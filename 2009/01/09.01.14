00:01:08 <MechaBlue> I did a lot of documentation work on HUnit in 6.8.3 but didn't get it into the mainline before 6.10.1 was released.  6.10.1 made some changes to how the library handles errors and now I'm trying to merge in the old documentation.
00:01:24 <MechaBlue> There aren't that many files and it's been at it for 4 hours.
00:01:44 <mornfall> You are using darcs-1 repository. That's part of the problem.
00:02:27 <mornfall> But yeah, darcs-2 isn't a miracle either.
00:03:15 <MechaBlue> Yeah
00:03:50 <mornfall> I'm trying to fix problems with darcs, but things like nonexistence of a decent http library in haskell makes things much harder than I'd like.
00:04:21 <vixey> write decent http library
00:04:43 <mornfall> vixey: Sorry.
00:05:19 <MechaBlue> I can understand that.  I have both repositories on my local machine, though, so it's not a networking issue.
00:06:41 <mornfall> MechaBlue: Well, the problem here is that we can't sell darcs-2, since there are numerous slowdowns in common operations.
00:07:07 <mornfall> MechaBlue: So people will keep using darcs-1 with the exponential merge algorithm.
00:08:02 <mornfall> And fixing darcs-2 turns out to be a real mess, since it has loads of things implemented inside that are missing in libraries.
00:08:11 <ddarius> :t curry
00:08:12 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
00:08:20 <vixey> sounds like a job for super-gwern!
00:08:40 <mornfall> And since I can't even get -ing cabal library upgrade installed, I guess darcs progress won't be that spectacular.
00:08:46 <ddarius> :t flip . curry
00:08:47 <lambdabot> forall a b c. ((a, b) -> c) -> b -> a -> c
00:08:48 <vixey> :t curry curry
00:08:50 <lambdabot>     Couldn't match expected type `(a, b)'
00:08:50 <lambdabot>            against inferred type `(a1, b1) -> c'
00:08:50 <lambdabot>     Probable cause: `curry' is applied to too few arguments
00:09:17 <ddarius> :t uncurry
00:09:18 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:09:24 <vixey> :t uncurry uncurry
00:09:25 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
00:09:45 <MechaBlue> Is there a list of shortcomings?
00:09:59 <mornfall> FFS. How do you tell cabal to install itself into ~/.cabal and not /usr/local?
00:10:57 <lepassive> I want some help in finding simple beginner level projects in haskell to learn from
00:12:55 <mornfall> So the workflow is. Try to compile darcs with HTTP pipelining. Fine, debian has old libcurl, install 7.19.2 from source. Find out that Cabal 1.6 screws up pkgconfig-depends (need to figure -v3, since it doesn't print a thing, just fails silently)... try to install Cabal HEAD. It insists on installing into /usr/local. *bang head against wall*
00:13:17 <mornfall> Viva yak shaving.
00:13:48 <vixey> mornfall, just gave me a great idea for a haskell logo :p
00:13:51 <mornfall> Ah right, --user.
00:14:29 <MechaBlue> lepassive: It's not glamorous but documentation is a good way to do.
00:14:57 <MechaBlue> lepassive: A lot of major features are not documented or could use some extra description.
00:15:00 <mornfall> \o/ pkgconfig problem solved.
00:15:06 <Raevel> haskell logo: http://i2.sitepoint.com/graphics/talk-to-the-hand-resized-115.jpg
00:15:11 <lepassive> MechaBlue, yes I now familiar with reading the APIs, but the best way to learn is to learn how to combine them together in a working sample
00:15:17 <MechaBlue> lepassive: At the same time, you can check out the code
00:15:24 <vixey> Raevel, I don't understand it
00:15:30 <Raevel> okay n/m then :-(
00:15:33 <MechaBlue> mornfall: Congrats
00:16:07 <MechaBlue> lepassive: How do you feel about writing a native HTTP library? ;)
00:16:09 <mornfall> MechaBlue: But the yak is now likely to die from cold...
00:16:49 <mornfall> MechaBlue: Fixing HTTP 4000 would possibly suffice. It's now about 50 % slower than curl in darcs, which ain't *that* bad.
00:16:54 <lepassive> MechaBlue, I can't do it easily with python I guess i should check out that after going on with simpler in Haskell :)
00:17:08 <lepassive> I can**
00:17:13 <mornfall> Well, it would also help to get pipelining.
00:17:39 <mornfall> It's in todo for I think what's years now.
00:18:14 <MechaBlue> Frankly, 50% slower is nothing as long as it's correct and feature complete.
00:18:29 <mornfall> MechaBlue: 50 % slower can get into tens of minutes.
00:18:37 <mornfall> It's on download time, not on CPU time.
00:18:45 <MechaBlue> Yeah
00:19:56 <MechaBlue> Does the ordering of patches matter in darcs?
00:20:27 <Workybob> well yes...
00:20:31 <Workybob> in that some depend on each other
00:20:35 <Workybob> but that's the only thing that matters
00:20:55 <mornfall> MechaBlue: For what?
00:22:12 <MechaBlue> Right now, I'm trying to merge my working version (based on 6.8.3) into the official release (6.10.1).  The official release has fewer changes.  Would it be significantly faster to be merging the other way instead?
00:24:12 <mornfall> MechaBlue: Dunno. It might make sense to cherry-pick just the patch(es) you are interested in. There might be other conflicts in there.
00:24:35 <mornfall> If you try to pull everything, you are likely to get many more conflicts in code that you are not interested in.
00:25:48 <lepassive> how far can i go with haskell as I study physics mainly not math ?
00:26:00 <mornfall> As far as you want, I guess. :
00:26:01 <mornfall> :)
00:26:06 * MechaBlue nods
00:26:34 <mornfall> David Roundy is in physics. (The original author of darcs.)
00:27:57 <lepassive> Well I am asking because of category theory (I didn't hear of it till I read about Monads) and it sounds a basic thing for haskellers
00:28:09 <mornfall> Don't worry.
00:28:34 <Adamant> it's not that basic in Haskell
00:28:47 <Adamant> you can write a fair amount of Haskell without knowing it
00:29:52 <lepassive> Adamant, well It's like coding in python without using classes as it there, you can use it and write a better code, but you don't
00:30:09 <mornfall> Not really.
00:30:13 <sleven> which algorithm is the easiest to implement for finding out if a matrix is invertible? gauss-jordan?
00:30:15 <MechaBlue> lepassive: There are two reasons that I work with Haskell.  The first is that there is a lot of promise, when compared to C++ and its derivatives.  The second is that there is never any shortage of things to learn.
00:30:16 <Adamant> I wouldn't even put it that way
00:30:32 <sleven> is hmatrix parallell?
00:30:47 <lepassive> MechaBlue, What is shortage ?
00:30:55 <mornfall> That reminds me.
00:31:20 <mornfall> Anyone ever tried to do parallel entries into GHC RTS? It seems to be very inefficient. : - (
00:31:25 <MechaBlue> lepassive: Shortage means "there is not enough".  There is always more to learn in Haskell.
00:31:32 <mornfall> (From C++ code, eg.)
00:31:59 <mornfall> MechaBlue: I wouldn't say it's particular to Haskell, though. :)
00:33:15 <lepassive> MechaBlue, I guess Haskell is kinda straight forward (in syntax) maybe not in the libS as I'm not so familiar with yet
00:34:25 <MechaBlue> lepassive: The syntax is fairly straightforward but a lot of the techniques are more interesting.  The type system, monadic programming, arrows, and stuff like GADTs that I haven't even looked at.
00:35:32 <lepassive> one thing for sure I'm going to do is getting some advanced math course in the summer
00:35:32 <MechaBlue> The libraries are usually boring because they focus on practical tasks that have been done many times before.
00:37:01 <ddarius> lepassive: Most expert Haskellers don't know anything about category theory.
00:37:41 <lepassive> ddarius, How come?
00:38:01 <ddarius> lepassive: Why would they?
00:38:51 <lepassive> ddarius, because they lead the community and should 've grasped all the aspects
00:39:15 <vixey> eh.....
00:40:00 <MechaBlue> You don't need to understand category theory in order to understand how monads work and how to apply them.
00:40:03 <vixey> lepassive, having a strong foundation in category theory is important prerequisite for using haskell?
00:40:56 <MechaBlue> A good understanding of category theory, as a whole, could take years to acquire.
00:41:19 <vixey> I think I know what a functor is :)
00:41:23 <vixey> but tha's about it.....
00:41:45 <lepassive> vixey, that's the point alot of articles pass that statement like it's a given to the reader. I'm studying engineering and never crossed on functor or whatever coming from category theory
00:42:11 <vixey> lepassive, so you read this somewhere? where
00:42:11 <vixey> ?
00:42:56 <lepassive> vixey, almost every Monad related article
00:44:05 <MechaBlue> Functor is a class in the Prelude module?
00:44:22 <ddarius> lepassive: You can "grasp" all of Haskell without understanding category theory, in the same way that you can grasp all of Haskell without understanding advanced data structure design or details of network protocols or formal methods.
00:45:35 <MechaBlue> How important is hugs support?
00:45:36 <mornfall> You evil people.
00:45:43 <mornfall> I have an exam in category theory next Monday.
00:45:49 <mornfall> Do you have to talk about it *just now*?
00:46:07 <lepassive> ddarius, uha like It comes with learning
00:46:14 <lepassive> mornfall, sorry to hear that :(
00:46:27 <mornfall> : - )
00:46:46 <osfameron> MechaBlue: apparently it's important to get at least 3 hugs per day
00:47:17 <lepassive> osfameron, LOL (#python doesn't like LOLz)
00:47:40 <ddarius> lepassive: No, like those areas may not be relevant to you.  Certainly, most of what falls under category theory doesn't apply to programming.
00:48:25 <lepassive> ddarius, but It's related to the design/philosophy of Haskell
00:48:34 <dolio> Just like you don't need several courses in abstract algebra to use Data.Monoid.
00:48:34 <ddarius> lepassive: What makes you think so?
00:49:27 <lepassive> Well my feeling is it's pure math in there
00:51:06 <lepassive> I've read most of YAHT/Learn yourself a Haskell and the wikibooks and feels like I'm stuck don't know what to do and RWH case studies sounds kinda informer not teaching not to mention complexity some how
00:51:25 <lepassive> wikibook*
00:51:41 <ordnungswidrig> :t :^:
00:51:43 <lambdabot> parse error on input `:^:'
00:52:11 * vinicius wonders if there are unicode characters for squiggol operators
00:52:16 <vinicius> *for all
00:53:04 <Saizan> lepassive: i think it's time to write and read some code then
00:53:05 <ordnungswidrig> :t (:^:)
00:53:06 <lambdabot> Not in scope: data constructor `:^:'
00:53:28 <ddarius> lepassive: If you are interested in the math, by all means study it.  If you are just interested in learning how to program in Haskell, all you need to know about functors and monads is covered in sections 6.3.5 and 6.3.6 of the Report.
00:53:34 <lepassive> Saizan, Well I asked about that and was told about writing a native HTTP lib :)
00:54:26 <Saizan> suggestions on what to write are never too serious :)
00:54:55 <sleven> is hmatrix parallell?
00:55:09 <sleven> link to the report¨ you seak of?
00:55:32 <dolio> Off the top of my head, I'd say it isn't.
00:55:43 <dolio> But that's just a guess.
00:56:09 <lepassive> ddarius, what report ?
00:56:44 <Saizan> @where report
00:56:45 <lambdabot> http://www.haskell.org/onlinereport/
00:57:27 <lepassive> wow is that a ready-to-copy report fore Haskell research at school ?
00:57:41 <lepassive> Just kidding
00:58:17 <dolio> @yow!
00:58:17 <lambdabot> Well, O.K.  I'll compromise with my principles because of EXISTENTIAL DESPAIR!
00:58:48 <mornfall> Oh. Lambdabot has swallowed sarahbot?
01:00:57 <vixey> "in certain languages with complex type systems, such as Haskell and Scala" -- ugh.....
01:01:24 <vixey> why is it "complex"?
01:02:14 <mornfall> vixey: Because it's not real? *hides*
01:02:16 <dolio> Just read "complex" as "good".
01:02:26 <sjanssen> vixey: coming from which perspective?
01:02:56 <sjanssen> for example, any type system looks complex compared to Java's
01:03:18 <dolio> Less so lately.
01:03:20 * vixey doesn't have a clue about javas <> stuff
01:03:25 <sjanssen> yeah, pre-generics
01:03:27 <dolio> Since they have parametric polymorphism now.
01:04:08 <dolio> And I think both sarahbot and lambdabot have swallowed the zippy fortune file.
01:04:43 <dolio> Although lambdabot's wasn't working for a while. And there was much gnashing of teeth.
01:04:50 <Saizan> that mix of parametric polymorphism and subtyping is not entirely clear to me, yet
01:06:07 <pejo> We should throw in some subtyping support in Haskell!
01:06:32 <dolio> Yeah. Just stick it in any old place.
01:06:39 <vixey> at the kind level!
01:06:57 <vegai> hmm, couldn't newtype vs data be derived by the compiler?
01:07:19 <vegai> so that data would work like newtype whenever there's just one constructor
01:07:30 <vegai> or is there something subtle going on
01:07:39 <vixey> vegai, I wonder if that would break the module system?
01:07:48 <quicksilver> vegai: there is something subtle going on.
01:07:55 <quicksilver> they have slightly different semantics.
01:08:10 <dolio> > let f (State s) = 5 in f undefined
01:08:11 <lambdabot>   5
01:08:19 <quicksilver> in a way which probably doesn't seem important, most of the time.
01:08:29 <quicksilver> but an optimisation which converted data to newtype would change semantics.
01:08:40 <vixey> like if I wrote data Foo x = Foo x  and exported Foo(..) in library Foo, then if Bar uses Foo and I change it to data Foo x = Foo x | Bar y would it break the Bar module?
01:09:04 <mornfall> sjanssen: I don't think generics changed the type system of Java in any interesting way.
01:09:08 <vegai> quicksilver: ok. Too bad.
01:09:10 <quicksilver> well (under ghc) that would change the interface
01:09:11 <dolio> You'd need to recompile Bar anyway.
01:09:16 <quicksilver> because you added a new constructor
01:09:22 <quicksilver> so that would force a recompile of Bar.
01:09:30 <sjanssen> mornfall: I just added that disclaimer since I'm not so experienced with Java generics
01:09:42 <mornfall> :)
01:09:55 <sjanssen> whereas I know from personal experience that Java pre-generics is trivial
01:10:04 <vegai> I just feel that this town isn't big enough for all those three type declaration thingies
01:10:14 <vegai> perhaps 'type' should go :P
01:10:22 <mornfall> vegai: How come?
01:10:30 <quicksilver> well type isn't a declaration thingy really
01:10:30 <mornfall> Take away type and I'll hit you. :)
01:10:37 <quicksilver> it's just a kind of alias
01:10:44 <vegai> quicksilver: yes, exactly
01:10:46 <mornfall> A very useful alias.
01:10:46 <vixey> type is a bit silly
01:10:57 <Saizan> yeah, i don't like type
01:11:02 <vixey> I don't see why  type Z = (X,Y)  is better than writing   Z = (X,Y)
01:11:06 <vegai> mornfall: uh oh :P
01:11:09 <quicksilver> I think it's not as useful as it could be because it doesn't handle class contexts well
01:11:12 <quicksilver> (is that right?)
01:11:29 <Saizan> it's only useful if you can work with that alias as an abstract type
01:11:34 <quicksilver> which is, kind of, because class contexts aren't really part of types.
01:11:40 <Saizan> otherwise you've to always care what it's an alias of
01:11:42 <quicksilver> which is annoying.
01:11:52 <quicksilver> Saizan: well it's just to save typing, I think
01:12:01 <mornfall> quicksilver: And reading!
01:12:04 <quicksilver> and to some extent, to permit simple refactorings.
01:12:09 <mornfall> It usually saves much more reading than typing.
01:12:09 <quicksilver> mornfall: right.
01:12:11 <ddarius> vixey: That conflicts with a pattern match.
01:12:55 <Saizan> i end up having to read more, since i've to jump between documentations to see what an alias is :)
01:13:22 <mornfall> Saizan: Abolish functions!
01:13:35 <mornfall> Saizan: Afterall, they make you jump to the documentation to see what they do.
01:13:40 <mornfall> *hides*
01:13:58 <Saizan> mornfall: the difference is that functions have a simple semantic that's shorter than their definition
01:14:11 <Saizan> while type synonyms rarely have that.
01:14:15 * ddarius is not sure how to name adjunctions.
01:14:56 <Saizan> that's what i meant with my former "abstract type" comment
01:15:42 <ddarius> Saizan: Would you rather see, Adjunction f u -> Adjunction (f :. f) (u :. u) or (forall a b. Iso (f a -> b) (a -> u b)) -> (forall a b. Iso ((f :. f) a -> b) (a -> (u :. u) b)) ?
01:15:59 <vixey> Adjunction f u -> Adjunction (f :. f) (u :. u)
01:16:35 <mornfall> Saizan: Hm, I found it useful to stack monad transformers. Although that might have been a crime against good manners. :)
01:17:03 <ddarius> mornfall: You should newtype monad transformer stacks.
01:17:07 <quicksilver> monad transformer stacks are better off newtyped, normally
01:17:18 <vixey> why? I never do that
01:17:54 <Saizan> ddarius: adjunction is a synonym? do i have to know about Iso to use it?
01:18:11 <ddarius> Iso is a data declaration and Adjunction is indeed a type synonym.
01:19:32 <TML> If ghci doesn't understand things like Ctrl-D to exit or "up arrow" for history, does that mean it didn't pick up my libedit0?
01:20:05 * ddarius has possibly the craziest but most compact definition of the state monad ever (if you only count the state monad specific stuff.)
01:20:26 <ddarius> Though edwardk may have me beat in craziness.
01:20:31 <vixey> lets see!
01:20:48 <Saizan> TML: yeah
01:21:11 <TML> Saizan: Spectacular. :I
01:21:59 <Saizan> TML: i'd install http://code.haskell.org/~judah/ghci-haskeline , at this point
01:22:05 <quicksilver> TML: or there is something funny about your libedit. It does seem to work unreliably for some people.
01:22:37 <ddarius> type State s = (->) s :. (,) s; stateAdjunction :: Adjunction ((,) s) ((->) s); stateAdjunction = Iso (flip . curry) (uncurry . flip); instance (Functor ((,) s), Functor ((->) s) => Monad (State s) where return = unit stateAdjunction; (>>=) = bind (multiplication stateAdjunction)
01:22:38 <Saizan> http://code.haskell.org/haskeline
01:23:07 <TML> Saizan: Well, I'm trying to create a reproducible build environment for SuSE Linux Enterprise Desktop so that I can push it into their 'openBuild' system, so I should probably try to fix it
01:23:20 <pozic> Why doesn't GHC accept: let Constructor{..} = f x -- with f x containing existentials? I get my brain exploded. It does say what one can do to remedy it, but why doesn't it accept it in the first place?
01:23:52 <quicksilver> pozic: because let bindings permit recursion.
01:24:15 <quicksilver> pozic: while existential unwrapping has to introduce a strict (non-recursive) scope
01:24:15 <opqdonut> ddarius: wow
01:24:54 <opqdonut> would you mind dissecting that in a blog entry or something?
01:25:16 <ddarius> opqdonut: It's part of an article I'm considering making for the Monad Reader.
01:25:22 <opqdonut> ah, great :)
01:25:24 <pozic> quicksilver: Why does it have to introduce a strict scope?
01:25:27 <vixey> nice
01:25:29 <quicksilver> ddarius: why the Functor contexts?
01:25:36 <opqdonut> which issue? the next one?
01:25:38 <quicksilver> pozic: because it introduces a new type variable.
01:25:51 <ddarius> quicksilver: Probably because I haven't imported the modules that define those instances.
01:26:01 <quicksilver> ddarius: ah, OK.
01:27:04 <pozic> quicksilver: I am sorry, I don't really get it. I just see existentials as values on which certain functions available in type classes can be called on and let, in this case a record pun, to introduce variables into scope.
01:27:55 <quicksilver> pozic: well, I wasn't sure what level to answer your question at.
01:28:40 <quicksilver> pozic: if you have an existential constructor "Foo :: forall a . a -> Foo"
01:28:51 <quicksilver> then when you do "case f of Foo x -> .... "
01:29:00 <quicksilver> then 'x' has an unknown type
01:29:11 <quicksilver> so you mustn't let it escape from that scope
01:29:15 <quicksilver> because you don't know what it is.
01:29:18 <ddarius> opqdonut: The next one is what I'm aiming for.  It depends on whether I get enough to talk about and enough code.
01:29:25 <quicksilver> you couldn't type check anything where it escaped.
01:29:58 <pozic> quicksilver: that makes sense, although in this case the type would always be () and could be statically known.
01:30:24 <quicksilver> if the type could be statically known, why is it an existential?
01:30:33 <quicksilver> if the type is statically known, just use the type...
01:30:48 <pozic> quicksilver: no, I was confusing something.
01:36:30 <Saizan> but, what's the technical problem for type inference/checking?
01:37:55 <Saizan> with let Foo x = <expr>, you've to add something like [x : exists a. a] to the context when typechecking <expr>
01:38:49 <Saizan> but that doesn't look much different from the 'case' case
01:39:19 <quicksilver> Saizan: it would be fine if you restricted the recursion, afaik.
01:39:39 <quicksilver> let Foo x = <expr mentioning y>; Foo y = <expr mentioning x>; in ...
01:39:46 <quicksilver> would be a problem though ;)
01:40:04 <quicksilver> indeed, it's a problem even if only one of the two is an existential unwrap.
01:40:28 <quicksilver> but rather than have an adhoc rule outlawing recursion in lets which unwrap existentials, they simply require you to use case
01:40:36 <quicksilver> which is defined to be non-recursive.
01:40:55 <pozic> quicksilver: using Foo{..} <- return <expression> works, but I consider that a hack too.
01:41:10 <Saizan> that's the same as lambda/case
01:41:14 <quicksilver> yes, because that desugars to case.
01:41:40 <pozic> But case introduces another level of indentation.
01:41:55 <Saizan> quicksilver: i don't see why it'll be a problem with mutual recursion, can you elaborate?
01:42:52 <quicksilver> the unwrapped existential type escapes and appears in the context of its own typing judgement
01:44:10 <pozic> quicksilver: isn't that an implementation detail of the type checker?
01:44:29 <quicksilver> I think so, yes.
01:44:38 <quicksilver> I think this is a GHC quirk in a sense.
01:44:42 <Saizan> i don't see that as a problem, as long as it doesn't appear in the resulting type
01:44:49 <quicksilver> "GHC does not allow such matching. More generally, GHC does not allow matching of existentially quantified constructors inside irrefutable patterns (of which let pattern bindings are a special case). It is said that the translation to GHC's intermediate language is problematic. "
01:44:57 <quicksilver> Saizan: I agree. But you would need to check it didn't.
01:45:10 <quicksilver> Saizan: (not even indirectly)
01:45:38 <Saizan> indirectly?
01:47:26 <quicksilver> well, that was a bit of a silly qualification.
01:47:40 <quicksilver> 'not anywhere in the resulting types'
01:47:46 <Saizan> ah ok :)
01:51:13 <devilx0>  :o
02:03:07 <vixey> hi BONUS
02:10:06 <BONUS> heyo
02:10:15 <BONUS> did you guys figure anything out about those zippers
02:10:44 <vixey> well I am pretty sure there is no simple way to make a zipper for some F that holds (e -> F a)
02:11:33 <BONUS> ah hmm. what about what quicksilver is saying, that he thinks zippers are (a, Context a)
02:11:35 <vixey> because you have to subtract ()
02:11:39 <BONUS> instead of (F a, C a)
02:11:49 <BONUS> that seems kind of strange to me because how are you going to walk around then
02:12:14 <vixey> well the thing with (a, Context a) is, how do you write the function --> F a
02:12:21 <vixey> back to the unzipped data
02:12:28 <BONUS> hmm yeah
02:12:32 <quicksilver> that's one of the functions you have to write, yes
02:12:35 <quicksilver> (is that a problem?)
02:12:42 <vixey> I just don't see how it is possibl
02:12:56 <quicksilver> you turn the context inside out and stuff the value back in
02:13:07 <quicksilver> it's a structural induction over the context.
02:13:34 <BONUS> for instance, if you have a binary tree that has elements in all nodes, what would you store in the context then
02:13:37 <BONUS> if you have (a, C a)
02:13:58 <quicksilver> BTree a = Leaf a | Branch a (Tree a) (Tree a), right?
02:14:03 <BONUS> yeah
02:14:07 <quicksilver> sorry, s/Tree/BTree/ in the last two.
02:14:26 <Peaker> why not: BTree a = Empty | Branch a (BTree a) (Btree a)   ?
02:14:44 <vixey> Tree a = Leaf a | Branch (Tree a) (Tree a)
02:14:44 <BONUS> yeah Peaker's version i like better
02:14:51 <Peaker> (So values are always in Branches)
02:14:51 * quicksilver shrugs
02:14:52 <vixey> is what we were looking at yesterday
02:14:58 <vixey> BTree a = Leaf a | Branch a (BTree a) (BTree a)
02:15:01 <BONUS> both a little i think
02:15:01 <quicksilver> if you permit empty trees
02:15:08 <quicksilver> then your zipper is only over non-empty ones
02:15:13 <quicksilver> you can't focus on an empty tree
02:15:18 <quicksilver> nothing to focus on!
02:15:25 <BONUS> hmm
02:15:52 <vixey> oh
02:15:55 <Peaker> quicksilver: why not have a NoFocus constructor too then? :-)
02:16:09 <quicksilver> Peaker: because the form we are discussing is (a, C a)
02:16:17 <quicksilver> it's meaningless form unless there is always an a.
02:16:20 <vixey> what about  Head a = Eye a | Neck [Heads a]  ?
02:16:23 <vixey> what's the zipper for that
02:16:25 <quicksilver> there are choiches here.
02:16:26 <Peaker> quicksilver: the "a" is not the Empty itself?
02:16:39 <quicksilver> Peaker: "a" is the value type
02:16:41 <BONUS> quicksilver: of course you can focus on an empty tree
02:16:43 <quicksilver> stored at the nodes.
02:16:47 <quicksilver> BONUS: it's a choice.
02:16:47 <vixey> and  Head' a = Eye' a | Neck' (Tree (Heads' a))
02:16:50 <BONUS> ah
02:16:57 <quicksilver> BONUS: I'm saying that, in the "(a,C a)" version
02:16:58 <quicksilver> you can't.
02:17:04 <BONUS> oh in that version
02:17:05 <BONUS> yeah
02:17:07 <Peaker> quicksilver: oh, that means there's exactly one a in each node, right?  Why commit to that?
02:17:08 <quicksilver> because that formulation is all about focussing on elements.
02:17:10 <BONUS> there's no a in the empty tree
02:17:29 <quicksilver> Peaker: we've got to make some choices so we agree what we're discussing.
02:17:36 <vixey> and (F a, C a) is for focusing on subtrees
02:17:46 <quicksilver> agreed.
02:18:00 <quicksilver> BTree a = Empty | Branch a (BTree a) (Btree a)
02:18:05 <quicksilver> then the Ctx is
02:18:06 <BONUS> what do you store in the context if you use (a, C a) then
02:18:20 <BONUS> so that you can go, say, to the value that's left of a
02:18:22 <BONUS> or right of a
02:18:50 <quicksilver> CtxBT a = Top | CtxBT (CtxBT a) (BTree a) (Btree a)
02:19:09 <quicksilver> and the 'unzip' that vixey was asking about is
02:19:16 <quicksilver> unzip (a,Top) = Branch a Empty Empty
02:19:22 <BONUS> ah
02:19:44 <BONUS> wouldn't you need to do CtxBT a = Top | CtxBT (CtxBT a) a (Btree a) (Btree a)
02:19:48 <BONUS> if you allow all nodes to have elements
02:20:01 <quicksilver> no, because we store the focussed element outside the context
02:20:04 <quicksilver> (a, C a)
02:20:20 <quicksilver> in this example.
02:20:20 <BONUS> i was thinking that the a represents the value of the element above it
02:20:45 <quicksilver> it's like representing text selections, actually
02:20:49 <quicksilver> there are at least three choices:
02:20:58 <quicksilver> "insertion point" - context only, no selection
02:21:12 <quicksilver> "cursor on character" - context focussed on a single char
02:21:21 <quicksilver> "selected string" - context focussed on a substructure
02:21:30 <quicksilver> I think you can make cases for all three, sometimes.
02:21:33 <BONUS> aha, that makes sense, yes
02:21:53 <quicksilver> and you can implement them in terms of each other to some extent.
02:23:38 <quicksilver> as to which one "The Zipper" is really supposed to refer to, I can't remember.
02:26:34 <quicksilver> even "substructure" is a choice.
02:26:53 <quicksilver> If you allow yourself to be guided by the standard recursive definition, then only tails are substructures of lists.
02:27:01 <quicksilver> but if you ignore the definition and consider an abstract notion of list.
02:27:09 <quicksilver> then any slice might be a substructure.
02:27:16 <Saizan> then we can ask on which one of those the derivative of F really corresponds
02:27:17 <quicksilver> (this is what you want for text selection)
02:27:34 <quicksilver> if you have a mathematical frame of mind you might permit any subseqence
02:27:38 <ski_> (vixey : "some F that holds (e -> F a)" ?)
02:27:40 <vixey> for (a,a) you have Context = Left a | Right a
02:27:43 <quicksilver> (not necessarily consecutive)
02:27:56 <quicksilver> Saizan: well the derivative is based on the actual definition
02:28:00 <quicksilver> it's an algebraic thing.
02:28:08 <quicksilver> so if you use List a = a | Cons a (List a)
02:28:10 <vixey> for (a,a,a) you have Context = Left a a | Middle a a | Right a a
02:28:25 <quicksilver> then you will get the "substructures are tails" interpretation.
02:28:33 <Saizan> quicksilver: yeah, but if i take the derivative, do i get C in the (a,C a) or (F a,C a) sense?
02:28:45 <vixey> ski_, what about it?
02:28:46 <ski_> Saizan : the former
02:28:53 <ski_> vixey : what does it mean
02:28:54 <ski_> ?
02:29:06 <vixey> data F a = F (a -> F a)
02:29:07 <vixey> oops
02:29:09 <vixey> data F a = F (e -> F a)
02:29:16 <BONUS> vixey ... in Left a a, the two fields are the values of the middle and right components, right?
02:29:24 <vixey> yes
02:29:30 <BONUS> so that's forall e. there?
02:29:56 <ski_> Saizan : to get the latter, you have to decompose `F a' into `FF a (F a)' and take the derivative of `FF a' (and possibly a little more work), iirc
02:30:26 <ski_> probably `e' is free there ..
02:30:40 <Saizan> deriving wrt the recursive variable?
02:30:54 <Saizan> err
02:30:56 <ski_> (s/deriving/differentiating/)
02:31:20 <ski_> (or maybe "taking derivative")
02:31:26 <Saizan> FF a f differentianting on f?
02:31:42 <ski_> yes
02:31:44 <ski_> f :: *
02:32:06 <ski_> actually, i think it was slightly more complicated than that
02:32:12 <ski_> consider
02:32:26 <ski_> data List a = Nil | Cons a (List a)
02:32:44 <quicksilver> My informal experience is that when the recursion has semantic significance, you want the
02:32:48 <ski_> so you can define a
02:32:48 <quicksilver> (F a,C a) version.
02:33:04 <quicksilver> but when the recursion is merely a programattic device, you want the (a, C a) version.
02:33:06 <ski_> data ListF a r = NilF | ConsF a r
02:33:12 <quicksilver> that's not very formal, but there it is.
02:33:20 <ski_> such that `List a' is iso to `Mu (ListF a)'
02:33:34 <Saizan> yeah
02:33:53 <ski_> however, `D (ListF a)' will only select the direct child node
02:34:04 <sleven> how much stackspace does ghc allocate by default? can i request more?
02:34:15 <ski_> we want to either select the root node, or a child node, or a grandchild node, et.c.
02:34:31 <vixey> and the zipper for:  data Clause a = Atom a | Functor (List (Clause a))   given data ListContext a = Stop | Pop a (ListContext a) ..
02:34:33 <ski_> so we want to compose `ListF a' with itself
02:35:09 <ski_> and then take the derivative of the resulting thing
02:35:28 <vixey> is data ClauseContext a = At | Enter (ListContext (ClauseContext a)) ?
02:35:50 <ski_> the composed version might be
02:36:24 <ski_>   data ListFW a r = Here r | NilFW | ConsFW a (ListFW a r)
02:37:00 <Saizan> vixey: yeah the zipper of [[a]] is ListZipper (ListZipper a)
02:37:20 <vixey> so data ClauseContext a = At | Enter (ListZipper (ClauseContext a))
02:37:46 <vixey> maybe.. (ListZipper ClauseContext a)
02:38:03 <lilac> Peaker: pong
02:38:12 <vixey> Zipper :: (* -> *) -> (* -> *) -> * ?
02:38:19 <ski_> vixey : i'm not sure that's right
02:38:33 <ski_> (the `ClauseContext' and `ListContext' things ..)
02:39:13 <ski_> (vixey : also, it might help if you tell which sense of `Zipper' you intend, here)
02:39:57 <ski_> (i think you intend the derivative .. but i'm not sure)
02:40:00 <vixey> subterm zippers
02:40:14 <vixey> Z a = (F a, C a)
02:40:23 <TML> Good grief, I think ghc takes longer to build than gcc+glibc
02:41:07 <vixey> I think I can use: Zipper f c a = (f a, c a)
02:41:31 <vixey> (maybe in paper zipper would take the codes of the types f and c and actually compute the zipper though)
02:43:54 <ski_> vixey : can you complete the `..' in the definition of `ListContext' ? (or was it complete ?)
02:44:02 <cjs> I am constantly doing something like x { accessor = f (accessor x) }. Is there some nicer way to do this without the constant repetition of the accessor?
02:44:11 <sbahra> Where could I order a nice Haskell shirt from?
02:44:20 <cjs> I've asked this before, actually.....
02:44:23 <vixey> if <<_>> is what you are focusing on, with  [a,b,c,d,e,<<f,g,h]>>  it's tricky how to get the 'f' out
02:44:27 <Saizan> cjs: write an helper function
02:44:27 <vixey> (or enter into the 'f')
02:44:31 <cjs> I guess I can do that get/set thing....
02:44:33 <ski_> cjs : functional lenses, i think
02:44:47 <cjs> Saizan: The problem is, accessor always changes.
02:45:07 <vixey> it looks like you have to use a element focusing zipper for nested data types...
02:45:29 <ski_> (vixey : .. yes or no ?)
02:45:43 <vixey> ski_, It was just plain wrong I think
02:45:50 <ski_> Saizan : i probably lost you, right ?
02:46:11 <Saizan> cjs: have one for each, or http://hackage.haskell.org/packages/archive/derive/0.1.4/doc/html/Data-Derive-Ref.html
02:48:02 <Saizan> ski_: D (ListF a) = Cons a?
02:48:27 <ski_> yes
02:48:30 <ski_> fairly useless
02:48:37 <cjs> Saizan: looks like what I need, though I guess it needs template haskell?
02:48:52 <ski_> we need `D ((ListF a)^N)' more or less
02:48:56 <Saizan> cjs: yes, or the derive preprocessor
02:49:41 <cjs> Hm. I will have to investigate this one day.
02:50:32 <Saizan> well, it's simple to use it like $(derive makeRef ''YourType)
02:51:15 <Saizan> ski_: the element-focusing zipper looks much simpler :)
02:51:46 <cjs> All that stuff is way beyond me a the moment.
02:52:35 <BONUS> i'm trying to make an element focusing zipper for a binary tree now and it's turning out to be more complicated and less elegant than the subtree focusing one
02:52:50 <BONUS> i might be doing something wrong though
02:53:15 <Saizan> are you taking the derivative algebraically?
02:53:28 <vixey> of this one BONUS BTree a = Leaf a | Branch a (BTree a) (BTree a) ?
02:53:34 <BONUS> yeah of that one
02:53:49 <BONUS> Saizan: what do you mean by that
02:54:10 <vixey> how about CLeaf | CBranch (BTree a) (BTree a) | CBranchLeft a (BTree a) | CBranchRight a (BTree a)
02:54:16 <vixey> for the Context
02:54:33 <Saizan> T a = Leaf a | Branch a (T a) (T a) ~~ T a = a + 2a(T a)
02:54:38 <BONUS> hmm
02:54:51 <Saizan> then just take the derivative like in calculus
02:54:54 <BONUS> currently for the context im trying Top |Ctx (Ctx a) a (Tree a) (Tree a)
02:54:55 <vixey> zipUp (a, CLeaf) = Leaf a; zipUp (a, CBranch l r) = Branch a l r | ...
02:54:59 <Saizan> wrt a
02:55:18 <ski_> (quicksilver : btw, just by taking an abstract type `List a' defined by `data List a = a | Cons a (List a)' you don't get selection on tails ..
02:55:20 <BONUS> so it's basically the upper context, the upper value and the left branch of the upper value and the right branch of it
02:55:23 <vixey> Leaf a | Branch a (T a) (T a)  ~  a + a * Ta * Ta
02:56:07 <boegel> Don Steward was interviewed by the Intel folks, has anyone heard it?
02:56:25 <vinicius> link
02:56:50 <BONUS> boegel: yeah i heard it, pretty good listen
02:59:58 <ski_> (BONUS : it would be simpler if you could decide to have elements in nodes *xor* leaves ..)
03:00:26 <BONUS> yeah, could be
03:00:40 <BONUS> although i'm at a loss, for instance, if you're focusing at the root of a tree in that way
03:00:47 <BONUS> do you then do (root_element, Top)
03:01:03 * ski_ wonders if the context inversion shows up in the math, and if so, how ..
03:01:03 <BONUS> cause that doesn't give you any info about the structure whatsoever
03:01:09 <BONUS> i think you gotta invert it yeah
03:01:36 <ski_> BONUS : i thought you were focusing on elements !?
03:01:52 <BONUS> yeah i am
03:01:53 <lilac> data Tree a = Leaf a | Branch a (T a) (T a) => data ZipperTree a = LeafFocus a (TreeContext a) | BranchFocus a (Tree a) (Tree a) (TreeContext a); data TreeContext a = NilContext | UnBranch1 a (T a) (TreeContext a) | UnBranch2 a (T a) (TreeContext a)
03:02:11 <ski_> BONUS : so you can't focus on the root, since the root isn't an element (it's a tree)
03:02:17 <lilac> data List a = Null | Cons a (List a) => data ZipperFocus a = ConsFocus a (List a) (ListContext a); data ListContext a = NilContext | UnCons a (ListContext a)
03:02:22 <BONUS> sorry, yeah i meant focusingon the element in the root
03:02:52 <lilac> should be pretty simple to automate this translation with TH
03:04:57 <ski_> (lilac : though that's going *via* the substructure focuser ..)
03:13:53 <hugo___> hi
03:15:14 * ski_ goes back to trying to implement Loebs theorem ..
03:15:46 <vegai> @hoogle String -> Handle
03:15:47 <lambdabot> Prelude error :: String -> a
03:15:47 <lambdabot> Debug.Trace trace :: String -> a -> a
03:15:47 <lambdabot> Distribution.ReadE readEOrFail :: ReadE a -> String -> a
03:15:57 <vegai> @hoogle String -> IO Handle
03:15:58 <lambdabot> Distribution.Simple.Utils die :: String -> IO a
03:15:58 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
03:15:58 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
03:16:13 <vegai> hmm, guess not.
03:16:38 <ski_> @type openFile
03:16:39 <lambdabot> Not in scope: `openFile'
03:16:57 <ski_> @type System.IO.openFile
03:16:58 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
03:17:10 <ski_> (you were looking for that ?)
03:17:51 <vegai> I was actually looking at System.Process.runProcess and wondered whether one could supply Strings as stdin/stdout/stderr
03:20:00 <vegai> so, I looked for something that would transmogrify a String to a Handle
03:21:16 <Saizan> i think you want runInteractiveProcess
03:21:58 <Saizan> or readProcess
03:22:23 <jeffz``> vegai: something like string ports from scheme?  I've wondered that too.
03:22:51 <hugo___> i was reading the set of design principles of the python programming language on LtU... seems some of them are incompatible with haskell
03:23:29 <hugo___> but its quite an interesting read, check it: http://python-history.blogspot.com/
03:23:56 <vegai> jeffz``: yes, indeed
03:24:41 <vegai> Saizan: yes, readProcess
03:25:27 <vegai> readProcess is strict, though
03:25:58 <vegai> on the return value. Cannot really use it to create large pipelines, I assume that means
03:27:32 <Saizan> eh, no
03:27:43 <Saizan> ?hackage HSH
03:27:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH
03:28:46 <Saizan> vegai: that might work for you, otherwise i think you've to create pipes
03:37:37 <Saizan> ?hoogle Iso
03:37:38 <lambdabot> Data.Char isOctDigit :: Char -> Bool
03:37:38 <lambdabot> package EdisonAPI
03:37:38 <lambdabot> package EdisonCore
03:37:56 <Saizan> ?hackage category-extras
03:37:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
03:39:18 <Saizan> don't we need a standard Iso class?:)
03:39:55 <lilac> for isomorphisms?
03:40:21 <lilac> or for international standards?
03:41:10 <Saizan> isomorphisms
03:41:45 <lilac> instance Iso String where iso _ = 10646
03:44:00 <BONUS> alright, here's two zippers for a binary tree that i made http://hpaste.org/13918#a1
03:44:09 <BONUS> first is in the form (F a, C a) and the second is (a, C a)
03:44:24 <BONUS> but the second one seems less elegant and there's even redundant data in the context :\
03:44:40 <wjt> I enjoy how http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Object.html explains that the classes are defined with associated types not fundeps in the preamble, but that's not true at all
03:47:02 <lilac> BONUS: the second one looks plain wrong
03:47:12 <BONUS> i wouldn't be surprised
03:47:18 <BONUS> but i tried it out a bit and i can traverse it and all
03:47:24 <lilac> BONUS: it doesn't seem to allow O(1) updates of the focus
03:47:31 <ski_> Saizan : there may be several isomorphisms between two types ..
03:47:48 <lilac> BONUS: primarily because the 'focus' element is actually repeated multiple times
03:47:58 <BONUS> yeah you're right
03:48:03 <BONUS> :\
03:48:22 <pozic> Is there any possible way that class A a where bar::(Show x)=> a -> x might be useful?
03:48:48 <lilac> data ZipperTree a = LeafFocus (TreeContext a) | BranchFocus (Tree a) (Tree a) (TreeContext a); data TreeContext a = NilContext | UnBranch1 a (T a) (TreeContext a) | UnBranch2 a (T a) (TreeContext a)
03:49:01 <lilac> then (a, ZipperTree a) is a zipper
03:49:51 <BONUS> hmmm
03:49:51 <vixey> how about CLeaf | CBranch (BTree a) (BTree a) | CBranchLeft a (BTree a) | CBranchRight a (BTree a)?
03:50:12 <lilac> vixey: that type contains elements you don't want.
03:50:24 <vixey> such as
03:50:25 <vixey> ?
03:50:43 <BONUS> the zippers where you focus on a substructure of the functor seem a lot simpler
03:51:27 <Saizan> pozic: no
03:51:34 <vixey> BONUS, consider:  data BTreeContext a = CLeaf | CBranch (BTreeContext a) (BTreeContext a) | CBranchLeft a (BTreeContext a) | CBranchRight a (BTreeContext a)
03:51:37 <vixey> BONUS, isn't that it?
03:51:50 <lilac> vixey: what tree is represented by the context (1, CBranchLeft 2 CLeaf)
03:52:27 <BONUS> or if we have (2, CLeaf), considering that means that we're at a leaf
03:52:28 <pozic> Saizan: because the problem is that it states that the method returns the intersection of the types in the Show class, right?
03:52:29 <BONUS> how do we move up
03:52:58 <pozic> Saizan: and to implement that we can only pick _!_.
03:53:06 <vixey> ah
03:53:26 <vixey> data BTreeContext a = CLeaf | CBranch (BTree a) (BTree a) | CBranchLeft a (BTreeContext a) (BTree a) | CBranchRight a (BTreeContext a) (BTree a)  then ?
03:53:31 <lilac> BONUS: you actually already have your answer
03:53:31 <Saizan> pozic: yeah
03:53:36 <vixey> this seems inside out though
03:53:43 <lilac> BONUS: in your first paste, look at your type Ctx.
03:53:55 <BONUS> yeah
03:53:55 <lilac> both constructors have an 'a' (the focus)
03:54:04 <lilac> take that out to form a Ctx'
03:54:10 <BONUS> lilac: thats not the focus
03:54:19 <BONUS> that's the value in the parent node
03:54:38 <sbahra> learnmeahaskell.com is down?
03:54:42 <lilac> BONUS: oops. what i meant was, Loc a = (Tree a, Ctx a)
03:54:48 <quicksilver> @where lyah
03:54:49 <lambdabot> www.learnyouahaskell.com
03:54:52 <sbahra> Ah
03:54:53 <BONUS> :]
03:54:54 <lilac> ... actually ...
03:54:55 <sbahra> learnyou :)
03:55:03 <quicksilver> sbahra: no, learnyou, I insist!
03:55:37 <koeien> ha! my copy of RWH is here!
03:55:45 <lilac> BONUS: i think i've missed the point here. the difference between (f a, c a) and (a, c a) is that not all f a actually contain a focus element
03:55:47 <Saizan> BONUS: http://notvincenz.blogspot.com/2007/07/higher-order-zippers.html
03:56:11 <BONUS> lilac: yeah, they focus on part of the substructure
03:56:16 <lilac> BONUS: the one i gave above is (a, c a) and your paste is (f a, c a)
03:56:25 <Saizan> before it gets to the higher-order part it explains the derivation of zippers from derivatives quite well
03:56:29 <BONUS> yeah, the second paste is supposed to be (a, c a)
03:56:33 <BONUS> but it's wrong
03:56:38 <lilac> BONUS: but my one is for a different tree type ;-)
03:56:43 <BONUS> ah Saizan i'll give that a read
03:56:48 <BONUS> ooh aha i see
03:57:49 <lilac> data Tree a = Leaf | Tree (Tree a) a (Tree a) => data TreeFocus = TreeFocus (Tree a) a (Tree a) (TreeCtx a); data TreeCtx a = TreeCtxL a (Tree a) | TreeCtxR (Tree a) a
03:58:11 <BONUS> quicksilver: could you take a look at http://hpaste.org/13918#a1 later ... it's supposed to be a zipper in the form of (a, C a) and the context is kind of like the context that you wrote earlier today, but the whole zipper is off cause it doesnt allow O(1) updates
03:58:35 <BONUS> hmm lilac
03:58:48 <lilac> if you prefer, data TZ a = TZ (Tree a) (Tree a) (TC a); data TC a = L a (Tree a) | R (Tree a) a; data TreeZipper = (a, TZ a)
03:58:58 <lilac> oops, that last data was supposed to be a type ;-)
03:59:10 <BONUS> ah yeah it's easier for me to understand them in that way
03:59:12 <BONUS> let's see now
04:00:18 <lilac> data Down a = Down (Tree a) (Tree a); data Up a = L a (Tree a) | R (Tree a) a; type TreeZipper a = (a, Up a, Down a)
04:00:34 <vixey> I don't get it
04:01:04 <lilac> in the (a, c a) formulation, you only have values at locations in the tree where there is an 'a'
04:01:22 <lilac> so you don't have values at leaves for BONUS' Tree type
04:01:47 <lilac> 'Up a' should also have a 'Top' case
04:01:52 <ski_> lilac : shouldn't you have a list of `Up a' .. or something ?
04:02:18 <lilac> data Up a = Top | L a (Tree a) (Up a) | R (Tree a) a (Up a)
04:02:20 <lilac> better
04:02:24 <ski_> right
04:02:54 * lilac forgot to recurse in the transformation ;-)
04:03:09 <BONUS> yeah haha
04:03:46 <vixey> oh
04:03:47 <ski_> what exactly are we quibbling about, rn ?
04:03:56 <vixey> ok
04:06:47 <vixey> can you take zippers of GADTs
04:08:27 <ski_> any specific one you'd like us to consider ?
04:08:40 <vixey> how about data Hilbert t = (:$:) :: Hilbert (a -> b) -> Hilbert a -> Hilbert b; K :: Hilbert (a -> b -> a); S :: Hilbert ((a -> b -> c) -> (a -> b) -> (a -> c)
04:08:50 <vixey> )
04:08:54 <ski_> (even just nonregular might be illuminating)
04:10:17 <ski_> and i suppose you want to focus on a sub-`Hilbert' ?
04:11:01 <ski_> (possibly the inverted and the non-inverted cases will be different here ..)
04:11:16 <vixey> I have got to go
04:11:25 <ski_> oh
04:11:36 <ski_> ttyl, then
04:11:43 <vixey> later
04:14:37 <mmorrow> data Cxt a = Top a | Loc a (a -> Cxt a)
04:15:05 <mmorrow> (re: TreeZipper)
04:16:55 <ski_> how would that work ?
04:17:23 <ski_> there's no `Tree a's in there
04:18:36 <mmorrow> downTree :: Int -> Cxt (Tree a) -> Maybe (Cxt (Tree a)); downTree n (Loc (Node x xs) k) = case splitAt n xs of (ls,r:rs) -> Just (Loc r (\r -> Loc (Node x (ls++r:rs)) k)); _ -> Nothing
04:18:43 <quicksilver> Loc a (a -> Tree a)
04:18:44 <quicksilver> surely.
04:18:58 <mmorrow> nono, Loc a (a -> Cxt a)
04:19:04 <mmorrow> becasue
04:19:17 <mmorrow> putIn tree = Top tree
04:19:49 <ski_> oh .. `Cxt (Tree a)'
04:19:50 <mmorrow> i have some code for this somewhere, it illustrates better than a jumbled one-line
04:19:51 * ski_ hms
04:20:00 * mmorrow looks for it
04:21:21 <ski_> mmorrow : and `upTree' ?
04:21:50 <mmorrow> upTree (Loc a k) = k a
04:22:05 <mmorrow> upCxt it should be. ..
04:22:11 <mmorrow> (since it's generic)
04:22:35 <mmorrow> and top (Top a) = a; top (Loc a k) = top (k a)
04:22:38 <ski_> mmorrow : but that just walk up to the root, no ?
04:22:57 <mmorrow> just one level
04:23:07 <mmorrow> i'll paste
04:23:13 <ski_> oh .. right
04:23:17 <ski_> `a -> Cxt a'
04:23:36 <ski_> that's nice :)
04:25:19 <ski_> shantih! shantih! shantih!
04:30:33 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=762#a762
04:36:56 <mmorrow> err, that "intoC" is broken
04:37:12 * Saizan wonders if he has to reimplement unification if he wants his STLC prolog typechecker to not type Y
04:37:18 <mmorrow> (i tried to make a generic one, but that was a bad try)
04:37:40 <ski_> (though, i'm not sure if having `Top' in `Cxt' is right ..)
04:38:11 <mmorrow> you'd have to, otherwise you couldn't get into a Cxt
04:39:18 <ski_> couldn't one `newtype Cxt a = Loc a (a -> Either a (Cxt a))' ?
04:44:20 <dcoutts> if cabal is going to warn if your package index is more than X days old, what is a reasonable value of X to start bugging people?
04:45:00 <dcoutts> obviously it would be better if it could check more automatically but we're implementing a quick hack here
04:45:41 <dcoutts> for example if it did this, would that really get on people's nerves:
04:45:46 <dcoutts> Warning: The package list for 'hackage.haskell.org' is 15 days old. Run 'cabal
04:45:46 <dcoutts> update' to get the latest list of available packages.
04:51:56 <mmorrow> ski_: here's a little interactive treewalker editline repl http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=762#a763
04:53:28 <mmorrow> dcoutts: maybe if it just said "package index age: X days" everytime it ran
04:53:50 <dcoutts> mmorrow: I think that would get annoying :-)
04:53:53 <mmorrow> heh
04:53:59 <mmorrow> i'd find it informational
04:54:01 <dcoutts> since it'll print this for more or less every command
04:54:05 <mmorrow> oh
04:54:11 <dcoutts> each one that inspects the package index
04:54:18 <ski_> mmorrow : that code duplication seems to me like it might be naturally avoided by changing the context representation ..
04:54:27 <mmorrow> i was thinking it'd do it only for cabal install
04:54:45 <dcoutts> also, fetch, upgrade, list etc
04:54:49 <mmorrow> ski_: i dunno. any change would make it less simple
04:55:17 <mmorrow> and i was just lazy and coding quick to do that function nicely
04:56:10 <etech> Hello
05:00:28 <gio123> what is a deference between  breath-firsts and iterative deepenings
05:00:29 <gio123> ?
05:00:46 <mmorrow> ski_: like this i guess http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=762#a764
05:01:37 <mmorrow> ski_: Cxt a is already iso to Either a (Cxt a) essentially, because of Top
05:02:36 <mmorrow> Cxt a = Either a (a, a -> Cxt a) = (Top a | Loc a (a -> Cxt a))
05:05:25 * sw17ch yawn
05:11:36 <ski_> (mmorrow : not `Either a (Cxt a)' though ..)
05:12:07 <mmorrow> but what do you gain from having both (Left a) and (Right (Top a)) ?
05:12:22 <mmorrow> chopC (Top a) = a; chopC (Loc a _) = a
05:12:43 <mmorrow> Top . chopC
05:13:22 <ski_> i'm not sure why one would have `Left a' and `Right (Top a)' ..
05:14:11 <ski_> i was (attempting to) consider `newtype Cxt a = Loc a (a -> Either a (Cxt a))' ..
05:15:08 <ski_> so you could do
05:15:23 <ski_>   root :: a -> Cxt a
05:15:32 <ski_>   root a = Loc a Left
05:16:02 <ski_>   up :: Cxt a -> Either a (Cxt a)
05:16:12 <ski_>   up (Loc a k) = k a
05:17:00 <ski_> (i prefer being told when one can't move further in a direction ..)
05:18:46 <ski_> hm ..
05:18:58 <mmorrow> cxt f _ (Top a) = f a; cxt _ g (Loc a k) = g a k; root = Top; up = cxt Left (Right . flip ($)); chop = cxt Top (const . Top)
05:19:22 <ski_> mmorrow> :t cxt
05:19:26 <mmorrow> i dunno, imo the Either adds noise, but to each his own
05:19:48 <mmorrow> :: (a -> o) -> (a -> (a -> Cxt a) -> o) -> Cxt a -> o
05:20:04 <mmorrow> just the (non-rec) cata
05:20:07 <ski_> a cata ?
05:20:15 <ski_> ok, a case
05:20:26 * mmorrow makes catas for all his ADTs :)
05:21:00 <loadquo> Is there a good introduction to catamorphism etc anywhere?
05:21:26 <mmorrow> loadquo: basically, all it really is is .. say you have
05:22:28 * ski_ ponders `data Cxt a = forall x. Loc x (x -> Either a (Cxt a))'
05:22:54 <mmorrow> data F a b c = C1 a1 .... a1n1 | C2 a2 .... a2n2 | ... | CN aN .... aNn2
05:23:38 <mmorrow> cataF f1 f2 .. fi .. fN (Ci ai ... aini) = fi ai .... aini
05:24:23 <mmorrow> so each fi replaces the constructor and gets that con's args
05:24:36 <ski_> (obviously plain that `Cxt' is pretty useless ..)
05:24:47 <mmorrow> cataList nil _ [] = nil; cataList _ cons (x:xs) = cons x xs
05:25:10 <ski_> i like to call that `caseList'
05:25:32 <mmorrow> ski_: i was just trying to do breadth-first numbering with Cxt, but i'm gonna need to change it to:
05:26:05 <mmorrow> data Cxt r a = Top a | Loc a (r -> Cxt r r)
05:26:19 <mmorrow> (i think, still trying)
05:26:46 <loadquo> I think I get it, I just have to make it make sense with the examples I've seen.
05:26:46 <ski_>   cataList nil cons = cata
05:26:50 <ski_>     where
05:26:58 <ski_>     cata [    ] = nil
05:27:00 <ski_>     cata (a:as) = cons a (cata as)
05:27:50 <ski_> mmorrow : the `Cxt r r' feels not quite right ..
05:27:53 <mmorrow> loadquo: so for each constructor of a datatype, you provide a function which will get handed the constructor it corresponds to's arguments should that cata get that constructor as an arg
05:28:11 <mmorrow> yeah it doesn't
05:28:34 <mmorrow> err, maybe...
05:28:48 <ski_> (after one iteration `a = r' ..)
05:32:14 <Saizan__1> mmorrow: you forgot the recursive part
05:32:38 <mmorrow> (in cata?)
05:32:51 <mmorrow> you can just fix to get the recursive cata
05:33:30 <Saizan__1> cataList nil _ [] = nil; cataList _ cons (x:xs) = cons x xs <- what do you "fix" here?
05:35:26 <loadquo> mmorrow, I think I get what you are doing. I'm just not sure why you want to do it.
05:36:22 <mmorrow> @let list nil _ [] = nil; list _ cons (x:xs) = cons x xs
05:36:23 <lambdabot>  <local>:24:0:
05:36:23 <lambdabot>      Multiple declarations of `L.list'
05:36:23 <lambdabot>      Declared at: <loca...
05:36:27 <mmorrow> grr
05:36:28 <mmorrow> > list
05:36:29 <lambdabot>       Overlapping instances for Show
05:36:29 <lambdabot>                                  (t -> (...
05:36:42 <mmorrow> @let foldl_ = fix (\k f z -> list z (\x xs -> k f (f z x) xs))
05:36:44 <lambdabot>  Defined.
05:36:50 <mmorrow> @let foldr_ = fix (\k f z -> list z (\x xs -> f x (k f z xs)))
05:36:52 <lambdabot>  Defined.
05:37:04 <mmorrow> > foldl_ (+) 0 [0..10]
05:37:06 <lambdabot>   55
05:37:20 <mmorrow> > foldr_ (++) [] [0..9]
05:37:22 <lambdabot>       No instance for (Enum [a])
05:37:22 <lambdabot>        arising from the arithmetic sequence ...
05:37:34 <mmorrow> > foldr_ (++) [] (fmap (:[]) [0..9])
05:37:36 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
05:37:41 <mmorrow> > foldr_ (:) [] [0..9]
05:37:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
05:37:47 <Saizan> yeah, but the catamorphism is your foldr_, not cataList
05:38:16 <mmorrow> foldr_ is a recursive cata
05:38:28 <Saizan> there's no non-recursive cata
05:38:29 <mmorrow> like, for trees you get
05:38:52 <Saizan> catamorphisms are defined on fixpoints of functors
05:38:55 * mmorrow has this written down in case it looks like i'm just whipping this out from memory
05:39:06 <mmorrow> Saizan: ah, i guess we're using diff defs
05:39:39 <mmorrow> so s/cata/non-rec cata/ for all my comments :)
05:39:45 <mmorrow> @let tree node (Node x xs) = node x xs
05:39:48 <lambdabot>  Defined.
05:39:59 <mmorrow> @let tfoldl = fix (\k f z -> tree (\x xs -> foldl (\a b -> k f a b) (f z x) xs))
05:40:02 <lambdabot>  Defined.
05:40:05 <mmorrow> @let tfoldr = fix (\k f z -> tree (\x xs -> f x (foldr (\t b -> k f b t) z xs)))
05:40:08 <lambdabot>  Defined.
05:40:16 <Saizan> well, catamorphism is already an obscure name, if we start to overload it then it'll get very messy :)
05:40:16 <mmorrow> one is preorder, one is inorder
05:41:37 <mmorrow> Saizan: i like considering the non-recursive case because the recursive case(s) can be gotten via fix, but not vice-versa
05:41:41 <dpratt71> what is the name for this guy? (->)
05:41:42 <ski_> treeCata :: (a -> [r] -> r) -> (Tree a -> r)
05:41:50 <mmorrow> @type tree
05:41:51 <lambdabot> forall t t1. (t -> Forest t -> t1) -> Tree t -> t1
05:42:05 <ski_> @tyoe tfolfl
05:42:06 <lambdabot> Not in scope: `tfolfl'
05:42:12 <mmorrow> heh
05:42:13 <ski_> @type tfoldl
05:42:15 <lambdabot> forall a t. (a -> t -> a) -> a -> Tree t -> a
05:42:20 <ski_> @type tfoldr
05:42:22 <lambdabot> forall t b. (t -> b -> b) -> b -> Tree t -> b
05:43:09 <Saizan> mmorrow: yeah, but the -morphisms are meant to be schemes of recursion
05:43:28 <ski_> @let treeCata = \node -> fix $ \cata -> tree $ \a tas -> node a (map cata tas)
05:43:31 <lambdabot>  Defined.
05:43:35 <ski_> @type treeCata
05:43:36 <lambdabot> forall t b. (t -> [b] -> b) -> Tree t -> b
05:45:21 <vincenz> :t tree
05:45:22 <lambdabot> forall t t1. (t -> Forest t -> t1) -> Tree t -> t1
05:45:28 <vincenz> :t node
05:45:29 <lambdabot> Not in scope: `node'
05:45:38 <drdozer> afternoon
05:45:50 <drdozer> I'm writing a priority queue class
05:46:30 <drdozer> I've used indexed types before but was wondering if I should use an indexed datatype for this, to represent the (item, priority) element in the queue
05:46:39 <dpratt71> @type (->)
05:46:40 <lambdabot> parse error on input `->'
05:46:46 <dpratt71> hmm...
05:48:29 <ski_> dpratt71 : `->' is used in two contexts .. (a) in types, (b) in `\',`case'
05:48:42 <ski_> which are you interested in ?
05:49:08 <dpratt71> I used to think it was just syntax...
05:49:23 <dpratt71> ...but somebody told me it was a function
05:49:26 <ski_> it is syntax that is used in two contexts
05:49:28 <dpratt71> ...I think
05:49:33 <ski_> @type ord
05:49:34 <lambdabot> Char -> Int
05:49:44 <ski_> there it is used in a type
05:49:54 <dpratt71> so it's not a function/operator in any sense?
05:50:14 <ski_> meaning that `ord' is a function, taking arguments of type `Char' and giving results of type `Int'
05:50:35 <ski_> so it is used in types describing functions
05:50:48 <lilac> it's a binary type constructor. "(->) a b" is a function from a to b, which can be written infix as "a -> b"
05:50:51 <dpratt71> I get the part about the function signature...
05:51:07 <dpratt71> ah, constructor
05:51:15 <ski_> *type* constructor
05:51:23 <ski_> (as opposed to *data* constructor)
05:51:32 <dpratt71> as opposed to?
05:51:36 <dpratt71> oh
05:51:41 <ski_> have you seen `Nothing' and `Just' yet ?
05:51:48 <lilac> writing it prefix is useful for instances, for instance "instance Functor ((->) a)"
05:51:58 <ski_> those, and `False',`True' are all *data* constructors
05:52:05 <dpratt71> you can partially apply that, right?
05:52:09 <lilac> whereas Maybe and Bool are type constructors
05:52:23 <dpratt71> Maybe ;)
05:52:24 <ski_> while `Int',`Maybe',`IO',`Char' are *type* constructors
05:52:50 <ski_> lookup :: Eq a => a -> [(a,b)] -> Maybe b
05:52:59 <dpratt71> what's the Monad that involves the partial application of (->) ?
05:53:08 <lilac> in the context of "\a -> a + 1" and "case a of 42 -> True", it's just syntax
05:53:21 <lilac> dpratt71: that's the reader monad
05:53:34 <ski_> dpratt71 : `(r ->)', which you sadly have to write as `(->) r' currently
05:53:43 <dpratt71> lilac: ok, thanks
05:53:49 <ski_> dpratt71 : i call it the environment monad .. some prefer `reader'
05:54:40 <dpratt71> supposing you wanted to find documentation...it would be the Reader monad?
05:54:59 <ski_> no
05:55:02 <oklopol> > let unjustified a = case a of (Just a) -> a; Nothing -> Nothing in unjustified (Just (Just (Just Nothing))
05:55:03 <lambdabot>   <no location info>: parse error on input `;'
05:55:05 <oklopol> > let unjustified a = case a of (Just a) -> a; Nothing -> Nothing in unjustified (Just (Just (Just Nothing)))
05:55:07 <lambdabot>   Just (Just Nothing)
05:55:11 <ski_> dpratt71 : it would be the `(->) r' monad
05:55:11 <opqdonut> dpratt71: it would be the (->) e monad :)
05:55:18 <dpratt71> by the way, is there a name for this? (->)
05:55:27 <ski_> "arrow"
05:55:30 <oklopol> anorectic arrow
05:55:36 <ski_> "implies"
05:55:38 <dpratt71> I'm not sure what google will think if I google (->)
05:55:48 <opqdonut> hoogle it
05:55:50 <ski_> @index (->)
05:55:51 <lambdabot> bzzt
05:55:55 <ski_> @hoogle (->)
05:55:55 <lambdabot> keyword ->
05:55:59 <ski_> bah
05:56:23 <dpratt71> is it correct to call it an operator?
05:56:41 <FunctorSalad> slightly offtopic, but... can you calculate the median of a list in the straightforward way by mutual recursion of "medianOdd :: [a] -> a" and "medianEven :: [a] -> (a,a)" or am I missing something?
05:56:46 <ski_> it is correct to call it a *type* operator
05:56:51 <opqdonut> dpratt71: yeah it's a type operator
05:57:05 <dpratt71> is there more than one type operator?
05:57:18 <FunctorSalad> (medianOdd for lists of odd length, medianEven for lists of even length... the possiblity of duplicate elements is the problem)
05:57:47 <ski_> dpratt71 : there is an extension in ghc that allows defining new type operators (which have to start with `:')
05:58:15 <dpratt71> ok, that should get me going, thanks ski_, et al
05:58:20 <daf> aren't (,), (,,), (,,,) etc. type operators?
05:58:40 <ski_> not in the normal sense of "operator" in haskell
05:58:42 <oklopol> > (,,,,,,,,,) 0 0 0 0 0 0 0 0 0
05:58:43 <lambdabot>       Overlapping instances for Show
05:58:43 <lambdabot>                                  (j -> (...
05:58:48 <ski_> you might call them mixfix operators
05:58:57 <drdozer> daf: they are when used in type signatures, but they are datatype constructors when used in that context
05:58:58 <daf> type functions?
05:59:09 <daf> well, sure they are normal functions too
05:59:09 <oklopol> > (,,,,,,,,,) 0 0 0 0 0 0 0 0 0 0
05:59:11 <lambdabot>   (0,0,0,0,0,0,0,0,0,0)
05:59:16 <oklopol> \o7
05:59:24 <drdozer> daf: so '(,) a b' in a type-context produces a new type: (a,b)
05:59:28 * ski_ forgets the exact definition of `median'
05:59:37 <drdozer> (3,6) in a data context produces a new tuple data item
05:59:50 <daf> yes yes
06:00:01 <daf> what I'm wondering is: what do you call (,) etc in type context?
06:00:11 <daf> are they "type functions", or something else?
06:00:13 <FunctorSalad> ski_: I'm not sure what the median of [1,1,2] should be either ;)
06:00:14 <ski_> "product"
06:00:16 <drdozer> I assume it's a type constructor of kind * -> * -> *
06:00:19 <ski_> "times"
06:00:22 <ski_> "and"
06:00:49 <daf> perhaps type constructor is the term I'm looking for
06:00:56 <daf> I guess [] is a type constructor of kind * -> * then
06:00:59 <gio123> what is a deference between  breath-firsts and iterative deepenings ?
06:01:02 <drdozer> exatly daf
06:01:03 <ski_> FunctorSalad : ok .. with no definition we're doomed to failure (or incompatible successes, mayhaps)
06:01:06 <daf> as is (->)
06:01:11 <drdozer> daf: and Either
06:01:25 <ski_> @kind (,)
06:01:26 <lambdabot> * -> * -> *
06:01:30 <ski_> @kind []
06:01:32 <lambdabot> * -> *
06:01:35 <daf> except that (->) can be called a "type operator" as well as a "type constructor"
06:01:36 <drdozer> @kind Either
06:01:38 <lambdabot> * -> * -> *
06:01:48 <daf> @kind (->)
06:01:50 <lambdabot> ?? -> ? -> *
06:02:01 <daf> yikes
06:02:05 <ski_> @kind (# #)
06:02:06 <daf> what are "??" and "?"?
06:02:06 <lambdabot> parse error on input `#)'
06:02:09 <ski_> @kind (# , #)
06:02:11 <lambdabot> parse error on input `,'
06:02:16 <ski_> @kind (# Int , Bool #)
06:02:17 <lambdabot> (#)
06:02:33 <ski_> @kind Int -> (# Int , Bool #)
06:02:34 <lambdabot> *
06:02:40 <ski_> @kind (# Int , Bool #) -> Int
06:02:41 <lambdabot>     Kind mis-match
06:02:41 <lambdabot>     Expected kind `??', but `(# Int, Bool #)' has kind `(#)'
06:03:13 <ski_> `??' is a superkind of `*' and `#'
06:03:27 <ski_> `?' is a superkind of `??' and `(#)'
06:03:32 <daf> what is '#', and what is a superkind?
06:03:33 <ski_> @kind Int#
06:03:35 <lambdabot> Not in scope: type constructor or class `Int#'
06:03:50 <ski_> @kind GHC.Base.Int#
06:03:52 <lambdabot> #
06:03:53 <pejo> ski, what is (#), unboxed tuple?
06:03:57 <FunctorSalad> ski_: hmm, wikipedia says "order them and take the middle element / the arithmetic mean of the two middle elements"...
06:03:59 <ski_> `#' is the kind of unboxed types
06:04:10 <ski_> `(#)' is the kind of unboxed tuples
06:04:19 <daf> is this GHC-specific?
06:04:27 <ski_> highly so
06:04:40 <ski_> FunctorSalad : that sounds remniscent ..
06:05:09 <FunctorSalad> ski_: the usual O(n) algorithm is divide-and-conquer, but I have a list...
06:05:22 <ski_> if `k1' is a superkind of `k0' and `t' has kind `k0', then `t' has kind `k1'
06:05:50 <daf> ok. could you give an example?
06:06:10 <pejo> ski, and what character are those superkinds? It doesn't seem wise to call them "?" and "??".
06:06:39 <ski_> @kind GHC.Base.Int# -> Double -> (# () , GHC.Base.Int# #)
06:06:41 <lambdabot> *
06:07:04 <ski_>   () :: *
06:07:14 <ski_>   GHC.Base.Int# :: #
06:08:04 <FunctorSalad> I could use median xs = sort xs !! (length xs `div` 2), but that is not just O(n*log n) (at least sort is presumably optimized though), it also iterates through half the list :(
06:08:13 <ski_>   * =< ??
06:08:15 <FunctorSalad> (in addition to the sort)
06:08:16 <ski_>   # =< ??
06:08:18 <ski_> so
06:08:27 <ski_>   () :: ??
06:08:31 <ski_>   GHC.Base.Int# :: ??
06:08:33 <ski_> also
06:08:40 <ski_>   ?? =< ?
06:08:41 <ski_> so
06:08:44 <ski_>   () :: ?
06:08:46 <ski_>   GHC.Base.Int# :: ?
06:08:53 <ski_> so
06:08:53 <pejo> FunctorSalad, length iterates through the entire list.
06:09:00 <FunctorSalad> pejo: right :)
06:09:06 <ski_>   (# () , GHC.Base.Int# #) :: (#)
06:09:09 <ski_> also
06:09:19 <ski_>   Double :: *
06:09:23 <ski_>   Double :: ??
06:09:36 <ski_> and
06:09:45 <pejo> FunctorSalad, it's still O(n*log n) though.
06:09:46 <ski_>   (->) :: ?? -> ? -> *
06:09:49 <ski_> so
06:10:14 <FunctorSalad> pejo: but probably a lot slower than some custom recursion scheme I can't think of now ;)
06:10:14 <ski_>   Double -> (# () , GHC.Base.Int# #) :: *
06:10:25 <ski_> and, since
06:10:34 <ski_>   GHC.Base.Int# :: ??
06:10:43 <ski_>   GHC.Base.Int# -> Double -> (# () , GHC.Base.Int# #) :: *
06:11:10 <ski_> (daf : i hope that's elaborate enough ..)
06:11:18 <gal_bolle> @djinn [a] -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
06:11:18 <lambdabot> Cannot parse command
06:11:34 <gal_bolle> @djinn [a] -> [ [ a ] ]
06:11:35 <lambdabot> Error: Undefined type []
06:11:54 <gal_bolle> thanks anyway, lambdabot
06:12:06 <pejo> FunctorSalad, you don't need to sort to find the median though, it can be done in linear time.
06:12:09 <ski_> @type (:[])
06:12:10 <lambdabot> forall a. a -> [a]
06:12:10 <daf> ski_: hmm, ok
06:12:28 <daf> ski_: so a superkind is more general than any of its subkinds
06:12:32 <ski_> @type map (:[])
06:12:33 <lambdabot> forall a. [a] -> [[a]]
06:12:36 <FunctorSalad> pejo: yep, I'm wondering whether it's possible with linear recursion rather than divide-and-conquer though
06:12:50 <ski_> daf : yeah .. it's similar to supertypes and subtypes
06:13:09 <daf> ski_: thanks for elaborating
06:13:21 <gal_bolle> ski: i was just being confused by the "Undefined type []"
06:13:39 <gal_bolle> what types does djinn know, and how do i get that information?
06:13:56 <daf> ski_: so * is the most general kind, and other kinds are more restricted in some way?
06:13:56 <pejo> gal_bolle, djinn doesn't do recursive types
06:14:01 <ski_> (daf : you might notice that `(# , #) :: ? -> ? -> (#)', even though lambdabot didn't want to say that)
06:14:09 <gal_bolle> ok, thanks
06:14:34 <gal_bolle> would there be a way to teach it about [] by treating it as a black box?
06:14:40 <ski_> daf : `*' is not more general than e.g. `* -> *'
06:14:53 <gal_bolle> (giving it a few Data.List functions as axioms)
06:15:14 <daf> ski_: hmmmm
06:15:59 <ronwalf> Setup: I'm implementing a little closed world reasoner (rete-ish), and part of it involves various types of 'matching-nodes', which match inferences of different types.  Each of these nodes has a different state, but the same interface.    Is there a good way to do this with state monads, or should I just use continuation-passing style?
06:16:16 <ski_> daf : also, in the given hierachy, `?' would be the most general .. not `*'
06:16:32 * ronwalf will have to learn the state monad someday
06:16:47 <ski_> (and `?' is not more general than e.g. `* -> *', i should hasten to add)
06:17:06 <daf> does ? include * -> *?
06:17:12 <ski_> no
06:17:16 <daf> is there a kind that includes * -> *?
06:17:46 <ski_> possibly `* -> ?' does .. depending on exactly how the kind subtyping system looks like
06:18:17 <lilac> > let median [] = error "median []"; median xs@(_:xt) = go1 xt xs where go1 [] (y:_) = y; go1 (x:xs) ys = go2 xs ys; go2 [] (y1:y2:_) = (y1+y2)/2; go2 (x:xs) (_:ys) = go1 xs ys in median [1,2,3,4,5] -- FunctorSalad
06:18:22 <lambdabot>   3.0
06:18:29 <lilac> > let median [] = error "median []"; median xs@(_:xt) = go1 xt xs where go1 [] (y:_) = y; go1 (x:xs) ys = go2 xs ys; go2 [] (y1:y2:_) = (y1+y2)/2; go2 (x:xs) (_:ys) = go1 xs ys in median [1,2,3,4,5,6]
06:18:31 <lambdabot>   3.5
06:18:46 <ski_> ronwalf : using CPS for what ?
06:19:08 <ronwalf> ski_: To encapsulate the state
06:19:38 <ski_> care to elaborate ?
06:20:03 <ronwalf> ski_: Are you familiar with RETE?
06:20:04 <ski_> (or paste, as you see fit)
06:20:07 <ski_> nope
06:20:37 <Gracenotes> in untyped lambda calculus, apparently "the untyped type is really U->U". Is this true?
06:20:55 <lilac> FunctorSalad: simpler: median [] = error "median []"; median xs@(_:xt) = go xt xs where go [] (y:_) = y; go [_] (y1:y2:_) = (y1+y2)/2; go (_:_:xs) (_:ys) = go xs ys
06:21:03 <ehird> Gracenotes: all lambda calculi are:
06:21:05 <ehird> a = a -> a
06:21:07 <ski_> Gracenotes : depends on how much primitives you add
06:21:09 <ehird> *calculi functions
06:21:25 <ehird> this is why if you can type the Y combinator, IIRC typing breaks down as you can type any LC term
06:21:41 <Gracenotes> also, I left this out: "where U is the untyped type"
06:21:51 <Gracenotes> so something like bottom, then
06:22:29 <Gracenotes> http://lambda-the-ultimate.org/node/3075 third comment, by the way
06:22:36 <ronwalf> ski_: Let me head off for a bit and make a mock-up
06:22:43 <ski_> @hoogle (* -> * -> *) -> * -> *
06:22:43 <lambdabot> Parse error:
06:22:43 <lambdabot>   --count=20 "(* -> * -> *) -> * -> *"
06:22:43 <lambdabot>                 ^
06:22:56 <ski_> bah .. no kind searches :(
06:23:05 <ehird> Gracenotes: coo, that links to anarchy golf
06:23:06 <ehird> loev that site
06:23:08 <ehird> *love
06:23:11 <lilac> @let median [] = error "median []"; median xs@(_:xt) = go xt xs where go [] (y:_) = y; go [_] (y1:y2:_) = (y1+y2)/2; go (_:_:xs) (_:ys) = go xs ys
06:23:14 <lambdabot>  Defined.
06:23:18 <lilac> @type median
06:23:20 <lambdabot> forall t. (Fractional t) => [t] -> t
06:23:52 <FunctorSalad> lilac: aren't you assuming that the list is already ordered there?
06:23:59 <lilac> FunctorSalad: yep.
06:24:37 <FunctorSalad> it would save the length / !! waste, yes
06:25:06 <lilac> it depends how much sorting is done by forcing the list spine, but i can imagine sort implementations where that will be O(n)
06:25:24 <Holle_> how can i use the same name of fields in different records?
06:25:27 <lilac> (where by "that" i mean median . sort)
06:25:53 <ski_> Gracenotes : e.g. if you add booleans, then you get somthing like `a = Bool + (a -> a)'
06:26:01 <lilac> Holle_: you can only do that if the fields are in the same data type or in different modules
06:26:31 <Gracenotes> ski_: silly question, but what do you mean by + there?
06:26:41 <lilac> Holle_: suppose you had a field called f of type T in a data type D. that gives you a function "f :: D -> T"
06:27:13 <lilac> Holle_: the rules for when you can reuse field names are basically, it's allowed if you could write a function with the right type by hand
06:27:16 <ski_> Gracenotes : `Either'
06:27:19 <Holle_> if i use the field "index :: Int" in both records it is ok?
06:27:50 <Gracenotes> ski_: oh, I see. And how does that work?
06:27:59 <lilac> Holle_: 'data X = A { index :: Int } | B { index :: Int; thing :: Char }'  is OK
06:28:12 <ski_> Holle_ : however, for ghc see <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields>
06:28:20 <lilac> (because you can write a function 'index' with type X -> Int)
06:29:05 <ski_> Gracenotes : you can define `data U = B Bool | F (U -> U)' in haskell if you want to play with it
06:29:42 <dublpaws> a general note about what Holle_ is saying, if two or more data elements share a substantial number of fields does it warrent the creation of an associated typeclass?
06:30:21 <ski_> cond = F (\(B b) -> F (\t -> F (\e -> if b then t else e)))
06:30:27 <lilac> dublpaws: in that case, it seems likely that those elements should be in a data type of their own :)
06:30:35 <gal_bolle> what's the tersest/clearest way to explicitely give a type to a do block? I'd like to say something like {do :: IO Int ; a <- foo; b <- bar; a+b}
06:30:40 <ski_> F f $$ x = f x
06:30:54 <gal_bolle> but putting the type annotation there is not legal
06:31:05 <lilac> gal_bolle: the tersest way is to say nothing at all and let haskell figure it out
06:31:07 <pejo> gal_bolle, b :: IO Int; b = do ..
06:31:09 <quicksilver> gal_bolle: do { a <- foo; b <- bar; return (a + b) } :: IO Int
06:31:13 <dublpaws> ok lilac I see. thanks.
06:31:14 <Gracenotes> ski_: not to mention, not = F (\(B a) -> B (not a))? Hopefully?
06:31:30 <gal_bolle> lilac: i want machine-checked comments
06:32:05 <ski_> gal_bolle : `do a <- foo; b <- bar; a+b :: IO Int'
06:32:14 <ski_> (FSVO `(+)')
06:32:22 <Holle_> my directory structure: root conatains main.hs and the folder Game. Game contains the modules mapData.hs and graphics.hs. how can i use mapData in graphics.hs?
06:32:25 <gal_bolle> quicksilver: is that doable with indentation rather than ; ?
06:32:42 <Gracenotes> @hoogle Doc
06:32:43 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
06:32:43 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
06:32:43 <lambdabot> Distribution.Simple.InstallDirs docdir :: InstallDirs dir -> dir
06:33:07 <lilac> ski_: i especially like that that works no matter where the braces go
06:33:32 <ski_> Gracenotes : `not = F (\b -> cond $$ b $$ false $$ true)'
06:34:17 <Gracenotes> mm.
06:34:28 <lilac> Holle_: it's conventional to name your .hs files after the modules. that means capitalizing the first letter
06:35:05 <ski_> gal_bolle : my version is
06:35:06 <lilac> Holle_: so you'd have module Main in Main.hs, Game.MapData in Game/MapData.hs and Game.Graphics in Game/Graphics.hs
06:35:19 <lilac> Holle_: then in Game/Graphics.hs you say "import Game.MapData"
06:35:34 <gal_bolle> ski_ thanks
06:36:10 <lilac> Holle_: build with 'ghc --make' and it'll find your .hs files automatically based on filename <-> module name correspondence
06:36:39 <Gracenotes> ski_: so far so good, except the lowercase bools. Where did those come from?
06:36:49 <Holle_> ghci doesn't works?
06:37:26 <lilac> Holle_: ghci should work too
06:37:33 <ski_> Gracenotes : i was thinking you would figure those out :) .. `true = B True', mutatis mutandis
06:38:13 <CosmicRay> is haskell.org slow for anyone else just now?
06:38:15 <Holle_> but it says: could not find module "Game.Graphics" trying to import it to Game.MapData
06:38:50 <lilac> Holle_: are you running ghci from root or from Game/ ?
06:38:59 <Holle_> from Game
06:39:17 <lilac> try running it from root instead
06:39:24 <CosmicRay> also I'm trying to use cabal to build a library that uses hsc2hs, and contains #ifdef __GLASGOW_HASKELL__... unfortunately the code within that #ifdef block is being passed to hugs as well
06:39:26 <FunctorSalad> @src splitAt
06:39:27 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
06:39:27 <CosmicRay> I have no idea why
06:39:31 <Gracenotes> ski_: trying to get a good feel about what the system is "supposed" to be
06:39:37 <ski_> sudo ghci main.hs
06:39:56 <lilac> ski_: aargh!
06:39:57 <Gracenotes> then again I could have just checked the type >_>
06:39:59 <CosmicRay> it is also somewhat unclear to me what the relationship between these predefined macros for CPP and hsc2hs is.
06:40:06 <Holle_> running from root works :)
06:40:08 <ski_> lilac >:D
06:40:15 <dcoutts> CosmicRay: sigh. It's part of the general hsc2hs confusion. Are you using ghc-6.8 btw?
06:40:46 <CosmicRay> dcoutts: yes
06:40:47 <FunctorSalad> :src partitionAt
06:40:50 <FunctorSalad> @src partitionAt
06:40:50 <lambdabot> Source not found. Maybe you made a typo?
06:41:11 <ski_> (Gracenotes : i'm not sure what you're wondering about ..)
06:41:18 <dcoutts> CosmicRay: If you're using ghc-6.8 then the hsc2hs on your $PATH is the one that came with ghc, it uses ghc as it's C compiler, thus it defines __GLASGOW_HASKELL__
06:41:19 <quicksilver> gal_bolle: yes, but you'd have to parenthesise the whole do expression, I think.
06:41:23 <CosmicRay> dcoutts: at first I was using #ifndef __HUGS__, which also would produce the desired result, but it failed in the same way.
06:41:29 <CosmicRay> dcoutts: doh.
06:42:06 <CosmicRay> dcoutts: would using CPP in Cabal for this particular file instead produce the desired result?
06:42:12 <CosmicRay> dcoutts: or what is the workaround here?
06:42:12 <dcoutts> CosmicRay: I've not tested this, but try configureing --with-hsc2hs=hsc2hs-hugs or whatever the hugs version is called, you might need to give a full path
06:42:38 <Gracenotes> ski_: I'm not quite familiar with lambda calculus with booleans, let alone lambda calculus. I found the article looking for information about Haskell and lambda calculus :)
06:42:42 <dcoutts> CosmicRay: in Cabal-1.6 we tell hsc2hs to use gcc as the C compiler and we pass the right flags (I think)
06:42:42 <CosmicRay> dcoutts: unfortunately this is a library that *I'm* the author of, and I feel somewhat dubious about expecting the end user to know about that
06:42:50 <CosmicRay> dcoutts: excellent
06:42:53 <Gracenotes> so far I've implemented church booleans in Haskell (not terribly hard) and a few operations on thme
06:42:54 <Gracenotes> *them
06:43:03 <Holle_> lilac: data A { index :: Int } and data B  { index :: Int } won't work?
06:43:05 <ski_> Gracenotes : if you like, you could define `data LExpr = Var String | Lam String LExpr | App LExpr LExpr | Boole Bool | Cond LExpr LExpr LExpr' and try to write `eval :: LExpr -> U'
06:43:15 <dcoutts> CosmicRay: if you could test that it works in Cabal-1.6 that'd be brilliant, if not file tickets
06:43:30 <CosmicRay> dcoutts: one of my other Haskell libs uses CPP and not hsc2hs.  it seems to do the right thing there.
06:43:42 <CosmicRay> dcoutts: I tried using CPP along with hsc2hs on this one, but it appears hsc2hs got to it first
06:43:43 <dcoutts> CosmicRay: yes, the only problem is hsch2s
06:43:50 <lilac> Holle_: not if they're in the same module. that would generate a function of the type (A | B -> Int), which isn't legal in Haskell'98
06:43:54 <dcoutts> CosmicRay: because it does the cpping
06:44:01 <CosmicRay> right
06:44:05 <ski_> (Gracenotes : of course, it becomes slightly more interesting if you add naturals, instead of just booleans)
06:44:10 <CosmicRay> well it is not a terribly consequential issue.
06:44:13 <dcoutts> which it has to do, because it gets stuff from the C header files
06:44:26 <Gracenotes> ski_: Succ and Zero, you mean? Later maybe :P
06:44:27 <CosmicRay> the cost of not doing this is an extra memcpy() on each SQL query string that heads to PostgreSQL
06:44:39 <ski_> Gracenotes : *nod*
06:44:42 <dcoutts> CosmicRay: well it means your package is borked with hugs, that's not irrelevant, we'd like it to work with hugs
06:44:47 <Gracenotes> but, eval first.
06:44:51 <CosmicRay> it's because the ByteString unsafe* functions are in Data.ByteString.Unsafe in GHC and Data.ByteString in HUGS
06:44:59 <Holle_> lilac: writing data X = A {} | B {} i never know what type X is of :/
06:45:16 <CosmicRay> dcoutts: what I'm saying is that I have a workaround that imposes a small but likely negligible performance penalty, and works with both GHC and Hugs.
06:45:27 <ski_> Holle_ : `X' *is* a type
06:46:09 <Holle_> could i also write: data A = A {} data B = {} data X = A | B?
06:46:34 <ski_> no
06:46:36 <dcoutts> CosmicRay: that's fine use it, I'm saying I'd much appreciate if you managed to find the time to check if the standard approach works with the latest Cabal, because I want Cabal to work with hugs.
06:46:49 <drdozer> Holle_: that isn't doing what you think it is
06:48:24 <dcoutts> CosmicRay: the general problem with hsc2hs is that it's supposed to be a compiler-independent ffi pre-processor, but to actually use it it has to #include the HsFFI.h from the compiler you're using, so out-of-the-box it either ends up working with one compiler or none (without supplying extra compiler-specific -I flags)
06:48:28 <CosmicRay> dcoutts: I will be sure to do that once it hits Debian
06:48:59 <Holle_> so i have to write it like this http://hpaste.org/13920?
06:49:07 <dcoutts> CosmicRay: oh, that might be some time. That will not be until there is a new hugs release and that release gets into debian. I think we're talking 2+ years.
06:49:13 <CosmicRay> dcoutts: I am currently in the midst of trying to make it work with every combination of {ghc6.8,ghc6.10,hugs}{POSIX,Mac,Windows}
06:49:22 <dcoutts> CosmicRay: great :-)
06:49:24 <CosmicRay> dcoutts: I track unstable and experimental
06:49:29 <CosmicRay> dcoutts: thanks very much for your Setup.lhs BTW
06:49:35 <CosmicRay> dcoutts: that appears to be working well on Linux
06:49:38 <dcoutts> CosmicRay: ok 1+ year then for a new hugs release :-)
06:49:48 <CosmicRay> dcoutts: nobody has yet responded to my email asking to test it on Windows though
06:50:19 <CosmicRay> I love having all this stuff in git.  a quick git revert to get rid of the autoconf hacks, then commit your code, and poof.  works.
06:50:20 <dcoutts> CosmicRay: aye, they want everything to work, but don't want to help
06:50:38 <CosmicRay> dcoutts: yes, that has been my experience too, with a couple of exceptions.
06:50:50 <ski_> Holle_ : don't unify them in the same type, unless you really want to handle both cases in all functions you pass them to
06:51:06 <Holle_> what does it mean?
06:51:13 <CosmicRay> dcoutts: I quite regularly hear that "HDBC-ODBC doesn't work with $EXPENSIVE_PROPRIETARY_DB", and rarely accompanied by much debugging info, let alone a patch
06:51:26 <CosmicRay> dcoutts: and it's an environment I can't possibly duplicate
06:51:40 <dcoutts> CosmicRay: yeah, I think you need to politely flame them a bit and ask for their effort
06:51:42 <Olathe> Holle_: Do you understand the difference between a constructor and a type ?
06:51:47 <ski_> Holle_ : also, if you're using ghc, did you read the link i gave a while ago ?
06:52:24 <dcoutts> CosmicRay: I feel slightly that way about Vista and OSX. At least these days one can run OpenSolaris in a VM ok.
06:52:46 <Holle_> i am using ghc. i tried to read the link, but my english is not good enough i think :/
06:55:30 <Holle_> so i have to use different modules?
06:57:08 <Gracenotes> ski_: hey, I'm a bit stuck on eval (Var s). Any, er, ideas?
06:58:51 <Gracenotes> besides something crazy like = false, that is
06:59:32 <ski_> Gracenotes : consider a worker with `evalWith evalVar (Var s) = evalVar s'
06:59:34 <CosmicRay> dcoutts: I generally answer that I can't test or debug that environment myself, and they will have to patch it or tell me what I need to know to patch it myself.
07:00:06 <ski_> (Holle_ : you can also succumb and use different names for `index', et.c. ..)
07:00:25 <Gracenotes> hrm. (*.*)
07:00:57 <Holle_> ski_:  so i habe to rename many lines of code :/
07:01:34 <ski_> evalWith (\"x" -> true) (Var "x") = B True  -- e.g.
07:02:21 <CosmicRay> dcoutts: as a general matter, I find myself dropping Hugs support for more and more of my libraries, because people want features it doesn't do well with
07:02:30 <ski_> > (\"" -> ()) ""
07:02:31 <lambdabot>   ()
07:02:34 <Gracenotes> hmm, evalVar could also probably be a curried Map get
07:02:38 <CosmicRay> dcoutts: I had a problem with the Hugs regexp libraries for the longest time.  now I am running into utf8-string not working over there.
07:02:54 <Gracenotes> and if something isn't in the Map... hm.
07:03:13 <ski_> Gracenotes : well, you could just assume that everything is in the map
07:03:21 <ski_> (otherwise error, or whatever)
07:03:44 <ski_> (you'll still get errors from `cond $$ cond' and such ..)
07:03:52 <Gracenotes> ah. okay. Don't know where I'm going to get the magical map from, but that's my problem :)
07:04:24 <ski_> one variant is to set every string to e.g. `false' in the initial map
07:05:17 <FunctorSalad> lilac ski_ : turns out that generalizing the problem to "find the kth-smallest element" makes the problem very straightforward to solve recursively :) http://hpaste.org/13921
07:05:23 <ski_> (or to `false' for prime-length strings, and `true' otherwise, if you wish)
07:05:42 <Holle_> isn't it possible to use same types for different records without renaming or ussing additional modules?
07:05:59 <ski_> the same types, yes
07:06:12 <ski_> the same data constructors or fields, no
07:06:38 <Holle_> ok then i have to rename the fields...
07:07:05 <quicksilver> your mistake is as thinking of them as fields.
07:07:10 <quicksilver> Those names are not field names.
07:07:14 <quicksilver> They are selector names.
07:07:27 <quicksilver> (and a selector is a kind of function, and lives in the function namespace)
07:07:36 <quicksilver> it might be nice if they were field names but they aren't really :(
07:07:47 <Holle_> that's the problem ./
07:10:04 <Olathe> > intercalate ' ' "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
07:10:05 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
07:10:08 <Olathe> What ?
07:10:13 <Olathe> @type intercalate
07:10:14 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:10:18 <Olathe> Ahh.
07:10:31 <quicksilver> @type intersperse
07:10:32 <lambdabot> forall a. a -> [a] -> [a]
07:15:07 <dcoutts_> CosmicRay: the number of packages we test on hugs is depressingly low
07:15:24 <dcoutts_> CosmicRay: it's partly my fault for not always testing cabal-install on there
07:15:32 <dcoutts_> if it were easy more people would do it
07:15:58 <dcoutts_> on the other hand, cabal-install cannot track dependencies with hugs, because hugs does not record the info for installed packages.
07:16:34 <SamB_XP> so ?
07:16:35 <dcoutts_> CosmicRay: with a bit of time and effort it could be radically improved, unfortunately there are many other priorities
07:16:37 <SamB_XP> make it do so!
07:17:01 <dcoutts_> SamB_XP: I would most welcome you volunteering, I can offer you guidance
07:17:24 <jkff> Hi all. I'm reading GHC core from a simple computation (of type ST blah () ) that fills an STUArray, and it looks like the implicit state argument doesn't get optimized away: the core code returns unboxed tuples and passes the state around, whereas it should probably return a (). Is that the expected behaviour?
07:17:38 <SamB_XP> dcoutts: what ... but you said it's your fault
07:18:03 <dcoutts_> SamB_XP: well, only in the sense of me not having enough hours in the day
07:18:04 <SamB_XP> anyway, cabal-install doesn't build with the HEAD so I'm not helping until that changes ;-PP
07:18:27 <dcoutts_> SamB_XP: yes it does, use Cabal-1.6 with ghc HEAD :-)
07:18:36 <SamB_XP> the Cabal HEAD
07:19:17 <SamB_XP> what does the GHC head have to do with anything ???
07:19:33 <SamB_XP> I think I'm still using 6.8
07:19:38 <hydo_> new compiler features?  Just taking a stab at it...
07:20:32 <SamB_XP> well, I'd be improving support for alternative implementations, so I don't see what the version of the mainstream implementation has to do with it ;-P
07:20:36 <dcoutts_> SamB_XP: seriously, if you want to send me patches to update cabal-install to use Cabal HEAD then I'll branch cabal-install-0.6.x and we can have cabal-install HEAD track Cabal HEAD
07:20:58 <SamB_XP> dcoutts: I might if I understood the type error
07:21:01 <dcoutts_> SamB_XP: I assumed you were using ghc HEAD which comes with cabal HEAD
07:21:07 <hydo> SamB_XP:  It was just a guess.
07:21:28 <SamB_XP> hydo: well, I guess that's a decent guess then ...
07:21:39 <hydo> I try :)
07:22:08 <SamB_XP> dcoutts: no, I haven't even found a debian package for GHC 6.10 yet
07:22:19 <dcoutts_> SamB_XP: also, if all you need is the LHC patches, I think those will apply to Cabal-1.6 so you can use that in the meantime
07:22:27 <SamB_XP> hmm ...
07:22:48 <SamB_XP> well, currently I've just gotten used to using runghc Setup
07:23:45 <hydo> Anyone know if there's a fix for http-simple?  Google isn
07:23:58 <hydo> isn't giving up the love.  specifically, the ConnError issue.
07:24:15 <SamB_XP> I would just use the full HTTP at this point, I think
07:26:54 <byorgey> anyone know what 'haddock: internal Haddock or GHC error: renameDecl
07:26:58 <byorgey> ' means ?
07:27:44 <FalconNL> Does anyone know when voting on the new Haskell logo is supposed to start?
07:27:47 <SamB_XP> it means you have to break out your source code
07:27:53 <SamB_XP> and search for renameDecl
07:28:08 <SamB_XP> (specifically, the GHC and Haddock source code)
07:29:04 <dcoutts_> byorgey: it means one of two things: update to the latest haddock, or if you're already running the latest version then report it as a bug
07:29:22 <byorgey> dcoutts_: this is from the auto-build log on Hackage
07:29:36 <byorgey> the split package fails to build with that error
07:29:41 <dcoutts_> ah
07:30:00 <byorgey> I can report it as a bug though, if that's what it is.
07:30:14 <dcoutts_> byorgey: does it work on your own box? if so perhaps ask Ross to update haddock if you think a later version fixes the issue.
07:30:25 <prokyonA> I have just spend a little while looking at the GUI-Libraries mentioned in the Haskell-Wiki. Almost all of them are extremely outdated (>4 years). Would anyone be interested if I wrote a new categorization on the talk-page?
07:31:08 <byorgey> dcoutts_: yes, it does work on my own box.  ok, I'll email Ross.
07:31:11 <cjs> Voting? Where can one see the candidates?
07:31:36 <dcoutts_> prokyonA: go for it
07:31:39 <FalconNL> cjs: http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
07:32:41 <quicksilver> prokyonA: be bold.
07:34:01 <Gracenotes> ski_: I think I did it :D
07:34:16 <ehird> the new logos are way too overcomplex
07:34:19 <Gracenotes> the only thing is, I didn't pattern match (Lam s e), only (App (Lam s e) e')
07:34:28 <ehird> http://haskell.org/haskellwiki/Image:05_Logo.png <- what ever happened to one strong concept executed simply...?
07:34:43 <Gracenotes> is that fine?
07:34:46 <Igloo> ehird: Not all of them, e.g. http://haskell.org/sitewiki/images/0/07/Lenny1.png
07:35:01 <ehird> I'm quite partial to this one http://haskell.org/haskellwiki/Image:Haskell_logo_falconnl_8_basic.png but it needs to stay on the ground more
07:36:08 <ehird> ok, http://media.nokrev.com/junk/haskell-logos/logo[1-7].png are _brilliant_
07:36:32 * quicksilver doesn't think so
07:36:38 <quicksilver> they look like the logo of a transit company
07:36:42 <quicksilver> (train/tram)
07:36:51 <ehird> haskell transits programmers to programs :-)
07:37:43 * quicksilver likes http://haskell.org/sitewiki/images/5/57/Haskell-logo-6up.png
07:37:48 <quicksilver> with a different typeface.
07:37:58 <ehird> wow, that's ...
07:37:59 <ehird> no comment
07:38:10 <quicksilver> good no comment or bad no comment?
07:38:19 <ehird> bad :D no offense to the creator
07:38:31 <Gracenotes> ah, natural numbers time
07:38:36 <BONUS> i like http://www.haskell.org/sitewiki/images/d/da/Haskell2v3.png
07:38:46 <BONUS> and also http://www.haskell.org/sitewiki/images/d/da/Haskell2v3.png (with a different typeface)
07:39:02 <ehird> BONUS: um
07:39:03 <ehird> same link
07:39:14 <BONUS> whoops!
07:39:21 <BONUS> i meant http://www.haskell.org/sitewiki/images/3/35/Horizontal-logo.png but wiht a different typeface
07:39:21 <Gracenotes> they both look so... different...
07:39:34 <quicksilver> ehird: I think it's a simple design, works with or without text, works with or without colours, and is recognisable even at a small size
07:39:35 <tromp__> reminds me of .... DELL
07:39:37 <ehird> http://haskell.org/sitewiki/images/8/85/NarleyYeeaaahh.jpg is the Correct Choice
07:39:47 <ehird> quicksilver: it looks ugly, though. and it's not very simple.
07:40:03 <Gracenotes> ehird: quite a large tooth you have there
07:40:19 <ehird> :)
07:40:40 <byorgey> yeeeeeeeahh!
07:40:52 * paper_cc thinks of a rounded lambda with a forall symbol
07:41:03 <paper_cc> s/rounded/circled/
07:41:23 <Gracenotes> kind of like the current logo? :D
07:41:28 * byorgey thinks the Haskell logo should be a black square on a white background
07:41:31 <ehird> http://haskell.org/sitewiki/images/2/21/Haskell-apankrat.png <-- this would be great if it was Haskell or HAskell instead of HASKELL
07:41:48 <byorgey> no distracting text, no frills
07:41:49 <BONUS> i like that one
07:41:58 <cnwdup> How do you design programs? Prior to coding.
07:42:02 <ehird> right now it looks like a transportation company or something
07:42:29 <vixey> by trial and improvement
07:42:29 <drdozer> @kind []
07:42:31 <lambdabot> * -> *
07:42:33 <drdozer> @kind (,)
07:42:35 <lambdabot> * -> * -> *
07:42:41 <drdozer> @kind [(,)]
07:42:42 <lambdabot>     `(,)' is not applied to enough type arguments
07:42:42 <lambdabot>     Expected kind `*', but `(,)' has kind `* -> * -> *'
07:42:50 <cnwdup> vixey: Really? I always end up at a stage where I tend to rewrite the whole thing.
07:43:01 <vixey> yes that's what I meant
07:43:13 <drdozer> mm - how do I make this one then? [(,)] :: *->*->*
07:43:27 <cnwdup> Do you think thats a good thing or just the bad thing you're happen to do either?
07:43:36 <byorgey> drdozer: what do you mean?  what you've written doesn't make sense.
07:43:44 <vixey> drdozer, you can't really,  type a :--> b = [(a, b)] is valid though
07:44:08 <byorgey> oh, like  ([] .) . (,)
07:44:14 <byorgey> if that were valid syntax
07:44:20 <drdozer> byorgey: yeah, that's the sort of thing
07:44:44 <drdozer> byorgey: It is meant to be fed into an instance declaration so it needs that kind
07:45:19 <BONUS> you're better off newtyping it then
07:45:56 <drdozer> BONUS: I wanted to explicitly avoid newtyping it so my code can run over [(a,b)] directly
07:46:13 <BONUS> ah, i see
07:46:21 * vixey waves her arms around trying to get drdozers attention
07:46:35 <quicksilver> drdozer: you can't.
07:46:38 <drdozer> perhaps I could introduce a type PairList a b = [(a,b)], but that seems to obfuscate my intent
07:47:00 <BONUS> just be sure to turn on -fallow-undecidable-instances
07:47:02 <quicksilver> drdozer: [(a,b)] isn't of the form T a b, basically.
07:47:23 <drdozer> quicksilver: no - but that's an accident of syntax
07:47:57 <quicksilver> no it's not.
07:48:02 <quicksilver> It's of the form T (R a b)
07:48:10 <quicksilver> which is different, and it's no accident.
07:48:18 <drdozer> ah, I see what you mean
07:48:45 <drdozer> some type-level function would be needed to adapt T (R a b) into T' a b
07:48:46 <quicksilver> You can consider the type [] :.. (,)
07:49:00 <quicksilver> where :.. is the appropriate type composition operator.
07:49:20 <quicksilver> (but it *would* be a newtype, and you'd have to unrwap it)
07:50:05 <quicksilver> newtype (T :.. R) a b = TypeCompose12 (T (R a b))
07:50:12 * quicksilver wonders if that is what he means.
07:50:25 <quicksilver> I think it is.
07:50:38 <quicksilver> Then ([] :.. (,)) has the required kind
07:51:00 <vixey> so does data Context a b = Empty | Extend Context a b
07:51:14 <drdozer> quicksilver: but then someone can't just have a [(foo, bar)] and expect this code to work
07:51:20 <quicksilver> drdozer: indeed not.
07:51:31 <quicksilver> [(foo,bar)] is definitely not of the form (T a b)
07:51:34 <vixey> drdozer, that's what is meant by 'you can't do that in haskell'
07:51:36 <quicksilver> which is a shame, in some sense.
07:51:54 <quicksilver> although unrestricted type functions are a can of worms.
07:52:21 <drdozer> pants
07:52:37 <quicksilver> sure, a can of pants if you prefer.
07:53:41 <drdozer> ok, and it won't let me use a partially applied type synonym in a class declaration either
07:54:05 <drdozer> (for good reasons I guess)
07:54:06 <quicksilver> for the same reason.
07:54:22 <quicksilver> partially applied type synonym = type lambdas = unrestricted type functions = can of pants
07:54:56 <vixey> what do you mean by unrestricted?
07:54:57 <jkff> Another question about ST: Is there anything like unsafeWriteArray for STUArray? I couldn't find it myself in the docs, in google or in hoogle. GHC.Arr has unsafeWriteSTArray, but it is for STArray, and I can't figure out how to apply it to STUArray.
07:55:26 <drdozer> quicksilver: I was thinking I could get about this by using an indexed datatype, but so far I've only used indexed types
07:55:30 <quicksilver> vixey: well, the only type functions haskell has are type constructors, including newtypes.
07:55:46 <vixey> drdozer, (one last attempt) this isn't possible
07:55:47 <quicksilver> vixey: that restriction makes certain kinds of inference possible
07:56:08 <quicksilver> removing that restriction would make them unrestricted.
07:56:14 <vixey> I see
07:56:18 <centrinia> I'm working on Euler 137 and I'm wondering if there is a faster way to compute    filter (\a -> isSquare (polynomial a)) [1..]
07:56:41 <drdozer> vixey: I realise *this* is not possible, but there may be something related that has the same effect for the client
07:56:55 <vixey> "client"?
07:57:00 <drdozer> whoever uses the API
07:57:12 <vixey> I tend to call them programmer
07:57:28 <drdozer> :D there are so many roles called 'programmer'
07:57:37 <vixey> I must have quite a different outlook
07:58:01 <Lemmih> jkff: Data.Array.Base.unsafeWrite?
07:58:10 <vixey> drdozer, what's an indexed datatype?
07:58:28 <centrinia> Hi pumpkin.
07:58:30 <drdozer> vixey: class Foo where data Foo
07:58:33 <pumpkin> hi!
07:58:54 <vixey> drdozer, oh I tend to call them associated types
07:59:01 <quicksilver> drdozer: you may well be able to do something like this with associated types.
07:59:13 <quicksilver> drdozer: you'd need to stand a bit further back and explain what you're trying to do though ;)
07:59:14 <drdozer> vixey: I may have my terms wrong - I thought they where class Foo where type Foo
07:59:25 <quicksilver> that's an assocated type *synonym*
08:00:02 <drdozer> ah, in that case I have been using associated type synonyms proffitably for the past week but have so far not used associated types at all
08:00:04 <FunctorSalad> why can't associated datatype instance decls see type variables in the context of the class instance decl?
08:00:08 <centrinia> pumpkin: Do you know how to find integer arguments of a polynomial that make the result a perfect square?
08:01:51 <quicksilver> FunctorSalad: ehm, can you put them syntactically inside the class perhaps?
08:02:00 <quicksilver> FunctorSalad: sounds like you ought to be able to do something like that.
08:02:29 <byorgey> @remember quicksilver partially applied type synonym = type lambdas = unrestricted type functions = can of pants
08:02:29 <lambdabot> Okay.
08:03:04 * quicksilver goes and registers canofpants.com just in case it becomes big business.
08:03:12 <drdozer> quicksilver: I'm writing a little class that behaves like a priority queue
08:03:28 <FunctorSalad> quicksilver: think I'll just use an associated type synonym instead
08:04:01 <drdozer> the concrete type of the (entity,priority) pairs needs to be instantiated on a per-implementation basis
08:04:44 <drdozer> I can paste my current (working) code if it would help
08:06:51 <pozic> Where can I find a MonadPlus instance for RandT?
08:07:49 <drdozer> http://pastebin.com/m29ad5474
08:09:01 <pozic> In one of the Haskell papers they use Suc k :)
08:09:15 <jkff> Lemmih: Can't find it here http://www.haskell.org/ghc/docs/latest/html/libraries/
08:09:23 <leimy> So is it that a lot of people haven't updated to 6.10.x yet for GHC that a lot of Hackage Packages haven't built successfully on it?
08:09:25 <leimy> or against it?
08:09:36 <leimy> or is it that it's hard to maintain Hackage between compiler releases?
08:10:05 <byorgey> @seen waern
08:10:05 <lambdabot> I saw waern leaving #haskell, #haskell.se and #ghc 3m 11d 18h 39m 21s ago, and .
08:10:28 <byorgey> liar!
08:10:41 <jkff> Lemmit: Disregard that :)
08:11:11 <byorgey> leimy: probably some of both.  Personally I haven't switched over to 6.10 yet (I have it installed but don't use it as the default).
08:11:11 <quicksilver> leimy: this was a particularly painful change.
08:11:27 <quicksilver> due to some incompatible API changes
08:11:33 <quicksilver> (mainly Exception, I think?)
08:11:44 <quicksilver> as I recall, 6.6 -> 6.8 was very good compatibility wise.
08:11:45 <pozic> leimy: persons writing application X with libraries Z compatible with compiler version V will wait until libraries Z are available for version V + 1.
08:11:46 <jkff> (sorry for the typo, *Lemmih)
08:11:51 <byorgey> yeah, that was a big one, also some stuff with Category/Arrow etc.
08:14:45 <leimy> pozic: so it's kind of a bootstrapping issue
08:15:03 <leimy> also, to maintain compatibility with 6.8 and 6.10 could be a royal pain I bet.
08:15:36 <leimy> One almost wishes they'd have labelled 6.10 as 7?
08:17:16 <quicksilver> leimy: well it wasn't GHC changes that caused the breakage
08:17:22 <quicksilver> it was library API changes.
08:17:30 <leimy> ah
08:17:34 <quicksilver> There is no haskell code that GHC 6.8 would compile which 6.10 won't
08:17:40 <quicksilver> modulo a couple of obscure bug fixes
08:17:56 <quicksilver> you could, for example, use ghc 6.10 but still compile against the 6.8 version of base
08:17:57 <Zao> quicksilver: Unless you use exceptions.
08:18:03 <Zao> Or mix bases.
08:18:08 <quicksilver> Zao: As I said, not GHC changes.
08:18:12 <quicksilver> library changes.
08:18:15 <leimy> This is why that Haskell platform stuff is going to be really nice.
08:18:25 <Zao> The last time I tried building anything everything exploded due to some parts wanting -3 and some -4.
08:18:34 <quicksilver> Yes. THat is what I am saying.
08:18:36 <quicksilver> Library changes.
08:18:41 <quicksilver> Nothing to do with 6.10.
08:18:45 <quicksilver> honestly, nothing at all.
08:18:50 <quicksilver> it's base 3 vs base 4
08:22:58 * byorgey cooks lambda frittatas
08:23:01 <dons> there you go. prime time is now. http://www.reddit.com/r/programming/comments/7pohw/why_haskell_is_beyond_ready_for_prime_time/
08:23:01 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
08:23:11 <idnar> time is prime
08:23:18 <ehird> who cares if haskell is ready...
08:23:39 <dons> employers
08:23:59 <vixey> It is not at all uncommon for the discussion on the lists to lead to groundbreaking developments in Haskell development
08:24:02 <athos> hi all
08:24:02 <ehird> dons: right, and a blog post will convince them?
08:24:02 <vixey>  ^ nice
08:24:05 <ehird> uh huh
08:24:21 <byorgey> hi athos
08:24:51 <dons> ehird: better than not saying anything at all, right?
08:24:52 <quicksilver> "You won?t find a more advanced compiler anywhere on earth"
08:24:58 * quicksilver doesn't find hyperbole like that useful.
08:25:09 <dons> heh
08:25:11 <quicksilver> That just makes people who know better laugh into their sleeves at you.
08:25:12 <leimy> ehird: Do you have managers?  All they read is blogs, and listen to things other people tell them... they don't research on their own.
08:25:14 <ehird> dons: in other news, it's the year of the linux desktop
08:25:28 * leimy might be a little bitter
08:25:32 <ehird> leimy: maybe i'm both too optimistic and too pessimistic.
08:25:36 <leimy> heh
08:25:41 <leimy> Yeah perhaps a bit of both
08:25:47 * byorgey agrees with quicksilver, hyperbole is the most useless thing ever.
08:26:04 <ehird> byorgey: you should shut up. everyone who generalizes should be shot.
08:26:08 <leimy> I can tell you that I implemented in about 2 hours some Haskell code that we're going to deploy as an Erlang module's back-end, talking over stdin/stdout :-)
08:26:20 <leimy> and so far no one is stopping me... so I take that as a good thing.
08:26:21 <pumpkin> centrinia: nope, sorry :/
08:26:36 <dons> i don't  think some guy's list of haskell infrastructure --> why everything is in place for haskell's wide use now, is going to hurt
08:26:46 <quicksilver> byorgey: well, that plus pants in a can.
08:26:47 <Gracenotes> dons: whose blog is intoverflow?
08:26:48 <dons> leimy: very cool
08:26:50 <leimy> Someone said they wanted me to add some behaviors to the application... thought it'd take a week, I said, probably a few hours.
08:26:59 <CosmicRay> guys, I think Haskell really *is* breaking into mainstream right now.
08:27:00 <pumpkin> Gracenotes: intoverflow's :P
08:27:03 <byorgey> quicksilver: hehehe
08:27:04 <leimy> And I was half done implementing it on the bus downtown.
08:27:10 <dons> Gracenotes: http://intoverflow.wordpress.com/about/
08:27:11 <leimy> so I think they're going to be sold.
08:27:13 <CosmicRay> there is a continuum of cautioun out there in business.
08:27:15 <pumpkin> byorgey: where was the hyperbole?
08:27:18 <dons> leimy: you should blog about that :)
08:27:23 <Gracenotes> I just got an idea for a great blog name: booleanoverflow
08:27:28 <byorgey> pumpkin: in the post dons linked to, apparently
08:27:30 <leimy> dons: sadly I'd have to be pretty vague about it...
08:27:31 <CosmicRay> some people, like us, will use something if we are convinced it works better than what we were using, even if it represents a big change.
08:27:37 <leimy> dons: I'm not sure my company likes the blogging.
08:27:38 <ehird> why do people blog so much
08:27:38 <byorgey> although it isn't loading for me
08:27:39 <Gracenotes> it makes no sense >_>
08:27:43 <CosmicRay> other people will never do a big change until they've seen lots of other people go first
08:27:49 <CosmicRay> and the latter is much more common.
08:27:52 <dons> ehird: to communicate with others
08:28:02 <quicksilver> pumpkin: "You won?t find a more advanced compiler anywhere on earth"
08:28:08 <ehird> i wasn't aware blogs were the only way to do that...
08:28:09 <quicksilver> pumpkin: was the hyperbole to which I referred.
08:28:18 <dons> where earth = { erlang, python, ocaml, C, C++, ruby, sbcl }
08:28:18 <pumpkin> quicksilver: aha :) bring it up with the author who's in this room! :P
08:28:28 <CosmicRay> if somebody reads a blog post, or an article in $FREE_IT_MAGAZINE that droves of people are switching from $LANG to HAskell, then all of a sudden droves of people *will* switch from $LANG to Haskell, regardless of whether they were to start with ;-)
08:28:31 <quicksilver> ehird: of course not. There is also twitter, and facebook.
08:28:34 <pozic> How should I structure my newtyped monad transformer such that it will derive a MonadTrans instance?
08:28:40 <dons> CosmicRay: agreed :)
08:28:42 <leimy> dons: I should thank you and your co-authors again for writing that book, it has opened my eyes a bit about a thing or two with Haskell.
08:28:43 <ehird> quicksilver: in the olden days, there was also myspace!
08:28:47 <dons> leimy: woot!
08:28:59 <quicksilver> dons: I used it successfully as an advocacy tool
08:29:07 <quicksilver> dons: I just left it on my printer as a talking point ;)
08:29:11 <dons> hehe
08:29:11 <leimy> LOL
08:29:13 <leimy> good idea
08:29:25 <quicksilver> colleague has already downloaded the online version to read on the train
08:29:29 <quicksilver> I did offer him my version
08:29:35 <quicksilver> but he seemed to prefer the online one ;)
08:29:40 <byorgey> pozic: I could be wrong, but I don't think you can automatically derive MonadTrans.
08:29:45 * leimy has the print one.
08:29:50 <leimy> dons: how has that been selling on Amazon?
08:29:56 <leimy> just out of curiosity?
08:30:05 <doserj> the author of that blog post also seems to confuse free theorems with a tool like djinn
08:30:34 * vixey never confuses djinn with free because only one actually makes sense
08:30:39 <dons> they are certainly part of the ecosystem
08:30:46 <CosmicRay> leimy: we're #30 in the software development category right now
08:30:55 <leimy> CosmicRay: Cool!
08:30:57 <CosmicRay> leimy: we've consistently been at or above that point, I think.
08:31:06 <leimy> CosmicRay: which author are you? :-)
08:31:12 <CosmicRay> leimy: John Goerzen
08:31:23 <leimy> Ah!
08:31:29 <pozic> CosmicRay: do you retire when you are at #1? ;)
08:31:31 * leimy forgot he could  /who
08:31:32 <pejo> vixey, Janis Voigtländer has some stuff on free theorems in the presence of seq.
08:31:33 <pumpkin> oh wow, the one I didn't think was in #haskell!
08:31:41 <pumpkin> so all three come here! thank you guys again! :P
08:31:54 <CosmicRay> pozic: the higher we get on the list, the more errata we have to sort through at oreilly.com.  It's a curse ;-)
08:32:01 <leimy> heh
08:32:51 <CosmicRay> actually it's been great to get all those errata submissions, as well as all the comments during the alpha/betas
08:33:05 <CosmicRay> I think we are all way behind working on the errata though
08:33:17 <CosmicRay> I think the only major errata is that the exceptions chapter is incompatible with ghc 6.10
08:33:37 <quicksilver> CosmicRay: errata just to be published online? Or is there a plan for a second edition?
08:34:18 <CosmicRay> quicksilver: the errata do get published online.  no discussions of a 2nd ed. have happened yet.  but if one happens -- I would hope it would -- we would certainly go through all the errata.
08:35:35 <Olathe> > let f' xs = partition (==(minimum xs)) xs in takeWhile (not.null).drop 1.map fst.iterate (f'.snd) $ ([], [1, 5, 1, 2, 3])
08:35:36 <lambdabot>   [[1,1],[2],[3],[5]]
08:36:20 <jberg> is there an isNum or something similar instead of just isDigit?
08:39:29 <byorgey> jberg: you could use 'reads' to see if it parses
08:39:42 <byorgey> > reads "123" :: [(Int,String)]
08:39:43 <lambdabot>   [(123,"")]
08:39:47 <byorgey> > reads "x123" :: [(Int,String)]
08:39:48 <lambdabot>   []
08:40:02 <byorgey> is that the sort of thing you want?
08:40:03 <ski_> Gracenotes : you should be able to handle `App (App (Lam "f" (Lam "x" (App (Var "f") (Var "x")))) (Boole True)) (Lam "x" (Var "x"))' ..
08:40:20 <leimy> reads is definitely handy
08:41:00 <jberg> byorgey, ah smart. but can i check if it belongs to the typeclass Num?
08:41:26 <leimy> jberg:  you can force a function to require stuff to be of Num
08:41:28 <byorgey> jberg: that would be much more difficult
08:41:46 <jberg> leimy, yes, but i have to check if a string is a number, int or float
08:41:51 <byorgey> jberg: you'd have to try parsing it as each possible Num type, and there's no way to enumerate the types in a type class
08:41:56 <byorgey> especially since type classes are open
08:41:57 <jberg> but i guess for now i can limit it to just integers
08:42:11 <leimy> yeah that'd be kind of tricky
08:42:12 <leimy> hmm
08:42:20 <Gracenotes> ski
08:42:23 <Gracenotes> er, testing
08:42:24 <byorgey> jberg: if you know which types you want to check, you can just call reads at each type, and manually check whether any succeed
08:42:25 <leimy> if it parses as int, or float then it is of Num though right? :-)
08:42:39 <jberg> byorgey, yes i see
08:42:57 <Gracenotes> ski_: oh, and to add natural numbers, you do need to add something like I Int to U, right?
08:43:00 <jberg> ill just use ints for now :)
08:43:07 <byorgey> ok =)
08:43:07 <leimy> In fact you could use `mplus`
08:43:12 <leimy> because [] is mzero
08:43:35 <vixey> Gracenotes what are you wryting?
08:43:43 <ski_> Gracenotes : yes
08:43:48 <FunctorSalad> does the "SPECIALIZE instance" pragma specialize every method in the instance?
08:43:58 <leimy> (reads x ::Int) `mplus` (reads x ::Float) `mplus` (reads x <whatever>)
08:44:05 <Gracenotes> ski_: oddly enough, I'm turning up a pattern matching error
08:44:09 <dons> so, say you got a multicore, and you wanted to see what intel was recommending as good books and tools to read up on how to use a multicore system.... http://software.intel.com/en-us/articles/technical-books-for-multi-core-software-developers/
08:44:09 <leimy> hmmm
08:44:11 <leimy> would that work?
08:44:29 <dons> you'd be kinda pleasently surprised to see a haskell book in their "top 10 multicore texts"... :)
08:44:44 <leimy> > (reads "12.3" ::Int) `mplus` (reads "12.3" ::Float)
08:44:46 <lambdabot>   Couldn't match expected type `Int'
08:44:47 <jberg> leimy, reads and not read?
08:44:48 <Gracenotes> ski_: I think the problem is that I didn't define an App (Var v) e
08:44:49 <leimy> doh!
08:45:01 <leimy> jberg: when reads fails it gives an empty list right?
08:45:12 <jberg> i dunno :)
08:45:17 <leimy> and mzero for list is []
08:45:27 <Gracenotes> I'll go about implementing that...
08:45:33 * vixey doesn't exist
08:45:57 * int80_h doesn't exist either, he occurs.
08:46:06 <quicksilver> > (reads "12.3" :: [(Int,String)]) `mplus` (reads "12.3" :: [(Float,String)])
08:46:07 <lambdabot>   Couldn't match expected type `Int' against inferred type `Float'
08:46:13 <ski_> vixey : writing interpreter for untyped lamba calculus, with a few extensions
08:46:17 <quicksilver> ehm
08:46:17 <ski_> (bool)
08:46:22 <quicksilver> that doesn't work ;)
08:46:43 <Olathe> > let bubbleSort [] = []; bubbleSort xs = iterate bubble xs !! (length xs - 1) where bubble (x:xs) = f' x xs; f' x [] = [x]; f' x (y:ys) = if x <= y then x:f' y ys else y:f' x ys in bubbleSort [5,4..1]
08:46:44 <leimy> nope :-)
08:46:45 <lambdabot>   [1,2,3,4,5]
08:47:30 <kmeyer> is the Char type an 8-bit char type or a utf-16 style char type?
08:47:33 <ski_> Gracenotes : it's better if you define it for single constructors at a time
08:47:54 <ski_> > ord (maxBound :: Char)
08:47:56 <lambdabot>   1114111
08:48:10 <quicksilver> kmeyer: it is not utf-16 style.
08:48:12 <leimy> quicksilver: sadly the types don't line up, so the expression fails...
08:48:20 <quicksilver> kmeyer: it represents unicode code points
08:48:22 <Gracenotes> ski_: I think I might try definite multiple and then seeing if there's anything I can abstract from both
08:48:29 <quicksilver> leimy: yes, I realised it was nonsense after I wrote it.
08:48:31 <kmeyer> quicksilver: good enough
08:48:34 <ski_> Gracenotes : sure
08:48:42 <CydeWeys> I know many other programming languages, including Lisp.  I'm just getting into Haskell.  Anything I should know?
08:48:52 <drdozer> is there a neat idiom for checking if two lists contain a common element?
08:48:55 <vixey> CydeWeys, nobody gets out here alive
08:48:57 <ski_> CydeWeys : haskell is lazy
08:48:57 <leimy> quicksilver: yeah and that's what I was thinking... but it'd be nice to be able to do that I guess, or something like it.
08:49:13 <leimy> I suppose that's what parsec and stuff is for.
08:49:17 <CydeWeys> ski_: Yup, I already read about that and it sounds neat.
08:49:25 <quicksilver> leimy: you'd have to embed them in a suitable ADT
08:49:26 <kmeyer> drdozer: convert them to sets and calculate the intersect?
08:49:29 <drdozer> I don't need the comon elements, only if they exist
08:49:33 <quicksilver> leimy: data IntOrFloat = I Int | F Float
08:49:36 <Olathe> > not.null.intersect $ [1..5] [5..10]
08:49:37 <lambdabot>   Couldn't match expected type `[a]'
08:49:38 <ski_> (CydeWeys : also, what vixey said)
08:49:41 <quicksilver> drdozer: Data.List.intersect
08:49:43 <Olathe> > not.null $ intersect [1..5] [5..10]
08:49:45 <lambdabot>   True
08:49:46 <kmeyer> or there you go
08:49:53 <quicksilver> as olathe demonstrates
08:50:01 <drdozer> quicksilver: and that'll be efficient if called in an inner-loop?
08:50:05 <CydeWeys> ... dare I ask why no one gets out alive?
08:50:06 <kmeyer> nooo
08:50:12 <quicksilver> asymptotically, yes, drdozer
08:50:26 <quicksilver> laziness means it stops when its found the first common element
08:50:29 <drdozer> k, will try it and profile :)
08:50:36 <ski_> CydeWeys : because we're all addicted, and won't leave, obviously
08:50:38 <leimy> quicksilver:  and when you have the ADT, you've built something you need to check by deconstruction :-)
08:50:38 <quicksilver> it's O(m x n) on distinct lists though
08:50:55 <leimy> but I suppose that gets the job done.
08:51:10 <quicksilver> if you want O((m + n) log (m + n)) you should just switch to Data.Set.intersect
08:51:13 <leimy> data CheckOutMyJunk = I Int | F Float | Error
08:51:16 <leimy> or something like that.
08:51:17 <CydeWeys> Any recommendations on a good first project for Haskell familiarization?  Something more complex than a Hello World, obviously.
08:51:17 <int80_h> > let a = Just [1,2]
08:51:18 <lambdabot>   <no location info>: parse error on input `;'
08:51:19 <int80_h> a
08:51:28 <CydeWeys> Hopefully something that demonstrates the strengths of Haskell.
08:51:31 <ski_> CydeWeys : other things about haskell is that it has purity and is missing macros
08:51:43 <Olathe> You could do O(n log n + m log m) with two merge sorts and then a modified merge.
08:51:53 <drdozer> quicksilver: yeah - I think most of this code will be switching data-types fairly soon
08:52:00 <vixey> leimy, Maybe IntOrFloat could be nicer being more fine grained
08:52:04 <kmeyer> quicksilver: told you
08:52:12 <athos> @src sort
08:52:13 <lambdabot> sort = sortBy compare
08:52:19 <athos> :-)
08:52:24 <leimy> vixey: hyes
08:52:27 <CydeWeys> ski_: Hrmm, can't say that I know what purity means (you mean it's purely functional?).  As for macros ... yeah, I don't really use those in the other languages I use often, so I won't miss them.
08:52:28 <int80_h> > let a = Just [1,2] in a
08:52:30 <lambdabot>   Just [1,2]
08:52:35 <int80_h> > a
08:52:37 <lambdabot>   a
08:52:43 <int80_h> what?
08:53:07 <Olathe> > minMax
08:53:08 <lambdabot>   Not in scope: `minMax'
08:53:15 <int80_h> how can I bind Just [1,2] to a, I want to ask a question about it
08:53:38 <lilac> @let a = Just [1,2]
08:53:41 <lambdabot>  Defined.
08:53:47 <int80_h> < a
08:53:49 <Olathe> > a >>= sort
08:53:50 <ski_> > let a = Just [1,2] in maybe False ((== 2) . length) a
08:53:51 <lambdabot>       Ambiguous occurrence `a'
08:53:51 <lambdabot>      It could refer to either `L.a', defined a...
08:53:51 <lambdabot>   True
08:53:58 <Olathe> Bah.
08:54:04 <int80_h> @a
08:54:04 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
08:54:06 <beelsebob> > fmap sort a
08:54:07 <lilac> > a
08:54:07 <lambdabot>       Ambiguous occurrence `a'
08:54:08 <lambdabot>      It could refer to either `L.a', defined a...
08:54:09 <lambdabot>       Ambiguous occurrence `a'
08:54:09 <lambdabot>      It could refer to either `L.a', defined a...
08:54:10 <Olathe> @let aa = Just [1,2]
08:54:10 <lilac> gah
08:54:12 <ski_> > L.a
08:54:12 <Olathe> > aa
08:54:14 <lambdabot>  Defined.
08:54:15 <lambdabot>   mueval: Prelude.read: no parse
08:54:15 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
08:54:16 <lambdabot>  Terminated
08:54:20 <beelsebob> > fmap sort aa
08:54:21 <lambdabot>   Just [1,2]
08:54:29 <Olathe> > aa >>= return.sort
08:54:31 <lambdabot>   Just [1,2]
08:54:41 <Olathe> @type fmap
08:54:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:54:45 <ski_> > L.a  -- again
08:54:46 <lambdabot>   Just [1,2]
08:54:49 <beelsebob> > sort <$> aa
08:54:50 <lambdabot>   Just [1,2]
08:54:51 <int80_h> yikes
08:54:57 <beelsebob> > (pure sort) <*> a
08:54:59 <lambdabot>       Ambiguous occurrence `pure'
08:54:59 <lambdabot>      It could refer to either `Control.Appl...
08:55:00 <beelsebob> > (pure sort) <*> aa
08:55:01 <lambdabot>       Ambiguous occurrence `pure'
08:55:01 <lambdabot>      It could refer to either `Control.Appl...
08:55:07 <ski_> int80_h : so prefix with `L.' to disambiguate with the other `a'
08:55:10 <beelsebob> > (Control.Applicative.pure sort) <*> aa
08:55:11 <lambdabot>   Just [1,2]
08:55:24 <Olathe> @type Control.Applicative.pure
08:55:26 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:55:38 <int80_h> @L.a
08:55:39 <lambdabot> Not enough arguments to @.
08:55:41 <Gracenotes> ski_: well, for starters, does this have the correct behavior (although inefficient)? evalWith env (App (Lam s e) e') = evalWith (\a -> if a == s then evalWith env e else env s) e'
08:55:50 <lilac> > groupBy (<) <$> Just [1,2,3,2,3,4,5]
08:55:52 <lambdabot>   Just [[1,2,3,2,3,4,5]]
08:56:04 <int80_h> okay this is not helping, I'll just tell you what ghci is giving me
08:56:05 <lilac> > groupBy (<) <$> Just [5,6,7,4,5,6,3,4,5]
08:56:07 <lambdabot>   Just [[5,6,7],[4,5,6],[3,4,5]]
08:56:10 <vixey> Gracenotes, don't do that though
08:56:20 <Gracenotes> what.
08:56:26 <beelsebob> int80_h: what was the question?
08:56:49 <int80_h> okay so given a type b :: Maybe [Integer]
08:56:58 <ski_> Gracenotes : you've swapped the two-subexpressions ..
08:56:59 <int80_h> just head b
08:57:20 <int80_h> why does Just head b produce an error?
08:57:21 <Gracenotes> uh. yay me?
08:57:29 <ski_> > (\foo -> 3) (foo * 2)
08:57:30 <lambdabot>   Not in scope: `foo'
08:57:31 <lilac> int80_h: the expression 'Just head b' ?
08:57:35 <beelsebob> int80_h: because b isn't a list
08:57:35 <ehird> http://hpaste.org/13924 is this an idiomatic translation of http://thedailywtf.com/Articles/The_Brillant_Paula_Bean.aspx? ;-)
08:57:37 <beelsebob> it's a maybe list
08:57:48 <beelsebob> if you want to apply head inside the maybe, you've gotta fmap it in there
08:57:56 <lilac> int80_h: also, you're not applying head to b. you're applyiung Just to head and you're applying the result to b
08:57:56 <beelsebob> > fmap head (Just [1,2,3])
08:57:57 <lambdabot>   Just 1
08:58:02 <int80_h> lilac: yeah I want to return Nothing in the event there's nothing for head to return
08:58:23 <lilac> int80_h: oh. head doesn't do that.
08:58:32 <beelsebob> no, head errors in that case
08:58:36 <lilac> (do you mean on an empty list?)
08:58:38 <beelsebob> you need a safe head definition for that
08:58:44 <Gracenotes> ski_: I don't quite get what's incorrect about the definition
08:58:48 <int80_h> lilac: yeah
08:58:50 <beelsebob> safeHead [] = Nothing; safeHead (x:xs) = Just x
08:59:14 <Gracenotes> it "works", according to the specification that doesn't exist (?)
08:59:15 <beelsebob> > let safeHead [] = Nothing; safeHead (x:xs) = Just x in Just [1,3,4] >>= safeHead
08:59:16 <lambdabot>   Just 1
08:59:37 <lilac> @let safeHead [] = Nothing; safeHead (x:xs) = Just x
08:59:40 <lambdabot>  Defined.
09:00:00 <lilac> > map (>>= safeHead) [Nothing, Just [], Just [1]]
09:00:02 <lambdabot>   [Nothing,Nothing,Just 1]
09:00:10 <paper_cc1> > let head = fromJust . safeHead in head []
09:00:12 <lambdabot>   * Exception: Maybe.fromJust: Nothing
09:00:28 <paper_cc1> > let head = fromJust . safeHead in head [1,2,3]
09:00:30 <lambdabot>   1
09:00:52 <lilac> @type listToMaybe
09:00:54 <lambdabot> forall a. [a] -> Maybe a
09:01:03 <lilac> @check listToMaybe == safeHead
09:01:04 <lambdabot>   Not in scope: `safeHead'
09:01:14 <beelsebob> > let head = maybe (error "head: empty list") id . safeHead in head []
09:01:16 <lambdabot>   * Exception: head: empty list
09:01:22 <lilac> @check listToMaybe == let safeHead [] = Nothing; safeHead (x:xs) = Just in safeHead
09:01:23 <beelsebob> > let head = maybe (error "head: empty list") id . safeHead in head [1]
09:01:23 <lambdabot>   Couldn't match expected type `Maybe a'
09:01:24 <lambdabot>   1
09:01:39 <lilac> @check \xs -> listToMaybe xs == let safeHead [] = Nothing; safeHead (x:xs) = Just in safeHead xs
09:01:40 <lambdabot>   Couldn't match expected type `Maybe a'
09:01:49 <ski_> Gracenotes : try on `App (Lam "x" (Boole True)) (Var "x")'
09:02:19 <Gracenotes> yields B True
09:02:41 <ski_> Gracenotes : yes .. now try `(\x -> True) x' in hugs or ghci ..
09:02:57 <Gracenotes> ah.
09:04:20 <Gracenotes> ski_: identity is (Lam "x" (Var "x")), right?
09:04:28 <ski_> yes
09:04:31 <ski_> \x -> x
09:04:58 <Gracenotes> at least that works.
09:05:49 <Gracenotes> well, when combined with App
09:05:53 <Gracenotes> hm.
09:06:06 <cknapp> :t (,)
09:06:07 <lambdabot> forall a b. a -> b -> (a, b)
09:06:19 <cknapp> Oh...
09:06:33 <jpcooper> hello
09:06:44 <jpcooper> could anyone tell me how to split a string by commas?
09:07:42 <vixey> what have you tried so far?
09:08:15 <jpcooper> @hoogle a -> [a] -> [[a]]
09:08:16 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
09:08:16 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
09:08:16 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
09:08:45 <jpcooper> vixey, I am wondering whether there is a function which I do not know of that does this
09:08:50 <osfameron> there is a new library isn't there?
09:09:26 <cknapp> It can't be terribly difficult to write...
09:09:34 <osfameron> cknapp: you'd be surprised
09:09:47 <cknapp> Appparently I would if it hasn't been written...
09:09:51 <osfameron> well, to do it in its generality (which is the argument people always make for it not being in core libraries)
09:10:50 <jpcooper> cknapp, yes bloody hell
09:11:10 <chessguy_work> 'ello
09:11:37 <ziman> there should be newly added Data.Split on Hackage
09:11:54 <osfameron> I blogged about it ages ago at http://greenokapi.net/blog/2007/11/12/haskell-words-and-perl-split/
09:12:05 <ziman> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
09:12:08 <chessguy_work> ziman, i thought it was Data.List.Split
09:12:11 <Gracenotes> ski_: I'm probably going about this with not enough abstraction. evalWith :: (String -> U) -> LExpr -> U is basically correct, right?
09:12:38 <quicksilver> omg, osfameron blogged and my name is there in lights!
09:12:42 <quicksilver> next stop hollywood!
09:12:47 <ziman> chessguy_work, ah, it _is_ Data.List.Split
09:12:50 <cknapp> OMG, quicksilver!
09:12:58 <osfameron> hehe
09:13:03 <quicksilver> move aside, leonardo and kate, quicksilver is on his way.
09:13:04 <cknapp> You're like, famous in the haskell community
09:13:25 <jpcooper> thanks ziman
09:13:31 <cknapp> haskell community: 500 and counting...
09:13:46 <chessguy_work> hm, actually i wonder how much of that stuff could be lifted to arbitrary functors
09:14:01 <chessguy_work> then it really would be approriate to call it Data.Split
09:14:56 <chessguy_work> @losers
09:14:56 <lambdabot> Maximum users seen in #haskell: 651, currently: 630 (96.8%), active: 37 (5.9%)
09:15:34 <Gracenotes> hm... nvm. *works*
09:15:46 <quicksilver> chessguy_work: not much.
09:15:54 <quicksilver> chessguy_work: arbitrary functors do not have substructures.
09:16:24 <chessguy_work> oh, i think i meant arbitrary monoids
09:18:38 <chessguy_work> yeah, and/or MonadPlus
09:19:34 <ski_> Gracenotes : iirc, that should work, yes
09:19:58 <Gracenotes> ski_: I think it's helping to think about it in terms of the lambda calculus, not just types :/
09:20:29 <quicksilver> chessguy_work: you need more than that
09:20:37 <chessguy_work> quicksilver, hm?
09:20:38 <quicksilver> chessguy_work: you need the opposite of a monoid
09:20:40 <ski_> you want to map `Lam s e' to an element of form `F (\x -> ...)'
09:20:42 <quicksilver> you need to be able "split bits off"
09:20:47 <quicksilver> not just join bits together.
09:21:09 <ski_> Gracenotes : you could try seeing how to fill in the dots ...
09:21:28 <quicksilver> I think oleg calls this msplit
09:21:29 <quicksilver> http://okmij.org/ftp/Computation/monads.html#LogicT
09:21:40 <chessguy_work> hmm, i see
09:21:55 <Gracenotes> ski_: ah... I haven't invoked F yet in evalWith.
09:22:07 <mmorrow> , [$ty| msplit |]
09:22:12 <Gracenotes> F has a "Radioactive -- Avoid" sign on its head
09:22:12 <lunabot>  forall a b . MonadLogic b => (b a) -> b (Maybe ((a, b a)))
09:22:24 <vixey> ski_, is it (whereever F resides) called the semantic domain?
09:22:27 <pozic> Why can't GHC derive this monadtrans instance? newtype MT s m a = MT (RandT StdGen (StateT s m) a)  deriving (Monad, MonadTrans)
09:23:04 <quicksilver> you don't want it anyway.
09:23:09 <quicksilver> MonadTrans is useless.
09:23:19 <mmorrow> heh
09:23:24 <pozic> quicksilver: so, I should manually lift everything?
09:23:30 <chessguy_work> seems like we need a class MonadSplit m where extract :: m a -> a; split :: m a -> (m a, m a)
09:23:45 <quicksilver> pozic: no. You should use MonadState and MonadRand.
09:24:01 <chessguy_work> except that instead of numerous functions, you'd have numerous instances of this monad for list, which would suck
09:24:11 <quicksilver> MonadTrans exposes the concrete structure of your transformer stack
09:24:15 <mmorrow> @src Splittable
09:24:16 <lambdabot> class Splittable t where
09:24:16 <lambdabot>     split :: t -> (t,t)
09:24:17 <quicksilver> you normally want that to be abstract.
09:24:20 <mmorrow> @index Splittable
09:24:20 <lambdabot> GHC.Exts
09:24:28 <pozic> quicksilver: ok, and whatabout a MonadPlus RandT instance?
09:24:43 <mmorrow> , src ''Copointed
09:24:43 <pozic> quicksilver: I wanted to combine MaybeT with RandT, but it doesn't appear to work.
09:24:48 <lunabot>  class (Functor f) => Copointed f where
09:24:48 <lunabot>          extract :: forall a . f a -> a
09:25:11 <quicksilver> well you need to write the MonadPlus instance for RandT
09:25:23 <quicksilver> I guess you mean the lifted one from the 'inside' monad
09:25:53 <pozic> quicksilver: anyway, but you advocate not using the newtype approach?
09:26:06 <quicksilver> no, the newtype is good.
09:26:14 <quicksilver> I just think MonadTrans is a red herring.
09:26:37 <quicksilver> you want to derive (manually or automatically) instances of classes like MonadPlus, MonadState, MonadRand
09:26:55 <quicksilver> which give access to the primitives you want (e.g. get, mplus) without exposing the structure of your implementation.
09:27:00 <quicksilver> that's what those classes are for.
09:27:02 <quicksilver> abstraction.
09:27:38 <quicksilver> Something I said?
09:28:13 <mmorrow> heh
09:28:36 * vixey should probably have said 'a' instead of 'th'
09:28:38 * vixey should probably have said 'a' instead of 'the'**
09:31:04 <chrisdone> is this right? (-> e) a = e -> a
09:31:15 <quicksilver> no
09:31:21 <quicksilver> ((->) e) a = e -> a
09:31:25 <chrisdone> I realised just as you said it
09:31:29 <chrisdone> brainfart
09:31:45 <Choko> :t (->)
09:31:46 <lambdabot> parse error on input `->'
09:31:47 <quicksilver> (-> e) a is not legal syntax but if it were
09:31:48 <chrisdone> (-> e) a = a -> e
09:31:51 <chrisdone> sure, yeah
09:31:55 <quicksilver> we would expect it to be a section ;)
09:31:59 <quicksilver> don't have type sections.
09:32:08 <quicksilver> type sections = type lambdas = can of pants, as previously advertised.
09:32:31 <lilac> presumably you can now get much the same effect with type families?
09:32:41 <lilac> although you can't define instances for (-> a) obviously
09:32:43 <vixey> same effect as what?
09:32:55 <lilac> right type sections
09:33:10 <quicksilver> no more or less than you already could with a newtype
09:33:26 <lilac> type rather than newtype, no?
09:33:45 <lilac> or are associated types required to be newtypes / data?
09:33:54 <quicksilver> no, you can have an associated type synonym
09:34:00 <quicksilver> but what would you associate it to in this case?
09:45:00 <ski_> (vixey : i believe so, yes)
09:46:29 <SuZume> Short Question: How to display " in a String without terminating it. /" won't work for me. (Using Hugs)
09:46:43 <quicksilver> SuZume: \"
09:46:43 <lilac> > "  \"  "
09:46:45 <SuZume> Correction \"
09:46:45 <lambdabot>   "  \"  "
09:46:50 <quicksilver> > "\""
09:46:51 <lambdabot>   "\""
09:46:56 <FunctorSalad> type family rightSection a b :: * -> *; type instance rightSection Foo Bar x = Foo x Bar -- lilac?
09:46:58 <quicksilver> SuZume: dunno why it wouldn't work for ou.
09:47:08 <gnut> hi all
09:47:09 <FunctorSalad> didn't try :)
09:47:28 <FunctorSalad> maybe you can even generalize Foo and Bar
09:47:33 <lilac> FunctorSalad: yeah, something like that
09:47:57 <SuZume> "test\"test" results in test\"test ...The Backslash is still shown in the output.
09:48:14 <quicksilver> SuZume: I doubt it.
09:48:22 <lilac> SuZume: that's because ghci is using 'print' which uses 'show'
09:48:23 <quicksilver> SuZume: I expect it results in "test\"test"
09:48:28 <quicksilver> which is different
09:48:49 <quicksilver> I can't imagine how it would ever strip the outer quotes without stripping the backslash.
09:48:57 <lilac> SuZume: sorry, Hugs not ghci but i expect it's the same
09:49:18 <quicksilver> SuZume: perhaps you could paste a part of the hugs session so we can see what is happening.
09:49:19 <lilac> SuZume: try:
09:49:29 <lilac> > length "\""
09:49:31 <lambdabot>   1
09:49:35 <lilac> > head "\""
09:49:37 <lambdabot>   '"'
09:49:47 <FunctorSalad> lilac: won't work :( it expects 2 params / doesn't accept the x
09:50:28 <SuZume> length "\""
09:50:28 <SuZume> 1
09:50:33 <lilac> FunctorSalad: don't you mean * -> * -> * ?
09:50:47 <SuZume> Hugs> "test\"test"
09:50:47 <SuZume> "test\"test"
09:50:50 <quicksilver> yes.
09:51:00 <quicksilver> That is showing you the output as a string.
09:51:04 <Olathe> SuZume: And what is the length of that ?
09:51:09 <quicksilver> so it's quoting it and backslashing the internal quote
09:51:15 <quicksilver> the backslash isn't part of the string
09:51:21 <SuZume> Hugs> "test\"test"
09:51:21 <SuZume> "test\"test"
09:51:21 <SuZume> Hugs> '\"'
09:51:21 <SuZume> '"'
09:51:21 <SuZume> Hugs> "test"++'\"':"test"
09:51:21 <SuZume> "test\"test"
09:51:21 <quicksilver> it's part of the representation of the string
09:51:35 <quicksilver> just like the " around the ends.
09:51:40 <quicksilver> SuZume: do you see?
09:51:44 <ski_> > "test" ++ '"' : "test"
09:51:46 <lambdabot>   "test\"test"
09:51:59 <saml> @src List.groupBy
09:51:59 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:52:02 <mrd> > "\"" !! 0
09:52:04 <lambdabot>   '"'
09:52:05 <saml> @src Data.List.groupBy
09:52:05 <lambdabot> Source not found. I feel much better now.
09:52:28 <SuZume> So there is no way NOT do display the backslash in the output String?
09:52:33 <quicksilver> @src groupBy
09:52:34 <lambdabot> groupBy _  []       =  []
09:52:34 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:52:34 <lambdabot>     where (ys,zs) = span (eq x) xs
09:52:38 <FunctorSalad> lilac: as far as I see that wouldn't solve it either
09:52:38 <quicksilver> SuZume: it's NOT in the string.
09:52:42 <saml> > "âÌ¼" !! 0
09:52:43 <lambdabot>   '\9676'
09:52:44 <quicksilver> it's in the REPRESENTATION of the string.
09:52:48 <Olathe> SuZume: Have you tried printStrLn "zomg\"zomg" ?
09:52:50 <mrd> SuZume: do a putStrLn "\""
09:52:56 <Olathe> Ahh, putStrLn.
09:53:11 <RayNbow> > say "zomg\"zomg"
09:53:12 <lambdabot>   zomg"zomg
09:53:16 <lilac> SuZume: hugs is adding the \ and " in so you can see the special characters in the string
09:53:16 <ski_> SuZume : there is a difference between showing a value (in this case a string), and outputting some characters from a string
09:53:17 <mrd> SuZume: you are getting very confused because the output at the Hugs prompt is designed to be "read"-able which means it must contain the backslash
09:53:17 <SuZume> Thanks a lot!
09:53:31 <saml> > "\\"
09:53:32 <lambdabot>   "\\"
09:53:40 <quicksilver> saml: @src as far as I know never has module qualifiers.
09:53:46 <SuZume> putStrLn solved the Problem!
09:53:47 <lilac> > map show "foo\"bar"
09:53:49 <lambdabot>   ["'f'","'o'","'o'","'\"'","'b'","'a'","'r'"]
09:54:01 <FunctorSalad> lilac: it just expects an existing type of the given kind on the RHS of "type instance"
09:54:01 <mrd> SuZume: there is no problem. you misunderstand the usage of the hugs prompt.
09:54:14 <saml> @src span
09:54:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:54:15 <lilac> FunctorSalad: :(
09:54:17 <FunctorSalad> lilac: so we'd need the flipped binary type constructor in the first place...
09:54:22 <FunctorSalad> (I could be wrong of course)
09:54:35 <drdozer> thanks for the help guys - I seem to have the gillespi algorithm all coded up now
09:54:56 <drdozer> it runs like a dog but it runs
09:57:31 <Gracenotes> ski_: oh, I think I see why it's not working... you may have mixed up the arguments
09:57:52 <Gracenotes> your example "translates" to (\f -> \x -> f x) (True) (\x -> x)
09:58:14 <Gracenotes> and going true $$ id fails
09:58:17 <Gracenotes> *doing
09:58:55 <Gracenotes> (of course, the reason it didn't work before is because the design was screwed up)
09:59:18 <chessguy_work> @pl \f -> \x -> f x
09:59:18 <lambdabot> id
09:59:32 <Gracenotes> unless, that is, your example was valid and the design still is screwed up
10:01:59 <Gracenotes> hm. Let me see if I can do this with Map now
10:03:42 <Gracenotes> ah... it's so tempting to add a "Null" at the end of U
10:03:46 <Gracenotes> :P
10:12:05 <Gracenotes> hm... has anyone ever made a programming language that implements the lambda calculus using RPN?
10:12:18 <Gracenotes> is that even possible? :)
10:12:59 <CydeWeys> Reverse Polish Notation?
10:13:08 <tromp__> does that even make sense?
10:13:47 <tromp__> you mean writing application as arg fun instead of fun arg ?
10:13:52 <int80_h> wait, I think christopher lloyd did that in Back to the Future III
10:14:02 * vegai smiles
10:14:16 <vegai> Gracenotes: those seem to be orthogonal concepts
10:14:33 * Gracenotes takes the dot product of them
10:14:48 <pumpkin> lol
10:14:53 <Gracenotes> hm... really, let me think
10:15:30 <Gracenotes> in infix, the notation would be something like (\x -> x) $ 4
10:15:48 <Gracenotes> in prefix, something like (app (lambda x x) 4)
10:15:50 <pumpkin> (\x -> x) ?
10:15:55 <pumpkin> why?
10:16:22 <Gracenotes> in RPN, then, maybe x x lambda 4 app
10:16:25 <PeakerWork> Gracenotes: if RPN is just a superficial syntactic level change, then it shouldn't be a problem
10:16:49 <Gracenotes> it's absolutely crazy and impossible to use, but I think it could work
10:17:01 <centrinia> You can always have an RPN SK combinatory evaluator.
10:17:30 <Gracenotes> CydeWeys: hello! Yeah, reverse polish...
10:18:24 <Gracenotes> the only reason I ask is because RPN is pretty easy to write a parser for (as far as I've seen)
10:18:45 <vixey> centrinia, but you can't represent every SK term with it
10:18:47 <centrinia> Why not use S-expressions?
10:18:55 <centrinia> vixey, you can't?
10:20:50 <sw17ch> hello all
10:22:38 <Gracenotes> greetings, sw17ch
10:23:02 <sw17ch> anything new and exciting in the community?
10:23:28 <Raynes> Yo.
10:23:42 <CydeWeys> I'm running GHCi on Windows and the interface *sucks*.  It's the basic DOS prompt.  Is there anything better?
10:23:57 <sw17ch> putty wrapper aroudn cygwin
10:24:04 <sw17ch> then use ghci through cygwin
10:24:13 <CydeWeys> I'm actually installing Cygwin now.
10:24:20 <CydeWeys> So I just run GHCi from within Cygwin?
10:24:24 <CydeWeys> BASH would be nice ..
10:24:25 <newsham> a command window sucks?
10:24:47 <Raynes> Use an alternate shell.
10:24:48 <newsham> you can run ghci from cygwin
10:24:58 <newsham> but if you're just sitting in ghci what does it matter what launched it?
10:25:43 <CydeWeys> newsham: The DOS windows are absolutely atrocious.
10:25:59 <CydeWeys> Just copy-pasting into them is more arduous than it should be.
10:26:02 <CydeWeys> Scrollback is terrible.
10:26:04 <newsham> cygwin often runs in a dos window.
10:26:04 <CydeWeys> Resizing doesn't work well.
10:26:05 <CydeWeys> Etc.
10:26:29 <CydeWeys> You can't even select text normally :-/
10:26:32 <newsham> i guess you're talking about using rxvt or something?
10:26:44 <newsham> if you turn on quick-edit the text selection is ok
10:26:58 <CydeWeys> I don't even know what rxvt is.
10:27:04 <CydeWeys> I'm talking about the basic DOS prompt that comes with Windows.
10:27:19 <newsham> yup.  cygwin by default runs in the normal dos cmd window
10:27:42 <CydeWeys> So if I can get this running in something like PuTTY ... that'd be much better.
10:28:03 <newsham> run cmd.exe, click on the upper left corner, select properties, options tab, click on QuickEditMode, click OK, select apply to the shortcut that started this window
10:28:10 <newsham> now you can cut&paste without using the menu
10:28:15 <Raynes> CydeWeys: I'll agree on the suckage.
10:28:33 <newsham> if you install cygwin you can run the rxvt terminal in X if you want
10:28:47 <newsham> or if you install mingw it runs in rxvt (not in X) by default
10:28:56 <CydeWeys> newsham: Except selection is in a box instead of being line-intelligent :-/
10:29:09 <CydeWeys> But this is definitely an improvement.
10:29:24 <newsham> it has its plusses and minuses.  sometimes box selection works well, sometimes it doesnt
10:29:40 <newsham> (ie. cutting a block of code is actually useful if there's no line wrap)
10:29:50 <Gracenotes> CydeWeys: yeah, you have to right click, find "Select", select a block, and hit enter to copy, right?
10:30:04 <newsham> gracenotes: if you dont have quick edit turned on, yes.
10:30:07 <CydeWeys> Gracenotes: Not in quick edit mode, which newsham just showed me, thankfully.
10:30:21 <Gracenotes> ah. If only I had known that :)
10:30:23 <CydeWeys> I'm used to Konsole and PuTTY and any variety of terminals that don't suck.
10:30:29 <Gracenotes> but now I'm safe with Ubuntu
10:30:33 <CydeWeys> Going back to Windows' DOS window is always torture.
10:30:41 <p_l> the default console emulator wasn't touched for a long time
10:30:42 <newsham> cydeweys: though you shouldnt need too much cut&paste in ghci.  you can use the arrow keys to line edit your history
10:30:50 <p_l> CydeWeys: Except it's not DOS at all ;-)
10:30:51 <newsham> and you can reference previous results using the "it" variable
10:30:52 <mapreduce> On Windows I like to run my Cygwin bash shell from within emacs.
10:30:55 <mapreduce> M-x shell or M-x term
10:30:59 <CydeWeys> newsham: Well, I'm going through a tutorial right now, so I'll be doing a lot of cut and pasting into the window.
10:31:32 <newsham> cyde: so the cutting wont be in the cmd window, and will prob be line-smart
10:31:39 <newsham> just the pasting into ghci
10:31:44 <CydeWeys> Yup, thankfully Firefox is line-smart.
10:32:31 <CydeWeys> I'm installing Cygwin over a tethered mobilephone connection.  This is fun.
10:32:38 <CydeWeys> Still faster than 56k, heh.
10:32:38 <newsham> cydeweys: if the terminal is still bothering you, probably the quickest path would be to get mingw.
10:32:51 <CydeWeys> What does mingw get me that cygwin doesn't?
10:32:52 <newsham> cygwin will be good too, but you'll have to run X to get another terminal I believe
10:33:04 <newsham> mingw is smaller and comes with non-X rxvt
10:33:06 <CydeWeys> Looks like I can install mingw through cygwin, at least.
10:33:27 <newsham> oh, cygwin comes with non-X rxvt too
10:33:28 <CydeWeys> Honestly I'd just do all of this on my GNU/Linux server (which I'm chatting to you through right now) if it wasn't for this slow mobile connection.
10:33:39 <newsham> so when you start cygwin, just type "rxvt" at the prompt and you'll get another terminal window
10:33:57 <p_l> cygwin also is not native, despite whatever you might claim. When I read about how fork() is implemented, I screamed
10:34:12 <CydeWeys> This is really courteous.  All of the files cygwin is downloading during installation are bzip2ed.
10:34:24 <newsham> p_l: but he'll just be using it as a terminal to run ghci, which is native.
10:34:44 <p_l> ... now that's... unnecessary?
10:34:54 <p_l> Why not download a small native terminal?
10:34:54 <CydeWeys> p_l: How else would you do it?
10:35:00 <CydeWeys> Like what?
10:35:01 <newsham> he's trying to avoid the cmd terminal which he doesnt like
10:35:11 <dax> good morning
10:35:15 <Spark> i use cygwin because i want makefiles and bashscripts and so on
10:35:22 <sw17ch> @seen dons
10:35:23 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1h 44m 40s ago.
10:35:29 <p_l> I remember at least one mention of native rxvt here and I remember running rxvt without X11
10:35:32 <CydeWeys> ghci also isn't the only thing I'm going to be running in cygwin, either.
10:35:56 <Spark> the problem isn't so much cmd.exe as it is the dos shell
10:35:58 <Spark> it's just shit
10:35:58 <newsham> p_l: cygwin and mingw have an X-less rxvt
10:36:15 <p_l> For rest of POSIX stuff, I use real POSIX subsystem, not "POSIX botched on Win32 so it would work on win9x"
10:36:21 <newsham> spark: but if you're in the ghci shell you dont need to worry about the dos shell
10:36:22 <CydeWeys> Spark: Whatever it is, it's missing features that've been in *nix shells for literally decades.
10:36:56 <dax> what is really bad about this code: http://paste.pocoo.org/show/99667/ ?
10:36:57 <newsham> cydeweys: another alternative is to just run some unix variant in qemu or vmware and use their console or ssh into it with putty
10:37:43 <CydeWeys> Meh, that's too much overhead.
10:37:44 <p_l> CydeWeys: Because it's obsolete. There is a new one for scripting and we will probably see some fixes to the terminal emulator widget itself
10:38:21 <p_l> CydeWeys: SUA + native rxvt?
10:38:29 <CydeWeys> SUA?
10:38:37 <p_l> Services for Unix Applications
10:38:42 <CydeWeys> I was referring to the VM idea as having too much overhead.
10:38:55 <CydeWeys> You know, I did install SUA on this computer before I reinstalled Windows.
10:39:06 <CydeWeys> What're the relative pros/cons of SUA versus cygwin?
10:39:08 <newsham> cydeweys: less cpu overhead than running cygwin.  more complete environment.
10:39:16 <newsham> (vmware, that is)
10:39:27 <newsham> obviously big disk overhead
10:39:34 <CydeWeys> Less CPU overhead to virtualize a complete OS?
10:40:10 <p_l> in SUA's case - less overhead compared to Cygwin, possible better overall integration with system
10:41:17 <p_l> SUA is basically a slighlty outdated (in some apps, not in standards IIRC) BSD with SysV compatibility working on NT kernel
10:41:24 <p_l> you could call it NT Unix
10:41:51 <p_l> or UNIX NT ;-)
10:41:55 <CydeWeys> Cygwin is probably a better fit for me then, because I have lots of Linux experience but nothing to speak of with BSD.
10:42:02 <CydeWeys> Or UNIX, for that matter.
10:42:20 <newsham> bsd is like cygwin is like linux is like unix
10:42:37 <newsham> cygwin is about as close to linux as linux is to bsd or unix
10:43:29 <p_l> the differences you might see are of the kind you probably don't notice too much. Stick to POSIX when it comes to API, and you won't have many problems
10:44:12 <CydeWeys> As long as my embarrassing beginner Haskell programs work correctly, I'm golden.
10:44:43 <CydeWeys> Oh, I know a good Haskell program to start off with: the traveling salesman.
10:48:44 <gnuvince> Does GHC have persistent data structures like Clojure?  Where two or more data structures can share data?  If so, is there a place I could read about it
10:48:45 * AirCastle doesn't know much math/haskell, but knows the traveling salesman is np-hard.. how is haskell with np-hard tasks?:)
10:48:47 <gnuvince> ?
10:49:18 <sw17ch> gnuvince: that's the default in haskell
10:49:40 <augustss> gnuvince: you have work hard to get anything else
10:49:50 <gnuvince> OK
10:49:52 <gnuvince> Thanks
10:50:06 <sw17ch> > let x = 1; y = 2 in (x,y)
10:50:08 <lambdabot>   (1,2)
10:50:22 <sw17ch> > let x = 1; y = 2; z = 3 iin ((x,y),(y,z))
10:50:24 <lambdabot>   <no location info>: parse error on input `;'
10:50:28 <sw17ch> > let x = 1; y = 2; z = 3 in ((x,y),(y,z))
10:50:30 <lambdabot>   ((1,2),(2,3))
10:50:55 <newsham> air: np-hard doesnt imply difficulty in programming.
10:51:59 <rwbarton> AirCastle: Haskell is great for NP-hard tasks because if your implementation has a few extra log n factors no one will ever notice :)
10:52:11 <AirCastle> hahah
10:52:24 <rwbarton> AirCastle: It's the linear-time tasks that are tough :)
10:53:47 <pumpkin> lol
10:53:55 <pumpkin> I never thought of it that way
10:54:29 <Gracenotes> hm, it seems Haskell doesn't like Church booleans that much sand a b = (a b a). Although (a b false) works just fine. Darn infinite types :X
10:54:42 <pumpkin> I liked the k-clique perl module that basically says "this problem is np-complete... you shouldn't ask it for large cliques"
10:55:05 <pumpkin> @quote wango
10:55:06 <lambdabot> wango says: do you like turing complete?
11:01:16 <CydeWeys> So map (*2) ... works, but not map (*2+1) ...  do I need to nest two map statements, or am I missing something?
11:01:37 <vixey> you should probably write: (+1) . (*2)
11:01:58 <rwbarton> Or, heaven forbid, map (\x -> x*2 + 1)   :)
11:02:21 <dax> i want to use Data.Time in my programm, what do i have to put in the Build-Depends field?
11:02:26 * vixey wonders if the zipper focused on: x*2 + 1  is [(+1),(*2)]
11:02:31 <CydeWeys> Uh-oh, the new syntax is piling on already.
11:03:03 <rwbarton> dax: I think "cabal build" will tell you, provided you have the necessary package installed on your system
11:03:34 <dax>     Could not find module `Data.Time.Clock':
11:03:35 <dax>       Use -v to see a list of the files searched for.
11:03:43 <Raevel> @type (+(*2))
11:03:45 <lambdabot> forall a. (Num (a -> a), Num a) => (a -> a) -> a -> a
11:04:04 <rwbarton> dax: I think that means you don't have the necessary package installed then
11:04:14 <rwbarton> dax: looks like it's the "time" package
11:04:27 <CydeWeys> This code example for making an infinite list of 1s is giving a syntax error?  makeList = 1 : makeList
11:04:52 <rwbarton> CydeWeys: That's a valid declaration
11:04:54 <Raevel> > let makeList = 1 : makeList in makeList
11:04:55 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:04:57 <dax> rwbarton: i can compile it with ghc --make dice.hs
11:05:05 <mmorrow> heh, looks like a haskell "bid request" went unanswered http://www.rentacoder.com/RentACoder/misc/BidRequests/ShowBidRequest.asp?lngBidRequestId=1069445
11:05:26 <mmorrow> (randomly came across this in a google search)
11:05:38 <dax> and "time" in the build-depends is wrong, he can't find it then
11:05:38 <mmorrow> "Extend gitit wiki program"
11:06:36 <rwbarton> dax: Huh, weird.
11:06:45 <rwbarton> dax: Can you :m +Data.Time from ghci?
11:07:00 <dax> yep
11:07:15 <rwbarton> er, Data.Time.Clock I guess, but it shouldn't matter
11:07:25 <dax> everything except cabal build works
11:07:33 <Gracenotes> dax: are you by chance using a Debian-based system?
11:07:47 <Gracenotes> you may have to apt-get libghc6-time-dev
11:07:51 <int80_h> @src third
11:07:51 <lambdabot> Source not found. You speak an infinite deal of nothing
11:07:55 <Gracenotes> if you're building it that way
11:07:55 <mmorrow> , [|\x -> (x * 2) + 1|]
11:07:58 <lunabot>  LamE [VarP x_0] (InfixE (Just (InfixE (Just (VarE x_0)) (VarE *) (Just (L...
11:08:11 <mmorrow> , (\(LamE _ e)->e) `fmap` [|\x -> (x * 2) + 1|]
11:08:14 <lunabot>  InfixE (Just (InfixE (Just (VarE x_0)) (VarE *) (Just (LitE (IntegerL 2))...
11:08:18 <vixey> , fix (\x -> [| (x * 2) + 1|])
11:08:19 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift
11:08:31 <mmorrow> ugh i hate "InfixE"
11:08:49 <Gracenotes> LamE? an uncool lambda?
11:09:18 <int80_h> @take
11:09:18 <lambdabot> Maybe you meant: time type
11:09:23 <int80_h> @src take
11:09:23 <mmorrow> , (\(LamE _ e)->everywhere (mkT (\(InfixE (Just a) o (Just b))->AppE (AppE o a) b)))) e) `fmap` [|\x -> (x * 2) + 1|]
11:09:23 <lambdabot> take n _      | n <= 0 =  []
11:09:23 <lambdabot> take _ []              =  []
11:09:23 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
11:09:25 <lunabot>  luna: parse error on input `)'
11:10:39 <mmorrow> , (\(LamE _ e)->everywhere (mkT (\e -> case e of InfixE (Just a) o (Just b)->AppE (AppE o a) b; _ -> e)) e) `fmap` [|\x -> (x * 2) + 1|]
11:10:41 <lunabot>  AppE (AppE (VarE +) (AppE (AppE (VarE *) (VarE x_0)) (LitE (IntegerL 2)))...
11:11:25 <dax> works, too ;)
11:11:25 <dax> yes.
11:11:25 <dax> i am using ubuntu
11:12:33 <Gracenotes> dax: there are plenty of packages that you can install via apt-get, heavens knows why installing ghc doesn't do it automatically
11:12:41 <bos> What's the name of the arrow combinator that distributes like this? \f g k -> (f k, g k)
11:12:47 * bos curses Control.Arrow
11:13:04 <Gracenotes> mtl, http, parsec, for instance -- all of them uninstalled-by-default dependencies of cabal, incidentally
11:13:14 <Toxaris> @type (***)
11:13:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:13:18 <mmorrow> bos: (&&&)
11:13:23 <rwbarton> @hoogle (c -> a) -> (c -> b) -> c -> (a, b)
11:13:23 <lambdabot> No results found
11:13:40 <rwbarton> @hoogle x c a -> x c b -> x c (a, b)
11:13:40 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
11:13:45 <rwbarton> boo
11:14:00 <bos> mmorrow: thanks!
11:14:05 <mmorrow> :)
11:14:38 <rwbarton> , src ''LitE
11:14:40 <lunabot>  luna: Not in scope: type constructor or class `LitE'
11:14:51 <mmorrow> , src 'LitE
11:14:56 <lunabot>  data Exp = ... | LitE Lit | ...
11:14:56 <lunabot>  infixl 9
11:14:57 <mmorrow> , [|42|]
11:15:00 <lunabot>  LitE (IntegerL 42)
11:15:05 <rwbarton> , src ''Lit
11:15:10 <lunabot>  data Lit = CharL Char
11:15:10 <lunabot>           | StringL String
11:15:10 <lunabot>           | IntegerL Integer
11:15:19 <rwbarton> ok
11:15:41 <mmorrow> (i need to add this function..)
11:15:48 <mmorrow> , (\(TyConI (DataD _ _ _ cons _)) -> fmap (\(NormalC n _)->ppDoc n) cons) $(lift =<< reify ''Lit)
11:15:51 <lunabot>  [CharL,StringL,IntegerL,RationalL,IntPrimL,WordPrimL,FloatPrimL,DoublePrimL]
11:16:48 <rwbarton> , $( return $ InfixE (ListE [IntegerL 1, IntegerL 2]) (AppE (mkName "liftM") (InfixE None (mkName "+") None)) (ListE [IntegerL 10, IntegerL 20]) )
11:16:50 <lunabot>  luna: Not in scope: data constructor `None'
11:16:56 <rwbarton> , $( return $ InfixE (ListE [IntegerL 1, IntegerL 2]) (AppE (mkName "liftM") (InfixE Nothing (mkName "+") Nothing)) (ListE [IntegerL 10, IntegerL 20]) )
11:16:57 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
11:17:02 <rwbarton> argh
11:17:12 <mmorrow> hmm
11:17:25 <rwbarton> , $( do l <- mkName "liftM"; p <- mkName "+"; return $ InfixE (ListE [IntegerL 1, IntegerL 2]) (AppE l (InfixE Nothing p Nothing)) (ListE [IntegerL 10, IntegerL 20]) )
11:17:26 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
11:17:33 <mmorrow> newName
11:17:40 <rwbarton> , src 'mkName
11:17:45 <lunabot>  mkName :: String -> Name
11:17:57 <mmorrow> i tihnk you just forgot the wrap the 1st and 3rd args to InfixE in Just
11:18:02 <mmorrow> , src 'InfixE
11:18:05 <rwbarton> oh that's true
11:18:08 <lunabot>  data Exp = ... | InfixE (Maybe Exp) Exp (Maybe Exp) | ...
11:18:08 <lunabot>  infixl 9
11:18:46 <rwbarton> , $( return $ InfixE (Just $ ListE [IntegerL 1, IntegerL 2]) (AppE (mkName "liftM") (InfixE Nothing (mkName "+") Nothing)) (Just $ ListE [IntegerL 10, IntegerL 20]) )
11:18:48 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
11:19:05 <rwbarton> I wish I could get longer error messages in privmsg
11:19:26 <mmorrow> does it only give one line in /msg too?
11:19:31 * mmorrow checks
11:19:32 <dax_> now it works
11:19:41 <dax_> i was missing the package
11:19:51 <dax_> (but compiling by hand worked Oo)
11:20:03 <mmorrow> rwbarton: good point, i'll fix that
11:20:23 <dons> ?Yow!
11:20:23 <lambdabot> If Robert Di Niro assassinates Walter Slezak, will Jodie Foster marry Bonzo??
11:20:26 <dons> omg
11:20:40 <dons> hey guys. is haskell still working?
11:21:00 <BONUS_> works for me
11:21:10 <roconnor> > 1 + 1
11:21:12 <lambdabot>   2
11:21:12 <dons> woot
11:21:13 <Zao> dons: It entered a blackhole last week :P
11:21:17 <dons> yikes!
11:21:24 <dons> be careful with your applications
11:21:37 <BONUS_> hey what the heck i subscribed to haskell-cafe and im not getting anything in my inbox
11:21:41 <BONUS_> how long does this usually take
11:21:52 <roconnor> I caused a temporal paradox in Haskell tomorrow
11:21:59 <rwbarton> , $( return $ InfixE (Just $ ListE [LitE $ IntegerL 1, LitE $ IntegerL 2]) (AppE (VarE 'liftM) (InfixE Nothing (VarE '(+)) Nothing)) (Just $ ListE [LitE $ IntegerL 10, LitE $ IntegerL 20]) )
11:22:01 <lunabot>  luna: luna: panic! (the 'impossible' happened)
11:22:41 <rwbarton> Hmm, not a solution to the infix expressions problem after all
11:23:10 <idnar> luna luna luna?
11:26:49 <dax_> any idea where i can find h2ps in ubuntu?
11:27:35 <dons> dax_: hmm. should come with ghc
11:27:47 <rwbarton> dax_: do you mean hp2ps?
11:28:05 <dax_> ah!
11:28:09 <dons> ahaha
11:28:45 <dax_> thx :D
11:34:20 <ski_> Gracenotes : oops, you're right .. i managed to flip the order there
11:36:25 <Gracenotes> ski_: no problem! I also made an (Map String U) -> LExpr -> U... I get it a lot better now :D
11:37:04 <ski_> *nod*
11:39:36 <mmorrow> lunabot now forkIOs for every line it reads
11:39:38 <mmorrow> hehe
11:39:51 <mmorrow> , "asdfg" + 99
11:39:53 <lunabot>  luna: No instance for (GHC.Num.Num [GHC.Types.Char])
11:39:53 <lunabot>    arising from a use of `GHC.Num.+' at <interactive>:1:50-61
11:39:53 <lunabot>  Possible fix:
11:39:56 <mmorrow> crap
11:40:18 <pizza_> ...
11:40:20 <Gabbie> lol
11:42:09 <ski_> > "asdfg" + 99
11:42:10 <lambdabot>       No instance for (Num [Char])
11:42:10 <lambdabot>        arising from the literal `99' at <i...
11:42:15 <Raynes> Possible fix: lunabot has quit.
11:42:39 * ski_ stares blankly
11:42:40 <Raynes> Yep, that fixed it. :>
11:42:50 <mmorrow> "crap" because i only want to give 1 line of err msg in chan, and more in /msg
11:45:15 <rwbarton> Looks like they improved this error message in 6.10
11:46:20 <gwern> http://relapse-software.net/haskell_5.png <-- yeearrghh... it's got me! save yourselves!
11:46:31 <mercury^> mapreduce: Do I?
11:46:53 <dax_> why is this so slow? http://paste.pocoo.org/show/99678
11:47:33 <mmorrow> , "asdf" + 99
11:47:34 <lunabot>  luna: No instance for (GHC.Num.Num [GHC.Types.Char])
11:47:56 <Gracenotes> @pl \m n f x -> m (\n' f' x' -> n f' (n' f' x')) (flip const) f x
11:47:56 <lambdabot> flip flip (const id) . (. liftM2 (.))
11:48:02 <Gracenotes> -.-
11:48:09 <Gracenotes> @pl \m n f -> m (\n' f' x' -> n f' (n' f' x')) (flip const) f
11:48:10 <lambdabot> flip flip (const id) . (. liftM2 (.))
11:48:16 <pumpkin> dax_: profile it!
11:48:22 <Gracenotes> hm. 'f course.
11:48:38 <Gracenotes> @unpl flip flip (const id) . (. liftM2 (.))
11:48:38 <lambdabot> (\ t f -> t (\ m -> f >>= \ j -> m >>= \ i -> return (\ p -> j (i p))) (\ _ h -> h))
11:48:39 <gwern> http://www.ep.tc/problems/28/07.html <-- 'About this time the Greek letter lambda developed as the internationally recognized symbol for homosexuals' o.0
11:48:44 <pumpkin> dax_: `rem` is supposed to be faster than `mod` and they're equivalent for positive numbers I think
11:48:46 <Gracenotes> ...yeah, that's useful. argh.
11:48:55 <dax_> profiling just tells me the time is spent im main :o
11:49:03 <pumpkin> dax_: -auto-all ?
11:49:28 <Gracenotes> gwern: I couldn't figure out whether the book was facetious or not until I read the reviews
11:49:37 <pumpkin> dax_: also, IntMap is more efficient than Map Int
11:49:38 <Olathe> @type insertWith'
11:49:39 <lambdabot> Not in scope: `insertWith''
11:49:47 <rwbarton> dax_: System.Random is my guess
11:49:52 <gwern> Gracenotes: which is it?
11:50:00 <pumpkin> rwbarton: is that grabbing from /dev/random ?
11:50:00 <dax_> its not the random numbers
11:50:02 <Gracenotes> gwern: at some points it sounds like religion parodying gays; at other points, it sounds like the other way around
11:50:07 <mercury^> dax_: 10^7 random numbers?
11:50:18 <pumpkin> dax_: if it's getting them from /dev/random, that'll definitely be unusably slow
11:50:26 <pumpkin> nondeterministically slow :P
11:50:33 <Gracenotes> gwern: the conclusion I've come to, based on the reviews, is that it's from a religious POV
11:50:35 <dax_> i tried with a stream of ones - no difference
11:50:45 <pumpkin> also, fromListWith
11:50:46 <rwbarton> dax_: it is for me
11:50:50 <mercury^> It's because printing 10^7 numbers takes a while
11:50:51 <pumpkin> rather than fold insertWith
11:51:07 <rwbarton> dax_: 14 seconds to run that code, 13 seconds if I replace toList . regRolls . roll with sum
11:51:10 <Gracenotes> gwern: it seems the other way around because the person almost seems intentionally factually inaccurate
11:51:31 <gwern> Gracenotes: hm, factual inaccuracy bespeaks distaste of the subject?
11:51:34 <Gracenotes> saying that gays are bad because they do many of the exact same perverted things that... wait for it... heterosexuals do
11:51:39 <mercury^> dax_: an array is better than a map here, also.
11:51:55 <pumpkin> what's the range of the random output?
11:52:05 <pumpkin> oh, `mod` 6
11:52:12 <dax_> hehe :D
11:52:23 <mercury^> dax_: there's Test.BenchPress
11:52:25 <pumpkin> then just use an STArray :P
11:52:28 <pumpkin> or something
11:52:29 <rwbarton> accumArray
11:52:31 <dax_> print . toList . regRolls . roll $ take 10000000 [1..] -> not faster
11:52:43 <rwbarton> dax_: it's 1.4 s vs 14 s for me with that change
11:52:49 <dax_> Oo
11:52:49 <rwbarton> dax_: are you compiling with optimizations?
11:52:56 <gwern> hm, QT is now lgpl. but yet, every haskeller will continue to not use QtHaskell
11:53:00 <pumpkin> dax_: are you printing? outputting that much stuff to stdout will take a while :P
11:53:08 <pumpkin> oh wait, it's a small list
11:53:09 <dax_> oh. right
11:53:18 * sw17ch wonders if there's some incantation needed to summon dons
11:53:24 <dax_> i started the wrong bin.. >.<
11:53:25 <rwbarton> @get-dons
11:53:26 <lambdabot> Unknown command, try @list
11:53:28 <Gracenotes> gwern: anyways, it's a gem. Not as much of a gem as Church numerals, though!
11:53:31 <Gabbie> rwbarton, I thought you ask if dax_ was compiling with optimism.
11:53:36 <dax_> so its the random numbers
11:53:54 <gwern> sw17ch: @seen dons usually works fairly well for me
11:54:01 <sw17ch> @seen dons
11:54:01 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 25m 52s ago.
11:54:24 <gwern> 'Our (small (15 persons))company just less than month ago paid more than 30000$ for QT licenses. I do not dare to tell the news to our CEO.'
11:54:26 <sw17ch> it seem that whenever i do that his presence is lacking at least until i sign out of IRC :)
11:54:44 <mercury^> dax_: also, generating random ints and then modding by 6 is not good
11:55:33 <mercury^> getStdRandom (randomR (1,6))
11:55:35 <CydeWeys> gwern: Ouch
11:55:37 <mercury^> does what you want
11:55:42 <mercury^> properly
11:55:51 <gwern> CydeWeys: hey, when did you start hanging out in #haskell?
11:55:56 <Olathe> > takeWhile (>0).iterate (flip div 6) $ 2^64
11:55:58 <lambdabot>   [18446744073709551616,3074457345618258602,512409557603043100,85401592933840...
11:56:02 <Olathe> > length.takeWhile (>0).iterate (flip div 6) $ 2^64
11:56:05 <lambdabot>   25
11:56:17 <mercury^> So, all in all: use Test.BenchPress, use the proper generator, use an array.
11:56:48 <Olathe> > length.takeWhile (>=6).iterate (flip div 6) $ 2^64
11:56:51 <lambdabot>   24
11:57:01 <CydeWeys> gwern: Earlier today?
11:57:19 <rwbarton> sigh... I think it's taking longer to darcs get the extralibs than it will take to build all of ghc
11:57:21 <gwern> CydeWeys: well if that's the way you swing, I shan't criticize
11:57:30 <dax_> will try the getStdRandom (randomR (1,6))
11:57:38 <CydeWeys> Indeed, it tis.
11:57:42 <gwern> rwbarton: my secret technique was to add &s to the script and get them in parallel
11:57:58 <rwbarton> gwern: that is an excellent idea
11:58:02 <Igloo> rwbarton: You know there are snapshot tarballs that include the extralibs?
11:58:30 <rwbarton> Igloo: Yeah, but I need a patch from Tuesday and I wasn't sure whether it would be included in the latest snapshot, which is from Tuesday :)
11:58:42 <Igloo> rwbarton: But you can ./darcs-all pull once you have the snapshot
11:59:25 <Igloo> rwbarton: where snapshot = http://darcs.haskell.org/ghc-HEAD-2009-01-09-ghc-corelibs-testsuite.tar.bz2
12:00:29 <gwern> maybe rwbarton could just paint his darcs red
12:00:42 <rwbarton> Igloo: Ah, I didn't know about that kind of snapshot (that's different from the ones in http://www.haskell.org/ghc/dist/current/dist/)?
12:01:03 <Igloo> yes; those ones are just source, not darcs repos
12:01:14 <dax_> how do i create an ifinite list of random values from getStdRandom (randomR (1,6)) ?
12:01:33 <rwbarton> I'll just go out and do something else for a while, and then I won't have this problem again, right?
12:01:44 <rwbarton> :t randomRs
12:01:46 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
12:02:09 <gwern> rwbarton: yes. and at the end, there will be cake
12:02:10 <jeffersonheard> I'm wondering a bit about the HTTP 4000.0.1 package...  Up till now, my code's been written using HTTP-Simple, which uses HTTP on the backend.  If I install the package and re-compile the code, do I get the speedup automatically?
12:02:19 <mmorrow> , 42
12:02:21 <lunabot>  42
12:02:38 <Olathe> > let gen = mkStdGen 5; rolls = randomRs (1, 6) in rolls gen
12:02:41 <lambdabot>   [6,2,2,1,3,2,5,1,5,4,2,2,1,2,6,4,2,4,2,3,2,4,5,4,2,1,5,1,6,4,3,2,4,5,5,3,3,...
12:02:43 <ebering> So how do I get multiple linear inhereitence objects
12:02:58 <Olathe> > let gen = mkStdGen 5; rolls = randomRs (1, 6) in take 5.rolls $ gen
12:03:00 <dax_> ah, thx!
12:03:01 <lambdabot>   [6,2,2,1,3]
12:03:02 <mmorrow> rwbarton: the bot src is a total clusterfuck, i'll have to clean it up and add the more-lines-of-err-msg-in-/msg later
12:03:06 <jeffersonheard> it looks like no off the top of my head
12:03:09 <jeffersonheard> @seen dons
12:03:09 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 35m ago.
12:03:16 <gwern> jeffersonheard: iirc, http4k uses a different api
12:03:24 <Martijn> @src negate
12:03:24 <lambdabot> negate x = 0 - x
12:03:29 <gwern> it isn't transparent, that is
12:03:31 <dancor> Main.hs has lines "import qualified Transf.Foo", "import qualified Transf.Bar", .., and "transfs = [Transf.Foo.transfs, Transfs.Bar.transfs, ..]".  How much of this can template haskell automate, when I add or remove a file in Transf/
12:03:36 <jeffersonheard> gwern: that's what I thought
12:03:43 <jeffersonheard> but I haven't seen an example of the new API being used
12:03:45 <dancor> or should i just make some wrapper script to ease such add/removes
12:04:03 <dax_> great. 1.1s instead of 24
12:04:04 <gwern> dancor: the last time I checked on th, it didn't yet handle imports and module declarations
12:04:12 <SamB_irssi> boy thats's a lot of nicks ...
12:04:25 <rwbarton> @users
12:04:25 <lambdabot> Maximum users seen in #haskell: 651, currently: 633 (97.2%), active: 24 (3.8%)
12:04:31 <Martijn> @src (-)
12:04:31 <lambdabot> x - y = x + negate y
12:04:33 <gwern> jeffersonheard: well, dcoutts told me that there were htttp4k patches floating around for cabal-install
12:04:38 <rwbarton> @src Num
12:04:38 <lambdabot> class  (Eq a, Show a) => Num a  where
12:04:38 <lambdabot>     (+), (-), (*)           :: a -> a -> a
12:04:38 <lambdabot>     negate, abs, signum     :: a -> a
12:04:38 <lambdabot>     fromInteger             :: Integer -> a
12:04:43 <dancor> gwern: so i might be able to generate the "transfs = .." bit but nothing else?
12:04:47 <jeffersonheard> gwern: thanks.  I'll see if I can find those
12:04:54 <gwern> jeffersonheard: but I don't know offhand of any packages which used http3k which have updated to http4k besides that
12:05:29 <gwern> dancor: um; I dunno where your TH expressions could be getting the 'Transf.Foo' info from, but besides that...
12:05:31 <jeffersonheard> right.  I switched over to cURL for speedup, but it makes compiling on windows a pain, so I was going to go back to HTTP now that they'd updated it
12:05:44 <ski_> @src Ratio negate
12:05:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:06:06 <gwern> jeffersonheard: if you do change to http4k might be worth emailing -cafe with a description of what you had to do to go from 3k to 4k
12:06:18 <dancor> oh, ok.  can i do source code manipulations with Language.Haskell.Exts that preserve whitespace?
12:06:41 <dancor> like is whitespace part of the abstract syntax tree
12:06:44 <Gracenotes> @pl three s z = s (s (s z))
12:06:44 <lambdabot> three = ap (.) (join (.))
12:07:15 <dancor> i guess i can TIAS
12:07:23 <Gracenotes> ...or just take 3 . iterate :)
12:07:41 <Gracenotes> actually, (!!2)
12:07:45 <gwern> dancor: good question. there must be some way of preserving whitespace, else hint wouldn't give you suggestions which mutate expressions but preserve the whitespace
12:07:59 <dancor> ah, maybe i'll look at hint
12:08:37 <gwern> er, hlint, I meant
12:09:42 * gwern wonders if I should've pressed ndm to rename dr. haskell hlint, given the similarity to 'hint'
12:09:43 <mmorrow> , src ''Exp
12:09:48 <lunabot>  luna: out of memory (requested 1048576 bytes)
12:09:50 <mmorrow> , src ''Exp
12:09:51 <pumpkin> aw
12:09:55 <lunabot>  luna: out of memory (requested 1048576 bytes)
12:09:55 <mmorrow> kill!!
12:10:12 <dancor> maybe hint is the crazier one
12:10:14 <pumpkin> up its memory limit a little?
12:10:19 <pumpkin> one megabyte is a little tight :P
12:10:24 * dancor releases package called h
12:11:01 * gwern shakes fist at dancor. liek there aren't enough packages starting with h! there goes my tab-complete
12:11:21 <SamB_irssi> gwern: you don't NEED to tab complete a package whose entire name is "h"
12:11:49 <dancor> yeah h is all you'll need, it will obsolete those other h* packages
12:11:59 <Gracenotes> @pl \a -> a b c d e f g
12:11:59 <lambdabot> flip (flip (flip (flip (flip ($ b) c) d) e) f) g
12:12:04 <gwern> SamB_irssi: what happens if I *want* the obsolete h* packages?
12:12:22 <mmorrow> , src ''Exp
12:12:33 <gwern> <tab>~/bin/h<tab>h<tab>h<tab>h...
12:12:42 <lunabot>  data Exp = VarE Name
12:12:44 <lunabot>           | ConE Name
12:12:46 <lunabot>           | LitE Lit
12:12:54 <mmorrow> hmm
12:13:14 <SamB_irssi> gwern: what was the first tab for ?
12:13:28 <gwern> SamB_irssi: an offering to the gods of habit
12:13:37 <SamB_irssi> what the ?
12:13:41 * gwern is an oblate of them
12:13:49 <SamB_irssi> hmm, maybe I do that too
12:13:53 <dax_> accumArray dies on stack overflow...
12:14:02 <SamB_irssi> but I don't think about it
12:14:35 <mmorrow> , src ''Exp
12:14:39 <rwbarton> dax_: hmm.  Try it with a UArray
12:14:40 <lunabot>  data Exp = VarE Name
12:14:40 <lunabot>           | ConE Name
12:14:40 <lunabot>           | LitE Lit
12:14:43 <mmorrow> yay
12:16:35 <dancor> cabal-install is always trying to reinstall containers-0.2.0.0 for some reason, and failing on Data/IntMap.hs:182:7:Could not find module `Data.Data':it is a member of package base, which is hidden
12:16:59 <mmorrow> pumpkin: these are the curr limits
12:17:06 <mmorrow> ah, crap one sewc
12:17:45 <moonpatio>   [ (ResourceCPUTime, mkLims 6 6) -- 3 3)
12:17:45 <moonpatio>   , (ResourceTotalMemory, mkLims 200000000 200000000) ]
12:18:08 <pumpkin> :o
12:18:09 <mmorrow> , 200000000 / (1024*1024)
12:18:10 <pumpkin> moonpatio :o
12:18:10 <lunabot>  190.73486328125
12:18:15 <mmorrow> wowo
12:18:16 <pumpkin> ah
12:18:34 <pumpkin> that's the hpaste2 server right?
12:18:36 <mmorrow> and 6 seconds since i restart the evaluator _every_ time :(
12:18:41 <pumpkin> aw
12:18:47 <pumpkin> , "test"
12:18:49 <lunabot>  "test"
12:19:01 <dancor> i tried clearing out my .cabal dir
12:19:07 <pumpkin> is there some way of running the evaluator in the same process?
12:19:08 <vincenz> why a second bot?
12:19:15 <pumpkin> having ghc produce code in memory?
12:19:15 <Olathe> , let (+) a b = 5 in 2 + 2
12:19:17 <lunabot>  5
12:19:20 <pumpkin> + mprotect etc.
12:19:29 <Martijn> Where is instance Monad (Either a) defined?
12:19:31 <vincenz> > 1
12:19:32 <lambdabot>   1
12:19:33 <pumpkin> vincenz: because it's a different bot :) and runs a different version of ghc
12:19:34 <dancor> in case i had done anything weird when first upgraded to 6.10.1
12:19:37 <mmorrow> i want to have the evaluator listen on a port (just read-one-line-answer-with-output protocol). the only thing is that if the evaluator gets killed by rlimits, i'd have to arrange for the bot the restart it
12:19:48 <pumpkin> ah
12:19:59 <mmorrow> that way it wouldn't have to ask ghc for a HscEnv (expensive) every time
12:20:11 <pumpkin> mmorrow: is it possible to catch it in-process before it gets rlimited?
12:20:20 <mmorrow> vincenz: is has some other stuff that lambdabot doesn't
12:20:22 <pumpkin> to internally limit resource usage?
12:20:26 <pumpkin> , permutations [1..3]
12:20:28 <lunabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
12:20:35 <gwern> 'produce code in memory' == GHC API's eval?
12:20:36 <pumpkin> , subsequences [1..3]
12:20:37 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
12:20:46 <mmorrow> , eval "eval \"unQ[|\x -> x|]\""
12:20:47 <lunabot>  luna: lexical error in string/character literal at character ' '
12:20:55 <mmorrow> , eval "eval \"unQ[|\\x -> x|]\""
12:21:00 <lunabot>  luna: lexical error in string/character literal at character ' '
12:21:01 <gwern> mmorrow: I forget, but lunabot doesn't use watchdog threads?
12:21:02 <pumpkin> gwern: why don't the bots use that?
12:21:06 <mmorrow> , eval "eval \"unQ[|\\\\x -> x|]\""
12:21:10 <gwern> pumpkin: lb does
12:21:10 <lunabot>  <<Dynamic>>
12:21:27 <pumpkin> gwern: but last I looked, it was just running a new mueval process
12:21:37 <vincenz> > 1
12:21:39 <lambdabot>   1
12:21:39 <pumpkin> or seemed to be on my machine
12:21:39 <gwern> what do you think mueval is doing?
12:21:54 <pumpkin> well yeah, but the mueval wasn't persistent
12:22:02 <pumpkin> maybe that was just due to all the fix id being thrown at it
12:22:08 <pumpkin> when we were testing it
12:22:08 <mmorrow> gwern: all it is is a quicky 20 minutes-to-write bot that pipes a single line into a quicky 20-minutes-to-write wrapper prog over the eval function:
12:22:12 <mmorrow> , eval "42"
12:22:17 <lunabot>  <<Integer>>
12:22:17 <ski_> Martijn : `Control.Monad.Error', i believe
12:22:34 <Olathe> . eval "evil"
12:22:35 <mmorrow> gwern: so nothing fancy (yet)
12:22:37 <gwern> pumpkin: yes, mueval isn't persistent; easier to write it that way
12:22:37 <Olathe> , eval "evil"
12:22:41 <lunabot>  luna: Not in scope: `evil'
12:22:49 <ski_> @type do Left undefined; return ()
12:22:50 <lambdabot> forall a. (Error a) => Either a ()
12:22:54 <mmorrow> , eval (show "evil")
12:22:59 <lunabot>  <<[Char]>>
12:23:01 <pumpkin> hmm okay :)
12:23:13 <gwern> pumpkin: and more secure, since otherwise an expression might generate some output, and then hijack the bot for its own nefarious purposes
12:24:00 <sw17ch> neferious bot is nefarious...
12:24:01 <gwern> or it could just DOS - if the entire process doesn't end with each eval, how do you know it's still working? when evaluating untrusted code, you want as little shared state as possible...
12:24:17 <ski_> Martijn : however, note that the instance there is `instance Error e => Monad (Either e)', which is evil
12:24:29 <pumpkin> gwern: yeah, I meant that you could just spawn a separate thread and kill it after a speciied time limit, just like a separate process
12:24:29 <gwern> I'm still nervous that "lb's writing to a file for mueval to load" is going to bite me someday
12:24:40 <Martijn> ski_: Yes, I just noticed the error constraint. It's buggig me.
12:24:47 <dancor> it's confusing how the containers install could remain broken for very long, regardless of if the problem is in that package or in cabal-install
12:25:13 <Martijn> ski_: but I guess it's necessary to implement a good fail
12:25:15 <gwern> pumpkin: actually, ghc 6.10 demonstrates why that is a bad idea
12:25:26 <ski_> Martijn : `fail' is evil, too :)
12:25:36 <mmorrow> gwern: since we're running bytecode, in principle we should be able to have 100% full control over it, but we don't currently with ghc's bytecode interp (let x = x in x will lock everything up)
12:25:38 <Martijn> ski_: definitely :-(
12:25:43 <ski_> (as long as it is in `Monad', at least)
12:25:54 <pk> I just read something about the halting problem
12:26:01 <gwern> pumpkin: with ghc 6.10, if one thread evals 'let f = f + 1 in f' (or whatever infinite loop), then the other threads never run!
12:26:15 <Martijn> ski_: it should be in a separate class
12:26:21 <pumpkin> gwern: yeah, I've noticed (and have been very frustrated by it) :P
12:26:23 <mmorrow> that one is OK though, since it is allocating mem
12:26:43 <mmorrow> do "let x = x in x" in ghci
12:26:45 <pumpkin> gwern: doesn't mean that's correct behavior though... if that could be fixed it seems like there's no reason not to run a persistent mueval?
12:26:52 <gwern> mmorrow: well I don't have the exact expression memorized. there's a couple expressions in my testsuite which trigger it
12:26:55 <mmorrow> (then ^Z kill -9)
12:27:29 <gwern> pumpkin: it just illustrates the point - small changes in lowlevel code can totally destroy security if you can operate only *within* a process
12:28:04 <gwern> I'm thinking of switching to 'watchdog processes' - spawning a separate process which will kill the main mueval process - since doing that on the thread level obviously doesn't work
12:28:06 <pumpkin> yeah :) low-level bugs in your compiler/runtime can destroy your app security :P
12:28:15 <mmorrow> fix id, let x = x in x, anything that doesn't ever try to allocate mem, since that's the hook ghc's scheduler uses, so a thread that just tightly loops and never allocates (in bytecode) currently is runaway until you kill -9 it
12:28:31 <dax_> http://paste.pocoo.org/show/99689/ test bench is weird Oo
12:28:32 <mmorrow> in compiled code it would die with
12:28:35 <mmorrow> <<loop>>
12:28:50 <gwern> pumpkin: right, but imagine I had started with watchdog processes - then it wouldn't matter about non-allocating threads
12:29:03 <gwern> because there's less shared state - state like the GHC RTS
12:29:14 <pk> I was wondering, If we make sure the program never call the function 'halt', then is it possible to say it will halt ?
12:29:16 <chrisdone> how flexible are kinds?
12:29:17 * gwern is probably abusing the term shared state here :)
12:29:29 <chrisdone> * -> * says something is a type constructor,  yes?
12:29:35 <pumpkin> yeah :) but ideally, you shouldn't have to worry about low-level bugs :) I mean, you could say by similar reasoning that you're assuming the OS process memory is correctly separated :)
12:29:38 <pumpkin> but I do see what you mean
12:29:40 <mauke> chrisdone: yes
12:29:41 <mmorrow> ideally you'd have the evaluator always running, with a watchdog proc making sure to restart it if it's killed by rlimits
12:29:45 <pumpkin> and that GHC is a work in progress :P
12:29:59 <Martijn> Any piece of software is
12:30:19 <chrisdone> what about: a -> a -> *, does this mean a type constructor which takes two of the same type and constructs a new type?
12:30:27 <mmorrow> because then you don't have to do an expensive have-ghc-read-package.conf-other-stuff-give-you-an-env every expression
12:30:35 <Martijn> chrisdone: two of the same kind I guess
12:30:39 <ski_> chrisdone : there is no kind polymorphism
12:30:45 <jeffersonheard> uh.... wow.  okay. a simple 5mb image on my local server...  old HTTP: 1.605 secs
12:30:52 <jeffersonheard> new HTTP: 0.102 secs
12:30:52 <chrisdone> oh, I see
12:31:03 <Martijn> ski_: not in Haskell, but there is in Agda I think
12:31:17 <mmorrow> chrisdone: one thing is every kind has to end in "-> *"
12:31:25 <dancor> can i force cabal to use base-4
12:31:26 <mmorrow> pita
12:31:26 <ski_> Martijn : yes .. presumably chrisdone was asking about haskell
12:31:37 <Martijn> ski_: *nods*
12:31:49 <ski_> @kind GHC.Base.Int#
12:31:50 <lambdabot> #
12:31:57 <ski_> no `.. -> *'
12:31:59 <chrisdone> so kinds just describe the arity of a type?
12:32:00 <pumpkin> what are those # types?
12:32:20 <rwbarton> chrisdone: the arity of a type, and the arity of its arguments, etc.
12:32:28 <ski_> pumpkin : `#' is kind of unboxed types (this was mentioned a bit earlier today)
12:32:35 <pumpkin> ah :)
12:32:36 <chrisdone> rwbarton: right
12:32:48 <pumpkin> sorry, wasn't paying attention
12:33:26 <milton131> Â±Â²Â³1³Â±Â²Â³Â±Â²Â´Â±Â²Â³Â±Â²
12:33:50 <mauke> milton131: what?
12:33:59 <chrisdone> I'll look at the haskell 98 report, I presume there'll be a nice description of kinds there
12:34:03 <chrisdone> preflex: be poppavic
12:34:04 <preflex>  if I get the chance to shit on yer nose, will you tolerate the procedure or react? Wwhen do you react? why? whose "timeslice"?
12:34:30 <dancor> when i hack the cached package cabal file, i get this error: cabal: At least the following dependencies are missing: base >=4 && ==3.0.3.0
12:34:53 <chrisdone> http://www.haskell.org/onlinereport/decls.html#sect4.1.1
12:34:54 <chrisdone> lovely
12:35:10 <dancor> but idk why cabal-install tacks on the ' && ==3.0.3.0' there
12:37:32 <jeffersonheard> nice...  30 reps of HTTP-4001 make it faster than even downloading using cURL
12:37:52 <dax_> http://paste.pocoo.org/show/99691 i can't get faster :(
12:37:58 <jeffersonheard> 0.0521 secs on average HTTP vs 0.069 secs average on cURL
12:40:02 <rwbarton> dax_: on my machine it seems to be spending about 95% of its time generating random numbers
12:40:33 <rwbarton> @hackage mersenne-random
12:40:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random
12:40:55 <rwbarton> You might try that for faster random number generation
12:41:03 <jeffersonheard> http://hpaste.org/13928
12:41:55 <dax_> thx rwbarton :)
12:45:11 <gwern> jeffersonheard: well, as I said elsewhere - http4k is ridiculously faster than 3k (or: 3k was ridiculously slow)
12:45:51 <gwern> although in my benchmarking of 20meg ghc files on haskell.org showed curl with a few% advantage, which was interesting
12:47:23 <jeffersonheard> gwern: I remember you saying it, which is why I decided to change over.  At this speed, though, the network will be the limiting factor, and not using curl means I don't have to install cygwin on the host machine
12:47:26 <jeffersonheard> for windows
12:48:00 <gwern> jeffersonheard: cool. what is using it anyway?
12:48:48 <dublpaws> Data.Map.lookup 'A' (Data.Map.fromList (zip "ABC" [1..])) --  that, I hope returns Just 1   ...  I was under the impression that <- will yank the value 1 from the maybe monad resulting in happiness. There is no happiness though - only despair and utter hopeless feelings of inadequacy.
12:48:54 <jeffersonheard> gwern: Not a library -- an app.  A realtime collaborative environment for GIS/large images called The Big Board (right now)
12:49:07 <gwern> GIS... geographic something something?
12:49:22 <jeffersonheard> gwern: will be submitting a poster on it for ICFP next year as well as a full paper on some of the internals, notably a pure-functional implementation of the R-Tree indexing structure
12:49:29 <Nafai> gwern: Geographic information systems
12:49:37 <jeffersonheard> Nafai: thanks
12:49:41 <Nafai> np
12:49:42 <mauke> > M.lookup 'A' (M.fromList (zip "ABC" [1..]))
12:49:44 <lambdabot>       No instance for (Show (m t))
12:49:44 <lambdabot>        arising from a use of `show' at <in...
12:49:49 <mauke> > M.lookup 'A' (M.fromList (zip "ABC" [1..])) :: Maybe Int
12:49:50 <lambdabot>   /tmp/5084615323301337756:70:36: Not in scope: `M.lookup'/tmp/50846153233013...
12:49:51 <Nafai> I've done a bit with GIS in the past.  All Java, unfortunately.
12:49:58 <mauke> wtf
12:50:06 <gwern> jeffersonheard: ok, then I won't bug you about what it means to collaborate on large images of maps :) I'll just wait for dons to post your project a couple dozen times to reddit
12:50:13 <jeffersonheard> lol
12:50:14 <jeffersonheard> right
12:50:22 <jeffersonheard> I should start a blog for these things
12:50:23 <mauke> , M.lookup 'A' (M.fromList (zip "ABC" [1..])) :: Maybe Int
12:50:25 <lunabot>  luna: Not in scope: `M.lookup'
12:50:51 <Cale> dax_: Also, using Data.Map rather than UArray is just *slightly* faster, at least in my test... I'm just retrying it with optimisations turned on.
12:51:09 <Cale> Ah, okay, with -O2, it's just slightly slower.
12:51:13 <gwern> jeffersonheard: blogs can be interesting in haskell. I've long wanted to use gitit with my darcs backend as a blogging engine
12:51:48 <jeffersonheard> gwern: think teleconferencing, but instead of a virtual whiteboard for people to draw on, you have a virtual map for people to pin things to and draw on, and "things" can be anything from quick snippets of text to anything that can be viewed on the web currently
12:52:00 <gwern> (although I've no idea who could host such a thing!)
12:52:05 <rwbarton> Cale: What if you replace the random number generation with cycle [1..6]--is it still only a slight difference then?
12:52:08 <sbahra> Is there anything I should be worried about when upgrading ghc to 6.10.1 from 6.8.3?
12:52:20 <sbahra> For example, ABI issues with currently installed packages.
12:52:26 <gwern> sbahra: well, reinstalling everything could be annoying
12:52:39 <sbahra> gwern, so I should remove all installed packages?
12:53:29 <rwbarton> sbahra: ghc will keep the package configurations separate for different versions
12:53:34 <gwern> sbahra: I think installed libraries will just be ignored
12:53:42 <gwern> if they're for the worng version
12:53:47 <rwbarton> sbahra: I'd suggest not uninstalling ghc-6.8.3 even
12:53:58 <Cale> rwbarton: Without optimisations, UArray is about 3 times slower than Map then, and with optimisations, it's about 3 times faster.
12:54:11 <sbahra> rwbarton, ok, perfect.
12:54:30 <sbahra> Makes sense.
12:54:36 <sbahra> ghc-6.8.3, etc...
12:54:42 <rwbarton> sbahra: Right
12:55:06 <rwbarton> sbahra: I'm on debian so my ghc-6.10.1 is in /usr/local/bin, while ghc-6.8.2 is in /usr/bin, which makes it even more convenient to choose one or the other
12:55:19 <rwbarton> sbahra: just need to modify my PATH appropriately
12:55:23 <sbahra> nod
12:55:29 <sbahra> I'll try to work out something pretty for FreeBSD ports.
12:55:49 * sbahra is probably going to have ghc-6.8 port, ghc-6.10 port and then ghc meta-port.
12:56:57 <Cale> But yes, most of the work seems to be spent on generating pseudorandom numbers. I wonder what makes System.Random so inefficient...
12:56:57 <rwbarton> Cale: UArray in only 3 times faster--that's pretty impressive for Data.Map
12:57:06 <rwbarton> s/in/is/
12:57:17 <rwbarton> How about IntMap?
12:57:18 <Cale> I've had really good experiences with Data.Map in general.
12:57:24 <Cale> okay, I'll try it :)
12:58:13 <gwern> Cale: splittable, I guess. dons' mersenne random generator is not splittable and it's many times faster
12:58:22 <dancor> is it weird that the darcs cabal-install depends on cabal 1.6 which is not the darcs cabal which is 1.7
12:58:40 <dancor> i guess it's a trickle-down model of stability
12:58:50 <Cale> rwbarton: Uh... Data.IntMap appears to be missing insertWith' ...
12:58:58 <gwern> Cale: I remember someone saying that it was odd there'd been so little research on fast splittable random generators
12:59:27 <Cale> gwern: I don't see how mersenne isn't at least naively splittable
12:59:32 <rwbarton> Cale: sigh
12:59:42 * dancor used to think splitting was kwlr before Control.Monad.Random
12:59:45 <gwern> Cale: a wizard did it
13:00:00 <thoughtpolice> wizards tend to do stuff like that I guess?
13:00:15 <Cale> All you'd have to do is use your existing mersenne generator to generate random states for two new ones...
13:00:49 <Cale> split isn't really required to have any statistical guarantees
13:00:50 <drdozer> If I've got something expensive that runs in MonadRandom, and I want to run, say 100 replicates, and want to be able to run these in parallel, what should I do?
13:01:00 <dancor> yeah in that sense every seedable generator is splitable
13:01:43 <gwern> drdozer: the usual stuff I guess. use the parallel strategies
13:01:59 <drdozer> gwern: na, because the random seed is threaded between the 100 repetitions
13:02:01 <rwbarton> drdozer: you want some kind of MonadRandom interface to split?
13:02:15 <dancor> ya i guess splitting is inherently kwlr for parallelism
13:02:20 <dancor> hmhmhm
13:02:48 <gwern> drdozer: you can't take 100 nums and pass each replicate 1 num?
13:03:08 <rwbarton> You could have an Applicative interface to Random that used split in ap
13:03:13 <rwbarton> (I think)
13:03:16 <gwern> 'parMap (replicate stuff) $ take 100 gen' I guess I was thinking
13:03:45 <rwbarton> gwern: maybe each computation needs many random numbers
13:03:57 <drdozer> rwbarton: yeah - a <- runInSplit someFunc
13:03:59 <rwbarton> gwern: in which case you can use split, but it doesn't exactly fit in the MonadRandom mold
13:04:11 <sbahra> What do you mean by "split"?
13:04:13 <gwern> rwbarton: bah! they can just create a new generator using their given number
13:04:45 <rwbarton> drdozer: unsafeInterleaveRandom :: (MonadRandom m) => m a -> m a
13:05:01 <sbahra> ;-[
13:05:08 * sw17ch freaks out after chasing down a problem with his javascript only to discover that it's an IE bug
13:05:14 <gwern> blast, the old darcs does indeed fail filestore tests
13:05:21 <int-e> rwbarton: you can implement a newStdGen analogue for MonadRandom using split
13:05:37 <Cale> rwbarton: Without insertWith', I have to increase the stack space available for it to run, and it consumes most of my available memory, and optimised, it runs about 3 times slower than the unoptimised UArray solution (which is 3 times slower than the unoptimised Data.Map solution)
13:06:19 <drdozer> rwbarton: does that function exist? hoogle doesn't seem to know about it
13:06:24 <rwbarton> Cale: Yeah, that's not terribly surprising
13:06:34 <rwbarton> drdozer: No, it was a semi-joking name for your runInSplit
13:06:55 <edwardk> @seen lispy
13:06:56 <lambdabot> lispy is in #haskell-blah, #darcs and #haskell. I last heard lispy speak 18h 13m 17s ago.
13:07:03 <rwbarton> drdozer: based on the similarity of its type and semantics to unsafeInterleaveIO
13:07:09 <Cale> IntMap is kind of a stupid library which really should not exist anyway. I always write things in terms of Data.Map, with the understanding that if my keys are Ints, then eventually at some future point in time it'll optimise that case.
13:07:15 <drdozer> rwbarton: well anyway, something like that - then I can fold it over a list of monad randoms
13:08:03 <drdozer> Cale: the compiler, or the library?
13:08:16 <Cale> drdozer: The library, with help from the compiler.
13:08:54 <drdozer> Cale: isn't that one of the cases where indexed types and type synonyms are meant to help out?
13:09:00 <Cale> Yeah.
13:09:02 <drdozer> data-specific collections
13:09:14 <rwbarton> @hackage gmap
13:09:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gmap
13:09:16 <Cale> Though I don't think the current rendition can really help at this point...
13:09:25 <Cale> Oh, perhaps...
13:09:41 <edwardk> cale: now if we can only do that for (byte)strings ;)
13:09:53 <drdozer> I've still not found a use for the indexed types (rather than synonyms) - perhaps I just don't understand them well enough
13:10:32 <Cale> My understanding is that type families in their current state are open, so, like class instances, you need a type constructor to select on, and can't write a fall-through case.
13:10:36 <rwbarton> drdozer: do you mean data families vs. type families?
13:10:41 <drdozer> yes
13:10:53 <Cale> Or data families, yes
13:10:55 <drdozer> I use type-families a lot, but haven't yet found a use for data families
13:11:02 <rwbarton> I'm currently using data families in a project, but can't really say I *understand* them
13:11:20 <Cale> We should really have closed data families, I have a feeling they would be much more useful in many cases.
13:11:29 <rwbarton> A data family is basically like an open GADT
13:11:38 <Peaker> Cale: what's that?
13:12:09 <Gracenotes> yay, I've finished an incredibly rudimentary version of my lambda-calculus-based RPN esoteric language! ">x + #x 0 + @" evals to 2 :)
13:12:18 <Cale> Peaker: Open vs. closed in the sense of whether it can be extended later.
13:12:31 <edwardk> drdozer: i use type families for a lot of crap i used to use big bloated MPTCs for. data families are arguably useful when you need to be able to run that backwards but i prefer type to data families.
13:12:48 <_dolio> I thought closed families were coming in 6.10, but alas, not.
13:12:53 <Cale> Peaker: Currently, typeclasses, data families, type families, etc, are all open, which means that they allow future modules to write new instances.
13:12:55 <Peaker> I asked on the haskell cafe list why there is both "type" and "data" inside type-classes, and augustss replied that "data" ensures that the data-type can, by being unique, derive back which typeclass it is
13:12:56 <drdozer> Cale: stating disjointness between classes would be great
13:13:02 <rwbarton> drdozer: Here is a simplified version of my use case for data families: http://hpaste.org/13738#a4
13:13:21 <Peaker> Cale: by "data families" you mean a "data" declaration inside a type-class?
13:13:49 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#data-families
13:13:54 <dolio> Families don't have to be tied to a type class.
13:15:38 <dolio> uvector uses data families, as well.
13:16:53 <drdozer> rwbarton: ah, nice - perhaps I should re-visit it for my distributions module
13:16:56 <Cale> It seems common to have parametric data types for which you'd like to have various special cases at specific types, and then a polymorphic case which handles all the others.
13:17:07 <dolio> That was, after all, one of the original points of data/type families. They let you do specialization of the array representation for stuff like the data parallel arrays.
13:17:10 <sw17ch> how are compiler extensions handled across modules?
13:17:16 <Cale> dolio: yeah...
13:18:00 <drdozer> I find indexed types make the coded much closer to your ontology/terminology
13:18:08 <drdozer> since you re-name types in a specific context
13:18:09 <Cale> sw17ch: Typically, a module which was compiled with extensions doesn't force other modules it is built against to include those extensions.
13:18:35 <sw17ch> Cale: the follow up question is how much extensions can break the way modules interface to eachother?
13:18:40 <sw17ch> or how they can
13:18:43 <rwbarton> Hmm, my ghc build isn't installing: ghc-pkg: /usr/local/lib/ghc-6.11.20090114/package.conf: openFile: does not exist (No such file or directory)
13:18:52 <Cale> sw17ch: Well, depends which extensions you're talking about...
13:18:52 <sw17ch> that question probably shouldn't involve a quantity
13:19:05 <drdozer> rwbarton: sudo?
13:19:10 <sw17ch> Cale: in the case of -XEmptyDataDecls, i see no reason that should cause problems
13:19:11 <dancor> :t split
13:19:13 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
13:19:16 <sw17ch> nor in the case of ViewPatterns
13:19:19 <Cale> sw17ch: Right, that's not a problem.
13:19:19 <rwbarton> drdozer: yeah, sudo make install
13:19:22 <sw17ch> but i'm guessing there are some somewhere that must
13:19:43 * ski_ wonders whether `EmptyDataDecls' also allow `case e of {}' .. and if not, why so ?
13:19:47 <Cale> sw17ch: The more interesting cases are with the extensions that lift restrictions on typeclass instances.
13:19:59 <rwbarton> I don't remember having this problem with ghc-6.11.20090107 :P
13:20:02 <sw17ch> Cale: of course. MultiParamTypeclasses
13:20:10 <rwbarton> > case 1 of {}
13:20:11 <Cale> sw17ch: In that case, I believe it's the extensions that the class-declaration was compiled with that determine what instances are allowed.
13:20:12 <lambdabot>   <no location info>: parse error on input `}'
13:20:15 <Zao> Anyone has Windows 7 here?
13:20:33 <sw17ch> really
13:20:37 <Zao> If I launch ghci from the Run menu or start menu, it crashes.
13:20:39 <sw17ch> ah, i see it now
13:20:43 <Zao> It works fine in a command window.
13:20:44 <drdozer> haha, is windows 7 just the Vista beta 2?
13:20:50 <dolio> I don't think you can write an instance for a MPTC without having the LANGUAGE pragma on that module.
13:21:04 <sw17ch> Cale: It still seems to be a bit like magic in many cases, either that or many of the extensions boil down to an optimization or a set of syntactic sugar
13:21:07 <dolio> You might be able to use them in a context, though.
13:21:31 <Cale> sw17ch: Well, mixing modules compiled with different extensions is always going to be slightly magical.
13:21:42 <Zao> "The application failed to initialize properly (0xc0000142). Click OK to terminate the application."
13:21:44 <Cale> There's little way around that.
13:21:59 <Cale> But I haven't found it to be a problem in practice.
13:22:17 <Cale> Typically, you build the whole project with one set of extensions anyway.
13:22:19 <sw17ch> Cale: are there exts that don't play nice with eachother?
13:22:34 <Cale> There might be. I don't know.
13:22:55 <Cale> I don't know of any examples of that.
13:23:22 <Cale> Well... functional dependencies and GADTs have no interaction.
13:23:48 <Cale> So if you use them together, the type inference will seem to fail in cases where you can work out what the types should be.
13:24:25 <Cale> But type families and GADTs interact nicely.
13:24:50 <drdozer> are functional dependencies likely to be deprecated?
13:24:51 <Gracenotes> @hoogle String -> Maybe Int
13:24:51 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
13:24:51 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
13:24:51 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:24:56 <Gracenotes> mreh.
13:25:06 <drdozer> since you can do all the useful stuff with type families
13:25:13 <Cale> (Type families were invented primarily to make the interaction with GADTs easier to specify)
13:25:53 <dpratt71> what's the name of this channel's "overflow" channel?
13:25:55 <pejo> drdozer, what useful stuff can't you do with functional dependencies?
13:26:08 <Cale> dpratt71: #haskell-overflow
13:26:13 <Gracenotes> @hoogle String -> Bool
13:26:13 <lambdabot> Distribution.PackageDescription flagDefault :: Flag -> Bool
13:26:13 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
13:26:13 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
13:26:29 <drdozer> pejo: I can't think of any - I can't think of anything that I used to use fundeps for that I can't do with type families
13:26:31 <dpratt71> Cale: thanks; is that logged by any chance?
13:27:10 <Cale> dpratt71: I don't know.
13:27:17 <Cale> dpratt71: I have logs of it.
13:27:31 <Cale> (with some gaps, I'm sure)
13:28:15 <dpratt71> do you have the logs from our recent discussion?
13:28:24 <Gracenotes> @src all
13:28:24 <lambdabot> all p =  and . map p
13:28:25 <Cale> yep
13:28:36 <Cale> In fact, it's still in my scrollback buffer :)
13:29:00 <dpratt71> Cale: in what format and can I get a copy?
13:29:26 <dpratt71> Cale: I wanted to review a couple of things we discussed
13:32:10 <sw17ch> Cale: I haven't played with GADT's yet, i suppose i should
13:33:46 <ski_> dpratt71 : <http://tunes.org/~nef/logs/haskell/09.01.14> might be useful ..
13:34:05 <dpratt71> ski_: ok, thanks
13:36:19 <dax_> thx for testing, Cale
13:37:52 <Cale> dax_: No problem. The real problem is as rwbarton identified, in the generation of pseudorandom numbers.
13:39:26 * dancor gives up debugging this cabal-install issue
13:41:55 <Cale> I wonder how long type families will last.
13:42:27 <dancor> that quote will probably be funny in the future
13:42:27 <Gracenotes> longer than my toy programming language :P
13:42:34 <dancor> one way or the other
13:42:36 <Cale> It seems that proper type functions would obviate the need for them.
13:42:41 <Gracenotes> ">x >y @ #x #y 1 @ >x + #x @" isn't really readable >_> fun, though
13:43:06 <Cale> Gracenotes: forthish?
13:43:37 <Gracenotes> Cale: yep! equivalent to the Haskell code (\x y -> x y) (\x -> x+1) 1
13:44:30 <Gracenotes> Writing useful programming languages in it will probably be more difficult than brainfuck
13:44:43 <Gracenotes> er, programs
13:44:56 <Cale> hehe, maybe programming languages as well ;)
13:45:19 <gbacon> ?pl \x -> ((,) x)
13:45:19 <lambdabot> (,)
13:45:22 <Gracenotes> perhaps. The lambda calculus is Turing-complete, after all
13:45:31 <gbacon> ?pl \x y -> ((,) x y)
13:45:31 <lambdabot> (,)
13:45:50 <gbacon> ?pl \x -> ((,) 1 x)
13:45:50 <lambdabot> (,) 1
13:46:58 <Gracenotes> instead of using the boolean and number extensions, perhaps I should using Church encoding :D
13:47:06 <Gracenotes> *use
13:47:27 <sbahra> Hrm?
13:47:37 <sbahra> Some things have changed in 6.10.1 with regards to handleToFd?
13:47:48 <ski_> encode computable reals by church encodings !
13:48:58 <Gracenotes> heck, Haskell doesn't even have computable reals
13:49:11 <ski_> > pi :: CReal
13:49:13 <lambdabot>   3.1415926535897932384626433832795028841972
13:49:25 <Gracenotes> so that's what "C" stands for >_>
13:49:41 <sw17ch> what defines a "computable real" as opposed to a real
13:49:41 <ski_> > showCReal 50 pi
13:49:43 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
13:50:13 <ski_> sw17ch : that it is definitely computable
13:50:32 <Trafalgard> > pi
13:50:34 <lambdabot>   3.141592653589793
13:50:42 <Trafalgard> > :type pi
13:50:43 <lambdabot>   <no location info>: parse error on input `:'
13:50:44 <sw17ch> ski_: as opposed to 1/11 ?
13:50:46 <Trafalgard> whr?
13:50:53 <Trafalgard> @type pi
13:50:55 <lambdabot> forall a. (Floating a) => a
13:51:06 <Gracenotes> ski_: what are non-computable reals? irrational numbers? transcendent ones?
13:51:07 <sbahra> :t pi
13:51:08 <ski_> sw17ch : `1/11' is definitely computable
13:51:09 <lambdabot> forall a. (Floating a) => a
13:51:14 <sw17ch> ski_: what's not :)
13:51:33 <Trafalgard> What's the difference between @type here and :type?
13:51:38 <sbahra> @hoogle showCReal
13:51:38 <lambdabot> No results found
13:51:39 <cknapp> Ah, I love C... reading a CS:APP, and a caption reads "This code uses casting to circumvent the type system"... *sigh*
13:51:48 * Trafalgard saw someone use @ a bunch yesterday, that's why I used it
13:51:50 <sbahra> ski_, where is showCReal?
13:51:58 <ski_> @index showCReal
13:51:59 <lambdabot> bzzt
13:52:01 <cknapp> I don't think there is a difference...
13:52:13 <ski_> @bitsmack
13:52:13 <lambdabot> :)
13:52:21 <Cale> Trafalgard: :t is a shortcut for @type
13:52:22 <ski_> @hoogle CReal
13:52:22 <lambdabot> No results found
13:52:28 <cknapp> "@" is how to normally get lambdabot's attention, but :t is a shortcul...
13:52:36 <cknapp> Or Cale can beat me to it. :)
13:52:49 <Gracenotes> Data.Number.CReal
13:52:59 <sbahra> @src showCReal
13:53:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:53:05 <sbahra> Gracenotes, ah
13:53:05 <Gracenotes> showCReal :: Int -> CReal -> String
13:53:08 <sbahra> thx
13:53:23 <Trafalgard> @src pi
13:53:23 <lambdabot> Source not found.
13:53:33 <Trafalgard> @info pi
13:53:33 <lambdabot> pi
13:53:36 <Trafalgard> :|
13:53:41 <Gracenotes> Trafalgard: I wouldn't do @src pi if I were you!
13:53:52 <Gracenotes> you might infringe someone's copyright!
13:54:01 <cknapp> @src pi
13:54:01 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:54:05 <mauke> pi = 355/113
13:54:13 * cknapp is sad
13:55:00 <Gracenotes> Trafalgard: lambdabot does not really come up with the sources dynamically; rather, it has a file containing specific source definitions, most of which are what's actually used in GHC
13:55:25 <mauke> and there is no @info
13:55:27 <rwbarton> , src 'pi
13:55:32 <lunabot>  Class op from Floating: pi :: forall a . Floating a => a
13:55:42 <mauke> actually, someone should make @info an alias for @eval
13:56:02 <Trafalgard> ah well.
13:56:08 * Trafalgard does :info in ghci instead
13:56:10 <ski_> @info +
13:56:10 <lambdabot> (+)
13:56:10 <tromp__> Gracenotes: an example uncomputable real is the halting probability Omega
13:56:12 <mauke> @help eval
13:56:12 <lambdabot> eval. Do nothing (perversely)
13:56:13 <Trafalgard> It spams a bit anyhow
13:56:44 <Gracenotes> Chaitin's constant, says Wiki
13:57:11 <ski_> (Gracenotes : non-computable numbers are such that cannot be approximated to any degree ..)
13:57:15 <sbahra> does numbers build fine on 6.8?
13:57:18 <Trafalgard> :eval doesn't exist in ghci, too :P
13:57:25 <sbahra> appears to give trouble
13:57:27 <Cale> Also, any undefinable real :)
13:57:28 <Gracenotes> "I'm thinking of a real number, any real number..."
13:57:42 <Gracenotes> is an example of a non-computable real
13:57:50 <Cale> hehe
13:57:51 <Gracenotes> at least, I can computer it. You can't.
13:57:55 <Gracenotes> *compute
13:58:05 <tromp__> that's unspecified ratehr than uncomputable:)
13:58:06 <Gracenotes> So I suppose it is computable. darn.
13:58:36 <Cale> There are only countably many definitions of specific real numbers, so most real numbers are not even definable.
13:59:05 <Cale> (let alone computable)
13:59:08 <beelsebob> Cale: in fact, the chance of chosing an irrational from the real numbers is 1
13:59:16 <beelsebob> so that would be very very likely
13:59:23 <tromp__> cale, pls give us an example of an undefinable number:)
13:59:30 <Cale> Similarly with regard to definable reals
13:59:38 <beelsebob> but I guess that's not the same as computable
13:59:45 <beelsebob> after all, pi is computable and also irrational
13:59:49 <Cale> tromp__: By definition I can't give a specific one.
14:00:04 <Gracenotes> but who knows, some supposedly non-computable real number you find lying around might actually be sin(exp(6593^(43/291)))
14:00:06 <tromp__> just kidding:)
14:00:20 <Gracenotes> so it is quite tricky
14:00:23 <Cale> tromp__: Though, if I extend the ZFC axioms with some additional assumptions, I can define more real numbers than I used to be able to.
14:00:26 <cknapp> Gracenotes: by definition, that's computable
14:00:42 <Gracenotes> cknapp: once you find out how to compute it, yes
14:01:05 <cknapp> Ah. I see your point
14:01:24 <Cale> Gracenotes: er...
14:01:38 <cknapp> The halting probability numbers are provably uncomputable
14:01:57 <Cale> Gracenotes: There must be real numbers for which no program exists to compute them, not just that we don't know a program to compute them.
14:03:17 <Cale> (that's what the uncomputable reals are)
14:05:25 <Olathe> That's because there are at least 200 more real numbers than integers.
14:05:27 <Olathe> And 200 is a lot.
14:05:40 <Gracenotes> Cale: hm.. so there must be a number such that there does not exist an x that makes the number equal to f(x)?
14:05:50 <Gracenotes> where f is any function from one real to another one
14:05:58 <Cale> Hm?
14:06:05 <Olathe> Gracenotes: No, that's not it.
14:06:10 <Cale> Most functions R -> R are not computable either.
14:06:17 <cknapp> Cale: where f is a computable function
14:06:18 <Gracenotes> yeah. not quite sure what the definition entails
14:06:26 <Gracenotes> your definition, I mean
14:06:30 <Olathe> Gracenotes: You can convert any computer program into an integer fairly easily.
14:06:34 <Gracenotes> and yes, I do mean that f is computable
14:06:52 <Gracenotes> Olathe: yes, I'm aware, with cardinality... oh
14:06:53 <Cale> Gracenotes: A real number x is computable if and only if there exists a program which given a natural number n, computes the first n digits of x.
14:06:54 <cknapp> Computable = "can write a program in some (recursively enumerable?) language which prints as output that number"
14:07:04 <AirCastle> if x is not computable then there cannot be a function f(y) from which you get x where y is computable. i thin kthat's what Gracenotes is saying..
14:07:12 <cknapp> Cale and your beating me to the punch...
14:07:13 <Peaker> hmm.. what's the difference between an indexed type/data, and a type/data family?
14:07:29 <Cale> Gracenotes: There are only countably many programs with which you could attempt to compute real numbers.
14:07:51 <Cale> Gracenotes: Hence, most real numbers (R being uncountable) are not computable.
14:07:53 <Peaker> hmm.. I found the HaskellWiki, so nm
14:08:21 <cknapp> Peaker: it's good you found it yourself, because we're engaged in a consuming discussion. :D
14:08:22 <Gracenotes> AirCastle: that's it, I think.
14:08:29 <Cale> There can be functions f such that f(x) is computable when x is uncomputable.
14:08:47 <Cale> Consider the function for which f(x) = 0 for all x.
14:08:52 <AirCastle> Gracenotes: i guess it stands to reason, because then the function f and the variable y could both be put into one computable number
14:08:55 <Peaker> Was about to say: const/id?
14:08:57 <Gracenotes> const 0 :)
14:09:16 <Cale> Or, pick your favourite uncomputable number, and consider the function f which swaps that number and 0, leaving all other numbers alone.
14:09:16 <cknapp> Peaker: id won't work
14:09:23 <Peaker> cknapp: why not?
14:09:34 <cknapp> What's id (chaitan's constant)?
14:09:43 <Gracenotes> this is quite interesting, because I'll be taking a class on Theory of Computation next semester
14:09:50 <Peaker> cknapp: chaitan's constant
14:10:01 <cknapp> How do you compute chaitan's constant?
14:10:08 <cknapp> Answer: you don't
14:10:10 <Peaker> cknapp: I don't need it, it was given to me as an argument :-)
14:10:11 <Cale> Or, say, given an uncomputable real number x, let f(x) = 0, and for all other real numbers t, f(t) = t
14:10:22 <Peaker> cknapp: I don't need to, that was
14:10:23 <cknapp> But you need to return it.
14:10:31 <Peaker> cknapp: yeah, so I just return my argument?
14:10:33 <Gracenotes> hm. It seems that the focus of the Theory of Computation course is more about compsci than it is about math
14:10:36 <AirCastle> the thing i don't understand is there is supposed to be the 'Omega number', which is the ratio of halting programs to not halting programs (or vice versa), but i don't see how that ratio does not depend on what the computing language is and how numbers are converted into it
14:10:38 <JoshTriplett> Does a "bracket" or "bracket_" exist for non-IO monads?
14:10:52 <Cale> AirCastle: It does depend on that.
14:11:07 <Cale> AirCastle: "Chaitin's constant" is not just one constant.
14:11:21 <Cale> It depends on your enumeration of programs.
14:11:33 <asgaroth> JoshTriplett: there's bracket in Control.Exception
14:11:38 <Gracenotes> is Chaitin's constant probably really high or really low?
14:11:41 <AirCastle> ok.  so, given one particular chaitin's constant, you can come to an approximation of it by coming up with random programs and running them for a fairly long time right?
14:11:43 <asgaroth> ah, ignore that
14:11:57 <Gracenotes> actually, that probably depends on the language
14:12:02 <Cale> AirCastle: in a weak sense
14:12:15 <Gracenotes> there must be programs more prone to halting than others
14:12:18 <JoshTriplett> asgaroth: OK, I will. :)
14:12:18 <Gracenotes> er, languages
14:12:27 <Cale> AirCastle: You will have no real guarantees about the error.
14:12:47 <cknapp> Peaker: but actually giving f(x) requires computing x. Think about when haskell returns "id [1..]". id does nothing bout that program (f(x)) takes forever.
14:13:10 <Cale> Typically, it might be possible to determine the first few binary digits of Chaitin's constant, but then after that, it becomes intractable.
14:13:33 <Gracenotes> really *raises eyebrows*
14:13:43 <cknapp> Cale: don't we have 5-10 or so for Turing machines?
14:14:24 <tromp__> chaitin computed the first 7 bits of his number
14:14:34 <Gracenotes> for which language?
14:14:41 <cknapp> tromp__: thanks.
14:14:42 <tromp__> a lisp like language
14:15:06 <tromp__> those bits were all 1
14:15:21 <tromp__> since it takes some effort to write a non-halting lisp program:)
14:15:41 <cknapp> :)
14:15:49 <AirCastle> it's not hard to write a non halting program in any functional language..?
14:16:03 <tromp__> yes, but it takes more than 7 bits:)
14:16:12 <Cale> AirCastle: It's hard in Charity.
14:16:24 <Gracenotes> does Charity not like recursion?
14:16:28 <Cale> Er, well, I suppose Charity includes codata, so it's not so hard ;)
14:16:30 <ski_> Cale : is it even possible ?
14:16:41 <tromp__> my binary lambda calculus has a stricter definition of halting
14:16:47 <Cale> Gracenotes: Charity has restricted forms of recursion.
14:16:51 <ski_> Cale : i don't think you can just run don't a `codata' indefinitely, though
14:16:55 <tromp__> so its ghalting probability wld be much smaller
14:16:56 <jonaskoelker> I think it's hard writing a non-halting arb fragment shader :P
14:17:06 <ski_> Cale : you need to index it with a `data'
14:17:16 <Gracenotes> hey, great psuedorandom-bit generator: make a psuedo-random grammar, find the first few bits of Chaitin's number in it, repeat until you have all the bits you need
14:17:17 <ski_> s/don't/down/
14:17:21 <Cale> ski_: hmm, it would make sense in some cases to do so though -- stream processing I/O for example.
14:17:26 <Gracenotes> not guaranteed to be distributed well
14:17:38 <Peaker> There can be a top-level type family declaration -- but how do you define the actual types in the family?
14:18:03 <Peaker> oh, type instance, weird
14:18:04 <cknapp> Grcenote: sound's brilliant!
14:18:09 <ski_> Cale : that only runs down the input stream some finite number of elements bounded by how many elements of the output stream are demanded
14:18:10 <cknapp> sounds*
14:18:26 <jonaskoelker> Gracenotes: alternatively, generate a lot of random turing machines and measure their kolmogorov complexity ;)
14:18:41 <AirCastle> or turn your microphone on and sample from it :p
14:18:56 <jonaskoelker> AirCastle: nonono!  That's possible!
14:19:02 <Gracenotes> jonaskoelker: is that guaranteed to be a bit... faster?
14:19:02 <AirCastle> hahah
14:19:11 <cknapp> Hurray! Haskell has a new intractible algorithm!
14:19:50 <cknapp> What is it "Haskell: where easy things are easy and the impossible happens"?
14:19:50 <Cale> ski_: I was thinking of a program which was intended to run forever, processing data.
14:20:35 <Gracenotes> encryption via various properties of Turing machines. Not a bad idea, eh? ;)
14:20:48 <Cale> ski_: Perhaps something like a web server, or an operating system.
14:20:53 <ski_> Cale : apart from stream transformers, i'm not sure that is possible in Charity (bicbw)
14:20:58 <dons> thanks slava! http://www.reddit.com/r/programming/comments/7pohw/why_haskell_is_beyond_ready_for_prime_time/c071i7o
14:21:23 <Cale> ski_: It seems like it ought to be possible to use codata for that.
14:21:24 <Peaker> anyone has any idea when the ghc/rts bug that's blocking unamb, and therefore Reactive is going to be fixed?
14:21:45 <Cale> ski_: Perhaps Charity's I/O system is too restricted to do it though.
14:22:32 <dancor> gwern: it turns out that hlint doesn't preserve whitespace
14:22:39 <bombshelter13> Do PortAudio bindings exist for Haskell? Or, failing that, ALSA/OSS/Jack/CoreAudio bindings?
14:22:58 <Cale> Check Hackage...
14:22:58 <ski_> Cale : if it's not possibly, then i think it's so by design (though possibly one could relax things without enabling nontermination ..)
14:23:19 <acidjnk> hello
14:23:22 <AirCastle> if you took audio data it would have genuine randomness but it wouldnt be uniformly distributed. i was wondering.. with some simple transformation maybe you could make it uniformly distributed?  like, you could use a regular old pseudo random generator and use each sample as a seed?
14:23:24 <dancor> what is a good haskell parser that preserves whitespace
14:23:27 <Cale> ski_: Like providing a choice between main and comain or something :)
14:23:29 <acidjnk> Is this equivalent to the map function? let map2 f xs = foldr (\x y->[f x]++ y) [] xs
14:23:39 <AirCastle> well it would have patterns other than non uniformity
14:23:40 <AirCastle> too
14:23:49 <Cale> bombshelter13: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/portaudio
14:23:49 <ski_> (Cale : `comain' ?)
14:24:08 <gwern> dancor: oops
14:24:09 <bombshelter13> Cale: Ooh, promising.
14:24:09 <ski_> acidjnk : yes
14:24:15 <acidjnk> Ok, thanks.
14:24:21 <mauke> @src map
14:24:21 <acidjnk> Phew, that took me over an hour.
14:24:22 <lambdabot> map _ []     = []
14:24:22 <lambdabot> map f (x:xs) = f x : map f xs
14:24:35 <mauke> acidjnk: [x] ++ y better written as x : y
14:24:38 <acidjnk> I was there very quickly but with two small syntax errors.
14:24:46 <acidjnk> thanks
14:25:06 <Gracenotes> hm... it would probably help people to have a 'monad cookbook' of sorts, no? Just example after example of using monads. Not deriving them, just using them.
14:25:18 <Gracenotes> Sort of like the examples in All About Monads, but more of them
14:25:27 <ski_> map f = foldr ((:) . f) []
14:26:04 <sjanssen> Gracenotes: that's a nice idea
14:26:06 <jeffwheeler> @src map
14:26:06 <lambdabot> map _ []     = []
14:26:07 <lambdabot> map f (x:xs) = f x : map f xs
14:26:37 <wchogg> @seen chessguy
14:26:38 <lambdabot> I saw chessguy leaving #haskell-overflow, ##logic, #novalang, #haskell and #haskell-blah 17h 59m 41s ago, and .
14:31:33 * dancor cannot find a whitespace-preserving haskell parser and is considering reinventing this wheel in parsec
14:32:04 <dcoutts> dancor: were you having cabal problems?
14:32:19 <skorpan> :t or
14:32:21 <lambdabot> [Bool] -> Bool
14:34:22 <dancor> dcoutts: ya same as http://hpaste.org/12293 looks like
14:35:24 <dancor> i guess it's using base-3 for containers when it should use base-4
14:36:51 <dcoutts> dancor: it's a bug in containers that it does not specify base >= 4 if it needs Data.Data
14:37:10 <dcoutts> dancor: though it's usually not a problem since you've got containers installed already
14:37:57 <dancor> yeah and i do have containers installed, but when i try to cabal-install about half the time (most recently hlint) this happens
14:38:13 <dancor> not sure how cabal-install decides it needs to reinstall
14:38:18 <sw17ch> perhaps the popularity of Haskell is permanantely limited because it requires the user to put a lot of thought into what they are writing. i wonder if the "warning: requires brain" stickers keep more people from using Haskell.
14:38:28 <dancor> anyway, is there a reason the containers bug hasn't been fixed
14:39:04 <dancor> sw17ch: i know that more often in haskell i look at other ppl's code and simply cannot figure it out
14:39:16 <dcoutts> dancor: the usual problem is having the exact same package version installed in the global and user package db, check ghc-pkg list
14:39:45 <dcoutts> dancor: and for some reason I've not properly investigated that confuses cabal-install's dep resolver
14:39:55 <dcoutts> it'll also generally cause problems, so best avoided
14:39:57 <hydo> Speaking of user packages, am I 'headin' fer a heartbreak' by installing everything globally?  I seem to have less weirdness when I do...
14:40:20 <dancor> ~ ghc-pkg list|grep containers cgi-3001.1.7.0, containers-0.2.0.0, cpphs-1.6, dancomp-0.1,
14:40:25 <dcoutts> hydo: I do the opposite, I install everything per-user
14:40:27 <dancor> it's listed once
14:40:38 <sw17ch> dancor: well, it's not even that. you get that with any language.
14:40:40 <jonaskoelker> Has anyone toyed with the idea of making a CAS embedded in haskell (possibly with TH)?  I think there's some typeclassing fun to be had (classes Group, Ring, Field, etc.), but it probably requires raping some of the standard classes (Enum, Num)...  what do you all think?  Doable?  Good/bad idea?
14:40:45 <dcoutts> dancor: I mean generally
14:41:05 <dcoutts> dancor: any package where the same version is installed globally and per-user, eg Cabal lib itself perhaps?
14:41:32 <dancor> sw17ch: i think i get that a lot more with haskell.  my code is beautiful to me, but more often there are substantial interperson differences seems like
14:42:28 <dancor> i also install everything globally
14:42:32 <dancor> only
14:43:52 <dcoutts> dancor: so you're saying there's no overlap and you still get this problem?
14:44:07 <dcoutts> dancor: could you @hpaste the output of ghc-pkg list and the failing run
14:44:31 <dcoutts> dancor: or rather the cabal install whatever --dry-run -v  that wants to re-install containers
14:48:30 <dax_> gn8
14:49:32 <dons> nice, hope it isn't just good wishes, http://www.reddit.com/r/programming/comments/7pohw/why_haskell_is_beyond_ready_for_prime_time/c071jgc
14:49:33 <dublpaws> is there a convenience function for reverse . tail . reverse $ somelist
14:49:43 <Cale> init
14:49:58 <dublpaws> thanks Cale
14:50:03 <Cale> No problem.
14:50:14 <Cale> It's also more efficient than reversing twice.
14:50:25 <Cale> (but still pretty inefficient if you have to do it a lot)
14:51:06 <Cale> Lists are just not the right data structure if you have to do a lot of modifications to the end.
14:51:19 <Gracenotes> (init . init . init . init . init . init . init . init) should still only go through the list once, right? (providing the list is long enough)
14:51:34 <Gracenotes> the only problem is that you have to do several calls just to access the next element
14:52:56 <Cale> Gracenotes: right, and it'll do a lot of allocation (though short-lived garbage is treated rather well by GHC, it still eats up lots of time)
14:53:51 * sw17ch goes home
14:54:47 <ddarius> Cale: Why would it only go through the list once?
14:57:01 <Cale> ddarius: Well, in the sense that in order to produce each element, it doesn't have to get to the end of the list.
14:57:10 <Cale> > (init . init . init . init . init . init . init . init) [1..]
14:57:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:58:06 <Cale> So you might choose to think of it as a bunch of interleaved passes, I suppose.
14:58:51 <tromp__> in that case, reverse . drop 8 . reverse might be more efficient
14:58:53 * cknapp is going to kill someone if he "learns" floating point arithmetic in the Systems class he's about to take...
14:59:05 <Cale> tromp__: yeah.
14:59:15 <Cale> tromp__: except not in the infinite list case
14:59:24 <cknapp> :)
14:59:27 <Cale> > (reverse . drop 8 . reverse) [1..]
14:59:45 <lambdabot>   thread killed
14:59:51 <dublpaws> hehe
15:00:03 <tromp__> no, only if you're strict in list length:)
15:01:32 <Cale> cknapp: "learns"?
15:02:02 <cknapp> I've been "taught" FPA in... lemme count...
15:02:22 <cknapp> 5 classes in 2 and a half years
15:02:52 <cknapp> Meaning, I was taught once, and subjected to 4 more times
15:03:26 <cknapp> Seeing as this class is an extension of 2 of the classes I learned it in, I'm praying that it is glossed over...
15:03:48 <Gracenotes> cknapp: do you have to implement FP? Or just use it?
15:03:50 <cknapp> I have no problem with "This is how FPA works... blah blah blah mantissa... blah blah blah"
15:04:09 <cknapp> Just use it. In fact, if I had to implement it, I would be itnerested for the first time ever
15:04:21 <cknapp> /s/tn/nt
15:05:44 <cknapp> The painful thing is the last 3 classes that I saw it in, the professor was like "I think most of you have learned this before, but..." and then lectures for a week on it...
15:05:47 <cknapp> Anyway...
15:05:49 * cknapp stops ranting
15:07:03 <eu-prleu-peupeu> hello
15:07:08 <eu-prleu-peupeu> Haskl3z0rs
15:08:43 <cknapp> Hey, e-p-p
15:09:28 <eu-prleu-peupeu> :D
15:09:31 <dancor> why is Language.Haskell.Exts.lexer of type (Token -> P a) -> P a
15:09:56 <dancor> shouldn't it be  String -> [Token]  or something
15:11:20 <dancor> Language.Haskell.HsColour.Classify.tokenize  looks better
15:14:14 <ptolomy2> Hah. Quoth Sussman: "I don't much like macros."
15:14:38 <cknapp>  Sussman?
15:14:43 <cknapp> That's like a groundbreaking statement...
15:14:53 <cknapp> Where was this?
15:14:55 <mauke> dbThe Sussmanbd
15:15:07 <ptolomy2> A lecture I attended.
15:15:35 <ptolomy2> Out of context quotes are fun.
15:16:13 <cknapp> Hahaha
15:16:24 <__barg> what is the *easy* way to print a [Word16] as binary?
15:16:33 * cknapp accuses ptolomy2 of slander.
15:16:34 <cknapp> :)
15:16:43 <mauke> Data.Binary
15:17:28 <__barg> mauke: any way to avoid that? it might not be installed :(
15:17:44 <mauke> ghc might not be installed
15:17:50 <__barg> :-)
15:18:13 <dancor> you can copy the code
15:18:18 <dancor> (joke)
15:18:44 <cknapp> @pl (\f g x -> filter f (map g x))
15:18:45 <lambdabot> (. map) . (.) . filter
15:19:15 <cknapp> Hmm... time to study that...
15:19:28 <dancor> explode
15:19:42 <cknapp> dancor: eh?
15:19:56 <dancor> cknapp: studying that blows my mind
15:20:10 <cknapp> Well, yeah... that's why I need to study it
15:20:26 <cknapp> It's like LSD, without the headache afterwards. :)
15:20:44 <dancor> @unpl a . (.) . b
15:20:45 <lambdabot> (\ h -> a (\ d e -> b h (d e)))
15:21:07 <mauke> here, take some fmap fix return
15:21:19 <tromp__> is there a version of Binary working with bits instead of bytes?
15:21:55 <dancor> tromp__: it should be reasonable to convert the bytes that Binary gives you to bits right?
15:22:50 <cknapp> Hurray for beta reduction. I like Haskell. :D
15:23:04 <tromp__> i'd want decodeFile to give me 8 Bool's for each byte
15:23:31 <mathijs> can someone explain to me the result of '[0.1,0.3..1]' ? I do get that floats are a bit unreliable because representing a base10 floating number in binary isn't always straightforward 'mappable', but I don't get why it ends up > 1
15:23:48 <dancor> tromp__: there is also Data.Bits
15:23:54 <kpreid> > [0.1,0.3..1]
15:23:56 <erikc> parseBool w8 = map (flip testBit w8) [0..7]
15:23:58 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
15:23:59 <mauke> mathijs: bug in the spec
15:24:07 <rwbarton> mathijs: user error
15:24:08 <erikc> massage until it typechecks :P
15:24:13 <dancor> tromp__: maybe that is better for what you want than 8 Bool's
15:24:13 <kpreid> > [0,2..5]
15:24:14 <rwbarton> mathijs: don't enter [0.1,0.3..1], it's meaningless
15:24:15 <lambdabot>   [0,2,4]
15:24:16 <tromp__> it's broken indeed
15:24:20 <Gracenotes> 'iterate' is quite uncanny in its similarity to Church numerals
15:24:33 <cknapp> Gracenotes. :)
15:24:40 <AirCastle> i read something that says that when you use floats in a list like that it adds a little bit to the final number
15:24:48 <AirCastle> to get around some of the float weirdness i thnik
15:24:50 <tromp__> Data.Bits is for doing bitwise operators, not for serializatoin
15:25:03 <Gracenotes> need to stop with church numerals and explore the rest of the lambda calculus...
15:25:34 <mathijs> rwbarton: well, I know it's not terribly useful, but to me it means numbers between 0.1 and 1 with some (unreliable) steps that are aproximately 0.2
15:25:58 <cknapp> Gracenotes: YES!
15:26:05 <rwbarton> mathijs: which in turn means... nothing
15:26:18 <rwbarton> mathijs: the point is to make [0.1, 0.3 .. 0.9] do something reliable
15:26:31 <rwbarton> mathijs: rather than [0.1, 0.3, 0.5, 0.700000000001] or whatever
15:26:32 <AirCastle> re the [0.1,0.3..1] <-- i think this is where it explains it: http://book.realworldhaskell.org/read/getting-started.html in the 'beware enumerating floating point numbers' section
15:26:38 <AirCastle> it adds .5
15:26:50 <mathijs> rwbarton: ok, granted. but still, shouldn't there be some check to see if a number is > than the number behind the .. ?
15:26:53 <rwbarton> mathijs: no
15:27:05 <rwbarton> mathijs: because then you will get the kind of output I gave above
15:27:41 <rwbarton> mathijs: The real answer is "don't use enumFromThenTo with floating point types"
15:28:05 <tromp__> [a,b..c] should mean takeWhile(<=c) $ a : iterate (+(b-a)) b
15:28:18 <tromp__> for b>=a
15:28:26 <cknapp> How do I check the associativity of (.)?
15:28:55 <cknapp> Wait...
15:28:59 <cknapp> Nevermind.
15:29:04 <dancor> tromp__: i think you just want to go like ByteString -> [Word8], which unpack does, and then to bits from there
15:29:08 <rwbarton> tromp__: see, then people will have *actual* problems with [0.1, 0.3 .. 0.9]
15:29:14 <cknapp> Actually, the question still stands (for future reference)
15:29:26 <mathijs> rwbarton: ok... I got that :)  but still I think it's strange that [0,10..205] doesn't end up above 205. if list comprehension doesn't work on floats, wouldn't it be better just to disable them?
15:29:29 <Cale> cknapp: ((f . g) . h) x = (f . g) (h x) = f (g (h x)) f ((g . h) x) = (f . (g . h)) x
15:29:35 <rwbarton> tromp__: whereas the way it is now, there are only *theoretical* problems with ridiculous things like [0.1, 0.3 .. 1.0]
15:29:47 <tromp__> rwbarton those ppl deserve trouble,
15:29:49 <Cale> whoops, missed an = sign
15:29:57 <Cale> ((f . g) . h) x = (f . g) (h x) = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x
15:30:13 <tromp__> they shld realize floats are inaccurate and write map (/10) [1,3..9] instead
15:31:07 <cknapp> Cale: can you help me understand this pointless output from lambdabot:
15:31:27 <cknapp> @pl (\f g x -> filter f (map g x))
15:31:27 <lambdabot> (. map) . (.) . filter
15:31:36 <Cale> Sure.
15:32:07 <mathijs> tromp__: well that would be my solution too, but like I said, it would be a lot clearer just to disable list comprehension on floats altogether instead of returning numbers that are clearly out of range.
15:32:08 <tromp__> it's entirely reasonable to expect [a,b..c] to equal takeWhile (<=c) [a,b..]
15:32:19 <tromp__> just as for Ints
15:32:22 <rwbarton> tromp__: basically you are saying that enumFromThenTo should not exist for floating point types, which I agree would be nice.
15:32:46 <cknapp> Cale: I have no idea where to start.
15:32:52 <cknapp> I *do* know what the code does
15:32:54 <Cale> Start with ((. map) . (.) . filter) f g x
15:33:26 <dmwit> \f g x -> filter f (map g x)
15:33:31 <dmwit> \f g x -> filter f . map g $ x
15:33:36 <dmwit> \f g -> filter f . map g
15:33:40 <tromp__> no, i'm saying that it shld be obvious how enumFromTo is derived from enumFrom
15:33:51 <dmwit> \f g -> (.) (filter f) (map g)
15:33:57 <cknapp> Ah!
15:34:00 <dmwit> \f g -> (.) (filter f) . map $ g
15:34:03 <cknapp> That was the step I was missing.
15:34:12 <rwbarton> tromp__: but the meaning you want to give it is useless.  It would exist only to trip people up and give them wrong answers.
15:34:13 <SamB_irssi> tromp__: how could it be ?
15:34:20 <dmwit> Okay, I'll stop. =)
15:34:25 <cknapp> Thanks a ton.
15:34:43 <rwbarton> tromp__: far better for it to be a compile-time error somehow.
15:34:44 <SamB_irssi> tromp__: I'm fairly certain that Enum doesn't imply Ord ...
15:35:36 <tromp__> i wonder just how enumFromTo is defined on Float
15:35:52 <mauke> Terrible!
15:36:18 <loadquo> How would I go about defining an array of Integrals?
15:36:38 <mathijs> dmwit: is there some way to get lambdabot produce steps like that? I mean I can follow it, and in most not-too-hard situations I can do them on my own, but it would be nice to have some way of checking.
15:36:53 <SamB_irssi> tromp__: with mush weeping and gnashing of teeth, I think
15:36:57 <tromp__> well, i guess  Float/Double not having Enum instance is a good solution too
15:37:06 <SamB_irssi> s/mush/much/
15:37:25 <rwbarton> @src Enum
15:37:26 <lambdabot> class  Enum a   where
15:37:26 <lambdabot>     succ                     :: a -> a
15:37:26 <lambdabot>     pred                     :: a -> a
15:37:26 <lambdabot>     toEnum                   :: Int -> a
15:37:26 <lambdabot>     fromEnum                 :: a -> Int
15:37:28 <lambdabot> [3 @more lines]
15:38:02 <rwbarton> Yeah, I think the entire instance could be disposed with
15:38:45 <dmwit> mathijs: Not that I know of.
15:38:58 <dmwit> mathijs: Perhaps you'd like to hack the ?pl module in \bot's source... ;-)
15:39:30 <mathijs> dmwit: maybe in a few months, when my haskell feels more natural :)
15:39:43 <SamB_irssi> mathijs: it is unlikely that you would enjoy the process, but who knows, you might actually get some results
15:39:44 <cads_> does anyone here have a love of CG?
15:40:11 <mathijs> dmwit: but I guess that's the place to start... I mean it probably does something like that internally anyway.
15:40:50 <cknapp> dmwit: So then we have (\f -> (. map) . (.) (filter f)), right? From there I can finish it, but I don't understand that step.
15:40:58 <byorgey> cads_: yeah, computerized gerbils are the best!
15:41:33 <dmwit> cknapp: Here's where I left off.
15:41:38 <dmwit> \f g -> (.) (filter f) . map $ g
15:41:44 <dmwit> \f -> (.) (filter f) . map
15:42:08 <dmwit> \f -> (.) ((.) (filter f)) map
15:42:12 <cads_> byorgey, I refer to computer graphics, the study of the methods by which computers synthesize images
15:42:18 <dmwit> \f -> (. map) ((.) (filter f))
15:42:24 <cknapp> Ok.
15:42:30 <cknapp> That... makes sense.
15:42:42 <byorgey> cads_: that's what I figured, I was just being silly =)
15:42:54 <cknapp> I get it now. Thank you.
15:43:08 <byorgey> cads_: I do, in fact, like CG.  It depends what you mean by 'love' though.
15:43:35 <cads_> byorgey, well, love is a relative term for sure
15:43:50 <cads_> i'd say I love haskell enough to join a chat channel and talk about it
15:44:08 <cads_> but I've been reading CG literature since I was 13
15:44:26 <cads_> so graphics was a love before even programming
15:44:39 <byorgey> ah.  well, for me, those are basically switched =)
15:44:52 <mathijs> cads_: you didn't program at 13 yet? :P
15:45:40 <loadquo> Is there any way to see if a function is the same function as another one?
15:45:47 <oklopol> loadquo: not in general
15:46:01 <lament> "I love my wife enough to join a chat channel and talk about it"
15:46:06 <cads_> mathijs, just a few prime number sieves and the like
15:46:22 <byorgey> loadquo: if their domains are finite, you can compare them at every possible input and see if all the outputs agree.
15:46:29 <byorgey> loadquo: other than that, no.
15:46:45 <oklopol> byorgey: if they always halt
15:46:56 <byorgey> er, right. =)
15:47:11 <oklopol> you have both the problem of usually infinite domains, and semidecidability.
15:47:59 <cknapp> loadquo: look up "udnecidability of equivalence"
15:48:07 <cknapp> /s/dn/nd
15:48:11 <rwbarton> Having an infinite domain is not necessarily a problem
15:48:12 <SamB_irssi> yeah, total functions of finite domain have decidable equivalence
15:48:13 <mathijs> cads_: I started at 6 or something.. MSX basic. I still feel the pain when I created some visual clock at 9 or 10 and my dad didn't believe I made it :) Thinking back I still think sine and cosine must have been a guess / trial&error thingy :)
15:48:25 <oklopol> rwbarton: neither is semidecidability
15:48:37 <oklopol> they just are in general
15:48:53 <loadquo> cknapp, I wasn't looking for anything fancy. I just wanted to figure out whether (+) == (+)
15:49:11 <oklopol> or what was your point, maybe it was something deeper than i was assuming
15:49:19 <rwbarton> oklopol: I mean, you can determine equality for total functions of type (Int -> Bool) -> Bool
15:49:32 <byorgey> loadquo: well, the point is, that IS fancy =)
15:49:38 <oklopol> rwbarton: elaborate
15:49:38 <cads_> mathijs, wow, the idea of playing with sine and cosine and writing programs with them before knowing what they did, learning them in a intuitive way.. sound like a real charachter forming experience
15:49:45 <SamB_irssi> rwbarton: technically the domain is finite there ;-P
15:49:48 <oklopol> loadquo: that's possible in say c++ with functors
15:49:55 <oklopol> or well, with functions in general
15:50:03 <rwbarton> oklopol: See http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
15:50:38 <byorgey> SamB_irssi: I think rwbarton means  (Nat -> Bool) -> Bool
15:50:39 <roconnor> that links shows how to define equality on any compact type, rather than on just finite types
15:50:39 <SamB_irssi> I learned sin and cos from a POV-Ray scene (MegaPOV, specifically)
15:50:41 <cads_> anyways, I am trying to create a channel for open source graphics discussion, so anyone that is interested private message me
15:51:06 <roconnor> byorgey: or (Integer -> Bool) -> Bool
15:51:18 <rwbarton> Yeah, I was slightly sloppy
15:51:21 <oklopol> rwbarton: i'll leave that open, hopefully i'll read it tomorrow
15:51:22 <Gracenotes> in lambda calculus with number and boolean extensions, are operations like + and * supposed to be black boxes?
15:51:27 <Gracenotes> i.e. already implemented
15:51:29 <cknapp> @pl (\f l -> l ++ (map f l))
15:51:29 <lambdabot> ap (++) . map
15:51:40 <cknapp> @src ap
15:51:41 <lambdabot> ap = liftM2 id
15:51:54 <cads_> do you guys know people in this channel with knowledge of haskell where graphics are concerned?
15:51:55 <loadquo> I suppose I'm not interested in whether the functions were the same but whether the labels for the functions were the same.
15:51:56 <byorgey> roconnor: ah, is that compact too?
15:51:58 <Gracenotes> + could possibly be implemented via the Y combinator, but it seems much easier just to define them for the person
15:52:00 <Gracenotes> using it
15:52:05 * byorgey doesn't pretend to know what 'compact' means in this context
15:52:19 <roconnor> byorgey: compact are the types you can search :P
15:52:20 <sjanssen> Gracenotes: they could be, or they could just be sugar for the usual Church encoding
15:52:39 <byorgey> roconnor: hehe, ok =)
15:52:43 <roconnor> byorgey: er, I suppose that is not quite right.
15:52:45 <roconnor> but close
15:52:58 <SamB_irssi> cads_: what, you mean the channel logs would be have a simple permissive license ?
15:52:58 <mathijs> cads_: well I started by just typing-over listings in computer-magazines and changing stuff (values, statements). My native language is Dutch, so most manuals/documentation for basic wasn't readable for me. I really learned by trial&error, bit like evolution :)  but still... I wonder what would have happened if haskell were around those days.
15:53:03 <cknapp> @src ap
15:53:03 <lambdabot> ap = liftM2 id
15:53:22 <byorgey> Gracenotes: often if the lambda calculus is extended with numbers and booleans, a small number of primitive functions is provided too, from which things like + and * can be implemented.
15:53:33 <Gracenotes> ah, good :)
15:53:34 <byorgey> Gracenotes: such as succ, pred, and an 'if' construct
15:53:48 <tromp__> you started on 8-bit home computers, mathijs?
15:53:54 <Gracenotes> I have succ and 'if'
15:54:02 <Gracenotes> not pred though
15:54:22 <cknapp> pred is surprisingly tricky...
15:54:31 <dmwit> succ and ifzero (and Y) should be enough to do (+).
15:54:34 <dmwit> (*), too, probably.
15:54:59 <cknapp> (*) is pretty easy, overall
15:55:04 <Gracenotes> oh, I forgot about ifzero
15:55:19 <mathijs> tromp__: yep, MSX2. But the funny part was that it had quite good graphics (back then), like 256 colors and 'sprites'. That made learning and playing around a lot more fun as a kid.
15:55:29 <sjanssen> why bother with Y rather than just use Church encoding?
15:55:30 <dancor> should i expect like   let pair' = if f $ fst pair then pair else (fst pair, False)   to not bother computing f if snd pair is already False
15:55:35 <dancor> or should i add a check
15:55:46 <SamB_irssi> apparantly pred Z = Z isn't too bad ...
15:55:54 <dancor> let pair' = if snd f && f (fst pair) then pair else (fst pair, False)
15:55:56 <Gracenotes> better than blowing up
15:55:59 <tromp__> i had plenty fun with crappy graphics on a zx spectrum:)(
15:56:14 <dons> hmm. do we really not have off_t bound?
15:56:18 <mathijs> tromp__: wasn't that 4-bit?
15:56:27 <Gracenotes> I believe I've implemented Y: ">f >x >x >y @ @ #y @ #x >f >x >x >y @ @ #y @ #x @ #f"
15:56:47 <tromp__> 8bit with some 16 bit registers (Z80)
15:57:13 <rwbarton> dancor: It will compute f even if snd pair is already False, I'm pretty sure
15:57:29 <dancor> rwbarton: tx
15:57:32 <rwbarton> dancor: since if f (fst pair) is _|_, then snd pair' should be too, according to the definition you wrote
15:57:54 <mathijs> tromp__: cool. I did learn assembly code for Z80 in CS classes. just the basics though.
15:58:22 <dons> ah, FileOffset
15:59:00 <dancor> rwbarton: that's true.  _|_ thwarts my simple but optimized code again
16:00:13 <cknapp> Gracenotes: I can't read your notation,t here...
16:00:51 <mathijs> tromp__: the nicest part I still remember (I was about 5 or 6) were the weekly radio-transmissions of sourcecode. some techy radio show that broadcasted a game each week. I had to record it on tape so I could play it on my msx :)
16:01:35 <Gracenotes> cknapp: it's RPN. >x #x is identity; >x #x 2 @ applies id to 2
16:01:51 <Gracenotes> making an esoteric language :) right now I'm adding little features
16:02:10 <cknapp> Ah....
16:02:12 <tromp__> i once bought a magazine with a plastic LP on it that you could play and feed into your zx spectrum
16:02:21 <Gracenotes> >x +1 #x 2 @ is 3
16:02:30 <tromp__> never got them off radio
16:02:37 <cknapp> Alright... give me a moment to decipher.
16:02:38 <mathijs> tromp__: wow :)  didn't know they used LPs for that too
16:03:17 <tromp__> i really hated typing in long lists of hexcodes:(
16:03:27 <mathijs> tromp__: maybe there was an even better program hidden on it... if you would play it backwards!
16:03:51 <tromp__> my lp player only went forward:(
16:04:09 <tromp__> so i missed the satanic programs:)
16:04:19 <Botje> http://photoshopdisasters.blogspot.com/2009/01/ion-turntable-minus-thirty-three-and.html
16:04:22 <Botje> just get one of these
16:04:23 <Pseudonym> tromp: So you didn't get the memo that Paul is dead?
16:04:50 <tromp__> must've gone in my spam folder
16:05:04 <cknapp> Gracenotes: so what exactly is '#x'?
16:05:27 <mathijs> cknapp: some new language from microsoft?
16:05:31 <cknapp> hahaha
16:05:35 <Gracenotes> hehe
16:05:35 <cknapp> that would be x#
16:06:07 <Gracenotes> it's a lambda expression using the variable "x"
16:06:12 <cknapp> Ok.
16:06:17 <Gracenotes> its body is the top item on the stack
16:06:23 <cknapp> Right... I figured that out from the #f...
16:06:28 * cknapp is an idiot sometimes.
16:06:50 <Gracenotes> it's grouped with parentheses here: (>f ((>x >x >y @) @ #y) @ #x) (>f ((>x >x >y @) @ #y) @ #x) @ #f
16:06:57 <cknapp> Ah, that might help...
16:07:32 <Gracenotes> er, actually, a better grouping would be (>f ((>x >x >y @ @) #y) @ #x) (>f ((>x >x >y @ @) #y) @ #x) @ #f
16:07:58 <dmwit> Botje: I don't get it... =/
16:08:16 <Botje> dmwit: i didn't either, at first. look at the miniature image
16:08:26 <Gracenotes> wow, this language could go somewhere :) In terms of esoteric languages, that is
16:08:30 <Botje> and think about which way LPs are supposed to spin (clockwise)
16:08:50 <Gracenotes> it's nothing really original -- lambda calculus in postfix -- but still
16:09:00 <mathijs> anyways... speeking of microsoft... I read that f# is somewhat based on haskell. Do any of you have some experience with it?
16:09:37 <dmwit> Botje: So it's just flipped horizontally?
16:09:43 <Botje> yeah
16:09:47 <cknapp> Gracenotes: don't have an extra variable floating around in there?
16:10:07 <dmwit> Botje: That's pretty lame; what's to stop the head from rotating a full 90 degrees (and therefore still not digging into the LP as it plays)?
16:10:13 * dmwit hates PSD even more now
16:10:34 <peachi> can anyone like me to a relatively simple implementation of depth-first searching in haskell?
16:10:36 <Botje> i don't think the head doesn't rotate that way
16:11:09 <Botje> uh
16:11:10 <Gracenotes> cknapp: I don't think so. It parses to (Lam "f" sub sub), where sub is (App (Lam "x" (App (Var "f") (Lam "y" (App (Var "x") (App (Var "x") (Var "y"))))))
16:11:13 <Botje> nuke one of the negations :)
16:11:34 <dmwit> peachi: Certainly!
16:11:45 <cknapp> Is the y necessary?
16:12:06 <cknapp> Y = \f.(\x.f(xx))(\x.f(xx))
16:12:23 <dmwit> peachi: I recommend learning about the list monad; after that, depth-first search is pretty easy.
16:12:26 <Gracenotes> ah. good point
16:12:46 <Gracenotes> the extra Y yields information about how the redex is ultimately evaluated
16:12:53 <Gracenotes> but it's not necessarily
16:12:57 <sw17ch> @seen dons
16:12:57 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 14m 35s ago.
16:13:05 <Gracenotes> s/Y/y/
16:13:06 <cknapp> Ok... I figured that might be the case.
16:13:08 <augustss_> Yay!
16:13:16 <peachi> dmwit, hmm, I haven't learnt about monads at all (I've heard of them, though), but I more wanted to get my head around depth-first searching in some simplish haskell!
16:13:28 <peachi> dmwit, thanks anyway though :)
16:13:29 <dpratt71> mathijs: Haskell is pure functional; F# is hybrid imperative/functional; I'd be surprised if they took nothing from Haskell, but I can't see F# being "based" on Haskell
16:13:34 <cknapp> peachi: The paper with the fgl library has one...
16:13:36 <cknapp> @where fgl
16:13:37 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
16:13:39 <cknapp> :)
16:13:43 <peachi> thanks :)
16:13:46 <cknapp> It isn't too hard to understand
16:13:48 <pumpkin> Data.graph in containers also does it
16:13:57 <dmwit> peachi: Well, it's certainly not that hard, even without using the list monad.
16:13:58 <dpratt71> F# is OCaml for .NET, as I understand
16:14:10 <dmwit> dpratt71: Sounds about right.
16:14:40 <cknapp> pumpkin: the one you mentioned should be the same implementation, no?
16:14:40 <erikc> f# is great if you are stuck on .net
16:14:54 <Pseudonym> Dunno about "great".
16:15:00 <Pseudonym> But point taken.
16:15:01 <dpratt71> I'm new to both F# and Haskell...
16:15:02 <Holle_> what is wron wit my format? http://hpaste.org/13930 ghc says: parse error on input =
16:15:04 <mathijs> dpratt71: well not exactly based, I just saw some language list (1930-now) which stated haskell as heavy influence on f#. But is f# lazy for example?
16:15:07 <erikc> pseudonym: well, compared to the alternatives :)
16:15:27 <dpratt71> ...I love that there is now a .NET functional language, but...
16:15:30 <Pseudonym> Holle: Link doesn't work
16:15:35 <Gracenotes> > fix (\f a b -> if a==0 then b else f (a-1) (b+1)) 7 5
16:15:37 <lambdabot>   12
16:15:38 <dpratt71> ...I really regret all the compromises
16:15:39 <Gracenotes> :D
16:15:47 <augustss_> F# is better than the alternatives on .net
16:15:58 <Holle_> http://hpaste.org/13930
16:16:16 <loadquo> Holle_ 'as' is a keyword?
16:16:18 <Pseudonym> > fix (\f x -> if x == 0 then 1 else x * f (x-1)) 5
16:16:20 <lambdabot>   120
16:16:21 <rwbarton> Holle_: Stop putting expressions in let blocks :P
16:16:28 <defun> can't types and type classes be used to the same effect as lisp macros? Isn't the whole point of macros to create a higher level of abstraction? Isn't that what we do with types, type classes, and obviously functions? I just want to make sure this assumption is correct, since I am not a lisp programmer, but want to convert my friend to haskell =)
16:16:30 <Holle_> as is a variable
16:16:31 <rwbarton> Holle_: or, whatever you are doing
16:16:35 <rwbarton> Holle_: as = if ...
16:16:36 <Pseudonym> Ah, link works.
16:16:39 <Pseudonym> Weird.
16:16:46 <dmwit> You can't do assignment in an if.
16:16:49 <dpratt71> augustss_: I agree and I don't agree; I'm concerned that many people's first exposure to functional programming will be "tainted"
16:16:53 <rwbarton> Holle_: Not if ... then as = ... else as = ... which makes no sense
16:16:56 <dmwit> Try this instead:
16:17:02 <dmwit> as = if foo then bar else quux
16:17:46 <augustss_> Oh I think f# taints, but it's there for .net users
16:18:01 <rwbarton> Holle_: By the way, you could define  data State = Normal | 1 Nachbar | 2 Markiert | 3 Nachbar Markiert
16:18:07 <rwbarton> oops, I thought I was going to get to edit that
16:18:08 <dmwit> loadquo: "as" is actually a valid variable name, believe it or not, because it is only a valid keyword in import statements.
16:18:10 <dpratt71> we need Haskell with a .NET Monad ;)
16:18:18 <rwbarton> Delete all the numbers and extra spaces
16:18:25 <Holle_> incorrect indention
16:18:28 <Saizan_> defun: there's always TemplateHaskell for what you can't do with typeclasses and laziness :)
16:18:32 <Holle_> at the else case
16:18:40 <loadquo> dmwit, yeah found that out a little later.
16:19:04 <Holle_> rwbarton: could i sort this data type by number?
16:19:13 <mathijs> wasn't there some work underway for ghc to generate java bytecode or .net CLI ?
16:19:17 <rwbarton> Holle_: Sure, if you add  deriving (Eq, Ord)
16:19:29 <Holle_> that's nice
16:19:36 <rwbarton> data State = Normal | Nachbar | Markiert | NachbarMarkiert deriving (Eq, Ord)
16:19:51 <Debugger> mathijs: For java, you could try clojure
16:20:01 <Holle_> Normal < Nachbar = True?
16:20:12 <augustss_> Yes
16:20:39 <dpratt71> As a compromise, I would like F# to have a "pure" keyword that would enforce functional purity
16:21:05 <int80_h> hey someone mentioned earlier that haskell lacks macros. Does that matter? IS there something that can be done with macros that haskell can't do? Or is it a matter that haskell can't do it easily?
16:21:28 <lament> int80_h: how often do you find yourself needing macros?
16:21:42 <augustss_> Macros can define variable binding constructs
16:21:56 <int80_h> lament: well, in Lisp, for example, I can use macros to generate little domain specific languages.
16:22:07 <dmwit> Here, we use monads for DSLs.
16:22:21 <rwbarton> One could argue that user-defined binding constructs are not so great for readability
16:22:26 <bombshelter13> dmwit: Do you have an example link? I'd enjoy seeing that!
16:22:27 <mathijs> Debugger: that's not really what I meant. clojure is at most a language that is close to haskell, but in the end it should be possible for a haskell-compiler (such as ghc) to output different 'binary' formats, like java bytecode or .net CLI. I remember reading about it, but it wasn't ready yet, or it even stopped.
16:22:27 <lament> int80_h: yes, i realize you *can* use them
16:22:34 <lament> int80_h: but how often do you find yourself needing them?
16:22:38 <int80_h> I thought so. I mean, I suspected that monads supplanted macros for some purposes.
16:22:57 <Holle_> now it works :) thanks!
16:22:58 <dmwit> bombshelter13: Parsec and Harpy are great examples.
16:23:03 <augustss_> One could argue that user defined infix is bad for readability
16:23:08 <bombshelter13> dmwit:  I'll look em up. :)
16:23:09 <mlh> so what's the answer to int80_h's question "IS there something that can be done with macros that haskell can't do?"
16:23:17 <mlh> I guess no
16:23:24 <dmwit> bombshelter13: xmonad ain't bad, either -- they even named the program after their X monad. =)
16:23:30 <int80_h> lament: me? not at all. But I'm thinking to the future when I want to write a mud engine in haskell. I'll need a language the way LPmud needs LPC.
16:23:39 <dpratt71> haskell is turing complete, right?
16:23:43 <rwbarton> augustss_: Sure.  So a language should not have too many such features :)
16:23:57 <bombshelter13> dmwit: viewing the X11 protocol as the domain specific language, I guess? :P
16:24:02 <dmwit> mlh: There are some things, yes; augustss_ mentioned the most common one, I guess.
16:24:16 <dmwit> bombshelter13: Actually, not quite; viewing window management as a DSL.
16:24:24 <dmwit> bombshelter13: It's a very cool DSL, in my opinion.
16:24:44 <bombshelter13> dmwit: hmm, curious...
16:24:48 <cknapp> dpratt71: I believe so... it contains System F as a subset...
16:24:52 <cknapp> I think
16:25:26 <cknapp> Really though, any "popular" programming language is going to be: jsut write a turing machine simulator
16:25:44 <cknapp> (left as an exercise for the reader, of course)
16:25:49 <dmwit> cknapp: That doesn't sound right.  System F doesn't have decidable type inference.
16:25:49 <loadquo> Or the game of life simulator.
16:25:58 <cknapp> Hmm...
16:26:08 <dpratt71> then the answer to the question "IS there something that can be done with macros that haskell can't do?" is...no
16:26:19 <dmwit> But "Turing complete" is indeed a pretty poor measure for a language. =)
16:26:20 <cknapp> dmwit: you're probably right.
16:26:27 <augustss_> System f is not Turing complete
16:26:32 <int80_h> so we don't need macros.
16:26:35 <cknapp> augustss_: really?
16:26:41 <oklopol> dpratt71: turing completeness only implies you can add any feature you like to the language if you're willing to just interpret it. actually adding a feature is a more subtle question turing completeness has nothing to do with.
16:26:41 <dmwit> Wait, what?
16:26:45 <augustss_> Really
16:26:59 <dmwit> Oh, yeah.
16:27:04 <cknapp> Hmm... hurray, LC, then?
16:27:19 <dmwit> It follows from the fact that all (well-typed) System F programs terminate, I guess.
16:27:34 <augustss_> Yes it does
16:27:34 <dmwit> System F + fix, then
16:27:39 <cknapp> dpratt71: Lisp macros? They do certain things easily, just like Haskell makes certain things easy taht are harder in other langauges
16:27:57 <oklopol> that is, you can always create any dsl in any tc language, it's just about whether you have to build it from scratch, or whether you can use the underlying language and build features on top of it
16:28:00 <cknapp> that*
16:28:18 <dpratt71> cknapp: the question I quoted didn't include the word "easily" ;)
16:28:28 <cknapp> So the answer is no. :D
16:28:55 <erikc> the power / "ease of use" of lisp macros are really tied into the dynamic typing + runtime code generation/interpretation features of a lisp system
16:29:01 <cknapp> But it may be that you need to write a lisp interpreter in Haskell to get what you want... That's unlikely, but possible
16:29:36 <cknapp> erikc: definitely.
16:29:48 <erikc> and haskell is statically typed and runtime code gen is inconvenient, so any things that macros can do that haskell cant do are most likely tied into the dynamic types / runtime code gen
16:30:02 <ddarius> erg0t: No it isn't.
16:30:09 <dmwit> As an aside, Haskell actually has several macro systems.
16:30:21 <SamB_irssi> several ?
16:30:25 <dmwit> CPP, TH, QQ, ...
16:30:31 <SamB_irssi> QQ?
16:30:31 <pumpkin> QQ?
16:30:31 <erikc> ddarius: was that to me?
16:30:38 <ddarius> erikc: Er, yes.
16:30:47 <dmwit> quasi-quoting -- it's kind of related
16:30:48 <SamB_irssi> and I wouldn't exactly call CPP a macro system ...
16:30:57 <dmwit> It passes for a macro system in C.
16:31:16 <SamB_irssi> that's only because C doesn't have a macro system
16:31:16 <pumpkin> oh
16:31:18 <erikc> ddarius: can you clarify?
16:31:19 <dmwit> There's also SYB and Derive for more specific needs.
16:31:32 <SamB_irssi> Derive is an application of TH, though
16:31:43 <SamB_irssi> not a macro system in itself
16:31:50 <dmwit> Well, these are just off the top of my head.
16:31:56 <dmwit> Without having actually used any of them myself.
16:32:11 <dmwit> So somebody who really wanted macros could certainly, with a bit of research, come up with something usable.
16:32:36 <SamB_irssi> and I think SYB is done almost entirely with typeclasses
16:33:06 <ddarius> erikc: Lisp macros don't have anything to do with dynamic typing or runtime code generation / "interpretation."  You can make a case for dynamic typing making it a bit easier (in some respects), but runtime code generation definitely has nothing to do with it.
16:33:50 <SamB_irssi> ddarius: how do you run the macros without interpretation ?
16:34:08 <ddarius> SamB_irssi: How do you run most of the code you run?
16:34:43 <SamB_irssi> Lisp code ?
16:35:02 <cknapp> ddarius: so it's a result of lisp list=lisp code?
16:35:11 <SamB_irssi> I suppose I generally use "load"
16:35:20 <SamB_irssi> and then call it from a REPL
16:36:02 <Saizan_> the fact that the macro code is compiled and run or interpreted looks irrelevant to me
16:36:18 <Saizan_> it all happens at compile-time anyway
16:36:33 <erikc> saizan: but compile-time can be run-time
16:36:44 <Saizan_> erikc: that's orthogonal
16:36:59 <Saizan_> erikc: the macro will be run at the compile-time of that run-time eval
16:37:01 <SamB_irssi> I think there are actually three times in Lisp
16:37:18 <SamB_irssi> compile-time, load-time, and run-time ...
16:37:34 <bombshelter13> Hey, sorry for the really basic one, but I'm still new to this language - how do I get 2^1/12? The ^ operator only seems to handle integral powers.
16:37:36 <SamB_irssi> hmm. that doesn't feel quite right.
16:37:50 <SamB_irssi> bombshelter13: it does only handle integer powers
16:37:51 <Cale> 2 ** (1/12)
16:37:59 <Cale> > 2 ** (1/12)
16:37:59 <kmeyer> anyone familiar with how hard it is to bootstrap ghc to a new platform?
16:38:00 <lambdabot>   1.0594630943592953
16:38:11 <pumpkin> bombshelter13: dealing with music?
16:38:13 <SamB_irssi> kmeyer: apparantly it's a black art
16:38:16 <bombshelter13> Cale: thanks! :)
16:38:18 <bombshelter13> pumpkin: yep
16:38:21 <pumpkin> :)
16:38:51 <Cale> bombshelter13: There are three exponentiation operators in the Prelude, corresponding to 3 separate definitions of exponentiation from mathematics.
16:38:58 <bombshelter13> pumpkin: still haven't gotten PortAudio hooked up, but I've got a little language neutral thing to write .WAVs that I'm using in the mean-time. :)
16:39:02 <Cale> :t (^)
16:39:04 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
16:39:07 <Cale> :t (^^)
16:39:08 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
16:39:09 <Cale> :t (**)
16:39:10 <pumpkin> bombshelter13: awesome :)
16:39:10 <lambdabot> forall a. (Floating a) => a -> a -> a
16:39:25 * cknapp learned something new!
16:39:40 <Cale> ^ requires positive integral powers, but allows any numeric base
16:39:55 <Cale> ^^ allows negative integral powers, but requires a fractionally-typed base
16:40:07 <Gracenotes> > fix (+1)
16:40:23 <lambdabot>   thread killed
16:40:29 <Gracenotes> > fix (+1) 0
16:40:30 <lambdabot>       No instance for (Num (t -> a))
16:40:30 <lambdabot>        arising from the literal `1' at <...
16:40:56 <Cale> ** allows fractional/floating point powers, but requires a floating point (or similar) base
16:42:14 <erikc> if you compile some code with the ghc api and it runs some template haskell, is there a way for the template haskell function to access your program's address space?
16:42:33 <erikc> i guess it wouldnt typecheck
16:42:42 <erikc> or it'd be hard to typecheck
16:50:42 <SamB_irssi> erikc: of course it can access your address space
16:51:09 <SamB_irssi> erikc: however, it most likely won't be able to make much sense of much of it
16:52:16 <erikc> right, thats the runtime codegen aspect im getting at, im not sure how'd feed some runtime data in your program to the compiler so the TH can use it to generate versioned code for your current state, and then dynamically load it
16:52:25 <erikc> samb: theres also read-time and reader macros for lisp
16:52:48 <SamB_irssi> erikc: I'm not sure it would be possible to do anything USEFULL this way ...
16:53:31 <Holle_> what i have to do if i have 2 modules and they want to use each other?
16:53:56 <dolio> Oh no! Even more SamBs!
16:54:00 <erikc> mainly for self-optimizing code
16:54:01 <dolio> @yow!
16:54:01 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
16:54:05 <SamB_irssi> Holle_: use a conforming implementation
16:54:18 <SamB_irssi> Holle_: (kidding. there aren't any!)
16:54:34 <Holle_> ?
16:54:56 <Holle_> so i have to build a module, that both use?
16:56:01 <erikc> or say, running a sql query and dynamically generating the code for manipulating the result so you can interact with it at the repl in a lispy manner :)
16:57:30 <Holle_> or what could i do?
16:59:04 <erikc> holle: yep, have a separate module that both use
17:01:29 <intoverflow> well, lesson learned: don't claim that haskell is prime time unless you have an IDE and a word processor :)
17:01:59 <ddarius> We have a word processor and multiple IDEs.
17:02:15 <ddarius> Well, text editor.
17:02:21 <intoverflow> yeah
17:02:30 <ddarius> Though I wouldn't be surprised if there were a (simple) word processor somewhere.
17:02:59 <lament> is there an ide and a word processor in perl, python, ruby?
17:03:06 <intoverflow> lament: exactly!
17:03:28 <pumpkin> intoverflow: no language is even a true respectable language without an IDE, right? like, duh!
17:03:56 <intoverflow> the comments have been interesting; a lot of people hadn't seen hoogle or hayoo before and were suitably impressed
17:04:29 <intoverflow> the api search engines are a pretty good demonstration that there's something unique going on
17:06:18 <kmeyer> hm, what if I just want to build a ghc that *targets* another platform, but runs on the host platform (a la gcc)?
17:06:46 <pumpkin> output to c and gcc that file to another platform? :P
17:06:50 <pumpkin> not sure that's a viable option though
17:07:01 <kmeyer> is there an option to output to C?
17:07:10 <kmeyer> (is .hc real C?_
17:07:12 <pumpkin> you can say via-C and then tell it to keep it
17:07:29 <pumpkin> I think so, although it's completely unreadable
17:07:31 <kmeyer> that'll probably expect the platform constants of the host, though
17:07:34 <pumpkin> (by humans)
17:07:36 <erikc> if ppl are worried about no ide, just wait till they try the debugger and see the real execution flow :P
17:07:57 <Saizan_> pumpkin: that C is not portable
17:08:04 <pumpkin> ah :/
17:08:41 <kmeyer> I think it'd be a really cool feature if it was added (probably a lot of work though)
17:09:08 <pumpkin> well they can already generate code for a bunch of different archs
17:09:16 <kmeyer> (e.g. compiling haskell code to run on embedded systems)
17:09:41 <kmeyer> pumpkin: right, but it has to be done *on* that arch
17:09:44 <int80_h> kmeyer: yeah I'd like to know if running haskell on a phone is possible the way running java is
17:09:59 <pumpkin> I want to compile ghc for iphone
17:10:03 <kmeyer> heh
17:10:04 <pumpkin> and add it to cydia
17:10:07 <kmeyer> a step in the right direction
17:10:10 <kmeyer> cydia?
17:10:11 <erikc> Saizan: is there a way to get the generated C to match/use the types in GHC's /include dir?
17:10:16 <pumpkin> but porting it is a rather daunting task
17:10:22 <pumpkin> kmeyer: apt for iphone
17:10:26 <kmeyer> oh, fun
17:10:39 <pumpkin> we already have hugs on it
17:10:45 <pumpkin> but ghc >> hugs :P
17:10:50 <int80_h> pumpkin: we have juhs for iphone?
17:10:54 <int80_h> I mean, hugs?
17:10:58 <kmeyer> and hugs certainly won't run on smaller systems, I think
17:11:06 <pumpkin> someone told me hugs was on there
17:11:12 <pumpkin> let me look
17:12:03 <pumpkin> yup
17:12:12 <Saizan_> erikc: i think that it's not that simple, however i don't know the details
17:12:34 <Saizan_> ghc-users@ should know
17:12:36 <int80_h> so it must be possible to compile ghc code to iphone
17:12:55 <pumpkin> int80_h: I'm sure it's possible, but it's scary getting it up and running
17:13:07 <kmeyer> pumpkin: can an iphone run gcc, etc?
17:13:25 <kmeyer> the platforms I'm thinking of are small enough that it'd be impossible to run gcc on them
17:13:26 <hydo> if it's unlocked, yes.
17:13:28 <int80_h> kmeyer: it wouldn't need to. You could cross-compile from somewhere else
17:13:35 <kmeyer> int80_h: right, that's what I'm trying to do
17:13:46 <kmeyer> but ghc doesn't support that in its bootstrap process, I think
17:13:51 <adimit> eeerh... can anyone tell me  why the ResponseCode in Network.HTTP.Base is an integer triple?
17:13:59 <pumpkin> kmeyer: yeah, it does have a gcc that runs natively
17:14:06 <pumpkin> but most people tend to cross-compile
17:14:08 <hydo> ghc for iphone... oooo.
17:15:30 <pumpkin> :)
17:15:35 <erikc> maybe the computer language shootout will need to start including power consumption along with space/time
17:15:50 <pumpkin> I'd imagine it's proportional to time :P
17:16:03 <pumpkin> unless you're calling special hardware like wifi
17:16:18 <adimit> erikc: wouldn't that pretty much be a function over cpu cycles and maybe IO?
17:16:27 <adimit> (so space/time again)
17:19:59 <dancor> anything pre-existing for manipulating a "view" into a List
17:20:14 <kmeyer> "view"?
17:20:24 <dnul_> i want a function that obtains the intersection of a list of list ...something like foldl (intersect) [??] [[2,3],[3,4]]  equals [3]
17:20:33 <dancor> like   type View a = [(a, Bool)]
17:20:43 <dancor> viewFilter f (x@(v, b) : xs) = (if b && f v then x else (v, False)) : viewFilter f xs
17:20:50 <Cale> dnul_: foldr1 intersect
17:20:52 <roconnor> > intersect [[2,3],[3,4]]
17:20:54 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
17:20:54 <lambdabot>        arising from a u...
17:21:02 <roconnor> > foldr1 intersect [[2,3],[3,4]]
17:21:04 <lambdabot>   [3]
17:21:15 <roconnor> > foldl1 intersect [[2,3],[3,4]]
17:21:17 <lambdabot>   [3]
17:21:19 <dnul_> wow , whats foldr1 ?
17:21:23 <roconnor> > foldl'1 intersect [[2,3],[3,4]]
17:21:24 <lambdabot>   Not in scope: `foldl'1'
17:21:29 <roconnor> > foldl1' intersect [[2,3],[3,4]]
17:21:31 <lambdabot>   [3]
17:21:40 <roconnor> > foldr1 intersect []
17:21:42 <lambdabot>   * Exception: Prelude.foldr1: empty list
17:21:45 <gwern> dnul_: ironic, just today I needed the exact same thing
17:22:02 <dnul_> gwern: doing projecteuler?
17:22:21 <dancor> "view" means you pretend you are manipulating some sublist of the list but you keep the ignored parts around as reasonably as you can
17:22:22 <dnul_> roconnor: What does foldr1 does?
17:22:41 <gwern> dnul_: no, writing a darcs backend for gitit
17:22:55 <gwern> the problem arose while processing the output of grep.
17:23:00 <dnul_> gwern: nice ..
17:23:01 <roconnor> dnul_: sames as foldr, except throws an exception for the empty list
17:23:11 <dmwit> dnul_: foldr1 f (x:xs) = foldr f x xs
17:23:21 <roconnor> @src foldr1
17:23:22 <lambdabot> foldr1 _ [x]    = x
17:23:22 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:23:22 <lambdabot> foldr1 _ []     = undefined
17:23:31 <dmwit> I like mine better.
17:23:37 <roconnor> me too
17:23:57 <Cale> I don't.
17:24:10 <dancor> @help vote
17:24:10 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
17:24:11 <Cale> dmwit's puts the first element of the list at the end...
17:24:15 <dmwit> You're right, I don't either.
17:24:26 <Cale> > let foldr1 f (x:xs) = foldr f x xs in foldr1 f [1,2,3,4,5]
17:24:28 <lambdabot>   Add a type signature
17:24:40 <Cale> > let foldr1 f (x:xs) = foldr f x xs in foldr1 f [1,2,3,4,5] :: [Expr]
17:24:40 <dnul_> roconnor: dmwit thanks
17:24:41 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
17:24:41 <lambdabot>        arising from a u...
17:24:43 <Cale> > let foldr1 f (x:xs) = foldr f x xs in foldr1 f [1,2,3,4,5] :: Expr
17:24:45 <lambdabot>   f 2 (f 3 (f 4 (f 5 1)))
17:24:54 <dmwit> Yep, you convinced me.
17:24:55 <dmwit> ?src foldl1
17:24:56 <lambdabot> foldl1 f (x:xs) = foldl f x xs
17:24:56 <lambdabot> foldl1 _ []     = undefined
17:24:59 <dmwit> great
17:25:02 <roconnor> foldr1 f l = foldr f (last l) (init l)
17:25:04 <sjanssen> dmwit: your foldr1 isn't right
17:25:13 <dmwit> sjanssen: Yep, we've noticed.
17:25:18 <sjanssen> ah, ok :)
17:25:44 <roconnor> hmm
17:25:50 <roconnor> I need a view pattern
17:26:29 <roconnor> foldr1 f (snoc l -> (xs,x)) = foldr f x xs
17:26:32 <roconnor> um
17:26:37 <roconnor> how do view patterns work?
17:26:53 <roconnor> 'cause what I wrote doesn't make any sense
17:26:59 <dancor> src is lying, the real one does (error "Prelude.foldr1: empty list") on [], not undefined
17:27:50 <roconnor> error "Prelude.foldr1: empty list" === undefined
17:27:57 <roconnor> :P
17:28:26 <roconnor> @src error
17:28:26 <lambdabot> error s = throw (ErrorCall s)
17:28:31 <roconnor> ohhh
17:28:40 <roconnor> @type throw
17:28:41 <lambdabot> Not in scope: `throw'
17:28:45 <sjanssen> roconnor: in Haskell '98, you're right
17:28:53 <sjanssen> in GHC with exceptions, you aren't
17:28:56 <roconnor> @hoogle throw
17:28:57 <lambdabot> Control.Exception throw :: Exception -> a
17:28:57 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
17:28:57 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
17:29:17 <roconnor> that doesn't look like the right definition of error.
17:29:20 <roconnor> where did that come from?
17:29:29 <dmwit> dancor: You can't tell the difference between undefined and error "foo" in pure code.
17:29:49 <roconnor> error            :: String -> a
17:29:49 <roconnor> error            =  primError
17:29:50 <dmwit> Why doesn't it look right?
17:29:55 <roconnor> that is the src for error
17:30:05 <dmwit> helpful =)
17:30:21 <roconnor> :P
17:30:24 <dancor> @src error
17:30:25 <lambdabot> error s = throw (ErrorCall s)
17:30:35 <dancor> @src throw
17:30:36 <lambdabot> throw exception = raise# exception
17:30:43 <dancor> @src raise#
17:30:44 <lambdabot> Source not found. There are some things that I just don't know.
17:30:53 <roconnor> obviously it should be primError s = throw (ErrorCall s)
17:32:09 <dancor> raise# = fix homunculus
17:37:41 <cknapp> How does the deriving keyword actually work-- what is the compiler doing to generate the class code?
17:38:05 <ddarius> @where report
17:38:05 <lambdabot> http://www.haskell.org/onlinereport/
17:38:12 <cknapp> :)
17:38:14 <wli> cknapp: By induction on the structure of types.
17:38:29 <cknapp> Ah.
17:39:23 <rwbarton> Does gtk2hs compile against ghc-6.10.1?
17:39:42 <dcoutts> rwbarton: the darcs version does and we're expecting a tarball release any day now
17:42:33 <rwbarton> dcoutts: thanks.  What do I have to get a configure script in the darcs version?
17:42:49 <dcoutts> autoreconf
17:44:46 <pumpkin> when does logo voting happen, and who decides who gets to vote?
17:48:18 <cknapp> :t (=<<)
17:48:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:49:11 <cknapp> pumpkin: logo voting?
17:50:45 <dmwit> pumpkin: When you find out, let me know.
17:51:06 <dmwit> pumpkin: That seems to be the least organized part, which is a shame, since there's so many good logos on the page...
17:52:43 * mmorrow votes for the  >Î»=  logo
17:52:58 <cknapp> Logo for what?
17:53:06 <mmorrow> for haskell
17:54:31 <cknapp> "bind the real world" hehe
17:54:38 <cknapp> Too bad it isn't a very good logo...
17:56:09 <mmorrow> i mean come on, (>Î»=) is not only ingenious, but it can be conveyed in its entirety using only characters typable on a keyboard
17:57:57 <mmorrow> , ">Î»="
17:57:59 <lunabot>  ">\955="
17:58:03 <mmorrow> , utf8enc ">Î»="
17:58:06 <lunabot>  ">\206\187="
17:58:24 <kmeyer> where is lambda on my keyboard?
17:58:36 <mmorrow> ok you got me
17:58:40 <mmorrow> :)
17:58:56 <kmeyer> ">\=" <-- poor substitute
17:59:20 <mmorrow> that's acceptable nonetheless i'd say
17:59:28 <keseldude> map lambda to replace $
18:00:08 * ddarius use $ more than Î» 
18:00:48 * mmorrow never uses Î» other than when voting for logos and lying about what keys are on keyboards
18:01:08 * dmwit has \lambda on his keyboard
18:01:22 <mmorrow> is it right next to \kappa?
18:01:44 <ddarius> @google ÎºÎ¶
18:01:46 <lambdabot> http://www.kz-epka.gr/
18:01:46 <lambdabot> Title: ï¿½ï¿½' ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ ...
18:01:57 <ddarius> @google ÎºÎ¶-calculus
18:01:59 <lambdabot> No Result Found.
18:02:12 <keseldude> doesn't look like lambda to me
18:02:23 <Cale> I can type Î» either by pressing both shift keys and hitting l, or by putting SCIM into TeX mode and typing \lambda
18:02:49 * ddarius would never want to type something while pressing both shift keys.
18:02:57 <cknapp> mmorrow: can you give me a link to the >\= logo (too lazy to get a real lambda...
18:03:19 * mmorrow looks for it
18:03:26 <mmorrow> @go Î¼Î·Î½Î¹Î½Î½ Î±ÎµÎ¹Î´Îµ Î¸ÎµÎ±
18:03:28 <lambdabot> No Result Found.
18:04:16 <cknapp> Why are you looking up random Greek?
18:05:05 <mmorrow> http://article.gmane.org/gmane.comp.lang.haskell.cafe/49072
18:05:16 <mmorrow> http://media.nokrev.com/junk/haskell-logos/logo8.png
18:05:22 <mmorrow> that's not random greek!
18:05:53 <cknapp> Ah. Right... I totally missed the >
18:05:54 <mmorrow> there're also ones with non-rounded corners
18:05:58 <cknapp> What is it?
18:06:09 <mmorrow> the start of the iliad
18:06:47 <cknapp> Ah...
18:06:58 <mmorrow> oops
18:07:05 * cknapp only reads Greek well enough to decipher Greek from random button mashing...
18:07:13 <mmorrow> s/Î¼Î·Î½Î¹Î½Î½/Î¼Î·Î½Î¹Î½/
18:07:20 <mmorrow> @go Î¼Î·Î½Î¹Î½ Î±ÎµÎ¹Î´Îµ Î¸ÎµÎ±
18:07:28 <lambdabot> http://www.signographie.de/cms/upload/pdf/Andron_1_Gre_Cp_Muster.pdf
18:07:28 <lambdabot> Title: Îá¿Î½Î¹Î½ á¼ÎµÎ¹Î´Îµ, Î¸ÎµÎ¬, Î Î·Î»Î·Î¹Î¬Î´ÎµÏ á¼ÏÎ¹Î»á¿Î¿Ï
18:07:30 <mmorrow> woot!
18:07:35 <cknapp> I was wondering why there were two nus at the end.
18:07:53 <mmorrow> heh
18:08:14 <cknapp> Nice.
18:08:21 <abuiles1> Hi Guys, could someone please explain me what does " model -> pK "  in   "instace Operation model pK | model -> pK w"
18:08:33 * cknapp now has a pdf he'll never read...
18:08:34 <abuiles1> how can I read that
18:08:35 <abuiles1> ?
18:09:04 <rwbarton> abuiles1: That isn't valid syntax
18:09:10 <cknapp> Can you get rid of the quotation marks?
18:09:19 <rwbarton> abuiles1: You probably mean  class Operation model pK | model -> pK where ...
18:09:34 <mmorrow> sing of wrath, goddess, the wrath of hateful achilles...
18:09:54 <rwbarton> funny how all the non-acute accented characters don't show up on my terminal
18:10:12 <wli> My terminal isn't showing anything intelligible; it must lack unicode.
18:10:40 <abuiles1> rwbarton: Yes that's right I wrote bad
18:10:41 <abuiles1> http://hpaste.org/13932
18:11:08 <wli> Now it shows it properly.
18:11:23 <rwbarton> abuiles1: It means you can't have two instances Operation model pK and Operation model pK' with pK and pK' different types
18:11:31 <wli> Sort of. A bunch of the characters are still garbage.
18:11:33 <rwbarton> abuiles1: the type model determines the type pK.  It's called a functional dependency
18:12:22 <rwbarton> wli: Those are probably all the characters with accents that aren't used in modern greek
18:12:29 <abuiles1> rwbarton: what I don't get is the second part after |
18:12:48 <mmorrow> yeah, there are more accents in ancient
18:12:48 <rwbarton> abuiles1: Yes, that's exactly what I was explaining above
18:13:02 <mmorrow> well, there were _no_ accents in actual ancient greek
18:13:28 <wli> Nor punctuation. ;)
18:13:28 <mmorrow> they were added later
18:13:33 <mmorrow> nor spaces!
18:13:38 <mmorrow> :)
18:13:43 <Saizan_> nor letters!
18:13:47 <cknapp> mmorrow: sounds fun!
18:13:48 <rwbarton> MHNINAEIDE
18:14:00 <mmorrow> leet!
18:14:14 <cknapp> I guess it's a good thing that greek word endings are predictable?
18:14:27 <rwbarton> Youreallythinkspacesarethatimportanttounderstaing?
18:14:40 <wli> I don't know about spaces. Punctuation I do know didn't exist. I'm not sure how capitalization was actually done in the original texts, either, but suspect it may not have had the same relationship to sentence structure as expected by readers of modern-day English.
18:14:48 <cknapp> rwbarton: correct spelling is more important.
18:14:49 <cknapp> :)
18:15:01 <abuiles1> rwbarton: thank!
18:15:02 <rwbarton> cknapp: Yeah, I noticed that but didn't want to write out the whole thing again :)
18:15:05 <abuiles1> *S
18:15:05 <repnop> spelling doesn't matter in english
18:15:16 <wli> Not only was spelling not standardized, but the alphabet wasn't entirely standardized, either.
18:15:16 <repnop> as long as the length is near correct and the first and last letters are correct
18:15:20 <rwbarton> wli: Well, the original "texts" weren't even written down.
18:15:54 <wli> rwbarton: When speaking of the Iliad and Odyssey, yes. I was referring to ancient Greek as written by the ancient Greeks themselves.
18:16:02 <cknapp> Hell, even English spelling wasn't standardized until the 18th century
18:16:02 <mmorrow> there were no spaces, and certain letters get alided in certain situations making it hard as crap to decipher wtf ALLCAPSNOSPACESAYING
18:16:57 * bombshelter13 needs a good hugs error cheatsheet. :/
18:17:07 <wli> I'm not 100% sure whether ancient Greek had the distinction between miniscule and majuscule.
18:17:34 <ddarius> I'm pretty sure it didn't.
18:17:35 <mmorrow> wli: yeah, i'm not so sure either
18:18:00 * wli remember seeing mostly allcaps but isn't a connoisseur of ancient texts.
18:18:07 <Gracenotes> yay me, I spent the last two hours trying to apply fix to a function, rather than applying a function to fix. RPN has its drawbacks... :/
18:18:20 <cknapp> Gracenotes: HAHAHA
18:18:34 * rwbarton has certainly seen inscriptions in all caps without no spaces but doesn't know exactly when lowercase letters and spaces came about
18:18:35 <ddarius> Don't you usually apply fix to a function.
18:19:04 <mmorrow> i think that's what the "original" whatever they found it on was in, but iirc the lowercase letters + the various accents and rules for them got invented in the middle ages
18:19:16 <cknapp> ddarius: I think that was part of the joke... he's working on an esoteric language
18:19:27 <Gracenotes> have I confused the application order? by applying fix to a function I mean using fix as the argument for a function, rather than the other way around
18:19:45 <ddarius> f fix is f applied to fix
18:19:47 <cknapp> Gracenotes: Oh. you're right
18:20:03 <cknapp> Gracenotes: do you have any info on this language?
18:20:34 <wli> mmorrow: Ancient Egyptian is more interesting from the standpoint of being a mixture of ideogrammatic and other sorts of systematization.
18:21:10 <Gracenotes> cknapp: I made it up, thanks to the help of ski_... the expressions in it are: data LExpr = Var String | Lam String LExpr | App LExpr LExpr | Boole Bool | Cond LExpr LExpr LExpr | Zero | Succ LExpr | Pred LExpr | IsZero LExpr | Add LExpr LExpr | Mul LExpr LExpr
18:21:16 <mmorrow> wli: i've always thought that would be really interesting, but haven't learned anything about it
18:21:36 <Gracenotes> the rest of it is evaluating and parsing
18:22:13 <cknapp> Ah...
18:22:19 <Gracenotes> the tokens are 0, T, F, ?0, +1, -1, >string, #string, @, +, *, and ?
18:22:23 <wli> mmorrow: I don't know all that much about it apart from that it had the same sorts of deficits as other writing systems in tandem with being a wild mixture of different things (syllables, ideograms, phonetic, etc.).
18:22:53 <cknapp> I love this channel so much more than I can ever express in words...
18:22:55 <mmorrow> (classes, functional dependencies, GADTs, type families, ...)
18:22:57 <mmorrow> oops
18:23:15 <Gracenotes> I'm going to work on it some more and get it in a more usable state
18:23:18 * mmorrow invokes the google machine
18:25:36 * wli is still stymied by smoking out left and right Householder transformations to eliminate the nondiagonal lower and right borders of a matrix (i.e. u^t u = v^t v = 1 and (I - 2 u u^t) A (I - 2 v v^t) is zero along its lower and right borders save for the lower right corner element).
18:26:01 <wli> (More specifically effective computation thereof.)
18:26:16 <mmorrow> 5998x7838 image of the rosetta stone http://www.freemasonry.bcy.ca/biography/champollion_jf/rosetta.gif
18:26:19 <Gracenotes> aha! I've finally gotten factorial working: fix >a ?0 1 >f >a -1 @ >a * ? #a #f @ 5 @. When I add forth-like definitions, I can do factorial 5 @
18:26:27 <wli> (And yes, it's hoping for a direct method for the SVD.)
18:26:45 <defu1> can someone explain the difference of top-down programming vs. bottom-up programming? Or better yet, are there any code examples out there? Are libraries examples of bottom-up programming? Does functional programming inherently imply bottom-up programming?
18:28:35 <cknapp> Why does everyone ask questions that I can almost, but not quite, provide some sort of meaningful answer to?
18:29:00 <Gracenotes> yay, got peano addition to work. The fruit of 3 hours of work realized! okay then :X
18:29:35 <cknapp> Gracenotes: If it makes you feel better, I think it took more than 3 hours for Peano to come up with it...
18:29:55 <Gracenotes> heh
18:30:00 <kerlo> There's such a thing as bottom-up programming?
18:30:26 <dolio> I imagine those terms could mean multiple things to multiple people.
18:30:36 <cknapp> lispers talk about it all the friggin' time...
18:30:50 <kerlo> If I'm not as ignorant as I think I am, bottom-up programming is buying all the parts and then figuring out what you need them for, and top-down programming is figuring out what parts you need and then buying them.
18:30:57 <Gracenotes> I've heard top-down and bottom-up programming compared to evaluation, somewhere
18:31:04 <Gracenotes> top-down is lazy, bottom-up is strict
18:31:32 <dolio> You could talk about top-down versus bottom-up mergesort and be pretty clear about it.
18:31:32 <Gracenotes> you may do a lot of work for bottom-up, but not all of it may be realized in the final result
18:31:46 <kerlo> Maybe people who know the answer are as ignorant as I am regarding it, then.
18:31:47 <cknapp> dolio: heh
18:31:56 <dolio> Top down is where you say, "to sort array A, divide it in half, sort the two arrays, and then merge."
18:31:57 <kerlo> (English: "Maybe I do know the answer, then.")
18:32:01 <steshaw> @pl concat (intersperse ", " (map show (xs)))
18:32:01 <lambdabot> join (intersperse ", " (map show xs))
18:32:07 <Gracenotes> that definition of top-down/bottom-up in terms of practice makes sense to me
18:32:28 <dolio> Bottom up is where you say, "divide array A into trivially sorted arrays, then merge two together at at time until you have only one array left."
18:32:28 <steshaw> @pl join = concat (intersperse ", " (map show (xs)))
18:32:29 <lambdabot> join = join (intersperse ", " (map show xs))
18:32:34 <cknapp> Gracenotes: I don't think that's what he had in mind...
18:32:39 <steshaw> @pl join xs = concat (intersperse ", " (map show (xs)))
18:32:40 <lambdabot> join = join . intersperse ", " . map show
18:32:42 <wli> dolio: What's heapification then dequeueing, then?
18:32:50 <Gracenotes> cknapp: not sure if he was talking about process or not
18:32:56 <wli> dolio: Dequeueing is quite incremental...
18:33:22 <dolio> I'm not sure heapsort has multiple variants on the algorithm in the same way.
18:34:10 <kerlo> What's the fastest, then?
18:34:17 <dolio> It's not really a divide and conquer algorithm.
18:34:33 <dolio> Of course, there's no bottom-up quicksort, either.
18:34:33 <cknapp> Gracenotes: I thought he was talking about the act of programming itself... But I could be wrong
18:34:44 <dolio> At least, not that I can think of off the top of my head.
18:35:06 <Gracenotes> cknapp: yes, me too. Hm. Process of writing a program, that is
18:35:16 <ddarius> kerlo: Top-down would be clearly ideal if every problem had a clear, clean, unchanging break-down.
18:35:36 <ddarius> (and you only had one problem)
18:36:23 <mmorrow> wli: wow hieroglyphs are super interesting (reading http://en.wikipedia.org/wiki/Egyptian_hieroglyphs)
18:36:42 <wli> Also if every problem were small enough that it didn't have to be decomposed into smaller subproblems for the sake of comprehensibility.
18:36:50 <mmorrow> "owever, the same sign can, according to context, be interpreted in diverse ways: as a phonogram (phonetic reading), as a logogram, or as an ideogram (semagram; "determinative") (semantic reading)."
18:37:22 <wli> mmorrow: That's the general idea of what I know about them, except I only know the vaguest summary (like the quoted sentence).
18:37:37 <ddarius> wli: That exactly what top-down design does, so that's certainly not an issue with it.
18:39:22 <wli> Decomposability, compositionality, etc. you already covered.
18:40:38 <mmorrow> this is interesting:
18:40:42 <mmorrow> "Hieroglyphs are written from right to left, from left to right, or from top to bottom, the usual direction being from left to right. The reader must consider the direction in which the asymmetrical hieroglyphs are turned in order to determine the proper reading order."
18:41:21 * mmorrow sees ideas for program representation in hieroglyphs ;)
18:41:33 <dublpaws> it comes down to names
18:41:49 <dublpaws> names are important, need a picture for each one
18:42:39 <wli> mmorrow: One has to wonder how well anyone can actually read the stuff.
18:47:14 <cknapp> wli: Archaeologists make their living the same way scribes did: by pretending to know what's going on. :)
18:48:52 <Saizan> you mean scribes were just doodling there acting intellectual?
18:49:21 * wli does some more quick algebra on B = (I - 2uu^t) A (I - 2vv^t) hoping that something can be smoked out to make the right and lower borders of B all 0 save for the lower right diagonal.
18:50:02 <cknapp> Saizan: Of course!
18:50:13 <ddarius> Saizan: Just like current ones.
18:50:22 <cknapp> They also had better memories than everybody else (so no one could tellt ehy were lying)
18:50:49 <wli> (Or, alternatively, the first row and column save for the upper leftmost entry.)
18:51:12 <mmorrow> yeah, but they didn't have paper that would do what they wrote BY ITSELF!
18:51:16 <cknapp> wli: I try to avoid linear algebra...
18:51:21 <mmorrow> , [0..]
18:51:23 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
18:51:36 <cknapp> mmorrow: We do!!!!
18:51:46 <mmorrow> WE WIN!
18:51:51 <cknapp> HURRAY!
18:51:57 <pumpkin> what?
18:52:01 * cknapp grabs a bottle of champagne
18:52:14 <cknapp> pumpkin: We win!
18:52:17 <cknapp> Isn't that enough?
18:52:20 <pumpkin> oh, yay!
18:52:23 <pumpkin> congratulations :)
18:52:28 <wli> , let cantor ((x:xs):xss) = x : cantor (zipWith (:) xs xss) in take 10 $ cantor [[(i, j) | j <- [0..]] | i <- [0..]]
18:52:31 <lunabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)]
18:52:40 * cknapp is trying not to fall on the ground laughing
18:52:52 <mmorrow> heh
18:53:03 <ddarius> cknapp is easily entertained.
18:53:17 <cknapp> Sometimes...
18:53:26 <cknapp> really, I just laugh violently when I laugh
18:53:59 <cknapp> Or I just think I'm funnier than I am...
18:54:37 <dancor> @src span
18:54:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:54:49 <mmorrow> @src break
18:54:50 <lambdabot> break p =  span (not . p)
18:54:59 <dancor> lambdabot: what are _you_ doing?  not enough that's what
18:55:07 <wli> (The zipWith (:) there is actually problematic, since if xss is shorter than xs or vice-versa things go awry.)
18:55:53 <cknapp> wli: what are you trying to write?
18:56:25 <wli> cknapp: Nothing. I just got no help/hints/etc. in the SVD junk so I spewed something random.
18:56:42 <kerlo> wli: any particular reason you called it 'cantor'?
18:57:16 <pumpkin> it's the cantor pair function isn't it? or something to that effect
18:58:27 <dancor> http://en.wikipedia.org/wiki/Cantor_pairing_function
18:59:34 <kerlo> Nothing to do with the Cantor set, then.
19:02:06 <SamB> dons: why did you submit my lame blog entry to reddit ?
19:02:23 <wli> , let myZip (x:xs) (y:ys) = (x:y) : myZip xs ys ; myZip [] ys = ys ; myZip xs [] = [xs] ; cantor ([]:xss) = cantor xss ; cantor [] = [] ; cantor ((x:xs):xss) = x : cantor (myZip xs xss) in take 10 $ cantor [[(i, j) | j <- [0..]] | i <- [0..]]
19:02:25 <lunabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0)]
19:03:08 <mmorrow> , let diag [] ((x:xs):xss) = x : diag [xs] xss; diag ([]:q) xss = diag q xss; diag ((y:ys):q) [] = y : diag (q++[ys]) []; diag ((y:ys):q) ((x:xs):xss) = y : x : diag (q++[ys,xs]) xss in diag [] (fmap repeat [0..])
19:03:09 <lunabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16...
19:04:28 <mmorrow> , let diag [] ((x:xs):xss) = x : diag [xs] xss; diag ([]:q) xss = diag q xss; diag ((y:ys):q) [] = y : diag (q++[ys]) []; diag ((y:ys):q) ((x:xs):xss) = y : x : diag (q++[ys,xs]) xss in diag [] (fmap (\n -> zip (repeat n) [0..]) [0..])
19:04:30 <wli> mmorrow: Maybe join replicate would be more interesting.
19:04:30 <lunabot>  [(0,0),(0,1),(1,0),(0,2),(2,0),(1,1),(3,0),(0,3),(4,0),(2,1),(5,0),(1,2),...
19:04:45 <mmorrow> hmm
19:05:43 <mmorrow> @let diag = let go [] ((x:xs):xss) = x : go [xs] xss; go ([]:q) xss = go q xss; go ((y:ys):q) [] = y : go (q++[ys]) []; go ((y:ys):q) ((x:xs):xss) = y : x : go (q++[ys,xs]) xss in go []
19:05:46 <lambdabot>  Defined.
19:05:50 <mmorrow> @type diag
19:05:51 <lambdabot> forall t. [[t]] -> [t]
19:06:11 <mmorrow> > diag (fmap (join replicate) [0..])
19:06:13 <lambdabot>   * Exception: <local>:36:11-170: Non-exhaustive patterns in function go
19:06:16 <mmorrow> sigh
19:06:34 <wli> mmorrow: See what I mean? ;)
19:07:09 <BMeph> It reminds me of the searchable infinite sets stuff Escardo is doing. :)
19:07:20 <mmorrow> wli: hehe
19:07:30 <wli> , let myZip (x:xs) (y:ys) = (x:y) : myZip xs ys ; myZip [] ys = ys ; myZip xs [] = [xs] ; cantor ([]:xss) = cantor xss ; cantor [] = [] ; cantor ((x:xs):xss) = x : cantor (myZip xs xss) in take 25 . cantor $ map (join replicate) [0..]
19:07:33 <lunabot>  [1,2,2,3,4,3,4,5,3,4,5,6,7,4,5,6,7,8,9,5,6,7,8,9,10]
19:08:37 <dancor> ok i should be less hard on lbot
19:08:47 <dancor> i too cannot find the defn of span in the ghc source
19:09:42 <mmorrow> found it. geez, that one was sneeky
19:09:53 <mmorrow> @let diagonal = let go [] [] = []; go [] ((x:xs):xss) = x : go [xs] xss; go ([]:q) xss = go q xss; go q ([]:xss) = go q xss; go ((y:ys):q) [] = y : go (q++[ys]) []; go ((y:ys):q) ((x:xs):xss) = y : x : go (q++[ys,xs]) xss in go []
19:09:56 <lambdabot>  Defined.
19:10:06 <mmorrow> > diagonal (fmap (join replicate) [0..])
19:10:08 <lambdabot>   [1,2,2,3,3,4,3,5,4,6,5,7,4,8,6,9,5,10,7,11,4,12,8,13,6,14,9,15,5,16,10,17,7...
19:10:22 <dancor> at least there is an implementation here http://www.haskell.org/onlinereport/standard-prelude.html
19:10:30 <wli> Interesting would be the indices of various numbers.
19:10:43 <mmorrow> i'm sure that sequence of patterns could be optimized..
19:11:12 <wli> mmorrow: At one point I had written something involving typeclasses that could flatten out arbitrarily deeply nested lists in like fashion.
19:11:40 <mmorrow> wli: interesting
19:12:43 <mmorrow> i hate having to deal with the (verbosity) overhead of Mu in similar cases (w/out typeclasses)
19:13:07 <wli> mmorrow: It didn't do diagonal . diagonal etc.; it actually arranged for indices to occur in a natural fashion, so e.g. [[[(i, j, k) | k <- [0..]] | j <- [0..]] | i <- [0..]] would have (u,v,w) before (u',v',w') whenever u + v + w < u' + v' + w' etc.
19:13:12 <mmorrow> but even then, i'm not clear on what can be done with typeclasses that requires something like Mu to do without
19:13:38 <mmorrow> ah, i see
19:16:08 <mmorrow> there's this paper "A Poor Man's Concurrency Monad" that makes a neat ADT and uses a Cont variant + a round-robin scheduler to essentially do what diag is doing, but in [a], s/[b]/a "process" producing output/
19:16:24 <mmorrow> i thought it was a cool way to look at things
19:17:01 <wli> mmorrow: It was, however, dogslow. It calculated lists of indices like [Int] and somehow managed to unravel things from there IIRC.
19:17:15 <mmorrow> heh
19:17:30 <mmorrow> http://www.cs.chalmers.se/~koen/pubs/entry-jfp99-monad.html
19:18:05 <wli> mmorrow: Basically doing it for precisely the case of [[(Int, Int)]], [[[(Int, Int, Int)]]], etc., and using !! one dimension at a time.
19:18:17 <mmorrow> urg
19:18:33 <wli> mmorrow: I had general formulas for the indices worked out that made it possible.
19:18:57 <elliotbay> Hi all, I've got a noob question for anyone willing: Should I be able to use data constructors as first-class functions?
19:19:08 <mmorrow> i wonder how that would perform with something like Data.Sequence
19:19:44 <wli> Probably better than what I ended up doing, but the indexing structures for such things can be problematic.
19:19:56 <Cale> elliotbay: yes
19:20:24 <bombshelter13> What does an ' Instance of Integral Double required for definition of saw' error imply? It happens when I try to floor something, that, when returned, looks like a double...
19:20:24 <BMeph> @where hpaste2
19:20:25 <lambdabot> I know nothing about hpaste2.
19:20:39 <BMeph> mmorrow: ^^ (hint, hint) ;)
19:20:58 <Cale> :t floor
19:20:59 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
19:21:24 * mmorrow snaps to
19:21:27 <Cale> bombshelter13: floor turns something from a RealFrac type (for example Double) into something of Integral type (for example Integer)
19:21:35 <SamB> bombshelter13: fromInteger . floor
19:21:43 <mmorrow> @where+ hpaste2 http://moonpatio.com:8080
19:21:43 <lambdabot> Okay.
19:21:50 <bombshelter13> Cale:  Ohhh, so i need to convert it's return into a doble again.
19:21:50 <dons> bombshelter13: using hugs eh?
19:21:53 <Cale> yeah.
19:22:07 * BMeph smiles and salutes mmorrow in gratitude. :)
19:22:10 <Cale> I wonder if it ought to be generalised.
19:22:20 <BMeph> mmorrow: Thank you! :)
19:22:25 <Cale> (to Num)
19:22:29 <mmorrow> no problemo
19:22:32 <bombshelter13> dons: At the moment, yeah, I'm on my OS X machine and macports didn't seem to like building GHC. :/
19:23:14 <elliotbay> Cale: So, if i have (Tic :: [[Space]] -> Board) and (l :: [[[Space]]]), then I should be able to say "map Tic l", right?
19:23:43 * BMeph wouldn't mind dealing with magmas, if that's what it takes to kick the Prelude's number class stack to the curb...
19:23:59 <elliotbay> Incidentally, I'm in the same position as bombshelter13
19:24:35 <Cale> elliotbay: yes
19:24:39 <mmorrow> what the frig is a "magma"?? i've never heard of such thing until about two months ago (and by overhearing someone in here talking about it)
19:24:50 <Cale> mmorrow: A magma is a set with an operation on it.
19:25:00 <mmorrow> hmm
19:25:07 <SamB> a binop, yes ?
19:25:09 <mmorrow> a binary one?
19:25:12 <Cale> yes
19:25:19 <Cale> and closed
19:25:22 <ddarius> @quote free.pointed.magma
19:25:22 <lambdabot> ddarius says: In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
19:25:27 <Cale> (in case you worry about partiality)
19:25:37 <mmorrow> hehe
19:26:08 <harovali> what function wuold be useful to group the elements of a list in sub lists of n elements?
19:26:11 <SamB> ddarius: is that a topologists tree or a computer scientist's tree ?
19:26:25 * BMeph thinks "free pointed magma" sounds like something from Half-Life 3.
19:26:25 <rwbarton> Topologists don't have trees, do you mean graph theorists?
19:26:32 <SamB> oh, maybe
19:26:40 <ddarius> SamB: Computer scientists'.
19:26:41 <SamB> topologists don't have trees ?
19:26:41 <intoverflow> rwbarton: we've got degree-1 CW complexes
19:26:50 <rwbarton> intoverflow: connected and simply connected :)
19:27:02 <SamB> (what do they make topology textbooks out of, then?)
19:27:11 <Cale> harovali: something like:  map (take n) . takeWhile (not . null) . iterate (drop n)
19:27:13 <X-Scale> -
19:27:13 <X-Scale> catz is ~dddd@2001:470:91bc:0:70bd:93d:1d54:ac3e * 333
19:27:13 <X-Scale> catz on #ipv6
19:27:13 <X-Scale> catz using irc.ipv6.he.net Hurricane Electric IPV6 IRC Server
19:27:13 <X-Scale> catz actually using host 2001:470:91bc:0:70bd:93d:1d54:ac3e
19:27:17 <X-Scale> err...sorry
19:27:22 <X-Scale> stupid paste :S
19:27:26 * intoverflow  plays a drum sane fore samb
19:27:49 <Cale> > let chunk n = map (take n) . takeWhile (not . null) . iterate (drop n) in chunk 3 "abracadabra"
19:27:51 <lambdabot>   ["abr","aca","dab","ra"]
19:27:57 <mmorrow> SamB: mobius strips
19:28:11 <harovali> Cale: wow
19:28:33 <SamB> mmorrow: that must make it difficult to join more than two pages together
19:28:50 <elliotbay> Cale: Oh, thanks.  I was looking in the wrong part of the error line, having forgotten parens around a parameter in a function definition
19:29:01 <Cale> elliotbay: ah
19:29:01 <mmorrow> that's not a problem, since you can't turn the page anyways
19:29:01 <SamB> and I think to do even that you need to figure out how to make a klein bottle
19:29:16 <SamB> mmorrow: I was thinking that too
19:29:19 <BMeph> harovali: That's nothing - Cale spared you from the "unfildr/listToMaybe/splitAt" version. ;)
19:29:27 <BMeph> *unfoldr
19:29:44 <harovali> BMeph: how would that be?
19:30:19 <dons> ?users
19:30:20 <lambdabot> Maximum users seen in #haskell: 651, currently: 583 (89.6%), active: 19 (3.3%)
19:30:22 <BMeph> harovali: I'll "leave it as an exercise"... ;)
19:30:35 <pumpkin> 583!
19:30:39 <pumpkin> that's almost nobody :(
19:30:50 <harovali> BMeph: o my  :)
19:31:14 * BMeph thinks pumpkin should rename his Tweet to "pumpkindemiurge"... ;p
19:31:53 <pumpkin> :o
19:32:03 <pumpkin> :O
19:32:05 <pumpkin> !!!
19:32:44 <pumpkin> BMeph: sorry for spamming recently :P
19:34:07 <Cale> > let chunk n = unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt n)) in chunk 3 "abracadabra"
19:34:08 <lambdabot>   ["abr","aca","dab","ra"]
19:34:11 <Cale> ;)
19:34:46 <pumpkin> I'm so excited about using guard in an unfold
19:34:54 <pumpkin> I've always disliked having to put an if in there
19:38:42 <Gracenotes> @unpl liftM2 (>>) (guard (\a -> f b))
19:38:42 <lambdabot> (\ g -> (guard (\ a -> f b)) >>= \ c -> g >>= \ a -> return (c >> a))
19:39:09 <Gracenotes> erm. hm.
19:39:17 <Gracenotes> @unpl liftM2 (>>) (guard (\a -> f a))
19:39:18 <lambdabot> (\ g -> (guard (\ a -> f a)) >>= \ c -> g >>= \ b -> return (c >> b))
19:39:30 <Saizan> unpl doesn't use types to simplify
19:39:51 <Gracenotes> mm :/
19:39:56 <Gracenotes> @unpl liftM2 (>>) (guard f)
19:39:57 <lambdabot> (\ e -> (guard f) >>= \ b -> e >>= \ a -> return (b >> a))
19:40:00 <Saizan> liftM2 (>>) (guard . not . null) (return . splitAt n) == \x -> do (guard . not . null) x; return . splitAt n $ x
19:40:08 <elliotbay> Round 2: I have a type I need to process, but it doesn't matter which data constructor I've used (they're all of arity 1), should I be able to bind that to a variable (or _) when pattern-matching, and go on to look at the parameter?
19:40:19 <Gracenotes> ah
19:41:15 <Saizan> elliotbay: no, you can't match on a generic constructor
19:41:21 <Cale> elliotbay: I'm afraid not. You can either redesign your type to factor out the enumeration of possibilities, or you can write a function which projects out the value.
19:41:35 <Cale> For example, if you had:
19:41:49 <Cale> data Foo = A Double | B Double | C Double
19:41:56 <Cale> you might refactor that as
19:42:01 <Cale> data FooType = A | B | C
19:42:07 <Cale> data Foo = Foo FooType Double
19:43:10 <Cale> Or else write something like  fooValue :: Foo -> Double, which captures the pattern matching for you.
19:43:12 <elliotbay> I see, thanks
19:44:00 <elliotbay> Of course, the last option, i would have to write all the cases down anyway
19:44:16 <elliotbay> *latter
19:44:40 <Cale> yes
19:44:46 <Cale> But you'd only have to do it once.
19:44:52 * elliotbay nods
19:45:36 <elliotbay> 'twas only for a show function
19:46:35 <Cale> elliotbay: You should note that you can also just derive show
19:46:46 <Cale> data Foo = ... deriving (Show)
19:47:19 <Cale> Oh, but of course, the derived show will actually print the constructor.
19:48:55 <elliotbay> Yeah, and it'll be harder to mentally parse.  I'm representing an arbitrary height/width tic-toe board as a list of lists
19:49:04 <elliotbay> +tac
19:49:52 <elliotbay> It's really only arbitrary h/w because I didn't like how messy things were turning out with a tuple
19:54:43 <mib_qy9raf> hey .. compiliing ghc stopped with a Setup: haddock version >=0.6 is required but it could not be found.
19:54:49 <zambonegro>  Tired of them sheiitskined negros and their generalmonkeyshines?  Join us at http://www.chimpout.com !!!  Thats right!!!Chimpout.com is nniiigger hating central.  We are not white supremacists......but people of all races that hate nigggeers and aren't nigggeeers.  Join us in the humanistic alliance against the little simians!  http://www.chimpout.com
19:54:52 <mib_qy9raf> afaik, haddock is required for docs ..
19:55:00 <chessguy> @undo do { x <- foo; y <- bar; f x y }
19:55:01 <lambdabot> foo >>= \ x -> bar >>= \ y -> f x y
19:55:12 --- mode: ChanServ set +o Saizan
19:55:17 --- mode: Saizan set +b *!*=zamboneg@*.sd.sd.cox.net
19:55:17 --- kick: zambonegro was kicked by Saizan (Saizan)
19:55:23 <chessguy> @pl foo >>= \ x -> bar >>= \ y -> f x y
19:55:23 <lambdabot> (bar >>=) . f =<< foo
19:55:33 --- mode: Saizan set -o Saizan
19:55:49 <mib_qy9raf> so I am wondering how I can remove the doc compile target ?
19:56:44 <mib_qy9raf> I don't want to do make clean
19:57:40 <Gracenotes> case True of { ... } is probably not a good idea, I should think?
19:58:50 <elliotbay> You won't find disagreement here
19:59:23 <Gracenotes> the purpose being to emulate guards where there's no function definition.. ahm. great
19:59:27 <chessguy> @pl p f (a, b) = (f a, f b)
19:59:27 <lambdabot> p = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
20:01:45 <chessguy> wchogg:  you around?
20:05:05 <Saizan> Gracenotes: i've seen case () of _ | for that
20:05:32 <Saizan> note that you can also use guards in let
20:05:53 <chessguy> @pl f x y = c (s x) (s y)
20:05:54 <lambdabot> f = (. s) . c . s
20:06:08 <Saizan> > let x | 1 <= 4 = "foo" | otherwise = "bar" in x
20:06:10 <lambdabot>   "foo"
20:06:24 <harblcat> how many people use vim to program haskell?
20:06:32 <Gracenotes> ah
20:06:45 <ddarius> Approximately half the people who program in Haskell (and are reasonably active in the community)
20:06:46 <dolio> c `on` s
20:07:35 <chessguy> ddarius: half? i'm just curious, what do you base that on?
20:07:42 <chessguy> dolio:  i thought it was something like that
20:07:47 <chessguy> @src on
20:07:47 <lambdabot> (*) `on` f = \x y -> f x * f y
20:08:02 <nek> @src show
20:08:03 <lambdabot> show x = shows x ""
20:08:23 <mib_qy9raf> is it because they are old timers or are the new fangled editors particularly sucky for haskell ?
20:08:41 <ddarius> chessguy: There was a survey years ago and of the people that responded about half used vim, the other half used emacs and there were a smattering of other editors.  Since then I haven't noticed any trend toward any other editor.
20:09:10 <flippo> It seems about time for someone to implement an IDE entirely in haskell.
20:09:11 <nek> wondering how a generic derived show works..
20:09:11 <Cale> mib_qy9raf: Almost everyone likes either vim or emacs.
20:09:12 <chessguy> ddarius:  sounds logical to me. i guess for some reason i expected the smattering to be bigger
20:09:25 <chessguy> flippo:  yeah, join the crowd
20:09:27 <sleven> how would Haskell do for large-scale parallell scientific computing?
20:09:33 <sleven> is hackage down?
20:09:44 <ddarius> chessguy: It probably is bigger now than then.
20:09:46 <chessguy> @faq can Haskell do large-scale parallell scientific computing?
20:09:46 <lambdabot> The answer is: Yes! Haskell can do that.
20:09:57 <flippo> smart bot
20:10:00 <Cale> sleven: It's quickly moving in that direction
20:11:05 <nek> how does it know and convert the constructor (the identifier) to the literal string for something like data Foo = Foo x deriving (Show) ?
20:11:30 <Cale> nek: It generates code which does that.
20:11:40 <sleven> is hackage down?
20:11:49 <Saizan> sleven: not for me
20:11:54 <Cale> The implementation of show which it constructs from the data declaration includes a literal string.
20:12:27 <benl23> @faq can Haskell solve the halting problem?
20:12:27 <lambdabot> The answer is: Yes! Haskell can do that.
20:12:30 <benl23> hmm
20:12:58 <mib_qy9raf> @faq will you ever halt ?
20:12:59 <lambdabot> The answer is: Yes! Haskell can do that.
20:13:09 <mmorrow> looks like it halted to me
20:13:11 <mib_qy9raf> ohh ... might need some work
20:13:13 <mib_qy9raf> :D
20:14:35 <benl23> @faq can the Haskell community ever admit that Haskell is not the right tool for some tasks?
20:14:35 <lambdabot> The answer is: Yes! Haskell can do that.
20:14:39 <benl23> horray for that
20:14:52 <nek> Cale, is that done in the compiler?  IOW, can i implement something like that (ie. generating code) using pure haskell as a normal class?
20:15:30 <pumpkin> benl23: why do you ask?
20:15:30 <ddarius> > gshow [1,2,3]
20:15:32 <lambdabot>   /tmp/8776398311826288757:70:44: Not in scope: `gshow'
20:15:40 <benl23> :) just curious
20:15:45 <sleven> why doesnt cabal isntall come with haskell? i have cabal but i cant do cabal at the prompt
20:15:47 <pumpkin> benl23: the haskell community seems a lot more open to other languages than others, honestly
20:15:48 <ddarius> > Data.Generics.gshow [1,3,5]
20:15:50 <lambdabot>   /tmp/3446462019623831454:70:44: Not in scope: `Data.Generics.gshow'
20:16:20 <mak__> sleven: cabal-install isn't Cabal
20:16:26 <ddarius> @hoogle gshow
20:16:27 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
20:16:36 <ddarius> > Data.Generics.Text.gshow [1,2,4]
20:16:38 <lambdabot>   /tmp/843032898967049284:70:44:
20:16:38 <lambdabot>      Not in scope: `Data.Generics.Text.gshow'
20:16:50 <ddarius> Curse you, bot!
20:17:06 <twb> http://hpaste.org/13933 I don't understand this GHC error
20:17:20 <CakeProphet> > curse = fail "epic" in curse
20:17:21 <lambdabot>   <no location info>: parse error on input `='
20:17:29 <CakeProphet> > let curse = fail "epic" in curse
20:17:30 <lambdabot>       No instance for (Show (m a))
20:17:30 <lambdabot>        arising from a use of `show' at <in...
20:18:42 <Cale> nek: It's done by the compiler.
20:19:05 <Cale> nek: If you were writing such a function by hand, you would write the string literals yourself.
20:25:47 <nek> i see.
20:25:54 <nek> Cale,  thanks =)
20:36:35 <bombshelter13> Wow... Haskell is ridiculously concice... I've had essentially the same code go from ten pages of perl to three pages of scheme to less than a page of haskell.
20:36:42 <bombshelter13> concise, that is.
20:36:58 <pumpkin> just you wait
20:37:01 <pumpkin> it'll get even shorter!
20:37:23 <bombshelter13> probably will, as my skills improve. :)
20:37:32 <pumpkin> haskell gets leaner with time, as you find more super duper abstractions with funky operators
20:38:35 <Saizan> ?type on
20:38:37 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:38:56 <pumpkin> that's one I've just recently started using
20:38:59 <pumpkin> enjoying it a lot :)
20:39:02 <Saizan> twb: the use of `on` forces xs and ys to be of the same type
20:39:37 <dons> had anyone seen this, http://www.math.chalmers.se/~koen/ParserComboC/parser-combo-c.html
20:40:00 <elliotbay> I'm almost positive some of the functions I'm writing are already abstracted in the Prelude
20:40:00 <aluink> http://hpaste.org/13934, i'm not understanding the syntax of that case, what's going on?
20:40:45 <pumpkin> dons: lol
20:41:05 <pumpkin> that is surprisingly elegant for c, but still remarkably ugly :P
20:41:11 <dons> koen's a smart cookie
20:41:23 <jeffz`> dons, a year or two ago, might have seen it on reddit somewhere
20:41:50 <aluink> nm, had someone here look over my shoulder...didn't say anything, just the effect of him looking and it clicked...what a good friend!
20:43:18 <pumpkin> omg that code is insecure
20:43:20 <pumpkin> me overflows it
20:43:25 <dons> aluink: we had a toy stuffed bear at my university help desk for that purpose :)
20:43:28 <pumpkin> (the c parser)
20:43:36 <dons> you were supposed to explain your problem to the bear first.
20:43:46 <dons> then if you still didnt know the answer, explain it to the help desk guy
20:44:09 <dons> surprisingly effective
20:45:39 <pumpkin> how is the c parser supposed to return an AST or other information to its caller?
20:45:57 <pumpkin> seems like it'd make it a lot less elegant
20:45:59 <twb> 15:41 <Saizan> twb: the use of `on` forces xs and ys to be of the same type
20:46:01 <twb> Saizan: thanks
20:49:44 <dolio> pumpkin: You use out parameters, apparently.
20:53:28 <dolio> I think the real question is: why bother doing this in C?
20:55:12 <harovali> a where is a closure?
20:56:47 * wli guesstimates he'd be better off with Givens rotations for the square part and a Householder reflection to annihilate the remainder of the longer border.
20:57:54 <Elly> dons: around here, we call that "cardboard dogging"
20:58:33 * wli thinks it's possible to annihilate unequal pairs of opposing off-diagonal elements with Givens rotations, but isn't entirely sure.
21:03:43 <sleven> im tyring to insall hmatrix
21:03:47 <sleven> why do i need al that
21:03:53 <sleven> http://www.hmatrix.googlepages.com/installation
21:04:20 <sleven> one of the problems of hackage seems to be that all packages are so dependant one ach other
21:04:33 <byorgey> uh... code reuse is a good thing, right?
21:04:42 <byorgey> cabal-install handles all the dependencies for you, anyway.
21:04:43 <sleven> great when I had cabal isnlal that figure dit out but sometimes even cabal can and then your kind of f***ed
21:04:55 <byorgey> once you've installed it once, you don't have to worry about dependencies ever again.
21:05:00 <sleven> yes
21:05:19 <sleven> sometimes it still doesnt work, ive tried hmatrixfor agaes without success on both ubuntu and windwos
21:06:08 <byorgey> sleven: well, if you're running into a particular error, why not say what it is? someone might have a suggestion.
21:06:09 * wli has mostly been trying to write linear algebra stuff from scratch in pure Haskell without success.
21:06:37 * wli notes how sad a statement that is regarding how drastically his programming abilities have declined.
21:08:02 <mmorrow> what is "success" here, efficiency, correctness, or elegance (or some combo thereof)?
21:10:04 <wli> I seem to fail on all three counts.
21:10:39 <mmorrow> if it's efficiency, it'd be way cool to somehow spit a bunch of mmx and/or sse code out from haskell. e.g. generating this would be easy (sbahra's code): http://moonpatio.com/repos/sbahra-mmxsse2/mmx/mmx.S
21:11:25 <mmorrow> run http://moonpatio.com/repos/sbahra-mmxsse2/mmx/benchmark_mmx.c and immediately come the realization that on x86(32) the fact that ghc isn't using mmx instrs is a huge loss
21:11:33 * wli only cares about polymorphism in the number field so that algebraic number fields, multiple precision arithmetic, etc. are possible.
21:11:40 <sleven> http://linux.tcs.inf.tu-dresden.de/~voigt/ft/ <- doesnt work
21:11:42 <sleven> anyway
21:12:02 <sleven> hmatrix, at leats the following dependancies are smissing "storable-complex -any"
21:12:34 <Olathe> > let 'f = 5 in 'f
21:12:36 <lambdabot>   <no location info>:
21:12:36 <lambdabot>      lexical error in string/character literal at chara...
21:12:55 <mmorrow> sleven: so wget that and install it
21:13:11 <mmorrow> or use cabal install
21:13:15 <Saizan> sleven: that's why you should use cabal-install
21:13:51 <sleven> it's "runhaskell setup configure" then install then build?
21:14:15 <Saizan> that's the "manual" installation procedure
21:14:20 <mmorrow> ghc --make Setup.*hs; ./Setup configure && ./Setup build && sudo ./Setup install
21:14:33 <Saizan> that requires you to install the dependencies by hand
21:14:40 <mmorrow> pretty haddocks with
21:14:40 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
21:14:46 <Saizan> ?hackage cabal-install
21:14:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
21:15:29 <Saizan> with that installed ^^^ you can just run "cabal install hmatrix" and it'll install the haskell dependencies for you
21:15:59 <dibblego> is there a function \c f -> if c then f c else c ?
21:16:27 <wli> I think there's something the bots have called if' which is related.
21:16:28 <sleven> it seems being on windows is the problem.
21:16:30 <wli> @type if'
21:16:32 <lambdabot> Not in scope: `if''
21:16:37 <dibblego> yes I could do it with if'
21:16:39 <mmorrow> @let bool f _ False = f; bool _ t True = t {-this is nice-}
21:16:40 <sleven> Saizan: on windows too?
21:16:42 <lambdabot>  Defined.
21:16:46 <wli> Maybe it's only for results of @pl
21:16:50 <mmorrow> oh this one too
21:16:55 <Saizan> sleven: yes
21:17:12 <mmorrow> @let b ? (t,f) = if b then t else f
21:17:15 <lambdabot>  Defined.
21:17:20 <Saizan> sleven: but note that hmatrix depends on some C libraries, that might be hard to install on windows
21:17:50 <wli> There's left and right for Either, which is quick and dirty.
21:18:06 <sleven> and hen it starts
21:18:16 <wli> Not to mention maybe and fmap on Maybe.
21:18:22 <sleven> to isntall cabal isntall u need more libs and for those libs u need even more
21:18:28 <Saizan> sleven: no
21:18:30 <mmorrow> \c f -> bool c (f c) c
21:18:38 <Saizan> sleven: you need only 3 libs for cabal-install
21:18:40 <mmorrow> c ? (c, f c)
21:19:04 <mmorrow> sleven: are you drunk?
21:19:12 <mmorrow> ;)
21:21:52 <pumpkin> sleven: not only that, but cabal-install has a bootstrap.sh that even grabs the dependencies for you
21:22:44 <Saizan> pumpkin: not on windows :)
21:22:50 <pumpkin> fair enough :P
21:23:05 <steshaw> @pl listToString xs = concat (intersperse ", " (map show (xs)))
21:23:06 <lambdabot> listToString = join . intersperse ", " . map show
21:23:28 <steshaw> Cannot anyone tell me where the 'join' function comes from?
21:23:33 <sleven> does install come before build?
21:23:39 <Olathe> @index join
21:23:39 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:23:47 <sleven> runhaskell setup configure then build or install?
21:23:54 <dancor> i want to do a bunch of "(pullOffPart, mainPart') = scan f mainPart" and have "(concat pullOffParts, finalMainPart)" at the end.  what is good way to do this, State Monad, or my own Monad?
21:23:59 <jeffz`> sleven: if you haven't built anything, what do you propose to install?
21:24:04 <steshaw> Olathe: thanks :)
21:24:14 <Olathe> You're welcome.
21:24:44 <pumpkin> steshaw: isn't concat . intersperse intercalate?
21:24:44 <steshaw> I am just using 'concat' now but the @pl plugin says to use 'join' but it wasn't in the prelude ...
21:25:00 <pumpkin> @src intercalate
21:25:00 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:25:20 <sleven> how do I run command as admin on windows? i eman the eq of sudo
21:25:22 <steshaw> Yes, when I did my own point free conversion I used concat
21:25:40 <steshaw> However, the point free form required me to add a type annotation
21:25:50 * wli wishes for some infix thingie e.g. (###) so f ### g = left f . right g
21:26:09 <dancor> steshaw: join is more general (join is concat for the List Monad).  if your stuff is List specific then concat is probably clearer imho
21:26:49 <Saizan> ?type (+++)
21:26:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
21:27:00 <Saizan> wli: ^^^
21:27:15 <steshaw> dancor: ok
21:28:03 <dancor> @pl concat
21:28:04 <lambdabot> join
21:28:16 <dancor> pl just does that to save some characters?
21:28:48 <wli> Saizan: Doh, it was my stupidity all along.
21:28:57 <dancor> @pl concat :: [[a]] -> [a]
21:28:58 <lambdabot> (line 1, column 17):
21:28:58 <lambdabot> unexpected ">" or "-"
21:28:58 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
21:29:22 * wli is at a loss to see uses of arrows other than (->) floating around.
21:29:54 <wli> Or, for that matter, to be able to read Arrow lib types well enough to figure out what the (->) arrow will really do.
21:30:42 <dancor> there are only three useful Monads and one useful Arrow ;)
21:31:01 * wli ponders what the list monad would look like with cantor as join.
21:31:12 <Saizan> yeah, they would be nicer to read if they used "~>" instead of "a"
21:31:12 <dancor> anyone saying otherwise is a categoric onanist
21:31:45 <newsham> List, IO and ?
21:31:46 <wli> We've got monad and arrow libraries; how long before there's a hyperdoctrine lib?
21:31:50 <newsham> Cont?
21:31:53 <wli> Maybe?
21:32:12 <Saizan> we have plenty of useful monads
21:32:18 <newsham> if you had to choose one monad: http://sigfpe.blogspot.com/2008/12/mother-of-all-monads.html
21:32:31 <newsham> sigfpe brilliance
21:33:20 <wli> MonadRWSContListMaybeSTIO?
21:34:05 <wli> Monads aren't all that in and of themselves; it's monad transformers that are the real dirt.
21:34:37 <dmwit> ?hoogle (a -> IO Bool) -> [a] -> IO ([a], [a])
21:34:38 <lambdabot> No results found
21:34:51 <pumpkin> :o
21:34:57 <wli> Rolling one's own monad transformers is where it's at.
21:35:02 <pumpkin> dmead: an IO partition?
21:35:12 <dmwit> partitionM
21:35:21 <dmwit> It needn't be so specific as IO. ;-)
21:35:34 <Gracenotes> liftM?
21:35:43 <dmwit> Not quite...
21:35:56 <dmwit> Since the argument is in the monad already.
21:35:58 <pumpkin> dmwit: does it exist, or would you like it to?
21:36:00 <jberryman> can anyone think of a Monad instance for: STree a = Tree a (STree a) (STree a) | End   ?
21:36:00 <jberryman> just interested because so many list functions can be easily raised to a 2d version for that tree type
21:36:09 <dmwit> Anyway, it's easy to write, I was just hoping it was in the libraries somewhere.
21:36:56 <dmwit> jberryman: Certainly; you can do basically the same thing as the list monad, I think.
21:37:12 <wli> Hmm, partitionEithers ended up being the name for my classify :: [Either t t'] -> ([t],[t'])
21:39:36 <Saizan> jberryman: you've to decide how to merge (STree b,Stree b,Stree b) into Stree b, for (>>=)
21:40:50 <sleven> permission denied
21:40:50 <sleven> where does runhaskell setup isntall install?
21:40:54 <sleven> do i need a C:/program files/haskell/ ?
21:41:20 <Saizan> if you configure with --user it'll install in an user-specific directory
21:41:46 <Raynes> It installed into C:/ for me.
21:41:53 * wli can't figure out a natural join operation.
21:42:18 <jberryman> right, the equivalent seems to be to replace the Ends of the tree with a bunch of copies of the Tree below... if that makes sens
21:42:51 <sleven> how do I run as admin in vista?
21:43:15 <wli> Expression trees and substitution monads usually operate by hooking the nested expression trees in where the variable names would go, and then just eliding the variable name constructor to join.
21:43:32 <Saizan> yeah
21:43:41 <Saizan> but here 'a' is in the wrong place
21:45:53 <wli> data Expr t = Var t | Add (Expr t) (Expr t) | ... ; instance Monad Expr where Var x >>= f = f x ; Add x y >>= f = liftM2 Add (f x) (f y) or some such.
21:46:59 <wli> jberryman: So a better bet would be a tree structure whose data is hung entirely off the leaves.
21:47:08 <ztirf_> do I need to do anything special to get command-line ghc to link with cabal-installed packages?
21:47:15 <Saizan> Add x y >>= f = liftM2 Add (f =<< x) (f =<< y)
21:47:28 <jberryman> btw, that tree does make a very useful comonad instance I'm finding
21:47:50 <Saizan> ztirf_: no, but you need to pass --make to make it link at all
21:48:26 <wli> data TipTree t = Tip t | Branch (TipTree t) (TipTree t) ; instance Monad TipTree where Tip x >>= f = f x ; Branch x y >>= f = liftM2 Branch (x >>= f) (y >>= f)
21:48:33 <ztirf_> ah, let me try that flag
21:49:11 <ztirf_> awesome, thanks
21:49:38 <Saizan> jberryman: without End
21:49:49 <Saizan> jberryman: that's an instance of the "cofree comonad"
21:49:58 <Saizan> newtype Cofree f a = Cofree { runCofree :: (a, f (Cofree f a)) }
21:50:40 <jberryman> wli: that is the only tree definition that seems to come up in example haskell code (conveniently) but how do I make a binary search tree with that (the object of my module)?
21:52:01 <ztirf_> can one define it recursively
21:52:08 <newsham> > let f xs = foldr (>>>) id (map (either (first.(:)) (second.(:))) xs) ([],[]) in f [Left 'c', Left 'a', Right 1, Right 2, Left 'r']
21:52:10 <lambdabot>   ("rac",[2,1])
21:52:52 <ztirf_> ah I see - the nodes contain no entries
21:59:47 <wli> jberryman: It's because it most conveniently fits the Monad model. AIUI what you need is an ordering-conscious merging function, which doesn't work for Monad.
22:00:05 <wli> jberryman: Basically the same reason Map etc. can't be instances of Monad.
22:00:37 <wli> I'm off.
22:02:17 <jberryma1> wli: thanks a lot. got disconnected and was checking the logs
22:17:28 <kniu> hey guys
22:21:47 <kniu> you know how people keep on making new languages for the JVM and microsoft's CLR?
22:21:53 <MichaelGG> yea
22:21:58 <kniu> how hard is it to do the same for GHC?
22:22:18 <kniu> Haskell has a buncha libraries to take advantage of, and GHC does some pretty impressive optimization.
22:22:23 <MichaelGG> ghc's a runtime platform?
22:22:31 <kniu> It isn't; I know.
22:22:57 <kniu> but how hard would converting it to one or taking on something anyway be?
22:24:37 <MichaelGG> ask on haskell cafe :)
22:25:09 <MichaelGG> sounds like a pretty big deal to switch to a full shared VM isnt it/
22:26:54 <Raynes> That sounds... Weird.
22:27:12 <kniu> Raynes, what do you mean?
22:27:19 <Raynes> It just sounds weird.
22:27:50 <Raynes> Like he said, ask on the Haskell mailing list.
22:27:55 <kmeyer> kniu: make a C compiler target haskell :D
22:28:38 <ddarius> That would be easier than you might expect.
22:28:49 <kmeyer> efficiently?
22:28:50 <kniu> wrap every statement in the IO monad.
22:28:56 <kmeyer> kniu: efficient--
22:29:17 <kniu> use unsafePerformIO/unsafeCoerce everywhere.
22:29:19 <ddarius> Probably reasonably efficiently.
22:29:33 <kniu> ..use the C FFI.
22:29:37 <kniu> YO DAWG
22:29:57 <kmeyer> kniu: whoah, you're at CMU?
22:30:04 <kniu> aye.
22:30:08 * kmeyer has a buddy there
22:30:30 <dibblego> is liftM2 mplus in the standard libraries?
22:30:44 <ddarius> :t liftM2 mplus
22:30:46 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
22:30:48 <ddarius> No.
22:30:56 <dibblego> k
22:34:45 <hydo> My google-fu is failing me.  Do you guys know of any tutorial or otherwise that explains what you have to package to redistribute a haskell binary?  Assuming same os/processor/etc. of course.
22:35:21 <hydo> I guess I could ldd an executable on a linux box or something to find out. :P nevermind... didn't think of that.
22:40:24 <ddarius> @wiki How to make a Haskell program
22:40:25 <lambdabot> http://www.haskell.org/haskellwiki/How_to_make_a_Haskell_program
22:41:31 <blackh1> ddarius: 1. write 'main =', 2. scratch head, ...
22:42:52 <ddarius> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
22:43:09 <ddarius> Damn, if I had gone with "write" like I was thinking I would have nailed it.
22:43:46 <nanothief> I have a list of filepaths, (ie [FilePath]), and want to split them into two lists, one with dirs and one without, ie ([String],[Stirng]). partition and doesDirectoryExist would do it, but I can't figure out to combine them
22:44:14 <nanothief> can I do it with those two functions, or do I need to write my own partition like function?
22:50:29 <jeffz`> "Use Darcs unless you have a specific reason not to. It's much more powerful than most competing systems (and it's written in Haskell)."
22:50:33 <jeffz`> that's rather strong
22:51:32 <Nafai> That probably is less true now than it was at the time the wiki page was first written
22:51:43 <Nafai> (except for the written in haskell part)
22:52:13 <sjanssen> jeffz`: darcs has massive marketshare in the Haskell world
22:52:34 <sjanssen> if you want to encourage contributions from other Haskell hackers, darcs is probably best
22:53:02 <vegai> darcs was pretty good to start with, and recently it started getting better
22:53:36 <MechaBlue> Darcs is great until it isn't.  Then it really isn't.
22:53:40 <jeffz`> sjanssen: can I add those two statements to that paragraph on the wiki?
22:53:50 <kmeyer> eh, I'm only familiar with git :S
22:53:51 <sjanssen> jeffz`: absolutely
22:54:34 <sjanssen> kmeyer: do you hack on lots of Haskell projects?
22:54:50 <kmeyer> no :D
22:54:55 * kmeyer is a newbie
22:54:59 <sjanssen> well, there you go :)
22:57:23 <intoverflow> MechaBlue: what are some of the issues with darcs?  I've only used it for tiny projects
22:57:57 * hydo should read up on it... if there's a compelling reason to move from git, i'd use it.
22:58:50 <MechaBlue> intoverflow: I'm mostly grousing.  The biggest problem that occurs is when two versions of a repository are merged and there are conflicts.
22:59:12 <intoverflow> ah yes, a very classic problem
22:59:32 <sjanssen> MechaBlue: that's mostly better with darcs 2 and the hashed repository format
22:59:42 <MechaBlue> I killed a merge after 6 hours of waiting and did it by hand in 20 minutes.
23:00:37 <MechaBlue> sjanssen: That's what I've heard and I look forward to seeing it being more widely adopted.
23:01:08 <sjanssen> MechaBlue: yeah, I haven't had a chance to use it on many repositories either
23:01:29 <sjanssen> not many have switched over, since the new format isn't backwards compatibility
23:01:40 <sjanssen> s/ility/le
23:06:43 <blackh1> I'm eating dinner. buy.;-):)
23:09:57 <MechaBlue> Soon!  Soon I shall be done!  Muahaha!
23:11:00 <joma> where does cabal want to create a directory when i do runhaskell setup install?
23:11:00 <joma> in the same dir?
23:11:00 <joma> because i get permission denied(retarded windows)
23:11:45 <MechaBlue> It will probably be trying to install in common folders.  Are you using Vista?
23:13:50 <MechaBlue> If so, you'll need to execute the command as an admin.  I think there is also a flag to tell it to install to user directories (--user ?)
23:13:51 <Demettry> Hi every1! Need some help, that's appreciated!
23:13:51 <Demettry> I have type Tsttype = [ (Double, Double, Double) ] and a function Tstfun :: Tsttype -> Double
23:13:51 <Demettry> But GHC says "Invalid type signature" on function declaration. What's wrong? I just can't see anything (((
23:14:06 <jeffz`> joma, did you try using --user like someone suggested last time you asked?
23:15:21 <Demettry> do I need to import some module that's responsible for tuples??
23:16:19 <level1> hi, I was looking at programming langauge benchmarks last week and I thought saw that for some algorithms haskell was significantly faster than C.  I can't seem to find the webpage anymore.  Is that true or is it just my imagination?
23:16:21 <Demettry> GHC says "invalid type declaration" even on Tstfun :: [ (Double, Double, Double) ] -> Double
23:16:51 <MechaBlue> Functions must start with a lowercase letter
23:17:08 <MechaBlue> tstFun :: Tsttype -> Double
23:17:15 <MechaBlue> That should work
23:17:43 <Demettry> Arghhhh.... I'm such and idiot )))
23:17:55 <koeien> no, not really; it's not obvious that this is the case
23:17:56 <Demettry> MechaBlue: Thanx
23:18:01 <koeien> few languages have this property
23:18:08 <Demettry> It works now
23:18:14 <level1> koeien: talking to me?
23:18:15 <MechaBlue> Sweet
23:18:19 <koeien> no, Demettry
23:19:14 <Demettry> MechaBlue: I called my function QBFtoSAT, so it didn't work =) Probably I had to sleep at least a little bit in the last 22 hours =)
23:19:42 <MechaBlue> Demettry: That would definitely do it ;)
23:19:45 <koeien> level1: http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=gcc  has a few
23:20:55 <koeien> level1: there are a few instances here where ghc is faster than gcc
23:22:42 <koeien> but i don't think the shootout is very useful. it's just an indication
23:24:26 <level1> koeien: well, it seems like the haskell can only beat C when multithreading in involved.  I'm a Java programmer, not a Haskell person, so I'm not an expert, but it seems like this is simply a lucky break: C uses threads poorly
23:24:33 <level1> koeien: am I wrong?
23:24:54 <baaba> lucky break?
23:25:03 <koeien> my impression is that you can only beat C when you write ugly haskell code =) if you look at the entries
23:25:18 <koeien> whereas the C is always ugly
23:25:22 <MechaBlue> level1: C doesn't really use threads poorly.  It's just a lot harder to use them well.
23:25:22 <vegai> the multithreading C programs seem to use pthreads and mutexes
23:25:38 <level1> koeien: you mean do brutally optimize the haskell code?
23:25:42 <koeien> level1: yes
23:25:54 <koeien> but it is possible to get near-C performance
23:25:55 <vegai> also, the ghc programs don't seem to be compiled with -threaded
23:26:04 <vegai> oops, scratch that. They are, actually
23:27:14 <level1> since haskell is functional it can transparently multithread an application, right?  this should provide some big benefits
23:27:29 <sjanssen> level1: threads aren't the only place Haskell can win
23:28:02 <koeien> level1: in theory. in practice you don't want to spawn threads for trivial cases
23:28:05 <vegai> level1: the compiler isn't smart enough (and perhaps can never be) to realize when it's a good idea to branch
23:28:16 <vegai> branch/fork
23:28:59 <vegai> perhaps if forking became supercheap by advances in CPUs and the os, it might make sense to always fork
23:29:09 <sjanssen> Haskell is about writing code at a high level, while C is at lower levels.  A sufficiently smart compiler can sometimes do amazing optimizations on high level code, but not on low level code
23:29:37 <koeien> in theory this is true
23:29:49 <level1> I'm writing the proposal for a research paper.  It would be nice if I had at least a little evidence that haskell can be faster than C because it the haskell compiler sees the problem in a fundamentally different way... I want to see if I can identify the improvements by analyzing the output of the compilers and some other ways
23:30:08 <level1> koeien: how come the sun java compiler never beats C then?
23:30:09 <vegai> level1: haskell will never be faster than well-written C
23:30:12 <sjanssen> for example, GHC will turn "map f . map g" into "map (f . g)".  It is much harder to do this when the maps are for loops operating on a mutable array
23:30:18 <vegai> level1: and Java will neither
23:30:22 <MechaBlue> level1: Have you looked into lazy evaluation and thunks?
23:30:43 <level1> MechaBlue: I've forgotton what thunks are.  I understand lazy evaluation pretty well
23:30:56 <sjanssen> koeien: it is true in practice, especially with the qualifier "sometimes"
23:31:41 <koeien> level1: probably because of run-time stuff that needs to be checked? i don't know. maybe start-up time of the bytecode interpreter. java is getting pretty good in terms of performance
23:31:42 <MechaBlue> level1: Thunks are just the way that lazy evaluation is implemented in GHC.  That model lends itself to a lot of interesting possibilities.  STM was one of those.
23:31:46 <vegai> but average Haskell/Java/python code can easily be faster than average C code
23:32:05 <MechaBlue> Actually, Java can beat out C.
23:32:21 <vegai> sure, if the C code is horrible :)
23:32:31 <koeien> level1: were you referring to http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance
23:32:41 <MechaBlue> Java can do something called "aggressive inlining", which C can't
23:32:45 * mauke considers writing a malloc in haskell
23:33:03 <level1> MechaBlue: actually, the sun java compiler almost never does
23:33:15 <peachi> where is fromJust defined? I'm using hugs and it just says "undefined variable"... I thought it was in the prelude?
23:33:23 <mauke> @index fromJust
23:33:23 <lambdabot> Data.Maybe
23:33:30 <sjanssen> peachi: it isn't in the Prelude.  See Data.Maybe
23:33:41 <peachi> thanks >_<
23:33:49 <peachi> so I do: import Maybe
23:33:50 <peachi> ?
23:33:57 <mauke> import Data.Maybe
23:34:04 <sjanssen> peachi: import Maybe will work, but Data.Maybe is preferred
23:34:10 <mauke> or :also Data.Maybe if you're in hugs
23:34:23 <peachi> thanks guys
23:35:07 <mauke> someone should write a program called kisses
23:35:09 <level1> thanks everyone!
23:35:10 <sjanssen> vegai: I'm not sure that your state "haskell will never be faster than well-written C" is true
23:35:36 <MechaBlue> Haskell will never be faster than optimally written C?
23:35:48 <sjanssen> vegai: we're eventually going to reach the point where C's machine model doesn't apply any more
23:36:07 <gmh33> MechaBlue: can humans write optimal C code?
23:36:22 <sjanssen> where things like pointer aliasing are going to cripple C optimizers
23:36:25 <koeien> can humans write optimal Haskell?
23:36:41 <koeien> gmh33: compiler writer employment theorem?
23:36:53 <level1> theoretically, you could just write the output of a haskell compiler in assembly inlined into the C compiler
23:36:54 <ddarius> @hoogle malloc
23:36:55 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
23:36:56 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
23:36:56 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
23:37:01 <koeien> if you assume that humans are no more powerful than machines
23:37:02 <MechaBlue> gmh33: That's where the real value of Haskell is.  However, the issue still stands.
23:37:43 <ddarius> level1: Assembly does not translate into C.
23:38:05 <sjanssen> level1: I don't think inline assembly truly counts as C code
23:38:09 <level1> haha
23:38:31 <gmh33> koeien / MechaBlue: just saying that Human C code and Optimum C code are not the same, also, there's more room for machine optimization of languages (like Haskell) than there is for C, etc, etc.
23:38:33 <level1> for any given assembly code, I'd bet you could write an equivelent C program
23:38:55 <koeien> yes, of course. also an equivalent Haskell program
23:39:07 <koeien> it's just harder to do "reasonably"
23:39:21 <MechaBlue> level1: Is performance a constraint?  If not, you could rewrite any assembly program in XSL.
23:39:29 <dons> this is a great read from a serious ocaml programmer, http://www.reddit.com/r/haskell/comments/7pus9/random_thoughts_on_haskell/
23:39:34 <gmh33> level1: most CPUs have machine instructions for overflow detection, etc, semantics for which are not included in ansi-C
23:39:39 <level1> MechaBlue: I love XSL
23:39:47 <level1> MechaBlue: and actually its fairly fast
23:39:52 <ddarius> level1: There is quite a lot of assembly that doesn't translate into C which why so many language implementors dread targeting C.
23:40:22 <gmh33> C is kind of a LCD of assembly languages
23:40:48 <dmwit> liquid crystal display?
23:40:53 <dmwit> ;-)
23:41:12 <level1> least common denomenator
23:41:12 <ddarius> gmh33: If only.
23:42:34 <koeien> dons: interesting. i can sympathise with the idea of not calling everything 'monoid'/'functor'/'monad'
23:42:47 <koeien> although i don't have a problem with it
23:42:52 <mornfall> gmh33: It has awful lot of cruft for that role. Cf. C--.
23:43:51 * ddarius can verify that you can travel hundreds of miles in west Texas and not really go anywhere.
23:43:53 <gmh33> mornfall: I understand, but just pointing out C doesn't have (any?) features which can't be easily translated directly into machine code on most (all?) platforms
23:44:06 <dons> ddarius: :)
23:44:14 <dons> brian lives in manhattan.
23:44:36 <mornfall> gmh33: Depends on your definition of "easily". I guess. : - ]
23:44:55 <mornfall> gmh33: The other day, I read that Apple ]['s CPU didn't do multiplication.
23:45:37 * ddarius thinks people just like using the word "heterodyne" regardless of appropriateness.
23:45:57 <ddarius> mornfall: 'lots of processors that don't do floating point arithmetic.
23:47:28 <p_l> in fact, C was designed and used on one
23:47:48 <mornfall> : - )
23:47:54 <mornfall> ddarius: Good point.
23:48:30 <dons> ddarius: did you see the commenter at the end? "Haskell feels like a much clearer, more pure vision of something that Iâve seen hints of in other tools that Iâve used in the past (XSLT, some of jQuery, closures in groovy, blocks in ruby, dependency injection, etc)."
23:48:43 <ddarius> dons: Haven't finished reading it yet.
23:48:56 <ddarius> Incidentally, "monoid" isn't a term from category theory.
23:49:26 <koeien> true. it's algebra, but it sounds scary =)
23:49:56 * vixey is terrified of math
23:50:17 * p_l needs to relearn his math
23:50:40 * koeien has an examination about stochastic processes in 5 hours =)
23:50:49 <koeien> talk about scary
23:51:21 <vixey> Warning: Do not feed the math
23:52:20 <p_l> I consider Psychology scarier. At least Math doesn't make you diagnose yourself with various disorders...
23:52:51 <vixey> how come everyone studies phychology these days?..
23:53:16 <p_l> vixey: Cause it's quite a broad _experimental_ science?
23:53:28 <dons> ok. time for more good news...
23:53:29 <dons>  http://haskell.forkio.com/dotnet
23:53:50 <vixey> ah .NET my favorite thing..
23:53:55 <dons> a full Haskell <-> .NET interop
23:54:00 <peachi> hey, our lecturer hinted that our haskell exam today would involve implementing a graph algorithm for DAGs that can be written nicely in relativity few lines (5 or 6 or so)
23:54:05 <peachi> any ideas heh
23:54:09 <ddarius> dons: Re the comment, the commentor has seen shreds of FP (in particular HOFs) and Haskell is undeniably a "much clearer, more pure vision" of FP than any of the things he's listed.
23:54:11 <dons> its crazy how much is happening now. every hour something is getting announced
23:54:18 <p_l> vixey: In my case, as CS&AI freshman, I've got Introductory Psychology as rather important subject
23:54:19 <dons> ddarius: exactly.
23:54:24 <peachi> considering this is *not* particularly advanced haskell
23:54:24 <kmeyer> anyone know of a good reference for, say, making a C api to pure haskell functions?
23:54:30 <dons> and he saw all the way through.
23:54:39 <dons> kmeyer: ah, the wiki has a page.
23:54:43 <kmeyer> cool
23:54:45 <kmeyer> any idea which page?
23:54:52 <dons> sure, i wrote it.
23:54:59 <dons> so its this one, http://haskell.org/haskellwiki/Calling_Haskell_from_C
23:55:02 <ddarius> kmeyer: Or just read the FFI spec.  It's quite readable.
23:55:07 <ddarius> @where ffi
23:55:07 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
23:55:30 <kmeyer> dons: thanks
23:55:38 <dons> busy times, vixey, busy times.
23:56:07 <peachi> anyone? :/
23:56:21 <vixey> peachi, couldn't figure out what you were asking
23:56:30 <dons> peachi: something with lists i guess.
23:56:33 <koeien> peachi: maybe DFS or BFS
23:56:48 <peachi> hmm
23:56:52 <dons> it wasn't really a question you asked.
23:57:10 <peachi> I've searched for DFS and BFS with haskell but I can't find any simple examples of an implementation
23:57:22 <vixey> peachi, so try to implement it
23:57:25 <koeien> try it=)
23:57:28 <koeien> it's a nice exercise.
23:58:04 <koeien> the only real problem i see is how you would represent your graph. normally you would do this using a set of vertices + nodes, but in haskell you might want to do this inductively
23:58:10 <koeien> ehm, s/nodes/edges
23:58:18 <peachi> well I don't exactly understand the explanaton of the DFS algorithm on wikipedia :s
23:58:41 <koeien> you never had an intro graphs or algorithms course?
23:58:47 <dons> well, an inductive defn. is a bit non-trivial, imo. you could just use vertices and nodes. the FGL lib gives an inductive graph library
23:59:05 <peachi> koelen, nope, he just said there's an extra credit question that is to do with a graph algorithm
23:59:13 <peachi> and so i'm just having a look now
23:59:17 <vixey> peachi, a look at what??
23:59:28 <peachi> some graph algorithms heh
23:59:42 <peachi> I understand wikipedia's explanation of topological sort
23:59:52 <peachi> but not DFS or BFS
