00:00:06 <int80_h> so I have the basic form, but I don't know how to get it to loop, just overflow
00:00:14 <int80_h> myCycle x = foldr(++) x [x]
00:00:27 <inv> I wrote a small parser
00:00:45 <inv> but it is too slow on simple string
00:00:52 <inv> is it possible to optimize it ?
00:01:07 <inv> I have removed all from it, here it is:
00:01:07 <inv> http://paste.factorcode.org/paste?id=375
00:01:16 <pumpkin> , scanU (+) 0 (toU [1..5])
00:01:17 <lunabot>  toU [0.0,1.0,3.0,6.0,10.0]
00:01:21 <inv> only one function is here
00:01:21 <pumpkin> is that normal?
00:01:34 <int80_h> I either get "infinite type" errors. or it overflows
00:01:37 <inv> question: is it possible to optimize it ?
00:01:54 <pumpkin> inv: use bytestrings
00:02:07 <pumpkin> inv: or don't use !!, at least
00:02:12 <int80_h> pumpkin: any clues?
00:02:21 <inv> I don't want to use any external library
00:02:30 <pumpkin> inv: then don't use !!
00:02:30 <mmorrow> rwbarton: well i can catch that in the haskell reference interp i have, but for some reason it's an issue in a C interp (maybe). i actually forgot that my interp handles that. ghci barfs, and helium's lvm interp has an ominous comment to the effect of "let x = x in x can loop here. fixme??"
00:02:36 <int80_h> inv is like me :)
00:02:37 <rwbarton> mmorrow: Raise is the <<loop>> exception I guess?
00:02:41 <mmorrow> rwbarton: now i'm even more confused
00:02:43 <vegai> int80_h: I would've also suggested you use parsec :)
00:02:47 <pumpkin> int80_h: you want to write cycle with a foldr?
00:02:52 <mmorrow> rwbarton: exactly. that "-1" is a blackhole exception
00:02:54 <vegai> agh, s/int80_8/inv/ again
00:03:11 <mmorrow> (currently there's just one kind of exception..)
00:03:20 <int80_h> pumpkin: well, with a fold. I think folr is the easiest way to go
00:03:20 <pumpkin> is it normal that scanlU returns one fewer element than scanl?
00:03:38 <inv> vagai, we use parsec in a project, but I'd like very simple and fast parser
00:03:58 <inv> ok, so !! is a problem
00:04:05 <mmorrow> rwbarton: if you're interested, the relevant spec is http://serv1.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.81.7841
00:04:07 <inv> will try to fix it now, thank you
00:04:31 <mmorrow> rwbarton: it's actually a (reasonably) quick read, and extremely enlightening
00:05:21 <mmorrow> and it gives the gist of how the STG machine works too, and how certain things about the lvm are improvements over it
00:05:46 <kiris> yay liskell compiled. needs to be put on hackage some day..
00:06:27 <int80_h> liskell? a lisp written in haskell?
00:06:30 <mmorrow> kiris: ooh, cool
00:06:37 <vegai> int80_h: a haskell with lisp syntax, rather
00:06:39 <mmorrow> kiris: you've gotta paste some samples :)
00:06:45 <kiris> int80_h: a layer over GHC for sexpressions using the GHC api
00:06:54 <kiris> mmorrow: I guarantee it
00:06:58 <int80_h> kiris: sweet!
00:07:04 <kiris> int80_h: with macros n' shit
00:07:05 <kiris> @go liskell
00:07:08 <lambdabot> http://liskell.org/
00:07:08 <lambdabot> Title: About Liskell
00:07:48 <kiris> site's kind of out of date, his blog was like a week or two ago though: http://blog.clemens.endorphin.org/2009/01/liskell-standalone.html
00:09:05 <int80_h> pumpkin: still there?
00:09:21 <pumpkin> sorry, engrossed in documentation :P
00:09:44 <int80_h> is :P a toungue sticking out? I've never figured that one out
00:10:53 <kiris> it originally meant tongue in cheek but now it means some kind of smile
00:11:24 <vegai> hmm, I have something like this: outgoing <- (actOnMessage input) relayExceptionToFront
00:11:40 <vegai> no, actually: outgoing <- handle (actOnMessage input) relayExceptionToFront
00:11:50 <int80_h> ahhh
00:11:53 <vegai> an exception that "handle" should handle there is raised after this line
00:12:00 <vegai> is laziness biting me, perhaps?
00:12:22 <vegai> or are exceptions broken in ghc-6.10?
00:12:28 <pumpkin> int80_h: why write it in terms of a fold?
00:12:38 <pumpkin> and not just a recursive let?
00:12:43 <pumpkin> @src cycle
00:12:44 <lambdabot> cycle [] = undefined
00:12:44 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:13:02 <kiris> parseResponse :: String -> Maybe HSBCReply
00:13:03 <kiris> parseResponse xml = do
00:13:03 <kiris>   dom <- parseXMLDoc xml
00:13:03 <kiris>   el <- findElement (qname "TransactionStatus") dom
00:13:06 <kiris>   parseReply $ strContent el
00:13:09 <kiris> hells yeah I love the maybe monad
00:13:43 <inv> heh
00:13:48 <inv> thank for the help
00:14:03 <inv> without !! it works 100 times faster :)
00:14:08 <pumpkin> yay
00:14:14 <mmorrow> rwbarton: i just realized how/where ghci inserts the "ghci is in an IO do-block" support code. it must be added during bytecode generation from Core.
00:14:50 <vegai> hmh. I wish Haskell wasn't lazy by default ;/
00:14:55 <pumpkin> vegai: why?
00:14:58 <kiris> hahaha
00:15:09 <vegai> ok, that was a bit of a troll. Sorry.
00:15:22 <vegai> it just seems to be the only thing I suffer from in this great language
00:15:48 <pumpkin> just curious :) wasn't planning on calling you out for trolling
00:16:05 <vegai> pumpkin: my exceptions are thrown weirdly, and I suspect it might be due to laziness
00:16:14 <kiris> X learns Haskell. X complains about fundamental feature of Haskell
00:16:16 <pumpkin> :o
00:16:16 <vegai> and I suppose that's even worse. I'm not sure if it's laziness
00:16:24 <hydrapheetz> laziness is gre--*zzzzzzz*
00:16:43 <kiris> laziness is, uh, I'll tell you later
00:17:05 <vegai> kiris: I suggest you write something real in Haskell and then check back at me :-P
00:17:22 <vegai> ok, that was even worse. Sorry again.
00:17:34 <kiris> vegai: I have ! 6_g
00:17:50 <jethr0> > "laziness is gre" ++ undefined ++ "eat"
00:17:52 <lambdabot>   "laziness is gre* Exception: Prelude.undefined
00:17:55 <kiris> vegai: http://productsforhair.co.uk/
00:18:17 <int80_h> pumpkin: because that's the exercise
00:18:28 <int80_h> pumpkin: I'm working out of RWH
00:18:28 <pumpkin> ah
00:18:53 <vegai> kiris: what's that on?
00:19:11 <kiris> vegai: haskell cgi
00:19:19 <int80_h> while also fantisizing about writing a Haskell interface to lpc mun libs
00:19:21 <int80_h> mud
00:19:41 <pumpkin> > let x = foldr (\x y -> x:y) x [1,2,3] in x
00:19:46 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
00:19:58 <pumpkin> actually
00:20:06 <pumpkin> > let x = foldr (:) x [1,2,3] in x
00:20:07 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
00:20:09 <int80_h> I meant lpmud. mpc is the scripting language for lpnud, which I never liked. haskell would make a better scripting language.
00:20:29 <int80_h> ugh, no lambda's yet
00:20:49 <pumpkin> that's not a lambda
00:20:50 <pumpkin> just a let
00:20:54 <int80_h> ah that's it, but I was hoping for a think through, not an answer
00:21:00 <pumpkin> oh
00:21:02 <pumpkin> I'm sorry :/
00:21:25 <inv> found another problem
00:21:26 <inv> http://paste.factorcode.org/paste?id=376
00:21:31 <int80_h> pumpkin: well that's not quite right anyway
00:21:35 <inv> it fails with stack error
00:21:37 <mmorrow> rwbarton: this is interesting: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=890#a895
00:21:53 <inv> is pp2 function tail-recursive or not ?
00:22:05 <int80_h> [1,2,3] should be replacable by any arbitrary list
00:22:15 <pumpkin> int80_h: it is
00:22:36 <int80_h> where I can do myCycle [foo]
00:22:43 <inv> lambdabot: @tail recursive
00:22:44 <lambdabot> Consider it noted.
00:22:52 <int80_h> or rather myCycle 'foo"
00:23:00 <int80_h> erm "foo"
00:23:13 <rwbarton> mmorrow: the "what is this stuff" is just let x = x in x
00:23:22 <recursive> hello
00:23:22 <lambdabot> recursive: You have 1 new message. '/msg lambdabot @messages' to read it.
00:23:26 <recursive> @messages
00:23:26 <lambdabot> inv said 42s ago:
00:23:28 <rwbarton> it has a value on the stack, duplicates it, throws away the old one, and enters it again
00:23:39 <int80_h> oh well, I will try and forget the answer and try and get a think through tomorrow
00:23:42 <mmorrow> rwbarton: interesting. i wonder why
00:24:01 <pumpkin> int80_h: well it isn't fully general yet, so there's still stuff to do :)
00:24:14 <inv> it's a recursive! why doesn't it work
00:24:28 <mmorrow> rwbarton: i think this is a clear case of missed optimization
00:24:46 <mmorrow> or rather, not-even-attempted optimization ;)
00:24:52 <rwbarton> why those three lines aren't just ENTER?
00:25:26 <mmorrow> or even, why are they there at all?
00:25:53 <int80_h> pumpkin: thanks :)
00:26:13 <mmorrow> also, the ghci byecode doesn't seem to be blackholing at all
00:28:43 <pumpkin> @seen dons
00:28:43 <lambdabot> dons is in #arch-haskell, #haskell, #xmonad, #darcs, #concatenative and #ghc. I last heard dons speak 6h 14m 14s ago.
00:31:45 <mmorrow> rwbarton: err, to clarify  i meant why is that entire new BCO being pushed (or even exist) at all?
00:33:51 <rwbarton> that's the BCO that's running while the evaluation of let x = x in x is looping
00:34:22 <pumpkin> , zipU (toU [1]) (toU [1..10])
00:34:23 <lunabot>  toU [1.0 :*: 1.0]
00:34:38 <pumpkin> , zipU (toU [1..10]) (toU [1])
00:34:40 <lunabot>  toU [1.0 :*: 1.0,2.0 :*: 4.3168913395e-314,3.0 :*: -3.2494673059599182e-4...
00:34:45 <rwbarton> we have x at the top of the stack to evaluate, we duplicate it and throw it away (for some reason), then enter it
00:34:48 <rwbarton> x = x
00:35:02 <vegai> fancy. Even seq (length str) str won't make my exception handler handle it
00:35:32 <vegai> I guess it's time to start trying to make a failing test case out of all this
00:36:07 <mmorrow> the lvm code just pushes the /same/ code twice rather than duplicate it. notice also that the STG code is MkAp'ing _2_ vals from the stack (one of which is this new BCO) instead of the lvm's PackAp 1. i'm not sure exactly what this means in term of anything yet though
00:36:10 <pumpkin> , replicateEachU 1 (toU [100000]) (toU [5])
00:36:11 <lunabot>  Killed.
00:36:13 <pumpkin> :P
00:36:49 <mmorrow> rwbarton: but then it's weird, because the STG code is also pushing 0 twice, so it seems the STG code is pushing that new BCO for no apparent reason
00:37:00 <pumpkin> , replicateEachU 1 (toU [10000]) (toU [5])
00:37:01 <lunabot>  toU [5.0,-2.4414284458537163e-55,9.350925523306327e-266,-3.38678197325890...
00:37:08 <pumpkin> , replicateEachU 1 (toU [100000]) (toU [5])
00:37:09 <lunabot>  luna: internal error: allocGroup: free list corrupted
00:37:15 <pumpkin> there we go
00:37:29 <mmorrow> heh
00:37:57 <pumpkin> , "you there?"
00:37:59 <lunabot>  "you there?"
00:38:01 <pumpkin> yay :)
00:38:11 <pumpkin> just one of the subprocesses died?
00:38:30 <mmorrow> <rwbarton> we have x at the top of the stack to evaluate, we duplicate it and throw it away (for some reason), then enter it
00:38:32 <mmorrow> totally
00:38:44 <pumpkin> I wonder how exploitable something like that is
00:38:47 <pumpkin> the UArr is unboxed
00:39:00 <mmorrow> i think maybe that makes it not able to tell it's entering a blackhole because it's a new copy of the same node rather than the original (?)
00:39:40 <mmorrow> pumpkin: every expression spawns the "luna" executable fresh
00:39:45 <pumpkin> I see :)
00:39:46 <mmorrow> and the bot talks to it over a pipe
00:39:59 <pumpkin> still, could I use that to make the luna executable do bad things, I wonder
00:40:11 <pumpkin> sounds like more work than it's worth, either way
00:40:21 <mmorrow> pumpkin: $10 bounty on my /etc/passwd ;)
00:40:24 <pumpkin> lol
00:40:39 <vegai> ok, I managed to nnarrow it down. Perhaps you'll see now what I'm screwing up:
00:41:11 <vegai> http://paste.factorcode.org/paste?id=377
00:41:30 <vegai> why isn't myHandler handling the exception, and is there a way to make it handle it?
00:44:37 <vegai> perhaps I should go to haskell-cafe with this...
00:45:08 <pumpkin> does anyone know if consU and snocU are O(n)? I'd expect them to be
00:45:32 <vegai> hmm, in that case it seems to be enough to just strictness annotate the 'b' in the test function
00:45:41 <pumpkin> assuming the array isn't fused
00:45:46 <vegai> I'm not sure if I can do the equivalent in my real code, though
00:46:07 <vegai> shouldn't the exception handler still handle it, laziness or not?
00:46:48 <mmorrow> rwbarton: i think this is the relevant 50-line snippet from ByteCodeGen.lhs http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=890#a897
00:47:06 <mmorrow> "-- General case for let.  Generates correct, if inefficient, code in
00:47:06 <mmorrow> -- all situations."
00:47:31 <mmorrow> ah!
00:47:34 <mmorrow> i think i found it
00:47:39 <mmorrow> "-- ToDo: don't build thunks for things with no free variables"
00:48:01 <cads> Velociraptors, I'm very glad you joined the channel tonight, because i have a question, and it would be normally inappropriate for this channel.
00:48:19 <mmorrow> rwbarton: just highlighted it
00:48:42 <cads> Between a town taken over by zombies, and a lab where velociraptors have been set loose, where would you guys rather find yourselves?
00:48:56 <mmorrow> zombies for sure
00:49:54 <cads> more people say zombies
00:50:26 <mmorrow> at least you have a chance against a zombie
00:50:57 <pumpkin> boo, I can't write anything about UArr itself in the documentation because haddock can't output docs for associated types
00:51:07 <vegai> Ok, I found the correct place to add the strictness annotation. Thanks for you help, everyone :-)
00:51:17 <pumpkin> vegai: you're very welcome! ;)
00:51:18 <cads> i can't stand the philosphical implications of zombies, I'd take my chances with the raptors and hope I had a grenade launcher or something
00:51:47 <mmorrow> and while both may eat you while you're still alive, you'll probably have ample time to off yerself with the zombies should the situation become dire. velociraptors are speedy however.
00:52:26 <cads> I think raptors would be a swifter death
00:52:39 <arw> hm. the usual zombie is slow and not too intelligent. so greater chances of survival.
00:52:53 * Velociraptors are also zombies.
00:55:07 <cads> I feel with a town of zombies you'd have no safe haven, and it would be a matter of you getting tired of off guard. It feels like a longer more grueling encounter, your dead friends coming after you could have quite the psychological impact.
00:55:46 <cads> Whereas with the raptors you're probably trained in what to do in case of raptor containment breach, and all you really have to do is survive till you get the hell out of there
00:56:19 <cads> I dunno, fucking raptors, they'd toy with you
00:58:51 <Adamant> cads: slow zombies are easier to deal with than fast zombies
00:59:10 <Adamant> when zombies are both fast and semi-intelligent again, then raptors are beat hands-down
00:59:22 <cads> Given a tiling of the plane with equilateral triangles, and a line segment drawn between two arbitrary points on the plane, may we easily calculate the number of triangle cells that the segment crosses over?
01:00:03 <cads> Adamant, I am legend made it so I couldn't stand in the perfect dark if i was stoned, for a couple months :D
01:00:12 <Adamant> ow
01:00:33 <Adamant> great book turned into a average Holywood blockbuster
01:01:15 <cads> I can only imagine the impact of the book, but the visual impact of those zombies was really something
01:01:50 <cads> and I call them zombies from a philosophical sense, realizing that there was nothing supernatural or undead about them
01:01:57 <Adamant> cads: the book is much scarier in a way
01:02:29 <Adamant> well, there can be science-based zombies, it's part of the genre
01:03:11 <cads> one thing I wondered about that is whether those altered humans could survive in the long term (and why they didn't eat each other - maybe the beginnings of culture? or just instinct)
01:03:36 <Adamant> the write, Mathieson, is one of the all time horror greats because he realized you didn't need the supernatural to scare.
01:03:42 <Adamant> *writer
01:03:42 <cads> would they regain sentience and language and culture after generations of living with the virus
01:03:56 <Adamant> cads: that's something the book picks up.
01:04:23 <soa2ii> Hi there! Maybe a weird question but can someone here show me (doesn't matter what) a piece of clean and tidy haskell code? I would like to see what Haskell looks like from "real" programmers instead of my stuff I got from university :S
01:04:42 <cads> it was a good movie but i sensed missing depth
01:07:00 <cads> soa2ii: I don't know about a small snippet that would show that, but there are lots of projects with source available, say from hackage
01:07:42 <p_l> Adamant: There is another version of the ending, which is true to the original story. However, they got "average Americans" for prescreening and they didn't like the original ending, so they replaced it :/
01:09:24 <cads> soa2ii: do you know calculus?
01:09:29 <Adamant> p_l: it's sort of true to the original story, not entirely
01:09:42 <hiredman> I remember reading an electronic copy of the book on my glowing computer screen in an otherwise dark room
01:09:46 <hiredman> really creappy
01:09:49 <hiredman> creepy
01:10:21 <cads> oh man
01:10:29 <soa2ii> cads: No... I do not know much about haskell... and honestly I'm really happy if this lecture is over... Haskell seems to be nice... but not with this professor...
01:10:37 <p_l> Adamant: Still, according to my second hand sources, the original ending and theatrical one are completely different :-)
01:10:46 <cads> hiredman, just you saying that made me close my laptop screen and adjust my eyes to the dark for a moment
01:10:52 <p_l> soa2ii: I wish I had Haskell for my CS course
01:11:32 <soa2ii> p_l: Well... minds are different :S For me smth like Java/C++ is much better :P
01:11:48 <cads> soa2ii: a shitty lecturer can suck, even if you could easily learn the subject with self-study
01:12:12 <p_l> soa2ii: Not when end-of-term exam consists of playing with java.awt to draw a stupid matrix of flags
01:12:36 <soa2ii> p_l: lol... where do you do that? :D
01:13:02 <Axman6> anyone know of some nice blogging software that can be made to display haskell, and ins't wordpress? i'm sick of the bullshit i have to go through every time i try and set it up
01:13:12 <soa2ii> I think two nested for-loops and some drawing is not that hard ;)
01:13:17 <cads> i was going to suggest this paper about automatic differentiation and how it may be implemented in haskell. It corresponds to an existing library which is documented pretty well by the paper itself, and might be a good example of a useful working haskell code
01:13:42 <Adamant> p_l: you can see the original/second ending on Youtube
01:14:26 <p_l> soa2ii: first half year of CS @ University of Aberdeen. We've got quite good AI group, but "Foundations of Computing Science" is... well, worse than my first year High School when it comes to CS :>
01:14:43 <pumpkin> > df (dVar x)
01:14:45 <lambdabot>   1~~
01:15:08 <soa2ii> p_l: :P I have to cope with that here...
01:15:09 <soa2ii> http://rafb.net/p/Tp8YOG60.html
01:15:35 <soa2ii> We're trying to build a compiler... and I don't have an idea what to do :S
01:15:50 <hiredman> lucky bastard
01:17:02 <cads> could we apply 'don't repeat yourself' to not have all those copies of deriving?
01:17:06 <soa2ii> If you've neder worked with haskell before... then you get about 500 lines ugly formatted code.... and no idea :/
01:17:06 <p_l> soa2ii: looks like a nice assignment :) (except for comments in German ;-) )
01:17:36 <soa2ii> p_l: The comments are from my prof... we just have to fill smth in...
01:17:46 <soa2ii> There are some english things from myself :P
01:18:27 <cads> god, haskell code can be so opaque
01:18:42 <soa2ii> cads: What do you mean?
01:19:43 <soa2ii> IMHO (don't know if you could it better) this code is not suitable for haskell beginners...
01:19:46 <pumpkin> cads: like http://is.gd/9NaD ?
01:19:50 <soa2ii> I see just ... "letters"
01:19:57 <cads> that file is formated in a bunch of fat dense boxes of text
01:20:29 <pumpkin> yeah, it isn't the prettiest haskell I've ever seen
01:21:09 <soa2ii> So IMHO the lecture stuff is hard enough... you have no odea about haskell and then you have to get throught _that_ code... :S
01:22:31 <pumpkin> presumably the hard enough lecture is supposed to teach you about that code?
01:23:10 <soa2ii> pumpkin: No. About the things this code should do.
01:23:28 <cads> soa2ii: it'll depend on how serious you are about it. If the lecture gives all that without the prerequisites then you might have to work hard to catch up on your own
01:24:21 * cads remembers taking heavy integral calculus based physics while at the same time only just taking differential calculus
01:24:37 <cads> ... that was a nightmare
01:25:18 <cads> none of what I had to know for physics would be covered in calc untill next semester
01:27:25 <soa2ii> cads: I know that... tried to do physics next to cs first...
01:27:30 * arw remembers all his physics lectures beeing half calc lectures because calc was 2 semesters behind (and never got to the advanced stuff)
01:27:35 <soa2ii> But then I figured out cs is enogh ;)
01:28:03 <cads> soa2ii:  I think you can do it, but you'll need to supplement yourself with a hard and fast source of knowledge, like you might have to resort to schaum's outlines in a class where both the professor and the textbook are longwinded and senile
01:28:51 <soa2ii> cads: Sorry... my english is not good enough to understand that... but it sounds ironic :P
01:30:00 <cads> No, I mean to say, in the end it is your responsibility to learn the material that you wished for the class to teach you, even if the professor or the textbook cannot
01:31:24 <soa2ii> cads: Of course.
01:31:26 * p_l resolves to copy-pasting code from previous assignment to finish today's exam...
01:31:46 <cads> p_l, you teach?
01:32:43 <p_l> cads: No, I'm taught. And that is even sadder considering the kind of stuff I've got for assignments :)
01:32:44 <cads> sounds like you're composing an exam
01:32:50 <cads> ah
01:32:54 <cads> java/
01:32:56 <cads> ?>
01:32:56 <lambdabot> Maybe you meant: . ? @ v
01:33:00 <cads> hehe
01:33:13 <p_l> there's some Haskell in of the courses available for 4th year students... but not earlier
01:33:40 <joga> I'm pretty ignorant with haskell atm but the code soa2ii pasted looks to me like some graphics app translated from java to haskell :)
01:34:26 <joga> judging from the commented blocks too, if all you gotta do is fill in those with haskell, it's probably doable if you just spend a couple of days examining it
01:34:39 <soa2ii> joed: Well... it should compile my parsed MGPL source so I could play pong and invaders...
01:34:54 <cads> nice
01:34:55 <soa2ii> I don't have a clue how my prof got that code...
01:35:15 <soa2ii> joed: sry, I meant joga
01:37:04 <soa2ii> The worst on that lecture is: The hard thing to me is haskell :/ I understand what I have to do there and I could do those stuff in java without problems I think :P
01:37:28 <BrokenClockwork> @src @
01:37:29 <lambdabot> Source not found. That's something I cannot allow to happen.
01:37:36 <BrokenClockwork> @src '@'
01:37:37 <soa2ii> Well... now I whined enough... have to finish this somehow until monday :S
01:37:37 <lambdabot> Source not found. stty: unknown mode: doofus
01:38:49 <joga> soa2ii, I suppose you've read some of the introductions to haskell on the net?
01:39:11 <soa2ii> joga: Yes a little... why?
01:39:47 <cads> soa2ii:  it could b worse: http://www.haskell.org/pipermail/haskell/2004-August/014387.html
01:40:09 <joga> I just feel haskell can be learned pretty fast, I'm just a newbie though :)
01:41:18 <cads> i'd agree with joga, soa2ii, Don't Panic!
01:41:39 <mauke> > cycle "oh god "
01:41:41 <lambdabot>   "oh god oh god oh god oh god oh god oh god oh god oh god oh god oh god oh g...
01:41:58 <cads> Hah!
01:42:09 <soa2ii> cads: Yeah... haskell itself is not that hard if you start on your own and know what to do... but if you get 500 lines of weired code and no idea... :S
01:42:19 <cads> then you panic.
01:42:52 <cads> I'm saying not to panic, you can learn enough to make that code not so wierd
01:43:05 <soa2ii> Til monday? :P
01:43:10 <joga> good way to start is reading about haskell syntax, after you understand how to read the code it's obviously more easy to interpret it ;)
01:44:22 <BrokenClockwork> Is there a more efficience way to code faculty as with recursion: = n * fac (n-1) ?
01:44:55 <Axman6> BrokenClockwork: use an accumulating parameter?
01:45:05 <cads> BrokenClockwork: you can code it to take advantage of tail recursion so that it could execute in constant space
01:45:19 <cads> .. what axman said
01:45:29 <BrokenClockwork> ok, thanks I will take a look on that :)
01:45:32 <joga> BrokenClockwork, http://www.willamette.edu/~fruehr/haskell/evolution.html ;)
01:45:52 <BrokenClockwork> ah I saw this, this is nice ^^
01:46:32 <Axman6> BrokenClockwork: fac n | n < 2 = 1 | otherwise = fac' n 1 where fac; 0 x = x; fac; n x = fac' (n-1) $! (n*x)
01:47:24 <Cale> Is factorial actually called faculty in some languages, or is that just a common error?
01:47:42 <mauke> Fakult√§t in German
01:47:59 <mauke> ah, and a .de hostmask
01:48:00 <cads> you guys, can we suggest some terse and quick yet comprehensive haskell guides for soa2ii? His code starts with declaring a bunch of data types, does anything start out right with that?
01:48:24 <BrokenClockwork> yeah I found faculty and factorial when translating it
01:48:29 <BrokenClockwork> :P
01:48:59 <soa2ii> cads: I think I know what those datatypes do... or what do you mean? (:
01:50:02 <soa2ii> joga: Your fuculty page makes me sad :P
01:50:26 <cads> i've always imagined a system by which one could understand the semantics of any language, wherein one would click any term that is not understood and it would be expanded into simpler terms which could in turn be expanded
01:50:54 <mauke> until at the end you get simple machine instructions, which are trivial
01:51:12 <cads> In my dreams the expansions turn into informative english dialog, heh
01:51:27 <soa2ii> :P
01:51:55 <mauke> ooh, or brainfuck
01:52:18 <cads> so that essentialy all you'd need to do to get your own custom language tutorial would be to click through all the interesting bits of an existing program
01:52:32 <soa2ii> cads: Well... you have to maintain both... but if you code java with eclipse for example you'll get the documentation to each functions with mouse hover ;)
01:52:39 <cads> mauke, malbolge would definitely be better
01:52:46 <mauke> malbolge is too complicated
01:52:55 <mauke> brainfuck is even simpler than machine code
01:53:12 <soa2ii> whitespaces is even simpler than brainfuck ;)
01:53:13 <cads> I thought bf was a sick joke?
01:53:21 <soa2ii> cads: No.
01:53:24 <mauke> soa2ii: no
01:53:40 <soa2ii> mauke: Really?
01:53:46 <mauke> I've written a whitespace interpreter, and it's a lot more complicated
01:54:05 <mmorrow> mauke: what the two -sentence summary of whitespace?
01:54:18 <mauke> it has a stack, random access memory, bigints, etc.
01:54:46 <mmorrow> so you have `elem` "\n\r\f " ?
01:55:05 <mmorrow> \t
01:55:16 <p_l> cads: sick joke is DeCSS written in Brainfuck running on brainfuck vm coded in TECO which runs on TECO emulation inside GNU Emacs.
01:55:16 <mauke> see http://mauke.ath.cx/stuff/whitespace/ :-)
01:55:24 <mmorrow> sweets
01:55:51 <beelsebob> mauke: your C is almost as understandable as whitespace
01:56:03 <mauke> what!
01:56:09 <mmorrow> oh sweet
01:56:13 <mauke> my C is totally sweet
01:56:35 <mmorrow> argh! the tabs hurt my eyes!!@#
01:56:43 <mmorrow> ;)
01:56:47 <mauke> :set ts=4
01:57:00 <beelsebob> :set ban-tabs=true
01:57:02 <cads> mauke, your code makes my tummy hurt.
01:57:05 <mmorrow> :set ts=2
01:57:06 <mmorrow> !!
01:57:14 <Raevel> are arrays by convention indexed from 1 upwards? why not start at 0 as with lists?
01:57:21 <mauke> mmorrow: see? everyone gets what they want :-)
01:57:31 <mauke> cads: where?
01:57:42 <mmorrow> i like the (splay?) tree in a single macro though :)
01:58:01 <mauke> mmorrow: C programmer's templates :-)
01:58:08 <mmorrow> hehe
01:58:27 <cads> Raevel: with arrays you give whatever range of indices you want when you construct them, if my understanding is correct. So you make choose 0-indexed or 1-indexed arrays
01:58:28 <Axman6> mauke: you need to lay off the crack man
01:59:01 <Raevel> cads: that's true, i was wondering if either was preferred and why
02:01:52 <cads> in a lot of computer science literature I see 0 indexed arrays and sequences and whatnot, and in a lot of math I see 1 indexed sequences, but then you have lots of things like polynomials or sequences of derivatives for which the zeroth order is important and notations of such are usually zero indexed
02:03:06 <Raevel> true
02:03:18 <mmorrow> lol
02:03:22 <Raevel> i suppose that answers my question :-)
02:03:43 <mmorrow> "Whitespace is a particularly useful language for spies. Imagine you have a top secret program that you don't want anyone to see. What do you do? Simply print it out and delete the file, ready to type in at a later date. Nobody will know that your blank piece of paper is actually vital computer code!"
02:04:06 <cads> it should depend on whether the zeroth element is actually associated with zero in some way, IMO, or if the first element is just the first, and you'd like the nth element of a n element array to be the last one
02:04:15 <mmorrow> @remember whitespace Nobody will know that your blank piece of paper is actually vital computer code!
02:04:15 <lambdabot> Done.
02:04:30 <mmorrow> http://compsoc.dur.ac.uk/whitespace/
02:04:41 <Raevel> i'm programming piet
02:05:03 <BrokenClockwork> I am looking forward to a function, which extracts me from a number its digits, for instance 123 -> [1,2,3]
02:05:08 <BrokenClockwork> or a tuple
02:05:12 <BrokenClockwork> (1,2,3)
02:05:33 <Raevel> BrokenClockwork: if there are arbitrarily many digits you can't return a tuple
02:05:42 <Taejo> @hoogle Char -> Int
02:05:42 <lambdabot> Data.Char digitToInt :: Char -> Int
02:05:42 <lambdabot> Data.Char ord :: Char -> Int
02:05:42 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
02:05:54 <Taejo> map digitToInt (show 123)
02:05:57 <mauke> > map digitToInt . show $ 123
02:05:58 <lambdabot>   [1,2,3]
02:06:08 <Taejo> :t map digitToInt . show
02:06:09 <lambdabot> forall a. (Show a) => a -> [Int]
02:06:14 <mauke> :t unfoldr
02:06:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:06:37 <Raevel> i just realized i've never used unfoldr
02:07:21 <mauke> > unfoldr (\n -> if n == 0 then Nothing else let (q,r) = n `quotRem` 10 in Just (intToDigit r, q)) 123
02:07:22 <lambdabot>   "321"
02:07:32 <mauke> > unfoldr (\n -> if n == 0 then Nothing else let (q,r) = n `quotRem` 10 in Just (r, q)) 123
02:07:34 <lambdabot>   [3,2,1]
02:07:45 <cads> forget catamorphisms and hylomorphisms
02:07:59 <cads> what's fun are hickey-morpisms
02:08:19 * cads is gonna do a few on his baby later today
02:08:41 <ziman> unfoldr is ana- ?
02:09:26 <ac> please excuse me for asking this repeatedly, but does anybody around happen to have some experience with the hsc3 library?
02:19:46 <Raevel> I want my cabal package to compile with -Wall, can i make this happen in my .cabal somehow?
02:21:35 <InkBottle1> Hi, I'm looking for documentation on how to wirite bindings to C libraries
02:21:53 <mauke> @where ffi
02:21:53 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
02:22:07 <Raevel> real world haskell has a chapter about it as well
02:22:36 <InkBottle1> thanks
02:23:49 <BrokenClockwork> if I want to convert an Integer input to an Int type, I use fromIntegral?
02:23:53 <Raevel> oh, i foound the GHC-Options flag now
02:24:06 <mauke> BrokenClockwork: yes, or fromInteger
02:24:24 <BrokenClockwork> that's the same?
02:24:50 <mauke> if the source type is Integer, yes
02:26:05 <BrokenClockwork> and what's the reverse function?
02:26:09 <BrokenClockwork> Int -> Integer?
02:26:15 <mauke> fromIntegral
02:26:16 <Saizan> fromIntegral
02:26:21 <Saizan> ?type fromIntegral
02:26:22 <lambdabot> forall a b. (Num b, Integral a) => a -> b
02:26:29 <Saizan> it's quite general
02:27:10 <Saizan> the other conversion functions are round/truncate/floor/ceiling and realToFrac
02:27:27 <mauke> and the big hammer, toEnum . fromEnum
02:29:36 <doserj> and fromRational
02:29:52 <BrokenClockwork> ah ok
02:39:01 <Gracenotes> oh, wow... parsing the lambda calculus is so much easier if you analyze the tokens going /backwards/ in a parenthetical expression
02:39:25 <mauke> huh?
02:40:08 <Gracenotes> "\a. b c d \e f g". start with g, then (f g), then \e. (f g), then d (\e. (f g)), etc.
02:40:32 <Gracenotes> which can be done recursively, of course
02:40:41 <mauke> how do you parse the b c d part?
02:40:55 <mauke> because (d (c d)) would be wrong
02:41:15 <Peaker> Gracenotes: why is it easier to have "g" convert to "(f g)" than to have "f" convert to "(f g)"?
02:41:17 <augustss> Gracenotes: parsing lambda calculus is easy going forward too
02:41:43 <Gracenotes> (c d) (\e. (f g)), ((b c) d) (\e. (f g))... hm
02:42:08 <Gracenotes> yeah, it might get a little complex :/
02:42:11 <augustss> it's many1 atomExp
02:42:27 <Gracenotes> indeed, the last few hours have been filled with many semi-failed parsing ideas
02:42:59 <Gracenotes> well, that helps. It's just that writing it in an imperative language feels so weird :/
02:43:15 <augustss> Gracenotes: do it with parsec first
02:43:55 * Gracenotes hasn't used parsec yet
02:44:05 <Gracenotes> I'll try to see if I can get this working in it, though
02:44:28 <Gracenotes> how does parsec deal with nested structures?
02:44:38 <mauke> beautifully
02:45:17 <mauke> expr = char '(' *> expr <* char ')'  -- useless example
02:46:27 <Gracenotes> which JavaScript, I'm making two passes -- one to tokenize (\f. (\g. (\h. h g)) (\x. (\z. x)) (\y. y f) (\u. u) -> ['\f', ['\g', ['\h', 'h', 'g']], ['x.', ['\z', 'x']], ['\y', 'y', 'f'], ['\u', 'u']]), another to build the AST
02:46:49 <Gracenotes> not like it matters terribly much, but is it possible to do it with one with parsec?
02:47:29 <mauke> yes
02:47:38 <mauke> it's also possible to do it with one pass in javascript
02:48:06 <Gracenotes> probably is :/
02:48:18 <asgaroth> Speaking of parsec: Do I always have to define an Applicative instance for GenParser myself to use applicative style?
02:48:20 <mauke> everything is possible with enough regexes
02:48:44 <Gracenotes> yeah, I haven't used regexes in forever :)
02:49:05 <Gracenotes> at least not with programming languages (other than bash)
02:49:05 <Peaker> Gracenotes: lucky you
02:49:19 <Gracenotes> I grep and sed to my heart's content all the time
02:50:47 <mauke> http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/examples/calc.pk - if you could read the code, it might even help you :-)
02:53:44 <jeffz`> I don't understand cabal, cabal configure, cabal build work ok, they build an executable, when I say cabal install, it attempts to recompile and complains that a function isn't exported.
02:55:16 <jeffz`> http://jeffz.name/onex/ is the cabal project
03:04:02 <Gracenotes> argh. Corecursion time, I think... >_>
03:34:57 <mmorrow> here's a pretty graphviz-rendered graph illustrating the tricolor abstraction from garbage collection http://moonpatio.com/images/tricolor.png
03:35:53 <BONUS> mmorrow: nice. got the code for that?
03:35:56 <mmorrow> well, not illustrating the process of garbage collection with it, but showing the possible ptrs from object classified as diff colors to other objects
03:36:02 <mmorrow> BONUS: yes, one sec
03:41:04 <mmorrow> BONUS: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=898#a899
03:41:39 <BONUS> ah cool :] cheerio
03:42:06 <mmorrow> :)
03:45:15 <cnwdup> Can I use monadic function to make some type an instance of Alternative?
03:45:52 <Peaker> cnwdup: when you're writing a specific instance, its for a specific type, so if it already has a Monad instance, sure you can use it
03:46:07 <Peaker> cnwdup: you might need some extra context (if the monad instance has that context)
03:46:33 <cnwdup> Peaker: okay
03:46:57 <Peaker> if the monad is:  instance Ord a => Monad (SomeType a) where ...       then you might need:  instance Ord a => Alternative (SomeType a) where ... to use the Monad instance here
03:47:09 <Peaker> @src Alternative
03:47:09 <lambdabot> class Applicative f => Alternative f where
03:47:09 <lambdabot>     empty :: f a
03:47:09 <lambdabot>     (<|>) :: f a -> f a -> f a
03:47:32 <Peaker> cnwdup: people define Functor/Applicative instances using: liftM, return and ap  all the time, I think
03:47:53 <cnwdup> Peaker: Okay. It was just feeling weird. But I just recognized you do the same thing with Applicative.
03:47:56 <cnwdup> Jep. Thanks (-:
03:48:41 <Peaker> I dislike the dichotomy between Monoid, Alternative and MonadPlus
03:49:12 <bremner> Peaker: can't have a dichotomy between three things. You're welcome :-)
03:49:22 <Peaker> s/dichotomy/division :)
03:49:31 <Peaker> It started out as a dichotomy between Monoid and MonadPlus :)
03:49:42 <mauke> dichotomy(Monoid, dichotomy(Alternative, MonadPlus))
03:50:02 <ziman> yo dawg i herd you liek dichotomy... :)
03:50:36 <Heffalump> trichotomy?
03:51:03 <Peaker> I think we need higher ranked class contexts so we can do something like:  class (Monad m, forall a. Monoid (m a)) => MonadPlus m where <nothing -- instance only means it abides the Monoid vs Monad laws>
03:51:36 <Peaker> so we don't have code duplication between the Monoid, Alternative and MonadPlus classes
03:53:48 <Peaker> The problem is that people really hate newtype'ing for different Monoid instances -- so they like the duplicate classes :-(
03:57:12 <Peaker> newtype RecursiveMonoidMaybe a = RMM { unRMM :: Maybe a } ; inRMM = RMM ~> unRMM ; instance Monoid (RecursiveMonoidMaybe a) where ... ;  instead of (callFunc someMaybeValue) you can use inRMM callFunc someMaybeValue -- to use the other instance
03:57:23 <Peaker> so the newtype stuff is not that expensive, really
03:57:30 <Peaker> </monolog>
03:57:35 <Peaker> </monologue>
03:59:52 <RayNbow> @hoogle (~>)
03:59:53 <lambdabot> No results found
04:01:34 <true\false> I'm just trying to work out if I want to do C or Haskell .. I'm curious, how much use can a CS student, coming from OO, gain from learning a functional language?
04:01:46 <RayNbow> Peaker, (~>) = ?
04:01:47 <Peaker> @let result = (>>>) ; argument = (<<<) ; infixr 2 ~> ; (x ~> y) z = x >>> z >>> y
04:01:48 <lambdabot>  Defined.
04:01:52 <RayNbow> ah
04:01:53 <Peaker> @type (~>)
04:01:55 <lambdabot> forall (a :: * -> * -> *) b c c1 d. (Arrow a) => a b c -> a c1 d -> a c c1 -> a b d
04:02:02 <mmorrow> true\false: do C and Haskell :)
04:02:27 <Peaker> true\false: A functional language is better than an OO language :-)
04:02:29 <true\false> mmorrow: Ok.. Then what I do in the summer, and what I do between now and then (Especially as I have a week off now)
04:02:42 <Peaker> @type length ~> length ~> id
04:02:43 <lambdabot> forall a a1 c1. (Int -> Int -> c1) -> [a] -> [a1] -> c1
04:03:08 <true\false> I fail to see a real use for haskell outside of an academic interest right now
04:03:18 <Peaker> > (length ~> length ~> id) compare "zz" "aaa"
04:03:19 <mmorrow> true\false: start programming things you think are cool in C, Haskell, or both
04:03:20 <lambdabot>   LT
04:03:33 <Peaker> true\false: Haskell *is* in use outside of academia
04:03:47 <vixey> true\false, generally for programming problems
04:03:56 <mmorrow> true\false: what's one thing you use programming for
04:03:57 <mmorrow> ?
04:04:11 <true\false> For passing my course, general little things in C# for daily tasks
04:04:18 <Peaker> true\false: inheritance-based OO is a bad idea (as inheritance is a bad idea)
04:04:25 <mmorrow> cool, what's one such daily task?
04:04:47 <true\false> Daily log of sleep/food/exercise
04:05:22 <true\false> Peaker: I actually am quite fond of OO in that respect
04:05:38 <Peaker> true\false: I was too.  I can explain why inheritance is a bad idea :-)
04:05:44 <Peaker> true\false: and what the better alternatives are
04:05:45 <ziman> what's wrong about inheritance?
04:06:06 <mmorrow> cool, so for instance you could learn how to use Data.Map (which is a must), then make your own little DB/log-thingy that you can parse say a csv in, then summarize it, then maybe spit out a webpage with Text.XHtml
04:06:13 <Peaker> ziman: inheritance solves various problems, but each of them has a far better solution (and you will find it in Haskell) :-)
04:06:33 <Peaker> ziman: The first problem it solves is polymorphism. Its a really bad way to do polymorphism, because it locks 3rd parties out from deciding how your types are polymorphic
04:06:48 <RayNbow> Peaker: it took me a while to figure it out, but I now undersatnd (~>) :)
04:06:58 <true\false> Interfaces are a nice way to implement polymorphism though
04:07:03 <Peaker> RayNbow: its a very cool operator, IMO :)
04:07:22 <Peaker> true\false: They would be, except the types that implement them have to specify that they implement them
04:07:40 <Peaker> true\false: in Haskell, I can connect a 3rd party type to a 3rd party interface, in OO, you have to hope that the class writer implemented the interface
04:07:42 <RayNbow> (f ~> g ~> h) a b c  = (h a) (g b) (f c)  -- Peaker, this is correct, right?
04:07:43 <true\false> Sure, but that's just how abstraction is great..
04:07:50 <RayNbow> (does (~>) have a name?)
04:08:05 <true\false> Ahh.. Right, but I think they generally do
04:08:23 <Peaker> RayNbow: no no,  (f ~> g ~> h) func a b = h (func (f a) (g b))
04:08:23 <twb> Is hpaste down?
04:08:31 <Peaker> RayNbow: apply f to the first arg, g to the second, and h to the result
04:08:48 <Peaker> RayNbow: Some ~> involving expression creates a "function editor" that takes a function and returns a new function that handles its args/result
04:09:02 <Peaker> true\false: generally do what?
04:09:07 <true\false> Well whatever, real world haskell should teach me a thing or two about programming in general .. And I'm tired of not understanding functional code :p
04:09:12 <Peaker> true\false: If I define a new interface, I can't get the whole world of classes to magically inherit it
04:09:18 <true\false> Peaker: Generally implement related interfaces
04:09:25 <twb> http://paste.lisp.org/display/74149 this case/Just cascade is ugly; how can I refactor it?
04:09:35 <RayNbow> Peaker: ah k
04:09:38 <baaba> > (show ~> id ~> id) (++) 5 "3"
04:09:39 <lambdabot>   "53"
04:09:45 <Peaker> true\false: But the way that interfaces in OO work mean that people don't create high granularity useful interfaces, because there'd be too many and noone would inherit/implement them all
04:09:56 <true\false> Hmmm, true..
04:10:11 <Peaker> So that's the first problem inheritance solves badly, I can proceed to the next ones :)
04:10:28 <Peaker> (Note that Haskell's type-classes solve polymorphism in a much better way)
04:10:49 <vixey> better than what?
04:11:00 <Peaker> vixey: better than inheritance or Java's "implements"
04:11:02 <true\false> Than C derived languages
04:11:21 <true\false> Hmm gah my programming knowledge is actually pretty poor I'm realising, reading RWH
04:11:23 <Peaker> RayNbow: x ~> y ~> z == x ~> (y ~> z) and can be seen as "apply x to the first arg, and (y ~> z) to the result. The result happens to be a function too, so it applies y to its arg, and z to its result
04:11:28 <mmorrow> > (\m -> Map.map (\x -> fromIntegral x / fromIntegral (Map.size m)) m) . foldl' (\m x -> Map.insertWith' (+) x 1 m) Map.empty . take 100000 $ randomRs (0,3::Int) (mkStdGen 398927)
04:11:30 <vixey> Peaker, is Java your definition of OO?
04:11:31 <lambdabot>   fromList [(0,6254.25),(1,6230.5),(2,6266.75),(3,6248.5)]
04:11:31 <Peaker> RayNbow: so a common pattern in ~> is:  blah ~> bleh ~> id
04:11:39 <Peaker> vixey: No
04:11:48 <vixey> Have you looked at Epigram 1 yet?
04:12:14 <Peaker> vixey: Nope, to spark interest enough to look for its hiding website, you'd have to tell me what it is first :)
04:12:29 <baaba> :t ((++), (show ~> show ~> id) (++))
04:12:31 <lambdabot> forall a a1 a2. (Show a2, Show a1) => ([a] -> [a] -> [a], a1 -> a2 -> [Char])
04:12:57 <Peaker> RayNbow: you have to have the "id" there to not touch the result but be able to apply a function to all the arguments
04:13:08 * RayNbow nods
04:13:10 <baaba> hm, i guess that needs a bit of additional type annotation to be a good demonstration
04:13:31 <augustss> @seen mmorrow
04:13:31 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 4s ago.
04:13:39 <Peaker> > (show ~> show ~> id) (++) 5 6
04:13:40 <mmorrow> @let avgs a = (\m -> Map.map (\x -> fromIntegral x / fromIntegral (Map.size m)) m) . foldl' (\m x -> Map.insertWith' (+) x 1 m) Map.empty $ a
04:13:41 <lambdabot>  <local>:9:16: Not in scope: `Map.map'
04:13:42 <lambdabot>  
04:13:42 <lambdabot>  <local>:9:62: Not in scope: `Map.si...
04:13:42 <lambdabot>   "56"
04:13:43 <mmorrow> augustss: hi
04:13:59 <Peaker> > (show ~> show ~> id) (++) 5 "hehe"
04:14:02 <lambdabot>   "5\"hehe\""
04:14:13 <augustss> mmorrow: mcode is akin to LLVM.  it's a low level virtual machine; assembly code level.
04:14:14 <Peaker> > (show ~> show ~> replicate 3) (++) 5 "hehe"
04:14:16 <lambdabot>   ["5\"hehe\"","5\"hehe\"","5\"hehe\""]
04:14:56 <mmorrow> augustss: cool. was it made especially and only for hbc (and/or lml)?
04:15:28 <mmorrow> well, not in that it's particular to them, but it was used for them
04:15:36 <augustss> made especially for lml.  The G-code was translated ti M-code, and from there to native code.
04:15:58 <augustss> mmorrow: the garbage collector and other critical parts of the rts were written in M-code
04:16:01 <mmorrow> interesting. i've been trying to grok it some recently
04:16:10 <RayNbow> > let stringAdd = (read ~> read ~> show) (+)    in   stringAdd "1" "2"
04:16:13 <lambdabot>   "3"
04:16:13 <mmorrow> augustss: ah yes. i've been looking at that in particular
04:16:29 <RayNbow> :t (read ~> read ~> show) (+)
04:16:31 <lambdabot> String -> String -> String
04:17:07 <augustss> mmorrow: the M-code came about when we made the second code generator, for 68k.  The first was for VAX.  Then we needed an abstraction yo avoid rewriting a lot of code that was written in aembly.
04:17:11 <augustss> assembly
04:18:01 <mmorrow> yeah, it caught my eye since i can't really think of anything else that abstracts over assembly, but is /still/ assembly
04:18:02 <RayNbow> hmm...
04:18:26 <augustss> mmorrow: so the M-code is kinda like VAX assembly code
04:18:47 <augustss> Fewer instructions and addressing modes.
04:18:48 <RayNbow> > (read ~> read ~> show) (+) "1.0" "3.0"
04:18:50 <lambdabot>   "* Exception: Prelude.read: no parse
04:18:58 <RayNbow> > ((read :: (String -> Double)) ~> read ~> show) (+) "1.0" "3.0"
04:19:00 <lambdabot>   "4.0"
04:19:22 <mmorrow> hmm, so is that a good thing (because it simplifies things), or a bad thing (because it's limiting)?
04:19:35 <mmorrow> (i dunno if it's limiting..)
04:19:59 <mmorrow> in particular, the addressing modes
04:20:21 <augustss> mmorrow: we kept the ones we needed :)
04:20:32 <mmorrow> heh, cool
04:21:16 <augustss> mmorrow: it worked out pretty well.  hbc still beats ghc on some benchmarks after all :)
04:21:52 <mmorrow> sweet. it's interpreter has a big one-up on ghci since it can do data/class decls too
04:23:20 <Peaker> RayNbow: :-)
04:23:36 <augustss> yes.  I don't see why ghci doesn't add that.
04:24:49 <mmorrow> augustss: totally
04:26:29 <mmorrow> i've been trying to figure it out, and am to where i've got everything and i need to link it, but there are functions that aren't public that you'd need
04:26:36 <mmorrow> so stuck again
04:26:54 <mmorrow> (in particular, in Linker.lhs)
04:27:02 <mmorrow> :(
04:27:57 <mmorrow> ((and you can't just duplicate Linker.lhs to MyLinker.lhs because it has a global IORef that's synced with the global state in Linker.c))
04:28:03 <mmorrow> yuk
04:28:53 <augustss> So export the functions you need
04:29:01 <Peaker> Hey I just noticed emacs's Haskell mode can indent stuff much better when you use pre-line comma instead of post-line comma
04:29:57 <mmorrow> augustss: hmm, yeah i guess that's really all i have to do
04:30:38 <mmorrow> (but then it won't work with an unmodified ghc, but whatever. it'll work nonetheless)
04:32:19 <BrokenClockwork> What is more used Emacs or Vim?
04:33:39 <mrsolo> depend on whom youask
04:34:09 <Peaker> Is there a   data Tree b l = Branch b (Tree b l) (Tree b l) | Lead l   -- type in Hackage?
04:34:49 <true\false> Another rather important problem .. Is it prounounced "Hask-ull" or "Hask-ell"?
04:35:19 <Badger> heh
04:35:31 <Badger> Hask-L :P
04:35:44 <true\false> Rightyo, ta
04:37:34 <augustss> And despite how some people pronounce Haskell, it doesn't rhyme with Pascal.
04:38:53 <Gracenotes> ...oh?
04:39:09 <Gracenotes> stress on the second syllable?
04:41:53 <Boney> augustss: I think that's because many people pronounce Pascal incorrectly/differently.
04:41:58 <jeffz`> @seen dcoutts
04:41:59 <lambdabot> dcoutts is in #haskell, #ghc, #darcs, #haskell-soc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 16h 51m ago.
04:42:03 <augustss> haha
04:42:39 <true\false> augustss: Aye.. I was wondering why somebody learnt Haskell at college last night, turns out it was delphi/pascal
04:42:49 <true\false> lastButOne [a] = if(length(tail(a)) == 1) then a else lastButOne (tail([a])) --As far as I'm aware, this is logically sound?
04:43:23 <Boney> true\false: Melbourne University used to teach Haskell in 1st year (freshman)
04:43:36 <vixey> true\false, this is not C
04:43:39 <true\false> Boney: UK college, for 16-18
04:43:45 <Boney> ah.
04:44:02 <vixey> true\false, you may write:  if length (tail a) == 1 then ...
04:44:18 <Peaker> true\false: if length (tail a) == 1 ..   and that is equivalent to:   if length a == 2  (which is safer!)
04:44:21 <mrsolo> boney: 1st year? oh my
04:44:25 <vixey> true\false, but:  lastButOne [a]  is probably wrong
04:44:38 <Boney> true\false: I guess we call that senior high school.  Often called VCE which referrs to the sylabus here in Australia.
04:44:46 <Peaker> true\false: you know the "init" function?
04:44:55 <Peaker> > init "hello"
04:44:57 <lambdabot>   "hell"
04:45:10 <true\false> Peaker: No, I'm following the real world haskell exercise to try and implement this
04:45:16 <Peaker> perhaps not the best examples :P
04:45:30 <Peaker> true\false: oh, ok
04:46:02 <true\false> Ok ta, semi works .. It just returns the last 2 elements, so at least it's functional in some capacity.
04:46:20 <true\false> Oh meant to return the head at the end, that's why
04:46:53 <augustss> Arghh!!  LLVM is starting to frustrate me.  I've now filed my third bug report for the day.
04:47:10 <BrokenClockwork> I imported Data.List, but Haskell is still not in scope with 'permutations'
04:47:16 <BrokenClockwork> I thought this function is included
04:47:23 <vixey> BrokenClockwork, if not you can just write it
04:47:23 <skorpan> @hoogle permutations
04:47:24 <lambdabot> No results found
04:47:54 <augustss> BrokenClockwork: I don't think it's in there.  Yet.  It should be.
04:48:08 <vixey> , 'src permutations
04:48:10 <lunabot>  luna: Couldn't match expected type `t -> a'
04:48:12 <vixey> , src 'permutations
04:48:16 <lunabot>  permutations :: forall a . [a] -> [[a]]
04:49:46 <Peaker> > let permutations [] = [[]] ; permutations (x:xs) = let p = permutations xs in x:p ; p++[x] in permutations [1,2,3]
04:49:48 <lambdabot>   <no location info>: parse error on input `in'
04:49:58 <Peaker> > let { permutations [] = [[]] ; permutations (x:xs) = let p = permutations xs in x:p ; p++[x] } in permutations [1,2,3]
04:50:00 <lambdabot>   <no location info>: parse error on input `}'
04:50:13 <Peaker> oops
04:50:17 <Peaker> > let { permutations [] = [[]] ; permutations (x:xs) = let p = permutations xs in [x:p, p++[x]] } in permutations [1,2,3]
04:50:19 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
04:50:19 <lambdabot>        Expect...
04:54:53 <augustss> 4th LLVM bug report
04:55:17 <vixey> do you still trust LLVM ?
04:55:30 <vixey> I mean once these 4 bugs are gone .. is it going to be reliable?
04:56:50 <jeffz`> dcoutts: can I bother you with a cabal problem?
04:56:59 <pejo> augustss, are you trying to generate assembly in runtime from some DSL?
04:57:04 <BONUS> > let perms [] = [[]]; perms xs = [y:ys | y <- xs, ys <- perms $ delete y xs] in perms [1,2,3]
04:57:06 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
04:57:17 <augustss> vixey: It generates failed assertions.  Better than wrong code.
04:57:18 <vixey> > let perms [] = [[]]; perms xs = [y:ys | y <- xs, ys <- perms $ delete y xs] in perms [1,2,2,3]
04:57:20 <lambdabot>   [[1,2,2,3],[1,2,3,2],[1,2,2,3],[1,2,3,2],[1,3,2,2],[1,3,2,2],[2,1,2,3],[2,1...
04:57:31 <vixey> oh right
04:57:46 <vixey> if it's just assertions that's not bad I guess
04:57:53 <augustss> pejo: At the moment I'm just trying single instruction functions from text based assembly code.
04:58:05 <augustss> Sorry, two instruction functions
04:58:31 <augustss> vixey: it seems like a lot of things are not implemented yet
04:58:47 <Philonous> > let perms [] = [[]]; perms xs = [y:ys | y <- xs, ys <- perms $ delete y xs] in perms [2,1,2]
04:58:49 <lambdabot>   [[2,1,2],[2,2,1],[1,2,2],[1,2,2],[2,1,2],[2,2,1]]
04:59:33 <tjb> I've got a question about foldl vs. foldr.  If we have a commutative property, it seems like foldl should be more efficient than foldr to evaluate -- but I've read that foldr is preferable, any ideas?
05:00:08 <Peaker> let perms [] = [[]] ; perms (x:xs) = [bef ++ [x] ++ aft | perm <- perms xs, i <- [0..length perm], let (bef, aft) = splitAt i perm] in perms [1,2,3]
05:00:13 <Peaker> > let perms [] = [[]] ; perms (x:xs) = [bef ++ [x] ++ aft | perm <- perms xs, i <- [0..length perm], let (bef, aft) = splitAt i perm] in perms [1,2,3]
05:00:15 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
05:00:43 <Peaker> > let perms [] = [[]]; perms xs = [y:ys | y <- xs, ys <- perms $ delete y xs] in perms [1,2,3]
05:00:45 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
05:01:35 <Peaker> @type let perms [] = [[]]; perms xs = [y:ys | y <- xs, ys <- perms $ delete y xs] in perms
05:01:37 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
05:01:44 <Peaker> @type let perms [] = [[]] ; perms (x:xs) = [bef ++ [x] ++ aft | perm <- perms xs, i <- [0..length perm], let (bef, aft) = splitAt i perm] in perms
05:01:46 <lambdabot> forall a. [a] -> [[a]]
05:03:31 <tjb> @src elem
05:03:31 <lambdabot> elem x    =  any (== x)
05:03:42 <vixey> module Foo where ( const :: a -> b -> a )  doesn't work
05:03:47 <vixey> oops
05:03:54 <vixey> module Foo ( const :: a -> b -> a ) where .. doesn't work
05:03:54 <tjb> @src any
05:03:55 <lambdabot> any p =  or . map p
05:04:03 <vixey> why not ?
05:04:21 * vixey noticed
05:04:26 <vixey>   (+++),      -- :: ReadP a -> ReadP a -> ReadP a
05:04:28 <dobblego> the type signature goes after where
05:04:34 <vixey> lines like this in ReadP
05:04:46 <BONUS> foldl builds up a lot of thunks along the way
05:05:39 <tjb> BONUS: couldn't foldl start evaluating the thunks instead?
05:05:46 <Philonous> tjb: foldl needs to create a lot of thunks because thanks to lazy evaluation functions are computed in "reverse" order, that is the outermost function is computed first and will only invoke the inner functions on demand
05:06:18 <vixey> @src foldl'
05:06:18 <lambdabot> foldl' f a []     = a
05:06:18 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:06:18 <tjb> Philonous, BONUS: ah that is right -- laziness induces that behavior
05:06:35 <Philonous> tjb: That's what foldl' does
05:06:39 <Gracenotes> @hackage derangement
05:06:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derangement
05:06:50 <BONUS> however, is foldl' or foldr more efficient for commutative operations
05:07:07 <vixey> foldl' f = foldl (\a x -> f $! a $! x)  is this right?
05:09:22 <Peaker> BONUS: it depends what the operation is/how lazy it is?
05:09:42 <vixey> > 1+1
05:09:43 <lambdabot>   2
05:09:46 <Peaker> @type foldl
05:09:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:09:51 <BONUS> yeah i guess so
05:10:45 <Peaker> > foldl' ((const . const) 0) 0 [0..]
05:11:10 <Peaker> > foldl ((const . const) 0) 0 [0..]
05:11:29 <Peaker> ouch!
05:11:36 <Peaker> Cale: sorry!
05:11:55 <Peaker> > foldr ((const . const) 0) 0 [0..]
05:12:03 <lambdabot>   0
05:12:42 <Peaker> BONUS: that's a commutative operation, and its most efficient with foldr :-)
05:12:52 <BONUS> HMMM!
05:13:06 <Peaker> BONUS: for Int (+), foldl' would be more efficient
05:13:57 <tjb> @src or
05:14:03 <lambdabot> or    =  foldr (||) False
05:14:32 <tjb> what about the or function?
05:15:32 <tjb> that has to be more efficient to evaluate with foldl' -- right? :-)
05:15:39 <L-Spiro> Hello.
05:15:51 <vixey> hi
05:16:17 <L-Spiro> I am doing the tutorial here: http://darcs.haskell.org/yaht/yaht.pdf
05:16:53 <L-Spiro> I want to do excercise 3.3 but I didn't see anything about printing booleans or comparison operators.
05:16:58 <L-Spiro> For example &&.
05:18:31 <Philonous> > True || undefined
05:18:32 <lambdabot>   True
05:18:40 <Philonous> > undefined || True
05:18:41 <lambdabot>   * Exception: Prelude.undefined
05:18:50 <Philonous> (||) is not commutative
05:19:48 <L-Spiro> So I am supposed to use a map.
05:20:18 <L-Spiro> Oh I got it.
05:20:22 <Heffalump> tjb: no, because || is lazy
05:20:40 <L-Spiro> map Char.isLower "Whatever"
05:20:59 <BONUS> > all isLower "Whatever"
05:21:01 <lambdabot>   False
05:21:06 <BONUS> > any isLower "Whatever"
05:21:08 <lambdabot>   True
05:21:18 <L-Spiro> > map Char.isLower "Whatever"
05:21:20 <lambdabot>   /tmp/3532411973316842332:70:36: Not in scope: `Char.isLower'
05:21:28 <tjb> oh, interesting.  Getting used to 'laziness' is still going to take me some time :)
05:21:32 <Peaker> tjb: yeah
05:21:36 <RayNbow> > mconcat (Any . isLower) "Whatever"
05:21:37 <lambdabot>   Couldn't match expected type `[a]'
05:21:47 <RayNbow> hmm
05:21:55 <Peaker> > mconcat (any . isLower) "Whatever"
05:21:56 <lambdabot>   Couldn't match expected type `a -> Bool'
05:22:06 <Peaker> > (any . isLower) "Whatever"
05:22:07 <lambdabot>   Couldn't match expected type `a -> Bool'
05:22:15 <Peaker> > (any isLower) "Whatever"
05:22:16 <lambdabot>   True
05:22:34 <RayNbow> oh wait
05:23:13 <L-Spiro> Ah I figured out 3.4 also.  I am feeling good.
05:23:19 <RayNbow> > mconcat $ map (Any . isLower) "Whatever"
05:23:20 <lambdabot>   Any {getAny = True}
05:24:03 <RayNbow> > (getAny . mconcat . map (Any . isLower)) "Whatever"
05:24:04 <lambdabot>   True
05:25:07 <dmwit> > null ("Whatever" >>= guard . isLower)
05:25:08 <lambdabot>   False
05:25:14 <dmwit> > null ("whatever" >>= guard . isLower)
05:25:15 <lambdabot>   False
05:25:26 <dmwit> err
05:25:39 <dmwit> > guard True :: [()]
05:25:40 <lambdabot>   [()]
05:25:45 <dmwit> zoinks!
05:25:58 <dmwit> :t when
05:26:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:26:04 <dmwit> :t guard
05:26:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
05:26:19 <dmwit> ah
05:26:26 <dmwit> > null ("whatever" >>= guard . isUpper)
05:26:27 <lambdabot>   True
05:26:42 <RayNbow> > let genericAny = (getAny . foldMap (Any . isLower))         in      genericAny "Whatever"
05:26:44 <lambdabot>   Not in scope: `foldMap'
05:26:58 <RayNbow> > let genericAny = (getAny . Data.Foldable.foldMap (Any . isLower))         in      genericAny "Whatever"
05:26:59 <lambdabot>   True
05:27:02 * dmwit defines "any p xs = null (xs >>= guard . not . p)" to be perverse
05:27:20 <cnwdup> @src some
05:27:21 <lambdabot> some v = some_v
05:27:21 <lambdabot>   where many_v = some_v <|> pure []
05:27:21 <lambdabot>         some_v = (:) <$> v <*> many_v
05:27:54 <RayNbow> dmwit: hmm... does that work for infinite lists?
05:28:22 <dmwit> > null (repeat 'a' >>= guard . not . isLower)
05:28:34 <RayNbow> :p
05:28:37 <lambdabot>   thread killed
05:28:47 <dmwit> =)
05:29:05 <dmwit> > null (repeat 'a' >>= guard . isLower) -- just to make sure
05:29:07 <lambdabot>   False
05:29:37 <dmwit> But then, "any" works only one way on infinite lists, too, so what the heck.
05:29:47 <RayNbow> :p
05:30:43 <RayNbow> > filter (const False) [1..]
05:31:06 <RayNbow> ^ someone once asked me why Haskell wasn't smart enough to produce the answer []... :p
05:31:25 <RayNbow> ...I answered him we need to solve EQ_TM first :p
05:31:32 <vixey> hehe
05:32:04 <vixey> there should be an language with execution that does AI to try and figure stuff like that out
05:33:36 <RayNbow> @bot
05:33:37 <lunabot>  :)
05:33:37 <lambdabot> :)
05:33:53 <scanz> hey
05:34:10 <scanz> have some problem with my haskell code
05:34:13 <edwardk> @users
05:34:13 <lambdabot> Maximum users seen in #haskell: 599, currently: 599 (100.0%), active: 18 (3.0%)
05:34:25 <vixey> scanz, what is it?
05:34:28 <BONUS> i thought it was over 600
05:34:45 <scanz> http://privatepaste.com/9dYd7YM7fs in line 28 i get the error "Syntax error in expression (unexpected `->')" but dont know why
05:34:49 <RayNbow> lambdabot is one hell of a senile bot... chronic amnesia :p
05:35:16 <BONUS> you forgot the of
05:35:18 <BONUS> for one
05:35:50 <dmwit> That's some deep indentation.
05:36:29 <dmwit> I don't think 0 and 1 count as Bools.
05:37:11 <killerboy> hi
05:37:31 <killerboy> lamdabot's facts base was emptied, what happened?
05:37:44 <BONUS> @users
05:37:44 <lambdabot> Maximum users seen in #haskell: 600, currently: 600 (100.0%), active: 20 (3.3%)
05:37:57 <dmwit> scanz: Did you know about if/then/else?
05:38:10 <vixey> killerboy, <RayNbow> lambdabot is one hell of a senile bot... chronic amnesia :p
05:38:14 <dmwit> It's not so common to pattern match on Bools (though sometimes it is appropriate).
05:38:14 <vixey> pretty much sums it up
05:38:37 <killerboy> ok
05:38:41 <Peaker> dmwit: a friend of mine who is excited about Subtext's schematic tables refuses to use if/then/else and only uses pattern-matching, heh
05:38:57 <dmwit> Actually, most of this should be straight logic.
05:39:01 <dmwit> No pattern matching necessary.
05:47:28 <vixey> I wanted to write this typechecker but I cannot concentrated on it :/
05:47:40 <vixey> hmf
05:51:33 * Peaker is refactoring/improving an SDL-based widget-set
05:51:41 <Peaker> well, its the beginnings of a widget-set, anyway
05:51:48 <Peaker> (Only has TextEdit so far, heh)
05:53:55 <killerboy> could anybody do something for lambdabot to save facts in file?
05:54:04 <killerboy> (i can't because i donno haskell :-( )
05:54:11 <killerboy> (at least not instantly)
05:54:59 <beelsebob> what would such a command look like?
05:55:05 <dmwit> killerboy: Of course.
05:55:10 <dmwit> That's what we have ?flush for.
05:55:11 <beelsebob> I'm guessing it would be very like @where, but with a different name
05:55:24 <dmwit> beelsebob: oh, ?fact already exists...
05:55:29 <dmwit> ?fact ?fact
05:55:29 <beelsebob> oh, does it?
05:55:29 <lambdabot> I know nothing about ?fact
05:55:34 <killerboy> dmwit, how ?flush works?
05:55:49 <dmwit> killerboy: It just write's lambdabot's state out to disk.
05:55:58 <dmwit> Unfortunately, only a privileged few can invoke it...
05:56:03 <killerboy> oh
05:56:05 <killerboy> so could you?
05:56:13 <dmwit> No.
05:56:18 <killerboy> who can?
05:56:23 <true\false> You can? :)D
05:57:01 <dmwit> ?where lambdabot
05:57:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
05:57:15 <dmwit> That's... probably on old link.
05:57:33 <mauke> you could also use preflex
05:57:47 <mauke> as a general rule, preflex is much dumber, but it does not forget
05:57:55 <killerboy> what is preflex?
05:58:01 <mauke> a bot
05:58:18 <killerboy> but i want this ----> lambdabot to save it
05:58:27 <mauke> why?
05:58:30 <killerboy> don't wanna my own instance
05:58:37 <mauke> you don't have to
05:58:54 <killerboy> ?
05:59:12 <mauke> ?
05:59:14 <dmwit> preflex: version
05:59:14 <preflex>  4.325
05:59:27 <dmwit> killerboy: preflex is a sturdy bot.
05:59:40 <dmwit> A little less capable than lambdabot, but I think mauke's done a nice job with it.
06:01:03 <killerboy> it isn't on logic
06:01:16 <killerboy> *##logic
06:02:08 <true\false> Heh, anybody else find learning the basics of Haskell a little awkward compared to C derived languages?
06:02:32 <dublpaws> not another bracket language
06:02:43 <dmwit> true\false: I find C-derived languages a little awkward after using the basics of Haskell...
06:03:40 <true\false> Really?
06:03:58 <Peaker> true\false: Haskell syntax is so much better than C-style syntax after you get used to both :-)
06:04:35 <true\false> I'm sure it's nice once you get a basic grasp of it
06:04:42 <Badger> truly.
06:05:02 <dmwit> Function application has always felt a bit awkward since I got used to the silent syntax.
06:05:13 <dmwit> and (.) pipes...
06:06:06 <killerboy> bye
06:08:00 <pitekus> i installed a ghc binary but it can't find libedit.so, which is in $HOME/lib
06:08:20 <pitekus> Is there a flag or smth i can use?
06:08:44 <mstr> ANSI C is horrible
06:08:50 <mstr> even compared to C++
06:09:08 <dmwit> pitekus: LIBRARY_PATH, or -L
06:09:13 <Peaker> mstr: why?
06:09:23 <vixey> mstr,  what brought this on?
06:09:28 <dmwit> pitekus: There's probably alse something you can send to the configure script during the installation.
06:09:34 <mstr> <Peaker> true\false: Haskell syntax is so much better than C-style syntax
06:09:42 <Peaker> mstr: Oh, the syntax
06:09:45 <dmwit> I'm not sure about this C > C++ thing.
06:09:55 <Peaker> mstr: C++ syntax is the worst horrible syntax ever :)
06:10:09 <mstr> Peaker: C++ gets you a lot of memory management for free though :)
06:10:19 <Peaker> If<You<Know>,What<I> space here > Mean
06:10:26 <dublpaws> smart pointers are really. really. really nice.
06:10:58 <mstr> I do. After 5 years of professional coding I could say that I know the language, and I'm still unsure sometimes ;)
06:10:59 <Peaker> dublpaws: You can't implement proper GC with smart pointers, afaik
06:11:08 <mstr> haskell and python are so nice :)
06:11:24 <dublpaws> Peaker: that's an interesting factoid.
06:11:42 <Peaker> dublpaws: and ref-counting is not a really great idea.. so what can smart pointers do?
06:11:56 <mstr> Peaker: are you talking about some casting tricks to break GC?
06:12:00 <pitekus> dmwit: LIBRARY_PATH doesn't seem to make a differnece
06:12:06 <dublpaws> valgrind ./a.out  , no leaks.
06:12:11 <dublpaws> that's what they do
06:12:17 <Peaker> mstr: no, C++'s smart pointers and my opinion of them :)
06:12:27 <Peaker> dublpaws: until you have a cyclic reference :P
06:12:30 <mstr> better than nothing :)
06:12:30 <dmwit> pitekus: urk
06:12:31 <stevan> pitekus: LD_LIBRARY_PATH, if that doesn't help try LD_RUN_PATH also
06:12:46 <Peaker> dublpaws: also, performance-wise, proper GC is probably better than ref-counting
06:13:09 <mstr> too bad they didn't get GC into C++0x
06:13:43 <pitekus> stevan: no luck :-(
06:14:06 <true\false> Hmm I like the value constructor syntax..
06:14:18 <L-Spiro> I prefer C syntax.
06:14:21 <L-Spiro> C++.
06:14:22 <true\false> Sort of like constructor overloading, though named?
06:14:32 <Peaker> L-Spiro: how long have you been using Haskell?
06:14:37 <stevan> pitekus: btw, do you have editline package from hackage installed under the ghc version you are using to compile 6.10.1 with?
06:14:41 <L-Spiro> An hour.
06:14:46 <Peaker> L-Spiro: :-)
06:14:58 <Peaker> L-Spiro: Yeah, I hated Haskell's syntax for the first couple of months, now I love it
06:15:03 <mauke> I prefer Perl syntax to C++
06:15:07 <pitekus> stevan: im not compiling ghc, im installing the binary
06:15:11 <L-Spiro> But you know I am going into it completely open-minded.  I am not hating on its syntax or anything about it.
06:15:26 <true\false> Peaker: Months? Heh..
06:15:50 <true\false> I have this week off before I go back to C# as my primary language.. Bad time to learn, but hey
06:15:54 <mstr> Perl :(
06:16:08 <L-Spiro> I am learning Haskell to pass a job interview.
06:16:13 * vixey ponders "primary language"
06:16:19 <Peaker> true\false: well, after a few weeks I thought "I see why the advantages of this syntax, I no longer hate it, but I still am not used to it"
06:16:33 <Peaker> L-Spiro: who asks about Haskell in a job interview?
06:16:33 <vixey> is it like owning your own house?
06:16:35 <mstr> I wanted to find the functional enlightenment :D
06:16:48 * edwardk wonders what he would have to classify his primary language as after all this time.
06:16:51 <mstr> not there yet
06:16:56 <L-Spiro> Peaker, I think it has to do with testing how quickly we learn new technologies.
06:17:10 <Peaker> L-Spiro: oh, they told you to learn it for the interview, interesting
06:17:10 <L-Spiro> Slash languages.
06:17:15 * Peaker might use that
06:17:15 * Badger writes a pure function "enlightenment" for mstr
06:17:17 <dublpaws> primary language: the language when given a smattering of tasks a user provides working solutions in the shortest amount of time.
06:17:18 <true\false> Sure .. Perhaps I can try to implement a server application in Haskell? It serializes to XML and sends objects to the C# client?
06:17:24 <L-Spiro> They told me to write a sample program in Haskell.
06:17:30 <L-Spiro> Before I can even get to the interview.
06:17:39 <true\false> Or is that a bit ambitious.. Not entirely sure.
06:17:47 <L-Spiro> So it is their way of eliminating a lot of candidates.
06:17:59 <L-Spiro> It is probably effective in most cases but I will not be one of them.
06:18:03 <L-Spiro> I will learn it.
06:18:30 <mauke> sample program: main = putStr "Hello, world!\n"
06:18:45 <L-Spiro> Nope, I have to sort a file and classify words in the file.
06:18:55 <mauke> aw
06:18:56 <edwardk> dublpaws: then probably, embarassingly enough, perl. ;)
06:19:01 <Peaker> true\false: its not hard to immediately write working Haskell programs as a newbie.  Of course after 2-3 months you'll look back and say "Yuck!" and refactor everything to 1/5 of the code :)
06:19:13 <Axman6> ok, movabletype >>> wordpress. so much simpler!
06:19:24 <Peaker> true\false: perhaps "not hard" is an exaggaration, you still have to fight with some laziness issues and puzzling error messages, perhaps
06:19:31 <true\false> Peaker: Hehe.. I guessed that
06:19:33 <Peaker> but its not more difficult than learning other languages
06:19:42 <Badger> Axman6: (>>>)? :P
06:19:56 <Axman6> much greater than ;)
06:20:06 <Peaker> heh, its also flip (.) on functions
06:20:18 <L-Spiro> Having experience in functional lazy pure languages makes me a better programmer, so I am not going to complain or judge the syntax/methods at all.
06:20:35 <stevan> pitekus: try ./configure LDFLAGS=-L$HOME/lib CPPFLAGS=-I$HOME/lib/include (or wherever you got the include files) LIBS="-ledit -lcurses"
06:20:35 <Badger> Peaker: heh, lies
06:20:53 <Badger> learning C as a beginner is easier, surely.
06:21:06 <L-Spiro> Me?
06:21:14 <Badger> or some such language
06:21:18 <true\false> Learning something like C# as a newbie is very easy...
06:21:29 <Peaker> Badger: did your first C programs work or seg fault horribly? :)
06:21:40 <Badger> no segfaults! :)
06:21:43 <Peaker> Badger: if you include writing your first working programs in "learning a language" then Haskell is easier :)
06:21:51 <mauke> Peaker: silent memory corruption! :-)
06:22:26 <mstr> unallocated pointers don't always segfault ;)
06:22:34 <true\false> Well if I was new to code, I'd have given up now by learning Haskell.
06:22:53 <L-Spiro> I'm not a beginner in programming.  I have been a professional game developer for years.  I was a dev on Heroes of Might and Magic, Ghost Recon 2, 187 Ride or Die, and some others/
06:22:54 <pitekus> stevan: Didn't help. I guess ghc is somehow directly linked to /usr/lib/libedit or something...
06:23:09 <Badger> Peaker: perhaps so, but longer ones are a little bit painful :P
06:23:17 <vixey> L-Spiro, oh cool
06:23:37 <Badger> L-Spiro: how have you found learning it?
06:23:44 <L-Spiro> Learning Haskell?
06:23:47 <Badger> indeed
06:23:58 <Peaker> he said he used Haskell for 1 hour :)
06:24:09 <L-Spiro> Not too hard.  I have managed to do all of the examples on my own so far.
06:24:50 <L-Spiro> I hope to have this file sorted by tomorrow.
06:25:08 <mauke> main = interact $ unlines . sort . lines
06:25:15 <L-Spiro> Then I get to study Python (I know I should have learned it years ago) for their second sample program.
06:26:08 <L-Spiro> An important point in learning it easily is that there are good guides available for beginners.
06:26:47 <Peaker> mauke: onLines = lines ~> unlines ;   main = interact $ onLines sort
06:26:49 <Saizan> what are you using for haskell?
06:26:56 <L-Spiro> GHC.
06:27:00 <L-Spiro> And Notepad.
06:27:09 <Saizan> as a guide, i meant
06:27:19 <mauke> notepad :-[
06:27:21 <L-Spiro> http://darcs.haskell.org/yaht/yaht.pdf
06:27:33 <Peaker> L-Spiro: what languages have you used so far, if you didn't use Haskell and Python? :)
06:27:51 <Saizan> C++ i guess :)
06:28:02 <L-Spiro> C#, C, C++, Java, Objective-C, etc.
06:28:18 <L-Spiro> Mostly C++.
06:28:24 <Peaker> L-Spiro: and what did you use when you needed a quick script?
06:28:51 <mauke> those are all the same language :-)
06:28:53 <L-Spiro> mIRC script sometimes, or L. Spiro Script (my own language).
06:30:08 <dublpaws> is  f.f.f$val   more efficient than   f(f(f(val)))?   do the (.)s signal ghc to cram that code into one function, or somehow algebraically reduce it?
06:30:16 <L-Spiro> mauke, normally the difference is in the platform/SDK more than in the language.  Most consoles (and even mobile devices) use C/C++.
06:30:20 <mauke> dublpaws: no
06:30:23 <BONUS> dublpaws: the compiler takes care of it
06:30:47 <dublpaws> okay good to know.
06:32:45 <beelsebob> L-Spiro: one could argue with the massive sales of the iPhone, that most mobile devices use Obj-C
06:32:54 <Peaker> L-Spiro: What's your language like?
06:33:31 <Peaker> Obj-C is such a hack :-P
06:33:34 <L-Spiro> beelsebob, the problem with that assertion is that most iPhone development is C/C++ with Objective-C used just for glue.
06:34:09 <masklinn> L-Spiro: erm no, most iPhone development is Objective-C with raw C used for performances where needed, or Objective-C++ with raw C++ used for perfs
06:34:09 <L-Spiro> Peaker, my language is like C.  But suited for quick scripts because of its ease in creating some new code, compiling it, and seeing output.
06:34:23 <beelsebob> L-Spiro: not at all ‚Äì iPhone development is *entirely* Obj-C, or it doesn't get on the app store
06:34:29 <Peaker> L-Spiro: you have to define the static types of all variables manually, etc?
06:34:34 <beelsebob> using private APIs gets you banned
06:34:44 <beelsebob> and all the exposed ones are Obj-C
06:34:54 <masklinn> beelsebob: I'm pretty sure the private APIs and Frameworks are in Obj-C too anyway
06:35:02 <beelsebob> masklinn: not all of them, but yeh
06:35:38 <Axman6> anyone here use movable type for a blog where you have haskell?
06:36:03 <masklinn> and since Obj-C is a superset of C, it doesn't really matter whether the objective part is used a lot of rarely, it's obj-c anyway
06:36:07 <L-Spiro> Peaker, yes.  beelsebob, no.  Using C/C++ on iPhone does not mean you are using private API's/frameworks.  masklinn, I guess I am coming from the perspective of game development where most code is indeed performance-sensitive.
06:36:39 <blenket> how could C be improved? like what could be made easier and safer without introducing too much overhead?
06:37:05 <Peaker> blenket: ptr * could become a postfix rather than prefix operator
06:37:06 <mauke> blenket: a module system :-)
06:37:19 <Peaker> blenket: Arrays could not automatically degrade to pointers to their first elements
06:37:23 <L-Spiro> blenket, my script language is basically C with some friendliness added.  For example, declaring variables anywhere in the function, and declaring globals and functions in any order.
06:37:43 <L-Spiro> Those would be 2 very simple things.
06:37:52 <cnwdup> What's wrong with hpaste?
06:37:54 <Peaker> L-Spiro: I think you've been missing out on so much ease you can get with languages like Python/Haskell :-)
06:37:55 <dmwit> L-Spiro: I hope you didn't spend long on that, since gcc has been offering those extensions a long time...
06:37:56 <mauke> C already does the first part
06:38:09 <dublpaws> blenket: all variables are const, there would be a mutab  keyword instead
06:38:15 <L-Spiro> dmwit, that was not the focus of my language.  It is designed for hacking.
06:38:18 <mauke> dublpaws: 'var', please
06:38:21 * dmwit nods
06:38:21 <L-Spiro> Peaker, probably.
06:38:24 <masklinn> designed for hacking what?
06:38:31 <L-Spiro> masklinn, games usually.
06:38:37 <masklinn> and why not use forth if you want a flexible, hackable language with fast turnaround?
06:38:47 <jeffz`> cnwdup: it bought the farm, http://moonpatio.com/fastcgi/hpaste.fcgi/
06:38:59 <L-Spiro> For example I added the "extern" keyword to mean "a variable declared inside another process on your computer".
06:39:32 <cnwdup> jeffz`: Ah, thanks. (-:
06:39:32 <dublpaws> var eh.  brings back the pascal
06:39:38 <L-Spiro> So if you read from external variables the value will come from the RAM of another process.  Writing to them changes the RAM of another process.
06:40:05 <masklinn> L-spiro: I'm pretty sure C already has extern
06:40:06 <paolino> mh, what is the difference between intercalate and intersperse ?
06:40:11 <mauke> masklinn: not like that
06:40:19 <dmwit> =mauke
06:40:20 <mauke> paolino: the type :-)
06:40:26 <masklinn> mauke: yes I know the meaning's completely different, but that only makes things worse
06:40:28 <BONUS> intersperse takes an element and a list of elements and puts that element in between all the elements
06:40:34 <BONUS> > intersperse 'a' "hhhh"
06:40:37 <masklinn> extend C by redefining keywords? Ouch
06:40:38 <lambdabot>   "hahahah"
06:40:56 <mauke> masklinn: hey, it's what C and C++ have done :-)
06:40:59 <BONUS> intercalate takes a list of lists and a list, puts that between all the elements and then concats them
06:41:15 <paolino> so only concat ...
06:41:16 <Peaker> L-Spiro: how does it work? Does it send a request to the other process? Shared memory?
06:41:21 <dmwit> paolino: right
06:41:25 <L-Spiro> masklinn, the normal use of extern in C/C++ would have no use in my language.  I wanted to use familiar terms rather than invent new ones.  I also borrowed synchronized from Java.
06:41:28 <masklinn> mauke: I don't take that as a demonstration that it's a good idea to do so :D
06:41:31 <BONUS> > intercalate ", " ["hey", "sup"]
06:41:32 <mauke> 'static' has 4 different meanings in C/C++
06:41:33 <lambdabot>   "hey, sup"
06:41:47 <BONUS> > concat $ intersperse ", " ["hey", "sup"]
06:41:49 <lambdabot>   "hey, sup"
06:41:50 <masklinn> mauke: const also has a buttload of different meanings
06:41:51 <Peaker> mauke: in C++ :)
06:42:01 <gwern> @flush
06:42:02 <mauke> Peaker: no, only 3 in C++
06:42:04 <Peaker> masklinn: What does const mean besides the common one?
06:42:12 <L-Spiro> Peaker, it has 2 primary ways.  One using the Win32 API ReadProcessMemory() and another uses my own kernel driver to access the RAM in the target process.
06:42:14 <BONUS> so yeah intercalate is intersperse and then concat
06:42:15 <Peaker> mauke: oh, which C meaning is not in C++?
06:42:16 <dmwit> Hell, even "0" can mean things other than an all-zero bit-pattern in C++.
06:42:31 <Peaker> L-Spiro: you're not targeting platform independence eh? :-)
06:42:40 <mauke> Peaker: void f(int a[static 123])
06:42:48 <paolino> I was wondering if I could use them to mix two lists element by element
06:42:56 <Peaker> mauke: never heard of that feature -- what is that?
06:43:08 <L-Spiro> Well the extern feature is implementation-dependent.  When you add it to your software your software gets to define how it works and what it does.
06:43:13 <dmwit> paolino: zip
06:43:14 <mstr> are there other game platforms other that consoles and windows pc? ;)
06:43:27 <mauke> Peaker: means a is still a pointer (as usual), but f will always be called with an array of at least 123 elements, so the compiler can prefetch stuff
06:43:30 <Adamant> beelsebob: the iThings don't have that much market penetration yet
06:43:33 <dmwit> paolino: transpose is also handy if you have more than two lists
06:43:33 <Adamant> Peaker: it's less of a hack than C or especially C++
06:43:37 <L-Spiro> So you can change how it works on a Mac, or change its meaning to reading values from files or across LAN's etc.
06:43:45 <paolino> dmwit: [a] -> [a] -> [a]
06:43:52 <dmwit> paolino: zipWith, then
06:43:56 <dmwit> :t zipWith (+)
06:43:58 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
06:44:19 <paolino> [1,3 ..] [2,4 ..] -> [1..]
06:44:27 <dmwit> paolino: ah, yeah, then use transpose
06:44:36 <dmwit> > transpose [[1,3..], [2,4..]]
06:44:38 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
06:44:50 <dmwit> > concat $ transpose [[1,3..], [2,4..]]
06:44:51 <mauke> :t (concat .) . transpose
06:44:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:44:52 <lambdabot>     Couldn't match expected type `a1 -> [[a]]'
06:44:52 <lambdabot>            against inferred type `[[a2]]'
06:44:52 <lambdabot>     Probable cause: `transpose' is applied to too many arguments
06:44:54 <Peaker> mauke: its not enforced, right?
06:45:04 <Peaker> mauke: if you call it with less, that is
06:45:13 <BONUS> :t (concat .) . intersperse
06:45:14 <dmwit> :t (concat . transpose .) . (\a b -> [a, b])
06:45:15 <mauke> Peaker: depends on how nice your compiler is :-)
06:45:15 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:45:16 <lambdabot>     The operator `.' [infixr 9] of a section
06:45:16 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
06:45:16 <lambdabot>         in the section: `(concat . transpose .)'
06:45:19 <paolino> dmwit: thanks
06:45:33 <mauke> dmwit: it's just a single (.)
06:45:46 <dmwit> uhh
06:45:50 <dmwit> I don't think so...?
06:46:00 <byorgey> :t concat . transpose
06:46:02 <lambdabot> forall a. [[a]] -> [a]
06:46:02 <dmwit> :t ((concat . transpose) .) . (\a b -> [a, b])
06:46:03 <lambdabot> forall a. [a] -> [a] -> [a]
06:46:08 <mauke> er
06:46:14 <mauke> lost in context :-(
06:46:15 <dmwit> Mine is right.
06:46:17 <dmwit> ah
06:46:20 <dmwit> sorry then =P
06:46:38 <byorgey> dmwit: up already? =)
06:46:46 <dmwit> Haven't gone to bed yet. =)
06:46:49 <byorgey> hah
06:47:01 <dmwit> No, but really, I'm on a bit of a wacky schedule recently.
06:47:11 <dmwit> sleep 1400-2200 or so
06:47:17 <cnwdup> I am trying to write a parser (much like in RWH) but it's *really* slow if its using functions of the Alternative class. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=900#a900 Is there something obvious which is slowing it down?
06:47:25 <byorgey> dmwit: heh, crazy.
06:47:27 <paolino> transpose is a zipN ?
06:47:33 <mauke> paolino: yes
06:47:34 * tibbe swears about the badly documented Network.Socket module
06:47:34 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
06:47:37 <dmwit> paolino: yep, but be careful!
06:47:51 <dmwit> paolino: Lists of varying length can bite you even harder here than with zip.
06:47:53 <mauke> tibbe: oh, which part?
06:48:15 <dmwit> transpose . transpose /= id
06:48:24 <paolino> > transpose [1..5][1,2]
06:48:25 <lambdabot>   Couldn't match expected type `[t1] -> t'
06:48:36 <tibbe> mauke: SocketStatus in this particular case but many functions lack any documentation.
06:48:38 <paolino> > transpose [[1..5],[1,2]]
06:48:40 <lambdabot>   [[1,1],[2,2],[3],[4],[5]]
06:48:52 <dmwit> > transpose [[1,2], [1..5]]
06:48:53 <lambdabot>   [[1,1],[2,2],[3],[4],[5]]
06:49:20 <dublpaws> @let emotion = ":)"
06:49:20 <dmwit> There's no "hole" value to put in the last three lists.
06:49:22 <lambdabot>  Defined.
06:49:27 <dublpaws> reverse emotion
06:49:31 <dublpaws> > reverse emotion
06:49:33 <lambdabot>   "):"
06:49:34 <dmwit> So you don't get [hole, 3], etc.
06:49:39 <mauke> hmm, SocketStatus seems to be an implementation detail of Socket
06:49:51 <paolino> dmwit: as expected, don't know why actually
06:50:15 <chessguy> @check \x -> (transpose . transpose) x == x
06:50:16 <lambdabot>   "Falsifiable, after 7 tests:\n[[],[(),(),(),(),()],[(),(),(),()],[(),(),()]...
06:50:34 <tibbe> mauke: well, e.g. send requires the socket to be either bound or connected. I would expect it to have to be connected but I can't really figure it out from the code
06:50:38 <dmwit> ?check liftM2 (==) (transpose . transpose) id
06:50:40 <lambdabot>   "Falsifiable, after 2 tests:\n[[]]\n"
06:50:50 <dmwit> Ooo, that's a good one.
06:50:55 <dmwit> > transpose [[]]
06:50:57 <lambdabot>   []
06:50:59 <dmwit> nasty
06:51:13 <dublpaws> :t liftM2
06:51:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:51:21 <dublpaws> pft, yeah right
06:51:55 <dmwit> liftM2 :: (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)
06:52:11 * dublpaws goes back to his duplo fortress of dunce
06:57:14 <tibbe> I think the documentation of 'send' in Network.Socket is wrong. It's not enough to have a bound socket to call send, the socket needs to be connected with either 'connect' or 'accept'
06:57:23 <dublpaws> (a->b->c) is a function which takes types returned from function (e->a) and (e->b) and implements transitivity from e->c... ?
06:57:35 <dmwit> right
06:57:52 <dmwit> dublpaws: See if you can finish this definition:
06:57:59 <dmwit> liftM2 f g h = \e -> ...
06:58:06 <dublpaws> h?
06:58:14 <omegaman> what does the \ mean?
06:58:17 <omegaman> <= n00b
06:58:21 <dmwit> omegaman: It's a lambda.
06:58:22 <skorpan> Œª
06:58:24 <omegaman> ah
06:58:25 <vixey> hey omegaman
06:58:28 <omegaman> i see
06:58:32 <dmwit> omegaman: I could have written it as "liftM2 f g h e = ...", too.
06:58:47 <omegaman> ok
07:02:17 <dublpaws> f (g e) (h e)
07:02:42 <vixey> :t \a'b'c a b -> (\e -> a'b'c (a e) (b e))
07:02:43 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
07:03:37 <dmwit> dublpaws: Exactly!
07:05:44 <idnar> tibbe: what if it's a UDP socket?
07:09:10 * byorgey makes lambda polenta
07:11:33 <paper_cc> OT is there a lazy XML parser anywhere?
07:13:32 <ozy`> @hoogle xml
07:13:32 <lambdabot> package xml
07:13:32 <lambdabot> package xml-parsec
07:13:32 <lambdabot> package xml2x
07:13:48 <tibbe> idnar: but send doesn't allow you to specify a receipient
07:13:48 <SamB> xml-parsec isn't it
07:14:45 <ozy`> paper_cc: hmmmm... http://hackage.haskell.org/packages/archive/HaXml/1.19.4/doc/html/Text-XML-HaXml-ParseLazy.html
07:15:20 <idnar> tibbe: oh, true
07:15:31 <tibbe> idnar: and the man pages seem to agree with me.
07:15:36 <idnar> I guess you have to sendto
07:15:42 <tibbe> idnar: right
07:19:29 <Saizan> paper_cc: there's a lazy one in HXT based on tagsoup i think
07:19:43 <skorpan> @pl \w -> " " ++ w ++ " "
07:19:44 <lambdabot> (' ' :) . (++ " ")
07:19:47 <skorpan> lol
07:19:49 <ksf> zomg I'm back!! :P
07:20:15 <idnar> zomg he's back
07:21:34 <vixey> hey how do you convert alpha syntax to de bruijn?
07:21:54 <vixey> @go alpha conversion is easy
07:21:56 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
07:21:56 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
07:22:28 <vixey> I found this http://www.cs.nott.ac.uk/~txa/publ/alpha-draft.pdf
07:22:52 <vixey> alpha-equivalence classes --> de bruijn
07:23:12 <vixey> and alpha-beta-equivalance classes --> HOAS works too but I don't know any account of it does anyone?
07:26:40 <vixey> there's a section "Substitution is monadic" :)
07:33:59 <ksf> c2hs should support plugins
07:35:34 <dcoutts> ksf: hmm?
07:35:43 <dcoutts> aaargh! blogger.com is so broken!
07:36:01 <dcoutts> yay for captcha images that are not even displayed! 404 ffs
07:36:16 * dcoutts wanted to comment on a funny review of cabal
07:36:21 <ksf> Well, I just had a look at Language.Haskell, noticed that it doesn't know about c2hs hooks and am now browsing the c2hs source to figure out where to hack it.
07:36:45 <dcoutts> ksf: try haskell-src-exts
07:36:48 <ksf> ...as there's no way I'm going to type all those function names by hand.
07:37:22 <ksf> ...then there's the point that I'm going to need info out of the c headers, too.
07:37:24 <dcoutts> ksf: what are you trying to do?
07:38:03 <ksf> generating agar bindings.
07:39:34 <skorpan> is there anything in haskell which can easily retrieve information on rwx permissions for files?
07:39:36 <ksf> Actually, gtk2hs comes with its own version of c2hs, so I don't know why I shouldn't do the same.
07:39:48 <dcoutts> ksf: it does but it should not need to
07:39:59 <dcoutts> ksf: it's aiming to get back to the mainline version
07:40:08 <dcoutts> ksf: so what extra do you need?
07:41:11 <SamB> huh, the locatedb on code.haskell.org is stale
07:41:36 <SamB> dcoutts: do you have any idea how to reset a password in trac ?
07:41:43 <SamB> is there a plugin needed or something ?
07:42:28 <dcoutts> SamB: ask the trac admin to do it. If you're the trac admin then I'm not sure check the trac docs.
07:42:52 <SamB> dcoutts: I don't have the permissions to change the file :-(
07:42:54 <ksf> calling variadic functions with fixed arguments, snatching the values out of #defines into functions... I guess I can do instance generation with TH.
07:43:30 <SamB> I unfortunately forgot my password ...
07:43:31 <vixey> does anyone have some examples of deriving daat types based on semantics of some other data type?
07:43:33 <dcoutts> SamB: you should do if you belong to the project and certainly if you're the project admin.
07:43:43 <ksf> and handling void pointers ;) I had to do typedef void void_t
07:43:46 <SamB> dcoutts: it's only writable by www-data
07:43:51 <islon_s> im trying to use haskell mode for emacs and keep getting this error "Symbol's function definition is void: switch-to-haskell", any ideas?
07:44:26 <jge> :t haskell
07:44:26 <dcoutts> SamB: so you're not the project admin, so you can ask them right?
07:44:28 <lambdabot> Not in scope: `haskell'
07:44:41 <SamB> dcoutts: what can they do ?
07:44:52 <dcoutts> SamB: they can reset your password
07:45:06 <dcoutts> SamB: they have full control over the trac instance
07:45:27 <dcoutts> ksf: calling variadic functions requires generating .c stubs and ffi importing those
07:45:50 <ksf> dcoutts, yes, I know.
07:45:52 <SamB> I don't see how Lemmih would have any more write access to /srv/trac/lhc/trac.htpasswd than I do ....
07:45:57 <ksf> I'm not using the variadic part, though.
07:46:05 <dcoutts> ksf: all sounds like useful additions to c2hs, I don't think you need to fork anything
07:46:26 <SamB> er, wait
07:46:38 <SamB> that's actually /srv/trac/lhc/db/trac.htpasswd
07:46:45 <SamB> $ ls -l /srv/trac/lhc/db/trac.htpasswd
07:46:45 <SamB> -rw-r--r-- 1 www-data lhc-p 68 Jan  8 16:19 /srv/trac/lhc/db/trac.htpasswd
07:46:46 <lunabot>  luna: Not in scope: `ls'
07:47:02 <dcoutts> SamB: oh ok, those perms are wrong
07:47:07 <ksf> well, let's say it like that: I would'nt care if my hacks don't make their way upstream.
07:47:40 <SamB> dcoutts: yeah, it should be -rw-rw-r-- or -rw-rw----, right ?
07:47:51 <dcoutts> SamB: right, the latter
07:48:20 <SamB> I'd check the rest of the htpasswd.dbs to make sure they aren't world readable as well
07:48:33 * mmorrow fires up wget real quick
07:48:44 <jge>  < SamB> I'd check the rest of the htpasswd.dbs to make sure they aren't world readable as well
07:48:47 <jge> 23:48  * mmorrow fires up wget real quick
07:48:58 <mmorrow> :)
07:49:04 <SamB> jge: not that kind of world readable
07:49:15 <dcoutts> SamB: I've fixed the lhc one, I'll check with Igloo before fixing the rest.
07:49:22 <SamB> by "world", I mean "users who can ssh into code.haskell.org"
07:49:50 <SamB> dcoutts: could you also change the owner of our conf/trac.ini to www-data ?
07:50:41 <dcoutts> ksf: that's fine, no need to go to extra effort to have them incorporated but it's easy to darcs send your changes even if you do not think they're of high enough quality to incorporate, it's at least a starting point for someone else
07:50:50 <ksf> dcoutts, some simple macro functianality would be nice, too.
07:51:07 <dcoutts> ksf: it's commonly requested but harder to implement than it looks
07:51:16 <ksf> and, most importantly, the possibilty to define custom renaming functions.
07:51:22 <dcoutts> hmm?
07:51:35 <SamB> dcoutts: thanks for fixing that one, now I changed my password fine
07:51:46 <ksf> as agar uses AG_FunctionFoo, which gets messed up by the standard one.
07:52:54 <dcoutts> ksf: oh you mean the Haskell function gets called aGFunctionFoo ?
07:53:28 <ksf> either FunctionFoo with just prefix dropping, or functionfoo with renaming.
07:53:56 <dcoutts> does it do that even if you don't define any prefix?
07:54:09 <dcoutts> and does importing using 'as' help?
07:54:19 <ksf> then it's agFunctionfoo
07:54:30 <ksf> I'm using that right now, but it's tedious.
07:54:34 <dcoutts> right
07:54:54 <dcoutts> and you want functionFoo
07:54:59 <ksf> ...what I want is functionFoo, as the modules already provide the namespacing.
07:55:08 <dcoutts> I'm not sure why it should lower case the remaining words
07:55:21 <dcoutts> I don't see any benefit to that at all under any convention
07:55:40 <dcoutts> SamB: fixed
07:55:56 <dcoutts> ksf: so I'm sure a patch for that would be appreciated
07:55:58 <ksf> well, it's a good bug to get started with the c2hs source...
08:00:51 <SamB> dcoutts: thanks!
08:01:20 <adrian_> hello
08:01:36 <SamB> now I can set defaults for e.g. the component field from the web UI :-)
08:01:42 <SamB> adrian_: greetings
08:01:43 <adrian_> Is there anything special I need to do in order to have haddock documentation linked on hackage
08:01:50 <SamB> wait!
08:01:51 <adrian_> for my own package
08:01:57 <SamB> that's all
08:02:28 <adrian_> runhaskell Setup.lhs sdist doesn't seem to include any
08:02:37 <adrian_> does hackage build it itself?
08:03:58 * loadquo mucks about with adding OO like functions to data constructors
08:06:22 <byorgey> hm, adrian_ quit already
08:06:25 <dcoutts> ksf: may already be fixed in patches from benedikt
08:07:06 <Twey> loadquo: OO-like functions?
08:07:09 <chessguy> @quote Gracenotes
08:07:09 <lambdabot> No quotes match. Where did you learn to type?
08:07:43 <chessguy> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
08:07:44 <lambdabot>   [[0.0]]
08:08:01 <sw17ch> > let x = 2^65 :: Integer in (toEnum . fromEnum) x :: Integer
08:08:02 <lambdabot>   0
08:08:07 <sw17ch> that bothers me
08:08:42 <vixey> > let x = 2^65 :: Integer in (toEnum . (\x -> x :: Integer) . fromEnum) x :: Integer
08:08:43 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
08:08:47 <byorgey> sw17ch: why?
08:08:50 <vixey> :t toEnum
08:08:51 <lambdabot> forall a. (Enum a) => Int -> a
08:08:54 <vixey> well... there is the problem...
08:09:08 <sw17ch> byorgey, i see why it's that way, but the limits of word width bother me in all machines :)
08:09:28 <loadquo> Twey: Functions you can't access without an instance of the data type.
08:09:29 <byorgey> well, yeah.  the Enum class is silly anyway.
08:09:50 <sw17ch> i think the one that bothers me more is:
08:09:53 <sw17ch> > let x = 2^65 :: Integer in fromIntegral x :: Int
08:09:54 <lambdabot>   0
08:09:57 <Twey> loadquo: How do you do that, then?
08:10:00 <mdmkolbe> Why doesn't the ST monad have a class and methods associated with it (e.g. like State and put/get)?
08:10:04 <vixey> data Foo = Foo
08:10:06 <vixey> data Bar = Foo
08:10:22 <vixey> (Foo.Foo, Bar.Foo) :: (Foo, Bar)
08:10:25 <bohdan> hpaste is down?
08:10:28 <vixey> why not allow that?
08:10:35 <SamB> dcoutts: can you also change the owner of the attachments directory ?
08:10:42 <byorgey> bohdan: looks like it.
08:10:45 <byorgey> @where hpaste2
08:10:45 <lambdabot> I know nothing about hpaste2.
08:10:46 <sw17ch> I would expect an error, or at least the limit of Int... rather than 0..
08:10:51 <sw17ch> but i'm guessing there's good reason :)
08:11:08 <byorgey> bohdan: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:11:17 <loadquo> Twey: Create lambdas when you construct the data type and have the data type accept functions...
08:11:22 <SamB> or perhaps just create ticket and wiki subdirectories with the right owner ...
08:11:30 <byorgey> sw17ch: well, any choice is arbitrary anyway
08:11:30 <loadquo> Not sure how useful it will be.
08:11:40 <bohdan> byorgey: thanks :)
08:11:45 <sw17ch> byorgey, which is why i'd typically think an error would be better :)
08:11:47 <Twey> loadquo: Ah, I see
08:11:52 <Twey> Not very, I would imagine :-P
08:11:59 <byorgey> sw17ch: but then fromIntegral would be partial, which is surely worse.
08:12:21 <dcoutts> SamB: done
08:12:42 * ksf groans
08:12:48 <sw17ch> byorgey, hmmm... complete function... or correct function... i don't know... it seems that could lead to a scary bug
08:12:54 <bohdan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=901#a901 -- I don't understand why this gets a stack overflow
08:12:55 <SamB> hmm
08:12:56 <ksf> there are two "underscoreToCase" functions in the source
08:13:08 <SamB> I wonder if I should have removed the ANSI escapes from this attachment before uploading
08:13:22 <byorgey> sw17ch: if you're converting Integers to Ints and don't think about the possibility of bugs, you probably deserve it either way ;)
08:13:34 <SamB> dcoutts: hmm, maybe you should just chown ALL the files in the whole directory to www-data ?
08:13:37 <sw17ch> byorgey, oh fine.. :P
08:13:43 <SamB> and the directory ?
08:13:59 <SamB> the group seems to stick well enough
08:14:00 <sw17ch> i just had something pop up in my program that says the range of the Int i'm using is outside of the bounds of Word32...
08:14:06 <vixey> sw17ch: fromEnum . toEnum <= id   is that right?
08:14:13 <sw17ch> except there's only one place i use fromEnum, and it's fairly well defined
08:14:53 <byorgey> sw17ch: how could an Int be outside the bounds of a Word32?
08:14:55 <haskfun> hello! i wrote a search: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=902#a902 ... but now I want this with "Query" (look at query') the search should be like: query "q | p" "foop" -> True.. i hope you understand
08:14:55 <byorgey> if it's negative?
08:15:09 <sw17ch> byorgey, on a 64 bit machine
08:15:10 <chessguy> @check \x -> (fromEnum . toEnum) x == x
08:15:11 <lambdabot>   Add a type signature
08:15:17 <byorgey> sw17ch: ah, I see
08:15:22 <SamB> I wonder if it's possible to write a trac plugin to render grin code ...
08:15:27 <sw17ch> it's goofy...
08:15:35 <SamB> well, I mean, to process ANSI color escapes
08:15:51 <bohdan> haskfun: deutsch? :)
08:16:03 <haskfun> Ja
08:16:06 <haskfun> hehe
08:16:08 <SamB> like this one http://trac.haskell.org/lhc/attachment/ticket/8/IntEnum_final.grin#preview
08:16:12 <loadquo> Twey, it mainly makes sense if security is a priority. It allows you do to odd stuff like hiding the constructor of a data type inside the data type, so they can't be created unless you already have an instance of that or another data type.
08:16:25 <SamB> er, like *in* this file
08:16:37 <dcoutts> SamB: done
08:16:37 * byorgey needs to reexamine his duotriakontocentric worldview
08:16:47 <SamB> dcoutts: thanks!
08:16:51 <SamB> sorry to trouble you
08:16:59 <haskfun> bohdan: verstehst du was ich meine?
08:18:13 <byorgey> haskfun: by the way, the way you have defined the Query type is probably not what you want
08:18:30 <byorgey> haskfun: you probably want something like:  data Query = Empty | QStr String
08:18:32 <haskfun> I know that
08:18:33 <gwern> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
08:18:35 <lambdabot>   [[0.0]]
08:18:35 <Zao> Does anyone know what diagrams like http://www.sqlite.org/images/syntax/create-table-stmt.gif are called?
08:18:42 <byorgey> there needs to be a constructor for the String part
08:18:44 <byorgey> haskfun: ok =)
08:18:50 <ozy`> bohdan: still there?
08:18:53 <haskfun> thats why im asking ;)
08:18:56 <bohdan> ozy`: yeah
08:19:12 <gwern> @quote sandtrout
08:19:12 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
08:19:33 <gwern> @remember Cale I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other memories and prescience to rule over everyone and everything for millenia.
08:19:33 <lambdabot> Done.
08:19:33 <centrinia> That looks like the output of ANTLR.
08:19:37 <haskfun> so Query should be able to use a syntax like | or & ... how do i do this?
08:19:44 <ozy`> bohdan: I'm running your program now... waiting for it to overflow
08:20:00 <gwern> @quote $o.o$
08:20:00 <lambdabot> No quotes match. :(
08:20:06 <idnar> 3~/lastlog cale
08:20:07 <ozy`> ah, there it goes
08:20:08 <idnar> oops
08:20:13 <gwern> @remember Gracenotes > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
08:20:14 <lambdabot> Nice!
08:20:18 <gwern> @quote Gracenotes
08:20:18 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
08:20:25 <beelsebob> Zao: looks like BNF ‚Äì only made more "readable"
08:20:30 <dmwit_> ?quote \$o.o\$
08:20:30 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
08:20:31 <gwern> @quote dog house
08:20:32 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
08:20:35 <dmwit_> ?quote $o.o$
08:20:36 <lambdabot> No quotes match. You type like i drive.
08:20:36 <gwern> @quote dog
08:20:36 <lambdabot> blackdog says: <blackdog> kallo, kallay: my gf dragged me along to a ceramics class, and I now have a mug with a lambda on one side and the legend "go away, or i will replace you with a trivial
08:20:37 <lambdabot> lambda expression" on the other.
08:20:43 <gwern> @quote dog
08:20:43 <lambdabot> skew says: I think blackdog is right
08:20:46 <byorgey> haskfun: you probably want to first parse the query string into some sort of representation
08:20:48 <dmwit_> gwern: How can you detect whether that's a duplicate...?
08:21:02 <dmwit_> Oy, I have an underscore again.
08:21:06 <byorgey> haskfun: like  Query = Empty | QLit String | QOr Query Query | ...
08:21:09 <gwern> @forget skew I think blackdog is right
08:21:09 <lambdabot> Done.
08:21:20 <byorgey> haskfun: then write a parser with type  String -> Query
08:21:24 <gwern> dmwit_: how do you mean?
08:21:29 <gwern> @quote house
08:21:29 <lambdabot> No quotes match. Maybe you made a typo?
08:21:31 <loadquo> @quote cale
08:21:31 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
08:21:40 <gwern> @remember rwbarton A type class is not a type just like a dog house is not a dog.
08:21:41 <lambdabot> It is forever etched in my memory.
08:21:50 <dmwit_> gwern: Your original search wouldn't have matched, even if the quote existed.
08:21:51 <gwern> @quote PolynomialDivisionOperatorFactory
08:21:51 <lambdabot> No quotes match. You type like i drive.
08:21:54 <haskfun> ok thats a good advise
08:21:59 <byorgey> haskfun: so, for example,  parse "q | p" === QOr (QLit "p") (QLit "q")
08:22:02 <dmwit_> gwern: Because ?quote takes perl regexen.
08:22:15 <dmwit_> gwern: So ?quote $o.o$ can never match any quote...
08:22:15 <Zao> beelsebob: The term seems to be "syntax diagram" or "railroad diagram"
08:22:17 <bohdan> ozy`: it should overflow immediately
08:22:22 <byorgey> haskfun: and then writing the  query :: Query -> String -> Bool  function should not be too hard
08:22:27 <gwern> dmwit_: I maked you a query, but I escaped it :(
08:22:40 <dmwit_> =/
08:22:49 <gwern> @remember quicksilver or in Java, we'd make it more generic by using a PolynomialDivisionOperatorFactory.
08:22:49 <lambdabot> I will never forget.
08:23:02 <gwern> @quote roconnor
08:23:02 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
08:23:04 <gwern> @quote roconnor
08:23:05 <lambdabot> roconnor says: [after a long -cafe thread on the suckiness of using math terms in Haskell] we don't use Integer anymore. Too abstract. It is now called CountingThingy.
08:23:09 <gwern> @quote roconnor
08:23:09 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
08:23:12 <gwern> @quote roconnor
08:23:12 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
08:23:18 <skorpan> is there any x s.t. x:arbitraryList == arbitraryList?
08:23:20 <byorgey> ah, the traditional weekly HWN quote re-@remember-fest =)
08:23:23 <gwern> @remember roconnor I was going to read about laziness, but I decided to do it later, when I need to understand it.
08:23:23 <lambdabot> It is forever etched in my memory.
08:23:27 <vixey> skorpan, yes repeat
08:23:32 <gwern> byorgey: it is venerable by this point
08:23:34 <gwern> @flush
08:23:48 <skorpan> vixey: x == repeat? :|
08:24:02 <vixey> skorpan, obvious not that doesn't even make sense
08:24:05 <vixey> > repeat x
08:24:06 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
08:24:32 <gwern> byorgey: although I omit the SPJ one because I didn't find it very amusing, and the perl one, while amusing if you know the original, is too verbose
08:24:35 <skorpan> vixey: i don't understand what you mean. i want an x s.t. x:arbitraryList == arbitraryList?
08:24:41 <vixey> skorpan, oh nvm.. you were looking for an 'x' ... that would be head (repeat x)
08:25:02 <Axman6> :t repeat repeat
08:25:03 <lambdabot> forall a. [a -> [a]]
08:25:04 <vixey> skorpan not true in general seeing as  x:[] /= []
08:25:15 <skorpan> vixey: yeah, so there is no such thing.. thanks anyways
08:25:24 <gwern> @ask Cale could you update darcs lambdabot with some fresh state/ goodness?
08:25:24 <lambdabot> Consider it noted.
08:25:39 <loadquo> @quote Cale
08:25:39 <lambdabot> Cale says: But it's not like there's a council of math gnomes which get to decide which definitions everyone uses.
08:25:47 <vixey> skorpan there is if the list is infinite
08:25:49 <Twey> skorpan: The answer is no
08:25:56 <skorpan> vixey: yes, but in general, no
08:25:57 * Twey ponders.
08:26:05 <Twey> Is an infinite list == to anything?
08:26:14 <SamB> of course not
08:26:15 <byorgey> Twey: depends what you mean by == .
08:26:20 <skorpan> Twey: i think he's saying that x:(repeat x) == repeat x
08:26:35 <loadquo> @quote Cale
08:26:35 <lambdabot> Cale says: I should write a program which automatically mods down any article containing the word "Agile"
08:26:41 <Twey> I know what vixey is trying to say, but I don't know that it's true
08:26:44 <SamB> == never gets to the end of it, so can only return False
08:26:50 <byorgey> Twey: if you mean, "does the Eq instance for lists ever return True for an infinite list", the answer is no.
08:26:53 <blenket> @quote spj
08:26:53 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
08:26:57 <Twey> I think there's a strong argument that an infinite list is unequal to anything
08:27:10 <SamB> Twey: I wouldn't say that
08:27:15 <bremner> what about itself?
08:27:17 <SamB> but I would say it's not (Prelude.==) to anything
08:27:20 <byorgey> Twey: but if it's more of a semantic question, then you can define equality for infinite mathematical lists in a sensible way.
08:27:20 <Twey> Even itself
08:27:28 <bremner> that sucks
08:27:28 <Twey> Oh really?
08:27:31 * ksf fixed "underscoreToCase", added a trace to make sure it's returning the Right Thing, added a trace around every other toUpper in the source... and is utterly puzzled by the fact that c2hs outputs a capitalised name for a function.
08:27:32 <byorgey> for example, using bisimulation.
08:27:32 <vixey> Twey, I can never tell when people mean equals, ==, or what they are on about anymore
08:27:33 <Twey> OK, I'll take your word for it, then :)
08:27:55 <mdmkolbe> Is there a way to have a global STRef?  (E.g. like in C I could have a global pointer.)
08:28:10 <Twey> mdmkolbe: Of course
08:28:20 <SamB> if you mean == as some as-yet undetermined coinductive relation ...
08:28:21 * Twey ponders.
08:28:24 <Twey> Actually, not of course.
08:28:37 <SamB> then probably the list is equal to itself
08:28:37 <byorgey> Twey: although the question of whether it's decidable is a different question.
08:28:49 <Twey> If you write foo = newSTRef at the top-level, you'll get an IO which will create a new one each time
08:29:18 <Twey> mdmkolbe: You can do it (more or less) with a Reader monad
08:29:19 <mdmkolbe> Twey: that is exactly what makes this an interesting question
08:29:33 <Twey> It's not truly global, but you can thread it through whatever you want
08:30:02 <mdmkolbe> Twey: true
08:30:12 <skorpan> what was the GHC extension which enabled rank 2-type signatures?
08:30:33 <dmwit> Rank2Types -- just at a guess
08:30:34 <gwern> Rank2Types or RankNTypes?
08:30:39 <skorpan> rank 2 specifically
08:30:41 <ksf> IMNSHO, c2hs should be inherently incapable of outputting invalid function decls like that.
08:31:14 <Roshan> Question) I had exactly the same question. I am trying to simulate a global mutable reference in an ST monad.  I dont want to pass the STRef around manually. Do I need a StateT transformer to thread the references through, or is there some way to do it just using the ST monad?
08:31:36 <dmwit> You can use ReaderT.
08:31:51 <dmwit> But no, I don't think there's a way to do it with pure ST.
08:32:51 <chessguy> am i missing some standard pattern in this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=903#a903
08:33:04 <Twey> Roshan: If you don't need to write stuff, just use Reader(T), don't bother with State(T)
08:33:05 <Roshan> So is it fair to say that State and ST do different things. State gives us "globals" and ST gives us "mutables".
08:33:10 <Twey> Aye.
08:33:29 <Twey> Well... the State 'globals' are also mutable
08:33:31 <ksf> so, if underscoreToCase returns "getError", "GetError" is output, if it returns "geterror", "geterror" is output... WTF?
08:34:04 <mdmkolbe> Roshan: Reader gives us constant (shadowable) globals, while State gives us mutable globals
08:34:11 <Roshan> Twey: dmwit: thanks for the ReaderT suggestion.
08:34:19 <Roshan> Is there any other way to do this other than by using a monad transformer?
08:34:19 <flipflop> hpaste doesn't work?
08:34:42 <Roshan> Twey: true...
08:34:46 <bohdan> >  foldl' (\(c, xs) x -> (c+x, x : xs)) (1, []) . take 1000000 $ repeat 9 -- why does this result in a stack overflow?
08:34:48 <lambdabot>   (* Exception: stack overflow
08:35:05 <bohdan> fold' is strict, right?
08:35:09 <bohdan> *foldl'
08:35:39 <ozy`> bohdan: foldl' is not necessarily quite as strict as you need it to be
08:35:47 <chessguy> @where moonpaste
08:35:47 <lambdabot> I know nothing about moonpaste.
08:35:52 <ozy`> your lambda has to be strict, too
08:36:03 <chessguy> @where hpaste2
08:36:03 <lambdabot> I know nothing about hpaste2.
08:36:06 * chessguy sighs
08:36:15 <ozy`> so \(!c, !xs) x -> (c + z, x : xs)
08:36:19 <chessguy> flipflop:  http://moonpatio.com/fastcgi/hpaste.fcgi/
08:36:26 <ozy`> *c + x
08:37:15 <bohdan> ozy`: I see. thanks :)
08:37:35 <Axman6> @where+ hpaste2 http://moonpatio.com/fastcgi/hpaste.fcgi/new
08:37:35 <lambdabot> Done.
08:37:40 <Axman6> @where hpaste2
08:37:41 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
08:37:56 <ozy`> bohdan: that still might not do it. try profiling if it still gives you trouble >_>
08:38:19 * ozy` is not the most experienced strictness analyst
08:38:22 <bohdan> ozy`: what's the inline comment version of -XBangPatterns ?
08:38:49 <koeien> {-# LANGUAGE BangPatterns #-}
08:38:54 <flipflop> ok... What's wrong with my type declaration here:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=904#a904
08:39:03 <idnar> > f $ g $ x :: Expr
08:39:04 <lambdabot>   Add a type signature
08:39:25 <idnar> > f x
08:39:26 <lambdabot>   Add a type signature
08:39:28 <idnar> > f x :: Expr
08:39:29 <lambdabot>   f x
08:39:36 <idnar> > f (g x) :: Expr
08:39:37 <lambdabot>   Add a type signature
08:39:39 <idnar> meh
08:39:50 <koeien> flipflop: you nead a 'fromIntegral', i think, in the denominator of your 1/... -expression
08:40:00 <koeien> :t fromIntegral
08:40:02 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:40:52 <flipflop> koeien: oh wow..  that did it.  Thank you
08:41:26 <chessguy> @quote fromIntegral
08:41:26 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
08:42:56 <flipflop> koeien: is this because the division expects Integer as denominator given the 1 / ...  ?
08:43:26 <koeien> no, (/) needs a Fractional type, Integer is not a Fractional type
08:44:00 <koeien> :t (/)
08:44:01 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:44:23 <flipflop> aha...  I get it.  Thank you.
08:45:30 <sw17ch> hmm...
08:46:01 <sw17ch> is it possible to do [minBound .. maxBound] :: Word64 on a 32 bit machine?
08:46:05 <sw17ch> err...
08:46:14 <sw17ch> [minBound .. maxBound] :: [Word64]
08:47:38 <dmwit> sw17ch: I think so.
08:48:09 <Axman6> yep
08:48:15 <Axman6> just tried it
08:48:34 <sw17ch> Axman6, can you get the last index?
08:48:42 <Axman6> with !!?
08:48:46 <sw17ch> yessir
08:48:50 <Axman6> nope
08:48:55 <dmwit> No, !! uses Int.
08:48:59 <sw17ch> or anything?
08:49:00 <sw17ch> :)
08:49:02 <dmwit> You're only guaranteed 29 bits for Int.
08:49:02 <Axman6> maxBound :: Word64
08:49:03 <Axman6> 18446744073709551615
08:49:13 <Axman6> i can do !! 100
08:49:14 <sw17ch> > fromEnum maxBound
08:49:15 <lambdabot>   Add a type signature
08:49:21 <sw17ch> > fromEnum (maxBound :: Word64)
08:49:22 <lambdabot>   * Exception: Enum.fromEnum{Word64}: value (18446744073709551615) is outside...
08:49:31 <sw17ch> this is my problem
08:49:34 <sw17ch> :)
08:49:41 <blenket> http://video.google.com/videoplay?docid=-4991530385753299192 , <- watch the animated man
08:50:00 <sw17ch> what about
08:50:10 <dmwit> sw17ch: But you get the same thing on a 64-bit machine.
08:50:13 * Axman6 tries ([minBound .. maxBound] :: [Word64]) !! maxBound 
08:50:14 <sw17ch> > let x = [minBound..maxBound] in (reverse x) !! 0
08:50:15 <lambdabot>   ()
08:50:18 <dmwit> So that's not a 32-bit/64-bit machine problem.
08:50:46 <sw17ch> well, in this case, i'm just having an issue when trying to enumerate IP addresses on a 32bit machine
08:51:15 <sw17ch> http://code.google.com/p/scurry/source/browse/trunk/src/Scurry/Util.hs
08:51:17 <sw17ch> line 43 and below
08:51:27 <sw17ch> the last function on line 74 is what breaks on a 32 bit machine
08:51:38 <sw17ch> i think
08:51:46 <dmwit> Note that I have maxBound :: Int = maxBound :: Word64 `div` 2
08:52:29 <dmwit> So even if you have 64-bit Ints, you have serious problems with the Enum class.
08:52:47 <Axman6> sw17ch: well, that reverse thing used well over a gig of RAM...
08:52:56 <sw17ch> hehe
08:53:01 <sw17ch> before you kill it? :)
08:53:09 <Axman6> yah
08:53:12 <Axman6> in ghci
08:53:18 <sw17ch> yeah, i suppose i could have seen that comming
08:53:21 <sw17ch> coming *
08:53:24 <dmwit> Axman6: 32-bit integers are capable of *indexing* 4 GB.
08:53:49 <dmwit> Storing all of the 32-bit integers therefore takes *at least* 4 GB, even if you can store each one in a byte (which you obviously can't).
08:54:45 <Axman6> sw17ch: any problem with using a 4-tiple of Int8's?
08:55:10 <sw17ch> Axman6, other than i have to do a little more mangling to actually get them used as HostAddr's
08:55:19 <sw17ch> my ScurryAddress is just a newtype around HostAddress
08:55:24 <bohdan> ozy`: no overflows, but it's still way too slow, spends 60% in GC :(
08:55:29 <dmwit> I guess [minBound..maxBound] :: [Word32] would take about 32GB to store.
08:55:42 <diltsman> Anybody know a good place to learn about writting a Yi config file?
08:55:59 <Twey> Axman6: A quadruple?
08:56:02 <vixey> > show (length "[minBound..maxBound] :: [Word32]") ++ " bytes"
08:56:03 <lambdabot>   "32 bytes"
08:56:07 <ozy`> bohdan: you might try using stream fusion techniques, I suppose
08:56:11 <dmwit> diltsman: Oh, good question!
08:56:26 <dmwit> diltsman: I bet there isn't a lot of good documentation for Yi, huh?
08:56:30 <diltsman> I found one site, but it seems to be from Yi 0.3.0.
08:56:32 <bohdan> ozy`: what's that ? :)
08:56:35 <vixey> ?faq can haskell compress 4GB into 32 bytes
08:56:35 <lambdabot> The answer is: Yes! Haskell can do that.
08:56:53 <diltsman> dmwit: As near as I can tell, there is no documentation...other than the code.
08:56:57 <dmwit> diltsman: I bet the best you can do is to look at the source...
08:56:58 <dmwit> yeah
08:57:00 <dmwit> =/
08:57:07 <Zao> vixey: Uncompressing it however...
08:57:18 <vixey> ?faq can haskell uncompress 4GB from 32 bytes
08:57:18 <lambdabot> The answer is: Yes! Haskell can do that.
08:57:26 <Zao> The same 4GB? :)
08:57:34 <Twey> Sure
08:57:37 <icqn> vixey, and 5Gb?
08:57:41 <dmwit> Depends which 4GB you started with.
08:57:54 <Twey> thirtyTwoBytes = 0 :: Int32;
08:58:05 <loadquo> ?faq Can can haskell do everything?
08:58:05 <lambdabot> The answer is: Yes! Haskell can do that.
08:58:08 <Axman6> ok, sleep time for me. before i go, i must say that movable type is awesome as blogging software. so much less hassel compared to wordpress, and it's all static content, so it serves fast
08:58:16 <dmwit> Twey: But that's only 32 bits!
08:58:20 <Twey> fourGigs = thirtyTwoBytes :: RuddyHugeInt;
08:58:24 <Twey> Er, yes
08:58:30 <Twey> Need a new type, then :-P
08:58:37 <ozy`> bohdan: http://book.realworldhaskell.org/read/profiling-and-optimization.html <-- time to start profiling, now that we know it won't crash. this chapter contains everything I know (and all I've forgotten) about optimizing haskell code
08:58:42 <dmwit> RuddyHugeInt =D
08:58:44 <dmwit> Twey++
08:59:10 <Twey> Hahaha
08:59:39 <int80_h> @seen lemmih
08:59:40 <lambdabot> I saw lemmih leaving #haskell 25d 8h 41m 7s ago, and .
08:59:48 <int80_h> yikes
09:00:06 <dmwit> preflex: seen lemmih
09:00:07 <preflex>  lemmih was last seen on #haskell 3 days, 5 minutes and 2 seconds ago, saying: Because they aren't types.
09:00:30 <dmwit> mauke++
09:00:48 <int80_h> why doesn't preflex and lambdabot match?
09:00:55 <dmwit> lambdabot is forgetful
09:01:06 <dmwit> (It crashes a lot, and loses all its state each time.)
09:01:16 <sw17ch> I <3 GeneralizedNewtypeDeriving
09:01:22 <int80_h> he doesn't drone on about the good old days does he?
09:01:29 <dmwit> We need a pokebot that just calls ?flush periodically. =)
09:01:39 <dmwit> int80_h: Well, he wore an onion on his belt...
09:02:23 <int80_h> crap, lemmih's server is timeing out and it's where I do my haskell exercises
09:02:39 <trofi> it's simpler to start one more thread in \bot to flush data
09:03:40 <Twey> int80_h: wget FTW
09:05:01 <Twey> I don't suppose anyone knows what the values of the arguments to Graphics.UI.SDL.Events.MouseMotion mean, do they?
09:06:15 <dmwit> ?hackage sdl
09:06:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sdl
09:07:03 <int80_h> twey: it times out before I can connect
09:07:05 <dmwit> haha nope
09:08:25 <sw17ch> there is something all messed up with how Network.Socket handled byte order...
09:08:34 <sw17ch> i find myself having to mangle things once in a while
09:08:38 <dmwit> Twey: At a guess, it's coordinates in window-space and screen-space.
09:08:47 <sw17ch> that is, if you want to do any sort of work with the addresses used
09:08:58 <sw17ch> in my case, enumerating all of them within a specific network mask
09:09:57 <Twey> dmwit: Word16, Word16, Int16, Int16?
09:10:39 <dmwit> Word/Word for screen coordinates (always positive), Int/Int for window coordinates (in case it's outside the window)
09:11:03 <dmwit> Obviously this is just a guess.
09:11:04 <Deewiant> Twey: have you looked at the SDL docs (as in, the C ones)
09:12:15 <dmwit> http://www.libsdl.org/cgi/docwiki.cgi/SDL_MouseMotionEvent -- probably related
09:13:06 <dmwit> Apparently the signed ones are "relative" coordinates... but they don't say what they're relative to.
09:13:20 <dmwit> How come documentation is so hard?
09:13:20 <Twey> Aha!
09:13:33 <Twey> Hmm, confusing
09:13:38 <Twey> It is a bit
09:13:42 <Deewiant> Relative to the previous position?
09:14:05 <Deewiant> Easy to test out, no? :-P
09:14:05 <Twey> Where does the button state go in the Haskell?  :-\
09:14:18 <Twey> I would imagine relative to the previous position, yeah
09:14:34 <Twey> I see... Word16is an unsigned Int16, huh
09:14:41 <Twey> Word16 is**
09:14:45 <dmwit> yes
09:14:56 <Twey> But what about the state member?
09:15:07 <mmorrow> sw17ch: it'd be nice if there was a as-thin-as-possible-ffi-binding useable as an alternative to Network.Socket
09:15:52 <sw17ch> mmorrow, yeah, but i'm guessing that's really hard with Windows tossed in there
09:16:52 <mauke> sw17ch: are you using the PortNum data constructor anywhere?
09:16:53 <mmorrow> last week i wanted to be able to use accept nonblockingly, but the current lib turns that into an exception, and it's a total pain in the ass to deal with all the structs/etc (i considered writing my own for about 10 minutes and quit)
09:17:22 <mmorrow> sw17ch: ugh, i wasn't even considering windows and it still didn't look that painless
09:17:57 <sw17ch> mmorrow,
09:17:59 <sw17ch> woops
09:18:09 <sw17ch> i'm using HostAddress and PortNum
09:18:25 <sw17ch> newtype SA = SA HostAddress deriving (Num)
09:18:27 <sw17ch> FAILS
09:18:30 <mmorrow> and also if you just want the Socket's Fd, there's an MVar in the Socket (not that this matters, but since i only want the Fd i'd rather not be creating all these MVars)
09:18:37 <sw17ch> with GeneralizedNewtypeDeriving
09:18:43 <mauke> sw17ch: stop using PortNum
09:18:44 <sw17ch> because it fails to take into account the byte order
09:19:13 <sw17ch> mauke, what should be used instead?
09:19:24 <mauke> fromIntegral or nothing
09:20:03 <dmwit> sw17ch: Notice the Num instance? ;-)
09:20:12 <sw17ch> on HostAddress?
09:20:19 <dmwit> 22 :: HostAddress
09:20:28 <dmwit> wait
09:20:30 <dmwit> :t PortNum
09:20:31 <lambdabot> Not in scope: data constructor `PortNum'
09:20:38 <rwbarton> It seems like a bug that the PortNum constructor is exported at all
09:20:41 <sw17ch> > (22 :: HostAddress) + 1
09:20:42 <lambdabot>       Not in scope: type constructor or class `HostAddress'
09:20:46 <mmorrow> type HostAddress = GHC.Word.Word32      -- Defined in Network.Socket
09:21:17 <dmwit> rwbarton: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg17778.html
09:21:36 <dmwit> sw17ch: 22 :: PortNumber -- this is what I meant
09:21:36 <sw17ch> i think it's a problem that if i want to do any sort of address generation i need to call out to Data.Binary to make things happy
09:21:43 <koeien> hmm, i've never noticed the Num instance and used PortNum in the past :/
09:21:49 <sw17ch> or get the bytes in the right order
09:22:01 <mmorrow> just get your Data.Bits on?
09:22:25 <mauke> PortNum is a trap
09:22:29 <mmorrow> heh
09:22:33 <rwbarton> dmwit: I wonder whether anyone has made a libraries proposal
09:22:46 <dmwit> gah, wrong again
09:23:14 <dmwit> 22 :: PortNumber -- final try, this time after looking at the documentation
09:23:54 <dmwit> It's really confusing that PortNumber is a constructor for a type other than PortNumber.
09:24:20 <mmorrow> @remember mauke PortNum is a trap
09:24:20 <lambdabot> I will never forget.
09:24:33 <mauke> @slush
09:24:33 <lambdabot> Not enough privileges
09:24:46 <mmorrow> @slinky
09:24:46 <lambdabot> Unknown command, try @list
09:25:03 <mmorrow> @help slush
09:25:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:25:07 <vixey> @nixin
09:25:08 <lambdabot> The press is the enemy.
09:25:18 <mmorrow> @. vixen nixon
09:25:19 <lambdabot> good? not great?
09:25:25 <mauke> @vixey
09:25:25 <lambdabot> You think this is a botiecall??
09:25:39 <mmorrow> @. elite nixon
09:25:40 <lambdabot> iph y0U +hINK 7he uNITed s7A7es |-|aS z70OD $ti1|, \/\/hO buIlt T|-|e |ARgEs7 SH0PPING cENter IN tHE \/\/0R|d?
09:25:42 <vixey> @keal
09:25:42 <lambdabot> bot defective
09:25:46 <vixey> @keal
09:25:46 <lambdabot> need to plan a fieldtrip to Frederick B. Mancoff of Freescale Semiconductor
09:25:48 <vixey> @keal
09:25:48 <lambdabot> i can explain why something is without knowing what the rules decided by man are
09:25:57 <mmorrow> @. vixen . elite nixon
09:25:57 <lambdabot> in to
09:26:05 <vixey> @vixey
09:26:05 <lambdabot> Sex is the mysticism of materialism and the only possible religion in a materialistic society.
09:26:44 <mauke> @slush
09:26:50 <vixey> @shoosh
09:26:50 <lambdabot> Choose between what?
09:27:30 <mmorrow> @nixon
09:27:30 <lambdabot> I can see clearly now... that I was wrong in not acting more decisively and more forthrightly in dealing with Watergate.
09:27:37 <mauke> @msg #haskell pwnd
09:27:37 <lambdabot> pwnd
09:27:47 <vixey> @msg #haskell sloosh
09:27:47 <lambdabot> Not enough privileges
09:29:03 * sw17ch wishes for peekMVar
09:29:11 <sw17ch> @index peekMVar
09:29:11 <lambdabot> bzzt
09:29:16 <sw17ch> k, just making sure
09:29:30 <mauke> :t tryTakeMVar
09:29:31 <lambdabot> Not in scope: `tryTakeMVar'
09:29:40 <mauke> @index tryTakeMVar
09:29:40 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
09:31:12 <icqn> i am doing the exercises from the haskell the real world, can load in ghci a file ch3/Nullable.hs with a line: data Maybe t = Just t | Nothing, and overload existing Maybe, that ghci does not complain?
09:31:16 <mauke> sw17ch: well, there's always TMVar
09:31:43 <sw17ch> @index readMVar
09:31:43 <lambdabot> Control.Concurrent.MVar, Control.Concurrent
09:32:01 <sw17ch> doh!
09:32:04 <sw17ch> there it is
09:32:33 <mauke> icqn: yeah, start Nullable.hs with 'import Prelude hiding (Maybe(..))'
09:32:56 <felix_> Hi, i m learning haskell at the university. is there a good free haskell compendium?
09:33:24 <mauke> @where lyah
09:33:24 <lambdabot> www.learnyouahaskell.com
09:33:28 <mauke> @where rwh
09:33:28 <lambdabot> is http://www.realworldhaskell.org/blog/
09:33:35 <mauke> @where yaht
09:33:35 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:33:50 <dmwit> ?where gentle
09:33:50 <lambdabot> http://www.haskell.org/tutorial/
09:33:56 <mauke> heh
09:33:59 <dmwit> Yeah!
09:34:05 * dmwit high fives all  around
09:34:16 <icqn> mauke, and with :load Nullable.hs  + something? or what do you mean with start? import this line?
09:34:17 <felix_> thanks
09:34:29 <ozy`> basically there are (last [1..]) haskell tutorials
09:34:57 <mauke> icqn: put the import line in the Nulllable.hs file, at the top
09:35:34 <felix_> i m looking specifically for the data definitions
09:35:47 <mauke> which data definitions?
09:35:52 <felix_> for example data List a = Nil | Cons a (List a) deriving Show
09:36:00 <mauke> doesn't exist
09:36:07 <doserj> where report
09:36:10 <vixey> here: data List a = Nil | Cons a (List a) deriving Show
09:36:11 <doserj> @where report
09:36:12 <lambdabot> http://www.haskell.org/onlinereport/
09:36:22 <mauke> @where lib
09:36:22 <lambdabot> I know nothing about lib.
09:36:28 <mauke> @where+ lib http://haskell.org/ghc/docs/latest/html/libraries/
09:36:28 <lambdabot> It is forever etched in my memory.
09:37:22 <felix_> I dont understand what s this "Cons" for.
09:37:36 <mauke> it's a data constructor
09:37:57 <vixey> felix_, to build up and tear down parts of a 'List'
09:37:59 <h0tzenpl0tz> anyone tried f#?
09:38:08 <felix_> ah okay
09:38:08 <mauke> you use it to create values of type List a, and (in pattern matching) to get at a List's contents
09:38:15 <haskfun> hello, im not that far, but why the last ine does not work? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=905#a906
09:38:23 <icqn> mauke, Thank you.
09:38:53 <felix_> and the name "Cons" is arbitrary?
09:39:04 <mauke> felix_: yes
09:39:20 <dmwit> haskfun: Query and String are not the same type.
09:39:21 <rwbarton> felix_: Arbitrary, but also traditional
09:39:39 <mauke> felix_: in general, it's data YOURTYPENAMEHERE param1 param2 param3 ... = CONSTRUCTOR1 Type1 Type2 ... | CONSTRUCTOR2 Type1 Type2 ... | ...
09:40:18 <dmwit> haskfun: You'll likely end up mildly disappointed with your (parse "p | q" = ...) line, too. =P
09:40:31 <felix_> mauke: and what is paramX?
09:40:39 <haskfun> thats just a test case
09:40:42 <true\false> Question .. Why does (1:(2:[])) become a list, not a tuple?
09:40:51 <mauke> felix_: identifiers starting with lowercase letters. they're type variables.
09:40:59 <rwbarton> :t (:)
09:41:00 <dmwit> true\false: (:) and [] are the list constructors.
09:41:00 <lambdabot> forall a. a -> [a] -> [a]
09:41:00 <idnar> true\false: no commas
09:41:16 <dmwit> true\false: Basically the answer to your question is, "because".
09:41:17 <mauke> felix_: e.g. Cons 'x' Nothing is a List Char, while Cons 1 (Cons 2 Nothing) is a List Integer
09:41:18 <rwbarton> (1:(2:[])) is the same as (:) 1 ((:) 2 [])
09:41:20 <vixey> true\false,  (1,(2,()))  is the tuple
09:41:28 <haskfun> dmwit: Ok, but how do I compare than query and the String?
09:41:38 <true\false> Right.. So I'm guessing : is an operator or some sort
09:41:48 <trofi> :t (:)
09:41:48 <vixey> (:) is an infix constructor
09:41:49 <lambdabot> forall a. a -> [a] -> [a]
09:41:53 <mauke> true\false: it's even a constructor :-)
09:42:00 <dmwit> haskfun: Pattern match on the query, as you did earlier.
09:42:05 <mauke> (that means it's an operator with superpowers)
09:42:08 <felix_> mauke: thanks i ll play a bit with that
09:42:17 <beelsebob> true\false: the real question is actually, why does [1,2,3] become a list, not a tuple
09:42:19 <trofi> > (:) 1 []
09:42:20 <lambdabot>   [1]
09:42:21 <dmwit> haskfun: There's two "Query" constructors that you don't have cases for yet, so start your matches there.
09:42:26 <beelsebob> and the answer is that [1,2,3] is syntactic sugar
09:42:34 <beelsebob> for (1 : (2 : (3 : [])))
09:43:03 <true\false> Hmm ok.. So that I follow. and I presume [] marks the end of array?
09:43:04 <dmwit> I guess the real question is: why would you expect 1:2:[] to turn into a tuple?
09:43:06 <true\false> * list
09:43:18 <trofi> [] == Null
09:43:24 <trofi> Nil
09:43:27 <vixey> trofi, what?
09:43:32 <dmwit> true\false: Yes, [] marks the end of a list.
09:43:33 <true\false> dmwit: Idiocy? Who knows..
09:43:38 <mauke> true\false: yes, [] is a special value (like :)
09:43:44 <dmwit> true\false: Actually, [] is an empty list.
09:43:53 <dmwit> true\false: But "marks the end of a list" is a fine way to think of it, too.
09:43:55 <trofi> regarding > 19:35:40 < vixey> here: data List a = Nil | Cons a (List a) deriving Show
09:44:16 <vixey> still doesn't make sense
09:44:18 <true\false> Heh, maybe I'll understand that better once I get to actually coding in haskell
09:44:32 <beelsebob> true\false: have you yet defined any data types?
09:44:58 <true\false> Sure.. Like data Student = Student Int String ?
09:45:21 <beelsebob> okay, well, list is defined like this... data List a = Cons a (List a) | Nil
09:45:27 <beelsebob> but with rather shorter constructors
09:45:34 <zkincaid> hey - does anyone know if there has been any more work on type-indexed coproducts since the HList paper?
09:45:39 <mauke> data [] a = (:) a ([] a) | []
09:45:39 <beelsebob> data [a] = (:) a [a] | []
09:45:46 <vixey>  type-indexed coproducts o_o
09:46:01 <vixey> zkincaid, is that like ocaml?
09:46:14 <rwbarton> , src ''[]
09:46:17 <lunabot>  data [] a = [] | a `(:)` ([a])
09:46:27 <vixey> O_o `(:)`
09:46:32 <vixey> @src []
09:46:32 <lambdabot> data [] a = [] | a : [a]
09:46:38 <rwbarton> yeah, that's a fail
09:46:45 <true\false> beelsebob: Hrm, perhaps this is a stupid question .. Is that recursive?
09:46:52 <beelsebob> true\false: yes
09:47:00 <chessguy> @type foldr
09:47:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:47:18 <beelsebob> that's what makes it able to have any length
09:47:32 <true\false> Ahha, that's interesting..
09:48:17 <tjb> hpaste has been down for awhile.  Any idea when it will be back?
09:48:31 <Saizan> @get-shapr
09:48:32 <lambdabot> shapr!!
09:49:00 <true\false> beelsebob: Oh now I see it, gah.. I forgot about the : for use in adding to lists
09:50:28 <CakeProphet> > factors 100
09:50:29 <lambdabot>   Not in scope: `factors'
09:52:00 <mauke> is it me or do we have quite a few germans in here?
09:52:18 <Heffalump> in proportion to what?
09:52:20 <CakeProphet> > let factors x = 1 : filter (==0).(`mod` 0) [2..x `div` 2] : x in factors 100
09:52:21 <lambdabot>   Couldn't match expected type `a1 -> [a]'
09:52:21 <zkincaid> vixey: I'm not sure what you mean.  The HList paper introduced (among other things) a way of implementing type-indexed coproducts in Haskell - does ocaml have a nice way of doing type-indexed coproducts?
09:52:35 <Heffalump> I expect there's quite a few americans in here, but then there's quite a few of them in the world as a whole
09:52:45 <vixey> zkincaid, oh I was asking to confirm I understand what you meant -- but if you don't know ocaml then that wont work
09:52:50 <CakeProphet> > let factors x = 1 : filter ((==0).(`mod` 0)) [2..x `div` 2] : x in factors 100
09:52:51 <lambdabot>       Occurs check: cannot construct the infinite type: a = [[a]]
09:52:51 <lambdabot>        Expe...
09:52:57 <vixey> zkincaid, why are you interested in this ?
09:53:08 <vixey> zkincaid, I mean are there some programs you can't type in haskell without this?
09:54:02 <CakeProphet> > let factors x = 1 : (filter (\n -> n `mod` x == 0) [2..x `div` 2]) : x in factors 100
09:54:03 <lambdabot>       Occurs check: cannot construct the infinite type: a = [[a]]
09:54:03 <lambdabot>        Expe...
09:54:20 <CakeProphet> > let factors x = 1 : (filter (\n -> n `mod` x == 0) [2..x `div` 2]) ++ [x] in factors 100
09:54:21 <lambdabot>   [1,100]
09:54:26 <CakeProphet> ...lolno
09:54:35 <vixey> :t divMod
09:54:37 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:54:49 <CakeProphet> :t divMod 100 5
09:54:50 <lambdabot> forall t. (Integral t) => (t, t)
09:54:56 <CakeProphet> > divMod 100 5
09:54:57 <lambdabot>   (20,0)
09:55:16 <CakeProphet> vixey:  any reason I would use that?
09:55:32 <jad4> how do you guys do the ++ symbol in latex?
09:55:44 <jad4> richard bird style
09:56:02 <rkstr> type two pluses
09:56:09 <Badger> +
09:56:10 <Badger> +
09:56:18 <bremner> jad4: use lhs2TeX ?
09:56:21 <CakeProphet> > let factors x = 1 : (filter (\n -> n `mod` x == 0) [2..x `div` 2] ++ [x]) in factors 100
09:56:23 <lambdabot>   [1,100]
09:56:33 <vixey> , let  prime n = factors n == [n];  primes = 2 : filter prime [3, 5..];  factors 0 = []; factors (divisor primes -> (factor, remainder)) = factor : factors remainder;  divisor (x:xs) i | x*x > i = (i, 0) | (r, 0) <- divMod i x = (x, r) | otherwise = divisor xs  in  factors 100
09:56:34 <lunabot>  luna: Couldn't match expected type `(t, t)'
09:56:37 <CakeProphet> > let factors x = 1 : (filter (\n -> x `mod` n == 0) [2..x `div` 2] ++ [x]) in factors 100
09:56:38 <lambdabot>   [1,2,4,5,10,20,25,50,100]
09:56:41 <CakeProphet> there we go
09:56:44 <chessguy> is there some data structure into which i can insert without duplication in constant or logarithmic time?
09:56:59 <chessguy> (i.e., i want the insert to take care of making sure duplication doesn't happen)
09:57:00 <CakeProphet> Data.Set I believe
09:57:02 <Deewiant> Data.Set?
09:57:14 <jad4> bremner,  I can, but  it's a bit overkill for what I want now :S
09:57:24 <CakeProphet> chessguy:  it's basically a hash table with no keys. insert and membership tests are constant time.
09:57:32 <vixey> jad4,  does it work or not?
09:57:33 <jad4> bremner,  the ++ would be sufficient
09:57:37 <jad4> vixey, nope
09:57:37 <mauke> it's a search tree, not a hashtable
09:57:40 <zkincaid> Ôªøvixey: yeah, I'm trying to write an extensible interpreter (a la monad tranformers and modular interpreters), and it would be convenient to be able to inject values into type indexed coproduct
09:57:44 <skorpan> why can't you write type signatures with "don't care" terms? e.g. fst :: (a, _) -> a?
09:57:46 <jad4> vixey, gives 2 pluses
09:57:48 <chessguy> ah, nice
09:58:05 <vixey> zkincaid, probably just use GADTs then
09:58:29 <vixey> zkincaid, you can sort of tie the knot with data definitions, but doing a universe might be easier
09:58:46 <Peaker> skorpan: because no-one implemented it yet :)
09:59:08 <CakeProphet> > let factors x = 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x]; isPrime n = factors n == [1, n] in (factors 7, isPrime 7)
09:59:09 <lambdabot>   ([1,7],True)
09:59:13 <skorpan> Peaker: okay, so there is no underlying hindley-milner, or whatever the name was, here...
09:59:26 <zkincaid> vixey: are GADTs extensible?  I thought once I definition for a data type, it was fixed
09:59:35 <Peaker> skorpan: there shouldn't be a problem, in principle, afaik
09:59:49 <CakeProphet> > let factors x = 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x]; isPrime n = factors n == [1, n] in filter (isPrime) [1..]
09:59:50 <lambdabot>   [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
10:00:24 <CakeProphet> > let factors x = 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x]; isPrime n = factors n == [1, n] in filter (isPrime) [98..]
10:00:25 <lambdabot>   [101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,19...
10:00:38 <Saizan> zkincaid: they aren't
10:00:41 <CakeProphet> > let factors x = 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x]; isPrime n = factors n == [1, n] in filter (isPrime) [10000..]
10:00:43 <lambdabot>   [10007,10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10...
10:00:45 <byorgey> skorpan: IIRC, someone actually proposed exactly this on a mailing list recently
10:00:57 <skorpan> byorgey: oh, cool
10:01:00 <ozy`> zkincaid: you could use typeclasses, I suppose....
10:01:09 <vixey> byorgey, do you think it will be implemented?
10:01:14 <chaoslynx> hi, i get the following error, when compiling some example code: e variable `e' in the constraint: `Exception e'
10:01:22 <CakeProphet> -shrug- I've honestly never minded making my type variable explicit.
10:01:23 <zkincaid> Saizan, interesting... I'll read up on them
10:01:34 <byorgey> vixey: I've no idea.
10:01:42 <byorgey> maybe I should try =)
10:01:47 <Saizan> zkincaid: i meant that they are not extensible
10:02:20 <zkincaid> Saizan: oh... heh.  Ok thanks
10:02:48 <Saizan> zkincaid: data families are extensible, but you can't pattern match against them liberally
10:02:51 <Deewiant> aw, I was just about to answer him
10:02:51 <CakeProphet> I suppose _ would be universal quantification?
10:03:08 <loadquo> @hoogle (Monad m) => (m a, m a) -> m (a, a)
10:03:08 <lambdabot> No results found
10:03:40 <Deewiant> ?ty uncurry (liftM2 (,))
10:03:42 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
10:04:29 <bohdan> > [] == [] -- why does this work?
10:04:30 <lambdabot>   True
10:04:34 <doserj> CakeProphet: no. I guess _ should mean that type checking shouldn't care what type inferencde infers at this position
10:04:40 <Deewiant> bohdan: why not?
10:04:55 <CakeProphet> doserj:  so it could be either?
10:04:55 <ziman> because an empty list is equal to an empty list :)
10:04:58 <bohdan> Deewiant: what would be the type of (==) that is being used?
10:05:00 <ozy`> zkincaid: if you define your interpreter to operate on typeclasses instead of a data type, you can access the data values with class methods, and then your API's consumers can extend the interpreter by creating instances
10:05:01 <loadquo> Deewiant: That should do, thanks.
10:05:05 <mauke> bohdan: extended defaulting
10:05:13 <Saizan> bohdan: it's defaulting to [] :: [()]
10:05:40 <bohdan> mauke, Saizan, where is this documented?
10:05:49 <ddarius> bohdan: In the GHC user guide.
10:06:03 <doserj> CakeProphet: so if type inference would find out that fst actually has type fst :: (a,String) -> a, instead of fst::(a,b) -> a, it wouldn't give an error
10:06:12 <mauke> bohdan: http://haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
10:06:32 <bohdan> thanks
10:06:32 <vixey> zkincaid, this what I meant by tie a knot: http://www.haskell.org/sitewiki/images/4/44/Interp3.lhs
10:06:42 <CakeProphet> zkincaid: doserj  ...it wouldn't give an error anyways.
10:06:44 <CakeProphet> er
10:06:48 <vixey> zkincaid, but again just picking a fixed universe is probably easier
10:06:53 <CakeProphet> directed at doserj, not zkincaid.
10:06:58 <Deewiant> CakeProphet: yes, it would.
10:07:06 <zkincaid> ozy`: It does operate on typeclasses (like monad transformer and modular interpreters) - class (Monad m) => Interp t m v | t -> v where interp :: t -> m v
10:07:06 <CakeProphet> if fst :: (a, b) -> a
10:07:32 <Deewiant> > let f :: (a,b) -> a; f (a, b) = const (b ++ "") a in f (1,"foo")
10:07:33 <lambdabot>   Couldn't match expected type `a' against inferred type `[Char]'
10:07:38 <Deewiant> CakeProphet: see error ^
10:07:38 <zkincaid> I have no problem extending t - that's straightforward I've seen it done a bunch of times.  Extending v is giving me trouble.
10:07:40 <doserj> CakeProphet: we are considereing a type signature of fst :: (a,_) -> a
10:07:46 <Deewiant> oh wait, oops
10:07:50 <tjb> I can't figure out how to write a recursive function of mine that returns "Maybe [a]" instead of "[a]".  Any ideas? http://haskell.pastebin.com/d4f05f61f
10:07:53 <Deewiant> > let f :: (a,b) -> a; f (a, b) = flip const (b ++ "") a in f (1,"foo")
10:07:55 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `b'
10:07:59 <Deewiant> CakeProphet: that error ^
10:08:06 <CakeProphet> Deewiant:  ooooh, right.
10:08:11 <Deewiant> > let f :: (a,String) -> a; f (a, b) = flip const (b ++ "") a in f (1,"foo")
10:08:13 <lambdabot>   1
10:08:22 <Deewiant> CakeProphet: so basically I think what he wants is for the _ to be inferred
10:08:28 <CakeProphet> Deewiant:  if the implementation of the function didn't allow b to be polymorphic, then _ wouldn't error in that case.
10:08:43 <Deewiant> yeah.
10:08:56 <zkincaid> vixey: yes, I'm using that approach for extending the language for, say, addition as well as multiplication - I'm having trouble figuring out how to extend the values as well
10:09:06 <CakeProphet> it would just be telling the compiler that I know what types I want here and here, but go ahead and figure out what _ is for me.
10:09:08 <mauke> tjb: '= []' -> '= Just []',  '= [] -- ERROR' -> 'Nothing'
10:09:35 <mauke> tjb: and the recursive calls need fmap (x1 :) (hdlc_byte_destuff xs)
10:09:59 <CakeProphet> > let factors x = 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x]; isPrime n = factors n == [1, n] in filter (isPrime) [10000000..]
10:10:06 <CakeProphet> :#
10:10:14 <lambdabot>   thread killed
10:10:18 <tjb> mauke: fmap oh.  Let me take a look
10:10:33 <mauke> tjb: well, you could do it without fmap, but I think this is the shortest way :-)
10:11:03 <icqn> Do you use vim for writing haskell code, and if so how do you deal with indent?
10:11:13 <mauke> yes, manually
10:11:20 <mauke> well, :set ai
10:11:22 <Deewiant> icqn: vim.org has a haskell filetype script better than the default
10:11:26 <bohdan> icqn: yes, ^T/^D
10:11:39 <tjb> mauke: "Functor" map, interesting
10:11:40 <Deewiant> it still messes stuff up occasionally though
10:11:43 <chessguy> ugh, i'm so sure that forward chaining is some kind of fold, but i can't seem to make it work in my brain
10:11:45 <CakeProphet> :t factors x = 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x]
10:11:47 <lambdabot> parse error on input `='
10:11:52 <Deewiant> but a lot less than the default
10:11:59 <mauke> tjb: Maybe is just a list of at most 1 element
10:12:06 <mauke> tjb: fmap is a generic map
10:12:16 <icqn> Debolaz, Do you mean this one http://www.vim.org/scripts/script.php?script_id=1968 ?
10:12:24 <tjb> mauke: interesting, thanks
10:12:28 <CakeProphet> :t (\x -> 1 : (filter (\n -> x`mod` n == 0) [2..x `div` 2]) ++ [x])
10:12:30 <lambdabot> forall a. (Integral a) => a -> [a]
10:12:34 * tjb will be looking at mauke's suggestion for a min
10:12:40 <CakeProphet> Integral is kind of a nice typeclass. It lets you use Integer for large numbers without sacrificing the efficiency of Int for smaller values.
10:12:40 <Deewiant> icqn: probably yes, there are only two and one of them says it's better than the default :-P
10:13:00 <CakeProphet> same for Floating I guess but with Float and Double.
10:16:36 <CakeProphet> > lol x n = (lol x n) ++ x in lol "This is a very inefficient way to repeat a string multiple times." 100
10:16:38 <lambdabot>   <no location info>: parse error on input `='
10:16:46 <CakeProphet> > let lol x n = (lol x n) ++ x in lol "This is a very inefficient way to repeat a string multiple times." 100
10:16:48 <lambdabot>   "* Exception: stack overflow
10:17:05 <CakeProphet> > let lol x n = (lol x (n-1)) ++ x in lol "This is a very inefficient way to repeat a string multiple times." 100
10:17:07 <lambdabot>   "* Exception: stack overflow
10:17:13 <CakeProphet> ha, didn't even matter.
10:17:35 <mauke> infinite recursion does that
10:17:45 <Deewiant> CakeProphet: base case
10:17:46 <Lemmih> CakeProphet: You don't have a base case.
10:17:55 <CakeProphet> > let lol x 0 = x; lol x n = (lol x (n-1)) ++ x in lol "This is a very inefficient way to repeat a string multiple times." 100
10:17:57 <lambdabot>   "This is a very inefficient way to repeat a string multiple times.This is a...
10:17:58 <mauke> all your base case are belong to us
10:18:15 <CakeProphet> > let lol x 0 = ""; lol x 1 = x; lol x n = (lol x (n-1)) ++ x in lol "This is a very inefficient way to repeat a string multiple times." 1000
10:18:16 <lambdabot>   "This is a very inefficient way to repeat a string multiple times.This is a...
10:18:32 <CakeProphet> :(
10:19:17 <Deewiant> > let lol x 0 = ""; lol x 1 = x; lol x n = (lol x (n-1)) ++ x in map head $ [lol "This is a very inefficient way to repeat a string multiple times." n | n <- [1000,2000..]]
10:19:33 <lambdabot>   thread killed
10:19:37 <Deewiant> meh
10:20:30 <CakeProphet> so, I'm still having a hard time understanding existential quantification in Haskell
10:21:04 <CakeProphet> is basically a constraint that says that "lol this type can represent an arbitrary type, but only one of them."
10:21:09 <CakeProphet> *type variable
10:22:40 <cha0xz> ello
10:23:16 <inv2004> hi all
10:24:48 <jeffwheeler> Would it be logical to say that all (or most?) functions in Haskell are "universally quantified"?
10:24:55 <jeffwheeler> If so, then what would be existentially so?
10:25:29 <CakeProphet> Deewiant:  in f :: (a,b) -> a; f (a, b) = flip const (b ++ "")  ....would f :: forall a. exists b. (a, b) -> a   fix the type signature of f?
10:26:44 <Deewiant> Possibly, if 'exists' were valid haskell ;-)
10:27:12 <CakeProphet> jeffwheeler:  there exists no functions in Haskell that are existentially qualified. :D
10:27:32 <jeffwheeler> CakeProphet: that makes sense, but then why do people always talk about it?
10:27:42 <ksf> dcoutts, I currently use http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=907#a907 as flag implementation, the problem with enums is that an .&. of two can't be a member of that enum without getting excessive. any thoughts?
10:27:43 <CakeProphet> it's apparently going into Haskell`
10:27:56 <jeffwheeler> CakeProphet: weird, I wonder how that'll work
10:28:05 * jeffwheeler looks up the proposal
10:28:23 <rwbarton> Existential quantification is what happens when you match against a universally quantified data constructor
10:28:30 <CakeProphet> jeffwheeler: (I supposed you've have to assume that not "universall quantified" = "existentially quantified")
10:28:45 <paper_cc> can anyone explain Conrol.Morphism.Cata ... or just give a simple example?
10:28:48 <Olathe> ksf: The section of RWH on conversing with C code has a nice solution for that.
10:28:58 <rwbarton> , src 'cata
10:29:01 <lunabot>  cata :: forall c f . Functor f => (f c -> c) -> Mu f -> c
10:29:08 <CakeProphet> otherwise the negation would be there exists no functions in Haskell that are not universally quantified.
10:29:09 <ksf> in a nutshell, exists allows you to pass any Num into a Num a => [a]
10:29:15 <ksf> polymorphic, that is.
10:29:24 <memento> Im trying to use Error Monad like this: http://rafb.net/p/q5wjKq34.html but i'm getting an error what i can't figure out, can someone help?
10:29:54 <rwbarton> , src ''Mu
10:29:57 <lunabot>  newtype Mu f = Mu (f (Mu f))
10:30:21 <Olathe> @type strMsg
10:30:23 <lambdabot> forall a. (Error a) => String -> a
10:30:32 <ksf> ...that's about the only chapter of RWH I didn't read yet.
10:30:38 <rwbarton> , let len = cata (maybe 0 (+1)) in len $ Mu (Just (Mu (Just (Mu Nothing))))
10:30:40 <lunabot>  2
10:30:50 <rwbarton> paper_cc: ^^
10:31:14 <dcoutts> ksf: since it's a set of flags then represent it by a record of bools and convert to an intt in the Flag instance ?
10:31:21 <Olathe> @src MonadError
10:31:22 <lambdabot> class (Monad m) => MonadError e m | m -> e where
10:31:22 <lambdabot>     throwError :: e -> m a
10:31:22 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
10:31:42 <paper_cc> memento: you forgot to deconstruct your SemanticError in handler'
10:32:13 <memento> ohh, with Left?
10:32:13 <paper_cc> it should read handler' (Err e) = error e
10:32:27 <memento> mm
10:33:30 <ksf> actually, I like the RWH solution of passing a list of flags.
10:33:34 <paper_cc> rwbarton: I didn't understand Mu actually =(
10:33:42 <Deewiant> ?src Mu
10:33:43 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:33:54 <ksf> records of bools tend to get confusing wrt. position of things.
10:34:16 <CakeProphet> @hoogle (a ->b -> c) (a -> b -> d) (c,d)
10:34:17 <lambdabot> No results found
10:34:20 <CakeProphet> hmmm...
10:34:20 <ksf> ...with 31 bools, things get a bit messy.
10:34:24 <memento> paper_cc: thx, it works now
10:35:04 <memento> paper_cc: but why is that he doesn't need to reconstruct it?: http://www.haskell.org/all_about_monads/examples/example12.hs
10:35:34 <chessguy> @pl i x xs = nub (x:xs)
10:35:34 <lambdabot> i = (nub .) . (:)
10:36:00 * ksf wants {#enum define#} now, and pulls the sources
10:36:28 <paper_cc> memento: well he does need to deconstruct (if you mean printError) - using location and reason
10:36:40 * chessguy keeps seeing this (f .) . g pattern from @pl
10:36:42 <chessguy> seems useful
10:37:02 <chessguy> @pl \f g -> (f .) . g
10:37:02 <lambdabot> (.) . (.)
10:37:18 <paper_cc> memento: you could use data SemanticError = Err { semanticMsg :: String }, then handler' = error . semanticMsg
10:37:32 <paper_cc> or, equivalently, handler' e = error $ semanticMsg e
10:37:58 <chessguy> @type let (:.) = ((.).(.)) in (:.) nub (:)
10:37:59 <lambdabot> Not in scope: data constructor `:.'
10:37:59 <lambdabot> Not in scope: data constructor `:.'
10:38:01 <memento> ok thx
10:38:39 <chessguy> @type let ($.) = ((.).(.)) in ($.) nub (:)
10:38:40 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:39:03 <Deewiant> chessguy: .: is what it's usually called
10:39:14 <chessguy> ah
10:39:21 <chessguy> @hoogle (.:)
10:39:21 <lambdabot> Warning: Unknown type .:
10:39:21 <lambdabot> Prelude undefined :: a
10:39:21 <lambdabot> Data.Array.Base arrEleBottom :: a
10:39:29 <Deewiant> chessguy: but it's not in any library.
10:39:36 <chessguy> @hayoo
10:39:36 <lambdabot> Unknown command, try @list
10:39:36 <paper_cc> rwbarton: so Deewiant: is Mu f infinite functor-of-functors-of-...
10:39:45 <chessguy> we need a @hayoo command
10:39:54 <paper_cc> :t ((.).(.))
10:39:56 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:40:19 <ozy`> :t ((.) .)
10:40:20 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
10:40:40 <Deewiant> paper_cc: not necessarily functor, but yeah, as I understand it it's basically an infinite nesting of an arbitrary type
10:40:47 <rwbarton> paper_cc: morally, Mu f = f (Mu f).  It's like fix but for functors.
10:41:09 <paper_cc> rwbarton: that's the most difficult thing to understand for me =)
10:41:22 <rwbarton> paper_cc: so if  F a = Nil | Cons Int a, then Mu F is like  List = Nil | Cons Int List
10:42:23 <paper_cc> rwbarton: the problem is like that one with monads: "Now try to understand it in all its generality, man"
10:43:01 <monochrom> In general if you define recursive datatype "X = ... X...", it is "F x = ...x...; X = Mu F"
10:43:09 <HasMeta> Hey folks, I'm trying to extract the "<body>...</body" from a html file using haskell ... could somebody help out a freshman?
10:43:32 * paper_cc just understood that if data Tuple a = Tuple a a, then Mu Tuple is a binary tree
10:43:46 <paper_cc> s/Tuple a a/Nil | Tuple a a/
10:43:49 <BMeph> chessguy, Deewiant: It's part of the Caleskell Collection. :)
10:44:00 <rwbarton> paper_cc: Right.
10:44:10 <bremner> HasMeta: there are a few xml parsers on hackage.  tagsoup might work for you
10:44:12 <chessguy> Caleskell? you mean The Other Prelude?
10:44:54 <bremner> HasMeta: although regular expressions would also work for well formed input
10:44:57 * paper_cc looks at (.:). DO WANT compositions for two-arg functions in the Prelude...
10:45:32 <HasMeta> actually I don't want to parse the html code (I don't think it's even xhtml conform), a simple line-by-line loop which checks for "<bod..." would be fine
10:45:38 <jeffwheeler> :t curry
10:45:39 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:45:45 <jeffwheeler> :t uncurry
10:45:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:45:56 <monochrom> "X = Nil | Tuple X X" is a binary tree.
10:46:22 <jeffwheeler> > uncurry zip $ ([1..5], [6..10])
10:46:24 <lambdabot>   [(1,6),(2,7),(3,8),(4,9),(5,10)]
10:46:33 <chessguy> @src any
10:46:33 <lambdabot> any p =  or . map p
10:46:49 <paper_cc> monochrom: while X a = Nil | Tuple a a is just a maybe-tuple.
10:46:54 <HasMeta> bremmer: a regex would be just fine
10:46:55 <chessguy> @type ((.).(.)) or map
10:46:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:47:08 <chessguy> there it si again
10:47:26 <monochrom> Yes.
10:47:41 <jeffwheeler> > (uncurry.zip) . (\a b -> (a, b)) $ [1..5] [6..10]
10:47:42 <lambdabot>   Couldn't match expected type `b -> c'
10:47:48 <jeffwheeler> > (uncurry.zip) . (\a b -> (a, b)) $ [1..5] $ [6..10]
10:47:49 <lambdabot>   Couldn't match expected type `b -> c'
10:47:56 <ddarius> :t ((.).(.)) concat map
10:47:57 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
10:48:46 <monochrom> "F a = Nil | Cons Int a" is also something like maybe. If you Mu it you get a list.
10:49:05 <ddarius> Exercise: Concisely describe Mu Maybe
10:49:30 <Saizan> heh
10:49:47 <rwbarton> paper_cc: So in this binary tree case, cata takes a way to produce a value corresponding to the empty tree, and a way to combine two values corresponding to the children of a node, and returns a function that processes an entire tree using those two functions.
10:50:36 <rwbarton> paper_cc: those two inputs are represented as a function X c -> c, where X c = Nil | Tuple c c
10:50:46 <CakeProphet> what's the historical reason for the choice of lambda as the symbol for an anonymous function.
10:51:11 <byorgey> CakeProphet: that's what Alonzo Church used in his original paper introducing the lambda calculus.
10:51:33 <CakeProphet> ...did he explain why?
10:51:39 <byorgey> CakeProphet: but apparently there is some question as to whether he intended to use that symbol, or whether it was made up by the person who typed the paper.
10:51:50 * paper_cc understood the way cata makes an universal fold
10:51:56 <byorgey> i.e. he used something that sort of looked like a lambda, but wasn't
10:51:56 <Nafai> byorgey: Got a few minutes to look at something? :)
10:52:00 <byorgey> Nafai: sure!
10:52:18 <paper_cc> rwbarton: Deewiant: ddarius: thanks =)
10:52:25 <CakeProphet> byorgey:  I'm assuming he didn't call it "lambda calculus" then. ;)
10:52:27 <byorgey> CakeProphet: so, basically, the answer boils down to: hysterical raisins
10:52:30 <ddarius> CakeProphet: There's an apocryphal story that he used a hat, then one typesetter used ^x and another typesetter interpreted that as a lambda.
10:52:44 <paper_cc> ddarius: Mu Maybe is sort of type-level unary numbers?
10:52:49 <byorgey> CakeProphet: I guess he didn't.
10:52:58 <Nafai> byorgey: http://github.com/Nafai77/recent-feeds/tree/master
10:53:10 <byorgey> paper_cc: right, but not type-level at all
10:53:15 <Nafai> byorgey: I'm getting a stack space overflow with that code
10:53:17 <byorgey> they are real honest data values.
10:53:24 <paper_cc> yes
10:53:31 <paper_cc> ok
10:53:43 * paper_cc tries to make type-level church numerals
10:53:44 <chessguy> i'm almost willing to lay down money that this is a fold: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=903
10:53:46 <ddarius> paper_cc: Not type level.
10:54:13 <Nafai> byorgey: Even if I remove the data binary stuff, just having my deDupItems function called from something in the IO monad (except my main function for some reason) causes the stack overflow
10:55:27 <ozy`> chessguy: where's the c come from?
10:55:48 <chessguy> ozy`:  arbitrary, unfrotunately
10:56:38 <chessguy> ozy`:  well, outside the function i guess i should say
10:56:42 <chessguy> hm
10:57:56 <chessguy> ozy`:  it could be passed into f
10:59:23 <ksf> dcoutts, where can I get that sweet 0.16.0 c2hs darcs version? (or are you just minutes away from releasing it?)
10:59:24 <ozy`> chessguy: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=903#a909
10:59:28 <byorgey> Nafai: is deDupItems just removing duplicate items by id?  what's the purpose of the IdCountMap?
10:59:37 <dcoutts> ksf: just about to push
11:00:34 <ozy`> chessguy: what are you actually trying to do, anyway?
11:00:50 <chessguy> ozy`:  trying to write forward-chaining inference as a fold
11:01:12 <byorgey> Nafai: in other words, can you simplify it by just inserting all the items into a Set by ID, then listing the items of the set?
11:02:06 <Nafai> byorgey: Sure, if that would be simpler.  I was just using the map as a set, I really don't need the count
11:02:24 <Nafai> byorgey: I would just like the persist it so I can keep this from one run to the next
11:02:32 <byorgey> oh, I see
11:02:34 <CakeProphet> does Haskell have a built-in hash function. :3
11:02:45 <islon_s> i tried to to implement the quick sort haskell algorithm in scala, they are equals but the scala version doesnt work =/
11:02:53 <byorgey> oh, ok, that was the part I didn't get.
11:03:06 <byorgey> Nafai: how many items are you running this on?
11:03:42 <Nafai> Each RSS file has 100 but this will be running for a long time, so potentially tens of thousands
11:03:43 <dcoutts> ksf: if you could check that bug with the new darcs version that'd be great, there have been some changes wrt name case transformations
11:03:56 <Nafai> Well, maybe not that many uniques
11:04:07 <byorgey> Nafai: my initial suspicion is that deDupItems is just building up a huge thunk instead of doing useful work, and when it is finally demanded it blows the stack trying to compute this map and list of kept items
11:04:20 <dcoutts> ksf: if not, we should try your patch (or equivalent in the new code) again
11:04:22 <Nafai> Possibly
11:04:24 <loadquo> @hoogle Data.Map
11:04:24 <lambdabot> module Data.Map
11:04:24 <lambdabot> Data.Map data Map k a
11:04:24 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
11:04:57 <roconnor> @hoogle bind
11:04:58 <lambdabot> Distribution.Simple.InstallDirs bindir :: InstallDirs dir -> dir
11:04:58 <lambdabot> Distribution.Simple.InstallDirs BindirVar :: PathTemplateVariable
11:04:58 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
11:05:01 <Nafai> byorgey: The funny thing is, it works when called from main
11:05:06 <roconnor> is there a bytestring bind?
11:05:13 <byorgey> Nafai: try putting bangs in front of the arguments to deDupItems', like so:  deDupItems' :: [Item] -> ![Item] -> !IdCountMap -> [Item]
11:05:28 <byorgey> although that might not even be enough
11:05:29 <roconnor> oh right
11:05:31 <roconnor> concatmap
11:05:39 <roconnor> @hoogle concatmap
11:05:39 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
11:05:39 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
11:05:39 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
11:05:44 <roconnor> :)
11:06:15 <ozy`> chessguy: mind clarifying the type issue? ie. should f return a Bool or a list?
11:06:26 <byorgey> Nafai: but the thing to do is probably to compile it with profiling turned on and look at some profiling output.
11:06:33 <chessguy> ozy`:  good question
11:06:38 <Nafai> byorgey: "Unexpected strictness annotation"
11:07:14 <pumpkin> @seen dons
11:07:15 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
11:07:21 <chessguy> ozy`:  i think i wrote it wrong
11:07:25 <Nafai> byorgey: So part of the reason I used a map here was easy lookups to see if a given item has been seen before
11:07:26 <byorgey> oh, maybe you're supposed to put the bangs in front of the actual arguments, like deDupItems' (item:items) !keptItems !seenMap
11:07:41 <Nafai> Oh :)
11:07:53 <paper_cc> ddarius: bingo! Mu (Either a) is isomorphic to [a]
11:07:54 <jeffwheeler> @src (.)
11:07:54 <lambdabot> (f . g) x = f (g x)
11:08:16 <paper_cc> ddarius: err, i'm wrong
11:08:18 <ddarius> paper_cc: Indeed.  And Maybe a ~ Either () a so Nat ~ [()]
11:08:40 <ddarius> Ah, you are wrong
11:08:50 <ddarius> You have a Nat type with Zero a
11:08:51 <Nafai> byorgey: Yeah, the strictness didn't help
11:09:00 <Nafai> byorgey: I should try profiling I guess
11:09:07 <jeffwheeler> :t (.)
11:09:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:09:20 <ddarius> paper_cc: But you mentioned it above you want Maybe . (,)
11:09:40 <ddarius> for lists, and then ((), a) ~ a and then Nat ~ [()]
11:10:17 <paper_cc> no infix (.) for types :/
11:10:19 <monochrom> All recursions are like the Mu of flat things. (Tautology.)
11:10:28 <vixey> paper_cc, I know.. it sucks
11:10:46 <vixey> paper_cc, I actually don't understand why haskell doesn't have  \(T : K) -> T  at type level
11:10:48 <Nafai> byorgey: How does the code look, beyond not working? :)
11:10:55 <ddarius> paper_cc: You can make a newtype (and there's a library that already does this on hackage), but there is no actual type level functions like this.
11:11:20 <ddarius> vixey: Arbitrary type lambdas or the identity type function?
11:11:30 * rwbarton wonders if hoogle can search for type constructors by kind
11:11:34 <vixey> ddarius, well kinded lambda in type level
11:12:01 <byorgey> Nafai: pretty good, but I think there are probably things that could be simplified
11:12:02 <dons> woo hwn, http://www.reddit.com/r/programming/comments/7s5rh/haskell_weekly_news_monoids_stmio_the_1000th/
11:12:24 <pumpkin> ooh it's dons
11:12:27 <ddarius> vixey: I believe supporting that would require higher order unification in the type checker.
11:12:31 <byorgey> Nafai: for example, getDeliciousUrlId (RSSItem item) = getDelIdFromUrl `fmap` rssItemComments item
11:12:32 <Nafai> byorgey: Probably.  This code was written when I was sleepy, too
11:12:43 * ozy` screams into his communicator
11:12:44 <BONUS_> ah cool
11:12:48 <ozy`> DOOOOOOOOOOOOOOONNNNNNNNNSSSSSSSSS
11:12:53 <BONUS_> aren't the weekly news usually on mondays?
11:12:53 * ozy` echoes
11:12:54 <ozy`> DOOOOOOOOOOOOOOONNNNNNNNNSSSSSSSSS
11:13:05 <paper_cc> vixey: `O` still won't work as (,) has kind * -> * -> *, will it?
11:13:06 <vixey> ddarius, but you have decideable equality for simply typed lambda terms (i.e. types), so why would you have to use HOU?
11:13:15 <vixey> paper_cc, what ?
11:13:20 * Nafai digs out RWH
11:13:21 <dons> don't be noisy, ozy`
11:13:23 <pumpkin> dons: did you get my message?
11:13:27 <Nafai> I remember reading about fmap
11:13:28 <dons> hmm?
11:13:33 <pumpkin> mm guess not :P
11:13:41 * paper_cc remembers that sort of composition on types was defined as `O`
11:13:49 <pumpkin> I've been writing a load of haddock for uvector and had a couple of questions for you
11:14:08 <dons> ah awesome!
11:14:10 <byorgey> BONUS_: nope, that was just last week when I was busy all weekend =)
11:14:16 <byorgey> they're usually on Saturday
11:14:20 <dons> pumpkin: i find dev stuff proceeds best via email. can you email?
11:14:23 <vixey> paper_cc, oh wasn't worrying about kind polymorphism yet
11:14:34 <pumpkin> dons: sure thing, the @galois one?
11:14:40 <dons> yep
11:14:50 <paper_cc> vixey: I was just wondering if that's the case when one needs it
11:14:57 <pumpkin> sounds good, thanks
11:15:04 <vixey> paper_cc, where one needs what?
11:15:14 <paper_cc> kind-level polymorphism
11:15:27 <vixey> oh right, yeah I think that is a good example
11:15:31 <byorgey> vixey: type-level lambdas does indeed require higher order unification.
11:15:48 <vixey> byorgey, in what situations?
11:15:58 <Nafai> byorgey: Can you explain the fmap there?  I'm still need to re-read that section of RWH to understand functors
11:15:59 <ddarius> paper_cc: I have a use-case for kind polymorphism in Haskell 98.
11:16:00 <byorgey> vixey: for example, suppose you are trying to unify the types  f a  and  m b
11:16:12 <byorgey> vixey: if there are no type-level lambdas, you know that  f == m  and  a == b
11:16:26 <vixey> byorgey, reduce them to beta normal form first
11:16:54 <vixey> hm
11:16:55 <paper_cc> vixey: well, recursive lambdas...?
11:16:59 <Nafai> byorgey: nm I just saw the stuff on page 246 about fmap and Maybe
11:17:00 <vixey> ok I see what you mean
11:17:01 <byorgey> vixey: those are in beta normal form.
11:17:20 <byorgey> Nafai: ok =)
11:17:48 <roconnor> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
11:17:50 <lambdabot>   [[0.0]]
11:18:17 <Nafai> byorgey: I need to run, but I'd like some more suggestions later so I can get this working :)
11:18:20 <vixey> but checking a term has a type doesn't require unification
11:18:21 <chessguy> @type unfoldTree
11:18:22 <lambdabot> forall b a. (b -> (a, [b])) -> b -> Tree a
11:18:23 <Nafai> byorgey: Of course, if you have time.
11:18:24 <byorgey> hehe, took me five minutes of staring at that to figure out how it works =)
11:18:27 <vixey> it's only type inference that uses unification
11:18:40 <byorgey> Nafai: ok, sure, if I'm around
11:19:12 <vixey> actually checking a GADT pattern match would require unification too
11:19:23 <vixey> ok so it really is impractical
11:19:43 <byorgey> vixey: right.
11:20:20 <rwbarton> byorgey: 14:17 < roconnor> > ... 14:18 < byorgey> hehe, took me five minutes ... I disbelieve :P
11:20:55 * sw17ch tries to remember the Setup.hs command to make a hackage package
11:21:11 <jeffwheeler> sw17ch: `cabal sdist`, not Setup.hs :P
11:21:32 <byorgey> rwbarton: heh, I meant, the first time I looked at it, which was when I put it in the HWN =)
11:21:39 <sw17ch> why is -O2 rarely needed?
11:21:48 <sw17ch> (thus sayith cabal sdist)
11:22:00 <rwbarton> ah!
11:22:06 * rwbarton goes to finish reading HWN
11:22:09 <tibbe> am I alone in thinking it's a bit weird for Network.Socket.recv to throw an exception on EOF?
11:22:17 <Twey> HWN?
11:22:28 <jeffwheeler> Twey: Haskell Weekly News
11:22:32 <Twey> tibbe: Yes... I'd go with Maybe myself
11:22:49 <Twey> Exceptions are for, well, exceptional circumstances
11:22:54 <tibbe> Twey: why not just return an empty string?
11:23:00 <tibbe> Twey: I agree with that
11:23:25 <vixey> it says HOU is semi-decidable, like checking real numbers are equal
11:23:40 <vixey> like checking real numbers are not equal*
11:23:41 <Twey> tibbe: Because there are a few cases better-suited to an empty string
11:23:54 <tibbe> Twey: in fact it's very weird since you would always have to use catch since EOF will happy in any program reading from a socket
11:24:03 <Twey> Aye
11:24:11 <maltem> sw17ch: where does it say that?
11:24:13 <Twey> It's not good use of exceptions
11:24:20 <sw17ch> when i do cabal sdist
11:24:23 <sw17ch> maltem, ^^
11:25:43 <maltem> sw17ch: in what situation? some specific package?
11:26:06 <sw17ch> maltem, i'm putting my P2P VPN on hackage right now.
11:26:26 <sw17ch> and i have -Wall -O2 -threaded in my ghc options
11:26:34 <sw17ch> in the cabal file, and i think it's complaining about the -O2
11:26:50 <jeffwheeler> sw17ch: it, being 'cabal dist'
11:26:57 <sw17ch> yes
11:27:01 <jeffwheeler> err, sdist
11:27:14 <vixey> byorgey, (so dependently typed pattern matching is undecidable too)
11:28:13 <byorgey> vixey: sad, isn't it?
11:28:41 <dons> sw17ch: yaya
11:28:50 <sw17ch> dons: :)
11:29:05 <paper_cc> sw17ch: "not that for now -O2 is unlikely to produce better results than -O" GHC docs
11:29:07 <sw17ch> it supports automatic address assignment and i made everything a lot simpler to start
11:29:13 <sw17ch> dons ^^: so it's time
11:29:26 <sw17ch> paper_cc, ah, alright...
11:29:36 <vixey> I don't know
11:29:54 <paper_cc> sw17ch: though some packages are compiled under -fvia-C -O2
11:29:57 <vixey> I want to understand HOU
11:30:13 <monochrom> I feel that since ghc 6.8 -O2 is likely to produce better results than -O.
11:31:04 <vixey> hm
11:31:04 <CakeProphet> @src Applicative
11:31:05 <lambdabot> class Functor f => Applicative f where
11:31:05 <lambdabot>     pure  :: a -> f a
11:31:05 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:31:11 <vixey> if you can always find a unifier if one exists...
11:31:16 <dons> use -O2 if you think it is better
11:31:18 <CakeProphet> @instances Applicative
11:31:18 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:31:19 <dons> i do  :)
11:31:35 <vixey> that just means the only real problem is trimming impossible cases away
11:31:45 <vixey> I think.. ?
11:32:10 <vixey> so any well typed program would be fine.. but badly typed ones could cause infinite loops
11:32:24 <CakeProphet> @instances-importing Control.Applicative Applicative
11:32:24 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
11:32:42 <HasMeta> hmm -> "Failed to load interface for `Text.Regex'"
11:33:23 <paper_cc> @src WrappedMonad
11:33:23 <lambdabot> Source not found. Maybe you made a typo?
11:33:31 <paper_cc> ,src 'WrappedMonad
11:33:32 <lunabot>  luna: Not in scope: data constructor `WrappedMonad'
11:33:40 <paper_cc> ,src WrappedMonad
11:33:41 <lunabot>  luna: Not in scope: data constructor `WrappedMonad'
11:33:57 * paper_cc wonders where he can find help for lunabot
11:34:03 <paper_cc> ,src "WrappedMonad
11:34:04 <lunabot>  luna: lexical error in string/character literal at end of input
11:34:22 <rwbarton> , src ''WrappedMonad
11:34:25 <lunabot>  newtype WrappedMonad m a = WrapMonad {unwrapMonad :: (m a)}
11:35:08 <paper_cc> , src "WrappedMonad
11:35:09 <lunabot>  luna: lexical error in string/character literal at end of input
11:35:41 <paper_cc> , src ''Mu
11:35:43 <lunabot>  newtype Mu f = Mu (f (Mu f))
11:35:44 <rwbarton> ' is used with values and data constructors, '' with type constructors
11:35:54 <paper_cc> , src "WrappedMonad
11:35:55 <lunabot>  luna: lexical error in string/character literal at end of input
11:36:02 <rwbarton> " is used with strings :P
11:36:08 <skorpan> i'm unable to build hmp3 1.5.2.1 with errors on ambiguous type variables in FastIO.hs. anyone else experiencing this?
11:36:16 * paper_cc blames ASCII
11:36:22 <paper_cc> , src ''WrappedMonad
11:36:24 <lunabot>  newtype WrappedMonad m a = WrapMonad {unwrapMonad :: (m a)}
11:36:36 <paper_cc> rwbarton: :)
11:36:47 <HasMeta> please help http://rafb.net/p/e1uE9t75.html :-/
11:37:17 <rwbarton> HasMeta: use ghc --make Regex.hs
11:37:22 <paper_cc> BTW why is hpaste.org down?
11:37:34 <rwbarton> HasMeta: aka "figure out all the package dependencies for me"
11:37:45 <HasMeta> ah, that worked, thanks ;)
11:37:47 * paper_cc thinks that somebody should put hpastetwo in the channel description
11:38:05 <ozy`> paper_cc: that's what she said!
11:38:10 <ozy`> I mean... what I said.
11:38:23 * ozy` shuffles feet abashedly
11:38:31 <ksf> dcoutts, it's still GetError -> geterror
11:38:32 <sw17ch> of course, now i forget my hackage credentials
11:38:51 <ksf> (...damnit, I just broke my build)
11:40:29 <ksf> as a side note, it'd be nice if c2hs mentioned what it does to stdout, like ghc... cabal install appears to hang on "Preprocessing foo", and it's not even compiling nearly 10% of agar.
11:41:49 <JasonFelice> Ok, can somebody explain me why (flip id) does what it does?
11:41:59 <ksf> @src flip
11:42:00 <lambdabot> flip f x y = f y x
11:42:01 <koeien> Sure!
11:42:02 <ksf> @src id
11:42:02 <lambdabot> id x = x
11:42:10 <koeien> :t flip
11:42:11 <ksf> that enough? :P
11:42:11 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:42:36 <koeien> basically, (a -> b -> c) needs to be unified with (t -> t)
11:42:37 <dcoutts> ksf: sorry, what about GetError? I've missed some context. I'm not sure what you mean about preprocessing either, is it really hung or is it doing something, run the build with -v to see cabal calling c2hs
11:43:05 <ksf> AG_GetError is just an agar function.
11:43:20 <ksf> and no, it's not hung, it's just taking ages.
11:43:30 <ksf> ...without giving any output.
11:43:53 <sw17ch> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Scurry-0.0.1
11:44:14 <ksf> (I don't believe anyone ever wrote a autoconf'ed Setup.hs without knowing about -v)
11:44:15 <dcoutts> ksf: ah, that, ok.
11:44:21 <sw17ch> dons: it blows up, whoops
11:44:52 <JasonFelice> koeien: I'm not getting why it's not a compile error, sorry.
11:45:14 <ksf> :t (flip id)
11:45:16 <lambdabot> forall b c. b -> (b -> c) -> c
11:45:19 * sw17ch forgot the other-sources line...
11:45:59 <koeien> JasonFelice: so, flip :: (a -> (b -> c)) -> b -> a -> c, and since id :: t-> t, the compiler has to unify t->t with a->(b->c) . so a = t->t, and b = c = t.
11:46:54 <koeien> hmm, that's not completely right
11:47:35 <HasMeta> is there a simple way to beautify this? -> http://rafb.net/p/c0NMir37.html
11:47:42 <JasonFelice> heh.
11:47:54 <koeien> JasonFelice: better, a = t -> u, b = t, c = u.
11:48:20 <vixey> HasMeta, you see:  "<body>content</body>"  I would do it like this
11:48:20 <paper_cc> HasMeta: beautify regexes?!
11:48:32 <koeien> JasonFelice: GHC is better in unifying than I am
11:48:40 <vixey> @let tag name body = "<"++name++">"++body++"<"++name++"/>"
11:48:41 <lambdabot>  Defined.
11:48:50 <vixey> > let body = tag "body" in  body "content"
11:48:51 <lambdabot>   "<body>content<body/>"
11:48:55 <vixey> umm.....
11:49:03 <vixey> well with less silly mistakes probably
11:49:38 <paper_cc> > let tag name body = "<" ++ name ++ ">" ++ body ++ "</" ++ name ++ ">"; body = tag "body" in body ".*"
11:49:39 <ksf> dcoutts, the same patch works (but of course w/ different line nums)
11:49:39 <lambdabot>   "<body>.*</body>"
11:49:51 <mauke> preflex: ? html
11:49:51 <preflex>  Don't parse html with regular expressions! See HTML::Parser, and its subclasses: HTML::TokeParser, HTML::TokeParser::Simple, HTML::TreeBuilder, HTML::TableExtract, etc. See also http://htmlparsing.icenine.ca/.  If your response begins "that's overkill.  I only want to..." you are wrong.
11:49:56 <paper_cc> > let tag name body = "<" ++ name ++ ">" ++ body ++ "</" ++ name ++ ">"; body = tag "body" in body "(.*)"
11:49:58 <lambdabot>   "<body>(.*)</body>"
11:49:59 <vixey> hehe
11:50:02 <rwbarton> preflex: wrong channel
11:50:02 <mauke> ... that's what #perl would say :-D
11:50:15 <koeien> JasonFelice: basically, id gets specialised to ((t->u)->(t->u))
11:50:29 <ksf> there's also tagsoup...
11:50:48 <skorpan> hey, anyone familiar with SYB here? shouldn't this always return False? everything (&&) (False `mkQ` canWrite)
11:50:57 <skorpan> like, no matter what canWrite is.
11:51:03 <paper_cc> hmm, universal recipe for Perl: don't <whatever> with regular expressions!
11:51:20 <paper_cc> s/Perl/semi-readable Perl/
11:51:25 <rwbarton> , [$ty| mkQ |]
11:51:27 <lunabot>  forall a b c . (Typeable a, Typeable b) => c -> (b -> c) -> a -> c
11:51:30 <Botje> paper_cc: i disagree
11:51:35 <Botje> regexes are handy.
11:51:41 <mauke> regexes are readable.
11:51:49 <vixey> regexes are regular
11:51:52 <Botje> :)
11:51:53 <skorpan> regexen* ffs.
11:51:54 <vixey> ^^ spot the lie
11:52:00 <mauke> vixey: they aren't, actually :-)
11:52:14 * paper_cc remembers that 5-line shell command to download a YouTube playlist
11:52:20 <rwbarton> skorpan: I don't think so...
11:52:23 <skorpan> paper_cc: awk and sed madness?
11:52:34 <skorpan> rwbarton: i don't see why really.
11:52:49 <paper_cc> skopan: real, pure sed madness =)
11:52:55 <rwbarton> , let canWrite :: Integer -> Bool; canWrite = True in everything (&&) (False `mkQ` canWrite) (3 :: Integer)
11:52:57 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer
11:53:12 <Botje> /^ID: (\d+) somewhere=\((\d+),(\d+),(\d+)\)$/
11:53:23 <paper_cc> wget -O$f.mp4 "http://keepvid.com"$( wget -O- 'htt—Ä://keepvid.com/?url=htt—Ä%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D'$f | sed -rn 's%^.*<a href="(/save-video\.mp4[^"]*)".*$%\1%p' )
11:53:33 <sw17ch> can some one `cabal install Scurry` for me?
11:53:34 <sw17ch> :)
11:53:35 <Botje> this is much clearer than whatever code you can come up with to parse that
11:53:44 <paper_cc> Botje: ^^ now explain what this is =)
11:53:51 <skorpan> rwbarton: what was that?
11:54:01 <rwbarton> , let canWrite :: Integer -> Bool; canWrite _ = True in everything (&&) (False `mkQ` canWrite) (3 :: Integer)
11:54:03 <lunabot>  True
11:54:06 <olsner> how can I force cabal to install the latest version of something? cabal install QuickCheck installs 1.2, but I seem to want things for implementing my Arbitrary instance that are only in 2.1
11:54:13 <Botje> paper_cc: it parses that keepvid.com page for a link that starts with /save-video.mp4
11:54:28 <dcoutts> olsner: cabal install 'quickcheck > 2'
11:54:29 <jeffwheeler> olsner: cabal install QuickCheck==2.1 might work
11:54:30 <rwbarton> , let canWrite :: Integer -> Bool; canWrite _ = True in everything (&&) (False `mkQ` canWrite) (3 :: Integer, 4 :: Integer)
11:54:31 <jeffwheeler> or that
11:54:31 <lunabot>  False
11:54:34 * ksf just checked the only bigger perl program he ever wrote and noticed regexes to parse csv and case-match part of the url
11:54:41 <Twey> :t mkQ
11:54:42 <koeien> olsner: did you try `cabal update` first. then cabal install QuickCheck==2.1
11:54:43 <lambdabot> forall r b a. (Typeable b, Typeable a) => r -> (b -> r) -> a -> r
11:54:57 <Botje> paper_cc: also note that the regex itself pales in comparison to the wget and sed noise around it
11:55:02 <dcoutts> koeien: the default version is 1.x so that would not make any difference
11:55:03 <olsner> ooh, it takes dependencies rather than package names
11:55:05 <olsner> that's cool
11:55:07 * paper_cc surrenders
11:55:14 <koeien> dcoutts: hmm, that is specific for this package?
11:55:20 * Botje hoists the // flag
11:55:20 <dcoutts> koeien: yes
11:55:24 <skorpan> rwbarton: so why did the first example return True whereas the second one didn't?
11:55:34 <rwbarton> skorpan: I think because of the (,) constructor
11:55:48 <dcoutts> koeien: because of the dozens and dozens of packages that work with 1.x and not 2.x due to not having specified an upper bound
11:56:00 <dcoutts> koeien: it's somewhat of a compatibility hack
11:56:08 <dcoutts> though a rather effective one
11:56:20 <koeien> hmmz. a better fix would be to rename QuickCheck to QuickCheck2 ?
11:56:26 <koeien> nah, hacking it is
11:56:35 <skorpan> rwbarton: i don't follow :(
11:57:08 <dcoutts> koeien: no, the better fix is to warn about all packages that depend on it that do not specify the version correctly
11:57:33 <koeien> yeah, that would be optimal but time-consuming
11:57:37 <olsner> it worked! now, is it possible to explicitly make quickcheck do an exhaustive test?
11:57:44 <rwbarton> skorpan: everywhere (&&) f (3, 4) = f (3, 4) && f 3 && f 4
11:57:44 <koeien> also, some maintainers may not respond and stuff like that
11:57:47 <mauke> let plus = liftM2 (,); num = many1 digit in string "ID: " *> num <* string " somewhere=(" `plus` num <* string "," `plus` num <* string "," `plus` num <* string ")" <* eof
11:58:06 <geezusfreeek> olsner, define "exhaustive"
11:58:13 <paper_cc> @src <*
11:58:13 <lambdabot> (<*) = liftA2 const
11:58:16 <paper_cc> @src *>
11:58:17 <lambdabot> (*>) = liftA2 (const id)
11:58:22 <dcoutts> koeien: we can enforce it for new uploads and eventually we're going to add a mechanism to edit .cabal files of existing packages on hackage
11:58:22 <paper_cc> @ty <*
11:58:23 <lambdabot> parse error on input `<*'
11:58:28 <paper_cc> @ty (<*)
11:58:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:59:08 <olsner> geezusfreeek: in this case, I am testing a function that takes two Int16 and would like to test every combination of two Int16's (which should be feasible)
11:59:16 <rwbarton> skorpan: if f = False `mkQ` (\(_ :: Integer) -> True), then f 3 = True but f (3, 4) = False
11:59:21 * ksf adds Build-Tools: c2hs >= 0.16.0 to agar.cabal and hopes that dcoutts applies that patch before releasing it.
11:59:45 <geezusfreeek> olsner, that i know of, that is not possible with quickcheck because it chooses random values. smallcheck might be a better candidate for this case
11:59:54 <dcoutts> ksf: the naming transforms in c2hs scare me, I don't understand yet where they really happen.
11:59:55 <olsner> otoh, maybe I should just do that myself instead of going through quickcheck
12:00:15 <ksf> dcoutts, during chs parsing.
12:00:20 <dcoutts> ksf: I know your patch makes it work for you, but I'd like to understand the code to make sure we're not breaking something
12:00:28 <dcoutts> ksf: yeah, which is weird to start with
12:00:38 <ksf> you can debug it with -d chs
12:00:54 <true\false> If I understand this correctly, pattern matching with functions can be likened to method overloading?
12:00:57 <ksf> ...it just rewrites stuff to explicit Foo as Bar.
12:01:19 <koeien> true\false: no
12:01:41 <koeien> true\false: the class system is more similar to method overloading
12:01:47 * geezusfreeek tries to understand true\false's misunderstanding
12:02:04 <true\false> Mind if I paste two lines here?
12:02:11 <geezusfreeek> two lines is okay
12:02:13 <true\false> goodExample (x:xs) = x + goodExample xs
12:02:13 <true\false> goodExample _      = 0
12:02:34 <true\false> That is what reminds me of method overloading, somewhat.
12:02:50 <geezusfreeek> why does that look like method overloading to you?
12:02:51 <mauke> true\false: that's just a single function defined in multiple clauses
12:02:52 <paper_cc> true\false: pattern matching "overloads" on values, while C++ overloads on types and argcounts
12:03:01 <mauke> it's not multiple functions
12:03:15 <inv2004> lambdabot: @paste
12:03:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:03:21 <inv2004> don't work
12:03:24 <geezusfreeek> true\false, pattern matching is more like a switch statement combined with a handy way to bind variables for each case
12:03:34 <paper_cc> @where hpastetwo | inv2004
12:03:34 <lambdabot> I know nothing about hpastetwo.
12:03:40 <ksf> @where hpast2
12:03:40 <lambdabot> I know nothing about hpast2.
12:03:42 <mauke> it's also syntactic sugar for goodExample tmp = case tmp of (x:xs) -> x + goodExample xs; _ -> 0
12:03:43 <Deewiant> @where hpaste2
12:03:44 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
12:03:48 <inv2004> thx
12:03:58 * ksf fails
12:04:03 <rwbarton> If you implemented discriminated unions in C++ using a class for each constructor (which some people seem to like to do) then it is a little like method overloading.
12:04:07 <koeien> mauke: there you pattern match again ;) cheater
12:04:23 <true\false> Hmm...
12:04:25 <paper_cc> @where+ hpastetwo http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
12:04:25 <lambdabot> Good to know.
12:04:27 <koeien> rwbarton: no, in C++ you could add new values. this is not possible in Haskell
12:04:32 <koeien> rather, new types
12:04:58 <true\false> I understand it to the extend that given different values the expression used differs, is that corrrect?
12:05:34 <mauke> true\false: yes (but overloading uses different types)
12:06:00 <inv2004> could someone help with this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=911#a911
12:06:05 <Heffalump> the key difference is that overloading is almost always open, in that you can add new overloads in other places
12:06:09 <inv2004> why is it not tail-recusion ?
12:06:19 <inv2004> hugs drops with stack error
12:06:20 <Heffalump> whereas pattern matching/ADTs are closed, all the alternatives have to be defined at once
12:06:41 <koeien> Heffalump: indeed. that's what I was trying to point out.
12:06:44 <mauke> inv2004: pp2 is undefined
12:06:45 <CakeProphet> @instances-importing Control.Arrow Arrow
12:06:46 <lambdabot> (->), Kleisli m
12:06:48 <dons> ?users
12:06:49 <lambdabot> Maximum users seen in #haskell: 645, currently: 632 (98.0%), active: 32 (5.1%)
12:06:59 <mauke> inv2004: stack errors are usually *caused* by tail recursion
12:07:10 <inv2004> mauke: ups, sorry, just a moment
12:07:14 <CakeProphet> @src Kleisli
12:07:15 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:07:33 <paper_cc> . src ''Kleisli
12:07:39 <paper_cc> , src ''Kleisli
12:07:40 <lunabot>  luna: Not in scope: type constructor or class `Kleisli'
12:07:47 <ksf> does hackage know of versions like 1.2.3-pre1 and 1.2.3-r1?
12:07:58 <eu-prleu-peupeu> reactive is so freakin harsh!
12:08:16 <true\false> Ok .. Right, I still don't entirely understand. Anybody reccomend a second source to RWH to hammer this stuff in?
12:08:24 <ksf> (because I'd like to have the agar version in the version of the bindings)
12:08:55 <paper_cc> true\false: well, you know, overloading is when you define void f(int); and void f(double);
12:08:58 <paper_cc> true
12:09:01 <paper_cc> err
12:09:21 <true\false> Yes...
12:09:33 <paper_cc> true\false: with matching, f always has the same type
12:10:11 <paper_cc> true\false: e.g. goodExample :: [a] -> Int
12:10:30 <vixey> goodExample :: [Int] -> Int
12:10:37 <mauke> inv2004: in pp, what happens when you use $! instead of $ ?
12:10:54 <paper_cc> vixey: monomorphism..?
12:10:56 <inv2004> i'll try
12:11:26 <paper_cc> vixey: I was convinced to write goodExample :: (Num b) => [a] -> b first
12:11:42 <vixey> goodExample :: (Num b) => [b] -> b
12:11:47 <koeien> actually it was Num b => [b] -> b
12:11:50 <Deewiant> how about starting with simpleExample :: Int -> Int ? :-P
12:11:55 <vixey> lol
12:12:03 <koeien> yeah, [Int] -> Int is better :)
12:12:15 <Deewiant> simpleExample 0 = True
12:12:17 <mauke> simpleExample 0 = 0; simpleExample x = 2*x
12:12:18 <Deewiant> simpleExample _ = False
12:12:18 <vixey> koeien, or!!
12:12:23 <vixey> goodExample :: [_] -> Int
12:12:32 <CakeProphet> @src ((->) a) (>>>)
12:12:32 <lambdabot> Source not found. My mind is going. I can feel it.
12:12:32 <koeien> otherwise you have overloading >:-)
12:12:33 <Deewiant> mauke: bad example, the first case is unnecessary :-P
12:12:35 <vixey>          ^ this is not implemented
12:12:35 <inv2004> mauke: wow, it works!
12:12:46 <mauke> magic, ladies and gentlemen
12:12:50 <inv2004> I didn't think its the reason
12:12:52 <Twey> vixey: [_] is inval‚Äî oh :)
12:13:04 <vixey> Twey, but it *should be*
12:13:23 <Twey> But why?
12:13:29 <vixey> because it's awesome
12:13:32 <Twey> Hahaha
12:13:38 <ksf> vixey is coding too much agda.
12:13:41 <Twey> But offers no practical gain over a :-P
12:13:55 <vixey> Twey,  [a] -> Int  would be a type error
12:13:58 <Twey> Now, meta-meta-kind systems... that's awesome
12:14:05 <vixey> Twey,  [Int] -> Int  works... but have redundant information
12:14:06 <Olathe> > let simpleExample 0 = 0; simpleExample x = 2 + simpleExample (x - 1) in map simpleExample [1..]
12:14:08 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
12:14:11 <vixey> Twey,  [_] -> Int  perfection!
12:14:13 <mauke> inv2004: related: http://haskell.org/haskellwiki/Stack_overflow
12:14:14 <ksf> i_want_to_have_all_the_parameters_of_my_program_in_one_sentence
12:14:19 <Twey> [a] -> Int would be a type error?
12:14:26 <Twey> :t length
12:14:27 <lambdabot> forall a. [a] -> Int
12:14:42 <vixey> :t let  goodExample (x:xs) = x + xs; goodExample [] = 0 in  goodExample :: [Int] -> Int
12:14:43 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
12:14:44 <lambdabot>       Expected type: t
12:14:44 <lambdabot>       Inferred type: [t]
12:14:46 <koeien> in this case it would be  type error
12:14:51 <vixey> :t let  goodExample (x:xs) = x + goodExample xs; goodExample [] = 0 in  goodExample :: [Int] -> Int
12:14:52 <lambdabot> [Int] -> Int
12:14:53 <koeien> what vixey means is "partial type inference"
12:14:54 <vixey> :t let  goodExample (x:xs) = x + goodExample xs; goodExample [] = 0 in  goodExample :: [a] -> Int
12:14:55 <lambdabot>     Couldn't match expected type `Int' against inferred type `a'
12:14:55 <lambdabot>       `a' is a rigid type variable bound by
12:14:55 <lambdabot>           the polymorphic type `forall a. [a] -> Int' at <interactive>:1:69
12:14:58 <vixey> :t let  goodExample (x:xs) = x + goodExample xs; goodExample [] = 0 in  goodExample :: [_] -> Int
12:14:59 <lambdabot> parse error on input `_'
12:15:08 <koeien> or whatever it's called
12:15:16 <inv2004> mauke: thx
12:15:17 <vixey> koeien, wasn't aware of any name for it
12:15:24 <koeien> i don't, i just made it up :)
12:16:03 <true\false> Ok is this right to say then:
12:16:14 <true\false> thing 1 = 0
12:16:15 <roconnor> what does it mean for something to be "unutterably tedious" ?
12:16:29 <vixey> roconnor, alpha conversion
12:16:29 <true\false> thing _ = 254
12:16:34 <Olathe> It means that even the speaker would fall asleep.
12:16:39 <true\false> The same type, int, is present?
12:16:42 <vixey> roconnor, or just anything that is so horribly boring you don't even want to talk about it
12:16:48 <dons> sw17ch: are you going to blog about scurry?
12:16:53 <geezusfreeek> true\false, here is a sample haskell function with pattern matching and equivalent C code (untested though) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=912#a912
12:17:00 <paper_cc> @ty (let thing 1 = 0; thing _ 254 in thing)
12:17:01 <lambdabot> parse error on input `in'
12:17:01 <Deewiant> true\false: unfortunately that has type (Num a, Num b) => a -> b
12:17:08 <sw17ch> dons: i'm hoping to
12:17:14 <Deewiant> paper_cc: missing =
12:17:18 <true\false> geezusfreeek: Ta
12:17:19 <koeien> geezusfreeek: indeed. the best analogy is enum with a union
12:17:23 <sw17ch> dons: but that means i need to actually, you know... install wordpress on sw17ch.com
12:17:23 <Deewiant> true\false: but yeah, you could give it type Int -> Int
12:17:28 <roconnor> vixey: hmm
12:17:34 <Olathe> Deewiant: I think int* is Maybe Int.
12:17:50 <roconnor> vixey: sometimes it feels like you guys speak a totally different language :D
12:17:51 <Deewiant> where was int*
12:17:57 <sw17ch> dons: actually, this is probably a good time to do that
12:18:03 <dons> sw17ch: well, just write about it somewhere. since this is a great development
12:18:03 <Olathe> Oh, wrong person, sorry.
12:18:07 <Deewiant> :-)
12:18:08 <roconnor> vixey: thanks for the translation
12:18:11 <paper_cc> @ty (let thing 1 = 0; thing _ = 254 in thing)
12:18:12 <lambdabot> forall t t1. (Num t1, Num t) => t -> t1
12:18:16 <Olathe> geezusfreeek: I think int* is Maybe Int.
12:18:16 <Twey> roconnor: „Å™„Çì„Åß„Åù„ÅÜÊÄù„Å£„Å¶„ÅÑ„Çã„Çì„Å†„Çç„ÅÜ
12:18:20 <paper_cc> Deewiant: thanks =)
12:18:20 <CakeProphet> > ((arr (*2)) *** (arr (+3)) -< 5
12:18:21 <lambdabot>   <no location info>: parse error on input `;'
12:18:24 <CakeProphet> ..
12:18:28 <dons> check it out guys, sw17ch wrote a p2p vpn app, http://www.reddit.com/r/haskell/comments/7s653/a_cross_platform_p2p_vpn_application_in_haskell/
12:18:32 <geezusfreeek> Olathe, but easier to screw up ;)
12:18:33 <roconnor> Twey: :P
12:18:34 <dons> non-trivial :)
12:18:39 <CakeProphet> > ((arr (*2)) >>> (arr (+3)) -< 5
12:18:40 <lambdabot>   <no location info>: parse error on input `;'
12:18:40 <Olathe> geezusfreeek: Sure :)
12:18:47 <dons> shapr: check out scurry
12:19:10 <geezusfreeek> Olathe, plus i was trying to be more general for the sake of instruction
12:19:25 <koeien> sw17ch, dons: cool
12:19:55 <koeien> uses /dev/tun* under linux?
12:20:10 <CakeProphet> :t proc
12:20:11 <lambdabot> Not in scope: `proc'
12:20:23 <CakeProphet> :t Control.Arrow.proc
12:20:24 <sw17ch> koeien, yes
12:20:24 <lambdabot> Not in scope: `Control.Arrow.proc'
12:20:26 <CakeProphet> ..
12:20:30 <pumpkin> , replicateEachU 1 (toU [100000]) (toU [1])
12:20:31 <lunabot>  Killed.
12:20:32 <CakeProphet> where is proc?
12:20:41 <pumpkin> , replicateEachU 1 (toU [100000]) (toU [1])
12:20:41 <paper_cc> @where proc
12:20:41 <lambdabot> I know nothing about proc.
12:20:42 <lunabot>  toU [1.0,-1.8958047777523144e-57,9.350925523306327e-266,-4.33137823168107...
12:20:51 <sw17ch> koeien, and TAP-Win32 (which installs with openvpn) on Windows
12:20:53 <paper_cc> CakeProphet: in arrow syntax =)
12:21:03 <sw17ch> and i forget how it works on Mac and BSD (i didn't write that C code)
12:21:21 <CakeProphet> paper_cc:  it's a language extension?
12:21:29 <koeien> cool :) i'll cabal it
12:21:34 <true\false> Ok thanks for the input, think it makes a bit more sense now.. I'll mull it over as I attempt to get a heater in this freezing room
12:22:45 <paper_cc> CakeProphet: http://www.haskell.org/arrows/syntax.html
12:23:07 <CakeProphet> paper_cc:  I've already read that page. Are they not functions?
12:23:23 <Heffalump> are what not functions?
12:23:33 <paper_cc> Heffalump: proc
12:23:57 <paper_cc> CakeProphet: First, note that there are two new keywords: proc (arrow abstraction)  is a kind of lambda <...>
12:24:26 <CakeProphet> paper_cc:  so then lambdabot doesn't support arrow syntax?
12:24:55 * paper_cc thinks he's not experienced with #haskell bots at all
12:26:04 <paper_cc> , (proc x -> do y <- (+1) -< x; z <- (-1) -< x; returnA -< y + z) 10
12:26:05 <lunabot>  luna: Pattern syntax in expression context:
12:26:28 <paper_cc> , (\x -> (x+1) + (x-1)) 10
12:26:29 <lunabot>  20
12:26:44 <paper_cc> lunabot doesn't have arrows either
12:26:53 <paper_cc> +seem to have
12:27:27 <HasMeta> puah, is there a way to extract the text from the "body" tag (TagSoup)?
12:27:43 <paper_cc> , ((+1) &&& (-1) >>> arr (uncurry (+))) 10
12:27:44 <lunabot>  luna: Not in scope: `&&&'
12:27:46 <CakeProphet> so how does one convert arrows to pure values (or IO, or whatever).
12:27:52 <paper_cc> > ((+1) &&& (-1) >>> arr (uncurry (+))) 10
12:27:53 <lambdabot>       No instance for (Num (c' -> c'))
12:27:53 <lambdabot>        arising from a use of `negate' ...
12:28:06 <paper_cc> > ((+1) &&& (subtract 1) >>> arr (uncurry (+))) 10
12:28:08 <lambdabot>   20
12:29:21 <jeffwheeler> @src arr
12:29:22 <lambdabot> Source not found. You type like i drive.
12:29:24 <jeffwheeler> :t arr
12:29:25 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
12:29:29 <paper_cc> @src Arrow
12:29:30 <lambdabot> class Arrow a where
12:29:30 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:29:30 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
12:29:30 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
12:29:30 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
12:29:32 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
12:29:34 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
12:29:43 <paper_cc> jeffwheeler: ^^
12:30:00 <snookerb> hello folks
12:30:17 <jeffwheeler> @src Arrow Int
12:30:17 <lambdabot> Source not found. You speak an infinite deal of nothing
12:30:20 <jeffwheeler> @src Arrow Integer
12:30:20 <lambdabot> Source not found. Sorry.
12:30:22 <jeffwheeler> :(
12:30:32 <snookerb> i have a short question regarding the lookup function
12:30:32 <paper_cc> @src Arrow (->)
12:30:32 <lambdabot> Source not found. :(
12:30:41 <BONUS_> arrow isntances gotta be of kind * -> * -> *
12:30:51 <paper_cc> , src ''Arrow (->)
12:30:52 <lunabot>  luna: parse error on input `->'
12:31:03 <Deewiant> arr = id, pure = id, (>>>) = flip (.), etc.
12:31:12 <paper_cc> how does one get source for an instance declaration?
12:31:14 <snookerb> the lookup function returns the second elemnt of a pair matching some "search" word
12:31:14 <snookerb> Input: lookup 'c' [('a',0),('b',1),('c',2)]
12:31:14 <snookerb> Output: Just 2
12:31:23 <BONUS_> yeah
12:31:27 <byorgey> snookerb: right.
12:31:28 <snookerb> ok, now i am searching for some kind of function to update this value
12:31:33 <Deewiant> ?src [] (==) -- paper_cc
12:31:34 <lambdabot> Source not found. My pet ferret can type better than you!
12:31:37 <Deewiant> ach
12:31:39 <Deewiant> ?src [] (==)
12:31:39 <lambdabot> []     == []     = True
12:31:39 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
12:31:39 <lambdabot> _      == _        = False
12:31:46 <snookerb> i mean, surely i could just remove it from the list
12:31:48 <snookerb> and the readd it
12:31:51 <paper_cc> ?src Arrow (->)
12:31:52 <lambdabot> Source not found.
12:31:53 <BONUS_> snookerb: if you want to update values, i'd recommend using Data.Map
12:31:55 <Deewiant> paper_cc: but anyhoo, \bot doesn't know everything.
12:31:55 <snookerb> but there must be a better way
12:32:06 <snookerb> well, i am bound to this data strukture
12:32:12 <BONUS_> ah
12:32:12 <snookerb> so i have to get along with it
12:32:22 <pumpkin> ?src (->) arr
12:32:22 <lambdabot> arr f = f
12:32:25 <snookerb> i thought maybe there is already an "update" or something like this
12:32:33 <Deewiant> oh, well apparently it knows those. :-)
12:32:45 <paper_cc> @src (>>=) ((->) a)
12:32:45 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:32:46 <BONUS_> nah, because a list isn't really the best data structure for key value pairs
12:32:50 <BONUS_> but it's easy to write your own update
12:32:56 <snookerb> yeah
12:33:04 <pumpkin> it would be a map
12:33:07 <ozy`> @src (->) (>>=)
12:33:07 <lambdabot> f >>= k = \ r -> k (f r) r
12:33:11 <snookerb> but i have written so many functions and found out later that they already exists
12:33:19 <snookerb> this time i wanted to save the extra time ;-)
12:33:26 <BONUS_> yeah that happens to me too :D
12:33:30 <snookerb> ok, so my function will the search the list again for this pair
12:33:34 <snookerb> remove it
12:33:41 <snookerb> return a new list without this pair
12:33:43 <BONUS_> yeah
12:33:46 <snookerb> and then i re-add the modified one
12:33:47 <snookerb> right?
12:34:03 <BONUS_> basically it will return a list like the old one, except with that pair removed, yeah
12:34:08 <ozy`> :t (>) >>= map
12:34:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
12:34:09 <lambdabot>       Expected type: (a -> Bool) -> a -> b
12:34:09 <lambdabot>       Inferred type: (a -> Bool) -> [a] -> [Bool]
12:34:10 <mauke> @hoogle (a -> Bool) -> [a] -> ([a], [a])
12:34:10 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
12:34:10 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
12:34:11 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
12:34:13 <BONUS_> although you gotta watch out for two things: 1) what if there are many pairs with the same key?
12:34:19 <CakeProphet> > ((+3) >>= (+5)) x
12:34:19 <BONUS_> 2) what if that pair isn't in already
12:34:20 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
12:34:20 <lambdabot>      Proba...
12:34:21 <BONUS_> what happens then
12:34:25 <snookerb> yeah
12:34:28 <snookerb> thanks for the tip
12:34:33 <paper_cc> @hoogle (a -> Bool) -> [a] -> [a]
12:34:34 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
12:34:34 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
12:34:34 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
12:34:41 <snookerb> well, i do a lookup search before anyway and throw an error if the pair is not there
12:34:55 <BONUS_> > (+3) >>= (*) $ 9
12:34:57 <lambdabot>   108
12:34:57 <snookerb> and, there will only be one pair with some key
12:35:10 <CakeProphet> > ((+3) >>= (+)) x
12:35:12 <lambdabot>   x + 3 + x
12:35:12 <snookerb> guys, thanks very much for you help
12:35:16 <BONUS_> np
12:35:17 <snookerb> this channel is just great!
12:35:20 <snookerb> thumbs up!
12:35:22 <BONUS_> :]
12:35:24 <CakeProphet> > ((+3) >>= (*)) x
12:35:25 <lambdabot>   (x + 3) * x
12:35:28 <paper_cc> > let remove k = filter ((/=k).fst) in remove 1 [(1, "1"), (0, "0")]
12:35:29 <lambdabot>   [(0,"0")]
12:35:30 * snookerb back to coding
12:35:37 * snookerb is back to coding
12:35:40 <snookerb> ;-)
12:35:41 <CakeProphet> it's like a one-sided `on`....
12:35:54 <ozy`> :t (any (>3)) >>=
12:35:55 <lambdabot> parse error (possibly incorrect indentation)
12:35:59 <ozy`> :t ((any (>3)) >>=)
12:36:00 <lambdabot> forall a b. (Ord a, Num a) => (Bool -> [a] -> b) -> [a] -> b
12:36:37 <paper_cc> > let update k v = ((k, v):) . (filter $ (/=k).fst) in update 1 "baz" [(0, "foo"), (1, "bar")]
12:36:38 <lambdabot>   [(1,"baz"),(0,"foo")]
12:37:05 <BONUS_> snookerb: when you're not sure if you're about to write a function that already exists, think of what its type would be and then search that type in hoogle :]
12:37:10 <BONUS_> that saves me a lot of time
12:37:18 <CakeProphet> @hoogle a
12:37:19 <lambdabot> Text.XHtml.Frameset abbr :: Html -> Html
12:37:19 <lambdabot> Text.XHtml.Strict abbr :: Html -> Html
12:37:19 <lambdabot> Text.XHtml.Transitional abbr :: Html -> Html
12:37:20 <CakeProphet> :3
12:37:41 <Deewiant> That should really not be the type you're looking for ;-)
12:37:44 <adh0c> hi
12:37:53 <CakeProphet> @hoogle (a ->b) -> (b -> c) -> c
12:37:53 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
12:37:53 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
12:37:53 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
12:38:40 <CakeProphet> @hoogle (b ->c) -> (a -> b) -> c
12:38:41 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
12:38:41 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
12:38:41 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
12:38:44 <paper_cc> @botsnac
12:38:44 <lunabot>  :)
12:38:45 <lambdabot> :)
12:38:48 <paper_cc> @botsnack
12:38:48 <lambdabot> :)
12:38:48 <lunabot>  :)
12:38:50 <ozy`> ooh ooh
12:38:55 <paper_cc> ahem
12:38:57 <adh0c> is there a way to calculate fractional numbers with arbitrary precision?
12:38:57 <ozy`> :t [Data.Function..]
12:38:58 <lambdabot> parse error on input `]'
12:39:03 <paper_cc> , let 2 + 2 = 5 in 2 + 2
12:39:04 <lunabot>  5
12:39:15 <paper_cc> err
12:39:26 <Deewiant> :t [(Data.Function..)]
12:39:28 <lambdabot> forall b c a. [(b -> c) -> (a -> b) -> a -> c]
12:39:54 <paper_cc> CakeProphet: (a -> b) -> (b -> c) -> (a -> c) looks like (>>>)
12:39:55 <CakeProphet> > 3 + 3 = 10 in 3 + 3
12:39:56 <lambdabot>   <no location info>: parse error on input `='
12:40:06 <CakeProphet> > let 3 + 3 = 10 in 3 + 3
12:40:08 <lambdabot>   10
12:40:08 <vixey> :t [(.),id]
12:40:09 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
12:40:09 <CakeProphet> heh
12:40:09 <lambdabot>     Probable cause: `id' is applied to too many arguments
12:40:09 <lambdabot>     In the expression: id
12:40:11 <pumpkin> adh0c: fractional? there's Data.Ratio which gives you Rational, which using Integer numerators and denominators gives you arbitrary precision
12:40:14 <rwbarton> @botsnaRGHGHH
12:40:14 <lunabot>  :)
12:40:14 <lambdabot> Unknown command, try @list
12:40:19 <xian> Hi, is it possible in ghci to load a module in a "qualified" manner (in case of duplicate function names)?
12:40:19 <pumpkin> adh0c: if you want the computable reals, try CReal
12:40:19 <vixey> adh0c, yes
12:40:24 <vixey> adh0c, using (%)
12:40:27 <idnar> rwbarton: OM NOM NOM NOM
12:40:33 <xian> I tried :load qualified Module  and :load Module hiding (foo)  but both weren't accepted.
12:40:36 <paper_cc> @botsnaf
12:40:36 <lunabot>  :)
12:40:36 <lambdabot> :)
12:40:43 <rwbarton> xian: You can just use the qualified names without importing at all.
12:40:52 <CakeProphet> > 5 % 3
12:40:53 <lambdabot>   5%3
12:41:07 <CakeProphet> > (5 % 3) + (10 % 3)
12:41:09 <lambdabot>   5%1
12:41:12 <rwbarton> xian: But you can't do other things like "qualified import as" or "hiding", AFAIK (which would be very useful)
12:41:13 <ozy`> whoa
12:41:19 <adh0c> so, let's say I want to have 20 digits after the decimal point, what would I use?
12:41:21 <rwbarton> xian: except by loading a file that does those imports
12:41:25 <pumpkin> adh0c: CReal
12:41:29 <pumpkin> > pi :: CReal
12:41:31 <lambdabot>   3.1415926535897932384626433832795028841972
12:41:34 <pumpkin> > showCReal 50 pi
12:41:35 <rwbarton> , src ''Fixed
12:41:35 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
12:41:36 <lunabot>  luna: Not in scope: type constructor or class `Fixed'
12:41:39 <vixey> @src rational
12:41:39 <lambdabot> Source not found. My mind is going. I can feel it.
12:41:41 <adh0c> oh great
12:41:43 <adh0c> thanks
12:41:44 <vixey> @src Rational
12:41:45 <lambdabot> type Rational = Ratio Integer
12:41:47 <pumpkin> adh0c: it's a package though
12:41:58 <adh0c> oh
12:42:07 <pumpkin> adh0c: it's on hackage in the numbers package
12:42:10 <paper_cc> OT how does one set the secondary prompt for GHCI?
12:42:19 <CakeProphet> @instances Num
12:42:20 <lambdabot> Double, Float, Int, Integer
12:42:33 <CakeProphet> @instances-importing Data.Ratio Num
12:42:34 <lambdabot> Double, Float, Int, Integer, Ratio a
12:42:34 <adh0c> is there a way of doing this without downloading packages maybe?
12:42:47 <xian> rwbarton: Well, I'm trying to load the Module in ghciD[D[D[D[D[D[D[D.
12:42:52 <Deewiant> adh0c: sure, write it yourself :-P
12:42:55 <pumpkin> adh0c: write your own module for infinite precision reals?
12:42:56 <pumpkin> :P
12:43:00 <Deewiant> adh0c: but, uh, if you want fixed-point, just use Integer
12:43:02 <xian> sorry for those ctrl characters. I don't know where they were coming from :P
12:43:04 <pumpkin> adh0c: why not download it? it's pure haskell
12:43:08 <rwbarton> xian: ah, that must be the editline version of ghci :P
12:43:51 <CakeProphet> @src Ratio
12:43:52 <lambdabot> data (Integral a) => Ratio a = !a :% !a
12:44:15 <CakeProphet> ! means eager right?
12:44:29 <pumpkin> in some places
12:44:32 <pumpkin> (strict)
12:44:41 <pumpkin> if you put it in a data definition it does
12:44:54 <pumpkin> and sometimes as function/lambda parameters I think
12:45:06 <CakeProphet> pumpkin:  right, in a value context it's array subscript right?
12:45:10 <dolio> The latter is a GHC extention.
12:45:34 <paper_cc> dolio: {# LANGUAGE BangPatterns #}?
12:45:41 <pumpkin> CakeProphet: yeah, or whatever someone defined ! as if you didn't import array
12:45:45 <CakeProphet> > does Ratio define any helper functions along with it?
12:45:46 <lambdabot>   <no location info>: parse error on input `;'
12:45:47 <dolio> Yes. Although it's {-#
12:45:54 <paper_cc> heh
12:45:57 <CakeProphet> nevermind, I'll google.
12:45:59 <pumpkin> CakeProphet: like what?
12:46:50 <paper_cc> @ty approxRational
12:46:51 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
12:47:02 <CakeProphet> :t lcd
12:47:02 <dolio> > let r = 4 % 6 in (numerator r, denominator r)
12:47:03 <lambdabot> Not in scope: `lcd'
12:47:04 <lambdabot>   (2,3)
12:47:06 <CakeProphet> :t gcd
12:47:07 <lambdabot> forall a. (Integral a) => a -> a -> a
12:47:08 <CakeProphet> heh
12:47:33 <paper_cc> @where gcd
12:47:33 <lambdabot> I know nothing about gcd.
12:47:38 <paper_cc> @index gcd
12:47:38 <lambdabot> Prelude
12:47:47 <paper_cc> @index numerator
12:47:47 <lambdabot> Data.Ratio
12:48:17 <CakeProphet> The Data class comprehends a fundamental primitive gfoldl for folding over constructor applications, say terms.
12:48:19 <CakeProphet> is this greek to anyone else?
12:48:33 <adh0c> sounds like english to me
12:48:38 <vixey> doesn't make sense to me
12:48:46 <Deewiant> The Data class comprehends it; I don't
12:48:53 <dolio> "comprehends" sounds weird.
12:48:57 <rwbarton> the Data class is pretty intense.
12:49:04 <rwbarton> , src 'gfoldl
12:49:07 <lunabot>  Class op from Data: gfoldl :: forall a . Data a => forall c . (forall d b...
12:49:07 <lunabot>                                                                           ...
12:49:07 <lunabot>                                                                           ...
12:49:11 <pumpkin> nice
12:49:20 <rwbarton> , [$ty| gfoldl |]
12:49:23 <lunabot>  forall a b . Data a => (forall c d . Data d => b (d -> c) ->
12:49:23 <lunabot>                                                 d -> b c) ->
12:49:23 <lunabot>                         (forall e . e -> b e) -> a -> b a
12:49:27 <geezusfreeek> @src gfoldl
12:49:27 <lambdabot> Source not found. That's something I cannot allow to happen.
12:51:51 <pumpkin> this makes no sense to me:
12:51:52 <pumpkin> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however
12:51:52 <pumpkin> process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
12:52:02 <Deewiant> heh
12:52:21 <ksf> foreign import ccall safe "Agar/Core/Init.chs.h AG_InitCore"
12:52:21 <ksf>   initCore'_ :: ((Ptr CChar) -> (CUInt -> (IO CInt)))
12:52:24 <ksf>     Type found where type variable expected
12:52:26 <ksf> wut?
12:52:27 <paper_cc> @index Mu
12:52:27 <lambdabot> bzzt
12:52:34 <paper_cc> @index FixF
12:52:34 <lambdabot> bzzt
12:52:43 <paper_cc> err?
12:52:47 <ksf> CChar, that is.
12:52:55 <paper_cc> , src ''FixF
12:52:58 <lunabot>  newtype FixF f = InF {outF :: (f (FixF f))}
12:53:25 <ksf> pumpkin, do it like me, nuke your .cabal and .ghc.
12:53:40 <pumpkin> ksf: I did that once, didn't enjoy it much :/
12:54:00 <ksf> or do ghc-pkg unregister process-1.0.1.1 and hope.
12:54:12 <CakeProphet> > exp 10
12:54:13 <lambdabot>   22026.465794806718
12:54:21 <dcoutts> pumpkin: you almost certainly have a package registered in the global and user package dbs, the exact same version. Unregister the per-user one. It confuses cabal and it'll confuse ghc too.
12:54:23 <CakeProphet> ...wat.
12:54:51 <CakeProphet> what is exp?
12:55:03 <vixey> > iterate f x
12:55:04 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
12:55:06 <ksf> dcoutts, i got that error with 1.0.1.0 installed system-wide and 1.0.1.1 installed as -user
12:55:15 <ksf> s/got/had
12:55:16 <pumpkin> dcoutts: hmm, I'm just trying to upgrade haddock... is there some way of finding out which package is confusing it?
12:55:24 <maltem> CakeProphet: natural exponentiation function
12:55:31 <CakeProphet> ah
12:55:39 <pumpkin> > exp 1
12:55:40 <lambdabot>   2.718281828459045
12:55:50 <dcoutts> pumpkin: ghc-pkg list and look for the package where the exact same version is installed in both global and user sections
12:55:58 <dolio> > exp 1 :: CReal
12:55:59 <lambdabot>   2.7182818284590452353602874713526624977572
12:56:24 <CakeProphet> > significand pi
12:56:25 <lambdabot>   0.7853981633974483
12:56:29 <dcoutts> ksf: yes but it will have been because another package (the exact same version) was in both the user and global packages
12:56:42 <CakeProphet> > exponent pi
12:56:44 <lambdabot>   2
12:56:46 <Gracenotes> @hoogle Fractional a => CReal -> a
12:56:47 <lambdabot> Warning: Unknown type CReal
12:56:47 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
12:56:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:56:54 <dcoutts> ksf: so when the package dbs are merged it looks like a package that depends on the one that's being masked deps on two versions of the same package
12:57:09 <pumpkin> lol, I somehow managed to get cabal itself installed in both
12:57:20 <CakeProphet> > 5 ^^ 10
12:57:21 <lambdabot>   9765625.0
12:57:25 <CakeProphet> ...lolwat
12:57:26 <Gracenotes> unsafeCoerce...? Is there really any situation in which that would be useful?
12:57:42 <Deewiant> cases where the type system is stupider than you
12:57:44 <dcoutts> ksf: eg the ghc-6.10 api package depends on Cabal-1.6.0.1, but if that's also installed per-user and the per-user one deps on a different process package then it looks like the ghc package depends on two versions of the process package.
12:57:45 <pumpkin> Gracenotes: say you wanted to get the IEEE representation of your float :P
12:57:58 <Gracenotes> CakeProphet: are you thinking of 10^5?
12:58:06 <vixey> Gracenotes, no
12:58:07 <Gracenotes> > (5^10, 10^5)
12:58:08 <Deewiant> pumpkin: I don't think that'd work actually since you're not working on the unboxed representation
12:58:08 <lambdabot>   (9765625,100000)
12:58:09 <dolio> Gracenotes: No. It doesn't exist. :)
12:58:21 <CakeProphet> Gracenotes:  no... I'm wondering what ^^ does.
12:58:31 <geezusfreeek> Gracenotes, when you want to do stupid things like perform IO in the ST monad :P
12:58:34 <pumpkin> Deewiant: hmm, seemed to work when I tried it, maybe I did something differently though
12:58:35 <Deewiant> pumpkin: assuming Float -> Int, that is.
12:58:38 <vpetro> hmm, i am trying to convert this: http://paste.pocoo.org/show/101202/ into Haskell, but not sure what is the best way to go about it. Can anyone make a suggestion?
12:58:44 <pumpkin> Deewiant: I was doing it the other way around
12:58:51 <pumpkin> well Int32
12:58:55 <Deewiant> pumpkin: well, maybe it does, but I think it might be luck :-P
12:59:08 <pumpkin> :D
12:59:10 <tibbe> is puzzled about isEOFError, why should reading to the end of a file result in an exception?
12:59:12 <Gracenotes> so it would be used mostly when using direct primitive-based types?
12:59:18 <Gracenotes> (if at all)
12:59:24 <Gracenotes> CakeProphet: **, ^^, and ^ are exponential operators
12:59:36 <Deewiant> pumpkin: I honestly don't know, but the docs are rather explicit about what's defined to work.
12:59:40 <CakeProphet> Gracenotes:  what are ** and ^^?
12:59:47 <geezusfreeek> :t (**)
12:59:48 <lambdabot> forall a. (Floating a) => a -> a -> a
12:59:52 <geezusfreeek> :t (^)
12:59:53 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:59:55 <geezusfreeek> :t (^^)
12:59:56 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:00:00 <geezusfreeek> note differences
13:00:17 <CakeProphet> ...different typeclasses?
13:00:20 <Gracenotes> CakeProphet: note that CReal is both Fractional and Floating
13:00:51 <Gracenotes> if you want to exponentiate a CReal with a CReal base, use **
13:01:04 <Gracenotes> for a CReal to an integral base, try ^^ or ^
13:01:04 <CakeProphet> ah... ** allows Floating exponents...
13:01:07 <pumpkin> unless it's negative
13:01:11 <CakeProphet> ^ is integer exponents, more or less.
13:01:13 <pumpkin> in which case you probably want a ComplexCReal
13:01:14 <Gracenotes> oh, yeah. That's true.
13:01:33 <CakeProphet> and ^^ is integer exponentiation for Fractionals?
13:01:49 <dolio> Yes.
13:01:51 <Gracenotes> > 5 ^^ (-2.5) :: Complex CReal
13:01:51 <pumpkin> :t (^)
13:01:53 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:01:53 <lambdabot>   Add a type signature
13:01:54 <pumpkin> :t (^^)
13:01:55 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:01:56 <Gracenotes> ee
13:01:56 <pumpkin> :t (**)
13:01:57 <lambdabot> forall a. (Floating a) => a -> a -> a
13:02:02 <dolio> > 5 ^ (-1)
13:02:03 <lambdabot>   * Exception: Negative exponent
13:02:07 <dolio> > 5 ^^ (-1)
13:02:08 <lambdabot>   0.2
13:02:28 <CakeProphet> > 5 ** (-1)
13:02:29 <lambdabot>   0.2
13:02:48 <geezusfreeek> > (5 :: Int) ** (-1)
13:02:49 <lambdabot>       No instance for (Floating Int)
13:02:49 <lambdabot>        arising from a use of `**' at <in...
13:03:00 <geezusfreeek> > (5 :: Int) ^^ (-1)
13:03:00 <Gracenotes> > 5 ** (0.5) :: CReal
13:03:01 <lambdabot>       No instance for (Fractional Int)
13:03:01 <lambdabot>        arising from a use of `^^' at <...
13:03:02 <lambdabot>   2.2360679774997896964091736687312762354406
13:03:05 <xian> sorry to be still bothering you, but I still can't load a module into ghci via :load when there is a function defined in the module I want to load that is also the name of another function defined in the Prelude
13:03:23 <pumpkin> xian: you want :m, not :l
13:03:31 <bolrod>  :m +List
13:03:38 <pumpkin> or you can just refer to the fully qualified name
13:04:15 <bolrod> I was wondering.. anyone tried to make haskell with only smiley functions? :)
13:04:26 <Gracenotes> also, "import X" is a shortcut for ":m +X", which I find easier to type
13:04:29 <bolrod> > let (^.^) = (+) in 1 ^.^ 2
13:04:30 <lambdabot>   3
13:04:44 <Gracenotes> bolrod: I made something like that once...
13:05:00 <Gracenotes> @quote Gracenotes lol
13:05:00 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
13:05:14 <bolrod> :)
13:05:15 <bohdan> > it -- does lambdabot support 'it' ?
13:05:17 <lambdabot>   Not in scope: `it'
13:05:44 <geezusfreeek> > let it = 8 in it
13:05:46 <lambdabot>   8
13:06:02 <vixey> I can't figure out how to implement the type rule of lambda :/
13:06:22 <roconnor> vixey: sounds tricky
13:11:06 <CakeProphet> ...IO is a functor?
13:11:18 <vixey> yes
13:11:31 <pumpkin> any monad is a functor
13:11:42 <CakeProphet> fmap f io = io >>= f  ?
13:11:46 <pumpkin> liftM
13:11:53 <CakeProphet> er...
13:11:57 <dolio> io >>= return . f
13:11:58 <CakeProphet> fmap f io = io >>= (return.f)  ?
13:11:58 <BONUS_> fmap (++"!") getLine
13:12:00 <CakeProphet> yeah
13:12:01 <Gracenotes> (a -> b) -> (IO a -> IO b)
13:12:46 <vixey> :t (>>=) . (return .)
13:12:47 <lambdabot> forall b b1 (m :: * -> *) a. (Monad m) => (a -> b1) -> (m b1 -> a -> b) -> a -> b
13:12:53 <idnar> CakeProphet: fmap = liftM
13:12:59 <vixey> :t (return .) . (>>=)
13:13:00 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m1, Monad m) => m1 a -> (a -> m1 b) -> m (m1 b)
13:13:11 <vixey> @pl fmap f io = io >>= (return.f)
13:13:11 <lambdabot> fmap = fmap
13:13:14 <Gracenotes> CakeProphet: it's possible to write any fmap with >>=, but iirc not the other way around though
13:13:20 <vixey> @pl fmap f io = io >>>= (returrn . f)
13:13:20 <lambdabot> fmap = flip (>>>=) . (returrn .)
13:13:22 <CakeProphet> so why not not have an instance for (Monad m) => Functor m a
13:13:36 <CakeProphet> instead of using liftM
13:13:47 <dolio> That overlaps with every other instance.
13:13:55 <idnar> well, in an ideal universe, Monad would be a subclass of Functor
13:14:25 <idnar> (or actually, Functior => Applicable => Monad or something, but you get the idea)
13:14:29 <idnar> Applicative?
13:14:31 <pumpkin> yup
13:14:36 <idnar> my brain is fried
13:15:49 <Gracenotes> @hoogle Monad m => m (a -> b) -> m a -> m b
13:15:50 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:15:50 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
13:15:50 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:15:59 <Gracenotes> ah
13:16:14 <Gracenotes> duh... :P
13:17:34 <idnar> yeah, ap = <*>
13:18:39 <pumpkin> sweet, I can launch missiles from my STM transactions now!
13:18:54 <BrokenClockwork> Hey, I want to test a product, if the product containts this and that or this and that numbers... would you advice me to use digitToInt and test the list with elem?
13:19:04 <idnar> up unsafeLaunchMissiles?
13:19:05 <idnar> er
13:19:07 <idnar> pumpkin: unsafeLaunchMissiles?
13:19:22 <pumpkin> doesn't even need to be unsafe!
13:19:32 <pumpkin> these missiles are super safe
13:19:39 <vixey> unsafeDigitToInt
13:19:46 <BrokenClockwork> ^^
13:19:49 <pumpkin> it is unsafe!
13:19:54 <pumpkin> > digitToInt 'a'
13:19:55 <lambdabot>   10
13:20:00 <pumpkin> > digitToInt 'x'
13:20:01 <lambdabot>   * Exception: Char.digitToInt: not a digit 'x'
13:20:02 <pumpkin> :(
13:20:24 <BrokenClockwork> > map digitToInt . show 12
13:20:25 <lambdabot>   Couldn't match expected type `a -> [Char]'
13:20:38 <pumpkin> $
13:20:38 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
13:20:38 <BrokenClockwork> > map digitToInt . show $ 12
13:20:40 <lambdabot>   [1,2]
13:20:48 <bohdan> @hoogle (a,b,c)->b
13:20:48 <nothingmuch> bah
13:20:48 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
13:20:48 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
13:20:51 <nothingmuch> what happenned to http://chrisdone.com/haskell/unsafe.txt ?
13:21:02 <BrokenClockwork> it was to unsafe
13:21:06 <BrokenClockwork> so its being deleted
13:21:09 <pumpkin> @seen kriss
13:21:09 <lambdabot> I haven't seen kriss.
13:21:28 <sjanssen> nothingmuch: probably an unsafePerformIO . removeFile
13:22:40 <Gracenotes> yeah, it's so difficult to perform IO when you're using a REPL wrapped in the IO monad
13:22:59 <dons> stepcut:
13:23:00 <dons> utils/CabalDebian.hs:16:17:
13:23:00 <dons>     Could not find module `Distribution.Package.Debian.Main':
13:23:00 <dons>       Use -v to see a list of the files searched for.
13:23:41 <Gracenotes> @hoogle IO (a -> b)
13:23:41 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
13:23:41 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
13:23:41 <lambdabot> Control.Parallel.Strategies sPar :: a -> Strategy b
13:24:03 <pumpkin> Gracenotes: :o
13:25:58 <pumpkin> > unsafeListenTraviata
13:25:59 <lambdabot>   Not in scope: `unsafeListenTraviata'
13:26:13 <Gracenotes> @hoogle Maybe (a -> b)
13:26:13 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
13:26:14 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
13:26:14 <lambdabot> Control.Parallel.Strategies sPar :: a -> Strategy b
13:26:16 <stepcut> dons: that should be fixed in the version that is live now
13:26:18 <Gracenotes> ..
13:26:24 <pumpkin> Gracenotes: what are you looking for?
13:26:26 <stepcut> dons: I am about to update again though
13:26:44 <stepcut> dons: fixed in 3.17.1 I think
13:26:46 <Gracenotes> pumpkin: anything Monad m => m (a -> b) that exists in the standard packages :)
13:26:53 <Gracenotes> hm, maybe I should try that
13:27:01 <dons> great
13:27:01 <stepcut> dons: I am uploading 3.18 shortly
13:27:03 <Gracenotes> @hoogle Monad m => m (a -> b)
13:27:03 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
13:27:03 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
13:27:03 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
13:27:15 <Gracenotes> apparently not
13:27:33 <pumpkin> what would such a thing do? :P
13:28:13 <pumpkin> just "be"?
13:28:16 <mreh> Has anyone here ever designed a GA in haskell?
13:28:18 <pumpkin> a monad-wrapped function? :P
13:28:22 <Gracenotes> I've never had to use `ap` before that much... wondering if the first argument comes up at all in type signatures :)
13:28:46 <Gracenotes> `ap` does operate on monad-wrapped functions, after all...
13:28:48 <pumpkin> I don't think hoogle will find subsets
13:29:10 <pumpkin> well, List
13:29:11 <pumpkin> > ap [(+1), (*2)] [1,2,3]
13:29:13 <lambdabot>   [2,3,4,2,4,6]
13:29:21 <pumpkin> but I don't think it exists much in general
13:30:15 <Gracenotes> yeah... ap is not the function for me. *hugs liftM\d? close*
13:31:39 * ksf whines
13:31:57 <ksf> {#enum define#} doesn't understand macros using |
13:33:28 <bohdan> > let wc = map (intToDigit . length . (filter isAlpha)) . words in wc "How I want a drink, alcoholic of course, after the heavy lectures involving quantum mechanics!"
13:33:29 <lambdabot>   "314159265358979"
13:33:46 <trofi> :D
13:34:47 <vixey> intToDigit . length . (filter isAlpha) = intToDigit . length . filter isAlpha
13:35:03 <stepcut> dons: uploaded 3.18.1
13:35:40 <dixie> > 40+2
13:35:41 <lambdabot>   42
13:36:03 * Nafai works on profiling his program
13:37:50 <Nafai> How do I install the profiling libraries for libraries I've installed with cabal install?
13:38:35 <pumpkin> you --reinstall the ones you want with -p
13:38:38 <Deewiant> --enable-profiling IIRC; not sure if there's an easy way to do it for everything you've already got installed
13:38:45 <pumpkin> and go through and do it on their dependencies too
13:38:48 <pumpkin> and their dependencies
13:38:50 <pumpkin> and so on :P
13:39:01 <Deewiant> the thing to do is to edit your .cabal/config before you install anything
13:39:18 <Deewiant> so you never install anything without profiling libraries :-P
13:39:28 <Deewiant> I really don't understand why it's not the default
13:39:31 <pumpkin> yeah, that's what I ended up doing
13:40:24 <Nafai> pumpkin, Deewiant: Thanks
13:41:04 <Nafai> library-profiling in .cabal/config?
13:41:12 <bohdan> > words "How I want a drink, alcoholic of course, after the heavy lectures involving quantum mechanics!" >>= return . intToDigit . length . filter isAlpha -- monadic version is more confusing :)
13:41:13 <lambdabot>   "314159265358979"
13:42:25 <pumpkin> Nafai: yes
13:43:30 <ksf> dcoutts, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=915#a915
13:44:08 <Gracenotes> > concatMap ((:[]) . intToDigit . length . filter isAlpha) $ words "How I want a drink, alcoholic of course, after the heavy lectures involving quantum mechanics!"
13:44:10 <lambdabot>   "314159265358979"
13:44:52 <bohdan> Gracenotes: in fact you can get by with a simple 'map'
13:46:24 <olsner> > intToDigit . length . filter isAlpha <$> words "foo bar"
13:46:25 <lambdabot>   "33"
13:47:12 <Gracenotes> bohdan: yes, you can, as pumpkin did above
13:47:41 <Gracenotes> just wrapping and unwrapping for (>>=) :)
13:48:12 <Gracenotes> bohdan: er, actually, you did it above. never mind.
13:48:37 <bohdan> @pl \a -> head a : '.' : tail a
13:48:37 <lambdabot> liftM2 (:) head (('.' :) . tail)
13:48:44 * pumpkin loves taking credit though, so feel free to keep doing it
13:48:56 <pumpkin> :)
13:49:57 <bohdan> \(x:xs) -> x : '.' : xs
13:50:13 <bohdan> @pl \(x:xs) -> x : '.' : xs
13:50:13 <lambdabot> ap ((. ('.' :)) . (:) . head) tail
13:50:17 <bohdan> hmmm
13:50:24 <bohdan> is there something like insertAt ?
13:51:16 <bohdan> @src insert
13:51:16 <lambdabot> insert e ls = insertBy (compare) e ls
13:51:50 <BrokenClockwork> I need an explanation for this code: permutate xs = [x:ys | x <- xs, ys <- permutate (delete x xs)] it permutate list of lists, however I don't get the (delete x xs). for instance when I enter [1,2] it should be (delete [1,2] [1,2]) which makes no sense, cuz this should not work, but it does, how?
13:52:05 <BrokenClockwork> it permutates lists*
13:52:39 <bohdan> > [x | x <- [1..3]]
13:52:40 <lambdabot>   [1,2,3]
13:53:04 <islon_s> what do you people use to program in haskell?
13:53:12 <trofi> > [(a,b) | a<-[1,2], b<-[3,4]]
13:53:14 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
13:53:16 <BrokenClockwork> Vim
13:53:18 <trofi> islon_s: irc client
13:53:18 <Nafai> Hrm, that wasn't helpful :(
13:53:24 <pumpkin> islon_s: textmate, but not too satisfied
13:53:28 <bohdan> > [ k | x <- [1..3], k <- delete x [1..3]]
13:53:29 <lambdabot>   [2,3,1,3,1,2]
13:53:33 <Badger> for balance
13:53:37 <Badger> I'll say emacs
13:53:52 <islon_s> the emacs mode is not very helpfull
13:54:02 <bohdan> > [ (x,k) | x <- [1..3], k <- delete x [1..3]] -- BrokenClockwork, this should make it clear
13:54:04 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
13:54:17 <BrokenClockwork> yeah thanks, that was what I was been looking for :)
13:54:57 <maltem> BrokenClockwork: it's not delete [1,2] [1,2] because x is not a list
13:55:03 <BrokenClockwork> well, I use Vim, because BONUS sent me his awesome color lightening from his tutorial. I see no big deal to use just your normal texteditor
13:55:50 <mreh> is there a way to make a fixed length list?
13:56:06 <tromp__> replicate
13:56:20 <islon_s> when you are used to eclipse java features it IS hard to use your normal text editor
13:56:29 <tromp__> btw, every list has its length fixed:)
13:56:33 <mreh> i mean define a fixed length list in a type synonym
13:56:38 <pumpkin> how about infinite ones? :o
13:56:41 <icqnumber> Is there a easy way to see which of two given function works faster in ghci?
13:56:48 <icqnumber> s/a/an
13:56:50 <mreh> tuples suckz
13:56:53 <pumpkin> icqnumber: :set +s, but it's not a complete picture
13:57:19 <pumpkin> icqnumber: since some types of functions are designed to work better (way better) after a certain kind of optimization that ghci won't apply
13:57:23 <icqnumber> pumpkin, What do you mean with "a complete picture"
13:57:37 <maltem> mreh: you *can* do some type hackery, but it isn't usually worth it I'd say
13:57:41 <pumpkin> so it may look like one function is faster in ghci, whereas in a compiled program with -O2, the other one is way faster
13:57:41 <BrokenClockwork> the best comparing time is the compiled version of your programm
13:57:49 <ksf> btw, who decided on using vi-syntax for ghci? I want to hand out a ++
13:58:04 <BrokenClockwork> what is vi-syntax?
13:58:12 <ksf> :set foobar
13:58:14 <pumpkin> colons
13:58:17 <ksf> ...for exampl.
13:58:20 <mreh> maltem: tell me more
13:58:32 <vixey> data LengthFiveList a = LengthFiveList a a a a a
13:58:37 <mreh> maltem: the alternative is a 10-tuple
13:58:39 <icqnumber> pumpkin, but will the result hold without optimizations ?
13:58:57 <maltem> mreh: oh, you mean, the length is always ten?
13:58:59 <vixey> or
13:59:00 <pumpkin> icqnumber: I wouldn't rely on it, compiled code is still different from the bytecode
13:59:10 <vixey> data LengthFiveList a = LengthFiveCons a (LengthFourList a)
13:59:16 <mreh> i want to be able to operate on the data-structure recursively for the sake of brevity
13:59:21 <pumpkin> icqnumber: it can give you a very general idea, but just keep in mind that it's not always true
13:59:42 <mreh> vixey, that's hardly maintainable
13:59:50 <pumpkin> with TH it sort of is
14:00:00 <pumpkin> but GHC will be sad if you make bigs ones
14:00:01 <icqnumber> pumpkin, Good, Thank you.
14:00:14 <maltem> mreh: okay, so the length is not always ten. then you'd have to annotate the list type with its length
14:00:16 <mreh> maltem: ues
14:00:30 <Saizan> data Vec n a where Nil :: Vec Zero a; Cons :: a -> Vec n a -> Vec (Succ n) a; type LengthFileList a = Vec (Succ (Succ (Succ (Succ (Succ Zero))))) a
14:00:37 <maltem> mreh: (it cannot be always ten if you're going to recurse on the structure)
14:00:56 <Saizan> mreh: that's recursive, and you can set the length in the type
14:01:01 <maltem> mreh: er... well what Saizan just did
14:01:16 <mreh> maltem: it's a type synonym for a recursive datatype that is only length 10
14:02:39 <mreh> thanks Saizan, ill give it a go
14:04:52 <Saizan> you need {-# LANGUAGE GADTs, EmptyDataDecls #-} and data Zero; data Succ a;  for that
14:05:50 <icqnumber> pumpkin, because i would spontaneously say that the fist version will work faster http://codepad.org/DyQsL3j0
14:05:58 <Gracenotes> :t liftIO
14:06:00 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:06:05 <Gracenotes> @src liftIO
14:06:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:07:05 <Saizan> http://haskell.org/pipermail/haskell/2005-May/015815.html
14:07:39 <icqnumber> pumpkin, But, it seems not to be the case.
14:08:45 <pumpkin> icqnumber: why would you intuitively think that?
14:10:10 <icqnumber> pumpkin, Because it uses two lists, and many functions ( tail head, func)...
14:10:13 <Ro0ster> Help me, I can't view this site: http://gamingguru.org/index.php
14:10:32 <Raevel> -_-
14:10:32 <pumpkin> icqnumber: the first one isn't tail-recursive though
14:10:39 <icqnumber> pumpkin, And Integer instead of Int
14:14:24 <BONUS_> it would be great if haskell was used in some sort of government defense system or something so that there would be a function that returns an actual IO action that launches the missiles
14:14:37 <BONUS_> like, literally
14:15:16 <icqnumber> pumpkin, The second one myLen takes xs apart the same way as the first one, and uses one extra list, the only one thing which explains that, is that addition is very slow...
14:15:33 <pumpkin> nope
14:15:37 <pumpkin> as I said, the first one isn't tail-recursive
14:15:51 <pumpkin> so it needs to maintain a list of "pending" additions
14:15:54 <maltem> BONUS_: I'm not sure how that would be great
14:15:55 <pumpkin> until it reaches the end of the list
14:17:55 <bohdan> now, we all know that govt defence systems use ada
14:19:04 <BONUS_> maltem: yeah that would actually suck, maybe in a controller for toy missiles?
14:19:42 <icqnumber> pumpkin, Ok, You have a better explanation.
14:19:58 <pumpkin> @src length
14:19:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:19:59 <ehird> BONUS_: no, no
14:20:01 <ehird> that would be great
14:20:03 <ehird> unsafeLaunchMissiles
14:20:13 <ehird> perhaps
14:20:17 <vixey> -_-
14:20:24 <vixey> I got this HTTP error
14:20:27 <vixey>  Attempted to divide by zero.
14:20:27 <vixey> Description: An unhandled exception occurred during the execution of the current web request. Please review the stack trace for more information about the error and where it originated in the code.
14:20:27 <vixey> Exception Details: System.DivideByZeroException: Attempted to divide by zero.
14:20:27 <pumpkin> bah, I can't convince haddock to generate a top-level description on a module
14:20:29 <dons> arch haskell news of the week, http://archhaskell.wordpress.com/2009/01/24/arch-haskell-news-jan-24-2009/
14:20:31 <ehird> unsafeLaunchMissilesDONOTCALLTHISFUNCTIONGODDAMMITJUSTDONTSTAYAWAYAndHereIsSomeMoreObnoxixioxixiuousNameSoYouDontCallIt
14:20:37 <vixey> ... and I thought it was supposed to be a joke
14:20:40 <Gracenotes> BONUS_: I'm sure there's a C interface for launching some toy rockets somewhere
14:20:41 <ehird> ha
14:20:55 <Gracenotes> or if not, you could probably write one. And then have a Haskell interface on top of it :)
14:21:17 <BONUS_> yeah definitely gonna do that one day haha
14:21:28 <bohdan> vixey: and...?
14:21:39 <vixey> end of lame story
14:21:40 <ddarius> ehird: tab completion
14:21:50 <ehird> ddarius: outlaw tab completing editors.
14:21:56 <Gracenotes> BONUS_: or, if you can write a program that moves a simple robot, but it next to the missile control system
14:22:00 <Gracenotes> *put
14:22:06 * bohdan is probably not getting some secret truth about magical programming languages that prevent division by zero
14:22:11 <vixey> bohdan, but I blame IRC
14:22:36 <Gracenotes> I know there are possibilities for robot-writing in C
14:23:23 <dons> :t div
14:23:24 <lambdabot> forall a. (Integral a) => a -> a -> a
14:23:36 <dons> div :: a -> a -> Maybe a :)
14:23:47 <pumpkin>  is there some secret to getting haddock to generate a top-level "Description" section?  all the docs say about it is http://www.haskell.org/haddock/doc/html/ch03s03.html
14:24:20 <olsner> "stm-io-hooks: launch missles from your STM transactions" :)
14:24:21 * skorpan enjoys seeing lennart augustsson post to haskell-cafe
14:26:36 <ddarius> skorpan: ?
14:26:55 <ddarius> skorpan: More specifically, why do you enjoy it/what's so special about it?
14:27:24 <skorpan> ddarius: because he's "from" chalmers, the university i go to
14:27:33 <idnar> unsafeDeliverPizza
14:28:01 <BrokenClockwork> how are is more then one module importet?
14:28:10 <BrokenClockwork> import x, y?
14:28:14 <BrokenClockwork> x | y ?
14:28:22 <geezusfreeek> mapM_ print $ repeat unsafeDeliverPizza
14:28:23 <skorpan> BrokenClockwork: import X\nimport Y
14:28:53 <BrokenClockwork> ok
14:29:20 <BrokenClockwork> @src 'digitToInt
14:29:21 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:29:29 <BrokenClockwork> @src digitToInt
14:29:30 <lambdabot> Source not found. It can only be attributed to human error.
14:33:03 <ehird> :t \a b -> a+(b/2)
14:33:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:33:09 <ehird> i get the infinite type
14:33:11 <ehird> when doing that
14:33:37 <geezusfreeek> @pl \a b -> a+(b/2)
14:33:37 <lambdabot> (. (/ 2)) . (+)
14:34:07 <geezusfreeek> @pl \b a -> a+(b/2)
14:34:08 <lambdabot> (+) . (/ 2)
14:34:56 <ehird> helpful :\
14:35:10 <skorpan> @djinn (Fractional a) => a -> a -> a
14:35:11 <lambdabot> Error: Class not found: Fractional
14:35:15 <skorpan> akk!
14:35:32 <ehird> Prelude> let a ($$) b = a+(b/2)
14:35:32 <ehird> <interactive>:1:18:
14:35:34 <ehird>     Occurs check: cannot construct the infinite type: a = t1 -> a -> t
14:35:36 <geezusfreeek> ehird, sorry, i wasn't trying to be helpful. i do not know what the problem could be
14:35:36 <ehird>     Probable cause: `/' is applied to too many arguments
14:35:51 <ehird> ok :)
14:35:51 <geezusfreeek> oh
14:36:02 <geezusfreeek> try let a $$ b = a+(b/2)
14:36:15 <ehird> oh, duh :)
14:36:18 <geezusfreeek> ;)
14:39:40 <olsner> dons: eeek, the haskell spectralnorm entry is still doing the wrong thing (unsynchronizedly running all iterations in parallel)
14:40:06 <BrokenClockwork> I am searching for a function, which returns a list item with the index n
14:40:21 <vixey> BrokenClockwork, it would be in Data.List if it existed
14:40:58 <pumpkin> !!
14:41:01 <dons> olsner: ?
14:41:14 <bohdan> @hoogle [a] -> Int -> a
14:41:14 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:41:14 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:41:14 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
14:41:23 <dons> looks synchronized to me.         putMVar children (me : cs) forkIO (child `finally` putMVar me ())
14:41:47 <BrokenClockwork> > !! [3,4,5,6] 3
14:41:48 <lambdabot>   <no location info>: parse error on input `!!'
14:41:58 <tromp__> use (!!)
14:42:00 <dmwit> > (!!) [3,4,5,6] 3
14:42:01 <lambdabot>   6
14:42:02 <BrokenClockwork> > (11) [3,4,5,6] 3
14:42:04 <lambdabot>       No instance for (Num ([t] -> t1 -> a))
14:42:04 <lambdabot>        arising from the literal ...
14:42:12 <BrokenClockwork> woopsie :)
14:42:36 <bohdan> > [1..10] !! 5
14:42:37 <lambdabot>   6
14:42:52 * bohdan <3 double-factorial operator
14:43:11 <bohdan> > let double-factorial = (!!)
14:43:12 <lambdabot>   <no location info>: parse error on input `;'
14:43:16 <olsner> dons: but each child is reading its data (which should be from the previous iteration) and writing its result (the input of the next iteration) into the same array at the same time, afaics
14:43:21 <idnar> heh
14:43:35 <bohdan> aaargh
14:43:39 <idnar> bohdan: can't use - in an identifier
14:43:44 <idnar> try _
14:43:44 <bohdan> > let doubleFactorial = (!!)
14:43:45 <tromp__> use _
14:43:45 <lambdabot>   <no location info>: parse error on input `;'
14:43:56 <tromp__> and use @let
14:43:56 <dmwit> > let doubleFactorial = (!!) in 3
14:43:58 <lambdabot>   3
14:44:14 <bohdan> @let doubleFactorial = (!!) -- finally! :)
14:44:16 <lambdabot>  Defined.
14:44:18 <dons> olsner: relies on the scheduler not getting  things out of order, i guess
14:44:31 <bohdan> > doubleFactorial "Hello world" 7
14:44:32 <lambdabot>   'o'
14:44:35 <dons> feel free to write a more explicitly orderred versoin
14:44:36 <pumpkin> BrokenClockwork: beware, !! can be quite slow
14:44:45 <BrokenClockwork> I thought so
14:44:47 <BrokenClockwork> :)
14:44:47 <dmwit> No!
14:44:51 <dmwit> Speedy like cheetah!
14:45:05 <olsner> I suspect the benchmark data just doesn't produce very different results no matter the number of iterations
14:45:43 <tromp__> > enumFromTo 1 3
14:45:44 <lambdabot>   [1,2,3]
14:45:52 <olsner> with this version, the result differs slightly (in the 6th decimal place or so) with different +RTS -Nn parameters
14:46:08 <tromp__> @let singleFactorial = product . enumFromTo 1
14:46:09 <idnar> @hoogle enum
14:46:13 <lambdabot>  Defined.
14:46:13 <BrokenClockwork> I am working on Euler problem #32 right now for this, very annoying ^^
14:46:15 <lambdabot> Prelude class Enum a
14:46:17 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
14:46:19 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
14:47:27 <bohdan> > doubleFactorial [0..200] $ singleFactorial 5
14:47:28 <lambdabot>   120
14:48:15 <dons> olsner: right, so its relying on the scheduler
14:48:21 <dons> which is a bit .. fragile
14:48:41 <agcorona> someone can point me to the documentation of the GHC API
14:48:42 <agcorona> ?
14:48:44 <bohdan> > doubleFactorial (map singleFactorial [1..200]) (singleFactorial 5)
14:48:45 <lambdabot>   809429852527344373968162284544935082997082306309701607045776233628497660426...
14:49:04 <idnar> heh
14:49:26 <roconnor> @hoogle Sum
14:49:27 <lambdabot> Data.Monoid newtype Sum a
14:49:27 <lambdabot> Data.Monoid Sum :: a -> Sum a
14:49:27 <lambdabot> Prelude sum :: Num a => [a] -> a
14:50:00 <dmwit> agcorona: Documentation?  GHC API?  hahahaha
14:50:11 <agcorona> does not exist?
14:50:19 <dmwit> agcorona: :browse has about the best information that's available.
14:50:51 <agcorona> do you know if there are hooks for the debugger?
14:51:04 <agcorona> hooks to the debugger i mean
14:51:07 <ksf> do I upset people if I define type Error = Maybe String and return IO Error's?
14:51:31 <ehird> how can I fix the emacs inferior-haskell problem that repeats the input you give it before the result? :(
14:51:32 <dmwit> ksf: Nope, though there is an Error class that you might want to look into.
14:52:29 <ksf> I'm wondering whether I should throw exceptions instead.
14:52:36 <idnar> ksf: that's not a great error type, how do you know what the error was?
14:52:48 <ksf> you look at the string.
14:53:05 <ksf> it's just what agar provides me with.
15:01:57 <olsner> dons: here's mine: http://haskell.org/haskellwiki/Shootout/Parallel/SpectralNorm#ST.2FIOUArray-based_solution - how do I go about submitting it to the shootout?
15:02:23 <loadquo> Is there a list of Haskell projects that need help anywhere? Preferably not heavily monadic I'm getting a fair amount of practice with that style.
15:03:08 <pumpkin> olsner: parallel?
15:03:33 <pumpkin> loadquo: most projects on hackage I'm sure would welcome some input in the form of darcs/git/whatever SCM patches
15:04:20 * loadquo browses hackage
15:04:37 <olsner> pumpkin: yes, we already had parallel versions, but this one parallelises by splitting the data within each iteration rather than parallelising the iterations
15:04:43 <pumpkin> ah
15:05:41 <roconnor> what is the opposite of "representative"?  If A is B's representative, then B is A's ____.
15:06:02 <olsner> "representee"?
15:06:21 <pumpkin> constituent ;)
15:06:24 <roconnor> or if As are the set of represenatives, then Bs is the set of _____
15:06:42 <rwbarton> equivalence classes? (guessing wildly here)
15:06:47 <ksf> represented?
15:06:58 <rwbarton> home state? :)
15:07:07 <ksf> as in passive of to represent
15:07:15 <vixey> roconnor, you can't say just  B is equal to A ?
15:07:37 <pumpkin> I'm just obviously basing my guess on politics :P
15:07:40 <pumpkin> which probably doesn't fit very well
15:07:41 <roconnor> vixey: cauchy sequences represent real numbers, but cauchy sequences are not real numbers.
15:07:55 <roconnor> pumpkin: you have the best term so far :D
15:07:57 <ksf> If you want grammar, you can say "represented thingies" or "represented people"
15:07:59 <vixey> I thought they were :S
15:08:30 <Riastradh> roconnor, that depends on your point of view!  Cauchy sequences (of rationals) are a perfectly legitimate construction of the real numbers.
15:08:36 <ddarius> roconnor: equivalence class
15:08:36 * ksf thinks he got too much german grammar in his head
15:08:48 <Riastradh> (Well, equivalence classes of Cauchy sequences, to be precise.)
15:08:56 <vixey> hi Riastradh!
15:09:33 <roconnor> vixey: cauchy sequences are not a monoid under +, but real numbers are
15:09:47 <vixey> so it's like
15:09:51 * roconnor wonders if that is true
15:09:55 <vixey> newtype R = R CauchyConvergentSequence
15:10:10 <roconnor> maybe that is a bad example.
15:10:16 <roconnor> but that is the idea
15:10:16 <rwbarton> roconnor: cauchy sequences are a monoid under +, aren't they?
15:10:43 <rwbarton> roconnor: sequences with a particular convergence condition probably aren't a monoid under +
15:10:59 <roconnor> rwbarton: right
15:11:21 <roconnor> maybe I can use fast converging cauchy sequences
15:12:47 <roconnor> so fast cauchy sequences are representatives
15:13:09 <roconnor> monoid laws don't apply to representatives, they apply to _______
15:14:02 <ddarius> roconnor: Equivalence class is what you want.
15:14:04 <ksf> aaaargh
15:14:16 <ddarius> Representatives are representatives -of- equivalence classes.
15:14:17 <ksf> xmonad thinks I'm on a 640x480 screen
15:14:27 <BONUS_> this owns: http://www.reddit.com/r/haskell/comments/7s6l0/fast_incremental_regular_expression_matching_with/ everyone upvote this up :]
15:14:45 <roconnor> ddarius: not broad enough.  partial functions can be representatives.  I suppose I could say PER
15:14:54 * rwbarton plans to upvote it down
15:14:56 <pumpkin> lol
15:15:01 <roconnor> but that still doesn't feel right.
15:15:03 <ddarius> roconnor: representatives of?
15:15:31 <ddarius> roconnor: Incidentally, you are wrong (re your email post)
15:15:40 <roconnor> good, explain
15:15:53 <ddarius> roconnor: As a trivial case, interpreters.
15:15:53 <ksf> SDL fullsrceen is evil.
15:16:05 <roconnor> what about interpreters
15:16:10 <bohdan> @pl \a -> a == f a
15:16:10 <lambdabot> ap (==) f
15:16:18 <bohdan> @src ap
15:16:18 <lambdabot> ap = liftM2 id
15:16:40 <Gracenotes> hm, units of measure inference in F# looks interesting... does Haskell have anything like that?
15:16:42 <loadquo> Has anyone done any work with the probability packages on hackage?
15:16:44 <ksf> it doesn't seem to know that you can go fullscreen without grabbing all of the display.
15:16:58 <ddarius> roconnor: A correct implementation of an interpreter (for a Turing-complete language) is not total.
15:17:28 <ddarius> Another example, arguably is if d == 0 then 0 else 1/d,  the subexpression 1/d is not total technically.
15:18:16 <roconnor> I'm going to weezle out of that one for now and say that the interpreter's precondition is that the code is total.  But I'll think about it.
15:18:33 <roconnor> I don't like my weezling
15:18:55 <vixey> what's this about?
15:19:00 <rwbarton> Gracenotes: Not out of the box, but there's a "dimensional" library
15:19:22 <ddarius> roconnor: Another example is a web server, but then you can say "or productive."
15:19:32 <Gracenotes> yeah, an extension's great too :) just curious about the semantics of it
15:19:35 <Gracenotes> @hackage dimensional
15:19:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional
15:19:39 <roconnor> ddarius: productive functions are obviously total
15:19:45 <roconnor> (but not finite)
15:20:20 <Gracenotes> wow, Dim... quite a long constructor
15:20:24 <roconnor> ddarius: now that i think about it, perhaps I don't need to talk about total/partial constituents, only total/partial represenatives
15:20:34 <ddarius> Not with the usual technical definition of "total" or else the term "productive" wouldn't need to exist.
15:20:54 <roconnor> ddarius: the constituants perhaps are not even a CPO.
15:21:01 <roconnor> possible
15:21:05 <roconnor> possibly
15:21:09 <roconnor> anyhow, I'm off to dinner
15:21:12 <ddarius> CPOs are overrated
15:23:01 <vixey> is it off haskell cafe or something?
15:23:59 <loadquo> Gracenotes: I think there is some syntax sugar the (*~) operator appears to build them see (http://code.google.com/p/dimensional/wiki/GMExample)
15:24:19 <inv> re all
15:24:43 <inv> how to force calculation of expression ?
15:24:57 <rwbarton> Use it :)
15:25:01 <ddarius> inv:  Why do you want to do this?
15:25:06 <trofi> @src foldl'
15:25:06 <lambdabot> foldl' f a []     = a
15:25:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:25:15 <tromp__> use it or lose it
15:25:19 <inv> just a moment, I'll post an example
15:25:31 <inv> lambdabot: @paste2
15:25:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:25:38 <rwbarton> @where hpaste2
15:25:39 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:25:50 <ddarius> trofi: There are good reasons, but when you understand them you don't have such questions.
15:26:07 <inv> thx
15:26:33 <trofi> :t evaluate
15:26:35 <lambdabot> Not in scope: `evaluate'
15:26:40 <trofi> @hoogle evaluate
15:26:41 <lambdabot> Control.Exception evaluate :: a -> IO a
15:26:41 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
15:26:50 <inv> here it is: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=917#a917
15:27:20 <inv> I suppose pp3 should be tail-recursive
15:27:49 <rwbarton> wow, hpaste2 fali
15:27:51 <rwbarton> *fail
15:27:54 <inv> but it fails with stack error
15:28:50 <jeffz`> dcoutts: around?
15:31:13 <gwern> @seen dcoutts
15:31:14 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I don't know when dcoutts last spoke.
15:31:15 <inv> are where any tool to check if the function is tail-rec ?
15:31:22 <gwern> @seen dcoutts_
15:31:22 <lambdabot> Last time I saw dcoutts_ was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
15:31:22 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
15:31:22 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 25d 2h 37m 54s ago, and .
15:31:42 <Badger> heh
15:31:50 <vixey> inv, in the context of haskell/lazy fp it's not clear what you mean by tail recursive
15:31:55 <Badger> dcoutts is multicultural.
15:32:11 <Badger> or is that just a list of all lambdabot's channels?
15:32:13 <gwern> :( what a bad time for dcoutts to not be here
15:32:21 <gwern> Badger: latter I suspect
15:32:27 <gwern> note the pronoun
15:32:40 <Badger> yeah, I thought
15:32:53 <inv> vixey: i don't want stack overflow with it :)
15:34:20 <dons> hackage tag cloud: http://donsbot.wordpress.com/2009/01/24/what-is-haskell-good-for/
15:35:03 <ddarius> inv: p and pp3 together are not tail recursive
15:35:31 <inv> ow, ok, I thought about it :(
15:35:36 <inv> thx
15:35:47 <jeffz`> anyone know why cabal install fails with this cabalized example? http://jeffz.name/onex/ - seems simple enough that it should just work - I'm using 6.10.1 and cabal 1.6.0.1
15:37:13 <gwern> jeffz`: ah, the good ol' Control.Exception bug
15:37:22 <llayland> trying to make ghc:
15:37:24 <llayland> cabal-bin.exe: c:/temp/ghc-6.10.1/utils/hsc2hs/install-inplace/bin/hsc2hs: runGenProcess: invalid argument (Exec format error)
15:37:27 <gwern> it just isn't a real day in #haskell without someone running into it
15:37:28 <rwbarton> The real question is why is that paste in a 285-pixel wide region
15:38:07 <ik> perldoc perlop for haskell?
15:38:20 <gwern> jeffz`: you can either Control.Exception->Control.OldException, or depend on base3
15:38:34 <dons> haddock?
15:38:37 <dons> ik ^
15:39:14 <rwbarton> ik: hoogle
15:39:26 <jeffz`> gwern: hmm,  but it compiles fine with ghc --make, or cabal build, just cabal install fails.
15:39:50 * gwern shrugs. try it and see
15:40:05 <yitz> dons: nice. how about a few words on the blog about how you created that cloud?
15:40:33 <ik> dons: rwbarton: really I'm just looking for what $= means, but I'd like to know where the docs for that sort of thing is so I don't have to ask again.
15:40:46 <ik> dons: rwbarton: perldoc perlop is where I'd look for that sort of thing in perl, that's why I mentioned that
15:41:07 <rwbarton> ik: that operator is defined by a package (probably opengl or gtk2hs)
15:41:25 <yitz> @hoogle ($=)
15:41:25 <lambdabot> No results found
15:41:30 <ik> rwbarton: ah.  opengl in this case.  Thanks.
15:41:41 <yitz> @hoogle $=
15:41:42 <lambdabot> No results found
15:41:47 <rwbarton> ik: enter $= here: http://holumbus.fh-wedel.de/hayoo
15:43:00 <jeffz`> gwern: hmm, nothing.  if I shorten what "cabal install" does to ghc -hide-all-packages -package base-3.0.3.0 onex.hs, it also complains that Control.Exception does not export onException
15:43:07 <ik> rwbarton: oh.  It is uncooperative in w3m.
15:43:13 <ik> rwbarton: does it require javascript to function?
15:43:15 <rwbarton> indeed
15:43:18 <rwbarton> I think so.
15:43:18 <ik> pesky.
15:43:26 <gwern> interesting
15:43:29 <rwbarton> hoogle is more browser-friendly, but doesn't have as many packages I guess
15:43:35 <ik> Thanks for the link, though
15:43:48 <ik> It did just tell me where $= came from :)
15:45:41 <ddarius> p TSyms zs ~> pp3 [TSym,TSyms] zs 0 ~> case p TSym zs of ... ~> pp3 [TSyms] (tail zs) ... ~> case p TSyms (tail zs) of ... ~> case pp3 [TSym, TSyms] (tail zs) of ... ~> case (case p TSym (tail zs) of ...) of ... ~> case (pp3 [TSyms] (tail (tail zs)) ...) of ->
15:47:11 <ddarius> The crucial thing is: pp3 [TSyms] ... ~> case (pp3 [TSyms] ...) of ...
15:47:35 <ddarius> So you end up with cases nested 100000 deep.
15:49:48 <gwern> ok peeps filestore is now on hackage
15:50:33 <sbahra> cool
15:52:45 * loadquo thinks about doing a spline package 
15:52:57 <sjanssen> filestore, eh?  Interesting
15:53:26 <loadquo> And then implement a probability distribution function package using splines.
15:53:40 <gwern> oh right, I need to do the ANN don't I
15:53:43 * gwern feels sheepish
15:56:19 <gwern> there we go
16:00:19 <xci> hey guys - where can I check the sample implementations of Prelude-functions
16:00:29 <dons> in the Prelude.hs ?
16:00:43 <porges> http://darcs.haskell.org/packages/base/Prelude.hs
16:00:48 <dons> here's the hugs prelude, http://www.cse.unsw.edu.au/~dons/data/Prelude.html
16:01:19 <sjanssen> xci: see the Haskell report
16:01:21 <sjanssen> @where report
16:01:21 <lambdabot> http://www.haskell.org/onlinereport/
16:01:51 <gwern> dons: gitit and orchid and filestore are being released tonight
16:02:17 <gwern> (filestore's already out, and orchid & filestore will be whenever john and sebastiaan check their email)
16:02:54 <dons> wooo!
16:03:01 <dons> darcs-backed?
16:03:15 <cschneid> Can another language call into haskell?  Say I have a ruby web app, and I want to write some interesting algorithm in haskell, can I call directly (library level) rather than spawning a process?
16:03:29 <gwern> dons: no, they're just maintenance releases to add some -Wall clean up
16:03:43 <gwern> (yes, of course this is the darcs-backed gitit release :)
16:04:05 <porges> cschneid: yes, I'm not sure if there are direct Ruby bindings though
16:04:11 <gwern> also, gitit can toggle between RST and Markdown as its default mode, which should help out the darcs folk
16:04:16 <dons> ok. great. i'll pick them up when i get to them.
16:04:23 <dons> cschneid: yes, via the C ffi
16:04:49 <cschneid> dons: so haskell exposes functions externally that can be called from C (and hence almost anything)?
16:05:00 <gwern> indeed
16:05:11 <dons> yep.
16:05:23 <porges> cschneid: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
16:05:25 <dons> 'foreign export' is used to export haskell functions as C things you can call with a header.
16:05:39 <dons> exactly, porges
16:05:50 <dons> so if you can call C, you can call Haskell
16:05:54 <cschneid> sweet, I'll check this out :)
16:05:56 <dons> 3. profit?
16:06:03 <cschneid> no real use yet, but I'm sure I'll figure out 2. ???
16:06:37 <gwern> pandoc also now has 'plugins' but I haven't decided how cool they are yet
16:06:46 <sjanssen> cschneid: in this case, the "2. ???" is "Realize that Haskell is way better than Ruby, and rewrite your entire application in Haskell" :)
16:06:57 <porges> is ./validate the GHC test suite?
16:07:12 <cschneid> as much as I'd like that to be possible, haskell simply can't compete with something like sinatra for clarity of code for the web.
16:07:21 <cschneid> (oohhh, thems are fightin' words!)
16:07:23 <cschneid> :)
16:07:55 * gwern wonders idly what sinatra is
16:07:58 <sjanssen> hmm, I ought to take a look at gitit.  It might be the answer to my dreams of blogging directly in literate Haskell
16:07:59 <rwbarton> Someone will probably now go and figure out how to make sinatra code (whatever that is) compile as valid haskell. :)
16:08:12 <cschneid> http://sinatra.github.com/
16:08:13 <cschneid> :)
16:08:28 <cschneid> that'd be really sweet if a minimalist web interface like this would get built in haskell.
16:09:16 <gwern> sjanssen: gitit's not *quite* there yet - literate haskell gets displayed cool, but the non-code isn't yet interpreted as markdown or whatever - which is what oen really wants
16:09:31 <porges> is anyone familiar with building GHC
16:09:35 <gwern> it certainly is on the todo, and being able to do that is a prerequisite to the haddock wiki idea
16:09:37 <sjanssen> gwern: actually, I'd prefer a TeX-ish interpretation
16:09:44 <gwern> so I'm sure it'll get done soon
16:09:59 <sjanssen> I find Bird style very annoying, TeX style is much more convenient
16:10:15 <porges> just have bird2tex and tex2bird :P
16:10:58 * ksf groans
16:11:17 <ksf> I have to write callbacks in haskell that take varargs.
16:11:41 <gwern> don't we call those 'lists'?
16:11:50 <skorpan> :t _|_
16:11:52 <lambdabot> parse error on input `|'
16:11:54 <skorpan> aw darn it.
16:11:59 <skorpan> :t (_|_)
16:12:01 <lambdabot> parse error on input `|'
16:12:03 <skorpan> aw darn it.
16:12:07 <ksf> well, yes... they're passed as varargs and inside a struct.
16:12:30 <porges> _ is a special character, so you can't even define (_|_) = undefined
16:12:30 <ksf> including a format string that can name args and stuff.
16:13:02 <rwbarton> :t let _I_ = undefined in _I_
16:13:03 <lambdabot> forall a. a
16:13:49 <ddarius> porges: _ is simply not a character that can lead an identifier, same as 1 or '.
16:14:09 <ksf> ...but what I'm really procrastinating is detecting whether or not a haskell value I return gets gc'ed, so I can unregister the event handler it represents.
16:14:15 <gwern> (ok, orchid/orchid-demo/salvia're now on hackage as well)
16:14:17 <rwbarton> it can't?  Is what I wrote above a GHC extension?
16:14:38 * loadquo has been thinking about the head on [] problem
16:14:40 <gwern> '  # die if we need to
16:14:42 <gwern>   if ($this->fallover)
16:14:42 <gwern>     { die "Khaaaaaaaaaaaaan!" }
16:15:00 <binrapt> What? PHP in #haskell?
16:15:04 <ddarius> rwbarton: Oh wait, I'm just wrong.  There's nothing special about it's use in identifiers except that it alone is reserved just like 'case'
16:15:07 <binrapt> Or is that Perl too?
16:15:16 <idnar> looks like perl
16:15:55 <ddarius> You can't define _|_ because _ isn't an -operator- character (and | is)
16:16:52 <yitz> ddarius: so why did what rwbarton write work?
16:17:04 <ddarius> yitz: 'I' is not an operator character.
16:17:12 <rwbarton> and _ is a letter
16:17:19 <yitz> ok
16:17:32 <loadquo> Might it be possible to define the domain of a function, and throw a compile time error if the function variable is not checked to be of the right domain before being passed, or the function has a domain such that it will not call the function with a value outside?
16:17:50 <ddarius> :t let _1_ = undefined in _1_
16:17:52 <lambdabot> forall a. a
16:18:10 <rwbarton> In fact, _ is a lowercase letter :)
16:18:11 <ddarius> loadquo: Yes, it is called giving it a type.
16:18:21 <Heffalump> loadquo: not without defining the domain as a type, or using some tool like ESC/Haskell (which I don't know if it's released yet or not)
16:18:26 <gwern> loadquo: head [] is too addictive a pleasure to give up for most haskellers. might as well make haskell total while we're at it
16:18:35 <gwern> Heffalump: don't think so; I've never heard of it
16:19:21 <kmeyer> > head []
16:19:23 <lambdabot>   * Exception: Prelude.head: empty list
16:19:38 <loadquo> e.g. head :: [a] -> a where [a] /= [] or somesuch
16:20:13 <gwern> we do have a safe library where head is defined something like 'head :: a -> [a] -> a'
16:20:31 <idnar> @type listToMaybe
16:20:32 <lambdabot> forall a. [a] -> Maybe a
16:20:49 <idnar> @type maybe
16:20:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:20:55 <idnar> @type fromMaybe
16:20:56 <lambdabot> forall a. a -> Maybe a -> a
16:21:22 <idnar> @pl \xs d -> fromMaybe d (listToMaybe xs)
16:21:22 <lambdabot> flip fromMaybe . listToMaybe
16:21:33 <idnar> @pl \d xs -> fromMaybe d (listToMaybe xs)
16:21:33 <lambdabot> (. listToMaybe) . fromMaybe
16:21:39 <idnar> @type \d xs -> fromMaybe d (listToMaybe xs)
16:21:40 <lambdabot> forall a. a -> [a] -> a
16:22:01 <loadquo> Defining a whole new type seems excessive. I was hoping to use it for mathematical functions where the domain is not defined as well.
16:22:18 <tromp__> any1 here use an eReader?
16:22:28 <ddarius> So can I be considered a troll on Haskell-Cafe?
16:22:49 <pao> > fromMayber 3 Nothing
16:22:50 <lambdabot>   Not in scope: `fromMayber'
16:23:00 <pao> > fromMaybe 3 Nothing
16:23:01 <lambdabot>   3
16:23:15 <pao> > fromMaybe 3 Just 1
16:23:16 <lambdabot>   Couldn't match expected type `Maybe t'
16:23:35 <pao> > fromMaybe 3 $ Just 1
16:23:36 <lambdabot>   1
16:24:40 <gwern> ddarius: you are not nearly loquacious enough to be a good troll
16:25:50 <loadquo> > sqrt (-1)
16:25:51 <lambdabot>   NaN
16:25:53 <ddarius> gwern: I admit, my original comment that has spawned a 33 post long thread (and growing) was not loquacious at all.
16:26:37 <gwern> ddarius: well, I'll admit that was darn impressive
16:26:58 <gwern> I think I've managed similar feats... two or three times. but certainly not often at all
16:27:23 <gwern> (time will tell whether my latest one succeeds in gettign a WP admin de-sysopped, though)
16:27:36 <alex23> hi
16:29:29 <alex23> i get an error: "Instances of (Floating Int, RealFrac Int) required for definition of isindsideCirc" when i compare a sqrt with an Int, how to do this without errors?
16:29:42 <ddarius> @quote fromIntegral
16:29:42 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
16:29:45 <ddarius> @quote fromIntegral
16:29:46 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
16:30:04 <CakeProphet> is there anyway on lambdabot to compute an arrow?
16:30:07 <CakeProphet> :t app
16:30:09 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
16:31:10 <ddarius> "Haskell: Good for Pugs"
16:31:37 <dons> heh
16:31:53 <loadquo> Ddarius: I was happy to learn that. Now I just need to know what pugs are.
16:32:00 <dons> small dogs.
16:32:01 <ddarius> @wn pug
16:32:05 <gwern> 'haskell: because pugs need hugs'
16:32:09 <skorpan> :t fromIntegral
16:32:11 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:32:12 <lambdabot> *** "pug" wn "WordNet (r) 2.0"
16:32:12 <lambdabot> pug
16:32:12 <lambdabot>      n : small compact smooth-coated breed of Asiatic origin having a
16:32:12 <lambdabot>          tightly curled tail and broad flat wrinkled muzzle [syn:
16:32:13 <lambdabot>          {pug-dog}]
16:32:15 <lambdabot>      [also: {pugging}, {pugged}]
16:32:16 <dons> gofers too
16:34:53 <byorgey> CakeProphet: sure.  what exactly do you mean, 'compute an arrow'?
16:35:08 <alex23> @ddarius: where to put the fromIntegral ?
16:35:08 <lambdabot> Unknown command, try @list
16:35:26 <CakeProphet> ...well.. it's all fine and dandy to construct arrows from smaller arrows, but what if I want the result of their computation in a somewhat tangible form. (I guess this applies to regular programs too, not just lambdabot)
16:35:34 <byorgey> alex23: sqrt returns a floating-point number, so you'll have to convert the Int before comparing.
16:35:47 <byorgey> e.g.  sqrt blah < fromIntegral n
16:35:49 <CakeProphet> with monads, you usually end up in IO at some point... to output the fruits of your computation
16:35:53 <CakeProphet> what about arrows?
16:35:58 <alex23> oki thx
16:36:09 <porges> wishlist: GHC builds faster
16:36:13 <Heffalump> CakeProphet: well, there's an IO arrow (using Kleisli)
16:36:16 <byorgey> CakeProphet: well, each particular type of arrow may have a corresponding 'run' function
16:36:25 <Heffalump> and any other kind of arrow will have a run function as byorgey says
16:36:34 <Heffalump> most monads aren't IO and also have a run function
16:36:38 <CakeProphet> byorgey:  hmmm... what about (->) a?
16:36:46 <gwern> 'ANN: gitit 0.5' :)
16:36:46 <Heffalump> CakeProphet: just apply it to a value!
16:36:47 <byorgey> CakeProphet: those are their own run function =)
16:36:52 <CakeProphet> ...oh.
16:36:54 <CakeProphet> ha
16:37:04 <CakeProphet> (->) a /is/ an arrow.
16:37:10 * CakeProphet is silly.
16:37:14 <Heffalump> actually (->) is an arrow
16:37:17 <CakeProphet> ah
16:37:25 <Heffalump> and not a very useful one
16:37:31 <byorgey> sure it is!
16:37:32 <idnar> (->) a is a monad
16:37:33 <CakeProphet> so then instance Arrow (->) where arr = id  ?
16:37:41 <Heffalump> I can't actually visualise the type of the Reader arrow off the top of my head.
16:37:41 <byorgey> I use the (->) arrow all the time.
16:37:56 <Heffalump> byorgey: with proc notation and all?
16:37:57 <byorgey> CakeProphet: right.
16:38:04 <erikc> join #objc
16:38:06 <erikc> oops
16:38:13 <porges> blasphemer!
16:38:13 <byorgey> Heffalump: no, not with proc notation.  just with (***) and (&&&) and such
16:38:17 <Heffalump> erikc: don't do that, you have no idea what you might catch
16:38:18 <CakeProphet> and then >>> = (.) ?
16:38:21 <erikc> :)
16:38:22 <Heffalump> byorgey: ah, yes, me too
16:38:25 <byorgey> Heffalump: I use >>> sometimes too
16:38:28 <porges> <<< = (.)
16:38:32 <erikc> it was empty anyway
16:38:36 <CakeProphet> ah
16:38:39 <Heffalump> best thing for it
16:38:44 <CakeProphet> >>> = flip (.) ?
16:38:49 <byorgey> CakeProphet: right.
16:38:49 <porges> CakeProphet: yes
16:38:57 <alex23> when i compare sqrt (x**2 + y**2) <= fromIntegral (Int1+Int2) I got Instance of Floating Int required for definition of isin....
16:39:04 <CakeProphet> ah... there was someone wanting a flip (.) earlier... I should have told them about >>>   :P
16:39:09 <porges> haskell's really running out of characters
16:39:21 <Heffalump> not at all, Unicode support is getting better all the time
16:39:22 <porges> soon we'll have >>>>
16:39:33 <CakeProphet> for Squares
16:39:36 <CakeProphet> an abstraction of Arrows.
16:39:38 <porges> Heffalump: none of the libraries use them :P
16:39:51 <byorgey> alex23: what types are x and y?
16:39:54 <porges> Heffalump: I'm just writing a patch to add some things for -< -<< etc
16:40:07 <stepcut> CakeProphet: Spears are the absraction of Arrows -- shapr has been working on them for years now
16:40:12 <CakeProphet> yeah... Unicode support for my keyboard is lacking Heffalump.
16:40:21 <CakeProphet> stepcut:  ...
16:40:23 <Heffalump> there's a Heffalump character in unicode?
16:40:25 <CakeProphet> will it ever end?
16:40:26 <ddarius> CakeProphet: You don't "end up in IO at some point" "with monads", you end up in IO at some point because main :: IO ().
16:40:39 <ddarius> (or forall a. IO a technically)
16:40:53 <alex23> x and y are Int
16:41:43 <byorgey> alex23: ah, there's the problem.
16:41:46 <byorgey> @type (**)
16:41:48 <lambdabot> forall a. (Floating a) => a -> a -> a
16:41:53 <CakeProphet> byorgey:  so then explain (&&&) and (***) for (->) a ... I have a hard time understand them.
16:42:05 <porges> @src (&&&)
16:42:05 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
16:42:10 <byorgey> alex23: try  sqrt (fromIntegral (x^2 + y^2))
16:42:14 <porges> @src (***)
16:42:14 <lambdabot> f *** g = first f >>> second g
16:42:26 <alex23> thx
16:42:28 <alex23> i ll try
16:42:45 <byorgey> CakeProphet: well, *** is the 'parallel composition' of two arrows
16:42:55 <porges> (f *** g) x y = (f x, g y) ; (f &&& g) x = (f x, g x)
16:42:56 <CakeProphet> hmmm
16:43:03 <porges> err first should be (x,y)
16:43:03 <byorgey> i.e. it takes an arrow from  a to b  and an arrow from  c to d  and makes an arrow from (a,c) to (b,d)
16:43:12 <CakeProphet> ah okay... applying an argument to (f *** g) will compute both...
16:43:15 <porges> (f *** g) (x, y) = (f x, g y) ; (f &&& g) x = (f x, g x)
16:43:17 <CakeProphet> hey, I was actually thinking about making a function for that.
16:43:17 <byorgey> CakeProphet: does that make sense?  if I could draw a picture it would help
16:43:32 <CakeProphet> nah I've got it.
16:43:36 <byorgey> > ((+1) *** (*3))  (4,9)
16:43:38 <lambdabot>   (5,27)
16:44:08 <byorgey> CakeProphet: now, &&& is the same, except it duplicates its input and gives it to both arrows, instead of taking a pair of inputs
16:44:11 <ddarius> @where hpaste2
16:44:12 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
16:44:12 <Nafai> byorgey: http://gist.github.com/51615 <- profiling results
16:44:13 <skorpan> :t (>>>)
16:44:14 <crutcher> can someone give me a rough description of what an arrow is?
16:44:14 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:44:20 <skorpan> umm...
16:44:21 <Nafai> byorgey: Not sure that it is very useful
16:44:32 <CakeProphet> > let divMod' = (div &&& mod) in divMod' 10 5
16:44:33 <lambdabot>   Couldn't match expected type `t1 -> t'
16:44:34 <byorgey> > ((+1) &&& (*3)) 4
16:44:35 <lambdabot>   (5,12)
16:44:36 <CakeProphet> hmmm...
16:44:42 <loadquo> crutcher: A branch-able monad?
16:44:52 <byorgey> so in that example, the 4 gets passed to both the (+1) and the (*3)
16:44:55 <CakeProphet> how would I implement divMod with arrows?
16:45:07 <CakeProphet> ...or would I even want to?
16:45:15 <porges> [| |] ==> ‚ü¶ ‚üß ; (| |) ==> ‚¶á ‚¶à ; {| |} ==> ‚¶É ‚¶Ñ
16:45:16 <Heffalump> I was about to ask why you'd want to :-)
16:45:28 <CakeProphet> &&& just reminded me of divMod
16:45:36 <CakeProphet> since it returns a tuple of the result of two different functions
16:45:55 <byorgey> crutcher: an arrow is a model of a computation which takes an input of one type and yields an output of some other type.
16:46:06 <byorgey> crutcher: you can think of arrows as a generalization of functions.
16:46:18 <crutcher> in what ways are they different?
16:46:48 <crutcher> Is it true that all haskell functions are Arrows?
16:47:02 <byorgey> in general, an arrow might have other things going on than just computing output from input (state, some sort of private read-only lookup table, possibility of failure...)
16:47:20 <porges> CakeProphet: divMod = curry (div *** mod)
16:47:23 <byorgey> crutcher: yes, (->)  (the function type constructor) is an instance of Arrow.
16:47:38 <CakeProphet> @src curry
16:47:39 <lambdabot> curry f x y = f (x, y)
16:47:50 <CakeProphet> oh... awesome.
16:47:58 <porges> or uncurry
16:47:59 <idnar> @src uncurry
16:47:59 <lambdabot> uncurry f p = f (fst p) (snd p)
16:48:00 <CakeProphet> porges:  er... wait. wouldn't that produce two functions.
16:48:00 <porges> oops :P
16:48:01 <byorgey> crutcher: http://haskell.org/arrows/ is a nice introduction, with helpful pictures
16:48:17 <crutcher> thanks, I'll go look.
16:48:50 <alex23> arg the same error i pasted the code here: http://www.pastey.net/106955
16:48:51 <CakeProphet> byorgey:  it helps I guess, but it doesn't explain how the whole ordeal is more useful than the functional equivalents.
16:49:28 <porges> CakeProphet: err, i stuffed that up
16:49:30 <porges> :D
16:49:36 <dons> so we finally have a darcs-backed serious wiki, on happs.
16:49:39 <dons> perfect storm!!
16:49:46 <CakeProphet> porges:  yeah, anything produced with the arrow operators seems to only want one argument.
16:49:54 <Nafai> dons: Cool!
16:50:04 <dons> http://www.reddit.com/r/haskell/comments/7s7dq/gitit_05_now_supports_darcs_smarter_search/
16:50:06 <Nafai> byorgey: So yeah, profiling didn't really help :(
16:50:07 <dons> yay for gitit
16:50:27 <byorgey> CakeProphet: because once you've made all these different models of computation instances of the same type class, you can make generic combinators, prove things about all of them at once, and so on
16:50:46 <snookerb> hey folks
16:50:49 <snookerb> short question
16:51:01 <snookerb> is there a function, which replaces a certain item in a list
16:51:19 <snookerb> certain = specified by index
16:51:28 <ddarius> Subtitles I've given Haskell throughout the years: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=918#a918
16:51:48 <CakeProphet> > curry (uncurry div &&& uncurry div) 10 5
16:51:48 <snookerb> ["a","b","c"]
16:51:50 <lambdabot>   (2,2)
16:51:51 <ddarius> My favorite has to be: "Haskell: Turning Features Into Bugs Since 1989"
16:51:55 <byorgey> snookerb: not in the standard libraries, but you could write one
16:51:56 <CakeProphet> > curry (uncurry div &&& uncurry div) 100 6
16:51:57 <lambdabot>   (16,16)
16:51:58 <snookerb> is my list
16:51:58 <porges> CakeProphet: should have been curry (uncurry div &&& uncurry mod)
16:52:01 <CakeProphet> hmmm
16:52:04 <byorgey> snookerb: you'll probably want to use splitAt
16:52:05 <CakeProphet> > curry (uncurry div &&& uncurry mod) 100 6
16:52:06 <CakeProphet> right
16:52:07 <lambdabot>   (16,4)
16:52:11 <CakeProphet> sweet.
16:52:13 <snookerb> and i want to replace the second item with a new value
16:52:22 <snookerb> ok, splitAt is the way to go?
16:52:25 <CakeProphet> the POWER of arrows to implement divMod.
16:52:30 <snookerb> no predefinde function?
16:52:34 <byorgey> > splitAt 1 ["a","b","c"]
16:52:36 <lambdabot>   (["a"],["b","c"])
16:52:39 <porges> CakeProphet: arrows work better on unucrried functions :)
16:53:03 <byorgey> snookerb: nope, nothing predefined.  once you've done splitAt all you have to do is replace the head of the second list and patch things back up.
16:53:22 <snookerb> yeah, you're right
16:53:30 <byorgey> Nafai: sorry, I don't think I can be of much more help =(
16:53:30 <snookerb> is almost predefined ^^^
16:53:33 <snookerb> thanks very much
16:53:36 <byorgey> sure
16:53:42 <snookerb> !
16:53:46 <Nafai> byorgey: Okay :(
16:53:48 <koninkje> Are there any Cabal/CPP gurus in the house?
16:54:04 <dons> always.
16:54:24 <Nafai> byorgey: Thanks for the help you were able to give me.
16:54:29 <dobblego> @src Arrow
16:54:29 <lambdabot> class Arrow a where
16:54:29 <lambdabot>     arr, pure   :: (b -> c) -> a b c
16:54:29 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
16:54:29 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
16:54:29 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
16:54:31 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
16:54:35 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
16:54:41 <dobblego> oops sorry
16:54:44 <porges> @let replaceAt n xs item = let (y,ys) = splitAt n xs in y ++ (item : tail ys)
16:54:45 <lambdabot>  Defined.
16:54:59 <porges> replaceAt 1 ["a","b","c"] "d"
16:55:03 <porges> > replaceAt 1 ["a","b","c"] "d"
16:55:04 <lambdabot>   ["a","d","c"]
16:55:14 <CakeProphet> :t <:>
16:55:16 <lambdabot> parse error on input `<:>'
16:55:21 <CakeProphet> :t (<:>)
16:55:22 <RayNbow> @check \x y -> y == 0 || curry (uncurry div &&& uncurry mod) x y == divMod x y
16:55:22 <lambdabot> Not in scope: `<:>'
16:55:24 <lambdabot>   "OK, passed 500 tests."
16:55:42 <RayNbow> @hoogle divMod
16:55:44 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
16:55:45 <asgaroth> @let divMod' m = (flip div m &&& flip mod m)
16:55:46 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
16:55:48 <lambdabot>  Defined.
16:55:50 <porges> @check \x y -> y /= 0 ==> curry (uncurry div &&& uncurry mod) x y == divMod x y
16:55:51 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
16:55:52 <lambdabot>           ...
16:55:52 <CakeProphet> hmmm.. could probably make a new arrow operator that automatically curries and uncurries.
16:55:56 <byorgey> @type curry (uncurry div &&& uncurry mod)
16:55:57 <Nafai> dons: Do you have time to help me track down a stack space overflow error?
16:55:57 <asgaroth> > divMod' 6 100
16:55:58 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
16:55:59 <lambdabot>       Ambiguous occurrence `divMod''
16:55:59 <lambdabot>      It could refer to either `L.divMod'...
16:56:11 <asgaroth> @undefine divMod'
16:56:18 <dons> Nafai: sadly, not atm. though if you ask in here, there's lots of experts. (and on -cafe)
16:56:22 <asgaroth> @let divMod'' m = (flip div m &&& flip mod m)
16:56:23 <lambdabot>  Defined.
16:56:27 <asgaroth> > divMod'' 6 100
16:56:29 <lambdabot>   (16,4)
16:56:52 <koninkje> dons: So I've been working on that patch for ghc-core, and I'm not sure how best to maintain forward- and backward-compatibility. Namely the HsColour package 1.10.* vs 1.11.* issues. I'm trying to use CPP to allow both versions but the MIN_VERSION_hscolour(A,B,C) stuff is only in Cabal >=1.6 so I'm not sure how best to CPP away the problems
16:56:54 <dons> gwern++ getting gitit and orchid to be friends.
16:57:07 <dons> koninkje: just depend on the newest hscolour, imo
16:57:12 <Nafai> dons: K, thanks.
16:57:22 <Nafai> I might post to -cafe
16:57:52 <koninkje> dons: as you wish
16:57:59 <CakeProphet> > let pack f (*) g = curry (uncurry f * uncurry g); divMod' = pack div (&&&) mod in divMod' 100 6
16:58:01 <lambdabot>   (16,4)
16:58:29 <CakeProphet> ...poor verb choice for the function name, but whatever.
16:58:36 <Nafai> Just not sure I'm ready for the deluge that -cafe will be :)
17:00:03 <bohdan> @pl \a = -a
17:00:04 <lambdabot> (line 1, column 4):
17:00:04 <lambdabot> unexpected "="
17:00:04 <lambdabot> expecting operator, pattern or "->"
17:00:14 <bohdan> @pl \a -> -a
17:00:14 <lambdabot> (line 1, column 7):
17:00:14 <lambdabot> unexpected "-"
17:00:14 <lambdabot> expecting lambda abstraction or expression
17:00:35 <asgaroth> bohdan: negate
17:00:36 <byorgey> @pl \a -> (-a)
17:00:37 <lambdabot> negate
17:00:54 <ddarius> :t \a -> -a
17:00:55 <byorgey> unary minus syntax is dumb.
17:00:55 <lambdabot> forall a. (Num a) => a -> a
17:01:01 <ddarius>  @pl is dumb
17:01:04 <bohdan> what's wrong with "@pl \a -> -a" ?
17:01:05 <byorgey> that too.
17:01:12 <ddarius> bohdan: Nothing.
17:01:30 <ddarius> bohdan: Oh, @pl is what is wrong.
17:01:40 <bohdan> ok I see :)
17:01:44 <CakeProphet> hmmm...
17:01:47 <byorgey> apparently @pl uses a borked parser.
17:01:56 <CakeProphet> so what's the benefit of Data.Stream. All the functions look the same.
17:02:12 <ddarius> byorgey: @pl uses a seriously broken parser in many regards
17:02:25 <gwern> 'In actual fact, to write a good Haskell program is to create a work of art. As such, any Haskell program worth writing must be beautiful. In fact, rumour has it that the GHC optimiser analyses programs it is asked to compile and, if it finds it aesthetically pleasing, will work harder to make your program run faster. '
17:02:26 <ddarius> CakeProphet: The implementation of the functions.
17:02:39 <nothingmuch> CakeProphet: the same as what?
17:02:47 <CakeProphet> as [] functions
17:02:49 <int-e> CakeProphet: it's a reimplementation of Data.List with improved fusion rules.
17:02:49 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
17:02:49 * Nafai takes the plunge and subscribes to -cafe
17:02:54 <nothingmuch> Stream is a typeclass
17:02:58 <nothingmuch> :i []
17:03:03 * RayNbow wonders which book he should get (since I got about 40 USD to burn...)
17:03:03 <nothingmuch> no worky in lambdabot?
17:03:05 <CakeProphet> data Stream a = Cons a (Stream a)
17:03:09 <int-e> lambdabot: I saw that one already :(
17:03:10 <CakeProphet> nothingmuch:  not this one
17:03:11 <thoughtpolice> int-e: I think he's talking about the Stream package
17:03:14 <thoughtpolice> int-e: not stream fusion
17:03:27 <byorgey> CakeProphet: Streams are infinite.
17:03:31 <gwern> dons: it'd be interesting if you actually notice the optimizations in gitit. maybe before you install 0.5 you could do some timings of your old gitit
17:03:36 <byorgey> they're like lists with no nil case.
17:03:41 <CakeProphet> byorgey:  ...right. but what do they do that lists don't.
17:03:50 <thoughtpolice> gwern: how much more performant? :)
17:03:51 <byorgey> CakeProphet: they are safer.
17:03:59 <CakeProphet> ah. it's what they can't do that makes them good.
17:04:04 <byorgey> CakeProphet: e.g. calling 'head' on a Stream is always safe.
17:04:08 <byorgey> CakeProphet: right. =)
17:04:15 <int-e> thoughtpolice: oh never mind.
17:04:29 <gwern> thoughtpolice: well, my tests show loadtime is roughly 1/3
17:04:31 <ddarius> Ah, Data.Stream is something different than what I thought.
17:05:01 <CakeProphet> hmmm...
17:05:08 <int-e> thoughtpolice: In my defense, the stream-fusion package has a Data.Stream module as well.
17:05:12 <CakeProphet> next step: understanding Reader/Writer.
17:05:31 <gwern> thoughtpolice: but it's hard to tell, because I know loadtime is down to 1/3 or 1/4 once the caching kicks in, but it's the first load that would be slow and that's so hard to measure
17:05:35 <agemo> hi, anyone feel like helping me struggle with cabal?
17:05:46 <agemo> I've got this thing that imports Data.Generics
17:05:56 <gwern> depend on syb!
17:06:04 <agemo> this means that base has to be included
17:06:21 <agemo> i've got base-3.0.3.0 installed
17:06:23 * gwern waits with bated breath to see whether I got it right. 2 statements means a high score
17:06:24 <thoughtpolice> int-e: hehe :)
17:06:46 <agemo> and build-depends in cabal file includes base>3
17:06:55 <thoughtpolice> agemo: what GHC are you using?
17:07:02 <gwern> (go in the basket, c'mon go in the basket...)
17:07:03 <agemo> and yet, cabal build gives me the error that base-3.0.3.0 is hidden
17:07:22 <agemo> The Glorious Glasgow Haskell Compilation System, version 6.10.1
17:07:24 <agemo> that one :)
17:07:32 <thoughtpolice> agemo: ghc 6.10.1 comes with 2 versions of base
17:07:46 <koninkje> dons: the patch is on its way
17:07:46 <thoughtpolice> there were incompatible changes made in base-4.0, so base-3.0.3.0 is there for compatibility
17:08:05 <agemo> oh
17:08:07 <agemo> that helps :)
17:08:07 <thoughtpolice> agemo: in these changes, Data.Generics was split out into a separate 'syb' package ( that should be installed by default)
17:08:21 <Nafai> Yay, I'm now on -cafe and -beginners.
17:08:24 <thoughtpolice> agemo: so do what gwern recommended - try putting a dependency on syb along with base > 3
17:08:32 <thoughtpolice> agemo: and that should work
17:08:39 <agemo> let's try :)
17:08:49 * gwern chafes at the delay!
17:09:17 <CakeProphet> :T do {x <- local (.(+3)) (+4); return x}
17:09:21 <CakeProphet> :t do {x <- local (.(+3)) (+4); return x}
17:09:22 <lambdabot> forall c a. (Num a, Num (a -> c)) => (a -> c) -> a -> c
17:09:29 <CakeProphet> eh
17:09:31 <dons> koninkje: yay!
17:09:53 <dons> koninkje == wren!
17:10:00 <gwern> wren?
17:10:06 <dons> mystery nicks.
17:10:10 <gwern> knonikje is a bird?
17:10:16 <CakeProphet> :t  do {x <- local id  (+4); return x}
17:10:18 <lambdabot> forall a. (Num a) => a -> a
17:10:22 <CakeProphet> :t  do {x <- local id  (+4); return x} 5
17:10:22 <koninkje> winterkoninkje :: Dutch == wren :: English
17:10:24 <lambdabot> parse error on input `5'
17:10:24 <agemo> compiles! thanks people :)
17:10:32 <CakeProphet> :t  (do {x <- local id  (+4); return x}) 5
17:10:33 <lambdabot> forall a. (Num a) => a
17:10:36 <CakeProphet> >  (do {x <- local id  (+4); return x}) 5
17:10:37 <dons> koninkje: you're in pdx now?
17:10:38 <lambdabot>   9
17:10:41 <CakeProphet> heh.
17:10:57 <CakeProphet> MonadReader compose.
17:11:03 <koninkje> dons: alas, no. I moved to the east coast about a year back
17:11:04 <CakeProphet> er
17:11:06 <CakeProphet> $
17:11:06 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
17:11:09 <dons> ah
17:11:19 <koninkje> My irc is still there though ;)
17:11:20 <dons> i was thinking it was surprising that we havent met (?)
17:11:51 <koninkje> Indeed. I'd meant to go to POPL last year but it didn't work out
17:12:03 <CakeProphet> :t (.(+4))
17:12:04 <lambdabot> forall c a. (Num a) => (a -> c) -> a -> c
17:12:10 <koninkje> I went to school with Trevor Elliott (I assume he's still at Galois?)
17:12:49 <dons> oh, yes.
17:12:55 <dons> i sit next to him. elliottt
17:13:01 <dons> small world.
17:13:10 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-core-0.4.2
17:13:19 <dobblego> @instances Arrow
17:13:20 <lambdabot> (->), Kleisli m
17:13:22 <koninkje> I remember when he got that job, I hadn't heard of Galois at the time :)
17:13:30 <dons> heh
17:13:46 <dons> we had a bit of a more secretive culture in the past, imo.
17:13:57 <dons> crypto does that to you, i think.
17:14:00 <dobblego> newtype Kleisli m a b = Kleisli (a -> m b) -- ?
17:14:02 * koninkje nods
17:14:06 <dons> but that's changing very rapidly now
17:15:08 <koninkje> If I don't end up going to Edinburgh, I may end up at Simon Fraser which is close enough to stop by PDX from time to time
17:15:20 <ddarius> dobblego: Yes.
17:16:04 <dobblego> ddarius, thanks
17:16:20 <ddarius> If there was a standard library for Comonads we'd also have newtype CoKleisli w a b = CoKleisli (w a -> b)
17:16:22 <CakeProphet> aaah... I see what reader does.
17:17:34 <CakeProphet> basically you can decouple the code that works on the environment from the actual environment without using a new function parameter
17:17:37 <CakeProphet> because of ask
17:17:43 <CakeProphet> (and asks)
17:18:00 <ddarius> newtype Comma f g a b = Comma (f a -> g b) might also be useful and then type DiAlgebra f g a = Comma f g a a
17:20:34 <hackage> Uploaded to hackage: ghc-core 0.4.2
17:20:34 <hackage> Uploaded to hackage: gitit 0.5
17:20:34 <hackage> Uploaded to hackage: orchid-demo 0.0.5
17:20:35 <hackage> Uploaded to hackage: orchid 0.0.7
17:20:37 <hackage> Uploaded to hackage: salvia 0.0.5
17:20:39 <ddarius> The Reader monad is not very compelling by itself.
17:20:40 <redditbot> Fast incremental regular expression matching with monoids
17:20:40 <redditbot> A cross platform P2P VPN application in Haskell
17:20:40 <redditbot> darcs weekly news #14
17:20:41 <redditbot> gitit 0.5: now supports darcs, smarter search
17:20:43 <redditbot> HDBC now has a mysql backend!
17:20:48 <ddarius> Attack of the bots!
17:21:21 <gwern> bah, it didn't get filestore? how does it get ghc-core & gitit but not filestore...
17:21:34 <bohdan> @pl \x g a -> g (f a)
17:21:35 <lambdabot> const (. f)
17:22:16 <dons> it takes the last 5 this hour
17:22:23 <dons> if you release more than 5 in an hour, it drops the early ones
17:22:41 <porges> if I only downloaded ghc-HEAD-X-X-X-ghc.tar.bz2 is there a quick way to pull in the corelibs & testsuite?
17:23:29 <thoughtpolice> that will come with all the corelibs
17:23:46 <thoughtpolice> there should be another version of that exact same file but with '-testsuite' on the end though
17:23:48 <thoughtpolice> which has it too
17:23:57 <porges> yeah, but can I pull it in with darcs or something
17:24:11 <thoughtpolice> otherwise you can do 'darcs get http://darcs.haskell.org/testsuite'
17:24:25 <porges> cool
17:26:22 <gwern> (wow, proggit doesn't like filestore)
17:27:24 <Heffalump> so how do orchid and gitit compare?
17:27:31 <ksf> segfaults by pointer arithmetic.
17:27:40 <ksf> I've never had them until I learned haskell.
17:27:46 <dons> i've only used gitit.
17:27:54 <dons> it compares well with mediawiki, imo.
17:28:10 <dons> on a smaller scale, of course.
17:28:16 <dons> the happs single binary model is useful here
17:28:25 <gwern> Heffalump: how do they compare? well, I like gitit better
17:28:31 <gwern> just to make that clear :)
17:28:37 <bohdan> @pl \x g a -> g (f a x)
17:28:38 <lambdabot> flip (.) . flip f
17:28:56 * gwern has a low opinion of orchid reinventing the (pan)doc wheel
17:29:02 <bohdan> @pl \x g -> g . flip (f x)
17:29:02 <lambdabot> flip (.) . flip . f
17:29:12 <sm> orchid has more ajaxy polish.. and a new sucky markup, yes
17:29:19 <gwern> also, the interface while interesting and web 2.0y is less familiar to me than the cool blue mediawiki stylings of gitit
17:29:26 <sm> and it's own new appserver
17:29:28 <dons> :)
17:29:34 <gwern> but I'll admit that's a pretty superificial reason to like gitit better
17:29:36 <kmeyer> someone have an example gitit wiki up somewhere?
17:29:43 <thoughtpolice> http://lhc.seize.it
17:29:48 <thoughtpolice> we're using it for the lhc site
17:29:49 <gwern> kmeyer: yes, it's linked in the ANN
17:29:52 <bohdan> @pl \x g ->
17:29:53 <lambdabot> (line 1, column 8):
17:29:53 <lambdabot> unexpected end of input
17:29:53 <lambdabot> expecting lambda abstraction or expression
17:29:56 <sm> http://gitit.joyful.com is another
17:29:57 <thoughtpolice> i don't think that lemmih has upgraded though
17:29:58 <gwern> thoughtpolice: sure, but that's no 0.5 I'll bet
17:29:59 <dons> i run gitit locally for all my note,draft,document prep, and task tracking
17:30:01 <idnar> is web 2.0y the version after web 2.0x?
17:30:03 <kmeyer> thanks
17:30:06 <bohdan> @pl \x g -> g (\a -> f a x)
17:30:07 <lambdabot> flip id . flip f
17:30:11 <gwern> @tell Lemmih btw, you can now upgrade your gitit
17:30:12 <lambdabot> Consider it noted.
17:30:13 <thoughtpolice> gwern: no, it's still like 0.3.2
17:30:15 <sm> (without the cool blue media wikistylings :)
17:30:45 <gwern> :( it's just so rare I can use the word 'stylings' IS THAT SO WRONG
17:31:20 <dobblego> does the instance Arrow (Kleisli m) require (Monad m) => ?
17:31:40 <Heffalump> dobblego: how could it not?
17:31:43 <ddarius> dobblego: It should.
17:31:52 <thoughtpolice> dons: re. using cryptol's haskell backend to populate libraries, I think that would be super good. I've been thinking of using coq to write some stuff up, extract a bit of haskell code and clean it up for hackage.
17:31:52 <dobblego> thanks
17:31:59 <dons> mmm
17:31:59 <kiris> preflex: be poppavic
17:32:00 <preflex>  if I get the chance to shit on yer nose, will you tolerate the procedure or react? Wwhen do you react? why? whose "timeslice"?
17:32:23 <Gracenotes> dobblego: grep yields instance Monad m => Arrow (Kleisli m) where...
17:32:38 <pumpkin> yo yo!
17:32:56 <sm> dons: oh, also orchid/salvia doesn't build cleanly, seems less actively maintained
17:33:03 <sm> hopefully that will improve
17:33:19 <dolio> @palomer
17:33:20 <lambdabot> Scalliwags!
17:33:21 <dons> builds cleanly here.
17:33:22 <sm> on the other hand, you don't have to learn git to contribute
17:33:25 <dons> just made packages for it.
17:33:26 <gwern> sm: orchid/salvia is just one guy. gitit on the other hand is 2 guys :)
17:33:29 <sm> oh, yay
17:33:29 <dons> hehe
17:33:46 <gwern> why, that's a 100% improvement
17:33:47 <dons> gitit didn't, fwiw (due to package versioning issues of my own making)
17:35:26 <dons> filestore getting good attention on reddit, btw.
17:35:30 <dons> good work
17:36:20 <gwern> dons: 15 votes and no comments is good?
17:36:23 * pumpkin eats sour skittles
17:36:44 <dolio> You know they have chocolate skittles now?
17:36:56 <dolio> I mean, why bother?
17:37:06 <dons> gwern: after 20 mins, yes.
17:37:24 <pumpkin> dolio: wow! no, I didn't
17:38:21 <dons> gwern: compare with, e.g. http://www.reddit.com/r/haskell/comments/7s70z/what_is_haskell_good_for/
17:38:32 <dons> which i thought was pretty inoffensive, and is on the /haskell/ reddit
17:39:26 * ksf is going to make himself a t-shirt with "I used unsafeCoerce to fix a segfault" on it.
17:39:53 <dublpaws> @hoogle (* -> *)
17:39:53 <lambdabot> Parse error:
17:39:53 <lambdabot>   --count=20 "(* -> *)"
17:39:53 <lambdabot>                 ^
17:39:58 <dons> ksf: haha
17:40:08 * dons notes cabal install gitit suceeds wonderfuly
17:40:35 <Nafai> cabal install is fun :)
17:40:41 <gwern> dons: didn't you quip that gitit with its 40 deps was one of the best arguments for cabal-install?
17:40:49 <dons> sounds plausible
17:41:03 <gwern> (huh, 5 votes up and 3 down? for a little tag cloud?)
17:41:06 <dons> my arch packages are having trouble, while cabal-install gobbles it down.
17:41:11 <idnar> heh
17:41:21 <ksf> gwern, how many packages are left uninstalled after that?
17:41:25 <ksf> frag?
17:41:36 <gwern> heh heh
17:41:40 <thoughtpolice> i want a shirt that just says "i accidentally the whole unsafeCoerce#"
17:42:26 <dons> gwern: up votes	9
17:42:27 <dons> down votes	7
17:42:35 <dons> that's kinda crazy. am i being bot-modded?
17:42:37 <pebbles> wow, why so many down votes?
17:42:51 <olsner> "i accidentally the whole ***Exception: undefined"
17:42:52 <L-Spiro> Hello.  I need a tip.
17:43:02 <gwern> olsner: I lik that one better
17:43:06 <dons> yeah, now 8/10
17:43:09 <dons> something's fishy
17:43:13 <thoughtpolice> dons: it wouldn't surprise me if some java folks have created a cabal against you
17:43:33 <dons> on the haskell reddit?
17:43:35 <nodogbite> thoughtpolice: lol, java folks
17:43:38 <gwern> if anyone would be singled out, it'd be dons...
17:44:17 <L-Spiro> I get input from a file and need to parse line-by-line.  Is there a function already in Haskell to take a string and return all the characters up to the first new line?
17:44:18 <pebbles> dons: which one is this?
17:44:35 <dons> gwern: yeah, might be traffic from another forum
17:44:37 <pebbles> which reddit story, that is
17:44:44 <Gracenotes> they're trying to take us on Reddit... next thing you know, we'll have street combat and defenestration
17:44:45 <dons> http://www.reddit.com/r/haskell/comments/7s70z/what_is_haskell_good_for/
17:45:01 <gwern> L-Spiro: 'head . lines'?
17:45:15 <dons> something fishy
17:45:21 <pebbles> dons: I modded it up and it instantly got downmodded again
17:45:26 <pebbles> weird
17:45:32 <pebbles> it was 10/8 before, now 11/9
17:45:34 <gwern> or 'takeWhile (not . (== "\n"))', maybe...
17:45:35 <dons> pity having mods on the reddit doesn't give any ability to see who's doign what to it
17:45:44 <dons> pebbles: yeah, looks like bots
17:45:45 <nodogbite> dons: i up modded
17:45:50 <gwern> (er, '\n')
17:46:01 <L-Spiro> Just a note: I have been using Haskell for a total of 3 hours/.
17:46:05 <pumpkin> 13/10 :o
17:46:06 <gwern> L-Spiro: there're a lot of ways
17:46:07 <nodogbite> #haskell can beat any bot
17:46:10 <dons> i'll delete the post and try again. see if there's a pattern.
17:46:10 <pumpkin> lol
17:46:26 <idnar> up votes13
17:46:27 <idnar> down votes10
17:46:41 <L-Spiro> What is head . lines?
17:46:43 <dons> i don't think we've cumulatively had that many downmods on the haskell reddit
17:47:00 <nodogbite> L-Spiro: the 'head' function composed with the 'lines' function
17:47:14 <gwern> > lines "foo\nbar\nfoo"
17:47:15 <lambdabot>   ["foo","bar","foo"]
17:47:26 <gwern> > (head . lines) "foo\nbar\nfoo"
17:47:27 <lambdabot>   "foo"
17:47:44 <L-Spiro> That is probably what I want.
17:48:02 <sm> dons: just voted up.. that is odd. Maybe in the next one describe what's on the other end of the link, people may be going by the title
17:48:07 <dons> yeah
17:48:07 <porges> > lines "foo\r\nbar\rfoo\n"
17:48:08 <lambdabot>   ["foo\r","bar\rfoo"]
17:48:11 <sm> (the cloud was cool)
17:48:13 <L-Spiro> It doesn't handle the \r.
17:48:23 <L-Spiro> (I checked also.)
17:48:26 <gwern> wonder if it does on a windows system
17:48:41 <L-Spiro> Nope.
17:48:43 <dons> i think the cloud is actually good to show people who think haskell's "math" or "niche"
17:48:46 <L-Spiro> I am on Windows.
17:48:50 <sm> in fact I definitely prefer a reddit link that has motivating description, unless it's already got votes
17:49:06 <bohdan> L-Spiro: http://book.realworldhaskell.org/read/functional-programming.html#x_a6
17:49:20 * sm would never down-vote without looking though
17:49:21 <dons> sm: ok, let's do that instead.
17:50:07 <dons> http://www.reddit.com/r/haskell/comments/7s7nc/what_is_haskell_good_for_a_tag_cloud_of_haskell/  there you go
17:50:29 <L-Spiro> It is okay.  The file they gave me has only \n.
17:50:47 <L-Spiro> (But indeed they should add support.)
17:50:58 <pumpkin> \r needs to die already
17:51:04 <ksf> 8031172082481973057 does not look like a boolean value.
17:51:07 <bohdan> dons: it might help to filter out module names
17:51:10 <pumpkin> ksf: you sure?
17:51:19 <dons> so there's one immediate downmod, which i think is an auto-bot
17:51:25 <dons> bohdan: on the tag cloud?
17:51:26 <bohdan> dons, otherwise, I don't see why 'system' is so large
17:51:30 <bohdan> dons, yes
17:51:35 <dons> bohdan: they're not module names
17:51:38 * sm cheers at the plucky little finance 
17:51:38 <dons> they're category tags from hackage.
17:51:46 <dons> hehe. a couple of little finance libs
17:51:52 <dons> math, really.
17:52:00 <pumpkin> @faq can haskell make me billions? I want money
17:52:00 <lambdabot> The answer is: Yes! Haskell can do that.
17:52:08 <dons> cool.
17:52:20 <bohdan> dons: oh, ok, I thought it was mined from text descriptions
17:52:25 <bohdan> dons, nevermind then
17:52:31 <dons> no, mined from hackage tags.
17:52:44 <dons> i'll put the library on hackage for making the tag clouds
17:52:46 <dons> its cute.
17:53:58 <dcoutts> gwern: pong
17:54:03 <dcoutts> jeffz`: pong
17:54:08 <gwern> dcoutts: er... ping?
17:54:44 <ksf> ...maybe I should start to read the Foreign.Ptr haddock.
17:54:48 <bohdan> dons, I also hope you looked at only one version per package? :)
17:54:53 <L-Spiro> Wait, how do I convert the file contents to a string after this: s <- readFile "input.txt"
17:54:55 <dons> bohdan: right
17:54:57 <dcoutts> gwern: actually perhaps you were just using @seen on behalf of jeffz`
17:55:05 <sm> dons: may we have that hyperlinked, on hackage :)
17:55:16 <gwern> dcoutts: so anyway we of filestore has a wee problem with Paths_filestore
17:55:16 <dons> yes, further work.
17:55:25 <dons> hyperlinked , dynamically generated, hosted on hackage.
17:55:38 <dcoutts> gwern: please test with darcs version of Cabal-1.6.x
17:55:47 <gwern> dcoutts: our tests.lhs calls data/filestore/git.hs eg which calls Paths_filestore, but obviously it aint there...
17:55:48 <dcoutts> gwern: I think it is fixed
17:55:50 <gwern> oh you figured it out?
17:55:59 <gwern> because I thought I had darcs cabal...
17:56:02 <dcoutts> gwern: oh, try running build first
17:56:15 <dons> we need 'directory' on hackage.
17:56:23 <sm> then we can play a game of conquer the cloud.. right now it's DATA
17:56:23 <dons> i modified unix, now can't rebuild directory since it isn't released :/
17:56:26 <dcoutts> gwern: yes, cabal haddock does not build the autogen files (yet) have to build first
17:56:42 <dcoutts> dons: hmm, we should get them all on there, including base
17:56:45 <ksf> there's a certain evilness associated with accessing an array of a union without the glorious C type system.
17:56:54 <dons> i'm ok with not modifying base. but the others, sure.
17:57:03 <dcoutts> base should be there too
17:57:08 <dcoutts> there's no reason not to
17:57:10 <ksf> ...maybe I should just give up and write the pointer stuff in c.
17:57:13 <dons> if you can make it work :)
17:57:13 <gwern> dcoutts: there a bug for that haddock thing yet?
17:57:17 <dcoutts> dons: cabal will not accidentally try and upgrade it
17:57:34 <dons> cabal is smart
17:57:37 <dcoutts> gwern: I think so, add yourself to the cc if you find it otherwise file it new
17:57:52 <gwern> dcoutts: doesn't seem to work - I'm using 'Using Cabal-1.7.0 compiled by ghc-6.10'
17:58:26 <gwern> dcoutts: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=919#a919
17:58:33 <dcoutts> gwern: yeah, sorry I thought you were talking about a different bug. The not building autogen modules for the haddock command is still not fixed.
17:58:59 <dons> shouldn't liskell be a hackage app that depends on ghc-api?
17:59:00 <gwern> the filestore.cabal file currently reads 'Other-modules:       Paths_filestore'
17:59:10 <dons> woo. gitit installed
17:59:11 <dcoutts> gwern: oh, now that's different, you're running test
17:59:25 <gwern> dcoutts: yes, there's 2 issues here - haddocks and testing
17:59:26 <dons> less: don't rebuild directory, randomly bump version numbers, and not rebuild things
17:59:30 <gwern> sry if I confused you
18:00:16 <dcoutts> gwern: as for testing you're compiling test without setting -i flag to find the Paths_blah module
18:00:27 <gwern> where would I set -i?
18:00:28 <bohdan> wow I've just realized that '|xrags' is (.) and '|xargs -I X' is (\X ->)
18:00:38 <dcoutts> gwern: -i dist/build/autogen
18:00:57 <dcoutts> gwern: no idea if runhaskell accepts such flags
18:01:00 <gwern> 'target `dist/build/autogen' is not a module name or a source file'
18:01:06 <gwern> guess not?
18:01:21 <pumpkin> dons: do you remember what the first parameter enumFromToEachU does? it seems to do nothing...
18:01:24 <thoughtpolice> runghc will accept those flags
18:01:29 <pumpkin> , enumFromToEachU 2 (toU [1 :*: 4, 7 :*: 10])
18:01:30 <lunabot>  luna: Ambiguous occurrence `:*:'
18:01:35 <pumpkin> :(
18:01:36 <dons> umm
18:01:38 <thoughtpolice> runghc -idist/build/autogen -- files...
18:01:41 <dolio> , [$ty| enumFromToEachU |]
18:01:41 <dons> look at the code!
18:01:44 <lunabot>  Int -> UArr (:*: Int Int) -> UArr Int
18:01:52 <pumpkin> dons: hah, I'm trying to figure it out :) alright, I'll keep looking
18:01:53 <dcoutts> gwern: oh sorry, no space between -i and the dir
18:02:00 <gwern> ah, 'runghc -idist/build/autogen Tests.lhs' does work
18:02:03 <SamB> lunabot: hey, your GHC is buggy
18:02:13 <gwern> (incidentally, what a bizarre option that is - no space? how does that even parse...)
18:02:50 <SamB> gwern: short options often work that way ...
18:02:59 <jeffz`> dcoutts: hiya, I had a problem with using 'cabal install' after doing cabal configure and cabal build with the Win32 package, so I reduced it to a small testcase, http://jeffz.name/onex - I gave up though when I noticed I can just use a plain old Setup.hs to do configure, build and install without error.
18:03:47 <dcoutts> jeffz`: it's do to with selecting the version of base, 3 or 4
18:04:15 <dcoutts> jeffz`: runghc Setup / cabal configure  always pick the latest version, ie 4
18:04:37 <dcoutts> jeffz`: cabal install uses a solver and preferences and if you do not specify, it prefers base 3 over 4
18:04:54 <dcoutts> jeffz`: so your package needs 4 because it needs onException from the Control.Exception
18:05:12 <dcoutts> jeffz`: so you should specify as such then it'll always work
18:05:27 <jeffz`> ah, so it does
18:05:32 <dcoutts> jeffz`: it's only because you've not specified that it chooses base 3
18:05:42 <thoughtpolice> @seen augustss
18:05:42 <lambdabot> I saw augustss leaving #haskell 11h 25m 19s ago, and .
18:06:03 <dcoutts> jeffz`: it was introduced as a backwards compat measure for the 100's of packages that did not specify a version of base but worked with base 4
18:06:09 <pumpkin> alright, I conclude that the argument is ignored! :P
18:06:39 <dcoutts> jeffz`: I admit it's confusing that configure behaves differently from install, I'm changing it to be more consistent and less confusing in the next release of cabal-install
18:07:07 <thoughtpolice> @tell augustss I think you need to fix the llvm package again - when trying to build ./llvm/examples with llvm-0.6.0.2 from hackage I get undefined references to "_LLVMGetPointerToGlobal"
18:07:07 <lambdabot> Consider it noted.
18:07:11 <dolio> pumpkin: It's passed to the Stream constructor.
18:07:20 <pumpkin> dolio: I see that, but it seems to have no effect?
18:07:28 <dolio> It does if you give it undefined.
18:07:34 <dolio> So it gets used somewhere. :)
18:07:42 <pumpkin> the constructor has !Int there
18:07:45 <bohdan> dons, what's the algorithm for font size?
18:08:07 <dolio> Not in my copy.
18:08:41 <pumpkin> dolio: oh you're right
18:08:45 <dolio> pumpkin: It's obviously supposed to be the length of the stream.
18:08:49 <dolio> It's probably just a hint.
18:08:53 <pumpkin> dolio: yeah, but it doesn't seem to behave that way
18:08:55 <L-Spiro> Iam trying to print the values in a list one-by-one using a function which I want to accept the list as an argument.
18:09:00 <thoughtpolice> i really must say oleg's implicit parameters trick is pretty awesome.
18:09:06 <pumpkin> dolio: I can pass it a negative number and it generates the exact same value as 1000
18:09:06 <thoughtpolice> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=881
18:09:16 <thoughtpolice> i decided to type up the modulus math part of the paper and it's brilliant. :)
18:09:27 <aresnick> Hi!  I'm trying to use cabal-install to install the zip-archive package, and I'm receiving the error "Failed to parse package dependency: "zip-archive.cabal"" when I enter "cabal install zip-archive.cabal" I haven't found much online, and I was wondering if anyone had any pointers to where I should look to debug next?
18:09:33 <L-Spiro> printArray n = do  -- How do I define n as an array/list so I can use snd on it?
18:09:46 <dcoutts> aresnick: try upgrading cabal-install first
18:10:07 <dcoutts> aresnick: it sounds like you're using an older version that cannot parse some newer packages
18:10:16 <aresnick> dcoutts: I'm using the most recent darcs version, but I can try the stable, instead.
18:10:27 <dcoutts> aresnick: really? what version?
18:10:39 <dcoutts> aresnick: ohhh!
18:10:45 <dcoutts> aresnick: you said cabal install zip-archive.cabal
18:10:58 <aresnick> dcoutts: Yep, is that wrong?
18:10:59 <dcoutts> aresnick: "zip-archive.cabal" is not a package name or dependency
18:11:26 <dcoutts> aresnick: you mean "zip-archive" or something like "zip-archive-1.0" or "zip-archive < 2"
18:11:35 <dcoutts> those are all valid
18:11:39 <dcoutts> blah.cabal is not
18:11:44 <dcoutts> (yet)
18:11:52 <aresnick> dcoutts: I downloaded the zip-archive.cabal package, because when I just tried cabal install zip-archive, I get the error "cabal: There is no package named zip-archive"
18:11:57 <aresnick> dcoutts: I see
18:12:22 <dcoutts> hmm, there is such a package
18:12:35 <dcoutts> aresnick: make sure you did an update first, cabal list zip-archive  shows it's there
18:12:52 <aresnick> dcoutts: Ah!  OK.  So cabal _is_ something that looks online
18:13:24 <Gracenotes> wow.. smalltalk is weird.
18:13:29 <dcoutts> aresnick: yes :-)
18:13:40 <pumpkin> dolio: aha
18:13:49 <aresnick> dcoutts: Hmm, is there something beyond "cabal update" I should do?
18:13:52 <dolio> pumpkin: It looks to me like there could be problems in certain cases if that number isn't right.
18:13:55 <dolio> But I'm not 100% sure.
18:13:57 <pumpkin> dolio: it is used to decide how much memory to allocate, but it happily runs over the buffer
18:14:02 <pumpkin> so it looks fine
18:14:11 <dcoutts> aresnick: no, that's it, and make sure you're running 0.6.0 or later
18:14:15 <pumpkin> but it'll die if you provide something too small
18:14:32 <dcoutts> aresnick: cabal install zip-archive works fine here
18:14:46 <pumpkin> it's in newDynU btw
18:14:53 <dolio> Right.
18:15:04 <aresnick> dcoutts: Hmm, OK--I'm using 0.6.1, and cabal update runs fine (suspiciously quickly, though).  cabal list zip-archive still fails, though.
18:15:29 <dolio> Anyhow, that doesn't look very safe.
18:15:37 <aresnick> dcoutts: When I try to run cabal upgrade, I get the error "cabal: There is no installed version of base"
18:15:54 <pumpkin> dolio: yeah, should probably have a safe mode check added to it
18:16:02 <dcoutts> aresnick: avoid upgrade for the moment
18:16:37 <dcoutts> aresnick: the http downloading should be quicker than it used to be, we switched to HTTP-4000
18:17:04 <dcoutts> aresnick: it fails as in cannot parse or fails as in zip-archive is not present?
18:17:17 <aresnick> dcoutts: zip-arcihve is not present; sorry for the ambiguity.
18:17:38 <dcoutts> aresnick: you might want to check the downloading, does sound a tad suspicious
18:17:59 <dcoutts> aresnick: eg inspect the index manually, perhaps download it manually and compare
18:18:05 <aresnick> dcoutts: A potentially relevant thing I found strange in the install--no ~/.cabal/config was created  I made one for symlink-bindir, but I was surprised that there wasn't one by default.
18:18:17 <aresnick> dcoutts: OK, I assume I can find the index on Hackage.
18:18:21 <aresnick> dcoutts: Thanks for the leads-
18:18:25 <L-Spiro> http://rafb.net/p/1gdDot84.html  What is wrong with this?
18:18:31 <dcoutts> aresnick: that is odd, the config file should always be created
18:18:33 <L-Spiro> The error is related to the use of tail.
18:19:08 <aresnick> dcoutts: OK, maybe I'll just try a fresh install.
18:19:31 <dcoutts> aresnick: yes, it really should always make it, even the darcs version is not that broken (I just tried it)
18:19:47 <dcoutts> aresnick: I'll be interested in what you find out, but now I've gotta get to bed
18:19:48 <aresnick> dcoutts: Alright--there's no make uninstall; is deleting the directories enough?
18:19:53 <aresnick> dcoutts: OK, thanks for your help!
18:19:57 <dcoutts> aresnick: yes, that's enough
18:20:08 <dcoutts> aresnick: rm ~/.cabal ~/.ghc  to blow it all away
18:20:18 <dcoutts> g'night folks
18:20:23 * dcoutts :: Sleep -> IO ()
18:20:23 <aresnick> dcoutts: Sounds good.  I'll let you know how it turns out.  'Night!
18:20:32 <redditbot> What is Haskell good for: A tag cloud of Haskell library diversity
18:20:32 <redditbot> The new Haskell network, web and wiki appliances
18:20:57 <Cale> L-Spiro: several things?
18:20:57 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:21:08 <L-Spiro> Cale, no doubt.  Care to list them?
18:21:37 <Cale> L-Spiro: show doesn't give an IO action, it produces a String, therefore this is in the list monad.
18:21:43 <roconnor> maybe I should use the term "realizer" instead of "representative".
18:21:49 <Cale> L-Spiro: are you sure that's what you want?
18:21:56 <L-Spiro> Not at all.
18:22:03 <L-Spiro> I want to print each element in a list.  Nothing more.
18:22:25 <Cale> The second strange thing is the pattern [n,b] which matches only a list of length 2
18:22:40 <porges> mapM_ print list
18:22:42 <Cale> (and then you apply head and tail to the first element of that list)
18:22:46 <L-Spiro> Yes but I did not know how to match a list of size > 1.
18:22:52 <Cale> (x:xs)
18:23:12 <Cale> printList (x:xs) = do print x; printList xs -- this would be okay
18:23:20 <Cale> Of course, you need a base case, like:
18:23:26 <Cale> printList [] = return ()
18:23:30 <L-Spiro> I have printList [] = []
18:23:41 <L-Spiro> But obviously that isn't fully right.
18:23:53 <Cale> You don't want it to produce a list, do you?
18:24:06 <Cale> You want it to produce an IO action for printing the elements of the list.
18:24:19 <L-Spiro> No.  But again I didn't know how not to produce a list (I have only been working with Haskell for 3 hours).
18:24:21 <Cale> (an IO action which probably has no interesting result)
18:24:22 <L-Spiro> Yes.
18:24:44 <Cale> return v gives the IO action which does nothing except to return v
18:24:58 <Cale> () is the empty tuple, and is handy for when you have nothing interesting to return
18:25:16 <Cale> So  printList [] = return ()  is suitable.
18:26:10 <Cale> A pattern like (x:xs) matches a nonempty list, with the first element matching x, and the tail matching xs
18:26:31 <L-Spiro> My ultimate goal is going to be to read a file, convert the lines to an array, and then sort data in the array by catagory.
18:26:48 <Cale> okay.
18:26:55 <Cale> Array or list?
18:27:03 <Cale> Probably a list would be simpler.
18:27:07 <L-Spiro> http://rafb.net/p/GaJAni34.html
18:27:08 <dons> language lists?
18:27:09 <L-Spiro> I am using this now.
18:27:12 <dons> L-Spiro: lists :)
18:27:16 <L-Spiro> And ir ptints correctly.
18:27:19 <L-Spiro> It prints.
18:27:29 <dons> readFile >>= print . sortBy (comparing category) . lines
18:27:32 <L-Spiro> (List.)
18:27:33 <Cale> Note that lists and arrays are not the same thing
18:27:34 <dons> appox.
18:28:54 <L-Spiro> dons, I am not sure how I can apply that.  I have to figure out how to determine the category of each item.
18:29:10 <dons> what format is each line ?
18:29:27 <L-Spiro> A line is either upper-case for a category or lower-case for an entry in the last category.
18:29:52 <L-Spiro> 2 categories: NUMBER and ANIMAL.
18:31:11 <L-Spiro> With lines( s ) I break the file into a list.  Now I just have to figure out how to go from there.
18:31:25 <porges> can someone point me to a couple of examples using (| |) and {| |}
18:31:35 * pumpkin loves learning
18:32:28 <akillah> hi, inspired by replaying an old lisp screencast (http://lispm.dyndns.org/mov/dsl-in-lisp.mov if anyone seen it; basically a remake of M. Fowlers scarry XML & Java DSL article) and i decided to to try it in haskell. what i've came with : http://paste.ideaslabs.com/show/azRhtQAOhj
18:32:37 <akillah> would anybody be so kind to look at it and tell me whether i should have done anything better ? also, i thought that as next step i'd try to stuff the data into records, but in truth, i can think of no elegant solution
18:32:45 <akillah> could anybody point me to some docs explaining how to solve such cases ? thanks in advance.
18:34:28 <ksf> some time in the future, we will have main :: Event World -> Event World
18:35:03 <pumpkin> some of these functions are hard to explain!
18:35:16 <L-Spiro> Here is my idea for parsing the file (since I can not think of a way to do it without side-effects).
18:36:11 <L-Spiro> I guess I want to parse the list 2 times, one checking for the NUMBER category and making a list and one checking for the ANIMAL category and making another list.
18:36:24 <L-Spiro> Right?  Because I can't switch between them and make 2 lists at once can I?
18:37:07 <Cale> L-Spiro: why can't you?
18:37:11 <sjanssen> L-Spiro: sure you can
18:37:22 <Cale> You can certainly do it with plain recursion.
18:37:41 <L-Spiro> Or maybe I can have one function that passes a list down and the list changes depending on if the current line is a category or not.
18:38:27 <Cale> L-Spiro: basically, you want to turn the list into a list of (Category, Item) pairs.
18:39:05 <L-Spiro> So basically I will have a function that accepts 2 empty lists and passes both down to func A which checks the category and passes either list down to func B which adds items up to the next category, where func A makes the switch again.
18:39:07 <L-Spiro> Right?
18:39:28 <Cale> L-Spiro: empty lists?
18:39:36 <L-Spiro> It will fill them.
18:39:39 <L-Spiro> Or create them.
18:39:49 <L-Spiro> I mean I can't return 2 lists can I?
18:39:49 <Cale> If they're empty, they can't have any elements.
18:40:00 <Cale> ;)
18:40:00 <L-Spiro> You can't add to an empty list?
18:40:03 <Cale> Right.
18:40:17 <Cale> You can make a new list from an empty list by adding an element.
18:40:24 <pumpkin> omg Axman6 haz a blog!
18:40:33 <Axman6> a new blog* :)
18:40:44 <L-Spiro> So how do I organize this?
18:40:45 <Axman6> i did have a wordpress one, but you can't add plugins >_<
18:41:01 <Axman6> so, no markdown, no syntax hilighting
18:41:32 <L-Spiro> So I return a (Category, Item) pair.
18:41:36 <Cale> L-Spiro: how about a function which takes a category (the current/initial category), and a list of categories/items
18:41:47 <Axman6> pumpkin: did you try going to it?
18:41:56 <pumpkin> yup!
18:42:00 <pumpkin> haven't read it yet, only just saw the tweet
18:42:02 <Axman6> awesome. how's the loadtime?
18:42:02 <L-Spiro> How do I "define" a category?
18:42:11 <Cale> L-Spiro: just a string, yeah?
18:42:17 <Cale> Let's call it categorise :: String -> [String] -> [(String,String)]
18:42:19 <L-Spiro> No special typing?
18:42:22 <Axman6> i don't have a very good connection (though it's better than i sed to be)
18:42:22 <Cale> We could.
18:42:25 <Axman6> used*
18:42:40 <dufflebunk> Anyone used hacanon-light, and have an example to share?
18:42:45 <pumpkin> Axman6: not noticeably slow
18:42:53 <Axman6> awesome :)
18:43:05 <Cale> But since categories have to be stored alongside items in our list, we'd end up using Either, and it would be more complicated.
18:43:15 <L-Spiro> I will stick with simple.
18:43:22 <Axman6> movable type is awesome by the way, i highly recommend it. being able to use SQLite as the backend is soooo mucvh easier
18:43:41 <Cale> categorise cat [] = []
18:43:44 <pumpkin> Axman6: I want a git backend
18:43:52 <Axman6> heh
18:43:54 <L-Spiro> But since the category can have many items, shouldn't it be (String,List)?
18:43:55 <Cale> categorise cat (x:xs) = ...
18:44:04 <bremner> pumpkin: ikiwiki
18:44:21 <Cale> L-Spiro: We're just attaching categories to each element.
18:44:32 <Cale> L-Spiro: If you prefer, we could build up a Data.Map or something.
18:44:41 <L-Spiro> Nope.  I will stick with simple
18:45:03 <Cale> now, we have two cases
18:45:10 <Cale> Either x is a category, or it's an item
18:45:17 <Olathe> > splitZomg ["Zomg", "hello", "how are you ?", "Kthx", "goodbye"]
18:45:19 <lambdabot>   [("Zomg",["hello","how are you ?"]),("Kthx",["goodbye"])]
18:45:36 <L-Spiro> Yes.
18:45:37 <Cale> If x is a category, the result should be the same as if we'd started with that category, and didn't have this element
18:45:40 <Cale> That is:
18:46:00 <Cale> categorise cat (x:xs) | isCategory x = categorise x xs
18:46:16 <Cale> yeah?
18:46:31 <L-Spiro> I will post the input file.
18:46:43 <L-Spiro> http://rafb.net/p/XPKTRV56.html
18:46:47 <Cale> On the other hand, if x is an item instead, we want to attach the current category to it, and proceed down the list:
18:47:07 <ddarius> groupBy isRight $ map eitherCategoryOrWord $ words input
18:47:10 <Cale>                       | otherwise    = (cat,x) : categorise cat xs
18:47:20 <L-Spiro> | = new line right?
18:47:31 <Cale> no, it's a guard
18:47:40 <Cale> | is part of the syntax
18:47:54 <L-Spiro> Oh, I have not read about that.
18:48:08 <Cale> You can use if ... then ... else ... instead, something like:
18:48:23 <Cale> categorise cat (x:xs) = if isCategory x
18:48:28 <koninkje> foo | this = is | that = at == foo = if this then is else if that then at else ...
18:48:31 <Cale>                            then categorise x xs
18:48:40 <Cale>                            else (cat,x) : categorise cat xs
18:48:42 <L-Spiro> isCategory x = Char.isUpper( x )
18:48:43 <koninkje> (where the ... means pattern failure)
18:48:58 <L-Spiro> Right?
18:49:12 <Cale> L-Spiro: all isUpper x
18:49:38 <L-Spiro> IsUpper is not in scope.
18:49:42 <Cale> import Data.Char
18:50:02 <Cale> Also, note that it's case sensitive
18:50:16 <blackdog> to ask a dumb question: how do i let cabal know to compile some C files as well as the haskell source? (relatedly: i assume i just pass something like library-dir to bind to C system libraries?)
18:51:43 <blackdog> ah, c-sources. knew it was a dumb question.
18:52:21 <L-Spiro> http://rafb.net/p/1CvaxV64.html  This is what I have,
18:52:25 <L-Spiro> Compiles.
18:53:15 <Cale> Note that the parens around x in the definition of isCategory are unnecessary
18:53:25 <Cale> parens are only ever needed for grouping
18:53:25 <L-Spiro> Yes.
18:53:47 <Cale> So if you load that into ghci, and do something like...
18:53:53 <Cale> xs <- fmap lines (readFile "test.file")
18:53:55 <Cale> and then
18:53:59 <Cale> categorise "" xs
18:54:09 <Cale> you should get [("NUMBERS","one"),("NUMBERS","three"),("NUMBERS","two"),("NUMBERS","one"),("NUMBERS","three"),("ANIMALS","sheep"),("ANIMALS","horse"),("ANIMALS","cow"),("ANIMALS","horse"),("NUMBERS","seven"),("NUMBERS","six"),("NUMBERS","six"),("ANIMALS","moose")]
18:55:18 <L-Spiro> Did not compile.
18:55:34 <Cale> hm?
18:55:45 <akillah> well, ignored so far ;-) would anybody at least please tell me whether Template Haskell is the way to go when i want automatically generate data structures from description ?
18:56:19 <L-Spiro> http://rafb.net/p/Nq2ShA15.html
18:56:21 <Cale> akillah: I suppose you could use TH for that.
18:56:29 <L-Spiro> Seems to be on the         categorise "" xs line.
18:56:47 <Cale> L-Spiro: right, that wasn't intended as an IO action
18:56:48 <akillah> cale: seems that you know of a better solution ?
18:56:57 <Cale> L-Spiro: It was intended for you to type at the ghci prompt
18:57:07 <L-Spiro> Oh.
18:57:08 <Cale> L-Spiro: but you can add a print to it if you prefer
18:57:18 <Cale> print (categorise "" xs)
18:57:32 <L-Spiro> xs <- fmap lines( readFile "input.txt" )  This part is okay in the source?
18:57:36 <akillah> just pointer to some docs/papers concerning this would be enough ...
18:57:37 <L-Spiro> It gives a list.
18:57:46 <Cale> akillah: Define a sufficiently general datatype and use that.
18:58:01 <L-Spiro> Okay it printed the right thing.
18:58:16 <rwbarton> L-Spiro: Your parentheses are quite misleadingly placed
18:58:26 <ddarius> L-Spiro: How do you read 'fmap lines( readFile "input.txt" )' ?
18:58:38 <L-Spiro> Read it?
18:59:04 <pumpkin> interesting formatting
18:59:13 <ddarius> L-Spiro: Explain what you think you are telling the language with that line.
18:59:14 <jeffz`> yeah... this isn't C
18:59:20 <akillah> cale: but how should i fill the data type ? i mean it can have varying number of differently typed fields (parametes). seems like a lot of manual work. it's a breeze with lisp macros ..
18:59:30 <Cale> L-Spiro: the parens in that code serve only to group the readFile "input.txt" into one thing.
18:59:44 <Cale> L-Spiro: They don't mean "apply lines to this parameter"
18:59:55 <L-Spiro> Apply lines?
18:59:55 <Cale> (in fact, it's fmap lines which is being applied)
19:00:07 <Cale> Functions are applied to their parameters
19:00:12 <L-Spiro> There is a difference between lines( and lines (?
19:00:35 <Axman6> no
19:00:56 <Axman6> functions don't need brackets in haskell, unless you need to bind things together
19:01:02 <newsham> > words("this is a test")
19:01:04 <lambdabot>   ["this","is","a","test"]
19:01:04 <Cale> L-Spiro: no, it's just that the way that you're formatting it possibly betrays a confusion of how you're thinking about it :)
19:01:06 <newsham> > words ("this is a test")
19:01:08 <lambdabot>   ["this","is","a","test"]
19:01:11 <Nafai> So I think I've perhaps narrowed down my issues to be with the feed library
19:01:12 <newsham> > words "this is a test"
19:01:13 <lambdabot>   ["this","is","a","test"]
19:01:14 <Axman6> like foldr (flip (:)) [] xs
19:01:20 <rwbarton> akillah: If you want to declare a data type whose definition is determined at compile time by the contents of a file, TH is the way to go
19:01:53 <rwbarton> akillah: but a lot of the time, you don't actually need to do that
19:02:19 <akillah> rwbarton: what i have: http://paste.ideaslabs.com/show/azRhtQAOhj
19:02:59 <Cale> L-Spiro: another curious thing about function application in Haskell is that it associates to the left.
19:03:13 <Cale> L-Spiro: if you write f x y z, you're really writing ((f x) y) z
19:03:15 <rwbarton> akillah: Man that paste site has ugly formatting. :)
19:03:20 <pumpkin> Axman6: I figured out my bug with UArr :) but doubt my solution will solve your issue :/
19:03:26 <akillah> rwbarton: but i don't know how should i stuff the parsed data into a record even if i'd declare it manually (so i couldn't even "templatize it" using TH).
19:03:37 <Axman6> pumpkin: was it your fault or a bug?
19:03:39 <Cale> L-Spiro: All functions have exactly one parameter, and those which appear to have more just return other functions.
19:04:12 <pumpkin> Axman6: my fault, really, but the documentation didn't state that many more operations were unsafe than those marked as unsafe (and that things with similar names to list counterparts didn't have the same semantics)
19:04:23 <Cale> L-Spiro: So this is the only reason for the parens around readFile "foo"
19:04:25 <L-Spiro> Jesus Christ GHC.exe was taking 1.6 gigs of RAM.
19:04:30 <L-Spiro> I could not use my computer WTF.
19:04:42 <porges> is the GHC documentation for generics out of date? I just tried the example at http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
19:04:44 <ozy`> what were you compiling? O_o
19:04:48 <L-Spiro> Nothing.
19:04:56 <pumpkin> L-Spiro: a very common thing for beginners :P
19:04:57 <Axman6> L-Spiro: that happens from time to time
19:04:57 <Cale> L-Spiro: If we'd left them out, it would be  ((fmap lines) readFile) "foo", which isn't what we wanted.
19:05:14 <Cale> L-Spiro: huh?
19:05:27 <Cale> L-Spiro: How was it run?
19:05:29 <L-Spiro> GHC was just running off with all my RAM.
19:05:30 <Axman6> L-Spiro: if you do things like reverse [1..], it'll easily use a few gigs of RAM before you have to kill it
19:05:42 <L-Spiro> I was just running the code I posted.
19:05:45 <Axman6> ozy`: i'm guessing ghci
19:05:52 <rwbarton> I think ghci which is the same executable as ghc
19:05:54 <ozy`> ah yeah
19:05:58 <pumpkin> yeah
19:06:01 <L-Spiro> ghci was running fine.
19:06:02 <L-Spiro> STill is.
19:06:53 <L-Spiro> http://rafb.net/p/ZRdr9Z54.html  Anyway is that better?
19:07:00 <L-Spiro> I have to go now.
19:07:06 <rwbarton> akillah: Well, you might decide the [(String, String)] lookup table is fine (or maybe Map String String)
19:07:18 <rwbarton> L-Spiro: Yes, much better :)
19:07:39 <L-Spiro> Okay well we will have to get back to this later.  I have a date.
19:07:43 <shapr> ooh
19:07:48 <shapr> I wish I had a date!
19:08:04 <dons> shapr: lots of cool stuff happening this week.
19:08:09 <dons> you been following events?
19:08:09 <L-Spiro> I'm not too excited.  I haven't seen her picture.
19:08:16 <L-Spiro> Anyway I am off.  Thank you for the help/
19:08:23 <shapr> dons: Nah, work was way busy.
19:08:36 <shapr> dons: I did see the HAppS fork, yay! And the new cryptol thingy, w00!
19:08:40 <shapr> What else happened?
19:08:47 <shapr> It's totally time to organize CHUG...
19:08:54 <dons> 1000th package released. a p2p vpn client also. gwern's worked hard to get gitit/orchid to play well, so now we have a uniform API for git/darcs storage
19:08:57 <shapr> Let's see, I need to email peeps to find a venue..
19:09:02 <shapr> Whoa awesome!
19:09:09 <shapr> I love the idea of a uniform git/darcs api!
19:09:13 <SamB> shapr: is that some higher-order milk-drinking competition ?
19:09:14 <dons> http://www.reddit.com/r/haskell/  <-- news coming quick and fast.
19:09:18 <shapr> SamB: Yeah, something like that.
19:09:22 <dons> patch-tag.com launched
19:09:25 <dons> like github for darcs
19:09:28 <shapr> w00!
19:09:44 <rwbarton> akillah: Or, you could define data SVCL = SVCL { customerName, customerID, callTypeCode, dateOfCall :: String }; lineToSVCL l = SVCL (field "CustomerName") (field "CustomerID") (field "CallTypeCode") (field "DateOfCall") where field s = fromJust (lookup s l)
19:09:53 <shapr> I've mostly been donig non-haskell stuff recently.
19:09:55 <akillah> rwbarton: would there be something like reflection to determine the names/order of fields of datatype ? is there an elegant way to apply a method (Type Constructor in my case) to a number/array of parameters ? or is this a plainly lispy way to do it and i should know better ? is there some docs explaining it ?
19:10:02 <shapr> I did email Norman Ramsey, asked if he'd come to a CHUG.
19:10:03 <Nafai> shapr!
19:10:07 <shapr> Nafai!
19:10:28 <rwbarton> akillah: If you want functions like that lineToSVCL above, but don't want to write them manually, then yes, you can use TH
19:10:34 <shapr> dons: p2p vpn client? What's it called?
19:10:41 <dons> shapr: i put all my blog posts together on a new site, that's much easier to use, also. so some of the old "classics" are more accessible
19:10:41 <shapr> wchogg: Hey, any progress on the bluetooth binding?
19:10:44 <dons> "scurry"
19:10:46 <shapr> I want to play with that!
19:10:47 <shapr> haha
19:10:49 <shapr> Good name!
19:11:36 * pumpkin is sad that haddock doesn't support associated types
19:11:41 <rwbarton> akillah: There are many examples of this kind of thing in the derive package, though the source can be a little... cryptic
19:12:14 <shapr> dons: The haddock needing examples discussion was cool.
19:12:16 <shapr> I totally agree!
19:12:36 <rwbarton> Did anyone count how many emails there were in the "ocaml" thread?
19:12:47 <akillah> rwbarton: thanks, if i tried to write it manually i might have realizet it's that simple and stopped worrying about reflection. since when using templates/macros the order will be fixed and then no reflection is needed. thanks a lot ;-)
19:13:06 <shapr> In fact, why not extend haddock to include QC/hunit tests as a separate section in the docs?
19:13:14 <Cale> You might be interested in something like Parsec for parsing.
19:13:17 <shapr> That would go quite a ways towards describing how the code should behave.
19:13:24 <erikc> hrm, is there a way to have cabal-install use multiple hackage repos/servers?
19:13:26 <Axman6> shapr: sounds like an excellent idea
19:13:32 <Cale> (akillah)
19:13:53 <shapr> erikc: I'm pretty sure it already supports that.
19:14:02 <akillah> cale: ???
19:14:34 <ksf> let's say I have an Event String and an Event Bool, and want to snapshot_ (the reversed string if true, the string if false) (eitherE stringE boolE. How do I implement the pseudocode?
19:14:37 <dons> yep. i think the killer app for this year's google SoC is wiki+ haddock
19:14:42 <shapr> ahh!
19:15:10 <Cale> akillah: It's a library which lets you write and compose parsers in various ways, and treat them as first-class values.
19:15:15 <shapr> Oh, microsoft gave a talk to my group at raytheon
19:15:21 <shapr> The talk was about software factories.
19:15:29 <rwbarton> I think this is a case where parsec might actually be overkill. :)
19:15:43 <shapr> It was clear that the people giving the talk had very little clue about DSLs, but were trying valiantly to describe them anyway.
19:16:11 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=920#a920 <- semi-complete code
19:16:20 <Cale> Perhaps, but I tend to reach for parser combinators on anything much more complicated than words/lines will accomplish :)
19:16:55 <shapr> So it seems that Microsoft's next trick is DSLs.
19:16:57 <akillah> cale: ah, you mean the parsec reference ;-)) yeah, i've seen parsec in action, csv parser in few lines of beautifull code. i even modularized it to allow for different quoting/separating characters.
19:17:11 <erikc> shapr: was there any coverage of M in that talk?
19:17:32 <shapr> Someone asked "How do you get two of these things to work together?" but no one could answer that. I was tempted to spout off about embedded DSLs.
19:17:33 <Nafai> I just got ghci to crash :(
19:17:46 <shapr> erikc: Yup, they touched on M and Oslo.
19:18:16 <rwbarton> ksf: Can you stepper the string, and then isn't Behavior an instance of Applicative?
19:18:18 <Nafai> http://gist.github.com/51664 <- My error
19:18:29 <shapr> And they talked about agile programming, specifically SCRUM. That was funny.
19:18:32 <Nafai> shapr: Is M their "Emacs for .NET" that isn't really?
19:18:40 <erikc> nafai: thats intellipad
19:19:00 <erikc> which is ironpython/xml scripted
19:19:06 <shapr> Nah, M is a modelling language, iirc.
19:19:18 <Nafai> Oh yeah
19:19:31 <ksf> rwbarton, care to elaborate for someone for whom Applicative == fmap ?
19:19:37 <Nafai> Intellipad is what they use to edit M
19:19:41 <rwbarton> :t (<*>)
19:19:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:19:52 <Nafai> http://blogs.msdn.com/intellipad/archive/2008/10/30/creating-a-custom-mgrammar-command-in-intellipad.aspx
19:20:01 <ksf> that makes sense.
19:20:04 <rwbarton> ksf: you have a Behavior (String -> String) and a Behavior String and want to "apply" the first to the second
19:20:07 <olsner> shapr: funny as in interesting or funny as in amusing?
19:20:14 <shapr> olsner: Amusing.
19:20:18 <erikc> shapr: we are doing scrum where i work now, it annoys me so much that ill likely quit if it becomes the norm
19:20:25 <hackage> Uploaded to hackage: logfloat 0.9.1.3
19:20:31 <akillah> thanks a lot, guys, i'm going to do some more mental masturbation, i mean practice. wish me luck with TemplateHaskell, it seems pretty chunky ;-)
19:20:32 <shapr> They really do have some clue about agile programming, but it's serious cognitive dissonance at Raytheon.
19:20:32 <redditbot> Bryan O'Sullivan on the Power of Haskell - O'Reilly Broadcast
19:20:39 <shapr> Raytheon is all about the waterfall.
19:20:49 <rwbarton> Nafai: That's what happens when you load two packages in ghci that depend on different versions of a third package
19:21:00 <shapr> erikc: I really enjoy agile programming. What bugs you about SCRUM?
19:21:12 <rwbarton> Nafai: the solution seems to be to recompile whichever package is using the older version.  It's unpleasant
19:21:22 <Nafai> Yeah :(
19:22:08 <Nafai> rwbarton: I just recompiled a few of my modules with profiling support, but not all, I wonder if that screwed it up
19:22:12 <ksf> works so far.
19:22:39 <ksf> I guess the misbehaviour I get is rooted in me not passing the same clock to all sinks.
19:22:42 <rwbarton> Nafai: probably not related to the profiling but maybe they're now built against a newer version of bytestring
19:23:01 * Nafai nods
19:23:27 <ddarius> rwbarton: 97
19:23:44 <ddarius> wtf is SCRUM?
19:23:44 <rwbarton> ddarius: Oh, that's less than it felt like
19:23:59 <ddarius> rwbarton: There should have been side threads that also added to it.
19:24:34 <ddarius> E.g. the improved documentation for Bool which is another 20 posts
19:24:54 <lucca> armored object oriented?
19:24:58 <kbateman> http://en.wikipedia.org/wiki/Scrum_(development)
19:24:59 <erikc> shapr: so far it has meant more meetings, and more attempts at planning/sizing before the problems are properly understood, so a waste of time (but this is more an organizational issue than a specific problem with scrum)
19:25:15 <shapr> erikc: Yeah, doesn't sound like agile programming to me.
19:25:49 <rwbarton> 222 emails with "OCaml" in the subject
19:25:54 <ddarius> rwbarton: Maybe 197
19:26:02 <ddarius> It seems GMail split it into two for some reason.
19:26:25 <shapr> erikc: Spike Solution to understand the problem, then you can do something about it.
19:26:33 <Axman6> someone probably changed the subject
19:26:34 <shapr> At Raytheon, we ship our prototypes...
19:26:45 <Axman6> Anyone here use Movable Type?
19:27:19 * SamB wonders if MARKs can be inserted programmatically in GHC's heap profiles ?
19:27:27 <chessguy> > foldr (+) 4 [1..]
19:27:29 <lambdabot>   * Exception: stack overflow
19:27:38 <erikc> shapr:  we do 2 week sprints (quite short imo), but the customer wants a weekly working build, so the thursday/friday of the off week are typically spent patching up the build temporarily
19:27:40 <cjb> shapr: hola
19:28:14 <inbuninbu> hi, i'm fairly new to haskell... i've been reading up on it with "real world haskell", but have had trouble wrapping my head around the best way to solve what seems like a relatively simple problem... any help would be greatly appreciated...
19:28:31 <blackdog> inbuninbu: don't ask whether you can ask :) just ask
19:28:38 <inbuninbu> haha, thanks
19:28:39 <ddarius> shapr: You have quality programmers is all
19:28:47 <rwbarton> Already 17% more emails on haskell-cafe than in all of December
19:29:39 <inbuninbu> well, it's pretty simple; i want to create a data structure for a 3d mesh... vertices with edges... so basically an undirected graph where each node is a 3d coordinate
19:29:40 <shapr> hola cjb!
19:29:49 <shapr> erikc: That sucks
19:29:56 <shapr> erikc: That's not the way to do it.
19:30:07 <shapr> erikc: But then, I refuse to check in code that doesn't build.
19:30:07 <olsner> continuous last-minute fixing is definitely a bad idea
19:30:46 <shapr> erikc: wait, the customer wants a build that's not flaky at the end of every week? wtf?
19:31:01 <shapr> erikc: So you're saying that in reality you have confused one week cycles?
19:31:14 <Axman6> whoot! got twitter announcing my new blog posts :)
19:31:31 <Axman6> s/twitter/twitter+Movable Type/
19:31:35 <erikc> yup :), its a bit crazy
19:32:14 <inbuninbu> i thought about using a Data.Map structure for vertices, of type, say (Double, Double, Double), and another that is a list of pairs relating two of the vertex keys
19:32:24 <shapr> erikc: So, perhaps you should point out that SCRUM is focussed on not interrupting the programmers while they're working, and one week builds are interruptions?
19:33:30 <blackdog> hey, what's the policy on forking stuff on hackage? Microbench has a bug and the author's unresponsive to reports...
19:34:23 <rwbarton> inbuninbu: you might want something like a Map Int ((Double, Double, Double), Set Int), where the Ints identify vertices
19:34:38 <kbateman> inbuninbu:  an immutable array to hold the vertices would work well if you're not changing them often
19:34:45 <erikc> yup, its been done :\, its a bad environment at this point, management went to an agile seminar and came back 'enlightened', but layered scrum on top of what we were already doing
19:34:49 <shapr> blackdog: Send a patch to the author?
19:34:55 <shapr> erikc: oh much suck!
19:35:03 <blackdog> shapr: did, but no response.
19:35:10 <pumpkin> , unzipU . mapU (\x -> x :*: x+1) $ toU [1..5]
19:35:11 <lunabot>  luna: Ambiguous occurrence `:*:'
19:35:13 <pumpkin> that is really neat to me
19:35:19 <pumpkin> even though lunabot doesn't like it
19:35:25 <ddarius> erikc: Why does the customer want weekly builds?  What happens if you just give them last weeks build on the off week?
19:35:29 <blackdog> (it's a trivial bug - just using Ints rather than Integers means it can spin forever)
19:35:54 <Axman6> pumpkin: what's it supposed to do?
19:36:09 <pumpkin> Axman6: it just unzips it, but the unzip is constant time
19:36:09 <shapr> blackdog: I'd say fork it.
19:36:11 <rwbarton> I wonder whether Int64 or Integer is typically faster on a 32-bit platform
19:36:31 <Axman6> pumpkin: and what's all this U business? looks like something i should be looking into ;)
19:36:33 <rwbarton> I guess Int64, but I'm always surprised that Integer is not really that slow
19:36:52 <pumpkin> Axman6: uvector! the most awesomest package ev4r! it'll have more complete documentation soon, I hope
19:36:59 <pumpkin> (as I'm writing some)
19:37:04 <inbuninbu> rwbarton, kbateman: thanks! that nudges me in the right direction, i think. one thing that's hard to get my brain around is the best solution instead of a poor solution that might work, but is well, poor
19:37:05 <Axman6> ah, excellent :)
19:37:18 <ozy`> rwbarton: isn't that thanks to the magic of the hideously optimized GMP library?
19:37:24 <Axman6> pumpkin: care to give a brief explanation of what it does?
19:37:39 <inbuninbu> rwbarton++
19:37:48 <inbuninbu> kbateman++
19:37:57 <Axman6> @karma rwbarton
19:37:57 <lambdabot> rwbarton has a karma of 4
19:37:59 <rwbarton> ozy`: No, Integer has a separate constructor for "small" integers
19:38:00 <Axman6> @karma kbateman
19:38:01 <lambdabot> kbateman has a karma of 1
19:38:05 <rwbarton> @src Integer
19:38:05 <lambdabot> data Integer = S# Int#
19:38:05 <lambdabot>              | J# Int# ByteArray#
19:38:11 <pumpkin> Axman6: it's like a UArray in that it's unboxed, but it's also like Stream in that it's very fusible (is that a word?) meaning that many operations can be optimized out completely, removing the need for ever allocating the underlying array
19:38:27 <kbateman> kbateman++
19:38:32 <Axman6> nice :)
19:38:33 <kbateman> @karma kbateman
19:38:33 <lambdabot> You have a karma of 1
19:38:35 <kbateman> awww
19:38:39 <Axman6> @karma
19:38:40 <lambdabot> You have a karma of 5
19:38:40 <ksf> erikc, the trick is never to give them code before one week after deadline, even if you're finished three months early. spend the rest of the time renaming identifiers until you are truly satisfied.
19:38:43 <Axman6> whoot
19:39:01 <Axman6> @karma C
19:39:02 <lambdabot> C has a karma of 0
19:39:11 <Axman6> @karma C++
19:39:11 <lambdabot> C++ has a karma of -1
19:39:14 <Axman6> heh
19:39:24 <pumpkin> Axman6: yeah, it's really neat. http://hackage.haskell.org/packages/archive/statistics-fusion/0.2/doc/html/Math-Statistics-Fusion.html is a small stats package on top of it, and you can see the difference in performance on it
19:39:24 <Heffalump> @karma C--
19:39:25 <lambdabot> C-- has a karma of 1
19:39:25 <ddarius> "In the effective topos there exists a chain-complete distributive lattice with a monotone and progressive endomap which does not have a fixed point. Consequently, the Bourbaki-Witt theorem and Tarski‚Äôs fixed-point theorem for chain-complete lattices do not have constructive (topos-valid) proofs."  !
19:39:30 <erikc> ddarius: they want to measure progress and have their own QA team audit the builds
19:39:35 <Heffalump> @karma- C++
19:39:35 <lambdabot> C++'s karma lowered to -2.
19:39:39 <Heffalump> @karma+ C--
19:39:40 <lambdabot> C--'s karma raised to 2.
19:39:50 <pumpkin> C--++
19:39:54 <pumpkin> @karma C--
19:39:54 <lambdabot> C-- has a karma of 3
19:40:00 <pumpkin> C++--
19:40:03 <olsner> ddarius: obviously!
19:40:09 <pumpkin> omg it's a BMeph
19:40:10 <Axman6> C--++
19:40:11 * pumpkin hides
19:40:44 <ksf> erikc, just don't let them see your bug generator.
19:40:44 * BMeph seeks
19:41:05 * SamB accesses
19:41:19 <kbateman> My boss asked me how many lines of code I can write in a day.
19:41:31 <ddarius> olsner: It's actually rather significant and not good.
19:41:32 <SamB> kbateman: heh
19:41:36 <kbateman> I said "as many as you require me too.  I can't guarantee how good they'll be.
19:41:37 <blackdog> kbateman: time to go code yourself a minivan
19:41:49 <Nafai> I did -40 the other day
19:41:53 <inbuninbu> @karma+ kbateman
19:41:54 <lambdabot> kbateman's karma raised to 2.
19:42:06 <ddarius> Nafai: Those are the good days.
19:42:08 <inbuninbu> @karma+ rwbarton
19:42:08 <lambdabot> rwbarton's karma raised to 5.
19:42:15 <kbateman> thank'ye kindly
19:42:33 <inbuninbu> your welcome, thanks for the help
19:42:40 <ksf> @seen conal
19:42:41 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
19:42:45 <blackdog> Nafai: i tend to do auditing on my co-workers' code... i'd guess that my output over the last few months is in the negative thousands
19:42:53 <jberg_> what does it mean when you have class Foo a b c | a b -> c where ... like what does the | do?
19:42:54 * ksf bets he's afk
19:42:57 <Nafai> ddarius: Well, technically it was +5, but if you don't count the comments, it was -40
19:43:03 <Nafai> blackdog: :))
19:43:09 <olsner> heh, that's the kind of net negative producing programmers you want :)
19:43:24 * ksf is going to try to find out the state of that ghc fix before @telling conal
19:43:37 <Nafai> Unfortunately, my performance at my last job was compared to a coworkers based on lines of code produced
19:43:40 <blackdog> olsner: there was a blog post recently about outlawing the 'paste' command in coding editors...
19:43:44 <ddarius> I've removed hundreds of lines of code in a day.
19:44:14 <kbateman> jberg: that means that the 'c' type is determined by a and b.
19:44:14 <mjb> Removing lines is my second favorite thing to do. Removing files is my first.
19:44:15 <ddarius> blackdog: Disallow copy and paste but allow cut, yes!
19:44:42 <ddarius> So you cut code out of your program and then can't put it back in!
19:44:44 <jberg_> kbateman: okay.. but what effect does that have on code?
19:44:58 <Twey> kbateman: Correct answer: 'down to -400 on a good day'
19:45:48 <blackdog> ddarius: heh, that'd work.
19:45:57 <Twey> jberg_: http://www.haskell.org/haskellwiki/Dependent_type
19:45:58 <Cale> jberg_: it separates the functional dependency from the parameters
19:46:05 <Cale> er...
19:46:15 <Cale> This doesn't have to do with dependent types, afaik.
19:46:16 <jberg_> thanks
19:46:21 <Twey> Wait, that's not it
19:46:23 <Twey> Yeah.  Heh
19:46:25 <Cale> It's functional dependencies. :)
19:46:43 <Twey> I should probably look at URLs before handing them out.
19:46:44 <jberg_> oh..
19:46:47 * Twey makes a note.
19:46:50 <Cale> a b -> c  means that together a and b uniquely determine c
19:47:19 <Cale> That is, for any given types a and b, there is at most one type c for which there's an instance Foo a b c
19:47:26 <Twey> http://www.haskell.org/haskellwiki/Functional_dependencies ‚Äî this one
19:47:33 <rwbarton> More specifically, the compiler will complain if you try to define two instances Foo a b c, Foo a' b' c' where a = a' and b = b' but c /= c'
19:48:47 <ddarius> blackdog: It would especially bad for me as I tend to cut and double paste rather than copy and paste.
19:48:57 <jberg_> hmm ok. im looking at monad reader 8 and reading type level instant insanity where they solve if you can place a stack of cubes, each with different color faces so that no two faces are the same, in the typesystem alone
19:49:31 <blackdog> ddarius: heh, i do that. it drives pete gammie nuts - he claims i'm needlessly mutating :)
19:49:40 <Gracenotes> which is probably easier to learn for someone (me) with no experience with theorem provers? Coq, Agda, something else?
19:49:48 <jberg_> and he defines the "function" and as class And b1 b2 b | b1 b2 -> b where and :: b1 -> b2 -> b
19:50:02 <ddarius> Cale: It doesn't though it is useful for type level computation which is often used to simulate dependent types in Haskell.
19:50:18 <Cale> ddarius: yeah.
19:50:23 <ddarius> blackdog: I believe I tend to do it so I get visual feedback that the copy was actually performed.
19:50:33 <Gracenotes> learn meaning "understand at at least a rudimentary level"
19:50:47 <SamB> what does one do when ghostscript doesn't like one's heap profiles???
19:50:48 <Cale> jberg_: Typeclasses are essentially relations on types
19:51:05 <ddarius> SamB: Panic and run around.
19:51:06 <Cale> jberg_: functional dependencies are ways of insisting that those relations behave as functions
19:51:33 <koninkje> Cale: Don't you mean MPTCs rather than usual TCs (albeit a degenerate case of relations)
19:51:39 <ddarius> If you know relational database theory, functional dependencies are exactly the same thing as functional dependencies from that
19:51:57 <Cale> koninkje: Well, sure, we're talking about MPTCs here, but single parameter typeclasses do as well.
19:52:05 <olsner> SamB: rewrite the heap profiler to produce bitmaps rather than over-complicated postscript?
19:52:05 <ddarius> koninkje: Not too many useful functional dependencies to apply to single parameter type classes.
19:52:08 <Cale> (they're predicates)
19:52:23 * koninkje wasn't paying much attention to the actual discussion 
19:52:33 <rwbarton> And yet, FunctionalDependencies doesn't imply MultiParamTypeClasses for some reason
19:52:36 <koninkje> ddarius: heh, true true
19:52:49 <ddarius> rwbarton, koninkje: There are some (or at least, is one).
19:53:10 <Cale> jberg_: That is, we're thinking of And as a relation on types (I suspect there will be type level booleans around somewhere)
19:53:40 <Cale> jberg_: and the first two parameters to the typeclass determine the third, which we think of as the result of the And.
19:53:53 <rwbarton> ddarius: Huh, I didn't really expect that to be accepted! (| -> a)
19:53:54 <ddarius> class C a | -> a is non-trivial.
19:54:13 <jberg_> Cale, yes i understand now, thanks!
19:54:40 <ddarius> rwbarton: Haskell has a tendency to not have corner cases (i.e. to handle -all- cases uniformly)
19:54:52 <ddarius> One unfortunate exception is the lack of empty data types.
19:54:57 <rwbarton> I wonder if it's useful for anything
19:54:59 <BMeph> It sounds self-contradictory, so it's probably true...is there a Complex CReal instance? :)
19:55:09 <SamB> ddarius: what are you talking about ?
19:55:09 <Twey> Empty data types?  Void?
19:55:16 <Cale> BMeph: instance?
19:55:17 <pejo> Gracenotes, I recently asked that, and got the answer "whatever theorem prover you have local expertise for".
19:55:19 <rwbarton> BMeph: Complex CReal is a type
19:55:28 <rwbarton> > log (-1.295) :: Complex CReal
19:55:29 <lambdabot>   0.2585106951515010720202333836477219102595 :+ 3.141592653589793238462643383...
19:55:34 <ddarius> Twey: Things like Void.  E.g. data Foo;
19:55:35 <Gracenotes> local expertise?
19:55:57 <Twey> Oh, I wasn't aware that was valid syntax
19:55:59 <pejo> Gracenotes, if you're at a university - use what they teach, or know.
19:56:04 <Twey> I thought Void was magic :)
19:56:07 <ddarius> Twey: It isn't in Haskell 98
19:56:10 <ddarius> Twey: Albeit newtype Void = Void Void is also as empty semantically as Void is, but.
19:56:10 <Twey> Ah
19:56:21 <Gracenotes> pejo: ah. I don't think I'll be using any before I graduate (I'm an undergrad) :/
19:56:26 <SamB> ddarius: Is that legal?
19:56:36 <olsner> but ghc has data Foo, right?
19:56:36 <ddarius> SamB: Which?
19:56:38 <SamB> that sounds like it'd confuse compilers rather a lot ...
19:56:40 <ddarius> olsner: Yes.
19:56:45 <Gracenotes> I just want to get a taste of what sort of logic/semantics they use
19:56:54 <ddarius> rwbarton: Probably not, it would seem to be equivalent to simply defining the method as a function.
19:57:19 <rwbarton> ddarius: Why aren't there zero-parameter type classes? :)
19:57:44 <Twey> What would they be used for?
19:57:53 <Cale> rwbarton: Those would just be modules or collections of functions.
19:58:11 <rwbarton> Sure, but it'd be more consistent to include them, no?
19:58:45 <olsner> oh, the wonder... that'd look like a java class declaration or something
19:59:06 <ddarius> olsner: It would be like a module as Cale suggested.
19:59:06 * rwbarton is not seriously suggesting a ZeroParamTypeClasses extension
19:59:30 <pejo> Gracenotes, ok, let me know if you get any other answers. :-)
19:59:33 <ddarius> rwbarton: They may come when a clear idea and consensus is formed on a new module system.
19:59:54 <Gracenotes> pejo: all right... I guess I have to start somewhere, though!
20:01:11 <Axman6> aww, i missed the 1000th package announcment :(
20:01:21 <Twey> I too
20:03:19 * koninkje would much rather see the ability to pass types or functions/values through the module system, than to see ZeroParamTypeClasses
20:03:43 <Twey> Dynamically construct modules?
20:03:55 <pumpkin> darcs is asking me for a patch name, is there a convention? can I use spaces etc.?
20:04:07 <ddarius> koninkje: Simply write a preprocessor that encodes a hybrid of SML's and O'Caml's module system into Haskell type classes.
20:04:16 <koninkje> For certain values of "dynamic" (And actually, just passing Types should be fine. )
20:05:17 <koninkje> ddarius: I was thinking od somewhat different cases, but essentially that, yes.
20:05:21 <koninkje> s/od/of/
20:05:34 <rwbarton> I wish there were a more straightforward alternative to the "implicit configurations" magic
20:06:09 <ddarius> With associated type synonyms, the last somewhat awkward part of the encoding has been dealt with.  It should actually be rather usable directly now.
20:07:00 <rwbarton> You still have to "serialize" your data through polymorphic recursion, right?
20:07:19 <rwbarton> I guess the interface can be made nice though.
20:08:09 <ddarius> mmorrow: Want a big exercise for TH/QuasiQuoting-fu?
20:12:30 <dino-> pumpkin: Yes, you can use spaces. It's the comment for your commit into the darcs repo.
20:12:38 <pumpkin> thanks :)
20:13:20 <dino-> And something that wasn't apparent to me at first, the long comment just drops you into an editor where you see your not-long comment as the first line. But you can edit both of them there.
20:13:36 <pumpkin> ah, cool
20:13:43 <dino-> Don't be afraid, you can also unrecord if mistakes are made.
20:13:51 <dino-> And then record again.
20:14:39 <ddarius> @tell mmorrow Implement some syntax/TH-fu for an ML-like module system using the ideas from http://www.cs.rutgers.edu/~ccshan/xlate/xlate.pdf and http://www.cse.unsw.edu.au/~chak/papers/WC08.html
20:14:40 <lambdabot> Consider it noted.
20:16:34 * ksf likes git
20:18:14 <pumpkin> me too
20:18:19 <ksf> phew.
20:18:28 <blackdog> i like git so much i want to take it out behind the bikesheds and get it pregnant.
20:18:41 <ksf> I thought it was the silence before the flame.
20:19:33 <ksf> anyway, anyone who doesn't agree with linus is an idiot.
20:19:48 <blackdog> ksf: by definition, almost.
20:19:53 <dino-> ksf: No no, no flame. But with git, I was kind of really shocked at the funky twiddling that was required to read-only share a repo, even just with http, not getting the git daemon involved.
20:20:16 <blackdog> dino-: i do all that sort of thing with gitosis
20:20:24 <ksf> that's gotta be a hell of a web server you're using there.
20:20:33 <redditbot> Kinetic OS source (as it stood when development stopped) released
20:20:57 <ksf> @slap redditbot
20:20:58 <lambdabot> I don't perform such side effects on command!
20:21:12 <ksf> how many times have to tell him he should post the url alongside?
20:21:17 <pumpkin> yay
20:21:20 <pumpkin> I submitted a patch!
20:21:28 * pumpkin jumps around
20:21:36 <SamB> ksf: well, the one in #lhc-compiler gives the URLs now ...
20:21:41 <rwbarton> ksf: I've even sent a patch.  It was one line, I sent it over IRC :)
20:24:08 <ozy`> guise
20:24:18 <ozy`> we should drop copies of RWH on India
20:25:25 <Axman6> pumpkin: uvector?
20:25:25 <cjb> we could ship it with the OLPC :)
20:25:28 <pumpkin> Axman6: yup!
20:25:31 <Axman6> nice :)
20:25:33 <pumpkin> Axman6: I love that package
20:25:43 <gwern> we could drop copies of Kernighan & Ritchie over North Korea
20:26:10 <MyCatVerbs> We could drop copies of K&R on top of small children.
20:26:19 <Axman6> i'm in the process of writing a hopefully useful piece of code, an extension to Markdown that pipes the text through hscolor -lit -css first
20:26:22 <MyCatVerbs> It'd be harmless too. Damn but that book's thin.
20:26:35 <pumpkin> Axman6: did you ever figure out your STUArray problem?
20:26:35 <gwern> MyCatVerbs: oh well as long as we aren't dropping it *on* them that's fine
20:26:42 <pumpkin> Axman6: you could try rewriting it with UArrs :D
20:26:51 <dolio> I don't know about that. If you catch a corner of that thing, it could do some damage.
20:26:55 <gwern> Axman6: markdown is a format i thought
20:26:56 <Axman6> nah, waiting until dons can take a look at it
20:26:57 <ozy`> http://code.scrapcrap.org/books-beer <-- the India thing
20:27:01 <MyCatVerbs> dolio: the paperback version, for safety's sake.
20:27:11 <Axman6> gwern: i know, this is a movable type plugin though
20:27:21 <dolio> That's the only version I've ever seen.
20:27:34 <dolio> It's still like 3/4 of an inch thick.
20:27:48 <stu8ball> cjb: Ship what with OLPC? RWH?
20:29:54 <Axman6> whoops.. heh... tried to use my plugin before i had hdcolor installed >_<
20:29:58 <Axman6> hscolor*
20:30:11 <ozy`> *HsColour
20:30:16 <pumpkin> phail
20:30:43 <Axman6> forgot how long it'd take to get ghc and all of hscolor's deps installed
20:30:57 <Axman6> ah good, it's just started compiling hscolor
20:32:17 <BMeph> Has someone made a plugin yet that lets lambdabot tell intransigent C/C++ fanboys, "you're doing it wrong"? ;)
20:33:05 <koninkje> dons: I think your feed for Arch Haskell is broken. It updates all the most recent N entries, which makes Planet Haskell reprint all of them
20:33:08 <Axman6> @quote doing it wrong
20:33:08 <lambdabot> No quotes for this person. :(
20:33:10 <Axman6> :(
20:33:16 <Axman6> @quote wrong
20:33:16 <lambdabot> qwe1234 says: just because it's inflammatory doesn't mean it's wrong
20:33:18 <dolio> @quote doing.it.wrong
20:33:19 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
20:33:23 <Axman6> @quote wrong
20:33:24 <lambdabot> newsham says: irc bots executing external programs..  always a good idea! what could possibly go wrong?
20:33:29 <Axman6> @quote wrong
20:33:30 <lambdabot> qwe1234 says: just because it's inflammatory doesn't mean it's wrong
20:33:54 <roconnor> @keal
20:33:55 <lambdabot> i need math friendly compiler to compile for jvm or flash
20:34:18 <pumpkin> I have an irc alias that lets me do /wrong
20:34:19 <pumpkin> maybe http://is.gd/Gf7 ?
20:34:23 <dolio> Yes. I've been looking for a way to turn my math into flash.
20:34:24 <pumpkin> (outputs the above)
20:34:33 <Olathe> @quote doing
20:34:34 <lambdabot> SyntaxNinja says: You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean
20:34:34 <lambdabot> I'll keep doing what I'm doing." ;)
20:34:40 <pumpkin> @quote wango
20:34:40 <lambdabot> wango says: do you like turing complete?
20:34:50 <stu8ball> > it
20:34:51 <lambdabot>   Not in scope: `it'
20:35:13 <Axman6> anyone else see Adobe using LLVM to turn the C version of Doom into flash, and getting it to run as a pretty decent speed?
20:35:48 <stu8ball> Someone I know was compiling Doom for Flash not too long ago.
20:35:59 <stu8ball> Don't know if he properly finished.
20:36:27 <doublec> Axman6, http://labs.adobe.com/wiki/index.php/Alchemy
20:36:34 <doublec> That's Adobe's C/C++ to flash compiler
20:36:34 <stu8ball> Yeah, that.
20:36:56 <Axman6> yep, that's the one
20:39:16 <roconnor> > round 0.5
20:39:18 <lambdabot>   0
20:39:19 <mjb> I believe Google has something similar where they compiled Quake into whatever their product is called.
20:39:21 <roconnor> > round 1.5
20:39:23 <lambdabot>   2
20:39:27 <roconnor> , round 0.5
20:39:28 <lunabot>  0
20:39:33 <roconnor> , round 1.5
20:39:34 <lunabot>  2
20:39:57 <roconnor> @src Float round
20:39:58 <lambdabot> Source not found.
20:40:01 <rwbarton> A JavaScript backend for LLVM could be pretty cool.
20:40:04 <roconnor> @src round Float
20:40:05 <lambdabot> Source not found. Just try something else.
20:40:09 <stu8ball> The sexiest Quake spinoff I have ever heard of was this augmented reality version using GPS and radio triangulation and shit.
20:40:13 <stu8ball> Fucking win.
20:40:24 <stu8ball> And head-mounted displays.
20:40:27 <ksf> @quote Right Thing
20:40:27 <lambdabot> No quotes for this person.
20:40:40 <ksf> yeah, she dosn't know anything about it.
20:41:06 <te> my name is Akmar and i am 7 yrs old and dad tied me in the basement and tell me to have all dos game by 7 o clock or i get no food plz help
20:41:55 <Axman6> hmmmm.... i could be wrong, but it seems like my freebsd machine managed to compile haskell... before it'd compiled ghc
20:42:28 <SamB> it's hard to compile GHC without GHC ;-P
20:42:36 <roconnor> te: how much do you know about monads?
20:43:25 <te> roconnor: not enough
20:43:25 <MyCatVerbs> SamB: I can compile GHC from x86 Linux ELF to x86 Linux ELF using the universal compiler known as "cat". :)
20:43:38 <pumpkin> MyCatVerbs: wow, l33t
20:43:55 <ddarius> te: Well you can not eat for greater than a month assuming you're not already starving, so you have some time.
20:44:02 <roconnor> te: how about coproducts and initial algebras?
20:44:11 <MyCatVerbs> pumpkin: my favourite thing about (\x -> x) is the sheer polymorphism of it.
20:44:16 <te> roconnor: why? ddarius: haha
20:44:20 <pumpkin> MyCatVerbs: it's amazing
20:44:57 <Axman6> MyCatVerbs: you should start all function definitions with .. = (\x -> x) $ ..
20:45:04 <roconnor> te: you need to learn about monads, coproducts, initial algebras, directed complete partial orders, and zygohistomorphic prepromorphisms before you can start learning Haskell.
20:45:05 <pumpkin> that's a great idea
20:45:09 <Axman6> just to prove how awesome it is
20:45:27 <pumpkin> let's call it IPS, identity-prefixed style
20:45:50 <Axman6> "commonly used to assist in proof testing"
20:45:54 <ddarius> :t id :: forall a. a
20:45:55 <lambdabot>     Couldn't match expected type `a1' against inferred type `a -> a'
20:45:55 <lambdabot>       `a1' is a rigid type variable bound by
20:45:55 <lambdabot>            the polymorphic type `forall a1. a1' at <interactive>:1:0
20:46:03 <ddarius> :t id :: forall a. a -> a
20:46:04 <lambdabot> forall a. a -> a
20:46:06 <te> roconnor: why are you telling me this?  to sound smart?  to use those terms in conversation?
20:46:10 <ddarius> :t fix id :: forall a. a -> a
20:46:11 <lambdabot> forall a. a -> a
20:46:14 <ddarius> :t fix id :: forall a. a
20:46:15 <lambdabot> forall a. a
20:46:22 <Axman6> > fix id 1
20:46:23 <lambdabot>   * Exception: stack overflow
20:46:29 <Axman6> that was quick :|
20:46:37 <pumpkin> te: it's actually pretty common to hear stuff worse than that in this channel, but he was just trying to scare you off I guess :P
20:46:49 <pumpkin> "worse"
20:46:55 <pumpkin> = more esoteric-sounding
20:47:35 <Axman6> probably insanely useful too
20:47:43 <stu8ball> "Help! I'm a PhD in CS and I can't understand monads!" is a common one in here I think.
20:47:48 <ddarius> Axman6: Not really.  At least not for Haskell.
20:47:53 <te> stu8ball: haha, really?
20:47:58 <stu8ball> kinda
20:48:02 <Axman6> haha
20:48:16 <pumpkin> stu8ball: how many people advertise their PhDs in here? I haven't seen much
20:48:23 <stu8ball> dunno
20:48:23 <pumpkin> :P
20:48:26 <ksf> eitherE is not operationally comutative
20:48:35 <Axman6> monads aren;t that hard. i don't think i fully understand them, but once you get used to using them, they're ok
20:48:40 <ddarius> pumpkin: If we wanted to be esoteric we'd be talking about zero hand grenades.
20:49:14 <stu8ball> What about second-hand grenades?
20:49:15 <te> understanding enough to explain them out loud has been harder than anything else
20:49:36 <te> i find explaining what Haskell is and how it works to be pretty difficult to people who aren't as interested in programming as me
20:50:04 <crutcher> How far off is 6.10.2?
20:50:11 <te> all of the terminology requires explanation, just the basic idea of a functional language leaves most people pretty confused
20:50:15 * ksf hopes it's around the corner
20:50:45 <bigorilla> did anyone ever program a network game in haskell?
20:51:02 <crutcher> I'm doing the parallel tutorial, and the bugs in 6.10.1 are driving me nuts. I guess I could compile/install HEAD, but on a mac that sounds like a bag of no-fun
20:51:02 <pumpkin> te: you aren't really 7, are you :(
20:52:27 <kbateman> Haskellers tend to jump straight to the abstraction
20:52:38 <pejo> te, I agree that Haskell is very hard, but surely working programmers are aware of recursion and such things?
20:53:09 --- mode: shapr set -o shapr
20:53:10 <stu8ball> Dunno. Is the 'Frag' game a network game?
20:53:32 <te> pumpkin: of course not, i just thought it was funny
20:53:36 <pumpkin> :'(
20:53:37 <ddarius> All you have to do is say, "You know that language you program in?  Remove assignment and IO and now you have a functional language."
20:53:45 <pejo> crutcher, I can't speak for the current state of HEAD but I haven't had any problems building it when it's not broken, it just takes a lot of time.
20:53:55 <bigorilla> stu8ball: thanks. I'll look into that. I'm missing a function to see if there's data on my socket..
20:53:56 <ksf> ...at which point people will think you're describing html.
20:54:00 <ddarius> (and continuations if the language has them, and exceptions for that matter)
20:54:12 <te> pejo: of course they're aware of recursion, but demonstrating that sort of thing is difficult out loud
20:54:28 <te> ddarius: sure, but for most working programmers, that is an impossible idea
20:54:43 <crutcher> something I'd really like to be able to say, but haven't figgured out yet:  parMap :: Int -> (a -> b) -> [a] -> [b]  such that for some integer k values, the values will be sparked in parallel ahead of their usage.
20:54:51 <shapr> te: I think most programmers don't think about programming from that direction, and that's one reason Haskell would help them so much!
20:54:52 <ksf> there's gotta be some way of directly injecting the benefits of pure first-order functions into brains.
20:55:05 <shapr> ksf: ICFP contest?
20:55:06 <ksf> ...or there can't be, because it's a side-effect.
20:55:09 <shapr> hah
20:55:22 <ddarius> ksf: Single Assignment C
20:55:24 <crutcher> I don't want to spark an entire list's computation (because it might be infinite), but I'd like to do some (tunable) amount of prior work in parallel
20:56:29 <crutcher> maybe if I played with zip and drop, I could build up pairs of (value, future value) and do par or pseq on them.
20:56:37 <crutcher> I think that might work, actually.
20:57:11 <ddarius> crutcher: Just use a "chunk" function and concat . map (parMap f)
20:57:26 <gwern> ksf: well, the injection would be monadic; the info could be pure as ever
20:57:42 <gwern> you'd be lifting the brain's intellectual level, as 'twere
20:58:16 <pumpkin> crutcher: there's also a chunking parallel strategy
20:58:58 <crutcher> that's an interesting idea. But I'm pretty sure I can make this work.
20:59:05 <chessguy> sweet, thinking of forward-chaining inference as a fold cut my code in half :)
20:59:06 * ksf wants cummutative monoids.
20:59:14 * chessguy <3 haskell
20:59:41 <crutcher> one thing that gets to me about haskell is sometimes I get really tired of feeling stupid.
20:59:51 * ksf wants mappend to be commutative, to be precise.
20:59:52 <pumpkin> crutcher: parListChunk n for example, then you can just call parMap
21:00:03 <nolrai_East> @pl \x -> owner x == player
21:00:04 <lambdabot> (player ==) . owner
21:00:13 <chessguy> crutcher:  haha. just means you just gotta push yourself a little more
21:00:13 <nolrai_East> duh
21:00:39 <crutcher> chessguy: I'm pretty sure there's no bottom
21:00:46 <te> crutcher: haha, feeling stupid means you're learning
21:00:52 <crutcher> pumpkin: thanks.
21:01:03 <chessguy> crutcher: you never know....:)
21:01:07 <chessguy> @quote bottom
21:01:07 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
21:01:10 <pumpkin> there's definitely no cake
21:01:27 * chessguy dangles the carrot a little closer to crutcher's nose
21:01:45 * BMeph is patiently waiting for Cale to re-define commutative operators by using lub... ;)
21:02:58 * ksf also accepts hints on how to get eitherE to not ignore occurences of its second argument
21:03:03 <BMeph> I wonder: is there a "If programming languages were Rubik's Cube solutions"-type web site out there? :)
21:03:19 <shapr> Never give up, never surrender!
21:03:24 <pumpkin> @hoogle eitherE
21:03:25 <lambdabot> No results found
21:03:32 <shapr> crutcher: C'mon, in Haskell you get to talk about booty calls all the time!
21:03:47 <ksf> http://hackage.haskell.org/packages/archive/reactive/0.10.5/doc/html/src/FRP-Reactive-Reactive.html#eitherE
21:03:49 <MyCatVerbs> BMeph: I want the "bleach all the stickers so the whole thing comes out solid white" option. What language would that be?
21:04:08 <crutcher> shapr: I don't get the reference
21:04:11 <blackdog> hey, anyone around who can give me an account on hackage? I have version 0.01 of a new project to commit
21:04:23 <pumpkin> Axman6 is on fire!
21:04:38 <ksf> I even tried fmap (const ()) bE `mappend` fmap (const ()) sE
21:04:45 <ksf> ...although I know it can't help.
21:04:46 <crutcher> don't get me wrong, I'm sold on haskell. I want to do something absolutely crazy with it, but I've got years of grunt work before I can even try.
21:04:57 <ksf> ...as I never use the values.
21:05:05 <pumpkin> crutcher: I wouldn't say years
21:05:26 <SamB> crutcher: hey, at least it's grunting because you're getting a headache, rather than because you are bored
21:05:43 <pejo> blackdog, I think you have to mail someone. The procedure is described on hackage somewhere.
21:05:55 <blackdog> pumpkin: well, it could be. not necessarily that you can't be productive and useful reasonably quickly - most other languages you stop learning because you've done all you can except learn new libraries
21:05:55 <crutcher> pumpkin: I want to teach the compiler to implicitly thread checkpoint/recovery code through computations so that we can get reliable computation as efficiently and easily as we currently get parallel computation
21:06:07 <pumpkin> crutcher: check out STM!
21:06:10 <ddarius> blackdog: You email Ross.  There should be a link on the hackage page.
21:06:13 <blackdog> pejo: yeah, i mailed ross
21:06:19 <blackdog> i'm just impatient :)
21:06:33 <olsner> SamB: that is, until you find the fold expression that produces the rest of your life
21:06:33 <ddarius> blackdog: You'll just have to wait.
21:06:35 <crutcher> pumpkin: transactions are not reliable computation. they don't survive machine failure
21:06:42 <pumpkin> ah
21:06:48 <pejo> blackdog, it's 5 am on Sunday for him, you'll have to wait a bit longer. :-)
21:06:55 <pumpkin> they give you two of the ACID letters though :P
21:06:58 <ksf> You can definitely get productive faster in haskell than in c++.
21:07:09 <ksf> (if you are able to grok what you can do with templates, that is)
21:07:11 <crutcher> ah indeed. this is cluster-scale work, working in a causally consistent monad, not in IO.
21:07:14 <BMeph> crutcher: Sounds like you're moving dangerously close to xzibit territory with that project... ;)
21:07:14 <blackdog> pejo: heh. ah well, i'll cope i suppose.
21:07:18 <crutcher> so yeah, I've got some homework to do
21:07:25 <pumpkin> crutcher: yeah, sounds like it :)
21:07:28 <pumpkin> lol
21:07:32 <pumpkin> SUP DAWG
21:08:01 <pumpkin> @seen dons
21:08:01 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1h 53m 23s ago.
21:08:11 <crutcher> thing is, very large numbers of cluster scale batch processes in the real world fail, and the partial work done on them can't be replayed. I'm including mapreduces in this.
21:08:29 <crutcher> anyway, back to the grind.
21:09:54 <crutcher> pumpkin: okay, I've read through the Strategy stuff, and nothing seems to do what I want. The list* strategies either evaluate a fixed portion of the list, or they evaluate all of the list and return.
21:10:17 <pumpkin> crutcher: what do you want out of it again?
21:10:21 <crutcher> I want to lazily evaluate future portions of the list which are within k elements of an element which has already been consumed.
21:10:34 <pumpkin> oh, I misunderstood then :/
21:10:44 <crutcher> but I think I can make it work :)
21:10:47 <pumpkin> yay
21:11:15 <crutcher> and I guess I can try to massage it into its own Strategy
21:11:41 <mmorrow> crutcher: do you mean /strictly/ evaluate future portions .... within k .. ?
21:11:41 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
21:12:05 <crutcher> dammit. again, I feel dumb. its: parBuffer
21:12:18 <crutcher> does exactly what I want.
21:12:23 <crutcher> kahhhhhhhn!
21:12:41 <pumpkin> yay :)
21:13:06 <pumpkin> seems like it's under an odd category in the documentation
21:13:15 <pumpkin> it's in the same group as all the seq* functions
21:13:52 <pejo> pumpkin, one could argue that par and seq are related
21:14:03 <pumpkin> yeah, but there's a par group right above it
21:14:09 <mmorrow> ddarius: interesting
21:15:51 <crutcher> It uses the same approach I wanted to, but much nicer. Rather than building tuples and tearing them apart, it just scans over two offsets in the same list
21:15:56 <crutcher> http://hackage.haskell.org/packages/archive/parallel/1.1.0.0/doc/html/src/Control-Parallel-Strategies.html#parBuffer
21:18:31 <aresnick> Having changed my symlink-bindir variable in .cabal/config, is there anything I need to do to get cabal to pay attention to it?  When I'm installing, it's still putting things in .cabal/bin
21:18:32 <te> what's the simplest way to get the inverse of a rational function in Haskell?
21:19:11 <pumpkin> te: numerical inverse of a Rational?
21:19:16 <pumpkin> or the inverse of the function itself?
21:19:19 <bigorilla> stu8ball: Frag's not a network game..
21:19:21 <Axman6> pumpkin: i'm on fire?
21:19:25 <pumpkin> Axman6: blogwise
21:19:32 <Axman6> i just had a shower... so i hope not :o
21:19:36 <Axman6> :)
21:19:45 <Axman6> this pen, fucking awesome. pity i won
21:19:51 <Axman6> won't be able to use it much :(*
21:20:02 <MyCatVerbs> Secretly, we've replaced Axman6's water supply with methanol. Let's see if he notices...
21:20:26 <hackage> Uploaded to hackage: permutation 0.4.1
21:20:31 <mmorrow> aresnick: where is the symlink to? if a global install is what you want, you can pass cabal the --global flag. if not, i'm not sure if a symlink'll work (it might)
21:21:15 <pumpkin> Axman6: is it a pen 15 ?
21:21:30 <aresnick> mmorrow: Oh, wait!  Do I need a separate directory for cabal installs?  I was just asking it to install in a ~/bin directory
21:21:59 <aresnick> mmorrow: Does cabal look at config every time it runs?
21:22:01 <Axman6> Uploaded to Axmanage: immolationp-0.0.1
21:22:17 <Axman6> -p
21:22:23 <mmorrow> aresnick: hmm, i'm not sure exactly what cabal does with local (to ~) installs
21:22:34 <aresnick> mmorrow: OK
21:22:52 <mmorrow> i always install to a dir in /usr/local/ghc/... (but i build from src)
21:22:53 <pejo> aresnick, are you sure cabal expands ~?
21:23:08 <aresnick> pejo: Nope, but I'm actually using /home/aresnick
21:23:08 <te> pumpkin: im not sure, im just trying to get f^-1(x) where f(x) = 2*x/(x^2+2x-1)
21:23:36 <pumpkin> haskell can't do that automatically for you
21:23:51 <rwbarton> te: there's no easy haskell-specific way to solve polynomial equations, which is what that amounts to
21:23:53 <mmorrow> aresnick: does your symlink include an absolute path or a relative one?
21:24:17 <te> rwbarton: thanks, just curious
21:24:31 <Axman6> te: f' x = f x ^ (-x)?
21:24:33 <aresnick> mmorrow: It's absolute, but it is to an existing directory.  What should symlink-bindir be?  An existing directory?  Or where I want cabal to put a symlinked directory?
21:24:33 <SamB> rwbarton: what about typeclass hax ?
21:25:07 <mmorrow> aresnick: dcoutts probably knows what to do here (i don't :)
21:25:14 <rwbarton> SamB: typeclass hax for solving polynomial equations? that would be ... interesting
21:25:18 <Axman6> oh no! ghc failed to build on freebsd!
21:25:24 <Axman6> from ports no less!
21:25:28 <ozy`> D:
21:25:45 <MyCatVerbs> Axman6: what arch? oO
21:25:50 <Axman6> x86
21:26:03 * Axman6 tries again
21:29:19 <chessguy> err, is this not H98?
21:29:20 <chessguy> instance (Show a) => Show (Sentence a) where
21:29:42 <MyCatVerbs> chessguy: that's in H98, sure.
21:29:50 <ddarius> Unless Sentence is a type synonym.
21:30:07 <chessguy> oh, yeah
21:30:21 <chessguy> bah
21:36:03 <chessguy> hm, there's gotta be a better way to do a show instance for this
21:36:38 <pumpkin> Henning Thielemann likes to put his initials on his package names :P
21:37:01 <ddarius> pumpkin: Need some way to control the namespace
21:37:12 <chessguy> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=922#a922 -- can i get rid of the quotes?
21:37:16 <pumpkin> yeah but with names like supercollider, I doubt he'll have much of a problem
21:37:34 <pumpkin> he should get supercollider compiling in LHC
21:37:57 <SamB> heh
21:38:05 <chessguy> or at least move the !'s inside them
21:38:06 <ddarius> pumpkin: It should be no problem (at least once LHC can compile anything)
21:38:12 <mmorrow> chessguy: i'm guessing s1,s2 :: Sentence String ?
21:38:17 <somnolence> what's the opposite of floor in haskell?
21:38:18 <somnolence> ceil?
21:38:20 <chessguy> ya
21:38:21 <somnolence> > ceil(5)
21:38:22 <lambdabot>   Not in scope: `ceil'
21:38:24 <pumpkin> I look forward to that day :)
21:38:24 <ddarius> ceiling
21:38:24 <mmorrow> Sentence Doc would do it
21:38:25 <Olathe> > ceiling 5
21:38:27 <lambdabot>   5
21:38:27 <somnolence> thanks
21:38:29 <mmorrow> , text "x"
21:38:31 <lunabot>  x
21:38:48 <ddarius> , text "x\y"
21:38:49 <lunabot>  luna: lexical error in string/character literal at character '"'
21:38:51 <ddarius> , text "x\ny"
21:38:52 <lunabot>  x
21:38:52 <lunabot>  y
21:39:19 <mmorrow> , text "\b@bot"
21:39:20 <lunabot>  @bot
21:39:36 <Olathe> , text "@bot"
21:39:38 <lunabot>  @bot
21:39:47 <Olathe> , text "\0@bot"
21:39:48 <lunabot>  @bot
21:39:50 <ddarius> , text "\n\b@bot"
21:39:51 <lunabot>  @bot
21:39:57 <chessguy> bah, screw it, i'll just manually filter out the quotes in my show instance
21:39:58 <Olathe> , text "zomg\n@bot"
21:40:00 <lunabot>  zomg
21:40:00 <lunabot>  @bot
21:40:01 <mmorrow> (in case anyone getting ideas, it strips all ctrl chars)
21:40:10 <Olathe> Heheh
21:40:10 <pumpkin> lol
21:40:12 <mmorrow> (that could be used evilly)
21:40:27 <pumpkin> I still need to recover your passwd file
21:40:30 * pumpkin adds to his todo
21:40:32 <mmorrow> $10 bounty!
21:40:33 <lunabot>  luna: Not in scope: `bounty'
21:40:37 <mmorrow> hah
21:41:14 <mmorrow> ok, the '$' prefix is getting the chop
21:41:18 <pumpkin> aw
21:41:20 <pumpkin> sad :)
21:41:27 <mmorrow> heh
21:41:52 <ddarius> chessguy: Just don't use Term String
21:42:09 <chessguy> ddarius:  got a better suggestion?
21:42:11 <mmorrow> haha, maybe i'll have it always return "bash: <whatever was typed>: command not found"
21:42:26 <mmorrow> that'll mess with heads
21:42:37 <ddarius> chessguy: Term Var where Var is a newtype wrapper around strings that displays without quotes.
21:43:19 <ddarius> # ls
21:43:38 <mmorrow> $ sudo halt
21:43:39 <lunabot>  luna: Not in scope: `sudo'
21:44:55 <Olathe> $ sudo => "Enter password:"
21:44:57 <lunabot>  luna: parse error on input `=>'
21:45:25 <BMeph> $ sudo make me a sandwich
21:45:26 <lunabot>  luna: Not in scope: `sudo'
21:45:36 <BMeph> Schucks. ;)
21:45:38 <Olathe> Enter password:
21:45:48 <mmorrow> maybe if you call it a "sammich"?
21:48:56 <pumpkin> the tag cloud dons submitted to reddit is being downmodded again
21:49:32 <intoverflow> yeah, reddit isn't very web toodotoh friendly
21:49:49 <SamB> toodotoh?
21:50:02 <ddarius> SamB: Look closer.
21:50:05 <intoverflow> 2.0
21:50:20 <SamB> oh
21:51:16 <Lemmih> dons: Yo, can you help me install some Haskell packages with pacman?
21:51:17 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
21:52:02 <rwbarton> Hackage has a "Middleware" category?
21:52:19 <sm> how do I convert a NominalDiffTime to a number so I can divide by 60 ?
21:52:20 <SamB> it's for sandwiches
21:52:23 <rwbarton> I guess anyone can create a category just by uploading a package
21:52:28 <ddarius> rwbarton: Yes.
21:52:40 <dolio> Hackage has whatever categories people put in their .cabal.
21:53:31 * ddarius uploads enterprisehaskellgators
21:55:07 <ksf> wasn's usenet the original 2.0?
21:55:20 <ksf> s/s/t
21:55:41 <ddarius> "watn's usenet the original 2.0?" ?
21:56:01 <ksf> uhmm... what's the regex for "replace second occurence"?
21:56:20 <Olathe> s/s /t
21:56:26 <ksf> a classical case of wishfull parsing.
21:56:53 <ksf> s/l// ;)
21:57:34 <Olathe> s/s\/.*\/.*//
21:58:07 <ksf> that's a classical case for s||
21:58:23 <ksf> (which is perl's killer feature)
21:59:10 <ddarius> ksf: Not (s)ed's?
21:59:29 <johan____> should i use Data.Array or GHC.Array or what? i want mutable i think
21:59:30 <mmorrow> um, does sed do that?
21:59:36 <ksf> (aside from $_ = "foo")
21:59:45 <pumpkin> johan____: use STArray!
21:59:48 <ddarius> mmorrow: Seemingly.
21:59:51 <mmorrow> ong
21:59:53 <mmorrow> pmg
21:59:55 <mmorrow> gah!
21:59:57 <mmorrow> omg
21:59:58 <pumpkin> lol
22:00:08 * mmorrow life just got bettar
22:00:12 <rwbarton> s/.*/omg/
22:00:16 <Olathe> zomg
22:00:27 <Olathe> How did it get butter ?
22:00:30 <johan____> pumpkin: okay, what is that? State Array?
22:00:40 <pumpkin> johan____: yeah, it lives in the ST monad
22:00:47 <mmorrow> sed -r 's|/////////////////||g'
22:01:05 <pumpkin> johan____: which is nice because it means you can be pure to the outside world, yet still have mutable values within your function
22:01:23 <johan____> pumpkin: but i know very little of the state monad.. maybe i should read in RWH
22:01:39 <pumpkin> johan____: it's quite easy to use
22:01:44 <pumpkin> not sure if it's in RWH
22:02:00 <mmorrow> > flip runState 0 (do x <- get; put (x+1); return (show x))
22:02:02 <lambdabot>   ("0",1)
22:02:35 <pumpkin> johan____: but it's not the State monad :) it's ST
22:02:44 <mmorrow> ah
22:02:46 <pumpkin> which is a bit like a restricted IO
22:02:46 <rwbarton> johan____: You shouldn't need to import anything from GHC.*
22:02:48 <johan____> pumpkin: i know very little about monads too :) altough im getting there. im not exactly scared of them anymore :)
22:03:09 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef 99; readSTRef x)
22:03:10 <lunabot>  luna: Couldn't match expected type `GHC.ST.ST s a'
22:03:14 <pumpkin> johan____: some info at http://www.haskell.org/haskellwiki/Arrays#Mutable_arrays_in_ST_monad_.28module_Data.Array.ST.29 (that page also contains other array information if you want)
22:03:17 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef x)
22:03:19 <lunabot>  99
22:03:59 <Olathe> @undo do x <- newSTRef 42; writeSTRef x 99; readSTRef x
22:04:00 <lambdabot> newSTRef 42 >>= \ x -> writeSTRef x 99 >> readSTRef x
22:04:30 <Olathe> @undo do x <- newSTRef 42; writeSTRef x 99; readSTRef x; writeSTRef x 100
22:04:31 <lambdabot> newSTRef 42 >>= \ x -> writeSTRef x 99 >> readSTRef x >> writeSTRef x 100
22:04:47 <pumpkin> @@ @pl @undo do x <- newSTRef 42; writeSTRef x 99; readSTRef x; writeSTRef x 100
22:04:48 <lambdabot>  ap ((>>) . ap ((>>) . flip writeSTRef 99) readSTRef) (flip writeSTRef 100) =<< newSTRef 42
22:04:52 <pumpkin> damn right
22:04:54 <blackdog> hm. can you not declare strict record types?
22:05:02 <johan____> thanks pumpkin
22:05:11 <mmorrow> blackdog: i don't see why not
22:06:47 <blackdog> mmorrow: http://pastebin.com/d6acc15f8
22:06:51 <blackdog> i get a parse error
22:07:14 <mmorrow> ah, put the bangs on the types
22:07:22 <mmorrow> rather than the selector names
22:08:00 <mmorrow> !(Array Word64  a)
22:08:54 <blackdog> ah, right
22:08:55 <blackdog> thanks
22:11:36 <johan____> what is this deal with runST runThis runThat, what does "run" do?
22:12:24 <SamB> we just like to name the functions that run computations like that ...
22:12:32 <mmorrow> for instance, the State type is really a function rather than a value, so runState feeds this funciton you've built up with the initial arg you give
22:12:41 <pumpkin> you can think of the runtime as being runIO
22:12:56 <pumpkin> and your main is just an IO
22:13:18 <mmorrow> newtype State s a = State (s -> (a, s))
22:13:29 <mmorrow> @unmtl State s a
22:13:29 <lambdabot> s -> (a, s)
22:13:35 <mmorrow> @unmtl Cont r a
22:13:35 <lambdabot> (a -> r) -> r
22:13:41 <mmorrow> @unmtl Reader r a
22:13:41 <lambdabot> r -> a
22:13:45 <pumpkin> mtl?
22:14:04 <mmorrow> named after the package
22:14:38 <mmorrow> runState :: (s -> (a,s)) -> s -> (a,s)
22:14:40 <BMeph> Monad: The Language. ;p
22:14:43 <mmorrow> (stripping the newtype)
22:15:05 <mmorrow> so essentially, runState is just ($)
22:15:05 <johan____> hmm, ok
22:15:38 <mmorrow> and the "do" block isn't really /doing/, but is /constructing/ a function
22:16:11 <pumpkin> or a burrito
22:16:24 <mmorrow> por favor!
22:16:29 <joed> I prefer tostadas
22:16:38 <pumpkin> yeah, but we all know that monads are burritos
22:16:46 <ozy`> monads are like burritos... they can have meat -and- vegetables!
22:16:53 <joed> The burrito is a texan thing
22:16:57 <pumpkin> and if you ever find yourself with a double-wrapped burrito
22:17:04 <pumpkin> just call join on it
22:17:19 <joed> Do you want to be texan?
22:17:36 <ozy`> "monad" is an encoded anagram of "texan"
22:17:39 <mmorrow> newtype Burrito a = Burrito (forall m (Monad m) => m a)
22:17:45 * ksf hates it when he knows upstream bugs that concern his code are fixed but not yet pushed and doesn't know where to get the patches
22:18:10 <ozy`> instance (Monad m) => Burrito m
22:18:11 <blackdog> heh, that'll teach me. thought i'd be clever and use a digest of the strings to "optimise" lookup. straight comparison of bytestrings is way faster :)
22:18:14 <ksf> burritos with curry?
22:18:24 <ksf> I think I'll pass.
22:18:29 <pumpkin> curried gonads
22:19:14 <ksf> Premature cleverness is the root of all dumbness :P
22:20:03 <blackdog> ksf: i should have realised, really. a CRC has to look at every byte of the input string anyway - if you're comparing two strings, most of the time you can quit early anyway.
22:20:44 <ksf> well, it depends on how many lookups you do.
22:21:00 <ksf> ...and how similar your strings are.
22:21:09 <blackdog> 16777215
22:21:11 <blackdog> :)
22:21:30 <pumpkin> why not add one to that?
22:21:46 <blackdog> (realistically, i don't need it to be this fast, but given that it does less than wren's bytestring-trie code, it really had better be faster)
22:22:19 <ksf> trie++
22:22:24 <ksf> @karma trie
22:22:25 <lambdabot> trie has a karma of 1
22:23:11 <blackdog> ksf: yeah, it's surprisingly difficult to beat
22:23:38 <ozy`> my brother's cat is a monad
22:24:20 <ksf> how so? lazy?
22:24:33 <ksf> cats++
22:24:37 <ksf> @karma cats
22:24:38 <lambdabot> cats has a karma of 1
22:24:51 <ksf> dogs--
22:24:56 <ksf> @karma dogs
22:24:57 <lambdabot> dogs has a karma of -1
22:25:01 <Gracenotes> hooray cats
22:25:29 <Gracenotes> although I must say, I ran around the house playing with my family's dog earlier today. It was fun. You can't do that with cats.
22:25:49 <ksf> but they can do it with humans.
22:25:52 <ozy`> sure you can
22:25:55 <Gracenotes> she jumped at me and lightly bit my leg
22:26:00 <pumpkin> Gracenotes: CATS?
22:26:07 <pumpkin> somebody set up us the bomb!
22:26:17 <pumpkin> all our base are belong to them :(
22:26:43 <Gracenotes> still, cats are very cute, and much more delicate, and clean, and prettiful, and good to pet.
22:27:20 <joed> And thoroughly annoying, I have 2 cats and a Rottie.
22:28:30 * blackdog is getting frighteningly used to typing 'unsafePerformIO'
22:28:34 <ray> my cat is a monad because it implements bind and return
22:28:43 <Olathe> unsafeFormHabit
22:28:55 <Gracenotes> ray: following the monad laws?
22:29:03 <ray> naturally
22:29:14 * ksf wants to have a cat that can code, too.
22:29:16 <ray> (that was meant as a pun)
22:29:40 <Gracenotes> binding your cat to another cat binding must be the same as binding a your cat in a cat binding to a third cat
22:29:45 <mmorrow> ksf: i maid u a test case, but i eated it?
22:30:52 <Olathe> return :: Food -> Cat Poop
22:31:05 <te> haha
22:31:14 <te> return :: Cat -> Food
22:31:21 <Olathe> Eww
22:31:21 <joed> THat is a mysterious return thogh
22:31:24 * te starts the oven
22:31:48 <Olathe> return :: Fish -> Cat Food
22:32:04 <Olathe> Or, even better: Fish -> Cat Fish
22:32:08 <te> I used to joke with folks when I adopted a kitten -- I'd tell them I was only fattening it up to eat it
22:32:30 <nodogbite> te: ha
22:32:32 <Gracenotes> remember, though, it has to be a Monad m. What's m in this case?
22:32:32 <te> I got some interesting looks
22:32:33 <wchogg> That's ridiculous.  They're better lean.
22:32:40 <te> lol touche
22:32:44 <te> I know that /now/!
22:32:54 <ksf> Cats have a lazy monomorphism restriction wrt. mating.
22:33:18 <te> All this talk of cats is making me hungry -- I think I have one in the freezer
22:33:24 <te> I nice short-haired domestic
22:33:25 <te> A*
22:33:57 <nodogbite> te: whats all this cat talk
22:35:23 <BMeph> Haskell: Telling the C/C++/Java Community "UR DOIN IT RONG", since 1989. ;)
22:37:00 <te> lol
22:38:34 <Gracenotes> perhaps -- Functor Cat is Watching You Morph Cats
22:39:01 <nodogbite> all your base are belong to us
22:39:28 <mmorrow> preflex: seen Saizan
22:39:29 <preflex>  Saizan was last seen on #haskell 8 hours, 32 minutes and 24 seconds ago, saying: http://haskell.org/pipermail/haskell/2005-May/015815.html
22:53:23 <pumpkin> anyone know some good efficient algorithms for computing skewness and kurtosis?
23:03:39 <ksf> does anyone know how to tell ghc during compile-time to use something different than .ghc?
23:05:35 <jeffz`> guiltily, I sometimes mv .ghc .ghc-foo
23:09:48 <ksf> actually, it shouldn't be needed, as it's a different version.
23:11:42 <bos> pumpkin: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Va._Higher-order_statistics
23:12:26 <pumpkin> thanks :)
23:28:49 <oss> Is there any field use Haskell? I'm going to find some examples.
23:30:06 <pumpkin> ?
23:30:26 <pumpkin> many people from different fields use haskell
23:30:46 <oss> Could you show me some sites? Or show me some examples?
23:30:59 <pumpkin> of what?
23:32:07 <canadaduane> I think s/he means "Instead of using enterprise java, we implemented the system in Haskell"
23:32:16 <canadaduane> something big and critical that has to do with business, perhaps :)
23:32:33 <kiris> coi
23:32:33 <vegai> I'm trying, I'm trying
23:32:52 <ozy`> Lawnmower Man Ltd. or whatever it was
23:32:55 <oss> haha, I'm a HPC maintainer. Always use perl, I know perl6 will be written by haskell.
23:32:56 <ozy`> they use haskell
23:33:15 <canadaduane> interesting
23:33:19 <canadaduane> lawnmower man, eh?
23:33:50 <sm> http://www.haskell.org/haskellwiki/Haskell_in_industry
23:33:56 <canadaduane> ah, cool
23:34:00 <kiris> u'i
23:34:03 <kiris> woops
23:34:14 <ozy`> http://www.hustlerturf.com/ <== these dudes
23:34:21 <sm> ¬¨http://donsbot.wordpress.com/2009/01/24/what-is-haskell-good-for/
23:34:28 <kiris> I was about to say "oops I nearly spoke lojban then", in lojban ~_>
23:35:02 <canadaduane> lol, hustleturf... I like it
23:35:28 <sm> woah.. how does a zero-turn mower get lawn mown ? unless it's very thin ?
23:47:35 <erikc> o snap, xah lee swings
23:47:38 <kiris> ?type loeb
23:47:40 <lambdabot> Not in scope: `loeb'
23:47:53 <kiris> is xah lee banned from here?
23:48:35 <kiris> I have a list written on one side of my hand of the channels he isn't banned in
23:53:59 <pumpkin> > unfoldl (\x -> Just (x, x + 1) 0
23:54:00 <lambdabot>   <no location info>: parse error on input `;'
23:54:04 <pumpkin> > unfoldl (\x -> Just (x, x + 1)) 0
23:54:05 <lambdabot>   Not in scope: `unfoldl'
23:54:08 <pumpkin> > unfoldr (\x -> Just (x, x + 1)) 0
23:54:09 <pumpkin> lol
23:54:10 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:59:34 <inv> hi all
23:59:38 <inv> lambdabot: @hpaste2
23:59:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:59:59 <pumpkin> hi
