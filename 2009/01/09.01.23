00:00:03 <mmorrow> yeah, that's true
00:00:11 <Cale> Even with something like scim, they're still too hard to type.
00:00:15 <porges> f ⋅ x = f x
00:00:21 <porges> I've set them up in XCompose
00:00:28 <porges> ⋅ = $
00:00:30 <mmorrow> it's a hard decision, since on the one hand you can't type them directly, but on the other you get so many more syms
00:01:46 <mmorrow> a little utility cli prog that scanned a file and turned multi-char-ascii syms into their (user-configurable) equiv unicode one-char syms would be super handy
00:01:52 <mmorrow> e.g.
00:02:06 <mmorrow> ("->","→")
00:02:08 <mmorrow> etc
00:02:41 <mmorrow> hmm, it might even have to parse the code, so it can replace context-sensitively
00:02:51 <mathijs> one other thing... I read about lazy/strict bytestrings yesterday in BONUS' LYAH. I want to try them to replace normal list-of-chars IO that I use in some programs. The only problem is that the input text can't be treated as Word8 characters, since they are utf-8. Are there any ways to convert a lazy bytestring back to normal text? or would this defeat the purpose of bytestrings altogether?
00:04:02 <mmorrow> mathijs: there's a utf8-string package that may be useful here
00:04:15 <mmorrow> but you want to avoid unpacking a ByteString once you've go tone
00:04:18 <mmorrow> *got one
00:04:58 <mathijs> mmorrow: thanks
00:05:01 <mmorrow> (which unfortunately of course would mean you can't index into it and expect the i'th Word8 to be the i'th utf8 char)
00:05:21 <mmorrow> but efficiency-vs-convenience round 1 million
00:06:46 <porges> there aren't that many use cases for wanting the exact nth char in a string
00:06:48 <dancor> would it be crazy to make a ByteString-like structure of Word32's instead of Word8's where each Word32 is a unicode character
00:07:25 <ksandstr> wouldn't make unicode handling any easier, since combining characters take up multiple codepoints regardless of encoding (afair)
00:07:29 <mmorrow> dancor: no, in fact storable-vector (or storable-something) is essentially that
00:07:35 <mmorrow> (storable-vector on hackage)
00:07:57 <mmorrow> but if you had Word32s, you could use utf32
00:08:11 <mmorrow> and wouldn't have to deal with encoding to 8 or 16
00:08:13 <porges> but you still have to deal with combininng codepoints
00:08:27 <mmorrow> (you'd have to decode/encode constantly upon IO though)(
00:08:27 <porges> so you can't !! and expect a character
00:08:35 <mmorrow> ohhh, yeah
00:08:38 <mathijs> mmorrow: mmorrow: isn't there a way to go from bytestring to normal string?
00:08:44 <mmorrow>  /combining/ codepoints
00:08:56 <mmorrow> mathijs: is the ByteString utf8?
00:09:08 <mmorrow> (there are functions for this in utf8-string)
00:09:16 <mathijs> in that case I could combine the lazy 64k-blocks loading of bytestring.lazy and still have indexing
00:09:21 <mmorrow> if it's not utf8, then you can just unpack +
00:09:24 <mathijs> mmorrow: yes it is
00:09:26 <mmorrow> fmap c2w
00:09:30 <mmorrow> err, w2c
00:09:38 <porges> mathijs: then you lose the whole point of using ByteString
00:09:44 <porges> un and re-packing will cost
00:09:49 <mmorrow> yeah, big cost
00:10:10 <mathijs> hmmm ok... so I guess utf8 is just killing performance no matter what.
00:10:23 <therp> I'm really stunned by the amount of blog entries dons produces
00:10:23 <mathijs> but I guess that's the case in any language
00:10:25 <mmorrow> not necessarily if you keep it as a ByteString
00:10:43 <mmorrow> but that may or may not be a pita...
00:11:21 <mathijs> mmorrow: no, I get that, but If I want to index/search/regexp-match in it, I guess strings are better suited?
00:12:15 <porges> there are regex libraries for bytestring now, no?
00:12:31 <mmorrow> hmm, yeah i guess it would depend on the regex lib
00:13:02 <mmorrow> i don't see why a utf8-aware regex lib wouldn't be as efficient as it could be
00:13:36 <mmorrow> i'm not sure about which ones are utf8-aware though
00:13:43 <mathijs> ok, so the big question is... is there a utf8-aware regexp lib that handles bytestrings
00:13:57 <mathijs> well, I'll have a look :)
00:13:59 <mmorrow> yes, that seems like it's the crux
00:15:22 <porges> regex-base depends upon bytestring
00:15:25 <porges> so looks good ;P
00:15:58 <mmorrow> also, i know that pcre-light is fast (dunno about utf8 though)
00:16:03 <Cale> It seems to me that most regex libs are already so inefficient that merely choosing one which didn't use a retarded algorithm would far outweigh the performance cost of having to use String.
00:16:31 <mathijs> and I guess regex-base is retarded?
00:16:51 <Cale> I don't think regex-base on its own provides an implementation, does it?
00:17:54 <mathijs> well if it depends on bytestring... I can combine it with utf8-string right?
00:19:17 <mathijs> maybe I should just order german clients to stop using ü and ß :)
00:19:18 <Cale> utf8-string is mostly about converting ByteString -> String according to utf8, no?
00:20:00 <ivanm> Cale: I thought it was for normal strings as well...
00:20:39 <Cale> ah, it does supply some direct operations stored as bytestrings... You'd probably gain little by not just applying the function to turn it all the way into a String though.
00:20:41 <porges> it goes to and from both
00:20:45 <mathijs> Cale: ah ok... so that's expensive anyway. I get it. So I need a regex lib that doesn't need to use strings for utf8 but uses bytestrings natively
00:20:54 <Cale> mathijs: Well...
00:21:31 <Cale> mathijs: A DFA is always going to eat starting from the beginning of the string.
00:21:49 <Cale> mathijs: So taking its input as a list of Chars is actually probably not that bad.
00:23:48 <mathijs> ok, and will it help to use lazy bytestrings just for IO and have utf8-string convert them to strings on the fly(lazily) for further processing? Or will just using normal string-io be just as efficient? I guess it won't read stuff disk byte-for-byte anyway, since the OS will do the caching?
00:24:44 <Cale> Yeah, that sounds about right.
00:25:05 <Cale> How complicated are the regular expressions anyway?
00:25:19 <Cale> (and how much data are you processing)
00:28:29 <mathijs> Cale: I don't have any concrete numbers, just investigating different aspects of haskell before deciding to use it on any projects. but an example I could think of is processing logfiles. they can become big at times and do contain utf8.
00:28:52 <mathijs> or searching through mbox/Maildir
00:28:57 <mmorrow> well, you'd just need a regex lib that deals with ByteStrings if it's in haskell, and with char* if it's in C (since a ByteString is essentially just a Ptr Word8)
00:29:05 <Cale> yeah... I usually start by implementing something, and then if it's too slow, I'll profile it.
00:30:51 <mathijs> well, I prefer that agile way of developing too. But like I said, I'm just investigating various parts of haskell and learn what problems/fixes might arise in various areas that gave me problems in other languages in the past.
00:31:25 <mathijs> Just to make sure that when I will use it on a real project, I won't find any showstoppers.
00:31:39 <mmorrow> i know that pcre-light takes ByteStrings and (i'm guessing since it's written by one of the ByteString authors) passes the underlying Ptr to C
00:32:00 <mmorrow> which is as efficient as you can do
00:32:09 <mmorrow> (i don't think the ByteString is copied)
00:32:23 <mmorrow> so then it's just a matter of whether libpcre is fast
00:32:35 <mmorrow> and whether it can handle utf8
00:32:36 <mathijs> well that's nice, but does it handle utf8?
00:32:40 <mmorrow> not sure
00:32:45 <mathijs> libpcre does I think
00:32:53 <mmorrow> oh sweet, then you're golden
00:33:51 <mathijs> or maybe it's possible to convert the search pattern (utf8) to bytestring and just search on that. kind of like the other way around.
00:34:15 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light
00:34:35 <mathijs> tnz
00:34:38 <mathijs> tnx
00:35:26 <mmorrow> looks like it does
00:35:27 <mmorrow> utf8 :: PCREOption
00:35:27 <mmorrow> no_utf8_check :: PCREOption
00:36:49 <mathijs> mmorrow: cool, I'll write it down... thats another item on my list to mark as doable-in-haskell :)
00:37:50 <mmorrow> nice! :)
00:38:12 <mathijs> now... only this 'conquer the world' item... :P
00:38:45 <mmorrow> because of haskell's awesome FFI, anything (sensible) that can be done in C cna be done in haskell
00:39:14 <mmorrow> and pretty much anything nonsensible too i guess
00:39:49 <mmorrow> the only thing you couldn't do is things where the garbage collector is just too much overhead
00:39:55 <mmorrow> i guess
00:40:12 <mmorrow> realtime things also are not possible in general with ghc's rts
00:40:34 <mmorrow> but that's not an inherent limitation of /haskell/ per se
00:40:49 <mmorrow> just a particular inplem
00:40:53 <mmorrow> *implem
00:40:55 <mathijs> mmorrow: yeah, but I'm not good at C. I can read it, but that's about all. So it's good to know that in the end, I can drop back to that for performance, but I'd like to be able without dropping to C.
00:41:26 <mmorrow> sure, but the nice thing is that you can utilize any of the countless C libraries without writing one line of C
00:41:44 <mathijs> anyway, I'm mainly a ruby programmer. So haskell will outperform most of my current stuff by far anyway.
00:41:50 <mmorrow> foreign import ccall "malloc" c_malloc :: CSize -> IO (Ptr a)
00:41:56 <mmorrow> boom, you have malloc
00:42:54 <mmorrow> so most FFI bindings aren't necessarily for performance so much as they are to import a library that happens to be in C
00:43:03 <mmorrow> e.g., libpcre
00:43:11 <mmorrow> or sqlite
00:43:12 <mathijs> mmorrow: ok, that's nice indeed. Ruby has something similar (RubyInline) where you can write a function/method in C inline. RubyInline (tries to) take care of any data going from/to ruby.
00:44:20 <mmorrow> haskell only handles the putting-the-args-on-the-C-stack-and-calling-the-func-then-grabbing-the-return-val-from-the-C-stack
00:44:47 <mmorrow> that "only" is all you really need though
00:44:57 <mmorrow> (i'm not sure what exactly Ruby does)
00:45:06 <mathijs> mmorrow: well it sounds great. since there are so many c-libraries out there. in ruby it used to take a little more code to bind to a c library, or I had to use SWIG, which feels dirty.
00:45:23 <mmorrow> heh
00:45:28 <mmorrow> yeah, it's really nice
00:45:38 <mmorrow> the FFI that is
00:46:18 <mathijs> mmorrow: ruby does kind of like the same, but it handles some datatypes (like its strings) automatically. also, since ruby isn't compiled, the rubyinline thing handles the compilation on the fly.
00:46:34 <mmorrow> ah, i see
00:46:35 <mathijs> mmorrow: I guess C++ is more problematic though?
00:46:40 <mmorrow> yeah, way more
00:46:54 <mathijs> name obfuscations
00:47:01 <mmorrow> i've never used the FFI with C++ personally, but i know it's epic
00:47:17 <mathijs> same in ruby. I hate C++ for that.
00:47:46 <mmorrow> heh
00:49:16 <Axman6> C++ doesn;t seem to me like it's groove very well with haskellish things anyway
00:49:18 <mathijs> I've been thinking about doing some stuff on apt (debian's package manager). haskell would be perfect for that because of all the dependencies and nice tree-structures. Thing is that apt's library is c++ :(
00:50:16 <Cale> Interestingly enough though, I had no trouble in a quick test of interfacing Haskell with fortran code using GCC's fortran implementation.
00:51:38 <Axman6> nice
00:52:33 <Axman6> Cale: make a package!
00:52:34 <Cale> of what?
00:52:35 <Cale> It's exactly like interfacing with a C library.
00:52:35 <mathijs> :) anyway, thanks for helping. got to go. byebye
00:52:35 <Axman6> well... don't then, see if i care :P
00:52:35 <Cale> hehe
00:53:06 <Cale> I suppose I could go get a bunch of old fortran number crunching stuff and write bindings around it :)
00:59:10 --- mode: irc.freenode.net set +o ChanServ
01:09:13 <alar> what should I use to convert String<->ByteString? hoogle is cryptic on the topic
01:09:55 <yottis> bytestring.char8
01:10:17 <yottis> it's like bytestring but uses chars instead of word8s
01:10:59 <yottis> Data.ByteString.Char8 i mean
01:11:28 <yottis> and pack + unpack from that module should do the job
01:14:24 <mmorrow> alternatively, you can do
01:14:25 <mmorrow> , (chr . fromIntegral) (0::Word8)
01:14:27 <lunabot>  '\NUL'
01:14:43 <mmorrow> c2w = chr . fromIntegral
01:14:49 <mmorrow> pack = B.pack . fmap c2w
01:14:53 <dcoutts> alar: Data.ByteString.Char8.pack/unpack
01:15:05 <mmorrow> also, there's an optimized c2w/w2c in Data.ByteString.Internal
01:15:39 <mmorrow> oops, i meant
01:15:47 <mmorrow> w2c = chr . fromIntegral
01:15:49 <mmorrow> not c2w
01:16:02 <alar> :t w2c
01:16:03 <lambdabot> Not in scope: `w2c'
01:16:17 <mmorrow> @type chr . fromIntegral :: Word8 -> Char
01:16:18 <lambdabot> Word8 -> Char
01:16:22 <alar> :t Data.ByteString.Internal w2c
01:16:23 <lambdabot>     Not in scope: data constructor `Data.ByteString.Internal'
01:16:23 <lambdabot> Not in scope: `w2c'
01:16:28 <alar> :t Data.ByteString.Internal.w2c
01:16:29 <lambdabot> Word8 -> Char
01:16:34 <mmorrow> @type fromIntegral . ord :: Char -> Word8
01:16:35 <lambdabot> Char -> Word8
01:16:43 <alar> :t Data.ByteString.Internal.c2w
01:16:44 <lambdabot> Char -> Word8
01:16:47 <mmorrow> the ones in Internal are optimized though
01:16:51 <alar> :t ByteString
01:16:52 <lambdabot> Not in scope: data constructor `ByteString'
01:16:54 <mmorrow> and have {-# INLINE #-}
01:17:03 <alar> :t Data.ByteString.ByteString
01:17:03 <mmorrow> @kind ByteString
01:17:05 <lambdabot>     Not in scope: type constructor or class `ByteString'
01:17:05 <lambdabot>     Not in scope: data constructor `Data.ByteString.ByteString'
01:17:06 <quicksilver> and you shouldn't use them.
01:17:13 <mmorrow> quicksilver: why not?
01:17:14 <quicksilver> You should use the Char8 version and pack/unpack.
01:17:17 <alar> quicksilver: why?
01:17:30 <quicksilver> because you're just making life hard for yourself.
01:17:34 <mmorrow> heh
01:17:40 <quicksilver> Use the version of bytestring which is *designed* for easy interoperation with string
01:17:51 <quicksilver> rather than messing around with internal functions which have ugly names :P
01:17:57 <mmorrow> personally i don't like the Char8 versions
01:18:14 <mmorrow> quicksilver: you can alternatively use
01:18:15 <mmorrow> fromIntegral . ord :: Char -> Word8
01:18:22 <mmorrow> chr . fromIntegral :: Word8 -> Char
01:18:26 <alar> what's wrong with name "w2c"?
01:18:37 <mmorrow> (i like it personally :)
01:19:07 <quicksilver> mmorrow: why are you telling me that?
01:19:10 <quicksilver> mmorrow: do you think I don't know?
01:19:13 <quicksilver> ;P
01:19:32 <mmorrow> quicksilver: you said "rather that messing around with internal functions"
01:19:42 <mmorrow> :)
01:19:51 <alar> I wouldn't touch ByteString if not the need for charset conversions
01:19:59 <quicksilver> I am perfectly well aware of how to convert between data types, thanks. I'm just suggesting that the best answer to alar's question "what should I use to convert String<->ByteString?" is "use the Char8 version of ByteString and pack/unpack"
01:20:18 <mmorrow> quicksilver: heh, ok.
01:20:26 <quicksilver> well the simplest answer.
01:20:35 <quicksilver> If you need more than ASCII then you'll need an encoding library.
01:20:40 <alar> yes
01:20:50 <alar> and encoding library needs ByteString
01:22:26 <quicksilver> probably with a good encoding liibrary you never convert between String and ByteString yourself - you use the encoding libraries fnctions to do that.
01:22:34 <mmorrow> quicksilver: have you done anything else with that javascript stuff? (also, could you re-link me)
01:23:25 <quicksilver> such as fromString/toString (Data.ByteString.UTF8)
01:23:35 <quicksilver> mmorrow: no, I'm better at starting projects than finishing them :P
01:23:42 <mmorrow> quicksilver: why I don't like .Char8 is because Chars in haskell aren't 8bits, and Word8 (although it's actually not) _is_ 8bits
01:23:56 <mmorrow> quicksilver: heh, me too
01:24:00 <quicksilver> well that's why it's called Char8 not Char ;)
01:24:11 <mmorrow> but there is no Char8! :)
01:24:15 <alar> quicksilver: what if I use other locale?
01:24:19 <quicksilver> I agree it's a bit ugly, but as long as you understand what it does, it's simple.
01:24:27 <quicksilver> alar: then you use a different encoding library
01:24:38 <mmorrow> quicksilver: is that js stuff still online though?
01:24:57 <quicksilver> alar: "iconv" or "encoding", perhaps
01:26:30 <alar> here: http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html is said that every library uses ByteString
01:26:58 <alar> therefore I need to either to ByteString IO or DYteString<->String conversion
01:27:09 <alar> or both
01:28:41 <porges>  there are both
01:30:33 <quicksilver> alar: yes you use ByteString IO
01:30:46 <quicksilver> alar: converting a ByteString to a String before IOing it would be perverse.
01:31:13 <alar> then my next question: how ByteString IO is done?
01:31:36 <quicksilver> hPut :: Handle -> ByteString -> IO ()
01:31:41 * alar suspects that ByteString IO might be somewhat faster than String IO
01:31:52 <quicksilver> hGet :: Handle -> Int -> IO ByteString
01:31:56 <alar> @index hPut
01:31:56 <lambdabot> bzzt
01:31:59 <RayNbow> http://obfuscatedcode.wordpress.com/2008/02/16/functional-pearl-trees/ <-- this is the 2nd time I encounter this example... and it still amazes me :)
01:32:04 <quicksilver> and other functions, found at the bottom of http://www.haskell.org/ghc/dist/current/docs/libraries/bytestring/Data-ByteString.html
01:32:14 <alar> thanks!
01:32:22 <alar> @karma+ quicksilver
01:32:22 <lambdabot> quicksilver's karma raised to 6.
01:33:03 <porges> you probably want the lazy versions if you want to use them like the usual haskell functions
01:33:13 <luqui> RayNbow, that's simulating an attribute grammar using lots of parameter passing
01:33:31 <RayNbow> with lambdabot's chronic amnesia, we could have a monthly karma ladder :p
01:33:36 <quicksilver> "It?s nice to see my 25 year old example showing up again" -- augustss
01:33:53 <luqui> RayNbow, you might also be amazed that attribute grammars are the same as CoKleisli arrows over a zipper
01:33:54 <quicksilver> that's interesting. I thought this example was attributed to Bird.
01:34:00 <quicksilver> Maybe Bird stole it from augustss.
01:34:09 <luqui> i.e. UUAG isn't really necessary =P
01:34:09 <alar> oh, and function names coincide with prelude. It simplifies memorizing them and demands careful import specificatrion
01:34:21 <RayNbow> quicksilver: if it's 25 years old... it's older than me :p
01:34:23 <quicksilver> alar: yes, true on both counts.
01:34:38 <RayNbow> luqui: UU?
01:34:53 <luqui> University of Utrecht
01:35:03 <luqui> UUAG is an attribute grammar preprocessor for haskell
01:35:10 <RayNbow> ah
01:35:54 * RayNbow didn't expect UU to show up as part of other abbrevs :p
01:38:34 <luqui> type Sin = IO ; repent = unsafePerformIO
01:39:03 <Axman6> isn't that worse because you'rew hiding the sin?
01:39:25 <luqui> I think the sin should be hidden
01:39:34 <quicksilver> donateMoneyToChurch = unsafePerformIO
01:39:52 <luqui> ideally everything is purely functional.  you sin when you need an RTS extension.
01:40:06 * luqui keeps reading it as 'sine'
01:40:09 <mmorrow> garbage collection?
01:40:47 <multiholle> i'm using eclipse. trying to put a module in a subdirectory fails, because ghc won't find the import like 'Game.Common'.
01:41:03 <mmorrow> what's the module's name?
01:41:20 <multiholle> the name of the module is Common
01:41:28 <mmorrow> it needs to be Game.Common
01:41:45 <multiholle> sorry :) it is Game.Common
01:41:57 <multiholle> using ghc without eclipse works.
01:42:03 <mmorrow> what dir is your pwd when you're building?
01:42:14 <quicksilver> eclipse needs to have the correct root directory of the project
01:42:22 <mmorrow> (it needs to be  Game/..)
01:42:27 <multiholle> how du i get the pwd?
01:42:31 <quicksilver> from which "Main" (e.g.) is in Main.hs and "Game.Common" is Game/Common.hs
01:42:34 <mmorrow> dunno, don't use eclipse
01:42:42 <mmorrow> *i don't use eclipse
01:42:43 <quicksilver> unfortunately I don't know anyone who uses eclipse for haskell.
01:43:06 <quicksilver> I imagine it's in something called project settings or project preferences or project info or someting ;)
01:43:11 <multiholle> quicksilver: what's a good enviroment for programming haskell?
01:43:18 <quicksilver> in my opinion, emacs.
01:43:22 <mmorrow> vim, emacs + bash
01:43:23 <quicksilver> (and ghci)
01:43:37 <sjanssen> this trick never gets old, no matter how many times you see it http://obfuscatedcode.wordpress.com/2008/02/16/functional-pearl-trees/
01:44:33 <quicksilver> sjanssen: augustss claims credit at the bottom but I'm curious, I'm sure I've seen that example attributed to Bird.
01:44:36 <mmorrow> the breadt-first-numbering version of that idea is equally as amusing http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=676
01:44:58 <mmorrow> (that bfn is from the appendix to the okasaki paper)
01:45:21 <mmorrow> i think i supoerficially changed ti though
01:46:36 <mmorrow> ah, i wrapped it so you don't have to provide the initial [Int]
01:46:49 <mmorrow> (and used foldl' instead of explicit recursion)
01:47:01 <mmorrow> although i'm using explicit recursion too..
01:47:49 <mmorrow> that's so cool though. bfn in under 20 lines
01:48:16 <mmorrow> oh, n/m it's wrapped in the okasaki paper as well
01:48:28 <quicksilver> zipwithTF tree [1..]
01:48:42 <quicksilver> it's one line, if your traversable instance for the tree is a breadth-wise one :)
01:48:55 <mmorrow> oh rly
01:49:08 <mmorrow> i'll have to looks at that
01:49:10 <quicksilver> this is not a terrible serious comment.
01:49:15 <quicksilver> it's just pushing the work into the traversable instance.
01:49:25 <mmorrow> ah ok, for a second there i was like whoa
01:49:51 <quicksilver> well actually it's sharing the work out between the implementation of 'zipwithTF' which is itself 10 lines or so
01:49:57 <quicksilver> and the traversabe instance for the tree
01:50:08 <mmorrow> unfoldForestQ in Data.Tree (hidden) uses the okasaki idea
01:50:11 <sjanssen> hmm, zipWithTF?
01:50:24 <sjanssen> quicksilver: just a map under a State Monad?
01:50:28 <mmorrow> (unfoldForestBF* use it, which are exported)
01:50:55 <mmorrow> it would have to be a breadth first mapAccum though
01:51:23 <quicksilver> sjanssen: yes.
01:51:25 <mmorrow> i've tried to write such a thing before and have failed
01:51:32 <mmorrow> i'm interested to see the implem
01:51:44 <sjanssen> mmorrow: well, mapAccum is just mapM where M = State
01:51:48 <quicksilver> http://www.haskell.org/haskellwiki/Foldable_and_Traversable
01:51:54 <mmorrow> sure, but /breadth-first/
01:52:19 <mmorrow> it's easy to write `levels', but not so easy to write mapAccumTBF
01:53:36 <sjanssen> mmorrow: you'd write the mapM method in the Traversable instance in a breadth-first fashion
01:53:57 <sjanssen> quicksilver is cheating :)
01:54:30 <quicksilver> that's what I do best.
01:55:09 <sjanssen> and, of course, you'd use Okasaki's trick to write mapM :)
01:59:22 <mmorrow> oh, and i forget to mention, it has to work on a /Forest/ (although the bfn i linked to doesn't, it could be made to)
01:59:49 * mmorrow is still playing with the code from quickseilver's link
01:59:54 * mmorrow is about to test
02:00:05 <sjanssen> mmorrow: forests are more difficult?
02:00:24 <mmorrow> i guess not actually
02:00:37 <mmorrow> i mean, you need to handle that for the tree case anyways..
02:02:07 <alar> what should I do to embed non-ASCII chars in String constant? Use UTF-8? What decoding does GHC front-end use?
02:02:32 <sjanssen> alar: GHC uses UTF-8
02:02:47 <alar> thanks
02:02:59 * alar goes to test it
02:03:09 <sjanssen> alar: but, the IO functions truncates characters greater than 255
02:03:19 <mmorrow> fail!
02:03:22 <mmorrow> let bfn fs = subForest (zipWithTF (flip const) (Node undefined fs) [(-1::Int)..])
02:03:25 <mmorrow> doesn't work
02:04:05 <alar> sjanssen: if I put String through encoding library, things must become right
02:04:14 <quicksilver> alar: you can use UTF8 directly in source files, with GHC.
02:04:22 <quicksilver> or you can use portable but clumsy string escapes
02:04:29 <mmorrow> the test forest i used (which is actually trivially a forest) is
02:04:32 <quicksilver> > chr 666
02:04:33 <lambdabot>   '\666'
02:04:38 <sjanssen> alar: yeah, if you use the UTF-8 IO stuff or whatnot
02:04:38 <mmorrow> let f0 :: [Int] -> Forest Char; f0 = concat . unfoldForestM_BF (\n -> return $ if n < 4 then (chr (n+1),replicate n (n+1)) else (chr(n+1),[]))
02:04:39 <quicksilver> like that.
02:04:48 <mmorrow> test0 = f0 [1]
02:05:07 * alar wonders how to use string escapes with every non-latin letter
02:06:27 <quicksilver> alar: yeah that would be very ugly. I recommend using GHC's UTF8 source approach ;)
02:06:44 <quicksilver> or keep your non-ascii data in external files, I suppose.
02:06:56 <mmorrow> am i not defining bfn with zipWithTF correctly? or does that way just not work?
02:07:05 * alar is string-escaping vodka and bears
02:07:13 <sjanssen> quicksilver: (where System.IO will totally fail at decoding them)
02:07:21 <mmorrow> i don't see how zipWithTF could actually work for bfn
02:07:27 <scook0> ... strings escape you?
02:07:29 * scook0 ducks
02:07:35 <sjanssen> mmorrow: what does your Traversable instance look like?
02:07:36 <quicksilver> sjanssen: we already had the encoding library discussion with alar before you popped by ;)
02:07:45 <mmorrow> sjanssen: from quicksilver's link
02:07:54 <alar> sjanssen: what's wrong with using encoding library on file being read?
02:08:13 <mmorrow> sjanssen: section 3 in http://www.haskell.org/haskellwiki/Foldable_and_Traversable
02:08:34 <mmorrow> i just noticed there's a version below that, but it looks equivalent
02:08:45 <sjanssen> alar: using the library is okay.  What sucks is that the built-in functions don't work
02:08:56 <sjanssen> mmorrow: I see no Traversable instances in that article
02:09:03 <mmorrow> oh
02:09:20 <mmorrow> sjanssen: what is the Traversable instance for Tree you have in mind
02:09:21 <mmorrow> ?
02:09:24 * quicksilver remains annoyed by whoever wrote that second version
02:09:30 <quicksilver> for their use of the term "makes use of State instead of the self defined Supply monad"
02:09:41 <quicksilver> s/term/phrase/
02:09:44 <mmorrow> heh
02:09:48 <quicksilver> as if that's an *advantage*
02:10:07 <sjanssen> mmorrow: the Traversable instance would visit nodes in breadth-first order, of course :)
02:10:09 * alar thinks that ByteStringIO -> encoding -> read combination would allow keeping sources in any encoding
02:10:21 <mmorrow> sjanssen: if would have to maintain a queue of forests manually to do bfn
02:10:24 <quicksilver> "here is an alternative version of your code which uses entirely Ints instead of self-defined ADTs"
02:10:37 <mmorrow> if it doesn't make use of the recursive knot that the okasaki appendix uses
02:10:42 <sjanssen> mmorrow: nah, I'm sure you can use Okasaki's trick
02:10:51 <quicksilver> oh, it was fons.
02:10:55 * quicksilver throws up his hands in despair.
02:10:56 <mmorrow> oh, well that that's the same thing :)
02:11:05 <mmorrow> *then that's
02:11:31 <sjanssen> quicksilver: is there a really good reason to use Supply rather than State?
02:11:41 <mmorrow> i thought you were saying it was somehow doing it differently in an extremely sneaky way or something
02:11:50 * alar wonders if HTTP library can work with ByteString
02:11:59 <mmorrow> (which is what i've tried to do before and failed)
02:12:20 <mmorrow> use StateCPS!
02:12:23 <quicksilver> sjanssen: just because it has a restricted interface, and that's what I needed.
02:12:24 <Saizan> alar: recent versions do
02:12:31 <alar> cool!
02:12:37 <mmorrow> twice as fast as mtl CPS /and/ unboxed tuple State
02:12:48 <mmorrow> oops s/mtl CPS/mtl State/
02:12:54 <quicksilver> sjanssen: it's not important, but it's nice to use something with the right type.
02:13:13 * mmorrow likes writing his own monads instead of using mtl too
02:13:24 <alar> then I might be able to get non-latin pages using it
02:14:42 <mmorrow> http://moonpatio.com:8080/repos/MISC/state-bench/
02:14:57 <mmorrow> i meant
02:14:58 <mmorrow> http://moonpatio.com/repos/MISC/state-bench/
02:15:05 <mmorrow> err, actually they both work
02:16:08 <mmorrow> dolio has an mtl drop-in clone that uses cps in the implem somewhere
02:16:41 <mmorrow> i have this (didn't bother making any classes nor writing the transformers) http://moonpatio.com/repos/monad-cps/
02:19:24 <tjb> @src replicate
02:19:25 <lambdabot> replicate n x = take n (repeat x)
02:19:55 <tjb> @src repeat
02:19:55 <lambdabot> repeat x = xs where xs = x : xs
02:20:58 <tjb> @src take
02:20:58 <lambdabot> take n _      | n <= 0 =  []
02:20:59 <lambdabot> take _ []              =  []
02:20:59 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
02:22:43 <quicksilver> mmorrow: I find it interesting the way a manual CPS transform speeds up GHC-compiled code.
02:22:49 <quicksilver> mmorrow: do you understand the deep reason for this?
02:23:00 <quicksilver> does it alter strictness or make it easier to infer the correct strictness?
02:23:31 <mmorrow> quicksilver: i think it's because the non-cps version has to unpack the tuple just to repack it again in (>>=)
02:23:47 <quicksilver> so a proper tuple deforester would remove the difference?
02:24:12 <mmorrow> hmm, i'm not sure but that sounds like it might work
02:24:36 <alar> :t pack
02:24:36 <mmorrow> (so would such a tuple deforester deforest the code to essentially the equiv of the cps version?)
02:24:37 <lambdabot> Not in scope: `pack'
02:24:46 <alar> :t Data.ByteString.pack
02:24:47 <lambdabot> [Word8] -> BSC.ByteString
02:25:17 <alar> @hoogle [Char]->[Word8]
02:25:17 <lambdabot> Prelude fail :: Monad m => String -> m a
02:25:17 <lambdabot> Control.Monad fail :: Monad m => String -> m a
02:25:17 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
02:25:33 <alar> @hoogle String->ByteString
02:25:33 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
02:25:33 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
02:25:33 <lambdabot> Prelude read :: Read a => String -> a
02:26:07 <mmorrow> quicksilver: said another way, i think the cps versions are faster because they only deal with functions and (.)/($) in (>>=), whereas the non-cps ones pattern-match on data
02:26:13 <alar> :t Data.ByteString.Char8.unpak
02:26:14 <lambdabot> Not in scope: `Data.ByteString.Char8.unpak'
02:26:17 <alar> :t Data.ByteString.Char8.unpack
02:26:18 <lambdabot> BSC.ByteString -> [Char]
02:26:47 <alar> :t Data.ByteString.Char8.(BSC.ByteString)
02:26:48 <lambdabot> Couldn't find qualified module.
02:26:57 <mmorrow> quicksilver: so i guess a transformation that somehow turns pattern matching/etc into function composition/application or something (i'm not sure if this is what "deforesting" is)
02:26:57 <alar> :t Data.ByteString.Char8.BSC.ByteString
02:26:58 <lambdabot> Couldn't find qualified module.
02:27:21 <mmorrow> quicksilver: that transformation seems like it'd be hard to me though
02:27:37 <mmorrow> it's essentially the same thing that DList does going from (++) to (.)
02:27:48 <mmorrow> (in a sense)
02:30:08 <quicksilver> I'm not sure that deforestation is really the right word.
02:30:19 <quicksilver> but eliminating intermediate tuples, any how.
02:30:37 <quicksilver> in principle it's just, given
02:30:51 <quicksilver> let x = (a,b) in ..... E .....
02:31:00 <quicksilver> replace all instance of 'fst x' with a and 'snd x' with b
02:31:10 <tjb> for haskell style, are functions discouraged to use underscores instead of CamelCase ?
02:31:18 <quicksilver> which should be fine, as long as its all statically visible to the compiler
02:31:25 <tjb> i.e., "my_function" instead of "myFunction"
02:31:25 <Cale> tjb: Most people use camelCase.
02:31:38 <quicksilver> tjb: there isn't a strong convention, but the standard library is mostly CamelCase
02:31:53 <Cale> tjb: Personally, I prefer camelCase to underscores.
02:31:58 <quicksilver> (actually the standard library is mostly one-word functions!)
02:32:09 <quicksilver> I sometimes use underscores for internal functions
02:32:13 <quicksilver> foo = .... foo_aux ....
02:32:14 <tjb> hmm, I'll have to see if my brain adjusts to seeing and using camelCase
02:32:27 <quicksilver> I don't think it is really one of the important things ;)
02:32:43 <tjb> personally I prefer underscores for readability -- but I may just prefer because I've used it for awhile :)
02:33:44 <tjb> ok, well if there isn't too string of an aversion -- I won't fight underscores for much longer :)
02:33:58 <tjb> s/string/strong/
02:34:15 <bastl> hey, is there a pretty printer for complex haskell terms like: http://pastebin.com/m38e7cf5e ? It is an AST and i want to analyse it myself, but reading is very hard ...
02:35:21 <bastl> i want a tree like presentation of the term ...
02:35:35 <quicksilver> there's one GHC uses to format error messages
02:35:45 <quicksilver> btu I'm not sure it's accessible, which is a shame.
02:36:03 <quicksilver> sounds like the kind of thing mmorrow woudl know
02:36:12 <quicksilver> mmorrow: pretty pretty for complex haskell terms?
02:36:16 <mmorrow> heh
02:36:20 <mmorrow> oh
02:36:27 * mmorrow looks
02:36:29 <quicksilver> e.g. bastl's paste
02:36:31 * quicksilver nods
02:36:45 <mmorrow> bastl: yes there is exactly
02:36:49 * mmorrow links
02:37:06 * bastl is once more impressed about the kindness of haskell-folks ... :-)
02:37:21 <Jway> what is the difference between "reverse . filter p" and "reverse filter p"
02:37:26 <mmorrow> bastl: this package http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
02:37:32 <mmorrow> has a function named `pretty'
02:37:43 <mmorrow> which calls `show' on its arg, then
02:37:50 <mmorrow> parses that as a haskell expression
02:37:52 <alar> Jway: type error, probably
02:37:58 <mmorrow> then prettyprints that AST
02:38:05 <mmorrow> to give you pretty show output
02:38:16 <mmorrow> i use it for everything now
02:38:26 <bastl> looks like you wrote it !?
02:38:27 <mmorrow> it's especially nice in combo with HsColour as well
02:38:35 <mmorrow> bastl: heh, yes :)
02:38:46 <bastl> :-)
02:39:04 <mmorrow> that package uses the parser in haskell-src-exts, which is nice
02:39:15 <mmorrow> (that parser is nice)(
02:40:06 <mmorrow> , (text . pretty) (Node 42 [Node 12 []])
02:40:07 <lunabot>  Node{rootLabel = 42,
02:40:07 <lunabot>       subForest = [Node{rootLabel = 12, subForest = []}]}
02:40:19 <mmorrow> , (text . pretty) (Node 42 [Node 12 [], Node 10 []])
02:40:20 <lunabot>  Node{rootLabel = 42,
02:40:20 <lunabot>       subForest =
02:40:20 <lunabot>         [Node{rootLabel = 12, subForest = []},
02:40:36 <bastl> cool. perhaps you can help me with another issue: i tried to install the "hint"  package but failed. you know it?
02:40:53 <mmorrow> i know it, but i'm not familiar with it in particular
02:41:02 <mmorrow> i know some about the ghc-api though
02:41:09 <mmorrow> bastl: what ghc are you using?
02:41:16 <bastl> hm. i had missing dependencies. ghc 6.8.2
02:41:22 <quicksilver> mmorrow++
02:41:22 <bastl> from std ubuntu
02:41:27 <mmorrow> ah. yeah you probably want to install 6.10.1
02:41:31 <bastl> k
02:41:35 <mmorrow> quicksilver: :)
02:41:43 <bastl> thought so. thanks alot
02:41:48 <quicksilver> installing 6.10 is not without its disadvantages
02:41:55 <quicksilver> some libraries are not ported to work with it yet
02:42:33 <Peaker> the LHC compiler compiles to E, the ERights capability language?
02:42:38 <Peaker> or to some other E?
02:42:48 <lilac> the large hadron compiler?
02:42:48 <mmorrow> keeping 6.8.2 around in addition to installing 6.10.1 might be nice
02:43:28 <pozic> Is there a way to read the current log value from a Writer?
02:44:42 <Maddas> GHC is the Giant Hadron Compiler?
02:44:54 <Maddas> (Computer? Collider? Crusher?)
02:46:35 <m3ga> Maddas: (Glorious|Glasgow) Haskell Compiler
02:47:02 <asgaroth> full name is "Glorious Glasgow Haskell Compilation System "
02:49:27 <Saizan> Peaker: another E
02:49:36 <mmorrow> bastl: (that function is in Language.Haskell.Meta.Utils in case it's hard to find)
02:49:58 <Peaker> Saizan: ah, poor choice of a name :)
02:50:26 <Saizan> it's just an internal intermediate language
02:51:07 <bastl> mmorrow: ill install 6.10 later. thanks so long
02:51:14 <mmorrow> so long
02:51:16 <Saizan> it goes Haskell -> E -> GRIN -> C, right now
02:51:21 <fasta> cabal install haskell-src-meta fails here with Could not find module Data.Generics: it was found in multiple packages: base-3.0.3.0 syb
02:52:27 <mmorrow> fasta: if you're trying to use base-3, you'll need to delete "syb" from the import list
02:52:31 <mmorrow> err, sorry
02:52:34 <mmorrow> build-depends:
02:52:47 <mmorrow> i thought i explicitly required base == 4.* though
02:53:09 <mmorrow> fasta: what ghc do you have?
02:53:38 <fasta> mmorrow: I was not asking for some hack to make it work; I don't even use the package. I just wanted to tell you that it didn't work everywhere. :) 6.10.1
02:53:59 <mmorrow> ah, thanks. i'm only supporting base-4.
02:54:00 <alar> Data.Encoding does very strange things
02:54:14 <Saizan_> fasta: did you cabal update recently?
02:54:30 <fasta> Saizan_: yesterday
02:55:21 <fasta> mmorrow: ok, it does work :)
02:55:27 <mmorrow> i don't see how you could be using 6.10.1 and trying to install haskell-src-meta with the .cabal that's in there and get that error msg though, because base-3 should have been excluded since base==4 is explicitly required
02:55:30 <mmorrow> ah, good :)
02:55:40 <mmorrow> oh, yeah i just uploaded that last night
02:57:48 <pozic> Is there a good solution for nested StateT applications?
02:58:21 <hynek> map hi channel
02:58:46 <Saizan_> hi
03:01:25 <pao> pozic: I don't understand exaclty what you mean, but I found helpful avoinding "newtype deriving" on the StateMonad class in order to keep better control of the interfaces
03:04:26 <alar> (decode KOI8R $ encode KOI8R myStr) == myStr
03:04:27 <kapil> is it possible to implement the diagonal enumeration of rationals through a function of type [a]->[b]->[(a,b)]
03:05:09 <alar> but with CP1251 it is True
03:09:06 <mmorrow> kapil: yes
03:10:12 <kapil> perhaps the question should have been "how does one implement it?" rather that "is it possible?" :)
03:11:32 <mmorrow> , let diag [] (xs:xss) = diag [xs] xss; diag ((x:xs):q) ((y:ys):xss) = (x,y) : diag (q++[xs,ys]) xss in diag [] (fmap repeat [1..])
03:11:33 <lunabot>  [(1,2),(1,3),(2,4),(1,5),(3,6),(2,7),(4,8),(1,9),(5,10),(3,11),(6,12),(2,...
03:11:52 <mmorrow> or something like that if that's incorrect
03:12:00 <lilac> > [1..] >>- (\a -> [1..] >>- (\b -> return (a,b)))
03:12:02 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3),(1,6),(3,2),(1...
03:12:02 <mmorrow> but i think that's it
03:12:22 <lilac> > [1..] >>- (\a -> [1..] >>- (\b -> return (a%b)))
03:12:24 <lambdabot>   [1%1,2%1,1%2,3%1,1%3,1%1,1%4,4%1,1%5,2%3,1%6,3%2,1%7,1%2,1%8,5%1,1%9,2%5,1%...
03:12:34 <mmorrow> kapil: lilac is using (>>-) from MonadLogic
03:12:40 <mmorrow> which is from logict
03:12:45 <mmorrow> , '(>>-)
03:12:46 <lunabot>  Control.Monad.Logic.Class.>>-
03:13:19 <mmorrow> hmm, actually i should have do
03:13:20 <mmorrow> ne
03:13:34 <mmorrow> , let diag [] (xs:xss) = diag [xs] xss; diag ((x:xs):q) ((y:ys):xss) = (x,y) : diag (q++[xs,ys]) xss in diag [] (repeat [1..])
03:13:35 <lunabot>  [(1,1),(2,1),(2,1),(3,1),(2,1),(3,1),(2,1),(4,1),(2,1),(3,1),(2,1),(4,1),...
03:13:41 <mmorrow> errm, no
03:13:46 <mmorrow> , let diag [] (xs:xss) = diag [xs] xss; diag ((x:xs):q) ((y:ys):xss) = (x,y) : diag (q++[xs,ys]) xss in diag [] (fmap repeat [1..])
03:13:47 <lunabot>  [(1,2),(1,3),(2,4),(1,5),(3,6),(2,7),(4,8),(1,9),(5,10),(3,11),(6,12),(2,...
03:13:55 <mmorrow> i think that's it
03:14:36 <kapil> thx. let me look at these solutions one by one. slowly, ...
03:15:23 <mmorrow> (also, that `diag' function needs another case if it's not getting an infinite list)
03:15:42 <mmorrow> actually, a few more cases in that case
03:17:56 <mmorrow> augustss: hi. what exactly is that "mcode" used in hbc?
03:18:35 <mmorrow> err, i meant augustss_
03:26:37 <Nafai> I need some advice.  I'm writing a program where the main is essentially "interact myFunction".  But, some of the stuff in myFunction needs the IO monad
03:27:55 <Nafai> How do I handle this?  Obviously, (String -> String) is a pure function
03:28:17 <quicksilver> well, you're probably not going to be using interact any more :)
03:29:20 <alar> :t Data.ByteString.Lazy.Char8.pack
03:29:21 <lambdabot> [Char] -> BSLC.ByteString
03:29:40 <faXx> unsafePerformIO?
03:31:07 <Nafai> quicksilver: Yeah, figured as much :(
03:31:41 <alar> quicksilver: Data.Encoding has a bug in KOI8R, UTF8 is restricted to single charset, therefore I have to use Codec.Text.IConv. And Codec.Text.IConv demands manual conversion String<->ByteString ;)
03:32:04 <alar> so pack/unpack/whatever are inevitable
03:33:12 <mmorrow> yuk
03:34:39 <mmorrow> alar: really? it looks to me like Codec.Text.IConv uses ByteString
03:34:41 <lilac> @src interact
03:34:41 <lambdabot> interact f = do s <- getContents; putStr (f s)
03:34:50 <lilac> Nafai: ^^ that might be helpful to you :)
03:34:55 <alar> yes
03:35:05 <mmorrow> alar: (yes to which? :)
03:35:08 <alar> but my program internally uses String
03:35:13 <mmorrow> ohh, ok
03:35:33 <mmorrow> well, i guess if you're already using String it's not as big of a deal
03:35:56 <mmorrow> in fact, it may even be faster than if IConv took a String as input
03:35:56 <alar> e.g. to hold non-latin string constants
03:36:13 <lilac> Nafai: do you want your function's IO effects to happen interleaved with its output or before its output?
03:36:20 <mmorrow> alar: utf8-string will utf8 encode/decode for you
03:36:36 <mmorrow> (both to/from String or ByteString)
03:37:10 <lilac> Nafai: if you want the effects before any output, then "do s <- getContents; s' <- f s; putStr s'"
03:37:20 <quicksilver> alar: eh?
03:37:25 <alar> mmorrow: do you suggest using utf8-string to perform String<->ByteString conversion?
03:37:40 <quicksilver> alar: surely the ByteString end of Codec.Text.IConv is the encoded end?
03:38:02 * lilac ponders whether "do s <- getContents; s' <- unsafeInterleaveIO (f s); putStr s'" is safe
03:38:06 <alar> quicksilver: Codec.Text.IConv has Byte String on both ends
03:38:28 <quicksilver> oh, I see.
03:38:33 <mmorrow> alar: iyes
03:38:42 <quicksilver> so you use Codec.Text.IConv to go to/from UTF8
03:38:47 <mmorrow> in particular, Data.ByteString.UTF8.fromString :: String -> ByteString
03:38:48 <quicksilver> and the use utf8-string to go to/from String
03:38:49 <quicksilver> I think.
03:38:54 * lilac supposes there is an equivalent formulation using forkIO
03:38:57 <mmorrow> and toString :: ByteString -> String
03:39:01 <alar> thanks!
03:39:06 <mmorrow> :)
03:39:07 <alar> I'll try it
03:39:31 <quicksilver> dcoutts_: why does "iconv" package lack a "decode" or "toString" function?
03:39:54 <mmorrow> ohhh, you were using iconv to go to utf8
03:40:08 <quicksilver> iconv doesn't seem to have a "not-encoded" choice :)
03:40:09 * mmorrow though there was some other encoding here
03:40:14 <dcoutts_> quicksilver: there's no such thing
03:40:14 <mmorrow> *thought
03:40:27 <quicksilver> dcoutts_: sure there is
03:40:29 <dcoutts_> quicksilver: you could convert to UTF32 and then convert into String
03:40:42 <quicksilver> decode :: EncodingName -> ByteString -> String
03:41:01 <quicksilver> dcoutts_: then you still need a function to convert from UTF32 to String.
03:41:11 <quicksilver> seems like a sensible thing to have in the iconv API, to me
03:41:14 <quicksilver> (a way to produce Strings)
03:41:17 <dcoutts_> quicksilver: sure, fine. I'm not sure that belongs in the iconv package
03:41:45 <dcoutts_> iconv is for converting between encodings
03:41:51 * quicksilver nods
03:42:02 <quicksilver> but iconv also has a good list of encodings
03:42:04 <dcoutts_> converting to/from Unicode String perhaps belongs elsewhere
03:42:14 <quicksilver> perhaps, yes
03:42:29 <quicksilver> seems like a natural thing to have in iconv to me :)
03:42:37 <quicksilver> because it's iconv that knows what 'EncodingName' means
03:42:38 <dcoutts_> for example once we've got Data.Text, then converting to/from that is natural
03:43:03 <dcoutts_> quicksilver: yes but it's easy to layer on top by just composing with a UTF32->String or whatever
03:43:11 <asgaroth> Do I have to copy these Applicative instance declaration for parsec to the folder everytime I want to use parsec in an Applicative style as shown in rwh?
03:43:13 <dcoutts_> and you still get to use the encoding name
03:43:47 <dcoutts_> quicksilver: the point is iconve gives you two named end points, you want only one because you want to fix on end point to be Unicode
03:43:56 <dcoutts_> it's less general and so easy to layer on top
03:44:26 <quicksilver> right, but unicode isn't a "encoding"
03:44:36 <hugo___> :D
03:44:38 <dcoutts_> String is not an encoding
03:44:40 <quicksilver> it's the absence of an encoding, really
03:44:41 * quicksilver nods
03:44:44 <quicksilver> exactly.
03:44:58 <quicksilver> I don't want to break abstraction and find out what the internal rep of a Char really is
03:45:00 <dcoutts_> quicksilver: all the things iconv produces are encodings, UTF-8, 16, 32 etc
03:45:07 <quicksilver> I just want way to get Chars out of an iconv encoding.
03:45:25 <dcoutts_> then convert it to a known unicode encoding and then convert to String
03:45:30 * quicksilver nods
03:45:47 <dcoutts_> such a convenience api does not need to expose all the crazy things iconv can do, and can work on top of the Windows equivalent
03:47:35 <alar> *** Exception: Codec.Text.IConv: cannot convert from string encoding "UTF8" to string encoding "KOI8-R"
03:47:40 <alar> =)
03:47:51 * mmorrow just got his "Garbage Collection" and "Linkers & Loaders" books from amazon
03:49:24 <alar> convert "UTF8" "KOI8-R" $ fromString myStr
03:49:36 <alar> what's wrong with it?
03:50:14 <mmorrow> alar: what if the string is "∀∁∂∌∊∆" ?
03:50:42 <alar> mmorrow: myStr is not "∀∁∂∌∊∆" =)
03:51:08 <mmorrow> but i mean that it's probably not possible to encode from utf8 to KOI8-R in the general case
03:51:09 <alar> and my locale wouldn't print "∀∁∂∌∊∆" either
03:51:21 <mmorrow> what is a sample string you're trying to convert?
03:51:26 <mmorrow> , "∀∁∂∌∊∆"
03:51:27 <lunabot>  "\8704\8705\8706\8716\8714\8710"
03:51:31 <mmorrow> , utf8enc "∀∁∂∌∊∆"
03:51:33 <lunabot>  "\226\136\128\226\136\129\226\136\130\226\136\140\226\136\138\226\136\134"
03:52:00 <alar> mmorrow: if I'm not mistaken, iconv decides dynamically whether it can convert the string supplied
03:52:11 <mmorrow> alar: oh, i don't know particulars
03:52:23 <mmorrow> alar: dcoutts_ may know
03:52:40 <lilac> alar: it gives an exception if the conversion fails? that seems rather unfriendly
03:53:01 <Kamina> Hello.. does someone know why not all MonadS are always Applicative functors too?
03:53:10 <pao> while we're on unicode topic... is there a way to "convert" String from a unicode normal form to another?
03:53:12 <dcoutts_> lilac: what would you prefer? silent data loss?
03:53:26 <lilac> dcoutts_: a Maybe return type?
03:53:36 <alar> got it!
03:53:49 <alar> simply encoding name did not match anything
03:54:15 <dcoutts_> lilac: http://hackage.haskell.org/packages/archive/iconv/0.4.0.2/doc/html/Codec-Text-IConv.html
03:54:15 <lilac> Kamina: the Monad typeclass is older than Applicative.
03:54:18 <alar> lilac: if I'm not mistaken, there is a function to test if conversion is possible at all
03:54:27 <pao> Kamina: http://www.haskell.org/haskellwiki/Functor_hierarchy_proposal ... does it helps?
03:54:52 <lilac> dcoutts_: ah, convert's supposed to be productive.
03:55:37 <dcoutts_> lilac: it provides a pretty complete api for handling conversion errors, 'convert' is the convenience api which you use if you want exceptions and a simple api
03:56:17 <dcoutts_> alar: check iconv -l  for the list of encodings that you system supports
03:56:33 <dcoutts_> alar: on my system your example works fine because iconv -l lists both encoding names
03:56:38 <alar> dcoutts: I've already figured this error
03:56:59 <dcoutts_> unforunately the iconv api does not provide a way to list supported encodings
03:57:06 <mmorrow> "UTF8//" ??
03:57:28 <mmorrow> whoa, i didn't know iconv did all of these
03:57:36 <yakov> hey
03:57:37 <alar> =)
03:57:43 <Kamina> lilac, pao: hmmm i see.. that's somehow quite ugly :/
03:57:52 <alar> iconv is pretty powerful
03:58:20 <pao> dcoutts: is there a way to perform unicode normal form conversions with iconv?
03:58:56 <dcoutts_> pao: I'm not sure, it's certainly not specified by the iconv spec
03:58:57 <pao> Kamina: yep... but it rarely bites from a practical point of view (at least for my experience)
03:59:13 <dcoutts_> pao: you'd be better off with a unicode-specific api
03:59:33 <Nafai> How do I express what I'm trying here: http://gist.github.com/50987
03:59:44 <dcoutts_> mmorrow: I'm not sure why iconv -l  lists them with trailing //'s
03:59:45 <Nafai> It's not liking the assignments in the if
04:00:07 <lilac> Kamina: it's easy to define an Applicative instance for a Monad though. "instance Functor M where fmap = liftM; instance Applicative M where pure = return; (<*>) = ap" iirc
04:00:20 <marcot> Good morning.
04:00:22 <pao> dcoutts_: do you know where I can look for it? does there already exist an haskell implementation?
04:00:23 <dcoutts_> mmorrow: '//' is used in gnu iconv as a separator between the name an conversion options
04:00:27 <quicksilver> Nafai: haskell doesn't have assignement statements.
04:00:30 <marcot> Is there a way to simplify enumFrom minBound?
04:00:31 <quicksilver> Nafai: it has definitions.
04:00:36 <Nafai> Blah
04:00:43 <Nafai> Why do simple things keep tripping me up :)
04:00:52 <dcoutts_> pao: try http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unicode-normalization
04:01:02 <Nafai> That's what I get for trying to code when tired :)
04:01:04 <quicksilver> Nafai: try "let itemsToKeep = if count > 0 then blah else blah in deDupItems' items itemsToKeep
04:01:21 <pao> dcoutts_: thanks... sorry... I should have searched myself
04:01:31 <Nafai> quicksilver: Ah, thanks.  That sounds right
04:01:34 <Kamina> lilac: yes, there is also the WrapMonad function
04:01:41 <Kamina> :t WrapMonad
04:01:42 <lambdabot> forall (m :: * -> *) a. m a -> WrappedMonad m a
04:01:44 <lilac> Nafai: let itemsToKeep | count > 0 = keptItems | otherwise = keptItems ++ [item]
04:01:46 <quicksilver> Nafai: or, just add itemsToKeep to your where calses
04:01:52 <quicksilver> (since you aready have a where clause tehre)
04:02:21 <mmorrow> dcoutts: does that mean you include the "//" in the name, or omit it?
04:02:45 <mmorrow> dcoutts_
04:02:47 <dcoutts_> mmorrow: when you use the Haskell iconv api you should omit it.
04:02:51 <mmorrow> cool
04:03:05 <dcoutts_> we use it internally if you use the fuzzy conversion
04:03:26 <mmorrow> hmm, i'll have to read up on iconv. it looks super useful
04:03:54 <Nafai> Frustrating that I still let simple things trip me up
04:04:09 <quicksilver> Nafai: that's OK, it's a learning curve
04:04:16 <dcoutts_> mmorrow: the only downside is it's a bit of a pain on windows. It'll build but the sources are about 1Mb due to all the char tables.
04:04:17 <quicksilver> Nafai: there are two main things in haskell, definitions and expressions.
04:04:28 <quicksilver> Nafai: if x then y else z is an expresson, "foo = bar" is a definition.
04:04:41 <quicksilver> Nafai: the trick is to notice that some are valid in some places and some in others :)
04:05:00 <mmorrow> dcoutts_: i'm glad i rarely have to deal with (building things on) windows
04:06:02 <Nafai> Yes, much cleaner: http://gist.github.com/50987
04:06:48 <quicksilver> Nafai: "where delId = getDeliciousUrlId item" seems a bit redundant to me
04:06:55 <quicksilver> Nafai: why not just inline that since it's only used once
04:07:08 <quicksilver> case getDeliciousUrlId item of -> .....
04:07:26 <Nafai> Probably a good idea, I'm still getting a feel for what needs to be named separately and what not
04:07:38 * quicksilver nods
04:07:52 <quicksilver> overuse of where clauses makes the reader jump backwards and forwards when they're trying to read.
04:09:48 <Nafai> quicksilver: Any other comments, here's the latest http://github.com/Nafai77/recent-feeds/blob/e32ea7770d821f02120fa032983ecb02979bfdb6/recent-feed.hs
04:12:11 <quicksilver> Nafai: looks good.
04:12:18 <quicksilver> Nafai: foo <- return $ bar is a bit odd
04:12:27 <quicksilver> return to put it in the monad and <- to pull it straight out.
04:12:34 <quicksilver> I would normally just say "let foo = bar"
04:12:59 <patmanpato> can i ask a question about compiling a simple prog with ghc ?
04:13:29 <patmanpato> all it is is   main = 1 + 1 , but i get the error:  No instance for (Num (IO a))
04:13:45 <nothingmuch> main needs an IO action
04:13:46 <Nafai> quicksilver: Yeah, I'm forgetting about let.
04:13:53 <nothingmuch> are you trying to print 1 + 1?
04:14:01 <quicksilver> patmanpato: (1+1) is just an expression, rather than a complete program.
04:14:14 <quicksilver> you could do "main = print (1+1)" if you do indeed want to print it.
04:14:26 <patmanpato> ohh, i see, the tutorials ive been reading gloss over this :S
04:14:43 <jrockway> the idea is to learn a bit of the langauge first, in ghci, then worry about making a standalone program
04:14:45 <patmanpato> thanks
04:15:06 <patmanpato> yeah, things are working quite nicely in ghci but i was wondering why the simple things wouldnt compile with ghc :S
04:15:28 <nothingmuch> ghci can evaluate expressions
04:15:34 <nothingmuch> print is implicit
04:16:07 <jrockway> it is not that different from any other programming language, really
04:16:59 <patmanpato> actually, im still a bit lost with this, sorry.... can i compile:   main = do    foo 5 ;  putStrLn "hi" ;   ,  with  foo = 1 + 1   ?  (sorry , not sure how to write it out without indentation here )
04:17:35 <alar> type error, probably
04:17:40 <alar> :t 1+1
04:17:41 <lambdabot> forall t. (Num t) => t
04:17:43 <nothingmuch> patmanpato: no, because 'foo' is still an expression
04:17:56 <alar> :t putStrLn "hi"
04:17:58 <lambdabot> IO ()
04:18:10 <nothingmuch> patmanpato: the do block for 'main' needs to contain IO actions
04:18:41 <Peaker> :t let foo = 1+1 in foo
04:18:42 <lambdabot> forall t. (Num t) => t
04:18:54 <patmanpato> oh, so every expression in the main block needs to be IO ?
04:19:11 <nothingmuch> yes
04:19:18 <nothingmuch> :t print
04:19:19 <lambdabot> forall a. (Show a) => a -> IO ()
04:19:21 <jrockway> sort of
04:19:32 <Peaker> patmanpato: what would you expect a non-IO statement to do in a do block?
04:19:40 <jrockway> do { let foo = 1 + 1; print foo }
04:19:42 <Peaker> patmanpato: (of main)
04:20:22 <nothingmuch> also, in your example foo is of type Int, it can't take an argument (5)
04:21:45 <patmanpato> oh, gotchya, i didnt think of that
04:21:47 <patmanpato> thanks :)
04:22:03 <meta7> newbie: need func: input [[1,2],[3,4], ...], output [[3], [7],...]
04:23:17 <twanvl> > [sum [1,2], sum [3,4], sum [5,6]]
04:23:18 <lambdabot>   [3,7,11]
04:24:24 <Peaker> > map sum [[1,2],[3,4],[5,6]]
04:24:25 <lambdabot>   [3,7,11]
04:25:07 <skorpan> > sum $ map sum [[1,2],[3,4],[5,6]]
04:25:09 <lambdabot>   21
04:25:12 <meta7> without map, sum... ;(
04:25:25 <nothingmuch> meta7: #!/bin/sh
04:26:01 <nothingmuch> why code haskell without using map?
04:26:09 <jrockway> i was just going to say
04:26:17 <jrockway> just explicitly recurse yourself... but why?
04:26:31 <quicksilver> to answer coursework questions
04:26:32 <quicksilver> one imagines.
04:26:51 <quicksilver> normally that's the reason behind a question of the form "How do I do X, without using A, B or C"
04:26:57 <jrockway> yeah, that is my guess too :)
04:27:21 <int-e> > sum $ sum <$> [[1,2],[3,4],[5,6]]
04:27:23 <lambdabot>   21
04:27:37 <Peaker> @src (->) (>>>)
04:27:38 <lambdabot> f >>> g = g . f
04:28:08 <nothingmuch> ooh, didn't know about @src
04:28:12 <nothingmuch> ++
04:30:21 <meta7> "psum ([a:b]:c) = [a+b]: psum c" - don't work
04:31:13 <vixey> meta7, what does "don't work" mean?
04:32:04 <meta7> GHCi: cannot construct the infinite type: t=[t]
04:32:04 <k-zed> hulloh
04:32:09 <SamB> vixey: perhaps it means "I am too lazy to do my own coursework"
04:32:29 <vixey> :t let psum ([a:b]:c) = [a+b]: psum c in psum
04:32:30 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
04:32:31 <lambdabot>       Expected type: t
04:32:31 <lambdabot>       Inferred type: [t]
04:32:39 <vixey> oh right I know why
04:32:39 <SamB> or not ;-P
04:32:52 <asgaroth> Why isn't a Applicative instance for GenParser already included in Parsec(I'm sure there's a good reason, I just don't know it)?
04:32:55 <vixey> meta7,  if you have  [a:b]  then a :: x, and b :: [x]
04:32:58 <k-zed> maximum [1..1000000] results in a stack overflow... what gives? :)
04:32:59 <asgaroth> *an
04:33:07 <vixey> meta7,  so try [a,b] instead of [a:b],  or a:b:c instead
04:34:04 <Workybob> where do I configure cabal install to install to somewhere sensible?
04:34:26 <Saizan_> Workybob: ~/.cabal/config
04:34:59 <laz0r> hi #haskell, i installed ghc-6.10 and it seems that runhaskell does not seem to work as expected
04:35:18 <SamB> laz0r: what does it do ?
04:35:29 <skorpan> http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/VeryLazyEvaluation
04:35:31 <Saizan_> Workybob: you should find the default settings commented out there
04:35:55 <laz0r> i use it in some shell scripts, #!/usr/bin/runhasll, and when I run the script, nothing happens but my mousepointer changes into a little plus...
04:36:07 <laz0r> until i hit ctrl-c
04:36:13 <Workybob> Saizan_: yep, but in fact all I needed to do was add --global
04:36:13 <vixey> skorpan, any details?
04:36:17 <Peaker> laz0r: runhasll?
04:36:21 * Workybob doesn't get why it doesn't do that by default
04:36:30 <laz0r> oh, runhaskell of course
04:36:33 <SamB> laz0r: what happens when you run it manually ?
04:36:34 <Peaker> laz0r: if you have "import" interpreted by a shell, rather than by Haskell, then you'll get that
04:36:35 <asgaroth> laz0r: Check if they run correctly when you type "runhaskell foo.hs" manually
04:36:42 <SamB> oh, what ???
04:36:49 <mauke> Peaker++
04:37:05 <daf> that old chestnut
04:37:09 <asgaroth> Shouldn't the shell don't care about the import with the shebang at the top?
04:37:13 <daf> import is some sort of ancient screenshot tool
04:37:13 <skorpan> vixey: that's all there is, but it looks interesting
04:37:21 <quicksilver> not really ancient.
04:37:24 <edbond> what does '$' means in 'putStrLn $ ....' ?
04:37:26 <Saizan_> Workybob: so that it doesn't mess with your system configuration, you can set userInstall: False, btw
04:37:30 <quicksilver> imagemagick is da beez kneez
04:37:31 <Peaker> @type ($)
04:37:31 <mauke> @src ($)
04:37:32 <lambdabot> forall a b. (a -> b) -> a -> b
04:37:32 <lambdabot> f $ x = f x
04:37:36 <asgaroth> edbond: It's just function application to avoid parentheses
04:37:37 <Saizan_> "user-install"
04:37:38 <daf> quicksilver: oh, I thought it was some X thing
04:37:53 <Workybob> Saizan_: to me, the point of cabal *install* is to mess with my system configuration ;)
04:37:54 <SamB> import is not a great name for a screenshot tool...
04:37:55 <daf> still, arguably poor command naming
04:37:59 <quicksilver> edbond: putStrLn $ a b c is "(putStrLn) (a b c)"
04:38:15 <quicksilver> poor naming is a venerable unix tradition ;)
04:38:26 <asgaroth> Anyway, if there's "#!/usr/bin/haskell" at the top, it shouldn't matter whether there's an "import" program
04:38:26 <daf> haha
04:38:51 <Saizan_> Workybob: it's easier to just remove .cabal and .ghc than looking for libs in /usr/local, but i see your point :)
04:38:53 <quicksilver> edbond: i.e. it's just function application, but it has the effect of changing the bracketing.
04:40:19 <dublpaws> > $ $
04:40:20 <lambdabot>   <no location info>: parse error on input `$'
04:40:50 <Peaker> > ($) ($) ($)
04:40:51 <lambdabot>       Overlapping instances for Show ((a -> b) -> a -> b)
04:40:51 <lambdabot>        arising from...
04:41:06 <SamB> what I want to know is why he didn't get an error about ther being no /usr/bin/runhassl
04:41:12 <Peaker> > show ($)$($)$($) 5
04:41:13 <lambdabot>   Couldn't match expected type `a -> b'
04:41:17 <Peaker> > show $($)$($)$($)$ 5
04:41:18 <lambdabot>       No instance for (Num (a -> b))
04:41:19 <lambdabot>        arising from the literal `5' at <...
04:42:35 <k-zed> say that i have a long, complicated list of pairs; sortBy stack overflows on it
04:42:49 <k-zed> if i print the list first, then sortBy works
04:43:08 <quicksilver> k-zed: compiled or interpreted?
04:43:13 <k-zed> well, in ghci
04:43:19 <k-zed> sortBy .. expr fails
04:43:22 <k-zed> let x = expr
04:43:22 <k-zed> x
04:43:24 <k-zed> sortBy x
04:43:25 <k-zed> this works
04:43:29 * quicksilver nods
04:43:35 <quicksilver> it will probably work fine compiled.
04:43:46 <Peaker> @src sortBy
04:43:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:43:47 <quicksilver> the details may depend on the form of 'expr', too
04:43:55 <laz0r> ok, the scripts do work when I just run them with /usr/local/bin/runghc or runhaskell, but that #!/usr/local/bin/runhaskell thing still does not work
04:45:07 <daf> laz0r: how are you running them?
04:45:35 <asgaroth> laz0r: The script is executable, right?
04:45:57 <laz0r> i have a directory ~/bin, with i add to my PATH, i put them there and set the executable flag
04:46:59 <laz0r> and then i just run them
04:47:07 <asgaroth> laz0r: Hmm, is the shebang at the top of the file?
04:47:10 <laz0r> yes
04:47:23 <laz0r> shebang means #!... right?
04:47:25 <asgaroth> yeah
04:47:37 <asgaroth> which shell are you using?
04:47:40 <laz0r> bash
04:47:54 <koeien> #! must be the *first characters* of the file. no spaces
04:48:08 <k-zed> quicksilver: same effect in the compiled version, actually
04:48:10 <asgaroth> and no comment signs or similar, haskell recognizes them
04:48:51 <koeien> hmm. i have the same problem actually
04:48:56 <laz0r> no spaces, no newlines
04:49:09 <asgaroth> hmm, I don't have it with zsh
04:49:17 <asgaroth> maybe yet another flaw in bash
04:49:22 <koeien> but. using runghc of 6.8.2 works
04:49:59 <koeien> it invokes GHC 6.10.1 however
04:50:17 <SamB> hehehe
04:51:38 <asgaroth> hmm, try /usr/bin/env runhaskell instead, perhaps your runhaskell is located somewhere else
04:51:45 <laz0r> mmh, could be a reason to finally try out zsh
04:51:50 <koeien> asgaroth: mine is not
04:51:59 <loadquo> @src insertBy
04:52:00 <lambdabot> insertBy _   x [] = [x]
04:52:00 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
04:52:00 <lambdabot>                                  GT -> y : insertBy cmp x ys'
04:52:00 <lambdabot>                                  _  -> x : ys
04:52:33 <koeien> $ which runhaskell # gives /usr/local/bin/runhaskell
04:52:33 <laz0r> using /usr/bin/env works!
04:52:34 <lunabot>  luna: Not in scope: `which'
04:52:50 <asgaroth> laz0r: then your runhaskell was probably somewhere else than you thought
04:53:19 <koeien> asgaroth: i have the same problem. runhaskell was invoked correctly. maybe a bash bug
04:53:23 <laz0r> don't think so, i gave it the complete path #!/usr/bin/env /usr/local/bin/runghc
04:53:43 <SamB> wierd!
04:53:45 <asgaroth> normally env runghc or runhaskell should be enough
04:53:53 <laz0r> and that /usr/local/bin/runghc has been there all the time, just added the env bit in fornt
04:53:54 <asgaroth> since that's what env is for(among other thigns)
04:53:56 <laz0r> *front
04:54:29 <asgaroth> *things
04:54:44 <dublpaws> > ((\x -> (\y -> (x*y+2))) $3 ) $5
04:54:46 <lambdabot>   17
04:55:07 <koeien> dublpaws: (\x -> (\y -> ... )) is the same as (\x y -> ... )
04:55:16 <dublpaws> neat!
04:55:20 <koeien> also, you don't need $ here
04:55:38 <koeien> $ is used for omitting parentheses, its definition is just   f $ x = f x
04:55:39 <lunabot>  luna: parse error on input `='
04:55:44 <dublpaws> yeah, I was seeing if some of the parens could be stripped away using $ $
04:56:01 <koeien> > (\x y -> x*y+2) 3 5 -- shorter
04:56:02 <lambdabot>   17
04:56:36 <Peaker> @let result = (.) ; argument = flip (.)
04:56:37 <lambdabot>  Defined.
04:56:42 <Peaker> > (result (+2) . (*)) 3 5
04:56:44 <lambdabot>   17
04:56:51 <Peaker> > (((+2).) . (*)) 3 5
04:56:52 <lambdabot>   17
04:57:01 <asgaroth> One might also need $ if there you want to apply several functions to one argument, so it's not just for paren-avoiding
04:57:03 <koeien> @pl (\x y -> x*y+2)
04:57:03 <lambdabot> flip flip 2 . ((+) .) . (*)
04:57:13 <asgaroth> > map ($3) [(+1),(*2)]
04:57:15 <lambdabot>   [4,6]
04:57:33 <Peaker> @type flip id
04:57:34 <lambdabot> forall b c. b -> (b -> c) -> c
04:57:35 <koeien> asgaroth: yea that's another use of ($)
04:57:41 <koeien> zipWith ($) [(1+),(2*)] [1,2]
04:57:43 <Peaker> @type flip . flip $ id
04:57:44 <lambdabot> forall b c. (b -> c) -> b -> c
04:59:07 <asgaroth> But I guess the use of $ is detrimental to your ability to read perl code, since you mentally `divide' the expression once you see a $ :)
04:59:30 <koeien> asgaroth: this is a good thing actually :-)
05:00:08 <Peaker> Perl code is not meant to be read. Or written. :-)
05:00:17 <Peaker> Perl is a sociological experiment on programmers
05:00:43 <asgaroth> perl code is meant to be generated with dd and /dev/random instead :)
05:01:16 <SamB> perl isn't *that* bad
05:01:29 <koeien> yes it is
05:01:29 <asgaroth> Peaker: Or the result of thousands of sys admins trying to create a programming language
05:01:36 <koeien> yay! another flamewar :-)
05:01:43 <vixey> perl is great
05:02:03 <dublpaws> if it runs good, it is good.
05:03:03 <Peaker> Well, Perl with "use strict" may be ok, but its still doesn't distinguish ints, strings and other types, so it masks a lot of runtime errors :-(
05:03:40 <SamB> not really a problem if you're just using it to generate Haskell code from simple text files ;-P
05:04:36 <Peaker> Even simple scripts use both ints and strings, and if it masks errors about the operators that combine them, not only in compile time but also in runtime, it makes me sad
05:05:04 <vixey> don't write "bannana" + 3  in a perl file problem solved
05:05:29 <vixey> (don't write  head []  in haskell either)
05:05:37 <Peaker> vixey: when programming, there are sometimes layers of indirection
05:05:55 <dublpaws> :t (:|)
05:05:56 <lambdabot> Not in scope: data constructor `:|'
05:06:16 <Peaker> vixey: postponing errors to runtime is bad enough, Perl postpones them forever
05:06:32 <dublpaws> @let grimace = (:|)
05:06:34 <lambdabot>  <local>:2:10: Not in scope: data constructor `:|'
05:06:39 <pejo> Peaker, not true.
05:06:42 <vixey> I don't think you get my point
05:07:43 <Peaker> vixey: Haskell hitting pattern match failures in runtime is bad - but at least you get an error.  In Perl, Strings/Ints are not distinguished, so you don't even get the error in runtime
05:07:52 <loadquo> @let :| = "Grimace"
05:07:52 <lambdabot>   Parse error
05:07:56 <Peaker> vixey: If you only write completely flawless code, than there is no problem, sure :-P
05:08:07 <koeien> loadquo: starting with : is only allowed for data constructors
05:08:30 <vixey> Peaker, do you think I don't know this ?
05:09:34 <Peaker> vixey: you tried to parallelize (head []) and ("hello" + 5) when the only parallel is that they both expose weaknesses of the language. But the weaknesses are of a completely different magnitude
05:10:24 <vixey> no I disagree these aren't weaknesses
05:10:46 <Peaker> vixey: getting errors late rather than soon is not a weakness?
05:12:04 <koeien> "hello" + 5 => "hello5", at least in some languages
05:12:11 <koeien> so that's not an error
05:12:33 <asgaroth> It introduces a lot of error sources though
05:12:44 <koeien> true, i'm playing devil's advocate now
05:12:58 <koeien> i prefer the strong, static type :)
05:13:21 <Badger> heh
05:13:39 <Peaker> If you can't have types, at least have good granularity of runtime tags
05:13:46 <Peaker> (e.g Python)
05:14:16 <koeien> you mean 'static types'
05:14:22 <koeien> python has types
05:14:24 <vixey> Peaker, if every programming language tried to approximate haskell they would all be worthless because haskell exists
05:14:53 <daf> yes, Perl is a bad Haskell
05:15:10 <Peaker> koeien: well, IIRC, its the book "types and programming languages" that coined the distinction between types and "tags".  The idea is that calling "types" which describe terms/expressions, and "tags" which describe runtime values by the same name, blurs the discussion/understanding
05:15:23 <SamB> the question is, how bad of a Perl is Haskell ?
05:15:26 <koeien> Peaker: ok. that's not a mainstream definition afaik
05:15:40 <daf> SamB: I think it could be better
05:15:49 <SamB> yes, me too
05:15:57 <daf> whatever language you use, dynamic types and static types are fundamentally different
05:16:07 <Badger> @faq Can Haskell become a better Perl?
05:16:07 <lambdabot> The answer is: Yes! Haskell can do that.
05:16:21 <koeien> daf: x86 assembly language? :)
05:16:26 <vixey> daf, ty
05:16:46 <daf> koeien: I meant human language, as in terminology
05:18:02 <Peaker> vixey: if a language can do everything another language can do, better, then that other language is already useless.  I don't believe this is the case with Haskell/Perl, but I think its not far from it
05:18:18 <daf> I think that's an oversimplification
05:18:31 <daf> people care a lot about the how
05:18:48 <Saizan_> yeah "better" was crucial in that sentence :)
05:18:48 <asgaroth> That's what the better referred to, I guess
05:19:04 <lilac> one thing languages "do" is have mindshare. that's pretty hard to inherit.
05:20:02 <koeien> and community, if that is what you mean
05:20:06 <vixey> I don't like the current trend in language design, "Must have 'closures', Must have 'generics', Must have XML integration, Must taste like chicken" it's all misguided
05:20:10 <koeien> the haskell community != java community
05:20:19 <SamB> Haskell can't be used to parse Perl 5
05:20:37 <SamB> (well, not without far more effort than the most dedicated perl hacker is willing to invest ...)
05:20:44 <daf> SamB: quite :)
05:21:18 <koeien> vixey: do you have a proposal? you want language design to be more about 'high-level' changes, rather than details?
05:22:40 <SamB> vixey: you have to admit, a staticly typed language without parametric polymorphism kinda sucks
05:23:05 <SamB> and closures are really useful
05:23:28 <SamB> Java has had them for ages, though in an extremely inconvenient way for most of them ...
05:23:36 <daf> I agree with the XML and chicken parts
05:24:50 <vixey> koeien, I didn't mean that.. more that recently a lot are trying to take the average of java, scheme, C#, ocaml, haskell, scala, ... and get the perfect middleground, rather than diverging out to get something original
05:25:06 <koeien> is there something essentially wrong with that?
05:25:21 <SamB> perhaps you should have picked better things to pick on
05:25:36 <SamB> rather than closures and parametric polymorphism
05:25:36 <vixey> koeien, that's just what I meant when I said "I don't like this current trend.."
05:25:39 <koeien> not that i disagree from an academic perspective
05:25:47 <Twey> SamB: Read-only closures, as I recall
05:25:50 <koeien> but the engineer in me wants useful tools
05:26:03 <SamB> read-only ?
05:26:18 <vixey> Twey, read only anonymous, but read write a-anonymous ones
05:26:29 <koeien> "nonymous" :)
05:26:32 <vixey> anyway it's pretty moot since objects  <=> lambda
05:27:06 <SamB> I was talking about inner classes or whatever
05:27:30 <papermachine> Is there an easy way to turn a (String, [String]) map into something in Data.Graph?
05:27:58 <daf> I think vixey is saying that people aren't taking the opportunity to improve on the status quo when they create new languages
05:28:13 <daf> rather, they just remix old elements in slightly different combinations
05:28:14 <koeien> they are
05:28:37 <koeien> what is wrong with such an approach?
05:29:01 <daf> that it's not a way to get genuinely new improvements
05:29:02 <pejo> vixey, the blend of "everything" shifts how people think though. Haskell will seem less radical after you've been exposed to F#.
05:29:15 <koeien> we have a lot of experience with programming languages and their abilities. why not create a new language that combines several good aspects of each, while maintaining usefulness. Let's call it C#.
05:29:33 <daf> C# is not unique in that respect
05:29:35 <vixey> pejo, F# looks like a mix of <languages I mentioned earlier>
05:29:42 <koeien> daf: of course not
05:29:54 <vixey> so as a toned down version of Haskell, yeah sure -- but what
05:30:00 <vixey> does anyone gain out of that?
05:30:01 <pejo> vixey, .. which makes our type system less radical.
05:30:09 <daf> programming language ideas have been migrating from academia to the hands of the general programming population for decades
05:30:34 <koeien> papermachine: does graphFromEdges help?
05:31:20 <papermachine> koeien: Ah, I was in the wrong module.
05:31:22 <koeien> daf: not always, in fact there are several widely-used languages that are built by engineers instead of academics
05:31:26 <papermachine> koeien: Thanks.
05:31:40 <Twey> koeien: Perl?  :-P
05:31:49 <daf> koeien: well, academia is perhaps the wrong word
05:31:49 <pejo> Well, as interesting as this is I have to run. Cheers.
05:31:57 <daf> koeien: though I am curious as to which ones you're thinking of
05:32:09 <papermachine> In fact, graphFromEdges is well-nigh perfect!
05:32:13 * papermachine hugs koeien.
05:32:15 <marcot> @pl enumFrom minBound
05:32:16 <lambdabot> [minBound..]
05:32:29 <koeien> java, perl? i might be wrong though
05:32:34 * vixey points out that X# was designed and implemented by engineers :P
05:32:38 * koeien hugs papermachine :)
05:33:05 <daf> koeien: I wouldn't count Java as an innovative language
05:33:11 <daf> and most of Perl isn't either
05:33:17 <Twey> X# eh *reads*
05:33:29 <koeien> i think it is, in some respects. although seriously over-hyped
05:33:36 <Twey> What, Java?
05:33:39 <koeien> yes
05:33:53 <Twey> I don't think it has anything that wasn't already in Lisp
05:34:07 <Twey> (and/or C++)
05:34:20 <koeien> then almost no languages are 'innovative'. Lisp is of course highly innovative
05:34:48 <koeien> but it doesn't really matter imo. Java is useful, so why not build something like it?
05:35:04 <koeien> the same for C#
05:35:15 <vixey> Java is useful .. so use it
05:35:18 <daf> if they're so good...
05:35:43 <koeien> there are more useful languages, at least for me. Haskell is not for everybody
05:35:50 <koeien> IME
05:35:50 <vixey> but don't mutilate it by adding $hip_language_feature
05:36:05 <Peaker> koeien: .NET was innovative in finally noticing that so many different "languages" were actually the same language with different syntaxes
05:36:17 <Twey> Heh
05:36:20 <Peaker> and creating a single language runtime for that language, with multiple frontends
05:36:25 <Peaker> for the various syntaxes
05:36:30 <koeien> yes, i don't know if it's a good idea, but it's innovative
05:36:40 <daf> that's true
05:36:42 <Peaker> sure it is -- share the efforts on the runtime
05:36:43 <daf> but it's moot
05:36:53 <daf> since it's not language innovation
05:37:03 <koeien> well ok, you have a point there.
05:37:19 <koeien> i was also refering to java's ``ecosystem'' earlier
05:37:57 <daf> ecosystem is great; very practical
05:38:02 <daf> but it's not an innovation either
05:38:31 <vixey> what's the ecosystem?
05:38:47 <daf> I assumed libraries + community
05:38:54 <koeien> jvm, libraries, salesmen
05:39:34 <vixey> ok
05:40:24 <loadquo_> I'd like a new C-like language (as in easy to tell how much resources are being used, no garbage collection), but with less #define nonsense needed.
05:40:35 <bling> augusts: do you teach coq, isabelle, proof general etc?
05:40:46 <Peaker> loadquo_: BitC?
05:40:55 <daf> C with modules?
05:41:16 <loadquo_> Peaker: Had a brief look at that, really should look into it more.
05:43:22 <loadquo_> daf: What do you mean?
05:43:22 <paper_cc> [about low-level languages] is there any production-ready qhasm-alike thing?
05:43:55 <daf> loadquo_: I suppose I was thinking of #include rather than #define
05:46:22 <paper_cc> (i.e. just a formula translator/instruction scheduler with some portable instruction set?)
05:48:57 <ksandstr> paper_cc: i'm not sure if you mean llvm
05:49:22 <ksandstr> it's apparently seeing some production use in apple's opengl implementation
05:50:32 <paper_cc> like that... but a brief look made me think that LLVM is something like GNU Lightning - that is, a runtime code generator.
05:51:13 <pao> I'm searching a "lift" function with signature of time (m a -> m b) -> t m a -> t m b... is this possible a all?
05:51:19 <pao> *type
05:51:38 <quicksilver> pao: In general, no.
05:51:39 * paper_cc thinks about a language with more consistent low-level semantics, easier inline asm and smaller syntax than C
05:51:43 <paper_cc> :t lift
05:51:44 <idnar> @hoogle lift
05:51:44 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
05:51:46 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
05:51:46 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
05:51:46 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
05:52:02 <Stephan202> @pl \a g -> puts g >> return . splitAt a
05:52:03 <lambdabot> flip ((>>) . puts) . (return .) . splitAt
05:52:05 <quicksilver> pao: you may be interested to read this :  C
05:52:13 <quicksilver> pao: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
05:53:30 <ksandstr> paper_cc: did you take a good look at llvm? it's quite distinct from lightning.
05:53:32 <pao> quicksilver: thanks a lot
05:54:04 <pao> in fact I don't think it is possible to "extract" m a from t m a .... only a is "extractable"
05:54:32 <bling> would it makes sense to make a functional C-like language with monads? or is low-level-C-programs so much sideeffects it wouldnt matter?
05:54:38 <Peaker> @type \f act -> (act >>= (\a -> lift (fmap f (return a)))
05:54:39 <lambdabot> parse error (possibly incorrect indentation)
05:54:57 <pao> :t act
05:54:58 <lambdabot> Not in scope: `act'
05:55:04 <pao> ops :-)
05:55:14 <Peaker> @type \f -> (>>= (lift . fmap f . return))
05:55:15 <lambdabot> forall (t :: (* -> *) -> * -> *) a b (f :: * -> *). (Monad (t f), Functor f, Monad f, MonadTrans t) => (a -> b) -> t f a -> t f b
05:55:32 <Peaker> @type \f -> (>>= (lift . f . return))
05:55:34 <lambdabot> forall a (m :: * -> *) a1 (t :: (* -> *) -> * -> *) (m1 :: * -> *). (Monad (t m), Monad m1, Monad m, MonadTrans t) => (m1 a -> m a1) -> t m a -> t m a1
05:55:34 <paper_cc> :t \f -> (lift f >>=)
05:55:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) b. (Monad (t m), Monad m, MonadTrans t) => m a -> (a -> t m b) -> t m b
05:55:48 <pao> Peaker: got there? :-)
05:56:02 <Twey> bling: I think that attempting to separate out side effects at such a low level would be an exercise in futility
05:56:03 <Peaker> Doesn't   (MonadTrans  t) imply (Monad (t m)) ?
05:56:10 <quicksilver> it does, yes
05:56:11 <Peaker> pao: not quite :)
05:56:13 <quicksilver> but m1 is not m.
05:56:29 <vixey> I think you need Monad m as well
05:56:31 <Twey> And lend not much to the eventual programs but clumsiness
05:56:38 <idnar> (Monad (t m), Monad m, MonadTrans t) =>     m1?
05:57:18 <lilac> Peaker: looks like you've got (a -> m b) -> t m a -> t m b there
05:57:24 <pao> Twey: the alternative is manually "unrolling" the monad stack and rebuilding it, ... not less clumsy
05:57:37 * lilac scratches head
05:58:10 <idnar> @type \f -> (>>= (lift . liftM f . return))
05:58:11 <lambdabot> forall (t :: (* -> *) -> * -> *) a1 r (m :: * -> *). (Monad (t m), Monad m, MonadTrans t) => (a1 -> r) -> t m a1 -> t m r
05:58:21 <Peaker> lilac: the lift is in the wrong place
05:58:29 <Peaker> @type \f -> (>>= lift (f . return))
05:58:30 <lambdabot>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
05:58:30 <lambdabot>     When matching the kinds of `t :: (* -> *) -> * -> *' and
05:58:31 <lambdabot>                                `(->) :: ?? -> ? -> *'
05:58:37 <Saizan_> wasn't there a package on hackage implementing this? http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111 i can't find it
05:59:00 <pao> Saizan_: MonadLib?
05:59:25 <Saizan_> no, monadLib is yet another
06:00:40 <Peaker> @type (\mapper tact -> do { x <- tact; lift (mapper (return x)) }) :: (Monad m, MonadTrans t, Monad (t m)) => (m a -> m b) -> t m a -> t m b
06:00:42 <lambdabot> forall (m :: * -> *) a b (t :: (* -> *) -> * -> *). (Monad (t m), MonadTrans t, Monad m) => (m a -> m b) -> t m a -> t m b
06:00:52 <Peaker> pao: I think that's it?
06:01:12 <Peaker> pao: but that might not be what you really are after here
06:01:38 <pao> Peaker: the signature is correct, let me check the semantics
06:01:43 <Peaker> pao: because you might as well take an (a -> m b) here, as I just "return" to generate the (m a), whereas you might want whatever monadic value is inside the transformer (but you can't get that, I don't think)
06:02:10 <pao> Peaker: yep, I think the semantic is not correct because of return
06:03:03 <Peaker> pao: I think that its not possible to convert (t m a -> m a) in any meaningful fashion without another method in another typeclass extending MonadTrans
06:03:04 * quicksilver agrees
06:03:18 <pao> Peaker: yep
06:03:59 <quicksilver> something along the general lines of MonadInterleave
06:03:59 <pao> Peaker: only a is "extractable from t m a
06:03:59 <quicksilver> which is all about whether or not you can 'freeze' and 'thaw' the monadness of a particular monad
06:03:59 <Peaker> pao: yeah
06:04:28 <pao> quicksilver: the cafe post is the one about interleaving, right?
06:04:32 * quicksilver nods
06:04:48 <quicksilver> (m a -> m b) is what I would call a monadic action which takes a callback
06:05:05 <quicksilver> the question of whether you can use callbacks in the wrong monad
06:05:15 <quicksilver> is a fiddly one.
06:05:24 <paper_cc> @ty \f x -> x >>= (lift . f . return)
06:05:25 <lambdabot> forall a (m :: * -> *) a1 (t :: (* -> *) -> * -> *) (m1 :: * -> *). (Monad (t m), Monad m1, Monad m, MonadTrans t) => (m1 a -> m a1) -> t m a -> t m a1
06:05:27 <pao> nice... I fact what I need to insert is exactly, semantically a callback :-)
06:05:33 <quicksilver> to turn (m a -> m b) into (t m a -> t m b)
06:05:41 <quicksilver> you are actually trying to "run" a "t m a" callback
06:05:43 <quicksilver> inside 'm'
06:06:07 <quicksilver> and your function (m a -> m b) only knows what to do with a "m a" callback, not a "t m a" one.
06:06:09 <paper_cc> (recall) is (m1 a -> m b) -> t m a -> t m b acceptable?
06:06:12 <lilac> Peaker: i would have thought (m1 a -> m a1) -> t m a -> t m a1 would be uninhabited :(
06:06:16 <quicksilver> the post I posted is the case where m is IO.
06:06:28 <quicksilver> paper_cc: no.
06:06:38 <quicksilver> (m1 a -> m b) is polymorphic
06:06:44 <quicksilver> it claims it can run a callback of 'any' monad
06:06:50 <quicksilver> in practice, it can't possibly do anything useful with it
06:06:59 <quicksilver> fully polymorphic monad actions are useless.
06:07:04 <paper_cc> quicksilver: hmm
06:07:09 <Peaker> lilac: maybe return should be disallowed then :-)
06:07:23 <quicksilver> all you can do is compose them with themselves.
06:07:23 <paper_cc> @ty \f x -> x >>= (lift . f . return)
06:07:23 <lambdabot> forall a (m :: * -> *) a1 (t :: (* -> *) -> * -> *) (m1 :: * -> *). (Monad (t m), Monad m1, Monad m, MonadTrans t) => (m1 a -> m a1) -> t m a -> t m a1
06:07:24 <pao> quicksilver: what I'm doing right now is to run the transformer, apply the callback, and rebuild the transformer
06:07:26 <lilac> Peaker: where do you get a value of type a1 from?
06:07:26 * quicksilver nods
06:07:38 <Twey> pao: Huh?  A C-like language with monads?
06:07:42 <paper_cc> quicksilver: that doesn't look too polymorphic
06:07:43 <Peaker> lilac: I don't, I get an (m a1)
06:07:46 <Twey> Basically all the code would be in the IO monad
06:07:48 <quicksilver> pao: well that post just really outlines how you do that, for each of several specific transformers.
06:07:51 <asgaroth> Is there a way to avoid having to lift stuff like putStr when using a state transformer with IO except lifting them manually?
06:07:55 <Twey> It's just pointless
06:07:57 <Peaker> lilac: from an (m a)
06:07:58 <asgaroth> s/state/monad/
06:08:01 <lilac> Peaker: to get an (m a1) you need to create a (m1 a)
06:08:03 <pao> Twey: what is pointless?
06:08:31 <quicksilver> asgaroth: Yes. Wish they were prelifted.
06:08:31 <lilac> Peaker: and in order to do that you need to escape the m1 monad
06:08:31 <Peaker> lilac: yeah, return lets me do that cause I have an "a"
06:08:31 <quicksilver> asgaroth: if putStr was defined as liftIO . putStr
06:08:31 <quicksilver> asgaroth: then it would be auto-lifted.
06:08:31 <lilac> Peaker: you don't have an a, you have an m1 a
06:08:31 <koeien> heh
06:08:32 <quicksilver> asgaroth: you could define this yourself, if you use it often.
06:08:34 <idnar> @type liftIO . putStr
06:08:35 <lambdabot> forall (m :: * -> *). (MonadIO m) => String -> m ()
06:08:42 <koeien> quicksilver: is IO a MonadIO ?
06:08:42 <idnar> surely someone has already defined a module full of those?
06:08:45 <Peaker> lilac: I have an "a" from ((t m a)>>=)
06:08:46 <quicksilver> koeien: yes.
06:08:52 <koeien> probably, with lift = id
06:08:52 <lilac> Peaker: actually, i'm thinking about this all backwards
06:08:57 <asgaroth> quicksilver: Ok, thanks
06:09:00 <Peaker> lilac: This whole thing is inside (t m)
06:09:06 <lilac> Peaker: yeah, i see it now ;-)
06:09:13 <quicksilver> you can think it through in both diretions, IMO.
06:09:19 <quicksilver> just try not to switch direction half way ;)
06:09:35 <lilac> Peaker: what you've got is equivalently (a -> m b) -> t m a -> t m b
06:09:49 <lilac> Peaker: because the only m1 a you can sensibly provide is 'return x' for some x
06:10:54 <Peaker> lilac: yep
06:11:01 <pao> Peaker: lilac: what I've seen in my use case is that you cannot do it without the Transformer constructor and runner
06:11:02 <lilac> @type (lift .)
06:11:04 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) a1. (Monad m, MonadTrans t) => (a1 -> m a) -> a1 -> t m a
06:11:08 <paper_cc> quicksilver, Peaker: what am I doing wrong?
06:11:08 <lilac> ^^ more general still
06:11:18 <paper_cc> @let liftAp f = (>>= (lift.f.return))
06:11:25 <lambdabot>  <local>:2:0:
06:11:25 <lambdabot>      Warning: Pattern match(es) are overlapped
06:11:25 <lambdabot>               In...
06:11:38 <paper_cc> > liftAp (map show)
06:11:39 <lambdabot>       Overlapping instances for Show (t [] a -> t [] String)
06:11:39 <lambdabot>        arising f...
06:11:45 <paper_cc> @undefine liftAp
06:11:52 <paper_cc> grr
06:11:56 <lilac> @undefine
06:11:57 <Saizan_> paper_cc: that's the same solution Peaker proposed
06:12:01 <paper_cc> oops
06:12:08 <paper_cc> I've overlooked, sorry
06:12:27 <Saizan_> paper_cc: the problem is that the (t m a) action is runned instead of transformed
06:13:22 <paper_cc> @let liftAp' f = (>>= (lift.f.return))
06:13:22 <lambdabot>  Defined.
06:13:22 <paper_cc> > liftAp' (map show)
06:13:22 <lambdabot>       Overlapping instances for Show (t [] a -> t [] String)
06:13:22 <lambdabot>        arising f...
06:13:22 <paper_cc> @ty liftAp' (map show)
06:13:22 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad (t []), Show a) => t [] a -> t [] String
06:13:47 <Peaker> Its somewhat tempting to have the type system somehow disallow having:    (m a -> m b)  instead of (a -> m b) in your type, when it could do with the latter
06:13:58 <Peaker> but of course, that would be truly limiting
06:14:45 <Saizan_> > flip runReaderT () $ liftAp' length $ lift [1..10]
06:14:47 <lambdabot>   Couldn't match expected type `m a1' against inferred type `Int'
06:15:04 <Saizan_> > flip runReaderT () $ liftAp' (return . length) $ lift [1..10]
06:15:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
06:15:26 <Saizan_> only singletons, instead of being able to see the whole list at once
06:16:22 <quicksilver> Saizan_++ # clever example.
06:17:15 <vixey> :t lift [1..10]
06:17:16 <lambdabot> forall t (t1 :: (* -> *) -> * -> *). (MonadTrans t1, Enum t, Num t) => t1 [] t
06:18:28 <pao> Saizan_: that's clear :-)
06:18:42 <pao> Saizan_: no other option that unrolling the Transformer
06:19:02 <memento> I have sg like this, this is in a State monad(so get means State's get): http://rafb.net/p/8E66FI29.html how can I fix this? If I print return before the checkPredName it will lifted to m a but than the case's match won't work
06:23:40 * paper_cc has finally lifted himself to Control.Monad.CleverExample
06:25:32 <paper_cc> is there a failure monad (Either e) anywhere?
06:26:23 <Olathe> I think Maybe is one.
06:26:36 <skorpan> Error?
06:26:51 <Peaker> paper_cc: there's ErrorT, which is basically EitherT with other names than Left/Right
06:26:56 <Peaker> @hoogle ErrorT
06:26:57 <lambdabot> Control.Monad.Error newtype ErrorT e m a
06:26:57 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
06:26:57 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
06:27:08 <Peaker> oh sorry, not even other names :)
06:27:35 <paper_cc> thanks
06:27:46 <lilac> paper_cc: (Either e) is a monad
06:28:06 <paper_cc> @ty (Left 0 >>=)
06:28:07 <lambdabot> forall t b b1. (Error t, Num t) => (b -> Either t b1) -> Either t b1
06:28:31 <paper_cc> aha
06:28:33 <idnar> lilac: well, (Error e) => Either e
06:28:47 <lilac> idnar: indeed. fail.
06:29:02 <idnar> or rather, Either e /is/ a monad, but that's not the instance that's defined
06:29:27 <paper_cc> idnar: ^ it looks to me that it's defined
06:29:38 <paper_cc> @ty (Right "hello world" >>=)
06:29:40 <lambdabot> forall a b. (Error a) => ([Char] -> Either a b) -> Either a b
06:29:54 <lilac> paper_cc: idnar is correct
06:29:54 <CosmicRay> in a cabal file, if I set buildable: false, is there a way to override that on the command line?
06:29:54 <idnar> paper_cc: notice the Error constraint
06:29:56 <lilac> paper_cc: you need an Error instance for your error type
06:30:00 <CosmicRay> I'm trying to figure out a good way to build unit tests that aren't to be installed
06:30:04 <lilac> @src Error
06:30:05 <lambdabot> class Error a where
06:30:05 <lambdabot>     noMsg  :: a
06:30:05 <lambdabot>     strMsg :: String -> a
06:30:06 <lilac> @instances Error
06:30:07 <lambdabot> IOError, String
06:30:29 <idnar> > noMsg :: String
06:30:32 <lambdabot>   ""
06:30:35 * quicksilver thinks dcoutts is probably the only man who can help CosmicRay .
06:30:51 <lilac> presumably noMsg is used by the MonadPlus instance for Either e, and not the Monad instance?
06:30:58 <CosmicRay> quicksilver: I am hoping he is here, indeed ;-)
06:30:58 <idnar> dcoutts Kenobi, you're my only hope!
06:31:04 <CosmicRay> dcoutts is like a live wikipedia for cabal
06:31:11 <CosmicRay> @seen dcoutts
06:31:11 <lambdabot> dcoutts is in #haskell, #ghc, #darcs, #haskell-soc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 5h 15m 56s ago.
06:31:12 <quicksilver> lilac: yes, noMsg is used for mzero, I think.
06:31:19 <paper_cc> @ty (Left 123 >>=)
06:32:14 <joma> hey vixey man, whadya sayin machine learning be the 80s mon? machine learning be now be everywhere
06:32:14 <lambdabot> forall t b b1. (Error t, Num t) => (b -> Either t b1) -> Either t b1
06:32:14 <lilac> idnar: i don't know a dcoutts Kenobi, but I know an old Duncan Kenobi...
06:32:14 <quicksilver> damn those machine learning rastas
06:32:14 <vixey> joma I think you confused me with someone else
06:32:14 * paper_cc has noticed (Error t, Num t). Thank lilac, idnar
06:32:14 <pao> :t \tma -> lift . (undefined::m a -> m b) . evalStateT tma
06:32:14 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a b a1. (Monad m, MonadTrans t) => StateT a1 m a -> a1 -> t m b
06:32:31 <Saizan_> CosmicRay: the only way is to use a flag
06:32:42 <pao> Peaker: quicksilver: lilac: this is the "custom" solution for my "callback"
06:33:26 <CosmicRay> Saizan_: I guess that ought to work, sure
06:33:36 <lilac> YO DAWG WE HERD YOU LIKE TYPES SO WE PUT A KIND SYSTEM IN YOUR TYPE SYSTEM
06:33:44 <CosmicRay> hah
06:34:13 <Twey> We need a meta-kind system
06:34:19 <Twey> And a meta-meta-kind system...
06:34:46 <vixey> Twey, why?
06:34:52 <idnar> http://dontclickthis.whatingods.name/derive-while-you-derive.jpg -- chain rule
06:37:37 * paper_cc thinks that ErrorT String State <WhateverState> () is the only thing that can make memento's code readable
06:37:50 <paper_cc> memento: what is the definition of SemanticResult?
06:39:24 <zoq> Irssi 0.8.10 (20051211) - http://irssi.org/ goto end
06:39:34 <paper_cc> memento: grr. you simply need "return Ok" instead of Ok in the bottom
06:41:36 <memento> paper_cc: its data SemanticResult = Ok | Error String;
06:42:52 <paper_cc> memento: then there should be some mention of State in type for checkConstInPredList, shouldn't it?
06:43:35 <memento> the types uncommented there
06:43:42 <flazz> I made a list of randoms using newStdGen/randoms, what is the range of values? is it possible to make a new type that are only positive integers between a range? and then specify that type to randoms?
06:44:16 <memento> and I know that the return is needed to OK and Error but the compiler's problem with checkPredName's return value
06:44:18 <quicksilver> flazz: why not use randomRs ?
06:44:52 <flazz> quicksilver: because i don't know about it :)
06:45:41 <memento> im in the middle of rewriting the whole thing with State monad and im doing it just step by step
06:46:50 <Workybob> has anyone here build gtk2hs recently?
06:47:23 <paper_cc> memento: then you need to wrap things in 'do' or >>= or whatever
06:48:02 <paper_cc> memento: like: get >>= \(c, p) -> checkBlah p >>= \r -> case r of ...
06:48:39 <memento> ooohhh
06:48:50 <memento> really really thanks
06:50:17 <memento> but checkBlah is not monadic
06:50:54 <paper_cc> yep
06:51:49 <paper_cc> (return.checkBlah) ?
06:51:49 <memento> so bind will not work, just with return checkBlah >>= but it does not make sens does it?
06:51:49 <memento> then im not getting sg:)
06:51:59 <memento> i just try maybe it will make sens when im doing:)
06:52:01 <paper_cc> memento: it does in the sense it passes the state unchanged and wraps the result
06:52:22 <paper_cc> (btw and what's the type of Predicate constructor?)
06:52:29 <paper_cc> /s/Pre/the Pre/
06:53:13 <xenoblitz> Hi people :) I was wondering... is there a way to see a program's stack in haskell using ghc or perhaps an ide?
06:54:52 <memento> paper_cc: it seems it's working thanks and i think i get it now:)
06:55:45 <paper_cc> memento: maybe you still should be using ErrorT String State <something> instead of State <something> ...
06:56:12 <quicksilver> xenoblitz: haskell programs don't really have a stack in the normal sense.
06:56:22 <ziman> xenoblitz, you might want to take look at ghci's debugger (although i find `stack' a rather problematic term in haskell)
06:56:23 <jeffz`> xenoblitz: why would you want to do that?
06:57:12 <memento> paper_cc: yeah i will just step by step:)
06:57:38 <xenoblitz> quicksilver: yes yes i know ... lets call them function calls
06:57:41 <xenoblitz> ziman: yes I'll take a look
06:57:41 <xenoblitz> jeffz': I need to see some function calls
06:57:59 <lilac> xenoblitz: you can see the evaluation "stack" in ghci
06:58:01 <xenoblitz> quicksilver, ziman, jeffz': just took a look around and found Hat... seems to be what I really need
06:58:04 <ziman> xenoblitz, also, there's Debug.Trace
06:58:35 <xenoblitz> lilac: i'll look it up thanks :)
06:58:38 <quicksilver> xenoblitz: the problem is that the enclosing calls may well not exist
06:58:41 <xenoblitz> ziman: thanks as well
06:58:46 <quicksilver> xenoblitz: depending on exactly what's happening.
06:59:02 <quicksilver> xenoblitz: tail calls can clear an entire enclosing context
06:59:04 <xenoblitz> quicksilver: all I want to do is just see what function is called with what input
06:59:28 <quicksilver> hat is probably the right answer although some people have reported it hard to get running.
06:59:34 <quicksilver> I personally have never really needed this :)
06:59:59 <xenoblitz> quicksilver: am trying a little embedding of a mini language
07:00:20 <xenoblitz> quicksilver: i need to see why a certain script is behaving in a way I'm not expecting it to
07:01:30 <quicksilver> xenoblitz: I'm not saying my code never has bugs ;)
07:01:42 <quicksilver> xenoblitz: I'm just saying I never miss the lack of stack trace.
07:02:04 <quicksilver> I normally manage to solve bugs by experimenting in ghci.
07:02:35 <BMeph> xenoblitz: Aye, GHCi ftw. :)
07:02:58 <xenoblitz> quicksilver: hehe what kind of experiments? :P
07:03:08 <sw17ch> Is it common to have a 2K module take > 10 minutes to compile and still not finish?
07:03:09 <Peaker> did anyone compare the speed of the Haskell shootout solutions to the idiomatic Haskell code?
07:03:29 <Peaker> (the shootout Haskell solutions are notorious for being unidiomatic)
07:03:32 <sw17ch> (ghc 6.10.1 built from source on Ubuntu 8.10 eith extra-libs)
07:03:56 <quicksilver> xenoblitz: observe the result of an expression. observe the result of subexpressions. think a bit.
07:04:06 <quicksilver> xenoblitz: try a different subexpression. Build up. generalise. think a bit more.
07:04:12 <quicksilver> xenoblitz: drink coffee. solve bug.
07:04:16 <xenoblitz> hehe dry runs :P
07:04:43 <xenoblitz> quicksilver: ok ok I'll give it another shot at what you said :P
07:07:43 <quicksilver> quickcheck properties can be helpful, too
07:08:25 <xenoblitz> quickcheck: I never tried quickcheck on Data structures... maybe i should
07:08:30 <lilac> xenoblitz: run subexpressions and build up until one of them is wrong
07:08:55 <lilac> or start from the wrong value and dig down until things stop being wrong :)
07:09:45 <xenoblitz> quicksilver: oops I meant quicksilver: not quickcheck:
07:09:53 <asgaroth> What's the best way for breadth-first traversal of a tree? Currently I'm using a State monad with a list as a queue.
07:11:03 <xenoblitz> lilac: yeah I'll do the first :)
07:11:13 <quicksilver> asgaroth: the "best" way is okasaki's functional pearl : http://debasishg.blogspot.com/2008/09/breadth-first-numbering-okasakis.html
07:11:18 <quicksilver> asgaroth: warning, your head may explode.
07:11:29 <ehird> Happs is orphaned? Wow.
07:12:36 * paper_cc thinks how to wrap breadth-first traversal into a fold
07:12:47 <asgaroth> quicksilver: Thanks, I'll have a look at it. (I'm actually trying to write a pretty-printer for trees and for that, breadth-first traversal would be the way to go, right?)
07:13:37 <asgaroth> (At least if I don't have a way to go a line "up" again)
07:13:37 <quicksilver> depends on the kind of pretty printing you have in mind I think :)
07:14:09 <quicksilver> some pretty printers use smart combinators which let you put rectangular blocks 'next to' each other
07:14:19 <quicksilver> which sidesteps the problem of going up a line.
07:14:28 <quicksilver> the one in the haskell standard lib is like that.
07:15:05 <asgaroth> Okay thanks, but I guess I'll try to do it without such helpers as an exercise anyway though
07:16:29 <jkff> Hi folks. Could you suggest me some random cool articles? (I'm going to have some spare time for reading them in a train) I'm trying to restrict the codomain of 'random' but can't think of anything in particular. Probably, anything hot on continuations? Or on parallelism? Or on fusion of blablamorphisms?
07:16:53 <Twey> HAppS is orphaned?!
07:17:05 <paper_cc> [curious about that tree traversal] how does one map all the stuff from Control.Morphism.Cata to Wikipedia's Catamorphism explanation...?
07:17:25 <ehird> Twey: since last year, apparently
07:17:40 <ehird> http://groups.google.com/group/HAppS/msg/d128331e213c1031 linked from http://happstack.com/faq.html
07:17:42 <Twey> Lemmih?
07:17:48 <ehird> lemmih posted that message
07:17:54 <Twey> :-\
07:17:54 <asgaroth> jkff: Hmm, the Monad.Reader issues are quite interesting
07:18:06 <Twey> Oh right
07:18:12 <Twey> It was forked.  Phew.
07:18:16 <ehird> yeah
07:19:16 <cnwdup> @hoogle EitherT
07:19:17 <lambdabot> No results found
07:20:09 <Twey> HAppS needs more docs
07:20:09 <jkff> asgaroth: Thanks, Issue 6 looks cool! http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
07:20:25 <jkff> Especially considering there's sigfpe and roconnor inside
07:22:05 <Twey> I've been meaning to work with it for ages
07:22:25 <mstr> what does "...is applied to too many type arguments" mean?
07:22:42 <quicksilver> well, for example Maybe takes one argument
07:22:45 <quicksilver> as in 'Maybe Int'
07:22:52 <quicksilver> so 'Maybe Int Int' would give that error, I think.
07:23:02 <quicksilver> > Nothing :: Maybe Int Int
07:23:03 <lambdabot>       Kind error: `Maybe' is applied to too many type arguments
07:23:03 <lambdabot>      In the t...
07:23:06 <mstr> I'm trying to do: split' :: ([Int], [Int]) [Int] -> ([Int], [Int])
07:23:10 <Twey> It's the type-level equivalent of writing '3 4' :)
07:23:33 <Twey> mstr: ([Int], [Int]) isn't a type constructor
07:23:36 <quicksilver> mstr: it's writing "([Int], [Int])" and [Int] next to each other like that
07:23:40 <quicksilver> that it is complaining about
07:23:48 <quicksilver> what did you intend? two parameters?
07:24:03 <quicksilver> ([Int], [Int]) -> [Int] -> ([Int],[Int])
07:24:04 <quicksilver> perhaps
07:24:21 <mstr> trying to do: split :: [Int] -> ([Int], [Int])
07:24:40 <mstr> (no full solutions pls. this is an exercise :] )
07:25:02 <Twey> mstr: You're just trying to implement split?  So why are you messing with the type?
07:25:25 <mstr> so I'd like to pass the pair of new lists and the original list to split'
07:25:43 <asgaroth> mstr: What are you trying to do? On what criterion do you want to split?
07:26:05 <Twey> mstr: What quicksilver said, then
07:26:16 <Twey> But... wait what?  o.@
07:26:25 <Twey> You're trying to pass... the return value?
07:26:40 <mstr> like in tail recursion
07:26:53 <Twey> Ah, it's an accumulator
07:26:55 <mstr> I just try to pass on the lists
07:27:00 <mstr> Twey: yea
07:27:10 <Twey> OK then, but hint: you don't need to do that
07:27:37 <mstr> I want to try that solution anyway, and more haskelly ones later :)
07:27:59 <Twey> It's less about being Haskelly than about simply being pointless
07:28:07 <Twey> Split, you see, breaks at the given point
07:28:10 <mstr> arfg :(
07:28:24 <Twey> So once you get to that point, you already have the second list
07:28:33 <Twey> You don't need to iterate over it
07:29:04 <Twey> (as a benefit, you also get laziness in that argument)
07:34:25 <int80_h> @src any
07:34:25 <lambdabot> any p =  or . map p
07:36:59 <asgaroth> @pl \p -> or . map p
07:37:00 <lambdabot> any
07:37:18 <asgaroth> @pl \x -> foo . bar x
07:37:19 <lambdabot> (foo .) . bar
07:37:45 <Peaker> Hmm.. I read that toolkits have a Draw monad. Why isn't it just a Draw monoid?
07:38:24 <lilac> http://haskell.pastebin.com/m33510595 <-- my number-a-tree algorithm
07:38:32 <Twey> @pl \x -> case x of y -> 3; z -> 5
07:38:32 <lambdabot> (line 1, column 19):
07:38:32 <lambdabot> unexpected ">" or "-"
07:38:32 <lambdabot> expecting variable, "(", operator or end of input
07:39:00 <skorpan> @hoogle <$>
07:39:00 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:39:05 <lilac> is this novel, or have i reinvented somethign well-known?
07:39:14 <ozy`> > take 3 $ take 9000 $ "pizza"
07:39:15 <lambdabot>   "piz"
07:39:25 <Twey> @pl really should fail more elegantly on constructs it can't handle
07:39:25 <asgaroth> Peaker: I don't know they do, but I guess they're doing something IO-ish and therefore perhaps are a monad transformer on top of IO
07:39:25 <lambdabot> really should fail more elegantly on constructs it can't handle
07:39:30 <Twey> Haha
07:39:32 <asgaroth> *what they
07:40:38 <Peaker> asgaroth: even if they're IO, why not: data Draw = Draw (IO ()) -- instance Monoid Draw where .. mappend (Draw x) (Draw y) = Draw (x>>y) ?
07:42:03 <asgaroth> Peaker: Hmm, I could imagine that they are perhaps also managing some other stuff like gui state. (The X monad in xmonad for example is a ReaderT and a StateT on IO)
07:42:21 <drdozer> anyone here used Data.GraphViz?
07:42:55 <skorpan> is there any nice instance of Show which can be used to pretty print trees, e.g. (Branch x [Branch y [], Branch z [Branch w []]])
07:42:59 <Peaker> asgaroth: then they can use a transformer, my point is that there's no point in the "a" there, so you can fixate it to () and then have mappend instead of >>=
07:44:31 <asgaroth> Peaker: Hmm, that makes sense, although I could imagine some actions in the Draw monad query some sort of state, but then Draw would be a misnomer, in my opinion
07:44:40 <asgaroth> *that query
07:44:46 <sw17ch> Distribution.Simple is installed with Cabal right?
07:45:20 <Peaker> asgaroth: yep
07:51:03 <sw17ch> is any one here working with 6.10.1 on an i386 box?
07:51:11 <sw17ch> linux?
07:51:29 <sw17ch> i think i have a compiler bug :\
07:51:39 <sw17ch> but can't reproduce it on my x86_64 box or on windows
07:52:05 <lilac> sw17ch: i have such a box
07:52:36 <sw17ch> i'm hitting an infinite loop on a 2K module
07:53:36 <ztirF> so I'm looking at the CORE representation of a math function I wrote - why does it have "case" statements that don't do anything?
07:53:44 <ztirF> as in, they only have one alternative
07:53:49 <ztirF> called "__DEFAULT"
07:54:38 <drdozer> Are either of Mattew or Ivan who wrote Data.GraphViz in here?
07:56:07 <Axman6> ztirF: that's the way things are done.
07:57:36 <mstr> hmm, is there a function to do take two tuples and do something to their each member?
07:57:47 <lilac> ztirF: in core, 'case' statements force thunks
07:58:05 <mstr> for example we have (1,2) (a,b) and we want:
07:58:23 <mstr> func 1 a     func 2 b etc
07:58:29 <skorpan> @pl \x -> toTree (fp </> x)
07:58:30 <lambdabot> toTree . (fp </>)
07:58:33 <lilac> mstr: first, second
07:58:35 <skorpan> what! i tried that.
07:59:15 <mstr> or rather end result would be a tuple : (func 1 a , func 2 b)
07:59:33 <ztirF> lilac: k, so if I make the function strict, that stuff should go away?
07:59:56 <lilac> > ((f *** f) *** (f *** f)) (1,2) (a,b)
07:59:58 <lambdabot>   Couldn't match expected type `t1 -> t'
08:00:28 <dmead> hey channel
08:00:53 <dmead> how would i go about running haskell on an arm 8 with regular linux
08:01:03 <fasta> Where is draw_rect in the Haskell SDL package?
08:01:04 <dmead> can ghc bootstrap for arm?
08:01:35 <asgaroth> fasta: You can look it up with hayoo
08:01:39 <asgaroth> @where hayoo
08:01:40 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:01:45 <fasta> asgaroth: no, I can't.
08:01:57 <fasta> asgaroth: I already tried, and hayoo returned an empty result.
08:02:05 <asgaroth> Ok, didn't know that
08:02:14 <dmead> maybe you're looking in for the wrong thing then
08:02:20 <mstr> what namespace are first and second in?
08:02:22 <Axman6> @hoogle rect
08:02:23 <lambdabot> Distribution.Simple.Utils copyDirectoryRecursiveVerbose :: Verbosity -> FilePath -> FilePath -> IO ()
08:02:23 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
08:02:23 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
08:02:36 <Axman6> @hoogle draw
08:02:36 <lambdabot> Data.Tree drawForest :: Forest String -> String
08:02:36 <lambdabot> Data.Tree drawTree :: Tree String -> String
08:02:36 <lambdabot> package graphics-drawingcombinators
08:02:37 <fasta> dmead: ?
08:02:43 <dmead> nm
08:02:48 <asgaroth> fasta: you could try building the hoogle database with haddock for that sdl package and use that to search with hoogle
08:03:18 <kiris> ah, cool
08:03:29 <kiris> hoogle --dump | grep -E "^#[0-9]+[ ]+module " | sed -r "s/#[0-9]+[ ]+module ([^ ]+).*/\1/g" | sort -u
08:03:36 <kiris> module list!
08:03:45 * kiris goes for ido-mode import writing
08:03:47 <lilac> > (f *** f) (a, b)
08:03:48 <lambdabot>   Add a type signature
08:03:52 <lilac> > (f *** f) (a, b) :: (Expr, Expr)
08:03:54 <lambdabot>   (f a,f b)
08:04:00 <mstr> ah, it was fst and snd :P
08:04:21 <Axman6> roconnor: i find :m +<tab><tab>y in ghci easier...
08:04:31 <lilac> > (($)***($)) ((f *** f) (a, b)) (1,2) :: (Expr, Expr)
08:04:32 <lambdabot>   Couldn't match expected type `t -> (Expr, Expr)'
08:04:35 <roconnor> good to know
08:04:49 <ozy`> I'm seeing all kinds of fascinating stuff on moonpatio today....
08:04:52 <quicksilver> lilac: I tried that too. Couldn't entirely see what it wasn't working.
08:06:26 <mstr> so how about this? http://pastebin.com/f57d10d1a
08:06:40 <skorpan> i don't suppose it's possible to declare a type local to a function?
08:06:51 <mstr> that's ok, or is there some better way?
08:06:52 <Peaker> > (f a, f b)
08:06:53 <lambdabot>   Add a type signature
08:06:58 <Peaker> > (f a, f b)::(Expr,Expr)
08:07:00 <lambdabot>   (f a,f b)
08:07:35 <fasta> There is no binding for sdl-draw, which contains the function.
08:08:09 <skorpan> is it possible to add some sort of "decorator" to a type declaration which tells ghc not to export it?
08:08:19 <Peaker> lilac: because the result of the expression left of (1,2)  is a tuple of two functions
08:08:25 <Peaker> quicksilver: ^^
08:08:26 <fasta> skorpan: you can just like not export the type :)
08:08:40 <skorpan> fasta: but i don't want to clutter the module declaration with everything *but* that type
08:08:46 <quicksilver> Peaker: *nod*.
08:08:49 <Peaker> @type (($)***($)) ((f *** f) (a::Expr, b))
08:08:50 <lambdabot> forall a b a1 b1. (SimpleReflect.FromExpr b1, Show a1, SimpleReflect.FromExpr b, Show a) => (a -> b, a1 -> b1)
08:09:02 <CosmicRay> anyone have ideas on my post on typeclass for converting between types?
08:09:05 <Peaker> @type (($)***($)) ((f *** f) (a::Expr, b::Expr))
08:09:07 <fasta> skorpan: either write a preprocessor/th hack, or no.
08:09:07 <lambdabot> forall a b a1 b1. (SimpleReflect.FromExpr b1, Show a1, SimpleReflect.FromExpr b, Show a) => (a -> b, a1 -> b1)
08:09:14 <skorpan> fasta: okay, thanks
08:09:17 <vixey> CosmicRay, I didn't see it
08:09:37 <lilac> Peaker: indeed.
08:09:42 <quicksilver> skorpan: split your modules into a mostly internals and a mostly externals one
08:09:48 <CosmicRay> vixey: let me get you a url
08:09:48 <quicksilver> skorpan: (yes, I know that's not very nice)
08:10:17 <CosmicRay> vixey: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/51290
08:10:22 <Peaker> > let (****) = uncurry (***) in (($)***($)) ((f *** f) (a, b)) **** (1,2) :: (Expr, Expr)
08:10:24 <lambdabot>   (f a 1,f b 2)
08:10:33 <lilac> heh, nice
08:11:35 <Axman6> @pl \(a,b) (c,d) -> (f a c, f b d)
08:11:36 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. f) . flip . (((.) . (,)) .) . f)
08:11:57 <Peaker> @type \(a,b) (c,d) -> (f a c, f b d)
08:11:58 <lambdabot> forall t t1 t2 t3 t4 t5. (SimpleReflect.FromExpr (t3 -> t5), Show t1, SimpleReflect.FromExpr (t2 -> t4), Show t) => (t, t1) -> (t2, t3) -> (t4, t5)
08:12:21 <Peaker> @type \(a,b) (c,d) -> (a c, b d)
08:12:23 <lambdabot> forall t t1 t2 t3. (t -> t2, t1 -> t3) -> (t, t1) -> (t2, t3)
08:12:29 <Peaker> @pl \(a,b) (c,d) -> (a c, b d)
08:12:30 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
08:12:37 <Peaker> @type uncurry (***)
08:12:39 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
08:13:27 <Peaker> @type uncurry (***) :: (_->_, _) -> _        would be nice
08:13:29 <lambdabot> parse error on input `_'
08:13:59 <ozy`> so, to the people playing with continuations and goto.... is there a way to jump forward, as well as back?
08:14:06 <Peaker> ozy`: mdo
08:14:16 <Peaker> (maybe)
08:14:44 <ozy`> @hoogle mdo
08:14:45 <lambdabot> keyword mdo
08:14:45 <lambdabot> package mdo
08:14:45 <lambdabot> package RandomDotOrg
08:14:49 <lilac> Peaker: i had a look at hacking that into ghc, but it's not easy :(
08:14:54 <lilac> (at least, not for me)
08:15:10 <vixey> lilac, I think that's because GHC is a mess not because it's difficult to implement by the way
08:15:12 <Peaker> lilac: hacking what?
08:15:29 <Peaker> mdo?
08:15:35 <vixey> Peaker, (the thing you just suggested)
08:15:40 <lilac> Peaker: _ in types
08:15:43 <Peaker> lilac: oh
08:16:12 <Peaker> lilac: I have no idea how ghc looks inside, heh
08:16:13 <lilac> vixey: yeah. in principle it's just adding a non-forall-quantified variable
08:16:50 <cnwdup> I have a monad Parser a = Parser { runParser :: StateT ParserState (Either ParserError) a }. How can I override Parser's fail method so that it returns Left ParseError? I tried the following but it doesn't match against type Parser a. Any suggestions how to make it work? http://rafb.net/p/FVmxfk28.html
08:17:06 <ozy`> vixey: how could GHC be not a mess? I haven't seen a whole lot of compilers but it seems to be their inevitable fate....
08:18:02 <Zao> ozy`: Because unlike other compilers, it's written in an awesome language?
08:18:16 <Peaker> Zao: C?
08:18:22 <Peaker> Heh, a lot of ghc is in C isn't it?
08:18:39 <ozy`> ¯\O_o/¯
08:18:53 <Saizan> Peaker: no
08:19:09 <jeltsch> I have installed several packages via cabal-install. Unfortunately, Cabal doesn’t build Haddock documentation by default. How can I tell cabal-install to generate documentation for the packages it already installed? How can I tell cabal-install to always generate documentation when installing packages?
08:19:17 <Zao> Peaker: All Haskell and a bit of Perl for the mangler.
08:19:21 <Zao> If that abomination is still alive.
08:20:02 <cnwdup> Ah, actually I think I got it working. (-:
08:20:10 <Botje> cnwdup: shouldn't it be StateT ParserState (Either ParseError a) ?
08:20:12 <jeltsch> Peaker: The runtime system contains some C code, however.
08:20:12 <Peaker> Saizan: I remember some website that shows pie charts of how much languages various projects use, and it showed 30-50% (I can't remember which) for ghc
08:20:18 <Saizan> jeltsch: for the latter "documentation: True" in ~/.cabal/config
08:20:33 <jeltsch> Sazian: Thank you.
08:20:42 <ozy`> Peaker: 30-50% of...?
08:20:45 <ozy`> C?
08:20:51 <cnwdup> Botje: I didn't think so. Should it? (-:
08:20:53 <jeltsch> Saizan: What about the former? Do I have to reinstall all already installed packages?
08:21:05 <loscar> /?
08:21:24 <Saizan> jeltsch: unfortunately, yes
08:22:05 <Botje> i'm not sure about partially applied kinds, but it looks weird :p
08:22:23 <quicksilver> Zao: except for the C
08:22:25 <quicksilver> Zao: and the Cmm
08:22:26 <Peaker> ozy`: ya
08:22:30 <Saizan> Peaker: the typechecker is in pure haskell, anyway
08:23:06 <Peaker> did anyone try to implement examples for type error messages?  Making up example types that would fail?
08:23:22 <Peaker> (Instead of weird messages like "Can't construct infinite type a = (a, a)")
08:25:05 <Peaker> example message: "e.g: When a=String, it would fail, because line 64 expects a tuple, not a String"
08:25:24 <vixey> that would confuse me a lot ....
08:25:45 <Peaker> vixey: not to replace the error messages, but as extra information below, that is more newbie friendly
08:25:45 <quicksilver> Peaker: people have spent a lot of time trying to work out ways to get nicer error messages.
08:25:51 <quicksilver> Peaker: but, don't let me put you off.
08:25:59 <quicksilver> Peaker: come up with some proposals and post them to the mailing list.
08:26:17 <quicksilver> SPJ is very strongly in favour of good error messages
08:26:23 <quicksilver> he often asks for suggestions on how to improve them.
08:26:55 <Peaker> cool
08:27:05 <vixey> I wonder if everyone agrees that type family/associate whatever-they're-called should be printed out normalized in error messages?
08:27:42 <lilac> vixey: i think i'd prefer them unexpanded, with GHC /also/ telling me what they expand to
08:27:49 <skorpan> @src mkRegex
08:27:49 <lambdabot> Source not found. There are some things that I just don't know.
08:27:50 <Peaker> I just got my friend bigorilla here to learn Haskell, and his main criticism (aligning with mine) is that its not newbie-friendly, compared to, say Python, because in Python you get concrete errors like "Expected String, found Int" or "no attribute 'blah'" whereas type errors are much more abstract
08:27:52 <quicksilver> vixey: I think everyone agrees on the problem; I'm not sure everyone agrees on the solution.
08:28:05 <quicksilver> Peaker: I'm 100% with you there.
08:28:20 <vixey> :t "foo" ++ (3 :: Int)
08:28:21 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Int'
08:28:21 <lambdabot>     In the second argument of `(++)', namely `(3 :: Int)'
08:28:26 <quicksilver> boggling error messages are the worst thing about beginning to learn haskell.
08:28:28 <vixey> Couldn't match expected type `[Char]' against inferred type `Int'
08:28:43 <quicksilver> you cheated, vixey.
08:28:47 <Peaker> :t "foo" ++ 3
08:28:48 <lambdabot>     No instance for (Num [Char])
08:28:48 <lambdabot>       arising from the literal `3' at <interactive>:1:9
08:28:48 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
08:28:51 <quicksilver> you constrained the type of the Int.
08:28:58 <quicksilver> it's a much worse error for the more 'natural' mistake
08:29:03 <quicksilver> (as Peaker just showed)
08:29:06 <idnar> Peaker: python has really awful error cases too, so that's not a great argument
08:29:18 <Peaker> idnar: what awful error messages does Python have?
08:29:22 <quicksilver> :t putStrLn 1 2
08:29:23 <lambdabot>     Couldn't match expected type `t1 -> t'
08:29:23 <lambdabot>            against inferred type `IO ()'
08:29:31 <quicksilver> ^^ that message isn't great, either.
08:30:04 <quicksilver> idnar: for myself, I couldn't care less what Python's error messages are.
08:30:09 <quicksilver> I do care that haskell's are bad for newbies. though.
08:30:24 <vixey> Haskell error messages are fine
08:30:45 <Peaker> vixey: then why can't newbies understand them?
08:30:46 <vixey> the number system is atrocious.....
08:30:52 <vixey> They can Peaker
08:31:17 <int80_h> I understand them just fine
08:31:22 <Peaker> vixey: Well, when I was a newbie, and all the friends I got to learn Haskell had all been boggled by error messages.. I sometimes spent hours debugging a single error message
08:31:26 <int80_h> but I don't always know what to do about it
08:31:48 <vixey> ok so it took you time to learn something new
08:32:11 <int80_h> @src cycle
08:32:11 <Peaker> I guess the solution is to have the code editor only let you construct type-correct programs :)
08:32:11 <lambdabot> cycle [] = undefined
08:32:11 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:32:23 <Peaker> so there are no type errors in the first place :-)
08:32:35 <vixey> did you try Epigram 1?
08:32:43 <Peaker> nope
08:32:48 <Saizan> the fact is that in the general case you can't give much nicer error messages (e.g. what if putStrLn was polymorphic in the monad?), so you need to add special cases to get sensible messages when you can
08:32:50 <int80_h> @type cycle
08:32:51 <lambdabot> forall a. [a] -> [a]
08:32:54 <vixey> Peaker, you must!
08:33:08 <idnar> Peaker: well, there's some stuff to do with method argument handling, for example: http://paste.ubuntu.com/108630/
08:33:08 <Peaker> @go Epigram 1
08:33:16 <lambdabot> http://www.nabble.com/Epigram-1-for-6.5-td6704628.html
08:33:16 <lambdabot> Title: Nabble - Epigram - Epigram 1 for 6.5
08:33:16 <quicksilver> vixey: no, they're not. They're dire.
08:33:33 <quicksilver> Saizan: yes, that's certainly the problem.
08:33:38 <Peaker> idnar: those are very clear, imo
08:33:50 <vixey> quicksilver, the closer they are to the actual type errors the better -- this way you can be methodical about fixing things
08:33:55 <idnar> Peaker: they make absolutely no sense at first glance
08:33:56 <Peaker> idnar: because of the (this is what really happened) part
08:34:06 <vixey> quicksilver, I mean actual violations of the type rules
08:34:07 <idnar> Peaker: in the first one, I've passed 5 arguments, and it's telling me I passed 6
08:34:13 <BONUS> what about adding some guessing into the error messages, maybe if fnewbie-errors is turned on or something. so that it gives an error message and then says: this might be because X or because Y
08:34:20 <BONUS> and X and Y are more specific cases
08:34:21 <idnar> Peaker: once you understand why it's happening, there's no problem, but the same goes for the Haskell messages mentioned earlier
08:34:28 <quicksilver> Peaker: count the numbers ;)
08:34:36 <idnar> (and in general, is a tautology; if you know what's happening with an error, then it's no longer confusing :P)
08:34:37 <quicksilver> Peaker: "foo() takes at most 5 arguments (6 given)
08:34:42 <quicksilver> Peaker: but he gave it 5 args.
08:34:44 <quicksilver> not 6.
08:34:45 <Peaker> quicksilver: yeah, I know - the implicit partial application Python has confuses the number
08:34:54 <quicksilver> OK, so you see the problem.
08:35:01 <quicksilver> I agree with idnar, those are poor messages.
08:35:02 <Peaker> quicksilver: but the fact it tells you that the partial application happened eases that confusion
08:35:21 <BONUS> Python could really fix the reporting of implicit self when you pass arguments to functions
08:35:28 <quicksilver> vixey: you can only be methodical about fixing things if you understand the whole of the type system pretty well.
08:35:45 <idnar> Peaker: well, it's more than that
08:35:51 <quicksilver> vixey: I do not want haskell to be a language where you need to understand the whole of the type system to understand the error you get in your first failed program.
08:35:52 <vixey> quicksilver, I know that takes time to learn intuitively but there is not any other way to write type correct programs
08:36:02 <quicksilver> I dispute that.
08:36:10 <idnar> Peaker: the root of the problem is that the TypeError you get from invoking a callable with the wrong signature doesn't give you the information you need to understand what went wrong
08:36:15 <quicksilver> this channel is full of people who write type correct programs without understanding the whole of the type system.
08:36:19 <vixey> quicksilver, it is the same without types, you can only write syntactically correct programs once you know the syntax of a language
08:36:22 <quicksilver> I help such people write programs every day.
08:36:39 <idnar> Peaker: it gets worse when super() is involved, because the signature you messed up isn't even the function you're actually invoking
08:36:45 <Peaker> idnar: would it be better if instead of saying 5, 6  it said: "One too many arguments"?
08:36:50 <quicksilver> it's not unreasonable to suggest the messages could be better.
08:37:09 <idnar> Peaker: I think it would suffice if it showed you the signature of the function where the mismatch actually occurs
08:37:10 <quicksilver> Peaker: it would be better if it said (6 including the implict arg 'self')
08:37:16 <quicksilver> but let's not spend too long talking about python.
08:37:23 <quicksilver> the interesting point is the haskell messages ;)
08:37:30 <Peaker> idnar: I think the only really poor Python TypeError is the one where the actual function that you're calling is neither in the traceback nor identifiable by the name (something like __init__ takes ...  Which Init??)
08:37:38 <Peaker> quicksilver: yeah :)
08:37:51 <vixey> quicksilver, yeah everyone wants stuff to be 'better', I wasn't disputing that..
08:38:31 <vixey> quicksilver, I don't like the idea of pulling 'examples' out of common situations because when you leave Kansas this is going to work against you
08:38:35 <quicksilver> Peaker: btw, here is the graph which says that GHC is 33% C
08:38:37 <quicksilver> Peaker: https://www.ohloh.net/p/ghc/analyses/latest
08:38:42 <quicksilver> Peaker: myself, I don't believe it is true.
08:39:13 <int80_h> is cycle supposed to be an infinite loop?
08:39:20 <int80_h> or am I using it wrong?
08:39:22 <idnar> Peaker: http://paste.ubuntu.com/108643/
08:39:31 <idnar> anyhow, I've gotten sidetracked
08:39:40 <BONUS> int80_h: yeah it is, you have to cut it somewhere
08:39:45 <idnar> my original point was that people tend to become "blind" to bad error messages they've gotten used to
08:39:52 <BONUS> > take 10 . cycle $ [1,0,1]
08:39:53 <lambdabot>   [1,0,1,1,0,1,1,0,1,1]
08:40:35 <idnar> so when people come across something new, they complain about the sharp edges
08:41:03 <idnar> but once it's been "established" for a while, people get so used to avoiding the sharp edges that they've forgotten about their presence
08:41:03 <int80_h> BONUS, what does $ mean?
08:41:08 <Twey> C++'s error messages, for example :-P
08:41:38 <idnar> so it's a good idea to take notice of the sharp edges when people do notice them, rather than trying to sweep them under the carpet
08:41:43 <loadquo> @src $
08:41:43 <lambdabot> f $ x = f x
08:42:02 <sbahra> quicksilver, https://www.ohloh.net/p/firefox/analyses/latest
08:42:11 <SamB_irssi> hey, there's some spam in the haddock trac
08:42:29 <SamB_irssi> the titles of some of the low-priority tickets, in particular, have been spammed into ...
08:42:31 <int80_h> well, break out the eggs!
08:42:31 <vixey> Peaker found it yet?
08:42:32 <idnar> to put it another way, Haskell's error messages aren't just bad for newbies
08:42:56 <SamB_irssi> look at the bottom of http://trac.haskell.org/haddock/report/1 ...
08:42:59 <Peaker> vixey: nope
08:43:00 <idnar> the fact that an experienced Haskell programmer sees a particular error message and goes "aha, it must be problem X!" because they're used to associating the two things, does not mean that it's a good error message
08:43:12 <SamB_irssi> idnar: indeed
08:43:13 <ozy`> I for one would like it if the GHC messages were just worded a little more nicely... "expected argument of type X, but inferred value of type Y"
08:43:19 <vixey> k I guess you aren't really interested or something
08:43:34 <Peaker> vixey: sorry, a bit busy with other stuff atm
08:43:35 <dmead> #hoogle arm
08:43:39 <dmead> @hoogle arm
08:43:39 <lambdabot> Distribution.System Arm :: Arch
08:43:39 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
08:43:43 <SamB_irssi> ozy`: it isn't always an argument though ...
08:43:53 <Axman6> @hackage HARM
08:43:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HARM
08:43:55 <dmead> dons, here?
08:44:08 <Axman6> my one and only package :) (which i didn't write :()
08:44:11 <ozy`> SamB_irssi: then the wording can be adjusted as appropriate
08:44:22 <idnar> for example, "Couldn't match expected type `t1 -> t' against inferred type `IO ()'" actually means "you tried to apply too many arguments to something"
08:44:48 <idnar> I'm not suggesting the latter as an alternative message, but a message that carried that information would be a lot more useful
08:44:51 <vixey> idnar, how did you get this error message?
08:44:58 <idnar> :t putStrLn 1 2
08:44:59 <lambdabot>     Couldn't match expected type `t1 -> t'
08:44:59 <lambdabot>            against inferred type `IO ()'
08:45:08 <idnar> quicksilver gave that example eralier
08:45:09 <idnar> *earlier
08:45:20 <vixey> quicksilver cheated :p
08:45:23 <vixey> :t putStrLn (1 :: Int) (2 :: Double)
08:45:25 <lambdabot>     Couldn't match expected type `String' against inferred type `Int'
08:45:25 <lambdabot>     In the first argument of `putStrLn', namely `(1 :: Int)'
08:45:36 <idnar> :t putStrLn "1" "2"
08:45:37 <lambdabot>     Couldn't match expected type `[Char] -> t'
08:45:37 <lambdabot>            against inferred type `IO ()'
08:45:39 <idnar> same difference
08:45:40 <vixey> the reason you get bad error messages is because the numeric system is atrocious
08:45:48 <idnar> ^^^ no numeric system involved
08:46:02 <idnar> I was mainly focusing on the application aspect, not Num instances
08:46:15 <quicksilver> overloading certainly makes the error messages wors
08:46:20 <quicksilver> but you can get some bad ones without it
08:46:38 <idnar> anyhow, in lieu of actually fixing the error messages, having some documentation to help you understand what you did wrong when you get a certain error message would also be helpful
08:46:43 <quicksilver> indentation errors in multiline do blocks lead to pretty weird stuff
08:46:44 <idnar> although such documentation tends to be rather embarassing
08:46:56 <int80_h> myCycle x = foldr head [] x, this gets an "cannot construct an infinite type error"
08:47:13 <SamB_irssi> idnar: perhaps having the compiler SUGGEST that it might be that would be appropriate ?
08:47:16 <quicksilver> (sometimes but not always related to overloading)
08:47:17 <int80_h> a = [[a] -> [a]]
08:47:25 <skorpan> i seem to recall reading some haskell code somewhere with "whenM" but i couldn't find it on hoogle. any ideas?
08:47:27 <SamB_irssi> I think it already does that sort of thing sometimes ?
08:47:30 <quicksilver> the infinite type one is hard to solve IMO.
08:47:33 <quicksilver> SamB_irssi: it does, yes.
08:47:42 <quicksilver> @hoogle when
08:47:42 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:48:00 <skorpan> no, whenM. i think that would be Monad m => m Bool -> m () -> m ()
08:48:04 <quicksilver> :t let x = (1,x) in x
08:48:05 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t1, t)
08:48:05 <lambdabot>       Expected type: t
08:48:05 <lambdabot>       Inferred type: (t1, t)
08:48:05 <idnar> @foldr head [] ?x
08:48:08 <lambdabot> No match for "head".
08:48:08 <lambdabot> No match for "[]".
08:48:08 <lambdabot>  
08:48:09 <lambdabot> *** "x" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
08:48:11 <lambdabot> X
08:48:12 <quicksilver> skorpan: No. That one isn't anywhere.
08:48:12 <idnar> oops
08:48:13 <lambdabot> [20 @more lines]
08:48:14 <int80_h> any feedback?
08:48:17 <idnar> @type foldr head [] ?x
08:48:18 <lambdabot> forall a. (?x::[[[a] -> [a]]]) => [a]
08:48:33 <quicksilver> int80_h: oh, sorry, I thought you were contributing to the discussion on bad error messages :)
08:48:39 <int80_h> I'm trying to fold head on x
08:48:41 <quicksilver> int80_h: I didn't realise that was a genuine question.
08:48:46 <Axman6> wtf is Occurs check: supposed to mean anyway? doesn't even really make grammatical sense
08:49:00 <int80_h> no worries, trying to construct cycle
08:49:06 <int80_h> using foldr
08:49:14 <idnar> Axman6: I assume the "Occurs check" is something to do with checking that types occur
08:49:26 <quicksilver> pretty sure you won't want 'head' to construct cycle.
08:49:43 <int80_h> hmm
08:49:49 <idnar> I think the biggest problem with that error is that it's hard to figure out where it arises
08:50:19 <idnar> ie. what and where the heck are t and t1?
08:50:50 <quicksilver> idnar: and what the heck is an infinite type, and who says I wanted one? ;)
08:51:02 <quicksilver> :t \x -> x == (x,0)
08:51:03 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, t)
08:51:03 <lambdabot>       Expected type: a
08:51:03 <lambdabot>       Inferred type: (a, t)
08:51:11 <vixey> nobody wants an infinite typ
08:51:21 <quicksilver> idnar: that's a bit of a contrived example, but you get infinite type errors with stuff that looks nothing like recursion.
08:51:22 <Saizan> hah, everyone should take a course on implementing prolog, so you'd know what the occurs check is ;)
08:51:55 <quicksilver> infinite type errors can arise through a simple typo, it's a bit sad.
08:52:03 <idnar> quicksilver: yeah, I think it's quite easy to accidentally run into one of those by nesting incorrectly or leaving something out
08:52:18 <idnar> and now you're staring at this multiline expression trying to figure out where on earth this "infinite type" is
08:52:25 <quicksilver> vixey: I would claim that's a bad error even if you understand the type system, in fact.
08:52:33 <vixey> what do you want it to say instead ?
08:52:37 <quicksilver> I don't know.
08:52:43 <idnar> I mean, heck, I know exactly what an infinite type is, and why it's a problem
08:52:46 <quicksilver> I said at the beginning that this problem is hard, and I don't have the answers.
08:52:54 <vixey> I have the answer :p
08:52:56 <idnar> but that still doesn't help me find the problem buried in five lines of code
08:52:56 <quicksilver> if I had better suggestions I'd have emailed SPJ 3 years ago.
08:53:28 <quicksilver> someone should make a name and shame - bad type errors list
08:53:43 <quicksilver> and try to get some community suggestions on how they can be more clearly described
08:54:32 <BMeph> vixey: No everyone wants an infinite type, they just don't have a consistent way to get the compiler to handle it. Except maybe Tim Sheard... ;)
08:55:31 <BMeph> Saizan: I'd call that (implementing Prolog) Cruel and Unusual Punishment. We have laws against that in the US. ;)
08:55:33 <quicksilver> there's always ocaml -rectypes
08:55:42 <Peaker> quicksilver: I think it should say: "== takes two arguments of the same type, but x and (x,0) were given, and they can't possibly be the same type"
08:55:54 <quicksilver> BMeph: and, as of yesterday, it's become clear you actually intend to abide by them ;)
08:56:10 <quicksilver> Peaker: Yes. I think something along those lines.
08:56:34 <vixey> why not "Oh fiddlesticks, this isn't working lets have a cup of tea"?
08:56:38 <Nafai> I've got a couple of currently pure functions that use a Data.Map instance that I would like to serialize to save and load from disk so that I keep using it from run to run of my program
08:56:55 <quicksilver> Peaker: although I doubt the unification algorithm is storing enough information to remember where constraints "came from"
08:57:06 <Nafai> http://github.com/Nafai77/recent-feeds/blob/8327e863eeb5ac947a37d7e8d7ebf2fe3794c5ee/recent-feed.hs <- deDupItems an deDupItems'
08:57:06 <quicksilver> vixey: why not contribute to the discussion, or ignore it
08:57:27 <quicksilver> Nafai: the most naive way is to 'show' the items to a text file and 'read' them from it
08:57:28 <Nafai> Is there an easy way to wrap those function in something that handles that while maintaining their purity?
08:57:30 <vixey> I thought I was contibuting I guess my opinion is invalid or something though
08:57:41 <quicksilver> Nafai: that should work fine for small-medium sized maps
08:57:51 <int80_h> @src cycle
08:57:52 <lambdabot> cycle [] = undefined
08:57:52 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:57:59 <Nafai> quicksilver: *nods*.  I was considering using Data.Binary.  I was worried more about the purity.
08:58:08 <Nafai> I tried an experiment earlier
08:58:11 <quicksilver> vixey: "Oh fiddlesticks this isn't working" was not a contribution to the discussion on how to get a better error message.
08:58:26 <vixey> quicksilver: I was pointing something out
08:58:38 <Nafai> For some reason, when I added the IO monads to those functions (returning IO [Item]) I got stack overflows
08:58:39 <Saizan> vixey: there are way better ways to express your opinion
08:58:39 <quicksilver> and the thing you were pointing out was?
08:58:43 <Nafai> But that was the only thing I had changed
08:58:54 <quicksilver> Nafai: you don't want to add the IO monad to those functions.
08:59:04 <quicksilver> Nafai: you jsut want a thin wrapper which reads teh map at the beginning
08:59:05 <Nafai> Yeah, I know :)
08:59:09 <quicksilver> Nafai: and writes it out at the end
08:59:15 <quicksilver> Nafai: and let the pure stuff stay pure.
09:00:07 <vixey> taking a step away from the actual type rules of the language, by trying to make meaningful errors from common situations is obfuscation -- was trying to point it out by taking that to the logical conclusion
09:00:35 <islon_s> i want to do a while like this
09:00:36 <islon_s> while :: Bool -> IO a -> IO a
09:00:36 <islon_s> while test action
09:00:36 <islon_s> 	| test == True = action `seq` while test action
09:00:39 <islon_s> 	| otherwise = action
09:00:47 <vixey> quicksilver, but maybe I have a track record for saying nonsense without thinking?
09:00:51 <islon_s> but it doesnt work =/
09:01:05 <quicksilver> vixey: In my opinion you do not.
09:01:12 <jeltsch> Hello, who is responsible for the software behind Hackage?
09:01:15 <vixey> islon_s, I don't think `seq` is the right thing, but (>>) instead
09:01:17 <ozy`> islon_s: you want >>= instead of seq.
09:01:21 <ozy`> er, >>
09:01:25 <jeltsch> type-level has a strange build failure (internal Haddock or GHC error).
09:01:27 <Saizan> vixey: but we're only trying to get more information from the typechecker about what has gone wrong, not taking guesses
09:01:37 <idnar> @type whileM
09:01:38 <lambdabot> Not in scope: `whileM'
09:01:42 <jeltsch> Therefore type-equality-check cannot be build (type-level is missing).
09:01:43 <loadquo> Perhaps you could have urls to wikis with details on what the specific error means and common places that it might occur.
09:01:50 <quicksilver> vixey: But that particular interjection came across as saing "what you are doing is stupid", rather than suggesting how we might do it better.
09:01:50 <athos> @index whileM
09:01:50 <ozy`> @hoogle whileM
09:01:51 <lambdabot> bzzt
09:01:51 <lambdabot> No results found
09:02:04 <idnar> uhm
09:02:13 <loadquo> In the error messages that is.
09:02:13 <idnar> @type until
09:02:14 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
09:02:16 <jeltsch> Therefore most Grapefruit packages won’t be built when they are released since most depend on type-equality-check.
09:02:19 <quicksilver> islon_s: changing seq to >> will make that look better, but the nature of 'Bool' is that if once true, it will be always true.
09:02:20 <jeltsch> This is really odd.
09:02:24 <idnar> hmm, no
09:02:24 <vixey> quicksilver, it is stupid to use typical situations to build error messages
09:02:39 <islon_s> i thought the lazyness will do the job...
09:02:43 <quicksilver> islon_s: so that's either going to loop forever, (for True) or not at all (for False)
09:02:44 <islon_s> *would
09:02:51 <islon_s> it loops forever
09:02:53 <vixey> it might seem pragmatically sensible but it's obfuscation
09:03:05 <koeien> islon_s: :) the problem is that, say you pass (37^2 == 1369) to the function, it will always be True
09:03:17 <idnar> quicksilver: wouldn't there be a new test each time?
09:03:24 <idnar> oh
09:03:26 <idnar> whoops, misread
09:03:31 <islon_s> i passed c /= 'e' and in the action i do c <- getChar
09:03:32 <Peaker> vixey: I don't think its stupid, many people find it easier to generalize from the concrete than directly work with the general
09:03:35 <quicksilver> vixey: Error messages are a question of user interface; it doesn't seem stupid to use examples to understand how a UI works.
09:03:37 <idnar> you'd need (a -> Bool) -> IO a -> IO a or something
09:03:54 <athos> @src until
09:03:54 <lambdabot> until p f x | p x       = x
09:03:54 <lambdabot>             | otherwise = until p f (f x)
09:03:54 <koeien> islon_s: such a thing is not possible.
09:04:07 <quicksilver> vixey: Also, if you provide both the 'technical' explanation (in all cases, uniformly) as well as a better hint (which only works in some simple cases)
09:04:20 <ozy`> islon_s: any time you have two IO actions you want connected, you have to sequence them with >> or >>=
09:04:25 <quicksilver> vixey: that may be a tool by which new programmers come to understand the technical explanation in the context of examples they understand.
09:04:35 <quicksilver> and actually, that's exactly what GHC does
09:04:39 <ozy`> islon_s: that includes the loop function itself
09:04:41 <quicksilver> (it has heuristic hints for certain cases)
09:04:45 <koeien> i like the new GHC improvements in that regard
09:04:48 <quicksilver> although I forget exactly which ones.
09:04:49 <islon_s> ozy`: i'm still trying to understand IO / monads
09:05:14 <quicksilver> islon_s: (c /= 'e') refers always to the c you read the first time
09:05:19 <Peaker> quicksilver: "maybe you applied too few arguments" and these?
09:05:20 <quicksilver> islon_s: because variables don't change
09:05:26 <quicksilver> Peaker: yes, those are the ones
09:05:32 <int80_h> crap
09:05:35 <islon_s> so its really not possible
09:05:42 <quicksilver> islon_s: it's possible, just not how you wrote it.
09:05:53 <koeien> islon_s: yes, certainly!
09:05:54 <quicksilver> you have to pass (e.g.) the action or test you want to run
09:05:58 <quicksilver> not the result of it
09:06:05 <islon_s> i have to use a (t -> Bool) function instead...?
09:06:07 <quicksilver> (c /= 'e') :: Bool is a result
09:06:20 <quicksilver> "t -> Bool" or "IO Bool" or "m Bool"
09:06:22 <ozy`> islon_s: that's right
09:06:22 <quicksilver> for example
09:06:25 <quicksilver> might be the types of tests
09:06:30 <roconnor> > 9**(1/25)
09:06:32 <lambdabot>   1.0918668996138925
09:06:34 <quicksilver> (t -> Bool) is probably the simplest example.
09:06:44 <koeien> i would go with (a -> Bool)
09:07:14 <islon_s> quicksilver: so IO Bool?
09:07:19 <koeien> something like,   while :: (a -> Bool) -> IO a -> IO [a]
09:08:16 <koeien> :t   while p m = m >>= (\x -> x: if p x then while p m else [])
09:08:17 <lambdabot> parse error on input `='
09:08:30 <koeien> @def   while = m >>= (\x -> x: if p x then while p m else [])
09:08:30 <lambdabot> Maybe you meant: bf let
09:08:31 <Nafai> quicksilver: Could you look at my latest?  I'm getting a stack overflow error: http://github.com/Nafai77/recent-feeds/blob/53c8dca7221f5d89b85d3e0d75fead6ff2c0ec23/recent-feed.hs
09:08:37 <koeien> @let   while = m >>= (\x -> x: if p x then while p m else [])
09:08:37 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
09:08:39 <quicksilver> :t let while p m = m >>= (\x -> x: if p x then while p m else []) in while
09:08:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:08:43 <Nafai> A Stack space overflow error
09:08:51 <quicksilver> ^^ that's what you meant, koeien
09:08:59 <koeien> quicksilver: eh yeah
09:09:24 <koeien> but why is the type not monadic? :/
09:09:32 <Peaker> @pl \(p, s) -> (p, p+s)
09:09:32 <lambdabot> uncurry (liftM2 (.) (,) (+))
09:09:36 <int80_h> I have a two line program, can I paste here?
09:09:52 <vixey> koeien, []
09:09:59 <koeien> ah right.
09:10:00 <quicksilver> Nafai: let items = deDupItems items seenMap
09:10:03 <koeien> return and stuff :)
09:10:08 <sbahra> int80_h, sure
09:10:16 <quicksilver> Nafai: is a recursive binding
09:10:20 <int80_h> myCycle x = foldr (:) x y
09:10:24 <quicksilver> Nafai: the items on the left is the items on the right.
09:10:26 <int80_h>    where y = myCycle x
09:10:27 <Nafai> Whoops
09:10:28 <Nafai> Duh :)
09:10:38 <quicksilver> Nafai: probably you want something like let itemsDeDupped = deDupItems items seenMap
09:10:39 <Twey> > until (> 5) (+1) 0
09:10:41 <lambdabot>   6
09:10:41 <int80_h> now, this gets me a stack overflow, instead of the behavior I want
09:10:42 <ziman> uncurry (liftM2 (.) (,) (+)) -- this is beyond my comprehension
09:10:58 <vixey> int80_h, why are you using foldr with (:) instead of just (++) ?
09:11:12 <ozy`> :t uncurry $ liftM2 (.) (,) (+)
09:11:13 <lambdabot> forall a. (Num a) => (a, a) -> (a, a)
09:11:21 <quicksilver> ziman: well the first thing to notice is that the uncurry forces a particular choice of monad for the liftM2
09:11:25 <quicksilver> :t liftM2
09:11:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:11:31 <ozy`> @pl uncurry $ liftM2 (.) (,) (+)
09:11:31 <lambdabot> uncurry (liftM2 (.) (,) (+))
09:11:35 <ozy`> eh
09:11:36 <vixey> :t fix . (++)
09:11:36 <Twey> ziman: \(x, y) -> (+ y) . (, x)
09:11:38 <lambdabot> forall a. [a] -> [a]
09:11:46 <sbahra> int80_h, http://haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
09:11:50 <ray> that uncurry $ liftM2 thing was pl'd up in the first place
09:11:51 <ozy`> @let snafuFubar = uncurry $ liftM2 (.) (,) (+)
09:11:52 <lambdabot>  Defined.
09:11:53 <int80_h> vixey, : does what I want. When I don't try the recursion I get [1,2,3,1,2,3]
09:11:55 <Twey> (except that tuple-sections aren't allowed, eh)
09:12:00 <Saizan> int80_h: that code is equivalent to "let x = x ++ x in x"
09:12:02 <quicksilver> ziman: liftM2 returns something "m r", but uncurry expects a function
09:12:04 <sbahra> @wiki Fold
09:12:04 <lambdabot> http://www.haskell.org/haskellwiki/Fold
09:12:07 <ozy`> > snafuFubar (3, 7)
09:12:08 <lambdabot>   (3,10)
09:12:10 <quicksilver> ziman: so that forces the monad to (->)
09:12:20 <vixey> int80_h, but your function doesn't work.....
09:12:22 <quicksilver> ziman: then you just have to understand the monad instance for (->)
09:12:31 <quicksilver> and see what liftM2 does for that particular monad.
09:12:45 <int80_h> vixey:> but it didn't look to me that : was the problem
09:12:45 <Nafai> quicksilver: Anything else obvious?  I'm still getting the stack space error
09:12:52 <vixey> int80_h, ok
09:13:01 <vixey> int80_h, I suggest you use (++) and not foldr with (:) though
09:13:57 <ziman> quicksilver, Twey, thanks, now i get it
09:14:08 <ziman> Twey, your example is flipped, i think
09:14:09 <int80_h> vixey : okay
09:14:23 <Twey> Possibly, I can never remember
09:14:28 <ray> :t (,)
09:14:29 <lambdabot> forall a b. a -> b -> (a, b)
09:14:30 <ziman> @pl \(x,y) -> (,x) . (+y)
09:14:31 <lambdabot> (line 1, column 12):
09:14:31 <lambdabot> unexpected ","
09:14:31 <lambdabot> expecting lambda abstraction or expression
09:14:31 <koeien> int80_h: 'foldr (:) x y' == 'y ++ x'.
09:14:38 <Twey> No tuple sections
09:14:41 <Twey> ((,) x)
09:14:43 <ziman> @pl \(x,y) -> flip (,) x . (+y)
09:14:44 <lambdabot> uncurry ((. (+)) . (.) . flip (,))
09:14:52 <ziman> uh oh
09:14:58 <ozy`> ziman: sadly, you can't do (,x) as with normal operators
09:15:07 <Twey> > liftM2 (+) (*) (+) 3 2
09:15:08 <lambdabot>       No instance for (Num (a -> a))
09:15:08 <lambdabot>        arising from a use of `+' at <int...
09:15:10 <Twey> Bah
09:15:29 <skorpan> how do i check whether a given FilePath is a link (symlink or normal)
09:15:36 <Saizan> int80_h: the problem with foldr (:) x y where y = myCheck x is that to reduce the foldr it has to inspect y, so it has to inspect myCheck x which reduces the foldr which inspects y.. so it gets stuck into an infinite loop
09:15:38 <Twey> @pl \x y -> x * 2 + y
09:15:38 <lambdabot> (+) . (2 *)
09:15:51 <Twey> Ack
09:15:54 <Twey> I can't think straight
09:16:12 <skorpan> lambdabot is amazing.
09:17:59 <ozy`> lambdabot will only break your heart
09:18:54 <roconnor> > deriv (\x -> sin x + (cos x)^2) x
09:18:56 <lambdabot>   1 * cos x + (1 * negate (sin x) * cos x + cos x * (1 * negate (sin x)))
09:19:13 <ray> :t deriv
09:19:15 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
09:19:15 <int80_h> Saizan : thanks :)
09:20:38 <BMeph> quicksilver: Care to enter the first example for http://www.haskell.org/haskellwiki/Bad_type_errors ? :)
09:21:13 <wli> Simplification is another issue entirely.
09:21:29 <wli> e.g. what's meant by simplification?
09:21:49 <Saizan> Nafai: in deDupItems' you're using a Map as an accumulator and count as one too
09:22:23 <Nafai> Hrm?
09:22:52 <Nafai> I want to add items to the map as I see them.  The value in the map is the number of times I have seen them
09:22:59 <Nafai> So I update with the correct count
09:22:59 <Saizan> yeah
09:23:18 <wli> 1 * cos x --> cos x is pretty obvious, but 3 * cos x + 4 * sin x vs. 5*sin(x + arctan(3/5)) is another matter.
09:23:29 <cnwdup> > \EOF
09:23:31 <lambdabot>   <no location info>: parse error on input `;'
09:23:34 <cnwdup> > '\eof'
09:23:35 <lambdabot>   <no location info>:
09:23:36 <lambdabot>      lexical error in string/character literal at chara...
09:24:36 <Peaker> I think warnings about unused names should probably appear prior to type errors - often you just accidentally typo another arg or such
09:25:05 <Saizan> Nafai: sorry, i thought you didn't inspect those until the end but now i see that count is used in itemsToKeep which will be forced in the next recursion step
09:25:06 <Nafai> Saizan: Is there something wrong with that approach?
09:26:01 <Nafai> Saizan: *nods*  I didn't have problems with this until I added the serialization :)
09:26:12 <alexeevg> @info forever
09:26:12 <lambdabot> forever
09:26:23 <alexeevg> @where forever
09:26:23 <lambdabot> I know nothing about forever.
09:26:30 <Peaker> Control.Monad(forever)
09:26:39 <alexeevg> Peaker: thanks!
09:26:46 <Saizan> Nafai: aah, then it might be decodeFile's fault
09:27:20 <Nafai> I think my map might have a total of 62 entries with the data file I'm processing
09:28:45 <chessguy_work> 'ello
09:28:58 <Saizan> Nafai: try "fmap decode (L.readFile seenMapFile)"
09:29:39 <loadquo> Is there a cogent discussion of when to use IOUArrays vs STUArrays anywhere?
09:29:47 <Nafai> Saizan: Actually, this will be on the first run when there isn't a file, so perhaps it is in the encode
09:29:52 <Nafai> I need the correlarly
09:29:55 <Nafai> (sp?)
09:30:09 <Saizan> there was a thread on -cafe about problems with Map's Binary instance, iirc
09:30:40 * Nafai searches
09:31:08 <rwbarton> loadquo: Use STUArrays in computations that are otherwise pure (besides using mutable arrays) if you want to wrap up the entire computation as a pure function.
09:33:08 <loadquo> Thanks. IOUArrays for me then, I think.
09:33:28 <quicksilver> loadquo: STUArrays by preference; IOUArrays when you have to intersperse IO with the array access.
09:34:39 <Nafai> Saizan: Thanks, I think I found the thread.
09:34:45 <loadquo> quicksilver: I'm writing a machine emulator so I will have IO from interrupts. Or rather I should probably say I am trying to see how a machine emulator would be written.
09:35:07 <loadquo> In haskell.
09:35:19 <quicksilver> if your emulator is pure the interrupts could be pure
09:35:27 <quicksilver> but yes, normally, you'd expect them to be in IO.
09:38:47 <rwbarton> It's also possible to run ST actions from IO, so if you write all your array processing in ST and then discover you do need IO after all, it won't be the end of the world
09:39:58 <rwbarton> , src ''IO
09:40:01 <lunabot>  newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a)
09:40:06 <rwbarton> , src ''ST
09:40:09 <lunabot>  newtype ST s a = ST (STRep s a)
09:42:32 <chessguy_work> so what's up with thihs AST stuff. are we working towards getting a macro system in place?
09:42:34 <loadquo> I'd prefer to write the Array functions as Pure, but thinking about one type of monad is enough for me at the moment.
09:43:27 * wli hopes for more Arrow tutorials.
09:43:27 <Saizan> AST stuff?
09:43:39 <chessguy_work> isn't lunabot spitting out ASTs?
09:44:57 <papermachine> A macro system would make my head collectively explode.
09:45:13 <ray> "collectively" because it's already exploded?
09:45:15 <chessguy_work> you have a collection of heads?
09:45:42 <ozy`> his head is a hivemind
09:45:46 <islon_s`> collective :: Head -> [Head]
09:45:50 <ozy`> hive...head?
09:46:24 <papermachine> Our name is Legion, for we are many.
09:46:46 * Gracenotes sends papermachine to the river
09:46:53 * papermachine oinks.
09:46:53 <Peaker> wli: who uses arrows?
09:47:12 <Peaker> arrows need to be redesigned
09:47:47 <Nafai> Bleh, this should be easier
09:48:34 <Peaker> I think something like: class Arrow a where swap, fst, snd  -- and no arr!  swap/fst/snd should be implemented as if they were (arr swap, arr fst, arr snd) but allows more types to be arrows because general "arr" need not be supported
09:49:15 <lilac> what do people think of this code for breadth-first tree numbering: http://haskell.pastebin.com/m33510595
09:49:34 <Gracenotes> I've heard about arr being inconvenient before -- what kind of issues result from requiring it?
09:50:41 <Peaker> Gracenotes: its not about convenience, its about making many things not arrow'able
09:50:56 <Peaker> Gracenotes: I think a bidirectional computation could be an arrow if not for "arr"
09:50:57 <Gracenotes> such as?
09:51:10 <Gracenotes> oh. hm
09:51:12 <Peaker> Gracenotes: such that you can run the arrow computation in either direction
09:51:52 <Peaker> Gracenotes: there are many other examples, but I can't recall now. I think *most* ideas I have seen that mapped to arrows had no possible "arr"
09:52:39 <chessguy_work> @quote pirate
09:52:40 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
09:52:40 <true\false> How do people rate Real World Haskell as an intro into Haskell + Functional programming?
09:52:41 <Peaker> Gracenotes: If the Arrow type-class is meant to allow non-functions to be considered computations, then "arr" completely ruins it, because it requires that these non functions can express anything a turing-complete function can - which means they can represent anything at all
09:52:46 <kiris> oh man, this huge emacs lisp function is so hard to understand
09:52:58 <kiris> I can't read functions longer than a page anymore ;_;
09:53:10 <BONUS> true\false: 6 out of 5 stars
09:53:10 <BONUS> imho
09:53:11 <kiris> especially imperative-as-fuck ones
09:53:29 <Twey> kiris: That's because they're crap
09:53:36 <true\false> BONUS: Heh, right .. So a good resource for an OO coder to move into Haskell?
09:53:38 <chessguy_work> lilac, is there some reason for it not to use Data.Tree?
09:53:45 <BONUS> definitely :]
09:53:53 <lilac> Gracenotes: 'arr' creates problems for arrow-based tabler-driven parsers.
09:53:57 <kiris> Twey: but I need to understand it ;____;
09:54:01 <true\false> Ok thanks, I'll just stick with it then .. Don't get a soddin' thing so far, but hey
09:54:20 <Twey> kiris: Try to refactor it... I usually find that helps :)
09:54:32 <Twey> true\false: Hehe, hey!  :)
09:54:36 <islon_s`> i didnt like rwh
09:54:58 <islon_s`> learnyouahaskell is a lot more simple and easy to follow
09:55:00 <kiris> Twey: http://www.cua.dk/ido.el -- have a look at ido-read-internal. @_____@
09:55:32 * true\false waves at Twey
09:55:35 <Gracenotes> hm. looks like the designer(s) of Control.Arrow were thinking mainly of functions
09:55:36 <Twey> islon_s`: But not nearly as in-depth
09:55:52 <Twey> Functions are the simplest arrow
09:55:54 <Gracenotes> might it have been possible to define a sub-typeclass of Arrow with arr...?
09:56:16 <chessguy_work> lilac, also, have you seen http://www.reddit.com/r/haskell/comments/7rsae/lazy_tree_traversals_for_efficiency/ ?
09:56:20 <Peaker> Gracenotes: well, "arr" has been moved to the Control.Category.Category class
09:56:28 <Peaker> Gracenotes: so all it takes is for Arrow not to subclass it
09:56:34 <islon_s`> Twey: yes, but rwh is not designed for OO people
09:56:37 <lilac> chessguy_work: no reason to not use Data.Tree, but it was just a quick sketch
09:56:42 <Peaker> Gracenotes: but then Arrow does need implementations of swap and fst, instead
09:56:45 <Gracenotes> ah. That works
09:56:49 <chessguy_work> lilac, ok, just wondering
09:56:53 <Gracenotes> hm
09:56:54 <Twey> Yuck, imperative :-P
09:56:57 <Twey> islon_s`: Doesn't matter
09:57:30 <Twey> OO is not a paradigm at the same level as functional/imperative
09:57:33 <kiris> Twey: it's worse than that;   dynamic variables
09:57:43 <Twey> What most people think of as OO is basically just imperative
09:57:45 <BONUS> idnt like rwh
09:57:45 <BONUS> <islon_s`> learnyouahaskell is a lot more simple and easy to follow
09:57:45 <BONUS> <kiris> Twey: http://www.cua.dk/ido.el -- have a look at ido-read-internal. @_____@
09:57:45 <BONUS> * true\false waves at Twey
09:57:45 <BONUS> <Gracenotes> hm. looks like the designer(s) of Control.Arrow were thinking mainly of functions
09:57:46 <BONUS> <Twey> islon_s`: But not nearly as in-depth
09:57:48 <BONUS> whoops
09:57:53 <Twey> It's not hard to set aside
09:57:53 <BONUS> sorry y'all
09:57:55 <BONUS> meant to paste this
09:57:56 <BONUS> let (t', m) = rpMin (t, m) in t'
09:57:58 <Twey> Haha, BONUS
09:58:13 <Twey> BONUS: 'ey, what's this I hear about you telling people Haskell's crap for game dev?
09:58:23 <BONUS> welp
09:58:26 <true\false> Oh sorry.. I missed all of that the first time
09:58:26 <BONUS> haha did i say that?
09:58:28 <kiris> methinks BONUS is pasting our logs to people, analysing our thoughts
09:58:32 <Twey> Apparently
09:58:44 <Surma> hey guys. I have a list of tuples, and I want to sort by second part of these tuples. Is there some way of doing that using ``sort''?
09:58:47 <Gracenotes> BONUS -- a spy among us
09:58:48 <ray> it'd be more efficient to just give those people a link to the official logs!
09:58:52 <Twey> Something about games being all about manipulating state, and Haskell incapable of working with state
09:58:55 <BONUS> probably got misunderstood, i said it's more naturaly to me (personally) to develop games in stuff like Python than in Haskell :]
09:59:03 <Twey> OK :)
09:59:05 <Nafai> So is there another route to go for serialization of data other than Data.Binary and going to a DB?
09:59:14 <glguy> kiris, if you are feeling left out of the log sharing, the log is available in the topic
09:59:15 <true\false> islon_s`: I can endure some head to desk moments for a while.. As long as I get it within a week to reasonable degree.
09:59:20 <Twey> Surma: No, but there is by using sortBy
09:59:20 <BONUS> games are one of the few things left that i prefer to think about imperatively haha
09:59:36 <kiris> glguy: I know v_v
09:59:37 <Twey> > sortBy (comparing snd) [(1, 2), (3, 1), (5, 4)]
09:59:38 <BONUS> i've even started thinking about music as a function from time to frequency
09:59:39 <lambdabot>   [(3,1),(1,2),(5,4)]
09:59:41 <lilac> > sortWith (comparing snd) [(2,3), (4,1), (4,2) ]]
09:59:43 <lambdabot>   <no location info>: parse error on input `]'
09:59:44 <Kamina> Surma: there is the Data.List.sortBy function
09:59:47 <lilac> > sortWith (comparing snd) [(2,3), (4,1), (4,2)]
09:59:48 <lambdabot>   Not in scope: `sortWith'
09:59:53 <Twey> You were all too slow.  Muahahaha.
09:59:55 <lilac> bah
10:00:08 <lilac> Twey: do i get extra points for being slow /and/ wrong?
10:00:10 <Gracenotes> BONUS: hey, I made a Tetris in Haskell :P (obviously not as complicated as what you might be doing, but meh)
10:00:12 <ray> sortVia
10:00:17 <Twey> lilac: Yes, yes you do
10:00:26 * Twey gives lilac a pointy had with the letter 'D' on.  :-P
10:00:28 <BONUS> Gracenotes: rly? that's cool. do you have the source somewhere
10:00:30 <Twey> hat**
10:00:51 <ray> is that the same tetris that's on hackage?
10:00:57 <tromp__> BONUS, i wrote a connect 4 solver in haskell
10:00:58 <lilac> Twey: could have been worse, the hat could've said C++
10:01:03 <Twey> Hahaha
10:01:16 <chessguy_work> BONUS, what kind of games and why?
10:01:24 <kiris> c++ is stupid!! derp
10:01:29 <Gracenotes> BONUS: yeah... I'm still working on adding colors to blocks, but I'll give you the pre-color version :)
10:01:35 <BONUS> noice
10:01:46 <Kamina> Surma: sortBy (\a b -> compare (snd a) (snd b)) [(1,9),(2,8)]
10:01:48 <BONUS> chessguy_work: i dont know, like platformers or something. you shoot a guy and he has 10 hit points less or something
10:01:54 <papermachine> Gracenotes: Is it more than IORef'ing?
10:01:57 <Kamina> Surma: with  import Data.List
10:02:00 <chessguy_work> oh, ok
10:02:07 <BONUS> i think that lends itself to imperative thinking more easily than functional
10:02:19 <Surma> thanks guys, gotta remeber that compare-function
10:02:31 <chessguy_work> BONUS, you should read HSOE
10:02:36 <Gracenotes> papermachine: it does have some IORef-ing here and there
10:02:36 <BONUS> HSOE?
10:02:44 <chessguy_work> @where hsoe
10:02:44 <lambdabot> Haskell School of Expression.
10:02:46 <ray> colorful haskell book
10:02:53 <BONUS> ooh, i've been meaning to get that
10:02:53 <chessguy_work> heh. thanks
10:02:56 <papermachine> Is it in dead tree only?
10:02:58 <chessguy_work> @where books
10:02:58 <lambdabot> I know nothing about books.
10:03:01 <chessguy_work> papermachine, yes
10:03:05 <chessguy_work> @where book
10:03:05 <papermachine> :<
10:03:05 <lambdabot> I know nothing about book.
10:03:07 * chessguy_work sighs
10:03:09 <ray> @where the haskell book with the pretty colors on it
10:03:10 <lambdabot> I know nothing about the.
10:03:10 <BONUS> prob. gonna order it once i go over RWH completely
10:03:16 <Gracenotes> papermachine: it's mainly because the callbacks are of type IO
10:03:28 <Gracenotes> er, Event -> IO Bool, even
10:03:31 <papermachine> Yeah.
10:03:34 <Twey> I want to order RWH, but I have no money :(
10:03:42 <chessguy_work> papermachine, actually, http://books.google.com/books?id=lQbth9j5j9oC&dq=haskell+school+of+expression&printsec=frontcover&source=bn&hl=en&sa=X&oi=book_result&resnum=4&ct=result
10:03:53 <chessguy_work> and BONUS ^^
10:03:58 <papermachine> chessguy_work: limited preview
10:03:58 <BONUS> w00t
10:04:08 <chessguy_work> papermachine, but better than nothing :)
10:04:23 * ray prefers dead tree books to their cost in cigarettes or coffee
10:04:40 <Twey> ray: I don't have cigarettes or coffee, either :(
10:04:46 <ray> :(
10:04:53 * Twey has £5 left in the piggy-bank.
10:05:09 <BONUS> i got RWH for relatively cheap because the pound sterling is so low compared to the euro
10:05:16 <Twey> The computer broke, so now I'm broke.
10:05:17 <BONUS> so i ordered it from amazon.co.uk
10:05:20 <Gracenotes> BONUS: here, if you can stand the gratuitous IORefs (could be refactored, possibly) http://haskell.pastebin.com/m41f7c750
10:05:36 <Twey> BONUS: Hey!  Stop raping our currency x.x
10:05:41 <BONUS> anyway, probably gonna get HSOE after finishing RWH and James D. Watson's autobiography
10:05:42 <BONUS> haha
10:05:54 <Twey> Ruddy economic collapse
10:05:55 <BONUS> Gracenotes cool :]
10:05:59 <BONUS> wil czech that out
10:06:02 <chessguy_work> Gracenotes, nice and short
10:06:13 <ray> every time your currency falls my hosting bill gets cheaper!
10:06:23 <Twey> Hahaha
10:06:33 <Gracenotes> chessguy_work: yeah, even with all the extra (unneeded) type signatures and blank lines ;)
10:06:44 <ray> it used to be almost $30 a month, now it's under $20
10:06:53 <cognominal> what are the respective strength of hayoo et hoogle?
10:07:01 <chessguy_work> Gracenotes, just because it's unneeded for the compiler doesn't make it unneeded :)
10:07:04 <ray> hoogle only does standard libraries, hayoo does hackage
10:07:15 <ray> i think
10:07:26 <BONUS> Twey: if i order stuff from amazon.co.uk, it sort of seems to me like i'm *investing* in the UK economy really
10:07:35 <arw> uh, nice, 26.99 GBP == 28.84 EUR...
10:07:39 <Gracenotes> chessguy_work: for shortness :)
10:07:52 * wli is still pondering the proper way to do in-core B+ trees in Haskell.
10:08:15 <wli> Or persistent B+ trees, for that matter.
10:08:23 <Gracenotes> now, implementing something like a dungeon-room in Haskell might be more complicated
10:08:45 <Gracenotes> which is the idea behind my next Haskell gaming-thing -- sort of a clone of a good game called DROD
10:08:56 <Gracenotes> an array of arrays, maybe?
10:09:27 <Gracenotes> or array of (Int,Int), again
10:09:45 <angelixd> gracenotes: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LambdaHack
10:10:07 <Gracenotes> *downloads src*
10:10:31 <chessguy_work> Gracenotes, this one? http://en.wikipedia.org/wiki/Deadly_Rooms_of_Death
10:10:53 <Gracenotes> chessguy_work: yeah
10:11:14 * ray should write lambdabot's mystery dungeon
10:12:26 <adrian_> @pl \x -> (x, f x)
10:12:27 <lambdabot> ap (,) f
10:12:33 <Gracenotes> hm, this individual seems to have divided his modules by the utilities of each
10:12:38 <chessguy_work> Gracenotes, that looks like it would be fun to write an AI for
10:12:40 <adrian_> @pl \x -> (f x,x)
10:12:41 <lambdabot> (,) =<< f
10:12:51 <BONUS> :t id &&& f
10:12:52 <adrian_> :t =<<
10:12:52 <lambdabot> parse error on input `=<<'
10:12:53 <lambdabot> forall a c'. (SimpleReflect.FromExpr c', Show a) => a -> (a, c')
10:13:04 <BONUS> what the heck
10:13:05 <adrian_> :t (=<<)
10:13:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:13:13 <BONUS> > (id &&& (+3)) 5
10:13:14 <lambdabot>   (5,8)
10:13:22 <Gracenotes> chessguy_work: the neat part is, the AI is basically "canon": for example, goblins move around by a specific mathematical formula, based on distance to the player.
10:13:35 <chessguy_work> Gracenotes, no, i mean AI for the good guy :)
10:13:37 <Gracenotes> and Tar has its own growth rules
10:13:40 <adrian_> :t (,)
10:13:41 <lambdabot> forall a b. a -> b -> (a, b)
10:13:51 <Gracenotes> chessguy_work: oh, yeah, people have considered doing that
10:14:07 <Gracenotes> although for large rooms it might get tricky :)
10:14:09 <adrian_> :t (,) =<< f
10:14:10 <lambdabot> forall a b. (SimpleReflect.FromExpr a, Show b) => b -> (a, b)
10:14:41 <Gracenotes> what, an Expr is a monad?
10:14:47 <chessguy_work> > 38 * 32
10:14:49 <lambdabot>   1216
10:15:20 <adrian_> I don't understand how (,) =<< f works
10:15:23 <BONUS> i think lambdabot might be a bit messed up
10:15:30 <Peaker> hmm, I need a (State s a) -> (StateT s m a)
10:15:43 <chessguy_work> @type (,) =<< ?f
10:15:44 <lambdabot> forall a b. (?f::b -> a) => b -> (a, b)
10:16:04 <Gracenotes> @instances Monad
10:16:05 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:16:16 <chessguy_work> Gracenotes, that doesn't list them all
10:16:23 <glguy> Gracenotes, no, ((->) r) is
10:16:30 <BONUS> Peaker: lift?
10:16:50 <chessguy_work> glguy!
10:16:57 <BONUS> wait nah
10:17:05 <Gracenotes> glguy: huh... I read it as f >>= (,), so f should be a monad?
10:17:06 <chessguy_work> long time no see
10:17:13 <glguy> Gracenotes, no, f is a function
10:17:37 <Peaker> BONUS: that's not quite lift
10:17:39 <mmorrow> @type \m -> let (a,s') = runState m s in put s' >> return a
10:17:40 <lambdabot> forall t (m :: * -> *). (MonadState Expr m) => State Expr t -> m t
10:17:42 <adrian_> so the -> b part of (,) is the monad?
10:17:43 <BONUS> yeah
10:17:54 <BONUS> lift is m a to t m a
10:17:55 <Gracenotes> glguy: and also a monad? :/
10:18:13 <glguy> Gracenotes, functions are the reader monad
10:18:14 <chessguy_work> Gracenotes, function application is a monad
10:18:22 <Gracenotes> okay, but you said "no" >_>
10:18:39 <mmorrow> @type \(State f) -> StateT (return . f)
10:18:40 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => State t t1 -> StateT t m t1
10:18:45 <Gracenotes> all right
10:18:56 <glguy> State? isn't that from the outdated mtl library?
10:19:00 <mmorrow> hehe
10:19:06 <glguy> time to move up to MonadLib, now with the AbortM class
10:19:17 <mmorrow> yay!
10:19:21 <BONUS> :t \(State f) -> StateT $ \s -> let (a,s') = f s in return (a, s')
10:19:23 <lambdabot> forall s (m :: * -> *) a. (Monad m) => State s a -> StateT s m a
10:19:29 <wli> What's a monad look like as an Arrow?
10:19:41 <Peaker> Maybe I could use StateT IO vs StateT Identity, but there's no conversion between those either
10:19:42 <glguy> suspend :: (AbortM m c, ContM m) => ((a -> m b) -> m c) -> m a
10:19:42 <lilac> Monad m => a -> m b
10:19:48 <Peaker> BONUS: :-P
10:20:00 <lilac> wli: ^^ that's the Kleisli arrow of a monad
10:20:01 <Peaker> BONUS: I think I ought to find a way to refactor my way out of it
10:20:04 <lament> function application seems like a very boring monad
10:20:05 * Gracenotes always forgets about the func monad
10:20:11 <mmorrow> glguy: looks stupendous
10:20:14 <glguy> Peaker, Why are you writing your values as specific to the identity monad
10:20:29 <glguy> Peaker, rather than polymorphically over all inner monads?
10:20:39 <wli> lilac: I've forgotten about Kleisli arrows, if I ever knew.
10:20:51 <Peaker> glguy: Ah, I could do that. The reason I didn't want IO as an inner monad - is because I don't have side effects, but if I'm polymorphic, its also true
10:21:03 <Peaker> glguy: (also true that I can't have side effects, that is)
10:21:09 <Peaker> glguy: so that might be a good solution :)
10:21:35 <mmorrow> > return 42 :: IO Double
10:21:37 <lambdabot>   * Exception: "<IO Double>"
10:21:39 * wli tends to end up with IO as an inner monad on a frequent basis.
10:22:12 <wli> For some reason accepting input and producing output do that to the monads.
10:22:55 <BONUS> :t m >>= g
10:22:57 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
10:22:57 <lambdabot>     In the first argument of `(>>=)', namely `m'
10:23:38 <glguy> wli, IO sneaks in there a lot, but you can still write the portions of your program that don't do any IO polymorphically and then instantiate them to IO when you use them
10:23:44 <GarethTheGreat> so, i'm guessing 10 billion noobs ask this multiple times, but - monads, wtf?
10:23:46 <glguy> (was what I was advocating for)
10:23:52 <GarethTheGreat> are they just function wrappers with multiple functions?
10:23:54 <GarethTheGreat> or am i missing something?
10:24:04 * wli tends to go no further than a MonadIO constraint and only ever specialize it to run within main.
10:24:15 <wli> glguy: That happens, sure.
10:24:18 <lilac> GarethTheGreat: they're a useful collection of functions which haskell gives convenient syntax to
10:24:47 <GarethTheGreat> lilac: so - a function library with a specific syntax?
10:25:04 <lilac> well, an interface which anyone can implement, with a special syntax
10:25:05 <GarethTheGreat> because they're more than just a monad concept
10:25:13 <GarethTheGreat> err, haskell
10:25:14 <lilac> (along with some rules for what's permitted)
10:25:17 <GarethTheGreat> more than just a haskell concept
10:25:32 <GarethTheGreat> truth be told, i'm not a haskell coder myself, but apparently haskell is the "home" of monads
10:25:34 <ddarius> The special syntax is rather unimportant cenceptually (even pragmatically to a large extent)
10:25:40 <BONUS> basically, they're a way to sequence a lot of funny things into one funny thing
10:25:41 <lilac> indeed. the structure they have happens to also be the structure of something in category theory
10:26:03 <GarethTheGreat> BONUS: so, like a function wrapper for multiple functions?
10:26:05 <lilac> which gives them various nice properties to do with adjunctions of functors :)
10:26:06 <BONUS> when you're using do notation for I/O, you're just glueing together several IO actions into one and that one will then be run when the program executes
10:26:10 <GarethTheGreat> is that a correct way to view them?
10:26:14 <ddarius> GarethTheGreat: No.
10:26:21 <GarethTheGreat> right, thought i missed something
10:26:43 <lament> GarethTheGreat: you know how in a language like C you can, in effect, combine multiple statements into a single larger statement by putting a semicolon between them? Monads are like that, except they allow you to combine whatevers into a single larger whatever.
10:26:59 <sm> has anyone tried to script logging into their bank in haskell ? do we have the libaries to do that without pain ?
10:27:25 <wli> Well, the thing to understand about monads is really monad transformers, and in particular, how unwinding monad transformer stacks lets you turn things inside-out so you get IO on the results of pure computations etc. like you want.
10:27:31 <ddarius> lilac: I'd phrase your earlier sentence more along the lines that monads were -taken- from category theory.
10:27:37 <lilac> GarethTheGreat: (work in progress) http://metafoo.co.uk/practical-monads.txt
10:27:46 <lilac> ddarius: i think that's actually kinda irrelevant
10:27:49 <GarethTheGreat> lament: putting a semicolon between things on one line just means >1 statement per line
10:27:51 <quicksilver> Hah. emacs wins again.
10:27:55 <GarethTheGreat> the syntax is not really important
10:28:03 <quicksilver> transpose-sexps rocks.
10:28:40 <conal> quicksilver: and how!
10:28:44 <chessguy_work> sm, i've never seen any library like that
10:28:46 <lilac> ddarius: anyway, i thought that these-things-are-monads came after we-need-something-with-this-type
10:29:01 <ddarius> lilac: No, that's not what happened.
10:29:03 <sm> there's that selenium thing, though
10:29:20 <quicksilver> conal: know anything about delaunay triangulations and 2D curve drawing?
10:29:21 <conal> quicksilver: also align-regexp
10:29:30 <conal> quicksilver: i don't
10:29:31 * quicksilver uses align-regexp compulsively.
10:29:40 * conal too
10:29:44 <lilac> ddarius: i read somewhere that prior to monads, haskell had some io primitives with the types of return and join
10:29:50 <quicksilver> conal: I'm trying to do something in the spirit of geometry3D, for fast 2D bezier animation.
10:29:52 <Peaker> GarethTheGreat: lets generalize on the concept of types that contain values of other types (they must be able to contain any type at all), and call them "boxes". For example, a list is a box that may contain any other type.  Such boxes may be modified and sequences together in various ways.  The most powerful of these ways is a "Monad"
10:30:04 <lilac> ddarius: but really i have no idea; i wasn't using haskell back then
10:30:18 <conal> quicksilver: cool.  let me know how it goes.
10:30:23 <quicksilver> conal: there is an awesome paper by loop and blinn which renders bezeir shapes on the GPU but I don't entirely understand it. It even does proper antialising in the pixel shader.
10:30:33 <GarethTheGreat> reading that link, it looks like monads are basically a means of metaprogramming, where your metaprograms do all your impure operations
10:30:38 <conal> quicksilver: i saw that paper.  neat stuff.
10:30:48 <lilac> GarethTheGreat: that's one thing you can do with them
10:31:00 <conal> quicksilver: i worked in that group at msr.
10:31:08 <lilac> GarethTheGreat: and indeed the IO and ST monads in haskell do just that
10:31:10 <ddarius> lilac: I doubt it, but possibly inadvertently.  Monads being applied as they are in Haskell was noticed before Haskell quite existed and certainly well before a Monad class was added (or even could be added.)
10:31:21 <GarethTheGreat> i do wonder why using metaprograms to preserve your functional purity makes any sense
10:31:56 <lilac> GarethTheGreat: it sounds like you're not sure why functional purity is valuable
10:31:59 <GarethTheGreat> surely the act of invoking your new metaprogram alters the result of the function invoking it
10:32:13 <GarethTheGreat> lilac: i understand, it makes static analysis simpler
10:32:16 <GarethTheGreat> lets you distribute stuff etc
10:32:20 <BONUS> the most important thing about monads is >>=, which says: give me a funny A and a function that takes a normal A and returns a funny B and i'll give you a funny B.
10:32:59 <quicksilver> conal: it appears to base it on the observation that all (cubic) bezier curves are projective space transforms of a particular simple one. Whcih is clever, surprising, and extraordinarily convenient given that GPUs are good at projective transforms :)
10:33:14 <Gracenotes> GarethTheGreat: for IO, everything is impure. The idea is handling pure sub-components without mixing them up. (Not the other way around.)
10:33:24 * wli points people to springschool95.ps
10:33:46 <BONUS> hey, since conal is here, gonna ask: what's the best starting point to learn about reactive?
10:33:47 <lilac> Gracenotes: i actually completely disagree ;-)
10:33:47 <conal> quicksilver: nice
10:33:55 <GarethTheGreat> Gracenotes: that makes more sense now
10:34:00 * glguy thinks that (=<<) is more interesting than (>>=)... (a -> m b) -> (m a -> m b)   give me a function from a to m b, and I'll lift the argument into m
10:34:01 <Gracenotes> lilac: how so?
10:34:01 <GarethTheGreat> so, it doesn't eliminate impurity, just makes it modular
10:34:18 <GarethTheGreat> and now lilac has to go and disagree just as my brain clicks :(
10:34:18 <conal> BONUS: do you want to learn about FRP in general?  Reactive in particular?
10:34:21 <chessguy_work> lilac, i like this (http://metafoo.co.uk/practical-monads.txt) . can i reddit it?
10:34:25 <glguy> which meshes with return :: a -> m a  , give me a value and I'll lift it
10:34:26 <lilac> Gracenotes: everything, including IO actions, are pure. the idea is handling impure sub-components without mixing them up.
10:34:28 <quicksilver> conal: still, I'll do it on the CPU first. And they gloss over how they obtain the initial triangulation.
10:34:29 <lilac> chessguy_work: it's not finished yet
10:34:31 <BONUS> conal: i meant FRP in general, yeah
10:34:43 <chessguy_work> aww
10:34:48 <chessguy_work> finished shminished
10:34:49 <Peaker> GarethTheGreat: you're catching it very quickly! :-)
10:34:53 <lilac> chessguy_work: i'll let you know when i'm done.
10:34:58 <chessguy_work> sweet
10:35:01 <rwbarton> GarethTheGreat: The only thing which "invokes" anything is the Haskell run-time system
10:35:11 <conal> BONUS: my old Fran tutorial will give you a flavor: http://conal.net/fran/tutorial.htm .
10:35:15 <Gracenotes> lilac: well, yes. But structurally, monads tend to divide your program as I described.
10:35:16 <GarethTheGreat> Peaker: yeah, that's because i'm already of the type that hates OOP and likes to casually do metaprogramming
10:35:18 <rwbarton> which lives outside your program
10:35:34 <conal> BONUS: then you can check out links from the FRP page on the haskell wiki .
10:35:36 <Peaker> GarethTheGreat: Indeed the "purity" of Haskell doesn't mean that Haskell has no impure programs, only that pure and impure programs are marked as such
10:35:42 <lilac> Gracenotes: i think considering them that way will lead to confusion when your pure code passes IO actions around, is all.
10:35:47 <BONUS> conal: cool, thanks, i'll give that and those links a go :]
10:35:59 <Peaker> conal: The GHC guys say they expect 6.10.2 in a ~month -- have you tested unamb on the latest git repos of ghc?
10:36:09 <lilac> Gracenotes: but the two ways of thinking are in some sense dual anyway
10:36:38 <quicksilver> BONUS: in terms of the conal's particular implementation, there is good reading to be found in the archives of the reactive mailing list
10:36:42 <GarethTheGreat> so... you do your impure stuff in a seperate program, built via your main program, and the main program remains completely pure
10:36:49 <quicksilver> BONUS: which doesn't take long to read - it's not been around long.
10:37:00 <BONUS> quicksilver: nice. got a link?
10:37:11 <conal> Peaker: i've done some testing with a ghc head from last week.  it definitely fixes the problems with unamb that i knew of.
10:37:35 <quicksilver> BONUS: http://www.haskell.org/mailman/listinfo/reactive
10:37:51 <Gracenotes> lilac: I just seem to see confusion on whether, conceptually, pure "contains" impure or impure "contains" pure
10:37:51 <BONUS> cool
10:37:57 <Gracenotes> in the sense I described
10:38:18 <GarethTheGreat> Gracenotes: from the looks of things, "pure" and "impure" are side by side
10:38:33 <conal> i'd change the description of Haskell as "purely functional", which i think misleads people.
10:39:10 <conal> i think of it as a hybrid functional/imperative language (like ML), but with functional/imperative distinguished statically in types (unlike ML).
10:39:33 <GarethTheGreat> i'll let out why i'm looking into monads - been learning erlang recently, and that's something strongly functional
10:39:50 <GarethTheGreat> but it has some aspects which make it "impure"
10:39:58 <GarethTheGreat> like ETS and process tables
10:40:08 <Gracenotes> executing impure actions can contain executing pure actions. Executing entirely pure actions, though, can't contain executing impure actions.
10:40:38 * conal wonders what a "pure action" is
10:40:38 <Gracenotes> as lilac described, though, executing pure actions can /handle/ code with impure actions, without actually executing said actions
10:40:43 <chessguy_work> lilac, is that all literate haskell?
10:40:51 <Gracenotes> conal: uh, I guess something with side effects
10:41:03 <Gracenotes> again, just in the context of IO
10:41:21 <Gracenotes> (which isn't *exactly* an exemplary monad >_>)
10:41:30 <conal> and what's an impure action?
10:42:01 <Gracenotes> conal: er, sorry, mixed them up. In my explanation, an "impure action" has side effects; a "pure action" doesn't.
10:42:10 <quicksilver> conal: it is purely functional in the sense that all functions (things of type a -> b) are pure.  I think that's what the term is supposed to mean.
10:42:35 <conal> Gracenotes: that's what i'd guessed.  a "pure action" wouldn't be an "action" at all, would it?
10:42:42 <quicksilver> putStr is a pure function : for a given string, it always returns the same IO ().
10:42:59 <Gracenotes> or, rather, anything marked as having side effects, by IO, is "impure"
10:43:18 <GarethTheGreat> this changes a bit with DB access....
10:43:45 <Gracenotes> in the sense that it executes an impure action. A "pure action" can kinda be viewed as an action, although it does the same thing every time.
10:43:46 <GarethTheGreat> sql("select * from whatever;") can easily return different results each time
10:43:57 <GarethTheGreat> and anything that calls sql() will also be influenced
10:43:57 <Gracenotes> most of this is simplification, but hopefully it's a useful simplification
10:43:58 <lilac> chessguy_work: no, it's not literate haskell. it's approximately markdown formatting
10:44:04 <conal> quicksilver: i know that's the rationale.  but one could say the same about programming in C via CPP.
10:44:14 <chessguy_work> oh ok
10:44:15 <BONUS> GarethTheGreat: every time it returns an action that will go fetch something and then yield it
10:44:39 <GarethTheGreat> BONUS: got it
10:44:48 <ddarius> conal: Is CPP purely functional? and if so, well then CPP -is- purely functional and calling it such is appropriate.
10:44:55 <GarethTheGreat> so, you can have your impure stuff invoke your pure stuff, just not vice-versa
10:45:05 <GarethTheGreat> this is making more sense now
10:45:06 <Gracenotes> GarethTheGreat: or calling a remote database could also accidentally reach the wrong server and launch the missiles
10:45:14 <GarethTheGreat> lol
10:45:32 <GarethTheGreat> i hope no military systems are configured to launch missiles if an SQL select is sent ;)
10:45:37 <conal> my concern is that lumping IO programming in with semantically simple functional programming blurs the distinction in people's minds between imperative and functional programming.
10:46:14 <GarethTheGreat> stu8ball: btw, random ACHTUNG
10:46:23 <GarethTheGreat> my brain appears to have clicked
10:46:40 <conal> ddarius: that's the point i was making.  calling CPP/C programming "purely functional" as as appropriate as calling Haskell-with-IO programming "purely functional".
10:46:55 <conal> ddarius: they're both technically accurate though easily misleading.
10:47:21 <ddarius> CPP is purely functional, CPP/C is not.
10:47:30 <BONUS> true, even though the only time anything impure happens in a haskell program is when it is run :]
10:47:49 <conal> ddarius: in the same way that Haskell is purely functional and Haskell-with-IO is not.
10:48:56 <Gracenotes> GarethTheGreat: then there are other types of monads, too...
10:49:01 <Gracenotes> @where all about monads
10:49:01 <lambdabot> I know nothing about all.
10:49:04 <Gracenotes> :>
10:49:15 <skorpan> how do i check if a given FilePath is a symlink?
10:49:15 <Gracenotes> lemme see, http://www.haskell.org/all_about_monads/html/index.html
10:49:18 <GarethTheGreat> Gracenotes: they're at least making more sense
10:50:11 <quicksilver> conal: sure, but that's a statement about CPP, not about C
10:50:20 <quicksilver> conal: people *do* do some quite nice functional tricks in CPP
10:50:24 <quicksilver> (not many people, but some)
10:50:38 * wli needs arrow tutorials.
10:50:43 <Gracenotes> CPP = C++?
10:50:44 <quicksilver> however in C itself, "int f(int)" does not denote a function Int -> Int
10:50:47 <quicksilver> and that's the point.
10:50:48 <quicksilver> Gracenotes: no
10:50:52 <wli> The C preprocessor.
10:50:54 <quicksilver> Gracenotes: the preprocessor
10:50:56 <Gracenotes> oh, I see
10:50:59 <Gracenotes> :)
10:51:07 <conal> quicksilver: yes.  and people program in CPP+C, not in C.
10:51:10 <quicksilver> and in ML, "int -> int" does not denote a function Int -> Int.
10:51:12 <quicksilver> and that's the point.
10:51:27 <conal> quicksilver: that's one point, not *the* point.
10:51:30 <quicksilver> conal: sure, but most of them don't use CPP's facilities to any great extent.
10:51:33 <quicksilver> ;)
10:51:50 * paper_cc remembers Boost.Preprocessor
10:51:50 <quicksilver> consider my statement modified to: And that's *quicksilver's* point.
10:51:56 <flux> quicksilver, are you saying in Haskell it does denote, or just that not even in Haskell it does?-)
10:52:05 <quicksilver> flux: in haskell it does.
10:52:16 <BONUS> consider this java: Object a = getSomeA(); Object b = getSomeB(); Object c = getSomeC(); Foo foo = Foo(a,b,c)
10:52:16 <conal> quicksilver: i agree with quicksilver's point.
10:52:23 <quicksilver> and that's why I personally think it is useful to consider haskell purely functional in a way C and ML are not.
10:52:33 <conal> quicksilver: and i doubt quicksilver understand's conal's point.
10:52:35 <flux> quicksilver, well yes, given _|_ is part of all types..
10:52:48 <wli> ML has some niceties to it.
10:52:49 <BONUS> now what if you could instead of ; use some different semicolon, like ;? that would make foo null if any one of the three function calls returned null?
10:52:52 <flux> quicksilver, but really, the function might return or it might not return, and if it does, it will return int. that will hold true in all those languages.
10:52:57 <BONUS> instead of throwing a null pointer exception
10:52:59 <conal> quicksilver: if that's your reason, i recommend a more specific term than "purely functional".
10:53:07 <wli> ML's module system in paricular is quite dreamy.
10:53:27 <quicksilver> flux: but if it returns, it will do so consistently, and always calculate the same mathmetical function.
10:53:32 <BONUS> monads are a way to introduce that ;?
10:53:34 <augustss> dreamy?
10:53:46 <conal> quicksilver: e.g., such as the description i gave ("a hybrid functional/imperative language (like ML), but with functional/imperative distinguished statically in types (unlike ML).")
10:53:57 <quicksilver> flux: the property that distinguishes a function from a relation (in mathematics) is that it has a single result for each input.
10:54:08 <wli> augustss: Good, powerful, expressive, etc.
10:54:14 <quicksilver> conal: On the contrary, I do understand your point.
10:54:24 <conal> quicksilver: show me.
10:54:30 <augustss> wli: yes, and the way it's usually explained, very complex
10:54:50 <flux> quicksilver, I'm don't think Int -> Int captures that for the same int it will always return the same int, rather it would be an orthogonal issue?
10:54:55 <conal> quicksilver: i mean i doubt wheter your understanding of my point matches mine.
10:54:58 <wli> As simple as possible, but no simpler.
10:55:00 <lilac> flux: _|_ is not part of "newtype X = X X"
10:55:27 <lament> flux: in Haskell, it does capture that...
10:55:46 <lament> (pretending as usual that unsafePerformIO does not exist)
10:55:49 <quicksilver> conal: I think you're saying that describing haskell as purely functional ignores the fact that haskell is an excellent imperative language which can do impure things.
10:56:00 <conal> flux: because the meaning of a haskell function is a function in the math sense.
10:56:03 <flux> lament, I like to think it is other things in haskell that state that, not that signature in particular
10:56:04 <quicksilver> conal: but that it uses the type system to separate the two.
10:56:22 <quicksilver> and thus it's a better imperative language than ML or C.
10:56:26 <lilac> flux: (->) is a constructor of /pure/ function types
10:56:32 <lament> flux: it's the signature - it doesn't have IO in it :)
10:56:33 <conal> quicksilver: thanks!  now i know what got across and what didn't.  :)
10:56:54 <lilac> flux: whereas IO `O` (->) (or something) is a constructor of what you might call impure function types
10:57:04 <quicksilver> flux: that's what that signature means. (->) is the constructor for mathematical functions.
10:57:15 <quicksilver> ("functions int he precise mathematical sense of the word")
10:57:25 <quicksilver> conal: well, was that your point? or was it something else?
10:57:44 <conal> quicksilver: it's something else.
10:57:53 <flux> lilac, that can be argued, no? because the IO x isn't something that looks impure from the language point of view?
10:57:53 <quicksilver> personally I think being purely functional is something to be proud of; it is closely linked to referential transparency which is also something to be proud of.
10:58:08 * PrimeMinisterFag breaths in deeply
10:58:17 <flux> as Int -> IO () will always return the same action for the same integer
10:58:17 --- mode: ChanServ set +o quicksilver
10:58:18 <CosmicRay> @hoogle convert
10:58:18 <lambdabot> package geniconvert
10:58:18 <lambdabot> package wavconvert
10:58:25 <PrimeMinisterFag> wait, how do i do a type declaration before i define the function with lambdabot
10:58:29 <CosmicRay> @hoogle printf
10:58:29 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
10:58:29 <lambdabot> module Text.Printf
10:58:29 <lambdabot> package printf-mauke
10:59:42 <lament> > let foo :: Int -> Int = (+3) in foo 5 -- PrimeMinisterFag
10:59:44 <lambdabot>   8
10:59:45 <flux> as it is impossible to declare a function in haskell that is impure, I don't see what is the point in emphasizing that (->) is a constructor for _pure_ functions?
11:00:03 <conal> quicksilver: to me, the power & beauty of "functional" is in the simple semantic simplicity, which includes referential transparency.  haskell-with-io includes functional programming plus imperative programming.  i like to reserve "pure" for when i can understand my program's semantics without bringing in the (intractable) semantics of IO.
11:00:35 <conal> allowing functional & imperative programming to work together without breaking the functional parts is a great trick.
11:00:51 <conal> it means that part of my  program is still pure.  but not the whole thing.
11:00:53 <PrimeMinisterFag> @let roots :: (Float, Float, Float) -> (Float, Float); roots (a,b,c) = (x1, x2) where; x1 = e+sqrt d/(2*a);x2 = e - sqrt d/(2*a); d = b*b - 4*a*c; e = -b / (2*a)
11:00:54 <lambdabot>  Defined.
11:01:03 <PrimeMinisterFag> > roots 1 2 3
11:01:04 <conal> except in the technical sense you mentioned, which ignores the semantics of IO.
11:01:04 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
11:01:08 <PrimeMinisterFag> >:
11:01:16 <PrimeMinisterFag> > roots (1,2,3)
11:01:17 <lambdabot>   (NaN,NaN)
11:01:28 <PrimeMinisterFag> ah, whatever
11:01:42 <augustss> > roots (1,-5,6)
11:01:44 <lambdabot>   (3.0,2.0)
11:01:50 <PrimeMinisterFag> :D
11:02:10 <augustss> > roots (1:+0,2,3)
11:02:11 <CosmicRay> @hoogle maxBound
11:02:11 <lambdabot>   Couldn't match expected type `Float'
11:02:11 <lambdabot> Prelude maxBound :: Bounded a => a
11:02:19 <augustss> bah!
11:02:26 <wchogg> conal : I almost feel like a more descriptive term for pure is 'algebraic', i.e. you can analyze the code from entirely an algebraic perspective.
11:02:37 <augustss> PrimeMinisterFag: why did you add a limiting type signature?
11:02:50 <PrimeMinisterFag> to make sure it would work
11:02:57 <PrimeMinisterFag> what, you want doubles? ;)
11:03:02 <conal> wchogg: algebraic as in axioms / formal properties?
11:03:08 <CosmicRay> is anyone aware of bounds-aware conversion functions for int-related types?  fromIntegral seems to generate junk if given something too big
11:03:10 <augustss> PrimeMinisterFag: I want toe most general type
11:03:17 <PrimeMinisterFag> ok
11:03:19 <PrimeMinisterFag> @undefine
11:03:25 <kau> hello dear haskellers!
11:03:29 <PrimeMinisterFag> @let roots (a,b,c) = (x1, x2) where; x1 = e+sqrt d/(2*a);x2 = e - sqrt d/(2*a); d = b*b - 4*a*c; e = -b / (2*a)
11:03:31 <lambdabot>  Defined.
11:03:37 <kau> i am searching a function that search and remplace a sub-string into a string, one replacement at a time.
11:03:39 <conal> wchogg: i'm looking for a new term to replace "functional programming", since i suspect it'll be easier than rehabilitating what "purely functional" has come to mean in Haskell.
11:03:44 <kau> like that: repls :: Eq a => [a] -> [a] -> [a] -> [[a]]
11:03:49 <conal> wchogg: my current favorite is "denotational programming"
11:03:59 <lilac> @let genericRoots a b c = (j+k, j-k) where j = -b/(2*a); k = sqrt(b*b-4*a*c)/(2*a)
11:04:01 <lambdabot>  Defined.
11:04:06 <augustss> > roots (1:+0,2,3)
11:04:08 <lambdabot>   ((-1.0) :+ 1.4142135623730951,(-1.0) :+ (-1.4142135623730951))
11:04:15 <lilac> > genericRoots 1 (2:+0) 3
11:04:17 <lambdabot>   ((-1.0) :+ 1.4142135623730951,(-1.0) :+ (-1.4142135623730951))
11:04:17 <lament> conal: what's wrong with 'purely functional'?
11:04:23 <augustss> PrimeMinisterFag: there, now it works for complex
11:04:34 <PrimeMinisterFag> ah ;)
11:04:39 <PrimeMinisterFag> lovely
11:04:49 <conal> lament: from what i can tell, sometimes people use that term to include IO and sometimes not.
11:04:55 <augustss> > roots (1:+0,2,3::Complex CReal)
11:04:57 <lambdabot>   ((-1.0) :+ 1.4142135623730950488016887242096980785697,(-1.0) :+ (-1.4142135...
11:05:16 <conal> lament: i.e., to include programs that involve IO (or STM or ...)
11:05:36 <conal> types that have no tractable denotational model
11:05:50 <lament> conal: i suppose everything up to actual execution of 'main' is purely functional, regardless of presence of IO In the signature...
11:06:29 <conal> lament: that meaning of "purely functional" is what i'm looking to leave behind.
11:06:40 <conal> lament: one could say the same about CPP/C programming.
11:06:40 <lament> i see
11:07:15 <conal> lament: what's missing for me in that thinking is the distinction between the semantically simple aspects and the semantics intractable ones.
11:07:20 <lament> is CPP purely functional?
11:07:33 <GarethTheGreat> lament: that'd be news to me...
11:07:38 <beelsebob> lambdabot: yes, it is
11:07:38 <GarethTheGreat> side effects all over the place
11:07:42 <beelsebob> it's a rewrite language
11:07:45 <beelsebob> GarethTheGreat: where?
11:07:46 <lament> i see
11:07:55 <conal> lament: i'm assuming it is.  if not, then replace CPP with a functional subset.
11:07:56 <lament> GarethTheGreat: the C preprocessor, not C++
11:07:59 <GarethTheGreat> ah
11:08:06 <GarethTheGreat> ok, ignore what i said then
11:10:23 <lament> conal: i don't see a problem, you could say C has a purely functional part (macros) and a dirty part (everything else), and everything that applies to purely functional stuff in haskell applies to it in C; there're just fewer opportunities to write purely functional code
11:10:44 <conal> lament: yes!  i agree.
11:11:07 <lament> looking at a piece of C code, you immediately see if it's a macro or a function
11:11:08 <conal> lament: so if Haskell+IO programming is "purely functional" then CPP+C programming is also.
11:11:31 <PrimeMinisterFag> no it's not
11:11:42 <PrimeMinisterFag> ok, yes it is
11:11:45 <conal> lament: both statements are factual at the surface, and both ignore deeper semantic properties.
11:11:55 <PrimeMinisterFag> but C doesn't really have higher order functions
11:12:01 <lament> conal: haha, yes
11:12:04 <PrimeMinisterFag> witho3~ut some serious screwing around
11:12:09 <lament> conal: i see the problem
11:12:23 <dolio> How do you tell macros from functions in C?
11:12:30 <dolio> Or do you mean definitions thereof?
11:12:30 <lament> so we can't claim haskell to be purely functional with a straight face
11:12:38 <lament> dolio: yes
11:12:41 <conal> i'm going for a haircut.  catch you all later.
11:12:43 <PrimeMinisterFag> mathematica is strictly functional, no?
11:12:55 <chessguy_work> byorgey++
11:12:55 <PrimeMinisterFag> no IO, at least that ic an remember
11:12:59 <PrimeMinisterFag> no mutable state
11:13:03 <chessguy_work> awesome explanation of existential quantification
11:13:24 --- mode: quicksilver set -o quicksilver
11:13:36 <idnar> chessguy_work: where?
11:13:45 <chessguy_work> idnar, on -cafe
11:14:00 <idnar> ah, I'm a bit behind on -cafe mail
11:14:10 <quicksilver> flux: the point of epmhasising that (->) is pure was to make the contrast with C and ML
11:14:26 <quicksilver> flux: where the equivalent constructs (int -> int) and "int f(int)" are not.
11:14:56 <quicksilver> conal: Yes, I accept that point. But it doesn't personally swing me enough to reject the tag line.
11:16:07 <chessguy_work> idnar, hmm, i don't see it on gmane or i'd give you a link
11:16:17 <quicksilver> beelsebob, conal : I note that CPP is not referentially transparent though.
11:18:30 <koeien> PrimeMinisterFag: mathematica is not pure
11:19:09 <chessguy_work> idnar, oh! it's on the beginner list that's why
11:19:31 <newsham> lament: CPP does not enforce a separation between the functional and nonfunctional parts.  #define MAX(x,y) ((x)<(y)?(y):(x)) ; MAX(n++,m--); and you have issues
11:19:51 <newsham> call by name does not appreciate side effects.
11:20:11 <chessguy_work> idnar, http://thread.gmane.org/gmane.comp.lang.haskell.beginners/748/focus=759
11:20:17 <idnar> newsham: CPP doesn't have side effects ;)
11:20:27 <newsham> idnar: but cpp lets you mix in c
11:20:28 <idnar> well, I suppose #error might be a side effect
11:20:38 <newsham> which is my point.
11:20:40 <idnar> newsham: yeah, but that's kinda like IO in Haskell
11:20:55 <newsham> IO does not suffer from the same issue.
11:20:56 <true\false> Hmm ok .. So tuples are just a collection that allows me to use different types in the same set?
11:21:06 <true\false> And the value+type is called the 'unit'?
11:21:22 <koeien> it's not a "set".
11:21:39 <koeien> it's a fixed number of elements of a few (possibly distinct) types, in a fixed order
11:21:41 <eu-prleu-peupeu> hi
11:21:56 <newsham> idnar: you cannot apply "max" to an IO action without lifting
11:22:09 <koeien> and, `unit' is the type (), which has only () (and bottom) as values
11:22:12 <true\false> koeien: Sort of like an anonymous type, or is that just entirely wrong?
11:22:28 <koeien> true\false: you can think of it like that, yes
11:22:34 <newsham> and when lifted, the IO actions only evaluate once, not multiple times as in cpp
11:22:37 <idnar> newsham: what I mean is that you're not actually performing any side-effects, just describing them
11:23:01 <true\false> koeien: Hmm, right .. I think I'm following. TA
11:23:02 <koeien> true\false: normally, in a larger program you wrap such a thing up in a newtype or data
11:23:46 <true\false> Heh, I'm really not at that stage yet
11:24:23 <Twey> true\false: It's a bunch of values stuck together.  :)
11:24:24 <koeien> you can always define   type MyPair = (String, Int)  or something like that
11:24:25 <newsham> idnar: [09:09] < lament> conal: i don't see a problem, you could say C has a purely functional part (macros) and a dirty part (everything else)
11:24:30 <newsham> I'm referring to that statement.
11:24:39 <beelsebob> quicksilver: it isn't?  Where not?
11:24:39 <newsham> (ie. talking about both cpp and c together)
11:24:58 <quicksilver> beelsebob: you can redefine macros.
11:25:13 <quicksilver> beelsebob: so it's not safe to textually substitute blindly (which is what r.t. means)
11:25:14 <true\false> koeien: Oh I see.. So it's just a composite data type, for the sake of knowing what the actual thing is meant to hold?
11:25:18 <Twey> C macros aren't functional
11:25:24 <Twey> They're just text :-\
11:25:35 <beelsebob> Twey: it's a term rewriting language
11:25:38 <newsham> twey: if you're saying "its just lexical" then I say "so is lambda calculus"
11:25:39 <quicksilver> Twey: well rewrite languages have a clear functional semantics
11:25:41 <true\false> koeien: type Student = (String, Int) -- name, age
11:25:47 <quicksilver> Twey: which is, I think, what beelsebob and conal are getting at.
11:25:48 <koeien> true\false: yes, if you use 'type' you're just creating a type synonym
11:26:01 <quicksilver> but there is no semantics in which "#define foo" makes foo into a function
11:26:03 <koeien> true\false: e.g., type String = [Char]   in the Prelude
11:26:08 <true\false> Ahh, get it, thanks
11:26:14 <idnar> chessguy_work: nice
11:26:17 <tibbe__> when/where is the next haskell hackathon
11:26:20 <tibbe__> >
11:26:38 <dolio> #undefine is side-effectish.
11:26:45 <true\false> Should that work in GHCi?
11:26:50 <beelsebob> quicksilver: ah, yeh, I see what you're getting at now
11:27:01 <koeien> true\false: no, you'll have to create a file for it.
11:27:15 <koeien> true\false: but, i would recommend doing that anyway for anything more than 1 line
11:27:42 <true\false> koeien: Right.. I'll try to bear that in mind
11:28:14 <quicksilver> dolio: so is #define foo blah; .... ; #define foo zar ; ....
11:28:19 <dolio> At the very least, CPP is sensitive to the order in which things appear in the file.
11:28:28 <dolio> Which doesn't sound particularly functional.
11:28:38 <dolio> Or pure, or whatever.
11:28:59 <trofi> like in haskell
11:30:00 <augustss> macro expansion is about as bad as it gets in violating referential transparency
11:30:37 <quicksilver> personally I think conal conflates "has a tractable semantics" with "is functional"
11:30:45 <Twey> newsham: I'm not
11:31:14 <Twey> It's not just lexical — it works only with text, considering concrete and abstract syntax alike
11:31:19 <quicksilver> I think that's not a reasonable conflation.
11:31:40 <quicksilver> I can easily make a toy algol-like language with mutable variables and give it a tractable semantics.
11:31:48 <koeien> I think that it would be hard to precisely define whenever a PL is "functional" or "imperative".
11:31:50 <quicksilver> but I definitely wouldn't call that purely functional.
11:32:09 <quicksilver> (where by "Easily" I mean "other people have done the hard work")
11:32:10 <koeien> i would argue that C is not "functional", but that is not a mathematically precise statement
11:32:51 <lament> a language doesn't need to be functional to be purely functional
11:33:02 <dublpaws> can't find in man ghc, what flag to use to dump desugared source.. is this possible?
11:33:18 <koeien> dublpaws: you mean Core?
11:33:24 <elliottt> dcoutts: you around?
11:33:32 * dublpaws investigates this Core thing.
11:33:47 <koeien> dublpaws: my 'man ghc' says -ddump-ds though for "desugared"
11:34:03 <dublpaws> ohoh ok thanks
11:34:14 <koeien> i don't know what it does
11:35:07 <Twey> I think that's just to standard Haskell, desugaring do-notation and the like
11:35:18 <newsham> twey: cpp isn't a lexical system?
11:36:07 <Twey> newsham: The word you missed out is quite important :)
11:36:47 <newsham> twey: I dont think it is.
11:36:50 <Twey> 'Dynamic scope is not the same as lexical scope' 'Dynamic scope is the same as lexical scope?!'
11:37:06 <Twey> Considering it reverses the whole meaning of the sentence, it is.
11:38:01 <newsham> *sigh*
11:38:35 <mathijs> does anyone know if the code samples in 'Real World Haskell' are online somewhere? I'm a bit lazy :)
11:39:30 <newsham> the whole book is
11:39:31 <dcoutts> elliottt: hi
11:39:34 <trofi> should be in darcs repo if public
11:40:07 <mathijs> newsham: I know, but I don't feel like cutting and pasting piece by piece ;)
11:40:20 <mathijs> trofi: any where can I find the repo?
11:41:27 * trofi is googling
11:43:50 <mathijs> looks like it's private
11:43:57 <Guenni> hi, is frantk still alive?
11:44:17 <mathijs> no problem, in that case I'll just copy and paste stuff.
11:47:42 <skorpan> any idea why my ghci won't recognize my åäö?
11:48:08 <mathijs> terminal not on utf8?
11:48:19 <skorpan> i'm using rxvt-unicode
11:48:28 <skorpan> ghc 6.10.1 btw
11:48:49 <mathijs> hrm... and in rxvt itself you can type those characters?
11:48:54 <skorpan> yes
11:48:56 <skorpan> @pl \(re, rp) n -> subRegex re n rp
11:48:56 <lambdabot> uncurry (flip . subRegex)
11:49:17 <Saizan> skorpan: yes, editline
11:49:27 <skorpan> Saizan: what?
11:49:31 <elliottt> dcoutts: i had a cabal problem that was rather mysterious, but i seem to have it taken care of now
11:49:40 <elliottt> dcoutts: an option was buried in a series of makefiles :)
11:50:02 <Saizan> skorpan: ghc-6.10.1 switched from readline to editline that doesn't support utf8
11:50:07 <dcoutts> elliottt: ah, tracing where bogus options come from is rarely fun
11:50:38 <skorpan> Saizan: ah, that's terrible :(
11:50:57 <dcoutts> elliottt: I've occasionally thought we should track the source of options within Cabal so we can have a debug mode where we explain their source, eg command line, config file, default, env vars etc.
11:51:11 <elliottt> dcoutts: that would be excellent :)
11:51:15 <Saizan> skorpan: i use ghci-haskeline since then, but there's also a patch in ghc-users@ to get it to build with readline
11:51:19 * ksf would like to know what the :+-> in makeEvent :: Clock TimeT -> a :+-> Event a means.
11:51:50 * ksf now officially calls the :+-> -operator "Conal pointing at his nose at you"-operator.
11:52:00 <skorpan> Saizan: is utf-8 support in plans for editline?
11:52:36 <mathijs> and also... why was switched to editline in the first place?
11:52:46 * Nafai tries to decide whether to bite the bullet and subscribe to haskell-cafe
11:52:46 <koeien> what's wrong with readline?
11:52:56 <ehird> readline is gpl
11:53:02 <Saizan> skorpan: i don't know, but editline doesn't look very active
11:53:03 <PrimeMinisterFag> There is no "change" other than a new act in the same old play. The same orchestra is playing. The same conductor is in charge. The same venue holds the show. Only the music has changed.
11:53:08 <koeien> aha, so GHC was in violation for a long time?
11:53:08 <PrimeMinisterFag> oh wrong channel sorry
11:53:25 <ehird> hahaahahahah
11:53:29 <koeien> lol
11:53:32 <ehird> oh wrong channel sorry
11:53:41 <ksf> nah, bsd may use gpl, but it limited distribution and usage.
11:53:57 <koeien> of course. you have to be careful then
11:54:18 <koeien> not to create a "derived work"
11:54:21 <mathijs> maybe switch ghc to gpl then :)
11:54:37 <ksf> that's what readline effictively did, yes.
11:54:37 <koeien> no, we want closed-source forks of ghc!! :)
11:54:47 <MichaelGG> So, I have a somewhat embarrassing question
11:54:47 <mathijs> f#
11:55:16 * ksf doubts that there'll be a fork of ghc that can survive without spj peeking at it.
11:55:16 <MichaelGG> I've read some of Erik Meijer's papers, namely "static typing where possible..." and "confessions of a used programming language salesman"
11:55:57 <MichaelGG> And... I don't get it. To my admittedly ignorant mind, it looks as if he just got sick of people not getting things so gave up and moved to VB?
11:56:17 <MichaelGG> but he's obviously vastly more powerful than I.... so what are your takes on it?
11:56:25 <ksf> VB: you can have your cake and eat it, but you don't want to 'cos it tastes bad.
11:57:27 * ksf can't believe noone here knows what :+-> means.
11:57:45 <dublpaws> :t (:+->)
11:57:47 <lambdabot> Not in scope: data constructor `:+->'
11:57:52 <ksf> it's in reactive.
11:57:56 <chessguy_work> ksf, you've got a booger hanging out your nose?
11:57:59 <ksf> makeEvent :: Clock TimeT -> a :+-> Event a
11:58:15 <ehird> it means dfshf89a7y87dysadyasd
11:58:33 <koeien> so. are arrows in Haskell just like arrows in CT ? over which category?
11:58:41 <ksf> or is it just one of conal's newtypes for (,)?
11:58:44 <ehird> @src Arrow
11:58:45 <lambdabot> class Arrow a where
11:58:45 <lambdabot>     arr, pure   :: (b -> c) -> a b c
11:58:45 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
11:58:45 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
11:58:45 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
11:58:47 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
11:58:49 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
11:58:52 <CosmicRay> @hoogle Float
11:58:52 <lambdabot> Prelude data Float
11:58:53 <lambdabot> Text.Parsec.Token float :: GenTokenParser s u m -> ParsecT s u m Double
11:58:54 <ehird> koeien: does that answer your question?
11:58:55 <lambdabot> Text.PrettyPrint.HughesPJ float :: Float -> Doc
11:59:07 <koeien> ehird: no :) i know the definition, but not the relation to CT
11:59:14 <ehird> :)
11:59:15 <koeien> if there is any obvious relation
11:59:32 <Saizan> ksf: what about :info (:+->)?
12:00:26 <dolio> koeien: Someone mentioned on one of the lists recently that they correspond to indexed Freyd categories.
12:00:27 <MichaelGG_> Like, in the "where possible", he says phantom types are "overly complicated and exotic", and "like trying to run a marathon with a ball and chain tied to your leg and triumphantly shoting that you nearly made it even though you baild out after the first mile"
12:00:34 <ksf> well, I can't even figure out where it's defined.
12:00:38 <Saizan> koeien: each instance of Arrow defines a new category where the objects are still haskell types, but the morphisms are different
12:00:44 <dolio> People used to think they were just Freyd categories, but apparently that isn't accurate.
12:01:30 <ksf> MichaelGG, looks like someone who can't stand not understanding something.
12:03:20 <MichaelGG_> ksf, that's Erik Meijer's line
12:03:56 <koeien> dolio: i thought mathematics was accurate :)
12:04:02 <koeien> (no, i didn't. but j/k)
12:04:37 <MichaelGG_> ksf, I don't think it's a case of him not understanting :). he's got 4 papers on type systems on the haskell wiki , 2 with SPJ
12:04:40 <koeien> Saizan: thanks. that helps me wrap my mind around them :) haskell has sparked some interest in CT for me
12:04:52 <ksf> well, I agree that phantom types are a bit exotic, but "overly complicated" is doubly wrong: they're quite simple.
12:06:03 <dolio> Erik Meijer said phantom types are overly complicated and exotic?
12:06:54 <dolio> I don't think I've read any of his stuff since he stopped doing Haskell.
12:09:15 <skorpan> which function is most appropriate to lowercase a string?
12:09:27 <dolio> map toLower
12:09:53 <koeien> you will need to import toLower from Data.Char, I think
12:11:40 <MichaelGG_> dolio yes
12:11:55 <dolio> Anyhow, I can't say I grasp his simile. Phantom types don't seem like running a marathon with a ball and chain at all. :)
12:12:03 <MichaelGG_> see "Static Typing Where Possible, Dynamic Typing When Needed: The End of the Cold War Between Programming Languages"
12:12:14 <MichaelGG_> I dont get it -- im even using them in C# :\
12:12:29 <MichaelGG_> and they're incredibly useful and catch tons of problems for me
12:12:45 <dolio> Yeah. They're just a tool.
12:12:50 <MichaelGG_> or is Meijer a Haskell secret agent?
12:12:51 <dolio> Sometime a useful one.
12:12:52 <ksf> yes, :+-> is just another synonym for (,)
12:13:02 <MichaelGG_> like he left to infiltrate MS DevDiv
12:13:06 <dolio> It's hard to say.
12:13:26 <ksf> the conal-equivalent of saying "think of this tuple as a function"
12:13:33 <dolio> In some ways, I think he says things like that, while secretly adding lots of Haskell stuff to VB.
12:14:07 <MichaelGG_> dolio , see "Confessions of a used programming language salesman" -- the abstract says a lot
12:14:22 <dolio> Like that Flapjax talk where the guy kept ragging on functional programming, while he was secretly pitching his new functional reactive programming framework in JavaScript. :)
12:14:31 <MichaelGG_> heh
12:14:35 <SubStack> quite the intelligence service the haskell community has
12:14:48 <SubStack> with the infiltration and the secret agents and what-not
12:15:19 <ksf> shht, there's no such thing as the HBI.
12:15:26 <dolio> @fact HSU
12:15:26 <lambdabot> I know nothing about hsu
12:15:28 <MichaelGG_> SubStack, considering MS's C# and VB community seems to scream in fear at even the notion of type inference.....
12:15:32 <dolio> Hmm.
12:15:43 <dolio> @fact chessguy
12:15:43 <lambdabot> I know nothing about chessguy
12:15:53 <dolio> Evidently the fact database got cleaned out.
12:16:17 <SubStack> I would have thought C# would be a bit more enlightened, what with its cousin F#
12:16:41 <dolio> It's getting better.
12:17:08 <dolio> Hasn't VB not required type annotations for some time?
12:17:24 <dolio> Admittedly, everything used to default to "variant" or whatever if you didn't specify.
12:17:42 <idnar> defint a-
12:17:43 <idnar> z
12:17:50 * idnar recalls the good old days
12:17:55 <RayNbow> dolio: I'm not sure if the Variant thing carried over to VB.NET
12:18:08 <idnar> the variant thing was basically dynamic typing
12:18:13 <dolio> Yeah.
12:18:14 <idnar> not type inferrence
12:18:14 <cads> @lastspoke chessguy
12:18:14 <lambdabot> Unknown command, try @list
12:18:17 <cads> hrm
12:18:26 <idnar> *inference
12:18:29 <MichaelGG_> dolio, well yea, dynamic typing
12:18:33 <idnar> @seen chessguy
12:18:33 <lambdabot> I saw chessguy leaving #novalang and #haskell 15h 35m 6s ago, and .
12:18:38 <MichaelGG_> but you should see the C# peopl with the "var" keyword
12:18:42 <MichaelGG_> its like let
12:18:46 <cads> thanks idnar :)
12:18:46 <dolio> But if you can do inference and get static checking, that's just free good stuff. :)
12:18:47 <MichaelGG_> and they totally freak out
12:18:50 <RayNbow> but VB.NET did have late binding before C# introduced the dynamic type
12:19:00 <MichaelGG_> "Our company decided we will not permit usage of the var keyword"
12:19:04 <MichaelGG_> stuff like that
12:19:09 <ziman> why would anybody freak out because of that? :)
12:19:23 <MichaelGG_> i have no clue
12:19:39 <dolio> Even C++ is finally relaxing some of the need for type declarations.
12:19:47 <MichaelGG_> the same people also love ASP.NET MVC's strategy of "just box all the arguments and we'll reflect on them and randomly fail for you"
12:20:07 <MichaelGG_> one of the asp.net mvc devs even said "there's no such thing as type inference in a statically typed language"
12:20:24 * RayNbow facepalms...
12:20:52 <asgaroth> Can anyone give me some hints for pretty-printing trees(preferably just with putStr/putStrLn, no fancy helper libs or such)?
12:21:11 <SubStack> deriving Show?
12:21:23 <SubStack> oh, you said pretty
12:21:46 <RayNbow> http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/src/Data-Tree.html#drawTree
12:21:58 <RayNbow> ^ might serve as some inspiration
12:21:58 <SubStack> that looks nifty
12:22:00 <sbahra> @fact logic
12:22:00 <lambdabot> logic: ⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳
12:22:13 <asgaroth> RayNbow: thanks
12:23:16 <cads> @fact farsi
12:23:16 <lambdabot> I know nothing about farsi
12:23:22 <cads> durn.
12:23:30 <RayNbow> asgaroth: iirc, drawTree produces string representations that resemble the one shown here: http://www.codeproject.com/KB/shell/tree_view/tree_view.jpg
12:24:50 <asgaroth> RayNbow: That's great. I think I'll try adapting it to print them vertically(without transpose or such tricks) as an exercise.
12:25:26 <Nafai> Wow.
12:25:27 <cads> would you guys encourage people to write their haskell programs using the above unicode logic symbols when appropriate? For example the generic plus/circle operator I use when I am dealing with a generic associative operator, just as a mnemonic saying "this is like plus".
12:25:43 <Nafai> I just glanced at a subject line of an e-mail that had a $ in it
12:25:52 <cads> i'd like to use arrows too rather than ->
12:25:53 <asgaroth> Does haskell support unicode operators?
12:25:55 <Nafai> I started parsing it as Haskell code and function application
12:26:06 <arw> asgaroth: yes, it does
12:26:11 <dolio> cads: Go for it, if you don't mind typing the stuff in.
12:26:12 <idnar> cads: unfortunately most of those characters aren't present in my monospace font, so they look awful (because they're substituted from elsewhere)
12:26:26 <idnar> also, they're hard to type
12:26:32 <cads> ah crud
12:26:57 <conal> quicksilver: ("personally I think conal conflates "has a tractable semantics" with "is functional"").  more accurate: tractable semantic is what makes functional programming appealing to me.  that's why i'm thinking of using the term "denotational programming" for what i do, rather than "functional programming".
12:27:04 <CosmicRay> @hoogle [a] -> [a] -> [(a, a)]
12:27:04 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
12:27:04 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
12:27:04 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
12:28:08 <cads> as for typing, don't think it'd be that bad to say ctrl-shift-a for an arrow, rather than -,shift-.
12:28:58 <quicksilver> conal: that's very reasonable.
12:29:22 <quicksilver> conal: tractable semantics is definitely (on of the main) nice things about functional programming.
12:29:26 <dolio> I'm a fan of \,-,shift-.
12:29:37 <quicksilver> conal: so is equational reasoning (which is not the same, although not unrelated)
12:29:55 <conal> quicksilver: i'd say very closely related.
12:29:56 * arw would be a fan of <compose>, -, >
12:30:16 <arw> hail to sun for making keyboards with a compose key :)
12:30:17 <conal> quicksilver: that semantic tractability is the main ingredient in powerful equational reasoning.
12:30:19 <dolio> Anyhow, many Agda folk make heavy use of unicode for cool looking code.
12:30:57 <cads> I've seen that and was impressed
12:31:14 <conal> quicksilver: ("<quicksilver> putStr is a pure function : for a given string, it always returns the same IO ()."  Although off my main point (which was semantic tractability, i'm also curiouis whether that claim about putStr can be made precise, let alone demonstrated to be valid.
12:31:37 <cads> tractable semantics or not, I feel like programs are easier to understand when they're wrapped in some more comfortable notation
12:31:41 <conal> s/tractability,/tractability),/
12:32:06 <conal> cads: i'm guessing you mean understand informally.  if so, i'm with you.
12:32:32 <cads> I am able to reason better about haskell programs when I write them down on paper and throw in random informal math notation
12:32:41 <cads> than, say, in a text editor
12:32:44 <conal> cads: with a more precise notion of "understand", i don't know how to separate semantics &  understanding.
12:34:06 <cads> I'm talking about the simple psychological aspect of the text/human interface, with the human doing the understanding, rather than the deeper program semantics as you guys are, I think
12:34:41 <cads> I still find ruby easier to understand, even though the formal semantics of it have got to be horrendous
12:35:19 <conal> cads: i suspect when you use math notation, you're also keeping yourself in the land of simple semantics.
12:35:49 <conal> cads: and hence are thinking more clearly than when you're using notation that doesn't reinforce math-style thinking.
12:36:11 <cads> yeah
12:36:28 <quicksilver> conal: (sorry, I"m still 3 or 4 points behinds you here) - the point about denotational semantics  and functional programming is that haskell is a functional program because it has a natural denotation as *functions*
12:36:36 <gwern> (the problem with simple semantics is that our desired behaivour often has complex semantics)
12:36:47 <quicksilver> conal: rather than a denotation as traces, or trees, or decision diagrams, or all the other things you could imagine doing denotations in terms of
12:37:11 <conal> gwern: perhaps that situation is where simple semantics is of most importance.
12:37:12 <quicksilver> conal: (ignore that the CPO semantics isn't entirely functions, it's close enough)
12:37:16 <gwern> (so it starts off easier to take a complex semantics and bash at it with imperative updates until it's black-and-blue in a way that resembles what we want)
12:37:43 <quicksilver> conal: other programming languages might have entire tractable semantics but if functions aren't the key building block it's less "functional"
12:38:30 <cads> something as simple as a function with one parameter as a subscript, I don't know why, but reinforces that function's character in my mind more than if i just wrote the function to take an extra argument. The first denotes in my mind a class of functions indexed by the subscript, which is equivalent to the latter, but is somehow more comfortable
12:38:44 <conal> quicksilver: that's another reason i find "functional" misleading.  it gets people to think that the main point is functions.
12:39:29 <ksf> conal++
12:39:36 <conal> ksf: thx.
12:39:46 <ksf> (just in general, nothing recent on #haskell)
12:39:55 <conal> in that case, a "pure functional" program would have nothing but functions.
12:39:57 <ksf> reactive is currently making my day.
12:40:07 <conal> ksf: it is?  how?  :)
12:40:14 <ksf> it just works.
12:40:42 <conal> :)
12:41:03 <ksf> I guess I can show you guys proof-of-concept reactive agar bindings in an hour or two.
12:41:33 <ksf> but first, I need some more tea.
12:42:20 <conal> ksf: agar?
12:42:30 <ksf> libagar.org
12:42:41 <ksf> an sdl/opengl tk.
12:43:33 <Twey> Arrrgh, existential types *rocks back and forth*
12:43:41 <ksf> ...featuring a pure c interface with the only gotcha being void* and varargs and 2-clause bsd license.
12:44:12 <conal> ksf: thx.
12:44:19 * cads comforts twey with http://projectfortress.sun.com/Projects/Community/attachment/wiki/FortressQuestions/NAS-CG.png
12:44:38 <cads> now isn't that sooothing?
12:45:06 <conal> "The Agar API is entirely thread-safe when Agar is compiled with optional threads support. "  :)
12:45:07 * Twey blinks.
12:45:10 <arw> the internal error?
12:45:11 * Twey explodes.
12:46:29 <conal> ksf: are the guis 2D or 3D?
12:46:47 <conal> ksf: looks 2D from the screnshots (http://libagar.org/screenshots.html.en)
12:48:34 <conal> on semantic simplicity, here's a quote from Tony Hoare's Turing award lecture: "I conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is make it so complicated that there are no obvious deficiencies.  The first method is far more difficult."
12:48:43 <MichaelGG_> is it fair to say a simple definition of phantom types is "a type that has a type parameter on the left hand side thats not on the right hand side"?
12:48:54 <MichaelGG_> conal nice
12:49:05 <conal> MichaelGG_: yeah! :)
12:49:12 <conal> MichaelGG_: that's my understanding of phantom types.
12:49:17 <MichaelGG_> ok
12:50:59 <ksf> they're 2d.
12:51:09 <conal> <quicksilver> ("the point about denotational semantics  and functional programming is that haskell is a functional program because it has a natural denotation as *functions*").  i think *all* nontrivial languages have functions as their denotations.
12:51:15 <ksf> flat, that is, you can customize the rendering.
12:51:29 <MichaelGG_> conal man web devs should take that quote to heart.
12:51:52 <mauke> data Null a = Null; instance Monad Null where return _ = Null; _ >>= _ = Null
12:52:01 <conal> MichaelGG_: how about *all* devs?
12:52:17 <ray> if web devs took that quote to heart they'd cease to exist
12:52:24 <MichaelGG_> ray theyd implode
12:52:25 <ray> in one of those puffs of logic
12:52:26 <ksf> yeah, thread safety is important when you've got tens of thousands of forkIO $ adaptE's.
12:52:37 <MichaelGG_> they just love it when you can pass around strings, then look up in a dictionary and unbox to whatever type
12:52:39 <MichaelGG_> and just hope it works
12:52:40 <MichaelGG_> oh wait
12:52:44 <MichaelGG_> thats what "unit tests" are for.
12:52:47 <MichaelGG_> ::roll::
12:53:04 <MichaelGG_> Am i the only one who sees half the unit test stuff out there just a lame replacement for a type system?
12:53:09 <ray> more than half
12:53:09 <mauke> who needs dictionaries when you can just access the symbol table at runtime?
12:53:15 <mathijs> I have a totally offtopic question, but since people here are helpful and have great knowledge in general, I'll ask anyway :)  is there an easy way to get linux to 'memory-lock' a process? so that it becomes unswappable?
12:53:32 <MichaelGG_> mathijs what happens when the machine goes into hibernate
12:53:39 <Twey> conal: They don't
12:53:46 <Twey> (not mathematical functions, anyway)
12:54:13 <mathijs> MichaelGG_: it never will, it's a server and I need some processes to keep in memory.
12:54:15 <MichaelGG_> oh shit i knew there were btards in here.
12:54:27 <MichaelGG_> mathjis, no it was a rhetorical question
12:55:01 <mauke> mathijs: well, there's mlock()
12:55:23 <bohdan> what's the equivalent of last . takeWhile ?
12:55:36 <mathijs> mauke: I found that :) but that's a syscall. I just want to apply that to some processes :)
12:55:53 <mauke> already running processes?
12:56:12 <mathijs> mauke: it's ok to apply it when they start
12:56:34 <mauke> crap, mlock doesn't survive exec
12:57:09 <bohdan> actually disregard that, what's the equivalent of \p start -> last . (start:) . takewhile p start
12:57:23 <mathijs> mauke: also... it's a user-level process so I might need to enable some capabilities for it as well.
12:58:39 <bohdan> oh got it :) dropWhile . not :)
12:58:46 <conal> Twey: sure they do.  the semantics of a C program is a function from environment & store ...
13:02:14 <Twey> conal: Side effects :-\
13:03:18 <conal> Twey: yeah. :-\
13:03:43 <conal> i'm off to a wifi cafe.  back online in 30 minutes or so.
13:04:44 <Twey> Aye-aye
13:10:01 <jethr0> hola #haskell
13:11:38 <SubStack> oh hai
13:13:36 <Taejo> @pl \vs -> zipWith (+) (map (* dt) (dv'dt:vs)) vs
13:13:36 <lambdabot> zipWith (+) =<< map (dt *) . (dv'dt :)
13:14:05 <Taejo> @pl int dv'dt vs = zipWith (+) (map (* dt) (dv'dt:vs)) vs
13:14:05 <lambdabot> int = join . ((zipWith (+) . map (dt *)) .) . (:)
13:15:06 <Taejo> @where =<<
13:15:07 <lambdabot> I know nothing about =<<.
13:15:14 <Taejo> @index =<<
13:15:14 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:29:08 <ksf> http://picfront.de/d/MDlHFKLpVHS/agar-reactive.png http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=861#a861
13:29:35 <ksf> there are some sync issues, though.
13:29:42 <ksf> the lower text display lags.
13:30:54 <CakeProphet> so how does GHC and other Haskell compilers determine how to lookup imported modules?
13:31:18 <ksf> actually, the coolest demo ever would be a text box that always contains a palindrome, no matter what you type in.
13:31:53 <ksf> that is, if s /= reverse s then s ++ reverse s else s
13:33:06 <ksf> ghci searches in paths managed with ghc-pkg, the current directory and -i<dir>
13:33:11 <ksf> ghc, that is.
13:33:14 <ksf> both, actually.
13:34:13 <lucca> ksf: that could cause huge growth; need a more clever palindromer
13:34:53 <ksf> yeah.
13:35:25 <ksf> but the important thing is to mess with the textbox the user is typing in.
13:37:02 <saml> > let x = x in 1
13:37:04 <lambdabot>   1
13:37:22 <mauke> > let 1 = 1 in x
13:37:24 <lambdabot>   x
13:40:14 <ehird> > let 1 = 2 in 1
13:40:16 <lambdabot>   1
13:40:16 <ksf> conal, where should I start to investigate if reactive is too lazy pushing events into an adaptE?
13:40:19 <ehird> > let 1 = 2 in 1+1
13:40:21 <lambdabot>   2
13:40:35 <ehird> always irked me that that didn't work
13:40:39 <smitty1e> So, I'm writing a blackbody radiation calculation function.  The denominator has exp^^x, where x is calculated on the fly.  Is this where I use a lambda?
13:40:39 <saml> > let f (1,b) = (b,1) in let (a,b) = f (1, b) in b
13:40:40 <ehird> or at least give a pattern match error
13:40:41 <lambdabot>   1
13:41:08 <saml> > let f (1,b) = (b,42) in let (a,b) = f (1, b) in b
13:41:10 <lambdabot>   42
13:41:13 <Taejo> > let None = 1 in ()
13:41:15 <lambdabot>   Not in scope: data constructor `None'
13:41:21 <Taejo> > let Nothing = 1 in ()
13:41:23 <lambdabot>       No instance for (Num (Maybe t))
13:41:23 <lambdabot>        arising from the literal `1' at ...
13:41:32 <Taejo> > let Nothing = Just 1 in ()
13:41:33 <lambdabot>   ()
13:41:35 <saml> lazy evaluation is lazy
13:41:38 <ksf> import Debug.Trace
13:41:52 <Taejo> > let Nothing = Just 1 in Nothing
13:41:54 <lambdabot>   Nothing
13:42:10 <Taejo> > let Nothing = Just 1 in Nothing == Just 1
13:42:11 <lambdabot>   False
13:42:28 <Taejo> (yes, I do know what's going on here. it's still weird)
13:42:35 <loadquo> Smittyle: I don't think you need a lambda, you might use a where statement for x for readability  </newbie answer>
13:43:15 <smitty1e> loadquo: I was using a where, and the type system slapped me for not having everything reduce to Float.
13:44:03 <ksf> sometimes reactive pushes no event for multiple invokations of the sink, then it catches up, but always lags at least one.
13:45:05 <Taejo> smitty1e, probably best to paste something (where are we pasting these days?)
13:45:05 * BMeph wished Reactive lead events by one instead of lagging
13:45:06 <saml> > let f [] _ = ([], 0); f (x:xs) n = let (xs', s) = f xs n in (x/n:xs', s+x) in f [1..10] 5.0
13:45:08 <lambdabot>   ([0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0],55.0)
13:45:24 <BMeph> @where hpaste2
13:45:25 <lambdabot> http://moonpatio.com:8080/
13:45:30 <loadquo> smittyle: I believe you want ** instead of ^^ but I may be wrong
13:45:40 <Taejo> :t (^^)
13:45:42 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:45:48 <Taejo> I believe you actually want exp
13:45:51 <Taejo> :t exp
13:45:53 <lambdabot> forall a. (Floating a) => a -> a
13:45:58 <smitty1e> radience lambda temp = 2/lambda^^5*h*c^^2 / (exp (\lambda temp -> h * c / lambda * k * temp ) - 1)
13:45:59 <Taejo> > exp 2
13:46:00 <lambdabot>   7.38905609893065
13:46:26 <Taejo> smitty1e, that \ is completely out of place
13:46:36 <smitty1e> The k, defined in the where clause, doesn't seem to be visible within the lambda
13:46:47 <CosmicRay> @hoogle Char8
13:46:47 <lambdabot> module Data.ByteString.Char8
13:46:47 <lambdabot> module Data.ByteString.Lazy.Char8
13:46:47 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
13:46:58 <Taejo> radience lambda temp = 2/lambda^^5*h*c^^2 / (exp (h * c / lambda * k * temp ) - 1)
13:47:01 * ksf shivers seing \lambda ->
13:47:04 <Taejo> what's wrong with that?
13:47:18 <ksf> don't use lambda as an argument name.
13:47:22 <BMeph> smitty1e: that "(\lambda temp -> h * c / lambda * k * temp )" part is almost absolutely NOT what you want to do... :)
13:47:30 <smitty1e> OK
13:47:59 <Taejo> ksf, no, I meant what's wrong with my code. \lambda is certainly weird, but I understand where smitty1e is coming from
13:48:02 <smitty1e> I need to raise the euler number to a power based upon two input arguments.  What is the happy way to effect that?
13:48:20 <Taejo> smitty1e, exp (h * c / lambda * k * temp )
13:48:22 <smitty1e> Taejo: lamba is what's in the blackbody formula.
13:48:27 <ksf> f a b = 1/ exp (3*a - b)
13:48:30 <ksf> ...or something
13:48:52 <BMeph> Taejo: What's wrong with it majorly, is: the \lambda will shadow the lambda argument. :\
13:49:21 <Taejo> BMeph, my code doesn't have \lambda
13:50:08 <smitty1e> Teajo: k is a constant defined in the where clause, but apparently invisible to the exponentiation.  Guess I have to make that an input variable.
13:50:31 <Taejo> smitty1e, no, that is not the case
13:50:40 <Taejo> unless there is *another* k somewhere
13:50:44 <BMeph> Taejo, Right, I was reacting as if you meant what was wrong with '\lambda' in smitty1e's code, since you said: " \lambda is certainly weird, but I understand where smitty1e is coming from". :)
13:51:15 <Taejo> I meant, I understand calling the variable lambda, having studied a little physics
13:51:33 <smitty1e> No, making k an input still no worky worky.  Retyped, in case there is a wierd emacs encoding thing happening, but still no joy.
13:51:38 <ksf> THERE IS NO LAMBDA BUT LAMBDA AND IT IS _THE_ LAMBDA
13:51:53 <dons> ?yow
13:51:53 <lambdabot> Was my SOY LOAF left out in th'RAIN?  It tastes REAL GOOD!!
13:51:54 <Taejo> smitty1e, why don't you paste the whole declaration
13:51:56 <smitty1e> ksf: Fascinating. I detect passion.
13:51:59 <BMeph> smitty1e: Please use the hpaste2 link, and show us where the 'where' clause is in relation to the radience function. :)
13:52:17 <dolio> There is no Dana, only Zuul.
13:52:57 <smitty1e> url, bitte?
13:53:09 <ksf> @where hpaste2
13:53:09 <smitty1e> I see a paste2 in google...
13:53:10 <lambdabot> http://moonpatio.com:8080/
13:53:44 <loadquo> Smittyle: Paste your code here http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
13:54:52 <smitty1e> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=862#a862
13:55:38 <Taejo> :t (^^)
13:55:40 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:55:43 <smitty1e> I'm probably using the worst exponentiation...
13:55:43 * cads sings *monad monad, bo bonad, bannana fanna fo fonad..*
13:55:52 * cads gets back to work
13:56:16 <Taejo> smitty1e, for one, 1.381*10^^(-23) is better written as 1.381e-23
13:56:39 <smitty1e> Taejo: thank you.  This will improve the latex output. ;)
13:58:00 <smitty1e> Oh, and c is another function, which I neglected in the hpaste2...
13:58:26 <Taejo> smitty1e, function? or a constant c = 3e8?
13:58:48 <Taejo> smitty1e, are you getting a compile error here, or just the wrong output?
13:59:07 <smitty1e> c :: Float; c = 1 / sqrt( e * m ); where e = 8.854*10e-12;  m=4*pi*10e-7
13:59:17 <smitty1e> Taejo: k is not visible...
13:59:33 <smitty1e> course0.lhs:108:37: Not in scope: `k'
13:59:55 <Taejo> smitty1e, are you mixing tabs and spaces?
14:00:23 <smitty1e> Probably...
14:00:40 <Taejo> smitty1e, don't
14:00:49 <Taejo> tabs are dangerous
14:02:46 * ksf thinks tabs should be a syntax error
14:02:50 <smitty1e> just within the function, or the whole file
14:03:11 <mmorrow> a cheney copying gc: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=863
14:03:35 * mmorrow got "Garbage Collection" from amazon today
14:03:36 <Taejo> well, the problem here is within the radience declaration, has no advantages, and a single disadvantage: it causes a world of hurt
14:03:45 <ksf> the good thing is that I don't ever get them in my source as expand-tabs is on.
14:04:13 <erikc> mmorrow: fun book
14:04:45 <mmorrow> totally
14:05:15 <mmorrow> i'm starting with the "copying" chapter, then going to the "incremental and concurrent".
14:05:38 <Taejo> s/, has/, but tabs have/
14:06:07 <smitty1e> OK, I am sorry for being such a dolt.  What is my penance?  I had been trying to write an auxiliary function, and was not paying close enough attention to the line numbers.
14:06:19 <smitty1e> It was another function lacking the k.
14:06:32 <smitty1e> How many Hail Currys do I owe?
14:06:37 <Taejo> lol
14:06:41 <Taejo> no worries
14:06:53 <mmorrow> erikc: i got "linkers & loaders" too ;)
14:07:05 <Taejo> but in future, paste a full file, so *we* can match line numbers
14:07:24 <smitty1e> Aye.
14:07:26 <ksf> conal, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=864#a865 : any idea?
14:07:50 * conal looks
14:07:57 <Taejo> if you like, you could write a "hail Curry" plugin for \bot, so #haskellers can give each other them, and \bot keeps track of how many you have done
14:08:18 <conal> ksf: hm.  i'm not seeing code at that url
14:08:26 <ksf> no.
14:08:28 <ksf> i'll paste.
14:09:08 <augustss> @hail Curry
14:09:09 <lambdabot> Unknown command, try @list
14:09:09 <smitty1e> Taejo: you just blew away my meagre skill, but I'll file that away for when I can differentiate between 'up' and 'down'.
14:09:11 <ksf> tell me if you want to have the .chs to bake the bindings.
14:09:53 * ksf tries to forkIO the loop instead of the adaptE
14:11:07 <ksf> ...works much better, but still not perfect.
14:11:09 <mmorrow> um, did the css suddenly stop working at moonpatio.com?
14:11:17 <mmorrow> or is it just me
14:11:37 <mmorrow> i don't know how this could even happen and am sure it's just me..
14:11:51 <erikc> mmorrow: hehe, linkers and loaders is so so, How Debuggers Work is fun too
14:12:05 <mmorrow> cool
14:12:09 <Taejo> mmorrow, I didn't look before now, but it looks pretty unstyled to me
14:12:18 <mmorrow> snap
14:12:23 <mmorrow> i dunno what happened
14:12:35 <mmorrow> the .css is visible and everything..
14:12:57 <lgas> why do I get a stack overflow if I do "maximum [3..999999]" ?
14:13:36 <ksf> conal, sorry.
14:13:53 <Taejo> @src maximum
14:13:54 <lambdabot> maximum [] = undefined
14:13:54 <lambdabot> maximum xs = foldl1 max xs
14:14:00 <ksf> compiling a forkIO without -threaded isn't the best idea you can have.
14:14:38 <lgas> that seems to be stack safe to me...?
14:15:21 <Taejo> lgas, nah, you want foldl1'
14:15:31 <augustss> lgas: no stack overflow for me... ghc -O2
14:15:33 <Taejo> foldl1 max [3..999999]
14:15:36 <Taejo> > foldl1 max [3..999999]
14:15:39 <lambdabot>   * Exception: stack overflow
14:15:42 <Taejo> > foldl1' max [3..999999]
14:15:44 <lambdabot>   999999
14:16:18 <Taejo> with strictness analysis, it should work, but otherwise you get a huge thunk
14:16:22 <lgas> what's the difference between fold1l and foldl1' and why isn't maximum defined in terms of foldl1' then?
14:16:28 <mmorrow> maybe somehow the last paste messed with it
14:16:42 <ksf> lgas, strictness.
14:16:50 <augustss> lgas: well, they are not semantically equivalent
14:16:59 <Taejo> lgas, foldl1' evaluates the intermediate values
14:17:20 <ksf> in case of -O2, ghc supposedly does more strictness analysing and thus makes your program work although it shouldn't.
14:17:39 <u5h> hello
14:17:42 <augustss> ksf: why shouldn't it?
14:17:47 <ArneB> Are there any cases where maximum defined with foldl1 is preferable to maximum defined with foldl1'?
14:17:47 <u5h> who wants to help me recreate the free market for banking with hApps :)
14:17:48 <pstickne> ksf:  that seems backwards :)
14:17:58 <augustss> ksf: when the numbers are Integer it's fine to be more strict
14:17:59 <u5h> open source, constructed of goodwill and GHC
14:18:02 <Taejo> ArneB, I'm trying to think of one
14:18:06 <pstickne> u5h:  you mean to imply there was ever a "free market" with banking? :-)
14:18:14 <u5h> i doubt it
14:18:16 <mmorrow> ksf: did you just paste the one with the ticks? sry, but i have to delete it because i think it somehow made hpaste2 crap itself wrt css
14:18:17 <u5h> but it's possible
14:18:26 <ksf> do it.
14:18:31 <mmorrow> (i don't know how that could even happen though)
14:18:35 <pstickne> u5h:  but then how will we spend the bailout :-/
14:18:37 <mmorrow> but it's all i can think of
14:18:38 <u5h> i need help though
14:18:40 <u5h> there's a shitton of work
14:18:54 <augustss> ArneB: you can easily contract examples where it would terminate with foldl1 but not foldl1'.  But they would be rare in real life.
14:18:57 <u5h> shit-ton, hyphenated
14:18:57 <Taejo> mmorrow, it was CSS-less for me before the ticks paste
14:19:19 <mmorrow> hmm odd
14:19:23 <Taejo> augustss, can you give such an example?
14:19:39 <mmorrow> the css worked after i pasted the one before that too
14:19:43 <u5h> all you need a series of analyses based on consumer profiles as to which banks for which information is available will confer the lowest cost onto the consumer
14:19:52 <Taejo> augustss, never mind, I got it
14:19:56 <u5h> through any manner of 'fees'
14:20:10 <Taejo> > () <= ()
14:20:11 <lambdabot>   True
14:20:22 <u5h> > Just False
14:20:23 <lambdabot>   Just False
14:20:53 <smitty1e> Just False? That describes the output from my function!
14:21:02 <davidL> gwern: when is mueval going to work with ghc-6.10?
14:21:02 <u5h> :D
14:21:05 <Taejo> > let badlist = replicate 1000 error ++ () in maximum badlist
14:21:07 <lambdabot>   Couldn't match expected type `[[Char] -> a]'
14:21:16 <Taejo> > let badlist = replicate 1000 undefined ++ () in maximum badlist
14:21:17 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
14:21:23 <Taejo> > let badlist = replicate 1000 undefined ++ [()] in maximum badlist
14:21:25 <lambdabot>   * Exception: Prelude.undefined
14:21:52 <augustss> @src foldl1
14:21:52 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:21:52 <lambdabot> foldl1 _ []     = undefined
14:22:02 <Taejo> urgh, max is left-biased
14:22:07 <augustss> @src foldl
14:22:08 <lambdabot> foldl f z []     = z
14:22:08 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:22:39 <gwern> davidL: a few days/weeks ago
14:22:53 <u5h> @src foldr
14:22:53 <lambdabot> foldr f z []     = z
14:22:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:23:00 <u5h> aha!
14:23:03 <davidL> gwern: the one on hackage isn't working
14:23:09 <gwern> really?
14:23:11 <gwern> how so
14:23:13 <augustss> @src foldl1
14:23:13 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:23:14 <lambdabot> foldl1 _ []     = undefined
14:23:21 <augustss> @src foldl'
14:23:21 <lambdabot> foldl' f a []     = a
14:23:21 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:23:30 <davidL> gwern: just a sec, let me upgrade to 6.10 again
14:24:32 * ksf wants to add a finaliser to a non-Foreign value he returns from a function
14:24:53 <Gracenotes> I remember that when I first came to #haskell, I was surprised that lambdabot could quote the sources of entire functions in one or two lines...
14:25:10 <davidL> gwern: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=868#a868
14:25:27 <gwern> Gracenotes: as was I
14:25:44 <bolrod> until you found out they really were 2 lines??
14:25:55 <gwern> davidL: how recent a hint is this?
14:26:10 <Gracenotes> bolrod: well, I trusted that they were the actual sources :)
14:26:16 <bolrod> ;p
14:26:29 <gwern> davidL: if it doesn't work with darcs hint, then there's certainly a problem
14:26:29 <davidL> gwern: hint-0.3.1.0
14:26:40 <mmorrow> i haven't a clue why the css suddenly broke
14:26:46 <augustss> Gracenotes: some are a little massaged.
14:27:08 <augustss> > foldl1 undefined []
14:27:09 <Gracenotes> yeah. The canonical implementation
14:27:09 <lambdabot>   * Exception: Prelude.foldl1: empty list
14:27:31 <Gracenotes> instead of, say, something more performance-friendly
14:27:34 <augustss> Gracenotes: like using undefined instead of calling error.
14:27:47 <davidL> gwern: should I upgrade to darcs hint?
14:28:14 <Raevel> cabal rocks
14:28:19 <Raevel> amazing
14:29:20 <gwern> bah, gorin moved things around!
14:29:41 <Gracenotes> @src foldr1
14:29:42 <lambdabot> foldr1 _ [x]    = x
14:29:42 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:29:42 <lambdabot> foldr1 _ []     = undefined
14:29:55 <mmorrow> i'll have to try to fix the css later, gotta run
14:30:12 <mmorrow> (maybe it'll fix itself!!!)
14:30:26 <davidL> gwern: in the darcs version too?
14:30:52 <gwern> yes
14:31:00 <davidL> :-[
14:31:45 <kiris> mmorrow: that's just what jesus said, sir!
14:32:00 <Raevel> parsec question: i wan to matchi anything up to a newline, how can i do it?
14:32:30 <davidL> gwern: are you fixing it? ;)
14:32:31 <Cale> many (noneOf "\n")
14:32:41 <Raevel> why ofcourse, thanks!
14:32:42 <gwern> davidL: yes
14:32:59 <davidL> gwern: thank you, let me know when I can pull
14:35:45 <Taejo> mmorrow, Error: The stylesheet http://moonpatio.com:8080/hpaste/hpaste.css was not loaded because its MIME type, "text/plain", is not "text/css".
14:35:46 <Taejo> Source File: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
14:35:46 <Taejo> Line: 0
14:36:08 <mmorrow> Taejo: oh crap, my fault
14:36:18 <mmorrow> Taejo: thx, nice call.
14:36:18 <gwern> davidL: pushed & hackaged
14:36:32 <davidL> gwern: thanks
14:37:29 <Taejo> mmorrow, no problem
14:37:42 <mmorrow> beautiful, fixed.
14:38:10 <Taejo> mmorrow, much better
14:38:13 <mmorrow> (i went a little too wild there after a rampage to make .c files display as text ;)
14:39:12 <Taejo> mmorrow, http://xkcd.com/292/
14:39:15 <mmorrow> kiris: i must be chosen!
14:39:36 <mmorrow> Taejo: yes exactly!
14:39:39 <mmorrow> :)
14:40:32 <mmorrow> so i guess the css has been broken for hours then...
14:40:43 <smitty1e> Can someone help me find a missing power of 10? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=869#a869
14:41:45 <lament> 10, 100, 1000, 10000, 100000, 10000000, 100000000... find the missing power of 10!
14:41:54 <Raevel> 1000000000000000000000000 !
14:42:04 <Taejo> smitty1e,  8.854187817*10e-12 should be 8.854187817e-12
14:42:09 <smitty1e> There just isn't much there there.  Why is the light so slow in my head?
14:42:22 <Taejo> <x>e<y> means x*10^y
14:42:32 * ksf just succeded in deadlocking agar
14:42:33 <smitty1e> Taejo: Do you have an Amazon wish list so that I can compensate you for your time?
14:42:58 <Cale> Yeah, that should be written 8.85e-12
14:43:14 <smitty1e> We may have hit upon errors running throughout my work.  Oddly, they've been balancing thus far, or the notation shift introduced them.
14:43:18 <Cale> and 4*pi*1e-7
14:43:26 <Taejo> smitty1e, not right now, but feel free to (a) get me The Road To Reality by Penrose or (b) feed me when I get fired for spending all day on IRC
14:43:28 <idnar> lament: 1?
14:43:36 <idnar> :)
14:43:57 <gwern> Taejo: I have a PDF of road to reality
14:44:00 <ddarius> Taejo: The Road to Reality is a good but frustrating book.
14:44:04 <mmorrow> ksf: (i didn't end up deleting your pastes)
14:44:06 <Cale> > let e = 8.854187817e-12; m = 4*pi*1e-7 in 1/sqrt(e*m)
14:44:07 <lambdabot>   2.997924580105029e8
14:44:21 <ddarius> gwern: To save your back?
14:44:36 <gwern> ddarius: yep
14:44:43 <gwern> I'd email Taejo it but it's 14m
14:45:00 <gwern> and gzip only takes it down to 13m
14:45:07 <Taejo> gwern, evaluate (long book in PDF) == _|_ (i.e., head asplode)
14:45:16 <Taejo> ddarius, worth the frustration?
14:45:22 <ddarius> gwern: Most major free email providers can handle that it seems.
14:45:34 <gwern> ddarius: I thought gmail etc. limited it to 10m these days
14:45:44 <ddarius> Taejo: Yes, I just wish he had used different formalisms.
14:45:46 <gwern> I could dcc send it to Taejo
14:46:05 <ddarius> gwern: My impression was that it was at least 15MB.  I sent an 11.2MB video the other day.
14:46:07 <Taejo> gwern, I'm very unlikely to read a PDF, so don't worry about it
14:46:21 <mmorrow> i just made a symlink to the sqlite db that that hpaste2 is using in case anyone ever wants a snapshot of everything  http://moonpatio.com/hpaste.db
14:46:25 * gwern tries anyway
14:46:26 <smitty1e> My source code keeps shrinking.  Haskell may be the software equivalent of felt.
14:46:40 <gwern> Taejo: to accept it I think is '/dcc get'
14:46:52 <Taejo> gwern, I'm at work
14:46:54 <gwern> (although I'm not sure, I don't use dcc very often)
14:47:14 <Taejo> in xchat, I get a popup asking me if I want to accept it
14:47:42 <gwern> ah. I suppose a gui chat client could do that instead
14:51:08 <gwern> so is there any sort of syntax highlighting for .prof output?
14:51:14 <gwern> I find them kind of unreadbale
14:53:19 <wabash> Hi. I'm installing Haskell. Is Haskell 98 really the current version?
14:53:19 <mmorrow> gwern: HsColour makes a ton of random things more readable
14:53:36 <wabash> mmorrow: What's HsColour?
14:53:45 <mmorrow> @hackage hscolour
14:53:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hscolour
14:54:20 <mmorrow> a cli prog + lib that colors haskell code (but since it doesn't actually parse it, you can use it for all kinds of stuff)
14:54:24 <wabash> Ah, ok. it's for html.
14:54:37 <wabash> Any good editors that are simple to use?
14:54:39 <mmorrow> also outputs css'ed html
14:54:41 <gwern> mmorrow: that is indeed random
14:54:42 <wabash> Anyone use gedit?
14:54:43 <mmorrow> and tty color
14:54:55 <mmorrow> cat /dev/urandom | od | HsColour -tty
14:55:04 <mmorrow> weeee!
14:55:30 <mmorrow> cat /proc/cpuinfo | HsColour -tty
14:55:47 <mmorrow> dmesg | HsColour -tty
14:56:11 <thoughtpolice> works well for ghc's core output :)
14:56:51 <mmorrow> HsColour is the sheeyit
14:57:06 <thoughtpolice> also i just finished reading most of oleg's "implicit configurations paper", very nice and clean solution :]
14:57:23 <mmorrow> hmm, i'm not sure if i've seen that or not
14:59:06 <Twey> Can we catch pattern-match failures?  Is it '98 to do so?
14:59:21 <mmorrow> thoughtpolice: what section is it under?
14:59:25 <thoughtpolice> mmorrow: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=870#a870
14:59:43 <thoughtpolice> mmorrow: I typed that code out from the paper; it's not all of it, but it does show how to do really nice modulus math (check out test3 at the bottom!)
14:59:53 <thoughtpolice> and does integer reification to/from types
14:59:59 <shapr> @users
15:00:00 <lambdabot> Maximum users seen in #haskell: 646, currently: 629 (97.4%), active: 28 (4.5%)
15:00:21 <thoughtpolice> unfortunately it does not work for reasons I can't explain because the normalize function needs the 's' type variable to be lexically scoped, but the way it is presented in the paper does not work
15:00:42 <thoughtpolice> even the literate haskell code with oleg's technical report didn't work because it had a parse err; i just asked g-h-u
15:01:04 <mmorrow> heh
15:01:13 <thoughtpolice> mmorrow: but yes it's a very clever solution
15:01:20 <mmorrow> looks interesting, i'll have to look at it more closely
15:01:32 <thoughtpolice> the modulus math example is pretty clear and it gives rise to ideas about how to use fundeps/type classes to do more stuff like this :]
15:01:51 <thoughtpolice> mmorrow: paper is pretty easy to read.
15:02:37 <gwern> @hoogle waitForTermination
15:02:37 <lambdabot> No results found
15:05:37 * jeffwheeler is always happy to see (people in #java * 2) == people in #haskell
15:06:50 <Twey> You accidentally a whole #BH?  That's bad.
15:07:01 <skorpan> try to it
15:07:23 <Gracenotes> jeffwheeler: we're getting fat :X
15:07:50 <thoughtpolice> we are legion
15:07:56 <Gracenotes> so... does Hugs have a :type?
15:08:11 <jeffwheeler> Gracenotes: I'm worried about corrupting my system if I install Java. Better SSH to Yi on my Mac. :)
15:08:34 <jeffwheeler> Gracenotes: I'll compile stuff there.
15:09:22 <Twey> Gah: data Event = MouseMotion !Word16 !Word16 !Int16 !Int16
15:09:30 <Twey> Thanks SDL, that's helpful
15:09:51 <Gracenotes> jeffwheeler: heh. Yeah, I'll be working on Java this semester, as a pre-requisite. I used to be pretty active in ##java... to an extent I think the attitudes in an IRC channel reflect on the language (not to mention the bot)
15:09:56 <roconnor> > 3714+12066+11351
15:09:58 <lambdabot>   27131
15:10:14 <Twey> I at least managed to get a college that used C# :)
15:10:16 <lament> what does the bot do in ##java?
15:10:23 <dobblego> ##java is a joke
15:10:28 <Gracenotes> lament: mostly sarcasm :)
15:10:33 <jeffwheeler> Gracenotes: I have to use it at high-school programming contests (and other stuff in computer science).
15:10:37 <roconnor> > 2646+3296-2060
15:10:38 <lambdabot>   3882
15:10:42 * Twey will be trying to slip CL, F# and possibly some Haskell in there the whole year...
15:10:56 <Gracenotes> lament: and links, e.g. to the javadocs based on class name
15:11:08 * jeffwheeler hasn't looked at what languages my various college options use
15:11:20 <jeffwheeler> I saw Illinois did at least some C, but I have no idea what else.
15:11:33 <Gracenotes> there is a bit of an anti-newbie attitude in ##java
15:11:55 <jeffwheeler> Then again, that's true in almost _every_ channel, except #haskell
15:12:01 <jeffwheeler> :P
15:12:02 <Twey> Hm
15:14:08 <koeien> i once used Haskell for a networking assignment, the teacher was not amused
15:14:19 <lament> Gracenotes: #haskell would have a lot more anti-newbie sentiment if it has the kind of newbies ##java does
15:14:30 <Gracenotes> koeien: was the assignment language-agnostic?
15:14:40 <kiris> koeien: the teacher is a big lame face
15:14:46 <koeien> Gracenotes: yes. in fact, since it was a networking assignment, it was encouraged to use all kinds of stuff
15:15:12 <koeien> so yeah, we used Haskell :) parsing of networking messages was very elegant
15:15:19 <jeffwheeler> koeien: presumably he was happy, rather than amused. It shouldn't have been funny! :D
15:15:32 <kiris> jeffwheeler: haha, yeah, seems to me like haskellers just can't wait to teach newbies things
15:15:33 <koeien> :) nah, he couldn't understand our program
15:15:41 <Taejo> I managed to go a whole semester of college using only Haskell ... my tutor didn't understand it, but the TA told him to suck it
15:15:53 <Gracenotes> lament: that might be true ("avoid success at all costs"). Still, sarcasm abounds in ##java, and anti-newbie doesn't have to be mocking, necessarily
15:15:59 <kiris> (I think it's a factor of learning something hard, you want to tell people about it. hence the two or three (thousand) monad tutorials)
15:16:06 <ksf> kiris, the point is that explaining stuff, you tend to start to understand it yourself for the first time.
15:16:13 <kiris> ksf: indeed
15:16:14 <ksf> s/that/that while/
15:16:25 <Gracenotes> lament: still, it's not a bad channel on the whole. Some of the conversations in there are quite informative
15:16:45 <Gracenotes> i.e. clueful
15:16:54 * ddarius could happily live in ignorance of the minutae of Java.
15:16:54 <rainmann> haha!
15:17:22 <rainmann> Gracenotes, please let me know next time you see a clueful discussion in ##java - I'd like to witness such an event
15:17:41 <Gracenotes> clueful in the navel-gazing sense, then :P
15:17:46 * ksf used to write object-less java while constantly looking at the assembly, some time ago.
15:18:29 <lament> Gracenotes: hi my program not workeded lolz why??? wuts a function lol. i need 2 do assignment 4 next monday a chat server lol so how do u do it? lol
15:19:24 <Gracenotes> I wonder how these people even know that IRC exists...
15:19:34 <ksf> warez.
15:20:03 <Gracenotes> eh. That's true. Outside of freenode, anyway.
15:20:05 <jeffwheeler> Gracenotes: a valid question.
15:20:05 <ksf> that is, you don't develop those speech mannerisms by leeching via bittorrent.
15:21:32 * Twey grins.
15:21:33 * Gracenotes goes off to develop some Enterprise Haskell(TM)
15:21:33 <ksf> still, sometimes I get pissed by the omnipresent niceness in #haskell. I usually cure that by talking in spring's #main.
15:21:34 <Twey> I blame AOL
15:21:44 <Twey> Hahaha
15:21:46 <smitty1e> OK, so I'm breaking down my exponential failures, and cannot grasp why a function to calculate c and multiply by a constant yields infinity:
15:21:47 <smitty1e> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=871#a871
15:22:23 <ksf> smitty1e, just a guess: number too big?
15:22:31 <quicksilver> smitty1e: I think you're beyond the resolution of Floats
15:22:40 <quicksilver> smitty1e: I haven't looked at your code carefully
15:22:47 <ddarius> ksf: I try to be catankerous.
15:22:52 <smitty1e> ksf: did it at GHCi, yeilded something in 10^43 or so.
15:23:12 <quicksilver> smitty1e: try replacing all instances of Float with Double in your code
15:23:15 <quicksilver> does that help?
15:24:34 <smitty1e> quicksilver: like wisdom from Mercury, it did, by Jove.
15:24:48 <quicksilver> hurrah.
15:24:53 <quicksilver> Float is a rather limited type
15:25:18 <Gracenotes> hm. Would a lambda calculus tutorial I'm writing be any less clear if I highlighted redexes-to-be-evaluated rather than underlined them?
15:25:50 <Twey> No
15:25:53 <Gracenotes> or maybe I should do both
15:25:55 <Twey> I think they should be underlined
15:25:58 <Twey> In colour
15:26:02 <ddarius> Gracenotes: It would be harder to read for color blind people.
15:26:08 <Twey> Yes, I was thinking the same
15:26:13 <ksf> you should make them blinky.
15:26:16 <Gracenotes> hm. That's true.
15:26:18 <Gracenotes> heh
15:26:18 * Twey hits ksf.
15:26:19 <snookerb> hey folks
15:26:26 <Twey> Hi snookerb
15:26:30 <Gracenotes> text-decoration: blink
15:26:45 <Twey> Ych
15:26:50 <Twey> Can't believe they included that in CSS
15:26:58 <Twey> I mean, WTF.
15:27:16 <Twey> You should have to work *hard* to design Seizure Robots.
15:27:18 <Gracenotes> ddarius: if the color value (as in HSV) is different enough, it shouldn't matter, right?
15:27:40 <ddarius> Gracenotes: I suspect, but I don't really know much about color blindness.
15:27:46 <Twey> Gracenotes: Yes — they'll either be unable to see the highlight, or be unable to see the text
15:28:02 <Gracenotes> I could take a screenshot and then grayscale it... hopefully enough to determine the color?
15:28:07 <ksf> go for a difference in saturation instead of hue.
15:28:10 <Gracenotes> color difference, that is
15:28:19 <Twey> Underline
15:28:22 <idnar> there are different kinds of colour blindness
15:28:25 <Twey> Yes
15:28:26 <Gracenotes> yes
15:28:39 <Twey> Just underline.  :)
15:28:47 <idnar> I think there are various classes of visual impairment that are mutually exclusive wrt. to working around them
15:29:22 <ksf> bold, bold italic, italic, underline, bold underline, italic underline, bold italic underline, serif, sans serif... tell me there isn't enough to do colour _and_ shape.
15:29:22 <Twey> Oh, and apply an auditory style, too
15:29:30 <snookerb> hey guys
15:29:34 <snookerb> i have a strange problem
15:29:37 <snookerb> maybe someone can help
15:29:38 <snookerb> initStore_by_Blocks:: Store -> [Block] -> Store
15:29:38 <snookerb> initStore_by_Blocks curStore (x:xs) = case x of
15:29:38 <snookerb> 											Animation name otype oref commands -> (initStore_by_Blocks (curStore ++ [(name, (AnimVal otype oref commands))] xs))
15:29:39 <snookerb>                           					_ 								   -> error ("Event")
15:29:51 <Gracenotes> meh. The thing is, I'm underlining both the redex and the things applied. It's kind of difficult to see where the not-underlined space is between the redex and arguments
15:29:55 <snookerb> always brings up the error:     parse error on input `_'
15:30:03 <snookerb> anyone any idea why?
15:30:07 <ksf> yeah. like most people can't properly discern shades of khaki.
15:30:13 <Twey> Gracenotes: Underline the redex, bold the arguments
15:30:24 <idnar> snookerb: you seem to be mixing tabs and spaces, which will lead to insanity
15:30:24 <Gracenotes> <strong> it!
15:30:29 <Twey> Quite so
15:30:31 <snookerb> ohh
15:30:33 <snookerb> ok
15:30:38 <snookerb> well, i tried just tabs
15:30:43 <Twey> snookerb: You seem to be pasting lots of code to an IRC channel, which will lead to anger
15:30:45 <Gracenotes> Twey: even so, you can't tell arguments apart like that
15:30:49 <quicksilver> snookerb: yes, teh _ should be indented to match the Animation
15:30:57 <quicksilver> snookerb: and avoid tabs, they will cause you pain ;)
15:31:14 <ddarius> quicksilver lost his left eye to a tab
15:31:16 <Twey> Gracenotes: The arguments have spaces between them, no?
15:31:17 <Gracenotes> (technically everything has one argument, but allowing applications to λa b c d e.)
15:31:28 * ksf still thinks tabs should be outlawed by the tokenizer
15:31:32 <Gracenotes> Twey: yes... and some of the arguments have spaces *in* them
15:31:32 <snookerb> ok
15:31:33 <snookerb> thanks
15:31:37 <snookerb> sorry for pasting so much code
15:31:40 <quicksilver> ddarius: still, I think the patch makes me look mysterious.
15:31:45 <snookerb> just wanted to giuve you all the informations
15:31:47 <snookerb> ok
15:31:52 <Gracenotes> meh. Maybe I should try for shades of gray
15:31:56 <ddarius> quicksilver: Everyone loves an eye patch.
15:31:58 <Gracenotes> or just one shade
15:32:06 <snookerb> i will reitend all now
15:32:14 * ksf is going to write up a h' proposal about tabs
15:32:14 <snookerb> but in my editor the _ is matched with animation
15:32:15 <snookerb> well
15:32:20 <snookerb> bare me a sekond
15:32:30 <Twey> snookerb: That's fine
15:32:47 <Twey> Actually, that's what quicksilver told you to do
15:33:09 <Twey> The issue is that you're mixing tabs and spaces — a tab won't necessarily have the indentation value to the compiler that it does to your editor.
15:33:18 <Twey> So what seems to line up to you, won't to the compiler.
15:33:30 <Gracenotes> it shouldn't be hard to distinguish #DDD on #F9F9F9...
15:33:36 <quicksilver> certainy what you pasted didn't match.
15:33:42 <Twey> Have your editor convert to tabs when you save, and you get the best of both worlds.
15:33:43 <quicksilver> animation had, erm, 10 tabs?
15:33:52 <quicksilver> but _ had about 20 spaces and 5 tabs
15:33:55 <Gracenotes> okay. Thanks for comments..
15:34:00 <quicksilver> I didn't count, that was an estimtion by eye.
15:34:41 <Twey> 11 tabs, 26 spaces and 5 tabs
15:35:11 <snookerb> hihi
15:35:12 <snookerb> ok guys
15:35:14 <snookerb> thanks so far
15:35:16 <snookerb> i use textmate
15:35:25 <snookerb> i will check the settings and use only spaces
15:35:27 <snookerb> no tabs
15:35:31 * Twey nods.
15:35:32 <snookerb> i will reintend
15:35:36 <Twey> That's the way to go
15:35:41 <Twey> It should reindent for you
15:35:44 <snookerb> if there is sitll a problem i will come back
15:35:47 <snookerb> thanks very much
15:35:52 <loadquo> I might have to disable my tab key, it is always getting me in trouble
15:35:58 <snookerb> ;-)
15:36:03 <Twey> Just do C-x h M-x indent-region or equivalent
15:36:07 <Twey> (or use emacs... :-P)
15:36:14 <Twey> Haha, loadquo
15:36:20 <Twey> But it's so useful for autocompletion :)
15:36:58 <noZone> Don't play with your tab key... you'll go blind.
15:37:01 <hydrapheetz> I just use vim with a handful of scripts. Most of the scripts are just for settings.
15:37:17 <ksf> :set et
15:37:19 <ksf> :retab
15:37:24 <Twey> Ych, scripting vim
15:37:41 <Twey> A proposition only slightly preferable to writing C :-P
15:37:42 <hydrapheetz> And I use hard tabs everywhere except when working with python code.
15:38:35 <hydrapheetz> :(
15:38:59 <Gracenotes> what would be really nice is a click-and-evaluate lambda JavaScript tool
15:39:25 <snookerb> wow
15:39:27 <Twey> For what language, Haskell?
15:39:30 * ksf should try yi once again
15:39:31 <snookerb> i changed to soft tabs
15:39:32 <snookerb> reintendet
15:39:38 <snookerb> and now it works
15:39:42 <Twey> emacs has something similar built in for Lisp
15:39:47 <snookerb> well it doen't but now i get another error ^^
15:39:49 <Gracenotes> for Haskell, or for lambda calculus. Anything with lambda expressions and basic tokens
15:39:52 <Twey> snookerb: There you go then :)
15:39:57 <snookerb> thanks
15:39:59 <snookerb> !
15:40:04 <Twey> Gracenotes: There's one built into emacs
15:40:07 <Twey> C-j
15:40:10 <ksf> I won't switch before yi's haskell mode is better than vim's, though.
15:40:21 <hydrapheetz> Isn't yi written in haskell?
15:40:28 <ksf> yeah.
15:40:29 <Gracenotes> Twey: okay, but the idea of clicking on a JS-link and evaluating it seems even cooler :)
15:40:44 <Twey> eval-print-last-sexp
15:40:51 <Gracenotes> or highlighting and seeing the arguments
15:41:01 <Twey> Write it, then :)
15:41:05 <Gracenotes> I shall!
15:41:16 <Gracenotes> the difficult part will be parsing, though
15:41:38 <Twey> I wrote a parsing module for JS
15:41:44 <Twey> But I lost it
15:41:51 <Heffalump> aww
15:41:59 <ksf> There's just one thing I have to say about emacs, and it's the most evil: DYNAMIC SCOPE!
15:42:11 <Gracenotes> just counting the parens should be enough for basic tokenization
15:42:29 <Twey> ksf: Dynamic scope?  In *my* elisp?!
15:42:30 <Twey> :-P
15:42:36 <hydrapheetz> I just like vim's simplicity (single keys for moving around/manipulating text.) I guess that's why I've stuck with it for so long.
15:42:49 <p_l> Gracenotes: Isn't it similar to Oberon? It had executable text :)
15:43:02 <Gracenotes> Oberon, eh?
15:43:06 <ksf> additionally, I don't seem to be able to exit emacs if I ever start it.
15:43:22 <p_l> ksf: how come?
15:43:33 <ksf> there's just no such simple thing as :q
15:43:36 <Twey> hydrapheetz: Except it's not really simple, because you have to make sure you're in the right mode
15:43:50 <Twey> You could accomplish the same thing in emacs with a sticky ctrl key :)
15:43:58 <ksf> Twey, most vi users are spoiled by vim.
15:44:16 <Twey> C-x C-c to exit, by the bye.
15:44:17 <ksf> where you can backspace and cursor-navigate in insert mode.
15:44:18 <hydrapheetz> but but but I really don't want to reach all the way for the ctrl key :<
15:44:31 <rwbarton> Oh yeah, but the ESC key is like right there.
15:44:33 <hydrapheetz> (Yes, I know about the vim emulation modes.)
15:44:44 <Twey> Hahaha
15:44:45 <mmorrow> Gracenotes: there's a Parsec JS parser in here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/WebBits
15:44:49 <hydrapheetz> (vi/vim)
15:44:50 <Gracenotes> I haven't learned any terminal-based text editors yet.
15:44:55 * ksf long since remapped esc to where it belongs: left of the 1.
15:45:02 <Gracenotes> I don't want to become emotionally involved :X
15:45:05 <p_l> the first thing you need to have in order to use emacs is ctrl-key remapped into proper place :)
15:45:22 <Twey> Nah
15:45:35 <Twey> My hands fit C-anything nicely
15:45:37 <Gracenotes> mmorrow: oh, neat. Although in this case, JS is doing the parsing
15:45:43 <Twey> In its default place at the corner there
15:45:52 <smitty1e> Gracenotes: is there another editor besides emacs?
15:45:58 <Twey> Gracenotes: Yhc's JS backend!  :)
15:46:26 <mmorrow> Gracenotes: in that case, here's a JS parser + evaluator in JS: http://mxr.mozilla.org/mozilla/source/js/narcissus/
15:46:49 <Gracenotes> I'm not even parsing JS :P just simple lambda expressions
15:47:04 <Gracenotes> that is neat, though
15:47:38 <mmorrow> Gracenotes: i thought you were going to make a js evaluator that we can click on in yi? ;)
15:48:13 <Gracenotes> well, one clicks on redexes, and they're applied to their arguments (or are the arguments applied to them...? always confuse that)
15:48:26 <nikanj> mmorrow: I remember reading some Yegge rants about narcissus but I'm having recall issues. I remember it didn't fit his needs too well..
15:48:37 <Gracenotes> I'll probably use Haskell form for it: \x -> x
15:48:47 <Gracenotes> or a combination, \x. x
15:49:24 <mmorrow> nikanj: i've tried it and didn't get it to really do anything exciting (but i probably don't know how to use it, etc, etc)
15:49:49 <mmorrow> , parseExp "\\x->x"
15:49:50 <lunabot>  Right (LamE [VarP x] (VarE x))
15:50:32 <Gracenotes> oh, nice
15:50:43 <mmorrow> , (\(Right e)->(\(LamE [x] (LamE [y] e)) -> LamE [x,y] e) e) (parseExp "\\x->\\y->x y")
15:50:45 <lunabot>  luna: <interactive>:1:51-106: Non-exhaustive patterns in lambda
15:50:47 <Gracenotes> , parseExp "\\x y -> y x"
15:50:49 <lunabot>  Right (LamE [VarP x,VarP y] (AppE (VarE y) (VarE x)))
15:50:58 <rwbarton> It seems like haskell-src-exts should provide a direct interface to parse an expression that doesn't involve "main = " hackery.
15:51:11 <mmorrow> , (parseExp "\\x->\\y->x y")
15:51:13 <lunabot>  Left "2\nSrcLoc {srcFilename = \"<unknown>.hs\", srcLine = 3, srcColumn =...
15:51:16 <mmorrow> wuh
15:51:18 <Gracenotes> eek
15:51:23 <mmorrow> , (parseExp "\\x -> \\y -> x y")
15:51:25 <lunabot>  Right (LamE [VarP x] (LamE [VarP y] (AppE (VarE x) (VarE y))))
15:51:27 <Gracenotes> I've written a lambda calculator evaluator that uses Vars, Lams and Apps. So porting JS shouldn't be that difficult
15:51:27 <mmorrow> fail
15:51:34 <mmorrow> , (\(Right e)->(\(LamE [x] (LamE [y] e)) -> LamE [x,y] e) e) (parseExp "\\x-> \\y -> x y")
15:51:35 <lunabot>  LamE [VarP x,VarP y] (AppE (VarE x) (VarE y))
15:51:38 <rwbarton> , [$ty| parseModule |]
15:51:40 <lunabot>  luna: Exception when trying to run compile-time code:
15:51:41 <mmorrow> , ppDoc $ (\(Right e)->(\(LamE [x] (LamE [y] e)) -> LamE [x,y] e) e) (parseExp "\\x-> \\y -> x y")
15:51:43 <lunabot>  \x y -> x y
15:51:45 <rwbarton> , parseModule
15:51:46 <lunabot>  luna: Not in scope: `parseModule'
15:52:11 <mmorrow> if only TH had imports/exports/modules
15:52:34 <mmorrow> , parseHsModule "module Asdf where\nmain = print ()\n"
15:52:36 <lunabot>  Right (Module (SrcLoc {srcFilename = "<unknown>.hs", srcLine = 1, srcColu...
15:52:42 <rwbarton> > \x->\y->x y
15:52:44 <lambdabot>   <no location info>: parse error on input `->\'
15:52:47 <mmorrow> ah
15:53:05 <Gracenotes> the lack of a ->\ operator has troubled me before :P
15:53:21 <Gracenotes> until I learned about multi-args lambda expressions, that is
15:53:32 <mstr> > let mean x = (sum x) / (length x)
15:53:33 <lambdabot>   <no location info>: parse error on input `;'
15:53:43 <mstr> @let mean x = (sum x) / (length x)
15:53:43 <lambdabot>  <local>:4:9:
15:53:43 <lambdabot>      No instance for (Fractional Int)
15:53:43 <lambdabot>        arising from a use...
15:53:44 <mmorrow> , either undefined (text . pprHsModule) $ parseHsModule "module Asdf where\nmain = print ()\n"
15:53:45 <lunabot>  module Asdf where
15:53:45 <lunabot>  main = print ()
15:53:53 <Gracenotes> mstr: genericLength may prove useful there
15:54:00 <Gracenotes> :t length
15:54:02 <lambdabot> forall a. [a] -> Int
15:54:02 <rwbarton> , parseExp "\\(\\\\)->(\\\\)"
15:54:04 <lunabot>  Right (LamE [VarP \\] (VarE \\))
15:54:05 <Gracenotes> :t genericLength
15:54:06 <lambdabot> forall b i. (Num i) => [b] -> i
15:54:07 <mmorrow> hehe
15:54:09 <mstr> @let mean x = (sum x) / (genericLength x)
15:54:10 <lambdabot>  Defined.
15:54:16 <mstr> ah, thx Gracenotes
15:54:26 <mmorrow>  , $(return (parseExp "\\(\\\\)->(\\\\)"))
15:54:32 <mmorrow> , $(return (parseExp "\\(\\\\)->(\\\\)"))
15:54:33 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
15:54:40 <Gracenotes> mstr: sure. length forces it to be an Int, but genericLength works with whatever is inferred
15:54:43 <mmorrow> , $(return . either undefined id $ (parseExp "\\(\\\\)->(\\\\)"))
15:54:45 <lunabot>  luna: No instance for (GHC.Show.Show (t -> t))
15:54:52 <mmorrow> , $(return . either undefined id $ (parseExp "\\(\\\\)->(\\\\)")) 42
15:54:54 <lunabot>  42
15:54:57 <mmorrow> haha
15:55:08 <mstr> Gracenotes: but can't int be converted to double?
15:55:10 <mmorrow> , return . either undefined id $ (parseExp "\\(\\\\)->(\\\\)")
15:55:11 <lunabot>  luna: No instance for (GHC.Show.Show (m Language.Haskell.TH.Syntax.Exp))
15:55:23 <mmorrow> , ppDoc . either undefined id $ (parseExp "\\(\\\\)->(\\\\)")
15:55:25 <lunabot>  \(\\) -> (\\)
15:55:29 <Gracenotes> mstr: it can be, with fromIntegral
15:55:32 <porges> mstr: you have to tell it to be
15:55:41 <rwbarton> @src genericLength
15:55:41 <lambdabot> genericLength []    = 0
15:55:42 <lambdabot> genericLength (_:l) = 1 + genericLength l
15:55:45 <mmorrow> , (\(\\) -> (\\)) 42
15:55:46 <lunabot>  42
15:55:56 <Gracenotes> however, better not to touch Ints at all, I think. (unless performance demands it, which I don't know if it will)
15:55:58 <mmorrow> oh, for some reason i thought we were pulling a fast one
15:56:01 <mmorrow> but no
15:56:23 <Gracenotes> \\ is a valid operator, after all
15:56:26 <ddarius> (\\) is a perfectly legitimate operator (and a defined one at that)
15:56:27 <mmorrow> yeah
15:56:32 <ddarius> :t (\\)
15:56:32 <mmorrow> it took me a sec
15:56:33 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:57:15 <Gracenotes> > (\(\\) -> (\\)) (\\) [] []
15:57:17 <lambdabot>   []
15:57:50 <mstr> i see
15:57:59 <augustss> mmmm, obfuscation
15:58:12 <Gracenotes> the identity function! what obfuscation! :P
15:58:51 <mmorrow> , show "\\(\\\\)->(\\\\)"
15:58:52 <lunabot>  "\"\\\\(\\\\\\\\)->(\\\\\\\\)\""
15:59:04 <mmorrow> , reverse $ show "\\(\\\\)->(\\\\)"
15:59:05 <lunabot>  "\")\\\\\\\\(>-)\\\\\\\\(\\\\\""
15:59:09 <Peaker> \ only escapes stuff in a string?
15:59:17 <idnar> eek
15:59:19 <augustss> yes
15:59:30 <augustss> and Char
15:59:30 <idnar> @type (\\)
15:59:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
16:00:02 <Taejo> iterate show "\\"
16:00:06 <Taejo> > iterate show "\\"
16:00:07 <lambdabot>   ["\\","\"\\\\\"","\"\\\"\\\\\\\\\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\\\\\\...
16:00:20 <Gracenotes> that's interesting. reversing Haskell code
16:01:13 <Gracenotes> > reverse "(\x -> foldl (+) x [1..10]) 0"
16:01:15 <lambdabot>   <no location info>:
16:01:15 <lambdabot>      lexical error in string/character literal at chara...
16:01:18 <Gracenotes> :(
16:01:24 <Gracenotes> > reverse "(\\x -> foldl (+) x [1..10]) 0"
16:01:26 <lambdabot>   "0 )]01..1[ x )+( ldlof >- x\\("
16:01:38 <Peaker> ldlof
16:02:06 <Gracenotes> I could have used rdlof, too
16:02:07 <porges> @let ldlof = flip . foldl
16:02:08 <lambdabot>  Defined.
16:03:22 <Gracenotes> huh. interestingly, code in my RPN-based lambda calculus language looks very much like the reversed Haskell code above...
16:03:23 <mmorrow> rwbarton: yeah, it'd be nice without embedding-into-a-module-string-hackery
16:04:05 <rwbarton> mmorrow: Surely there must be such a function in the haskell-src-exts source code, I would think
16:04:14 <rwbarton> mmorrow: I know no such function is exported
16:04:21 <mmorrow> rwbarton: it's actually pretty easy to add new entry points to happy parsers
16:04:38 <mmorrow> i was able to add 8 new entry points to ghc's Parser.y that i extracted for luna
16:04:50 <rwbarton> oh, I see
16:05:06 <mmorrow> http://moonpatio.com:8080/repos/luna/haddocks/Luna-Internal-Parser.html
16:05:13 <mmorrow> all you have to do is:
16:05:55 <mmorrow> so it originally had:
16:05:57 <mmorrow> %name parseModule       module
16:05:57 <mmorrow> %name parseStmt         maybe_stmt
16:06:09 <mmorrow> (and) %partial parseHeader    header
16:06:22 <mmorrow> (partials are interesting because you can get results even upon failure)
16:06:23 <mmorrow> anyway
16:06:32 <ksf> one thing is for shure: It'll take me years to retrain my muscle memory from typing "vi foo<tab>" to "yi foo<tab>". Actually, most likely there'll just be an alias.
16:06:34 <mmorrow> %name parseExpr         exp
16:06:43 <hydrapheetz> Recursion still makes my head hurt
16:06:49 <idnar> ksf: I decided to retrain from 'vi' to 'vim' at one point
16:06:55 <mmorrow> %name parseType         ctype           %name parseKind         kind       %name parseDecls        topdecls_list
16:06:56 <idnar> ksf: so I alised 'vi' to 'echo Use vim, dummy.' :P
16:06:59 <idnar> ksf: err, aliased
16:07:11 <Peaker> I alias 'vi' to 'emacs -nw'
16:07:13 <mmorrow> you just have to track down the production, then add it to the %name list
16:07:33 <mmorrow> rwbarton: (the .y is here http://moonpatio.com:8080/repos/luna/src/Luna/Internal/Parser.y.source)
16:10:03 <smitty1e> Yay.  It looks like I've written the correct function, though, with the kind of exponents involved, the whole thing seems rather paren-sensitive.  Or my haskell-fu is still weak, which is more likely the case. ;)
16:10:20 <Twey> smitty1e: It's weak
16:10:36 <Twey> Become more familiar with the operator precedence — you don't need most of those brackets
16:10:40 <smitty1e> Twey: That's an awful lot of sugar coating on your assessment... ;)
16:10:44 <Twey> (still more can be eliminated by using $ instead)
16:10:53 <Twey> Heh
16:13:37 <Twey> smitty1e: Actually, some of the cases here are even covered by your basic BODMAS or whatever acronym people use where you are
16:14:58 <smitty1e> Twey: Oh, I'm just taking an online physics refresher, and thought that it was time to quit reading about haskell and start using it.
16:15:20 <smitty1e> Thank fortune for #haskell, or would be dead in the water.
16:15:28 <Twey> Heheh
16:15:37 <Twey> 's a nice channel
16:17:21 <porges> buh? I occasionally think I'm missing portions of the chat
16:17:38 <Twey> Perhaps you are
16:18:04 <porges> did smitty1e write their function anywhere
16:18:14 <Twey> porges: A while back
16:18:30 <Twey> 23:21:49 < smitty1e> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=871#a871
16:18:37 <Twey> An hour ago
16:18:41 <porges> ah good :P
16:18:44 <Twey> Heh
16:18:51 <Twey> Don't worry, you're not going mad :-P
16:19:52 <porges> some greek letters would make that nicer :D
16:20:37 <Peaker> I thought I should create a Draw Monoid instead of a Draw Monad, but now I can't get the size of stuff I'm combining in order to draw a cursor, for example :P
16:20:42 <Twey> Haha
16:20:55 <Twey> Peaker: And now you know why it's a monad :-P
16:21:14 <Peaker> Twey: surely it doesn't have to be :P
16:21:27 * Twey shrugs.
16:21:36 <Twey> You never know when a bit of impurity might be necessary
16:21:46 <porges> applicative might fit
16:21:46 <Twey> It's usually wise to make callbacks IO values
16:22:44 <porges> smitty1e:  putStrLn $ show $ x == print x
16:22:51 <smitty1e> porges: I'm working on getting the .lhs thing going in emacs, but I figured I'd focus on substance before style.
16:23:06 <ksf> yi definitely needs an inbulit help.
16:23:17 <Twey> Chains of $ aren't nice
16:23:28 <Twey> Write putStrLn . show $ x
16:23:34 <smitty1e> And LaTeX hates them, too.
16:23:39 <porges> lol
16:23:39 <Twey> Heh
16:23:54 <porges> smitty1e: I meant greek letters in the haskell source
16:23:56 <Twey> Not in \code :)
16:24:04 <porges> rather than epsilon, ε
16:24:16 * porges hugs .XCompose
16:24:22 <Twey> Hehe
16:24:26 <smitty1e> porges: have you got an emacs reference for how to do that?
16:24:39 <porges> smitty1e: Google .XCompose
16:24:45 <porges> then you can use it all over X
16:24:46 <Twey> ϵ ∀ ∃ ≡
16:24:58 * Twey hugs scim-tables
16:26:13 <porges> linky?\
16:26:18 <porges> google's still blocking me
16:27:12 <smitty1e> something like http://dotfiles.org/~inky/.XCompose
16:27:40 <Olathe> Why is Google blocking you ?
16:28:32 <smitty1e> This is a minor hoot: http://img.boxofjunk.ws/thanks-capn-obvious.jpg
16:28:43 <smitty1e> from the ~inky link
16:29:09 <Twey> Oho
16:29:17 <Twey> porges: In emacs, hit C-x RET C-\
16:29:24 <Twey> Select the 'TeX' input method
16:29:32 <Twey> Then you can write stuff like \epsilon
16:29:37 <porges> oh, emacs :P
16:29:40 <skorpan> i only need to hit C-\ here for some reason...
16:29:50 <Twey> And \equiv
16:29:52 <lucca> skorpan: c-\ toggles after you've selected an input method
16:29:59 <Twey> skorpan: That's just to enable/disable current input method
16:30:15 <skorpan> right, but if i haven't chosen one it asks me
16:30:21 * Twey nods.
16:30:23 <skorpan> so there...
16:30:26 <skorpan> no need for C-x RET
16:30:32 <Twey> Oh
16:30:38 <Twey> smitty1e: You asked the question, sorry :)
16:30:57 <Gracenotes> heh, it's a different experience to program once again with mutable variables, in JavaScript
16:31:01 <Twey> For the same functionality in X, install scim and scim-tables and use the LaTeX input
16:31:08 * Gracenotes has to get used to this
16:31:11 <porges> smitty1e: so yeah, I bound => to ⇒, -> to → and so on
16:31:16 <smitty1e> Yeah, but I've got font troubles.  I get the box which I guess is a font monad.
16:31:25 <porges> greek letters to G-[semi-equivalent latin letter]
16:31:47 <smitty1e> Probably my encoding on the file is AFU.
16:31:49 <skorpan> емакс кан евен до кыриллик
16:32:00 <porges> G-E = ε, G-P-I = π
16:32:07 <smitty1e> skorpan: that's an odd piano on my screen.
16:32:16 <Olathe> ｚｏｍｇ ！
16:32:25 <Twey> イット　カン　アルソ　デゥー　ジャパニーズ :-P
16:32:41 <SamB> what's with Olathe and Twey writing in Japanese ?
16:32:43 <smitty1e> But the hiragana looks good.
16:32:57 <Twey> smitty1e: That was katakana :-P
16:32:58 <skorpan> こにちわ
16:32:59 <lucca> ¬_¬
16:33:00 <porges> Haskell' needs to drop the capitalization rules
16:33:08 <Twey> skorpan: 「こんにちは」
16:33:20 <skorpan> -ha?
16:33:22 <smitty1e> Twey: challenge to tell at this resolution.
16:33:26 <ksf> stop it, ircii messes up half of all that unicode.
16:33:27 <skorpan> i don't speak japanese
16:33:36 <Twey> SamB: skorpan said (in Cyrillicised English): emacs can even do Cyrillic
16:33:38 <skorpan> ksf: all the more reason to switch to emacs :P
16:33:51 <Olathe> What I said in English was: zomg !
16:33:52 <Twey> I said (in katakana-ised English): it can also do Japanese
16:33:59 <smitty1e> skorpan: domo arigotoni with meatsauce.
16:34:05 * Twey laughs.
16:34:10 <Twey> skorpan: No, not -ha
16:34:16 <skorpan> 모후ㅕㅣ 냐 솓 채ㅐ딘ㅅ 쇄혀ㅗ
16:34:25 <SamB> Olathe: I'm just commenting on your use of the crazy wide chars ;-P
16:34:26 <Twey> That's the 'wa' — it's the topic particle, so it's written as は
16:34:26 <skorpan> let's see someone decipher that
16:34:32 <lucca> hmm, wide chars eh?
16:34:33 <Olathe> SamB: I know :)
16:34:38 <lucca> ⃝⃟̸̢̢̥̻̻̥̦̦⃡⃡̑̎ò⃒⃚̡̢̙̜̭̬̬̿⃐⃐⃗⃕⃔⃛̚͡⃝⃟⃠⃒⃓̴̶̶⃒̢̛̛̬̭̰̬̫̫̪̩̘̝̟̣̤̣̟̙̝̝̲̲̝̭̭̫̫⃖́⃗⃗⃗̔̔̾̚
16:34:42 <skorpan> WHOA
16:34:43 <Twey> I learnt hangeul, but forgot it again :(
16:34:46 <skorpan> that messed my emacs up lucca
16:34:47 <Twey> lucca: HOLY MONKEYS
16:34:59 <Twey> Haha
16:35:01 <lucca> yay unicode
16:35:09 <ksf> both my ircii and konsole are still fine.
16:35:12 <SamB> lucca: you're messing up my x-chat too
16:35:12 * skorpan goes looking for klingon...
16:35:14 <smitty1e> Actually, I shouldn't be so careless with another language.  No disrespect to the Japanese intended, to any future transcript readers.
16:35:23 <Twey> My irssi is fine too :)
16:35:25 <SamB> I think pango doesn't grok those chars or something
16:35:31 <Twey> skorpan: There's no Klingon in Unicode
16:35:35 <skorpan> Twey: i know :(
16:35:37 <smitty1e> racismQ
16:35:40 <Twey> Hahaha
16:35:43 <skorpan> but there is some "unofficial" support
16:35:45 <mauke> oo҉
16:35:49 <ksf> that'd be speciesism.
16:35:51 <SamB> the conscript registry
16:35:53 <Twey> Yeah
16:35:58 <smitty1e> xenophobia
16:35:58 <Twey> Unmaintained now :(
16:36:03 <Twey> Cowan gave up on it, I think
16:36:04 <SamB> really ???
16:36:09 <SamB> aww :-(
16:36:20 <Twey> I still use it anyway
16:36:24 <Twey> Hey, it's better than nothing
16:37:27 <StoneToad> I have a function that's defined as "bar = foo", foo is [[a]] -> [[a]] -> [a], but bar is [[Integer]] -> [[Integer]] -> [Integer] ... what's going wrong?
16:37:39 <mauke> monomorphism restriction
16:37:51 <Olathe> ...is the work of SATAN
16:37:53 <Twey> Ych
16:37:56 <Twey> KILL IT WITH FIRE
16:37:58 * ksf never got what that was about, he just disabled it.
16:38:02 <Twey> Hahaha
16:38:05 <Peaker> A TTF font is a pure data structure, but SDL's font size computation is in IO :-(
16:38:24 <StoneToad> mauke: so adding a type signature will fix it?
16:38:25 <Olathe> It requires IO ?
16:38:29 <mauke> StoneToad: try it
16:38:38 <Peaker> Olathe: I'd think not, but according to SDL.TTF it does
16:38:39 <ksf> all ffi functions are IO
16:38:45 <Twey> {-# LANGUAGE NoMonomorphismRestriction #-}
16:38:45 <Peaker> ksf: not all of them
16:39:09 <Olathe> Well, if the result won't change, they could use unsafeZomgIO to get around that.
16:39:12 <Twey> Peaker: Because the computation involves impure input
16:39:16 <Twey> (screen size and the like)
16:39:42 <ksf> ...SDL could also choose to load a changed ttf without you noticing, breaking purity.
16:39:50 <Peaker> Twey: given TTF and font size, it needs the screen size to determine how many pixels some text will take?
16:39:57 <Twey> Peaker: *nods*
16:40:06 <Peaker> ksf: then screw SDL :-)
16:40:07 <Twey> Font size, IIRC, is provided in points
16:40:13 <Twey> (may be wrong here)
16:40:13 <StoneToad> mauke: seems odd that I didn't get the problem on both... (type signature on bar makes it work it seems)
16:40:44 <Peaker> I guess I do need a Draw Monad where I have getFontSize and drawing operations
16:40:44 <Twey> The actual size in pixels of the text depends on screen resolution and some other stuff
16:40:51 <Peaker> oof
16:40:54 <porges> Haskell source needs a layout engine with sub- & superscripts :P
16:41:33 <Twey> porges: It's called Agda
16:41:38 <skorpan> haskell needs readline because editline apparently doesn't do utf-8 which makes testing a pain in the ass
16:41:49 <SamB> Twey: that doesn't really do it
16:42:03 <ksf> skorpan, use a gui.
16:42:05 <Twey> Am I thinking of Epigram?  :)
16:42:13 <ksf> failing that, a unix pipe.
16:42:14 <SamB> Twey: it only does Unicode
16:42:15 <skorpan> ksf: how would that help?
16:42:20 <Twey> ksf: That's not the point
16:42:24 <SamB> which can FAKE a few sub- and super- scripts
16:42:37 <Twey> Point
16:42:50 <skorpan> exchange-point-and-mark
16:42:50 <ksf> usually, tk's come with textboxen that do unicode.
16:43:17 <skorpan> ksf: i'm not sure tk is less of a pita than editline
16:43:19 <Twey> ksf: Yes, but GHCi doesn't.  Unless you're thinking of reimplementing all of GHCi...
16:43:31 <ksf> tk, not tk.
16:43:34 <ksf> twey, ok.
16:43:39 <ksf> toolkit.
16:43:44 <sbahra> @fact logic
16:43:44 <Taejo> Twey, why did you learn Hangeul?
16:43:44 <lambdabot> logic: ⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳
16:43:53 <Twey> Taejo: Because I thought I'd learn Korean
16:44:00 <Taejo> lol, same
16:44:06 <Twey> Never got around to it though :)
16:44:09 <skorpan> ksf: s/tk/some gui toolkit/
16:44:13 <Twey> Ditto with Russian/Cyrillic :(
16:44:28 <BMeph> skorpan: editline doesn't do utf-8 because it has WTF-8p ;)
16:44:37 <Taejo> my Cyrillic is worse than my Hangeul
16:44:46 <Twey> s/some gui toolkit/JUST SAY GTK2HS ALREADY/
16:44:58 <ksf> doesn't compile over here.
16:45:10 <Twey> What crazy machine are you using?
16:45:16 <skorpan> I'M NOT SURE GTK2HS IS LESS OF A PITA THAN EDITLINE
16:45:17 <ksf> ghc 6.10.1
16:45:25 <ksf> same goes for wxhaskell.
16:45:27 <Twey> Taejo: I haven't forgotten my Cyrillic because people use it all the time :-P
16:45:32 <Taejo> actually, the Cyrillic I know is equal to the intersection of Cyrillic with Greek
16:45:33 <Twey> ksf: Oh ah :-\
16:45:37 <SamB> BMeph: has what now ?
16:45:39 <Twey> Taejo: Haha :-P
16:45:56 <ksf> taejo, afair that's even less than the intersection with latin.
16:45:58 <Twey> Wait, I'm using 6.10.1, and I have gtk2hs
16:45:59 <pumpkin> o hai
16:46:09 <BMeph> SamB: Take a step back and look at it... ;)
16:46:25 <Twey> He
16:46:33 <ksf> that's why I'm doing agar bindings right now.
16:47:05 <Twey> You could do APL instead :-P
16:47:08 <smitty1e> are any of the gentoo haskell folks in this chat?
16:47:20 <ksf> ...with a proper, reactive interface, while i'm at it.
16:47:22 <SamB> dcoutts: ?
16:47:28 <porges> @fact haskell
16:47:29 <lambdabot> I know nothing about haskell
16:47:46 <ksf> twey, agar even comes with ada bindings. no apl, though.
16:47:47 <smitty1e> lambdabot understands the bliss of ignorance
16:48:14 <ksf> smitty1e, I'm using gentoo, but am not gentoo-haskell folk.
16:48:19 <augustss> @quote haskell
16:48:19 <lambdabot> Boney says: Haskell is like Lego
16:48:49 <ksf> @quote gentoo
16:48:50 <lambdabot> lambdabot says: Will I get a treat if I join #gentoo-uy?
16:49:04 <Twey> Boo, gtk2hs fails to compile
16:49:10 <smitty1e> ksf: yeah, the portage is only at 6.8.2 for ghc
16:49:23 <ksf> the overlay is at 6.10.1
16:49:24 <smitty1e> my gentoo-fu is lamer than my haskell-fu
16:49:30 <ksf> emerge layman
16:49:35 <ksf> layman -a haskell
16:49:56 <smitty1e> ah! not having that overlay yet.  let me catch up in my course before I frobnicate.
16:51:14 <ksf> anyway, gtk is a sluggish beast.
16:51:22 <smitty1e> ksf: it actually downgraded met a version while installing the literate haskell stuff.  should have thought to get the overlay.
16:51:55 <ksf> I usually only do emerge ghc cabal-install and then cabal install the rest.
16:52:17 <roconnor> :D Pick Haskell if: You want there to be a good chance that your program will run correctly the first time it successfully compiles.
16:53:04 <Twey> ksf: GTK isn't
16:53:07 <Twey> GNOME is
16:53:23 <Twey> I always thought that too, until I stopped using GNOME.  GTK alone is actually very snappy.
16:53:32 <Taejo> ksf: greek and cyrillic: г,д,л,п,р,ф,х (7); all three: а, в, е,к,м,о,с,т,у (8);  latin and cyrillic: none
16:53:51 <Taejo> so, technically you're right
16:54:08 <ksf> в is a false friend.
16:54:16 <ksf> it's actually pronounced w.
16:54:26 <ksf> the b looks similar, though.
16:54:38 <smitty1e> I'm using xfce
16:54:52 <Peaker> Oh, the decisions from 1200BC taking their toll on today's folk
16:54:55 <Twey> ksf: It's pronounced [v]
16:55:05 <ksf> well, not in germany.
16:55:10 <Twey> Ah :)
16:55:24 <Twey> Well... yes (that was IPA [v] :-P)
16:55:38 <smitty1e> ksf: where in Germany?  My in-laws live near Heidelberg.
16:55:39 <porges> Yi requires alex but it doesn't install it when I `cabal install yi`?
16:55:46 <Twey> It doesn't have the [ʋ] allophone that German 'w' has, though
16:55:50 <ksf> near hamburg.
16:56:21 <ksf> two or three cat throws away from http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:56:54 <SamB> porges: cabal isn't good at installing tools
16:57:33 * ksf just successfully installed yi.
16:57:37 <ksf> ...via cabal install
16:57:38 <Taejo> so в is like beta in modern Greek, and б is like B in Latin and beta in ancient Greek?
16:58:10 <ksf> I propably could tell you if I knew anything about greek.
16:58:32 <Taejo> AFAIK, beta is /v/ in modern Greek, and /b/ in ancient
16:58:43 <ksf> but yes, в=v and б=b
16:58:44 <Twey> Taejo: Right
16:58:51 <Twey> And right
16:59:31 <smitty1e> So, will haskell be ported to the past, so that my undergraduate experience a couple decades back can suck less?
17:00:05 <csaba_> hi! how can i restrict a [t] type to accept only types derived from a specified typeclass?
17:00:08 <Twey> smitty1e: If it didn't involve Lisp even back then, there's nothing we could have done for you :-P
17:00:25 <Twey> csaba_: TypeClass t => [t]
17:01:10 <ksf> unicode fail.
17:01:22 <Taejo> I'm really proud of http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=875#a875
17:01:35 <smitty1e> It involved TrueBasic, whose only "claim to fame" was the ability to perform matrix operations on up to two matrices.
17:01:43 <smitty1e> So, that was a flogging.
17:01:52 <ksf> http://www.alanwood.net/unicode/cyrillic.html <- the unicode names give the pronounciation
17:02:01 <smitty1e> Some Matlab, too.
17:02:22 <mauke> whoa, darcs gtk2hs compiled
17:02:24 <ksf> that's a lot more than the contemporary russian set, though.
17:02:30 <mauke> pgavin++
17:02:52 <SamB> smitty1e: you could always go back to school
17:03:01 <SamB> of course, it'll probably suck even more this time ;-P
17:03:17 <smitty1e> I kind of am at the moment, for a certificate, but my wife doesn't want me to pursue the PhD.
17:05:45 <csaba_> what;s the problem with this: class ModelAttr a => [a]
17:05:53 <ksf> while we're at it, e is usually je, p is r, c is s , y is u, x is ch like in german bach and я isn't an r, at all.
17:06:20 <ksf> in general, it's a bugger to get used to.
17:06:25 <ksf> ... and H is n.
17:07:00 <Twey> я is 'ya', е is 'ye'
17:07:18 <Twey> ksf: If we're talking in English, use English orthography to describe the sounds... or, better, IPA :-P
17:07:38 <porges> Taejo: parZipWith? :)
17:07:41 * ksf searches his mind for an example of e -> e instead of ye.
17:08:01 <Taejo> @src parZipWith
17:08:01 <lambdabot> Source not found. I feel much better now.
17:08:09 * ksf tries to locate his dictionary
17:08:11 <Taejo> @hoogle parZipWith
17:08:12 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
17:08:15 <Twey> Well, it's not strictly 'ye' and 'ya'
17:08:31 <porges> Taejo: to make it even nicer :P
17:08:35 <Twey> They're soft vowels: if a consonant comes before them, they palatalise it
17:08:48 <Twey> E.G. in the name Андреева
17:09:07 <ksf> the worst thing in russian orthography is o -> a.
17:09:10 <Taejo> porges, does that work if your zipping a list with its own tail?
17:09:21 <Twey> The first е is 'e' (can't palatalise р) and the second is 'ye'
17:09:39 <Taejo> porges, I mean, how much parallelisation can you do
17:09:56 <porges> good point
17:10:00 <porges> probably need to test that :P
17:10:01 <Olathe> Is there a short version of msum.map return ?
17:10:07 <Twey> ksf: You mean ∀o. (Vowel o) => o -> a? :-P
17:10:13 <ksf> yeah.
17:10:29 <Twey> That, and the almost totally random stress.
17:10:45 <ksf> that rule that makes russian think you're from backwards siberia if you pronounce stuff like it's written.
17:10:49 <Twey> Yeah :-P
17:11:57 <lament> in the word 'moloko' (milk), all three 'o's are different vowels
17:12:17 <ksf> in kirov, the first two are the same.
17:13:29 <Taejo> porges, I can't think how one would make a parallelisable integrator, if the "force function" is opaque
17:18:29 <porges> *cry*
17:19:35 <islon_s> hi guys
17:20:14 <Taejo> islon_s, hi
17:21:05 <ksf> htf do I tell c2hs to make a non-IO foreign import?
17:21:41 <islon_s> is there a way to know the function name inside it?
17:21:43 <Axman6> foreign import superSafeISwear f
17:22:00 <SamRH> islon_s congratulations, you asked a stupid question
17:22:06 <SamRH> oh wait I'm sorry :(
17:22:08 <ksf> islon_s, why would you want to?
17:22:19 <SamRH> excuse me, I'm being dumb, wrong channel, wrong language, wrong.. everything :(
17:23:03 <islon_s> ksf: i have a function that take a string and create some data but this string is always the name of the function
17:23:25 <ksf> ah, my crystal globe was right. use TH to generate them.
17:23:38 <Taejo> islon_s, what if the function didn't have a name? or it had multiple names?
17:24:19 <islon_s> Taejo: o.o?? its 5 functions they have specific names
17:24:46 <ksf> islon_s, he's referring to foo = bar; baz = foo.
17:24:56 <ksf> "bar" has two names there.
17:25:19 <Taejo> islon_s, what ksf said, plus anonymous functions: what is the name of \x -> x
17:25:21 <islon_s> its a static string
17:25:33 <ksf> islon_s, as I said, use template haskell.
17:25:48 <Cale> islon_s: Functions don't have names at runtime.
17:25:48 <islon_s> 'orc lv = newEnemy Warrior "orc" lv' the parameter to Warrior is always the name of the function
17:25:50 <SamRH> islon_s: even writing something like myFunc = do { x <- foo; return (thisFunction'sName ++ x } would be no good
17:25:51 <ksf> I wouldn't bother if it's just a couple of functions, though.
17:26:09 <ksf> ouch.
17:26:16 <ksf> you don't want to type with strings.
17:26:27 <ksf> data Beast = Orc | Gollum
17:26:42 <ksf> data Warrior = Warrior Beast
17:27:10 <Olathe> data Data = Data Data
17:27:19 <islon_s> nevermind
17:27:35 <ksf> olathe, that's arbritrarily sensefree.
17:32:45 <Olathe> Data . Data . Data . Data $ undefined :: Data
17:33:42 <jeffz`> @type (\f x -> f >>= (flip x))
17:33:44 <lambdabot> forall a a1 c. (a1 -> a) -> (a1 -> a -> c) -> a1 -> c
17:33:58 <jeffz`> @hoogle (a1 -> a) -> (a1 -> a -> c) -> a1 -> c
17:33:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:33:58 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
17:33:58 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
17:34:03 <ksf> gnargh c2hs even treats accesses like foo->bar as IO
17:34:58 <Olathe> @type (\f x -> f >>= (flip x)) (+) (id.(+))
17:35:00 <jeffz`> @pl (\f x -> f >>= (flip x))
17:35:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
17:35:00 <lambdabot>       Expected type: a -> (a -> a) -> c
17:35:00 <lambdabot>       Inferred type: a -> a -> a
17:35:01 <lambdabot> (. flip) . (>>=)
17:35:15 <Olathe> @type (\f x -> f >>= (flip x)) (+2) (id.(+2))
17:35:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> c
17:35:16 <lambdabot>     Probable cause: `.' is applied to too many arguments
17:35:16 <lambdabot>     In the second argument of `(\ f x -> f >>= (flip x))', namely
17:35:39 <Olathe> @type (\f x -> f >>= (flip x)) (+2) (const.(+2))
17:35:41 <lambdabot> forall b. (Num b) => b -> b
17:36:07 <Olathe> @type (\f x -> f >>= (flip x)) (+2) (const.(+2)) x
17:36:09 <lambdabot> Expr
17:36:13 <Olathe> > (\f x -> f >>= (flip x)) (+2) (const.(+2)) x
17:36:15 <lambdabot>   x + 2
17:39:48 <ksf> instance EditableI TextBox where
17:39:49 <ksf>     editableI tb = fromVoid $ unsafePerformIO ({#get AG_Textbox->ed#} (void tb))
17:40:03 <ksf> ...and I thought haskell would safe me from doing such stuff.
17:41:12 <snookerb> hey ho
17:41:20 <snookerb> i have a short question about a notation in haskell
17:41:24 <snookerb> data Attr  = ProgAttr {x,y,w,h,speed::Int}
17:41:30 <snookerb> how do i handel this type
17:41:46 <ksf> what do you want to do?
17:41:53 <snookerb> i mean, if i have an instance of Attr, how do i access / modify / read each atribut?
17:41:56 <ksf> construct it, match it, or access it.
17:42:05 <snookerb> well, i will have to use all
17:42:10 <snookerb> first i have to construct it
17:42:14 <snookerb> later to edit it
17:42:23 <ksf> matching and constructing works like with normal data types.
17:42:36 <ksf> additionally, you get functions named like the fields.
17:42:38 <snookerb> like
17:42:38 <snookerb> ProgAttr{x=0,y=0,w=0,h=0,speed=50}
17:42:38 <islon_s> accessx attr = attr{x}
17:43:04 <ksf> so you can do "x myAttrs" to get the x field of myAttrs
17:43:07 <islon_s> updatex attr value = attr{x = value}
17:43:17 <snookerb> ahh, cool
17:43:32 <ksf> myAttrs {x=4} gives you a new Attr with x set to 4 and the rest equal to myAttrs
17:43:33 <snookerb> thanks a lot
17:43:35 <islon_s> but it dont update the attr it return a new one
17:43:41 <Peaker> damn github is cooler than launchpad
17:43:50 <snookerb> i see
17:43:59 <snookerb> ok, so it pretty straighforward
17:44:00 <islon_s> *doesnt
17:44:07 <snookerb> ;-)
17:44:23 <islon_s> i use it a lot ;)
17:44:27 <ksf> haskell usually tends to be straightforward, after you let it rape your mind.
17:44:39 <snookerb> its quite wierd
17:44:44 <snookerb> i have never seen the notation before
17:44:50 <snookerb> and is quite hard to google because of the bracket ^^
17:44:59 <Peaker> @remember ksf haskell usually tends to be straightforward, after you let it rape your mind.
17:44:59 <lambdabot> Done.
17:45:01 <snookerb> anyway, looks very usefukk
17:45:02 <islon_s> im still trying to resist the rape
17:45:10 <ksf> there's the haskell report.
17:45:16 <ksf> and there's rwh.
17:45:20 <ksf> @where rwh
17:45:20 <lambdabot> is http://www.realworldhaskell.org/blog/
17:45:25 <snookerb> yeah, i think i am through the raping level and quite comfortable with the general idea
17:45:33 <snookerb> but some little notations still drive me crazy
17:45:41 <snookerb> but thank god there is this channel and google ^^^
17:45:53 <snookerb> ok
17:45:56 <islon_s> IO drives me crazy (i'm a imperative programmer)
17:46:14 <ksf> IO drives me crazy (i'm a functional programmer)
17:46:20 <snookerb> yeah, many thinks are kind of strange, but in the end very nice
17:46:28 <snookerb> after the rqping stage ;-)
17:46:46 <islon_s> im programming a little and simple rpg and its full of state ><
17:46:52 <snookerb> ok guys, thanks a lot for you help!
17:46:57 <snookerb> back to coding now ^^^
17:48:08 <cognominal> (Nothing:)    left me perplex... until I thought about partial application  :)
17:48:24 * ksf needs to have a look at the gtk2hs code to see if he can snarf stuff
17:48:32 <Peaker> @type lift ask
17:48:34 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, MonadReader a m) => t m a
17:48:34 <ksf> ...about anything _but_ the build system, that is.
17:48:39 <Peaker> @type (lift . lift . lift) ask
17:48:41 <lambdabot> forall (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) (m :: * -> *) a (t2 :: (* -> *) -> * -> *). (MonadReader a m, MonadTrans t2, Monad (t2 m), MonadTrans t1, Monad (t1 (t2 m)), MonadTrans t)
17:48:41 <lambdabot> => t (t1 (t2 m)) a
17:48:41 <ksf> I want stuff to work, after all.
17:50:26 <islon_s> me too, in a simple and straitforward way
17:50:29 <Olathe> @src lift
17:50:30 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:50:34 <Olathe> @type lift
17:50:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
17:50:49 <Olathe> @instances MonadTrans
17:50:50 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
17:52:06 <islon_s> they could have named lambdabot as a woman
17:53:14 <dpratt71> reading through RWH...
17:53:33 <dpratt71> ...having difficulty mentally "parsing" something...
17:53:52 <dpratt71> ...anyone willing to try to interpret for me?
17:53:57 <ksf> @vixen, a/s/l
17:53:58 <lambdabot> 19/f/California
17:54:40 * jeffwheelerPhone wonders where in California
17:54:56 <ksf> @vixen, where in California?
17:54:56 <lambdabot> why don't you guess?
17:55:09 <jeffwheelerPhone> :(
17:55:23 <ksf> yeah, she's usually not very approachable.
17:56:54 <dons> ?yow
17:56:54 <lambdabot> Hello.  I know the divorce rate among unmarried Catholic Alaskan females!!
17:57:08 <dons> phew, that was a long day. but now it is lambda o'clock
17:58:02 <Saizan> dpratt71: what is it?
17:58:43 <dpratt71> Saizan:
17:58:45 <dpratt71> newtype Parse a = Parse {
17:58:46 <dpratt71>       runParse :: ParseState -> Either String (a, ParseState)
17:58:48 <dpratt71>     }
17:59:03 <dpratt71> I get this much: ParseState -> Either String (a, ParseState)
17:59:05 <dons> hey guys, anyone want to have a go at a modern haskell cheatsheet?
17:59:07 <dons>   http://www.addedbytes.com/cheat-sheets/python-cheat-sheet/
17:59:34 <dons> Prelude, Lists, Map, bit of System.*
18:00:02 <Saizan> dpratt71: can you parse newtype Parse a = Parse (ParseState -> Either String (a, ParseState)) ?
18:00:42 <dpratt71> Saizan: I think so...
18:00:54 <Saizan> it has only one field which is a function of that type
18:01:22 <porges> dons: apparently programming python is 1/3 processing dates
18:01:26 <dons> :D
18:01:30 <dons> yes, i thought that odd.
18:01:40 <Saizan> then additional you get an accessor, equivalent to this definition: runParse (Parse f) = f
18:01:42 <dpratt71> Saizan: right
18:02:10 <dpratt71> Saizan: ah
18:02:41 <Saizan> it's called record syntax, and "runParse" is the name of the only field of this record
18:03:10 <Saizan> you also get special syntax for updating, like "p { runParse = foo }"
18:03:13 <dpratt71> Saizan: I find it strange the way the constructor parameter is specified via the accessor definition (not sure my terminology is right)
18:03:47 <porges> dpratt71: it's the same as
18:03:59 <dpratt71> Saizan: now you've lost me :)
18:04:05 <porges> newtype Parse a = Parse (ParseState -> Either String (a, ParseState))
18:04:13 <porges> runParse (Parse x) = x
18:04:15 <Saizan> dpratt71: it makes more sense when you have more than one field, e.g. data Point = Point { x :: Int, y :: Int, color :: Color }
18:04:25 <porges> except you also get the 'update' syntax
18:04:44 <dons> oh, SPJ on the list. must be back from vacation
18:04:56 <dons> man, i'm sick of non-stream fused Data.List.
18:05:03 <dons> gotta fix that.
18:05:18 <Saizan> dpratt71: this is just syntactic sugar though, so for now you can just desugar it mentally to the non-record form
18:05:37 <porges> dons: merge merge merge
18:06:25 <porges> it would be nice if foldr & friends from the Prelude were changed to be imported from Foldable
18:06:25 <Nafai> Anyone got time to help me figure out this Stack Space Overflow error?
18:06:27 <dpratt71> Saizan, porges : thanks for explaining this, but could you explain the "update" syntax a bit further
18:07:09 <dpratt71> Saizan: what does "p" represent in "p { runParse = foo }"
18:07:24 <Saizan> dpratt71: a value of type "Parse a"
18:07:30 <porges> the Parse that you're updating
18:07:33 <Peaker> @type local
18:07:34 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
18:08:25 <porges> if you take the Point example, you could do "makeRed point = point { color = Red }
18:08:26 <dpratt71> "updating" sounds a bit like "mutating", which I thought was not the way of Haskell
18:08:50 <Saizan> dpratt71: you just return a new value with that field changed
18:08:58 <islon_s> can i see the function docs in ghci?
18:08:59 <dpratt71> Saizan: ah
18:09:06 <dons> i think i'll just release a Data.List depending on uvector's Stream definitions
18:09:10 <Nafai> In this code: http://github.com/Nafai77/recent-feeds/tree/master
18:09:30 <smitty1e> Haskell trig functions: do they expect radians? :type sin is somewhat ambiguous on the point, but I think it's a 'yes'.
18:09:39 <dpratt71> Saizan, porges: it's all clear now, thanks
18:09:40 <Peaker> If I have newtype SomeTransformer m a = SomeTransformer (ReaderT r1 (ReaderT r2 (ReaderT r3 (m a)))) deriving (MonadTrans, Monad, MonadIO) ; then I have   liftR1= SomeTransformer ; liftR2 = SomeTransformer . lift ; liftR3 = SomeTransformer . lift . lift
18:09:47 <Nafai> Merely putting calls to my deDupItems in the IO monad ouside of my main, I get a stack space overflow error
18:09:47 <dolio> > sin pi
18:09:49 <lambdabot>   1.2246467991473532e-16
18:09:52 <Saizan> point { color = Red } == let (Point x y _) = point in Point x y Red
18:09:53 <Peaker> then how can I use "local" on the middle transformer?
18:10:02 <Nafai> This is before I can even call any of the Data.Binary stuff
18:10:05 <Nafai> Any ideas what's up?
18:10:10 <Peaker> local wants a computation -- but it can't take a computation of the whole monad, just of some internal monad transformer
18:10:13 <smitty1e> sin 40
18:10:19 <smitty1e>  > sin 45
18:10:20 <Peaker> so is "local" really quite incompatible with monad transformers?
18:10:27 <Peaker> > sin 45
18:10:29 <lambdabot>   0.8509035245341184
18:10:39 <dons> hey guys, here's the new proposed MD6 (md5 hash replacement) implemented in cryptol. http://www.reddit.com/r/haskell/comments/7s15q/implementing_rivests_new_md6_algorithm_in_cryptol/
18:10:40 <pejo> dons, have you got time to work on Stream Fusion again?
18:10:43 <dons> cryptol has a haskell backend
18:10:45 <smitty1e> You guys have more mojo than me.. :)
18:11:00 <dons> so it might be cool to generate a good crypto library for haskell, using cyptol as a preprocessor...
18:11:02 <porges> > cos 0 == cos (2 * pi)
18:11:03 <smitty1e> Oh, that's the Bird script, then?
18:11:04 <lambdabot>   True
18:11:05 <dons> pejo: not really
18:11:06 <Peaker> > sin (45 * 2 * pi / 360)
18:11:08 <lambdabot>   0.7071067811865475
18:11:17 <dons> pejo: but its kinda done, so i want to lock it down
18:11:27 <pejo> dons, nice to hear that.
18:11:27 <Peaker> > sin (60 * 2 * pi / 360)
18:11:29 <lambdabot>   0.8660254037844386
18:11:39 <Peaker> > sqrt 2 / 2
18:11:41 <lambdabot>   0.7071067811865476
18:11:51 <porges> smitty1e: degrees are like the imperial system of angles
18:11:56 <Peaker> > sqrt 3 / 2
18:11:58 <lambdabot>   0.8660254037844386
18:12:04 <thoughtpolice> dons: i've been reading lee pike's paper on a verified cryptographic language compiler (a compiler for uCryptol,) very very cool stuff. :)
18:12:13 <Peaker> so, any Monad Transformer guru in here?
18:12:34 <Nafai> dons: You got a moment to help me with some code?
18:12:49 <Saizan> Peaker: well, you have to peel the first layer, like localR2 f (SomeTransformer m) = SomeTransformer (ReaderT $ \r -> local f (runReaderT m r))
18:13:18 <Peaker> Saizan: ah, runReaderT to convert the big computation I have to an inner one
18:13:26 <Peaker> @type withReader
18:13:28 <lambdabot> forall r' r a. (r' -> r) -> Reader r a -> Reader r' a
18:14:11 <Gracenotes> hm... you really can't reduce '(\x. (\y. x)) y' without renaming something, huh.
18:14:29 <dons> thoughtpolice: yeah, there's lots of cool model checking stuff we do with it.
18:14:56 <Peaker> Saizan: that is kind of painful though
18:15:12 <dolio> That's why you use de Bruijn indices.
18:15:17 <Gracenotes> yeah.
18:15:30 <porges> or UUIDs
18:15:32 <porges> ^_^
18:16:40 <Peaker> Saizan: or not so bad, I think
18:18:29 <thoughtpolice> dons: i also looked at iavor's phd thesis which was really really cool. this combined with my coq-playtime thoughts have lead me to think that a high level language for systems programming like in iavor's paper + a bit of theorem proving = ultimate win. on that note, I hope we see something like tom s.'s "type invariants" in GHC soon. :)
18:18:48 <islon_s> whats the easiest way to get a random number between 0 and y??
18:19:27 <porges> @hoogle randomR
18:19:27 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
18:19:27 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
18:19:27 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
18:20:00 <islon_s> any example?
18:20:08 <porges> TH should accept ⟦⟧ for [| |]
18:21:33 <porges> > replicateM 100 $ randomRIO (0,10)
18:21:35 <lambdabot>   * Exception: "<IO [Integer]>"
18:22:00 <islon_s> o.o
18:22:35 <porges> > replicateM 100 (randomRIO (0,10)) >>= print
18:22:37 <lambdabot>   * Exception: "<IO ()>"
18:22:48 <porges> can lambdabot not do IO
18:23:10 <thoughtpolice> no
18:23:19 <sbahra> @fact logic
18:23:19 <lambdabot> logic: ⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳
18:23:20 <porges> do that in ghci then islon_s :)
18:23:29 <islon_s> thanks =)
18:23:30 * gwern ponders the correct parsing of porges's question
18:23:45 <thoughtpolice> if we could:
18:23:50 <sbahra> @fact-update logic "⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳ ⟦⟧"
18:23:50 <thoughtpolice> > removeDirectory "/"
18:23:50 <lambdabot> Fact recorded.
18:23:51 <lambdabot>   Not in scope: `removeDirectory'
18:23:54 <sbahra> @fact logic
18:23:54 <lambdabot> logic: "⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳ ⟦⟧"
18:24:10 <porges> we need that compartmentalization of the IO monad
18:24:16 <porges> I remember a paper on it :P
18:24:52 <sbahra> @fact-delete logic
18:24:52 <lambdabot> Fact deleted.
18:24:54 <sbahra> @fact symbols
18:24:54 <lambdabot> symbols: "⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳ ⟦⟧"
18:24:57 <sbahra> There we go.
18:24:58 <thoughtpolice> "data types a la carte"
18:26:17 <porges> I was trying to figure out a good unicode symbol for >> and >>= and could only come up with ⤚ and ⤜, respectively
18:26:27 <Gracenotes> hm. Maybe I can avoid the need for de Bruijn indices if I find the names of all the free variables in an expression before substituting inside a lambda abstraction
18:26:54 <Gracenotes> and then renaming the arguments to the abstraction, if necessary
18:27:59 <Gracenotes> I'm pretty sure that'll work... I'll see if it's a problem, anyway
18:28:15 <Gracenotes> I have a freeVar function anyway
18:29:17 <Saizan> well, not only free ones
18:30:13 <Gracenotes> hm... which other ones? I wouldn't want to substitute variables that are already bound
18:30:25 <NNNNooooOOOO> check this http://ihatekaty.com/?id=415110#6dzz5z54fsdq7ez78z8d
18:30:56 <Gracenotes> he's just trying to get pageviews for his stupid "get page views and unlock pictures" site
18:31:41 <Gracenotes> anyway, in (\x. (\a b c. x)) t, I should be fine substituting x->t so long as t doesn't contain a free instance of a, b, or c
18:32:09 <Axman6> @ops
18:32:10 <lambdabot> Maybe you meant: docs oeis pl
18:32:17 <Axman6> bah
18:32:24 <idnar> he left anyway
18:32:31 <idnar> I think @where ops is what you wanted
18:32:35 <Axman6> still, worth banning
18:32:41 <idnar> @where ops
18:32:41 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
18:32:46 <idnar> there you go :P
18:32:47 <Gracenotes> -.-
18:33:01 <Gracenotes> anyways, I have a feeling the whole thing is just a scheme to get ad money
18:33:08 <rwbarton> @. seen where ops
18:33:08 <lambdabot> shapr is in #haskell, #haskell-blah and #unicycling. I last heard shapr speak 3h 33m 9s ago.
18:33:13 <Gracenotes> so NNNNooooOOOO is probably from the site
18:33:37 <dolio> In (\x. \y. \z. x y z) y you have to make sure you don't rename y to z, as well.
18:33:52 --- mode: ChanServ set +o allbery_b
18:33:57 <islon_s> its possible to make a "(Int, Int) -> Int" function that returns a random Int??
18:33:58 --- mode: ChanServ set +o shapr
18:34:00 <dolio> Or if you do, you have to rename z.
18:34:50 --- mode: allbery_b set +b *!*@95.66.74.232
18:34:52 <shapr> I'm at work.. someone else ban?
18:34:57 <shapr> thanks allbery_b!
18:35:13 --- mode: allbery_b set -o allbery_b
18:35:15 <allbery_b> no problem
18:35:15 <sbahra> haha, well his website is amusing. :-P
18:35:16 <idnar> Gracenotes: yeah, it's an advertising pyramid scheme
18:35:19 <Axman6> cheers shapr
18:35:21 <Gracenotes> dolio: ah, good point
18:35:27 <Axman6> uh, allbery_b even
18:35:37 <Axman6> just saw the @ and assumed :)
18:35:39 <idnar> using images stolen from some site I don't recognise
18:35:57 <Gracenotes> while claiming to use a personal story
18:36:11 <allbery_b> shapr and I both popped in and opped at about the same time
18:36:22 <sbahra> Interesting advertising scheme.
18:36:25 <allbery_b> have to pay close attention around #haskell :)
18:37:50 <idnar> sbahra: it's stolen from a certain genre of web games
18:38:05 <idnar> sbahra: which are also based around getting people to "click" on "your link"
18:38:41 <idnar> sbahra: for example, you might be a vampire; every time someone hits your link, they get told you just drained their blood, and get an offer to play the game; meanwhile you rack up points from your victims, becoming a master vampire, or something
18:39:03 <sbahra> Yes, I've seen that on Facebook.
18:39:09 <idnar> (so, basically, nothing new on the internet)
18:39:12 <sbahra> I ended up just blocking the application.
18:39:27 <idnar> heh, I haven't run into one on Facebook, but it doesn't surprise me
18:40:14 <Gracenotes> facebook? What facebook? :P
18:40:32 <Gracenotes> (yeah, not very active there...)
18:40:49 <idnar> heh
18:41:12 <idnar> Gracenotes:
18:41:14 <idnar> http://www.explosm.net/comics/1137/
18:41:53 <Gracenotes> eesh :>
18:43:20 <Gracenotes> earlier ihatexxx sites had the multiple-clicks-to-see-one-image property... I suppose that the katy version has optimized the algorithm to one-click-to-see-one-image
18:43:30 <dolio> Gracenotes: But that gives you the algorithm for proper substitution. To do the substitution (\y -> e')[x->e], you see if y is in the free variables of e, and if so, you generate a fresh name z not in the free variables of e, and perform the substitution (\z -> e'[y->z])[x->e].
18:43:31 <Gracenotes> AB testing, perhaps? ;)
18:43:55 <dpratt71> what's the site where you post Haskell code snippets?
18:44:01 <dolio> And if y is not in the free variables, the it's just (\y -> e'[x->e]), of course.
18:44:04 <SamB> @hpaste2
18:44:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:44:11 <SamB> no ...
18:44:14 <SamB> @where hpaste2
18:44:14 <lambdabot> http://moonpatio.com:8080/
18:44:22 <rwbarton> autocorrect--
18:44:29 <dpratt71> SamB: Service Temporarily Unavailable
18:44:43 <SamB> dpratt71: which ?
18:44:58 <dpratt71> SamB: moonpatio works, thanks
18:45:06 <Gracenotes> dolio: yep. I'm doing something along those lines -- to automate the "reduce one redex at a time" process
18:45:19 <Gracenotes> reduce at will
18:45:26 <SamB> I didn't know hpaste1 was down -- I just thought hpaste2 was better ;-)
18:45:52 <smitty1e> Thanks, #haskell: I kicked butt and took names on my first test of my wimpy physics library!
18:51:26 <gwern> has anyone made use of the mediawiki library? it's not well documented
18:54:04 <l3ns> hi guys and girls
18:54:22 <gwern> not even a blog post with an example or two :(
18:55:10 <l3ns> I am planning to work on a project and my friend told me best way is do it in Haskell.
18:55:28 <gwern> what a tasteful friend
18:55:31 <l3ns> so I am here now, a complete beginner.
18:55:41 <Gracenotes> gwern: parts of the MediaWiki library are good for (1) running and (2) interacting with other parts of the MediaWiki library. Not sure what else, though.
18:55:50 <ozy`> l3ns: you writing a compiler? :p
18:55:57 <gwern> Gracenotes: you've looked at it too?
18:56:08 <ozy`> l3ns: (ie. what's the project?)
18:56:25 <Gracenotes> gwern: I've followed the threads to see how various processes work
18:56:43 <l3ns> this involves Networking and FFI in Haskell
18:57:02 <gwern> Gracenotes: my first app was going to spit out all the xmonad.hss in http://haskell.org/haskellwiki/Xmonad/Config_archive
18:57:13 <islon_s> can i make a ++ span multiple lines?
18:57:17 <gwern> but this is a big library to which I have no skeleton key
18:57:19 <gwern> islon_s: sure
18:57:25 <gwern> just indent it right
18:57:31 <islon_s> how?
18:57:33 <ozy`> islon_s: indent the next line and you're all set
18:57:45 <l3ns> basically, I have a code in C that interfaces with a stepper motor. Now I want it to be a little bit complex.
18:57:53 <Gracenotes> gwern: you're generating MediaWiki markup?
18:58:10 <l3ns> I plan to control a stepper motor from a second computer.
18:58:23 <gwern> Gracenotes: no, I just want to get a bunch of xmonad.hss without downloading them manually
18:58:43 <ozy`> islon_s: if one line starts a declaration and the next line is indented the same amount, the parser inserts a semicolon between them. otherwise, the newline is treated as whitespace
18:59:10 <ozy`> ("starts a declaration" is kind of specific... it's actually more general but I had to say -something-)
18:59:12 <l3ns> Hence, I need networking..to send the data inputted by the user from pc A to pc B
18:59:34 <Gracenotes> gwern: ah. Well, there is http://en.wikipedia.org/w/api.php, which it doesn't seem haskellwiki has bared
18:59:38 <gwern> and this example doesn't help - he throws in a login but it isn't actually needed? way to confuse me for a while siggy. I'm not a genius hacker like you!
18:59:38 <Gracenotes> ...if you mean that?
18:59:43 <gwern> Gracenotes: wait, it hasn't?
18:59:48 <blenket> someone want to write a browser in haskell?
19:00:06 <lispy> blenket: I don't :)
19:00:07 <gwern> iirc, someone did in the late '90s
19:00:45 <Gracenotes> interfacing Flash with Haskell... yum
19:01:00 <ozy`> l3ns: networking code is generally straightforward.... but you're a total newbie, no? have you ever used a functional language?
19:01:06 <lispy> aren't browsers hard to write because you have to figure out how to support all the stuff that appears on the web in practice?
19:01:19 <gwern> one could spend multiple lifetimes writing a browser. it's best to leave that to existing projects
19:01:27 <l3ns> ozy`: this is my first time with functional programming.
19:01:45 <gwern> Gracenotes: you seem to be right. :( no api.php on haskell.org
19:01:50 <Gracenotes> indeed, multiple man-lifetimes have been spent writing a browser
19:02:04 <islon_s> $ is the mos usefull function ever
19:02:05 <lunabot>  luna: Not in scope: `is'
19:02:07 <gwern> ok... so tonight's task is now learning tagsoup, not mediawiki :)
19:02:08 <islon_s> *most
19:02:09 <blenket> them be monstas
19:02:47 <l3ns> ozy`: I am on imperative programming side
19:03:17 <Gracenotes> gwern: ..or you could substitute them all on one page and preview it
19:03:35 <ozy`> l3ns: you're gonna have a blast >_>
19:03:42 <Gracenotes> assuming haskellwiki has templates
19:03:57 <gwern> Gracenotes: it does, but that'd still require me to update the subst page
19:04:13 <Gracenotes> which subst page?
19:04:19 <l3ns> ozy`: I have 1 month to learn it all, at least the Networking and FFI side of Haskell. I need more time?
19:05:03 <gwern> Gracenotes: you're suggesting creating a page full of subst templates, each of which names one of the pages listed in http://haskell.org/haskellwiki/Xmonad/Config_archive
19:05:19 <gwern> Gracenotes: every time someone adds a new config link to that page, I'd have to add a new subst template
19:05:55 <gwern> if I write a script which visits every config linked from that page, then I simply heedlessy run the script every time I want to investigate the general properties of xmonad.hses
19:05:58 <Gracenotes> or transcluded templates, perhaps with some marker between each, and then copy-and-pasting the preview into a file, and then parsing that
19:06:09 <ozy`> l3ns: it took me more time than that to be able to modify a program and feel like I knew what I was doing... and I'd already learned three other functional langs
19:06:11 <Gracenotes> ah. So it's not one-time.
19:06:21 <ozy`> l3ns: your mileage may vary, however
19:06:24 <gwern> Gracenotes: ideally, this will be multiple-times multiple-users
19:06:35 <gwern> every xmonad dev with some spare time :)
19:06:57 <l3ns> ozy`: hmmm.
19:07:10 <Gracenotes> gwern: well, if it helps, http://haskell.org/haskellwiki/?title=Xmonad/Config_archive/Wfarr's_xmonad.hs&action=raw is a text file with the page source
19:07:36 <ozy`> l3ns: I suggest you start here... http://book.realworldhaskell.org/read/
19:08:27 <gwern> Gracenotes: that does help a little
19:08:47 <ozy`> l3ns: and take a look at this for some examples of networking code (if nothing else): http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
19:08:51 <Gracenotes> gwern: also, if you had the API, you could batch-get the sources of every page linked to on Xmonad/Config_archive
19:09:22 <Gracenotes> where the MediaWiki engine concatenates the sources into an XML/JSON/YAML file, and sends them to you
19:09:29 <gwern> Gracenotes: so far my plan looks like this: download the config archive page as html. filter for all http links. then filter out everything that doesn't include 'xmonad.hs'. then I'll take the resulting urls, append your '&action=raw' to them, and batch download them
19:09:49 <l3ns> ozy`: Thank you very much, ozy`. I really appreciate it. :)
19:09:59 <Gracenotes> that'll work
19:10:30 <gwern> to get fancier, I'll probably throw in a 'takeWhile (isPrefix "</haskell>" . dropWhile (isPrefix "<haskell>") . lines'
19:10:49 <gwern> so I get only the contents between <haskell></haskell> brackets, in general
19:11:09 <Gracenotes> gwern: hopefully there's only one <haskell> bracket on the page, then
19:11:44 <gwern> Gracenotes: well, any further bracketpairs will be dropped if I understand my code correctly
19:12:11 <gwern> but AFAIK all the config pages always go <haskell>xmonad.hs</haskell> [<haskell>some other stuff</haskell>]
19:12:11 <SamB> gwern: shouldn't there be a not in there ?
19:12:11 <Gracenotes> I believe so
19:12:26 <gwern> SamB: in the takeWhile? hm, probably so
19:12:42 <islon_s> lambdabot was made in haskell?
19:12:45 <Gracenotes> so... you could wget http://haskell.org/haskellwiki/Xmonad/Config_archive, use sed to extract the appropriate links and then modify them, then batch download again with wget
19:12:48 <gwern> this is pseudocode, I reserve the right to make errors :) even if my pseudocode is haskell and thus executable
19:13:02 <ozy`> l3ns: standard advice for newbies :p you should also read this, if the syntax confuses you... http://www.haskell.org/haskellwiki/Common_Misunderstandings
19:13:06 * gwern wards off Gracenotes. say not those names!
19:13:16 <gwern> islon_s: yes.
19:13:30 <Gracenotes> shell scripts are somewhat functional. Piping very much so
19:13:30 <gwern> > filter (> 1) [1..10] -- look! haskell!
19:13:31 <lambdabot>   [2,3,4,5,6,7,8,9,10]
19:13:59 <islon_s> cool
19:14:05 <gwern> Gracenotes: that's true. there's even a page floating around showing that shell pipelines are monads
19:14:19 <Gracenotes> in fact, I'd bet I could write it as a one-liner ;) and then use an interact-based Haskell program to filter out the <haskell>s!
19:14:20 <stepcut> is it just me, or is the Haskell example on this page missing the 'factory' part? http://en.wikipedia.org/wiki/Factory_method_pattern
19:14:30 <Gracenotes> (or another sed)
19:14:47 <l3ns> ozy`: I will look into that as well :)
19:15:16 <gwern> Gracenotes: I wrote a bot which downloads wikipedia and archives external links with webcite in haskell once. I think it was about 3 lines of code, excluding typesigs and formatting
19:15:28 <l3ns> http://learnyouahaskell.com/ is good for beginners like me.
19:15:28 <Gracenotes> I've seen it
19:15:42 <gwern> (darn. my lies have been exposed! oh wait)
19:15:47 <Gracenotes> I've referenced it a few times regarding monads, actually :)
19:15:50 <islon_s> very good: http://www.qwantz.com/archive/001394.html
19:16:15 <gwern> Gracenotes: oh really? I think I also wrote a tutorial on how I developed it
19:16:35 <Gracenotes> gwern: I've even ran it :) <albeit not actually sending the archive request, merely printing each of the results>
19:16:49 * gwern feels awfully flattered now
19:17:04 <roconnor> is function application montone in both parameters?
19:17:06 <roconnor> as in
19:17:27 <roconnor> if f0 <= f1 and x0 <= x1, then f0 x0 <= f1 x1
19:18:03 <gwern> Gracenotes: did you see my redirect bot? I thought the permutations part was pretty cool
19:18:54 <lispy> roconnor: what is <= here?  It seems that the <= for f0 and f1 is probably a different comparison than the <= for x0 and x1
19:19:00 <gwern> ah, my bad. looks like my archive-bot is more like 4 lines of code once you remove some do expressions and where clauses and type sigs
19:19:12 <Gracenotes> I skimmed the source, but didn't really read it
19:19:17 <roconnor> lispy: comparison in it's DCPO
19:19:25 <lispy> roconnor: DCPO?
19:19:50 <roconnor> um Directed Continuous Partial Order?
19:19:55 <roconnor> if I'm not mistaken
19:20:08 <lispy> never heard of it
19:20:09 <Cale> directed complete
19:20:12 <roconnor> the denotation semantics of haskel
19:20:19 <roconnor> ahcomplete
19:20:23 <noZone> Is anyone working on "Supero"-like optimization for GHC?
19:20:30 <Cale> Yes, I believe that is true, btw.
19:22:01 <ksf> risking to insult someone present, I have to say that cabal is a PITA
19:22:21 <gwern> oh cool, I can even reuse some of my archive-bot code for this script
19:22:23 <gwern> nice
19:22:49 <pejo> nozone, on and off.
19:23:19 * ksf wants a simple, clean and user-friendly thing like omake, just of course moar purr.
19:23:47 <roconnor> lispy: you should learn about DCPOs for Haskell.  It is somewhat useful to be aware of.
19:24:15 <roconnor> they are not as scary as they sound
19:24:25 <rwbarton> f x0 <= f x1 by the monotonicity requirement for functions, and f0 x <= f1 x by definition of <= on functions
19:24:28 <roconnor> I typically ignore the D and C part.
19:24:40 <roconnor> rwbarton: that's what I figured
19:24:40 <pejo> nozone, why?
19:26:34 <lispy> roconnor: where did you learn abou tit?
19:28:08 <ksf> can I run a program and get its stdout as IO String, without coding it up myself?
19:28:51 <rwbarton> ksf: readProcess
19:29:24 <shapr> @users
19:29:24 <lambdabot> Maximum users seen in #haskell: 646, currently: 578 (89.5%), active: 21 (3.6%)
19:29:34 <gwern> one of the nice things about tagsoup is that it doesn't do anything fancy with types, so it's very easy to just run in ghci 'liftM process $ openUrl targeturl' and just see whether process is grabbing the right stuff
19:30:20 <ksf> thx
19:32:44 <gwern> @pl (λx →  "http://haskell.org/" ++ x ++ "&action=raw")
19:32:44 <lambdabot> (line 1, column 3):
19:32:44 <lambdabot> unexpected "\187"
19:32:44 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
19:32:50 <gwern> @pl (\x →  "http://haskell.org/" ++ x ++ "&action=raw")
19:32:50 <lambdabot> (line 1, column 6):
19:32:50 <lambdabot> unexpected "\134"
19:32:50 <lambdabot> expecting pattern or "->"
19:32:54 <gwern> @pl (/x →  "http://haskell.org/" ++ x ++ "&action=raw")
19:32:55 <lambdabot> (line 1, column 2):
19:32:55 <lambdabot> unexpected "/"
19:32:55 <lambdabot> expecting lambda abstraction or expression
19:33:05 <gwern> @pl (\x ->  "http://haskell.org/" ++ x ++ "&action=raw")
19:33:05 <lambdabot> ("http://haskell.org/" ++) . (++ "&action=raw")
19:33:11 <gwern> bleh
19:34:06 <Gracenotes> oh, that's not quite bad
19:34:34 <Gracenotes> so long as it's not more than O(length of other stuff + length of x)
19:34:44 <dublpaws> python has a module called inspect that allows for deep introspection.  I was wondering there was such in for haskell. ideally something like import SomeModule  (dataIn SomeModule) -> StructA {someAccessor::someType, yatta} ... (functionsIn SomeModule) -> [func1 (TypeA -> TypeB)..]   a basic outline of the code
19:35:17 <Gracenotes> seems that it's O(length of prefix + length of x)
19:35:50 <Axman6> > length "http://haskell.org/"
19:35:51 <lambdabot>   19
19:36:04 <Axman6> O(length x + 19) :P
19:37:55 <pejo> dublpaws, you can get a lot of info from the .hi-files. Not sure if reading them is possible through the GHC-api.
19:38:21 <dublpaws> okay pejo I'll check there, thanks.
19:38:31 <rwbarton> dublpaws: you can also get (probably a smaller amount of) info from template haskell and in particular reify
19:42:42 <dublpaws> wow some info on reify -> "The representations are encoded in the Haskell type Graph," that's one end of it. in particular it will be very nice to see how haskell programs fit together on a directed graph
19:43:00 <noZone> pejo: Cause it would be nice to have better performance out of GHC. Not that I'm complaining, much. ;)
19:43:03 <pejo> dublpaws, what is it you're trying to do?
19:43:21 <dublpaws> visualize haskell programs
19:45:04 <pejo> noZone, ok, just don't hold your breath - there were some performance problems according to the paper on Supero
19:45:31 <pejo> dublpaws, may I ask why you don't use the source as starting point instead?
19:46:05 <noZone> Some of us nutters like to see blood squeezed from turnips....
19:46:12 <haedent> so I'm looking at the HDBC example in RWH: in ghci, toSql 0 works fine, but in a compiled file I get an "Ambiguous type variable"  and resolved it by writing iToSql 0
19:46:30 <dublpaws> I'm still learnin the language and was going to use this as project to learn more.
19:46:32 <haedent> why would ghci behave differently?
19:47:02 <dublpaws> (and parsec is still a little hairy for me)
19:47:38 <rwbarton> dublpaws: Not that "reify", the one in template haskell
19:48:14 <rwbarton> dublpaws: If you have the source of a haskell module, you can use haskell-src-exts to parse it
19:48:20 <pejo> dublpaws, haskell-src-exts and the ghc-api can parse stuff for you though.
19:49:14 <jeffz`> I'm trying to build the Win32 package with 6.10.1, but it says System\Win32\SimpleMAPI.hsc:16:56: Module `Control.Exception' does not export `onException', but as far as I can see it's exported, any ideas?
19:49:19 <pejo> noZone, still, it's a fairly complex transformation, so getting it bugfree will take some time. :-)
19:49:20 <dublpaws> okay. I'll definately take a look at that rwbarton. template haskell sounds terribly attractive.
19:49:36 <dublpaws> lots of goodies, thanks guys.
19:49:42 <lispy> sexy even
19:50:04 <noZone> Yeah, I just read more on the subject. Black magics it seems.
19:52:21 <pejo> noZone, well, atleast lots of small things that can go wrong which will result in broken programs.
19:55:43 <gwern> @hoogle zipWith
19:55:43 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:55:43 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
19:55:43 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:56:02 <gwern> @hoogle zipWithM
19:56:02 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
19:56:02 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
19:56:02 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
19:56:21 <pumpkin> what's a mutable array that lives in ST and isn't a MUArr?
19:58:07 <pumpkin> dons: you around?
20:01:08 <pumpkin> oh wow, shapr's opped without needing to kick someone!
20:01:24 <lispy> No, shapr is about to kick me
20:01:25 <lispy> For this
20:01:30 <pumpkin> o.O
20:01:30 <lispy> ?slap shapr
20:01:31 * lambdabot hits shapr with a hammer, so they breaks into a thousand pieces
20:01:34 <pumpkin> O.o
20:01:45 <dolio> They breaks?
20:01:57 <dolio> STUArray
20:02:02 <pumpkin> yeah, found it :)
20:02:03 <pumpkin> thanks
20:02:15 <pumpkin> dolio: I'm trying to improve the documentation on uvector
20:02:35 <pumpkin> and also thinking of what else would be handy in the package
20:02:47 --- kick: lispy was kicked by shapr (Kicked by shapr)
20:02:56 <rwbarton> Ooh, I have a question
20:03:35 <gwern> well, lispy certainly was correct
20:03:40 * shapr snickers
20:03:45 <ac> what's a better way to get this series: map (recip . (2**)) [1 .. 10] -- ?
20:03:56 <rwbarton> Why is it called "uvector" when the word "vector" hardly appears at all in the package? :)
20:04:26 <lispy> Okay, I'm really sorry for calling you all a bunch of toads.
20:04:29 <pumpkin> rwbarton: it's magic! each function has an invisible "vector" suffix
20:04:30 <lispy> I'll be nice
20:04:37 <pumpkin> but you can't see it
20:04:38 <rwbarton> ac: would you prefer [ 1/2^n | n <- [1..10] ]?
20:04:42 <pumpkin> (because it's invisible)
20:04:48 <rwbarton> pumpkin: is that because it's unboxed?
20:04:58 <gwern> it's invisible? hm...
20:05:00 <pumpkin> yeah
20:05:04 * gwern senses a lambdabcat coming on!
20:05:08 <pumpkin> it's another awesome thing in haskell
20:05:11 <pumpkin> invisible names
20:05:12 <gwern> 'Invisible vector'
20:05:16 <pumpkin> lol
20:05:24 <bhurt> I
20:05:25 <pumpkin> rwbarton: but really, beats me :)
20:05:49 <SamB> I didn't think Haskell identifiers were allowed to include Unicode whitespace ...
20:05:49 <gwern> let's see a vector has a magnitude and direction, so it'll be a cat dancing for joy in mid air, but with no visible arms!
20:05:53 <pumpkin> is it uncommon to have many of the typical list operations on mutable arrays? I don't see many mutable map/fold/etc. functions
20:05:54 <shapr> lispy: If you ask for trouble ;-)
20:06:16 <pumpkin> all you have on a MUArr is write and read
20:06:18 <pumpkin> and update
20:06:22 <ac> is there a function like iterate that produces a list where the first element is the argument passed, the second is 1 iteration, the third element 2 iterations, etc
20:06:48 <pumpkin> that is iterate isn't it?
20:06:55 <pumpkin> > iterate (+1) 0
20:06:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
20:07:03 <ac> oh duh
20:07:06 <pumpkin> :)
20:07:21 <ac> > take 10 $ iterate (*0.5) 1
20:07:23 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
20:07:42 <bhurt> I've got a style question- how bad is it, if, in a do statement, I do code like: var <- return $ some_expr; ... instead of let var = some_expr in ... ?  Other than the obvious performance hit.
20:08:02 <ksf> I could have written 10 ffi bindings in the time it took me to set up cabal. And that doesn't even include hooking up custom preprocessors, just compiling what I already had.
20:08:03 <pumpkin> is there any good reason to not have a mapMU (other than someone confusing it with mapM on UArrs) for example?
20:08:14 <rwbarton> It seems like everyone is trying to do that (var <- return ...) recently...
20:08:25 <ksf> ...which a 10-line makefile written in 5 minutes happily did.
20:08:33 <islon_s> how i get the nth element of  list?
20:08:39 <pumpkin> rwbarton: why would people?
20:08:49 <bhurt> islon_s : use the !! operator
20:09:01 <rwbarton> pumpkin: I don't know, but there was a recent haskell-cafe thread where it caused problems
20:09:04 <pumpkin> islon_s: if you need it a lot, consider not using a list
20:09:22 <rwbarton> and I saw it in an hpaste here the other day
20:09:23 <islon_s> pumpkin: i dont and its a 20 elements list
20:09:52 <pumpkin> rwbarton: weird
20:09:56 <bhurt> pumpkin: Well, it avoid some indentation.  I have some code where I'm annoyingly mixing purely functional definitions and monadic effects, and the indentation level was getting to be a problem.
20:09:56 <rwbarton> bhurt: in case you can't tell, I prefer to write "let var = some_expr" in general :)
20:10:07 <rwbarton> bhurt: you can just write "let var = some_expr" on a line by itself
20:10:11 <ozy`> :t (!!)
20:10:13 <lambdabot> forall a. [a] -> Int -> a
20:10:28 <rwbarton> bhurt: and it will scope over the rest of the do-block
20:10:32 <bhurt> I don't need the "in"?
20:10:36 <pumpkin> nope
20:10:43 <rwbarton> do { let x = a; y... } --> let x = a in do { y... }
20:10:58 <bhurt> OK.  My Ocaml habits bite me in the ass.
20:11:31 <bhurt> Thanks everyone.
20:12:03 <bhurt> (back to coding)
20:12:12 <rwbarton> I guess the answer to my question is probably that too many monad tutorials don't talk about the let "command".
20:12:56 <pumpkin> anyone have any ideas on whether it's a conscious choice to omit typical higher-order functions on mutable arrays, or if people just don't get around to it?
20:13:34 <Axman6> pumpkin: sounds like mapMU would be damn useful indeed
20:13:59 <pumpkin> Axman6: in the (mapM)U sense or the map(MU) sense?
20:14:00 <Axman6> if for no better reason than to scrap some boilerplate
20:14:20 <Axman6> probably mapM...
20:15:20 <rwbarton> Hmm, sigfpe's explanation of the "let" in do-syntax is technically wrong.
20:15:31 <pumpkin> sigfpe? wrong?
20:15:33 <pumpkin> surely not
20:15:39 <Axman6> unbeliever!
20:16:01 <BMeph> rwbarton: Wrong how? :)
20:16:52 <rwbarton> He says do { let x = a; y... } desugars to (\x -> do { y... }) a
20:17:19 <rwbarton> which is false in Haskell 98, the variable x in the first can have a polymorphic type but the variable x in the second cannot
20:18:02 <rwbarton> > do { let x = 35 ; [(x :: Int, x :: Double)] }
20:18:03 <lambdabot>   <no location info>: parse error on input `}'
20:18:08 <ksf> argh. I've got a serious problem concerning cabal install.
20:18:08 <rwbarton> > do let x = 35 ; [(x :: Int, x :: Double)]
20:18:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:18:23 <pumpkin> ksf: what's wrong?
20:18:47 <ksf> Executable sections can't depend on a library in the same package.
20:18:55 <ksf> ...on the package they're in, that is.
20:19:09 <SamB> ksf: yeah, that does suck
20:19:11 <rwbarton> > do let { f x = x + 1 } ; [ (f (3 :: Int), f (3 :: Double)) ]
20:19:13 <lambdabot>   [(4,4.0)]
20:19:19 <noZone> unbeliever = do putStrLn "I'm the dirty heretic, so what's it to yah?!?"
20:19:24 <SamB> in practice it means the SAME modules are often built AGAIN
20:22:01 <ksf> also, I'd like to say that any program linked to a lib _must_ be compiled with -threaded.
20:22:40 <ksf> There's also a LD_LIBRARY_PATH issue that the system could take care of, not sure if it should, though.
20:22:56 <islon_s> randomRIO is exclusive in the second parameter?
20:23:05 <noZone> I love the smell of pegged CPUs in the morning.
20:23:35 <ksf> and, btw, when will there be "cabal uninstall"?
20:23:36 <BMeph> noZone: ...does it smell like victory? :)
20:23:59 <chipdude> good evening
20:24:19 <noZone> It smells like Haskell grinding out another pretty mandelbrot wallpaper.
20:24:40 <Axman6> noZone: oo, nice. what're you using for it?
20:25:18 <gwern> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=883#a883 <-- does anyone see any reason that this would not produce any files when run? it otherwise seems to work fine
20:25:32 <chipdude> I think I've grasped the Monad Nature.  However, one thing still puzzles me: What is the mechanism by which the various functions chained with >>= are forced to be evaluated, fully, in order?  Given   f1 >> f2, which means f1 >>= (\_ -> f2), the value of f1 is never used.
20:25:40 <BMeph> noZone; I prefer my mandelbrot freshly squeezed. :)
20:25:52 <chipdude> So why in   do { putStrLn "a"; putStrLen "b"; }    does "a" get printed?
20:25:53 <noZone> Some poorly optimized code I found on some web page, then I modified it so I could play with the colors, zoom and all.
20:26:08 <Axman6> nice
20:26:22 <noZone> Haskell is fun to play with.
20:26:26 <chipdude> I beg elucidation
20:26:53 <pumpkin> gwern: does it need liftM?
20:27:05 <rwbarton> :t liftM (writeFile ?x) ?y
20:27:06 <lambdabot> forall (m :: * -> *). (Monad m, ?y::m String, ?x::FilePath) => m (IO ())
20:27:11 <pumpkin> seems like an IO IO
20:27:15 <rwbarton> yeah
20:27:22 <rwbarton> should be
20:27:28 <rwbarton> :t writeFile ?x =<< ?y
20:27:30 <lambdabot> (?y::IO String, ?x::FilePath) => IO ()
20:27:39 <gwern> pumpkin: it compiles and runs, so apparently not?
20:27:50 <pumpkin> gwern: well, it doesn't mind doing an IO( IO ())
20:27:51 <noZone> Now if I get my dual core CPU installed it'll be time fore some parallel Haskell Mandelbrotting.
20:27:56 <pumpkin> but it won't do anything tangible
20:28:05 <gwern> wut
20:28:21 <rwbarton> @type zipWithM
20:28:23 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
20:28:45 <chipdude> that's a pretty type
20:28:51 <rwbarton> "m c" there is "IO (IO ())"
20:29:01 <gwern> why is that a bad thing?
20:29:07 <pumpkin> you need to "run" it twice
20:29:13 <rwbarton> because the effect you want is in the inner IO
20:29:27 <chipdude> nobody here familiar with (Monad IO) >>= ?
20:29:29 <rwbarton> I guess, since it's not producing any files :)
20:29:40 <pumpkin> chipdude: ?
20:29:44 <mmmdonuts> chipdude, I think "a" gets printed just because the IO monad is special that way, i.e. it's a cheat.
20:30:02 <pumpkin> it's not special
20:30:11 <islon_s> main :: Cheat ()
20:30:11 <pumpkin> but yeah, it does get printed
20:30:23 <gwern> so... would 'return $ zipWith (\x y -> liftM (writeFile x) y) (map show [(1::Int)..]) hs' be better?
20:30:24 <rwbarton> chipdude: m >>= f in the IO monad means, by definition, "perform the action m, producing a result a, and then pass that to f and run the resulting action"
20:30:33 <rwbarton> gwern: worse :)
20:30:36 <pumpkin> gwern: another IO!
20:30:38 <rwbarton> gwern: you'd want join, not return
20:30:41 <gwern> ack!
20:30:50 <rwbarton> gwern: but really you want writeFile x =<< y and not liftM (writeFile x) y
20:31:14 <pumpkin> :t (>>=)
20:31:15 <chipdude> rwbarton: "perform an action" is something I've seen referred to but not defined
20:31:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:31:34 <rwbarton> chipdude: in particular, the semantics of the IO monad is such that all the effects of m occur before all the effects of f, regardless of how f uses the result of m
20:31:57 <pumpkin> chipdude: so all that code is saying is that the effect of putStrLn "a" must happen before the effect of putStrLn "b"
20:32:10 <rwbarton> chipdude: You can think of it as what the Haskell run-time system does with your main function
20:32:13 <chipdude> rwbarton: does the IO monad have to escape the language to do this?  or is it a simple matter of using the forced-evaluation feature?
20:32:17 <islon_s> it uses seq to do so?
20:32:20 <gwern> rwbarton: that does seem to work
20:32:23 <rwbarton> seq is irrelevant
20:32:25 <ksf> :src System.IO.(>>=)
20:32:38 <ksf> @src System.IO.(>>=)
20:32:39 <lambdabot> Source not found. stty: unknown mode: doofus
20:32:52 <rwbarton> chipdude: One way to think about IO is that (>>=) is just a data constructor.
20:33:03 <pumpkin> or a burrito
20:33:20 <chipdude> rwbarton: you've stated your conclusion: "The IO monad does x"  I'm trying to find out _how_ it does it.
20:33:22 <ksf> chipdude, the value of f1 is used, just not the stuff it returns.
20:33:30 <chipdude> To distinguish it from, e.g. the [] monad
20:33:43 <porges> chipdude: you can't really write it in plain haskell
20:33:49 <porges> it requires support from the compiler
20:33:52 <chipdude> oh, that's sad
20:34:19 <rwbarton> Well, you can't write putchar() in C either.
20:34:23 <ksf> if f1 is IO String, the IO monad _will_ exectute that IO String and pass a String to ignorance... but the action is executed before its result cat be ignored.
20:34:34 <chipdude> not so, rwbarton
20:34:58 <chipdude> rwbarton: however, it is true that you can't write printf() in K&R C
20:35:19 <pumpkin> you can't write any IO functions in pure c because there's no syscall mechanism
20:35:27 <ksf> ...and whether or not you can write putc in C depends on the os.
20:35:28 <pumpkin> other than calling the standard lib's syscall function
20:35:29 <chipdude> oh, is that what you meant.
20:35:34 <islon_s> the FFI of C is the SO
20:35:43 <gwern> @pl (\x ->  (show x) ++ ".hs")
20:35:44 <lambdabot> (++ ".hs") . show
20:36:28 <nolrai_East> Ok if I want errors that I can then recover from and go back to where the error happened I want something like "ContT (ExceptionT err) a" right?
20:36:45 <ksf> chipdude, you shouldn't try to understand monads with IO as an example, anyway, it's a special case belonging to the awkward squad.
20:36:47 <rwbarton> chipdude: The only thing in haskell that actually does any IO is the run-time system.
20:37:09 <porges> you can look at the implementation here: http://darcs.haskell.org/packages/base/GHC/IOBase.lhs
20:37:17 <rwbarton> chipdude: and the only way to actually perform an action is to have it be the value of the symbol "main".
20:37:34 <chipdude> I'm entirely happy to give away that the implementation of putStrLn is not real Haskell
20:37:54 <chipdude> But I'm quite miffed that the basic concept of laziness and order-of-evaluation has to be cheated just to make printing work
20:37:55 <rwbarton> chipdude: There's a good explanation of this point of view somewhere online, let me see if I can find it
20:38:00 <rwbarton> No, they don't.
20:38:06 <porges> putStrLn is real haskell
20:38:19 <pumpkin> chipdude: it isn't at all
20:38:20 <gwern> ok, so now my script seems to be working
20:38:27 <chipdude> IO.(>>=) has magic behavior different from other (>>=) or so everybody just told me
20:38:31 <rwbarton> Evaluation doesn't ever cause IO actions to be performed.
20:38:35 <pumpkin> chipdude: nope
20:38:44 <chipdude> Then ... what does?
20:38:50 <gwern> hm. it is somewhat embarassing that a bot to download and archive wikipedia urls is 3 or 4 lines, and this is 6
20:38:54 <pumpkin> evaluating the result
20:38:57 <rwbarton> Writing "main = <some IO action>"
20:38:59 <pumpkin> in the runtime
20:39:16 <chipdude> and what forces the printing of "a" in    do { putStrLn "a"; putStrLn "b"; }  ?
20:39:19 <rwbarton> And, you can build complex IO actions out of simpler ones using >>=
20:39:37 <pumpkin> chipdude: the runtime :P
20:39:42 <nolrai_East> a >> b is the action of doing a then doing b.
20:39:48 <pumpkin> chipdude: just like the real entry point of your program isn't main in c :P
20:39:50 <rwbarton> (>>=) is as much a black box as putStrLn.
20:39:53 <pumpkin> sort of
20:40:00 <kapil> one might even go so far as to say "evaluation" is the wrong word for a haskell function. "identity" or "relation" is what a function is really describing.
20:40:21 <porges> (>>=)  (IO m) k = IO ( \ s ->
20:40:22 <porges>   case m s of
20:40:22 <porges>     (# new_s, a #) -> unIO (k a) new_s
20:40:22 <porges>   )
20:40:41 <porges> constructing the IO monad is ordinary haskell
20:41:03 <ksf> chipdude, no, it hasn't.
20:41:03 <chipdude> I don't know (#  #)   otherwise I can read that
20:41:08 <rwbarton> I don't think you can call id *ordinary* haskell :P
20:41:12 <rwbarton> *it
20:41:16 <porges> (# #) is unboxed tuples
20:41:32 <porges> well it's fairly ordinary
20:41:33 <porges> :P
20:41:41 <pumpkin> if ghc-specific
20:42:20 <chipdude> all right, Which of those bits is the one that forces the "a" to actually pop out?
20:42:35 <chipdude> ( porges, thanks for the retrieval )
20:42:42 <nolrai_East> @unmtl ErrorT e Cont s
20:42:42 <lambdabot> err: `Cont (Either e s)' is not applied to enough arguments, giving `/\A. (A -> Either e s) -> Either e s'
20:42:44 <chipdude> ( my download had just finished )
20:42:55 <nolrai_East> ummm
20:43:06 <porges> the stuff you *can't* write is the stuff imported from GHC.Prims
20:43:12 <jeffz`> figured it out... the cabal config had to depend on base >= 3
20:43:40 <rwbarton> You could say that new_s causes a data dependency which requires m to run before k, but this is very compiler-specific and not conceptual
20:44:09 <chipdude> well, that I get, actually
20:44:38 <chipdude> however a comment in IOBase.lhs is interesting: {
20:44:41 <chipdude> There is really only one way to \"perform\" an I\/O action: bind it to
20:44:41 <chipdude> @Main.main@ in your program.  When your program is run, the I\/O will
20:44:41 <chipdude> be performed.  It isn't possible to perform I\/O from an arbitrary
20:44:41 <chipdude> function, unless that function is itself in the 'IO' monad and called
20:44:41 <chipdude> at some point, directly or indirectly, from @Main.main@.
20:44:41 <lambdabot> Unknown command, try @list
20:44:43 <chipdude> }
20:44:53 <rwbarton> Yes, that's what I've said about five times :)
20:45:14 <nolrai_East> What does callCC do? how does one use the cont monad?
20:45:17 <rwbarton> Well, at least once :)
20:45:43 <chipdude> rwbarton: you've been telling the truth, but you haven't been answreing the question I was asking ... you told me what to do, not what's happening.  Or else I did not understand you.
20:46:18 <porges> yeah, like the comment says
20:46:23 <porges> the runtime runs "main"
20:46:48 <rwbarton> The lack of relationship between laziness and order-of-evaluation and sequencing in IO is a conceptual issue, not an implementation-specific one, I think.
20:47:53 <porges> chipdude: the real magic is the RealWorld type :)
20:48:06 <chipdude> there is also the semantic spillover between Monads in general and IO, the most famous Monad, in particular.   "Being a Monad" does not at all imply "being like IO", or so I seem to be learning
20:48:11 <pejo> rwbarton, could you interpret what you just said?
20:48:29 <porges> chipdude: yes, IO is just one application
20:49:05 <kapil> there are the Maybe and List monads after all
20:49:20 <rwbarton> Conceptually IO could be defined (using GADT syntax) like   data IO where Return :: a -> IO a; Bind :: IO a -> (a -> IO b) -> IO b; GetChar :: IO Char; PutChar :: Char -> IO (); ...
20:49:22 <chipdude> It's more like IO is a magical type that does things no other type can do ... and just to be puckish, when the inventors of IO were deciding on its interface, they figured a Monadic interface would be fun
20:49:26 <rwbarton> as a totally normal type.
20:49:53 <ksf> nolrai_East, if you have to ask here, you don't want to use it.
20:50:12 <rwbarton> Somewhere inside the Haskell RTS is some code (written in C let's say!) that takes such a value and actually performs the action
20:50:30 <chipdude> This implies that if I want to force execution of my functions which may be implemented in e.g. C and therefore have side effects, I can't jus tmake up my own Monad instance and go at it.  The magic of IO will not occur, and my functions may go uncalled.
20:50:30 <nolrai_East> ksf: how would you implement errors you can come back from?
20:50:34 <chipdude> This is Irritating.
20:50:57 <rwbarton> If it sees a Bind constructor, it runs the first action, and then passes it to the second function and runs the resulting action
20:51:27 <pejo> nolrai, use Maybe, Either, or some other mechanism
20:51:41 <rwbarton> This doesn't have anything to do with laziness or evaluation, it's just the way the semantics of the IO monad is defined
20:51:48 <chipdude> Um
20:51:59 <ksf> I would'nt fail in the first place.
20:52:03 <porges> chipdude: what you do is write a monad which has some kind of a runMe function which "executes" it in the IO monad
20:52:29 <porges> kind of like the "main" function
20:52:30 <nolrai_East> pejo: I already am the problem is I need to be able come back to the computation from an error, but only sometimes.
20:52:59 <ksf> anyway, usually you want to use delimited continuations instead of full-blown one, as they are nearly as powerful but don't imply as much semantical brainbending.
20:53:06 <chipdude> So, IO is an inconsistent language feature masquerading as a type constructor.
20:53:16 * mriou is wondering why there's a STArray but no STMap in the standard lib
20:53:29 <rwbarton> chipdude: I don't understand where you get this idea from
20:53:36 <pumpkin> mriou: I was just asking that earlier :)
20:53:47 <pumpkin> mriou: no answer though :)
20:53:48 <ksf> nolrai_East, to start off: what kind of error?
20:53:57 <nolrai_East> ksf: where can i lern about "delimited continuations"
20:54:09 <chipdude> rwbarton: I'm just active-listening.  How have I misunderstood you?
20:54:11 <mriou> pumpkin: heh! I guess some things have no explanation :)
20:54:44 <ksf> http://okmij.org/ftp/Computation/Continuations.html#shift-cgi
20:55:06 <ksf> generally, oleg is the guy when it comes to them.
20:55:11 <ksf> there's also a haskell library.
20:55:38 <ksf> http://en.wikipedia.org/wiki/Delimited_continuation
20:55:53 <ksf> http://www.haskell.org/haskellwiki/Library/CC-delcont
20:55:57 <rwbarton> chipdude: IO is certainly special in that the only way to have your program actually do anything is to bind a value of type IO a to the variable main.
20:56:40 <rwbarton> chipdude: but there are no special rules about evaluation pertaining to IO.
20:56:53 <noZone> Ask yourself: Are your monads secure? Unsure? Try these guys: http://monadsecurity.com/
20:57:11 <SamB> hmm, I think Maybe is safe enough anyway
20:57:18 <SamB> Either probably, too
20:57:47 <chipdude> rwbarton: I feel that I am being toyed with.  It has already been acknowledged that the putStrLen "a" problem is solved by magic that lay outside the base language
20:57:58 <pumpkin> o.O
20:57:59 <chipdude> and then you say that there are 'no special rules about evaluation'
20:58:10 <cads> chipdude:  :(
20:58:17 <cads> I have that feeling too
20:58:19 * rwbarton is somewhat puzzled
20:58:27 <pumpkin> chipdude: it isn't really true, but you can think of it as a list of instructions
20:58:28 <cads> I think the magic is gnomes in the compiler that talk to the monads
20:58:32 <pumpkin> for the runtime to perform later
20:58:52 <pumpkin> the list is pure and follows the exact same rules as anyone else, but what is done with it later isn't pure
20:58:59 <Olathe> cads: That's a trade secret.
20:59:04 <chipdude> pumpkin: I have had it up to  ^^here with  "think about it as X".  What IS it?  I tire of allegory
20:59:17 <pumpkin> O.o
20:59:18 <chipdude> pumpkin: and as for "later", that's silly
20:59:37 <cads> Olate: I'm sure I could find a video where SPJ prances around vivaciously and explains it all awesomely
20:59:40 <chipdude> if the first thing the program does is ask for input, and then it processes that input for an hour, the IO hardly happened "later", did it?
20:59:51 <p_l> chipdude: I guess to avoid allegory you'd probably need to play with advanced maths :D
20:59:52 <SamB> chipdude: well, in fact it's deeply wired into most compilers
20:59:52 <pumpkin> chipdude: it's a model of computation
20:59:58 <kapil> there is no "RealWorld" without the arrow of time. mathematical relations are timeless
21:00:05 <Smokey`> chipdude: I learned long ago, not to question 'how' haskell works, while 'in theory' a lot of it has nice logical implementations, there's a lot of magic at it's core that doesn't want to be understood. ;)
21:00:22 <chipdude> Great.  Haskell is the only thought experiment with a compiler
21:00:36 * pumpkin shrugs
21:00:43 <rwbarton> chipdude: Do you also question the "magic" that occurs when you use putchar() in C?
21:00:45 <cads> chipi
21:00:46 <Axman6> chipdude: what do you want to know?
21:00:46 * ksf decides to call it a day and fetches a beer
21:00:48 <Smokey`> chipdude: don't question, just accept. :P
21:00:53 <rwbarton> or is it just that you already know how it works?
21:00:57 <chipdude> rwbarton: I'm a compiler hacker.  I not only question it, I improve it
21:01:04 <cads> chipitude
21:01:07 <cads> err, chipdude
21:01:14 <cads> have you read about monads?
21:01:21 <kapil> the compiler + runtime is RealWorld just as the transistor is the real world for the thought expermiments of quantum mechanics
21:01:49 <pumpkin> be careful, he's had it up to here
21:01:50 <chipdude> cads: Enough to know they don't do the magic about which I ask.  The Either monad tuned on the lightbulb for me
21:01:52 <pumpkin> of any kind of comparison
21:02:08 <chipdude> the [] monad was entertaining as well
21:02:15 <pumpkin> where is Either's monad instance?
21:02:19 <pumpkin> someone was looking for it the other day
21:02:23 <Olathe> cads: Heheh
21:02:25 <Axman6> @src Either Monad
21:02:26 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:02:29 <pumpkin> I could only find its functor instance
21:02:32 <Axman6> @src Either (>>=)
21:02:33 <lambdabot> Left  l >>= _ = Left l
21:02:33 <lambdabot> Right r >>= k = k r
21:02:34 <dolio> It's in Control.Monad.Error.
21:02:38 <dobblego> \e f -> case e of Left x -> Left x; Right x -> Right (f x)
21:02:40 <pumpkin> eww :)
21:02:58 <dobblego> it is a Monad for forall e. Either e
21:03:04 <Axman6> @src Either fmap
21:03:05 <lambdabot> fmap _ (Left x) = Left x
21:03:05 <lambdabot> fmap f (Right y) = Right (f y)
21:03:06 <pumpkin> yeah
21:03:07 <chipdude> actually I was thinking of Maybe and mistyped.  Either's fun, too
21:03:12 * ksf offers kapil a length of rope in case he doesn't want to fly away.
21:03:31 <pumpkin> they're pretty close to one another
21:03:32 <Axman6> hmm, fmap is just flip (>>=) for Either right? or am i missing something?
21:03:33 <pumpkin> anyway, bbiab
21:03:42 <Axman6> oh, no
21:03:47 <dobblego> Axman6, you're missing something
21:03:48 <chipdude> OK.  Wlel, I gather that the goal is not to know.  Which is a valid lifestyle o fcourse.
21:04:24 <cads> chipdude: so you've gotten the explanation how monads piggyback some extra info on top of normal types, still don't know how that info can actually leak out to the real world through mechanisms of the language?
21:04:50 <cads> surely that answer is tractable
21:05:21 <mriou> chipdude: actually making IO a monad sort of makes sense
21:05:22 <rwbarton> chipdude: do you understand how ordinary lazy evaluation works?
21:05:24 <ksf> chipdude, the important thing is that the IO definition of >>= is implemented as any other one, with the small exception that it uses stuff from GHC.Prim that you can't write in haskell because if you could, haskell wouldn't be pure anymore
21:05:40 <chipdude> cads: if I want to have guarantees of execution (not evaluation) for my _own_ functions, I need to know how the IO functions do it.
21:05:51 <rwbarton> chipdude: No. No you don't
21:05:51 <chipdude> ... because apparently they are the only functions that _get_ to do it.
21:05:59 <rwbarton> chipdude: You just need to write actions in the IO monad, is all.
21:06:01 <ksf> you could use those definitions in GHC.Prim to implement your own notion of dealing with the outside world, completely bypassing the IO monad.
21:06:16 <Axman6> ew
21:06:18 <ksf> (which, maybe, you should do, just for the heck of it)
21:06:38 <dolio> You'd have to wrap it in IO for main, though.
21:06:41 <Axman6> chipdude: how much haskell do you know?
21:06:50 <dolio> (To get an initial RealWorld, too.)
21:06:58 <bd_> chipdude: What you need to do to ensure execution is too understand the API contract of IO - not the /implementation/ of it.
21:06:58 <cads> I don't understand what the difference between execution and evaluation are.
21:06:59 <chipdude> Axman6: about 150 pages of Real World Haskell.  Up through the Monad chapter.
21:07:12 <dobblego> chipdude, this might help http://blog.tmorris.net/controlling-effects-with-flatmap/
21:07:20 <Axman6> ah, righto
21:07:22 <bd_> chipdude: Asking about how the IO monad is actually built is like asking what the FILE type in C really is
21:07:26 <ksf> dolio, damn you you are right. or is there a function called "start:"?
21:07:34 <nolrai_East> "main = myFunction >> stuff >> myFunction2 " will always exeicute myFunction. Thats all you need to do.
21:07:36 <bd_> while it may be an instructive exercise, it's not something you usually need to know to use it
21:07:38 <rwbarton> Does anyone know where mauke's or Cale's "IO as GADTs" (possibly without the GADTs) tutorials are?
21:07:44 <porges> bd_: except that you can look at GHC.IOBase.hs and see exactly how it works
21:07:49 <cads> it sounds like chipdude is where I am, where if I was asked to write from scratch the IO monad, I wouldn't have the foggiest idea on what to call to make that happen
21:07:50 <bd_> porges: well, you can in C too
21:07:50 <mmmdonuts> chipdude, if you look at all the low-level things with side effects in haskell, like mutable slots (IORefs and MVars), they all just use the IO monad.  You can do the same thing.
21:07:59 <chipdude> bd_: So I'm gathering
21:08:03 <porges> bd_: but __FILE__ is part of the compiler :P
21:08:07 <Cale> rwbarton: in my head?
21:08:09 <bd_> porges: not __FILE__, FILE :)
21:08:17 <rwbarton> Cale: I thought I read it online somewhere.
21:08:20 <porges> bd_: doh
21:08:22 <cads> mmmdonuts: but he wants to _understand_ the io monad
21:08:22 <chipdude> bd_: However, what *is* the API contract of IO?  Did I miss that in the I/O chapter?
21:08:26 <rwbarton> Cale: But maybe that was in my head too :)
21:08:39 <dolio> ksf: Well, I don't think you're going to get GHC to compile a working Haskell program without defining a "main :: IO a". That's simply how it works.
21:08:56 <cads> chipdude: real world haskell probably won't go through the implementation of the io monad in the IO chapter
21:09:03 <ksf> chipdude, no, you didn't.
21:09:10 <porges> bd_: well, IO is written there, and you can see how it works. The things that IO is built on, however, are not :)
21:09:18 <ksf> the implementation of the IO Monad is compiler-specific, anyway.
21:09:36 <cads> you guys I think he's got a real concern
21:09:36 <ksf> ...as Hugs won't use GHC.Prim.
21:09:41 <rwbarton> cads: If you were asked to write putchar() from scratch in C, would you have the foggiest idea on what to do?
21:09:46 <bd_> chipdude: Well, the API contract of IO consists of the general contract of Monad, plus the IO primitives like putStr
21:09:59 <mmmdonuts> cads, I thought chipdudes wanted to do C FFI stuff with side effects.  There seem to be multiple separate questions in play.
21:10:01 <rwbarton> cads: It's a trick question, because of course you can't.
21:10:08 <cads> rwbarton: touche.
21:10:18 <chipdude> bd_: but if I had my own function that's definitely I/O but isn't in the std, then whwat?  Say, System V IPC
21:10:22 <rwbarton> Right, so this is why I'm confused about what everyone is asking :)
21:10:50 <ksf> you don't get IO's outside the standard.
21:10:53 <bd_> chipdude: Then you'll need to use the foreign function interface. :)
21:10:59 <ksf> they're either built-in or ffi functions.
21:11:01 <bd_> chipdude: or a suitable wrapper library
21:11:20 <bd_> It's a good idea to get a hang of the basics before writing FFI bindings though... :)
21:11:40 <rwbarton> Aha: http://mauke.ath.cx/stuff/haskell/how-to-io.html
21:11:55 <chipdude> The FFI has guaranteed execution order?
21:12:01 <bd_> chipdude: Depends.
21:12:05 <ksf> the IO monad has.
21:12:08 * chipdude sighs, as always
21:12:17 <chipdude> the answer of an expert is "It depends."
21:12:22 <rwbarton> chipdude: Take a look at the first 3 sections of that
21:12:23 <Smokey`> now we're back to his question, 'how' it depends, 'how' it works, etc...
21:12:26 <bd_> chipdude: You can have the FFI produce functions in IO. For example, socket :: Domain -> Type -> Protocol -> IO Socket
21:12:27 <chipdude> rwbarton: looking
21:12:28 <dobblego> chipdude, you're making it harder than it really is - I strongly recommend to take a break and try again later
21:12:35 <porges> might need to do an exposition of the IO implementation and go through every basic function to show how it all links otgether
21:12:35 <iron34> Anyone feel like answering a question about the "Occurs check" ?
21:12:44 <cads> chipdude, rwbarton is a weezard, he seems to know what's up
21:12:46 <ksf> ...it depends on whether or not you import the functions as pure or IO ones.
21:12:48 <porges> iron34: hpaste away :P
21:12:56 <bd_> chipdude: or you can have it produce 'pure' bindings, but this is dangerous if you don't know exactly how it works, precisely because execution order is not guarenteed
21:13:01 <ksf> ...and you can seriously hurt your foot by declaring impure functions pure.
21:13:04 <bd_> nor is execution count
21:13:10 <chipdude> OK
21:13:15 <iron34> sorry I am a noob how do I hpaste ?
21:13:20 <chipdude> rwbarton: I shall read
21:13:34 <Axman6> @where hpaste2
21:13:35 <lambdabot> http://moonpatio.com:8080/
21:13:39 <Axman6> iron34: ^^
21:13:43 <chipdude> thank you all for effort.  I hope at least you learned something about what a newb reads when you write what looks to you like a clear answer.  :-,
21:14:03 <mmorrow> chipdude: foreign import ccall unsafe "malloc" c_malloc :: CSize -> IO (Ptr a)
21:14:36 <cads> I am right there with you, chipdude. I've kind of accepted that feeling of being lost and having to take some things on faith, plus my itinerary for mastering haskell isn't hurried. When i can read the source of the compiler implementation, and the compiler whitepapers, and the haskell report, and understand those, I know my answers will have long been answered.
21:15:18 <BMeph> chipdude: Just curious, but which compilers have you hacked, and what about them do you like to find?
21:15:31 <iron34> I am at the hpaste2 site but how do I upload my code there ?
21:15:47 <mriou> cads: you don't need to understand its implementation to understand an abstraction (unless it leaks)
21:16:08 <Axman6> iron34: copy the code, and paste it into the text box
21:16:22 <mriou> but maybe that's what you call faith :_
21:16:22 <chipdude> BMeph: I've worked with C for a long time - first C compiler I hacked generated z80 code and I retargeted it to the 6809
21:16:32 <chipdude> worked on C++, was one of the core Perl hackers for a long time
21:16:48 <chipdude> s/C++/G++/
21:17:24 <chipdude> I'm quite familiar with magic ... one of the key data structures inside perl is a struct named MAGIC
21:17:39 <chipdude> I think I have only one piece missing now
21:17:46 <mmorrow> which one?
21:17:50 <chipdude> and I may not find it here, but that's OK
21:17:52 <BMeph> chipdude: Right, just trying to gauge your Blub level...
21:17:54 * BMeph ducks
21:17:55 * mmorrow just showed up and has no context
21:18:20 <iron34> ok I did it
21:18:52 <chipdude> What is the machanism by which the runtime "executes" an IO action?   And it's possible that the >>= source code pasted above answered that but I don't know enough Haskell to read it
21:18:54 <BMeph> chipdude: Honestly, you sound as if you're really more interested in how GHC works, and not how Haskell works. You may find better answers to your questions in #ghc, if that's what you're looking for. :)
21:19:01 <chipdude> .
21:19:04 <porges> iron34: then paste a link to the page :)
21:19:08 <chipdude> BMeph: interesting thought, there.
21:19:10 <chipdude> thank you
21:19:35 <iron34> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=884
21:19:36 <BMeph> chipdude: Sure. :)
21:19:54 <pejo> chipdude, (sidenote) large chunks of #ghc is normally on european time, and this time several are attending POPL
21:20:04 <SamB> chipdude: well, it uses the non-existant RealWorld# value as a token to sequence the execution ...
21:20:05 <mmorrow> chipdude: "_how_" the IO monad does it is by the compiler compiling the code _such that_ the IO monad does "it"
21:20:39 * pumpkin is back!!!1!1!
21:20:41 <pumpkin> did you miss me?
21:20:55 <mmorrow> (or rather the IO monad being defined/implemented in terms of primitives which do the things expected of the IO monad)
21:20:55 <Raevel> Y
21:20:59 <ksf> SamB, that's a lie. RealWorld# really contains the real world, folded into it by a dimensional transformation.
21:21:16 <pumpkin> I thought realworld had a single value?
21:21:31 <iron34> so my problem is when I try to define factorial the way I did in my hpaste it gives me an Occurs check
21:21:57 * BMeph didn't miss pumpkin. But then, he's never thought or shooting at the pumpkin before now...
21:22:01 <ksf> nope, it passes the whole of existence around. but since its's pure, you don't notice yourself being interpreted by haskell.
21:22:02 <pumpkin> :(
21:22:23 <SamB> ksf: and how does that get the entire world down to 0 bits ?
21:22:32 <porges> iron34: f f n = ((f f) n), whereas you probably want f (f n)
21:22:39 <ksf> that's the illusion of it.
21:22:40 <erikc> chipdude: http://hackage.haskell.org/trac/ghc/wiki/Commentary is what i used for an initial understanding of how ghc's implementation of haskell works under the hood, its an ok overview
21:22:44 <porges> to apply f twice
21:22:52 <ksf> see, even haskell has to obey thermodynamics.
21:22:55 <pumpkin> , copyMU (newMU 5) 5 (toU [1..5])
21:22:56 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
21:22:56 <chipdude> erikc: ty
21:22:59 <ksf> so it just folds dimensions.
21:23:15 <chipdude> mmorrow: true, if tautological :-)
21:23:16 <pumpkin> ah
21:23:27 <mmorrow> chipdude: heh, but exactly!
21:23:28 <pumpkin> , unsafeFreezeAllMU $ copyMU (newMU 5) 5 (toU [1..5])
21:23:29 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
21:23:31 <mmorrow> :)
21:23:38 <pumpkin> , runST (unsafeFreezeAllMU $ copyMU (newMU 5) 5 (toU [1..5]))
21:23:39 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
21:23:41 <pumpkin> :(
21:23:46 <porges> foldr (>>>+<<<) point world
21:23:47 <iron34> porges : well actually no because fac2 is defined to take a function and an argument n
21:24:09 <pumpkin> , runST (liftM unsafeFreezeAllMU $ copyMU (newMU 5) 5 (toU [1..5]))
21:24:10 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
21:24:15 <pumpkin> alright, I fail
21:24:28 <chipdude> pejo: ty for timing advice
21:24:36 <porges> iron34: but you can't have f f n
21:24:45 <porges> iron34: the types don't work
21:24:55 <porges> f (f n) works
21:25:01 <porges> @let test f n = f f n
21:25:02 <lambdabot>  <local>:7:11:
21:25:03 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -...
21:25:12 <porges> @let test f n = f (f n)
21:25:14 <lambdabot>  Defined.
21:25:29 <Axman6> iron34: do you maybe want n * fac2 f (n-1)?
21:25:31 <dolio> , newU 5 (\a -> copyMU a 5 (toU [1..5]))
21:25:32 <lunabot>  toU [-5.200131131405314e-43,-3.98325491268437e-43,-5.199589506224227e-43,...
21:25:35 <mmorrow> chipdude: any two implementations could implement the IO monad in completely different ways, as long as they have the same behavior from the pov of w/in the language
21:26:59 <dolio> There's really no official, formal operational semantics of the IO monad, either.
21:27:00 <pumpkin> , newU 5 (\x -> permuteMU a (toU [5..10]) (toU [2,1,3,4,5]))
21:27:01 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
21:27:05 <iron34> I am trying to eliminate the direct recursive reference
21:27:14 <porges> iron34: I think the problem is that the first one is applying f to f, and then that to n. This means that f has to have an infinite type, because if f accepts f then is applied to something else you end up with a function that must accept one more argument than it does accept!
21:27:35 <dolio> So they could probably even implement them noticeably differently and argue that their implementation is correct.
21:27:35 <pumpkin> dolio: do you know if the omission of higher-order functions on MUArr is intentional or just because the library isn't complete yet?
21:27:47 <rwbarton> But surely everyone agrees on the semantics of return, (>>=), getChar, and putChar, which is sufficient for the current discussion
21:27:50 <dolio> What kind of higher order functions?
21:27:57 <mmorrow> , let transposeU us@(u:_) = runST (do mus <- replicateM (lengthU u) (newMU (length us)); foldM (\i u -> zipWithM_ (flip writeMU i) mus (fromU u) >> return (i+1)) 0 us; mapM unsafeFreezeAllMU mus); xs = fmap toU [[0..3],[4..7]] in transposeU xs
21:27:58 <lunabot>  [toU [0.0,4.0],toU [1.0,5.0],toU [2.0,6.0],toU [3.0,7.0]]
21:28:03 <pumpkin> dolio: things like map, fold
21:28:09 <iron34> Ok but what is with the occurs check how does that work ?
21:28:10 <mriou> the thing about IO is whether you can really avoid it, many programs actually have IO operations at a fairly low level which bubble up
21:28:16 <dolio> , [$ty| foldlU |]
21:28:18 <lunabot>  forall a b . UA a => (b -> a -> b) -> b -> UArr a -> b
21:28:26 <pumpkin> dolio: I mean on MUArrs, not UArrs
21:28:31 <porges> iron34: the occurs check normally only comes up when you end up with something with an infinite type
21:28:44 <pumpkin> dolio: or are you just not supposed to use them much?
21:28:44 <porges> iron34: which means you need to change something
21:28:48 <ksf> iron34, that's Hindley-Milner type inference.
21:28:58 <dolio> Oh. I think the answer is that MUArrs aren't the part of the library dons is excited about.
21:29:05 <pumpkin> ah :)
21:29:06 <iron34> Because haskell can do recursive type definitions but they seem to work in declaring types
21:29:08 <pumpkin> alright
21:29:14 <ksf> google it up to be puzzled like, most likely, you never have been before.
21:29:20 <dolio> They're just there to support certain operations on the UArrs.
21:29:20 <porges> iron34: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=884#a885 works
21:29:35 <pumpkin> I'm just trying to clean up / complete the documentation and trying to figure out what some of the undocumented functions do
21:29:38 <ksf> "recursive" /= "infinite".
21:30:00 <ksf> (now I've maneuvered myself into an area made of pitfalls)
21:30:30 <ksf> that is, an infinite type wrt. Occurs check is one for which the type checker can't figure out a fixpoint.
21:30:36 <pumpkin> , permuteU (toU [5..10]) (toU [2,1,3,4,5])
21:30:37 <lunabot>  luna: Not in scope: `permuteU'
21:31:24 <mmorrow> ksf: for any "cannot construct the infinite type" error, you can derive the needed newtype to do it from the "t = ... t ..." part
21:32:04 <pumpkin> , reverseU (toU [1..5])
21:32:05 <lunabot>  luna: Not in scope: `reverseU'
21:32:07 <dolio> Haskell disallows equirecursive types, but allows isorecursive types.
21:32:18 <ksf> yeah, but I'm not at all shure whether I'd ever want to do that.
21:32:24 <mmorrow> ksf: "newtype" just amounts to a strategic (unsafe)Coerce in that case
21:33:06 <mmorrow> , src ''Mu
21:33:08 <iron34> porges: doesn't work for me when I called fac3 5 it says No instances for (Num (a -> a), Ord (a -> a))
21:33:08 <iron34>       arising from a use of `fac3' at <interactive>:1:0-5
21:33:08 <iron34>     Possible fix:
21:33:08 <iron34>       add an instance declaration for (Num (a -> a), Ord (a -> a))
21:33:08 <iron34>     In the expression: fac3 5
21:33:08 <iron34>     In the definition of `it': it = fac3 5
21:33:09 <lunabot>  newtype Mu f = Mu (f (Mu f))
21:33:40 <mmorrow> , muT [0..3]
21:33:42 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
21:34:17 <ksf> iron34, that's because 5 is a Number, and not a function.
21:35:01 <ksf> > let fac n = product [1..n] in fac 20
21:35:03 <lambdabot>   2432902008176640000
21:35:37 <iron34> but I defined fac3 n = fac2 fac2 n
21:35:47 <mmorrow> , $(foldT [|()|] (\a b -> [|($a,$b)|]) (muT (fmap lift [0..7::Int])) id)
21:35:49 <iron34> shouldn't it take a number
21:35:50 <lunabot>  (((0,1),(2,3)),((4,5),(6,7)))
21:36:23 <ksf> well, the first fac2 takes a function, and a number... which makes the second one quite confused.
21:36:36 <ksf> add a few parenthesis to clear stuff up.
21:36:49 <mmorrow> , fmap ($ $(foldT [|()|] (\a b -> [|($a,$b)|]) (muT (fmap lift [0..7::Int])) id)) [fst . fst . fst, snd . fst . snd, snd . snd . snd]
21:36:51 <lunabot>  [0,5,7]
21:37:09 <pumpkin> does having a CAF of False optimize away any check depending on that name?
21:37:38 <pumpkin> so if I do debug=False, if debug then x else y. Does the if get optimized to y with no condition checking?
21:37:49 <rwbarton> I would certainly hope so!
21:38:00 <ksf> pumpkin, check the core?
21:38:24 <iron34> where should I add the parenthesis I did fac3 n = fac2 (fac2 n) did not make a difference
21:38:32 <rwbarton> It should get inlined and then there is probably a rule for "if False then x else y"
21:38:45 <ksf> how is fac2 defined?
21:39:00 <dolio> pumpkin: Looks like it gets optimized away.
21:39:15 <pumpkin> cool :)
21:39:23 <iron34> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=884#a885
21:39:24 <rwbarton> dolio: does it report that a rule fired?
21:39:32 <iron34> ksf there is the link to hpaste
21:39:49 <ksf> anyway, in general: add type annotations to your functions, it helps to clean up stuff... especially the error messages.
21:39:57 <dolio> rwbarton: Probably, but I don't know what optimization that would fall under.
21:40:21 <dolio> Oh, KnownBranch, probably.
21:40:47 <iron34> ksf would you have a suggestion on the function signature ?
21:40:49 <rwbarton> Yeah.  Not a rule
21:40:54 <dolio> Right.
21:40:56 <pumpkin> what does {-# INLINE [1] mean?
21:40:57 <Axman6> iron34: again, you need fac3 n = fac2 (fac2 n)
21:41:18 <Axman6> oh wait, sorry, no you don't
21:41:31 <ksf> iron34, the second one works...
21:41:36 <dolio> The [1] specifies in which phase of the optimizer the rule should be applied.
21:41:38 <rwbarton> pumpkin: It's something subtle about what "phases" the definition can be inlined during.
21:41:46 <rwbarton> pumpkin: I suggest consulting the GHC manual
21:41:50 <pumpkin> ah okay, thanks :)
21:41:58 <rwbarton> (the syntax is quite counterintuitive to me)
21:42:11 <rwbarton> Well, not counterintuitive, just non-obvious.
21:42:13 <iron34> ksf the second one doesn't work when I type fac3 5 it gives me an error message
21:42:36 <Axman6> iron34: paste the error message on hpaste
21:43:01 <Axman6> iron34: oh i know what the problem is, fac2 needs a function and a number
21:43:03 <pumpkin> if I write a rewrite rule for "x (unx a) = a" that doesn't automatically cover the inverse, right?
21:43:03 <rwbarton> iron34: You can't do what you're trying to do without explicit recursion or recursive types (which in Haskell require a newtype or data)
21:43:13 <pumpkin> it has no reason to know that, I guess
21:43:31 <Axman6> iron34: maybe you want fac3 n = fac2 (fac2 fac) n
21:43:43 <mriou> I'm wondering what people think about "write yourself a scheme in 48 hours", almost everything happens in IO
21:43:44 <SamB> pumpkin: it'd be bad if it did
21:43:48 <SamB> it might get in a loop
21:43:53 <iron34> done http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=884#a886
21:44:02 <SamB> pumpkin: if you want that, you'll have to put them in different phase ranges
21:44:03 <mriou> would there be some better way for the same exercise
21:44:05 <mriou> ?
21:44:27 <pumpkin> SamB: why would it get into a loop?
21:44:47 <SamB> pumpkin: rewriting back and forth!
21:44:56 <Axman6> iron34: fac2 needs a function and a number, you're using the outer fac2 correctly in fac3, but the inner one needs another function
21:44:56 <pumpkin> but it's just matching against the function application
21:45:06 <rwbarton> iron34: f (f (n-1)) isn't really what you want, is it?
21:45:15 <ksf> iron34, try fac3 id 5
21:45:21 <rwbarton> iron34: you wanted f f (n-1), but that requires recursive types
21:45:26 <SamB> pumpkin: oh, you mean a different thing by inverse ?
21:45:38 <ksf> ...figuring out _why_ will bend your mind.
21:45:39 <iron34> rwbarton yes
21:45:40 <Axman6> ksf: fac3 doesn;t take in any functional arguments...
21:45:51 <ksf> sure it does.
21:45:59 <ksf> it's got type fac3 :: (Int -> Int) -> Int -> Int
21:46:10 <pumpkin> SamB: like, if x (unx a) gives me a, and I have another rule for unx (x a), I don't see why it would get stuck
21:46:13 <iron34> gave me the wron answer 660
21:46:14 <ksf> if fac 2 has fac2 :: (Int -> Int) -> Int -> Int
21:46:22 <SamB> pumpkin: ah, fine
21:46:29 <dolio> pumpkin: SamB was referring to "a = x (unx a)"
21:46:29 <pumpkin> sorry, wasn't clear
21:46:32 <nolrai_East> argh, why does monadLib define an "(MonadPluss m) => MonadPluss (ExceptionT e m)" instance, why?
21:46:37 <ksf> iron, what do you want to calculate, anyway?
21:46:39 <rwbarton> iron34: Without recursive types or explicit value recursion, you can't write general recursive functions.
21:46:40 <pumpkin> oh yeah, I didn't mean that
21:46:51 <SamB> can you see why it'd go into a loop ?
21:47:37 <pumpkin> yeah, with what dolio said, definitely
21:47:40 <iron34> rwbarton : Why not ?
21:47:58 * ksf thinks iron should save that one somewhere safe, start over and re-investigate it not earlier than next week
21:48:02 <rwbarton> iron34: Hmm, it's a theorem?  I don't know how to prove it off-hand :)
21:48:26 <rwbarton> iron34: Every term in the simply-typed lambda calculus is strongly normalizing
21:48:40 <iron34> rwbarton : I will take intuition instead of proff if you have it
21:49:12 <rwbarton> iron34: I don't really have intuition for it either, besides the fact that you're trying to do it and it's not working. :)
21:49:19 <iron34> rwbarton: Strongly normalizing
21:49:28 <iron34> ?
21:49:52 <rwbarton> Meaning evaluation is guaranteed to terminate under any reduction strategy
21:50:34 <dolio> Producing the same term, to boot.
21:50:43 <rwbarton> Yeah, that too.
21:50:54 <rwbarton> But that's not as surprising.
21:51:02 <dolio> Perhaps not.
21:51:18 <iron34> rwbarton: So if haskell can not guarantee termination then it doesn't compile
21:51:29 <ksf> nope, that's agda.
21:51:37 <rwbarton> Well, no.  Because haskell has both value recursion and recursive types.
21:51:55 <ksf> that is, agda's typechecker may not terminate if you don't prove your program terminates.
21:52:04 <rwbarton> But you're not using either of those in your program (and it looks like you're explicitly trying to avoid value recursion)
21:52:39 <iron34> rwbarton: yes I use that technique in other pls to avoid recursion
21:52:52 <ksf> you can't, if you want to loop.
21:52:53 <iron34> don't understand why it won't work in haskell
21:53:02 <rwbarton> iron34: Because of the type system, basically.
21:53:15 <diltsman> I'm trying to build the cabal-install package.  When it trys building zlib I get an error saying "error: zlib.h: No such file or directory".  Anybody know what I can do to fix this?  I can see zlib.h in a directory within the zlib package.
21:53:18 <rwbarton> iron34: I too would like to have a satisfying conceptual explanation of exactly why this is the case
21:54:02 <ksf> diltsman... debian or ubuntu? zlib installed but not zlib-dev?
21:55:31 <iron34> rwbarton: you seem pretty knowledgeable maybe you know a Haskell Uber Guru who knows the answer ?
21:55:41 <ksf> you cannot, ever, construct anything with real or potential infinite length without recursion. ever. never.
21:56:02 <ksf> accept it as a natural law, that's the easiest way.
21:56:17 <iron34> ksf : well it works in python and java I can show you the code
21:56:25 <ksf> nope.
21:56:32 <ksf> a for is a recursion.
21:56:45 <ksf> ...just a not-as-general type as your usual one.
21:56:54 <ksf> s/type/kind
21:57:00 <diltsman> ksf: Ubuntu.  I installed zlibc.  I can't find a package named zlib or zlib-dev.
21:57:17 <rwbarton> iron34: at least in python it's because you don't have the type system stopping you.
21:57:25 <ksf> do you have /usr/include/zlib.h?
21:57:34 <rwbarton> iron34: let me cook up an example of doing recursion in haskell without value recursion
21:58:14 <diltsman> ksf: yes.  zlib.h is at /usr/include/zlib.h
21:58:28 <iron34> rwbarton: sure that would be great. By the way it does work in java I tried it
21:59:28 * ksf just compiled zlib-0.5.0.0 without problems
22:00:26 * BMeph looks for the Cale-signal...
22:00:28 <ksf> ...and the haskell zlib package comes with the whole zlib, it doesn't even need a system-wide installed one.
22:01:01 <ksf> did you try runhaskell Setup.hs build -v3 and look at the gcc invokation?
22:01:02 <iron34> ksf: In reference to your for loop comparion in the python and java version I wiped up I did not use a loop construct
22:02:50 <ksf> still, you have recursion if you code a (potentially) infinite algorithm in finite lines of code.
22:03:07 <rwbarton> iron34: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=884#a888
22:03:10 <ksf> show me the code and I show you.
22:03:35 <diltsman> ksf: I built and installed zlib (not using the ./bootstrap.sh script) and that installed.  Then everything went smootly from there.
22:03:43 <rwbarton> iron34: that's just introducing a newtype to get around the type error you were getting before.
22:03:48 * BMeph is curious to see iron34's code
22:04:33 <ksf> rwbarton, that's even worse readable than any usage of fix.
22:04:42 <rwbarton> Yes, it is
22:05:29 <ksf> ...but that's what it is, basically.
22:05:40 <iron34> rwbarton: You rock can you explain to a noob like myself why this works and mine did not
22:06:03 <ksf> :t fix
22:06:05 <lambdabot> forall a. (a -> a) -> a
22:06:16 <ksf> @src fix
22:06:16 <lambdabot> fix f = let x = f x in x
22:06:23 <rwbarton> OK, first ignore the 'a' parameter to Fun, I didn't end up using it
22:06:29 <rwbarton> newtype Fun = Fun (Fun -> Integer -> Integer)
22:06:42 <rwbarton> defines a type Fun which is isomorphic to Fun -> Integer -> Integer
22:07:18 <rwbarton> The error message you were getting originally was Haskell complaining that you couldn't have a type t which was *equal* to t -> Integer -> Integer
22:07:43 <pumpkin> if I try to :m
22:07:44 <ksf> ...which is isomorph to Fun -> (Integer -> Integer) -> Integer -> Integer
22:07:50 <nolrai_East> what does "GADT pattern match in non-rigid context for `ChooseCommand'" mean exactly?
22:07:58 <pumpkin> + Data.Array.Vector in ghci, it tells me "module `Data.Array.Vector' is not loaded"
22:08:09 <pumpkin> if I do :l for it, it says it can't find a header file
22:08:10 <rwbarton> because in "f f (n-1)", the two f's have the same type, call it t, then t must be a function that takes an argument of type t and an Integer and returns an Integer
22:09:01 <rwbarton> Haskell doesn't allow infinite types like t = t -> Integer -> Integer, but only because in practice they usually mean you made an error writing your program.
22:09:22 <rwbarton> You can work around it with a newtype wrapper like in my paste.
22:09:43 <SamB> rwbarton: not also because it would take too long to print the type ?
22:10:21 <dolio> Nah, you just write 'mu t. t -> Integer -> Integer'.
22:10:30 <rwbarton> Yeah, maybe.  Apparently OCaml has a switch to allow isorecursive types; I don't know how it displays them in general :)
22:12:08 <iron34> rwbarton: how did you learn about all this if I may ask ? any good bokk sugestions ?
22:13:10 <iron34> man my spelling is way off
22:13:12 * ksf still wonders what's supposed to be the point of it all.
22:14:10 <pumpkin> rwbarton is smart
22:14:21 <ksf> still, rwbarton, you should submit that to http://www.willamette.edu/~fruehr/haskell/evolution.html
22:14:26 <pumpkin> he doesn't learn, he teaches
22:14:28 <iron34> pumpkin I agree
22:14:28 <pumpkin> :D
22:14:38 <rwbarton> I read "The Functional Approach to Programming" by Cousineau + Mauny a long time ago, I think it was pretty good for learning about Hindley-Milner
22:14:39 <pumpkin> :)
22:14:49 <rwbarton> and a lot from hanging out here of course :)
22:16:13 <rwbarton> I'm pretty sure I learned that recursive types give you general recursion from dolio, for instance
22:17:18 <iron34> rwbarton : well I add that book to my reading list
22:17:48 <iron34> but I see it uses CAML
22:17:58 * ksf learned all he needed to know to grok haskell papers from the wizard book.
22:18:19 <ksf> ...and from haskell papers, of course.
22:18:26 <rwbarton> Yeah, but the overlap between ML and Haskell is large.
22:21:45 <ksf> the rationale to learn scheme could be to learn to type statically: with that amount of abstraction, you'd be lost relying on run-time errors to catch your type errors.
22:22:43 <iron34> well thanks all especially you rwbarton I learned something cool I guess I will sleep on it
22:22:47 <iron34> good night all
22:31:18 <eve> hello?
22:31:28 <eve> is anyone here?
22:31:49 <jeffz`> @users
22:31:50 <lambdabot> Maximum users seen in #haskell: 646, currently: 567 (87.8%), active: 8 (1.4%)
22:31:55 <eve> ?
22:32:27 <eve> ?
22:32:27 <eve> ?/
22:32:27 <lambdabot> Maybe you meant: . ? @ v
22:32:28 <eve> ?
22:32:34 <eve> is anyone on here
22:33:15 <eve> hellooo
22:33:31 <int80_h> would it make sense to try and work through the exercises in the wizard book using haskell?
22:33:50 <ray> what's this wizard book i hear so much about
22:34:02 <eve> can someone help me with php????
22:34:03 <ray> where much is relative, it took up a significant percentage of that one line of text at least
22:34:09 <int80_h> google it, it's a canonical CS book using scheme
22:34:18 <ray> you mean SICP?
22:34:22 <int80_h> jah!
22:34:25 <eve> i need help with php, anyone?
22:34:32 <int80_h> this is the haskell room eve
22:34:40 <arw> eve: nope. this is not #php
22:34:41 <eve> wut does that mean?
22:34:41 <ray> some of it might be useful to do
22:34:59 <int80_h> because I'm considering buying it
22:35:13 <eve> wait, is there a php roomm?
22:35:21 <int80_h> and we have a troll!
22:35:51 <ray> if you're like me and vastly prefer dead tree books to online books, i recommend it
22:35:53 * int80_h goes to work on RWH
22:36:17 <int80_h> ray: I really do. I have to have an actually book. I can't stand reading a book online
22:36:33 <ray> it goes in one eyeball and out the other, or something
22:36:59 <int80_h> I need to get another copy of K&R, and work through the Data Structures pdf from the Stanford CS Library
22:37:20 <int80_h> and my book collection will be satisfactory for now
22:37:33 * ozy` whips eve with a snake
22:37:43 <ozy`> go to ##php
22:37:51 <int80_h> I wish there was a Haskell equivilent to those docs at the Stanford CS Library
22:38:29 <int80_h> although I may do the final task "The great binary tree " problem, in haskell
22:39:27 <int80_h> see joo mugs later, I'm off to watch Red Dwarf
22:53:36 <pumpkin> is there an overview of the additional optimizations in uvector over stream-fusion?
22:54:16 <bombshelter13> Is there any standard option, that, given [1,2,3,4,5,6,7,8,9] will give back [[1,4,7],[2,5,8],[3,6,9]]?
22:54:25 <bombshelter13> standard function, that is
22:54:43 <dobblego> @type splitAt
22:54:44 <lambdabot> forall a. Int -> [a] -> ([a], [a])
22:54:52 <Axman6> look into the Data.List.Split library
22:54:53 <pumpkin> no
22:54:58 <pumpkin> it's a classification
22:54:59 <dobblego> there is Data.List.Split
22:55:12 <chromakode> hey guys, what's going on with the logo contest?
22:55:18 <bombshelter13> dobblego: i'll try that
22:55:24 <pumpkin> I don't think split can do it
22:55:34 <pumpkin> maybe
22:56:47 <beelsebob> bombshelter13: I'm not dead certain about the semantics of your function – what would it yield if I added a 10?
22:57:08 <pumpkin> or an 11
22:57:08 <bombshelter13> beelsebob: it would probably be truncated.
22:57:14 <pumpkin> hmm
22:57:20 <beelsebob> and what if I added 10,11,12?
22:57:39 <pumpkin> bombshelter13: I can see two obvious interpretations of the function :o
22:57:50 <Gracenotes> argh! Every time I try to think in depth about a recursive process, Gerald Jay Sussman's voice pops up in my head and reminds me that "Recursion is all about wistful thinking", and it ruins my concentration :/
22:57:50 <beelsebob> I think I can see 3
22:58:01 <bombshelter13> wasn't there some sort of rotate function? maybe i can do some sort of rotate/zip combo, if i can find that
22:58:13 <rwbarton> bombshelter13: you probably want transpose + something from Data.List.Split
22:58:25 <pumpkin> when I first saw it, it looked like equivalence classes mod 3
22:58:35 <beelsebob> yeh
22:59:12 <bombshelter13> rwbarton: kay, i'm gonna look those up
22:59:58 <pumpkin> bombshelter13: if you appended an 11 onto the list, would it go into the first list, the second, or none? (or the third?? :P)
23:00:04 <beelsebob> equivClasses n xs = map (\m -> filter ((==m) . (`mod` n)) xs) [1..n] -- something like this pumpkin?
23:00:27 <pumpkin> yeah
23:01:10 <bombshelter13> pumpkin: I'm not sure, I'm only concerned about valid input at the moment... (valid = a list argument whose length is a multiple of the split width)
23:01:33 <pumpkin> bombshelter13: so if I appended 12,10,11 to it
23:01:36 <beelsebob> bombshelter13: how is the split width determined?
23:01:42 <cads> hey, does the phrase "wearing the hair shirt of lazy language design" stir any memories? I don't know if that's the actual wording, but i think it was in an essay on haskell's long, and apparently at times challenging history.
23:01:48 <bombshelter13> beelsebob: another argument
23:01:55 <bombshelter13> like 'magic 3 [1,2,3,4,5,6,7,8,9]
23:02:01 <beelsebob> bombshelter13: then what I just posted appeareds to work fine
23:02:09 <bombshelter13> beelsebob: kay, i'll try it out
23:02:20 <beelsebob> > let equivClasses n xs = map (\m -> filter ((==m) . (`mod` n)) xs) [1..n] in equivClasses 3 [1..9]
23:02:22 <lambdabot>   [[1,4,7],[2,5,8],[]]
23:02:25 <beelsebob> or not
23:02:28 <pumpkin> you need 0
23:02:29 <cads> I believe hair shirts were something that monks would wear to make themselves more pure through discomfort
23:02:30 <pumpkin> and n- 1
23:02:33 <beelsebob> oh, so I do
23:02:41 <beelsebob> > let equivClasses n xs = map (\m -> filter ((==m) . (`mod` n)) xs) [0..(n-1)] in equivClasses 3 [1..9]
23:02:43 <lambdabot>   [[3,6,9],[1,4,7],[2,5,8]]
23:02:47 <beelsebob> but then I need rotation
23:03:03 <beelsebob> > let equivClasses n xs = map (\m -> filter ((==m) . (`mod` n)) xs) ([1..(n-1)]++[0]) in equivClasses 3 [1..9]
23:03:04 <pumpkin> [1..n-1]++[0] :P
23:03:04 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
23:03:06 <beelsebob> ugly now
23:03:19 <pumpkin> yup
23:03:24 <rwbarton> It's unclear whether the groups are supposed to be based on the positions of the elements in the list or their values
23:03:33 <beelsebob> > let equivClasses n xs = map (\m -> filter ((==m) . (`mod` n)) xs) (map (`mod` n) [1..n]) in equivClasses 3 [1..9]
23:03:34 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
23:03:37 <Gracenotes> it doesn't make sense to order it = 0 mod 3, = 1 mod 3, = 2 mod 3?
23:03:39 <beelsebob> pumpkin: how's thit?
23:03:41 <pumpkin> yeah, that's what I tried to ask :)
23:04:00 <beelsebob> Gracenotes: if it were me, i'd start at 0
23:04:06 <beelsebob> but it wasn't the requested function
23:04:06 <rwbarton> > splitEvery
23:04:07 <lambdabot>   Not in scope: `splitEvery'
23:04:09 <rwbarton> , splitEvery
23:04:11 <Gracenotes> ah
23:04:12 <lunabot>  luna: Not in scope: `splitEvery'
23:04:48 <Gracenotes> beelsebob: you're in the Chinese function-writing room, huh? :P
23:05:01 <beelsebob> Gracenotes: :D
23:05:01 <rwbarton> @tell mmorrow it'd be nice to have Data.List.Split in lunabot
23:05:01 <lambdabot> Consider it noted.
23:05:25 <mmorrow> rwbarton: adding now
23:05:25 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
23:05:28 <beelsebob> Gracenotes: work's been getting to me – they've got it into my head that I have to write what *they* want, not what I want
23:06:22 <Gracenotes> maybe you should write what they don't know they want yet :P
23:07:10 <cads> ahh, it was peyton jone's talk "Wearing The Hair Shirt: a retrospective on haskell"
23:07:20 <cads> has anyone read it?
23:07:27 * Gracenotes has
23:07:37 <cads> insightful read?
23:07:53 <Gracenotes> the part about the implementation of type classes was very informative
23:08:38 <Gracenotes> it also has some "open challenges" in Haskell
23:08:43 <cads> are type classes something present in the original formulation of hindley myer, or a later extension to include polymorphism?
23:08:49 <BMeph> cads:; That's an SPJ-ism. :)
23:08:56 <cads> ah
23:09:18 <cads> I'm consistently amazed by that guy's energy, both in person and in his publications
23:09:33 <mmorrow> , chunk 4 [0..]
23:09:34 <lunabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23...
23:09:45 <beelsebob> ah
23:09:46 <beelsebob> cool
23:09:49 <Gracenotes> @index chunk
23:09:49 <lambdabot> bzzt
23:09:53 <Gracenotes> D:
23:09:56 <beelsebob> @hoogle chunk
23:09:56 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
23:09:56 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
23:09:56 <lambdabot> Data.ByteString.Lazy.Internal chunkOverhead :: Int
23:09:58 <mmorrow> @hackage split
23:09:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
23:09:59 <cads> Gracenotes: thanks for the minireview, I'll look forward to the section on type classes
23:10:06 <mmorrow> , 'chunk
23:10:07 <lunabot>  Data.List.Split.Internals.chunk
23:10:25 <mmorrow> (it's exported by Data.List.Split)
23:10:28 <mmorrow> ((too))
23:10:38 <rwbarton> , transpose $ chunk 3 [1..9]
23:10:39 <lunabot>  [[1,4,7],[2,5,8],[3,6,9]]
23:10:40 <Gracenotes> cads: enjoy :)
23:10:50 <bombshelter13> rwbarton: handy! thanks.
23:11:19 <Gracenotes> ah, transpose. Such a useful function that it seems I never end up using :X
23:11:19 <mmorrow> , unintercalate "fg" (cycle "asdfghjkl;")
23:11:20 <lunabot>  ["asd","hjkl;asd","hjkl;asd","hjkl;asd","hjkl;asd","hjkl;asd","hjkl;asd",...
23:11:49 <mmorrow> byorgey: your split pkg looks useful :)
23:12:35 <mmorrow> , splitEvery 4 [0..]
23:12:36 <lunabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23...
23:14:25 <lpjhjdh> So I was trying to figure out how to generate a type from a dynamically computed value and failing, finally looking to Oleg.  Are there any prominent projects using type-level stuff for configuration like in his functional pearl paper?
23:14:37 <mmorrow> , scanl (+) 0 (fmap (*2) [1..])
23:14:38 <lunabot>  [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,4...
23:14:55 <psamathos> I'm having trouble with a type signature( http://pastebin.com/m273ae9ed ) anyone know why I get "Test.hs:3:0: Invalid type signature"?
23:14:58 <mmorrow> , splitPlaces (scanl (+) 0 (fmap (*2) [1..])) [0..]
23:15:00 <lunabot>  [[],[0,1],[2,3,4,5,6,7],[8,9,10,11,12,13,14,15,16,17,18,19],[20,21,22,23,...
23:15:23 <psamathos> I must have tried every possible variation a after ::
23:16:25 <rwbarton> psamathos: just guessing, maybe you only want :: IO ()   ?
23:16:45 <psamathos> I think I've tried but I'll try again :)
23:17:12 <psamathos> rwbarton: same error :)
23:17:41 <mmorrow> this works for me:
23:17:42 <mmorrow> foreign export ccall "runTest" test_main :: IO ()
23:17:43 <mmorrow> test_main :: IO ()
23:17:43 <mmorrow> test_main = do putStrLn "Hello, world!"
23:17:58 <psamathos> how odd :(
23:18:02 <mmorrow> i think that'll look like a "void test_main(void)" from C
23:18:15 <psamathos> exactly what I want :)
23:18:20 <mmorrow> woot
23:19:38 <rwbarton> psamathos: oh, maybe you forgot {-# LANGUAGE ForeignFunctionInterface #-} ?
23:19:40 * pumpkin is writing docs for UArr :D
23:20:12 <mmorrow> $ ghci -fobject-code
23:20:13 <lunabot>  luna: Not in scope: `ghci'
23:20:15 <psamathos> rwbarton: I think so too :)
23:20:15 <mmorrow> is the best thing evar
23:20:27 <psamathos> rwbarton: thanks alot :)
23:20:39 <mmorrow> pumpkin: sweet
23:21:29 <pumpkin> is there any way to ask cabal to simply regenerate haddock and install it?
23:21:34 <pumpkin> rather than recompiling the code?
23:21:37 <Axman6> , print "check..."
23:21:38 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
23:22:25 <mmorrow> pumpkin: you can do
23:22:28 <mmorrow> ./Setup haddock
23:22:37 <pumpkin> and then install?
23:22:40 <pumpkin> ./Setup install, that is
23:22:41 <mmorrow> these are my fav opts
23:22:48 <mmorrow> not positive about that part
23:23:03 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
23:23:29 <mmorrow> (i don't know if the "--haddock-options=--html" is needed or not now that i think about it)
23:24:14 <pumpkin> it worked fine for me without
23:29:26 <jdrake> I was just doing some ladder logic for the first time today (PLCs!) and I swear it is basically a purely functional language whose program runs in a monad.
23:32:58 <Adamant> hardware is usually parallel except where it's sequential
23:33:56 <jdrake> The way the execution was explained to me is that each rung is done in order, and that outputs can only be written to once.
23:34:14 <jdrake> In fact, the way I wrote my program, the outputs were the result of a formula of inputs.
23:35:03 <mmorrow> can anyone think of how to detect exps like (e.g.) "let x = x in x" which (1) don't allocate any memory, and (2) don't call into any other functions ??
23:35:24 <mmorrow> "fix id" isn't an example
23:35:52 <Adamant> jdrake: I'm trying to learn VHDL from a book, everything there is parallel unless you make it sequential, IIRC
23:36:10 <rwbarton> won't the rts detect that loop if you compile with optimizations?
23:36:15 <mmorrow> i'm not sure how to classify such expressions exactly, but i'm trying to figure out so i can detect them before going to bytecode and attempting to run it, which will lock a bytecode interp up
23:36:32 <jdrake> Adamant, is VHDL fairly easy to get hardware for? I am interested in playing with various things.
23:36:55 <mmorrow> rwbarton: indeed. i'm not sure exactly how, though. what i think happens is that ... hmm actually i'm not sure how compiled code deals with that.
23:36:57 <Adamant> jdrake: you "make" hardware with VHDL and Verilog
23:37:09 <mmorrow> rwbarton: good point
23:37:10 * rwbarton has no idea either
23:37:12 * mmorrow looks
23:37:12 <arw> you can get several cheap evaluation boards for FPGAs for something like 100$.
23:37:13 <Adamant> you put it into CLPD's, FPGA's, or ASICs
23:37:19 <Adamant> or less, even
23:37:27 <jdrake> Adamant, I know, you need the actual hardware to write it to...
23:37:29 <Adamant> they're pretty limited
23:37:48 <mmorrow> i was thinking that such expressions shouldn't be too hard to catch by examining an AST
23:37:53 <Adamant> jdrake: the lowest end Spartan-3 Xilinx is like ~$50 for a board
23:38:07 <mmorrow> the thing though is i'm not sure if it's always possible to statically identify these situations
23:38:10 <Adamant> to have fun you'd probably want around a ~$150 board
23:38:18 <jdrake> Adamant, sounds like fun
23:38:37 <Adamant> you can buy a demo board from Xilinx or several other places
23:38:59 <Adamant> jdrake: sorry for accidently talking down to you
23:39:17 <arw> problem is mostly that you need some kind of 'peripherals' for your device to do anything more than blinking LEDs :)
23:39:19 <jdrake> Adamant, worry not
23:39:47 <Adamant> arw: definitely
23:39:58 <Adamant> I need to buy stuff for my Arduino for that reason
23:39:59 <jdrake> arw, how about some nice rotary encoders, LED bargraphs, and possibly even a small display?
23:40:17 <p_l> Some of the FCPGA can be used with Terracota, so you can simply strap them in into a multi-socket amd64 board along with an Opteron and reprogram them on the fly :-)
23:40:24 <p_l> *FPGA
23:41:11 <arw> jdrake: usually you have ha handfull of LEDs, a 7-segment-display or dot-matrix and a bunch of freely usable pins on those boards.
23:41:20 <arw> jdrake: and some switches and buttons for 'input'
23:41:55 <arw> often those freely usable pins are wired to vga/usb/ps2/whatever.
23:42:35 <arw> like here: http://www.xilinx.com/products/devkits/HW-SPAR3-SK-UNI-G.htm
23:43:30 <arw> problem is, getting those to work requires more than beginners skills, even when you use library components ('cores') for the protocols.
23:44:31 <jdrake> Something that would be nice is a cheap PLC to play with. I wonder if anyone has made a hobbyist level PLC
23:44:58 <rwbarton> mmorrow: it might also work to statically analyze the bytecode before you interpret it
23:45:20 <arw> btw, what is the state of hardware design in haskell?
23:45:37 <Adamant> arw: check Lava
23:45:41 <Adamant> and Bluespec
23:45:46 <Adamant> and Wiring
23:46:17 <jdrake> night all
23:46:56 <arw> hmkay. i've briefly looked at lava before, but from the webpages it seemed somewhat out of use
23:47:03 <mmorrow> rwbarton: yeah, that sounds like a plausible way to do it to. also, probably easier than examining the AST somewhere higher up too
23:47:11 <arw> or rather, the pages seemed somewhat unmaintained.
23:47:36 <mmorrow> rwbarton: here's the (kinda) bytecode ghc generates for "let x = x in x" http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=890#a890
23:47:50 <mmorrow> it's somewhat hard to decipher
23:47:55 <mmorrow> (i haven't yet)
23:48:23 <mmorrow> but what's happening at a conceptual level is clear
23:48:56 * mmorrow has to figure out what exactly that embedded core in there says
23:49:14 <rwbarton> yeah, I was just going to ask about that
23:51:31 <rwbarton> looks like it's the core that corresponds to the preceding ProtoBCO
23:52:21 <Adamant> arw: ask augustss? he wrote a lot of the original Bluespec stuff, he probably knows what the current state of the art is more than a hardware n00b like I do
23:52:46 <Adamant> *does
23:56:57 <vegai> oh man, this is weird. My exception handler stopped working when I changed it and the function it watches to return IO String instead of IO ()
23:57:12 <vegai> in other words, now the exception goes past my handler and kills my thread
23:57:20 <inv> hi all
23:57:30 <vegai> are there perhaps some known bugs in exceptions in ghc-6.10...?
23:57:38 * vegai digs around
23:57:58 <inv> !paste
23:58:17 <inv> lambdabot: @paste
23:58:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:58:37 <inv> ups, unavailable :(
23:59:19 <int80_h>  I'm trying to define cycle in terms of foldr
23:59:32 <vegai> int80_h: http://paste.factorcode.org/new-paste
23:59:32 <int80_h> but anytime I try to recurse, I get a stack overflow
23:59:39 <vegai> s/int80_8/inv/
23:59:42 <mmorrow> rwbarton: here's the lvm bytecode for "a = let x = x in x" for comparison http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=890#a892
