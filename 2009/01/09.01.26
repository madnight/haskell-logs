00:00:01 <duryodhan> it joins the funtion map tail
00:00:03 <duryodhan> ok
00:00:05 <shachaf> duryodhan: It joins (map tail) and (filter (not . null))
00:00:11 <duryodhan> cos function app has max precedence
00:00:14 <duryodhan> ok ok
00:00:17 <ivanm> yup
00:00:22 <ivanm> duryodhan: so, that second list comprehension removes empty lists from our list of lists, and takes off the first element of each of those lists
00:00:46 <ivanm> we then prepend xs to the front of that list
00:01:07 <ivanm> basically, what we've done is taken our "table" of values, and removed the first column
00:01:19 <ivanm> we then recursively apply transpose on it
00:01:20 <duryodhan> yeah .. makes sense now
00:01:37 <ivanm> so the second half of that function transposes everything but the first column
00:01:55 <ivanm> so all that's left to do is convert the first column into a row, and then we're done
00:01:57 <duryodhan> ivanm: but then why go through having x:xs in the definition .. you could do without that ..
00:02:16 <ivanm> duryodhan: the reason they do that, is that they then don't have to manually split it apart in the middle of the function definition
00:02:35 <ivanm> since in the second half, we don't want the first element, whereas in the front half we only want the front element
00:02:42 <ivanm> @src transpose
00:02:43 <lambdabot> transpose []             = []
00:02:43 <lambdabot> transpose ([]   : xss)   = transpose xss
00:02:43 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
00:03:07 <duryodhan>  transpose (xss) = ([h | (h:t) <- xss]) : transpose ([ t | (h:t) <- xss]) ?
00:03:11 <ivanm> ^^ we can see from the previous cases that we know by this stage that we will have at least one row, which contains at least one element when we hit that line
00:03:44 <ivanm> duryodhan: that line you've pasted isn't the complete definition, since we need to know what happens when we've removed all the columns ;-)
00:03:54 <duryodhan> ok the very first line and this
00:04:09 <duryodhan> I am saying that splitting x:xs is anyways done by the comprehension right ?
00:04:16 <ivanm> duryodhan: the second line says that if there are no more elements in the first row, we can ignore it
00:04:29 <ivanm> duryodhan: _only_ for the rest of the list of lists
00:04:42 <_spm_Draget> I get the error 'ERROR "MGPL-Interpreter-l.hs":329 - Syntax error in expression (unexpected `;', possibly due to bad layout)' in this code (I know it is messy :P) : http://rafb.net/p/YzFCtB63.html
00:04:56 <_spm_Draget> Does anyone know why? I do not see any ; in line 329
00:04:58 <ivanm> duryodhan: we have three different components coming in: x is the first element of the first row, xs is the rest of the first row, and xss is the rest of the rows
00:05:07 <duryodhan> ivanm: yeah
00:05:38 <duryodhan> ivanm: but you are spltting each row in xss again as head : tail .. and x:xs is also doing the same thing
00:06:00 <ivanm> duryodhan: if you look, the list comprehensions are only applied to xss
00:06:10 <ivanm> not to the first row
00:06:11 <duryodhan> ivanm: I know ..
00:06:31 <duryodhan> ivanm: I am saying it could also be applied to first row .. without having to write it down by hand as x:xs
00:06:36 <ivanm> actually, that line you pasted is wrong
00:06:47 <ivanm> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss]) <-- that's it
00:07:05 <duryodhan> ivanm: I know .. I am saying wouldn't the line I pasted also work
00:07:15 <ivanm> OK, lets compare them
00:07:24 <ivanm> @src transpose
00:07:25 <lambdabot> transpose []             = []
00:07:25 <lambdabot> transpose ([]   : xss)   = transpose xss
00:07:25 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
00:07:47 <duryodhan> ivanm: if I am not wrong .. the line I pasted would take the head of all rows and form the the topmost row .. and attach to it the transpose of the matrix formed by the tails of all rows
00:08:47 <ivanm> > let trans [] = []; trans ([]:xss) = trans xss; trans xss = [h | (h:t) <- xss]) : trans [t | (h:t) <- xss] in trans [[1,2,3],[4,5,6],[7,8,9]]
00:08:49 <lambdabot>   <no location info>: parse error on input `)'
00:09:00 <ivanm> > let trans [] = []; trans ([]:xss) = trans xss; trans xss = [h | (h:t) <- xss] : trans [t | (h:t) <- xss] in trans [[1,2,3],[4,5,6],[7,8,9]]
00:09:02 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
00:09:25 <ivanm> duryodhan: my guess is, it's included there because we already know its of that form and so its done manually for convenience reasons
00:09:36 <ivanm> could be performance, could be to help deal with infinite lists, *shrug*
00:09:46 <ivanm> > let trans [] = []; trans ([]:xss) = trans xss; trans xss = [h | (h:t) <- xss] : trans [t | (h:t) <- xss] in trans [[1,2,3],[4,5,6],[7,8]]
00:09:48 <lambdabot>   [[1,4,7],[2,5,8],[3,6]]
00:10:00 <ivanm> > transpose [[1,2,3],[4,5,6],[7,8]]
00:10:02 <lambdabot>   [[1,4,7],[2,5,8],[3,6]]
00:10:23 <ivanm> duryodhan: yeah, its probably defined like that precisely _because_ they know its of that form and thus can do it manually
00:10:33 <ivanm> > let trans [] = []; trans xss = [h | (h:t) <- xss] : trans [t | (h:t) <- xss] in trans [[1,2,3],[4,5,6],[7,8]]
00:10:35 <lambdabot>   [[1,4,7],[2,5,8],[3,6],[]]
00:10:53 <ivanm> OK, so the second part is needed still to strip empty lists
00:11:03 <duryodhan> ohhh yeah
00:11:06 <duryodhan> ok ok got it ..
00:11:23 <duryodhan> but the third part is writtne like that cos they already know that it is of taht form
00:11:27 <duryodhan> ok
00:11:35 <_spm_Draget> I get the error 'ERROR "MGPL-Interpreter-l.hs":329 - Syntax error in expression (unexpected `;', possibly due to bad layout)' in this code (I know it is messy :P) : http://rafb.net/p/YzFCtB63.html Does anyone know why?
00:12:26 <ivanm> _spm_Draget: random guess: malformed formatting
00:12:51 <ivanm> _spm_Draget: no if statement in line 329, but you have a then and else
00:12:57 <ivanm> there you are ;-)
00:13:20 <BMeph> _spm_Draget: add a space to the 'then' and the 'else' lines. :)
00:13:34 <ivanm> oh, yeah, that
00:14:06 <ivanm> _spm_Draget: note that the reason it mentions ';' is because they can be used to manually reposition items, without relying on indentation
00:14:26 <ivanm> never forget children, that malformed and badly indented Haskell is _bad_ Haskell
00:14:27 <ivanm> ;-)
00:19:31 <Botje> it might as well be *gasp* C!
00:21:05 <Badger> :o
00:28:26 <_spm_Draget> I have a function contains that is supposed to check if a variable (string) is inside a store ((string, string)) and it is defined like this: 'contains store name = not (length ([(a, b) | ((a, b) <- store), a == name]) == 0)'
00:28:47 <_spm_Draget> The <- is causing a compiler error.
00:29:42 <sjanssen> _spm_Draget: remove the parens around ((a, b) <- store)
00:29:43 <Botje> drop the parens around (a,b) <- store
00:29:57 <sjanssen> _spm_Draget: do you want to see a better way to write that?
00:29:59 <Botje> also, length x == 0 is the same as null x
00:31:11 <augustss> _spm_Draget: you could do  name `notElem` map fst store
00:31:50 <augustss> Oh, sorry:  name `elem` map fst store
00:32:31 <sjanssen> or isJust $ lookup name store
00:32:50 <augustss> yep
00:32:52 <bos> @src runSTUArray
00:32:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:32:58 <sjanssen> or any ((name ==) . fst) store
00:33:14 <sjanssen> but no need to enumerate all possible solutions :)
00:33:26 <augustss> I like isJust $ lookup name store
00:33:42 <idnar> @type isJust
00:33:44 <lambdabot> forall a. Maybe a -> Bool
00:33:52 <idnar> @typ either
00:33:54 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
00:34:01 <idnar> er
00:34:02 <idnar> @type maybe
00:34:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
00:34:14 <augustss> @src isJust
00:34:14 <lambdabot> isJust Nothing = False
00:34:14 <lambdabot> isJust _       = True
00:34:18 <idnar> @type maybe False (const True)
00:34:20 <lambdabot> forall a. Maybe a -> Bool
00:36:57 <BMeph> Gotta sleep before work - see y'all in seven. :)
00:37:50 <sjanssen> @djinn Maybe a -> Bool
00:37:50 <lambdabot> f a =
00:37:50 <lambdabot>     case a of
00:37:50 <lambdabot>     Nothing -> False
00:37:50 <lambdabot>     Just _ -> True
00:38:08 <sjanssen> wow!
00:39:11 <ivanm> :o
00:39:23 <ivanm> @djinn a -> Maybe a -> a
00:39:24 <lambdabot> f a b =
00:39:24 <lambdabot>     case b of
00:39:24 <lambdabot>     Nothing -> a
00:39:24 <lambdabot>     Just c -> c
00:39:36 <dmwit> Nice!
00:39:38 <ivanm> and there's the maybe function in all its glory!
00:39:47 <ivanm> @djinn [a] -> Maybe a
00:39:48 <lambdabot> Error: Undefined type []
00:39:51 <ivanm> :(
00:39:58 <ivanm> I take it djinn doesn't like lists?
00:40:01 <dmwit> Well, you don't get recursive types in ?djinn.
00:40:06 <ivanm> ahhh
00:40:07 <ivanm> pity
00:40:23 <ivanm> @djinn a -> Bool -> Maybe a
00:40:24 <lambdabot> f a b =
00:40:24 <lambdabot>     case b of
00:40:24 <lambdabot>     False -> Nothing
00:40:24 <lambdabot>     True -> Just a
00:40:35 <dmwit> Recursive types lead naturally to recursive terms... ;-)
00:40:44 <ivanm> heh
00:40:48 <ivanm> and we can't have that! :o
00:40:51 <dmwit> "fix" throws a wrench in all the pretty theory.
00:40:52 <ivanm> damn recursivists...
00:41:11 * ivanm can't recall ever seeing a "useful" usage of fix
00:41:49 <augustss> ivanm: it's not just fix.  It's any recursion
00:41:59 <augustss> well, any general recursion
00:42:00 <ivanm> augustss: yeah, I got that
00:42:06 <ivanm> but since dmwit brought fix up...
00:42:29 <dmwit> ivanm: Well, "fix id" is approximately equal to "undefined".  So a trivial solution to anything in ?djinn is "fix id".
00:42:35 <sjanssen> augustss: does djinn come up with isJust merely by coincedence?
00:42:37 <dmwit> That's why we want to keep recursion out of the picture.
00:42:55 <ivanm> dmwit: hmmm....
00:43:01 <augustss> sjanssen: yes.  it could have been not . isJust
00:43:10 <ivanm> > fix id
00:43:12 <lambdabot>   * Exception: stack overflow
00:43:17 <ivanm> heh
00:43:21 <dmwit> :t fix id
00:43:22 <lambdabot> forall a. a
00:43:25 <sjanssen> @src Maybe
00:43:25 <lambdabot> data Maybe a = Nothing | Just a
00:43:28 <dmwit> :t undefined
00:43:29 <lambdabot> forall a. a
00:43:43 <pumpkin> > fix undefined
00:43:45 <lambdabot>   * Exception: Prelude.undefined
00:44:43 <dmwit> > Just coincidence
00:44:45 <lambdabot>   Just "it's because the constructors came in a consistent order, of course"
00:45:16 <dmwit> That would have been better without the "it's". =P
00:51:32 <dolio> Not all recursive types get you into the bad type of recursion.
00:51:50 <dolio> Depending on the restrictions you use.
00:57:16 <augustss> But recursion is actually not the big reason lists are not included.  I don't know how to add general elimination rules to the proof engine.  It's made for propositional logic.
00:59:26 <dolio> Yeah. I don't know about that, either. :)
01:00:59 <goalieca> > nubBy(((>1) .) . gcd) [2..]
01:01:00 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
01:09:03 <pumpkin> is the git distributed model common in darcs? I've got a copy of the uvector repo with my changes applied to it, and have so far been sending dons patches via email. Is it normal/possible for me to put my own copy up somewhere for him to "pull" from?
01:09:07 <pumpkin> (him and anyone else)
01:09:18 <pumpkin> I'm thinking of patch-tag or something
01:10:01 <sjanssen> pumpkin: yes
01:10:20 <sjanssen> normal, possible, encouraged
01:10:38 <pumpkin> how would I push my current copy of uvector (that I got from code.haskell.org) somewhere else?
01:11:27 <sjanssen> pumpkin: darcs put or init and push
01:11:30 <pumpkin> I'm guessing since patch-tag seems to have a global namespace for repo names, it wouldn't be very polite of me to call it uvector, but I should probably call it pumpkin-uvector or something
01:13:58 <pumpkin> ack, it's complaining about darcs repo version mismatches :/
01:14:25 <pumpkin> darcs convert I guess
01:14:54 <pumpkin> "The recommended way to convert an existing project from darcs 1 to
01:14:54 <pumpkin> darcs 2 is to merge all branches, `darcs convert' the resulting
01:14:54 <pumpkin> repository, re-create each branch by using `darcs get' on the
01:14:54 <pumpkin> converted repository, then using `darcs obliterate' to delete patches
01:14:54 <pumpkin> of branches."
01:14:56 <pumpkin> doesn't sound fun :/
01:15:30 <sjanssen> pumpkin: 'darcs convert' should generally be avoided
01:15:45 <sjanssen> so what format is your upstream repository in?
01:16:00 <pumpkin> Darcs2
01:16:07 <pumpkin> I guess I could create it in Darcs1 format
01:16:12 <pumpkin> what's my best option?
01:16:34 <sjanssen> no, I mean the code.haskell.org repository, the one you hope to eventually send your patches to
01:16:38 <pumpkin> oh
01:17:02 <pumpkin> I assume 1, as it complained when I tried to push it to patch-tag (which is 2)
01:17:06 <sjanssen> probably
01:17:07 <pumpkin> is there an easy way to see?
01:17:26 <sjanssen> 'darcs query repo'
01:17:43 <pumpkin>         Format: darcs-1.0
01:17:56 <sjanssen> you'll want all repositories to use the same format as upstream
01:18:08 <pumpkin> alright, so I'll just make my patch-tag one a darcs-1
01:20:21 <C-Keen> I am trying to bootstrap cabal install with a ghc-6.8.2 and it fails when building zlib's cbits. It seems that an additional -I for gcc is missing, can I pass this through Setup.hs?
01:20:27 <pumpkin> yay, it's up!
01:20:34 <pumpkin> I guess patch-tag doesn't support online browsing yet
01:21:23 <SubStack> System.Console.GetOpt confuses me
01:21:43 <SubStack> namely, what is the (Maybe String -> a) function in OptArg supposed to do?
01:22:26 <SubStack> there's an example, but it's hardly illuminating
01:22:39 <pumpkin> it looks like it converts from the string (optionally) provided on the command line to whatever you need it to be
01:23:08 <quicksilver> yes, it converts from the string (the option parameter) or Nothing (if there wasn't a parameter)
01:23:11 <quicksilver> to whatever you choose
01:23:23 <quicksilver> you're allowed to choose any option representation that suits your program.
01:23:47 <daf> it's quite magic
01:23:50 <daf> arguably too magic
01:23:53 <quicksilver> the higher order interface to GetOpt is a rite of passage :)
01:24:09 <quicksilver> once you grok it, it really opens the door to higher order programming
01:24:09 <SubStack> except for the part where it picks up all -- names I throw at it and formats it with the function that I provide the first OptArg
01:24:39 <daf> oh, I'm thinking of simplearg
01:25:48 <SubStack> if the documentation actually explained this it would be easier I think >_<
01:25:57 <jeltsch> Hello, who is the official contact person of Hackage?
01:27:07 <pumpkin> jeltsch: all of it? what do you need?
01:29:02 <SubStack> ParseArgs looks more promising anyways
01:30:04 <jeltsch> pumpkin: There is a bug in the Haddock or GHC installed on Hackage which leads to package documentation not being built. I want to get this problem fixed.
01:42:30 <C-Keen> @go paste
01:42:41 <lambdabot> http://www.pastemagazine.com/
01:42:41 <lambdabot> Title: Paste Magazine :: Home
01:42:54 <C-Keen> @go hpaste
01:43:00 <lambdabot> http://hpaste.org/
01:43:08 <C-Keen> hm, 503
01:43:24 <pumpkin> @where hpaste2
01:43:24 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
01:43:30 <pumpkin> hpaste has been down for several days
01:43:32 <Badger> @wheinb4d
01:43:33 <lambdabot> Unknown command, try @list
01:43:44 <C-Keen> thanks pumpkin
01:45:08 <C-Keen> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=967#a967
01:45:39 <quicksilver> C-Keen: You don't have zlib-dev installed?
01:47:08 <C-Keen> quicksilver: ah *duh*
01:47:50 <SubStack> blarg, I was passing the wrong function ALL ALONG
01:51:57 <jeltsch> Hello, is there anyone feeling responsible for Hackage? (See my message from 25 minutes ago.)
01:53:19 <pumpkin> jeltsch: what's the bug preventing docs from building?
01:54:03 <pumpkin> the docs are built once a day iirc
01:54:13 <jeltsch> pumpkin: See the end of this log: http://tinyurl.com/as67x5
01:54:44 <pumpkin>  /usr/local/bin/HsColour -css -anchor -odist/doc/html/type-level/src/Data-TypeLevel-Num-Aliases-TH.html src/Data/TypeLevel/Num/Aliases/TH.hs
01:54:45 <pumpkin> lol
01:55:11 <jeltsch> pumpkin: Oh, are all docs built every day or only docs of newly uploaded packages?
01:55:24 <pumpkin> I think only newly uploaded ones
01:55:51 <jeltsch> pumpkin: Why lol?
01:56:06 <pumpkin> the "HsColour -css -anchor -odist" directory
01:56:23 <pumpkin> oh wait
01:56:24 <pumpkin> I'm stupid :)
01:56:43 <pumpkin> it's going into dist/html/type-level/src/Data-TypeLevel-Num-Aliases-TH.html src/Data/TypeLevel/Num/Aliases/TH.hs I see
01:56:56 <pumpkin> :)
01:58:03 <jeltsch> pumpkin: The very end of the log says something about fromJust applied to Nothing.
01:58:08 <pumpkin> yeah, saw that
01:59:12 <jeltsch> pumpkin: Since building type-level breaks, building type-equality-check breaks too (depends on type-level) and building almost all of Grapefruit (which I want to upload soon) will break too leading to almost no Grapfruit documentation on Hackage :-( .
01:59:28 <pumpkin> aw
02:00:31 <Herbi> hi scanz
02:00:48 <scanz> hey
02:04:12 <scanz> how can i interprete this error message?: Instances of (Floating Int, Num Bool) required for definition of evalExpr
02:04:25 <pumpkin> is that hugs?
02:04:27 <pumpkin> or not GHC?
02:04:35 <scanz> hugs
02:04:58 <quicksilver> scanz: you are using (/) with an integer
02:05:06 <pumpkin> sounds like you're trying to treat a bool as a number
02:05:07 <quicksilver> scanz: and you're using "if" with a number
02:05:09 <quicksilver> would be my guess.
02:05:24 <scanz> okay, i'll check this
02:05:26 <scanz> thx
02:05:51 <BONUS> also, you are using hugs
02:06:16 <augustss> nothing wrong with that
02:06:22 <ivanm> BONUS: yeah, that sounds like his biggest problem ;-)
02:06:49 <pumpkin> anyone feel like pulling from my uvector repo and seeing if it all still works?
02:08:30 <Herbi> hpaste seems to be down
02:08:37 <Herbi> any1 knows why?
02:08:40 <pumpkin> it's been down for days
02:09:06 <quicksilver> glguy: hpaste has been down for a few days.
02:09:12 <quicksilver> Herbi: there is always hpaste2
02:09:14 <quicksilver> @where hpaste2
02:09:15 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
02:09:16 <scanz> i dont find the error, can somebody have a look pleas.. im sorry its formated in a bad way http://privatepaste.com/a8LZPF3RMV
02:09:17 <BONUS> my previous sentence wasn't rly constructive so uh let me elaborate i guess: i'd prefer using GHC over Hugs, because it's more up to date and has more stuff
02:09:44 <BONUS> the last Hugs version is from like 2006 or so it says on the site
02:10:02 <pumpkin> ack, I sent dons a bad patch for uvector but I've sent him a couple of emails since he last replied to me and I don't want to look like I'm spamming!
02:10:04 <pumpkin> what to do!
02:11:06 <quicksilver> scanz: Yowch. THat is horrible formatting indeed ;)
02:11:11 <scanz> its better this way: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=968#a968 kann sbd gave a look please?
02:11:14 <quicksilver> scanz: the "Num Bool" part of the error is from this:
02:11:24 <quicksilver> case (x1 <= x2 && x2 <= x1+w1 && y2 <= y1 && y2 >= y1+h1) of 1 -> ....
02:11:30 <hugo___> hello
02:11:35 <quicksilver> scanz: that expression in () is a Bool expression
02:11:41 <quicksilver> scanz: it can't possibly take the value '1'
02:11:50 <quicksilver> (it can take the value True or False)
02:11:56 <scanz> okay, a only true or false?
02:11:58 <quicksilver> it might be more natural to use 'if' than 'case' on it.
02:12:06 <scanz> okay, thank you!
02:12:19 <quicksilver> the floating error is from the sqrt
02:12:28 <idnar> @where symbols
02:12:29 <lambdabot> I know nothing about symbols.
02:12:32 <quicksilver> your evalExpr returns Int
02:12:36 <quicksilver> you can't sqrt an Int.
02:12:37 <idnar> @fact symbols
02:12:37 <lambdabot> symbols: "⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳ ⟦⟧"
02:12:42 <augustss> scanz: also, the indentation is still horrible.  Far too much
02:12:51 <idnar> hmm, where's -> ?
02:12:52 <pumpkin> oh wow
02:12:56 <pumpkin> that code is amazing
02:13:08 <pumpkin> do you have a 30" screen or something?
02:13:46 <augustss> 2 point font :)
02:14:36 <pumpkin> that's a pretty enormous nesting of if statements (assuming 0/1 = False/True)
02:15:13 <augustss> looks like the code needs some refactoring.  and reindenting. :)
02:15:51 <pumpkin> scanz: keep in mind that you have a bunch of what's essentially case x of True -> True; False -> False
02:16:29 <scook0> heh, I looked at that code and thought "that doesn't look so complex"
02:16:34 <scook0> then I saw my scrollbars ;)
02:16:44 <pumpkin> if x then True else False is just x
02:18:23 <scanz> okay, tank you very much.. i thought that i need this indentation to get no indentation error, whatever.. how can i cast double to int?
02:18:42 <pumpkin> round/truncate/ceiling/floor
02:19:15 <pumpkin> you do need indentation if you want to write it like that, but there are probably more elegant ways of writing it. what you don't need is indentation that deep, regardless of how you write it
02:20:30 <hackage> Uploaded to hackage: language-c 0.3.1.1
02:20:35 <pumpkin> ooh
02:21:08 <quicksilver> scanz: personally, on line 18, I would hit RET just before the very first "case get_obj"
02:21:41 <quicksilver> scanz: then I'd start that case in column 3 (i.e. two spaces in)
02:21:48 <quicksilver> that would save you quite a lot of 'indentation creep'
02:22:04 <quicksilver> then, I'd case "get_obj v1" and "get_obj v2" at the same time
02:22:14 <scanz> okay, thx.. i'll fix it
02:22:17 <quicksilver> case (get_obj v1, get_obj v2) of
02:22:25 <scanz> but how can i could cast double t int
02:22:31 <pumpkin> scanz: I told you
02:22:37 <pumpkin> round/truncate/ceiling/floor
02:22:41 <pumpkin> you choose
02:22:41 <quicksilver>   (ObjVal Rectangele attr1,ObjVal Rectangle attr2) ->
02:23:06 <pumpkin> scanz: there's no single way to pass from a Double to an Int
02:23:20 <pumpkin> is 4.4 4 or 5? or 7?
02:23:21 <pumpkin> :P
02:23:31 <doserj> @type round/truncate/ceiling/floor --just kidding
02:23:32 <lambdabot> forall a b. (Fractional (a -> b), Integral b, RealFrac a) => a -> b
02:23:37 <pumpkin> lol
02:23:49 <scanz> okay, i understand what you mean with round/truncate/ceiling/floor thx
02:25:37 <augustss> scanz: soon you will ask how to convert an Int to a Double
02:25:57 <scanz> Cannot justify constraints in explicitly typed binding - what's that?
02:26:20 <pumpkin> scanz: I don't know hugs errors... can you give us some context?
02:27:00 <scanz> ERROR file:.\MGPL-Interpreter_D.hs:170 - Cannot justify constraints in explicitly typed binding
02:27:02 <scanz> *** Expression    : evalExpr
02:27:03 <scanz> *** Type          : Store -> Expr -> Int
02:27:05 <scanz> *** Given context : ()
02:27:06 <scanz> *** Constraints   : (RealFrac (a -> a), Floating a, RealFrac (b -> b), Floating b, RealFrac (c -> c), Floating c, RealFrac (d -> d), Floating d, RealFrac (e -> e), Floating e, RealFrac (f -> f), Floating f, Floating g, RealFrac (g -> g), Floating h, RealFrac (h -> h), Floating i, RealFrac (i -> i))
02:27:14 * pumpkin cries
02:27:14 <quicksilver> yowch.
02:27:20 <quicksilver> that's a nice set of constraints.
02:27:27 <augustss> scanz: you've made a type error
02:27:36 <pumpkin> scanz: you're treating functions as numbers somewhere
02:27:52 <augustss> scanz: And your function is far too big, so it's difficult to pin it down
02:28:06 <scanz> okay, i'll search
02:28:56 <pumpkin> scanz: I'd strongly recommend you to break it down into more manageable chunks that you can check individually for correctness
02:29:13 <augustss> scanz: A good trick for developing Haskell code is to type check often.  Don't finish your code before giving it to the compiler.  Just stick undefined in the places you've not finished and make sure it type checks.
02:30:04 <pumpkin> Axman6: !!!
02:30:17 <Axman6> pumpkin: !!!!!
02:30:25 <pumpkin> Axman6: wanna do me a big favo(u)r?
02:30:29 * pumpkin grins
02:30:38 <Axman6> favour, yes. what is it?
02:31:16 <pumpkin> darcs get http://www.patch-tag.com/publicrepos/pumpkin-uvector :P
02:31:29 <pumpkin> and see if it works for you
02:31:46 <Axman6> sure
02:32:02 <Axman6> what do i do?
02:32:10 <pumpkin> well, you could cabal install it directly
02:32:27 <pumpkin> but what I'm mainly interested is if you cd into tests and type make
02:32:35 <pumpkin> *in
02:32:40 <Axman6> sure
02:33:16 <pumpkin> thanks :)
02:35:01 <Axman6> one failure so far
02:35:16 <Axman6>     ** test 8 of Bool-specific failed with the binding(s)
02:35:16 <Axman6>     **   toU [False,True,False]
02:35:22 <Axman6> but that's it
02:35:23 <pumpkin> oh yeah, that's expected
02:35:30 <Axman6> good good :)
02:35:38 <pumpkin> whee
02:35:54 <pumpkin> the docs in that package should be way more complete than the one on hackage btw
02:36:03 <Axman6> excellent
02:36:03 <pumpkin> if you wanna play with it
02:37:25 <patmanpato> does anyone recommend any books/resources for learning haskell or functional programming in general, with the emphasis being towards AI ?
02:39:50 <patmanpato> i know a lot of people seem to say its hard to find FP books that aren't geared towards AI programming, but im actually finding it the opposite :(
02:40:16 <quicksilver> I have no idea what an 'emphasis towards AI' is.
02:40:18 <Axman6> @where RWH
02:40:18 <lambdabot> is http://www.realworldhaskell.org/blog/
02:40:18 <_spm_Draget> http://rafb.net/p/yOvSFa14.html says ERROR "MGPL-Interpreter.hs":223 - Instance of Floating Int required for definition of intersects, does anyone know why it wants a floating int?
02:40:34 <quicksilver> AI barely exists: to the extent that it does exist, it's just a disparate collection of techniques
02:40:36 <Axman6> patmanpato: do you know any haskell yet?
02:40:43 <pumpkin> _spm_Draget: you in scanz' class?
02:40:46 <doserj> I guess "those people" are thinking of lisp-like languages
02:41:11 <_spm_Draget> The complete code is: http://rafb.net/p/5o9nAx30.html, the fucntion is at line 223
02:41:23 <_spm_Draget> pumpkin: I am not sure what you mean
02:41:39 <_spm_Draget> pumpkin: Ah, I think yes :P
02:41:44 <pumpkin> _spm_Draget: we had someone else in here also writing an MGPL (whatever that is) interpreter in hugs :P
02:41:46 <Axman6> is this homework?
02:41:53 <scanz> yeah^^
02:41:56 <_spm_Draget> xD
02:41:59 <Axman6> -_-
02:42:01 <soa2ii> Axman6: No... university stuff...
02:42:02 <_spm_Draget> It is trture...
02:42:08 <pumpkin> a third one!
02:42:09 <soa2ii> I'm there too :P
02:42:11 <pumpkin> they're everywhere!
02:42:13 <Axman6> still doesn't mean it's not homework :)
02:42:13 <soa2ii> :D
02:42:24 <Axman6> which uni?
02:42:30 <soa2ii> Can you hep us about that floating error?
02:42:37 <soa2ii> Axman6: Dortmund, Germany.
02:42:38 <Axman6> dortmund
02:42:49 <Axman6> /whois'd you ;)
02:43:39 <pumpkin> _spm_Draget: you're trying to use an Int as a floating point number
02:43:39 <soa2ii> Please help us ... we just have two hoers left :P
02:43:47 <soa2ii> pumpkin: Where?
02:43:55 <soa2ii> The intersects is mainly my stuff...
02:44:00 <doserj> line 293, you use sqrt
02:44:10 <soa2ii> doserj: OK... how shall I fix that?
02:44:16 * Axman6 would find it easier to help if you were using ghc
02:44:42 <Axman6> (sqrt . fromIntegral)
02:44:43 <soa2ii> Axman6: I _would_ use ghc but the code the hand out dont work with ghc...
02:44:50 <Axman6> :\
02:44:53 <pumpkin> you use fromIntegral
02:44:54 <doserj> sqrt (a*a + b*b) < d ==> a*a + b*b < d*d
02:45:02 <pumpkin> or that :)
02:45:04 <pumpkin> which is nicer
02:45:18 <Axman6> soa2ii: doserj's solution is more efficient too
02:45:22 <doserj> as long as d is positive ...
02:45:33 <Axman6> doesn't matter
02:45:37 <xci> yeah
02:45:40 <Axman6> oh, maybe it does
02:45:42 <pumpkin> or you have complex variables
02:45:58 <Axman6> yeaqh, if d's negative, that's never going to be true
02:46:22 <pumpkin> ah yeah
02:46:35 <pumpkin> alright, time for bed for me
02:46:36 <xci> yes but the right side is so the implication is wrong
02:48:13 <pingpongpat> argh, got d/c,... does anyone recommend any books/resources for learning haskell or functional programming in general, with the emphasis being towards AI ?
02:51:51 <dcoutts> C-Keen: managed to get zlib installed ok?
02:52:20 <Axman6> pumpkin: any chance 	uvector-0.1.0.3: Fast unboxed arrays with a flexible interface	Contents	Index
02:52:24 <Axman6> Data.Array.Vector	
02:52:27 <C-Keen> dcoutts: yes thanks, dev packages missing and my apt skills too old
02:52:29 <Axman6> Portability	See .cabal file
02:52:29 <Axman6> Maintainer	Don Stewart
02:52:31 <Axman6> Contents
02:52:34 <Axman6> Array classes
02:52:36 <Axman6> Streaming pure arrays
02:52:38 <Axman6> Conversions to/from lists
02:52:41 <Axman6> Basic operations on pure arrays
02:52:43 <Axman6> Introducing and eliminating UArrs
02:52:46 <Axman6> Basic interface
02:52:48 <Axman6> Transforming UArrs
02:52:51 <Axman6> Reducing UArrs (folds)
02:52:53 <Axman6> Logical operations
02:52:55 * quicksilver slaps Axman6 
02:52:56 <Axman6> Arithmetic operations
02:52:58 <Axman6> Building UArrs
02:53:01 <Axman6> Scans
02:53:03 <Axman6> Accumulating UArrs
02:53:06 <Axman6> Generating UArrs
02:53:08 <Axman6> Unfolding UArrs
02:53:10 <doserj> cut'n'paste gone wild?
02:53:11 <Axman6> Subarrays
02:53:13 <Axman6> Breaking arrays
02:53:16 --- mode: ChanServ set +o quicksilver
02:53:16 <Axman6> Searching Arrays
02:53:18 --- kick: Axman6 was kicked by quicksilver (quicksilver)
02:53:32 <quicksilver> I wasn't sure how many lines might be left
02:53:56 --- mode: quicksilver set -o quicksilver
02:54:04 <C-Keen> cats on keyboard_
02:55:11 <doserj> well, http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/Data-Array-Vector.html goes on a bit longer...
02:55:35 <Axman6> again, sorry suys!
02:55:58 <pumpkin> Axman6: what were you trying to ask ? :o
02:56:32 <Axman6> anyway... pumpkin, and chance mapU :: (UA e, UA e') => (e -> e') -> UArr e -> UArr e' could be turned into mapU :: (UA a, UA b) => (a -> b) -> UArr a -> UArr b? i dislike using x and x' in type sigs
02:56:44 <Axman6> and matches the map def better
02:56:50 <augustss> Arrg!  hoogle is down :(
02:57:25 <pumpkin> Axman6: it could be, but that was the style dons wrote it in and I didn't want to second-guess him :P
02:57:45 <pumpkin> not that confident yet
02:57:46 <Axman6> bah, go for it! he won't mind :)
02:58:20 <pumpkin> there's a trac up for the package btw
02:58:32 <Axman6> ah right, i remember seeing that
02:58:37 <pumpkin> http://trac.haskell.org/uvector/
02:59:49 <Axman6> heh, two tickets... both yours :P
03:00:01 <pumpkin> three!
03:00:38 <Axman6> oh yes, indeed
03:00:59 <pumpkin> anyway, bedtime :) ciao
03:01:10 <Axman6> pumpkin: Sarah says hi btw :P
03:01:15 <Axman6> g'night
03:01:17 <pumpkin> hi sarah! ;)
03:07:03 <Eelis> i'm trying to compile lhs2tex, and am getting the errors described here: http://www.mail-archive.com/haskell@haskell.org/msg21505.html . there's a reply saying that restricting base to <4 in the cabal file should do the trick, but changing "base < 3" to "base < 4" in lhs2tex.cabal makes no difference for me.
03:07:08 <Eelis> suggestions?
03:07:40 <dcoutts> Eelis: did you change the right bit? sounds not
03:07:52 <dcoutts> base < 3 would have been in a branch
03:08:17 <Eelis> i changed the line in lhs2tex.cabal that said "    build-depends:      base < 3, regex-compat, mtl, filepath, utf8-string"
03:08:21 <Eelis> the last line
03:09:00 <dcoutts> Eelis: but the line above says base >= 3
03:09:22 <Eelis> i figured that branch was only selected if i specified the splitBase flag somehow
03:09:33 <Eelis> should i add base < 4 there, too?
03:09:51 <dcoutts> Eelis: right, either use cabal-install which will make it work, or add base >= 3 && < 4 to the top line
03:10:44 <Eelis> dcoutts: works, thanks!
03:35:12 <andun> hoogle down? how to do haskell development now? :(
03:35:14 <augustss> dcoutts: I realized that my alloc alignment patch doesn't work.  I don't know how to fix the problem without changing the low level allocators (like C's malloc).
03:35:29 <augustss> andun: yes, it's terrible!
03:36:13 <dcoutts> augustss: I don't understand why
03:36:26 <idnar> adimit: try hayoo, perhaps
03:36:47 <augustss> dcoutts: say you get a pointer from malloc and align it.  what happens when you give that pointer to free?
03:37:10 <Workybob> @hoogle a -> b
03:37:11 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:37:11 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:37:11 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
03:37:15 <Workybob> use hoogle :)
03:37:30 <dcoutts> augustss: ah yes, we have to track the base address if we're using malloc/free (but not ghc' alloca etc)
03:38:00 <augustss> dcoutts: yes, but at the moment a Ptr is just the raw address (AFAIK)
03:38:39 <dcoutts> augustss: yes, so it'd involve changing StorableArray etc to have both pointers
03:38:53 <dcoutts> and making with* remember the base address
03:39:03 <augustss> dcoutts: yes.  Lots of changes
03:39:17 <dcoutts> augustss: well, worth noting on the ticket
03:39:27 <dcoutts> ah, you did
03:40:10 <augustss> dcoutts: for 6.10.2 I'll settle for 16 byte alignment.
03:40:15 <dcoutts> aye
03:40:41 <dcoutts> that's quite a lot though, not something we'd want to live with
03:41:21 <augustss> dcoutts: ummm, depend on how many Ptrs you allocate
03:43:29 <quicksilver> might be worth having the framework in place for sharing a single allocated block between multiple objects
03:43:40 <quicksilver> then you only store a single master pointer
03:43:45 <quicksilver> (like bytestring substrings work)
03:44:11 <dcoutts> ugg, it's really nasty
03:44:17 <SamB> I don't see how Ptrs can track the base+offset ... how would you get that back from C code ?
03:44:18 <dcoutts> and no great saving
03:44:51 <dcoutts> quicksilver: since bytestrings have to track offset and length anyway, that's what an allocator does
03:45:39 <dcoutts> bytestrings do it because it's intrinsic to the representation and for arbitrary sharing, not because we want a faster allocator
03:47:04 <fasta> andun: the wonders of the web.
03:47:58 <hugo___> hpaste is down ?!
03:48:12 <SamB> @where hpaste2
03:48:12 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
03:48:29 <hugo___> ohh :(
03:48:37 <hugo___> i really needed to access some old snippets there
03:48:38 <SamB> someone really should change the topic
03:48:48 <SamB> hugo___: oh :-(
03:49:02 <hugo___> ok, no problem
04:02:15 <scanz> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=972#a972 in line 4 i get the error "Cannot justify constraints in explicitly typed binding" but i dont find it
04:05:02 <L-Spiro> Anyone here know Ruby?  It literally takes 5 hours and 42 minutes to get an answer in #Ruby.
04:05:39 <quicksilver> scanz: among you problems is "round sqrt(...)"
04:05:50 <SamB_XP> L-Spiro: so exact a time ?
04:05:55 <quicksilver> scanz: that calls 'round' with two arguments, the first of which is 'sqrt'
04:06:02 <L-Spiro> Yes.
04:06:04 <quicksilver> scanz: you meant "round(sqrt(....))"
04:06:18 <L-Spiro> Because that is exactly how long it took to get an answer.
04:06:22 <quicksilver> L-Spiro: You'll get answwers much more quickly here.
04:06:28 <quicksilver> However, the answer will be : Don't use ruby.
04:06:30 <quicksilver> Use haskell instead.
04:06:43 <L-Spiro> Haskell can create a server?
04:06:50 <koeien> @faq can Haskell create a server?
04:06:50 <lambdabot> The answer is: Yes! Haskell can do that.
04:06:58 <L-Spiro> I didn't think so.
04:07:00 <SamB_XP> no, you have to write it yourself
04:07:05 <SamB_XP> but you can do it in Haskell
04:07:18 <SamB_XP> well, or you could use a pre-written one
04:07:42 <SamB_XP> but my point is, Haskell doesn't yet quite have the ability to write your program for you
04:07:44 <koeien> but please, I don't ask for Haskell help in #ruby either
04:07:44 <SamB_XP> not quite
04:07:52 <L-Spiro> But I am required to use Ruby.
04:08:04 <SamB_XP> ask in -blah maybe ;-P
04:08:18 <SamB_XP> #haskell-blah
04:08:29 <L-Spiro> I exchange, I will sit in #cplusplus and answer all your questions regarding C++/.
04:08:48 <SamB_XP> it's not as on-topic as sex and violence, but at least it's not Haskell, so it should be allowed there ;-P
04:09:02 <quicksilver> L-Spiro: what makes you think you know C++ better than us? ;)
04:09:06 <hugo___> :)
04:09:29 <L-Spiro> I'd rather not answer that.
04:09:37 <hugo___> oh
04:10:20 <hugo___> l-spire i have something for you, and your c++: www.fefe.de/c++/c%2B%2B-talk.pdf
04:10:24 <hugo___> go 4 it :)
04:10:58 <SamB_XP> quicksilver: apparantly the horrors of his C++ experience are too great for words
04:11:16 <quicksilver> that's not uncommon, I feel
04:11:34 <L-Spiro> SamB_XP, my experience in C++ doesn't really matter.  Anyone who talks himself up is arogent.
04:12:08 <hugo___> L-Spiro: just check the link i gave ya, and read it every night before you go to sleep
04:13:09 <L-Spiro> Why?  I don't try to point out all the downsides to Haskell nor convert you to C++/
04:13:17 <quicksilver> L-Spiro: if that's directed at me, then you misunderstood me.
04:13:24 <quicksilver> There was a smiley at the end of my comment.
04:14:07 <L-Spiro> You mean my comment about talking one's self up?
04:14:12 * quicksilver nods
04:14:34 <L-Spiro> That was my reason for not wanting to answer the question.
04:14:44 <quicksilver> fair enough.
04:14:52 <SamB_XP> oh. not because of the horrors of your experience ?
04:15:11 <SamB_XP> that's too bad. how come you didn't have horrors ?
04:15:31 <L-Spiro> Any time you set out to demonstrate that you must know something better than someone else you must invariably have to talk yourself up.
04:15:41 <L-Spiro> Which I really hate to do.
04:15:59 <L-Spiro> I don't have horrors in C/C++.  I don't know why others do?
04:16:10 <koeien> C and C++ are different languages
04:16:13 <SamB_XP> ugh! no! not C/C++, anything but that!
04:16:16 <L-Spiro> Yes.
04:16:28 <L-Spiro> And I really am not much of a fan of C, while I love C++.
04:16:43 <SamB_XP> so why'd you call them C/C++ ?
04:16:49 <SamB_XP> as if they were the same thing ?
04:17:12 <papermachine> How can you love C++ and dislike C?
04:17:22 <L-Spiro> Do I really need to explain the context of my slash?
04:17:40 <L-Spiro> papermachine, simple things are annoying in C.  For example declaring variables at the top of functions.
04:18:01 <SamB_XP> well, often when people refer to C/C++ they talk about some mythical language
04:18:03 <L-Spiro> I also do not like C functions.  I prefer organization through classes and namespaces.
04:18:26 <SamB_XP> C could definately benefit from namespaces
04:18:34 <papermachine> L-Spiro: Sorry, that was actually a rhetorical question. I already consider your taste in languages suspect; you don't need to defend it.
04:19:07 <scanz> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=972#a972
04:19:08 <scanz> Instances of (Floating Int, RealFrac Int) required for definition of evalExpr
04:19:10 <scanz> can somebody tell me whre RealFract Int comes from? Is that the output of the round funkction?
04:19:37 <quicksilver> scanz: you have not made the changes I told you about last time.
04:20:30 <scanz> i have made it but doesnt paste the new version.. one moment
04:22:18 <doserj> scanz:: RealFrac a => a is the _input_ to the round function
04:22:38 <L-Spiro> Anyway my offer for C++ help was an honest attempt at repaying people for the help I have gotten here.
04:22:47 <L-Spiro> And I am idling in ##C++.
04:23:32 <scanz> okay, the input of the round function should be int, how can i fix this?
04:24:08 <doserj> scanz: ??? why do you want to round an int?
04:24:36 <scanz> okay, you are right, the input is double
04:28:16 <scanz> a liitle part of my code, i think the error should be visibile here too
04:28:18 <scanz> False -> case (round (sqrt(((x1+w1)-x2)*((x1+w1)-x2))) <= r2) of
04:28:19 <scanz> True -> 1
04:28:21 <scanz> False -> 0
04:28:22 <scanz> x1, w1, x2, etc. are all ints
04:28:24 <scanz>         
04:32:16 <doserj> you cannot call sqrt on ints
04:32:21 <doserj> @type sqrt
04:32:23 <lambdabot> forall a. (Floating a) => a -> a
04:33:00 <scanz> okay, that means @int sqrt(x1+x2...)?
04:33:18 <doserj> you don't need to calculate square roots
04:33:49 <quicksilver> scanz: if you want sqrt your ints you're doing to have to 'upgrade' them to double first
04:33:59 <quicksilver> it's not a very elegant way to solve the problem but maybe that doesn't matter to you
04:34:09 <quicksilver> > let x = 5 :: Int in sqrt x
04:34:10 <lambdabot>       No instance for (Floating Int)
04:34:10 <lambdabot>        arising from a use of `sqrt' at <...
04:34:17 <quicksilver> > let x = 5 :: Int in sqrt (fromIntegral x)
04:34:18 <lambdabot>   2.23606797749979
04:34:30 <mornfall> What is to . as fmap is to $? :)
04:35:29 <quicksilver> (>>>) or (>=>)
04:35:45 <quicksilver> or Control.Category..
04:35:54 <mornfall> Ok. Guess I'll settle with fmap a . b
04:36:22 <mornfall> Those pointy things look arcane and dangerous. :))
04:36:34 <mornfall> But thanks anyway. :)
04:37:04 <augustss> scanz: you should define isqrt, sqrt on Int.
04:37:26 <doserj> I'm confused. what relation do fmap and $ have?
04:37:31 <augustss> scanz: isqrt = fromIntegral . sqrt . round
04:37:59 <mornfall> doserj: relate f $ g x and f `fmap` g x.
04:38:00 <doserj> augustss: other way round
04:38:06 <Workybob> mornfall: fmap is (.), not ($)
04:38:14 <augustss> doserj: yes, sorry
04:38:21 <augustss> doserj: no coffee yet :)
04:38:29 <Workybob> @src ((->) a) fmap
04:38:29 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:38:32 <Workybob> bah
04:38:47 <augustss> scanz: isqrt = round . sqrt . fromIntegral
04:38:59 <mornfall> @type ($)
04:39:01 <lambdabot> forall a b. (a -> b) -> a -> b
04:39:05 <mornfall> @type fmap
04:39:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:39:41 <augustss> If f is the identity, that's $
04:40:20 <augustss> But, alas, the identity cannot be made into a Functor in Haskell
04:40:58 <mornfall> augustss: I won't cry too much over that. Over lose sleep.
04:41:00 <mornfall> or*
04:41:18 <Cale> mornfall: hehe, what is to (.) as (.) is to ($)? :)
04:41:48 <mornfall> Cale: ... :)
04:42:47 <mornfall> And with >>=? :-)
04:44:38 <Cale> (.).(.) is, perhaps
04:44:47 <Cale> :t ($)
04:44:49 <lambdabot> forall a b. (a -> b) -> a -> b
04:44:51 <Cale> :t (.)
04:44:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:44:56 <Cale> :t (.).(.)
04:44:57 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:45:29 <mornfall> I'm wondering if use of such graphic symbols should be banned.
04:45:50 <Cale> :t fmap . fmap
04:45:52 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
04:46:28 <Cale> Specialising, that could be  (a -> b) -> f (e -> a) -> f (e -> b)
04:47:56 <Cale> So, I suppose that's a bit of an analogue
04:48:23 <Cale> That is, (fmap . fmap) is to fmap what (.) is to ($), perhaps
04:49:39 <SamB> I ... don't think so
04:49:43 <mornfall> Cale: Bingo.
04:50:03 <byorgey> what is to <*> as fmap is to filterM?
04:50:31 <SamB> I never use `fmap . fmap` to replace `fmap` on the left of another `fmap` because I wish that `fmap` had the other associativity
04:50:37 <mornfall> ((fmap . fmap) BL.unpack read) ~ \x -> BL.unpack `fmap` read x.
04:51:02 <Cale> SamB: hm?
04:51:13 <Cale> Other associativity?
04:51:30 <mornfall> I won't use fmap . fmap anyway, don't worry.
04:51:33 <SamB> I wish ($) had the other one
04:51:39 <Cale> It's associative in the only sense I can imagine...
04:52:14 <Cale> fmap f (fmap g h) = fmap (fmap f g) h, when those both make sense.
04:52:43 <mornfall> (But, what have I done??)
04:53:08 <SamB> yes, well, that was a description of my idea of what the relationship between (.) and ($) is, with fmap and (fmap . fmap) substituted in
04:53:17 <Cale> mm...
04:53:18 <SamB> and "never" added
04:53:38 <Cale> ah
04:53:46 <Cale> right :)
04:53:53 <Cale> Now it makes sense :)
04:53:53 <Wallix> how can i programm a merge sort that doesn't split a list everytime in 2 parts but in "n"-parts?
04:54:56 <Cale> I suspect it would be very similar to the one which splits into 2 parts.
04:55:22 <Cale> Only slightly more complicated...
04:55:50 <Cale> The merge would have to find which of the n lists had the least first element.
04:57:17 <Wallix> sure it would be similar but i don't get the idea
04:59:23 <Cale> Wallix: You would split the list into n equal parts, n-mergesort each of them, and then merge them by repeatedly taking the least first element of the n lists, and recursing on the set of lists with that one element removed
04:59:54 <_spm_Draget> I AM FREEE WAHHH
05:00:06 * _spm_Draget runs into freedom
05:00:48 <Wallix> "least first element", Cale?
05:01:16 <SamB> that means last ;-P
05:01:37 <SamB> actually it means the minimum list head ...
05:01:45 <augustss> Wallix: How is your 2 part merge sort structured?  You can do it in two rather different looking ways.  1) split the argument in the middle, recurse, and merge.  2) make your list into a list of singleton lists, then make passes through this list that merge adjecent pairs until there's only one element left.
05:02:26 <Wallix> 2 i think
05:03:12 <augustss> Wallix: then you just have to switch from a 2-way to an n-way merge.
05:03:37 <augustss> Wallix: and make a pass through the list a little differently, of course
05:04:28 * PeakerWork got his workplace to order "Real World Haskell". Step 1 in converting everyone :-)
05:05:07 <Cale> Wallix: yes, the minimum list head
05:07:15 <Japanac> hi, i am new to haskell. i have read every "haskell for complete c retards" on the web and still struggle with simple tasks; as reading input from user using stdin (hSetBuffering stdin LineBuffering) and storing all lines into a  list :: [String] until the user enters an empty line. i know this is fairly simple and would appreciate any help
05:07:28 <Wallix> Cale: thanks, i'll try
05:08:31 <Cale> Japanac: sure
05:08:54 <Cale> Japanac: getLine is the appropriate action to get a line of text from the user
05:09:18 <Cale> getLines = do x <- getLine; ...
05:09:27 <Cale> So we'll start by getting a line.
05:09:41 <Cale> getLines = do x <- getLine; if null x then ... else ...
05:09:49 <Japanac> i tried that , is that any different from hGetLine stdin?
05:09:53 <Cale> and we're going to do something different depending on whether that's empty
05:09:58 <Cale> It's no different.
05:10:10 <Axman6> @src getLine
05:10:11 <lambdabot> getLine = hGetLine stdin
05:10:14 <Axman6> :)
05:10:28 <Japanac> ok i came that far, but the problem is when i try to concate the list
05:10:30 <Cale> getLines = do x <- getLine; if null x then return [x] else do xs <- getLines; return (x:xs)
05:10:42 <Cale> oh, actually...
05:10:46 <Cale> getLines = do x <- getLine; if null x then return [] else do xs <- getLines; return (x:xs)
05:10:52 <Cale> is probably more like it
05:11:04 <Japanac> let me try, thanks cale :)
05:11:06 <Cale> (you don't want a blank line at the end, most likely)
05:11:07 <Axman6> yeah, thought that was a little strange
05:11:34 <Axman6> Japanac: sounds like something i could add to my IO tutorial :)
05:11:39 <bastl> i want to install a package from hackage but have missing dependencies. are there any easy tools to resolver them? (or do i have to download and install each and every on its own?)
05:11:54 <Axman6> bastl: install cabal-instal
05:11:55 <Axman6> ll*
05:12:19 <Cale> Japanac: If x is the empty string, we return the empty list of lines, otherwise, we get xs by running getLines, and return the full list (x:xs)
05:13:04 <Axman6> bastl: you're  ot working on some MGPL thing by any chance are you?
05:14:30 <bastl> Axman: MGPL? modified GPL ?
05:14:59 <Axman6> no idea, just there's been at least three other people in here tonight from dortmund asking about haskell
05:15:25 <Japanac> yay it works, thx Cale!
05:16:42 <Axman6> Japanac: the important thing is, do you understanf why it works?
05:16:46 <Twey> Homework?
05:17:01 <Axman6> d*
05:17:04 <ozy`> > 2e3
05:17:05 <lambdabot>   2000.0
05:17:07 <ozy`> > 2e
05:17:08 <lambdabot>       No instance for (Num (Expr -> a))
05:17:08 <lambdabot>        arising from the literal `2' a...
05:17:26 <Axman6> ozy`: more TM work?
05:17:37 <ozy`> Axman6: yup
05:17:41 <Axman6> :)
05:17:54 <Cale> Japanac: more importantly, does the code make sense?
05:17:54 <Japanac> yes Axman6, (head : tail) ... i understand, but i was stuck on errors of type: inferred IO [string] expecting [String].
05:18:12 <Japanac> makes perfect sense thx.
05:18:17 <Axman6> i wish i could help more, but i realy have no idea about language defs :\
05:18:19 <ozy`> looks like invalid numeric literals aren't errors... they merely get interpreted as different stuff
05:18:31 <ozy`> Axman6: don't sweat it
05:18:32 <Axman6> Japanac: well study it carfully, just to make sure :)
05:18:35 <Cale> Japanac: It's important to remember that a value of type IO [String] is not at all the same as a list of strings. It's an action which if executed will produce a list of strings.
05:18:38 <ozy`> write a compiler or two and come back :p
05:18:39 <bastl> Axman thanks for the tip ill have a look at the logs ;-)
05:18:52 <Cale> Japanac: *Evaluation* doesn't cause this execution to occur.
05:19:12 <Cale> (any more than loading the source code of a C program into a text editor would cause that program to run)
05:19:23 <Japanac> Cale, so in order to create a list of string from IO [string], what do i have to do?
05:19:26 <Axman6> ozy`: well, e is part of the SimpleReflect stuff i believe, so that's why you're getting that error
05:19:38 <Axman6> Japanac: you don't
05:19:57 <Cale> Japanac: You use do-notation to define an IO action which runs it like v <- x
05:20:04 <Cale> If x :: IO [String], then v :: [String]
05:20:22 <Cale> But then the whole do-block will have type (IO t) for some t
05:20:24 <ozy`> Axman6: yes, it's interpreting "e" as an identifier
05:20:32 <Twey> > e
05:20:32 <Axman6> once you're in IO, you have to star in IO. you can apply pure functions to the input and output, but you can't (safely) write a function f :: IO [String] -> [String]
05:20:34 <lambdabot>   e
05:20:35 <Cale> So you're gluing together smaller actions into larger ones.
05:20:49 <Cale> Eventually, you define an action called main, and it's what runs in a compiled program.
05:20:50 <ozy`> a more obvious example....
05:20:59 <Twey> Heh
05:21:18 <Twey> > exp 1
05:21:20 <lambdabot>   2.718281828459045
05:21:24 <Twey> e... :-P
05:21:24 <ozy`> > let stuff 2e = show e; stuff n e = "pizza" in stuff 2 12
05:21:26 <lambdabot>   "12"
05:22:13 <Axman6> interesting
05:22:20 <Japanac> thx Cale for the clarification. i am more closer in understanding haskell now
05:22:24 <Twey> ozy`: Remember that existing bindings can't be used in patterns...
05:22:29 <Twey> Axman6: too
05:22:42 <ozy`> Twey: ...can't they? O_o
05:22:45 <Twey> No
05:22:58 <Twey> The 'e' in 'stuff n e' is completely different to the SimpleReflect 'e'
05:23:03 <ozy`> I mean: can't you re-bind a name as a passed parameter?
05:23:09 <ozy`> oh, well yeah
05:23:15 <Twey> You can, and that's what you're doing
05:23:18 <ozy`> you meant the opposite of what I thought you meant :p
05:23:21 <Twey> Shadowing the global e
05:23:22 <Twey> Haha
05:23:53 <ozy`> shit man.... you freaked me out for a second there
05:24:14 <ozy`> I was thinking "what happens if I have a global named xs?!"
05:24:21 <Axman6> haha
05:24:26 * Twey laughs.
05:24:32 <augustss> ozy`: it would be like Java!
05:24:34 <Twey> That buggers stuff up in Erlang
05:24:43 <Twey> Java shadows, doesn't it?
05:24:46 <Twey> With a warning, though
05:25:03 <ozy`> Java warns about shadowing sometimes, but not others
05:25:08 <Saizan> ghc warns about that too, with -Wall
05:25:55 <ozy`> (in Java I eventually got to the point where I named my ivars $x, $y, etc.)
05:26:06 <ozy`> (just to confuse the hell out of whoever's reading it)
05:26:08 <BrokenClockwork> @src 'fromEnumTo
05:26:09 <lambdabot> Source not found. Wrong!  You cheating scum!
05:26:14 <Badger> heh
05:26:18 <BrokenClockwork> @src fromEnumTo
05:26:19 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:26:30 <Twey> ozy`: Haha
05:26:33 <BrokenClockwork> @src 'fromEnumTo'
05:26:34 <lambdabot> Source not found.
05:26:37 <Twey> I think convention in x_, y_
05:26:38 <Badger> @src fromToEnum
05:26:39 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:26:39 <Twey> is**
05:26:56 <BrokenClockwork> @src (@)
05:26:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:27:06 <lilac> @src Int enumFromTo
05:27:07 <lambdabot> Source not found. You type like i drive.
05:27:19 <adimit> Can someone recommend me a good Linux distribution to use on a 64bit PPC G5, with decent Haskell support (i.e. current GHC in package database)
05:27:24 <Badger>  enumFromTo x y | x > y = []
05:27:24 <Badger>                      | x == y = [y]
05:27:24 <Badger>                      | True = x : enumFromTo (succ x) y
05:27:27 <ozy`> Twey: yes, but I got sick of Java and felt like being contrary
05:27:46 <Badger> adimit: archlinux :)
05:27:51 <Thunder> BrokenClockwork: Some functions are implemented in other languages than Haskell. THose are native methods.
05:27:58 <BrokenClockwork> oh
05:28:03 <adimit> Badger: no. archlinuxppc doesn't have ghc at all.
05:28:07 <Badger> oh. :(
05:28:09 <Axman6> Badger: that puts an Ord and Eq restriction on that...
05:28:22 <adimit> I use archlinux for me x86 machines, too, so that was the first I checked.
05:28:39 <Twey> ozy`: :-P
05:28:39 <Badger> Axman6: I just grabbed it from where I remembered in being :P
05:28:42 <Twey> Arch FTW.
05:28:43 <Axman6> adimit: afaik, ghc is on;y supported on 32 bit ppc
05:28:55 <Badger> that's from the SDL bindings.
05:29:11 <Twey> BrokenClockwork: In the case of @, it's implemented in lambdabot, not in Haskell in general
05:29:12 <Axman6> adimit: you know if you can compile as 32 bit and have that work?
05:29:17 <adimit> Axman6: oh. That's bad. Well, I might also just run 32 bit.
05:29:22 <Twey> I don't think there's an @ operator
05:29:29 <Twey> > let (@) = (+) in 2 @ 3
05:29:31 <lambdabot>   <no location info>: parse error on input `@'
05:29:34 <Axman6> libraries probably won't be too happy...
05:29:34 <Twey> Oh, it's magic?
05:29:37 <Twey> What does @ do?
05:29:50 <Axman6> f xss@(x:xs)
05:29:53 <augustss> as patterns
05:29:55 <ozy`> Twey: @ is one of those reserved lexemes
05:29:55 <Twey> Oh, of course
05:30:00 <adimit> yeah 32 bit shouldn't really be a problem. The problem is that I don't want to use ghc 6.4 or so (which is included in, say Yellow Dog Linux)
05:30:04 <Twey> But it shouldn't be necessary except in patterns :-\
05:30:13 <adimit> and the last time i tried Debian on PPC, it was a nightmare.
05:30:15 <Twey> adimit: Arch has 6.10
05:30:20 <ozy`> Twey: patterns are magic.
05:30:22 <adimit> Twey: on PPC?
05:30:29 <augustss> Twey: agreed
05:30:29 <Twey> No, not on PPC
05:30:36 <Twey> You said x64 :-P
05:30:45 <bastl> Axman6: wow, cabal install rocks!
05:30:46 <Axman6> he said PPC 64 ;)
05:30:52 <Axman6> bastl: yup :)
05:30:54 <ozy`> Twey: I don't think you can define data constructors using infix operators... you can't pattern match against them
05:30:57 <Twey> Oh, damn
05:31:05 <Twey> ozy`: Can
05:31:08 <Axman6> ozy`: yes you can
05:31:09 <Twey> But only if they start with :
05:31:13 <Axman6> no
05:31:16 <adimit> Twey: nono, I'm runnng Arch on my x86 boxen, but now I have a PPC G5. Damned fine machine, it's a pity to waste it to mac os, so I'd like to put linux on it.
05:31:23 <ozy`> Twey: w...wat.
05:31:26 <Axman6> you can use x `Cons` ys
05:31:27 <Twey> Hmmm
05:31:30 * ozy` types furiously
05:31:33 <Twey> Axman6: Doesn't count :-P
05:31:37 <Twey> But yeah
05:31:38 <Axman6> sure it does!
05:31:44 * Badger typechecks furiously.
05:31:51 <bastl> does anyone know when that infrastructure hits standard ubuntu repositories?
05:32:06 <Axman6> huh?
05:32:08 <Badger> Twey: so can I see your WIP? :)
05:32:21 <adimit> Twey: by the way, the machine is currently running 64bit mode on Mac OS, with ghc 6.10 working just fine.
05:32:24 <Twey> Hmm, Fedora has 6.8
05:32:33 <Twey> IIRC that runs on PPC
05:32:46 <Axman6> adimit: OS X doesn't 'work in 64 bit mode'
05:33:04 <adimit> Axman6: huh. Well, didn't know that.
05:33:06 <Axman6> it can run both 64 and 32 bit binaries (the kernel is 32 bit)
05:33:25 <ozy`> Twey, Axman6, curse you for being right :p
05:33:25 <dublpaws> trickery afoot
05:33:26 <Twey> It emulates?
05:33:29 <adimit> ok, that might be the reason it's running fine. (if a bit slow).
05:33:31 <Axman6> it's essencially a 64 bit system, but not puerly 64 bit. your G5 will run ghc just fine
05:34:06 <Axman6> Twey: nothing emulated, both the G5 and Core 2s can run both 32 and 64 bit apps natively
05:34:06 <ozy`> adimit: the G5 will degrade gracefully to 32 bit mode while executing a 32 bit binary
05:34:16 <Twey> Badger: Cheeky
05:34:27 <adimit> ozy`, Axman6, thanks for you input. My experience with PPC is limited.
05:34:36 <Axman6> which G5 do you have?
05:35:14 <adimit> The 3.0, i.e. Powermac 7,3
05:35:24 <Axman6> which machine i mean :P
05:35:37 <Axman6> Power Mac?
05:35:43 <adimit> Power Mac, yes :-)
05:35:45 <Badger> Twey: I wouldn't dream of being cheeky :P
05:35:56 <Axman6> can't remember how our G5 iMac identifies itself
05:36:03 <Axman6> nice machine that :)
05:36:05 <adimit> The machine is rather spiffy for a three-year-old.
05:36:20 <ozy`> my computer is 4 years, seven months :(
05:36:26 <Axman6> will probably still beat a Core 2 for most intensive floating point stuff
05:36:29 <adimit> yes. That's exactly why I'd like to *use* it. But Mac OS is constantly interfering.
05:36:31 * ozy` watches it break apart as he types on it
05:36:47 <Axman6> ozy`: which machine?
05:36:58 <ozy`> adimit: ah, you're seeing the "Dude, like, stop running free software and stuff" error message?
05:37:11 <Twey> Hahahaha
05:37:30 <ozy`> Axman6: PPC albook
05:37:33 <ozy`> 1.4GHz
05:37:36 <Axman6> ohh, nice :d
05:37:38 <Axman6> :D*
05:37:39 <adimit> ozy`: essentially. X11 is a bitch, I can't use XMonad, Java is sloooooow, and OLD (as this still runs Tiger)...
05:38:03 <ozy`> adimit: so wipe it and run ubuntu
05:38:16 <Axman6> there's no Arch for PPC is there?
05:38:18 <ozy`> adimit: assuming you can deal with the whole "^W closes windows" thing, I mean
05:38:22 <ozy`> Axman6: nope
05:38:31 <Badger> Axman6: there is, but it has no ghc
05:38:31 <Axman6> shame
05:38:32 <adimit> ozy`: you can make that ^W thing go away.
05:38:51 <adimit> and make ^W behave like it was meant to behave.
05:38:56 <Axman6> adimit: what? you're not allowed to change system defaults!
05:39:05 <ozy`> adimit: yes, I've heard, but -some- programs are "smart" enough to bind it in their source code >:\
05:39:10 <adimit> Axman6: I'm every system default's nightmare.
05:39:12 <Twey> adimit: Fedora has PPC support and GHC 6.8
05:39:27 <Axman6> :'(
05:39:29 <adimit> Twey: yay. So it's either that or Ubuntu, I guess.
05:39:36 <Twey> No contest :)
05:39:48 <ozy`> (adimit: I'm still on OS X because ^W can be fixed more easily and more universally here than under linux :p)
05:40:00 <ozy`> (well, that and the fonts look a bit nicer.)
05:40:18 <adimit> ozy`: yes, but OSX has no XMonad, and will place the windows just everywhere, but not where it's supposed to.
05:40:22 * ozy` bashes gtk-gvim's head in with a hammer
05:40:30 * adimit has been with XMonad from 0.2.
05:40:31 <ozy`> adimit: patch up your .xinitrc
05:40:55 * Twey huggles emacs.
05:40:57 <ozy`> I was running xmonad for about a week... couldn't be bothered to learn the controls <.<
05:41:14 <adimit> ozy`: that doesn't help all the Aqua stuff (Firefox, Eclipse, etc.
05:41:32 <ozy`> adimit: ah, well, yeah. you're screwed there.
05:41:39 <Twey> ozy`: You can't run it for a week and not learn them :-P
05:41:55 <ozy`> Twey: I didn't work exclusively in X11 though
05:42:13 <Twey> Oh, you're monolingual huh
05:42:18 <ozy`> (in a sense, I wasn't "really" running it)
05:43:31 <ozy`> Twey: X11 is a second-class citizen under OS X
05:43:51 <Axman6> it's getting there
05:44:10 <Twey> ozy`: Oh, right.
05:44:15 <Axman6> but of course, it's going to be not as good as it could be, because it has to work with something better ;)
05:44:33 <daf> Display PDF?
05:44:41 <adimit> Yes, Aqua is rather nice, a lot more so than X11. But it's very inflexible.
05:44:53 <Axman6_> oh hooray!
05:45:54 <ozy`> Axman6_: dude don't give into peer pressure like that
05:46:00 <mstr> you mean cocoa not aqua?
05:46:18 <Axman6> no, he means aqua
05:46:34 <adimit> well, that Mac OS glitzfest, anyway. Cocoa is the toolkit, Aqua is the rendering engine.
05:46:41 <ozy`> mstr: cocoa is an API (like GTK, maybe). aqua (display PDF) is a display engine
05:46:48 <mstr> adimit: nah, it's quartz :D
05:46:53 <ozy`> (I've never used GTK, hence the engine)
05:46:58 <mstr> aqua is the theme
05:47:07 <ozy`> mstr: eh, quartz, aqua, what's the difference. :p
05:47:19 <adimit> ozy`: *actually* Aqua doesn't display PDF. It just *could* output PS with the same commands it uses to draw to the screen.
05:47:33 <bastl> can someone assist in using hscolour in  ghci ?
05:47:33 <ozy`> they're both closed source so we can't -really- see where one ends and the other begins... ;)
05:47:35 <adimit> I think NeXT used PS as a proper language for their window server.
05:47:39 <ozy`> adimit: hmmm, true
05:47:45 <bastl> i want the evaluation result to be coloured !?
05:47:49 <Axman6> bastl: in ghci? o.O
05:48:17 <malcolmw> bastl: you can simply pipe them together:  ghci | hscolour -tty
05:48:17 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
05:48:30 <ozy`> adimit: yeah they had display PS, with all the best parts of X11 and all the raging performance of... mole's asses in january
05:48:40 <malcolmw> bastl: but it does mean that you will not see what you type in ghci, until a lexical unit is completed
05:48:53 <bastl> Im experimenting with complex terms. i already have a pretty printer for haskell expressions, but its still nearly undreadable
05:49:30 <bastl> (the terms are ASTs of java files )
05:49:43 <adimit> ozy`: hehe.
05:50:10 <adimit> Well, thanks guys, Fedora it is then, since Ubuntu doesn't *oficially* support GHC. Thanks again :-)
05:50:25 <mstr> ozy`: quartz replaces display ps
05:50:57 <ozy`> mstr: I'd actually forgotten the distinction >_> but oh well :p
05:51:07 <ozy`> (between quartz and aqua, I mean)
05:51:34 <ozy`> (woulda remembered if I'd thought before typing :p)
05:51:52 * ozy` quits rambling and goes to find coffee
05:54:29 <stu8ball> I'm not a Mac user, but I think Aqua is the WM and Quartz is something to do with compositioning.
05:55:50 <Badger> quartz = compiz = aero, in loose terms?
05:56:11 <mstr> quartz compositor etc. yea
05:56:30 <mstr> quartz = directdraw? = cairo in loose terms too :)
05:57:00 <Badger> orly
05:57:13 <stu8ball> Well, Compiz is both a WM and compositor.
05:57:46 <mstr> http://en.wikipedia.org/wiki/Quartz_Compositor
05:58:39 <ozy`> stu8ball: the dock, if anything, is the WM (if it can even be said that there's a WM at all)
05:59:03 <ozy`> OS X doesn't -really- have X11
05:59:24 <stu8ball> That's something I don't really want to think about.
05:59:37 <ozy`> X11.app implements the X11 protocol on top of OS X's native graphics system
05:59:42 <ozy`> well... too bad :p
05:59:47 <stu8ball> Surely if something draws borders around windows and stuff, it's a window manager? Doesn't necessarily need to be X11 to be a WM, right?
06:00:15 <ozy`> stu8ball: the window borders aren't drawn by the "WM," but by the GUI toolkit
06:00:23 <stu8ball> Also true.
06:00:26 <stu8ball> Reparenting etc.
06:00:43 <dcoutts_> any Windows users with admin rights who can help me understand and test http://hackage.haskell.org/trac/hackage/ticket/454
06:00:44 <stu8ball> I mean xmonad doesn't do borders.
06:00:52 <dcoutts_> "file permissions of installed files on windows"
06:01:10 <ozy`> stu8ball: ...except if you run it in X11.app, it -does- do borders....
06:01:16 <ozy`> stu8ball: look, it's complicated :p
06:01:34 <stu8ball> We should all use Rio, which is simplicity itself.
06:02:27 * stu8ball :: Away
06:02:47 <mstr> that's so quakenet :(
06:14:55 <maltem> Ahh. I'm entering #haskell, and it is comfortably quiet here. Just as it used to be in the good ol' times.
06:15:29 <Zao> The robot monkey operators consumed all the loud ones.
06:16:14 <jeffz`> dcoutts_: at a glance, I don't see the issue on win2k8, I've installed a random program from hackage as admin and it has read and execute set for users
06:17:43 <jeffz`> dcoutts_: cabal 1.6.0.1 and ghc 6.10.1
06:18:23 <dayzman> hi
06:19:13 <dayzman> with the conventional notation, is x usually an element and xs usually a list?
06:19:45 <dcoutts_> jeffz`: and the non-executable files also have ok permissions?
06:20:15 <dcoutts_> jeffz`: adding your findings to the ticket would be helpful, I'm trying to get a picture of where we have problems exactly.
06:20:31 <hackage> Uploaded to hackage: Wired 0.2
06:20:37 <jeffz`> dcoutts_: ok, the package I installed was Encode, looking at its LICENSE file, it has read and execute for users too, so no problem there
06:20:57 <Axman6> dayzman: that;s the convention yes, though you can also use f x = ...
06:21:03 <Axman6> with x not being a list...
06:21:19 <dcoutts_> jeffz`: you mean cygwin/msys ls says it has execute permission, I don't think windows has that notion really
06:21:48 <jeffz`> dcoutts_: nope, right click properties.. security, users, the pane shows that users have read and execute
06:21:52 <Gracenotes> dayzman: yep. (x:xs)
06:22:05 <dcoutts_> jeffz`: hmm ok, and admin has write I presume.
06:22:18 <jeffz`> dcoutts_: yeah
06:22:21 <Gracenotes> most often with lists of a polymorphic type, it seems
06:22:23 <dayzman> i see. thanks
06:22:24 <dcoutts_> jeffz`: thanks
06:38:35 <bastl> i want to apply a list of functions to all the same argument of type (a,a) and get a list of results. Can neone help ?
06:39:01 <koeien> bastl: map ($(x,y)) [f1,...,fn]
06:39:24 <bastl> what is $(x,y) ??
06:39:42 <koeien> bastl: it's a section. do you know that (+2) is a function?
06:39:47 <bastl> y
06:40:08 <koeien> bastl: you can do that with any operator. in this case the `$' function. the definition of $ is in fact very simple
06:40:12 <koeien> it's function application
06:40:14 <BONUS> > inc $ 3
06:40:14 <koeien> @src ($)
06:40:15 <lambdabot> f $ x = f x
06:40:15 <lambdabot>   Not in scope: `inc'
06:40:19 <BONUS> uh
06:40:22 <BONUS> > succ $ 3
06:40:24 <lambdabot>   4
06:40:38 <RayNbow> > (sequence [(*3), succ, negate]) 2
06:40:39 <bastl> gotta think about that :-)
06:40:40 <koeien> bastl: you could also write,   map (\f -> f (x, y)) [f1,...,fn]
06:40:40 <lambdabot>   [6,3,-2]
06:40:46 <BONUS> yeah
06:40:52 <BONUS> or map (flip id (x,y))
06:41:08 <bastl> dear, now you are confusing me :-)
06:41:09 <koeien> magic! i strongly prefer the section with ($)
06:41:24 <koeien> instead of 'flip id'
06:41:24 <BONUS> haha sorry, but yeah, the section with $ is prefered
06:41:36 <BONUS> basically just like you have 3 + 2 and f $ x
06:41:43 <BONUS> you can have (+ 2) and ($ x)
06:41:53 <BONUS> in which case the section just takes what's supposed to be on the left side
06:42:02 <BONUS> in the case of (+2) it's a number that's supposed to be on the left side
06:42:19 <BONUS> and in the case if ($ (x,y)), there's a function that's supposed to be on the left side
06:42:33 <RayNbow> BONUS: instead of (flip id x), you could also use (`id` x)... it saves a few keystrokes ;)
06:42:46 <bastl> BONUS: ah, thanks. that makes sense
06:42:50 <BONUS> cool, i never thought of doing that
06:43:26 <koeien> sickos :-)
06:43:28 <BONUS> > map ($ 3) [(+1),(+2),(+3)]
06:43:30 <lambdabot>   [4,5,6]
06:43:55 <BONUS> @pl \f -> f 3 2
06:43:56 <lambdabot> flip ($ 3) 2
06:44:36 <RayNbow> > sequence [f,g,h] x :: [Expr]
06:44:38 <lambdabot>   [f x,g x,h x]
06:45:35 <BONUS> > sequence [fst, snd] (1,2)
06:45:37 <lambdabot>   [1,2]
06:46:11 <RayNbow> monad magic :p
06:50:33 * Badger badgers BONUS for LYAH :P
06:50:46 <BONUS> haha wish i could do LYAH now :[
06:50:57 <BONUS> school work mounting up and i'm procrastrinating as we speak
06:51:03 <BONUS> should rly get back to work ughhgh
06:51:05 <Badger> d'oh :(
06:51:18 <BONUS> but expect a lot of new content in february! :]
06:51:33 * Badger anticipates eagerly.
06:51:40 <BONUS> w00t
06:53:57 <dormoose> :t map (++) ["aeu", "13"]
06:53:58 <lambdabot> [[Char] -> [Char]]
06:54:01 <dormoose> -- why is that type so weird?
06:54:38 <Saizan> map (++) ["aeu", "13"] == [("aeu"++),("13"++)]
06:54:52 <Zao> A list of functions from strings to strings.
06:55:16 <dormoose> oh my. How do I join strings then? unlines is something like what I need
06:55:23 <Saizan> > foldr (++) [] ["aeu", "13"] -- you wanted this then
06:55:25 <lambdabot>   "aeu13"
06:55:27 <dormoose> \o/
06:55:31 <Saizan> or just concat
06:55:34 <Zao> @type concat
06:55:35 <lambdabot> forall a. [[a]] -> [a]
06:55:38 <Saizan> > concat ["aeu", "13"]
06:55:40 <Zao> @type concatMap
06:55:41 <lambdabot>   "aeu13"
06:55:42 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:00:29 <chessguy_work> 'mornin
07:01:35 <chessguy_work> > [1,2,3] >>= (:[])
07:01:36 <lambdabot>   [1,2,3]
07:07:33 <bastl> has anyone already played with "hint" ?
07:09:51 <ozy`> http://www.rsmw.net/ergo/windowsystems.png <== in case the topic ever comes up ever again
07:10:48 <Cale> bastl: I have
07:12:17 <chessguy_work> hm, you know what would be cool? an online IDE. something you could actually code in from anywhere
07:12:22 <bastl> Cale: problem solved already ...
07:13:33 <chessguy_work> it could code the same subset of the language as LB, but slightly more permanent
07:14:11 <chessguy_work> sort of a cross between LB and hpaste
07:14:40 <Cale> chessguy_work: have you seen that pastebin which executes the pastes in a controlled environment in a bunch of languages?
07:14:48 <chessguy_work> hm, no
07:14:55 <Cale> It was written in Haskell...
07:15:06 <kiris> what was it's name?
07:15:21 <Cale> I'm just seeing if I remember correctly
07:15:21 <kiris> its
07:15:35 <Cale> Perhaps codepad.org?
07:16:15 <Cale> yep
07:16:19 <Cale> that was it :)
07:16:32 <chessguy_work> nice
07:16:33 <chessguy_work> http://codepad.org/AYAdSikj
07:16:38 <chessguy_work> it even does IO
07:17:01 <Gracenotes> ooh, scary :3
07:17:16 <byorgey> how about an online, *collaborative* IDE? =D
07:17:37 <koeien> byorgey: i've thought about that as well
07:17:39 <Gracenotes> but I assume the environment itself is controlled by means outside of the language itself..?
07:17:45 <Cale> yeah
07:18:14 <kiris> byorgey: an online collaborative IDE which can be edited at run time :P
07:18:21 <byorgey> hehehe
07:18:40 <chessguy_work> allows types, too
07:18:42 <chessguy_work> http://codepad.org/DBekKF0Z
07:18:57 <byorgey> we'll just make a dead simple version to start, and then bootstrap it by coding it using itself =)
07:19:11 <chessguy_work> byorgey, i dunno, this looks pretty collaborative already
07:19:24 <byorgey> chessguy_work: what does? codepad.org?
07:19:27 <chessguy_work> ya
07:19:43 <byorgey> nah, I mean collaborative in the sense of SubEthaEdit, or Gobby
07:19:51 <byorgey> like, multiple people can actually be typing stuff at the same time
07:19:58 <chessguy_work> oh, ok
07:20:04 <gwern> ah, the old 'let's do a gobby!' idea
07:20:24 * quicksilver has done that in emacs from time to time
07:20:24 <gwern> (some haskeller will code that up eventually... probably as some yi extensions)
07:20:35 <quicksilver> not for much serious work though
07:21:28 <kiris> yeah, emacsclient makes that possible
07:21:44 <kiris> although it doesn't show where people are currently at so it's not as good as gobby
07:21:44 <koeien> i like the idea
07:21:48 <chessguy_work> man, i wish i had had this yesterday when i was @let'ing half my code :)
07:21:51 <koeien> integrated version control
07:22:08 <koeien> easy im- and exporting using git/darcs/whatever
07:22:50 <koeien> but i don't know whether it's a _good_ idea
07:22:53 <chessguy_work> geez, even allows imports: http://codepad.org/nPfx1AXp
07:23:18 <koeien> does this thing run arbitrary C code?
07:23:43 <chessguy_work> http://codepad.org/about
07:23:52 <koeien> ok
07:24:01 <kiris> Cale: are you sure codepad was written in haskell? runs on a Python framework called Pylons
07:24:07 <koeien> ah, ic
07:24:15 <gwern> oh wow, I didn't realize codepad was even still running
07:24:15 <koeien> the /about page says "Python"
07:24:17 <Cale> kiris: Perhaps I misheard.
07:24:18 <chessguy_work> hm, apparently only -98
07:24:27 <gwern> (we hear so little from the geordi guys it's easy to forget them)
07:24:48 <Cale> kiris: It was a while back that I was told about it. The author apparently does use Haskell for some things, anyway.
07:24:50 <kiris> ahhh
07:24:53 <kiris> Code execution is handled by a supervisor based on geordi. The strategy is to run everything under ptrace, with many system calls disallowed or ignored. Compilers and final executables are both executed in a chroot jail, with strict resource limits. The supervisor is written in Haskell.
07:25:01 <Cale> aha
07:25:15 <koeien> ahw! that's the part written in Haskell then; the front-end is python
07:25:46 <chessguy_work> wow, the "raw code" link even lets you just download your code into a ".hs" file
07:25:49 <chessguy_work> this thing rocks
07:26:14 <gwern> geordi was written in haskell, but I remember looking it over when I was coding mueval and thinking it was very strange
07:27:20 <kiris> geordi - C++ eval bot
07:27:28 <kiris> geordi was re-implemented in haskell or something?
07:27:32 <gwern> (not that trying to safely eval c++ isn't a strange thing to begin with)
07:27:44 <kiris> oh
07:28:17 <gwern> reimplemented? I think it was always in haskell
07:28:40 <gwern> (although it is a mix of languages so it's a little confusing)
07:29:02 <kiris> sorry, I misread "C++ eval bot" as "an eval bot written in C++" and not "a bot which evaluates C++".. ¬_¬
07:29:45 <chessguy_work> this thing pretty much obsoletes hpaste2
07:30:08 <chessguy_work> @where+ codepad codepad.org
07:30:08 <lambdabot> Done.
07:30:46 <gwern> chessguy_work: harsh man. what's stopping hpaste2 from calling mueval on paste contents?
07:31:05 <chessguy_work> nothing. except that it doesn't....
07:31:19 <sw17ch> So, say I wrote a VPN application... what would be the best part of it to start writing about?
07:31:21 <gwern> so file a feature request with the maintainer
07:31:34 * sw17ch is trying to foster a community aroudn his toy
07:31:37 <Cale> codepad does more than mueval though.
07:31:54 <Cale> It compiles the entire paste as a program and executes it.
07:31:54 <dublpaws> The function I'm debugging consumes all memory, don't know if it is recursing infinitely or if I'm just "doing it wrong".  The debugger isn't much help, because when peeking at a value requires :force ghci spins off forever.
07:32:08 <Cale> (not just evaluating expressions)
07:32:16 <gwern> Cale: mm. good point.
07:32:32 <gwern> might be able to do something with --load-file...
07:32:43 <Gracenotes> I rented a VPS so that I could use IRC in my university... but turns out my university blocks said VPS service :(
07:33:32 <dublpaws> Gracenotes: tty.freeshell.org, ssh you@yourvps;
07:33:32 <gwern> Gracenotes: sbu has quite an arsey IT department doesn't it?
07:33:34 <Cale> dublpaws: Probably best to avoid the debugger. Better to just try to understand the function that you've written better.
07:33:56 <Cale> dublpaws: perhaps you could paste it?
07:34:01 <gwern> Gracenotes: fwiw, SDF only charges 1$ for a basic account, although I forget if that includes an irc client
07:34:04 <Gracenotes> I can't even ssh into it
07:34:27 <Gracenotes> then again, it might be a problem with my configuration
07:34:42 * Gracenotes should e-mail the service
07:34:54 <gwern> sbu can't be blocking ssh as well... there's no way they could get away with that
07:35:14 <Gracenotes> "No IRC without membership fee"... hm, sounds reasonable
07:35:48 <dublpaws> http://dpaste.com/113148/
07:35:57 <Axman6> Gracenotes: i'd give you an account on my server if you wanted
07:35:59 <dublpaws> Cale: ^^
07:36:12 <Axman6> the connection's not great, but it's fine for IRC
07:36:25 <Cale> dublpaws: okay... looking...
07:37:04 <Gracenotes> IRC is all I need it for :) I already have a few other shell accounts, but none allow use as tunnels.
07:37:18 <Axman6> Gracenotes: mine would :)
07:38:03 <CosmicRay> stupid hugs.
07:38:10 <CosmicRay> ERROR "/usr/lib/hugs/packages/QuickCheck/Test/QuickCheck/Utils.hs":27 - Ambiguous class occurrence "Testable"
07:38:10 <CosmicRay> *** Could refer to: Test.QuickCheck.Testable Test.HUnit.Base.Testable
07:38:36 <fasta> stupid ghc ;)
07:38:41 <CosmicRay> so I apparently cannot run "import qualified" both HUnit and QuickCheck in a single file
07:39:04 <CosmicRay> fasta: GHC at least would tell me which of my source files caused the problem!
07:39:29 <Twey> CosmicRay: Apparently you didn't use 'qualified'
07:39:39 <fasta> When I define an incorrect type synonym (I refactored a bit), I get that the original type definition is wrong.
07:39:40 <CosmicRay> Twey: ah, but I did.
07:39:42 <Twey> Wait, *in* QuickCheck?
07:39:45 <Twey> o.@
07:39:48 <Cale> dublpaws: There are a number of troubling things about the way this is written...
07:40:07 <fasta> It should have said something like incorrect application of type foo at line (line of type synonym).
07:40:08 <dublpaws> I figured :D
07:40:09 <CosmicRay> Twey: I import qualified several modules in here.  some of them import one or the other (not qualified).
07:40:15 <Axman6> CosmicRay: are you importing HUnit and QuickCheck?
07:40:19 <Twey> Shouldn't have anything to do with it...
07:40:22 <Cale> dublpaws: The first thing which jumps out at me is the way that acc is used
07:40:30 <CosmicRay> Axman6: yes, but qualified.
07:40:36 <Cale> dublpaws: Appending to the end of a list repeatedly is bad
07:40:37 <Axman6> hmm
07:40:40 <CosmicRay> Twey: I agree.  Hence "stupid Hugs". ;-)
07:40:44 <fasta> CosmicRay: but... I didn't know Hugs had still users? ;)
07:40:45 <Twey> What you import in your file shouldn't have any effect on what happens in Utils.hs
07:40:49 <Twey> Mmm :-\
07:40:52 <Twey> Haha, fasta
07:40:53 <fasta> Hugs is fast, but limited.
07:40:56 <Cale> dublpaws: this is because xs ++ ys takes O(length xs) time to fully evaluate
07:41:04 <CosmicRay> fasta: I have been wondering this too, of late.
07:41:05 <Cale> dublpaws: So doing it repeatedly is quadratic.
07:41:26 <dublpaws> 10-4
07:41:29 <Gracenotes> Axman6: that would be useful, thanks... I'm still having a bit of trouble logging in to the VPS I got :/
07:41:52 <Axman6> Gracenotes: so you want an account?
07:41:54 <dublpaws> Thanks Cale, I'll rethink it.
07:42:02 <Cale> dublpaws: The next thing is the use of 'head', which is worrying on its own -- what if 'rest' is empty?
07:42:14 <Gracenotes> yes, please :)
07:42:18 <Cale> dublpaws: What's a case on which it loops forever?
07:42:53 <dublpaws> if the predicates don't match and the list stays the same size.
07:43:14 <Cale> dublpaws: well, okay :)
07:43:21 <Cale> dublpaws: What is this actually meant to do?
07:43:57 <dublpaws> "aa1bbb22222c33" --> ["aa1", "bbb2", "c3"]
07:44:15 <chessguy_work> gwern, what's the point of trying to replicate something that already works?
07:44:18 <dublpaws> that's the idea, but the Chars are Strings in the real case
07:44:37 <Twey> group would be useful...
07:44:49 <Cale> Or at least splitAt
07:44:52 <Cale> er
07:44:55 <Cale> span rather :)
07:44:59 <Twey> Mmm
07:45:09 <Cale> hmm
07:45:22 <bastl> Cale: concerning hint: I would like to use things from Main (e.g. commandline parameters) in a module Id like to interpret. any idea whether thats possible ?
07:45:51 <dublpaws> consume strings containing only alphas, take the next string which contains digits, drop the rest of the digits; wash, rinse, repeat.
07:46:06 <Cale> > groupBy (\x y -> isAlpha x == isAlpha y) "aa1bbb22222c33"
07:46:08 <lambdabot>   ["aa","1","bbb","22222","c","33"]
07:46:14 <gwern> chessguy_work: it's not on hackage
07:46:22 <chessguy_work> huh?
07:46:24 * dublpaws meditates
07:46:34 <Twey> Aye
07:46:37 <Twey> Ooh
07:46:39 <Twey> A fold?
07:46:39 <chessguy_work> you mean codepad?
07:46:58 <gwern> bastl: why not? 'args <- getArgs; eval (head args)' is perfectly sensible and it doesn't change if you pass head args to a function in another module which calls eval on it
07:47:47 <chessguy_work> @pl \x y -> i x == i y
07:47:47 <lambdabot> (. i) . (==) . i
07:48:07 <quicksilver> chessguy_work: (==) `on` i
07:48:17 <chessguy_work> yeah
07:48:18 <Eelis> can lambdabot be taught about `on` ?
07:48:19 <Twey> f x = map headLetters . groupBy ((==) `on` isAlpha) where headDigits ys@(y:_) = if isDigit y then [y] else ys
07:48:23 <Twey> Something like that?
07:48:25 <gwern> @hoogle on
07:48:25 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
07:48:25 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
07:48:25 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
07:48:28 <Twey> :t on
07:48:30 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:48:33 <chessguy_work> Eelis, yeah, @pl is just a bunch of re-write rules
07:48:34 <bastl> gwern: thats right
07:48:34 <Twey> She knows about on...
07:48:37 <quicksilver> Eelis: no living mind can comprehend the evil that is @pl
07:48:38 <Twey> Oh, for @pl
07:48:42 <Twey> Hahaha
07:48:42 <chessguy_work> Twey, @pl deosn't
07:48:46 <Eelis> chessguy_work: neat :)
07:48:56 <Eelis> quicksilver: hm, that is unfortunate
07:49:18 <gwern> Eelis: mueval knows on, but I can't vouch for any of the other tools
07:50:17 <quicksilver> he's talking about @pl.
07:51:27 <gwern> quicksilver: hence my qualification
07:54:46 <harovali> are people out there using "applicative functors" ? can anyone comment ?
07:54:56 <quicksilver> of cours.
07:55:04 <quicksilver> all monads are applicative functors
07:55:08 <quicksilver> and mondas are pretty useful.
07:55:14 <quicksilver> so we use applicative functors every day.
07:55:15 <athos> :D
07:55:17 <harovali> yes
07:55:20 <Axman6> bah, who needs monads!
07:55:38 <Axman6> mathematical research nonsense!
07:55:45 <koeien> who needs monads when we have arrows? :)
07:55:57 <fasta> We will never know omega anyway, what's the point? ;)
07:56:18 <harovali> fasta: what does it mean?
07:57:38 <fasta> harovali: http://en.wikipedia.org/wiki/Chaitin%27s_constant
07:57:49 <Thunder> Monads are the easy way to convert a pure functional programm into FORTRAN spaghetti code.
07:58:02 <koeien> especially the Continuation monad :)
07:58:28 <chessguy_work> now WarmFuzzyThings, _those_ are useful!
07:58:29 <arw> FORTRAN is not spaghetti. there are line numbers!
07:58:30 <arw> :>
07:58:57 <quicksilver> harovali: you are not getting very serious answers, but your question was not very well formed.
07:59:06 <quicksilver> harovali: can you be more specific about what you'd like to know?
07:59:09 <Thunder> Strictness annotations, do notation and the State monad are the road to the C-hell
07:59:14 <CosmicRay> yay hugs de-crapified.
07:59:17 <quicksilver> Have you read the applicative paper?
07:59:17 <koeien> no
07:59:30 <fasta> CosmicRay: what did you do?
07:59:31 <koeien> Thunder: the State monad used locally is fine
07:59:46 <koeien> with not "too much" state
07:59:51 <quicksilver> Thunder: the State monad is just a convenient way to construct and compose functions (s -> (a,s))
07:59:55 <CosmicRay> fasta: tweaked some imports.  it was an unhelpful error.
08:00:01 <quicksilver> it's a very natural - and extremely functional - notion.
08:00:13 <koeien> quicksilver: agreed
08:00:15 <fasta> CosmicRay: oh. I thought it was _impossible_ ;) Lucky you!
08:00:22 <CosmicRay> fasta: indeed ;-)
08:00:38 <koeien> you should not use the state monad for everything of course
08:00:38 <Thunder> koeien: No, the State monad is misused to implement old-fashioned imperative algorithms in Haskell
08:00:51 <Badger> huzzah!
08:00:57 <quicksilver> Thunder: That's unlikely.
08:00:57 <koeien> Thunder: I don't necessarily disapprove of that
08:01:04 <quicksilver> the ST monad or the IO monad would be more likely things to do that in.
08:01:05 <harovali> quicksilver: the answers are ok for me now, thanks
08:01:17 <Thunder> quicksilver: Hackage prove me correct.
08:01:28 <Axman6> Thunder: that sounds a lot more like the ST monad to me
08:01:33 <quicksilver> Thunder: I disagree.
08:01:36 <quicksilver> forcefully.
08:01:36 <Axman6> State is for passing state around
08:01:39 <kiris> I think it's about time I learned about ST
08:01:48 <Thunder> Ok, ST ist besser to rant about
08:01:58 <fasta> Oh, it seems Omega isn't cool anymore, it's Super Omega nowadays.
08:02:00 <Axman6> ST is lovely
08:02:06 <koeien> there is nothing wrong with the IO monad. there is something wrong with overusing it
08:02:21 <kiris> I now know one fact about ST; that it is lovely :P
08:02:45 <Axman6> kiris: it lets you make stateful computations, in a pure way
08:03:06 <kiris> more stateful than the State monad?
08:03:16 <Axman6> yes
08:03:19 <kiris> how?
08:03:22 <koeien> it's less explicit about the state that is passed around
08:03:24 <Axman6> you get mutable state variables
08:03:31 <Axman6> actual mutable state
08:03:38 <kiris> real first-class values?
08:03:40 <Axman6> like IORefs, but they're STRefs
08:03:42 <tromp__> it lets you use arrays
08:03:43 <Thunder> Axman6: Exactly. The wrong way.
08:03:44 <kiris> ah
08:04:03 <koeien> whereas State makes explicit what the type of the state is
08:04:06 <Axman6> Thunder: huh?
08:04:28 <kiris> why might I want to use the ST monad?
08:04:52 <tromp__> to use arrays as your state
08:05:01 <Axman6> kiris: you can do efficient array ops, with in place update
08:05:02 <tromp__> like a transposition table in game tree search
08:05:13 <quicksilver> there are two (entirely distinct) reasons to use ST
08:05:32 <quicksilver> one is to get a type-safe heap from which you can allocate any number of references
08:05:45 <quicksilver> (which is a bit like Map String Dynamic, but much more type safe)
08:05:49 <quicksilver> that's the STRef part.
08:06:00 <Thunder> Axman6: Algorithms which needs updateable variables comes from imperative coding. Haskell prefers functional algorithms. If more and more users start to code their old-fashioned programms in Haskell, Haskell will become more and more an imperative language.
08:06:09 <quicksilver> the other is to do array computations which are implemented reasonably efficiently behind the scenes.
08:06:15 <quicksilver> using mutable update and so on.
08:06:30 <fasta> Thunder: that only works when there exist functional versions to begin with.
08:06:37 <koeien> Thunder: of course, but sometimes you need fast performance. I don't see what is wrong to run the ST monad locally
08:06:47 <Thunder> If you need an prominent example: Look at Bytestrings.
08:06:48 <kiris> I see
08:06:52 <Axman6> Thunder: i disagree. things like ST are pure, and let you do things that are not always possible or efficient without mutable state
08:07:19 <koeien> Thunder: i prefer using ST & taking an algorithm out of a book instead of thinking too much
08:07:37 <Thunder> koeien: You can't beat the C by trying to code in the same manner.
08:07:39 <koeien> if there is no reasonable functional implementation
08:07:55 <tromp__> there's no functional alternative to transposition tables
08:08:21 <koeien> Thunder: no, I can't. can you by coding functional? fine, good for you; in that case you are right. but it's not always possible or reasonable
08:08:25 <Axman6> Thunder: you try and make an efficient puerly functional version of the shootout's n-bodies program in haskell, that doesn't use hundreds of megs of ram
08:08:31 <bastl> where can i find up-to-date haddock docs of package hint ? i only find old docs ...
08:09:10 <quicksilver> Thunder: you consider bytestrings to be an example of what?
08:09:21 <Axman6> aren't bytestrings pure?
08:09:22 <Thunder> *hualp* Exactly: Nobody is looking for an efficient functional alternative. Nobody is looking for the reasons of performance problems. "Make it strict, put it into ST or IO, feel good."
08:09:47 <quicksilver> Loads of people are looking into the reasons for the performance problems.
08:09:55 <quicksilver> It is a topic of discussion here every day.
08:09:56 <koeien> Thunder: that is not true
08:10:00 <quicksilver> and on the mailing list most days.
08:10:00 <Axman6> what's wrong with ST? it is pure, it is functional.
08:10:02 <pejo> Thunder, most of the *reasons* for Haskell performing badly are known.
08:10:19 <quicksilver> strictness is a whole other discussion to imperative programming, too.
08:10:37 <quicksilver> correct strictness is quite simply *necessary* for a lazy language to perform acceptably.
08:10:54 <quicksilver> what we can hope for - and we do - is that the compiler to get it correct on its own more often.
08:11:04 <koeien> yep. you can improve the strictness analyser of the compiler
08:11:04 <Thunder> quicksilver: Bytestrings are the surrender of Read/Show developments
08:11:19 <quicksilver> Thunder: can you explain that in a different way?
08:11:26 <quicksilver> (I'm not sure what you're saying here)
08:11:29 <koeien> there is nothing wrong with Read/Show; only the implementation of GHC
08:12:22 <Axman6> Thunder: you know bytestrings being huge performance benefits without mugh, if any, extra effort at all right?
08:12:28 <Axman6> much*
08:12:38 <fasta> He probably means that ByteString is an "easy" way out, since from an information point of view bytestrings don't have any benefit.
08:13:13 <fasta> He probably wants that the compiler transforms the Strings to ByteStrings where possible.
08:13:37 <Thunder> quicksilver: Instead of developing algorithms which work in constant space (lazily) to deal with large amount of data, the data is handled in a way like assembler. I call it a capitulation.
08:14:00 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=973#a973 Can anyone tell me what's so inefficient about this implementation?
08:14:02 <koeien> the compiler is not some god you can invoke to magically optimize everything under the sun
08:14:18 <fasta> koeien: actually, one can make such a compiler.
08:14:27 <quicksilver> Thunder: bytestrings don't seem much like assembler to me
08:14:33 <fasta> koeien: in less lines of code than GHC, it will just be slow.
08:14:46 <Thunder> So we have a different point of view.
08:14:49 <quicksilver> Thunder: bytestrings let you write "length . lines <$> getContents"
08:14:52 <arw> fasta: compiler guys tell that all the time.
08:14:53 <koeien> fasta: *very* slow :-)
08:15:03 <quicksilver> and get a "wc -l" program which runs more or less as faast as the C one
08:15:07 <quicksilver> how is that "like assembler"?
08:15:24 <quicksilver> an assembler implementation of wc -l would be hundreds of lines, I expect.
08:15:51 <Thunder> quicksilver: The Bytestring library is tightly coupled with the implementation of the compiler.
08:15:59 <quicksilver> sure.
08:16:15 <fasta> Thunder: because computers are not infinitely fast.
08:16:17 <quicksilver> I'm not sure what point you're making here, though?
08:16:30 <quicksilver> the ByteString library is a compiler extension, in a sense
08:16:37 <fasta> Thunder: the less it is coupled, the more work the compiler needs to do.
08:16:38 <quicksilver> it teachs the compiler some new optimisation rules
08:16:40 <koeien> fasta: were you referring to the 'compiler writer employment theorem'?
08:16:45 <quicksilver> that's clever stuff, IMO.
08:16:51 <Thunder> We can mask every "bad code" by a library and "do not think about" anymore. But wrapping does not solve the problem.
08:16:53 <fasta> koeien: no
08:17:30 <kiris> the examples on the shootout are kind of horrid to look at for someone who spends most of their time in pure-land shaped around actions. it's sad on the one hand that to be fast haskell basically resorts to C-like code but on the other it's nice that one can write fast imperative code under the hood and use that in a high level way, like ByteString and so on
08:17:33 <scook0> the turtles have to stand on something
08:17:44 <quicksilver> Thunder: how would you solve the problem, for example?
08:18:01 <koeien> fasta: i fail to see, in that case, that you could write a faster-than-GHC optimizing compiler in less lines of code. could you provide a reference for me to look at?
08:18:14 * koeien is interested in this stuff
08:18:20 <Thunder> kiris: The shootout rules were changed, because haskell and other lazy programming languages are too fast for the imperative guild.
08:18:31 <fasta> koeien: faster than GHC? I didn't say that.
08:18:46 <koeien> fasta: ok. "such a compiler" was referring to... ?
08:18:51 <kiris> Thunder: I'm quite sure that is lies, a joke or lies about the "too fast" stuff. can you elaborate?
08:19:05 <fasta> koeien: the code it generates will be faster, but otherwise it will be a lot slower.
08:19:17 <quicksilver> the shootout guys did change some rules in what seems externally to have been a slightly arbitrary fashion.
08:19:25 <quicksilver> But haskell wasn't in any danger of winning, even so :)
08:19:35 <koeien> kiris: it was just that .     do { let x = expensiveComputation; return () }    is very fast in Haskell :)
08:19:47 <koeien> iirc
08:20:01 <Thunder> quicksilver: There was an article from the shootout maintainer some weeks ago in haskell-cafe.
08:20:02 <kiris> but that wouldn't give any result anyway, do you have a better example?
08:20:26 <quicksilver> there was a bunch of stuff
08:20:28 <tromp__> it wld in the IO monad, as part of main
08:20:29 <kiris> koeien: you're basically saying "return ()" is fast in haskell
08:20:33 <quicksilver> where tweaking GC options was considered cheating
08:20:39 <koeien> kiris: yes :) indeed.
08:20:43 <quicksilver> or laziness was avoiding part of a computation which was 'supposed' to be done
08:20:54 <quicksilver> even though it didn't technically contribute to the result
08:21:04 <quicksilver> but such problems inevitably plague benchmark suites
08:21:17 <koeien> yeah, it's not "fair". but they don't claim that as well
08:21:55 <vixey> @go Foundations for Structured Programming with GADTs
08:21:59 <lambdabot> http://crab.rutgers.edu/~pjohann/popl08.pdf
08:21:59 <lambdabot> Title: Foundations for Structured Programming with GADTs
08:22:53 <dublpaws> haskell organizes the hurt.
08:23:08 <kiris> http://shootout.alioth.debian.org/u32/benchmark.php?test=binarytrees&lang=ghc&id=1
08:23:15 <kiris> that's nice code
08:24:04 <kiris> http://shootout.alioth.debian.org/u32/benchmark.php?test=fannkuch&lang=ghc&id=5
08:24:10 <kiris> that's, uh, I have no idea
08:24:25 <kiris> "translation from the C version
08:24:28 <kiris> ya think?
08:24:34 <BMeph> IO should me a class of its own, with types in it corresponding to IO-compatible stuff (including I/O).
08:24:38 <BMeph> *be
08:24:57 <fasta> koeien: one related issue is that a compiler which takes 20 years to optimize something is considered slow, but a compiler engineer who took 20 years to learn his craft is considered brilliant.
08:25:21 <Thunder> quicksilver: To anwer your question about my solution: I do not have a good one, I'm looking for real functional algorithms for myself (at the moment).
08:25:25 <kiris> BMeph: you mean like "I'm in the IORef monad now"? or "I'm in the file IO monad now"?
08:25:55 <CosmicRay> BMeph: http://software.complete.org/static/missingh/doc//MissingH/System-IO-HVIO.html
08:25:58 <quicksilver> Thunder: you don't implement addition yourself, but you trust that (+) gets compiled to an efficient operation
08:26:08 <fasta> Thunder: so, you are saying: we should all jump from this plane, but I am still thinking about the parachutes?
08:26:08 <CosmicRay> BMeph: also http://software.complete.org/static/missingh/doc//MissingH/System-IO-HVFS.html
08:26:19 <roconnor> I wish I could cairo clip to allow drawing only outside the fill region
08:26:19 <quicksilver> Thunder: how is that any different from a datatype (ByteString) which has other various primitives which are compiled to efficient operations?
08:26:41 <quicksilver> Thunder: practical languages have to start with a base set of types and operations with  known complexity bounds.
08:27:11 <CosmicRay> BMeph: MissingH includes instances for HVIO for the disk, as well as in-RAM buffers of various sort.  Makes unit testing quite nice.
08:27:16 <Axman6> Thunder: you've got to remember that in the end, we want the most efficient imperative result we can get, and if that means programming imperatively, then so be it. there's no need to be a purity nazi when there's not much to gain :)
08:27:26 <Thunder> quicksilver: *g* Of course there is a final real hardware cut. But these contacts should not be extented without good reasons.
08:27:52 <CosmicRay> BMeph: HBFS has similar stuff.  There's also a chroot emulation in pure Haskell, as well as a way to restrict access to the system's filesystem to be read-only.
08:28:07 <CosmicRay> s/HBFS/HVFS/
08:28:11 <quicksilver> Thunder: the complexity bounds of [a] are a good reason not to use [Word8] as the only available interface to chunks of bytes.
08:28:37 * loadquo_ shudders at trying to implement a RAM based VM without Mutable arrays
08:28:37 <Thunder> There are other interfaces: i.e. Sequence.
08:28:46 <loadquo_> at the thought of*
08:29:05 * Axman6 doesn't think he'd like to use multi GB Sequences
08:29:31 <kiris> there's a nice paper about implementing scheme with the state monad and transformers
08:29:39 <Thunder> fasta: We do not need to jump from the plane at all. Let us stay inside the functional thing.
08:29:44 <roconnor> > sqrt (1-0.5^2)
08:29:46 <lambdabot>   0.8660254037844386
08:29:51 <roconnor> > sqrt(3)/2
08:29:54 <lambdabot>   0.8660254037844386
08:29:57 <quicksilver> Thunder: again, there is nothing un-functional about ByteString
08:30:04 <quicksilver> it's just another datatype with other complexity constraints.
08:30:11 <quicksilver> it's no more mysterious than Int.
08:30:19 <quicksilver> (although its complexity constraints are admittedly more subtle)
08:30:24 <Thunder> quicksilver: I do count the library implementation, too.
08:30:26 * koeien thinks Int is quite mysterious :)
08:30:31 <roconnor> > 6-sqrt(3)/2*7
08:30:32 <fasta> Thunder: Since when do functional data structures exist according to you?
08:30:33 <lambdabot>   -6.21778264910704e-2
08:30:38 <quicksilver> ByteString merely appears to be implemented in haskell.
08:30:40 <quicksilver> It isn't.
08:30:41 <koeien> > (2^30 :: Int) + (2^30 :: Int)
08:30:43 <lambdabot>   2147483648
08:30:46 <quicksilver> It's a primitive type.
08:30:55 <Axman6> quicksilver: could the same be said about Integer?
08:30:55 <vpetro> kiris: do you have a link to the paper?
08:31:06 <quicksilver> Axman6: right. Integer also isn't implemented in haskell.
08:31:13 <quicksilver> and it also has slightly subtle complexity constraints.
08:31:33 <quicksilver> It just so happens that our compiler (GHC) permits us to implement new primitives in a language not-entirely-unlike haskell.
08:31:39 <Axman6> Thunder: do you feel that Integer would be better imploemented as a [Bool]?
08:31:40 <Thunder> quicksilver: How many "primitive" types do we need? A new one for every operation we like to borrow from the existings algorithms world?
08:31:49 <quicksilver> and this langauage shares some of the maintainability advantages of haskell.
08:32:03 <quicksilver> Thunder: I shouldn't think so, not, not by a long short.
08:32:08 <Thunder> Axman6: I'd prefer it as [Int].
08:32:12 <kiris> I dislike functions that throw exceptions instead of returning an Either value..
08:32:19 <kiris> ~ ___~
08:32:24 <quicksilver> I should imagine uvector subsumes most of what we need.
08:32:27 <Axman6> still, the performance would be unthinkably bad
08:32:29 <quicksilver> at least, DPH-capable uvector.
08:32:46 <quicksilver> (bytestrings could be reimplemented in a sufficiently capable uvector, I think)
08:33:03 <koeien> Thunder: there is a balance, of course. everything could be implemented as an 'Int' with suitable newtype/data-wrappers
08:33:06 <Thunder> Axman6: Why? Because the gmp library is coded in assembly?
08:33:08 <quicksilver> the set of primitive types we need is probably small.
08:33:09 <Axman6> kiris: i feel the same about Prelude functions that error instead of using Maybe or something
08:33:15 <koeien> Thunder: do you think we would need to implement everything that way?
08:33:28 <Axman6> Thunder: because lists are inefficient
08:33:47 <Axman6> and would provide a lot of overhead on any operations on Integers
08:33:55 <koeien> or even as a Bool! Let's do that. my point is, Haskell is in some respects pragmatic
08:33:58 <Thunder> koeien: If we had efficient lazy algorithms, the question would not arise.
08:34:26 <kiris> emphasis on the hypothetical 'if'
08:34:41 <koeien> if you need to allocate thunks and do everything lazy, it will not be efficient
08:34:48 <koeien> there is a reason that strictness analysis is important
08:34:49 <Thunder> Axman6: Lists need not to be inefficient. Algorithms has to keep in mind, that they are not array.
08:34:51 <tromp__> do lazy bytestrings have identical semantics to [Word8] ?
08:34:55 <quicksilver> Thunder: rubbish.
08:35:04 <quicksilver> Thunder: I believe you have very little idea what you're talking about.
08:35:09 <koeien> Thunder: please, show me efficient binary sort on a list
08:35:10 <Thunder> quicksilver: Possible.
08:35:18 <quicksilver> lists have a memory overhead of about 8:!
08:35:22 <koeien> s/sort/search
08:35:33 <quicksilver> that's the key reason that [Char] can never be efficient as ByteString
08:35:35 <vixey> this paper says: omg GADTs are sooooooo complex
08:35:39 <Thunder> koeien: Why binary?
08:35:44 <quicksilver> and it doesn't really have much to do with efficient lazy algorithms.
08:35:54 <koeien> not binary. you can do it ternary if you want. O(log n)
08:35:58 <hugo___> what should be used for random access ?
08:36:07 <quicksilver> we know how to implement Integer in pure haskell, and get the same asymptotic complexity as gmp
08:36:12 <vixey> page 2 has some theorems and the conclusion is lets go shopping
08:36:13 <pejo> Thunder, laziness is only a win in the case you don't have to do some work. If you have to do all the computations strict is usually a win because of how our computers work.
08:36:15 <koeien> it's not even hard to do
08:36:16 <quicksilver> it's not particularly difficult if you know what you're doing.
08:36:20 <loadquo__> Category Theory question: What is the difference between a map and a morphism? I may have asked this already, before I lagged out, apologies if that is the case.
08:36:24 <quicksilver> but it will still be slower than gmp.
08:36:28 <hugo___> i mean, really fast random access ?
08:36:34 <Axman6> Thunder: this channel is full of some  of the smartest programmers you may find on the internet. there's a lot fo work going on with this stuff, and they certainly are not lazy about trying to find new efficient ways to do things. it's just a lot of things are better done in another way, and if we can get a nice pure haskell interface to them, then that's the best of all worlds
08:36:35 <koeien> loadquo__: there is none :)
08:36:38 <quicksilver> loadquo__: 'map' is normally an informal term.
08:37:07 <hugo___> Axman6: does that include me ?
08:37:16 <quicksilver> loadquo__: for example : "A functor : C -> D is a map from objects of C to objects of D and also a map from morphisms of C to morphisms of D, such that blah blah blah"
08:37:19 <Axman6> maybe? i dunno :P
08:37:27 <hugo___> hehe
08:37:33 <hugo___> neither do i, but i guess not
08:37:36 <hugo___> yet
08:37:37 <hugo___> lol
08:37:37 <quicksilver> loadquo__: i.e. map is used in the ordinary set-theoretical sense of map. Except those things might not be sets. Hence 'informal'.
08:37:56 * Axman6 wonders if he'll learn any category theory at uni
08:38:14 * koeien is still learning CT
08:38:44 <koeien> on my own though, not at my university (which is a university of technology, so few know about CT here)
08:38:55 <loadquo__> quicksilver: Heh, that was exactly the context that confused me.
08:39:12 <hugo___> on my univ there is no haskell teaching, much less category theory
08:39:18 <tromp__> could GHC use the efficient lazy bytestring implementation for any use of [Word8] ?
08:39:35 <quicksilver> loadquo__: so, in that context it's not a very technical term. It's probably a synonym for 'function' in the ordinary, casual sense of the word.
08:39:45 <Axman6> tromp__: depends on the usage
08:40:02 <vixey> what does |*| mean? as a kind
08:40:07 <koeien> quicksilver: only in small categories
08:40:12 <koeien> ?
08:40:20 <tromp__> so, it cld be efficient if you stick to certain conventions in how you use the [Word8] ?
08:40:38 <vixey> could
08:41:16 <Axman6> vixey: absolute anything!
08:41:17 * ksf sighs
08:41:27 <vixey> any kind ?
08:41:34 <ksf> I thought there'd be a revolution in iceland, but the government just gave up.
08:41:35 <Axman6> absolutely!
08:41:42 * Axman6 has no idea
08:41:45 <vixey> k
08:41:47 <loadquo__> quicksilver: Hmm, thanks.
08:41:49 <vixey> I don't either that's why I asked
08:41:51 <koeien> ksf: ? new elections
08:41:59 <Thunder> pejo: Laziness allowes localization of data while distributing the working code. That allows to reuse code and to write better code.
08:42:04 <Axman6> why were they rioting anyway?
08:42:19 <koeien> Axman6: the financial crisis
08:42:37 * Axman6 needs to get back to reddit
08:42:41 <ksf> 'cos the people wanted a new goverment, and the government rather a new people...
08:43:07 <Axman6> heh
08:43:39 <pejo> Thunder, but you were talking about efficiency, and from an efficiency pov laziness is only a win if it can avoid computing a result.
08:44:54 <koeien> nonstrictness != sharing datastructures
08:45:32 <Thunder> pejo: The approbriate imperative program is likely to become too complex, to be implemented.
08:45:59 <pejo> Thunder, you are confusing order of evaluation with (im)purity.
08:46:02 <vixey> @w80 approbriate
08:46:03 <lambdabot> No match for "approbriate".
08:46:42 <ksf> from a coding efficiency pov, it eases abstractions because you can code them more general without paying run-time costs for unused stuff.
08:46:52 <fasta> Thunder: most people program computers perfectly fine in that manner.
08:47:10 <athos> your discussion lacks examples i guess
08:47:52 <athos> it's much too abstract and that's why you all talk at cross-purposes
08:50:16 <ozy`> here's an example for you. the "par" function allows you to pass any value (par's first argument) to another thread to be evaluated there in parallel to the second argument
08:50:46 <ozy`> without laziness this would be a bit difficult :p
08:51:42 <MyCatVerbs> ozy`: eh, you can write fork/join concurrency in non-lazy languages too.
08:51:57 <pejo> ozy, that would be fine in a strict semantics too, assuming that you catch any exceptions from the parallell thread, and that you make sure you evaluate the entire spark before returning.
08:52:02 <chessguy_work> if i were to upload a hackage that imports another hackage, would my hackage automatically be flagged as "depending" on the other?
08:52:20 <ozy`> MyCatVerbs: yeah but you also have to explicitly specify when you want to call a function
08:52:29 <MyCatVerbs> pejo: but then you'd have to have `par` take more than two operands (otherwise it'd just be seq). :)
08:52:30 <pejo> ozy, and values are already evaluated, so it's unecessary to spark at all.
08:52:40 <ozy`> (IIRC, ML does this with () as a dummy argument)
08:52:51 <nothingmuch> chessguy_work: ot that i've uploaded any, but i think it has to be explicit in the .cabal file
08:52:59 <orel> hi guys, anybody want see me nude? http://www.top100adultvacations.com/in.php?id=Olaf
08:53:18 <pejo> MyCatVerbs, what would the extra parameters be used for?
08:53:21 <nothingmuch> packages distribute modules, you import a modoule, which needs to be provided by a package you depend on
08:53:27 --- mode: ChanServ set +o Philippa
08:53:28 --- mode: ChanServ set +o quicksilver
08:53:30 --- mode: quicksilver set +b *!*n=orel@*.karneval.cz
08:53:30 --- kick: orel was kicked by quicksilver (quicksilver)
08:53:34 <Philippa> heh
08:53:36 --- mode: quicksilver set -o quicksilver
08:53:39 <Axman6> hooray Philippa
08:53:43 --- mode: Philippa set -o Philippa
08:53:45 <quicksilver> quickdrawmcsilver.
08:54:00 <chessguy_work> nothingmuch, yeah, but...hmm. it's still gonna break if they download my hackage and not the other, and try to build it
08:54:02 <Axman6> quicksilver: you got beat from where i am ;)
08:54:13 <quicksilver> interesting.
08:54:18 <nothingmuch> chessguy_work: it will complain politely =)
08:54:24 <chessguy_work> it will?
08:54:26 <quicksilver> IRC servers demonstrate some of the subtle points of general relativity.
08:54:33 <dcoutts_> chessguy_work: that's what explicit dependencies are for
08:54:33 <vegai> quicksilver, Philippa: aren't you afraid this channel is too small for the both of you?
08:54:44 <nothingmuch> also, cabal will refuse to build without the declared dependency before you ship
08:54:44 * vegai whistles Good,Bad&Ugly
08:54:47 <quicksilver> there is no global timeline
08:54:47 <chessguy_work> nice
08:54:48 <dcoutts_> chessguy_work: cabal install will just download and install the dependencies
08:54:51 <MyCatVerbs> pejo: well, if a `par` b fully evaluates a before starting to evaluate b, then it's just seq.
08:55:09 <chessguy_work> dcoutts mm, but i don't _want_ it to be dependent
08:55:22 <nothingmuch> so you wnat it to not work? =P
08:55:32 <hugo___> are there any good tut/documentation on haskell random ?
08:55:36 <pejo> MyCatVerbs, so par needs to be a primitive in a strict language.
08:55:39 <dcoutts_> chessguy_work: then don't depend on it and then you'd better not import it
08:55:40 <chessguy_work> i don't want it to not build, but i don't want to require them to download the other
08:56:06 <dcoutts_> chessguy_work: how can it work if something that it needs is missing?
08:56:16 <ozy`> MyCatVerbs: in hindsight you could wrap them in (\() -> (); stuff)
08:56:29 <dcoutts_> chessguy_work: are you trying to construct an optional dependency?
08:56:41 <dcoutts_> where it can build with or without some other package?
08:56:44 <ozy`> s/;/`seq`/ for various purposes
08:56:55 <dcoutts_> chessguy_work: a conditional dependency
08:57:19 <ozy`> MyCatVerbs: so basically my example was crap >_>
08:57:46 <Axman6> quicksilver: general relativity == lag?
08:58:03 <quicksilver> Axman6: it's not the lag, it's the fact we're on different servers
08:58:11 <Axman6> yeah i know :)
08:58:18 <quicksilver> Axman6: and events are propagated between servers. It's not a perfect analogy.
08:58:26 <quicksilver> but it can demonstrate some of the same 'paradoxes'
08:58:34 <Axman6> i've lost enough "i was first!" "no i was!" fights to know how irc behaves :(
08:59:01 <Axman6> namely against Beelsebob. bastard
08:59:03 <dcoutts_> chessguy_work: it's possible to have conditional dependencies if that's what you're trying to do
08:59:14 <chessguy_work> perhaps i should explain what i'm trying to do
08:59:26 * Beelsebob pokes Axman6 in the type faster already
08:59:33 <Axman6> oo
08:59:42 <dcoutts_> chessguy_work: yep
09:00:21 <skorpan> what's the idea behind this representation of an addition? data Plus a b = Inl a | Inr b
09:00:24 <skorpan> what's Inl and Inr?
09:00:37 <quicksilver> it's type addition
09:00:40 <ehird> It's ty-
09:00:41 <ehird> Yeah.
09:00:41 <quicksilver> not numeric addition
09:00:43 <chessguy_work> there are several satisfiability solvers on hackage, but none of them have a nice front end for using them. i want to create a package that has a nice front end for representing propositinal logic statements, and a typeclass for a solver. then i can provide an instance of the class for each existing solver
09:00:46 <ehird> like how Maybe a is a+1
09:00:53 <quicksilver> as in data Either a b = Left a | Right b
09:01:09 <chessguy_work> the idea being to unify how we represent queries to these kinds of solvers
09:01:09 <skorpan> i don't get it.
09:01:13 <quicksilver> (there are strong algebraic analogies with numbers, which is why they call it addition)
09:01:40 <cryptononce> is there a mode in ghci that allows me to browse function definitions?
09:01:54 <MyCatVerbs> cryptononce: 'fraid not, sorry.
09:01:55 <quicksilver> cryptononce: no
09:01:59 <dcoutts_> chessguy_work: ahh, you want to provide instances for types defined in other packages but without depending on those packages.
09:02:13 <kiris> preflex: be poppavic
09:02:14 <preflex>  well, I also am known to on occasion ask sex/age priv - so I can figure out someones headspace, or what might offend.
09:02:16 <chessguy_work> right
09:02:26 <ehird> please stop making preflex be poppavic
09:02:29 <ehird> it's scary :(
09:02:41 <ehird> cryptononce: Like, lambdabot @src?
09:02:45 <dcoutts_> chessguy_work: there's no nice solution to that. Either you just depend on them, or you have to make tiny packages that depend on the package providing the type and the package providing the class
09:02:46 <ehird> Lambdabot is available for ghci..
09:02:52 <quicksilver> cryptononce: all the standard library source is available online though
09:03:02 <quicksilver> (and offline, if you are lucky)
09:03:02 <dcoutts_> chessguy_work: and the latter is not nice of course, you end up with N one-line packages
09:03:25 <chessguy_work> dcoutts_, can i just provide multiple ways of building my package?
09:04:11 <dcoutts_> chessguy_work: you can conditionally depend on all of the packages you're wrapping, however it's not really kosher since you're changing the api you provide based on the way its built.
09:04:23 <quicksilver> preflex: seen shapr
09:04:24 <preflex>  shapr was last seen on #haskell 11 hours and 20 seconds ago, saying: ddarius: er, yeah, I'll get right on that
09:04:30 <quicksilver> @get-shapr
09:04:30 <lambdabot> shapr!!
09:04:38 <dcoutts_> chessguy_work: so there is no way for another package depending on yours to say they need the instance for sat-foo vs sat-bar
09:04:45 <Axman6> heh
09:04:58 <chessguy_work> hrm
09:05:07 <nothingmuch> preflex: f/14 ;-) lolz !!!
09:05:07 <dcoutts_> chessguy_work: different ways of building a package are not supposed to change the api
09:05:18 <chessguy_work> yeah, that makes sense
09:05:24 <cryptononce> quicksilver: thanks.
09:05:36 <fasta> What's the easiest way to put a collection of possibly translated/rotated images on the screen? I.e., is there some library which can already do that, or failing that, is there a library to get the image data from a variety of image formats to get access at the individual pixels and a library which can put individual pixels on the screen?
09:06:12 <nothingmuch> chessguy_work: you could make an addon package with that additional dep that depends on the more standalone one
09:06:45 <chessguy_work> nothingmuch, you mean the additionial dependency on the other packages?
09:06:55 <dcoutts_> nothingmuch, chessguy_work: that approach is essentially what the database packages do, HDBC-mysql, HDBC-postgres
09:07:36 <quicksilver> fasta: probably wx. possibly SDL.
09:07:52 <nothingmuch> oh, hmm
09:07:56 <nothingmuch> i missed your explanation
09:07:56 <quicksilver> fasta: I have used wx to to a quick interactive image-cropper and it was not very difficult.
09:07:58 <fasta> quicksilver: sdl cannot, because sdl_draw has no Haskell version.
09:07:59 <nothingmuch> i think my response is naive
09:08:18 <chessguy_work> i suppose i could send an email to the maintainers of the other packages. might be interesting to see how actively they're maintained anyway
09:08:23 <nothingmuch> so you can make a core package for the typeclass
09:08:27 <nothingmuch> and then one package per typeclass instance
09:08:36 <chessguy_work> ugh
09:08:39 <nothingmuch> and maybbe these additional typeclasses can be merged upstream
09:08:46 <quicksilver> fasta: you don't need (or want) sdl_draw to simply blit images, possibly transformed or rotated.
09:08:57 <quicksilver> fasta: sdl core functionality + sdl_image is enough
09:09:02 <chessguy_work> i'd rather submit patches to the other packages, if they'll allow it
09:09:02 <quicksilver> however, wx may be more convenient.
09:09:13 <quicksilver> unless you mean rotating by something other 90-degrees
09:09:23 <quicksilver> if you mean that, then I would use opengl
09:09:50 <fasta> quicksilver: yes, by something else than 90 degrees :)
09:09:57 <kiris> fasta: you can get pixels from an input using libgd
09:10:04 <kiris> s/input/image
09:10:36 <kiris> http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html
09:10:41 <quicksilver> fasta: Ah. Then I would use opengl. Other libraries may also allow this but I don't know what they are.
09:10:54 <kiris> I have a modified version which has getPixel returning the colour of a pixel at a certain (x,y) point
09:10:55 <quicksilver> (and opengl doesn't solve the image loading part -- I used wx to load images which I then displayed with opengl. YMMV)
09:11:22 <Saizan> @where hpaste2
09:11:23 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
09:12:23 <kiris> fasta: do you want it?
09:13:09 <chessguy_work> this totally needs to be turned into a lolcat picture: http://girltalk.blogs.com/.a/6a00d8341c032a53ef010536f242ed970c-pi
09:13:28 <fasta> kiris: no, try to get it in the distribution, or put up your own package.  Thanks for the offer. \
09:13:55 <kiris> I'll put up my own package, one moment
09:13:58 <ozy`> chessguy_work: that's been all over the *chans for years
09:14:12 <quicksilver> chessguy_work: INVISIBUL RIGGING
09:19:17 <cryptononce> Is there a way to use pattern matching with specific function values in a higher order function?
09:19:33 <kiris> fasta: http://chrisdone.com/code/haskell/gd/dist/gd-3000.4.1.tar.gz
09:20:01 <fasta> kiris: ok, and now add a setPixel function ;)
09:20:02 <cryptononce> such a hofunc f1 = "f1" ; hofunc f2 = "f2"  where f1 and f2 are functions.
09:20:29 <kiris> fasta: that's already there
09:20:46 <fasta> kiris: oh, ok. Then I skimmed it a bit too fast.
09:20:48 <Axman6> cryptononce: not that i know of
09:21:11 <quicksilver> cryptononce: no, functions are opaque
09:21:25 <quicksilver> cryptononce: if you want to match you probably want an ADT which stands in for the function
09:21:31 <quicksilver> data MyFunction = F1 | F2
09:21:32 <kiris> fasta: that one is different in that it supports getPixel and ByteStrings
09:21:46 <quicksilver> eval :: MyFunction -> (Int -> Int) ; eval F1 = f1; eval F2 = f2;
09:21:50 <kiris> fasta: I can remove the bytestring dependancy if you want normal gd with just getPixel
09:24:15 <cryptononce> quicksilver: thanks.
09:24:51 <kiris> fasta: here, I built the docs: http://chrisdone.com/code/haskell/gd/dist/doc/html/gd/
09:25:31 <roconnor> gtk2hs works under windows, right?
09:26:39 <roconnor> ah yes it does
09:26:41 <roconnor> good
09:28:56 <koeien> it works fine!
09:29:15 <koeien> although a bit ugly, but that's more due to GTK+
09:35:23 <PeakerWork> monad transformer types are a bit clumsy to write, its pretty nice I can just hide the type behind a "runStateT ... $ do ..." :-)
09:35:32 <mgee> hi, is there a function to check wether a string is a substring of another? for example if "testing" contains "est"
09:35:41 <PeakerWork> mgee: isInfixOf
09:35:42 <koeien> `isInfixOf`
09:35:55 <mgee> thx!
09:36:46 <PeakerWork> > "thx" `isInfixOf` "thanks
09:36:47 <PeakerWork> > "thx" `isInfixOf` "thanks"
09:36:48 <lambdabot>   <no location info>:
09:36:48 <lambdabot>      lexical error in string/character literal at chara...
09:36:49 <lambdabot>   False
09:38:19 <quicksilver> PeakerWork: yes, haskell appears to lack good tools to help dealing with complex types.
09:38:33 <quicksilver> PeakerWork: just look at that session types stuff by matthew-_
09:38:36 <PeakerWork> quicksilver: infix types help a little
09:39:14 <PeakerWork> have a link to that?
09:39:19 <quicksilver> no.
09:39:52 <quicksilver> yes.
09:39:53 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sessions
09:40:12 <quicksilver> PeakerWork: infix types just trade off readability against horizontal space (like infix operators)
09:40:22 <quicksilver> they don't actually help you abstract away the details of complex types.
09:40:39 <PeakerWork> quicksilver: what system can help with that?
09:40:45 <PeakerWork> quicksilver: thanks for the link
09:41:34 <quicksilver> PeakerWork: I don't entirely know. Something like type synonyms which works with class contexts too, would help, I think.
09:43:01 <PeakerWork> something like:   type Monad m => Blah m s = Bleh m (Bluh s)     ?
09:47:05 <andun> i'm getting some (imo) crazy type errors in my program. here's the code and the error message: http://codepad.org/UdaCaho6
09:47:44 <andun> it fails on the normalization function, but it's already annotated, so i don't see why
09:48:25 <andun> without the annotations i get "Ambiguous type"
09:48:51 <doserj> I guess that's the ScopedTypeVariables problem
09:48:58 <quicksilver> andun: because you can't annotate like that
09:49:07 <quicksilver> without turning on scopedtypevariables
09:49:41 <quicksilver> turn on ScopedTypeVariables and add an explicit forall sol, g, fit .
09:49:51 <quicksilver> to the beginning of the type sig on line 25
09:51:51 <andun> "forall sol g fit. (Blabla sol, ...) => ..."?
09:52:54 <drdozer> afternoon
09:53:06 <drdozer> cabal doesn't seem to want to install curl for me
09:53:11 <drdozer> and it doesn't seem to be telling me why :(
09:53:14 <Axman6> anyone know what Gofer is? seems an awful lot like haskell
09:53:25 <dcoutts_> drdozer: have you got the curl C libs and headers installed?
09:53:51 <drdozer> dcoutts, quite possibly not
09:54:02 <quicksilver> Axman6: a predecessor to haskell.
09:54:09 <Axman6> righto :)
09:54:11 <quicksilver> andun: yup
09:54:16 <Axman6> taking a look at http://people.cs.uu.nl/jeroen/article/jpeg/index.html
09:54:19 <Cale> Axman6: Check out what hugs stands for
09:54:56 <ddarius> quicksilver: Not quite.
09:55:23 <drdozer> dcoutts, curl and libcurl-dev are installed now
09:55:26 <andun> quicksilver: parse error on input '=>'.
09:55:47 <ddarius> quicksilver: Gofer was a spin-off of Haskell to try out some ideas most of which were folded back into Haskell.  The primary things being constructor classes and multiparameter type classes.
09:56:00 <drdozer> dcoutts_: cabal is telling me: See `config.log' for more details - but no such file appears to exist anywhere
09:56:19 <andun> (quicksilver: this is the new type annotation: http://rafb.net/p/ZQb5ZL55.html)
09:56:20 <dcoutts_> drdozer: no, that's in the temporary build directory
09:56:39 <dcoutts_> drdozer: so does it say what step it fails at>
09:56:44 <drdozer> dcoutts_: I've done a find under ~/.cabal - should I be looking under /tmp?
09:57:14 <dcoutts_> drdozer: no, it gets cleaned up, you'd have to untar and build it that way to inspect generated files
09:57:24 * drdozer mutters
09:57:56 <dcoutts_> drdozer: but it might be easy, what does it say when it fails, not the final message but the first one that goes wrong during configure
09:58:33 <drdozer> configure: error: curl libraries not found, so curl package cannot be built
09:59:38 <hugo___> yehh Axman6, i've been wondering about a jpeg functional implementation for quite some while now
09:59:46 <dcoutts_> drdozer: it's just looking for curl/curl.h
10:00:07 <drdozer> kk - I'm having words with aptitude
10:00:51 * dcoutts_ notes that the darcs version of cabal install has a nice command "cabal unpack curl"
10:00:57 <dcoutts_> $ cabal unpack curl
10:00:58 <dcoutts_> Downloading curl-1.3.4...
10:00:58 <dcoutts_> Unpacking curl-1.3.4...
10:00:59 <lunabot>  luna: Not in scope: `cabal'
10:01:07 <dcoutts_> lunabot: shh
10:01:20 <dcoutts_> unpacks it in the current dir, quite handy
10:01:30 <dcoutts_> well, in a subdir obviously curl-1.3.4/
10:01:54 <drdozer> when cabal works, it is really quite nice :D
10:02:27 <drdozer> ok, fixed by: aptitude install libcurl4-gnutls-dev
10:02:37 <dcoutts_> drdozer: in this case it's the checking for required C headers and libs that's not as good as it could be
10:02:49 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/262
10:02:57 <dcoutts_> which we're hoping to improve for the next release
10:03:03 <dcoutts_> since it annoys a lot of people
10:03:14 <drdozer> dcoutts_: and it deleting the error logs even on failure
10:03:39 <dcoutts_> drdozer: add your vote to http://hackage.haskell.org/trac/hackage/ticket/427
10:08:57 <drdozer> dcoutts_: I've commented on the bug but can't see a 'vote' button
10:09:30 <dcoutts_> drdozer: adding a comment or adding yourself to the cc counts as a vote
10:09:42 <andun> hm. setting ScopedTypeVariables and adding foralls gives Ambbiguous type. i don't see any conflicting types, though
10:09:57 <chrisdone> 'ello
10:10:13 <drdozer> can cabal be convinced to haddock and test stuff it's downloaded and installed?
10:10:34 <gwern> haddock? yes
10:10:42 <gwern> '-- + Haddocks
10:10:44 <gwern>  documentation: True
10:10:51 <gwern> test? dunno
10:10:58 <dcoutts_> drdozer: it can only haddock stuff at the point when you install it, so docs for things you've already installed requires --reinstall
10:13:47 <drdozer> is -O2 dangerous?
10:14:01 <dcoutts_> drdozer: no
10:14:03 * drdozer was just wondering why cabal defaults to -O1
10:14:13 <dcoutts_> drdozer: because it's the sensible default
10:14:33 <galdor> hi, I've some trouble with text parsing in haskell
10:14:36 <drdozer> OK - I thought you could specify optimization level in the .ccabal file?
10:14:41 <galdor> I'm trying to split a string in words
10:15:00 <galdor> in ruby, I do something like str.scan(/[\w\d]+/)
10:15:01 <dcoutts_> drdozer: it's supposed to be up to the person installing the package rather than up to the person writing the package
10:15:03 <ozy`> > words "split this string" -- for galdor
10:15:05 <lambdabot>   ["split","this","string"]
10:15:11 <galdor> words splits with whitespace
10:15:16 <drdozer> galdor: hoogle is your friend - search for something like String -> [String]
10:15:17 <dcoutts_> drdozer: so cabal configure/install have a -O0/1/2 flag
10:15:17 <trofi> :t lex
10:15:18 <lambdabot> String -> [(String, String)]
10:15:31 <galdor> drdozer: I looked at Text.Regex.PCRE
10:15:37 <galdor> there's a split function
10:15:42 <galdor> splitRegex I mean
10:15:53 <dcoutts_> drdozer: so I commented on the ticket, basically --resume is impossible but would it still be useful to have a --keep-build-dir flag? see the comment in the ticket for details.
10:15:55 <galdor> but it can't split on "[^\\w\\d]+"
10:16:05 <galdor> and it seems to have some trouble with unicode
10:19:54 <glguy> galdor, trouble with UTF-8, or Unicode?
10:19:59 <drdozer> dcoutts_: replied
10:20:10 <galdor> glguy: as far I can see, UTF-8
10:20:20 <glguy> galdor, if you are parsing utf8 encoded bytes, you'll want to decode them first
10:20:32 <hackage> Uploaded to hackage: gd 1000.0
10:20:58 <galdor> glguy: actually my first concern is being able to properly split words
10:21:58 <galdor> for example:
10:21:59 <galdor> splitRegex (mkRegex "[^a-z]+") "Hello, world!"
10:22:03 <galdor> ["","ello","world",""]
10:22:18 <galdor> splitRegex (mkRegex "[^A-Za-z]+") "Hello, world!"
10:22:21 <galdor> ["Hello","world",""]
10:22:29 <galdor> why do I get a third match ?
10:23:30 <glguy> the ! is seen as a delimiter
10:23:40 <glguy> between world and the empty string
10:23:57 <galdor> ok so it matches the 'nothing' between '!' and the end
10:24:09 <galdor> have to go, I'll try to make it work later
10:24:35 <ozy`> > filter . not . null $ splitRegex (mkRegex "[^A-Za-z]+") "Hello, world!"
10:24:37 <lambdabot>   Not in scope: `splitRegex'Not in scope: `mkRegex'
10:24:41 <ozy`> waaauuughhhh
10:31:02 <dcoutts_> drdozer: I think I've decided it's not necessary, we have better alternatives. I've added my comments.
10:35:41 <Gracenotes> is there an arrow somewhere for (a, b, c)?
10:35:52 <Gracenotes> or would that make it not-an-arrow?
10:37:27 <loadquo> Is there a good example of a Functor that is not a Monad?
10:39:29 <Gracenotes> er.... a Map, maybe? *thinks*
10:39:47 <ddarius> Map could probably be made into a monad.
10:39:51 <Saizan> ((,) a) for arbitrary a
10:39:53 <byorgey> Gracenotes: that doesn't make sense.  an instance of Arrow must have kind  * -> * -> *
10:40:06 <ddarius> Saizan: That could easily be made into a monad.
10:40:28 <Saizan> ddarius: how do you write return?
10:40:54 <Gracenotes> byorgey: okay, fair enough. Perhaps I should use a Data instead of a 3-tuple, then..
10:40:59 <zloog> :t when
10:41:00 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:41:05 <ddarius> Ah, for some reason I was thinking of Either.  return could be written, you could make a bind but it would be pointless.
10:41:32 <byorgey> Gracenotes: using an actual data declaration in place of any tuples bigger than two-tuples is probably a good idea, in general.
10:42:10 <Gracenotes> it's for a 2D game board that has multiple "layers"... so that probably makes sense
10:49:15 <Gracenotes> hm... the only problem is that some objects may inhabit multiple layers... :/
11:04:02 <CosmicRay> hrm.  there is no docs for what it means for a CalendarTime or ZonedTime to be equal.
11:04:16 <CosmicRay> does equality mean a reflection of the same instant in time, or does it mean something else?
11:04:55 <dmead> should you really be testing for equality in time states?
11:05:24 <CosmicRay> I don't follow the question.  I'm just interested in what == does for them.
11:06:42 <dmead> well it's the same time state, or it does nothing
11:06:54 <dmead> doing == with time might not ever work right if you'r eworking with a timer
11:06:57 <dmead> you want =<
11:07:03 <dmead> or =>
11:07:21 <dmead> to find out if a certain period of time has passed
11:07:21 <CosmicRay> not working with a timer.  this is mainly for some quickcheck tests.
11:07:25 <dmead> ah
11:07:56 <dmead> well i just can't think of an instance where == would be meaningful
11:08:05 <CosmicRay> well it can be meaningful
11:08:16 <CosmicRay> it could represent that x and x' are the same local time in a timezone
11:08:24 <CosmicRay> or it could represent that x and x' are the same instant
11:08:26 <dmead> sure, but timers
11:08:27 <dmead> no
11:08:40 <dmead> it could, but chances are you're comparison won'y happen at the right time
11:08:44 <dmead> or your timestamp
11:08:48 <dmead> it'll never work
11:09:37 <CosmicRay> there are ways to get a ZonedTime outside of timers.
11:09:48 <CosmicRay> looking at file timestamps, for instance.
11:09:55 <CosmicRay> quite a few things have a precision of only 1s
11:10:03 <CosmicRay> some things have a precision of only 1 day
11:10:11 <dmead> ah yea
11:10:22 <dmead> i thought you meant like down the the millisecond
11:10:53 <CosmicRay> well sure, I'd want the comparison to consider all fields.  but there are a lot of cases where pico will be 0, simply because the data for it doesn't exist
11:11:06 <dmead> sure
11:15:18 <Liempt> @t /x -> x+x
11:15:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:15:31 <Liempt> I. . .don't think I meant that.
11:16:51 <olsner> ooh, I love that set of topic manipulation commands
11:20:08 <Gracenotes> hm... what's the best way to chain Readers, all of type (a -> a)? Use a State?
11:20:32 <hackage> Uploaded to hackage: monadLib 3.5.1
11:20:32 <hackage> Uploaded to hackage: cflp 2009.1.26
11:24:19 <chrisdone> Peaker: ping
11:26:12 <nothingmuch> lambdabot: hit on jrockway
11:26:18 <nothingmuch> jrockway: sorry =P
11:28:12 <jrockway> nothingmuch: lambdabot doesn't love me
11:28:43 <jrockway> > let love = jrockway >>= nothingmuch
11:28:45 <lambdabot>   <no location info>: parse error on input `;'
11:29:05 <ozy`> ahem
11:29:16 <trofi> yeah, too many ';'
11:29:57 <nothingmuch> i think lambdabot should embed perl for Bone::Easy support
11:30:04 <nothingmuch> or maybe someone should port it
11:30:25 <jrockway> nothingmuch: there could be a haskell-ish version
11:30:40 <jrockway> like, "nothingmuch: liftM me into the monad of your heart"
11:40:32 <hasMeta> hello folks
11:40:46 <CosmicRay> hi
11:40:59 <hasMeta> is there a way to extract the pure html code using tagsoup (not text)? -> http://rafb.net/p/LibWxV82.html
11:44:49 <chessguy_work> hm, i'm trying to figure out if http://codepad.org/ allows extensions, but i never use them myself. what's a good way to test them?
11:45:11 * ksf wants -ize/ise-agnostic identifier names
11:45:25 <chrisdone> and colour/color?
11:45:39 <ksf> nope, color is always wrong.
11:45:45 <CosmicRay> ksf: what, and avoid a good flamewar?  Pretty soon you'll suggest that we should be agnostic of vi vs. emacs.
11:45:54 <CosmicRay> (viper all the way, right? <grin>)
11:45:55 <ksf> we are.
11:45:58 <ksf> we are yi.
11:46:07 <chrisdone> you may be yi
11:46:13 <chrisdone> but I like to actually get work done
11:46:21 <pumpkin> ksf: how about peas?
11:46:24 <wownoob> how to
11:46:29 <wownoob> wups sorry
11:46:35 <wownoob> how to change font color??
11:46:37 <chrisdone> how to babby form?
11:46:50 <pumpkin> > how (formed babby)
11:46:51 <lambdabot>   Not in scope: `how'Not in scope: `formed'Not in scope: `babby'
11:46:53 <pumpkin> boo
11:46:59 <pumpkin> I had that defined the other day
11:47:05 <chrisdone> good job
11:47:09 <pumpkin> :(
11:47:16 <pumpkin> anyway, you need to do way instain mother
11:47:27 <ksf> If I had been able to figure out how to use all those cool haskell source features yi is alleged to have, I would have already switched.
11:47:33 <wownoob> http://theclickgame.com - check how fast you are to click with your mouse in 30 seconds. If you are very good, you will be listed on the highscore - ALL TIME.... http://theclickgame.com
11:47:42 <Eelis> is there a nice section-like way of writing (\x -> x - 1) ?
11:47:46 <chessguy_work> @where op
11:47:46 <lambdabot> I know nothing about op.
11:47:48 <ksf> I don't care about vim mode resembling vi more than vim.
11:47:48 <chessguy_work> @where ops
11:47:48 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:47:55 <idnar> Eelis: subtract 1
11:47:55 <ehird> wow.
11:47:56 <pumpkin> wownoob: you'll just get kicked
11:48:03 <pumpkin> wownoob: and no one cares
11:48:03 <ehird> the click game is a total ripoff of my old game
11:48:08 <ksf> cursor keys are a waste of time, anyway.
11:48:11 <Eelis> idnar: i see, thanks
11:48:26 <wownoob> http://theclickgame.com - check how fast you are to click with your mouse in 30 seconds. If you are very good, you will be listed on the highscore - ALL TIME.... http://theclickgame.com
11:48:26 <wownoob> http://theclickgame.com - check how fast you are to click with your mouse in 30 seconds. If you are very good, you will be listed on the highscore - ALL TIME.... http://theclickgame.com
11:48:28 --- mode: ChanServ set +o Saizan
11:48:30 --- mode: ChanServ set +o dcoutts_
11:48:35 * ksf is surprised that there isn't a global "Serialisable" class.
11:48:36 <trofi> :]
11:48:36 <Saizan> too late..
11:48:40 * chessguy_work dives for cover
11:48:55 --- mode: ChanServ set -o dcoutts_
11:49:14 --- mode: Saizan set -o Saizan
11:49:15 <Eelis> idnar: i see there is no "add". was subtract introduced specifically because of -'s difficulties?
11:49:21 <pumpkin> so if you had the word pea as an identifier in your code, would that be wrong?
11:49:22 <trofi> ksf: Storable?
11:49:24 <idnar> Eelis: I believe so
11:49:27 <ksf> ...apart from read and show, which more or less suck.
11:49:31 <Eelis> idnar: ok, makes sense
11:49:32 <pumpkin> or is it not wrong because both england and the US make the mistake? :P
11:49:36 <pumpkin> "mistake"
11:49:44 <lilac> Saizan: you're clearly not fast enough at clicking your mouse! :)
11:50:34 <Saizan> lilac: as if i used the mouse at all! :)
11:50:41 <lilac> :) indeed
11:50:52 <ksf> haddock sucks for browsing instances.
11:51:23 <CosmicRay> ksf: that is an understatement.
11:51:29 <CosmicRay> ksf: there was a thread about this recently.
11:51:33 <Gracenotes> > foldl1' subtract $ map (4/) [1..9^6]
11:51:34 <lambdabot>   2.77259248558936
11:51:42 <Gracenotes> D:
11:51:48 <Gracenotes> > foldl1' subtract $ map (4/) [1,3..9^6]
11:51:52 <CosmicRay> ksf: currently haddock doesn't document what instances a module exports, nor does it let you provide docs about what the instance of a particular typeclass actually does
11:51:52 <pumpkin> Gracenotes: and his fancy math
11:51:53 <lambdabot>   3.14159641693555
11:51:58 <Gracenotes> :D
11:52:19 <Gracenotes> better than doing (flip (-))
11:52:21 <pumpkin> that's the 4 * atan1 thing isn't it?
11:52:22 <ksf> I need both Binary and storable...
11:52:27 <Gracenotes> yeah
11:52:57 <ksf> that is, encode a value into typedef/sizeof/data and back
11:53:15 <zloog> :? cycle
11:53:22 <zloog> ?src cycle
11:53:22 <lambdabot> cycle [] = undefined
11:53:22 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:53:30 <zloog> ?src (++)
11:53:30 <lambdabot> []     ++ ys = ys
11:53:30 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:53:30 <lambdabot> -- OR
11:53:30 <lambdabot> xs ++ ys = foldr (:) ys xs
11:53:48 <hasMeta> beautify -> http://rafb.net/p/SEUjDD15.html
11:53:57 <ksf> happS has Serialize.
11:54:16 <pumpkin> hasMeta: YESSIR
11:54:31 <hasMeta> :-)
11:57:24 <Botje> hasMeta: that is wrong and broken on more than one level
11:57:35 <mle> 9^6?
11:58:29 <Gracenotes> mle: er, you can go higher than that. It just so happens that 9^6 is the highest you can go to get 5 decimal places of accuracy in 3 digits by using the non-strict version of foldl1
11:58:35 <hasMeta> Botje: good to know, but what exactly is wrong?
11:58:50 <Gracenotes> mle: see http://stackoverflow.com/questions/407518/code-golf-leibniz-formula-for-pi#408897
11:58:57 <Botje> using regular expressions to filter html
11:59:04 <mle> hmmmm, okay
11:59:22 <Gracenotes> code golf in Haskell is enjoyable :) (for some problems, anyway)
11:59:27 <hasMeta> Botje: so what?
11:59:33 <Gracenotes> it doesn't do to well with FizzBuzz, for instance
11:59:36 <Gracenotes> *too
12:00:03 <Botje> don't use that code in production :)
12:00:29 <Gracenotes> most Haskell fizzbuzzes I've seen are sorta long
12:00:43 <Gracenotes> using guards, etc.
12:01:08 <hasMeta> Botje: does it look like production code? ;) anyway, to you know how to beautify the regex? would be nice to reduce it to a single statement
12:01:28 <Botje> very well:
12:01:42 <Botje> instead of deleting what you don't want, select what you DO want
12:02:19 * CosmicRay gets ready to upload two new packages to hackage
12:02:28 <pumpkin> yay
12:02:29 <hasMeta> yes, that's what I thought about, but regex-find only returns true/false, doesn't it?
12:02:35 <pumpkin> what are they?
12:02:41 <ozy`> hasMeta: <body> <!-- </body> --> OH SNAP </body>
12:03:02 <CosmicRay> pumpkin: #1 is testpack: some tools to mix QuickCheck and HUnit cases, and some replacements for HUnit display functions to make a nicer output.
12:03:19 <pumpkin> ooh
12:03:25 <hasMeta> ozy: ppssst
12:03:39 <CosmicRay> pumpkin: #2 is convertible, a generic library providing a typeclass and instances for conversion between different types.  (for instance, between different numeric types and different time types), including pure error-handling and bounds checking
12:03:51 <pumpkin> hasMeta: you'll find that in the end you use the regex to match closing tags and nothing else :P
12:03:59 <pumpkin> and everything else is your own logic
12:03:59 <CosmicRay> after these two are in Hackage, HDBC will be rewritten to use convertible, though of course in a backwards-compatible way
12:04:05 <chessguy_work> CosmicRay++
12:04:09 <chessguy_work> very cool
12:04:22 <zloog> I have a string and I want only the part of the string from the until the first whitespace. I know it would be easy to write one myself but is there an approach in the standard libs i could use?
12:04:33 <pumpkin> CosmicRay: cool, I've always wanted to do something like that!
12:04:37 <CosmicRay> :-)
12:05:09 <chessguy_work> zloog, takeWhile (not . whiteSpace)
12:05:20 <chessguy_work> where whiteSpace x = x `elem` ...
12:05:24 <Botje> hasMeta: let result = (html =~ "<BODY>(.*?)</BODY>" :: String)
12:05:29 <dcoutts_> CosmicRay: do you think it provides much over just using named functions?
12:05:32 <zloog> chessguy_work: Thanks, I was hoogling for sometime like take until
12:05:33 <Botje> don't have a ghci to test at hand
12:05:41 <ski_> BONUS_ : i'm not
12:05:43 <zloog> chessguy_work: knew I'd seen the function somewhere
12:05:51 <CosmicRay> dcoutts_: yes.  there are too many named functions to remember.  I have to resort to a chart.
12:05:56 <dcoutts_> CosmicRay: I can see how it's handy in a DB to map equivalent typed, but I'm not sure it's such a good idea completely generically?
12:06:01 <hasMeta> gosh, I'm only trying to process some latex2html output (which is very predictable) and I'm not really familiar with haskell + regex, would you please give me a hint?
12:06:04 <hasMeta> thanks! :)
12:06:07 <CosmicRay> dcoutts_: also, the named functions don't do bounds checking.  watch.
12:06:12 <pumpkin> Botje: how about someone sticking a <!-- </BODY> --> after the last body tag? :P
12:06:27 <CosmicRay> > (fromIntegral (534134132513531431431::Integer))::Int
12:06:28 <lambdabot>   -821445624045565433
12:06:41 <Botje> pumpkin: that's what i warned hasMeta against
12:06:46 <dcoutts_> CosmicRay: right, but that's exactly the kind of example that makes me nervous
12:06:46 <pumpkin> :)
12:07:07 <hasMeta> is there a way to slap both of you? :P
12:07:07 <dcoutts_> CosmicRay: that beginner just 'cast' one value to another without knowing or caring what they're doing
12:07:10 <CosmicRay> dcoutts_: so convertible has a function safeConvert that returns Either ConvertError a
12:07:15 <hasMeta> anyway, thanks
12:07:29 <dcoutts_> CosmicRay: ok, that at least makes it a bit more special purpose
12:07:31 <CosmicRay> dcoutts_: there is also a wrapper convert that will cause a Left to raise an exception
12:07:43 <CosmicRay> (breaking out of Either)
12:08:11 <CosmicRay> dcoutts_: http://git.complete.org/convertible?a=blob;f=Data/Convertible/Base.hs;h=3d714259f26da5d090ebee61ffad00c2fb85f0ea;hb=HEAD
12:08:20 <dcoutts_> CosmicRay: right (or perhaps I mean left :-) ). As I say it makes perfect sense in the context of a DB lib
12:08:37 <CosmicRay> dcoutts_: In some cases, no functions for conversion exist in the standard libraries.  For instance, converting System.Time to Data.Time and vice-versa
12:08:49 <CosmicRay> dcoutts_: right, this started when I rewrote the data marshalling features for HDBC 2.0.
12:08:59 <CosmicRay> dcoutts_: I was starting to write these time conversion functions
12:09:00 <dcoutts_> CosmicRay: but those are the kinds of conversions where you probably want to know what you're doing
12:09:21 <CosmicRay> dcoutts_: and then I realized that this was more broadly useful
12:09:46 <CosmicRay> dcoutts_: well, yes and no.  I have a lot of situations where I have a Double and I want an Integer and I don't care how it gets there, dammit ;-)
12:09:58 <CosmicRay> floor, round, truncate... all precise enough.
12:10:07 <dcoutts_> CosmicRay: right, I trust you with such a weapon, but not everyone :-)
12:10:09 <drdozer> I have several datatypes that are enums, all upper-case constructors
12:10:27 <CosmicRay> dcoutts_: oh you mean I *shouldn't* submit this to libraries@ for inclusion in base? ;-)
12:10:29 <drdozer> is there code that will let me convert between lower-case versions of the string of their names and the enum values?
12:10:31 <hasMeta> Botje: "=~" not in scope :-/
12:10:35 <drdozer> introspection magic?
12:10:40 <dcoutts_> CosmicRay: quite
12:10:43 <CosmicRay> dcoutts_: I didn't even use unsafe*IO anywhere! <grin>
12:10:58 <dcoutts_> heh
12:11:15 <CosmicRay> dcoutts_: I do think there is a legitimate problem that it's very annoying to convert between numeric types.
12:11:19 <pumpkin> CosmicRay: what if I want to convert my Double to an Int (on a 64-bit machine) by just treating it by its ieee representation though??
12:11:52 <dcoutts_> CosmicRay: yes, though to some extent that reflects the real problems and choices
12:12:04 <hasMeta> Botje: found it ...
12:12:07 <CosmicRay> pumpkin: well, if you convert a Double to an Int with safeConvert, you will get the expected thing: truncate of that Double, if it fits in an Int, or an error otherwise.
12:12:18 <CosmicRay> pumpkin: I am not suggesting everyone should use convertible.
12:12:38 <pumpkin> *(uint64_t *)(&myDouble)
12:12:40 <pumpkin> :D
12:12:41 <CosmicRay> dcoutts_: that is true, but not entirely.
12:12:47 <tromp__> pumpkin: call a c function :)
12:12:55 <CosmicRay> dcoutts_: for instance, the best way I've found to convert a double to a float is (fromRational . toRational)
12:13:02 <CosmicRay> dcoutts_: this is non-obvious to many.
12:13:04 <Saizan> or peek/poke
12:13:05 <dcoutts_> CosmicRay: true
12:13:31 <CosmicRay> also a heck of a lot of typing ;-)
12:13:46 * ksf just realised by accidental implementation how to do utterly unidiomatic haskell with typeclasses.
12:14:06 <CosmicRay> past that, you only need fromRational, toRational, truncate, and fromIntegral to do the basic stuff.
12:14:07 <CosmicRay> "only".
12:14:10 <ozy`> @let rerationalize = fromRational . toRational
12:14:13 <lambdabot>  Defined.
12:14:24 <CosmicRay> ozy`: and see, that name is also non-obvious to many ;-)
12:14:40 <ozy`> CosmicRay: I almost typed "dtof" but whatever :p
12:14:44 <CosmicRay> Haskell's numeric typeclass system is very nice in so many ways.
12:14:59 <CosmicRay> ozy`: yes, that would have been too restrictive, because it's also ftod :-)
12:15:00 <ozy`> alternately: coerceRational
12:15:06 <ozy`> whoops... :p
12:15:23 <pumpkin> unsafeCoerceButSafeReallyJustDon'tForgetTheTypeSystem
12:15:38 <CosmicRay> here's the thing.  If you have, say, an In64 and desperately want a Double...
12:15:54 <CosmicRay> and you are trying to figure out how to do this by reading haddock docs.
12:15:59 <CosmicRay> it will take you a long time.
12:16:07 <CosmicRay> because there are so many numeric typeclasses
12:16:18 <pumpkin> I wonder if hoogle is smart enough
12:16:23 <pumpkin> @hoogle Int64 -> Double
12:16:23 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
12:16:23 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
12:16:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:16:26 <CosmicRay> now if you know that the secret for things like this is fromIntegral, you're a lot better.
12:16:28 <pumpkin> yay
12:16:31 * ksf needs a way to make c2hs generate run-time upcast checking to calm his conscience.
12:16:34 <CosmicRay> but it's something of tribal knowledge
12:16:53 <CosmicRay> pumpkin: yay for the first result, boo for the third!
12:17:02 <dcoutts_> CosmicRay: of course fromIntegral is not a class method, its fromInteger . toInteger. It's obviously there to simplify common conversions. There's a good argument for the same for the floating numeric types.
12:17:03 <pumpkin> even the second seems a little out of place
12:17:06 <CosmicRay> does lambdabot report unsafeCoerco for everything? ;-)
12:17:19 <neun> hi, I have a cabal question: how do I include subdirectories in sdist?
12:17:38 <idnar> > unsafeCoerce (5 :: Int64) :: Double
12:17:40 <lambdabot>   Not in scope: `unsafeCoerce'
12:17:41 <CosmicRay> neun: you may be looking for extra-source-files
12:17:42 <idnar> aww :P
12:17:56 <dcoutts_> CosmicRay: oh, actually there is, it's called realToFrac
12:18:02 <idnar> @index Int64
12:18:02 <lambdabot> Data.Int, Foreign
12:18:03 <dcoutts_> CosmicRay: I didn't know that :-)
12:18:05 <neun> CosmicRay: thanks
12:18:14 <idnar> 2.5e-323, apparently
12:18:23 <dcoutts_> CosmicRay: seems I never have to convert doubles <-> floats :-)
12:18:40 <dcoutts_> :t realToFrac
12:18:41 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:19:00 <CosmicRay> dcoutts_: thank you, but also: crap.  now that means that I have to revise the chart in RWH to use it ;-)
12:19:01 <drdozer> so e.g. given "data Foo = A | B" I'm looking for a way to go from some 'f' to A, and from "A" to f==A
12:19:13 <dcoutts_> CosmicRay: doh! :-)
12:19:21 <CosmicRay> dcoutts_: so none of the hundreds of people that reviewed that page realized that realToFrac existed either ;-)
12:19:35 <dcoutts_> CosmicRay: nope, I'd no idea and I thought I knew this stuff
12:19:57 <nomeata> Hi. Did anyone here happen to get an e-mail from a James Wood today?
12:20:18 <drdozer> CosmicRay, the number hierarchy is so convoluted that it is feindishly difficult to figure out exactly which fooToBar would apply to the two numeric types you have to hand
12:20:32 <hackage> Uploaded to hackage: leksah 0.4.0.2
12:21:51 <doserj> dcoutts, CosmicRay: the haskellwiki knew it... http://www.haskell.org/haskellwiki/Converting_numbers#Converting_between_float_types
12:21:52 <dcoutts_> CosmicRay: it's more general than one needs really. eg:
12:21:54 <dcoutts_> > realToFrac (1.453564 :: Double) :: Ratio Integer
12:21:56 <lambdabot>   51142736630931%35184372088832
12:22:28 <dcoutts_> CosmicRay: which is probably another reason nobody looks for it, it's got a funny name
12:22:31 <CosmicRay> dcoutts_: http://article.gmane.org/gmane.comp.lang.haskell.cafe/51398
12:22:45 <dcoutts_> CosmicRay: because it follows the class names, and I wasn't looking for a conversion to Fractional
12:22:52 <CosmicRay> right
12:23:09 <maltem> drdozer: I think the problem here is that the numeric classes mix semantics/calculation and conversion
12:23:44 <dcoutts_> CosmicRay: yes what we're really looking for is an 'upcast' into the floating types, that would also serve to convert floating types
12:24:07 <maltem> drdozer: or even if they don't, it's hard to remember which are calculation, and which are conversion
12:24:34 <CosmicRay> dcoutts_: Wren points out that realToFrac is not the right way to go because it can't represent inf of NaN
12:24:43 <dcoutts_> CosmicRay: aye
12:24:49 <CosmicRay> dcoutts_: and there apparently is thus no correct way to convert a Float to a Double in the standard library.
12:25:26 <CosmicRay> it somewhat amuses me that this doesn't bother anyone.
12:25:43 <dcoutts_> CosmicRay: none of use use floats :-)
12:25:49 <CosmicRay> heh
12:25:51 <dcoutts_> use/us
12:26:25 <CosmicRay> ah, the joys of living in an age of computational plenty
12:26:27 <drdozer> it does seem to be crying out for some sort of 2-place conversion class
12:26:55 <dcoutts_> drdozer: that's just what I was arguing against, as a generic thing in the standard libs at least.
12:27:40 <drdozer> dcoutts_ the current status quo is clearly not serving us well though
12:27:57 <doserj> > realToFrac (1/0::Float) ::Double
12:27:58 <lambdabot>   3.402823669209385e38
12:28:06 <CosmicRay> weird!
12:28:09 <dcoutts_> drdozer: well it's got some holes, it's not that bad
12:28:28 <doserj> > realToFrac (1/0::Double) ::Float
12:28:30 <lambdabot>   Infinity
12:28:31 <CosmicRay> doserj: congratulations.  You have discovered the exact value of infinity.
12:28:40 <CosmicRay> doserj: time to write your thesis. ;-)
12:28:50 <CosmicRay> doserj: ok and that is weirder.
12:28:57 <chessguy_work> surely that's worth an honorary doctorat
12:29:00 <chessguy_work> e
12:29:13 <dcoutts_> doserj: heh, hugs gives completely different answers
12:29:14 <doserj> > realToFrac (1e150::Double) ::Float
12:29:16 <lambdabot>   Infinity
12:29:24 <dcoutts_> realToFrac (1/0::Float) ::Double
12:29:24 <dcoutts_> 127.999999940395
12:29:26 <dcoutts_> according to hugs
12:29:33 <dcoutts_> realToFrac (1/0::Double) :: Float
12:29:33 <dcoutts_> 2.384186e-07
12:29:40 <CosmicRay> > (realToFrac ((sqrt (-1))::Float))::Double
12:29:42 <lambdabot>   -5.104235503814077e38
12:30:22 <CosmicRay> I am also terribly curious why none of these functions do bounds checking.
12:30:31 <CosmicRay> it should be called unsafeFromIntegral
12:30:40 <doserj> ghc at least kind of makes sense. Hugs is totally wierd
12:30:54 <CosmicRay> > (fromIntegral (3971481389743897143971347984::Integer))::Int
12:30:55 <lambdabot>   -8535231346427363824
12:30:58 <ozy`> http://github.com/ynd/mona-clojure/blob/master/mona-clojure.clj <== what are haskell type annotations doing in a clojure source file? >_>
12:31:23 <Botje> documentation!
12:31:51 <doserj> > 1000::Word8
12:31:53 <lambdabot>   232
12:32:36 <doserj> unsafeLiteralOneThousand?
12:32:52 <CosmicRay> hah
12:33:20 <dcoutts_> but those sized types are explicitly defined to wrap
12:33:37 <CosmicRay> dcoutts_: but does conversion imply wrapping?
12:33:46 <CosmicRay> dcoutts_: I'm not sure that I'd assume that default
12:33:48 <maltem> doserj: Compiler warning: Numeric literal exceeds type bounds
12:34:09 <dcoutts_> CosmicRay: I'm sure there are use cases both ways
12:34:19 <CosmicRay> right
12:34:41 <CosmicRay> aren't you all so happy that I made a one-sentence note that I'm preparing to upload stuff to hackage?  ;-)
12:34:58 <pumpkin> I wonder where dons is!
12:35:20 <augustss> New York?
12:35:36 <pumpkin> I guess :)
12:35:52 <olsner> they don't have IRC in new york?
12:36:02 <pumpkin> nah, it's way behind
12:36:05 <augustss> Bah!  posix_memalign() seems to be a rare beast :(
12:36:17 <dolio> > 1000 :: Data.Word.Checked.Word8
12:36:19 <lambdabot>       Failed to load interface for `Data.Word.Checked':
12:36:19 <lambdabot>        Use -v to see ...
12:36:20 <olsner> hah! did you perchance think it was portable? :P
12:36:22 <pumpkin> augustss: needing it for vector stuff in llvm?
12:36:27 <chupish> depends on the region of NY
12:36:59 <pumpkin> augustss: if it helps, all mallocs on mac os are aligned to 16-byte boundaries :P
12:37:05 <augustss> pumpkin: Yes, the whole Foreign memory allocation needs an overhaul.  Someone totally forgot about alignment. :(
12:37:06 <pejo> augustss, what platforms has it?
12:37:12 <Gracenotes> :O no IRC in NY? --lifelong upstater
12:37:22 <augustss> pumpkin: not on my mac
12:37:31 <pumpkin> augustss: they certainly claim they are :o
12:37:37 <pumpkin> augustss: for the libvdsp stuff
12:37:42 <pejo> augustss, PPC?
12:37:48 <chupish> actually, I'm thinking about some regions on LI, which still use library-perscribed dial up because CV won't run lines
12:37:49 <olsner> possibly, the most portable thing is to implement your own aligning allocator out of an assumed-unsafe malloc
12:37:53 <augustss> pumpkin: hmmm, maybe I've only allocated with ghc's allocator and not malloc
12:38:31 <pumpkin> augustss: ah, mac OS's malloc _claims_ it always returns aligned memory, but I never bothered to see if they were lying
12:38:54 <pumpkin> from the mac os manpage "    The malloc(), calloc(), valloc(), realloc(), and reallocf() functions allocate memory.  The allocated memory is aligned such that it can be used for any data type,
12:38:54 <pumpkin>      including AltiVec- and SSE-related types.  The free() function frees allocations that were created via the preceding allocation functions."
12:38:54 <augustss> olsner: yes, you're probably right.
12:39:54 <pumpkin> o.O
12:40:01 <smtms> malloc is required by the C standard to return aligned memory suitable for any data type
12:40:16 <Gracenotes> chupish: hm? I
12:40:23 <Gracenotes> er, I'm in LI at the moment
12:40:23 <pumpkin> yeah, but it wasn't taking into account 16-byte datatypes
12:40:27 <pumpkin> was it?
12:40:27 <augustss> smtms: Any C data type, yes
12:41:13 <smtms> pumpkin, if 8-byte alignment is required for 16-byte datatypes...
12:43:11 <smtms> pejo, on platforms where alignment is not required, it still boasts performance a lot
12:43:40 <Twey> Why is there no showBin in Numeric?
12:43:48 * Nafai builds GHC from source
12:43:52 <pejo> smtms, my question was what platforms that had posix_memalign().
12:44:02 <byorgey> Twey: it's not hard to just use showIntAtBase, is it?
12:44:38 <Twey> Well, no, but showIntAtBase 2 (\x -> chr $ x + ord '0') isn't quite as snappy as showBin
12:44:41 <CosmicRay> Nafai: fun.  I've done that on AIX.
12:44:46 <CosmicRay> Nafai: doing that on AIX was... not fun.
12:44:57 <pumpkin> anyway, malloc on mac os does return 16-byte aligned chunks
12:45:05 <olsner> once in my life have I seen an AIX workstation
12:45:07 <augustss> CosmicRay: But then what is fun on AIX? :)
12:45:16 <Nafai> CosmicRay: I wouldn't imagine.  Doing anything on those UNIX's isn't fun.  I had to use HP-UX at my last job.  No fun.
12:45:25 <Twey> @src showIntAtBase
12:45:25 <lambdabot> Source not found. My brain just exploded
12:45:29 <Twey> :(
12:45:30 <CosmicRay> augustss: we brought in cameras and took photos the day we ran dd to wipe the disk on the AIX server before we sent it back to the leasing company.
12:45:46 <CosmicRay> augustss: I've never done that with any other platform ;-)
12:45:48 <augustss> I wrote one of the first commercial Haskell applications on AIX and HP-US in 1995.
12:46:03 <augustss> HP-UX
12:46:24 <CosmicRay> augustss: other things that are "fun" on AIX, for certain definitions of "fun", include dealing with a bad disk in an array and IBM's vi.
12:46:26 <pejo> augustss, what version of HP-UX was current back then?
12:46:26 <Twey> Oh really
12:46:27 <augustss> CosmicRay: I understand the sentiment
12:46:41 <augustss> pejo: you expect me to remember that?
12:46:42 <Twey> CosmicRay: Does IBM also have an emacs?  :-P
12:46:43 <leimy> I'm coding in Erlang today, doing something with a fold, that really feels like it should be in a State monad
12:46:44 <CosmicRay> the latter of which mysteriously corrupts your file if you attempt to move your cursor past its end.
12:46:45 * ksf ponders about the amount of work involved in binding to a TK _and_ providing a decent, extensible, interface vs. just bleeding implementing a TK in pure haskell.
12:46:49 <Nafai> Apparently my first Unix was HP-UX
12:47:00 <byorgey> Twey: just define  showBin = showIntAtBase 2 ("01"!!) ""
12:47:02 <Nafai> I remember compiling bash and screen in $HOME as I learned what they were
12:47:04 <CosmicRay> Twey: ironically, yes, in a sort of weird way.  AIX comes with a "Linux Compatibility CD", complete with penguin on it
12:47:06 <pejo> augustss, people often remember horror stories quite well. :-)
12:47:09 <Twey> byorgey: Oh, yeah, that's nicer
12:47:14 <CosmicRay> Twey: it includes RPM packaged up as an AIX package
12:47:14 <pumpkin> leimy: use the erlang interface for haskell! :P
12:47:22 <Twey> Hahaha
12:47:23 <leimy> pumpkin: huh?
12:47:25 <CosmicRay> Twey: and then various open source stuff compiled for AIX and packaged as RPMs.
12:47:33 <Twey> ksf: That sounds pretty awesome
12:47:41 <leimy> pumpkin: Like write the code in Haskell, generate Erlang? :-)
12:47:42 * ksf remembers loggin into solaris from a linux tty, invoking vi and being greeted by ed.
12:47:46 <pumpkin> leimy: I saw it on hackage a little while ago... it allows your haskell code to act as an erlang node :P
12:47:50 * Twey laughs.
12:47:51 <leimy> Ah
12:47:59 <leimy> yeah that wouldn't do it unfortunately, a little too heavy
12:48:01 <CosmicRay> ksf: Solaris don't like TERM=linux eh
12:48:02 <pumpkin> aw :(
12:48:07 <Philonous> Is someone working on a FreeBSD port for ghc 6.10?
12:48:15 <leimy> I'm just noticing this abstraction would be better served by a monad, and monads don't feel very natural in Erlang sadly.
12:48:23 <ksf> I ended up using xterm ;)
12:48:40 <Twey> Monads are kind of hard without types.
12:48:46 <CosmicRay> Twey: the other fun thing about all this is that eventually some of IBM's AIX packagesystem packages started depending upon RPMs to be installed, but there was no solid cross-dependency mechanism between the two
12:48:59 * Twey winces.
12:48:59 <vixey> it's fine without types, you just have to write explicitly which monad you're using
12:49:28 <olsner> it's like type safety, but without the type safe part!
12:49:37 <CosmicRay> Twey: also, both IBM binutils and GNU binutils were broken on the platform in different, and weird, ways!  The joys of AIX!
12:49:40 <vixey> I can't name one untyped language that isn't type safe
12:49:48 <CosmicRay> vixey: hah
12:49:49 <vixey> but C, C++.. are not type safe, although they are typed
12:49:52 <pao> Philonous: ghc 6.10.1 has got a problem with mmap on FreeBSD... there should be a fix in trunk
12:50:00 <ksf> for example, marshalling haskell functions and data implementing a widget into the C object system of a TK is a PITA.
12:50:20 <pumpkin> Philonous: I think sbahra might be working on it, but I'm not sure
12:50:24 <pao> Philonous: as soon as 6.10.2 will be out I can expect that the freebsd port will be updated
12:50:33 <pao> *you
12:50:35 <Philonous> pao: Ah, how does that problem manifest itself?
12:51:08 <pao> Philonous: let me look for the bug report...
12:51:29 <Philonous> Found it
12:51:34 <Philonous> ghci doesn't work
12:51:39 <Philonous> That's exactly my problem.
12:52:04 <multiholle> if a program crashes inclusive ghc, how could i find the reason? is it possible to see the error?
12:52:27 <ozy`> multiholle: inclusive?
12:52:33 <pumpkin> multiholle: you mean a program you compiled with ghc?
12:52:51 <pao> Philonous: you could try to download the branch a compile it
12:53:52 <multiholle> i ran ghci >> main and did something and then my program and ghci crashes and i don't know why :/
12:54:39 <jganetsk> if i want to compile a source file, is there anyway to make the assembly easy to read? like -O0 ?
12:54:46 <jganetsk> if i want to compile to assembly
12:54:53 <pejo> multiholle, you could try to :set -fbreak-on-error and run :trace main if you have a recent version of ghc.
12:54:55 <pumpkin> multiholle: "something"? what did you do?
12:55:21 <multiholle> it's a complex game
12:55:28 <maltem> multiholle: also, how does the crash manifest itself? are you silently returned to the shell prompt?
12:56:13 <multiholle> i use gtk2hs as output
12:56:40 <multiholle> i think it was an out of bounds exception using the !! operator
12:56:48 <pumpkin> oh
12:57:23 <pumpkin> it can't tell you what line the file crashed on, if that's your question
12:57:33 <pumpkin> ideally you won't have very many !! around your code
12:57:41 <multiholle> yes, that i would like to know
12:57:57 <gwern> jganetsk: I don't think ghc does readable assembler. maybe ghc core would be better for you?
12:58:03 <pumpkin> you could redefine !! to provide more info if it crashes
12:58:24 <pumpkin> like maybe traceShow the failing list
12:58:26 <pumpkin> and the index you asked
12:58:49 <jganetsk> gwern: sure, how do i output core?
12:59:08 <multiholle> redefining !! sounds good
12:59:23 <pumpkin> so import Prelude hiding (!!)
12:59:39 <multiholle> i'll try
12:59:41 <multiholle> thanks.
12:59:43 <pao> @seen dons
12:59:43 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 17h 45m 3s ago.
12:59:43 <gwern> jganetsk: the manual tells you
12:59:48 <Raevel> hiding ((!!))
13:00:15 <pumpkin> ah
13:00:26 <pumpkin> you'll need to import qualified Prelude as P or something to get the original !! back
13:00:26 <maltem> jganetsk: use one of the -fdump-* flags
13:00:36 <andun> is there some way of writing something like "type (Foo a) => Bar a = a -> String"?
13:00:36 <maltem> er, -ddump
13:00:40 <Philonous> Is there an ETA for ghc 6.10.2?
13:00:56 <pumpkin> andun: what would that mean?
13:00:57 <andun> (i just want an alias for a common function type in my program)
13:01:33 <andun> pumpkin: foo :: Bar a is really foo :: (Foo a) => a -> String
13:01:47 <jganetsk> maltem: thanks
13:01:49 <Raevel> andun: type Bar = (Foo a) => a -> String
13:02:50 <andun> that's apparently an "Illegal polymorphic or qualified type"
13:02:58 <Raevel> oh
13:03:05 <maltem> yeah it's not Haskell 98
13:03:31 <andun> i'm happy with ghc-isms as long as they won't come out and bite me
13:03:53 <maltem> hm, I don't think there is any extension doing that, or is there?
13:03:55 <ztirF> is there something like typeOf in haskell?  I want to do n*sizeof(undefined :: typeOf(x))
13:04:07 <koeien> yes there is
13:04:13 <koeien> @hoogle asTypeOf
13:04:13 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:04:14 <pumpkin> can't you just do sizeof(x) ?
13:04:19 <Raevel> andun: does -XRankNTypes solve it?
13:04:38 <koeien> pumpKin: there is no "sizeof" i think
13:04:47 <jganetsk> yeah, how can there be a sizeof
13:04:50 <jganetsk> what would that return
13:04:57 <andun> Raevel: hm, yeah! but won't that potentially bite me? :P
13:05:04 <andun> RankNTypes sounds bad
13:05:04 <pumpkin> @hoogle sizeof
13:05:05 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
13:05:05 <lambdabot> System.Posix.Internals sizeof_stat :: Int
13:05:09 <Raevel> andun: no idea :-)
13:05:16 <koeien> yeah for Storables, of course
13:05:16 <SamB_irssi> why not n * sizeOf x ?
13:05:21 <pumpkin> well yeah :)
13:05:22 <pumpkin> that's what I meant
13:05:48 <pumpkin> I just didn't get why the undefined needed to be thrown in there
13:05:58 <doserj> andun: one problem is, what should a type like (Bar, Bar) mean? are the free variables unified or not?
13:05:58 <SamB_irssi> it doesn't ...
13:06:10 <ztirF> pumpkin: my function knows the type, but I don't
13:06:25 <SamB_irssi> if it's defined on _|_, it's defined on every other element of that type too ...
13:06:43 <ztirF> pumpkin: all it gets is a foreignPtr, and I have to get the type out of the function signature somehow
13:06:54 <andun> doserj: not sure i know what a unified variable is
13:06:59 <pumpkin> ztirF: yes, but since sizeof is just working on the type, and it's fine to stick an undefined in there, isn't it enough to stick x in there too?
13:07:31 <maltem> he doesn't have an x if it's a ForeignPtr
13:07:39 <SamB_irssi> oh
13:07:44 <pumpkin> hmm
13:08:05 <SamB_irssi> what was that extension to bind type variables ?
13:08:09 <pumpkin> sizeof (undefined `asTypeOf` x) == sizeof x though?
13:08:41 <elly> what's sizeof?
13:08:45 <doserj> andun: think of a simpler example: type Number = (Num a) => a
13:08:54 <pumpkin> Foreign.Storable sizeOf :: Storable a => a -> Int
13:09:03 <vixey> -XScopedTypeVariables
13:09:15 <doserj> andun: now can (Number, Number) contain two different kinds of numbers?
13:09:27 <andun> ok. i see
13:09:44 <SamB_irssi> pumpkin: given that the haddock for sizeOf gives an example with undefined, (meaning that it doesn't use the argument), yes
13:10:43 <maltem> ztirF: in case you didn't catch it, -XScopedTypeVariables has been proposed
13:10:49 <ztirF> I'm checking it out
13:10:53 <ski_> (doserj : unified, of course ..)
13:11:07 <CosmicRay> yay xmonad is unborked in sid!
13:11:42 <ztirF> ahh, excellent, thanks vixey
13:11:49 * ski_ starts sidplay
13:12:46 <dolio> debian fired the Swedish chef?
13:12:54 <pumpkin> bork bork
13:13:17 <doserj> ski_: then I think type synonyms aren't really synonyms any more
13:13:30 <ski_> doserj : how come ?
13:14:52 <doserj> ski_: you can't substitute them anymore without checking for variable captures or other contexts etc
13:15:09 <SamB_irssi> doserj: that would still be a synonym
13:15:28 <ski_> `a' would of course be a module-scope (or smaller) type variable
13:15:28 <SamB_irssi> but the thing is existentials aren't allowed in that position
13:15:42 <leimy> > forkIO $ putStrLn "Hello"
13:15:43 <lambdabot>   Not in scope: `forkIO'
13:15:56 <leimy> > Control.Concurrent.forkIO $ putStrLn "Hello"
13:15:57 <lambdabot>   /tmp/5767390921476038285:70:32:
13:15:57 <lambdabot>      Not in scope: `Control.Concurrent.fork...
13:16:01 <leimy> doh
13:16:03 <pumpkin> IO isn't allowed in lambdabot
13:16:06 <ski_> (doserj : i.e. no dynamic scoping, here)
13:16:25 <leimy> pumpkin: seems like I really shouldn't be using putStrLn in a thread either.
13:16:29 <leimy> here's what I get back:
13:16:35 <pumpkin> leimy: yeah, I've had that issue
13:16:49 <pumpkin> you mean the interleaved output?
13:16:50 * SamB_irssi wonders why GHC uses the same file for +RTS -p and +RTS -px
13:17:40 <leimy> http://paste.lisp.org/display/74294
13:17:48 <pumpkin> yeah :)
13:17:58 <pumpkin> leimy: mmorrow suggested I use a Chan in that case, and it worked fine
13:18:01 <leimy> Yeah
13:18:08 <leimy> I was thinking I have an outputter thread
13:18:13 <pumpkin> yeah, it's quite easy
13:18:17 <leimy> and it just prints Strings sent to it
13:18:19 <dolio> "type Bar = (Foo a) => a -> String" is shorthand for "type Bar = forall a. (Foo a) => a -> String".
13:18:35 <leimy> I have to rearrange a bunch of code for that, but it should be ok
13:18:42 <leimy> A lot of times threads sharing stdout is an issue.
13:18:51 <ski_> dolio : in ghc ? i didn't know that
13:19:18 <ztirF> excellent, I have created my monster: unsafeAliasSlice !
13:19:55 <ztirF> O(1) array slicing yes please
13:20:01 <vixey> :(
13:20:10 <dolio> Which is why it requires RankNTypes (or 2).
13:20:34 <vixey> does GHC or anyone implement that open data types idea?
13:20:54 <ski_> (.. also, i'm not sure i like it)
13:21:28 <dolio> Yeah, I think it should probably be an error and force you to write the forall.
13:22:04 <dolio> But I suppose one could argue that it follows the convention of implicitly quantifying at whatever top level you have.
13:22:44 <dolio> "foo :: (Foo a) => a -> String" being shorthand for "foo :: forall a. (Foo a) => a -> String" and whatnot
13:23:43 <vixey> I want to use this http://people.cs.uu.nl/andres/OpenDatatypes.pdf
13:23:44 <ski_> i would like to possibly have future extensions allowing non-local type variables
13:23:51 <ski_> e.g. as module arguments
13:24:04 <dolio> Yeah, that'd be nice.
13:24:20 <ski_> or, defining a local data-type inside the scope of a polymorphic value definition
13:24:32 <pao> @src alloca
13:24:32 <lambdabot> Source not found. I feel much better now.
13:24:51 <dolio> vixey: As far as I know, nobody implements it.
13:25:10 <vixey> humf :(
13:25:11 * ski_ has a few times used "temporary" types, where having to parameterize by a bunch of type variables is just annoying
13:25:20 <dolio> Data families are open of course, but something tells me it's not the same as the stuff in that paper.
13:25:25 <dolio> Although It's been a while since I read it.
13:26:45 <dolio> Yeah, definitely not the same thing.
13:27:01 <ski_> (dolio : however, yes, striking a good balance between implicit quantification and expressiveness seems not obvious how to achieve)
13:27:24 <vixey> I would like to understand why people seem to say GADTs are "hard" or whatever
13:28:06 <dolio> Yeah. Being explicit in type synonyms that require a higher-rank polymorphism extension doesn't seem too arduous to me.
13:28:57 <dolio> But requiring it in ordinary Hindley-Milner type signatures would be a pain.
13:30:23 <dolio> I think implementing GADTs is harder than using them, if that's what you meant.
13:30:30 <vixey> dolio,
13:30:32 <vixey>  yes
13:30:49 <vixey> type checking (fully annoted) haskell doesn't require unification
13:30:54 <vixey> but type checking GADTs _does_
13:31:05 <vixey> so if you add type level lambdas to haskell .. that's fine
13:31:05 <leimy> pumpkin: did you use STM.TChan for your channel stuffs?
13:31:16 <vixey> but you add it to Haskell + GADTs -- you need HOU (?)
13:31:18 <dolio> At least, there's still occasional discussion about "where do I put type signatures in this to make it work" on the glasgow-users list.
13:31:36 <vixey> dolio, btw abuot your PTS checking,
13:31:37 <pumpkin> leimy: nope, just a regular Chan
13:31:40 <vixey> I have a question
13:31:44 <Heffalump> vixey: type level lambdas require HOU on their own
13:31:53 <dolio> Because they're still tweaking that aspect of it.
13:31:54 <pumpkin> leimy: it was very simple, I can paste the code that mmorrow gave me if you want
13:32:01 <vixey> Heffalump, without GADTs even ? in what situation?
13:32:03 <Heffalump> oh, you're talking about with explicit signatures everywhere
13:32:07 <vixey> yes
13:32:12 <Heffalump> I meant inference. But annotating everything would be very painful.
13:32:12 <dolio> vixey: If you're referring to the current state of the repository, it's pretty jacked up.
13:32:20 <vixey>  tc (Lam v e) = do b  <- lift fresh
13:32:21 <vixey>                    te <- local ((v,b):) $ tc e
13:32:21 <vixey> --                   let rt = elimUnused $ Pi v b te
13:32:21 <vixey>                    let rt = Pi v b te
13:32:23 <vixey>                    return rt
13:32:28 <vixey> dolio, just this rule ^
13:32:28 <pumpkin> leimy: it's import Control.Concurrent.Chan
13:32:29 <dolio> It's hot a half-assed unification thing that won't really work in practice.
13:32:45 <leimy> pumpkin: It's ok... I've got some code where I wrote a concurrent prime sieve with STM.TChan
13:32:49 <leimy> that's the only reason I asked :-)
13:33:21 <leimy> thanks though
13:33:47 <pumpkin> ah okay :)
13:34:11 <vixey> dolio,  is it an omission that you never check if  Pi v b te  is well formed?
13:34:17 <leimy> I know Chan is an unbounded FIFO
13:34:36 <leimy> I presume it's somehow buffered?
13:34:41 <leimy> or is that all just laziness?
13:34:53 <dolio> Well formed?
13:34:55 <leimy> plus clever scheduling
13:35:06 <jsgf> hi all!
13:35:09 <vixey> like   Pi "x" 3 (...)  is ridiculous because 3 isn't a type
13:35:13 <vixey> for example
13:35:41 <jsgf> is there a standard function of type :: (a -> Bool) -> a -> Maybe a
13:35:55 <jsgf> if p a then Just a else Nothing
13:36:07 <jsgf> ?
13:36:33 <dolio> vixey: Well, if 3 isn't a type, then it's unlikely that tc would yield it for the type of the expression e.
13:36:49 <jsgf> looks like something that should be in Data.Maybe, but I don't see anything, but i'm sure I'm overlooking something
13:37:34 <thomashartman1> I just upgraded to ubuntu ibex on a new laptop and installed ghc 6.10.1 from the binary package. ghc is there, but cabal appears to not have been installed.
13:37:47 <thomashartman1> aren't you supposed to get cabal with the default install of 6.10.1?
13:38:34 <CosmicRay> dcoutts_: how long does it normally take between cabal-upload and the time the docs are built on hackage?
13:38:52 <harovali> sorry for the dumb question: is there some sort of haskell fluency contest?
13:39:01 <doserj> thomashartman1: the Cabal library is part of ghc. But cabal-install (with the cabal program) is not
13:39:19 <thomashartman1> ah
13:39:50 <doserj> cabal-install needs the zlib and HTTP packages, which are not part of ghc
13:41:13 <dolio> vixey: The only places I could see that coming from are: 1) something like (Pi x 3 x), which I think would fail to check (since 3's type isn't a sort)...
13:42:23 <doserj> (how you can, in the 21st century, leave HTTP out of the de-facto standard libraries is another question)
13:42:41 <thomashartman1> pity that downloading zlib (and http? ) isn't part of bootstrap.sh script that comes with cabal
13:42:49 <dolio> vixey: Or, the environment containing (foo : 3), but I think I assume the environment has terms that passed type checking (or whose types are currently being inferred).
13:43:04 <vixey> yes well formed env. is essential
13:43:23 <Saizan> thomashartman1: it is
13:43:36 <Saizan> thomashartman1: you need the zlib C headers though
13:45:39 * Heffalump thinks having statically linked cabal executables on the webpage would save a lot of support hassle
13:46:17 <dolio> Anyhow, I've from time to time thought about rolling it back to when it required Church-style terms, but I've never gotten around to it.
13:46:54 <Beelsebob> Heffalump: yep, this was one of my main arguments against cabal-install – it takes a bit before it has fewer dependancies you don't have than the thing you want to install
13:47:05 <Beelsebob> hopefully the haskell platform will sort that out
13:47:09 <Heffalump> try installing gitit :-)
13:47:22 <Beelsebob> heh
13:47:35 * drdozer thinks Heffalump is right
13:47:43 <Heffalump> I wasn't particularly keen on installing it originally, but it was well worth it.
13:47:59 <vegai> hmm, I just got gitit installed with one command
13:48:17 <Heffalump> vegai: with or without cabal-install?
13:48:24 * Beelsebob wants to be able to cabal install cabal-install
13:48:33 <Heffalump> Beelsebob: you can...
13:48:34 <Saizan> Beelsebob: you can
13:48:36 <Heffalump> well, not on 'doze
13:48:39 <vegai> cabal install gitit
13:48:42 <Beelsebob> not the first time ;)
13:48:44 <Heffalump> vegai: well, so did I
13:48:51 <Heffalump> Beelsebob: that's why we should have static binaries
13:48:58 <Beelsebob> yep
13:49:01 <Heffalump> vegai: except pandoc is broken if you've enabled executable profiling
13:49:03 <Saizan> why not on 'doze?
13:49:06 <augustss> ghc should come with a cabal binary
13:49:10 <Heffalump> Saizan: because of filesystem semantics
13:49:12 <vegai> Heffalump: aah.
13:49:22 <Heffalump> augustss: that's the point of the platform, surely
13:49:32 <Heffalump> adding more dependencies to ghc's release process would be bad
13:49:56 <augustss> Heffalump: I can see ghc binary packages, I can see no platform.
13:49:58 * ksf shouldn't write that many rants, it makes him think too much.
13:50:11 <vegai> sudo pacman -S ghc cabal-install # works fine here :-P
13:50:15 <Heffalump> perhaps they should put out a first platform release with just the minimum :-)
13:50:23 <Heffalump> for cabal-install that is
13:50:24 <augustss> It's just plain obstinence not to put a cabal binary in the ghc binary package.
13:50:59 <Heffalump> calling it obstinance when there's only been one release cycle it could sensibly have happened in is a bit extreme :-)
13:51:06 <ksf> ghc should have a thing like drscheme
13:51:13 <doserj> augustss: but then the source doesn't match th
13:51:16 <doserj> ups
13:51:18 <augustss> Heffalump: I like to be extreme
13:51:20 <Heffalump> and how would you propose actually building the binary?
13:51:43 <doserj> *the binary
13:51:50 <augustss> Heffalump: I seem to be able to build the binary.  I sure someone else can do it too.
13:52:11 <vegai> cabal-install depends on http and zlib, so you would need those with ghc as well
13:52:17 <vegai> oh, and cabal itself, of course
13:52:21 <Heffalump> augustss: on what platforms?
13:52:44 <augustss> vegai: No, I'd just include a statically linked binary.
13:53:11 <augustss> Heffalump: the platforms that have binary packages
13:53:21 <pumpkin> augustss: for your aligned memory issue, can't you just allocate (amount requested + 16) and return a structure containing a 16-byte aligned start, as well as the actual start you were given (for free)
13:53:28 <pumpkin> +15 I guess
13:53:37 <vegai> augustss: oh, you talk about distro packages?
13:53:40 <Heffalump> augustss: you've built cabal binaries yourself for all those platforms? wow.
13:54:03 * Heffalump goes to look at how many there are
13:54:08 <augustss> Heffalump: not all, but I don't expect the easy ones to fail :)
13:54:26 <doserj> there are only 4 supported ones
13:54:36 <augustss> pumpkin: where would I put the extra base pointer?  there's no room for it in a Ptr
13:54:39 <Heffalump> what, like sparc solaris?
13:54:48 <doserj> 2 are linux
13:54:52 <pumpkin> augustss: oh, yeah :/
13:55:00 <doserj> + windows + macos (intel)
13:55:14 <drdozer> is there a library function to capitalize a word?
13:55:22 <pumpkin> drdozer: I hope not!
13:55:42 <lilac> augustss: where are you getting unaliged memory from?
13:55:44 <pumpkin> my alphabet doesn't have capitals, you insensitive clod!
13:55:50 <augustss> drdozer: It's about the first thing I write and put in a utility library at every new job :)
13:55:51 <pumpkin> *writing system
13:56:04 <augustss> lilac: malloc, potentially
13:56:37 <lilac> augustss: malloc is guaranteed to return memory aligned correctly for anything that fix in it
13:57:05 <pumpkin> augustss: how about valloc?
13:57:30 <augustss> lilac: the Storable class has a method called alignment which says which alignment you want for the type.  it can be larger than the alignment returned by malloc
13:57:43 <osfameron> @pl (\l -> foldl aux [] $ sort l)
13:57:44 <lambdabot> foldl aux [] . sort
13:57:53 <pumpkin> lol
13:58:23 <osfameron> ah, I tried that but the error I got was the pesky monomorphism
13:58:32 <pumpkin> provide a type signature
13:58:35 <osfameron> yeah
13:58:43 <augustss> osfameron: yeah, it's a pain
13:58:45 <pumpkin> or just turn off monomorphism restriction
13:58:55 <osfameron> is there any advantage to it?
13:59:15 <pumpkin> osfameron: it's supposedly to prevent functions from evaluating multiple times when you don't expect it
14:00:00 <pumpkin> it would be nice to have it off by default, and for it to maybe spit out a warning if such a case ever happens
14:01:35 <augustss> pumpkin: the warning might be tricky
14:02:30 <pumpkin> augustss: isn't it possible to keep track of all functions that would've been disallowed under monomorphism restriction before, and to check if they're used with different types? I have no clue how this all happens behind the scenes
14:04:02 <vixey> I though MR was so people didn't have to write so many type signatures down
14:04:10 <Gracenotes> @hoogle maxBy
14:04:11 <lambdabot> No results found
14:04:19 <vixey> but it actually achieves the opposite for the programs I write
14:04:20 <augustss> pumpkin: maybe it's easy.  I just remember thinking about it many years ago and I couldn't come up with simple way to warn
14:04:21 <Gracenotes> @instances Ord
14:04:22 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:04:35 <Gracenotes> :X
14:04:48 <vixey> @instances Enum
14:04:49 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:04:51 <Gracenotes> @hoogle maximumBy
14:04:51 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:04:51 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
14:04:51 <loadquo> Does anyone know why fmap on (,) is like second? And not first or something that acts on both members of the tuple?
14:05:00 <Gracenotes> oh. phew
14:05:07 <loadquo> > fmap (+3)   (4,5)
14:05:09 <lambdabot>   (4,8)
14:05:15 <vixey> loadquo, it's arbitrary.. sort of, it turns out that's the only one you can easily define in haskell
14:05:32 <Twey> Huh?
14:05:40 <Gracenotes> without a wrapping of (,), anyway
14:05:40 <Twey> They shouldn't either of them be definable
14:05:46 <vixey> (try to write all 3 functor instances)
14:05:47 <augustss> no
14:05:52 <pumpkin> loadquo: to act on both, a functor would need to take two types?
14:05:56 <Heffalump> loadquo: because of argument order and the definition of Functor
14:06:04 <loadquo> > first (+3) (4,5)
14:06:06 <lambdabot>   (7,5)
14:06:12 <augustss> it's a bit of a wart
14:06:33 <Heffalump> why can't you section (,), btw?
14:06:50 <augustss> grrr, why isn't ghc picking up my hs-boot file...
14:07:03 <Gracenotes> kinds can basically be partially applied, no?
14:07:13 <glguy> Heffalump, probably the same reason that "1,2" isn't the same as "(1,2)"
14:07:17 <Gracenotes> and the second comes after first
14:07:29 <Gracenotes> :k (,)
14:07:30 <lambdabot> * -> * -> *
14:07:56 <Heffalump> glguy: and if you ever wonder whether it should be the same, just look at F# :-)
14:08:17 <vixey> 1,2 works fine in ocaml
14:08:41 <dolio> What's the syntax for list literals in ocaml?
14:08:46 <vixey> [1;2;3]
14:08:50 <dolio> Ah.
14:09:11 <idnar> (,) is the wrong kind for a functor, so you can't define that instance
14:09:54 <vixey> for any a,   (,) a :: * -> *   is a functor... basically
14:09:59 <idnar> Gracenotes: I think you mean types can't be partially applied?
14:10:06 <dolio> x,y = (x,y) also doesn't work very well for Haskell's multiple tuple types.
14:10:25 <Gracenotes> idnar: yes, that's correct...
14:10:30 <idnar> vixey: and theoretically \b -> (,) a could be a functor, except you can't write that type in Haskell
14:10:40 <idnar> er
14:10:41 <dolio> Since (x,y,z) could be ((x,y),z) or (x,y,z) or (x,(y,z)).
14:10:44 <idnar> \b -> (,) b a
14:10:49 <Gracenotes> I'd hate to think of a level of abstraction above kinds :/
14:11:01 <idnar> hyperkind!
14:11:02 <osfameron> is there a better way of doing this in haskell? http://rafb.net/p/kTflao63.html
14:11:31 <osfameron> (this kind of thing is easy in Perl with automatically flattening lists and ? :  ternaries)
14:11:46 <loadquo> Okay I see why, I think.
14:12:12 <Stephan202> @pl \a b c -> evalStateT (runStateT a b) c
14:12:13 <lambdabot> (evalStateT .) . runStateT
14:12:23 <idnar> (,) is a bifunctor, though
14:12:35 <idnar> but there's no typeclass for that in the prelude
14:12:36 <Stephan202> @pl \a c b -> evalStateT (runStateT a b) c
14:12:37 <lambdabot> flip . (evalStateT .) . runStateT
14:14:14 <augustss> osfameron: reverse . nubBy isPrefixOf . reverse . sort
14:14:33 <loadquo> How do people read nub?
14:14:41 <Twey> 'nub'
14:14:42 <vixey> left to right :P
14:14:54 <augustss> rhymes with hub
14:14:57 <idnar> uhm
14:15:00 <Twey> Yes, but the other way it spells 'bun'
14:15:07 <dolio> Probably better to sortBy (flip compare).
14:15:08 <Twey> And everyone knows that buns are delicious
14:15:19 <Twey> Or maybe 'dun', hm
14:15:24 <loadquo> Any particular reason, it is nub?
14:15:30 <idnar> when you have something like Control.Monad.msum
14:15:31 <osfameron> augustss: ah, cool!
14:15:48 <augustss> loadquo: it's an appropriate name for the function
14:15:57 <osfameron> in archaic English
14:16:02 <dolio> @wn nub
14:16:03 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
14:16:03 <lambdabot> nub
14:16:03 <idnar> how does Haskell know that's not function composition on constructors called Control and Monad, and a function called msum?
14:16:04 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
14:16:06 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
14:16:08 <lambdabot>      3: the choicest or most essential or most vital part of some
14:16:10 <lambdabot> [5 @more lines]
14:16:13 <dolio> See 3.
14:16:21 <Twey> idnar: By magic.
14:16:28 <Gracenotes> of some... what?
14:16:51 <Twey> @more
14:16:52 <lambdabot>         idea or experience; "the gist of the prosecutor's
14:16:52 <lambdabot>         argument"; "the heart and soul of the Republican Party";
14:16:52 <lambdabot>         "the nub of the story" [syn: {kernel}, {substance}, {core},
14:16:52 <lambdabot>          {center}, {essence}, {gist}, {heart}, {heart and soul}, {inwardness},
14:16:52 <Raevel> @more
14:16:52 <lambdabot>          {marrow}, {meat}, {pith}, {sum}, {nitty-gritty}]
14:16:53 <idnar> oh, I see, you have to have spaces if you want it to be function composition on constructors
14:16:56 <ziman> idnar, lexical magic. If you made spaces around the dots, it would be function composition.
14:17:09 <Twey> idnar: To help it, and us, always put spaces around the dot when you mean composition.
14:17:11 <ziman> or start the identifier with a lowercase letter
14:17:12 <augustss> idnar: it's pretty yucky
14:17:14 <tromp__> >  reverse . nubBy isPrefixOf . reverse . sort $ [ "/foo/bar/baz", "/foo", "/qux/wibble", "/foo/bar", "/qux" ]
14:17:15 <lambdabot>   ["/foo","/foo/bar","/foo/bar/baz","/qux","/qux/wibble"]
14:17:23 <loadquo> I was thinking 1 personally, or maybe it make newbies ask silly questions.
14:17:27 <Gracenotes> hm... not quite
14:17:30 <idnar> Twey: sure, I hate code without spaces around the dot, but I was just wondering
14:17:37 <idnar> Twey: after I saw "System.Mem.StableName.hashStableName.System.IO.Unsafe.unsafePerformIO" on haskell-cafe
14:17:37 <Twey> *nods*
14:17:40 <osfameron> augustss: has to be reverse . nubBy (flip isPrefixOf) . reverse . sort
14:17:41 <Twey> Hahaha
14:17:44 <idnar> Twey: and my brain nearly bled out through my eyeballs
14:17:48 <Twey> :-D
14:18:04 <Twey> That's what unsafePerformIO does.
14:18:06 <tromp__> >  reverse . nubBy (flip isPrefixOf) . reverse . sort $ [ "/foo/bar/baz", "/foo", "/qux/wibble", "/foo/bar", "/qux" ]
14:18:07 <Twey> Don't do it, kids.
14:18:08 <lambdabot>   ["/foo/bar/baz","/qux/wibble"]
14:18:14 <idnar> unsafePierceEyeballs
14:18:21 <idnar> unsafeExtractBrains
14:18:30 <Twey> Aptly named
14:18:33 <Twey> That is indeed unsafe
14:18:35 <augustss> osfameron: weird.  it works for me
14:18:54 <osfameron> the fact that wordnet lists the desired definition of nub 3rd (after a completely unheard of definition about protuberances) does suggest it's slightly old-fashioned to say the least
14:18:55 <tromp__> nubBy is quadartic time though?!
14:19:07 <augustss> Has nubBy changed?
14:19:11 <osfameron> >  reverse . nubBy isPrefixOf . reverse . sort $ [ "/foo/bar/baz", "/foo", "/qux/wibble", "/foo/bar", "/qux" ]
14:19:13 <lambdabot>   ["/foo","/foo/bar","/foo/bar/baz","/qux","/qux/wibble"]
14:19:22 <augustss> I see it
14:19:42 <idnar> tromp__: but it's lazy
14:19:53 <osfameron> ah, it used to have args in different order?
14:19:57 <sacrebleu> please take this poll: http://gudagi.com/poll.html
14:20:11 <augustss> osfameron: It works when I paste it into my ghci
14:20:28 <augustss> osfameron: ghci 6.10.1
14:20:30 <idnar> @type nubBy
14:20:30 <loadquo> I think my problem with nubBy is that nub isn't a verb....
14:20:30 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:20:32 <hackage> Uploaded to hackage: level-monad 0.1
14:20:32 <hackage> Uploaded to hackage: convertible 1.0.0
14:20:32 <hackage> Uploaded to hackage: testpack 1.0.0
14:20:34 <vixey> sacrebleu, is this relevant to haskell at all?
14:20:42 <osfameron> spam I'd guess
14:20:45 <idnar> loadquo: sure it is
14:20:49 <loadquo> It didn't compile in my brain.
14:20:53 <vixey> osfameron, why guess?
14:20:59 <idnar> loadquo: Nub \Nub\, v. t. [Cf. {Knob}.] To push; to nudge; also, to beckon. [Prov. Eng.] [1913 Webster]
14:21:07 <osfameron> vixey: because I don't want to click on it to find out :-)
14:21:11 <idnar> not that that makes any sense ;)
14:21:21 <augustss> loadquo: In English you can verb anything.
14:21:33 <vixey> @remember <augustss> loadquo: In English you can verb anything.
14:21:33 <lambdabot> I will remember.
14:21:34 <vixey> lol
14:21:47 <Twey> osfameron: What?  Unheard-of definition about protuberances?
14:21:56 <Twey> The protuberance definition is the common one
14:21:59 <loadquo> Augustss: Just because you can, doesn't mean you should.
14:22:09 <osfameron> Twey: ah well, I must have missed it
14:22:16 <_Dae_> I came here to whine about C being unelegant, but now I thought the better of it
14:22:17 <Twey> osfameron: It's even slang for 'clitoris'
14:22:22 <dolio> head is also not a verb.
14:22:29 <Twey> It is
14:22:34 <Twey> It means 'to hit with the head'
14:22:37 <osfameron> "head off at the pass"
14:22:43 <Twey> And that
14:22:43 <augustss> _Dae_: C has a certain elegance in its simplicity.
14:22:47 <osfameron> or "to lead"
14:22:53 <dolio> Yes, there's that head.
14:23:03 <dolio> But the head in the prelude is not a verb.
14:23:13 <dolio> Nor is tail.
14:23:24 <Twey> Imagine if it followed a list around...
14:23:35 <Twey> But yes, insisting that all functions be verbs rather screws up record syntax.
14:23:43 <_Dae_> augustss: ahh, yes. I just find it hard not to write spaghetti.....
14:23:52 <dolio> Same with succ, pred, signum, sin, cos...
14:24:10 <loadquo> I expand head to mean "head of" in my brain. I only want function names to be verbs if you decided to use By or something else in the function name as well.
14:24:31 <augustss> Having function names be verbs suggest that they do something.  But Haskell functions just are.
14:24:57 <idnar> augustss: verbing weirds language
14:25:03 <ski_> do be do
14:25:28 <augustss> idnar: !
14:25:52 <dolio> nubBy computes the nub by using the provided function. :)
14:25:52 <ski_> @type getLine
14:25:53 <lambdabot> IO String
14:26:13 <Gracenotes> @src maximumBy
14:26:14 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:26:17 <Gracenotes> no
14:27:10 <augustss> > nubBy isPrefixOf . sort $ [ "/foo/bar/baz", "/foo", "/qux/wibble", "/foo/bar", "/qux" ]
14:27:12 <lambdabot>   ["/foo","/qux"]
14:27:20 <Gracenotes> ah, a simple foldl1...
14:27:42 <augustss> > nubBy (flip isPrefixOf) . sort $ [ "/foo/bar/baz", "/foo", "/qux/wibble", "/foo/bar", "/qux" ]
14:27:44 <lambdabot>   ["/foo","/foo/bar","/foo/bar/baz","/qux","/qux/wibble"]
14:27:59 <inv> hi all
14:28:26 <inv> lambdabot: 1 + 2
14:28:34 <tromp__> if u sort, than (flip isPrefixOf) always false
14:28:35 <koeien> try,
14:28:37 <koeien> > 1 + 2
14:28:38 <tromp__> then
14:28:39 <lambdabot>   3
14:28:44 <augustss> if lambdabot using an "improved" nubBy?
14:28:49 <inv> koeien: thx!
14:28:58 <inv> lambdabot: >1+2
14:29:08 <ski_> > nubBy isPrefixOf . sort $ [ "/foo/bar/baz", "/foo", "/qux/wibble", "/foo/bar", "/qux", "" ]
14:29:08 <tromp__> > nubBy isPrefixOf . sort $  ["/foo","/foo/bar","/foo/bar/baz","/qux","/qux/wibble"]
14:29:09 <koeien> no "lambdabot: " in front
14:29:10 <lambdabot>   [""]
14:29:10 <lambdabot>   ["/foo","/qux"]
14:29:25 <Gracenotes> that's why one should reverse the list, no?
14:29:26 <osfameron> augustss: the nubBy I'm using required the flip
14:29:41 <augustss> osfameron: which ghc version?
14:29:41 <inv> lambdabot: @help
14:29:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:29:47 <loadquo> inv, you can /msg lambdabot as well if you want.
14:29:48 <osfameron> The Glorious Glasgow Haskell Compilation System, version 6.6.1
14:29:53 <tromp__> u reverse to have the longer ones first
14:29:57 <pleed> hello
14:30:04 <inv> loadquo: sorry, I'm going there
14:30:07 <augustss> osfameron: ah, they might have changed nubBy in 6.10
14:30:18 <osfameron> that's rather silly of them :-)
14:30:19 <dolio> > nubBy (flip isPrefixOf) . sortBy (flip compare) $ ["/foo","/foo/bar","/foo/bar/baz","/qux","/qux/wibble"]
14:30:20 <lambdabot>   ["/qux/wibble","/foo/bar/baz"]
14:30:27 <Gracenotes> *success*
14:30:34 <dolio> , nubBy (flip isPrefixOf) . sortBy (flip compare) $ ["/foo","/foo/bar","/foo/bar/baz","/qux","/qux/wibble"]
14:30:35 <lunabot>  luna: Couldn't match expected type `[[a]]'
14:30:48 <dolio> Oh, right.
14:30:57 <osfameron> dolio: isn't sortBy (flip compare) the same as reverse . sort  ?
14:31:03 <tromp__> yep
14:31:05 <augustss> what's wrong with luna?
14:31:16 <osfameron> ah I suppose it's lazier?
14:31:17 <Gracenotes> osfameron: extensionally... but it might not be as efficient (I don't know, though)
14:31:24 <dolio> osfameron: Yes, but it sorts it in reverse order immediately instead of sorting in order and reversing it afterwards.
14:31:42 <dolio> augustss: luna doesn't do qualified imports, so right now sortBy is from uvector-algorithms.
14:31:45 <augustss> the flip comapre one is most likely more efficient
14:31:51 <pumpkin> :o
14:32:00 <augustss> dolio: that's crazy!
14:32:04 <ray> craaaaaaazy!
14:32:05 <pleed> If haskell evaluates an expression for example f :: [a] -> Int  ,  f a -> Int and i do  f g a while g is a function returning a List, is haskell so lazy it throws g a into f because it knows g's return type or does it expand g a first?
14:32:09 <Gracenotes> o:
14:32:16 <dolio> I think mmorrow is working on a new version with qualified imports. :)
14:32:34 <Gracenotes> hooray (?)
14:32:44 <koeien> pleed: you meen, f :: [a] -> Int, and   f (g a)  ?
14:32:49 <pleed> yes
14:33:03 <pleed> and g :: Int -> [Int]
14:33:08 <koeien> it's call-by-need
14:33:24 <koeien> so "from the outside"
14:33:28 <augustss> pleed: f will be called before g
14:33:43 <augustss> pleed: g only if necessary
14:33:54 <koeien> (although, the compiler might know that calling g first is more efficient; but only if the semantics are the same)
14:33:55 <adept> Hi. Say, what has changed WRT building/linking c-sources in GHC 6.10?
14:34:00 <pleed> augustss: where does haskell know if it s necessary in this case?
14:34:10 <pleed> augustss: does it look what return type g ist?
14:34:14 <augustss> pleed: if f uses its argument
14:34:21 <dolio> , apply sort (toU [10,9..1])
14:34:23 <lunabot>  toU [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
14:34:28 <koeien> pleed: e.g.    g x = [2,3,4], and f = length
14:34:58 <koeien> pleed: then,  f (g undefined) = length (g undefined) = -- at this moment g will be called
14:34:59 <adept> Or I try it another way - anyone got bloomfilter running with GHC 6.10?
14:35:04 <pleed> but g maybe doesnt return a list
14:35:11 <pumpkin> dolio: I have an updated version of uvector with a couple of minor bug fixes on patch-tag
14:35:18 <augustss> pleed: it must, otherwise it doesn't type check
14:35:27 <koeien> pleed: you mean if g goes in a loop?
14:35:44 <pleed> koeien: maybe g :: Int -> Int
14:35:54 <dolio> pumpkin: What kind of bug fixes?
14:35:55 <augustss> pleed: type error
14:35:56 <koeien> that is not possible, the compiler will complain in this case
14:36:26 <koeien> > let g :: Int -> Int; g x = x + 1; f :: [Int] -> Int; f = length in f (g 37)
14:36:27 <pumpkin> dolio: just off-by-ones mostly, along with some minor divergences from List behavior for some functions
14:36:27 <lambdabot>   Couldn't match expected type `[Int]' against inferred type `Int'
14:36:31 <koeien> you see?
14:36:32 <pleed> augustss: so when haskell sees f g a , it looks for g's return type and if it matches, it does length g a ?
14:36:39 <augustss> pleed: and types can be determined without evaluating the functions
14:36:43 <_Dae_> anyone know how obsidian is comming along these days?
14:36:47 <koeien> pleed: please mind your parentheses; f (g a) is different from f g a
14:36:48 <pleed> augustss: ah thanks, ok
14:37:01 <dolio> Ah. uvector-algorithms doesn't really use the UArr segment.
14:37:11 <koeien> pleed: haskell is statically typed; it can infer the types at compile-time
14:37:19 <pumpkin> dolio: ah, alright
14:37:32 <dolio> I'm still waiting for my memcpy patch to get in. :)
14:37:42 <dolio> And unsafeZipMU or something like that.
14:37:52 <inv> should I use hugs ?
14:38:07 <koeien> inv: i prefer ghc
14:38:14 * Badger hugs inv
14:38:17 <pumpkin> ah :)
14:38:19 <koeien> i think most people do (correct me if i'm wrong)
14:38:52 <knapr> is haskell suited for a program that uses a lot of randomizing functions? and if you add a lot of dynamic evals to that... lisp(clojure) is a better choice?
14:38:52 <inv> I tried to do take 10 $! reverse $ take 100000 $ repeat '1' in hugs - answer is stack overflow
14:38:54 <koeien> inv: also, the book RWH uses GHC for its examples
14:39:26 <inv> lambdabot works fine - do it use ghc ?
14:39:29 <inv> does
14:39:32 <koeien> inv: lambdabot uses ghc
14:40:06 <ray> @faq Is haskell suited for a program that uses a lot of randomizing functions?
14:40:07 <lambdabot> The answer is: Yes! Haskell can do that.
14:40:28 <Badger> @faq can Haskell send benmachine insane?
14:40:28 <lambdabot> The answer is: Yes! Haskell can do that.
14:40:40 <knapr> but seriously
14:40:41 <benmachine> quite so.
14:40:59 <koeien> knapr: in fact, i believe random numbers are very elegant in haskell. but i'm biased, obviously
14:41:16 <augustss> knapr: what do you mean by dynamic evals?
14:41:24 <pumpkin> what's going on with http://www.haskell.org/haskellwiki/AI btw?
14:41:44 <knapr> my point is the monads that harass and stalk you can eb a pain in the ass, so if your program uses them everywhere, dont they just get in the way?
14:41:45 <knapr> (eval '(+ 1 2 3)) -> 6 at runtime
14:41:48 <knapr> creating functions at runtime
14:42:18 <koeien> knapr: that is not possible in run-time; unless you do some really freaky stuff like compiling ghc in
14:42:30 <benmachine> so guys, what is const for
14:42:33 <ddarius> koeien: eval is just a function
14:42:37 <sw17ch> :t const
14:42:39 <lambdabot> forall a b. a -> b -> a
14:42:47 <sw17ch> @src const
14:42:48 <lambdabot> const x _ = x
14:42:52 <koeien> benmachine: const discards its second argument, and always returns the first
14:43:12 <koeien> > const 37 undefined
14:43:13 <lambdabot>   37
14:43:14 <benmachine> koeien: yeah I'd worked that out... but if you were going to discard it why did you give the function a second argument?
14:43:29 <koeien> it is not useful on itself. it is sometimes useful to pass it to another function
14:43:44 <koeien> or in type class instances
14:43:46 <tromp__> const is very useful together with ap
14:43:57 <benmachine> map?
14:44:01 <koeien> no, ap :)
14:44:04 <koeien> :t ap
14:44:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:44:08 <augustss> and map
14:44:15 <idnar> / fmap
14:44:18 <tromp__> only 2 functions you need (if haskell were untyped)
14:44:18 <benmachine> oh, k
14:44:32 <augustss> benmachine: length = sum . map (const 1)
14:44:51 <koeien> :t foldr (+1) 0
14:44:52 <lambdabot> forall b. (Num b, Num (b -> b)) => [b -> b] -> b
14:45:13 <idnar> :t foldl (+1) 0
14:45:14 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
14:45:14 <lambdabot>     Probable cause: `+' is applied to too many arguments
14:45:14 <lambdabot>     In the first argument of `foldl', namely `(+ 1)'
14:45:42 <benmachine> augustss: neat
14:45:44 <benmachine> ok, thanks
14:45:46 <pumpkin> dolio: might it make sense to have a rewrite rule for apply sequences in your uvector-algorithms?
14:45:51 <idnar> :t foldl (const (+1)) 0
14:45:52 <lambdabot> forall a. (Num a) => [a] -> a
14:45:58 <idnar> > foldl (const (+1)) 0 [1..5]
14:45:59 <lambdabot>   6
14:46:05 <pumpkin> whoops
14:46:07 <pumpkin> dolio: might it make sense to have a rewrite rule for apply sequences in your uvector-algorithms?
14:46:35 <dolio> Probably. I hadn't really thought about that.
14:46:45 <pumpkin> I'm not sure how exactly you can chain two STs up
14:47:05 <pumpkin> but apply f . apply g $ u seems like it only really needs one copyMU
14:48:24 <dolio> Right. I'll have to think about it.
14:48:46 <dolio> maybe apply f . apply g = apply (\a -> g a >> f a)
14:49:13 <pumpkin> that would make sense
14:49:13 <BMeph> What kinds of algorithms use trees that only store values at the tips ('Tip' s)? :)
14:52:07 <ski_> BMeph : huffman decoding ?
14:52:29 <vixey> BMeph, Prolog execution (although there is usually more (mutable) stuff on the tree)
14:53:18 <smtms> tips? is that the same as leaves?
14:53:46 <BMeph> smtms: Yes. :)
14:54:43 <BMeph> smtms: It's winter in the N hemisphere, y'know... ;)
14:54:57 <magthe> anyone from seereason hanging out in here?
14:55:19 <pumpkin> I didn't know compute science trees were deciduous
14:55:55 <koeien> why is "Hask", the category of haskell types as objects + functions as arrows, not a "real" category?
14:56:01 <koeien> because of seq ?
14:56:36 <dolio> Yes.
14:56:38 <ddarius> koeien: seq causes one problem
14:57:18 <koeien> ddarius: is there another one then ? :-)
14:57:55 <djahandarie> ddarius, whoa, your name is my name. :o
14:58:19 <ddarius> djahandarie: Except my nick isn't my name.
14:58:27 <pumpkin> lol
14:58:30 <Tobsan> lol
14:58:34 <djahandarie> -_-
14:58:39 <ddarius> djahandarie: There's a Darius Bacon that comes around every now and then.
14:58:51 <djahandarie> I've seen him on the Google Search results
14:58:56 <ozy`> I still don't "get" instances x_x
14:59:07 <ozy`> "Illegal instance declaration for `Num (a -> [a])'"
14:59:09 <ddarius> koeien: I suspect that without seq Haskell can form a category.  It still isn't a terribly pretty category.
14:59:10 <ozy`> blargh
14:59:16 <pumpkin> djahandarie: you can still remark "whoa, your nick is my name. :o" if that makes you feel any better
14:59:25 <dolio> koeien: Lifted tuples are a problem, I think.
14:59:38 <ddarius> ozy`: That's not a legal instance head in Haskell 98.
14:59:39 <koeien> dolio: what's a "lifted tuple"?
14:59:57 <dolio> In haskell, _|_ is distinct from (_|_,_|_).
14:59:59 <SamB_irssi> koeien: well, they aren't strict
15:00:00 <dolio> And so on.
15:00:18 <koeien> dolio: yes, i know. but that is also true for  (Tuple a b) right?
15:00:26 <dolio> Yes.
15:00:29 <SamB_irssi> true
15:00:42 <djahandarie> pumpkin, -_-
15:00:59 <koeien> but why would that be a problem?
15:01:14 <dolio> I seem to recall them not being categorical products.
15:01:18 <dolio> But I forget the specifics.
15:01:23 <koeien> okay
15:01:52 <jganetsk> sorry for my lack of knowledge, but why does seq mess up the category?
15:02:04 <dolio> > undefined `seq` ()
15:02:06 <lambdabot>   * Exception: Prelude.undefined
15:02:10 <dolio> > (id . undefined) `seq` ()
15:02:12 <lambdabot>   ()
15:02:40 <koeien> jganetsk: with seq, you can see the difference between 'undefined' and 'const undefined'
15:02:58 <koeien> (which is the same problem as dolio showed, if i see this correctly)
15:03:00 <dolio> In a category, id . f = f.
15:03:12 <ozy`> > const undefined undefined
15:03:14 <lambdabot>   * Exception: Prelude.undefined
15:03:24 <Gracenotes> what's the relation of undefined to _|_?
15:03:30 <koeien> it's the same
15:03:39 <koeien> just a convenient representation of it
15:03:48 <ozy`> Gracenotes: undefined represents one of the possible values of _|_
15:03:51 <Gracenotes> hm, they seemed similar
15:03:52 <ozy`> well
15:03:54 <ozy`> "values"
15:04:03 <ozy`> the other major one being an infinite loop :p
15:04:04 <Gracenotes> most _|_s that I've seen are 'never terminating'
15:04:10 <Gracenotes> yeah
15:04:12 <koeien> Gracenotes: yes. semantically they're the same
15:04:26 <koeien> it's just inconvenient if your program loops if you write head []
15:04:27 <Gracenotes> immediately halting and never halting?
15:04:40 <BMeph> ozy': "Interpretations"?
15:04:47 <ozy`> BMeph: sure
15:04:53 <BMeph> :)
15:05:08 <Gracenotes> > let i = i in i
15:05:18 <loadquo> > fmap (fmap (+10) (\x -> if (x ==10) then 100 else 8)) (+10)  10
15:05:20 <lambdabot>   18
15:05:23 <lambdabot>   thread killed
15:05:57 <hasMeta> could somebody please have a look at my code? http://rafb.net/p/xlrNN893.html -> line 13 -> parse error on '='
15:06:28 <ozy`> hasMeta: are you indenting with tabs?
15:06:30 <ray> > let thread killed = thread killed in thread killed
15:06:32 <lambdabot>   Not in scope: `killed'
15:06:34 <koeien> hasMeta: tabs?
15:06:38 <trofi> :]
15:06:42 <koeien> hasMeta: spaces are preferred.
15:06:47 <Gracenotes> > let o o = o in o "this is identity, weirdly"
15:06:49 <lambdabot>   "this is identity, weirdly"
15:07:08 <ozy`> hasMeta: you have to line up the contents of a [where|do|let|of] block exactly
15:07:13 <loadquo> > fmap (fmap (+10) (\x -> if (x ==10) then x + 100 else  x+ 8)) (+10)  10
15:07:16 <lambdabot>   38
15:07:22 <ray> it's identity because otherwise you'd get one of those occurs check thingies
15:07:38 <hasMeta> I'll give it a try
15:07:42 <loadquo> > fmap (fmap (+10) (+8)) (+10)  10
15:07:44 <lambdabot>   38
15:07:48 <Gracenotes> of course, it's fine if you think of it as o = (\o -> o)
15:08:08 <idnar> > let o o o = o o in o
15:08:09 <lambdabot>       Conflicting definitions for `o'
15:08:09 <lambdabot>      In the definition of `o'
15:08:13 <idnar> heh
15:08:17 <koeien> lol
15:08:18 <loadquo> > fmap (fmap (+10) (\x -> if (x ==0) then x + 100 else  x+ 8)) (+10)  10
15:08:20 <lambdabot>   38
15:08:28 <loadquo> > fmap (fmap (+10) (\x -> if (x ==20) then x + 100 else  x+ 8)) (+10)  10
15:08:30 <lambdabot>   130
15:08:38 <idnar> YO DAWG WE HERD YOU LIKE DEFINITIONS
15:08:41 <Gracenotes> > (\a a -> a) yes no
15:08:42 <lambdabot>       Conflicting definitions for `a'
15:08:42 <lambdabot>      In a lambda abstractionNot in scop...
15:08:48 <Gracenotes> > (\a -> \a -> a) yes no
15:08:49 <lambdabot>   Not in scope: `yes'Not in scope: `no'
15:08:58 <Gracenotes> oh, yeah :P well, it'd work
15:09:04 <idnar> > ?x
15:09:05 <lambdabot>       Unbound implicit parameter (?x::a)
15:09:05 <lambdabot>        arising from a use of `e_111'...
15:09:11 <ozy`> > (\a -> \a -> a) "yes" "no"
15:09:13 <lambdabot>   "no"
15:09:15 <ray> yo dawg i herd you like definitions so we put definitions in your definitions so you can define identity while you define identity
15:09:37 <ozy`> > flip (\a -> \a -> a) "yes" "no"
15:09:38 <lambdabot>   "yes"
15:11:12 <mIGu> hi, I need to compile a utility using ghc and I'm getting these errors: http://pastebin.com/d3afb4cea I'm not familiar with Haskell, can anyone give a hint how to fix those?
15:11:44 <jeffz`> mIGu: pass --make to ghc
15:11:46 <Heffalump> mIGu: add -package containers to the command line
15:12:10 <hasMeta> http://rafb.net/p/kO1RyW20.html -> parse error on input "removeTags"
15:12:17 <Heffalump> given that the command-line is already fairly specific about what it wants, my suggestion is probably cleaner, but jeffz`s would work too
15:12:29 <magthe> well, well, no luck in finding any seereason people it seems
15:12:38 <magthe> I'd better be off to bed instead then
15:12:51 <hasMeta> argh ok, got it
15:12:57 * wli wonders what's with ghc-6.10.1 vs. readline.
15:13:43 <mIGu> ok, -package containers fixed the error, thanks :-)
15:15:13 <dolio> > (undefined &&& undefind >>> fst) `seq` ()
15:15:14 <lambdabot>   Not in scope: `undefind'
15:15:19 <dolio> > (undefined &&& undefined >>> fst) `seq` ()
15:15:21 <lambdabot>   ()
15:16:41 <Gracenotes> oh, nice, the topic is a Haskell list! Just like in #scheme
15:16:51 <Gracenotes> except it's malformed :/
15:17:00 <hasMeta> stupid question: what's the difference between sequencing with $ and composition '.'
15:17:17 <Gracenotes> (well, #scheme isn't a Haskell list)
15:17:25 <ozy`> hasMeta: composition -always- returns a new function
15:17:29 <loadquo> @src $
15:17:29 <lambdabot> f $ x = f x
15:17:31 <newsham> > foldr (const . Just) Nothing [1..]
15:17:33 <lambdabot>   Just 1
15:17:39 <loadquo> @src (.)
15:17:39 <lambdabot> (f . g) x = f (g x)
15:17:51 <hasMeta> great, thanks!
15:17:59 <ddarius> newsham: Now write tail using foldr.
15:18:18 <vixey> write O(1) tail using foldr
15:18:22 <newsham> hrmm.. do I hafta?
15:18:46 <Gracenotes> use qubits for extra credit
15:19:14 <idnar> tail using foldr, eek
15:19:48 <djsiegel> Hi, who cna I talk to about pandoc?
15:19:52 <djsiegel> I have an encoding issue.
15:20:09 <Gracenotes> may help:
15:20:10 <Gracenotes> @src foldr
15:20:11 <lambdabot> foldr f z []     = z
15:20:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:20:33 <hackage> Uploaded to hackage: mathlink 1.0.0.1
15:20:33 <hackage> Uploaded to hackage: hsx 0.4.8
15:20:33 <hackage> Uploaded to hackage: mathlink 1.0.0.0
15:22:10 <wli> What's mathlink, I wonder?
15:22:21 <pumpkin> tail using foldr is easy!
15:22:25 <pumpkin> ;)
15:22:44 <ddarius> pumpkin: It is if you have no sensibilities.
15:22:45 <pumpkin> > foldr (const tail) [1,2,3] [()]
15:22:47 <lambdabot>   [2,3]
15:22:48 <pumpkin> :P
15:22:57 <pumpkin> I guess that's what you meant :)
15:22:59 * wli wonders what happened to gslhaskell
15:23:06 <idnar> pumpkin: cheating :P
15:23:07 <ddarius> pumpkin: Nope.
15:23:24 <Gracenotes> oh, I confused last and tail. :/ last is a bit easier to write, it seems
15:23:26 <jganetsk> i think i hve it
15:23:29 <idnar> Gracenotes: yeah
15:23:36 <idnar> Gracenotes: I still can't work tail out
15:23:52 <Gracenotes> does tail with foldr use corecursion?
15:24:07 <idnar> I was thinking you have to stash the head somewhere so you can use it, but I don't know how to drop it from the final result
15:24:26 * vixey is trying to not give away the secret
15:25:02 <Gracenotes> the answer being of the form foldr (something) something theList, right?
15:25:50 <jganetsk> fst (foldr (\v acc -> (snd acc, v:(snd acc))) (undefined, [])
15:25:52 <Gracenotes> and not something with pattern-matching in the args, i.e. tail (x:xs)
15:25:54 <pumpkin> here's a really ugly one
15:25:56 <pumpkin> > snd $ foldr(\x (f, acc) -> (True, if f then x:acc else acc)) (False, []) [1,2,3]
15:25:58 <lambdabot>   [1,2]
15:26:02 <pumpkin> oh whoops, wrong one
15:26:05 <pumpkin> that's init :)
15:26:24 <jganetsk> > (fst (foldr (\v acc -> (snd acc, v:(snd acc))) (undefined, [])) [1,2,3]
15:26:26 <lambdabot>   <no location info>: parse error on input `;'
15:26:31 <jganetsk> oops
15:26:46 <dolio> koeien: I think the problem with _|_ /= (_|_,_|_) is that, for instance, there are two functions (a,b) -> (a,b): \p -> (fst p, snd p) and \p -> p.
15:27:00 <dolio> So (a,b) isn't terminal.
15:27:27 <jganetsk> fst . foldr (\v acc -> (snd acc, v:(snd acc))) (undefined, [])
15:27:38 <ddarius> dolio: That's one way of putting it.  I'd just cast the universal property in equational form.
15:27:46 <vixey> :t fst . foldr (\v acc -> (snd acc, v:(snd acc))) (undefined, [])
15:27:47 <lambdabot> forall a. [a] -> [a]
15:27:49 <idnar> pumpkin: the snd seems like cheating
15:27:58 <pumpkin> idnar: true :) and it wasn't right anyway
15:27:59 <idnar> or fst, whichever
15:28:04 <Gracenotes> @check \p -> (fst p, snd p) == p
15:28:04 <pumpkin> that was init, and the other one is last
15:28:05 <lambdabot>   "OK, passed 500 tests."
15:28:21 <Gracenotes> they're at least equal in that sense, no?
15:28:24 <idnar> if you get to use other random functions, then you might as well just use "foldr (const tail) [1,2,3] [()]"
15:28:27 <jganetsk> > (fst . foldr (\v acc -> (snd acc, v:(snd acc))) (undefined, [])) [1,2,3]
15:28:29 <lambdabot>   [2,3]
15:28:31 <vixey> Grace, the total fragment yes
15:28:33 <jganetsk> why is that wrong?
15:28:34 <idnar> (functions outside the fold, I mean)
15:28:41 <ozy`> @check "pizza"
15:28:42 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
15:28:42 <lambdabot>           ...
15:28:57 <idnar> jganetsk: I don't know that it's wrong, it just seems like cheating to me, because it's more than "just" a foldr
15:28:58 <jganetsk> no functions outside the fold?
15:29:07 <idnar> on the other hand, I'm not entirely sure it's possible to do better than that
15:29:07 <jganetsk> ok
15:29:20 <jganetsk> that's how you would write tail in System F
15:29:46 <jganetsk> wait, who asked the question?
15:29:54 <jganetsk> vixey?
15:30:00 * vixey  
15:30:00 <pumpkin> ddarius
15:30:13 <Gracenotes> ddarius has already readied the getaway car and escaped from here, using this impossible problem as a diversion
15:30:17 <pumpkin> lol
15:31:42 <idnar> Gracenotes: haha
15:32:18 <Philonous> > let tail' = flip (foldr (\a b c -> a  `c`(b (:))) (\_ -> [])) (flip const)  in tail' [1,2,3,4,5]
15:32:20 <lambdabot>   [2,3,4,5]
15:34:27 <Philonous> Does that count?
15:34:31 * SamB_irssi wants to see something like http://domino.research.ibm.com/comm/research_projects.nsf/pages/metronome.tenedor.html for use with Haskell ...
15:34:39 <vixey> @let list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
15:34:42 <lambdabot>  Defined.
15:34:44 <vixey> @let rec = fix
15:34:47 <lambdabot>  Defined.
15:34:54 <vixey> case & rec all you need :p
15:36:32 <ksf> SamB_irssi, hp2ps?
15:36:43 <Gracenotes> heh. To find a function in good-style C++, you can grep for "::func" ... to find it in good-style Haskell, you can do "func ::"
15:36:52 <SamB_irssi> ksf: hp2ps is not exactly flexible ...
15:37:12 <dolio> ddarius: I'm having a bit more trouble coming up with an example for sums.
15:37:21 <SamB_irssi> obviously GHC already has a lot of useful infrastructure ...
15:37:26 <vixey> dolio, example of what?
15:38:42 <dolio> Haskell sums not being categorical sums.
15:38:53 <ksf> Clicking on a spike in the graph and being pointed to associated could would be cool, of course.
15:38:54 <koeien> dolio: (re category theory) thanks
15:39:39 <jganetsk> what are we still doing the fold thing?
15:40:28 <ksf> come on, someone dispute my rant on the cafe. I feel like flaming.
15:41:26 <drdozer> ksf: I'm all done ranting - just had some fundies on facebook telling me that slavery is fine because the bible says so, and in the same posts that the bible doesn't condone slavery
15:41:39 <drdozer> ksf: I'm all rant/flamed out for the day
15:42:13 <ksf> well, just ask them for their address, I bet you can use some cheap workers.
15:42:17 <Gracenotes> Discussions via Facebook groups arguably rot the brain
15:42:20 <mle> @pl (\_ a -> a+1)
15:42:20 <lambdabot> const (1 +)
15:42:26 <mle> >_<
15:42:31 <dolio> ksf: About GUI toolkits?
15:42:35 <ksf> yeah.
15:43:02 <dolio> There have been pure ones proposed in papers and stuff.
15:43:04 <drdozer> are there any good GUI toolkits? I've not used any yet but may need to soon
15:43:07 <dolio> Like GUI = Time -> Picture.
15:43:20 <osfameron> augustss, dolio: http://greenokapi.net/blog/2009/01/27/theres-the-nub-snippet-in-perl-and-haskell/ (thanks for the improvements!)
15:43:30 <drdozer> anything to avoid Java/Swing
15:43:37 <ksf> that's about the type of fieldtrip.
15:44:14 <ksf> UI -> Behaviour Geometry where UI is a record of Behaviour MousePos and so on
15:44:43 <pumpkin> osfameron: building a trie is still a lot more efficient than doing a nubBy :)
15:44:57 <dolio> Anyhow, writing a GUI system from scratch is a lot of work.
15:45:06 <ksf> I once did it in a day.
15:45:10 <dolio> And then it doesn't fit in with any other GUI on the system. :)
15:45:14 <ksf> Not a full-featured one, mind you.
15:45:32 <ksf> but then, without having reactive.
15:46:16 <ksf> any properly-designed gui is different enough from any other gui that it deserves to have its own look, anyway.
15:46:30 <ksf> ...because a gui feels like it feels, not like the toolkit behaves.
15:46:40 <dolio> Personally, I still have hope for first figuring out what a good Haskell GUI library would be like, and then afterwards figuring out how to back it up with existing toolkits.
15:46:43 <dolio> But maybe that's naive.
15:46:51 <osfameron> pumpkin: I guess so... it's not as clearly a single pass as the simple fold either if it's having to check every nub each time
15:46:55 <ksf> I think it's the right approach.
15:47:00 <osfameron> @src nubBy
15:47:00 <lambdabot> nubBy eq []             =  []
15:47:00 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:47:10 <ksf> ...especially because you can just ignore the last part.
15:47:38 <pumpkin> osfameron: you italian?
15:47:43 <ksf> those grapefruit examples, for example, look like line noise to me.
15:48:05 <osfameron> pumpkin: no, but I've spent quite a lot of time there
15:48:12 <pumpkin> ah :)
15:48:25 <dolio> Well, I like that the majority of the widgets in my web browser look and act like the majority of the widgets in my mail client, and so on.
15:48:37 <Gracenotes> dolio: for the limited GUI programming I've done in Haskell, I wonder if one library is inherently more 'Haskell-y' than another
15:48:57 <Gracenotes> even among the C-based ones
15:49:00 <osfameron> hmmm, I probably want an abstraction like nubBy but without the wrapping of filters
15:49:38 <dolio> Gracenotes: Writing GTK event code in the IO monad isn't what I'd call an ideal Haskell program. :)
15:49:53 <ksf> gracenotes, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=977#a977
15:49:58 <ksf> foo is haskell, main isn't.
15:50:11 <dolio> But my experience with GUI stuff in Haskell is pretty limited.
15:50:12 <osfameron> 'smushBy' or something like that.  With the unixy 'uniq' semantics of requiring a sorted list
15:50:21 <Gracenotes> dolio: well, you will sometimes need to use IO in GUI actions
15:50:26 <defun> how is "map read . lines" different from "map read lines"
15:50:47 <ksf> :t map read . lines
15:50:48 <lambdabot> forall a. (Read a) => String -> [a]
15:50:50 <Olathe> Well, map read lines is fine if lines is a list.
15:50:50 <ksf> :t map read lines
15:50:52 <lambdabot>     Couldn't match expected type `[String]'
15:50:53 <lambdabot>            against inferred type `String -> [String]'
15:50:53 <lambdabot>     In the second argument of `map', namely `lines'
15:50:58 <ksf> that's the difference.
15:51:04 <wli> :t fmap read lines
15:51:06 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
15:51:07 <lambdabot>       Expected type: String -> String
15:51:07 <lambdabot>       Inferred type: String -> [String]
15:51:16 <defun> hmm
15:51:20 <defun> ok
15:51:20 <Gracenotes> e.g., I'd imagine reversing a string wouldn't use IO...
15:51:28 <Gracenotes> although it looks neat :)
15:52:23 <Olathe> > let uniq = map head.group in uniq [1, 1, 5, 3, 1]
15:52:24 <lambdabot>   [1,5,3,1]
15:52:57 <mak__> nub ?
15:53:01 <osfameron> Olathe: rarr!
15:53:11 <jganetsk> are we igving up on tail?
15:53:16 <ksf> yeah, I've got rid of Monad IO and got caught in Applicative Behaviour instead...
15:53:23 <vixey> jganetsk, I thought you got it already
15:53:51 <jganetsk> i thought what i did was cheating?
15:53:54 <jganetsk> no?
15:53:59 <Gracenotes> reactive programming does look muy interesante
15:54:05 <idnar> so if we have applicative functors, why don't we have monadic functors instead of monads?
15:54:09 <jganetsk> did my solution count?
15:54:49 <jganetsk> i thought there was some bigger secret
15:55:03 <ksf> because back when monads where introduced, people just wanted to do IO without pulling out their hair.
15:55:21 <idnar> to be clear, I'm referring to the name, not the typeclass hierarchy
15:55:22 <vixey> jganetsk, no you got pretty much what I was thinknig of
15:55:34 <vixey> jganetsk, can't remember where but I read there was a proof of it being impossible in O(1) time
15:56:37 <Gracenotes> is any tail possible in O(1) time?
15:56:51 <vixey> well I say tail (_:xs) = xs  is O(1)
15:56:59 <Gracenotes> oh, wait. Confusing it with last again :/
15:57:00 <idnar> I say it's O(N) >:)
15:57:27 <ksf> about the only thing that puzzles me right now is how to do the feedback loop "widget wants a specific size" -> container -> "widget gets another size"
15:57:46 <idnar> okay, I guess it really isn't
15:58:08 <ksf> I also fear that I'm going to end up with a cloud of typeclasses if I don't pay attention.
15:58:20 <Gracenotes> is there any subset of problems FRP is particularly good for?
15:58:25 <idnar> ksf: better wear a class mask
15:58:30 <idnar> ksf: inhaling that stuff is bad for your lungs
15:58:51 <ksf> anything that's got to do with time.
15:59:19 <idnar> Gracenotes: world domination!
15:59:31 <Gracenotes> for anything that can change at any arbitrary time?
15:59:49 <idnar> did anyone ever figure out what was up with the OI comonad?
15:59:51 <ksf> for event streams and behaviours over time and messing with them.
16:00:09 <Gracenotes> hm.. does it react in real time, or only when a property is read?
16:00:18 <ksf> it's both push and pull.
16:00:20 <wli> If Lisp/Scheme are red pills, then Haskell is a glow-in-the-dark magenta or fuchsia pill?
16:00:21 <idnar> I'd generalise to "event-driven"
16:00:25 <ksf> reactive, that is, not FRP in general.
16:00:42 <ksf> there is no pill.
16:01:27 <idnar> the pill is a lie
16:01:48 <ksf> you know, push sucks because it computes more than necessary, and pull sucks because it lags.
16:03:33 <ksf> gracenotes, http://conal.net/papers/simply-reactive/ , if you dare.
16:03:39 <drdozer> @curry3
16:03:39 <lambdabot> Unknown command, try @list
16:03:46 <osfameron> @pl (\eq -> map head . groupBy eq)
16:03:47 <lambdabot> (map head .) . groupBy
16:03:54 <osfameron> gah, .).
16:04:06 <pumpkin> I enjoy that
16:04:16 <idnar> osfameron: it's the sailboat operator!
16:04:27 <Gracenotes> *looks*
16:04:37 <osfameron> my brane fails at partially applied composition
16:04:47 <idnar> what about that semantic editor stuff?
16:04:49 <wli> @pl \eq -> catMaybes . map listToMaybe . groupBy eq
16:04:50 <lambdabot> ((catMaybes . map listToMaybe) .) . groupBy
16:05:20 * idnar tries to figure out what that would be
16:05:34 <idnar> @type result
16:05:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:05:40 <idnar> @type argument
16:05:41 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
16:05:51 <idnar> @type (\eq -> map head . groupBy eq)
16:05:52 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
16:05:58 <drdozer> mm - is there really no curry3?
16:06:38 <idnar> @type result (map head) . groupBy
16:06:39 <ski_> @djinn ((a,b,c) -> d) -> (a -> (b -> (c -> d)))
16:06:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
16:06:40 <lambdabot> f a b c d = a (b, c, d)
16:06:45 <idnar> oh, duh
16:07:20 <ksf> idnar, yes, reactive makes excessive use of fmap.
16:07:53 <Gracenotes> @djinn ((a,b,c) -> d) -> (a -> b -> c -> d)
16:07:53 <lambdabot> f a b c d = a (b, c, d)
16:08:07 <Gracenotes> oh... yeah, confused direction of associativity, darn
16:08:54 <osfameron> pumpkin, Olathe: updated post with a uniqBy version, thanks
16:09:00 <idnar> @type fmap
16:09:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:09:59 <ksf> @type Applicative.(<*>)
16:10:01 <lambdabot> Not in scope: data constructor `Applicative'
16:10:10 <ksf> @type (<*>)
16:10:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:10:16 <ksf> that's cool, too.
16:10:38 <ski_> @type (Applicative.<*>)
16:10:39 <lambdabot> Couldn't find qualified module.
16:10:55 <ksf> it's Control.Applicative
16:10:57 <idnar> @type fmap (map head) . groupBy
16:10:58 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
16:11:02 <idnar> that /almost/ makes sense to me
16:11:06 <ski_> @type (Control.Applicative.<*>)
16:11:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:11:33 <idnar> (r->) monad still makes my head hurt, though
16:12:06 <ksf> wait 'till you get to (fmap.fmap)
16:12:11 <ski_> idnar : why so ?
16:12:13 <ksf> :t (fmap.fmap.fmap.fmap)
16:12:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
16:12:34 <idnar> ksf: I just somehow can't wrap my head around it
16:12:43 <idnar> ksf: I always have to mentally expand everything for it to make any sense
16:12:50 <roconnor> ``This paper describes how a simple partial evaluator can be used to avoid the need for dictionary values at run-time by generating specialized versions of overloaded functions.
16:12:55 <ksf> http://www.haskell.org/pipermail/reactive/2008-November/000054.html
16:13:05 <roconnor> ``Furthermore, and somewhat surprisingly given the presence of multiple versions of some functions, for all of the examples that we have tried so far, specialization actually leads to a reduction in the size of compiled programs.
16:13:09 <roconnor> sweet
16:13:18 * idnar ponders <*> for (r->)
16:13:28 <Gracenotes> ksf: isn't Reader just a wrapped version of the (r->) monad?
16:13:37 <Gracenotes> er, idnar.
16:13:44 <idnar> Gracenotes: yes
16:13:56 <roconnor> aww, this was in 1994
16:14:00 <idnar> (r -> a -> b) -> (r -> a) -> r -> b ?
16:14:18 <idnar> bleh
16:14:21 <ski_> @type \f g x -> (f x) (g x)
16:14:22 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
16:14:23 <dobblego> idnar, <*> = ap
16:14:39 * dobblego points to the s in ski_ 
16:14:57 <idnar> dobblego: yeah, I know
16:15:07 <dobblego> @type ap
16:15:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:15:12 * idnar scratches his head
16:15:23 <idnar> oh, right
16:15:36 * ksf just pattern-matches the types.
16:15:49 <dobblego> replace every occurrence of m with ((->) r)
16:15:52 <dobblego> (((->) r) (a -> b)) -> ((->) r a) -> ((->) r) b
16:16:01 <travisbrady> anyone know why I'd get this error "extensible-exceptions -any, network-bytestring >=0.1.1.2 && <0.2" when trying to install hyena?  i have both of those packages installed via cabal install
16:16:09 <idnar> that's how I got  (r -> a -> b) -> (r -> a) -> r -> b
16:16:16 <Gracenotes> @type \f g x -> id (f x) (g x)
16:16:17 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
16:16:22 <dobblego> (r -> a -> b) -> (r -> a) -> (r -> b)
16:16:22 <idnar> oh well, guess it's just a matter of reading and writing more code
16:16:37 <dcoutts> travisbrady: are you installing via cabal install or runghc Setup ?
16:17:02 <travisbrady> dcoutts: runhaskell Setup.hs configure
16:17:25 <dcoutts> travisbrady: there's no need to use runghc Setup since you've got cabal install
16:17:36 <rwbarton> idnar: Conceptually, you're just applying a function depending on, say, time, or whatever, to a value that also depends on time, which is simple enough
16:17:38 <Gracenotes> hrm
16:17:49 <travisbrady> dcoutts: Hyena isn't available via cabal install
16:18:10 <dcoutts> travisbrady: but you can run "cabal install" from the directory its in
16:18:23 <rwbarton> idnar: it's just when people replace every single occurrence of \x -> (f x) (g x) with f <*> g that things get confusing
16:18:31 <travisbrady> dcoutts: yay!  thank you
16:18:35 <dcoutts> travisbrady: in general the "cabal" command has all the same command line interface as "runghc Setup"
16:18:54 <dcoutts> travisbrady: and as you've found, the defaults are different, runghc Setup does global installs by default (which cannot use user packages)
16:19:06 <ksf> ...and automagically passes --user, which is nice.
16:19:30 <dcoutts> travisbrady: so if you ever do have to use runghc Setup configure then add --user too
16:19:32 <Gracenotes> " liftA id" is like ap for (->) r, it seems...
16:19:33 <travisbrady> dcoutts: ah makes perfect sense, i have everything in ~/.cabal, thanks
16:19:50 <idnar> rwbarton: in general, I seem to have a hard time making sense of any use of ap / <*> that isn't of the form f <$> a <*> b <*> c (which just corresponds to liftAn, of course)
16:19:56 <ski_> @src ap
16:19:56 <lambdabot> ap = liftM2 id
16:20:14 <ksf> :t ($)
16:20:16 <lambdabot> forall a b. (a -> b) -> a -> b
16:20:22 <ksf> :t (<$>)
16:20:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:20:38 <ski_> @type (<<$>>)
16:20:40 <lambdabot> Not in scope: `<<$>>'
16:20:56 <rwbarton> idnar: well, writing f <*> a <*> b <*> c just means that f is varying/does IO/nondetermistic/whatever as well
16:21:01 <rwbarton> (as well as a, b, and c)
16:21:51 <dobblego> (<<$>>) = (<$>) . (<$>) would be handy
16:22:12 <ksf> fmap2 = (fmap.fmap) certainly is.
16:22:26 <dobblego> @type (<$>) <$> (<$>)
16:22:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:23:06 <idnar> <<<<<$>>>>>
16:23:07 <idnar> heh
16:23:26 <Gracenotes> @type (<*> ?a)
16:23:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f, ?a::f a) => f (a -> b) -> f b
16:23:36 <idnar> I'm fine with fmap.fmap.fmap, because you're just lifting through more than one layer of functor
16:23:44 * ksf rather uses arabic numbers than joining the church of church
16:23:56 <Gracenotes> @type (<*> (?a <*> ?b <*> ?c))
16:23:58 <lambdabot> forall (f :: * -> *) a b a1 a2. (?c::f a2, Applicative f, ?b::f a1, ?a::f (a1 -> a2 -> a)) => f (a -> b) -> f b
16:24:08 <idnar> rwbarton: well, maybe my problem is just people pulling obscure tricks with ap and (r->) and whatnot :P
16:24:47 <idnar> (f x) (g x) = f x (g x) right?
16:24:51 * ksf mumbles "designed by obfuscation"
16:24:52 * BMeph likes Scott numerals, though.
16:24:57 <Saizan> > zip`ap`tail [1..] -- !
16:24:58 <lambdabot>   Couldn't match expected type `[a] -> [b]'
16:25:05 <Saizan> > zip`ap`tail $ [1..] -- !
16:25:07 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
16:25:11 <idnar> @quote zip`ap`tail
16:25:12 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
16:25:18 <Gracenotes> idnar: yeah... irc
16:25:28 <idnar> :)
16:25:30 <ski_> @pl (f x) (g x)
16:25:30 <lambdabot> f x (g x)
16:25:40 <loadquo_> @src ap
16:25:41 <lambdabot> ap = liftM2 id
16:25:57 <idnar> for some reason I always get a bit confused about the associativity of function application when there are parentheses whizzing around
16:26:01 <idnar> which doesn't make much sense, but...
16:26:09 <BMeph> I've found ap zip .map ... a useful construct, myself. :)
16:26:37 <ozy`> :t ap zip . map
16:26:39 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
16:27:08 <rwbarton> map (id &&& f) seems clearer
16:27:29 <idnar> I agree
16:27:37 <luite_> is it possible the specify RTS defaults in a haskell source file? (for example to increase the allocation area or heap size)
16:27:43 <idnar> @type (&&&)
16:27:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:27:58 <idnar> hmm
16:28:00 <rwbarton> "ap zip" is a classic combination, though :)
16:28:08 <idnar> @type (uncurry (&&&) .)
16:28:09 <lambdabot> forall (a :: * -> * -> *) b c c' a1. (Arrow a) => (a1 -> (a b c, a b c')) -> a1 -> a b (c, c')
16:28:16 <idnar> no
16:28:32 <mak__> huh nice ;]
16:29:08 <idnar> @pl \f g h -> curry f . (g &&& h)
16:29:09 <lambdabot> (. (&&&)) . (.) . (.) . curry
16:29:12 <idnar> @type \f g h -> curry f . (g &&& h)
16:29:13 <lambdabot> forall b c a c1 c'. (((c1, c'), b) -> c) -> (a -> c1) -> (a -> c') -> a -> b -> c
16:29:23 <ski_>   graph f = id &&& f
16:29:31 <idnar> @type \f g h -> uncurry f . (g &&& h)
16:29:32 <lambdabot> forall a b c a1. (a -> b -> c) -> (a1 -> a) -> (a1 -> b) -> a1 -> c
16:29:41 <idnar> @pl \f g h -> uncurry f . (g &&& h)
16:29:41 <lambdabot> (. (&&&)) . (.) . (.) . uncurry
16:29:44 <BMeph> map (id &&& f) looks wasteful, to me. Like, you want it to "do nothing", but you can't just leave it blank, so toss an 'id' in. :)
16:29:57 <osfameron> @src (.)
16:29:57 <lambdabot> (f . g) x = f (g x)
16:30:24 <Gracenotes> i also
16:30:30 <idnar> any chance of getting "pretty" arrow syntax out of @type?
16:30:32 <ski_>   cograph f = f ||| id
16:31:28 <idnar> @type (|||)
16:31:29 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
16:31:40 <ski_> @type cograph
16:31:41 <lambdabot> forall a b. (a -> b) -> Either a b -> b
16:31:47 <ski_> @type graph
16:31:48 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
16:32:01 * loadquo_ gets puzzled by type arrow syntax as well
16:32:04 <cads> gah, anyone here read steve yegge's blog/
16:32:04 <Twey> @seen conal
16:32:05 <lambdabot> I saw conal leaving #haskell and #ghc 1d 5h 19m 45s ago, and .
16:32:17 <idnar> like (Arrow (~>)) -> (b ~> c) -> (b ~> c') -> (b ~> (c, c')) or whatever
16:32:31 <idnar> cads: I occasionally read it by accident when someone links me up
16:32:34 <idnar> *spelling
16:32:41 <ski_> (s/)) ->/)) =>/)
16:32:48 <Twey> What spelling?
16:33:12 <loadquo_> @type (~>)
16:33:13 <lambdabot> Not in scope: `~>'
16:33:18 <BMeph> cads:I've been 'yegge-rolled' as well. ;)
16:33:25 <idnar> Twey: eh, I'm hallucinating, thought I was missing a 'c'
16:33:25 <ski_> loadquo_ : `(~>)' is a type variable, there
16:33:37 <Twey> loadquo_: (Arrow (~>))
16:33:45 <ski_> (of kind `* -> * -> *')
16:33:54 <cads> gah.. he's got an article about the absolute importance of a programmer's being good typists... he made me feel ashamed of the fact that when I type a symbol I get it wrong sometimes :(
16:34:00 <cads> now I must practice
16:34:02 <ski_> @kind Monad
16:34:04 <lambdabot> Class `Monad' used as a type
16:34:08 <idnar> it's just using b ~> c instead of a b c
16:34:10 <Twey> Note that it's made entirely out of lower-case punctuation :)
16:34:26 <ski_> there ought to be a way to query for the kinds of class parameters
16:34:33 <idnar> which is easier to read in the same way that b -> c is nicer than (->) b c
16:34:35 * ksf used to miss symbols like ^ and %, too, until he learned haskell
16:34:53 <idnar> cads: haha
16:35:00 <idnar> cads: the reason I'm a good typist is IRC, not programming
16:35:02 <BMeph> idnar: Which would be more useful, if '~' were in the middle of the glyph-space (if that makes sense...). :)
16:35:17 <ksf> you can be quite sure that anyone who uses a german keyboard layout isn't a good programmer.
16:35:19 <idnar> cads: I'm typically only writing one piece of code at a time, but I regularly have three or four IRC conversations concurrently
16:35:51 <idnar> BMeph: ∼>
16:36:14 <BMeph> idnar: Genau da. ;)
16:36:24 <Twey> Haha
16:36:44 <idnar> or maybe ⊳
16:36:55 <Twey> I'm a crap typist, but I have the gift of almost always recognising my mistakes in time to backspace over them.  :)
16:36:57 <ski_> @type or maybe
16:36:58 <lambdabot>     Couldn't match expected type `[Bool]'
16:36:58 <lambdabot>            against inferred type `b -> (a -> b) -> Maybe a -> b'
16:36:58 <lambdabot>     In the first argument of `or', namely `maybe'
16:37:03 <Olathe> @@ @run let f [] = []; f ('-':'>':xs) = '\8594':f xs; f ('=':'>':xs) = '\8658':f xs; f (x:xs) = x:f xs in say $ f @show @type (|||)
16:37:06 <lambdabot>   forall (a :: * → * → *) b d c. (ArrowChoice a) ⇒ a b d → a c d → ...
16:37:07 <idnar> ⋯⊳
16:37:08 <idnar> heh
16:37:39 <idnar> Twey: I tend to "feel" mispresses when I make them, and correct them without even thinking about it
16:37:41 <cads> I feel like i'm a reasonable typist for all of my undisciplined method... it's bad when I need to consistently put in symbols though
16:37:44 <Twey> Indeed
16:37:50 <idnar> that's why a keyboard with good tactile responsiveness is essential
16:38:17 <cads> and I'll from time to time glance at the keyboard to accelerate my typing..
16:38:22 <idnar> my typing technique is a bit eccentric, though; I never "practiced" learning to type
16:38:32 <cads> as my fingers spider about the rows wildly
16:38:37 <idnar> so the way my style developed is basically that I press a key with whatever finger can reach it quickest
16:38:41 <ozy`> idnar: lucky you, having a keyboard that doesn't constantly backfire
16:38:45 <idnar> which means I use different fingers for the same key depending on what I just typed
16:38:49 <ddarius> cads: Learn Dvorak
16:39:04 <Twey> I think we should use a ↣ as the universal sign for arrows.  :-P
16:39:07 <ozy`> I have to jam on my S and K keys every ten or fifteen seconds to get them to work
16:39:12 <idnar> (it also means I can type faster than people who learned to type the "right way")
16:39:15 <Twey> Dvorak <3
16:39:21 <idnar> yeah, <3 Dvorak
16:39:27 <Twey> Dvorak saves my wrists.
16:39:30 <idnar> it didn't make my typing any faster, but my wrists thank me for switching every day
16:39:39 <Twey> Right :-D
16:40:14 <idnar> when typing on qwerty, I need to keep my wrists elevated most of the time so I can "hover" over the keys; with dvorak I can rest them most of the time
16:40:22 <idnar> so instead of taking breaks every hour, I can type forever
16:40:39 <Twey> I haven't used QWERTY for ages
16:40:46 <ski_> @type forever
16:40:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:40:50 <idnar> haha
16:40:51 <Twey> Hahaha
16:41:14 <Twey> I started to have these horrible stabbing pains through my wrists after I'd been typing for a while
16:41:17 <cads> http://steve-yegge.blogspot.com/2008/09/programmings-dirtiest-little-secret.html has motivated me to find some open source typing program in the repositories and yeah, while I'm at it learn dvorak
16:41:51 <idnar> man, I remember the weekend I first switched to dvorak
16:41:52 <cads> he beats you down with a torrent of FUD, till you're like "wow, I'd be a much better programmer if I could touch-type"
16:41:53 <Twey> So I switched to Dvorak, and after a couple of weeks of hell whilst learning it, making the most awkward motions possible, my wrists like me again.
16:41:55 <idnar> typing on IRC was so frustrating
16:42:05 <cads> then he builds you up with encouraging words.
16:42:09 <idnar> as soon as I would stop concentrating, I'd slip back into qwerty typing
16:42:16 <idnar> so I'd type out a whole paragraph
16:42:17 <idnar> hit enter
16:42:25 <idnar> and realise 95% of it was gibberish
16:42:51 * cads is thinking about rearranging the letters on his lappietop
16:43:11 * wli is wondering how to get sound working on his laptop.
16:43:13 <cads> but that'd defeat the purpose of learning to touchtype in dvorak..
16:43:17 <Olathe> I think on most keyboards the index finger keys aren't really movable.
16:43:25 <cads> wli, windows will do it.
16:43:41 <Olathe> At least, on my laptop a while back it was that way.
16:44:20 <BMeph> Get a frog (?) keyboard. :)
16:44:25 <Twey> Hahahahaha, Yegge :-D
16:44:33 <idnar> just get a blank keyboard ;P
16:44:38 <Twey> DAS KEYBOARD
16:44:41 <stulli> Did anybody cabal install leksah lately? It says "Killed" when resolving dependencies.
16:44:50 <Gracenotes> Twey: with dvorak :P
16:44:52 <Twey> « At the time our story begins, our pathetic hero Yeev is peering through his giant scratched bifocal goggles at the electives list, trying to find one that doesn't involve grease and sparks and teachers screaming for a medic, can anyone here make a tourniquet, help help help oh god my pension, and all that manly American stuff you find in Shop class. »
16:44:54 <cads> idnar, I shall apply acetone to the keys
16:44:55 <Gracenotes> oh, what hell that would be
16:44:59 <Twey> I'm starting to like this guy
16:45:06 <Twey> Gracenotes: Nah, 's OK
16:45:07 <dcoutts> stulli: you're not using cabal version 0.5.x are you?
16:45:13 <dcoutts> stulli: with ghc-6.10
16:45:16 <cads> Twey: he rambles.
16:45:24 <idnar> Twey: his writing is... entertaining
16:45:24 <cads> and is hilarious
16:45:25 <Twey> All my keyboards are still labelled as QWERTY, even though I use them as Dvorak
16:45:35 <ski_> <http://datamancer.net/keyboards/ergo1/ergo1.htm>
16:45:36 <Olathe> Mine too.
16:45:44 <idnar> typically content-free, but entertaining nonetheless
16:45:45 <idnar> :P
16:45:47 <Twey> Hehe
16:46:00 <cads> how'd you guys identify the keys while learning?
16:46:02 <Olathe> It's nice for confusing anyone who might try to use my computer.
16:46:05 <idnar> there's that crazy keyboard where the keycaps are miniature LCD displays
16:46:10 <wli> cads: Windows would prove an awkward Linux kernel programming environment at best.
16:46:18 <stulli> dcoutts, yes, 0.5.1 after i installed ghc 6.10 an hour ago
16:46:22 <idnar> cads: keep hitting keys until the right letter appears on the screen
16:46:23 <BMeph> I hate people that know how to type, but canNOT freakin' Spell to save their life! Aaugh! That's my opinion of the Ultimate waste of talent.
16:46:25 <cads> idnar, it costs $5000!
16:46:44 <dcoutts> stulli: if you've still got 6.8 installed then use that to upgrade your cabal-install version
16:46:46 <idnar> cads: it's like hunt and peck, except with the keyboard behind your back ;)
16:46:46 <Olathe> cads: It's frustrating at first getting it wrong so often, but after a month or so, you're much more accurate.
16:46:58 <stulli> dcoutts, thanks, will try that
16:47:00 <cads> surely there's a more structured way
16:47:04 <dcoutts> stulli: eg if ghc-6.8.2 is still on your path then: cabal install -w ghc-6.8.2 cabal-install
16:47:18 <Olathe> I suppose a typing tutor program wouldn't hurt.
16:47:20 <ddarius> dolio: either f g . Left = f; either f g . Right = g; either (f . Left) (f . Right) = f  As written none of these equations hold, but in particular the last does not hold when applied to undefined.
16:47:46 * cads will hunt for a little dvorak banner to invoke from a hotkey or to put on top of the rest of his windows
16:47:51 <loadquo_> I got me an alphagrip keyboard. Havn't put in the hours to learn it though.
16:47:57 <kalkin-> hi guys
16:48:29 <Gracenotes> Twey: http://www.thinkgeek.com/computing/input/8396
16:48:29 <Gracenotes> imagine someone trying to work out qwerty positions by memory, and gibberish coming out :3
16:48:33 <Gracenotes> I use a laptop, so reassigning keys isn't that easy
16:48:35 <Gracenotes> well, it's easy, but using reassignments will be difficult
16:48:37 <Gracenotes> there's only one keyboard
16:48:44 <ddarius> cads: I had a PDF of a Dvorak keyboard up, but I could already touch-type.  If you need to learn touch-typing too, I'd recommend going through a program for it configured for Dvorak.
16:48:47 <kalkin-> i have a tree data Baum a = Knoten a [Baum a]. to make a list [a] from it but i stuck
16:49:18 * ddarius switches between Dvorak and QWERTY with no trouble (now)
16:49:41 <kalkin-> i am not sure how i should iterate over every Knoten (Leaf) of the Baum (tree)
16:49:45 <BMeph> cads: I've edited my company computer's keymap, so that the Caps Lock and the left Ctrl keys are swapped. I'm just waiting for someone else to try it... >:)
16:50:12 * ksf learned true touch-typing not before learning dvorak and needs to look at the keyboard to find qwerty letters, now.
16:50:28 <BMeph> loadquo_: Please learn it, I've slobbered over that thing for months, now. :)
16:51:00 <Toxaris> kalkin-: what do you have so far?
16:51:03 <ski_> kalkin- : what code have you got, so far ?
16:51:08 <BMeph> loadquo_: I'd love to know if it's really worth $100, to someone, at least. :)
16:51:24 <mornfall> How do I turn CTime into a Word64? : - \
16:52:13 <Olathe> @hoogle CTime -> a
16:52:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:52:14 <lambdabot> Prelude id :: a -> a
16:52:14 <lambdabot> Data.Function id :: a -> a
16:52:32 <mornfall> ...
16:52:32 <kalkin-> hmm, i think i have an idea, i neead a helper function which i can give a list of trees and it will call the toList functino and herself again
16:52:41 <Cale> mornfall: It's an instance of Enum
16:52:49 <mornfall> Cale: Indeed. And Num.
16:52:51 <kalkin-> Toxaris , ski_ : just a second i wanna try something out
16:53:01 <loadquo_> BMeph: I've started to get the hang of letters. However what I really want it for is to get a nice comfy chair and a screen placed at the right height. Being a few inched over 6 ft does not do me any favours with normal office equipment
16:53:09 <Cale> On my machine, it's the same as an Int32 internally.
16:53:18 <Cale> fromEnum should do.
16:53:28 <Cale> (to turn it into an Int
16:53:29 <Cale> )
16:53:36 <Cale> and then perhaps fromIntegral from there
16:53:40 <mornfall> Int might be a little too small, no?
16:53:53 <mornfall> Although dunno if time_t is 64b anywhere.
16:53:58 <Cale> Might be... but practically speaking, it's a machine word.
16:54:26 <mornfall> Ok. Thanks, will do with fromIntegral . fromEnum.
16:54:32 <Cale> I wonder, is the data constructor exposed?
16:54:37 <loadquo_> BMeph: The little knowledge I have so far has not interfered with my normal typing either.
16:54:55 <Cale> mm... seems not
16:55:47 <Twey> Gracenotes: Yes, I know Das Keyboard :-P
16:56:05 <Twey> Of course it's easy.  setxkbmap dvorak :)
16:56:10 <Gracenotes> but does Das Keyboard know you?
16:56:15 <Twey> Alas no
16:56:19 <BMeph> loadquo_: I hear ya, I'm "only" 6'2", but I've experienced "fun" with office gear, too. :)
16:56:29 <Gracenotes> Twey: yeah, then I wouldn't be able to get it back :
16:56:30 <Gracenotes> :/
16:56:38 <Twey> I've never mustered the money to feel like spending USD$120 on a keyboard :-P
16:56:57 <Twey> Gracenotes: Here's the technique I used when learning the Russian keyboard:
16:56:59 <kalkin-> hmm so far i have this http://nopaste.ns-linux.org/?YmFlYj but now i'm stuck
16:57:09 <Twey> 1) Hit a key.
16:57:12 <mornfall> <-- oww, evil.
16:57:20 <Twey> 2) If the right character comes out, break.
16:57:29 <BMeph> 3) ????
16:57:29 <Twey> 3) Otherwise, choose the next key and goto 1.
16:57:35 <Twey> BMeph: Don't you dare :-P
16:57:43 <ddarius> > let aux [] v = [v]; aux xss@(x:xs) v = v : if x `isPrefixOf` v then xs else x:xs in foldr aux [] . sort $ words $ "/foo/bar/baz /foo /foo/bar /qux /qux/wibble"
16:57:44 <idnar> hahaha
16:57:44 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
16:57:44 <lambdabot>        Expect...
16:57:52 <shepheb> would it be possible to take a PDF of say course slides and have each slide inserted into gitit as a separate inline image for annotation?
16:57:54 <idnar> 4)#%FDPNO CARRIER
16:57:55 * BMeph goes in a corner, and cackles noisily
16:57:58 <Twey> Hahahaha
16:58:37 <ksf> just browse ebay for model-m's, preferrably 102-key models so you can map esc to ` and ` to the 102nd key.
16:59:31 <dolio> ddarius: Well, I was thinking of examples that wouldn't involve seq. either undefined g . Left = undefined is obviously a problem with seq, but without it it should be fine.
16:59:32 <kalkin-> Toxaris , ski_ : http://nopaste.ns-linux.org/?YmFlYj <- there is the code i have so far
16:59:42 <spacelobsters> trying to build xmobar. but i'm getting "Xmobar.hs:88:6: Not in scope: `throwDynTo'". What's wrong with it?
17:00:06 <ddarius> dolio: The equations are the laws that need to hold.  My example doesn't require seq to fail.
17:00:24 <ddarius> > either (const () . Left) (const () . Right) undefined
17:00:25 <lambdabot>   * Exception: Prelude.undefined
17:00:27 <ddarius> > const () undefined
17:00:29 <lambdabot>   ()
17:00:29 <ski_> kalkin- : i think you want to use `++' somewhere, instead of `:'
17:00:46 <ski_> > [False,True]:[True,True]
17:00:47 <lambdabot>   Couldn't match expected type `[Bool]' against inferred type `Bool'
17:00:48 <ski_> > [False,True]++[True,True]
17:00:49 <lambdabot>   [False,True,True,True]
17:01:02 <Olathe> > let tryABunchOfKeys = f' 0 where f' p t = if chr p == t then chr p else f' (p + 1) t in map tryABunchOfKeys "Hello"
17:01:04 <lambdabot>   "Hello"
17:01:16 <dolio> ddarius: Yes, that one doesn't hold.
17:01:36 <Toxaris> kalkin-: and I think you have a problem with your recursion, too. the recursive case is in toList2, but the base case is in toList
17:01:58 <Twey> What's the convention for with* functions?
17:02:15 <Twey> Actually, forget that, I just remembered an example that fits the pattern I want to use :)
17:03:36 <dolio> But 'either f g . Left = f' and 'either f g . Right = g' should unless you can test for the difference between undefined and eta expansions thereof, no?
17:04:04 <ski_> > seq (\x -> undefined x) ()
17:04:05 <lambdabot>   ()
17:04:31 <stulli> dcoutts, The installation failed because i need network-2.2.0.1. When installing that i get an error about a missing HsFFI.h
17:04:43 <ozy`> > undefined 1 2 3
17:04:44 <lambdabot>   * Exception: Prelude.undefined
17:04:57 <kalkin--> k, now it works replaced : with ++ and added the case [] to toList2
17:05:03 <kalkin--> thanks guys a lot
17:05:06 <roconnor> @type member
17:05:08 <lambdabot> Not in scope: `member'
17:05:11 <roconnor> @type elem
17:05:13 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:05:19 <kalkin--> hmm seems like my root server is down
17:05:35 <kalkin--> k, cu
17:05:36 <ozy`> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=978#a978 <== I have NO idea what I'm doing.
17:05:38 <kalkin--> and thanks again
17:05:41 <ski_> kalkin-- : now, you might try using `map' instead of having an auxilary `toList2'
17:07:00 <Gracenotes_> @botsnack
17:07:00 <kalkin-> ski_: i dont think i#m allowed to
17:07:00 <lunabot>  :)
17:07:00 <lambdabot> :)
17:07:14 <kalkin-> (its homework)
17:07:40 <dcoutts> stulli: ah, you don't want to upgrade network, you've most likely already got it
17:07:41 <ski_> (kalkin- : how about using `do'-notation, then ? :)
17:07:56 <Gracenotes_> @botsnack
17:07:57 <lunabot>  :)
17:07:57 <lambdabot> :)
17:08:06 <dcoutts> stulli: run the command with --dry-run and -v, if necessary specify the exact version of network, the same one you've got installed now.
17:08:23 * Gracenotes_ wonders what the hell was wrong with his connection
17:09:25 <BMeph> kalkin-: your toList2 is concatMap toList. :)
17:10:24 <stulli> dcoutts, That gives me the following: In order, the following would be installed: zlib-0.4.0.4 cabal-install-0.6.0
17:10:34 <dcoutts> stu8ball: excellent
17:10:36 <dcoutts> oops
17:10:41 <dcoutts> stulli: excellent
17:10:42 <BMeph> kalkin-: If you can find how to write that up in an "allowed" way, it should be good. :)
17:10:45 <ski_> (BMeph : .. the OP has left)
17:11:03 * dcoutts stumbles over nick completion again
17:11:24 <BMeph> ski_: Ah, pity. Thanks for the HU. :)
17:11:43 <ski_> (but not quit, apparently)
17:11:54 <ski_> @wtf HU
17:11:54 <lambdabot> Maybe you meant: bf ft wn
17:12:00 <Gracenotes> jeez... I have a method with (Int, Int) -> Coord -> Coord -> Delta, where Coord and Delta are both newtypes of (Int, Int). And the Ints mean different things in the three uses. odd.
17:12:06 <ddarius> dolio: Yes, the do if seq doesn't exist.
17:12:12 * cytzol dances the convert-from-lhs-to-hs-because-there-are-fewer-comments-than-hoped dance
17:12:36 <stulli> dcoutts, how is that excellent? cabal -V still tells me its version 0.5.1
17:12:51 * ski_ initially thought `hs' there were a typo for `rhs'
17:12:52 <Twey> cytzol: Not the add-more-comments dance?
17:12:56 <Twey> Haha
17:13:10 <Twey> That's nothing
17:13:15 <Twey> 01:12:02 < lambdabot> Maybe you meant: bf ft wn
17:13:19 <Twey> 'boyfriend for the win'
17:13:19 <cytzol> Twey: see, that's the problem with self-descriptive names
17:13:43 * Twey feels this may be Freudian.
17:14:03 <BMeph> ski_: Heads-Up (notification) :)
17:14:04 <ksf> ctrl+vllGx
17:14:08 <ksf> ...and you're done.
17:14:09 <ddarius> Gracenotes: That's not surprising at all.
17:15:14 <BMeph> cytzol: MOAR COMMENTS PLZ, kthxbai!
17:15:15 * ski_ stares at ksf
17:15:19 <dcoutts> stulli: I mean it's planning to install the right stuff, so now leave off the --dry-run and let it do it for real. The point it's not trying to reinstall the network package.
17:15:45 <dcoutts> stulli: and when it's done, check cabal --version that you've got the right one on your $PATH
17:16:14 <ksf> rectangular-select right right end-of-file remove
17:16:34 <matthewp> We're following along to the Real World Haskell over on #novalang on Chapter 3-4
17:16:39 <ksf> ...starting in the top left corner, of course.
17:17:08 <ksf> rectangular selections are a critical feature for editors.
17:18:17 <gwern> @quote monoid
17:18:17 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
17:19:05 <Gracenotes> as far as I can tell, most explanations of monads using category theory are 'simple', anyway
17:20:13 <stulli> dcoutts, heh, this is getting nasty. zlib-0.4.0.4 fails to install. Error: HsFFI.h missing
17:21:19 <dcoutts> stulli: ohhh, it's using the hsc2hs from ghc-6.10, do you still have the old hsc2hs or did it get overwritten? If not you'll have to build cabal-install for 6.10, but building the three packages manually, not using cabal-install.
17:23:02 <stulli> dcoutts, I will reinstall cabal-install tomorrow, its already 2AM here. Thanks for your guidance so far!
17:23:21 <dcoutts> stulli: np
17:23:30 <pumpkin> anyone know what the deal is with the logo competition?
17:25:58 * ksf decided the Right Interface for keyboards is ((Event (Key, PressedOrReleased)),Behaviour [Key])
17:26:19 <ksf> so you can snapshot the behaviour to figure out combinations, modifiers and such.
17:27:20 <ksf> in general, quite a lot of stuff has useful combinations of Event/Behaviour pairs that contain slightly different stuff.
17:30:20 <gwern> pumpkin: last I saw it was stalled on how to vote
17:30:24 <ddarius> Gracenotes: Monads are simple.
17:30:32 <pumpkin> gwern: :(
17:30:39 <ddarius> Gracenotes: You're hard pressed to make it complicated as there is not much to say.
17:30:51 <hmm_not_sure> free world fo warcraft clone done in haskell yet?
17:31:23 <ksf> it should usually suffice to call them overloaded ; .
17:31:49 <jeffz`> hmm_not_sure: are you planning to work on one?
17:31:55 <ddarius> ksf: That says nothing at all.
17:32:03 <ray> people who think they don't understand monads often actually do, but don't realize until they write a monad tutorial
17:32:21 <ksf> ...except that you have to obey certain laws for syntax to make sense.
17:32:31 <ksf> which makes sense to c programmers.
17:32:48 <ksf> so you can actually teach monad laws without mentioning what they are about.
17:33:10 <ray> has anyone written "how to understand monads by writing a monad tutorial" yet?
17:34:13 <ksf> yeah, monads are like sex: you have to get down to business to figure out how it works.
17:34:45 <ddarius> ray: "Don't."
17:34:56 <ski_> (.. maybe someone should write "how to understand monads by reading monad tutorials")
17:35:10 <intoverflow> monads are like almost-idempodent endofunctors, you need to, uh, diagrams, uh, like a monoid, er, hrm.
17:35:49 <Saizan> ("Don't." again?)
17:35:50 <newsham> monad tutorial combinators
17:36:03 * ski_ recalls seeing a book about "almost algebras and almost homomorphisms"
17:36:03 <ddarius> Saizan: Indeed.
17:36:52 <ray> monad tutorial combinators, yes
17:39:56 <ski_> (this apepars to be in that area : "On algebra homomorphisms in complex almost -algebras" <http://www.emis.de/journals/CMUC/ps/cmuc0201/Triki.ps>)
17:53:19 <noZone> monad tutorials be damned! I want a monad that is a tutor! Maybe one that can teach swimming or ice cream making.
17:54:53 <pshc_> Out of curiosity, what's an example of input for reads that gives more than one list item?
17:56:29 <Cale> pshc_: I don't think any of the standard instances involve ambiguous parses
17:57:03 <pshc_> hooray!
17:57:29 <IOMonad> wise ones, how do I append a block of null bytes to a file?
17:57:57 <IOMonad> (or any binary data, non String)
17:58:12 <Cale> Use Data.ByteString perhaps
17:58:24 <pumpkin> open the file in append mode
17:58:25 <pumpkin> or seek to the end
17:58:27 <pumpkin> and write?
17:58:47 <Cale> :t appendFile
17:58:49 <lambdabot> FilePath -> String -> IO ()
17:58:53 <Cale> There's also that
17:59:05 <Cale> I wonder...
17:59:06 <Cale> :t Data.ByteString.appendFile
17:59:08 <lambdabot> FilePath -> BSC.ByteString -> IO ()
17:59:15 <Cale> yes, that would work as well
17:59:31 <ac> :t mappend
17:59:34 <lambdabot> forall a. (Monoid a) => a -> a -> a
18:00:10 <pumpkin> file as a monoid!
18:00:13 <IOMonad> Just so I know, can a String in haskell consist of NULL bytes in the middle?
18:00:14 <pumpkin> under concatenation! :P
18:00:19 <Cale> IOMonad: yes
18:00:22 <pumpkin> you'd have to keep an empty file sitting around on your computer
18:00:25 <pumpkin> as your identity element
18:00:29 <Cale> IOMonad: A String in Haskell is just a list of Char
18:00:43 <Cale> IOMonad: So it can even be infinite length if you like.
18:00:55 <gnuvince_> > "a\000b"
18:00:57 <lambdabot>   "a\NULb"
18:01:03 <IOMonad> So what would be better String or ByteString
18:01:14 <pumpkin> bytestring
18:01:15 <Cale> IOMonad: Depends on what you're doing
18:01:22 <pumpkin> using a string for binary data is questionable
18:01:29 <Cale> If you need to work with binary data, ByteString is the way to go.
18:01:32 <pumpkin> given that Chars are supposed to represent unicode code points
18:01:34 <Cale> Or even something like Data.Binary
18:01:57 <IOMonad> Yea, this is hard core binary data, nothing to do with unicode thats for sure
18:02:10 <Cale> Right, pretty soon the String IO functions could be doing encoding/decoding.
18:02:19 <Cale> But currently they don't.
18:03:12 <Cale> At present, they're sort of broken, and just hand you a list of Chars each of which is in the range \0 to \255.
18:03:26 <IOMonad> So Data.Binary or Data.ByteString are my options? ByteString will never be interpreted as Char, correct?
18:03:39 <Cale> There's Data.ByteString.Char8
18:03:50 <Cale> which does conversion to 8-bit chars automatically
18:04:03 <Cale> As well as various encoding libraries on top of Data.ByteString
18:04:16 <Cale> But the plain ByteString library treats it as a sequence of Word8 values.
18:06:14 <defun> should i install cabal as root or as usr?
18:06:17 <IOMonad> Lets say Im implementing a database (for argument sake) what would make more sense? Data.Binary or Data.ByteString
18:06:27 <IOMonad> basically Im writing pages of fixed size
18:06:48 * ksf wonders what'll happen if he keeps on going being type-fundamentalistic. Possibly your editor will crash because you unplugged the keyboard.
18:07:16 <pejo> defun, if other users need it - install it globally.
18:07:23 <defun> kk
18:07:26 <pumpkin> IOMonad: Data.Binary sits on top of bytestring
18:07:49 <pumpkin> IOMonad: and gives you methods to create values of given endiannesses and sizes from native haskell types
18:08:03 <ksf> OS X's playAudio (or whatever) function fails if no speakers are connected. Innovative ways to confuse users...
18:08:03 <Cale> Data.Binary is a convenience library for giving datatypes specified binary representations so they're easy to serialise/deserialise.
18:08:18 <hmm_not_sure> is it my life as an engineer to spend inordinate amounts fo time finding soltions to some managers idea of colorful little blogs and arrows on a powerpoint presentation?
18:09:09 <ksf> the solution to those ideas is coming up with your own and letting the manager believe he came up with it.
18:10:27 <pejo> hmm_not_sure, managers usually make decisions, so it doesn't seem totally unreasaonable.
18:10:51 * ksf just noticed that managing the output of reactive stuff is much messier than managing the input
18:10:58 <Cale> Tomorrow, after a cataclysmic event, everyone is going to get cool superpowers. However, your superpower will be finding the perfect arrows and bullet points for powerpoint presentations, so don't get too excited.
18:11:44 <dolio> I don't know. That could probably earn you a 7 figure salary if you use it right.
18:12:06 <SamB> who is responsible for the stupid idea of letting managers make decisions?
18:12:19 <Japsu> SamB: the management
18:13:04 <byorgey> Cale: sounds like a horoscope from the Onion =)
18:13:06 * ksf thinks it's the MGT
18:13:47 <idnar> SamB: sounds like something the PHB might have thought of
18:15:02 <mjb> SamB: Ever figure out your profiling issues?
18:15:12 <Peaker> chrisdone: pong
18:15:41 <SamB> you mean where I press ^C and the RTS doesn't finish writing the profiling data to the file?
18:18:01 <cpfr> hey I upgraded to 6.10 and now cabal-install is giving me problems
18:18:10 <cpfr> and for some reason now i dont have parsec3
18:19:07 <pejo> cpfr, you need to reinstall your packages with the new ghc
18:19:29 <cpfr> pejo, what command should i use
18:19:39 <cpfr> since cabal upgrade gave me parsec 2.1.0.1
18:20:41 <wli> I don't remember what went on with parsec over here. I think I've got parsec3 and parsec2.1.0.1 simultaneously installed.
18:21:16 <cpfr> i use features in parsec3
18:21:25 <cpfr> so a downgrade isn't good for me
18:21:38 <wli> I've no idea what's new in parsec3.
18:21:40 <zloog_> Anyone know of a limit for the number of statements in executeMany?
18:22:01 * ksf stares at his MX-Laser, not believing that a bleeding mouse requires duplication of the keyboard interface.
18:22:13 <jeffz`> @index executeMany
18:22:14 <lambdabot> bzzt
18:22:21 <pumpkin> zloog_: sqlite3?
18:22:38 <zloog_> pumpkin: Yea
18:22:47 <pumpkin> zloog_: I'd guess there isn't one... unlike remote DBs, it doesn't really need to fit a statement into a packet or anything
18:24:01 <zloog_> pumpkin: Have a list of around 100k things im trying to insert. tinkering with different "take X" values to see where it ends up throwing unknown exception
18:24:08 <cpfr> pejo, any idea why i get the error: cabal: cannot configure haddock-2.4.1. It requires ghc >=6.8.2 && <6.13
18:24:08 <cpfr> There is no available version of ghc that satisfies >=6.8.2 && <6.13
18:24:36 <pumpkin> zloog_: isn't there a version of INSERT that allows you to do many insertions in one statement?
18:25:14 <zloog_> pumpkin: No idea, I'm trying to pickup what i need to know about sql through a teach yourself in 10 mins book... Thanks for the hint though
18:25:40 <pejo> cpfr, did you install cabal-install with your new ghc, or are you using your old version?
18:25:48 <cpfr> with my old
18:25:57 <cpfr> but i already ran cabal upgrade cabal
18:26:05 <cpfr> and cabal upgrade cabal-install
18:27:20 <pejo> cpfr, sorry, I have no idea if that is supposed to work or not.
18:27:21 <defun> I am trying to instal cabal. I've already installed the lib cabal. Now I am proceding to install http. I get this error what attepting to "runghc Setup configure" (http://pastebin.com/m1b9e8fae). Am I supposed to manually grab parsec and network?
18:27:42 <zloog_> defun: Yup
18:27:56 <zloog_> defun: The bootstraping is manual :(
18:28:05 <defun> bummer.
18:28:16 <CakeProphet> > |#| x = x in |#| 4
18:28:17 <lambdabot>   <no location info>: parse error on input `|#|'
18:28:19 <defun> is the procedure for installing parsec the same?
18:28:26 <SamB> defun: what about that shell script?
18:28:26 <CakeProphet> > |!| x = x in |#| 4
18:28:28 <lambdabot>   <no location info>: parse error on input `|!|'
18:28:36 <defun> SamB: not working on Solaris.
18:28:37 <CakeProphet> | is not a valid operator I take it?
18:28:39 <SamB> oh
18:28:41 <CakeProphet> er
18:28:43 <CakeProphet> oh
18:28:43 <SamB> you don't have wget ?
18:28:58 <SamB> or uses foreign shell constructs?
18:28:59 <defun> SamB: I do. It just chooses not to see it.
18:29:00 <CakeProphet> > (|!|) x y = y in |#| 4
18:29:02 <lambdabot>   <no location info>: parse error on input `='
18:29:18 <CakeProphet> > (|!|) x y = y in 3 |!| 4
18:29:19 <lambdabot>   <no location info>: parse error on input `='
18:29:21 <CakeProphet> ...
18:29:22 <SamB> defun: well, you could manually do what the script ought to do
18:29:35 <defun> That's precisely what I am trying to do.
18:29:49 <defun> be right back.
18:29:55 <dolio> > 3 |!| 4 where (|!|) x y = y
18:29:57 <lambdabot>   4
18:29:58 <wli> Say, does anyone know what happened with readline support on 6.10.1?
18:30:14 <CakeProphet> oh rite
18:30:16 <dolio> It works if you compile it yourself, I hear.
18:30:18 <SamB> wli: I think you need to specifically build that way
18:30:19 <pejo> wli, it was replaced by editline.
18:30:29 <SamB> apparantly editline is the default
18:30:52 <Saizan> wli: you need to use a patch floating around in ghc-users@
18:30:54 <CakeProphet> > let ({!}) = (+) in 1 {!} 2
18:30:56 <lambdabot>   <no location info>: parse error on input `{'
18:30:57 <pejo> wli, http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15949.html
18:31:12 <CakeProphet> imagine the fun that could be had with that operator
18:31:23 <wli> I rather quickly noticed that my vi keybindings vaporized in 6.10.1, masked 6.10.1, and downgraded to 6.8.3
18:32:10 <CakeProphet> > let (\) = (+) in 1 \ 2
18:32:11 <lambdabot>   <no location info>: parse error on input `)'
18:32:13 <wli> (I've no idea if there's a compelling reason to upgrade to 6.10.1)
18:32:34 <CakeProphet> > let (~) = (+) in 1 ~ 2
18:32:36 <lambdabot>   <no location info>: parse error on input `)'
18:32:39 <dolio> Probably not unless you want one of the new extensions.
18:32:41 <CakeProphet> what's some fun unicode operators one could ake?
18:33:00 <idnar> @where symbols
18:33:00 <lambdabot> I know nothing about symbols.
18:33:04 <idnar> @fact symbols
18:33:05 <lambdabot> symbols: "⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳ ⟦⟧"
18:33:05 <dolio> I don't think optimization got radically better or anything.
18:33:12 <Olathe> @help fact
18:33:13 <lambdabot> fact <fact>, Retrieve a fact from the database
18:33:17 <CakeProphet> :t stretch
18:33:19 <lambdabot> Not in scope: `stretch'
18:33:19 <dolio> Although 6.8.3 had a bug where certain things didn't get specialized.
18:33:22 <Olathe> @fact zomg
18:33:23 <lambdabot> I know nothing about zomg
18:33:23 <idnar> @let (∋ ) = elem in 5 ∋  [1..10]
18:33:24 <lambdabot>   Parse error
18:33:26 <idnar> aww
18:33:36 <Peaker> I can't compose existentially quantified functions, but I can use them, heh.  Found a case for f $ x $ y  as (f . x $ y) does not compile, because x is an existentially quantified function
18:36:17 <wli> dolio: I don't even know what the new extensions are.
18:36:21 <CakeProphet> > let halts = id; (⊥) = True in if halts (⊥) then "halting problem schmalting problem." else ""
18:36:23 <lambdabot>   "halting problem schmalting problem."
18:36:45 <dolio> wli: Well, I think that answers your question, then.
18:37:18 <wli> Okay, are there any exciting new extensions in 6.10.1?
18:37:39 <dolio> Type families work better.
18:37:45 <dolio> Quasiquoting.
18:37:50 <Saizan> View patterns
18:38:05 <pejo> wli, view patterns, quasi quotes, external core output, changes in the ghc api, multithread gc.
18:38:08 <CakeProphet> Quantum TypeClasses
18:38:11 <CakeProphet> is a good one.
18:39:06 <ray> > let halts prog = if prog == "halt;" then Just True else Nothing in halts "halt;"
18:39:07 <wli> I'm not sure which of those I've any idea how to use beyond view patterns, though I'd have to work up to making any significant use of them.
18:39:08 <lambdabot>   Just True
18:39:12 <ray> halting problem solved
18:39:28 * wli needs a type family tutorial in addition to a monad tutorial.
18:39:31 <wli> ergh
18:39:37 <ddarius> wli: Why?
18:39:37 * wli needs a type family tutorial in addition to an arrow tutorial.
18:39:43 <idnar> ray: hah
18:39:54 <ray> what's next? bring 'em on
18:39:55 <idnar> there's an easier way to solve the halting problem
18:40:06 <CakeProphet> > tranpose [[1,2,3], [4,5,6]]
18:40:08 <lambdabot>   Not in scope: `tranpose'
18:40:11 <idnar> insert an infinite loop at the end of every program; then halts = const True
18:40:14 <CakeProphet> > transpose [[1,2,3], [4,5,6]]
18:40:16 <lambdabot>   [[1,4],[2,5],[3,6]]
18:40:18 <CakeProphet> @src transpose
18:40:19 <lambdabot> transpose []             = []
18:40:19 <lambdabot> transpose ([]   : xss)   = transpose xss
18:40:19 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:40:27 <idnar> er
18:40:30 <idnar> halts = const False
18:40:31 <ray> general case schmeneral case
18:40:55 <wli> ddarius: I don't even know what type families are and I'm thoroughly arrow clueless.
18:40:55 <ddarius> halts = const True is the correct definition.
18:41:04 <ddarius> wli: So just don't use either.
18:41:30 <idnar> Either isn't an arrow anyway
18:41:32 * idnar hides
18:41:47 <dolio> More like 'halts = (`seq` True)' really.
18:41:49 <wli> I'd like to know how to use such things, esp. if type families are the up-and-coming replacement for fundeps.
18:42:42 <idnar> dolio: haha
18:42:42 <dolio> Type families are just writing pattern matching functions over types.
18:42:54 <dolio> With some hand waving.
18:43:13 <ddarius> Instead of class Foo a b | a -> b  and instance Foo [Char] Char you write class Foo a where type B; and instance Foo [Char] where type B = Char;
18:43:15 <wli> That's a lot more than merely "some" handwaving.
18:43:22 <dolio> :)
18:43:30 <cpfr> help i am screwed!~
18:43:38 <cpfr> package ghc-6.10.1 is broken due to missing package process-1.0.1.0
18:43:38 <ddarius> Anyway, fundeps aren't going anywhere for a long while
18:43:45 <cpfr> my errors are getting bad
18:44:09 <dolio> type family Foo a b c :: kind tells you how many you can match on.
18:44:24 <Saizan> cpfr: ghc-pkg list process ?
18:44:29 <dolio> type instance Foo Int Char Double = ... is a case.
18:44:42 <cpfr> ghc-pkg list process
18:44:42 <cpfr> /usr/local/lib/ghc-6.10.1/./package.conf:
18:44:42 <cpfr> /home/cf/.ghc/i386-linux-6.10.1/package.conf:
18:44:42 <cpfr>     process-1.0.1.1
18:44:44 <chessguy_work> in let x = "foo" in ....
18:44:47 <chessguy_work> what would you call x?
18:45:07 <chessguy_work> a symbol? locally-scoped variable?
18:45:34 <wli> Well, there's reputedly new and schnazzy stuff that can be done with such things as type families, arrows, template haskell, generics, GADT's, etc.
18:45:39 <idnar> I'd probably go with something like "local variable" or "local name" or "local binding"
18:45:56 <CakeProphet> let phi = (1 + sqrt 5) / 2;  stretch s r b = concat $ transpose [s, map ((flip replicate " ").round) (iterate (*r) b)] in stretch ">" phi 1
18:46:00 <Saizan> cpfr: so you unregistered the process package built with your ghc, you've to reinstall
18:46:06 <CakeProphet> > let phi = (1 + sqrt 5) / 2;  stretch s r b = concat $ transpose [s, map ((flip replicate " ").round) (iterate (*r) b)] in stretch ">" phi 1
18:46:08 <lambdabot>   Couldn't match expected type `[[Char]]'
18:46:24 <ddarius> wli: I know how to use all of those things more or less and rarely use any of them.
18:46:30 <cpfr> Saizan, do i reinstall ghc?
18:46:47 <Saizan> cpfr: yes
18:47:04 <cpfr> what happens with process 1.0.1.1
18:47:13 <CakeProphet> > replicate 5 " "
18:47:14 <lambdabot>   [" "," "," "," "," "]
18:47:27 <SamB> arrows aren't that great ...
18:47:40 <Saizan> cpfr: process-1.0.1.1 will stay in your user database (which is kept under ~/.ghc by default)
18:47:49 <cpfr> ok
18:48:08 <wli> ddarius: Is there anything out there that would make linear algebra polymorphic over the scalar division ring easier? Or linear algebra with types to enforce well-formedness of matrix/matrix and matrix/vector sums and products?
18:48:22 <Saizan> cpfr: having it there will cause problems with cabal-install if you're trying to use the ghc-api
18:49:07 <ddarius> wli: Associated types and type families would probably make expressing those constraints more natural, but you can more or less do that with multiparameter type classes and functional dependencies as well.
18:49:36 <cpfr> Saizan, now it says This package indirectly depends on multiple versions of the same
18:49:36 <cpfr> package.
18:49:42 <ddarius> Really, associated types and type families should actually be more natural to a Haskell programmer than multiparameter typeclasses and functional dependencies.
18:49:58 <Saizan> cpfr: this being?
18:50:01 <hmm_not_sure> haskell for gui good?
18:50:04 <cpfr> cabal configure haddock
18:50:11 <jeffz`> hmm_not_sure: try it and see.
18:50:34 <ozy`> hmm_not_sure: hmm. not sure.
18:50:54 <Saizan> cpfr: you can go on with cabal build, it's a warning and you shouldn't have problems in this case
18:51:23 <cpfr> Saizan, just wanted to be sure things were safe
18:51:28 <idnar> what are associated types?
18:51:42 <Saizan> cpfr: if it compiles they are
18:51:53 <idnar> and generics?
18:51:58 <ddarius> cpfr: Damn the torpedoes, full steam ahead!
18:51:58 <cpfr> Saizan, /usr/bin/ld: cannot find -ledit
18:52:08 <roconnor> does gtk2hs support glyphpath?
18:52:33 <wli> ddarius: Well, if anything makes it easy, I'm all over it.
18:52:52 <Saizan> cpfr: ah, that means you've to install the C libedit library using your distro package manager
18:53:19 <cpfr> Saizan, I see, thanks!
18:53:33 <CakeProphet> > let phi = (1 + sqrt 5) / 2;  stretch s r b = concat $ zipWith (:) s (map ((flip replicate " ").round) (iterate (*r) b)) in stretch ">" phi 1
18:53:35 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
18:53:47 <ddarius> wli: Who said anything about easy?  It's more or less a different way of saying the same kind of things.
18:53:48 <necroforest> fail
18:55:18 <CakeProphet> > let phi = (1 + sqrt 5) / 2;  stretch s r b = concat $ transpose [s, (map (concat.(flip replicate " ").round) (iterate (*r) b)] in stretch ">" phi 1
18:55:19 <lambdabot>   <no location info>: parse error on input `]'
18:56:23 <CakeProphet> > let phi = (1 + sqrt 5) / 2;  stretch s r b = concat $ transpose [s, (map (concat.(flip replicate " ").round) (iterate (*r) b))] in stretch ">" phi 1
18:56:25 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
18:56:27 <CakeProphet> ...
18:56:35 <CakeProphet> nevermind
18:56:51 <Gracenotes> never say never!
18:56:56 <ksf> oh how easy life would be if you never had to do side-effects.
18:57:17 <CakeProphet> > let phi = (1 + sqrt 5) / 2;  stretch s r b = concat $ transpose [[s], (map (concat.(flip replicate " ").round) (iterate (*r) b))] in stretch ">" phi 1
18:57:20 <lambdabot>   [">"," ","  ","   ","    ","       ","           ","                  ","  ...
18:57:22 <Gracenotes> ksf: and how much harder, for the user :)
18:57:23 <CakeProphet> ...bah
18:58:05 <sbahra> Is it accurate to say "a functional language is side-effect free"?
18:58:30 <elly> no
18:58:34 <sbahra> I thought so.
18:58:43 <elly> the term for that is usually 'pure'
18:58:44 <int80_h>  
18:58:47 <cpfr> Saizan, now i get cabal: � openFile: does not exist (No such file or directory)
18:58:50 <elly> functional just means that functions are first-class
18:58:50 <ksf> in reality, there are no side-effects. there are just functions with multiple return values and plumbing made out of fixpoints.
18:58:52 <cpfr> what does that mean?
18:59:03 <sbahra> elly, this is what I saw too. :-)
18:59:07 <sbahra> elly, http://home.gwu.edu/~yhwang1/CS210/cs210_syllabus.html
18:59:36 <sbahra> Terrible, terrible class.
18:59:46 <pumpkin> lol
18:59:49 <pumpkin> you taking it?
18:59:56 <int80_h> back
18:59:58 <sbahra> He spent most of today talking about Java and the difference between applets, servlets and applications.
19:00:01 <CakeProphet> it's as accurate as saying "Emacs is a good choice for a content management system"
19:00:05 <CakeProphet> which is of course true.
19:00:16 <ksf> functional software design paradigms with examples in ada, java, c, c++ and perl??!
19:00:25 <int80_h> sbahra: god, I really want to avoid those kinds of classes
19:00:25 <sbahra> pumpkin, yes. There was a good instructor before who was covering actual "paradigms" and several languages including Haskell.
19:00:30 <sbahra> ksf, yes! :-(
19:00:45 <sbahra> pumpkin, anyways, they just replaced him with this guy.
19:00:56 <sbahra> pumpkin, oh, he also discussed the 7 OSI layers! :-)
19:01:02 <pumpkin> sbahra: looks like your prof wanted to go to a school similar to the one he came from! he inverted his middle letter
19:01:04 <pumpkin> lol
19:01:06 <sbahra> This is a graduate class, too.
19:01:08 <pumpkin> awesome
19:01:15 <necroforest> that's a grad class?
19:01:18 <sbahra> Yes.
19:01:20 <pumpkin> them graduate students need a gentle introduction too!
19:01:21 * ksf thinks being hit on the head with a copy of CTM teaches one more about paradigms than that course.
19:01:24 <int80_h> sbahra: what? good god. that sounds horrible
19:01:25 <sbahra> I just left 40 minutes in.
19:01:35 <sbahra> I couldn't handle it.
19:01:40 <int80_h> you aren't paying for that I hope
19:01:44 <sbahra> Anyways, this is off-topic. I'll continue my rant in -blah.
19:01:47 <sbahra> int80_h, I am. :-(
19:01:55 <int80_h> bastards, get your money back!
19:02:14 <idnar> heh
19:02:17 <int80_h> anyway, where can I find channel logs? I need to look something up from two days ago. or maybe it was yesterday...
19:02:23 <pumpkin> it's in the topic I think
19:02:26 <pumpkin> was last time I looked
19:02:40 <int80_h> oh indeed it is thanka :)
19:03:16 <Saizan_> cpfr: during build?
19:03:25 <cpfr> Saizan, after build
19:03:41 <cpfr> Saizan, build worked, but it now seems cabal-install does not
19:03:51 <cpfr> all i can do is run help
19:03:58 <cpfr> even cabal update fails now
19:03:59 * ksf tries to find out whether you can tie a knot into reactive without going via IO
19:04:02 <Saizan_> cpfr: btw, you should use cabal install --only at this point
19:04:45 <cpfr> Saizan: cabal install hlint
19:04:45 <cpfr> cabal: � openFile: does not exist (No such file or directory)
19:05:51 <Saizan_> cpfr: weird, can you try cabal install hlint -v3 ?
19:06:25 <CakeProphet> are there any papers out there on new concurrency systems?
19:07:28 <ozy`> CakeProphet: yes but you have to read them all simultaneously
19:08:03 <cpfr> Saizan, http://pastebin.com/d1db240d2
19:08:06 <pejo> CakeProphet, language mechanisms for concurrency, or someone building a new large concurrent system?
19:08:49 <CakeProphet> pejo:  language mechanisms. Generally I just want to look around at fresh ideas on designing concurrent systems.
19:10:46 <Saizan_> cpfr: it seems it has some problem with reading the tarball containing the index of packages on hackage
19:11:21 <Saizan_> cpfr: i'd try moving ~/.cabal somewhere else
19:12:01 <pejo> CakeProphet, depending on what you mean by new: the manticore project had a couple of papers at ICFP last year, and they should provide some relevant references too.
19:12:27 <CakeProphet> pejo:  I mean "things I've never seen" moreso than "new"
19:12:34 <CakeProphet> pejo:  I'll check it out
19:13:10 <Saizan_> cpfr: it'd be interesting to find out what's happening though
19:13:48 <pejo> CakeProphet, ok, then I don't have any idea, sorry.
19:16:17 <xpika> is there a maybe read function?
19:16:40 <xpika>  Read a => String -> Maybe a ?
19:16:45 <Saizan_> you can write one with reads
19:16:53 <Saizan_> ?type reads
19:16:54 <lambdabot> forall a. (Read a) => String -> [(a, String)]
19:17:13 <idnar> @type listToMaybe . reads
19:17:14 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
19:17:15 <Saizan_> and then petition for its inclusion in the standard libraries
19:17:26 <idnar> @type fmap fst . listToMaybe . reads
19:17:27 <lambdabot> forall a. (Read a) => String -> Maybe a
19:17:58 <pumpkin> it seems odd for them to write reads as if it'll return more than one result but never make it do so
19:18:51 <idnar> hmm, that's not actually right
19:19:11 <xpika> idnar: Nice
19:19:17 <Saizan_> type Parser a = String -> [(a, String)]
19:19:26 <idnar> @type listToMaybe . map fst . filter (null `on` snd) . reads
19:19:27 <lambdabot>     Couldn't match expected type `[a] -> c'
19:19:27 <lambdabot>            against inferred type `Bool'
19:19:27 <lambdabot>     Probable cause: `null' is applied to too many arguments
19:19:38 <idnar> bah
19:19:46 <xpika> > (fmap fst . listToMaybe . reads) "2" :: Maybe Int
19:19:47 <lambdabot>   Just 2
19:19:51 <xpika> see
19:19:58 <idnar> yeah, but
19:20:00 <idnar> > (fmap fst . listToMaybe . reads) "2foobar" :: Maybe Int
19:20:02 <lambdabot>   Just 2
19:20:06 <idnar> ^^^ probably not what you want
19:20:22 <xpika> :S
19:20:25 * pumpkin senses more monoids coming from sigfpe in the near future
19:20:34 <idnar> @type listToMaybe . map fst . filter (null . snd) . reads
19:20:35 <lambdabot> forall a. (Read a) => String -> Maybe a
19:20:50 <xpika> idnar: should be good for now
19:20:53 <idnar> > let read' = listToMaybe . map fst . filter (null . snd) . reads in read' "2foobar" :: Maybe Int
19:20:55 <lambdabot>   Nothing
19:20:59 <idnar> > let read' = listToMaybe . map fst . filter (null . snd) . reads in read' "42" :: Maybe Int
19:21:00 <lambdabot>   Just 42
19:21:02 <idnar> :)
19:22:13 <idnar> @type \x -> listToMaybe [r | (r,s) <- reads x, null s]
19:22:15 <lambdabot> forall a. (Read a) => String -> Maybe a
19:22:53 <idnar> pumpkin: is there absolutely no way for it to return more than one result?
19:23:15 <pumpkin> idnar: I don't think any of the standard library Read instances do
19:23:55 <Saizan_> @type \x -> listToMaybe (reads x) >>= \(r,s) -> guard (all isSpace s) >> return r
19:23:57 <lambdabot> forall a. (Read a) => String -> Maybe a
19:24:25 <idnar> okay, but theoretically someone could define an instance that returns more
19:24:30 <_roconnor> @hoogle ([Maybe a] -> [a]
19:24:31 <lambdabot> Parse error:
19:24:31 <lambdabot>   --count=20 "([Maybe a] -> [a]"
19:24:31 <lambdabot>                               ^
19:24:34 <_roconnor> @hoogle ([Maybe a] -> [a])
19:24:34 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
19:24:34 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
19:24:34 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
19:25:15 <idnar> @type maybe
19:25:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:25:24 <idnar> @type maybe mzero return . listToMaybe . map fst . filter (null `on` snd) . reads
19:25:26 <lambdabot>     Couldn't match expected type `[a] -> c'
19:25:26 <lambdabot>            against inferred type `Bool'
19:25:26 <lambdabot>     Probable cause: `null' is applied to too many arguments
19:25:30 <idnar> @type maybe mzero return . listToMaybe . map fst . filter (null . snd) . reads
19:25:31 <lambdabot> forall (m :: * -> *) a. (Read a, MonadPlus m) => String -> m a
19:26:32 <idnar> :P
19:26:43 <CakeProphet> alright, so I was sitting here, coding away at my Haskell MUD codebase, and it suddenly hit me that I have never fried a grapefruit.
19:26:47 <CakeProphet> has anyone attempted this?
19:26:50 <idnar> CakeProphet: ...whaaaat
19:27:06 <idnar> what kind of crazy MUD are you working on?
19:27:58 <CakeProphet> standard RP-intensive codebase design (maybe with some fancy inheritance features) but I had grapefruits and am craving something delicious and fruity.
19:28:21 <wli> CakeProphet: RP?
19:28:28 <idnar> roleplay
19:28:29 <CakeProphet> roleplay. Like acting for nerds.
19:28:33 <idnar> hahaha
19:29:03 <ozy`> CakeProphet: hey, have you ever had buffalo chili on a chocolate chip cookie?
19:29:05 <int80_h> @src foldr
19:29:06 <lambdabot> foldr f z []     = z
19:29:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:29:13 <ozy`> (the animal buffalo, not the sauce)
19:29:26 <CakeProphet> ozy`:  ...no
19:29:46 <CakeProphet> apparently this dude has fried a grapefruit: http://moges.blogspot.com/2007/03/pan-fried-grapefruit_13.html
19:30:28 <ozy`> CakeProphet: well, I ask because it makes about as much sense as fried grapefruit
19:30:54 <CakeProphet> I remember I fried bananas once. It was the most delicious thing I've ever eaten.
19:34:35 <islon_s> Prelude> :load Control.Monad.Cont
19:34:36 <islon_s>  <no location info>: module `Control.Monad.Cont' is a package module
19:34:40 <islon_s> why? -=/
19:35:30 <pumpkin> why are you :load ing it?
19:35:37 <pumpkin> rather than :m + Control.Monad.Cont
19:35:46 <chessguy_work> @hoogle Cont
19:35:47 <lambdabot> module Control.Monad.Cont
19:35:47 <lambdabot> Control.Monad.Cont newtype Cont r a
19:35:47 <lambdabot> Control.Monad.Cont Cont :: (a -> r) -> r -> Cont r a
19:35:59 <islon_s> because i'm a newbie, thanks =D
19:35:59 <gio123> @ _ski
19:36:19 <gio123> @_ski
19:36:19 <lambdabot> Maybe you meant: ask wiki
19:36:25 <pumpkin> o.O
19:36:47 <gio123> @ _ski
19:36:47 <pumpkin> his nick has the underscore on the other side, if you want to highlight him :P
19:37:09 <gio123> @ ski_
19:37:27 * pumpkin stares
19:37:53 <gio123> @ pumpkin
19:38:19 <int80_h> eee
19:38:25 <int80_h> @seen mathijs
19:38:25 <lambdabot> I saw mathijs leaving #haskell 20h 36m 59s ago, and .
19:38:27 <pumpkin> @ gio123
19:38:31 <int80_h> damnit
19:38:31 <pumpkin> @ int80_h
19:38:40 <int80_h> hi hi
19:38:53 <gio123> bot dows not work?
19:39:02 <pumpkin> gio123: um?
19:39:07 <pumpkin> maybe http://is.gd/Gf7 ?
19:39:08 <_roconnor> I don't suppose there is a unicode character for "10" out there
19:39:42 <gio123> pumpkin: why bot does not answer our question?
19:39:51 <pumpkin> because there was no question
19:40:05 <pumpkin> are you looking for @seen ?
19:40:09 <gio123> i need to chekc whether bot seen last time ski_
19:40:14 <gio123> ah
19:40:15 <gio123> yes
19:40:24 <pumpkin> _roconnor: Ⅹ ;)
19:40:25 <gio123> seen@ pumpkin
19:40:31 <pumpkin> it's @seen
19:40:56 <gio123> @seen pumpkin
19:40:56 <lambdabot> pumpkin is in #lhc-compiler, #haskell, #ghc and #haskell-blah. I last heard pumpkin speak 24s ago.
19:40:57 <_roconnor> pumpkin: how about 11 :)
19:41:11 <gio123> @seen ski_
19:41:12 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I last heard ski_ speak 2h 1m 15s ago.
19:41:13 * ksf giggles at the thought of writing "Foo even runs on windoze, but you'll have to get an X server to display its GUI on the same machine"
19:41:14 <_roconnor> pumpkin: X isn't such a bad idea
19:41:29 <pumpkin> _roconnor:
19:41:31 <pumpkin> Ⅺ
19:41:34 <pumpkin> ⅺ
19:41:34 <pumpkin> :P
19:41:36 <gio123> @seen Cale
19:41:37 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 30m 39s ago.
19:41:43 <IOMonad_>  
19:41:49 <_roconnor> pumpkin: great!
19:42:07 <pumpkin> also, ⑽
19:42:09 <pumpkin> ⑩
19:42:12 <pumpkin> ❿
19:42:14 <pumpkin> ⓾
19:42:15 <pumpkin> :P
19:42:22 <pumpkin> not to mention the chinese numerals
19:42:27 <pumpkin> and accounting counterparts
19:43:04 <islon_s> it's amazing how haskell implements continuations with monads
19:43:16 <_roconnor> :)
19:43:28 <_roconnor> I could use those for all my labels
19:43:31 <mm_freak> in the other hand, i've never found a use case for Cont
19:43:46 <mm_freak> you could just as well use any failable monad
19:43:53 <islon_s> i used continuations a lot in javascript/rhino
19:44:16 <mm_freak> yeah, but in haskell i've never really found a use for them…  there's a monad for almost everything
19:44:28 <int80_h> @seen Calew
19:44:28 <lambdabot> I haven't seen Calew.
19:44:29 <islon_s> haskell is pure black magic
19:44:29 <int80_h> @seen Cale
19:44:30 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 1h 33m 32s ago.
19:44:44 <_roconnor> mm_freak: ya, lazy evaluation take care of a bunch of uses of continuations
19:44:54 <mm_freak> _roconnor: yeah
19:44:58 <int80_h> yes, haskell is what you get when you take the Darts Arts to their logical conclusion
19:45:01 <mm_freak> well, i use the fix function a lot
19:45:10 <mm_freak> but i don't consider that using continuations
19:45:13 <int80_h> bah s/Darts/Dark
19:45:47 <mm_freak> it's just a convenient way to express recursion — sometimes at least
19:46:56 <islon_s> i've looked at the continuation monad in scala but it's just a bad hack compared to haskell
19:48:33 <mm_freak> well, since i'm mainly a haskell programmer, i found myself using continuations and other things quite a lot in other languages
19:48:50 <mm_freak> for example, in most cases, i use continuations in C, rather than malloc/free
19:49:25 <mm_freak> void allocMemory(size_t size, void (*k)(void *));
19:49:48 <necroforest> how does that work?
19:50:09 <pumpkin> allocates on stack and passes memory to other function?
19:50:19 <int80_h> mm_freak : could you give a code example of using continuations in place of malloc/free?
19:50:25 <mm_freak> yeah, for example using alloca(), but it's not much useful that way
19:50:42 <mm_freak> it's more useful with file handles and such, because you can just return without having to care about closing everything
19:51:05 <mm_freak> before that, i used goto to jump to an error handler at the end
19:51:07 <int80_h> hmm, I better just master continuations first, then figure out how to do it in C
19:51:54 <Peaker> what does "orphan instance" mean?
19:52:05 <Pseudonym> int80_h: It's usually a good idea to master something in Haskell before trying it in any other language.
19:52:16 <mm_freak> int80_h: well, it's not that hard:  int withFile(const char *filename, void (*user)(FILE *));
19:52:22 <necroforest> mm_freak, could you write up a quick example in pastebin or something?
19:52:23 <mm_freak> in the same way you would use withFile in haskell
19:52:27 <pumpkin> Peaker: referring to the blog post about them?
19:52:32 <mm_freak> necroforest: ok, gimme a minute
19:52:39 <necroforest> thanks :90
19:52:40 <Peaker> pumpkin: no, a warning I'm getting
19:52:44 <Peaker> pumpkin: about an instance that is in use
19:52:51 <pumpkin> Peaker: from the blog post I read about them, it's an instance of a typeclass defined in a file that contains neither the type nor the classs
19:52:59 <pumpkin> *module
19:53:17 <pumpkin> does that fit your situation?
19:53:30 <Peaker> pumpkin: yeah
19:53:36 <Peaker> pumpkin: why is that a bad thing? :-)
19:53:43 <pumpkin> can't remember :P
19:53:46 <Peaker> pumpkin: SDL lacks a Show instance for various stuff
19:53:49 <pumpkin> there was a blog post on it just yesterday
19:53:54 <Peaker> pumpkin: I have an SDL wrapper that does define it
19:54:03 <pumpkin> http://lukepalmer.wordpress.com/2009/01/25/a-world-without-orphans/
19:54:04 <Peaker> I guess somebody else might collide with me
19:54:16 <idnar> Peaker: I think it's bad because the presence or absence of the instance is a bit obscure
19:54:52 <idnar> ie. both the typeclass and type might be loaded, but not the instance
19:54:56 <Peaker> "orphan instance" is such a horrible name for it :)
19:55:08 <pumpkin> send it to the orphanage!
19:55:19 <Peaker> "independent instance" maybe?
19:55:30 <idnar> it's an orphan because the parents are gone :P
19:55:30 <pumpkin> rogue instance!
19:55:35 <Peaker> I have the *weirdest* bug in my widget set :P
19:55:40 <idnar> it's all on its lonesome
19:55:47 <pumpkin> awww
19:58:36 <Peaker> damn I want a debugger :(
19:58:50 <zloog_> ?src executeMany
19:58:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:58:56 <Debugger> I already have a gf.. sorry
19:59:02 <pumpkin> lol
20:01:15 <chessguy_work> haha
20:01:19 <chessguy_work> that was random
20:01:25 <pumpkin> bos: have any luck with uvector? or was it too ghc-specific for your needs?
20:02:46 <Peaker> oh man... I totally forgot!
20:02:56 <Peaker> I was debugging a weird source of undeterministic movements in my widgets
20:03:03 <Peaker> wondering "wtf can introduce non-determinism here?"
20:03:19 <Peaker> totally forgetting that each SDL wrapper buggy usage of Int instead of CInt gets garbage in the top 32-bits
20:03:27 <Peaker> time to get rid of all my debug warts
20:03:58 <necroforest> quantum widget sets
20:05:22 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=979#a979
20:05:38 <int80_h> could someone help me fix the broken code from Chapter 5 RWH?
20:06:25 <mm_freak> necroforest: http://rafb.net/p/tMbi5884.html
20:06:28 <Peaker> my widget set is beginning to look pretty cool, btw :-)
20:07:18 <Nafai> Peaker: You're writing your own widget set?
20:07:22 <Peaker> functional widgets -- they have just (size,draw) methods that return Draw.Compute and Draw.Draw  monads that can *only* compute drawing sizes and draw stuff, and they have handlers that can only return a new widget state, but not do anything imperative
20:07:24 <Peaker> Nafai: yeah
20:07:31 <mm_freak> int80_h: that may be interesting for you, too
20:07:32 <idnar> I want a Julia widget set
20:07:38 <Peaker> Nafai: very minimal, yet more useful than Gtk/Qt/etc, IMO :-)
20:07:56 <Peaker> Nafai: I believe conventional UI's (Gtk-style/etc) are insanely badly designed
20:08:04 <int80_h> mm_freak: thanks. Could you tyake a look at my url?
20:08:04 <Nafai> Peaker: Are you Achim Schneider from -cafe?
20:08:11 <Peaker> Nafai: No, I am Eyal Lotem
20:08:36 <blackh> int80_h: Prettify.hs wants "module Prettify where" at the top.
20:08:54 <Nafai> Peaker: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/51478
20:09:17 <mm_freak> int80_h: use "module X where"
20:09:26 <mm_freak> where X is your module name
20:09:31 <int80_h> thanks guys. I figured I was missing something obvious
20:09:47 <mm_freak> i think, if you don't do that, Main is assumed
20:10:00 <Nafai> Peaker: Badly designed API-wise or look-and-feel wise?
20:10:01 <int80_h> is that after the import keyword?
20:10:08 <necroforest> mm_freak, thanks i'm reading it now
20:10:16 <Peaker> Nafai: the latter
20:10:25 <mm_freak> int80_h: before, at the top
20:10:31 <int80_h> okay
20:10:34 <Peaker> Nafai: I blame Qt/Gtk-style GUI's for people's (rightful) rejection of GUI's to replace various textual things such as CLI interfaces or text editors
20:10:48 <mm_freak> (after any module-wide pragmas, but for now, just ignore that)
20:10:56 <Nafai> Peaker: Interesting idea.  I'd be interested in seeing what you have in mind.
20:11:01 <int80_h> now I'm getting a bunch of "not in scope errors"
20:11:23 <blackh> int80_h: What symbols?
20:11:28 <Peaker> Nafai: sure, my widget set is coming along nicely, I hope to create a non-textual code editor with it (I've done this in Python, now replicating a similar design in Haskell)
20:11:29 <int80_h> this would really put off a person who was not totally determined to go through this book, come hell or high water.
20:11:36 <int80_h> blackh: I'll post
20:12:08 <Nafai> Peaker: Cool!  I always like to see people doing work that is different from the norm :)
20:12:36 <Peaker> Nafai: I already have a tiny preview of my widget set, but now I'm hunting an SDL bug :)
20:12:53 <Nafai> Yay for bugs in OPSS
20:12:54 <Peaker> Nafai: (the widget set itself is semi-interesting, I think it probably won't be convincing until its used in a realistic setting)
20:12:56 <Nafai> Er, OPS
20:12:57 <int80_h> blackh: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=979#a980
20:13:00 <Peaker> OPS?
20:13:07 <Nafai> Other People's Software
20:13:10 <Peaker> heh
20:13:51 <mm_freak> int80_h: import SimpleJSON in Prettify
20:13:56 <int80_h> oh wait, I think I know what is wrong here
20:14:01 <mm_freak> and there is no JValue constructor, just a JValue type
20:14:16 <mm_freak> you probably meant JNumber or such
20:14:29 <Peaker> Nafai: I'm pretty excited about my progress and ideas for progress that I stayed up to 6:15 am to get this idea done :)
20:14:33 <int80_h> mm_freak: I just copied verbatim out of the book. That's why it's broken.
20:14:45 <Peaker> ah, found the buggy function
20:14:54 <Nafai> Peaker: That is excited!
20:15:45 <mm_freak> int80_h: sorry, import SimpleJSON in PrettyJSON…  remember that imports are not reexported by default
20:16:05 <mm_freak> importing Prettify doesn't import SimpleJSON
20:16:25 <int80_h> mm_freak: your line gave me a parse error. What file is it supposed to go  in?
20:16:56 <int80_h> mm_freak: okay I'm with you now
20:17:27 <Gracenotes> @check \xs -> foldr (/) 1 xs == foldr (/) 1 (reverse xs)
20:17:29 <lambdabot>   "Falsifiable, after 0 tests:\n[1.0,2.3333333333333335]\n"
20:17:34 <int80_h> mm_freak what file is that import line supposed to go in?
20:17:53 <Gracenotes> @check \xs -> foldr (/) (1::CReal) xs == foldr (/) 1 (reverse xs)
20:17:55 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
20:17:55 <lambdabot>          ...
20:18:23 <int80_h> mm_freak: I thought I was with you but I believe I've put that import line in the wrong file
20:18:23 <mm_freak> int80_h: i'll leave that as an exercise for you…  look at the symbol that fails and where it fails, then look where it's defined and whether you import that particular module there
20:18:54 <int80_h> mm_freak it's failing as a parse error
20:19:06 <mm_freak> then you've got a different error now =)
20:19:25 <int80_h> mm_freak : right, I've put it in the wrong file
20:19:44 <mm_freak> that shouldn't result in a parse error
20:19:56 <mm_freak> maybe you've put it before the module line
20:20:16 <Peaker> I think "foreign" should disallow use of "Int" and only allow "CInt", perhaps there should be a typeclass for things that can be used there?
20:20:38 <bos> pumpkin: uvector is too tied to ghc
20:20:49 <pumpkin> yeah :/
20:20:56 <pumpkin> bos: whatcha looking to do with it?
20:21:35 <bos> pumpkin: working on a new core library for packed unicode text
20:21:42 <pumpkin> ooh nice
20:23:09 <int80_h> mm_freak : This line goes in Prettify.hs right? I put it right after the "module Prettify where" line
20:23:32 <int80_h> import SimpleJSON in PrettyJSON
20:23:38 <bos> oops.
20:23:51 <int80_h> that's supposed to be right? Because it complains about a parse error at "in"
20:23:55 <mm_freak> int80_h: if i answered that, i wouldn't have helped you
20:23:59 <Peaker> arrg.. have to fix a bazillion Ints to CInts in SDL-ttf wrapper
20:24:01 <mm_freak> you need to understand the module system
20:24:16 * bos bangs his head against Cabal under Hugs
20:24:23 <int80_h> mm_freak: I don't believe the chapter explains it very well. It would help to have code that worked.
20:24:35 <mm_freak> the parse error comes from my failure to separate code from message =)
20:24:50 <mm_freak> it goes "import SimpleJSON" =)
20:25:05 <Gracenotes> @hoogle [a] -> [([a], [a])]
20:25:06 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:25:06 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:25:06 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
20:25:10 <int80_h> ah, in the file PrettyJSON. gotcha
20:25:13 <mm_freak> i thought, this is obvious
20:25:44 <Gracenotes> @hoogle [a] -> Int -> ([a], [a])
20:25:45 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
20:25:45 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
20:25:45 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
20:25:50 <Peaker> yay!  Bug-free!
20:26:07 <Nafai> Peaker: w00t
20:26:26 <int80_h> if it were obvious, it wouldn't need to be explains. One could say "ther module system is obvious and needs no further explaination"
20:26:54 * wli wishes the module system did so much more.
20:27:12 <int80_h> This code is supposed to be there, to explain the module system. It's really really broken. I'm more confused than ever. It still is broken. New errors.
20:27:18 <SamB> mm_freak: it's not obvious!
20:27:22 <SamB> in *is* a keyword
20:27:52 <SamB> and there are a lot of keywords and almost keywords involved in import declarations ...
20:28:02 <int80_h> oh wait, I think I can handle this new error
20:28:17 <mm_freak> now i got, what's wrong
20:28:23 <mm_freak> <mm_freak> int80_h: sorry, import SimpleJSON in PrettyJSON…  remember that imports are not reexported by default
20:28:31 <int80_h> one of them at least
20:28:34 <mm_freak> actually that "import SimpleJSON in PrettyJSON" was not a piece of code
20:28:39 <int80_h> there are two new errors
20:28:40 <mm_freak> it was an english sentence
20:28:51 <int80_h> mm_freak: I'm past that, and on to a whole new brokenness
20:29:38 <int80_h> wait, I know what I want to do next. I just don't know the syntax. I'll post
20:29:42 <SamB> mm_freak: well, its hard to tell that too for a greenhorn ;-P
20:30:01 * wli has never figured out how anyone intends to resolve whatever goes wrong with mixing more powerful module systems with typeclasses, and for that matter, doesn't even know what goes wrong with module systems vs. typeclasses.
20:30:25 <mm_freak> int80_h: at least you mostly have the certitude in haskell, that as soon as your code compiles, it works =)
20:30:46 <ddarius> wli: Nothing goes wrong.
20:30:47 <mm_freak> SamB: yeah, i noticed that =)
20:30:51 <int80_h> mm_freak: yes. I love haskell. This book is begining to bug me, however
20:31:02 <SamB> mm_freak: tell that to LHC
20:31:04 <Gracenotes> @src signum
20:31:05 <lambdabot> Source not found. :(
20:31:09 <SamB> it doesn't seem aware of this adagee
20:31:13 <SamB> er. adage.
20:31:15 <wli> ddarius: Then I don't understand how it's done. Or something.
20:31:19 <ozy`> int80_h: which book? RWH?
20:31:34 <ksf> @seen conal
20:31:34 <lambdabot> I saw conal leaving #haskell and #ghc 1d 9h 19m 14s ago, and .
20:31:55 <int80_h> ozy`: yes
20:32:00 <mm_freak> SamB: now i lost you
20:32:18 <SamB> mm_freak: it's always not working!
20:32:18 <int80_h> ozy`: chapter five is chock full of newbie-confusing brokeness
20:32:23 <SamB> even when it compiles
20:32:31 <mm_freak> SamB: ah yes, but they don't use haskell
20:32:43 <ksf> @ask conal I'm confused... or rather unsure. Does passing different Clock TimeT's to makeEvent's have any semantical consequences that I really don't want to deal with?
20:32:44 <lambdabot> Consider it noted.
20:32:46 <int80_h> if I was just a casual newbie, vaguely interested in haskell I would have thrown the book away by now and forgotten al labout haskell.
20:32:58 <Peaker> Lemmih: you here?
20:33:00 <mm_freak> @faq would haskell code make the LHC work?
20:33:01 <lambdabot> The answer is: Yes! Haskell can do that.
20:33:07 <SamB> mm_freak: sure we do
20:33:14 <SamB> it's a Haskell compiler, written in Haskell
20:33:23 <ozy`> int80_h: hmmm, that needs to be fixed by the next printing, I guess... the authors are dons and who else? I forgot
20:33:26 <Lemmih> Peaker: Maybe.
20:33:35 <Peaker> Lemmih: I just emailed you a patch to fix SDL-ttf's use of Ints
20:33:38 <Peaker> Lemmih: into CInts
20:33:41 <SamB> to quote our blog:
20:33:43 <rwbarton> SamB: Doesn't LHC work whenever it compiles, just by definition? :)
20:33:47 <SamB> "No, not that Hadron Collider. The Haskell Compiler."
20:33:53 <int80_h> ozy`: I forget too. I'm all for making this book what it can be though.
20:34:01 <mm_freak> SamB: oh well, i thought you mean the large hadron collider (LHC), because "it's always not working!" would fit
20:34:04 <int80_h> in the meantime I still need to fix this code
20:34:09 <mm_freak> and they don't use haskell
20:34:43 <Lemmih> Peaker: Thanks.
20:34:49 <SamB> I think we made our blog soon after we tried going to the channel ##lhc to talk about our compiler ?
20:35:02 <Peaker> Lemmih: no problem, thank you for the bindings, I'm really productive with those :-)
20:35:18 <mm_freak> can LHC create a black hole?
20:35:27 <mm_freak> "NO!  damned, it's just a compiler!"
20:35:28 <_roconnor> @type maybe
20:35:30 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:35:37 <dolio> GHC can detect black holes.
20:35:50 <int80_h> if it can't compile a black hole, what good is ti in the Real World (tm)?
20:36:09 <SamB> LHC apparantly asserts the existance of black holes with great regularity
20:36:11 <mm_freak> it can
20:36:16 <thoughtpolice> SamB: that it does!
20:36:19 <thoughtpolice> :)
20:36:25 <int80_h> okay I think my problem code has been reduced to a mere typo, I hope
20:36:28 <dublpaws> it'll probably be the first language to generate a singularity
20:36:34 <SamB> namely, right when it's about to update them
20:36:39 <wli> Goddamn, my back is hurting like Hell.
20:37:01 <mm_freak> @faq can haskell create a black hole?
20:37:02 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:08 <Pseudonym> How much does Hell hurt?
20:37:19 <idnar> Pseudonym: approximately wli's back
20:37:22 <wli> Sorry, meant for -blah
20:37:25 <int80_h> only the mormon part of hell hurts. oh wait, that's heaven.
20:37:30 <Axman6> argh, trying to convert Gofer to haskell is annoying. trying to figure out which maps should be fmaps is a real pain
20:37:34 <Nafai> int80_h: :P
20:37:38 <mm_freak> @faq can haskell know the state of the cat without opening the box?
20:37:39 <lambdabot> The answer is: Yes! Haskell can do that.
20:37:44 <Pseudonym> Axman: All of them!
20:37:57 <Axman6> heh, good point actually :P
20:38:04 <SamB> no, actually it's the other way 'round
20:38:09 <SamB> all our fmaps should be maps
20:38:10 <pumpkin> Axman6: #maxosx is mean
20:38:15 <SamB> but we departed from the True Haskell
20:38:24 <Axman6> they are?
20:38:33 <mm_freak> > map (+1) $ Just 3
20:38:35 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Maybe t'
20:38:38 <mm_freak> =/
20:38:50 <pumpkin> Axman6: I went in to ask a question about whether people like a program and some dude comes to me and says "Polling is not allowed in here."
20:39:36 <Pseudonym> pumpkin: Use select() instead.
20:39:36 <Axman6> wth?
20:39:36 * wli thought there was some sort of clash between ML-like module systems with higher-order modules etc. and Haskell-like typeclasses.
20:39:41 <idnar> > (.) (+1) $ Just 3
20:39:43 <lambdabot>   Couldn't match expected type `a -> b'
20:39:50 <Axman6> when was that? and who said it?
20:39:55 <pumpkin> earlier today
20:39:59 <pumpkin> can't remember his nick
20:40:00 <idnar> mm, no caleskell
20:40:01 <dolio> wli: Well, you have to figure out what the scope of instances are.
20:40:02 <pumpkin> let me go in and see
20:40:16 <ddarius> wli: Nope.  Quite the opposite.  The problem is that they overlap too much so naively sticking both together is inelegant.
20:40:17 <Axman6> was it an op?
20:40:23 <mm_freak> select() instead of poll()?  that's quite non-democratic
20:40:28 <idnar> hahaha
20:40:31 <idnar> epoll()!
20:41:04 <SamB> idnar: it's rigged, I tell you!
20:41:08 <conal> any lhs2TeX users here?  i'm wondering why this doesn't work out:  %format sqrt (u) = "\sqrt{" u "}"
20:41:08 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
20:41:19 <mm_freak> > (+1) <$> Just 3
20:41:21 <lambdabot>   Just 4
20:41:34 <SamB> conal: what happens ?
20:41:39 <pumpkin> Axman6: nope, I tried to explain that I wasn't polling but just asking whether someone liked one program over another, and he replied with "you asked for people's opinions, thus you are conducting a poll, which is not allowed." or something along those lines, so I just left
20:42:11 <SamB> okay, people
20:42:12 <dublpaws> pumpkin: sounds like a real hoot in there.
20:42:15 <SamB> vim or emacs ?
20:42:20 <pumpkin> yup :)
20:42:27 <conal> SamB: i get a latex error: "! Missing } inserted.", though the generated latex code looks good to me.
20:42:31 <mm_freak> pumpkin: ridiculous
20:42:42 * rwbarton edits files by writing String -> String functions
20:42:44 <ozy`> pumpkin: so what program -was- it, anyway?
20:42:47 <SamB> conal: where did it get inserted ?
20:42:50 <Pseudonym> I guess the way around it was asking about experiences with some program.
20:43:01 <Pseudonym> You'd get identical answers.
20:43:10 <wli> ddarius: I think it had something to do with instance visibility, esp. where some sort of "open world assumption" comes in.
20:43:12 <pumpkin> ozy`: I'll rant in -blah :P don't want to be too off-topic in here :)
20:43:37 <Axman6> pumpkin: doesn't sounds like something that'd normally happen
20:44:16 <dublpaws> @let Data CatDead = True | False
20:44:16 <lambdabot>   Parse error
20:44:17 <pumpkin> Axman6: his nick ended with an AZ, and I've seen him before in #macdev
20:44:45 <Axman6> MariasAZ?
20:44:45 <conal> SamB: i don't think i know what you're asking.  the context was "acos (D x x') = D (acos x) (x' / (-  sqrt (1 - x^2)))"
20:44:47 <ike_> When we use GHC 6.10.1, can we change the history of ghci in ~/.ghc/ghci_history?
20:45:00 <ike_> ah , size of history
20:45:03 <pumpkin> Axman6: think so
20:45:13 <Axman6> think i have the spelling wrong, but anyway
20:45:14 <SamB> conal: what was the full error message from LaTeX ?
20:45:21 <SamB> surely it gave context in the message...
20:45:26 <Axman6> MariusAZ
20:45:37 <Gracenotes> a -> (a -> (b, c)) -> (b -> ()) -> (c -> (d, e)) -> (d -> ()) -> (e -> (f, g)) -> (f -> ()) -> g
20:45:43 <Gracenotes> you can use djinn to solve this maze: http://files.waukeganschools.org/students/MazeCraze/MazeIntro.gif
20:45:45 <pumpkin> Gracenotes: that's pretty impressive
20:45:45 <ksf> do I want to know the answer to the question why there's no waitThread :: ThreadId -> IO ()?
20:45:46 <Gracenotes> :)
20:46:08 <Axman6> @djinn a -> (a -> (b, c)) -> (b -> ()) -> (c -> (d, e)) -> (d -> ()) -> (e -> (f, g)) -> (f -> ())  -> g
20:46:08 <lambdabot> f a b _ c _ d _ =
20:46:08 <lambdabot>     case b a of
20:46:08 <lambdabot>     (_, e) -> case c e of
20:46:08 <lambdabot>               (_, f) -> case d f of
20:46:08 <lambdabot>                         (_, g) -> g
20:46:10 <Gracenotes> pumpkin: it doesn't mean too much. It's just a type representation of a graph
20:46:27 <ddarius> Gracenotes: That's cute.
20:46:54 <ddarius> Gracenotes: You'd enjoy a logic language.
20:47:27 <Gracenotes> such as Prolog? (if that's a logic language)
20:47:44 <conal> SamB: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=981#a981
20:48:14 <ddarius> Prolog is an example, and unfortunately the only real representative example.  There are better logic languages than Prolog, but none with the kind of backing.
20:48:23 <conal> SamB: more context: the lhs2TeX block is inside a figure environment.
20:48:36 <SamB> conal: were you in math mode ?
20:48:38 <rwbarton> conal: is the \sqrt within $...$?
20:48:40 * wli liked mercury.
20:49:18 <pumpkin> conal: LaTeX error messages are pretty useless :/
20:49:26 <conal> it's in whatever mode lhs2TeX uses for \begin{code} ... \end{code}
20:49:28 <Gracenotes> I've heard it's a mind-bender... /me should try it
20:49:32 <ddarius> Mercury is functional-logic and thus arguably not representative and there are better languages than Mercury (particularly better languages for working with logic programming)
20:49:48 <ddarius> Gracenotes: Every programmer should learn Prolog (and then never use it)
20:49:58 <Gracenotes> :)
20:50:07 <idnar> hahaha
20:50:15 <sbahra> ddarius, what is a better logic language than Prolog?
20:50:16 <dublpaws> can template haskell create types dynamically at runtime?
20:50:30 <wli> ddarius: What would you recommend more highly than Mercury?
20:50:32 <pumpkin> well, it can create types at its runtime
20:50:37 <pumpkin> which is compile time for most people
20:50:50 <ddarius> sbahra: lambdaProlog for a start.  Unfortunately, most of the languages that really go with the idea of a logic language only have toy implementations.
20:50:58 <ddarius> LolliMon is awesome, but a toy.
20:51:18 <mlh> I was amazed to find someone actually using prolog in a commercial setting.  Apparently it can be used in IBM's Tivoli management thingy
20:51:29 <int80_h> ddarius: what would be required for a logic language to be industrial strenght, i.e. not a toy?
20:51:40 <ddarius> int80_h: Serious implementations.
20:51:46 <wli> Prolog technology theorem provers?
20:51:55 <wli> That's one of the things I liked about Mercury.
20:51:59 <int80_h> ddarius: what would make it serious?
20:52:12 <int80_h> better error handling?
20:52:20 <ddarius> int80_h: At a start, the implementors shouldn't consider it a toy.
20:52:59 <int80_h> okay, put a different way. What makes it a toy. Please don't say "because it's not serious" :)
20:53:47 <erikc> performance, tooling, ffi, tunability of logical -> physical mapping
20:53:48 <ddarius> int80_h: No support intended, buggy, incomplete, no libraries, unusably inefficient, missing important language features.
20:54:01 <int80_h> thanks. good enough :)
20:54:02 <SamB> ddarius: some of us are good to our toys
20:54:07 <erikc> o, libraries, yea, thats important too :)
20:54:45 <erikc> i wish datalog would have panned out
20:55:11 <int80_h> hey is anyone working on a ruby implementation in haskell? I always thought PUGS was an excellent piece of marketing
20:55:17 <stu8ball> Any Lojbanists here btw, speaking of logic languages.
20:55:18 <erikc> most commercial sql dbs have extensions to enable datalog-like features
20:55:19 <dublpaws> I'm wondering, Gracenotes extravagent type above, if types were first class, maybe there'd be more options for implementing fast data structures...
20:55:19 <stu8ball> ?
20:55:36 <Axman6> anyone know what abort in Gofer was?
20:55:42 <dublpaws> int80_h: there is one already (ruby interpreter)
20:55:46 <Axman6> or became
20:55:54 <dino-> I have a situation where it would be neat for two functions in a module to have the same name and the same types except for the "return" type.
20:55:58 <int80_h> dublpaws: is it in hackage?
20:56:12 <dublpaws> don't think so.
20:56:16 <dino-> This reminds me of the kind of spooky (=~) in Text.Regex.Posix.Wrap
20:56:21 <ddarius> Axman6: You can try looking at old versions of the Haskell Report.  It's probably error or some variant thereof.
20:56:22 <int80_h> why the hell not? it really should be
20:57:27 <ddarius> dino-: If there are only two, it sounds like you should simply give them different names unless you think you'll add more later.
20:57:31 <Axman6> ddarius: well i've got lines like "writeFile dst output abort done", and readfile taking functional arguments
20:57:31 <dino-> Is that kind of typeclass hackery really the only way to do that?
20:57:34 <dublpaws> int80_h: it's called rtype, though the author claims it's not as fast as  the C implemenation
20:57:44 <dino-> ddarius: ya, it's very much not important to force the same naming.
20:58:07 <int80_h> dublpaws: cool, I'll google it
20:58:27 * wli is still trying to think of the specific issue with "open world assumptions" and instance visibility vs. higher-order module systems.
20:58:27 <ddarius> Axman6: It might be a continuation for some continuation-based IO.
20:58:44 <ddarius> Axman6: Probably an error continuation.
20:58:49 <dino-> I wonder sometimes if it's possible for pugs to just be the actual P6 interpreter. Instead of parrot.
20:58:50 <Axman6> yeah
20:59:11 <SamB> dino-: what is this "the"?
20:59:15 <ddarius> dino-: You mean sociologically?
20:59:30 <SamB> I've got my doubts as to whether any one will win out
21:00:06 <dino-> In the sense that you go and get one P5 interpreter now. The one that everybody uses for your platform.
21:00:06 <Axman6> bloody hell... ok, i'm going to have to read this paper and write this thing from scratch i think
21:00:36 <ddarius> dino-: I can't see anything technologically stopping that, hence my question.
21:00:55 <Axman6> ghc jpeg.hs 2>&1|wc -l => 240
21:01:00 <ddarius> Axman6: You don't like pre-monadic IO systems?
21:01:01 <dino-> ddarius: Yes
21:01:16 <SamB> dino-: well, that's partly because nothing else can run P5 code
21:01:26 <Axman6> ddarius: they;re fine, i just turned them into monadic ones... but then i got 240 lines of errors :P
21:01:27 <SamB> Perl6 has had multiple implementations for a while now
21:07:10 <dino-> SamB: re running P5: I'm reminded of chatting once with people on Perlmonks. I said something, I think it was commenting on how the regex code knows the difference between a $ for end of string and when $ is for interpolating a variable.
21:07:21 <chrisdone> http://www.haskell.org/pipermail/libraries/2003-December/001576.html
21:07:27 <dino-> And they told me you don't ever want to see how the code in there works.
21:07:30 <dino-> run away
21:07:31 <chrisdone> nice little smtp library with plain text authentication support
21:07:48 <chrisdone> I might put it on hackage seeing as it's not already there
21:08:12 <ksf> can seq be defined in pure haskell without -XexistentialQuantification?
21:08:15 <lispy> data IntList = Nil | Cons Int IntList; IntList == forall l. l -> (Int -> l -> l) -> l.  I see this in a paper, could someone help me understand it?
21:08:26 <SamB> ksf: it can't be defined in Haskell at all ever
21:08:33 <lispy> :t seq
21:08:35 <lambdabot> forall a t. a -> t -> t
21:08:41 <SamB> it's always a primitive
21:08:54 * ddarius is not sure if lispy is serious or not.
21:09:04 <idnar> seq doesn't have anything to do with existential qualification afaict
21:09:16 <lispy> ddarius: I'm serious.  I don't see how the list is similar to that function
21:09:19 <SamB> the type of seq is nothing special
21:09:26 <SamB> it's what it does with bottoms ...
21:09:31 <ddarius> lispy: That type is the type of the Church encoding of a list.
21:09:32 <idnar> @type foldr
21:09:33 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:09:42 <sbahra> SamB, erotic
21:09:53 <ddarius> :t \l n c -> foldr n c l
21:09:54 <lambdabot> forall a b. [a] -> (a -> b -> b) -> b -> b
21:10:04 <idnar> what the huck
21:10:08 <idnar> er, heck
21:10:15 <idnar> oh, server died, I guess
21:10:18 <ksf> Hmmm. I was just reading http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types and got the impression, as you can't do heck with forall a . a
21:10:21 <rwbarton> :t \f -> f [] (:)
21:10:22 <lambdabot> forall a a1 t. ([a] -> (a1 -> [a1] -> [a1]) -> t) -> t
21:10:28 <ksf> ...except force thunks.
21:10:29 <nikki93> What's with the Netsplittation?
21:10:43 <ksf> but this thunk forcing might be exactly what needs a primitive.
21:11:15 <lispy> ksf: Well, case is how you force a thunk without seq
21:11:19 <ddarius> ksf: Having a unboundedly polymorphic function that forces values requires a primitive.
21:11:55 <idnar> At approximately 07:10 this morning, an aircraft carrying 800 passengers on a Freenode Airlines flight exploded while in midair. The cause of the explosion is unknown, but emergency response personnel say it is unlikely anyone survived the disaster.
21:11:58 <ksf> netsplit mania
21:12:03 <lispy> this is due to "type abstraction" (Reynolds 1983) by the way :)
21:12:04 <dino-> Did we just get moved to a new server automatically?
21:12:12 <SamB> oh come on can't they just kill the server already ?
21:12:36 <lispy> ksf: I jsut happen to be reading a paper on existentials too...
21:12:38 <stu8ball> ugh
21:13:04 <lispy> rwbarton: I'm still staring at that, but that's a very illustrative type you have :)
21:14:24 <rwbarton> lispy: It should be specialized
21:14:39 <rwbarton> :t \(f :: [Int] -> (Int -> [Int] -> [Int]) -> [Int]) -> f [] (:)
21:14:44 <ksf> I just collided my nick with myself.
21:14:51 <rwbarton> @botsnack
21:15:12 <BMeph> Hmm, net split?
21:15:20 <nikki93> Wtf?
21:15:27 <nikki93> lolfreenode
21:15:32 <Gracenotes> the servers are having a figurative orgy :/
21:15:37 <nikki93> Massjoin?
21:15:38 <BMeph> freelolnode
21:15:44 <ksf> I tried to do polymorphic lists several times, instinct telling me that it should be possible iff I got a class to constrain stuff too, but never succeded until I saw it in code.
21:15:45 <nikki93> I HAVE to take a screenshot of this.
21:15:55 <jeffz`> @users
21:16:04 <lambdabot> Maximum users seen in #haskell: 658, currently: 357 (54.3%), active: 5 (1.4%)
21:16:05 <nikki93> ksf: Shh, right now its time to sit back and watch freenode fill up.
21:16:13 <ksf> I've never seen it in a tutorial before, is it in rwh?
21:16:24 <nikki93> > let f = (+2) in f 3
21:16:30 <lambdabot>   5
21:16:36 <nikki93> Yay I still remember haskell. :)
21:16:53 <gwern> http://www.reddit.com/r/gnu/comments/7smnc/is_there_a_canonical_rebuttal_of_criticism_of/c07aoks <-- man what am I on and where can I get some
21:17:27 <idnar> man, this is painful
21:17:35 * ksf doesn't know why /lusers should be a operation too expensive to execute.
21:17:43 <jeffz`> weird, my client says there was about 600 netsplits in the last few minutes
21:17:58 <idnar> jeffz`: some server seems to be bouncing up and down
21:18:36 <alar>  /loosers operation? what's it?
21:18:43 <ksf> it's /lusers.
21:19:05 <ksf> shows the number of lusers on the server.
21:19:09 * SamB_irssi wishes he had access to the power cable on that server
21:19:23 <Gracenotes> my entire buffer it covered in splits
21:19:26 <Gracenotes> *is
21:19:32 <Gracenotes> *spills
21:19:37 <Gracenotes> *no, splits
21:19:41 * Gracenotes gives up
21:19:45 <nikki93> Yeah!
21:19:47 <gwern> 1/lusers
21:19:55 <jeffz`> heh, smart irc clients (erc for emacs) only displays the splits in the server buffer not in channels :P
21:20:00 <gwern> omterestomg
21:20:02 <Gracenotes> boo, irssi users
21:20:14 <ksf> ...this server has 0 servers connected.
21:20:16 <Gracenotes> yeah, I should probably write a plugin for ChatZilla to make it a bit more bearable
21:20:18 <nikki93> I'm on irssi.
21:20:30 <nikki93> irssi ftw!
21:20:35 <nikki93> It works without X too!
21:20:41 <Gracenotes> irssi's netsplit functionality is neat, though
21:20:49 <SamB_irssi> my irssi isn't handling these joins well
21:20:54 <Gracenotes> "Display ___ to see all users parted in netsplit" -- no thank you
21:20:59 <nikki93> SamB_irssi: Neither is mine, but who cares.
21:21:02 <Gracenotes> at least that's what my irssi did
21:21:07 <SamB_irssi> but I guess they're from people who were tired of bouncing
21:21:16 <chrisdone> http://git-scm.com/
21:21:19 <lispy> My irssi freaked out and I had to disconnect for a bit
21:21:20 <chrisdone> GHC should be on that list!
21:21:50 <lispy> data Fix f = Fix (f (Fix f)) -- Does this basically qualify as an infinite type?
21:21:54 <Gracenotes> chrisdone: GHC doesn't get as much hype as all those other projects :(
21:22:03 <rwbarton> @users
21:22:03 <lambdabot> Maximum users seen in #haskell: 658, currently: 349 (53.0%), active: 12 (3.4%)
21:22:06 <chrisdone> Gracenotes: I don't know what the hell "prototype" is
21:22:10 <lispy> Is GHC fully on git these days?
21:22:14 <chrisdone> or andriod
21:22:36 <lispy> android is probably google's mobile platform for their cell phones
21:22:40 <Gracenotes> Prototype -- probably the most popular JS library out there... Android: Google's version of the iPhone
21:22:49 <chrisdone> fair enough
21:22:53 <ksf> more importantly, darcs could be in the list of other vcs's.
21:23:06 <stu8ball> jeffz`: 600?
21:23:12 <Gracenotes> still, some representation would be good :)
21:23:35 <stu8ball> If I do /last -file splits Netsplit where 'split' is a named pipe, and have `<splits wc` in another shell, I get 140
21:26:25 <stu8ball> lol chanserv
21:26:42 <lispy> What is the technical definition of a term?
21:26:53 <lispy> is that a "value" roughly?
21:31:14 --- topic: '["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell" "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:31:14 --- topic: set by dons on [Mon Dec 08 22:35:28 2008]
21:31:18 <SamB> man, how many pieces did they split this network into ?
21:34:05 <BMeph> Tumbling in the spinning dryer of teh intarwebs...
21:35:18 <alar> can it be so that installation of one package disrupts the other package?
21:35:29 <lispy> BMeph: I feel as though I've lost a sock or two here
21:35:43 <SamB> lispy: and 200-300 channel members ?
21:36:08 <elly> that wasn't very fun
21:36:09 <lispy> SamB: yeah, give or take
21:36:38 <SamB> they should learn to take things DOWN when they break, not toggle them like that ...
21:36:52 <BMeph> lispy: Well, I feel less linty, anyway... ;p
21:37:07 <lispy> my client isn't able to follow the netsplits tonight and I use irssi...so something nasty is happening
21:37:09 <ixdy> SamB: nah, this is more fun
21:37:21 <idnar> lispy: I'm assuming that wasn't manual intervention
21:37:30 <lispy> I assume this is the change Obama was talking about ;)
21:37:52 <ddarius> lispy: A change you can believe in.
21:38:00 <SamB> lispy: what, he cut the funding to freenode ?
21:38:15 <SamB> why would obama do that ?
21:38:40 <sjanssen> @users
21:38:40 <lambdabot> Maximum users seen in #haskell: 658, currently: 389 (59.1%), active: 9 (2.3%)
21:38:43 <ixdy> wow
21:38:46 <elly> we have been owned
21:39:20 <sjanssen> @users
21:39:21 <lambdabot> Maximum users seen in #haskell: 658, currently: 397 (60.3%), active: 9 (2.3%)
21:39:30 <SamB> they're trickling in, we'll be back up to nearly full size in 10 minutes I'm sure
21:39:39 <sjanssen> it is fun watching the channel grow :)
21:40:05 <alar> @oosers
21:40:05 <lambdabot> Maximum users seen in #haskell: 658, currently: 412 (62.6%), active: 10 (2.4%)
21:40:17 <ray> @hosers
21:40:17 <lambdabot> Maximum users seen in #haskell: 658, currently: 414 (62.9%), active: 11 (2.7%)
21:40:24 <SamB> @lusers
21:40:24 <lambdabot> Maximum users seen in #haskell: 658, currently: 412 (62.6%), active: 11 (2.7%)
21:40:28 <alar> @loosers
21:40:29 <lambdabot> Unknown command, try @list
21:41:03 * lispy <3 hosers
21:41:19 <sjanssen> @users
21:41:19 <lambdabot> Maximum users seen in #haskell: 658, currently: 435 (66.1%), active: 12 (2.8%)
21:41:36 <mmorrow> , 42
21:41:36 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:41:58 <SamB> hey, lambdabot is doing pretty well for such a major netsplit ...
21:42:46 <sjanssen> SamB: IIRC netsplits used to cause major problems in lambdabot, mysterious crashes and the like
21:42:56 <SamB> sjanssen: I know!
21:42:58 <alar> @lusers
21:42:58 <lambdabot> Maximum users seen in #haskell: 658, currently: 495 (75.2%), active: 13 (2.6%)
21:43:01 <SamB> that's what I'm talking about
21:43:08 <Axman6> this is going to take a while...
21:43:25 <BMeph> This is going to take a LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOng while... :|
21:43:54 <SamB> hmm, isn't this a lovely time to announce the new LHC release ?
21:44:45 <ixdy> well, if anyone wants to collect a userid -> hostname mapping
21:44:48 <ixdy> now is a great time :)
21:45:05 <mmorrow> SamB: what's the deal with lhc and garbage collection?
21:45:06 <elly> ixdy: there's also always /who :P
21:45:15 <SamB> mmorrow: haven't got any yet
21:45:19 <ixdy> elly: shhh
21:45:22 <ixdy> this is more fun
21:45:32 <SamB> mmorrow: well, except boehm's
21:45:38 <SamB> if you enable that flag
21:45:43 <Axman6> in @users, anyone know how long ago someone nees to have talked to be counted as active?
21:45:51 <SamB> @users
21:45:51 <lambdabot> Maximum users seen in #haskell: 658, currently: 529 (80.4%), active: 14 (2.6%)
21:45:59 <mmorrow> SamB: heh, i looked at that src the other week. it's epic x1000
21:46:14 <SamB> epic in what sense ?
21:46:22 <thoughtpolice> what? boehm gc?
21:46:26 <mmorrow> extensive
21:46:27 <elly> 00:45  rbraun: this is from hubbard's console:
21:46:28 <elly> 00:45  rbraun: dancer-ircd.fre[15809]: segfault at 00000000 eip b7edfb48 esp bfc0362c error 4
21:46:32 <Gracenotes> %Bh
21:46:57 <ddarius> Clearly a Haskerll ircd is needed
21:47:02 <mmorrow> i dunno, look at the code and you'll see what i mean
21:47:06 <SamB> Haskerll was a joke
21:47:08 <alar> @lusers
21:47:08 <lambdabot> Maximum users seen in #haskell: 658, currently: 531 (80.7%), active: 16 (3.0%)
21:47:11 <SamB> how about just plain Haskell
21:47:57 <wli> A Haskell epoll ffi interface could be useful for such.
21:48:00 <mmorrow> also, isn't the boehm collector conservative? ie not exact (or something)?
21:48:16 <SamB> mmorrow: quite!
21:48:21 <SamB> that's why I didn't really count that
21:48:25 <mmorrow> heh
21:48:50 <ddarius> SamB: Most of the ideas of Haskerl were adopted into Haskell.
21:49:09 <SamB> ddarius: huh. why are we adopting the ideas from jokes?
21:49:09 * wli is surprised there aren't more network protocol implementations in Haskell.
21:49:12 <sjanssen> wli: there's an effort to port GHC's RTS to epoll rather than select
21:49:19 <SamB> next we'll be implementing Haskell over Avian Carriers
21:49:41 <wli> sjanssen: spiffy
21:50:12 <ksf> If I've got a bunch of Types, all of them having a Foo constraint and some of them having a Show constraint, how do I get to call the show of those thingies that have a Show instance and do something else for the others?
21:50:37 <lispy> ksf: you want to do reflection on the type classes?
21:50:47 <ksf> errr.... yes.
21:50:48 <mmorrow> wli: to do that without rts support is kinda painful with the current Network.Socket (i've been trying to use a partial libev binding for a webserver with mixed results so far)
21:50:54 <sjanssen> ksf: I don't think you can do that
21:50:58 <ksf> I've already got them all in one list.
21:51:17 <lispy> ksf: usually this involves making a new type class I think.  And you make an instance for types that have the right type class instances
21:51:39 <wli> mmorrow: I did notice something resembling pain when I tried and failed.
21:51:47 <mmorrow> hehe
21:51:50 <lispy> ksf: but, I guess you don't know what to do for something that is both Foo and Show
21:52:02 <bos> stuff like libev ought to not be terribly pressing in general.
21:52:49 * wli wonders if there's something on hackage with BCD support.
21:52:53 <mmorrow> i'm only really trying to use using the part of it relating to Fd's
21:53:17 <mmorrow> so i don't have to deal with select/poll/epoll/kqueue/whatever myself
21:53:19 <ksf> I do know what to do if it's both, the problem is that I can't sort those from the others.
21:54:05 <ribbitmibbit>  Over 80% of Negros lack the necessary genetic mutations for Microcephalin that are necessary for higher cognitive thought processes.  (Microcephalin Study, University of Chicago)  Learn this and evenmore facts about the feral niiiigggger beast at Chimpout.  http://www.chimpout.com/forum/index.php  All non-negroid races are welcome!  We love andrespect Asians, Whites, Indians, Native Americans, non-negroid Jews andHispanics, et
21:54:13 --- mode: ChanServ set +o sjanssen
21:54:16 --- mode: sjanssen set +b *!*=48cf1683@gateway/web/ajax/mibbit.com/session
21:54:16 --- kick: ribbitmibbit was kicked by sjanssen (sjanssen)
21:54:23 --- mode: ChanServ set -o sjanssen
21:54:52 <mmorrow> the only thing is though i think i'd need to use accept in a nonblocking way, but Network.Socket doesn't really support that usage and writing an ffi binding for accept et al would be extremely painful due to all the structs
21:55:14 <mmorrow> so i'm not sure if i'm going to pursue libev anymore
21:55:48 <sjanssen> mmorrow: I'd much rather see support for epoll and the like added to the RTS any way
21:55:57 <mmorrow> totally! me too
21:55:59 <sjanssen> let all applications benefit
21:56:08 <sjanssen> bos: you're working on that, right?  How is it going?
21:56:10 <mmorrow> after all, that's all i'm using libev to get at
21:56:31 <bos> sjanssen: It's going.
21:58:47 <ksf> so there's no way in hell to write a thing that shows all of http://hackage.haskell.org/packages/archive/xhb/0.0.2009.1.6/doc/html/Graphics-XHB.html#t%3AEvent without writing equally many functions, each just calling show?
21:59:49 <ddarius> > gshow (Just 3)
21:59:50 <lambdabot>   /tmp/1988681889395721448:70:36: Not in scope: `gshow'
21:59:54 <mmorrow> , 42
22:00:01 <ddarius> > Data.Generics.Text.gshow (Just 3)
22:00:03 <lambdabot>   /tmp/539404476123148708:70:36:
22:00:03 <lambdabot>      Not in scope: `Data.Generics.Text.gshow'
22:00:08 <rwbarton> , gshow (Just 3)
22:00:09 <mmorrow> hmm, did lunabot crash or just split
22:00:16 * mmorrow checks
22:00:29 <int80_h> @hackage Numeric
22:00:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Numeric
22:00:39 <mmorrow> preflex: seen lunabot
22:00:45 <mmorrow> @seen lunabot
22:00:46 <lambdabot> I saw lunabot leaving #haskell 47m 49s ago, and .
22:00:54 <ksf> @seen preflex
22:00:54 <lambdabot> Last time I saw preflex was when I left ##freebsd, ##hrg, ##logic, #ai, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
22:00:54 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
22:00:54 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #interplanetarylazers, #jhc, #jtiger, #lhc-compiler, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #
22:00:54 <lambdabot> unicycling and #xmonad 47m 30s ago.
22:00:58 <zloog_> I have a real simple program that only opens an sqlite3 connection with HDBC adds around 100k rows to a table and then disconnects. During the executeMany statement I'm getting a "step: SQL logic error or missing database" error. Anyone run into a problem like this before?
22:01:06 <mmorrow> looks like split
22:01:17 <int80_h> @hackage Numeric
22:01:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Numeric
22:01:29 <mmorrow> @users
22:01:29 <lambdabot> Maximum users seen in #haskell: 658, currently: 531 (80.7%), active: 23 (4.3%)
22:02:19 <int80_h> okay, that url for Numeric does not exist
22:02:30 <ddarius> @hackage FraggleRock
22:02:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FraggleRock
22:02:35 <int80_h> is there still a Numeric library, or has it been broken up?
22:02:39 <mmorrow> fragglerock! sweet!
22:03:02 <ddarius> int80_h: Numeric is a standard library, as in Haskell 98 Report standard.
22:03:13 <mmorrow> look in darcs.haskell.org/libraries/base/
22:03:14 <int80_h> RWH says I need to import Numeric to use showHex, but I still get "out of scope"
22:03:22 <mmorrow> um
22:03:23 <ddarius> @hoogle showHex
22:03:24 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
22:03:34 <mmorrow> you should have Numeric
22:03:41 <ddarius> int80_h: Are you sure you don't have a typo or some such?
22:04:05 <int80_h> ddarius: well the book says I need to put it in Prettify.hs. That could be wrong. There is alot wrong in this chapter
22:05:16 <int80_h> it's getting pretty frustrating encountering error after error in a book that's supposed to be teaching me a language I don't know
22:05:17 <rwbarton> I suggest putting the import in the module where you use showHex
22:05:27 <int80_h> rwbarton: okay I was about to try that
22:05:50 <lispy> int80_h: which chapter?
22:05:53 <geezusfreeek> int80_h, what chapter are you in?
22:06:03 <int80_h> lispy: chapter 5
22:06:34 <int80_h> hell
22:06:56 <geezusfreeek> ah, it does appear to be an error in the book, at least online
22:07:13 <int80_h> geezusfreeek : one error among many
22:07:25 <SamB> geezusfreeek: I think the online version has LESS errors, not more
22:07:31 <int80_h> I spend more time fixing this broken code than I am doing any exercises
22:07:35 <SamB> being more up-to-date, in my understanding
22:07:50 <SamB> int80_h: post fixes to the online version ?
22:07:50 <bos> actually, the online version doesn't include the final round of copyedits.
22:08:04 <SamB> oh
22:08:23 <int80_h> SamB: I wouldn't know where to begin. I suppose I could start all over, where I began typing things in
22:08:42 <int80_h> I'd really like this book to be what it could be
22:08:50 <SamB> bos: did they copyedit the code too ?
22:09:05 <bos> int80_h: you should download the example source tarball.
22:09:14 <int80_h> did they have someone actually work through the book cold?
22:09:29 <int80_h> bos: bah, you're right
22:09:55 <int80_h> bos: I didn't see exacvtly where to find that. not mentioned in the book in any prominent place. nor on the website
22:10:25 <int80_h> bos: but I was hoping that typing it in myself would help me understand it. at least slow me down. I tend to read things to quickly
22:10:29 <bos> hmm, good point.
22:11:12 <ksf> ...well, then the question becomes "how in hell do I get a Data instance if I can't (or don't want to) edit the code and add it to deriving"?
22:11:52 <rwbarton> standalone deriving, but it won't solve your problem anyways
22:12:49 <int80_h> I still have some scoping problems but I think I can suss it out. Or at least know what questions to ask
22:13:27 * ksf is going to do some vim magic.
22:14:07 <rwbarton> the problem is basically that the Show instance dictionaries are not packed into the SomeEvent existential type
22:14:11 <rwbarton> (I assume you have a [SomeEvent])
22:14:37 <ksf> ... I have an (Event SomeEvent), but that's essentially the same.
22:14:46 <rwbarton> yeah
22:15:46 <rwbarton> the Event SomeEvent is being produced somewhere outside your control I presume?
22:16:18 <sereven> int80_h: aye, at least that bit seems fixed in the examples tarball and print version of RWH fwiw
22:16:19 <ksf> either inside the x server or inside xhb, depending on pov.
22:16:55 <int80_h> sereven: what's the url for the examples tarball?
22:17:09 <int80_h> I never did find it, in either the book, nor the website
22:19:25 <rwbarton> ksf: I think your only option is to use fromEvent to handle each type you know is an instance of both Event and Show individually
22:19:59 <sereven> int80_h: yeah, took me a while to find, it's on the oreilly RWH page, meh... not bookmarked. The example link. on left
22:20:32 <rwbarton> ksf: if you had control over the construction of the existential wrapper, this would be easier
22:20:46 <ksf> actually, if I'm going to print them all, I'm gonna change the binding generator.
22:27:03 <cpfr> hey what changed in Control.Exception
22:27:14 <cpfr> I am not getting Ambiguous type variable errors
22:28:09 <BMeph> cpfr: Maybe what changed...is You! ;)
22:28:34 <cpfr> DUN DUN dun
22:28:40 <cpfr> Ambiguous type variable `e' in the constraint:
22:28:40 <cpfr>       `Exception e'
22:28:42 <sjanssen> cpfr: basically everything changed
22:28:57 <sjanssen> use base < 4, Control.OldException, or @docs Control.Exception
22:29:11 <cpfr> sjanssen, I had a catchIO function
22:29:16 <cpfr> that I would like to work
22:29:55 <sjanssen> @docs Control.Exception
22:29:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
22:30:31 <cpfr> what was so wrong about: catchIO = handle (hPrint stderr)
22:31:09 <mmorrow> cpfr: fwiw (if you're not using cabal-install) this hack works for me (and i use it quite a bit):
22:31:10 <mmorrow> for i in `find . | grep -vE "_darcs" | grep -E "\.hs"`;do cat $i | sed -r 's/Control.Exception/Control.OldException/g' > a; mv -f a $i; done
22:31:13 <mmorrow> ;)
22:31:36 <mmorrow> i can never remember to sed flag to update in-place
22:31:44 <cpfr> mmorrow, I'm trying to do things the wright way
22:31:46 <mauke> -i
22:31:47 <mmorrow> preflex: see lunabot
22:31:53 <mmorrow> mauke: sweet
22:31:59 <sjanssen> I wonder if anyone will ever switch to the new Control.Exception?
22:32:09 <sjanssen> compatibility is such a PITA
22:32:16 <mmorrow> cpfr: that code fixes the borken code to use the right way ;)
22:32:37 <rwbarton> cpfr: usually you just need to pin down the type variable it's complaining about to SomeException
22:32:56 <cpfr> but catchIO abstracts that out
22:33:07 <mmorrow> yeah, alternatively rake the code and add type sigs
22:33:08 <rwbarton> huh?
22:33:29 <ksf> mmorrow, that's a classical case of not using find monolithically enough.
22:33:30 <cpfr> mmorrow, but what type sig would work
22:33:40 <mmorrow> ksf: haha
22:33:47 <ksf> it actually works like a map, there's no need for a for.
22:34:11 <mmorrow> cpfr: could you paste the def of catchIO?
22:34:35 <mauke> SomeException
22:34:45 <mauke> preflex: seen lunabot
22:34:45 <preflex>  lunabot was last seen on #haskell 5 hours, 26 minutes and 48 seconds ago, saying:  :)
22:34:54 <cpfr> mmorrow: catchIO = handle (hPrint stderr)
22:34:59 <mmorrow> you chould just be able to do:
22:35:01 <mmorrow> catchIO :: IO a -> (IOException -> IO a) -> IO a
22:35:01 <mmorrow> catchIO = catch
22:35:21 <rwbarton> catchIO = handle (hPrint stderr :: SomeException -> IO ())
22:35:23 <cpfr> whoa!
22:35:59 <mmorrow> lunabot is in some #haskell somewhere with like 2 people
22:36:36 <alar> how can I kill a package?
22:36:57 <alar> ghc-pkg lists network-2.2.0.1 in user package list
22:37:08 <alar> but ghc-pkg hide can't find it
22:37:10 <cpfr> thanks mmorrow it worked!
22:37:17 <mmorrow> cpfr: awesome
22:37:41 <rwbarton> alar: ghc-pkg hide --user
22:38:34 <mauke> mmorrow: yay netsplit
22:38:43 <mmorrow> weeee
22:39:08 <cpfr> mmorrow++
22:39:55 <alar> @karma+ rwbarton
22:39:55 <lambdabot> rwbarton's karma raised to 6.
22:40:19 <alar> strange things happen
22:40:52 <alar> when I compile my program under root, every library is in place
22:41:04 <hackage> Uploaded to hackage: lhc 0.6.20090126
22:41:05 <redditbot> Some libgd changes
22:41:05 <redditbot> InfoQ: What Makes Haskell Worth Learning for Real World Applications
22:41:05 <redditbot> Implementing Schneier's SHA-3 candidate in Cryptol
22:41:05 <redditbot> There's the nub (snippet in Perl and Haskell) - Just another lambdabananacamel,
22:41:05 <redditbot> Malcolm Wallace: codec implementations
22:41:10 <alar> but under user it can't find something
22:41:34 <alar> doesn't root package database belong to all users?
22:41:35 <mauke> alar: my crystal ball says: you rm'd a library but it's still registered in the user db
22:41:42 <rwbarton> alar: Sounds like you have packages installed specifically for the root user
22:41:47 <rwbarton> alar: no
22:41:56 <rwbarton> alar: the global package database belongs to all users
22:42:07 <rwbarton> alar: only root can write it, but that doesn't make it the same as root's user package database
22:42:09 <rntz> Is there some deep reason why type synonyms can't be partially applied?
22:42:11 <alar> rwbarton: if I reinstall them all under user, would it work?
22:42:29 <rwbarton> alar: it should, or if you prefer, you can install with --global as root
22:43:13 <alar> rwbarton: how can I discriminate user "root"'s package database from global package databse?
22:43:46 <alar> /usr/local/lib/ghc-6.8.3/package.conf
22:43:48 <rwbarton> alar: Well, if you ghc-pkg list as root, you should see the global packages on top, and root's user packages below; is that what you mean?
22:43:58 <alar> I'm calling this thing "root database"
22:44:03 <mmorrow> rntz: it would make them like functions, and typechecking wouldn't be able to be guaranteed to ever terminate
22:44:04 <mauke> it isn't
22:44:16 <alar> the database that's listed under all users
22:44:33 <rwbarton> That's the global package database
22:44:37 <alar> ok
22:44:41 <alar> terms cleared
22:44:44 <rwbarton> you need to use --global to install things into it
22:45:03 <alar> ah. I see what's wrong
22:45:45 <alar> I have HTTP-4000 both in global (which I erroneously called "root") and user databases, but user database lacks dependencies
22:47:06 <rntz> mmorrow: ah. In that case, is there any way to partially apply (->) to its second parameter (just as ((->) a) partially applies it to its first)?
22:47:37 <rwbarton> rntz: only with a newtype
22:47:43 <mmorrow> rntz: you could use a newtype
22:47:44 <mmorrow> yeah
22:47:53 <mmorrow> (unfortunately that's the only way)
22:47:56 <rntz> :-(
22:48:02 <rwbarton> rntz: i.e., newtype FunctionTo a b = F (b -> a), then you can partially apply FunctionTo
22:48:20 <alar> rwbarton: can it be so that some users can't access packages from global database?
22:48:36 <rntz> Yeah, I can see how it would be done with newtype... ugly, though; but thanks!
22:48:37 <rwbarton> alar: I wouldn't think so...
22:48:53 <alar> then I don't understand
22:49:11 <alar> I have packages HTTP and network in gloval database
22:49:11 <rwbarton> what exactly is going wrong?
22:49:18 <alar> I can use them under root
22:49:25 <alar> but can't use them under user
22:49:37 <rwbarton> can you paste the output of ghc-pkg list as root and as your user?
22:50:06 <alar> @where paste
22:50:06 <lambdabot> http://hpaste.org/new
22:51:08 <alar> http://paste.org.ru/?f8shtd
22:51:59 <alar> http://paste.org.ru/?8w79y6
22:53:30 <rwbarton> hmm
22:53:48 <alar> [root@alarum /home/sysadmin/http]# ghci m2.hs
22:53:49 <alar> GHCi, version 6.8.3: http://www.haskell.org/ghc/  :? for help
22:53:49 <alar> Loading package base ... linking ... done.
22:53:49 <alar> [1 of 3] Compiling BMonad           ( BMonad.hs, interpreted )
22:53:49 <alar> [2 of 3] Compiling Def              ( Def.hs, interpreted )
22:53:49 <alar> [3 of 3] Compiling Main             ( m2.hs, interpreted )
22:53:53 <alar> Ok, modules loaded: Def, BMonad, Main.
22:53:55 <alar> *Main>
22:54:00 <alar> $ ghci m2.hs
22:54:00 <alar> GHCi, version 6.8.3: http://www.haskell.org/ghc/  :? for help
22:54:01 <alar> Loading package base ... linking ... done.
22:54:03 <alar> BMonad.hs:5:7:
22:54:05 <alar>     Could not find module `Network.URI':
22:54:07 <alar>       it is a member of package network-2.2.0.1, which is hidden
22:54:09 <alar> Failed, modules loaded: none.
22:54:11 <alar> Prelude>
22:54:22 <quicksilver> and indeed, it is hidden.
22:54:28 <alar> they both should get Network and HTTp from global database
22:54:28 <quicksilver> network-2.2.0.0 is visible
22:54:32 <quicksilver> 2.2.0.1 is hidden
22:54:40 <rwbarton> right, but the user HTTP-4000.0.4 package is also hidden
22:54:59 <quicksilver> that's OK because there is a global HTTP visible.
22:55:33 <alar> but root gets global network-2.2.0.0 and it's ok for him
22:55:35 <rwbarton> right, so if it's using the global HTTP, why doesn't it depend on network-2.2.0.0 in both cases?
22:56:06 <alar> maybe there are some stale .hi?
22:56:12 <quicksilver> that's possible.
22:56:57 <alar> where should I look for them apart from current dir?
22:57:44 <alar> current dir has no .hi
22:57:59 * quicksilver is thoroughly confused, to be honest.
22:58:26 <rwbarton> me too, I can't say for sure that this behavior is a bug, but it surprises me
22:59:07 <mm_freak> luqui: how can i measure in different bases with quantum-arrow?
22:59:54 <alar> right before I started to try it under root I had misterious problem with HTTP/HXT not finding Network libs
23:00:39 <alar> they had bound to different Network version (I suppose) and could not coexist at run time
23:00:42 <alar> under user
23:00:56 <alar> under root all turned to be pretty well
23:01:25 <glguy> making use of callCC return, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=982
23:02:35 <mmorrow> glguy: rad! i was actually trying to figure out how to do that/exact/ same thing yesterday (seriously).
23:03:02 <glguy> mmorrow, also, with monadlib 3.5.1, there is the AbortM class
23:03:06 <glguy> so you don't need to hack your own
23:03:20 <mmorrow> oh rly? i'll check it out
23:04:55 <alar> rwbarton: maybe I should try to uninstall user's HTTP and both networks?
23:05:00 <mmorrow> the `fix' is the crucial part i was overlooking
23:05:53 <glguy> mmorrow, I use it to write: suspend :: (ContM m, AbortM m a1) => ((a -> m b) -> m a1) -> m a
23:05:56 <glguy> Prelude MonadLib> let suspend f = callCC $ \ k -> f k >>= abort
23:05:58 <rwbarton> alar: uninstall as in unregister?  that might work
23:07:14 <mmorrow> glguy: do you have shift and reset in monadLib?
23:07:39 <glguy> mmorrow, no
23:10:05 <mmorrow> @let shift f = Cont (\k -> runCont (f (\a -> Cont (\h -> (h . k) a))) id)
23:10:07 <lambdabot>  Defined.
23:10:19 <mmorrow> (i think that's it)
23:11:20 <mmorrow> @let reset m = Cont (\k -> k (runCont m id))
23:11:22 <lambdabot>  Defined.
23:12:44 <mmorrow> > runCont (shift (\k -> k 42 >>= k) >>= return . (*2)) id
23:12:45 <lambdabot>       Ambiguous occurrence `shift'
23:12:45 <lambdabot>      It could refer to either `L.shift', d...
23:12:56 <mmorrow> hmm
23:13:00 <mmorrow> > runCont (L.shift (\k -> k 42 >>= k) >>= return . (*2)) id
23:13:02 <lambdabot>   168
23:13:26 <mmorrow> > runCont (callCC (\k -> k 42 >>= k) >>= return . (*2)) id
23:13:27 <lambdabot>   84
23:13:42 <mmorrow> weee
23:14:04 <mmorrow> ski: ping
23:19:47 <nikki93> Just found this awesome language: http://www.cat-language.com/index.html
23:20:52 <mmorrow> sweet turtle graphics run in that screenshot
23:24:05 <glguy> mmorrow, We'll have to get these operators into monadlib :)
23:24:15 <mmorrow> woohoo! :)
23:26:53 <mmorrow> , 42
23:26:56 <lunabot>  42
23:26:57 <mmorrow> , 42
23:26:58 <lunabot>  42
23:28:00 <mmorrow> bot: <socket: 5>: hGetChar: end of file
23:28:02 <mmorrow> bah
23:30:23 * mmorrow wonders what would have caused that (was during the netsplitting)
23:30:34 <bastl> good morning
23:31:03 <bastl> mmorrow: im using your pretty function now. can you give me details about how indentation works?
23:31:17 <mmorrow> bastl: hi.
23:31:26 <bastl> (from haskell-src-meta)
23:31:28 <mmorrow> bastl: it's using the prettyprinter from haskell-src-exts
23:31:50 <mmorrow> bastl: as in you want to tweak how it prints?
23:32:15 <bastl> not yet, but understand (in case of deeply nested lists)
23:32:17 <gio123> @seen Cale
23:32:18 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I don't know when Cale last spoke.
23:32:38 <gio123> @seen ski_
23:32:38 <mmorrow> that's definitely possible, but you'd need to write a copy of it which uses prettyPrintWithMode rather that (as it uses currently) prettyPrint
23:32:38 <lambdabot> ski_ is in ##logic and #haskell. I don't know when ski_ last spoke.
23:33:00 <mmorrow> bastl: what in particular about it are you trying to find out?
23:33:32 <mmorrow> bastl: (for exact details you probably want to check out the src of Language.Haskell.Exts.Pretty)
23:34:13 <mmorrow> http://hackage.haskell.org/packages/archive/haskell-src-exts/0.4.8/doc/html/src/Language-Haskell-Exts-Pretty.html
23:34:40 <bastl> when does it linebreak, how does it do indenting
23:35:24 <mmorrow> ah, i see. i would look at the default for this http://hackage.haskell.org/packages/archive/haskell-src-exts/0.4.8/doc/html/Language-Haskell-Exts-Pretty.html#t%3APPHsMode
23:35:29 <mmorrow> in the code
23:35:47 <mmorrow> ah, it's http://hackage.haskell.org/packages/archive/haskell-src-exts/0.4.8/doc/html/src/Language-Haskell-Exts-Pretty.html#defaultMode
23:36:12 <lgas> I'm trying to import Graphics.UI.GLUT and getting undefined symbol errors.  This is on OS X with GLUT installed from mac ports already.  Any pointers?
23:36:48 <bastl> ok, thanks mmorrow.
23:36:56 <mmorrow> lgas: did you build the haskell GLUT lib /after/ you installed GLUT?
23:37:01 <mmorrow> bastl: no problem :)
23:37:33 <lgas> I don't recall building the haskell GLUT lib.  I assumed it was prebundled or something.
23:37:44 <lgas> I'll try to figure out where it came from and rebuild it.
23:38:06 <mmorrow> it doesn't come bundled with ghc-6.10.*
23:38:25 <mmorrow> (but is on hackage)
23:38:57 <glguy> mmorrow, your implementation translated into monadlib is
23:38:58 <glguy> suspend f = callCC $ \ k -> f k >>= abort
23:38:58 <glguy> reset m = lift $ runContT m
23:38:58 <glguy> shift f = suspend $ \ k -> runContT return (f (\ a -> return (k a)))
23:39:14 <lgas> I just did a "cabal install glut" which appears to have rebuilt it and I still get the same error.
23:39:15 <mmorrow> glguy:  nice.
23:39:19 * mmorrow copy/pastes
23:40:05 <mmorrow> lgas: sucky. that was my best guess. beyond that i dunno :)
23:40:08 <lgas> I'm running ghc 6.8.2 if that makes a difference.
23:40:12 <alar> rwbarton: it works!
23:40:17 <alar> thanks a lot
23:40:31 <luqui> mm_freak, observeWith takes an equivalence relation.  each equivalence class of that relation is a basis vector.
23:40:40 <lgas> I wonder if it's a library path thing.  I bet it is.
23:40:50 <mmorrow> ah yeah, maybe
23:41:08 <int80_h> @hoogle ord
23:41:08 <lambdabot> Data.Char ord :: Char -> Int
23:41:08 <lambdabot> module Data.Ord
23:41:08 <lambdabot> Prelude class Eq a => Ord a
23:41:12 <lgas> Also just noticed that there is a libglut.dylib both in /opt/local (from macports) and in /Developer/SDKs in the Apple dev stuff.
23:41:18 <lgas> That could also be problematic.
23:41:25 <glguy> mmorrow, hmm, I think I was premature in my monadlib code :)
23:41:44 <mmorrow> glguy: heh, i was about to ask you about the callCC in suspend
23:41:55 <glguy> mmorrow, no, that part is right :)
23:42:08 <mmorrow> oh, what is it then?
23:42:23 <glguy> it passes off the continuation
23:42:30 <glguy> and then returns whatever you do straight away
23:42:35 <glguy> aborting the rest of the computation
23:42:40 <glguy> leaving you to resume it later
23:42:45 <mmorrow> hmm
23:43:11 * mmorrow has to play in ghci to understand the issue
23:47:25 <mmorrow>     No instance for (BaseM m IO)
23:47:33 <mmorrow> ?
23:47:37 <glguy> give a type signature
23:47:43 <mmorrow> ah
23:51:05 <lgas> mmorrow: I see some examples online where it looks like people are passing arguments to ghc like -lglut -lGL etc.  I am not doing anything like that (though I've now tried the obvious "-lglut" with no success)... I'm guessing that's the problem?
23:51:18 <lgas> I assume ghc works roughly like a C compiler/linker in terms of command line args?
23:51:31 <lgas> oh look at that, ghc --help is very helpful. :)
23:51:37 <mmorrow> lgas: i'm not sure, but that sounds like a good possibility
23:52:02 <glguy> mmorrow, ok, I think I've got it now
23:52:29 <mmorrow> nice
23:52:36 <glguy> needa paste
23:52:43 * mmorrow is just getting the typesigs worked out
23:52:57 <int80_h> holy cow, chapter 5 finally compiles
23:53:02 <int80_h> now I can play with it
23:53:45 <glguy> mmorrow, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=983#a983
23:53:45 <mmorrow> glguy: (was that a question? if so, yes please :)
23:53:49 <mmorrow> heh, cool
23:54:15 * dormoose is trying to use the iconv library. It apparently takes ByteStrings, not ordinary strings. How to make them Strings?
23:54:41 <blackh> dormouse: pack and unpack
23:54:53 <mm_freak> luqui: i think, i need an example…  in a two-state system, how can i rotate the measure base by 45 degrees?
23:55:08 <luqui> mm_freak, you're talking about a hadamard?
23:56:21 <mm_freak> i'm not good at names…  i have prepared |0°> + |90°>, now i'd like to measure, say, in base |10°> + |100°>
23:56:37 <dormoose> blackh: Pack/unpack take [Word8], will it be compatible with String?
23:56:40 <mmorrow> glguy: nice, that looks like it does it :)
23:57:10 <glguy> mmorrow, it takes a bit of wrangling to avoid using the Cont constructor
23:57:11 <blackh> dormoose: pack and unpack from the ByteString.Char8 package convert straight to/from Strings...
23:57:33 <mmorrow> glguy: heh, wranglin is key in so many things
23:57:36 <mm_freak> @ luqui
23:57:51 <mmorrow> i like suspend
23:57:57 <blackh> dormoose: but in Text.ByteString you'll have to do 'map (fromIntegral . ord)' and similar
23:57:57 <luqui> mm_freak, that rotation is linear.  so you should be able to do it with arrow combis and entangle.
23:58:21 <dormoose> blackh: Hmm! There is a readFile that reads ByteStrings. It's better to use that, I guess.
23:58:24 <luqui> mm_freak, i.e.      newBasis <- rotate -< oldBasis;  observe newBasis;  returnA -< oldBais
23:58:39 <luqui> mm_freak, I can try to work out rotate if you'd like
23:58:51 <blackh> dormoose: Yes, it's fast!
23:58:59 <dormoose> blackh: o wait, no, I want to run it on stdin/stdout. Hey, how to deal with conflicting imports?
23:59:14 <mm_freak> luqui: i think, i could do it myself…  it's just that doing it manually is currently easier =)
23:59:20 <blackh> dormoose: import qualified XXX as YY
23:59:31 <mm_freak> just take the inner product and do the random selection yourself
23:59:53 <mm_freak> "manually" as in without the quantum arrow
23:59:57 <thoughtpolice> @seen dons
23:59:58 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
