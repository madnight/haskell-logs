00:01:44 <Workybob> nope, no dice :(
00:01:44 <ksf> Cannot use record selector `unEventHandler' as a function due to escaped type variables
00:01:56 <ksf> is there another fix other than pattern matching?
00:01:57 * Workybob is confused as to why cabal-install can't find this package anyway
00:02:07 <ksf> and why does only ghci tell me that?
00:02:10 <Workybob> it just report's "fuck off, ghci-haskeline doesn't exist"
00:02:29 <wli> mmorrow: Any tricks to getting ghci to take that as input?
00:02:50 <ksf> anyway, that's Yet Another Ghc Error I Did Not See Yet
00:02:51 <mmorrow> wli: i'll paste
00:03:25 <wli> mmorrow: A mini-lib of TH convenience combinators? ;)
00:04:04 <wli> I've got :set -XTemplateHaskell in my ~/.ghci so it's got to be.
00:06:29 <wli> mmorrow: Get a bot to send me a message about it or something... I've got to go.
00:07:40 <mmorrow> wli: this'll do it with the reg TH lib http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1032#a1032
00:07:54 <mmorrow> wli: haskell-src-meta has all the convenience stuff lunabot has
00:08:09 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1033#a1033 <-- how do I get rid of that case at the bottom?
00:08:28 <mmorrow> wli: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
00:08:43 <mmorrow> ah crap
00:08:52 <mmorrow> @tell wli this'll do it with the reg TH lib http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1032#a1032
00:08:52 <lambdabot> Consider it noted.
00:09:17 <mmorrow> @tell wli haskell-src-meta has all the convenience stuff lunabot has: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta
00:09:17 <lambdabot> Consider it noted.
00:10:34 <mmorrow> ksf: i guess all you can do is make a helper funciton `unEventHandler' or something
00:10:46 <mmorrow> unEventHandler (EventHandler a) = a
00:11:49 <ksf> I bleeding have one!
00:13:40 <ksf>     Inferred type is less polymorphic than expected
00:13:40 <ksf>       Quantified type variable `a' escapes
00:15:33 <mmorrow> sucky
00:21:51 <ksf> why, oh why, do have both XHB and reactive to export a thingie called Event?
00:23:20 <Ralith> to encourage the use of selective imports!
00:23:56 <ksf> ...to encurage importing either one or the other, but not both ?!
00:24:09 <Peaker> I think Python has done right to use: "from blah import *" to discourage this horrible import form
00:24:49 * ksf wants eclipse's automagic import managing.
00:24:57 <daf> Peaker: but "from blah import foo" is uglier than it should be
00:25:36 <ksf> die unless open foo
00:25:48 <Peaker> daf: import blah(foo) is a little less clear and token-wise, same amount of typing :-)  (my texteditor completes the import form when you use "from .."
00:26:28 <Peaker> I think Python import syntax is better and should be adopted for Haskell' :-)
00:26:51 <daf> I really like that the "import" always comes first
00:27:09 <ksf> I like that the die comes first.
00:27:23 <Ralith> I like cake.
00:27:24 <daf> "import *" is much more problematic in Python, because you can't tell statically what it includes
00:27:25 <Peaker> daf: import comes first, but "qualified" or module name, depending if its a closed unqualified or qualified ruins the look anyhow :-)
00:27:33 <daf> Peaker: that's true
00:27:52 * daf gives up programming entirely
00:27:53 <Peaker> daf: Yeah, Python sucks, but (import *) in Haskell is problematic too (even if a little less so)
00:28:13 <daf> Peaker: how so?
00:28:14 <lament> namespace pollution makes reading the code problematic.
00:28:21 <lament> regardless of language.
00:28:30 <Peaker> daf: not just readability wise, it makes API's non-backwards-compatible if they add new names -- they might break compilation of user libraries because of conflicting symbols
00:28:34 <ksf> too much quantifiers do the same.
00:28:39 <ksf> *many
00:28:41 <daf> Peaker: hmm, right
00:28:46 <ksf> I'm never going to learn that.
00:28:52 <Peaker> ksf: qualifiers can often come *instead* of a large part of the name
00:29:39 <ksf> that's the nice thing of Java's style: import Foo.Bar just saves you from typing Foo.Bar everywhere.
00:29:47 <Peaker> ksf: readIORef should not be IORef.readIORef, it should be IORef.read
00:30:04 <Peaker> ksf: I don't know how java imports work, do they all import open unqualified?
00:30:38 <ksf> you import a class or a whole directory of classes.
00:30:47 <mmorrow> ksf: why don't you just:
00:30:57 <mmorrow> import ....Reactive hiding (Event)
00:31:00 <Peaker> ksf: into your own unqualified namespace?
00:31:03 <mmorrow> import qualified ....Reactive as R
00:31:08 <mmorrow> R.Event
00:31:14 <Peaker> ksf: Java and other OO languages have 2 notions of namespaces, and that sucks
00:31:57 <mmorrow> somwhat similar to the idiom (using Map as example)
00:32:08 <mmorrow> import Data.Map (Map)
00:32:09 <ksf> well, anything that's better at avoiding name clashes than c works, in the end.
00:32:13 <mmorrow> import qualified Data.Map as M
00:32:36 <lament> even C works, in the end.
00:32:43 <ksf> import bleedingfigureitoutbytype Foo
00:32:51 <Peaker> mmorrow: I like import qualified Data.Map as Map.         Map.lookup is very clear :-)
00:32:52 <lament> Your module qualifiers just become part of names
00:33:15 <mmorrow> hmm, a list of the "idioms" for doing non-trivial (:= things that can be done with one import expression) import things would be nice
00:33:30 * mmorrow makes one with the cases he can think of
00:33:34 <ksf> so, why doesn't become lookup polymorphic over Maps and whatever else if you import it more than once?
00:33:52 <mmorrow> err, i meant non-trivial := things that can't ...
00:34:02 <ksf> -XImplicitTypeClassing
00:34:16 <mmorrow> um, what do you mean poly over Maps ?
00:34:21 <Peaker> ksf: that would be a horrible feature
00:34:34 <mmorrow> Map is a data
00:34:40 <Peaker> ksf: instead, we should have explicit type-classes to minimize the amounts of symbols out there
00:34:57 * mmorrow likes records of functions over typeclasses
00:35:07 <mmorrow> (othre than in the cases of Functor/Monad/etc)
00:35:15 <mmorrow> (Show/Read)
00:35:30 <Peaker> mmorrow: In what cases do you prefer the records?
00:35:31 <ksf> ...we need HumanelyReadable, too.
00:35:32 <Peaker> mmorrow: Monoid?
00:35:48 <mmorrow> Peaker: in cases where instance selection is a hiderance
00:35:49 <Peaker> we need an auto-derived "DebugShow"
00:35:59 <mmorrow> Peaker: yeah, similar situations to Monoid
00:36:13 <mmorrow> when there's not just one "right" instance
00:36:34 <Peaker> mmorrow: so tuples shouldn't be functors?
00:36:40 <mmorrow> i think Show should be := DebugShow and always be the autoderived instance
00:36:50 <mmorrow> and we'd add a class (e.g.) Pretty
00:37:08 <Peaker> Pretty and Unpretty? :-)
00:37:13 <mmorrow> and in ghci you could select if you want it to by default use Show or Pretty
00:37:16 <Peaker> DebugShow can't have a DebugRead
00:37:35 <mmorrow> DebugShow in my mind is Show
00:37:49 <mmorrow> (so Read is DebugRead)
00:37:59 <mmorrow> and PrettyRead == Parse
00:38:03 <ksf> Show's of lists usually aren't decipherable if longer than say 10 wrapped lines.
00:38:21 <mmorrow> ie Show/Read are for showing/reading haskell expressions representing data values
00:38:40 <mmorrow> and Pretty/Parse are for whatever someone wants them to be for their typ;e
00:38:42 <daf> read . show should == id
00:38:44 <ksf> they should be called TextSerialise
00:39:02 <mmorrow> ksf: but no sane person uses String for serialization
00:39:08 <ksf> ...or rather Serialise Text
00:39:09 <mmorrow> (except in small cases)
00:39:10 <daf> should parse . pretty?
00:39:17 <ksf> so what are they there for?
00:39:32 <mmorrow> daf: i guess that would be up to the programmer for their type
00:39:42 <mmorrow> (i'd want that personally, but who knows)
00:39:54 <mmorrow> ksf: to "see" the structure of data
00:40:21 <mmorrow> , (text . pretty) (Tree 0 [Tree 1 [], Tree 2 []])
00:40:22 <lunabot>  luna: Not in scope: data constructor `Tree'
00:40:29 <mmorrow> , (text . pretty) (Node 0 [Tree 1 [], Node 2 []])
00:40:30 <lunabot>  luna: Not in scope: data constructor `Tree'
00:40:35 <mmorrow> , (text . pretty) (Node 0 [Node 1 [], Node 2 []])
00:40:37 <lunabot>  Node{rootLabel = 0,
00:40:37 <lunabot>       subForest =
00:40:37 <lunabot>         [Node{rootLabel = 1, subForest = []},
00:40:46 <ksf> any show <significant amount of data> isn't parsable by any mere mortal.
00:40:55 <mmorrow> if Show wasn't the derived one, that `pretty' function wouldn't work
00:41:44 <mmorrow> exactly, that's why you'd have a function like `pretty', which parses the shown String as a haskell expression, then prettyprints the two-levels-meta AST back to the one-level-meta one
00:41:49 <ksf> (show . pretty) (Node 0 [Node 1 [], Node 2 []])
00:41:59 <mmorrow> , error ","
00:42:00 <lunabot>  luna: ,
00:42:04 <ksf> , (show . pretty) (Node 0 [Node 1 [], Node 2 []])
00:42:06 <lunabot>  "\"Node{rootLabel = 0,\\n     subForest =\\n       [Node{rootLabel = 1, s...
00:42:16 <ksf> gragh.
00:42:21 <mmorrow> pretty uses the haskell-src-exts parser+prettyprinter
00:42:40 <mmorrow> , show (Node 0 [Node 1 [], Node 2 []])
00:42:41 <lunabot>  "Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = []},N...
00:43:30 <mmorrow> (it's only a concidence that that function is called `pretty' and i mentioned that Pretty class earlier, i didn't mean to imply i mean they're associated)
00:43:57 <mmorrow> , [$ty| pretty |]
00:44:00 <lunabot>  forall a . Show a => a -> String
00:44:20 <darx> hi, how do I store lambdas in lists?
00:44:32 <mmorrow> for instance, run package.conf through that `pretty' to get it human-readable
00:44:33 <ksf> [id,id]
00:44:44 <darx> ksf: without id
00:44:47 <ksf> :t [id,id]
00:44:48 <lambdabot> forall a. [a -> a]
00:44:51 <darx> lambdas
00:45:03 <ksf> :t [sum]
00:45:04 <lambdabot> forall a. (Num a) => [[a] -> a]
00:45:08 <mmorrow> err, well you'd need to `read' it first, but you'd use a modified `pretty' that doesn't `show' first
00:45:47 <ksf> :t [(<|>),mplus]
00:45:48 <lambdabot> forall (f :: * -> *) a. (MonadPlus f, Alternative f) => [f a -> f a -> f a]
00:47:02 <ksf> :t [x -> x, const 2, y -> y]
00:47:03 <lambdabot> parse error on input `->'
00:47:16 <ksf> :t [\x -> x, const 2, \y -> y]
00:47:17 <lambdabot> forall b. (Num b) => [b -> b]
00:47:35 <ksf> does that answer your question?
00:47:40 <darx> yep
00:48:20 <darx> [\x -> x, \x -> x]
00:48:26 <darx> doesn't work
00:48:45 <ksf> :t?
00:49:26 <mmorrow> here's that list of import idioms: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1037#a1037
00:49:33 <mmorrow> i can only think of two ottomh
00:49:39 <Peaker> mmorrow: what would DebugShow for (a->b) be?  That's why I think we need a separate DebugShow -- for things you show but not read, and are only useful for debugging
00:50:13 <mmorrow> Peaker: there couldn't be one. so yes, i see where an additional DebugShow would definitely be nice.
00:50:35 <darx> ksf: why is there no show for lambda lists?
00:50:35 <pirate_girl> when is this so called free world of warcraft clone going to be finished?
00:50:50 <mmorrow> Pretty/Show/Debug <--> Parse/Read/Rebug
00:50:55 <mmorrow> heh, "Rebug"
00:51:29 <mmorrow> darx: what would your preference be for showing machine code?
00:51:34 <ksf> darx, because the code does neither survive compilation nor stays the same.
00:52:21 <darx> JavaScript shows the skeleton
00:52:36 <mmorrow> darx: but in haskell the skeleton/srccode no longer exists
00:53:01 <mmorrow> foreign import unsafe ccall "malloc" malloc :: CSize -> IO (Ptr a)
00:53:03 <mmorrow> show malloc
00:54:45 <darx> thanks y'all
00:55:15 <mmorrow> :)
00:55:29 <ksf> why should anyone want to clone wow? one is too much, already.
00:58:12 <mmorrow> darx: but to actually answer your question about in compiled-to-bytecode expressions in ghci, it'd be possible for ghci to hang onto the src code in addition to compiling to bytecode and show you that, but it doesn't. also, that'd be a ghci-specific thing rather than part of the language.
00:58:24 <ksf> he's gone.
00:58:28 <mmorrow> oh
01:00:55 <ksf> Ah. Is record selectors not working with existentials a feature of case being a core expression?
01:01:21 <ksf> hmmm.
01:02:40 <ksf> wth does case'ing and pattern matching in functions differ?
01:05:27 <ikegami__> I notice that GHCi 6.10.1 has a feature saving history at ~/.ghc/ghci_history
01:06:13 <ikegami__> Can we change the number of histories? For example, to edit ~/.ghci?
01:06:53 <ikegami__> I looked the manual of GHC but unfortunatelly cannot find the description
01:07:31 <ikegami__> Maybe the number of histories, which are saved, is fixed...
01:07:58 <int80_h> oi
01:08:31 <int80_h> I still don't understand partial functions...I'm going to post some brokwn code in a sec
01:09:37 <therp> int80_h: partial in the sense that they may return bottom?
01:09:44 <therp> "return"
01:09:56 <int80_h> partial as in curried
01:10:39 <int80_h> I mean partial applications
01:10:55 <opqdonut> :)
01:11:06 <ksf> that's when you send a resumee but no cv.
01:12:41 <ksf> int80, what's the difference between a function that increments its argument by one and another that takes two numbers and adds them?
01:13:47 <int80_h> ksf, one has always has "1" as an argument to the + operator
01:14:14 <ksf> ...and thus takes one argument less.
01:14:31 <ksf> ...as one is already partially applied.
01:14:36 <int80_h> ksf, I have something more specific than that...hold on
01:14:52 <ksf> (no. it's completely applied. the function is... nevermind)
01:16:35 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1038#a1038
01:16:41 <int80_h> take a look at that if you like
01:17:13 <int80_h> I'm trying to write the graham scan exercise from RWH using idiomatic haskell. running into trouble with partial application using sortBy
01:17:37 <opqdonut> int80_h: why does withPivot take a _list_
01:17:40 <opqdonut> :t sortBy
01:17:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
01:17:42 <|jedai|> int80_h: the problem isn't in sortBy
01:17:45 <ksf> 1) you can't call myCotan with two arguments.
01:17:49 <ksf> it only takes one.
01:18:01 <|jedai|> :t comparing
01:18:01 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
01:18:02 <opqdonut> you want "comparing myCoTan" i guess
01:19:03 <doserj> withPivot a b c = (myCoTan a b) >= (myCoTan a c)
01:19:14 <doserj> sortBy (comparing withPivot a)
01:19:17 <|jedai|> The argument to comparing should translate one PointXY to something you want to compare, instead you gave it a function that take a list of PointXY...
01:19:21 <doserj> sortBy (comparing (withPivot a))
01:19:23 <int80_h> I am comparing myCoTan, but I have to make sure that the write points get compared
01:19:27 <int80_h> right
01:19:46 <int80_h> with is what withPivot is for
01:19:58 <int80_h> thanks guys. I'll do a re-write
01:20:36 <therp> and also withPivot doesn't return Bool as its signature says
01:21:10 <doserj> oh, yep. ignore my suggestion...
01:21:25 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1033#a1033 <-- how to get rid of the case in tryEvents?
01:23:08 <opqdonut> pattern match on EventHandler?
01:23:32 <|jedai|> ksf: tryEv (EventHandler ..) Nothing = ..
01:24:33 <|jedai|> Also 'a >>= return . f' is equal to 'liftM f a'
01:24:51 <ksf> dammit, I was to focused on using a fuction.
01:25:10 <|jedai|> Or 'f <$> a' if you like Control.Applicative
01:26:27 <|jedai|> tryEv (EventHandler fn) Nothing = fn c <$> fromEvent ev
01:28:08 * ksf delights in the fact that fn c <$> fromEvent ev completely matches Connection -> a .
01:28:34 <ksf> which makes it more readable, if you aren't afraid of angle brackets.
01:29:27 <ksf> It's only been a month or so since I started to dig pointless style.
01:31:48 * ksf wouldn't want to explain tryEvent in a "how to write your first gui in haskell" tutorial, though.
01:37:58 <quicksilver> ikegami__: the history is saved by editline or readline, depending which you compiled against, I believe
01:38:27 <quicksilver> ikegami__: it should be configurable in inputrc or somethign like that
01:39:44 <Workybob> does anyone see what I'm doing wrong here? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1031
01:39:52 <Workybob> I fail at getting random bits of software to build
01:40:31 <jeffz`> something to do with inonv being a macro on OS X
01:40:42 <Workybob> oh?
01:40:49 <jeffz`> iconv, yeah
01:40:58 <jeffz`> someone else asked about it in here within the past 48 hours
01:41:01 <Workybob> I don't even know what iconv is, so any background you could add would be useful
01:41:14 <hackage> Uploaded to hackage: concurrentoutput 0.2
01:41:21 <jeffz`> it's for translating between character sets
01:43:03 <jeffz`> http://hackage.haskell.org/trac/ghc/ticket/2979
01:43:06 <jeffz`> could be it.
01:43:50 <Workybob> ah, interesting
01:43:57 <Workybob> cheers
01:45:35 <Workybob> hmm, oh well, that wasn't part of the source I was interested in, I was just hoping to get it building and running in the mean time though
01:53:50 <ikegami__> aha
01:54:35 <ikegami__> quicksilver: thanks for your kindness
02:13:49 <edbond1> why function . is not enclosed in `` when used in map . lines ?
02:14:47 <Saizan_> because it's an operator, i.e. a function whose name is composed by symbols (except some reserved ones)
02:15:20 <quicksilver> edbond1: just like, for eample, 3 + 4
02:15:31 <quicksilver> edbond1: (compare to 3 `add` 4)
02:15:46 <quicksilver> the `` are used to convert ordinary alphabetical functions to infix.
02:15:50 <Saizan_> and (+) 3 4
02:16:34 <edbond1> thanks a lot
02:16:51 <Badger> @seen Peaker
02:16:51 <lambdabot> I saw Peaker leaving #haskell-blah, #haskell-overflow and #haskell 41m 28s ago, and .
02:17:22 <Badger> hmmm
02:17:29 <Badger> anyone alive who's run lambdabot before?
02:17:55 <PeakerWork> I can run it but I have to reboot first
02:18:05 <PeakerWork> Just found a mueval taking 100% cpu, heh
02:18:15 <Badger> oh hello
02:18:20 <PeakerWork> brb rebooting
02:19:59 <Saizan_> is code.haskell.org down?
02:20:37 <Badger> --- community.haskell.org ping statistics ---
02:20:37 <Badger> 14 packets transmitted, 1 received, 92% packet loss, time 13001ms
02:21:16 <Badger> ...ow
02:27:47 <lilac> Badger: i have a running \b
02:28:16 <mcnster> offtopic, but haskell has never let me down yet :).  is there a way to stop ld.so from loading so's at random addresses under linux?
02:28:45 <elbar> i thought that is a feature ;)
02:28:50 <Martijn> :r
02:28:54 <Martijn> doh
02:29:33 <Badger> lilac: what's it using?
02:29:35 <lilac> mcnster: yes, there is. you can use setarch <your arch> -R
02:29:46 <mcnster> its a feature thats making debugging rather difficult :)
02:29:52 <lilac> mcnster: you can also set something in /proc if you want it permanently disabled
02:30:56 <lilac> mcnster: 'echo 0 > /proc/sys/kernel/randomize_va_space' to turn it off for all processes, setarch -R <process> for just one
02:31:16 <lilac> btw, it's not ld.so, it's the kernel that does it
02:31:26 <lilac> Badger: using in what sense?
02:31:35 <Martijn> Can someone please tell me why these 3 lines don't typecheck? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1039#a1039
02:31:40 <Badger> I mean resources
02:32:06 <lilac> 80MB virtual, 20MB resident
02:32:23 <Badger> hmmm, that's a fair bit.
02:32:49 <mcnster> lilac, i tried "setarch x86_64 -R", got a new shell, but under gdb its still a different addy...
02:33:02 <lilac> Martijn: you want the first argument to be 'forall a. f a -> a'
02:33:10 <lilac> (because it's a different 'a' there)
02:33:21 <lilac> or a first argument of 'f (g a) -> g a'
02:34:22 <Martijn> lilac: ah, right, thanks. decomposeL :: (forall b. f b -> b) -> (f :.: g) a -> g a doesn't work either, though.
02:35:41 <Saizan_> what's the error?
02:35:54 <Martijn> Occurs check: cannot construct the infinite type: a = g a
02:38:02 <Saizan_> it works for me
02:38:47 <Martijn> Ah, I needed to turn on RankNTypes.
02:39:00 <Martijn> That's odd, usually GHC suggests that instead of just giving an error.
02:39:13 <Saizan_> true
02:40:22 <Martijn> What's the difference between 'decomposeL :: (forall b. f b -> b) -> (f :.: g) a -> g a' and 'decomposeL :: (f b -> b) -> (f :.: g) a -> g a' ?
02:41:14 <mcnster> lilac, thanks :)
02:41:14 <hackage> Uploaded to hackage: logfloat 0.10.0
02:41:14 <hackage> Uploaded to hackage: darcswatch 0.2
02:41:28 <quicksilver> Martijn: the former takes a polymorphic first parameter
02:41:34 <alexeevg> you pass polymorphic function in the first case, and can instantiate the type variable 'b' in decomposeL at different types
02:41:49 <quicksilver> Martijn: the latter polymorphically takes a monomorphic first parameter :)
02:42:14 <Martijn> Ah... is this similar to the difference between a forall in a type synonym and a forall in a data constructor?
02:42:25 <quicksilver> yes, it's the same issue
02:42:40 <quicksilver> it's actually the difference between forall in a positive position and forall in a negative position
02:42:46 <Martijn> Right. I only recently realised that those two foralls are completely different.
02:42:48 <quicksilver> that is, to the left of an odd number of (->) signs.
02:43:02 <Martijn> Ah... what's that called again, covariant and contravariant?
02:43:05 <quicksilver> yes.
02:43:12 <Martijn> Right
02:43:17 <quicksilver> well it is also called positive and negative position :)
02:43:20 <quicksilver> but yes, also that.
02:43:35 <Martijn> So those two are the same foralls except in different positions.
02:44:17 <quicksilver> yes.
02:44:39 <Martijn> Sometimes I understand this and sometimes it confuses me horribly. :-(
02:44:49 <quicksilver> there is a sense in which things to the left of the (->) sign are negated.
02:45:05 <quicksilver> in classical logic, "A -> B" is (NOT A) OR B
02:45:07 <Martijn> And I'll be like, yay! I understand! No, wait, I don't.
02:45:12 <quicksilver> this is related to that intuition.
02:45:20 * Martijn nods.
02:45:22 <quicksilver> However the logic of program types is not classical.
02:45:26 <quicksilver> (not normally, anyway)
02:45:31 <quicksilver> but it's a related idea.
02:45:37 <Martijn> Right
02:46:00 <quicksilver> so (forall a. a) -> b is different to forall a . a -> b
02:46:35 <Martijn> because the a is bound in a negative resp. positive position
02:46:55 * quicksilver nods
02:47:01 * alexeevg found an-explicit-type-passing-based explanation very helpful in understanding rank-n types
02:47:04 <pao__> dcoutts: is there a mailing list trace on the discussion about "tracking package ABI"?
02:47:13 <quicksilver> alexeevg: yes, some people find that useful.
02:47:24 <quicksilver> some people find the 'game theory' explanation of function types useful.
02:47:32 <quicksilver> "Your opponent chooses the type" vs. "You choose the type"
02:47:37 <Martijn> Aha
02:48:03 <quicksilver> if your opponent gets to choose the type, then you've got to prepared to cope with anything
02:48:17 <quicksilver> whereas when you get to choose, you can make it match other stuff if you want it to.
02:48:30 <Martijn> That makes sense
02:48:33 <alexeevg> nice one
02:48:37 <Martijn> Is there a wiki article about this?
02:49:00 * Saizan_ was trying to find the link to the angelic/demonic choice article he once read
02:50:55 <Saizan_> btw, it's related to the fact that exists a. F a <=> Not (forall a. Not (F a))
02:51:16 <quicksilver> Martijn: http://en.wikipedia.org/wiki/Game_semantics
02:51:25 <quicksilver> (that may no be a good article, I haven't read it yet)
02:52:25 <Martijn> It looks interesting but too far away from Haskell to be of use to Haskellers, I think.
02:53:50 <koeien> what is the difference between (forall a. a) -> b and forall a. a -> b   ? in theory perhaps, but in practice the only function that will do is bottom?
02:54:30 <koeien> in the first case `id' works, but it's impossible to construct (forall a. a) ?
02:54:37 <alexeevg> right
02:54:48 <quicksilver> yes, not the most illuminating example
02:54:55 <quicksilver> although I didn't quantify the 'b'
02:55:01 <quicksilver> you could fix it to, e.g., Bool, if you want
02:55:18 <quicksilver> then the first one has solutions id, const True, and const False
02:55:29 <quicksilver> whereas the second only has const True and const False
02:55:40 <koeien> yes, apart from variations on bottom
02:56:09 <koeien> then my understanding was correct, thanks
02:56:31 <Martijn> and not.
02:56:53 <koeien> good catch
02:57:02 <Martijn> but that's being nitpicky.
02:57:03 <quicksilver> oh yeah, and not.
02:57:23 <quicksilver> fun examples require slightly more interesting types.
02:58:44 <Martijn> The reason for my question is that I'm trying to write a function :: Fix (f :.: g) -> Fix g
02:59:13 <Saizan_> > let f :: forall a. Show a => a -> String -> (String,String); f s = (s 1, s 'a') in f show
02:59:14 <lambdabot>   Couldn't match expected type `String -> (String, String)'
02:59:25 <Saizan_> ops
02:59:40 <quicksilver> by supplying "unF :: forall a . f (g a) -> g a " and rippling it through the Ins? ?
02:59:45 <Martijn> I think I need an (forall a. f a -> a) for that. And I think g needs to be a Functor.
03:00:08 <Martijn> Yeah
03:00:22 <quicksilver> g being a functor would help you with g (f a) -> g a
03:00:27 <quicksilver> you don't need it this way around.
03:00:52 <quicksilver> and in anycase, you don't need anything to be a functor if you are happy to specify the type of unF more precisely, like I did.
03:01:05 <Martijn> Okay
03:01:49 <Saizan_> how do you recurse in the Fix (f :.: g) inside g if it's not a functor?
03:02:12 <quicksilver> Saizan_: good point.
03:02:19 <alexeevg> @where (:.:)
03:02:19 <lambdabot> I know nothing about (:.:).
03:02:44 <Saizan_> newtype (f :.: g) a = O (f (g a))
03:02:55 <Martijn> functor composition
03:03:01 <alexeevg> thanks
03:03:27 <quicksilver> technically, just type composition.
03:03:36 <quicksilver> You're just *thinking* of it as functor composition.
03:03:39 <quicksilver> Which is fair enough.
03:04:02 <Martijn> Well, any type constructor ::: * -> *, so Functor is too specific, true
03:09:36 <Martijn> If I extract the (forall a. f a -> a) into a type class I won't need to write forall anymore, right?
03:09:54 <opqdonut> err type class?
03:10:04 <opqdonut> are you sure you don't mean encapsulate it in a type
03:10:14 <Martijn> I am sure
03:10:22 <Martijn> I'm looking at category-extras' Copointed
03:10:31 <opqdonut> ah
03:11:19 <opqdonut> well the type of coreturn is still "forall a. Copointed c => c a -> a"
03:11:25 <quicksilver> you can make a class for 'f' which contains a method "forall a . f a -> a", yes.
03:11:30 <quicksilver> I still think you don't want this.
03:11:41 <quicksilver> I still think you actually want (forall a . f (g a) -> g a)
03:11:46 <Martijn> Why?
03:12:01 <quicksilver> because in practice very few functions have 'extract'
03:12:09 <quicksilver> however morphisms FG -> G are quite common
03:12:15 <opqdonut> itym functors
03:12:17 <quicksilver> s/functions/functors/
03:12:46 <quicksilver> you can fail to have extract in general, but still have a restricted extract, relative to a particular 'g'
03:12:47 <Martijn> Hmm. f (g a) -> g a is more specific and therefore occurs more often?
03:12:50 <quicksilver> right.
03:12:59 <quicksilver> of course I don't know what you're *actually* trying to do :)
03:13:20 <Martijn> Well, f is gonna be (,) Annot in my case
03:14:50 <quicksilver> ah, well, you're OK there
03:14:53 <quicksilver> that's for sure :)
03:15:08 <Martijn> What I'm actually trying to do is have a datatype ExprF, and I want to write parser combinators that help you write parsers that yield Fix ((,) PositionInformation :.: ExprF).
03:15:48 <quicksilver> I think that's quite interesting.
03:16:48 <PeakerWork> @bot
03:16:48 <lambdabot> :)
03:16:48 <lunabot>  :)
03:17:03 <Martijn> I hope so; it's for my master thesis :-)
03:17:06 <opqdonut> fixing compositions of functors is the intuitive way of inserting stuff into an ast
03:17:16 <opqdonut> I tried it for a compiler and it made my code horrible
03:17:25 <opqdonut> so i went the specialised GADT way
03:17:40 <quicksilver> horrible code isn't necessarily a block for a master's thesis
03:17:46 <Martijn> Hehe
03:17:49 <quicksilver> doing somethign clever is more important than doing it elegantly ;)
03:17:54 <opqdonut> indeed :)
03:17:57 <opqdonut> Martijn: which uni?
03:18:01 <Martijn> Utrecht
03:18:21 <quicksilver> you can have a chapter about the fact that your code is much less ugly than previous attempts by opqdonut but still leaves a lot to be desired.
03:18:32 <opqdonut> :--)
03:18:44 <quicksilver> why the long face? ;)
03:19:52 <opqdonut> i like to comment out mismatching parenthesis :P
03:20:04 <opqdonut> er, -ses
03:20:26 <Martijn> Fix ((,) Info :.: ExprF) is interesting but it doesn't work for mutually recursive data types
03:20:36 <Martijn> But I'm hoping the multirec library/paper can help me with that
03:20:38 <dcoutts> pao__: I don't think it's been discussed on a mailing list actually
03:22:09 <Martijn> what's ABI stand for?
03:22:29 <Axman6> application binary interface?
03:22:33 <opqdonut> application binary interf...?
03:22:36 <pao__> dcoutts: no problem... thanks... it seems a very reasonable approach indeed ;-)
03:22:49 <Axman6> oh, beelsebob's opqdonut!
03:22:54 <opqdonut> huh?
03:22:56 <Axman6> beelsebob'd even
03:23:11 <opqdonut> basically ABI is to linking what API is to compiling
03:23:31 <Axman6> opqdonut: it's scary the nimber of times he's done that to me, said almost exactly what i was writing, just before i said it
03:23:32 <Martijn> Aha
03:23:40 <pao__> Martijn:  yep "Application Binary Interface"... in this context I guess it's a mix of API and ABI...
03:23:43 <opqdonut> Axman6: well, glorious stereo and all :)
03:23:53 <Axman6> making me look like a fool. there's i much humiliation
03:25:15 <Axman6> anyone looked at any Gofer? its 'monad comprehensions' are rather odd imo. use the same syntax as list comprehensions
03:25:18 <Martijn> opqdonut: what did you mean by specialised GADT?
03:26:03 <opqdonut> Martijn: well i use phantom types to give the type of the subtree, Stmt, Expr, and so on
03:26:07 <opqdonut> and also the annotation type
03:26:11 <alexeevg> Axman6: what's so odd about them?
03:26:23 <Axman6> well the return's at the top for one
03:26:32 <opqdonut> and then transform functions on a per-subtree-type basis
03:26:34 <Axman6> so following the code can require some jumping
03:27:17 <alexeevg> do you find list comprehensions natural?
03:27:21 <Martijn> opqdonut: does that mean you put all constructors (from Expr, Stmt, etc) in one big GADT?
03:27:33 <pozic> Can I refer to a module that is higher up the hierarchy than the current module? In module X.Y.Z I want to refer to module L, which is two directories above the directory containing X.Y.Z.
03:27:47 <opqdonut> Martijn: yeah basically
03:27:56 <Martijn> opqdonut: that doesn't sound too elegant :-(
03:28:00 <opqdonut> Martijn: which is very specialised, yeah
03:28:05 <pozic> (Without modifying the search path)
03:28:18 <opqdonut> i looked around for more elegant solutions but they really didn't work in terms of expressing the transformations
03:28:25 <Martijn> *nods*
03:28:28 <opqdonut> i even had a general-ish attribute grammar system at one point
03:28:43 <opqdonut> and I started with mutually recursive vanilla types, which turned out horrible
03:28:59 <opqdonut> I actually have a few blog posts on this if you're interested
03:29:05 <Martijn> Sure
03:29:27 <opqdonut> http://pseudo.fixme.fi/~opqdonut/blog/Attribute_Grammars__GADTs_and_MonadFix__part_2_.html <- that's part two, links to part one
03:29:32 <opqdonut> part three never came out
03:29:55 <opqdonut> the subject is AST and transform representation, not parsing
03:30:03 <Martijn> Nice, thank you
03:30:34 <Saizan_> pozic: module names are absolute
03:31:18 <Saizan_> pozic: i.e. if you've src/X/Y/Z.hs your searchpath should be src/
03:31:46 <pozic> Saizan_: ah, ok. I just tried it and it worked.
03:32:30 <ksf> threading is great, threading sucks.
03:32:44 <Axman6> damn right!
03:32:46 <ksf> that is, if you thread enough, your program is gonna quite really, really soon.
03:32:56 <ksf> *quit
03:33:56 <ksf> ...so I actually have to block on an mvar as last action in main to stop it from committing suicide.
03:34:43 <fasta> ksf: yes, I believe most people trip over that.
03:35:02 <opqdonut> heh
03:35:09 <opqdonut> ugly
03:35:15 <ksf> it is, in fact, quite interesting to have an interactive program without a main loop.
03:35:52 <Martijn> ksf: maybe this is what you're looking for: martijn.van.steenbergen.nl/journal/coexec
03:36:53 <opqdonut> nice
03:37:25 <ksf> ...with just a small problem: all those sub-threads never, ever quit on their own.
03:38:33 <Martijn> ksf: when should your program stop running?
03:38:47 <ksf> when an event handler decides that it should.
03:39:37 <ksf> so it's gonna write to the right mvar or just do exitWithExitSuccess.
03:39:49 <Martijn> ah
03:40:02 <fasta> Martijn: heh, that code has been written by at least 5 different persons now.
03:40:10 <fasta> Probably > 100 ;)
03:40:13 <opqdonut> guess it should be in the libs then
03:40:14 <opqdonut> :)
03:40:27 <fasta> opqdonut: I think it is, since less than a year.
03:40:33 <opqdonut> ah
03:40:37 <fasta> Don't ask me where.
03:40:51 <opqdonut> haven't been doing threads lately
03:41:48 <ksf> gosh.
03:41:49 <ksf> i did
03:41:51 <ksf>     lock <- newEmptyMVar
03:41:51 <ksf>     takeMVar lock
03:41:54 <ksf> and got
03:42:01 <ksf> Demo: ExitSuccess
03:42:02 <ksf> Demo: thread blocked indefinitely
03:43:26 <ksf> wait... key handlers should'nt react to expose events.
03:43:43 <Martijn> quicksilver: can you give an example where f (g a) -> g a is possible but f a -> a is not?
03:43:45 <ksf> (so much about type safety
03:43:53 <ksf> yeah.
03:43:58 <ksf> haskell is just too smart.
03:44:05 <quicksilver> Martijn: Maybe [a]
03:44:15 <quicksilver> you can't do Maybe a -> a
03:44:19 <ksf> I have to write to the mvar at some time in the future, or it won't block.
03:44:25 <quicksilver> but Maybe [a] -> a is possible
03:44:29 <quicksilver> (send Nothing to [])
03:44:34 <alexeevg> Martijn: IO (IO a)
03:44:45 <quicksilver> that's the other canonical one, yes.
03:44:46 <opqdonut> yeah, f=g for any monad f
03:44:52 <quicksilver> alexeevg++ # not sure why I missed that
03:45:06 <quicksilver> in a way, that's what's behind my one too
03:45:15 <quicksilver> since Maybe is "like" the list monad
03:45:20 <Martijn> Nice, thanks.
03:45:23 <quicksilver> my example factors through [[a]]
03:45:35 <quicksilver> and join :: [[a]] -> [a]
03:46:11 <Martijn> Is there a name for f (g a) -> g a?
03:47:09 <quicksilver> I'm not aware of one.
03:47:22 <quicksilver> g (f (g a)) -> g a woudl be one leg of an adjunction.
03:47:42 <ksf> could it be that mvars don't like reactive?
03:48:08 <Martijn> Hmm
03:48:12 <quicksilver> ksf: certainly reactive is designed to be used single-threadedly and 'in control of' the main thread
03:48:14 <Martijn> It's sort of like a join but not quite.
03:48:35 <quicksilver> ksf: although that's more a function of how a particular reactive adapter might work than reactive itself
03:48:41 <quicksilver> since reactive is demand-driven.
03:49:32 <ksf> it also pushes.
03:49:59 <quicksilver> I don't believe it does.
03:50:08 <Axman6> anyone know of any nice State tutorials/exercises?
03:50:20 <quicksilver> reactive is entirely driven by if/when you inspect the behaviours and events
03:50:28 <Martijn> Axman6: Real World Haskell maybe?
03:50:52 <Axman6> well, the State stuff in there is mixed up in stuff that i wasn't very interested in :\
03:51:00 <Axman6> but, i should take another look
03:52:52 <lilac> yay, my copy of RWH has arrived :)
03:53:00 <ksf> well, there's forkE in Reactive.Internal.Reactive, and conal is using unamb.
03:53:08 <ksf> I wouldn't call that "single-threaded"
03:53:21 <ksf> I'm still looking for his locks, though.
03:53:24 <quicksilver> I didn't say it was single-threaded internally.
03:53:33 <quicksilver> I said itw as designed to be used single-threadedly.
03:53:36 <Martijn> Axman6: http://ertes.de/articles/monads.html#section-6 is also worth a try
03:53:47 <quicksilver> you don't need locks with unamb
03:53:50 <quicksilver> that's kind of the point.
03:53:52 <Saizan_> ?bot
03:53:52 <lambdabot> :)
03:56:26 <ksf> I don't like the idea of using only a single adaptE, and using a single sink would require polling.
03:57:16 <Workybob> reactive never requires you to poll if your OS doesn't already
03:57:45 <ksf> if it doesn't like to be fed from two different threads, it does.
03:57:53 <Workybob> why?
03:58:15 <ksf> ...because I can't block in a single thread on both sources at the same time.
03:58:20 <Workybob> sure you can
03:58:29 <Workybob> there's been several threads on that on haskell-cafe
04:00:56 <ksf> care to point me to them?
04:03:51 <Workybob> "[Haskell] Wait for *either* MVar to be set" would seem to be an encouraging topic
04:04:06 <Martijn> Yay, I finally implemented decomposeLF :: Functor g => UnF f g -> Fix (f :.: g) -> Fix g :-P
04:06:23 <ksf> d'oh.
04:07:53 <ksf> still, I'm not gonna use less threads until conal tells me to.
04:10:37 * Axman6 needs a really nice example of using the State monad. he still doesn't 'get' it
04:11:49 <Martijn> Adman6: did you read ertes' chapter too?
04:12:57 <Axman6> i'm reading it now :)
04:13:55 <Botje> > runState (get) 42
04:13:56 <lambdabot>   (42,42)
04:14:07 <Botje> > runState (modify (-1) >> get) 42
04:14:08 <lambdabot>       No instance for (Num (s -> s))
04:14:08 <lambdabot>        arising from a use of `negate' at...
04:14:13 <Botje> > runState (modify (subtract 1) >> get) 42
04:14:14 <lambdabot>   (41,41)
04:14:36 <Botje> > runState (get >>=  >> get) 42
04:14:37 <lambdabot>   <no location info>: parse error on input `>>'
04:15:01 <Botje> > runState (get >>= \orig -> put (orig-1)  >> return orig) 42
04:15:02 <lambdabot>   (42,41)
04:16:46 <Axman6> get takes the current state out, and put puts back a (possibly) modified state?
04:18:20 <Botje> yup
04:19:04 <Axman6> i still can't see how State is really all that useful
04:19:35 <Botje> i've used it for keeping track of unique names
04:20:27 <Botje> > let uniq = do { num <- get; put (num+1); return $ "UNIQ_" ++ show num} in runstate (replicateM 10 uniq) 0
04:20:28 <lambdabot>   Not in scope: `runstate'
04:20:33 <Botje> > let uniq = do { num <- get; put (num+1); return $ "UNIQ_" ++ show num} in runState (replicateM 10 uniq) 0
04:20:34 <lambdabot>   (["UNIQ_0","UNIQ_1","UNIQ_2","UNIQ_3","UNIQ_4","UNIQ_5","UNIQ_6","UNIQ_7","...
04:21:02 <Botje> i've also used it for storing my grid when doing terrain generation
04:21:24 <quicksilver> Axman6: do you ever find functions (a -> a) useful?
04:21:25 <Botje> it doesn't add functionality to your code, it just makes it clearer
04:21:42 <quicksilver> for some particular 'a'
04:21:45 <Axman6> Botje: not to me :(
04:21:52 <Axman6> quicksilver: possibly...
04:22:02 <quicksilver> like ParseTree -> ParseTree or GameBoard -> GameBoard
04:22:09 <quicksilver> or Document -> Document
04:22:17 <Axman6> sure
04:22:24 <quicksilver> 'State' is just a combinator library for building functions like that.
04:22:26 <Botje> Axman6: just start writing code. some day you'll realize "hey, this is State"
04:22:43 <quicksilver> and saving you from certain mistakes (accidentally using an old version of a variable)
04:22:54 <Axman6> well, i've done things like explicitly passing around something that would be considered state
04:22:59 <ksf> no matter what I do, the rts claims I'm blocking indefinitely and commits suicide.
04:23:27 <quicksilver> Axman6: well, that's all State is
04:23:36 <ksf> ...with a single input and a single output thread, that is.
04:23:38 <Botje> Axman6: I couldn't find a use for Writer either
04:23:39 <quicksilver> Axman6: a slightly more implicit way to pas that around.
04:23:46 <Axman6> yeah, i figured that, i just don't have a feel of how to use it
04:23:49 <Botje> Then i had to write a function to find free variables :]
04:24:50 <quicksilver> Axman6: have you ever written code like this: "let a' = something a; a'' = somethign a'; a''' = something a''" ?
04:25:01 <quicksilver> for different 'somethings' normally ;)
04:25:16 <quicksilver> and often with different parameters hanging around making it look a bit messier.
04:25:25 <Axman6> i'd normally try to compose those ;)
04:25:29 <quicksilver> right.
04:25:34 <quicksilver> well State is just a way to compose them
04:25:42 <quicksilver> you can see it as a generalisation of (.)
04:25:47 <quicksilver> to slightly more complex cases
04:25:52 <quicksilver> where you have "side-return-values"
04:25:57 <quicksilver> as well as the "a" return value
04:26:30 <quicksilver> "let (a',x) = something a; (a'',y) = somethign a'; (a''',z) = something a''" ?
04:27:03 <quicksilver> State (1) deals with those side-return values uniformly and (2) makes it slightly harder to use a'' when you meant to use a'
04:27:13 <quicksilver> but really the reason for using it is the same as the reason to use (.)
04:27:23 <Axman6> fair enough
04:28:14 <osfameron> State seems too magical to understand when I've looked at it
04:28:20 <osfameron> (not looked enough though)
04:28:24 <quicksilver> and there is nothing wrong with not using it when you don't want to
04:28:35 <quicksilver> or with mixing some code which uses it and some code which threads the state explicitly.
04:28:52 <quicksilver> as a learning technique (for any new code abstraction) I like to be able to code partly using it and partly doing it by hand
04:29:06 <quicksilver> and then you can see the exact effect of rewriting one particular sub to use the new abstraction
04:29:14 <quicksilver> and see if you think that's an improvement or not.
04:30:06 <Martijn> I've never really used local state monads yet. Whenever I use a state monad it's because my whole application revolves around that state.
04:30:39 * Axman6 thinks he will stick to explicit state threading, and the ST monad if needed
04:34:37 <quicksilver> Axman6: threading an RNG is a great example of using a state monad to simplify code.
04:34:48 <Botje> Axman6: explicit threading is so annoying :]
04:34:53 <Axman6> yeah, i've seen that done
04:35:02 <Botje> if you need to thread another thing you get to edit all your code again
04:35:14 <Botje> whereas with state you only need to add a field or change a type
04:35:36 <quicksilver> "let (red,g') = random g; (green,g'') = random g'; (blue,g''') = random g'' in (Color red green blue, g''')
04:35:40 <quicksilver> versus
04:35:49 <quicksilver> "Color <$> random <*> random <*> random
04:36:54 <Botje> or liftM3 Color random random random
04:37:58 <Martijn> I like the applicative style better
04:38:09 <Martijn> Since it works for any arity
04:39:23 <icqnumber> can only one function for example toUpper be loaded in ghci instead of loading :m + Data.Char?
04:39:27 <quicksilver> me too, but I don't think it's very important ;)
04:39:49 <quicksilver> icqnumber: not direcly. You can load a file which imports only one function
04:40:00 <quicksilver> "import Data.Char(toUpper)" <-- in a file, which you then load into ghci
04:40:27 <icqnumber> quicksilver, Thank you.
04:40:34 <Martijn> icqnumber: you can write: let toUpper = Data.Char.toUpper
04:40:43 <BONUS> i really wish you could do limited or qualified imports from ghci
04:41:13 <icqnumber> Martijn, oh, yes.
04:41:15 <hackage> Uploaded to hackage: logfloat 0.11.0
04:41:42 <redditbot> Much Ado About Monads â€“ Maybe Edition - Matthew Podwysocki's Blog
04:52:14 * ksf has the nasty feeling that he hasn't got a threading problem, but a problem with existentials.
04:53:26 <marcot> Is planet.haskell.org down?
04:53:39 <Martijn> forall e. Existential e => e -> Void
04:54:43 <quicksilver> BONUS: yes, and data declarations and type declarations
04:54:50 <quicksilver> BONUS: and a way to dump out the current scope/context to a file
04:54:51 <quicksilver> BONUS: :)
04:55:05 <BONUS> haha yeah
04:55:13 <quicksilver> BONUS: but given that you can't do those things, having an editor window also open is pretty convenient.
04:55:14 <ksf> yeah, that's it.
04:55:50 <BONUS> true yeah, when messing around in ghci i just write definitions and imports in an editor and then keep doing :r
04:55:54 <Raynes> Having your GHCi and your editor on the /same/ window is much better (teh Emacsfoo).
04:55:59 * Raynes goes to sleep.
04:56:10 <Badger> marcot: apparently not.
04:56:31 <ksf> I have to do an additional
04:56:31 <quicksilver> uses emacs too, but with two windows. One for source, one for ghci. Or, as a true emacs-sen would call them, frames.
04:56:31 <ksf>     forkIO $ adaptE $ (fmap.const) (return ()) evs
04:56:54 <ksf> to stop the rts from thinking... something.
04:57:02 <osfameron> you can run ghci within emacs?
04:57:07 <opqdonut> yep
04:57:07 <quicksilver> osfameron: of course.
04:57:14 <osfameron> gosh
04:57:19 <quicksilver> osfameron: and hit C-c C-l to send your current file to ghci
04:57:25 <osfameron> wow
04:57:28 <quicksilver> and various other bindings to pull type information in the other direction.
04:57:28 <ksf> anyway, the key is that all reactive events must be sunken back into IO, in some way or the other.
04:57:51 <quicksilver> ksf: if the runtime can detect that you're blocking on an event which can definitely never occur, it will kick you out.
04:57:52 <osfameron> cute.  Doesn't it create all kinds of new hate with terminal emulator within terminal emulator craziness ?
04:58:07 <opqdonut> well emacs has a pretty good term emu
04:58:17 <mmorrow> this is amusing, screenshot-video of three copies of random red-black trees being generated and prettyprinted every 0.1 seconds
04:58:19 <mmorrow> http://moonpatio.com:8080/video/rbtrees.ogg
04:58:20 <opqdonut> and of course you could run it graphically
04:58:23 <quicksilver> you don't use the terminal emulator for ghci (in the normal setup)
04:58:30 <quicksilver> so it's emacs' line editing commands
04:58:33 <quicksilver> not ghci's line editing.
04:58:36 <osfameron> oh?
04:58:38 <quicksilver> emacs' paging commands, etc.
04:58:41 <osfameron> how do you speak to ghci then?
04:58:43 <hugo___> hiiiiii there
04:58:48 <quicksilver> dumb terminal
04:58:50 <opqdonut> osfameron: by typing :)
04:58:50 <quicksilver> one line at a time style
04:58:55 <ksf> yeah, but try to tell the runtime which existentials X might send you if you create windows with such and such parameters.
04:58:57 <quicksilver> i.e. like ghci with readline disabled.
04:59:13 <osfameron> ah
04:59:13 <quicksilver> but that doesn't matter because everything that readline used to do for you, emacs is doing instead
04:59:17 <quicksilver> at the layer above.
04:59:29 <quicksilver> with the benefit of sharing copy/paste buffer with your other files
04:59:30 <osfameron> emacs does sound very powerful, shame I don't get on with it
04:59:32 <quicksilver> and other similar things.
04:59:55 <quicksilver> deep down inside you there is an emacs user trying to get out
04:59:59 <quicksilver> I can see that clearly now.
05:00:06 <osfameron> it's very far down
05:00:09 <quicksilver> I would buy some cheap white sheets in case it gets messy.
05:00:21 <osfameron> I tried the builtin tutorial several times.  Used to make me very angry
05:00:36 <quicksilver> from anger comes strength.
05:00:37 <osfameron> though I did get to the end of it the last time (3 years ago or so) but didn't stick with it
05:00:51 <quicksilver> the best way to learn emacs is to have a co-worker who uses it
05:00:56 <osfameron> yeah I guess
05:01:00 <quicksilver> and spend a week or so saying "so, what's the best way to do this?"
05:01:10 <osfameron> I always had viheads to learn from
05:01:11 * Botje started using emacs to edit lisp
05:01:21 <SamB> is it just me or is code.haskell.org down ?
05:01:25 <quicksilver> I was taught emacs and perl and cgi and http in 1993/4 on a work experience placement.
05:01:33 <quicksilver> that was a very formative 4 weeks.
05:01:40 * mstr started learning lisp to to able to use emacs
05:01:48 <int-e> ksf: You may be running into RTS bugs that reactive has uncovered recently. They're fixed, but you need ghc head or a recent snapshot of the ghc 6.10 branch for the fixes.
05:01:49 <quicksilver> this fancy thing called 'mosaic 0.9'
05:01:51 <quicksilver> those where the days.
05:01:59 <SamB> mstr: actually you only need to know lisp to CONFIGURE emacs
05:02:34 <mstr> sense of humour is also optional, but helps with learning emacs too
05:02:59 <mstr> ;)
05:03:05 <SamB> why do you mention it ?
05:03:08 <SamB> I have one ;-P
05:03:40 <SamB> oh, it turns out code.haskell.org is just really slow
05:04:09 <mstr> any good monad tutorials? :)
05:04:26 <ray> write a monad tutorial
05:07:17 <bastl> just noticed that nearly every link to "pretty" logs of #haskell on http://tunes.org/~nef/logs/haskell/ is broken. Is the maintainer around?
05:07:49 <ksf> oh bugger.
05:08:00 <ksf> reactive definitely messes up if you have more than one adaptE.
05:09:35 <ksf> from the outside, it seems to leak events exponentially with every forked adaptE you add.
05:12:22 <ksf> this means that I have to thread back every single existential that that the forall matches, which kinda defeats the reason XHB uses existentials in the first place.
05:14:22 <SamB> bastl: I guess nef hasn't kept his links up to date, or the site(s) folded ...
05:15:23 <dancor> is code.haskell.org up
05:15:43 <SamB> well, I did a pull recently after asking the same thing
05:15:54 <SamB> and it took a while but worked
05:16:22 <dancor> i can't load code.haskell.org in browser and (darcs get --partial http://code.haskell.org/yi) failed after like 10min
05:16:38 <mmorrow> Saizan: ping
05:16:42 <SamB> oh, I was using SSH
05:16:47 <Saizan> mmorrow: pong?
05:17:11 <mmorrow> Saizan: hey. i can't remember, what was the issue you hit with hbuild?
05:17:37 * mmorrow thinks it would be really cool if cabal could build stuff in parallel
05:17:50 <mmorrow> not only cool, but hugely time-saving
05:17:55 <Saizan> mmorrow: serializing Dynamic, with some Ord/Eq context
05:18:03 <mmorrow> ah yeah, that's right
05:18:21 <dancor> SamB: but normal humans like me don't have ssh accuounts right
05:18:30 <mmorrow> Saizan: was this in relation to parallel building?
05:18:40 <SamB> dancor: I dunno. I might have been normal when mine was activated.
05:19:35 <h0tzenpl0tz> hello, we'll have software-design exams tomorrow and we wonder if you can find something like proxy- or decorator-pattern when only haskell data/type types are given.
05:20:00 <SamB> I applied a while back, and sometime before I started hacking on LHC my application must have been accepted, but either they didn't send me an email or I missed it
05:20:02 <Saizan> mmorrow: well, i could do without, but then i'd have to use a fixed union type representing all the different kinds of targets needed during the build
05:20:28 <SamB> decorator pattern ?
05:20:36 <SamB> in *Haskell* ?
05:21:05 <Saizan> mmorrow: which is what i admittedly did in the prototype
05:21:56 <mmorrow> Saizan: tell me if i'm not seeing all the pieces here:
05:23:01 <SamB> h0tzenpl0tz: those patterns aren't very common in Haskell, I don't even have a clue what decorator would look like ...
05:23:30 <mmorrow> so you would get some sort of dependency graph for a package, then take the SCCs or some such, then proceed to walk the graph in parallel building each node and using MVars to sync up at the join points
05:23:45 <mmorrow> ?
05:24:00 <mmorrow> or are we talking about at the level of packages..
05:24:16 <mmorrow> (in which case the graph would be a package dep graph instead of a module dep graph)
05:24:46 <Saizan> mmorrow: well, yeah, the point is that in the general case you need to start building before you can see the whole graph, e.g. with preprocessors
05:24:50 <ksf> conal is going to love this.
05:24:50 <mmorrow> and each runProcess/whatever would be in a forkIOP
05:24:53 <mmorrow> *forkIO
05:24:56 <omg911> is there any GUI bindings for haskell that looks native on macOS?
05:25:05 <Martijn> wxhaskell maybe?
05:25:07 <mmorrow> Saizan: ah, good point
05:25:30 <lilac> @pl \l -> f (g x l) l
05:25:30 <lambdabot> f =<< g x
05:25:45 <mmorrow> Saizan: ok, but even so you'd eventually have the graph, right?
05:25:48 <omg911> martijn: ah really i was trying to make the latest build on darcs but there were some type error and i gave up
05:25:51 <Saizan> mmorrow: and also the real aim was to create a good EDSL for describing builds, that would track dependencies automatically, so you don't get all the problems with incorrect Makefiles you see out there
05:26:05 <Martijn> omg911: i have no experience building wxhaskell, so i can't help you there
05:26:15 <Martijn> omg911: i just thought it did native stuff on mac
05:26:26 <mmorrow> Saizan: that sounds cool, i remember reading some stuff on that
05:27:02 <mmorrow> Saizan: i guess i'm only focusing on building packages and/or modules in parallel to save time
05:27:06 <omg911> martijn: thanks anyways, you know any others?
05:27:25 <mmorrow> do you see any inherent difficulties with doing just that?
05:27:34 <mmorrow> (given cabal as it is/whatever)
05:27:43 <Martijn> omg911: afraid not
05:28:02 <Saizan> mmorrow: supporting preprocessors?
05:28:08 <mmorrow> sure
05:28:10 <Etenim> Hey. I have sort of a problem. I need to compile a short Haskell program using the HOpenGL/GLUT package for the Windows platform, but I, myself, don't have Windows installed anywhere. Could someone do that for me?
05:28:23 <mmorrow> (assume also you can parse arbitrary haskell code)
05:28:52 <quicksilver>  /win 37
05:28:55 * quicksilver sighs
05:29:04 <mmorrow> aren't all preprocs external to ghc? (since TH can't add imports)
05:29:19 <mmorrow> in which case you'd just parse their output and extract whatever
05:29:30 <Saizan> so you mean doing only the compilation of haskell modules in parallel?
05:29:49 <Axman6> quicksilver: 37 windows? impressive
05:29:58 <Saizan> already preprocessed, i mean
05:30:03 <quicksilver> Axman6: 63 I think
05:30:17 <Axman6> irssi?
05:30:24 <mmorrow> actually, i'm thinking of parallelism at two levels. the first being wrt modules within a single cabal pkg, and the second wrt packages within a single build session.
05:30:58 <Saizan> the second part is much easier, and you'd implement it in cabal-install
05:31:06 <mmorrow> but i'm most interested in wrt diff packages in par, since i think this would bring the most savings
05:31:10 <Saizan> you already have the graph there
05:31:17 <mmorrow> Saizan: exactly
05:31:26 <quicksilver> Axman6: yes.
05:31:29 <mmorrow> Saizan: so you don't think it would be that hard then
05:31:30 <mmorrow> ?
05:31:32 <Axman6> quicksilver: on OS X?
05:31:57 <Saizan> mmorrow: no, you could even start compiling before all the packages are downloaded
05:32:04 <mmorrow> sweet
05:32:07 <Saizan> mmorrow: there's a ticket open for this
05:32:11 <mmorrow> oh?
05:32:22 <Axman6> or, from OS X i should ask. if so, i might have something you might be interested in: http://axman6.homeip.net/blog/growl-net-irssi-script-its-back.html
05:32:33 <lilac> @pl \x y -> if y `elem` c then y else x
05:32:33 <lambdabot> flip (if' =<< (`elem` c))
05:32:46 <Axman6> lets you use Growl with irssi, locally, or over a network (including over the internet
05:32:46 <quicksilver> Axman6: no, irssi on debian via ssh + screen.
05:34:23 <Saizan> mmorrow: http://hackage.haskell.org/trac/hackage/ticket/447
05:34:34 <mmorrow> Saizan: great, thx
05:36:30 <dcoutts> mmorrow, Saizan: the greatest benefits are to be had from building individual packages in parallel and merging the build graphs of multiple packages to build everything in one go, in parallel, with fine-grained deps.
05:36:34 <Saizan> i think there's a ticket about starting to build while downloading, but i can't find it
05:36:45 <dcoutts> of course that only works for packages using the same build system
05:37:15 <Saizan> dcoutts: don't you have to register the dependencies first?
05:37:34 <dcoutts> Saizan: yes, but the packages do not need to be built to be registered
05:37:52 <dcoutts> Saizan: and yeah, there's a ticket on doing multiple package builds in parallel, using cabal-install
05:37:57 <SamB> dcoutts: you evil, evil man
05:38:05 <jeffz`> Etenim: I might be able to, link?
05:38:08 <mmorrow> dcoutts: oh interesting. i hadn't tought of merging the module dep graphs of multiple packages
05:38:10 <dcoutts> SamB: hah
05:38:13 <SamB> what if someone else tries to use them then ?
05:38:14 <mmorrow> *though
05:38:17 <mmorrow> **thought
05:38:21 <Saizan> you just need to have the .hi in the right place soon enough eh?:)
05:38:23 <dcoutts> SamB: register it locally
05:38:35 <dcoutts> Saizan: right, you make the deps on the .hi files
05:38:48 <lilac> > map(head.head&&&nub.sort.(>>=tail)).groupBy(on(==)head).sort.groupBy(on(/=)(isUpper.head)).lines$file
05:38:49 <lambdabot>   [("ANIMALS",["cow","horse","moose","sheep"]),("NUMBERS",["one","seven","six...
05:38:50 <SamB> hmm, you mean like in ./dist/cabal-install-tmp or so ?
05:38:51 <lilac> > (map.map)snd.groupBy(on(==)fst).nub.sort.(zip=<<scanl1(\x y->if y`elem`categories then y else x)).lines$file
05:38:52 <lambdabot>   [["ANIMALS","cow","horse","moose","sheep"],["NUMBERS","one","seven","six","...
05:39:11 <dcoutts> Saizan: this is more relevant for packages like gtk2hs or happs, where there are several components that all share the same build system.
05:39:45 <Etenim> jeffz`, http://pastebin.com/d602c8c41  I'd be very thankful. :)
05:39:53 <SamB> dcoutts: I'm sure thise works wonderfully with systems that collect libraries into .hl files ;-P
05:40:00 <Saizan> right, it'd be very nice for happs
05:40:17 <dcoutts> Saizan: and it's less for performance (via greater parallelism) than for devs to be able to treat these multi-package systems as a single system when hacking/building
05:40:53 <dcoutts> SamB: yeah, that'd create pinch points in the dep graph
05:41:03 <dcoutts> SamB: it's a good idea for installed packages of course
05:41:14 <dcoutts> less helpful when hacking
05:41:28 * mmorrow starts collecting graph code
05:41:42 <dcoutts> ghc should do the same for installed packages rather than dozens of .hi files
05:42:14 <jeffz`> Etenim: http://jeffz.name/etenim.exe
05:42:27 <jeffz`> Etenim: compiled with ghc 6.8.2 -O2
05:42:42 <Etenim> jeffz`, thanks!
05:42:48 <jeffz`> Etenim: ps. I don't have windows either :P
05:42:59 <Etenim> jeffz`, how did you do it?
05:43:11 <jeffz`> Etenim: I use ghc under Wine for some things.
05:43:11 <SamB> are you a WINEr, jeffz` ?
05:43:18 <SamB> aww nuts
05:43:19 <SamB> too late
05:43:21 <jeffz`> SamB: the preferred spelling is Wine
05:43:29 <SamB> okay, Winer then
05:43:37 <Etenim> jeffz`, ah. Good to know.
05:43:44 <dcoutts> isn't that a kind of sausage?
05:43:49 <SamB> I thought it stood for Wine Is Not an Emulator
05:43:54 <Etenim> jeffz`, did you try to run the executable?
05:44:05 <SamB> hrmm.
05:44:14 <SamB> or WINE is Not an Emulator, even
05:44:14 <jeffz`> Etenim: it requires you to provide a glut32.dll
05:44:27 <Etenim> Understandably.
05:44:34 <SamB> wait, the Is should be capitalized
05:45:15 <jeffz`> SamB: http://wiki.winehq.org/FAQ#head-8b4fbbe473bd0d51d936bcf298f5b7f0e8d25f2e
05:45:52 <SamB> jeffz`: can I help it if I'm an old-timer ?
05:46:06 <jeffz`> SamB: I forgive you :)
05:46:13 <SamB> I'm stubborn and also very forgetful, so probably you've not accomplished anything by telling me about this ;-P
05:46:27 <SamB> next, you'll be telling me it isn't spelled UNIX
05:46:42 <X-Scale> I'm a Haskell newbie. I wonder if it is possible to create very specific types like a type that only represents prime numbers. Any hints ?
05:46:57 <SamB> X-Scale: not in Haskell, no
05:47:11 <SamB> you can do that in Coq or Agda, though
05:47:11 <X-Scale> SamB: is that a language with such a flexibility ?
05:47:19 <lilac> X-Scale: you can create an abstract type (that is, put it in a module and only export functions which maintain that invariant)
05:47:49 <X-Scale> Oh...interesting. I'll check them out.
05:48:21 <Etenim> Cheers. :)
05:48:42 <lilac> X-Scale: this is the haskell way of doing encapsulation. the type has other inhabitants, but it's not possible to create such values...
05:50:11 <lilac> X-Scale: alternatively, you could say: 'newtype Prime = Prime Nat', and say that 'Prime n' represents the 'n'th prime
05:50:19 <lilac> it depends what you want to /do/ with these things, i guess.
05:51:14 <ksf> what did you do to the hamsters running trac?
05:52:48 <X-Scale> thanks for making it more clear, lilac.
05:56:24 <lilac> X-Scale: any total FP language with dependent types should allow you to construct a type where the inhabitants are values and proofs that those values are prime, if that's what you want
05:56:25 <X-Scale> I was trying to figure out a way of making ever more complex language structures inside a single language. A language than can extend itself in a ever more abstract sense. Lisp can do it in a way.
05:57:05 <X-Scale> Exactly.
05:57:47 <edbond1> http://pastebin.com/m16a30cfd
05:58:07 <edbond1> what should I do to expose package?
05:58:47 <lilac> (i'm guessing what your requirements are here, but...) i think you probably want a module exporting a type Prime, "isPrime :: Integer -> Maybe Prime" and "fromPrime :: Prime -> Integer"
05:59:07 <Saizan> edbond1: you've to unpack the HPDF tarball and edit the .cabal file
05:59:18 <Saizan> edbond1: adding bytestring to build-depends
05:59:38 <lilac> X-Scale: haskell's perfectly fine if you just want to create abstractions like that
06:00:16 <lilac> X-Scale: but if you want the proof that a value is prime to be checked by the type system, you're going to need at least half an Oleg.
06:00:51 <dcoutts_> @seen alexeevg
06:00:52 <lambdabot> alexeevg is in #haskell. I don't know when alexeevg last spoke.
06:00:58 <gnuvince> Is Oleg now a unit of measurement?
06:01:07 <Botje> yep
06:01:08 <pejo> lilac, isPrime should be a predicate, no?
06:01:17 <dcoutts_> Saizan: cabal unpack is so handy
06:01:18 <Botje> @quote milli-oleg
06:01:18 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
06:01:19 <lilac> pejo: if it were, how would you construct Primes?
06:01:31 <edbond1> Saizan: I use cabal on ubuntu
06:01:53 <lilac> pejo: the idea was to combine primality testing with Prime construction to ensure that all Primes are prime
06:01:57 <pejo> lilac, mkPrime, createPrime or similar?
06:02:05 <lilac> pejo: which would have what type?
06:02:22 <Saizan> edbond1: right, but unfortunately the .cabal file in that package is not correct, it probably worked with an older ghc
06:02:24 <Axman6> hmm... i wonder if i could use uvector to make an efficient primes producer...
06:02:24 <alexeevg> dcoutts_: Hi. I received your response, thanks.
06:02:27 <lilac> pejo: if you're saying i picked a bad name, then i agree :)#
06:02:37 <dcoutts_> alexeevg: I realise I was partly wrong! :-)
06:02:44 <pejo> lilac, I'm objecting to your naming of that particular type signature. "isPrime" suggests it is a test, the type signature suggests you're creating the data.
06:02:48 <alexeevg> dcoutts_: ?
06:02:54 <Saizan> edbond1: so you need to fix it manually
06:02:54 <lilac> pejo: well, it's both :-/
06:02:59 <dcoutts_> alexeevg: the thing about headers depending on other headers is right, but the same does not apply for libs
06:03:04 <edbond1> Saizan: thanks
06:03:10 <lilac> pejo: maybeCreatePrime might be better
06:03:29 <dcoutts_> alexeevg: because for libs when we link to them, there are no actual symbols we need from them, so they do not need to pull in their deps recursively
06:03:40 <lilac> pejo: or toPrime for some misplaced notion of symmetry ;-)
06:03:54 <dcoutts_> alexeevg: so the libs are all independent, but the headers are sadly dependent in the way I described
06:04:02 <alexeevg> dcoutts_: true, so ld has nothing to check except the file presense
06:04:29 <dcoutts_> alexeevg: right. So it means we can give a precise list of missing deps, but only a partial list of missing headers
06:04:36 <Saizan> edbond1: which version of ghc are you using?
06:04:49 <dcoutts_> alexeevg: erm a precise list of missing library deps
06:04:53 <alexeevg> dcoutts_: other thing I noticed in autoconf-generated headers - they are slightly more complex, they wap include in #ifdef _cplusplus extern "C"
06:05:09 <alexeevg> not sure if its needed for gcc and *.c - files
06:05:17 <alexeevg> wap/wrap
06:05:25 <SamB> lilac: cooler would be primeOrNot :: Either Composite Prime
06:05:32 <dcoutts_> alexeevg: mm, I guess that is for the sake of c++ headers, or perhaps if one is using a c++ compiler.
06:05:32 <lilac> SamB: nice :)
06:05:45 <edbond1> Saizan: 6.8.2
06:05:52 <dcoutts_> alexeevg: I expect it is not needed.
06:06:05 <SamB> you would actually use something of the sort in a proof setting
06:06:16 <alexeevg> ok, I believe your suggestion is easy to implement
06:06:23 <dcoutts_> alexeevg: I still very much like the idea of doing it all with a single test in the best case, it'd make it much faster
06:06:27 <Axman6> bah! where is pumpkin!
06:06:40 <dcoutts_> alexeevg: if you'v ever sat through a long list of autoconf tests you'll know what I mean :-)
06:06:51 <dcoutts_> alexeevg: then if it fails, we go do the more accurate tests.
06:06:51 <alexeevg> hehe
06:07:23 <SamB> because otherwise, you'd have trouble handling the case where the number failed the primality test
06:07:36 <lilac> SamB: rather, primeOrNot :: Either4 Zero Unit Composite Prime
06:07:46 <SamB> lilac: hmm.
06:07:53 <alexeevg> ok, so it gonna look like mapM_ test (inits headers)
06:08:06 <lilac> SamB: i guess it depends on your definition of composite though
06:08:11 <dcoutts_> alexeevg: yes, if it didn't work perfectly the first time.
06:08:20 <alexeevg> no, mapM_ test (reverse $ inits $ headers)
06:08:37 <alexeevg> there's no special case then
06:08:51 <SamB> lilac: according to MathWorld they're >1
06:09:05 <Saizan> edbond1: so, in the .cabal file, where it says base >= 4, put base >= 3, and where it says base >= 3, put base < 3
06:09:16 <dcoutts_> alexeevg: I don't think that works. I think it does have to start from small to large
06:09:30 <dcoutts_> alexeevg: otherwise you don't know which one is at fault
06:09:51 <alexeevg> dcoutts_: yes. you're right
06:10:23 <lilac> SamB: i guess it's less clear whether zero is a composite (i'd say so, since i think it makes your field a topology under compositeness)
06:10:41 <alexeevg> ok, I hope I'll send patch today or tomorrow
06:11:07 <edbond1> Saizan: compiling! Thank you!
06:12:19 <ktne> hello
06:12:23 <ktne> i'm running ghci
06:12:30 <ktne> will ghci compile to native code internally?
06:12:35 <ktne> or all commands will be interpreted?
06:12:39 <Axman6> to bytecode
06:12:41 <koeien> bytecode
06:12:46 <ktne> hmm
06:12:58 <ktne> is there any interactive haskell that uses a JIT?
06:13:00 <koeien> so slower than native code, but far faster than naive interpreting
06:13:08 <Axman6> so probably closer to compiled speed than inperpreted
06:13:22 <koeien> ktne: if you compile a binary ghci will link to it
06:13:24 <stepcut> I think there is a -fobject-code flag to ghci, not sure what it does though
06:13:26 <Axman6> joachifm: if you've already compiled the code, it will use that
06:13:54 <Axman6> uh, that was for ktne, not joachifm, sorry
06:13:59 <ktne> so haskell is an interpreted language?
06:14:09 <mreh> ktne: no and yes
06:14:18 <ktne> how is that?
06:14:29 <ktne> i always assumed haskell is a compiled language
06:14:30 <Axman6> well, ghc is certainly a compiler
06:14:32 <mreh> you can compile it, you can interperet it
06:15:03 <mreh> gch is a compiler, ghci is an interactive environment
06:15:17 <koeien> there exist a compiler, but for development there is also an interpreter
06:15:18 <ktne> doesn't the interactive environment use ghc as backend?
06:15:23 <koeien> yes
06:15:24 <dcoutts_> alexeevg: great, thanks. no need to wait for it to be perfect, I can hack on it too.
06:15:26 <mreh> it's static typing so it can be fully compiled to binaries
06:15:32 <ktne> no
06:15:34 <ktne> my issue is
06:15:39 <SamB> it uses GHC, but it doesn't do all that native compilation
06:15:43 <ktne> can i run interactive code at native speed?
06:15:49 <koeien> mreh: you could compile dynamically typed languages to binary as well...
06:15:50 <mreh> heyal no
06:16:10 <SamB> it DOES, however, load native .o files for modules you've compiled seperately
06:16:10 <koeien> ktne: e.g. you have a function 'f :: Int -> Int', compiled in another module, and you call that from the interpreter
06:16:11 <augustss> ktne: you can load compiled modules into the interactive environment.  they run at full speed
06:16:14 <koeien> you will get native speed
06:16:25 <ktne> hmm
06:16:29 <ktne> that;s not really what i want
06:16:31 <mreh> is anyone here know if jane's street are stil hiring?
06:16:45 <Axman6> ktne: how is it not what you want?
06:16:52 <SamB> mreh: my guess would be not this week ?
06:16:55 <augustss> mreh: they still have ads on google
06:17:00 <lilac> ktne: you can compile code at runtime using the GHC API, and then you can probably use it from your program.
06:17:04 <SamB> what the heck
06:17:06 <lilac> is that what you want?
06:17:09 <ktne> Axman6: i was looking for an interactive environment that runs at native speed
06:17:15 <SamB> still hiring, are they, in these hard economic times ?
06:17:17 <mreh> would they take on an intern i wonder?
06:17:25 <Axman6> ktne: which ghci can do, people have told you this at least three times now :)
06:17:30 <mreh> time to find out!
06:17:35 <augustss> SamB: they could be making lots of money
06:17:36 <Axman6> ghci foo.o i think may do it
06:17:36 <ktne> they told me it's interpreted
06:17:44 <SamB> augustss: true
06:17:45 <ktne> no
06:17:47 <Axman6> they told you it would run compiled code too
06:17:48 <koeien> ktne: no, bytecode
06:17:51 <ktne> duh
06:17:59 <koeien> ktne: also, compiled code will be run with native speed
06:18:00 <ktne> but i don't need to run compiled code
06:18:04 <ktne> i need to run shell code
06:18:06 <Axman6> ...
06:18:09 <augustss> SamB: you can make a lot of money when the derivative of any value is high, doesn't matter if it goes up or down
06:18:10 <koeien> then there is no way out, I'm sorry
06:18:12 <ktne> i mean, interactive command line code
06:18:13 <mreh> does yaron minksy hang around here?
06:18:20 <Axman6> ktne: so, things you let?
06:18:24 <lilac> ktne: you can take shell code, compile it, then run it at full compiled speed, but i don't think it'll be completely trivial.
06:18:41 <SamB> augustss: hmm, maybe I should start selling aspirins to Haskell n00bs
06:18:45 <Axman6> ktne: the .o files give ghci an interface to running all functions contained within, at native speeds
06:18:52 * ksf hears archive.org's robots whizzing around, searching for the tape the requested site is on.
06:18:57 <ktne> ok, cya
06:19:12 <Axman6> urgh
06:19:16 <mreh> does anyone here have a contact number for jane's street in the uk?
06:19:26 <mreh> janes street?
06:19:35 <augustss> jane street
06:19:39 <lilac> ksf: i really hope you're right about that :)
06:19:39 <SamB> heh
06:19:56 <SamB> mreh: aural learner, eh?
06:20:25 <mreh> no, just stupid
06:20:28 <Axman6> heh
06:20:40 <mreh> aural learner sounds euphemistic anyway
06:20:55 <mreh> just slow on the old uptake are we? yes, yes I am stupid
06:21:15 <SamB> I meant ... you seem to have remembered how it SOUNDS, not how it's spelled ;-)
06:21:41 <mreh> i know what you meant
06:22:13 <augustss> mreh: their web site explains how to contact them
06:22:25 <SamB> I do that a lot too, I think ...
06:22:41 <mreh> jane street in london anyone? would mr minsky be aware of the london team anyway?
06:23:23 <mreh> i like phoning up and checking they got my cv
06:23:58 <mreh> then pestering them with calls until they forward it on to the relevant person
06:24:09 <mreh> heavy breathing etc.
06:24:42 <SamB> I wonder if the London office is anywhere near jane street ?
06:25:13 <mreh> nah, it's on Broadgate
06:25:21 <mreh> shame really
06:25:24 <SamB> hmm, jane street is VERY short
06:25:27 <mreh> they should change the name of company
06:25:53 <SamB> http://maps.google.com/maps?q=Jane+St,+Tower+Hamlets,+London+E1,+United+Kingdom&hl=en&ie=UTF8&cd=4&geocode=FVANEgMdqBb__w&split=0&sll=43.560502,-81.699003&sspn=0.006295,0.011414&ll=51.514712,-0.059655&spn=0.000609,0.001529&t=h&z=19&iwloc=addr
06:25:56 <earthy> somehow broadgate capital fires connotations of being broadsided
06:26:13 <earthy> I'd stay with Jane Street if I were them. ;)
06:26:51 <SamB> I assume they are named after a different Jane Street, since this one is so short and in a residential area, at that
06:27:54 <earthy> http://maps.google.com/maps?client=safari&rls=en-us&q=jane+street+new+york&oe=UTF-8&um=1&ie=UTF-8&split=0&sa=X&oi=geocode_result&resnum=1&ct=title
06:28:18 <mreh> Hoboken.. he he
06:30:32 <daf> maybe it's named after a person
06:30:47 <SamB> named Jane Street ?
06:31:15 <mreh> or nicknamed Jane Street
06:32:02 <SamB> strangely, it isn't in their faq: http://www.janestreet.com/workplace/faq.php
06:32:07 <SamB> eww, php
06:32:25 <mreh> i'll ask in my interview and get back to you
06:33:49 <mreh> what does education re-imbursement actually mean? I have to work for you for a long time before I can get that?
06:34:02 <mreh> from a US perspective, im from the UK obviously
06:34:41 <Axman6> oh no! i get a stack overflow with Data.List.Stream, but not with Data.List :(
06:34:53 <lilac> Axman6: erk! :(
06:35:03 <Axman6> simple program too
06:35:08 <jeffz`> mreh, usually taken to mean that you pay for studies or learning materials out of your own pocket and you might be reimbursed in part or full.
06:35:26 <mreh> would this be part time education whilst i work?
06:36:28 <Axman6> lilac: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1040#a1040 if you're interested
06:37:52 <Axman6> quicksilver: were you responsible for moonpatio?
06:41:43 <redditbot> Learning to Reason in Haskell, Part 2
06:42:08 <Saizan> Igloo: did you see my email about syb-with-class?
06:51:07 <flipflop> Where is the GHC analogue of "/usr/local/share/hugs/lib/Prelude.hs"?    locate Prelude.hs doesn't find anything...
06:52:30 <elly> I have /usr/lib/ghc-6.10.1/base-3.0.3.0/Prelude.hi
06:53:03 <Martijn> flipflop: locate Prelude.hi
06:53:23 <flipflop> that's a binary, any way I can view the source?
06:53:39 <doserj> flipflop: download the ghc source
06:53:46 <flipflop> fair enough....
06:53:49 <flipflop> thank you
06:53:53 <drdo> Has anyone used XMonad with GNOME 2.24?
06:55:11 <doserj> flipflop: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Prelude.html has links to the source code
07:01:56 <flipflop> doserj: thank you! :)
07:03:20 <augustss> @seen igloo
07:03:20 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 51m 33s ago.
07:04:08 <augustss> @seen dcoutts
07:04:08 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 20m 24s ago.
07:04:18 <dcoutts_> augustss: hia
07:04:41 <augustss> dcoutts_: Any rumours about when 6.10.2 will be released?
07:05:11 <dcoutts_> augustss: I've asked recently, nothing definite. There's still quite a few high priority bugs to fix.
07:05:44 <drigz> is there a builtin for a while-type loop in haskell?
07:05:47 <dcoutts_> augustss: to get a reasonable sense, keep an eye on the trac report of tickets for the 6.10 milestone
07:06:01 <cajun-rat> drigz: forM
07:06:13 <Itkovian> Any idea what I am missing, or where I should look to remove the wrapping of the lsat list argument in a second list?
07:06:16 <Itkovian> > ap (map (flip (!!)) [1,2,3]) [[1,2,3,4,5,6]]
07:06:17 <lambdabot>   [2,3,4]
07:06:21 <dcoutts_> augustss: is there anything particular this affects for you?
07:06:27 <lilac> drigz: plenty, depending on what you actually want to do :)
07:06:42 <augustss> dcoutts_: OK.  We want to switch, bug since DLL generation is broken in 6.10.1 we can't.
07:06:45 <drigz> something like IO Bool -> IO () -> IO ()
07:07:08 <drigz> while (not isEOF handle) hGetChar handle >>= print
07:07:08 <gnuvince> :t ap
07:07:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:07:17 <lilac> @hoogle Monad m => m Bool -> m ()
07:07:18 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
07:07:18 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
07:07:18 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
07:07:32 <dcoutts_> augustss: ah, you're stuck on 6.8 because of that
07:07:41 <augustss> dcoutts_: yes
07:07:52 <drigz> a combination of forever and unless i think would be good
07:08:15 <MacNala> In Chapter 3 of Real World Haskell it is not clear to me how to get the myInfo into the ghci system there appears to be two definitions for ch03/BookStore.hs can anyone help?
07:08:20 <lilac> drigz: while test cmd = let self = do b <- test; if b then cmd >> self else return ()
07:08:31 <lilac> @let while test cmd = let self = do b <- test; if b then cmd >> self else return ()
07:08:31 <lambdabot>   Parse error
07:08:39 <drigz> lilac: i thought i might have to write it; i just wanted to check
07:08:56 <lilac> @let while test cmd = let self = do { b <- test; if b then cmd >> self else return () } in self
07:08:57 <lambdabot>  <local>:7:0:
07:08:57 <lambdabot>      Warning: Pattern match(es) are overlapped
07:08:57 <lambdabot>               In...
07:09:27 <lilac> drigz: it's not a very useful function though, though. better would be something like:
07:09:51 <lilac> whileM :: Monad m => (a -> Bool) -> m a -> m [a]
07:09:56 <lilac> @hoogle Monad m => (a -> Bool) -> m a -> m [a]
07:09:56 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
07:09:57 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
07:09:57 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
07:10:13 <drigz> lilac: would that do what i want?
07:10:13 <gio123>  @seen ski_
07:10:23 <Axman6> filterM?
07:10:27 <drigz> then my condition would have to have type () -> Bool
07:10:31 <drigz> which isn't very exciting
07:10:33 <gio123> @seen ski_
07:10:33 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I don't know when ski_ last spoke.
07:10:52 <lilac> drigz: while test cmd = whileM id (cmd >> test)
07:11:03 <lilac> drigz: except that'd run cmd at least once
07:11:18 <lilac> drigz: whereas you can't implement whileM in terms of while
07:11:28 <lilac> therefore whileM is a more powerful recursion construct
07:11:40 <drigz> lilac: more powerful but can't do what i want?
07:11:52 <lilac> drigz: it /can/ do what you want
07:12:14 * lilac thought there was an untilM somewhere?
07:12:23 <lilac> @type until
07:12:24 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:12:40 <dcoutts_> augustss: I can't find the ticket for it, do you happen to know it or remember the search term?
07:13:13 <Axman6> @hoogle until
07:13:13 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
07:13:14 <PeakerWork> @src until
07:13:14 <lambdabot> until p f x | p x       = x
07:13:14 <lambdabot>             | otherwise = until p f (f x)
07:13:22 <lilac> drigz: to be honest, i suspect it's not in the std lib because people would normally just write it recursively
07:13:32 <PeakerWork> @type (takeUntil.) . iterate
07:13:33 <lambdabot> Not in scope: `takeUntil'
07:13:34 <drigz> lilac: but if they close the connection before they send a character i try and read from a closed file
07:13:37 <drigz> and crash
07:13:37 <PeakerWork> @type (takeWhile.) . iterate
07:13:38 <lambdabot>     Couldn't match expected type `a -> Bool'
07:13:38 <lambdabot>            against inferred type `[a1]'
07:13:38 <lambdabot>     Probable cause: `iterate' is applied to too many arguments
07:13:53 <augustss> dcoutts_: The DLL problem?  It's been resolved.  We're just waiting for a release.
07:14:10 <dcoutts_> augustss: oh ok. I misunderstood.
07:14:24 <MacNala> In Chapter 3 of Real World Haskell it is not clear to me how to get the myInfo into the ghci system there appears to be two definitions for ch03/BookStore.hs can anyone help?
07:14:45 <drigz> lilac: anyway, thanks!
07:14:54 <augustss> dcoutts_: We don't want to be stuck using a snapshot version either.  It's nicer to be on an official release.
07:15:22 <dcoutts_> augustss: yes of course. well there are 15 high priority tickets left for 6.10.2
07:15:32 <dcoutts_> http://hackage.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&milestone=6.10.2
07:16:46 <dever> hey, if i have a list of two lists of [String] and the second list contaings elements that are in the first, how do i get the elements in the second that aren't in the first
07:16:50 <dever> ?
07:18:12 <dever> filter ( notElem list1 ) list2 ??
07:18:20 <augustss> dever: use \\
07:18:24 <koeien> dever: (\\)
07:18:24 <Martijn> @hoogle \\
07:18:24 <lambdabot> Data.IntMap (\\) :: IntMap a -> IntMap b -> IntMap a
07:18:24 <lambdabot> Data.IntSet (\\) :: IntSet -> IntSet -> IntSet
07:18:24 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
07:18:35 <koeien> > [1,1,2] \\ [1,2]
07:18:37 <lambdabot>   [1]
07:19:04 <Beelsebob> that's not quite the function he asked for though
07:19:05 <koeien> if you want all 1's to be removed, \\ is not the function you want
07:19:05 <dever> [1,2,3] \\ [2,4]
07:19:15 <dever> > [1,2,3] \\ [2,4]
07:19:16 <lambdabot>   [1,3]
07:19:43 <Beelsebob> dever: your original code looks nice and simple to me
07:19:44 <augustss> dcoutts_: doesn't look like igloo is out of work yet...
07:20:28 <quicksilver> Axman6: I deny everything.
07:20:31 <quicksilver> Axman6: try mmorrow
07:20:36 <lilac> drigz: while test cmd = test >>= (\x -> if x then whileM id (cmd >> test) else return ())
07:20:40 <lilac> (for what it's worth)
07:20:48 <Axman6> heh, ok, cheers
07:20:54 <dcoutts_> augustss: nope, plenty of issues to fix. The judgement is when to cut it and punt the rest to 6.10.3.
07:21:27 <lilac> drigz: don't you have a race between your test and your read anyway?
07:21:27 <drigz> lilac: tbh i should probably catch the exception instead of just checking beforehand
07:21:30 <augustss> dcoutts_: Set a date.  That makes it easy.
07:21:46 <drigz> lilac: i'm just lazy
07:21:52 <drigz> the exception catching looked complicated
07:21:58 <dever>  > filter ( notElem [1,2,3,4] ) [1,2,5]
07:22:08 <lilac> drigz: also, if there's no way to do this without potentially generating an exception, that sounds like a pretty mediocre design choice in the lib :(
07:22:25 <dcoutts_> augustss: it's up to JaffaCake, I'll let him know
07:22:30 <dever> ahh
07:22:57 <lilac> drigz: whatever it is you're doing, i suspect it can be done at a higher level of abstraction, where you have simply a list instead of an explicit loop
07:23:10 <lilac> that's usually the way in haskell, especially if you're operating at an imperative level
07:23:54 <drigz> lilac: this is my first foray into imperative haskell
07:27:16 <dever> cheers folks!
07:27:32 <loadquo> > filter ( notElem [1,2,3,4] ) [1,2,5]
07:27:32 <lambdabot>       No instance for (Num [[t]])
07:27:32 <lambdabot>        arising from the literal `1' at <int...
07:27:48 <dever> got it sorted
07:27:55 <dever> should be
07:28:10 <dever> > filter ( `notElem` [1,2,3,4] ) [1,2,5]
07:28:11 <lambdabot>   [5]
07:29:51 <dv__> > filter (flip notElem [1,2,3,4]) [1,2,5]
07:29:53 <lambdabot>   [5]
07:30:44 <dever> what does flip do?
07:31:04 <Raevel> @type flip
07:31:05 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:31:19 <Raevel> @src flip
07:31:19 <lambdabot> flip f x y = f y x
07:32:16 <quicksilver> dever: turns a binary function into one with the parameters the other way around.
07:32:24 <quicksilver> > flip (-) 3 4
07:32:26 <lambdabot>   1
07:32:36 <doserj>  > let (<) = flip (>) in 1 < 2
07:32:41 <doserj> > let (<) = flip (>) in 1 < 2
07:32:42 <lambdabot>   True
07:32:44 <dever> ah ok cool! thanks!
07:37:33 <ozy`> is there -any- editor aside from Textmate that highlights regular code and type signatures differently?
07:37:39 <ozy`> does yi do that?
07:37:52 <lilac> > ((flip.flip) (const undefined) 42 `seq` True, const undefined 42 `seq` True)
07:37:54 <lambdabot>   (True,* Exception: Prelude.undefined
07:38:09 <lilac> flip.flip != id :: (a -> b -> c) -> _
07:41:16 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.2
07:41:45 <redditbot> HDBC now has a mysql backend!
07:41:45 <redditbot> darcs weekly news #14
07:45:34 <mreh> is anyone here in the domain of quantum computation?
07:47:22 <ozy`> maybe
07:47:29 <ozy`> collapse our waveforms and find out!
07:47:42 <mreh> damn! i was going to make that joke
07:48:28 <mreh> seriously though
07:49:57 <jessta> could anyone tell me what the >>= operator does?
07:50:08 <loadquo> @type >>=
07:50:09 <lambdabot> parse error on input `>>='
07:50:14 <loadquo> @type (>>=)
07:50:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:50:56 <koeien> jessta: it's kind of a long story
07:50:58 <doserj> jessta: it does more or less the same as what <- does in do-notation. For more explanation, you have to read one of the monad tutorials...
07:51:10 <koeien> see a "Monad" tutorial
07:51:16 <lilac> jessta: it takes a monadic container of type 'a', and a mapping from type 'a' to monadic containers of type 'b'. it applies the mapping, then collapses the structure to give a monadic container of type 'b'
07:51:32 <koeien> @where RWH
07:51:33 <lambdabot> is http://www.realworldhaskell.org/blog/
07:51:35 <insane> is it possible to use where expression inside a guard?
07:52:00 <quicksilver> where expressions scope over all guards.
07:52:26 <quicksilver> normally it's fine just to put it at the bottom of the definition.
07:52:36 <insane> yes that works
07:52:45 <lilac> jessta: you can decompose it as (a >>= f) = join (liftM f a), where 'liftM' does the mapping, and 'join' does the collapse-of-structure from m (m b) -> m b
07:53:01 <insane> but is there a way to put it in a way that the scope of where is only one guard?
07:53:34 <lilac> jessta: for instance, for lists, it applies a function to each element, producing a list of lists, then concatenates to form a list
07:54:05 * Saizan wonders why there's not Monoid a => Monoid (IO a) instance
07:54:12 <Saizan> s/not/no/
07:54:23 <lilac> jessta: and for IO (values-with-side-effects), it applies a function to the value computed by the IO action, producing an IO action which computes an IO action of type b
07:54:36 <lilac> jessta: and then it collapses that by sequencing the side-effects into an IO action of type b
07:54:38 <quicksilver> insane: sure, if you nest another definition inside the where clause
07:54:56 <quicksilver> insane: the thing about lets and wheres is to remember that let is for expressions and where is for definitions (including case)
07:54:58 <lilac> Saizan: i think conal has one somewhere
07:55:10 <lilac> it's used in Reactive IIRC
07:55:17 <quicksilver> > let y = x where x = let x | True == (let x = y where y = 1 in True) = 1 in 1 in 1
07:55:18 <lambdabot>   1
07:55:46 <quicksilver> a guard is a boolean expression - in particular, it's an expression.
07:56:17 <lilac> quicksilver: you tryin' to boost SamB's aspirin business?
07:56:22 <lilac> :)
07:57:20 <quicksilver> SamB_XP_ sells aspirin?
07:57:38 <quicksilver> anyhow, this particular questioner is already insane.
07:57:53 <lilac> quicksilver: 14:18 < SamB> augustss: hmm, maybe I should start selling aspirins to Haskell n00bs
07:57:59 <quicksilver> ah.
07:58:19 <quicksilver> let/where is weird.
07:58:27 <quicksilver> they're the same, in the sense that one is sugar for the other
07:58:41 <quicksilver> but they're different, in the sense that they apply to completely different parts of the grammar.
07:58:49 <quicksilver> I find this hard to explain clearly.
07:59:06 <lilac> it's awkward that you can't desugar 'where' into 'let' without desugaring function definitions too
07:59:20 <lilac> or at least guards
07:59:37 <lilac> and you can't desugar 'let' into 'where' without synthesizing variables :(
08:02:45 <Saizan> don't you hate when you've worked out a nice interface that works for 99% of your code and then you've this ugly corner case that doesn't really fit?
08:03:33 <ik> Yes.  Find the corner case and punch it.
08:03:35 <quicksilver> Saizan: Hit it repeatedly with a pointy stick.
08:03:47 <quicksilver> #haskell++ # count on us for the violent solution.
08:03:50 <ik> It's good to know we agree on the use of violence in this situation
08:04:02 <Axman6> @karma #haskell
08:04:02 <lambdabot> #haskell has a karma of 1
08:04:06 <Axman6> @karma haskell
08:04:06 <lambdabot> haskell has a karma of 47
08:04:22 <insane> quicksilver: thank you i think i get it now
08:04:39 <Axman6> it must be pure violence though, none of this mercy crap
08:05:10 <quicksilver> insane: \o/
08:05:58 <dcoutts_> Saizan: yes, it tells us our design is wrong, or perhaps that the problem is wrong :-)
08:06:26 <dcoutts_> Saizan: if the problem says "I need a way to do X", perhaps really they're just wrong.
08:08:02 <Saizan> contrsucting the arguments for haddock has something wrong somewhere :)
08:13:10 <drdozer> I just tried to run: Cabal-1.6.0.1$ ghc --make Setup.hs and got /usr/bin/ld: cannot find -lgmp
08:13:18 <drdozer> presumably there is some library or something that I've missed?
08:13:29 <quicksilver> your ghc is broken, I think.
08:13:32 <dcoutts_> drdozer: it means your ghc setup needs fixing
08:14:00 <drdozer> ouch
08:14:02 <dcoutts_> drdozer: presumably gmp is either not installed or installed somewhere non-standard
08:14:40 <dcoutts_> drdozer: in the former case, install it. In the latter case you can adjust ghc's standard linker paths.
08:15:02 <drdozer> dcoutts_: I have lots of files under: /home/nmrp3/tmp/ghc-6.10.1/gmp
08:15:20 <drdozer> and libraries/integer-gmp
08:15:31 <jeffersonheard> I see lambdabot's back up today
08:15:31 <lambdabot> jeffersonheard: You have 1 new message. '/msg lambdabot @messages' to read it.
08:15:36 <dcoutts_> drdozer: I presume you installed a ghc binary
08:15:46 <drdozer> dcoutts_: good guess
08:15:46 <dcoutts_> drdozer: then all you need to do is install your distros gmp package
08:16:08 <Le-Chuck_ITA> Hi there, I ask a question here which is off topic, I asked on #math, but it's about category theory and there I don't think I'll have any luck. So forgive me if I ask here.
08:16:08 <Le-Chuck_ITA> In a  category of monos with pullbacks, I have an isomorphism rho: m -> m, and an arrow f : n -> m . Then it is easy to prove that the pullback of f and rho is made up of an isomorphism rho' and an arrow f'
08:16:08 <Le-Chuck_ITA> How to prove that rho' is an iso over n??
08:16:11 <jeffersonheard> gwern, did you still have RENCI license questions or did I already take care o fthem
08:16:13 <jeffersonheard> ?
08:16:40 <dcoutts_> drdozer: if there's a gmp-dev package then install that too
08:16:55 <drdozer> dcoutts_ I seem to be given the option of libgmp2(-dev) and libgmp3(-dev)
08:17:03 <dcoutts_> drdozer: pick 3
08:17:06 <dino-> dcoutts_: I've been using cabal-install a great deal lately, particularly with big upgrades of systems to 6.10. c-i is fantastic. Thank you and all those who contrib!
08:17:17 <dcoutts_> dino-: :-)
08:19:57 <drdozer> thanks dcoutts_ - I will have to kick our admin - seems my sudo privilages don't extend as far as I thought
08:26:14 <vixey> I want to poll #haskell :)
08:26:29 * vixey is just reading these http://www.intuitionism.org/
08:26:40 <vixey> esp. question 6 is interesting
08:31:23 <jeffersonheard> new blog post on Control.Monad.IfElse control flow tools
08:34:17 <jeffersonheard> http://vis.renci.org/jeff
08:36:42 <drigz> i'm getting a conflict between System.IO.Error.catch and Control.Exception.catch
08:36:46 <drigz> can one be replaced by the other?
08:37:06 <vixey> jeffersonheard, oh gosh .. anaphoric-if, hehe
08:37:10 <leimy> sometimes you've got to import something "hiding" something else due to name clashes
08:37:15 <drdozer> it isn't my day
08:37:18 <drigz> leimy: but i'm using both currently
08:37:31 <leimy> well you can import the other as a different name
08:37:35 <leimy> via "qualified"
08:37:46 <leimy> but whether their interchangeable is in the docs most likely
08:37:51 <drigz> i want to know if i have to use IO.Error.catch for IOErrors and Control.Exception for exceptions
08:37:55 <drdozer> drigz: try something like: import qualified System.IO.Error as SIOE
08:38:27 <leimy> drigz: I don't know the answer, and it'll vary from GHC 6.8 to 6.10
08:38:29 <leimy> possibly
08:38:30 <jeffersonheard> vixey, not sure what that comment means
08:39:19 <drigz> leimy: i looked in the source - apparently i can just use the Control.Exception one
08:39:32 <drigz> this is the sorcue of hugs98-Nov2003, so hopefully it's still true :p
08:40:15 <drdozer> cabal hates me :(
08:40:41 <vixey> jeffersonheard: I just remember using/implementing anaphoric if, it's such a bizarre language construct
08:40:43 <leimy> drigz: well there you go! :-)
08:40:44 <vixey> in lisp
08:40:50 <drigz> leimy: apparently i can't :(
08:40:57 <drigz> i take the typechecker's word above some old source
08:41:02 <leimy> drigz: oh then the source lied?
08:41:34 <jeffersonheard> vixey, yes.  the thing is it's also so damn useful.  I was doing a whole bunch of Gtk event handling, and it  kept coming down to if x is in this range, take x, and....
08:41:56 <drigz> it seems they're kind of the same
08:41:57 <drdozer> ./Setup install made some files under ~/.cabal, but no ~/.cabal/bin
08:41:59 <drigz> catch will catch both
08:42:19 <drigz> but catch from IO.Error guarantees that it will be an IOError, allowing you to call isEOFError on it
08:42:32 <dcoutts_> drdozer: what package were you installing ?
08:42:57 <drdozer> hang on - I think I'm being monumentally stupid
08:43:19 <drdozer> I think I installed cabal, not cabal-install
08:46:44 <drigz> what's the right way to handle the death of a thread?
08:46:55 <drigz> identify the exception that killed it and raise it if it's unexpected?
08:47:17 <drigz> i have no idea how i can identify exceptions (short of calling show on it and parsing the result...
08:47:20 <drigz> )
08:48:18 <quicksilver> the right way is to catch only those types you know how to handle.
08:48:25 <quicksilver> and ignore or re-throw anything else.
08:50:29 <Saizan> in base-3 you can pattern match on the constructors, in base-4 they are also differentiated by type
08:50:35 <drdozer> mm - installing ghc 6.10 from the binary didn't install c2hs as well
08:52:19 <quicksilver> Saizan: in base-3 the preferred way was to catch with a predicate though
08:52:26 <quicksilver> (which only matched the one you wanted)
08:55:28 <drigz> how do i find out which version of base- i have?
08:55:38 <drigz> i've been looking at the docs for base-4 which has confused me
08:55:50 <drigz> well, scratch my first question - i have base-3
08:55:57 <drigz> out of curiosity, how would i do it in base-4?
08:56:22 <drigz> ok, scratch that too - i think i'd just have to write my own version of ioExceptions etc.
08:57:45 <quicksilver> drigz: the docs for base-4 aren't much help
08:57:50 <quicksilver> they're still the -3 versions of the docs
08:57:56 <drigz> ok
08:58:02 <quicksilver> the only reliable guide is the actual signatures.
08:58:04 <drigz> i've also been going by RWH which uses base-3
08:58:13 <drigz> when is base-4 going to be used?
08:58:31 <drigz> wait, if i install 6.10 will it give me base-4?
08:58:51 <bos> yes
08:58:56 <bos> it'll give you both
08:59:33 <drigz> should i just use Control.OldException if i prefer it? why is it being changed?
09:01:07 <dublpaws> can this happen: (f x1 .. xn); like pythons f(*args); where x1..xn would be tuplated or listified?
09:02:08 <quicksilver> dublpaws: no.
09:02:16 <dublpaws> thanks
09:02:24 <quicksilver> dublpaws: haskell functions have to have a particular type.
09:02:37 <quicksilver> a function can take 5 arguments, or a list of arguments, or a tree of arguments, etc.
09:02:45 <quicksilver> but whatever it is, is known to the type system.
09:03:15 <dublpaws> yeah I figured that, but wanted to be sure, thanks for the clarity.
09:03:43 <Martijn> Is it possible to implement cataE? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1041
09:04:38 <Martijn> I've been trying and thinking for two hours now but I can't figure it out.
09:05:14 <dublpaws> something like -- f :: *[a] -> a, I guess.
09:06:06 <quicksilver> Martijn: same problem as last time.
09:06:19 <quicksilver> you don't want a parameter of the form "f a -> Either e a"
09:06:25 <quicksilver> you want it to be "forall a . f a -> Either e a"
09:06:43 <quicksilver> because you need to apply it to f (FixF f)
09:07:06 <Martijn> *scratches head*
09:07:28 <Saizan> uhm no
09:07:35 <rwbarton> quicksilver: hmm?  foldr doesn't take a polymorphic argument
09:08:24 <vixey> what does AlgebraE mean?
09:08:27 <vixey> Hi roconnor
09:08:31 <augustss> Martijn: what's a sample f that you have in mind?
09:08:36 <rwbarton> it also doesn't have the type of cataE though
09:08:38 <Saizan> you're going to apply it to "f (Either e a)"
09:08:57 <Martijn> evalE :: AlgebraE ExprF String Int
09:08:57 <Martijn> evalE expr = case expr of
09:08:57 <Martijn>   Add x y -> check (x + y)
09:08:57 <Martijn>   Sub x y -> check (x - y)
09:08:57 <Martijn>   Mul x y -> check (x * y)
09:08:58 <Martijn>   Num n   -> check n
09:09:01 <roconnor> hi vixey
09:09:03 <Martijn> with
09:09:03 <Martijn> check :: Int -> Either String Int
09:09:26 <vixey> logician roconnor, I came across your answers on intuitionism! this is interesting
09:09:44 <vixey> I mean www.intuitionism.org
09:09:49 <roconnor> vixey: my answers are subject to change
09:10:11 <roconnor> along with my characterization of myself
09:10:12 <augustss> Martijn: so ExprF e = Add e e | Sub e e | ... ?
09:10:19 <dever> where can i find the source files for haskell libraries?
09:10:37 <roconnor> sounds like someone is reading data types a la carte
09:10:42 <vixey> Martijn: Why are you doing it this way?
09:10:50 <Martijn> augustss: yes. sorry, you asked for an f, not an algebra.
09:11:10 <vixey> and what is 'E'?
09:11:22 <Martijn> Error
09:11:26 <Martijn> as in, Either e a
09:11:35 <Axman6> > [x | x <- Just 2]
09:11:36 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Maybe t1'
09:11:37 <vixey> why don't you use monads like everyone else :p
09:11:47 <vixey> I don't understand your approach
09:12:11 <rwbarton> Martijn: this cataE reminds me of a "costrength" which can be implemented only with callCC
09:12:44 <rwbarton> Martijn: for example, say there are errors in the left and right branches, which do you return?
09:12:47 <Martijn> My approach is this: I want to specify an algebra (such as eval above) which allows the possibility of failure at every level.
09:12:54 <rwbarton> Martijn: for a general functor you have no notion of "left" or "right"
09:13:18 <Martijn> Leftmost, like a monad. So should I require Monad f? Would that help?
09:13:43 <Saizan> Martijn: i think you also want to take a parameter like (f (Either e a) -> Either e (f a))
09:13:46 <rwbarton> f isn't a monad though.  Traversable f perhaps
09:13:55 <rwbarton> right, what Saizan wrote is a special case of Traversable
09:14:11 <rwbarton> and for your f, you do have a natural Traversable instance
09:14:17 <vixey> Martijn, I am curious why you use 'Algebra' instead of monadic though?
09:14:28 <Martijn> vixey: I'm not sure what you mean
09:14:39 <int-e> Martijn: you need a function  f (Either e a) -> Either e (f a)  ... looks like traversable?
09:14:52 <vixey> roconnor, Henks answer to (6) is great too
09:15:09 <vixey> ( http://www.intuitionism.org/people/henbar.html )
09:15:13 <fasta> vixey: probably because it is for his thesis/ some course.
09:15:15 <Martijn> Traversable... I'll take a look at that
09:15:38 <vixey> Martijn, My approach to this would be to write eval using the error monad
09:15:52 <vixey> Martijn, but you have chose to use AlgebraE... so I am just wondering what motivates the choice
09:16:02 <Saizan> vixey: have you read Data Types a La Carte?
09:16:07 <vixey> Saizan, yeah
09:16:15 <Saizan> it gives a nice introduction to this sort of things
09:16:21 <int-e> (for the record, cata :: Functor f => (f a -> a) -> FixF f -> a  can be implemented as  cata f = f . fmap (cata f) . outF)
09:16:40 <Martijn> I haven't read that paper yet -- I will
09:16:48 <vixey> Martijn, well ... ?
09:16:53 <vixey> you don't have to tell me if you don't want to :p
09:17:11 <Martijn> vixey: It's a good question, I'm not sure
09:17:18 <vixey> :S
09:17:25 <Martijn> vixey: Probably because I chose algebras for a previous problem and they worked out nicely there
09:17:30 <vixey> oh cool
09:17:48 <vixey> Will you paste it though?  I am curious how it can turn out
09:17:55 <vixey> (the prev. thing which did work)
09:20:04 <hellige> Martijn: your AlgebraE is just a Dialgebra f (Error e)
09:20:04 <hellige> isn't it?
09:20:04 <hellige> or rather Either e, sorry...
09:20:04 <Martijn> Previously I had an ExprAlgE and a fold that worked through an Expr (not a fix point that time), and it returned either a result :: a or an error coupled with the path in the expression at which the error occurred.
09:20:39 <roconnor> vixey: heh, I read Henk's answers with his voice in my head
09:20:48 <jeffersonheard> BMeph, why do you thin I don't understand what flip does?
09:20:48 <Martijn> I don't know, maybe I'm taking an approach that is way too complicated
09:21:09 <vixey> roconnor, ooo you have heard Henk irl cool!
09:21:18 <jeffersonheard> > :t flip
09:21:19 <lambdabot>   <no location info>: parse error on input `:'
09:21:24 <jeffersonheard> @type flip
09:21:25 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:21:33 <jeffersonheard> @type (filp when)
09:21:34 <lambdabot> Not in scope: `filp'
09:21:41 <jeffersonheard> @type (flip when)
09:21:42 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> Bool -> m ()
09:22:29 <rwbarton> roconnor: I like your answer to #8 :)
09:22:47 <jeffersonheard> oh...  that'd be it.  You're right.  I was thinking backwards.  Control.Monad.IfElse.(>>?) is just a synonym for when
09:22:53 <roconnor> vixey: I did work for his group for 4 years :)
09:23:01 <jeffersonheard> @type when
09:23:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:23:34 <loadquo> @check ((a*b)*c == a*(b*c))
09:23:35 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:23:40 <drigz> RWH's concurrency chapter walks through writing a module for a thread manager
09:23:48 <loadquo> How does it know which type to use?
09:23:49 * quicksilver is quite surprised by all the people answering 'Yes' to 1. Including roconnor.
09:24:22 <drigz> it allows you to wait for a thread to end and returns the reason it ended. however, this reason seems to be opaque
09:24:25 <roconnor> quicksilver: it is all a matter of how you choose to interpret the words in the questions
09:24:28 <osfameron> quiz?
09:24:32 <quicksilver> @check (\a b c -> (a*b)*c == a*(b*c))
09:24:33 <lambdabot>   "OK, passed 500 tests."
09:24:41 <quicksilver> loadquo: I think that's what you meant ;)
09:24:52 <drigz> long story short, from this code: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html#x_u31 how do i export the ThreadStatus info?
09:25:02 <quicksilver> and the answer is, it defaults to Integer because it's a Num instance.
09:25:10 <loadquo> Ah, quite possibly. What I really wanted was to do it on Ints though.
09:25:25 <drigz> if i put Running in the exports list it says it's not in scope, but i can't use it elsewhere without...
09:25:26 <quicksilver> @check (\a b c -> (a*b)*c :: Int == a*(b*c))
09:25:26 <lambdabot>   Parse error at "==" (column 27)
09:25:35 <quicksilver> @check (\a b c -> (a*b)*(c :: Int) == a*(b*c))
09:25:36 <lambdabot>   "OK, passed 500 tests."
09:25:59 <rwbarton> loadquo: It's true on Ints too, everything is mod 2^32.
09:26:06 <quicksilver> roconnor: that tends to be a key factor when answering *any* question :)
09:26:25 <rwbarton> loadquo: (well, that's not stated in the Haskell report of course)
09:26:26 <Zao> rwbarton: Doesn't the report only guarantee 2^30 distinct Int values?
09:26:43 <quicksilver> loadquo: you can try them all if you like; there are only 2^96 possibilities.
09:27:42 * loadquo has a hard time visualising that
09:27:54 <quicksilver> it's a neat fact about number theory
09:28:08 <quicksilver> that operations 'modulo' a fixed modulus are still associative.
09:28:28 <quicksilver> (and various other properties)
09:28:28 <loadquo> So Ints are abelian, right?
09:28:36 <Martijn> afk, dinner
09:28:42 <quicksilver> although that's true, that's not the point here.
09:28:47 <quicksilver> abelian is (a+b) == (b+a)
09:28:56 <quicksilver> (or (a*b) == (b*a))
09:29:01 <Saizan> drigz: you've to put ThreadStatus(Running) in the export list
09:29:02 <quicksilver> depending which group you were thinking of.
09:29:07 <tromp__> what is purple and commutes?
09:29:15 <Saizan> drigz: or ThreadStatus(..) for all of them
09:29:41 <drigz> Saizan: ah, thank you!
09:29:56 <tromp__> an abelian grape
09:30:01 <quicksilver> tromp__: *rimshot*
09:34:18 <loadquo> quicksilver: Hmm, your right there was some other property that I was interested in... can't remember what it was.
09:35:13 <dever> anyone know where can i find the source files for haskell libraries?
09:35:38 <quicksilver> dever: yes. You can browse them all online.
09:35:41 <Saizan> http://darcs.haskell.org/libraries/
09:35:47 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
09:36:12 <lilac> quicksilver: fwiw, i'd say: +----##-+-
09:37:01 <quicksilver> hmm. you say yes to 1 as well?
09:37:07 <quicksilver> damn constructivists!
09:37:23 <quicksilver> damn you all to an indeterminate hell! ;)
09:37:35 <drigz> i only just learnt about constructivism, and i find it really confusing
09:37:57 <lilac> quicksilver: 'total function' as far as i'm concerned implies computable function
09:38:02 <vixey> drigz, how did you learn?
09:38:04 <lilac> otherwise the question would have just said function
09:38:06 <dever> cheers, seeing the source confused me even more :D
09:38:06 <vixey> drigz, and what ?
09:38:19 <quicksilver> lilac: a total function is one defined on every value.
09:38:27 <lilac> quicksilver: a function is one defined on every value
09:38:36 <lilac> (i'm a mathematician first and foremost)
09:38:55 * vixey defines function as a restriction of 'relation'
09:38:56 <drigz> vixey: i've been reading a biography of wittgenstein, in which russell figures heavily
09:39:11 <quicksilver> lilac: OK, then it's just a stupid argument about what total means.
09:39:18 <drigz> and i was reading about formalism on wikipedia, and then read about other mathematical philosophies
09:39:18 <quicksilver> http://en.wikipedia.org/wiki/Total_function
09:39:32 <drigz> and i don't understand on what grounds the principle of the excluded middle is rejected
09:39:34 <quicksilver> illustrates my definition not that I claim WP to be a good resource for definitional questions.
09:39:35 <vixey> m I don't know about wittgenstein
09:39:45 <lilac> quicksilver: sure. if we're talking about mathematical functions (as relations or whatever) then i'd say no to q1
09:39:45 <quicksilver> If every element of the domain of a binary relation f is associated to exactly one element of its codomain, then f is termed a total function, or simply a "function".
09:39:49 <ddarius> quicksilver: The set of natural numbers is a sham.
09:40:01 <quicksilver> lilac: *nod*
09:40:07 <drigz> vixey: his philosophy of mathematics was pretty much "guys! it doesn't matter!" except with much more genius (afaict)
09:40:08 <glguy> ?seen mm_freak
09:40:08 <lambdabot> mm_freak is in #haskell. I don't know when mm_freak last spoke.
09:40:09 <glguy> err
09:40:17 <lilac> quicksilver: but to be honest the whole thing is a land of mu since the answers all depend on your axioms
09:40:20 <pumpkin> the numbers are unnatural!
09:40:35 <vixey> ddarius, I just read about 'ultrafinitism' :p
09:40:49 <quicksilver> for some reason that other interpreation of the word 'total' didn't occur to me.
09:40:52 * quicksilver shrugs.
09:41:03 <quicksilver> definitional arguments are very dull. I'm glad that's all it is.
09:41:47 <redditbot> Control.Monad.IfElse - anaphoric and miscellaneous control flow utils.
09:42:39 <Saizan> quicksilver: well, it boils down to "do you accept non-computable functions as functions?"
09:43:00 <jeltsch> Hello, is it normal that GHC shows an error message for line 1, column 0 when compiling a source file?
09:43:20 <ddarius> Saizan: It depends on how you define "function"
09:43:23 <quicksilver> Saizan: not really something I associate with intuitionism.
09:43:30 <quicksilver> (that particular dichotomy)
09:43:36 <ddarius> jeltsch: If there is an error there, yes.
09:43:51 <quicksilver> the intuitionists I knew/know are perfectly happy to define a function as a set of pairs.
09:43:55 <augustss> Saizan: there are no non-computable functions ;)
09:43:57 <byorgey> jeltsch: what is the error?
09:43:58 <largos> does anyone know what bookseller offers the RWS authors the best deal on their sales? (I need to buy a copy)
09:44:08 <jeltsch> src/Examples/Grapefruit/Switching.hs:1:0:
09:44:08 <jeltsch>     Couldn't match expected type `SignalFun'
09:44:08 <jeltsch>            against inferred type `SSignal'
09:44:10 <largos> erf. RWS = RWH :)
09:44:17 <quicksilver> largos: I asked that. dons didn't seem to mind much.
09:44:19 <Saizan> so, how do we define augustss?:)
09:44:22 <vixey> quicksilver, hey why do you think we write the function space as PI :p
09:44:25 <jeltsch> Strange also that GHC doesnâ€™t show what the expected and inferred type is.
09:44:40 <quicksilver> largos: I used amazon.
09:44:41 <vixey> it's just a product of pairs
09:44:42 <augustss> Saizan: I'm a bot.
09:44:43 <largos> quicksilver: ah, thanks.  it looks like there are amazon referrer links on their blog -- I'll use that
09:45:02 <quicksilver> augustss is a non-computable bot.
09:45:06 <quicksilver> with a pirate module.
09:45:08 <quicksilver> @yar
09:45:08 <lambdabot> Smartly me lass
09:45:20 <jeltsch> I think there is no column 0, is it?
09:45:39 <byorgey> jeltsch: it usually numbers the columns starting from 0, I think
09:45:48 <augustss> @quote
09:45:48 <lambdabot> reddi says: and now i know: IT DOES NOT WORK ALWAYS ;-)
09:45:53 <byorgey> jeltsch: that does seem like a strange error though.
09:46:15 <quicksilver> @quote pirate
09:46:15 <lambdabot> mrd says: pirate logic is linearrr
09:46:17 <jeltsch> byorgey: There is probably no type error at the start of the module.
09:46:21 <quicksilver> mrd++
09:46:27 <byorgey> jeltsch: indeed.  what version of GHC?
09:46:36 <jeltsch> byorgey: 6.10.1
09:46:42 <augustss> @quote linear
09:46:42 <lambdabot> mrd says: pirate logic is linearrr
09:46:50 <augustss> @quote logic
09:46:50 <lambdabot> stepcut says: how can you possibly implement business logic without knowing about Schonfinkel!?
09:47:05 <stepcut> :)
09:47:28 <byorgey> jeltsch: well, report it as a bug: http://hackage.haskell.org/trac/ghc/wiki/ReportABug
09:47:32 <augustss> Good quote.  Not that it makes any sense. :)
09:47:53 <quicksilver> I never know what to do with left-over turkey after christmas. These days I generally schonfinkel it.
09:48:16 <stepcut> quicksilver: haha
09:49:10 <augustss> @quote business
09:49:11 <lambdabot> stepcut says: how can you possibly implement business logic without knowing about Schonfinkel!?
09:49:11 <lilac> quicksilver: do you have 0/0 bread with that?
09:49:26 <augustss> @quote implement
09:49:26 <lambdabot> emu says: people have gotten so used to the sloppy languages like python and perl which are specified by 1 implementation that they forget there is a difference
09:49:29 <quicksilver> lilac: peshwari.
09:49:29 <jeltsch> byorgey: :-O
09:49:32 <byorgey> all this talk of schonfinkel and 0/0 is making me hungry
09:49:38 <lilac> quicksilver: yummy :)
09:49:54 <pumpkin> @quote wango
09:49:55 <lambdabot> wango says: do you like turing complete?
09:50:07 <ddarius> @quote pumpkin
09:50:07 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
09:50:14 <vixey> @yeal
09:50:14 <lambdabot> nsa try kill me numerous times
09:50:16 <vixey> @yeal
09:50:16 <lambdabot> perhaps i just genius and never tested
09:50:17 <pumpkin> :)
09:50:17 <jeltsch> byorgey: I need this code work *now*. =-O
09:50:20 <augustss> pumpkin: you must be the only one
09:50:38 <pumpkin> augustss: I was being sarcastic at the time I think, or responding jokingly to a comment that records were ugly
09:50:41 <byorgey> mm, then maybe later we can have some pumpkin 4*atan(1)
09:50:45 <augustss> @yeal
09:50:45 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
09:50:49 <roconnor> inuitionists are not quite the same as constructivists
09:51:09 <byorgey> jeltsch: um...
09:51:10 <vixey> what are the biggest differences?
09:51:11 <roconnor> they have the same logic, but different mathematics
09:51:23 <ddarius> My understanding is intuitionism âŠ† constructivism
09:51:24 <quicksilver> roconnor: yes, that's what I thought. Which is why I was suprised at the answers to Q1
09:51:28 <jeltsch> byorgey: Seems that GHC 6.10.1 is not as stable as the former versions.
09:51:41 <roconnor> intuitionist assume that all functions are continuous
09:51:45 <jeltsch> byorgey: Or Iâ€™m doing more sophisticated things these days.
09:51:48 <byorgey> jeltsch: I don't know, I haven't used it much yet.
09:51:55 <vixey> haskellers know all functions are contiunous
09:52:17 <quicksilver> sure, but in a different topology
09:52:24 <quicksilver> it just depends how you encode things.
09:52:24 <roconnor> constructivists assumptions are compatible with classical mathematics so they don't assume such things
09:52:25 <drigz> roconnor: i've probably misunderstood you, but does that mean no step functions?
09:52:38 <jeltsch> byorgey: At least, it is the second strange 6.10.1 Iâ€™m discovering. The first was that the compiler loops if you turn on optimization with certain programs using explicit foralls.
09:52:53 <quicksilver> the function { f(x) = 0 | x<0; f(x) = 1 | otherwise } is perfectly haskell-definable
09:52:57 <vixey> I read the topology (X,P(X)) any function from there is continuous,  and any function /to/ (X,{{},X}) is continuous
09:52:59 <jeltsch> byorgey: 6.10.1 *bug*, I mean.
09:53:01 * rwbarton also thought intuitionism âŠ† constructivism, and intuitionism âŠ† classicism, but constructivism and classicism are incomparable
09:53:11 <quicksilver> and perfectly continuous in the CPO sense
09:53:14 <roconnor> drigz: not for your run-of-the-mill type of functions
09:53:20 <quicksilver> but the function on the reals which it is intended to model is not continuous.
09:53:46 <lilac> quicksilver: sure, but that's not a total function from the reals :)
09:53:58 <roconnor> rwbarton: constructivism is less than both intuitionism, classicism (and russian intuitionism)
09:54:02 <augustss> quicksilver: nor total
09:54:12 <roconnor> rwbarton: the others are incomparable (and incompatable)
09:54:41 <vixey> see after reading Heytings book, I thought intuitionism was /more/ specific than constructivism
09:54:50 <quicksilver> augustss: it's total in the sense I expected total to be taken.
09:54:56 <vixey> oh wait that's what you said
09:55:02 <quicksilver> augustss: it's defined for every real
09:55:07 <rwbarton> roconnor: It sounds like I have intuitionism and constructivism backwards
09:55:22 <roconnor> > let f x = if x < 0 then 0 else 1 in f (0::CReal)
09:55:24 <lambdabot>   1
09:55:24 <vixey> rwbarton, I'm muddled too...
09:55:41 <roconnor> god damn crap implemenation of CReal
09:55:41 <quicksilver> I had thought of intuionism as being a proof-theoretic thing and constructivism as a philosophical stance.
09:55:51 <vixey> A classical proof can be constructive or not,
09:55:56 <mattam> Would you agrees intuitionistic logic is the first constructive logic?
09:56:01 <vixey> but every intuitionist proof is constructive
09:56:03 <vixey> (is that true ?)
09:56:04 <ddarius> vixey: Indeed, if U : Top -> Set, then I -| U -| D should hold.
09:56:19 <quicksilver> but I'm pretty sure these words have been so sloppily used that you can't usefully argue about borderline cases.
09:56:20 <augustss> > let f x = if x < 0 then 0 else 1 in f (sin pi::CReal)
09:56:21 <ddarius> quicksilver: There is philosophy associated with intuitionism as well.
09:56:21 <lambdabot>   1
09:56:26 <vixey> ddarius, I don't know anything about adjunctions though :(
09:56:37 <vixey> I'm guessing  -|  means an adjunction
09:56:39 <quicksilver> vixey: no you can have a proof in intuitionistic logic of an existential statement, which fails to construct a witness.
09:56:41 <roconnor> rwbarton: actually I prefer to view constructive mathematics as an extension of classical mathematics rather than a restriction
09:56:42 <quicksilver> I think.
09:56:42 <ddarius> vixey: Yes.
09:57:05 <rwbarton> roconnor: in that case, all the classical theorems I know should still be true, right?
09:57:22 <rwbarton> roconnor: That's the sense in which I was using âŠ†
09:57:32 <vixey> quicksilver: In Heyting - Intuitionism, he kept stressing that you couldn't claim exstience of something without giving it.. like I think he used this example about the digits of pi which had actually been proved by the time I read this book
09:57:41 <augustss> why worry about all this infinite nonsense when we only have finite state machines anyway?
09:58:02 <ddarius> augustss: Indeed.  Finitism is the way to go.
09:58:10 <vixey> http://en.wikipedia.org/wiki/Ultrafinitism
09:58:14 <loadquo> augustss: Elegance?
09:58:15 <roconnor> rwbarton: well, I don't like to use the words true/false when talking about constructive mathematics.  All classical theorems (not using AC) are provable in constructive mathematics if you use the classical connectives.
09:58:16 <ddarius> The universe is effectively finite too.
09:58:22 <lilac> augustss: you believe the energy in the universe is bounded?
09:58:24 <mattam> augustss: because it's more abstract?
09:58:25 <vixey> I'm working on 2'ism.. we only deal with {True, False} :p
09:58:41 <roconnor> rwbarton: more or less
09:58:41 <lilac> augustss: and furthermore that space is quantized?
09:58:42 <augustss> lilac: I believe the energy is 0
09:59:33 <ddarius> @google "discrete analysis"
09:59:37 <lambdabot> http://www.springerlink.com/index/LN404KG52GV3863X.pdf
09:59:37 <lambdabot> Title: SpringerLink Home - Main
09:59:51 <vixey> http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimPDF/real.pdf
10:00:00 <roconnor> I have a proof that Ultrafinitism is inconsistent, but there the universe is too narrow to contain it.
10:00:07 <vixey> lol
10:00:13 <vixey> @remember <roconnor> I have a proof that Ultrafinitism is inconsistent, but there the universe is too narrow to contain it.
10:00:13 <lambdabot> I will never forget.
10:00:20 <dmead> anyone know when this year's ICFP is going to be?
10:00:28 <ddarius> http://www.math.rutgers.edu/~zeilberg/mamarim/mamarimhtml/real.html  Good ole Zeilberg
10:00:54 <roconnor> @forget <roconnor> I have a proof that Ultrafinitism is inconsistent, but there the universe is too narrow to contain it.
10:00:54 <lambdabot> Done.
10:00:55 <ozy`> is "deriving" a reserved word outside of type declarations?
10:01:01 <roconnor> @remember <roconnor> I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
10:01:01 <lambdabot> Good to know.
10:01:09 * roconnor revises history
10:01:30 <ddarius> > let deriving x = x in deriving 3
10:01:31 <lambdabot>   <no location info>: parse error on input `deriving'
10:01:38 <ozy`> guess so >_>
10:01:43 <byorgey> dmead: around the beginning of September IIRC
10:01:44 <ozy`> > let as = 5
10:01:45 <lambdabot>   <no location info>: parse error on input `;'
10:01:48 <byorgey> I don't know the exact dates
10:01:50 <dmead> excellent
10:01:50 <ozy`> > let as = 5 in as
10:01:52 <lambdabot>   5
10:02:00 <byorgey> dmead: it's earlier this year than it has been in the past
10:02:01 <ozy`> > let qualified = 5 in qualified
10:02:02 <lambdabot>   5
10:02:04 <dmead> i will assemble a crack team of hackers, to change the website results after the contest
10:02:08 <dmead> xD
10:02:09 <mm_freak> glguy: can i help you?
10:02:22 <glguy> mm_freak, tab-completion failure
10:02:22 <glguy> sorry
10:02:27 <mm_freak> ah, ok =)
10:04:22 <roconnor> one day I'd like to understand ultrafinitism.  I guess you could use it to make a typed programming language that doesn't run out of heap.
10:04:45 <vixey> I think ultrafinitism is a joke
10:04:59 <roconnor> oh?
10:05:06 <augustss> seems reasonable to me
10:05:33 <roconnor> augustss: have you actually seen a formal system for it?
10:05:45 <vixey> I mean it's ok to appreciate finitist arguments but as an entire foundation .. that just doesn't work
10:05:52 <augustss> roconnor: no, but I bet it has a finite number of axioms
10:05:57 <roconnor> :)
10:07:09 <augustss> It must be tricky when you don't really know what your upper size bound is.
10:07:29 <augustss> I mean 100 is an OK number, but not 10^10^10^10
10:07:38 <roconnor> augustss: I figure they use some sort of formal constant for the upper bound, and make proofs parametric in it
10:07:49 <rwbarton> ultrafinitists are breaking grothendieck's principle that it's better to have a nice category containing bad objects than a bad category containing only nice objects.
10:07:55 <roconnor> augustss: thus it will work on both 32-bit and 64-bit architectures
10:07:56 <augustss> Or they have a guro that tell them the current upper bound
10:07:57 <vixey> I don't believe that ultafinitists exist
10:08:02 <augustss> guru
10:08:04 <rwbarton> of course, ultrafinitists probably don't know who grothendieck is
10:08:30 <augustss> rwbarton: I don't know how to pronounce it
10:09:27 <augustss> vixey: at least you know there's only finite many of them.
10:09:27 <rwbarton> augustss: For all I know, everyone I know pronounces it wrong :)
10:09:34 <vixey> Lol
10:10:39 <augustss> I think the biggest number must be the number of fingers currently in existance
10:11:01 <lilac> augustss: two to the power of the number of fingers?
10:11:07 <lilac> minus one?
10:11:10 <ozy`> http://www.rsmw.net/ergo/textmate_haskell2.png <== any masochists using textmate? I seem to be making progress
10:11:17 <lament> is anyone actually an ultrafinitism?
10:11:20 <augustss> lilac: now it's getting iffy
10:11:23 <lament> apart from nuts i mean
10:11:43 <lament> *ultrafinitist
10:11:55 <vixey> that was silly
10:12:04 <vixey> I was trying to understand the source code in that paste
10:12:12 <vixey> I didn't realize it was only for demonstration :/
10:12:29 <pejo> ozy, I have colleagues using it.
10:12:33 <ozy`> vixey: it had to be nonsense, for half of what I was trying to test
10:12:43 <rwbarton> vixey: I didn't know you could put LANGUAGE pragmas there :P
10:12:45 <roconnor> ozy`: are you making a syntax highlighter?
10:12:52 <ozy`> roconnor: fixing one, rather
10:13:10 <ozy`> pejo: cool, send 'em over to #textmate. I need more test people
10:13:21 <ozy`> Axman6 seems to have passed out and/or died
10:14:16 <ozy`> roconnor: Textmate has had a haskell bundle for a couple years now, but it's in really sorry condition
10:14:35 <osfameron> any lambdacamels got any suggestions on how to do this in haskell? http://rafb.net/p/YlRPhM82.html
10:14:49 <osfameron> clearly the destructive fold is never going to work :-)
10:14:51 <ozy`> I think the indentation is still hopeless without some seriously dangerous hackery, but I can at least fix the highlighting
10:14:59 <roconnor> ozy`: nice that you are fixing it.  Although I use kate myself.
10:15:16 <osfameron> (Possibly a fold with a zipper down each level of Data.Map?)
10:15:21 <roconnor> and kubuntu
10:15:30 <osfameron> But I'm sure there's an idiomatic solution to this
10:16:11 <ozy`> roconnor: yeah, it's kind of a niche use case
10:16:49 <ozy`> roconnor: however, I was turned off of haskell for a couple of months myself, because TM didn't support it well enough and I wasn't yet very familiar with vim
10:17:06 <ozy`> so in case people are in the same boat somewhere, I wanna help them out
10:17:11 <roconnor> :)
10:17:16 <roconnor> ozy`++
10:17:25 <lilac> osfameron: what's that supposed to do? looks like line noise to me.
10:18:12 <roconnor> is hpaste gone for good?
10:18:13 <osfameron> lilac: that's why I asked for camelfolk specifically... ;-) look at the input list and the nested hash at the end, is that clearer than the Perl code?
10:18:33 <osfameron> it's supposed to dive down the paths supplied, creating a node at each level
10:18:49 <rwbarton> @type Data.Map.insert
10:18:50 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
10:19:15 <osfameron> (the technique is actually perverted FP, but really not pure)
10:19:42 <rwbarton> @type Data.Map.alter
10:19:43 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
10:20:16 <rwbarton> osfameron: I think it's a straightforward recursive definition using alter to add a single element "deeply" into a recursive Map
10:20:36 <rwbarton> osfameron: but it needs a newtype at least to write it down because of the recursive type
10:21:46 <osfameron> rwbarton: yeah - it might be simpler than I'm imagining it.  I'll give it a try with a simple recursive definition in a bit
10:22:06 <osfameron> why a newtype?
10:22:48 <rwbarton> osfameron: you want something like  newtype X = X (Map String X)
10:23:28 <osfameron> ah ok
10:24:43 <dever> hey can someone have a look at this, and maybe give me hint as to where im going wrong? http://pastebin.com/m3dcfeb79
10:24:53 <osfameron> rwbarton: thanks :-)
10:25:11 <rwbarton> osfameron: and if you want it to be as cryptic as the perl, you can probably write that recursion as a fold :)
10:25:44 <Saizan> dever: what's the problem?
10:25:46 <dever> it's line 3 that is giving me errors
10:25:47 <osfameron> rwbarton: I'm not sure about that though... the fold would end up with the leaf map woudln't it?
10:25:56 <osfameron> (because of not being destructive like the Perl version)
10:26:22 <Saizan> ?hoogle splitFileName
10:26:23 <lambdabot> System.FilePath.Posix splitFileName :: FilePath -> (String, String)
10:26:23 <lambdabot> System.FilePath.Windows splitFileName :: FilePath -> (String, String)
10:26:46 <Saizan> dever: splitFileName is a pure function, you use <- only for actions (in this case IO actions)
10:27:20 <Saizan> dever: but you can use let (oldDir,oldName) = splitFileName file
10:28:16 <dever> ah, ok cool!
10:34:03 <BMeph> osfameron: codepad says that line 9 (for @_) is an unblessed reference. Do you know what that means? :)
10:34:43 <osfameron> BMeph: that codepad's syntax highlighting is broken? ;-P
10:34:56 <ozy`> BMeph: are you asking that as someone unfamiliar with perl?
10:34:58 <osfameron> BMeph: that should just be iterating over the function's parameters
10:36:04 <dmead> is the icfp contest always grpahics related?
10:39:37 <rwbarton> dmead: No
10:39:48 <dmead> but the past 3 have been, yes?
10:40:07 <rwbarton> The 2006 wasn't, was it?
10:40:14 <dmead> i think
10:40:18 <dmead> so was 07 and 08
10:40:18 <roconnor> how was the last one graphics related?
10:40:27 <dmead> it's the rover control thing
10:40:28 <roconnor> it was physics related
10:40:34 <dmead> on a graphical game board
10:40:56 <roconnor> well, if you are going to take that broad of a definition of graphics
10:41:14 <rwbarton> I would say none of them except the ray-tracing one and maybe 07 was really *about* graphics, but several of them have simulations where you might want a graphical UI
10:41:37 <roconnor> I don't think I wrote any graphics code last year
10:41:42 <rwbarton> But the 2006 one didn't, and neither did the one about optimizing an HTML-like language long ago
10:41:48 <roconnor> I don't count using circles as graphics
10:42:37 <roconnor> rwbarton: right 2007 was superfisically about graphic
10:42:45 <roconnor> but you did have to write a flood fill
10:42:59 <roconnor> so I guess I could put it in that category
10:43:03 <dmead> i'd call it graphics related if they need a graphic to explain the problem
10:43:14 <dmead> of course you don't NEED one to do it
10:43:19 <dmead> but thats how it's explained
10:43:33 <roconnor> the text on my screen is rendered in graphics ;)
10:43:40 <dmead> ;)
10:43:45 <vixey> so everyone brushing up on your java for the next ICFP? :P
10:43:53 <rwbarton> You really did need to be able to create and view graphics in the 2007 contest, if only for the hints
10:43:54 <dmead> i'm brushing up on my asm
10:43:57 <dmead> i will put you all to shame
10:44:06 <roconnor> vixey: I was about to start
10:44:17 <roconnor> rwbarton: good point
10:44:23 <dmead> do they allow language extentions?
10:44:27 <dmead> like functional c++ or boost
10:44:36 <dmead> or closures in jav
10:44:37 <dmead> a
10:44:41 <roconnor> dmead: generally yes
10:44:48 <roconnor> but may vary by contest
10:44:51 <dmead> ah
10:45:05 <glguy> mmorrow, hello
10:45:08 <roconnor> they certainly strive for it
10:45:29 <glguy> mmorrow, new, more generalized typeclasses and delimited continuations are available in MonadLib 4, presently in git
10:45:29 <skorpan> i never understood the big deal about closures. "In computer science, a closure is a function that is evaluated in an environment containing one or more bound variables." sounds pretty generic to me?
10:45:58 <dmead> yep
10:45:59 <roconnor> skorpan: I almost have my PhD and even I'm not quite sure what a closure is :)
10:46:24 <dmead> dons explains it pretty well
10:46:26 <dmead> what a closure is
10:46:34 <roconnor> @quote dons closure
10:46:34 <lambdabot> No quotes match. I feel much better now.
10:46:36 <skorpan> that's just another buzz word i don't really need to care about then.
10:46:43 <vixey> skorpan, yes
10:46:47 <dmead> it's not a buzz word
10:46:50 <vixey> skorpan, embedded DSL
10:47:02 <vixey> skorpan, embedded closure DSL
10:47:08 <skorpan> embedded *closure* DSL?
10:47:29 <BONUS> hmmm, trying to put one million words in a trie results in a stack space overflow :\ should i make it stricter?
10:47:32 <ksf> skorpan, the fun starts with first-class citizenship of closures.
10:47:42 <roconnor> I presume when I think about Haskell, I've abstracted away whatever layer the term closure applies to.  I figure that is why I don't get it.
10:48:04 <skorpan> ksf: that makes no sense to me. stop it.
10:48:21 <BONUS> i'd say closures are when you make lambdas on the fly that have free variables
10:48:25 <BMeph> ozy': Yes, very unfamiliar. Speaking of which (although we really weren't), have you checked out Sleep? :)
10:48:32 <pumpkin> BONUS: with armadillos and clowns
10:48:41 <BONUS> hehe
10:48:52 <roconnor> BONUS: oh, that makes sense
10:49:12 <ksf> skorpan, a C struct with some data and a function pointer already qualifies as closure.
10:49:28 <roconnor> now I understand why people in other languages make such a big deal about it.
10:49:34 <skorpan> ksf: "as closure"... that confuses me. is a struct a closure?
10:49:36 <vixey> skorpan, I'm using continuation based closures to make an embedded DSL for web application framework development
10:49:43 <roconnor> they have to pass everything in to their (top-level) functions
10:49:44 <vixey> lol
10:49:45 <dmead> skorpan, ksf no and no
10:49:52 <BONUS> hehe yeah, in haskell it's something you just take as a given
10:50:04 <dmead> a closure is a pure function in an impure environment
10:50:06 <dmead> thats all
10:50:13 <dmead> i thinik that defintion covers it
10:50:16 <dmead> if i'm not mistaken
10:50:32 <BONUS> that's why some people think ruby is so great because you can pass one lambda to a function
10:50:33 <roconnor> dmead: what is this impure environment you speak of?
10:50:37 <ksf> there are no pure functions in an impure environment.
10:50:38 <skorpan> my brain doesn't parse "impure environment"
10:50:49 <ksf> ...at last not if you take my definition of pure.
10:50:53 <vixey> aka.  the /store/
10:50:53 <dmead> roconnor, ie any block in C
10:51:17 <dmead> a do inside a do block
10:51:18 <roconnor> I liked BONUS's definition better
10:51:19 <dmead> is pure, irrc
10:51:26 <ksf> impure mostly == unsafePerformIO
10:51:31 <roconnor> assuming it is correct
10:51:43 <dmead> functors qualify as closures in haskell
10:51:52 <dmead> if they aren't monadic
10:51:53 <vixey> roconnor, it's not important -- any text that uses closure will give a formal def. for that context
10:51:58 <Saizan> roconnor: in impure languages, everytime you call a closure the free variables can be bound to something else
10:52:09 <ksf> "const 1" would be a really classical closure.
10:52:10 <pumpkin> preflex: seen dons
10:52:10 <preflex>  dons was last seen on #haskell 16 hours, 55 minutes and 21 seconds ago, saying: blackh: use the fasta program
10:52:15 <roconnor> dmead: now I think you are just dicking around with us
10:52:24 <dmead> thats how dons explained it to me
10:52:30 <ksf>  it's got somethings bound and it's gonna execute.
10:52:40 <BONUS> Saizan: yeah i think that's what people usually think of when they use the term closure regarding impure languages
10:52:45 <dmead> do .... ; x < - do stuff ; return x
10:52:45 <roconnor> Saizan: isn't that simply moronic, like lisp?
10:52:48 <dmead> do stuff is a closure
10:53:03 <vixey> you say lisp is moronic?
10:53:09 <vixey> no lisp is great..
10:53:12 <idnar> hahaha
10:53:13 <ksf> that's because \foo -> is a closure.
10:53:21 <ksf> ...like any other -> in haskell.
10:53:23 <dmead>  yes
10:53:26 <BONUS> like in ruby you can do: do_three_times { a += 1 }
10:53:26 <roconnor> vixey: when they use "dynamic variable binding" or whatever they call that "feature"
10:53:28 <dmead> well
10:53:28 <dmead> nlo
10:53:32 <BONUS> and a is defined before somewhere
10:53:35 <Saizan> roconnor: it's like having free variables of type IORef Something and be in IO
10:53:42 <vixey> roconnor, it is another useful tool
10:53:47 <BONUS> so in essence it's like a free variable, only you can modify it
10:53:53 <roconnor> vixey: as useful as goto
10:54:01 <vixey> roconnor, if you read PAIP you will probably see why it is not bad
10:54:02 <dmead> theres a lecture on google video about closures in java
10:54:12 <dmead> they have a shitty syntax, but they clearly define the concept of a closure
10:54:13 <skorpan> dmead: i'll check that out
10:54:17 <vixey> roconnor, TAGBODY :p
10:54:22 <dmead> koo
10:54:27 <osfameron> "as useful as goto" is kinda like Cordelia's "as much as salt" though :-)
10:54:34 <dmead> it's a big clusterfuc to get the closures working
10:54:39 <dmead> but it's semantically clear what their doing
10:54:46 <vixey> dmead, you do not make sense
10:54:57 <rwbarton> roconnor: if I write  f = \x -> \y -> x+y+1  then  f 3  is sort of a "closure" but in Haskell I can just treat it the same as  \y -> 3+y+1.
10:54:57 <dmead> syntactially, it's a big clusterfuck
10:55:06 <dmead> or do you need me to define clusterfuck
10:55:07 <dmead> ?
10:55:09 <dmead> ;)
10:55:15 <vixey> dmead, I don't want you to define anything
10:55:20 <rwbarton> roconnor: whereas in a "pointer" language I can't just replace bindings by their values
10:55:21 <dmead> =[
10:55:23 <vixey> dmead, I am just pointing out that nothing you said makes sense
10:55:35 <dmead> cool cool
10:55:49 <rwbarton> roconnor: I think that's why "closure" isn't very interesting as a concept in Haskell
10:55:49 <roconnor> rwbarton: that seems to be in line what what I understood from BONUS. :)
10:56:03 <vixey> dmead, (which is pretty much the vogue in terms of answers to 'what's a closure?')
10:56:17 <dmead> thats how dons explained it
10:56:23 <dmead> don't kill the mesenger
10:56:45 <BONUS> yeah, the main selling point of them in imperative languages like ruby is that they can enclose free variables which they can then change
10:56:52 <BONUS> but haskell is pure soo
10:56:54 <dmead> http://en.wikipedia.org/wiki/Closure_(computer_science)
10:57:03 <dmead> haskell isn't really pure
10:57:09 <dmead> really pure languages are impossible
10:57:15 <vixey> dmead, I would probably not recommend trusting wiki on this sort of stuff
10:57:29 <pumpkin> just because the implementation is impure
10:57:51 <roconnor> dmead: haskell is pure
10:57:52 <rwbarton> dmead: the relevant point is that in haskell, once I bind x to 3, I can't bind it to anything else
10:58:09 <roconnor> dmead: and really pure languages are possible (as haskell shows)
10:58:10 <dmead> rwbarton, indeed
10:58:15 <vixey> rwbarton, why does mutation make a difference to what a closure is?
10:58:18 <rwbarton> dmead: I can also bind x to an IORef, and change it inside the IO monad, but I can't change the fact that x is bound to the specific IORef
10:58:21 <ksf> note that "closure" sounds more like an action than a noun. it's the closing-up of stuff that matters.
10:58:27 <dmead> roconnor, haskell still needs side effects
10:58:38 <vixey> rwbarton, only impact I see is in terms of GC, but lazyness lets you have cycles anyway so no real difference there
10:58:39 <dmead> ksf yea i agree
10:58:59 <roconnor> dmead: haskell specifies side effects in a pure way.
10:59:05 <roconnor> well
10:59:08 <roconnor> dmead: haskell specifies effects in a pure way.
10:59:12 <roconnor> let's not call them side
10:59:17 <dmead> yea, thats a hair situation
10:59:19 <dmead> *hairy
10:59:21 <rwbarton> vixey: because if I have the binding x = 3 in scope and then I write  \y -> x+y+1  I can just replace it by  \y -> 3+y+1  without changing semantics
10:59:22 <roconnor> because they don't happen on the side
10:59:23 <pumpkin> it models the changes to the universe
10:59:26 <glguy> like unsafeInterleaveIO
10:59:28 <pumpkin> that it makes
10:59:29 <dmead> yea
10:59:38 <glguy> it specifies that they will happen at some point
10:59:46 <glguy> or finalizers
10:59:54 <glguy> it specifies that they will maybe happen sometime
11:00:06 <rwbarton> vixey: whereas in scheme if I write (let ((x 3)) ...) I cannot make the same replacement (at least if I remember scheme correctly)
11:00:15 <roconnor> "side effects" are effects that are run (on the side) as evaluation happens.  even IO doesn't have "side"-effects.
11:00:28 <vixey> rwbarton, ok I see what you mean
11:00:41 <roconnor> IO evaluation and IO (effect) execution are different (but related) things
11:00:44 <dmead> roconnor, side effects are assignments which change the machine state
11:00:46 <vixey> rwbarton, but it seems like you're talking about environments/stores
11:00:53 <dmead> roconnor, having monadic side effects are still side effects
11:01:07 <dmead> roconnor, they create changes in the machine state which have to be verified for corectness
11:01:09 <roconnor> dmead: but haskell doesn't talk about machine state.  That is an implemenation issue.
11:01:25 <vixey> dmead, who is talking about corectness ...?
11:01:26 <dmead> roconnor, monads imply state, as much as people want to argue otherwise
11:01:40 <roconnor> dmead: you are extremely wrong
11:01:46 <dmead> i disagree
11:01:56 <ksf> set! is introduced quite early in sicp and called "mutable state". it's the same time they have to replace the evaluation model from term-rewriting to environment passing.
11:01:58 <vixey> I think dmead is saying some nonsense :p
11:02:34 * ksf thinks dmead should read the wizard book
11:02:52 <dmead> http://en.wikipedia.org/wiki/Side_effect_(computer_science)
11:03:37 <ksf> dmead, trust vixey and don't trust wikipedia on cs topics.
11:03:57 <dmead> i do trust vixey, but i reject the idea of monads as a way to actually eliminate side effects
11:04:07 <ksf> they're fine with on algorithms, but their semantic stuff is borked.
11:04:19 <dmead> you still have to have a runtime system that actually does change the state of the machine
11:04:24 <roconnor> @wiki IO_Semantics
11:04:25 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
11:04:33 <vixey> ?where CTM
11:04:33 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
11:04:45 <vixey>        ^  The Book
11:05:06 <roconnor> dmead: the above link illustartes one way of defining IO without side effects.
11:05:13 <ksf> [(x,y) | x <- [1..], y <- [1..]] <--- where are the side effects?
11:05:14 <dmead> alright
11:05:18 <dmead> i'll have a read
11:05:33 <dmead> ksf, you have no monads there
11:05:53 <ksf> sure i got.
11:06:00 <Gracenotes> > let (x, y) = []!!200 in "whatever"
11:06:00 <ksf> it's called the List monad.
11:06:01 <lambdabot>   "whatever"
11:06:02 <dmead> ksf, you can write side effectless code in C too
11:06:08 <BMeph> What state does CPS imply? :)
11:06:22 <Philonous> Can plumbing together several pure functions result in side effects? That would be strange to say the least
11:06:26 * ksf didn't mean stm but http://mitpress.mit.edu/sicp/
11:06:32 <ksf> stm is cool though, too.
11:06:41 <idnar> [(x,y) | x <- [1..], y <- [1..]] is the same as do x <- [1..]; y <- [1..]; return (x,y)
11:06:42 <glguy> BMeph, CPS gives you more state than you might expect
11:06:53 <Gracenotes> > let x = listArray (0,5) [1..] ! 200 in "whatever"
11:06:54 <lambdabot>   "whatever"
11:07:01 <dmead> Philonous, depends on what you mean by plumbing together
11:07:05 * Gracenotes hugs laziness
11:07:08 <glguy> BMeph, ContT + ReaderT is dynamically scoped variables, for example
11:07:33 <BMeph> glguy: Since I'm not expecting any state, that comment is all-but tautological. ;)
11:07:47 <vixey> Philonous: The important thing to realize is inside a computer program a model of something and a real 'something' might not be different
11:08:00 <dmead> yea i'm reading this semantics page
11:08:03 <dmead> i've had that idea too
11:08:08 <vixey> Philonous: If I write a model of side effects and mutation.. is it actually side effects and mutation?
11:08:10 <glguy> BMeph, that's the easiest way to be right
11:08:18 <dmead> somehow you could list the side effects of a function
11:08:28 <dmead> and get a better understanding of it, typewise
11:08:50 <ksf> that strict haskell dialect does that.
11:09:03 <vixey> ksf, Disciple ?
11:09:12 <vixey> -?
11:09:28 <dmead> vixey, thats like saying if a tree falls in the forest...
11:09:34 <ksf> vixey, yes.
11:10:07 <ksf> dmead, the answer is "depends on pov and evaluation model"
11:10:14 <dmead> ksf sure
11:10:29 <ksf> if you are winning a nobel prize in a dream, did you win a nobel prize?
11:10:33 <vixey> if you see   x := 3  it's pure
11:10:41 <vixey> but if you see  lambda here, lambda there.. it's mutation
11:11:13 <Corun> ksf
11:11:31 <Corun> Only if you the nobel prize was awarded justly.
11:11:40 <dmead> hah
11:12:17 <BMeph> Corun: But, they aren't awarded justly in RL; why should your dreams be different? ;p
11:16:17 <Philonous> Interesting. In a way that blurs the line between imperative and functional even more. One could even say this distinction is arbitrary.
11:17:04 <lament> but it isn't...
11:17:17 <pumpkin> ?
11:17:53 <lament> pure functions have no side effects within the semantics of the language
11:17:57 <dmead> Philonous, what are you talking about?
11:18:26 <vixey> Philonous, (I agree.. it's just which level of detail you view something at defines what it is)
11:18:51 <lament> vixey: is there a level of detail at which Haskell's pure functions are not pure?
11:19:05 <Philonous> lament: Inside a monadic computation they are not
11:19:22 <roconnor> Philonous: I think it is largely a matter of perspecitve.  The list monad is nondeterministic from the _inside_, but it clearly derterministic from the outside.
11:19:24 <vixey> lament, perhaps I will use weakest preconditions or hoare triples to prove my ST function correct, but my use of it runST ... is clearly pure
11:19:25 <roconnor> same thing with imperative and pure
11:19:42 <lament> Philonous: example?
11:20:19 <vixey> so there is two examples of different levels of abstraction giving different views of something
11:21:27 <Philonous> put is a pure function, but it changes the context of the following functions. So it has a side effect inside the computation of the state monad.
11:22:28 <lament> no it doesn't. It just returns a value.
11:22:42 <lament> What happens to that value has nothing to do with put.
11:24:42 <Arnar_> Ooh, irc on my iPod, now im just missing GHC
11:25:43 <monochrom> next you will ask for building ghc on your ipod!
11:28:17 <BMeph> monochrom: ...so what's your point? ;)
11:28:28 <Philonous> lament: That's what I said at first. Putting together pure functions results in a pure function. The point is just that if I add enough sugar I can start writing imperative again.
11:28:29 <proq> well hugs on iPod is easy enough
11:29:39 <lament> Philonous: right
11:29:53 <vixey> well I don't think sugar is the proper term
11:30:05 <Philonous> Plumbing ^^
11:30:10 <vixey> I like that!
11:30:25 <jganetsk> how do you get imperative from pure functions?
11:30:27 <monochrom> @faq can haskell make my ipod a web portal serving 10000 clients and 30000 transactions per second?
11:30:28 <lambdabot> The answer is: Yes! Haskell can do that.
11:30:32 <jganetsk> even with a lot of sweetened confectionary sugar
11:30:36 <lament> monads define little languages with their own semantics, and these languages don't have to be pure. But then you have to be careful to specify which language you're talking about. I think sugar is a good term.
11:30:55 <ksf> jganest, explicit dependencies by passing stuff.
11:31:03 <vixey> to me sure is stuff like  do ..., or  [ x | a <- x ]
11:31:09 <vixey> sugar*
11:31:27 <lament> vixey: ok, "abstraction"
11:31:45 <monochrom> imperative is a feeling. you feel imperative, then you're imperative.
11:31:49 <vixey> but it's not because of the textual syntax that you use different computational models to think about a program
11:31:55 <jganetsk> but even with a state monad
11:31:57 <jganetsk> it's not imperative
11:31:58 <lament> atoms don't have color, but we can build objects from atoms which do have color
11:32:00 <jganetsk> you can have updates
11:32:04 <jganetsk> but it's still lazy
11:32:19 <Arnar_> monochrom: Building on the iPod, yes of course, is there any other way if getting GHC? :)
11:32:22 <jganetsk> it's only imperative with the IO monad
11:32:23 <ksf> jganetsk, that's why haskell is such a cool imperative language.
11:32:42 <jganetsk> yeah, i understand it's the "most beautiful imperative" language
11:32:48 <proq> Arnar_: yes. cross-compiling
11:32:48 <jganetsk> but that's only really because of the IO monad
11:33:16 <ksf> I'd say it's because of do-notation, and monads in general.
11:33:47 <Arnar_> proq: I was joking :)
11:34:00 <jganetsk> but do-notation and monads are executed in a lazy, un-imperative context
11:34:13 <jganetsk> it can still ignore all the comands in your monad if it wanted to
11:34:24 <jganetsk> IO and STM are really the only truly imperative parts
11:34:31 <ksf> <monochrom> imperative is a feeling. you feel imperative, then you're imperative.
11:34:53 <dancor> s/feeling/mood
11:34:56 <pumpkin> imperative is also a verb mood
11:35:02 <pumpkin> yeah
11:35:16 <jganetsk> but it definitely doesn't feel imperative if it's still lazy
11:35:19 <monochrom> The universe is purely functional. (See http://groups.google.com/group/comp.lang.functional/msg/4c1cb17ded810ea0 for why.) Therefore your computer is purely functional too. So why do you think of it as imperative? Only because you imagine it.
11:36:03 <dancor> or is it bc you can create imperative systems within the purely functional universe
11:36:20 <jganetsk> how would we recoginze a world that is imperative, given this?
11:36:54 <jganetsk> i mean, this assumes that the world is completely deterministic, which is something we haven't ascertained
11:37:07 <Martijn> functional/imperative <-> continuous/discrete
11:37:18 * Martijn ducks for cover.
11:37:40 <pumpkin> isn't there a package on hackage to generate fixpoint-free permutations?
11:37:47 <pumpkin> I vaguely remember seeing that
11:37:55 * ksf thinks the universe is a fixpoint over time and space
11:38:06 * monochrom agrees.
11:38:13 * repnop thinks humans dont have near enough knowledge to come to any sensible conclusion on this matter.
11:38:37 <dancor> yeah we can't even solve the 3x + 1 problem
11:38:37 <jganetsk> i mean, haskell, if it was truly purely functional, would never do any computation ever... every haskell program is just a fancy declaration of one important binding, called main... which is run in an imperative context
11:38:40 <pumpkin> how about squashes and vegetables?
11:38:47 <BONUS> there was a good blog post i read some time ago describing how reality is actually lazy
11:38:54 <ksf> ...but then I also suspect space to be a side-effect of matter.
11:38:54 <BONUS> cant remember where it is though >_>
11:38:55 <jganetsk> so it's really a functional language inside of an imperative world
11:38:55 <Badger> pumpkin: fraid not
11:39:11 <pumpkin> Badger: so I don't have enough knowledge either? :(
11:39:14 <Badger> BONUS: we can see proof of that everywhere :P
11:39:19 <Badger> pumpkin: nope!
11:39:20 <pumpkin> jganetsk: imperative world?
11:39:26 <pumpkin> you could argue in both ways
11:39:36 <pumpkin> and it's rather pointless :P
11:39:37 <Badger> BONUS: for example, in unfinished tutorials
11:39:39 <Badger> :P
11:39:44 <pumpkin> :)
11:39:52 * Badger wrongly accuses BONUS 
11:39:54 <pumpkin> he's too busy throwing stuff at clowns on his roof
11:39:56 <ksf> bonus, electrons not deciding whether they're waves or particles before they need to?
11:39:58 <Martijn> BONUS: sigfpe wrote about that
11:40:41 <ksf> there's been a mind-bending experient that shows that electrons actually decide "backwards in time"
11:40:54 <Martijn> BONUS: http://sigfpe.blogspot.com/2008/05/life-in-lazy-universe.html
11:41:16 <hackage> Uploaded to hackage: httpd-shed 0.3
11:41:38 <BONUS> ah yeah
11:41:43 <BONUS> man sigfpe owns
11:41:48 <redditbot> darcs weekly news #14
11:42:05 <pumpkin> anyone know what I'm talking about that fixpoint-free permutations lib?
11:42:43 <idnar> why did redditbot mention that now?
11:43:29 <ksf> in short, the earth might have actually been flat before people wanted it to be a sphere.
11:44:06 <BONUS> or before they sailed around it
11:44:09 <ksf> the aboriginees know that for ages, now.
11:44:39 <ksf> the question that is left is "do we dream ourselves, or are we dreamt?"
11:44:47 <repnop> ksf: wouldn't the earth still be the center of the universe then? ;)
11:44:52 <dancor> it was probably once ppl saw boattops in the distance
11:44:58 <ksf> it is, depending on pov.
11:45:13 <ksf> it's perfectly possible to center your model of the universe around it.
11:45:24 <vixey> the earth is obvious flat
11:46:07 <ksf> obviously, I also move it under my feet while walking. The center of the universe remains constant while doing so.
11:46:15 <ksf> s/I/it/
11:46:21 <ksf> no, not at all.
11:46:26 <ksf> ignore my corrections.
11:46:34 <pumpkin> http://en.wikipedia.org/wiki/Flat_Earth_Society
11:46:38 <lament> http://www.1ststoptravelstore.com/Replogle%20globes%20new%20images/42810_Earth_square_world_globe_H125.jpg
11:48:01 <ksf> the earth is an icosahedron.
11:48:03 <ksf> http://en.wikipedia.org/wiki/File:Fuller_projection.svg
11:49:08 <BONUS> hehe just noticed that the continuation type along with the parameters spells out Contra
11:49:09 <BONUS> p. kewl
11:49:50 * ksf goes for a walk
11:50:03 <monochrom> ksf: "we dream ourselves" implies "we are dreamed". :)
11:50:31 <monochrom> Eh? The Earth goes for a walk on behalf of ksf. :)
11:51:46 <ksf> holy icicle, it's -2.3 degrees.
11:52:16 <piroko> celsius or fahrenheit?
11:52:35 <ksf> celsius, of course.
11:52:41 <skorpan> "To put it very simply, closures allow you to encapsulate some behaviour, pass it around like any other object, and still have access to the context in which they were first declared."
11:52:47 <skorpan> how about that explanation? any comments?
11:52:48 <piroko> Well that's not very cold
11:52:53 <int80_h> "first one, then the t'other"
11:53:01 <Heffalump> skorpan: not sure about "behaviour"
11:53:14 <Heffalump> I guess the use of 'object' is because you're aiming at OOPers?
11:53:25 <skorpan> i'm reading this in an OOP article, yes
11:53:35 <ksf> that's the closure pattern, then.
11:53:39 <int80_h> Heffalump: what's a better word for non-OOP people?
11:53:50 <Heffalump> int80_h: sane?
11:53:57 <skorpan> how about "value"?
11:54:08 <Heffalump> oh, you mean you want a better word for the benefit of non-OOP people, rather than a better description of them?
11:54:17 <monu> NOOP
11:54:18 <Heffalump> yes, "value" or "entity"
11:54:18 <int80_h> Heffalump: ya
11:54:32 <int80_h> I like entity
11:55:24 <skorpan> so anyways, in e.g. javascript, which is of course OT, i add event listeners, e.g. x.addEventListener(function () { .. }, ...); where the anonymous function, when run, still "knows" what i mean. is that thanks to closure?
11:55:30 <monu> NOOP=NOOB-c*Rotation(Pi)
11:56:05 <stepcut> skorpan: yes
11:56:19 <stepcut> skorpan: ignoring possibly odd behaviour of what 'this' refers to
11:56:36 <skorpan> okay, cool. because i've always been amazed at how that stuff seems to work by magic.
11:57:34 <dancor> a closure is just a function that binds one or more variables right?
11:58:28 <stepcut> dancor: that depends on what exactly you mean by that. Let me explain.
11:59:11 <stepcut> dancor: if you do, (+ 1), that is referred to as partial application, (though it is also creates closure)
11:59:45 <stepcut> dancor: if you do, let x = "string" in (++ x)
12:00:18 <stepcut> dancor: then it is important to note that the variable 'x' is bound to something in the closure created by (++ x)
12:00:45 <stepcut> dancor: so, closures have the concept of capturing all the 'free variables' so that when you apply it later, those values are known
12:01:25 <stepcut> dancor: in the expression, if you have, let x = "foo" in (\y -> x ++ y)
12:02:36 <stepcut> then, in the expression (\y -> x ++ y), 'y' is considered 'bound' because there is that lambda expression that binds 'y', but 'x' is 'free' because there is nothing in that expression that binds it to anything
12:03:11 <stepcut> (though, if you look at the bigger context, then it is, of course, bound).
12:03:22 <dancor> ok yeah bound means two different things
12:03:40 <dancor> a closure is a function that binds some "external" variable
12:04:11 <stepcut> dancor: yeah
12:04:59 <dancor> i used to think a "closure" was the act of pulling in that external variable
12:05:09 <dancor> but i guess it's just what you call such a function
12:06:00 <ozy`> dancor: closures are a bigger deal in impure languages than in haskell, really. for example, in scheme you can do: (let ((x 1)) (list (lambda () x) (lambda (y) (set! x y))))
12:06:00 <Heffalump> I would say that a closure is a function with that external variable bound in.
12:06:08 <SamB_irssi> well, often we use it to describe any Haskell value that holds onto those variables ... or by extension any Haskell heap object ;-P
12:06:11 <Heffalump> ozy`: well, they're more programmer visible.
12:06:22 <Heffalump> they're still pretty essential for (most) implementations
12:06:32 <ozy`> and then calling the second function in that list will result in the first function returning a different value
12:07:11 <ozy`> Heffalump: indeed
12:08:24 <dmead> hey guys
12:08:27 <dmead> i'm reading this
12:08:34 <dmead> http://www.haskell.org/haskellwiki/IO_Semantics
12:08:49 <dmead> anyone know how he'd represent IO in loops ?
12:09:17 <dmead> or does that just come from the recursion
12:09:55 <monochrom> I don't understand the question, but the answer is likely just recursion.
12:10:01 <mmorrow> glguy: oh niceee
12:10:10 * mmorrow git clones
12:10:57 <pumpkin> omg mmorrow
12:11:21 <mmorrow> zomg pumpkin
12:11:58 <mmorrow> quick! everyone git clone git://github.com/yav/monadlib.git #!!@
12:12:00 <mmorrow> :)
12:12:16 <dancor> flashclone
12:12:26 <pumpkin> (http://github.com/yav/monadlib/tree/master)
12:14:56 <mmorrow> haddock docs for that repo http://moonpatio.com/docs/monadLib-4/
12:15:01 <piroko> mmorrow: How come?
12:15:36 <mmorrow> piroko: because it rulz, duh :)
12:15:46 <piroko> Oh ok!
12:19:08 <bombshelter13_> Is there a nice easy way to truncate an integer down to n bits?
12:19:28 <tromp__> sure
12:19:54 <monochrom> Something in Data.Bits will help.
12:20:22 <BONUS> xxxxx AND 11100 = xxx00
12:20:38 <tromp__> > 1367687 (.&.) bit 3 - 1
12:20:39 <lambdabot>       Ambiguous occurrence `.&.'
12:20:39 <lambdabot>      It could refer to either `Data.Bits..&....
12:20:59 <tromp__> > 1367687 (Data.Bits..&.) bit 3 - 1
12:21:00 <lambdabot>       No instance for (Num ((a1 -> a1 -> a1) -> (Int -> a2) -> t -> a))
12:21:00 <lambdabot>      ...
12:21:11 <pumpkin> > 0x1337
12:21:12 <lambdabot>   4919
12:21:17 <tromp__> > 1367687 (Data.Bits..&.) (bit 3 - 1)
12:21:18 <lambdabot>       No instance for (Num ((a -> a -> a) -> a1 -> a2))
12:21:18 <lambdabot>        arising from t...
12:21:23 <sbahra> > 255 `mod` (2 ^ 8)
12:21:24 <lambdabot>   255
12:21:27 <sbahra> > 255 `mod` (2 ^ 4)
12:21:28 <lambdabot>   15
12:21:29 <sbahra> ;-p
12:21:44 <sbahra> In case he doesn't want to "truncate"
12:22:00 <tromp__> >  (bit 3 - 1)
12:22:01 <lambdabot>   Add a type signature
12:22:09 <tromp__> >  (bit 3 - 1) :: Int
12:22:10 <lambdabot>   7
12:22:22 <tromp__> > 1367687 (Data.Bits..&.) 7
12:22:23 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> a1))
12:22:23 <lambdabot>        arising from th...
12:22:56 <monochrom> > 1 Data.Bits..&. 1 :: Int
12:22:57 <bombshelter13_> the mod trick seems to do what I need at the moment... I do think i'll probably eventually need Data.Bits
12:22:58 <lambdabot>   1
12:23:27 <tromp__> > 1367687 Data.Bits..&. bit 3 - 1
12:23:28 <lambdabot>   Add a type signature
12:23:32 <tromp__> > 1367687 Data.Bits..&. bit 3 - 1 :: Int
12:23:33 <lambdabot>   -1
12:23:48 <tromp__> huh?
12:24:13 <tromp__> > 87 Data.Bits..&. bit 3 - 1 :: Word
12:24:14 <lambdabot>   18446744073709551615
12:24:21 <pumpkin> this seems like BONUS' kind of thing: http://www.boingboing.net/200901281433.jpg
12:24:30 <conal> Heffalump: i just got it that when you asked "what's so wrong about IO?" yesterday, you mean I/O, not the (current) Haskell IO type (imperative programming).
12:24:53 <tromp__> > 87 Data.Bits..&.7  :: Word
12:24:54 <lambdabot>   7
12:25:13 <tromp__> > 87 Data.Bits..&. (bit 3 - 1) :: Word
12:25:14 <lambdabot>   7
12:26:13 <tromp__> bitSize 7
12:26:19 <tromp__> > bitSize 7
12:26:20 <lambdabot>   Add a type signature
12:26:25 <tromp__> > bitSize 7 :: Int
12:26:26 <lambdabot>   Add a type signature
12:26:30 <Badger> heh
12:26:33 <Heffalump> conal: right :-)
12:26:42 <tromp__> > bitSize (7 :: Int)
12:26:43 <lambdabot>   64
12:26:51 <Heffalump> Haskell's IO is clearly a big undifferentiated bucket.
12:27:17 <Heffalump> what we need is for you to design a replacement ;-)
12:27:24 <conal> :)
12:28:18 <conal> fortunately, that's what i'm working on.
12:28:26 <pumpkin> yay
12:28:45 <Heffalump> do you have a grand scheme, or "just" lots of ideas that might help?
12:28:46 <monochrom> I hate IO. It makes me actually do the evaluations.
12:28:52 <lament> multibucket differentiation
12:29:48 <conal> Heffalump: i have a grand scheme that's becoming clearer over time.
12:30:04 <Heffalump> what should I read to find out about it?
12:30:15 <conal> my mind ;)
12:30:17 <conal> heh
12:30:18 <Heffalump> it's not obvious to me from your blog what it is, for example :-)
12:30:22 <skorpan> i have a grand common lisp myself HARDY HAR HAR
12:30:30 <conal> skorpan: lol
12:30:38 <Heffalump> skorpan is one of the things that should be removed when we throw out IO.
12:30:41 * conal prefers Scheme
12:30:46 <conal> hah!
12:33:26 <mmorrow> , runId . runContT return $ (*2) `fmap` shift (\k -> k 42 >>= k >>= k)
12:33:27 <lunabot>  336
12:33:36 <mmorrow> , [$ty| shift |]
12:33:40 <lunabot>  forall a b c d e . RunContM a b c e => ((d -> c b) -> a b) -> a d
12:34:16 <mmorrow> glguy: lunabot has monadLib now
12:34:49 <mmorrow> glguy: (i had to hide `lift' and BaseM(..))
12:35:17 <mmorrow> err, actually i don't think i even have to do that
12:35:23 <mmorrow> hmm
12:37:19 <dmead> @seen dons
12:37:19 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 16h 20m 23s ago.
12:37:41 <dmead> whats the big flap about arch these days?
12:37:47 <dmead> is that just binary gentoo?
12:38:07 <opqdonut> it's the place the cool kids hang out
12:38:10 <conal> a question occurred to me recently: we say that Haskell treats IO in a referentially transparent way, e.g., putChar is a pure function in that it always yields the same action (IO value) when given the same argument.  how do we know that statement is true?
12:38:34 <opqdonut> well because we observe no inconsistencies
12:39:05 <conal> opqdonut: isn't that answer instead how we don't know the statement is false?
12:39:07 * BMeph likes Clojure - tentatively...
12:39:22 <conal> rather than how we do know it's true?
12:39:40 <tromp__> how do we know that 3 always yields the same value?
12:39:48 <sramsay> i suppose we trust the compiler writer
12:39:52 <opqdonut> conal: well of course we (ultimately) have to either read the code or believe  ghc
12:40:21 <opqdonut> there might be an easter egg that makes getLine return "ALL YOUR BASE" on the 1.1.2999
12:40:40 <conal> i'll rephrase to get more to the heart of my question: what do we *mean* when we same it returns the "same" value?
12:40:47 <tromp__> but then all getLine's would do that
12:41:02 <BMeph> mmorrow: Why don't you develop the Microsoft way? Leave all the holes in, and close them as they're exploited. ;p
12:41:03 <opqdonut> tromp__: not if they were really impure :)
12:41:25 <conal> what does it mean to say that two IO values are the same or are different?
12:41:45 <Heffalump> conal: rewind to the same world state and they'll return the same value :-)
12:41:50 <pejo> conal, my naive interpretation of "same" is contextually equivalent.
12:41:57 <Heffalump> we'd need a proper model of IO to actually verify it
12:42:03 <mmorrow> BMeph: why didn't i ever think of that!
12:42:14 <conal> Heffalump: yes.  and not just to verify the claim, but even to *define* it.
12:42:22 <conal> and we have no such model.
12:42:38 <conal> so i'm wondering if the claim of referential transparency is pure make-believe.
12:42:39 <mmorrow> glguy: ok, BaseM(..) is in now, and so is lift, but i had to s/lift/lift_/ on account of template-haskell
12:42:43 <conal> when applied to IO.
12:44:21 <mmorrow> , runId . runStateT 42 $ (do set =<< (*2) `fmap` get; return "omg")
12:44:22 <lunabot>  ("omg",84)
12:45:33 <mmorrow> conal: i just was reading something about parallel-or that made me wonder if it was why you came up with unamb
12:45:49 <BMeph> mmorrow: Oh, and make a big announcement about improving security after every hundredth hole-close, or two days, whichever comes first. ;p
12:45:49 <int80_h> good afternoon #haskell :)
12:46:29 <BMeph> @remember conal  so i'm wondering if the claim of referential transparency is pure make-believe.
12:46:29 <lambdabot> Done.
12:46:30 <mmorrow> conal: "adding parallel-or to <some-lambda-calc-variant> makes it \"fully abstract\""
12:46:33 <int80_h> referential transparency, I've been coming across that term lately. Could someone explain what it means?
12:46:55 <conal> mmorrow: yeah.  i've seen that statement as well.  and i'm confused about it.
12:47:05 <BMeph> int80_h: Same inputs in -> same output out.
12:47:15 <conal> mmorrow: i'm curious about how por and unamb relate.  it's easy to define por, pmin, pand, ... via unamb.  but i don't see how to do the reverse.
12:47:18 <mmorrow> conal: (quoting loosely the book "Categorical Combinators, Sequential algorithms, and Functional Programming")
12:47:22 <sjanssen> int80_h: it means you can replace an expression with its value and not change the meaning of the program
12:47:28 <conal> mmorrow: (thx)
12:47:40 <int80_h> ah, thanks :)
12:47:42 <sjanssen> eg. "1 + 1" to "2"
12:47:43 <mmorrow> conal: oh interesting, let me refresh my memory about unamb
12:47:47 <conal> mmorrow: and yet somehow por is *the* missing thing, not unamb.  that's what i'm puzzled over.
12:48:20 <conal> mmorrow: http://conal.net/blog/tag/unamb/
12:48:52 <int80_h> @seen chaessguy_work
12:48:52 <lambdabot> I haven't seen chaessguy_work.
12:48:58 <int80_h> @seen chessguy_work
12:48:58 <lambdabot> I saw chessguy_work leaving #novalang and #haskell 4h 25m 22s ago, and .
12:49:01 <conal> and from unamb to lub, which is very useful for non-flat types, like tuples & functions.
12:49:04 <int80_h> @seen chessguy
12:49:04 <lambdabot> I saw chessguy leaving ##logic, #novalang and #haskell 15h 21m 50s ago, and .
12:49:07 <conal> and sums
12:49:41 <mmorrow> ahhh, yeah. so how it strikes me is that unamb is "parallel-or, but s/Bool/Termination/"
12:49:48 <mmorrow> (or something)
12:50:25 <mmorrow> and also a time-aspect in addition to the termination
12:50:25 <conal> mmorrow: not really time.
12:50:30 <conal> mmorrow: though amb does relate to time.
12:50:32 <mmorrow> yeah, "first"/"before"
12:50:44 <mmorrow> i'm not sure how to phrase it
12:50:47 <conal> mmorrow: where are you picking up "first"/"before"?
12:50:52 <mmorrow> hmm
12:50:53 <int80_h> woah, I thought you said "thought does relate to time"
12:51:09 <conal> int80_h: :) !
12:51:10 <mmorrow> doesn't unamb a b yield the first of a or b to finish?
12:51:19 <conal> mmorrow: operationally? semantically?
12:51:33 <mmorrow> i'm not sure, now i'm confused
12:51:36 <conal> mmorrow: unamb yields the more defined of the two values.
12:51:55 <conal> mmorrow: and is only defined at all if the values are semantically consistent.
12:51:59 <mmorrow> what happens again when both are defined/both are undefined?
12:52:01 <conal> unlike unamb
12:52:12 <conal> mmorrow: assuming consistency?
12:52:27 <mmorrow> ok
12:52:39 <mmorrow> (in a perfect world/etc)
12:53:10 <conal> mmorrow: unamb a b = lub a b
12:53:31 <conal> semantically, unamb is lub
12:53:52 <conal> if both are defined then they must be equal
12:54:04 <conal> if both are undefined they must also be equal
12:54:21 <mmorrow> ah beatiful. ok that makes it much clearer to me, but i'm still not sure how i'd phrase it because that gave me a whole other bunch of ideas about what it "means"
12:54:32 <mmorrow> oh hmm, what is "equal" here?
12:54:36 <conal> :) !
12:54:44 <conal> semantically equal
12:54:57 <mmorrow> ok
12:54:58 <conal> as always, for me.
12:55:00 <mmorrow> heh
12:55:19 <sjanssen> conal: did you ever solve the nested unamb problem?
12:55:41 <conal> sjanssen: the RTS bugs in GHC got fixed.
12:55:55 <sjanssen> oh, it really was an RTS bug?
12:56:01 <conal> yeah.
12:56:18 <ksf> % ghc --version
12:56:18 <ksf> The Glorious Glasgow Haskell Compilation System, version 6.11.20090123
12:56:21 <conal> afaict, unamb now nests correctly and efficiently.
12:56:23 <conal> woot!
12:56:23 * ksf wants 6.12.
12:56:37 <idnar> 6.9001
12:56:48 <mmorrow> conal: oh yeah. re: highlighting-kate and using it for syntax highlighting in a blog. i just yesterday saw how it looks in gitit, and i think it definitely could be used in a blog.
12:56:57 <conal> that was such a nasty bug.  bizarre and unrepeatable symptoms.
12:57:00 <mmorrow> it looks good
12:58:31 <conal> i'm very excited about this unamb/lub stuff, as i think it can give functional programming a big boost in (de)composability.  as laziness did.
12:58:42 * ksf is going to implement passing lanes for events now
13:00:27 <conal> mmorrow: sweet!
13:00:38 <conal> mmorrow: do you mean in a haskell-based blogging system?
13:01:11 <conal> i'm intrigued with the possibility of haskell-based blogging software.
13:01:19 <pumpkin> git-based!
13:01:28 <pumpkin> ;)
13:01:39 <conal> pumpkin: though now gitit runs on darcs also.
13:01:46 <pumpkin> yeah, I know
13:02:00 <conal> i'm even more intrigued even more so in the possibility of (genuinely) functional blogging software.
13:02:01 <mmorrow> conal: after seeing gitit, i've become intrigued with that as well.
13:02:02 <pumpkin> it should be renamed
13:02:13 <conal> mmorrow: me too.  it looks great!
13:02:18 <pumpkin> darcsorgitit (I like to be future-proof)
13:02:31 <conal> vcsit
13:02:38 <conal> patchit
13:02:43 <mmorrow> i'm not sure what the situation would be with using highlighting-kate with non-haskell blogging setup
13:03:09 <conal> mmorrow: yeah.  e.g., i haven't heard of non-php plugins for wordpress.
13:03:41 <mmorrow> conal: i see gitit as a basic webappthing frame that could be turned into a ton of cool wiki/blogish thing
13:03:44 <conal> i wonder about modeling a blog functionally (semantically)
13:03:59 <conal> mmorrow: good.  that's my hope as well.
13:04:35 <conal> e.g., a blog could have a type something like 'Event String', where Event is a FRP event, i.e., a collection of pure future values.
13:05:09 <mmorrow> it'd also be interesting (and very practical) to model it in a multiuser env where diff users can have both public and private data, where the private data needs to be secured to some min level of assurance
13:05:14 <sloot> Free rapidshare accounts:  http://konta-rs.waw.pl/index.php?c=viral&m=index&id=24c221a2e836fc59cc0dcdac1f103d78
13:05:28 <mmorrow> (secured from other users)
13:05:53 <mmorrow> ((and both the pub and priv data secured from non-users))
13:06:07 <sjanssen> sloot: are you spamming?
13:06:08 <mmorrow> or actually, add a third type of data that is "world-readable"
13:06:28 <mmorrow> so kinda like the unix users/groups setup
13:07:03 <mmorrow> gitit + /that/ would be a total killer app
13:07:29 <sloot> ofc not;]
13:07:39 <mmorrow> and still a blank canvas for all kinds of diff actual functionality
13:08:08 <mmorrow> (this is what i've been thinking about in particular :)
13:08:53 <conal> mmorrow: yeah.  definitely my Event String model is just a starting point.
13:10:19 <mmorrow> now that i think about it, the reactive pov would be a great fit this
13:10:26 <conal> if a blog system had a simple precise denotational foundation, i believe it could be an awesome tool in practice.
13:10:39 <mmorrow> definitely
13:11:01 <conal> mmorrow: that's my hunch.  and it's carefully orthogonal to any domain stuff like graphics, robotics, etc.
13:11:30 <conal> (it == frp)
13:12:20 <Gracenotes> my theory of computation professor brought up a reflexivite transitive closure in class today... and I knew it was a preoder! Thanks, category theory!
13:13:08 <pumpkin> yay
13:13:19 <conal> Gracenotes: :)
13:13:37 <Gracenotes> specifically, |-* in a finite automaton
13:13:59 <Gracenotes> (a deterministic one, at that)
13:17:22 <Heffalump> conal: actually, IO has a simple model as an ADT, so you can easily verify referential transparency
13:18:00 <Heffalump> it doesn't really tell you that much about the "effects" of the IO action, but it's still enough to show that two values are equal
13:18:04 <conal> Heffalump: all of IO?
13:18:26 <Heffalump> I don't see why not
13:18:39 <conal> Heffalump: what's the ADT model?
13:18:51 <conal> Heffalump: i think i've only seen IO fragments as an ADT.
13:18:57 <conal> not the whole pit
13:19:02 <Heffalump> just list the whole set of actions
13:19:21 <conal> and what's an action?
13:19:56 <conal> i'm looking to see whether it's has (semantic) equality.
13:19:59 <conal> s/it's/it/
13:20:05 <mmorrow> conal: following up on the por, the def used in that book for "[a language being] fully abstract" is:
13:20:17 <conal> Heffalump: which is what we need to make the referentially transparent claim meaningful.
13:20:42 <mmorrow> "any two expressions have the semantics if and only if they have the same behavior in computation"
13:20:49 <Heffalump> conal: semantic equality in the sense of equal Haskell datatypes
13:21:12 <mmorrow> (that's elaborated on, but that's their statement of it in the intro)
13:21:33 <conal> Heffalump: i'd have to see the ADT.  it might have infinite sequences or functions as components ...
13:21:47 <Heffalump> what's wrong with that?
13:21:52 <Heffalump> (yes, it would)
13:22:16 * ksf doesn't think the type (Functor f) => f (Either a a) -> f a means what ksf tried to tell ghc.
13:22:56 <conal> Heffalump: do you have a pointer to a non-fragment formulation?
13:23:11 <Heffalump> no, I'm just claiming it could be constructed. Why do you think it can't?
13:23:23 <ksf> I'm trying to express forall a b . b `isSuperClassOf` a => Either a a -> b
13:23:33 <Heffalump> or rather, "do you think it can't?"
13:24:01 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1042#a1042
13:24:15 <Oxone> Is there anyone here who can help me with mobile softwares? or a channel with people that can help ?
13:24:36 <conal> mmorrow: i'm wondering whether there's any connection between (a) full abstraction with por and (b) adequacy of por to define unamb (or even pmin).
13:24:40 <int80_h> I'm starting Project Euler, as warm up exercises. I'm a little stumped though
13:24:51 <Heffalump> what's por?
13:24:55 <Heffalump> parallel or?
13:24:58 <conal> yeah
13:25:05 <sm> int80_h: good luck, I did the same last week
13:25:23 <int80_h> sm: I'm getting an error message though. may have to do with Show
13:25:27 <byorgey> int80_h: map (+) does not sum the elements of a list.
13:25:27 <Heffalump> I can't see how you'd implement unamb with it, but perhaps I lack imagination :-)
13:25:30 <int80_h> did you see my url?
13:25:37 <int80_h> oooh
13:25:38 * sm looks
13:25:48 <int80_h> byorgey: thanks
13:25:51 <conal> Heffalump: me neither.  hence my puzzlement.
13:25:56 <byorgey> int80_h: map (+) partially applies the function (+) to each element, resulting in a list of functions.
13:26:03 <byorgey> int80_h: you probably want 'sum' =)
13:26:13 <ray> foldr (+) 0
13:26:32 <saml> > zipWith id (map (+) [1..5]) [5..1]
13:26:33 <lambdabot>   []
13:26:35 <conal> Heffalump: i also wonder whether the "semantic ADT" view of IO contradicts important and common compiler optimizations.
13:26:38 <Heffalump> conal: I must have missed whatever statement you were replying to
13:26:39 <int80_h> I thought there was a function called sum. I looked for it in the index of RWH, and couldn't find it. Came to the wrong conclusion that it didn't exist
13:26:41 <sm> right, (+) needs two arguments
13:26:41 <byorgey> int80_h: and by the way, when ghc suggests that you add some complicated looking instance or other, that's usually NOT the solution =)
13:27:04 <byorgey> @src sum
13:27:04 <lambdabot> sum = foldl (+) 0
13:27:06 <conal> Heffalump: i also don't know how to implement unamb (or even pmin) with por.
13:27:34 <pumpkin> saml: zipWith id f ? :P
13:27:38 <Heffalump> conal: can you give an example? My intuition is that it won't.
13:27:42 <sm> int80_h: I'd keep hoogle and/or hayoo open, and probably the Prelude haddock page
13:27:45 <Heffalump> (re compiler optimizations)
13:27:58 <byorgey> ray: foldr (+) 0 also works, but it's needlessly lazy, since it has to get all the way through the list before it starts adding things from right to left.
13:27:59 <conal> Heffalump: of compiler optimization?
13:28:06 <saml> what's funcall?
13:28:11 <saml> > zipWith apply (map (+) [1..5]) [5..1]
13:28:13 <lambdabot>   Not in scope: `apply'
13:28:18 <byorgey> foldl is needlessly lazy too, we should really have sum' = foldl' (+) 0
13:28:18 <Heffalump> yes
13:28:31 <byorgey> saml: ($)
13:28:35 <byorgey> saml: or id
13:28:41 <sm> int80_h: and if you'd written a type signature for sumThem, you'd have got an easier error message, so that's always something to try
13:29:20 <byorgey> saml: also, note that [5..1] is the empty list.
13:29:22 <saml> > zipWith (\f x -> f x) (map (+) [1..5]) [5..1]
13:29:23 <lambdabot>   []
13:29:26 <byorgey> saml: you probably mean [5,4..1]
13:29:30 <saml> oh shit
13:29:34 <byorgey> =)
13:29:40 <saml> > zipWith id (map (+) [1..5]) [5,4..1]
13:29:40 <Heffalump> conal: I'd expect that the model would block reasoning about the primitives of IO and how they relate to each other.
13:29:41 <lambdabot>   [6,6,6,6,6]
13:29:41 <Gracenotes> hm, it seems the Google Maps van ran over a deer -- http://blog.pengxiao.net/2009/01/google-van-hits-deer/
13:29:47 <saml> yay 666666666666666666666666
13:29:48 <Heffalump> But it shouldn't block (say) applying the monad laws.
13:29:56 <pumpkin> saml: devil!
13:30:14 <conal> Heffalump: me too.  even the monad identity law would fail.
13:30:44 <Heffalump> the ADT I'm thinking of would be invariant under the monad laws
13:30:47 <conal> Heffalump: let alone lots of other optimizations.
13:31:11 <conal> Heffalump: okay.  then the many traditional optimizations beyond the (trivial) monad laws.
13:31:30 <Heffalump> those would be fine as they apply to pure computations
13:31:51 <Heffalump> can you give an example of a traditional optimization that you want to apply to the IO primitives? I guess reasoning about IORefs would be nice.
13:32:43 <conal> Heffalump: code motion that rearranges effectful but non-interfering computations so as to use registers more economically.
13:32:44 <Heffalump> I think it might be possible to give a better semantics than just "ADT equality" to some fragments (e.g. IORefs)
13:33:16 <Gracenotes> @instances MPlus
13:33:17 <lambdabot> Couldn't find class `MPlus'. Try @instances-importing
13:33:19 <conal> Heffalump: do you have an IO model in mind?  e.g., [String]?
13:33:23 <Gracenotes> @instances MonadPlus
13:33:24 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
13:33:36 <Heffalump> do you mean for the IORefs fragment?
13:33:38 <conal> Heffalump: where the strings describe actions somehow.
13:33:49 <conal> Heffalump: the whole enchilada
13:33:51 <Heffalump> I was thinking of something typed, with functions in it.
13:34:54 <conal> Heffalump: if there were some such complete and functional model and it has equality, even if undecidable, and if execution (probably via compilation) were based entirely on that model, then I think that'd answer my original question.
13:35:09 <conal> of "what does referentially transparency mean for IO"
13:35:22 <Heffalump> "were based" or "could be based"
13:35:22 <conal> Heffalump: which is sounding more plausible to me now.
13:35:26 <Heffalump> we could define an interpreter for it
13:35:27 <mmorrow> conal: those are interesting questions
13:36:10 <benmachine> so guys, ghc's option syntax is confusing me
13:36:16 <Heffalump> "were based" or "could be based" should have had a question mark after it
13:36:17 <conal> Heffalump: nice distinction. :)  if there were a really convincing argument that compilation "could be based".  one such argument is if it "were based"
13:36:21 <conal> mmorrow: thx :)
13:36:26 <benmachine> especially given that it feels the need to create three files only one of which I am interested in
13:36:38 <benmachine> I can't see how to specify the name for the .o file
13:36:47 <benmachine> or to specify the I don't care about .o files option
13:37:10 <ksf> ***** today on #haskell: ksf in mortal combat against existential quantification. Which one will have its mind bended?
13:37:11 <conal> mmorrow: "The beautiful answer is always proceeded by the more beautiful question." - e.e. cummings
13:37:32 <pumpkin> benmachine: they're just a product of compilation, it could stick them in a temp folder but why?
13:37:40 <ksf> s/against/with
13:37:46 <Heffalump> data IO a where PutChar :: Char -> IO () ; GetChar :: IO Char ; Value :: a -> IO a ; Bind :: IO a -> (a -> IO b) -> IO b ; ...
13:37:58 <Heffalump> with return and (>>=) being careful to apply the monad laws as they go
13:38:18 <benmachine> pumpkin: well, I'd like to keep them somewhere tidy at least
13:38:35 <conal> Heffalump: that's a fragment, right?
13:38:40 <Heffalump> of course, hence the ...
13:38:44 <benmachine> I tried using -odir but it seems to put Main.o in there
13:38:59 <Heffalump> but it seems to me obvious how to fill them in, if we know what the primitives, and with some solution for FFI that might be a bit more fiddly
13:39:00 <benmachine> if I want to use the same dir for several programs they think they're the same one?
13:39:06 <conal> Heffalump: even with the ..., it's a fragment.
13:39:10 <Heffalump> why?
13:39:19 <pumpkin> benmachine: maybe -outputdir ?
13:39:32 * benmachine doesn't see it in the man page
13:39:42 <pumpkin> that's where I found it
13:39:43 <conal> Heffalump: i'm making an assumption that you're not extending the language to allow infinitely many ctors per data type.
13:39:46 <pumpkin> but I have 6.10
13:39:47 <benmachine> but, I want to control the filename as well as the directory
13:39:54 <benmachine> 6.8.2
13:40:00 <pumpkin> benmachine: how will it know which .o to find given a module name then?
13:40:09 <Heffalump> well, since this is just a thought experiment, I don't see why I shouldn't, but why would I need to? FFI?
13:40:27 <benmachine> hmm? perhaps I don't understand the purpose of .o files
13:40:35 <pumpkin> benmachine: they're what the compiler outputs
13:40:45 <benmachine> well the compiler outputs three things
13:40:47 <pumpkin> the actual runnable program is the linker taking various .o files and sticking them together
13:40:57 <benmachine> oh, yes right
13:41:04 <benmachine> except I only have one because it's a small program
13:41:09 <benmachine> my problem is that
13:41:16 <conal> Heffalump: yeah.  one of the strengths of the monadic model of IO (contrasted with at least some of the others) is that it's an infinite pit.  it can swallow up everything we think of dumping in.
13:41:23 <benmachine> I'm using make
13:41:35 <benmachine> it runs these two commands for my two programs
13:41:36 <benmachine> ghc -W -hidir build/if -odir build/obj -o build/one one.hs
13:41:36 <benmachine> ghc -W -hidir build/if -odir build/obj -o build/two two.hs
13:41:36 <benmachine> compilation IS NOT required
13:41:59 <Heffalump> I think it's ok to model FFI by using String for the name of the foreign thing (appropriately qualified to guarantee that it really identifies it fully), along with some infrastructure so we can provide the right type
13:42:07 <benmachine> it seems that ghc thinks it's compiled the second one already because the .o and .hi file targets have the same names (despite the fact that the -o points to a different one)
13:42:15 <benmachine> and hence I get two of the same program
13:42:28 <benmachine> it just links the first one again
13:42:34 <Heffalump> in fact we could do that for every primitive if we chose to
13:42:35 <dcoutts> benmachine: do they define the same module?
13:42:54 <adept> Strange q. about FFI: I have C function which is completely defined in header file as "static inline" and referenced in my .hs. GHC 6.8 builds the package, inlining (as far as I can see) function in the .o of the Haskell module. GHC 6.10 does not inline function - nm lists it as 'U' in Haskell module .o. Bug in GHC 6.10?
13:42:57 <conal> Heffalump: makes sense to me.  if GHC doesn't know about it, it won't transform it.
13:42:57 <BMeph> benmachine: I thought -o was the option to name the executable. :)
13:43:16 <benmachine> BMeph: yeah it is, seemingly
13:43:18 <dcoutts> benmachine: if one and two define the same module then their .hi files will clash
13:43:20 <benmachine> dcoutts: http://benmachine.net/~ben/haskell/euler/one.hs
13:43:20 <defun> hi. I am trying to install hgalib from cabal. I get this error: (http://pastebin.com/f7b498d07). Why? And how do I fix it?
13:43:27 <Heffalump> and then for the bits we can model better, like IORefs, we can put them in the datatype properly and have some laws and things
13:43:33 <benmachine> that's one of the progrms
13:43:41 <augustss> adept: 6.8 goes via C for FFI, 6.10 doesn't
13:43:42 <benmachine> ams
13:44:05 <BMeph> defun: I see no file there. :)
13:44:18 <defun> You mean the link is bad?
13:44:23 <adept> augustss: aha. So, when I end up without this function in my .o's at all, this is definitely GHC bug?
13:44:32 <augustss> adept: try compiling the file with -fvia-C
13:44:34 <conal> Heffalump: sounds good.
13:44:39 <BMeph> defun: NM, I linked the paren in. :p
13:44:52 <dcoutts> defun: seems to be having trouble deleting the temporary directory. Is that Windows? Or NFS perhaps?
13:44:54 <Heffalump> does this mean you're now happy with the claim that IO is referentially transparent? :-)
13:44:57 <augustss> adept: well, it's a feature
13:45:10 <defun> No, it is solaris on zfs.
13:45:12 <adept> augustss: feature?
13:45:24 <conal> Heffalump: certainly not.  just that we could redefine it so that the claim has a meaning.
13:45:34 <adept> augustss: hm. Checked my .cabal - I already have -fvia-C
13:45:35 <Badger> conal: right now of course I have the dreaded IORefs. :)
13:45:38 <dcoutts> defun: can you check the content of that directory check if there are any remaining files, eg hidden one
13:45:46 <defun> one sec.
13:45:47 <conal> Badger: ??
13:45:48 <augustss> adept: ghc interfaces with an ABI not an API
13:46:04 <conal> Heffalump: assuming that IO were used only through that interface.
13:46:21 <conal> Heffalump: i.e., that no one routed around the semantic model.
13:46:22 <Heffalump> but now we just have to prove that any Haskell implementation behaves in an equivalent fashion
13:46:51 <Heffalump> which should be no harder than proving that the implementation is correct in lots of other ways
13:46:52 <adept> augustss: you've lost me here
13:47:29 <conal> Heffalump: we do (have to prove ...)?
13:47:30 <defun> No, nothing in /tmp/TMPhgalib-0.2.  Empty.
13:47:38 <augustss> adept: ghc uses a binary interface to talk to C, not the source level interface
13:47:40 <defun> Perhaps it did install?
13:47:43 <erikc> adept: it works by coincidence with -fvia-C because it includes your header in the generated C file and the C compiler handles the inlining
13:47:50 <vixey> you found an ADT for IO?
13:48:05 <Heffalump> vixey: IMO, we just stated the obvious one.
13:48:21 <adept> erikc: ah. so it works with ghc 6.8 by lucky chance
13:48:23 <augustss> adept: it's not a bug, it's a design choice.  one you might not like.
13:48:24 <benmachine> hurrah, I now get different numbers from my program
13:48:30 <vixey> I know how to give a domain that identifies beta equal terms in haskell
13:48:33 <Heffalump> conal: well, we have to if we want to show that it really is referentially transparent.
13:48:39 <vixey> Did you find something similar for IO wrt. monad laws
13:48:57 <Heffalump> monad laws are easy, you don't need full beta equality
13:48:58 <benmachine> however I still can't seem to control the .o filename, fortunately it doesn't at this stage seem to matter
13:48:59 <adept> augustss: so my best shot is to move C code to .c and drop the "inline"?
13:48:59 <Gracenotes> > let inBounds a b = a > b in not inBounds 2 5
13:49:00 <erikc> adept: yup, supporting it with the native backend would require GHC to parse + generate code for the C function
13:49:00 <lambdabot>   Couldn't match expected type `Bool'
13:49:13 <augustss> adept: It changed from 6.8 to 6.10.  The FFI spec is not quite clear about which it should be.
13:49:16 <Heffalump> you can just (e.g.) apply a smart constructor that reassociates
13:49:40 <augustss> adept: for the long run, yes.  But for now you could try with -fvia-C
13:49:56 <defun> yes, it seems to be installed in the lib directory.
13:50:31 <erikc> given the hoop jumping you have to do to get across the language barrier, the inlining isnt going to matter anyway
13:50:46 <augustss> very true
13:50:55 * Gracenotes should probably make Monster a typeclass, instead of an ADT
13:50:58 <skorpan> general computability question... does a language need some loop mechanism to be turing complete?
13:51:21 <pumpkin> erikc: I have a plan for a low-level binary lib that would sit on top of yours!
13:51:27 <hugo___> hello
13:51:35 <hugo___> are there any interpolator package for haskell ?
13:51:38 <erikc> pumpkin: ooo, fun, what kind of lib?
13:51:38 <adept> augustss: I already doing it with -fvia-C - does not help
13:51:40 <pumpkin> interpolator?
13:51:40 <augustss> skorpan: for a suitable definition of loop :)
13:51:43 <hugo___> yes
13:51:50 <vixey> Gracenotes, huh?
13:51:51 <pumpkin> erikc: the objc abi! both the new and the old one :D
13:52:00 <augustss> adept: oh, ok.  i thought it might
13:52:02 <hugo___> like linear interpolation, spline, cubic, etc... between two numbers ?
13:52:20 <erikc> pumpkin: which part of the abi?
13:52:46 <erikc> pumpkin: i have a somewhat dusty FFI binding to the objc runtime i need to finish
13:52:49 <pumpkin> well, all the structures that are stored on disk basically
13:52:52 <pumpkin> ah, not that
13:52:54 <Gracenotes> vixey: I could make the process-turn function dispatch based on pattern-matching the type of monster, but it seems to make more sense to just use typeclasses
13:52:55 <erikc> oh right, the metadata
13:53:21 <erikc> is that ABI standardized? from my reading it seemed like the only authorized way to read it is through the objc runtime library
13:53:31 <pumpkin> well, things like the static NSString representation, the general class structure, protocols, etc.
13:53:33 <Gracenotes> the only problem is that there would be extra types for every kind of monster, that I might not end up using outside of it being an instance of Monster
13:53:48 <int-e> adept: yes, static inline functions no longer work - it was a conscious choice by the ghc developers, to be consistent with the native code generator.
13:53:51 <defun> what is the _.hi extention for?
13:53:55 <pumpkin> erikc: nope, and it isn't documented, but it's pretty well understood
13:53:59 <erikc> ah, cool
13:54:06 <pumpkin> I wrote the first class-dump for objc2 in ruby
13:54:22 <erikc> oh, you wrote class-dump?
13:54:26 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1043#a1043 <-- where's my mistake?
13:54:28 <pumpkin> nope :P
13:54:33 <erikc> ah hehe
13:54:43 <pumpkin> but the author of class-dump never got around to updating it for the new ABI
13:54:54 <erikc> ah cool
13:54:54 <pumpkin> so I made a new one from scratch in (very ugly) ruby
13:54:57 <pumpkin> as a stopgap
13:55:03 <adept> int-e: so, I should drop static altogether?
13:55:48 <int-e> adept: if it's your C code, yes, I suppose you should. If it's foreign code, the best approach seems to write (non-static) wrapper functions and import those.
13:56:11 <ksf> BIELEFELD EXISTIERT GAR NICHT
13:56:44 <adept> int-e, augustss, erikc: thnx a lot
13:56:56 <ksf> ha! that proves it! ;)
13:57:00 <int-e> adept: http://www.mail-archive.com/cvs-ghc@haskell.org/msg07804.html is the commit in question
13:57:07 <pumpkin> who maintains haddock?
13:57:23 <pumpkin> or who has worked on it
13:57:36 <int-e> adept: (if you care)
13:57:43 <erikc> pumpkin: i hit a bit of a hitch with my "objh", there are so low level headaches, i basically gotta replicate what objc-python and macruby do using BridgeSupport
13:58:07 <pumpkin> erikc: you mean reimplement haskell datastructures as their objc counterparts?
13:58:17 <pumpkin> that sounds unpleasant if it's the case
13:58:49 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1043#a1043 <-- is the problem that the existential is scope-bound to the right branch?
13:59:04 <R-A-F> u dont believe it man
13:59:05 <R-A-F> lÃ¶l
13:59:06 <erikc> oh, no, but i gotta use bridgesupport to generate ffi data from frameworks/headers so that the haskell code can use the C data types easily
13:59:06 <R-A-F> http://www.unsere-nackte-pyjamaparty.net/?id=9362243
13:59:19 <pumpkin> erikc: oh I see
13:59:40 <erikc> messaging between objects is easy, but since objects can take C structs by value, or reteurn C structs by value, its an ABI issue
13:59:42 --- mode: ChanServ set +o Heffalump
13:59:58 <pumpkin> erikc: what would be really neat would be to be able to lazily wrap a list in an NSArray-like interface, for example, to pass to cocoa :P
14:00:01 <erikc> e.g. there are different sendMsg runtime functiosn depending on if a float/struct/int is returned, so you gotta know the return type of any message you send :\
14:00:06 --- mode: Heffalump set +b *!n=Jon@bie.dhcp.studentenwerk-bielefeld.de
14:00:23 <erikc> if everything just dealt with object pointers, it'd be a lot easier :)
14:00:35 <pumpkin> yeah :)
14:00:47 <pumpkin> but making an NSHaskellList that had all the same methods as NSArray
14:00:58 <pumpkin> could be kinda neat :P
14:01:10 <pumpkin> and an NSHaskellMap with all the NSDictionary methods
14:01:59 <pumpkin> I guess if they tried to make changes you'd run into issues
14:03:11 <defun> is the libdir created by cabal supposed to be populated by _.hi (haskell interface) files?
14:04:49 <dcoutts> defun: yes, and the libHSfoo.a
14:04:56 <sbahra> How serious is Data.Map's overhead?
14:05:07 <dcoutts> sbahra: memory overhead?
14:05:10 <sbahra> Does it make sense to use it for something that is 10/20 items?
14:05:12 <sbahra> dcoutts, time.
14:05:20 <Heffalump> overhead compared to what?
14:05:47 <sbahra> Heffalump, hold on
14:05:50 <dcoutts> sbahra: if you compare it to a list say, I expect the overhead is pretty low
14:06:00 <sbahra> I was going to say list, but let me find a better suited data structure.
14:06:28 <ksf> come on, someone help me with my existential crisis.
14:06:31 <sbahra> Let's say to StorableVectors.
14:06:47 <dcoutts> sbahra: in that case you'd compare to an IntMap of course
14:07:05 <dcoutts> since to compare to an array type your index is necessarily integral
14:07:29 <sbahra> Yes.
14:07:33 <dcoutts> (unless you're doing binary search on the values in your storable array)
14:07:34 <sbahra> I'll have to modify my type a bit.
14:08:03 <defun> dcoutts: thanks.
14:08:14 <sbahra> dcoutts, well, binary search on 10/20 items is pretty fast on an array in C (on most computers), for example. I would not be using a tree.
14:08:23 <sbahra> s/binary search/linear search/
14:08:34 <sbahra> dcoutts, since they'll all be packed on the same cache line hopefully.
14:08:58 <dcoutts> sbahra: comparing an intmap to an array really requires a test, it's hard to quantify otherwise.
14:09:05 <sbahra> dcoutts, :(
14:09:14 <sbahra> Ok, if I end up implementing both I'll let you guys know the results
14:09:16 <osfameron> evening
14:09:20 <osfameron> if I have:  newtype Node = Node (Map String Node)
14:09:25 <osfameron> how do I use that? ;-)
14:09:39 <conal> Heffalump: thanks for that conversation about IO, ADTs & semantics.  i didn't see how the pieces could fit together before.
14:09:44 <vixey> osfameron, what do you want to use it for?
14:09:46 <Heffalump> osfameron: what's the difficulty?
14:09:47 <osfameron> M.insert "foo" (Node M.empty) (Node M.empty)   <-- gives me a type error
14:10:00 <dcoutts> sbahra: but I'm not sure it makes a lot of sense to compare because if you can use an array then you would.
14:10:01 <BONUS> do
14:10:02 <osfameron> Couldn't match expected type `Map [Char] Node' against inferred type `Node'
14:10:06 <Heffalump> conal: it's kind of a null semantics, but I still think it's enough to demonstrate referential transparency
14:10:11 <dcoutts> sbahra: you'd use an IntMap if your int keys were not dense
14:10:12 <SamB_irssi> so how come we can't use IntMap with every Ix instance ?
14:10:30 <sbahra> dcoutts, what algorithm does IntMap implement?
14:10:46 <conal> Heffalump: agreed.  just enough to put solid ground under the referential transparency claim.
14:10:50 * SamB_irssi supposes because there is no unIndex member in Ix
14:11:07 <osfameron> vixey, Heffalump: e.g. I thought newtype could be used the same way as the aliased type, but I clearly don't understand what to do with it
14:11:10 <dcoutts> sbahra: it's one of those trees that follows the binary structure of the number
14:11:12 <Heffalump> SamB_irssi: (Ix a, Bounded a) should be enough
14:11:18 <dcoutts> sbahra: I'd have to look up the name
14:11:21 <sbahra> dcoutts, does it have a name?
14:11:23 <sbahra> dcoutts, ok.
14:11:24 * SamB_irssi guesses you could approximate this with range ...
14:11:27 <vixey> osfameron, well if you don't know what to use this thing for just delete it
14:11:28 <Heffalump> osfameron: what to do with it in what sense?
14:11:30 <sbahra> Don't worry about it, I'll find the name.
14:11:34 <sbahra> Thanks dcoutts
14:11:37 <dcoutts> sbahra: the docs should say
14:11:47 <int80_h> @sum
14:11:47 <lambdabot> Maybe you meant: bug run src
14:11:53 <int80_h> @src sum
14:11:53 <lambdabot> sum = foldl (+) 0
14:11:55 <pumpkin> isn't it just a trie?
14:12:03 <sbahra> sounds like it
14:12:10 <sbahra> but "just a trie" isn't good ;-p
14:12:15 <osfameron> vixey Heffalump: I understood I need a newtype alias, becuase the Node is recursive (the values are Nodes again).  But I don't understand how to use it as a Data.Map
14:12:16 <pumpkin> why not?
14:12:25 <sbahra> Because it doesn't mean much.
14:12:33 <pumpkin> well, a trie on the bits
14:12:34 <vixey> osfameron, with, newtype Node = Node (Map String Node)
14:12:42 <vixey> osfameron,  Node :: Map String Node -> Node
14:12:48 <dcoutts> pumpkin: yes, that's what it is, roughly.
14:12:48 <Heffalump> well, the leaves have to be Map.empty
14:13:00 <Heffalump> or you have to build a recursive structure
14:13:07 <Heffalump> but either of those are eminently possible
14:13:18 <vixey> :k Mu (Map String)
14:13:19 <lambdabot> Not in scope: type constructor or class `Map'
14:13:19 <osfameron> yeah, that's the newtype definition I have
14:13:23 <vixey> :k Mu (Data.Map String)
14:13:24 <lambdabot> Couldn't find qualified module.
14:13:28 <vixey> , Mu (Data.Map String)
14:13:29 <lunabot>  luna: Not in scope: data constructor `Data.Map'
14:13:36 <Heffalump> :k Mu (Data.Map.Map String)
14:13:37 <osfameron> but I can't insert anything into a Node
14:13:37 <lambdabot> *
14:13:53 <Heffalump> osfameron: you can, you can insert (String, Node) pairs
14:14:41 <int80_h> so, I want to build a list comprehension that has two filters
14:14:53 <SamB_irssi> int80_h: comma is your friend
14:14:57 <Heffalump> conal: btw Cale likes to push the ADT model of IO as a way of explaining it to newbies, so you should discuss it with him too :-)
14:14:57 <pumpkin> or just &&
14:15:03 <int80_h> all numbers [1..1000] that are either a multiple of 3 or 5
14:15:05 <pumpkin> but comma is nicer
14:15:11 <vixey> filter p . filter q = filter (lub p q)
14:15:12 <pumpkin> int80_h: this sounds strangely familiar :P
14:15:14 <Heffalump> int80_h: use || for that
14:15:14 <int80_h> ah, I misapplied the comma, okay let me try it again
14:15:33 <int80_h> I tried ||, must have misapplied
14:15:35 <Heffalump> [n | n <- [1..1000] | n `mod` 3 == 0 || n `mod` 5 == 0]
14:15:44 <BMeph> pumpie: PE #1. :)
14:15:47 <Heffalump> sorry, , not | in the second |
14:15:57 <int80_h> huh?
14:16:06 <Heffalump> [n | n <- [1..1000] , n `mod` 3 == 0 || n `mod` 5 == 0]
14:16:11 <osfameron> Heffalump: so I should be able to do:  M.insert "key" node1 node2  ?
14:16:17 <conal> Heffalump: thx.  btw, one of my unconscious confusions that got cleared up was that we only need definable equality, not decidable.
14:16:19 <Heffalump> osfameron: yes
14:16:50 <Heffalump> conal: ah :-) if we needed decidable equality then functions wouldn't be referentially transparent either
14:17:00 <conal> Heffalump: yeah!
14:17:17 * Heffalump still wants to read about conal's IO-replacing vision
14:17:20 <osfameron> Heffalump: but this gives a type error:  let node1 = Node M.empty; node2 = Node M.empty; in M.insert "key" node1 node2
14:17:29 <Heffalump> @type Data.Map.insert
14:17:30 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
14:17:46 <Heffalump> osfameron: you need to unwrap the Node for the node2 argument
14:18:14 <Heffalump> use newtype Node = Node { unNode :: Map String Node } for convenience
14:18:16 <drigz_> probably obvious, but is there a nop :: IO ()?
14:18:24 <byorgey> drigz_: return ()
14:18:25 <Heffalump> then Node $ M.insert "key" node1 (unNode node2)
14:18:42 <int80_h> pumpkin: this is problem 1, project Euler
14:18:55 <drigz> byorgey: of course. i'm still thinking in the 'return means leave the function' mindset...
14:19:00 <drigz> byorgey: thank you
14:19:00 <osfameron> Heffalump: why do I only need to unwrap node2 and not node1 ?
14:19:09 <pumpkin> yeah, was just being silly :)
14:19:10 <Heffalump> because node1 is the map member, which is of type Node
14:19:10 <byorgey> drigz: heh, right.  you're welcome.
14:19:17 <BMeph> pimpkon: Heh-heh. ;)
14:20:14 <osfameron> ah, thanks
14:20:20 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1043#a1043 <-- am I attempting the impossible?
14:20:32 <dobblego> @type filter
14:20:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:20:39 <dobblego> int80_h, ^^
14:21:41 <vixey> drigz, don'tReturn = return -- if that makes anything easier lol
14:21:50 <vixey> do ... ; don'tReturn x
14:21:57 <pumpkin> lol
14:21:58 <drigz> vixey: :D
14:22:16 <dobblego> do cancels don't leaving only return
14:22:28 <int80_h> dobblego: huh?
14:22:30 <pumpkin> ?
14:22:33 <vixey> O_o
14:22:45 <dobblego> int80_h, filter, you want filter :)
14:22:46 <pumpkin> you do scrambler word have?
14:22:54 <int80_h> @src filter
14:22:54 <lambdabot> filter _ []     = []
14:22:54 <lambdabot> filter p (x:xs)
14:22:54 <lambdabot>     | p x       = x : filter p xs
14:22:54 <lambdabot>     | otherwise = filter p xs
14:23:43 <int80_h> dobblego, it looks like my list comprehension is right, but the sum seems to be wrong. Okay I'll try filer
14:23:49 <int80_h> filter
14:23:56 <Baughn> I've got a program (xmobar..) that crashes on startup, with an user exception. Can I have ghci stop print a backtrace of that, at least?
14:24:04 <int80_h> sum [n | n <- [1..1000] , n `mod` 3 == 0 || n `mod` 5 == 0]
14:24:13 <dobblego> int80_h, you want to run sum on the result
14:24:13 <tromp__> :t foldr
14:24:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:24:16 <int80_h> ^^ that yields the wrong answer, according to Project Euler
14:24:27 <Heffalump> what is the problem statement?
14:24:43 <int80_h> http://projecteuler.net/index.php?section=problems&id=1
14:25:05 <drigz> int80_h: below 1000
14:25:06 <int80_h> find the sum of the multiples of 3 or 4 for all integers 1..1000
14:25:10 <Gracenotes> try 999
14:25:13 <ksf> data EitherEvent = forall a . X.Event a => RightE a | LeftE SomeEvent
14:25:16 <pumpkin> int80_h: you included 1000 :)
14:25:16 <int80_h> ah!
14:25:27 <drigz> int80_h: you have too little confidence in your haskell!
14:25:30 <ksf> how do I get the existential to scope both branches? I guess that's the problem.
14:25:32 <Gracenotes> when mathematicians say below, they mean below ;)
14:25:39 <pumpkin> and the answer is!!!
14:25:42 <Gracenotes> most of the time anyway
14:25:44 <pumpkin> 1
14:25:46 <vixey> @let n `divides` d = n `mod` d == 0
14:25:47 <lambdabot>  Defined.
14:25:58 <vixey> did I get the argument order wrong.....
14:26:02 <pumpkin> vixey: isn't that d `divides` n ?
14:26:03 <pumpkin> yeah
14:26:20 <vixey> d | n <=> exists k, dk = n  ?
14:26:24 <Gracenotes> not many languages have a "divides" function, as has as I can tell
14:26:28 <Gracenotes> *far
14:26:36 <Gracenotes> it can be useful
14:26:37 <pumpkin> az haz az
14:26:40 <seafood> mae, Saizan: I see you're working on a web stack based on HappS.
14:27:08 <vixey> can be implemented in Mathematica as
14:27:08 <vixey>   Divides[a_, b_] := Mod[b, a] == 0
14:27:23 <baaba> vixey, isn't that the other way around?
14:27:25 <int80_h> 233168
14:27:36 <Gracenotes> *gasp*
14:27:39 <int80_h> drigz: yeah I'm working on that
14:27:42 <Gracenotes> this IRC can never be published!
14:27:47 <baaba> exists k, d = nk :P
14:27:47 <Gracenotes> never ever ever!
14:27:50 <vixey> baaba, it's a good day if I can tell up from down
14:27:51 <pumpkin> quick, scrub the logs!
14:27:55 <baaba> ;)
14:28:11 <Gracenotes> no one may ever see this log, containing the most-answered Euler question solution!
14:28:12 <SamB_irssi> at least it isn't clearly identified
14:28:14 <BONUS> yo, anyone wanna take a crack at this http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1044#a1044
14:28:15 <BONUS> :]
14:28:21 <Heffalump> ksf: what's Expose?
14:28:36 <Gracenotes> ermv.
14:28:45 <ksf> Heffalump, an Event.
14:28:50 <ksf> X.Event, that is.
14:28:55 <Heffalump> I'm a bit lost.
14:29:03 <ksf> (i'm not responsible for that name clash)
14:29:09 <Heffalump> But it seems like you want to insist that a = Expose
14:29:15 <Heffalump> when clearly the existential says it can be any X.Event
14:29:16 <ksf> yeah.
14:29:49 <Heffalump> I don't understand the type error either, surely it should complain that Expose is not a
14:29:58 <SamB_irssi> ksf: that name clash happens a lot
14:29:58 <ksf> well... I want to splice the stream into different handlers, ignoring Events they don't understand, but passing them through.
14:30:06 <BONUS> basically when i try to populate a trie with 100k words, it works, but when i do it with 1 million words, i get a stack space overflow
14:30:12 <Heffalump> ok, so you want to match on specific types?
14:30:20 <Heffalump> if so, you do need Typeable.
14:30:33 * SamB_irssi tries to remember if GHC stacks can be examined in GDB
14:30:36 <ksf> that's what fromEvent and toEvent does.
14:30:49 <BONUS> im not sure where the stack gets filled here
14:30:52 <Heffalump> but it needs to be a superclass of X.Event
14:30:59 <Heffalump> your problem is with RightE, not with LeftE.
14:31:09 <ksf> ...that's SomeEvent.
14:31:55 <Heffalump> ksf: and you actually need to use fromEvent and toEvent in the definition of g
14:32:18 <int80_h> @hoogle fib
14:32:18 <lambdabot> No results found
14:32:25 <ksf> Heffalump, that's what I'm trying to avoid.
14:32:38 <Heffalump> I don't see how you can.
14:32:49 <Heffalump> You want to do type-based dispatch. That requires Typeable and its methods.
14:33:06 <ksf> right now, I'm changing EitherEvent to take an argument.
14:33:28 <ksf> ...but that won't work.
14:33:47 * Heffalump is off to bed
14:37:08 <ztirF> @pl \x -> x***x
14:37:08 <lambdabot> join (***)
14:38:06 <int80_h> @src !!
14:38:06 <lambdabot> xs     !! n | n < 0 = undefined
14:38:06 <lambdabot> []     !! _         = undefined
14:38:06 <lambdabot> (x:_)  !! 0         = x
14:38:06 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:38:31 <int80_h> is !! the factorial operator?
14:38:46 <Tobsan> ne
14:38:48 <idnar> no, it's the list subscript operator
14:38:57 <idnar> > [1..10] !! 5
14:38:58 <lambdabot>   6
14:39:23 <int80_h> gotcha
14:39:25 <Tobsan> > [[1..10]] !! 5 !! 5
14:39:26 <lambdabot>   * Exception: Prelude.(!!): index too large
14:39:27 <Baughn> > [0..]  !! 49172
14:39:28 <lambdabot>   49172
14:39:29 <Tobsan> hmm
14:39:40 <idnar> Tobsan: [[1..10]] is a list of one element
14:39:49 <Tobsan> idnar: ah, right
14:40:31 <ray> > [[1..10],[2..11]..[10..20]] -- probably doesn't work
14:40:32 <lambdabot>       No instance for (Enum [t])
14:40:32 <lambdabot>        arising from the arithmetic sequence ...
14:40:32 <int80_h> oh I've done it now, I'm computing 4 million fibonacci numbers
14:41:02 <ray> also, 10..19
14:41:09 <Baughn> ..that'll never finish. And if it did, the final number wouldn't fit in memory.
14:41:16 <vixey> > [(1..10),(2..11)..(10..20)]
14:41:17 <lambdabot>   <no location info>: parse error on input `..'
14:41:24 <vixey> > [(1,10),(2,11)..(10,20)]
14:41:25 <lambdabot>       No instance for (Enum (t, t1))
14:41:25 <lambdabot>        arising from the arithmetic seque...
14:41:47 <Baughn> > last [1.]
14:41:47 <lambdabot>   <no location info>: parse error on input `]'
14:41:49 <int80_h> hmm, may have misunderstood the spec
14:41:53 <Baughn> > last [1..]
14:42:00 <ray> thread killed
14:42:12 <lambdabot>   mueval: Prelude.read: no parse
14:42:19 <ray> hrm
14:51:34 <vixey> V = (V â†’s V) âŠ• Î£c VâŠ—ar(c)
14:51:38 <vixey> what does that mean ?
14:51:58 <saml> i think it's recursive
14:52:18 <ddarius> presumably all that notation is defined somewhere
14:52:24 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1043#a1045 <-- rationale: don't use existentials if you haven't tried not using them, first.
14:53:37 <ddarius> If I was going to guess, I'd say it meant that V is the disjoint sum of the set of strict endofunctions on V and the sum of the power of V to the arity of a constant symbol c.
14:55:31 <BONUS> hmm, you guys think it's ok if i post my problem with the stack overflow to haskell-cafe?
14:55:39 <BONUS> or should i use some other haskell mailing list
14:56:06 <ksf> the cafe is fine for code questions.
14:56:09 <augustss> vixey: looks like a domain equation
14:56:19 <BONUS> ah ok
14:56:45 <BONUS> i've got 18 lines of code that demonstrate the data structure and stuff, should i include them in the mail or should i link to a moonpatio paste
14:56:52 <ksf> ...it's bound to be considerably more on topic than the average post.
14:57:18 <ksf> 18 are fine to do inline.
14:57:46 <ksf> If in doubt, attach them.
14:58:01 <ksf> ...as inline text or such.
14:58:08 <BONUS> ah cool thanks
14:59:02 <Philippa_> if it's >100 lines and you're not treating it as literal haskell then you might want to think about it going in the mail
14:59:14 <Philippa_> otherwise the question's whether it's the best presentation of what you're talking about
15:00:59 <ksf> inline text attachments have the advantage that you can dump them into a file without copy&paste.
15:01:46 <ztirF> sorry if this is a dumb question but why isn't IArray i a an instance of Num ?
15:02:03 <roconnor> @src Num
15:02:03 <lambdabot> class  (Eq a, Show a) => Num a  where
15:02:03 <lambdabot>     (+), (-), (*)           :: a -> a -> a
15:02:03 <lambdabot>     negate, abs, signum     :: a -> a
15:02:03 <lambdabot>     fromInteger             :: Integer -> a
15:02:12 <ksf> I've got no idea what's the maximum size of an email is these days, I'm still keeping them <10k or such.
15:02:14 <ztirF> they all make sense except signum
15:02:19 <roconnor> ztirF: fromInteger is a bit tricky
15:02:37 <ztirF> hmm
15:02:49 <ztirF> you can do it with scoped type variables I bet
15:03:00 <roconnor> ztirF: I think there is no obvious single choice for some of these functions.
15:03:26 <roconnor> ztirF: you are welcome to make an instance, although I recommend wrapping in a newtype first.
15:03:33 <ztirF> roconnor: in array programming languages such as IDL or Fortran 90, the conventions are well established
15:03:59 <roconnor> ztirF: I would make signum pointwise
15:04:15 <roconnor> and probably make formInteger "pointwise" as well
15:04:27 <augustss> All of the pointwise makes good sense
15:04:35 <augustss> s/the/tehm/
15:04:40 <roconnor> ya
15:04:42 <augustss> s/tehm/them/
15:04:54 <roconnor> I'm almost inclined to drop the newtype wrapper
15:05:21 <int80_h> [ x | x <- fibs, even x, x <= 4000000]
15:05:33 <ztirF> then if you define dist, indgen etc. you get all of the IDL array goodness in Haskell
15:05:40 <int80_h> this hangs at the last fib to meet the spec, 3524578
15:05:50 <augustss> ztirF: so do it
15:05:57 <ztirF> I will!
15:06:24 <int80_h> and fibs is fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:06:27 <augustss> int80_h: because it can't know fibs is monotonically increasing, so it has to keep looking
15:06:30 <dublpaws> q
15:07:32 <bodq> do you know a happy song about programming?
15:07:47 <augustss> int80_h: [ x | x <- takeWhile (<= 4000000) fibs, even x]
15:07:56 <roconnor> s/can't know/doesn't know/
15:08:08 <augustss> can't know
15:08:14 <int80_h> augustss thanks :)
15:08:19 <ddarius> filter even $ takeWhile (<= 4000000) fibs
15:08:22 <augustss> not as the language is defined
15:08:34 <roconnor> hmm
15:08:50 <augustss> or rather, even if it knows, it has to keep looping
15:09:02 <ski_> (bodq : "God wrote the world in Lisp" ?)
15:09:03 <ksf> if you splice a rope into one strand and the rest, what's the name of the rest?
15:09:04 <roconnor> "has to"
15:09:15 <ddarius> roconnor: Doing something else would change semantics.
15:09:16 <augustss> it's the semantics of haskell
15:09:31 <decafbad> bodq: http://www.gnu.org/fun/jokes/wonderful-code.html
15:09:57 <roconnor> ddarius: it wouldn't change the semantics of int80_h wants to do, so if he tells the compiler his intensions...
15:10:01 <ztirF> @src Fractional
15:10:01 <lambdabot> class  (Num a) => Fractional a  where
15:10:02 <lambdabot>     (/)             :: a -> a -> a
15:10:02 <lambdabot>     recip           :: a -> a
15:10:02 <lambdabot>     fromRational    :: Rational -> a
15:10:06 <roconnor> but I've had this discussion on cafe
15:10:11 <bodq> decafbad: omg it's horrible :)
15:10:19 <bodq> ski_: thanks! I like this one
15:10:29 * bodq feels better :)
15:10:46 <decafbad> bodq: I love that song (original song)
15:10:48 <ddarius> roconnor: He can tell the compiler his intentions by writing code that expresses them in the language the compiler understands.
15:10:59 <bodq> decafbad: I can't recognize it
15:11:15 <roconnor> ddarius: yes, with RULE pragmas and such
15:11:18 <augustss> roconnor: changing termination is clearly not semantics preserving
15:11:26 <ddarius> roconnor: Or more simply, with Haskell
15:12:06 <decafbad> bodq: wonderfull world, most known from louis armstrong. was in "good morning vietnam" soundtrack
15:12:17 <roconnor> augustss: it doesn't preserve the semantics of the represenatives, but represenatives are simply a tool for achiving the computation we really want with "constiutants".
15:12:29 <roconnor> constituents
15:12:30 <bodq> why doesn't haskell have a ghci -e 'print "hello"' mode?
15:12:36 <augustss> roconnor: I still don't understand what that means
15:12:39 <ddarius> bodq: It does.
15:12:40 <vixey> bodq, ghc
15:13:01 <roconnor> augustss: you understand the difference between CReal and actual (constructive) real numbers?
15:13:36 <augustss> how do you know that bottom is not what i'm after, that it is the constituant?
15:13:52 <roconnor> augustss: you have to tell the compiler
15:13:53 <bodq> ddarius: vixey: I have trouble discovering it
15:14:12 <ddarius> bodq: Write exactly what you did only write 'ghc' instead of 'ghci'
15:14:16 <bodq> oh
15:14:23 <bodq> me dumb
15:14:28 * bodq facepalm
15:14:28 <augustss> yes, and int80_h ask for bottom, and got it
15:15:38 <augustss> roconnor: and the difference between CReal and the constructive real numbers seems to assume I'm a platonist. :)
15:15:40 <roconnor> int80_h was trying to express himself in Haskell.  It was clear to me what he wanted, even though he didn't say it with his Haskell (and hence Haskell didn't fully grasp what he wanted)
15:16:12 <augustss> It was only clear to you because you heard his question.
15:16:23 <bodq> ddarius: bash quoting rules make it unpleasant :(
15:16:23 <roconnor> augustss: right.
15:16:39 <augustss> If I had written that code, and you ran my code, how could you tell it's not what I intended?
15:17:27 <BMeph> ztirF: Were I you, I'd look at how Complex is defined, (cry out in anguish,) and learn. ;)
15:17:49 <roconnor> augustss: CR_ (\_ -> 0) is the real number the (constructive) real number 0, but CR_ (\n -> 2^^(-n)) is also 0. CR_ (\_ -> 0) is not the same as CR_ (\n -> 2^^(-n))
15:18:15 <roconnor> so CR_ foo is a CReal, and what I wrote as 0 above is a constructive real number.
15:18:48 <roconnor> CReals are representatives and 0 is a constituent (for lack of a better term)
15:18:53 <augustss> I understand that CReal is an abstract type and the the particular concrete implementation of CReal has multiple values that are equivalent outside the abstraction barrier.
15:19:19 <ski_> s/constituent/equivalence class/ ?
15:19:38 <roconnor> ski_: more like a PER
15:19:44 <augustss> But you're talking about the implementation of CReal.  I like to view it as an abstract type with certain properties.
15:20:35 <bodq> decafbad: ghc -e 'interact $ unlines . filter (all (`elem` ['"'"a"'".."'"f"'"'])) . lines' < /usr/share/dict/words
15:20:39 <roconnor> augustss: but you wouldn't feel bad about (a + (b + 0)) being optimized to (a + b) ?
15:20:48 <ski_> roconnor : why no reflexivity ?
15:20:58 <decafbad> bodq: so?
15:21:01 <roconnor> augustss: because it changes the semantics of represenatives.
15:21:06 <mib_omr0x8dh> this is haskell university?
15:21:12 <pumpkin> yup
15:21:13 <bodq> decafbad: your nick sounded familiar
15:21:30 <mib_omr0x8dh> cool i know someone who goes to that university
15:21:41 <augustss> I wouldn't mind if the compiler can prove that they are equivalent in all context where the abstract value can be used
15:21:42 <decafbad> bodq: we talked about a song
15:21:49 * ksf just designed his first functor
15:22:01 <ksf> ...without trying to, that is.
15:22:01 <ozy`> mib_omr0x8dh: not exactly
15:22:05 <loadquo> ksf, what does it do?
15:22:07 <pumpkin> does it FUNCTion?
15:22:09 <bodq> decafbad: right that's when it happened :) it took me a while...
15:22:14 <ozy`> mib_omr0x8dh: haskell is a programming language
15:22:15 <ddarius> ksf: You've probably made tons of functors.
15:22:34 <ozy`> I'm sure they teach haskell in the computer science department of haskell university, though
15:22:36 <augustss> roconnor: but my hope for such a compiler is small :)
15:22:54 <ksf> it takes an input stream, splices off streams and joins them into an output stream.
15:22:55 <augustss> Haskell Indians!
15:23:04 <int80_h> ozy`: I heard they use VB.Net for their CS classes
15:23:26 <ozy`> int80_h: I just lost all the faith in humanity that was restored last week
15:23:28 * vixey hopes for a small (hackable) haskell compiler
15:23:36 <vixey> actually I don't really care that much
15:23:44 <int80_h> ozy` : my jokes are cruel ;)
15:23:51 <augustss> vixey: I don't see how a haskell compiler can be that small :)
15:23:54 <ksf> I noticed it's a functor by wanting to fmap over it :)
15:24:00 <ddarius> ozy`: Go read about X#
15:24:09 <roconnor> ski_: I think it may be necessary for some values in your type to have no constituent.  Eg to create types that represent the concept of non-zero real numbers.
15:24:18 <ozy`> ddarius: been there, got the <t-shirt/>
15:24:42 <vixey> there are t-shirts??
15:24:45 <roconnor> augustss: It is pretty easy to tell GHC to optimize (b + 0)::CReal to b::CReal.
15:25:07 <augustss> roconnor: yes, but I don't know what the semantics of RULES are.
15:25:14 <mib_omr0x8dh> so anyone at haskell U know anyone named martha wells?
15:25:19 <ski_> roconnor : i don't follow .. which type ? .. why is non-zero reals problematic ?
15:25:31 <ozy`> mib_omr0x8dh: you missed the part where this isn't haskell university....
15:25:45 <vixey> @vera university
15:25:46 <ozy`> mib_omr0x8dh: I'm sure she gives great head though
15:25:46 <lambdabot> No match for "university".
15:25:47 <mib_omr0x8dh> lol i asked and someone said yes...
15:25:52 <roconnor> ski_: I would represent non-zero real numbers the same way I represent real numbers, by using something like CReal.
15:25:54 <vixey> @devils university
15:25:54 <lambdabot> No match for "university".
15:26:00 <mib_omr0x8dh> musta been asnwering a different question
15:26:02 <vixey> @vera univercity
15:26:02 <lambdabot> No match for "univercity".
15:26:16 <pumpkin> mib_omr0x8dh: I said yes in the sense that this is a center of knowledge and research and learning on haskell!
15:26:16 <ddarius> vixey: "University" isn't an acronym...
15:26:17 <pumpkin> ;)
15:26:19 <ski_> roconnor : so how do you know it is non-zero ?
15:26:26 <vixey> @w80 university
15:26:28 <lambdabot> *** "university" wn "WordNet (r) 2.0"
15:26:28 <lambdabot> university
15:26:28 <lambdabot>      n 1: the body of faculty and students at a university
15:26:28 <lambdabot>      2: establishment where a seat of higher learning is housed,
15:26:28 <lambdabot>         including administrative and living quarters as well as
15:26:29 <vixey> thanks ddarius
15:26:30 <lambdabot> [4 @more lines]
15:26:54 <mib_omr0x8dh> well srry i must be going now cya
15:26:54 <loadquo> @hoogle enum
15:26:55 <lambdabot> Prelude class Enum a
15:26:55 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
15:26:55 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
15:26:56 <vixey> Yeah I don't think we could call this channel "living quarters" really
15:27:20 <roconnor> ski_: _I_ know because I wrote the program.  And to remind myself, (and to potentially help the compiler with RULES), I write newtype NonZeroReal = NonZeroReal CReal
15:27:28 <int80_h> @hoogle abs
15:27:28 <lambdabot> Prelude abs :: Num a => a -> a
15:27:28 <lambdabot> Distribution.Simple.InstallDirs absoluteInstallDirs :: PackageIdentifier -> CompilerId -> CopyDest -> InstallDirTemplates -> InstallDirs FilePath
15:27:28 <lambdabot> Distribution.Simple.LocalBuildInfo absoluteInstallDirs :: PackageDescription -> LocalBuildInfo -> CopyDest -> InstallDirs FilePath
15:28:21 <augustss> roconnor: And how do you make sure there's no 0 in NonZeroReal?
15:28:23 <ski_> roconnor : so you want a quotient of a subobject of the representation type ?
15:28:25 <roconnor> augustss: I assume that part of the semantics of RULES are that the constituents of what the RHS and the LHS represent are the same.
15:29:13 <roconnor> augustss: I write my programs that way.  There is really no way for the compiler to enforce this.
15:29:15 * ski_ is not sure why we need words like `constituent' instead of plain `value'
15:29:17 <augustss> roconnor: RULES allow you to do anything, so if you want to use rules I have no opinion.  I have no idea what the semantics of a program with rules is.
15:29:38 <roconnor> augustss: ok
15:29:40 <ksf> "The proof follows trivially out of existentially quantified obviousity"
15:29:58 <ski_> (ksf : proof of what ?)
15:30:16 <roconnor> ski_: I need to distinguish represenatives from constituents.  They are different concepts.
15:30:27 <loadquo> Is there a nice way to do C++ style enums in haskell? I explicitly want a specific number associated with each label.
15:30:29 <roconnor> I don't know a better term.  If you tell me one, I'll use it.
15:30:29 <ksf> anything.
15:30:30 <augustss> roconnor: or rather, each use of RULES requires an external proof that the rule is valid
15:30:46 <vixey> loadquo, data Direction = North | South | ...
15:30:54 <roconnor> augustss: yes, and that proof will be about constituents and not about represenatives.
15:31:03 <vixey> loadquo, code North = 0; code South = ...
15:31:15 <ztirF> @src fromInteger
15:31:15 <lambdabot> Source not found.
15:31:16 <roconnor> augustss: or maybe you think that <CReal, +> isn't a monoid.
15:31:21 <pumpkin> or just derive Enum
15:31:23 <ski_> (roconnor : i'm not sure how well it works, but i'd start by saying that `CR_' need not be injective ..)
15:31:24 <ztirF> @hoogle fromInteger
15:31:25 <roconnor> augustss: that would be a consistent position to take.
15:31:35 <augustss> roconnor: you seem talk talk about the abstract and concrete values.  or does your terminology mean something else?
15:31:49 <roconnor> ski_: oh right. I forget. CR_ has all sorts of non-convergent functions.
15:32:04 <roconnor> ski_: so I don't need to go to Non-zero real numbers
15:32:17 <roconnor> augustss: I think those would be good terms to use.
15:32:18 <ski_> ok
15:32:24 <BONUS> hmm
15:32:24 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
15:32:44 <loadquo> vixey, you mean inside the code? I was hoping to have it obvious to anyone looking at the datatype...
15:33:03 <augustss> The proof of a+0=a for CReal relies on the fact that CReal is exported without (..).  If it were, the proof would be invalid.
15:33:15 <augustss> (at least I think so)
15:33:38 <roconnor> augustss: nope.  show (a+0) and show 0 are potentially different.
15:33:50 <vixey> loadquo, code North = 0; code South = ...  is obvious
15:33:50 <BONUS> guys, say you have n scrabble letters, like "msourpetc" and you want to know which words can be formed by using those letters, what's the approach you'd take?
15:34:07 <BONUS> you also have a dictionary
15:34:09 <vixey> loadquo, in any case that's the best I can think of
15:34:15 <pumpkin> BONUS: if you only want words using all the letters, it's easy
15:34:17 <augustss> roconnor: you mean show (a+0) and show a?
15:34:24 <roconnor> yes sorry.
15:34:24 <pumpkin> BONUS: otherwise there's an approach using a DAWG
15:34:28 <BONUS> pumpkin: no, any words
15:34:31 <BONUS> not only all letters
15:34:32 <pumpkin> YO DAWG, I HEARD YOU LIKE SCRABBLE
15:34:34 <ksf> bonus, a) permute, b) match
15:34:34 <vixey> BONUS, walk down a trie
15:34:43 <BONUS> yeah that's what i'm doing now
15:34:49 <BONUS> first i cram all the dictionary words in a trie
15:34:50 <vixey> > product [1.. length "msourpetc"]
15:34:51 <roconnor> (a+0) "speeds up" the fast converging cauchy sequence by a factor of 2 (or 4)
15:34:52 <lambdabot>   362880
15:34:52 <BONUS> and then i permute
15:34:54 <augustss> roconnor: well, then there's a leak in the abstraction barrier, and the rule is invalid
15:34:59 <pumpkin> it can be done a lot faster than that
15:34:59 <BONUS> and then i match prefixes against the trie
15:35:00 <pumpkin> using a DAWG
15:35:03 <mm_freak> is there an Int-like type, which is a Monoid instance with addition?
15:35:06 <BONUS> although i have to nub the solution later
15:35:10 <BONUS> what's a DAWG
15:35:13 <SamB_irssi> mm_freak: Sum Int, I think
15:35:18 <pumpkin> it's a trie with merged common suffixes
15:35:19 <vixey> BONUS, if you just walk down the trie than you shouldn't have to permute.. I think ..(?)
15:35:22 <mm_freak> i'd like to use Writer (instead of State) for counting recursions
15:35:27 <pumpkin> so it captures both common prefixes and common suffixes
15:35:33 <loadquo> mm_freak Sum?
15:35:40 <BONUS> hmm
15:35:41 <roconnor> augustss: the leak is important if you ever want to have a non-constant total function from the real numbers to a discreate space.
15:35:56 <mm_freak> ok, thanks
15:36:00 <loadquo> @instances Monoid
15:36:01 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:36:03 <pumpkin> BONUS: http://willforkforwood.blogspot.com/2007/09/dawg-algorithms-and-scrabble-source.html might cover it
15:36:06 <ksf> hmmm... a) build trie b) sort input c) walk trie d) profit
15:36:15 <BONUS> pumpkin thanks i'll czech that out
15:36:22 <pumpkin> slovak it
15:36:44 <augustss> roconnor: sad.  Well <CReal, +, 0> is not a monoid then.
15:37:02 <roconnor> augustss: your choice is either allow approximations of CReal to return different values for the "same" input, or to allow approximations of CReals to potentially never terminate.
15:37:04 <pumpkin> BONUS: or maybe http://www.forthfreak.net/index.cgi?DirectedAcyclicWordGraph (just search for scrabble yo dawg, I heard you like scrabble, so I put a dawg inside your dawg so you can scrabble better)
15:37:06 <BONUS> ksf: you mean sort the original list of letters?
15:37:12 <ksf> forget what I'm saying, I'm using only 10% of my brain, max.
15:37:23 <roconnor> augustss: that is one position to take, but I think it is a poor position.
15:37:27 <smtms> ksf, what's occupying the other 90%?
15:37:34 <pumpkin> buttsecks
15:37:48 <ski_> roconnor : why potentially never terminate ?
15:37:53 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1043#a1045 and what I want to develop it to be.
15:37:54 <mm_freak> is there any reason to prefer Writer (Sum Int) over State Int for counting something while computing something?
15:38:16 <glguy> mmorrow, how do I use lunabot?
15:38:27 <pumpkin> , "ohai"
15:38:29 <lunabot>  "ohai"
15:38:34 <roconnor> ski_: because of the theorem that all (computable) functions on the reals are continuous.
15:38:36 <byorgey> mm_freak: 'tell n' is slightly fewer keystrokes than 'modify (+n)' =)
15:38:41 <glguy> ,type "ohai"
15:38:42 <lunabot>  luna: parse error on input `type'
15:38:42 <augustss> roconnor: but it's the only one that's actually right.  But for convenience you might want to consider it to be a monoid anyway.
15:38:52 <pumpkin> , [$ty | "ohai" ]
15:38:53 <BONUS> hmmm i there's one way i can think of without permuting but just going over a list of dictionary words
15:38:53 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
15:38:54 <SamB_irssi> mm_freak: well, I think the Monoid has much more flexible evaluation order
15:39:03 <pumpkin> , [$type| "ohai" ]
15:39:04 <lunabot>  luna: lexical error in string/character literal at end of input
15:39:07 <pumpkin> boo
15:39:13 <benmachine> , ":\/"
15:39:14 <lunabot>  luna: lexical error in string/character literal at character '"'
15:39:21 <BONUS> and filtering by every letter in the dictionary word appearing in the original list of letters
15:39:43 <vixey> [a/x]B means replace the x free in B with a.. apparently
15:39:48 <vixey> who thought of that notation!?
15:39:52 <vixey> I use B[x := a]
15:40:00 <ski_> roconnor : .. oh, now i recall
15:40:00 <ksf> bonus, my naive approach would be to walk the trie, remove the match from the input and then continue walking.
15:40:06 <roconnor> augustss: the concept of the real numbers is certainly a monoid.  I wouldn't mind my compiler optimizing (b+0) to b.  To disallow such optimisation on principle seems fanatical.
15:40:09 <ksf> the permutation is being done by matching.
15:40:10 <skorpan> there's an abundance of different notations for variable substitution
15:40:11 <SamB_irssi> vixey: someone who didn't like that the substitutions were always on the right ?
15:40:19 <skorpan> the one i use is e[x <- y]
15:40:21 <mm_freak> byorgey: tell (Sum n)
15:40:26 <vixey> SamB_irssi, [a/x]B ... wtf!
15:40:29 <Philippa_> vixey "substitute a for x in B"
15:40:30 <skorpan> where all free occurrences of x in e are replaced with y
15:40:46 <augustss> roconnor: it's only by being fanatical that I can promise that the compiler does the right thing.
15:40:48 <SamB_irssi> skorpan: huh, I'd put the arrow the other way ;-P
15:40:54 <Philippa_> IOW, it came from the then-common verbal version
15:41:02 <skorpan> SamB_irssi: actually never seen that notation :P
15:41:10 <ski_> (it doesn't help that i can never recall whether `a' or `x' is the variable in the phrase "substitute a for x in ..")
15:41:12 <BONUS> ksf hmm. im not sure what the trie profits you then
15:41:18 <mm_freak> SamB_irssi: the purpose is counting something, so i'm not going to do anything more than (+1)
15:41:25 <roconnor> augustss: oh okay.  s/fanatical/overly cautious/
15:41:28 <Philippa_> ski_: yeah, I suspect it was less ambiguous at the time
15:41:29 <vixey> Philippa_, I guess I'll have to wait and see if that mnemonic actually lets me remember it
15:41:33 <mm_freak> the problem with Writer (Sum Int), i'm expecting it to be slower than State Int
15:41:36 <augustss> roconnor: once you start taking shortcuts there's no way to know where they will lead.
15:41:49 * loadquo doesn't like the Probability notation P(A|B) which means the probability of A given B
15:41:50 <redditbot> What is automatic differentiation, and why does it work?
15:41:50 <redditbot> Comparing formulations of higher-dimensional, higher-order derivatives
15:41:54 <ksf> well, enumerating all possible words and string-matching them against the dictionary is the other approach.
15:41:54 <vixey> but isn't something like  [ x := y ] so much clearer.......
15:42:07 <SamB_irssi> mm_freak: I guess the strict state monad would probably be best
15:42:10 <byorgey> mm_freak: if I were you, I'd just make my own monad, a strict variant of writer that just has a function called 'count' which increases a counter by one.
15:42:22 <byorgey> you could base it on the strict state monad.
15:42:23 <augustss> roconnor: it can never be the default for a compiler to make incorrect transformations.  if you want to tell it to do so, that's another matter.
15:42:26 <ksf> that might be faster for short words, but will explode in your face if they get longer.
15:42:32 <Philippa_> vixey: it is /now/. Once upon a time, := for mutable assignment (as a point of reference) didn't exist
15:42:49 <pumpkin> BONUS: more info on the DAWG approach here http://dotnetperls.com/Content/Directed-Acyclic-Word-Graph.aspx
15:42:59 <BONUS> kewl
15:43:03 <roconnor> augustss: if all my RULES preserve my constituents, then I have a pretty good control over the behaviour.
15:43:16 <roconnor> augustss: yes, of course you have to tell the compiler.
15:43:21 <mm_freak> SamB_irssi: yeah, that sounds reasonable
15:43:30 <pumpkin> BONUS: if you implement DAWG code in haskell, please make it public :D I was looking for it a couple of weeks ago but people just made YO DAWG jokes at me :P
15:43:41 <BONUS> haha sure thing
15:43:47 <SamB_irssi> pumpkin: where, here ?
15:43:54 <pumpkin> SamB_irssi: yeah :P
15:43:55 <ksf> me doesn't like :=, it reminds him of pascal.
15:44:01 <augustss> roconnor: yes, if you have an external proof that shows that what you care about is preserved by the rules, then I have no objections to them.
15:44:02 <mm_freak> byorgey: Writer seems natural, but State is more convenient and likely faster
15:44:14 <ski_> roconnor : possibly one can construct a real number whose `constituent' depends on the `representative' of another real number ..
15:44:14 <roconnor> augustss: oh good.
15:44:27 <vixey> actually I usually write  B[x]
15:44:36 <vixey> I assume "B has one free variable"
15:44:37 <SamB_irssi> ski_: sure you can!
15:44:42 <ski_> (roconnor : possibly even the compiler might fusion some code to do this when one's not expecting it)
15:44:43 <vixey> rather than "a is free in B"
15:44:45 <ksf> Pascal would turn over in his grave if he knew that abyss that's named like him.
15:44:49 <roconnor> ski_: sure, approximate and inject back into the reals.  Such a function is not "respectful"
15:44:56 <BONUS> hmmm implementing dawgs in haskell looks a bit tricky cause several nodes can point to the same one
15:45:01 <SamB_irssi> ski_: I don't think the compiler can fusion out "read"
15:45:04 <pumpkin> BONUS: yup :)
15:45:15 <BONUS> i haven't messed so much with graphs in haskell
15:45:19 <pumpkin> BONUS: it's just a DAG though, so a graph library should make it not too difficult
15:45:19 <augustss> but Haskell is now a somewhat different language, that will compute an element in an equivalence class.
15:45:20 <BONUS> this looks like a cool exercise to try out
15:45:21 <ksf> bonus, fgl.
15:45:27 <pumpkin> BONUS: but it's by far the fastest way to do it that I know of
15:45:29 <byorgey> mm_freak: right, so roll your own thin wrapper on top of strict state, and you get both naturalness and speed.
15:45:33 <roconnor> ski_: it probably wouldn't happen unexpectedly.  You would have to be using approximate, which you already knew wasn't respectful.
15:45:36 <SamB_irssi> vixey: what if B had two free vars ?
15:45:48 <roconnor> ski_: or some other non-respectful function.
15:45:53 <augustss> roconnor: some transformations that are normally semantics preserving in Haskell can change which element in the equivalence class you get.
15:45:54 <vixey> SamB_irssi, that's fine too.. this is just De Bruijn whatever
15:46:20 <ski_> vixey : in `B[x]' i'd say `B[x]' has `x' as free variable, but (probably) `B' doesn't
15:46:39 <vixey> ski_, yeah I've seen that a few times but it's not the meaning I was using
15:46:48 <pejo> ski/vixey, is B a term, or a context, or something else?
15:46:52 <SamB_irssi> vixey: but which one would it substitute ?
15:46:54 <Saizan> byorgey, mm_freak: strict state is not strict in the state though, you've to `seq` before you put for that
15:46:55 <vixey> pejo, a term
15:47:09 <roconnor> augustss: okay. this is Haskell + something.  But I argue that this is the language that we typically program in on this channel.
15:47:10 <vixey> SamB_irssi, the first one.. uh.. I guess that didn't explain anythnig
15:47:12 <byorgey> Saizan: oh, what's a strict in then?
15:47:36 <augustss> roconnor: I try not to. :)
15:48:02 <roconnor> augustss: o'rly
15:48:03 <Saizan> byorgey: in the tuple
15:48:04 <pejo> augustss, what are you discussing anyways, whether the compiler should be allowed to do unsound transformations?
15:48:04 <roconnor> :)
15:48:06 <augustss> roconnor: I'm a fanatical and paranoid compiler guy.
15:48:12 <ski_> pejo : if you ask me, i say `B' is a (meta-level) function from identifiers to expressions
15:48:25 <roconnor> augustss: I'm a mathematician :P
15:48:32 <ski_> (or possibly from expressions to expressions)
15:48:41 <augustss> roconnor: yes, they are known to take all kinds of shortcuts
15:48:52 <Saizan> byorgey: it uses case f a of (b,s) -> .. instead of let (b,s) = f a in ..
15:49:08 <byorgey> Saizan: oh, I see.
15:49:15 <roconnor> augustss: well, it does let us do what you say is impossible :)
15:49:30 <byorgey> wow, this whole time I misunderstood it =)
15:49:45 <augustss> roconnor: impossible for a computer :)
15:50:30 <roconnor> augustss: to me, the computer seems to be doing a pretty good job, whatever it is doing, even if you think I'm totally breaking the rules.
15:50:53 <SamB_irssi> well, does trace lose you referential transparency ?
15:51:07 <SamB_irssi> it's a similar argument you guys are having ;-P
15:51:13 <augustss> SamB_irssi: of course it does
15:51:14 <int80_h> @src dropUntil
15:51:14 <lambdabot> Source not found. Wrong!  You cheating scum!
15:51:49 <SamB_irssi> augustss: I claim "not unless you consider stderr to be part of the semantics of your program"
15:51:59 * pumpkin wants to implement soft heaps in haskell
15:52:01 <ski_> @free trace :: String -> a -> a
15:52:01 <lambdabot> f . trace x = trace x . f
15:52:16 <ddarius> pumpkin: Then do so.
15:52:19 <augustss> SamB_irssi: most people do
15:52:23 <SamB_irssi> I mean, if I can use a certain Haskell program to cook a hamburger on the CPU, does that mean that the program has side-effects?
15:52:27 <pumpkin> ddarius: trying to think of a good way of doing it :)
15:52:33 <SamB_irssi> augustss: but you don't HAVE to
15:52:46 <roconnor> SamB_irssi: that isn't portable.
15:52:50 <SamB_irssi> is the heap profiler part of the semantics of your program
15:52:53 <SamB_irssi> ?
15:53:31 * roconnor watches SamB_irssi mod out stderr in his concepts.
15:53:59 <augustss> SamB_irssi: I don't think it is.  Nor is the contents of it under program control.
15:54:11 <SamB_irssi> augustss: what about SCCs
15:54:39 <augustss> SamB_irssi: ghc is full of stuff I don't know the semantics of :)
15:54:43 <int-e> . o O ( traceShow samB'sPrivateKey $ ... )
15:54:54 <SamB_irssi> int-e: heh
15:55:32 <SamB_irssi> security is not controlled solely by semantics when the attacker has that kind of access, anyway
15:55:50 <augustss> SamB_irssi: but I understand what you're saying about stderr.  I just don't totally agree.
15:56:10 <SamB_irssi> augustss: it depends on what you care about at the time!
15:56:26 <augustss> SamB_irssi: absolutely, I use trace all the time for debugging.
15:56:43 <augustss> SamB_irssi: did you know I was the one that introduced trace?
15:56:45 <ztirF> logBase should be b->a->a imo
15:56:49 <ztirF> instead of a->a->a
15:56:52 <SamB_irssi> and it doesn't stop you from using referential transparency to reason about everything not involving stderr, yes ?
15:57:09 <ski_> @type logBase
15:57:10 <lambdabot> forall a. (Floating a) => a -> a -> a
15:57:22 <ski_> ztirF : both types in `Floating' ?
15:57:30 <ztirF> ski_: yes
15:57:44 <augustss> SamB_irssi: I would not use trace for something that was part of the normal usage of the program.
15:57:56 <ztirF> it's so I can make logBase for arrays sensible
15:57:58 <SamB_irssi> augustss: well, no
15:58:06 <SamB_irssi> not on purpose anyway ...
15:58:23 <augustss> right
15:58:27 <ski_> (ztirF : how can you make `fromInteger' for arrays sensible ?)
15:58:41 * SamB_irssi wonders if debugging a compiler counts as normal usage ?
15:58:45 <ztirF> ski_: you can't.  I set it = error, along with fromRational, and pi
15:58:50 <ztirF> but everything else works
15:58:56 <augustss> ski_: fromInteger is OK, but what about toInteger?
15:59:20 <SamB_irssi> obviously, if you don't want to consider something part of the semantics, it shouldn't be needed for normal usage ;-P
15:59:27 <ski_> augustss : which array bounds in `fromInteger' ?
15:59:31 <ski_> @type toInteger
15:59:32 <lambdabot> forall a. (Integral a) => a -> Integer
15:59:48 <ski_> @type fromInteger
15:59:49 <lambdabot> forall a. (Num a) => Integer -> a
15:59:53 <augustss> ski_: darn!  I forgot those :)
16:00:10 <ski_> (ztirF : were you trying to put arrays into `Integral' ?)
16:00:28 <augustss> ski_: I used mde instance decalrations like that, but I had the array size as part of the type, so it all worked out.
16:00:36 <ddarius> ztirF: If I were you, I would take a page out of APL/J implementations and use a more sophisticated "array" type
16:00:42 <ski_> augustss : `mde' ?
16:00:48 <augustss> ski_: made
16:00:55 <ztirF> ski_: I'm trying to put arrays into Num, Fractional, and Floating, but Integral probably eventually too
16:01:24 <SamB_irssi> okay, I'm going home now ...
16:01:25 <ztirF> ddarius: what advantage would that confer?  I want to make the instance over the class of IArray
16:01:42 <ski_> ztirF : so you're trying for something alike '(e ->)'. then ?
16:02:10 <ddarius> ztirF: You would be able to implement things like pi and fromInteger sensibly (perhaps) and you would open to some sophisticated optimizations.
16:02:45 <ztirF> ski_: I never could figure out what exactly that was.  Can you explain it to me?
16:03:39 <ddarius> As a very simply example of the former, you could have data Array' a = C a | Arr (Array Int a); fromInteger = C; C a + Arr arr = arrayMap (a+) arr; etc. (making up operations for simplicity)
16:03:43 <ztirF> ddarius: I'm not sure how they ever make sense; arithmetic on arrays is by convention pointwise
16:03:58 <ski_> ztirF : sorry, i was just wondering if you wanted something similar as `instance Num a => Num (e -> a) where fromInteger n = const n; (f + g) n = f n + g n; ...'
16:04:07 <ski_> ztirF : iow, pointwise calculations
16:04:22 <pumpkin> multiplication of arrays should be convolution
16:04:30 <pumpkin> :D
16:04:32 <ddarius> ztirF: One way to understand fromInteger 1 is it's an "infinitely wide" array and when you use a binary operation, like (+), you truncate to the shorter.
16:04:36 <ztirF> pumpkin: that's not the convention in IDL or Fortran 90
16:04:47 <ddarius> ztirF: What -do- you do when the arrays are not the same length in (+)?
16:04:57 <pumpkin> ztirF: just sayin :P
16:05:05 <ski_> pumpkin : can you remind me what convolution would be here again ?
16:05:11 <ztirF> ddarius: it should throw an exception I think
16:05:19 <chessguy> 'ello
16:05:46 <pumpkin> ski_: sliding dot-product-like thing? I could come up with a better explanation if you really wanted it :P
16:06:16 <ski_> (istr something like `sum [.a..b. | let a + b = x]')
16:06:41 <ztirF> ski_: is that like making array an instance of Functor?
16:06:51 <ztirF> I tried that once and it didn't work
16:07:05 <augustss> pumpkin: does convolution generalize to arbitrary rank arrays?
16:07:34 <pumpkin> not sure, probably in some obscure way :) I'm by no means an expert :)
16:07:46 <ski_> pumpkin : if you care to elaborate now, then sure
16:08:04 <pumpkin> I wasn't even reading the convo, just saw something about multiplying arrays
16:09:13 <ddarius> ski_: xs `conv` ys = map (xs `dot`) (tails ys)  dot xs ys = sum (zipWith (*) xs ys)
16:09:27 <loadquo> @instances IArray
16:09:27 <lambdabot> Couldn't find class `IArray'. Try @instances-importing
16:09:31 <loadquo> :(
16:09:40 <pumpkin> it can be done in nlogn time too
16:10:23 <chessguy> > let xs `conv` ys = map (xs `dot`) (tails ys); dot xs ys = sum (zipWith (*) xs ys); in [1,2,3] `conv` [4,5,6]
16:10:24 <lambdabot>   [32,17,6,0]
16:10:46 <pumpkin> I think you want not null tails
16:11:04 <pumpkin> > let xs `conv` ys = map (xs `dot`) (takeWhile not . null $ tails ys); dot xs ys = sum (zipWith (*) xs ys); in [a,b,c] `conv` [d,e,f]
16:11:05 <lambdabot>   Couldn't match expected type `[Bool]' against inferred type `Bool'
16:11:10 <ddarius> pumpkin: Doesn't really matter for the perspective I'm taking.
16:11:15 <pumpkin> fair enough :)
16:11:17 <ski_> so the index set is ordered ?
16:11:35 <pejo> ski, "faltning" på svenska.
16:12:05 <pejo> ski, nevermind, think I mis-interpreted you.
16:12:10 <ski_> (pejo : säjer mig inte mycket mera .. har kanske sett ordet nån gång :)
16:12:47 <ddarius> ski_: A quick way of stating what convolution is that keeps me from wondering if I implemented it correctly is, convolution is what happens to the coefficients of two polynomials when multiplied.
16:13:14 <ddarius> (ordered by degree)
16:14:03 <ddarius> > let xs `conv` ys = map (xs `dot`) (tails ys); dot xs ys = sum (zipWith (*) xs ys) in [0,1,0] `conv` [1..10]
16:14:04 <lambdabot>   [2,3,4,5,6,7,8,9,10,0,0]
16:14:06 <pumpkin> which is how you get fast multiplication algorithms on bigints
16:14:09 <dcoutts> Anyone around who understands Windows permissions and has admin access to a Vista box?
16:14:10 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/454#comment:11
16:14:27 <pumpkin> or using the NTT
16:14:41 <dcoutts> we're having difficulty understanding what is going on with inherited / default permissions
16:15:23 <ddarius> > let xs `conv` ys = map (xs `dot`) (tails ys); dot xs ys = sum (zipWith (*) xs ys) in [1..10] `conv` [0,1,0]
16:15:24 <lambdabot>   [2,1,0,0]
16:15:36 <ddarius> > let xs `conv` ys = map (xs `dot`) (tails ys); dot xs ys = sum (zipWith (*) xs ys) in [1..10] `conv` [0,1,0,0,0,0,0,0,0,0]
16:15:38 <lambdabot>   [2,1,0,0,0,0,0,0,0,0,0]
16:16:08 <ddarius> > let xs `conv` ys = map (xs `dot`) (tails $ reverse ys); dot xs ys = sum (zipWith (*) xs ys) in [1..10] `conv` [0,1,0,0,0,0,0,0,0,0]
16:16:09 <lambdabot>   [9,8,7,6,5,4,3,2,1,0,0]
16:16:39 <ddarius> > let xs `conv` ys = map (xs `dot`) (tails $ reverse ys); dot xs ys = sum (zipWith (*) xs ys) in [0,1,0] `conv` [1..10]
16:16:41 <lambdabot>   [9,8,7,6,5,4,3,2,1,0,0]
16:16:57 <ski_> "the discrete convolution of `f' and `g' is given by: `(f * g) n = sum [f m * g (n - m) | m <- [-Inf..Inf]]'"
16:17:20 <pumpkin> you tend to either pad with zeros or make it circular
16:17:29 <pumpkin> for those infs
16:17:34 <ski_> (which i prefer to think of as `sum [f a * g b | let a + b = n]')
16:17:37 <mmorrow> this went from fiddling in ghci while reading this book to a mini abstract machine + interactive repl  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1047#a1047
16:18:05 * ddarius just thinks as convolution as being the thing that makes the Convolution Theorem true.
16:18:14 <mmorrow> this book is sweet
16:18:20 <pumpkin> :)
16:18:22 <Gracenotes> mmorrow: stack-based single-step evaluator..?
16:18:26 <ddarius> mmorrow: Which book?  And that's how Pugs started.
16:18:41 <mmorrow> Categorical Combinators, Sequential Algorithms, and Functional Programming
16:18:51 <ddarius> mmorrow: By?
16:18:53 <mmorrow> Gracenotes: exactly
16:18:57 <mmorrow> um
16:19:03 <mmorrow> Pierre-Louis Curien
16:19:13 <pumpkin> sweet, it's in my lib
16:19:14 <ddarius> CAML guy, then
16:19:15 <mmorrow> written in 1993
16:19:19 <mmorrow> exactly
16:19:48 <dadaism_> hey i'm new to haskell and to this channel but i have a question that's been bugging me
16:19:56 <pumpkin> let's hear it!
16:20:10 <mmorrow> i've had this book for maybe 8 months, but wasn't really that thrilled until recently
16:20:21 <dadaism_> ok:  i'm going to basically show you exactly what i typed in and what i got out
16:20:49 <mmorrow> (until now that all the content is directly relevant to stuff)
16:20:53 <dadaism_> first i :set +t so i could see the types
16:21:03 <dadaism_> just for some more detail
16:21:13 <loadquo> dadaism_ perhaps use a paste bin?
16:21:18 <ski_> @where paste2
16:21:18 <lambdabot> I know nothing about paste2.
16:21:19 <dadaism_> ah
16:21:22 <ski_> @where hpaste2
16:21:22 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
16:21:38 <pumpkin> will hpaste ever get fixed?
16:21:38 <dadaism_> alright give me a sec then
16:21:42 <mmorrow> (well, not _all_ the content.... a bunch of it is eyes-glaze-over-omg-what-are-these-symbols)
16:22:51 <Gracenotes> hm... maybe I should use XML to represent saved state in my game board :/
16:23:04 <pumpkin> Gracenotes: as opposed to what?
16:23:32 <Gracenotes> as opposed to, er... binary? ASCII matrix with key? CSV? :)
16:23:40 <pumpkin> ah, maybe then :)
16:23:45 <mmorrow> the cool part is how the code and what it's manipulating is the same type
16:24:16 <dadaism_> alright
16:24:20 <int80_h> @hoogle lcm
16:24:20 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
16:24:22 <dadaism_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1048#a1048
16:24:40 <Gracenotes> @hoogle Complex
16:24:40 <lambdabot> module Data.Complex
16:24:40 <lambdabot> Data.Complex data RealFloat a => Complex a
16:24:40 <lambdabot> package storable-complex
16:24:46 <pumpkin> dadaism_: make it a Complex Double
16:24:50 <int80_h> so, a has to be of type Integral
16:24:53 <dadaism_> ah
16:24:54 <pumpkin> in the realm of Double, there is no i
16:25:02 <pumpkin> "realm"? o.O
16:25:04 <pumpkin> meh
16:25:06 <Gracenotes> > sqrt (-1)
16:25:07 <ski_> pumpkin : hm .. so the two arrays `ar0' and `ar1' could be converted into the two functions by `f i = ar0 ! n; g j = ar1 ! (- j)' ?
16:25:07 <lambdabot>   NaN
16:25:15 <mjb> Is there a way in GHCi to see an how an instance is defined?
16:25:17 <dadaism_> yeah i was wondering why sqrt (-1) was listed as a double
16:25:24 <Gracenotes> dadaism_: you see, with doubles (in any language, probably), sqrt (-1) is NaN
16:25:38 <dadaism_> and why it :: Double when I get not-a-number as my answer
16:25:50 <pumpkin> NaN is Double
16:25:55 <dadaism_> oh
16:25:57 <Gracenotes> dadaism_: it won't just blow up -- floating point arithmetic with doubles always return doubles
16:25:58 <loadquo> Infinity is a Double
16:26:06 <Gracenotes> even if they're invalid doubles
16:26:18 <mmorrow> glguy: lunabot's few things (other than eval) are:
16:26:19 <pumpkin> ski_: yeah, assuming you then used those together to convolve the two arrays
16:26:20 <roconnor> > 1/0 == 1/0
16:26:21 <lambdabot>   True
16:26:26 <roconnor> > 0/0 == 0/0
16:26:28 <lambdabot>   False
16:26:30 <pumpkin> correlation/autocorrelation are special cases of it
16:26:31 <mmorrow> , [$ty| \x -> show (0,x) |]
16:26:34 <lunabot>  forall a . Show a => a -> String
16:26:41 * roconnor thinks of Nan as the only invalid Double
16:26:50 <mmorrow> , runId . runStateT 42 $ (do set =<< (*2) `fmap` get; return "omg")
16:26:51 <lunabot>  ("omg",84)
16:26:55 <skorpan> is that some naan bread nom nom nom
16:26:56 <Gracenotes> success!
16:26:57 <dadaism_> thanks.  it seemed like euler's identity would just "work" in haskell.  but i guess it was wrong of me to assume things would be so easy
16:27:06 <mmorrow> , src 'runContT
16:27:08 <lunabot>  runContT :: forall a m i . (a -> m i) -> ContT i m a -> m i
16:27:09 <pumpkin> dadaism_: it is that easy
16:27:12 <pumpkin> you just need the right type
16:27:27 <ski_> pumpkin : ok .. (i only noticed the words "convolution" on WP some time after inventing the operation, so i'm not very familiar with traditional uses)
16:27:28 <mmorrow> , src ''ContM
16:27:31 <lunabot>  class (Monad m) => ContM m where
16:27:31 <lunabot>          callCC :: forall b a . ((a -> m b) -> m a) -> m a
16:27:42 <pumpkin> > (exp 1) ** (sqrt (-1)  * pi) :: Complex Double
16:27:43 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
16:27:48 <pumpkin> > (exp 1) ** (sqrt (-1)  * pi) :: Complex CReal
16:27:54 <lambdabot>   (-1.0) :+ 0.0
16:27:56 <Gracenotes> why not just exp it?
16:28:02 <pumpkin> that would make sense too :P
16:28:16 * pumpkin kicks himself
16:28:19 <Gracenotes> dadaism_: in Haskell, a :+ b means the same thing as a + bi
16:28:22 <skorpan> :t (:+)
16:28:23 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
16:28:28 <skorpan> oh.
16:28:31 <pumpkin> ski_: WP?
16:28:37 <Gracenotes> > (0 :+ 1)*(0 :+ 1)
16:28:38 <int80_h> hmm, online hoogle can't find Prelude lcd
16:28:38 <lambdabot>   (-1.0) :+ 0.0
16:28:41 <ski_> (pumpkin : wikipedia)
16:28:43 <pumpkin> oh :)
16:29:12 <int80_h> @hoogle lcd
16:29:13 <lambdabot> No results found
16:29:16 <loadquo> @hoogle Complex
16:29:16 <lambdabot> module Data.Complex
16:29:16 <lambdabot> Data.Complex data RealFloat a => Complex a
16:29:16 <lambdabot> package storable-complex
16:29:17 <pumpkin> int80_h: lcd _ = 1
16:29:31 <mmorrow> , runId . runContT return $ (*2) `fmap` shift (\k -> k 42 >>= k >>= k)
16:29:32 <lunabot>  336
16:29:46 <int80_h> oops I meant lcm
16:29:48 <pumpkin> int80_h: maybe you're looking for lcm or gcd? :P
16:30:02 <Gracenotes> lcm _ _ = unsafePerformIO (randomIO :: Int)
16:30:20 <int80_h> pumpkin, yeah lcm
16:30:28 <ski_> Gracenotes : type error, `IO a' doesn't match `Int'
16:30:29 <mmorrow> , runId . runContT return $ callCC (\z -> (*2) `fmap` shift (\k -> k 42 >>= k >>= z >>= k >>= k))
16:30:30 <pumpkin> I guess it doesn't make much sense for my lcd to take one arg :)
16:30:30 <lunabot>  168
16:30:37 <Gracenotes> ski_: IO Int
16:31:22 <dadaism_> is there no type inference in haskell (after loading Data.Complex) to treat sqrt (-1) as a Complex Double
16:31:41 <mmorrow> , runId . runContT return $ shift (\k -> liftM2 (+) (k 42) (k 42)) >>= \n -> callCC (\z -> (*2) `fmap` shift (\k -> k n >>= k >>= z >>= k >>= k))
16:31:42 <dadaism_> the only way e ** (i * pi) works is if i let i = 0 :+ 1
16:31:42 <lunabot>  336
16:31:50 <ski_> > sqrt ((-1) :: Complex Double)
16:31:52 <lambdabot>   (-0.0) :+ 1.0
16:32:28 <loadquo> , [$ty] shift
16:32:29 <lunabot>  luna: Couldn't match expected type `t -> a' against inferred type `[a1]'
16:32:38 <dadaism_> so if i choose to use complex numbers explicitly with sqrt, I need to :: Complex Double ?
16:33:04 <ski_> no
16:33:09 <Gracenotes> dadaism_: if the numbers are known to be complex already, you don't have to
16:33:31 <ski_> > sqrt (-1) + (0 :: Complex Double)
16:33:32 <lambdabot>   0.0 :+ 1.0
16:33:49 <mle> > exp $ 0 :+ pi
16:33:50 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
16:34:03 <Gracenotes> close enough to 0 :)
16:34:14 <loadquo> > realPart (sqrt (-1) )
16:34:16 <lambdabot>   -0.0
16:34:19 <Gracenotes> sqrt (-1) is just a Floating a => a. When the "a" is unspecified, Haskell makes it a Double
16:34:45 <loadquo> > complexPart (sqrt (-1) )
16:34:46 <lambdabot>   Not in scope: `complexPart'
16:34:53 <pumpkin> > map (($1) . flip uncurry ((+1), (*2))) [(>>), (<<<), (>>>), (.)]
16:34:54 <lambdabot>   [2,3,4,3]
16:35:04 <loadquo> > imagPart (sqrt (-1) )
16:35:05 <lambdabot>   1.0
16:35:06 <Gracenotes> when the t in "Complex t" is a Double, then "Complex Double" is a Floating a
16:35:19 <dadaism_> now I'm confused.  when i :set +t in ghci, sqrt (-1) results in NaN, it  :: Double
16:35:23 <Gracenotes> and so it fits, and Haskell is happy to use complex numbers
16:35:23 <dadaism_> i'm sorry
16:35:33 <pumpkin> dadaism_: you just need to say what type you want it to use
16:35:39 <dadaism_> ah
16:35:41 <pumpkin> using ::
16:35:43 <dadaism_> ok
16:35:50 <dadaism_> makes sense
16:35:54 <dadaism_> thanks a million
16:35:56 <pumpkin> > sqrt (-1) :: Complex Double
16:35:58 <lambdabot>   (-0.0) :+ 1.0
16:36:03 <ski_> dadaism_ : if you use `sqrt (-1)' in a context which requires complex numbers, then you don't need to type annotate
16:36:04 <Gracenotes> dadaism_: if you don't say what kind of type it'll be, Haskell assumes it's a Double by default
16:36:05 <mmorrow> , [$ty| shift |]
16:36:07 <lunabot>  forall a b c d e . RunContM a b c e => ((d -> c b) -> a b) -> a d
16:36:11 <loadquo> Or do something else with the number that implies it is a complex number like I have been doing.
16:36:25 <mmorrow> , [$ty| \x->x |]
16:36:27 <lunabot>  forall a . a -> a
16:36:28 <mmorrow> , [$tyQ| \x->x |]
16:36:31 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
16:36:37 <Gracenotes> ..arrow?
16:36:42 <ski_> dadaism_ : if you use it in a context which doesn't require complex numbers (such as directly in the interactor), then if you want complex numbers, you've have to say so
16:36:50 <pumpkin> Gracenotes: -> :P
16:36:56 <Gracenotes> yes, a bit odd...
16:36:58 <dadaism_> thanks!
16:37:02 <pumpkin> it's just the AST
16:37:13 <Gracenotes> it's partially applying (x->) :P
16:37:17 <mmorrow> the TH
16:37:24 <ski_> mmorrow : `RunContM' ?
16:37:35 <Gracenotes> > let m = (\x ->) x in m 3
16:37:36 <lambdabot>   <no location info>: parse error on input `)'
16:37:37 <mmorrow> monadLib
16:37:39 <dadaism_> now i'm on my way to haskell fun.  thanks all, esp gracenotes pumpkin & ski
16:37:42 <dadaism_> adios
16:37:47 <pumpkin> have fun :)
16:37:54 <mmorrow> ski_: glguy just got shift/reset into the darcs monadLib
16:38:11 <Gracenotes> or, wait... is it partially applying the second x instead?
16:38:16 <ski_> mmorrow : yes .. but that class looks quite ugly
16:38:21 <mmorrow> heh
16:38:29 <Gracenotes> , [$tyQ| \x->y |]
16:38:31 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (ConT Expr))
16:38:43 <ski_> mmorrow : i'm wondering whether there is a reason for it's existence ..
16:38:45 <Gracenotes> watwatwat
16:39:01 <Gracenotes> , [$tyQ| \y-> \x->y |]
16:39:04 <lunabot>  ForallT [a,b] [] (AppT (AppT ArrowT (VarT b)) (AppT (AppT ArrowT (VarT a)...
16:39:27 <ski_> , [$tyQ| y |]
16:39:30 <lunabot>  ConT Expr
16:39:48 <mmorrow> ski_: i'm not that familiar with the class structure in monadLib, but it looks like there're some improvements over mtl
16:40:13 <ski_> (mmorrow : maybe you know a link to docs for it ?)
16:40:13 <mmorrow> ski_: i've been meaning to look at the code though
16:40:17 <Gracenotes> , [$tyQ| \x y z -> contexpr |]
16:40:19 <lunabot>  luna: Exception when trying to run compile-time code:
16:40:21 <mmorrow> oh why yes ;)
16:40:23 <Gracenotes> :\
16:40:37 <Gracenotes> , [$tyQ| \x y z -> x |]
16:40:39 * loadquo will get confused between ConT and Cont
16:40:40 <lunabot>  ForallT [a,b,c] [] (AppT (AppT ArrowT (VarT c)) (AppT (AppT ArrowT (VarT ...
16:40:42 <pumpkin> @seen dons
16:40:42 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 20h 23m 45s ago.
16:40:53 <mmorrow> ski_: just built them an hour ago (with src links!): http://moonpatio.com:8080/docs/monadLib-4/
16:41:01 <ski_> loadquo : don't forget `ContT' !
16:41:25 <ski_> mmorrow : vielen dank
16:41:26 <Gracenotes> where did LamE go?
16:41:35 <mmorrow> loadquo: the TH constructors are nice in that they're all tagged with the first letter of their type in uppercase
16:41:36 <Gracenotes> it made me feel un-LamE
16:41:43 <sbahra> @seen mmorrow
16:41:43 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 9s ago.
16:41:51 <redditbot> HDBC now has a mysql backend!
16:41:51 <mmorrow> sbahra: hey
16:41:56 <sbahra> @tell mmorrow hey
16:41:56 <lambdabot> Consider it noted.
16:42:04 <mmorrow> , [|\x->x|]
16:42:04 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
16:42:05 <lunabot>  LamE [VarP x_0] (VarE x_0)
16:42:21 <mmorrow> omg a massage
16:42:23 <loadquo> mmorrow: Heh, I'll get used to it. Just made me double take for a second.
16:42:25 <pumpkin> @tell sbahra you didn't unpoof!
16:42:25 <lambdabot> Consider it noted.
16:42:31 * sbahra unpoofs
16:42:31 <lambdabot> sbahra: You have 1 new message. '/msg lambdabot @messages' to read it.
16:43:06 <Gracenotes> , [| \x y -> y x |]
16:43:07 <lunabot>  LamE [VarP x_0,VarP y_1] (AppE (VarE y_1) (VarE x_0))
16:43:13 <mmorrow> , src ''Exp
16:43:15 <lunabot>  data Exp = VarE Name
16:43:15 <lunabot>           | ConE Name
16:43:15 <lunabot>           | LitE Lit
16:43:18 <mmorrow> ..
16:43:32 <Gracenotes> E being an expression, T being a...? type?
16:43:35 <mmorrow> , src 'ConT
16:43:37 <lunabot>  data Type = ... | ConT Name | ...
16:43:37 <lunabot>  infixl 9
16:43:45 <mmorrow> , src 'VarP
16:43:48 <lunabot>  data Pat = ... | VarP Name | ...
16:43:48 <lunabot>  infixl 9
16:44:15 <mmorrow> , ['VarE, 'VarP, VarT, 'varE, 'varP, 'varT]
16:44:16 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
16:44:21 <mmorrow> , ['VarE, 'VarP, 'VarT, 'varE, 'varP, 'varT]
16:44:22 <lunabot>  [Language.Haskell.TH.Syntax.VarE,Language.Haskell.TH.Syntax.VarP,Language...
16:44:27 <glguy> ski_, the class exists so that the operations can float up and down the transformer stack
16:44:55 <glguy> ski_, it is ugly because you can use it to change the type that indexes ContT, the final result type
16:45:24 <glguy> without the added ugliness, your delimited continuations must have the same type as the outer scope's
16:46:02 * chrisdone pokes twey
16:46:10 <mmorrow> oh oops, i thought i had src links...
16:48:20 <mmorrow> ski_: ok, now there're src links
16:48:35 <CakeProphet> hmmm... does anyone know a good, free text on artificial intelligence?
16:48:52 <CakeProphet> I'd like to learn the basics and then more.
16:49:19 <X-Scale> start by understanding the Turing Machine -> http://www.youtube.com/watch?v=cYw2ewoO6c4 :)
16:50:16 <ski_> glguy : i'd prefer something inspired by `shift :: ((a -> Cont2 r r o) -> Cont2 q p p) -> Cont2 q o a', if you want to be able to change the answer types
16:50:46 <ksf> bah. I want to be able to write foo (Foo x) = ... ; foo = id
16:50:55 * chrisdone ponders whether "good" and "free" can both be use to describe a text on artificial intelligence
16:51:00 <Twey> Yes, I often wish for this :(
16:51:07 <mmorrow> me too
16:51:17 * ski_ grins
16:51:25 <chrisdone> me2
16:51:44 <chrisdone> happens a lot in instance definitions, I've noticed
16:51:49 <glguy> ski_, that type isn't general enough to write instances so that it can operate on a ReaderT Env (ContT i m)
16:52:12 <glguy> like the rest of the local-run functions, say try, collect, local
16:52:14 <ski_> hence `inspired by'
16:52:26 <pejo> ksf, have you tried uniplate?
16:52:30 <ski_> glguy : the point being that i was two indices
16:52:34 <ski_> s/was/want/
16:53:39 <ski_> (`bind :: Cont2 q p a -> (a -> Cont2 p o b) -> Cont2 q o b', in case you wonder)
16:53:57 <andun> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1049#a1049 what's wrong here? (problem with instances)
16:54:16 <glguy> ski_, where does b' come from?
16:54:24 <glguy> OH, that's just a quotation mark
16:54:35 <glguy> terminating the `
16:55:36 <glguy> ski_, unfortunately I don't see that you'll be able to do what and continue to use do-notation
16:55:47 <glguy> s/what/that
16:56:46 <ski_> that's right
16:57:28 <ski_> (but i'm not convinced the `shift' for `RunContM' is any good)
16:59:47 <ski_> (btw, using two index types, one can do a lot of fun, like
16:59:54 <ski_>     arbitrary = liftM Sudoku $ evalLoopCT $
17:00:17 <ski_>       loopCT [1..9] `thenC2T`
17:00:18 <ski_>       loopCT [1..9] `thenC2T`
17:00:18 <ski_>       lift cell
17:00:32 <ski_>  instead of doing two `forM' loops)
17:01:23 <ski_> (i should mention `loopCT :: Monad m => [a] -> Cont2T [b] b m a', i suppose)
17:04:57 <int80_h> I'm trying to find the best algorithm for finding the lcm of a range of integers.
17:05:04 <int80_h> right now, I'm considering this
17:05:07 <int80_h> http://en.wikipedia.org/wiki/Least_common_multiple#A_method_using_a_table
17:05:20 <int80_h> is there something more elegant?
17:05:36 <int80_h> I'm just talking algorithms. don't want to see a haskell solution
17:08:47 <Gracenotes> int80_h: interesting... except it also requires you to calculate all the primes..
17:08:57 <Gracenotes> ..needed for the calculation, anyway
17:09:07 <int80_h> Gracenotes: I can generate a list of primes easily enough, can't I?
17:09:21 <Gracenotes> just to calculate an LCM? :)
17:09:27 <int80_h> I'm trying something like [1,3,5,7,11 ..] but I get parse errors
17:09:58 <int80_h> Gracenotes: yeah, you're right. Not sure what my options are then
17:10:07 <Gracenotes> [..] only accepts things of the form [a..], [a..b], [a,b..], and [a,b..c]
17:10:29 <int80_h> here's something else, but the notation makes my head hurt
17:10:41 <Gracenotes> corresponding to calling the functions enumFrom, enumFromTo, enumFromThen, and enumFromThenTo
17:10:56 <int80_h> http://en.wikipedia.org/wiki/Least_common_multiple#A_third_method
17:11:42 <Gracenotes> anyway, [..] is only intended to accept arithmetic sequences :)
17:11:53 <ski_> (glguy : btw, i don't want to sound dismissive of the effort .. but i also want the "Right Thing")
17:12:01 <Gracenotes> for numbers, anyway. You could define something more interesting.
17:12:15 <glguy> ski_, I agree that it would be nice to have them so parameterized
17:12:38 <monochrom> int80_h: the notation v^(5) means the value of mutable variable v in iteration 5.
17:13:01 <ski_> (glguy : could you elaborate on why you have both `m' and `n' in `class ... => RunContM m i n j | ...' ?
17:13:03 <int80_h> mutable...ugh. sounds wrong for haskell
17:13:04 <ski_> )
17:13:13 <CakeProphet> @pl (\n -> n`mod` x &&  n `mod`y)
17:13:13 <lambdabot> liftM2 (&&) (`mod` x) (`mod` y)
17:13:22 <monochrom> It's a popular notation among mathematicians who don't use any programming language.
17:13:43 <monochrom> And you know how to functionalize any imperative algorithm,
17:14:27 <Gracenotes> int80_h: so you only want the LCM of 2 numbers, right?
17:14:30 <int80_h> monchrom: I would just generate a new list, instead of altering the old one right?
17:14:38 <CakeProphet> > let lcm x y | x < y = lcm y x | otherwise = head $ filter (liftM2 (&&) (`mod` x) (`mod` y)) [x..] in lcm 10 12
17:14:39 <lambdabot>       No instance for (Integral Bool)
17:14:39 <lambdabot>        arising from a use of `mod' at <...
17:14:41 <Twey> int80_h: Well, it also applies to, for example, map [1..6] (\x -> x + 1) for example
17:14:42 <int80_h> Gracenotes: nope, I want the LCM of a sequence
17:14:51 <Gracenotes> eek
17:14:55 <Twey> xâµ is 5
17:14:58 <Gracenotes> hurray
17:15:05 <int80_h> Gracenotes: specifically [1..20]
17:15:08 <glguy> ski_, Haskell thinks that ContT i m, and ContT j m  are totally different monads
17:15:12 <CakeProphet> @pl (\n -> (n `mod` x) &&  (n `mod`y))
17:15:12 <lambdabot> liftM2 (&&) (`mod` x) (`mod` y)
17:15:20 <ski_> glguy : and they are
17:15:23 <monochrom> would be fun to prove this algorithm correct :)
17:15:35 * monochrom teaches a prove-it-correct course.
17:15:40 <glguy> ski_, and since you can change which monad you are using
17:15:43 <glguy> with a reset
17:15:49 <int80_h> well, if it compiles, it's correct right?
17:15:51 <glguy> you need one parameter for each
17:15:55 <monochrom> hahahahahaha
17:16:05 <glguy> inner and outer
17:16:12 <CakeProphet> > let lcm x y | x < y = lcm y x | otherwise = head $ filter (\n -> n `mod` x == 0 && n `mod`y == 0)  [x..] in lcm 10 12
17:16:13 <lambdabot>   60
17:16:15 <Twey> @pl \z -> liftM2 (&&) (`z` x) (`z` y)
17:16:15 <lambdabot> ap (liftM2 (&&) . flip flip x) (flip flip y)
17:16:17 <monochrom> if it compiles, it spits out a number or it non-terminates
17:16:21 <Twey> Eww.
17:16:45 <glguy> you might also have an instance, RunContM m i n j => RunContM (ReaderT e m) (ReaderT e n)
17:16:48 <int80_h> CakeProphet: please don't give me solutions. I'm looking for an algorithm. Giving me a solution doesn't help me learn
17:16:53 <glguy> you might also have an instance, RunContM m i n j => RunContM (ReaderT e m) i (ReaderT e n) j
17:17:00 <int80_h> I'll have to quite so I don't peek now...brb
17:17:02 <Gracenotes> int80_h: well, take [3,4]. The least element is 3, so try [6,4]. Now it's 4, so try [6,8]. Now it's 6, so try [9,8]. Now it's 8, so try [9,12]. Now it's 9, so try [12,12]. Now everything's the same, so it's 12
17:17:02 <glguy> where the transformed monad is changing
17:17:03 <CakeProphet> int80_h:  ...that is an algorithm.
17:17:06 <Gracenotes> :/
17:17:15 <TomMD> I've unfortunately been forced to use GHC on windows to produce a GUI app (using GHC 6.8.3 due to gtk2hs restrictions).
17:17:22 * Gracenotes cuts CakeProphet's throat
17:17:26 <ski_> glguy : hmm
17:17:28 <TomMD> And in the process I've had trouble making a statically linked binary for distribution.
17:17:37 <TomMD> Does anyone know why -static doesn't work and how to fix that?
17:17:40 <CakeProphet> Gracenotes:  ...what.
17:17:45 <monochrom> Theorem: Haskell programs are algorithms. Proof: by induction on syntax.  Case 0: ...
17:17:53 <int80_h> okay back
17:17:58 <TomMD> ... I've also tried ld.exe from MinGW with no luck (can't seem to find all the libraries)
17:18:01 <glguy> ski_, if you can make a similarly general function with fewer parameters, that'd be cool :)
17:18:05 <int80_h> did I miss anything about possible algorithms?
17:18:13 <Gracenotes> int80_h: I was saying, the algorithm with the math notation is this: >int80_h: well, take [3,4]. The least element is 3, so try [6,4]. Now it's 4, so try [6,8]. Now it's 6, so try [9,8]. Now it's 8, so try [9,12]. Now it's 9, so try [12,12]. Now everything's the same, so it's 12
17:18:22 <Gracenotes> it's probably very slow
17:18:45 <ski_> glguy : i'm not sure how to make this better .. but i could try thinking of something ..
17:18:53 <Gracenotes> keep adding the original elements in a spot, selecting the lowest element each iteration, until everything is equal
17:18:58 <CakeProphet> > let lcm x y | x < y = lcm y x | otherwise = head $ filter (\n -> n `mod` x == 0 && n `mod`y == 0)  [x, 2*x..] in lcm 10 12
17:19:00 <lambdabot>   60
17:19:03 <CakeProphet> wooo faster.
17:19:04 <ski_> glguy : in `shift :: RunContM m i n j => ((a -> n i) -> m i) -> m a' i'm not sure why you really have `n' there
17:19:14 <Gracenotes> CakeProphet: stop it.
17:19:25 <CakeProphet> Gracenotes:  .....why.
17:19:46 <ski_> glguy : afaiu (i could be wrong), the `a -> n i' function there will always be pure, i.e. a `a -> i' function followed by `return'
17:19:47 <Gracenotes> he doesn't want to see the code, why the undefined are you showing it to him?
17:20:10 <int80_h> since Cakeprophet insists on sowing solutions, I'm going to go away for awhile
17:20:18 <int80_h> see you guys
17:20:26 <CakeProphet> ....wat.
17:20:32 <glguy> ski_, I'm heading out, I'll have to continue this after dinner
17:20:37 <monochrom> what is "solution"? how do we know?
17:20:40 <ski_> glguy : ok
17:20:48 <monochrom> how do we know what to avoid?
17:20:58 <Gracenotes> ...anyway. Nevermind.
17:21:01 <int80_h> I don't even want to discuss solutions. I want to discuss algorithms
17:21:06 <CakeProphet> I was mostly making a lcm function for my own benefit. But I still don't see the difference in a "solution" and an "algorithm".
17:21:14 <CakeProphet> in this case, at least.
17:21:17 <int80_h> I can figure out my own solution
17:21:26 <CakeProphet> so why can't you figure out your own algorithm?
17:21:28 <TomMD> Does anyone know how to get '-static' to actually perform static linking on GHC 6.8.3 / Windows
17:21:29 <monochrom> You are not being helpful.
17:21:37 <int80_h> me?
17:21:54 <CakeProphet> YEs.
17:22:12 <monochrom> (The "first strike" principle implies that whoever gets to say "you are not being helpful" first has the moral high ground. :) )
17:22:25 <int80_h> hold on
17:22:39 <Gracenotes> monochrom: it doesn't mean that the other person isn't being helpful, though :)
17:22:44 <monochrom> I don't understand why Haskell code is not algorithm.
17:22:51 <int80_h> CakeProphet, go ahead and do whatever you like. it's okay now
17:22:58 <CakeProphet> ...neither do I.
17:22:58 <Gracenotes> I CAN TAKE IT
17:22:59 <int80_h> I want to figure out the code myself
17:23:16 <CakeProphet> int80_h:  tell me what you would do.
17:23:19 <int80_h> I don't want to pick the wrong algorithm however
17:23:26 <Gracenotes> it's true, math algorithms don't translate *directly* to Haskell code
17:23:57 <int80_h> my first algorithm pick was clearly wrong after talking to Gracenotes about it for awhile
17:24:11 <Gracenotes> wait was it
17:24:26 <int80_h> was it what?
17:24:35 <Gracenotes> guess it was
17:24:41 <int80_h> ???
17:25:05 * ski_ wonders what's being discussed
17:25:25 <int80_h> I'm trying to find a good algorithm for euler project problem #6
17:25:29 <monochrom> lcm algorithms but don't show haskell code.
17:26:06 <Gracenotes> there is also #math, btw, a good channel
17:26:13 <int80_h> ah!
17:26:15 <CakeProphet> int80_h:  well, to me, the most intuitive algorithm would be to check if the remainder of dividing iterative multiples of the larger number by both x and y yields 0 for both.
17:26:17 <Gracenotes> I'm surprised they don't call it #homework-help
17:26:21 <CakeProphet> which is what I just implemented
17:26:45 <Gracenotes> CakeProphet: works for 2 numbers
17:27:02 <int80_h> yes, we can talk algorithms all we want there. But their algorithms might not be computer specific
17:27:30 <Gracenotes> CakeProphet: also, do you anticipate n `mod` x == 0 being false...?
17:27:36 <CakeProphet> ...ah... arbitrary amounts of numbers to test? Use a list and check multiple of maximum list
17:27:37 <int80_h> I mean, the wikipedia page has at least one approach that works on paper easily enough. But as Gracenotes mentioned, not very graceful to compute
17:28:02 <CakeProphet> Gracenotes:  no... I expect it to be True if it's a multiple.
17:28:10 <CakeProphet> and if its false I don't care about it so I get rid of it.
17:28:18 <Gracenotes> which it always will be, right?
17:28:27 <Gracenotes> [x, 2*x..]
17:28:38 <CakeProphet> ...oh, duh.
17:28:46 <CakeProphet> yeah, can omit that condition then.
17:29:07 <Gracenotes> filter ((==0) . `mod` y)
17:29:26 <CakeProphet> :t takeMax
17:29:27 <lambdabot> Not in scope: `takeMax'
17:29:27 <Gracenotes> it is a nice algorithm :) I'm sure there must be algorithms that are less naive, though..
17:29:30 <CakeProphet> :t dropMax
17:29:31 <lambdabot> Not in scope: `dropMax'
17:29:41 <Gracenotes> :t maximum
17:29:42 <lambdabot> forall a. (Ord a) => [a] -> a
17:29:47 <int80_h> Gracenotes, you talking about the table method?
17:29:49 <Gracenotes> :t maximumBy
17:29:50 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:29:58 <Gracenotes> int80_h: talking about CakeProphet's
17:29:59 <CakeProphet> Gracenotes:  there usually always is.
17:30:02 <int80_h> oh
17:30:10 <int80_h> I'm filtering that out
17:30:35 <SamB_XP> int80_h: what, you have him on ignore ?
17:30:51 <Gracenotes> it's not as surprising as you think it is :) You just need to find the first number n for which, for x and y, n divide both x and y
17:31:16 <int80_h> yeah, I didn't want to keep quitting the room, and I don't want to see the haskell code. he keeps insisting on coming up with solutions. That's fine, but I don't have to look.
17:31:18 <Gracenotes> try translating that to code first. It's a simple algorithm, but it works.
17:32:11 <int80_h> Gracenotes: how will that work for a sequence?
17:34:10 <monochrom> "the third method" always produces a cm of the input. you should accept that first.
17:34:27 <int80_h> cm?
17:34:33 <monochrom> lcm?
17:34:36 <Gracenotes> int80_h: it won't work for a sequence
17:34:41 <int80_h> ah
17:34:47 <Gracenotes> of course, you could always foldl1
17:35:09 <monochrom> I still don't know why it should be the l.
17:35:17 <Gracenotes> keep on lcm'ing numbers in a sequence to an accumulator, until it's the LCM of all of them
17:35:33 <int80_h> Gracenotes: that's it right there
17:35:42 <Gracenotes> LCM (a, b, c, d) = LCM(LCM(LCM(a, b), c), d)
17:35:55 <Gracenotes> it's a mathematical property :)
17:36:13 <int80_h> nice
17:36:14 <Gracenotes> there are also other mathematical properties you can exploit, i.e. prime factors, which are more involved
17:36:18 <int80_h> perfect
17:36:28 <CakeProphet> > mapAccumL max [1,2,3,4,5,6,7]
17:36:29 <lambdabot>       Occurs check: cannot construct the infinite type: acc = (acc, y)
17:36:29 <lambdabot>       ...
17:36:33 <CakeProphet> :t max
17:36:34 <lambdabot> forall a. (Ord a) => a -> a -> a
17:36:36 <int80_h> yeah I was trying to go the prime factors route at one point. that didn't work out well
17:36:40 <CakeProphet> ...ah.
17:36:40 <monochrom> Prove that "x divides y" is a partial order. Prove that "lcm" is join (or meet). Then associativity and commutativity of "lcm" follows.
17:37:06 <Gracenotes> partial order -- reflexive transitive antisymmetric?
17:37:10 <monochrom> Yes!
17:37:21 <Gracenotes> !!1!11!shiftone
17:37:36 <ski_> > lcm 1 (-1)
17:37:37 <lambdabot>   1
17:37:58 <int80_h> okay I'm going to write this up
17:38:01 <int80_h> bbl
17:38:04 <monochrom> You are surrounded by partial orders.
17:38:12 <Gracenotes> all alike.
17:38:16 * int80_h surrenders 
17:38:22 <monochrom> haha
17:38:44 <ski_> > lcm 0 0
17:38:46 <lambdabot>   0
17:38:51 <ski_> > gcd 0 0
17:38:53 <lambdabot>   * Exception: Prelude.gcd: gcd 0 0 is undefined
17:38:55 <Gracenotes> You are likely to be eaten by a poset
17:38:55 <ski_> bah
17:39:25 <Gracenotes> > gcd 432989 0
17:39:26 <lambdabot>   432989
17:39:33 <Gracenotes> > gcd 0 432989
17:39:34 <lambdabot>   432989
17:39:38 <ski_> that's right
17:39:49 <chessguy> @remember Gracenotes You are likely to be eaten by a poset
17:39:49 <lambdabot> Done.
17:40:01 <ski_> but (imnsho) `gcd 0 0 = 0'
17:40:26 <CakeProphet> > lcm ls = filter (\n -> all ((==0).(mod n)) ls) [maxn, maxn*2, ...] where maxn = maximum ls in lcm [1..10]
17:40:26 <lambdabot>   <no location info>: parse error on input `='
17:40:35 <CakeProphet> > let lcm ls = filter (\n -> all ((==0).(mod n)) ls) [maxn, maxn*2, ...] where maxn = maximum ls in lcm [1..10]
17:40:36 <lambdabot>   <no location info>: parse error on input `]'
17:40:39 <CakeProphet> ...
17:40:45 <CakeProphet> > let lcm ls = filter (\n -> all ((==0).(mod n)) ls) [maxn, maxn*2..] where maxn = maximum ls in lcm [1..10]
17:40:47 <lambdabot>   [2520,5040,7560,10080,12600,15120,17640,20160,22680,25200,27720,30240,32760...
17:40:51 <CakeProphet> ....oh
17:40:59 <CakeProphet> > let lcm ls = head $ filter (\n -> all ((==0).(mod n)) ls) [maxn, maxn*2..] where maxn = maximum ls in lcm [1..10]
17:41:00 <lambdabot>   2520
17:41:19 <hackage> Uploaded to hackage: bloomfilter 1.2.6
17:41:40 <CakeProphet> Gracenotes:  I don't remove maxn from the list because I figure the mod check isn't slow enough to merit going through the trouble of deleting it from the list.
17:42:23 <CakeProphet> > let lcm ls = head $ filter (\n -> all ((==0).(mod n)) ls) [maxn, maxn*2..] where maxn = maximum ls in lcm [1..1000] --This is going to break
17:42:38 <lambdabot>   thread killed
17:42:47 <CakeProphet> yeah, there's probably a better way to do it.
17:43:17 <Gracenotes> > length . show $ foldl1' lcm [1..1000]
17:43:19 <lambdabot>   433
17:43:44 <CakeProphet> heh
17:44:05 <int80_h> @hoogle foldl'
17:44:06 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
17:44:06 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
17:44:06 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
17:44:21 <monochrom> You are asked to find the lcm of 9, 12, 18. You imagine three infinite stream of multiples, one for each of 9,12,18: [9,18,27,...], [12,24,36,...], [18,36,54,...].  Any number occuring in all three streams is a common multiple.  The smallest one is the least common multiple and you win.
17:44:36 <CakeProphet> ....ah.
17:44:40 <CakeProphet> that's really nice.
17:45:01 <Gracenotes> foldl1' probably wasn't needed, but you never know
17:45:10 <CakeProphet> is there a zip that acts like filter?
17:45:15 * ksf just realized he just implemented a simple capability system, by virtue of writing ideomatic haskell.
17:45:19 <CakeProphet> takes a number of lists, checks them with a predicate and returns one?
17:45:36 <CakeProphet> hmmm...well that won't work.
17:45:45 <CakeProphet> because what kind of list would it return?
17:46:01 <roconnor> ksf: I was confused by capability systems, because it seemed like it was simply good programming style.
17:46:04 <Gracenotes> you mean, head . filter (\xs -> check list) lists
17:46:08 <Gracenotes> $
17:46:08 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
17:46:54 <SamB_XP> what is a capability system ?
17:47:04 <roconnor> good programming style :P
17:47:05 <ksf> roconnor, that's about it. I'm merely passing "putMVar lock ()" into a handler to give it the capability of terminating the program.
17:47:15 <SamB_XP> oh.
17:47:57 <roconnor> SamB_XP: capability systems are as opposed to systems which check security creditials.
17:48:26 <roconnor> SamB_XP: you are allowed to do any operation you are capable of expressing.
17:48:47 <SamB_XP> interesting concept
17:48:50 <roconnor> SamB_XP: security is enforeced by preventing you from expressing insecure operations.
17:48:54 <ksf> the fun thing is that the handler _has_ to use this capability at some time, or the readMVar blocks forever and terminates the program right away.
17:49:16 <roconnor> SamB_XP: instead of, "do I have permission to write in this directory"
17:49:21 <SamB_XP> how can blocking forever cause immediate termination ?
17:49:29 <ksf> So I guess I just pioneered resposibility systems.
17:49:31 <CakeProphet> > let lcm = head $ foldl intersection [] (map (\x -> map EnumFromThen x (2*x))) in lcm [1..10]
17:49:32 <lambdabot>   Not in scope: `intersection'Not in scope: data constructor `EnumFromThen'
17:49:35 <roconnor> it is impossible to even point to directories you have no permission to write to.
17:49:43 <CakeProphet> > let lcm = head $ foldl intersect [] (map (\x -> map enumFromThen x (2*x))) in lcm [1..10]
17:49:44 <lambdabot>   Couldn't match expected type `[a] -> b'
17:49:53 <roconnor> like mounting root as your home directory
17:49:56 <SamB_XP> roconnor: how do you read them ?
17:50:22 <ski_> (ksp : good, we need more responsible systems out there ..)
17:50:22 <CakeProphet> > let lcm = head $ foldl intersect [] (map (map (\x -> enumFromThen x (2*x)))) in lcm [1..10]
17:50:22 <lambdabot>   Couldn't match expected type `[[a]]'
17:50:23 <roconnor> SamB_XP: getting your hands on some read-only file handle, for example
17:50:29 <CakeProphet> bah... have to be the same type.
17:50:34 <ksf> SamB_XP, if the block is the only reference left to the lock, it's gonna block forever.
17:50:51 <ksf> dunno if that's enough to handle all cases, but it goes a long way.
17:51:00 <ksf> the RTS is _really_ stringent about it.
17:51:01 <CakeProphet> > let lcm = head $ foldl intersect [[]] (map (map (\x -> enumFromThen x (2*x)))) in lcm [1..10]
17:51:03 <lambdabot>   Couldn't match expected type `[[[a]]]'
17:51:07 <SamB_XP> it has to wait at least until the GC runs, doesn't it ?
17:51:21 <CakeProphet> @src foldl1
17:51:21 <lambdabot> foldl1 f (x:xs) = foldl f x xs
17:51:21 <lambdabot> foldl1 _ []     = undefined
17:51:21 <SamB_XP> but I guess that happens as soon as nothing can run ?
17:51:33 <ksf> you'd have to ask someone who knows more about ghc than me.
17:51:34 <CakeProphet> > let lcm = head $ foldl1 intersect (map (map (\x -> enumFromThen x (2*x)))) in lcm [1..10]
17:51:35 <lambdabot>   Couldn't match expected type `[[a]]'
17:51:38 <CakeProphet> ...
17:51:40 <CakeProphet> what is it doing.
17:52:44 <CakeProphet> > let lcm ls = head $ foldl1 intersect (map (map (\x -> enumFromThen x (2*x))) ls) in lcm [1..10]
17:52:45 <lambdabot>       No instance for (Enum [a])
17:52:45 <lambdabot>        arising from the arithmetic sequence ...
17:52:50 * ksf is caught in between generalising and specialising an abstraction.
17:52:55 <Gracenotes> @pl \x -> enumFromThen x (2*x)
17:52:55 <lambdabot> ap enumFromThen (2 *)
17:53:00 <Gracenotes> eek :/
17:53:18 <CakeProphet> I always forget what ap does
17:53:24 <ksf> :t ap
17:53:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:53:36 <pumpkin> > [x, 2*x..]
17:53:38 <lambdabot>   [* Exception: not a number
17:53:46 <ksf> :t <*>
17:53:46 <pumpkin> o.O
17:53:48 <lambdabot> parse error on input `<*>'
17:54:09 <ksf> :t (<*>)
17:54:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:54:09 <pumpkin> > let \x -> [x, 2*x..] in x 4
17:54:10 <lambdabot>   <no location info>: parse error on input `in'
17:54:10 <Gracenotes> sweet lambdabot, he gone done love the function application monad
17:54:11 <ksf> ap = <*>, that is.
17:54:17 <pumpkin> > let f x = [x, 2*x..] in f 4
17:54:19 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
17:54:21 <pumpkin> what the hell am I thinking?
17:54:28 <CakeProphet> > let lcm ls = head $ foldl1 intersect (map (map (ap enumFromThen (2*)) ls) in lcm [1..10]
17:54:30 <lambdabot>   <no location info>: parse error on input `in'
17:54:53 <CakeProphet> > let lcm ls = head $ foldl1 intersect (map (map (ap enumFromThen (2*))) ls) in lcm [1..10]
17:54:54 <lambdabot>       No instance for (Enum [a])
17:54:54 <lambdabot>        arising from the arithmetic sequence ...
17:55:05 <CakeProphet> ...where is it attempting to enumerate an arithmetic
17:55:07 <CakeProphet> er
17:55:49 <CakeProphet> a []
17:55:49 <Gracenotes> > let lcm ls = head $ foldl1 intersect (map (map (ap enumFromThen (2*))) ls) in lcm ([1..10]::[Int])
17:55:49 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Int'
17:55:50 <CakeProphet> > let lcm ls = head $ foldl1 intersect (map (ap enumFromThen (2*)) ls) in lcm [1..10]
17:55:52 <CakeProphet> ...wait, why am I using map on map.
17:56:00 <CakeProphet> @src intersect
17:56:00 <lambdabot> intersect = intersectBy (==)
17:56:03 <TomMD> ANN: Control-Engine, the worlds most complex thread pool.
17:56:08 <TomMD> Now on hackage.
17:56:08 <lambdabot>   mueval: Prelude.read: no parse
17:56:53 <Gracenotes> @src intersectBy
17:56:54 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
17:57:06 <Gracenotes> ah, I see
17:57:16 <Gracenotes> intersect needs to see *all* of the elements of a list
17:57:27 <CakeProphet> ah... can't be lazy then. :(
17:57:35 <CakeProphet> or can't be used with infinite lists
17:57:37 <CakeProphet> of course it's lazy
17:57:45 <TomMD> Could make it more efficient if you sort and compare.
17:58:03 <ksf> CakeProphet, it might be procrastinating.
17:58:04 <TomMD> Lazy on xs, not ys.
17:58:54 <CakeProphet> eh... I need to go do other stuff.
17:59:09 <Gracenotes> it possibly could be made lazy if it alternates between adding xs and ys, for instance, and only adds something not already in the list
17:59:41 <Gracenotes> of course, any sort of order would be screwed up
18:00:01 <Gracenotes> er, actually, no, I
18:00:07 <Gracenotes> I'm thinking of union
18:00:47 <CakeProphet> > let lcd a b = (a * b) / (gcd a b) in lcd $ getRandomR (1,1000) (mkStdGen 42) $ getRandomR (1,1000) (mkStdGen 1298)
18:00:51 <lambdabot>   Not in scope: `getRandomR'Not in scope: `getRandomR'
18:01:08 <pumpkin> lcd o.O
18:01:10 <CakeProphet> > let lcd a b = (a * b) / (gcd a b) in lcd $ randomR (1,1000) (mkStdGen 42) $ randomR (1,1000) (mkStdGen 1298)
18:01:11 <lambdabot>   Couldn't match expected type `a -> b'
18:01:13 <CakeProphet> ...
18:01:14 <CakeProphet> oh
18:01:16 <CakeProphet> ha
18:01:22 * CakeProphet is a clutz.
18:01:25 <pumpkin> :)
18:01:33 <pumpkin> people need better names for those
18:01:35 <Gracenotes> lcd is somewhat interesting, too
18:01:39 <pumpkin> they get confused all the time
18:01:44 <SamB> hmm, how can I copy a file into my X selection ?
18:01:47 <Gracenotes> not the drug
18:01:49 <pumpkin> least common denominator?
18:02:00 <Gracenotes> lowest common denominator of two fractions
18:02:13 <Gracenotes> it's basically GCD, iirc
18:02:19 <ksf> is there an Nary Either-type around?
18:02:21 <CakeProphet> ....wouldn't it be... 1?
18:02:23 <CakeProphet> always?
18:02:34 <pumpkin> largest common denominator = lcd :P
18:03:00 <ski_> most uncommon denomination
18:03:00 <Gracenotes> http://en.wikipedia.org/wiki/Lowest_common_denominator
18:03:29 <Gracenotes> hm, it is lcm in disguise
18:04:01 * ksf has to translate it into kgv and ggt, anyways.
18:04:29 <Philippa_> you know you're in trouble when: you're googling something for research and the first hit's from your own web site
18:04:42 <Gracenotes> the KGV is after you!
18:04:58 <kerlo> What if you're researching your own web site?
18:05:36 <ksf> sure there's a nary either, it's called (Integer, a)
18:06:07 <ski_> ksf : i hope you like `Integer -> a' for nary tuples ..
18:06:28 <ksf> I got the feeling that I'm trying to reinvent arrows.
18:12:51 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1050#a1050
18:12:56 <ksf> there's a pattern emerging there.
18:15:59 <TomMD> Since its been a while, I'll re-ask: Does anyone know how to get '-static' to actually perform static linking on GHC 6.8.3 / Windows
18:16:14 <ksf> basically, I'm going to use first' :: a b c -> (b, d) d quite a lot.
18:16:29 <ksf> errr... s/d/c/g
18:17:16 <SamB> TomMD: is that even possible ?
18:17:40 <SamB> TomMD: I'm fairly certain that Windows doesn't support statically linked executables
18:17:45 <ksf> wait... arrows don't include trinary tuples, do they?
18:17:50 <ski_> @kind forall a b c d. a b c -> (b, c) d
18:17:51 <lambdabot>     Kind error: `(b, c)' is applied to too many type arguments
18:17:51 <lambdabot>     In the type `(b, c) d'
18:17:51 <lambdabot>     In the type `a b c -> (b, c) d'
18:22:18 <TomMD> SamB: Humm, ok, thanks.  I use Windows as little as possible and didn't know that.
18:29:01 <wli> I think that may be an artifact of their syscall ABI essentially consisting of a DSO.
18:29:44 <Olathe> Software doesn't exist according to http://book.realworldhaskell.com/
18:31:12 <stepcut> cripe! how to people program in this freakin' imperative languages
18:31:37 <pumpkin> Olathe: what the hell is that?
18:32:00 <pumpkin> and why do they own realworldhaskell.com? :P
18:33:10 <Olathe> pumpkin: http://www.realworldhaskell.com/ redirects properly but that doesn't :)
18:33:23 <pumpkin> that's really random :)
18:34:06 <Olathe> Heheh. Yes.
18:34:06 <Olathe> Now to make a pure Haskell PNG decoder thingy.
18:34:06 <pumpkin> yay
18:34:54 <Olathe> What was that exciting new data type that's so much faster than C for strings or something ?
18:35:04 <coco`> hi
18:35:07 <Olathe> Hello.
18:35:20 <coco`> I hava a cabal problem
18:35:37 <coco`> "cabal haddock --hyperlink-source" fails
18:35:46 <pumpkin> Olathe: ?
18:35:46 <coco`> it says "cabal: hscolour version >=1.8 is required but it could not be found."
18:35:47 <coco`>  
18:36:00 <Olathe> pumpkin: There was something for web serving or something that was supposed to be superfast.
18:36:09 <pumpkin> network-bytestring?
18:36:12 <Olathe> Maybe.
18:37:10 <SamB> arg! attack of the yellow! http://trac.haskell.org/lhc/ticket/9
18:37:32 <omg911> coco`: did you try installing hscolour?
18:37:59 <coco`> ok, I fixed it
18:38:18 <coco`> it was installed, but the  "HsColour" command was not in my PATH
18:38:25 <omg911> ok
18:38:27 <coco`> (it's in ~/.cabal/bin)
18:38:29 <coco`> thanks anyway
18:38:34 <SamB> I wish someone had been there to help the GHC devs with that when they generated the docs for the most recent GHC release
18:41:19 <hackage> Uploaded to hackage: Control-Engine 0.0.1
18:43:44 <ksf> http://hackage.haskell.org/packages/archive/quantum-arrow/0.0.5/doc/html/QuantumArrow-Quantum.html
18:43:45 <ksf> ...
18:43:52 <ksf> fuzzy logic on steroids?
18:54:19 <erikc> wowie, what a day, vancouver game industry is in complete meltdown
18:54:27 <gio123> @seen Cale
18:54:27 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 22h 46m 49s ago.
18:54:48 <flippo> erikc, any particular reason?
18:54:57 <defun> I just tried to install haskeline. Got the following error: (http://pastebin.com/f31befab2). It is complaining about some posix libs. Please help!
18:55:13 <pumpkin> gio123: you do @seen Cale every time you join but you never seem to speak to him :o
18:55:24 <pumpkin> do you just like his name? :)
18:55:31 <gio123> @seen ski_
18:55:31 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I last heard ski_ speak 37m 41s ago.
18:55:43 <intoverflow> pumpkin: obviously.  it's a cool name
18:55:58 <Gracenotes> Stack space overflow: current size 8388608 bytes. ..eek, it all happened so quickly :/
18:56:01 <pumpkin> :)
18:56:25 <Olathe> If (a, isPNG) :: (IO L.ByteString, L.ByteString -> Bool), how do I use isPNG on a to get IO Bool ?
18:57:05 <Olathe> Ahh, got it. a >>= return.isPNG
18:57:53 <erikc> flippo: just the usual 'down economy' stuff, im sure some of the layoffs are just cutting bad hires too of course
18:57:53 <Olathe> @redo a >>= return.isPNG
18:57:53 <lambdabot> do { b <- a; (return . isPNG) b}
18:57:53 <gio123> @seen jhhjg
18:57:53 <lambdabot> I haven't seen jhhjg.
18:58:02 <gio123> @seen arw
18:58:02 <lambdabot> arw is in #haskell. I don't know when arw last spoke.
18:58:16 <pumpkin> gio123: are you a bot? :P
18:58:21 <SamB> ,seen arw
18:58:22 <lunabot>  luna: Not in scope: `seen'
18:58:26 <gio123> :)
18:58:29 <SamB> preflex: seen arw
18:58:29 <preflex>  arw was last seen on #haskell 1 day, 1 hour, 34 minutes and 40 seconds ago, saying: bla123: ldconfig also does soft links. its perfectly ok and expected to use softlinks for that.
18:58:30 <gio123> no
18:58:38 <Olathe> @bot
18:58:38 <lunabot>  :)
18:58:38 <lambdabot> :)
18:58:44 <pumpkin> @boot
18:58:44 <lambdabot> Unknown command, try @list
18:58:46 <SamB> preflex: bot
18:58:46 <preflex>  yes.
18:58:47 <Olathe> Nope, definitely not a bot.
18:58:55 <pumpkin> @bot
18:58:55 <lunabot>  :)
18:58:55 <lambdabot> :)
18:58:55 <pumpkin> :)
18:59:07 <SamB> pumpkin: you faker!
18:59:14 <SamB> no bot responds to its own output!
18:59:18 <pumpkin> Error: unknown command 'you'
18:59:30 <Olathe> They can if their IRC library is good enough.
18:59:39 <gio123> pumpkin: seen pshc
18:59:49 <pumpkin> gio123: who the hell is that?!?
19:00:04 <SamB> pumpkin: you're making a mess!
19:00:05 <gio123> I assumed u are a bot
19:00:07 <gio123> :)
19:00:10 <SamB> I almost got milk everywhere
19:00:20 <pumpkin> pumpkin: version
19:00:26 <pumpkin> negative turing test v 0.1
19:00:49 <gio123> turing test past test
19:00:57 <gio123> because i didnt recongnize
19:01:00 <gio123> u were bot or man
19:01:08 <Gracenotes> pumpkin: say pumpkin: say pumpkin: version
19:01:15 <pumpkin> pumpkin: version
19:01:21 <pumpkin> negative turing test v 0.1
19:01:29 <Gracenotes> pssh, you evaluated it incorrectly
19:01:37 <Gracenotes> inferior bot!
19:02:00 <pumpkin> Gracenotes: I evaluted internally
19:02:31 <Gracenotes> no you didn't; you didn't evaluated "pumpkin: version" internally
19:02:36 <Gracenotes> *evaluate
19:02:55 <pumpkin> I can choose how many iterations to go through
19:03:21 <gio123> what is jet streams?
19:03:42 <Gracenotes> pumpkin: what factors influence your choice?
19:04:12 <pumpkin> my PRNG
19:04:15 <Gracenotes> and why are you contradicting yourself, Mr. Bot?
19:04:56 <pumpkin> I'm not
19:05:03 <gio123> what is jet stream?
19:05:17 <pumpkin> http://en.wikipedia.org/wiki/Jet_stream
19:05:34 <SamB> pumpkin: how does your LHC tree look ?
19:05:48 <gio123>   pumpkin is a bot, i just checked!
19:05:50 <pumpkin> Complete, efficient, and elegant
19:05:55 <Gracenotes> pssh. Bots nowadays, insolent little Pucks
19:06:14 <SamB> pumpkin: RECORD!
19:06:15 <SamB> SEND!
19:06:34 <pumpkin> Invalid command
19:07:57 <gio123> we have to modify  pumpkin in such way to get more  efficient bot
19:08:39 <Olathe> Is there a nicer way to do IO (Maybe a) ?
19:08:57 <wli> You want IO exceptions?
19:09:04 <Olathe> Yes.
19:09:15 <SamB> pumpkin: darcs record --all --look-for-add --skip-long-comment -m 'panacea'
19:09:17 <Olathe> If the file loaded isn't a PNG file, explode nicely.
19:09:22 <Olathe> Or something.
19:09:36 <pumpkin> SamB: Invalid command
19:09:48 <SamB> pumpkin: darcs send --all --to naesten@gmail.com
19:10:09 <pumpkin> SamB:
19:10:17 <pumpkin> Redirecting all spam to naesten@gmail.com
19:10:19 <SamB> oh, darn it, I'm going to get more spam now, aren't I
19:10:32 <SamB> pumpkin: oh, come on, you don't need to send me some too!
19:10:43 <SamB> the channel logs will be bad enough!
19:11:07 <pumpkin> Oh wow, my computer became self-aware while I was in the bathroom
19:11:10 <andun> @ty liftM fromJust
19:11:11 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m a
19:11:20 <andun> Olathe: like that?
19:11:29 <monochrom> visiting the bathroom causes computer self-awareness
19:11:31 <tromp> > let f a b=a:f b$b-a
19:11:32 <lambdabot>   <no location info>: parse error on input `;'
19:11:34 <Olathe> Hmm...what happens with Nothing ?
19:11:38 <Olathe> Explosions ?
19:11:42 <andun> yes
19:11:47 <Olathe> Alright, thanks.
19:11:50 <tromp> @let f1 a b=a:f b$b-a
19:11:51 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
19:11:58 <tromp> @let f1 a b=a:f1 b$b-a
19:11:59 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a -> t'
19:12:19 <pumpkin> what are you trying t odo?
19:12:31 <pumpkin> as it stands, you're callinga list on a subtraction
19:12:35 <tromp> try fibonacci variations
19:12:46 <Olathe> Need a fast Fibonacci ?
19:12:50 <tromp> @let f1 a b=a:f1 b(b-a)
19:12:51 <lambdabot>  Defined.
19:12:59 <pumpkin> fastest fibonacci in the west!
19:13:00 <tromp> @let f2 a b=a:f2 b(a-b)
19:13:01 <lambdabot>  Defined.
19:13:11 <tromp> > f1 0 1
19:13:13 <lambdabot>   [0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,...
19:13:16 <tromp> boring:)
19:13:24 <tromp> > f2 0 1
19:13:26 <lambdabot>   [0,1,-1,2,-3,5,-8,13,-21,34,-55,89,-144,233,-377,610,-987,1597,-2584,4181,-...
19:13:28 <Olathe> @let ffib :: Int -> Integer; ffib n = snd.foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f - g)) where ss = f*f+g*g --by wli
19:13:29 <lambdabot>  Defined.
19:13:34 <tromp> familiar:)
19:13:53 <tromp> > f1 1 2
19:13:54 <lambdabot>   [1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1,1,2,1,-1,-2,-1...
19:14:16 <tromp> > f1 1 4
19:14:18 <lambdabot>   [1,4,3,-1,-4,-3,1,4,3,-1,-4,-3,1,4,3,-1,-4,-3,1,4,3,-1,-4,-3,1,4,3,-1,-4,-3...
19:14:23 <tromp> always cycles
19:15:23 <Olathe> :t f1
19:15:24 <lambdabot> forall a. (Num a) => a -> a -> [a]
19:17:47 <Olathe> > let f1c a b = elem (a, b) $ zip xs (tail xs) where (a:b:xs) = f1 a b in f1c 1 4
19:18:02 <lambdabot>   thread killed
19:19:16 <Gracenotes> yay :D my DROD clone is finally playable. At an extremely rudimentary level.
19:19:43 <pumpkin> DROD?
19:20:31 <Ralith> DROD?
19:21:11 <Gracenotes> http://forum.caravelgames.com/viewsitepage.php?id=68126
19:21:35 <Gracenotes> some more gameplay-ish examples are at http://forum.caravelgames.com/viewsitepage.php?id=68120
19:21:38 <geezusfreeek> dude i saw RWH at barnes & noble a half hour ago
19:21:46 <byorgey> DROD is the categorical dual of DANDD
19:21:59 <Gracenotes> .-.
19:22:14 <Gracenotes> it's neat, though. I just have roaches implemented. And walls.
19:22:25 <geezusfreeek> it was nice to see something classy in with the other programming books
19:23:11 <byorgey> geezusfreeek: nice. =)
19:23:59 * Gracenotes writes a parser for a basic ASCII matrix of a room
19:26:26 <Gracenotes> the heart and soul of the program takes place in processEvents :: Room -> Char -> State Queue Room, which processes a character from the user, passing along a queue of data (so that the caller will know to play a sound effect, for instance) and returning the altered room
19:30:28 <Gracenotes> :t readLine
19:30:29 <lambdabot> Not in scope: `readLine'
19:34:50 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1051#a1051
19:35:02 <int80_h> Think this is a type problem, but I'm not sure how to fix it
19:35:20 <Axman6> pumpkin: you there?
19:35:23 <pumpkin> yup
19:35:34 * int80_h makes pumpkin pie
19:36:00 <pumpkin> int80_h: you're asking for sqrt of an Intege
19:36:01 <pumpkin> r
19:36:17 <pumpkin> Axman6: sup sup?
19:36:19 <Axman6> i was wonderinf, would uvector be a good thing to use to create a list of prime numbers?
19:36:23 <Axman6> s/f/g
19:37:03 <necroforest> anyone in here an electrical engineer?>
19:37:05 <pumpkin> it wouldn't hurt, but a fast sieve is more important
19:37:16 <int80_h> pumpkin, when I pass, say, 1000 to sqrt, it doesn't complain
19:37:22 <blackh> int80h: Try round(sqrt $ fromIntegral n)
19:37:30 <Axman6> necroforest: i've done a course at uni. don't know all that much though. what's up?
19:37:37 <pumpkin> int80_h:
19:37:39 <pumpkin> :t 1000
19:37:40 <int80_h> ah, I don't know about $ yet...can I get an explaination?
19:37:40 <lambdabot> forall t. (Num t) => t
19:37:41 <blackh> int80_h: It's trying to round an integer
19:37:49 <pumpkin> 1000 has any numeric type
19:38:06 <necroforest> I need to know if there's an easy way to figure out the RMS value for a finite sum of sine waves of different frequencies (same amplitude and phase, though)
19:38:06 <blackh> int80_h: round(sqrt $ fromIntegral n) is the same as round (sqrt (fromIntegral n))
19:38:24 <Axman6> :t round . sqrt . fromIntegral
19:38:25 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
19:38:44 <Axman6> @let isqrt =  round . sqrt . fromIntegral
19:38:45 <lambdabot>  Defined.
19:38:51 <int80_h> blackh, but the first is more idiomatic?
19:38:52 <Axman6> > isqrt 10
19:38:53 <lambdabot>   3
19:39:00 <pumpkin> there are much better integer square root algorithms :)
19:39:06 <int80_h> round(sqrt $ fromIntegral n) <- more idiomatic?
19:39:32 <blackh> int80_h: $ is used to get rid of parentheses and make it more readable. It means "parentheses to the end"
19:41:07 <Gracenotes> @hoogle (a -> Int -> b) -> [a] -> [b]
19:41:08 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
19:41:08 <lambdabot> Data.List scanr :: (a -> b -> b) -> b -> [a] -> [b]
19:41:08 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:41:16 <Gracenotes> @hoogle (Int -> a -> b) -> [a] -> [b]
19:41:16 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:41:16 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:41:16 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:42:42 <cknapp> Question: I'm going to write a binomial heap, for the fun of it, and I'm wondering how I should build each tree: should the constructor be (Tree value key [Tree])? or something else?
19:43:37 <pumpkin> Axman6: I think there's some prime sieve in the uvector examples already actually
19:44:02 <Axman6> argh, i hate how it takes up to 4 days for planet haskell to get stories in. my rss stuff in mail keeps getting unread stuff too far down my list :(
19:45:12 <Olathe> > foldr (\a b -> 256*a + b) 0 [a, b, c, d]
19:45:14 <lambdabot>   256 * a + (256 * b + (256 * c + (256 * d + 0)))
19:45:37 <int80_h> oi
19:45:55 <roconnor> > foldl (\a b -> 256*a + b) 0 [a, b, c, d]
19:45:56 <lambdabot>   256 * (256 * (256 * (256 * 0 + a) + b) + c) + d
19:46:15 <Olathe> Ahh, that's it. Thanks.
19:46:29 <roconnor> > foldr (\a b -> a + 256*b) 0 [a, b, c, d]
19:46:30 <lambdabot>   a + 256 * (b + 256 * (c + 256 * (d + 256 * 0)))
19:46:41 <Gracenotes> @pl \x -> take 3 $ x ++ (repeat ' ')
19:46:42 <lambdabot> take 3 . (++ repeat ' ')
19:47:25 <int80_h> isFactor 600851475143
19:47:43 <int80_h> I can't generate more than 4 prime factors
19:47:49 <int80_h> it's hanging
19:48:13 <int80_h> oh wait, maybe there are only 4
19:48:17 <pumpkin> well yeah, factoring is really hard :)
19:48:33 <int80_h> and it's going to keep looking for prime factors that aren't there
19:48:37 <int80_h> I had this problem before
19:48:51 <pumpkin> divide by the ones you're already found
19:49:00 <pumpkin> then stop when you hit 1
19:49:27 <int80_h> I've got the right answer, but my program hangs
19:49:42 <int80_h> I think I know what to do. Use takeWhile
19:50:12 <int80_h> even though I arrived at the right answer, I still feel I need to fix it
19:51:19 <SamB_XP> < floor (sqrt n)
19:51:50 <bombshelter13_> What can I read to learn about implementing an instance of show for my data type?
19:51:57 <gnuvince_> @hoogle [a] -> a -> Bool
19:51:57 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
19:51:57 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
19:51:57 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
19:55:06 <gwern> jeffersonheard: I believe you addressed my RENCI license question
19:56:34 <int80_h> okay I'm trying to use takeWhile to fix my problem
19:57:03 <int80_h> getting the prefix notation wrong I think
19:57:16 <int80_h> findFactor n = [x | x <- (takeWhile ((==) mod x primeList n)]
19:57:27 <int80_h> complains of parse error
19:57:36 <int80_h> oh wait
19:58:19 <Axman6> conal: you around?
19:58:58 <conal> Axman6: for a little bit.
20:00:19 <Axman6> just having a look at that AD stuff you posted recently. i had just lst night thought i might try and make a differentiation package for my own use. you're looks a lot nicer than i would have come up with :P
20:00:26 <int80_h> ack I can't make this work. How do I use takeWhile to get this to terminate?
20:00:38 <int80_h> isFactor n = [x | x <- (primeList n), (n `mod` x == 0)]
20:01:03 <int80_h> I generate the right answer, but it keeps looking for primes
20:01:06 <Axman6> int80_h: i wouldn't use a list comprehension for all of that
20:01:27 <int80_h> okay, I'll re-write. I guess I really like them
20:01:48 <chessguy> err, that looks fine to me
20:01:56 <int80_h> chessguy: it doesn't terminate
20:02:08 <chessguy> int80_h, i mean aesthetically
20:02:22 <int80_h> it will keep looking through the generated lists for primes, even after it's found the highest prime factor
20:02:23 <chessguy> i would write it that way, if it worked :)
20:02:45 <Axman6> well there's a bracket missing for one
20:02:54 <_Jordan_> Hi everyone. I'm writing my first Haskell program, and I'm curious what the right way to do "inheritance" is. I have a type, Foo, with some components. Now what about a Bar, that has the same components as Foo, plus some more?
20:02:59 <int80_h> last time I had a similar problem, I was told to use takeWhile, which fixed the problem
20:03:03 <pumpkin> int80_h: that name is a little fishy :P
20:03:22 <chessguy> int80_h, yeah, i don't really get what you're doing here
20:03:31 <Axman6> jonafan: class Foo a => Bar a where ...?
20:03:48 <chessguy> int80_h, primeList n is the primes in [1..n] ?
20:03:54 <int80_h> I'll change the name, call it findFactor
20:04:01 <pumpkin> _Jordan_: classes and types in haskell don't correspond very cleanly with OO classes, so you might want to learn the haskell paradigm
20:04:07 <conal> Axman6: :) thanks.  i noodled over it a *ton*, getting it very pretty & very general.
20:04:21 <conal> Axman6: am writing a paper about it right now.
20:04:32 <int80_h> primeList is list of primes from [1..(sqrt n)]
20:04:47 <pumpkin> what is n here?
20:04:51 <int80_h> I can post all my code if you like
20:05:01 <Axman6> pumpkin: just wondering about why pi = D pi 0? i guess the pi would stick around when you've got things like pi*x^2?
20:05:13 <chessguy> int80_h, so...why doesn't it terminate?
20:05:22 <int80_h> oh n is 600851475143
20:05:22 <chessguy> primeList always generates a finite list?
20:05:29 <pumpkin> int80_h: I bet it will terminate
20:05:32 <Axman6> int80_h: project euler?
20:05:39 <pumpkin> int80_h: but your prime generator isn't fast enough for you to see that
20:05:42 <chessguy> pumpkin, i bet primeList is broken :)
20:05:54 <chessguy> or non-terminating
20:05:55 <int80_h> chessguy: well I forget the technical reason, but I was told it will keep looking through all primes. I want it to stop once it finds the highest prime
20:06:03 <int80_h> it finds the highest prime, but keeps looking
20:06:12 <int80_h> sure, it will terminate, sometime tommorrow ;)
20:06:14 <pumpkin> int80_h: that's a fairly large number... :P
20:06:21 <pumpkin> at least for naive methods
20:06:31 <SamB_XP> what highest prime ?
20:06:37 <int80_h> pumpkin: the method arrives at the correct answer, that's not the issue
20:06:44 <int80_h> the highest prime is ...
20:06:45 <pumpkin> SamB_XP: 103 is the biggest prime
20:06:59 * Axman6 quite likes his prime generator: primes = 2:L.filter isPrime [3,5..]; isPrime x = L.and . L.map (\n -> 0 /= rem x n) $ L.takeWhile (\n -> n*n <= x) primes
20:07:08 <SamB_XP> why did they bother inventing mersenne primes then ?
20:07:17 <Axman6> mutual recursion!
20:07:20 <int80_h> 103 is not the biggest prime factor of the number I gave
20:07:21 <SamB_XP> and here I always thought there was an infinite number of them
20:07:29 <pumpkin> int80_h: it's the biggest prime of all
20:07:34 <int80_h> lies!
20:07:46 <Axman6> > let primes = 2:L.filter isPrime [3,5..]; isPrime x = L.and . L.map (\n -> 0 /= rem x n) $ L.takeWhile (\n -> n*n <= x) primes in primes !! 10000
20:07:47 <lambdabot>   Not in scope: `L.filter'Not in scope: `L.and'Not in scope: `L.map'Not in sc...
20:08:06 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes !! 10000
20:08:08 <lambdabot>   104743
20:08:08 <int80_h> anyway I'll post my code..hold on
20:08:11 <Axman6> > let primes = 2:filter isPrime [3,5..]; isPrime x = and . map (\n -> 0 /= rem x n) $ takeWhile (\n -> n*n <= x) primes in primes !! 100000
20:08:21 <pumpkin> Axman6: too slow, sorry
20:08:25 <pumpkin> tsk tsk
20:08:26 <lambdabot>   thread killed
20:08:30 <Axman6> but its clean
20:08:53 * Axman6 should chanve the and.map to all
20:08:57 <Axman6> change*
20:09:41 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1052#a1052
20:09:44 <int80_h> there.
20:09:54 <int80_h> go ahead and try it, you'll get the right answer
20:10:03 <int80_h> yeah this is Project Euler problem 3
20:10:05 <pumpkin> I don't doubt it
20:10:19 <int80_h> I've been doing them all day as a way of avoiding chessguy's assignment
20:10:19 <Olathe> Yay ! Just <PNG: [<PNGChunk IHDR: 13 bytes>,<PNGChunk sRGB: 1 bytes>,<PNGChunk gAMA: 4 bytes>,<PNGChunk cHRM: 32 bytes>,<PNGChunk pHYs: 9 bytes>,<PNGChunk IDAT:48728 bytes>,<PNGChunk IEND: 0 bytes>]>
20:10:25 <int80_h> I think it's worked out pretty well ;)
20:10:27 <pumpkin> Olathe: woo!
20:10:38 <chessguy> int80_h, wow, you really need a life :)
20:10:41 <pumpkin> int80_h: what assignment is that?
20:10:41 <Olathe> Now to implement the CRC check.
20:11:14 <int80_h> pumpkin: chessguy wants me to do the graham scan problem from RWH in idiomatic haskell
20:11:28 <int80_h> chessguy: I like my life the way it is thank you very much ;)
20:11:37 <Axman6> > deriv (\x -> exp x) x
20:11:38 <lambdabot>   1 * exp x
20:12:01 <chessguy> actually, that was mean, and not even very funny. i apologize.
20:12:05 <Axman6> conal: does your AD stuff get rid of identities like 1 *?
20:12:26 <int80_h> chessguy: I've made progress on that btw, I just needed a break
20:12:42 <int80_h> I thought I was going to work on calculus today but got sidetracked by project euler
20:12:44 <pumpkin> > 1 * exp x
20:12:45 <lambdabot>   1 * exp x
20:12:46 <chessguy> cool!
20:13:02 <Axman6> :t 1 * exp x
20:13:03 <int80_h> chessguy: partial applications have got me tweaked
20:13:03 <lambdabot> Expr
20:13:09 <chessguy> lol
20:13:29 <int80_h> but I'm glad I went back to re-do this problem. I really shouldn't move on until I understand partial applications
20:13:47 <chessguy> int80_h, prolog has me 'tweaked' at the moment :)
20:14:01 <andun> > deriv (exp . exp)
20:14:02 <lambdabot>       Overlapping instances for Show (a -> a)
20:14:02 <lambdabot>        arising from a use of `s...
20:14:09 <int80_h> anyway, anyone have suggestions for my code? or should I just re-write without a list comprehension?
20:14:19 <Axman6> > deriv (exp.exp) x
20:14:20 <lambdabot>   1 * exp x * exp (exp x)
20:14:24 <chessguy> int80_h, paste your code
20:14:25 <int80_h> I could re-do this without them, if I had to
20:14:28 <int80_h> I did
20:14:33 <int80_h> oh wait...url
20:14:35 <Axman6> > deriv (exp.exp) 10
20:14:36 <lambdabot>   Infinity
20:14:39 <Axman6> :o
20:14:40 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1052#a1052
20:14:43 <chessguy> oh i see it
20:14:43 <int80_h> there it is
20:15:18 <pumpkin> > exp (exp 10)
20:15:19 <lambdabot>   Infinity
20:15:20 <pumpkin> > exp (exp 10) :: CReal
20:15:27 <chessguy> int80_h, ok, don't write primeList as a list comprehension
20:15:28 <pumpkin> :(
20:15:36 <lambdabot>   thread killed
20:15:41 <pumpkin> > exp 10
20:15:43 <lambdabot>   22026.465794806718
20:15:49 <Axman6> augustss: you're not nickaugust on twitter are you?
20:15:55 <pumpkin> > 3 ^22026
20:15:56 <lambdabot>   118237831279092270310442631728679092296044245819251639489538896360156673688...
20:16:02 <pumpkin> alright, I forgive it
20:16:18 <pumpkin> Axman6: nope
20:16:24 <conal> Axman6: that sounds like a symbolic differentiation question, rather than an AD question.
20:16:42 <Axman6> conal: probably is i guess
20:16:43 <chessguy> > let sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] in sieve [2..]
20:16:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:16:47 <conal> Axman6: oh -- unless you mean in infinite derivative towers.
20:17:01 <pumpkin> why towers and not skyscrapers?
20:17:08 <pumpkin> or obelisks
20:17:16 * Axman6 hasn't finished reading the post, and doesn;t know what that is...
20:17:24 <conal> pumpkin: or space elevators!
20:17:30 <pumpkin> ooh yeah!
20:17:37 <chessguy> xkcd++
20:17:38 <int80_h> chessguy: okay, it's inelegant?
20:17:46 <pumpkin> if they're going to be towers at least make them out of ivory
20:17:51 <chessguy> int80_h, there's just no reason for it
20:18:04 <int80_h> chessguy: okay.
20:18:20 * conal toodles off to have dinner.  waves bye-bye for now.
20:18:25 <chessguy> int80_h, it's essentially [x | x <- xs]
20:18:26 <int80_h> findFactor is what hangs. should I re-write that as well?
20:18:30 <chessguy> which is just xs :)
20:18:53 <pumpkin> Axman6: but I'm following him so you can find him if you look ;)
20:18:56 <chessguy> int80_h, one thing at a time
20:19:02 * pumpkin likes to be mysterious
20:19:06 <int80_h> chessguy: are you saying re-write seive or re-write primeList?
20:19:21 <chessguy> int80_h, sieve is fine, i was just checking it. re-write primeList first
20:19:30 <Axman6> pumpkin: well, he's following me, and i was wondering who he is
20:19:34 <pumpkin> :o
20:19:37 <int80_h> chessguy: okay
20:19:42 * Axman6 follows back
20:19:43 <pumpkin> Axman6: mysterious stalker!
20:20:08 * Velociraptors follow Axman6 too. 
20:20:12 <gwern> space fountains are more xkcdish
20:20:13 <pumpkin> :o
20:20:35 <Axman6> this is why i aslways carry steak with me... lots of steak
20:20:40 <pumpkin> mmm steak
20:21:51 * Axman6 feels slightly proud that both Xmonad and galoisinc are following him
20:22:24 <pumpkin> :o
20:22:29 * pumpkin is jealous!
20:23:41 <int80_h> chessguy: here is my re-write
20:23:50 <_Jordan_> Hmm... how I understand it is, a class describes a set of operations, and you can make instances of that class by specializing it on certain types, definining those functions for the instance. Am I right so far?
20:23:51 <int80_h> primeList n = takeWhile (< round(sqrt $ fromIntegral n)) primes
20:23:51 <glguy> ski_, you about?
20:24:10 <chessguy> int80_h, better
20:24:18 <ozy`> Axman6: you see my updated grammar?
20:24:28 <chessguy> int80_h, there's also a bug:
20:24:34 <chessguy> > let primeList n = takeWhile (< round(sqrt $ fromIntegral n)) primes in primeList 10
20:24:35 <lambdabot>   Not in scope: `primes'
20:24:38 <Axman6> ozy`: no, i've got it in my highlight though, i'll try it now
20:24:45 <ozy`> Axman6: all right
20:24:56 <chessguy> > let primes = sieve [2..]; sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0]; primeList n = [x | x <- (takeWhile (< round(sqrt $ fromIntegral n)) primes)] in primeList 10
20:24:58 <lambdabot>   [2]
20:25:06 <int80_h> chessguy: works for me
20:25:14 <chessguy> int80_h, that should be [2,3]
20:25:16 <int80_h> primes = sieve [2..]
20:25:33 <int80_h> oooh
20:25:45 <Axman6> i personally prefer to ony work with odd numbers when dealing with primes, and stick th 2 in front of it all
20:25:49 <int80_h> oops, same bug here
20:26:05 <ozy`> AAAAAAAHHHHH NETSPLIT
20:26:13 <pumpkin> AAAHAAHAAHAAAAAAAA
20:26:30 <Velociraptors> omnomnom.
20:26:44 <pumpkin> oh no, it's Velociraptors
20:27:06 <Axman6> chessguy: i don't like using sqrt when it's not needed, x < sqrt x -> x*x < n
20:27:18 * SubStack is having issues with memory consumption
20:27:20 * Axman6 throws steak furiously!
20:27:39 <SubStack> are there nice ways to track down which parts of the program are using lots of memory?
20:27:40 <chessguy> Axman6, not my code, but you copied his bug :)
20:27:43 <Axman6> SubStack: you think you're someone you're not?
20:27:49 <SubStack> heh
20:27:53 <int80_h> I'm just following the algorithm
20:27:54 <SamB_XP> chessguy: bug ?
20:28:20 * Axman6 feels that removing sqrt is a necessary optimisation
20:28:25 <chessguy> SamB_XP, in primeList n = [x | x <- (takeWhile (< round(sqrt $ fromIntegral n)) primes)]
20:28:41 <chessguy> SamB_XP, (don't tell him what it is)
20:28:54 <SubStack> I'd just like to know which part of my program is responsible for +10% total memory usage / sec as I run this model
20:29:17 * gwern looks quizzically at this mohws-related email. how was i involved in this and why can't I remember anything about it?
20:29:20 <SamB_XP> SubStack: you've heap profiled  ?
20:29:31 <int80_h> chessguy: it's no longer a list comprehension
20:29:33 <chessguy> @pl \x -> x < (round . sqrt . fromIntegral $ n)
20:29:34 <lambdabot> (< round (sqrt (fromIntegral n)))
20:29:45 <SubStack> SamB_XP: I'm not familiar with that
20:29:52 <chessguy> int80_h, oh, yeah, i forgot to copy your new definition
20:29:53 <SubStack> but researching
20:30:12 <SubStack> neat
20:30:50 * SubStack was just looking at the program's usage on top before
20:31:09 <ksf> @src Functor fmap
20:31:10 <lambdabot> Source not found. :(
20:31:17 <ksf> how do i do that?
20:31:22 <ksf> I'm missing source links in my docs...
20:31:30 <ksf> gah.
20:31:32 <Axman6> @check \x n -> n >= 0 ==> x >= 0 ==> (x < (round . sqrt. fromIntegral) n) == x*x < n
20:31:33 <lambdabot>       precedence parsing error
20:31:33 <lambdabot>          cannot mix `(==)' [infix 4] and `(<)'...
20:31:35 <int80_h> primeList 10 give [2], but primeList 100 gives [2,3,5,7]
20:31:37 <ksf> @src Maybe fmap
20:31:38 <lambdabot> fmap _ Nothing       = Nothing
20:31:38 <lambdabot> fmap f (Just a)      = Just (f a)
20:31:40 <Axman6> @check \x n -> n >= 0 ==> x >= 0 ==> (x < (round . sqrt. fromIntegral) n) == (x*x < n)
20:31:41 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
20:31:41 <lambdabot>           ...
20:31:43 <SamB_XP> SubStack: glad to be of service!
20:31:48 <ksf> that's not what I want.
20:32:01 <ksf> foo f x = case f x of
20:32:01 <ksf>     Nothing -> Left x
20:32:01 <ksf>     (Just y) -> Right y
20:32:18 <ksf> is that one somewhere in the libs?
20:32:20 <SubStack> knowing the right words to type into the search box is important ;p
20:32:43 <ksf> @src Maybe (<*>)
20:32:43 <lambdabot> (<*>) = ap
20:32:49 <ksf> @src ap
20:32:49 <lambdabot> ap = liftM2 id
20:33:07 <ksf> @src liftM2
20:33:07 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:33:15 <int80_h> chessguy, I got it! <=
20:33:17 <int80_h> !!!
20:33:18 <int80_h> hahahaha
20:33:35 * int80_h does the newbie super strut
20:33:35 <SubStack> although I'm not entirely sure what to do with this .hp file
20:34:22 <int80_h> chessguy: on to findFactor?
20:34:28 <monochrom> some utility turns it into a postscript file that you can print on a laser printer.
20:35:11 * SubStack installs the profiling libraries
20:35:14 <pastah> i want to do cotan (someRandomAngle)
20:35:27 <monochrom> I haven't profiled for ages, so I don't know the exact names.
20:35:30 <pastah> is theer some Data.* i can use?
20:35:56 <monochrom> > 1 / tan(pi/4)
20:35:58 <lambdabot>   1.0000000000000002
20:35:58 <SubStack> this is for a simplish glut particle system in haskell
20:36:10 <SubStack> instead of c because c isn't any fun
20:36:10 <pumpkin> I think we should all change nick to our favorite haskell function
20:36:27 <monochrom> My favourite haskell function is monochrom
20:36:54 <int80_h> @seen chessguy
20:36:54 <lambdabot> chessguy is in #novalang and #haskell. I last heard chessguy speak 5m 37s ago.
20:37:05 <monochrom> perhaps 80_h is your favourite interrupt
20:37:12 <int80_h> used to be
20:37:22 <monochrom> I forgot what it does.
20:37:26 <int80_h> I've moved on, but my name has remained the same
20:37:26 <nub> magick!
20:37:41 <int80_h> I was thinking of changing to pragma, or knf
20:37:48 <int80_h> think pragma is taken
20:37:59 <nub> cmpxchg
20:38:08 <nub> then you can be an atomic superhero!
20:38:11 <int80_h> I used to me into assembler in a heavy way
20:38:12 <BMeph> rwhnf! :)
20:38:14 <int80_h> be
20:39:02 <int80_h> is BMeph making some kind of xenophobic commentary ? ;)
20:39:23 <unsafeForeignPtr> I figured unsafePerformIO would be too popular... ;)
20:39:26 <SamB_XP> something about restricted weak head normal form ?
20:39:52 <int80_h> knf = kernel normal form
20:40:10 * SubStack interrupts int80_h 
20:40:16 <SuperMan> nuts
20:40:20 <monochrom> read-write head null fault
20:40:23 <SuperMan> I wanted to be SuperMan#
20:40:38 <monochrom> SuperMan# is primitive
20:40:47 <SamB_XP> also atomic!
20:44:10 <SubStack> this graph that the profiler made is sideways >:|
20:44:31 <unsafeForeignPtr> SubStack: Then print it sideways! :)
20:44:32 <SubStack> evince can rotate though, nifty
20:44:35 <SubStack> I guess!
20:44:50 <SubStack> except the printer just ran out of toner
20:45:05 <chessguy> int80_h, sorry, got distracted
20:45:14 <unsafeForeignPtr> SubStack: Or, you could rotate your monitor...naugh. ;p
20:45:15 <monochrom> modern monitors can be turned sideways. modern X support them, too.
20:45:43 <SubStack> wow that output is so unhelpful
20:45:48 <monochrom> hahaha
20:46:03 * unsafeForeignPtr bows in unappreciation
20:46:09 <SubStack> no, the graph
20:46:21 <SubStack> but anyways
20:46:27 <monochrom> There is another program that breaks down memory usuage by top-level definitions (roughly speaking)
20:46:33 <SubStack> oh yeah?
20:47:16 <monochrom> But like I said I haven't done this for a century, so I can't give you names.
20:52:52 <islon_s> i'm too drunk to code anythig -_-
20:53:58 <SubStack> blarg, what's the command that gives useful stuff for .prof files?
20:54:33 <SubStack> wait nevermind, this file is empty
20:55:23 <alsonk> help! I can't get GHC to _not_ look for the 'main' function.  I'm doing -c -no-hs-main, but no luck.
20:55:27 <alsonk> This is with 6.10
20:55:36 <alsonk> I don't think that I've had this issue with 6.8
20:55:53 <islon_s> geeks...
20:56:27 <pastah> sorry, i meant that i needed the arc-functions
20:56:29 <monochrom> If you drink and IRC, you're the real geek.
20:56:45 <pastah> i need to do arcsin/cos/tan
20:57:05 <monochrom> > arctan 1
20:57:06 <lambdabot>   Not in scope: `arctan'
20:57:10 <monochrom> Ah.
20:57:13 <monochrom> > atan 1
20:57:14 <lambdabot>   0.7853981633974483
20:57:30 <pastah> cool, thanks
20:57:34 <pastah> asin 1
20:57:43 <pastah> > asin 1
20:57:44 <lambdabot>   1.5707963267948966
20:57:54 <pastah> > asin 1 == (pi / 2)
20:57:55 <lambdabot>   True
20:57:57 <pastah> weeee
20:58:01 <monochrom> > atan2 (-1) (-1)
20:58:02 <lambdabot>   -2.356194490192345
20:58:03 <islon_s> i was talking with my boss about which is the most weid language, haskell opr lisp
20:58:13 <islon_s> i was advocating against lisp
20:58:16 <pastah> @hoogle atan2
20:58:16 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
20:58:19 <Riastradh> If you're drunk, why are you on IRC, islon_s?
20:58:38 <int80_h> @seen chessguy
20:58:38 <lambdabot> chessguy is in #novalang and #haskell. I last heard chessguy speak 13m 32s ago.
20:58:43 <chessguy> sup
20:58:45 <islon_s> Riastradh, because get drunk and get on irc is fun
20:58:53 <monochrom> Haskell is the weirdest language.
20:59:08 <int80_h> chessguy: primeList is fixed, ready for findFactor
20:59:17 <islon_s> no lisp ir weirder
20:59:20 <islon_s> is
20:59:21 <mm_freak> islon_s: lazy k
20:59:26 <mm_freak> or unlambda
20:59:55 <mm_freak> haskell isn't weird at all, to me it seems much more natural than any other language
20:59:56 <chessguy> int80_h, ...
21:00:03 <chessguy> int80_h, you don't need me :)
21:00:03 <SubStack> aha
21:00:07 <islon_s> yeah thats what i said
21:00:11 <SubStack> it seems as though I suck at drawing spheres
21:00:17 <SubStack> that part was eating up all of the memory
21:00:22 <chessguy> int80_h, for the record, findFactor does terminate, as long as primeList is finite
21:00:24 <monochrom> Haskell is the weirdest because it's both academic and successful.
21:00:30 <SubStack> the slow way uses like 0.9% of memory
21:00:36 <roconnor> haskell is successful?
21:00:40 <int80_h> chessguy: well okay I'll just re-write findFactor as a non list comprehension
21:00:49 <mm_freak> monochrom: good point
21:00:51 <islon_s> but u have to avoid success anyway so it cant be sucessful
21:00:57 <chessguy> int80_h, i don't think you have to, but if you want to, have at it
21:01:01 <int80_h> chessguy: it is supposed to terminate after finding the right answer. it doesn't
21:01:04 <monochrom> we failed to avoid success.
21:01:12 <mm_freak> though haskell isn't too academicâ€¦  it's just mathematical and mostly used by academics
21:01:12 * wli had some garbage on hpaste at some point for prime sieves.
21:01:15 * SubStack looks for some kind of way to destroy glut list thingies
21:01:16 <monochrom> and Tony Hoare predicted it.
21:01:30 <roconnor> all the academics moved to Agda
21:01:41 <islon_s> just because some drunk brazilian guy entered the chanell 3 am it doesnt mean that haskell is sucessful
21:01:56 <islon_s> or is it?
21:02:04 <chessguy> int80_h, well as it's written now, it returns a list
21:02:08 <mm_freak> islon_s: its user base is increasing
21:02:17 <mm_freak> constantly that is
21:02:31 <int80_h> chessguy : I want my list to terminate when the right answer is found. Instead of looking for primes it won't find
21:02:44 <int80_h> as far as I'm concerned, that's a bug
21:02:57 <chessguy> int80_h, so...you only want the first element of the list?
21:02:59 <islon_s> i conviced my java-man-boss to learn haskell, after 3 days he still doesnt understand anything
21:03:15 <Adamant> roconnor: what language are the academics standardizing on now? what happened to Epigram?
21:03:25 <roconnor> islon_s: give him 3 years
21:03:29 <wli> Adamant: He just said Agda.
21:03:30 <int80_h> chessguy: no, I want it to terminate when it finds the largest prime that meets the criteria. It finds that prime, and continues to look for it.
21:03:36 <monochrom> reddit is a measure of success. or at least fuss. Haskell is a big fuss on reddit, Lisp isn't.
21:03:46 <roconnor> Adamant: Epigram 2 is for even more hard core people
21:03:50 <roconnor> it doesn't even exist
21:03:56 <chessguy> int80_h, how can you possibly know when it's found the largest?
21:04:07 <roconnor> I'm not sure why Agda 2 is prefered to Epigram.
21:04:08 <int80_h> chessguy: the largest that meets the criteria
21:04:12 <monochrom> slashdot is another measure of fuss. they have a "not another haskell post again" tag or department or something.
21:04:16 <roconnor> I don't know their differences
21:04:18 <chessguy> int80_h, how can you possibly know when it's found the largest that meets the criteria?
21:04:19 <islon_s> reddit reflect only nerds not real worls
21:04:24 <islon_s> world
21:04:38 <Adamant> islon_s: this is programming, the nerds make the real world here
21:04:42 <int80_h> chessguy: I know when I find a prime that passed the condition I articulate in findFactor
21:05:13 <islon_s> Adamant,   im proud to be a nerd now
21:05:26 <int80_h> chessguy: then, I tested this by giving this number to the project euler page, which then confirmed I hasd the right number
21:05:36 <monochrom> hahahahaha
21:05:44 <int80_h> chessguy: yet, the program still searches *after* it has already found
21:05:44 <chessguy> int80_h, so as soon as you find one prime that is in primeList n, for which n `mod` x == 0?
21:05:53 <Adamant> islon_s: anyway, there are lots of languages weirder than either Lisp or Haskell
21:06:17 <islon_s> but they are so obscure that even nerds never heard of
21:06:36 <wli> Squiggol!
21:06:49 <Adamant> Prolog is sort of strange. the esoteric languages like Befunge, Unlambda, and INTERCAL are really strange, but on purpose
21:06:55 <int80_h> chessguy: hmm, I see. I'm not asking for the right thing
21:06:59 <islon_s> i thought i was a geek till some guy talk about continuation passing in C
21:07:03 <chessguy> int80_h,  :)
21:07:07 <int80_h> okay I'll bbl
21:07:13 <Adamant> APL is sort of there with Prolog
21:07:15 <chessguy> int80_h, you can't say it clearly in haskell if you can't say it clearly in english :)
21:07:19 <wli> Adamant: Mercury, LambdaProlog, etc.
21:07:28 <wli> Adamant: Curry, too.
21:07:34 <Adamant> wli: I put them in the Prolog family
21:07:37 <islon_s> i've learn prolog in the university but i've already forgot
21:07:41 <ksf> @djinn spliceF2 :: Functor f => (c -> a) -> f (Either a (Either b c)) -> f (Either a b)
21:07:42 <lambdabot> Cannot parse command
21:07:52 <Adamant> yeah Prolog is popular in Brazilian universities for some reason
21:07:52 <ksf> @list
21:07:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:08:01 <wli> islon_s: Standard stuff in kernel programming.
21:08:19 <ksf> @help djinn
21:08:19 <lambdabot> djinn <type>.
21:08:19 <lambdabot> Generates Haskell code from a type.
21:08:19 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
21:08:27 <Gracenotes> I'm finding Prolog easier to put off learning than most other languages :)
21:08:34 <ksf> @djinn Functor f => (c -> a) -> f (Either a (Either b c)) -> f (Either a b)
21:08:34 <lambdabot> Error: Class not found: Functor
21:08:54 <Adamant> Gracenotes: I need to get to it as well as Forth/Factor and APL/J
21:09:07 <Gracenotes> Factor is pretty fun :)
21:09:16 <wli> Adamant: Try Squiggol, the language invented for the paper "Functional Programming with Bananas, Lenses, Envelopes, and Barbed Wire." If you like @pl you'll love Squiggol.
21:09:20 <Gracenotes> as for APL, not touching that, but J is on the todo list, I think
21:09:40 <ksf> errr... Functor is in the prelude.
21:09:41 <Adamant> Gracenotes: well J is just updated semi-functionally APL
21:09:42 <Adamant> IIRC
21:09:58 <islon_> the band played pantera, im happy
21:10:00 <Gracenotes> yeah. I'd rather learn the more recent one. Hence, not learning Forth
21:10:15 <wli> There's some K language derived from APL AIUI used in financial circles.
21:10:20 <Adamant> yeah
21:10:29 <Gracenotes> Garbage Collection is nice
21:10:34 <Adamant> I think it's got a database that goes with it as well
21:10:35 <Gracenotes> (automatic)
21:10:38 <ksf> @djinn (c -> a) -> (Either a (Either b c) -> Either a b
21:10:38 <lambdabot> Cannot parse command
21:10:44 <islon_> how can someone live without GC?
21:10:49 <Gracenotes> paren
21:10:50 <Adamant> Gracenotes: Forth is awesome on really small systems
21:11:03 <Gracenotes> yeah, that's true. Factor is huge.
21:11:07 <ksf> @djinn (c -> a) -> Either a (Either b c) -> Either a b
21:11:07 <lambdabot> f a b =
21:11:07 <lambdabot>     case b of
21:11:07 <lambdabot>     Left c -> Left c
21:11:07 <lambdabot>     Right d -> case d of
21:11:07 <lambdabot>                Left e -> Right e
21:11:09 <lambdabot>                Right f -> Left (a f)
21:11:33 <islon_> nobody hacked lambdabot to print lisp code?
21:11:43 <islon_> it would be fun
21:11:47 <Adamant> Gracenotes: someone I know just managed to squeeze a Forth into a payload for memory corruption exploits, he's doing a paper on it
21:11:51 <monochrom> NO.
21:12:03 <Adamant> you could have it print Liskell
21:12:08 <ksf> lambdabot, now the generalised version over N Eithers, please.
21:12:30 <chessguy> err
21:13:07 <Gracenotes> do the internals for djinn use anything like a graph, by chance?
21:13:23 <chessguy> "Because it is possible to directly access program code in Prolog, it is easy to write interpreter of Prolog in Prolog. Such interpreter is called a meta-interpreter"...what does being able to write an  interpreter for a language in that language have to do with code as data? e.g., we can write a haskell interpreter in haskell, but it doesn't represent code as data
21:13:53 <islon_> im starting to gettng sober, i better go
21:13:56 <islon_> o/
21:14:02 <monochrom> "directly access" implies representation.
21:14:08 <Gracenotes> Factor/Forth have code as data. Most of Factor, including the parsers, is written in Factor
21:14:17 <ksf> _Rightf -> Left (a f)_ ???
21:14:27 <Gracenotes> as a result, the language often blurs the line between high-level and low-level :/
21:14:39 * ksf thinks djinn is confused.
21:14:52 <chessguy> Gracenotes, but we can do the same in haskell
21:15:01 <chessguy> yet it's not code-as-data
21:15:14 <ray> you can write one in any language
21:15:26 <ray> but it's famously done in SICP with scheme
21:15:29 <chessguy> oh! this is just saying it makes it _easy_
21:15:34 <ray> which is probably where that comes from
21:15:40 <chessguy> ray yeah, i've seen that
21:15:42 <Gracenotes> yes... but code-as-data is written into the language, not to mention code-as-easily-manipulable
21:15:48 <ray> because lisp does do the code as data thing of course
21:15:53 <rainmann> @type readLines
21:15:54 <lambdabot> Not in scope: `readLines'
21:16:03 <chessguy> for some reason i read "easy" as "possible"
21:16:05 <Gracenotes> there's no way to demarcate something in Haskell and say "parse this differently"
21:18:06 <Gracenotes> it's not a necessary feature, but it makes it ridiculously easy to write embedded domain-specific languages
21:18:13 <Bitrot> Hi. Does anyone here get the new Data Parallel extension?
21:18:16 <Gracenotes> i.e., there's an EBNF parser in Factor
21:19:25 <Gracenotes> or e.g.
21:20:54 <Axman6> Bitrot: what do you mean 'get'?
21:23:15 <T-Cell> how do I get around this: "Could not find module `State': it is a member of package ghc-6.10.1, which is hidden" ...?? this error occurred when I tried to compile a module.
21:24:29 <Axman6> T-Cell: import Control.Monad.State?
21:27:06 <Bitrot> Axman6: Sorry, that was a vague question. Can you help me better understand DPH? I'm not totally clear on how lifting/vectorization work.
21:27:27 <Axman6> what do you mean by lifting?
21:27:33 <bombshelter13_> How do I remove (or add a layer of type synonym-ity? I.e., I have an Int, x, and want to compare it with a Thingy, y, where Thingy is defined as type Thingy = int.
21:28:35 <Axman6> bombshelter13_: toThingy :: Int -> Thingy; toThingy = id
21:28:36 <roconnor> bombshelter13_: same as with data constuctors.
21:28:55 <roconnor> oh
21:29:00 <roconnor> not newtype
21:29:02 <roconnor> just type
21:29:13 <roconnor> Thingy and Int are convertable
21:29:16 <rwbarton> bombshelter13_: You don't have to do anything at all.  Thingy and Int are the same type.
21:29:19 <roconnor> you can just compare directly
21:29:56 * wli feels the pain of the fact that there is no limit to the damage that designing programming languages around the limitations of singlepass compilers of the early 1970's can do.
21:30:28 <ozy`> wli: relevant to bombshelter13_'s question? :p
21:30:49 <bombshelter13_> roconnor: hm, maybe i was doing something else wrong, then
21:31:53 <Bitrot> Axman6: As far as I understand, parallel array comprehensions get desugared into calls to functions like map, zip, etc... DPH then transforms "map f xs" into "fL xs" where fL is the "lifted" version of f. I get how the transformation operates for simple cases, but I'm getting lost with things like nested arrays, arrays of functions, etc...
21:32:05 <wli> ozy`: No. I just got bitten by some lack of modularity in C creating a need for the whole of the Linux kernel to be recompiled for the sake of a trivial change.
21:32:18 <ozy`> wli: aaaarrrghhhh
21:32:28 <Axman6> Bitrot: do you need to know how it works?
21:32:39 <Bitrot> I'd like to
21:33:55 <Axman6> Bitrot: sec
21:34:45 <Axman6> Bitrot: http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
21:34:49 <Axman6> might help
21:35:23 <Bitrot> Oh wow, thanks a bundle
21:35:24 <wli> ozy`: In particular you can only achieve the effect of a macro or inline by exposing its definition in such a way that things that don't use it are also recompiled.
21:36:18 <ozy`> wli: yeah. C can be pretty excruciating in that respect
21:37:07 <ozy`> I long for a language as straightforward as C but without the boneheaded malfeatures that still hold it back
21:37:20 <ozy`> (not that I can be bothered to design it myself)
21:38:05 <unsafeForeignPtr> ozy': What do you think of D, then? :)
21:38:38 <ozy`> unsafeForeignPtr: immediately disqualified for "straightforward," I'm afraid :p
21:39:10 <rwbarton> T-Cell: The ghc package contains interfaces to various bits of GHC the compiler.  Is that really what you're after?
21:40:16 <wli> Cyclone is probably the closest thing out there that's not vaporware that makes any progress toward dealing with my laundry list of things I want dealt with in C, though it does a lot of things I also don't want.
21:40:26 <nelhage> Can someone help with a quick using-the-FFI design question? I have a C function that accepts a char** array of strings, and I have a [ByteString] I want to call it with. What's the easiest way to marshal this?
21:40:38 <ozy`> I looked at cyclone for about ten minutes. too feature-heavy.
21:40:49 <wli> ozy`: Exactly.
21:41:02 <nelhage> I could obviously roll something using useAsCString, but it seems like it'd be messy and there ought be something simpler, offhand.
21:42:15 <nelhage> (The C function won't hold on to the memory, so I'd like something that scopes the memory allocation like useAsCString does)
21:42:59 <T-Cell> rwbarton, I think so .. I need to use a function called systemState which I believe is in that library.
21:43:13 <wli> ozy`: I guess what I really want is a genuine module system for C.
21:43:37 <wli> ozy`: ML functors or whatever.
21:43:45 <rwbarton> T-Cell: Ah yes probably.  Then you want to unhide the package: sudo ghc-pkg expose ghc
21:43:52 <ozy`> wli: that's about what I want, too :p
21:44:08 <ozy`> that, and a decent string library. that's all I ask.
21:44:08 <rwbarton> T-Cell: I think there is a less "stateful" way to do it, but that's the way I know off-hand
21:44:28 <T-Cell> thanks
21:44:30 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1053#a1053 <-- how do I get rid of the occurs check in the nicer definition?
21:46:07 <wli> ozy`: There's probably a lot that could be done, but things are so bad as they now stand I'd like to keep the demands small in the hopes that makes them more likely to be satisfied.
21:46:51 <wli> ozy`: I suppose one could, in principle, write a C front end for some cleaned-up imperative language.
21:46:58 <ozy`> wli: on the contrary, there's so much that can be done so easily (or at least, so much that's tempting to include in the language) that it's hard to resist bloating it to gargantuan proportions
21:46:59 <ozy`> perhaps
21:47:47 <wli> Well, the whole zero runtime impact constraint comes in there.
21:50:16 <rwbarton> nelhage: I don't think there is a much easier way
21:52:49 <Gracenotes> is there a good GTK library for bitmap graphics?
21:53:31 <Gracenotes> <with a Haskell interface ;)>
21:54:16 <nelhage> rwbarton: Hm, ok. I can at least abstract it. I wonder if there's a need for a typeclass with a "useAsC" method or something.
21:54:25 <rwbarton> nelhage: it does seem like there could be a combinator version of withArray with a type like (a -> (b -> IO ()) -> IO ()) -> [a] -> (Ptr b -> IO ()) -> IO () but as far as I can tell you have to write it yourself
21:54:37 <nelhage> Yeah, exactly.
21:54:52 <rwbarton> nelhage: Make a libraries proposal :)
21:55:05 <wli> ozy`: I don't think it's so hard to avoid bloat.
21:55:20 <nelhage> Still new enough I'm not sure where that'd go, but I'll write some code and if it seems clean I'll come back and ask.
21:57:08 <RichardG_> I have a question about technique.  I have a sequence of operations that are performed.  Each operation results in NoResult or Result a.  I want the sequence to evaluate to the first Result and not process any other operations (logical errors can occur).  Are there any built-in constructs (e.g., specific monads) that do this?
21:57:45 <ozy`> wli: well, okay, where it's really hard to avoid screwing around is with the syntax ;)
22:00:55 <ozy`> main(argv : [String]) : () do printf("hello world") end <-- a million unsuspecting programmers just cried out in pain, and were silenced
22:01:22 <wli> ozy`: What's that syntax supposed to be?
22:01:44 <rwbarton> nelhage: Actually, Foreign.Marshal.Utils.withMany solves most of your problem
22:02:06 <Gracenotes> ozy`: hey, what's wrong with {}? :)
22:02:09 <ozy`> wli: "do ... end" instead of "{...}," with pascal/ML style type annotations
22:02:13 <wli> ozy`: I suspect not that many people could smoke out what that means.
22:02:23 <ozy`> Gracenotes: it ought to be reserved for literals
22:02:33 <Gracenotes> { and }
22:02:35 <wli> main() needs a non-void return type, actually.
22:02:54 <ozy`> wli: okay, main(argv : [String]) : Int, then
22:03:18 <Gracenotes> by what would this be interpreted...?
22:03:37 <ozy`> Gracenotes: cosmonauts
22:03:58 <Gracenotes> oh, cosmonautswaitwhat?
22:04:15 <RichardG_> I think I found what I need: Control.Monad.Error and Control.Monad.Error.Class
22:04:36 <nelhage> rwbarton: Ah-ha, awesome
22:04:47 <ozy`> Gracenotes: what are you asking exactly? we're talking about a slightly more modern C replacement, in case you missed that....
22:05:20 <Gracenotes> oh, nothing. Seems a bit... niche, maybe?
22:05:50 <wli> ozy`: Baby steps. Debate each change individually.
22:05:57 <Gracenotes> you're just doing a little syntactic cleanup here and there, right? e.g., You can't just add a GC and still call it C :)
22:06:32 <wli> Gracenotes: I'd avoid certain sorts of cleanups.
22:06:56 <ozy`> wli: I'd still like it to be visually distinct... but yeah
22:07:08 <wli> Where the syntax really does need to get revised is function types.
22:07:12 <ozy`> Gracenotes: no GC, no exceptions, in my opinion.... read that how you want :p
22:07:19 <Gracenotes> to phrase it differently -- how easy or difficult would it be to "translate" between C and your C? Could a machine do it?
22:07:26 <wli> Most people can't write them once they get beyond a certain point.
22:07:51 <ozy`> wli: can't write function types?
22:08:02 <wli> ozy`: They're confusing to a lot of people.
22:09:26 <Gracenotes> I assume it'll be Turing-complete, i.e. you could write the same thing in both languages (preferably without an intermediary Turing machine).
22:10:39 <ozy`> wli: what changes would you make while still making it not-confusing to people who have seen C?
22:11:04 <ozy`> and it still needs to be parseable... LALR(1), certainly, if not LL(1)
22:11:29 <ozy`> Gracenotes: yes, that's the idea ;)
22:12:17 <ozy`> Gracenotes: in fact, semantically it should be nearly identical to C except in the cases where C depends on macros and/or the void pointer
22:12:53 <ozy`> (cf. module system, maybe polymorphic functions?)
22:13:05 <Gracenotes> so the type system, then
22:13:43 <bd_> FWIW, C++0x has a decent idea of function types. std::function<returntype(args)>
22:14:07 <bd_> boost::function somehow manages to implement this Today, too
22:26:35 <wli> ozy`: I wouldn't worry about being too similar to preexisting C/C++ but the C++0x affair is vaguely reasonable.
22:32:26 <X-Scale> If only there was a decent C IDE with a realtime Abstract Syntax Tree engine that analyses the code as Eclipse does for java...
22:34:00 <Gracenotes> @hoogle (a, b) -> (b, a)
22:34:00 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:34:00 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
22:34:00 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
22:34:58 <Ralith> X-Scale: emacs + Semantic, perhaps?
22:39:41 <ksf> @seen conal
22:39:41 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 2h 21m 20s ago.
22:39:56 <conal> ksf: hi there.
22:40:17 <ksf> conal, did you by any chance forget to remove the Show constraint from filterE after hacking around?
22:40:43 <conal> ksf: oops!  yeah.
22:40:46 <conal> thx.
22:41:27 <conal> ksf: i don't see it in my code.  what version do you have?
22:41:34 <ksf> http://hackage.haskell.org/packages/archive/reactive/0.10.5/doc/html/src/FRP-Reactive-PrimReactive.html#filterE
22:41:55 <redditbot> Problem of points using Monte Carlo
22:42:18 <conal> ksf: it'll be gone in the next release.  meanwhile, you can remove it from your copy.
22:43:50 <Olathe> @pl \f n -> n >>= return.f
22:43:50 <lambdabot> fmap
22:44:09 <ksf> I've thought about how I'd like to tie up events, and came up with fanE and spliceE.
22:44:58 <ksf> ...they work kinda similar to what I've posted on reactive, but split and join the Event stream instead of the carried values... as that generalises to pita.
22:44:59 <Axman6> oh hooray, happstack!
22:45:24 <ahunter1> Hey, I'm curious--is there any good large-scale Parsec examples out there?  In particular, I'd like to see a parser for a series of definitions in haskell-ish syntax...
22:51:05 <ski_> glguy : SYN ACK
22:53:45 * ksf is lost in his own types, as usual.
22:57:57 <Olathe> @pl \f x -> fmap (map f) x
22:57:57 <lambdabot> fmap . map
22:58:21 <Axman6> fmap . fmap
22:58:32 <sm> Axman6: yes, see #happs
22:58:46 <Axman6> will do :0
22:59:13 <Axman6> :)*
22:59:17 <Olathe> If I've used splitAt a bunch of times to get a section of a ByteString, how do I copy it to a new ByteString ?
22:59:26 <anthonymiller> can a function return two things, each of different types?
22:59:43 <ski_> anthonymiller : yes and no
22:59:48 <Olathe> > let f x = (x + 1, show x) in f 2
22:59:49 <lambdabot>   (3,"2")
22:59:51 <ski_> just return a pair of the two values
23:00:13 <ski_> > 18 `divMod` 7
23:00:14 <lambdabot>   (2,4)
23:00:26 <ski_> > (18 `div` 7,18 `mod` 7)
23:00:27 <lambdabot>   (2,4)
23:00:42 <anthonymiller> ski_: so tuples can contain different types?
23:00:47 <anthonymiller> @type divMod
23:00:47 <ski_> @type divMod
23:00:48 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
23:00:49 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
23:00:58 <anthonymiller> ah i see
23:01:09 <ski_> yes, they can contain values of differing types
23:01:33 <anthonymiller> but they are constrained to the same typeclass, right?
23:04:20 <_Jordan_> anthonymiller: no, not necessarily
23:05:05 <ski_> @type Data.Map.findMax
23:05:07 <lambdabot> forall k a. M.Map k a -> (k, a)
23:11:52 <Olathe> Oh dear.
23:12:20 <Olathe> > let a = Data.ByteString.Lazy.copy a in a
23:12:35 <lambdabot>   thread killed
23:12:45 <Olathe> That causes ghci to die.
23:13:01 <Olathe> > 5
23:13:02 <lambdabot>   5
23:16:54 <bombshelter13_> how can I be getting a divide by zero error in code that never divides?
23:18:53 <ozy`> bombshelter13_: memetic mutation
23:19:05 <bombshelter13_> wish I knew what that was...
23:19:10 <ski_> bombshelter13_ : maybe code you call divides ..
23:19:11 <ozy`> bombshelter13_: what's the code? are you sure it never divides?
23:19:22 <int80_h> hmm, I wonder how my code could be more efficient
23:19:28 <ski_> or possibly you divide somewhere else, and it's just triggered this late
23:19:47 <bombshelter13_> ozy`: I had one divide, and to test, I commented it out and replaced it with a constant value, still has the exception. :/
23:20:08 <ozy`> bombshelter13_: so you're calling something that divides.
23:20:46 <bombshelter13_> could overflowing integers somehow do it?
23:21:14 <ivanm> bombshelter13_: maybe if you paste the code somewhere... ;-)
23:21:26 <ski_> @where hpaste2
23:21:26 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
23:22:02 <bombshelter13_> it's fairly long at this point :/ i think i may give up for tonight and get to bed, and let people take a look tomorro when they'll have time to decipher it :/
23:22:13 <ozy`> bombshelter13_: sure
23:24:40 <ivanm> is it just me, or does this guy have no idea what he's talking about? http://www.atalasoft.com/cs/blogs/rickm/archive/2009/01/29/f-and-haskell-estranged-cousins.aspx
23:25:30 <ivanm> for example, why use floats when you can use doubles anyway? memory limit?
23:26:14 <bombshelter13_> anyhow... i'll figure it out tomorrow... later!
23:30:35 <newsham> "the fact that itâ€™s a committee language means that if a researcher can get enough support for an idea, they can almost be sure it will be included in the next iteration of the language."
23:30:39 <newsham> heh
23:30:48 <Ferdirand> nice example of cherry-picking argumentation
23:31:05 <newsham> as if msft has ever had a problem pushing around a committee
23:32:56 <newsham> i dont think his arguments support his conclusions.
23:33:01 <ivanm> yeah
23:34:16 <newsham> some of his arguments are silly (you dont need to always wrap partial functions in Maybe)
23:34:49 <newsham> haskell is accused of being too academic and too practical (fast doubles!)
23:35:12 <newsham> i definitely see a lack of direction, but its not in the haskell standard.
23:35:17 <ivanm> and OMG, Haskell throws an error if you try to find the first element of an empty list?!?!?!? :o
23:35:18 <newsham> perhaps his blog is committee designed
23:35:25 <ivanm> newsham: lol
23:35:26 <Raynes> newsham: Someone actually said "Nobody uses haskell" on the talk page of the Haskell wikipedia page.
23:35:40 <ivanm> Raynes: heh
23:35:52 <newsham> (and thats how you ad-hominem!)
23:36:10 <newsham> thank you thank you, next show at 11.  I'll be here all week
23:36:14 <newsham> </awake>
23:36:16 <ivanm> newsham: IMHO, the fact that Haskell is committee designed is great... esp. since I can't think of any other reasonably successful language that was also designed by committee!
23:36:31 <Raynes> They are arguing over whether or not the Haskell page should say that Haskell is the most popular functional programming language in Research right now.
23:36:37 <newsham> ivanm: *shrug* its an attack.  many (most?) things committee designed are of low quality.
23:36:39 <Raynes> They called it a blatant lie and "boasting".
23:36:55 <newsham> but it is not an argument in and of itself.
23:37:14 <newsham> if its so poorly designed it should be easy to come up with valid examples to back up the claim.
23:37:16 <Axman6> newsham: where's this article?
23:37:24 <ivanm> Axman6: http://www.atalasoft.com/cs/blogs/rickm/archive/2009/01/29/f-and-haskell-estranged-cousins.aspx
23:37:30 <newsham> http://www.atalasoft.com/cs/blogs/rickm/archive/2009/01/29/f-and-haskell-estranged-cousins.aspx
23:37:37 <newsham> anyway, i must sleep.
23:38:24 <Raynes> F# isn't a cousin, it's the retarded son in law.
23:38:38 <Olathe> @type ($!)
23:38:39 <lambdabot> forall a b. (a -> b) -> a -> b
23:38:51 <ivanm> Raynes: lol
23:39:08 <ivanm> @remember Raynes F# isn't a cousin [of Haskell], it's the retarded son in law.
23:39:08 <lambdabot> It is forever etched in my memory.
23:39:50 <lament> f# was apparently widely advertised at some recent big MS conference.
23:40:05 <lament> (a general conference for developers, forget the name)
23:40:22 <Raynes> They seem to be very proud of it.
23:41:15 <sjanssen> ivanm: I agree that the guy doesn't really know what he's talking about
23:41:37 <Adamant> ivanm: Ada was pretty successful, but only for what it really should be used for and not all the things people tried to use it for
23:41:37 <ivanm> his excuse is that he's just learning Haskell
23:41:42 <ivanm> in which case, why is he talking about it?
23:41:51 <ivanm> Adamant: *nod*
23:42:00 <ivanm> Adamant: but you've immortalised it in your nick anyway? ;-)
23:42:07 <Adamant> naw
23:42:14 <Adamant> and I'm not Adam Ant either
23:42:23 <ivanm> heh
23:42:36 <Adamant> darn you camel casing
23:42:44 <sjanssen> he claims that committee design is some systemic problem, but can only name trivial things like Int overflow and a couple partial functions
23:42:46 * Axman6 always read it as Ada mant)
23:42:49 <Axman6> -)
23:43:06 <Adamant> I'd prefer A Dam Ant, thanks
23:43:06 <sjanssen> don't most languages with a fixed precision integer type handle it the same way?
23:43:22 <sjanssen> heck, it's the semantics of the underlying CPU operations!
23:43:26 <Adamant> sjanssen: right, and Haskell offers a bignum int
23:43:28 <ivanm> sjanssen: his argument seem to be that in other languages, there's a warning flag or something that tells you that there's an overflow
23:43:39 <ivanm> Adamant: and how dare we offer it! ;-)
23:43:40 <Adamant> uh no
23:43:50 <Adamant> try that in C or C++
23:43:57 <Adamant> or even Java IIRC (check first)
23:44:01 <sjanssen> ivanm: I don't think I've used any like that
23:44:12 <Adamant> there will be no overflow notification
23:44:14 <Olathe> Is there a way to cache something loaded from a file ?
23:44:18 <Axman6> java has BigNum things, but i could never work them out
23:44:34 <Olathe> If I do unsafePerformIO, it seems to memoize it, but not otherwise.
23:44:41 <ivanm> Axman6: yeah, the BigDecimal is a PITA to use
23:44:52 <sjanssen> Axman6: they're not hard, just incredibly inconvenient with method calls rather than proper operators
23:44:58 <Adamant> you'd have to set the overflow bit at the machine level to do it "efficently"
23:44:59 <Axman6> aye
23:45:00 <ivanm> (and I've worked on a project where the lead programmer decided that they were _great_)
23:45:05 <Adamant> and even then it costs a ton
23:45:24 <Adamant> because of how common integer operations are
23:45:24 <sjanssen> Olathe: as a top-level variable?  You'd have to use unsafePerformIO
23:45:26 <ivanm> "There is no way to check the overflow bit. "
23:45:37 <Axman6> ivanm: they probably are for some things, but int64 is probab ly big enough for most purposes
23:45:45 <Adamant> ivanm: I don't know of any language that checks it
23:45:57 <Adamant> maybe SPARK or something ike that
23:45:57 <ivanm> Axman6: well, in the end he was only using it to _display_ numbers, not to do any operations
23:46:04 <Olathe> Is there a way to do unsafePerformIO to get that, but to put it back into IO for great evil ?
23:46:10 <ivanm> and since these where meant to be for assignments.... *shrug*
23:46:22 <sjanssen> Olathe: return $ unsafePerformIO stuff
23:46:33 <Axman6> ivanm: ... right, he's an idiot :)
23:46:42 <Olathe> Ahh, thanks :D
23:46:43 <ivanm> sjanssen: does that remove the unsafeness? ;-)
23:46:52 <Olathe> It now memoizes.
23:47:02 <Olathe> Plus, it looks all IOey
23:47:05 <Axman6> :t return . unsafePerformIO
23:47:05 <sjanssen> ivanm: no
23:47:06 <lambdabot> Not in scope: `unsafePerformIO'
23:47:06 <ivanm> Axman6: well, to be fair to him, he's a mathematician that was asked to lead development of this project, the prototype of which was written in extremely ugly C :s
23:47:08 <Axman6> bah
23:47:29 <Axman6> heh, i see
23:47:52 <Olathe> Axman6: return.unsafePerformIO :: (Monad m) => IO a -> m a
23:48:13 <Axman6> i know :) i was mainly checking if lambdabot knew that really
23:56:49 <anthonymiller> anyone use curry lol
23:57:00 <Axman6> huh?
23:57:13 <_Jordan_> with rice, sometimes...
23:57:38 <lament> :t curry
23:57:39 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
