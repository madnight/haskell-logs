00:00:26 <CakeProphet> another solution is to make a... Haskell interpreter?
00:00:46 <mmorrow> CakeProphet: totally
00:00:49 <CakeProphet> and then undefine just deletes some entry in a hash table.
00:01:31 <Saizan> making an haskell interpreter is not that easy, also it's hard to keep up with GHC's extensions
00:02:46 <CakeProphet> well yeah, I never said it was trivial.
00:03:14 <mmorrow> yeah totally. all of ghc's extensions would be unmanageable
00:03:15 <Saizan> though you could use GHC's typecheker
00:03:20 <CakeProphet> are there any existing Haskell interpreters?
00:03:31 <Saizan> yhc and hugs
00:03:40 <vixey> it's easy to make a interpreter for a tiny haskell like 'thing'
00:03:54 <mmorrow> yeah, i think this is a way. go from external-core -> translate -> translate -> compile to some bytecode -> exec on custom VM
00:04:30 <CakeProphet> we could make it distributed just for fun
00:04:36 <CakeProphet> ...
00:04:40 <mmorrow> but to actually be useful, we'd need one that can handle 100% full ghc haskell
00:04:48 <mmorrow> and isn't slow to boot
00:04:53 <mmorrow> not an easy task :)
00:05:38 <Ralith> implement it in whitespace!
00:05:39 <mmorrow> CakeProphet: yeah, i think there's a bunch of cool stuff that could be done with haskell prog -> bytecode -> network
00:05:43 <Ralith> just for fun, of course.
00:05:52 <mmorrow> easy party
00:05:53 <Ralith> oh, wait, that's actually feasible?
00:06:03 <mmorrow> what?
00:06:07 <mmorrow> byecode -> network?
00:06:09 <Ralith> yeah
00:06:11 <mmorrow> definitely
00:06:16 <Ralith> neat
00:06:20 <CakeProphet> mmorrow:  interpretered/bytecode-compiled allows for all sorts of fun stuff.
00:06:21 <mmorrow> but not with ghc's interpreter and byecode
00:06:33 <Ralith> haskell has nothing if not a wide array of implementation
00:06:34 <Ralith> s
00:06:41 <mmorrow> (without having to do probably the same amount of work it'd take to implement that from a clean slate)
00:06:52 <Ralith> nothing wrong with starting from a clean slate
00:06:56 <CakeProphet> serialization and introspective functions among them
00:07:04 <Ralith> I mean, by the time you've researched an alternative...
00:07:24 <vixey> I don't think it should be very difficult to write a new haskell implementation
00:07:27 <mmorrow> gah, i keep missing the 't' in byecode
00:07:38 <vixey> it would certainly take time though
00:07:57 <pumpkin> mmorrow: you could write a OISC with the only instruction being "bye", then that could sort of make sense
00:08:26 <mmorrow> vixey: i'm working on implementing that lvm (lazy virtual machine) + translation from ghc-ext-core -> lvm bytecode + byecode rts w/ gc and etc.
00:08:32 <mmorrow> pumpkin: l33t!
00:08:54 * vixey is playing sokoban :)
00:08:57 <mmorrow> vixey: write a front-end! :)
00:09:02 * CakeProphet is working on a specification for a massively concurrent language.
00:09:19 <mmorrow> CakeProphet: have you seen TIMBER? it's way cool.
00:09:25 <CakeProphet> Hello World uses, if I recall 11 to 12 threads.
00:09:27 * ski_ . o O ( a sokoban front-end for a haskell compiler ? )
00:09:31 <mmorrow> http://www.timber-lang.org/
00:09:35 <CakeProphet> mmorrow:  the weird trout language?
00:09:37 <vixey> lol hey ski
00:09:40 <mmorrow> http://www.timber-lang.org/index_pubs.html
00:09:42 <CakeProphet> er, salmon or whatever?
00:09:48 <mmorrow> it's new
00:09:51 <ski_> vixey : morning
00:09:58 <CakeProphet> oh... nevermined
00:10:35 <mmorrow> ski_: a haskell compiler to some (specified) "external core" format
00:11:13 <ski_> what does "external core" mean ?
00:11:28 <vixey> some variant of System F(c)(X) I guess
00:11:29 <mmorrow> if someone wrote a spec for a "universal external core" lang for haskell, that would be huge.
00:11:37 <mmorrow> like something analogous to this http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CoreErlang
00:11:53 * ski_ ponders how to detect "cycles" in clauses
00:12:03 <vixey> what's a clause?
00:12:40 <ski_> vixey : like prolog clauses, or haskell defining equations
00:12:53 <ski_> (possibly using `<=>' ..)
00:13:07 <mmorrow> this also looks super interesting http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=183
00:13:16 <vixey> why are you looking for cycles? is this termination analysis?
00:13:27 <mmorrow> ski_: i think you just need to compute the SCCs
00:13:58 <ski_> more like well-definedness checking
00:14:31 <ski_> e.g. if i have `p <=> q' and also `p <=> not q', then i have a cycle (a bad one, in this case)
00:15:07 <mmorrow> ski_: "external core" defined as some universal and minimal representation of haskell, which frontends could target, and backends would only have to worry about translating/compiling starting from that universal rep
00:16:51 <mmorrow> ski_: hmm. i guess something like 'q' and 'not q' can't both be reachable from p, for any p
00:17:53 <ski_> well, initially i think i'll ignore whether there's negation or not
00:18:02 <ski_> i.e. just cycle detection
00:18:28 <ski_> so `p <=> q',`q <=> r',`p <=> r' would also be detected as bad
00:19:07 <vixey> ski_, something occurs to me..
00:19:12 <ski_> but i want to do this for more complicated clauses (otherwise it's fairly trivial)
00:19:21 <vixey> ski_, why is  p <=> q  not a cycle, just this one clause on its own?
00:19:37 <ski_> vixey : because it's just one clause
00:19:38 * vixey wonders  p --> q --> p --> q --> ...
00:19:54 <ski_> if that clause was repeated, i'd probably detect a cycle
00:20:25 <vixey> then, p = q = r ?
00:20:54 <ski_> ideally i want cycles to "commute"
00:21:19 <mmorrow> (p => q and p => not q) => (not q => not p) => (p => not q => not p) => (p => not p) ==> there is at least one edge from `p' to `not p'
00:21:27 <vixey> I was thinking that if you tok each clause  u <=> v  as the constraints {u <= v, v <= u}
00:21:32 <vixey> then a topological sort may work
00:21:32 <ski_> however, i can't avoid trivial cycles which i get by walking back and forward across the same edges
00:21:44 <ski_> so i'll have to handle those cycles anyway
00:21:45 <vixey> but.... the trivial solution is always a solution..
00:21:55 <ski_> and they're not a problem, since they'll always commute
00:22:09 <mmorrow> so (i think) that the "bad cycles" would reduce to the existence of at least one edge from `p' to `not p' (resp. not p to p), for any p
00:22:54 <mmorrow> (one edge transitively)
00:23:06 <vixey> so I guess my question is, what is a cycle?
00:23:47 <ski_> a cycle (on `p') is when one can derive `p <=> p'
00:23:57 <ski_> however, there are always trivial cycles
00:24:11 <ski_> which are harmless
00:24:19 <mmorrow> and a bad one is when you can derive `p <=> not p'
00:24:33 <vixey> so it's like taking the transitive closure, and excluding depth 1 and 2
00:24:35 <mmorrow> actually, that should be
00:24:37 <ski_> (and unavoidable)
00:24:42 <ski_> so i'm only interested in finding non-trivial cycles
00:24:47 <mmorrow> p => not p   or    not p => p
00:25:13 <ski_> mmorrow : at the moment, i approximate "bad" by "non-trivial"
00:25:33 <mmorrow> hmm
00:25:42 <ski_> vixey : that's not enough
00:25:50 <mmorrow> wouldn't a cycle though just be a "TFAE"
00:25:51 <mmorrow> ?
00:25:58 <mmorrow> (the follwing are equivalent)
00:25:59 <ski_> consider `p <=> q',`q <=> r',`r <=> s'
00:26:00 <vixey> why not?
00:26:01 <CakeProphet> mmorrow:  http://esolangs.org/wiki/BugSophia   this is what I'm talking about. Not exactly pratical, just a conceptual thing. I still haven't figured out everything though
00:26:08 <ski_> no non-trivial cycles there
00:26:48 <ski_> mmorrow : "TFAE" ?
00:26:54 <vixey> ski_, what if you just interpret that as the constraints, {p < q, q < r, r < s}?
00:27:10 <vixey> does using < for everything go wrong?
00:27:12 <mmorrow> CakeProphet: wow, super cool.
00:27:39 <ski_> vixey : it could work initially .. but i'd prefer to handle the bi-directional variant
00:27:49 <vixey> oh right it would fail for: p <=> q, s <=> q, p <=> s
00:27:53 <mmorrow> ski_: (like in a book you might read in a theorem:  "The following are equivalent:  (i) ...   (ii) ....  (iii) ....")
00:28:12 <mmorrow> so in you example, p, q, r, s are really just the same exact node
00:28:24 <mmorrow> "by different names"
00:28:52 <mmorrow> ski_: ahh, i think you might want exactly the SCCs
00:29:04 <ski_> vixey : .. you're right
00:29:26 <mmorrow> then if `p' and `not p' are ever in an SCC, then you've got a contradiction
00:29:39 <ski_> mmorrow : maybe .. i'm still trying to figure out what i need
00:30:09 <CakeProphet> mmorrow:  I like this example http://esolangs.org/wiki/BugSophia#Truncated_99_bottles   ...though I can't say I remember what each instruction was supposed to do since I wrote it 2 years ago, but it certainly looks cool.
00:30:22 <ski_> however, `p',`q',`r',`s' above are all the same just for simplicity
00:30:27 * mmorrow just recently appreciated what the SCCs of a graph really say, and now sees applications for them everywhere ;)
00:30:59 <ski_> in more complex examples, those would have arguments, and possibly there would be more than one node on either side of the `<=>'s
00:31:17 <mmorrow> CakeProphet: the fact that it's 2D is great
00:32:19 <CakeProphet> > ord 'c'
00:32:20 <lambdabot>   99
00:32:46 <CakeProphet> ah... `c sets the byte to 99... I was wondering why I did that at the beginning of the counter loop.
00:33:54 <ski_> hm .. maybe one could state this in terms of topology .. or possibly pseudo-topological language
00:34:22 <ski_> i want to find out whether the "graph" spanned by the clauses is simply connected or not
00:34:28 <CakeProphet> oh lawd. pseudo-topological language?
00:34:37 <CakeProphet> actual topological language is pseudo-topological enough.
00:35:00 <ski_> (CakeProphet : i'm not sure there's a sensible notion of open subsets here ..)
00:35:30 <CakeProphet> a = {a}
00:35:46 <CakeProphet> my favorite kind of set is its own subset.
00:36:00 <intoverflow> gaaaaaaaa
00:36:08 <ski_> CakeProphet : ruled out by axiom of foundation, in ZF
00:36:12 <intoverflow> the Rule of Regularity horn is flaring!
00:36:32 <ski_> (of course, maybe you're a follower of Axcel ?)
00:36:59 <CakeProphet> you silly pedant. Obviously I just don't know what I'm doing.
00:37:08 <mmorrow> , text . utf8enc $ "\1791"
00:37:10 <lunabot>  ۿ
00:37:15 <mmorrow> , text . utf8enc $ "\x1791"
00:37:17 <lunabot>  ទ
00:37:25 <alex23> how fast are trigonometric functions in haskell in compare to addition, compare and division? Is the differenz similar to other programming languages like C or Java?
00:37:26 <mmorrow> gah, can anyone see that?
00:37:28 <mmorrow> (i can't)
00:37:51 <CakeProphet> I see a weird blob
00:37:52 <CakeProphet> but otherwise no
00:37:53 <enticingjelly> good morning
00:38:05 <CakeProphet> :t text
00:38:07 <lambdabot> String -> Doc
00:38:07 <enticingjelly> I see a square
00:38:16 <CakeProphet> :info Doc
00:38:32 <CakeProphet> @src Doc
00:38:33 <lambdabot> Source not found. Sorry.
00:38:42 <CakeProphet> text "What /are/ you."
00:38:45 <CakeProphet> > text "What /are/ you."
00:38:47 <lambdabot>   What /are/ you.
00:38:48 <enticingjelly> CakeProphet, this paradox is the reason why lambda calculus got a type system %)
00:38:54 <mmorrow> apparently "\x1791" is http://www.fileformat.info/info/unicode/char/1791/khmer_letter_to.png
00:39:08 <enticingjelly> CakeProphet, self application (think f = f f in haskell) was wrecking logic all over the place
00:39:12 <ski_> , fix (Mu . (:[]))
00:39:16 <lunabot>  Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [Mu [M...
00:39:18 <ski_> CakeProphet : just for you ^
00:39:32 <CakeProphet> :D
00:39:54 <mmorrow> http://esolangs.org/wiki/Category:Two-dimensional_languages
00:39:55 <enticingjelly> CakeProphet, that type system was the very ancestor of our type system in haskell
00:40:01 <mmorrow> , muT [0..4]
00:40:02 <CakeProphet> the universal set is my favorite
00:40:08 <CakeProphet> I only read it once and deduced it was bullshit
00:40:08 <lunabot>  Mu (T (Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (...
00:40:12 <CakeProphet> but aparently it needed proving.
00:40:12 <mmorrow> , muT [0..3]
00:40:17 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
00:40:19 <enticingjelly> CakeProphet, the universal set?
00:40:37 <enticingjelly> what is Mu?
00:40:38 <enticingjelly> :t muT
00:40:40 <lambdabot> Not in scope: `muT'
00:41:09 <CakeProphet> http://en.wikipedia.org/wiki/Universal_set
00:41:18 <CakeProphet> set of all elements/whatever
00:41:24 <ski_> Mu :: f (Mu f) -> Mu f
00:41:47 <vixey> show for Mu!!!
00:41:50 <vixey> great
00:42:02 <vixey> is it possible to read the src?
00:42:06 <enticingjelly> CakeProphet, ah. the set of basically just everything at all
00:42:09 <enticingjelly> nice.
00:42:09 <vixey> , src ''Show.Mu
00:42:11 <lunabot>  luna: Not in scope: type constructor or class `Show.Mu'
00:42:38 <enticingjelly> and... what the hell *is* Mu?
00:43:21 <pumpkin> it's what a Cao says
00:43:25 <vixey> ski, do arguments to a predicate change the cyclicity meaning?
00:43:47 <vixey> Mu takes the least fixed point of a in inductive data of kind * -> *
00:43:50 <athos> hi all!
00:43:51 <ski_> to a zeroth approximation, no
00:44:10 <vixey> so for example Mu Maybe, is  In Nothing, In Just (In Nothing), In Just (In Just (Nothing)), ...
00:44:10 <athos> beautiful morning :)
00:44:45 <vixey> Mu :: (* -> *) -> *; In :: f (Mu f) -> Mu f
00:45:27 <pumpkin> > iterate Just 1
00:45:28 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
00:45:28 <lambdabot>        Ex...
00:45:29 <vixey> oh
00:45:38 <pumpkin> boo
00:45:40 <vixey> In (Just (In (Just (Nothing))))*=
00:45:52 <vixey> In (Just (In (Just (In (Nothing)))))**
00:46:38 <ski_> , iterate (Mu . Just) (Mu Nothing)
00:46:46 <lunabot>  [Mu Nothing,Mu (Just (Mu Nothing)),Mu (Just (Mu (Just (Mu Nothing)))),Mu ...
00:46:47 <mmorrow> , $(let xs = muT (fmap lift [0..7::Int]) in foldT [|()|] (\a b -> [|($a,$b)|]) xs id)
00:46:49 <CakeProphet> has anyone ever needed an Either for three different types?
00:46:51 <lunabot>  (((0,1),(2,3)),((4,5),(6,7)))
00:47:08 <ski_> CakeProphet : yes
00:47:24 <vixey> CakeProphet, sometimes I build up types like  Either a (Either b (Either c (Either d ())))
00:47:27 <enticingjelly> CakeProphet, in that case, maybe you'd better just use your own type?
00:47:28 <pumpkin> CakeProphet: call it Treather!
00:47:52 <ski_> we need light-weight variants !
00:48:14 <ski_> (positional ones, i had in mind, here)
00:48:56 <CakeProphet> vixey:  ...wow
00:49:16 <ski_> , iterate (Mu . (:[])) (Mu [])
00:49:20 <lunabot>  [Mu [],Mu [Mu []],Mu [Mu [Mu []]],Mu [Mu [Mu [Mu []]]],Mu [Mu [Mu [Mu [Mu...
00:49:28 <vixey> why does luna call it Mu instead of roll/In
00:49:33 <vixey> that's a bit odd
00:49:35 <ski_> , 'Mu
00:49:37 <lunabot>  Luna.Mu.Mu
00:50:01 <ski_> mmorrow might mention
00:50:18 <pumpkin> alliteration!
00:51:02 <ski_> (vixey : btw, i hope you mean s/()/Void/ ..)
00:51:16 <CakeProphet> hmmmI should make a useful monad that doesn't akready exist.
00:51:26 <vixey> ski_, ah...h I always forget that
00:51:34 <CakeProphet> :t Void
00:51:36 <lambdabot> Not in scope: data constructor `Void'
00:51:40 <ski_> :k Void
00:51:41 <pumpkin> > let isAlliteration = (==1) . length . group . map head . words in isAlliteration "mmorrow might mention"
00:51:42 <lambdabot> Not in scope: type constructor or class `Void'
00:51:42 <lambdabot>   True
00:51:47 <pumpkin> damn right
00:52:10 <ski_> `Void' is in djinn
00:52:27 <ski_> (which you see if you do `@djinn-env')
00:56:52 <pumpkin> so I'm trying to make an überfast sliding entropy in UArr, but needing to pass a Data.(Int)Map around is hindering my PURE SPEED
00:58:20 <pumpkin> anyone have any suggestions on what to use instead?
00:58:37 <pumpkin> I'm thinking of just trying an array
00:58:50 <pumpkin> something like a MUArr
00:59:26 <pumpkin> it would give me O(len(s)*numuniq(s))
01:00:45 <pumpkin> in fact, I think that's the same bound I have right now
01:00:54 <pumpkin> so it'll probably be better
01:04:34 <pumpkin> anyone here ever play with MUArrs?
01:04:48 <vixey> "We assume some knowledge of category theory and in particular a certain acquaintance with categories of presheaves."... great.. something I know all about :/
01:06:51 <ski_> (vixey : try reading on until you possibly find unintelligble part, then skip or make a detour otherwhere to instantiate the missing parts, if motivated)
01:08:20 <elbar> which ghc version introduced base-3 ?
01:09:13 <augustss> @pl set x = do x' <- x; return (return x')
01:09:14 <lambdabot> (line 1, column 19):
01:09:14 <lambdabot> unexpected ";"
01:09:14 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
01:10:31 <ski_> set = liftM return
01:11:30 <sjanssen> elbar: 6.8.x
01:11:36 * ski_ tries to convince himself he should start small ..
01:12:08 <jonaskoelker> any parsing experts here?  I've found out that CFL --> LR(k) --> LR(1) --> LALR(1), where --> is inclusion of language classes.  Is "L is LR(k) for some k" decidable?  Is there a known algorithm?  Is there a known algorithm for producing a LALR(1) grammar for an LR(k) language?
01:12:23 <elbar> sjanssen: thx
01:33:12 <pumpkin> what are     Inferred type is less polymorphic than expected
01:33:12 <pumpkin>       Quantified type variable `s' escapes
01:33:12 <pumpkin>  errors?
01:35:14 <mmorrow> <vixey> is it possible to read the src?
01:35:19 <mmorrow> vixey: i missed that earlier
01:35:20 <mmorrow> <vixey> is it possible to read the src?
01:35:22 <mmorrow> oops
01:35:25 <mmorrow> <vixey> is it possible to read the src?
01:35:39 <mmorrow> (^V, not button-2 ;)
01:35:47 <mmorrow> oh crap
01:35:50 <mmorrow> i did it again
01:35:55 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=552
01:38:38 <mmorrow> pumpkin: it means you're trying to take the typevar `s' outside of where it's scoped and give it a concrete type
01:38:45 <pumpkin> :o
01:38:59 <pumpkin> I'm just trying to do something relatively simple with MUArr in ST
01:39:00 <mmorrow> , runST (do x <- newSTRef 42; readSTRef x)
01:39:02 <lunabot>  42
01:39:25 <mmorrow> , let stref = runST (do x <- newSTRef 42; return x) in runST (readSTRef stref)
01:39:26 <lunabot>  luna: Inferred type is less polymorphic than expected
01:40:00 <mmorrow> just do everything in ST, then encloses the whole huge final built-up computation in a single runST
01:40:14 <pumpkin> hmm
01:40:28 <pumpkin> I'd just like to figure out what's going wrong though
01:40:38 <pumpkin> maybe I should stay away from unsafeFreezeMU :P
01:40:50 <mmorrow> the `s' in (STRef s a) in escaping from
01:40:51 <pumpkin> but I figured it's unsafe only because it can change, but since I'm not changing it, it should be fine
01:40:52 <mmorrow> @type runST
01:40:53 <lambdabot> forall a. (forall s. ST s a) -> a
01:41:37 <mmorrow> data ST s a = ....
01:42:02 <mmorrow> data F a = forall s. F (ST s a)
01:42:51 <mmorrow> you can do unsafeSTToIO if you want
01:42:58 <mmorrow> also, unsafeIOToST
01:43:05 <pumpkin> nah, I'm afraid of IO :)
01:43:09 <mmorrow> heh
01:43:34 <mmorrow> (in ghc) IO a = ST RealWord a
01:43:49 <pumpkin> yeah, I'm afraid of the real world :P
01:43:49 <mmorrow> *RealWorld
01:43:57 <mmorrow> fair enough :)
01:44:16 <mmorrow> ST is pretty cool
01:44:23 <pumpkin> I probably shouldn't be mucking around with MUArr like this
01:44:44 <mmorrow> ohhhh, MUArr
01:44:44 <mmorrow> i thought you said STUArr
01:45:00 <pumpkin> nope :) still sits in ST
01:45:03 <mmorrow> ah
01:48:01 <pumpkin> I'm trying to fold passing a MUArr inside the fold
01:51:37 <tgoddad> hello
01:53:03 <pumpkin> sooo... I'm trying to get this to work, but I may have some fundamental issue with it: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=754#a754
01:54:06 <pumpkin> it's supposed to be the beginnings of an entropy function, but looks nothing like it right now
01:54:18 <pumpkin> and doesn't compile
01:54:56 <tgoddad> why the const?
01:55:03 <tgoddad> won't that always return 5?
01:55:05 <pumpkin> yeah
01:55:17 <pumpkin> I didn't feel like writing the rest, I just wanted to get it to compile
01:55:52 <tgoddad> what's it supposed to do?
01:57:00 <pumpkin> whoops, it's supposed to be UArr Int, not Double
01:57:00 <vixey> thanks mmorrow
01:57:04 <pumpkin> but basically
01:57:46 <pumpkin> it's supposed to take the largest int in xs as first parameter, a width (not used) and xs itself
01:58:10 <pumpkin> create a new MUArr of the size of the largest int, and then iterate over xs incrementing the created MUArr at the index of the current int in xs
01:59:04 <pumpkin> so I'm basically trying to use a MUArr as "fold state" in that foldU over xs
02:00:55 <pumpkin> make any sense?
02:03:16 <tgoddad> yeah, I see
02:04:06 <tgoddad> It seems a bit complicated to be using the state monad instead of a fold
02:04:19 <pumpkin> :P
02:04:27 <pumpkin> yeah
02:04:47 <pumpkin> well, I'm using both ;)
02:06:23 <pumpkin> omg a westbaer
02:06:48 <westbaer> omg pumpkin :o
02:06:55 <pumpkin> tgoddad: I've written this the "good" way a few times before, am mostly just trying to see how much speed I can squeeze out of it by using unboxed fused types
02:07:10 <tgoddad> ah :)
02:08:06 <pao> Hi all! I've recall I've heard GHC 6.8.3 is better than 6.8.2... is that true? can anyone elaborate, pls?
02:08:20 <pao> ops!
02:08:32 <pao> the contrary: 6.8.2 is better than 6.8.3
02:09:28 <pumpkin> > let (>) = (<) in 5 < 3
02:09:29 <lambdabot>   False
02:09:39 <pumpkin> > let (>) = (<) in 5 > 3
02:09:41 <lambdabot>   False
02:10:49 <Gilly> pumpkin: :)
02:11:52 <vixey> pao, it doesn't matter much since 6.9 is better than them both
02:13:27 <pumpkin> Gilly: :o
02:15:07 <Gilly> pumpkin: a funny "falsifying" statement :P
02:31:49 <mmorrow> pumpkin: from that paste, it looks like you need some customized foldM variant
02:33:11 <mmorrow> (customized foldM because you probably want to do s/[b]/MUArr b s/)
02:33:29 <maltem> Having finally read the Stream Fusion paper: What is the motivation for the existential in 'Stream'? Would something break if that type were just a parameter of 'Stream'?
02:33:40 <tgoddad> I don't really get that snippet
02:33:45 <tgoddad> I may be missing the point
02:33:47 <mmorrow> i looked at the haddocks, and it seems like such a function would be super useful, but it doesn't currently exist
02:35:34 <Saizan> maltem: you couldn't e.g. have a stream of streams which use different types for their internal state
02:36:01 <tgoddad> It looks like readMU and writeMU are State (UArr e), not a State (MUArr e)
02:36:28 <maltem> Saizan: when you have nested streams... thanks that makes sense
02:36:40 <mmorrow> maltem: (just peeked at the def of Stream) that looks related to the "Step" type in the "Polish Parsing" paper
02:36:47 <tgoddad> And the state function doesn't look how I would expect at all
02:37:17 <Saizan> maltem: or any other collection of them, really
02:37:24 <maltem> @where polish parsing
02:37:24 <lambdabot> I know nothing about polish.
02:37:38 <mmorrow> tgoddad: (are you talking about pumpkin's paste?) there are some type errors
02:37:42 <maltem> Saizan: yep I see
02:38:29 <mmorrow> @where+ polish http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf
02:38:29 <lambdabot> I will never forget.
02:38:36 <mmorrow> @where+ polish parsers http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf
02:38:36 <lambdabot> Good to know.
02:38:49 <mmorrow> @where+ polish parsing http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf
02:38:49 <lambdabot> Done.
02:39:11 <maltem> ah splendid
02:39:14 <mmorrow> :)
02:39:28 <mmorrow> that's a neat paper
02:40:33 <EvilTerran> mmorrow, you know you just created a single entry for "polish" with the text "parsing http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf" ?
02:40:37 <EvilTerran> ?where polish
02:40:37 <lambdabot> parsing http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf
02:40:48 <mmorrow> EvilTerran: heh, i didn't know that
02:40:57 <mmorrow> oh
02:41:04 <mmorrow> ah
02:41:20 <mmorrow> @where+ polish http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf
02:41:20 <lambdabot> Good to know.
02:41:26 <mmorrow> @where polish
02:41:26 <lambdabot> http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf
02:42:47 <maltem> Besides, why don't most Haskell papers have page numbers?
02:43:00 <BrokenClockwork> @src interact
02:43:00 <lambdabot> interact f = do s <- getContents; putStr (f s)
02:43:10 <BrokenClockwork> what's the interact function?
02:43:17 <maltem> Am I supposed to infer them?
02:44:04 <BrokenClockwork> I have a task where I have to use interact, but I have no idea what this is supposed to mean - I mean it's kind of a do function, but huh.. ?
02:44:05 <tgoddard> BrokenClockwork - it allows your program to accept a string of input and produce a string of output
02:44:14 <BrokenClockwork> oh
02:44:21 <maltem> BrokenClockwork: it reads from stdin, processes the read contents with the function f, and prints the result to stdout
02:44:29 <BrokenClockwork> I have to test a string for palindrom, I think this is it
02:44:34 <BrokenClockwork> okay :)
02:44:44 <EvilTerran> ?type interact
02:44:45 <lambdabot> (String -> String) -> IO ()
02:45:00 <BrokenClockwork> abny examples?
02:45:05 <BrokenClockwork> any examples?*
02:45:42 <tgoddard> main = interact (\a -> "Hello, " ++ a)
02:46:09 <vixey> @hoogle HughesPJ
02:46:10 <lambdabot> module Text.PrettyPrint.HughesPJ
02:46:11 <tgoddard> ./a.out <<< World
02:46:23 <vixey> @hoogle (--$$)
02:46:23 <lambdabot> No results found
02:46:29 <vixey> @hoogle (--<+>)
02:46:30 <lambdabot> No results found
02:46:53 <maltem> vixey: hoogling comments?
02:47:17 <vixey> --<+> isn't a comment
02:47:22 <vixey> so no
02:47:33 <EvilTerran> BrokenClockwork, interact (map Data.Char.toUpper)
02:47:34 <mmorrow> , runST (do mu <- newMU 1024; forM_ [0..1023] (\i -> writeMU mu i i); unsafeFreezeMU mu (lengthMU mu))
02:47:36 <lunabot>  toU [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
02:47:54 <maltem> oh... indeed, even though ---- is
02:48:02 <maltem> stupid Haskell syntax
02:48:19 <tgoddard> ssh - you'll hurt lambdabot's feelings
02:48:29 <EvilTerran> BrokenClockwork, interact (filter (not.null) . lines) would also be potentially useful
02:48:34 <EvilTerran> maltem, ---- is comment?
02:48:49 <maltem> > ----
02:48:50 <lambdabot>   <no location info>: parse error on input `;'
02:48:57 <maltem> > 2 ----
02:48:59 <lambdabot>   2
02:49:07 <mmorrow> > 3 ---
02:49:08 <lambdabot>   3
02:49:13 <vixey> any line of -------------------------------'s is a comment
02:49:17 <mmorrow> > 3 --|
02:49:18 <lambdabot>   <no location info>: parse error on input `;'
02:49:34 <BrokenClockwork> hm, still asking myself, why I should use this for a function which tests a string for palindrome
02:49:58 <tgoddard> Because it cuts out the IO and makes you work purely
02:50:01 <maltem> BrokenClockwork: you wouldn't need it for that function specifcally, but you'd want to have a way to test your function
02:50:44 <BrokenClockwork> yes, but what means test? I would jsut call the function: palin "otto" -> True
02:50:58 <BrokenClockwork> that's it ... mh
02:51:14 <tgoddard> I assume this is an assignment of some sort?
02:51:34 <BrokenClockwork> sure
02:51:41 <tgoddard> Whoever set it probably specified that to ensure that they didn't get any solutions with isPalindrome :: String -> IO Bool
02:51:45 <maltem> BrokenClockwork: right, it would give you back a boolean, but then, how do you run the program? (given that you wouldn't ask your user to launch ghci)
02:51:56 <BrokenClockwork> lol
02:52:37 <vixey> mmorrow, I think I /will/ write a frontend for a system F-ish thing
02:52:40 <BrokenClockwork> using a haskell programme without ghci?
02:52:51 <mmorrow> vixey: yippee!
02:53:10 <maltem> BrokenClockwork: erm, ghci is a developer's tool for debugging
02:53:21 <vixey> mmorrow, but I think I would like to try type level lambdas and some things like that
02:53:26 <mmorrow> vixey: consider targeting PiSigma maybe
02:53:30 <mmorrow> yeah, totally
02:53:36 <BrokenClockwork> how to run it else, jesus christ, never heard of using a haskell programme without GHC ^^
02:53:52 <mmorrow> dependent types ftw
02:54:01 <maltem> BrokenClockwork: ghc /= ghci; and once the program is compiled, you don't even need ghc anymore
02:54:15 <vixey> mmorrow, implementing dependents types is soo hard :( .. I think this could be good practice
02:54:31 <maltem> BrokenClockwork: ghc is a compiler you know :)
02:54:35 <BrokenClockwork> yes
02:54:45 <vixey> you can make a standalone binary with --make
02:55:01 <enticingjelly> :t interact
02:55:03 <lambdabot> (String -> String) -> IO ()
02:55:18 <mmorrow> vixey: check out the cayenne src for an example of doing it start-to-finish
02:56:40 <Saizan> i'd go the PTS way
02:57:11 <mmorrow> lexer, parser, printer, a few translations steps, type checking, support data structures/types, prettyprinting, reading in/writing out interface files, main wrapper that invokes external program.
02:57:28 <mmorrow> no  biggy ;)
02:57:51 <vixey> mostly NbE is what's confusingest
02:58:01 <mmorrow> pts looks cool
02:58:06 <vixey> and which primitives to have for inductive types and functions/eliminations
02:59:00 <mmorrow> this is interesting, re: pts and type erasure http://web.cecs.pdx.edu/~sheard/papers/FossacsErasure08.pdf
02:59:04 <vixey> mmorrow, is there an interpreter or whatever for PiSigma that I can run locally?
02:59:07 <BrokenClockwork> maltem: http://cod3po37ry.blogspot.com/2007/02/more-on-haskell-io-and-interact.html this should be about interact, shouldn't it?
02:59:31 <mmorrow> vixey: not an interp, but there is a cgi prog that will give you typechecked output
02:59:46 <mmorrow> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=183
02:59:55 <mmorrow> http://sneezy.cs.nott.ac.uk/cgi-bin/PiSigma
03:00:50 <mmorrow> here's two decls that type check in that cgi-prog http://hpaste.org/13164
03:01:02 <mmorrow> (both of which are general recursion :)
03:01:06 * Saizan now wants a mmorrow rss feed
03:01:35 <mmorrow> heh
03:02:44 <vixey> hey you could write a mutual that takes a number and gives a fixpoint for n mutually recursive functions
03:05:10 <mmorrow> interesting
03:28:20 <vixey> how do you parse something like  id Bool True  as  App (APP id Bool) True
03:28:36 <vixey> it's a bit awkward but id @ Bool True looks wrong
03:29:43 <vixey> maybe something like id 'Bool True is better?
03:30:05 <augustss> vixey: There's no need for special syntax
03:30:37 <augustss> vixey: just represent type application and regular application the same way.  it simplifies type checking too.
03:30:41 <EvilTerran> the left-recursion makes parsing trickier in some (most?) approaches, but it's still possible
03:31:01 <EvilTerran> orite, you mean the types/values thing
03:31:17 <vixey> so change  | App V V | APP V T
03:31:18 <vixey> into
03:31:24 <vixey> so change  | App V (Either V T) ?
03:31:36 <augustss> vixey: In fact, I'd say that not representing type and values the same way is a mistake.
03:31:47 <augustss> No, just App V V
03:31:56 <vixey> augustss I only wanted to do this because full dependent types is too hard
03:32:27 <augustss> It's not hard, but you can choose how much dependency you want in the type checker.
03:32:49 <augustss> vixey: look at how to type check for the lambda cube.
03:33:15 <vixey> I wrote typecheckers for lambda cube but without inductives or eliminations of inductive types
03:33:28 <vixey> it's data that makes it so difficult
03:34:15 <augustss> vixey: just represent data types with lambda expressions
03:35:01 <augustss> vixey: I must admit I've not tried that approach to the bitter end for full dependent types
03:35:14 <Saizan> does that work for gadts?
03:35:37 <augustss> Saizan: no :(
03:35:48 <augustss> not that I know
03:37:46 <BONUS> hmmm, haskell's list comprehensions don't have any features that python's list comprehensions don't have, right?
03:38:21 <EvilTerran> maybe with the right extensions
03:38:33 <Saizan> so what's better for gadts? add their constructors as primitives or the eliminator?
03:39:24 <vixey> it seems reasonable ot add GADT constructors as opaque constants with types given
03:39:47 <augustss> yes, and then a general rule for checking (simple) case expressions
03:40:25 <augustss> BONUS: Does Python list compr allow this:  [ x | [x] <- xss ] ?
03:40:40 <vixey> NbE for case expressions like that is probably difficult though
03:40:48 <augustss> BONUS: it picks out the elements of all single ton lists, other lists are skipped.
03:41:28 <augustss> case expressions are without a doubt the most complex construct to type check.  Especially in the fully dependent case.
03:42:31 <vixey> it should be like case M of { C1 v1..vn => i1;  C2 v1...vm => i2; ... }
03:42:32 * tgoddard looks up python list comprehensions
03:42:45 <hydrapheetz> python's list comprehensions are neat
03:42:56 <vixey> but when you match M against whatever constructor, you have to unify the types together and rule out impossible cases and ...
03:43:35 <augustss> vixey: In the fully dependent case you can't type check case without knowing what type the result has
03:44:11 <tgoddard> BONUS: unless you get in to extensions like GHC's new generalised list comprehensions they look like they're pretty much the same
03:44:28 <tgoddard> except Haskell's are lazily evaluated
03:44:31 <BONUS> augustss: yeah you're right python can't do that
03:44:38 <BONUS> also you can't pattern match in python
03:44:54 <BONUS> although python has lazy list comps too, only they're called generator expressions
03:45:35 <vixey> ahh.
03:45:40 <vixey> yeah it is very difficult
03:47:11 <augustss> Type checking of case without knowing the return type is undecidable (for dependent types).
03:48:03 <chrisdone> anyone use factor? is it actually nice to code in?
03:48:04 <augustss> vixey: Also, if M is not a variable, you're in trouble.
03:48:16 <vixey> isn't it undecidible even when you do have the return type, in the case where the type you are matching on has type indices which are functions.. because it would require higher order unification (of course you can just give up in those cases saying this is a type error: too hard to check)
03:49:29 <vixey> I suppose it doesn't really make sense to call it undecidible if you can detect when the problem may be too hard to solve
03:49:57 <augustss> vixey: Hmm, I'm not sure.  If all binding variable occurrences are decorated by types it shouldn't be a problem.  Assuming termination, of course.
03:50:02 <vixey> why is M not being a variable a problem?
03:51:08 <vixey> incase you didn't know it's type completely?
03:51:44 <augustss> vixey: It's all right for M not to be a variable, but it's a less powerful construct.  Generally the variable you case on can occur in the type of each RHS.  If you have a term M it becomes less obvious how to check if the tem M occurs in the type.
03:52:30 <vixey> ahh I see, yeah, because the matching changes what M looks like
03:52:47 <augustss> vixey: Yes.  And it could be reduced some, etc.
03:53:26 <augustss> vixey: So if you want the simplest version, only allow case of a variable, and insist on a type annotation for the return type.
03:56:21 <vixey> augustss, hm It's rather difficult/daunting :)
03:56:34 <vixey> it seems /possible/ though, that is something
03:58:07 <augustss> vixey: If you have 'case x of { C1 ... -> e1; ... } :: T(x)', just check that each arm has type T(Cn ...)
03:59:02 <augustss> vixey: of course, there's more to it, but that's the basic idea
04:02:45 <Saizan> so most of this should port to dependent types? http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.113.2304
04:02:53 <grom358> > 1 + 1
04:02:54 <lambdabot>   2
04:03:08 <Deeem> hi, how can i leave out a param and define the second so than i can make a function a -> b -> c to a -> c?
04:03:41 <Saizan> Deeem: with flip, or a lambda
04:04:06 <Saizan> "flip f arg" or "\x -> f x arg"
04:04:25 <Deeem> thx
04:05:57 <vixey> Saizan, it says No document with DOI "10.1.1.113.230404"
04:06:06 <vixey> oh my fault
04:08:23 <augustss> Saizan: Well, kinda.  The dependent types people did that 20 years before GADTs got into ghc.
04:09:46 * Axman6 would like to see an easier to follow version of http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=ghc&id=1 :(
04:10:55 <Saizan> augustss: yeah, my point of view on the subject is quite distorted i guess
04:12:24 <Saizan> Axman6: write one! on current ghc we should be able to write more readable code, and it needs to be parallelized anyway
04:13:26 <Axman6> yeah, i would need to look at the problem more, but i have a feeling it could benefit from DPH. not sure though
04:17:55 <Axman6> moozilla: you ok there?
04:18:05 <moozilla> yeah
04:18:06 <moozilla> bsod
04:18:08 <moozilla> :P
04:18:43 <Axman6> 20 times?
04:18:48 <Axman6> itch your OS man :P
04:18:51 <Axman6> ditch even
04:19:40 <hydrapheetz> The only times Windows has bluescreened on me repeatedly was with bad RAM
04:20:36 <mornfall> hydrapheetz: Could be bad driver, too.
04:20:49 <hydrapheetz> or that.
04:21:46 <moozilla> nah
04:21:49 <moozilla> the rest is my wifi
04:38:28 <Holle_> i want to install http://www.haskell.org/gtk2hs/ where do i get the old version of gtk (2.12)?
04:44:53 <Axman6> @hoogle vector
04:44:53 <lambdabot> package vector
04:44:53 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
04:44:53 <lambdabot> package vector-space
04:45:06 <Axman6> @hackage vector-space
04:45:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space
04:47:22 <Holle_> ok i found gtk+ 2.12 on a ftp-server
04:47:41 <Holle_> how do i install it using WinVista?
04:56:43 <athos> hi
04:57:00 <dcoutts> Holle_: are you just trying to install gtk2hs?
04:57:16 <dcoutts> Holle_: the gtk2hs windows installer includes the Gtk+ C libraries
04:57:29 <dcoutts> so there's no need to install them separately
04:58:20 <Holle_> ok
05:03:35 <pham> what short of type hackery is this? Running ":info Mmc.messageBody" results in: data Mmc.T = Mmc.Cons {..., Mmc.messageBody :: Mmc.Body}
05:04:09 <pham> what's with the ellipsis?
05:04:17 <n0nsense> muh
05:04:54 <pham> (Mmc is Sound.MIDI.Message.Channel, for whatever that's worth)
05:05:22 <Saizan> pham: that's just ghci omitting some of the definition for brevity
05:05:29 <Axman6> pham: it's removing info that;s not relevent
05:05:51 <pham> ok good... so I look at the source for the full definition?
05:06:05 <Saizan> :info Mmc.T
05:07:20 <pham> oh, that's what confused me... there's only one other member. But I see, it's not relevant
05:07:39 <pham> there could be 100
05:10:37 <pk> @src (+)
05:10:38 <lambdabot> Source not found. stty: unknown mode: doofus
05:11:28 <pham> so why does this module (actually set of modules) use records with one element?
05:11:46 <Axman6> free accessor functions?
05:11:59 <Axman6> and setter functions
05:12:08 <Axman6> probably the wrong name, but i'm very sleepy
05:12:30 <Holle_> i want to install http://osdir.com/ml/lang.haskell.libraries/2006-08/msg00131.html but i don't know how?
05:12:48 <pham> like for example, Velocity is a record with one field: fromVelocity :: Int
05:13:56 <Holle_> i installed ghc 6.8.3 and gtk2hs 0.9.13
05:14:27 <dcoutts> great
05:14:28 <maltem_> pham: There's an idiom going like newtype WrappedInt = WI { unwrap :: Int }
05:14:56 <dcoutts> Holle_: gtk2hs comes with the soegtk package
05:15:02 <maltem_> pham: It's useful if you're too lazy to define fromVelocity/unwrap/... by hand
05:15:17 <pham> maltem_: but what's the use of wrapping that int?
05:15:22 <Holle_> so now i can use soegtk?
05:15:39 <maltem_> pham: oh, that's just for clarity and type safety
05:15:51 <pham> maltem_: ah ok
05:16:37 <maltem_> pham: or if the data type is abstract, for encapsulation
05:16:44 <Holle_> what is the name of the module i have to import?
05:17:22 <dcoutts> Holle_: Graphics.SOE.Gtk
05:17:34 <dcoutts> Holle_: just as it says in the email you linked to
05:20:24 <Holle_> Loading package glib-0.9.13 ... <interactive>: Unknown PEi386 section name `.reloc' (while processing: C:/ProgramFiles/Gtk2Hs/HSglib.o) : panic! (the 'impossible' happened)
05:20:49 <Peaker> sequence [[0..7],[0..7]] will generate a list. I want a tuple for safer pattern matching. What's a nice way to get one, besides the obvious list comprehension or "do" notation?
05:20:59 <Holle_> what does this error mean?
05:21:16 <dcoutts> Holle_: bug in that version of ghc, you'll have to compile your programs using ghc --make rather than using ghci
05:21:33 <Holle_> using cmd of win?
05:21:57 <vixey> Peaker, the type of it should be?
05:22:16 <Peaker> vixey: Num a => [(a, a)]
05:22:45 <Peaker> vixey: or if the [0..7] and [0..7] are parameterizable then:  [a] -> [b] -> [(a,b)]
05:23:30 <Holle_> great that works :)
05:23:33 <Holle_> thnax.
05:23:35 <Peaker> cross [0..7] [0..7] would be fine, but I'd rather have some nice PL thing without having to define cross
05:25:12 <vixey> @let cross = liftA2 (,)
05:25:13 <lambdabot>  Defined.
05:25:21 <vixey> > cross "xyz" "uvw"
05:25:22 <lambdabot>   [('x','u'),('x','v'),('x','w'),('y','u'),('y','v'),('y','w'),('z','u'),('z'...
05:27:52 <Axman6> the distance between <0,0,0> and <1,1,0> should be √2 right?
05:28:06 <augustss> yes
05:28:20 <Axman6> ah, heh, had an extra square root in there
05:29:41 <Peaker> vixey: ah, right, thanks :-)
05:30:00 <vixey> Axman6, do you know why?
05:30:28 <Peaker> is there a mod for Fractional?  e.g:   5.6 `fmod` 2.2 = 1.2 ?
05:30:37 <Peaker> @hoogle Fractional a => a -> a -> a
05:30:37 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
05:30:37 <lambdabot> Prelude asTypeOf :: a -> a -> a
05:30:37 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
05:30:42 <Axman6> because the magnitude of a vector (from the origin) is the square root of the sum of the components squared? :)
05:30:53 <vixey> Axman6, and why is that?
05:30:55 <Peaker> @hoogle Floating a => a -> a -> a
05:30:55 <lambdabot> Prelude (**) :: Floating a => a -> a -> a
05:30:55 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
05:30:55 <lambdabot> Prelude asTypeOf :: a -> a -> a
05:31:21 <Axman6> vixey: pythagoras' theorem
05:31:30 <vixey> yeah, √(x^2 + (√(y^2 + z^2))^2)
05:32:15 <Axman6> taking a stab at making a readable version of http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=all
05:32:45 <Axman6> the current haskell one by dons is full of pointer magic
05:32:49 <vixey> just translate this: http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=sbcl&id=1
05:33:54 <Axman6> i was having a go at translating the erlang version actually
05:34:32 <Axman6> i'm not used to Lisp, so it'd be harder going i think
05:34:51 <athos> , src ''Ptr
05:34:58 <lunabot>  luna: Not in scope: type constructor or class `Ptr'
05:36:20 <Axman6> i do like being able to write things like dist v1 v2 = mag $ v1 .- v2. defining operators is so handy (yes, i know thay're just functions)
05:37:10 <Holle_> i want to try this demos of soe but i don't know how to get them work? http://www.haskell.org/soe/demos.htm
05:37:18 <Peaker> There's no uncurry3 ?
05:37:38 <Peaker> @src uncurry
05:37:38 <lambdabot> uncurry f p = f (fst p) (snd p)
05:37:44 <Axman6> @hoogle uncurry
05:37:45 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
05:37:45 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
05:37:50 <vixey> @go typed pattern combinators
05:38:03 <lambdabot> http://lambda-the-ultimate.org/node/3137
05:38:03 <lambdabot> Title: Functional Pearl: Type-safe pattern combinators | Lambda the Ultimate
05:38:05 <Peaker> @let uncurry3 f (x,y,z) = f x y z
05:38:06 <lambdabot>  Defined.
05:38:09 <Peaker> @type uncurry3
05:38:10 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
05:39:11 <Axman6> vixey: i've done my fair share of physics over the last three years, but i'm a little rusty, that's all
05:39:20 <vixey> Here Peaker: http://www.itu.dk/people/mir/typesafepatterns.hs
05:39:45 <Axman6> been 6+ months since i've done any physics though
05:40:13 <vixey> fundamental rule of physics seems to be everything is connected to everything else by a spring
05:40:24 <Axman6> :t (. (+))
05:40:25 <lambdabot> forall c a. (Num a) => ((a -> a) -> c) -> a -> c
05:40:53 <Axman6> @pl dist v1 v2 = mag $ v1 .- v2
05:40:53 <lambdabot> dist = (mag .) . (.-)
05:41:26 * Axman6 considers calling his subtraction function gam for symmetry
05:41:26 <Peaker> vixey: that's crazy stuff :-)
05:41:33 <vixey> it's pretty cool yeah
05:42:06 <Peaker> @src curry3
05:42:06 <lambdabot> Source not found. There are some things that I just don't know.
05:42:09 <Peaker> @hoogle curry3
05:42:09 <lambdabot> No results found
05:42:16 <Peaker> @hoogle 3
05:42:16 <lambdabot> Parse error:
05:42:16 <lambdabot>   --count=20 3
05:42:16 <lambdabot>              ^
05:42:27 <vixey> Peaker, but I pointed it out because it's got a definition of curry three
05:43:50 <Peaker> vixey: ah, now I understand why people want to have 2-tuples and 0-tuples to define (a, (b, c, ()))) rather than (a, (b, c))
05:44:08 <vixey> I don't :/
05:44:17 <vixey> oh
05:44:20 <vixey> yeah
05:44:34 <Peaker> vixey: I hate N-tuples. They ruin :info ! :-(
05:44:41 <vixey> (a,b,c) to mean (a,(b,(c,()))) would be silly, but writing (a,(b,(c,()))) in the first place is fine
05:44:51 <Peaker> why would it be silly?
05:44:52 <maltem_> Axman6: do tell us how the nbody program turns out, performance-wise. The shootout version actually looks worse than the reference Java implementation, which is faster :-/
05:45:06 <Axman6> yeah :\
05:45:16 <vixey> because (a,b,c) is a lot different
05:45:28 <Holle_> the examples of soe uses "drawRegionInWindow" which is not defined in Graphics.SOE.Gtk
05:45:29 <Peaker> vixey: yeah, but it sucks that it's different :)
05:45:44 <Peaker> vixey: There are no advantages, but at least 2 annoying disadvantages
05:45:46 <Axman6> :t fst.fst.fst
05:45:47 <lambdabot> forall a b b1 b2. (((a, b), b1), b2) -> a
05:45:57 <Axman6> :t fst.fst.fst.snd.snd.snd
05:45:58 <lambdabot> forall a b b1 b2 a1 a2 a3. (a3, (a2, (a1, (((a, b), b1), b2)))) -> a
05:46:00 <Peaker> vixey: (Well, unless backwards compatibility is an advantage)
05:46:08 <vixey> _|_  (_|_,_|_,_|_) (_|_,b,c) (a,_|_,c) (a,b,_|_), ...
05:46:25 <vixey> vs _|_, (_|_,_|_), (a,_|_) (_|_,(_|_,_|_)), ...
05:47:04 <vixey> at least that is the suggestion I got from the syntax, so making both syntax mean the same thing seems very confusing
05:47:17 <Peaker> vixey: so (a, !(b, !(c, !())))
05:47:32 <vixey> that's not a valid type though
05:47:37 <vixey> only a valid pattern
05:47:57 <vixey> (except for the !() I suppose)
05:48:03 <Peaker> data Tuple a b = Tuple a !b
05:48:28 <Peaker> data EmptyTuple = EmptyTuple
05:48:35 <vixey> now you can't build structures up like ((a,b),(c,d)) and except them to have sensible behavior
05:48:44 <vixey> (with that !b version)
05:48:55 <vixey> anyway that is just my view on it
05:49:41 <Peaker> why, (a, b) is a `Tuple` (b `Tuple` EmptyTuple) so a and b are not strict. And then:
05:50:18 <Axman6> @hoogle on
05:50:19 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:50:19 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
05:50:19 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
05:50:19 <Peaker> ((a, b), (c, d))  is just  twoTuple `Tuple` (twoTuple `Tuple` EmptyTuple)
05:50:31 <maltem_> Holle_: drawInWindow together with drawRegion should do the trick. not sure why drawRegionInWindow isn't there
05:50:46 <Peaker> vixey: would that have different bottoms?
05:50:49 <maltem_> Holle_: perhaps it's defined in the book
05:50:58 <vixey> no
05:51:18 <augustss> Sometimes I wish tuples were defined inductively like that
05:51:21 <vixey> it still has got more constructors though
05:51:25 <Holle_> it might be defined in the book
05:51:36 <Peaker> Every time I type   :info SomeClassOfTuple    I wish for tuples to be like that :P
05:51:39 <vixey> augustss, but why since it's so easy to define your own inductive tuples?
05:51:44 <Peaker> vixey: does that cause anything?
05:51:57 <augustss> vixey: but not with the usual synyax
05:51:59 <augustss> syntax
05:52:04 <vixey> oh
05:52:13 <Peaker> also you have to use a lot of existing code which returns or expects N-tuples
05:52:19 <vixey> I use a :*: b :*: c :*: d :: Vector (a, (b, (c, (d, ()))))
05:52:21 <Peaker> and you want :info Show  to not take a crap on your shell :-(
05:52:21 <vixey> sometimes...
05:52:36 <augustss> vixey: So do I
05:52:52 <vixey> (oops should have wrote d :*: END)
05:52:52 <augustss> Or something like that
05:53:13 <augustss> Yeah, it's the END that annoys me most :)
05:54:53 <mmorrow> vixey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=756#a756
05:55:16 <Peaker> also, every other feature N-thing in Haskell seems to be based on 0,2 things (Empty, Cons  or  non-Function, Func from arg to result)
05:55:57 <vixey> what does "feature N-thing" mean?
05:56:25 <Peaker> a feature that has N arguments or is parameterized by N params
05:56:28 <vixey> ok
05:56:34 <vixey> I use GADTs for them usually
05:56:41 <vixey> but I like the other tricks too they are neat
05:56:41 <mmorrow> if ... then ... else ...
05:56:46 <vixey> it's all really silly tbh :P
05:56:56 <mmorrow> but i hate ifte
05:57:00 <vixey> you can just program normally if you had dependent types
05:57:34 <mmorrow> i take that back, if then else is nice sometimes
05:57:53 <mmorrow> but actually it would be all the same if it was a function
05:58:00 <vixey> (the way GADTs fit together lets you compute types from other types -- it's just a bit trick to program in that way)
05:58:08 <augustss> mmorrow: I wish there were a function
05:58:25 <mmorrow> yeah, me too
05:58:46 <augustss> mmorrow: I usually use (?) :: Bool -> (a,a) -> a
05:59:05 <vixey> there's a definition of a if function: http://rascal-haskell.googlecode.com/svn/trunk/examples.hx
05:59:11 <mmorrow> ooh, that's nice. i use "bool :: a -> a -> Bool -> a" some
05:59:38 <mmorrow> but i rarely actually use a function to replace where i'd use ifte
06:00:17 <augustss> mmorrow: when I define ?, it typically so I can overload it on the boolean type
06:00:46 <mmorrow> hmm, what do you mean by "overload"?
06:01:39 <n0nsense> @hoogle gtk2hs
06:01:39 <lambdabot> No results found
06:01:40 <mmorrow> @let (?) b (t,f) = if b then t else f
06:01:41 <lambdabot>  Defined.
06:01:49 <dcoutts> @where gtk2hs
06:01:49 <lambdabot> http://haskell.org/gtk2hs/
06:01:53 <dcoutts> n0nsense: ^^
06:01:56 <n0nsense> dcoutts: :D
06:02:04 <n0nsense> dcoutts: I'm new to haskell
06:02:23 <mmorrow> > (4 < 5 ?) ("phew","nine!")
06:02:24 <lambdabot>       The operator `?' [infixl 9] of a section
06:02:24 <lambdabot>          must have lower prece...
06:03:08 <mmorrow> @let infixr 9 ?
06:03:09 <lambdabot>  Defined.
06:03:11 <mmorrow> whoa
06:03:17 <mmorrow> didn't expect that to work
06:03:17 <dcoutts> n0nsense: hoogle is great for names of functions and types, but not so good for package or project names
06:03:20 <mmorrow> > (4 < 5 ?) ("phew","nine!")
06:03:21 <lambdabot>       The operator `?' [infixr 9] of a section
06:03:21 <lambdabot>          must have lower prece...
06:03:25 <mmorrow> sigh
06:03:35 <mmorrow> @let infixr 9 ?
06:03:35 <vixey> > (4 < 5) ? ("phew","nine!")
06:03:36 <lambdabot>  <local>:5:9:
06:03:36 <lambdabot>      Multiple fixity declarations for `?'
06:03:36 <lambdabot>      also at  <local>...
06:03:37 <lambdabot>   "phew"
06:03:39 <mmorrow> gah
06:03:41 <EvilTerran> mmorrow, wouldn't a lower precedence have been in order?
06:03:46 <mmorrow> yeah, i blew it
06:03:55 <EvilTerran> time to @undef?
06:03:56 <redditbot> Armada on Hackage: real-time strategy game in Haskell
06:04:04 <mmorrow> anyone object?
06:04:17 <mmorrow> @undef
06:04:22 <mmorrow> > (?)
06:04:23 <lambdabot>   Not in scope: `?'
06:04:50 <mmorrow> hmm, should it be infixl or infixr ...?
06:04:56 * EvilTerran prefers the two-operator approach to that kinda thing
06:05:29 <mmorrow> 4 == 2 ? 9 == 12 ? (('a','b'),('c','d'))
06:05:34 <mmorrow> r
06:05:36 <ziman> do I need profiling versions of all libraries used in my program when profiling it?
06:05:55 <n0nsense> dcoutts: okay :D
06:06:00 <ziman> I used this command, according to RWH: ghc --make -O2 splitter.hs -o splitter -prof -auto-all -caf-all -fforce-recomp
06:06:05 <mmorrow> @let infixr ? 0; (?) b (t,f) = if b then t else f
06:06:05 <lambdabot>   Parse error
06:06:10 <mmorrow> @let (?) b (t,f) = if b then t else f
06:06:11 <lambdabot>  Defined.
06:06:15 <mmorrow> @let infixr ? 0
06:06:15 <lambdabot>   Parse error
06:06:16 <EvilTerran> True ?? x = pure x; False ?? x = empty; Just x ?: _ = x; Nothing ?: y = y
06:06:20 <ziman> and ghc complains Data.WAVE isn't profiling
06:06:20 <mmorrow> @let infixr 0 ?
06:06:21 <lambdabot>  Defined.
06:06:27 <mmorrow> > 4 == 2 ? 9 == 12 ? (('a','b'),('c','d'))
06:06:28 <lambdabot>   'd'
06:06:31 <mmorrow> nice
06:07:20 <mmorrow> @let ifte = uncurry . (?)
06:07:21 <lambdabot>  Defined.
06:08:47 <Axman6> ziman: easiest thing to do is run `cabal install <lib-without-profiling> --reinstall -p`
06:08:48 <mmorrow> > zipWith (fmap ifte (randomRs (False,True) (mkStdGen 76254))) [0..] [1..]
06:08:49 <lambdabot>       Ambiguous occurrence `ifte'
06:08:49 <lambdabot>      It could refer to either `L.ifte', def...
06:09:12 <ziman> Axman6, okay, thanks!
06:09:50 <mmorrow> > zipWith (fmap (uncurry.(?)) (randomRs (False,True) (mkStdGen 76254))) [0..] [1..]
06:09:51 <lambdabot>   Couldn't match expected type `a -> Bool'
06:10:01 <Axman6> ziman: and if that tells you you don't have other profiling libraries, then do the same for those libraries first
06:11:32 <Holle_> how do i import a module from a subdirectory?
06:13:59 <BONUS> well you have to have it set up properly first
06:14:01 <BONUS> the modules that is
06:14:09 <mmorrow> > zipWith ($) (fmap (?) (randomRs (False,True) (mkStdGen 76254))) (zip (repeat 0) (repeat 1))
06:14:09 <BONUS> then you just do import Subdirectory.Module
06:14:21 <lambdabot>   [1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,1,1,...
06:14:36 <BONUS> for example, you can make a directory called Foo and in it you put Bar.hs
06:14:38 <mmorrow> augustss: (?) is kinda nice
06:14:40 <Axman6> BONUS: zomg, don't do that, you'll get sued for copyright infringement!
06:14:52 <BONUS> and in Bar.hs you have module Foo.Bar where ...
06:14:53 <BONUS> hahaha
06:15:00 <BONUS> did someone copyright foo and bar
06:15:08 <Axman6> heh, no, the binary thing
06:15:21 <BONUS> oh haha
06:15:24 <augustss> mmorrow: I like it; it reminds me of C. :)
06:15:53 <mmorrow> heh, totally. i didn't make the connection until about 20 seconds ago
06:16:15 <ziman> Axman6, thanks, it works. Is there a performance penalty for having -p-compiled libs?
06:16:19 <Axman6> there was an article a while ago about why you should never compute all of pi on a computer, because it never repeats, it must contain all known binary strings, and as such, you could be charged for having pirated versions of PS and kiddie porn etc :P
06:16:32 <Axman6> ziman: no, they compile two different version afaik
06:16:40 <ziman> oh, i see.
06:16:59 <Axman6> BONUS: http://www.everything2.net/index.pl?node_id=1302963
06:17:15 <BONUS> haha yeah, that's true
06:17:48 <BONUS> but that's okay because it also probably contains the secrets to ultimate unlimited power as well
06:18:09 * mmorrow does     (&) :: IO () -> IO ThreadId; (&) = forkIO
06:18:19 <Axman6> hmm, true
06:18:29 <mmorrow> (forever (print 42) &)
06:18:37 <Axman6> mmorrow: erlang style?
06:18:42 <mmorrow> sh style!
06:18:48 <Axman6> ah, heh
06:19:07 <mmorrow> (while [[ true ]];do echo 42;done) &
06:19:18 <stu8ball> There's an esolang that uses the digits of pi that way Axman6 .
06:19:24 <stu8ball> Actually, there are a couple.
06:19:28 <EvilTerran> Axman6, i don't think "because it never repeats, it must contain all known binary strings" holds
06:19:33 <wjt> mmorrow: :D
06:19:50 <stu8ball> You find the program that you want to write somewhere within pi, and then you say to the interpreter of that language 'my program is between the Nth and Mth digits of pi'
06:19:53 <Axman6> EvilTerran: i was paraphrasing: It is conjectured that this number is normal, meaning that it contains ALL finite bit strings.
06:19:54 <EvilTerran> > ("0."++) . concat . iterate ('0':) $ "1"
06:19:55 <lambdabot>   "0.101001000100001000001000000100000001000000001000000000100000000001000000...
06:19:56 <vixey> it couldn't hold, digits are a function N -> Digit
06:19:59 <EvilTerran> never repeats :)
06:20:34 <mmorrow> , fix show
06:20:37 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
06:21:17 <mmorrow> , fmap (\c -> case c of '"' -> 1; '\\' -> 0;) (show (fix show)
06:21:19 <lunabot>  luna: parse error (possibly incorrect indentation)
06:21:23 <mmorrow> , fmap (\c -> case c of '"' -> 1; '\\' -> 0;) (show (fix show))
06:21:25 <lunabot>  [1,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,...
06:21:36 <mmorrow> almost
06:22:19 <Axman6> @src shows
06:22:19 <lambdabot> Source not found. My mind is going. I can feel it.
06:23:45 <mmorrow> , let f = concat . permutations in concat (iterate f [0,1])
06:23:47 <lunabot>  [0,1,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,0,...
06:24:11 <mmorrow> i think that would include all finite bitstrings
06:24:24 <mmorrow> , let f = concat . permutations in concat (iterate f [0..9])
06:24:26 <lunabot>  [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,1,0,2,3,4,5,6,7,8,9,2,1,0,3,4,5,...
06:25:03 <vixey> @let strings characters = concatMap (flip replicateM characters) [1..]
06:25:05 <lambdabot>  Defined.
06:25:07 <mmorrow> well, all infinite bitstrings too
06:25:07 <vixey> > strings "01"
06:25:09 <lambdabot>   ["0","1","00","01","10","11","000","001","010","011","100","101","110","111...
06:25:24 <vixey> All infinite bitstrings?
06:25:27 <mercury^> Heh.
06:25:32 <mmorrow> sure
06:25:33 <EvilTerran> > let xs = [] : concat [[0:x, 1:x] | x <- xs] in xs
06:25:35 <lambdabot>   [[],[0],[1],[0,0],[1,0],[0,1],[1,1],[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1]...
06:25:45 <cnwdup> How to catch an exception issued by Prelude.error using catchJust?
06:25:46 <EvilTerran> all finite bitstrings :)
06:25:47 <Axman6> > strings "01" !! 1000
06:25:48 <lambdabot>   "111101010"
06:25:50 <Axman6> > strings "01" !! 10000
06:25:52 <lambdabot>   "0011100010010"
06:25:54 <Axman6> > strings "01" !! 1000000
06:25:57 <lambdabot>   "1110100001001000010"
06:26:26 <vixey> > foldl (\y x -> x+2*y) 0 [1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0]
06:26:27 <lambdabot>   475714
06:26:34 <vixey> > foldl (\y x -> 2*x+y) 0 [1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0]
06:26:35 <lambdabot>   14
06:26:38 <ClaudiusMaximus> > fix error
06:26:40 <vixey> ohhuh.....
06:26:40 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
06:26:44 <Axman6> i saw a nice function a while ago that took in "01" and produced all binary numbers in order from 0
06:26:45 <vixey> > foldr (\y x -> x+2*y) 0 [1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0]
06:26:47 <lambdabot>   14
06:26:51 <vixey> > foldr (\y x -> 2*x+y) 0 [1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0]
06:26:52 <lambdabot>   135703
06:27:05 <vixey> I thought htat I would get 1000000 back
06:27:34 <Axman6> vixey: your thing has numbers like "000" in it
06:27:40 <vixey> oh right
06:28:24 <vixey> > concat (strings "!?&")
06:28:25 <mmorrow> cnwdup: it's a losing battle
06:28:26 <lambdabot>   "!?&!!!?!&?!???&&!&?&&!!!!!?!!&!?!!??!?&!&!!&?!&&?!!?!??!&??!?????&?&!?&??&...
06:29:30 <cnwdup> Hum, or more important: How can I catch exceptions in pure expressins? I've read about a reference to evaluate. But I don't see how this should work.
06:30:08 <Lemmih> cnwdup: catchJust errorCalls
06:30:27 <Lemmih> cnwdup: Short answer: you don't.
06:30:31 <cnwdup> lemmih: But which exception is being raised by Prelude.error?
06:30:54 <Lemmih> cnwdup: Are you using ghc-6.10?
06:31:13 <cnwdup> Hum, that sucks. So I can't write a pure function which uses uses read and returns Nothing if read fails or Just a otherwise?
06:31:16 <cnwdup> lemmih: Nope
06:31:24 <vixey> cnwdups, use: reads
06:31:43 <Lemmih> cnwdup: It's raising Control.Exception.Exception.
06:32:07 <cnwdup> vixey: Thanks.
06:32:15 <cnwdup> lemmih: Ok. Thanks as well.
06:33:09 <Holle_> writing "import Graphics.SOE.Gtk" where do i find the file on my disk?
06:34:56 <EvilTerran> cnwdup, you could use reads
06:34:58 <EvilTerran> ?type reads
06:35:00 <Lemmih> Holle_: Use --make and GHC will find it for you.
06:35:02 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:35:58 <EvilTerran> cnwdup, reads returns [] if there's no parse, [(theParse, trailingString)] if there is a parse, and multiple such pairs if it's ambiguous
06:36:18 <cnwdup> evilterran: Yep. Works like a charm with that. (-:
06:36:26 <EvilTerran> (nothing in the standard libs parses ambiguously, but the support's there)
06:37:25 <Holle_> i want to take a look in the module. --make doesn't shows me the file
06:37:49 <Lemmih> Holle_: Have you downloaded the source?
06:37:57 <Holle_> no
06:38:02 <mmorrow> vixey: it's too bad the code for that PiSigma cgi prog isn't available
06:38:28 <Holle_> isn't the source in a dir of ghc?
06:38:30 <jonaskoelker> hi all.  I want to profile my project, and I use uniplate (downloaded via cabal).  I edit ~/.cabal/config, /profiling/s/False/True/, cabal install --reinstall uniplate, but find no .*p_hi; what gives?
06:38:32 <EvilTerran> Holle_, you could download the source off http://hackage.haskell.org/cgi-bin/hackage-scripts/package/soegtk
06:38:36 <Lemmih> Holle_: That'd be the first step. Looking at compiled Haskell code isn't much fun.
06:39:49 <EvilTerran> Holle_, or you can browse the darcs repo online at http://code.haskell.org/gtk2hs/soegtk/
06:39:55 <Holle_> is it possible to change the source?
06:40:16 <mmorrow> Holle_: why wouldn't it be :)
06:40:23 <EvilTerran> you'd have to recompile etc
06:40:23 <dcoutts> jonaskoelker: hmm, I'd expect that to work. Does cabal install --reinstall -p uniplate work?
06:40:52 <jonaskoelker> dcoutts: yep, thanks :)
06:41:11 <Holle_> would it work without recompiling? i just want to change one data type and one function
06:41:15 <dcoutts> jonaskoelker: so that works and profiling: True in the config file did not work?
06:41:23 <EvilTerran> Holle_, what do you want to change?
06:41:36 <EvilTerran> (altho the short answer is "no")
06:41:39 <jonaskoelker> dcoutts: "-- library-profiling: True" in the config didn't work
06:41:51 <jonaskoelker> oh shit, that's a comment?
06:41:56 <dcoutts> jonaskoelker: yes :-)
06:41:58 <mmorrow> Holle_: you could load it in ghci, but that's pretty much the same as compiling it
06:42:06 <jonaskoelker> :( @ emacs config-mode
06:42:16 <dcoutts> jonaskoelker: I guess I need to add a comment at the top of the file saying -- this is a comment
06:42:27 <Holle_> i want to expand data Color = Black | Blue | ... and then have to change colorToRGB
06:42:33 <dcoutts> jonaskoelker: don't worry, you're not the first to hit that confusion
06:42:47 <jonaskoelker> s/f/cl/ -- I was quite certain :)
06:43:19 <EvilTerran> mmorrow, would that work on a c-preprocessed file? 'cos this one is (http://code.haskell.org/gtk2hs/soegtk/Graphics/SOE/Gtk.hs.pp)
06:43:30 <Holle_> isn't it possivle to import the module and "override" this parts?
06:43:42 <EvilTerran> that would break encapsulation somewhat
06:43:57 <mmorrow> if you were to :set -cpp -I..../includes
06:44:02 <mmorrow> it would
06:44:44 <mmorrow> (i'm don't recall if -I works at the ghci>, or if you have to do  $ ghci -I....., but one way or the other definitely works
06:45:41 <Holle_> i don't use ghci i'm using "ghc --make [file]"
06:47:02 * EvilTerran notes it's odd that SOE doesn't support arbitrary colors already
06:47:07 <mmorrow> Holle_: it'd probably be easier to make your own MyColor = ...., then write (myColorToRGB :: MyColor -> RGB{-whatever-}), (colorToMyColor :: Color -> MyColor) and (myColorToColor :: MyColor -> Maybe Color)
06:47:38 <mmorrow> yeah, that data Color = ... looks pretty restrictive
06:47:38 <EvilTerran> mmorrow, you couldn't draw the colors with SOE, then
06:47:45 <mmorrow> EvilTerran: oh
06:47:56 <EvilTerran> its routines expect a Color
06:48:06 <mmorrow> that's sucky
06:48:09 <EvilTerran> yeah =/
06:49:26 <Holle_> so i have to change data color?
06:49:42 <jonaskoelker> dcoutts: are there other haskell programs which use '--' for comments in config files?  ... Is that a common pattern?
06:50:04 <dcoutts> jonaskoelker: I'm not sure really, I didn't establish the convention
06:50:53 <EvilTerran> Holle_, while it'd probably involve re-writing your graphics functions, http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html is substantially more versatile than SOE
06:51:16 <cjb> ~
06:51:16 <cjb> ~
06:51:16 <EvilTerran> being a full 2d graphics lib instead of a teaching aid
06:51:24 <cnwdup> @pl (\s g -> concat $ map (\x -> map (\y -> g ++ [y]) s)
06:51:24 <lambdabot> (line 1, column 53):
06:51:25 <lambdabot> unexpected end of input
06:51:25 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
06:51:30 <cnwdup> @pl (\s g -> concat $ map (\x -> map (\y -> g ++ [y]) s))
06:51:30 <lambdabot> ((join . map . const) .) . flip (map . (. return) . (++))
06:51:51 <Holle_> isn't it much comlexer und more difficult?
06:52:01 <dcoutts> Holle_: the API for the soe package is fixed by the book, we cannot change it. cairo is excellent though.
06:52:14 <uu> hello
06:52:28 <dcoutts> Holle_: it's a bit more complicated but not much more so, see some of the demos
06:52:29 <cnwdup> holle_: Yup. So any suggestions how to make it simpler? I guess it could be close to readable using zipWith, but I don't quite know how.
06:52:48 <cnwdup> holle_: Oh, sorry if you were not refering to me. ^^
06:53:14 <Holle_> ^^
06:54:07 <EvilTerran> dcoutts, wouldn't sneaking a "| RGB Double Double Double" into Color (and the support in colorToRGB) be sufficiently non-intrusive?
06:54:45 <Holle_> i installed gtk2hs. is cairo inculded in it?
06:55:18 <EvilTerran> Holle_, i think so
06:55:28 <EvilTerran> http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html <- the haddock
06:55:40 <EvilTerran> oh, wait, i already pasted that. nvm. :P
06:58:48 <Holle_> cario looks good. i'll try it :)
06:59:03 <Holle_> thanks!
07:00:25 <noteventime> Does someone have any interesting information on managing grids (as in two dimensional arrays) in a generic-ish, nice and functional way :/
07:01:39 <cnwdup> What do you think whats the proportion of all Haskell coders to those who are in this channel?
07:02:11 <noteventime> I realise that when working with a two dimensional data structure, the way to iterate over it isn't as clear as when working with a list
07:02:18 <noteventime> But that's why I find it interesting
07:03:30 <dcoutts> EvilTerran: I'm nor sure I follow, I didn't think we defined a Color type in Cairo
07:03:49 <EvilTerran> dcoutts, i meant in SOE
07:04:11 <dcoutts> EvilTerran: oh, isn't it the same as in the upstream SOE api?
07:04:14 <EvilTerran> the existing interface would still be there, there'd just be a (kinda useful) extra bit
07:04:52 <dcoutts> EvilTerran: ahh, I see
07:05:08 * dcoutts looks up the SOE Color type and notices how silly it is
07:05:40 <dcoutts> EvilTerran: you're right but I think there's little to be gained in extending the SOE api at all, also it means that interoperability is better
07:05:53 <EvilTerran> true
07:05:55 <dcoutts> after all we provide better APIs elsewhere
07:06:01 <EvilTerran> hence my suggestion of switching to Cairo
07:06:07 <dcoutts> the SOE is just to support the book and the noobs with their examples
07:06:24 <dcoutts> EvilTerran: yes, it's a good suggestion, perhaps we should add it to the documentation
07:09:49 <walski> Hi
07:10:42 <walski> I've implemented an ADT and would like to write a == function for that ADT (explicitly not using deriving (Eq)). How can I
07:10:45 <walski> arg
07:10:57 <vixey> instance Eq ADT where
07:11:00 <vixey>  X == X = True
07:11:05 <walski> "How can I do that?" should be the last part
07:11:06 <vixey>  X == Y = False
07:11:07 <vixey> ...
07:11:08 <SamB_XP> what's wrong with the derived one ?
07:11:20 <walski> it's for the university, I have to do it on my own ;)
07:11:26 <SamB_XP> AH.
07:11:38 <walski> vixey: Thanks!
07:11:39 <SamB_XP> I was worried you might be planning something evil
07:12:02 <walski> hehe no no, I trust a lot in ready to use things ;)
07:13:05 <Axman6> walski: so is this homework?
07:13:21 <EvilTerran> walski, it might be easiest to do all the True cases, then finish with _ == _ = False
07:13:21 <SamB_XP> Axman6: he just said it is
07:13:29 <EvilTerran> noteventime, you could avoid the order-of-iteration problem entirely with DPH
07:13:38 <EvilTerran> noteventime, http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
07:14:07 <Axman6> SamB_XP: well, he said it was for university. could be doing a PhD on haskell... and not know how to form instances of classes >_>
07:14:43 <SamB_XP> are there enough Haskell PhDs to go around that non-enthusiasts do them too ?
07:15:09 <Axman6> yes, definitely
07:15:24 <cnwdup> ?pl (\a b -> a ++ [b])
07:15:24 <lambdabot> (. return) . (++)
07:16:06 <Axman6> cnwdup: that's almost always a bad idea
07:16:26 <cnwdup> axman6: But it's worth checking if it produces something good, isn't it?
07:16:36 <EvilTerran> cnwdup, going back to your previous question, how about \s g -> [x ++ [y] | y <- s, x <- g]
07:16:41 <Axman6> cnwdup: i mean appending to a list
07:16:47 <noteventime> Thanks EvilTerran, I was more interested in the logical order than the other it's computed on the CPU(s). For example, is there a nice way to implement a way to iterate over all cells and their neighbours.
07:17:14 <EvilTerran> cnwdup, although i would try to rethink appending single elements to the ends of lists
07:17:42 <cnwdup> axman6: Ah, yes. But lists are only small and it's only run once in the program.
07:17:42 <noteventime> And I don't mean only that problem in particular, but in general, has there been any discussion of implementing those kind of iteration schemes (or whatever the word may be) in general for grids
07:17:52 <EvilTerran> noteventime, ah, i see
07:17:54 <cnwdup> evilterran: Thanks for the suggestion. Didn't think of list comprehension.
07:17:57 <Axman6> cnwdup: ok, just as long as you know :)
07:18:11 <walski> Hm, what's wrong with the == implementation here: http://hpaste.org/13803 ?
07:18:19 <ulfdoz> Ich kann mcih dunkel erinnern: Das letzte mal kam das gestern zur Sprache.
07:18:22 <ulfdoz> ECHAN, sorry
07:18:55 <EvilTerran> walski, it's order-dependent?
07:19:33 <EvilTerran> walski, i think you might need to make that "instance Ord a => Eq (Set a) where ..."
07:19:39 <noteventime> EvilTerran: Talking about data parallel Haskell, any idea if there's been work on heterogeneous parallel programming in Haskell?
07:19:40 <walski> ah thanks!
07:19:53 <EvilTerran> noteventime, well, there's `par`
07:19:57 <Axman6> not instance Eq a => Eq (Set a) ?
07:20:34 <EvilTerran> Axman6, well, Ord would give you O(n.log n) equality comparisons instead of O(n^2)
07:20:46 <EvilTerran> Axman6, and all his other Set operations have an Ord constraint, so it'd be consistent
07:20:47 <noteventime> EvilTerran: huh?
07:21:10 <noteventime> EvilTerran: I mean for heterogeneous processors (or whatever they may be called)
07:21:12 <Axman6> EvilTerran: huh, why the difference in order of complexity?
07:21:26 <EvilTerran> noteventime, oh, right, i thought you meant heterogenous types
07:21:26 <noteventime> Like the most GPUs and the CELL BE
07:21:36 <noteventime> I see
07:21:50 <EvilTerran> Axman6, that would be giving away the answer :P
07:21:53 <walski> EvilTerran: Cool that Ord a prefix works! Great!
07:22:32 * EvilTerran thinks for a second
07:22:58 <EvilTerran> walski, ah, hang on, momentary confusion on my part; yes, writing Eq instead of Ord there would work
07:23:13 <EvilTerran> Axman6, i misread and thought he was storing them un-ordered
07:23:15 <EvilTerran> =/
07:23:24 <Axman6> :\
07:23:35 <Saya> :s
07:23:43 * EvilTerran is having a slow day :P
07:24:12 <drdozer> I keep needing a sort of 'bijection' type
07:24:12 <jonaskoelker> dcoutts: are you the cabal maintainer?
07:24:44 <drdozer> a pair of functions that are inverses of each other
07:25:07 <drdozer> that map between operations over one type to another and back
07:25:22 <Axman6> drdozer: (f.g) x == x && (g.f) x == x?
07:25:50 <drdozer> Axman6: that looks right
07:25:55 <SamB_XP> drdozer: so you want a typeclass isomorphism ?
07:28:20 <maltem> I noticed that with uvector, it's impossible to define custom instances of UA. Is that by design?
07:35:11 <maltem> Also, why is the exported version of lengthU the one that folds over the array, instead of lengthU from UA (and where is that one used anyways)?
07:36:00 <maltem> (ping dons)
07:36:28 <dcoutts> jonaskoelker: yes
07:37:06 <jonaskoelker> oh, goodie.  I have a conf-cabal-mode.el you may want to include.  Should I stuff it in trac?
07:37:31 <jonaskoelker> have a look at http://pastebin.com/f37895638 anyways
07:42:41 <drdozer> SamB, sorry - on the phone to my sis
07:44:48 <drdozer> SamB_XP, I'm not quite sure what you mean by 'typeclass isomorphism'
07:45:45 <SamB_XP> did you want to preserve certain operations across the conversion ?
07:46:30 <drdozer> SamB_XP: ah, so if there is a foo x, do I want there to be 'automatically' a foo y?
07:46:58 <SamB_XP> er ... that's not exactly what I meant
07:47:22 <SamB_XP> did you want anything besides that it be a bijection ?
07:48:14 <drdozer> so, if I had Foo Int and Bar String, I could use show/read to map operations over Int in to those over String
07:49:03 <drdozer> or if I have Foo Int, I may want to 'lift' operations over Int into those over Foo Int
07:50:10 <walski> bye
07:50:17 <drdozer> which I could do with the pair of operations "Foo" and "\(Foo i) -> i"
07:51:06 <everton_rc> What would be the best beginner Haskell book you guys advise?
07:51:33 <Axman6> RWH
07:51:34 <QplQyer> real world haskell
07:51:49 <arw> i like real world haskell, but i'm not sure if its ideal for beginners.
07:51:55 <everton_rc> Axioplase_, QplQyer The one from Orreiley?
07:51:58 <byorgey> everton_rc: it depends.  what's your programming and/or math background?  why do you want to learn haskell?
07:51:58 <kpreid> drdozer: that lift is usually fmap
07:52:03 <QplQyer> it sure covers a lot of basic grounds imo
07:52:06 <QplQyer> everton, yes
07:52:14 <arw> there are tons of short tutorials out there, which you might want to read first.
07:52:27 <everton_rc> byorgey, Im a computer scientist, I used to program in lisp
07:52:29 <arw> but beware of the "scary monad worshipping" kind :)
07:52:33 <kpreid> drdozer: instance Functor Foo where fmap f (Foo i) = Foo (f i)
07:52:51 <arw> everton_rc: there is a "program yourself a lisp in 48 hours" somewhere. thats very nice.
07:52:55 <everton_rc> arw, I read the 10minutes one
07:52:57 <drdozer> kpreid: that's what I thought, but fmap is too permissive in the 'filler' of Foo
07:53:05 <kpreid> doh, right
07:53:11 <byorgey> it's actually "program yourself a scheme in 48 hours" =)
07:53:13 <vixey> I don't like the 48 hours thing
07:53:24 <everton_rc> arw, I like lisp but they told me Haskell was better, so im giving it a shot
07:53:35 <byorgey> but I'm with vixey on this one.  I had to un-learn everything I learned about monads from that one.
07:53:37 <vixey> everton_rc, "they"?
07:53:55 <QplQyer> btw, anyone here succeeded in making wxhaskell 0.11.1 run on Ubuntu Hardy (8.04)?  I keep getting "type.c:2248: initialization assertion failed, use IA__g_type_init() prior to this function" etc :s
07:54:06 <kpreid> drdozer: if there were something general, it would be a two-parameter typeclass (Foo and Int)
07:54:10 <wjt> QplQyer: are you failing to call some wx initialization function?
07:54:29 <QplQyer> wjt, not that I know of, just trying to run the samples even
07:54:34 <wjt> huh.
07:54:46 <byorgey> everton_rc: well, I'd say try the wikibook or the "gentle introduction"
07:54:55 <everton_rc> vixey, people at university
07:54:56 <arw> everton_rc: the idea was just that it would have some familiar aspects.
07:55:02 <byorgey> since the "gentle introduction" is actually one of the least gentle ones we have, if you already know lisp =)
07:55:04 <drdozer> kpreid: so I have things like "data Bar a b = Bar (a, b)" and want this to be lifted in the same way - map between functions over Bar a b and those over (a, b)
07:55:05 <vixey> everton_rc, oh ok
07:55:12 <byorgey> @where wikibook
07:55:12 <lambdabot> http://en.wikibooks.org/wiki/Haskell
07:55:16 <byorgey> @where gentle
07:55:17 <lambdabot> http://www.haskell.org/tutorial/
07:55:23 <BONUS_> also there's YAHT
07:55:25 <BONUS_> @where YAHT
07:55:26 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:55:45 <everton_rc> awesome, thanks guys!
07:55:48 <QplQyer> YAHT is nice too idd
07:55:53 <Axman6> "type planet = { mutable x : float;  mutable y : float;  mutable z : float; ... " ew OCaml
07:55:56 <byorgey> everton_rc: Real World Haskell is good too, if you want to know how to do some real-world stuff
07:56:01 <everton_rc> The "Haskell programming" with the yellow cover isnt nice?
07:56:03 <BONUS_> i think it's best to learn haskell by reading several texts/tutorials
07:56:15 <BONUS_> cause each one puts stuff a bit differently and emphasizes different things
07:56:28 <BONUS_> everton_rc: yeah that one is nice too
07:56:28 <everton_rc> byorgey, btw, how easy would be to implement some processor specific stuff in haskell?
07:56:47 <everton_rc> BONUS_, cool
07:56:56 <byorgey> everton_rc: what do you mean by 'processor-specific stuff' ?
07:57:31 <chrisdone> hrm
07:57:40 <chrisdone> (a,a) -> [a], what's a good way?
07:57:49 <byorgey> everton_rc: I mean, can you give an example?
07:57:53 <everton_rc> byorgey, like take use of SPUs with cell
07:57:53 <chrisdone> @pl \(a,b) -> [a,a]
07:57:54 <lambdabot> ap (:) return . fst
07:58:07 <BONUS> @pl \(a,b) -> [a,b]
07:58:07 <lambdabot> uncurry ((. return) . (:))
07:58:09 <augustss> @pl \(a,b) -> [a,b]
07:58:09 <lambdabot> uncurry ((. return) . (:))
07:58:24 <byorgey> chrisdone: just \(a,b) -> [a,b].  there isn't really a nicer way than that.
07:58:31 <augustss> I'd say \(a,b) -> [a,b] is the good way
07:58:35 <chrisdone> good point I guess
07:58:46 <chrisdone> yeah
07:58:57 <byorgey> everton_rc: oh, I see.  I don't really know.
07:59:05 <vixey> :t sequence [fst,snd]
07:59:06 <lambdabot> forall b. (b, b) -> [b]
07:59:07 <byorgey> everton_rc: I bet someone has done it. =)
07:59:23 <byorgey> heh, vixey, nice =)
07:59:26 <augustss> I've sometimes defined a class for tuple-list conversions, so you can say toTuple/toList on any tuple size (up to a limit)
07:59:27 <everton_rc> byorgey, true :)
07:59:30 <chrisdone> oh what
07:59:35 <BONUS> sequence [fst,snd] (2,3)
07:59:37 <BONUS> > sequence [fst,snd] (2,3)
07:59:40 <lambdabot>   [2,3]
07:59:41 <BONUS> kewl
07:59:42 <chrisdone> vixey❤♥
07:59:48 <everton_rc> byorgey, but binding to shared libs in C is ok right?
07:59:51 <BONUS> reader monad you pwn
07:59:58 <vixey> :t liftA2 (,) (!!0) (!!1)
07:59:59 <lambdabot> forall a. [a] -> (a, a)
08:00:07 <chrisdone> BONUS: list monad?
08:00:10 <byorgey> everton_rc: sure, I've heard that the foreign function interface is actually quite nice
08:00:15 <byorgey> although I've never used it personally
08:00:24 <augustss> it is
08:00:41 <byorgey> everton_rc: you can read all about that in Real World Haskell
08:00:46 <byorgey> @where RWH
08:00:46 <BONUS> chrisdone: uh, no, reader monad here :]
08:00:47 <lambdabot> is http://www.realworldhaskell.org/blog/
08:00:53 <BONUS> :t sequence
08:00:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:00:55 <everton_rc> byorgey, cool now I have enough material for an entertaining weekend :)
08:01:10 <chrisdone> BONUS: where does reader come into it?
08:01:21 <BONUS> it's actually the ((->) r) monad
08:01:24 <byorgey> everton_rc: =)
08:01:34 <BONUS> but it works like Reader
08:01:39 <byorgey> small-r reader monad, not big-R Reader =)
08:01:42 <everton_rc> thanks for the help everyone!
08:01:50 <byorgey> everton_rc: sure, anytime
08:02:25 <chrisdone> ohh
08:02:39 <chrisdone> why's it called that?
08:02:43 <vixey> so I found this, http://www.cs.nott.ac.uk/~jmc/Publications_files/tait2.pdf
08:02:47 <vixey> which is interesting..
08:03:01 <wjt> @info Reader
08:03:02 <lambdabot> Reader
08:03:08 <wjt> thanks lambdabot. you've been great
08:03:09 <vixey> and it is like NbE except they also have got reify/reflect in one single function
08:03:12 <byorgey> chrisdone: because it allows you 'read-only' access to a shared environment
08:03:23 <byorgey> i.e. the r  in ((->) r)
08:03:33 <chrisdone> ah je'e
08:03:44 <BONUS> if you do: do a <- (*2); b <- (*3); return (a+b);, that will make a function that takes a number, applies (*2) to it and calls it a, applies (*3) to it and calls it b and then returns a+b
08:03:45 <BONUS> :]
08:03:46 <chrisdone> :t fst >> snd
08:03:47 <lambdabot> forall a b. (a, b) -> b
08:04:24 <BONUS> :t undefined >> snd
08:04:25 <lambdabot> forall a b. (a, b) -> b
08:05:28 <opqdonut> :t fst >>> snd
08:05:34 <lambdabot> forall b a b1. ((a, b1), b) -> b1
08:06:01 <BONUS> :t snd . fst
08:06:02 <lambdabot> forall a b b1. ((a, b), b1) -> b
08:06:03 <BONUS> w00t
08:07:08 <jonaskoelker> :t fst &&& snd
08:07:09 <lambdabot> forall a b. (a, b) -> (a, b)
08:07:18 <jonaskoelker> :t snd &&& fst
08:07:19 <lambdabot> forall a b. (a, b) -> (b, a)
08:07:21 <jonaskoelker> :)
08:07:30 <chrisdone> :t flip liftM fst
08:07:32 <lambdabot> forall r a b. (a -> r) -> (a, b) -> r
08:09:02 <augustss> :t flip fst liftM
08:09:03 <lambdabot> forall b c a1 r (m :: * -> *). (Monad m) => (((a1 -> r) -> m a1 -> m r) -> c, b) -> c
08:09:37 <BONUS> :t extract
08:09:38 <lambdabot> Not in scope: `extract'
08:09:46 <Peaker> :t result
08:09:47 <lambdabot> Not in scope: `result'
08:09:54 <augustss> :t flip fst snd
08:09:55 <lambdabot> forall b c a b1. (((a, b1) -> b1) -> c, b) -> c
08:10:11 <Peaker> @let result = (.) ; argument = flip (.) ; infixr 2 ~> ; f ~> g = argument f . result g
08:10:12 <lambdabot>  Defined.
08:10:20 <chrisdone> :t fst
08:10:20 <chrisdone> :t flip fst
08:10:22 <lambdabot> forall a b. (a, b) -> a
08:10:22 <lambdabot> forall b b1 c. b1 -> (b1 -> c, b) -> c
08:10:36 <augustss> :t flip flip fst snd
08:10:37 <lambdabot> forall c a b a1. (a1, ((a, b) -> a) -> c) -> c
08:11:11 <SamB_XP> augustss: what ARE you doing ?
08:11:26 <jonaskoelker> making sure the bot _earns_ its wages? ;)
08:11:29 <augustss> SamB_XP: random combinations of flip, fst, snd
08:11:40 <SamB_XP> WHY?
08:11:41 <vixey> I still like  flip fst liftM  best
08:11:52 <chrisdone> I'm still trying to figure it out
08:12:00 <augustss> SamB_XP: why not?
08:12:30 <chrisdone> oh if you read it backwards it's easy
08:12:36 <SamB_XP> flip flip (flip fst)
08:12:38 <SamB_XP> > flip flip (flip fst)
08:12:39 <lambdabot>       Overlapping instances for Show
08:12:39 <lambdabot>                                  ((a -> ...
08:12:42 <SamB_XP> :t flip flip (flip fst)
08:12:43 <lambdabot> forall a c b b1 c1. (a -> (b1 -> (b1 -> c1, b) -> c1) -> c) -> a -> c
08:12:58 <SamB_XP> :t flip flip
08:12:59 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
08:13:15 <chrisdone> > flip flifp 1 (+) 2
08:13:17 <lambdabot>   Not in scope: `flifp'
08:13:18 <SamB_XP> :t flip flip flip
08:13:19 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
08:13:19 <chrisdone> > flip flip 1 (+) 2
08:13:21 <lambdabot>   3
08:13:38 <augustss> 'flip flip flip' seems to be a fixpoint for applying flip
08:13:48 <augustss> :t flip flip flip
08:13:49 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
08:13:55 <augustss> :t flip flip flip flip
08:13:56 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
08:14:10 * chrisdone hates reading types over two lines
08:14:20 <chrisdone> need bigger IRC window~_~
08:15:00 <chrisdone> these are really easy to read actually
08:15:14 <chrisdone> scarity by obscurity!
08:15:42 <chrisdone> that's flip const in there
08:15:43 <chrisdone> :t flip const
08:15:45 <lambdabot> forall a b. b -> a -> a
08:15:51 <opqdonut> aka ignore
08:15:52 <chrisdone> oh, no wait
08:16:05 <vixey> :t liftM2 ~> flip ~> flip concatMap ~> flip liftM . flip snd
08:16:07 <lambdabot> forall a1 a2 r (m :: * -> *) a b c a11 b1 r1 a21 b2 c1. (Monad m) => ((m a1 -> m a2 -> m r) -> (b -> a -> c) -> ((a11 -> [b1]) -> [b1]) -> b2) -> (a1 -> a2 -> r) -> (a -> b -> c) -> [a11] -> (c1 ->
08:16:10 <lambdabot> r1) -> (a21, b2 -> c1) -> r1
08:16:14 <chrisdone> hhaha
08:16:29 * chrisdone prints it off and pastes on wall
08:17:04 <augustss> vixey: And now I want to see you using that function ;)
08:18:32 <chrisdone> haha, some of those are irrelevant
08:18:41 <chrisdone> (b -> a -> c), c is never used
08:19:15 <chrisdone> well, hum
08:19:26 <chrisdone> n/m
08:19:35 <BONUS> hmm
08:19:55 <BONUS> if you have b -> a -> c, c is always _|_
08:19:57 <BONUS> i presume
08:20:33 <chrisdone> in: (m a1 -> m a2 -> m r) -> (b -> a -> c) -> ((a11 -> [b1]) -> [b1]) -> b2
08:20:49 <chrisdone> the c could be used to make b2
08:21:07 <sbahra> _|_ to you, too.
08:21:18 * sbahra giggles insanely 
08:22:13 <kaol> who'd have thought that "last [1..]" is obscene
08:22:16 <chrisdone> this is _|_!
08:22:21 <chrisdone> http://www.youtube.com/watch?v=7C8GWIV4jzA
08:22:34 <polveroj> chrisdone: if it's polymorphic in all those types, the only things it can do with c is pass it to a function taking c or return it as-is
08:22:56 <chrisdone> hm, right
08:23:08 <chrisdone> e.g. pass it to a function of type c -> b2
08:23:14 <chrisdone> ?
08:23:39 <chrisdone> wait
08:23:50 <polveroj> chrisdone: but it can't have one of those because c only appears as a result in any of its arguments
08:23:52 <chrisdone> what could that function possibly return?
08:24:01 <BONUS> bottom
08:24:03 <chrisdone> if it only takes functions
08:24:05 <BONUS> i.e. undefined
08:24:12 <BONUS> if you have a function a -> b, b will be undefined
08:24:14 <chrisdone> ah right
08:25:28 <SamB_XP> @free BONUS :: a -> b
08:25:28 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
08:25:33 <SamB_XP> @free bONUS :: a -> b
08:25:33 <lambdabot> g . bONUS = bONUS . f
08:25:41 <BONUS> haha
08:25:51 <SamB_XP> that's a pretty general theorem
08:26:18 <SamB_XP> shapr: you were unbalanced!
08:26:22 <polveroj> > fix (\a -> "BONUS")
08:26:24 <lambdabot>   "BONUS"
08:26:24 <Peaker> bONUS makes all functions equal to each other
08:26:26 <SamB_XP> (possibly deranged?)
08:26:26 <shapr> wargh!
08:26:52 <SamB_XP> hmm, but that free theorem isn't true in Haskell of course
08:27:28 <Peaker> @free x :: Maybe a -> Maybe a
08:27:28 <lambdabot> $map_Maybe f . x = x . $map_Maybe f
08:27:40 <Peaker> what is $map_Maybe?
08:27:43 <Peaker> fmap?
08:27:50 <SamB_XP> yeah
08:27:51 <polveroj> SamB_XP: it's true for closed terms right?
08:28:02 <augustss> SamB_XP: let's ignore seq
08:28:09 <SamB_XP> augustss: I was!
08:28:17 <SamB_XP> augustss: I was thinking of const foo
08:28:28 <Peaker> is that theorem really true?
08:28:28 <SamB_XP> as g
08:28:40 <SamB_XP> Peaker: yes
08:28:48 <Peaker> oh it is, because "a" is so general :)
08:29:02 <SamB_XP> Peaker: there are two possible Maybe a -> Maybe a, discounting _|_s
08:29:30 <SamB_XP> neither of them actually does anything with the a, obviously
08:29:44 <SamB_XP> @free f :: [a] -> [a]
08:29:44 <lambdabot> $map g . f = f . $map g
08:29:57 <Peaker> Why doesn't it replace all the $map_stuff with fmap?
08:30:12 <Peaker> for avoiding assumption on the Functor instance?
08:30:14 <SamB_XP> er, well, you could call it like this
08:30:19 <SamB_XP> that probably too
08:30:22 <SamB_XP> but
08:30:26 <SamB_XP> @free fmap :: []
08:30:26 <lambdabot> fmap = fmap
08:30:31 <SamB_XP> wait what
08:30:36 <SamB_XP> that's not even well-kinded
08:30:46 <Peaker> Hehe
08:30:53 <Peaker> @free fmap :: [Int]
08:30:53 <lambdabot> $map $id fmap = fmap
08:31:09 <Peaker> map id = id, so that's not very impressive
08:33:44 <dolio> What did you expect from the free theorem of something with no polymorphism? :)
08:35:31 <Peaker> @free x :: (a -> f a)
08:35:31 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_64.hspp:(152,16)-(160,44): Non-exhaustive patterns in case
08:35:56 <dolio> @free g :: a -> F a
08:35:56 <Peaker> @free x :: (Num a => a -> Maybe a)
08:35:57 <lambdabot> $map_F f . g = g . f
08:35:57 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_64.hspp:(152,16)-(160,44): Non-exhaustive patterns in case
08:36:07 <Peaker> @free x :: (Num a => a)
08:36:07 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_64.hspp:(152,16)-(160,44): Non-exhaustive patterns in case
08:39:35 <augustss> does @free do type classes?
08:40:43 <Peaker> @free x :: (a -> a -> a)
08:40:43 <lambdabot> f . x y = x (f y) . f
08:41:05 <drdozer> I'm writing a library for working with probability distributions
08:41:16 <drdozer> it relies upon indexed types heavily
08:41:27 <drdozer> is there a good place to publish something like this?
08:41:38 <dcoutts> drdozer: hackage?
08:41:52 <drdozer> dcoutts: I mean like a paper :D
08:42:03 <dcoutts> drdozer: ah, sorry, no idea
08:42:10 <augustss> drdozer: Haskell workshop, ICFP
08:42:14 <Peaker> that really means: f (x y z) = x (f y) (f z)
08:42:58 <dolio> Yes.
08:43:25 <Peaker> which is true, yeah, either x will always be y or z, and then the result is f y or f z,  or it will just choose (f y) and (f z)
08:43:27 <augustss> drdozer: if it's short and elegant you can do an ICFP pearl.  Or a JFP pearl
08:43:43 <Peaker> why does @free result in a PL style thing like the above, rather than the more readable point-ful below?
08:44:26 <dolio> Don't know.
08:44:29 <augustss> Peaker: Indeed
08:45:19 <Peaker> @free x :: (a -> b -> Either a b)
08:45:19 <lambdabot> $map_Either f g . x y = x (f y) . g
08:45:53 <Peaker> What would $map_Either do?
08:45:58 <Peaker> Its probably not plain fmap?
08:46:05 <dolio> @type id . (+++)
08:46:06 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
08:46:19 <dolio> It does that.
08:46:23 <dolio> Only specialized to functions.
08:46:42 <idnar> @type either
08:46:43 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:46:47 <dolio> , [$ty| bimap |]
08:46:48 <Peaker> ah, its like an extended fmap that applies to each of the types inside the type?
08:46:58 <lunabot>  forall a b c d e f g h . Bifunctor a h e b => (h g f) ->
08:46:58 <lunabot>                                                (e d c) -> b (a g d) (a f c)
08:47:00 <drdozer> thx augustss
08:47:05 <dolio> Yes. It's map for bifunctors.
08:47:14 <idnar> @type \f g e -> either (Left . f) (Right . g) e
08:47:15 <lambdabot> forall a b a1 b1. (a -> a1) -> (b1 -> b) -> Either a b1 -> Either a1 b
08:47:27 <idnar> @pl \f g e -> either (Left . f) (Right . g) e
08:47:27 <lambdabot> (. (Right .)) . either . (Left .)
08:47:31 <idnar> ugh
08:47:35 <augustss> heh
08:47:43 <SamB_XP> Peaker: yeah, it's for clowns and jokers
08:47:50 <drdozer> Ah, in Edinburgh this year - should be easy for me to get to
08:47:55 <SamB_XP> it's batman's favorite combinator
08:48:21 <pejo> drdozer, IFL might be a possible venue too.
08:50:44 <Peaker> @hoogle BiFunctor
08:50:44 <lambdabot> No results found
08:51:00 <dolio> Bifunctor is from category extras.
08:51:06 <Peaker> @hoogle Bifunctor
08:51:06 <lambdabot> No results found
08:51:10 <Peaker> ah, ok
08:52:37 <Peaker> class Bifunctor where needsName :: (BiFunctor bi, Functor f) => bi a b -> Functor f  -- could allow for Trifunctor, Quadfunctor, etc?
08:53:19 <Peaker> instance Bifunctor (MyQuadFunctor a oops
08:53:19 <dolio> What?
08:53:25 <SamB_XP> Peaker: what the ?
08:53:27 <Peaker> class Bifunctor where needsName :: (BiFunctor bi, Functor f) => bi a b -> f b
08:53:44 <SamB_XP> Peaker: you need to read the paper, dude
08:53:55 <Peaker> SamB_XP: what paper?
08:54:04 <dolio> All of them.
08:54:12 <SamB_XP> dolio: all of what papers ?
08:54:17 <Peaker> arg, oops
08:54:20 <SamB_XP> I was thinking the clowns/jokers one
08:54:22 <Peaker> class Bifunctor bi where needsName :: Functor f => bi a b -> f b
08:54:25 <dolio> I don't know.
08:54:39 <dolio> Does that have a lot to do with bifunctors?
08:54:41 <Peaker> I don't want:  class Bifunctor bi where bifmap :: (a -> b) -> (c -> d) -> bi a c -> bi b d
08:54:51 <Peaker> bit then I'd need trifunctor, quadfunctor, etc
08:54:56 <Peaker> s/bit/because
08:55:02 * Peaker didn't get a lot of sleep :-)
08:55:06 <idnar> I don't understand the point of your needsName function
08:55:36 <dolio> Bifunctors are just functors of 'multiple arguments'.
08:55:50 <Peaker> idnar: I was hoping to be able to use it to "reduce" something like a Bifunctor to a normal functor, in a general way that would also allow reducing a Trifunctor to a Bifunctor, etc
08:56:09 <dolio> Like, if a functor is "C -> D" where C and D are categories, then a bifunctor is "C x C' -> D' where C, C' and D are categories.
08:56:40 <Peaker> dolio: so its not the bifmap I have above?
08:56:41 <BONUS> needsName = secondF
08:57:03 <dolio> Peaker: That's a specialization, yes.
08:57:11 <idnar> Peaker: you seem to be "reducing" it by throwing away half of it
08:57:14 <Peaker> dolio: what is the Haskell type?
08:57:23 <dolio> Just like the Functor class is a specialization of a more accurate model of categorical functors.
08:57:25 <idnar> Peaker: how is that useful?
08:57:33 <Peaker> idnar: well, if I want the first half, I just use normal fmap. If I want the second half, I can use:  reduce fmap
08:57:37 <dolio> Peaker: You got the type right.
08:58:35 <idnar> I'd expect bi a b -> f a then, at least
08:59:22 <dolio> Peaker: Bifunctors are 'regular' functors from product categories, so you can generalized that way.
08:59:26 <Peaker> idnar: that's just flipped?
08:59:38 <dolio> But I'm not sure modeling product categories in Haskell would be easy.
09:00:28 <Peaker> dolio: I was about to make up Either3 a b c = A a | B b | C c  -- as a contrived example to ask how you'd use bifmap to access each, but then I realized I'd really compose Eithers for that, and then I can use: bifmap id (bifmap ...) ...
09:00:59 <dolio> Yes, well, Either3 a would be a bifunctor.
09:01:05 <dolio> And Either3 would be a trifunctor.
09:01:11 <Peaker> dolio: I don't want "trifunctors" to exist :-)
09:01:14 <dolio> And Either3 a b would be a functor.
09:01:18 <EvilTerran> Either would be a bifunctor, wouldn't it?
09:01:24 <dolio> Yes.
09:01:30 <EvilTerran> and (,)?
09:01:34 <dolio> Yes.
09:02:02 * EvilTerran seems to be following. excellent. :)
09:02:03 <Peaker> So is there also Trifunctor and Quadfunctor/etc defined? :(
09:02:13 <dolio> I doubt it.
09:12:15 <hugo___> hello
09:19:49 <byorgey> hi hugo___
09:22:02 <pejo> CakeProphet, ping?
09:24:05 <jj1289> Maybe this is a dumb question: Is there any particular reason that some functions (head, ...) blow up in your face when used incorrectly, while other functions (find, lookup, ...) get encapsulated with Maybe? It seems inconsistent (and thus annoying)
09:24:29 <vixey> no
09:24:46 <BONUS> its just that it would be kind of tedious to use head etc.
09:24:54 <BONUS> if you always had to check for maybe and so
09:25:08 <BONUS> usually when using head, you watch out that its not an empty list
09:25:24 <vixey> nobody really uses head though, do they?
09:25:28 <BONUS> either by using it in an equation that has an (x:xs) pattern or checking with null beforehand
09:25:31 <vixey> I mean.. it's useless
09:25:32 <ozy`> aaaagghhhhh
09:25:43 <BONUS> yeah, i can't remember the last time i used it though
09:25:45 <jj1289> That's what i'm thinking when I use find, I know that it will work in my code
09:25:56 <vixey> map head . group . sort
09:26:07 <vixey> ^ useless use of head..
09:26:10 <jj1289> Are there any coding standards that I should follow regarding this?
09:26:20 <mib_smsn9w> hi .. I am just starting to learn haskell ... I am kinda not getting wats the difference between let x=11 and  x=11 ..
09:26:28 <dolio> Why is that useless?
09:26:29 <maltem> vixey: useless?
09:26:32 <BONUS> vixey: how would you do that without head
09:26:46 <jonaskoelker> map (\x:_ -> x) ...?
09:26:52 <mib_smsn9w> anyone can clear it up for me please ?
09:26:55 <ozy`> mib_smsn9w: sounds like you're running into GHCi's weird syntax :p
09:26:59 <vixey> there should be a function that takes [] -> []; (x:_) -> [x]
09:27:17 <jj1289> @jonaskoelker: that seems clumsy
09:27:18 <lambdabot> Unknown command, try @list
09:27:23 <baaba> mib_smsn9w, the difference is in which context you need one or the other
09:27:35 <jonaskoelker> jj1289: yeah... I *for* head :)
09:27:40 <jonaskoelker> s/I/I'm/
09:27:44 <jj1289> ;)
09:27:46 <ozy`> mib_smsn9w: "let ..." is used inside a function definition. you have to use it inside GHCi because it "pretends" to be a function definition that's evaluated incrementally
09:27:49 <baaba> mib_smsn9w, both create a binding but to create a local binding (ie. within the scope of a function definition) you need let
09:27:52 <jonaskoelker> just like I told my gf :)
09:28:01 <vixey> jonaskoelker, gross + I wasn't suggesting that
09:28:04 <dolio> That function isn't useful in the same places as head, though.
09:28:04 <BONUS> mib_smsn9w: if you're in a .hs file, to define top level functions, just use x = blah
09:28:08 <BONUS> in ghci, you do let x = blah
09:28:10 <mib_smsn9w> baaba: oh
09:28:11 <mib_smsn9w> k
09:28:15 <BONUS> and inside functions, you can use let bindings to give names to stuff
09:28:22 <ozy`> mib_smsn9w: also, in most cases you need to follow "let" with "in"... unless you're inside a "do" block
09:28:28 <jonaskoelker> vixey: so what are you suggesting?
09:28:32 <BONUS> x = let foo = bar; blue = red; in whatever
09:28:35 <EvilTerran> <vixey> there should be a function that takes [] -> []; (x:_) -> [x]
09:28:38 <EvilTerran> "take 1" :)
09:28:51 <ozy`> > take 1 []
09:28:53 <lambdabot>   []
09:28:55 <ozy`> huh
09:29:06 <dolio> map head . group . sort is actually one of the few valid uses of head, since group is guaranteed to produce non-empty lists as elements.
09:29:13 <mib_smsn9w> yeah .. I guess it looks obvious to me now .. its just that in the Real World Haskell book they haven't shown let expressions with a "in"
09:29:18 <maltem> filter (not . null) . take 1  doesn't really feel much better than  map head
09:29:20 <dolio> The types just don't prove it's right.
09:29:27 <vixey> dolio, It's also guaranteed that all the elements in each group are equal
09:29:33 <baaba> > let f x y = x + y in f 5 3
09:29:35 <lambdabot>   8
09:29:37 <mib_smsn9w> (at the start of the book that is )
09:29:40 <EvilTerran> maltem, it'd be "concat . map (take 1)" instead of "map head"
09:29:50 <dolio> Yes, and?
09:29:51 <mib_smsn9w> baaba: thanks a lot
09:29:56 <ozy`> mib_smsn9w: the inconsistent "let" rules confuse everyone who's just starting haskell. don't worry, you'll get used to it
09:30:01 <vixey> dolio, but it's rubbish to write programs that assume that instead of actually expressing it in types
09:30:13 <jkff> mib_smsn9w: Then most probably you've been so far reading only the bits that showed interaction in ghci
09:30:21 <maltem> EvilTerran: oh right :-/ still, doesn't feel better
09:30:23 <mib_smsn9w> ozy`: yeah .. I am thinking of it like the 'with' in javascript .. is that right ?
09:30:23 <dolio> Assume what?
09:30:33 <BONUS> nah, its just for giving names to stuff
09:30:38 <ozy`> mib_smsn9w: don't know javascript, so couldn't say.
09:30:38 <BONUS> in GHCI, you don't need the in part
09:30:39 <mib_smsn9w> jkff: yeah ..
09:30:40 <EvilTerran> vixey, unfortunately, "group" doesn't express non-emptiness of the sublists it returns in its type
09:30:44 <vixey> dolio, either of those two post conditions of group
09:30:54 <BONUS> in haskell, you do, unless you're in a do block or list comprehension, but you'll come to that :]
09:31:10 <dolio> Well, you could do it.
09:31:16 <EvilTerran> i'd consider it ok to use partial functions in a production situation, if, for instance, it passes Catch's analysis
09:31:24 <EvilTerran> and i think (map head . group) would
09:31:27 <EvilTerran> ?where catch
09:31:28 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
09:31:55 <baaba> we need a @catch :)
09:32:17 <jonaskoelker> EvilTerran, vixey: encoding information in the types... doesn't that run up against either undecidability or not being fun to program in?
09:32:26 <pejo> EvilTerran, catch needs to work on all the common ghc extensions for that to be a useful definition though.
09:32:30 <jonaskoelker> (info such as nonemptyness of lists)
09:33:07 <maltem> jonaskoelker: you would just have group return [(a,[a])] instead of [[a]]
09:33:10 <Peaker> group's result is always passed to head or length, isn't it?
09:33:16 <jonaskoelker> hm
09:33:20 <EvilTerran> Peaker, yeah, that's true =/
09:33:23 <EvilTerran> er, pejo
09:33:32 <Peaker> usefulGroup = map (head &&& length) group
09:33:49 <EvilTerran> Peaker, now what about groupBy?
09:33:50 <maltem> jonaskoelker: because (a,[a]) expresses the idea of a non-empty list
09:34:00 <jonaskoelker> nod
09:34:01 <Peaker> EvilTerran: groupBy is useful as it is :)
09:34:02 <EvilTerran> maltem, of course, either of those values could be partial in haskell anyway
09:34:11 <EvilTerran> maltem, so it's a bit of a losing battle
09:34:17 <jkff> jonaskoelker: That *does*; that's why theorem proving assistants with crazy type systems, like Coq, are hard to use, require a lot of brain-twisting and are used manually, not automatically.
09:34:45 <jkff> jonaskoelker: Although, to my mind, Coq is fun to program in; just a perverse kind of fun
09:34:52 <jonaskoelker> the best kind!
09:34:53 <jonaskoelker> :)
09:35:03 <jkff> True!
09:35:15 <BONUS> lol
09:35:18 <Peaker> Is Coq used for "real" work?
09:35:21 <Peaker> What can you do in Coq?
09:35:22 <EvilTerran> maltem, the solution being to switch to using a total language; but then it all becomes a bit obtuse (Coq, for instance)
09:35:33 <jonaskoelker> prove things very slowly
09:35:34 <jkff> Peaker: They've built a C compiler in Coq
09:35:35 <jonaskoelker> (I guess)
09:35:39 <jonaskoelker> :O
09:35:40 <jkff> Mostly in Coq, partly in OCaml
09:35:49 <maltem> EvilTerran: how so? Any value might be bottom, still Haskell has a type system that is useful
09:35:55 <jonaskoelker> just the parts they couldn't prove, yeah? :P
09:35:55 <Peaker> jkff: just a C compiler "front end", according to google?
09:36:35 <EvilTerran> maltem, yes, true... i mean, there's a limit to how much obsessing over partial values is appropriate when working in haskell
09:36:40 <pejo> Peaker, look at Xavier Leroy's homepage.
09:36:50 <Peaker> maltem: If you really use (a, [a]), then use a newtype so you have Functor, Applicative, and the other list goodies on it
09:37:08 <jkff> Peaker: http://sneezy.cs.nott.ac.uk/darcs/DTP08/slides/Xavier.pdf
09:37:19 <jkff> Programming and verifying a compiler with Coq:
09:37:19 <jkff> an experience report
09:37:23 <Peaker> thanks
09:37:24 <roconnor> > fmap (+1) (0,[1,2])
09:37:26 <lambdabot>       No instance for (Num [t])
09:37:26 <lambdabot>        arising from the literal `1' at <inter...
09:37:30 <maltem> EvilTerran: true, but I'm not sure why a type for a non-empty list specifically should exceed the limit :)
09:37:33 <roconnor> > fmap (+1) ([1,2],0)
09:37:35 <lambdabot>   ([1,2],1)
09:38:06 <maltem> Peaker: actually I agree with you that group by itself is quite useless
09:38:25 <maltem> Peaker: so the question of the best type for it doesn't really arise ;)
09:38:36 <jkff> It compiles a subset of C to PowerPC assembler, and its speed is about that of gcc -O1
09:43:21 <ozy`> mib_smsn9w: still here?
09:43:24 <dons> good stuff, http://www.reddit.com/r/programming/comments/7osfa/arithmetic_performance_in_the_llvm_versus_haskell/
09:44:09 <kowey> does anybody have news about the next Haskell Hackathon?
09:44:48 <ozy`> http://www.rsmw.net/ergo/ghci_quux.png <== just made this. it might be useful for people.
09:45:26 * ozy` shrugs
09:46:09 <kowey> and also, wasn't there an idea floating around about putting Haskell library wishlist items on reddit?
09:46:22 <ozy`> kowey: yeah, it's still around
09:46:25 <ozy`> haskell_proposals
09:46:35 <jkff> ozy`: What font and color scheme do you use?
09:46:46 <kowey> oh... I wonder why not just posting on haskell itself
09:46:58 <jkff> The font is very cool
09:47:03 <ozy`> jkff: deja vu sans mono (10 or 11, I forget), and two2tango
09:47:07 <kowey> i see... lots of proposals
09:47:19 <ozy`> on a mac, by the way
09:47:23 <jkff> ozy`: Thanks
09:47:29 <ozy`> if you're on linux you might want to play with your antialiasing
09:47:55 * ozy` salutes
09:48:07 <jkff> Nope, I'm on Windows
09:48:38 <ozy`> oh... oh I'm so sorry
09:48:40 <ozy`> I had no idea
09:48:48 <ozy`> I'm really sorry man
09:48:57 <jonaskoelker> lol
09:49:44 <CakeProphet> pejo:  hmmm?
09:49:46 <jkff> Hehe :) Well, anyways I spend 80% of my time in Vim, browsers, stuff written in Java and in putty terminals :)
09:50:53 <SamB> jkff: how much time do you spend running a vim java applet in a browser over putty ?
09:51:54 <jkff> SamB: As of now, none, but it definitely qualifies as a perverse kind of fun mentioned above, so I'll give it a try when I figure out how!
09:58:53 <kerlo> Ello.
10:01:22 <kerlo> @bot
10:01:22 <lunabot>  :)
10:01:22 <lambdabot> :)
10:01:28 <memento> q2 zh volt, nem kell hozzá sok IQ, van 1 könyv, abból kérdeznek,
10:01:28 <memento> sry
10:01:34 <kerlo> Yep, she's alive.
10:03:58 <redditbot> Verifying Compiler Transformations for Concurrent Programs | Lambda the Ultimate
10:03:58 <redditbot> musicxml: parse and write musicxml with Haskell
10:03:58 <redditbot> Arithmetic in the LLVM
10:03:58 <redditbot> GHC on SPARC: Bootstrapping 6
10:04:40 <CakeProphet> oh... you can specify rewrite rules in Haskell?
10:04:42 <CakeProphet> that's cool.
10:05:14 <kerlo> Sounds like someone's abusing GHC's compile-time capabilities.
10:05:31 <jkff> CakeProphet: But not as cool as it could be: neither does the compiler do anything to make the rules applicable if they aren't applicable 'as is', nor does it protect from looping etc
10:06:16 <jkff> CakeProphet: So, it just matches the terms exactly, and just applies the rules.
10:06:18 <jonaskoelker> :-? -- protect from looping?  How do you go about that?
10:06:50 <jkff> jonaskoelker: What do you mean?
10:07:03 <jonaskoelker> jkff: how general are the rewrite rules?
10:07:14 <jonaskoelker> jkff: isn't there some kind of halting problem somewhere?
10:07:46 <kerlo> I wonder if this means it's possible to compile Thue into GHC Haskell.
10:08:05 <jkff> They are not general at all, and the halting problem issue does arise.
10:08:21 <jkff> So, they are useful in a very narrow class of cases
10:09:14 <jkff> (I'm wrong about 'does nothing to make the rules applicable': as I read in the paper on GHC inliner, the inliner assigns a larger cost to a variable that has rewrite rules attached to it)
10:09:49 <kerlo> Are the rewrite rules compile-time only?
10:09:59 <jkff> Yes
10:10:07 <SamB> kerlo: yeah -- they're for optimization
10:10:21 <SamB> searching for rewrite rules at runtime doesn't tend to be useful for that!
10:10:36 * kerlo nods
10:12:18 <pejo> jkff, there's a separate paper on the rewrite rules from around the same time that the inliner paper was written.
10:15:58 <Peaker> runtime rewrite rules can be interesting...
10:16:29 <Peaker> for example,  (reverse . reverse = id) might only be applicable after you have identified that "reverse" was used in runtime (You can't, having no Eq for functions, but ghc/rts can, especially if someone evaluates to reverse itself directly)
10:16:40 <Peaker> it might be worth it, in some cases
10:18:12 <pejo> Peaker, why would it be bad to rewrite it during compile time?
10:18:46 <Peaker> f x = if expr x then reverse else id ; How do you rewrite:  reverse . f x
10:19:47 <Peaker> Maybe you can compile-time rewrite that to:   reverse . if expr x then reverse else id -> if expr x then reverse . reverse else reverse -> if expr x then id else reverse
10:34:01 * SamB wonders where to get a bot for #lhc-compiler
10:34:19 <SamB> a bot that would do logging
10:35:09 <sjanssen> Peaker: but reverse . reverse does not equal id
10:35:27 <Peaker> sjanssen: its more refined?
10:35:33 <sjanssen> Peaker: yes
10:35:41 <Peaker> well, you can make stuff more refined..?
10:35:41 <BONUS> reverse . reverse $ [1..]
10:36:07 <sjanssen> Peaker: no, I don't think you can
10:36:36 <Peaker> sjanssen: I think compilers are allowed to make a program more refined? What's the damage in that?
10:37:35 <sjanssen> Peaker: it changes the semantics of programs, good compilers don't do that
10:37:47 <jkff> The transformation will not preserve semantics, and anything that relies on this fact will break
10:38:00 <Peaker> sjanssen: only for the better :-)
10:38:05 <Peaker> brb
10:38:17 <sjanssen> Peaker: is it right for a program built with hugs to crash while the same program built with ghc will run successfully?
10:38:35 <Peaker> sjanssen: s/crash/hang -> yeah, why not
10:38:47 <Peaker> sjanssen: We already have that, too
10:39:01 <Peaker> sjanssen: strictness analysis avoids crashes
10:39:05 <Peaker> as well as optimizes
10:39:08 <Peaker> (real brb)
10:39:14 <sjanssen> Peaker: crashing and hanging are the same thing in Haskell '98
10:39:44 <jkff> I wonder whether there is a special name for theorems T such that if T(A) and B is more defined than A, then T(B).
10:39:54 <sjanssen> and strictness analysis only avoids crashes because we're executing on an imperfect machine (one with finite memory)
10:40:05 <jkff> Doing reverse . reverse -> id will not break these theorems, and will break others
10:41:07 <jkff> Probably theorems for which there exists a propositional formulation that does not use negation? But I doubt that this is well-defined
10:47:54 <drdozer> are there any commands in ghci to explore indexed types?
10:48:33 <drdozer> I keep getting horrible types that /should/ be equivalent to things like Int or String
10:48:44 <drdozer> but ghci only shows the indexed type form, not reductions of it
10:52:19 <knapr> how would haskell and hmatrix be for handling a 17770 * 480000 size matrix?
10:55:58 <kerlo> Ello.
10:56:08 <bremner> > (17770 * 480000 * 8)/(1024*1024)
10:56:10 <lambdabot>   65075.68359375
10:56:29 <bremner> knapr: you have 65G of memory, or sparse matrices?
10:58:03 <dolio> 1 byte elements are probably optimistic, too.
10:58:47 <bremner>  hence the *8
10:59:53 <dolio> Oh right.
11:00:18 <dolio> For some reason I was thinking 'number of bits/byte' there.
11:03:45 <ehird> Is yi stable enough to code haskell in it? :-)
11:04:55 <Saya> ok heres a boring question, i installed ghc 6.10 from a tar.bz.2 (ubuntu intrepid) but took the from libedit one so it installs but doesnt run but i cant seem to find an uninstall script provided! how do i uninstall ? :'(
11:05:26 <Saya> s/from/wrong >.<
11:05:51 <dolio> Just delete it from /usr/local
11:06:27 <pejo> Saya, you usually only get uninstall "automatically" if it's packaged (.deb in your case).
11:06:35 <arjanb> the haskell wiki has been spammed
11:06:44 <Saya> nope its a tar.bz
11:07:07 <Saya> yeah but if i just delete the folder wont there be console aliases and stuff like that left
11:07:19 <Saya> or it just scans the lib folder
11:07:29 <ibid> tar.gz's aren't typically meant to be user-friendly :)
11:07:48 <ibid> or tar.bz2's
11:08:02 <dolio> The only thing it does is install stuff in /usr/local
11:08:19 <dolio> Since that's first in $PATH, it overrides stuff in /usr.
11:08:20 <Saya> and a few stuff in bin
11:08:22 <ibid> some of them do provide make uninstall, but i usually don't bother - too many ways it could go wrong
11:08:29 <Saya> ok i just rm -r it :)
11:08:45 <BONUS> hmm why does this just hang at "
11:08:54 <pejo> Saya, you might have other things in /usr/local, so be a bit careful.
11:09:15 <iago> Saya, delete /usr/local/share/doc/ghc /usr/local/share/man/man1/ghc.1 /usr/local/lib/ghc-6.10.1
11:09:18 <BONUS> connectTo "google.com" (PortNumber 80) >>= \h -> hPutStr "GET / HTTP/1.1\r\n\r\n" >> hGetContents h
11:09:31 <dons> augustss: i wonder if it is possible to get syntax highlighting for code fragments in your blog?
11:09:52 <iago> Saya, and the following binaries from /usr/local/bin : ghc  ghc-6.10.1  ghci  ghci-6.10.1  ghc-pkg  ghc-pkg-6.10.1  haddock  hasktags  hp2ps  hpc  hsc2hs  runghc  runhaskell
11:10:31 <ski_> BONUS : try s/(PortNumber 80)/80/ ?
11:10:54 <iago> Saya, and, I usually install things in $HOME/local , or another ad-hoc directory
11:10:56 <BONUS> connectTo is String -> PortID -> IO Handle
11:11:13 <ibid> BONUS: what does "hang at "" mean?
11:11:22 <BONUS> well i do that in ghci
11:11:23 <robyonrails> how can I define functions in GHC interactive interpreter?
11:11:28 <robyonrails> (directly)
11:11:28 <BONUS> and i just get a " printed out
11:11:30 <ibid> robyonrails: use let
11:11:31 <wjt> robyonrails: let f x = x + 3
11:11:32 <BONUS> and that's it
11:11:36 <robyonrails> thx!
11:11:40 <ski_> BONUS : istr you should use the `Num' interface of `PortID' ..
11:12:03 <BONUS> whaddaya mean
11:12:47 <BONUS> ooh i see now
11:13:17 <BONUS> PortNumber is in Num
11:13:41 <ibid> BONUS: your snippet doesn't typecheck here
11:14:04 <BONUS> i'm using Network
11:14:12 <BONUS> not the lower level ones
11:14:14 <ski_> BONUS : possibly there's an `instance Num PortID', so you can use `80' instead
11:14:16 <BONUS> just playing with it basically
11:14:21 <ibid> BONUS: you were missing an h :)
11:14:32 <BONUS> ah yeah but it still needs the constructor
11:14:36 <ibid> BONUS: which tells me you didn't paste it directly
11:14:42 <BONUS> yeah i didnt, sorry boot that
11:14:44 <ibid> BONUS: in any case, for me it just returns ""
11:14:44 <BONUS> let me try again
11:14:50 <ibid> no point :)
11:14:52 <BONUS> yeah
11:14:58 <BONUS> hmmm ""?
11:15:01 <ibid> i got it to work, except it returns an empty string here
11:15:05 <BONUS> for me it just does " and then i have to kill ghci
11:15:07 <ibid> after several seconds
11:15:13 <ibid> how long did you wait?
11:15:17 <BONUS> not really long
11:15:19 <BONUS> let'se see
11:15:36 <ibid> in any case, your HTTP is malformed :)
11:16:08 <ibid> (missing host header in 1.1)
11:16:11 <ehird> Now taking bets as to how long ghc will take to compile
11:16:19 <BONUS> ah, of course
11:16:21 <BONUS> how stupid of me
11:16:24 <ehird> Betting aids: 2ghz intel core 2 duo, 2.5 GB of ram
11:16:29 <ibid> BONUS: but doesn't help :)
11:16:30 <knapr> it is the netflix dataset, 17770 movies, 480K users, very sparse
11:16:42 <knapr> so will this bring ghc to its knees?
11:16:55 <BONUS> although if i just telnet to google.com and try it without the Host header it works
11:16:58 <BONUS> yeah i get an empty string
11:16:59 <BONUS> strange
11:17:06 <BONUS> even when i do "localhost" on my own serevr
11:17:30 <ibid> BONUS: if you say HTTP/1.1, the server should tell you if you're missing Host
11:18:12 <monochrom> IIRC in HTTP/1.1 you must give Host.
11:18:20 <ibid> monochrom: exactly my point
11:18:30 <ibid> monochrom: and the server is required to diagnose a missing host
11:18:36 <monochrom> Ah.
11:18:39 <ibid> (not that google seems to care)
11:19:02 <BONUS> yeah anyway, it still shouldnt give back just an empty string
11:19:20 <ibid> BONUS: ah, now i know
11:19:47 <ibid> BONUS: you never flush the output buffer, and google is impatient (fast timeout)
11:19:56 <ibid> connectTo "google.com" (PortNumber 80) >>= \h -> hPutStr h "GET / HTTP/1.1\r\n\r\n" >> hFlush h >> hGetContents h
11:19:59 <ibid> that works here
11:20:09 <ibid> (even though it's malformed http/1.1 :)
11:20:12 <BONUS> aaah i see
11:20:15 <BONUS> noice, thanks!
11:20:32 <BONUS> so this isn't line buffered then eh?
11:20:34 <BONUS> hmm good to know
11:20:52 <ibid> BONUS: i believe sockets aren't, generally
11:20:58 <ibid> BONUS: you know what tipped me off?
11:21:04 <BONUS> haha what
11:21:16 <ibid> BONUS: i was too slow with telnetting google :)
11:21:23 <ibid> so i noticed their fast timeout
11:21:29 <BONUS> haha :D
11:22:00 <monochrom> Using telnet to surf the web is hard. Let's go sshing.
11:23:03 <SamB> monochrom: try IRCing with telnet ssometime
11:23:15 <ibid> hah, ought to be a trivia question on some quiz along the lines "which protocol is it whose servers are a bad idea and whose clients are essential?"
11:23:32 <SamB> X
11:24:18 <SamB> ibid: what did you mean for the answer to be ?
11:24:22 <ibid> SamB: telnet
11:24:40 <SamB> oh, so nethack.alt.org is a bad idea ?
11:24:53 <ibid> SamB: well, ok, there may be some occasional uses for them
11:25:10 <SamB> or do you think that should use SSH ?
11:25:11 <ibid> SamB: but only if you can't actually access a shell using it
11:25:39 <SamB> yeah, someone somewhere probably provides telnet access to shells still ...
11:26:18 <nolrai_East> what does "GADT pattern match in non-rigid context" mean?
11:26:18 <ibid> SamB: actually, somewhat similar to how authenticated ftp is a nightmare but anonymous ftp is useful (though mostly displaced by http nowadays)
11:26:21 <pejo> SamB, it seems to be common among the people that use Kerberos.
11:27:00 <ibid> SamB: i suppose this highlights the old rule, all rules have exceptions :)
11:27:07 <SamB> yeah, may rsync over SSH prevail
11:27:31 <ehird> RLOGIN!!
11:27:58 <SamB> export CVS_RSH=ssh
11:28:04 <SamB> duh
11:28:19 <ibid> that probably only helps with CVS?
11:28:24 <SamB> oh, plus why are you still using CVS?
11:28:44 <ibid> who is using CVS?
11:28:45 <SamB> and otherwise why are you admitting to have even heard of rlogin ?
11:28:49 <ibid> :)
11:28:54 <pejo> nolrai, http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg14922.html
11:28:59 <monochrom> IRCing with telnet is hard. Once in a while the server pings you and you have to pong. Pretty annoying if you have to afk.
11:29:10 <nolrai_East> pejo: thanks!
11:29:15 <SamB> monochrom: and setting up your nick is a pain, too
11:29:20 <ibid> monochrom: well, that's useful if you're on one of those channels that frown on idling :)
11:29:29 <SamB> if you don't type fast enough you get kicked iff immediately
11:29:31 <ehird> naw
11:29:35 <SamB> s/iff/off/
11:29:37 <ehird> freenode doesn't kick non-pongs in my experience
11:29:57 <SamB> | *
11:29:58 <pejo> ehird, in that case nobody will ever ping timeout.
11:30:10 <ehird> when was the last time you saw a freenode ping timeout
11:30:16 <SamB> pojo: what about TCP ping ?
11:30:22 <ibid> pejo: it's possible they kick on extensive pong failures
11:30:24 <SamB> er. pejo
11:30:29 <Deewiant> Is there something like System.Directory.copyFile which copies symbolic links as-is, instead of dereferencing them?
11:30:34 <ehird> hi Deewiant
11:30:36 <Badger>  * |
11:30:41 <Deewiant> yo
11:30:48 <knapr> lambdabot: can haskell handle a 17770*480K matrix?
11:30:53 <SamB> oh shit
11:30:55 <SamB> *|
11:31:00 <Badger> \o/
11:31:04 <SamB> Badger: gets the point
11:31:06 <Deewiant> @vixen can haskell handle a 17770*480K matrix?
11:31:06 <lambdabot> church is my favourite computer scientist.
11:31:26 <Badger> @vixen play pong with me
11:31:26 <lambdabot> Are you adopted by trolls?
11:31:35 <pejo> SamB, there's no such thing in tcp, the ping timeout messages that you usually see on irc is because the irc server didn't get a pong back (from the irc user) soon enough when it sent a ping.
11:31:45 <SamB> pejo: sure there is
11:31:50 <rankp> @lambdabot can haskell handle a 480K*17770 matrix?
11:31:50 <lambdabot> Unknown command, try @list
11:31:53 <SamB> if you send stuff and you don't get an ack ...
11:31:58 <rankp> @faq can haskell handle a 480K*17770 matrix?
11:31:59 <lambdabot> The answer is: Yes! Haskell can do that.
11:32:05 <rankp> lier!
11:32:22 <SamB> rankp: well, is it a sparse matrix ?
11:32:28 <koeien> i once used 4096x512 matrices in Haskell :) but 480K is pretty big. sparse, i hope?
11:32:29 <monochrom> @faq can haskell write my thesis?
11:32:29 <lambdabot> The answer is: Yes! Haskell can do that.
11:32:46 <ibid> monochrom: well, once you program it to do that
11:33:00 <monochrom> @hackage Academia.PhD.ThesisWriter
11:33:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Academia.PhD.ThesisWriter
11:33:01 <koeien> monochrom: putStrLn "\documentclass{report} ... "
11:34:06 <monochrom> The commands @faq and @hackage illustrate two basic combinators in functional programming: const and id. :)
11:36:45 <ziman> monochrom, :D
11:36:50 <pejo> SamB, if you send stuff and don't receive an ack you resend. It's not checking for liveness.
11:37:08 <ibid> pejo: but usually there is a TCP timeout
11:37:31 <SamB> are you unaware of tcpping ?
11:38:30 <rankp> yes very sparse!
11:38:50 <rankp> the point is
11:39:20 <rankp> is there even a point ing etting started with huge-scale numerical stuff in Haskell or should I stick to C++ and Python(scipy)?
11:39:37 <dons> rankp: how huge?
11:39:56 <dons> rankp: you wouldn't be the first. people do numerics in haskell (ghc's a good native code compiler, and there are many libraries).
11:40:03 <dons> i'd choose haskell first, but i tend to do that.
11:40:22 <dons> it depends on what your goals are.
11:40:29 <ibid> rankp: you may want to talk with aleator :)
11:40:32 <dons> want to do things in parallel?
11:40:50 <ibid> (though dunno about *huge* scale)
11:41:04 <dons> petascale?
11:41:07 <dons> exascale?
11:41:10 <rankp> netflix dataset, 17770*480000, very sparse
11:41:17 <rankp> (int)
11:41:37 <dons> what data structures/algorithms do you need?
11:41:46 <rankp> matrix
11:41:47 <ibid> dons: did you know that aleator's phd thesis had numerical results programmed in haskell? :)
11:41:50 <rankp> singular value decomposition
11:42:24 <dons> ibid: no, i didn't know that.
11:42:35 <dons> rankp: well, there's good , efficient matrix libs on hackage.haskell.org
11:42:43 <dons> all the usual things. blas, gsl, fftw etc
11:42:59 <dons> how much do you want to use haskell?
11:43:12 <dons> just updated today, in fact, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas-0.7.2
11:43:57 <byorgey> although note that the blas library doesn't do matrix decomposition
11:44:02 <byorgey> it's a bit more low-level
11:44:11 <byorgey> so said patrick's blog post at least
11:45:17 <pejo> SamB, the entire purpose of tcpping is to avoid ICMP filtering according to its homepage. There's no equivalent of ECHO_REQUEST in TCP.
11:47:00 <SamB> pejo: I KNOW
11:47:17 <SamB> but that same principle can be applied to IRC ping timeouts ...
11:47:46 <rankp> and the laziness is not gonna eat up my computer and byte my head off?
11:47:52 <rankp> bite
11:48:40 <ibid> dons: (not yet in PDF, i see)
11:50:48 <EvilTerran> rankp, it'll only do that if you use unsafePerformIO :P
11:51:30 <dons> rankp: laziness is your friend. use it if you like, or don't use it if you don't like.
11:52:37 <rankp> i see
11:53:01 <dons> i don't think we have any lazy matrix libs, so probably you won't care about laziness
11:54:21 <koeien> what would me want to prefer fundeps over type families?
11:54:49 <dons> there's a paper on how to design with them? http://web.cecs.pdx.edu/~mpj/pubs/fundeps-design.html
11:55:33 <dons> (i.e. well documented)
11:55:54 <koeien> or, the other way around. i think i can solve my problem with fundeps, but type families are "new"
11:56:03 <dons> well, you can probably solve with both.
11:56:32 <koeien> yeah, i thought so. that's why i asked if i should prefer one of them
11:58:24 <maltem_> koeien: type families being new means that they are cooler, but also people have less experience with them. so, pick the one that suits you
11:58:47 <dolio> Also the implementation is buggier.
11:58:49 <dolio> Maybe.
12:00:41 <koeien> maltem_, dons, dolio: thanks, i think i'll try type families because they are cool of course =) i'll see how it works out.
12:02:52 <dons> you could look at monads-tf and monads-fd to get a sense for them
12:03:59 <redditbot> Haskell BLAS bindings version 0.7
12:03:59 <redditbot> Monty Hall Problem Using Monte Carlo Simulations in Haskell
12:05:54 <Saya> iago: thx for the help
12:06:34 <chessguy> @pl f m s = n (t m s)
12:06:34 <lambdabot> f = (n .) . t
12:06:36 <chessguy> @bot
12:06:36 <lunabot>  :)
12:06:36 <lambdabot> :)
12:08:07 * byorgey bakes currant-lambda scones
12:10:14 <ekauq> newbie question: I need to put zeroes on the diagonal of a square matrix (nested lists), but I can't think in a way to do it... any hint?
12:10:40 <EvilRanter> ekauq, what're the other values in the matrix?
12:10:58 <ziman> EvilTerran, good alt nick ;)
12:11:06 <SamRH> ekauq: if you just want to overwrite the values, make a function that modifies the nth element of a list, and then use that function
12:11:10 <EvilTerran> > sort "evilranter" == sort "evilterran"
12:11:11 <lambdabot>   True
12:11:21 <EvilTerran> > sort "evilterran" == sort "irrelevant"
12:11:22 <lambdabot>   True
12:11:24 <EvilTerran> :D
12:11:42 <ehird> ha
12:12:14 * ehird considers writing a program that produces anagrams of a word with words from /usr/share/dict/words.
12:12:18 <ehird> that wouldn't be too hard, I guess.
12:12:52 <ekauq> EvilTerran, they are the sums of outer products of a set of vectors...
12:13:02 <sbahra_> What is JaffaCake's e-mail?
12:13:23 <kaol> why do I never seem to use a left fold? I sometimes start with that but end up doing a foldr, every time.
12:13:47 <SamRH> kaol: foldr follows the structure of a list
12:14:00 <EvilTerran> ekauq, i mean, do you have an existing matrix and are just overwriting the elements on the diagonal with 0, or are you doing algebraic manipulation to get some kind of equivalent matrix to what you've got already?
12:14:11 <EvilTerran> (equivalent but with 0s on the diagonal, i dunno)
12:14:25 <athos> 20:11:21 < EvilTerran> > sort "evilterran" == sort "irrelevant"
12:14:25 <athos> 20:11:22 < lambdabot>   True
12:14:28 <athos> lol :>
12:15:10 <chessguy> does this seem sensible to people? http://hpaste.org/13807
12:15:11 <EvilTerran> > zipWith (zipWith ($)) (iterate (id:) $ const 0 : repeat id) [[1,2,3],[4,5,6],[7,8,9]]
12:15:13 <lambdabot>   [[0,2,3],[4,0,6],[7,8,0]]
12:15:38 <EvilTerran> ekauq, if you're just replacing, there's an approach that'll do it
12:16:02 <ekauq> EvilTerran, thanks!
12:16:31 <EvilTerran> ekauq, but don't use it unless you know how it works :P
12:17:16 <ddarius> kaol: It depends on what you are doing and the kind of data you are producing.
12:17:33 <ddarius> kaol: You should know which fold you want before you start coding.
12:17:52 <byorgey> ehird: already been done, check out the 'wordplay' package in debian/ubuntu  =)
12:18:05 <ehird> byorgey: But, has it been done in haskell?
12:18:09 <ehird> I rest my case.
12:18:14 <byorgey> oh, well, probably not =)
12:18:16 <ekauq> EvilTerran, i could do both ways (overwriting or algebraic manipulation), because the matrix values are calculated
12:18:28 <EvilTerran> i see... ish
12:18:42 <ekauq> EvilTerran, now i'm trying to figure out how your code works ;)
12:18:43 <ehird> :t (<*>)
12:18:44 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:18:46 <EvilTerran> overwriting's probably easier, if it works :)
12:19:40 <newsham> > iterate ("id":) $ "const 0" : repeat "id"
12:19:42 <lambdabot>   [["const 0","id","id","id","id","id","id","id","id","id","id","id","id","id...
12:19:58 <ehird> Hmm, <*> is not what I was thinking of, I think.
12:20:03 <newsham> > iterate ("id":) $ take 3 ("const 0" : repeat "id")
12:20:04 <lambdabot>   [["const 0","id","id"],["id","const 0","id","id"],["id","id","const 0","id"...
12:20:18 <ehird> @hoogle (a -> b) -> f a -> f b
12:20:18 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
12:20:18 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:20:18 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:20:22 <ehird> Aha. <$>
12:20:45 <ddarius> mapM_ (putStrLn . show . map fst) . groupBy fst . ap (,) sort . lines =<< getContents
12:21:28 <ddarius> :t mapM_ (putStrLn . show . map fst) . groupBy fst . ap (,) sort . lines =<< getContents
12:21:29 <lambdabot>     Occurs check: cannot construct the infinite type:
12:21:30 <lambdabot>       a = (a, b) -> Bool
12:21:30 <lambdabot>     Probable cause: `fst' is applied to too many arguments
12:21:35 <chessguy> @type ap (,) sort xs :: [String]
12:21:36 <lambdabot> Not in scope: `xs'
12:21:45 <ddarius> :t mapM_ (putStrLn . show . map fst) . groupBy (comparing fst) . ap (,) sort . lines =<< getContents
12:21:46 <lambdabot>     Couldn't match expected type `Bool'
12:21:46 <lambdabot>            against inferred type `Ordering'
12:21:46 <lambdabot>       Expected type: (a, b) -> (a, b) -> Bool
12:21:52 <ddarius> bah
12:21:55 <chessguy> @type ap (,) sort (?xs :: String)
12:21:56 <lambdabot> (?xs::String) => ([Char], [Char])
12:22:09 <ddarius> :t groupBy
12:22:10 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
12:22:32 <ddarius> :t mapM_ (putStrLn . show . map fst) . groupBy ((==) `on` fst) . ap (,) sort . lines =<< getContents -- last time
12:22:34 <lambdabot>     Couldn't match expected type `[(a, b)]'
12:22:34 <lambdabot>            against inferred type `([String], [String])'
12:22:34 <lambdabot>       Expected type: String -> [(a, b)]
12:22:47 <chessguy> > ap (,) sort ["foo", "bar", "z"
12:22:49 <lambdabot>   <no location info>: parse error on input `;'
12:23:01 <chessguy> > ap (,) sort ["foo", "bar", "baz"]
12:23:02 <lambdabot>   (["foo","bar","baz"],["bar","baz","foo"])
12:23:37 <roconnor> chessguy: what monad is that?
12:23:39 <ddarius> I guess that should be a map (ap (,) sort).  I changed the input half-way through.
12:23:56 <chessguy> roconnor:  i dunno
12:24:00 <roconnor> oh reader monad
12:24:07 <roconnor> it's the sorted and orginal lists
12:24:13 <chessguy> yeah
12:24:44 <roconnor> boy, haskell can be hard to read sometimes
12:25:01 <ddarius> Makes perfect sense to me.
12:25:19 <roconnor> it's easy to understand when you know what it does
12:26:03 <SamB> > (sort &&& id) ["foo", "bar", "baz"]
12:26:04 <lambdabot>   (["bar","baz","foo"],["foo","bar","baz"])
12:27:01 <sbahra_> vry nice
12:27:08 <kmeyer> what's ap?
12:27:12 <EvilTerran> ?type ap
12:27:14 <ddarius> @src ap
12:27:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:27:14 <lambdabot> ap = liftM2 id
12:27:24 <EvilTerran> ap = liftM2 ($) -- i prefer this version
12:27:32 <ddarius> That is a bit cleare.
12:27:33 <ziman> in the ((->) e) monad, it's the S-combinator
12:27:43 <ddarius> > ap f g x :: Expr
12:27:44 <lambdabot>   Add a type signature
12:29:30 <dolio> > ap (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x
12:29:31 <lambdabot>   f x (g x)
12:29:55 <EvilTerran> > ap (f :: Expr -> Expr -> Expr) g x -- should be sufficient
12:29:57 <lambdabot>   f x (g x)
12:30:16 <kmeyer> and ($) is an apply function?
12:30:25 <EvilTerran> ?src ($)
12:30:26 <lambdabot> f $ x = f x
12:30:28 <EvilTerran> yes :)
12:30:39 <EvilTerran> it's really low precedence, so you can save on parentheses with it
12:31:05 <kmeyer> why is it needed then?
12:31:25 <yottis> it's useful in higher order functions
12:31:29 <EvilTerran> it's not needed, it's just a convenience. as i said, it lets you cut down on parentheses
12:31:48 <yottis> like zipWith ($) listOfFunctions listOfArguments
12:31:55 <EvilTerran> and it's clearer than "id" when you specifically want something that takes a function as its first parameter
12:32:14 <EvilTerran> also you can write ($ x), which is occasionally useful
12:33:05 <kmeyer> ok
12:33:36 <ddarius> :t (($ x), (`id` x))
12:33:37 <lambdabot> forall b t. ((Expr -> b) -> b, (Expr -> t) -> t)
12:34:55 <EvilTerran> ddarius, but `id` is four times longer than $ :P
12:36:50 <pumpkin> I have what may be a dumb question... I'm trying to do a foldlU over a UArr, using a MUArr as my fold state (that will presumably be updated as I fold through the UArr)... is this fundamentally flawed as I need to be carrying my ST with me through the fold, or is there some way to do it?
12:37:28 <EvilTerran> pumpkin, sounds like a "foldMU" kinda thing
12:37:35 <pumpkin> yeah :P
12:39:32 <Codex_> If a function f :: Int -> Int is a subset of (Int,Int), how would I write that?
12:39:55 <SamB> Codex_: in what language ?
12:40:12 <ddarius> > map (id &&& f) [minBound .. maxBound]
12:40:13 <lambdabot>   Add a type signature
12:40:14 <SamB> and it isn't, in fact, a subset
12:40:26 <SamB> it's just isomorphic with one
12:40:31 <Codex_> samB: what you mean it's not a subset?
12:40:37 <SamB> well, er. not isomorphic ...
12:40:38 <ddarius> SamB: It's not even that.
12:40:41 <EvilTerran> it's a function, not a set
12:40:45 <EvilTerran> .'. it's not a subset of anything
12:41:20 <SamB> it DOES forma a relation between Int and Int, if that's what you mean ;-P
12:41:59 <drdozer> Codex_:  A haskell function Int->Int is a procedure for calculating an Int given an Int.
12:42:28 <drdozer> Codex_: For any given set (Int, Int), there are infinitely many procedures for calculating the 2nd one from the 1st one
12:43:11 <SamB> drdozer: you sound confused
12:43:29 <SamB> drdozer: he was talking about sets of (Int, Int) -- that is, sets of pairs of Int
12:43:59 <pumpkin> is there some way of asking for a pure CAF to be computed at compile time
12:44:08 <pumpkin> oh actually, that's silly, it could be infinite still
12:44:41 <dolio> GHC doesn't really do much fancy compile-time evaluation.
12:45:05 <dolio> On its own, at least.
12:45:38 <maltem_> pumpkin: I think the only way is to compute it yourself, and put the result literally into the program :-/
12:45:53 <ddarius> maltem_: You could do that with TH
12:46:06 <ddarius> Alternatively, it should be possible to abuse rewrite rules to do it as well.
12:46:28 <jowens> howdy, i'm trying to do my first file input and getting some weird typing rules
12:46:29 <maltem_> TH would be advantageous if the result would span a million lines of code or something
12:46:39 <SamB> maltem_: I dunno
12:46:42 <jowens> project euler #22
12:46:42 <ddarius> maltem_: Nah, that wouldn't compile.
12:46:46 <jowens> the input file looks like this:
12:46:50 <jowens> "MARY","PATRICIA","LINDA", ...
12:46:52 <SamB> ddarius: it might COMPILE
12:47:02 <jowens> reading it like this:
12:47:03 <jowens>        inh <- openFile "names.txt" ReadMode
12:47:03 <jowens>        inpStr <- hGetContents inh
12:47:03 <SamB> but running it in GHCi would likely not work
12:47:07 <drdozer> SamB: I thought he was talking about f::Int->Int, which lets you compute a sub-set of (Int, Int) with something like \f -> map (\i -> (i, f i)) [minBound .. maxBound]
12:47:12 <pumpkin> jowens: for that one, I simply stuck a [ ] on both sides, and read it as [String] :P
12:47:23 <ddarius> SamB: I'm certain it wouldn't compile with any current GHC
12:47:30 <jowens> pumpkin: i hear ya, just figuring out what i'm doing wrong.
12:47:48 <jowens> i am splitting it and printing it:
12:47:50 <dolio> It has issues with compiling huge constants.
12:47:54 <jowens>        let m = (map init (map tail (splitOneOf "," inpStr)))
12:47:56 <n0nsense> building gtk2hs always fails...
12:48:01 <jowens> these are OK:
12:48:02 <jowens>        print m
12:48:02 <jowens>        print (head m)
12:48:10 <ddarius> It has issues compiling large amounts of code of any sort.
12:48:12 <jowens> and it prints: "MARY"
12:48:14 <pumpkin> jowens: maybe a paste service?
12:48:19 <jowens> but i can't do this:
12:48:20 <jowens>        print init(head m)
12:48:20 <pumpkin> would be easier to follow
12:48:25 <jowens> what's paste service?
12:48:30 <maltem_> ddarius: are you saying that generating a huge value with TH won't compile?
12:48:43 <pumpkin> maltem_: it won't :(
12:48:47 <dolio> print init(head m) = (print init) (head m)
12:48:50 <pumpkin> the compiler takes huge amounts of memory
12:48:50 <maltem_> ok...
12:49:07 <pumpkin> maltem_: it's not feasible to do even moderately large source files
12:49:09 * maltem_ has managed to totally avoid TH until now
12:49:15 <dons> large unboxed constants are fine :)
12:49:20 <pumpkin> jowens: http://hpaste.org/
12:49:21 <pejo> @paste -- jowens
12:49:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:49:35 <jowens> stupid parens
12:49:53 <jowens> oh, paste, cool, i can put in a big wad of code and then y'all can look at it?
12:52:06 <pumpkin> :t foldM
12:52:07 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:52:27 <pumpkin> @src foldM
12:52:28 <lambdabot> foldM _ a []     = return a
12:52:28 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:53:11 <jowens> ok this was a parens problem, i'm in good shape now, sorry for the false alarm
12:53:16 <jowens> thanks y'all
12:54:28 <Codex_> drdozer: that's exactly the construction for the subset based on (x, f x). I'm thinking of doing intersection between (x, f x) and (x, g x).
12:57:25 <n0nsense> jowens: stupid parents :D
13:00:50 <drdozer> Codex_: In the general case, you will probably want to compare the code for f and g, rather than compare the enumerations of these sets
13:01:13 <drdozer> Codex_: Of course, that's not trivial
13:01:26 <a_guest> Are the source files in the book "real world haskell" downloadable from internet?
13:03:07 <n0nsense> i hope gtk2hs compiles this time -.-'
13:03:21 <a_guest> ...yes. I found the sourcefile I needed from codesearch.google.com
13:03:40 <SamB> a_guest: the book is also available in webpage form
13:03:51 <SamB> aw nuts
13:04:23 <dcoutts> n0nsense: you're not trying to build the gtk2hs release tarball using ghc-6.10 are you?
13:04:57 <n0nsense> Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98, stage 2 booted by GHC version 6.8.2
13:05:02 <n0nsense> I think I'm not
13:05:39 <SamB> n0nsense: I didn't know there was an Haskell 98 version
13:05:46 <n0nsense> oh...
13:05:47 <n0nsense> seems so
13:05:58 <n0nsense> SamB: is it important?
13:06:48 <SamB> n0nsense: I'm just kidding, I thik
13:06:48 <n0nsense> wired-in package haskell98 mapped to haskell98-1.0.1.0
13:06:48 <n0nsense> SamB: i hope so :D
13:06:48 <n0nsense> I'm really new to haskell ^^
13:06:55 <n0nsense> you might scare me off :D
13:07:17 <SamB> though mine doesn't say that ...
13:07:28 <SamB> % ghc --version
13:07:28 <SamB> The Glorious Glasgow Haskell Compilation System, version 6.8.2
13:08:26 <n0nsense> SamB: which distro do you use?
13:08:33 <SamB> Debian
13:09:17 <Cale> cale@zaphod:~$ ghc --version
13:09:17 <Cale> The Glorious Glasgow Haskell Compilation System, version 6.10.1
13:09:32 <ray> The Glorious Glasgow Haskell Compilation System, version 6.6
13:09:34 <ray> :(
13:11:09 <n0nsense> SamB: I use arch...
13:11:26 <n0nsense> maybe they did compile something special :D
13:11:30 <n0nsense> either debian or arch
13:11:31 <n0nsense> dunno
13:12:41 <pumpkin> how hard would it be to write a foldMU over UArr?
13:13:32 <dons> you want inplace loops?
13:14:20 <dolio> foldMU f z = foldlU f (return z)
13:14:21 <pumpkin> I was trying to do a foldU f (newMU size) uarr
13:14:30 <pumpkin> dolio: it's that easy? :o
13:14:42 <dolio> I don't know what you want it to do exactly.
13:14:42 <pumpkin> *foldlU
13:14:54 <dolio> @src foldM
13:14:54 <lambdabot> foldM _ a []     = return a
13:14:54 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
13:15:00 <dolio> That's nothing special, as you can see.
13:15:12 <pumpkin> I want to use a MUArr as my foldlU state being passed around between iterations
13:15:19 <pumpkin> but MUArr must live in ST
13:15:43 <dolio> It's actually not as simple as what I wrote.
13:16:07 <dolio> foldlU (\mz e -> mz >>= \z -> f z e) (return z), probably.
13:19:31 <nolrai_East> what are the functions to convert to/from Enum to/from Int?
13:19:38 <pao> how would you say "I sounds polemic" in a more "idomatic" english? :-)
13:19:39 <pao> OT
13:19:40 <pumpkin> toEnum, fromEnum
13:19:44 <nolrai_East> :t foldlU
13:19:45 <lambdabot> Not in scope: `foldlU'
13:19:47 <pao> *it sounds
13:19:58 <nolrai_East> doh!
13:20:53 <athos> , src 'foldlU
13:21:00 <lunabot>  foldlU :: forall a b . UA a => (b -> a -> b) -> b -> (UArr a) -> b
13:21:19 <pumpkin> so yeah, I want b in that to be a MUArr
13:24:51 <nolrai_East> , src Bounded
13:24:53 <lunabot>  luna: Not in scope: data constructor `Bounded'
13:24:54 <pumpkin> am I just doing it wrong?
13:25:00 <pumpkin> (or trying to do it wrong)
13:25:10 <nolrai_East> @src Bounded Int
13:25:11 <lambdabot> Source not found. Are you on drugs?
13:25:26 <nolrai_East> @slap lambdabot
13:25:26 * lambdabot orders her trained monkeys to punch lambdabot
13:25:53 <harovali> what is Maybe ?
13:26:14 <pumpkin> harovali: something that allows a type to be itself or nothing
13:26:41 <harovali> pumpkin: hmmmmm
13:27:03 <MrStamp> what is the simplest xml parser for haskell for a noob?
13:27:04 <pumpkin> so it has two constructors, a Just x, or Nothing
13:27:23 <pumpkin> harovali: say you're searching a list for a value that matches some predicate
13:27:33 <byorgey> is sequence.complete.org working for anyone else?
13:27:41 <pumpkin> it would make sense to either return the value found, or Nothing if nothing was found
13:28:12 <pumpkin> byorgey: not loading for me
13:28:17 <athos> byorgey: not for me :(
13:28:22 <byorgey> ok, thanks
13:28:40 <byorgey> guess I can't put up the HWN yet, then =(
13:28:46 <pumpkin> HWN?
13:28:53 <byorgey> Haskell Weekly News
13:29:02 <byorgey> @seen CosmicRay
13:29:02 <athos> sad :(
13:29:02 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 1d 22h 32m 5s ago, and .
13:29:11 <byorgey> I'll still send it to the ML though
13:32:18 <pumpkin> @index foldM
13:32:18 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
13:32:30 <kmeyer> byorgey: what ml?
13:32:31 <n0nsense> /usr/bin/ghc --make -o hircules -Wall -package gtk2 -package network -ilib Main.hs
13:32:34 <n0nsense> ghc-6.8.2: unknown package: gtk2
13:32:36 <n0nsense> wtf
13:32:46 <byorgey> kmeyer: haskell@haskell.org, and haskell-cafe@haskell.org
13:32:48 <n0nsense> W_T_F?!
13:33:02 <pumpkin> n0nsense: cabal update maybe?
13:33:15 <n0nsense> pumpkin: ok thanks
13:33:19 <pumpkin> actually, not sur
13:33:22 <kmeyer> byorgey: which one should I subscribe to? :D
13:33:37 <n0nsense> pumpkin: no
13:33:42 <pumpkin> yeah
13:33:52 <dcoutts> n0nsense: does it really say package 'gtk2' ? there is no gtk2 package as far as I know
13:34:05 <n0nsense> dcoutts: it is gtk2hs
13:34:17 <n0nsense> the makefile tells something else
13:34:20 <dcoutts> n0nsense: there is no gtk2hs ghc package either, there's 'gtk'
13:34:29 <n0nsense> ah
13:34:52 <dcoutts> n0nsense: that form of error message from ghc means that a package that a compiled .hs file needs is not available, eg has been deleted
13:35:21 <dcoutts> n0nsense: when do you get it? during building gtk2hs or while building a program that uses gtk2hs ?
13:35:21 <byorgey> kmeyer: see http://haskell.org/haskellwiki/Mailing_lists
13:35:25 <EvilTerran> dcoutts, i'm looking at the mention of "-package gtk2" in the command-line
13:35:29 <byorgey> kmeyer: it depends what you want =)
13:35:40 <byorgey> kmeyer: haskell is low-traffic, for major announcements and such.
13:35:45 <n0nsense> lib/Threads.hs:26:7:
13:35:45 <n0nsense>     Could not find module `Gtk':
13:35:45 <n0nsense>       Use -v to see a list of the files searched for.
13:36:00 <byorgey> kmeyer: haskell-cafe is very high traffic, for discussion of all sorts of haskell-related things.
13:36:04 <n0nsense> dcoutts: building a program using gtk2hs
13:36:08 <dcoutts> EvilTerran: where is the "-package gtk2" coming from?
13:36:21 <kmeyer> byorgey: define "very high traffic"?
13:36:22 <EvilTerran> dcoutts, "<n0nsense> /usr/bin/ghc --make -o hircules -Wall -package gtk2 -package network -ilib Main.hs"
13:36:26 <byorgey> kmeyer: one of the functions of the Haskell Weekly News is to pick out interesting things from haskell-cafe for people who don't have time to read it =)
13:36:27 <kmeyer> 100+/day? 200+?
13:36:30 <dcoutts> EvilTerran: oh, user error, ok
13:36:47 <dcoutts> n0nsense: there is no Gtk module, you want to import Graphics.UI.Gtk, see some of the demos
13:36:55 <n0nsense> ok
13:36:55 <dons> sequence down for anyone? http://sequence.complete.org/hwn/20090110
13:36:58 <EvilTerran> dcoutts, should those -package flags even be necessary when using --make?
13:37:05 <dcoutts> n0nsense: did gtk2hs install ok? does ghc-pkg list gtk report it's installed?
13:37:13 <dcoutts> EvilTerran: no, they're not necessary
13:37:18 <kmeyer> dons: looks so
13:37:28 <n0nsense> dcoutts: it finally did
13:37:51 <byorgey> kmeyer: right now it looks to be around 40 messages per day
13:37:56 <n0nsense> [n0nsense@gurke ~]$ ghc-pkg list gtk
13:37:56 <n0nsense> /usr/lib/ghc-6.8.2/package.conf: gtk-0.9.13
13:37:57 <kmeyer> that's not too bad
13:38:01 <byorgey> I guess 'very high traffic' is a relative term =)
13:38:04 <kmeyer> yeah :)
13:38:06 <n0nsense> dcoutts: is that ok?
13:38:17 <dcoutts> n0nsense: yep, fine
13:38:20 <n0nsense> :)
13:38:40 <n0nsense> dcoutts: i needed to patch it, finally compiled
13:38:41 <nolrai_East> @pl mkHomePlanet player = liftM (homePlanet player) getRandom
13:38:42 <lambdabot> mkHomePlanet = flip fmap getRandom . homePlanet
13:38:50 <byorgey> kmeyer: there is also beginners@haskell.org
13:38:55 <byorgey> that page I linked has more info
13:39:08 <nolrai_East> :t flip fmap
13:39:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
13:39:44 <kmeyer> byorgey: reading it, thanks
13:39:52 <pumpkin> does anyone have any suggestions on how I'd do what I want (folding over UArr, using a MUArr for state)?
13:39:53 <kmeyer> (/me is a beginner, definitely)
13:40:07 <EvilTerran> ?index MUArr
13:40:07 <lambdabot> bzzt
13:40:11 <EvilTerran> ?hoogle MUArr
13:40:12 <lambdabot> Data.Array.Base unsafeAccumUArray :: (MArray (STUArray s) e (ST s), Ix i) => (e -> e' -> e) -> UArray i e -> [(Int, e')] -> ST s (UArray i e)
13:40:12 <n0nsense> kmeyer: /me too
13:41:47 <EvilTerran> pumpkin, where's the docs for these types?
13:41:59 <pumpkin> in http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/Data-Array-Vector.html
13:42:03 <byorgey> kmeyer: well, #haskell is a good place to be then =)
13:42:18 <pumpkin> EvilTerran: my issue is that MUArr updates need to be wrapped in ST
13:42:24 <byorgey> kmeyer: that page says something about having a 'choice' between beginners@ and haskell-cafe@, but you can certainly subscribe to both
13:42:26 <kmeyer> byorgey: learning by osmosis :D
13:42:32 <byorgey> yup =)
13:42:33 <kmeyer> I'm subscribing to all 3
13:42:40 <kmeyer> unless haskell@ is a duplicate of haskell-cafe@
13:42:42 <EvilTerran> pumpkin, you should be able to build an ST action in the accumulating parameter of the foldlU
13:43:14 <pumpkin> EvilTerran: I was trying that, but it wasn't working for me :/
13:43:39 <crutcher> is anyone working on making haddoc nicer? By this I mean both the generated HTML, and the docs for the libs in the standard dist?
13:43:55 <dons> crutcher: i  think nicer html would be welcome.
13:43:57 <crutcher> Cause they compare badly to, say, the python docs
13:44:05 <dons> if you've ideas, they'd be great contributions
13:44:06 <dcoutts> crutcher: waern is the haddock maintainer
13:44:07 <byorgey> kmeyer: sometimes it gets duplicate posts, but not always
13:44:07 <crutcher> lots of little cross-links just aren't their
13:44:09 <dons> just the format?
13:44:11 <crutcher> s/their/there/
13:44:19 <kmeyer> byorgey: ok, I'll just subscribe to all 3
13:44:25 <pumpkin> EvilTerran: the issue is that everything I try with, it says my ST's s is escaping
13:44:25 <byorgey> kmeyer: subscribing to all three sounds fine. (I'm subscribed to all three. =)
13:44:28 <kmeyer> I'm already on a few mailing lists with higher traffic than that
13:44:31 <EvilTerran> pumpkin, ... ah.
13:44:38 <dcoutts> crutcher: so talk to waern. I think he's mostly concerned with various bugs at the moment, so I'm sure he'd appreciate your help on making the html nicer.
13:44:40 <crutcher> dons: the format is a big part of it, there's no effective way to navigate 'up'
13:45:03 <dcoutts> crutcher: it would be nice if it used modern html too, rather than such an old standard
13:45:05 <waern> crutcher: feel free to add suggestions to http://trac.haskell.org/haddock
13:45:06 <lambdabot> waern: You have 1 new message. '/msg lambdabot @messages' to read it.
13:45:26 <harovali> In a Int -> Int -> Int          chain what  makes the last Int the type of the return value is that there is no -> after it ? and the return type of the previous Int be a function precisely because there S a -> after it ?
13:45:37 <EvilTerran> harovali, -> is right-associative
13:45:40 <kmeyer> currying
13:45:42 <EvilTerran> that's Int -> (Int -> Int)
13:45:58 <EvilTerran> each -> is "parameter type -> return type"
13:46:14 <crutcher> waern: okay. I'm at the point where I know I'm missing things, but I'm not sure what yet.
13:46:17 <harovali> aha, right.
13:46:39 <waern> crutcher: that's good enough to add as an "enhancement" ticket for a discussion start point
13:46:56 <harovali> -> is right associative, but left "applicative" so to say, right ?
13:47:09 <byorgey> harovali: function application is left associative.
13:47:15 <EvilTerran> pumpkin, i'm kinda stuck =/
13:47:20 <byorgey> is that what you mean?
13:47:26 <pumpkin> I can give you the approximate code I'm trying to get working
13:47:27 <harovali> byorgey: i see
13:47:39 <byorgey> so  "a b c" parses as  ((a b) c)
13:47:47 <pumpkin> I mostly want to know if the basic idea is somehow flawed, or if I'm just missing something to get it working
13:47:59 <harovali> byorgey: yes
13:48:17 <pumpkin> http://hpaste.org/13808 is what I'm trying
13:48:17 <byorgey> harovali: this fits nicely with -> being right associative.  For example, suppose a has type  Int -> Int -> Int, that is,  Int -> (Int -> Int)
13:48:23 * kmeyer is still confused w.r.t. monads and how they interact with pure functional code
13:48:39 <pumpkin> kmeyer: monads are pure functional code too
13:48:42 <harovali> byorgey: true, never have thought of it
13:48:44 <drdozer> mm, I  need an algorithm that calculates all paths between all nodes, where each path includes a node at much once
13:48:44 <byorgey> harovali: then   a b c  means  ((a b) c);  the  (a b) has type  Int -> Int, which is then applied to the c to produce an Int
13:49:00 <harovali> byorgey: brilliant
13:49:23 <kmeyer> pumpkin: well, sort of
13:49:27 <harovali> i hope I can learn haskell, I see a lot in it
13:53:19 <EvilTerran> pumpkin, i think it'd work with IORefs... =/
13:53:27 <pumpkin> onoes!
13:53:29 <byorgey> harovali: of course you can.
13:53:32 <pumpkin> I've never used an IORef before
13:53:52 <byorgey> harovali: are you reading a particular book or tutorial?
13:53:55 <EvilTerran> i'm trying to work out why the rank-2 type refuses to work
13:54:00 <n0nsense> dcoutts: dunno...
13:54:01 <EvilTerran> it should with type sigs in the right places
13:54:05 <n0nsense> it is really strange
13:55:57 <pumpkin> EvilTerran: this is all a bit over my head, but I thought I'd try to rewrite my sliding window entropy function using (M)UArrs as a challenge, and that code was the beginning of my attempt
13:57:09 <EvilTerran> ?type foldl :: forall a b. ((forall s. ST s b) -> a -> forall s. ST s b) -> (forall s. ST s b) -> [a] -> forall s. ST s b
13:57:11 <lambdabot> forall b a s. ((forall s1. ST s1 b) -> a -> forall s1. ST s1 b) -> (forall s1. ST s1 b) -> [a] -> ST s b
13:57:31 <pumpkin> scary type :P
13:58:05 <EvilTerran> you could neaten it up with "data AnyST a where AnyST :: ST s a -> AnyST a"... i think
13:58:47 <mmorrow> , runST (do mu <- newMU 1024; forM_ [0..1023] (\i -> writeMU mu i i); unsafeFreezeMU mu (lengthMU mu))
13:58:49 <lunabot>  toU [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
13:58:57 <mmorrow> wee
13:59:01 <pumpkin> hmm
13:59:05 <EvilTerran> pumpkin, i think you should be able to translate that into a valid type for foldlU, that, given explicitly, may let it typecheck
13:59:08 <pumpkin> mmorrow: there's an unsafeFreeAllMU
13:59:16 <EvilTerran> foldlU :: forall a b. UA a => ((forall s. ST s b) -> a -> forall s. ST s b) -> b -> UArr a -> forall s. ST s b
13:59:28 <pumpkin> mmorrow: now I just need that to fold over a UArr :P
13:59:40 <EvilTerran> , [$ty|()|]
13:59:40 <pumpkin> EvilTerran: hmm
13:59:43 <mmorrow> hmm
13:59:46 <lunabot>  ()
13:59:50 <roconnor> sequence is down again. :'(
13:59:54 <EvilTerran> , [$ty| foldlU :: forall a b. UA a => ((forall s. ST s b) -> a -> forall s. ST s b) -> b -> UArr a -> forall s. ST s b |]
13:59:58 <pumpkin> mmorrow: I guess I could just ask for indices of the UArr in that forM
13:59:59 <lunabot>  luna: Exception when trying to run compile-time code:
14:00:23 <byorgey> roconnor: do you know who runs it these days?
14:00:27 <EvilTerran> , [$ty| foldlU :: forall a b. UA a => ((forall s. ST s b) -> a -> forall s. ST s b) -> (forall s. ST s b) -> UArr a -> forall s. ST s b |]
14:00:32 <lunabot>  ()
14:00:36 <roconnor> nope
14:00:39 <byorgey> I don't know who to contact when it is down
14:00:43 <EvilTerran> er... that's not the right type
14:00:46 <byorgey> I don't think it is CosmicRay anymore
14:00:57 <EvilTerran> but it seems to accept it! :)
14:01:02 <pumpkin> lol
14:01:03 <mmorrow> pumpkin: i think a fold might be porrly suited for this, since folds have a window of 2, and you need more, and then also you've got a mutable array
14:01:33 <mmorrow> since you don't have to accumulate your state
14:01:39 <pumpkin> it's true :/
14:02:00 <sbahra> Hi pumpkin /\ mmorrow
14:02:06 <pumpkin> hi sbahra :)
14:02:10 <mmorrow> hiya
14:03:01 <pumpkin> mmorrow: what's a better way to iterate over the UArr, updating my MUArr at each iteration?
14:03:20 <pumpkin> I was scared of asking for successive indices in case it wasn't as efficient as a fold
14:03:27 <mmorrow> i'm thinking about it
14:03:32 <waern> crutcher: thanks a lot! :)
14:03:51 <crutcher> waern: serriously, or am I just whining?
14:04:00 <redditbot> Haskell on Windows
14:04:21 <waern> crutcher: seriously, I agree that we should steal lots of useful stuff from the python docs
14:04:33 <waern> I haven't looked at them before
14:04:56 <waern> I can't do it myself though, I'm swamped with bug fixing at the moment :)
14:05:13 <gwern> 'lo all
14:05:14 <lambdabot> gwern: You have 7 new messages. '/msg lambdabot @messages' to read them.
14:05:17 <crutcher> Cool. What I would really love is if we stole help() from python. I'm not sure how to do that. I'm pretty sure you'd need haddoc support in ghci
14:05:18 <gwern> any news?
14:05:46 <waern> crucher: ah, an in-language way to get the documentation?
14:05:59 <waern> (I've barely used python)
14:06:14 <crutcher> do you have python on your local machine?
14:06:27 <waern> yep
14:06:36 <sbahra> mmorrow, where is lunabot sourcecode? Is it easy to add commands?
14:06:54 <crutcher> run python on the cmd line, then type help(open)
14:07:04 <waern> crutcher: ok
14:07:09 <crutcher> or: import os; help(os)
14:07:16 <gwern> offhand, does anyone know how one gets a list of everything one has uploaded to hackage? the google site search doesn't seem to serve for this purpose
14:07:23 <MagicDuck> I wonder what the status of gpugen is
14:07:45 <waern> crutcher: ah, I see.
14:07:47 <mmorrow> sbahra: what kind of command? i'll add pretty much anything to it anyone writes
14:08:01 <mmorrow> (as long as it doesn't give unsafePerformIO)
14:08:05 <nolrai_East> @type replicateM
14:08:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:08:10 <sbahra> mmorrow, well, it will be for private use. But it will involve using Porte.Ports
14:08:28 <sbahra> mmorrow, for #haskell-FreeBSD. That way I can kick lambdabot out.
14:08:29 <waern> crutcher: currently it's hard to do that in ghci, but it could be done in a "super-ghci" based on both the GHC and Haddock API
14:08:34 <mmorrow> heh
14:08:46 <mmorrow> sbahra: well the evaluator etc code is at:
14:08:54 <gwern> sbahra: what do you have against lambdabot? :(
14:09:02 <mmorrow> http://moonpatio.com/repos/luna/
14:09:03 <pumpkin> aw
14:09:10 <waern> crutcher: the problem with doing it in ghci is that the docs are only stored in the .haddock files, not in .hi files
14:09:13 <crutcher> waern: it does that by inspecting the type, and grabbing the doc annotation. Python has a syntax for doc annotation (if a method or class starts with a string literal, that's the docs)
14:09:16 <sbahra> gwern, I love her. But sometimes I like to go back to skinny girls.
14:09:55 <crutcher> waern: yeah. But so long as those files are on the filesystem, or can be generated, you could slip it in
14:10:06 * gwern tries to parse that. lambdabot is to a chubby girl as lunabot is to skinny girls, and human fat is to... dependencies? ease of building? ...
14:10:13 <crutcher> for suitable values of 'you'
14:10:14 <crutcher> :)
14:10:24 <sbahra> ,src map
14:10:26 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
14:10:33 <sbahra> That was stupid.
14:10:39 <n0nsense_> re
14:10:40 <sbahra> mmorrow, but does it have anything for this?
14:10:49 <sbahra> mmorrow, src/hoogle/etc
14:11:18 <n0nsense_> dcoutts: er...
14:11:33 <mmorrow> sbahra: basically all the bot frontend does, is connect to irc, then scan every incoming msg for the eval char, and if found pipes a single line to the evaluator (which is a separate prog), then reads back a fixed-max number of lines.
14:11:45 <n0nsense_> I don't know the problem of hircules -.-'
14:11:54 <mmorrow> sbahra: it doesn't have hoogle, but i was actually thinking of hooking that up somehow
14:12:01 <mmorrow> it'd be way useful
14:12:02 <sbahra> I see
14:12:03 <pumpkin> n0nsense_?
14:12:15 <waern> crutcher, right... probably as a :doc command or something like that on the tool-level though. We could do it as a haskell function but then it would have to have an IO return type I figure
14:12:17 <n0nsense_> pumpkin: it does not build
14:12:25 <dcoutts> n0nsense: were you talking to me?
14:12:26 <crutcher> waern: I'll put that on my list of things to think about when/if I get up to the point that I know enough to kick ghci arround :)
14:12:32 <gwern> n0nsense_: well, the problems of hercules were 12 taskes he was set to atone for murdering his family...
14:13:14 <crutcher> waern: I just know that the REPL + help was crucial to my learning of python
14:13:16 <mmorrow> and lunabot is only using  _cpu-time_ and _mem-limit_ rlimits, and i believe that covers it
14:13:22 <waern> crutcher: great!
14:13:39 <n0nsense_> gwern: wtf
14:13:51 <pumpkin> lol
14:13:53 <n0nsense_> dcoutts: i think so
14:13:58 <n0nsense_> :D
14:14:15 * sbahra just bought applicative.org 
14:14:27 <gwern> mmorrow: srsly, those are your only protective measures in lunabot?
14:14:40 <n0nsense_> dcoutts: you answered my gtk-questions, isn't it?
14:15:10 <gwern> dcoutts: how would I get a list of all my uploads from hackage?
14:15:13 <dcoutts> n0nsense: yep, but I didn't see your other question, only "<n0nsense> dcoutts: dunno..." and "<n0nsense_> dcoutts: er..."
14:15:21 * gwern drats http://sequence.complete.org/hwn/20090110 load darn it
14:15:27 <n0nsense_> dcoutts: ;)
14:15:47 <mmorrow> , [$ty| let accumMU xs (a,b) k = let go 0 = return (); go n i = readMU mu n >>= k >> go (n-1) in go (b-a) in accumMU |]
14:15:53 <lunabot>  luna: Exception when trying to run compile-time code:
14:15:54 <mmorrow> gwern: yes
14:15:55 <n0nsense_> dcoutts: hircules wants to use gtk2... and I don't know where the problem is located
14:16:31 <gwern> mmorrow: sounds scary. surely it is sandboxed as well
14:16:51 <mmorrow> gwern: it's a hosted machine
14:17:04 <mmorrow> and it's not running as root
14:17:31 <mmorrow> assuming no one get unsafePerformIO, nothing can happen
14:17:41 <pumpkin> that's what you think!
14:17:44 * pumpkin haz epic exploit
14:17:54 <mmorrow> zomg
14:18:00 <pumpkin> ya
14:18:07 <pumpkin> be afraed!
14:18:10 <gwern> mmorrow: ah, so you have some sort of anti-unsafePerformIO protection in there as well
14:18:11 <mmorrow> WUT R UR CFLAGS!!?!
14:18:29 <pumpkin> lol
14:18:53 <gwern> -fomit-frame-pointer -O3 -fricer nachally
14:19:00 <mmorrow> gwern: yes, everything i import i go over and see if they expose unsafePerformIO-conjuring-ness.
14:19:25 <gwern> hm. what about the unsafeSTtoIO ones?
14:19:34 <mmorrow> , unsafeSTToIO
14:19:36 <lunabot>  luna: Not in scope: `unsafeSTToIO'
14:19:48 <mmorrow> , runIO
14:19:50 <lunabot>  luna: Not in scope: `runIO'
14:19:55 <dcoutts> n0nsense: if it really wants gtk2 rather than gtk then it is extremely old and is unlikely to work without some love and attention.
14:20:28 <harovali> byorgey: for now, I'm just reading the stuff in haskell.org
14:20:28 <mmorrow> , [$ty| readMU |]
14:20:35 <lunabot>  forall a b . UA b => (MUArr b a) -> Int -> ST a b
14:20:52 <harovali> byorgey: and some other places, randomly
14:21:03 <mmorrow> , [$ty| let accumMU xs (a,b) k = let go 0 = return (); go n = readMU mu n >>= k >> go (n-1) in go (b-a) in accumMU |]
14:21:08 <lunabot>  luna: Exception when trying to run compile-time code:
14:21:10 <mmorrow> grr
14:21:28 <mmorrow> , accumMU
14:21:30 <lunabot>  luna: Not in scope: `accumMU'
14:21:40 <mmorrow> ohh
14:21:45 <mmorrow> , [$ty| let accumMU xs (a,b) k = let go 0 = return (); go n = readMU xs n >>= k >> go (n-1) in go (b-a) in accumMU |]
14:21:50 <lunabot>  forall a b a . UA a => (MUArr a b) ->
14:21:50 <lunabot>                         ((Int, Int)) -> (a -> ST b a) -> ST b ()
14:22:09 <crutcher> I'd like to float a question. Has anyone played with out-of-process memoization?
14:23:00 <crutcher> Like, I'd like to hook a library up func up with a memo wrapper, but I'd like that wrapper to be silently chained to an external memo cache
14:23:27 <harovali> how does succintly haskell compare to ML ?
14:23:27 <crutcher> so that various computations can share expensive functions
14:23:41 <nolrai_East> @index replicateM
14:23:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:24:10 <pumpkin> mmorrow: did you get any ideas about my earlier UArr + MUArr issue?
14:24:20 <pumpkin> I'm really trying to do it rather imperatively :/
14:24:29 <gwern> harovali: pretty favorably; but there's not a huge difference. (default laziness may give haskell an edge)
14:28:14 <n0nsense_> /usr/bin/ghc --make -o hircules -Wall -package gtk2 -package network -ilib Main.hs
14:28:17 <n0nsense_> wtf
14:28:33 <gwern> hm, a new gitit. I wonder if it makes use of the new filepath DVCS abstraction layer
14:29:08 <mmorrow> , let accumMU xs (a,b) k = let go 0 = return (); go n = readMU xs n >>= k >> go (n-1) in go (b-a); upd ref k a = writeSTRef ref . flip k a =<< readSTRef ref in runST (do ref <- newSTRef 0; xs <- newMU 1024; forM_ [0..1023] (\i -> writeMU xs i i); accumMU xs (12,27) (upd ref (+)); result <- readSTRef ref; u <- unsafeFreezeMU xs (lengthMU xs); return (result, u))
14:29:10 <lunabot>  (120,toU [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,2...
14:29:13 <gwern> * filestore
14:29:48 <mmorrow> pumpkin: that uses an STRef to hold the accumulator during the accumMU function in there
14:30:04 <pumpkin> :o
14:30:08 <mmorrow> which takes a run of the array to accum over
14:31:16 <mmorrow> something like that seems like it might work ok
14:31:21 <pumpkin> wow :)
14:31:27 <pumpkin> I need to work it out :P
14:31:34 <pumpkin> (your code that is)
14:31:38 <gwern> (filestore, in case nobody's heard, is a new haskell package that offers a highlevel interface to darcs and git and putatively any DVCS anyone cares to write the code for)
14:37:05 <pumpkin> mmorrow: okay, I have no clue how that works lol
14:39:50 <mmorrow> pumpkin: i'll paste it cleaner
14:40:13 <pumpkin> mmorrow: I've cleaned it up a bit myself, but I guess I should read up on STRefs before bothering you :P
14:41:06 <gwern> @flush
14:42:23 <gwern> @quote zygohistomorphic
14:42:24 <lambdabot> No quotes match. Just what do you think you're doing Dave?
14:42:33 <gwern> hm.
14:42:44 <gwern> @quote EvilTerran
14:42:45 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
14:42:48 <gwern> @quote EvilTerran
14:42:49 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
14:43:01 <gwern> @remember EvilTerran [on category theory] the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
14:43:01 <oklopol> @quote zygohistomorphism
14:43:01 <lambdabot> I will never forget.
14:43:02 <lambdabot> No quotes match. Take a stress pill and think things over.
14:43:36 <gwern> @quote fromIntegral
14:43:36 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
14:43:58 <gwern> > floor (1.0/0.0)
14:44:00 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
14:44:08 <kmeyer> rofl
14:44:29 <gwern> the funny thing is in ghci it finishes
14:44:32 <kmeyer> yeah
14:44:45 <gwern> @quote pumpkin
14:44:45 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
14:44:55 <pumpkin> :o
14:44:58 <gwern> hm, wonder why the EvilTerran one wasn't in there
14:45:01 <gwern> @flush
14:47:47 <Saya> i installed the haskell llvm bindings with cabal (and llvm-dev) and when i compile with ghc --make a helloworld program the linker fails :'(  Do i  need to use special ghc arguments?
14:48:08 <pumpkin> @docs STRef
14:48:08 <lambdabot> STRef not available
14:48:12 <pumpkin> @hoogle STRef
14:48:12 <lambdabot> module Data.STRef
14:48:12 <lambdabot> Data.STRef data STRef s a
14:48:12 <lambdabot> Data.STRef.Lazy data STRef s a
14:48:26 <dcoutts> Saya: shouldn't need to, use hpaste to show what you did and what the result was
14:50:21 <Gracenotes> is there an analog for the data constructor "TmFalse of info" (OCaml) in Haskell? It's part of a code sample from TAPL
14:50:38 <Gracenotes> I'm not quite sure what 'info' means
14:50:56 <Saya> dcoutts: ok here ya go: http://hpaste.org/13810
14:51:29 <pumpkin> okay, I don't get STRefs either :P
14:51:35 <pumpkin> even after reading the docs
14:52:18 <Gracenotes> hm. I just won't include the info-whatever-it-is and see how it goes :X
14:52:30 <pumpkin> mmorrow: what's the (12,27) in your code?
14:52:41 <pumpkin> just an example I assume?
14:53:05 <Saya> Gracenotes: Its the info like the line number column number etc for the compiler output
14:53:12 <mmorrow> pumpkin: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=757#a757
14:53:28 <Saya> You dont actually need it its just for more readable/helpful error messages
14:53:34 <mmorrow> that was just a random range of indices i chose to accum over
14:53:37 <pumpkin> thanks mmorrow
14:53:40 <pumpkin> okay :)
14:53:42 <mmorrow> np :)
14:54:11 <Saya> wow hpaste2!
14:54:36 <Gracenotes> Saya: oh, I see. so there's probably not a Haskell counterpart. Thanks :)
14:54:45 <jberryman> > 10 / (2.2 - 2.1)
14:54:47 <lambdabot>   99.99999999999991
14:55:12 <jberryman> that's not quite right.
14:55:23 <pumpkin> > 10 / (2.2 - 2.1) :: CReal
14:55:24 <lambdabot>   100.0
14:55:31 <mmorrow> pumpkin: heh, my bash prompt snuck in there at the end
14:55:34 <Saya> Gracenotes: yes there is its whatever you decide to put there like it could be  data Info = {lineno :: Int, columnno :: Int} its whatever you decide to put there as a resul tof parsing
14:55:49 <pumpkin> mmorrow: I saw :P
14:55:59 <pumpkin> don't worry, wasn't trying to interpret it as haskell :P
14:56:13 <Gracenotes> ah. hm.
14:56:26 <jowens> hey, a couple of questions re: project euler #23
14:56:27 <jowens> http://hpaste.org/13811
14:56:48 <jowens> #1: This is taking forever to run. And I don't know why. 20k elements in a list does not seem like a deal-breaker.
14:56:58 <jowens> #2: Can't figure out how to compile it with more stack space
14:57:03 <pumpkin> jowens: you're doing 20k^2
14:57:12 <pumpkin> [a+b | a <- at, b <- at]
14:57:12 <jowens> ok, so i need to know why
14:57:26 <mmorrow> if it wasn't for the '$', it'd be valid as a pattern
14:57:27 <jowens> but it's much less than 20k after the filter is done
14:57:35 <mmorrow> oh no
14:57:37 <pumpkin> jowens: how much?
14:57:44 <jowens> hm lemme check
14:58:11 <pumpkin> jowens: also, there's a tighter bound than 28k  if you look on math sites
14:58:25 <jowens> sure, but i still need to learn how to deal with a big problem like this.
14:58:43 <jowens> length is a legitimate function?
14:58:51 <pumpkin> sure
14:59:12 <nolrai_East> What would the best way to test if a map contains any duplicate items (i.e. there are two keys that give the same value)?
14:59:14 <Saya> Anybody knows why llvm wont link :(? http://hpaste.org/13810 im on ubuntu intrepid with llvm-dev package and the llvm haskell bindings cabal installed (with ghc6.10)
14:59:23 <harovali> given
14:59:24 <harovali> take 10 fibs where fibs = 0:1:zipWith (+) fibs (tail fibs)
14:59:24 <harovali> , why if I put product before that hugs doesn't understand I want the product of the 10 first fibos ?
14:59:25 <lunabot>  luna: parse error on input `if'
14:59:26 <kmeyer> nolrai_East: maps aren't supposed to
14:59:37 <jowens> 6965
14:59:40 <jowens> so that is still too big
14:59:57 <jowens> ok, need to find an algorithm that doesn't take 6965^2, i can see where that would be bad.
15:00:02 <pumpkin> :)
15:00:08 <dcoutts> Saya: looks like it's not linking to the llvm libs
15:00:13 <dublpaws> I'm updating someones code who uses Data.FunctorM, is there a drop in replacement for that - I see that it's depracated.
15:00:35 <Saya> maybe the ubuntu llvm libs arent recent enough
15:00:55 <conal> harovali: perhaps missing parens or an other syntactic oops.
15:01:07 <tdanecker> , product $ take 10 fibs where fibs = 0:1:zipWith (+) fibs (tail fibs)
15:01:07 <pumpkin> mmorrow: so an STRef is just basically a mutable variable living in an ST?
15:01:08 <lunabot>  luna: parse error on input `where'
15:01:20 <dcoutts> Saya: what does "ghc-pkg field llvm extra-libraries" report ?
15:01:31 <harovali> conal: if I type
15:01:32 <harovali> product (take 10 fibs where fibs = 0:1:zipWith (+) fibs (tail fibs))
15:01:32 <harovali> it doesn't understand either. What else might be failing ?
15:01:33 <tdanecker> , product (take 10 fibs where fibs = 0:1:zipWith (+) fibs (tail fibs))
15:01:34 <lunabot>  luna: parse error on input `where'
15:01:37 <mmorrow> pumpkin: err, i should mention since i don't think is exactly obvious, is that accumMU runs over the interval *starting from the end* and finishing at the beginning
15:01:49 <ddarius> 'where' isn't an expression form
15:01:50 <mmorrow> pumpkin: yes, exactly
15:01:51 <conal> harovali: "where" is part of declaration syntax, not expression syntax.
15:01:53 <Saya> dcoutts: extra-libraries: LLVMAnalysis LLVMBitWriter LLVMBitReader LLVMCore
15:01:54 <harovali> tdanecker: what's the leading comma ?
15:01:55 <Saya>                  LLVMTarget LLVMSupport LLVMSystem
15:01:58 <mmorrow> (re: STRef)
15:02:00 <pumpkin> I notied that :)
15:02:03 <pumpkin> ok
15:02:05 <pumpkin> hmm
15:02:08 <conal> harovali: try "let" instead.
15:02:13 <dcoutts> Saya: hmm, you'll have to ask bos
15:02:17 <tdanecker> harovali: it tells the bot to evaluate it ;)
15:02:20 <pumpkin> bos is the boss
15:02:20 <harovali> conal great
15:02:26 <Saya> :(
15:02:28 <harovali> tdanecker: :-) I now got it
15:02:41 <conal> harovali: sry about that.  the original (iswim) notation did allow what you said.
15:02:54 * dublpaws finds replacement
15:03:14 <pumpkin> mmorrow: any reason you're using readSTRef and writeSTRef rather than modifySTRef ?
15:03:15 <augustss> Saya: that should work, I'd think
15:03:29 <harovali> conal: so, how else can I se how that'd work?
15:03:37 <mmorrow> pumpkin: no, and that's a great point :)
15:03:45 <pumpkin> mmorrow: the only advantage is that it's atomic, right?
15:03:55 <pumpkin> the modify one
15:03:59 <mmorrow> erm, i'm not sure actually
15:04:11 <conal> harovali: i don't understand your question.  do you mean how can you try the "let" form?
15:04:13 <ddarius> ST is sequential.  Atomicity is not an issue.
15:04:16 <mmorrow> i know there's atomicModifyIORef, but i'm not sure if there's an equiv ST one
15:04:18 <pumpkin> ddarius: ah
15:04:22 <augustss> Saya: you could try 'nm -o whereLLVMlives/*.a | grep LLVMCreatePassManager' to see where it is defined
15:04:31 <tdanecker> , let fibs = 0:1:zipWith (+) fibs (tail fibs) in product $ take 10 fibs
15:04:31 <harovali> conal: well, I tried it too, with no luck
15:04:33 <Saya> ok
15:04:33 <lunabot>  0
15:04:48 <harovali> tdanecker:  aha.
15:04:48 <jowens> pumpkin: it would still seem to me that i would need to calculate each of those n^2 sums
15:04:55 <jowens> any one of them could be significant.
15:05:08 <jowens> don't have to keep them all around at once, but i do have to compute them all.
15:05:09 <kmeyer> tdanecker: need to start with 1:1
15:05:13 <jowens> tell me why i'm wrong :)
15:05:17 <pumpkin> @type let a += b = modifySTRef ((+) b) in flip (+=) 1
15:05:18 <lambdabot>     Couldn't match expected type `STRef s a'
15:05:18 <lambdabot>            against inferred type `a1 -> a1'
15:05:18 <lambdabot>     In the first argument of `modifySTRef', namely `((+) b)'
15:05:49 <Saya> augustss: its theree in /usr/lib/llvm/lib
15:06:03 <augustss> Saya: in what file?
15:06:17 <pumpkin> wow, I could really define += in haskell? imperative cat is happy
15:06:52 <Saya> oh no the LLVM libs are there but LLVMCreatePassManager isnt
15:07:08 <augustss> Saya: do you have LLVM 2.4?
15:07:21 <mmorrow> pumpkin: this is a good one too   (.=) = writeSTRef
15:07:23 <augustss> pumpkin: yes, you can define += :)
15:07:26 <Saya> that must be the problem i have the one shipped with ubuntu lemme check
15:07:28 <pumpkin> wow
15:07:36 <pumpkin> I could really be disgustingly imperative if I wanted to be
15:07:52 <Saya> augustss: 2.2 i need 2.4 i guess
15:07:58 <augustss> pumpkin: you should look at my quicksort blog post :)
15:08:06 <pumpkin> augustss: linky? :)
15:08:07 <kmeyer> augustss: link?
15:08:19 <augustss> Saya: yes, you need 2.4
15:09:01 <augustss> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
15:09:35 <pumpkin> augustss: wow!
15:10:08 <augustss> pumpkin: the most disgusting hack is a[i] for indexing :)
15:10:17 <pumpkin> I was going to ask how you did that :P
15:10:31 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
15:10:35 <augustss> The cool hack is l-values vs. r-values
15:11:36 <harovali> is there some sort of reader-macro mechanism in the hugs read-eval-print loop?
15:11:57 <augustss> harovali: not that i know
15:11:58 <pumpkin> wow :)
15:12:13 <Saya> augustss: do i need to build from source? i only see ming32 binaries
15:12:22 <harovali> augustss: thanks
15:12:40 <augustss> Saya: there are some Linux binaries, but I don't know which
15:12:49 <nolrai_East> @index lift
15:12:50 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
15:12:50 <lambdabot> ParserCombinators.ReadPrec, Text.Read
15:14:07 <pumpkin> augustss: I like the comments on that post :P
15:16:25 <augustss> pumpkin: Some people appreciate more than others.  I find the code rather disgusting, but I like sick things like that.
15:16:39 <pumpkin> yeah, I wouldn't want to write code like that, but it's amazing that it's possible
15:16:45 <pumpkin> no offence to your code :P
15:17:53 <augustss> pumpkin: I'll never be offended by comments to that code.  It's like my Obfustacted C Code Contest code.  It's meant to be offensive.
15:17:59 <pumpkin> :)
15:19:07 <jeffwheeler> @help index
15:19:08 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
15:19:14 <Saya> wow you made c in haskell :)
15:19:23 <augustss> pumpkin: Haskell is supposed to be the best imperative language after all. :)
15:19:28 <jeffwheeler> I still like writing Haskell in Python.
15:19:29 <pumpkin> hah
15:20:24 <Saya> im happy that llvm helps me fight the gaz crisis i get compilator powered heat instead
15:21:14 <amaron> Saya: where are you from?
15:21:57 <Saya> france we dont actually have gaz shortage here :p
15:22:13 <baaba> it's spelled gas
15:22:28 <mmorrow> that c-ummm-haskell is great
15:22:29 <amaron> heh :), cpu doesn't help here
15:22:31 <Saya> well its gaz in french!
15:22:48 * mmorrow has an idea for goto
15:23:43 <jowens> trying to compile with a larger stack size, i get ghc error: not built for: -prof
15:23:47 <jowens> clues?
15:24:38 <pumpkin> mmorrow: so the difference with your code is that you're updating your STRef by iterating over your MUArr, whereas I want to update my MUArr by iterating over my UArr :P
15:24:54 <pumpkin> this code has taught my a lot
15:24:59 <mmorrow> oh, ok. that should be easy enough
15:25:36 <mmorrow> you could swap the updRef function for an updMU, and the accumMU for an accumU
15:25:48 <mmorrow> err, whatever you'd call it
15:25:56 <pumpkin> I'll try playing around with it :)
15:25:58 <pumpkin> thanks
15:26:12 <jowens> classico 9595$ GHCRTS=-K32M !ghc
15:26:12 <jowens> GHCRTS=-K32M ghc -o 23 23.hs +RTS
15:26:12 <jowens> not built for: -prof
15:26:27 <augustss> mmorrow: you need a continuation monad for goto
15:27:27 <mmorrow> augustss: i was thinking of using an STRef (a -> ST (STRef (a -> ... ))) or something
15:27:58 <augustss> mmorrow: how is that going help you jump?
15:28:08 <mmorrow> i have some code, just gotta find it...
15:32:13 <jowens> in fact, RTS options don't seem to do anything
15:32:14 <jowens> classico 9599$ ghc -o 23 23.hs +RTS -K128M -RTS
15:32:14 <jowens> classico 9599$ ./23
15:32:14 <jowens> Stack space overflow: current size 8388608 bytes.
15:32:15 <jowens> Use `+RTS -Ksize' to increase it.
15:34:04 <pumpkin> jowens: probably something wrong if you're exceeding stack space in the first place
15:34:16 <pumpkin> try being stricter
15:34:22 * pumpkin hands jowens The Whip
15:34:38 <augustss> jowens: try -O2
15:34:40 <jowens> well, yeah, i'll work on the algorithm, but it's kind of annoying that the compiler options that are supposed to work don't in fact do anything
15:35:02 <pumpkin> jowens: the +RTS flags are to your program
15:35:06 <ddarius> jowens: You are passing the runtime options to -GHC-
15:35:21 <ddarius> You want to pass them to -your program-
15:35:23 <pumpkin> jowens: ghc is compiled in ghc too, so the RTS flags work on it :)
15:35:32 <augustss> jowens: ./23 +RTS -K128M
15:35:37 <jowens> ahhhhh
15:35:37 <mmorrow> augustss: err, my code won't work as-is, but i'm thinking to try to do it with something like  (Map label (STRef s (ST s a)))
15:35:38 <jowens> that'll go
15:35:40 <jowens> thanks
15:36:00 <jowens> thanks augustss
15:36:01 <mmorrow> then (join . lookup) to jump
15:36:14 <mmorrow> err, lookup + readRef..
15:36:50 <augustss> mmorrow: I've had too much wine to know if that can possibly work. :)
15:36:54 <pumpkin> lol
15:36:58 <mmorrow> hah
15:37:13 <pumpkin> my swedish friend told me that drinking is the only thing to do in sweden
15:37:21 <mmorrow> heh
15:37:32 <augustss> pumpkin: not true.  we also have haskell
15:37:35 <pumpkin> lol ok :)
15:38:17 <harovali> if I start reading about hugs, is then an easy transition that of learning ghc ?
15:38:43 <pumpkin> why use hugs at all?
15:38:54 <augustss> your programs with still run.  ghc just have more extensions
15:39:03 <harovali> pumpkin: I found a step by step tutorial on it
15:39:14 <Saya> augustss: i finished compiling llvm, did the install but now its missing LLVMX68.o -.- even though i have stuff like LLVMSparc.o and LLVMMSIL.o ...
15:39:38 <augustss> harovali: don't worry, hugs is not a wasted effort
15:39:41 <Saya> i do have LLVMX86AsmPrinter.o and LLVMX86CodeGen.o though
15:39:48 <harovali> augustss: thanks
15:40:20 <augustss> Saya: hmmm, I'm not sure why it's missing
15:41:51 <harovali> what is $ for ?
15:42:13 <ski_> application
15:42:20 <ski_> > sin $ pi
15:42:21 <pumpkin> harovali: avoiding parentheses :P
15:42:21 <lambdabot>   1.2246467991473532e-16
15:42:29 <harovali> aha
15:42:40 <ski_> > (($) $ sin) $ pi
15:42:41 <lambdabot>   1.2246467991473532e-16
15:42:49 <pumpkin> lol
15:43:09 <augustss> > sin $ 1+1
15:43:11 <lambdabot>   0.9092974268256817
15:43:16 <augustss> > sin (1+1)
15:43:18 <lambdabot>   0.9092974268256817
15:43:24 <pumpkin> > sin 1 + 1
15:43:26 <lambdabot>   1.8414709848078965
15:43:38 <harovali> i see
15:43:50 <koeien> > sum [1/n^2 | n <- [1..100]] - pi^2/6
15:43:52 <lambdabot>   -9.950166663334148e-3
15:43:57 <pumpkin> so without the $ or parentheses it's interpreted as (sin 1) + 1
15:44:33 <jeffwheeler> It's called 'function application', as far as I know.
15:44:42 <jeffwheeler> Or, the 'function application operator'.
15:44:47 <jeffwheeler> I suppose space is one, too. ;)
15:44:50 <koeien> @src ($)
15:44:51 <lambdabot> f $ x = f x
15:44:52 <harovali> a precedence modifier, say
15:44:54 <koeien> see, very easy
15:44:56 <ski_> @src ($!)
15:44:57 <lambdabot> f $! x = x `seq` f x
15:45:23 <pumpkin> harovali: yeah, but just implemented easily using standard language constructs :)
15:45:33 <harovali> pumpkin: i like it
15:45:34 <pumpkin> it just has a precedence of 0
15:46:13 <koeien> > (+1) $ (+2) $ 3
15:46:15 <lambdabot>   6
15:46:45 <koeien> you can "chain" the $'s as well
15:47:05 <ski_> arguably, `$' should associate the other way, though
15:47:16 <pumpkin> people typically keep one $ near the end of their expression
15:47:17 <ski_> or at least it would be handy if `$!' did
15:47:21 <pumpkin> and use (.) for the rest
15:47:25 <koeien> since you could use (.)?
15:47:27 <pumpkin> when possible
15:47:36 <ski_> @src foldl'
15:47:37 <lambdabot> foldl' f a []     = a
15:47:37 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:47:51 <ski_> consider if we instead had
15:48:09 <ski_>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
15:48:25 <ski_> but currently one'd have to write
15:48:32 <koeien> but then your associativity is "right" again
15:48:32 <ski_>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
15:49:15 <ski_> `$' and `$!' is currently right-associative, yes
15:51:59 <pao> iterateeS definitely rock
15:52:12 <ski_> ?
15:52:29 <ski_> @hoogle iterateeS
15:52:30 <lambdabot> No results found
15:52:59 <ski_> @type \f x -> join (f `ap` x)
15:53:00 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> m a -> m a1
15:53:06 <ski_> @type \f x -> join (liftM (x >>=) f)
15:53:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> m a -> m b
15:53:26 <ski_> @type \f x -> f `ap` x
15:53:26 <pao> ski_: http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf
15:53:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:53:30 <ski_> @type \f x -> liftM (x >>=) f
15:53:32 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (a -> m b) -> m a -> m1 (m b)
15:57:50 <ski_> > (\f x -> join (f `ap` x)) [sqrtL,sbaL] [4,-4,0]
15:57:51 <lambdabot>   [2.0,-2.0,0.0,4.0,-4.0,0.0]
15:58:10 <ski_> > (\f x -> join (liftM (x >>=) f)) [sqrtL,sbaL] [4,-4,0]
15:58:12 <lambdabot>   [2.0,-2.0,0.0,4.0,-4.0,0.0]
15:59:04 <ski_> (pao : ty)
16:00:22 <augustss> :t sbaL
16:00:23 <lambdabot> forall a. (Num a, Ord a) => a -> [a]
16:00:37 <augustss> > sbaL 55
16:00:38 <lambdabot>   [55,-55]
16:03:56 <ski_> @check \x -> all (x ==) [abs y | y <- sbaL x]
16:03:57 <lambdabot>   Not in scope: `sbaL'
16:04:03 <ski_> @check \x -> all (x ==) [abs y | y <- L.sbaL x]
16:04:04 <lambdabot>       Failed to load interface for `L':
16:04:04 <lambdabot>        Use -v to see a list of the fi...
16:04:10 * ski_ sighs
16:06:27 <ski_> (if anyone wonders .. the object of the previous tests was to attempt falsifying `join (f `ap` x) = join (liftM (x >>=) f)')
16:08:38 <crutcher> has anyone done a parallel/threaded version of mapM/forM?
16:09:09 <crutcher> I'd like something lighter weight than forkIO, but still in the IO monad.
16:09:45 <crutcher> seems like there would already be a nice answer to this.
16:10:07 <Saizan> ?hoogle mergeIO
16:10:07 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
16:10:07 <lambdabot> Control.Concurrent nmergeIO :: [[a]] -> IO [a]
16:10:17 <Saizan> ah, no
16:12:43 <BMeph> crutcher: Rool your own, and put it on Hackage. :)
16:12:48 <Saizan> ?type \f xs -> do c <- newChan; mapM (\a -> do forkIO (f a >>= writeChan c)) xs; return c
16:12:49 <lambdabot> Not in scope: `newChan'
16:12:49 <lambdabot> Not in scope: `forkIO'
16:12:49 <lambdabot> Not in scope: `writeChan'
16:14:15 <Saizan> something like that, though it's hard to tell when you you've fetched all the elements from the Chan, so maybe something else on top of MVars is more appropriate
16:15:31 <crutcher> Saizan: if there were one chan per forkIO, so each MVar gets written only once (isn't there a type that can only get one val anyway?)
16:17:19 <Saizan> yeah mean each round could write in its own MVar? that's also possible
16:17:54 <Saizan> ?type newMVar
16:17:55 <lambdabot> Not in scope: `newMVar'
16:18:02 <Saizan> ?hoogle newMVar
16:18:03 <lambdabot> Control.Concurrent.MVar newMVar :: a -> IO (MVar a)
16:18:54 <Saizan> \f xs -> do ms <- mapM (\a -> do m <- newMVar undefined; forkIO (f a >>= putMVar); return m) xs; mapM takeMVar ms
16:19:13 <ClaudiusMaximus> @hoogle newEmptyMVar
16:19:13 <lambdabot> Control.Concurrent.MVar newEmptyMVar :: IO (MVar a)
16:19:27 <Saizan> ClaudiusMaximus: thanks
16:20:12 <crutcher> neat. Let's see if it works ...
16:27:19 <crutcher> *Main> forParIO ["abc", "def", "jkl"] putStrLn
16:27:19 <crutcher> abdjcek
16:27:20 <crutcher> fl
16:27:20 <crutcher> [(),(),()]
16:27:28 <crutcher> yay!
16:28:18 <ski_> forParIO_
16:28:31 <crutcher> What's a good name? forParIO is nasty
16:29:04 <crutcher> ski_: that one doesn't drop the return list, though I should do one that does
16:29:13 <pumpkin> parMapIO?
16:29:34 <crutcher> parMapIO, parMapIO_, parForIO, parForIO_ sounds good
16:29:35 <pumpkin> looks like a map
16:29:39 <ski_> does it give the results in the same order as the actions ?
16:29:56 <crutcher> pumpkin: modeled on forM and mapM, you'd want to provide both
16:30:00 <pumpkin> crutcher: it returns the list of them? in that case I don't think it should be an underscored one
16:30:00 <Saizan> my last version does
16:30:15 <pumpkin> oh
16:30:19 <pumpkin> you have multiple versions of it
16:30:29 <crutcher> Saizan: btw, your version has a bug arround putMVar, you left off the 'm'
16:30:48 <crutcher> pumpkin: well, I will in about 10 minutes.
16:31:08 <pumpkin> crutcher: why not reverse the order of arguments to make it more like a map?
16:31:13 <Saizan> crutcher: the problem of writing code without a type-checker :)
16:31:18 <EvilTerran> pumpkin, that's what the parMapIO version'd be
16:31:26 <EvilTerran> ?type mapM
16:31:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:31:28 <EvilTerran> ?type forM
16:31:28 <Saizan> ?type forM
16:31:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
16:31:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
16:31:35 <EvilTerran> ?src forM
16:31:35 <lambdabot> forM = flip mapM
16:31:54 <pumpkin> oh I see
16:38:32 <crutcher> This is what I've got so far: http://hpaste.org/13812
16:39:01 <crutcher> oh blegh, I left the MVar in the _ version
16:39:16 <pumpkin> anyone in here ever played with oz?
16:39:20 <pumpkin> (the programming language)
16:39:20 <koeien> associated types are easier for me than fundeps!
16:39:35 <koeien> till now, at least =)
16:40:25 <Saizan> crutcher: do you want parForIO_ to wait for the threads to end?
16:40:42 <crutcher> that's an interesting question
16:40:53 <pumpkin> I'd like to get "unbound variables" in haskell
16:40:55 <ski_> (pumpkin : yes)
16:41:06 <crutcher> probably worth having two versions, one that does, and one that doesn't.
16:41:15 <pumpkin> ski_: is there something similar to oz's unbound variables in haskell already?
16:41:17 <crutcher> as is, I'll have to re-work it
16:41:25 <ski_> pumpkin : no
16:42:34 <Saizan> unbound variables?
16:42:46 <ddarius> pumpkin: You could easily make them, but they wouldn't be anywhere near as transparent as Oz's.
16:42:52 <ddarius> Which would largely defeat the point.
16:42:54 <pumpkin> yeah :/
16:42:54 <ski_> Saizan : `uninstantiated variables' is a better term
16:43:09 <ddarius> Saizan: Single assignment data flow variables.
16:43:14 <Saizan> ah, i see
16:43:44 <Saizan> like language support for IVar
16:43:56 <pumpkin> IVar?
16:44:13 <pumpkin> ah I see
16:44:50 <Saizan> not sure where that's defined
16:44:59 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-ivar
16:45:01 <pumpkin> ?
16:47:02 <Gracenotes> @hoogle (Maybe a -> Maybe a) -> a -> a
16:47:03 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
16:47:10 <crutcher> Saizan: I think if I'm going to wait on the threads, I might as well go ahead and allocate the MVars, and then just ignore the result list (after it gets evaluated).
16:47:20 <crutcher> So, parForIO_ xs f = do { parForIO xs f; return () }
16:47:24 <Gracenotes> hm. easy enough to write one myself, I suppose
16:47:24 <chessguy> @pl m' f xs = m (p f) xs
16:47:24 <lambdabot> m' = m . p
16:47:32 <chessguy> @type map . pure
16:47:33 <lambdabot> forall a b. b -> [a] -> [b]
16:47:34 <ddarius> @djinn f :: (Maybe a -> Maybe a) -> a -> a
16:47:35 <lambdabot> Cannot parse command
16:47:35 <Saizan> pumpkin: in the one i meant "read" were pure, conal uses them in reactive i think
16:47:45 <ddarius> @djinn (Maybe a -> Maybe a) -> a -> a
16:47:45 <lambdabot> f a b =
16:47:45 <lambdabot>     case a Nothing of
16:47:45 <lambdabot>     Nothing -> b
16:47:45 <lambdabot>     Just c -> c
16:48:00 <Saizan> crutcher: yeah
16:48:08 <Gracenotes> ah. actually, this would probably match my function better...
16:48:11 <ddarius> Probably want the other one
16:48:12 <Gracenotes> @djinn (a -> Maybe a) -> a -> a
16:48:12 <lambdabot> f a b =
16:48:12 <lambdabot>     case a b of
16:48:12 <lambdabot>     Nothing -> b
16:48:12 <lambdabot>     Just c -> c
16:48:41 <Saizan> crutcher: you could only optimize that by changing the last mapM in parForIO to mapM_
16:48:42 <ddarius> :t fromMaybe
16:48:43 <lambdabot> forall a. a -> Maybe a -> a
16:48:48 <Gracenotes> hm. Maybe I shouldn't be using Maybe for this :)
16:48:50 <ddarius> :t (fromMaybe .)
16:48:51 <lambdabot> forall b a. (a -> b) -> a -> Maybe b -> b
16:49:06 <ddarius> :t (flip fromMaybe .)
16:49:07 <lambdabot> forall a a1. (a1 -> Maybe a) -> a1 -> a -> a
16:49:14 <Axman6> @hoogle ([a],[b]) -> [(a,b)]
16:49:14 <lambdabot> No results found
16:49:28 <ziman> :t uncurry zip
16:49:29 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
16:49:43 <Axman6> cheers
16:50:08 <Gracenotes> I'm trying to translate an OCaml function that involves a NoRuleApplies error
16:50:28 <ddarius> Gracenotes: Maybe seems reasonably for that.
16:50:31 <crutcher> Saizan: yeah, that's worth doing I guess.
16:50:42 <ddarius> Or Either/Error if you want to propagate the error out further.
16:50:48 <Gracenotes> ddarius: yes. It's becoming convoluted, though, because it's allowed to raise an exception and later pattern match against it
16:51:17 <ddarius> Gracenotes: Are you using Maybe monadically?
16:51:54 <Gracenotes> I haven't written the function that evaluates it yet. Unfortunately it's a bit of an odd case -- an eval function that simplifies an expression until it can't be simplified any further
16:52:31 <Gracenotes> maybe even simple recursion would do the trick
16:52:43 <ziman> you might get into a loop that way
16:53:00 <ziman> that's what's always happening to me ;)
16:53:12 <ddarius> ziman: Program in a language without recursion or loops then.
16:53:24 <Gracenotes> it is a single-step evaluator, after all
16:53:33 <crutcher> Saizan: okay, I've got a new version: http://hpaste.org/13812#a1
16:54:02 <TuringTest> Hooray for quickcheck, again.
16:54:13 <TuringTest> OS X has a very buggy regex library.
16:54:33 <Gracenotes> hm. Let me see if I can write it without any error-esque constructs by changing the logic of the program
16:54:41 <Saizan> crutcher: that looks fine
16:54:43 <TuringTest> Could someone else (on linux) run echo "abb" | sed -nr 's/(()|.)(b)/[\1][\3]/p' and tell me the result?
16:55:05 <Heffalump> [a][b]b
16:55:10 <TuringTest> And then compare with echo "abb" | sed -nr 's/(.|())(b)/[\1][\3]/p'
16:55:26 <Heffalump> [a][b]b
16:55:32 <TuringTest> Heffalump: That is the correct result, but OS X prints a[][b]
16:55:34 <oshyshko> how do I make ghci print unicode string w/o backslashes? E.g.: putStrLn "\208" -- should print value w/o backslash?
16:55:50 <TuringTest> Heffalump: That is also the correct result, and OS X gets it right.
16:56:17 <ski_> @type let foo f x = f x >>= foo f in foo  -- might be useful for iterated simplification
16:56:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> a -> m b
16:56:21 <kryptiskt> oh no! ghci crashes in Windows 7. works from the command line though.
16:56:36 <Olathe> oshyshko: It does that without backslash here.
16:56:55 <TuringTest> A basic, bedrock, property of the extended regular expression is that the order of branches should never change the matching text (though it can change which parts are in which subexpression captured).
16:56:55 <_dolio> oshyshko: Snagging the utf8-string package off of hackage should do it.
16:56:58 <TuringTest> And OS X is getting this wrong.
16:58:22 <pumpkin> moo
16:58:33 <pumpkin> OS X does regular expressions?
16:59:05 <pumpkin> do they have a syscall for them?
16:59:21 <Olathe> No, they have a lot of standard unix tools, though.
16:59:38 <Olathe> I think he's saying sed is buggy on OS X.
16:59:42 <pumpkin> yeah, I know :)
16:59:44 <pumpkin> just being silly
16:59:49 <oshyshko> Olathe: indeed... Guess, my problem is about "show" function. Is it possible to make "show" return strings w/o backslashes?
16:59:58 <Olathe> oshyshko: Not really.
17:00:05 <pumpkin> oshyshko: filter them out?
17:00:09 <Olathe> oshyshko: If you have a String, you don't need show, really.
17:02:00 <oshyshko> Olathe: I have a [[String]] full of Unicode chars, and I need ghci to print it ASIS, so I can read them from screen.
17:03:05 <Gracenotes> eval' (TmIf t1 t2 t3) = eval' t1 >>= \t1' -> Just (TmIf t1' t2 t3)
17:03:12 <Gracenotes> ...seems a bit clunky.
17:03:23 <Olathe> oshyshko: putStrLn.(++"]").('[':).intersperse "," $ xs
17:03:55 <Gracenotes> hm.
17:04:26 <TuringTest> pumpkin and Olathe: OS X has a regexp c library that is used by grep, sed, and Haskell's regex-posix
17:04:34 <Olathe> Ahh.
17:04:38 <Olathe> oshyshko: putStrLn.(++"]").('[':).concat.intersperse "," $ xs
17:04:56 <ski_> @src intercalate
17:04:57 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
17:05:04 <Olathe> Ahh.
17:05:06 <pumpkin> TuringTest: what library is that?
17:05:12 <Olathe> oshyshko: putStrLn.(++"]").('[':).intercalate "," $ xs
17:05:29 <Olathe> Thanks :)
17:05:42 <TuringTest> regex-posix provides the backend for regex-compat which provides Text.Regex
17:05:44 <Olathe> So, let disp = putStrLn.(++"]").('[':).intercalate ","
17:06:00 * ski_ thinks `('[':).(++"]")' reads nicer
17:06:22 <pumpkin> TuringTest: you mean regexec and friends?
17:06:22 <roconnor> ("["++).(++"]")  ?
17:06:27 <TuringTest> I also have written a pure Haskell library called regex-tdfa which I am trying to test
17:06:28 <ski_> or that, yes
17:06:38 <ddarius> Gracenotes: eval' (TmIf t1 t2 t3) = liftM (\t1' -> TmIf t1' t2 t3) (eval t1)
17:06:39 <Olathe> Hmm, I think that would be nicer.
17:06:48 <TuringTest> pumpkin: exactly #include <regex.h>
17:06:51 <Olathe> So, let disp = putStrLn.('[':).(++"]").intercalate ","
17:07:06 <TuringTest> pumpkin: and OS X is broke.
17:07:16 <pumpkin> TuringTest: aha, it says in the man page "This is an alpha release with known defects.  Please report problems."
17:07:17 <pumpkin> lol
17:07:40 <roconnor> when is OS XI coming out?
17:07:49 <Gracenotes> ddarius: looks good
17:07:50 <pumpkin> sounds like http://bugreport.apple.com/ time :P
17:07:54 <TuringTest> This is also very broken on OS X: echo XababaYababaZ | sed -r 's/((X)(aba|b|ab)(aba|b|ab)(Y)(aba|b|ab)*(Z))/[\1] => [\2][\3][\4][\5][\6][\7]/'
17:08:01 <TuringTest> pumpkin: I have been
17:08:02 <Olathe> roconnor: Not for a while.
17:08:25 <TuringTest> pumpkin: I may let QuickCheck look for more before I send another report.
17:08:37 <pumpkin> :)
17:08:52 <pumpkin> I hate how apple's radar works
17:08:57 <Olathe> I think they've been spending the time getting OS X up to the features OS 9 had, which they're pretty much done with.
17:09:00 <Cale> roconnor: Heh, they'll probably do something like write it OS 11, but insist that it be pronounced "OS one one"
17:09:06 <pumpkin> if they close my bug as "duplicate of x" I want to be able to see x dammit
17:09:30 <mgsloan2> hey, just curious, is Bool builtin or just in the prelude? it seems like a number of language features (guards, if) depend on it
17:09:55 <Cale> mgsloan2: A bit of both. It's defined in the Prelude, but language features rely on it.
17:10:07 <pumpkin> @src Bool
17:10:07 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:10:16 <EvilTerran> the features that depend on it desugar to things that don't depend on it
17:10:26 <mgsloan2> Cale - right, so how does that work out if I don't import the prelude?
17:10:39 <Olathe> How does if desugar ?
17:10:41 <EvilTerran> (well, that depend on it insofar as they expect True and False to be constructors of the same type)
17:10:49 <Cale> mgsloan2: If you use one of those things, True and False won't be in scope, and you'll get an error
17:10:53 <mgsloan2> ahh I see
17:10:59 <EvilTerran> Olathe, if and guards desugar into case
17:11:04 <Olathe> Ahh.
17:11:08 <mgsloan2> so the data constructors "True" and "False" are the special bits
17:11:10 <mgsloan2> interesting
17:11:18 <EvilTerran> well, the desugaring uses them
17:11:36 <EvilTerran> much like the desugaring for do{} uses >>=
17:11:42 <mgsloan2> right
17:11:55 <EvilTerran> i believe you can mess around with the definitions of both in GHC with -XNoImplicitPrelude
17:12:07 <EvilTerran> and have it affect the desugaring appropriately
17:12:14 <Olathe> Ahh, is that how you get rid of the Prelude ?
17:12:21 <mgsloan2> right.  One could make a really messed up boolean type if one wanted
17:12:27 <EvilTerran> Olathe, that's what separates the desugaring from the prelude types
17:12:36 <EvilTerran> Olathe, you get rid of the prelude with "import Prelude ()"
17:12:36 <Cale> Oh, also, apparently 'if' syntax refers directly to GHC.Bool.Bool
17:12:45 <Olathe> Oh, I was wondering about how to do it outside of this discussion.
17:12:49 <Cale> So if that's not in scope, it just doesn't seem to work...
17:12:59 <mgsloan2> aww
17:13:00 <EvilTerran> Cale, oh, right, even with -XNoImplicitPrelude? that's odd
17:13:11 <tomh-> any UU people here atm?
17:13:16 <mgsloan2> it would be pretty bad ass if you could make a custom bool type that worked in if and such
17:13:22 <EvilTerran> i guess the desugaring would be kinda broken if you changed it
17:13:33 <ddarius> mgsloan2: There's nothing special about True and False.
17:13:45 <Cale> {-# LANGUAGE NoImplicitPrelude #-}
17:13:45 <Cale> data Bool = False | True | FileNotFound
17:13:45 <Cale> foo = if FileNotFound then 'a' else 'b'
17:13:56 <Cale> doesn't seem to work
17:14:04 <EvilTerran> if only "if" desugared to a function you could overload with -XNoImplicitPrelude :P
17:14:10 <mgsloan2> ddarius: I know.  but as cale said, if is tied directly to GHC.Bool.Bool
17:14:34 <ddarius> mgsloan2: As is every other function that is defined against GHC.Bool.Bool
17:14:45 <Gracenotes> ddarius: thanks, it's working :) the final function ended up being somewhat elegant, eval x = maybe x eval (eval' x)
17:14:52 <idnar> haha
17:14:55 <mgsloan2> ddarius: thing is, is that if isn't a function
17:15:08 <mgsloan2> it should be, sure
17:15:25 <ddarius> mgsloan2: Yes, but it presumably desugars into case p of GHC.Bool.True -> ... ; GHC.Bool.False -> ...
17:15:35 <mgsloan2> ahh
17:16:03 <ddarius> Which is no different than a predefined 'if' function would behave.
17:16:27 <EvilTerran> ddarius, but you could swap out a predefined (prelude) "if" function with -XNoImplicitPrelude :P
17:17:05 <mgsloan2> yeah i guess the only difference is that with a custom bool you might not get a pattern match (if it used eg True instead of GHC.Bool.True)
17:17:34 <mgsloan2> so it'd be pretty useless
17:19:38 * Cale wonders if mmorrow ever wrote the quasiquoting syntax for catamorphisms
17:19:48 <drdozer> that's a pain - I can't add indexed type constraints to superclasses that declare those indexed types
17:20:30 <drdozer> I wanted to tell my graph class that: (ID (Node g) ~ ID (NodeI (Edge g)))
17:21:09 <oshyshko> If I have a string like "\\208" (4 chars), how to unescape it to "\208" (1 char)?
17:21:55 <Cale> oshyshko: Well, you could tack some double quotes on either end of it and use the read definition for strings...
17:22:02 <Saizan> > read "\"\\208\"" :: String
17:22:03 <lambdabot>   "\208"
17:22:19 <Cale> > length (read "\"\\208\"" :: String)
17:22:20 <lambdabot>   1
17:23:20 <Holle_> is it possible to run --make direkt from ghci? or i have to use the console: ghc --make [FILE]
17:23:55 <oshyshko> let s = "\\208"   read s :: String    "*** Exception: Prelude.read: no parse
17:24:26 <Saizan> oshyshko: you've to add '\"' at the start and at the end
17:24:38 <byorgey> > read "\"xyz\"" :: String
17:24:39 <ddarius> > let s = "'\\208'" in read s :: Char
17:24:40 <lambdabot>   "xyz"
17:24:41 <lambdabot>   '\208'
17:25:25 <byorgey> > show "xyz"  -- show and read should be inverse
17:25:27 <lambdabot>   "\"xyz\""
17:25:54 <Saizan> aren't they?
17:26:13 <byorgey> yes, for instances in the standard libraries
17:26:16 <mgsloan2> > let unescape = read . ("\""++) . (++"\"") :: String -> String in unescape "\\208"
17:26:17 <lambdabot>   "\208"
17:26:42 <byorgey> well, except for some exceptions
17:27:04 <byorgey> read for Doubles, for example, is not injective
17:27:19 <mgsloan2> might not work out for strings either
17:27:27 <ddarius> read . show = id; show . read /= id
17:27:56 <mgsloan2> > read "\"\65\"" :: String
17:27:58 <lambdabot>   "A"
17:27:58 <byorgey> right.  but show . read  is probably idempotent.
17:28:02 <mgsloan2> yeah
17:28:30 <ddarius> byorgey: If read . show = id then show . read must be idempotent. show . read . show . read = show . id . read
17:28:36 <Holle_> nowbody knows?
17:28:39 <byorgey> ah, good point =)
17:28:55 <aleator> En varmaan mene itsekn.
17:28:57 <crutcher> Saizan: I've got docs now, but no idea what to do next wrt hackage: http://hpaste.org/13812#a2
17:29:16 <Saizan> Holle_: you mean you want ghci to create the .hi and .o files for you?
17:29:25 <chessguy> @pl e k a = c k a s n
17:29:25 <lambdabot> e = flip flip n . flip flip s . c
17:29:27 <Saizan> or build a binary
17:29:32 <Holle_> yes and the exe tooo
17:29:57 <Saizan> in that case there isn't a command for that
17:30:16 <Holle_> so i have to use the console?
17:30:33 <Saizan> you can execute commands in the shell from ghci with :!
17:31:04 <byorgey> crutcher: you want to upload this as a package to hackage?
17:31:25 <crutcher> byorgey: Why not?
17:31:27 <Holle_> ok thanks.
17:31:48 <Saizan> crutcher: http://en.wikibooks.org/wiki/Haskell/Packaging
17:31:53 <byorgey> crutcher: do, by all means!  I was just confirming that's what you were asking about
17:31:56 <byorgey> crutcher: see http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:32:10 <Saizan> http://www.haskell.org/cabal/ also
17:32:29 <oshyshko> let s = Just "\208"     putStrLn $ f $ show s   ...
17:32:53 <oshyshko> What should be "f", so the string will be printed as a single char?
17:33:03 <stepcut> so, do you guys think this function can be implemented?
17:33:04 <stepcut>  h :: (Applicative f) => f (a, (b -> c)) -> (a -> f b) -> f c
17:33:12 <tomh-> anyone into automatic program analysis ?
17:33:19 <crutcher> byorgey: I just sent a request for a hackage account
17:33:34 <byorgey> crutcher: excellent.
17:34:09 <Saizan> stepcut: with c = b that's the same as >>=, so no
17:34:47 <stepcut> Saizan: yeah, I was thinking that as well
17:35:09 <stepcut> so far Indexed Monads are the only solution to my problem
17:35:33 <crutcher> byorgey: I'm cool with revision control, in general. But I've not used darcs before. Is there a community repo, or repo mirror? Or are all projects running their own copies?
17:36:23 <byorgey> crutcher: code.haskell.org is used to host a lot of repos.
17:36:30 <Saizan> they usually just put a darcs repo behind a webserver
17:36:46 <byorgey> crutcher: if you go to community.haskell.org you can request an account.
17:37:07 <byorgey> but since darcs is a distributed RCS it tends to not matter as much.
17:37:17 <dolio> @type \m g -> do (a, f) <- m ; b <- g a ; return (g b)
17:37:18 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t2, t1) -> (t2 -> t t2) -> t (t t2)
17:37:46 <dolio> @type \m g -> do (a, f) <- m ; b <- g a ; return (f b)
17:37:47 <lambdabot> forall (t :: * -> *) t1 t2 t3. (Monad t) => t (t1, t2 -> t3) -> (t1 -> t t2) -> t t3
17:39:11 <dolio> Anyhow, it clearly needs join/bind.
17:40:04 <dolio> @type \m g -> fmap (\(a, f) -> f <$> g a) m
17:40:05 <lambdabot> forall t a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (t, a -> b) -> (t -> f a) -> f1 (f b)
17:41:54 <crutcher> byorgey: only if I can keep track of my repos :)
17:42:32 <oshyshko> read ("\"" ++ (show $ Just "\208") ++ "\"") :: String     "*** Exception: Prelude.read: no parse
17:42:43 <ztirf> @pl (\x y -> (x+y)/2.0)
17:42:43 <lambdabot> flip flip (2 . 0) . ((/) .) . (+)
17:43:00 <byorgey> crutcher: heh, true =)
17:43:12 <ztirf> @pl (\x y -> (x+y)/2)
17:43:12 <lambdabot> flip flip 2 . ((/) .) . (+)
17:43:23 <byorgey> crutcher: well, I keep all mine on code.haskell.org, anyway, it's quite convenient
17:44:01 <dublpaws> anyone know of a virtual machine built with haskell?
17:44:05 <dolio> > read ("\"" ++ (show $ Just "\208") ++ "\"") :: String
17:44:07 <lambdabot>   "* Exception: Prelude.read: no parse
17:44:40 <byorgey> for bigger projects you can request a special directory and group for the project etc., for smaller things I just keep them in a subdirectory of my public web folder
17:44:46 <dolio> > reads ("\"" ++ (show $ Just "\208") ++ "\"") :: [String]
17:44:47 <lambdabot>   Couldn't match expected type `String'
17:45:07 <dolio> > reads ("\"" ++ (show $ Just "\208") ++ "\"") :: [(String,String)]
17:45:08 <lambdabot>   [("Just ","\\208\"\"")]
17:46:02 <crutcher> I think I'll take a stab at hunit later. Unittesting this should be ... interesting?
17:47:07 <Saizan> ah, btw
17:47:41 <crutcher> I guess I could map over a list of MVars, and assert properties
17:47:51 <crutcher> Saizan: btw?
17:47:53 <Saizan> if you do this to spread work on multiple cores you've to pay attention to the strictness
17:48:15 <Saizan> i.e. make sure the result is evaluated in the forked thread, rather than in the consumer
17:48:53 <crutcher> Saizan: aren't MVars strict?
17:49:03 <Saizan> no
17:49:11 <crutcher> really?
17:49:36 <Saizan> really, make a test with undefined
17:49:48 <Saizan> it'll throw an exception only when you inspect it
17:49:59 <crutcher> hmm. Neat.
17:51:12 <Saizan> in fact dons wrote this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict-concurrency
17:54:14 <crutcher> Saizan: Hmm. You don't necessarily want that value to be strict.
17:55:26 <Saizan> crutcher: yeah, i was just pointing the laziness of MVar out because it's commonly overlooked
17:55:31 <crutcher> is there a good name convention for the strict version of a function?
17:55:45 <crutcher> thanks, I didn't even suspect
17:55:56 <ddarius> foldl'
17:56:03 <Axman6> f' is common
17:56:22 <chessguy> ugh, this ADT has to be simpler to write
17:57:19 <Axman6> hmm, mutability would be nice when trying to emulate this in haskell :( http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=ocaml&id=1
17:57:39 <chessguy> i'll give a free ++ to whoever can simplify http://hpaste.org/13813 , lol
17:58:08 <chessguy> (i know, generous of me)
17:58:25 <mae> is there a monadic action which takes a list of monads, executes them in parallel, and returns IO [List of results]
17:58:29 <byorgey> chessguy: why do you have  A | B | C | ... | Z ?
17:58:34 <kpreid> chessguy: ...what are the necessary type distinctions?
17:58:43 <mae> or even a tuple of io actions
17:58:44 <chessguy> byorgey:  meh, for kicks
17:59:08 <kpreid> chessguy: that is, does there have to be a type which holds atoms but not Complex?
17:59:09 <chessguy> kpreid:  the only ones i want to use directly are Sentence and Symbol
17:59:12 <byorgey> ok, I guess as long as you never need to do anything with Symbols other than test for equality
17:59:24 <ski_> chessguy : is `Complex' and `Atom' of any use ?
17:59:33 <chessguy> ski_:  not by itself
17:59:44 <Axman6> mae: something like sequence . parMapM ? (parMapM doesn't exist afaik)
18:00:14 <ski_> chessguy : also, i'd count `T',`F' as `Complex' rather than `Atom' ..
18:00:29 <chessguy> ski_:  err, really?
18:00:32 <kpreid> chessguy: http://hpaste.org/13813#a1
18:01:22 <mae> ok is there a function that taks
18:01:30 <mae> [a] -> (a,a,a,a_
18:01:32 <mae> err
18:01:34 <chessguy> hey, daddy like!
18:01:41 <chessguy> kpreid++
18:01:49 <Olathe> mae: Nope.
18:01:53 * chessguy needs to learn not to stick to grammars quite so literally
18:02:37 <kpreid> chessguy: on the other hand, something more like your original might be useful if you want to be able to pattern match on e.g. "true or false" or "atom"
18:02:46 <crutcher> Saizan: I think this covers it? http://hpaste.org/13812#a3
18:02:55 <chessguy> kpreid:  you can match on T and F
18:03:02 <chessguy> kpreid:  or am i not understanding
18:03:05 <kpreid> chessguy: sure but only as two cases or a guard
18:03:22 <crutcher> mae: what are you asking for exactly?
18:03:43 <kpreid> in your old one you can write case x of Atom ... -> ...; here you would have to write case x of T -> ...; F -> ...; Symbol s -> ...
18:03:49 <chessguy> kpreid:  oh, you mean if i ever need to be able to pattern match against any (original) atom
18:03:59 <kpreid> right
18:04:02 <chessguy> gotcha
18:04:07 <chessguy> i think this should be fine
18:04:51 <kpreid> another thing you might be interested in, though this is unrelated, is a type which by definition only permits e.g. conjunctive or disjunctive normal form
18:05:06 <chessguy> oh?
18:05:51 <kpreid> well, that's another thing you can do. whether it's useful to your app or not, I don't know
18:06:06 <chessguy> kpreid:  yeah, it probably will be. got an example?
18:06:48 <kpreid> data CNF = CNF [[AtomOrNegatedAtom]] would be a sufficient representation
18:07:46 <ddarius> Either Atom Atom
18:08:16 <kpreid> yah
18:09:06 <ski_> @pl Either Atom Atom
18:09:06 <lambdabot> Either Atom Atom
18:09:35 <Olathe> I'd recommend type Symbol = String or something, since Label "A" and A are easy to confuse and pattern matching against A doesn't seem to be needed.
18:10:03 <ski_> (chessguy : yes, really)
18:10:24 <chessguy> Olathe:  fair enough
18:10:27 <chessguy> ski_:  why is that?
18:11:54 <ski_> because i want to group `T',`F' with `(:/\:)',`(:\/:)'
18:12:23 <chessguy> ski_:  err...isn't that kind of begging the question? :)
18:12:31 <chessguy> not disagreeing, jsut trying to understand
18:13:02 <ski_> those are all logical combinators
18:13:26 <ski_> as opposed to the nonlogical propositional variables
18:14:22 <chessguy> well, there is no more "complex" part anyway. or would you still make a change to kpreid's suggestion (http://hpaste.org/13813#a1)
18:14:29 <chessguy> (ski_  ^^)
18:15:33 <kpreid> chessguy: ah, another representation you can use is And [Sentence] | Or [Sentence] | ...
18:15:45 <kpreid> chessguy: then the value And [] is true and Or [] is false
18:18:02 <Axman6> anyone here familliar with OCaml? need a hand converting something into haskell: http://hpaste.org/13814
18:18:59 <kpreid> Axman6: I don't really know OCaml, but I can make a good guess
18:19:35 <Axman6> cheers. i'll paste the code for the datatypes i'm using too, which should help in the conversion
18:20:16 <kpreid> nah
18:20:35 <Axman6> well here it is anyway http://hpaste.org/13814#a1 :P
18:21:45 <ski_> chessguy : abstracting the symbols <http://hpaste.org/13813#a2>
18:22:53 <chessguy> interesting idea
18:23:09 <ski_> i'm not sure how much more useful that is for you
18:23:18 <ski_> but it feels cleaner doing it that way
18:23:36 <ski_> (also, you might be able to exploit the expression monad ..)
18:23:53 <crutcher> Axman6: I'd use the record form
18:24:23 <bigorilla> is there a way to convert Int to Integer? thanks :)
18:24:36 <crutcher> Axman6: are you still looking for an energy func?
18:24:42 <Axman6> bigorilla: fromIntegral, or toInteger i think
18:24:48 <Axman6> crutcher: yeah
18:25:04 <crutcher> bigorilla: fromIntegral (1 :: Int) :: Integer
18:25:14 <bigorilla> thanks
18:25:16 <bigorilla> :)
18:25:23 <ski_> (Axman6 : `(V x y z) .+. .. = ..' can be replaced with `V x y z .+. .. = ..')
18:25:29 <Axman6> > toInteger (1 :: Int)
18:25:30 <lambdabot>   1
18:25:41 <ski_> > toInteger ()
18:25:42 <lambdabot>       No instance for (Integral ())
18:25:42 <lambdabot>        arising from a use of `toInteger' ...
18:25:45 <Olathe> Does hpaste have some sort of search ?
18:25:51 <crutcher> Axman6: well, you _could_ do this all in the state monad, since you keep updating e.
18:26:17 <crutcher> Axman6: but e is just an accumulator, and there's no reason not to just sum over the values
18:26:45 <Axman6> crutcher: well, if you could show me how, i'd be happy to see how it's done :)
18:27:08 <crutcher> let me tinker ...
18:27:13 <kpreid> Axman6: I've annotated with a direct conversion with no haskell-isms other than changing the iteration over bodies
18:27:24 <roconnor> Olathe: AFAIK you have to use google
18:27:29 <Axman6> actually, i think i'll keep going the way i am, it's supposed to be a clear version of the shootout n-bodies problem
18:27:32 <kpreid> but yes, doing a sum without mutation like crutcher says would be a better idea
18:28:36 <Olathe> Google doesn't have much.
18:29:12 <Axman6> kpreid: ah nice, i'll have to try that out later
18:29:25 <roconnor> google blogs?
18:29:45 <gnuvince> haskell.org is down?
18:29:53 <roconnor> upgrading
18:30:08 <gnuvince> roconnor: is it gonna be back up tonight?
18:30:18 <roconnor> not sure how long it will be donw
18:30:33 <gnuvince> ok
18:31:31 <crutcher> Axman6: I'm confused by your operators. Where's +. ?
18:31:33 <chessguy> *TestKB> entails (PropKB [Not (Symbol "p")]) (Symbol "p")
18:31:33 <chessguy> True
18:31:37 <chessguy> hmm, probably not a good thing :)
18:31:54 <Axman6> crutcher: i don't have one, and i haven't found i need one
18:32:13 <crutcher> Axman6: its in the OCaml
18:32:26 <crutcher> So I don't know what to translate it to.
18:32:39 <Axman6> crutcher: how is it needed?
18:32:56 <crutcher> Its in the code, +. is used a lot
18:33:23 <Axman6> oh, +. means work with floating point values i think, nothing to do with my *. etc operators
18:33:37 <ski_> aye
18:34:02 <crutcher> Well, what value do you want me to use?
18:34:24 <crutcher> Look, I'll translate the OCaml, and you re-write it for your types
18:35:11 <Axman6> ok
18:35:43 <crutcher> Also, in the future, maybe use lists for your dimensions? I know it isn't as typesafe, but the code's a lot easier
18:37:01 <BMeph> The surprising thing is that the Haskell version does nothing in parallel... :\
18:37:21 <Axman6> yeah :\
18:37:42 <Axman6> bleh, i did so much stuff like this in python for physics, now i can;t remember any of it >_<
18:38:53 <necroforest> what did you use python for in physics?
18:39:29 <Axman6> iterated simulations of things like n-body problems
18:40:04 <necroforest> ah
18:40:07 <necroforest> it was fast enough ?
18:40:41 <Axman6> awww, it was ok i guess. it was a first year course, so computational efficiency was not a high priority :P
18:40:45 <crutcher> Axman6: I've not tested this, and I'm sure it could be done better, and you should change the func names to something readable, but here you go: http://hpaste.org/13814#a4
18:41:27 <necroforest> a first year course did n-body problems ?
18:42:47 <Olathe> @type sqrt
18:42:48 <lambdabot> forall a. (Floating a) => a -> a
18:42:48 <scsibug> egad, is haskell.org down?
18:42:59 <bigorilla> seems so
18:43:01 <chessguy> ok, good, "p" no longer entails "not p"
18:43:09 <crutcher> Axman6: I think you are better off working out the component functions on their own, and then composing them.
18:43:12 <hydrapheetz> And at the one time I want to go through it, too
18:43:15 <chessguy> bigorilla: scsibug : an email just went out, they're upgrading it
18:43:22 <hydrapheetz> *collective sigh*
18:43:24 <Axman6> crutcher: yeah that's how i'm working atm
18:43:35 <crutcher> Axman6: Is my code helpful?
18:44:16 <Axman6> crutcher:  a little, more for converting the ideas that are going on in the ocaml than actual code though. i'll show you what i have in a sec if you like
18:44:40 <crutcher> k. I may go eat first
18:45:06 <sbahra> !users
18:45:08 <sbahra> @users
18:45:08 <lambdabot> Maximum users seen in #haskell: 668, currently: 596 (89.2%), active: 15 (2.5%)
18:47:53 <chessguy> sweet, got one real example of logical inference working
18:49:22 <skorpan`> no you didn't
18:49:46 <chessguy> eh? are you talking to me skorpan`  ?
18:49:51 <Axman6> crutcher: http://hpaste.org/13814#a5 is what i've come up with
18:49:52 <skorpan`> no, sorry
18:50:00 <chessguy> oh, i was wonderin'
18:50:04 <bigorilla> newb q: "inList :: a -> [a] -> Bool" - how do I say that a is an instance of Eq?
18:50:16 <skorpan`> no you weren't
18:50:27 <Axman6> inList :: Eq a => a -> [a] -> Bool
18:50:29 <skorpan`> tROLLD
18:50:33 <chessguy> bigorilla:  inList :: Eq a => a -> [a] -> Bool
18:50:49 <chessguy> Axman6:  grr
18:50:53 <bigorilla> Axman6 & chessguy thanks mucho btw is there a builtin inList func?
18:50:55 <Axman6> ha, Beelsebob's
18:51:00 <Axman6> Beelsebob'd even
18:51:02 <chessguy> @type elem
18:51:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
18:51:07 <chessguy> ha!
18:51:10 <chessguy> gotcha that time
18:51:21 <Axman6> no you didn't, i didn't say anything :P
18:51:25 <chessguy> exactly
18:51:27 <bigorilla> cool :)
18:51:50 <bigorilla> it's not too bad not knowing all these because then it can be exercise in making em
18:52:05 <skorpan`> not that big of an exercise though
18:52:32 <Axman6> bigorilla: how are you defining inList btw?
18:52:34 <bigorilla> for a newb it might be. first with recursion then with any in map or someth
18:52:49 <chessguy> 33 + 40
18:52:53 <chessguy> oops
18:52:59 <Axman6> > 33 + 40
18:53:00 <lambdabot>   73
18:53:16 <Axman6> ha!
18:53:54 <bigorilla> Axman6: any way of pasting code nicely so I could answer?
18:53:55 <chessguy> lol
18:53:58 <chessguy> @hpaste
18:53:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:54:01 <chessguy> shazam!
18:54:03 <bigorilla> thanks :)
18:54:11 <bigorilla> bot I guess :)
18:54:23 <crutcher> Axman6: I think you can do this with two maps, one over the individual terms, and one over the pairwise (with a correct list comprehension)
18:54:28 <bigorilla> Axman6: started this way: http://hpaste.org/13815
18:54:34 <crutcher> then you subtract the second summation from the first
18:54:57 <ztirf> @src mappend
18:54:58 <lambdabot> Source not found.
18:55:03 <ztirf> @hoogle mappend
18:55:04 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
18:56:06 <crutcher> bigorilla: try: inList a bs = any (==a) bs
18:56:42 <bigorilla> crutcher: thanks. that's my second iteration. sort of, used name for (==a)
18:57:18 <Axman6> bigorilla: want a shorter version?
18:57:30 <bigorilla> hmm. can I use elem? :)
18:57:43 <crutcher> well, there's: inList a = any (==a)
18:58:11 <bigorilla> I got to admit that is compact and simple
18:58:12 <Axman6> inList e (x:xs) = e == x || inList e xs; inList _ [] = False -- pretty lazy, and clear
18:58:27 <crutcher> any is lazy
18:58:35 <crutcher> and short circuits
18:59:21 <Axman6> sure, but i think it's better for someone who's new to learn how to define things recursively first, then find out how they're abstracted in the language elsewhere
18:59:32 <bigorilla> actually with "any (==a)", "elem" almost doesn't deserve having its own name
18:59:34 <Axman6> @src any
18:59:34 <lambdabot> any p =  or . map p
19:00:03 <Axman6> @src or
19:00:04 <lambdabot> or    =  foldr (||) False
19:00:26 <crutcher> @src notElem
19:00:26 <lambdabot> notElem x =  all (/= x)
19:00:27 <bigorilla> @src False
19:00:27 <lambdabot> Source not found. You speak an infinite deal of nothing
19:00:39 <Axman6> @src Bool
19:00:39 <lambdabot> data Bool = False | True deriving (Eq, Ord)
19:00:41 <Olathe> > tails "Hello"
19:00:42 <lambdabot>   ["Hello","ello","llo","lo","o",""]
19:00:50 <bigorilla> hi
19:00:51 <crutcher> now, why notElem has its own def, I have no idea
19:01:13 <Axman6> for clarity
19:01:50 <Axman6> @src notElem
19:01:51 <lambdabot> notElem x =  all (/= x)
19:02:01 <crutcher> not . elem is clear.
19:02:23 <crutcher> throwing 'not' as a prefix on every Bool return func isnt
19:02:40 <Axman6> sure it is
19:03:16 <Saizan> crutcher: it's convenient for uses like filter (x `notElem`) xs
19:04:15 <Saizan> filter (not . elem x) doesn't read as naturally as that
19:04:44 <Olathe> Axman6: Here's my crazy attempt: http://hpaste.org/13814#a6
19:04:45 <crutcher> Saizan: maybe it would be nice to fix the grammar so you could use: filter (x `not . elem`) xs
19:04:55 <crutcher> but that doesn't work
19:05:15 <crutcher> anyway, I'm starving. Thanks for the par help
19:06:41 <Axman6> Olathe: ah nice, yeah i could do with some more functions like kinetic energy
19:07:39 <newsham> grrr..  i upgraded ghc and its broken... again.
19:07:50 <Axman6> newsham: to which version?
19:07:54 <newsham> 6.10.1
19:08:13 <Axman6> how's it broken?
19:08:19 <newsham> Loading package ghc-prim ... ghc: panic! (the 'impossible' happened)
19:08:26 <Axman6> heh
19:08:31 <newsham> ghc: Unable to mmap() for jump islands
19:08:40 <Axman6> ask in #ghc i guess
19:08:51 <newsham> ask what?  i know its broken.
19:09:03 <newsham> there's no doubt about it
19:09:32 <Saizan> well, why, if there's a workaround, if they are aware of the bug, etc..
19:09:56 <newsham> its broken because of the linker.  it was broken in older versions and then they fixed it
19:09:59 <newsham> and i guess they broked it again
19:14:05 <Axman6> well tell them then
19:14:05 <bigorilla> newb question: is it normal to have lots of levels of indentation in haskell?
19:14:25 <Axman6> depends
19:14:52 <bigorilla> (http://hpaste.org/13816)
19:15:00 <newsham> if you're writing lots of small functions you shouldnt need too much indenting
19:16:44 <bigorilla> I wrote a small program with GLUT that lets me move red squares on a chess board.. total newb so my style might be totally blah.. (http://hpaste.org/13816)
19:17:38 <newsham> ?src when
19:17:38 <lambdabot> when p s = if p then s else return ()
19:17:58 <bigorilla> cool :)
19:18:10 <newsham> your "action" function in motionCb can be a "when"
19:18:39 <bigorilla> although I stay of "if"s since I watched subtext2 video :)
19:19:18 <Olathe> Axman6: Now with actual compilability ! http://hpaste.org/13814#a7
19:20:03 <ztirf> I can think of fmap as a container-independent version of map, right?
19:20:36 <Axman6> Olathe: hmm, interesting
19:20:46 <Axman6> ztirf: pretty much
19:20:48 <newsham> polymorphic version of map
19:21:02 <bigorilla> Axman6: so far it looks like the original is simpler..
19:21:11 <dons> ?users
19:21:12 <lambdabot> Maximum users seen in #haskell: 668, currently: 591 (88.5%), active: 15 (2.5%)
19:21:13 <ztirf> k, so is there a corresponding thing for zipWith?
19:21:26 <bd_> ztirf: Not all containers have an ordering
19:21:26 <Axman6> bigorilla: what original?
19:21:41 <bd_> ztirf: so zipWith doesn't necessarily make sense
19:21:44 <bigorilla> it's not related to Ocaml to haskell code in beginning?
19:21:45 <ztirf> bd_: ahhh, I see
19:22:01 <bd_> s/containers/functors/ even
19:22:13 <bd_> @hoogle zipWith
19:22:14 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:22:14 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
19:22:14 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
19:22:26 <Axman6> bigorilla: sorry, what are you talking about? i'm pretty out of it today :P
19:22:41 <bd_> hmm
19:23:07 <ztirf> bd_: how would I go about writing one? I'd need some kind of "ordered" context?
19:23:11 <chessguy> @pl \s -> (symbol "b" s) :=>: (mkSentence "p" (genNeighbors s))
19:23:11 <lambdabot> ap ((:=>:) . symbol "b") (mkSentence "p" . genNeighbors)
19:23:41 <bd_> ztirf: Well, you'd need Data.Foldable + some class that implies the ability to go from a list to whatever this type is
19:23:48 <bigorilla> Axman6: I looked on a hpaste link (http://hpaste.org/13814#a7), which started with "Axman6 OCaml to Haskell 1 hour ago" and assumed the end is a haskell version but I guess my assumption is incorrect
19:23:48 <bd_> monoid
19:23:49 <bd_> right
19:24:09 <bd_> generalZipWith :: (Foldable m, Monoid m) => (a -> b -> c) -> m a -> m b -> m c
19:24:26 <bd_> easiest implementation would be something like:
19:24:49 <bd_> ... hm, wait, monoid doesn't have a singleton element
19:25:10 <bd_> this is sounding suspiciously like a traversable monad
19:25:15 <bd_> plus monoid
19:26:39 <bigorilla> lambdabot: where is when?
19:26:47 <ztirf> bd_: oh - is it just liftM2 or something then?
19:26:59 <bd_> hmm, indeed
19:27:01 <bd_> :t liftM2
19:27:03 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:27:05 <bd_> oho
19:27:09 <bd_> no need for traversable even
19:27:20 <bigorilla> newsham: what do I import for "when"?
19:27:20 <bd_> though
19:27:23 <CakeProphet> @src transpose
19:27:24 <lambdabot> transpose []             = []
19:27:24 <lambdabot> transpose ([]   : xss)   = transpose xss
19:27:24 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:27:27 <bd_> > liftM2 (,) [1,2] [1,2]
19:27:28 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
19:27:32 <bd_> different results for List
19:27:40 <bd_> even though the type matches
19:28:06 <bd_> traversable gives it an order, so a traversable monad.... would need monoid as well probably
19:28:10 <bd_> though I could be wrong :)
19:28:11 <Olathe> > liftA2 (,) [a, b] [c, d]
19:28:13 <lambdabot>   [(a,c),(a,d),(b,c),(b,d)]
19:28:21 <ztirf> is that because the List monad has the concatMap logic in "bind"?
19:28:24 <Olathe> @type liftA2
19:28:26 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
19:28:28 <Olathe> @type liftM2
19:28:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:28:42 <bd_> ztirf: well, if you look at liftM2's definition
19:28:43 <bd_> @src liftM2
19:28:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:28:55 <ztirf> right, there it is
19:28:57 <bd_> it's not really possible to traverse m1 and m2 in parallel if you will
19:30:47 <Olathe> @@ @undo @src liftM2
19:30:48 <lambdabot>  ()
19:30:54 <Olathe> O...K
19:31:10 <Olathe> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:31:10 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
19:31:25 <timebomb> heya, how can i install yi with cocoa ui support?
19:31:25 <CakeProphet> > runState (return "lol")  --test
19:31:27 <lambdabot>       Overlapping instances for Show (s -> ([Char], s))
19:31:27 <lambdabot>        arising from a...
19:31:59 <ztirf> > let (m1,m2) = ([1,2],[3,4]); f = (,) in do { (x1,x2) <- (m1,m2); return (f x1 x2) }
19:32:00 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(a, b)'
19:32:55 <CakeProphet> > evalState (return "lol")  --test
19:32:57 <lambdabot>       Overlapping instances for Show (s -> [Char])
19:32:57 <lambdabot>        arising from a use ...
19:33:06 <Olathe> Hmm...
19:34:05 <Olathe> Is there a way to convert a list to another monad ?
19:34:31 <ztirf> array has listArray
19:34:42 <Olathe> > mplus (return 5) (return 6) :: Maybe Int
19:34:44 <lambdabot>   Just 5
19:34:45 <CakeProphet> using do with lists is pretty much like list comprehension right?
19:34:57 <ztirf> CakeProphet: they are equivalent
19:35:09 <Olathe> @type mplus
19:35:10 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
19:36:49 <Axman6> :t foldl mappend mzero
19:36:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Monoid (m a)) => [m a] -> m a
19:37:05 <Axman6> @src Monoid
19:37:06 <lambdabot> class Monoid a where
19:37:06 <lambdabot>     mempty  :: a
19:37:06 <lambdabot>     mappend :: a -> a -> a
19:37:06 <lambdabot>     mconcat :: [a] -> a
19:37:10 <CakeProphet> @src concatMap
19:37:10 <lambdabot> concatMap f = foldr ((++) . f) []
19:37:13 <Axman6> :t foldl mappend mempty
19:37:14 <lambdabot> forall a. (Monoid a) => [a] -> a
19:37:44 <CakeProphet> @src List >>=
19:37:44 <lambdabot> Source not found. :(
19:37:52 <CakeProphet> @src [] >>=
19:37:52 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:38:14 <chessguy> @type delete
19:38:15 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
19:39:02 <chessguy> err, what's the easiest way to get all pairs of the list, where (a, b) and (b,a) are the same
19:39:07 <chessguy> my brain is dead
19:39:16 <Olathe> @src [] (>>=)
19:39:17 <lambdabot> xs >>= f     = concatMap f xs
19:39:22 <CakeProphet> @src (>>=) :: [a] -> (a -> [b]) -> [b]
19:39:23 <lambdabot> Source not found. There are some things that I just don't know.
19:39:24 <CakeProphet> ...
19:39:51 <Olathe> @src [] (>>)
19:39:51 <lambdabot> xs >> ys      = concatMap (const ys) xs
19:40:05 <CakeProphet> I was just curious which function defined itself in terms of the other and which implemented the actual stuff
19:40:17 <CakeProphet> hmmm
19:40:35 <CakeProphet> so >> just replaces everything?
19:40:35 <Olathe> > sequence [1] [2]
19:40:36 <lambdabot>       No instance for (Num ([t] -> a))
19:40:37 <lambdabot>        arising from the literal `1' at...
19:40:53 <Olathe> @src (>>)
19:40:53 <lambdabot> m >> k      = m >>= \_ -> k
19:42:09 <CakeProphet> > do { a <- [1..10]; [a, a*10]}
19:42:11 <lambdabot>   [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100]
19:42:18 <CakeProphet> > do { a <- [1..10]; [a, a*10]; [a]}
19:42:20 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
19:42:34 <CakeProphet> > do { a <- [1..10]; [a, a*10]; [a+1]}
19:42:36 <lambdabot>   [2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]
19:42:50 <CakeProphet> that's odd.
19:43:07 <CakeProphet> what use is that?
19:44:04 <chessguy> > do { a <- [1..10]; [a, a*10]; [8,8,8,8]}
19:44:06 <lambdabot>   [8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,...
19:45:25 <BMeph> CakeP: What use is what? :)
19:45:33 <chessguy> > let nums = [1..3] in [(x,y) | x <- nums; y <- nums; x /= y]
19:45:34 <lambdabot>   <no location info>: parse error on input `;'
19:45:36 <CakeProphet> using >> with lists.
19:45:56 <chessguy> > let nums = [1..3] in [(x,y) | x <- nums, y <- nums, x /= y]
19:45:57 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
19:46:40 <chessguy> ugh, how do i do that, but not wind up with both (1,2) and (2,1), e.g.,
19:47:16 <ztirf> > zip [1..3] [1..3]
19:47:18 <lambdabot>   [(1,1),(2,2),(3,3)]
19:47:39 <chessguy> err, that's not right
19:47:54 <chessguy> i want [(1,2),(1,3),(2,3)
19:47:58 <chessguy> ]
19:47:59 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
19:48:04 <ztirf> > zipWith (/=) [1..3] [1..3]
19:48:05 <lambdabot>   [False,False,False]
19:48:10 <chessguy> @slap lunabot
19:48:10 * lambdabot secretly deletes lunabot's source code
19:48:15 <chessguy> hahahaha
19:48:24 <Olathe> @type sequence
19:48:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:48:39 <Olathe> > sequence [[1], [2]
19:48:40 <ddarius> How appropriate.
19:48:41 <lambdabot>   <no location info>: parse error on input `;'
19:48:41 <Olathe> > sequence [[1], [2]]
19:48:42 <lambdabot>   [[1,2]]
19:48:48 <Olathe> > sequence [[1], [2, 3]]
19:48:50 <lambdabot>   [[1,2],[1,3]]
19:49:03 <Axman6> @remember lambdabot * lambdabot secretly deletes lunabot's source code
19:49:03 <lambdabot> Done.
19:49:03 <Olathe> > sequence [[1, 2], [3, 4]]
19:49:05 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
19:49:12 <Axman6> @quote lambdabot
19:49:13 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
19:49:18 <Axman6> @quote lambdabot
19:49:18 <lambdabot> lambdabot says: lambdabot hasn't said anything memorable
19:49:26 <Axman6> @quote lambdabot
19:49:26 <lambdabot> lambdabot says: Of course i'm female
19:49:29 <chessguy> > sequence [1..3] [2..3]
19:49:29 <Axman6> @quote lambdabot
19:49:30 <lambdabot> lambdabot says: lambdabot
19:49:30 <lambdabot>       No instance for (Enum ([t] -> a))
19:49:30 <lambdabot>        arising from the arithmetic se...
19:49:37 <ztirf> @src fmap
19:49:37 <lambdabot> Source not found. Sorry.
19:49:40 <Axman6> @quote lambdabot
19:49:40 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
19:49:42 <BMeph> > do { x <- [1..4]; y <- [1..4]; guard (x<y); return (x,y)}
19:49:43 <ztirf> @hoogle fmap
19:49:43 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:49:43 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
19:49:43 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
19:49:44 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
19:49:47 <Axman6> bah
19:50:06 <chessguy> > sequence [[1..3],[2..3]]
19:50:08 <lambdabot>   [[1,2],[1,3],[2,2],[2,3],[3,2],[3,3]]
19:50:16 <Olathe> > sequence [[1, 2]]
19:50:18 <lambdabot>   [[1],[2]]
19:50:19 * BMeph prefers the moe direct: "Beer: It's not Just for Breakfast, anymore!" :)
19:50:31 <Olathe> > sequence [Just 1, Just 2]
19:50:33 <lambdabot>   Just [1,2]
19:51:13 <CakeProphet> > > let nums = [1..3] in [(x,y) | x <- nums, y <- nums, x /= y, x < y]
19:51:15 <lambdabot>   <no location info>: parse error on input `>'
19:51:15 <chessguy> > let nums = [1..3] in sequence [nums,tail nums]
19:51:16 <lambdabot>   [[1,2],[1,3],[2,2],[2,3],[3,2],[3,3]]
19:51:19 <CakeProphet> > let nums = [1..3] in [(x,y) | x <- nums, y <- nums, x /= y, x < y]
19:51:21 <lambdabot>   [(1,2),(1,3),(2,3)]
19:51:31 <Olathe> @type sequence
19:51:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:51:40 <Olathe> @hoogle m [a] -> [m a]
19:51:41 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
19:51:41 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
19:51:41 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
19:51:51 <BMeph> CakeProphet: Having 'x < y' makes 'x /= y' unneeded. :)
19:51:53 <CakeProphet> > let nums = [1..3] in [(x,y) | x <- nums, y <- nums, x < y]
19:51:54 <lambdabot>   [(1,2),(1,3),(2,3)]
19:51:56 <CakeProphet> right
19:52:19 <CakeProphet> that gives you what you want for that list, dunno if it works for all of them
19:52:26 <CakeProphet> > let nums = [1..10] in [(x,y) | x <- nums, y <- nums, x < y]
19:52:28 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(...
19:52:37 <BMeph> CakeProphet: All of which 'them'? :)
19:52:54 <CakeProphet> well, I'm assuming chessguy wants this code to work on something less specific than [1..3]
19:53:07 <chessguy> indeed
19:54:00 <Olathe> > liftM2 (,) (Just 5) (Just 6)
19:54:01 <lambdabot>   Just (5,6)
19:54:34 <ztirf> > liftM2 (,) [1,2] [3,4]
19:54:36 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
19:54:47 <chessguy> whoah
19:54:56 <BMeph> chessguy: So, are you gonna tell us, or is it a Secret? ;)
19:55:02 <chessguy> BMeph:  hm?
19:55:18 <Olathe> > (Just 5) >>= const 1
19:55:20 <lambdabot>       No instance for (Num (Maybe b))
19:55:20 <lambdabot>        arising from the literal `1' at ...
19:55:30 <Olathe> > (Just 5) >> return 1
19:55:32 <lambdabot>   Just 1
19:55:48 <ddarius> CakeProphet: x /= y && x < y <=> x < y unless your ordering is totally jacked up.
19:55:58 <Olathe> > [1, 2, 3] >> return 1
19:55:59 <lambdabot>   [1,1,1]
19:56:01 <BMeph> chessguy: " <CakeProphet> well, I'm assuming chessguy wants this code to work on something less specific than [1..3]  <chessguy> indeed" <- care to be more specific? ;)
19:56:09 <Olathe> > msum [1, 2, 3]
19:56:10 <lambdabot>       No instance for (Num (m a))
19:56:10 <lambdabot>        arising from the literal `1' at <int...
19:56:24 <CakeProphet> ddarius:  I fixed it.
19:56:40 <Olathe> @type sum
19:56:41 <lambdabot> forall a. (Num a) => [a] -> a
19:56:53 <Olathe> @hoogle (Num a) => m a -> a
19:56:55 <lambdabot> Data.Foldable product :: (Foldable t, Num a) => t a -> a
19:56:55 <lambdabot> Data.Foldable sum :: (Foldable t, Num a) => t a -> a
19:56:55 <lambdabot> Prelude product :: Num a => [a] -> a
19:56:55 <ddarius> CakeProphet: Actually I misread the rest of the conversation.
19:57:19 <BMeph> So, if "the cake is a lie", then what does that make *you*, CakeProphet, hmm? ;)
19:57:19 <Olathe> > let sum' = Data.Foldable.sum in sum' [1, 2, 3]
19:57:22 <lambdabot>   6
19:57:30 <Olathe> > let sum' = Data.Foldable.sum in sum' (Just 1)
19:57:32 <chessguy> BMeph:  oh. i'm combining two [(Int, Int)]'s actually
19:57:32 <lambdabot>   1
19:58:03 <BMeph> chessguy: Ah, seksay! :)
19:58:14 <Olathe> > let sum' = Data.Foldable.sum; length' x = sum' (x >> return 1) in length' (Just "A")
19:58:16 <lambdabot>   1
19:58:19 <CakeProphet> > LiftM2 (,) [1..3] [1..3]
19:58:20 <lambdabot>   Not in scope: data constructor `LiftM2'
19:58:22 <chessguy> foo :: [(Int, Int)] -> [(Int, Int)] -> [((Int, Int), (Int, Int))]
19:58:22 <Olathe> > let sum' = Data.Foldable.sum; length' x = sum' (x >> return 1) in length' ["A"]
19:58:24 <lambdabot>   1
19:58:24 <chessguy> :)
19:58:26 <CakeProphet> > liftM2 (,) [1..3] [1..3]
19:58:27 <Olathe> > let sum' = Data.Foldable.sum; length' x = sum' (x >> return 1) in length' ["A", "B"]
19:58:28 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:58:29 <lambdabot>   2
19:59:20 <BMeph> chessguy: Sums and differences? :)
19:59:24 <Olathe> > let sum' = Data.Foldable.sum; length' x = sum' (x >> return 1) in length' (putStrLn "Hello")
19:59:28 <lambdabot>       No instance for (Data.Foldable.Foldable IO)
19:59:28 <lambdabot>        arising from a use o...
19:59:30 <CakeProphet> chessguy:  does x < y work for any list?
19:59:41 <chessguy> CakeProphet:  um...no?
19:59:46 <chessguy> BMeph:  nah, coordinates
19:59:58 <chessguy> BMeph:  i'm playing with logical inference in a wumpus world
20:00:19 <CakeProphet> is there a standard lib function that's like...
20:00:20 <BMeph> chessguy: Ah. Don't get eaten by a grue, then. :)
20:00:29 <chessguy> wumpus you mean :)
20:00:31 <CakeProphet> lol f (x,y) = f x y
20:00:33 <jowens> hey, very n00bish question. i'm doing ok on learning haskell, but i am using a lot of parentheses. I note that people who are good at this use a lot of . and $, and i'd be obliged if I got a good succinct description of "when should i use ." and "when should i use $.
20:00:51 <ddarius> CakeProphet: curry
20:01:00 <CakeProphet> :t curry
20:01:02 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:01:03 <BMeph> CakeProphet: uncurry. :)
20:01:09 <ddarius> Er yeah
20:01:14 <CakeProphet> :t uncurry
20:01:16 <ddarius> What BMeph said
20:01:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:01:21 <BMeph> Er, yeah, curry. Never mind. :p
20:01:25 <CakeProphet> ah ha
20:01:35 <ddarius> No, BMeph, you were right.
20:01:57 <ddarius> Actually, we're both wrong and the answer is fix.
20:02:09 <Olathe> > foldr (:) [] [1, 2, 3]
20:02:11 <lambdabot>   [1,2,3]
20:02:34 <CakeProphet> map (uncurry (<)) (liftM2 (,) [1..3] [1..3])
20:02:37 <Olathe> > let foldr' = Data.Foldable.foldr in foldr' (:) [] (Just 1)
20:02:38 <BMeph> ddarius: LOL
20:02:39 <lambdabot>   [1]
20:02:43 <CakeProphet> > map (uncurry (<)) (liftM2 (,) [1..3] [1..3])
20:02:45 <lambdabot>   [False,True,True,False,False,True,False,False,False]
20:02:46 <CakeProphet> :3
20:02:57 <CakeProphet> > filter (uncurry (<)) (liftM2 (,) [1..3] [1..3])
20:02:59 <lambdabot>   [(1,2),(1,3),(2,3)]
20:03:26 <BMeph> Olathe: So what are you up to? Besides making sure you can rightly use the contents of the Folable module? ;)
20:03:36 <BMeph> *Foldable
20:04:15 * BMeph wishes he could blame his bad typing on the wireless keyboard, but he can't. :)
20:06:16 <BMeph> jowens: when you have a function on either side, use '.'; when you have a composition of functions on one side, and a value for the function(s) on the other, use '$'. :)
20:06:43 <jowens> bmeph: can you do a tiny example for each & compare to how it's done with parens?
20:06:46 <jowens> THANKS
20:06:47 <BMeph> jowens: If that's too succinct, let me know; If it isn't succinct enough, ask ddarius. ;)
20:07:34 * chessguy still has twice as many pairs as he should
20:07:52 <chessguy> squarePairs = filter (\(x,y) -> x /= y) $ liftM2 (,) squares squares
20:09:05 <chessguy> > let squares = [(0,0),(0,1),(1,0),(1,1)] in squarePairs = filter (\(x,y) -> x /= y) $ liftM2 (,) squares squares
20:09:06 <lambdabot>   <no location info>: parse error on input `='
20:09:07 <BMeph> jowens: E.g., I have a totient function in my Factorization module: totient = product . concatMap (\(x:xs) -> pred x:xs). group . primeFactors
20:09:34 <chessguy> > let squares = [(0,0),(0,1),(1,0),(1,1)] in filter (\(x,y) -> x /= y) $ liftM2 (,) squares squares
20:09:35 <lambdabot>   [((0,0),(0,1)),((0,0),(1,0)),((0,0),(1,1)),((0,1),(0,0)),((0,1),(1,0)),((0,...
20:09:49 <BMeph> jowens: If I wanted to use it with a point (that is, with an argument giving a result), I'd write:
20:10:02 <jowens> bmeph: So far I haven't found any functions I can't do with a whole bunch of parentheses. I guess what would be helpful is seeing "a(b(c(d(x)))) =  a ^ b * c ..." or something like that.
20:10:07 <BMeph> jowens: totient n = product . concatMap (\(x:xs) -> pred x:xs). group . primeFactors $ n
20:10:31 <Olathe> BMeph: I was evilly trying to go from m a -> [a], then zip two lists, then go from [(a, b)] -> m (a, b)
20:10:53 <chessguy> @pl \a b c -> a(b(c))
20:10:53 <lambdabot> (.)
20:11:13 <BMeph> jowens: This would otherwise look like: totient n = product (concatMap (\(x:xs) -> pred x:xs) (group (primeFactors n)))
20:11:22 <chessguy> @pl \a b c d -> a(b(c(d)))
20:11:22 <lambdabot> (. (.)) . (.) . (.)
20:11:36 <BMeph> @src (.)
20:11:36 <lambdabot> (f . g) x = f (g x)
20:11:40 <jowens> chessguy: a bit less succinct please :)
20:11:44 <chessguy> haha
20:11:51 <BMeph> jowens: ^^ check out the def'n. :)
20:11:56 <jowens> ahhhh that one is good, (f . g) x
20:11:59 <jowens> i like
20:12:05 <jowens> how about $?
20:12:10 <BMeph> @src ($)
20:12:10 <lambdabot> f $ x = f x
20:12:25 <BMeph> jowens: ^^ There you go. :)
20:12:26 <chessguy> jowens:  ($) is purely a precedence hack
20:12:28 <pumpkin> @pl $ . $
20:12:28 <lambdabot> (line 1, column 1):
20:12:29 <lambdabot> unexpected "$"
20:12:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
20:12:35 <pumpkin> @pl ($) . ($)
20:12:35 <lambdabot> id
20:12:42 <pumpkin> @pl ($ .) . (. $)
20:12:42 <lambdabot> (line 1, column 2):
20:12:42 <lambdabot> unexpected "$"
20:12:42 <lambdabot> expecting lambda abstraction or expression
20:12:50 <pumpkin> @pl (($) .) . (. ($))
20:12:50 <lambdabot> id
20:12:59 <jowens> ok in english, explain the precedence hack?
20:13:11 <CakeProphet> @pl \a b c d e f g h i -> a(b(c(d(e(f(g(h(i)))))))
20:13:12 <lambdabot> (line 1, column 47):
20:13:12 <lambdabot> unexpected end of input
20:13:12 <lambdabot> expecting variable, "(", operator or ")"
20:13:16 <BMeph> chessguy: Have you replaced your 'x /= y' with 'x < y' yet? ;)
20:13:16 <CakeProphet> ...
20:13:26 <chessguy> BMeph:  x and y aren't ints
20:13:27 <CakeProphet> parenthesis hell.
20:13:35 <BMeph> chessguy: For that matter, /can/ you do that replacement? :)
20:13:42 <chessguy> > let squares = [(0,0),(0,1)] in filter (\(x,y) -> x /= y) $ liftM2 (,) squares squares
20:13:44 <lambdabot>   [((0,0),(0,1)),((0,1),(0,0))]
20:14:06 <BMeph> chessguy: Are they members of Ord, though? :)
20:14:22 <chessguy> (that should only produce ((0,0),(0,1))
20:14:22 <BMeph> s/they/their types/
20:14:35 <chessguy> maybe...
20:14:50 <chessguy> > (0,0) < (2,2)
20:14:51 <lambdabot>   True
20:15:00 <jowens> chessguy: can you explain the precedence hack in english?
20:15:02 <chessguy> > (0,8) < (2,2)
20:15:04 <lambdabot>   True
20:15:14 <ddarius> chessguy: Lexicographic
20:15:29 <pumpkin> jowens: how $ works?
20:15:36 <Holle_> i'm using gtk2hs with cairo to draw simple graphics. is it possible to insert a pause between two steps of painting?
20:15:36 <jowens> yes exactly
20:15:37 <chessguy> jowens:  basically it just lets you pretend there are parentheses around the rest of the expression, without putting them there
20:16:03 <jowens> chessguy: can you give me an example of hw you would use it and the parenthesized equivalent?
20:16:13 <pumpkin> jowens: all it does is apply its left argument to its right, but it has the lowest possible precedence
20:16:14 <jowens> in the spirit of (f . g) x = f (g x)
20:16:16 <chessguy> > let squares = [(0,0),(0,1)] in filter (\(x,y) -> x < y) $ liftM2 (,) squares squares
20:16:18 <lambdabot>   [((0,0),(0,1))]
20:16:25 <BMeph> jowens: It's a 'precedence hack' because it lets you separate the function part from the value part without changing the result, so you can have a complicated value on the right side of it. :)
20:16:48 <chessguy> haha, that's sick
20:16:49 <chessguy> ok
20:16:56 <jowens> but chessguy's example has something simple on the right of it
20:17:18 <chessguy> f (x y z) = f $ x y z
20:17:27 <jowens> well, that is what i want to know.
20:17:30 <jowens> ok cool.
20:17:46 <chessguy> that is so ridiculously sick...
20:17:54 <jowens> so it's like f (somethingcomplicated) == f $ somethingcomplicated ?
20:18:02 <chessguy> yep, exactly
20:18:19 <chessguy> jowens:  there's one more place it's nice
20:18:20 <jowens> so all it does is save () and add $?
20:18:24 <jowens> i'm just not seeing the big deal.
20:18:26 * BMeph cheers for jowens - you got it! :)
20:18:34 <CakeProphet> chessguy:  you told me x < y wouldn't work.
20:18:36 <chessguy> (f . g . h) x = f . g . h $ x
20:18:44 <chessguy> CakeProphet:  i was wrong
20:19:00 <Holle_> there should be a function like sleep [time]...
20:19:07 <jowens> (somethingcomplicated) x == somethingcomplicated $ x
20:19:07 <pumpkin> > let (>) = (<) in 5 > 3
20:19:08 <lambdabot>   False
20:19:09 * chessguy eats some tasty cake
20:19:13 <CakeProphet> I thought there was?
20:19:20 <pumpkin> chessguy: it's a piece of cake to bake a pretty cake
20:19:29 <chessguy> jowens:  that's it
20:19:40 <pumpkin> if the way is hazy
20:19:42 <jowens> ok. i will watch for code and see where losing those () makes sense.
20:19:43 <knapr> are programming languages formal languages?
20:19:45 <jowens> thanks guys.
20:19:52 <knapr> to some extent I guess but fully?
20:19:58 <chessguy> jowens:  want me to see if i can scare up an example from my own live code
20:20:05 <jowens> chessguy: sure thing!
20:20:12 <chessguy> here ya go:
20:20:13 <chessguy> symbol s (x,y) = Symbol $ s ++ show x ++ show y
20:20:20 <BMeph> @hoogle delay
20:20:20 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
20:20:37 <BMeph> Holle_: ^^
20:20:39 <jowens> so the paren equivalent is Symbol(s ++ show x ++ show y) ?
20:20:40 <CakeProphet> Holle_:  that's sleep.
20:20:48 <Holle_> ^^
20:21:02 <CakeProphet> noep
20:21:04 <CakeProphet> er
20:21:06 <CakeProphet> yes
20:21:06 <chessguy> jowens:  yep
20:21:11 <CakeProphet> (I didn't see the parens)
20:21:29 <jowens> so ... forgive me, I'm slow ... I'm not seeing the point.
20:21:34 <jowens> you save one character
20:21:39 <CakeProphet> well
20:21:49 <CakeProphet> it becomes easy for parens to get deeply nested.
20:21:53 <pumpkin> jowens: you also get locality :P
20:21:54 <CakeProphet> so $ helps to curtail that.
20:21:55 <jowens> YES I KNOW THAT  :)
20:21:57 <jowens> on the parens
20:22:00 <jowens> because I have way many of them.
20:22:03 <chessguy> jowens:  it prevents us from looking like lisp :)
20:22:16 <ztirf> (shudder)
20:22:17 <chessguy> jowens:  it's nothing more than an idiom
20:22:21 <BMeph> jowens: totient n = product . concatMap (\(x:xs) -> pred x:xs). group $ primeFactors  n
20:22:25 <chessguy> just a habit
20:22:25 <jowens> and i have done lisp. and i love lisp. ok, i see.
20:22:46 <chessguy> BMeph:  nice one
20:23:00 <Holle_> which module i have to import for "sleep"?
20:23:05 <chessguy> @hoogle sleep
20:23:05 <lambdabot> No results found
20:23:11 <jowens> again, thanks guys, i'll watch for more good examples
20:23:12 * chessguy mutters
20:23:14 <pumpkin> @index threadDelay
20:23:14 <lambdabot> GHC.Conc, Control.Concurrent
20:24:18 <Holle_> not in scope: 'sleep'
20:24:23 <CakeProphet> why is it so hard to make a pleasant looking lambda syntax
20:24:29 <CakeProphet> I've never found one that didn't look ugly to me.
20:25:19 <pumpkin> CakeProphet: most of us don't have lambda keys on our keyboards
20:25:22 <ztirf> @pl accum (+) a (assocs a)
20:25:22 <lambdabot> accum (+) a (assocs a)
20:25:32 <ztirf> @pl \a -> accum (+) a (assocs a)
20:25:32 <lambdabot> ap (accum (+)) assocs
20:26:00 <CakeProphet> @pl (\(x:xs) -> pred x:xs)
20:26:01 <lambdabot> ap ((:) . pred . head) tail
20:26:15 <ztirf> @pl \f a -> accum f a (assocs a)
20:26:15 <lambdabot> (`ap` assocs) . accum
20:26:22 <ddarius> CakeProphet: God is telling you point-free is the way to go.
20:26:36 <ddarius> knapr: Yes, programming languages are formal languages.
20:26:43 <Holle_> i couldn't find the module for sleep :/
20:26:45 <pumpkin> @quote wango
20:26:45 <lambdabot> wango says: do you like turing complete?
20:26:45 <CakeProphet> I like point-free when I'm using higher order functions
20:26:51 <pumpkin> Holle_: @index threadDelay
20:26:55 <CakeProphet> but otherwise I have a hard time reading pointfree.
20:27:09 <ztirf> @pl \f a b> accum f a (assocs b)
20:27:09 <lambdabot> (line 1, column 7):
20:27:09 <lambdabot> unexpected ">"
20:27:09 <lambdabot> expecting pattern or "->"
20:27:11 <BMeph> ddarius: Except I'd hesitate to call php a 'formal' anything... ;p
20:27:15 <ztirf> @pl \f a b -> accum f a (assocs b)
20:27:15 <lambdabot> flip flip assocs . ((.) .) . accum
20:27:17 <chessguy> @pl safe s = Not (symbol "w" s) :/\: Not (symbol "p" s)
20:27:18 <lambdabot> (line 1, column 8):
20:27:18 <lambdabot> unexpected "="
20:27:18 <lambdabot> expecting variable, "(", operator or end of input
20:27:20 <ddarius> BMeph: And yet it is.
20:27:43 <chessguy> @pl \s -> Not (symbol "w" s) :/\: Not (symbol "p" s)
20:27:44 <lambdabot> (line 1, column 29):
20:27:44 <lambdabot> unexpected ":"
20:27:44 <lambdabot> expecting pattern
20:27:51 <CakeProphet> @bf MAKE BF WORK LAMBDABOT
20:27:51 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
20:27:56 <Holle_> GHC.Conc, Control.Concurrent doesn't work
20:28:37 <chessguy> @pl \s -> f (Not (sy w s)) (Not (sy p s))
20:28:37 <lambdabot> ap (f . Not . sy w) (Not . sy p)
20:28:51 * chessguy rolls his eyes
20:29:34 <CakeProphet> @src ap
20:29:35 <lambdabot> ap = liftM2 id
20:29:41 <CakeProphet> oh ho
20:29:46 <CakeProphet> ap has a pointfree definition
20:29:51 <CakeProphet> @src (.)
20:29:52 <lambdabot> (f . g) x = f (g x)
20:29:59 <CakeProphet> scandal
20:30:26 <CakeProphet> I no longer deem any code using (.) to be 100% point-free.
20:30:38 <ddarius> (.) = fmap
20:31:00 <pumpkin> @superpl
20:31:00 <lambdabot> Unknown command, try @list
20:31:08 <CakeProphet> ...satisfactory
20:31:20 <CakeProphet> @src flip
20:31:20 <lambdabot> flip f x y = f y x
20:31:27 <CakeProphet> how would define a pointfree flip? That's trickier.
20:31:45 <Olathe> > let foldr' f n xs = (Data.Foldable.foldr) f n xs; toList' xs = foldr' (:) [] xs; zip' :: (MonadPlus m, Data.Foldable.Foldable m) => m a -> m b -> m (a, b); zip' a b = foldr mplus mzero.map return $ zip (toList' a) (toList' b) in zip' (Just 5) (Just 6)
20:31:47 <lambdabot>   Just (5,6)
20:31:51 <CakeProphet> I don't even think it's possible.
20:31:56 <Olathe> > let foldr' f n xs = (Data.Foldable.foldr) f n xs; toList' xs = foldr' (:) [] xs; zip' :: (MonadPlus m, Data.Foldable.Foldable m) => m a -> m b -> m (a, b); zip' a b = foldr mplus mzero.map return $ zip (toList' a) (toList' b) in zip' [1..3] [10..]
20:31:58 <lambdabot>   [(1,10),(2,11),(3,12)]
20:33:07 <BMeph> CakeProphet: Oh, it's possible, it's just messy. :)
20:33:40 <CakeProphet> @src liftM2
20:33:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:34:00 <CakeProphet> okay... ap is no longer super-point-free
20:34:05 <CakeProphet> @src fmap
20:34:06 <lambdabot> Source not found. You type like i drive.
20:34:12 <ddarius> :t \f -> runCont (fmap (Cont f) . return)
20:34:13 <lambdabot>     Couldn't match expected type `a -> b'
20:34:13 <lambdabot>            against inferred type `Cont r a1'
20:34:13 <lambdabot>     In the first argument of `fmap', namely `(Cont f)'
20:34:24 <CakeProphet> @src fmap :: a->b
20:34:24 <lambdabot> Source not found. You type like i drive.
20:34:26 <Olathe> > let foldr' f n xs = (Data.Foldable.foldr) f n xs; toList' xs = foldr' (:) [] xs; zip' :: (MonadPlus m, Data.Foldable.Foldable m) => m a -> m b -> m (a, b); zip' a b = foldr (mplus.return) mzero $ zip (toList' a) (toList' b) in zip' [1..3] [10..]
20:34:28 <lambdabot>   [(1,10),(2,11),(3,12)]
20:34:30 <ddarius> :t \f -> runCont (fmap f . Cont . return)
20:34:31 <lambdabot>     Couldn't match expected type `Cont r a'
20:34:31 <lambdabot>            against inferred type `r1 -> Cont r1 b'
20:34:31 <lambdabot>     In the first argument of `runCont', namely
20:34:31 <Olathe> Shorter.
20:36:02 <ddarius> :t \f -> runCont . fmap f . return
20:36:03 <lambdabot> forall r a b. (a -> b) -> a -> (b -> r) -> r
20:37:13 <ztirf> arg I need a typeclass wizard's help
20:38:05 <ztirf> http://hpaste.org/13817
20:38:14 <ddarius> Ah, need cofmap
20:38:29 <ztirf> I'm trying to make a Zippable class
20:39:03 <ztirf> I've defined fzip :: (a -> b -> c) -> (f a -> f b -> f c)
20:39:20 <ztirf> for lists, fzip = zipWith
20:39:40 <ztirf> but for arrays, this is what I want but it doesn't work: fzip f x y = accum f x (assocs y)
20:39:45 <BMeph> CakeProphet: Here's some :spf for you: "ap = (. ((. (return .)) . (>>=))) . (>>=)"
20:39:50 <Olathe> You can modify what I have a bit to give you zipWith for anything that's MonadPlus and Foldable.
20:40:13 <Olathe> @instances MonadPlus
20:40:14 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
20:40:23 <Olathe> @instances Data.Foldable.Foldable
20:40:24 <lambdabot> Maybe, []
20:40:26 <ddarius> :t let cofmap :: (a -> b) -> (f b -> f a); cofmap = undefined in \f -> cofmap f . runCont . return
20:40:27 <lambdabot> forall a r a1. (a -> r) -> a1 -> (a1 -> r) -> a
20:40:29 <CakeProphet> BMeph:  now create pointfree defintions of return, >>=,  and .   ;)
20:40:32 <Olathe> Not so many, I guess.
20:40:35 <CakeProphet> I think eventually, somewhere
20:40:40 <ztirf> why is an array not foldable?
20:40:40 <CakeProphet> you will need a named variable.
20:42:20 <CakeProphet> BMeph: nontheless, very nice. You've successfully made it impossible for me to discern how pointfree ap works.
20:42:34 <ddarius> :t let cofmap :: (a -> b) -> (f b -> f a); cofmap = undefined in \f -> (. f) . runCont . return
20:42:36 <lambdabot> forall a r a1. (a -> a1 -> r) -> a1 -> a -> r
20:42:48 <ddarius> @pl \f -> (. f) . runCont . return
20:42:48 <lambdabot> (. (runCont . return)) . flip (.)
20:42:52 <ddarius> Shite
20:43:16 <CakeProphet> flip (.)  ...what a wonderful function.
20:43:30 <Axman6> :t flip (.)
20:43:32 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
20:43:47 <ddarius> flip = (. (runCont . return)) . cofmap
20:43:55 <Axman6> @let (.|) = flip (.)
20:43:56 <lambdabot>  Defined.
20:43:58 <ddarius> flip = (. (runCont . return)) . (>>>)
20:44:02 <ddarius> :t (. (runCont . return)) . (>>>)
20:44:03 <lambdabot> forall r a b. (b -> a -> r) -> a -> b -> r
20:44:26 <Olathe> ztirf: http://hpaste.org/13817#a1
20:44:30 <Axman6> > (+2) .| (*5) $ 7
20:44:31 <lambdabot>       Ambiguous occurrence `.|'
20:44:31 <lambdabot>      It could refer to either `L..|', defined...
20:44:38 <Axman6> :t (.|)
20:44:39 <lambdabot>     Ambiguous occurrence `.|'
20:44:39 <lambdabot>     It could refer to either `L..|', defined at <local>:1:0
20:44:39 <lambdabot>                           or `Control.Parallel.Strategies..|', imported from Control.Parallel.Strategies
20:44:44 <Axman6> ah. lame
20:44:53 <Axman6> @let (.|.) = flip (.)
20:44:54 <lambdabot>  Defined.
20:45:01 <Axman6> > (+2) .|. (*5) $ 7
20:45:02 <lambdabot>       Ambiguous occurrence `.|.'
20:45:02 <lambdabot>      It could refer to either `L..|.', defin...
20:45:09 <dolio> (>>>) = flip (.)
20:45:09 <Axman6> rawr
20:45:09 <pumpkin> lol
20:46:02 <kmeyer> ?type flip
20:46:04 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:46:12 <Olathe> @src flip
20:46:13 <lambdabot> flip f x y = f y x
20:46:24 <kmeyer> useful how?
20:46:28 <ztirf> Olathe: gotcha.  So how do I make it work for Array?  What I pasted doesn't work
20:46:46 <dolio> > sortBy (flip compare) [1..10]
20:46:48 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
20:46:50 <ddarius> flip is the adjoint transpose defining the adjunction that induces the continuation monad, which is how I developed my definition.
20:46:56 <gwern> .... does http://www.math.chalmers.se/~patrikj/poly/unify/PU.tar.gz load as a web page for anyone else?
20:47:24 <Axman6> downloads here
20:47:26 <Olathe> @src Either mplus
20:47:27 <lambdabot> Left _ `mplus` n = n
20:47:27 <lambdabot> m      `mplus` _ = m
20:47:37 <gwern> hm. maybe it's just my firefox then
20:48:13 <pumpkin> probably sends its mime type wrong or something
20:48:15 <pumpkin> but it downloads for me
20:48:23 <mauke> gwern: displays inline
20:48:50 <gwern> mauke: you on ff too?
20:48:55 <mauke> yes
20:49:46 <bos> ddarius: you should be writing haskell koans.
20:50:24 <gwern> yeah, we need some decent haskell koans. the ML folks have way better FP koans than we do
20:50:50 <gwern> (the only one I'm really proud of is the Maybe koan)
20:50:52 <mauke> Content-Type: text/plain
20:50:56 <mauke> Content-Encoding: gzip
20:50:59 <knapr> are programming languages formal languages?
20:50:59 <mauke> FAIL
20:51:00 <knapr> to some extent I guess but fully?
20:51:03 <Elly> where's the Maybe koan?
20:51:22 <pumpkin> knapr: am I having deja vu?
20:51:27 <Elly> knapr: that depends how well-described they are, I guess
20:51:37 <knapr> is haskell?
20:51:38 <gwern> Elly: http://haskell.org/haskellwiki/Koans
20:51:40 <knapr> is python?
20:51:40 <gwern> @where koans
20:51:41 <lambdabot> I know nothing about koans.
20:51:47 <gwern> @where+ koans http://haskell.org/haskellwiki/Koans
20:51:48 <lambdabot> I will remember.
20:51:50 <gwern> @where+ koan http://haskell.org/haskellwiki/Koans
20:51:51 <lambdabot> It is stored.
20:51:54 <gwern> @flush
20:52:00 <knapr> can I embed unsafe_perform_assembler in Haskell?
20:52:11 <gwern> (one might complain about the pluralization, but 'haiku' is plural as well)
20:52:15 <pumpkin> knapr: how are those questions related? :P
20:52:16 <stepcut> knapr: harpy ?
20:52:29 <knapr> harpy?
20:52:36 <knapr> @harpy
20:52:37 <lambdabot> Unknown command, try @list
20:52:42 <knapr> @SPJ
20:52:42 <lambdabot> Unknown command, try @list
20:52:45 <stepcut> http://uebb.cs.tu-berlin.de/harpy/
20:52:46 <knapr> @quote SPJ
20:52:46 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
20:52:48 <knapr> @quote SPJ
20:52:49 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbies recruited in '07"
20:52:50 <pumpkin> o.O
20:52:52 <Olathe> ztirf: Let me check.
20:52:53 <gwern> unsafePerformHarpy?
20:53:50 <pumpkin> knapr: most languages computers deal with are "formal"
20:55:46 <pumpkin> knapr: so I think you tend to have people just call them languages, and distinguish the other case by saying "natural"
20:55:46 <gwern> (bah, the actual wiki article is hit #11 for 'haskell koans'? dmmit)
20:55:46 <Olathe> > index ('t', 'v')
20:55:46 <lambdabot>       Overlapping instances for Show (Char -> Int)
20:55:46 <lambdabot>        arising from a use ...
20:55:46 <Olathe> > index ('t', 'v') 'u'
20:55:46 <lambdabot>   1
20:55:46 <Olathe> > range ('t', 'v')
20:55:47 <lambdabot>   "tuv"
20:55:47 <gwern> '<sclv> A student asks master wadler, what is the nature of a recursive type? Wadler replies: Mu.' <-- I sometimes wonder what this one means
20:55:50 <mauke> haha
20:56:29 <mauke> newtype Mu f = Mu (f (Mu f))
20:56:59 * gwern squints at that. lolwut
20:56:59 <Elly> one of these days I need to actually learn haskell instead of using it as ML :P
20:57:00 <CakeProphet> hmmm
20:57:05 <CakeProphet> > 3 `+` 3
20:57:06 <lambdabot>   <no location info>: parse error on input `+'
20:57:12 <pumpkin> `+`?
20:57:12 <CakeProphet> ha
20:57:28 <CakeProphet> just seeing if it worked. :D
20:57:30 <pumpkin> only wordish functions need ``
20:57:31 <pumpkin> lol
20:57:32 <pumpkin> ok
20:57:36 <CakeProphet> > 3 `(+)` 3
20:57:37 <lambdabot>   <no location info>: parse error on input `('
20:57:38 <gwern> > 3 `(+)` 3
20:57:39 <lambdabot>   <no location info>: parse error on input `('
20:57:55 <gwern> jinxed *and* wrong, what an cursed expression
20:57:58 <mauke> gwern: http://blog.plover.com/prog/springschool95-2.html
20:58:10 <pumpkin> > (`mod`) 5 2
20:58:11 <gwern> > let plus = (+) in 3 `plus` 3
20:58:12 <lambdabot>   <no location info>: parse error on input `)'
20:58:12 <lambdabot>   6
20:58:13 <ztirf> Olathe: ahhh, it's because accum doesn't do what I want
20:58:17 <pumpkin> > `mod` 5 2
20:58:18 <lambdabot>   <no location info>: parse error on input ``'
20:58:20 <ztirf> :type accum
20:58:25 <ztirf> @type accum
20:58:27 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
20:59:19 <ztirf> why isn't that (e->a->f) I wonder?
20:59:20 <gwern> I wonder how hard it'd be to switch the haskell wiki to gitit
20:59:41 <BMeph> ztirf: Uh, because it's an /accumulator/, maybe? ;p
20:59:43 <gwern> it's not like we use much complex mediawiki stuff besides categories and a few templates
21:00:10 <bos> i imagine that john macfarlane would be quite happy to have haskell.org as a customer.
21:00:45 <gwern> probably
21:00:47 <Olathe> ztirf: How are you going to handle arrays with very weird startings and endings ?
21:01:04 <gwern> I was thinking more of the dogfooding aspect - factor runs on its own wiki, why shouldn't we?
21:01:07 <Olathe> ztirf: Like (1, 5) and (100, 120) ?
21:01:24 <CakeProphet> bounds!
21:01:26 <CakeProphet> ...
21:01:38 <BMeph> ztirf: It's made to go through multiple occurances of matching 'i' in the pairs.
21:01:38 <Olathe> Yes, bounds.
21:01:41 <Olathe> And leaps, too.
21:01:42 <bos> gwern: well, factor has approximately no users compared to haskell (or possibly compared to any small integer of your choice).
21:02:03 <ztirf> Olathe: hmm, I guess I would want that to throw an error or something
21:02:10 <gwern> bos: ZED SHAW USES IT
21:02:17 <pumpkin> ztirf: so they'd have to have the same starting index?
21:02:23 <gwern> (which makes it so fucking awesome, by definition)
21:02:29 <CakeProphet> bos:  -1000000 is a pretty small integer.
21:02:36 <bos> gwern: THEN IT's FUCKING AWESOME.
21:02:42 <ztirf> pumpkin: yeah, I want to write a Zippable class and make an instance for arrays
21:02:43 <pumpkin> CakeProphet: is it? :o
21:02:46 <BMeph> gwern: ho's Zed Shaw? ;)
21:02:54 <ztirf> so they should probably have to have that
21:02:55 <BMeph> gwern: Who's Zed Shaw? ;)
21:02:58 <mae> what is the easiest way to use a constant defined in a C header in your haskell code
21:03:02 <pumpkin> ztirf: yeah, but how do you deal with mismatched bounds?
21:03:05 <CakeProphet> > -100000000 < 0
21:03:06 <lambdabot>   True
21:03:08 <CakeProphet> pumpkin:  yes
21:03:17 <CakeProphet> anything smaller than nothing is pretty small.
21:03:18 <gwern> BMeph: well as a consultant he is a ho, so you were right the first time
21:03:27 <Olathe> ztirf: I think it'd be better to get the intersection of the ranges.
21:03:35 <Olathe> ztirf: That's effectively what list zip does.
21:03:48 <stepcut> mae: I use hsc2hs. {#const NAME_OF_C_CONST}, or something like that. it's been a while.
21:03:50 <ztirf> Olathe: right
21:03:59 <ddarius> bos: Small integers have way more users than Haskell.
21:03:59 <BMeph> ztirf: Why not start small: Make a zippable class, and put all of the zipWith versions in it. Along with map. And repeat. And make them work automagically. ;)
21:04:03 <Olathe> ztirf: (0, 5) and (0, 3) [for lists of six and four elements] gives (0, 3) result.
21:04:06 <kerlo> I'd say that most programming languages have "approximately no users compared to -1000000".
21:04:27 * CakeProphet makes a language called Small Integers.
21:04:33 <kerlo> 0 is a better approximation than -1000000, after all.
21:04:47 <ztirf> BMeph: well for lists its easy: instance Zippable [] where fzip = zipWith
21:04:51 <gwern> all programming languages have measure 0 users, according to an obscure math joke I saw
21:05:04 <Olathe> Maybe and Either are also simple.
21:06:39 <BMeph> ztirf: What if you want to zip three lists? ;p
21:07:33 <ztirf> well then I'd have to write a new class, right, because it wouldn' be class Zippable where          fzip :: (a -> b -> c) -> (f a -> f b -> f c)
21:07:36 <gwern> I hope macfarlane finishes up the darcs gitit support soon :(
21:07:49 <ztirf> you'd need (a->b->c->d) or something
21:07:50 <gwern> (waiting is so tiresome)
21:07:51 <Olathe> \f xs ys zs -> fzip f (fzip f xs ys) zs
21:07:58 <Olathe> @type \f xs ys zs -> zip f (zip f xs ys) zs
21:08:00 <lambdabot>     Couldn't match expected type `t -> [b]'
21:08:00 <lambdabot>            against inferred type `[(a, b1)]'
21:08:00 <lambdabot>     In the second argument of `zip', namely `(zip f xs ys)'
21:08:07 <Olathe> Hmm...
21:08:18 <Olathe> @type \f xs ys zs -> zip (f.uncurry) (zip f xs ys) zs
21:08:19 <lambdabot>     Couldn't match expected type `[a]'
21:08:20 <lambdabot>            against inferred type `(a1 -> b -> c1) -> c'
21:08:20 <lambdabot>     In the first argument of `zip', namely `(f . uncurry)'
21:08:28 <Olathe> @type \f xs ys zs -> zip (uncurry f) (zip (,) xs ys) zs
21:08:30 <lambdabot>     Couldn't match expected type `[a]'
21:08:30 <lambdabot>            against inferred type `(a1, b) -> c'
21:08:30 <lambdabot>     In the first argument of `zip', namely `(uncurry f)'
21:08:33 <Olathe> ...
21:08:49 <Olathe> @pl \(a, b) c -> f a b c
21:08:50 <lambdabot> uncurry f
21:09:02 <Olathe> @type \f xs ys zs -> zipWith (uncurry f) (zipWith (,) xs ys) zs
21:09:04 <lambdabot> forall a b b1 c. (a -> b -> b1 -> c) -> [a] -> [b] -> [b1] -> [c]
21:09:11 <Olathe> @type zipWith3
21:09:12 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:09:24 <Olathe> So...
21:09:49 <Olathe> fzip3 xs ys zs = fzip (uncurry f) (fzip (,) xs ys) zs
21:10:26 <Olathe> Bah.
21:10:29 <Olathe> fzip3 f xs ys zs = fzip (uncurry f) (fzip (,) xs ys) zs
21:10:37 <ztirf> @type ((listArray (0,3) [0..3]) >>= )
21:10:38 <lambdabot> forall t t1 b. (Monad (Array t), Ix t, Enum t1, Num t1, Num t) => (t1 -> Array t b) -> Array t b
21:10:56 <ztirf> @src Array >>=
21:10:57 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:11:00 <ztirf> @src Array a >>=
21:11:01 <lambdabot> Source not found. You untyped fool!
21:11:06 <Olathe> @src Array (>>=)
21:11:07 <lambdabot> Source not found. You type like i drive.
21:11:12 <Olathe> @instances Monad
21:11:13 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:11:22 <Olathe> I don't think Array is a monad.
21:11:26 <ztirf> ouch
21:13:03 <Olathe> @type zipWith3
21:13:04 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:13:29 <Olathe> @pl \f xs -> f xs
21:13:30 <lambdabot> id
21:13:52 <Olathe> @type \f xs ys zs -> zipWith id (zipWith f xs ys) zs
21:13:54 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> [a] -> [b1] -> [b] -> [c]
21:13:55 <CakeProphet> > let zipWith3 xs ys zs = zipWith ($) (zipWith f xs ys) zs in zipWith3 (,,) [1,2,3] [1,2,3] [1,2,3]
21:13:57 <lambdabot>   Couldn't match expected type `[a]'
21:14:50 <CakeProphet> > let zipWith3 f xs ys zs = zipWith ($) (zipWith f xs ys) zs in zipWith3 (,,) [1,2,3] [1,2,3] [1,2,3]
21:14:52 <lambdabot>   [(1,1,1),(2,2,2),(3,3,3)]
21:15:07 <Olathe> > let zipWith3 f xs ys zs = zipWith id (zipWith f xs ys) zs in zipWith3 (,,) [1,2,3] [1,2,3] [1,2,3]
21:15:09 <lambdabot>   [(1,1,1),(2,2,2),(3,3,3)]
21:15:46 <CakeProphet> ztirf:  you can make a bunch of fzipn functions based off of the defintion of fzip
21:15:55 <CakeProphet> like so.
21:18:19 <Olathe> http://hpaste.org/13817#a3
21:18:32 <Olathe> @type zipWith7
21:18:33 <lambdabot> forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
21:18:34 <Olathe> @type zipWith8
21:18:35 <lambdabot> Not in scope: `zipWith8'
21:18:48 <Olathe> So, now you have the same fzip to fzip7
21:19:10 <CakeProphet> ...why on earth would you ever need zipWith7
21:19:22 <dolio> You wouldn't.
21:19:53 <Olathe> For all your seven argument functions, of course ;)
21:19:55 <ztirf> don't knock those 7-dimensional functions
21:20:52 <gwern> well sure; just the other day I used a 6th order function
21:20:59 <kmeyer> how does haskell know when to use Double or Float for Fractional types?
21:21:11 <mauke> kmeyer: it defaults to Double
21:21:16 <kmeyer> ah
21:21:25 <kmeyer> so unless you specify Float it sticks to Double?
21:21:40 <gwern> let's see, how did that one go? it took a parser generating a parser paramaterized by a few settings and returned a curried parser...?
21:21:51 * gwern needs to re-read that Functional Pearl
21:22:51 <dolio> zipWith6 isn't 6th order, by the usual definition of order for functions.
21:22:58 <dolio> It's only second order.
21:23:16 <dolio> (Not that that's what you meant.)
21:23:56 <Olathe> > let fzip f as bs=zipWith f as bs;fzip3 f as bs cs=fzip id(fzip f as bs)cs;fzip4 f as bs cs ds=fzip id(fzip3 f as bs cs)ds;fzip5 f as bs cs ds es=fzip id(fzip4 f as bs cs ds)es;fzip6 f as bs cs ds es fs=fzip id(fzip5 f as bs cs ds es)fs;fzip7 f as bs cs ds es fs gs=fzip id(fzip6 f as bs cs ds es fs)gs in fzip7 (,,,,,,) [1] [2] [3] [4] [5] [6] [7]
21:23:57 <lambdabot>   [(1,2,3,4,5,6,7)]
21:24:19 <ztirf> nice
21:25:30 <Saizan> http://hpaste.org/12309
21:27:25 <ztirf> Saizan: what does the "guarded" type notation mean in class Zip a r | r -> a ?
21:27:48 <Saizan> it's a functional dependency
21:28:04 <Saizan> it meas that r uniquely determines a
21:28:07 <Olathe> Just what you've always hoped for...Zippable (): http://hpaste.org/13817#a5
21:29:24 <Olathe> > undefined :: ()
21:29:25 <lambdabot>   * Exception: Prelude.undefined
21:30:10 <Olathe> Is it a bad idea to use _ to ignore any arguments when the type is () ?
21:30:35 <ddarius> Olathe: It depends on whether you want your function to strict or not.
21:30:36 <Olathe> Or is undefined supposed to cause mayhem there ?
21:32:55 <BMeph> gwern: Bind for a continuation-based parser, I believe. :)
21:38:03 <dolio> @free seq
21:38:04 <lambdabot> g . seq x = seq (f x) . g
21:40:22 <mauke> @free const
21:40:23 <lambdabot> f . const x = const (f x) . g
21:40:37 <ztirf> if I have a list of functions and I want to apply them to another list, how do I do that
21:40:53 <mauke> zipWith id
21:41:30 <ztirf> ah, yes
21:45:30 <mm_freak> is there any difference between 'data X a = X (a -> a)' and 'data X a = X !(a -> a)'?
21:46:35 <dolio> Yes.
21:46:44 <mm_freak> background:  i have a data structure with many functions, and i wonder whether i can save some memory through strictness
21:47:31 <dolio> No, it won't save any memory.
21:47:57 <dolio> Although 'newtype X a = X (a -> a)' might, I guess.
21:48:06 <mm_freak> newtype won't work for me
21:50:54 <BMeph> gwern: www.eecs.usma.edu/webs/people/okasaki/jfp98.ps
21:53:17 <pumpkin> BMeph: you'll try to be nicer if I try to be smarter? :o
21:53:54 <asolove> I'm wondering if someone can help me get the ghci toplevel working with emacs editing.
21:54:39 <asolove> the ghci process is started in my home folder, when emacs calls load it gives a full path so that works ok, but if the module requires another one in the same directory, ghci can't find it
21:54:54 <asolove> Is there a way to set the ghci search path?
21:55:38 <ztirf> asolove: :set -i<path>
21:55:56 <asolove> wow, thanks
21:57:03 <BMeph> pumpkin: That's my story, and I'm sticking to it. ;p
21:58:28 <pumpkin> :)
22:08:33 <pumpkin> :t forM
22:08:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:08:40 <pumpkin> @src forM
22:08:40 <lambdabot> forM = flip mapM
22:08:43 <pumpkin> lol
22:09:38 <kmeyer> what does the forall syntax mean in type definitions?
22:09:51 <fsanches> sometimes the code is much simpler than the type signature, uh?
22:10:03 <pumpkin> @src mapM
22:10:03 <lambdabot> mapM f as = sequence (map f as)
22:10:08 <pumpkin> yup :)
22:10:24 <kmeyer> @src sequence
22:10:25 <lambdabot> sequence []     = return []
22:10:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:10:25 <lambdabot> --OR
22:10:25 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:10:50 <Cale> kmeyer: It's implicit if left out. It introduces type variables: forall a. (...) means that for all types a, the type (...) is valid.
22:10:55 <kmeyer> ah, so it's a monad version of map?
22:11:19 <elbar> hence the ..M ;)
22:11:31 <kmeyer> well I'm just trying to understand the definition is all :D
22:11:44 * kmeyer is a newbie
22:12:13 <fsanches> some of these functions are just amazing
22:12:23 <Cale> Basically, you can ignore it... "forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]" means the same thing as "(Monad m) => [a] -> (a -> m b) -> m [b]"
22:13:05 <Cale> Explicit foralls only start to matter when they occur deeper into the type
22:14:28 <Cale> :t runST
22:14:29 <lambdabot> forall a. (forall s. ST s a) -> a
22:14:45 <ztirf> so that's weird, why isn't this a runtime error:
22:14:48 <Cale> Like in that case, where the parameter to the function must be polymorphic.
22:14:53 <ztirf> listArray (5,3) [0..3]
22:14:58 <ztirf> > listArray (5,3) [0..3]
22:14:59 <lambdabot>   array (5,3) []
22:15:11 <Cale> ztirf: It's an empty array, I suppose.
22:15:26 <Cale> listArray doesn't complain about extra elements in the list you provide.
22:16:11 <ztirf> > listArray (3,3) [0..]
22:16:12 <lambdabot>   array (3,3) [(3,0)]
22:16:14 <Cale> > range (5,3)
22:16:16 <lambdabot>   []
22:16:27 <Cale> > range (3,5)
22:16:29 <lambdabot>   [3,4,5]
22:16:31 <ztirf> huh I see
22:16:57 <BMeph> @src (>>=) Cont r
22:16:57 <lambdabot> Source not found. Maybe you made a typo?
22:16:59 <BMeph> @src (>>=) Cont
22:17:00 <lambdabot> Source not found.
22:17:05 <BMeph> @src (>>=) Cont r a
22:17:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:17:12 <BMeph> @src (>>=) (Cont)
22:17:13 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:17:21 * BMeph sighs
22:17:33 <Cale> @src Cont (>>=)
22:17:34 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
22:18:22 <ztirf> BMeph: I finally got Zippable Array to work
22:18:35 <ztirf> http://hpaste.org/13817#a6
22:19:15 <BMeph> ztirf: Conga-Rats! ;)
22:19:22 <BMeph> Cale: Thanks. :)
22:19:23 <ztirf> ya rly
22:20:45 <ztirf> I should totally put that on hackage
22:32:56 <Axman6> is there any way to see info about the optimisation rules that've been fired? i can see what rules have been fired with ghc-core, but not what they are
22:33:58 <Axman6> also, has anyone ever defined an instance of NFData for use with Controll.Parallel(.Strategies)?
22:34:31 <Cale> Axman6: I've done the latter.
22:35:33 <pumpkin> I've used derive to do it for me
22:35:35 <Cale> As for figuring out what the rules are, they're in the library source, if you can find them.
22:35:44 <Axman6> pumpkin: that works?
22:36:10 <pumpkin> Axman6: worked for me
22:36:18 <pumpkin> I just used the Data.Derive.TH
22:36:41 <Cale> You'll find pragmas like  {-# RULES "split/join" forall x. splitD (joinD x) = x #-}
22:37:07 <Axman6> ah righto
22:37:18 <Cale> Writing your own instance of NFData isn't so hard though
22:37:21 <ddarius> There's a compiler flag that will dump which rewrite rules fired.
22:37:46 <Axman6> well http://hpaste.org/13819 are my datatypes. what sort of thing do i need to write to make rnf?
22:37:51 <Axman6> english++
22:38:19 <Axman6> ddarius: yeah, i've been using dons' ghc-core to see what's going on, and i was wondering what the rules were actually doing
22:38:22 <Cale> Oh, in that case,  rnf = seq
22:38:26 <Cale> er
22:38:43 <Cale> well,  rnf = whnf
22:38:49 <Axman6> flip seq ()?
22:39:03 <Axman6> or flip seq Done i guess
22:39:08 * pumpkin helps Axman6 wean off rnf addiction
22:39:13 <Cale> type Done = ()
22:39:27 <Axman6> ah yes, it's a type, my bad
22:39:41 <Cale> But there's an rwhnf which does that.
22:39:58 <Cale> The strictness annotations on your type will take care of the est.
22:40:00 <Cale> rest*
22:43:38 <knapr> since haskellers know everything. how do I move a value into: int i; in C++? asm("mov i, $1"); doesnt work
22:43:55 <pumpkin> o.O
22:43:57 <mauke> depends on your compiler, obviously
22:44:09 <pumpkin> that's not c++ anyway :P
22:44:16 <pumpkin> int i = 1 ;)
22:44:24 <mauke> IIRC C++ makes 'asm' an actual keyword
22:44:36 <pumpkin> well yeah, but the code's in a string, that's cheating
22:44:39 <intoverflow> sure, though the assembler syntax is probably allowed to vary
22:44:43 <intoverflow> say, across platforms
22:44:51 <knapr> can graph libraries and other datastructres gain much from parallell code(perhaps need to be rewritten to do so but can they)?
22:45:10 <p_l> knapr: I guess it depends on the exact task
22:45:52 <p_l> if you do a lot of work in parts of graph that are not directly connected, it could speed things a lot
22:46:34 <kmeyer> knapr: ask in ##c++
22:52:47 <knapr> in haskell it feels not like programming but like declarations of truth. how does it work? i cant feel the metal. does ghc generate machinecode? can i see what machinecode it generates somehow?
22:53:03 <pumpkin> yes, yes
22:53:19 <ddarius> knapr: Program in lambdaProlog
22:53:23 <pumpkin> -keep-s-file
22:53:26 <pumpkin> I think
22:53:33 <pumpkin> will show you the asm it generates
22:54:59 <sjanssen> knapr: what does programming have to do with metal?
22:55:32 * pumpkin pulls out his dijkstra quote
22:55:32 <mauke> sounds like you haven't written enough Perl
22:55:41 <Saizan> (well, there are those automatic lyrics generators for epic metal)
22:55:59 <intoverflow> Saizan: that's only true IN HELL
22:56:04 <kerlo> s/metal/substance/, perhaps.
22:56:05 <pumpkin> "Computer science is no more about computers than astronomy is about telescopes"
22:56:06 <pumpkin> or something like that
22:56:37 <intoverflow> yeah, but this is from the guy who doesn't like goto's, so who can trust him?
22:57:01 <pumpkin> knapr: if you want to feel the metal, you should program in assembly language :)
22:57:07 <pumpkin> everything else is a progressively thicker condom
22:58:15 <sjanssen> pumpkin: hmm, that isn't the most flattering comparison :)
22:58:19 <pumpkin> lol
22:58:34 <Saizan> it depends, is the condom a stimulating one?
22:58:36 <pumpkin> really thick condoms are the best!
22:58:48 <intoverflow> condoms are eminently useful
23:00:37 <intoverflow> *silence*
23:01:00 <pumpkin> :)
23:01:00 <intoverflow> this is like my first day of teaching all over again
23:07:21 <pumpkin> intoverflow: teaching what?
23:07:36 <intoverflow> math
23:09:36 <ddarius> The Condom Problem: "Two men and two women would like to have safe sex in all four hetrosexual permutations. Given two condoms, how can they do so?"
23:09:53 <pumpkin> lol
23:10:05 <pumpkin> can you list all four heterosexual permutations for me before I answer?
23:10:10 <bigorilla> there's also the 3 and 1 version
23:10:36 <bigorilla> but also you're telling it wrong
23:10:49 <bigorilla> two dudes and two chicks, each one with a different sex disease..
23:11:01 <ddarius> bigorilla: That's not relevant.
23:11:06 <bigorilla> :)
23:13:17 <bigorilla> pumpkin: Jo with Lissa, Mickey with Lisa, Jo with Elizabeth, Mickey with Elizabeth
23:23:23 <bigorilla> @src takeWhile
23:23:23 <lambdabot> takeWhile _ []                 =  []
23:23:23 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
23:23:23 <lambdabot>                    | otherwise =  []
23:28:53 <hydrapheetz> ssssdddddwwww/win 35
23:28:57 <hydrapheetz> oops
23:30:15 <hydo> Heh.. my first thought was "Oh, he must be playing a game in another window.  back x4, left x5, and forward x4".
23:30:29 <hydrapheetz> hydo: You're actuall correct about that.
23:30:37 <hydrapheetz> Garry's Mod, in fact
23:30:49 <kmeyer> yeah, I guessed something fps-ish from the /command
23:30:55 <kmeyer> well and the movement keys
23:31:04 * hydrapheetz alt-tabbed to switch to a different window in irssi
23:31:50 <hydo> Oh wow, garry's mod is pretty cool.
23:32:06 <hydrapheetz> Yeah, it is. 'specially with spacebuild 3 and all the related mods
23:32:35 <hydrapheetz> Makes for hours of entertainment (and hilarity. Like that one time my spaceship *exploded* because I forgot to add a space shield.)
23:36:15 <hydo> ok, I can't resist.  This looks like too much fun.
23:44:33 <jeffwheeler> Does anybody have GHC 6.10 on Ubuntu? If so, did you manually install from the linux x86 binaries?
23:45:29 <Saizan> that's the preferred route, anyway, unless you want to rebuild it to use readline
23:45:48 <jeffwheeler> Saizan: fair enough, I'll do that; thanks
23:46:01 <jeffwheeler> I'm fairly indifferent about the readline issue.
23:47:47 <intoverflow> jeffwheeler: I use 6.10 on ubuntu, I built from source
23:47:51 <intoverflow> iirc there isn't an apt-get for it
23:48:07 <kmeyer> @src foldl
23:48:07 <lambdabot> foldl f z []     = z
23:48:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:48:14 <jeffwheeler> intoverflow: yeah, the prebuilt package is 6.8.3; thanks
23:48:20 <jeffwheeler> I'm downloading the src now.
23:48:40 <Saizan> why not the generic binary?
23:48:44 <kmeyer> @src foldr
23:48:44 <lambdabot> foldr f z []     = z
23:48:45 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
23:48:53 <pumpkin> anyone happen to know if unsafeFreezeMU is O(1)?
23:49:18 <jeffwheeler> Saizan: Oh, actually I lied. I was downloading the binary without realizing it, anyways! :)
23:49:41 <kmeyer> is foldl faster / use less stack than foldr or vice versa?
23:50:16 <kmeyer> (to me it looks like foldl is lazier)
23:50:25 <kmeyer> oh wait
23:50:46 <pumpkin> I'm assuming it's unsafe because it's keeping the exact same backing, and someone could still mutate it behind your back... which would sort of imply O(1)
23:51:22 <vixey> kmeyer, in different situations they have different space and time complexity
23:51:22 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
23:51:28 <vixey> @mossages
23:51:28 <lambdabot> mmorrow said 10h 43m ago: i've got abssyn, free/bound vars, and a parser + pprinter for pisigma at http://moonpatio.com/repos/pisigma/. i've decided to use this as the interp frontend "core lang"
23:51:28 <lambdabot> for my lvm implem, so if everything goes as planned, anything you can manage to translate into this you can interpret
23:52:23 <Saizan> @wiki Stack overflow
23:52:23 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
23:52:29 <Saizan> kmeyer: ^^^^
23:54:02 <Saizan> the short story is, foldr f is better when f is sufficiently lazy in its second argument, foldl is rarely the right choice, you use foldl' f when f is strict
23:54:55 <Saizan> iin thos situation they work in constant stack
23:55:13 <Saizan> s/iin thos situation/in those situations/
23:55:39 <kmeyer> Saizan: ok, thanks
23:55:57 * kmeyer is still newbie
23:57:22 <vixey> kmeyer, I think of foldl f s0 [a,b,c,..] as going    s0 ~(a)~> s1 ~(b)~> s2 ...
23:57:26 <Saizan> the key is to understand that lazy evaluation reduces expressions in outermost-leftmost first order with sharing
23:57:34 <kmeyer> vixey: what's ~?
23:57:42 <vixey> just a squiggle
23:57:45 <kmeyer> heh
23:57:53 <vixey> but the arrows mean it takes the intial state through each element of the list via 'f'
23:58:10 <vixey> and foldr (&) o [a,b,c,d] = a & (b & (c & (d & o)))
23:58:10 <Saizan> and in foldr f z, f ends up being the outermost function, so that's what drives evaluation
23:58:47 <vixey> so foldr just replaces all the (:) and [] constructors in one go
23:59:42 <Saizan> while with foldl, the application of f is buried in the accumulating parameter, and it's only demanded after the whole list is consumed, so you can build an huge thunk formed by the applications of 'f'
