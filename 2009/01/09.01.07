00:02:56 <Saizan> not necessarily
00:03:01 <Saizan> look at ghc-pkg list
00:12:42 <rwbarton> all right, I already found some code that ghc 6.8.2 accepts and ghc 6.10.1 doesn't!
00:12:51 <cjs> Oh, I found some of that, too.
00:13:07 <rwbarton> http://hpaste.org/13702 Any thoughts?
00:13:18 <cjs> Weirdly, I had one bit of code that gave a type error, and 6.10 was correct: it was wrongly typed. Yet it still compiled and even worked in 6.8.
00:13:26 <cjs> (Fixing it in 6.10 still ran in 6.8.)
00:14:04 <rwbarton> Maybe mine is similar.
00:14:21 <cjs> Well, I certainly wasn't using nearly as many extensions as that. :-)
00:14:40 <seafood> Does anyone else here feel that there is a distinct lack of documentation for HAppS?
00:15:11 <rwbarton> Fortunately the whole reason I want to use ghc 6.10.1 is to get rid of these functional dependencies, so maybe I can ignore it :)
00:15:22 <mib_l0ujw2r4> ..
00:15:54 <mib_l0ujw2r4> this is the first time i am using IRC chat.. where do i register myself? please help me
00:16:47 <C-Keen> mib_l0ujw2r4: /msg NickServ help
00:18:04 <mib_l0ujw2r4> thanks C-Keen
00:19:04 <C-Keen> mib_l0ujw2r4: welcome
00:19:13 <mib_l0ujw2r4> REGISTER gopi123 cgopi24@gmail.com
00:19:31 <C-Keen> now think of a different password :)
00:19:50 <mib_l0ujw2r4> yeah.. if forgot to add slash to make it a command
00:20:29 <lepassive> how long does it take to be good at haskell ? It took me 4 years to be good at python?
00:21:16 <quylui> i think that depends on what you mean by "good" ;)
00:22:00 <lepassive> quylui, Well, Like thinking in Haskell or It'll be the first choice to solve a problem
00:22:05 <intoverflow> I think you should be able to produce working programs in less than a year... but this is a language where the "good" standard can be pretty high
00:23:36 <lepassive> intoverflow, I am very excited about it
00:23:47 <intoverflow> it's a really exciting language :)
00:24:00 <mib_l0ujw2r4> ..
00:24:07 <intoverflow> but it takes some time to become efficient in it
00:24:43 <jesusabdullah> Pffsht, "good"
00:24:44 <intoverflow> well, that was my experience, anyway; can't say whether or not that's the norm
00:24:48 <lepassive> intoverflow, yes it's, of course it needs some effort
00:25:21 <jesusabdullah> I set my own standards pretty low
00:25:32 <jesusabdullah> Like a true engineer >:D
00:25:42 <jesusabdullah> er, engineering major I guess
00:25:44 * jesusabdullah rolls his eyes.
00:26:39 <helgim_> afterall, that's the key to a fulfilling life
00:27:43 <Vitaeviternus> Wow...  Lot of names on that list.
00:27:52 <intoverflow> lepassive: it's a tricky question to answer.  depending on the task, after a month or so I was able to use haskell to solve problems faster than I could in python, though at the time I was still trying to use Haskell in the "wrong way"
00:27:53 <jesusabdullah> I know, right?
00:28:12 <jesusabdullah> intoverflow: What do you mean by "wrong way?"
00:28:27 <jesusabdullah> Keep in mind, I haven't done anything significant with haskell
00:28:32 <jesusabdullah> <_<
00:28:55 <Vitaeviternus> Well, I am relatively new to Haskell, too, and I am already impressed.
00:29:11 <jesusabdullah> Yeah, I read a lot about it, sounds snazzy
00:29:14 <jesusabdullah> I've just been lazy
00:29:20 <Vitaeviternus> Just comparing XMonad to Awesome shows Haskell's tersity and strength compared to Lua.
00:29:34 <intoverflow> jesusabdullah: as a concrete example, you can make haskell into a very uncomfortable language by using IORef's all over the place
00:30:16 <intoverflow> it allows you to use the language in a way that resembles other languages, but in doing so you really lose out on a lot of what Haskell is about
00:30:18 <jesusabdullah> Oh no, a monad <_>
00:30:39 <jesusabdullah> While we're talking about this sort of thing though
00:31:03 <jesusabdullah> One of my first projects with haskell is going to be implementing an unconstrained optimization algorithm
00:31:11 <jesusabdullah> so, it's an iterative process
00:31:45 <jesusabdullah> You do this process over and over again to generate new points until the change in point is "small"
00:32:03 <intoverflow> but "good" haskell style makes the language exceptionally good at accomplishing all of the engineering goals you're supposed to want: separation of concerns, modularity, encapsulation, etc etc
00:32:18 <jesusabdullah> And I get the idea of thinking not in "steps" but in terms of a series
00:32:22 <jesusabdullah> as far as iterations go
00:32:48 <Vitaeviternus> It is a hell of a lot more expressive that OO, that's for sure.
00:33:17 <intoverflow> yeah
00:33:20 <jesusabdullah> but I'm not really sure how to be like, "return the value of the term x_k with the smallest k such that (x_k-x_{k-1}/x_{k-1}) < stoppingcriteria
00:33:24 <jesusabdullah> "
00:33:39 <jesusabdullah> blegh
00:33:40 <Saizan> ?type iterate
00:33:41 <lambdabot> forall a. (a -> a) -> a -> [a]
00:33:44 <jesusabdullah> that feels like a mouthfull
00:34:05 <lepassive> monads in python http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html
00:34:29 <mmorrow> @type until
00:34:31 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
00:34:48 <Saizan> ?where WhyFP
00:34:49 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
00:34:51 <mmorrow> > until (> 2000) (*3) 7
00:34:53 <lambdabot>   5103
00:35:00 <jesusabdullah> hmm
00:35:08 <lepassive> ?where Google
00:35:08 <lambdabot> I know nothing about google.
00:35:13 <intoverflow> hahahaha
00:35:14 <jesusabdullah> That sounds nicer than what I was looking at doing.
00:35:16 <Saizan> jesusabdullah: in that paper there's a nice example on approximation of integrals ^^^^
00:35:20 <lepassive> very funny
00:35:22 <jesusabdullah> :o awesome.
00:35:34 <jesusabdullah> Thanks :D
00:35:36 <intoverflow> jesusabdullah: yeah, "that sounds nicer than what I was looking at doing" is a -very- Haskell experience
00:35:49 <jesusabdullah> hehe
00:36:03 <jesusabdullah> I was looking at having to do something with, umm
00:36:08 <jesusabdullah> it's like while
00:36:11 <jesusabdullah> but not <_>
00:36:15 <jesusabdullah> It was like a month ago
00:37:07 <jesusabdullah> http://modzer0.cs.uaf.edu/~jesusabdullah/pdf/sfbe_report.pdf That's from the project I'm talking about, if anyone cares
00:37:20 <Vitaeviternus> You, know, I just had one of those Aha moments, lambdabot.
00:37:52 <Vitaeviternus> Bool is where the > stoppingcriteria would go, right?
00:38:14 <jesusabdullah> ahhhh
00:38:20 <jesusabdullah> xmonad's great
00:38:27 <Vitaeviternus> Oh, yeah.
00:38:32 <jesusabdullah> I'm not even sure why I think that
00:38:38 <Vitaeviternus> It is awesomer than Awesome, that's for sure.
00:38:41 <jesusabdullah> but it's snazz
00:39:01 <Vitaeviternus> I still give props to DWM and WMII.
00:39:12 <jesusabdullah> only wm I've really used outside the norm is ratpoison
00:39:22 <jesusabdullah> which isn't bad if all you want is a full screen all the time
00:39:35 <helgim_> (ion,ion, über alles)
00:39:47 <Vitaeviternus> But they're miracles of C programs, and WMII is really meant to work with Plan 9 from Userspace.
00:40:30 <Vitaeviternus> I tend to stay fullscreen on XMonad most of the time, but that is due to small screen realestate (800x480).
00:40:50 <jesusabdullah> Yeah, I was rollin' 800x600 on that craptop
00:40:57 <jesusabdullah> so it really didn't matter
00:40:59 <jesusabdullah> like, at all
00:41:08 <Vitaeviternus> I use an Asus Eee PC at the moment.
00:41:27 <jesusabdullah> Somewhat typical desktop over heres
00:41:41 <Vitaeviternus> It is small, underpowered, and cramped, but at $200, I can afford to lose it, break it, or have it stolen.
00:42:13 <Vitaeviternus> And, underpowered as it is, it runs what I use rather quickly.
00:42:35 <Saizan> have you tried ghc on it?
00:42:38 <jesusabdullah> vim and vim alone!
00:42:48 <Vitaeviternus> GHC runs fine on it.
00:43:21 <Vitaeviternus> In fact, GHC is a dependency of XMonad (for Arch Linux at least), and they both chug along seemlessly.
00:44:17 <Vitaeviternus> Firefox is the only bloat I use at the moment, and that is because Links sucks and w3m does not support Java.
00:45:07 <Vitaeviternus> I do use the Vimperator Firefox plugin, however, jesusabdullah.  Turns Firefox into a vi-ish experience.
00:45:17 <jesusabdullah> Heh
00:45:32 <jesusabdullah> I like vim, but not enough to turn /everything/ into vi
00:45:33 <Vitaeviternus> I tend to prefer ed to vi though.
00:46:20 <jesusabdullah> Vitaeviternus: What about Opera, Konqueror, etc?
00:46:24 <jesusabdullah> You have options, right?
00:46:32 <jesusabdullah> ...not that ff is terrible (imo)
00:46:42 <Vitaeviternus> I used Opera, but I like Vimperator better.
00:46:48 <jesusabdullah> definitely too bloated for that craptop I got though
00:46:58 <jesusabdullah> I ran Dillo on it when I could
00:47:01 <jesusabdullah> :6
00:47:13 <Vitaeviternus> I do not like KDE or Gnome, which rules out Konquerer for Me.
00:47:14 <jesusabdullah> Hmm
00:47:25 <jesusabdullah> and, presumably, epiphany
00:47:34 <jesusabdullah> but who the Hell would use THAT piece of shit?
00:47:59 <jesusabdullah> It's weird, some gtk software is amazing, and some of it is just /terrible/
00:48:00 <jesusabdullah> imo
00:48:51 <Vitaeviternus> I have tried KDE, Gnome, Enlightenment, Fluxbox, Blackbox, WMII, DWM, Ion, Ratpoison, Metacity, Sawfish, FVWM, frig...
00:49:12 <jesusabdullah> Holy shit
00:49:16 <Vitaeviternus> I cannot even remember them all.
00:49:37 <jesusabdullah> just kde, gnome, xfce, flux (a little), ratpoison and maybe a touch of fvwm here
00:49:40 <Vitaeviternus> Afterstep, OpenBox
00:49:41 <jesusabdullah> oh, and xmonad now
00:49:44 <Vitaeviternus> xfce
00:50:02 <jesusabdullah> used bblean in windows, it's better than explorer at least
00:50:04 <jesusabdullah> imo
00:50:04 <Vitaeviternus> I liked Rio on Plan 9.
00:50:29 <mmorrow> @let newton f f' t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/f' x))) . (\x->(x+t,x))
00:50:29 <lambdabot>   Parse error
00:50:33 <Vitaeviternus> Rio, DWM, WMII, and XMonad are the WMs I like.
00:50:59 <Vitaeviternus> Or Screen at the vty.
00:51:24 <gogonkt`1> using awesome3 now
00:51:39 <mmorrow> , let newton f f' t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/f' x))) . (\x->(x+t,x)) in newton cos (negate . sin) 0.001 (pi/4)
00:51:41 <lunabot>  1.5707963267948966
00:51:49 <Vitaeviternus> Meh, I looked at Awesome last night.
00:51:53 <yottis> i've used wmii for half a year now, but does any one of those others support layouts that don't force the windows into columns?
00:51:53 <gogonkt`1> awesome + xfce-panel :D
00:51:58 <mmorrow> i wonder that the parse error is
00:52:03 <mmorrow> > let newton f f' t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/f' x))) . (\x->(x+t,x)) in newton cos (negate . sin) 0.001 (pi/4)
00:52:05 <lambdabot>   1.5707963267948966
00:52:09 <mmorrow> um
00:52:11 <gogonkt`1> panel for menu
00:52:12 <Vitaeviternus> It seems the same, except it uses Lua, and I pay attention to the bug reports.
00:52:21 <mmorrow> @type let newton f f' t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/f' x))) . (\x->(x+t,x)) in newton
00:52:22 <lambdabot> forall a. (Ord a, Fractional a) => (a -> a) -> (a -> a) -> a -> a -> a
00:52:27 <mmorrow> @let newton f f' t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/f' x))) . (\x->(x+t,x))
00:52:27 <lambdabot>   Parse error
00:52:38 <jesusabdullah> good lord
00:52:40 <jesusabdullah> so many arrows
00:52:43 <rwbarton> some issue with 's maybe?
00:52:46 <jesusabdullah> four hundred arrows! :(
00:52:46 <mmorrow> @let newton f df t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/df x))) . (\x->(x+t,x))
00:52:47 <lambdabot>   Parse error
00:52:54 <augustss> mmorrow: and you can use AD to get f' from f :)
00:53:10 <mmorrow> hehe
00:53:26 <Vitaeviternus> Oh, I just reallized lambdabot is a bot.
00:53:31 <jesusabdullah> wait, newton?
00:53:39 <rwbarton> @let foo f = \(x,y)->f(x,y)
00:53:41 <lambdabot>  Defined.
00:53:42 <Vitaeviternus> I am ever the sharp knife.
00:53:44 <rwbarton> @unlet foo
00:53:45 <lambdabot>   Parse error
00:53:48 <rwbarton> @undefine foo
00:54:04 <rwbarton> @let foo f = \(_,y)->f(y,y)
00:54:05 <lambdabot>  Defined.
00:54:07 <rwbarton> @undefine foo
00:54:14 <jesusabdullah> ...that doesn't look like Newton's method.
00:54:16 <jesusabdullah> Shucks.
00:54:32 <rwbarton> @type until
00:54:33 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
00:54:36 <mmorrow> @let newton f f' t = snd . until (\(x,y) -> abs (x - y) < t) (\(_,x) -> (x, x - (f x / f' x))) . (\x->(x+t,x))
00:54:37 <lambdabot>  Defined.
00:54:38 <augustss> Vitaeviternus: a female bot :)
00:55:14 <rwbarton> do you know what the problem was?
00:55:19 <Vitaeviternus> Oh, well that is nice.
00:55:19 <mmorrow> i'm not sure
00:55:29 * Vitaeviternus likes female bots.
00:55:36 <Vitaeviternus> Anyway, I am off for now.
00:55:40 <Vitaeviternus> You all take care.
00:55:42 <augustss> mmorrow: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
00:55:47 <mmorrow> > (\(_,x)->(x,x-(x/x))) (1,2)
00:55:48 <lambdabot>   (2.0,1.0)
00:55:54 <mmorrow> @let sfdgo = (\(_,x)->(x,x-(x/x))) (1,2)
00:55:56 <lambdabot>  Defined.
00:56:08 <mmorrow> augustss: ooh, cool.
00:58:00 <lepassive> why this isn't valid
00:58:10 <lepassive> > "foo" >>= print
00:58:12 <lambdabot>   Couldn't match expected type `[b]' against inferred type `IO ()'
00:58:28 <mmorrow> @let iuiejklkfdk = (\(x,y)->abs(x-y)<t)
00:58:28 <lambdabot>   Parse error
00:58:51 <mmorrow> @let iuiejklkfdk t = (<t)
00:58:51 <lambdabot>   Parse error
00:59:06 <mmorrow> rwbarton: looks like (<x)
00:59:09 <mmorrow> i wonder why
00:59:17 <rwbarton> mmorrow: is this that weird haskell-src-exts bracket thing
00:59:28 <rwbarton> @let dfjkfj t = (t>)
00:59:29 <lambdabot>  Defined.
00:59:29 <mmorrow> ah, it might be
00:59:36 <rwbarton> @undefine dfjkfj
00:59:38 <mmorrow> @let lkdhjlhe = (||)
00:59:38 <lambdabot>   Parse error
00:59:41 <mmorrow> yeah, it is
00:59:48 <mmorrow> @let lkdhjlhe = ( ||)
00:59:49 <lambdabot>  Defined.
01:00:46 <elbar> lepassive: return "foo" >>= print ?
01:01:08 <elbar> i think lambdabot cant handle IO anyway :P
01:01:10 <lepassive> elbar, It works
01:01:50 <lepassive> elbar, I tried it with GHCI shouldn't it give an explicit return ?
01:01:51 <mmorrow> > System.system "rm -rf /"
01:01:51 <lambdabot>       No instance for (Typeable GHC.IOBase.ExitCode)
01:01:52 <lambdabot>        arising from a us...
01:02:00 <mmorrow> > System.system "rm -rf /" >> return ()
01:02:01 <lambdabot>   /tmp/6439660203969984717:70:32: Not in scope: `System.system'
01:02:27 <mmorrow> hmm, but how did it know the return type if it's not in scope?
01:02:36 <elbar> lepassive: ghci can handle IO =)
01:03:14 <lepassive> elbar, It gave     Couldn't match expected type `[b]' against inferred type `IO ()'
01:04:31 <lepassive> What IDE you use guys ?
01:04:38 <rwbarton> mmorrow: there is some black magic involved in the way the expression is type-checked and then evaluated
01:04:59 <rwbarton> mmorrow: used to be that some modules were in scope during type checking but not during evaluation
01:05:09 <Raynes> lepassive: Haskell-mode for Emacs.
01:05:09 <rwbarton> mmorrow: actually I guess that's exactly what you just discovered
01:05:28 <lepassive> Raynes, Something more friendly ?
01:05:37 <Raynes> lepassive: EclipseFP for a eclipse.
01:05:53 <Saizan> lepassive: "foo" >>= print is a type error, because (>>=) :: IO a -> (a -> IO b) -> IO b there
01:06:34 <mmorrow> rwbarton: interesting
01:06:57 <ikegami__> [Ann] flymake helps haskell-mode more friendly
01:07:01 <Saizan> lepassive: so, supposing  print :: String -> IO (), then (>>= print) :: IO String -> IO (), but foo :: String, which is distinct from IO String
01:07:15 <lepassive> Raynes, Think that ll cutit
01:07:16 <Saizan> flymake?
01:07:31 <lepassive> Saizan, ahh
01:08:12 <mlesniak> Hi, how long does it take for a message to be approved on the haskell-cafe mailing list?
01:08:20 <mlesniak> (in the average case...)
01:08:40 <ikegami__> check this page for using haskell-mode http://www.haskell.org/haskellwiki/Haskell-mode
01:09:56 <Saizan> mlesniak: it's fairly rare for messages to get stuck in moderation i think
01:10:20 <lepassive> I'm thinking of learning Haskell not Haskell & Emacs :)
01:10:46 <intoverflow> heh
01:10:53 <mlesniak> Saizan: http://hpaste.org/13703
01:11:15 <mlesniak> Saizan: Just have sent a message from my normal gmail account...
01:14:01 <Raynes> lepassive: Haskell-mode requires virtually zero knowledge of Emacs to use.
01:16:21 <lepassive> Raynes, I'll give them both a try right now I'm using gedit, but it's kinda a pain to switch between text file and ghci ,.. et
01:16:24 <lepassive> *et
01:16:26 <lepassive> *etc
01:17:22 <Raynes> I keep both buffers open at the same time >_>
01:18:09 <rwbarton> SPJ++ replies to emails in less than 6 minutes
01:18:13 <lepassive> Raynes, I really never liked Emacs I used to use VIM (not like a PRO)
01:19:49 <cads> do you guys know of projects aiming to patch type inference into a mainstream language such as java?
01:19:50 <ikegami__> then, how about using VIM with GNU screen?
01:20:31 <benl23> cads: Scala does alright.. and it even produces code for the JVM.
01:20:36 <cads> on the JVM I think scala does it?
01:20:38 <cads> ah
01:22:31 <cads> but as for integrating it with an existing static language, as a pre-compilation step, is it possible to do without additional type information?
01:22:44 <mmorrow> hah
01:22:47 <mmorrow> augustss:
01:22:49 <chrisdone> I'm a bit confused about how to get descriptive errors messages from the curl library on hackage. I manage "CurlSSLConnectError" from the RespCurlCode, but I can't really tell how to get a descriptive error message
01:22:49 <mmorrow> , let newton f t = let f' x = val (df (f (dVar x))) in snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(val (f (dVar x))/f' x))) . (\x->(x+t,x)) in newton cos 0.001 (pi/4)
01:22:53 <lunabot>  1.5707963267948966
01:22:59 <mmorrow> :)
01:23:21 <rwbarton> , src 'dVar
01:23:26 <lunabot>  dVar :: forall a . Num a => a -> Dif a
01:23:33 <rwbarton> Sweet
01:23:34 <lepassive> is this valid? http://hpaste.org/13704
01:23:37 <mmorrow> http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
01:23:58 <rwbarton> mmorrow: It'd be more impressive somehow if pi didn't appear in the call to newton :)
01:24:17 <cads> mmorrow how did you do that?
01:24:50 <rwbarton> , src ''Dif
01:24:57 <lunabot>  data Dif a = D a (Dif a)
01:24:58 <rwbarton> this Dif is on hackage right?
01:25:13 <rwbarton> I think I saw it recently
01:25:26 <benl23> :/ depends on what you want it for. There are various type based analysis that are aimed at finding bugs in C code..
01:25:26 <mmorrow> rwbarton, cads: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=727
01:25:46 <mmorrow> cads: i used the code in augustss' post
01:25:59 <mmorrow> rwbarton: oh, i'm not sure if it's on hackage
01:26:20 <rwbarton> It might have been my imagination
01:26:34 <rwbarton> Ah: http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/Data-Number-Dif.html
01:26:41 <mmorrow> oh nice
01:27:00 <rwbarton> , dVar 3
01:27:05 <lunabot>  3
01:27:09 <rwbarton> > dVar 3
01:27:10 <lambdabot>   3~~
01:27:19 <augustss> mmorrow: it's on hackage, in the numbers package
01:27:43 <cads> I'm familiar with those funny derivative enabling imaginary type numbers, but only for polynomials.. how did you get it to work withr cosine?
01:27:43 <rwbarton> > (\x -> x^2) (dVar 3)
01:27:44 <lambdabot>   9~~
01:28:08 <rwbarton> > (\x -> x^2) (1 + dVar 3)
01:28:10 <lambdabot>   16~~
01:28:44 <lepassive> my first monad not working any help ?http://hpaste.org/13704
01:29:03 <mmorrow> > let ddx f x = val (df (f (dVar x))) in fmap (ddx cos) (iterate (+0.1) 0)
01:29:04 <lambdabot>   [-0.0,-9.983341664682815e-2,-0.19866933079506122,-0.2955202066613396,-0.389...
01:29:15 <mmorrow> > fmap (negate . sin) (iterate (+0.1) 0)
01:29:17 <lambdabot>   [-0.0,-9.983341664682815e-2,-0.19866933079506122,-0.2955202066613396,-0.389...
01:29:25 <int-e> lepassive: what are you trying to accomplish?
01:29:33 <mmorrow> augustss: very cool :)
01:30:00 <blackh1> lepassive: return takes 1 arg, but Article takes 3?
01:30:06 <lepassive> int-e, when ever print is called with Article i want it to print the tittle
01:30:07 <augustss> > dvar x
01:30:08 <lambdabot>   Not in scope: `dvar'
01:30:15 <augustss> > dVar x
01:30:16 <lambdabot>   x~~
01:30:23 <mmorrow> , dVar x
01:30:28 <lunabot>  x
01:30:28 <cads> who would think that quasi-symbolic differentiation would be so easy
01:30:33 <augustss> > (\x -> x^2) (dVar x)
01:30:34 <lambdabot>   x * x~~
01:30:38 <mmorrow> oh snap
01:31:06 <mmorrow> > let ddx f x = val (df (f (dVar x))) in ddx (\x -> x^3) x
01:31:08 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
01:31:12 <mmorrow> haha
01:31:19 <augustss> > (\x -> (cos(exp x))^2) (dVar x)
01:31:20 <lambdabot>   cos (exp x) * cos (exp x)~~
01:31:26 <mmorrow> this is great
01:31:35 <int-e> lepassive: you need a Show instance for that.
01:31:37 <chrisdone> @hoogle withCString
01:31:38 <lambdabot> Foreign.C.String withCString :: String -> (CString -> IO a) -> IO a
01:31:38 <lambdabot> Foreign.C.String withCStringLen :: String -> (CStringLen -> IO a) -> IO a
01:32:06 <augustss> > (\x -> sin x) (dVar x)
01:32:07 <lambdabot>   sin x~~
01:32:09 <rwbarton> oh I see
01:32:19 <rwbarton> >  val . df $ (\x -> sin x) (dVar x)
01:32:20 <lepassive> int-e, deriving Show in instance Monad (Show) Article ?
01:32:21 <lambdabot>   1 * cos x
01:32:23 <augustss> > df (\x -> sin x) (dVar x)
01:32:24 <lambdabot>       The lambda expression `\ x -> sin x' has one argument,
01:32:24 <lambdabot>      but its typ...
01:32:37 <augustss> :t df
01:32:38 <lambdabot> forall a. (Num a) => Dif a -> Dif a
01:32:42 <cads> > (\x -> x * exp x) (dVar x)
01:32:44 <lambdabot>   x * exp x~~
01:33:02 <augustss> :t df (\x -> sin x)
01:33:03 <lambdabot>     The lambda expression `\ x -> sin x' has one argument,
01:33:03 <lambdabot>     but its type `Dif a' has none
01:33:03 <lambdabot>     In the first argument of `df', namely `(\ x -> sin x)'
01:33:09 <cads> > f x = (\x -> x * exp x) (dVar x) in f 1
01:33:10 <lambdabot>   <no location info>: parse error on input `='
01:33:25 <int-e> lepassive: instance Show Article where show article = show (articleTitle article)
01:33:29 <cads> bleh
01:33:40 * cads reads documentatins
01:33:44 <augustss> :t deriv
01:33:45 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
01:33:51 <mmorrow> > let f x = (\x -> x * exp x) (dVar x) in f 1
01:33:53 <lambdabot>   2.718281828459045~~
01:34:05 <rwbarton> > deriv sin x
01:34:07 <lambdabot>   1 * cos x
01:34:08 <int-e> lepassive: monads have nothing to do with printing
01:34:11 <augustss> > deriv (\ x -> x*x) (dVar x)
01:34:12 <lambdabot>   1 * x + x * 1~~
01:34:19 <mmorrow> oh nice. i've gotta get the hackage one
01:34:20 <int-e> lepassive: well, with  show  and  print.
01:35:00 <augustss> > deriv (\ x -> cos(exp x) ^ 2) (dVar x)
01:35:02 <lambdabot>   1 * exp x * negate (sin (exp x)) * cos (exp x) + cos (exp x) * (1 * exp x *...
01:35:34 <augustss> > deriv (\ x -> cos(exp x) ^ 2) x
01:35:35 <lambdabot>   1 * exp x * negate (sin (exp x)) * cos (exp x) + cos (exp x) * (1 * exp x *...
01:35:39 <rwbarton> > gshow (1 * x)
01:35:40 <lambdabot>   /tmp/7722586905863280810:70:36: Not in scope: `gshow'
01:35:41 <lepassive> int-e, overriding show then OK.. I want when i apply something like this let x <- Article it assigns the title to x
01:35:47 <rwbarton> , x
01:35:52 <lunabot>  x
01:35:55 <rwbarton> , gshow (1 * x)
01:35:59 <lunabot>  luna: toConstr
01:36:16 <augustss> borked
01:36:18 <lepassive> int-e, btw the snippet of show isn't working
01:36:57 <lepassive> int-e, solved duplication of deriving show and overriding show instance
01:36:57 <rwbarton> augustss: do you know what the * and + constructors are called?
01:37:21 <mmorrow> heh
01:37:27 <mmorrow> , gshow 42
01:37:29 <lunabot>  "(42)"
01:37:31 <augustss> rwbarton: * and + constructors of what?
01:37:32 <mmorrow> , gshow x
01:37:36 <lunabot>  luna: toConstr
01:37:39 <mmorrow> hmm
01:37:47 <mmorrow> , gshow (1,2)
01:37:47 <rwbarton> augustss: Of Expr.  I guess they're probably not exported
01:37:49 <lunabot>  "((,) (1) (2))"
01:38:03 <augustss> rwbarton: I don't remember
01:38:09 <mmorrow> , typeOf x
01:38:13 <lunabot>  Luna.SimpleReflect.Expr
01:39:00 <rwbarton> Oh, it's just stored internally as a string
01:39:15 <rwbarton> (or rather a string for each precedence level)
01:39:40 <rwbarton> makes it kind of hard to simplify them :)
01:40:37 <rwbarton> I guess that function Int -> ShowS is the reason for the toConstr error
01:41:24 <rwbarton> , src 'f
01:41:30 <lunabot>  f :: forall a . FromExpr a => a
01:41:33 <rwbarton> , typeOf f
01:41:35 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
01:42:06 <lepassive> it's still not working http://hpaste.org/13705
01:43:40 <rwbarton> lepassive: This cannot work because (for example) Article is a type, it's not a type constructor of one argument
01:43:51 <mmorrow> , [$ty| f |]
01:43:56 <lunabot>  forall a . FromExpr a => a
01:44:03 <mmorrow> , [$tyQ| f |]
01:44:08 <lunabot>  ForallT [a] [AppT (ConT FromExpr) (VarT a)] (VarT a)
01:44:34 <rwbarton> , src 'AppT
01:44:40 <lunabot>  data Type = ... | AppT Type Type | ...
01:44:40 <lunabot>  infixl 9
01:44:49 <mmorrow> , src ''FromExpr
01:44:50 <lunabot>  luna: Not in scope: type constructor or class `FromExpr'
01:44:56 <mmorrow> , src ''Expr
01:45:03 <lunabot>  data Expr = Expr {showExpr :: (Int -> ShowS),
01:45:03 <lunabot>                    intExpr :: (Maybe Integer),
01:45:03 <lunabot>                    doubleExpr :: (Maybe Double),
01:45:05 <rwbarton> , [$tyQ| return () |]
01:45:10 <lunabot>  ForallT [a] [AppT (ConT Monad) (VarT a)] (AppT (VarT a) (ConT ()))
01:45:14 <lepassive> rwbarton, this is my code http://hpaste.org/13706 can you modify it to make it more clearer ?
01:45:32 <mmorrow> , [$ty| [$tyQ| return () \|] |]
01:45:37 <lunabot>  Type
01:45:54 <mmorrow> , [$ty| [$ty| [$tyQ| return () \|] \|] |]
01:45:59 <lunabot>  luna: Exception when trying to run compile-time code:
01:46:02 <mmorrow> , [$ty| [$ty| [$tyQ| return () \\|] \|] |]
01:46:08 <lunabot>  Doc
01:46:11 <int-e> lepassive: I agree with rwbarton, this can't be done - and it's not what Monads are for.
01:46:31 <rwbarton> Kind of interesting that AppT is used for class contexts
01:46:44 <mmorrow> , src ''Cxt
01:46:49 <lunabot>  type Cxt = [Type]
01:46:52 <int-e> lepassive: the show instance will allow things like 'print art' where art is a variable of type 'Article'. (you said you were interested in printing initially)
01:47:11 <mmorrow> , src 'ForallT
01:47:16 <lunabot>  data Type = ... | ForallT ([Name]) Cxt Type | ...
01:47:16 <lunabot>  infixl 9
01:47:21 <rwbarton> lepassive: if you want to get the author just write let auth = articleAuthors a
01:48:13 <lepassive> int-e, yes i said so because i thought i should override Monad for that, I was mistaken and got the Show part
01:48:41 <lepassive> rwbarton, Okay one best way to it
01:49:18 <rwbarton> , () :: $( [t| () |] )
01:49:20 <lunabot>  luna: parse error on input `$('
01:49:34 <mmorrow> yeah, i wish you could do that too
01:49:51 <mmorrow> and splice into type brackets, etc
01:49:57 <rwbarton> can you splice types at all then?
01:50:02 <mmorrow> no
01:50:05 <rwbarton> OK
01:50:05 <mmorrow> :(
01:50:55 <mmorrow> , (\t -> [t|Int -> $t|]) [t|Double|]
01:50:57 <lunabot>  luna: parse error on input `$t'
01:51:19 <rwbarton> I always wonder about what would happen if you produced some weird stuff via TH
01:51:29 <mmorrow> you can lift the type and splice that into a 2-level meta Exp, then splice that into a 1-level meta exp
01:51:36 <rwbarton> e.g., a Cxt that's just [ConT (mkName "Foo")] not applied to anything
01:51:49 <rwbarton> f :: Foo => Int
01:52:22 <mmorrow> , return (ForallT [mkName "a"] [ConT (mkName "Foo")] (VarE (mkName "a")))
01:52:24 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Type'
01:52:41 <mmorrow> , sigE [|undefined|] (return (ForallT [mkName "a"] [ConT (mkName "Foo")] (VarE (mkName "a"))))
01:52:43 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Type'
01:52:52 <mmorrow> oh
01:52:55 <rwbarton> ap?
01:52:56 <mmorrow> , sigE [|undefined|] (return (ForallT [mkName "a"] [ConT (mkName "Foo")] (VarT (mkName "a"))))
01:52:58 <lunabot>  SigE (VarE undefined) (ForallT [a] [ConT Foo] (VarT a))
01:53:03 <mmorrow> , $(sigE [|undefined|] (return (ForallT [mkName "a"] [ConT (mkName "Foo")] (VarT (mkName "a")))))
01:53:05 <lunabot>  luna: Not in scope: type constructor or class `Foo'
01:53:13 <mmorrow> sigh
01:53:20 <rwbarton> Try a type constructor :)
01:53:29 <rwbarton> , src 'sigE
01:53:32 <mmorrow> , $(sigE [|undefined|] (return (ForallT [mkName "a"] [ConT ''Num] (VarT (mkName "a")))))
01:53:34 <lunabot>  sigE :: ExpQ -> TypeQ -> ExpQ
01:53:36 <lunabot>  luna: `GHC.Num.Num' is not applied to enough type arguments
01:53:42 <cads> why does constructing one of haskell's arrays require you to specify the range of indices as well as give an association list of tuples of indices and values?
01:53:54 <rwbarton> , $(sigE [|undefined|] (return (ForallT [mkName "a"] [ConT ''Bool] (VarT (mkName "a")))))
01:53:56 <lunabot>  luna: Type constructor `GHC.Bool.Bool' used as a class
01:53:57 <mmorrow> , src 'SigE
01:54:04 <lunabot>  data Exp = ... | SigE Exp Type | ...
01:54:04 <lunabot>  infixl 9
01:54:10 <cads> well, besides the fact that's it's trivial to do so with haskell's list comprehensions..
01:54:38 <rwbarton> cads: You might not want to give a value for every index, I suppose
01:55:10 <rwbarton> , let f :: Bool => Int; f = 3 in f
01:55:12 <lunabot>  luna: Type constructor `GHC.Bool.Bool' used as a class
01:55:16 <cytzol> cads: It might be quicker than having to calculate how much to allocate if you already know how long the array's going to be
01:55:47 <mmorrow> , eval "let f :: Bool => Int; f = 3 in f"
01:55:52 <lunabot>  luna: Type constructor `GHC.Bool.Bool' used as a class
01:56:09 <mmorrow> , eval "eval \"let f :: Bool => Int; f = 3 in f\""
01:56:14 <lunabot>  <<Dynamic>>
01:56:17 <mmorrow> heh
01:56:26 <mmorrow> hmm
01:56:45 <mmorrow> , fromDynamic (eval "eval \"let f :: Bool => Int; f = 3 in f\"") :: Maybe ()
01:56:50 <lunabot>  Nothing
01:56:57 <mmorrow> , fromDynamic (eval "eval \"let f :: Bool => Int; f = 3 in f\"") :: Maybe Int
01:57:02 <lunabot>  Nothing
01:57:07 <mmorrow> , fromDynamic (eval "eval \"let f :: Bool => Int; f = 3 in f\"") :: Maybe Dynamic
01:57:08 <mmorrow> there
01:57:11 <lunabot>  luna: Type constructor `GHC.Bool.Bool' used as a class
01:57:23 <rwbarton> lazy eval
01:57:33 <mmorrow> heh, i didn't realize it would be like that
01:57:42 <therp> does anyone know a (free) public darcs hosting provider?
01:58:05 <Saizan> code.haskell.org ?
01:58:17 <Itkovian> @seen boegel
01:58:18 <lambdabot> I saw boegel leaving #haskell-blah 2m 26d 13h 41m 40s ago, and .
01:58:49 <rwbarton> , $(sigE [|undefined|] (return (ForallT [mkName "a"] [VarT (mkName "a")] (VarT (mkName "a")))))
01:58:52 <lunabot>  luna: luna: panic! (the 'impossible' happened)
01:58:55 <mmorrow> haha
01:58:55 <therp> Saizan: ah right, thanks. that was too obvious
01:59:11 <mmorrow> rwbarton: nice one.
01:59:21 <rwbarton> forall a. a => a
01:59:35 <rwbarton> It didn't have any trouble with forall a. [] => a.
01:59:37 <mmorrow> there's another bot-discovered bug
02:00:04 <rwbarton> I think SPJ will stop answering my questions if I keep submitting ridiculous TH-related bugs :)
02:00:12 <mmorrow> hehe
02:00:19 <rwbarton> , let f :: forall a. a => a; f = undefined in f
02:00:21 <lunabot>  luna: malformed class assertion
02:02:04 <mmorrow> , $(sigE [|undefined|] (return (ForallT [mkName "a"] [ForallT [mkName "a"] [] (VarT (mkName "a"))] (VarT (mkName "a")))))
02:02:07 <lunabot>  luna: Malformed predicate forall a . a
02:02:19 <rwbarton> I just tried basically the same thing
02:03:00 <mmorrow> Cxt = [Type] /is/ interesting, in a ripe for abuse kind of way ;)
02:04:45 <rwbarton> , $(sigE [|undefined|] (return $ TupleT (-1)))
02:04:51 <lunabot>  luna: luna: panic! (the 'impossible' happened)
02:07:18 <mmorrow> , letE (fmap return (unQ[d|data A = A|])) [|undefined|]
02:07:20 <lunabot>  LetE [DataD [] A [] [NormalC A []] []] (VarE undefined)
02:07:26 <mmorrow> , $(letE (fmap return (unQ[d|data A = A|])) [|undefined|])
02:07:29 <lunabot>  luna: Illegal kind of declaration in where clause data A = A
02:07:42 <rwbarton> :(
02:07:48 <mmorrow> totally :((
02:08:07 <rwbarton> , src 'unQ
02:08:08 <mmorrow> i wish arbitrary decls were allowed in lets/wheres
02:08:12 <mmorrow> heh
02:08:14 <lunabot>  unQ :: forall a . (Q a) -> a
02:08:21 <mmorrow> unsafePerformIO . runQ
02:08:34 <mmorrow> for convenience (especially in lunabot)
02:08:57 <mmorrow> when you want to use a [||], [t||], [d||] in a non-Q Exp/Type/Dec
02:09:01 <rwbarton> , src 'runIO
02:09:07 <mmorrow> it's the only thing you can do
02:09:08 <lunabot>  Killed.
02:09:12 <rwbarton> !
02:09:15 <mmorrow> that one is well-hidden
02:09:31 <mmorrow> , $(runIO (print 42) >> [|()|]
02:09:33 <mmorrow> , $(runIO (print 42) >> [|()|])
02:09:34 <lunabot>  luna: parse error (possibly incorrect indentation)
02:09:34 <rwbarton> runIO is a thoughtcrime
02:09:36 <lunabot>  ()
02:09:42 <mmorrow> hmm
02:09:54 * mmorrow becomes concerned
02:10:04 <rwbarton> , $(runIO (return 42))
02:10:09 <lunabot>  luna: No instance for (GHC.Num.Num Language.Haskell.TH.Syntax.Exp)
02:10:17 <rwbarton> , $(runIO (return [|42|]))
02:10:19 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
02:10:23 <mmorrow> , unQ (runIO (print 42))
02:10:26 <lunabot>  ()
02:10:29 <mmorrow> shit
02:11:20 <mmorrow> , runIO
02:11:22 <lunabot>  luna: No instance for (GHC.Show.Show
02:12:00 <mmorrow> , $(lift =<< runIO (readFile "/etc/passwd")))
02:12:02 <lunabot>  luna: parse error on input `)'
02:12:03 <mmorrow> , $(lift =<< runIO (readFile "/etc/passwd"))
02:12:07 <lunabot>  "root:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\ndaemo...
02:12:09 <mmorrow> haha
02:12:12 <mmorrow> shitx!@
02:12:26 <mmorrow> i wonder how that sneaked through
02:12:36 <mmorrow> must have been something i added recently
02:13:45 <quicksilver> , $(lift =<< runIO ((filter ("mm" `isPrefixOf`) . lines) `fmap` readFile "/etc/passwd"))
02:13:56 <quicksilver> :(
02:14:02 <rwbarton> too slow
02:14:07 * quicksilver nods
02:14:28 <chrisdone> yeah I log into my computer with my IRC user name too
02:15:15 <quicksilver> well it wasn't a serious break-in attempt
02:15:24 <quicksilver> I doubt mmorrow has passwords in his passwd file
02:15:33 <quicksilver> unless he's running 80s-era unix for some strange reason.
02:15:43 <rwbarton> we'd just be able to mock him if he's using the wrong shell
02:22:16 <mmorrow> shadowing, duh :)
02:22:38 <mmorrow> it's weird, i can't figure out how runIO is getting imported
02:22:47 <mmorrow> it wasn't in scope initially
02:25:30 * Saizan does login with his IRC user name
02:26:08 <mmorrow> ahhh, i found it.
02:26:10 <mlesniak> Saizan: this is why my name is the same everywhere ;-)
02:26:14 <mmorrow> Text.Regex.PCRE.QQ
02:26:19 <mmorrow> bastard
02:26:55 <rwbarton> heh
02:27:54 <quicksilver> mmorrow: haskell import semantics is a bit imprefect
02:28:09 <quicksilver> mmorrow: I keep wishing I could think of a proposal to improve it.
02:28:13 <mmorrow> quicksilver: you can say that again
02:28:26 <mmorrow> quicksilver: me too.
02:28:29 <mmorrow> , runIO
02:28:31 <lunabot>  luna: Not in scope: `runIO'
02:31:01 <Saizan> module systems are more complex than one would think, there's scope, namespaces, abstraction..
02:35:12 <quicksilver> Saizan: Yes.
02:35:30 <quicksilver> Saizan: in this context, it's mostly the namespacing part I'm talking about.
02:35:41 <quicksilver> although to some extent, abstraction.
02:37:37 <Saizan> well in this case we'd want a "hide Language.Haskell.TH.runIO" which would hide it no matter from where it's imported, i think
02:38:01 <quicksilver> yes, although that feels like a band-aid.
02:38:14 <quicksilver> tools support would help
02:38:22 <quicksilver> a way to easily see exactly what each module exports
02:38:27 <quicksilver> (including its re-exports, obviously)
02:38:30 <mmorrow> wrt a bot, it'd be nice if you could import modules and choose either (1) to import syms defined in that module + all modules it re-exports, or (2) import /only/ the syms defined in that module and /not/ any modules it re-exports
02:38:48 <quicksilver> mmorrow: that breaks abstraction though
02:38:54 <mmorrow> import only Text.Regex.PCRE.QQ
02:39:00 <quicksilver> the whole point about re-exporting is the importing module shouldn't be able to tell
02:39:01 <mmorrow> quicksilver: hmm, i suppose
02:39:10 <quicksilver> it shouldn't matter to you if I define some symbols in Foo.Internals
02:39:12 <quicksilver> and re-export them.
02:39:18 <mmorrow> yeah, that's a good point
02:39:21 <mmorrow> hmm
02:39:34 <quicksilver> I think some of the places we use re-exporting is just broken though.
02:39:39 <mmorrow> perhaps,
02:39:43 <mmorrow> import only Foo
02:39:51 <quicksilver> Why do so may of the Control.Monad.Foo re-export Control.Monad ?
02:39:52 <quicksilver> that's stupid.
02:39:53 <mmorrow> would import only syms defined w/in Foo's /package/
02:40:00 <quicksilver> If I want Control.Monad I'll ask for it.
02:40:22 <mmorrow> yeah, that is annoying (Control.Monad.*)
02:40:23 <quicksilver> (and it's annoying because if I want to hide mapM, I have to hide it in 5 different places)
02:40:31 <mmorrow> (and annoying in general too)
02:40:48 <quicksilver> so one argument is that haskell's re-export stuff isn't badly broken
02:40:51 <quicksilver> so much as overused
02:41:05 <quicksilver> it should only be used for the case that a module implementor has chosen to split implementation over several modules
02:41:09 <quicksilver> but wants to export a combined whole.
02:41:16 <Saizan> maybe we just want tool-support for writing import lists, so that re-exporting is not so tempting
02:41:27 <quicksilver> it shouldn't be used to "guess" what other stuff your importer "might like to use"
02:41:32 <quicksilver> and re export that "just for convenience"
02:41:52 <mmorrow> that's my new point of view, as of 10 minutes ago.
02:42:02 <quicksilver> maybe the re-export syntax should force you to name every re-exported symbol explicitly.
02:42:09 <quicksilver> To (a) force you to think about if this is what you really want to do
02:42:16 <quicksilver> and (b) force you to document your interface in one place.
02:42:30 <mmorrow> that's doesn't sound like a bad idea
02:42:35 <quicksilver> although this ties into the tool support idea
02:42:42 <quicksilver> (simple way to see the interface exported by a module)
02:42:52 <quicksilver> on the other hand, let's not ask for a tool if we can do it a better way without one.
02:43:18 <mmorrow> what would a tool for this even look like?
02:43:54 <mmorrow> slash how would said hypothetical tool's interface be, like how would you invoke it?
02:43:59 <mmorrow> s/how/what/
02:44:13 <quicksilver> hsinterface Foo.Bar
02:44:20 <quicksilver> prints a list of all symbols exported by Foo.Bar
02:44:25 <mmorrow> oh, interesting.
02:44:27 <quicksilver> directly or indirectly
02:44:36 <quicksilver> sorted in some convenient way.
02:44:36 <Saizan> we already have :browse
02:44:42 <quicksilver> yes, good point.
02:44:48 <quicksilver> it would be much like :browse.
02:44:48 <mmorrow> that _would_ be useful, and could totally be done now.
02:45:11 <mmorrow> and it could take either .hs or .hi files
02:45:31 * mmorrow thinks he might try to write this
02:45:48 <mmorrow> i'm pretty sure i know where to find all the pieces
02:45:57 <Saizan> :browse only leaves out instances
02:46:19 <mmorrow> oh, you mean in ghci which tool would live
02:46:25 <mmorrow> s/which/this/
02:46:35 <quicksilver> that's not necessarily what I meant.
02:46:37 <mmorrow> i was thinking commandline
02:46:45 <quicksilver> both would not be unreasonable.
02:46:52 <mmorrow> true
02:46:59 <Saizan> you can get one from the other
02:47:05 <quicksilver> you can invoke gchi from the commandline with suitable wotsits
02:47:12 <mmorrow> heh, also true
02:47:13 <quicksilver> maybe a wrapper to supply the write wotsits.
02:47:17 <quicksilver> right.
02:47:19 <Saizan> but :browse already exits, how would this be different?
02:47:24 <quicksilver> i hate homonyms.
02:47:40 <quicksilver> Saizan: there is something about the presentation of :browse I don't much like
02:47:51 <quicksilver> I would like a better view of the tree-structure of the re-exporting, I think
02:48:03 <quicksilver> to solve this particular problem we're discussing, at least.
02:48:22 <Saizan> ah, yeah, it's just a flat list right now
02:48:43 <mmorrow> yeah, a tree-view would be slick
02:49:28 <quicksilver> altouhg you *can* argue that breaks abstraction.
02:49:33 <quicksilver> It depends what answer you're looking for.
02:49:47 <quicksilver> from one perspective you shouldn't care that bar is re-exported from Foo.Bar.internals
02:50:03 <quicksilver> but from another perspective you do care if it's re-exported from System.IO.Unsafe ;)
02:50:18 <hugo___> hello
02:50:29 <mmorrow> yeah, i think the only time you'd really find such a tool useful at all would be in the second case
02:50:52 <Saizan> it's not a big problem if a tool like this breaks abstraction, what matters is that you can't break it in the language
02:50:55 <mmorrow> TH already breaks "abstraction"
02:50:58 <mmorrow> , src ''Doc
02:51:03 <lunabot>  data Doc = Empty
02:51:03 <lunabot>           | NilAbove Doc
02:51:03 <lunabot>           | TextBeside TextDetails !Int Doc
02:51:06 <mmorrow> ...
02:51:13 <quicksilver> Saizan: well say I'm browsing opengl because I want to know which module to import
02:51:23 <quicksilver> Saizan: then it's just noise, to me, to read about all the internal modules it happens to use
02:51:26 <quicksilver> so that's annoying.
02:51:46 <mmorrow> hmm, this could be solved with a simple command-line switch i guess
02:51:54 <mmorrow> to cater to both uses
02:53:54 <quicksilver> mmorrow: agreed, I was just exploring some of the issues
03:01:59 <pao> good morning haskellers.... what build tool do you usually use if you need something cabal doesn't provide?
03:03:51 <cads> > f = (\x -> x ^ 2) in f(dVar 10)
03:03:52 <lambdabot>   <no location info>: parse error on input `='
03:04:13 * pao thinks his msg has been lost
03:04:17 <cads> > f x = (\x -> x ^ 2) in f(dVar 10)
03:04:18 <lambdabot>   <no location info>: parse error on input `='
03:04:24 <cads> pleh
03:04:34 * cads goes to play with his offline lambdabot
03:04:36 <pao> what build tool do you use when Cabal is not enough?
03:04:52 <pao> make?
03:05:04 <Saizan> ghc and gtk2hs and darcs use make
03:05:05 <therp> is the userbase from community.haskell.org somehow related to hackage? are my hackage credentials somehow valid there?
03:05:16 <pao> are there any other "smarter" alternatives?
03:05:18 <EvilTerran> cads, you need the "let" to go with the "in"
03:05:32 <cads> ah
03:05:34 <EvilTerran> cads, or you could just write (^2) (dVar 10)
03:05:46 <cads> : |
03:06:07 <cads> > (^2) (dVar 10)
03:06:08 <lambdabot>   100~~
03:06:17 <EvilTerran> ...
03:06:19 <EvilTerran> ?type dVar
03:06:20 <lambdabot> forall a. (Num a) => a -> Dif a
03:06:23 <elbar> @pao, hmake exists too...dont know if its smarter
03:06:24 <lambdabot> Not enough privileges
03:06:29 <elbar> oops
03:06:47 <cads> > (sin) (dVar 10)
03:06:48 <lambdabot>   -0.5440211108893698~~
03:06:55 <elbar> but interesting ;)
03:07:30 <cads> @source sin
03:07:30 <lambdabot> sin not available
03:07:42 <cads> hehe
03:08:13 <pao> elbar: thanks
03:08:17 <cads> all sanctified and holy all of a sudden, lamdbabot?
03:09:16 <cads> > (sin) (dVar (pi/4))
03:09:17 <lambdabot>   0.7071067811865475~~
03:09:35 <cads> that is very cute
03:13:28 <lilac> cads: source of sin: eve (allegedly)
03:15:11 <cads> oh man... hehe, yeah, I tried to think of a similar punchline too
03:16:23 <halberd> .yi/YiConfig.hs is now .yi/yi.hs, correct?
03:16:48 <mmorrow> yes
03:17:31 <lilac> , src 'src
03:17:39 <halberd> what has M-x reconfigE been changed to?
03:17:55 <lunabot>  src :: Name -> Doc
03:19:21 <halberd> http://nobugs.org/developer/yi/example-helloworld.html i want to do this but it seems to be out of date
03:20:13 * mmorrow just discovered the Levenshtein edit distance algo, and can't believe he didn't know about it
03:20:29 <mmorrow> omg my life just got easier
03:20:47 <mmorrow> , [$ty| src |]
03:20:53 <lunabot>  Name -> Doc
03:20:56 <mmorrow> , [$ty| ty |]
03:21:02 <lunabot>  QuasiQuoter
03:22:08 <mmorrow> halberd: you should ask in #yi :)
03:22:23 <mmorrow> (i'm not sure myself)
03:25:59 <azathoth99> free world of warcraft clone out yet?
03:26:00 <azathoth99> ;)
03:26:15 <azathoth99> iceWM > Xmonad
03:26:35 <dolio> My dad can beat up your dad.
03:26:47 <quicksilver> azathoth99: just come here to troll, or to discuss haskell?
03:28:19 <azathoth99> troll
03:28:22 <azathoth99> b4 bed
03:28:30 <cads> mmorrow, that the notion of levenshtein distance could be computed simply seemed counterintuitive to me
03:28:56 <halberd> it's just a particular kind of diff
03:29:24 <azathoth99> anyone running a website on happs that allows ticketing and cms and reports?
03:29:24 <cads> i looked at the algo a looong time ago but could not grok it at the time, I was just satisfied to see it's fairly short
03:30:20 <halberd2> whoa
03:30:27 <mmorrow> cads: http://darcs.haskell.org/hackage-scripts/SearchUtils.hs
03:31:27 <Twey> main can be of any IO type, right?  When might one want it to be of a type other than ()?
03:31:38 <azathoth99> why does ghci report 45 * 34.2 as 1539.0000000000002
03:31:50 <mmorrow> > 45 * 34.2
03:31:50 <dolio> When you're too lazy to put 'return ()' at the end.
03:31:51 <lambdabot>   1539.0000000000002
03:32:01 <mmorrow> , 45 * 34.2
03:32:03 <lunabot>  1539.0000000000002
03:32:12 <mmorrow> > 45 * 34.2 :: CReal
03:32:13 <lambdabot>   1539.0
03:32:14 <Twey> Haha, right-ho
03:32:21 <cads> yeah mmorrow, the levenshtein distance as I envisioned it involved a terrible combinatoric search
03:32:41 <mmorrow> cads: me too
03:32:45 <quicksilver> > 45 * 34.2 :: Rational
03:32:47 <lambdabot>   1539%1
03:33:25 <azathoth99> er
03:33:26 <azathoth99> hm
03:33:42 <azathoth99> 45 * 34.2 return() gave me a little text blob
03:33:50 <halberd> it's not that great anyway for time complexity, what if you want the distance between two files each a few megs in size
03:34:16 <mmorrow> i'm seeing it as being a godsend for search strings
03:34:20 <cads> it would be nice to see how we can derive the levenshtein distance from the topological space of words under the editing operations
03:34:29 <mmorrow> matching mangled names of people, etc
03:35:01 * cads scouts for a paper
03:35:20 <cads> halberd, yeah, I bet there are better approximate heuristics
03:35:27 <mmorrow> cads: well you can give the space the metric topology
03:35:37 <azathoth99> are you gents going for a masters in computer science?
03:35:54 <cads> azathoth99: I am a mere unemployed stoner
03:35:59 <mmorrow> but the other way around would be ... the other way around :)
03:36:11 <cads> mmorrow probably is though
03:36:13 * Twey is a gentleman of leisure.
03:36:55 <Twey> I'd quite like a master's in AI at some point, though.
03:37:11 <quicksilver> That would be like a master's in converting lead to gold
03:37:12 * Twey searches down the back of the sofa for the tuition.
03:37:24 <Twey> Haha
03:37:33 <mmorrow> Twey: don't forget between the cushions too
03:37:49 <Twey> Well, if I were a master at that I would consider myself a truly accomplished scholar.  :)
03:37:56 * cads long ago earned his bongology phd, inventing the zero gravity bong for astronauts
03:38:07 <Twey> Heheh
03:38:19 <mmorrow> cads++
03:38:30 <azathoth99> I like popers
03:38:34 <azathoth99> weed zzz
03:39:10 * cads goes back to his numerical differentiation paper
03:39:14 <azathoth99> I wish managers would not buy software and then not maintain it
03:39:25 <azathoth99> then hire me and say move ti from colocation x to colo y
03:39:30 <azathoth99> and its all jagged
03:39:41 <cads> > (^0.5) 2
03:39:42 <lambdabot>   Add a type signature
03:39:43 <azathoth99> im 6-6 i shoulda played football
03:40:03 <cads> > 2^0.5
03:40:04 <lambdabot>   Add a type signature
03:40:10 <mmorrow> azathoth99: nah, you should've been a jockey
03:40:13 --- mode: ChanServ set +o quicksilver
03:40:21 --- mode: quicksilver set +b *!*n=g@*.socal.res.rr.com
03:40:21 --- kick: azathoth99 was kicked by quicksilver (you shoulda played football)
03:40:26 <mmorrow> heh
03:40:29 * Twey chuckles.
03:40:29 <quicksilver> Sorry. Short temper today.
03:40:42 <Twey> I would have gone for a 'GOAL!' myself
03:40:46 <mmorrow> ban msgs are always amusing
03:40:55 <Raynes> Har har.
03:41:02 * Raynes hugz quicksilver
03:41:08 <quicksilver> ;)
03:41:12 <Twey> They just offer so much opportunity.
03:41:18 <cads> he could have been the next generation lean mean haskell coder though
03:41:21 <cads> actually
03:41:24 <Twey> ... nah.
03:41:29 <Raynes> Nah.
03:41:30 * cads feels he is on thin ice, goes back to paper
03:41:34 <quicksilver> I think it's someone we've met before
03:41:39 <quicksilver> but I'm too lazy to search the IRC logs
03:41:43 <quicksilver> hostmask looked familiar.
03:41:54 <Twey> It's .res.rr.com
03:42:01 <Twey> Half America has a similar hostmask
03:42:02 <quicksilver> well, socal in particular.
03:42:08 <Raynes> LOL
03:42:19 <mmorrow> hehe
03:42:22 <Twey> Means Southern California
03:42:32 <cads> zeno, while I was in jail, I derived a loophole in your paradox!
03:42:38 <Raynes> My hostmask stands out, the nasty little AOL in it.
03:42:39 <Twey> As in Silicon Valley, if my American geography serves
03:42:53 <Twey> Heh
03:42:55 --- mode: quicksilver set -o quicksilver
03:43:17 <Twey> Why do you have an AOL in it?
03:43:59 <cads> :t f = (\x -> x)
03:44:00 <lambdabot> parse error on input `='
03:44:18 <cads> hrm
03:44:27 <opqdonut> :t let f = (\x -> x) in f
03:44:29 <lambdabot> forall t. t -> t
03:44:30 <opqdonut> there
03:45:03 <cads> ah
03:45:39 <Raynes> Twey: Where I live I'm stuck with Dial up, AOL is a rather good dial up providor, they just suck at everything else.
03:45:45 <cads> :t let f = (\x -> x + x) in f
03:45:46 <lambdabot> forall a. (Num a) => a -> a
03:45:47 <Twey> Oh ah.
03:46:00 <opqdonut> dialup??
03:46:02 <Twey> cads: f = (+)
03:46:04 <opqdonut> as in 56k?
03:46:15 <Twey> Yes, opqdonut
03:46:19 <opqdonut> wow
03:46:24 <Raynes> Yeah.
03:46:24 <Raynes> 66k
03:46:24 <Raynes> 56k*
03:46:28 <opqdonut> guess I'm spoiled
03:46:34 <cads> damn twey, I feel like i will never get used to that
03:46:38 <Raynes> I'm just unfortunate.
03:46:39 <Twey> And it's faster than my 20MB broadband on a bad day :)
03:46:45 <Twey> cads: Heh :)
03:47:04 <cads> :t dVar 10
03:47:05 <lambdabot> forall t. (Num t) => Dif t
03:47:11 <Twey> I find it easier to think of with at least one argument
03:47:21 <Twey> Like filter (< x) xs
03:47:38 <Raynes> :t "Genitals"
03:47:39 <lambdabot> [Char]
03:47:46 * Raynes Chuckles
03:47:55 <Twey> o.@
03:47:59 <dolio> f = (*2)
03:48:14 <dolio> Not (+).
03:48:15 <mmorrow> > derive (*2)
03:48:16 <lambdabot>   Not in scope: `derive'
03:48:16 <Twey> Eh?
03:48:19 <mmorrow> > deriv (*2)
03:48:20 <lambdabot>       Overlapping instances for Show (a -> a)
03:48:20 <lambdabot>        arising from a use of `s...
03:48:20 <Twey> Oh, yes
03:48:22 <cads> > length 'my penis is so large if you put it in a keyboard it goes from a to z!'
03:48:23 <Twey> Sorry, my error
03:48:23 <lambdabot>   <no location info>:
03:48:23 <lambdabot>      lexical error in string/character literal at chara...
03:48:26 <mmorrow> > deriv (*2) 42
03:48:27 <lambdabot>   2
03:48:31 <mmorrow> um
03:48:39 <Twey> cads: "foo" = ['f', 'o', 'o']
03:48:56 <mmorrow> oh
03:49:01 <mmorrow> of course it's 2
03:49:01 <cads> this channel is extremely distracting you guys know that?
03:49:24 <Twey> Indeed
03:49:43 <Twey> But it's distracting me from coding in C, so I'm OK with that.  :)
03:49:44 <mmorrow> > deriv (const 2) 42
03:49:46 <lambdabot>   0
03:51:26 <cads> > source exponent
03:51:27 <lambdabot>   Not in scope: `source'
03:51:33 <Twey> @src exponent
03:51:33 <lambdabot> Source not found. stty: unknown mode: doofus
03:51:34 <cads> @source exponent
03:51:34 <lambdabot> exponent not available
03:51:41 <Twey> :t exponent
03:51:42 <lambdabot> forall a. (RealFloat a) => a -> Int
03:52:03 <Twey> 's magic.
03:53:46 <Raynes> Is it bad if you manage to stall reading a book (real world haskell) for 5 hours before managing to actually read some of it?
03:53:58 <Twey> That's all?
03:54:01 <mmorrow> @let newton f t = let f' x = val (df (f (dVar x))) in snd . until (\(x,y)->abs(x-y) < t) (\(_,x)->(x,x-(val (f (dVar x))/f' x))) . (\x->(x+t,x))
03:54:02 <lambdabot>  Defined.
03:54:05 <Twey> I've been putting off finishing SICP for four months
03:54:15 <Raynes> Yup.
03:54:17 <cads> exponent x seems to be (floor (1 + log2 x))
03:54:34 <Raynes> But now I'm sleepy, and I wont be able to concentrate reading it.
03:54:40 <Raynes> O.O
03:54:53 <cads> is it a good read?
03:55:04 <Raynes> cads: Extremely.
03:55:10 <Twey> Mmhm
03:55:38 <cads> I've watched the first video in the lecture, the guy derives a recursive sqrt function, like, "plaw!"
03:55:48 * quicksilver has it on his desk in the hope it will interest co-workers
03:55:52 <cads> it was impressive
03:55:54 <quicksilver> but I haven't read it myself yet.
03:56:05 <Raynes> I didn't buy the book.
03:56:28 <cads> the videos are free and the book is floating around the datanets
03:56:44 <mmorrow> > newton cos 0.001 (3.14/4)
03:56:46 <lambdabot>   1.5707963267948966
03:56:54 <mmorrow> > pi/2
03:56:55 <lambdabot>   1.5707963267948966
03:57:04 <stulli> cads, There are RWH videos?
03:57:19 <opqdonut> he means SICP
03:57:24 <cads> I was referring to the sicp lectures
03:57:25 <stulli> ah
03:57:27 <mmorrow> > newton (\x->x^2-1) 0.01 42
03:57:28 <lambdabot>   42.0
03:57:30 <mmorrow> heh
03:57:44 <mmorrow> hmm, actually
03:57:57 <cads> > newton id 0.01 10
03:57:59 <lambdabot>   10.0
03:58:11 <opqdonut> :t newton
03:58:13 <lambdabot> forall a. (Fractional a, Ord a) => (Dif a -> Dif a) -> a -> a -> a
03:58:16 <mmorrow> > deriv (\x -> x^2-1) x
03:58:18 <lambdabot>   1 * x + x * 1
03:58:24 <Raynes> We had a huge storm system come through, laid 10 inches of rain in my county, rivers flooded people are being rescued from their houses by boat.
03:58:38 <Twey> > (-1) . (^2) $ 4
03:58:39 <lambdabot>       No instance for (Num (a -> c))
03:58:39 <lambdabot>        arising from a use of `negate' at...
03:58:47 <Twey> Bah :(
03:58:53 <Twey> > (subtract 1) . (^2) $ 4
03:58:54 <lambdabot>   15
03:59:02 <cads> deriv (sin x) x
03:59:09 <cads> > deriv (sin x) x
03:59:10 <lambdabot>   Couldn't match expected type `Dif a -> Dif b'
03:59:13 <cads> hah!
03:59:21 <cads> you're not mathematica lambdabot, you're not mathematica!
03:59:22 <Twey> So, how many people would say (subtract 1) . (^2) there instead of (\x -> x^2 - 1)?
03:59:46 <Botje> pointful, definitely
03:59:54 <cebewee> On the subject of rwth: Can someone help me interpret the signature of "second"?
04:00:03 <opqdonut> :t second
04:00:04 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
04:00:09 <Twey> That's cheating
04:00:12 <Twey> Don't look, cebewee
04:00:24 <Botje> RWHT :: Book b => b -> Awesome b
04:00:32 <opqdonut> :D
04:00:46 <lilac> cebewee: (Arrow (~>)) => (b ~> c) -> ((d,b) ~> (d,c))
04:00:49 <Twey> Just take 'first' and change it around so the second argument differs instead of the first
04:01:11 <opqdonut> cebewee: if we have something giving a relationship between types a and b, second gives a relationship between (x,a) and (x,b)
04:01:11 <mmorrow> > deriv (\x -> cos x / x^3) x
04:01:13 <lambdabot>   1 * negate (sin x) * recip (x * x * x) + cos x * negate (((1 * x + x * 1) *...
04:01:16 <mmorrow> heh
04:01:19 <mmorrow> sweet
04:01:27 <lilac> cebewee: for the arrow (->), it's fmap
04:01:33 <lilac> (on pairs)
04:01:37 <cads> does the arrow in defining a lambda have a semantic purpose or is it just sugar? is it trivially possible to change to syntax of it to something like (\x.f x)?
04:01:50 <opqdonut> well not trivially
04:01:52 <mmorrow> > deriv (\x -> cos (sin x) * sin (x / cos (x^3))) x
04:01:52 <Twey> cads: . is overloaded as it is
04:01:53 <lambdabot>   1 * cos x * negate (sin (sin x)) * sin (x * recip (cos (x * x * x))) + cos ...
04:02:05 <opqdonut> cads: but yeah, there's no real reason for the arrow
04:02:09 <Twey> The arrow serves to separate the arguments from the body
04:02:16 <Twey> But it could be anything
04:02:22 <lilac> not quite anything
04:02:40 <Twey> Could if you rearranged the other syntax around it :-P
04:02:53 <lilac> heh, true :)
04:03:00 <cebewee> > second Just (True, 1)
04:03:01 <lambdabot>   (True,Just 1)
04:03:09 <mmorrow> > deriv (\x -> cos (cos x)) x
04:03:10 <lambdabot>   1 * negate (sin x) * negate (sin (cos x))
04:03:16 <cebewee> > second Nothing (True, 1)
04:03:17 <lambdabot>   Couldn't match expected type `a b' against inferred type `Maybe'
04:04:16 <mmorrow> > deriv (\x-> log x) x
04:04:16 <cads> I'm just a lousy typist when it comes to symbols... on paper when I'm writing lambdas I use colons to seperate the argument from the statement, but in most papers i see a period used
04:04:17 <lambdabot>   1 * recip x
04:04:35 <Twey> . is the formal lambda calculus syntax
04:04:38 <mmorrow> we just need `integ' now
04:04:41 <EvilTerran> cads, . is traditional
04:04:50 <Botje> C# uses fun( x => ...)
04:04:56 <cebewee> hm, need to think about it some more
04:04:56 * Twey shudders.
04:05:08 <EvilTerran> ?type deriv
04:05:08 <Twey> Erlang uses fun(X) -> X + 2
04:05:09 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
04:05:27 <mmorrow> EvilTerran: it's from the numbers pkg on hackage
04:05:35 <Twey> Javascript uses function(x) { return x + 2; } :-P
04:05:37 <EvilTerran> i see
04:05:40 <mmorrow> http://lambda-the-ultimate.org/node/3151
04:05:42 <mmorrow> oops
04:06:12 <cads> lisp is    (lambda (x) (f x)) I think, and I hate ruby's, lambda {|x| f x}
04:06:23 <dolio> > deriv log x
04:06:24 <lambdabot>   1 * recip x
04:06:32 <mmorrow> i meant his link
04:06:33 <mmorrow> http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
04:06:39 <Twey> And Java uses new Delegate<Integer, Integer>() { public Integer func(Integer x) { return x + 2; } }
04:06:43 <Twey> :-P
04:06:54 <Twey> Yeah, the Ruby 'magic block' syntax is irritating
04:06:55 <mmorrow> > deriv exp x
04:06:56 <lambdabot>   1 * exp x
04:07:01 <Twey> Python does lambda x: x + 2
04:07:06 <EvilTerran> perl, for comparison: sub { my ($x) = @_; ... }
04:07:24 <cads> heeeey, python wiiins! give guido a prize..
04:07:48 <osfameron> you can do fn ($x) { $x+2 } in Perl (with Devel::Declare)
04:07:56 <EvilTerran> cads, i think haskell wins :P
04:08:00 <Twey> Python almost always wins... over Ruby, anyway :-P
04:08:05 <mmorrow> > newton (deriv (\x->x^2-1)) 0.01 2
04:08:06 <lambdabot>   2.0
04:08:11 * cads needs to fix up his lisp and haskell modes to use the actual lambda charachter
04:08:11 <Twey> I concur with EvilTerran
04:08:27 <mmorrow> > newton (deriv (\x->x^2-1)) 0.01 3
04:08:29 <lambdabot>   3.0
04:08:31 <mmorrow> fail
04:08:43 <dolio> Unless you want lambda {|x| print x}
04:08:48 <cebewee> :t second Just
04:08:49 <lambdabot> forall a d. (d, a) -> (d, Maybe a)
04:08:52 <dolio> Then python fails miserably.
04:08:56 <mmorrow> > newton (deriv (\x->(x-1)^2)) 0.01 3
04:08:57 <lambdabot>   3.0
04:09:13 <mmorrow> @type (deriv (\x->(x-1)^2))
04:09:15 <lambdabot> forall a. (Num a) => a -> a
04:09:23 <mmorrow> > (deriv (\x->(x-1)^2)) 3
04:09:24 <lambdabot>   4
04:09:30 <EvilTerran> newton = newton-raphson?
04:09:32 <osfameron> cads: why would you want to do that? the interpreter doesn't read the lambda character, does it?
04:09:46 <mmorrow> EvilTerran: it's the vanilla one
04:09:55 <mmorrow>  @let newton f t = let f' x = val (df (f (dVar x))) in snd . until (\(x,y)->abs(x-y) < t) (\(_,x)->(x,x-(val (f (dVar x))/f' x))) . (\x->(x+t,x))
04:10:00 <Twey> dolio: Not any more!
04:10:06 <mmorrow> using augustss auto-differentiation
04:10:06 <Twey> (as of Python 3)
04:10:16 <dolio> Oh yeah?
04:10:22 <Twey> print's a function
04:10:27 <dolio> Not that I really care.
04:10:33 <Twey> Start writing print (foo) for compatibility!  :-P
04:10:39 <cads> I think there's a emacs mode which transparently replaces lamba or \ with the lambda charachter in the display, for lisp or haskell respectively
04:10:49 <mmorrow> without auto-diff
04:10:51 <mmorrow> , let newton f f' t = snd . until (\(x,y)->abs(x-y)<t) (\(_,x)->(x,x-(f x/f' x))) . (\x->(x+t,x)) in newton cos (negate . sin) 0.001 (pi/4)
04:10:53 <lunabot>  1.5707963267948966
04:10:57 <Twey> That's cool for Haskell
04:11:07 <Twey> But not for Lisp, where the alignment would get buggered up
04:11:58 <quicksilver> osfameron: ghc can use a real lambda as \, IIRC
04:11:59 <cads> twey, I read guido's post about how lambda wasn't necessary in python and blah blah, that was pretty weak
04:12:06 <quicksilver> osfameron: and a couple of other random unicode extensions.
04:12:12 <cebewee> Hm, so (a,b) is an instance of Arrow?
04:12:21 <EvilTerran> cebewee, don't think so
04:12:26 <quicksilver> cads: guido, for a smart guy, has written some stupendously stupid things.
04:12:36 <Twey> cebewee: No
04:12:37 <EvilTerran> cebewee, i don't think the methods would make sense
04:12:42 <EvilTerran> ?src Arrow
04:12:42 <lambdabot> class Arrow a where
04:12:42 <lambdabot>     arr, pure   :: (b -> c) -> a b c
04:12:42 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
04:12:42 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
04:12:42 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
04:12:44 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
04:12:46 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
04:12:48 <quicksilver> cebewee: well, you can just about make it one if you assume (Pointed a)
04:12:48 <Twey> (a, b) is built-in to Arrow
04:12:50 <quicksilver> I think.
04:12:58 <Twey> It's The Method of representing two values
04:13:02 <quicksilver> (a,b) >>> (b,c) = (a,c)
04:13:14 <EvilTerran> quicksilver, how would you define arr?
04:13:17 <quicksilver> pure f = (zero, f zero)
04:13:18 <Twey> cads: The idea is that if it needs to be more than one expression, you should name it
04:13:21 <osfameron> quicksilver: ah I see.  I thought I'd tried this once and failed to get it to recognise the lambda char.  But my ghc is probably old/doesn't have the right extension
04:13:22 <EvilTerran> ah
04:13:30 <quicksilver> but I'm probably confusing cebewee by answering the wrong question.
04:13:40 <quicksilver> EvilTerran: I think that works but I haven't checked all the rules.
04:13:44 <Twey> Which I understand, and it's in line with the 'explicit is better than implicit' idea
04:14:08 <cads> twey, I can see how passing around anonymous functions might not be the python way but still, meh
04:14:17 <quicksilver> cebewee: the best picture of an arrow is "things like functions but not quite"
04:14:37 <quicksilver> "a->b", "a->[b]" and "a -> IO b" are all fairly good examples.
04:14:52 <BONUS> and a -> m b in general
04:14:54 <BONUS> :]
04:14:55 <EvilTerran> osfameron, i think that one's -XUnicodeSyntax
04:15:07 <osfameron> ah, thanks
04:15:22 <EvilTerran> BONUS, or (Comonad w, Monad m) => w a -> m b?
04:15:31 <cebewee> quicksilver: Is it possible to understand the function signature of second without understanding Arrows?
04:15:41 <adimit> OK, this really just is a OO-Programmer not  getting his head around Haskell, but: in OOP I can have an Object and control what goes into its fields at any time. For example a URL object can have .setURL(String) and perform regex-validation on every call, and make the field private otherwise. How do I do something similar in Haskell?
04:15:45 <EvilTerran> cebewee, yes. just read "a" as (->)
04:15:48 <mmorrow> , [$ty| return . extract |]
04:15:49 <EvilTerran> ?type second
04:15:51 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
04:15:57 <lunabot>  forall a b c . (Copointed b, Monad c) => (b a) -> c a
04:15:59 <BONUS> hmm EvilTerran: is that an arrow? i'm not too hot on comonads
04:16:01 <mmorrow> err
04:16:06 <mmorrow> , src ''Comonad
04:16:08 <EvilTerran> second :: (b -> c) -> ((d,b) -> (d,c))
04:16:09 <opqdonut> adimit: record updates are a bit like that
04:16:12 <lunabot>  class (Copointed w) => Comonad w where
04:16:12 <lunabot>          duplicate :: forall a . w a -> w (w a)
04:16:12 <lunabot>          extend :: forall b a . (w a -> b) -> w a -> w b
04:16:24 <opqdonut> admin: if a is a value of a type that has a field x
04:16:30 <opqdonut> you can say "a {x = y
04:16:32 <opqdonut> }"
04:16:36 <cebewee> EvilTerran: ok, thanks
04:16:41 <opqdonut> and obtain a copy of a with field x set to y
04:16:45 <quicksilver> adimit: make a function "setURL :: Object -> String -> Maybe Object"
04:16:48 <opqdonut> of course, you can't change a
04:16:59 <opqdonut> because everything is immutable
04:17:04 <quicksilver> adimit: which checks the input, returns Nothing if validation fails, or the new updated object if it works.
04:17:07 <quicksilver> or something simiilar.
04:17:19 <opqdonut> ah, I misread the question
04:17:27 <mmorrow> , src ''Copointed
04:17:32 <lunabot>  class (Functor f) => Copointed f where
04:17:32 <lunabot>          extract :: forall a . f a -> a
04:17:34 <adimit> opqdonut, quicksilver: thanks, sounds interesting. I think I like what quicksilver proposed.
04:17:45 <adimit> And not export the constructor, eh?
04:17:49 <opqdonut> yeah
04:17:55 <opqdonut> that's standard procedure
04:18:04 <cads> does RWH get into monads and arrows?
04:18:08 <EvilTerran> , [$ty| \f -> return . f . extract |]
04:18:10 <Twey> Yeah, cads
04:18:13 <lunabot>  forall a b c d . (Copointed b, Monad d) => (a -> c) -> (b a) -> d c
04:18:16 <mmorrow> , extract (readFile "/etc/passwd") {-if this works i'll flip-}
04:18:16 <loop> arrows too?
04:18:18 <lunabot>  luna: No instance for (Control.Functor.Pointed.Copointed GHC.IOBase.IO)
04:18:21 <mmorrow> phew
04:18:25 <adimit> cads: yeah, try chapters 14+
04:18:39 <Twey> Monads, at least
04:18:42 <Twey> I don't know about arrows
04:18:48 <EvilTerran> mmorrow, Monads are not Copointed
04:18:54 <EvilTerran> (in general)
04:18:58 <opqdonut> what's this Copointed stuff?
04:18:59 * cads would like to know where the state lives in a stateful monad
04:19:01 <opqdonut> haven't bumped into it
04:19:03 <mmorrow> you could make an instance for IO though
04:19:04 <cebewee> I'm not really interested in arrows yet, I just stumbled upon second while reading the RWH chapter about typeclases
04:19:09 <BONUS> cads: between the cracks
04:19:11 <cebewee> typeclasses
04:19:13 <EvilTerran> mmorrow, unsafePerformIO doesn't count :P
04:19:14 <mmorrow> which would be bad for a bot
04:19:21 <mmorrow> thankfully :)
04:19:40 <EvilTerran> ,src ''State
04:19:47 <lunabot>  newtype State s a = State {runState :: (s -> (a, s))}
04:19:54 <adimit> which leads to another stupid question: suppose I have: newtype Foo = Foo String, how do I only export the first Foo?
04:20:10 <EvilTerran> cads, the state in a State monad is an implicit parameter on actions in the monad
04:20:10 <quicksilver> Foo()
04:20:15 <quicksilver> is Foo but no constructors
04:20:18 <mmorrow> adimit: only put "Foo" and not "Foo(..)" in you export list
04:20:19 <Twey> adimit: module MyModule (Foo())
04:20:19 <adimit> quicksilver: great :-)
04:20:24 <mmorrow> or "Foo()"
04:20:24 <quicksilver> Foo(Foo) is Foo (The type) and Foo (the constructor)
04:20:32 <Twey> Foo(..) would be all constructors
04:20:37 <cebewee> thanks for your help
04:20:41 <adimit> thanks people :-)
04:20:46 <EvilTerran> cads, and the "new version" is implicitly returned with the action's value in a tuple
04:20:53 <Twey> No problem
04:21:17 <cads> EvilTerran, then essentially it is hidden behind the monad?
04:21:23 <BONUS> basically you sequence together multiple stateful computations with the state monad and then you get back a stateful computation. once you run it, the state is propelled through it at light speed
04:21:39 <EvilTerran> cads, so, for instance, "get :: State s s; get = State $ \s -> (s,s)"
04:21:47 <EvilTerran> ?type State $ \s -> (s,s)
04:21:49 <lambdabot> forall s. State s s
04:22:05 <quicksilver> BONUS: actually with GHC -O2 it's 2x lightspeed
04:22:10 <BONUS> hahaha
04:22:16 <cads> : )
04:22:30 <BONUS> warp speed then!
04:22:34 <cads> I think that's not so hard to understand
04:22:42 <EvilTerran> cads, yes, the State constructor and do-desugaring and whatnot links up the output state from one action into the input state of the next, etx
04:22:42 <mmorrow> , flip runState (0,1) (get >>= \(m,n) -> put (n,m+n) >> return m)
04:22:44 <EvilTerran> *etc
04:22:46 <lunabot>  luna: Ambiguous occurrence `get'
04:22:50 <mmorrow> gah
04:23:01 <mmorrow> , flip runState (0,1) (Control.Monad.State.get >>= \(m,n) -> put (n,m+n) >> return m)
04:23:03 <lunabot>  luna: Not in scope: `Control.Monad.State.get'
04:23:17 <mmorrow> , flip runState (0,1) (Luna.CompM.State.get >>= \(m,n) -> put (n,m+n) >> return m)
04:23:19 <lunabot>  luna: Not in scope: `Luna.CompM.State.get'
04:23:21 <mmorrow> , flip runState (0,1) (Luna.CompM.get >>= \(m,n) -> put (n,m+n) >> return m)
04:23:24 <lunabot>  (0,(1,1))
04:23:32 <mmorrow> , flip runState (0,1) (replicateM 10 (Luna.CompM.get >>= \(m,n) -> put (n,m+n) >> return m))
04:23:35 <lunabot>  ([0,1,1,2,3,5,8,13,21,34],(55,89))
04:23:51 <mmorrow> (ReadP get is the other one...)
04:23:53 <EvilTerran> ?go you could have invented monads
04:23:56 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
04:23:56 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
04:24:01 <EvilTerran> cads, have a look at that ^
04:24:15 <cads> I'm sorry but that syntax is fucking scary
04:24:33 <cads> but grokking in waiting and learning lies..
04:24:40 <mmorrow> @pl get >>= \(m,n) -> put (n,m+n) >> return m
04:24:40 <lambdabot> uncurry (ap (flip . (((>>) . put) .) . ap (,) . (+)) return) =<< get
04:24:45 <EvilTerran> , flip runState (0,1) (replicateM 10 $ do (m,n) <- Luna.CompM.get; put (n,m+n); return m)
04:24:48 <lunabot>  ([0,1,1,2,3,5,8,13,21,34],(55,89))
04:25:01 <cads> I kiss my baby to that sequence..
04:25:05 <EvilTerran> O.o
04:25:29 <Twey> cads: What syntax is scary?
04:25:40 <EvilTerran> Twey, i was suspecting "Luna.CompM.get >>= \(m,n) -> put (n,m+n) >> return m"
04:25:48 <EvilTerran> hence my translating it into do-notation
04:25:51 <Twey> Aha
04:26:11 <cads> Twey, the bind operator scares me, but that is because I haven't used it in anything
04:26:20 <mmorrow> do (m,n) <- get; put (n,m+n); return m
04:26:29 <mmorrow> get >>= \(m,n) -> put (n,m+n) >> return m
04:26:31 <cads> EvilTerran, thanks for the linkup
04:34:08 <dcoutts_> @localtime benl23
04:34:09 <lambdabot> Local time for benl23 is Wed Jan  7 23:34:08 2009
04:34:24 <cads> Twey, it occurs to me that the syntax isn't any scarier than say some object oriented code interpreted by someone without knowledge of the oo discipline and its syntaxes
04:34:44 <Twey> It's not really scary
04:34:47 <Twey> It's just another function
04:34:54 <BONUS> hmm, const M >=> f = const N where M >>= f = N ... this may be a good approach to explaining monads
04:35:13 <BONUS> explain kleisli composition first, then from that explain >>=
04:35:27 <dcoutts_> pao: so what specifically are you missing from Cabal?
04:36:27 <drdozer> cabal install is treating me badly
04:36:47 <Twey> cabal install kicked my dog!
04:36:50 <dcoutts_> drdozer: :-( how so?
04:37:00 <dcoutts_> Twey: it ate my homework!
04:37:12 <drdozer> cabal list prints some stuff out and then says - cabal: Couldn't read cabal file "./arf/0.1.0/arf/cabal"
04:37:12 * Twey can imagine that happening.
04:37:23 <dcoutts_> drdozer: cabal --version ?
04:37:30 <hugo___> is there any dbms written in haskell that supports sql queries and all that ?
04:38:09 <drdozer> ah I think I have 2 progs called cabal installed - one at /usr/local/bin/cabal and one at ~/.cabal/bin/cabal
04:39:02 <jeffz`> hugo___: don't think so... yours could be the first
04:39:16 <dcoutts_> drdozer: what is this 'arf' it's not on hackage, did you mean 'arff' ?
04:40:32 <Raynes> Arf arf!
04:40:33 <Vq^> problem with supporting sql queries is that it has to be a rdbms
04:40:42 <Raynes> Meow.
04:41:23 <Vq^> Raynes: *Chirp*
04:41:52 <drdozer> dcoutts_: I think it was almost certainly due to me having two different cabal binaries in my path
04:42:12 <dcoutts_> drdozer: if one of them is older, yes.
04:42:19 * cads just searched a dating site for profiles mentioning the haskell programming language
04:42:21 <dcoutts_> drdozer: you want version 0.6
04:42:27 <cads> there was a girl!
04:42:38 <cads> one, exactly :D
04:42:53 <cads> and a bunch of cool seemind nerdy dudes
04:43:11 <drdozer> OK - is there a reason it installs the binary to my home-space rather than system-wide? I see why it would want to put managed packages in my space, but not the binary
04:47:05 <Twey> A girl?!
04:47:18 <Twey> Was it Philippa, or vixey?  :-P
04:48:19 <quicksilver> drdozer: if it's working in local mode, it's assuming you don't have privs to install anything globally
04:48:23 <quicksilver> I think?
04:58:15 <pao> dcoutts_: I'm not missing anything in cabal... I was just looking at a "haskell friendly" build tool, alternative to make, that could be used a general porpouse build tool
04:58:43 <dcoutts_> pao: ah, I see. Yes, Cabal is not general purpose.
04:59:10 <quicksilver> the road to software success is paved with failed make replacements.
04:59:12 <pao> dcoutts_: sorry for the misspell :-)
04:59:18 <quicksilver> I'm not entirely sure why.
04:59:57 <dcoutts_> quicksilver: it's easy to start, but hard to complete
05:00:22 <quicksilver> dcoutts_: yes, btu generically that is true of almost all software problems.
05:00:23 <dcoutts_> "how hard can it be? It's just a graph and a topological sort..."
05:00:36 <quicksilver> dcoutts_: I'm not sure why there are so many projects on this particular thing.
05:00:50 <dcoutts_> quicksilver: because everyone uses a make-like build tool
05:00:59 * quicksilver nods
05:01:05 <dcoutts_> and gets frustrated at how it doesn't quite do the right thing for them
05:01:14 <dcoutts_> and thinks "I can do it better!!"
05:02:07 <dcoutts_> making one that fits a niche is not that hard, but then people start stretching it and the lack of a decent language / abstraction becomes a problem
05:10:31 <jeltsch> Building the current Gtk2Hs darcs version failed. I did another make and put the output here: http://nopaste.org/p/aOTO3xxMV Any help?
05:11:21 <philipp> jeltsch: had the same problem but couldn't fix it
05:11:41 <jeltsch> philipp: Exactly the same message?
05:11:46 <philipp> yep
05:12:21 <philipp> tried to use an own version of c2hs but could't get it working
05:12:26 <jeltsch> phillip: Hmm, building a week or so ago went well. However, I didnât build SVG stuff etc. then.
05:12:30 <dcoutts_> jeltsch: I expect you've got an older gtk version and there's a mistake in the gtk2hs code that does not do the proper conditional compilation for that function
05:12:38 <dcoutts_> that's my guess
05:13:00 <jeltsch> dcoutts_: What is "older"? I use a current Ubuntu.
05:13:16 <dcoutts_> jeltsch: what gtk version?
05:13:34 <jeltsch> dcoutts_: 2.14.4
05:16:55 <dcoutts_> jeltsch: check /usr/include/gtk-2.0/gtk/gtktooltips.h
05:17:19 <dcoutts_> jeltsch: does it conditionally define things based on a DEPRECATED macro?
05:18:53 <philipp> GTK_DISABLE_DEPRECATED?
05:19:00 <jeltsch> dcoutts_: Yes, it seems that the whole header file is skipped if GTK_DISABLE_DEPRECATED is defined.
05:21:04 <gal_bolle> is there an escape function :: String -> String that escapes a string, but does not put quotes around it?
05:21:54 <jeltsch> gal_bolle: reverse . tail . reverse . tail . show
05:22:19 <gal_bolle> yes, but i was looking for a library function
05:22:33 <gal_bolle> and something that does not traverse the string thrice, too
05:22:43 <jeltsch> gal_bolle: Hmm, itâs still linear time.
05:23:18 <jeltsch> gal_bolle: Dontât know whether the string will be processed thrice in the presence of optimization.
05:23:24 <mmorrow> , let go [] = []; go ('
05:23:30 <lunabot>  luna: parse error on input `)'
05:23:30 <mmorrow> oops, hit enter by accident
05:24:00 <arw> usually, if you care about performance, you dont want to use String anyways. use ByteString instead.
05:24:26 <gal_bolle> yes, here i have a very big constant string
05:24:29 <mmorrow> , let go [] = []; go ('\\':cs) = "\\\\" ++ go cs; go ('"':cs) = "\\\"" ++ go cs in go "foo\"\\a\\b\""
05:24:34 <lunabot>  luna: <interactive>:1:54-126: Non-exhaustive patterns in function go
05:24:42 <lilac> (reading back) assuming that a make-like tool is just a graph and a topological sort is, i think, an error in itself :(
05:24:45 <mmorrow> , let go [] = []; go ('\\':cs) = "\\\\" ++ go cs; go ('"':cs) = "\\\"" ++ go cs; go (c:cs) = c : go cs in go "foo\"\\a\\b\""
05:24:47 <lunabot>  "foo\\\"\\\\a\\\\b\\\""
05:24:50 <jeltsch> arw: It depends. String conversion can sometimes be optimized away by deforestation or something like that.
05:25:13 <lilac> in my experience, any non-trivial build system includes building part of the graph as a result of executing some of the rules
05:25:13 <Axman6> > let go [] = []; go ('\\':cs) = "\\\\" ++ go cs; go ('"':cs) = "\\\"" ++ go cs; go (c:cs) = c :  go cs in
05:25:15 <lambdabot>   <no location info>: parse error on input `;'
05:25:22 <Axman6> > let go [] = []; go ('\\':cs) = "\\\\" ++ go cs; go ('"':cs) = "\\\"" ++ go cs; go (c:cs) = c :  go cs in go (fix error)
05:25:23 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
05:25:29 <Axman6> hmm
05:25:44 <jeltsch> gal_bolle: There is also Data.Sequence.
05:25:57 <Axman6> there was something that produced "\"\\\"\\\\"\\\\\\\"... or something
05:25:58 <arw> jeltsch: yes, but mostly that leads to somewhat unpredictable performance.
05:26:04 <jeltsch> @index Seq
05:26:05 <lambdabot> bzzt
05:26:12 <mmorrow> , fix show
05:26:16 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
05:26:24 <jeltsch> What does lambdabot: bzzt mean?
05:26:39 <ivanm> jeltsch: no result
05:26:40 <mmorrow> like a gameshow and you lost
05:26:40 <Axman6> ah that's it
05:26:46 <quicksilver> @index Sequence
05:26:46 <lambdabot> bzzt
05:26:47 <gal_bolle> ok, so i have a big file, and i want to generate a .hs file that says mystring = <contents of the file>
05:26:47 <Axman6> > let go [] = []; go ('\\':cs) = "\\\\" ++ go cs; go ('"':cs) = "\\\"" ++ go cs; go (c:cs) = c :  go cs in go (fix show)
05:26:48 <lambdabot>   "\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\...
05:26:50 <quicksilver> hmm
05:27:03 <gal_bolle> and i want the contents of the file to be on several lines
05:27:14 <Axman6> > let go [] = []; go ('\\':cs) = "\\\\" ++ go cs; go ('"':cs) = "\\\"" ++ go cs; go (c:cs) = c :  go cs in go.go.go.fix $ show
05:27:15 <lambdabot>   "\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\...
05:27:31 <gal_bolle> right now i have
05:27:32 <gal_bolle>           thedata <- liftM lines $ getContents
05:27:34 <gal_bolle>           putStrLn $ varname ++ " =\"\""
05:27:35 <gal_bolle>           forM_ thedata $ \line -> putStrLn (" ++" ++ show line)
05:27:37 <gal_bolle> but it's making ghc cry
05:27:50 <gal_bolle> when i compile the output hs file
05:28:07 <Botje> gal_bolle: can you put it on hpaste.org ?
05:28:17 <Botje> with the error it shows
05:28:29 <jeltsch> dcoutts_: Do you think there is an easy fix to the building problem or should I maybe try without --disable-deprecated?
05:28:55 <gal_bolle> here it is http://hpaste.org/13709
05:29:13 <cads> EvilTerran: that introduction to monads is the clearest once i've seen
05:29:19 <gal_bolle> there's no error though, ghc has just been eating 80% of my cpu for 5 minutes
05:29:23 <gal_bolle> and running
05:29:30 <dcoutts_> jeltsch: you could send a patch to conditionally bind those functions, like we do for other deprecated functions
05:29:33 <jeltsch> dcoutts_: By the way, it would be even cooler if Gtk2Hs would include the complete interface always but mark deprecated stuff with GHCâs deprecation macro.
05:29:35 <EvilTerran> cads, yeah, it's my personal favourite, too :)
05:29:52 <gal_bolle> it just  finished
05:29:52 <mmorrow> main = (mapM_ putStr . zipWith (\(c,s) -> c : show s) ('[':repeat ',') . lines =<< getContents) >> putStrLn "]"
05:30:01 <jeltsch> dcoutts_: No idea how to do that. :-(
05:30:05 <dcoutts_> jeltsch: yes, my code gen does do that now, but the existing code has not been changed
05:30:07 <mmorrow> that should print it as a list
05:30:35 <Botje> gal_bolle: you know that getContents reads the content from stdin, right?
05:30:43 <dcoutts_> jeltsch: look at gtk/Graphics/UI/Gtk/Abstract/Container.chs.pp look for #ifndef DISABLE_DEPRECATED
05:30:45 <Botje> how are you running it?
05:30:52 <gal_bolle> yes, i redirected stdin
05:31:43 <mmorrow> oops
05:31:47 <cads> EvilTerran:  other introductions had me distracted when I imagined action scenes where astronauts desperately run down a corridor, get into a spacesuit with umbilical and jump out of the airlock into space.. then they put on another suit that's even more powerful and take the jumpgate to the center of the sun.. now what was I talking about?
05:31:49 <Botje> gal_bolle: works for me
05:31:50 <mmorrow> zipWith (\c s ->
05:32:02 <gal_bolle> it's not running it that's a problem
05:32:15 <gal_bolle> it's compiling the output hs file
05:32:32 <EvilTerran> cads, heh, quite. i find learning by motivating examples to be easier than learning by obtuse allegory
05:32:36 <gal_bolle> ghc is having a hard time swallow the 4000 string concatenations
05:32:49 <lilac> gal_bolle: my guess is that ghc is doing the O(n^2) thing
05:32:54 <chessguy_work> gal_bolle, can you paste that file?
05:33:03 <cads> EvilTerran: have you seen the video where the amicable professor with the australian hat breaks monads down on the chalkboard?
05:33:07 <lilac> gal_bolle: rewrite it as concat of a list
05:33:11 <mmorrow> i meant this
05:33:12 <mmorrow> main = (mapM_ putStrLn . zipWith (\c s -> c : show s) ('[':repeat ',') . lines =<< getContents) >> putStrLn "]"
05:33:21 <mmorrow> $ cat /dev/urandom | od | head -10 | ./hslist
05:33:21 <lilac> gal_bolle: although i don't know if GHC will optimize that :(
05:33:23 <EvilTerran> cads, i'm not sure; do you have a link?
05:33:26 <chessguy_work> @type  (mapM_ putStrLn . zipWith (\c s -> c : show s) ('[':repeat ',') . lines =<< getContents) >> putStrLn "]"
05:33:27 <lambdabot> IO ()
05:33:44 <lilac> gal_bolle: alternatively, write it each line as ("str"++) .
05:33:45 <jeltsch> dcoutts_: Hmm, there is only a gtk/Graphics/UI/Gtk/Types.chs but no gtk/Graphics/UI/Gtk/Types.chs.pp.
05:33:47 <Workybob> mmorrow: ewww, why the mapM?
05:33:49 <mmorrow> that's literally the output of cat hslist.hs
05:33:50 <cads> Iv'e got the video on my harddrive, let me find out his name
05:33:54 <Workybob> why not construct the string, and then print it once?
05:34:04 <dcoutts_> jeltsch: right, it's generated directly as a .chs file
05:34:11 <mmorrow> Workybob: why not? :)
05:34:13 <gal_bolle> workybob, that's not the problem
05:34:17 <Workybob> mmorrow: much less composable
05:34:25 <chessguy_work> @pl \c s -> c : show s
05:34:26 <lambdabot> (. show) . (:)
05:34:27 <jeltsch> dcoutts_: So what should I do then?
05:34:29 <Workybob> you now can't easily do something with the output from it
05:34:30 <lilac> gal_bolle: or replace each newline with "\\\n\\" in the source string
05:34:40 <mmorrow> Workybob: it's not meant to be composable, it's an off-the-cuff one-liner :)
05:34:40 <cads> EvilTerran: I liked his approach of simply presenting the axioms of monads, but it was not programming language specific
05:34:41 <gal_bolle> yes, that's what i was going to do
05:34:46 <gal_bolle> hence my original question
05:34:55 <Workybob> mmorrow: yeh, but it's possible to do off the cuff in one line, also in a composable way
05:35:03 <jeltsch> dcoutts_: Directly modify the chs file?
05:35:04 <gal_bolle> (a library function to escape without adding quotes)
05:35:07 <mmorrow> i don't see how it's not composable
05:35:08 <dcoutts_> jeltsch: oh, that file is generated from tools/hierarchyGen/hierarchy.list which supports deprecation
05:35:24 <mmorrow> also, composable how? wrt other haskell functions, or as a shell program?
05:35:45 <dcoutts_> jeltsch: see also gtk/Graphics/UI/Gtk/Embedding/Plug.chs.pp for an example of an entire module that gets conditionally compiled
05:35:47 <mmorrow> cat | tr -d '\n'
05:36:43 <jeltsch> dcoutts_: So I have to just uncomment the symbols in question in tools/hierarchyGen/hierarchy.list? What about the "if deprecated" strings in this file?
05:36:46 <Workybob> mmorrow: composable with the rest of a potential Haskell program
05:36:55 <mmorrow> and if in haskell, do you mean something like unlines, or do you mean the fact that i made it have linebreaks at all?
05:37:07 <dcoutts_> jeltsch: you add if deprecated to the two newly deprecated types
05:37:12 <Workybob> I mean the fact that you use mapM_ to print essentially 1 string
05:37:19 <Workybob> it should have stayed a string for as long as possible
05:37:21 <Workybob> (using concat etc)
05:37:22 <mmorrow> _one-line-at-a-time_
05:37:37 <Workybob> yes â you could have used concat afterwards to stick them together into one string
05:37:41 <Workybob> then you have an extra pure value you can work on
05:37:41 <mmorrow> i could have
05:37:48 <EvilTerran> laziness would make it one-line-at-a-time anyway
05:37:51 <Workybob> thus... more composable
05:38:13 <mmorrow> but it wouldn't be in IO anyhow if it were written to be composable
05:38:21 <mmorrow> and if also would be left as a [String]
05:38:46 <mmorrow> so how it's chosen to be output i don't feel has to do with composability.
05:39:10 <Workybob> mmorrow: well no, in that it's a tool â it's gotta output eventually, but it would have been written as main = putStLn . pureMain =<< getContents
05:39:24 <EvilTerran> ?src interact
05:39:24 <lambdabot> interact f = do s <- getContents; putStr (f s)
05:39:28 <Workybob> that too
05:39:29 <mmorrow> with a wrapper
05:39:38 <mmorrow> pureMain = concat . foo
05:39:43 <Workybob> yep, exactly
05:39:46 <cads> EvilTerran: Don't Fear The Monads: http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/
05:39:51 <Workybob> pureMain being an extra pure value you can work with
05:39:59 <Workybob> so it's more composable
05:40:04 <Workybob> because you can now hand that value around
05:40:04 <EvilTerran> cads, thanks, i'll have a look
05:40:13 <mmorrow> well feel free to rewrite it :)
05:40:44 <vegai> is it possible to read from a Concurrent.Channel with a timeout?
05:41:20 <lilac> gal_bolle: http://hpaste.org/13709#a2
05:41:29 <vegai> preferably so that it won't be fragile as hell :P
05:41:31 <quicksilver> vegai: fork a thread and kill yourself
05:41:41 <vegai> yes, that was my first idea
05:41:51 <jeltsch> dcoutts_: You mean like that: http://hpaste.org/13710
05:42:01 <vegai> except for the forking a thread part. Har har har.
05:42:12 <quicksilver> but I don't know how you guarantee you don't get the exception just after you've read
05:42:12 <icqnumber_> is there a way to print only the 10 first element of the list defined as fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
05:42:17 <quicksilver> and before you've processed.
05:42:21 <vegai> aye..
05:42:34 <Workybob> icqnumber_: take
05:42:37 <Workybob> @type take
05:42:38 <lambdabot> forall a. Int -> [a] -> [a]
05:42:42 <dcoutts_> jeltsch: exactly, then you need to modify the corresponding modules to conditionally compile the whole things
05:42:44 <Workybob> > take 10 [1..]
05:42:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:42:51 <vegai> I wonder if I should be using CHP anyway.
05:42:53 <dcoutts_> jeltsch: for reference see gtk/Graphics/UI/Gtk/Embedding/Plug.chs.pp
05:43:00 <icqnumber_> Workybob, thank you
05:43:04 <cads> EvilTerran, also of interest are the Catsters' videos, where, at least for the monad lesson, the extremely cute Eugenia Cheng goes all out on category theory
05:43:31 <cads> alas I has a crush on her..
05:44:02 <chessguy_work> @pl f pr pe s n = t n $ r $ so sc
05:44:02 <lambdabot> f = const (const (const (flip t (r (so sc)))))
05:44:08 * chessguy_work sniggers
05:44:29 <Gracenotes> sniggering at work, eh?
05:44:33 <dcoutts_> jeltsch: actually a better example is gtk/Graphics/UI/Gtk/MenuComboToolbar/OptionMenu.chs.pp
05:44:51 <drdozer> :t fromList
05:44:53 <lambdabot> Not in scope: `fromList'
05:44:58 <dcoutts_> jeltsch: copy that use & placement of #ifndef DISABLE_DEPRECATED in the FileSelection and Tooltips modules
05:45:02 <drdozer> :t Control.Monad.Random.fromList
05:45:04 <lambdabot> Couldn't find qualified module.
05:46:28 <vegai> ah, chp not yet updated to ghc-6.10
05:46:30 <chessguy_work> @pl f n = t n x
05:46:30 <lambdabot> f = flip t x
05:46:49 <jeltsch> dcoutts_: Hmm, I thought, these #ifndef DISABLE_DEPRECATED things are autogenerated from tools/hierarchyGen/hierarchy.list.
05:47:13 <dcoutts_> jeltsch: hierarchy.list only affects the Types.chs module
05:47:15 <quicksilver> vegai: use "block" around the readChan
05:47:19 <quicksilver> vegai: then its safe
05:47:29 <quicksilver> vegai: (internall the readChan will "unblock" around the critical region)
05:47:50 <quicksilver> vegai: according to JaffaCake at least.
05:48:05 <vegai> I'll try that, thanks.
05:48:30 <vegai> I wonder if I can test this by flooding the channel and killing the thread
05:48:41 <JaffaCake> don't assume that block prevents all async exceptions - it just prevents them from happening in random places
05:49:16 <gal_bolle> thanks lilac
05:50:21 <quicksilver> vegai: it's very hard to test race conditions where you don't have access to the source
05:50:22 <lilac> gal_bolle: does that sort out the GHC runtime issue?
05:50:29 <gal_bolle> yes
05:50:40 <lilac> gal_bolle: you might want to file a bug on the GHC trac about that.
05:50:50 <gal_bolle> ok
05:50:53 <quicksilver> vegai: often you can only reproduce them confidently by adding synthetic delays to widen the race
05:50:58 <chessguy_work> hey wchogg : i vote that after we finish PCI, we do AIMI - this stuff is great!
05:51:08 <quicksilver> vegai: int-e provided this doc, too : http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#12
05:52:14 <lilac> gal_bolle: i think you also need to replace the '\n' -> '\\\n\\' with '\n' -> '\\n\\\n\\' or you'll lose the newlines in your string
05:52:21 <drdozer> gha! I'm drowning in the haskell number hierarchy again
05:52:48 <gal_bolle> lilac, yes, i did that
05:53:03 <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
05:53:25 <quicksilver> or realToFrac
05:53:49 <Raynes> Magic 8-ball says 'I smell death on you'.
05:54:12 <chessguy_work> @remember lilac <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
05:54:12 <lambdabot> I will never forget.
05:54:59 <drdozer> I think I need the coercion (Floating f) => f -> Rational
05:55:25 <kpreid> :t realToFrac
05:55:26 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
05:55:41 <kpreid> @instance Fractional
05:55:41 <lambdabot> Maybe you meant: instances instances-importing
05:55:45 <kpreid> @instances Fractional
05:55:46 <lambdabot> Double, Float
05:56:27 <vegai> hmm, could this work... http://haskell.org/ghc/docs/latest/html/libraries/base/System-Timeout.html
05:56:34 <quicksilver> drdozer: realToFrace
05:56:38 <EvilTerran> @instances-importing Data.Ratio Data.Complex Fractional
05:56:39 <lambdabot> Complex a, Double, Float, Ratio a
05:56:43 <quicksilver> drdozer: without the erroneous trailing e.
05:57:01 <drdozer> quicksilver: i need the inverse of that I think - I need to end up with a real, given a fractional
05:57:04 <chessguy_work> @hoogle Frace
05:57:04 <lambdabot> No results found
05:57:11 <vegai> not if I have FFI calls, apparently
05:57:11 <quicksilver> drdozer: I promise you, it's what you nead.
05:57:14 <MichaelGG> So for lambdas, why does Haskell use \ -> instead of \ . ?
05:57:32 <quicksilver> drdozer: it is its own inverse, in practice.
05:57:45 <EvilTerran> MichaelGG, because we wanted (.) for function composition
05:57:45 <quicksilver> (the only thing that is fractional but not real is Complex d)
05:57:51 <vegai> though it says that it might work also for FFI code. Hmm
05:58:00 <MichaelGG> EvilTerran, would it be ambiguous?
05:58:13 <EvilTerran> i... guess not, actually
05:58:28 <drdozer> no, I really do need the inverse of this
05:58:44 <MichaelGG> I much prefer \ over "fun" :P
05:58:52 <quicksilver> > (realToFrac (2.0 :: Double)) :: Rational
05:58:53 <lambdabot>   2%1
05:59:01 <quicksilver> drdozer: are you sure?
05:59:02 <EvilTerran> > realToFrac (2.0 :: Rational) :: Double
05:59:03 <lambdabot>   2.0
05:59:24 <quicksilver> drdozer: which concrete types do you need to convert between.
05:59:27 <chessguy_work> MichaelGG, or "lambda"
05:59:39 <chessguy_work> who in the world thought that writing that out was a good keyword
05:59:46 <EvilTerran> chessguy_work, indeed, that's something i found really off-putting about lisp
05:59:58 <quicksilver> conceivably the same person who didn't like infix operators :)
06:00:03 <MichaelGG> chessguy_work, someone who doesnt do functional programming?
06:00:08 <EvilTerran> long keywords everywhere!
06:00:17 <MichaelGG> I really hope F# will allow \ over fun
06:00:24 <EvilTerran> programming languages should be huffman-encoded by design
06:00:46 <drdozer> quicksilver: ah, ok - adding (Floating f, Real f) => made it work as needed
06:01:06 <EvilTerran> need a keyword a lot - then it should be a short keyword
06:01:13 <drdozer> thanks - I never would have worked that out in a million years
06:02:18 <EvilTerran> if it's common, it will come up often enough in code that anyone learning the language will, by necessity, know it, even if it's non-self-explanatory
06:02:47 <chessguy_work> hey, what would it take to be able to write a  program that could control an electronic gadget of some type in haskell?
06:03:06 <MichaelGG> EvilTerran, so, for common things, are symbols better than short keywords?
06:03:09 <MichaelGG> i.e., \ over "fun"
06:03:16 <EvilTerran> MichaelGG, well, they're even shorter :)
06:03:27 <EvilTerran> MichaelGG, i don't mind ml's "fn" for lambdas
06:03:44 <jeltsch> dcoutts_: In the file you mentioned there is also this.
06:03:53 <jeltsch> dcoutts_: -- As of Gtk+ 2.4, 'OptionMenu' has been deprecated in favor of 'ComboBox'.
06:04:01 <chessguy_work> in c# it's just "x => ..."
06:04:09 <MichaelGG> chessguy_work, yea, except its also useless
06:04:12 <EvilTerran> but i don't shy away from symbols just because they're symbols
06:04:18 <MichaelGG> cause you have to have the type specified
06:04:18 <chessguy_work> MichaelGG, hm?
06:04:19 <quicksilver> chessguy_work: openFile "/dev/tty0" ReadWRite ?
06:04:24 <EvilTerran> (unlike many haters of operator overloading)
06:04:31 <MichaelGG> you cant do" var inc = i => i + 1"
06:04:32 <jeltsch> dcoutts_: I cannot put an equivalent line into the FileSelection and Tooltips modules because I donât know what the replacements are. Do you know?
06:04:33 <dcoutts_> jeltsch: if you can find from the gtk docs what it's been replaced by then feel free to add something similar
06:04:46 <MichaelGG> you have to do Func<int,int> inc = i => i + 1
06:04:48 <quicksilver> chessguy_work: I mean no harder or easier than any other language I guess.
06:05:08 <chessguy_work> MichaelGG, hm, that's strange. wonder why it can't infer that type?
06:05:13 <MichaelGG> C# provides just enough functional to get you interested, then make you want to tear your eyes out
06:05:20 <chessguy_work> quicksilver, yeah, i don't know what it woul take in any language though :)
06:05:30 <MichaelGG> chessguy_work, well first, its inference is crap. second, they use the same syntax for quoted code
06:05:41 <MichaelGG> i.e. "x => x + 1" could be code or an expression tree
06:05:46 <jeltsch> dcoutts_: Uff, so much manual work. Could this automated maybe?
06:05:58 <MichaelGG> which is another decision to dumb it down for the morons who use it :(
06:06:04 <dcoutts_> jeltsch: a lot of it can and has been
06:06:25 <chessguy_work> MichaelGG, hey, be careful, i'm a C# programmer by day :)
06:06:38 <MichaelGG> chessguy_work, im sorry to hear that
06:06:39 <dcoutts_> jeltsch: FileSelection has been superseded by the FileChooser
06:06:51 <MichaelGG> I'm actually using C# today too. but we're trying to move everything to F# as fast as possible
06:07:00 <chessguy_work> MichaelGG, it could be far worse
06:07:07 <MichaelGG> It makes me sick -- I declare a field in C#, and it's literally 300+ characters.
06:07:09 <chessguy_work> (C++ <shudder>
06:07:17 <drdozer> MichaelGG - how is F#?
06:07:25 <dcoutts_> jeltsch: "Tooltips" has been deprecated in GTK+ 2.12, in favor of "Tooltip".
06:07:38 <MichaelGG> F# F#ing rocks
06:07:44 <Zao> F# is meh.
06:07:54 <drdozer> I've got a friend in MS who is keen to push F# as a language for compute-intensive bioinformatics on ms platforms
06:08:02 <Zao> "hay lol I can do units, let's all do units and see, you can do units!"
06:08:14 <Zao> Although that may be a flaw of F# bloggers :)
06:08:18 <EvilTerran> units of vodka?
06:08:29 <chessguy_work> quicksilver, do you know?
06:08:41 <drdozer> Zao - units are very important things, if nothing else, to give you a warm fuzzy feeling about your code
06:08:44 <MichaelGG> heres why I like F#: I get .NET (tons of libraries, runtime everywhere, interop with C#), I get an awesome IDE
06:08:44 <chessguy_work> quicksilver, or have suggestions of search terms?
06:08:56 <quicksilver> chessguy_work: well, hardware devices present themselves in various ways.
06:09:06 <quicksilver> the simplest, historically, presented themselves as serial devices
06:09:18 <quicksilver> which you just write to and read from bytes like a network connection or indeed a file.
06:09:18 <drdozer> MichaelGG: exactly - it's the interoperability and IDE that make it compelling
06:09:19 <Workybob> I get the feeling that something like this should already exist, but I don't know what it is â anyone know?
06:09:20 <Workybob> http://hpaste.org/13711
06:09:21 <quicksilver> that's easy in any language.
06:09:33 <chessguy_work> quicksilver, sure
06:09:37 <quicksilver> Workybob: Data.Unique ?
06:09:47 <MichaelGG> drdozer, yep
06:09:56 <MichaelGG> I cannot see why anyone would use C# over F#
06:10:02 <drdozer> MichaelGG: if there was a good quality haskell Java bytode back-end (and intellij/eclipse/netbeans took notice), then haskell would have much the same advantages
06:10:04 <MichaelGG> for anything except where F# doesnt have a nice designer
06:10:07 <chessguy_work> MichaelGG, WCF?
06:10:08 <ivanm> MichaelGG: I find your reasons for liking F# extremely offputting... :s
06:10:10 <Workybob> quicksilver: oh, good point â but doesn't that just create unique values, rather than enforcing that each value you create is associated with a unique value
06:10:17 <MichaelGG> chessguy_work, WCF works fine with F#
06:10:17 <quicksilver> chessguy_work: more recently they present themselves through the USB api (say) which is more complex.
06:10:25 <chessguy_work> MichaelGG, ah, i see
06:10:28 <quicksilver> Workybob: well it's closely related at least :)
06:10:28 <chessguy_work> didn't realize that
06:10:35 <MichaelGG> ivanm, well it depends on what youre rtying to accomplish
06:10:36 <Workybob> quicksilver: indeed
06:10:47 <lilac> Workybob: that's not referentially transparent
06:11:00 <ivanm> MichaelGG: AFAICT, a good IDE only leads to automated code generation == boilerplate
06:11:01 <MichaelGG> I want to hire people, get them quickly writing software and have any library i could possibly want instantly available and supported
06:11:05 <Workybob> lilac: no, it isn't â it needs an unsafe name
06:11:09 <MichaelGG> ivanm, no not at all
06:11:15 <chessguy_work> quicksilver, by API, i assume you mean a hardware api
06:11:17 <ivanm> (for a questionable definition of "good")
06:11:24 <MichaelGG> ivanm, a good IDE saves me keystrokes (RSI FTW!), gives me type info when i want it, etc.
06:11:34 <ivanm> emacs does that....
06:11:34 <quicksilver> chessguy_work: not really.
06:11:37 <quicksilver> chessguy_work: USB is a spec.
06:11:37 <ivanm> and it's not an IDE ;-)
06:11:38 <MichaelGG> shows compile errors as i  type em
06:11:40 <drdozer> MichaelGG: exactly - real-world utility outweighs beauty when you'v got a deadline and an angry customer
06:11:41 <chessguy_work> MichaelGG, waht's RSI?
06:11:45 <quicksilver> chessguy_work: you would interface to it via a software library.
06:11:46 <ivanm> *shrug* flymake
06:11:47 <MichaelGG> repetitive strain injury
06:11:51 <chessguy_work> oh, haha
06:11:57 <quicksilver> chessguy_work: (or your kernel does that for you, and presents a simpler interface to you)
06:12:16 <MichaelGG> I also have integrated source control, build environment, work item tracking, and correlation between those
06:12:27 <MichaelGG> and it doesnt take any work at all to setup :)
06:12:28 <lilac> Workybob: just change "identified :: a -> IO (Identified a)". if people want to unsafePerformIO it, let them do so at their own risk :)
06:12:35 <ivanm> MichaelGG: yup, a decent text editor (read emacs) has all that...
06:12:36 <chessguy_work> MichaelGG, don't suppose you're hiring in norhtern virginia :)
06:12:47 <ivanm> maybe not the lack of a setup.... but I like configurability
06:12:55 <chessguy_work> quicksilver, hmm, so the language would need a USB library
06:13:05 <MichaelGG> and a good debugger
06:13:14 <Workybob> lilac: true
06:13:31 <MichaelGG> for instance, if I want to expose some code as a transactional service -- is there a WS-AtomicTransaction library for Haskell?
06:13:41 <ivanm> MichaelGG: *shrug* I've found ghci to fulfill most of my debugging requirements
06:13:43 <quicksilver> chessguy_work: yes.
06:13:43 <MichaelGG> in .NET, I add a few lines here and there and presto
06:13:52 <ivanm> MichaelGG: what's WS?
06:13:53 <lilac> Workybob: alternatively, you could use a state monad for tracking the identifiers.
06:14:05 <MichaelGG> WS is the hugely complex "web services" specifications
06:14:18 <ivanm> ahhhh.....
06:14:19 * ivanm runs
06:14:20 <ivanm> ;-)
06:14:29 <MichaelGG> and WS-AtomicTransaction is the only non-binary proprietary protocol to do distributed transactions , for instance
06:14:45 <MichaelGG> so I can have my users tie in my system to, say, update their balance, transactionally into their own DB
06:15:17 <MichaelGG> If I could just study and learn stuff all day, perhaps F# wouldnt be as interesting
06:15:26 <chessguy_work> quicksilver, thanks for the insight
06:15:30 <drdozer> web-services and functional programming /should/ be a really good match, but in practice they are not because the ws infrastructure just isn't there
06:15:42 <MichaelGG> drdozer, how do you mean?
06:16:13 <quicksilver> MichaelGG: these advantages you cite are not advantages of the language per se, but of the wider ecosystem.
06:16:16 <drdozer> well, proper SOAs look much more like bundles of related functions than they do look like objects
06:16:19 <quicksilver> MichaelGG: (which doesn't invalidate them)
06:16:47 <MichaelGG> quicksilver,  agreed
06:16:55 <MichaelGG> drdozer, yes exactly.
06:16:58 <jeltsch> dcoutts_: More Gtk2Hs building errors: http://hpaste.org/13712
06:17:06 <drdozer> so describing a service as a haskell class is a much cleaner abstraction than describing it as a java interface
06:17:10 <jeltsch> dcoutts_: How to deal with them? Not whole modules but single functions now.
06:17:20 <MichaelGG> drdozer, i think any "OO" stigma on them is simply just cause everyones an idiot? :)
06:17:41 <dcoutts_> jeltsch: similar way, see the other uses of DISABLE_DEPRECATED in other modules
06:17:50 <drdozer> yeah, and because the 1st and 2nd generation containers and tooling encouraged OO-over-SOAP rather than SOA
06:17:55 <MichaelGG> quicksilver, another good thing is F# now has full commercial funding
06:18:16 <MichaelGG> so tool support, compatibility, stable releases, etc are all up there
06:18:30 <MichaelGG> yet they still are super responsive. half the time I report a bug or feedback and the F# guys write back within 30 minutes
06:18:36 <chessguy_work> MichaelGG, what do you mean by commercial funding?
06:18:56 <quicksilver> MichaelGG: well GHC has commercial funding, but it's a question of degree.
06:19:03 <MichaelGG> chessguy_work, I mean ,F# is no longer just a MS research project -- its shipping in VS 2010. theyre already poaching devs from other parts of the company :)
06:19:15 <chessguy_work> ah, gotcha
06:19:27 <MichaelGG> I mean ill be able to call up MS PSS at 2AM and get a support ticket and a hotfix if theres a bug or whatnot
06:20:03 <chessguy_work> is there going to be a new VS between now and 2012? or is that the next one
06:20:12 <MichaelGG> yea VS2010 is gonna ocme out this year
06:20:13 <MichaelGG> i think
06:20:19 <MichaelGG> and F# is the only interesting thing in it :P
06:20:25 <Zao> chessguy_work: 10 is already out as a CTP in a virtual machine.
06:20:37 <MichaelGG> yea but its a really early preview
06:20:44 <jeltsch> dcoutts_: But I donât have to modify tools/hierarchyGen/hierarchy.list, do I?
06:20:47 <MichaelGG> a beta should be out soon? then itll have more cool stuff
06:20:48 <Zao> MichaelGG: Yes, as CTP indicates.
06:21:03 <MichaelGG> CTP is a really loose term. SQL shipped CTPs all the way up to the release candidate
06:21:11 <MichaelGG> But what I mean is that F# isnt in the CTP
06:21:14 <drdozer> I know java bytecode well enough - if I wanted to get ghc to compile to that, where would I start?
06:21:14 <MichaelGG> nor is the new IDE
06:21:20 <Zao> In VS land it's rather defined though.
06:21:21 * EvilTerran notes that IORefs provide call-by-name semantics
06:21:44 <MichaelGG> Wel, for instance, the VS 2005 alpha build had the new IDE. this 2010 CTP doesnt have its new IDE
06:21:50 <chessguy_work> drdozer, personally, i'd start in #ghc
06:22:06 <MichaelGG> its mainly so the C# people can use dynamic typing and think theyre leet like python users. (dont ask how that logic works)
06:22:07 <chessguy_work> drdozer, not saying you shouldn't ask here
06:22:49 <Saizan> EvilTerran: if you allocate a different IORef each time?
06:23:20 <quicksilver> drdozer: you may wish to investigate a couple of dead projects which tried to do this
06:23:42 <quicksilver> drdozer: but #ghc, and the ghc-dev mailing list, are appropriate venues
06:24:26 <dcoutts_> jeltsch: no, because there are no types being deprecated in this case
06:24:44 <PeakerWork> Dynamism sucks :P
06:25:13 <PeakerWork> I've liked Python for years, but still hated the dynamism, only thinking that nobody got staticness right (Until I learned Haskell..)
06:25:41 <Raynes> Rich Hickey would beg to differ.
06:25:49 <MichaelGG> Yea... I still don't get dynamic typing. Some people (PaulGraham) just go on and on about having different types in one list -- maybe im just dumb.
06:26:03 <Raynes> And Paul Graham, but I don't like him so much.
06:26:15 <dons> ?yow
06:26:15 <lambdabot> Look!  A ladder!  Maybe it leads to heaven, or a sandwich!
06:26:35 <EvilTerran> Saizan, i'm thinking of passing IO actions as parameters to IO functions
06:26:42 <chessguy_work> lambdabot cracks me up :)
06:26:45 <dons> yeah :)
06:26:45 <lambdabot> dons: You have 14 new messages. '/msg lambdabot @messages' to read them.
06:26:50 <MichaelGG> All the python/ruby people I've met are just running away from Java
06:27:00 <stu8ball> Perl 6's type system is decent.
06:27:01 <MichaelGG> oh and they go on about how cool it is that they can monkeypatch or something.
06:27:12 <MichaelGG> and how they have runtime macros or something
06:27:13 <chessguy_work> 14 new messages. don, you better quit slacking off :)
06:27:15 <EvilTerran> Saizan, as, if the function binds them repeatedly, the values of any IORefs it uses get determined at the time
06:27:16 <stu8ball> You can have static or dynamic stuff in Perl 6, whichever suits.
06:27:31 <EvilTerran> Saizan, i note the same applies to State, too
06:27:39 <stu8ball> Although it's static weak typing, not static strong typign as in Haskell.
06:27:50 * EvilTerran is just randomly observing things while working on his coursework
06:28:00 <Saizan> EvilTerran: ah, i see
06:28:26 <Saizan> ..not sure if i'd call that call-by-name
06:28:48 <Saizan> not that i'm that expert on call-by-* definitions
06:28:53 <PeakerWork> MichaelGG: You can have different types in one list and not be totally dynamic with existentials. Just be as dynamic as you must, no more
06:29:54 <MichaelGG> PeakerWork, well thats what i was thinking - static languages have ways around it so i dont see why its a big deal
06:30:37 <PeakerWork> Python dynamism goes as far as having even namespaces and names be runtime things -- and for little reason, really
06:30:42 <Saizan> or you can just have an HList! :)
06:30:46 <PeakerWork> (Making even code editors much less useful)
06:32:10 <EvilTerran> , runST $ do r <- newSTRef "r"; let { foo m = do x <- m; modifySTRef r (++x); m }; foo (readSTRef r)
06:32:14 <lunabot>  luna: Not in scope: `runST'
06:32:17 <EvilTerran> gr
06:35:58 <EvilTerran> Saizan, as i understand it, call-by-name allows you to do odd things like "rec while(p,e) = (if p then e; while(p,e) else skip); val x = 10; while(x > 0, (x := x - 1; print(x)));"
06:37:38 <EvilTerran> that's probably taking it to extremes
06:38:06 <PeakerWork> I think "call by name" is a bad name..
06:38:39 <EvilTerran> well, blame my lecturer, he defined it that way in the notes i'm looking at :P
06:38:50 <Saizan> i've only considered it in the LC, but yeah it looks similar, you're recomputing the (x > 0) "from scratch"
06:40:32 <PeakerWork> how about "call by thunk"? :)
06:41:16 <EvilTerran> as i said, i see it as analagous to passing an IO action around that's using IORefs
06:41:41 <EvilTerran> we just need to be a lot more explicit if we're doing weird things like that :)
06:42:01 <cads> EvilTerran, I must thank you once more for referring me to this tutorial. Monads are beautiful
06:42:21 * cads now feels "Monad to the bone"
06:42:37 <MichaelGG> so is it possible to understand monads purely from a haskell and not category theory
06:43:11 <Saizan> sure
06:43:46 <cads> yeah, a monad is just 3 functions that satisfy some properties
06:44:30 <PeakerWork> cads: which tutorial?
06:44:39 <Saizan> or you can say that it's a way to compose functions which have "richer" results
06:44:41 <cads> MichaelGG: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
06:44:43 <PeakerWork> cads: 2, or even 1 in addition to Applicative
06:44:47 <drdozer> I tend to think of monads as interpreters
06:44:58 <PeakerWork> I think of monads as boxed values
06:45:24 <MichaelGG> then whats the big deal
06:45:25 <yip> thinking about monads in general is pretty tricky but thinking about a specific monad in a certain way works
06:45:27 <PeakerWork> I think Functor and Applicative are more commonly useful than monads, but monads are used because of library structuring/etc..
06:45:32 <Saizan> drdozer: that's roughly how they started using them in programming
06:45:40 <MichaelGG> I've sorta gotten to the point that I think of monads as quantum mechanics -- if i think i get it, i must not.
06:45:44 <PeakerWork> MichaelGG: Who says there is a big deal? :)
06:46:20 * drdozer grumbles about Monad.fail
06:46:46 <yip> drdozer: you don't have to use it
06:47:01 <osfameron> fail seems quite pragmatic to me
06:47:19 <PeakerWork> Functor -- a box you can copy or change the contents of (but still remain in the box).   Applicative -- like Functor, but you can also combine the contents of two boxes and form a single box which is the result computation on both contents as inputs.   Monad -- Like Applicative, but you can choose or create boxes to combine based on the contents of existing boxes
06:47:21 <osfameron> after all, haskell is a practical programming language, not a branch of abstract maths
06:47:23 <Saizan> i.e. a Monad can be used either for describing the semantic or writing an interpreter for an impure language
06:47:35 <PeakerWork> @src MonadFail
06:47:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:47:47 <PeakerWork> osfameron: Why not class Monad m => MonadFail m where fail :: ... ?
06:47:57 <Saizan> osfameron: most monads don't have a sensible definition of fail
06:48:18 <drdozer> right - is ther a 5 min tutorial I should look at before writing my first tab-delimited parser in haskell?
06:48:41 <Saizan> osfameron: that makes it not very pratical, since you just get an exception in pure core, instead of a compile-time error
06:48:42 <osfameron> ah fair enough
06:48:51 <drdozer> or do I simply read the file, split on newline, split on tab?
06:48:53 <cads> MichaelGG: well take mathematical functions of real numbers... simple and practical enough to write one, x^2, nice.. but the mathematical theory of function analysis gets really crazy with metric spaces and other abstract stuff mathematicians invented to really get a grip on functions and bring them under the microscope
06:49:03 <EvilTerran> osfameron, that's all well-and-good for the pragmatists, but i'm a purist through-and-through, so it irks me :P
06:49:27 <osfameron> is this one of the warts that will be fixed in ' ?
06:49:54 <cads> similar with category theory and monads... and if you read the tutorial I showed you, you'll see how a monad is actually something you'd probably come up with if you were in a particularly higher order function type of mood
06:50:04 <Saizan> ' for now is a just a bunch of LANGUAGE extensions :)
06:50:14 <MichaelGG> ok thanks
06:50:20 <MichaelGG> gonna read it
06:50:31 <Saizan> drdozer: maybe use parsec or ReadP
06:50:35 <MichaelGG> It just seems everyone gets all hyper
06:50:44 <MichaelGG> C#/VB wont call em monads, F# calls em workflows
06:50:56 <therp> Peaker: nice insight (Functor/Applicative/Monad)
06:51:02 <MichaelGG> and everyone makes it out to be the hardest thing in the world
06:51:15 <MichaelGG> like "I'm a PhD in compsci, and I dont understand monads"
06:51:47 <cads> Peaker, where could I read more about functor and applicative?
06:51:49 <EvilTerran> therp, except PeakerWork forgot that Applicative also gives you a way to put values in boxes
06:52:01 <PeakerWork> oops, right
06:52:03 <Saizan> MichaelGG: that means he's never really looked at them :)
06:52:16 <EvilTerran> altho i'd separate that out into another layer, Pointed, between Functor and Applicative
06:52:52 <Saizan> and rename Applicative to Zip
06:53:00 <EvilTerran> then they're all classes of one function (plus superclasses), which i find aesthetically pleasing :P
06:54:34 <quicksilver> Saizan: why is Zip a good name for applicative?
06:54:50 <cads> hehe you guys are maniacs :D
06:55:46 <Saizan> quicksilver: because it'll contain only  zip :: Zip f => f a -> f b -> f (a,b) at that point
06:56:26 <quicksilver> Saizan: I don't see why that is a better fundamental method than <*>
06:56:55 <quicksilver> and I don't think 'zip' is a good name for it, since in many applicatives it looks nothing like zipping.
06:59:25 * Workybob also loves Applicative very specifically because it's just like applying things
06:59:32 <drdozer> @src lines
06:59:32 <Workybob> or more to the point... it *is* applying things
06:59:32 <lambdabot> Source not found. It can only be attributed to human error.
06:59:46 <drdozer> @src Data.List.lines
06:59:46 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:59:52 <Saizan> (>>=) is applying things too :)
07:00:29 <Workybob> not in the same way ââ applicative is very specifically saying "you can live in a higher order world and still carry on doing application as you normally would"
07:01:59 <Saizan> higher order?
07:02:22 <camio> Anyone know where I can find specific rules for the use of arrow syntax (as opposed to translation rules)?
07:03:05 <redditbot> A Cross-language Comparison of Monads in Haskell, O'Caml, and Qi
07:03:05 <redditbot> Wadler's Blog: Well-typed programs can't be blamed
07:03:05 <redditbot> GHC on SPARC: Bootstrapping 5
07:05:02 <camio> Ah, I think I found what I'm looking for here, http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf
07:06:48 <a_guest> Hello. I shall use the function 'sortBy' in script in ghci. I get error: not in scope. What shall I do?
07:07:06 <xerox> ?index sortBy
07:07:07 <lambdabot> Data.List
07:07:09 <Deewiant> :m +Data.List
07:07:30 <a_guest> ...what to write in script (*.hs) ?
07:07:32 <xerox> if you have one, stick import Data.List on top of your .hs file
07:07:36 <Deewiant> import Data.List
07:07:39 <Saizan> import Data.List
07:07:43 <Deewiant> import Data.List (sortBy)
07:07:58 <cads> are there instances of monads where proving the monad properties is hard enough that it's not done, and where bugs could cause subtle and spooky errors?
07:08:11 <quicksilver> camio: nobody seems to use arrow notation. I wonder why not.
07:08:23 <quicksilver> camio: the only time I've really used arrows was when I used haxml.
07:08:30 <quicksilver> camio: and I didn't use the notation.
07:08:41 <cads> with simple examples, bind and unit either are correct, or the thing flat out won't work
07:08:59 <a_guest> thank you all. I am reading "Real World Haskell"
07:09:14 <dons> ?users
07:09:14 <lambdabot> Maximum users seen in #haskell: 668, currently: 626 (93.7%), active: 20 (3.2%)
07:09:52 <quicksilver> cads: the monads laws fail for many common monads
07:10:01 <quicksilver> cads: fortunately they fail for 'boring' or 'unimportant' reasons.
07:10:12 <cads> hmm
07:10:14 <Deewiant> They fail for IO, don't they?
07:10:33 <Deewiant> I seem to remember that the monad laws don't mix with IO and _|_
07:10:44 <quicksilver> the monad laws don't really mix with _|_, full stop.
07:10:56 <Deewiant> heh
07:11:05 <quicksilver> it could be argued that you should read the laws as applying to the noble, non-_|_ fragment of haskell.
07:11:20 <quicksilver> or appropriately weaken what the "equality" is suposed to be.
07:11:21 <EvilTerran> ISTR Omega doesn't really follow them, even for non-_|_ cases
07:11:36 <quicksilver> omega fails up to ordering, I suspect.
07:11:40 <EvilTerran> yeah
07:11:42 <vixey> with Omega you should consider [] as a bag
07:11:45 <EvilTerran> as you said, weaken equality
07:11:49 <vixey> same with ReadP
07:12:18 <cads> so all of these are just pseudo-monadic, but still useful
07:12:24 <EvilTerran> if it were wrapped up abstractly, with "runOmega :: Ord a => Omega a -> [a]; runOmega (Omega xs) = sort xs", say, it'd satify the laws
07:12:37 <quicksilver> cads: well, equality isn't defined in general for haskell
07:12:41 <EvilTerran> but that's a bit of a computational nusciance when it's "close enough" without it
07:12:44 <vixey> EvilTerran wouldn't that make the only use of Omega.. no longer possible?
07:12:51 <quicksilver> cads: so, when you ask if laws are obeyed, you have to decide what equality is supposed to mean.
07:13:02 <vixey> (infinite lists)
07:13:03 <quicksilver> cads: for example, in IO, you probably mean the equality to be observational.
07:13:15 <EvilTerran> quite
07:13:27 <EvilTerran> as i said, a computational nusciance :P
07:13:29 <quicksilver> for some definition of observation.
07:13:39 <quicksilver> Which you can possibly make work in a such a way that the laws pass :)
07:13:39 <vixey> to show Cont is a monad, you need to have the eta law f = \x -> f x
07:13:41 <Deewiant> EvilTerran: nuisance
07:13:51 <EvilTerran> ... yes, qutie
07:13:53 <quicksilver> nusciance : the property of being nutty.
07:13:59 <Saizan> you could have runOmega :: Omega a -> IO [a], and blame IO :P
07:14:04 <EvilTerran> er, quite. cold hands, cold brain, etcetc :P
07:14:06 <vixey> haha
07:14:25 <EvilTerran> (cold building)
07:14:27 <cads> gah.. how the io 'monad' manages to spit stuff out to the real world and still be 'purely functional' in definition still keeps me awake at night
07:14:29 <Deewiant> @vixen qutie
07:14:30 <lambdabot> My instant messenger doesn't work.
07:15:00 <vixey> cads, and have you used ST?
07:15:03 <Holle_> how can i create a variable and change the value during runtime
07:15:12 <vixey> Holle_, you can use ST
07:15:21 <Deewiant> or IO
07:15:31 <Holle_> how?
07:15:34 <vixey> well I am pointing out ST specifically because it is simpler than IO
07:15:43 <int-e> JaffaCake: I noticed. Thanks :)
07:15:44 <Holle_> what is st?
07:15:51 <int-e> wrong chann
07:16:01 <quicksilver> Holle_: the short answer is "You don't. Haskell variables denote values and haskell values are immutable".
07:16:06 <vixey> Holle_, ST is a monad, so there are a few functions to use like making a new reference, setting them, reading them..
07:16:22 <quicksilver> The longer answer is that in some monads, you can get a value which denotes a mutable cell.
07:16:22 <Deewiant> using ST you can write imperative code in a pure function
07:16:23 <Saizan> Holle_: you need to use explicit references, like IORef or STRef
07:16:36 <quicksilver> that shouldn't be the first approach to a problem.
07:16:45 <quicksilver> the first approach should just be to write a pure function which returns the 'new' value
07:16:51 <quicksilver> (or values)
07:16:52 <vixey> cads, guess not then
07:17:14 <cads> vixey, no
07:17:33 <cads> sorry, my brain's stuck on a seeming paradox
07:17:55 * quicksilver hands cads a mirror in the shape of a klein bottle
07:18:19 <cads> you know those things only exist in 4 dimensions?
07:18:33 * cads feels better though
07:18:41 <vixey> cads, (looking at ST might help to understand IO)
07:19:04 * BMeph wonders what a Kleene bottle looks like...
07:19:31 <cads> much like a tequila bottle..
07:19:44 <Holle_> int myVariable -> change(myVariable, 2) -> doSomethingElse -> print(myVariable)
07:19:58 <vixey> Holle_, you're learning C?
07:20:08 <Holle_> no
07:20:12 <drdozer> right, I've butchered some Parsec together, and tried to process af= file using 'parseFromFile, but my parser seems to read off the end of the file and get confused
07:20:13 <vixey> Holle_, so chane -> into >>=
07:20:27 <vixey> Holle_, and  int myVariable  should be making a new STRef
07:20:30 <drdozer> "unexpected end of input \ expecting "\t" or new-line
07:20:44 <Botje> drdozer: add an eof somewhere?
07:20:54 <vixey> Holle_, but also for the moment, change the print to just return (show myVariable)
07:21:06 <drdozer> Botje: is that not handled for me by parseFromFile?
07:21:06 <cads> vixey, I feel like i'm at the edge of the epiphany i'm lookin' for
07:21:30 <Workybob> @where blobs
07:21:30 <lambdabot> http://haskell.org/Blobs
07:21:30 <Deewiant> drdozer: end of file is but end of input isn't
07:21:43 <Botje> you have to explicitly match eof anyway to ensure you don't parse part of the file and skip the rest as garbage :)
07:21:45 <Deewiant> drdozer: your parser could be used on a plain String, after all
07:21:57 <Holle_> Unresolved overloading *** Type       : Monad a => a [[[Integer]]]
07:22:10 <vixey> cads, the point is that (like IO), ST can do 'real' mutation, but ST is simple enough you can do a pure implementation of it (with worse algorithmic complexity) but looking at it as just a model of mutation like that should help to see why IO can be pure in the same way
07:22:12 <cads> I think i'll run across something that say 'this! this is the code that lets us encapsulate state and preserve referential transparency'
07:23:45 <cads> hmm, constructing it from scratch myself probably is the best way
07:27:02 <drdozer> I've tried "parseFromFile (do { tf <- tabfile ; eof ; return tf }) myFile.tab" but I still get the same error
07:27:57 <dmead> what error
07:28:57 <drdozer> the one saying it can't read \t or \n, and giving a line-number that's one beyond the end of the file
07:29:02 <Botje> drdozer: paste your code and input, then
07:29:08 <quicksilver> drdozer: it's hitting the end of a file when it things it still has something to prase
07:31:20 <drdozer> pastebin.com/m16395323
07:31:53 <mmorrow> a garbage collector (for IntMap heaps) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=728
07:32:20 <Saya> Hey, are there any good SDL bindings for haskell ?
07:32:34 <mmorrow> not looking forward to writing that in C ;)
07:33:05 <EvilTerran> drdozer, does your parser demand a final newline that you aren't giving it, perhaps?
07:33:37 <maltem> that's indeed the case
07:33:37 <drdozer> EvilTerran: I'm feeding it a file containing one line of tab-del text with a single new-line
07:33:53 <maltem> oh, or maybe not then...
07:34:06 <lilac> are there any commonly-used monads where this does not hold: "fail str >>= f == fail str"
07:34:35 <drdozer> wc -l test.tab says it has 2 lines
07:35:09 <EvilTerran> drdozer, I'm suspicious of (many $ anyChar)
07:35:34 <maltem> drdozer: wait then you would have 2 newlines, if it is GNU wc
07:35:35 <quicksilver> lilac: (subject to concern about exactly what == means) no, I think that one is pretty safe.
07:35:36 <EvilTerran> as soon as that gets run, it'll gobble up the rest of the file
07:35:56 <EvilTerran> leaving the "newline" on the next line of the do-block unsatisfiable
07:36:19 <drdozer> Evilterran: so replace that with not \t \n?
07:36:21 <EvilTerran> (likewise the tabC)
07:36:27 <Olathe> Is there a return that takes multiple arguments for a list, but works with other monads ?
07:36:38 <vixey> mmorrow: hp  :: Ptr p  "hp" is short for something?
07:36:48 <mmorrow> heap pointer
07:36:55 <EvilTerran> drdozer, perhaps (many $ noneOf "\t\n")
07:37:03 <mmorrow> just the start of the free space
07:37:14 <vixey> @src Cont
07:37:15 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:37:17 <mmorrow> (as if the IntMap was a block of mem)
07:37:28 <mmorrow> that monad also is just a cps State
07:37:41 <EvilTerran> drdozer, also, sepBy and the like are really intended to be used infix
07:37:57 <EvilTerran> "x `sepBy` y" = "list of xs, separated by ys"
07:37:59 <mmorrow> (i had the code for that handy, and the cps version is actually way faster too)
07:38:12 <drdozer> EvilTerran: that's done it - thanks
07:38:43 <quicksilver> Olathe: what would you like it to do, in other monads?
07:39:00 <EvilTerran> ?type mconcat . map return
07:39:02 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => [a] -> m a
07:39:22 <drdozer> I didn't realise that many anyChar would be greedy and not back off
07:39:24 <EvilTerran> > mconcat . map return $ [1..10] :: [Int]
07:39:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:39:29 <quicksilver> ?type msum . map return
07:39:31 <EvilTerran> > mconcat . map return $ [1..10] :: Maybe Int
07:39:31 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
07:39:32 <lambdabot>       No instance for (Monoid Int)
07:39:32 <lambdabot>        arising from a use of `mconcat' at ...
07:39:39 <EvilTerran> ah, yes, msum, not mconcat.
07:39:43 <EvilTerran> i'm always getting those mixed up
07:39:43 <idnar> > msum . map return $ [1..10] :: [Int]
07:39:43 <quicksilver> EvilTerran: I wonder if that's what you meant.
07:39:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:39:46 <idnar> > msum . map return $ [1..10] :: Maybe Int
07:39:48 <lambdabot>   Just 1
07:39:49 <idnar> heh
07:40:05 <quicksilver> drdozer: Parsec is always absolutely greedy.
07:40:10 <quicksilver> drdozer: that's why I never use it.
07:40:13 <Olathe> quicksilver: Take the first element.
07:40:16 <idnar> quicksilver: what do you use?
07:40:18 <quicksilver> I reject that as a design decision for a parser library.
07:40:21 <Olathe> Ahh.
07:40:27 <mmorrow> vixey: pretty much, it's just doing a standard "reachable", but instead of keeping a "seen" set, it copies nodes the the "to" heap, overwrites that node with a forwarding ptr in the "from" heap, and follows its pointers.
07:40:32 <Olathe> > msum [2, -2] :: Maybe Int
07:40:33 <lambdabot>       No instance for (Num (Maybe Int))
07:40:33 <lambdabot>        arising from the literal `2' a...
07:40:44 <Olathe> > msum.map return $ [2, -2] :: Maybe Int
07:40:45 <lambdabot>   Just 2
07:40:46 <quicksilver> idnar: in every case I've ever needed it, I've simply knocked together my own parser combinators.
07:40:52 <Olathe> > msum.map return $ [2, -2] :: [Int]
07:40:53 <lambdabot>   [2,-2]
07:40:56 <quicksilver> idnar: if I wanted a library, I tend towards polyparse
07:40:58 <Olathe> Ahh, thanks :)
07:41:23 <mmorrow> and "copy" returns (among other things) a function to update that node's ptrs once you resolve them
07:42:20 <mmorrow> but you have to put a node into the `to' heap *before* you resolve its ptrs, so that if you ever cycle back, you'll see the forwarding ptr and know to stop
07:42:49 <mmorrow> and that's (apparently) the same idea when ghc resolves class constraints
07:43:27 <mmorrow> it has to put the instance it's trying to justify into the graph *before* it starts resolving the constraints. that way it can handle cyclic class constraints
07:43:39 <sw17ch> is it possible to write a sum that doesn't overflow the stack? i was thinking CPS style at first, but either i'm doing it wrong, or it's not possible. :)
07:43:48 <mmorrow> (i made that connection after the fact)
07:44:05 <vixey> interesting
07:44:24 <maltem> sw17ch: you mean, like Prelude.sum, but not fail on large lists? Of course that can be written!
07:45:15 <sw17ch> maltem: yes, that's the one
07:45:21 <sw17ch> i'm justn ot able to come up with the solution
07:45:22 <sw17ch> :)
07:45:44 <maltem> sw17ch: the trick is to use seq, or instead of using seq by hand, use foldl'
07:45:52 <BONUS> foldl' (+) 0
07:45:53 <BONUS> :]
07:46:03 <maltem> > foldl' (+) 0 [1..10^8]
07:46:09 <lambdabot>   5000000050000000
07:46:22 <sw17ch> @index foldl'
07:46:23 <lambdabot> Data.List
07:46:52 <maltem> sw17ch: it's sometimes useful just to define sum' = foldl' (+) 0
07:47:27 <sw17ch> @src foldl'
07:47:27 <lambdabot> foldl' f a []     = a
07:47:27 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:47:34 <sw17ch> ahhh....
07:48:05 <sw17ch> yes, see, i was building up the continuation without forcing the evaluation thus far
07:48:21 * sw17ch hates it when he forgets to be lazy or that he's being lazy
07:48:26 <yottis> is there btw a reason product doesn't just stop traversing if it encounters a 0 in the list?
07:48:43 <vixey> yottis, it doesn't currently?
07:48:44 <quicksilver> yottis: Yes. (*) isn't written like that.
07:48:53 <augustss> yottis: it would assume 0*x=0
07:48:57 <quicksilver> yottis: it could be, but that would make it much slower.
07:49:10 <vixey> > 0 * infinity
07:49:11 <lambdabot>   0
07:49:27 <quicksilver> if (*) had to short-circuit out for 0 we couldn't use machine code ops for it any more.
07:49:31 <vixey> > product ([2, 3, 5, 0] ++ [1..] ++ [infinity])
07:49:35 <quicksilver> well, it would certainly be hard to get that right
07:49:40 <quicksilver> for a small benefit
07:49:41 <yottis> iirc there was a newtype wrapper Product somewhere in the monoid or monad modules, but it behaved exactly the same too
07:49:53 <maltem> vixey: floating-points are usually a bad argument, they always behave different from everything else ;)
07:50:09 <yottis> which was a slight turnoff, you'd think that's the stuff you use a monoid for anyway
07:50:09 <vixey> maltem, I don't know about floats
07:50:32 <lambdabot>   mueval: Prelude.read: no parse
07:51:04 <maltem> @src Product
07:51:05 <lambdabot> Source not found. I feel much better now.
07:51:08 <maltem> @src Prod
07:51:08 <lambdabot> Source not found. Sorry.
07:51:09 <jeltsch> dcoutts_: I have deprecated boxPackStartDefaults and boxPackEndDefaults. Now the building problems are even worse.
07:51:19 <maltem> @src Sum
07:51:19 <lambdabot> Source not found.
07:51:22 <maltem> bah
07:51:40 <yottis> quicksilver, but it's not (*) that is a problem, but product itself
07:51:53 <quicksilver> well, product is just a fold over (*)
07:51:57 <quicksilver> which is fair enough in my opinion.
07:52:04 <jeltsch> I have done a darcs whatsnew on the respective file.  darcs told me that this file isnât even in the repository.  On the other hand it was able to give me a diff.  So to what version is this file compared?  Iâm confused.
07:52:09 <quicksilver> You could ask for a short-circuiting (*), which would sovle the problem.
07:52:14 <quicksilver> But I think it's not worth it.
07:52:22 <dcoutts_> jeltsch: of course at any stage you can give up, send in the patches you've got so far and not use --disable-deprecated
07:52:24 <SamB_XP> not for Int, no ;-P
07:52:27 <SamB_XP> or Integer
07:52:31 <yottis> it is, the short-circuiting product just would have to use some kind of a short-circuiting fold
07:53:01 <maltem> jeltsch: Maybe the diff is just the whole file?
07:53:01 <quicksilver> yottis: sure, you could solve it in hte product if you like.
07:53:03 <vixey> mmorrow, and gc is a monad so that you can perfrom a GC incrementally ?
07:53:09 <quicksilver> But if I was going to solve it, I'd solve it in the (*).
07:53:14 <PeakerWork> quicksilver: short circuiting on (*) might be worth it if at least one of the sides is significantly more expensive to compute than (*)
07:53:26 <EvilTerran> x |*| y = f x y `unamb` f y x where f 0 y = 0; f x y = x * y
07:53:34 <quicksilver> PeakerWork: ...and if 0 occurs often enough for it to be worth it.
07:53:38 <PeakerWork> quicksilver: yeah
07:53:54 <PeakerWork> quicksilver: adaptive (*) based on automatic runtime profiling could be nice :-)
07:53:57 <vixey> @src unamb
07:53:57 <lambdabot> Source not found. Are you on drugs?
07:53:57 <EvilTerran> usually, when you're finding the product of a list of numbers, you don't expect it to be 0
07:53:58 <jeltsch> dcoutts_: Was it correct to edit Box.chs? Itâs not a .pp file.
07:54:15 <dcoutts_> jeltsch: no, it has to be a .chs.pp
07:54:22 <vixey> why really use unamb instead of computation monad...
07:54:27 <augustss> I would object strongly to changing * so 0*x is 0.  I often make instances where this is not true.
07:54:45 <PeakerWork> You could use Nothing to represent 0, and (Just x) to represent numbers, and using   foldr (liftA2 (*)) (pure 1)  :-)
07:54:56 <jeltsch> dcoutts_: Do you know how darcs could know what I have changed in the .chs file if itâs not in the repository?
07:54:56 <EvilTerran> vixey, why use par instead of STM?
07:55:04 <vixey> idk
07:55:08 <vixey> because par doesn't do anything
07:55:10 <EvilTerran> lightweightness
07:55:24 <sw17ch> is there ever a case where sum wouldn't be strict?
07:55:26 <mmorrow> vixey: i made it a monad to wrap the heap state so it wouldn't be hellish juggling stuff, but re incrementally. i'm not sure exactly how concurrent gc's are done, but i want to find out.
07:55:34 <PeakerWork> EvilTerran: it seems a lot easier to use par...
07:55:36 <sw17ch> and/or is there a good reason sum isn't defined in terms of seq?
07:55:41 <sw17ch> and/or foldl'
07:55:42 <sw17ch> :)
07:55:46 <PeakerWork> @src sum
07:55:46 <lambdabot> sum = foldl (+) 0
07:55:53 <EvilTerran> par and unamb can slot into pure code, the finer-grained approaches tend to get you stuck in a monad
07:56:02 <PeakerWork> sw17ch: maybe for non-int[eger] instances of Num?
07:56:03 <mmorrow> vixey: but i don't think you could do it incrementally with that algo
07:56:09 <vixey> ok
07:56:15 <yottis> PeakerWork's solution looks like what i'd write if i were experienced enough to know all that applicative turf
07:56:17 <jeltsch> dcoutts_: Hmm, itâs in _darcs/pristine but darcs tells me that itâs not in the repo.
07:56:19 <maltem> sw17ch: you could in _theory_ have a number type where (+) isn't strict
07:56:20 <PeakerWork> > sum [a,b]
07:56:21 <lambdabot>   0 + a + b
07:56:27 <vixey> par and unamb use side effects btw
07:56:35 <dcoutts_> jeltsch: gtk/Graphics/UI/Gtk/Abstract/Box.chs is in the repo, there is no .pp version for that file
07:56:52 <maltem> maltem: for example, peano numbers (not extremely perfomant though anyways ;)
07:56:58 <maltem> er
07:57:00 <maltem> sw17ch: ^^
07:57:01 <sw17ch> hahahah
07:57:02 <vixey> pure code that is spawning a thread.......
07:57:02 <sw17ch> :P
07:57:06 <mmorrow> vixey: http://pure.ltu.se/ws/fbspretrieve/901432
07:57:06 <sw17ch> talking to your self now eh?
07:57:10 <jeltsch> dcoutts_: So is it correct to change the .chs instead of an .pp in this case?
07:57:12 <PeakerWork> @src product
07:57:12 <lambdabot> product = foldl (*) 1
07:57:19 <mmorrow> that's timber's gc + a correctness proof
07:57:25 <mmorrow> looks sweet
07:57:27 <dcoutts_> jeltsch: right
07:57:28 <EvilTerran> vixey, par's side-effects don't affect semantics, though, and neither do unamb's if you follow the associated rules
07:57:35 <maltem> sw17ch: I won't appreciate any further comments on that :-P
07:57:38 <dcoutts_> jeltsch: erm, sorry, no, it's not right
07:57:48 <vixey> morrow, have you seen Greg Morrisetts one
07:57:57 <PeakerWork> > let product = maybe 0 id . foldl (liftA2 (*)) (pure 1) in product [Just 5, Just 6, Nothing, Just 3]
07:57:58 <lambdabot>       Ambiguous occurrence `pure'
07:57:58 <lambdabot>      It could refer to either `Control.Appl...
07:58:00 <vixey> and well I think there are several authors but I remember his name
07:58:00 <dcoutts_> jeltsch: we'd have to convert it to a .chs.pp first
07:58:03 <mmorrow> vixey: i haven't
07:58:05 <PeakerWork> > let product = maybe 0 id . foldl (liftA2 (*)) (Control.Applicative.pure 1) in product [Just 5, Just 6, Nothing, Just 3]
07:58:07 <lambdabot>   0
07:58:10 <vixey> I'll see if it's online
07:58:14 <mmorrow> cool
07:58:20 <EvilTerran> @let app = Control.Applicative.pure -- to go with arr
07:58:22 <lambdabot>  Defined.
07:58:32 <mmorrow> crap, i have to run. i'll catch you later vixey.
07:58:38 <vixey> bye
07:58:46 <jeltsch> dcoutts_: How complicated is thatÃ
07:59:03 <dcoutts_> jeltsch: darcs mv  and also change the entry in Makefile.am
07:59:06 <quicksilver> sw17ch: catching up : no, just a bad reason.
07:59:19 <PeakerWork> > let toMaybe 0 = Nothing ; toMaybe x = x ; product = maybe 0 id . foldl (liftA2 (*)) (app 1) . map toMaybe in product [5, 6, 0, 3]
07:59:20 <lambdabot>       Ambiguous occurrence `app'
07:59:20 <lambdabot>      It could refer to either `L.app', defin...
07:59:21 <quicksilver> it's a poor idea to restrict the utility of a basic prelude function
07:59:21 <jeltsch> dcoutts_: But the content can stay the same?
07:59:32 <quicksilver> because someone *might* define a non-strict Num instance.
07:59:33 <PeakerWork> @let appp = Control.Applicative.pure
07:59:34 <lambdabot>  Defined.
07:59:38 <PeakerWork> > let toMaybe 0 = Nothing ; toMaybe x = x ; product = maybe 0 id . foldl (liftA2 (*)) (appp 1) . map toMaybe in product [5, 6, 0, 3]
07:59:38 <lambdabot>       No instance for (Num (Maybe a))
07:59:39 <lambdabot>        arising from a use of `toMaybe' ...
07:59:48 <quicksilver> If you define a non-strict Num instance, you can fold your own (+), damnit.
07:59:51 <sw17ch> quicksilver: alright. i wonder if it would make sense to have a bunch of specialized versions of these functions
07:59:52 <PeakerWork> > let toMaybe 0 = Nothing ; toMaybe x = Just x ; product = maybe 0 id . foldl (liftA2 (*)) (appp 1) . map toMaybe in product [5, 6, 0, 3]
07:59:53 <lambdabot>   0
08:00:05 <EvilTerran> let's just have sum and sum'
08:00:10 <SamB_XP> I don't see the point in product using foldl ...
08:00:19 <quicksilver> sw17ch: the strictness analyser gets it right sometimes.
08:00:27 <PeakerWork> quicksilver: could be nice if we didn't have duplicate code for differing strictness :-(
08:00:28 <sw17ch> does it now? cool
08:00:41 <sw17ch> it didn't seem to catch it in my trivial case :(
08:00:47 <vixey> @tell mmorrow There is tag free gc in polymorphic languages http://reports-archive.adm.cs.cmu.edu/anon/1996/CMU-CS-96-176.ps
08:00:47 <lambdabot> Consider it noted.
08:00:48 <dcoutts_> jeltsch: right
08:00:49 <quicksilver> SamB_XP: it uses fold so that the strictness analyzer can optimise it to foldl'.
08:01:02 <quicksilver> SamB_XP: if it used foldr, the strictness analyzer would not be able to help.
08:01:16 <quicksilver> sw17ch: with -O2 ?
08:01:25 * lilac wonders whether it's possible to prove that fail x >>= f == x
08:01:27 <sw17ch> quicksilver: .... damnit
08:01:40 <quicksilver> lilac: I think you have to take it as a law.
08:01:48 <quicksilver> lilac: how else will you reason about the behaviour of fail?
08:01:53 <quicksilver> lilac: you need some law to govern it.
08:02:10 <SamB_XP> quicksilver: the commitee was very optimistic, wasn't it!
08:02:10 <vixey> EvilTerran, I don't like that argument... just because it's operational concerns doesn't to me mean that it is pure
08:02:39 <sw17ch> quicksilver: yeah, i forgot that the strictness analysis doesn't run until you hit the optimization button
08:02:42 <PeakerWork> lilac: you mean (fail x)>>=f == (fail x) ?
08:02:48 <EvilTerran> vixey, eh, ok; i just like things like par and unamb because i can say "look how easy parallelism is in haskell!" and point at them :P
08:03:03 <quicksilver> SamB_XP: I think it slipped between the cracks in a way.
08:03:05 <redditbot> Monadic and Queue-Based Tree Search
08:03:07 <lilac> quicksilver: indeed. however, "(forall a. m a) -> (b -> m c) -> m c" can't have many inhabitants
08:03:14 <lilac> PeakerWork: yes, of course ;-) oops
08:03:15 <quicksilver> SamB_XP: I do think the current compromise is nonsensical
08:03:29 <quicksilver> SamB_XP: maybe augustss remembers something about it ;)
08:03:38 <vixey> EvilTerran, I tried to use par but it just makes my benchmark run slower :?
08:03:56 <augustss> quicksilver: huh? what? who?
08:04:05 <SamB_XP> I think maybe the problem is that spj is not comfy enough
08:04:17 <quicksilver> augustss: maybe you remember something about why sum is "foldl"
08:04:25 <quicksilver> given that foldl' is what you want for strict
08:04:25 <SamB_XP> (or perhaps the commitee should have just bought chairs rather than sitting on him ?)
08:04:30 <quicksilver> and foldr for lazy
08:04:39 <quicksilver> and foldl is just the bad compromise between the two.
08:05:12 <augustss> quicksilver: sum was written before the was a foldl' (before seq).  And it has stayed that way.
08:05:20 <lilac> in "fail x >>= f", the only (seq-free) possible use of f is "f undefined". so i think in that case we must have either "(>>=) = const", a call of "f undefined", or a monad where 'm a' can be constructed without an a.
08:05:30 <SamB_XP> augustss: that doesn't really explain the foldl ...
08:06:05 <fasta> Is there an auto cabal package already which takes the program in the current directory and uploads it to hackage after it has shown what it is going to send?
08:06:27 <augustss> SamB_XP: No.  I think it was changed from foldr to foldl so that all specialized instances of sum would behave properly.
08:06:57 <dcoutts_> fasta: not quite, cabal upload --check dist/foo-1.0.tar.gz  does something like that though
08:07:08 <augustss> SamB_XP: At least if you inline foldl and do strictness analysis
08:07:53 <conal> btw, recent versions of unamb have combinators for commutative ops, identity arguments and annihilators (http://hackage.haskell.org/packages/archive/unamb/latest/doc/html/Data-Unamb.html)
08:08:03 <fasta> dcoutts_: oh, and we need man cabal working too :)
08:08:43 <dcoutts_> fasta: I await your patch :-)
08:09:00 <conal> and some special cases: parallel and, or, min, max, and multiply
08:11:15 <yottis> it'd be useful to have a function toMaybe p v = if p v then Just v else Nothing
08:11:39 <dons> that's  a useful function, yeah
08:12:09 <vixey> huh...
08:12:16 <yottis> it'd be useful to handle division by zero errors too
08:12:19 <vixey> you can use:  bool Nothing (Just v)
08:12:30 <vixey> (bool has the obvious definition)
08:12:42 <vixey> oh wait
08:12:51 <vixey> I misunderstood, why do you actually check p v? instead of p?
08:13:04 <vixey> @src guard
08:13:04 <lambdabot> guard True  =  return ()
08:13:04 <lambdabot> guard False =  mzero
08:13:48 <gnuvince_> :t guard
08:13:50 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:13:59 * lilac is still pushing for (<?>) :: MonadZero m => Bool -> a -> m a; (<:>) :: Maybe a -> a -> a
08:14:04 <yottis> so i can say intToMaybe = toMaybe (/= 0)
08:14:19 <lilac> s/MonadZero/MonadPlus/ (grr)
08:14:40 <vixey> yottis, is your program in the maybe monad?
08:14:51 <vixey> yottis, if not, may be easier, then you can use guard
08:15:02 <yottis> well yes.. or PeakerWork's actually
08:15:14 <yottis> previous product
08:15:28 <quicksilver> yottis: I also find that useful sometimes.
08:15:42 <PeakerWork> @let toMaybe 0 = Nothing ; toMaybe x = Just x
08:15:43 <lambdabot>  Defined.
08:15:48 <quicksilver> You can express it as guard p v >> return v
08:15:54 <quicksilver> but that's not really "better"
08:15:55 <lilac> @let b <?> x = guard b >> return x; (<:>) = flip fromMaybe
08:15:56 <lambdabot>  Defined.
08:16:09 <lilac> > True <?> 42 <:> 76
08:16:10 <PeakerWork> @let fromMaybe = maybe 0 id
08:16:11 <lambdabot>  <local>:6:44:
08:16:11 <lambdabot>      Ambiguous occurrence `fromMaybe'
08:16:11 <lambdabot>      It could refer to e...
08:16:11 <lambdabot>   42
08:16:11 <quicksilver> @pl \v -> guard p v >> return v
08:16:11 <lambdabot> ap ((>>) . guard p) return
08:16:26 <PeakerWork> @let fromMaybe = maybe 0 id :: Num a => Maybe a -> a
08:16:26 <lambdabot>  <local>:6:44:
08:16:26 <lambdabot>      Ambiguous occurrence `fromMaybe'
08:16:26 <lambdabot>      It could refer to e...
08:16:28 <Twey> wireddd: True, but it's OK if you just stay away from the more questionable features
08:16:35 <lilac> PeakerWork: fromMaybe already exists
08:16:38 <lilac> @index fromMaybe
08:16:38 <PeakerWork> oops
08:16:38 <lambdabot> Data.Maybe
08:16:44 <PeakerWork> @let maybeToInt = maybe 0 id
08:16:45 <lambdabot>  Defined.
08:17:00 <PeakerWork> @let intToMaybe 0 = Nothing ; intToMaybe x = Just x
08:17:01 <lambdabot>  Defined.
08:17:05 <lilac> maybeToInt = (<:> 0)
08:18:07 <PeakerWork> > let product = maybeToInt . foldl (liftA2 (*)) (appp 1) . map intToMaybe in product [a, b, c]
08:18:09 <lambdabot>   1 * a * b * c
08:18:11 <PeakerWork> > let product = maybeToInt . foldl (liftA2 (*)) (appp 1) . map intToMaybe in product [a, b, 0, c]
08:18:13 <lambdabot>   0
08:18:15 <lilac> what would you name a module containing my <?> and <:>? Control.TernaryConditional ?
08:18:36 <PeakerWork> @type foldl (liftA2 (*)) (appp 1)
08:18:37 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => [f a] -> f a
08:20:13 <conal> lilac: personally i avoid "Control", which to me has imperative/sequential connotations.
08:20:41 <conal> lilac: and ?: is not especially controlish in a lazy language.
08:20:57 <EvilTerran> lilac, what types are you going for?
08:21:53 <Olathe> @type liftA2
08:21:54 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:21:56 <centrinia> Why not have  { data IfThenElse a = Bool <?> a <:> a; }  ?
08:22:03 <lilac> EvilTerran: (<?>) :: MonadZero m => Bool -> a -> m a; (<:>) :: Maybe a -> a -> a
08:22:31 <EvilTerran> lilac, ah, excellent, that's my favourite formulation too
08:22:32 <Olathe> > liftA2 (*) [a, b, c] [d, e, f]
08:22:33 <lambdabot>   [a * d,a * e,a * f,b * d,b * e,b * f,c * d,c * e,c * f]
08:22:37 <lilac> centrinia: because (1) that's not legal, and (2) the individual components make sense by themselves
08:22:41 <Olathe> > liftM2 (*) [a, b, c] [d, e, f]
08:22:42 <EvilTerran> lilac, although i'd be tempted to go for Alternative instead of MonadZero
08:22:42 <lambdabot>   [a * d,a * e,a * f,b * d,b * e,b * f,c * d,c * e,c * f]
08:23:09 <Olathe> @src liftA2
08:23:09 <lambdabot> liftA2 f a b = f <$> a <*> b
08:23:13 <vixey> centrinia, because itt's invalvid syntax ...?
08:24:19 <lilac> EvilTerran: (<?>) :: Alternative f => Bool -> a -> f a; (<:>) :: Alternative f => f a -> a -> f a ?
08:24:41 <lilac> EvilTerran: that's unfortunately ambiguous in simple cases such as "True <?> a <:> b"
08:25:06 <EvilTerran> lilac, nah, i'd have <:> only do Maybe; i'd just use Alternative for <?>
08:25:46 <lilac> Alternative is still a bit heavyweight (but yes, better than MonadPlus).
08:26:15 <EvilTerran> although i'd be tempted to not call them <?> and <:>, because <?> is taken by parsec (and, i think, other parser combinator libs as a result), and <:> isn't general over Applicative (or a subclass)
08:26:30 <lilac> >?< and >:< ? :)
08:27:09 <EvilTerran> i think i've called them ?? and ?: when playing with them
08:28:34 <EvilTerran> unconvinced by that, though
08:28:57 <EvilTerran> flip the first one, and call them (Â¿) and (?)? :P
08:29:11 <lilac> hehe
08:29:12 <EvilTerran> x Â¿p? y
08:29:59 <EvilTerran> or, more sanely, flip the first one and call them <? and ?>
08:31:31 <EvilTerran> it's no longer much like the C syntax, but i've seen it used in CSP and the like
08:31:35 <lilac> whatever it's called, i'm wondering whether the second one ought to go into Data.Maybe
08:31:51 <EvilTerran> and the first in Control.Applicative?
08:31:58 <lilac> that might be slightly odd ;-)
08:32:01 <EvilTerran> yeah
08:32:15 <lilac> but a possibility
08:32:25 <EvilTerran> could put them both in Control.Applicative, if they're intended to go together
08:32:50 <EvilTerran> aha! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
08:33:01 <EvilTerran> Control.Applicative.Infix would do nicely for <? and ?>
08:33:48 <lilac> that sounds like a good home.
08:34:23 <lilac> although in "x <? b ?> y" i'd worry that it's not obvious which is the 'true' and which is the 'false' branch
08:34:54 <EvilTerran> in CSP and suchlike things, true tends to be on the left
08:36:00 <ikegami__> I guess using 'unsafePerformIO'
08:36:03 <ikegami__> oops
08:36:04 <conal> lilac: nice formulation via Maybe.
08:36:17 <ikegami__> I have to finish to write again
08:36:45 <ikegami__> I expect that in general using 'unsafePerformIO' is harmful
08:36:46 <EvilTerran> i'd avoid guesswork when using unsafePerformIO ;)
08:37:15 <ikegami__> however, I couldn't find a webpage about the issue
08:37:21 <EvilTerran> there are circumstances when using unsafePerformIO is permissable
08:37:38 <EvilTerran> without breaking the semantics
08:37:52 <Saya> for logging i suppose
08:38:00 <EvilTerran> when the IO action is genuinely side-effect-less, and will always return the same thing, unsafePerformIO is okay
08:38:02 <ikegami__> right
08:38:13 <vixey> not true...
08:38:42 <EvilTerran> vixey, ?
08:38:47 <vixey> in that case, unsafePerformIO is pointless
08:39:12 <EvilTerran> ...
08:39:18 <Saya> yeah why would you need IO if you dont do side effects?
08:39:21 <ikegami__> Simon's paper describes when unsafePerformIO is not so dangerous : http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf
08:39:23 <vixey> you use it for an IO side effect
08:39:24 <EvilTerran> by "side-effect-less", i mean its side-effects are wholly self-contained
08:39:28 <vixey> aha
08:39:31 <vixey> Yes
08:39:34 <EvilTerran> sorry, overstated it a bit the first time :P
08:39:49 <Gracenotes> :O I found a language that has dynamic closures! (sorta)
08:40:10 <quicksilver> well, for FFI bindings
08:40:17 <loop_> what's a "dynamic" closure?
08:40:17 <quicksilver> which is why unsafePerformIO is in the FFI spec.
08:40:28 <vixey> Gracenotes, yeah would be interested in a definition
08:40:34 <EvilTerran> ST, for instance, uses mutable memory, and hence has side-effects under-the-hood
08:40:44 <ikegami__> however, I'm afraid that a newbie want to use 'unsafePerformIO' for removing 'IO' from 'IO a'
08:41:00 <lilac> heh. (<?>) :: ArrowZero a => Bool -> a b b
08:41:04 <Gracenotes> vixey: well, dynamic scope would be a better word. But it's a closure in that everything that's defined in the scope stays in the scope
08:41:08 <vixey> ikegami__, a lot of times that has been asked :p
08:41:09 <Saya> exept no good haskell tutorial introduces unsafePerformIO before the end
08:41:15 <EvilTerran> but they're all contained within the action passed to runST, so it's safe to use unsafePerformIO internally (which i believe it does)
08:41:27 <EvilTerran> ikegami__, that's why it's got "unsafe" in the name
08:41:32 <vixey> Gracenotes, that sounds normal
08:41:54 <ikegami__> vixey: I expected, therefore I'm looking a kind guide in Web
08:42:01 <Saya> it should be UNSAFE!!10101performIO to make a better statement
08:42:03 <Gracenotes> I don't think it would be a huge stretch to call it a dynamic closure, though. Although unusual
08:42:25 <vixey> Gracenotes, that sounds like the normal behavior though
08:42:30 <Gracenotes> ...yes :)
08:42:40 <Saya> what would a static closure be?
08:42:40 <vixey> Gracenotes, just describes closer over scope.. not sure why it's 'dynamic'
08:42:46 <int80_h> or UnsafeHURTUBADIO
08:42:53 <Gracenotes> vixey: as opposed to lexical
08:42:54 <vixey> Saya, lets find out what a dynamic one is first :/
08:43:15 <vixey> Gracenotes, I meant.. what you described, sounds to me, like a lexical closure
08:43:16 <Olathe> I'm more afraid that some newbie might want to use C++.
08:44:44 <ikegami__> for example, in the HaskellWiki, the dangerous of unsafe* has been not described yet (it is a stub) : http://www.haskell.org/haskellwiki/UnsafePerformIO
08:45:06 <Gracenotes> vixey: it's not lexical; in Factor, which I've been learning on-and-off in the last dozen hours, you can pass a quotation -- a sequence of code kind of like a function -- on the stack, and make the words used by the quotation mean something else
08:45:24 <Gracenotes> the quotation, however, is not in the lexical scope. It's on the stack somewhere, heaven knows how it got there
08:45:51 <Gracenotes> it's quite fun :)
08:46:46 <quicksilver> Gracenotes: that's no different from passing a literal list around a lisp dialect which uses dynamic binding, is it?
08:46:51 <Saya> well the stack is kindov like the scope
08:47:02 <ikegami__> I realized that unsafePerformIO is UNSAFE, but, how to explain my friends?
08:47:38 <EvilTerran> "it say's 'unsafe', it's in a module called 'unsafe', just trust me on this one" :P
08:47:47 <Gracenotes> quicksilver: not sure, I have yet to do anything with a Lisp dialect beyond arithmetic and basic function-passing
08:47:54 <ikegami__> hehe
08:48:51 <cizra> ikegami__: Suggest using a rubber with that one.
08:49:09 <Gracenotes> in a sense the feature does re-bind a word to have a different definition/behavior in a non-lexical way
08:49:19 <quicksilver> Gracenotes: yes.
08:49:23 <quicksilver> Gracenotes: but that's a very comment feature.
08:49:25 <quicksilver> common
08:49:25 <wjt> ikegami__: show them how to write cast :: a -> b with it
08:49:35 <quicksilver> it is, for example, standard in lisp.
08:49:44 <lilac> ikegami__: you could say, "the compiler will assume that the result is referentially transparent, and will optimize accordingly"
08:49:45 <quicksilver> and perl/python like languages.
08:50:01 <lilac> ikegami__: "if it's not, then /anything/ could happen"
08:50:02 <Gracenotes> how so in python?
08:50:22 <quicksilver> functions are looked up in the global scope at call time
08:50:29 <quicksilver> if you mess with the contents of global scope
08:50:34 <quicksilver> they'll do something different next time.
08:50:43 <Gracenotes> in Factor the global scope isn't changed, though
08:50:48 <EvilTerran> the perl module system is kinda built from this
08:50:55 <quicksilver> sure, but that's just a detail.
08:51:11 <quicksilver> you can build a setup in python which modifies the global scope and then restores it
08:51:12 <EvilTerran> "use Export" is, anyway
08:51:23 <quicksilver> perl has "local" which is explicitly for this.
08:51:27 <quicksilver> dynamic scope is not unusual.
08:51:36 <quicksilver> it is, however, hideously ugly, bugridden, and generally evil ;)
08:51:38 <quicksilver> but it's not unusual.
08:51:42 <athos> hi all!
08:51:52 <ikegami__> lilac: your answer satisfies me
08:52:05 <Gracenotes> quicksilver: "local" means that any function not in the lexical scope will act different when you call it and a "local" is around?
08:52:12 <Gracenotes> *differently
08:52:26 <chessguy_work> @undo do { x <- foo; return (bar x); }
08:52:26 <lambdabot> foo >>= \ x -> return (bar x)
08:52:32 <quicksilver> the ones that you alter with the local, yes.
08:52:35 <ikegami__> and I find a thread in Haskell Cafe http://www.mail-archive.com/haskell-cafe@haskell.org/msg30544.html
08:52:35 <EvilTerran> Gracenotes, pretty much, yeah
08:52:40 <Deewiant> @pl foo >>= \x -> return (bar x)
08:52:41 <lambdabot> bar `fmap` foo
08:52:59 <Gracenotes> I'm not sure if there are HOF in Perl, but if so, if you pass any random function to a function that uses local, the former function's behavior will be changed?
08:52:59 <chessguy_work> @type ?foo >>= return . ?bar
08:53:01 <lambdabot> forall a b (m :: * -> *). (?bar::a -> b, Monad m, ?foo::m a) => m b
08:53:06 <EvilTerran> Gracenotes, it (globally) redefines a global within the scope of the  "local" decleration
08:53:41 <EvilTerran> i mean scope time-wise, not lexically
08:53:57 <Gracenotes> quicksilver: also, you'll find that the module-switching idea in Python will work poorly if concurrency is involved
08:54:05 <quicksilver> sure.
08:54:12 <atom> is there a way of doing (snd . fst) ((1,2),3) without any parantheses (other than the ones to form the tuples)?
08:54:21 <ikegami__> thanks all, I'll try to talk again that my friends that unsafePerformIO considered harmful
08:54:22 <quicksilver> python lacks a thread-safe notion of dynamic scope.
08:54:25 <quicksilver> I agree with that.
08:54:28 <Gracenotes> in Factor, as apparently in Perl, the re-binding is limited to the dynamic scope
08:54:30 <chessguy_work> atom,  snd . fst $ ((1,2),3)
08:54:35 <quicksilver> (or if it has one, I'm not aware of it)
08:54:41 <chessguy_work> > snd . fst $ ((1,2),3)
08:54:43 <lambdabot>   2
08:54:49 <vixey> ikegami__, I prefer "unsafePerformIO considered to have very limited utility"
08:54:49 <EvilTerran> > snd $ fst ((1,2),3) -- atom
08:54:50 <lambdabot>   2
08:54:55 <quicksilver> since python was designed as a single threaded language you could always use the global 'hack' for that.
08:55:02 <atom> chessguy_work: thanks. What does the $ do in the geeral case?
08:55:05 <quicksilver> and many (most?) lisps have dynamic scope.
08:55:10 <chessguy_work> @src ($)
08:55:10 <lambdabot> f $ x = f x
08:55:13 <Deewiant> > let pair = (,) in snd . fst . flip pair 3 . pair 1 $ 2
08:55:14 <ikegami__> vixey: hm. I see
08:55:14 <lambdabot>   2
08:55:15 <Saya> thats like lua's global scope its just another table called _G with whatever you want to put inside, you can mess it up all you want :)
08:55:19 <Deewiant> -- look ma, no brackets
08:55:23 <Gracenotes> so, the language has dynamic scope/closures. That's all there is -- I haven't fully learned Lisp or Perl, so it's the first language that uses the feature :)
08:55:27 <chessguy_work> atom, it doesn't "do" anything, it's just a precedence hack
08:55:28 <Gracenotes> all other languages I've used have lexical scope
08:55:41 <atom> chessguy_work: thanks, just what I wanted.
08:55:52 <chessguy_work> it keeps haskell from looking like lisp :)
08:56:02 <atom> hah, good one
08:56:08 <vixey> you can tell between Lisps and MLs
08:56:10 <Gracenotes> a lisp dialect is next on the my languages-to-learn list, thankfully
08:56:22 <vixey> Lisp starts with a paren, ML has them all shifted in one
08:56:33 <vixey> (f (g x) (h)) vs  f (g x) h
08:56:48 <vixey> C has them all shifted in one as well
08:56:52 <chessguy_work> vixey, ...
08:56:56 <Raevel> i'm not a fan of lisp :-(
08:56:58 <chessguy_work> vixey, it was a joke...
08:57:10 <vixey> Raevel, how can you not be? :p
08:57:18 <Gracenotes> Raevel: from what I've seen, the end-parens can be numerous
08:57:18 <SamB> hehe
08:57:18 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
08:57:23 <SamB> @messages
08:57:23 <lambdabot> Lemmih asked 10h 50m 29s ago: Do you have an account on code.haskell.org?
08:57:36 <SamB> @tell Lemmih no, I don't have an account on code.haskell.org
08:57:36 <lambdabot> Consider it noted.
08:58:10 <Raevel> if i want functional programming i want haskell
08:58:12 * atom gives a big thumbs-up to the creator(s) of lambdabot.
08:58:21 <chessguy_work> hey SamB, i saw something haskell-related with the name Sam Bronson on it lately. is that you?
08:58:43 <SamB> chessguy_work: what ? where ?
08:58:59 <chessguy_work> SamB, i don't recall
08:59:06 <SamB> that IS my name
08:59:31 <Raevel> of course lisp can do a lot more than just functional programming... i still find lisp hard to read
08:59:48 <Badger> SamB: stalk'd. :P
08:59:58 <chessguy_work> i want to say that it had something to do with a logic implementation in haskell
09:00:09 <atom> Raevel: I still think inventing some new types of parens is the way to go :)
09:00:27 <Raevel> atom: utf-8 has a bunch you could use, i'm sure
09:00:38 <vixey> atom, [foo bar] is better than (squibble foo bar)?
09:01:20 <SamB> some of the Unicode brackets look a lot like some of the others ...
09:01:23 <quicksilver> Yeah, being able to invent new kinds of parens is really nice actually.
09:01:32 <atom> vixey: no, but imagine what you could do with [foo (bar {baz x y} w bc )]
09:01:36 <SamB> (and I'm not talking about lefts matching rights!)
09:01:46 <quicksilver> it's a very natural way for some kinds of notation.
09:01:52 <vixey> I want this feature in Haskell.
09:01:59 <vixey> (I despise it in lisp :p)
09:02:10 <vixey> but I wrote a parser for infix infixl infixr and bracket notations
09:02:28 <vixey> but I cannot possible hack it into GHC :/
09:02:40 <saml> > $(printf "Error in file %s line %d") "asdf" 324
09:02:41 <lambdabot>   <no location info>: parse error on input `$'
09:02:56 <atom> it would definitely keep c from looking like )))))))))) on some lines :)
09:03:03 <atom> ^^ end of line example there
09:03:06 <redditbot> Using the Maybe monad in F#
09:03:33 <atom> then it would look like )]})]}
09:03:44 <atom> I guess that would make it a bit more readable
09:03:47 <atom> if a lot harder to parse
09:06:49 <int80_h> @src mod
09:06:49 <lambdabot> Source not found. It can only be attributed to human error.
09:07:15 <gugu2> hi, is there a easy way to parse java? i dont like to write a parser on my own
09:07:33 <int-e> fasta: (continuing from #ghc) do you mean  data T where T :: Num a => (a -> Bool) -> T ?
09:07:51 <Raevel> gugu2: look for an existing java parser :-)
09:08:17 <gugu2> thats what i did, but i didnt find any
09:08:21 <fasta> int-e: if that works, yes, but imho that shouldn't be necessary.
09:08:40 <Raevel> gugu2: you could also use a parser generator
09:08:44 <saml> > 1 `mod` (-32)
09:08:45 <lambdabot>   -31
09:08:58 <lilac> > ['\12308'..'\12315']
09:08:59 <lambdabot>   "\12308\12309\12310\12311\12312\12313\12314\12315"
09:09:24 <int80_h> okay mod is a function, but lambdabot doesn't know the source for it?
09:09:39 <Olathe> @type mod
09:09:40 <lambdabot> forall a. (Integral a) => a -> a -> a
09:09:42 <gugu2> yea, ive tried happy
09:09:50 <Olathe> There are lots of different mods, one for each Integral type.
09:09:59 <quicksilver> int80_h: lambdabot has a manually entered partial src database.
09:10:05 <quicksilver> it's not intended to be complete.
09:10:06 <int80_h> ooooh
09:10:07 <gugu2> but i dont like to write it on my own... ;)
09:10:11 <Olathe> gugu2: There might be a BNF parser generator.
09:10:16 <fasta> int-e: oh, and it doesn't help btw. (same error)
09:10:19 <Olathe> gugu2: I think Java has BNF specs out there.
09:10:21 <gugu2> u talking about bnfc?
09:10:23 <quicksilver> I think `mod` is a method, so potentially has a different implementation per type.
09:10:34 <Olathe> gugu2: I don't know of any.
09:10:45 <PeakerWork> @type mod
09:10:47 <lambdabot> forall a. (Integral a) => a -> a -> a
09:11:09 <int80_h> I'm doing the "is it a palindrom" exercise from RWH. Can't use mod, or course. So I was looking into implementing it myself.
09:11:14 <matthewp> @src mod
09:11:14 <lambdabot> Source not found. My pet ferret can type better than you!
09:11:19 <chrisdone> @hoogle a -> m (m a)
09:11:20 <lambdabot> Data.List inits :: [a] -> [[a]]
09:11:20 <lambdabot> Data.List tails :: [a] -> [[a]]
09:11:20 <lambdabot> Data.Tree levels :: Tree a -> [[a]]
09:11:31 <chessguy_work> int80_h, why would you use mod for that?
09:11:38 <int-e> fasta: oops. my bad. should be T :: (forall a . Num a => a -> Bool) -> T
09:11:54 <chrisdone> @hoogle Functor m => a -> m (m a)
09:11:55 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
09:11:55 <lambdabot> Data.List inits :: [a] -> [[a]]
09:11:55 <lambdabot> Data.List tails :: [a] -> [[a]]
09:12:01 <int80_h> chessguy_work: because the first thing I want to test for , is is the length of the list an even number.
09:12:02 <lilac> @src Int mod
09:12:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:12:18 <chessguy_work> int80_h, you don't hvae to do that. there's a very very simple solution
09:13:00 <int80_h> chessguy_work: okay I'll think it over.
09:13:04 <matthewp> Can someone help set up the lambdabot for #novalang for the Real World Haskell book club channel?
09:13:10 <int80_h> I'm still thinking in C
09:13:43 <igowen[work]> int80_h: think about what it means to be a palindrome
09:13:45 <chrisdone> there's a club?
09:14:21 <matthewp> chrisdone: yes, over here - http://groups.google.com/group/real-world-haskell-book-club
09:14:30 <chessguy_work> igowen[work], good clue
09:15:24 <chessguy_work> chrisdone, the #novalang channel is also studying through RWH right now, every monday night at 8 pm EST
09:15:59 <Raevel> matthewp: sure, any specific problems you're having?
09:16:04 <dons> lambdabot: @join #novalang
09:16:12 <Raevel> or that :-(
09:17:41 <matthewp> Cale: can you set lambdabot up to auto-join #novalang?
09:18:02 <int-e> fasta: http://paste.debian.net/25461/
09:18:18 <fasta> int-e: thanks, I got it working already :)
09:18:30 <chessguy_work> matthewp, @tell might be appropriate - Cale tends to keep interesting hours
09:18:42 <chessguy_work> @help tell
09:18:44 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
09:18:47 <fasta> int-e: only this page seems a bit confusing now http://en.wikibooks.org/wiki/Haskell/GADT
09:19:04 <fasta> int-e: the section under existential types
09:20:16 <fasta> int-e: the fundep solution doesn't look that bad
09:21:02 <int-e> fasta: I should probably write  data N = N (forall a . Num a => a -> Bool)
09:21:22 <int-e> fasta: I thought for a moment that an existential was needed, but I was wrong.
09:28:29 <lilac> > (\s -> and . getZipList $ (\a b -> head a == last b) <$> ZipList (init $ tails s) <*> ZipList (tail $ inits s)) "Hello olleH"
09:28:31 <lambdabot>   True
09:29:11 <vixey> > foldr (\x ys -> [x] ++ ys ++ [x]) [] "Hello "
09:29:12 <lambdabot>   "Hello  olleH"
09:29:27 <vixey> > foldr (\x ys -> [x] ++ ys ++ [x]) " " "Hello"
09:29:28 <lambdabot>   "Hello olleH"
09:29:59 <PeakerWork> > let isPallindrome xs = xs == reverse xs in isPallindrome "who are era ohw"
09:30:00 <lambdabot>   True
09:31:21 <Badger> heh
09:32:12 <igowen[work]> although if you're going through RWH, I don't think reverse is introduced before that exercise
09:32:19 <igowen[work]> it's trivial to write yourself of course
09:32:26 <quicksilver> > let isPalindrome xs = ((==) `on` (map toLower . filter isLetter)) xs (reverse xs) in isPalindrome "Able was I, ere I saw Elba."
09:32:27 <lambdabot>   True
09:33:49 <quicksilver> > let isPalindrome xs = ((==) `on` (map toLower . filter isLetter)) xs (reverse xs) in isPalindrome "Doc, note: I dissent.  A fast never prevents a fatness.  I diet on cod."
09:33:50 <lambdabot>   True
09:33:54 <quicksilver> endless hours of fun!
09:34:29 <pumpkin> now make it enumerate english palindromes!
09:34:46 <igowen[work]> have fun with that
09:35:16 <lilac> > isPalindrome "A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal - Panama!"
09:35:17 <lambdabot>   True
09:35:36 <pumpkin> lol
09:35:40 <igowen[work]> haha nice
09:36:44 <quicksilver> mine was a bit politcally incorrect, anyway.
09:36:47 <quicksilver> cod stocks are endangered.
09:37:42 <Badger> :)
09:38:17 <stu8ball> Who came up with that one?
09:38:28 <stu8ball> The long variation of "A man, a plan, a canal", I mean.
09:39:05 <gpb>  /quit
09:39:27 <quicksilver> stu8ball: it's rec.puzzles folklore
09:39:33 <quicksilver> I don't know if it's attributed.
09:39:47 <Arnar> hi all
09:39:55 <osfameron> nice
09:40:01 <stu8ball> It's pure genius.
09:40:06 <quicksilver> Apprently, It's attribtued to Dan Hoey.
09:40:10 <quicksilver> http://norvig.com/palindrome.html
09:40:39 <quicksilver> http://www2.vo.lu/homepages/phahn/anagrams/panama.htm
09:41:09 <osfameron> Primo Levi had a bilingual palindrome, something like "In arts it is repose to life - E' filo teso per siti strani" though I'm not sure that either the English or the Italian are especially good
09:41:14 <Arnar> do you guys know of interesting places (besides MSRC) that take interns for Haskell jobs?
09:41:26 <osfameron> Arnar: geography?
09:41:44 <Arnar> osfameron: Earth
09:41:58 <Arnar> osfameron: I live in Iceland, but I intend to move wherever
09:42:36 <osfameron> cool
09:44:11 <osfameron> the canonical list is on the wiki isn't it?  http://www.haskell.org/haskellwiki/Haskell_in_industry
09:44:25 <Arnar> ah, thanks
09:44:40 <Arnar> I'm looking for something preferably research oriented
09:46:09 <pumpkin> omg haskell was used by AT&T to wiretap us
09:47:50 <Arnar> pumpkin: wonder if they used unsafePerformIO
09:48:01 <pumpkin> it was unfortunately very safe for them
09:48:25 <vixey> osfameron, nice
09:49:19 <wango> Is a Functional Progromming Turing-Complete??
09:49:36 <pumpkin> the languages I know of are
09:49:49 <pumpkin> or equivalent, at least
09:49:54 <Deewiant> @faq Can Haskell emulate a Turing machine?
09:49:55 <lambdabot> The answer is: Yes! Haskell can do that.
09:49:55 <pumpkin> as some people seem t make a distinction
09:49:56 <idnar> does functional programming have the buddha nature?
09:50:16 <pumpkin> @faq can haskell emulate the buddha nature?
09:50:16 <lambdabot> The answer is: Yes! Haskell can do that.
09:50:43 <pumpkin> @faq is haskell able to make goobers from widgets with no intermediate flingbos?
09:50:44 <lambdabot> The answer is: Yes! Haskell can do that.
09:50:54 <wchogg> @faq can Haskell giving meaning to my solitary existence?
09:50:54 <lambdabot> The answer is: Yes! Haskell can do that.
09:51:04 <Deewiant> meaning = undefined
09:51:12 <pumpkin> @faq can haskell reveal why wchogg's existence is solitary?
09:51:12 <lambdabot> The answer is: Yes! Haskell can do that.
09:51:28 <igowen[work]> @faq can haskell solve the halting problem?
09:51:29 <lambdabot> The answer is: Yes! Haskell can do that.
09:51:32 <igowen[work]> ...
09:51:36 <hallongrottan> o_O
09:51:39 <bd_> > let wchogg = id in fix wchogg
09:51:39 <pumpkin> duh
09:51:40 <wchogg> Deewiant : wait, so if I try to evaluate the meaning of life I'll get _|_?
09:51:40 <lambdabot>   * Exception: stack overflow
09:51:55 <bd_> Clearly Haskell expects wchogg to blow his stack.
09:52:06 <baaba> bottoms make the world go around
09:52:07 <Deewiant> wchogg: Yeah, stack or heap overflow
09:52:08 <wchogg> bd_ : I'm just an angry dude, apparently.
09:52:15 <cads> _|_ seems a little perverted to this admittedly perverted person..
09:52:16 <Deewiant> wchogg: Your machine can't compute it, you see
09:52:42 <czShadoW> @faq Can Haskell write my bachelor thesis?
09:52:43 <lambdabot> The answer is: Yes! Haskell can do that.
09:52:46 <cads> hmm it looks like... a bottom..
09:52:54 <czShadoW> \o/
09:52:58 <pumpkin> czShadoW: sweet, take it easy
09:53:08 <wchogg> cads : you've been looking at strange people then
09:53:27 <cads> a sitting bottom, perhaps
09:53:55 <czShadoW> pumpkin: Actually, I'm writing about Haskell type system, parsing etc.
09:54:01 <cads> aaanyhoo..
09:54:08 <vixey> cads, T is for top
09:54:09 <pumpkin> cool :)
09:54:14 <vixey> cads, _|_ is an upside down T
09:54:28 <Arnar> @faq can Haskell produce an NP-complete problem which is not in N?
09:54:28 <lambdabot> The answer is: Yes! Haskell can do that.
09:54:32 <Arnar> wow
09:55:08 <Gracenotes> Arnar: just import System.Quantum
09:55:25 <Deewiant> Of course you'll need a quantum computer
09:55:30 <cads> vixey, when I was a mere tot on the primordial internet, and this is a bit fuzzy, I was exposed to some ascii pornography..
09:55:50 <chessguy_work> wow, that list of industry uses of haskell has grown a lot lately
09:56:06 <Gracenotes> Deewiant: and you might have trouble getting the answer out of the (possibly) millions of universes you create
09:56:07 <Arnar> anyone here from Chalmers?
09:56:08 <chessguy_work> wchogg, seen my code yet?
09:56:10 <wchogg> chessguy_work : or as I like to think of it, the list of places to send a resume
09:56:16 <wchogg> chessguy_work : the hpaste?
09:56:23 <chessguy_work> wchogg, yeah
09:56:28 <Deewiant> Gracenotes: Yeah, that's an open bug
09:56:33 <chessguy_work> good old DataSet a b c
09:56:42 <Gracenotes> :)
09:56:52 <wchogg> chessguy_work : yeah, sorry I hadn't responded yet.  I was going to catch up on the e-mails this morning.
09:56:53 <Olidu> hi, newbie question, I usually debug with a lot of "printf"s  in other language, how do I do it in Haskell to show variable value?
09:57:07 <pumpkin> Olidu: Debug.Trace is an easy way
09:57:13 <pumpkin> it's not referentially transparent
09:57:14 <vixey> Olidu, there's a 'trace' function for that but I prefer to not debug personally
09:57:15 <Deewiant> unsafePerformIO . printf
09:57:17 <chessguy_work> wchogg, no sweat
09:57:19 <cads> but yes, I am familiar with the upside down T denoting bottom... is the T for top is the same thing as T used in logic to denote true, or is it a different concept?
09:57:36 <vixey> cads, same thing
09:57:42 <chessguy_work> cads, we usually call it _|_ here
09:57:50 <wchogg> Olidu : In the end though, you might want to go ahead & use the ghci debugger instead of using trace
09:57:54 <vixey> chessguy_work, uh.......
09:57:59 <chessguy_work> @quote bottom
09:58:00 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
09:58:03 <Olidu> ok, thx pumpkin, Deewiant and vixey,
09:58:06 <vixey> chessguy_work, what does an upside down T look like?
09:58:06 <pumpkin> :)
09:58:23 <chessguy_work> vixey, ...
09:58:30 <chessguy_work> vixey, _|_ ?
09:58:41 <pumpkin> ORLY
09:58:42 <Olidu> wchogg, ok, don't know how to use it yet. I'll learn
09:58:45 <wango> I don't UNderstand If you Get the NP in Haskell, how do you know P = NP running out of stak space?
09:58:47 <pumpkin> you must have an odd font
09:58:55 <wango> pumpkin, oracle! olidu halp me
09:59:02 <pumpkin> wango: ?
09:59:04 <wchogg> Olidu : one of the issues of The Monad Reader, available on the Haskell homepage, gives a really good tutorial on the ghci debugger
09:59:10 <chessguy_work> vixey, it's an approximation
09:59:14 <vixey> lol lambdabot keeps giving people the same message in a loop
09:59:14 <wango> when you use recursion Gödel numba
09:59:15 <chessguy_work> but better than using unicode or something
09:59:20 <pumpkin> wango: where did P ?= NP come from ? :P
09:59:27 <wango> I guess it's A complexity theorems
09:59:32 <wango> just like Turing
09:59:34 <pumpkin> wango: I thought you were asking about turing equivalence a minute ago
09:59:38 <wango> I was!!
09:59:39 <pumpkin> o.O
09:59:47 <wango> All Of computer sciensist are my faves
09:59:59 <wango> I love the computation and thes complexities and thes quantum compots
10:00:50 <wango|yeomius> hay mrsolo
10:00:55 <wango|yeomius> do you like turing complete?
10:00:56 <Olidu> wchogg, is it "Step inside the GHCi debugger"?
10:01:01 <wango|yeomius> Olidu: obviously
10:01:05 <pumpkin> wango|yeomius: do you have a haskell question?
10:01:10 <rwbarton> Olidu: Often people don't really "debug" Haskell code in the usual sense, but instead just test small pieces of code to see if they do what's expected
10:01:14 <wango|yeomius> pumpkin: only on sund :)
10:01:27 <pumpkin> we get the oddest trolls in here
10:01:38 <rwbarton> my bot-o-meter was hovering around 20%
10:01:40 <wchogg> Olidu : I believe so.  There was only one tutorial in the various monad reader's.
10:01:47 <EmielRegis> he wanted to discuss some serious maths ;)
10:01:51 <pumpkin> lol
10:02:05 <pumpkin> sounded a bit like he'd heard #haskell was full of computer scientists and was mocking us :P
10:02:10 <cads> people launch CS theory spewing bots into here from time to time/
10:02:12 <cads> ?
10:02:14 <EmielRegis> hehe
10:02:22 <Olidu> rwbarton, I made the data structure too complex, hard to debug pieces
10:02:31 <pumpkin> Olidu: refactor!
10:02:41 <EmielRegis> well, in fact I believe this place is better to ask about such things than #maths :D
10:02:51 <pumpkin> EmielRegis: yeah, it is
10:02:58 <Olidu> pumpkin, how?
10:03:08 <pumpkin> but being a "fan of turing" doesn't really count as asking about theory :P
10:03:08 <vixey> @remember <wango|yeomius> do you like turing complete?
10:03:08 <lambdabot> It is forever etched in my memory.
10:03:13 <EmielRegis> ^^
10:03:17 <lilac> Olidu: i accidentally the whole data structure
10:03:25 <cads> why do maths folks dislike the formalisms of computer science so?
10:03:25 <pumpkin> Olidu: do as lilac did
10:03:55 <EmielRegis> cads, how could they dislike it? mathemtics is built on formalism itself
10:03:57 <wchogg> pumpkin : and quote 4chan memes?
10:04:06 <vixey> cads, because God made the universe with 8 axioms of Set theory
10:04:11 <EmielRegis> lmao
10:04:14 <EmielRegis> group theory > set theory
10:04:16 <pumpkin> wchogg: yeah, it's the best solution to one's issues
10:04:16 <EmielRegis> all the way!
10:04:32 <pumpkin> EmielRegis: for some definitions of > I guess :P
10:04:34 <vixey> EmielRegis, group theory as a foundation for mathematics? :S
10:04:39 <cads> EmielRegis, true, but the formalisms of math are regimented and compartmentalized in different ways
10:04:41 <EmielRegis> indeed
10:04:50 <EmielRegis> no vixey, as more fun way of dealing with 'data' :)
10:04:57 <vixey> EmielRegis, oh ok
10:05:00 <Olidu> lilac?
10:05:07 <wchogg> pumpkin : specifically for the meaning of '>' that translates into "wow, why are we comparing these things?"
10:05:13 <pumpkin> Data.Group ?
10:05:25 <pumpkin> wchogg: hah, yeah, or x > y === x `dependsOn` y
10:05:33 <cads> where to a type theorist (a->a)->a and a->a are both functions, to a mathematician the first is a functional and the second is a function and they're both considered maps
10:05:36 <EmielRegis> cads, yes it is. I believe that CS maths is very much practical, while math maths is mostly just purely abstract - though, as of now, it is mostly developed by physicists so can be a moot point ;)
10:06:01 <pumpkin> EmielRegis: for some definitions of practical ;)
10:06:07 <vixey> cads, ugh
10:06:08 <wchogg> EmielRegis : I object.  It's mostly _abused_ by physicists.
10:06:08 <pumpkin> well, how much CS math have you been exposed to?
10:06:21 <idnar> cads: what about a->(a->a)
10:06:23 <EmielRegis> pumpkin, yes - as I said, physics math can be thought of practical as it is physical :)
10:06:28 <dolio> Type theorists aren't mathematicians?
10:06:39 <rwbarton> CS math and math math are different?
10:06:41 <pumpkin> dolio: guess not :)
10:06:41 <EmielRegis> wchogg, why abused? it's just a tool, and they are desperate :P
10:06:50 <vixey> rwbarton, yes
10:07:03 <rwbarton> vixey: yes, but overlapping
10:07:08 <wchogg> EmielRegis : I have several pre-prepared rants about why path integrals annoy the crap out of me.
10:07:24 <cads> idnar that would be some crazy subscripted operator
10:07:26 <EmielRegis> pumpkin, well, i guess not that much after all. Some abstract algebra, number theory, complexity, turing machines, lambda calculus, logic
10:07:29 <pumpkin> wchogg: ooh do those pre-prepared rants include "are you fan of turing complete?"
10:07:46 <EmielRegis> lol
10:07:49 <wchogg> pumpkin : #%*(!! No!  *revises his notes*
10:08:04 <pumpkin> :D
10:08:54 <EmielRegis> after all, math is just a tool and as such should be 'abused' as much as is needed for it to become 'practical' ;)
10:09:10 <pumpkin> all math is practical!
10:09:17 <EmielRegis> unless you talking bout philosophy of maths, godel, kant and other things like that
10:09:20 <pumpkin> it achieves some goal :P even recreational math
10:09:35 <EmielRegis> recreational math? you mean doing exercises for fun?:P
10:09:38 <cads> vixey, yeah, the way that I said that... I was't even wrong
10:09:42 <pumpkin> things like project euler :)
10:09:48 <pumpkin> math competitions, and such
10:10:09 <vixey> "recreational math" is supposed to be an insulting term
10:10:19 <pumpkin> yup
10:10:23 <ozy`> like "recreational abortion?"
10:10:39 <pumpkin> all math is recreational!
10:10:42 <tromp_> or recreational suicide
10:10:59 <EmielRegis> but at least math is reversible :D
10:11:11 <EmielRegis> or rather, time-symmetric
10:11:15 <vixey> EmielRegis: huh.....
10:11:20 <ziman> effects of math on one's health? :)
10:11:35 <pumpkin> EmielRegis: what if it isn't :o
10:11:54 <mrsolo> do i like turing complete?
10:11:59 <mrsolo> what is to like? it just is
10:12:07 <pumpkin> mrsolo: you mean you don't like it? :(
10:12:27 <wchogg> pumpkin : I think he's just racist against turings
10:12:44 <pumpkin> @quote wango
10:12:44 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
10:12:46 <pumpkin> oi
10:12:49 <pumpkin> @quote turing
10:12:49 <lambdabot> Robert_Dockins says: A Turing-complete type-checker isn't enough!  Our work is not complete until the parser is a universal machine as well!
10:12:51 <pumpkin> @quote turing
10:12:51 <lambdabot> pjd says: was Turing complete?
10:12:53 <pumpkin> :(
10:13:00 <pumpkin> @remember wango do you like turing complete?
10:13:00 <lambdabot> It is forever etched in my memory.
10:13:02 <mrsolo> pumpkin: i did not say that
10:13:07 <EmielRegis> heheh
10:13:08 <mrsolo> pumkin: do you like 1 + 1 = 2?
10:13:09 <pumpkin> @quote wango
10:13:09 <lambdabot> wango says: do you like turing complete?
10:13:16 <Gracenotes> A type-checker that's Turing-complete isn't enough! It needs to solve the halting problem too!
10:13:16 <mrsolo> pumkin: or may be 2 + 2 = 4?
10:13:17 <Deewiant> The parser? What about the lexer?!
10:13:18 <pumpkin> mrsolo: certainly I do! I would never betray math
10:13:20 <roconnor> @quote
10:13:21 <lambdabot> bringert says: psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
10:13:43 <Gracenotes> (ignore contradiction :/)
10:13:56 <mrsolo> pumkin: more so than 1/0?
10:14:28 <vixey> @quote
10:14:28 <lambdabot> <Brent-tc> says: Put it in readable format. XD What language is that even? VB?
10:14:53 <pumpkin> mrsolo: that's my favorite!
10:15:26 <EmielRegis> vb...
10:15:29 <EmielRegis> blasphemy
10:15:40 <vixey> @quote
10:15:41 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
10:15:48 <Gracenotes> ah, context.
10:15:55 <Gracenotes> needed.
10:15:58 <Gracenotes> here.
10:16:44 <Gracenotes> @quote firefox
10:16:44 <lambdabot> No quotes match. You untyped fool!
10:17:00 <Gracenotes> @quote
10:17:00 <lambdabot> DonaldKnuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
10:17:00 <lambdabot>  might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
10:17:01 <pumpkin> worst insult ever :(
10:17:17 <Gracenotes> I'm not actually untyped, I'm just ()
10:17:40 <pumpkin> > sort [(), (), ()]
10:17:42 <lambdabot>   [(),(),()]
10:17:48 <pumpkin> not sure why () is ord, really
10:17:54 <pumpkin> > compare () ()
10:17:55 <lambdabot>   EQ
10:18:02 <pumpkin> > () > ()
10:18:04 <lambdabot>   False
10:18:23 <Gracenotes> we need a () monad
10:18:31 <pumpkin> lol
10:18:34 <pumpkin> what would it do?
10:18:38 <abbe> lambdabot also quotes like rudybot :)
10:18:41 <pumpkin> like the /dev/null monad?
10:18:44 <Gracenotes> () >>= f = ()
10:18:48 <Gracenotes> return a = ()
10:19:00 <pumpkin> how would you get the other law? :P
10:19:07 <tromp_> that fails the laws
10:19:09 <Gracenotes> ...prayer?
10:19:12 <killerboy> hi
10:19:13 <pumpkin> lol
10:19:18 <roconnor> what law does it fail?
10:19:24 <pumpkin> unsafeGrabOriginalParameterWithoutStoring it
10:19:24 <killerboy> where can i paste lambdabot errors?
10:19:41 <roconnor> @paste
10:19:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:19:46 <rwbarton> unsafePerformUnit :: () -> a
10:19:51 <vixey> rwbarton, nooo!
10:19:55 <pumpkin> roconnor: >>= return maybe?
10:20:11 <killerboy> in other words, how to send note to author
10:20:28 <pumpkin> oh actually
10:20:30 <roconnor> pumpkin: looks good to me
10:20:33 <pumpkin> yeah
10:20:34 <Gracenotes> () >>= return = () >>= () = ()
10:20:39 <chessguy_work> killerboy, check the maintainer listed on hackage
10:20:40 <pumpkin> lol
10:20:48 <Gracenotes> technically return is never evaluated, though
10:20:50 <vixey> :k ()
10:20:51 <lambdabot> *
10:20:57 <Gracenotes> well, straight to the standard libraries it is!
10:21:01 <killerboy> what is hackage?
10:21:07 <roconnor> Gracenotes: I'll vote for it
10:21:08 <chessguy_work> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdabot
10:21:12 <chessguy_work> killerboy,
10:21:12 <roconnor> @what hackage
10:21:13 <pumpkin> Gracenotes: do you have a hackage lib up yet?
10:21:13 <lambdabot> http://hackage.haskell.org/
10:21:18 <pumpkin> Gracenotes: you should call it NullMonad or something :P
10:21:33 <lucca> madness
10:21:33 <Gracenotes> hehe
10:21:36 <pumpkin> UnitMonad?
10:21:44 <pumpkin> Unad :P
10:21:51 <Gracenotes> available under a BSD license
10:21:56 <pumpkin> yay
10:22:01 <pumpkin> plz2write nao
10:22:01 <tromp_> doesn't monad need a type constructor?
10:22:02 <mib_dospcxse> can anyone hear me? I was thomashartman1 on erc-select over emacs, but was getting ignored. Now I'm on mibbit.
10:22:09 <killerboy> i donno is it configuration issue, or program issue
10:22:15 <rwbarton> the only problem is you can't use (), because its type doesn't have the form m a
10:22:17 <mib_dospcxse> Is there some way to compile ghc without ipv6?
10:22:23 <pumpkin> rwbarton: yeah, hmm
10:22:27 <Gracenotes> aww, shucks.
10:22:32 <mib_dospcxse> I am trying to find a workaround for the bug described at http://code.google.com/p/happs/issues/detail?id=40
10:22:33 <roconnor> tromp_: ya, the monad is really newtype Unad a = ()
10:22:40 <pumpkin> lol
10:22:51 <BONUS> @type \x f -> const x >=> f $ undefined
10:22:53 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
10:22:56 <BONUS> w00t
10:22:58 <roconnor> er
10:23:00 <roconnor> tromp_: ya, the monad is really newtype Unad a = Unad ()
10:23:29 <Gracenotes> BONUS: writing the monads chapter? :D or just random workings?
10:23:41 <tromp_> but in the law (return x) >>= f == f x, x can be of any type, right?
10:23:45 <vixey> :t \x f -> const x >=> f $ ?q
10:23:46 <lambdabot> forall a (m :: * -> *) b c. (?q::a, Monad m) => m b -> (b -> m c) -> m c
10:24:09 <MichaelGG> Does Haskell have dimension types?
10:24:25 <vixey> MichaelGG, like cm meters,?
10:24:30 <MichaelGG> but generic
10:24:35 <vixey> MichaelGG, generic ?
10:24:37 <BONUS> hehe hey Gracenotes
10:24:44 <BONUS> thinkin' bout writing it :]
10:24:47 <MichaelGG> I mean, notunits of meaturement
10:24:49 <roconnor> *L*
10:24:56 <roconnor> Monad axioms:
10:24:56 <roconnor> Kleisli composition forms
10:24:56 <roconnor> a category.
10:24:58 <BONUS> that's half the work though
10:24:58 <Gracenotes> \o/
10:25:00 <twanvl> how about making Control.Applicative.Const () a monad?
10:25:35 <roconnor> twanvl: not haskell 98
10:25:44 <twanvl> right
10:25:46 <MichaelGG> like say I want a char list but qualified by another type
10:26:01 <MichaelGG> so i cant pass just any [char] in
10:26:07 <roconnor> we obviously want a portable Unad
10:27:45 <Gracenotes> @pl \a b -> f (g a b)
10:27:46 <lambdabot> (f .) . g
10:27:56 <pumpkin> that's the best one
10:28:03 <rwbarton> MichaelGG: I'm not clear on what you're trying to do, but it is likely that Haskell's type system can be made something like what you want
10:28:08 <roconnor> or (fmap (fmap f)) g
10:28:10 <rwbarton> s/made/made to do/
10:28:52 <MichaelGG> rwbarton, ok, well in another language (im not proficient in haskell), I might have a function that takes a string ID and does something with it
10:29:21 <MichaelGG> but I'd like the type system to check that I passed a String "ID" and not just a string. But the "ID" type is just some type I've added for safety
10:29:23 <arjanb> MichaelGG: you could wrap it in a newtype
10:29:31 <rwbarton> MichaelGG: Yes!  newtype ID = ID String
10:30:16 <MichaelGG> is there a way to add a type parameter to that, so I can have type ID is a string qualified by another type
10:30:17 <rwbarton> MichaelGG: That creates a new type ID whose internal representation is identical to that of String, but which is treated as distinct by the type-checker
10:30:39 <rwbarton> MichaelGG: Well, yes.  You can write  newtype ID a = ID String, for example
10:30:40 <MichaelGG> so I could have a function that takes two 'a IDs and concats them
10:30:56 <rwbarton> MichaelGG: in that case what 'a' represents is up to you.
10:30:57 <MichaelGG> so then I can specify functions to take, say "int ID"
10:31:12 <rwbarton> Right, "int ID" is written "ID Int" in Haskell
10:31:17 <MichaelGG> oh right
10:31:24 <MichaelGG> (sorry all day on F#)
10:31:40 <MichaelGG> Does this have a name?
10:31:41 <rwbarton> idConcat :: ID a -> ID a -> ID a; idConcat (ID x) (ID y) = ID (x ++ y)
10:31:47 <roconnor> *l* apparently "Dual" is "gratuitously pseudo-technical"
10:32:21 <killerboy> bye
10:32:23 <rwbarton> MichaelGG: 'a' here is often called a "phantom type".  See http://en.wikibooks.org/wiki/Haskell/Phantom_types for example
10:32:31 <MichaelGG> YES! that's what it's called then
10:32:42 <MichaelGG> i suspected it but wasnt sure
10:32:50 <twanvl> roconnor: at least "dual" is polarizing, some people like it a lot, others hate it
10:32:57 <MichaelGG> I can sorta do it in F# with "type 'a ID = ID of string"
10:33:02 * rwbarton hates "dual"
10:33:08 <MichaelGG> but then I need to match ID to get the string out and in general its sorta clunky
10:33:39 <roconnor> twanvl: when I make a language I'll make identifiers user loadable.
10:33:44 <roconnor> so we don't have to agree
10:33:57 <rwbarton> MichaelGG: it's exactly analogous in Haskell, and exactly as clunky.  The fact that you need to match ID is important, because wherever you do that, you might be breaking whatever guarantees the 'a' parameter is supposed to ensure
10:34:10 <twanvl> roconnor: that reminds me of Excel; it sounds horrible
10:34:20 <roconnor> oh, Excel can do this?
10:34:29 <twanvl> Excel translates function names
10:35:06 <roconnor> twanvl: you mean for internationalization?
10:35:11 <MichaelGG> rwbarton, oh :\. I seem to have to write ID twice when creating a value
10:35:19 * rwbarton doesn't hate "dual" that much actually
10:35:20 <MichaelGG> let x : ID<int> = ID "x"
10:35:38 <MichaelGG> It'd be nice to be able to do let  x= int ID "x"
10:35:42 <roconnor> rwbarton: as long as Descending isn't chosen, I'm happy.
10:35:45 <rwbarton> MichaelGG: I see
10:35:49 <twanvl> roconnor: yes, in an English excel you say "SUM(123)", while in a Dutch excel you use "SOM(123)", etc.
10:35:51 <dons> interesting. default minimal http server gets 7.4k conn/s, http://hpaste.org/13719
10:35:58 <dons> i wonder how we'd crank that up
10:36:03 <roconnor> twanvl: ah yes.  That sounds like what I want
10:36:18 <twanvl> what you *want*?
10:36:25 <rwbarton> MichaelGG: ghc has an extension for overloading string literals, so you could have "x" :: ID a; not sure I'd recommend that, though
10:36:26 <Deewiant> how can you possibly want that :-P
10:36:31 <roconnor> twanvl: sure
10:36:44 <MichaelGG> rwbarton, well strings were just an example.
10:36:47 <Raevel> dons: :-)
10:36:48 <rwbarton> MichaelGG: Right
10:36:50 <roconnor> Deewiant: don't you like o be able to read code?
10:37:14 <Deewiant> yes, and I like the code to not change depending on where I read it
10:37:32 <MichaelGG> can you do newtype ID a b = ID b
10:37:34 <pumpkin> dons: how does that oleg-esque http server compare? I can't remember what it was called
10:37:40 <Deewiant> MichaelGG: yep
10:37:41 <rwbarton> MichaelGG: Yes, sure
10:37:43 <dons> pumpkin: not sure. it was just a toy afaik.
10:37:56 <rwbarton> MichaelGG: In fact, I am about to use that in some code I am writing :)
10:37:56 <dons> i can't imagine it would be any better, since both are strict in their responses.
10:37:57 <MichaelGG> I bet it'd work better in haskell since it'll do more inference than ocaml style
10:38:31 <roconnor> Deewiant: So what, you prefer code that you cant read, so long as it doesn't change from system to system?
10:38:39 <MichaelGG> so is there a way to get units of measurement out of this somehow? by making a have a typeclass to handle conversions or something
10:38:51 <MichaelGG> (sorry if i sound incoherent...i dont understand anything_
10:39:01 <Deewiant> roconnor: At least then I only have to learn to read it once
10:39:07 <rwbarton> @hackage dimensional
10:39:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional
10:39:13 <Deewiant> roconnor: So, I'd say yes.
10:39:21 <roconnor> ok
10:39:33 <roconnor> well, I've never experience a system like I'm thinking
10:39:41 <roconnor> so it may not be as nice as I imagine.
10:40:19 <roconnor> but websites change apperience from system to system.  And that can be exploited for good or evil.
10:40:32 <Deewiant> The weirdness with excel is that it only accepts code in the language it speaks, but it can still understand code from any language
10:40:42 <Deewiant> Either it's not stored as text or the UI sucks
10:40:58 <Deewiant> (Because if it is, that means it should be able to accept more languages)
10:41:05 * rwbarton resists the temptation to make a joke about that
10:41:22 <roconnor> Deewiant: I'm assuming here that when I send an excel file to the netherlands, they read my formulas in Dutch.
10:41:41 <Deewiant> roconnor: Assuming their excel program is in Dutch, yep.
10:41:49 <MichaelGG> Thanks for the help guys
10:42:04 <roconnor> Deewiant: I doubt it can accept formulas in all languages simultaneously.  Terms may be ambiguous that way.
10:42:07 <osfameron> it must be stored as a parse tree
10:42:10 <Deewiant> My main annoyance is that I switch to a computer which isn't in English and suddenly my Excel productivity goes down 95%.
10:42:30 <roconnor> Deewiant: I think you are blaming the wrong piece of software there.
10:42:39 <Deewiant> roconnor: Not simultaneously, but it could be a setting.
10:42:52 <roconnor> that is a profile management problem, not really an excel problem.
10:42:52 <Deewiant> (If it could.)
10:43:30 <Deewiant> Hmm.
10:43:33 <bockmabe> wasssup
10:43:43 <Deewiant> Maybe.
10:43:51 <roconnor> I understand the frustation
10:43:54 <MichaelGG> So , one more question -- wouldn't phantom types solve all sorts of problems, like cross-site scripting, mismatched units (pixel height versus pixel length -- hell, even different string formats), etc. etc. in other languages?
10:44:10 <roconnor> when audio breaks in say VLC under ubuntu, who is at fault?
10:44:14 <roconnor> VLC?
10:44:22 <roconnor> The audio system
10:44:25 <roconnor> some other layer?
10:44:31 <rwbarton> MichaelGG: Yes
10:44:37 <rwbarton> MichaelGG: Or so we would have you believe :)
10:44:38 <Saya> pulseaudio
10:44:58 <MichaelGG> So, is it pointless to ask why the **** they don't do that? Like MS wrote a goddamn XSS runtime to dynamically inspect your data and guess if it's being attacked....
10:45:05 <dons> cool. llvm / haskell examples, http://www.reddit.com/r/programming/comments/7o2m5/using_llvm_to_generate_fast_machine_code_from/
10:45:07 <MichaelGG> or is everyone else just that dumb?
10:45:17 <Deewiant> roconnor: Knowing Linux's audio state, probably everyone. ;-)
10:45:24 <roconnor> :)
10:45:30 <MichaelGG> Am I missing something?
10:45:40 <osfameron> audio breaks in Linux?  was it ever fixed?
10:45:44 <dons> MichaelGG: we use the type system to stop various information leakage problems , yes.
10:45:51 <roconnor> MichaelGG: generic unit multiplication is a bit tricky with phantom types
10:46:00 <roconnor> well, a lot tricky
10:46:05 <rwbarton> MichaelGG: right, e.g., perl has this "taint" mechanism which you could view as a very special case of something kind of like phantom types
10:46:08 <roconnor> I don't know how to do it myself.
10:46:50 <Saya> There should be a way to have a type keyword that builds a different type but which makes equivalent functions for the new type..... hmm.. like if you have concat :: [String] -> String it should automatically make a concat :: [Id] -> Id but working only on ids (if you see what i mean  :s)
10:46:54 <MichaelGG> rwbarton, interesting. but such special cases -- i dunno, they feel wrong :P
10:47:02 * roconnor used phantom types to prevent errors from mixing up R G and B channels when cutting and pasting code.
10:47:06 <MichaelGG> but im thinking .NET in particular
10:47:33 <MichaelGG> ok on units of measurement -- F# has that for floats, so we can multiply divide etc and the units will change
10:47:42 <MichaelGG> Is that something that can/should be extended to all types?
10:48:18 <rwbarton> Saya: generalized newtype deriving is a little bit like that.
10:48:23 <dons> yeah, the 'dimensional' library gives us unit checking for lots of numeric types
10:48:36 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional
10:48:44 <MichaelGG> dons, but perhaps extensible so I could define HtmlEncodedString, SqlString, etc
10:48:48 <dons> sure. newtype
10:48:56 <vixey> huh
10:48:58 <dons> the types are fully programmable :)
10:49:01 <MichaelGG> with conversion methods
10:49:22 <vixey> what does it mean programmable?
10:49:40 <vixey> I found a really bizarre way to write functions that compute types from types
10:49:44 <rwbarton> MichaelGG: this is a nice read, though it sounds like it would be preaching to the choir.  http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
10:50:15 <MichaelGG> rwbarton, Yea i read that at some point i think
10:50:17 <vixey> MichaelGG, why would you have SqlString? rather than SQL abstract syntax ...
10:50:17 <vixey> ?
10:50:31 <MichaelGG> yea youre right, SQLString is a bad example cause it should be better
10:50:38 <MichaelGG> but HtmlEncoded, UrlEncoded, etc.
10:50:43 <MichaelGG> Console control escaped
10:51:00 <MichaelGG> but i guess it wouldnt make much sense to have operators on those
10:51:14 <MichaelGG> what would a unit of  url * html mean
10:51:19 <olsner> oh, 7.5kconn/s, eh? how good/bad is that for a web server?
10:51:47 <dons> olsner: very good
10:51:48 <MichaelGG> I did this stuff, tracking IDs by an unused type, in C#... but holy crap it was sooo painful.
10:52:05 <dons> olsner: we talk about the 10k conn/s grand challenge
10:52:06 <Saya> you cant multiply string so its normal url*html means nothing
10:52:20 <MichaelGG> right
10:52:43 <MichaelGG> OK one more question, so what would it mean to have any type allow a type parameter? like being able to say String<int>
10:52:57 <MichaelGG> the same way with units of measurements I can say float<cm>
10:53:16 <MichaelGG> and have the wrapper type automatically generated and matched or whatnot
10:53:21 <rwbarton> MichaelGG: Well, we have the kind system to keep track of that sort of thing
10:53:32 <MichaelGG> like "first class" syntax support for phantom types
10:53:41 <rwbarton> oh, I think I misunderstood
10:56:29 <rwbarton> While we're on a related topic, what do people think about the relative merits of...
10:56:42 <rwbarton> class Storable a where sizeOf :: a -> Int -- a is unused
10:56:49 <lilac> hmm. what strings problem? CallStoredProcedure('procname', 'arg1', 'arg2', ...)
10:57:01 <rwbarton> newtype Label a b = Label b; class Storable a where sizeOf :: Label a Int
10:57:02 <MichaelGG> lilac, yea, SQL is handled
10:57:13 <rwbarton> ?
10:57:51 <MichaelGG> lilac, im thinking more of, say, html encoding. or say "widthpixels" versus "heightpixels"
10:58:08 <lilac> MichaelGG: right, in those cases a newtype is /so/ the way to go
10:58:18 <lilac> or phantom types if you prefer
10:58:40 <rwbarton> The advantage of the latter is that sizeOf will only be computed once, which probably won't matter here, but matters in the application I have in mind
10:58:44 <rwbarton> a third alternative is
10:59:14 <rwbarton> data Void a; class Storable a where sizeOf :: Void a -> Int -- ghc won't optimize this to Int, will it?
10:59:37 <MichaelGG> lilac, yea. i was just wondering about cuter syntax
10:59:44 <lilac> rwbarton: Storable's sizeOf is a bit of an ass to use in a polymorphic function, i've found
10:59:50 <olsner> dons: I got a 50% increase by compiling with -threaded :)
11:00:05 <dons> olsner: oh, that's interesting.
11:00:08 <MichaelGG> instead of having to manually construct and match
11:00:18 <olsner> up to 15kconn/s from 9
11:00:43 <dons> i didn't try -threaded without forkOI
11:00:52 <rwbarton> lilac: I think my second suggestion would make it slightly more awkward, if anything
11:00:58 <lilac> MichaelGG: newtype deriving helps a bit, as does a Functor instance, but yeah, that's a little awkward.
11:01:18 <dons> olsner: yeah. indeed
11:01:21 <dons> >10k conn/s
11:01:58 <olsner> but using +RTS -Nn reduces performance after that
11:02:00 <rwbarton> MichaelGG: You could of course write idInt :: a -> ID Int a; idInt = ID
11:02:01 <lilac> rwbarton: right. you're entering the i-need-scoped-type-variables area there
11:02:09 <olsner> looks like -threaded does something magical even for single-threaded programs
11:02:14 <tehgeekmeister> http://hpaste.org/13720 <== this code ends up reading every row into memory before it starts running the map, why?
11:02:49 <rwbarton> lilac: the main advantage I see is that the current type signature of sizeOf is kind of a lie
11:02:58 <MichaelGG> rwbarton, yea -- solving it for one type is easy
11:03:07 <redditbot> Using LLVM to generate fast machine code from Haskell
11:03:15 <opqdonut> tehgeekmeister: because of HDBC
11:03:18 <opqdonut> i'd say
11:03:28 <opqdonut> takusen works better for that kind of use cases
11:03:34 <rwbarton> MichaelGG: You can also write id' :: b -> a -> ID b a; id' = const ID; ... id' (undefined :: Int) "foo" :: ID Int String
11:03:35 <lilac> rwbarton: it /requires/ that implementations don't look at the value they're given, but doesn't ensure that :(
11:03:35 <MichaelGG> I wanted to sorta aks the F# team if they'd consider anything, but wanted to actually have some idea wtf im talking about first :D
11:03:51 <twanvl> rwbarton: with ScopedTypeVariables you  have either  sizeof (Proxy :: Proxy a)  or  unLabel (sizeof :: Label a Int)
11:03:53 <tehgeekmeister> opqdonut: bahhh, takusen won't build for me.  =/
11:04:14 <tehgeekmeister> opqdonut: according to the documentation it's a lazy query, so i figured it should handle that fine.
11:04:18 <lilac> rwbarton: "sizeOf :: Storable a => (forall b. a -> b) -> Int" might be a little better from that perspective
11:04:44 <rwbarton> twanvl: right.  I'm planning on using the second in my application.  Just wanted to make sure people didn't find the idea repugnant :)
11:04:47 <lilac> rwbarton: but your phantom solution seems nicer still
11:05:26 <MichaelGG> Is the idea of first class phantom types completely idiotic?
11:05:35 <rwbarton> I think in the specific case of sizeOf, the current situation is pretty good from a practical point of view.
11:05:36 <lilac> rwbarton: plus you can always provide an "oldSkoolUnlabel :: a -> Label a b -> b"
11:05:39 <tehgeekmeister> oh, wait.  that code doesn't do what i want anyway...
11:05:40 <twanvl> I have seen a Void/Proxy type used for this before
11:05:45 <tehgeekmeister> is there a prelude function to get the last item in a list?
11:05:57 <twanvl> > last "stuff"
11:05:59 <lambdabot>   'f'
11:06:03 <MichaelGG> as in, being able to annotate any type, any where, and have it automatically become the phantom type
11:06:08 <basvandijk> Hello, I'm adding a simple fold/build fusion system to my stream library ( http://code.haskell.org/Stream ) similar to list foldr/build fusion. I have a question about the fusion rules for 'map' ( See: http://darcs.haskell.org/packages/base/GHC/Base.lhs ). The "map" rule rewrites 'map' in terms of 'build'. But why is it important to rewrite 'foldr (mapFB (:) f) []' back into 'map f' ? Doesn't GHC perform that optimisation automatically?
11:06:08 <basvandijk> (sorry for the long post)
11:06:24 <rwbarton> twanvl: I'd like it to be as easy as possible for the compiler to inline the value of sizeOf, and barring that, have it be computed at most once at runtime
11:06:30 <rwbarton> twanvl: that's why I want to make it not be a function
11:06:38 <lilac> MichaelGG: no, i don't think so. but it's going to play havoc with the type system, i think.
11:06:49 <rwbarton> (again sizeOf is a proxy for something in my actual application)
11:07:12 <lilac> MichaelGG: you're basically asking for newtypes without the extra value constructor, right?
11:07:29 <twanvl> I don't know whether it actually makes a difference, you would have to test it
11:07:29 <dons> basvandijk: it rewrite unfused occurences   back
11:07:46 <dons> since `map` directly is faster, if no fusion occurs.
11:07:47 <MichaelGG> lilac, yea
11:07:54 <dons> basvandijk: did you consider stream fusion instead, btw?
11:08:01 <MichaelGG> lilac, and this is mainly looking at F#, which already has that syntax for units of measurements
11:08:02 <dons> its more flexible, and yields better code :)
11:08:09 <MichaelGG> i.e. "float<cm>" is valid
11:08:12 <dons> and you can reuse the defintions in the uvector modules
11:08:15 <MichaelGG> I'd like "string<int>" to be valid too
11:08:40 <rwbarton> MichaelGG: is float<cm> a synonym for something you can express in the type system without the ...<...> notation?  (which I assume is specific to this usage?)
11:08:41 <basvandijk> dons: Yes I'm thinking about it. But fold/build fusion seemed more simple to begin with.
11:08:47 * chessguy_work wonders if dons has his GUI set to trigger on 'fusion' :)
11:08:55 <opqdonut> tehgeekmeister: well lazy might mean many things
11:08:56 <lilac> MichaelGG: well, what do you lift (+) :: Float -> Float -> Float to?
11:09:01 <dons> basvandijk: not sure it is. perhaps
11:09:06 <lilac> MichaelGG: do you require all arguments to be lifted at the same time?
11:09:25 <dons> http://code.haskell.org/~dons/code/uvector/Data/Array/Vector/Stream.hs
11:09:29 <lilac> MichaelGG: and then what about (+ (5.0::Float))? how do you know /not/ to lift that?
11:09:58 <lilac> MichaelGG: finally, what about (*) :: Float -> Float -> Float? You /don't/ want that lifted to (*) :: Float<cm> -> Float<cm> -> Float<cm>
11:09:59 <rwbarton> MichaelGG: also how do you construct a value of type float<cm>?
11:10:20 <MichaelGG> rwbarton, nohttp://blogs.msdn.com/andrewkennedy/archive/2008/08/20/units-of-measure-in-f-part-one-introducing-units.aspx
11:10:31 <MichaelGG> better than me messing up the explanation
11:11:53 <rwbarton> MichaelGG: I see
11:12:00 <MichaelGG> the unit of measurement is a type with a Measure attribute. then you just pass in a literal "2.0<m>"
11:12:05 <lilac> MichaelGG: are you aware of this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dimensional
11:12:12 <rwbarton> MichaelGG: So, it's a little hard to simulate syntax like 9.81<m/s^2> because of the way it mixes types and values
11:12:31 <MichaelGG> yea just saw that
11:12:32 <rwbarton> (simulate in Haskell)
11:13:00 <MichaelGG> what im thinking is, units of measurement, without conversions, seem like phantom types
11:13:06 <basvandijk> dons: I understand that the "mapList" rule rewrites unfused occurences back. However I was under the impression that GHC was able to inline mapFB in 'foldr (mapFB (:) f) []' yielding 'foldr ((\c f x xs -> f x `c` xs) (:) f) []' which could then be optimised to: 'foldr (\x xs -> f x : xs) []'
11:13:10 <MichaelGG> i.e., if I never used <m/s>
11:13:15 <lilac> MichaelGG: very much so; that's how i'd implement them
11:13:18 <MichaelGG> but just stuck to <m> <s> etc, I'd still get them
11:13:32 <MichaelGG> So, what if the syntax allowed ANY type (not just float) to specify ANY type
11:13:37 <basvandijk> dons: However I guess GHC isn't able to do that.
11:13:40 <MichaelGG> so I could write "string<int>"
11:13:42 <chessguy_work> @pl \x xs -> f x : xs
11:13:43 <lambdabot> (:) . f
11:13:52 * chessguy_work giggles
11:13:56 <lilac> MichaelGG: the trouble is, extending it to any type transparently doesn't work
11:13:59 <MichaelGG> which could be shorthand for Id<string,int>
11:14:12 <MichaelGG> not with the operators, but without them?
11:14:27 <lilac> MichaelGG: well, what does that actually give you?
11:14:33 <rwbarton> MichaelGG: There's no problem in principle.  It's just a matter of how neat you can make the syntax.
11:14:49 <MichaelGG> in haskell... im not sure, since type inference seems to work better and having ID a b isnt as big of a pain
11:14:55 <rwbarton> MichaelGG: before you were complaining about  let x :: ID Int String; x = ID "foo", right?
11:15:12 <MichaelGG> right - i dont want to specify string , at the least
11:15:18 <MichaelGG> I can do that via a helper function
11:15:38 <MichaelGG> I'd like to not specify ID either :)
11:15:41 <lilac> MichaelGG: i think there's probably something valuable here, but i think you'd have to go quite far from Haskell'98 before it would completely fit in :)
11:15:48 <rwbarton> you could make the syntax  let x = iD (undefined :: Int) "foo"
11:16:28 <lilac> let x = iD (_::Int) "foo" even
11:16:31 <MichaelGG> the problem in F# is that the constructor doesnt take type parameters - but i can work around it, i think
11:16:36 <MichaelGG> I'm gonna play with it
11:16:44 <vixey> lilac, _?
11:16:51 <MichaelGG> I just wanted to see if was already "done and done", or it was too stupid
11:17:11 <vixey> why not:  iD Int "foo"
11:17:14 <rwbarton> MichaelGG: of course, as you say, often you won't need the local type signature on x at all.
11:17:19 <vixey> I mean haskell /is/ based on System F? right? :P
11:17:19 <Deewiant> > _
11:17:21 <lambdabot>   Pattern syntax in expression context: _
11:17:21 <rwbarton> vixey: that would be ideal :)
11:17:41 * vixey data TYPE t where INT :: TYPE Int; BOOL :: TYPE Bool; ...
11:17:43 <Saya> and how about a way to restrict values to a range from within a type like a Â°c cant be < 273 (thats dependents types right?)
11:17:44 <vixey> alternative ..
11:17:49 <MichaelGG> the other side is that I'll always need a matchin the function definition right
11:18:00 <opqdonut> Saya: use a smart constructor
11:18:07 <vixey> (:->:) :: TYPE a -> TYPE b -> TYPE (a -> b)
11:18:22 <opqdonut> Saya: hide the real constructor and expose only a function that does the check
11:18:34 <vixey> FORALL isn't possible though, is it?
11:18:36 <basvandijk> dons: is your stream fusion package on hackage? I'm thinking about dropping the fold/build fusion and going directly to stream fusion. And I could use your code for inspiration ;-)
11:18:43 <opqdonut> so instead of Celsius :: Float -> Temp, one has mkCelsius :: Float -> Maybe Temp
11:19:02 <lilac> , [| Int |]
11:19:05 <lunabot>  luna: Not in scope: data constructor `Int'
11:19:06 <dons> basvandijk: yes, part of the uvector package
11:19:10 <Saya> yeah but if i have a with value 10 and do a - 300 .. well i guess these kind of things cant be guessed at compiled time
11:19:15 <Deewiant> , [| I# |]
11:19:17 <lunabot>  luna: parse error on input `|]'
11:19:20 <lilac> , [t| Int |]
11:19:26 <lunabot>  ConT Int
11:19:26 <rwbarton> MichaelGG: You'll need it whenever you need the underlying value, which is logically necessary to ensure that your invariant is maintained
11:19:28 <opqdonut> Saya: no, not generally
11:19:39 <tehgeekmeister> http://hpaste.org/13720#a2 <== why am i getting this type error?  recursion and monads confuse me...
11:19:40 <basvandijk> dons: right, I will take a look at uvector, thanks
11:19:50 <rwbarton> MichaelGG: e.g. by matching, you can write coerce :: ID a b -> ID a' b, which is "unsafe"
11:20:05 <lilac> , let f x = [|undefined :: $(x)|] in  f [t| Int |]
11:20:08 <lunabot>  luna: parse error on input `$('
11:20:28 <MichaelGG> yea youre right - well need the match
11:20:36 <MichaelGG> probably can hack up some syntax to make it quick when needed
11:20:48 <opqdonut> tehgeekmeister: remove the return after Just r ->
11:20:48 <Deewiant> lilac: one can't splice types
11:20:58 <Deewiant> you can splice the whole thing though
11:21:00 <opqdonut> you're trying to return an already-monadic value
11:21:21 <Deewiant> i.e. you can splice 'undefined :: type' but not only 'type'
11:21:22 <rwbarton> , [| undefined :: Int |]
11:21:25 <lunabot>  SigE (VarE undefined) (ConT Int)
11:21:43 <MichaelGG> i think i like that with units of measurements, even if I have a float<m>, I can just treat it like a float
11:21:54 <rwbarton> , let f = SigE (VarE 'undefined) in f <$> [t| Int |]
11:21:57 <lunabot>  SigE (VarE undefined) (ConT Int)
11:22:06 <MichaelGG> instead of having to extract the value
11:22:15 <MichaelGG> I think that would be valueable
11:22:32 <rwbarton> MichaelGG: Doesn't that defeat the whole point though?  Or at least, you should have to make explicit when you are doing that.
11:22:38 <opqdonut> well
11:22:40 <yitz> tehgeekmeister: you would have gotten a more readable error if you had supplied a type signature for lazyFetch.
11:22:42 <MichaelGG> no it doesnt really
11:22:52 <MichaelGG> Because "untyped" APIs
11:22:56 <MichaelGG> say "string.split"
11:22:59 <MichaelGG> are gonna operate the same
11:23:00 <tehgeekmeister> yitz: oh, i'll do that.
11:23:06 <opqdonut> if there were a typeclass "class Mul a b c | a b -> c; where (*) :: a->b->c"
11:23:19 <MichaelGG> But, i cannot pass it to any that are typed. so i dont need a match, I can call untyped functions, but not typed ones
11:23:21 <opqdonut> one could make for example multiplying float<m> with float work
11:23:23 <opqdonut> properly
11:23:34 <yitz> tehgeekmeister: but opqdonut deciphered it for you :)
11:23:36 <MichaelGG> multiplying float<m> with float is fine isnt it
11:23:46 <opqdonut> yes
11:23:54 <opqdonut> but we need to enforce that the result is float<m>
11:24:06 <opqdonut> just as float<m> times float<m> must produce float<m^2)
11:24:08 <rwbarton> MichaelGG: You could make newtype ID a b = ID b; instance Functor (ID a) where fmap f (ID x) = ID (f x); ... then fmap split (ID "foo" :: ID Int String) :: ID Int [String]
11:24:39 <MichaelGG> opqdonut, hmm. so ok, calling, say, string.split on an ID a string isnt guaranteed to give us a valid ID a string
11:24:41 <opqdonut> and you can make most prelude stuff work jsut by specifying the right typeclass instances
11:24:50 <vixey> FORALL :: a -> TYPE (f a) -> TYPE (f a), ... maybe ?
11:24:59 <rwbarton> , src 'ForallT
11:25:05 <vixey> no that wouldn't work
11:25:08 <MichaelGG> i guess it'd depend more on actual user scenarios -- is it worth it to always assume no type is safe, or force that ot be explicit.
11:25:11 <lunabot>  data Type = ... | ForallT ([Name]) Cxt Type | ...
11:25:11 <lunabot>  infixl 9
11:25:18 <opqdonut> MichaelGG: I'm sorry, I missed the beginning of this conversation
11:25:22 <opqdonut> what was the purpose of ID
11:25:36 <Saya> an identifier type i guess
11:25:43 <MichaelGG> opqdonut, basically, I want  phantom types everywhere with first class syntax
11:26:05 <MichaelGG> i..e, be able to write, say, "String<int>" and have that be "ID Int String"
11:26:19 <MichaelGG> but also not have to match out the value
11:26:23 <rwbarton> MichaelGG: btw in Haskell you could define, say, String :- Int for ID Int String :)
11:26:30 <opqdonut> MichaelGG: ID a is a functor
11:26:43 <tehgeekmeister> http://hpaste.org/13720#a3 <== i get a new error now
11:27:11 <MichaelGG> ID is newtype ID a b = ID b right
11:27:50 <rwbarton> MichaelGG: I think "it'd depend more on actual user scenarios" is exactly right
11:28:16 <opqdonut> i think you're shooting too generic
11:28:24 <rwbarton> MichaelGG: better to have a consistent general system than introduce magic syntax for a special case
11:28:33 <tehgeekmeister> if it weren't for all the monadic cruft around this, i think i could figure out this type error on my own, but i have a hard time figuring it all out when monads are combined as of yet.
11:28:53 <opqdonut> you probably either want a bunch of specialised nice solutions for specific problems
11:28:58 <opqdonut> or full dependent typing
11:29:19 <tehgeekmeister> oh!  liftM isn't what i want
11:29:33 <MichaelGG> dependent types - thanks something to research
11:29:36 <MichaelGG> I LOVE all this stuff
11:29:41 <vixey> MichaelGG, GADTs make "phantom" types first class
11:29:45 <MichaelGG> for years I've been muddling around screwing up stuff
11:29:57 <rwbarton> tehgeekmeister: why is it called lazyFetch?  It doesn't look lazy to me :)
11:30:04 <MichaelGG> like inC# just dicking with things till they sorta work, and wondering why stuff doesnt really click. then i come here say 2 lines, and its "oh, yes this is what you want"
11:30:12 <MichaelGG> and theres tons of existing research and so on
11:30:20 <tehgeekmeister> rwbarton: i want it to be lazy?
11:30:23 <opqdonut> indeed
11:30:37 <tehgeekmeister> rwbarton: maybe i didn't manage to pull that off, but i certainly do want it to be lazy
11:30:43 <rwbarton> tehgeekmeister: how about using fetchAllRows?
11:30:55 <tehgeekmeister> rwbarton: it read the entire result set into memory
11:31:17 <Saya> concretely dependent types are kinds that can take term parameters instead of just types right?
11:31:28 <tehgeekmeister> rwbarton: look up at the top version, it uses quickQuery, which is supposedly equivalent to preparing and using fetchAllRows
11:31:41 <MichaelGG> and, I have to say, the haskell community is the most intelligent language communitity I've dealt with, but also the most friendly and non arrogant
11:31:57 <opqdonut> MichaelGG: that's what they all say :P
11:31:59 <tehgeekmeister> MichaelGG: very true.
11:33:22 <rwbarton> tehgeekmeister: you'd have to use unsafeInterleaveIO to make your lazyFetch, which is how fetchAllRows is implemented
11:33:37 <vixey> It's amazing how much you can do in haskell i.e. not using dependent types, though
11:33:45 <vixey> but it is all ugly hacks :p
11:33:49 <vixey> still, fun
11:34:12 <tehgeekmeister> rwbarton: hum.  i think i might be better off just trying to figure out why fetchAllRows/quickQuery aren't working the way i want.
11:34:25 <rwbarton> tehgeekmeister: what if you simplify the entire argument of mapM_ to just 'print', does it still read the whole database into memory at once then?
11:34:26 <MichaelGG> like, im sure someone could give some explanation, someone else says "whats an abelian group" and not get flamed or "stfu and google n00b"
11:34:39 <tehgeekmeister> rwbarton: i'll try that
11:35:03 <MichaelGG> the downside is that i spend all day in awe and dont get any work done :)
11:35:51 <monochrom> I would not say "stfu n00b" but I would still say "google".
11:36:11 <MichaelGG> well on haskell cafe anyways people tend to go into long custom expanations which im sure google might answer somehow :)
11:36:31 <monochrom> Being aware of the unpredictable quality of the hits, I would point you to a specific url that I would take pride in recommending.
11:36:40 <MichaelGG> or that :)
11:36:59 <monochrom> But I would still refer to an existing piece of writing.
11:37:01 <tehgeekmeister> rwbarton: grown to 500mb in less than a minute, so i'd say yes.
11:37:03 <MichaelGG> I guess, otoh, I don't see many "hello. can u plz tell me how to play mp3 in haskkel. thnkx." type messages :)
11:37:35 <monochrom> It is remarkably dumb, not remarkably intelligent, to repeat in IRC what has already been well-written extensively and can be easily found.
11:37:57 <icqn> can u plz tell me how to play mp3 in haskkel?
11:38:04 <MichaelGG> i dont mean repeating everything, but people will take a bit of time to explain certain things if someone isnt getting it
11:38:06 <monochrom> Not to mention that IRC lacks the 2D layout necessary.
11:38:11 <czShadoW> monochrom: Some people like to explain things.
11:38:27 <MichaelGG> I dont see many other communities willing to do that -- theyll point at something, and thats that, usually.
11:38:33 <rwbarton> We get much stranger stuff like "do you like turing complete?" :)
11:38:35 <czShadoW> (In their free time.)
11:38:59 <MichaelGG> I knew F# got too popular when i saw that exact mp3 question on the forums
11:39:29 <monochrom> Of course, if I refer you to an article, and then you don't understand some parts of it, we can see what we can do.
11:39:57 <MichaelGG> monochrom, well yea -- in general people are understanding, kind, expanatory, etc.
11:40:05 <yitz> monochrom: like the part starting with "Abstract..."
11:40:13 <MichaelGG> I'm learning a bit just by reading haskell cafe
11:40:59 <icqn> MichaelGG, what is this?
11:41:06 <MichaelGG> ?
11:41:12 <tehgeekmeister> rwbarton: also, and very oddly, when i used fetchAllRows explicitly, as opposed to quickQuery, hdbc would begin a transaction, but the select statement never made it to postgresql (or at least into the log.)  when i use quickQuery the select statement makes it to postgresql, however...
11:41:44 <icqn> MichaelGG, what is haskell cafe?
11:41:52 <monochrom> mailing list
11:41:54 <MichaelGG> mailing list
11:42:19 <yitz> @where haskell cafe
11:42:20 <lambdabot> http://haskell.org/
11:42:27 <MichaelGG> So, if you had to not use Haskell, say , for a commerical project -- which language sucks least?
11:42:28 <yitz> @go haskell cafe
11:42:29 <rwbarton> @where haskell-cafe
11:42:32 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
11:42:32 <lambdabot> Title: Haskell-Cafe Info Page
11:42:32 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
11:42:40 <MichaelGG> And, how do you deal with it?
11:42:46 <icqn> thank you
11:43:05 <czShadoW> MichaelGG: Do you know the unofficial Haskell motto? "Avoid success at all costs." It's maybe answer to your amazement. :-)
11:43:36 <monochrom> czShadoW: I like to explain things, and I like to make it more efficient by amortization. Perhaps some other people don't like to be efficient.
11:43:37 <MichaelGG> czShadoW, i'd think swearing at everyone would avoid success more :)
11:43:57 <MichaelGG> monochrom, you're right. there's a whole class: Public services.
11:44:01 <rwbarton> tehgeekmeister: were you execute-ing the statement?
11:44:08 <monochrom> haha
11:44:12 <czShadoW> monochrom: It's good practice sometimes.
11:45:05 <MichaelGG> No, but seriously. After I learned F#, C# became untolerable. Haskell has more power than F#, so how do you tolerate other languages
11:45:20 <MichaelGG> like I'd take a significant paycut to work on an F# project versus a C# project
11:45:24 <tehgeekmeister> rwbarton: no, preparing and feeding the prepared statement to fetchAllRows.
11:45:44 <rwbarton> tehgeekmeister: I think you'd have to prepare, execute, then fetchAllRows; at least that's what quickQuery does
11:45:45 <erikc> michaelgg: grudgingly /w paycheck
11:45:56 <MichaelGG> are there any mental coping mechanisms
11:46:06 <erikc> i'd value a private office at 10k/year and using haskell at 20k/year :)
11:46:07 <czShadoW> MichaelGG: When is something successful and popular, it usually attract some stupid people with mp3 problems. :-)
11:46:07 <MichaelGG> part of the reason im a bit hesistant to actually use haskell and code in it
11:46:12 <rwbarton> tehgeekmeister: so that would explain why you don't see the query in the log, if it wasn't executed
11:46:15 <tehgeekmeister> rwbarton: oh, well that's good to know.  i still need to figure out why it's not being lazy enough, tho...
11:46:21 <MichaelGG> is cause im worried id discover something so powerful ill get sick if i cant use it :P
11:46:21 <rwbarton> tehgeekmeister: yeah, I'm puzzled by that
11:46:37 <MichaelGG> czShadoW, OH you were responding to that :)
11:46:44 <czShadoW> Yeah.
11:46:56 <MichaelGG> well it certainly keeps IRC and mailing lists clean
11:47:01 <tehgeekmeister> rwbarton: i've noticed dons looks at the intermediate haskell sometimes to see what it's really doing in blog posts, perhaps that could help here?
11:47:08 <monochrom> Someone's blog actually complains that after knowing Haskell he suffers depression at work. :)
11:47:18 <MichaelGG> I swear, if I see one more ASP.NET question asking why the Server cannot call the Win32 API on the client browser.......
11:47:34 <MichaelGG> monochrom, i wouldnt be surprised
11:47:37 <MichaelGG> after working in F# for a few months
11:47:40 <MichaelGG> I had to do C#
11:47:45 <rwbarton> there was a great comment on that blog
11:47:45 <monochrom> "I hate Haskell because now my job is miserable!"
11:47:46 <MichaelGG> i couldnt do it
11:47:47 <chessguy_work> monochrom, i'd bet a lot of haskell programmers experience that
11:48:07 <monochrom> Yeah, but this one actually says he hates Haskell for that. :)
11:48:13 <MichaelGG> its like "Why must i spend 300 characters writing a field declaration!!!"
11:48:24 <MichaelGG> opiates and benzodiapines help a bit
11:48:42 <chessguy_work> and hallucinogens?
11:48:43 <rwbarton> "Well, learning Haskell, Python or Ruby really makes you worse C# programmer the same way getting university degree makes you worse factory worker."
11:48:53 <vixey> monochrom, that is really sad
11:49:25 <MichaelGG> vixey, no, what's sad are the folks who see higher languages then sya
11:49:30 <MichaelGG> "I'd rather use C++"
11:49:43 <chessguy_work> preach it brother
11:49:52 <erikc> after spending my xmas vacation writing haskell code, i came back to work (c++) to discover that ive been reassigned to UI (a very old flash actionscript impl, reference counted garbage collection!)
11:49:53 <vixey> michaelGG, I don't mind that, I fell sorry for someone who has a job they don't like and suffers because of it
11:50:02 <MichaelGG> I'm astounded how many C# people went NUTS over the "var" keyword which is type inference for local variables.
11:50:15 <MichaelGG> one MS employee called it "fashionably late binding"
11:50:41 <MichaelGG> vixey, well they both suck
11:51:08 <MichaelGG> So are there any interview/hiring tips to find people who can think functionally?
11:51:21 <MichaelGG> I've had good success just doing general screening for intelligence
11:51:52 <chessguy_work> i'd think asking them some kind question about recursion would be good
11:51:58 <chessguy_work> (non-trivial)
11:52:00 <monochrom> Ask them to write a parser. (Give them a simple grammar.)
11:52:10 <chessguy_work> heh. that's a bit much
11:52:46 <erikc> make them convert a loop to a tail recursion function
11:52:52 <erikc> recursive
11:52:56 <vixey> I find parsing realyl really difficult to formall show correct :/
11:52:57 <MichaelGG> i mean, people who might not know functional, but are capable
11:53:11 <MichaelGG> cuase theres lots of good people who when given the chance just do functional perfect from the start
11:53:34 <MichaelGG> I hired a PHP programmer (we use .NET), and in a few days he was oging full speed full functional style
11:53:35 <chessguy_work> MichaelGG, yeah, but if that's true of them and they don't know of functional programming, then they've had their head stuck in the sand
11:53:43 <vixey> (and all the parsers I wrote out myself had bugs in them)
11:53:43 <tehgeekmeister> rwbarton: sorry if you replied after i left, firefox crashed (library blocks irc.)
11:53:46 <chessguy_work> MichaelGG, where are you hiring?
11:53:51 <erikc> even if they dont have functioanl experience, if they get that 'a-ha' moment that tail recursive functions are the same as loops, thats a plus
11:54:00 <erikc> if they didnt know it already
11:54:06 <monochrom> "S ::= S S | (S) | empty   write a parser for that"  It is pretty simple. Definitely simpler than the fabled Microsoft interview question "write an editor in C".
11:54:06 <icqn> MichaelGG, do you use mono?
11:54:09 <MichaelGG> chessguy_work, yes - head in the sand, but can you blame someone? industry doesnt really givey ou any pointers.
11:54:32 <vixey> monochrom, I read Meijers interview questions can be like  write foldr using foldl and foldl using foldr :p
11:54:40 <opqdonut> hehe
11:54:55 <MichaelGG> icqn, yes
11:54:55 <MichaelGG> CLR and mono
11:55:00 <MichaelGG> chessguy_work, not hiring at the monet
11:55:02 <monochrom> Anyway, parsers really show one's programming style, imperative vs functional.
11:55:07 <rwbarton> tehgeekmeister: I'm perplexed.
11:55:13 <monochrom> s/style/mindset/
11:55:18 <chessguy_work> MichaelGG, i dunno, i think watching what kinds of things MS is putting in their languages, and what kind of things are showing up in languages like python, ruby, etc., makes it pretty clear that functional programming is the future
11:55:30 <rwbarton> tehgeekmeister: What if you do a prepare, execute, and then fetch just one row, is the memory usage as bad?
11:55:41 <MichaelGG> chessguy_work, yea, right now
11:55:53 <rwbarton> tehgeekmeister: (It seems to me like it has to be, based on inspection of the source, but it's also kind of hard to believe)
11:55:58 <MichaelGG> I just happened to stumble across F# two or three years ago by luck
11:56:09 <MichaelGG> so iguess theres less excuse these days
11:56:20 <chessguy_work> yep
11:56:41 <chessguy_work> i mean, it's obvious that concurrency is king, and purity is the best way to do that
11:57:15 <tehgeekmeister> rwbarton: trying
11:58:05 <vixey> and in 10 years will you look to microsoft to see what's hot and new?
11:58:05 <rwbarton> tehgeekmeister: I assume the first row of your table is not 500M/16 characters in size
11:58:23 <vixey> I think it's a coincidence that they are using functional programming
11:58:39 <chessguy_work> vixey, really? why?
11:58:41 <chessguy_work> they're not stupid
11:58:43 <rwbarton> > 500000000 / 16
11:58:45 <lambdabot>   3.125e7
11:58:50 <rwbarton> 31 MB
11:59:14 <erikc> microsoft is the most innovative production language company today
11:59:30 <erikc> no one else is even competing really
11:59:39 <chessguy_work> well...they're a leader in the software industry anyway
12:00:15 <rwbarton> erikc: are you talking about f#, or microsoft research and ghc?
12:00:31 <osfameron> and C#, linq, powershell
12:02:31 <pumpkin> erikc: what about apple's Objc2? ;)
12:02:40 <pumpkin> surely that's way better than MS's offerings ;)
12:03:16 <quile> pumpkin: i second that
12:03:20 <vixey> it's basically Objective C with a gc.....
12:03:26 <vixey> and a couple other additions
12:03:33 <pumpkin> :P
12:03:39 <vixey> I wouldn't call it innovation, being practical yes
12:03:49 <Raevel> that gc sure was nice to have though
12:03:54 <sjanssen> isn't all the stuff in Objective C basically 15 years old anyway?
12:04:12 <vixey> sjanssen, yes that's what I was remarking on.. but they did add a couple new things
12:04:44 <sjanssen> things like LINQ, F#, etc. seem to be more unique
12:05:06 <ozy`> it would be nice to see obj-C replaced with a more expressive language
12:05:11 <pejo> rwbarton, MSR is really big. They have plenty of research outside of fp.
12:05:24 <vixey> ozy`, bind it
12:05:49 <ozy`> someone implemented a smalltalk dialect on the obj-C runtime and called it F-script... I don't know how useful it is but it's a nice proof of concept
12:05:50 <rwbarton> pejo: Yes, I know someone there who works on... whatever pure math he wants :)
12:05:56 <ozy`> vixey: sure. not haskell though.
12:06:15 <vixey> what?
12:06:28 <erikc> rwbarton: also the M data language stuff they showed recently is interesting
12:06:33 <vixey> I'm sure you can do a haskell binding to objective c
12:06:48 <ozy`> vixey: you can, and in fact someone has (HOC). but it sucks.
12:07:07 <vixey> HOC does suck that's why I said bind it instead of use HOC :p
12:07:08 <erikc> trying to fix up the SQL trainwreck into something less verbose and closer to the relational algebra
12:07:14 <ozy`> actually writing a cocoa app in HOC looks gruesome, as a matter of fact
12:07:17 <tehgeekmeister> rwbarton: http://hpaste.org/13720#a4 <== getting an annoying type error that i have to fix before i can try fetching a single row
12:07:31 <gnuvince_> :t foldM
12:07:32 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:07:52 * erikc spent an hour trying to get HOC building yesterday for cocoa yi, did not succeed
12:08:25 <ozy`> erikc: yeah, it's a hideous hack at the moment
12:08:41 <tehgeekmeister> erikc: it has some obscure errors when you try to build it, but with sufficient googling i've been able to build it a few times.
12:08:42 <ozy`> I got it to build once, but yi wouldn't compile with it
12:08:51 <tehgeekmeister> i even got yi to compile with it!
12:09:12 <vixey> I think if you want to use objective c from haskell the best move is to start from scratch, not using HOC
12:09:20 <vixey> I could be wrong though
12:09:33 <erikc> i agree
12:09:58 <monochrom> A lot of existential typing in Haskell is used to correspond to objects in Objective C. :)
12:10:00 <erikc> just send/receive messages, keep it all dynamic
12:10:15 <monochrom> Template Haskell is also used greatly for subclassing.
12:11:04 <rwbarton> tehgeekmeister: try changing fromSql to putStrLn
12:11:10 <rwbarton> tehgeekmeister: sorry I mean print to putStrLn
12:12:34 <tehgeekmeister> rwbarton: yep, it was growing just as quick.
12:12:37 <tehgeekmeister> =/
12:12:47 <rwbarton> tehgeekmeister: How big is the first row?
12:12:50 <tehgeekmeister> made it to 400mb before i killed it.
12:13:14 <tehgeekmeister> it's safe to say all the rows are less than a megabyte, since it's from the french wikipedia
12:13:31 <tehgeekmeister> maybe two megabytes, but certainly not 400
12:13:40 <rwbarton> Well, String means you are paying a factor of ~16
12:13:59 <rwbarton> (maybe 32 on a 64-bit platform)
12:14:13 <vixey> why is FORALL not expressible as a code?
12:14:30 <tehgeekmeister> still, 16*2 == 32 worst case, as opposed to 400 some megabytes
12:15:08 <tehgeekmeister> rwbarton: it's less than two pages of output on my screen, fetching it from psql manually just now
12:15:13 <monochrom> which FORALL?
12:15:31 <vixey> monochrom, I was wondering about making codes for types like,
12:15:54 <vixey> data TYPE t where BOOL :: TYPE Bool; (:->:) :: TYPE a -> TYPE b -> TYPE (a -> b)
12:16:11 <vixey> but it seems impossible to write a FORALL :: ?
12:16:37 <monochrom> I guess I don't know the language.
12:17:07 <opqdonut> vixey: you'd have to have stuff like
12:17:12 <opqdonut> a :: TYPEVAR
12:17:17 <opqdonut> then it'd be feasible I guess
12:17:34 <rwbarton> tehgeekmeister: it could be that fetchRow is somehow broken in the postgres driver
12:17:52 <rwbarton> tehgeekmeister: you could try dropping all but the first row of the table and see whether that helps
12:18:19 <rwbarton> tehgeekmeister: Or is the entire table less than two pages of output?
12:18:53 <tehgeekmeister> rwbarton: no, the first row is less than two pages.  the whole table is around two or three gigabytes.
12:19:16 <rwbarton> tehgeekmeister: try making a smaller table to see if fetchRow is just sucky and reading the whole table to spite you
12:19:27 <tehgeekmeister> rwbarton: once i let it run all the way thru and memory usage maxed out at 3.5 gigabytes before it hit a parse error.
12:19:52 <vixey> what on arth is this :"Illegal polymorphic or qualified type: forall a. a"
12:19:58 <vixey> that doesn't make sense...
12:20:36 <vixey> so I'm not even allowed to write forall inside a GADT?
12:21:05 <rwbarton> vixey: context?
12:21:11 <tehgeekmeister> rwbarton: in other words, yes, it read the WHOLE table before it attempted any parsing (i know this for sure because i was trying to parse the wrong column before, so it would've failed parsing on the very first row.)
12:21:29 <vixey> data Foo where FOO :: TYPE (forall a. a)|
12:21:31 <vixey> data Foo where FOO :: TYPE (forall a. a)
12:21:36 <vixey> oops
12:21:40 <vixey> data Foo aa where FOO :: Foo (forall a. a)
12:21:56 <rwbarton> tehgeekmeister: if fetchRow is reading the whole table, it sounds like a bug in something
12:23:55 <tehgeekmeister> rwbarton: =/  so basically i have to switch to takusen or a different db?
12:24:02 <rwbarton> vixey: it seems reasonable to me to disallow that
12:24:08 <vixey> :(((
12:24:27 <vixey> so I can't express quantification in types
12:24:54 <monochrom> (forall a. a) probably means something you don't intend.
12:24:56 * tehgeekmeister suspects mysql has probably been tested a bit more with hdbc, and will probably work better.
12:24:57 <rwbarton> how were you going to use it?
12:25:15 <vixey> my real non-simplified version was like:
12:25:31 <rwbarton> tehgeekmeister: I'm using mysql with hdbc right now.  It was a little painful--you have to go through odbc
12:25:31 <vixey> FORALL :: (forall x. TYPE x -> TYPE (f x)) -> TYPE (forall x. f x)
12:25:37 <rwbarton> tehgeekmeister: and I'm hardly stress-testing it
12:25:55 <vixey> but I get the same error on that
12:27:04 <vixey> oh
12:27:08 <vixey> it's just a bug :P
12:27:27 <vixey> if you try to do the same in a function instead of a GADT, it suggest: "Perhaps you intended to use -XImpredicativeTypes"
12:27:37 <vixey> but if you use this flag, it also allows my constructor though
12:27:48 <vixey> so I think the GHC error message for the GADT should include the helpful message too
12:28:27 <tehgeekmeister> rwbarton: hum.  perhaps i'll try a bit harder to get takusen to build.  i wish this weren't so painful.  all i want to do is use a database in really simple ways!
12:30:36 <vixey> yuck... you have to define, FORALL(n) for each n, like: FORALL2 :: (TYPE x -> TYPE (t x x)) -> TYPE (forall x. t x x)
12:31:00 <vixey> or is there some way to make a general FORALL?
12:31:09 <vixey> *Main> :t FORALL1 (\a -> a :->: a)
12:31:10 <vixey> FORALL1 (\a -> a :->: a) :: TYPE (forall x1. x -> x1)
12:31:10 <vixey> *Main> :t FORALL2 (\a -> a :->: a)
12:31:10 <vixey> FORALL2 (\a -> a :->: a) :: TYPE (forall x. x -> x)
12:31:13 <vixey> that's what happens otherwise..
12:31:23 <vixey> it only abstracts as many as it wants
12:34:43 <sana> hi
12:34:49 <vixey> hi sana
12:35:07 <sana> hi how r u
12:35:13 <vixey> confused :p
12:35:38 <eyeris> I am trying to install ghc 6.10.1 on a debian system from the generic linux binaries. I get an install error but it gives no details. Any idea how I can cause `make install` to tell me what is actually failing? http://hpaste.org/13722#a1
12:35:39 <b\6> i made a PortNumber for a SockAddrInet, but i think htons isn't happening, so i'm connecting to some wacky port rather than the one i wanted.
12:35:42 <sana> were u from
12:35:57 <mauke> b\6: does your code use PortNum?
12:36:03 <b\6> mauke: yeah.
12:36:08 <mauke> b\6: well, stop it
12:36:19 <b\6> mauke: how else do i make a PortNumber?
12:36:36 <rwbarton> b\6: using the Num instance
12:36:38 <mauke> depends on where you got the number from
12:36:47 <b\6> it's an Int, say.
12:36:55 <mauke> if it's a literal, just put it there
12:37:03 <mauke> if it has a fixed type, use fromIntegral
12:37:07 <b\6> hmm, ok.
12:37:19 <tehgeekmeister> http://hpaste.org/13723 <== error i get when trying to build takusen.  google doesn't seem to have anything about it.
12:37:23 <rwbarton> (Yes, it is terrible that this mistake is easy to make)
12:38:07 <rwbarton> tehgeekmeister: I'd guess your version of cabal is either too old or too new
12:38:35 <b\6> tehgeekmeister: i'm anxiously awaiting takusen 0.8.4. think it should fix some stuff related to 6.10.1.
12:38:51 <b\6> or maybe it'll be versioned differently since it's incompatible.
12:39:25 <Peaker> augustss: typo on your LLVM post: "lambda expressionw ith the"
12:40:08 <hallongrottan> :)
12:40:56 <loadquo> Would I be crazy to write an x86-like emulator in Haskell? I'm guessing bytestring would be my friend.
12:41:16 <Peaker> @hoogle unsafePurify
12:41:16 <lambdabot> No results found
12:42:14 <rwbarton> loadquo: More likely you'd want a mutable array like STUArray
12:42:36 <Bushmills> loadquo: i suppose if speed doesn't matter, it would be a nice exercise. but x86 is not the nicest target to emulate.
12:43:09 <tehgeekmeister> rwbarton: i'm using ghc 6.8.3, so whatever comes with that
12:43:38 <tehgeekmeister> b\6: oh that'd be nice.  i've wanted to use takusen over hdbc this whole time, but i've not once gotten it to build...
12:44:25 <vixey> you can actually catch throwError?
12:44:26 <vixey> oops
12:44:29 <vixey> I mean error
12:44:31 <rwbarton> tehgeekmeister: 'cabal install cabal' probably won't break anything and might fix your problem
12:44:50 <tehgeekmeister> rwbarton: i like that.  "probably won't break anything"  *tries
12:45:05 <tehgeekmeister> rwbarton: will i need to sudo for that?
12:45:27 <loadquo> Bushmills, I'm not exactly emulating x86 but something a bit like it (flat memory structure, single processor). I actually want to do some research on low-level architectures that use capability security for memory access, among other things.
12:45:42 <loadquo> rwbarton, thanks I'll check it out.
12:45:43 <rwbarton> tehgeekmeister: not if you don't usually sudo to cabal install things
12:45:51 <Elly> loadquo: are you familiar with the intel iAPX 432?
12:46:04 <Elly> loadquo: it had support for objects in hardware and 'capability segments' to access them
12:46:54 <tehgeekmeister> rwbarton: i don't usually use cabal install at all.
12:47:04 <tehgeekmeister> rwbarton: i may have picked up a bad habit, but i do this
12:47:10 <tehgeekmeister> ghc --make Setup.hs -prof
12:47:24 <tehgeekmeister> ./Setup configure -prof
12:47:29 <tehgeekmeister> ./Setup build
12:47:32 <tehgeekmeister> ./Setup install
12:47:42 <tehgeekmeister> and i sudo for the install, of course
12:47:45 <loadquo> Elly, I haven't looked at that one specifically but I know that hardware capabilities has been done before. I'll stop talking about it before I get more wildly off-topic.
12:48:07 <Peaker> loadquo: object capabilities?
12:48:12 <rwbarton> tehgeekmeister: ok, then just do the same for the cabal package
12:48:27 <Peaker> loadquo: mind coming to #haskell-blah to talk about that?
12:48:59 <Bushmills> loadquo: i'm contemplating to do something not entirely different, implementing a virtual machine based interactive interpreter and incremental compiler. for the same exists native hardware.
12:50:18 <tehgeekmeister> rwbarton: apparently cabal wasn't in my path at all, anyway?
12:50:27 <Bushmills> but that's be more meant as exercise than for practical use.
12:50:39 <vixey> ?djinn f (forall x. x) -> (forall x. f x)
12:50:39 <lambdabot> -- f cannot be realized.
12:50:45 <sbahra> Do you guys make a distinction between "purely functional" and "pure and functional"?
12:50:53 <rwbarton> tehgeekmeister: the cabal library is separate from the cabal executable, which is in the cabal-install package
12:50:53 <opqdonut> nah
12:50:55 <vixey> is djinn right about that?
12:50:57 <rwbarton> tehgeekmeister: only the first is relevant here
12:51:00 <vixey> I really cannot write this function at all?
12:51:19 <opqdonut> i didn't know djinn did foralls
12:51:36 <rwbarton> ?djinn f (foobar x. x) -> (foobar x. f x)
12:51:37 <lambdabot> -- f cannot be realized.
12:51:37 <SamB> djinn doesn't even get lists ...
12:51:40 <opqdonut> i'd say those types are isomorphic
12:51:52 <vixey> GHC doesn't agree :(
12:51:58 <opqdonut> er, no, they're not
12:51:59 <vixey> :t (\x -> x) :: (f (forall x. x) -> (forall x. f x))
12:52:00 <lambdabot>     Couldn't match expected type `x'
12:52:00 <lambdabot>            against inferred type `forall x1. x1'
12:52:00 <lambdabot>       `x' is a rigid type variable bound by
12:52:03 <vixey> I wish they were lol
12:52:23 * loadquo has gone to haskell-blah
12:52:32 <SamB> vixey: well, what's f ?
12:52:43 <vixey> f is any * -> *
12:52:56 <augustss> Peaker: thanks
12:52:58 <rwbarton> vixey: what if f is data F where Baz :: F (forall x. x) :)
12:53:07 <SamB> you mean an arbitrary one or a particular one ?
12:53:14 <vixey> rwbarton, I don't think that typechecks
12:53:22 <vixey> SamB: I'm not sure what the difference is
12:53:27 <ski_> or `data F a = MkF (a -> Bool)'
12:53:29 <SamB> rwbarton: then f isn't * -> *
12:53:36 <vixey> I have no specific f in mind
12:53:38 <SamB> vixey: who gets to pick
12:53:39 <rwbarton> SamB: huh?
12:53:59 <vixey> SamB: it'll come from: FORALL1 :: (forall x. TYPE x -> TYPE (t x)) -> TYPE (forall x. t x)
12:54:12 <vixey> the 't', I guess GHC picks it
12:54:25 <SamB> what is that ???
12:54:40 <vixey> SamB: you haven't seen the GADT syntax ?
12:54:43 <rwbarton> SamB: Oh sorry, I left out the kind signature F :: * -> *
12:54:44 <ski_> (that `t' is foralled : `FORALL1 :: forall t. ..t..)
12:54:48 <SamB> I have
12:54:50 <SamB> but not like THAT
12:54:53 <vixey> :p
12:54:58 <vixey> I'm just trying something out
12:55:12 <rwbarton> vixey: anyways there is nowhere for Baz to go under your f (forall x. x) -> (forall x. f x) function
12:55:20 <augustss> Elly: iapx 432 was really.  And abysmally slow.
12:55:35 <Elly> augustss: yep~
12:55:35 <augustss> Elly: really cool, that is.
12:55:39 <Elly> er, yep!
12:55:39 <vixey> rwbarton: data F where Baz :: F (forall x. x)
12:55:43 <Elly> also a total commercial failure
12:55:46 <vixey> rwbarton, stilll doesn't typecheck..
12:55:47 <Elly> but it's a neat idea
12:55:50 <rwbarton> data F :: * -> * where Baz :: F (forall x. x)
12:55:52 <rgr> exit
12:55:57 <SamB> well, if you don't have a clue what f is, you aren't going to even have a function of type forall f x. x -> f x ...
12:55:58 <rwbarton> I didn't realize the kind signature wouldn't be inferred
12:56:05 <vixey> data F :: * -> * where Baz :: F (forall x. x)
12:56:15 <tehgeekmeister> rwbarton: http://hpaste.org/13723#a1 <== different error after reinstalling cabal
12:56:15 <augustss> Elly: I've actually used a box with an iapx432 once.
12:56:17 <vixey> F (forall x. x) -> forall x. F x
12:56:31 <vixey> oh I see!
12:56:33 <Elly> augustss: wow!
12:56:35 <vixey> rwbarton, ty
12:56:37 <SamB> rwbarton: oh, my kind iference is lousy
12:56:47 <SamB> much like lhc's seems at the moment
12:56:55 <vixey> so how the hell do I write _my_ program :/
12:57:55 <rwbarton> (I don't understand why the kind isn't inferred; if I give formal arguments then *their* kinds are inferred...)
12:58:00 <Cale> loadquo: Not *too* crazy, though if you want decent performance, you might want to use something like Harpy.
12:58:13 <vixey> rwbarton, you can write  data F x where ...
12:58:19 <vixey> rwbarton, and then it infers F :: * -> *
12:58:37 <vixey> oh I see what you mean, yeah
12:58:39 <Cale> loadquo: (It basically allows you to generate and execute x86 code at runtime.)
12:58:40 <rwbarton> vixey: right, and with a different definition it might infer F :: (* -> *) -> * (if ... OK
12:58:42 <vixey> it should be possible
12:59:37 <vixey> the problem here is that I can't write /\t::* -> ... in haskell I think
12:59:45 <vixey> is there a workaround ?
12:59:50 <bos> Cale: or the LLVM bindings :-)
13:00:47 <dons> bos: super simple static response-only http server can do 11.5k conn/sec. http://hpaste.org/13719 . how would we make that even faster?
13:01:00 <dons> just benchmarking what the underlying limits are here
13:01:01 <ski_> (vixey : can't you just add `forall t. ' .. or am i misunderstanding the issue ?)
13:01:16 <vixey> ski_, to what?
13:01:18 <dons> (also, interestingly, -threaded improves performance signficantly, wihtout using forkIO)
13:01:20 <h0tzenpl0tz> hello, could anybody help me to do a ceiled division? Integer a,b => ceiling (a / b)
13:01:25 <bos> dons: i've modified network-bytestring to handle lazy ByteStrings
13:01:33 <dons> nice
13:01:37 <ski_> vixey : `FORALL1 :: forall t. ...'
13:01:45 <bos> dons: so that eliminates a layer of copying.
13:01:47 <vixey> ski_, I can add that yes
13:01:48 <dons> > ceiling ( pi / 2)
13:01:48 <lambdabot>   2
13:01:52 <Cale> h0tzenpl0tz: ceiling (fromIntegral a / fromIntegral b)
13:01:52 <vixey> ski_, I think that everything stays the same though
13:02:01 <dons> bos: oh, you can just put the bytestring chunk on the output handle?
13:02:03 <bos> dons: http://github.com/bos/network-bytestring/tree/master
13:02:08 <vixey> (I do get the same error)
13:02:19 <bos> dons: you can send a lazy bytestring to a Socket in a single system call
13:02:21 <ski_> (vixey : do you have a paste, so i can see the issue ?)
13:02:23 <dons> cloning.
13:02:33 <dons> bos, that's exactly what i'm looking for :)
13:02:36 <bos> dons: this is what i use for my memcached client
13:02:47 <bos> dons: which is faster, so far, than the fastest C client i can find
13:02:49 <h0tzenpl0tz> Cale: thanks alot!
13:03:00 <dons> i'm doing some very performance sensitive ipc stuff for work.
13:03:08 <Cale> h0tzenpl0tz: Or, probably better would be to make use of div/mod.
13:03:17 <h0tzenpl0tz> why?
13:03:21 <dons> passing data between vm instances, so thinking about how best to structure tihs
13:03:32 <Cale> h0tzenpl0tz: Converting to Double loses precision.
13:03:33 <bos> ah.
13:03:33 <dons> so thanks, i'll have a poke around
13:03:36 <augustss> h0tzenpl0tz: are a and b positive?
13:03:51 <h0tzenpl0tz> augustss: yes, image-coordinates
13:03:52 <bos> dons: i guess that in that case, you don't have a linux kernel under you
13:04:04 <augustss> h0tzenpl0tz: (a+b-1) `div` b
13:04:06 <dons> right. the kernel is ghc-rts :)
13:04:14 <dons> with a bit of xen.
13:04:17 <h0tzenpl0tz> augustss: ah, thanks!
13:04:32 * rwbarton needs GADTs in data families :(
13:04:44 <tehgeekmeister> which ghc/cabal versions have people gotten takusen to build with?
13:04:44 * twanvl thinks there should be a standard divUp function
13:04:50 <bos> dons: people have published about an inter-VM loopback for Xen, but i don't think it's actually available in mainline
13:05:04 <dons> yeah, i expect we'll be pushing patches upstream
13:05:27 <dons> intersting project: only pure haskell allowed, very high performance requirements.
13:05:30 <bos> actually, the problem is that there are way too many inter-VM communications mechanisms from everyone and their mom
13:05:36 <Cale> cdiv a b = a `div` b + signum (a `mod` b) -- I think this is right...
13:05:41 <dons> yep. that's what i'm wading through now.
13:05:55 <bos> dons: what did you benchmark your HTTP server with?
13:06:05 <dons> httperf
13:06:11 <Gracenotes> hm. a lazy stack language might be kind of cool.
13:06:11 <bos> ah. single client at a time?
13:06:22 <dons> yeah, its not really mine. it was from a blog post i saw yesterday
13:06:24 <Cale> @check let cdiv a b = a `div` b + signum (a `mod` b) in \a b -> cdiv a b == ceiling (fromInteger a / fromInteger b)
13:06:25 <dons> just tweaked to use a bytestring
13:06:25 <lambdabot>   "* Exception: divide by zero
13:06:35 <Cale> @check let cdiv a b = a `div` b + signum (a `mod` b) in \a b -> b /= 0 ==> cdiv a b == ceiling (fromInteger a / fromInteger b)
13:06:36 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
13:06:36 <lambdabot>           ...
13:06:45 <Cale> er...
13:06:50 <dons> bos, i wonder if
13:06:51 <dons> data IOVec = IOVec { iovBase :: Ptr CChar , iovLen :: CSize }
13:06:56 <dons> should have some ! {-# UNPACK #-} ?
13:07:08 <dons> or is it just packed over to C
13:07:28 <bos> dons: i was focusing on correctness there, really, didn't try any strictness annotations.
13:07:49 <Cale> oh, there is a problem with that anyway
13:07:52 <dons> k
13:08:11 <asgaroth> @check let cdiv a b = a `div` b + signum (a `mod` b) in \a b -> if b == 0 then True else cdiv a b == ceiling (fromInteger a / fromInteger b)
13:08:11 <SamB> hmm ... I've got a kind inference problem here: http://pastebin.com/f2b4873e1e
13:08:13 <lambdabot>   "Falsifiable, after 6 tests:\n-2\n-3\n"
13:08:21 <SamB> erg.
13:08:27 <SamB> http://pastebin.com/f2b4873e1
13:08:39 <vixey> is this really supposed to happen?
13:08:47 <vixey> Cannot match a monotype
13:08:49 <Cale> Yeah, or cdiv 1 (-2)
13:08:56 <vixey> Expected type: TYPE x  Inferred type: TYPE (forall x1. x -> x1)
13:09:07 <vixey> why can't it abstract out the 'x'?
13:09:27 <dnul_> :t nub
13:09:28 <lambdabot> forall a. (Eq a) => [a] -> [a]
13:09:35 <Cale> @check let cdiv a b = a `div` b + abs (signum (a `mod` b)) in \a b -> b == 0 || cdiv a b == ceiling (fromInteger a / fromInteger b)
13:09:37 <lambdabot>   "OK, passed 500 tests."
13:09:40 <bos> dons: i get about 5700 requests/sec with your code on my laptop
13:09:43 <Cale> yeah, that's it
13:09:47 <vixey> I even turned of monomorphism restriction but it didn't make a difference
13:10:08 <vixey> I think need FPH :/
13:10:09 <bos> dons: refactoring to use network-bytestring now
13:10:16 <dons> bos, that's interesting. i get 11.5k on a core 2
13:10:29 <dnul_> what does the nub function?
13:10:29 <bos> dons: i'm running 64-bit
13:10:34 <dons> me too
13:10:38 <bos> huh.
13:10:40 <Cale> dnul_: It removes duplicates
13:10:41 <dons> bos: -threaded ?
13:10:45 <dnul_> :P nice
13:10:49 <dnul_> Cale: thx
13:10:54 <Cale> > nub "abracadabra"
13:10:56 <lambdabot>   "abrcd"
13:11:06 <matthewp> Cale: since you're here, can you set up an auto-join for lamdbabot on #novalang for the Real World Haskell book club?
13:11:13 <Cale> okay
13:11:19 <bos> dons: ah, with -threaded, i get 7900
13:11:24 <Cale> lambdabot: @join #novalang
13:11:36 <dons> hc -O2 -fvia-C -optc-O3 -funbox-strict-fields --make -threaded
13:11:38 <dons> i think i used.
13:11:39 <chessguy_work> Cale, it's in there - he means for when the bot reboots
13:11:54 <Cale> chessguy_work: I'm doing the rest now
13:12:08 <chessguy_work> ah, ok
13:12:30 <SamB> darnit!
13:12:44 <SamB> I hate the kind monomorphism restriction :-(
13:13:04 <Cale> Kind monomorphism restriction?
13:13:08 <SamB> it makes the compiler debugger's life much much harder
13:13:17 <SamB> Cale: yes, kinds are restricted to being monomorphic!
13:13:17 <augustss> SamB: you have to use it cleverly to your advantage :)
13:13:33 <SamB> augustss: I don't see how I can use it to find where the compiler bugs are
13:13:41 <Cale> SamB: What do you want a polykind for?
13:13:51 <Cale> (Just out of interest)
13:14:01 <augustss> yeah, I'm curious too
13:14:04 <SamB> Cale: well, polykinds would make it much easier to spot where the kind inference was missing some kind information ;-P
13:14:28 <SamB> the trouble with defaulting to * is that it works far too often
13:14:51 <Cale> Oh... I would expect there to be kind variables at that level...
13:15:01 <Cale> There aren't?
13:15:08 <SamB> Cale: there are! before they get defaulted to *...
13:15:21 <rwbarton> Hence "monomorphism"
13:15:26 <olsner> what's a kind variable? :P
13:15:48 <Cale> olsner: Like type variables, except they range over kinds instead :P
13:15:54 <Draconx> olsner, one that buys you lunch once in a while.
13:16:52 <olsner> Cale: ah! I've wanted to use one of those
13:17:09 <Cale> Really?
13:17:13 <olsner> it kept my type-level church numeral multiplication from working
13:17:23 <SamB> what's a nice pastebin that isn't hpaste ...
13:17:38 <olsner> or maybe it was exponentiation that wouldn't kind-check properly
13:17:41 <vixey> kind variables ? you must be kidding
13:17:43 <Cale> SamB: hpastetwo
13:17:48 <bos> dons: using network-bytestring improves performance from 7900/sec to 11000/sec
13:17:50 <SamB> Cale: is that for real ?
13:17:56 <vixey> apparently Scala has _sub-kinding_
13:17:58 <Cale> http://www.moonpatio.com:8080/
13:18:14 <Cale> vixey: So does GHC
13:18:37 <olsner> zomg, what's sub-kinding?
13:18:39 <SamB> why isn't Haskell listed at the top next to None and C ?
13:18:43 <bos> dons: i'd have to call that pretty schweeeet
13:18:54 <bos> dons: no difference between strict and lazy in this trivial case
13:19:21 <Cale> SamB: what?
13:19:25 <olsner> bos: does that also get the same mysterious boost when compiling with -threaded?
13:19:37 <SamB> Cale: in the language menu
13:19:54 <Cale> The languages are in alphabetical order.
13:19:57 <augustss> olsner: like subtyping, but at the kind level.  ghc uses a simple kind lattice to handle the kinds for boxed types, unboxed types, etc
13:20:56 <bos> olsner: yes, but less dramatic.
13:20:59 <dons> bos, awesome.
13:21:06 <dons> bos, can you stick it on hpaste?
13:21:09 <bos> olsner: there's nothing mysterious about it.
13:21:12 <dons> i'll give it a whirl on my system
13:21:17 <bos> dons: http://hpaste.org/13719#a1
13:21:34 <bos> olsner: the threaded and non-threaded runtimes have completely different IO code.
13:21:43 <Cale> This talk about the kind system reminds me how much I'd like to see proper records/variants with row polymorphism.
13:21:51 <SamB> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=734
13:22:09 <bos> dons: i must say, chewing through 11000 requests/sec even with a mickey mouse program is really impressive
13:22:12 <olsner> augustss: is subkinding the same as e.g. class inheritance, like an is-a relation between kinds?
13:22:23 <tehgeekmeister> how can i force a specific version of cabal to be used, so that i can build a package that only works with a specific version?
13:22:24 <vixey> would haskell with explicit /\ and type application be great or horrible?
13:22:30 <SamB> that's a trace of the kind inference and the module in question ... anyone have any idea what kind that is that's been defaulted ?
13:22:31 <dons> Request rate: 11384.8 req/s (0.1 ms/req)
13:22:40 <olsner> I wonder what the equivalent C http server would do
13:22:40 <augustss> olsner: yeah, but very simple in this case
13:22:55 <rwbarton> vixey: have you looked at ghc core output? :)
13:23:03 <vixey> no
13:23:06 <augustss> vixey: If you always had to use the type application it would be horrible.
13:23:08 <bos> dons: that's within a whisker of me
13:23:15 <dons> bos, but that's not using network-bytestring is it?
13:23:19 <vixey> yes
13:23:20 <dons> import Network ?
13:23:21 <bos> dons: my code?
13:23:36 <dons> what module is it importing from network-bytestring?
13:23:43 <bos> Nertwork.Socket.ByteString
13:23:57 <augustss> vixey: optional use of yupe application would be good, IMO
13:24:03 <dons> bos, not in that paste.
13:24:05 <vixey> augustss, I tried to internalize djinn using GADTs but it's too hard withouth /\ :(
13:24:07 <augustss> s/yupe/type/
13:24:18 <bos> dons: oh noes! bad paste!
13:24:27 <olsner> heh, you seem to have pasted don's code instead of your own
13:24:35 <dons> so that paste gives me 11384, what i was getting before :)
13:24:44 <bos> http://hpaste.org/13719#a2
13:24:45 <SamB> thoughtpolice: have you guys done any changes to the KindInfer module ?
13:24:57 <bos> dons: ^^^
13:25:02 <rwbarton> augustss: I would like it too.  There are generally workarounds but they're ugly
13:25:05 <dons> ah
13:25:09 <erikc> Cale: can you define / point me to a paper on row polymorphism? im not familiar with the term
13:25:14 <bos> dons: i wonder why your perf is so good
13:25:21 <vixey> rwbarton, what workaround do you know?
13:25:23 <vixey> I don't know any.....
13:25:27 <dons> Request rate: 14424.9 req/s (0.1 ms/req)
13:25:33 <bos> dons: yummy!
13:25:34 <augustss> rwbarton: yeah, type proxies are ugly
13:25:38 <dons> good enough for government work
13:25:51 <Cale> erikc: Well, you have type variables (with a special kind) that represent an arbitrary record type.
13:25:53 <Raevel> <3 tube-switcher guy
13:26:12 <Cale> erikc: Together with operations that extend a record type with additional fields.
13:26:19 <bos> stdio-style buffering is not really your friend with sockets.
13:26:35 <augustss> vixey: use a regular argument instead of a type argument, and then pass (undefined::T)
13:26:35 <olsner> bos: hmm, Main.hs:28:4: Not in scope: `sendAll'
13:26:45 <vixey> oho
13:26:46 <bos> olsner: you need to clone my git repo, not tibbe's
13:26:59 <SamB> Cale: see line 771 ?
13:27:01 <Cale> erikc: So you can write polymorphic functions that operate on any record with the appropriate fields.
13:27:01 <bos> olsner: http://github.com/bos/network-bytestring/tree/master
13:27:05 <olsner> bah, and here I was using the plain hackage version
13:27:15 <Cale> SamB: yeah?
13:27:26 <bos> olsner: that's SO 2008
13:27:30 <tibbe> bos: what's this repo you're talking about? :)
13:27:31 <SamB> don't suppose you've any idea what that is ...
13:27:32 <tehgeekmeister> oh, whoa, ghc 6.10 got released while i wasn't looking, apparently...
13:27:36 <rwbarton> augustss: I am thinking of using a newtype Label a b = Label { unLabel b } and having class Foo a where foo :: Label a Int rather than foo :: a -> Int
13:27:38 <bos> tibbe: see url above
13:27:40 <tehgeekmeister> *updates
13:27:46 <tibbe> bos: something I ought to pull?
13:27:47 <rwbarton> augustss: that way I can store an Int in the dictionary which only needs to be computed once
13:27:50 <therp> tehgeekmeister: that was quite a while ago :)
13:27:51 <bos> tibbe: i've added lazy bytestring support to network-bytestring
13:28:04 <bos> tibbe: not yet, i haven't ported it to WinSock's shitty API yet
13:28:09 <ideamonk>  hi everyone!
13:28:09 <ideamonk> <nailcuts> i and my friends have been reading about motion detection since past few weeks
13:28:09 <ideamonk> <nailcuts> done some programming in matlab too
13:28:09 <ideamonk> <nailcuts> any ideas on application of motion detection apart from surveillance ?
13:28:14 <bos> tibbe: on the other hand, maybe you don't care
13:28:18 <vixey> this error: Couldn't match expected type `t x x x' against inferred type `x -> x -> x'
13:28:24 <vixey> is because GHC gives up easily?
13:28:29 --- mode: ChanServ set +o bos
13:28:39 --- mode: bos set +b *!n=ideamonk@122.167.26.*
13:28:44 <erikc> Cale: is this equivalent to a typeclass per record 'kind' and extending a record promotes to a different type class?
13:28:45 --- kick: ideamonk was kicked by bos (bos)
13:28:48 <vixey> or because t must be a single type constructor?
13:28:51 <tibbe> bos: some support is better than none as long as it's documented as platform specific
13:28:58 <Cale> vixey: The latter
13:28:59 <opqdonut> vixey: the latter
13:29:01 --- mode: bos set -o bos
13:29:11 <opqdonut> :)
13:29:13 <Cale> erikc: er...
13:29:16 <tibbe> bos: I so want a sendAll for [Strict.ByteString] too though
13:29:27 <bos> tibbe: there is
13:29:30 <vixey> lol bos kind of a eird reason to ban
13:29:48 <olsner> well, obvious troll was obvious
13:29:51 <tehgeekmeister> rwbarton: yeah, from around august to december i didn't touch anything programming or haskell related, so i didn't see it.
13:29:51 <vixey> oh
13:30:03 <vixey> they were asking about applications more than implementations
13:30:21 <Cale> bos: What was that ban about?
13:30:24 <bos> tibbe: you're welcome to pull as-is if you like. the code works.
13:30:38 <Raevel> why is that trolling? am i a troll if i don't get it?
13:30:44 --- mode: ChanServ set +o Cale
13:30:51 <bos> Cale: too hasty, probably
13:30:58 <tibbe> bos: I would probably prefer a .Lazy module though
13:31:00 --- mode: Cale set -b *!n=ideamonk@122.167.26.*
13:31:04 <bos> Cale: tibbe there is
13:31:08 <bos> er, oops
13:31:10 <tibbe> bos: excellent
13:31:13 <bos> tibbe: there is a .Lazy module
13:31:22 <tibbe> bos: let me read the code before asking more silly questions then ;)
13:31:24 <rwbarton> Anyone know when ghc 6.10.2 might come out?  Trying to decide whether to work around a missing feature in ghc 6.10.1 that's fixed in the HEAD...
13:31:29 <bos> tibbe: certainly :p-)
13:32:08 --- mode: Cale set -o Cale
13:32:13 <bos> Cale: thanks
13:32:56 <Cale> erikc: I suppose it is somewhat like a typeclass per record type, yeah.
13:33:29 <erikc> with sugar on top
13:34:04 <dainanaki> hey everyone, i'm trying to write a little basic text editor, and i'm wanting to build in key combination bindings, but i'm not sure how to get the signals for ctrl, alt, and so on.
13:34:16 <dainanaki> anyone have some ideas?
13:34:23 <Cale> Well, you'd also have a kind of field labels, and one value per field label type.
13:34:24 <thoughtpolice> SamB: no, don't believe so
13:34:42 <Cale> Something like:  'fieldName :: ('fieldName :: Label)
13:35:03 <dons> dainanaki: it depends on what ui you're using
13:35:16 <dainanaki> is my irc client working?
13:35:19 <dainanaki> oh there we go
13:35:25 <Raevel> yes probably
13:35:39 <dainanaki> did my earlier messages show up?
13:35:56 <opqdonut> yes
13:35:57 <Cale> Then some type-level operations for attaching types to labels, and composing them into rows.
13:36:15 <SamB> thoughtpolice: oh, I seem to have at least one patch that hasn't made it into your repo ...
13:36:21 <SamB> that might help
13:36:51 <SamB> oh rats, you're using a genuine darcs 2 repo :-(
13:37:20 <dainanaki> how do you receive signals for ctrl, alt and the other modifier buttons in the terminal in haskell?
13:37:34 <dons> dainanaki: which terminal io lib are you using?
13:37:37 <dons> curses? termio?
13:37:41 <thoughtpolice> yeah we switched a while back :/
13:37:58 <opqdonut> dainanaki: short story: looking at bit-patterns
13:38:15 <SamB> thoughtpolice: so how am I supposed to pull over my patches ???
13:38:17 <opqdonut> dainanaki: long story: it's hell
13:38:21 <Cale> SamB: What's wrong with genuine darcs 2 repos?
13:38:40 <SamB> Cale: I have patches in darcs 1 format that I can't pull in :-(
13:38:49 <dainanaki> dons, none yet. i just decided that i want to write a text editor, but i have no idea how to do anything terminal-io wise aside from using the basic System.IO stuff. I'm pretty sure that won't help though.
13:39:11 <opqdonut> look at ncurses bindings
13:39:24 <opqdonut> there was a hscurses ages ago, dunno if it's still alive
13:39:35 <dainanaki> i'll take a look on hackage
13:39:37 <Peaker> dainanaki: the tty device will translate some inputs (such as ^C) to signals. You can see which with (stty -a). Other than that, the tty device will generally convert key combo's to various character strings. Best to use a terminal library to abstract that
13:39:46 <dons> dainanaki: ah, so you might look at yi 0.1
13:39:49 <dons> which did all   that with curses
13:39:58 <dainanaki> mm how does yi do it now?
13:40:06 <dons> it uses gtk
13:40:10 <dons> or vty
13:40:14 <dainanaki> i download 0.5 but it's a little confusing
13:40:17 <Peaker> what's vty?
13:40:33 <Peaker> virtual teletype terminal?
13:40:37 <thoughtpolice> a simple curses-like library
13:40:41 <Peaker> ah
13:40:52 <dainanaki> what are the benefits of vty over curses?
13:40:59 <thoughtpolice> yi is the main project using vty afaics
13:41:47 <rwbarton> Cale: Here's an example where kind polymorphism might be useful in principle: http://hpaste.org/13727
13:41:53 <tibbe> bos: some nice performance you got there
13:42:01 <thoughtpolice> SamB: you might have to get a diff of your patch (i.e. something that 'diff -u' would produce) and apply it manually :(
13:42:08 <dainanaki> yi is pretty neat, but i'm hoping to generate some competition if i can stick with this little project long enough to make it useful
13:42:26 <bos> tibbe: not bad for 90 seconds of hacking
13:42:51 <tibbe> bos: nope, is that with the epoll backend?
13:42:53 <bos> tibbe: also, with network-bytestring, binary, and attoparsec, i have a faster memcached client than the best asynchronous C client
13:42:59 <bos> tibbe: no, just plain 6.10.1
13:43:05 <tibbe> bos: cool
13:43:16 <Cale> rwbarton: hm?
13:43:22 <bos> i don't think epoll would make any difference with just one client.
13:43:22 <thoughtpolice> bos: have you tested attoparsec v. parsec3?
13:43:28 <Cale> rwbarton: ah, I see
13:43:38 <vixey> is this error: Couldn't match expected type `f x x x'  against inferred type `A3 a a a', because A3 is a 'type' instead of newtype or data?
13:43:41 <rwbarton> Cale: I'm only using the case where the made-up kind variable ! is * in my code, but if this were in a general library, one might want to make it more general
13:43:43 <tibbe> bos: I tried to look at the haddoc for attoparsec but it didn't build on hackage (the haddock docs that is)
13:43:43 <thoughtpolice> (in terms of performance)
13:43:45 <bos> thoughtpolice: attoparsec was far faster, last time i looked
13:43:46 <roconnor> wow: http://mac.softpedia.com/get/Development/Libraries/colour-library.shtml
13:43:51 <bos> tibbe: hm
13:43:52 <roconnor> I wonder if all of hackage is up there
13:43:54 <tibbe> bos: no you're right
13:43:54 <thoughtpolice> bos: yay :)
13:44:45 <rwbarton> Cale: I think darcs might even use this type with ! = * -> *
13:44:59 <milton13> @src monad
13:44:59 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:45:05 <milton13> @src Monad
13:45:05 <lambdabot> class  Monad m  where
13:45:05 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:45:05 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:45:05 <lambdabot>     return      :: a -> m a
13:45:05 <lambdabot>     fail        :: String -> m a
13:45:12 <bos> i'm very motivated to switch attoparsec over to a continuation-based mechanism.
13:45:31 <bos> using a pure API on top of Socket.getContents just makes me feel queasy.
13:45:44 <bos> there's no way to control server-side timeouts or the like that way.
13:45:45 <tibbe> bos: what's this sendLimit?
13:45:58 <bos> tibbe: just in case you try to send a 4GB lazy bytestring
13:46:01 <tibbe> bos: lazy I/O makes me queasy in general
13:46:05 <tibbe> bos: ah
13:46:11 <bos> tibbe: it ensures that there's a cap on the amount of data it will try to send in a single system call
13:46:17 <tibbe> bos: could use some comments ;)
13:46:27 <bos> tibbe: comments are for people who can't read minds :-)
13:46:35 <tibbe> bos: heh
13:46:46 <bos> also, for people who don't use irc
13:46:49 <Cale> heh, I just realised that @src result for Monad is odd.
13:47:09 <tibbe> bos: looks like 'k' in loop could use a bang pattern
13:47:11 <Cale> It's inconsistent with regard to the explicit use of forall
13:48:58 <bos> tibbe: no, it's inspected immediately
13:49:09 <tibbe> bos: ok
13:49:30 <bos> tibbe: the first guard clause forces it
13:49:51 <bos> tibbe: likewise, the use of poke forces q
13:50:24 <Olathe> Cale: Thanks for fixing @src [] (>>)
13:52:52 <tibbe> bos: I'll look into merging the code back tomorrow
13:53:05 <bos> tibbe: thanks
13:53:21 <tibbe> bos: no promises before I've read it ;)
13:53:33 <mux> anyone interested in hacing a look at quickcheck tests for Data.Trie to ensure I'm doing things right?
13:54:26 <leimy> probably a dumb question, but is String an instance of Ord, and what's the easiest way to find out if a particular list type is an instance of some class?
13:54:43 <Olathe> @src Ord
13:54:43 <lambdabot> class  (Eq a) => Ord a  where
13:54:43 <lambdabot>     compare      :: a -> a -> Ordering
13:54:43 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:54:43 <lambdabot>     max, min         :: a -> a -> a
13:54:53 <Olathe> > "" < ""
13:54:55 <lambdabot>   False
13:54:57 <leimy> oh
13:55:01 <leimy> hmmm
13:55:05 <rwbarton> leimy: [a] is an instance of Ord iff a is
13:55:09 <Olathe> > getType [5]
13:55:10 <lambdabot>   Not in scope: `getType'
13:55:19 <Olathe> > show.typeRep $ [5]
13:55:20 <lambdabot>   Not in scope: `typeRep'
13:55:33 <adimit> Hm. Is there a splitAtChar :: String -> Char -> [String] function, outside of ByteString? I'd be content with splitAtElem :: [a] -> a -> [[a]], which I ended up writing: http://hpaste.org/13729
13:55:34 <leimy> rwbarton: ok thanks!
13:55:59 <leimy> I mean I could just try it, the compiler will catch me if I violate a function's constraints :-)
13:56:00 <adimit> (btw, hpaste doesn't seem to handle unicode math symbols too well)
13:56:10 <dons> adimit: hpaste 2 does though
13:56:18 <dons> but hpaste.org hasn't been upgraded yet
13:56:21 <mux> adimit: Data.List.Split probably has it
13:56:37 <bos> dons: is it a known weakness of Data.Binary.Put that a too-long sequence of actions causes a stack overflow?
13:56:53 <adimit> mux: hoogle doesn't find it...
13:56:58 <mux> wait a second
13:57:04 <dons> bos, that is not known.
13:57:12 <adimit> so that's why I probably overlooked it, sorry :-\
13:57:17 <mux> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
13:57:31 <roconnor> can you CPS the Put monad?
13:57:33 <Olathe> > typeOf [5]
13:57:34 <lambdabot>   [Integer]
13:57:39 <dons> roconnor: it already is
13:57:39 <Olathe> > show.typeOf $ [5]
13:57:41 <lambdabot>   "[Integer]"
13:57:46 <mux> it doesn't have haddock documentation, whch is probably why it's not indexed by hoogle
13:57:50 <roconnor> and it still stack overflows?
13:57:54 <roconnor> hmm
13:58:00 <adimit> mux: yes, I just noticed.
13:58:03 <dons> well, i'm not sure what bos' issue is.
13:58:10 * mux has overflow with the Get monad :-)
13:58:12 <dons> it would be a miscompile or mis-inlining i think
13:59:23 <tibbe> bos: do you know if the linux kernel ever merges in changes from other peoples trees or if all changes are rebased on top?
13:59:36 <bos> tibbe: it always merges
13:59:40 <rwbarton> leimy: oh also in general you can use :i <class name> or :i <type name> in ghci to find out about instances
13:59:43 <bos> linus never rebases.
13:59:53 <bos> very few of his lieutenants do so, either.
13:59:56 <tibbe> bos: ok so there are several parents of lots of commits?
13:59:58 <leimy> :i String
14:00:01 <bos> tibbe: yes.
14:00:13 <Olathe> @instances String
14:00:14 <lambdabot> Couldn't find class `String'. Try @instances-importing
14:00:22 <Olathe> @instances Expr
14:00:23 <lambdabot> Couldn't find class `Expr'. Try @instances-importing
14:00:23 <rwbarton> leimy: not here, only in ghci (it's a lot of output)
14:00:26 <Olathe> @instances-importing Expr
14:00:27 <lambdabot> Couldn't find class `Expr'. Try @instances-importing
14:00:28 <bos> dons: why is the mersenne-random package so slow on a 64-bit box? any idea?
14:00:30 <leimy> rwbarton: I see that
14:00:32 <leimy> thank you!
14:00:37 <Olathe> Yes, I might want to try @instances-importing
14:00:40 <mux> dons: btw, if you have any advices for that overflow with decodeFile, I'd be glad; should I try to add more SCCs for instance?
14:00:41 <Olathe> Maybe.
14:00:42 <dons> bos, the impure one? it shouldn't be.
14:00:43 <tibbe> bos: so I guess I should merge your branch as well
14:00:46 <bos> dons: right
14:00:51 <dons> bos, let me check on my box...
14:00:51 <tibbe> bos: should be a fast forward
14:00:56 <bos> tibbe: yes, that would be the usual thing to do
14:01:06 <dons> 0.1.3?
14:01:15 <dons> cd tests ; make ?
14:01:42 <bos> dons: yes
14:01:48 <bos> dons: let me get the repo, i installed with cabal-install
14:02:06 <tibbe> bos: alright, I'll do the merge tomorrow, I would greatly appreciate if you added some comments on the not so obvious parts
14:02:14 <tibbe> bos: would make it much easier for me to merge
14:02:23 <bos> tibbe: yes, i'm doing that.
14:02:29 <tibbe> bos: thanks :)
14:02:43 <dons> System.Random "Int" et al is expected to be slow.
14:02:46 <tibbe> bos: once we're happy with the API and implementation I'll make another release
14:03:01 <dons> System.Random: 23415782 "Int"
14:03:01 <dons> 9223371993751891118
14:03:01 <dons> Computation time: 43.131 sec
14:03:01 <dons> System.Random.Mersenne: 23415782 "Int"
14:03:01 <dons> 9223371885424769955
14:03:01 <bos> dons: what should i be looking for?
14:03:03 <dons> Computation time: 0.380 sec
14:03:06 <dons> looks ok to me.
14:03:20 <dons> System.Random: 43s, System.Random.Mersenne: 0.38s
14:03:33 <dons> with roughly similar big numbers
14:03:45 <dons> bos, what makes you think its slow?
14:04:09 <bos> dons: it's much slower on my 64-bit box than on my 32-bit box.
14:04:50 <bos> dons: so it's not slow in an absolute sense, just relative to 32-bit
14:04:55 <SamB> thoughtpolice: where would you want me to put a regression test for kind inference ?
14:05:14 <dons> try setting use_sse2
14:05:23 <bos> oh weird: 'error: CPU you selected does not support x86-64 instruction set'
14:05:27 <dons> cabal install -fuse_sse2
14:05:49 <dons> compiled for wrong machine?
14:06:03 <bos> dons: no, a build error for the pi.hs test
14:06:15 <thoughtpolice> SamB: lhc/regress/tests/2_language/ would probably work
14:06:28 <thoughtpolice> SamB: I believe lhc-regress tracks compile-time errors too, so that should be fine.
14:06:57 <vixey> why isn't
14:06:59 <thoughtpolice> SamB: if not I can code something into lhc-regress fast and push a patch
14:07:03 <vixey> a -> a -> a  =  f a
14:07:15 <vixey> with f = \\a -> a -> a -> a
14:07:27 <SamB> thoughtpolice: I expect it will be fine
14:07:27 <vixey> (\\ is like \ except at type level)
14:07:42 <vixey> or even,
14:07:48 <vixey> a -> b -> c = h a b c
14:08:06 <vixey> it works for (->) a b, but not a -> b -> c :(
14:08:41 <rwbarton> a -> b -> c is not the application of a type constructor to three arguments
14:09:01 <rwbarton> it's (->) a ((->) b c) so not of the form h a b c
14:09:21 <thoughtpolice> SamB: do you have push priviledges to http://code.haskell.org/lhc ? if not and you're going to contribute some more stuff I can give you push priviledges I believe...
14:09:39 <thoughtpolice> (I think any project member on community.haskell.org can, anyway)
14:09:46 <SamB> thoughtpolice: afaik I don't even have an account at code.haskell.org ...
14:09:51 <vixey> rwbarton, I wonder if it is decideable though
14:10:02 <vixey> actually, no I don't.
14:10:08 <vixey> It's obviously decidable
14:10:16 <rwbarton> vixey: it would be very bad for type inference to allow this kind of thing
14:10:23 <vixey> I think it would be great!
14:10:23 <thoughtpolice> SamB: been sending your patches to lemmih?
14:10:32 <vixey> to unify  f x y z = x -> y -> z
14:10:34 <SamB> thoughtpolice: yeah
14:10:43 <thoughtpolice> SamB: if you get an account bug me and I can add you I believe
14:10:56 <xenoblitz> guys i'm trying to understand the "tying the knot" thingy... are there other, perhaps simpler examples apart from http://www.haskell.org/haskellwiki/Tying_the_Knot ?
14:10:57 <vixey> you just set f = /\x, /\y, /\z, abstract z (abstract y (abstract x (x -> y -> z)))
14:11:19 <vixey> oops
14:11:20 <roconnor> > let x := 1:x in x
14:11:21 <lambdabot>   <no location info>: parse error on input `in'
14:11:26 <roconnor> > let x = 1:x in x
14:11:28 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:11:30 <vixey> f = abstract x (abstract y (abstract z (x -> y -> z)))
14:11:40 <vixey> abstract is some function that put in the /\x -> ...
14:11:53 <vixey> it's really easy right? there is no need for HOU?
14:11:54 <pumpkin> dons has blue hair :o
14:11:55 <baaba> > fix (1:)
14:11:56 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:12:20 <rwbarton> vixey: the problem is there may be many unifications if you allow such general terms
14:12:50 <dons> not these days
14:12:53 <vixey> rwbarton, as long as the rule is  abstract out all occurences of the variable,  it only has one solution?
14:12:56 <roconnor> xenoblitz: is right,  http://www.haskell.org/haskellwiki/Tying_the_Knot seems a little too complicated.
14:13:01 <rwbarton> vixey: how about unify f x x with x -> x
14:13:02 <roconnor> s/://
14:13:14 <rwbarton> vixey: is f = -> or f = abstract x (abstract y (x -> x))
14:13:15 <vixey> rwbarton, ah....... you got me
14:13:44 <vixey> it could be convention to get f = /\x y -> x -> x
14:13:50 <vixey> but I guess that it is just confusing...
14:14:01 <vixey> or it could give an error message in that case!
14:14:15 <thoughtpolice> xenoblitz: you might find this interesting - http://blog.plover.com/prog/springschool95-2.html
14:14:22 <xenoblitz> roconnor: as it says in the web-page "(It would be useful to have some more text describing the examples.)" ... I kind of agree
14:14:29 <xenoblitz> thoughtpolice: will take a look thanks
14:14:33 <rwbarton> but such unifications are very common, e.g., (+1) >>> (*4)
14:14:40 <vixey> roconnor, it might make sense to move that whole page to the Talk page?
14:14:41 <dainanaki> is there a menu widget in hscurses?
14:15:03 <thoughtpolice> xenoblitz: it basically shows how you can define a 'recursive datatype' in the same way you can define a recursive function: using the y combinator (essentially)
14:15:11 <roconnor> vixey: possibly.  I'm a little tempted to simply nuke it and try again.
14:15:15 <augustss> xenoblitz: there are much simpler examples to illustrate the knot tying
14:15:15 <thoughtpolice> xenoblitz: it's a neat trick.
14:15:31 <vixey> roconnor, yes
14:15:32 <xenoblitz> thoughtpolice: yeah i got the gist of the idea but the code is blowing my head :P
14:15:42 <vixey> roconnor, I can give you a knot example if you want to rewrite
14:15:45 <xenoblitz> augustss: any other examples are appreciated
14:15:47 <vixey> though it might be too complicated also
14:16:01 <roconnor> vixey: unfortunately I need to work on my thesis.
14:16:16 <augustss> xenoblitz: I'm afraid I don't have it written down.
14:16:22 <thoughtpolice> augustss: oh! i wanted to mention to you. i was using the llvm bindings and I tried using the transformation functions here - http://hackage.haskell.org/packages/archive/llvm/0.4.2.0/doc/html/LLVM-Core.html#23 and the program segfaulted on me
14:16:25 <xenoblitz> augustss: thanks all the same
14:16:31 <roconnor> the knot example should start with let x = 1:x, and work its way through some less trival examples.
14:16:31 <augustss> roconnor: I thought your thesis was done?
14:17:02 <roconnor> augustss: I was scheduled to finish writing by Dec. 31. ... that didn't entirely work out.
14:17:32 <roconnor> augustss: I need to finish editing my introduction and conclusion.  Then I'll be done writing.
14:17:37 <augustss> thoughtpolice: I'm not even sure how to use those transformation properly.  And it's certainly an incomplete set.
14:18:00 <thoughtpolice> augustss: I managed to write a post-haskell optimizer in C++ that loads the .bc file and optimizes it using those passes - I believe the fault of the segfault is that in the C++ bindings when you declare a passmanager with 'PassManager p;' you *must* do 'p.add(new TargetData(m))' (where 'm' is of type 'Module*')
14:18:21 <thoughtpolice> (because I actually had my C++ program segfault at first with the exact same err, and I tracked it down to that)
14:18:24 <augustss> thoughtpolice: you could just use opt
14:18:46 <thoughtpolice> augustss: ah, didn't even know if its existance :)
14:19:02 <dublpaws> anyone know if a switch exists for ghc to dump a parse tree to stdout?
14:19:08 <augustss> thoughtpolice: look in the latest examples directory
14:19:37 <bos> @seen sioraiocht
14:19:38 <lambdabot> Last time I saw sioraiocht was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-
14:19:38 <lambdabot> books, #haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru,
14:19:38 <lambdabot>  #haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 2m 25d 7h 52m 44s ago, and .
14:19:39 <thoughtpolice> augustss: ty - if I can get a patch to make those transformations work (the llvm-c bindings might not even allow me to do that..) properly I'll send you a patch asap
14:20:33 <yitz> @seen lambdabot
14:20:34 <lambdabot> Yes, I'm here. I'm in #novalang, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
14:20:34 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, ##freebsd, #gentoo-uy, #gentoo-
14:20:34 <lambdabot> haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
14:21:12 <tibbe> bos: have you used the fork queue feature on github?
14:21:16 <dmead> ?losers
14:21:17 <lambdabot> Maximum users seen in #haskell: 668, currently: 658 (98.5%), active: 27 (4.1%)
14:21:19 <dmead> ?yow
14:21:20 <lambdabot> ... ich bin in einem dusenjet ins jahr 53 vor chr ... ich lande im
14:21:20 <lambdabot> antiken Rom ...  einige gladiatoren spielen scrabble ... ich rieche
14:21:20 <lambdabot> PIZZA ...
14:21:24 <dmead> ?yow
14:21:24 <bos> tibbe: no, i'm not much of a git or github user
14:21:25 <lambdabot> I demand IMPUNITY!
14:21:28 <dmead> ?yow
14:21:29 <lambdabot> Well, I'm a classic ANAL RETENTIVE!!  And I'm looking for a way to
14:21:29 <lambdabot> VICARIOUSLY experience some reason to LIVE!!
14:21:36 <tibbe> bos: ah ok
14:21:36 <dmead> ?yow
14:21:37 <lambdabot> How's it going in those MODULAR LOVE UNITS??
14:21:40 <dmead> ?yow
14:21:41 <lambdabot> Let's all show human CONCERN for REVERAND MOON's legal difficulties!!
14:21:44 <dmead> ?yow
14:21:45 <lambdabot> My face is new, my license is expired, and I'm under a doctor's care!!!!
14:21:48 <bos> ugh, too much lambdabot spam.
14:21:49 <dmead> ?yow
14:21:49 <lambdabot> ... I want to perform cranial activities with Tuesday Weld!!
14:21:52 <bos> dmead: please.
14:21:55 <dmead> ?yow
14:21:56 <lambdabot> Should I get locked in the PRINCICAL'S OFFICE today -- or have a VASECTOMY??
14:22:05 <augustss> xenoblitz: Here's an excercise:  write a function that find the minimum value in a tree.  write a second function that replaces all values in a tree wuth a fixed value.  combine these functions so you do both things at once, the new function returns the minimum value and the transformed tree.  finally, do a little knot tying so you in one traversal find the minimum and replace all tree values with that minimum value.
14:22:06 <dmead> i'm looking for something thats actually funny :>
14:22:09 <Peaker> I'm trying to formulate a pickler combinator that is capable of describing excel's CSV.   Excel's CSV has funny escaping rules: quoting with " is optional, and allows commas and newlines inside text.  "" means " inside quotes.  I am wondering whether to describe a csv file as a tokenization of " and csv records on top of that, or have csvFile = sequ csvRow   and then have csvRow deal with the escaping somehow.. Any ideas?
14:22:16 <bos> dmead: you can pm lambdabot too
14:22:44 <dmead> Peaker, there is some example csv code in the online book 'practical haskell'
14:22:58 <Peaker> dmead: Just a parser or just a builder, afaics
14:23:03 <dmead> i've also written a parser from scratch but it's not open source
14:23:09 <dmead> parser
14:23:25 <dmead> what are you having issues with exaclty?
14:23:29 <Peaker> dmead: I want a bidirectional "parser"
14:23:34 <pumpkin> :o
14:23:35 <dmead> ah
14:23:38 <dmead> yea
14:23:44 <pumpkin> Peaker: arrow-based!
14:23:47 <Peaker> dmead: I'm using csv as an example complicated enough to see real issues
14:23:48 <pumpkin> and magic too!
14:23:50 <dmead> my code goes [[string]] <-> csv file
14:23:53 * bos wonders what a Socket's getContents should do in the face of an exception, and decides "nothing".
14:24:05 <Peaker> dmead: yeah, trying to declaratively define the escaping rules escapes me
14:24:11 <dmead> i just preprocess the file before reading
14:24:14 <pumpkin> dmead: the [[String]] bothers me a little in the current CSV offerings
14:24:17 <pumpkin> on hackage
14:24:24 <dmead> eliminate commas inside fields
14:24:38 <Peaker> dmead: lossy?
14:24:38 <dmead> make sure the seperators are acutally "," instead of just ,
14:25:06 <dmead> Peaker, lossy?
14:25:12 <dmead> what do you mean
14:25:15 <rwbarton> With fromRight :: Either a b -> b, is fromRight ~(Right x) = x any different from fromRight (Right x) = x?
14:25:19 <Peaker> dmead: do you get rid of actual commas?
14:25:23 <dmead> yea
14:25:27 <bos> rwbarton: yes
14:25:32 <dmead> but i suggest replace commas before parsing
14:25:45 <pumpkin> dmead: if you parse in "5.4,2.3\n4.6,2" and then output it out again, it'll have extra quotes won't it?
14:25:57 <dmead> so it's easy to do splitby (\x -> x == "\",\:") list
14:26:05 <dmead> no
14:26:11 <dmead> why
14:26:23 <rwbarton> bos: can you explain the difference using _|_?
14:26:38 <bos> rwbarton: yes
14:26:42 <dmead> Peaker,  use putStr instead of print
14:26:52 <Peaker> dmead: I want something like:  csvFile = sequ csvRow ; csvRow = interc "," csvValue ; csvValue = escapeWrapping "," "\"" "\"\""string
14:27:06 <pumpkin> dmead: ah, I see
14:27:18 <Peaker> dmead: then I want to be able to use:  parse csvFile contents ; or build csvFile myDataStructure
14:27:25 <rwbarton> bos: Would you mind doing so? :)
14:27:34 <sjanssen> rwbarton: they're not different
14:27:40 <dmead> Peaker, i load my csv file into a string using the strict IO libraries
14:27:47 <dmead> so it's a list of string, each string is a line
14:27:53 <rwbarton> sjanssen: because there is nothing surrounding the x on the RHS
14:27:53 <dmead> and then mine it with splitby from there
14:27:57 <Peaker> dmead: yeah, you don't handle building csv's
14:27:57 <dmead> with "," as the token
14:27:59 <sjanssen> rwbarton: exactly
14:28:01 <Peaker> dmead: only parsing
14:28:03 <dmead> i do
14:28:10 <xenoblitz> augustuss: was afk but took notice of the exercise :) will attempt it
14:28:17 <dmead> on output i have a function where i pass it lists represnting all the columns
14:28:22 <Peaker> dmead: oh, but then you have separate code for parsing and building?
14:28:25 <dmead> and it fills them in to be equal length and print
14:28:28 <dmead> yea
14:28:33 <Peaker> dmead: yeah, I want it to be the same code
14:28:33 <bos> dons: is ghc-core known to be borked?
14:28:37 <dmead> uh
14:28:41 <dmead> i don't follow you then
14:28:52 <dmead> it's just lists of list of strings
14:28:53 <Peaker> dmead: I want my code to define what csv *is*, and both parsers and builders to derive from that
14:29:04 <Peaker> dmead: no, its a bunch of escaping rules and formatting
14:29:09 <dmead> theng et the csv package from hackage
14:29:16 <dmead> i don't make use of any csv datatypes
14:29:22 <dmead> i didn't find it nessicary
14:29:52 <dmead> i have printcsv [[String]]]
14:29:55 <dmead> err
14:30:11 <dmead> printcsv  :: [[String]] -> IO()
14:30:27 <rwbarton> Peaker: I don't quite understand what the arguments to escapeWrapping do
14:30:37 <augustss> dmead: [[String]] -> String would be more useful
14:30:54 <dmead> i just copy and paste into a report from the emacs buffer =)
14:31:08 <dmead> but i'm going to change it to use standard io
14:31:17 <dmead> cause i have to process 10k csv files at once
14:31:45 <Peaker> rwbarton: its a hypothetical function, I guess that escapeWrapping does escaping by wrapping in front and back with the 2nd given string, if it encounters the first given string, and use the 3rd given string to encode the wrapper occurances themselves
14:31:54 <Peaker> rwbarton: that's ugly, surely there's a cleaner way to express that
14:32:03 <rwbarton> Peaker: ok
14:32:08 <dmead> augustss, i was super lazy about it
14:32:11 <Peaker> rwbarton: Maybe you have one? :-)
14:32:12 <dmead> the haskell way
14:32:13 <dmead> =_
14:32:14 <dmead> =)
14:32:47 <SamB> thoughtpolice: how come lhc-regress passes +RTS -M1G to lhc ?
14:33:12 <Peaker> rwbarton: I am thinking of two general options here, too, one is to have something like a (intercalate "," (escape rules here) (nested codec here)) so that it is aware of the escaping rules in case it sees "," in the nested data.  Another is to have the nested codec be capable of "stealing" the separators, so it can deal with the escaping, instead
14:33:30 <rwbarton> Peaker: it seems like for any fixed set of combinators like {sequ,interc,escapeWrapping} it wouldn't be hard to build an AST that represented them, but that's kind of lame
14:33:46 <vixey> dmead, you can put in scope functions which replace the IO stuff, and then have [[String]] -> String automatically
14:34:01 <Peaker> rwbarton: I hope to build a set of combinators that can't just handle CSV, but are modular/generic enough to handle other interesting file formats
14:34:05 <vixey> you wont need to change the body of your program
14:34:20 <SamB> thoughtpolice: oh, and how do you get it to recognize a test initially ?
14:35:28 <vixey> hi grahamhutton :)
14:35:33 <Peaker> rwbarton: Specifically, escapeWrapping seems to be a pretty crappy combinator :-)
14:35:38 <rwbarton> Peaker: Yes
14:35:39 <grahamhutton> hi vixey!
14:36:02 <Peaker> rwbarton: How do you describe the CSV escaping of wrapping with quotes whenever special chars (comma or newline) appear in a field?
14:36:29 <rwbarton> Peaker: "lame"
14:36:30 <rwbarton> :)
14:36:50 <dmead> vixey, i know, i just haven't gotten around to it
14:37:02 <SamB> thoughtpolice: okay, I think I'll just use the perl script ...
14:37:07 <Peaker> rwbarton: do you think its better for (intercalate ",") to be in charge of escaping commas and give clean items to a nested codec, or for (intercalate ",") to delegate to the nested codec the responsibility to not read commas that belong to it...
14:37:07 <thoughtpolice> SamB: the -M1g is probably because it'll exhaust heap space without it, but I'm not sure (lemmih wrote lhc-regress, so he may have found that flag was needed for some things to compile)
14:37:09 <dmead> i just let the code print to the emacs buffer during lunches and copy/paste when done
14:37:18 <vixey> dmead, aw....... I thought it was a really clever trick
14:37:30 <vixey> Cale taught me it
14:37:36 <bos> is it legitimate to grep for the number of type constructors that appear in GHC core output and use that as a criterion for deciding whether strictness annotations are needed?
14:37:39 <bos> note: not a real question.
14:37:40 <rwbarton> vixey: replacing IO with a Writer monad or something?
14:37:41 <thoughtpolice> SamB: to get it to recognize a test, just put the *.hs file in a directory, and then another file which is '*.hs.expected.stdout' which has the expected stdout results
14:37:46 <dmead> it's the same as using sprintf in C
14:37:54 <dmead> you can change what ouput stream you write to
14:38:12 <thoughtpolice> SamB: little more info here about what you can do - http://code.haskell.org/lhc/lhc-regress/README
14:38:26 <dmead> vixey, got an example anyway?
14:38:45 <SamB> arg, that doesn't work anymore either :-(
14:38:55 <thoughtpolice> SamB: but you don't need any of those extra files, you should be able to drop the .hs file anywhere in regress/tests and running lhc-regress from the lhc top-level dir should take care of it
14:39:26 <vixey> rwbarton, I was thinking of replacing it with data IOAccumulator a where Return :: a -> IOAccumulator a; ...and then writing runIOAcc :: a -> (a,String), Writer seems like a lot simpler now I think about it..
14:39:29 <abuiles> Hi guys,
14:39:47 <SamB> thoughtpolice: so ... how come the IrrefutableLambda test isn't being run ?
14:39:52 <rwbarton> Peaker: I guess I tend to think about this from the parser point of view, because parsing is usually harder
14:40:13 <rwbarton> Peaker: there it would be the nested codec's responsibility to read a single item knowing nothing about the separators
14:40:24 <pao_> @seen dcoutts_
14:40:24 <sjanssen> abuiles: hi!
14:40:24 <lambdabot> dcoutts_ is in #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts_ speak 2h 56m 13s ago.
14:40:34 <pao_> dcoutts_: can I?
14:40:55 <thoughtpolice> SamB: just a sec...
14:40:55 <Peaker> rwbarton: when using regexps, I'd prefer [^,]+, to .*?,  -- so the nested codec must be aware of the considerations like not eating parent's commas. I think that may be reasonable
14:40:56 <rwbarton> Peaker: intercalate would make sure the separators are there
14:40:59 <abuiles> I have been having a problem with the IO monad, and can't figure out what to do
14:40:59 <abuiles> http://hpaste.org/13733
14:41:19 <Peaker> rwbarton: But that means intercalate must know about escaping of items
14:41:35 <Peaker> rwbarton: and the escaping part seems to be easier at the lower level than the higher one
14:41:47 <dolio> abuiles: "$ getClockTime" isn't a valid expression by itself.
14:41:55 <pumpkin> Cale: is it possible to change lambdabot's nick without quitting it, or make it join other networks?
14:42:25 <thoughtpolice> SamB: sorry, running the test suite. I thought you could drop a .hs file in there, lemme see...
14:42:29 <dolio> abuiles: "insert Posts { ... } True" is likely a problem, too.
14:43:05 <abuiles> dolio: I tried without "$" and doesn't work neither
14:43:07 <rwbarton> Peaker: only if intercalate is something like map subParser . split ','.  But if intercalate pulls off one thing at a time using the subparser, it doesn't need to worry about embedded commas
14:43:29 <abuiles> dolio: why do you say insert Posts is likely a problem?
14:43:48 <dolio> abuiles: Because there's no way to parse that right.
14:44:00 <Peaker> rwbarton: that would mean intercalate is a silly goose that only verifies that the stuff after the subparser reads is its separator
14:44:01 <rwbarton> dolio: I agree that looks strange but doesn't actually parse as insert (Posts {...}) True?
14:44:01 <dolio> It needs to be "insert (Posts { ... }) True"
14:44:08 <dcoutts_> hia pao_
14:44:19 <Peaker> rwbarton: (your latter option)
14:44:26 <rwbarton> Peaker: Yes, it would
14:44:38 <thoughtpolice> SamB: hm yes IrrefutableLambda isn't being run because there was no IrrefutableLambda.expected.stdout file
14:44:48 <rwbarton> , src ''Reader
14:44:53 <thoughtpolice> SamB: having added it it gets put into the test suite, running it again...
14:44:56 <lunabot>  newtype Reader r a = Reader {runReader :: (r -> a)}
14:45:07 <rwbarton> , runReader Reader { runReader = const 1 } ()
14:45:10 <lunabot>  1
14:45:11 <dolio> > runState State { runState = (\s -> (s,s)) } 5
14:45:12 <lambdabot>   (5,5)
14:45:17 <rwbarton> See!
14:45:21 <rwbarton> Weird isn't it :)
14:45:22 <dolio> Huh, I wouldn't have guessed that.
14:45:32 <dolio> I stand corrected.
14:45:43 <abuiles> dolio : It used to work before I inserted the new field createdAt, it was just like that
14:45:53 <pao_> dcoutts_: hi an thanks... I'm trying to understand a problem... I though that you could maybe spot it in 5 ms ...
14:45:57 <abuiles> dolio: I am going to try like you say
14:46:03 <pao_> dcoutts_: http://hpaste.org/13734
14:46:05 <dolio> abuiles: What's the error?
14:46:40 <dcoutts_> pao_: upgrade cabal-install to the latest version
14:47:13 <dolio> abuiles: Apparently I'm wrong about the "insert Posts ..." thing, as shown above.
14:47:14 <Saizan_> pao_: if you want it to work with 6.8.3 and you've 6.10.1 in your path you've to pass -w /opt/local/bin/ghc-6.8.3
14:47:16 <dcoutts_> pao_: if you've still got ghc-6.8 or older installed then use that to build it since the older cabal-install will not work with ghc-6.10
14:47:22 <thoughtpolice> SamB: ok I ran the test suite, I guess we just forgot to add the IrrefutableLambda.expected.stdout file
14:47:27 <pao_> dcoutts_: but in that case cabal-install should not be used at all... am I wrong?
14:47:35 <thoughtpolice> SamB: so just add your test in there, put a .expected.stdout file with it and lhc-regress will pick it up
14:47:40 <dcoutts_> pao_: it can still be used with an older ghc
14:47:47 <drdozer> http://pastebin.com/de3a2206
14:47:56 <drdozer> I had this working (I think) earlier
14:48:03 <dcoutts_> pao_: if you uninstalled the older ghc then you'll need to re-install cabal-install manually
14:48:04 <drdozer> now it complains
14:48:24 <thoughtpolice> SamB: if it's known to fail, put it in lhc/regress/tests/bugs
14:48:36 <mux> if I'm seeing a huge leak that seems to happen at a replicateM call, it's probably that the list of actions is being actually built, right?
14:48:39 <abuiles> the error  is Error specification:
14:49:05 <pao_> dcoutts_: I'm trying to bootstrap an "old" cabal-install along with ghc-6.8.3 to test "old" packages
14:49:06 <thoughtpolice> SamB: and I've also just pushed the IrrefutableLambda patch so it'll get run
14:49:30 <pao_> dcoutts_: since I'm running runghc Setup, cabal-install should be out of games, right?
14:49:39 <dcoutts_> pao_: that's fine, a new cabal-install will work with old and new ghc
14:49:43 <drdozer> looks like it can't unify [Decorator (IdList i a)] with a, but I've added type Decorator (IdList i a) = a
14:49:46 <abuiles> dolio:     Couldn't match expected type `Control.Monad.State.Lazy.StateT                                     Environment IO t'            against inferred type `IO ClockTime'
14:50:00 <drdozer> sorry, with [a]
14:50:16 <dcoutts_> pao_: I never runghc Setup, I always use cabal-install
14:50:17 <dolio> Oh.
14:50:32 <dolio> abuiles: What happens if you use "lift getClockTime"?
14:50:38 <pao_> dcoutts_: I see
14:50:55 <abuiles> dolio: I'll try that
14:51:09 <pao_> dcoutts_: I'd like not to depend on any "pre-installed" cabal-install... but if you say it harmless... I'll try it
14:51:14 <dcoutts_> pao_: I use the latest cabal-install and I use it to help me test my packages with 4 versions of ghc, 6.4.2, 6.6.1, 6.8.3 and 6.10.1
14:51:59 <abuiles> dolio: It's looks like it works.
14:52:07 <dcoutts_> pao_: if you want to test with runghc Setup and the version of Cabal that comes with each older ghc then that's fine, you can do that
14:52:10 <kpreid> Cale, bos: fyi ideamonk did the same thing in #lisp, and just left a few minutes later without saying anything (despite response)
14:52:14 <abuiles> dolio: I'll will replace the another one
14:52:31 <dcoutts_> pao_: though it's also possible with cabal-install, use --cabal-lib-version=1.4.0.2 or whatever
14:52:41 <bhurt> Stupid quickcheck question, if someone has the time.
14:52:45 <dolio> abuiles: Yeah, getClockTime runs in IO, and you're in a transformer over IO. So you need to lift.
14:52:50 <dolio> abuiles: So either lift or liftIO.
14:53:18 <bhurt> I have two functions, call them f and g, where g is the inverse of f- that is (f.g) i == i
14:53:19 <dolio> liftIO can lift through multiple transformers.
14:53:29 <ozy`> :t lift throw
14:53:31 <lambdabot> Not in scope: `throw'
14:53:34 <bhurt> Here i is an int
14:53:35 <pao_> dcoutts_: I'm just wondering why my runghc doesn't work... cabal-install shouldn't be strictly needed
14:53:38 <bhurt> Er, integer
14:53:38 <bos> kpreid: heh
14:53:57 <bhurt> I want to write the quickcheck property to test this.
14:54:03 <dcoutts_> pao_: right, it's not needed, runghc Setup should work
14:54:25 <dcoutts_> bhurt: ok, what have you got so far?
14:54:33 <bhurt> I have: let prop_test i = (i >= 0) ==> (i < 100) `trivial` ((f.g) i == i)
14:54:57 <pao_> dcoutts_: did you give a look to the paste? I'm trying to install Cabal with runghc in the user db...
14:55:06 <pao_> dcoutts_: it doesn't work...
14:55:08 <dcoutts_> pao_: I didn't see the paste
14:55:12 <kpreid> bhurt: you might want to test g.f as well
14:55:12 <pao_> http://hpaste.org/13734
14:55:15 <mux> I think QuickCheck 2 has a Positive newtype to only generate positive numbers
14:55:15 <pao_> dcoutts_: http://hpaste.org/13734
14:55:17 <dcoutts_> pao_: you probably want --user
14:55:36 <pao_> dcoutts_: pls, give a look to the paste
14:56:03 <bhurt> The problem is that trivial wants the second argument to be a -> Property, while here it's just Property
14:56:13 <pao_> dcoutts_: I've already got --user
14:56:35 <pao_> I'm trying to bootstrap an "old" environment
14:56:42 <dcoutts_> pao_: what version is ghc ?
14:56:48 <bos> tibbe: sent you a pull request on github
14:56:52 <dcoutts_> pao_: the standard ghc on the path
14:56:59 <bhurt> Testing g.f is a trickier proposition, as the intermediate type is a string with special characteristics.
14:57:08 <abuiles> dolio :It solved the firs problem, I got another I thing is because the same reason, is IO, I wrapped it in lift but it didn't work,  http://hpaste.org/13735
14:57:08 <tibbe> bos: I'll deal with it tomorrow
14:57:08 <dcoutts_> pao_: since that's the version it's using, since you've not told it to use any other version
14:57:12 <pao_> dcoutts_: ghc -> ghc-6.10.1
14:57:23 <dcoutts_> pao_: then that's the problem, as I said before
14:57:25 <bos> woo, saizan joins the haskeller-on-twitter family
14:57:34 <dcoutts_> pao_: the Cabal-1.4.x does not work with ghc-6.10
14:57:43 <dcoutts_> pao_: which is why ghc-6.10 comes with Cabal-1.6 ! :-)
14:57:47 <bhurt> This is using the default ubuntu ghc (6.8.2) with it's builtin quickcheck.
14:58:04 <dolio> @hoogle toCalendarTime
14:58:04 <lambdabot> No results found
14:58:10 <Saizan_> bos: mostly to follow the other members :)
14:58:13 <pao_> dcoutts_: doesn't runghc -f ghc-path "ovverride" the ghc version used?
14:58:14 <dcoutts_> pao_: since you're trying to test the 'native' thing, it's a bit odd to use ghc-6.8 to run the Setup.hs but then use ghc-6.10 to build the package
14:58:27 <dolio> abuiles: toCalendarTime is in IO?
14:58:33 <dcoutts_> pao_: that tells runghc which version of ghc to use to interpret the Setup.hs script
14:58:35 <Saizan_> pao_: you need to tell Cabal to use ghc-6.8.3
14:58:45 <dolio> abuiles: That function won't work because it doesn't have IO in the result type.
14:58:48 <dcoutts_> pao_: which is completely unrelated to what ghc Cabal uses
14:58:53 <Saizan_> pao_: using the --with-ghc option, or -w for short
14:59:04 <dolio> And since you're not using unsafePerformIO...
14:59:37 <dcoutts_> Saizan_: actually it's --with-compiler / -w. But --with-ghc works ok for ghc.
14:59:53 <pao_> Saizan_: dcoutts_ perfectly clear... I thought that -f was enough
15:00:09 <abuiles> dolio: so? what can I do, use unsafePerformIO?
15:00:13 <pao_> dcoutts_: Saizan_: thanks for you patience
15:00:19 <dcoutts_> np
15:00:56 <dolio> No. You give genDate a type of ClockTime -> IO String or something like it.
15:01:06 <eyeris> I want GHC 6.10.1 on Debian/testing. Is the best way to achieve this to install the generic linux binary packages (.tar.bz2)?
15:01:13 <ddarius> "C-u M-x align"  This is why I have no desire to learn emacs.
15:01:43 <pao_> eyeris: I think definitely yes... It allows you to also control the prefix...
15:01:44 <abuiles> dolio:  genDate -> String
15:01:50 <ozy`> ddarius: C-u and M-x are commonly used primitive commands, for what it's worth
15:02:00 <pao_> eyeris: prefix as in ./configure --prefix
15:02:26 <ddarius> ozy`: That doesn't help the case.
15:02:31 <rwbarton> eyeris: I built mine from source so I could apply a patch to use readline rather than editline
15:02:34 <eyeris> pao_ Okay. I have been trying to do just that. I get an error on make install.
15:02:41 <eyeris> http://hpaste.org/13722#a1
15:02:43 <dolio> It's not as bad as undo being C-x u, where C-x C-u does something that totally screws you up if you need to undo several things.
15:02:45 <eyeris> That is a paste of the error
15:02:51 <dcoutts_> rwbarton: ooh? could you share said patch? I hate editline
15:03:01 <drdozer> I am still stuck with this error: http://pastebin.com/de3a2206
15:03:02 <rwbarton> dcoutts_: hang on, it's mauke's patch actually
15:03:05 <ozy`> ddarius: vim's :'<,'>Align is just as cryptic if you don't know what you're looking at
15:03:09 <eyeris> If I `cd libraries` and run the install cmd that it prints out just before the error, it runs without error
15:03:18 <dcoutts_> rwbarton: posting it to the ghc users list would be a great public service
15:03:20 <ozy`> dolio: yeah the undo model is horrible
15:03:23 <ddarius> ozy`: I don't care about cryptic, I care about what I actually have to type.
15:03:34 <vixey> and is there source code for from System F to TAL?
15:04:18 <bos> editline has not put us in our collective happy place as a community :-(
15:04:27 <vixey> I like editline
15:04:43 <bos> it randomly fails to build for me, and i end up with a ghci that doesn't do command line editing
15:04:46 <pao_> eyeris: I'm sorry ... the log doesn't report any useful error... I think you should ask someone more knowledgeable that me :-(
15:04:48 <bos> also, it doesn't handle UTF-8
15:04:49 <rwbarton> dcoutts_: http://mauke.ath.cx/stuff/haskell/ghc-6.10.1-readline.diff
15:04:54 <vixey> (when it works)
15:04:58 <rwbarton> dcoutts_: also you need to unpack the readline package from hackage into libraries/
15:05:01 <Cale> vixey: Don't you hate the behaviour of delete at the end of a line?
15:05:05 <dolio> abuiles: You could use unsafePerformIO to get genDate to have a pure type. But in general that's not advisable.
15:05:07 <yip> is the ghc api powerful enough already to fully implement all of ghci features?
15:05:07 <dcoutts_> rwbarton: yay, post it to one of the mailing lists for posterity
15:05:18 <rwbarton> dcoutts_: ... it's not my patch ... but OK, I guess
15:05:23 <dcoutts_> yip: by definition yes! :-)
15:05:28 <vixey> Cale, oh yeah I noticed that actually it sucks
15:05:42 <eyeris> pao_ Yeah, I've tried to stick a VERBOSE=1 in the Makefile but that didn't work :)
15:05:42 <eyeris> bbiab
15:05:44 <dcoutts_> yip: ghci, ghc -e, ghc --make and ghc -c  are all clients of the ghc api
15:05:50 <bos> we need a ghci with insane eye candy
15:05:54 <pao_> dcoutts_: Saizan_
15:05:54 <pao_> I can confirm that -w fixed
15:05:54 <vixey> is it possible to implemented editline type thing in haskell?
15:06:00 <bos> ghci with hscolour support
15:06:00 <vixey> (but better)
15:06:00 <dolio> Cale: Does it backspace?
15:06:09 <dcoutts_> bos: or just gtk...
15:06:14 <Saizan_> vixey: see haskeline
15:06:15 <ddarius> vixey: There is a worse one.
15:06:23 <mux> if I have a suspicion that a replicateM call is causing a space leak because it's building the actions list, how can I check that?
15:06:40 <yip> dcoutts_: so why are we not seeing dozens of ghci-like programs pop up? colorized ones, gtk ones, etc
15:06:48 <Cale> dolio: Worse... it backspaces and then pushes the cursor back one space
15:06:51 <vixey> it's too hard to implement something like read/editline without getting an urge to fix the mess of terminals
15:06:59 <pao_> eyeris: try increasing make debug level
15:07:04 <bhurt> All:  Never mind.  Figured out my quickcheck question.  Turns out it was a PEBKAC problem elsewhere in my code.
15:07:05 <bos> @users
15:07:06 <lambdabot> Maximum users seen in #haskell: 668, currently: 646 (96.7%), active: 27 (4.2%)
15:07:09 <pao_> eyeris: just to spot where the problem is
15:07:16 <pao_> eyeris: --debug=v should do
15:07:19 <eyeris> pao_ How do you do that? ahh!
15:07:22 <dolio> Cale: Man...
15:07:23 <BONUS> wow, it was like 500 something a few weeks ago
15:07:27 <Cale> dolio: So if you have abcd_ where _ represents the cursor, and then press delete followed by e, you end up with abec
15:07:28 <eyeris> I thought make used $VERBOSE
15:07:31 <BONUS> why the sudden influx of users
15:07:33 <eyeris> I will try that. Thanks
15:07:41 <dolio> Yeah, I just tried it out.
15:07:41 <dcoutts_> yip: the api is not lovely yet, though it's improved a lot recently
15:07:53 <dcoutts_> yip: but I think there's nothing stopping people now
15:08:35 <Cale> It also results in the unfortunate property that no matter where the cursor is positioned, holding delete will always eventually delete the whole line.
15:09:07 * rwbarton wonders if he is the only one who never uses the delete key
15:09:09 <dcoutts_> my happy editline story is that it silently fails when you put comments in the ~/.inputrc file
15:09:20 <drdozer> gha, it's like ghc is ignoring my type index
15:09:40 <dcoutts_> which is why I could never figure out why delete did not work despite putting the commands in there
15:10:22 <ddarius> dcoutts_: Comments are for the weak.  You know what's also for the weak; feedback.
15:10:30 <Cale> Heh, I wonder if there's a patent on sane delete-key behaviour ;)
15:10:35 <vixey> can you do bidirectional type checking for System F?
15:10:53 <vixey> it's just the same as STLC right?
15:13:34 <Saizan_> bidirectional type-checking is the one where you've input and output rules?
15:13:40 <vixey> yes
15:14:18 <ddarius> @google tridirectional type checking
15:14:21 <Peaker> Patent #516233 "A facility and implementation of erasing user input, while automatically pulling back input to avoid redundant spacing..."
15:14:21 <lambdabot> http://www.cs.cmu.edu/~fp/papers/popl04.pdf
15:14:22 <lambdabot> Title: Tridirectional Typechecking
15:15:24 <dons> bos: no, ghc-core is fully functioning.
15:15:40 * dons wonders why bos thinks all of dons projects are borked
15:15:41 <bos> dons: yeah, i wasn't able to repro the weirdness i saw.
15:16:03 <bos> find one strictness bug, and i suspect cockroaches under all the rocks!
15:16:07 <dons> :P
15:16:10 <bos> :-)
15:16:30 <dons> thanks for the xenloop hints. looks like i can steal some ideas
15:16:56 <pumpkin> is 11k requests/sec good then? I don't have any concept of how much is considered fast for webservers
15:17:04 <dons> 14.4k conn/s
15:17:07 <dons> bos' machine is slow
15:17:12 <dons> or borked :)
15:17:19 <bos> pumpkin: for a single-threaded program that's 35 lines long, it's really good
15:17:25 <dons> yeah
15:17:25 <abuiles> dolio : Still with the same problem :, can't figure out how to sort out that
15:17:27 <pumpkin> yay
15:17:50 <mux> if I have a suspicion that a replicateM call is causing a space leak because it's building the actions list, how can I check that?
15:18:02 <dons> mux, switch to replicateM_ ?
15:18:10 <Cale> mux: It builds the list of *results*
15:18:21 <mux> I need the results
15:18:24 <Cale> okay
15:18:48 <ddarius> "I have a suspicion that my function that returns a list allocates space for that list."
15:18:58 <mux> but I have a space leak at that particular point in the get instance for Arrays in Data.Binary
15:19:15 <mux> so I was thinking, maybe this is because the list of thunks is getting built, and thunks are big or something
15:19:52 <mux> the list of results is not big and can fit in memory just fine
15:19:56 <rwbarton> mux: do you still have that weird behavior where main does something different than its definition?
15:20:03 <mux> yes
15:21:37 <dolio> abuiles: If you change the type of the function, you'll have to change the way it's used, too.
15:21:41 <ddarius> adamjones: A completely different way of handling the problem you mentioned yesterday is to model your "units" as communicating concurrent processes.
15:21:50 <vixey> hi mmorrow
15:21:55 <mmorrow> hey vixey
15:21:55 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
15:21:56 <vixey> I left you a link in the bot
15:22:00 <mmorrow> oh sweet
15:22:20 <vixey> (about GC)
15:22:22 <dolio> "d <- genDate v ; ... d ..." instead of "... (genDate v) ..."
15:22:46 <mmorrow> cool
15:22:50 <abuiles> thanks
15:23:01 <adamjones> ddarius: right now I'm going with existential types, and may look into FRP. I'm trying to keep the confusion level as low as possible. Thanks though.
15:23:14 <mmorrow> that looks super applicable
15:23:26 <vixey> oh what are you working on?
15:23:28 <mux> heh, 20 minutes for realizing the code I'm looking for actually isn't in the core output I was reading
15:23:32 <vixey> I sort of though you just wrote a gc for fun :p
15:24:51 <mmorrow> vixey: i'm trying to get one working, because i've been doing an implem of that lvm (lazy virtual machine) (in haskell), i've got the translating and compiling to byecode maybe 80% done, but i need a gc :)
15:25:09 <vixey> oh cool
15:25:45 <vixey> I'd not heard of LVM only krivine and stuff
15:26:04 <mmorrow> it turns out that that virtual machine et al is exactly what helium is using
15:26:26 <mmorrow> (but the lvm spec was written in 2005, and all the helium code looks like it's form 2001)
15:26:29 <mmorrow> from
15:27:31 <mmorrow> http://serv1.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.81.7841
15:27:48 <vixey> mmorrow, oh you are hacking on GHC/
15:27:49 <vixey> ?
15:28:00 <matthewp> hmmm, having an issue with cabal update with the following error - user error (Codec.Compression.Zlib: incorrect header check)
15:28:06 <matthewp> anyone else getting that?
15:28:29 <matthewp> worked just a couple of days ago
15:28:30 <dcoutts> matthewp: sounds like the download is failing
15:28:53 <matthewp> dcoutts: hmm, I'll have to check it again on a different network
15:28:59 <SamB> did it say what URL it was looking at ?
15:29:14 <matthewp> 'http://hackage.haskell.org/packages/archive'
15:29:22 <SamB> what happens when you fetch that ?
15:29:24 <matthewp> doing a cabal update
15:29:41 <SamB> I mean, what do you see if you load it in your browser, etc ?
15:29:44 <matthewp> ah, it might be a proxy issue
15:29:51 <dcoutts> matthewp: and when you look at the file it downloaded, does it look ok? or too small for example?
15:30:18 <mak__> have anyone problem with linking gd?
15:30:23 <ztirF> @pl f x = delete (minimum x) x
15:30:24 <lambdabot> f = delete =<< minimum
15:30:54 <abuiles> dolio: You said that toCalendarTime is not IO, but  toCalendarTime :: ClockTime -> IO CalendarTime
15:31:12 <abuiles> is not the same?
15:31:15 <dolio> I was asking what it was. I didn't know off hand.
15:31:15 <matthewp> doesn't download anything
15:31:28 <dolio> I assumed by the way you were using it that it was.
15:32:01 <ztirF> @pl f x = g (h x) x
15:32:01 <lambdabot> f = g =<< h
15:32:28 <dolio> Anyhow, you don't get out of IO, so you don't get to use that function in a function with a pure type like "ClockTime -> String".
15:32:38 <Botje> ztirF: that's the >>= instance of ((->) r)
15:32:52 <Botje> @src (>>=) ((->) e)
15:32:52 <lambdabot> Source not found. :(
15:32:56 <Botje> @src (>>=) ((->) r)
15:32:56 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:32:58 <Botje> bleh
15:32:59 <mmorrow> vixey: kinda-maybe. i've been getting to know the interactive-eval/compile parts pretty well, but i haven't really much hacked on ghc itself.
15:33:00 <abuiles> dolio: ok ,thanks  . I'll check on that.
15:33:02 <Botje> i can never get @src right :)
15:33:15 <vixey> mmorrow, so did you write a haskell parser and typechecker and ...?
15:33:47 <mux> GHC arrays use ST behind the scene?
15:33:48 <ztirF> Botje: so I'm to think of (->r) as a monad?
15:33:52 <mmorrow> heh, not. it's just a backend VM that can support any lazy lang (and strict ones too apparently)
15:34:02 <mmorrow> s/not/no/
15:34:17 <SamB> mux: yeah
15:34:29 <mmorrow> but, i'm going to get external core from ghc, then translate that over a few steps to lvm bytecode
15:34:34 <BONUS> @pl \f g a r -> g (f a r) r
15:34:34 <lambdabot> flip flip id . ((flip . (ap .)) .) . flip ((.) . (.))
15:34:43 <drdozer> ok, I've figured out what's going on with these type indexes
15:34:44 <mmorrow> so i can get all the typechecking/optim/etc for free
15:34:52 <BONUS> does lambdabot know about >=>
15:34:56 <drdozer> I think it's a bug (or at least, an undocumented and unhelpful feature)
15:34:58 <vixey> cool
15:34:59 <quylui> i'm trying to make a number that verifies prime numbers... i can't seem to get it to work. what am i doing wrong? http://hpaste.org/13736
15:35:00 <mmorrow> also, the lvm can support dependently typed langs as well
15:35:03 <vixey> is core parseable?
15:35:07 <vixey> or do you get it directly
15:35:16 <Botje> ztirF: yes. it's defined as f >>= g = \r -> g (f r) r
15:35:17 <Botje> i think
15:35:22 <rwbarton> Can I think of data families as a kind of open version of GADTs?
15:35:26 <SamB> drdozer: that's usually what is meant by bug, yes
15:35:31 <vixey> mmorrow, oh cool, is there any modifications it needed for that?
15:35:43 <mmorrow> external-core. i grabbed ghc's code that deals with it, and changed it to not prettyprint it and just give me the AST
15:35:43 <thoughtpolice> mmorrow: what're you working on?
15:35:46 <drdozer> SamB :) except occasionally something behaving bat-shit crazy is what was intended
15:36:08 <mmorrow> thoughtpolice: i'm shooting for an (eventual) implem of http://serv1.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.81.7841
15:36:21 <drdozer> so, if you have the exact-same indexed type defined within two classes, the type-checker can't unify it
15:36:23 <Olathe> Is there a function equivalent to \x f -> x >>= (return.f) ?
15:36:32 <alboin> Hello, if I have a variable, returned from a function using IO, (thus the variable is IO a), how can I add that a to an [a]? I'm very much a new  user of the language...
15:36:39 <BONUS> liftM
15:36:41 <rwbarton> Olathe: flip fmap
15:36:43 <drdozer> it can work out when you've tried to bind it to two different things (and complains)
15:36:46 <thoughtpolice> mmorrow: ooh interesting. on the note of gc I actually have jones' book right here :)
15:36:54 <drdozer> but if you bind it to the same thing it accepts it but fails to unify
15:36:55 <SamB> drdozer: that sounds like a problem in the renamer
15:37:07 <BONUS> > liftM (+3) (Just 997)
15:37:09 <lambdabot>   Just 1000
15:37:12 <mmorrow> thoughtpolice: i'm currently trying to figure out how to write one. here's a first go http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=728
15:37:12 <Olathe> > flip fmap ["Test"] ord
15:37:13 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
15:37:18 <SamB> or something ...
15:37:19 <mmorrow> (IntMap heaps for now..)
15:37:23 <Botje> alboin: can you show an example on hpaste.org?
15:37:27 <Olathe> Actually.
15:37:34 <Olathe> @pl \x f -> x >>= (return.f)
15:37:34 <lambdabot> (. (return .)) . (>>=)
15:37:38 <BONUS> > flip fmap "Test" ord
15:37:38 <yip> "Garbage Collector" is top 10 worst occupation in U.S. :)
15:37:39 <yip> http://online.wsj.com/article/SB123119236117055127.html
15:37:39 <lambdabot>   [84,101,115,116]
15:37:53 <vixey> yip, all 10?
15:37:54 <vixey>  :p
15:37:56 <Olathe> alboin: You can only add it to an [IO a]
15:37:59 <drdozer> SamB: I will trust you on that
15:38:14 <mathijs> Hi all, I'm reading bonus's 'learn you a haskell' tutorial, and he has a note about optimizations in the code. Basically he uses a left fold, but on every step a recursive calculation is made on the previous steps. He notes that it would be wise to pass the result along with each step to get rid of the re-calculation... (more)
15:38:16 <Olathe> alboin: Or, perhaps an IO [a]
15:38:19 <drdozer> SamB: so perhaps I could declare the indexed type top-level?
15:39:37 <mathijs> now, since pure functions should always return the same result when given the same input, I would expect ghc to perform some smart caching itself, so I don't need to revert to tricks like that. Is this done by default? or with -O2 ?
15:39:54 <Botje> mathijs: no, caching is not done by default
15:40:04 <thoughtpolice> SamB: did you get your test working?
15:40:06 <Botje> because the compiler can't predict if the answer will be used in the future
15:40:12 <SamB> thoughtpolice: yeah
15:40:15 <SamB> it works
15:40:17 * ddarius had a GC for the LVM before he had compilation done or even started on translation.
15:40:28 <Olathe> @redo x >>= (\x -> return (x:xs))
15:40:29 <lambdabot> do { a <- x; (\ x -> return (x : xs)) a}
15:40:42 <thoughtpolice> SamB: yay. :) if you email your darcs patches to me I can apply them for you
15:41:14 <mmorrow> ddarius: heh
15:41:23 <Cale> mathijs: If every result of every function was stored, it would be as if there was no garbage collection, and even very simple programs would go through gigabytes of memory within seconds.
15:41:29 <Olathe> > let xs = [1, 2, 3]; x = return 5 :: IO Int in do { a <- x; return x:xs }
15:41:30 <lambdabot>   Couldn't match expected type `IO' against inferred type `[]'
15:41:38 <mathijs> Botje: I get that, but on the other hand, keeping a small cache around just to see if something gets used again (when using folds or other list-iteration functions) wouldn't hurt I would think.
15:41:38 <drdozer> SamB: I've worked around it by using type family and type instance rather than the (neater) associated type
15:41:56 <vixey> mathjis, you can 'turn on' that caching explicitly if you like, though
15:42:08 <Olathe> > let xs = [1, 2, 3]; x = return 5 :: IO Int in do { a <- x; return a:xs }
15:42:09 <lambdabot>   Couldn't match expected type `IO' against inferred type `[]'
15:42:10 <Botje> mathijs: the haskell wiki is a good starting point if you want to add memoization
15:42:42 <yip> vixey: no, just one spot :) Philosopher is 12th best occupation, and mathematician is number 1
15:42:45 <Olathe> > let xs = [1, 2, 3]; x = return 5 :: IO Int in x >>= (return.(:xs))
15:42:46 <lambdabot>   * Exception: "<IO [Int]>"
15:42:52 <Olathe> @type let xs = [1, 2, 3]; x = return 5 :: IO Int in x >>= (return.(:xs))
15:42:53 <lambdabot> IO [Int]
15:43:00 <Olathe> @redo let xs = [1, 2, 3]; x = return 5 :: IO Int in x >>= (return.(:xs))
15:43:00 <lambdabot> do { let { xs = [1, 2, 3]; x = return 5 :: IO Int}; a <- x; (return . (: xs)) a}
15:43:05 <SamB> thoughtpolice: that reminds me that I was going to try and get an account on community.haskell.org
15:43:33 <mathijs> Botje: thanks, I guess I will be able to set some flags that influence the caching behaviour? like setting the max number/mem per function/module and stuff?
15:43:39 <Olathe> > do { let { xs = [1, 2, 3]; x = return 5 :: IO Int}; a <- x; return (a:xs)}
15:43:40 <lambdabot>   * Exception: "<IO [Int]>"
15:43:51 <Botje> alboin: did you figure it out yet? if not, you can paste your code + error to hpaste.org
15:44:03 <Botje> mathijs: actually, at the moment memoization is more of a DIY thing, sorry :)
15:44:34 <mathijs> Botje: so probably I'm better of by just putting optimizations in my code?
15:44:46 <alboin> http://hpaste.org/13737?lines=true
15:45:49 <vixey> how do you memoize  f :: (a -> b) -> c
15:45:50 <SamB> thoughtpolice: huh, maybe I do have an account
15:46:30 <Peaker> vixey: if you are ghc, you might be able to
15:46:30 <SamB> thoughtpolice: actually I do
15:46:40 <SamB> either they forgot to tell me about it or I missed the email
15:46:49 <vixey> yah I guess so just checking pointer equality
15:47:05 <SamB> thoughtpolice: anyway, I'm SamB@nun
15:47:48 <mathijs> I like haskell's high-level abstractions of looking at things, but keeping to reason about speed (lists ++ vs :, passing values along just for optimization) feels low/asm-like. It's kind of weird. But I'll get used to it.
15:47:59 <SamB> thoughtpolice: or maybe I forgot!
15:48:39 <pumpkin> mathijs: it would be nice to be able to have a concise "annotation" of a value to tell it to remember it if possible
15:48:42 <vixey> mathijs, why not just ignore optimization?
15:48:44 <Botje> alboin: you're talking about the data case of run, right?
15:49:01 <thoughtpolice> SamB: k
15:49:04 <thoughtpolice> SamB: just a sec
15:49:15 <vixey> mathijs, that particular transform you mentioned can be automated
15:49:44 <mathijs> vixey: because I learn best by understanding the small/gory details and boundaries of techniques. Of course I don't have any real projects atm that need to be optimized :)
15:49:45 <alboin> yeah, its recursive, but it needs just [exectoken] without the IO
15:50:20 <vixey> I really dislike operational optimizations that are writting in code
15:50:38 <mathijs> pumpkin: well, telling it somehow feels dirty too. I mean, as I can see that there's some recursion going on on values that get passed along, so can the compiler I would say.
15:50:39 <vixey> algorithmic is fine, but stuff like using Int instead of Integer is really annoying
15:50:41 <thoughtpolice> SamB: k, done.
15:50:49 <rwbarton> vixey: how about memoization through proper sharing?
15:50:57 <pumpkin> mathijs: but it can't really predict (all the time, at least) how big a value it's thinking of memoizing will be at runtime
15:50:58 <SamB> thoughtpolice: so how do I push ?
15:51:04 <vixey> rwbarton, I consider that algorithmic
15:51:14 <Botje> alboin: if i understand your code correctly, you need to call run again, but with different parameters
15:51:17 <SamB> that is, to what address ?
15:51:19 <thoughtpolice> SamB: try to push your patches to 'SamB@community.haskell.org:/srv/code/lhc'
15:51:25 <Botje> run xs (push_stack s (a,b))
15:51:29 <Botje> in the data case
15:52:54 <drdozer> pants - using a type family .
15:53:02 <Botje> although (a,b) is probably not the correct type for ExecToken
15:53:19 <drdozer> pants - using a type family / type instance doesn't work quite the same
15:53:20 <Botje> so push_stack s (ExecNode (a,b)) instead of the above, i think?
15:53:22 * rwbarton is having problems with type families too
15:53:26 <rwbarton> http://hpaste.org/13738
15:54:01 <mathijs> pumpkin: In this perticular case, I can see (by analyzing the code) that keeping just the last result of some function around would be enough. Of course there will be many other cases where stuff's not so clear, So I'll just have to learn to optimize anyway, but some automatic smartness in ghc for simple cases would be nice.
15:54:13 <vixey> rwbarton, any reason for using type families instead of GADTs?
15:54:26 <rwbarton> vixey: because I want to have other instances of Structured as well
15:54:40 <thoughtpolice> SamB: success?
15:54:48 <vixey> rwbarton, like what?
15:54:56 <vixey> (just any simple one ?)
15:54:57 <Saizan_> i didn't know gadts were supported as data instances
15:54:57 <SamB> thoughtpolice: I pushed the kind inference fix
15:55:01 <pumpkin> mathijs: yeah, in many cases it should be obvious... such as maybe map (/ (sum xs)) xs -- don't compute sum each time, kthx
15:55:19 <rwbarton> vixey: say, data instance Part [a] c where Nth :: Int -> Part [a] a; class Structured [a] where select xs (Nth i) = xs !! i
15:55:25 <thoughtpolice> SamB: yay! push as you wish from now on. :)
15:55:36 <SamB> my other patches I'm not as sure of yet
15:55:57 <Botje> alboin: I annotated your paste on hpaste http://hpaste.org/13737#a1
15:56:01 <SamB> so I'm at least recompiling base to make sure it works
15:56:02 <rwbarton> Saizan_: Maybe that's the problem
15:56:11 <Botje> not knowing the exercise, i think that's what you're looking for
15:57:18 <SamB> thoughtpolice: what are your favorite -d options for LHC ?
15:57:45 <mathijs> pumpkin: yeah, stuff like that should really be detectable. The thing is... by optimizing it by hand, it makes the code less clear. That's exactly what I like about haskell in the first place, it just describes what stuff _is_ instead of how it behaves and which steps to take to get to a result.
15:58:03 <pumpkin> yeah, I agree :)
15:58:11 <pumpkin> maybe it does optimize that one
15:58:12 <pumpkin> I haven't tested
15:58:23 <pumpkin> it does seem pretty obvious
15:58:33 <thoughtpolice> SamB: most of the core* and grin* flags since they're useful for seeing post/pre optimizations etc.
15:59:09 <SamB> yeah, I use those when I'm debugging the mid- and back- ends
15:59:47 <SamB> do you use -dstats ?
15:59:51 <rwbarton> pumpkin: that code won't compute sum each time
16:00:13 <mathijs> pumpkin: maybe it would be possible to write some 'keepResults 1 (map (/ (sum xs)) xs) xs' function.
16:00:17 <thoughtpolice> SamB: never used it - what stats does it show?
16:00:24 <pumpkin> rwbarton: ah okay :)
16:00:32 <rwbarton> mathijs: where in LYAH are you looking?
16:00:34 <pumpkin> rwbarton: so under what conditions does it decide not to?
16:00:40 <SamB> seems to show a lot of info about what optimizations were applied
16:00:53 <thoughtpolice> SamB: ah, good. maybe that can help with this PureInteger stuff...
16:01:02 <mathijs> http://learnyouahaskell.com/functionally-solving-problems#heathrow-to-london scroll a bit down to the yellow box saying 'Optimization tip'
16:01:24 <thoughtpolice> SamB: Integer is treated very specially by lhc/jhc, so I'm trying to replace that with a pure haskell98 implementation of integer (written in terms of Int.)
16:01:56 <alboin> Yeah! Thanks. So the <- operator 'executes' the IO and returns the result, then?
16:02:03 <SamB> hmm, what's the status of array support ?
16:02:06 <thoughtpolice> SamB: unfortunately, lhc produces bad code for the PureInteger test.
16:02:12 <Botje> alboin: the thing is, you can't escape the IO monad
16:02:13 <thoughtpolice> and it segfaults :(
16:02:23 <thoughtpolice> SamB: not quite sure atm
16:02:35 <ztirF> (delete =<< minimum) [1,2,3]
16:02:35 <drdozer> these indexed types aren't quite working as advertised
16:02:45 <thoughtpolice> drdozer: how so?
16:02:45 <tromp_> zer iz no ezkape!
16:02:49 <ztirF> >(delete =<< minimum) [1,2,3]
16:02:51 <Botje> inside the do block you can execute com_print and capture the return value
16:02:55 <Lemmih> SamB: The arrays should work.
16:02:55 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
16:03:05 <ztirF> > (delete =<< minimum) [1,2,3]
16:03:06 <alboin> Yeah, I have *a lot* to learn yet. (especially on monads) Anyway, thanks for the help, this is an exceptionally helpful channel....
16:03:06 <rwbarton> mathijs: it seems extremely ambitious to try to make that particular optimization automatically
16:03:07 <lambdabot>   [2,3]
16:03:09 <Botje> which will have type [ExecToken]
16:03:11 <redditbot> Creating Haskell binaries with dynamically linked libgmp on Windows
16:03:18 <thoughtpolice> Lemmih: I got SamB push priviledges to the repo too; he pushed a fix for kind inference and a test
16:03:19 <Botje> but you then have to do something with it that is again in the IO monad
16:03:28 <Botje> like, for example, run or com_print :)
16:03:33 <Lemmih> thoughtpolice: Excellent.
16:03:33 <drdozer> thoughtpolice: well, they don't seem to always unify
16:03:35 <SamB> Lemmih: oh, it turns out that I have a community.haskell.org account
16:03:52 <thoughtpolice> Lemmih: also I added an IrrefutableLambda.expected.stdout file since one wasn't there for some reason - also why did you disable the BinaryTrees test?
16:04:14 <ztirF> anyone know where Monad ((->) r) is defined?
16:04:25 <Botje> Control.Monad.Instances, i think
16:04:27 <dons> yep
16:04:29 <SamB> Lemmih: I believe you will find that Control.Arrow doesn't work yet though
16:04:31 <mathijs> rwbarton: well, I don't expect that to be the case... Just thought it would be nice. Since I can see how much caching would be needed, I would think the compiler might be able to do the same.
16:04:41 <Botje> instance Monad ((->) r) -- Defined in Control.Monad.Instances
16:04:42 <Lemmih> thoughtpolice: LHC compiled it wrongly after I abstracted out the Id type.
16:04:50 <rwbarton> mathijs: You know, for example, that sum is associative
16:05:00 <ztirF> Botje++
16:05:07 <SamB> Lemmih: I think you messed that up a bit ...
16:05:19 * leimy just learned the glory of mplus and fmap with Maybe
16:06:11 <SamB> Lemmih: I'm seeing a lot off "Id 11424" or whatnot in the middle of what seem like they ought to be identifiers ...
16:07:18 <Lemmih> SamB: Right, I changed the pretty-printing of Ids.
16:07:35 <mathijs> rwbarton: but to get back to pumpkin's question... under what conditions does ghc decide not to recalculate sum xs every time in 'map (/ (sum xs)) xs'?
16:07:48 <SamB> Lemmih: I'm not sure that was very wise ...
16:08:11 <Lemmih> SamB: It shouldn't affect correctness.
16:08:36 <SamB> Lemmih: it really makes it harder for my eyes to parse E ...
16:09:07 <SamB> I see a space smack in the middle of a method name ...
16:09:14 <Lemmih> SamB: Feel free to fix it. Just change the derived Show instance to a hand written one.
16:09:33 <mak__> i have some problems with gd library is there other stuff to play with png?
16:10:01 <SamB> (or, at least, an autogenerated identifier of some sort ... I don't actually remember what letters mean what ...)
16:10:02 <rwbarton> mathijs: let's desugar that code a little bit, to  map (flip (/) (sum xs)) xs
16:10:27 <rwbarton> mathijs: now we can see that (sum xs) is passed as an argument to the function flip (/)
16:10:57 <Lemmih> thoughtpolice: The code generator is quite buggy. I want to disable features until we can verify its correctness.
16:11:32 <SamB> Lemmih: what do you mean by "code generator" or "features"
16:11:58 <rwbarton> mathijs: so that inner expression becomes let s = sum xs in {- definition of flip (/) -}
16:12:25 <Lemmih> SamB: The C we generate from Grin is invalid in some cases.
16:12:32 <SamB> Lemmih: ah.
16:12:49 <Lemmih> SamB: The Grin->C compile does a lot of fancy things that it really shouldn't.
16:12:56 <SamB> I guess so.
16:13:11 <SamB> Be careful of the FFI export support ...
16:13:20 <mathijs> rwbarton: ok, so far I get that. but it's map that I would think would make the flip ... part execute on every step
16:13:26 <SamB> I don't know if it ought to be there, but that's where it is
16:13:27 <ddarius> mathijs: Most of Haskell performance properties can be figured out simply by applying the intuitive/informal semantics of Haskell as rwbarton is doing here.  Only some cases require thinking any "lower-level" than that and those are usually explicitly compiler specific, e.g. unboxing.
16:13:50 <rwbarton> mathijs: same thing, we have let f = (let s = sum xs in {- definition of flip (/) -}) in {- definition of map -}
16:13:57 <SamB> (at least in large part)
16:13:59 <rwbarton> mathijs: note, there are no lambdas before the lets
16:14:23 <Lemmih> SamB: I won't think twice about disabling it. Generating correct programs should be the first priority.
16:14:39 <SamB> Lemmih: what do you mean "disabling"
16:14:43 <SamB> how do you do that ?
16:15:04 <rwbarton> > let myMap [] f = []; myMap (x:xs) f = f x : myMap xs f in let ys = [1..10000] in sum $ myMap ys (/ (sum ys))
16:15:05 <lambdabot>   1.0000000000000002
16:15:31 <Lemmih> SamB: Hopefully deleting the code will do the trick.
16:15:38 <rwbarton> mathijs: This is probably a terrible explanation.  Eventually you get the hang of figuring out what will be evaluated when. :)
16:15:45 <SamB> Lemmih: deleting ?
16:15:50 <SamB> that sounds a bit drastic ...
16:16:03 <scsibug> mak__: I think GD would be the easiest to get working, but gtkhs may be able to work with PNGs
16:16:07 <mathijs> rwbarton: I see... it takes some time to read though :)
16:16:16 <ddarius> rwbarton: Until you can "just see" what gets evaluated, you can always just apply the rules mechanically.
16:16:29 <newsham> hi
16:16:33 <rwbarton> mathijs: I guess one good thing to note is:    let f x = let y = {- expression -} in {- expression -}  -- y will be recomputed on every f call, even if it doesn't involve x (probably)
16:16:38 <mapreduce> :t PrintF
16:16:39 <lambdabot> Not in scope: data constructor `PrintF'
16:16:52 <rwbarton> mathijs: let f = let y = {- expression -} in \x -> {- expression -}  -- y will be computed only once
16:17:12 <Lemmih> SamB: It could be un-deleted if/when we get around to verifying its correctness.
16:17:57 <Lemmih> SamB: I'd rather print an error message than knowingly generate an incorrect program.
16:18:00 <SamB> hmm, there oughta be a test for that ...
16:18:34 <rwbarton> mathijs: Also, ghc won't take two textually distinct subexpressions in your code and share them (usually).
16:18:42 <rwbarton> mathijs: Those are the general rules I apply
16:18:55 <rwbarton> mathijs: Of course, you can work it out by hand as ddarius suggests, or ask Cale to do it :)
16:20:26 <ddarius> To qualify my statement some, compilers are always allowed to exchange semantically equivalent code, so whether this model is actually validated by an implementation is something that needs to be verified, but in practice, the simple, left-most, outer-most reduction with sharing is a good approximation.
16:20:28 <mathijs> rwbarton: I've copied your remarks. I do think I understand it, but I'm afraid I'll get stuff mixed up, so I keep those around for when I feel a bit more confident on optimizations and evaluation-order :)
16:20:58 <mathijs> rwbarton: ask Cale?
16:21:14 <SamB> Lemmih: what's an exaple of a program that produces invalid C ?
16:21:59 <ddarius> mathijs: Tell Cale that you don't understand lazy evaluation and he'll go on about double x = x + x for an hour.
16:22:39 <Peaker> for 5 minutes I think :P
16:23:00 <Peaker> and its a pretty useful tutorial, though it might be more productive to have a bunch of these Cale tutorials in a wiki or such
16:23:22 <SamB> oh, and thoughtpolice: have you turned on -flint ?
16:23:35 <thoughtpolice> SamB: no, i'll try that actually
16:23:44 <Peaker> There's something more "fun" about reading something as someone writes it, though, than reading from a wiki. Perhaps a "text screencast" could make reading easier :)
16:24:00 <loadquo> Program lambdabot to repeat them on request?
16:24:04 <SamB> maybe bad C comes from badly-typed E ;-P
16:24:27 <mak__> scsibug: i don't think that using gtk on shell is the best way ;]
16:24:49 <rwbarton> Peaker: Or just have a bot that spews them into #haskell-cale every 10 minutes
16:25:36 <ddarius> "poorly typed" or "ill-typed"
16:25:42 <Peaker> hmm.. a:  @. (storewiki Cale-tutorial) (takeMinutes 10) (grep Cale)   could be nice :)
16:27:28 <scsibug> mak__: agreed.  what problems are you having with GD?
16:27:43 <mak__> linking problem
16:27:52 <scsibug> what platform?
16:28:04 <mak__> linuks gentoo amd64
16:28:19 <mak__> linker can't find symbols in libarary
16:28:38 <Lemmih> SamB: BinaryTrees and PureInteger (on 32bit only, I think).
16:28:46 <mak__> but that's strange, the same library works fine on my desktop...
16:29:07 <SamB> Lemmih: and this happens even with -flint ?
16:29:27 <SamB> you know, probably lhc-regress should always run with -flint ...
16:29:35 <scsibug> I built GD recently (OS X) and had to disable freetype for it to work.  is it having problems with gd specifically, or a dependency?
16:29:36 <Lemmih> SamB: Not sure.
16:30:26 <yip> that reminds of. i have some haskell bindings to freetype that i need to upload to hackage
16:30:32 <Lemmih> SamB: Right, -flint and -fdebug.
16:30:42 <SamB> or does it already ?
16:30:57 <scsibug> yip: that'd be nice
16:31:15 <Lemmih> SamB: It doesn't.
16:32:07 <dons> Lemmih: which PureInteger is this?
16:32:18 <dons> igloo's or isaac dupree's ? or some other?
16:32:22 <Lemmih> dons: The yellow one.
16:32:27 <dons> now i'm confused.
16:32:31 <SamB> thoughtpolice: oh, if the tree shapes look messed-up in your terminal, you can always try it with -dsquare-stats ... did I tell you this already ?
16:32:46 <thoughtpolice> SamB: nope
16:33:04 <Lemmih> dons: The one by Isaac Dupree.
16:33:13 <dons> ah ok :)
16:33:13 <thoughtpolice> dons: Isaacs
16:33:14 <dons> good
16:33:18 <SamB> I implemented that when I was testing JHC from school with Putty
16:33:29 <SamB> since Windows didn't come with all those fancy curve shapes
16:33:34 <thoughtpolice> also running lhc with -flint did in fact expose a problem I think
16:33:39 <thoughtpolice> so SamB++++++
16:33:51 <thoughtpolice> lhc-regress always using -flint is a good idea
16:33:55 <yip> scsibug: alright i'll get around to it eventually. i also have a haskell md2 loader
16:33:55 <thoughtpolice> but I can't say the same about -fdebug
16:33:59 <SamB> was it a type error ?
16:34:01 <thoughtpolice> because on OS X the linker has a problem with that
16:34:01 <thoughtpolice> :(
16:34:19 <SamB> what's -fdebug do ?
16:35:17 <Lemmih> SamB: It compiles the C with -g instead of -DNDEBUG -O3 -fomit-frame-pointer.
16:35:22 <thoughtpolice> SamB: it controls whether to pass '-g' or '-O3 -fomit-frame pointer' to gcc
16:35:33 <SamB> ah.
16:35:36 <Lemmih> We could drop the -g.
16:35:39 <thoughtpolice> but yes, using -fdebug with lhc on OS X is apparently a no-go or something, at least last time I tried
16:36:02 <thoughtpolice> then again, the OS X linker/apple gcc is fairly weird, I have found out :(
16:36:25 <Lemmih> -DNDEBUG disables all the assertions in the generated code.
16:36:30 <SamB> thoughtpolice: well, what did -flint turn up ?
16:36:41 <SamB> Lemmih: yeah, I know
16:36:51 <asgaroth> What knowledge is needed to understand the concept of Arrows?
16:36:59 <Lemmih> Perhaps we should move to #lhc?
16:37:03 <SamB> is there one ?
16:37:42 <thoughtpolice> Lemmih: we got beaten to the punch :(
16:38:02 <thoughtpolice> SamB: just a sec, still looking through the output
16:38:08 <SamB> it turns out that #lhc is for people afraid of black holes
16:38:46 <SamB> asgaroth: well, a background in use-of-pointy-sticks is good
16:38:46 <Saizan_> and LHC doesn't even use the STG
16:38:50 <newsham> i'm afraid of black-scholes
16:39:07 <Lemmih> SamB, thoughtpolice: #lhc-compiler?
16:39:09 <SamB> are those black-holes that might or might not be there ?
16:39:12 <thoughtpolice> Lemmih: k
16:39:47 <asgaroth> SamB: hehe, I guess I'll just try to read that paper by Hughes and see how far I get
16:44:32 <newsham> *sigh* I wish lhs2tex build wouldnt break on windows on alternating releases :(
16:47:18 <fnord123> cabal install Cabal doesn't appear to pick up version 1.6
16:47:46 <dcoutts> fnord123: did you cabal update?
16:47:53 <fnord123> which is unfortunate because cabal install cabal-install seems to require it. which means users can't cabal their way out of the ghc 6.10 / cabal-install 0.51 bug
16:47:57 <SamB> newsham: well, the easy solution is to only install every other release
16:47:58 <dcoutts> fnord123: cabal list cabal will tell you what version it knows about
16:48:09 <fnord123> you can't cabal update from 6.8 anymore since the repo isn't backwards compatible
16:48:21 <dcoutts> fnord123: hmm?
16:49:11 <SamB> fnord123: what ... it doesn't still have all versions of everything except a few things that were pulled ?
16:49:46 <newsham> samb: but if i dont observe it, does it fail to build?
16:50:00 <newsham> i think if i dont look at every version it might not get fixed in alternating versions
16:50:03 <fnord123> from ghc 6.8.2, cabal-install 0.5.2, Cabal librari 1.4.0.2, cabal update; cabal list -> cabal: Couldn't read cabal file "./Glob/0.1/Glob.cabal"
16:50:14 <SamB> newsham: oh
16:50:29 <fnord123> and cabal install cabal-install -> Could not find module `Distribution.Verbosity':
16:50:48 <SamB> newsham: maybe you should just sign up to betatest it!
16:51:29 <dcoutts> fnord123: hmm, I just did that today and it worked, I did cabal install cabal-install to upgrade from 0.5.2 to 0.6.0
16:51:39 <dcoutts> fnord123: could you hpaste the log
16:51:47 <fnord123> which log?
16:51:58 <fnord123> the rxvt session or is there a log in .cabal?
16:52:14 <dcoutts> fnord123: running the failing command, cabal install cabal-install --dry-run -v  would also be interesting
16:53:00 <fnord123> it claims that it wants to install cabal-install-0.6.0
16:53:27 <fnord123> ill also point out that the aur repo on arch doesn't build 6.10.1 from testing. it fails in network for me
16:53:32 <dcoutts> fnord123: ok, so you must already have Cabal-1.6.0.1 then?
16:53:35 <saml> give me a poker hand ranking algorithm in haskell
16:53:45 <saml> i just had an interview with that question
16:54:15 <fnord123> yes, I manually installed Cabal-1.6.0.1 because Distribution.Verbosity is in Cabal, but cabal-install wouldn't upgrade me past 1.
16:54:18 <fnord123> 1.4
16:54:57 <fnord123> the money question: how do I make urxvt selection get into the clipboard firefox uses? :)
16:55:13 <dcoutts> select then middle mouse button to paste
16:55:28 <SamB> doesn't do what you askeed, but it does work
16:55:35 <fnord123> awesome
16:56:15 <fnord123> http://hpaste.org/13742
16:56:35 <rherrmann> saml: the interviewer must have read this: http://quantile95.com/2008/12/31/monte-carlo-poker-odds/
16:56:57 <dcoutts> fnord123: can you re-run with -v
16:57:01 <yip> if there are any calculus people here who would be willing to help me with a problem please join me in #calc
16:57:09 <fnord123> dcoutts: does that work over synergy? Sometimes pasting into a windows machine gets tricky
16:57:30 <loop_> umm, 'case undefined of' ..?
16:57:43 <ksf> conal? I don't think Double is the proper choice for time values.
16:58:28 <ksf> Ideally, I guess, it'd be (Integer, Integer), a variable fixpoint type.
16:59:54 <saml> rherrmann, ah darn i should've read that. i could've aced the interview
17:00:33 <ksf> ...the first int representing something big enough, at least seconds, that is, so it's gotta be aeons till computation complexity explodes... and quantum-scales before the other part explodes.
17:01:07 <ksf> s/variable//
17:01:24 <rherrmann> saml: it would be hard to come up with this solution out of thin air
17:01:29 <fnord123> the log has been annotated, refresh
17:01:39 <repnop> how fast is that poker code?
17:01:51 <rherrmann> saml: maybe what he was really asking you was if you read the programming sub-reddit ;-)
17:02:01 <repnop> most poker eval libraries do it much different for performance reasons (poker-eval)
17:02:54 <ksf> poker ai's are the devil, anyway. it's way to easy to make them play way to good.
17:03:09 <repnop> only has to break even anyways ;)
17:03:12 <redditbot> Creating/consuming JSON in Haskell, with the help of pattern guards
17:03:14 <Olathe> What does a hand ranker do ? Just give an ordering to the hands ?
17:03:52 <saml> rherrmann, my hand function was very similar actually. i didn't have to draw random 5 cards.
17:04:40 <ksf> look at the still availible cards, figure out each hand's likeliness, compare that with your own hand and figure out whether it's a sure-enough win.
17:04:45 <repnop> most ranking methods convert the hand to a numeric value
17:04:52 <repnop> highest value wins
17:05:15 <fnord123> ksf, there's also the outs. you need to figure out how much money you will bet to see if you can push some people out
17:05:28 <Olathe> So, it's just an ordering, but they implement it by converting to numbers and comparing ?
17:05:41 <repnop> Olathe: there are many ways
17:05:46 <saml> the problem was "given 5 cards, test if it's full house...etc"
17:05:47 <fnord123> if you don't raise then someone with 5-j can stay in and can flip a 5j2 and then you're toast. so the bot needs to know how to push bad hands out
17:06:06 <ksf> well, I only know about 1vs1 strip poker on mobile phones.
17:06:12 <saml> but to unit test, probably one should generate random cards
17:06:17 <rherrmann> Olathe: it could do more than that ... basically what you have to do (the naÃ¯ve approach) is, given some known cards (yours, from someone else, from the "river", whatever), try many combinations for the missing ones and evaluate the whole set in order to gather chances
17:06:21 <ksf> ...and about testers complaining that they don't get to see tits.
17:06:21 <fnord123> s/flip/flop/
17:06:40 <Olathe> rherrmann: Ahh.
17:07:03 <repnop> yeah SAIE ;)
17:07:18 <repnop> (subjective all-in equity)
17:08:01 <rherrmann> repnop: hmm, I wasn't aware of the terminology
17:08:09 <repnop> there's already some highly optimized opensource libraries for hand evaluators
17:10:49 <ksf> ...I asked game design to include querying the user what he's wearing and prompting him to undress if necessary, but sadly noone listened.
17:11:40 <rherrmann> ksf: lol ... just wear 5 layered socks and you're good
17:11:41 <repnop> 2+2 evaluator is nice if you dont want a large library (7 card hand evaluator, easy to count your outs)
17:11:56 <CakeProphet> hmmm...
17:12:49 <rherrmann> Truth is I just learned Texas Hold'em on the holidays
17:12:55 <repnop> yeah
17:13:06 <CakeProphet> > ( )   --lol
17:13:08 <lambdabot>   ()
17:13:10 <rherrmann> Then wondered if there were online poker calculators
17:13:11 <repnop> i wrote a naive algorithm awhile back before i did some research hehe
17:13:51 <rherrmann> Then, frustrated with their interfaces, wondered if I could come up with an app for Android
17:13:55 <fnord123> is there a cap on how long a hpaste can be?
17:13:58 <rherrmann> I mean, quickly
17:14:07 <ksf> actually, the key in winning strip poker is loosing slow enough to be credible.
17:14:16 <fnord123> dcoutts_: is there a section you need? hpaste appears to be cropping my post
17:14:25 <rherrmann> And started missing ghci in Android ;-)
17:14:53 <repnop> rherrmann: you interested in it?
17:14:59 * CakeProphet wonders how he would write an interpreter for a lazy/currying dialect of Python in Haskell.
17:15:29 <repnop> or was it just a simple project you're not going to think about again
17:15:35 <ksf> I'd try to do it as a DSL first, with TH.
17:15:47 <rherrmann> repnop: yes, maybe a small interpreter would be a lot of fun
17:16:30 <olidu> could someone take a quick look and help me out? http://hpaste.org/13744
17:16:57 <ksf> on second thought, don't do it, or python/ghc will be en par with haskell/ghc on the shootout.
17:17:20 <ksf> on third thought, do it, just to piss of the pythonistas.
17:17:36 <Olathe> Good.
17:17:52 <TomMD> olidu: The multiset.cabal file needs to specify its dependancies (eg: base)
17:18:09 <olidu> Tom, how?
17:18:58 <Saizan_> olidu: in the build-depends: field
17:18:59 <TomMD> edit MultiSet.cabal (or some similarly named file) and look for the "Build-Depends:" line
17:19:01 <rherrmann> repnop: we could call it HasToGo ... hehe
17:19:15 <TomMD> olidu: Add 'base' to that line.
17:19:26 <jonaskoelker> ksf: not much love for python, eh?
17:19:26 <dcoutts> fnord123: I'm interested in the top bit, when it compiles Setup.hs and configures cabal-install
17:19:40 <olidu> TomMD, it already has it.  "build-depends:    base, containers"
17:19:45 <ksf> not much hatred, either.
17:20:26 <ksf> I've only once written something in it, and figured out that to fix that last annoying bug I had to do dirty double-underscore hacks and stuff.
17:20:43 <Saizan_> olidu: ah, you want base == 3.*
17:20:52 <Saizan_> olidu: or base >= 3 && < 4
17:21:38 <Saizan_> olidu: otherwise it pick base-4.0.0.0 which doesn't have that module
17:21:41 <fnord123> I don't see anything about Setup.hs in the log. I pasted the end of the message now
17:21:48 <ksf> jonaskoelker, http://pastebin.com/m696e43fc
17:22:17 <Saizan_> olidu: i think you've to use the syb package if you want it to compile with base-4, but i'm not sure if the modules are the same
17:22:22 <ksf> There's not much chance of it being developed anymore, as I'm only looking at it while not coding.
17:22:37 <nanothief> Is there a library that can evaluate mathematical expressions with variables: eg evalExpr [("x", 2.5),("y",2)] "x * y" == 5.0
17:22:55 <olidu> problem solve!! thanks TomMD, Saizan
17:23:23 <olidu> thank you guys!!
17:23:42 <TomMD> np
17:24:09 <EvilTerran> nanothief, that's several problems in one; parsing, substitution, and evaluation
17:24:19 <olidu> btw, Python is still a good language, helped me a lot.  Although it's really slow
17:24:57 <EvilTerran> there's parsing libraries specialised to maths expressions
17:25:04 <nanothief> EvilTerran, yeah, I would write the program myself, but it will probably take a while, and I was hoping someone has done it already
17:25:06 <dcoutts> @localtime benl23
17:25:07 <lambdabot> Local time for benl23 is Thu Jan  8 12:25:06 2009
17:25:07 <EvilTerran> and the other two are relatively easy
17:25:13 <ksf> The main thing is that I don't really do any scripting at all. I forgot nearly all of my perl.
17:25:21 <EvilTerran> i don't know if it's been done before; probably :P
17:25:33 <jonaskoelker> ksf: looks nice :)
17:25:42 <ksf> ...and if I needed a language to embed, I'd either use lua or haskell.
17:26:53 <fnord123> ksf, why?
17:27:11 <fnord123> haskell to embed? with no binary distribution system?
17:27:12 <ksf> 'cos lua is fast and easily embedded, and haskell is haskell.
17:27:30 <ksf> ...not to mention that lua's semantics are nice, too.
17:28:04 <ksf> dynamic typing works quite well for run-time compilation.
17:28:08 <EvilTerran> fun with _G!
17:29:12 <ksf> anyway, in pyFret there's the problem that nothing's shown on the fretboard at program start.
17:29:52 <benl23> dcoutts: pong!
17:30:20 <ksf> ...and calling reCalc in the Proper Time won't work as it does'nt exist yet, or something.
17:30:32 <dcoutts> benl23: just checking that 'benl23' really is Ben Lippmeier
17:30:34 <ksf> s/in/at
17:30:38 <benl23> thats me
17:30:49 <dcoutts> benl23: jolly good :-)
17:30:52 <benl23> :)
17:30:58 <chrisdone> pointlessVariableName <- getThing
17:30:58 <chrisdone> case pointlessVariableName of
17:30:58 <chrisdone>   (Comp lex,@patt(ern,match)) -> ...
17:30:58 <chrisdone>   otherwise -> ..
17:31:02 <dcoutts> benl23: you should join #ghc really
17:31:04 <chrisdone> I hate this construct
17:31:13 <benl23> hmm ok, see you there.
17:31:24 <zkincaid> Does anyone know if there's a good way to "decorate" recursive data types?  Like if I decide that I want to add source position information to my AST data type, is there a way to do it in such a way that I can just lift my AST functions to work on my decorated AST?
17:31:47 <fnord123> dcoutts, do you need more information about this? I'm not sure how to debug it.
17:32:28 <fnord123> also, I have some X11-xdamage bindings to give. I've tested them and it seems to work alright. unsure if anyone wants it tho
17:32:35 <dcoutts> fnord123: where is the paste?
17:32:54 <fnord123> http://hpaste.org/13742#a3
17:32:54 <chrisdone> doesn't anyone else want a version of case which works in monads, like let?
17:33:18 <jonaskoelker> zkincaid: you could change "data AST = ..." to "data AST a = ...", then add a's to every node...
17:33:24 <fnord123> as I mentioned, there doesn't appear to be any mention of "Setup"
17:33:30 <dcoutts> fnord123: ahhh, your Cabal-1.6.0.1 is borked, the files have been deleted
17:33:43 <fnord123> but i just installed it :(
17:34:04 <chrisdone> ~_~
17:36:23 <olidu> Could someone take a quick look? what do the compiler err msgs mean? http://hpaste.org/13745
17:36:50 <Lemmih> olidu: Use --make
17:37:03 <newsham> anyone know how to use "{-# OPTIONS_GHC -fglasgow-exts #-}" in an lhs2tex file?
17:37:53 <dcoutts> fnord123: check the files, they appear to be missing
17:37:53 <ksf> zkincaid, you might want to move the structure out of your AST (no type recursion, that is) and then use fmap to your heart's content.
17:38:24 <fnord123> yes, /usr/lib/ghc-6.8.2/lib/ only has Cabal-1.2....
17:38:47 <olidu> Lemmih, like this?   "ghc --make -threaded  -o histogen histogen.o"
17:38:51 <dcoutts> fnord123: ghc-pkg describe Cabal-1.6.0.1 says what the lib dir is
17:39:07 <fnord123> when I runghc Setup.hs install without sudo, I'm told permission denied only in the documentation dir. I suspect it's only trying to install docs. that's odd.
17:39:27 <Lemmih> olidu: Right.
17:40:08 <olidu> it's not "no input files"
17:40:17 <olidu> It's now "no input files"
17:40:32 <Lemmih> olidu: Er, ghc --make histogen.hs -o histogen
17:40:33 <olidu> but my .o file is there
17:41:10 <roconnor> @djinn (Not (Not a) -> a) -> (Not a -> Not b) -> b -> a
17:41:11 <lambdabot> f a b c = a (\ d -> void (b d c))
17:41:23 <Lemmih> olidu: Otherwise you have to add the right package flags yourself.
17:41:45 <olidu> the "-threaded" flag doesn't seem to work with "--make"
17:42:07 <zkincaid> hmm... I was hoping for something that wouldn't require me to change the AST functions, but those are pretty reasonable alternatives - thanks ï»¿jonaskoelker and ksf
17:42:41 <fnord123> ok it's actually /usr/local/lib/Cabal-1.6.0.1/ghc-6.8.2/ and the .a is there. what $PATH is cabal feeding off of that it would miss this?
17:42:52 <Saizan_> zkincaid: for a somewhat advanced/novel technique see the Data Types a la Carte paper
17:43:02 <jonaskoelker> ksf: how do you mean "move the structure out of your AST"?
17:43:08 <dcoutts> fnord123: are the .hi files there too?
17:43:16 <fnord123> no
17:45:26 <dcoutts> fnord123: so that's why ghc is complaining
17:45:35 <dcoutts> fnord123: try reinstalling the Cabal lib
17:45:36 <mae> hello
17:46:47 <olidu> how to compile a threaded program? should I compile it to .o with -threaded or I can directly "--make"?
17:48:24 <fnord123> ok I rebuilt and reinstalled. and when I look in the subdirs, I see the .hi files. However, since I'm not clever I didn't look in those before when I reported no .hi files
17:48:35 <fnord123> rerunning cabal install cabal-install yields the same error
17:48:37 <zkincaid> Saizan_: thanks, I'll look it up
17:49:54 <dcoutts> fnord123: are the .hi files still not there? is your disk full or something? is any error reported during installation?
17:50:24 <zkincaid> Saizan_: Cool - this looks like it might be what I was looking for
17:50:33 <ksf> jonaskoelker, separating the whole thing into a) a generic tree b) a type for leaf nodes and b) a type for branch nodes (including type information of what's a legitimate type for its branch) and write a functor instance for the tree.
17:50:46 <EvilTerran> zkincaid, another approach is to rewrite "data Expr = Expr :+: Expr | Expr :*: Expr | Val Integer", for example, as "data Expr expr = expr :+: expr | expr :*: expr | Val Integer"
17:51:08 <ksf> it's more of a quick and dirty "start here thinking about it"- idea.
17:51:12 <fnord123> they are in Distribution/ and Language/Haskell. I didn't look in there for the .hi files since I had a brain fart and thought it would all be in the Cabal-1.6.0.1/ghc-6.8.2/ dir and not deeper
17:52:12 <EvilTerran> zkincaid, and then, given "newtype Fix f = In { out :: f (Mu f) }", the old Expr is equivalent to Fix Expr
17:52:28 <EvilTerran> (although you've got to faff around wrapping and unwrapping the newtype)
17:53:04 <ksf> the key idea being that you don't want to take the leaves apart in your traversal functions, but filter out the part that you want to change beforehand.
17:53:11 <jonaskoelker> ksf: how would a generic tree look?  Just "data Tree a = Node a [Tree a]"?  Or... How do you keep in the structural constraints (i.e. ifs have 3 children, nil has none, ...)?
17:54:02 <fnord123> i wonder why this is verifying Cabal >=1.6 is installed but then proceeds to use Cabal 1.4. If it ends up not finding 1.6, surely it would die there (?)
17:54:05 <EvilTerran> zkincaid, but you can have others, like "data FixPlusA a f = InPA { annotation :: a, outPA :: f (FixPlusA a f) }", etc
17:54:25 <ksf> jonaskoelker, I'm wondering myself.
17:54:42 <EvilTerran> zkincaid, it can get a bit cumbersome, but that's one of the more gratuitously general approaches
17:54:43 <EvilTerran> :)
17:55:04 <jonaskoelker> EvilTerran: how you pattern-match against that?
17:55:18 <ksf> I'm quite sure it's possible even without dependent types.
17:56:00 <EvilTerran> jonaskoelker, you can pattern-match a (Fix Expr) with, say "In (x :+: y)", which'd give (x, y :: Fix Expr)
17:56:58 <ksf> node labels being a gadt that return tuples or lists for their childrens, or something.
17:57:12 <EvilTerran> and a (FixPlusA a Expr) with "InPA a (x :+: y)", etcetc
17:57:13 <jonaskoelker> EvilTerran: but then not also against InPA...
17:57:27 <dcoutts> fnord123: it knows that 1.6 is installed, but ghc is not finding the files
17:57:33 <jonaskoelker> ah, so you're commited to either an annotation or not, but you can be type-agnostic...
17:58:15 <jonaskoelker> (as to the annotation type)
17:58:46 <EvilTerran> jonaskoelker, you could probably do something crafty with a typeclass to make it possible to generalise a lot of operations over any appropriate Fix-esque wrapping
18:00:20 <Saizan_> EvilTerran: isn't that what data types a la carte do?
18:00:42 <jonaskoelker> EvilTerran: it sounds like a "class FixMemmebr a b where getB = a -> b" or something... but I'm vague and uncertain
18:00:58 <EvilTerran> Saizan_, i think it's similar, yeah; i forget how heavily it got stuck into type-level fixedpoints
18:01:16 <fnord123> I got it! I used --reinstall on Cabal and zlib and now it's all working fine. I'm reinstalling ghc 6.10 to move back onto the current release.
18:01:28 <Saizan_> well, it doesn't put the extra data in the Fixers, but composes the non-recursive functors
18:01:53 <dcoutts> fnord123: great
18:02:17 <fnord123> oh dear, I hope he wasn't staying up until 2am for me. :(
18:02:54 <EvilTerran> fnord123, he's usually on here quite late, i wouldn't worry about it :)
18:03:31 <fnord123> well i made the stupid mistake of looking in the wrong dir for these .hi files which doesn't help someone want to help more
18:06:01 <EvilTerran> jonaskoelker, i was thinking something like "class FixedPoint fix where fixMap :: (f (fix f) -> g (fix g)) -> fix f -> fix g; instance FixedPoint Fix where fixMap f (In x) = In (f x); ..."
18:06:32 <zkincaid> hmm... alright, I have some reading/experimenting to do...
18:06:37 <jonaskoelker> hmm...
18:07:54 <EvilTerran> (instance FixedPoint (FixPlusA a) where fixMap f (InPA a x) = InPA a (f x))
18:09:44 <Saizan_> i wonder if fixMap :: (forall a. f a -> g a) -> fix f -> fix g would be enough
18:09:44 <ksf> the main problem while coding is finding the proper balance between converging and diverging ideas...
18:10:01 <kpreid> > succ 1.0
18:10:02 <lambdabot>   2.0
18:10:04 <ksf> ...and, of course, figuring out what's what.
18:10:46 <EvilTerran> Saizan_, i don't think so, seeing as In :: f (Fix f) -> Fix f
18:11:41 <CakeProphet> > [a,b,c] #+# [a,b,c]
18:11:42 <lambdabot>   Not in scope: `#+#'
18:11:43 <drdozer> after 14 hours coding haskell straight, I seem to be getting into the zen
18:11:50 <Saizan_> EvilTerran: fixMap f (In x) = In . f . fixMap f $ x ?
18:11:51 <CakeProphet> :(
18:12:01 <CakeProphet> I thought #+# was polynomial addition?
18:12:25 <ksf> Is the thought of zenning zen?
18:12:31 <Saizan_> i miss a fmap
18:12:37 <EvilTerran> Saizan_, actually, isn't (forall a. f a -> g a) harder to satisfy than (f (fix f) -> g (fix g)), anyway?
18:13:13 <Saizan_> yeah, that's what i referred to with "enough"
18:13:58 <EvilTerran> i mean, yours might be excessive
18:14:31 <EvilTerran> seeing as mine suits and is easier to satisgy
18:15:01 * EvilTerran -> sleep
18:15:07 <CakeProphet> > *+*
18:15:08 <lambdabot>   <no location info>: parse error on input `*+*'
18:15:21 <CakeProphet> what's polynomial addition?
18:15:22 <Saizan_> right, but yours feels a little too permissive, f (fix f) -> g (fix g) can scramble the tree as it wants
18:15:49 * benl23
18:15:54 * benl23
18:16:28 <Saizan_> CakeProphet: there isn't an operator defined in the standard libraries
18:16:57 * jonaskoelker :: caffeine -> learning
18:17:48 <igowen> haha
18:18:54 <jonaskoelker> I think I should probably bound the type of learning
18:18:57 * Ikkebr slaps benl23 around a bit with a large trout
18:19:24 * jonaskoelker :: (NonReligious learning) => caffeine -> learning
18:19:47 <jonaskoelker> or something...
18:21:55 <jonaskoelker> unfortunately, even though (not.null) coffee, workhours(tomorrow) > 0 so I have to go to bed
18:22:06 * jonaskoelker >>= sleep >>= work
18:27:59 <chessguy> quiet in here tonight
18:28:49 <byorgey> hi chessguy
18:29:00 <chessguy> hiya byorgey
18:33:54 <mmorrow> thoughtpolice: i just bought the jones book you referenced earlier.
18:34:21 <thoughtpolice> mmorrow: it's a good book.
18:34:25 <thoughtpolice> very worth it
18:34:57 * Olathe >> wheresOlatheAt
18:35:01 <Olathe> It's magic !
18:35:16 <BMeph> Hm, I have a good news/bad news/great news situation. :)
18:35:27 <Olathe> Ahh !
18:36:41 <BMeph> Good news: my copy of RWH is in my apartment manager's office. Bad news: Since I've been working overtime all week, I can't get to my manager's office before it's closed. Great news: I'm not working OT tomorrow! :)
18:37:55 <yip> did you guys see this? http://lambda-the-ultimate.org/node/3131
18:40:07 <Olathe> BMeph: Ahh, that's cool.
18:41:14 <gnuvince> Is there a way to set the prompt of GHCi with an environment var or a .ghcirc file?
18:41:31 <jhujhiti> http://pastie.org/355289 is there a way to make this kind of thing work? i'm not sure what i'd even call it
18:41:55 <Olathe> jhujhiti: No, C is used as a constructor twice.
18:42:36 <jhujhiti> Olathe: i'm not sure how else i could make A contain a C?
18:42:52 <Olathe> data A = OmgC C
18:43:03 <kpreid> jhujhiti: data A = AB | AC C
18:43:13 <Olathe> Then, you can construct it with OmgC (C 1 2)
18:43:26 <Olathe> OmgC (C 1 2) will be type A.
18:43:35 <Olathe> Or, even.
18:43:35 <jhujhiti> yeah, but then i need basically two type constructors
18:43:45 <Olathe> Sure.
18:43:52 <rwbarton> gnuvince: Yes, put    :set prompt "GHCi> "    in ~/.ghci
18:44:03 <kpreid> jhujhiti: you cannot have data constructors with the same name for different types
18:44:04 <Olathe> You want to hold a C, so you have to make a C using a constructor.
18:44:18 <Olathe> And you want to make an A, so you need to make an A using a constructor.
18:44:37 <gnuvince> rwbarton: thanks you
18:45:07 <Olathe> jhujhiti: You can, of course, make a function like makeA x y = OmgC (C x y)
18:45:27 <jhujhiti> heh, the factory pattern. *grumbles*
18:45:33 <Olathe> Yes :)
18:45:40 <jhujhiti> well, i guess the answer to my original question is "no" =(
18:45:50 <Olathe> Yeah, you have two functions called C there.
18:45:52 <kpreid> you can also make a function in a typeclass which takes Int and Int and makes an A or C depending on context
18:46:12 <jhujhiti> kpreid: ah, interesting, but how do i differentiate on the return type alone?
18:46:26 <kpreid> jhujhiti: haskell does that for you
18:46:30 <Olathe> It's a bit like this :
18:46:36 <kpreid> > minBound :: Boolean
18:46:37 <lambdabot>       Not in scope: type constructor or class `Boolean'
18:46:41 <Olathe> > (fromIntegral 5) :: Float
18:46:41 <kpreid> > minBound :: Char
18:46:43 <lambdabot>   5.0
18:46:43 <lambdabot>   '\NUL'
18:46:44 <kpreid> > minBound :: Bool
18:46:46 <lambdabot>   False
18:46:46 <Olathe> > (fromIntegral 5) :: Rational
18:46:47 <lambdabot>   5%1
18:47:05 <Olathe> You effectively tell it what the return type is, so it knows which function to use.
18:47:38 <Olathe> Just like if I told you I wanted a Rational, you could point out the Rational version of fromIntegral.
18:48:05 <drdozer> jhujhiti: OO languages only look at what kind of object the method is on ; haskell looks at the type of all parameters to a function to decide what code to run
18:48:25 <jhujhiti> drdozer: right
18:49:39 <jhujhiti> i like the typeclass idea. it seems succinct.
18:49:58 <drdozer> type classes are very nice IMHO
18:49:59 <Olathe> Type inference is where it's at :)
18:50:13 <dolio> Haskell potentially looks at the type of the result, too.
18:50:15 <ksf> http://hpaste.org/13746
18:50:28 <dolio> Which you don't typically get in most other languages.
18:50:33 <ksf> why doesn't the time display update continuously?
18:50:40 <centrinia> Are datatype constructors curried functions?
18:51:15 <Olathe> I think so.
18:51:21 <Olathe> What's a constructor with two arguments ?
18:51:25 <ksf> they're at least behaving as such.
18:51:28 <Olathe> Ahh, (:)
18:51:38 <Olathe> (:) is a nice example of a curryable constructor.
18:51:46 <ksf> Either, too.
18:51:58 <ksf> I didn't say that.
18:52:28 <Olathe> @instances Monad
18:52:29 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:52:31 <kpreid> infix confuses the issue with sections though :)
18:53:05 <kpreid> > map ((,) 0) [1,2,3,4]
18:53:06 <lambdabot>   [(0,1),(0,2),(0,3),(0,4)]
18:59:39 * ksf notices that he jumped on the (fmap.fmap)-craze bandwagon.
19:00:10 <Olathe> > 1:2:3:4:[]
19:00:11 <lambdabot>   [1,2,3,4]
19:02:55 <kpreid> :t fmap.fmap
19:02:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:03:19 <kpreid> ah
19:03:24 <SamB> dcoutts_: any idea what user trac runs as ?
19:03:40 <kpreid> the trick to seeing these things is to see what the function does to its first argument...
19:03:45 <ksf> http://www.haskell.org/pipermail/reactive/2008-November/000054.html <-- fmap.fmap
19:04:17 <kpreid> once one notices that fmap takes a function and adds one functor, it's obvious what fmap.fmap is
19:04:26 <ksf> see also http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
19:05:10 <BMeph> kpreid, ksf: conal has a plethora of "helpful" functions for dealing with such issues as well. :)
19:05:51 <kpreid> that's funny, because this is making me think of his 'semantic editor combinators'
19:06:48 <kpreid> ...which are the same thing
19:07:41 <ksf> it's not surprising, though, I'm using (fmap.fmap) to cut through two of his libraries...
19:08:05 <ksf> reactive-glut and reactive, that is.
19:08:33 <koninkje> mux: thanks. I've posted updated versions of the package
19:08:43 <BMeph> kpreid: Right, that's what I was refering to, I just didn't remember how /he/ refered to them. :)
19:09:12 <kpreid> yeah, and I didn't remember until I reread his article
19:09:15 <b7j0c> any haskeller's here try factor yet?
19:09:18 <kpreid> (thus the pause)
19:09:24 <ksf> has noone got an idea what makes the display noncontinuous in http://hpaste.org/13746 ? ... or at least has the same problem.
19:13:17 * ksf is going to try withTimeE over framePass
19:16:43 <geezusfreeek> i have mixed feelings about (fmap.fmap)
19:17:42 <ksf> Indeed, it's the solution.
19:17:53 <ksf> still, the question is why.
19:17:59 <geezusfreeek> kind of like my mixed feelings of doing f `flip` y with the idea being that `flip` looks like a placeholder for x
19:19:35 <ksf> It's hard to imagine the reactive interface without it.
19:21:02 <mmorrow> > (fmap . fmap . fmap) (*2) [[[0],[3..5]],[[92,4]]]
19:21:04 <lambdabot>   [[[0],[6,8,10]],[[184,8]]]
19:22:31 <pumpkin> why fmap?
19:22:50 <rwbarton> > let (-) = flip in (map - [1,2,3]) (* 10)
19:22:51 <lambdabot>   [10,20,30]
19:23:08 <kpreid> rwbarton: owwwwww
19:23:12 <pumpkin> lol
19:23:27 <kpreid> > let (__) = flip in (map __ [1,2,3]) (* 10)
19:23:28 <lambdabot>   Couldn't match expected type `t1 -> t'
19:23:34 <rwbarton> tried that, _ is a letter
19:23:39 <kpreid> oh, duh
19:24:26 <rwbarton> > let (Â·) = flip in (map Â· [1,2,3]) (* 10)
19:24:27 <lambdabot>   [10,20,30]
19:24:38 <igowen> hah
19:24:45 <rwbarton> > let (Â·) = flip in (map (* 10) Â·) [1,2,3]
19:24:47 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
19:25:07 <kpreid> > let (Â·) = id in (map (* 10) Â·) [1,2,3]
19:25:09 <lambdabot>   [10,20,30]
19:25:29 <kpreid> (let's make that work with a typeclass!!!)
19:25:40 <rwbarton> I had the same thought :(
19:26:35 <Saizan_> i'd rather use a quasiquoter :)
19:27:43 <lepassive> I'm struggling with RPN example in LUH: http://hpaste.org/13748 , I understand LUH but can't get the grip of head . foldl . ..etc
19:28:06 <lepassive> understand rpn explanation in LUH**
19:28:37 <kpreid> lepassive: you can rewrite that as solveRPN x = head (foldl foldingFunction [] (words x))
19:29:13 <iskaldur> hi, is there a hashmap implementation in haskell that supports O(1) lookup and insertion? (is it possible to do this?)
19:29:44 <kpreid> @hoogle HashTable
19:29:45 <lambdabot> module Data.HashTable
19:29:45 <lambdabot> Data.HashTable data HashTable key val
19:30:04 <kpreid> it's there and it works...but it's in IO.
19:30:09 <iskaldur> how does it work, though (what with haskell data structures being immutable?)
19:30:23 <SamB> Igloo: how did you get the "Test Case:" field in the GHC trac?
19:30:25 <Saizan_> it uses a mutable datastructure :)
19:30:26 <lepassive> kpreid, Now it makes more sense Thanks
19:30:29 <SamB> I want one for the lhc trac
19:30:52 <iskaldur> how? using monads somehow?
19:31:05 <Saizan_> iskaldur: yeah, using IO in this case
19:31:32 <Saizan_> iskaldur: you could do the same with ST
19:31:39 <SamB> @ask Igloo how did you get the "Test Case:" field in the GHC trac? I wants it for LHC's trac!
19:31:39 <lambdabot> Consider it noted.
19:32:10 <Saizan_> iskaldur: note that for most use cases a balanced tree like Data.Map is fine to use
19:32:32 <iskaldur> great, thanks! do you know of any good descriptions of its implementation besides the "dynamic hash tables" paper by per-ake larson?
19:32:33 <kpreid> iskaldur: you have the choice of O(1) and or O(log n)
19:32:51 <kpreid> s/O(1) and/O(1) and imperative/
19:32:56 <iskaldur> kpreid: what do you mean by choice?
19:33:29 <kpreid> Data.HashTable is O(1) but imperative, Data.Map is O(log n)
19:33:38 <iskaldur> ah, yes
19:33:45 <kpreid> I would use Data.Map unless you know you have reason not to
19:34:03 <Saizan_> uniqueness typing would be nice here
19:34:23 <iskaldur> why? because it's harder to code using data.hashtable, because of the monadic/imperative-style programming required?
19:34:36 <Saizan_> iskaldur: yeah
19:34:43 <kpreid> iskaldur: because if you use it you have to be in IO
19:34:58 <kpreid> (why isn't Data.HashTable in ST?)
19:35:03 <pumpkin> didn't someone mention an ST-based hashtable, or was that someone wishing?
19:35:03 <pumpkin> ah
19:35:15 <rwbarton> iskaldur: I also hear the implementation is not very good (because nobody uses it, because it's in IO...)
19:35:43 <iskaldur> by ST you're referring to the state monad?
19:36:01 <Saizan_> no, the ST monad
19:36:14 <pumpkin> it's magic
19:36:25 <pumpkin> like some parts of IO, but you can break free!
19:36:32 <lepassive> is there something like inspect and steps can be used to see the steps executed ?
19:36:33 <Saizan_> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
19:36:51 <pumpkin> lepassive: how do you mean?
19:37:16 <lepassive> like in VS step forward step back something like that ?
19:37:18 <Saizan_> lepassive: there's something like that in the ghci debugger
19:38:45 <lepassive> Saizan_, I'll look it up thanks
19:53:29 <lepassive> this line is fuzzy to me              foldingFunction xs numberString = read numberString:xs
19:54:16 <lepassive> a function takes in xs and a numberString returns read numberString:xs ?
19:54:21 <monochrom> (read numberString) : xs
19:54:30 <BMeph> lepassive: It's the last line of the definition of foldingFunction. :)
19:54:35 <ray> function application is fairly high precedence
19:54:52 <rwbarton> As in, higher than everything else :)
19:54:58 <ray> fairly
19:54:59 <rwbarton> Any operator, at least.
19:55:12 <lepassive> BMeph, I don't get how it works
19:55:39 <monochrom> (read numberString) : xs   may be for example  5 : [1,2,4]
19:55:54 <monochrom> @type read
19:55:55 <lambdabot> forall a. (Read a) => String -> a
19:56:07 <monochrom> yeah, 5 : [1,2,4] is an example.
19:57:00 <matthewp> > read "56" :: Int
19:57:01 <lambdabot>   56
19:57:31 <SamB> @tell Igloo nevermind, I figured it out ...
19:57:31 <lambdabot> Consider it noted.
19:57:47 <lepassive> okay this is my try in python http://pastebin.com/db390271 and It works and i guess he is doing the same here but some complicated way
19:57:47 <CakeProphet> @pl #+# a b = map sum $ transpose [a,b]
19:57:47 <lambdabot> (line 1, column 1):
19:57:47 <lambdabot> unexpected "#"
19:57:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
19:58:03 <Olathe> @tell rapidlyEmptyingDiskSpace hello
19:58:03 <lambdabot> Consider it noted.
19:58:03 <CakeProphet> @pl (#+#) a b = map sum $ transpose [a,b]
19:58:03 <lambdabot> (line 1, column 11):
19:58:04 <lambdabot> unexpected "="
19:58:04 <lambdabot> expecting variable, "(", operator or end of input
19:58:23 <Olathe> I wonder if the messages have an expiration.
19:58:28 <rwbarton> @pl \a b -> map sum $ transpose [a,b]
19:58:28 <lambdabot> ((map sum . transpose) .) . (. return) . (:)
19:59:52 <Olathe> @type sum
19:59:53 <lambdabot> forall a. (Num a) => [a] -> a
20:00:04 <Olathe> > transpose [a, b]
20:00:05 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
20:00:10 <Olathe> Lies.
20:00:16 <Olathe> > transpose [1, 2]
20:00:17 <lambdabot>       No instance for (Num [a])
20:00:17 <lambdabot>        arising from the literal `1' at <inter...
20:00:33 <Olathe> > transpose [[1], [2]]
20:00:34 <lambdabot>   [[1,2]]
20:00:36 <rwbarton> > map sum $ transpose [[1,3], [2]]
20:00:37 <lambdabot>   [3,3]
20:00:43 <rwbarton> > map sum $ transpose [[2], [1,3]]
20:00:44 <lambdabot>   [3,3]
20:00:56 <Olathe> Hmm...
20:01:00 <rwbarton> > transpose [[2], [1,3]]
20:01:02 <lambdabot>   [[2,1],[3]]
20:01:12 <rwbarton> Huh, OK.
20:01:16 <rwbarton> @src transpose
20:01:16 <lambdabot> transpose []             = []
20:01:16 <lambdabot> transpose ([]   : xss)   = transpose xss
20:01:16 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
20:03:06 <Olathe> > transpose [[1..3], [1..10]]
20:03:08 <lambdabot>   [[1,1],[2,2],[3,3],[4],[5],[6],[7],[8],[9],[10]]
20:03:19 <Olathe> A nice zip workaround.
20:04:02 <igowen> "workaround"?
20:04:21 <ray> > transpose [[1..10], [11..20]]
20:04:22 <Olathe> > zipWith (+) [1, 2, 3] [4, 5]
20:04:23 <lambdabot>   [[1,11],[2,12],[3,13],[4,14],[5,15],[6,16],[7,17],[8,18],[9,19],[10,20]]
20:04:24 <lambdabot>   [5,7]
20:04:41 <Olathe> > map sum $ transpose [[1, 2, 3], [4, 5]]
20:04:43 <lambdabot>   [5,7,3]
20:04:46 <rwbarton> Yeah, that's a neat trick
20:04:52 <pumpkin> igowen: I guess it's a zip that waits for both lists to end
20:04:54 <pumpkin> instead of the normal one
20:04:59 <igowen> ah.
20:04:59 <pumpkin> *unlike
20:05:00 <ksf> @instances Fractional
20:05:01 <lambdabot> Double, Float
20:05:05 <ksf> grrrr
20:05:17 <igowen> yeah, you'd have to use lists instead of tuples for that
20:06:16 <Olathe> let zipWith' f (a:as) (b:bs) = f a b:zipWith' f as bs; zipWith' _ as [] = as; zipWith' _ [] bs = bs
20:06:19 <SamB> > transpose [[1..3], [1..10]]
20:06:20 <lambdabot>   [[1,1],[2,2],[3,3],[4],[5],[6],[7],[8],[9],[10]]
20:06:24 <Olathe> There's another.
20:06:33 <SamB> oh, you did that one already
20:06:34 <Olathe> > zipWith' (+) [1..2] [1..3]
20:06:35 <lambdabot>   Not in scope: `zipWith''
20:06:38 <Olathe> Bah.
20:06:39 <SamB> > transpose [[1..10], [1..3]]
20:06:40 <lambdabot>   [[1,1],[2,2],[3,3],[4],[5],[6],[7],[8],[9],[10]]
20:06:48 <SamB> > transpose [[4..10], [1..3]]
20:06:50 <lambdabot>   mueval: Prelude.read: no parse
20:06:50 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
20:06:50 <Olathe> > zipWith' (+) [1..2] [1..3]
20:06:51 <lambdabot>   [2,4,3]
20:06:53 <rwbarton> :t zipWith'
20:06:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
20:07:00 <Olathe> > zipWith (+) [1..2] [1..3]
20:07:02 <lambdabot>   [2,4]
20:07:08 <SamB> > transpose [[4..10], [1..3]]
20:07:10 <lambdabot>   [[4,1],[5,2],[6,3],[7],[8],[9],[10]]
20:07:42 <Olathe> > zipWith (++) "zm!" "og"
20:07:43 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
20:08:07 <Olathe> @pl \a b -> a:b:[]
20:08:08 <lambdabot> (. return) . (:)
20:08:12 <igowen> > zipWith (++) ["zm!" "og"]
20:08:13 <lambdabot>   Couldn't match expected type `t -> [a]'
20:08:32 <Olathe> > zipWith (((:[]).).(:)) "zm!" "og"
20:08:33 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
20:08:36 <Olathe> Lies.
20:08:48 <Olathe> > zipWith ((.(:[])).(:)) "zm!" "og"
20:08:49 <lambdabot>   ["zo","mg"]
20:08:54 <Olathe> > zipWith' ((.(:[])).(:)) "zm!" "og"
20:08:55 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
20:08:55 <lambdabot>        Expect...
20:09:04 * Olathe sobs.
20:09:10 <igowen> there's too much punctuation in that expression
20:09:12 <lepassive> > putStrLn "I got it finally"
20:09:14 <lambdabot>   * Exception: "<IO ()>"
20:09:16 <Olathe> @type (zipWith, zipWith')
20:09:18 <lambdabot> forall a b c a1. ((a -> b -> c) -> [a] -> [b] -> [c], (a1 -> a1 -> a1) -> [a1] -> [a1] -> [a1])
20:09:26 <SamB> > transpose ["zm!","og"]
20:09:27 <lambdabot>   ["zo","mg","!"]
20:09:41 <lepassive> > "I got it"
20:09:41 <SamB> > (concat.transpose) ["zm!","og"]
20:09:43 <lambdabot>   "I got it"
20:09:43 <lambdabot>   "zomg!"
20:10:03 <Olathe> Now we need concatTranspose.
20:10:20 <SamB> to save three characters ?
20:10:29 <Olathe> Well, we have concatMap :)
20:10:42 <SamB> concatMap is not actually concat.map
20:10:52 <Olathe> Ahh.
20:10:55 <Olathe> @src concatMap
20:10:55 <lambdabot> concatMap f = foldr ((++) . f) []
20:11:10 <Olathe> @src concat
20:11:10 <lambdabot> concat = foldr (++) []
20:11:11 <SamB> that's a strange way to define it!
20:11:29 <pumpkin> why?
20:11:33 <SamB> overly efficient, I mean
20:11:37 <pumpkin> ah
20:11:38 <SamB> not clear enough
20:11:40 <Olathe> Ahh, it has the fusion or whatever predone.
20:11:44 <SamB> yeah
20:12:06 <Olathe> foldr f a.map g = foldr (f.g) a
20:12:16 <rwbarton> @src should just lie and say concatMap f = concat . map f
20:12:16 <lambdabot> Source not found. My mind is going. I can feel it.
20:12:34 <Olathe> Does ghc do the fusion for that fine ?
20:12:53 <SamB> should
20:13:42 <SamB> but that's the same def as GHC uses ...
20:14:02 <Olathe> Ahh.
20:14:05 <BMeph> I.e., concatMap == (concat .). map :)
20:14:35 <rwbarton> @src lies about many things
20:14:35 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:14:37 <rwbarton> @src sort
20:14:38 <lambdabot> sort = sortBy compare
20:14:39 <rwbarton> @src sortBy
20:14:39 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:15:05 <Olathe> Is there a tool to take something like g = map f -> g [] = []; g (x:xs) = f x:g xs ?
20:15:22 <SamB> whoa what's foldr2
20:15:32 <Olathe> But for fun things like g = foldr (++) [].map zomg
20:15:39 <Olathe> @src foldr2
20:15:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:15:50 <Saizan_> concatMap f = foldr ((++) . f) [] can be instructive if you're learning about foldr
20:19:02 <mauke> rwbarton: you can post a link (or the patch itself), sure. it's essentially untested, though. I extracted it after tweaking various things to beat ghc into submission
20:19:34 <rwbarton> mauke: Tested by me :)
20:19:52 <rwbarton> mauke: OK, thanks
20:29:19 <chessguy> i'm sure there's a more idiomatic way to do this, but i'm not sure what it is. any thoughts? http://hpaste.org/13749
20:30:14 <chessguy> the issue is there's sort of two separate states, the state of the world and the state of the agent
20:30:59 <kpreid> chessguy: first of all, split off that Int argument and use something separate for repeated application
20:31:10 <CakeProphet> > foldl (:) [] (replicate 5 [1..5])
20:31:11 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
20:31:11 <lambdabot>        Expect...
20:31:44 <CakeProphet> > foldl (flip :) [] (replicate 5 [1..5])
20:31:45 <lambdabot>   Couldn't match expected type `b
20:32:02 <kpreid> chessguy: ...oh, I see
20:32:14 <Olathe> > replicate 5 [1..5]
20:32:15 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5]]
20:32:23 <Olathe> Wait...
20:32:27 <Olathe> > flip :
20:32:28 <lambdabot>   <no location info>: parse error on input `;'
20:32:35 <Olathe> > (flip :)
20:32:36 <lambdabot>       Overlapping instances for Show
20:32:36 <lambdabot>                                  ([(a ->...
20:32:41 <kpreid> chessguy: you discard the agent at the end...
20:32:42 <Olathe> @type (flip :)
20:32:43 <lambdabot> forall a b c. [(a -> b -> c) -> b -> a -> c] -> [(a -> b -> c) -> b -> a -> c]
20:32:51 <Olathe> @type (:)
20:32:52 <chessguy> kpreid:  yes
20:32:52 <lambdabot> forall a. a -> [a] -> [a]
20:32:59 <CakeProphet> > foldl (flip (:)) [] (replicate 5 [1..5])
20:33:00 <Olathe> What the heck ?
20:33:01 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5]]
20:33:02 <kpreid> chessguy: I would definitely look at splitting that up into something you can just repeatedly apply
20:33:04 <Olathe> @type (flip (:))
20:33:06 <lambdabot> forall a. [a] -> a -> [a]
20:33:11 <kpreid> then *separately* discard the agent at the end
20:33:16 <Olathe> @unpl (flip :)
20:33:16 <lambdabot> (\ d -> (\ a b c -> a c b) : d)
20:33:22 <Olathe> What ?
20:33:27 <kpreid> maybe put the world in a state monad, or not, depending on what the rest of the code looks like
20:33:38 <mauke> Olathe: ( )
20:33:43 <CakeProphet> @pl f a b = map sum $ transpose [a,b]
20:33:43 <lambdabot> f = ((map sum . transpose) .) . (. return) . (:)
20:33:51 <Olathe> @unpl (+ :)
20:33:52 <lambdabot>  Parse error at ":)" (column 4)
20:33:55 <Olathe> @unpl ((+) :)
20:33:55 <chessguy> kpreid:  that is the code, really
20:33:55 <lambdabot> (\ a -> (+) : a)
20:34:06 <Olathe> Oh.
20:34:36 <CakeProphet> let  f a b = map sum $ transpose [a,b]  in f [a,b,c] [a,b,c]
20:34:40 <chessguy> kpreid: i'm not sure if the world and agent belong in separate state monads, or if i should only put the world in one or what
20:34:43 <CakeProphet> > let  f a b = map sum $ transpose [a,b]  in f [a,b,c] [a,b,c]
20:34:45 <lambdabot>   [0 + a + a,0 + b + b,0 + c + c]
20:35:05 <Olathe> I wish they'd reduce it a bit algebraically.
20:35:06 <Saizan_> chessguy: you could write it as a composition of functions (Agent.Percept,World) -> (Agent,Percept,World), which will be actually the same function replicated n times
20:35:12 <CakeProphet> Olathe: yes.
20:35:46 <chessguy> Saizan_:  true, assuming that first "." is a ","
20:35:50 <Olathe> At the very least, assume (0+) or (+0) is id.
20:35:55 <CakeProphet> I suppose you can't assume a b and c are integers though
20:35:55 <Saizan_> chessguy: yeah
20:35:57 <CakeProphet> ...but
20:36:04 <CakeProphet> I don't know what else they'd be in this context
20:36:07 <CakeProphet> other than type errors.
20:36:07 <Saizan_> chessguy: it's the Endo Monoid, btw
20:36:18 <chessguy> Saizan_:  say what?
20:36:20 <Olathe> Well, you could at least do a basic ring.
20:36:25 <Saizan_> @src Endo
20:36:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:36:28 <chessguy> @src Monoid
20:36:28 <lambdabot> class Monoid a where
20:36:28 <lambdabot>     mempty  :: a
20:36:28 <lambdabot>     mappend :: a -> a -> a
20:36:28 <lambdabot>     mconcat :: [a] -> a
20:36:31 <chessguy> that monoid?
20:36:37 <Saizan_> that class yes
20:36:53 <Saizan_> with the data Endo a = Endo (a -> a) instance
20:36:55 <chessguy> yeah, ok
20:37:22 <chessguy> err...
20:37:33 <chessguy> Endo a is an instance of Monoid?
20:37:38 <Saizan_> yes
20:38:06 <chessguy> so i would just use Endo (Agent, Percept, World)?
20:38:14 <Saizan_> yeah
20:38:22 <chessguy> @hoogle Endo
20:38:22 <lambdabot> Data.Monoid newtype Endo a
20:38:22 <lambdabot> Data.Monoid Endo :: a -> a -> Endo a
20:38:22 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
20:38:53 <Saizan_> the annoying part is to deal with the tupling
20:38:54 <rwbarton> that's Endo :: (a -> a) -> Endo a
20:39:11 <chessguy> Saizan_:  well, of course i can use a record
20:39:25 <Saizan_> true
20:39:42 <Olathe> You know, that's weird.
20:39:51 <chessguy> i don't really understand what Endo gets me though
20:40:14 <Olathe> Haskell has all these advanced mathematical structures, but its numeric classes and types are completely weird and nonstandard.
20:40:33 <crutcher> Is there a ghci or hoogle search which will tell me about all known instances of a given class?
20:40:44 <Saizan_> runAgent n = world . appEndo . mconcat . replicate n $ function
20:41:02 <crutcher> Olathe: they are very standard, the standard is Haskell 98
20:41:05 <Saizan_> more or less..
20:41:13 <Olathe> I mean mathematically standard.
20:41:28 <crutcher> Who is the mathematical standard body?
20:41:35 <chessguy> Saizan_:  err, what is function?
20:41:39 <Olathe> Not that sort of standard.
20:41:47 <Olathe> I mean standard as in the usual.
20:42:14 <Olathe> Like naturals, integers, rationals, reals, complexes.
20:42:16 <SamB_XP> why, they aren't even non-standard numeric structures!
20:42:21 <Saizan_> chessguy: function is essentially what's in your where clause
20:42:34 <crutcher> Please describe the common number classes seen in 'standard usage' accross programming languages, and how Haskell fails to meet them
20:42:48 <SamB_XP> crutcher: not programming languages
20:42:53 <Olathe> I'm sorry, but I'm not getting the impression you're trying to help.
20:42:54 <SamB_XP> crutcher: plus, he's not trolling
20:43:00 <Saizan_> chessguy: but i may be "optimizing" the wrong side here :)
20:43:21 <chessguy> Saizan_:  that's ok, it's interesting
20:43:31 <crutcher> SamB_XP: I know, but I'm trying a bit of socratic method
20:43:43 <SamB_XP> crutcher: try to ask better questions then
20:43:49 <rwbarton> crutcher: Olathe means abelian group, ring, field, etc. of course
20:43:58 <Olathe> That would be fine for classes, I think.
20:44:02 <crutcher> SamB_XP: I didn't say I was good at it :)
20:44:23 <crutcher> Olathe:
20:44:26 <rwbarton> It doesn't work when you don't know for sure that the other person doesn't know the thing you're trying to get across :)
20:44:51 <Saizan_> chessguy: Endo a is isomorphic to State a ()
20:44:58 <Olathe> For classes, those. For built-in types, integer, rational, and so on.
20:45:05 <chessguy> Saizan_:  oh!
20:45:29 <Saizan_> where mappend = (>>), and mempty = return ()
20:45:41 <erikc> Olathe: Data.Word and Data.Int have the types you're looking for, (Word8, Word16, Word32, Word64, Int16, etc), Data.Bits has the bitwise operations you'd expose for those
20:45:44 <chessguy> Saizan_:  except it lets you get at the result at the end?
20:45:53 <erikc> s/expose/expect
20:45:57 <crutcher> Olathe: Well, its got integer, rational, and so on. It also has bounded types, because these are necessary when working with lots of real data and hardare
20:46:04 <Olathe> I don't mind if they include raw hardware types, too.
20:46:18 <crutcher> Well, then what are you unsatisfied with?
20:46:31 <Saizan_> chessguy: what do you mean by result?
20:46:42 <chessguy> Saizan_:  the World at the end
20:46:43 <crutcher> I'm not suggesting that there are no problems, but "not standard" is very vauge
20:46:48 <Olathe> Well, I made a polynomial interpolator.
20:47:05 <crutcher> Okay, and?
20:47:26 <rwbarton> chessguy: it is in the state
20:47:40 <Olathe> I have to make one version for Integral and one for Real.
20:47:56 <Saizan_> chessguy: well, Endo World will just give you World, while State World (), will give you (World,()), it's not that different
20:47:57 <Olathe> Since it divides.
20:48:12 <Olathe> So, I have to turn Integral a into Rational.
20:48:12 <chessguy> yeah, ok
20:48:20 <Olathe> And I leave Real a as Real a.
20:48:25 <Olathe> Or whatever it is.
20:48:29 <Olathe> I think it's Fractional.
20:48:43 <Olathe> @type lagrange
20:48:45 <lambdabot> forall b. (Fractional b) => [b] -> [b]
20:48:50 <Olathe> Yeah, Fractional.
20:48:55 <Olathe> @type iLagrange
20:48:56 <lambdabot> forall a. (Integral a) => [a] -> [Ratio Integer]
20:49:05 <crutcher> Olathe: I can understand why that may suck, but I have to wonder about the wisdom of building an interpolator that works on integers. Couldn't you do the conversion after the fact?
20:49:12 <rwbarton> Olathe: Huh?  Why not iLagrange = lagrange . map fromIntegral
20:49:21 <Olathe> rwbarton: That's pretty much it.
20:49:29 <Olathe> iLagrange ys = lagrange.map ((%1).toInteger) $ ys
20:49:43 <rwbarton> @type lagrange . map fromIntegral
20:49:43 <Olathe> Since I need to divide, I have to convert to Rational.
20:49:44 <lambdabot> forall a b. (Integral a, Fractional b) => [a] -> [b]
20:50:06 <rwbarton> > lagrange . map fromIntegral ([1,3,6] :: [Integer])
20:50:08 <lambdabot>   Couldn't match expected type `a -> [b]'
20:50:12 <rwbarton> > lagrange . map fromIntegral $ ([1,3,6] :: [Integer])
20:50:13 <lambdabot>   [1.0,1.5,0.5]
20:50:23 <Olathe> Oh, sure.
20:50:30 <Olathe> I don't like that you need that, though.
20:51:19 <Olathe> But that's just a practical problem
20:52:09 <Olathe> I wish (3::Integer)/(2::Integer) gave 3%2, for instance.
20:52:35 <Olathe> And sqrt (3%2) gave a nice CReal or something.
20:52:52 <CakeProphet> @src (%)
20:52:53 <lambdabot> x % y = reduce (x * signum y) (abs y)
20:53:11 <rwbarton> It's hard to say whether you'd have to introduce more type signatures as a result of that than you'd eliminate occurrences of fromIntegral and so on
20:53:21 <CakeProphet> @src reduce
20:53:21 <lambdabot> reduce _ 0 = undefined
20:53:21 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
20:53:21 <lambdabot>     where d = gcd x y
20:54:10 <CakeProphet> :t reduce
20:54:12 <lambdabot> Expr -> Expr
20:54:13 <Olathe> I wish there was something like data StandardNumber = Integer Integer | Rational Rational | Real CReal
20:54:33 <CakeProphet> ...isn't % supposed to make ratios or something?
20:54:36 <Olathe> Yes.
20:54:43 <Olathe> @type 3%2
20:54:45 <lambdabot> forall t. (Integral t) => Ratio t
20:54:47 <chessguy> @pl \x -> f x . g x . h x
20:54:48 <lambdabot> liftM2 (.) f (liftM2 (.) g h)
20:55:40 * ksf wonders whether that stuttering in http://hpaste.org/13746#a3 is caused by TimeT being Double but doesn't really feel like hacking reactive to use an exact number type, right now.
20:58:25 <CakeProphet> it seems like you could just have a Real or Number type that can be arbitrarily large. It shouldn't be too hard for the compiler to expand the amount of memory used as it grows larger.
20:58:38 <Olathe> Sure.
21:00:18 <SamB_XP> CakeProphet: Real is a bit tricky ...
21:00:32 <SamB_XP> since, you know, equality of reals is undecidable
21:00:53 <CakeProphet> ...wat?
21:00:53 <Olathe> Yeah.
21:01:13 <Olathe> I suppose I sort of want Mathematica's number handling with Haskell's programming style.
21:01:18 <SamB_XP> man I wish they'd teach this in school ...
21:01:40 <ksf> I learned that we should just compare them using an epsilon.
21:01:55 <Olathe> For instance, it should know that (sqrt 2)^2 is exactly 2.
21:02:00 <ksf> ...which seriously breaks if scales don't match up.
21:02:07 <ksf> change, that is.
21:02:34 <CakeProphet> SamB_XP:  can you point to something that explains what you're talking about?
21:02:38 <SamB_XP> ksf: for actual real numbers, or floating point values ?
21:02:54 <SamB_XP> CakeProphet: well, try comparing pi with pi some time
21:02:54 <Saizan_> > sqrt 2 ^ 2 :: CReal
21:02:56 <lambdabot>   2.0
21:02:59 <SamB_XP> you'll never see the end of it!
21:03:17 <SamB_XP> there's always more digits
21:03:32 <ksf> real numbers are an illusion, created by formalistic math.
21:03:49 <SamB_XP> ksf: does that include pi ?
21:04:00 <ksf> sure.
21:04:07 <Olathe> pi was created separately by Satan.
21:04:29 <CakeProphet> SamB_XP:  Sure, but we can't represent irrational numbers on computers anyways. You /can/ compare an approximation of pi with an approximation of pi.
21:04:31 <SamB_XP> wait, what do you mean illusion
21:04:45 <SamB_XP> CakeProphet: oh, when we talk about reals, we mean it
21:04:54 <intoverflow> CakeProphet: there are some irrationals we can represent computationally
21:05:02 <SamB_XP> (of course, not those uncomputable reals ... )
21:05:08 <ksf> just think about arranging coins in a circle... how many do you have to arrange to come up with pi?
21:05:09 <intoverflow> it really depends on "represent"
21:05:23 <SamB_XP> ksf: that's not how you get pi
21:05:37 <ksf> my point.
21:05:51 <CakeProphet> -shrug- I don't mean the mathematical real. I just mean a data type that can grow infinite large, infinitely small, and expand internally as needed.
21:05:59 <CakeProphet> *infinitely
21:06:08 <Olathe> I think CReal does that.
21:06:22 <Olathe> But it lacks precision.
21:06:31 <CakeProphet> what does the C mean?
21:06:34 <Olathe> I mean, it lacks decidable precision.
21:06:35 <CakeProphet> C the language?  :/
21:06:36 <ksf> computable.
21:06:38 <Olathe> No.
21:06:39 <CakeProphet> oh
21:06:42 <Olathe> It's pure Haskell, I think.
21:07:08 <CakeProphet> > maxBound :: CReal
21:07:09 <lambdabot>       No instance for (Bounded CReal)
21:07:09 <lambdabot>        arising from a use of `maxBound'...
21:07:13 <CakeProphet> oh ho
21:07:28 <ksf> I'd like a fixpoint type for reactive, whith both sides being Integers.
21:07:29 <Olathe> > (1.0/0.0)
21:07:30 <lambdabot>   Infinity
21:07:40 <Olathe> > floor (1.0/0.0)
21:07:41 <CakeProphet> ...lolwat
21:07:42 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
21:07:54 <SamB_XP> ksf: just one ?
21:07:55 <CakeProphet> 1.0/0.0 isn't anything.
21:08:05 <Olathe> In Floats, it's Infinity.
21:08:14 <Olathe> In C too, I think.
21:08:16 <ksf> why would I want more than one?
21:08:26 <CakeProphet> Olathe:  I've never heard of that
21:08:32 <ksf> it's IEEE
21:08:34 <SamB_XP> ksf: well, wouldn't they come in various precisions ?
21:08:38 <Olathe> But you can see that Haskell can calculate the maximum Integer.
21:08:58 <Olathe> There's nothing higher than infinity, and lambdabot just gave us the value for it.
21:08:59 <SamB_XP> lol @ Olathe
21:09:23 <ksf> hmmm...
21:09:23 <CakeProphet> :t floor
21:09:24 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
21:09:29 <ksf> the part after the decimal point.
21:09:34 <CakeProphet> :t 1.0/0.0
21:09:35 <lambdabot> forall t. (Fractional t) => t
21:09:41 <SamB_XP> @remember Olathe <Olathe> > floor (1.0/0.0) <lambdabot> 179769... <Olathe> But you can see that Haskell can calculate the maximum Integer.
21:09:41 <lambdabot> Okay.
21:09:50 <SamB_XP> @quote Olathe
21:09:50 <lambdabot> Olathe says: 11 PM is a poison that sneaks up on you and then kills you tomorrow.
21:09:52 <SamB_XP> @quote Olathe
21:09:52 <lambdabot> Olathe says: it should suffice to just say that Oleg is the Chuck Norris of Haskell.
21:09:53 <SamB_XP> @quote Olathe
21:09:53 <lambdabot> Olathe says: We can't be totally sure, though. There might be some value of 1 that wasn't checked.
21:09:54 <SamB_XP> @quote Olathe
21:09:55 <lambdabot> Olathe says: You can never tell if a lazy person has been executed yet.
21:09:59 <SamB_XP> @quote Olathe highest
21:10:00 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
21:10:05 <SamB_XP> @quote highest
21:10:05 <lambdabot> No quotes match. My pet ferret can type better than you!
21:10:10 <Olathe> Ehh ?
21:10:14 <SamB_XP> @quote maximum
21:10:14 <lambdabot> Olathe says: <Olathe> > floor (1.0/0.0) <lambdabot> 179769... <Olathe> But you can see that Haskell can calculate the maximum Integer.
21:10:18 <Olathe> I don't remember saying that about Oleg.
21:10:38 <SamB_XP> Olathe: maybe you just forgot
21:10:43 <Olathe> Maybe.
21:10:45 <CakeProphet> > maxBound ::Integer
21:10:46 <lambdabot>       No instance for (Bounded Integer)
21:10:46 <lambdabot>        arising from a use of `maxBoun...
21:10:48 <SamB_XP> I've said plenty of stuff I don't remember saying
21:10:56 <CakeProphet> why does floor(1.0/0.0) do that?
21:11:45 <Olathe> CakeProphet: Float has a nice binary representation.
21:12:02 <Olathe> CakeProphet: They set aside some of the values for Infinity and NaN and so on, though.
21:12:11 <Olathe> CakeProphet: But floor doesn't treat those value specially.
21:12:18 <SamB_XP> Olathe: is that all ?
21:12:34 <ksf> anyway, pico- or say attosecond resolution should be more than sufficient.
21:12:35 <CakeProphet> Olathe:  that's silly...
21:12:39 <Olathe> In-band signalling bugs.
21:13:01 <Olathe> SamB_XP: I think there's +0.0 and -0.0
21:13:02 <SamB_XP> Olathe: doesn't that make that expression have multiple possible values for one IEEE type ?
21:13:09 <Olathe> And there are several NaNs or something.
21:13:23 <Olathe> SamB_XP: What do you mean ?
21:13:26 <SamB_XP> oh, was it the NaN there were a lot of ?
21:13:26 <ksf> ...considering that there's a maximum time resolution built into every computer.
21:13:28 <CakeProphet> I naturally distrust any standard that makes 1.0/0.0 equal to infinity.
21:13:30 <SamB_XP> I guess that's it
21:13:52 <ksf> > (1.0/(-0.0))
21:13:53 <lambdabot>   -Infinity
21:13:56 <ksf> see?
21:13:58 <Olathe> They didn't want a hardware exception or something like that.
21:14:01 <ksf> it's just the limit.
21:14:01 <SamB_XP> ksf: yeah, it always bugged me that VB used floating point for time ...
21:14:08 <Olathe> Negative zero is great !
21:14:16 <Olathe> > -0.0
21:14:18 <lambdabot>   -0.0
21:14:30 <Olathe> > +0.0
21:14:32 <lambdabot>   <no location info>: parse error on input `+'
21:14:35 <ksf> in IEEE, there's no true 0 but only +-0.
21:14:42 <Olathe> > negate $ -0.0
21:14:43 <lambdabot>   0.0
21:14:45 <CakeProphet> now then the question
21:14:50 <Saizan_> > floor (0/0)
21:14:52 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
21:14:57 <CakeProphet> is how to make a computation that yield -0.0
21:14:57 <Olathe> I think there's -0.0, 0.0, and +0.0
21:15:02 <CakeProphet> (negate 0.0 is cheating)
21:15:11 <Saizan_> good, now we also know the value of nullity
21:15:17 <Olathe> Saizan_: Haha
21:15:21 <SamB_XP> Olathe: oh come on
21:15:24 <SamB_XP> that's just silly
21:15:27 <CakeProphet> > 0/0
21:15:29 <lambdabot>   NaN
21:15:35 <Olathe> They did it for exact zero, and inexact zero, I think.
21:15:53 <Olathe> Not quite sure exactly.
21:16:10 <CakeProphet> ...why on earth doesn't Haskell get rid of such ridiculousness...
21:16:18 <Olathe> Apparently, Google takes more than 10 seconds to load.
21:16:34 <SamB_XP> Olathe: why? did they just reboot ?
21:16:42 <Saizan_> CakeProphet: it's not really haskell here, it's the CPU manufacturers
21:17:06 <Olathe> http://steve.hollasch.net/cgindex/coding/ieeefloat.html
21:17:12 <Olathe> No, my connection slows sometimes.
21:17:21 <Olathe> And dies for several hours every few months.
21:17:31 <CakeProphet> Saizan_:  Right. But then why doesn't Haskell abstract over the binary representations of floats?
21:17:43 <SamB_XP> you can't just abstract over it
21:18:26 <Olathe> And then when they transfer me from customer service to technical support and I'm on hold and I don't bother to rate the interaction with the representative by pressing 1-4, they hang up on me automatically.
21:18:32 <Olathe> It's a lovely system.
21:18:43 <Olathe> Ahh, here it is.
21:18:43 <Olathe> http://steve.hollasch.net/cgindex/coding/ieeefloat.html
21:18:51 <Saizan_> that implementation of floor is a bit silly though, an exception on floor NaN seems appropriate
21:18:53 <SamB_XP> @check \(x :: Int) -> x /= -x
21:18:53 <lambdabot>   Parse error in pattern at "->" (column 13)
21:19:09 <Olathe> Looks like +0, -0, Inf, -Inf, QNaN, SNaN
21:19:12 <SamB_XP> @check \x -> (x :: Int) /= -x
21:19:13 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
21:19:32 <SamB_XP> @check \x -> (x :: Int) /= 0 ==> x /= -x
21:19:33 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
21:19:33 <lambdabot>           ...
21:19:51 <CakeProphet> Saizan_:  that's what I'm saying... what's stopping Haskell's (/) function from raising an exception when the second argument is 0.0?
21:19:53 <SamB_XP> @check \x -> ((x :: Int) /= 0) ==> (x /= -x)
21:19:54 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
21:19:54 <lambdabot>           ...
21:20:02 <Olathe> Let's see.
21:20:04 <SamB_XP> how are you supposed to do this ...
21:20:19 <Olathe> > floor x == ceiling x where x = 1.0/0.0
21:20:21 <lambdabot>   True
21:20:23 <Olathe> Ahh.
21:20:36 <Olathe> > fromIntegral (floor (1.0/0.0)) :: Float
21:20:37 <lambdabot>   Infinity
21:20:38 <CakeProphet> > NaN
21:20:39 <lambdabot>   Not in scope: data constructor `NaN'
21:20:41 <Olathe> Excellent !
21:20:45 <Saizan_> CakeProphet: the numerical analysis programmers who want the IEEE semantic
21:20:53 <Olathe> Let's change QNaN to SNaN.
21:21:38 <SamB_XP> CakeProphet: also that'd be a bit slow
21:21:38 <SamB_XP> and, uh, bottomy
21:21:55 <Olathe> > floor x == ceiling x where x = (0.0/0.0)
21:21:57 <lambdabot>   True
21:22:14 <rwbarton> so 0.0/0.0 is an integer?
21:22:22 <Olathe> > 0.0/0.0
21:22:22 <SamB_XP> lol
21:22:23 <lambdabot>   NaN
21:22:31 <SamB_XP> rwbarton: it's not even a number
21:22:33 <Olathe> rwbarton: Hahah, yes, of course.
21:23:38 <nejucomo> I can't seem to handle exceptions from read in ghci:
21:23:41 <nejucomo> Prelude Control.Exception> handle (\_ -> return 42) $ return (read "'c'" :: Int)
21:23:41 <nejucomo> *** Exception: Prelude.read: no parse
21:24:08 <nejucomo> What am I missing here?
21:24:09 <Saizan_> use return $! (read ...)
21:24:18 <ksf> well, don't use read for production input.
21:24:23 <CakeProphet> is the NaN only a product of show or is there also a NaN function somewhere in Haskell? (for example, if you wanted filter (/=NaN))
21:24:24 <Saizan_> or better, use reads
21:24:28 <Olathe> > toBin 0 = "0"; toBin x = f' "" x where f' bs 0 = bs; f' bs n = f' ((if even n then 0 else 1):bs) (div n 2) in toBin [0..5]
21:24:29 <lambdabot>   <no location info>: parse error on input `='
21:24:50 <Olathe> > let toBin 0 = "0"; toBin x = f' "" x where f' bs 0 = bs; f' bs n = f' ((if even n then 0 else 1):bs) (div n 2) in toBin [0..5]
21:24:51 <lambdabot>       No instance for (Num Char)
21:24:51 <lambdabot>        arising from a use of `f'' at <intera...
21:24:54 <ksf> there's a nan value in the fpu, that's for sure.
21:24:55 <nejucomo> Saizan_: Is there something about laziness that is confusing me?
21:25:04 <SamB_XP> nejucomo: yeah
21:25:06 <Saizan_> nejucomo: readM xs = case reads xs of [(a,rest)] | all isSpace rest -> Just a; _ -> Nothing
21:25:25 <Saizan_> nejucomo: yeah, you've to force the value for the exception to trigger inside the scope of handle
21:25:57 <nejucomo> Strange.  Would you ever want the form I have written, or would you always want strict evaluation with handle?
21:26:29 <Saizan_> it depends which exceptions you're trying to catch
21:26:48 <Saizan_> for exceptions originating from IO you don't need the strictness
21:27:05 <Saizan_> you need it only if you expect your pure code to throw them
21:27:18 <Saizan_> ah, there's also readIO
21:27:23 <Saizan_> ?hoogle readIO
21:27:23 <lambdabot> Prelude readIO :: Read a => String -> IO a
21:27:23 <lambdabot> System.IO readIO :: Read a => String -> IO a
21:27:23 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
21:27:48 <Saizan_> which throws the exception as an IO one
21:28:14 <nejucomo> Hm.  I don't understand why IO exceptions behave differently than other kinds.
21:28:42 <Saizan_> because the sequencing of effects of the IO-monad makes them predictable
21:28:56 <nejucomo> I see.
21:29:38 <Saizan_> if you have an IO action m, you can be sure that all the IO-exceptions originating from it will be thrown before its execution has terminated
21:29:55 <nejucomo> Anyway, I'm writing a Parsec parser, so I shouldn't be using "read" in the first place.  I want to parse a float literal into a float value.
21:30:03 <Saizan_> while for the ones coming from pure code you're at the mercy of lazy eval
21:30:13 <nejucomo> Is there a simpler way to do this without Text.ParserGenerator.Parsec.Language ?
21:30:32 <jml> "Mercy? You want mercy? I'm Chaotic Neutral!"
21:31:33 <nejucomo> Sorry, I meant Parsec.Token.
21:31:40 <ksf> "I am <rolls dice...> very pleased to meet you!"
21:32:00 <Olathe> > (floor (0.0/0.0)) == -2^1024 - 2^1023
21:32:01 <lambdabot>   True
21:32:33 <Saizan_> nejucomo: it doesn't look like so
21:32:37 <Olathe> > fromIntegral (-2^1024 - 2^1022) :: Float
21:32:39 <lambdabot>   -Infinity
21:32:39 <nejucomo> The interface to Parsec.Token.float bothers me for two reasons:  I have to define a language def and float parses whitespace which I don't want.
21:32:47 <crutcher> meh. has anyone else noticed how truly awful the haddoc docs for Regex are?
21:32:58 * ksf would like to have sanity in fieldtrip's coordinate system
21:33:03 <Saizan_> nejucomo: i'd collect the digits and pass them to reads
21:33:04 <Olathe> > fromIntegral (-2^1024 - 2^1023 - 2^1022) :: Float
21:33:05 <lambdabot>   -Infinity
21:33:06 <CakeProphet> > (-0) / (-0)
21:33:08 <lambdabot>   NaN
21:33:27 <Olathe> Hmm, looks like it doesn't handle it right.
21:33:34 <Olathe> That should be NaN.
21:33:35 <nejucomo> Saizan_: I collected the digits and passed them to read...  Time to look up reads.
21:33:52 <Saizan_> ?type reads
21:33:53 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:33:54 <Olathe> > floor (-1.0/0.0) == -2^1024
21:33:55 <lambdabot>   True
21:34:07 <Olathe> That's the only value for Infinity in the spec.
21:34:13 <Olathe> -
21:34:26 <CakeProphet> > (1.0/0.0) + (1.0/0.0)
21:34:28 <lambdabot>   Infinity
21:34:44 <Saizan_> > let readM xs = case reads xs of [(a,rest)] | all isSpace rest -> Just a; _ -> Nothing in readM "12.4" :: Maybe Float
21:34:46 <lambdabot>   Just 12.4
21:34:51 <Saizan_> > let readM xs = case reads xs of [(a,rest)] | all isSpace rest -> Just a; _ -> Nothing in readM "foo" :: Maybe Float
21:34:53 <lambdabot>   Nothing
21:35:06 <CakeProphet> > 5 / (1.0/0.0)
21:35:07 <lambdabot>   0.0
21:35:20 <Olathe> > let QNaN = -2^1024 - 2^1023; SNaN = -2^1024 - 2^1022; NInf = -2^1024 in fromIntegral NInf :: Float
21:35:22 <lambdabot>   Not in scope: data constructor `QNaN'Not in scope: data constructor `SNaN'N...
21:35:32 <nejucomo> My documentation for read and reads looks quite similar, and neither mention exceptions.  Is it true that reads never raises an exception?
21:35:34 <Olathe> > let qNaN = -2^1024 - 2^1023; sNaN = -2^1024 - 2^1022; nInf = -2^1024 in fromIntegral nInf :: Float
21:35:35 <lambdabot>   -Infinity
21:35:41 <Olathe> > let qNaN = -2^1024 - 2^1023; sNaN = -2^1024 - 2^1022; nInf = -2^1024 in fromIntegral qNaN :: Float
21:35:42 <lambdabot>   -Infinity
21:36:02 <nejucomo> And what is with the [(a, b)] convention instead of Maybe (a, b)  ?
21:36:33 <Saizan_> nejucomo: String -> [(a,String)] is a primitive parser monad
21:37:00 <CakeProphet> @let Infinity = (1.0/0.0); NaN = (0/0)
21:37:00 <Saizan_> nejucomo: well, it's not actually an instance of monad, but it works like one
21:37:00 <lambdabot>  <local>:25:0: Not in scope: data constructor `Infinity'
21:37:00 <lambdabot>  
21:37:00 <lambdabot>  <local>:25:22: No...
21:37:11 <CakeProphet> @let infinity = (1.0/0.0); nan = (0/0)
21:37:13 <rwbarton> @unmtl StateT String [] a
21:37:14 <lambdabot>  Defined.
21:37:14 <lambdabot> String -> [(a, String)]
21:37:19 <ksf> > reads "1.0"
21:37:21 <lambdabot>   []
21:37:25 <nejucomo> Saizan_: But why isn't it:  String -> (a, String)
21:37:31 <CakeProphet> > -infinity
21:37:32 <lambdabot>       Ambiguous occurrence `infinity'
21:37:32 <lambdabot>      It could refer to either `L.infini...
21:37:34 <ksf> > reads "1.0" :: [(Float, String)]
21:37:36 <lambdabot>   [(1.0,"")]
21:37:36 <CakeProphet> ...
21:37:40 <Saizan_> nejucomo: it's a list because it allows ambiguous parser
21:37:45 <ksf> > reads "1.0 - 2" :: [(Float, String)]
21:37:46 <lambdabot>   [(1.0," - 2")]
21:37:50 <ksf> see?
21:37:51 <Saizan_> nejucomo: so, non-determinisc results
21:37:53 <CakeProphet> > nan
21:37:54 <lambdabot>   NaN
21:38:02 <ksf> > reads "1.0 2" :: [(Float, String)]
21:38:04 <lambdabot>   [(1.0," 2")]
21:38:21 <CakeProphet> @src reads
21:38:22 <lambdabot> reads = readsPrec minPrec
21:38:23 <CakeProphet> :3
21:38:34 <Saizan_> reads doesn't expose the ambiguity though, it's only used internally
21:38:45 <CakeProphet> @src readsPrec
21:38:45 <lambdabot> Source not found. You untyped fool!
21:38:47 * ksf is puzzled why it isn't a Maybe, too.
21:39:05 <nejucomo> Hm.  I'm not familiar with non-deterministic parsing.  Does that mean it might backtrack?
21:39:07 <SamB_XP> Saizan_: doesn't it ?
21:39:17 <ksf> or, even better (Maybe a, Maybe String)
21:39:20 <SamB_XP> nejucomo: yes! but I'm not sure if it ever does ...
21:39:24 <Olathe> > minimum nan 1.0
21:39:26 <lambdabot>       No instance for (Ord (t -> a))
21:39:26 <lambdabot>        arising from a use of `minimum' a...
21:39:35 <Olathe> > nan
21:39:37 <lambdabot>   NaN
21:39:38 <nejucomo> Thanks for all the help.
21:39:40 <Saizan_> SamB_XP: i've never found a case where it gives multiple results
21:39:43 <SamRH> > min nan 1.0
21:39:44 <Olathe> @type minimum
21:39:46 <lambdabot>   1.0
21:39:46 <lambdabot> forall a. (Ord a) => [a] -> a
21:39:50 <Olathe> > max nan 1.0
21:39:52 <lambdabot>   NaN
21:39:54 <Olathe> Bah.
21:40:04 <rwbarton> > nan > 1.0
21:40:05 <lambdabot>   False
21:40:07 <rwbarton> > nan < 1.0
21:40:09 <lambdabot>   False
21:40:10 <CakeProphet> ...rofl. what?
21:40:11 <rwbarton> > nan == 1.0
21:40:13 <lambdabot>   False
21:40:19 <Olathe> Heheh
21:40:25 <SamRH> > nan /= 1.0
21:40:27 <lambdabot>   True
21:40:30 <ksf> > nan == nan
21:40:32 <lambdabot>   False
21:40:39 <Saizan_> > compare nan nan
21:40:41 <lambdabot>   GT
21:40:42 <SamRH> > nan /= nan
21:40:42 <pumpkin> NaN isn't equal to anything
21:40:43 <Olathe> It should be max NaN x == max x NaN == x
21:40:44 <lambdabot>   True
21:40:51 <Olathe> Same with min.
21:40:54 <nejucomo> So I am guaranteed for reads to return either:  []  or  [(val, string)]
21:40:56 <Saizan_> NaN > NaN
21:41:03 <Olathe> > nan > nan
21:41:04 <lambdabot>   False
21:41:10 <Olathe> > nan > nan > nan
21:41:11 <lambdabot>       precedence parsing error
21:41:11 <lambdabot>          cannot mix `(>)' [infix 4] and `(>)' ...
21:41:13 <SamB_XP> nejucomo: I don't THINK so ...
21:41:24 <nejucomo> I wish the documentation spelled this out.
21:41:28 * ksf thinks so.
21:41:35 <CakeProphet> maximum [nan] ++ [1.0..100.0]
21:41:37 <rwbarton> nejucomo: Only for built-in and derived instances of Read
21:41:38 <SamRH> nejucomo: you can get lists with more options
21:41:40 <CakeProphet> > maximum [nan] ++ [1.0..100.0]
21:41:41 <lambdabot>       No instance for (Fractional [a])
21:41:42 <lambdabot>        arising from a use of `nan' at ...
21:41:52 <CakeProphet> oh rite
21:42:00 <CakeProphet> > maximum (nan:[1.0..100.0])
21:42:01 <lambdabot>   NaN
21:42:07 <SamB_XP> nejucomo: you can assume that when calculating performance, of course, but don't code as if it must be so ...
21:42:18 <Olathe> Float is the work of Satan.
21:42:22 <CakeProphet> I agree.
21:42:47 <nejucomo> Um.  So in what case would reads ever return more than one result?
21:43:11 <nejucomo> (Specifically I am parsing into a Float value...)
21:43:25 <SamB_XP> nejucomo: oh, I don't think you need to worry about it for Float
21:43:28 <Saizan_> for Float it won't
21:43:36 <CakeProphet> > type Float = Satan
21:43:37 <lambdabot>   <no location info>: parse error on input `type'
21:43:47 <nejucomo> I think I will *not* code the more than one value case and rely on pattern match failure as a failed assertion.
21:43:56 <Saizan_> but since reads uses readsPrec which is a method of Read, it really depends on the instance
21:43:59 <ksf> > reads "[1.0 2]" :: [([Float], String)]
21:44:00 <nejucomo> > reads "42" :: Float
21:44:01 <lambdabot>   []
21:44:02 <lambdabot>   Couldn't match expected type `Float'
21:44:15 <ksf> > reads "[1.0 2]" :: [(Float, String)]
21:44:17 <lambdabot>   []
21:44:20 <ksf> > reads "[1.0 2]" :: [([Float], String)]
21:44:20 <nejucomo> > reads "42.7" :: [(Float, String)]
21:44:22 <pumpkin> > reads "1.0 2 3" :: [([Float], String)]
21:44:22 <lambdabot>   [(42.7,"")]
21:44:23 <lambdabot>   []
21:44:24 <lambdabot>   []
21:44:30 <pumpkin> lol
21:44:31 <ksf> huh?
21:44:40 <SamB_XP> yeah really!
21:44:42 <Saizan_> ksf: you miss a comma
21:44:42 <nejucomo> > reads "42" :: [(Float, String)]
21:44:43 <SamB_XP> huh is right
21:44:44 <lambdabot>   [(42.0,"")]
21:44:45 <pumpkin> > reads "1.0 2 3" :: [(Float, String)]
21:44:47 <lambdabot>   [(1.0," 2 3")]
21:44:59 <ksf> > reads "[1.0, 2]" :: [([Float], String)]
21:45:01 <lambdabot>   [([1.0,2.0],"")]
21:45:06 <ksf> > reads "[1.0, 2]" :: [(Float, String)]
21:45:08 <lambdabot>   []
21:45:11 <Olathe> > reads "1.0 2 3" :: [(Float, Rational, Complex CReal)]
21:45:12 <lambdabot>   Couldn't match expected type `(Float, Rational, Complex CReal)'
21:45:21 <Olathe> > reads "1.0 2 3" :: [(Float, Rational, Complex Float)]
21:45:22 <lambdabot>   Couldn't match expected type `(Float, Rational, Complex Float)'
21:45:24 <nejucomo> > reads "banana" :: [(Float, String)]
21:45:25 <lambdabot>   []
21:45:45 <SamRH> > reads "(1.0,2,3)" :: [((Float, Rational, Complex Float), String)]
21:45:47 <lambdabot>   []
21:45:59 <SamRH> > reads "(1.0,2,3:+0)" :: [((Float, Rational, Complex Float), String)]
21:46:01 <lambdabot>   []
21:46:08 <SamRH> > reads "(1.0,2%1,3:+0)" :: [((Float, Rational, Complex Float), String)]
21:46:10 <lambdabot>   [((1.0,2%1,3.0 :+ 0.0),"")]
21:46:12 <Olathe> > read "3:+0"
21:46:13 <ksf> ouch
21:46:14 <lambdabot>   * Exception: Prelude.read: no parse
21:46:20 <pumpkin> this is a readfest
21:46:28 <Olathe> > read a book
21:46:29 <lambdabot>   Not in scope: `book'
21:46:35 <CakeProphet> :t reads
21:46:36 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:46:43 <Olathe> Ah hah !
21:46:46 <SamB_XP> it always bothers me how it complains about the last thing on the line first ...
21:46:58 <Saizan_> > a
21:47:00 <lambdabot>   a
21:47:11 <SamB_XP> > read some book
21:47:12 <Olathe> > reads "1.0 zomg 3 zomnotsog" :: [(Float, String)]
21:47:12 <lambdabot>   Not in scope: `book'
21:47:14 <lambdabot>   [(1.0," zomg 3 zomnotsog")]
21:47:23 <SamB_XP> Saizan_: my complaint stands!
21:47:28 <SamB_XP> > some
21:47:29 <lambdabot>       Overlapping instances for Show (f a -> f [a])
21:47:29 <lambdabot>        arising from a use...
21:47:30 <Olathe> Yes, I see the problem with [] instead of Maybe.
21:47:33 <SamB_XP> oh shit
21:47:44 <SamRH> haha
21:47:44 <SamB_XP> > read the book
21:47:45 <lambdabot>   Not in scope: `the'Not in scope: `book'
21:47:47 <ksf> :t listToMaybe
21:47:49 <lambdabot> forall a. [a] -> Maybe a
21:47:56 <SamB_XP> okay, it doesn't complain last-to-first
21:48:00 <Olathe> @type some
21:48:01 <SamB_XP> at least not here
21:48:01 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
21:48:08 <Olathe> @src sume
21:48:09 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:48:09 <ksf> @src listToMaybe
21:48:09 <lambdabot> listToMaybe []        =  Nothing
21:48:09 <lambdabot> listToMaybe (a:_)     =  Just a
21:48:15 <Olathe> @instances Alternative
21:48:16 <pumpkin> what's an Alternative?
21:48:16 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
21:48:26 <Olathe> @instances-importing is a lie !
21:48:27 <lambdabot> Couldn't find class `!'. Try @instances-importing
21:48:27 <pumpkin> @hoogle Alternative
21:48:28 <lambdabot> Control.Applicative class Applicative f => Alternative f
21:48:28 <lambdabot> Language.Haskell.ParseMonad alternative :: Lex a v -> Lex a (Lex a v)
21:48:31 <SamB_XP> > some "Hi!"
21:48:32 <lambdabot>   * Exception: stack overflow
21:48:34 <pumpkin> ah
21:48:41 <Saizan_> pumpkin: like MonadPlus but for Applicative
21:48:42 <nejucomo> What's the problem with a list instead of Maybe?
21:48:44 <SamB_XP> > some (Just 'I')
21:48:46 <lambdabot>   * Exception: stack overflow
21:48:47 <Olathe> @instances-importing tell me to try what I'm trying now, please
21:48:47 <lambdabot> Couldn't find class `please'. Try @instances-importing
21:48:50 <CakeProphet> reads "lolwhut" :: (Read a) => String -> [(a, String)]
21:48:52 <CakeProphet> :3
21:48:53 <pumpkin> Saizan_: interesting... haven't ever seen anyone use it
21:48:53 <SamB_XP> ... okay
21:48:59 <SamB_XP> some looks REALLY useful, doesn't it ?
21:49:08 <Olathe> > some what
21:49:09 <lambdabot>   Not in scope: `what'
21:49:25 <SamB_XP> > some a
21:49:27 <lambdabot>   Couldn't match expected type `f a' against inferred type `Expr'
21:49:42 <Olathe> > some (Lex a)
21:49:43 <lambdabot>   Not in scope: data constructor `Lex'
21:49:48 <Saizan_> that's this rumor that some is useful for parsers.
21:49:50 <Olathe> @hoogle Lex
21:49:51 <lambdabot> module Text.Read.Lex
21:49:51 <lambdabot> Language.Haskell.ParseMonad data Lex r a
21:49:51 <lambdabot> Prelude lex :: ReadS String
21:49:54 <Saizan_> *there
21:49:59 <SamB_XP> @instances Alternative
21:49:59 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
21:50:12 <SamB_XP> @instances-importing Control.Applicative Alternative
21:50:13 <lambdabot> Maybe, WrappedMonad m, []
21:50:17 <Olathe> @type alternative
21:50:18 <lambdabot> Not in scope: `alternative'
21:50:58 <CakeProphet> > some > none
21:51:00 <lambdabot>   Not in scope: `none'
21:52:12 <CakeProphet> > less == more
21:52:13 <lambdabot>   Not in scope: `less'Not in scope: `more'
21:53:15 <Olathe> > sleep
21:53:16 <lambdabot>   Not in scope: `sleep'
21:53:52 <CakeProphet> hmmm...
21:53:56 <CakeProphet> is there a sleep in Haskell?
21:54:19 <CakeProphet> to make the program pause for x number of microseconds or whatever.
21:54:34 <CakeProphet> I'm not sure how it would make sense.
21:55:04 <CakeProphet> > time
21:55:05 <lambdabot>   Not in scope: `time'
21:55:06 <ksf> I bet you can find one in the IO monad.
21:55:20 <CakeProphet> "in" it?
21:55:42 <pumpkin> you gotta look deep within
21:55:52 <rwbarton> @type threadDelay
21:55:53 <lambdabot> Not in scope: `threadDelay'
21:55:56 <pumpkin> RealWorld is pretty big
21:55:57 <rwbarton> @hoogle threadDelay
21:55:57 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
21:56:53 <CakeProphet> is it lazy?
21:57:19 <ksf> @hoogle sleep
21:57:19 <CakeProphet> I suppose it wouldn't matter... it would most likely happen right when you'd need it.
21:57:19 <lambdabot> No results found
21:57:23 <ksf> hmmm....
21:57:28 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Unistd.html#v%3Ananosleep
21:59:17 <CakeProphet> :t (do {printStrLn "lol"; printStr "lol"})
21:59:19 <lambdabot> Not in scope: `printStrLn'
21:59:19 <lambdabot> Not in scope: `printStr'
21:59:33 <pumpkin> putStrLn ?
21:59:34 <CakeProphet> :t (do {putStrLn "lol"; putStr "lol"})
21:59:36 <lambdabot> IO ()
21:59:36 <CakeProphet> yeah
21:59:53 <CakeProphet> I was just wondering how do combines monads
21:59:59 <dlurf> ksf: that's not portable, better to use threadDelay
22:00:08 <mmorrow> , let untilST p f x = mdo {k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref} in runST (untilST (> 200000) (*3) 1.003)
22:00:10 <lunabot>  533035.3229999999
22:00:21 <mmorrow> , unsafeIOToST
22:00:23 <lunabot>  luna: Not in scope: `unsafeIOToST'
22:00:24 <chessguy> CakeProphet:  do { foo; bar } === foo >> bar
22:00:49 <chessguy> CakeProphet:  do { x <- foo; bar x } === foo >>= bar
22:01:04 <chessguy> not sure if that's what you're asking
22:01:10 <CakeProphet> not really.
22:01:32 <CakeProphet> I suppose using recursion in a do makes sense with those semantics. So yes, that helped.
22:01:40 <mmorrow> , runST (do x <- newSTRef 99; writeSTRef x 88888 >> readSTRef x)
22:01:42 <lunabot>  88888
22:01:51 <CakeProphet> :t >>
22:01:52 <lambdabot> parse error on input `>>'
22:01:59 <chessguy> :t (>>)
22:01:59 <CakeProphet> :t (>>)
22:02:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
22:02:00 <mmorrow> , runST (do x <- newSTRef 99; writeSTRef x 88888; readSTRef x)
22:02:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
22:02:03 <pumpkin> why do and >>?
22:02:03 <lunabot>  88888
22:02:08 <pumpkin> ah ok
22:02:11 <mmorrow> no reason really
22:02:23 <rubber> is there a map reduce for haskell that is nicer than hadoop
22:02:36 <CakeProphet> I haven't learned what >> is.
22:02:43 <chessguy> @src Monad
22:02:43 <lambdabot> class  Monad m  where
22:02:43 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
22:02:43 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
22:02:43 <lambdabot>     return      :: a -> m a
22:02:43 <lambdabot>     fail        :: String -> m a
22:02:44 <pumpkin> CakeProphet: it's ; in a do statement :P
22:02:54 <pumpkin> expression, I guess
22:02:58 <Olathe> > fail
22:03:00 <lambdabot>       Overlapping instances for Show (String -> m a)
22:03:00 <lambdabot>        arising from a us...
22:03:03 <mmorrow> , runST (newSTRef 99 >>= \x -> writeSTRef x 8 >> readSTRef x)
22:03:05 <lunabot>  8
22:03:07 <Olathe> > fail "zomg" :: [Int]
22:03:08 <lambdabot>   []
22:03:15 <Heffalump> where did lambdabot get overlapping instances from?
22:03:20 <mmorrow> , runST (do x <- newSTRef 99; writeSTRef x 8; readSTRef x)
22:03:22 <lunabot>  8
22:03:32 <rwbarton> , runST fail
22:03:33 <lunabot>  luna: Couldn't match expected type `GHC.ST.ST s a'
22:03:41 <rwbarton> , runST (fail "blah")
22:03:43 <lunabot>  luna: blah
22:03:49 <CakeProphet> pumpkin:  right but... what does ; in a do statement... do?
22:03:57 <CakeProphet> I guess that was my original question, how it combines them
22:04:01 <pumpkin> just "moves on"
22:04:02 <rwbarton> CakeProphet: it's the same as layout
22:04:04 <Olathe> , runST (fail "zomg\nzomg")
22:04:05 <pumpkin> does the next thing
22:04:06 <lunabot>  luna: zomg
22:04:10 <Heffalump> CakeProphet: there's a desugaring defined in the report
22:04:25 <Heffalump> but ; is just a separator that you can also get from layout, as rwbarton ssays
22:04:32 <CakeProphet> layout?
22:04:37 <rwbarton> do foo
22:04:38 <rwbarton>    bar
22:04:43 <Heffalump> putting things on separate lines with the right indentation
22:04:49 <rwbarton> is the same as do { foo; bar } which desugars to foo >> bar
22:04:58 <CakeProphet> .....but /how/ does it semantically combine them
22:05:00 <CakeProphet> I know all the sugar.
22:05:07 <rwbarton> , src '(>>)
22:05:12 <lunabot>  Class op from Monad: (>>) :: forall m . Monad m => forall a b . (m a) ->
22:05:12 <lunabot>                                                                  (m b) -> m b
22:05:12 <lunabot>                       infixl 1 (>>)
22:05:14 <Olathe> @undo do { a <- x; y <- x; z <- x }
22:05:14 <lambdabot>  Parse error at "}" (column 29)
22:05:16 <mmorrow> ugh
22:05:18 <Heffalump> CakeProphet: that depends on the >> for a specific monad
22:05:24 <pumpkin> @undo do x <- newSTRef 99; writeSTRef x 8; readSTRef x
22:05:25 <Olathe> @undo do { a <- x; y <- x; z <- x; return z }
22:05:25 <lambdabot> newSTRef 99 >>= \ x -> writeSTRef x 8 >> readSTRef x
22:05:25 <lambdabot> x >>= \ a -> x >>= \ y -> x >>= \ z -> return z
22:05:30 <mmorrow> oh, my term was just small..
22:05:55 <pumpkin> CakeProphet: in general though, >> is just >>= ignoring the parameter
22:06:01 <pumpkin> that's all it's defined as
22:06:04 <Olathe> @undo do { a <- x; y <- x; z <- x; return 5 }
22:06:05 <lambdabot> x >>= \ a -> x >>= \ y -> x >>= \ z -> return 5
22:06:22 <Olathe> @undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:06:22 <lambdabot> x >>= \ a -> x >>= \ y -> x >>= \ z -> print "zomg" >> return 5
22:06:51 <pumpkin> @. pl undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:06:52 <lambdabot> x >> (x >> (x >> (print "zomg" >> return 5)))
22:07:01 <rwbarton> , Control.Monad.ST.Lazy.runST
22:07:03 <lunabot>  luna: Not in scope: `Control.Monad.ST.Lazy.runST'
22:07:13 <pumpkin> @. redo pl undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:07:14 <lambdabot>  Parse error at "mn" (column 14)
22:07:24 <Olathe> @@ @redo @pl @undo { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:07:24 <lambdabot>  Parse error at "{" (column 1)
22:07:30 <Olathe> @@ @redo @pl @undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:07:30 <lambdabot>  do { x; (do { x; (do { x; (do { print "zomg"; return 5})})})}
22:07:32 <rwbarton> pumpkin: you need way more .s
22:07:34 <Olathe> Yay !
22:07:41 <pumpkin> rwbarton: ah
22:07:52 <Olathe> @@ @pl @undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:07:52 <lambdabot>  x >> (x >> (x >> (print "zomg" >> return 5)))
22:07:54 <pumpkin> rwbarton: I've never done it with more than two
22:08:01 <Olathe> Heh
22:08:06 <rwbarton> @. redo . pl . undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:08:07 <lambdabot> Plugin `compose' failed with: Unknown command: "do"
22:08:11 <rwbarton> @. redo . pl . undo redo { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:08:11 <lambdabot> Parse error at "{" (column 1)
22:08:17 <Olathe> @. is evil
22:08:17 <lambdabot> Plugin `compose' failed with: Unknown command: "is"
22:08:20 <Olathe> @@ is good
22:08:20 <lambdabot>  is good
22:08:20 <rwbarton> @. redo . pl undo do { a <- x; y <- x; z <- x; print "zomg"; return 5 }
22:08:21 <lambdabot> do { x; (do { x; (do { x; (do { print "zomg"; return 5})})})}
22:08:24 <pumpkin> Olathe: yeah it is
22:08:30 <pumpkin> rwbarton: that's odd...
22:09:20 <pumpkin> @@ @pl @unpl @pl @unpl @pl @unpl \x y -> f (x g) y
22:09:20 <lambdabot>  f . ($ g)
22:09:26 <pumpkin> :)
22:09:26 <CakeProphet> so is nesting do's pretty much the same thing as using one do with all the lines together?
22:09:36 <rwbarton> CakeProphet: that's the associativity law for a monad
22:09:48 <rwbarton> CakeProphet: I don't know why redo, pl and undo have contrived to make it show up here
22:10:03 <rwbarton> @pl (a >> b) >> c
22:10:03 <lambdabot> a >> b >> c
22:10:08 <rwbarton> @pl a >> (b >> c)
22:10:09 <lambdabot> a >> (b >> c)
22:10:15 <Heffalump> I'd expect pl to apply associativity laws
22:10:31 <Olathe> @src (>>)
22:10:31 <lambdabot> m >> k      = m >>= \_ -> k
22:11:23 <Olathe> @pl a >>= const (b >>= const c)
22:11:24 <lambdabot> a >> (b >> c)
22:11:54 <Olathe> @pl (a >>= const b) >>= const c
22:11:54 <lambdabot> a >>= const b >>= const c
22:11:55 <rwbarton> Oh, sorry, this isn't the associativity law after all.
22:12:21 <rwbarton> That would be do { do { x; y }; z } === do { x; do { y; z } }
22:12:27 <rwbarton> do { x; y; z } is the latter by definition
22:13:00 <CakeProphet> alright, I think do makes sense now.
22:13:03 <CakeProphet> and >> for that matter.
22:14:35 <rubber> hm
22:15:02 <pumpkin> rubber: boing!
22:16:10 <rubber> heh
22:16:21 <rubber> trap judge death in boing plastic!
22:17:33 <CakeProphet> hmm... what happens if you do:  do {x <- Something; x <- Something}
22:17:39 <CakeProphet> is x overwritten or does Haskell complain?
22:17:52 <CakeProphet> well, not "overwritten"
22:18:03 <mauke> you get a new x
22:18:09 <CakeProphet> alright.
22:18:24 <pumpkin> remember, it's just desugared to new lambdas
22:18:25 <CakeProphet> because of how it translate to >>=
22:18:53 <rwbarton> The second x shadows the first
22:19:17 <CakeProphet> I'm never sure if things /actually/ works the way it theoretically is supposed to... or if the compiler simply cuts corners.
22:19:25 <CakeProphet> like with currying.
22:19:28 <pumpkin> NO CORNERS ARE EVER CUT!!!!
22:19:35 <pumpkin> except for negative numbers
22:19:45 <Elly> negative numbers are for the weak
22:19:57 <pumpkin> yeah, true men only use pure imaginary numbers
22:20:07 <pumpkin> they're more negative than negative numbers
22:20:14 <pumpkin> they are the root of all negativity
22:20:19 <monochrom> haha
22:20:36 <rwbarton> How do I make cabal install include hscolour links in the haddock output?
22:20:36 <Saizan_> what corners are there to cut with currying?
22:20:50 <Saizan_> --hyperlink-source
22:20:51 <ksf> pumpkin is right.
22:21:03 <ksf> a negative number of moons, eg, is quite imaginary.
22:21:13 <CakeProphet> for example... f x y  :: x -> y -> v
22:21:18 <pumpkin> even one corner I thought haskell was cutting turned out to be well reasoned (the monomorphism restriction)
22:21:25 <Saizan_> asa flag to cabal haddock
22:21:51 <CakeProphet> does f x actually produce a new function that takes y and return v... or, since that's pretty much pointless, does the compiler evaluate it all at once?
22:22:00 <CakeProphet> well
22:22:02 <CakeProphet> not the compiler
22:22:04 <CakeProphet> but you know what I mean.
22:22:28 <CakeProphet> the object code
22:22:31 <CakeProphet> or whatever.
22:22:33 <ksf> depends on how much strictness the strictifier can prove.
22:22:37 <Elly> depends how you use it, I guess?
22:22:47 <Saizan_> ah, yeah, it's smarter than that, since it would be pretty slow otherwise
22:23:40 <CakeProphet> alright. That's why I wasn't sure if do {x <- something; x <- something}  worked the same way as its >>= form or if Haskell cut corners with it too.
22:23:59 <rwbarton> I don't understand this phrase "cut corners"
22:24:06 <rwbarton> do you mean "optimize"?
22:24:11 <pumpkin> well it'll cut corners in the sense that it'll make things faster
22:24:16 <pumpkin> but if it changes the semantics, that would be kinda bad
22:24:33 <ksf> if in doubt, look at the core.
22:24:39 <Saizan_> CakeProphet: as long as the semantics don't change i'd not worry about such things
22:24:41 <pumpkin> I'm scared of core :(
22:25:01 * pumpkin needs to learn and embrace core
22:25:06 * pumpkin trembles
22:25:30 <ksf> it's just like using ddd and seeing c and asm alongside.
22:25:39 <int-e> it doesn't bite, pumpkin ;)
22:25:48 <ksf> ...you gotta go by the asm if you're debugging -O3 code.
22:25:50 <pumpkin> but I'm skewod
22:25:57 <Saizan_> asm is often prettier than the current Core prettyprinter
22:26:01 <rwbarton> Saizan_: I don't seem to have a flag --hyperlink-source in cabal install
22:26:10 <CakeProphet> Saizan_: I don't usually "worry" about it when I'm coding. Just questing to understand Haskell's compiler (and  I guess compilers in general)
22:26:10 <pumpkin> I'm sure I can read asm better than I can read core
22:26:16 * CakeProphet is interested in language design.
22:26:19 <Saizan_> rwbarton: it's for "cabal haddock"
22:26:40 <ksf> CakeProphet, I recommend starting off with the wizard book.
22:26:45 <ksf> last chapter.
22:26:51 <rwbarton> Saizan_: Ah
22:26:57 <CakeProphet> wizard book? SICP?
22:27:01 <ksf> yeah.
22:27:46 <CakeProphet> I started reading it a while back, but I didn't get to the later chapters.
22:27:48 <rwbarton> Saizan_: It ran hscolour, but didn't seem to make links in the haddock output
22:28:05 * ksf slurped it in one go on the first read
22:28:13 <rwbarton> Saizan_: never mind
22:28:21 <rwbarton> Saizan_: Is there a way I can specify this in .cabal/config ?
22:28:46 <pumpkin> I took a course that used SICP but somehow only ever found out about the book a couple of years after I took the course (I guess I just never bought the book or something... I was even more clueless back then)
22:29:00 <ksf> ...with details being left to be filled in later on subsequent reads.
22:29:12 <Saizan_> rwbarton: not currently, you might want to add your opinion to http://hackage.haskell.org/trac/hackage/ticket/206
22:29:49 <CakeProphet> ksf:  it's a wonderful book.
22:32:33 <nejucomo> Hrm.  My parsec parser has infinite recursion because I want to parse <expression> '.' <symbol> as an expression.
22:32:50 <nejucomo> I wonder how to do this right.
22:32:55 <Saizan_> nejucomo: see chainl
22:32:56 <mauke> what's the base case?
22:33:19 <nejucomo> mauke: The base case would be a different expression besides this form.
22:33:27 <Saizan_> recursive descent parsers can't handle left-recursion directly
22:33:33 <mauke> <base> ('.' <symbol>)*
22:35:06 <koninkje> Does anyone know what the overhead (in cycles) is for doing "safe" FFI calls (vs "unsafe")?
22:35:42 <rubber> lol
22:35:58 <pumpkin> koninkje: exactly 73
22:36:04 <newsham> is it possible to have code in lhs2tex file that is executed but not present in the .pdf output?
22:36:17 <koninkje> pumpkin: heh. Thanks
22:36:21 <pumpkin> sorry :)
22:37:07 * BMeph is watching the YouTubed videos
22:37:32 * BMeph meant ^^ of SICP
22:37:44 <ksf> youtube quality sucks.
22:38:01 <ksf> http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
22:38:15 <ksf> the divx ones.
22:38:55 <pumpkin> wow
22:38:56 <pumpkin> those are huge
22:39:49 <BMeph> pumpkin: That's what *SHE* said! ;[
22:39:52 <pumpkin> lol
22:42:47 <pumpkin> maybe someone has more input on this right now
22:43:10 <pumpkin> but say I was taking shannon entropy on a discretely sampled collection of real values
22:43:26 <pumpkin> I need to bin/discretize those values to get something meaningful out of it
22:43:47 <pumpkin> does anyone know what a reasonable/justifiable bin count/width/strategy is in this case?
22:45:03 <azathoth99> do you frap drinkers use haskell for  real world work or just paper writing fun?
22:45:14 <pumpkin> frap?
22:45:18 <mauke> what is a frap?
22:45:31 <cjb> and which universe do people have fun writing papers on?
22:45:49 <pumpkin> I sort of do, when I'm not on a time limit, which is pretty rare
22:45:57 <cjb> azathoth99: anyway, you sound like a prime candidate for _Real World Haskell_.
22:46:04 <azathoth99> haskeel seems to have a butload of people interested in it
22:46:10 <pumpkin> azathoth99: what's frap?
22:46:19 <cjb> pumpkin: frapucino.
22:46:20 <pumpkin> Functional ReActive Programming?
22:46:22 <pumpkin> ah :)
22:46:34 <cjb> although I like your version better
22:46:53 <azathoth99> frap is a milk shake with frothy top served by friendlies ice cream resteuraunts
22:47:20 * ksf was hoping frap to be something containing alcohol
22:47:47 <BMeph> pumpkin: Read this: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
22:48:04 <BMeph> pumpkin: Then, think about how to do it *ALL*! ;)
22:48:16 <pumpkin> BMeph: is that in relation to my question earlier or just cool? :)
22:48:34 <azathoth99> bloody friendlies site uses flash
22:49:14 <ksf> quite many haskell programs are impossible to write in other languages.
22:49:31 <BMeph> pumpkin: Yeah, the shannon ent thing. :)
22:49:36 <pumpkin> ah, thanks :)
22:49:52 <ksf> ...as noone has a despair threshold high enough to stand the amount of bugs it'd produce.
22:50:28 <pumpkin> BMeph: oh I think I came across this a while ago
22:50:31 <pumpkin> it's pretty neat
22:50:44 <pumpkin> but where's the entropy? :o
22:50:59 <rwbarton> Silly question, but: if I have two equations  f Foo = ...; f Bar = ...  and I want a where clause to apply to both, my best bet is to switch to f x = case x of ...?
22:51:05 <BMeph> pumpkin: Yeah, I just stumbled on it recently, not sure why... I'm eatng it up! :)
22:51:34 <azathoth99> is rael world haskell really free? how about learn you a haskell for great good ?
22:51:43 <pumpkin> azathoth99: both really free :)
22:51:47 <BMeph> rwbarton: Silly, rabbit! If it's the same function, the where will apply to both. :)
22:51:48 <newsham> both are online for your consumption
22:51:49 <mauke> azathoth99: are you a troll?
22:51:56 <int-e> pumpkin: just a vague idea, if you have a set of measurements, a reasonable bin size is dictated by noise plus measurement errors.
22:52:08 <newsham> troll you a chat
22:52:22 <BMeph> ...for great aggravation! ;p
22:52:41 <rwbarton> BMeph: Are you sure about that?  It doesn't seem to, but... I'm tired. :)
22:52:52 <pumpkin> int-e: someone in here suggested 3.5 * stddev(xs) / (length xs ** (1/3)) yesterday (for bin width) and cited a paper finding optimal bin widths for histograms (I haven't looked up what they mean by optimal yet, and my statistics is kinda lacking)
22:53:05 <azathoth99> no
22:53:11 <Saizan_> where is per-clause, because it has the variables in the patterns in scope
22:53:29 <azathoth99> I did get kicked from lisp room for asking stuff a while back by a guy named riastrd
22:53:34 <newsham> wouldnt optimal bin width depend greatly on distribution?
22:53:58 <BMeph> rwbarton: I tested it the hard way - I tried to use separate where clauses. GHC complained. I consolidated it to one 'where'...and it worked! :)
22:54:05 <pumpkin> int-e: I have a feeling that for the definition of optimal entropy binning I have in my head that I can't formulate, a variable-width bin would be even better, but it sounds hard and is made even harder by my inability for formalize what I mean by "good binning for entropy"
22:54:09 <int-e> pumpkin: I can't say more. (It's a vague idea mainly because I never dug into that topic deeply.)
22:54:21 <mauke> gavinâ½
22:54:24 <rwbarton> Saizan_: OK, right
22:54:28 <pumpkin> wow, an interrobang
22:54:50 <Saizan_> but BMeph contradicts me?
22:55:00 <newsham> sleep time
22:55:24 <azathoth99> sleep is for wimps
22:55:40 <pumpkin> I wish I were a wimp then
22:55:43 <azathoth99> mauke: who knows that name!
22:55:53 <Saizan_> BMeph: what did you test?
22:57:06 <alami> is haskel a high level programing languages :)
22:57:21 <alami> that's new for HASKEL :)
22:57:21 <Elly> oh yes
22:57:26 <Elly> Haskell, by the way
22:57:28 <Elly> it is not an acronym
22:57:29 <ksf> nope, agda is.
22:57:29 <BMeph> Saizan_: Hmm, it's been a while, I have no idea. I think one of the "seemingly-impossible" functions may have one, though. :)
22:57:55 <alami> and it is dificult then perl and c/c++ or not?
22:58:00 <Elly> um
22:58:02 <Elly> depends what the task is
22:58:05 <mauke> fuk
22:58:15 <pumpkin> mauke: I beg your pardon!
22:58:16 <alami> that's my first time that i hear about this language
22:58:17 <alami> :D
22:58:32 <pumpkin> alami: the wikipedia page provides a good overview on it :)
22:58:36 <araujo> alami, a whole different paradigm ... considering that.. I think it is easier than those languages
22:58:49 <nejucomo> alami: Actually, Haskell *is* an acronym, but the meaning is only revealed to those who prove their haskell skill.
22:59:01 <ksf> it's certainly easier if it's the first language you learn.
22:59:12 <Elly> yes
22:59:39 <Elly> I learned functional programming (by learning Standard ML) after years as a C and perl programmer, and rewiring my brain appropriate was a bit painful
22:59:48 <pumpkin> or awesome!
23:00:04 <Elly> it was awesome after I got good at it :)
23:00:08 <mauke> ML was ok after Perl
23:00:20 <Raevel> i head years of mostly javascript and a lot of php before functional programming
23:00:28 <Elly> I still don't know haskell and scheme as well as ML
23:01:10 <azathoth99> www.smlserver.org is an ml web thingy
23:01:18 <BMeph> I sometimes with I'd've studied ML after using Forth, but now, I don't have to, all the 'old-school' paper-writers use it, so I get it by osmosis. :)
23:01:36 <alami> so the first language to learn is haskel...
23:01:40 <azathoth99> forth? I find forth fascinating
23:01:43 <alami> that's will be funny
23:01:46 <ksf> HE ACCIDENTLY THE VERB!
23:02:56 <BMeph> azathoth99: Ain't it, though? I like a language that, unlike C, is both low-level access and high-level abstractionary (sp?). :)
23:04:50 <BMeph> rubber: Ain't it, though? I like a language that, unlike C, is both low-level access and high-level abstractionary (sp?). :)
23:05:37 <Raevel> i'm stupid. i wrote a custom dtd language for json, and thought "oh, i'll need a parser generator to make this useful". But then i just started coding a regular parser and evaluator, now i realized that i still need a parser generator
23:10:56 <rubber> abstraction
23:11:06 <rubber> I already found an error in real world haskell
23:11:11 <rubber> are the authors not american?
23:11:25 <rubber> or not like native english speakers?
23:11:40 <Elly> which error did you find?
23:11:44 <rubber> BMeph: some c progarmmers say c can be used to make great abstractions
23:12:33 <rubber> Since pure code has no dealings with the outside world, and the data it works with is never modified, the kinds of nasty surprise in which one piece of code invisibly corrupts data used by another are very rare. Whatever context we use a pure function in, it will behave consistently.
23:13:11 <rubber> suprise should be suprises
23:13:16 <pumpkin> not really
23:13:20 <rubber> yep Ima nerd
23:13:25 <rubber> oh surely
23:13:27 <pumpkin> and btw, americans don't have a monopoly on english :P
23:13:32 <stulli> rubber: They are Irish, Australian and American
23:13:37 <rubber> I am a published author
23:13:42 <pumpkin> rubber: so are they ;)
23:13:47 <rubber> heh
23:13:52 <Elly> rubber: I'm not sure about that
23:13:54 <stulli> (dont know if that makes a difference :) )
23:13:59 <pumpkin> I don't agree that it's an error
23:13:59 <Elly> rubber: 'kinds of nasty surprise' seems legitimate to me
23:14:07 <Elly> since the pluralization happens on 'kinds'
23:14:09 <pumpkin> there are many kinds of surprise
23:14:13 <pumpkin> how many kinds of surprise do you want?
23:14:27 <pumpkin> it's not an adjective and doesn't really need to agree with surprise
23:14:28 <rubber> I would put forth that even in the unlikely event australian english lets one mix plurals with non, it reads nicer my way
23:14:32 <pumpkin> semantically or linguistically
23:15:03 <rubber> it sounds liek 4th grader writing the way it is and any enlglish major reading it will face palm
23:15:12 <pumpkin> rubber: nope :)
23:15:15 <rubber> and make snarky comments about comupter guys having bad comm skills
23:15:17 <Elly> the irony patrol is approaching fast :)
23:15:26 <pumpkin> arguing by authority or intimidation won't work :P
23:15:37 <rubber> I attempt neither
23:15:49 <Elly> upon what basis do you assert that 'surprises' should be plural there?
23:15:53 <rubber> when have you ever heard the phrase kinds of suprise?
23:16:01 <pumpkin> you've cited authority by saying you're a published author, and said that any english major would condemn it as you have (== intimidation)
23:16:02 <rubber> KIND SS of Suprise
23:16:46 <rubber> there are many "kinds of animals" on noahs ark
23:16:56 <pumpkin> ahem, apostrophe ;)
23:17:03 <rubber> there are many "kinds of beers" in this bar
23:17:20 <Elly> I would say "kinds of animal" and "kinds of beer" respectively
23:17:24 <pumpkin> me too
23:17:43 <rubber> I might actually say kinds of beer, but never kinds of animals
23:17:52 <rubber> er kinds of animal
23:17:59 <rubber> [damn it jim]
23:18:01 <Elly> you can modify the sentence a bit and it still seems correctly plural - "There are many kinds [of beer/animal/etc]."
23:18:02 <pumpkin> I'd use singular for both :P
23:18:11 <Elly> why would you use singular for beer but not animal?
23:18:18 <pumpkin> as I said, there's no accordance rule in this case :P
23:18:18 <rubber> I am not sure
23:18:20 <pumpkin> it's a stylistic thing
23:18:28 <rubber> english is not the most consistent of languages
23:18:35 <rubber> I am telling you what sounds corret
23:18:39 <rubber> correct
23:18:44 <pumpkin> rubber: ...to you
23:18:50 <Elly> right, but we're telling you that the way presented up there sounds correct to us
23:18:55 <rubber> well of course
23:18:56 <pumpkin> you don't speak for all americans because I'm american :P
23:19:03 <Elly> and given that, as you said, English lacks well-defined rules...
23:19:03 <pumpkin> (vaguely)
23:20:30 <rubber> kinds of suprise
23:20:36 <rubber> kinds of suprises
23:20:48 <Elly> "There are many kinds of surprise." "There are many colours of paint."
23:20:52 <Elly> both of those sound correct to me
23:20:55 <pumpkin> my dictionary has a "usage note" for the three combinations we're not talking about
23:21:13 <pumpkin> kind of surprises, kinds of surprises, and kind of surprise
23:21:22 <pumpkin> they don't mention kinds of surprise
23:21:33 <Elly> the second one is the one rubber prefers
23:21:37 <pumpkin> yeah
23:21:38 <Raevel> or kind surprises? :-S
23:21:41 <mauke> it's all shades of gray
23:21:42 <pumpkin> I mean the one that started this
23:21:46 <mauke> I mean grays
23:21:52 <rubber> but remember the context: * the *kinds of nasty suprise[s], perhaps it has to do with the qualifying THE
23:21:54 <rubber> ah ha!
23:21:58 <pumpkin> the one thing they say not to do is say "these kind of <plural>" which is obviously wrong
23:22:09 <rubber> perhaps that makes the plurals have to match
23:22:13 <pumpkin> nope
23:22:28 <pumpkin> this kind, these kinds
23:22:31 <pumpkin> those have to match
23:22:37 <pumpkin> 1 kind, 5 kinds
23:22:45 <pumpkin> the genitive after that is up to you I think :P
23:22:56 <mauke> kinder
23:23:30 <rubber> the kinds of nasty suprise or the kind of nasty suprise
23:23:43 <rubber> see I think the kind of nasty suprise sounds ok
23:24:12 <mauke> this is all off topic :-|
23:24:16 <pumpkin> yeah :)
23:24:24 <rubber> interesting though eh
23:24:30 <Raevel> yes yes
23:24:36 <Elly> email one of the RWH authors and they'll probably forward it to their editor :)
23:24:52 <rubber> where are thier emails?
23:24:56 <Raevel> i need to study me an english more someday
23:25:11 <Elly> hopefully at the start of the book?
23:25:21 <Elly> or just ask dons when ey shows up :)
23:25:34 <BMeph> Raevel: Why bother with email? Just leave 'em a note here, in IRC. :)
23:25:42 <rubber> heh
23:25:56 <rubber> lets see if anything else I can find
23:26:12 <pumpkin> is there any reason to not replace all maps in my code with fmaps?
23:26:45 <pumpkin> not that there's really any reason to do so, just curious
23:27:25 <Saizan_> if i open a file twice, once for reading and later once for writing, if i write to the file do i later read what i've written or what was in the file at the point when i've first opened it?
23:27:31 <Saizan_> on unix
23:27:36 <Raevel> doesn't fmap just add the potential for confusion in that case?
23:27:46 <Elly> Saizan_: depends where your read pointer is
23:28:04 <Elly> Saizan_: man 2 read and man 2 write might clarify it
23:28:25 <pumpkin> Raevel: probably, just wondering if there are any other reasons not to
23:28:26 <Saizan_> Elly: at the start, i'm asking if file handles are transactionally indipendent, essentially
23:28:49 <Elly> I suspect that you will read what you have written
23:28:54 <pumpkin> Saizan_: I'd doubt they have any kind of (good) "transactional" behavior in the stdlib/kernel
23:28:57 <augustss> Saizan_: You'll read what you wrote.
23:29:02 <Elly> otherwise haskell would have to grab a copy of the entire file when you open it...
23:29:08 <Elly> which would be very odd and inefficient
23:29:30 <pumpkin> such a thing would be possible on something like ZFS
23:29:42 <pumpkin> but the transactions aren't really exposed to userland
23:29:48 <pumpkin> unfortunately :/
23:29:55 <Saizan_> augustss: does this still hold if the reading and the writing is done from different processes?
23:30:15 <Elly> it is probably written back to the file
23:30:24 <Elly> and the concurrent read reads back from the file, so...
23:30:44 <augustss> Saizan_: yes
23:31:38 <Saizan_> i see, so the only guarantee is wrt deletion
23:32:43 <augustss> Saizan_: there's a race though.  if you do the read() while before the write() has returned you don't know what you'll get.
23:34:10 <Saizan_> ah, even better :)
23:34:49 <BMeph> augustss: But, that means we can't get messages from the future! Oh, I guess that does make some sense. ;p
23:36:41 <enticingjelly> any library out there which uses continuations for web apps?
23:37:52 <rubber> www.happs.org
23:37:56 <rubber> hws
23:38:04 <rubber> I love the internet
23:38:24 <enticingjelly> "Write web services really easy using an elegant monadic framework for managing control-flow within your server."
23:38:33 <enticingjelly> that sounds like it might be what I'm looking for, thanks
23:39:26 <Saizan_> by continuations you mean like faking a continuous session with the user?
23:39:32 <enticingjelly> yes.
23:39:50 <enticingjelly> and I believe you can elegantly implement that using continuations.
23:40:15 <Saizan_> i'm aware only of WASH doing that, but it's sort of abandonware
23:40:40 <enticingjelly> Saizan_, I'll take a look at happs. well, once the issue comes up, right now I was just curious 8)
23:41:10 <Saizan_> don't look at happs.org however :)
23:42:16 <rubber> oh yeah wash
23:42:46 <Saizan_> http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial
23:43:03 <Saizan_> http://happstutorial.com/
23:44:43 <gour> thoughtpolice: hi, does takusen have support for BLOBs?
23:45:01 <pumpkin> I have an issue.. I'd like to break up my computation into manageable chunks so I tend to let someMeaningfulChunkOfComputedData = anIntenseComputation rawData at various stages of my program. It doesn't need to persist, and I only break it up to make my code simpler... however by doing the let I seem to prevent it from getting garbage collected as I retain a pointer to the head of the computed data, which means I get epic memory usage
23:45:58 <pumpkin> is there any better way of doing this so it doesn't feel the need to keep all that data around?
23:46:57 <vixey> can you post the different styles of program for comparison?
23:47:01 <Saizan_> are you compiling with -O2 ?
23:47:05 <pumpkin> Saizan_: yeah
23:47:33 <pumpkin> vixey: I'll try, just a sec
23:48:19 <Saizan_> uhm, i tend to divide the algorithm in transformers
23:48:26 <Saizan_> rather than intermediate results
23:48:33 <Saizan_> which then i can compose
23:48:35 <vixey> Saizan, like f . g . h ?
23:48:56 <Saizan_> vixey: yeah, sometimes the composition is not that simple though
23:48:59 <vixey> (that's what I do)
23:49:08 <vixey> well there's <=< also :p
23:50:04 <pumpkin> http://hpaste.org/13752 that's a simplified example
23:50:33 <pumpkin> the functions are bigger and more happens in them
23:50:37 <pumpkin> but not much bigger
23:50:42 <pumpkin> but there's a lot of data being juggled around
23:50:45 <vixey> pumpkin, why one has a type annotation, and the other does not?
23:50:57 <pumpkin> they're supposedly the same type
23:51:02 <pumpkin> I didn't feel like copying and pasting :P
23:51:24 <vixey> I wonder if,
23:51:29 <Saizan_> ?pl computeData' xxs = zipWith (*) (map slidingEntropy xxs) (map expensiveComputation xxs)
23:51:30 <lambdabot> computeData' = ap (zipWith (*) . map slidingEntropy) (map expensiveComputation)
23:51:33 <vixey> zipWith (&) (map f xs) (map f ys)
23:51:35 <vixey> is optimized to
23:51:40 <vixey> oops
23:51:43 <vixey> zipWith (&) (map f xs) (map g xs)
23:51:54 <vixey> ~~>  zipWith (\x y -> f x & g y) xs ys
23:51:58 <Saizan_> it should fuse, yeah
23:52:04 <vixey> and in the where case, maybe it's not optimized liek that?
23:52:09 <vixey> just a guess though
23:52:13 <pumpkin> that's what I'm assuming is making it more memory efficient
23:52:16 <pumpkin> because I've noticed it is
23:52:30 <pumpkin> it's not a huge deal, but I was wondering what approaches other people use in situations like this
23:52:36 <Saizan_> the question is that it's not smart enough to inline those where definitions
23:52:48 <vixey> or even,
23:52:57 <vixey> map (\x -> f x & g x) xs
23:53:02 <pumpkin> my main issue isn't one of speed as memory usage
23:53:09 <rwbarton> Yeah, I would hope those definitions would get inlined before the fusion phase...
23:53:14 <pumpkin> I don't need it to take up linear memory computing that list, and then consuming it again
23:53:17 <vixey> hey rwbarton
23:53:23 <rwbarton> Hi vixey
23:53:23 <pumpkin> rwbarton: well, the real thing is more complicated than that
23:53:26 <pumpkin> but that's the basic idea
23:53:27 <vixey> did you solve the problem with type families?
23:53:33 <rwbarton> kind of
23:53:43 <rwbarton> I upgraded to ghc 6.11.20090107 :)
23:53:50 <pumpkin> ooh
23:53:57 <rwbarton> which has the feature I need
23:54:42 <vixey> her's my take on it http://hpaste.org/13738#a1
23:54:49 <pumpkin> would Data.Stream from stream-fusion help my issue?
23:55:02 <vixey> I don't know about type families though, how does it work out?
23:55:04 <Saizan_> pumpkin: it looks like something you could post to ghc-users to see if it's expected behaviour or not
23:55:20 <pumpkin> it seems like my memory is being eaten up by "temporary lists" that stream fusion is supposed to cut out
23:55:31 <pumpkin> but I don't know enough about it to really be able to tell
23:56:13 <pumpkin> I guess Data.Stream is easy enough to use for me to just be able to try and see :)
23:56:22 <rwbarton> vixey: the idea with type families is that it's like an open GADT
23:56:35 <rwbarton> vixey: so I can define LEFT and RIGHT in a different module from NTH if I like
23:56:50 <vixey> rwbarton, doesn't it being open limit what you can do in a big way?
23:56:50 <rwbarton> vixey: but yeah basically it is the same idea as far as I can tell
23:56:54 <Saizan_> pumpkin: well Data.List already has its own fusion mechanism, but yeah trying doesn't hurt
23:57:01 <pumpkin> ah
23:57:27 <rwbarton> vixey: yes, probably :)  but I think you should still be able to write project and modify
23:57:35 <rwbarton> vixey: now they are class methods
23:57:49 <rwbarton> (of 'obj')
23:58:03 <Saizan_> stream-fusion must have advantages over the standard one, or they wouldn't have written it
23:58:48 <vixey> btw did anybody actually document /anything/ about type families yet?
23:59:08 <rwbarton> vixey: http://www.haskell.org/haskellwiki/GHC/Indexed_types is pretty useful
23:59:28 <rwbarton> vixey: let me try to write a type family version of your code
