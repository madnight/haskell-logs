00:00:18 <jql> fire any devs who fail to write good docs? :)
00:00:19 <Adamant> code you don't understand is code that will likely be incorrectly documented
00:00:33 <mmorrow> arw: i'm not sure though, because if it's nice, clean, well thought-out, and clear it's probably more likely that it works well/is bugfree than code that's not.
00:01:02 * cizra seconds mmorrow and Adamant 
00:04:06 <arw> mmorrow: i agree on the well tought-out part. the logic should be simple, clear and well-designed.
00:04:59 <arw> mmorrow: the rest is just cosmetics, thats what indent is for ;)
00:05:24 <mmorrow> arw: fair enough, but i think that clean code usually goes hand-in-hand with clean logic
00:06:27 <arw> sometimes. there are those programmers who produce clean logic without any effort. most of those also produce clean code.
00:07:22 <mmorrow> arw: sure
00:07:30 <arw> but there are those, who are unable to produce clean logic. they are mostly able to produce clean-looking code...
00:08:22 <mmorrow> heh, ok. perhaps
00:08:23 <mmorrow> ;)
00:08:45 <arw> thats also the answer for Adamant. good documentation comes only from people doing clean logic, not from people producing only clean code.
00:09:10 <Adamant> you need clean logic and clean code
00:09:45 <mmorrow> arw: (of course it is not a substitute for docs), but clean code is self-documenting
00:10:06 <mmorrow> assuming you need more info than docs could ever provide (unless the essentially duplicated the code)
00:10:23 <vixey> hiya!
00:10:30 <mmorrow> vixey: heya!
00:11:31 <arw> mmorrow: documentation should only provide some guidance through the code, it should help you find places to look at and put stuff into a perspective.
00:11:35 <idesperado> hello there...I wanna install cabal and cabal-install to simplify my  installation of haskell packages...but now I've already builded the  cabal and cabal-install package and there is still not a command  called cabal and cabal-install....plus,I'm using Ubuntu
00:12:06 <vixey> if anybody likes puzzles, I have a good suggestion for new years:  Try (but do not necessarily complete, that would be incredible) to solve one sokoban puzzle everday
00:12:38 <cizra> That's a great suggestion. Are there any console-based sokobans around?
00:12:52 <earthy> vixey: I fail at that suggestion.
00:12:54 <arw> idesperado: is there a /usr/local/bin/cabal? (ls -la on it)
00:12:57 <vixey> I know nothing to do with haskell :/ .. but it is so fun I thought I should suggest :p
00:12:59 <earthy> (at day 1 ;))
00:13:09 <mmorrow> arw: ah, we're talking about docs in two different senses. ok, i hear you there, but even so, code that needs docs in order to be understandable/readable is (now that i think about it) my definition for not clean code.
00:13:49 <earthy> mmorrow: I disagree
00:13:55 <idesperado> arw: no...it's in ~/.cabal/bin
00:14:03 * vixey thinks sokoban is probably the best puzzle ever invented
00:14:19 <arw> idesperado: ah, right. you need to add that path to your PATH.
00:14:45 <earthy> however, the only places where that is acceptable is for intricate algorithms that are best served with an extra explanation of the underlying ideas and data structures and *why* they work
00:15:05 <idesperado> arw: why could I just build the executable to /usr/local/bin...so that I don't need to add to my PATH
00:15:12 <mmorrow> earthy: if i know a programming language well enough, i'd be pretty confident in my ability to understand some code (that's clearly enough written) if all comments were stripped.
00:15:33 <arw> idesperado: you could, yes.
00:15:49 <earthy> mmorrow: I'd still find it tough to understand deletion for AVL trees, e.g.
00:16:03 <idesperado> arw: how could I do??
00:16:33 <CakeProphet> > fromEnum '\0'
00:16:34 <idesperado> add a prefix???
00:16:34 <mmorrow> earthy: heh, i agree. many times it wouldn't be easy or particularly fun, but /possible without an infeasible amount of effort/. :)
00:16:35 <lambdabot>   0
00:17:05 <idesperado> arw: like...runhaskell Setup.hs configure --prefix=/usr/local???
00:17:08 <vixey> mmorrow, is there a neutron repo?
00:17:53 <mmorrow> vixey: not yet, but very shortly. i just finished (more or less) some ffi bindings to libev, so now i can finish making neutron work.
00:17:55 <arw> mmorrow: there are some places where something sufficiently complicated happens, that should be documented. but mostly documentation just saves me the effort of reading the whole code just to understand one function.
00:18:10 <mmorrow> arw: i agree.
00:18:17 <CakeProphet> > maxBound :: Char
00:18:18 <lambdabot>   '\1114111'
00:18:43 <vixey> kk I look forward to it
00:18:50 <arw> idesperado: yes, something like that.
00:18:55 <mmorrow> vixey: me too :)
00:19:09 <vixey> mmorrow: (occurs to me that if I make a sokoban game in haskell maybe I can share some of the fun)
00:19:21 <idesperado> arw: but...I've done that...and without a --user it won't succeed...
00:19:44 <idesperado> arw: and it tells that the http and zlib not installed
00:20:04 <arw> idesperado: i'm not quite sure how i did that some time ago...
00:20:11 <mmorrow> vixey: you'll be the first to know about the repo when it's up :)
00:21:36 * mmorrow googles sokoban
00:26:11 <CakeProphet> is there a builtin that takes a number and returns 0 if its negative, otherwise it returns the number itself?
00:26:37 <CakeProphet> trivial to make, just don't want to be redundant
00:26:39 <mmorrow> max 0
00:26:42 <mmorrow> ?
00:26:50 <CakeProphet> aha!
00:26:51 <CakeProphet> beautiful.
00:37:57 <CakeProphet> @src getContents
00:37:58 <lambdabot> getContents = hGetContents stdin
00:38:07 <CakeProphet> @src hGetContents
00:38:08 <lambdabot> Source not found. Wrong!  You cheating scum!
00:38:18 <CakeProphet> @src getChar
00:38:19 <lambdabot> getChar = hGetChar stdin
00:38:32 <CakeProphet> I don't remember what getContents does.
00:38:59 <CakeProphet> how much input does it get (after being bound)
00:44:05 <vixey> if symmetry is: t R t' -> t' R t,  then the symmetric closure K' of K is: (t K t' -> t K' t') + (t K' t' -> t' K t).. to take the R1 closure R3 of a relation R2, you just take the R2 -> R3, and then each constructor of R1 except with s/R1/R3/?
00:44:35 <erso> @src tails
00:44:36 <lambdabot> tails []         = [[]]
00:44:36 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
00:46:24 <CakeProphet> > tails [1..10]
00:46:26 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
00:50:44 <CakeProphet> > heads [1..10]
00:50:46 <lambdabot>   Not in scope: `heads'
00:50:50 <CakeProphet> well that simply won't do
00:51:07 <erso> > inits [1,2,3,4]
00:51:09 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
00:51:12 <vixey> is the Ri closure of the Rj closure of R = the Rj closure of the Ri closure of R?
00:51:48 <CakeProphet> @let heads [] = []; heads (x:xs) = x : heads xs
00:51:51 <lambdabot>  Defined.
00:51:59 <CakeProphet> > heads [1..10]
00:52:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:52:04 <CakeProphet> perfect.
00:52:05 <vixey> lol
00:53:15 <CakeProphet> hmmm...
00:53:23 * vixey decides yes they are equal but decides also not to prove it..
00:53:46 <CakeProphet> is inits the rough equivalent of a power set?
00:53:54 <vixey> CakeProphet, no
00:53:58 <baaba> let heads' = scanl (:) [] in heads' [1, 2, 3, 4]
00:54:02 <baaba> > let heads' = scanl (:) [] in heads' [1, 2, 3, 4]
00:54:03 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:54:03 <lambdabot>        Expect...
00:54:41 <vixey> > map (\x -> [[],[x]]) "foobar"
00:54:43 <lambdabot>   [["","f"],["","o"],["","o"],["","b"],["","a"],["","r"]]
00:54:50 <vixey> > sequence (map (\x -> [[],[x]]) "foobar")
00:54:52 <lambdabot>   [["","","","","",""],["","","","","","r"],["","","","","a",""],["","","",""...
00:54:57 <baaba> > let heads' = scanl (flip (:)) [] in heads' [1, 2, 3, 4]
00:54:58 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1]]
00:55:04 <vixey> > concat (sequence (map (\x -> [[],[x]]) "xyz"))
00:55:05 <lambdabot>   ["","","","","","z","","y","","","y","z","x","","","x","","z","x","y","","x...
00:55:11 <baaba> hm, almost ;)
00:55:16 <mmorrow> grrrr
00:55:16 <vixey> > nub (concat (sequence (map (\x -> [[],[x]]) "xyz")))
00:55:17 <mmorrow> haddock: internal Haddock or GHC error: Maybe.fromJust: Nothing
00:55:18 <lambdabot>   ["","z","y","x"]
00:55:29 <baaba> > let heads' = reverse . scanl (flip (:)) [] in heads' [1, 2, 3, 4]
00:55:30 <lambdabot>   [[4,3,2,1],[3,2,1],[2,1],[1],[]]
00:57:46 <baaba> > let heads' = scanl ((++) . (:[])) [] in heads' [1, 2, 3, 4]
00:57:47 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:57:47 <lambdabot>        Expect...
01:01:06 <baaba> @pl \acc x -> acc ++ [x]
01:01:06 <lambdabot> (. return) . (++)
01:01:31 <Myrth> hi, what does the dot operator do? like one . two
01:01:40 <vixey> Myrth, it's function composition
01:01:53 <vixey> Myrth, so  (f . g) x = f (g x)
01:02:26 <vixey> and (f . g) . h = f . g . h = f . (g . h)
01:02:34 <vixey> and id . f = f . f . id
01:02:39 <Myrth> so it's useful to give function composition as parameter
01:02:53 <vixey> and (f . g)^-1 = g^-1 . f^-1  (^-1 meaning inverse, not valid haskell though)
01:03:04 <idnar> vixey: id . f = f . f. id??
01:03:17 <vixey> typo, id . f = f = f . id
01:03:21 <vixey> cheers
01:03:24 <idnar> oh, right
01:03:44 <Myrth> and $ ?
01:04:06 <idnar> f $ x = f x
01:04:18 <idnar> but it has low precedence, so it's useful to avoid adding ()
01:04:23 <vixey> ($) doesn't have any nice properties like (.)
01:04:33 <idnar> for example, instead of (f . g . h) x you could write f . g . h $ x
01:05:00 <Myrth> i see
01:06:11 <Myrth> oh and i'm confused why here lambda is not used: subEachFromTen = map (10 -)
01:06:22 <Myrth> it appears that (10 -) is an inline functoin?
01:06:25 <baaba> operator sugar
01:06:35 <vixey> > (x -) 4
01:06:37 <lambdabot>   x - 4
01:06:40 <baaba> if you leave out one or both operands it becomes a lambda expecting the missing operands
01:06:41 <vixey> > (* x) 4
01:06:43 <lambdabot>   4 * x
01:07:09 <erso> so-called currying, no?
01:07:15 <baaba> no
01:07:27 <vixey> erso, well it's partial application
01:09:01 <vixey> is there any shorthand/catchy-name for reflexive symmetric transitive closure?
01:09:37 <CakeProphet> hyperbolic!
01:10:05 <prb> vixey: That'd be the smallest equivalence relation containing the set of pairs.
01:10:18 <vixey> really, why is it smallest?
01:11:06 <prb> vixey: I assume that's what you mean by closure.
01:11:12 <prb> vixey: Add pairs until the set meets the requirements.
01:11:19 <angelixd> prb: wouldn't it just be the equivalence class?
01:11:31 <vixey> it is an equivalence class!
01:11:42 <vixey> prb, I think I have a sort of definition but I'm not sure it's standard
01:12:19 <prb> An equivalence class is a set of equivalent items.
01:12:28 * prb is dusting off some neurons.
01:12:39 <CakeProphet> it would be nice to be able to do partial application in tough spots using _'s
01:13:15 <CakeProphet> for the unapplied values to be applied (in positional order) later. But that would require compiler magic rather than curried functions.
01:13:18 <prb> vixey: Maybe I misunderstand what you're after.
01:13:32 <vixey> prb, so for example,  symmetric relation is  a S b -> b S a,  then the symmetric closure (which i'll call K), of R,  is   a R b -> a K b, and a K b -> b K a
01:13:48 <vixey> and you can do that for any relation similary
01:13:51 <vixey> similarly*
01:13:52 <prb> vixey: Yep.
01:14:02 <prb> That'd be the smallest equivlance relation containing your initial set.
01:14:14 <vixey> ok great
01:14:26 <prb> vixey: If you added any less, it wouldn't be an equivalence relation.
01:14:52 <vixey> if you have a irreflexive relation |>
01:15:13 <vixey> the transitive closure < of |> is a ordering I thin
01:15:34 <vixey> and the symmetric transitive closure ==> of |> is like an evaluation
01:15:47 <vixey> then the reflexivity symmetric transitive closure is =
01:16:47 * CakeProphet needs to take college math.
01:18:59 <vixey> If I make closure an operation
01:19:16 <vixey> like (R1) C (R2) is the R1 closure of R2
01:19:35 * vixey wonders what C does :?
01:19:47 <vixey> it's indempotent is it?
01:21:11 * vixey should stop blethering and asking silly questions now...
01:21:14 <CakeProphet> > let fun = 'h':'a':fun in fun
01:21:16 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
01:21:31 <CakeProphet> vixey: you need to find more easily satisfying hobbies.
01:21:36 <CakeProphet> like me.
01:25:07 <Myrth> anyone here worked with ocaml, python or erlang also?
01:25:18 <CakeProphet> Python here.
01:25:37 <prb> Erlang and Python both.
01:25:46 <Myrth> which one do you prefer?
01:25:54 <prb> Haskell.
01:26:19 <vixey> I only actually used ocaml, but I've programmed in python and erlang to learn at least a bit about them
01:26:22 <angelixd> prb: are you a software engineer?
01:26:23 <prb> Erlang's anonymous function syntax is unpleasant.
01:26:40 <prb> angelixd: I've written a little bit in my time... :)
01:27:29 <mattam> A lot of ocaml and some python here.
01:27:43 <Myrth> i've learned syntax and concepts for all these, but found that i'm starting to get confused, so want to choose one and make a project with it
01:28:10 <CakeProphet> > foldr (,) () [1.10]
01:28:11 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a, b)
01:28:12 <lambdabot>        Exp...
01:28:14 <CakeProphet> > foldr (,) () [1..10]
01:28:16 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a, b)
01:28:16 <lambdabot>        Exp...
01:28:17 <prb> Myrth: Sounds like a worthwhile exercise with any of the above.
01:28:45 <quicksilver> Myrth: python is an utterly uninteresting language :)
01:28:49 <vixey> CakeProphet, since the type of that fold would depend the length of the list.... :)
01:28:52 <angelixd> myrth: do you have a particular project in mind, or do you just want to learn another language?
01:29:02 <vixey> quicksilver, :p I agree
01:30:00 <mattam> vixey: so can you formalize the closure operator? It takes a predicate on relations and a relation right, not two relations?
01:30:03 <Myrth> angelixd: i have few projects in mind, but don't want to get too serious with it, cause right now i'm pretty busy with primary money maker (php)
01:30:13 <joed> Ick.
01:30:25 <vixey> mattam, oh haven't tried yet, I was just mumbling
01:30:40 <angelixd> hey, don't knock what pays the bills.  I do perl for a living and enjoy it; but am picking up haskell for fun
01:30:59 <vixey> mattam, It's kind of tricky though, at least not immediately clear how to replace one constructor with another
01:31:12 <CakeProphet> Myrth: I've got parts of a text-based game in Python, but it's been a while since I've picked it up
01:31:16 <joed> Yeah, I'm doing Javascript, Flash, Java right now, PHP is taking it too far ...
01:31:29 * joed ducks.
01:31:42 <CakeProphet> I could only handle Javascript out of those.
01:31:55 <quicksilver> flash is javascript with a different standard library
01:31:56 <Myrth> angelixd: long time i've made prolog interpreter in C just for fun and recent hype with functional languages woke up the interest
01:32:00 <Myrth> *long time ago
01:32:01 <vixey> I think I will try it
01:32:05 <quicksilver> (and a GUI tool for building animations, if you're into that)
01:32:06 <joed> quicksilver: Yep.
01:32:42 <prb> joed: With canvas coming and better performance in the browser, javascript is looking more and more interesting.
01:33:29 <Myrth> in my opinion javascript is greatly underappreciated
01:33:47 <joed> prb: I looked at canvas a long time ago, for UI I doubt flash will be killed, last long time contract I did was in Laszlo, which is XML+Javascript
01:34:31 <joed> prb: The output is Flash, and it is fairly decent event driven Javascript and 'Objects' or entities.
01:35:21 <joed> prb: Then if you actually want to pass any decent amount of data, all the neat stuff is rather useless.
01:36:12 <prb> joed: I looked at Laszlo passingly.  I've had contact with apps intended to serve JSON To Flash clients.
01:36:39 <mattam> vixey: Maybe you can define [Inductive C (by : relation A -> relation A) (of : relation A) : relation A := include : forall x y, of x y -> C x y | closed : forall x y, by C x y -> C x y.]
01:36:51 <joed> Right, that won't work, you need to pass XML, the JSON shortcut was removed around 3 releases ago.
01:36:57 <CakeProphet> Inductive C... sounds like a cool programming language.
01:37:10 <prb> So, Flash won't take JSON or Laszlo won't?
01:37:36 <joed> prb: Laszlo wont unless you write your own data parser.
01:38:02 <mattam> CakeProphet: it's Coq.
01:38:17 <mattam> vixey: no you can't, it's not positive :(
01:38:18 <CakeProphet> wat?
01:38:23 <prb> joed: Gotcha.  The JSON support in Haskell is there, so I've thought about it as the backend for visualization apps that target either canvas (FF 3.1) or Flash clients.
01:39:00 <joed> prb: Yeah, then you are golden.
01:39:01 <mattam> CakeProphet: Coq is a proof-assistant including a purely functional programming language with inductive/algebraic datatypes.
01:39:08 <Myrth> anyone used happs?
01:39:29 <prb> Myrth: Plenty of folks do.  There's a channel for it.
01:39:38 <prb> #happs
01:39:44 <mmorrow> @tell rwbarton some optims for you bf2elf compiler :) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=708
01:39:45 <lambdabot> Consider it noted.
01:39:50 <joed> prb: My last contract we wrote most of the Leapfrog child games websites in Laszlo, hence I think I ran into every problem you could.
01:40:23 <prb> joed: Interesting!
01:41:18 <joed> prb: We were asked to do a complete Javascript based art studio and image upload download suite, that in flash 8 is akin to getting a blunt object and repeatedly hitting your toes.
01:41:37 <prb> joed: Once upon a time I wrote a bunch of interactive labs for vector calc in Maple.  (I used to be a math prof...)  It would be nice to have that in browser in modern times.
01:42:04 <joed> THat you could easily do and back with haskell.
01:42:23 <vixey> mattam, with slight change, I think it works!
01:42:27 * cizra grumbles. Why don't more programming languages have functions like interact :: (String -> String) -> IO ().
01:42:47 <vixey> mattam, closed : forall t t', by of t t' -> closure by of t t'.
01:42:55 <CakeProphet> :t interact
01:42:57 <lambdabot> (String -> String) -> IO ()
01:43:23 <mmorrow> @src interact
01:43:23 <elbar> @bf ++[-]
01:43:23 <lambdabot> interact f = do s <- getContents; putStr (f s)
01:43:24 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
01:43:24 <vixey> so you can define open relations,  like   symmetric (r : relation A) : relation A := r a b -> symmetric b a
01:43:41 <mmorrow> elbar: it's a shame that's broken :(
01:43:46 <elbar> aye
01:43:59 <vixey> oh... it's not quite that though is it
01:44:06 <elbar> vanishing resources ... never good =)
01:44:16 <mmorrow> heh
01:46:00 <CakeProphet> vanishing resources AND broken pipes is even worse.
01:46:57 <elbar> who cleans up all the mess? :P
01:47:07 <vixey> mattam, do you think this is good: close : forall t t', closure by (by of) t t' -> closure by of t t' ?
01:47:18 <CakeProphet> I'm pretty sure I just discovered the set of all pluming jokes.
01:47:35 <mattam> vixey: It's quite funny... You can't prove idempotency for this one it seems
01:47:40 <idnar> plumbing
01:47:57 <CakeProphet>  //  the set of all funny jokes.
01:47:58 <mgsloan> hmm, why has Graphics.X11.Xlib disappeared from the std libs, and where can recent versions/docs be gotten?
01:48:03 <vixey> mattam, perhaps it's not indempotent? I just guessed at it
01:48:08 <mattam> That's what I ended up trying too :)
01:48:10 <vixey> oops
01:48:12 <vixey> idempotent
01:48:37 <Myrth> > interact "test"
01:48:38 <lambdabot>   Couldn't match expected type `String -> String'
01:48:50 <CakeProphet> :t interact
01:48:52 <lambdabot> (String -> String) -> IO ()
01:48:59 <CakeProphet> Myrth: you want a function. ;)
01:49:03 <mgsloan> > interact (const "test")
01:49:05 <lambdabot>   * Exception: "<IO ()>"
01:49:16 <Myrth> > interact (\x->x)
01:49:18 <lambdabot>   * Exception: "<IO ()>"
01:49:23 <CakeProphet> Myrth:  but no on lambdabot, because she doesn't like IO actions.
01:49:30 <CakeProphet> *not
01:49:41 <Myrth> "she" ? :)
01:49:51 * vixey can't figure out how to take the closure of closure...
01:50:01 <CakeProphet> pop open ghci though and try (interact id)
01:50:05 <CakeProphet> :D
01:50:22 <mgsloan> Myrth - here's a pic of her here - http://www.haskell.org/haskellwiki/Lambdabot
01:50:54 <idnar> does her husband beat her or something?
01:51:00 <CakeProphet> oh... I just used she because I'm used to reading it in tabletop game handbooks.
01:51:05 <mbz> mgsloan, 1st, the xlib bindings are incomplete.
01:51:05 <mbz> and 2nd, have you tried to search on hackage?
01:51:40 <CakeProphet> @src id --for Myrth
01:51:41 <lambdabot> Source not found. It can only be attributed to human error.
01:51:41 <Myrth> how (const "test") is a function?
01:51:46 <CakeProphet> ...
01:51:47 <mgsloan> mbz - ah
01:51:49 <CakeProphet> @src id
01:51:49 <lambdabot> id x = x
01:52:05 <mgsloan> i did do a browser find for "xlib" but not a hackage search
01:52:38 <idnar> @src const
01:52:38 <lambdabot> const x _ = x
01:52:49 <mgsloan> mbz - I don't really need much.. just want to do some fast 2d pixel manip and mouse/key input
01:52:53 <idnar> you could write that as const x = \_ -> x if you prefer
01:53:11 <idnar> const x is a function of one argument, that ignores its argument and evaluates to x
01:53:23 <idnar> Myrth: ^^^
01:53:33 <Myrth> what means \_ ?
01:53:45 <Myrth> lambda anything?
01:53:53 <CakeProphet> _ = don't care
01:53:59 <CakeProphet> doesn't assign the parameter a name
01:54:11 <Myrth> yeah but why backslash (lambda)
01:54:21 <CakeProphet> because it's a lambda.
01:54:22 <CakeProphet> ...
01:54:59 <cizra> Not in scope: `getArgs' -- hey, I thought getArgs was in prelude, in other words in every Haskell program?
01:55:06 <mbz> mgsloan, try bindings to opengl/glut
01:55:11 <Myrth> lol it will take some time... how many ways are there to write map function? :)
01:55:11 <CakeProphet> cizra:  noep. I think it's in System.
01:55:26 <cizra> CakeProphet: Oh, thanks
01:55:31 <mgsloan>  mbz - good suggestion, but really I just want to screw around pixels stored in arrays :)
01:55:34 <mattam> vixey: not sure it's actually possible to define it that way... We may need that by is a monotone operator.
01:55:36 <CakeProphet> Myrth: ...infinite. ;)
01:55:40 <quicksilver> mgsloan: xlib would be a terrible way to use 2D graphics
01:55:46 <Axman6> mgsloan: it's just like f _ = foo, \_ -> foo
01:55:47 <quicksilver> ;)
01:56:09 <quicksilver> opengl or sdl, I suggest
01:56:14 <mgsloan> quicksilver, true, if one sends x server commands to plot points.. I've already tried that method as a matter of fact
01:56:27 <mgsloan> but i've read you get decent perf if you copy from a shared image
01:56:36 <Myrth> so const x _ = x is the same like const x = \_ -> x
01:56:36 <vixey> mattam, is there a way to construct an inductive from a proof of a monotonicity?
01:56:59 <vixey> mattam, I saw tarski fixed point thereom, but.. it used an axiom
01:57:00 <mgsloan> I suppose opengl would indeed have to circumvent the X11 layer
01:57:03 <mgsloan> hmm
01:57:06 <CakeProphet> > let map _ [] = []; map' f (x:xs) = f x : map f xs in map (*10) [1.100]
01:57:07 <mbz> mgsloan, darcs repo:  http://darcs.haskell.org/X11
01:57:08 <lambdabot>   * Exception: /tmp/4776193917748772458:71:60-72: Non-exhaustive patterns in ...
01:57:14 <mgsloan> mbz - ah thanks
01:57:19 <quicksilver> mgsloan: xlib is a very low level api, it's just not terribly convenient ;)
01:57:21 <quicksilver> that's all.
01:57:22 <CakeProphet> > let map' _ [] = []; map' f (x:xs) = f x : map f xs in map' (*10) [1.100]
01:57:24 <lambdabot>   [11.0]
01:57:27 <CakeProphet> ...
01:57:49 <mattam> vixey: I don't think so, it would be great :) Inductives are second-class in Coq.
01:57:49 <mgsloan> quicksilver - right, right. really all i need is b/w blitting though
01:57:52 <CakeProphet> > let map' _ [] = []; map' f (x:xs) = (f x) : (map f xs) in map' (*10) [1.100]
01:57:54 <lambdabot>   [11.0]
01:57:58 <CakeProphet> lolwhut
01:58:01 <mbz> mgsloan, I tried to use xlib for doing simple 2d graphics last week. it was awful
01:58:17 <mgsloan> ah
01:58:22 <CakeProphet> > let map' _ [] = []; map' f (x:xs) = (f x) : (map f xs) in map' (*10) [1..100]
01:58:24 <lambdabot>   [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210...
01:58:26 <CakeProphet> o lawl.
01:58:44 <CakeProphet> Myrth: yes.
01:58:52 <CakeProphet> because of partial application.
01:59:24 <mgsloan> I really really wish I could just fiddle with the screen's buffer
01:59:49 <mbz> mgsloan, there are functions with 10-12 arguments inside xlib. are you sure you want use this crappy lib?
02:00:08 <CakeProphet> > map (subtract pi) [2,4..100]  -- Myrth: same reason I can do this
02:00:10 <lambdabot>   [-1.1415926535897931,0.8584073464102069,2.858407346410207,4.858407346410207...
02:00:43 <CakeProphet> :t subtract
02:00:45 <lambdabot> forall a. (Num a) => a -> a -> a
02:00:48 <CakeProphet> :t subtract pi
02:00:50 <lambdabot> forall a. (Floating a) => a -> a
02:02:02 <mgsloan> mbz - it does kinda suck, but really I just need to call enough functions to setup a block of memory, and the XImage descriptors for it, to act as a backbuffer
02:02:09 <mgsloan> then just twiddle away and alls well
02:02:45 <Myrth> there's no difference in performance for doing same thing different ways?
02:03:00 <Myrth> is there some guidelines on how to know the best?
02:03:04 <Myrth> or just testing
02:03:41 <CakeProphet> Myrth:  there's some things you can do... like using (:) recursive is going to be much faster than (++)
02:04:00 <Myrth> CakeProphet: because (++) makes copy of the whole string
02:04:03 <CakeProphet> but profiling can tell you if something is faster.
02:04:14 <CakeProphet> Myrth: yes. any list for that matter.
02:04:41 <Myrth>  do all functions make copy of their arguments?
02:05:14 <Myrth> or it's just poor implementation of "++" ?
02:05:20 <CakeProphet> -shrug- dunno. Haskell is compiled so there's no telling what happens to your code after optimization/translation-to-equivalent-assembly
02:05:46 <CakeProphet> @src (++)
02:05:47 <lambdabot> []     ++ ys = ys
02:05:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:05:47 <lambdabot> -- OR
02:05:47 <lambdabot> xs ++ ys = foldr (:) ys xs
02:06:51 <opqdonut> Myrth: it has to make a copy to keep referential transparency
02:07:09 <CakeProphet> ++ is slow(er) because of the recursion there.
02:07:27 <opqdonut> Myrth: and yes, it matters how you do things
02:07:35 <Myrth> CakeProphet: you just said: "like using (:) recursive is going to be much faster than (++)"
02:07:36 <Myrth> :)
02:07:48 <opqdonut> but the compiler is pretty smart, yes
02:08:25 <CakeProphet> Myrth:  yes. Because ++ recurses for each of your recursions.
02:08:29 <CakeProphet> which adds up
02:08:36 <CakeProphet> (:) does not
02:08:44 <vixey> Myrth, "foo" ++ "bar" doesn't copy "bar"
02:09:10 <vixey> Myrth, infact there is no copying, it has to create new cons cells, the values inside them can be shared
02:09:22 <mgsloan> well, ++ should at least behave lazily, right?
02:09:47 <Myrth> opqdonut: i'm not sure what "referential transparency" is, but why (++) couldn't be implemented like whatever is used instead of it?
02:10:08 <mgsloan> > take 10 (repeat 'x' ++ "yyy")
02:10:10 <lambdabot>   "xxxxxxxxxx"
02:10:12 <vixey> Myrth, what do you not like about the implementation?
02:10:39 <Myrth> vixey: in tutorial it's suggested not to use ++ for string concatenations, right?
02:10:49 <Myrth> for long strings
02:10:51 <vixey> Myrth, that's a rubbish tutorial
02:11:25 <vixey> Myrth, well if you are dealing with large textfiles, you wouldn't use String aat all really. so (++) isn't in question
02:11:32 <mbz> mgsloan, so all you want is just access to the 'raw video memory'?
02:11:33 <vixey> textfiles/datafiles
02:11:47 <mgsloan> mbz - yup that'd be awesome
02:12:10 <vixey> mgsloan, I've done that, it's  not very interesting
02:12:31 <mgsloan> well it's interesting when you have an application for it
02:13:20 <CakeProphet> Myrth, (:) and (++) do entirely different things.
02:13:51 <CakeProphet> > a:b:c:[]
02:13:53 <lambdabot>   [a,b,c]
02:14:01 <vixey> > [a] ++ [b] ++ [c] ++ []
02:14:02 <lambdabot>   [a,b,c]
02:14:12 <CakeProphet> :D
02:14:50 <vixey> blegh
02:15:03 <mgsloan> hehe i wonder if these clever vars have Enum defined
02:15:04 <CakeProphet> :o ?
02:15:09 <mgsloan> > [a..]
02:15:09 <vixey> I can't even show that transitive/symmetric/reflexive closure = symmetric/transitive/reflexivie closure
02:15:10 <idnar> > [a..]
02:15:11 <lambdabot>   [* Exception: not a number
02:15:12 <lambdabot>   [* Exception: not a number
02:15:12 <idnar> heh
02:15:20 <mgsloan> :)
02:15:20 <Axman6> interesting
02:15:26 <idnar> > succ a
02:15:27 <lambdabot>   succ a
02:15:32 <idnar> doh
02:15:35 <mgsloan> lol
02:15:36 <CakeProphet> vixey:  ...don't sweat it
02:15:59 <izzy1> whats the easiest way to show all the constructor names for a data type? i like to build code to show constructor names as a html table headers. ive been reading template haskell and syb but im overwhelmed. is there an easy way?
02:16:00 <CakeProphet> @src Expr
02:16:01 <lambdabot> Source not found. :(
02:16:19 <vixey> izzy1,should be easier with deriving Data and the Data stuff
02:17:34 <vixey> izzy1, this stuff is what I mean http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html
02:18:06 <vixey> izzy1, showConstr gives the constructor name and so on
02:18:51 <izzy1> i see, thats what im struggling on right now. i thought it was part of syb
02:19:05 <izzy1> i guess i need to read up on what Proxy is
02:19:18 <izzy1> im looking at the RJson package now
02:19:20 <vixey> izzy1, huh? Proxy isn't mentioned on the page
02:19:52 <izzy1> Proxy is in RJson... sorry for the confusion
02:20:34 * cizra ponders let strip = reverse . dropWhile (\x -> x /= ' ') . reverse
02:21:05 <cizra> > let strip = reverse . dropWhile (\x -> x /= ' ') . reverse in strip " foo foo    "
02:21:06 <lambdabot>   " foo foo    "
02:21:15 <cizra> > let strip = reverse . dropWhile (\x -> x == ' ') . reverse in strip " foo foo    "
02:21:16 <lambdabot>   " foo foo"
02:21:30 <cizra> > let strip = reverse . dropWhile (\x -> x == ' ') . reverse . dropWhile (\x -> x == ' ') in strip " foo foo    "
02:21:31 <lambdabot>   "foo foo"
02:21:53 <mmorrow> kill!!
02:21:54 <mmorrow> haddock: internal Haddock or GHC error: renameDecl
02:22:14 * mmorrow return to trying to get the harpy docs to build
02:22:30 <mattam> vixey: | closed : forall R, subrelation R (C by of) -> subrelation (by R) (C by of).
02:23:11 <Axman6> http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Merge_sort i think the haskell version could be nicer (even if it is damn short compared to the others
02:24:07 <vixey> mattam, hm, why is the (by R) on the right of -> ?
02:24:09 <mattam> vixey: That makes the thing positive, idempotent and it seems like it's really the closure.
02:24:45 <jberryman> > let strip = unwords . words in strip "    foo  foo "
02:24:47 <lambdabot>   "foo foo"
02:24:54 <mattam> subrelation is just relation inclusion, so it unfolds to an ->, and (by R) is on its left.
02:25:53 <vixey> I see, cool!
02:26:02 <mattam> Monotonicity is not even needed here. But it may be useful later.
02:26:08 <Axman6> i don't like seeing 'splitAt (length xs `div` 2) xs' in mergesort :\
02:26:23 <Myrth> > ((*) 1 ((-) 2 3)) -- hey you can write in haskell like in lisp :)
02:26:25 <lambdabot>   -1
02:27:30 <Axman6> Myrth: but please don't >_<
02:27:37 <Myrth> lol
02:27:49 <mattam> The trick relies on impredicativity basically.
02:30:32 <idnar> Axman6: what about http://en.literateprograms.org/Merge_sort_(Haskell) ?
02:31:21 <idnar> Axman6: although I guess that might be even worse than splitAt
02:32:35 <Axman6> yeah, i was reading a better version that used two functions odds and evens to split  the list into two even lists, then a function halves xs = (odds xs, evens xs), which gave good performance due to laziness
02:32:53 <Martijn> $ cabal install zlib
02:32:53 <Martijn> Resolving dependencies...
02:32:53 <Martijn> Downloading zlib-0.5.0.0...
02:32:53 <Martijn> cabal: Error: some packages failed to install:
02:32:53 <Martijn> zlib-0.5.0.0 failed while downloading the package.
02:33:07 <idnar> Axman6: see also http://neilmitchell.blogspot.com/2008/03/sorting-at-speed.html I guess
02:33:08 <Axman6> and didn't involve traversing the entire list for every iteration
02:34:29 <idnar> but I suppose the question is, what's the goal? readability, performance, ...?
02:34:43 <Axman6> performance usually
02:34:57 <idnar> Axman6: no, I mean for that wiki page
02:35:10 <idnar> if you want performance, then you probably don't want pure merge sort anyway
02:36:56 <mmorrow> success!
02:37:36 <mmorrow> in case anyone has been trying to get the harpy docs to build, making this temporary mod to Harpy.Call makes haddock succeed (i have no idea why)
02:37:37 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=710
02:42:18 <Axman6> idnar: no idea, probably readability i guess. but i think performance versions should be put there too, so that people may use them without reinventing the wheel badly
02:43:42 <Axman6> added another quicksort version i picked up somewhere that's rather fast to http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Quicksort#Haskell
02:46:35 <cizra> Gosh, GHC gets confused when trying to infer types for my (Ord a, Show a, Read a) data.
02:46:48 <cizra> Or perhaps am I doing something wrong? /me pastes
02:48:30 <cizra> http://hpaste.org/13519#a1 -- the error disappears when I remove the read  in (getFirst a, read . getLast $ a)
02:49:17 <Axman6> @pl (\f x -> (f x, x))
02:49:18 <lambdabot> ((,) =<<)
02:49:39 <opqdonut> cizra: just give a typesig for split
02:50:08 <cizra> opqdonut: Split? Oh, I thought I have to do it for ord. Mm.. can I do type signatures in where-clauses?
02:50:20 <opqdonut> yeah
02:50:26 <opqdonut> where f :: something
02:50:33 <opqdonut>     f = foo bar
02:50:37 <Axman6> where f :: a -> b; f = ergkajz
02:50:45 <cizra> thanks!
02:50:48 <opqdonut> and please, use one where
02:50:52 <opqdonut> not a bunch of nested ones
02:50:54 <Axman6> ; can be replaced with a new line of course (and should be)
02:51:39 <hugo___> good morning
02:51:39 <cizra> opqdonut: I reckoned it's best to keep the scope tight?
02:52:17 <cizra> opqdonut: I agree, though, that it hurts readability.
02:52:19 <opqdonut> well they're anyway hidden inside the parse scope
02:52:46 <opqdonut> and by the way
02:52:59 <opqdonut> :t \a b -> compare (snd a) (snd b)
02:53:00 <lambdabot> forall a a1 b. (Ord b) => (a, b) -> (a1, b) -> Ordering
02:53:04 <opqdonut> :t comparing snd
02:53:06 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
02:53:06 <maltem> cizra: if you've got too much 'where's, look if you can just make some functions top-level
02:53:36 <opqdonut> so you could just redefine cmp as "comparing snd" and inline it
02:55:04 <cizra> maltem: I'm against polluting top-level with one-time useless crap. And yes, opqdonut's suggestion about moving them into one where-clause looks good.
02:55:50 * mpwd doesn't believe in too many where's
02:56:12 * vixey puts an entire file in a where block once
02:56:19 <vixey> (except the one function)
02:56:25 <opqdonut> vixey: yeah, Module X where ... ;)
02:56:29 <vixey> haha
02:56:33 * mpwd high fives vixey
02:57:13 <maltem> cizra: a matter of taste... personally I just love short and tiny functions
02:58:06 <maltem> (which I may later recognize to be reusable, even)
02:58:07 <opqdonut> i tend to move things outside where when they _could_ be reused
02:58:33 <opqdonut> and I try to write top-level combinators that keep my where-definitions short and sweet
02:58:36 <paper_cc> :t compare `on` snd
02:58:38 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
02:58:58 <mpwd> maltem: If they are reusable and you've disciplined yourself to keeping a tidy namespace you can just bring them out of where-clauses.
02:59:18 <opqdonut> yeah it's a design decision
02:59:21 <opqdonut> each to his own :)
02:59:34 <mmorrow> i see where clauses as giving functions the ability to have little private modules of their own
03:00:06 <mmorrow> i mean, taking these suggestions to the extreme, why don't we just do away with modules completely ;)
03:00:14 <maltem> :t let ing = on in compare `ing` snd
03:00:16 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
03:00:18 <cizra> I like it very much, it makes possible to write utility functions without polluting other stuff.
03:02:25 <idnar> there's a balance to be found between locality and generality
03:02:35 <maltem> mmorrow: see, a design descision and matter of taste :) because I see where clauses as a way to define functions in a place where the arguments of the top-level functions are in scope
03:03:11 <mpwd> Also, it's basic mathematical practice; mathematicians all the time are "Let (blah,blah,blah) be an ordered 3-tuple where ..."
03:03:12 <mmorrow> maltem: i hate doing that!! :)
03:03:31 <vixey> mpwd, what is?
03:03:42 <mpwd> vixey: Where clauses
03:03:50 <vixey> but that is a let??
03:04:04 <mpwd> vixey: It's a let and a where :)
03:04:47 <mpwd> ...I will admit to using both when I feel like that's how I would write it in a mathematical proof...
03:04:56 <mmorrow> maltem: otoh, that is precisely how i use "let"
03:04:58 <maltem> mmorrow: if I hated doing that, I wouldn't use where clauses at all :)
03:05:26 <vixey> (if there was one module system which covers modules and 'where clauses', you can probably do stuff like,  :t foo.bar   bar being a where clause)
03:05:44 <vixey> or even > foo.bar f1 f2 ... b1 b2 ...
03:06:01 <maltem> vixey: yay for parameterized modules, I say
03:06:03 <vixey> although that might not make as much sense
03:07:38 <ski_> (vixey : it could be nice for testing)
03:07:53 * ski_ sometimes misses `local'
03:08:10 <vixey> what's local from?
03:08:18 <ski_> SML
03:08:25 <vixey> ohh
03:08:27 <vixey> I don't know SML
03:08:29 <dmhouse> :type local -- :)
03:08:31 <maltem> ski_: again, yay for nested module declarations, I say :)
03:08:43 <ski_> `<decl> ::= ...  |  local <decl> in <decl> end'
03:09:32 <ski_> so you can `local frob x = ... in foo x = ..frob..; bar x = ..frob.. end'
03:09:55 <mmorrow> * asgaroth has quit ("Lost terminal")
03:09:55 <mmorrow> <mpwd> ...I will admit to using both when I feel like that's how I would write it in a mathematical proof...
03:10:01 <mmorrow> heh, i admit doing this too
03:10:12 <mmorrow> oops on "* asgaroth has quit ("Lost terminal")" :)
03:10:44 * maltem was thinking my IRC client were broken
03:11:00 <mpwd> mmorrow: Hooray for the Curry-Howard isomorphism
03:11:10 <vixey> Curry-Howard
03:11:13 <ski_> (that would provide `foo' and `bar', but hide `frob')
03:11:43 <ski_> Curry-Howard-Lambek
03:12:40 <maltem> While we're at it, some book claims that currying should really be schönfinkeling
03:13:09 <Adamant> only if you're German
03:13:59 <maltem> Adamant: Schöfinkel wasn't German, afaik
03:14:49 <Adamant> he was of German Jewish extraction living in Russia, looks like
03:15:03 <maltem> hm ok
03:15:13 <maltem> ok Wikipedia says it could also be Freging
03:15:22 <vixey> Freig* ?
03:15:30 <hugo___> eh
03:15:31 <mpwd> Frege
03:15:44 <hugo___> who cares ? :P
03:16:03 <mpwd> hugo___: Logicians, historians of theoretical computer science.
03:16:19 <hugo___> anyway, it works, so... lets call it bananaing
03:16:31 <Adamant> maltem: Russia brought in a lot of Western European advisors post-Peter the Great
03:21:23 <maltem> hugo___: maybe the point of currying is that you can add spice one portion after the other, but you have to care not to give too much to the meal, too
03:22:24 <hugo___> well, its just the name discussion that i think its pointless...
03:23:19 <maltem> er, sorry to have stolen your precious time
03:24:35 <mattam> hugo___: proper attribution (even to dead people) is a reasonnable goal.
03:26:49 <mpwd> Galois gets a whole theory and a company named after him despite the fact that he founded neither :P
03:28:06 <hugo___> who is galois ?
03:28:42 <mattam> Évariste Galois, a mathematics genius.
03:28:45 <dmhouse> http://en.wikipedia.org/wiki/Evariste_galois
03:29:05 <dmhouse> "Évariste Galois (French pronunciation: [evaʁist ɡalwa]; October 25, 1811 – May 31, 1832) was a French mathematician born in Bourg-la-Reine. While still in his teens, he was able to determine a necessary and sufficient condition for a polynomial to be solvable by radicals, thereby solving a long-standing problem. "
03:29:35 <hugo___> what is the theory that is named after him ?
03:30:02 <dmhouse> http://en.wikipedia.org/wiki/Galois_theory
03:31:10 <hugo___> oh
03:31:15 <mpwd> dmhouse: I'll grant that he founded Galois theory... sorry...
03:31:17 <hugo___> those french people... always on the vanguard
03:31:41 <hugo___> maybe we should all switch to ocaml
03:31:50 <mpwd> dmhouse: There is a lot to his namesake theory that I'm sure he didn't grok.
03:32:58 <dmhouse> Well, of course.
03:33:17 <mpwd> there are parts of the theory we don't grok though :)
03:33:57 <dmhouse> I still have a lot of respect for him for solving an outstanding, important problem in mathematics whilst my age
03:34:07 <njbartlett> I don't think groking was a very fashionable activity in 19th Century France
03:34:20 <hugo___> i would like to understand mathematics... :/ but i guess now i suffer from too much bad teaching to be able to learn it properly
03:35:07 <mattam> hugo___: you can always lose yourself inside wikipedia as a substitute.
03:35:21 <mpwd> hugo___: Psh.  I don't think there's a proper way to learn math.
03:36:25 <mpwd> hugo___: A Prof of mine has a book called "The Haskell Road to Maths" which is kind of cool
03:37:27 <hugo___> maths teachers seem to suffer from too many psychological diseases... its probably the effects of too much math :P
03:37:37 <hugo___> and they all worship cauchy as a god
03:37:39 <mpwd> hugo___: Another cool book is "Concrete Mathematics" by Donald Knuth
03:38:23 <mpwd> hugo___: Blasphemers.  They just haven't heard the word of Godel...
03:38:59 <angelixd> i can't believe i'm hearing math professor bashing in a haskell channel
03:40:03 <mpwd> angelixd: Um, I was being tongue and cheek.  I'm a grad student in math...
03:40:39 <angelixd> leave it to me to take things too seriously
03:42:31 <mpwd> I think hugo might have been given a rough time by crazy math teachers, though.  But it's true that math teachers are crazy.  One of my undergrad profs named his daughter Cayley...
03:43:18 <mattam> Oh dear.
03:43:19 <angelixd> wow.
03:43:46 * Badger chuckles
03:44:00 <mattam> Sadly, concrete math is out of print.
03:48:01 <mmorrow> does anyone know the way to allow a program to exec data with "chcon"?
03:48:08 <mmorrow> i knew at one point..
03:48:43 <Gooddamn> ewrything about computers here>  http://www.lostworlds.lv/go.php?1139709442
03:49:14 <mmorrow> oh my
03:50:43 <mmorrow> Gooddamn: are you a bot?
03:50:53 <mmorrow> @where ops
03:50:53 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
03:51:23 <Axman6> damn, that is effective
03:51:31 <Gooddamn> all about computers go here>  http://www.lostworlds.lv/go.php?1139709442
03:51:33 <Gooddamn>  http://www.lostworlds.lv/go.php?1139709442
03:51:38 <mmorrow> i haven't looked at the link, but Gooddamn should probably be kickbanned
03:51:55 <idnar> it's one of these "get people to click on your link" games
03:52:03 <Gooddamn> try  it and you wil see heree>  http://www.lostworlds.lv/go.php?1139709442
03:52:05 <idnar> whatever they're called
03:52:13 <cizra> idnar: spam?
03:52:16 <mmorrow> heh
03:52:40 <Axman6> Gooddamn: if you're a bot, you won't be listening, if you aren't, fuck off
03:53:02 <idnar> Axman6: if he's a bot, he doesn't care; if he's not, he still doesn't care :P
03:53:05 <Gooddamn> no this is not spam go here>  http://www.lostworlds.lv/go.php?1139709442
03:53:10 <Gooddamn> all for free>  http://www.lostworlds.lv/go.php?1139709442
03:53:16 <ziman> @where ops
03:53:16 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
03:53:29 <Gooddamn> get free mony here>  http://www.lostworlds.lv/go.php?1139709442
03:53:29 <Badger> yay, mass ping!
03:53:52 <Badger> Gooddamn: here's the choice
03:53:54 <Badger> leave now
03:53:56 <Badger> or leave, now
03:55:09 <idnar> If you say a word I will cut off your heads; and if you do not say a word, I will also cut off your heads.
03:55:32 <Gooddamn> go here>  http://www.lostworlds.lv/go.php?1139709442
03:55:32 <cizra> Yeah. Both of them.
03:55:41 <Axman6> heh, DoS'd?
03:55:47 <Gooddamn> best chat ewer>  http://www.lostworlds.lv/go.php?1139709442
03:56:54 <Badger> @src fix
03:56:54 <lambdabot> fix f = let x = f x in x
03:56:59 <Badger> ohyes.
03:57:21 <Badger> hrm
03:57:25 <Badger> @hoogle forever
03:57:25 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
03:57:47 <mpwd> @src forever
03:57:47 <lambdabot> Source not found. Take a stress pill and think things over.
03:58:04 <baaba> > fix cos :: Double
03:58:06 <lambdabot>   * Exception: stack overflow
03:58:45 <ziman> forever a = fix (a >>) ;)
03:58:46 <Axman6> mpwd: forever x = x >> forever x
04:00:34 <quicksilver> sorry
04:00:37 * quicksilver was slow
04:01:00 <Badger> @hoogle fix
04:01:01 <lambdabot> Data.Function fix :: (a -> a) -> a
04:01:01 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
04:01:01 <lambdabot> module Control.Monad.Fix
04:06:20 <Badger> @hoogle randoms
04:06:20 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
04:20:51 <drbean_> lastlog drbean
04:22:19 <ac> hum, when I run "cabal install containers" I get the error: Could not find module `Data.Data'...
04:23:42 <mercury^> Is there a shorter way to express unzip . sortBy ((snd .) . compare . snd) . zip?
04:24:34 <ziman> @pl (snd .) . compare . snd
04:24:34 <lambdabot> (snd .) . compare . snd
04:24:38 <ziman> @unpl (snd .) . compare . snd
04:24:38 <lambdabot> (\ d j -> snd (compare (snd d) j))
04:25:42 <LimCore> guys?
04:25:51 <ziman> :t compare
04:25:51 <LimCore> are you writting code snippers or just bashing keyboards lol
04:25:52 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
04:26:19 <ziman> how can you take snd from Ordering?
04:26:31 <mercury^> ...
04:27:06 <mercury^> The function is the pointfree version of (\(_,a) (_,b) -> compare a b)
04:27:20 <opqdonut> :t comparing snd
04:27:22 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
04:27:23 <opqdonut> there
04:28:01 <mercury^> Which module is that from?
04:28:19 <Axman6> @index comparing
04:28:19 <ziman> @index comparing
04:28:19 <lambdabot> bzzt
04:28:20 <lambdabot> bzzt
04:28:25 <Axman6> @hoogle comparing
04:28:26 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:28:26 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:29:14 <mercury^> Thanks.
04:29:44 <opqdonut> comparing = (compare `on`)
04:29:48 <opqdonut> on is a useful combinator
04:29:51 <opqdonut> ?src on
04:29:51 <lambdabot> (*) `on` f = \x y -> f x * f y
04:37:06 <mmorrow> harpy fun: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=712#a712
04:37:26 <mmorrow> withCode :: [Word8] -> (FunPtr a -> IO b) -> IO b
04:37:29 <mmorrow> yay!!
04:38:09 <mmorrow> erm, actually harpy isn't even used in that particular file...
04:38:50 <hcube> hi! is there any standard function like this: func :: [[a]] -> [a] ?
04:39:04 <mmorrow> @hoogle
04:39:04 <lambdabot> No query entered
04:39:04 <lambdabot> Try --help for command line options
04:39:07 <mmorrow> @hoogle concat
04:39:07 <lambdabot> Prelude concat :: [[a]] -> [a]
04:39:07 <lambdabot> Data.ByteString concat :: [ByteString] -> ByteString
04:39:07 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
04:39:19 <ac> oh. Upgrading to ghc 6.10.1 solved that. I had no idea how behind I was :)
04:39:23 <hcube> wow
04:39:38 <mmorrow> hoogle [[a]] -> [a]
04:39:50 <mmorrow> @hoogle [[a]] -> [a]
04:39:50 <lambdabot> Prelude concat :: [[a]] -> [a]
04:39:50 <lambdabot> Data.List concat :: [[a]] -> [a]
04:39:50 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:39:59 <mmorrow> hoogle is nice
04:40:03 <hcube> thanks
04:40:06 <mmorrow> :)
04:40:07 <tristes_tigres> hi
04:49:12 <BONUS> @hoogle Applicative a => [a s] -> a [s]
04:49:13 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:49:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:49:13 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:50:26 <LimCore> hi paul424 \o/
04:50:38 <Peaker> does hoogle ignore the class context, or does it know Applicative f => Monad f ?
04:50:58 <BONUS> hmm
04:51:05 <BONUS> good question
04:51:36 <BONUS> but i can't use Control.Monad.sequence on something that's an Applicative but isnt a Monad :[
04:52:19 <EvilTerran> ?type foldr (liftA2 (:)) (pure [])
04:52:20 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
04:52:23 <quicksilver> you can use Control.Applicative.sequence though
04:52:40 <quicksilver> or maybe it lives in traversable, on reflection.
04:52:42 <quicksilver> yes, it does.
04:52:44 <BONUS> yeah
04:52:51 <quicksilver> sequenceA is the one you want.
04:53:01 <BONUS> its just strange that hoogle reports Control.Monad.sequence as matching the query
04:53:11 <BONUS> when i did @hoogle Applicative a => [a s] -> a [s]
04:53:16 <EvilTerran> yeah... i suspect it ignores the class contextr
04:53:41 <Peaker> @hoogle [a s] -> a [s]
04:53:42 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:53:42 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:53:42 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
04:54:38 <quicksilver> BONUS: hoogle is a bit approximate with typeclass contexts
04:54:43 <BONUS> ah
04:56:31 <Peaker> does it have some ad-hoc thing equating Applicative and Monad?
05:00:56 <quicksilver> Peaker: no.
05:01:12 <quicksilver> @hoogle ThisClassDoesNotExist a => [a s] -> a [s]
05:01:13 <lambdabot> Warning: Unknown class ThisClassDoesNotExist
05:01:13 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:01:13 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
05:01:28 <quicksilver> Peaker: it is willing to entirely ignore classes if it wants to.
05:01:46 <Peaker> quicksilver: why does sequenceA disappear, but sequence remains?
05:01:53 <Peaker> It seems to have a special case for Monads?
05:02:02 <quicksilver> that, I do not know.
05:02:13 <Peaker> perhaps because you might not know that some function you are looking for is in a monad..
05:02:16 <quicksilver> I guess sequenceA gets points for matching applicative exactly
05:02:21 <quicksilver> which lifts it up
05:02:29 <Peaker> @hoogle Handle -> String
05:02:30 <lambdabot> System.IO hGetContents :: Handle -> IO String
05:02:30 <lambdabot> System.IO hGetLine :: Handle -> IO String
05:02:30 <lambdabot> System.IO hShow :: Handle -> IO String
05:02:46 <quicksilver> sequenceA is still there
05:02:49 <quicksilver> it's just pushed down to 5th result
05:02:54 <quicksilver> I don't know the details of teh ranking code
05:03:04 <Peaker> quicksilver: ah
05:03:19 <Peaker> quicksilver: Well, look at how IO String matches String in the search
05:04:05 <Peaker> It does give the impression that hoogle tries to be agnostic as to whether your desired result is in a container type or not
05:13:33 <bohdan> how do I express [ k | k < [2..] and k * k <= n] ? (without using square root)
05:13:46 <bohdan> > [ k | k <- [2..] and k * k <= n]
05:13:47 <lambdabot>   Couldn't match expected type `t -> t1 -> a'
05:14:09 <bohdan> > [ k | k <- [2..] and k * k <= 100]
05:14:10 <lambdabot>   Couldn't match expected type `t -> t1 -> a'
05:14:48 <Axman6> > > [ k | k <- [2..], k * k <= 100]
05:14:50 <lambdabot>   <no location info>: parse error on input `>'
05:14:55 <Axman6> > [ k | k <- [2..], k * k <= 100]
05:15:05 <Axman6> ...
05:15:11 <lambdabot>   thread killed
05:15:22 <Axman6> :|
05:15:48 <Axman6> [ x | x <- [2..], x * x <= 100]
05:15:53 <Axman6> > [ x | x <- [2..], x * x <= 100]
05:16:09 <lambdabot>   thread killed
05:16:15 <Axman6> bohdan: well, that's how you'd do it, but lambdabot seems to be going crazy
05:16:20 <RayNbow> try it locally in GHCi
05:16:23 <tristes_tigres> @type takeWhile
05:16:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:16:41 <tristes_tigres> Axman6: you probably want takeWhile
05:16:42 <RayNbow> you'd see that ghci would only print "[2,3,4,5,6,7,8,9,10"
05:17:03 <bohdan> Axman6, it never terminates
05:17:04 <Axman6> ah that's right, that's why
05:17:10 <bohdan> I guess takewhile would work
05:17:24 <BONUS> well lambdabot can usually handle infinite sequences
05:17:29 <tristes_tigres> Axman6: GHCi has no way of knowing that once k*k has become greater than 100, it will stay so
05:17:35 <BONUS> oh yeah but theres that
05:17:41 <Axman6> tristes_tigres: i know
05:17:47 <bohdan> @pl x * x
05:17:47 <lambdabot> x * x
05:17:52 <bohdan> @pl \x -> x * x
05:17:53 <lambdabot> join (*)
05:18:05 * Axman6 prefers (^2)
05:18:10 <bohdan> @hoohle join
05:18:11 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
05:18:11 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
05:18:11 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
05:18:25 <bohdan> @src join
05:18:25 <lambdabot> join x =  x >>= id
05:18:59 <Peaker> @type (*)
05:19:00 <Axman6> bohdan: for the ((->) a) monad, it turns a function :: a -> a -> b into a -> b
05:19:01 <lambdabot> forall a. (Num a) => a -> a -> a
05:19:45 <Peaker> bohdan: the (r->) monad is considered the "Reader monad"
05:20:04 <Peaker> its actually spelled (->) r which is less readable, because infix types don't have sections, for some unknown reason
05:20:05 * Axman6 has no idea what that means :(
05:20:17 <Peaker> Axman6: what what means?
05:20:21 <tristes_tigres> takeWhile (\x->x*x<=100) [2..]
05:20:27 <Peaker> Axman6: "Reader monad"?
05:20:32 <Axman6> i don't know what the Reader monad is
05:20:43 <Peaker> Axman6: (->) a   is the Reader monad
05:20:53 <BONUS> also Reader
05:21:05 <BONUS> basically it's just a monad that reads from a common environment
05:21:17 <Peaker> Axman6: the reason its called reader is because all of the monadic values being combined have access to read some environment, but not modify it (as in the State monad)
05:21:28 <bohdan> so which one is a good monad tutorial?
05:21:40 <bohdan> I feel like I'm understanding the IO monad, but not monads in general
05:21:50 <tristes_tigres> >  takeWhile (\x->x*x<=100) [2..]
05:21:51 <Axman6> Peaker: ah, ok, starting to make sense (though i'm far too tired to really take it all in right now)
05:21:52 <lambdabot>   [2,3,4,5,6,7,8,9,10]
05:22:15 <BONUS> bohdan: this is pretty good imho http://spbhug.folding-maps.org/wiki/MonadsEn
05:22:18 <Peaker> bohdan: if you understand IO, then you understand how the type can be generalize from any    IO a       to  Monad m =>      m a   right?
05:22:19 <BONUS> also All About Monads
05:22:22 <BONUS> @where All About Monads
05:22:23 <lambdabot> I know nothing about all.
05:22:40 <BONUS> http://www.haskell.org/all_about_monads/html/index.html
05:22:52 <bohdan> Peaker, mm, not really. I understand the do, <- and >>= syntax
05:23:03 <bohdan> Peaker, but I don't quite understand why (*) is a monad
05:23:10 <bohdan> or for that matter, *what* is a monad
05:23:12 <Peaker> bohdan: you understand how  do and <-  are just unsugarted into >>= ?
05:23:27 <bohdan> Yeah
05:23:49 <Peaker> bohdan: so for IO, what are the types of (>>=) and return?
05:24:10 <Peaker> bohdan: also, do you know what "kinds" are?
05:24:21 <bohdan> Peaker, no I don't know what are kinds
05:24:40 <Peaker> bohdan: what is invalid about this type:   Int -> Int -> []   ?
05:24:48 <bohdan> >>= :: IO a -> IO b -> IO b
05:24:55 <bohdan> or somesuch :)
05:24:57 <Peaker> bohdan: no, that is the type of (>>)
05:25:01 <bohdan> @type (>>=)
05:25:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:25:06 <bohdan> ah right
05:25:08 <mercury^> @where anything
05:25:08 <lambdabot> I know nothing about anything.
05:25:13 <bohdan> >>= :: IO a -> (a-> IO b) -> IO b
05:25:23 <Peaker> bohdan: what is invalid about these types:   Int String -> IO -> []   ?
05:25:29 <Peaker> s/these types/this type
05:25:45 <bohdan> IO is a type constructor, it needs x as in IO x
05:25:48 <BONUS> basically >>= takes a fancy a and a function that takes a normal a and returns a fancy b and then returns a fancy b
05:25:51 <bohdan> Int isn't
05:26:19 <tristes_tigres>  IO a -> IO b -> IO b is actually a type of (>>>)
05:26:27 <Peaker> bohdan: right, "kinds" are basically the "types" of types that distinguish types from type constructors and the various constructor forms there are
05:26:43 <Peaker> tristes_tigres: you mean (>>) ?
05:27:10 <maltem> @type (>>>)
05:27:12 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
05:27:14 <bohdan> Peaker, so like type classes?
05:27:15 <Peaker> bohdan: so the "kind" of Int is a simple type, so simply   *     while the kind of IO is a type constructor from simple types so it is  *->*
05:27:16 <BONUS> >>> is a b c -> a c d -> a b d
05:27:18 <BONUS> gah beaten
05:27:34 <enjoy_korea> 
05:27:42 <Peaker> bohdan: no, just a simple system that makes sure "IO" is not used as a type but "IO Int" is
05:28:02 <bohdan> I don't understand the notation (*->*)
05:28:14 <Peaker> bohdan: its like a function from one simple type to another simple type
05:28:30 <Peaker> bohdan: because IO is sort of a compile-time "type function" that takes a simple type and returns a simple type
05:28:47 <maltem> bohdan: * is a type, and * -> * is a one-argument type constructor (it takes a type, and then gives you a type)
05:28:50 <Peaker> bohdan: (IO String) applies the IO "Type function" (type constructor) to its simple type argument (String)
05:29:07 <Axman6> argh, just tried to use >> as a pipe in terminal >_<
05:29:26 <maltem> bohdan: (or rather, * is the kind of a type etc.)
05:29:41 <tristes_tigres> can GHCi show kinds the way it dispplays types ?
05:29:57 <Peaker> bohdan: Note that   [Int] is just syntax sugar for ([] Int)  note the similarity to (IO Int).  [] and IO are of the same "kind", both are *->*
05:30:01 <maltem> Axman6: I think I once tried $ in a terminal
05:30:01 <Martijn> bohdan: Values always have simple types (i.e. types of kind *). There are no values of types with kind, say, * -> *. A specific example: there are no values of type IO.
05:30:22 <Peaker> bohdan: similarly,   Int->String   is equivalent to  ((->) Int String)  so (->) is of kind * -> * -> *
05:30:35 <Peaker> bohdan: following?
05:30:39 <hesselink> tristes_tigres: yes, you can use :kind just like :type
05:30:40 <bohdan> yes
05:30:55 <BONUS> basically * -> * means that it takes one concrete type (like Int) and produces a concrete type (like IO Int)
05:31:00 <bohdan> Peaker, go on :)
05:31:36 <maltem> er... there's more to say about kinds? is there?
05:31:57 <Peaker> bohdan: The operations (>>=) and return can be generalized from using  (IO a)  to using (m a) form, where m is any type of kind *->*
05:32:19 <Peaker> bohdan: obviously if m=IO we preserve the meaning that you already understand, right?
05:32:39 <maltem> Peaker: hey, not any type, only suitable types
05:32:43 <bohdan> aha
05:32:48 <bohdan> instance Monad [] -- Defined in GHC.Base
05:32:51 <Peaker> right, sorry :)
05:33:18 <Peaker> bohdan: note [] can be a Monad instance also because its kind is *->*          but Int cannot be a Monad instance because its kind is * and not *->*
05:33:58 <bohdan> ok
05:34:04 <bohdan> also Maybe has type *->*
05:34:10 <BONUS> a kind
05:34:17 <bohdan> right, kind
05:34:24 <BONUS> are you familiar with Either?
05:34:36 <Peaker> bohdan: now, any type of kind *->* that you declare is a Monad instance, you must define meaningful "return" and (>>=) operations for that type.  These operations must preserve some laws or assumptions
05:34:45 <Peaker> bohdan: right, and Maybe is indeed a Monad
05:35:06 <bohdan> so what are these laws?
05:35:19 <Peaker> bohdan: basically the laws say that:  "return" puts a value into the monad (a -> m a) where you can think of "m a" as a box of type "m" that "contains" an "a"
05:35:22 <tristes_tigres> hesselink:thanks
05:35:36 <BONUS> > return 3 :: Maybe Int
05:35:40 <lambdabot>   Just 3
05:35:40 <BONUS> > return 3 :: [Int]
05:35:42 <bohdan> BONUS, yes, it's (*->*->*), right? so it can't be a monad?
05:35:44 <lambdabot>   [3]
05:36:10 <Peaker> bohdan: Right, "Either" itself cannot be a Monad,   but (Either a) (already given a single type argument, even though its an "open" one) can be a Monad
05:36:24 <bohdan> uhu I understand that
05:36:36 <Peaker> bohdan: so there's indeed a Monad instance for (Either a)
05:36:43 <maltem> bohdan: "left identity" law: return x >>= f  =  f x
05:36:46 <idnar> Peaker: no, there isn't :(
05:36:54 <BONUS> because if you treat (Either a) as a type constructor (which it is), you can make that type constructor part of Monad
05:36:56 <Peaker> idnar: sure there is somewhere
05:36:59 <idnar> Peaker: there's a Monad instance for (Error a) => Either a
05:37:16 <maltem> bohdan: "right identity" law: m >>= return  =  m
05:37:35 <bohdan> ok now I can come up with definitions of return and >>= for (->) on my own
05:37:36 <maltem> bohdan: (those two laws just say that 'return' doesn't do anything interesting)
05:37:53 <BONUS> basically they say that it acts like boxing something up
05:37:56 <BONUS> to be plain
05:37:58 <Peaker> bohdan: not for (->) but for ((->) a) :)
05:38:08 <Peaker> bohdan: because (->) is like Either: *->*->*
05:38:16 <maltem> bohdan: finally, associativity:  (m >>= f) >>= g  =  m >>= (\x -> f x >>= g)
05:38:40 <BONUS> when you do return x >>= f, you just pack the x up with return and then it's unpacked by >>= and applied to f
05:38:45 <BONUS> so that's just like doing f x
05:38:47 <Peaker> idnar: oh, ok
05:39:10 <Axman6> anyone got a nice simple function to tell you how many digits are in an integral number? length.show isn't ideal
05:39:21 <BONUS> logBase 10?
05:39:35 <Axman6> > logBase 10 123456
05:39:38 <asgaroth> that fails for some cases due to floating point issues
05:39:38 <lambdabot>   5.091512201627771
05:39:44 <asgaroth> > logBase 10 1000
05:39:47 <lambdabot>   2.9999999999999996
05:39:47 <Axman6> > logBase 10 123456789
05:39:50 <lambdabot>   8.09151497716927
05:39:59 <arw> > ceil logBase 10 1000
05:39:59 <BONUS> ceiling . logBase 10
05:40:01 <lambdabot>   Not in scope: `ceil'
05:40:07 <Peaker> @type (^)
05:40:08 <tromp_> why is length.show not ideal??
05:40:09 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
05:40:12 <bohdan> Peaker, I'm not sure I understand what (->a) is
05:40:14 <Peaker> someone could write an exponentially-growing logBase search based only on (^)
05:40:18 <asgaroth> ceiling would make other results wrong:
05:40:23 <maltem> tromp_: leading -
05:40:24 <BONUS> > ceiling . logBase 10 $ 424
05:40:24 <asgaroth> > ceiling $ logBase 10 1234
05:40:28 <lambdabot>   3
05:40:28 <lambdabot>   4
05:40:31 <BONUS> > ceiling . logBase 10 $ 1000
05:40:31 <Axman6> tromp_: well, seemed to me it would be better to use the fact it's a number...
05:40:32 <Peaker> bohdan: (a->b) is just syntax sugar for "(->) a b"
05:40:34 <lambdabot>   3
05:40:37 <BONUS> gah!
05:40:46 <BONUS> ARGH! FLOATING POIINTS!
05:40:49 <tromp_> length.show.abs looks ideal
05:40:52 <Peaker> bohdan: so  ((->) a)  is basically (a->?)  where ? is waiting for another type argument
05:41:00 <Peaker> bohdan: or if types had "sections" like values, simply (a->)
05:41:06 <maltem> tromp_: right :)
05:41:44 <Axman6> tromp_: well i'm working with numbers that are potentially millions of digits long, so i'd rather not convert it to a string using show (i'm guessing that it's probably a little costly)
05:41:56 <tromp_> ah, but they're not converted to string!
05:42:04 <tromp_> remember Haskell is lazy
05:42:18 <tromp_> it will only do the work of determining #digits
05:42:22 <bohdan> ok let's say X is (->a), then X b is (a->b) ?
05:42:28 <Axman6> tromp_: i know, but it'll still have to go through the show routines
05:42:29 <BONUS> yes
05:42:44 <tromp_> it will shortcut parts of it
05:42:57 <Peaker> bohdan: don't write (->a) it implies a is the return type of the func, but its the argument
05:43:01 <Peaker> bohdan: write (->) a
05:43:48 <idnar> or (a ->)
05:44:01 <maltem> tromp_: well it will still be linear complexity
05:44:15 <bohdan> then, return :: X b -> (b -> X c) -> X c ; i.e. return :: (a -> b) -> (b -> (a->c)) -> (a->c)
05:44:26 <tromp_> at least
05:45:33 <Peaker> Axman6: reimplement   logBase :: Integral a => a -> a -> a     to be in O(log(digitCount))
05:45:44 <Peaker> Axman6: that could be useful in the stdlib, too
05:45:49 <maltem> bohdan: that's not return, but otherwise, right :)
05:46:03 <bohdan> right, >>= :)
05:46:04 <Peaker> Axman6: or O(log(result))
05:46:10 <Axman6> i'm happy with len n = len' n 0; len' 0 acc = acc; len' !n !acc = len' (n `div` 10) (acc+1)
05:46:25 <Peaker> bohdan: note that  a -> (b->c)  ===  a->b->c
05:47:29 <Peaker> Axman6: that's pretty much what length.show would be, because it will shortcircuit the modulo-to-digit part, and only get the `div` 10 part
05:47:55 <bohdan> so, f >>= g _ = g f _
05:48:05 <bohdan> @pl \f g _ -> g f _
05:48:05 <lambdabot> (line 1, column 15):
05:48:06 <lambdabot> unexpected "_"
05:48:06 <lambdabot> expecting variable, "(", operator or end of input
05:48:08 <Peaker> bohdan: s/_/x
05:48:11 <bohdan> @pl \f g x -> g f x
05:48:12 <lambdabot> flip id
05:48:25 <bohdan> mmm
05:48:25 <Peaker> bohdan: and its  g (f x)
05:48:32 <bohdan> @pl \f g x -> g $ f x
05:48:32 <lambdabot> flip (.)
05:48:42 <Peaker> bohdan: and also g wants x too
05:48:56 <Peaker> bohdan: "f >>= g x = g f x" is not quite it yet
05:49:23 <bohdan> ah right
05:49:33 <Peaker> bohdan: f >>= g x = ... something that must involve  (f x)   and    (g <some arg here> x)
05:49:33 <ejt_> hi, I'm playing with STM and was wondering if there's a standard 'delay :: Time -> STM ()' function anywhere.  eg, so I can write  'someSlowSTMAction `orElse` delay oneSecond'  ??
05:50:13 <bohdan> so, f >>= g x = (g (f x)) x
05:50:23 <Peaker> ejt_: I think the purpose of STM transactions is to completely or abort immediately
05:50:23 <bohdan> @pl \f g x -> (g $ f x) x
05:50:23 <lambdabot> flip flip id . (ap .) . flip (.)
05:50:45 <Peaker> bohdan: that seems right
05:50:52 <Peaker> @type  \f g x -> (g $ f x) x
05:50:54 <lambdabot> forall a t t1. (t -> a) -> (a -> t -> t1) -> t -> t1
05:50:59 <Axman6> :t \f g x -> (?g $ ?f x) x
05:50:59 <maltem> ejt_: not sure about your question, but you do know that retry waits passively?
05:51:01 <bohdan> why, I expected pl to give me f >>= g
05:51:01 <lambdabot> forall t t1 a t2 t3. (?f::t2 -> a, ?g::a -> t2 -> t3) => t -> t1 -> t2 -> t3
05:51:23 <Peaker> bohdan: @pl does not necessarily find the "prettiest" pl
05:51:28 <Axman6> :t join (?g . ?f)
05:51:30 <lambdabot> forall b a a1. (?f::a -> b, ?g::b -> a -> a1) => a -> a1
05:51:34 <Myrth> what's @pl?
05:51:42 <asgaroth> @help pl
05:51:43 <bohdan> @unpl f >>=g
05:51:43 <lambdabot> pointless <expr>. Play with pointfree code.
05:51:43 <lambdabot> (f >>= g)
05:51:47 <ejt_> Peaker, maltem: I've just found a bit in the papers on this - I think I'm going about this incorrectly :)
05:51:59 <BONUS> when writing the monad instance for ((->) r), its good to write down (r -> a) -> (a -> r -> b) -> (r -> b) on a napkin and look at that while coding up the equation :)
05:52:19 <Axman6> Myrth: turns lovely code into hard to understand PointLess (pl) code:
05:52:30 <bohdan> exactly what I did, bonus :) but with cyber-napkin being the irc log :)
05:52:31 <tristes_tigres> what is (?)
05:52:43 <Axman6> @pl \q w e r t y u i o p -> t y p e w r i t e r
05:52:47 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .)
05:52:47 <lambdabot>  .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . (
05:52:47 <lambdabot> (flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
05:52:47 <lambdabot> optimization suspended, use @pl-resume to continue.
05:52:49 * Axman6 hides
05:53:02 <tristes_tigres> Axman^ that was evil :-)
05:53:12 <Axman6> @pl-resume
05:53:19 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . (flip .)) .)) .)) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .)
05:53:19 <lambdabot> .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((
05:53:19 <lambdabot> flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
05:53:19 <lambdabot> optimization suspended, use @pl-resume to continue.
05:53:29 <Axman6> tristes_tigres: it goes on for a long time indeed
05:53:42 <bohdan> ewww
05:53:45 <BONUS> also when sequencing a monad and a function that returns a monad, the result will be amonad
05:53:48 <BONUS> so its good to write
05:53:49 <ziman> a funny way to encode a permutation :)
05:53:55 <BONUS> f >>= g = \a -> ...
05:54:21 <maltem> @type  \q w e r t y u i o p -> t y p e w r i t e r
05:54:23 <lambdabot>     Occurs check: cannot construct the infinite type:
05:54:23 <lambdabot>       t = t5 -> t7 -> t3 -> t2 -> t4 -> t6 -> t -> t3 -> t4 -> t1
05:54:23 <lambdabot>     Probable cause: `t' is applied to too many arguments
05:54:41 <baaba> @pl \x -> g (f x) x
05:54:42 <lambdabot> g =<< f
05:54:43 <tristes_tigres> what is the meaning of this notation ? (?f::a -> b)
05:54:51 <baaba> oh, ha
05:55:06 <Axman6> :t map ?f
05:55:08 <lambdabot> forall a b. (?f::a -> b) => [a] -> [b]
05:55:22 <maltem> tristes_tigres: evil implicit parameters
05:55:23 <bohdan> > (+1) >>= return 1
05:55:24 <Axman6> tristes_tigres: lets you find out what type a function or type should be
05:55:26 <lambdabot>       No instance for (Num (a -> b))
05:55:26 <lambdabot>        arising from the literal `1' at <...
05:55:38 <BONUS> if you have (r -> a) -> (a -> r -> b) -> (r -> b), you know the final function produced will take whatever f takes and return whatever g returns
05:56:22 <baaba> > (+1) >>= return (+1)
05:56:24 <lambdabot>       Overlapping instances for Show (a -> a)
05:56:24 <lambdabot>        arising from a use of `s...
05:56:34 <baaba> > let f = (+1) >>= return (+1) in f 5
05:56:36 <lambdabot>   6
05:56:55 <tristes_tigres> maltem: Aha ! implicit parameters
05:56:59 <BONUS> :t (+1) >>= return
05:57:01 <lambdabot> forall a. (Num a) => a -> a
05:57:06 <tristes_tigres> there should be some sort of syntax reference
05:57:20 <byorgey> tristes_tigres: there is =)
05:57:22 <byorgey> @where report
05:57:23 <lambdabot> http://www.haskell.org/onlinereport/
05:57:35 <maltem> byorgey: no implicit parameters in there
05:57:38 <tristes_tigres> byorgey: implicit parametrs aren't there
05:57:48 <byorgey> oh, my mistake
05:57:59 <maltem> tristes_tigres: the ghc user manual informally documents all extensions, though
05:58:09 <BONUS> are guards on case syntax part of H98 btw?
05:58:16 <bohdan> > (+1) >>= return $ 1
05:58:17 <byorgey> hm, the GHC documentation doesn't cover syntax?  or you mean it's just not all in one place?
05:58:19 <lambdabot>   2
05:58:23 <baaba> > let f = (+1) >>= (+) in f 5
05:58:26 <quicksilver> BONUS: yes
05:58:26 <lambdabot>   11
05:58:35 <BONUS> ah, kewl
05:58:41 <bohdan> where is Monda ((->) a) defined?
05:58:41 <BONUS> makes sense cause its just like a function anyway
05:58:43 <tristes_tigres> byorgey: and many many other things like Class a b c| a -> b
05:58:50 <Axman6> :t (>>= (+))
05:58:51 <bohdan> @hoohle (->) a
05:58:51 <lambdabot> Prelude undefined :: a
05:58:51 <lambdabot> Data.Array.Base arrEleBottom :: a
05:58:51 <lambdabot> Test.QuickCheck.Batch bottom :: a
05:58:52 <byorgey> tristes_tigres: right.
05:58:52 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
05:58:59 <bohdan> @hoohle Monad ((->) a)
05:59:00 <lambdabot> Warning: Unknown type Monad
05:59:00 <lambdabot> Prelude undefined :: a
05:59:00 <lambdabot> Data.Array.Base arrEleBottom :: a
05:59:04 <maltem> byorgey: I was just pointing tristes_tigres to the manual
05:59:13 <bohdan> @hoohle Monad
05:59:13 <lambdabot> module Control.Monad
05:59:13 <lambdabot> Prelude class Monad m
05:59:13 <lambdabot> Control.Monad class Monad m
05:59:23 <tristes_tigres> maltem: manual doesn't cover all commonly used syntax
05:59:56 <maltem> tristes_tigres: how do you mean? It's hard to find, but it should all be there :)
05:59:58 <tristes_tigres> And GHC does not have a single table with all syntax constructions
06:00:00 <arw> does haskell internally use type-tags, like scheme/lisp? does it need them at all?
06:00:16 <quicksilver> arw: no.
06:00:24 <quicksilver> arw: types can be compiled away
06:00:28 <quicksilver> and are, by GHC
06:00:34 <tristes_tigres> maltem: Oh yeah ? Well find there something like Class a b c| a -> b
06:00:50 <arw> because the compiler resolves all types at compile-time, as i thought. thanks.
06:00:58 <maltem> tristes_tigres: hold on a moment
06:01:16 <quicksilver> tristes_tigres: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html
06:01:19 <maltem> tristes_tigres: http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#functional-dependencies
06:01:32 <tristes_tigres> maltem: It's not the report
06:01:41 <maltem> tristes_tigres: of course not, it's an extension
06:01:48 <maltem> tristes_tigres: oh, I just realize
06:01:54 <Peaker> bohdan: if you now write the [] monad, you will see why it behaves the way it does :)
06:02:04 <tristes_tigres> maltem: and GHC documentation , unlike the report, does not have the table listing all permissible syntax
06:02:08 <maltem> »There should be more documentation, but there isn't (yet). Yell if you need it.« Wow...
06:03:04 <maltem> tristes_tigres: associated types are more fun than functional dependencies anyways :P
06:03:35 <bohdan> >>= :: [a] -> (a -> [b]) -> [b] ; return :: a -> [a]
06:04:29 <quicksilver> tristes_tigres: that's true. It's quite hard to imagine what form a table could take which summarised *all* syntax
06:04:51 <tristes_tigres> quicksilver:  how about the Report ?
06:04:57 <bohdan> return = (: [])
06:05:15 <tristes_tigres> maltem: Yes, they are alot of "fun"
06:05:25 <tristes_tigres> when you try to use them :-)
06:05:36 <quicksilver> tristes_tigres: the report documents haskell98 which had a pretty simple syntax
06:05:44 <quicksilver> tristes_tigres: however GHC extensions do not have simple syntax
06:05:49 <quicksilver> they have all kinds of things
06:06:30 <tristes_tigres> quicksilver: it could simply name the constructions and point tj a section of the manual
06:07:03 <tristes_tigres> right now, when you see an unfamiliar extension, you can either readd the whole manual or ask on #haskell
06:07:12 <tristes_tigres> there is no single place to look
06:07:22 <quicksilver> Yes. I understand what you said.
06:07:31 <quicksilver> I"m just saying, it would be quite hard to organise that table.
06:07:41 <quicksilver> There is no standard ordering for non-alphanumeric characters
06:07:44 <tristes_tigres> shouldn' be a lot of work to make a kind of index
06:07:49 <quicksilver> and there are a lot of extensions.
06:07:55 <quicksilver> Not hard to make, hard to *organise*
06:07:59 <quicksilver> in a way which is actually useful.
06:08:09 <tristes_tigres> quicksilver: even unorganized list would be helpful
06:09:33 <bohdan> f >>= g = map g f
06:09:40 <bohdan> or somesuch :)
06:09:45 <bohdan> @pl \a -> a !! 1
06:09:45 <lambdabot> (!! 1)
06:09:55 <bohdan> > [1..10] >= (!! 1)
06:09:56 <lambdabot>       The section `(!! 1)' takes one argument,
06:09:57 <lambdabot>      but its type `[t]' has none
06:10:15 <bohdan> > [1..10] >= return . (!! 1)
06:10:16 <lambdabot>   Couldn't match expected type `[t]'
06:10:25 <bohdan> > [1..10] >>= (!! 1)
06:10:27 <lambdabot>       No instance for (Enum [[b]])
06:10:27 <lambdabot>        arising from the arithmetic sequenc...
06:11:01 <maltem> bohdan: What would 7 !! 1 be?
06:11:15 <BONUS> bohdan:remember, g should be a function a -> [b]
06:11:18 <bohdan> > [1..10] >>= (+1)
06:11:19 <lambdabot>       No instance for (Enum [b])
06:11:19 <lambdabot>        arising from the arithmetic sequence ...
06:11:20 <BONUS> so you can't just map f to a function
06:11:24 <bohdan> > [1..10] >>= (:[])
06:11:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:11:31 <bohdan> > [1..10] >>= (:[1])
06:11:32 <lambdabot>   [1,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1]
06:12:21 <BONUS> if you have [a] -> (a -> [b]) -> [b], you can however map the function (a -> [b]) over the list [a]
06:12:28 <BONUS> but then you end up with [[b]]
06:12:33 <BONUS> and you need a [b] as the result
06:12:36 <BONUS> so you have to concat
06:14:07 <Axman6> > [1..10] >>= show
06:14:09 <lambdabot>   "12345678910"
06:14:53 <bohdan> @type \f g -> concat . map (return . g) f
06:14:54 <lambdabot>     Couldn't match expected type `a -> [[a1]]'
06:14:54 <lambdabot>            against inferred type `[m b]'
06:14:54 <lambdabot>     In the second argument of `(.)', namely `map (return . g) f'
06:15:10 <Axman6> hmm, anyone know why this would (appear to) build up a large thunk when run with large values of x? fib' !x (!m,!n) = fib' (x-1) $! (n, m+n) -- there's a basecase for x = 0 as well
06:15:27 <Peaker> bohdan: why (return . g) ?
06:15:38 <Peaker> bohdan: >>= takes a function that returns it in the monad already at its right side
06:15:39 <Axman6> there's some unnecessary strictness in there..
06:15:51 <bohdan> ok
06:16:09 <Peaker> @type \f g -> concat . map g f
06:16:10 <lambdabot>     Couldn't match expected type `a -> [[a1]]'
06:16:10 <lambdabot>            against inferred type `[b]'
06:16:10 <lambdabot>     In the second argument of `(.)', namely `map g f'
06:16:13 <bohdan> >  [1..10] >>= return . const 1
06:16:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
06:16:33 <bohdan> >  [1..10] >>= return . const 1 >>= return
06:16:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
06:16:37 <lilac> @type \f -> concat . map f
06:16:38 <Axman6> :t [a..]
06:16:39 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:16:40 <lambdabot> [Expr]
06:16:44 <Peaker> @type \f g -> concat (map g f)
06:16:45 <lambdabot> forall a a1. [a] -> (a -> [a1]) -> [a1]
06:16:48 <Axman6> > [a..d]
06:16:50 <lambdabot>   * Exception: not a number
06:16:51 <lilac> @type \f -> concat . map (return . f)
06:16:52 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
06:17:04 <lilac> @type liftM :: (a -> b) -> ([a] -> [b])
06:17:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:17:39 <Peaker> bohdan: you see above you have your >>=
06:18:12 <bohdan> yeah
06:18:14 <Peaker> > let f>>=g = concat (map g f) in [1,2,3]>>=return
06:18:16 <lambdabot>   [1,2,3]
06:18:21 <Peaker> > let f>>=g = concat (map g f) in [1,2,3]>>=(\x -> [x,x])
06:18:23 <lambdabot>   [1,1,2,2,3,3]
06:18:24 <bohdan> how would I tell lambdabot to show the source of >>= for [] ?
06:18:32 <lilac> @src [] (>>=)
06:18:32 <Peaker> @src (>>=) []
06:18:32 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:18:33 <lambdabot> xs >>= f     = concatMap f xs
06:18:40 <Peaker> @src concatMap
06:18:40 <lambdabot> concatMap f = foldr ((++) . f) []
06:18:53 <bohdan> nice
06:19:13 <Peaker> or concatMap = (concat.) . map
06:19:52 <bohdan> I see -- thanks everyone :)
06:19:55 * bohdan <3 #haskell
06:20:07 <BONUS> hehe
06:20:21 <Axman6> > iterate (\(m,n) -> (m, n+m)) (0,1)
06:20:23 <lambdabot>   [(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0,1),(0...
06:20:33 <Axman6> > iterate (\(m,n) -> (n, n+m)) (0,1)
06:20:35 <lambdabot>   [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89)...
06:20:47 <Axman6> > map snd . iterate (\(m,n) -> (n, n+m)) $ (0,1)
06:20:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:21:27 <Peaker> bohdan: define the Maybe monad :)
06:21:56 <bohdan> return :: a -> Maybe a; return = Maybe
06:22:11 <Axman6> not quite
06:22:20 <BONUS> remember, Maybe is a type constructor
06:22:27 <Axman6> > Maybe 2
06:22:28 <lambdabot>   Not in scope: data constructor `Maybe'
06:22:30 <bohdan> oh
06:22:40 <bohdan> return = Just
06:22:43 <BONUS> w00t
06:22:59 <BONUS> >>= :: Maybe a -> (a -> Maybe b) -> Maybe b
06:24:18 <lilac> @type flip (maybe Nothing)
06:24:20 <lambdabot> forall a a1. Maybe a1 -> (a1 -> Maybe a) -> Maybe a
06:24:39 <bohdan> eh
06:25:07 <BONUS> think about this also for a parallel
06:25:21 <BONUS> > let bigScaryFunction = undefined in [] >>= bigScaryFunction
06:25:23 <lambdabot>   []
06:25:40 <BONUS> [] is very similar to Nothing
06:26:51 <lilac> In fact, the Monad instance for the subtype of [a] containing only zero- and one-element lists is the same as the Monad instance for Maybe
06:27:54 <Peaker> Maybe is a list of 0 or 1 elements in general :)
06:28:03 <bohdan> Just a >>= g x = g a
06:28:04 <lilac> indeed, but that doesn't mean it has the same instances
06:28:15 <lilac> for instance, the Monoid instance is different
06:28:22 <Peaker> bohdan: what's that "x" there?
06:28:22 <bohdan> rather Just a >>= g = g a
06:29:09 <bohdan> > Nothing >>= \a -> Just a
06:29:10 <lambdabot>   Nothing
06:29:21 <bohdan> So, Nothing >>= _ = Nothing
06:29:39 <BONUS> yup!
06:29:52 <bohdan> aha so Nothing and [] and monadic zeroes
06:30:07 <lilac> bohdan: indeed
06:30:12 <lilac> > mzero :: Just Bool
06:30:14 <lambdabot>   Not in scope: type constructor or class `Just'
06:30:19 <lilac> > mzero :: Maybe Bool
06:30:21 <lambdabot>   Nothing
06:30:26 <lilac> > mzero :: [Int]
06:30:28 <lambdabot>   []
06:30:36 <bohdan> nice :)
06:30:44 <bohdan> mzero >>= Just
06:30:52 <bohdan> > mzero >>= Just
06:30:54 <lambdabot>   Nothing
06:31:20 <bohdan> > (mzero >>= return) :: Maybe Int
06:31:22 <lambdabot>   Nothing
06:31:25 <bohdan> > (mzero >>= return) :: [Int]
06:31:27 <lambdabot>   []
06:31:33 <bohdan> > mzero >>= return
06:31:34 <lambdabot>       No instance for (Show (m a))
06:31:34 <lambdabot>        arising from a use of `show' at <in...
06:31:41 <bohdan> > :t mzero >>= return
06:31:42 <lambdabot>   <no location info>: parse error on input `:'
06:31:42 <kukucis> need users>http://www.lostworlds.lv/go.php?1139709442
06:31:47 <Peaker> > Just 5 `mplus` Nothing
06:31:48 <bohdan> @type (mzero >>= return)
06:31:49 <lambdabot>   Just 5
06:31:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
06:31:52 <Peaker> > Just 5 `mplus` Just 8
06:31:53 <lambdabot>   Just 5
06:32:02 <kukucis> this is like bittorent tracker only better> http://www.lostworlds.lv/go.php?1139709442
06:32:07 <lilac> bohdan: (x >>= return) == x
06:32:09 --- mode: ChanServ set +o quicksilver
06:32:11 --- mode: quicksilver set +b *!*i=kukucis@78.84.113.*
06:32:11 --- kick: kukucis was kicked by quicksilver (quicksilver)
06:32:13 <lilac> (by the monad laws
06:32:31 <elbar> faster response this time =)
06:34:12 <Axman6> thanks quicksilver
06:34:23 <elbar> same ip as before btw
06:34:37 <quicksilver> well he won't be back, in that case
06:35:50 <knapr> is haskell written in haskell?
06:35:55 <knapr> or in C+haskell+asm?
06:35:59 <quicksilver> haskell is written in english
06:36:04 <quicksilver> it's a language, not a program ;)
06:36:10 <quicksilver> GHC is written mostly in haskell
06:36:16 <BONUS> haha
06:36:17 <quicksilver> with an RTS which has portions in C and C--
06:36:32 <mbz> quicksilver, C--?
06:36:38 <quicksilver> c minus minus
06:36:40 <quicksilver> @go c minus minus
06:36:51 * quicksilver pokes the bot
06:36:58 <lambdabot> Plugin `search' failed with: thread killed
06:37:03 <quicksilver> http://www.cminusminus.org/
06:37:11 <quicksilver> although, it's not exactly standard C--
06:37:25 --- mode: quicksilver set -o quicksilver
06:37:37 <Peaker> why is ChanServ here?
06:37:54 <quicksilver> so it can op people?
06:38:03 <Peaker> it can op people without being here
06:38:22 <quicksilver> yes, but if it left and the channel became empty
06:38:27 <quicksilver> the next person in would gain ops
06:38:39 <quicksilver> not that that is likely to happen to #haskell ;)
06:38:53 <Peaker> quicksilver: there are plenty of registered channels without ChanServ in them, I don't think that happens
06:39:26 <mbz> so there is some C-- compiler somewhere inside ghc
06:39:32 <mercury^> :r
06:39:32 <mercury^> Segmentation fault
06:39:34 <quicksilver> Peaker: It's in all the registered channels I'm in
06:39:37 <quicksilver> mbz: yes.
06:39:39 <mercury^> That's a first. :)
06:40:23 <Peaker> quicksilver: #haskell-blah is registered
06:41:32 <quicksilver> Peaker: then, I have no idea.
06:45:42 <Axman6> would anyone be able to explain why 'fib' !x (!m,!n) = fib' (x-1) (n, m+n)' uses so much ram for large x?
06:47:04 <bohdan> > do x <- "hello world"; [x," "]
06:47:05 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
06:47:08 <bohdan> > do x <- "hello world"; [x,' ']
06:47:10 <lambdabot>   "h e l l o   w o r l d "
06:47:18 <bohdan> @pl do x <- "hello world"; [x,' ']
06:47:18 <lambdabot> (line 1, column 22):
06:47:18 <lambdabot> unexpected ";"
06:47:18 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
06:47:35 <bohdan> @pl "hello world" ==> \x -> [x,' ']
06:47:35 <lambdabot> "hello world" ==> (: " ")
06:47:41 <bohdan> @pl "hello world" >>= \x -> [x,' ']
06:47:41 <lambdabot> (: " ") =<< "hello world"
06:48:20 <bohdan> "hello world" >>= (: "-:-")
06:48:21 <bohdan> > "hello world" >>= (: "-:-")
06:48:23 <lambdabot>   "h-:-e-:-l-:-l-:-o-:- -:-w-:-o-:-r-:-l-:-d-:-"
06:48:29 <bohdan> neat :)
06:50:49 <Axman6> would anyone be able to explain why 'fib' !x (!m,!n) = fib' (x-1) (n, m+n)' uses so much ram for large x? -- got disconnected, so if this already got through, sorry
06:51:18 <bohdan> is it possible to always preload certain modules when I start ghci?
06:51:25 <quicksilver> I think the nested bang pattern probably doesn't work the way you hope it will, Axman6
06:51:48 <quicksilver> Axman6: try making it three args instead of one and a tuple?
06:52:01 <quicksilver> bohdan: yes. .ghci
06:52:08 <Axman6> oh ffs i hate my ISP!
06:53:03 <quicksilver> Axman6: and, were you compiling with optimisation?
06:53:37 <bohdan> quicksilver, thanks! :)
06:54:14 <dons> ?users
06:54:14 <lambdabot> Maximum users seen in #haskell: 588, currently: 564 (95.9%), active: 13 (2.3%)
06:54:22 <mercury^> Axman6: if you are not just playing with strictness: there are much faster ways to generate large fibonacci numbers.
06:54:35 <bohdan> Peaker, maltem, BONUS -- thanks for helping me understand these pesky monads :)
06:54:42 <Axman6_> such as?
06:54:59 <bohdan> Axman6, matrix multiplication ?
06:55:09 <bohdan> Axman6, done in O(log n)
06:56:17 <bohdan> @google fast fibonacci matrix multiplication
06:56:19 <lambdabot> No Result Found.
06:56:32 <bohdan> lame
06:56:38 <bohdan> e.g. http://everything2.com/title/Compute%2520Fibonacci%2520numbers%2520FAST%2521
06:56:48 <quicksilver> well, or just mutiplication in Z[sqrt 5]
06:56:59 <quicksilver> which is what the matrix multiplication encodes, in a sense.
06:57:45 <bohdan> http://en.wikipedia.org/wiki/Fibonacci_numbers#Matrix_form also
06:57:47 <mercury^> fib(2n+1) = (2*f(n)+f(n-1))*(2*f(n)-f(n-1) + 2*(-1)^n
06:58:14 <mercury^> fib(2n) = fib(n)*(fib(n)+2*fib(n-1))
06:58:35 <mercury^> so you can keep generating pairs of succeding fibs and apply that transformation
06:59:05 <ejt_> if I put a type signature on a function in a 'where' clause, how do I tell ghc that the typevariable 'a' is the same as the 'a' in the signature for the enclosing function ?
07:01:01 <Axman6_> oh screw it, i don't care anymore
07:01:09 * Axman6_ goes to bed in rate at his shitty ISP
07:02:02 <arjanb> ejt_: you might need to use {-# LANGUAGE ScopedTypeVariables #-} in that module
07:02:18 <ejt_> arjanb: thx
07:03:08 <Axman6_> s/rate/rage
07:03:28 <bohdan> is there a way to debug 'count not match expected type' expressions? one better than :t-ing subexpressions by hand ?
07:06:09 <ejt_> arjanb: that plus a 'forall a.' fixed it thx
07:07:51 <idnar> man, whenever I read DPH code, my brain wants to parse [: and :] as smileys
07:08:28 <knapr> anyone good with C? I have looked through http://www.gnu.org/software/libc/manual/html_node/index.html but can't find ouit how to print longs and unisgneds. And #C is a bunch of a**-holes.
07:09:02 <mbz> %l/%ul for long/unsigned long
07:09:17 <arjanb> bohdan: leave the type signature off and see what the compiler infers
07:10:26 <idnar> ##c, you mean?
07:10:58 <quicksilver> it should be %ld
07:11:03 <quicksilver> although maybe d is assumed?
07:11:10 <quicksilver> knapr: anyhow your answers are in man 3 printf
07:12:43 <mbz> quicksilver, yep you are right, either %ld or %li.
07:13:20 * mbz goes to bed
07:13:25 <int80_h> I'm running ghc 6.8.3, but I can't find cabal
07:13:37 <int80_h> where should I expect to find it
07:13:50 <int80_h> ghc is in /usr/pkg/bin, I thought cabal would be there as well
07:14:04 <maltem> int80_h: the cabal program belongs to the cabal-install package, which doesn't ship with ghc
07:14:15 <int80_h> oooh, heh okay
07:14:29 <int80_h> maltem, can I use darcs to install it?
07:14:37 <maltem> int80_h: it's on hackage
07:14:41 <int80_h> got it
07:14:53 <maltem> int80_h: be aware, you'll also need HTTP and zlib
07:15:16 <maltem> int80_h: but I think there's a script in cabal-install that automates the installation of these
07:18:48 <int80_h> maltem: thanks
07:20:04 <mattam> 3
07:24:47 <bohdan> so where is (->) a monad defined?
07:24:56 <quicksilver> Control.Monad.Instances
07:24:57 <quicksilver> I think
07:25:12 <dons> int80_h: your distro probably has it already
07:25:13 <baaba> @src (->) (>>=)
07:25:13 <lambdabot> f >>= k = \ r -> k (f r) r
07:26:50 <int80_h> dons: I use netbsd, I couldn't find it under pkgsrc/devel
07:27:18 <int80_h> dons: I'll look at the list of all packages
07:27:37 <int80_h> because it looks like cabal-install has many many dependencies
07:28:50 <Philonous> int80_h: Cabal install comes with a bootstrap script which downloads, builds and registeres the deps with ghc automagically
07:29:02 <int80_h> oh nice
07:29:04 <int80_h> good
07:30:26 <Philonous> Though for some reason it stopped to work for me sometime in the past. But getting the packages by hand from hackage and installing them isn't too hard, either.
07:43:58 <rdeshpande> hello everyone!
07:44:13 <rdeshpande> just started learning haskell today
07:44:24 <araujo> hi rdeshpande
07:44:31 <araujo> rdeshpande, great way to start the year!
07:44:33 <araujo> :-)
07:44:42 <rdeshpande> hehe
07:44:49 <BONUS_> nice, learning haskell is fun
07:45:04 <rdeshpande> we don't use it at all at work, but ive heard it will help my programming style across languages
07:45:11 * araujo remembers he also started learning haskell by the end/beginning of a year
07:45:25 <int80_h> I'm trying to install zlib, but it doesn't have any install instructions
07:45:28 <chessguy_work> rdeshpande, welcome :)
07:45:31 <araujo> quite a lot, and who knows.. you could probably get it into work too :-)
07:46:06 <chessguy_work> hey guys, i think there should be a better way to represent this, possibly as a modified State monad? Any thoughts? http://hpaste.org/13522
07:46:27 <int80_h> anyone have any clues for me? I can't use cabal, I'm installing this because it's a cabal-install dependency
07:47:32 <Philonous> unrar, cd into the directory, ghc-make Setup.hs
07:48:25 <Philonous> Then ./Setup configure --user if you want to install it locally or ./Setup configure for global install
07:49:00 <int-e> oh. ghc --make, not ghc-make
07:49:21 <Philonous> then ./Setup build and ./Setup install
07:49:40 <Philonous> Oh, right, ghc -make, my bad
07:49:51 <Philonous> ghc --make even
07:49:52 <int80_h> yeah I figured that
07:50:31 <int80_h> where does ./Setup configure put zlib?
07:50:48 <int80_h> does it go in the same place as ghc?
07:51:16 <int80_h> I don't want it to go anyplace wierd like /usr/local
07:55:27 <BONUS_> does anyone else have a problem with graham hutton's book being too tall?
07:55:36 <BONUS_> or are my bookshelves just too small or what
07:55:45 <beelsebob> hehe, on april the 1st, at 4:25pm, the time will be 1^2/2^2/3^2 4^2:5^2
07:55:47 <beelsebob> :D
07:56:05 <BONUS_> haha
07:56:07 <BONUS_> nice
07:56:30 <grul> silly americans
07:56:37 <grul> (regarding your date format)
07:56:41 <beelsebob> eh?
07:56:44 <beelsebob> that's proper date format
07:56:55 <grul> i rest my case
07:57:00 <beelsebob> americans would say its this sunday
07:57:12 <beelsebob> grul: I mean, I didn't use american date format
07:57:19 <beelsebob> the americans put the month before the day
07:57:35 <BONUS_> 1/4/9 16:25
07:57:38 <grul> oh, i'm sorry
07:57:42 <BONUS_> yeah that's D/M/Y
07:58:06 <BONUS_> my fav way to write dates is YYYY/MM/DD
07:58:16 <grul> but still, doesn't it make more sense to put the most significant (year (?)) number first?
07:58:45 <beelsebob> grul: you mean like ISO format YYYY-MM-DD hh:mm
07:58:54 <grul> yes, exactly
07:58:58 <beelsebob> yes, it does
07:59:08 <beelsebob> but at least the UK format doesn't totally mess up the order
07:59:11 <BONUS_> MM/DD/YYY is just weird
07:59:14 <beelsebob> indeed
07:59:23 <beelsebob> DD/MM/YYYY at least has some format to it
07:59:53 <beelsebob> and arguably, the day *is* the most "significant" (not in the mathematical sense) part of the date
08:00:22 <grul> yeah, i guess you have a point
08:01:18 <Philonous> int80_h: Apparently you can change the install path by supplying a --prefix argument to Setup configure. But I have no clue what the standard path is.
08:01:39 <redditbot> Formatted IO as an embedded DSL: the final view :: New Oleg
08:01:44 <arw> is there a way to get some kind of safe index operator?
08:02:17 <arw> i want to compare two strings at index n, like in a!!n < b!!n
08:02:56 <arw> but if one is shorter, i want some kind of "smallest" default instead of a runtime error.
08:03:10 <scook0> what are you actually trying to accomplish?
08:03:24 <scook0> (the !! operator is usually a sign that you're going about things the wrong way)
08:03:43 <quicksilver> > [1,2,3] < [1,2,3,4,5]
08:03:43 <kpreid> @let [] !!! _ = Nothing; (x:_) !!! 0 = x; (_:xs) !!! i = xs !!! (i-1)
08:03:45 <lambdabot>   True
08:03:46 <lambdabot>  Defined.
08:03:49 <kpreid> er
08:03:54 <kpreid> @undefine
08:04:02 <kpreid> @let [] !!! _ = Nothing; (x:_) !!! 0 = Just x; (_:xs) !!! i = xs !!! (i-1)
08:04:04 <lambdabot>  Defined.
08:04:41 <bohdan> how do I see the number of reductions required to calculate somethig?
08:05:10 <jkff> bohdan: Run it in Hugs
08:05:18 <lilac> bohdan: the usual method is to ask Cale to reduce it by hand :)
08:05:24 <chessguy_work> or use debug in ghci
08:05:29 <baaba> > [1, 2, 3] !!! -5
08:05:30 <lambdabot>       precedence parsing error
08:05:30 <lambdabot>          cannot mix `(!!!)' [infixl 9] and pre...
08:05:34 <baaba> > [1, 2, 3] !!! (-5)
08:05:35 <lambdabot>   Nothing
08:06:03 <Philonous> > [undefined, undefined, 3] !!! 3
08:06:04 <lambdabot>   Nothing
08:06:07 <chessguy_work> @remember lilac <bohdan> how do I see the number of reductions required to calculate somethig? <lilac> bohdan: the usual method is to ask Cale to reduce it by hand :)
08:06:07 <lambdabot> Done.
08:06:13 <bohdan> baaba, the operator should be called !!1 :)
08:06:20 <baaba> heh
08:06:20 <Philonous> > [undefined, undefined, 3] !!! 2
08:06:22 <lambdabot>   Just 3
08:07:02 <baaba> > minBound :: Int
08:07:03 <lambdabot>   -9223372036854775808
08:07:07 <bohdan> uh now I'll be remembered as the guy making typos :)
08:07:17 <baaba> > [1, 2, 3] !!! (minBound :: Int)
08:07:18 <lambdabot>   Nothing
08:07:32 <baaba> > (minBound :: Int) - 1
08:07:33 <lambdabot>   9223372036854775807
08:07:47 <baaba> right, of course
08:08:11 <dmwit> > let xs !!! n = listToMaybe . drop n $ xs in [undefined, undefined, 3] !!! 2
08:08:12 <lambdabot>   Just 3
08:08:16 <SamB_XP> bohdan: unless lambdabot has another bout of amnesia, in which case you'll be forgotten
08:08:18 <dmwit> > let xs !!! n = listToMaybe . drop n $ xs in [undefined, undefined, 3] !!! 5
08:08:19 <lambdabot>   Nothing
08:08:24 <dmwit> Mine is better. =)
08:08:25 <Philonous> > [1..] !!! (-1)
08:08:27 <SamB_XP> but at least it wasn't under your name
08:08:38 <dmwit> > let xs !!! n = listToMaybe . drop n $ xs in [undefined, undefined, 3] !!! (-1)
08:09:32 <idnar> @type (!!!)
08:09:33 <idnar> @ping
08:09:33 <baaba> uh oh
08:09:33 <Philonous> Ooop, did I hurt it?
08:09:33 <dmwit> Except for negative indices, I guess.
08:09:38 <chessguy_work> @bot
08:09:39 <lunabot>  :)
08:09:42 <dmwit> But yours infinite loops on infinite lists with negative indices...
08:09:51 <lilac> let xs !!! n = (Just $! xs !! n) `unamb` unsafePerformIO (sleep 10 >> return Nothing)
08:09:56 <baaba> it doesn't loop infinitely
08:10:07 <dmwit> baaba: Are you sure?
08:10:12 <idnar> lilac: haha
08:10:12 <baaba> it just goes through 9223372036854775807 items ;)
08:10:18 <dmwit> =)
08:10:18 <baaba> until reaching the 0 case
08:10:26 <baaba> erm, 2 * 9223372036854775807 items even
08:10:29 <idnar> . 1 + 1
08:10:31 <idnar> er
08:10:32 <idnar> , 1 + 1
08:10:34 <lilac> idnar: "nearly unambiguous choice" :)
08:10:40 <lunabot>  2
08:10:45 <Philonous> baaba: Not for arbitraty large ints
08:10:46 <chessguy_work> heh
08:10:57 <lambdabot>   thread killed
08:11:02 <baaba> ah right if it's Integer then it'll be infinite
08:13:06 <lambdabot> pong
08:13:11 <lambdabot> forall a t. (Num t) => [a] -> t -> Maybe a
08:13:11 <lambdabot> :)
08:13:11 <lambdabot>   Just * Exception: Prelude.undefined
08:13:40 <idnar> whoa :P
08:13:49 <dmwit> Hey, that last one was me!
08:13:52 <dmwit> ?botsnack
08:13:52 <lambdabot> :)
08:13:56 <chessguy_work> ha
08:14:13 <idnar> it's you!
08:14:59 <baaba> > let xs !!! n = listToMaybe . drop n $ xs in [1..] !!! (-1)
08:15:00 <lambdabot>   Just 1
08:15:07 <baaba> not quite :P
08:15:09 <baaba> > let xs !!! n = listToMaybe . drop n $ xs in [1..] !!! (-3)
08:15:10 <lambdabot>   Just 1
08:15:32 <baaba> @undefine
08:15:56 <baaba> @let [] !!! _ = Nothing; _ !!! x | x < 0 = Nothing; (x:_) !!! 0 = Just x; (_:xs) !!! i = xs !!! (i-1)
08:15:57 <lambdabot>  Defined.
08:15:57 <dmwit> baaba: right
08:16:09 <baaba> > [1..] !!! (-1)
08:16:11 <lambdabot>   Nothing
08:16:23 <dmwit> > let xs !!! n | n < 0 = Nothing | otherwise = listToMaybe . drop n $ xs in [1..] !! (-1)
08:16:25 <lambdabot>   * Exception: Prelude.(!!): negative index
08:16:31 <dmwit> > let xs !!! n | n < 0 = Nothing | otherwise = listToMaybe . drop n $ xs in [1..] !!! (-1)
08:16:33 <lambdabot>   Nothing
08:16:37 <dmwit> > let xs !!! n | n < 0 = Nothing | otherwise = listToMaybe . drop n $ xs in [1..] !!! 13
08:16:38 <lambdabot>   Just 14
08:17:18 <dons> a little project i'm working on, http://code.haskell.org/~dons/docs/liboleg/
08:17:24 <dons> any thoughts lads and lasses?
08:17:30 <pumpkin> liboleg!
08:17:34 <dmwit> haha liboleg
08:17:53 <dons> i've mailed oleg about bundling all his modules. i'm sure he'll be pleased to see reuse
08:18:45 <quicksilver> dons: are many of them in reusable form, though?
08:18:58 <quicksilver> dons: I thought most of them were most like examples of what you can do if you try
08:19:02 <quicksilver> rather than complete usable library code
08:19:56 <dons> quicksilver: right, they're mostly little demo ideas
08:22:00 <dons> http://www.reddit.com/r/haskell/comments/7mz15/record_selectors_just_got_cheaper_ghc_now_exposes/
08:22:03 <dons> yay
08:22:46 <lilac> > let xs !!! n = unsafePerformIO $ (return $! xs !! n) `catch` pure Nothing in [1,2,3] !! 10
08:22:47 <lambdabot>   Not in scope: `unsafePerformIO'    Ambiguous occurrence `pure'
08:22:47 <lambdabot>      It coul...
08:22:55 <quicksilver> dons: oh, that is interesting.
08:22:57 <bohdan> is there something like Math package with all the toy functions 1st grade studends get as their homework? (primes/gcd/etc)
08:23:00 <quicksilver> I didn't know they were special.
08:23:40 <dons> bohdan: hmm. gcd is in the Prelude :)
08:23:46 <beelsebob> lilac: catch doesn't work in unsafePerformIO
08:23:53 <bohdan> ok, the other gcd :)
08:23:58 <bohdan> lcd that is
08:23:58 <pumpkin> bohdan: we even have lcm in the prelude!
08:24:00 <pumpkin> fancy, eh
08:24:04 <bohdan> ah
08:24:10 <pumpkin> > foldl lcm [1..10]
08:24:11 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
08:24:11 <lambdabot>        arising from a use...
08:24:13 <bohdan> what about prime numbers ? :)
08:24:39 <pumpkin> > foldl1 lcm [1..10]
08:24:41 <lambdabot>   2520
08:24:54 <bohdan> also factorial
08:25:01 <pumpkin> you can write factorial yourself :P
08:25:04 <bohdan> fibonacci :)
08:25:06 <pumpkin> primes there are things for
08:25:15 <bohdan> there should be a module :)
08:25:17 <pumpkin> why would you need fibonacci in the prelude? :P
08:25:19 <bohdan> import Toys
08:25:35 <pumpkin> http://www.haskell.org/haskellwiki/Prime_numbers
08:25:47 <bohdan> so that I could test my toy functions against real ones with quickCheck
08:27:04 <dons> Toys would be fun.
08:27:10 <dons> we could just point people at it for homework :)
08:27:17 <pumpkin> hah
08:29:30 <athos> hi all!
08:29:42 <hallongrottan> hello athos
08:30:25 <chessguy_work> hiya athos
08:30:34 <dmwit> You guys.
08:30:36 <dmwit> Shut up.
08:30:40 <dmwit> None of you is all.
08:30:56 <all> hi athos!
08:31:00 <dmwit> =D
08:31:31 <adrian_> where do I find something about the typeclass hierarchy in haskell?
08:31:33 <all> now I get highlighted every time someone writes > all even [2,4..100]
08:31:50 <chessguy_work> adrian_, you mean, for all the typeclasses?
08:31:50 <adrian_> I remember some graphic, but I can't find it on the wiki
08:31:59 <byorgey> adrian_: it's in the online report
08:32:02 <byorgey> @where report
08:32:03 <lambdabot> http://www.haskell.org/onlinereport/
08:32:04 <all> onoes I got highlighted
08:32:07 <all> I don't like this nick
08:32:11 <adrian_> great, thank you
08:32:47 <byorgey> > pumpkin even [2,4..100]
08:32:49 <lambdabot>   True
08:32:52 <pumpkin> lol
08:33:04 <bohdan> what?
08:33:07 <bohdan> how? :)
08:33:17 <pumpkin> probably @let pumpkin = all
08:33:17 <bohdan> > xxx
08:33:18 <lambdabot>   Not in scope: `xxx'
08:33:27 <athos> heya byorgey
08:33:29 <chessguy_work> > bohdan even [2..100]
08:33:30 <athos> happy new year :)
08:33:31 <lambdabot>   mueval: Prelude.read: no parse
08:33:31 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
08:33:31 <bohdan> > xxx
08:33:32 <lambdabot>   1
08:33:41 <byorgey> hey athos, happy new year =)
08:33:59 <lilac> beelsebob: good ol' unsafePerformIO :) any idea why?
08:34:12 <chessguy_work> welcome to the year of hackage  :)
08:34:12 <beelsebob> lilac: no idea
08:34:29 <athos> byorgey: btw: i wrote a letter to santa claus, which reads like "XX.) dear santa claus, make byorgey writing more entries to his math blog next year"
08:34:32 <athos> 8)
08:34:48 <byorgey> athos: oh, I know, he mentioned that
08:34:58 <byorgey> I told him I'd see what I can do
08:34:59 <athos> hehe
08:35:06 <athos> great
08:35:10 <chessguy_work> does that mean byorgey will go on the naughty list if he doesn't?
08:36:05 <byorgey> well, more like byorgey will lose his Platinum Preferred Gift Recipient status
08:36:15 <chessguy_work> heh
08:36:34 <chessguy_work> so, any ideas on a more natural way of expressing this? http://hpaste.org/13522
08:37:23 <leimy> Was thinking about how Erlang does "state" with the gen_server module.
08:37:34 <leimy> and how it could be compared with monads
08:38:14 <leimy> the state is suspended in arguments to the loops in the gen_server instance.
08:38:16 <lilac> chessguy_work: i suspect i'd want two KB monads, one which allows writing (ala State) and one which doesn't (ala Reader)
08:38:43 <leimy> kind of like how you get Monads to thread state through different monadic actions.
08:38:44 <mercury^> Why are n+k patterns considered bad?
08:38:48 <lilac> chessguy_work: is that all that's going to be in your interface
08:39:00 <lilac> mercury^: they suggest a representation that isn't correct, and perform operations which aren't obvious
08:39:04 <chessguy_work> lilac, probably
08:39:05 <lilac> s/correct/used/
08:39:18 <leimy> the only difference is that there's a sort of context switch, and one could write the same code with forkIO in haskell, and not really need the monad though it would clean the code up a lot.
08:39:49 <mercury^> Hmm, unless there is a natural number type, they are quite useful I find.
08:40:11 <chessguy_work> lilac, so you're saying that the first one does both reading and writing?
08:40:19 <lilac> mercury^: yes, they're useful, which is probably why they still exist :)
08:40:21 <pumpkin> n+k patterns?
08:40:35 <leimy> this makes me wonder if there's a way to make the typed channel IO mechanism of control for Haskell cleaner by putting some of that messages reception then function calling "event handling" via some weird Monad
08:40:39 <byorgey> > let f (n+1) = n  in f 3
08:40:41 <lambdabot>   2
08:40:47 <pumpkin> oh
08:40:47 <byorgey> pumpkin: like that ^^^
08:40:48 <lilac> chessguy_work: perhaps. is it more efficient to split up the creation and querying passes? is that compatible with your usage model?
08:40:52 <int80_h> having trouble with happs-tutorial...this is what happens when I try to install it
08:40:55 <int80_h> $ cabal install happs-tutorial
08:40:56 <int80_h> There is no available version of base that satisfies >=3.0.3.
08:40:59 <int80_h> Resolving dependencies...
08:41:01 <int80_h> cabal: cannot configure happs-tutorial-0.6.3. It requires base >=3.0.3.0
08:41:13 <chessguy_work> lilac, i don't really have a usage model yet :)
08:41:32 <byorgey> int80_h: looks like you need base-4 (which comes with ghc 6.10.1)
08:41:44 <int80_h> okay dokey
08:41:44 <lilac> chessguy_work: an alternative interface for that model would be "[Prop] -> (Prop -> Bool)"
08:42:06 <chessguy_work> lilac, so the State-ish one would basically be a copy and paste of the State code, with a few tweaks
08:42:23 <rwbarton> chessguy_work: what you have looks good to me
08:42:23 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
08:42:31 <sdubois92> In gentoo, i added the haskell overlay and when i emerge cabal it fails and says Could not find module `Text.PrettyPrint'
08:42:46 <chessguy_work> rwbarton, interesting. thanks for the comment
08:44:01 * pumpkin is annoyed by that "STM debunked" article on reddit
08:45:17 <roconnor> pumpkin: where?
08:45:32 <pumpkin> http://www.reddit.com/r/programming/comments/7mwmm/software_transactional_memory_debunked/
08:45:34 <chessguy_work> lilac, i don't get that model
08:45:37 <pumpkin> mostly because the cited paper doesn't really say that
08:46:07 <smtms> pumpkin, what does the paper say?
08:46:24 <pumpkin> I haven't read it, but even the portions he cites in the blog post don't say that :P
08:46:42 <chessguy_work> lilac, you'd have to know every proposition you want in the KB up front with that model
08:47:04 <chessguy_work> lilac, whereas with the ask/tell structure, you can do it incrementally
08:48:38 <vixey> dons, cool! (liboleg)
08:48:52 <leimy> concurrency is not always related to performance
08:48:58 <leimy> it can be a way to write programs
08:49:05 <chessguy_work> @vixey cool!
08:49:05 <lambdabot> how cool?
08:49:13 <leimy> but a lot of people have a hell of a time grasping that.
08:49:24 <leimy> code can be much cleaner if written in the actor model
08:49:34 <sclv> that's like the fourth go-round on reddit of that terrible article.
08:50:06 <pumpkin> I dislike how much anti-academic sentiment there is in the "programming" community
08:50:18 <leimy> yeah
08:51:28 <kaol> concurrency /= parallelism
08:51:40 <pumpkin> yeah, someone pointed that out in that thread, too
08:51:44 <leimy> good
08:51:59 <lilac> chessguy_work: so your usage model isn't "build a KB then query it" then? :)
08:52:10 <chessguy_work> lilac, i suppose not
08:52:35 <chessguy_work> lilac, more like build it, query it, add some more info, query again, etc.
08:52:38 <sclv> on the other hand, the blog post isn't that awful, since it recognizes that purity is what makes stm work
08:52:56 <pumpkin> sclv: my main issue is the sensationalist title, really
08:53:01 <pumpkin> debunked really is a little strong
08:53:12 <pumpkin> sure, it doesn't solve world hunger :P
08:53:15 <sclv> and conversely, any transactional memory without language support (i.e. referential transparency) is going to beawkward.
08:53:38 <sclv> the article he writes about is awful because it's only about stm extensions to e.g. c++ which of course is going to be a nightmare.
08:53:43 <dons> debunking strawmen
08:53:53 <pumpkin> :)
08:54:07 <sclv> functional programming does your laundry and makes toast: debunked!
08:54:22 <leimy> yeah
08:54:38 <SamB_XP> sclv: eh ?
08:54:49 <leimy> That's ok though... if less people know how to use the good tools and technology I can charge more per hour.
08:54:50 <SamB_XP> sclv: someone might have done it!
08:54:54 <leimy> so let them say it's debunked :-)
08:55:37 <pumpkin> leimy: lol
08:55:47 <chessguy_work> leimy, ha! definitely not the prevailing attitude in the community right now
08:56:14 <pejo> sclv, there was a paper at ICFP with STM for some dialect of ML, handling some mutation in the transactions.
08:56:58 <leimy> chessguy_work: Well my boss thinks it's great we use Erlang, thinks it's like an instant advantage over those floundering around hopelessly in Java :-)
08:57:22 <leimy> He likes to be a little ahead of the curve.
08:57:38 <sclv> pejo: sure, but c++?!
08:58:07 <pejo> sclv, shrug. Who knows?
08:58:23 <sclv> the paper actually makes a pretty good case for why it doesn't work so well...
08:58:35 <leimy> I like what they did in Plan 9 and Inferno for concurrency
08:58:37 <sclv> it just goes on to assume that it'll be that way for all languages.
08:58:46 <leimy> and really stuck to that abstraction to see how far they could take it.
08:58:50 <int80_h> lambdabot: do my laundry
08:58:54 <int80_h> bah
08:58:54 <leimy> the whole typed data channel thing is neat.
08:59:11 <int-e> @faq can Haskell do int80_h's laundry?
08:59:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:59:12 <int80_h> my pants are still dirty
08:59:25 <pejo> sclv, I haven't read the paper yet, but who knows how good the optimizers/alias analysis will be in 10 or 15 years?
08:59:26 * int80_h giggles
08:59:29 <beelsebob> she didn't say Haskell *will* do that int80_h
09:00:03 <cognominal> `one of my hero, one of the author of dtrace is very critical about STM.
09:00:27 <cognominal> But this guy lives very much in the kernel space, that must skew his perception
09:00:53 <chessguy_work> @do my laundry
09:00:54 <lambdabot> my laundry not available
09:01:01 <SamB_XP> oops
09:01:04 <pumpkin> yeah, dtrace is an awesome achievement, but I wouldn't extrapolate too much from that :P
09:01:05 <cognominal> for all I am concerns, STM made it in parrot
09:01:27 <leimy> dtrace is very domain specific :-)
09:01:31 <pejo> cognominal, is that the guy who asked David S Miller if he had ever kissed a girl, roughly in 1996?
09:01:40 <redditbot> Record selectors just got cheaper: GHC now exposes selectors to full optimisations
09:01:40 <redditbot> Type-level call-by-value lambda-calculator in three lines of Haskell
09:01:40 <redditbot> The GHC OpenSPARC project is underway! Exploiting the multithreaded T2 arch with Haskell
09:01:52 <leimy> Neat
09:02:10 <chessguy_work> mmm, where's the haskell reddit again?
09:02:16 <koeien> see tpic
09:02:17 <koeien> topic*
09:02:25 <cognominal> I tried to use dtrace on  parrot, and when I tried to print call stacks all I get is hexadecimal numbers :(
09:02:32 <quicksilver> haskell.reddit.com
09:02:36 <quicksilver> (surprisingly enough!)
09:02:44 <schme> Or just reddit.com in general.
09:02:49 <schme> Yes, it was funny.
09:03:22 <cognominal> I which I had time to learn more of  haskell, but just reading all these papers on monads, idioms and type theory opened very much my mind.
09:04:10 <cognominal> and seing the ideas making it on mainstreams language proves that haskell is doing some things right.
09:04:53 <chessguy_work> haskell is doing an awful lot of things right
09:05:42 <cognominal> well, the down side is you need to know a lot of things to start.
09:06:24 <quicksilver> cognominal: yes, programming tends to be like that.
09:06:24 <cognominal> not that I advocate the PHP way, which is knowing nothing and try to get by from there.
09:06:58 <int80_h> comparing PHP to haskell is like comparing a machine building machine to a rusty nail.
09:06:59 <wchogg> although I think books like Real World Haskell are lowering the barrier of entry by quite a bit.  It's the kind of thing I wish I had two years ago.
09:07:11 <cognominal> I like perl because it allows to start with very little knowledge and do domething
09:07:20 <cognominal> but Perl5 has to much cruft.
09:07:20 <quicksilver> no it doesn't.
09:07:29 <quicksilver> starting with perl requires knowing just as much as starting haskell.
09:07:36 <quicksilver> (different things though)
09:07:40 <chessguy_work> hiya wchogg
09:07:50 <wchogg> chessguy_work : hey
09:08:02 <cognominal> wchogg, I am reading RWH. That's probably what haskell needs right now.
09:08:09 <chessguy_work> we gonna rock the PCI ?
09:08:14 <int80_h> I'm expecting my copy in a few days
09:08:18 <cognominal> bootstrapping more people...
09:08:35 <anRch> cabal install anything resolving dependencies ...  with 6.10.1 on osx?
09:08:48 <wchogg> chessguy_work : Oh, did you e-mail me about that?
09:08:56 <cognominal> quicksilver, may be I am biased, I started with perl when the manual was one page long.
09:08:56 <chessguy_work> yep
09:09:03 <sbahra> cognominal, yesterday I spent 1 hour teaching someone who doesn't really know any other programming language, Haskell.
09:09:15 <sbahra> cognominal, he's loving it. He is able to write some useful things now.
09:09:26 <chessguy_work> wchogg, looks like a great book. i don't know how it was under my radar before you mentioned it
09:09:35 <sbahra> Understands ADTs, type classes, etc...
09:09:40 <wchogg> chessguy_work : Yeah, I was going to try and do some preliminary organization for that reading group tonight.
09:09:41 <cognominal> probably I shoud spend more time reading the backlog on this channel
09:09:42 <anRch> ... consuming cpu and memory
09:09:59 <chessguy_work> wchogg, good deal. has there been much other interest?
09:10:11 <wchogg> chessguy_work : ~10 people, including the author
09:10:16 <chessguy_work> sweet
09:10:18 <cognominal> audrey did a great job popularizing haskell in the Perl world
09:10:39 <chessguy_work> wchogg, i'm pidling around with doing some AIMA code too
09:10:48 <cognominal> to bead she had health problem and she is not any more around doing Perl 6 in haskell
09:10:51 <chessguy_work> s/dl/ddl/
09:11:03 <wchogg> chessguy_work : Oh, yeah we should keep in touch on that.  It's another on my 'to-do' list of books.
09:11:04 <Gilly> > product [1..5]
09:11:06 <lambdabot>   120
09:11:34 <Gilly> ops :) didn't remember i had scrolled up and was about to answer a question someone asked back there
09:12:12 <cognominal> sbahra, learning a new language is very much unlearning the idioms not relevant to it. I can understand that starting with haskell may not be more difficult.
09:12:18 <chessguy_work> wchogg, haskell really needs an AI framework
09:12:53 <sbahra> cognominal, this was a counter-statement to "I like perl because it allows to start with very little knowledge and do domething"
09:13:05 <sbahra> cognominal, but I do agree with this.
09:13:20 <pumpkin> I asked the github guys about hosting a haskell package repo a bit like they do for rubygems, and they asked me to submit a proposal about how it would work and what they would have to do to get it working... does anyone have any suggestions?
09:13:29 <cognominal> btw, is there possibility to do haskell and cocoa?
09:13:40 <wchogg> chessguy_work : Seems like it'd be a nice fit, really.
09:13:45 <quicksilver> There are bindings which are not particularly mature, cognominal
09:14:05 <cognominal> thx, quicksilver
09:14:39 <chessguy_work> wchogg, i wish i could take 6 months, build an industrial strength AI library in haskell, and then start contracting it out. that'd be sweet
09:14:58 <Gilly> Lemmih: I was testing LHC but ran fast into a segmentation fault by trying to print $ foldl (+) 0 [1..1000000]
09:17:16 <wchogg> chessguy_work : Heh, yeah I'm trying to turn my time in between jobs into something productive like that.  Not as ambitious, but I have a few very practical projects I'm hoping to contribute to the community.
09:17:43 <cognominal> turbinado?
09:17:50 <chessguy_work> wchogg, yeah, that's a completly fantasy wish :)
09:20:07 <wchogg> chessguy_work : Eh, nothing wrong with a complete fantasy if you have the finances to try it.
09:20:10 <chessguy_work> wchogg, what kind of projects are you working on
09:20:37 <chessguy_work> wchogg, i don't :)
09:21:20 <wchogg> chessguy_work :  I've been doing a lot of studying recently, but I've been working a bit on linux bluetooth bindings for Haskell.  It's kinda working, but it has no real error handling at all.  I'm going to try & fix that up then maybe make a prelim release.
09:21:23 <Lemmih> Gilly: Yeah, that happens.
09:25:46 <chessguy_work> wchogg, i see
09:29:33 <slint1> Question: As soon as I import Graphics.X11.Xlib ghc says: main.o: In function `sM2_info':
09:29:33 <slint1> (.text+0x145): undefined reference to `__stginit_X11zm1zi4zi2_GraphicsziX11ziXlib_'
09:29:33 <slint1> Do I have to use some additional flags, or something similiar?
09:30:28 <Lemmih> slint1: Did you use --make?
09:30:40 <pumpkin> @yhjulwwiefzojcbxybbruweejw
09:30:41 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
09:30:52 <slint1> no
09:31:04 <slint1> thx
09:31:28 <pumpkin> wasn't there a command to demangle those names?
09:31:43 <EvilTerran> preflex: zdec __stginit_X11zm1zi4zi2_GraphicsziX11ziXlib_
09:31:43 <preflex>  __stginit_X11-1.4.2_Graphics.X11.Xlib_
09:31:58 <EvilTerran> hm
09:32:07 <pumpkin> thanks :)
09:33:31 <CakeProphet> > (max 0) [-10..10]
09:33:33 <lambdabot>       No instance for (Num [t])
09:33:33 <lambdabot>        arising from the literal `0' at <inter...
09:33:40 <CakeProphet> > map (max 0) [-10..10]
09:33:42 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10]
09:40:42 <bohdan> > [-10..10] >>= return . max 0
09:40:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10]
09:41:45 <Cale> x >>= return . f = fmap f x
09:42:43 <CakeProphet> @help instances-importing
09:42:44 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
09:42:57 <CakeProphet> @help instances
09:42:58 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
09:43:09 <CakeProphet> @instances Functor
09:43:10 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:43:30 <cognominal> @help
09:43:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:43:47 <cognominal> @help list
09:43:48 <lambdabot> list [module|command]
09:43:48 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
09:44:08 <pumpkin> > fmap (+1) (1,3) == second (+1) (1,3)
09:44:09 <lambdabot>   True
09:44:17 <pumpkin> hmm
09:44:23 <pumpkin> > fmap (+1) (1,3)
09:44:25 <lambdabot>   (1,4)
09:44:58 <hugo___> i have (a,b) and i want to liftit to IO (a,b) how do i do it ?
09:45:04 <cognominal> why not (2, 4) ?
09:45:05 <pumpkin> return ?
09:45:12 <pumpkin> cognominal: beats me :)
09:45:27 <CakeProphet> hugo___:  return (a,b)
09:45:30 <hugo___> oh sorry
09:45:34 <hugo___> i didn't explain well
09:45:35 <Saizan> because instance Functor ((,) a) where ...
09:45:41 <hugo___> i want to apply snd on a IO (a,b)
09:45:44 <hugo___> how do i do it ?
09:45:49 <pumpkin> Saizan: yeah, I understand that, but why is it defined that way?
09:45:50 <SamB> liftM snd
09:46:08 <SamB> pumpkin: well, it can't be defined any other way!
09:46:17 <pumpkin> SamB: :o
09:46:29 <EvilTerran> pumpkin, because it's "instance Functor ((,) w) where fmap :: (a -> b) -> ((,) w) a -> ((,) w) b"
09:46:30 <CakeProphet> > liftM (map (+3)) [1..10]
09:46:31 <hugo___> oh, i was trying liftIO, but it complaints about matchin IO b against inferred type `(a, b1) -> b1'
09:46:32 <lambdabot>       No instance for (Enum [a])
09:46:32 <SamB> Functors are always over their last type parameter in Haskell
09:46:32 <lambdabot>        arising from the arithmetic sequence ...
09:46:46 <baaba> > let sndM = liftM snd in sndM $ Just (1, 2)
09:46:47 <lambdabot>   Just 2
09:46:49 <CakeProphet> hmmm
09:46:52 <pumpkin> SamB: ah
09:47:29 <CakeProphet> :t liftIO
09:47:31 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
09:47:40 <EvilTerran> pumpkin, if you wanted a Functor instance over both parts of a pair, you'd need "newtype Pair a = Pair (a,a); instance Functor Pair" or something
09:47:48 <pumpkin> ah, I see :)
09:47:58 <CakeProphet> hugo___:  that's because liftIO doesn't want a function.
09:48:03 <pumpkin> I don't particularly want one, was just curious why it worked that way
09:48:06 <CakeProphet> I think you probably want liftM
09:48:14 <pumpkin> I can use join *** or something :P
09:48:32 <EvilTerran> "everywhere" :P
09:48:47 <CakeProphet> > unsafePerformIO (liftM (+3) (return 3))
09:49:03 <lambdabot>   Not in scope: `unsafePerformIO'
09:49:21 <hallongrottan> ceiling cat is watching you CakeProphet...
09:49:29 <EvilTerran> , everywhere (mkT (+1)) (1,2)
09:49:32 <lunabot>  (2,3)
09:49:38 <CakeProphet> ....ceiling cat>
09:49:49 <pumpkin> http://isit2009yet.com/
09:50:00 <hallongrottan> CakeProphet: http://arcanux.org/lambdacats/unsafeperformio.jpg
09:50:01 <EvilTerran> er
09:50:01 <hallongrottan> =)
09:50:16 <CakeProphet> celing (interact read)
09:50:29 <CakeProphet> celing (interact read::Double)
09:50:30 <SamB> pumpkin: it's not very satisfying, having such arbitrary restrictions, but I don't think you can get rid of them without somewhat incoherant instances, like Coq allows
09:50:31 <CakeProphet> :3
09:50:54 <SamB> pumpkin: which kinda makes it tricky to get the right one ;-P
09:50:58 <pumpkin> SamB: yeah
09:51:09 <CakeProphet> hallongrottan:  I think unsafePerformIO is acceptable on lambdabot. ;) since she doesn't like IO.
09:51:28 <SamB> pumpkin: I mean, you basically have to make 'em first class for that to be sensible
09:52:00 <EvilTerran> first-class typeclass instances? sounds like fun
09:52:06 <mohbana> hi, i'm trying to build pandoc with kate-highlighting and it fails; http://pastebin.com/d2a1638b8
09:52:33 <hallongrottan> CakeProphet: haha :)
09:52:47 <Saizan> mohbana: Base.hsc:103:18: error: pcre.h: No such file or directory
09:53:07 <Saizan> mohbana: you've to install the pcre C library
09:53:21 <mohbana> Saizan: from my distro?
09:53:30 <Saizan> mohbana: yes
09:53:37 <gour> i plan to use sqlite3 as my application storage format, although there is possibility (for some use-cases) to use postgres in order to be able to access database over NFS. considering that hdbc does nice abstraction, i wonder what would be pro/cons in using odbc driver vs. sqlite3/postgres?
09:53:48 <Saizan> mohbana: and if your distro has -dev packages you've to install that
09:53:54 <pumpkin> I wonder where mmorrow went :o
09:54:18 <quicksilver> pumpkin: he suffered a Y2K9 bug, and winked out of existence ;(
09:54:27 <pumpkin> onoes!
09:55:30 <Olathe> At least the thing that checks that huge particle accelerator has code to verify that the page is correct.
09:57:07 <Olathe> Apparently they changed it.
09:58:23 <Olathe> Ahh, yes: if (!(typeof worldHasEnded == "undefined")) {document.write("YUP.");} else {document.write("NOPE.");}
09:59:46 <mohbana> Saizan: why do i need a C library to build syntax highlighting, it seems pretty strange to me and i thought cabal takes care of all the deps (btw, i quite new to this, i don't use haskell much).  here's the page; http://hackage.haskell.org/cgi-bin/hackage-scripts/package/highlighting-kate
10:01:01 <pumpkin> mohbana: it only takes care of dependencies on hackage
10:01:41 <dmwit> > ((==) `on` ($ succ $ (1, 3))) fmap second
10:01:42 <lambdabot>   Couldn't match expected type `(t, t1)'
10:01:53 <dmwit> :t (==) `on` ($ succ $ (1, 3))
10:01:54 <lambdabot> forall b t t1. (Num t1, Num t, Enum (t, t1), Eq b) => ((t, t1) -> b) -> ((t, t1) -> b) -> Bool
10:01:55 <CakeProphet> :t (on)
10:01:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:02:05 <athos> @src on
10:02:05 <lambdabot> (*) `on` f = \x y -> f x * f y
10:02:18 <dmwit> oh, right
10:02:26 <Olathe> @index on
10:02:26 <lambdabot> bzzt
10:02:39 <Olathe> Ahh, the huge bzzt library.
10:02:52 <dmwit> Wait... why didn't that work, then?
10:02:57 <dmwit> :t ($ succ $ (1, 3))
10:02:58 <lambdabot> forall b t t1. (Num t1, Num t, Enum (t, t1)) => ((t, t1) -> b) -> b
10:03:09 <EvilTerran> :t (==) `on` (($ (1, 3)) . ($ succ))
10:03:10 <lambdabot> forall b t t1 a. (Enum a, Num t1, Num t, Eq b) => ((a -> a) -> (t, t1) -> b) -> ((a -> a) -> (t, t1) -> b) -> Bool
10:03:17 <dmwit> looks better
10:03:24 <EvilTerran> ((==) `on` (($ (1, 3)) . ($ succ))) fmap second
10:03:26 <EvilTerran> > ((==) `on` (($ (1, 3)) . ($ succ))) fmap second
10:03:28 <lambdabot>   True
10:03:28 <Olathe> > ($ succ $ (1, 3)) fmap
10:03:32 <lambdabot>   Couldn't match expected type `(t, t1)'
10:03:42 <EvilTerran> ($ f $ x) = ($ (f x))
10:03:46 <dmwit> yep
10:03:47 <dmwit> silly me
10:03:49 <pumpkin> where does on come from then?
10:03:53 <dmwit> Data.Function
10:03:55 <EvilTerran> ($) is infixr, even if it shouldn't be :P
10:03:57 <pumpkin> ah, thanks
10:04:09 <lilac> it's the only useful part of Data.Function
10:04:10 <dmwit> What ever happened to \bot doing Caleskell? =)
10:04:19 <EvilTerran> if it was infixl, ($ f $ x) would be a parse error, tho =/
10:04:30 <athos> > (+) `on` exp 2 3
10:04:32 <lambdabot>       Overlapping instances for Show (a -> a -> b)
10:04:32 <lambdabot>        arising from a use ...
10:04:33 <Olathe> Caleskell < Hascale.
10:04:55 <athos> > (+) `on` exp $ 2 3
10:04:56 <lambdabot>       precedence parsing error
10:04:56 <lambdabot>          cannot mix `on' [infixl 0] and `($)' ...
10:05:00 <athos> :o
10:05:00 <dmwit> :t let infixl 0 $; f $ x = f x in ($ succ $ (1, 3))
10:05:01 <lambdabot>     The operator `$' [infixl 0] of a section
10:05:01 <lambdabot>         must have lower precedence than the operand `($)' [infixl 0]
10:05:01 <lambdabot>         in the section: `($ succ $ (1, 3))'
10:05:09 <dmwit> bummer
10:05:13 * EvilTerran still thinks (OP ...) should desugar to (\x -> x OP ...), before precedence evaluation
10:05:22 <athos> :t ((+) `on` exp)
10:05:23 <lambdabot> forall a. (Floating a) => a -> a -> a
10:05:27 <dmwit> > ((+) `on` exp) 2 3
10:05:29 <lambdabot>   27.47459302211832
10:05:31 <athos> > ((+) `on` exp) 2 3
10:05:32 <lambdabot>   27.47459302211832
10:05:37 <dmwit> too slow ;-)
10:05:38 <athos> ah i see
10:05:38 <lilac> EvilTerran: what about (OP ... OP) ?
10:05:40 <athos> :)
10:05:41 <EvilTerran> it'd give (OP ... OP) a consistent meaning, too
10:05:46 <lilac> indeed :)
10:05:51 <EvilTerran> lilac, yup :)
10:06:11 * EvilTerran has frequently wanted (++ [...] ++), for starters
10:06:21 <athos> > ((*) `on` exp) 2 3 == exp 5
10:06:22 <lambdabot>   True
10:06:28 <lilac> > map (*2+1) [1..5]
10:06:29 <lambdabot>       The operator `*' [infixl 7] of a section
10:06:29 <lambdabot>          must have lower prece...
10:06:30 <EvilTerran> ?src intercalate
10:06:30 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:06:32 <lilac> yay
10:06:36 <dmwit> EvilTerran: I disagree.
10:06:36 <athos> ah ok!
10:06:44 <CakeProphet> (OP ...)  doesn't work?
10:06:47 <EvilTerran> intercalate xs = foldr (++xs++) []
10:06:49 * CakeProphet uses it all the time.
10:06:53 * SamB wonders where he could find cliff's notez
10:07:02 <dmwit> EvilTerran: Consider the two cases where (++) is right- and left-associative in (++ [...] ++).
10:07:13 <mohbana> Saizan_: and pumpkin thanks
10:07:21 <EvilTerran> dmwit, ... yes?
10:07:22 <dmwit> EvilTerran: The associativity should determine which (++) gets applied first, but your scheme makes that impossible...
10:07:34 <EvilTerran> does it?
10:07:43 <coco> Hi everyone! Can I make Random.StdGen perisistent?
10:07:46 <dmwit> Yes.  Your scheme always applies the left ++ first.
10:07:50 <EvilTerran> it'd make it (\x y -> x ++ [...] ++ y)
10:08:02 <CakeProphet> coco:  persistent as in... saved to a file?
10:08:03 <dmwit> coco: What do you mean by persistent?
10:08:14 <EvilTerran> and *then* work out the associativity
10:08:21 <SamB> EvilTerran: yeah, I'm always annoyed when that doesn't work ;-P
10:08:25 <coco> dmwit, EvilTerran: yes, in the Data typeclass
10:08:28 <dmwit> EvilTerran: Well, I'll be damned.  You're totally right.
10:08:32 <EvilTerran> :D
10:08:42 * EvilTerran has thought this through, honest :)
10:08:53 <coco> (I meant CakeProphet, sorry)
10:08:58 <dmwit> EvilTerran: So, where's the Haskell' proposal that I can vote for?
10:09:10 <SamB> dmwit: I thought Haskell' had been cancelled
10:09:11 <EvilTerran> the only problem would be the occasional expectation that (* 2 + 1) was (* (2+1)), and you'd only make that mistake once
10:09:22 <SamB> dmwit: settle for a GHC feature request ticket
10:09:27 <lilac> EvilTerran: i'd /hope/ that's rare :)
10:09:32 <dmwit> SamB: I thought Haskell' had been accelerated to a real release schedule... =/
10:09:39 <lilac> EvilTerran: esp. since it doesn't work in haskell'98
10:09:44 <CakeProphet> coco:  still don't understand.
10:09:47 <EvilTerran> lilac, the risk of that is why it is like it is in h98
10:09:51 <rwbarton> > (* 2 + 1) 10
10:09:52 <lambdabot>       The operator `*' [infixl 7] of a section
10:09:52 <lambdabot>          must have lower prece...
10:09:57 <lilac> EvilTerran: (+1 * 1+)
10:09:58 <rwbarton> Ah good :)
10:10:02 <coco> I want to dump a StdGen into a file and then continue to use it later
10:10:14 <CakeProphet> transparently or manually?
10:10:17 <dmwit> > show (newStdGen 0)
10:10:18 <lambdabot>   Couldn't match expected type `t -> a'
10:10:19 <CakeProphet> manually is very easy.
10:10:21 <rwbarton> @src StdGen
10:10:21 <lambdabot> Source not found. It can only be attributed to human error.
10:10:24 <SamB> > (++ [] ++)
10:10:24 <dmwit> :t newStdGen
10:10:25 <lambdabot>   <no location info>: parse error on input `)'
10:10:26 <lambdabot> IO StdGen
10:10:27 <rwbarton> , src ''StdGen
10:10:29 <dmwit> oops
10:10:34 <rwbarton> :t mkStdGen
10:10:36 <lambdabot> Int -> StdGen
10:10:37 <lunabot>  data StdGen = StdGen Int32 Int32
10:10:39 <EvilTerran> because the only cases allowed in h98 are those where desugaring then resolving associativity is equivalent to resolving associativity first
10:10:46 <CakeProphet> coco:  use mkStdGen
10:10:46 <lilac> EvilTerran: the ability to say (*2 + 3*) would be nice :)
10:10:49 <dmwit> ?instances-importing System.Random Show
10:10:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, StdGen, Sum a, [a]
10:10:51 <rwbarton> CakeProphet: You should be able to use a standalone deriving declaration
10:10:55 <dmwit> ?instances-importing System.Random Read
10:10:56 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, StdGen, Sum a, [a]
10:11:06 <CakeProphet> rwbarton:  hmmm?
10:11:07 <rwbarton> lilac: I fear this will be abused to make a whole new class of smiley operators :P
10:11:08 <SamB> should mixed precedence/fixity be allowed in double-sections?
10:11:14 <EvilTerran> lilac, as an added bonus, it'd confuse the hell out of the ML-ers :P
10:11:17 <lilac> rwbarton: of course it will :) that's part of the fun
10:11:19 <dmwit> Well, there's Show and Read instances already, at least.
10:11:23 <Saizan_> coco: you can use read and show
10:11:26 <vixey> is lambda calculus a higher order rewrite system?
10:11:28 <dmwit> ?instances-importing System.Random Data
10:11:29 <lambdabot> Couldn't find class `Data'. Try @instances-importing
10:11:35 <dmwit> ?instances-importing System.Random Data.Data Data
10:11:35 <lambdabot> Couldn't find class `Data'. Try @instances-importing
10:11:35 <rwbarton> CakeProphet: There is a GHC extension that lets you say 'deriving instance Data StdGen', IIRC
10:11:41 <dmwit> ?index Data
10:11:42 <lambdabot> Data.Generics.Basics, Data.Generics
10:11:45 <lilac> EvilTerran: it'll allow for a whole new class of haskell / lisp bilingual programs
10:11:52 <CakeProphet> oh, neat.
10:12:02 <dmwit> ?instances-importing System.Random Data.Generics
10:12:02 <dmwit> ?instances-importing System.Random Data.Generics Data
10:12:02 <lambdabot> Couldn't find class `Data.Generics'. Try @instances-importing
10:12:02 <lambdabot> (), (a -> b), (a, b), (a, b, c), (a, b, c, d), Bool, Char, DataType, Double, Either a b, Float, IO a, Int, Integer, Maybe a, Ordering, ST s a, TyCon, TypeRep, [a]
10:12:02 <coco> I'm using HAppS and I want to put the random number generator in the state
10:12:02 <mattam> vixey: yes.
10:12:14 <coco> therefore HAppS wants it to be in the Data type class
10:12:29 <dmwit> coco: String is in the Data type class. ;-)
10:12:32 <coco> (I'm not sure what this type class is good for)
10:12:34 <CakeProphet> rwbarton:  I fail to see that being a problem. I think Haskell, as a whole, needs more smiley operators.
10:12:36 <SamB> I think (*2 + 3*) should be a different extension from (++ [] ++)
10:12:39 <dmwit> coco: But also pay attention to rwbarton, he's a Pretty Smart Guy.
10:12:48 <roconnor> > :[]
10:12:50 <lambdabot>   <no location info>: parse error on input `:'
10:12:51 <rwbarton> CakeProphet: Anyways, the name of the extension is StandaloneDeriving, you should be able to find docs online if I have the syntax wrong (as is likely)
10:12:55 <coco> dmwit: thanks, that helped :)
10:12:59 <EvilTerran> dmwit, the impression i had is that a descendent language to haskell will probably come along, with some haskell'-ey ideas taken into account, but it won't be intended to supersede haskell
10:13:02 <coco> still I don't really understand...
10:13:13 <roconnor> > (:[])
10:13:14 <lambdabot>       Overlapping instances for Show (a -> [a])
10:13:14 <lambdabot>        arising from a use of ...
10:13:21 <rwbarton> Oh, that was all supposed to be coco:, sorry
10:13:23 <CakeProphet> :[] is a fun face
10:13:43 <roconnor> @pl (:[])
10:13:44 <lambdabot> return
10:13:51 <lilac> EvilTerran: \x -> (: x :)
10:13:54 <coco> rwbarton: thanks, I'll check out the extension
10:14:06 <lilac> yay for smiley list construction
10:14:30 <dmwit> That's a weird operator.
10:14:41 <EvilTerran> that's (\a b -> a : x : b)...
10:14:48 <dmwit> > (\x y z -> y : x : z) 'e' 'w' "ird"
10:14:49 <lambdabot>   "weird"
10:14:58 <geezusfreeek> woah woah woah what?
10:15:01 <dmwit> Proof!
10:15:11 <CakeProphet> what's the rules for mixing symbols and letters in a function name?
10:15:21 <dmwit> CakeProphet: The rule is, don't.
10:15:26 <CakeProphet> can you have, for example, :R?
10:15:34 <dmwit> CakeProphet: a-z, 1-9, _ are letters
10:15:38 <EvilTerran> dmwit, and '
10:15:40 <dmwit> and '
10:15:40 <rwbarton> and 0 :)
10:15:52 * dmwit decides to just link to the Report
10:15:54 <dmwit> ?where h98
10:15:55 <lambdabot> http://haskell.org/onlinereport/
10:16:11 <rwbarton> :R is two tokens, : followed by R
10:16:46 <CakeProphet> alright.
10:17:24 <lilac> what if - were considered a letter?
10:17:29 <bohdan> @unpl \a b -> (x a) == (x b)
10:17:29 <lambdabot> \ a b -> (x a) == (x b)
10:17:34 <bohdan> @pl \a b -> (x a) == (x b)
10:17:34 <lambdabot> (. x) . (==) . x
10:17:56 <rwbarton> then-we-would-be-using-lisp
10:18:03 <CakeProphet> lilac: then Haskell is secretly Lisp.
10:18:09 <CakeProphet> ...
10:18:13 <CakeProphet> rwbarton beat me
10:18:20 <EvilTerran> that'would'be'most'unfortunate
10:18:30 <Saizan_> yeah, add more corner cases to unary minus!
10:18:33 <idnar> bohdan: (==) `on` x
10:19:08 <lilac> > ((+) `on` f) x y :: Expr -- bohdan
10:19:10 <lambdabot>   f x + f y
10:19:34 <idnar> > ((==) `on` f) x y :: Expr
10:19:36 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Bool'
10:19:49 <idnar> aww
10:20:58 <lilac> instance Show r => Show (Expr -> r) where show f = "\a -> " ++ show (f a)
10:21:10 <lilac> > (+) `on` f
10:21:11 <lambdabot>       Overlapping instances for Show (a -> a -> b)
10:21:11 <lambdabot>        arising from a use ...
10:21:38 * CakeProphet kind of feels like trolling a language channel
10:22:04 <CakeProphet> like... maybe going into a lisp channel and questioning everything sacred.
10:22:24 <lilac> CakeProphet: i suggest you try "S-expressions are ugly" :)
10:22:50 <baaba> or just
10:22:52 <CakeProphet> nah, that doesn't get people frustrated.
10:22:54 <vixey> Why don't you read an interesting book instead
10:23:00 <baaba> "hey guys, ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
10:23:03 <bohdan> so I'm trying to write ` instance (Ord a) => Org (Foo a) where compare = compare `on` weight ' -- but it complains that it can not deduce ` Eq (Foo a) ' -- why?
10:23:04 <CakeProphet> you have to ask legit sounding questions.
10:23:12 <bohdan> s/Org/Ord
10:23:19 <CakeProphet> and keep suggesting alternatives...
10:23:21 <CakeProphet> like
10:23:29 <rwbarton> @src Ord
10:23:29 <lambdabot> class  (Eq a) => Ord a  where
10:23:29 <lambdabot>     compare      :: a -> a -> Ordering
10:23:29 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
10:23:29 <lambdabot>     max, min         :: a -> a -> a
10:23:46 <rwbarton> bohdan: you must write an Eq (Foo a) instance first
10:23:53 <CakeProphet> "x feature of lisp is useless -- in Visual Basic, for example, you can do y which is much simpler and more efficient.... so I guess my question is, why use x instead of y?"
10:23:58 <Saizan> or later :)
10:24:10 <bohdan> strage -- why?
10:24:12 <rwbarton> Yes, first in the logical sense, not in the layout of your program :)
10:24:35 <Saizan> bohdan: because Eq is a superclass of Ord
10:24:50 <quicksilver> bohdan: because it's the law!
10:24:53 <baaba> bohdan, any code that uses Ord a can assume Eq a
10:25:04 <baaba> so it compiled you'd be left with the equivalent of pure virtual function calls :)
10:25:15 <baaba> s/it/if it/
10:25:22 <gour> is anyone doing some database work in haskell?
10:25:34 <bohdan> I just want to define one function -- compare
10:25:42 <bohdan> why am I force to also define (==) ?
10:26:03 <quicksilver> bohdan: because that is how Ord is declared.
10:26:11 <quicksilver> Ord is declared to require Eq
10:26:21 <quicksilver> and if a == b then compare a b should be EQ
10:26:24 <quicksilver> that's one of the laws.
10:26:50 <baaba> > let x .==. y = (x `compare` y) == EQ in 5 .==. 5
10:26:51 <lambdabot>   True
10:27:08 <bohdan> so what you're saying is that there's no way to define a /signle/ function to compare things, you always have to define (==) and something else
10:27:19 <quicksilver> bohdan: yes.
10:27:21 <geezusfreeek> you don't have to use Ord if you don't want
10:27:42 <quicksilver> you can do instance Eq (Foo a) where f == g = error "Go away I don't want to implement Eq" if you like.
10:27:43 <baaba> you could define your own class Ord2 a where compare :: a -> a -> Ordering
10:27:44 <baaba> :P
10:27:52 <baaba> but that wouldn't be terribly useful
10:27:52 <bohdan> geezusfreeek, I need it for e.g. sort
10:28:01 <bohdan> I could use sortBy of course :)
10:28:08 <coco> why can't there be several type class instances for the same type?
10:28:19 <baaba> why not just implement Eq?
10:28:21 <quicksilver> but a sort algorithm, in principle, is free to use the (==) method.
10:28:23 <baaba> @src Eq
10:28:23 <lambdabot> class  Eq a  where
10:28:23 <lambdabot>     (==), (/=)   :: a -> a -> Bool
10:28:27 <quicksilver> coco: because, that's what they are.
10:28:29 <geezusfreeek> coco, how would the compiler infer the correct type class when you use it?
10:28:32 <baaba> @src /=
10:28:32 <lambdabot> x /= y = not (x == y)
10:28:34 <coco> gee
10:28:36 <vixey> :t (\f x -> f (f x))(\f x -> f (f x))(\x y -> x)
10:28:36 <quicksilver> coco: type classes are the assignment of a bunch of methods to a type.
10:28:37 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
10:28:37 <lambdabot>     Probable cause: `x' is applied to too few arguments
10:28:37 <lambdabot>     In the expression: x
10:28:38 <coco> (sorry)
10:28:38 <baaba> it's not hard :P
10:28:42 <bohdan> quicksilver, compare provides enough information to implement eq, doesn't it?
10:28:44 <idnar> uhm, you could also do something like
10:28:44 <vixey> :t (\f x -> f (f x))
10:28:46 <lambdabot> forall t. (t -> t) -> t -> t
10:28:52 <quicksilver> coco: being unique is part of the definition of them.
10:28:56 <idnar> compareFoo :: Foo -> Foo -> Ordering
10:28:59 <quicksilver> coco: (you could imagine something else, of course)
10:29:01 <vixey> :t (\f x -> f (f x))(\f x -> f (f x))(\x y -> x)
10:29:03 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
10:29:03 <lambdabot>     Probable cause: `x' is applied to too few arguments
10:29:03 <lambdabot>     In the expression: x
10:29:03 <vixey> :t (\f x -> f (f x))(\f x -> f (f x))
10:29:05 <lambdabot> forall t. (t -> t) -> t -> t
10:29:10 <geezusfreeek> coco, you can use newtype to make a new type from the existing time if you want multiple instances for the same type of data
10:29:16 <geezusfreeek> *existing type
10:29:20 <quicksilver> bohdan: yes, you could say instance Eq (Foo a) where x == y = compare x y == EQ
10:29:25 <coco> geezusfreeek: one type class at a time would be open and thus have priority
10:29:32 <idnar> er, quicksilver beat me to it :P
10:29:43 <RayNbow> > (\n -> replicate n 0 ++ [1])   10
10:29:43 <quicksilver> coco: it's required to get sane semantics for things like Data.Map and Data.Binary
10:29:44 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,1]
10:29:48 <RayNbow> > (\n -> iterate (0:) [1] !! n)  10
10:29:49 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,1]
10:29:57 <quicksilver> coco: the uniqueness assumption runs pretty deep
10:30:02 <coco> quicksilver: they would be unique for any given place in the code
10:30:15 <geezusfreeek> coco, what do you mean "one type class at a time"?
10:30:19 <quicksilver> coco: yes, but that part in the code could communicate a Data.Map over to another part of the code
10:30:24 <quicksilver> coco: which has a different Ord instance in scope
10:30:32 <geezusfreeek> oh, scoping
10:30:33 <rwbarton> geezusfreeek: probably "one instance at a time", i.e., local instances
10:30:33 <quicksilver> coco: and then *bang* your computer explodes.
10:30:57 <quicksilver> or, with Data.Binary, a ByteString.
10:30:58 <quicksilver> etc.
10:31:03 <Saizan> coco: you're asking for something more like ML functors, which aren't type-directed
10:31:03 <coco> similar to modules in ML, where you say "open" and then one particular module becomes active
10:31:12 <Saizan> heh
10:31:18 <coco> :)
10:31:25 <quicksilver> if you want non-type-directed classes, just use data.
10:31:25 <geezusfreeek> coco, ML style modules would be nice, but we don't have them
10:31:30 <quicksilver> you don't need any fancy features for that.
10:31:37 <coco> I want to switch back and forth between arithmetic modulo 2 and modulo 3
10:31:44 <quicksilver> data Ord a = OrdData {compare :: a -> a -> Ordering}
10:31:48 <coco> writing "+" everytime
10:31:52 <Saizan> coco: use a phantom parameter
10:31:59 <Saizan> or just different types
10:32:08 <quicksilver> coco: proably newtypes are a good answer for that use case.
10:32:16 <geezusfreeek> newtype is the way i would do it
10:32:23 <coco> interesting
10:32:51 <coco> I would have to wrap all arguments with a constructor, though
10:32:51 <geezusfreeek> i also use newtype to make type class instances local (by not exporting the newtype)
10:33:06 <CakeProphet> I , personally, like to fill my code with countless useless newtype definitions, and then use their un-newtyped form anyways
10:33:14 <CakeProphet> newtype IntList = [Int]
10:33:17 <geezusfreeek> you would have to do something to that effect anyway to specify which type class instances you want
10:33:27 <vixey> CakeProphet: That's not even valid code...
10:33:37 <coco> geezusfreeek: I like that idea of not exporting, the globalness can sometimes be bothering
10:33:52 <roconnor> anyone understand how zipper scars work?
10:33:52 <CakeProphet> vixey:  perfect. Now it's even more useless. It makes every other piece of code useless.
10:34:04 <rwbarton> coco: if you're doing arithmetic, you hardly ever have to write a constructor, because of fromInteger
10:34:08 <geezusfreeek> CakeProphet, i don't understand what you are saying
10:34:13 * Debolaz got his copy of real world haskell today. \o/
10:34:16 <CakeProphet> ...I was confusing newtype with type
10:34:17 <CakeProphet> basically.
10:34:20 <baaba> @src fromInteger
10:34:21 <lambdabot> Source not found. Are you on drugs?
10:34:27 <coco> rwbarton: right, the example was bad
10:34:37 <chessguy_work> @type fromIntegral
10:34:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:35:10 <Saizan> you can carry informations in the types, if that's what you miss
10:35:20 <geezusfreeek> CakeProphet, you either have to scatter newtype constructors around or scatter different, nonoverloaded functions around, so either way you have to have some noise to get what you want
10:35:33 <mattam> The ordering could be part of the type of the map, or it's implementation.
10:35:44 <geezusfreeek> but the newtype version at least keeps some of the benefits of overloading
10:35:49 <CakeProphet> geezusfreeek:  LOLWAT? was that directed at coco?
10:36:00 <geezusfreeek> CakeProphet, no, you. you were complaining about newtype
10:36:23 <CakeProphet> no. I actually haven't learned what newtype does. I was just thinking of type
10:36:27 <geezusfreeek> ah
10:36:32 <geezusfreeek> nevermind then
10:36:33 * CakeProphet gogles.
10:36:38 <CakeProphet> :3
10:38:21 <mohbana> hi, last hurdle; http://pastebin.com/d70d1aa0a
10:38:40 <mohbana> i can't seem to use CABALOPTS='--user -fhighlighting make' either
10:39:31 <vixey> how could something be reflexive AND antisymmetric?
10:40:07 <lilac> CakeProphet: 'newtype' is exactly the same as 'data' except in fairly esoteric ways
10:40:11 <Saizan> mohbana: you've to install those packages
10:40:26 <CakeProphet> lilac:  that's my favorite kind of distinction.
10:40:32 <mohbana> Saizan: i've got those installed, i'm certain of it
10:40:33 <lilac> CakeProphet: for one, a newtype has no top-level _|_, so pattern matching on the top-level always succeeds
10:40:41 <Saizan> mohbana: with "cabal install"?
10:40:55 <lilac> CakeProphet: another difference is that GHC supports 'newtype deriving' (with -XNewTypeDeriving)
10:40:55 <Saizan> mohbana: if so you've to add --user to CABALOPTS
10:40:57 <CakeProphet> lilac:  what
10:41:10 <CakeProphet> what is _|_
10:41:12 <mattam> vixey: partial orders?
10:41:24 <lilac> CakeProphet: _|_ is a value representing a failed computation
10:41:33 <lilac> CakeProphet: a 'value' rather
10:42:12 <geezusfreeek> lilac, i think the semantic distinctions between data and newtype are much more important than most seem to say, at least if you exploit laziness a lot
10:42:14 <mohbana> $ cabal install utf8-string ... f you want to reinstall anyway then use the --reinstall flag..  do you mean like;  CABALOPTS="--user -fhighlighting make"
10:42:18 <lilac> CakeProphet: instead of saying that, say, "sum [1..]" doesn't terminate, we say it has the value _|_
10:42:20 <mohbana> Saizan:
10:43:11 <CakeProphet> lilac:  can you test sum [1..] to see if equals that?
10:43:12 <Saizan> mohbana: CABALOPTS="--user -fhighlighting" make
10:43:19 <CakeProphet> lol halting problem
10:43:28 <geezusfreeek> > sum [1..]
10:43:34 <mohbana> Saizan: thanks again.  that's all
10:43:38 <lambdabot>   mueval: Prelude.read: no parse
10:43:39 <lilac> CakeProphet: no, most operations on _|_ yield _|_
10:43:58 <geezusfreeek> > undefined
10:44:00 <lilac> CakeProphet: we say that f is /strict/ if f _|_ == _|_
10:44:02 <lambdabot>   * Exception: Prelude.undefined
10:44:11 <opqdonut> actually, defineable functions must be monotonic
10:44:29 <CakeProphet> > _|_
10:44:30 <lilac> CakeProphet: not all functions in Haskell are strict (for instance, "const 42" is not strict)
10:44:31 <lambdabot>   <no location info>: parse error on input `|'
10:44:36 <Saizan> CakeProphet: _|_ is not something available at the language level, it's a value introduced when describing the semantics
10:44:37 <vixey> hmmm
10:44:37 <opqdonut> in the sense that if f _|_ > _|_ then f somethingelse must be > _|_
10:44:38 <chessguy_work> @remember RussellNorvig "...the ideas of logic are far more general and beautiful than is commonly supposed."
10:44:38 <lambdabot> Good to know.
10:44:39 <vixey> is it true
10:44:47 <geezusfreeek> > let f = (+1) in f undefined
10:44:49 <lambdabot>   * Exception: Prelude.undefined
10:44:58 <opqdonut> (and every value that is not _|_ is >_|_
10:44:59 <opqdonut> )
10:45:01 <geezusfreeek> > let f = (\x -> 1:[x]) in f undefined
10:45:03 <lambdabot>   [1,* Exception: Prelude.undefined
10:45:08 <CakeProphet> .......then why are we talking about it in relation ti data and newtype.
10:45:38 <lilac> CakeProphet: because newtype-versus-data affects the semantics
10:45:49 <vixey> data O = O O
10:45:50 <lilac> CakeProphet: so discussing the semantics is essential to explain the difference :)
10:45:51 <bohdan> @pl \(a,b,c) -> c
10:45:52 <lambdabot> (line 1, column 6):
10:45:52 <lambdabot> unexpected ","
10:45:52 <lambdabot> expecting letter or digit, operator or ")"
10:45:52 <lambdabot> ambiguous use of a non associative operator
10:45:53 <vixey> O :: O -> O
10:46:12 <CakeProphet> lilac:  except you lost me with the _|_ stuff... so I have a feeling it would be easier to simply explain the difference.
10:46:17 <geezusfreeek> CakeProphet, newtype Foo a = Foo a; Foo _|_ = _|_
10:46:30 <bohdan> eh?
10:46:51 <geezusfreeek> CakeProphet, data Foo a = Foo a; Foo _|_ thunks the _|_ instead
10:46:53 <lilac> CakeProphet: suppose you have "newtype Foo a = Foo a". now, "case undefined of Foo _ -> True" returns True
10:47:10 <lilac> CakeProphet: suppose you have "data Foo a = Foo a". now, "case undefined of Foo _ -> True" produces an error
10:47:31 <Saizan> where undefined = error "undefined"
10:47:34 <CakeProphet> how do you get a "case undefined of Foo" in actual code?
10:47:49 <rwbarton> > case undefined of Just _ -> True
10:47:50 <lambdabot>   * Exception: Prelude.undefined
10:48:09 <mmorrow> fromJust = maybe undefined id
10:48:10 <sbahra> > let x = undefined in case x of Just _ -> True
10:48:11 <lambdabot>   * Exception: Prelude.undefined
10:48:11 <lilac> CakeProphet: 'undefined' is in some sense equivalent to a function which never returns
10:48:36 <CakeProphet> rwbarton:  was that actual Haskell?
10:48:43 <rwbarton> CakeProphet: Of course!
10:48:47 <lilac> CakeProphet: do you understand how laziness works semantically in haskell?
10:48:49 <rwbarton> CakeProphet: How could lambdabot evaluate it otherwise??
10:49:18 <CakeProphet> ...oh
10:49:30 <CakeProphet> -facepalm- that's a case expression, it read too much like English
10:49:32 <CakeProphet> so I was confused.
10:49:35 <bohdan> @pl \(a,b) -> (a, c:b)
10:49:35 <lambdabot> second (c :)
10:49:39 <geezusfreeek> > [1..] ++ undefined
10:49:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:49:45 <lilac> CakeProphet: in "case x of Foo _ -> True" with Foo a newtype, x is not forced (that is, not evaluated)
10:49:49 <geezusfreeek> ^ notice how that has no problem
10:49:55 <chessguy_work> errmmm, it's not valid to say "class Foo a b where bar :: a -> b -> Bool", is it?
10:50:09 <coco> is there a way to automatically derive Show, Eq etc. *after* a type has been defined?
10:50:10 <rwbarton> chessguy_work: Perfectly valid
10:50:11 <lilac> chessguy_work: sure, with -XMultiParameterTypeClasses
10:50:16 <mmorrow> rwbarton: hey, where did you get your info about how to properly construct an ELF .o for your bf2o compiler?
10:50:22 <rwbarton> coco: Yes, StandaloneDeriving :)
10:50:36 <sbahra> mmorrow, ELF standard
10:50:38 <rwbarton> mmorrow: I found some document on the web, I think it was from Sun
10:50:42 <sbahra> HP
10:50:48 <coco> rwbarton: thanks
10:50:51 <mmorrow> sbahra: grr, i was afraid of that ;)
10:50:59 <mmorrow> rwbarton: cool
10:51:20 <Gilly> any suggestions where to read about this "structural calculation with types" as done in http://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types ?
10:51:32 <CakeProphet> lilac:  it's not evaluated because the pattern always matches?
10:51:57 <mmorrow> sbahra, rwbarton: this is what i've been using http://www.cs.york.ac.uk/fp/darcs/ELF/ELF_Format.pdf
10:51:58 <lilac> CakeProphet: that's essentially right. because it's a newtype, the compiler assumes the pattern will always match.
10:51:59 <EvilTerran> CakeProphet, yup
10:52:09 <CakeProphet> ah okay....
10:52:13 <CakeProphet> what a strange distinction.
10:52:26 <sbahra> mmorrow, nod, it's what I used.
10:52:27 <opqdonut> Gilly: i've tried to find some material on that too but it's really scarce
10:52:29 <rwbarton> CakeProphet: Basically the data constructor Foo in newtype Foo a = Foo a is just a type-level thing that keeps the types a and Foo a separate.
10:52:38 <opqdonut> Gilly: esp. wrt. type logarithms
10:52:54 <rwbarton> CakeProphet: It doesn't have any run-time representation at all (not guaranteed by the language spec, but true in GHC)
10:52:56 <EvilTerran> type... logarithms? O.o
10:53:18 <lilac> CakeProphet: when one writes "data Foo = Foo", the compiler interprets that as "data Foo = Foo | DidNotTerminate" where DidNotTerminate is secretly returned by non-terminating functions
10:53:23 <rwbarton> CakeProphet: Whereas the data constructor Foo in data Foo a = Foo a is, well, real data
10:53:48 <lilac> CakeProphet: of course, that's not what really happens, since the compiler can't tell, but the point is that non-termination is treated as a separate 'value'
10:53:50 <rwbarton> (I don't know whether that explanation makes things more or less clear, but it's how I think about it)
10:53:53 <Gilly> opqdonut: ah, i see
10:54:06 <CakeProphet> lilac: not really though. it's just laziness.
10:54:23 <lilac> rwbarton: i've always found that unsatisfying, since a compiler could choose to represent 'newtype' and 'data' the same
10:54:40 <mmorrow> rwbarton: that bf2o compiler is pretty cool, you should make a darcs repo :)
10:54:44 <lilac> rwbarton: and indeed in the cases where it can use a smaller 'data' representation, i'd hope it would :)
10:55:09 <CakeProphet> is there anything in the standard library that's a newtype?
10:55:13 <coco> rwbarton: I'm using StandaloneDeriving and DeriveDataTypeable, but "deriving instance Data Random.StdGen" doesn't work
10:55:22 <coco> The data constructors of `Random.StdGen' are not all in scope
10:55:22 <coco>       so you cannot derive an instance for it
10:55:22 <coco>     In the stand-alone deriving instance for `Data Random.StdGen'
10:55:28 <rwbarton> coco: Ah
10:55:28 <mmorrow> rwbarton: (or if you don't want any part of it, i'd be happy to do so)
10:55:33 <lilac> @hoogle Reader
10:55:34 <lambdabot> module Control.Monad.Reader
10:55:34 <lambdabot> Control.Monad.Reader newtype Reader r a
10:55:34 <lambdabot> Control.Monad.Reader Reader :: r -> a -> Reader r a
10:55:37 <lilac> CakeProphet: ^^
10:56:06 <mattam> Gilly: look for McBride's paper at POPL.
10:56:12 <lilac> "newtype Reader r a = Reader { runReader :: r -> a }" IIRC
10:56:22 <rwbarton> , src ''Reader
10:56:28 <lunabot>  newtype Reader r a = Reader {runReader :: (r -> a)}
10:56:32 <CakeProphet> never used it... but I'm guessing you can use Reader _ to signify the condition where Reader never yields a result (like a better select() )
10:56:37 <mattam> "Clowns to the left, Jokers to the right" :)
10:56:39 <lilac> \o/ :)
10:58:09 <Gilly> mattam: thanks
10:58:19 <rwbarton> > show (mkStdGen 0)
10:58:20 <lambdabot>   "1 1"
10:58:27 <opqdonut> gah, the links from http://personal.cis.strath.ac.uk/~conor/ are dead
10:58:29 <rwbarton> > show (mkStdGen 1)
10:58:30 <lambdabot>   "2 1"
10:58:45 <mmorrow> > show (mkStdGen 2)
10:58:47 <lambdabot>   "3 1"
10:58:49 <mmorrow> hah
10:58:55 <opqdonut> ah, must be because his site is http://www.cs.nott.ac.uk/~ctm/ nowadays
10:59:04 <lilac> CakeProphet: suppose you write a function which runs another program and returns () if it terminates, and doesn't terminate if not. would you expect Haskell to be clever and say "The only value of () is () so i'm not even running your function at all" ?
10:59:12 <opqdonut> no, strictlypositive.org
10:59:17 <opqdonut> heh :)
10:59:27 <mattam> Gilly: it goes further into dissection but shows how derivation is a particular case.
10:59:34 <mattam> http://www.cs.nott.ac.uk/~ctm/CJ.pdf
10:59:42 <BrokenClockwork> http://hpaste.org/13531 -> the interpreter yells at me: Couldn't match expected type '(Int,Int)' against inferred type 'Int) in the line of where, but I don't get it, it's like he doesn't acknowledge the where...
10:59:43 <mmorrow> i don't know why, but for some reason i thought that mkStdGen did something slightly more interesting that that
10:59:47 <CakeProphet> lilac:  no... because then my program doesn't get run.
10:59:52 <CakeProphet> ...
10:59:57 <mmorrow> i guess there's no point really though
11:00:05 <rwbarton> coco: I think you're somewhat out of luck because the designer of the System.Random module decided not to export the implementation of StdGen.
11:00:16 <lilac> CakeProphet: ok. but mathematically, if the only value your function can return is (), then there's no point running it.
11:00:22 <Gilly> mattam: great! thanks, i'll go through it :)
11:00:25 <CakeProphet> yes.
11:00:48 <lilac> CakeProphet: so _|_ is a 'trick' to say "there's this other value which will never actually be returned, but you have to pretend it might be"
11:00:59 <lilac> CakeProphet: and 'data' adds a _|_ to the type it creates
11:01:06 <lilac> CakeProphet: whereas 'newtype' does not
11:01:23 <rwbarton> coco: On the other hand you can at least get the data out of the Show instance, so if you really wanted to you could write a Data instance that parses the output of that...
11:02:24 <lilac> CakeProphet: so your program now returns either () or _|_, and so you've got to run it to find out which
11:06:43 <coco> rwbarton: thanks again. not sure how to write Data instances (it looks comlicated). I'll just settle for manual use of show and read
11:07:04 <BrokenClockwork> map (*) [2,3,5]
11:07:08 <vixey> what's a pre-fixed point as opposed to a normal fixed point?
11:07:09 <BrokenClockwork> why doesn't this work?
11:07:18 <vixey> BrokenClockwork, "doesn't work"?
11:07:20 <koeien> BrokenClockwork: what are you trying to accomplish?
11:07:26 <BrokenClockwork> 2*3*5
11:07:32 <vixey> > map ($ 3) (map (*) [2,3,5])
11:07:34 <lambdabot>   [6,9,15]
11:07:39 <koeien> ok, you are "mapping" a function over a list here
11:07:40 <Cale> coco: You derive them usually.
11:07:42 <vixey> > foldl1 (*) [2,3,5]
11:07:42 <koeien> example:
11:07:44 <lambdabot>   30
11:07:47 <koeien> > map (+1) [2,3,5]
11:07:48 <Cale> coco: deriving (Data,Typeable)
11:07:48 <lambdabot>   [3,4,6]
11:07:52 <idnar> > foldl (*) 1 [2,3,5]
11:07:54 <lambdabot>   30
11:07:55 <BrokenClockwork> ah I was looking for fold :)
11:07:59 <koeien> right! :)
11:08:07 <koeien> > product [2,3,5]
11:08:08 <lambdabot>   30
11:08:13 <koeien> but that's cheating
11:08:18 <BrokenClockwork> heh :D
11:08:24 <rwbarton> Cale: It (System.StdGen) is in a module and the constructors aren't exported
11:08:27 <koeien> @src product
11:08:27 <lambdabot> product = foldl (*) 1
11:08:28 <CHJA> Can anyone suggest a good editor/IDE for Haskell (other than emacs/vim)?
11:08:33 <rwbarton> Cale: er System.Random.StdGen
11:08:35 <Cale> rwbarton: Ah, I missed that part :)
11:08:37 <coco> Cale: thanks, but I want it for Random.StdGen, which is non-exported
11:09:00 <vixey> "Least pre-fixed points are fixed points" :/
11:09:02 <coco> (sorry, I was slow)
11:09:36 <sclv> "A complete meal of several courses, sometimes with choices permitted, offered by a restaurant at a fixed price"
11:09:38 <athos> @src liftM2
11:09:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:09:43 <sclv> oh, wait. that's a prix fix
11:09:50 <athos> ah
11:10:56 <aluink> i'm not quite sure how to ask this question, so bear with me on my wording ;)
11:11:06 <aluink> is there a way i can check for a tautology of a function
11:11:21 <aluink> for instance... (isEmpty . makeEmpty) x == True
11:11:33 <vixey> aluink, nothing internal
11:11:35 <opqdonut> well, no
11:11:45 <opqdonut> you can prove it :)
11:11:56 <EvilTerran> you can check by exhaustion if the function has a finite domain
11:12:05 <aluink> sure, i can prove it, but sometimes it's not that easy with some functions ;)
11:12:06 <opqdonut> and in some cases the compiler can infer it
11:12:09 <opqdonut> for example newtypes
11:12:29 <koeien> aluink: halting problem, methinks
11:12:34 <EvilTerran> aluink, not easy for you, or for the compiler
11:12:35 <Raevel> aluink: also check out quickcheck
11:12:40 <aluink> i have two functions, makePalindrome, and checkPalindrome
11:12:53 <opqdonut> aluink: ah, use quickcheck
11:12:55 <cizra> aluink: Solving the RWH exercises?
11:13:10 <aluink> cizra: yes, but i'm revisiting
11:13:30 <aluink> koeien: yes, i hated that thing
11:13:48 <opqdonut> no it's not the halting problem
11:13:57 <koeien> not completely.
11:13:58 <opqdonut> it's the equality problem
11:14:00 <opqdonut> which is stronger
11:14:04 <koeien> but it's a subset
11:14:14 <koeien> right, stronger it is ;)
11:14:27 <Cale> @check let makePalindrome xs = xs ++ reverse xs; checkPalindrome xs = xs == reverse xs in \xs -> checkPalindrome . makePalindrome $ (xs :: String)
11:14:28 <lambdabot>   "OK, passed 500 tests."
11:14:50 <pumpkin> could it be rice's theorem too?
11:15:04 <vixey> @check \x y -> x == y
11:15:06 <lambdabot>   "OK, passed 500 tests."
11:15:13 <roconnor> check let makePalindrome xs = ""; checkPalindrome xs = xs == reverse xs in \xs -> checkPalindrome . makePalindrome $ (xs :: String)
11:15:14 <koeien> vixey: you have to be careful here :)
11:15:17 <Cale> @check \x y -> x == (y :: String)
11:15:18 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\503909\"\n\"\\443948\\282563\"\n"
11:15:22 <vixey> @check \x y -> x*y == 13*7
11:15:23 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n-3\n"
11:15:24 <Cale> heh
11:15:26 <roconnor> @check let makePalindrome xs = ""; checkPalindrome xs = xs == reverse xs in \xs -> checkPalindrome . makePalindrome $ (xs :: String)
11:15:28 <rwbarton> That was going to be my example too!
11:15:29 <lambdabot>   "OK, passed 500 tests."
11:15:29 <vixey> @check \x y -> x*y /= 13*7
11:15:30 <lambdabot>   "OK, passed 500 tests."
11:15:35 <vixey> ^ testing!
11:15:55 * vixey wonders if people write programs more complex than (*)
11:16:07 <roconnor> @check \x y -> x**y /= 13**7
11:16:09 <lambdabot>   "OK, passed 500 tests."
11:16:13 <opqdonut> vixey: :D
11:16:41 <Cale> vixey: Looked at the right way, that's a pretty deep question :)
11:17:38 <Cale> Hundreds of years of study, and how well do we *really* understand multiplication?
11:17:42 <opqdonut> yeah
11:17:53 <opqdonut> multiplication gives very rich structure to the naturals
11:18:15 <bohdan> @pl [ (a,b) | a <- a', b<-b']
11:18:16 <lambdabot> [(a, b) | a <- a', b <- b']
11:18:32 <bohdan> is there a function like zip but for the crossproduct?
11:18:51 <bohdan> @pl \a' b' -> [ (a,b) | a <- a', b<-b']
11:18:51 <lambdabot> (. (return . (b <-))) . (:) . (((a, b) | a) <-)
11:18:52 <vixey> > liftA2 (,) "wooble" "quux"
11:18:53 <lambdabot>   [('w','q'),('w','u'),('w','u'),('w','x'),('o','q'),('o','u'),('o','u'),('o'...
11:18:53 <koeien> you just wrote one
11:18:56 <koeien> also: double map
11:18:58 <opqdonut> > liftM2 (,) [1,2,3] [4,5,6]
11:19:00 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:19:11 <opqdonut> ah, vixey beat me to it
11:19:14 <koeien> list monad :)
11:19:17 <opqdonut> yes
11:19:20 <mmorrow> haha @pl fail
11:19:29 <koeien> pretty epic yes
11:19:32 <athos> :t liftA2
11:19:34 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:19:36 <mmorrow> , [$pl| \a' b' -> [ (a,b) | a <- a', b<-b'] |]
11:19:38 <athos> ah.
11:19:42 <rwbarton> @unpl (. (return . (b <-))) . (:) . (((a, b) | a) <-)
11:19:42 <lambdabot>  Parse error at "<-)))" (column 17)
11:19:42 <lunabot>  Killed.
11:19:50 <mmorrow>  @pl is way slow
11:19:52 <mmorrow> , [$pl| \a' b' -> [ (a,b) | a <- a', b<-b'] |]
11:19:58 <lunabot>  Killed.
11:20:02 <athos> is every monad an Applicative?
11:20:09 <koeien> no and yes
11:20:15 <mmorrow> lunabot's cputime rlimit is already at 7 seconds :/
11:20:23 <opqdonut> athos: yes
11:20:37 <athos> ok
11:20:39 <koeien> in practice, no, but you can make an instance
11:21:04 <mmorrow> , [$pl| \a b c -> g (f a b c) |]
11:21:09 <lunabot>  ((g .) .) . f
11:21:36 <sbahra> djoseph, hi
11:21:43 <sbahra> > map (+ 1) [1 .. 10]
11:21:44 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
11:21:55 <sbahra> djinni, etc...@list. You can PM him too.
11:23:25 <athos> @help djinn
11:23:26 <lambdabot> djinn <type>.
11:23:26 <lambdabot> Generates Haskell code from a type.
11:23:26 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
11:23:27 <athos> :[]
11:24:16 <sbahra> djoseph, that was directed to you. (@list, PM).
11:24:17 <pumpkin> mmorrow is back!
11:24:27 <mmorrow> pumpkin: hola!!
11:24:28 <vixey> , [$djinn| a -> b -> a |] 3 4
11:24:29 <djoseph> sbahra: Thanks
11:24:31 <lunabot>  luna: Not in scope: `djinn'
11:24:35 <pumpkin> :)
11:24:38 <mmorrow> vixey: good point
11:24:48 * vixey just cheking..
11:24:59 <sbahra> djoseph, some other features
11:25:01 <sbahra> @src map
11:25:01 <lambdabot> map _ []     = []
11:25:02 <lambdabot> map f (x:xs) = f x : map f xs
11:25:09 <sbahra> djoseph, or, hoogle
11:25:16 <sbahra> @hoogle [a] -> a -> Int
11:25:16 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
11:25:16 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
11:25:16 <lambdabot> Prelude (!!) :: [a] -> Int -> a
11:25:30 <rwbarton> Doesn't Oleg have a djinn implemented in the type system?
11:25:42 <bohdan> anyone wants a small coding challenge? :)
11:25:48 <pumpkin> bohdan: never!
11:25:59 <mmorrow> hmm, i think at this point there really needs to be a QuasiQuoter that implements the ability to splice the result of quasiquoters into other quasiquoters
11:26:23 <mmorrow> it's be ugly though since you have to escape "|]" as "\|]" inside other QQs
11:26:43 <athos> bohdan: post some cool challenge! now! go!
11:26:44 <athos> :_
11:27:34 <mmorrow> [$qq| [$pl| $([$djinn| a -> b -> a \|]) \|] |]
11:27:36 <mmorrow> ugh
11:27:41 <kaol> how does quasiquoting compare to TH? I haven't looked at the former yet but it looks kind of similar... what's the diff?
11:27:49 <rwbarton> mmorrow: you should add this stuff to lunabot: http://www.haskell.org/pipermail/haskell/2005-March/015423.html
11:27:53 <pumpkin> mmorrow: can't more complex expressions go between the $ |?
11:27:58 <vixey> koal, QQ is part of TH really
11:28:14 <mmorrow> kaol: quasiquotes are diff in that you defined a
11:28:17 <Saizan> kaol: it allows you to use custom syntax
11:28:21 <mmorrow> , src ''QuasiQuoter
11:28:26 <lunabot>  data QuasiQuoter = QuasiQuoter {quoteExp :: (String -> Q Exp),
11:28:26 <lunabot>                                  quotePat :: (String -> Q Pat)}
11:28:41 <mmorrow> and you give it a custom parser for expression context and pattern context
11:28:54 <vixey> [$lambdabot| @@ @pl (@djinn a -> a) |]
11:29:02 <athos> ,
11:29:03 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
11:29:04 <mmorrow> so it will transform arbitrary syntax in each context to a haskell expression and pattern respectively
11:29:10 <athos> , src foldl
11:29:12 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
11:29:15 <mmorrow> , src 'foldl
11:29:16 <vixey> @@ @pl (@djinn a -> a)
11:29:17 <lambdabot>  f = id
11:29:17 <bohdan> so given 'data Tree a = Empty | Branch a (Tree a) (Tree a)' write a function that takes (Tree Char) and prints the tree in ascii form top-down
11:29:21 <lunabot>  foldl :: forall a b . (a -> b -> a) -> a -> ([b]) -> a
11:29:23 <athos> :_
11:29:29 <mmorrow> athos: `src' really should be called `info'
11:29:34 <athos> ah!
11:29:37 <vixey> bohdan: I wonder what top down means
11:29:41 <mmorrow> rwbarton: sweet, /me looks
11:29:48 <pumpkin> bohdan: stick it into a Data.Map and use its printer :P
11:30:04 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
11:30:05 <athos> , src ''Exp
11:30:06 <bohdan> top-down means root is at the top :)
11:30:09 <athos> hehe
11:30:11 <lunabot>  Killed.
11:30:13 <mmorrow> aww
11:30:16 <lunabot>  data Exp = VarE Name
11:30:16 <lunabot>           | ConE Name
11:30:16 <lunabot>           | LitE Lit
11:30:21 <vixey> bohdan: still dunno what you'd be printing
11:30:26 <mmorrow> athos: do that in a /msg to see the whole thing
11:30:34 <athos> mmorrow: ok, thx
11:30:38 <mmorrow> :)
11:31:01 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
11:31:22 <lunabot>  forall a . (a -> a) -> a
11:31:30 <pumpkin> mmorrow: you didn't write up the sqlmagic quasiquoter proposal! :(
11:31:37 <athos> mmorrow: hehe, now i know why /msg is better for , src ''Exp :D
11:31:39 <mmorrow> pumpkin: heh, not yet.
11:31:51 <mmorrow> athos: hehe
11:32:12 <bohdan> vixey, http://hpaste.org/13534
11:32:24 <Mathematicz> I think i'm gunna go c++ as it's best way for gaming programmer (compared to haskell), even though haskell seems "better"
11:32:26 <juturnas> why does foldl take one element of the list separate?
11:32:38 <vixey> bohdan, oh right
11:32:42 <opqdonut> juturnas: to ensure nonemptyness
11:32:43 <juturnas> as in foldl (+) 1 [2,3,4]
11:32:51 <juturnas> ah ok
11:32:57 <juturnas> thanks
11:32:59 <pumpkin> juturnas: there is foldl1 if you want it
11:33:01 <opqdonut> foldl1 takes only the list
11:33:04 <opqdonut> and errors on an empty list
11:33:06 <Myrth> @src foldl
11:33:07 <lambdabot> foldl f z []     = z
11:33:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:33:10 <opqdonut> but if you know the list is nonempty
11:33:38 <juturnas> Ok that helps a lot, thanks everyone
11:33:46 <Myrth> @src foldl1
11:33:47 <lambdabot> foldl1 f (x:xs) = foldl f x xs
11:33:47 <lambdabot> foldl1 _ []     = undefined
11:34:39 <bohdan> athos, vixey, I would also call for using only lists
11:34:55 <vixey> bohdan, that's sort of silly
11:35:06 <bohdan> vixey, why?
11:35:20 <vixey> bohdan, you'll get a better program if you generalize away from the problem a bit
11:35:36 <vixey> (and use a couple of structures that aren't lists)
11:35:37 <opqdonut> the solution is just tying the knot
11:35:50 <opqdonut> like the famous list average problem, right?
11:36:01 <bohdan> vixey, what I means is not to use other builtin data structures
11:36:04 <opqdonut> oh okay, that's just one solution
11:36:30 <vixey> bohdan,  huh?  pretty much any data in the std library you can define for yourself
11:36:31 <jeltsch> Hello, I just tried this: http://hpaste.org/13535
11:36:33 <opqdonut> multipass allows for all sorts of simple versions
11:36:40 <jeltsch> This doesn’t work. Does anyone know why?
11:37:14 <opqdonut> err you can't derive monad for that?
11:37:19 <bohdan> vixey, ok nevermind
11:37:47 <jeltsch> What about generalized newtype deriving?
11:38:21 <opqdonut> jeltsch: i think the rank2 type botches that
11:38:23 <opqdonut> dunno tho
11:38:55 <jeltsch> opqdonut: Yes, I think it’s because of the forall. But why? Isn’t it sensible to derive a Monad instance for that?
11:38:57 <vixey> bohdan, btw, the d e f g nodes in your picture... but there is no 'a' in Leaf?
11:39:06 <vixey> bohdan, btw, the d e f g nodes in your picture... but there is no 'a' in Empty?***
11:39:17 <bohdan> vixey, yes they are nodes
11:39:24 <bohdan> vixey, empty is not shown
11:39:24 <opqdonut> jeltsch: well it might be sensible but the compiler can't do it as of now :)
11:39:53 <vixey> bohdan, so it shouldn't be: data Tree a = Empty _a_ | Branch a (Tree a) (Tree a)
11:39:58 <bohdan> so Branch is a misnomer, should be Node
11:40:07 <bohdan> no
11:40:12 <jeltsch> opqdonut: Hmm let’s see whether it’s sensible. I’ll try the deriving by hand. One moment.
11:40:26 <mmorrow> , src ''Tree
11:40:31 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
11:40:37 <mmorrow> , src ''Forest
11:40:42 <lunabot>  type Forest a = [Tree a]
11:44:59 <juturnas> So I don't fully understand laziness yet.  If i use a list comprehension to represent all fibonacci numbers, and then use filter to 'remove' all numbers > 4,000,000 and try to find the sum of all elements, will that work or hang?
11:45:08 <vixey> bohdan, type Matrix = (Columns, Rows, [Row]), type Columns = Rows = Integer, type Row = String -- (of length Columns)
11:45:32 <mmorrow> juturnas: that'll hang, but if instead you do     takeWhile (< 40000) , that'll work
11:45:50 <juturnas> Thanks
11:45:53 <mmorrow> np
11:46:22 <jeltsch> opqdonut: Yep, it works: http://hpaste.org/13535#a1
11:46:35 <jeltsch> opqdonut: Time for a feature request. :-)
11:48:33 <byorgey> jeltsch: the reason the first will hang is that the filter function has no way to 'know' when it is done.  *You* happen to know that the list of fibonacci numbers is sorted, so once you find a number bigger than 4 million you can stop, but the filter function keeps looking for things smaller than 4 million.
11:48:37 <vixey> bohdan, so if (1,1,["a"]),(1,1,["b"]),(1,1,["c"]) are Matrices then (5,3,["  c  ", " / \ ","a   b"]) is too (and I realize now I should have said Rows/Columns instead of Columns/Rows)
11:49:14 <byorgey> jeltsch: using 'takeWhile' essentially corresponds to using your extra knowledge about the list to stop as soon as something bigger than 4 million is found.
11:49:31 <jeltsch> byorgey: Hey, it’s not me you want to talk to. :-)
11:49:33 <mmorrow> byorgey: (@juturnas)
11:49:43 <byorgey> ah, whoops =)
11:50:12 <pumpkin> could a Data.Map be an instance of Arrow?
11:50:13 <byorgey> your nicks both start with 'j' and just so happened to be given the same color by whatever nick-hashing algorithm my irc client uses =)
11:50:13 <vixey> bohdan, so you can get something like, topDown = foldTree emptyMatrix joinMatrices
11:50:21 <ski_> (juturnas : as long as you represent the fibonacci numbers in the standard order ..)
11:50:28 <juturnas> Thanks byorgey
11:50:45 <bohdan> vixey, interesting
11:50:48 <juturnas> Now that you explain it seems kind of 'duh' :)
11:51:13 <byorgey> juturnas: good, that means I explained it well, but don't feel bad about not seeing it before =)
11:51:24 <vixey> bohdan, foldTree leaf branch Leaf = leaf ; foldTree leaf branch (Branch e l r) = branch e (foldTree leaf branch l) (foldTree leaf branch r)
11:51:25 <dons> @users
11:51:25 <lambdabot> Maximum users seen in #haskell: 597, currently: 594 (99.5%), active: 21 (3.5%)
11:51:28 <dons> mmm
11:51:33 <vixey> bohdan, just the primitive recursion for Tree
11:51:37 <byorgey> so close!
11:51:37 <pumpkin> or does a Data.Map have the same issues being an arrow as a monad
11:51:39 <juturnas> If i felt bad every time that happened I wouldn't be trying to learn haskell!
11:51:53 <byorgey> juturnas: hehe, good =)
11:52:28 <byorgey> pumpkin: if m1 and m2 are two Maps, what would m1 >>> m2 be?
11:53:19 <dmwit> I think it could work.
11:53:19 <pumpkin> well, a Map would just be a function with a finite domain
11:53:22 <Saizan> byorgey: you can think of a Map a b as a tabulated function, no?
11:53:22 <ski_> byorgey : their composition ?
11:53:29 <dmwit> If only there were no Ord constraint on keys. ;-)
11:53:30 <byorgey> I guess you match up values in m1 with matching keys in m2, and make a new map associating keys in m1 with values in m2 ?
11:53:38 <pumpkin> dmwit: yeah, that's what worried me
11:53:48 <pumpkin> byorgey: well, you'd just think of it as normal function composition
11:53:49 <ski_> arr id :: Map Integer Integer
11:53:50 <byorgey> yeah, ok, that makes sense
11:53:51 <Saizan> the Ord constraint is the problem yeah, same as Monad for Set
11:53:51 <pumpkin> assuming the Map types mathed
11:53:55 <pumpkin> matched
11:54:02 <dmwit> ski_: Map a a -- harder to satisfy...
11:54:12 <pumpkin> soemone needs to make a RArrow like RMonad :P
11:54:22 <pumpkin> and then I can play out my dumb ideas
11:54:23 <dmwit> ski_: But yeah, arr is hard to write.
11:54:43 <ski_> @index RMonad
11:54:43 <lambdabot> bzzt
11:55:13 <vixey> :t (\f x u v -> x u (\z -> v (f z))) :: forall a b. (a -> b) -> (() -> a)) -> forall y. (() -> y) -> (b ->y) -> ?x
11:55:15 <lambdabot> parse error on input `)'
11:56:12 <pumpkin> do arrows have special support in GHC? or could they be implemented as they are now, in 98?
11:56:34 <EvilTerran> GHC provides syntactic sugar
11:56:44 <byorgey> pumpkin: there is an extension in GHC to support special notation for arrows, but it's not needed to implement them
11:56:47 <pumpkin> is it just the (->) thing?
11:56:48 <pumpkin> ah
11:56:51 <EvilTerran> that's really quite substantial
11:57:05 <EvilTerran> (it hides all the pair-juggling we'd end up doing without it)
11:57:18 <opqdonut> hmm, pair juggling?
11:57:22 <byorgey> yeah, the notation allows you to name intermediate results.
11:57:38 <opqdonut> ah, yes, now i see
11:57:38 <vixey> if someone writes, in System F:  forall a b. (a -> b) -> t -> t[a := b)
11:57:43 <byorgey> otherwise you have to keep track of intermediate results by their position in some sort of nested tuple.
11:57:49 <opqdonut> yes
11:57:51 * byorgey shudders
11:57:53 <vixey> is this just like,   forall a b. (a -> b) -> t(a) -> t(b)  ?
11:58:08 <EvilTerran> vixey, i'd hope so
11:58:18 <cjay> when trying to configure plugins-1.3.1 on arch linux, I get: checking for C compiler default output file name... configure: error: C compiler cannot create executables
11:58:19 <EvilTerran> that's what that notation usually means
11:58:41 <Saizan> yeah, but 't' is not defined to take parameters
11:58:51 <byorgey> huh? I don't understand vixey's notation
11:58:54 <EvilTerran> except the parameter isn't named explicitly in the definition of "t" in the t[a := b] case
11:59:04 <opqdonut> byorgey: a probably appears in t
11:59:12 <opqdonut> as EvilTerran said
11:59:15 <EvilTerran> (i mean named explicitly as a parameter)
11:59:20 <vixey> ?djinn (a -> b) -> ((((a -> rho) -> a) -> a) -> a) -> ((((b -> rho) -> b) -> b) -> b)
11:59:21 <lambdabot> f a b c = c (\ d -> a (b (\ e -> e (\ f -> d (a f)))))
11:59:57 <rwbarton> ?djinn ((((a -> rho) -> a) -> a) -> a) -> a
11:59:57 <lambdabot> -- f cannot be realized.
12:00:04 <athos> @src maybe
12:00:05 <lambdabot> maybe n _ Nothing  = n
12:00:05 <lambdabot> maybe _ f (Just x) = f x
12:00:12 <dons> ?users
12:00:12 <lambdabot> Maximum users seen in #haskell: 597, currently: 597 (100.0%), active: 22 (3.7%)
12:00:16 <EvilTerran> byorgey, it's substitution, as in "(\x. E) y = E[x := y]"
12:00:21 <athos> 597 dons
12:00:22 <athos> !
12:00:23 <athos> :)
12:00:24 <dons> ok. all time high score.. just need 3 more :)
12:00:27 <athos> 3 more to go :/
12:00:39 <dons> hey all. haskell is fun. :)
12:00:45 <EvilTerran> tell your friends!
12:00:50 <dons> we got lambdas and types and variables that don't vary!
12:00:55 <ski_> rejoice !
12:00:56 <vixey> @let m a b c = c (\ d -> a (b (\ e -> e (\ f -> d (a f)))
12:00:56 <lambdabot>   Parse error
12:01:04 <vixey> @let m a b c = c (\ d -> a (b (\ e -> e (\ f -> d (a f))))
12:01:05 <lambdabot>   Parse error
12:01:08 <athos> > unsafeLaunchICBM now
12:01:09 <vixey> what :(
12:01:10 <lambdabot>   Not in scope: `unsafeLaunchICBM'Not in scope: `now'
12:01:14 <athos> :(
12:01:16 <vixey> @let m a b c = c (\ d -> a (b (\ e -> e (\ f -> d (a f)))))
12:01:16 <dons> Praise Wadler!
12:01:17 <BrokenClockwork> is there an already implemented ascii code table, for instance chr 65 = 'A' ?
12:01:17 <lambdabot>  Defined.
12:01:20 <dons> Bless Moggi!
12:01:26 <vixey> > chr 65
12:01:28 <lambdabot>   'A'
12:01:31 <dons> :)
12:01:31 <athos> > ord 'A'
12:01:33 <lambdabot>   65
12:01:35 <vixey> BrokenClockwork, looks like it!
12:01:36 <dons> welcome matt_estes
12:01:37 <vixey> :t m
12:01:39 <lambdabot>     Ambiguous occurrence `m'
12:01:39 <lambdabot>     It could refer to either `L.m', defined at <local>:5:0
12:01:39 <lambdabot>                           or `SimpleReflect.m', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
12:01:40 <BrokenClockwork> it doesn't work with prelude, does it?
12:01:44 <redditbot> Enfranchised Mind &raquo; The problem with STM: your languages still suck (hint: he's not talking about Haskell :)
12:01:46 <vixey> @let moo a b c = c (\ d -> a (b (\ e -> e (\ f -> d (a f)))))
12:01:46 <dons> BrokenClockwork: in Data.Char
12:01:47 <lambdabot>  Defined.
12:01:48 <vixey> :t moo
12:01:49 <lambdabot> forall t3 t t1 t2 t4. (t3 -> t) -> ((((t3 -> t1) -> t2) -> t2) -> t3) -> (((t -> t1) -> t) -> t4) -> t4
12:01:51 <athos> @index ord
12:01:52 <lambdabot> Data.Char
12:01:54 <BrokenClockwork> thanks :)
12:02:20 <byorgey> EvilTerran: yes, but I didn't understand what t(a) and t(b) meant
12:02:36 <rwbarton> > Nothing :: Maybe (Int)
12:02:37 <lambdabot>   Nothing
12:02:49 <vixey> :t moo (\u -> Left u) (\wobbly -> Right wobbly)
12:02:51 <lambdabot>     Occurs check: cannot construct the infinite type:
12:02:51 <lambdabot>       t3 = Either a (((t3 -> t1) -> t2) -> t2)
12:02:51 <lambdabot>       Expected type: t3
12:03:00 <EvilTerran> byorgey, i think that was meant to be the haskell-y notation for something equivalent
12:03:13 <BMeph> Ooh, so close, dons! :)
12:03:15 <EvilTerran> just where the parameter was named at the definition-point of t
12:03:21 <vixey> byorgey,  oh instead of  t(a)  how about  t a
12:03:28 <EvilTerran> "t takes this parameter"
12:03:41 <vixey> t :: * -> *
12:04:02 <dons> ?seen shapr
12:04:03 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 19h 57m 29s ago, and .
12:04:06 <BMeph> @users
12:04:06 <lambdabot> Maximum users seen in #haskell: 598, currently: 598 (100.0%), active: 24 (4.0%)
12:04:09 <dons> ah, he'd have liked   to be here.
12:04:13 <dons> ?shapr!
12:04:13 <lambdabot> Unknown command, try @list
12:04:20 <EvilTerran> ?get-shapr
12:04:21 <lambdabot> shapr!!
12:04:27 <mmorrow> qu@users
12:04:29 <dons> welcome Adkron
12:04:34 <mmorrow> noooo
12:04:36 <opqdonut> :D
12:04:38 <BMeph> D'Oh! :\
12:04:40 <vixey> maybe shapr will be the 600th
12:04:43 <dons> come on kids, we can do it...
12:04:48 <mmorrow> quick, somone  have two bots join!!
12:05:07 <ski_> (should our aliases temporarily part ?)
12:05:20 <Tobsan> =(
12:05:22 <athos> :'(
12:05:25 <BMeph> pumpkin: Bring out your bot! :)
12:05:30 <pumpkin> it died?
12:05:36 <EvilTerran> @bot
12:05:36 <pumpkinbot> :)
12:05:36 <lambdabot> :)
12:05:36 <lunabot>  :)
12:05:38 <mmorrow> @users
12:05:38 <lambdabot> Maximum users seen in #haskell: 599, currently: 597 (99.7%), active: 25 (4.2%)
12:05:38 <pumpkinbot> Maximum users seen in #haskell: 597, currently: 597 (100.0%), active: 4 (0.7%)
12:05:39 <pumpkin> lol
12:05:52 <EvilTerran> hehe
12:05:52 <Tobsan> lol
12:05:53 <dons> did someone scare away the bots
12:05:57 <chessguy_work> @source Control.Monad.State
12:05:57 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
12:06:14 <pumpkin> BMeph: why the false alarm?!?!?! I almost pressed the red button!
12:06:15 <bohdan> @skyNet
12:06:16 <lambdabot> Unknown command, try @list
12:06:22 <Tobsan> ahhaahahahahaha
12:06:23 <bohdan> good!
12:06:25 <EvilTerran> @vixen skynet?
12:06:25 <lambdabot> isn't it obvious?
12:06:29 <EvilTerran> O.o
12:06:35 <Tobsan> whaaaat
12:06:36 <mmorrow> @. elite nixon
12:06:36 <lambdabot> you WOn'7 |-|4VE nIxON 7O KICk ar0uNd aNYm0re, BECAu$E, Gen+1EmEN, +Hiz0rz I5 my |A57 pRE$s cONf3rENC3.
12:06:36 <dons> this is a good read, http://www.reddit.com/r/programming/comments/7n07q/the_problem_with_stm_your_languages_still_suck/
12:06:36 <athos> pumpkin: unsafePressRedButton?
12:06:37 <Tobsan> scary
12:06:39 <pumpkin> I'll bring in my bot if we hit 599
12:07:09 <ddarius> You can't use bots to raise the high-water mark.
12:07:15 <pumpkin> :(
12:07:26 <mmorrow> bots have to mercy though
12:07:28 <pumpkin> noes, don't leave
12:07:31 <mmorrow> *no
12:07:32 <BMeph> pumpkin: Ah! People keep leaving - I blame pimpknbot! ;)
12:07:37 <pumpkin> :(
12:07:46 <EvilTerran> dons, the post itself, or the reddit discussion?
12:07:48 <idnar> @users
12:07:49 <lambdabot> Maximum users seen in #haskell: 599, currently: 595 (99.3%), active: 27 (4.5%)
12:07:54 <pumpkin> oh no!
12:08:01 <mmorrow> sell sell selll!
12:08:09 <dons> EvilTerran: the post.
12:08:13 <pumpkin> now, I could join my bot to this channel, or my spambot to other channels
12:08:13 <Tobsan> michaelcdever: very welcome!
12:08:26 <pumpkin> we lose one and gain one each time!
12:08:28 <pumpkin> oh tomh!
12:08:46 <tomh> ye?
12:08:49 <tomh> whats up
12:08:51 <michaelcdever> cheers Tobsan
12:09:05 <pumpkin> 596!
12:09:16 <tomh> whats so special about that
12:09:18 <rwbarton> dons: is redditbot yours?
12:09:18 <ski_> MORE HASKELL
12:09:21 <dons> rwbarton: yeah
12:09:26 <pumpkin> 597!
12:09:27 <Tobsan> 597!
12:09:28 <Tobsan> lol
12:09:36 <tomh> some record or something?
12:09:41 <rwbarton> dons: Maybe it could include a tinyurl link?  I don't usually read reddit, but sometimes a headline looks interesting and I have to dig a little to find it
12:09:41 <ski_> > product [1..597]
12:09:43 <lambdabot>   588854108494383403099307013228607940848618184817256779144534315764482090326...
12:09:49 <Tobsan> 598!
12:09:50 <pumpkin> 598!
12:09:52 <dons> rwbarton: agreed.
12:09:54 <pumpkin> lol
12:09:55 <jerith> Aww, two more.
12:10:00 <rwbarton> dons: I guess it is just the RSS bot?
12:10:04 <dons> yeah
12:10:13 <dons> when i get back from vacation, i'll tweak it
12:10:16 <jerith> I must learn Haskell this year.
12:10:21 <pumpkin> omg!
12:10:25 <Tobsan> :o~~
12:10:26 <rwbarton> dons: Awesome.  seems like it'd be a generally useful feature
12:10:28 <pumpkin> !!!!!
12:10:28 <dons> woo!!!
12:10:29 <Tobsan> hoo~
12:10:29 <idnar> @users
12:10:30 <lambdabot> Maximum users seen in #haskell: 601, currently: 601 (100.0%), active: 30 (5.0%)
12:10:30 <dons> ?users
12:10:30 <lambdabot> Maximum users seen in #haskell: 601, currently: 601 (100.0%), active: 30 (5.0%)
12:10:31 <hugo___> dons: where are you taking vacances ?
12:10:33 <Tobsan> OMG
12:10:34 <mmorrow> @users
12:10:34 <lambdabot> Maximum users seen in #haskell: 601, currently: 601 (100.0%), active: 31 (5.2%)
12:10:37 * byorgey cheers
12:10:37 <dons> welcome all.
12:10:38 <pumpkin> yay
12:10:41 <hugo___> :D
12:10:41 * idnar sets the fireworks off
12:10:42 <jerith> Yay!
12:10:43 <dons> 2009 begins with a bang :)
12:10:44 <michaelcdever> back for another evening of asking you folks for help :D
12:10:45 <Tobsan> \o/
12:10:56 <hugo___> brutal
12:10:57 <opqdonut> :D
12:11:01 <athos> OH MY GOOD
12:11:02 <hugo___> 600 users for the win
12:11:04 <athos> 601 users
12:11:05 <athos> \o/
12:11:10 <jerith> <troll>So, is Haskell anything like PHP?</troll>
12:11:12 <dons> i think we might be bigger than #perl now..
12:11:17 <pumpkin> jerith: yes!
12:11:18 <mmorrow> pierre-: user 600
12:11:31 <idnar>  -!- Irssi: #perl: Total of 550 nicks [0 ops, 0 halfops, 0 voices, 550 normal]
12:11:33 <Tobsan> o_0
12:11:34 <pumpkin> jerith: it's written in text!
12:11:39 <chessguy_work> michaelcdever, ask away! we like questions!
12:11:42 <jerith> pumpkin: Let me guess... they're both Turing complete except PHP?
12:11:45 <arw> which only means that haskell-users need more help :>
12:11:49 <hugo___> when will the new logo be decided ? i want to start buying t-shirts :D
12:11:51 * jerith chuckles.
12:11:52 <athos> this year will occur in the history books of the future as the legendary "haskell year"
12:12:01 <michaelcdever> haha chessguy_work, you're going to regret that
12:12:01 <athos> or the beginning of "the golden haskell age"
12:12:03 <athos> 8]
12:12:03 <dons> in August we reached 500.
12:12:05 <idnar> the year of the lambda?
12:12:06 <pumpkin> every year will be a legendary haskell year
12:12:15 <dons> here was the last announce, http://article.gmane.org/gmane.comp.lang.haskell.cafe/42671
12:12:32 <athos> pumpkin: i think you just omitted the proof by induction, didn't you? :)
12:12:32 <czShadoW> @users
12:12:33 <michaelcdever> mind you, if someone were to volunteer to do my project, it'd save asking the questions
12:12:33 <lambdabot> Maximum users seen in #haskell: 602, currently: 602 (100.0%), active: 34 (5.6%)
12:12:40 <czShadoW> Heh, wow.
12:12:44 <pumpkin> athos: I'll leave that to you:P
12:12:50 <athos> ah ok :D
12:12:54 <pumpkin> michaelcdever: not sure about that
12:13:00 <vixey> it's bizzare to sometimes use "then" and other times use "->"
12:13:08 <bremner> > chr 8217
12:13:08 <chessguy_work> michaelcdever, what kind of project?
12:13:10 <lambdabot>   '\8217'
12:13:11 <michaelcdever> lol, I wouldn't wish this on anyone
12:13:21 <wchogg> michaelcdever : well now I'm curious
12:13:28 <michaelcdever> chessguy_work: graphical file manager, im planning on using gtk2hs
12:13:32 * jerith has been hacking in Erlang a bit recently.
12:13:39 <hugo___> i hope 2009 will also open more jobs for haskell programmers
12:13:47 <chessguy_work> michaelcdever, wow, for what OS?
12:13:47 <pumpkin> let's overtake python later this year, okay?
12:13:51 <ski_> (vixey : .. where ?)
12:13:52 <michaelcdever> but its been over a year since i've used haskell for anything and i forget loads
12:13:54 * jerith flees from the GUI file manager.
12:14:01 <michaelcdever> chessguy: just for a project
12:14:23 <chessguy_work> michaelcdever, ...
12:14:28 <michaelcdever> came up with the idea meself and all :D never been done before, specially not to the defree im hoping for :D
12:14:32 * pumpkin takes advantage of the activity to remind people of the existence of http://www.reddit.com/r/haskell_proposals/
12:14:34 <chessguy_work> michaelcdever, you must have an OS in mind for it to run on
12:14:35 <sdubois92>  Could not find module `Text.PrettyPrint' it is a member of package pretty-1.0.0.0, which is hidden
12:14:41 <sdubois92> any idea?
12:14:49 <sdubois92> i get that when i try to emerge cabal on Gentoo
12:14:49 <michaelcdever> yeah, linux
12:14:57 <chessguy_work> ah
12:15:09 <michaelcdever> gnome/kde/*wm independant
12:15:21 <chessguy_work> sounds like fun
12:15:27 <hugo___> oh pumpkin that sounds very good
12:15:32 <michaelcdever> sounds like a nightmare
12:15:35 <Raevel> sdubois92: it means that a used module isn't listed as a dependency somewhere
12:15:38 <michaelcdever> fixed that for you chessguy
12:15:58 <chessguy_work> michaelcdever, well complaining about it isn't going to get you any closer :)
12:16:11 <vixey> ski_, if  mu alpha rho and p[alpha := sigma] -> sigma then sigma, but it's really:  mu alpha rho -> (p[alpha := sigma] -> sigma) -> sigma
12:16:17 <abbe> hi all
12:16:20 <michaelcdever> i plan on opensourcing it too when i'm finished lol, i know that, but complaining aids procrastination
12:16:22 <chessguy_work> hi abbe
12:16:34 <sdubois92> Raevel: thats what i thought, but i can't find a package named "pretty"
12:16:37 <vixey> ski_, well I guess it's sort of gradually going from proof ==> program instead of all at once
12:16:38 <abbe> I'm having an issue with Data.HashTable in GHC
12:16:49 <abbe> hi chessguy_work
12:16:59 <hugo___> time to leave, see you all tomorrow
12:17:01 <chessguy_work> michaelcdever, ok, so what's the overall architecture of your file manager going to look like?
12:17:01 <abbe> I've pasted my code at http://hpaste.org/13537
12:17:08 <jerith> ghc doesn't want to compile on my G4 iBook. :-/
12:17:45 <abbe> It seems my hashtable insertion code is not being executed. Hmm...?
12:17:51 * chessguy_work prods michaelcdever along
12:17:56 <michaelcdever> well os architecture x32 during development, sys arch: user -> haskell fm <-> host system
12:17:58 <vixey> I should figure some how to type greek letters actualyy :/
12:18:14 <chessguy_work> michaelcdever, no, i mean the architecture of your code
12:18:23 <michaelcdever> is confused
12:18:39 <chessguy_work> michaelcdever, how are you going to do it, at a high level
12:18:39 <ski_> vixey : i suspect `if .. and ... then ...' might actually be a wordy notation for `.. , ... |- ...'
12:18:43 <paper_cc> abbe: you should be using mapM or mapM_ instead of return.map
12:18:49 <vixey> ski_, yes
12:18:52 <rwbarton> abbe: You should be using Data.Map :P
12:18:59 <vixey> ski_, I guess that is exactly it
12:19:02 <paper_cc> abbe: check the type of populate and it'll be clear
12:19:12 <michaelcdever> using a lot of the System modules :D
12:19:19 <chessguy_work> michaelcdever, like what?
12:19:21 <rwbarton> abbe: But yes, s/return $ map/mapM_/
12:19:48 <michaelcdever> System.FilePath, System.Directory, Posix.Regex (for searching)
12:19:50 <chessguy_work> @type return . map
12:19:51 <ski_> (vixey : .. or maybe an inference rule ..)
12:19:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m ([a] -> [b])
12:19:56 <abbe> oh, okay.
12:19:56 <paper_cc> abbe, your populate :: IO [IO ()], so the inner IO()s are not executed
12:20:01 <pumpkin> abbe: oh no, a hashtable :(
12:20:03 <ddarius> The "rule" notation has, typically, at least three levels of implication.
12:20:28 <chessguy_work> michaelcdever, ok. what about for Gtk2HS, what are you going to need out of that
12:20:32 <michaelcdever> im working on the searching today, im having problems getting it to recurse through the directories
12:20:32 <ski_> ddarius : the third being ?
12:20:51 <chessguy_work> michaelcdever, oh? have you seen the example in RWH?
12:20:58 <Cale> abbe: btw, Data.HashTable is not something which you should actually use for anything
12:21:06 <michaelcdever> yeah, im working on a modified version of that
12:21:11 <mmorrow> sdubois92: add "pretty" to the "build-depends:" in foo.cabal
12:21:14 <michaelcdever> rwh is a fantastic book
12:21:22 <mmorrow> whoa, i was scrolled up a ways
12:21:34 <michaelcdever> the version in rwh doesnt recurse
12:21:35 <Raevel> sdubois92: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty
12:21:46 <michaelcdever> it just searches a supplied directory
12:21:58 <paper_cc> @users
12:21:59 <lambdabot> Maximum users seen in #haskell: 605, currently: 602 (99.5%), active: 37 (6.1%)
12:22:00 <chessguy_work> michaelcdever, hm, really? i don't have it in front of me
12:22:01 <pumpkin> abbe: you might have a good reason for using hashtable, but things you'd typically use "hashes" for in other languages are usually dealt with using a Data.Map in haskell
12:22:07 <michaelcdever> in theory getting it to recurse should be easy
12:22:13 <bos> michaelcdever: glad you like the book
12:22:17 <michaelcdever> ill get you a link for it now...
12:22:18 <abbe> pumpkin: okay
12:22:30 <bos> the code in the book should indeed recurse into subdirectories
12:22:33 <ddarius> ski_: Object level implication.
12:22:44 <michaelcdever> bos: you'd be brian o sullivan then? lol, conas atá tu?
12:22:49 <bohdan> notice how many more users became active in the last few minutes
12:22:56 <chessguy_work> there's a blog entry about doing something like this, that you might like: http://blog.moertel.com/articles/2007/02/22/a-simple-directory-tree-printer-in-haskell
12:22:58 <abbe> thanks rwbarton, paper_cc and pumpkin.
12:23:03 <pumpkin> ?users
12:23:03 <lambdabot> Maximum users seen in #haskell: 605, currently: 602 (99.5%), active: 38 (6.3%)
12:23:08 <pumpkin> bohdan: a bit, why?
12:23:10 <bos> michaelcdever: ha! maith go leor, go raibh maith agat
12:23:31 <abbe> I'm trying to write a code-generator in haskell, and for symbol table, I'm planning to use HashTable
12:23:34 <michaelcdever> bos: i was so surprised when i was reading it, and i saw gaelige in it lol
12:23:40 <bohdan> pimpkin, rather (2*)
12:23:57 <Cale> It might have been improved since then, but at least a while back, Data.HashTable was both less scalable, and had poorer performance in general than Data.Map
12:23:59 <bos> michaelcdever: stealth cultural export
12:24:09 <chessguy_work> michaelcdever, dons and CosmicRay are the other 2 authors :)
12:24:24 <Cale> (on top of only being accessible from IO)
12:24:33 <abbe> okay, so I should be using Data.Map then.
12:24:37 <pumpkin> abbe: I'd try to stick to pure structures as much as possible, yeah
12:24:47 <michaelcdever> bos: ordererd the book last night... you're gonna be getting me through 3rd year lol
12:24:56 <mmorrow> abbe: or IntMap if you can. it's faster than plain Map
12:24:58 <bos> michaelcdever: cheers :-)
12:25:12 <michaelcdever> chessguy: cheers, theyll hate you for telling me that
12:25:17 <michaelcdever> :D
12:25:20 <pumpkin> is there some way IntMap could be marked as a specialization of Map?
12:25:26 <pumpkin> IntMap = Map Int
12:25:27 <rwbarton> What's the status of the new generalized tries?  I always feel guilty using a Map String ...
12:25:27 <abbe> I've another question, as an HashTable implementation shouldn't be doing any I/O computation then why it is wrapped in IO Monad ?
12:25:27 <pumpkin> :P
12:25:48 <pumpkin> abbe: because it's mutable
12:25:49 <mmorrow> pumpkin: yeah, that's super annoying. maybe something could be done with type families
12:26:04 <Cale> abbe: It needs to do both memory updates and random number generation.
12:26:09 <michaelcdever> yeah i saw that moertel blog, very good, im going to have a deeper look at it now
12:26:44 <mmorrow> type family MapT m k v
12:26:59 <mmorrow> type instance MapT Map Int a = IntMap a
12:27:05 <Cale> abbe: Technically, it could be in ST, but seeing as its performance is not really any better than Data.Map, there's little point.
12:27:06 <pumpkin> ah
12:27:06 <abbe> Cale: a valid reason then. thanks.
12:28:34 <mmorrow> rwbarton: other than they got uploaded to hackage, i'm not sure.
12:28:45 <mmorrow> @hackage gmap
12:28:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gmap
12:28:48 <mmorrow> i think
12:29:07 <chessguy_work> @users
12:29:07 <lambdabot> Maximum users seen in #haskell: 605, currently: 601 (99.3%), active: 38 (6.3%)
12:29:12 <mmorrow> @hackage windows-3.1
12:29:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/windows-3.1
12:29:17 <rwbarton> mmorrow: gmap does exist :)
12:29:17 <abbe> pumpkin, so it has nothing to do with mutability ?
12:29:27 <pumpkin> abbe: ?
12:29:28 <chessguy_work> dons, how did you get the numbers for the other channels?
12:29:30 <mmorrow> rwbarton: nice. i've been meaning to check it out
12:29:33 * mmorrow wgets
12:29:51 <mmorrow> rwbarton: there might also be a darcs repo on c.h.o
12:30:36 <abbe> pumpkin, I mean, is you reason also valid. Say if hashtable implementation never needed a random number generator, it simply asked user to specify the hashtable size
12:30:44 <abbe> pumpkin, and other parameters.
12:31:00 <pumpkin> abbe: it would be hard to make an immutable hashtable that didn't require copying the whole thing around each time
12:31:07 <pumpkin> but it may be possible, I'm not sur
12:31:07 <pumpkin> e
12:31:18 <Cale> abbe: Data.Map is immutable, but manages to be efficient because operations that update a Map create a new Map which shares all but O(log n) of its structure with the old one.
12:31:32 <dons> mm. is #haskell bigger than all the other FP langs put together?
12:32:05 <mmorrow> we need an ircstats bot that allows queries on this type of stuff
12:32:17 <rwbarton> mmorrow: this IntMap implementation is pretty hairy: http://hackage.haskell.org/packages/archive/gmap/0.1/doc/html/src/Data-GMap-IntMap.html
12:32:17 <mmorrow> every bot already has all the data..
12:32:22 <bos> dons: that's a seductive number!
12:32:24 <chessguy_work> @where lambdabot
12:32:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:32:38 <wjt> hmm. apparently calling an anonymous function a "lambda" is "enterprise"
12:32:39 <chessguy_work> @seen lambdabot
12:32:39 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
12:32:39 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, ##freebsd, #gentoo-uy, #gentoo-haskell, #
12:32:39 <lambdabot> friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
12:32:41 <abbe> okay, pumpkin and Cale
12:32:55 <abbe> thanks :)
12:32:59 <Cale> abbe: HashTables are not as amenable to that sharing
12:33:06 <mmorrow> rwbarton: gah!
12:33:13 <Cale> (immutable hashtables)
12:33:38 <dons> http://www.reddit.com/r/programming/comments/7n0p1/haskell_irc_channel_now_bigger_than_perl_or_ruby/ :)
12:33:41 <dons> ?users
12:33:42 <lambdabot> Maximum users seen in #haskell: 605, currently: 602 (99.5%), active: 37 (6.1%)
12:33:47 <michaelcdever> bos: just traced through that code again, doesnt seem to recurse
12:34:00 <mmorrow> rwbarton: i'm guessing that's at least 1000 lines
12:34:21 <Cale> But since any hash function which is capable of separating n distinct values must take O(log n) time to evaluate anyway, Data.Map's performance is asymptotically optimal.
12:34:29 <abbe> Another question, is there anything natively mutable in Haskell runtime. or it is just simulated.
12:34:52 <opqdonut> well IORefs for one
12:35:03 <dons> abbe: lots of native mutation via the ST monad
12:35:08 <dons> on which all mutatoin is built
12:35:17 <Cale> dons: and IO of course.
12:35:33 <mmorrow> which is a specialization of ST (in ghc at least)
12:35:38 <pumpkin> http://camlp3l.inria.fr/eng.htm :o
12:36:05 <Cale> mm... I'm not sure I'd be willing to view IO as a specialisation of ST
12:36:09 <mmorrow> hmm, is there anything fundamental about IO being a particular
12:36:16 <mmorrow> yeah, i'm wondering what that means
12:36:20 <bohdan> http://haskell.org/haskellwiki/IRC_channel doesn't load for me
12:36:30 <bohdan> ^ dons
12:36:32 <rwbarton> haskell.org isn't loading for me either
12:36:35 <pumpkin> http://downforeveryoneorjustme.com/haskell.org
12:36:54 <paper_cc> hmm, it had 605 users - above #python then
12:36:58 <dmwit_> dons: What do the numbers on the announcement mean?  #users?
12:37:07 <dons> dmwit_: yeah
12:37:13 <pumpkin> paper_cc: last I looked python had 640 or so?
12:37:15 <dons> the 'up/down' are rankings
12:37:20 <dons> i.e. haskell's overtaken 4 other langs
12:37:42 <abbe> oh, so one needs some kind of native support for native mutation, and not possible with pure-haskell (i.e. without any unsafe/native support), right ?
12:37:43 * bohdan .ooO( reddit effect? )
12:37:46 <dons> oh, is haskell.org under a bit of load?
12:37:49 <paper_cc> pumpkin: 604 according to the post
12:37:58 <mmorrow> down for me too
12:38:00 <sdubois92> Raevel: i emerge wl-pprint, is that different from pretty?
12:38:00 <dmwit_> paper_cc: 640 according to actually going there =)
12:38:01 <dons> yeah, haskell.org looks to be under a bit of effort.
12:38:12 <CakeProphet> I /still/ haven't gotten lambdabot to install
12:38:13 <Asztal> I wanted to download ghc 6.10 too :(
12:38:13 <dmwit_> And #php is at 690.
12:38:19 <mmorrow> does it still only handle 50 connections max?
12:38:21 <pumpkin> CakeProphet: it's a lot easier on 6.8
12:38:26 <dmwit_> That's why I was asking dons about the numbers -- they didn't seem that close to what I was seeing...
12:38:26 <vixey> ?djinn  ((Either a b) -> c)  ->  ((a -> c) , (b -> c))
12:38:27 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
12:38:27 <pumpkin> I got it onto my 6.10 at one point
12:38:30 <pumpkin> but it was a real pain
12:38:33 <vixey> ?djinn  ((a -> c) , (b -> c)) -> ((Either a b) -> c)
12:38:34 <lambdabot> f (a, b) c =
12:38:34 <lambdabot>     case c of
12:38:34 <lambdabot>     Left d -> a d
12:38:34 <lambdabot>     Right e -> b e
12:38:43 <pumpkin> we definitely need to overtake php for great justice
12:39:07 <Raevel> overtake in what sense?
12:39:24 <pumpkin> the number of users in their channel :P
12:39:39 <Raevel> we could just infiltrate and ban everyone
12:39:51 <Raevel> i doubt they're learning anything useful
12:39:53 <pumpkin> lol
12:39:58 <michaelcdever> grrr
12:40:01 <dons> dmwit_: oh, i just grabbed them from the ircstats site
12:40:01 <dmwit_> You get the freenode admin password, I'll initiate the hijinks. ;-)
12:40:34 <CakeProphet> you best be trollin'
12:40:45 <CakeProphet> we can just troll them out of their own channel.
12:40:59 <pumpkin> we should all go into #php and tell people that php kills baby seals and that we lost our families to it, ec.
12:41:02 <pumpkin> etc.
12:41:10 <Raevel> sdubois92: you can check if pretty is installed with ghc-pkg list | grep pretty
12:41:21 <ski_> @quote
12:41:21 <lambdabot> metaperl says: I never thought anyone could be on IRC as much as you and look that good
12:41:23 <mmorrow> i think pretty is in base
12:41:25 <vixey> how do you go from mu a, 1 + a  to  forall a, ( (1 + a) -> a ) -> a?
12:41:34 <sdubois92> Raevel:  packedstring-0.1.0.0, parsec-2.1.0.0, pretty-1.0.0.0,
12:41:44 <mmorrow> sdubois92: i think you just have to edit the whatever.cabal file of the package you're trying to install
12:41:57 <mmorrow> and add "pretty" to the "build-depends:" list
12:41:59 <sdubois92> mmorrow: im trying to install cabal
12:42:02 <mmorrow> heh
12:42:04 <Raevel> :*/
12:42:13 <sdubois92> its a catch 22 of sorts
12:42:15 <CakeProphet> pumpkin:  nah... just question features and why they're used in PHP instead of some equivalent, yet obviously non-superior, feature of Visual Basic
12:42:20 <CakeProphet> until flaming commences.
12:42:20 <mmorrow> sdubois92: where did you get your ghc?
12:42:35 <Cale> abbe: A better way to put it is that mutation isn't possible via Haskell evaluation (aside from that mutation which replaces an expression with its value), but it is possible via execution in the IO or ST monad.
12:42:37 <vixey> I guess it's just coincidence
12:42:46 <sdubois92> mmorrow: emerge ghc i guess
12:43:03 <pumpkin> "There are comments, both in the Reddit discussion that Bill references and in response to his own article, that suggest that a CS degree is actually an indicator of a poor programmer. " :o
12:43:04 <sdubois92> http://distro.ibiblio.org/pub/linux/distributions/gentoo/distfiles/ghc-bin-6.6.1-x86.tbz2
12:43:13 <mmorrow> sdubois92: maybe try something like emerge ghc-extralibs or something
12:43:18 <sdubois92> ok
12:43:22 * CakeProphet is 17. no degree.
12:43:33 <frivol> There are lots of good excuses to avoid an education.
12:43:40 <mmorrow> sdubois92: ooh, also see if there're any newer ghc's that 6.6.1
12:43:43 <pumpkin> CakeProphet: you must be a good programmer
12:43:47 <CakeProphet> clearly.
12:43:54 <CakeProphet> as can be seen by the examples provided on this channel.
12:44:05 <mmorrow> sdubois92: if not, you may want to juts get the ghc binary from http://haskell.org/ghc
12:44:05 <Cale> pumpkin: Everyone knows that a mathematics degree is what you really want, hehe ;)
12:44:08 <CakeProphet> with me playing with lambdabot.
12:44:30 * EvilTerran is 20, 2/3 of the way through a compsci degree, and planning to stay in uni for as long as possible by going into research :P
12:44:32 <pumpkin> Cale: hah, I really wanted one until I found I didn't like the the profs in my math dept :P
12:44:37 <mmorrow> math++
12:44:38 <dons> Cale: a CT PhD lolz :)
12:44:45 <beelsebob> so we only need to get 10 people in here to be the most popular language in the world^H^H^H^H^Hfreenode then?
12:44:45 <vixey> lol
12:44:58 <pumpkin> dons: CT?
12:45:04 <EvilTerran> pumpkin, category theory
12:45:07 <pumpkin> ah :)
12:45:19 <michaelcdever> gah
12:45:32 <CakeProphet> beelsebob, you forgot to backspace people and add "bots"
12:45:33 <EvilTerran> gah?
12:45:41 <beelsebob> CakeProphet: lol
12:45:53 <dmwit> beelsebob: I think maybe dons' stats are a bit off.
12:45:57 <pumpkin> EvilTerran: will you turn good once you finish the degree? or are you evil4life?
12:46:11 <CakeProphet> can you even imagine... if all 602 of us were active on this channel.
12:46:14 <ikkebr> beelsebob not true :p python has 638
12:46:18 <CakeProphet> I would immediately leave.
12:46:22 <mmorrow> rwbarton: hmm, i'm a bit suspicious about this AvlTree dep too..
12:46:24 <yottis> does anyone know any good category theory books?
12:46:30 <pumpkin> yottis: Cale does
12:46:31 <beelsebob> oh, dons' email lied then ikkebr
12:46:46 <Cale> yottis: Awodey's book is rather good
12:46:53 <beelsebob> :(
12:47:00 <yottis> i checked the cheapish "category theory for computer scientists" but that sounds a bit like "for dummies" :)
12:47:10 <pumpkin> yottis: who you calling a dummy??!?!
12:47:14 <vixey> yottis, haha
12:47:15 <pumpkin> :P
12:47:16 <Cale> yottis: http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
12:47:18 <mmorrow> yottis: that one looks kinda odd
12:47:25 <mmorrow> (judging by the TOC)
12:47:29 <EvilTerran> pumpkin, i'll turn good when i stop being attached to a university; if all goes to plan, that may be my retirement ;)
12:47:38 <mpwd__> yottis: Categories for the Working Mathematician is the classic
12:47:44 <pumpkin> EvilTerran: sounds like a good plan :P
12:47:52 <mmorrow> yottis: (@cat...for computer scientists)
12:47:55 <sdubois92> mmorrow: i think a re-emerge of ghc fixed it
12:47:57 * CakeProphet hasn't decided if he really wants to do CS in college.
12:48:00 <mmorrow> sdubois92: nice
12:48:02 <yottis> that suggests that there is actually a mathematician with a job :)
12:48:02 <Cale> Awodey's book has the nice property of not requiring too many prerequisites.
12:48:06 <pumpkin> CakeProphet: I'll decide for you if you want
12:48:08 <sdubois92> mmorrow: Raevel: thanks
12:48:11 <Cale> yottis: :)
12:48:13 <CakeProphet> pumpkin:  ...excellent.
12:48:18 <pumpkin> CakeProphet: ...yes
12:48:19 <mmorrow> sdubois92: you really should consider installing a newer ghc than 6.6.1
12:48:20 * CakeProphet revels in passiveness.
12:48:37 <CakeProphet> pumpkin:  reason?
12:48:37 <Feuerbach> beelsebob: that's not a biggest lie, actually. More important, that  stats is taken when #haskell got some maximum, so there's a bias
12:48:41 <michaelcdever> this is depressing
12:48:45 <pumpkin> CakeProphet: cause it's awesome, like duh
12:48:51 <beelsebob> Feuerbach: yeh, indeed
12:48:54 <pumpkin> michaelcdever: what is?
12:48:59 <Feuerbach> anyway, we all know Haskell community is the greatest
12:49:01 <Cale> Awodey's book is sort of the new version of CFTWM, in some sense.
12:49:05 <skorpan> @users
12:49:05 <CakeProphet> pumpkin:  but all of my semi-close CS friends who actually make money with it are total burn outs.
12:49:05 <lambdabot> Maximum users seen in #haskell: 605, currently: 604 (99.8%), active: 36 (6.0%)
12:49:18 <Cale> It's written for a slightly more general audience, and includes new material.
12:49:22 <pumpkin> CakeProphet: that's sad, they should've stayed in academia
12:49:22 <CakeProphet> pumpkin:  so maybe I just want to play with programming in my spare time and like... teach math, or something.
12:49:33 <michaelcdever> this directory thing, i should be able to get it to recurse real easy, but theres something im not seeing
12:49:41 <mpwd__> CakeProphet: I recomend you consider a liberal arts college like Reed or Brown where you can have a bit of freedom with what you study.
12:49:42 <dons> beelsebob: the numbers are only be transient, but the rankings should be correct.
12:49:43 <michaelcdever> and i know its right there in front of me
12:49:51 <michaelcdever> like.... right there
12:49:54 <beelsebob> dons: where's the ranking data from?
12:49:55 <athos> ?users
12:49:55 <lambdabot> Maximum users seen in #haskell: 605, currently: 604 (99.8%), active: 37 (6.1%)
12:50:07 <dons> i.e. php < python < haskell < perl < ruby < erlang < ocaml
12:50:07 <vixey> michaelcdever: hmm?
12:50:13 <Cale> (for example, how the lambda calculus fits into things, which I don't think the original CFTWM touched on)
12:50:13 <dons> beelsebob: the freenode irc stats site
12:50:18 <dons> which uses a bot to sample on some interval
12:50:19 <mmorrow> rwbarton: hmm
12:50:21 <mmorrow> [m@ganon Data]$ wc -l GMap.hs GMap/* | tail -1
12:50:21 <mmorrow>   9057 total
12:50:25 <michaelcdever> vixey: hmm indeed!
12:50:32 <vixey> k
12:50:32 * EvilTerran sees two options that would be making good use of his degree: exhausting job at a city bank leading to early retirement, grotesque riches, and being too crushed by the experience to make the most of either... or academia
12:50:52 <michaelcdever> academia Terran
12:50:54 <vixey> EvilTerran, what do you intend to study?
12:50:57 <abbe> any ideas anyone which package on archlinux provides documentation of GHC ? Or I've to download the docs tarball from haskell.org ?
12:51:13 <Feuerbach> dons: oh, then I take my claim back
12:51:22 * bohdan .ooO( Yum, fajitas )
12:51:26 <dons> abbe: there's no docs package. grab it from haskell.org/ghc
12:51:32 <EvilTerran> vixey, you mean research-wise? i'm angling for the sort of thing the "programming languages and tools" group do at my uni
12:51:35 <abbe> dons, okay, thanks
12:51:41 <CakeProphet> pumpkin:  what can you do in academia?
12:51:47 <michaelcdever> stuff this, im off to ponder recursion while smoking....
12:51:51 <EvilTerran> except with less Aspects. they seem to be obsessed with Aspects.
12:51:51 <mmorrow> rwbarton: hmm, actually i guess that's on par
12:51:53 <mmorrow> [m@ganon Data]$ wc -l Graph.hs IntMap.hs IntSet.hs Map.hs Sequence.hs Set.hs Tree.hs | tail -1
12:51:53 <mmorrow>   8215 total
12:51:54 <vixey> EvilTerran: that's like the broadest possible thing ever :p
12:52:12 <pumpkin> CakeProphet: do fun stuff that you enjoy (which is more than you can say about most jobs)
12:52:26 <CakeProphet> pumpkin:  but like... how. where. where do you get money.
12:52:31 <EvilTerran> vixey, nah, that'd be more along the lines of "i want to study computers!"
12:52:37 * ddarius has been here too long.
12:52:39 <athos> , src ''Name
12:52:45 <lunabot>  data Name = Name OccName NameFlavour
12:52:53 <pumpkin> CakeProphet: the money to do the fun stuff, or the money to live on?
12:52:58 <mmorrow> CakeProphet: any way that you can
12:53:03 <CakeProphet> pumpkin:  latter
12:53:09 <mpwd__> CakeProphet: Academics enjoy a lowly upper middle class lifestyle.  'Cept for economists and noble prize winners.
12:53:14 <pumpkin> CakeProphet: meager stipends or decent salary as a prof
12:53:20 <mpwd__> Who I understand live in palaces.
12:53:27 <pumpkin> stipends for the grad students, that is
12:53:35 <mmorrow> and ones who have businesses on the side
12:53:52 <mmorrow> "oh why sure i can be an expert witness. $1000/hr"
12:53:55 <EvilTerran> vixey, i expect i'll be helping out more experienced academics with their own ideas at first, anyway
12:54:06 <Cale> Mathematics doesn't require a lot of money to do though...
12:54:36 <EvilTerran> by the time i've climbed the ranks far enough to be genuinely blazing my own trail, no doubt my ideas will be completely different from what they are now
12:55:03 <mmorrow> "oh why sure i can tell you why everything of yours is broken, _/hr"
12:55:05 <mpwd__> CakeProphet: I know a computational linguist who does forensics (ie, figuring out if an email was written by a particular person) and he makes a bit of cash when he does consulting jobs for the courts.
12:55:20 <CakeProphet> mpwd__:  that sounds completely badass.
12:55:32 <pumpkin> I know someone who does similar stuff with image forensics
12:55:40 <mpwd__> CakeProphet: Carl Vogel is totally the man :)
12:55:44 <mmorrow> "oh why sure i can tell you _, _/hr"
12:55:47 <ski_> @type let f :: Mu (Either ()) -> forall a. (Either () a -> a) -> a; f (In e) k = case e of Left () -> k (Left ()); Right m -> k (Right (f m k)) in f  -- vixey, this ?
12:55:48 <lambdabot> forall a. Mu (Either ()) -> (Either () a -> a) -> a
12:55:50 <EvilTerran> who knew computational linguistics was so glamorous...
12:56:17 <mpwd__> EvilTerran: Well, he lives in Trinity College in a tiny room
12:56:26 <mpwd__> ...which I guess is glamorous...
12:56:44 <dmwit> Doesn't xkcd have something to say about computational linguistics...?
12:56:51 <opqdonut> indeed :)
12:56:54 <dmwit> http://xkcd.com/114/
12:56:54 <Cale> I'm not sure how much weight I'd want to place on evidence of that sort...
12:57:03 <EvilTerran> mpwd__, in london?
12:57:10 <mpwd__> EvilTerran: Dublin
12:57:12 <EvilTerran> ah
12:57:19 <EvilTerran> there's a lot of Trinity colleges :)
12:57:44 <mpwd__> Cale: He tells me that false positives are common, but false negatives are rather rare from his analysis.
12:57:48 <EvilTerran> London, Oxford and Cambridge all have their own
12:57:59 <CakeProphet> http://xkcd.com/114/
12:58:08 <CakeProphet> ...
12:58:08 <dmwit> CakeProphet: waaay too slow
12:58:10 <CakeProphet> oh
12:58:11 <CakeProphet> beat me
12:58:27 <dmwit> ?go xkcd computational linguistics
12:58:33 <lambdabot> http://xkcd.com/114/
12:58:33 <lambdabot> Title: xkcd - A Webcomic - Computational Linguists
12:58:39 <dmwit> First hit on Google. =)
12:59:03 <mpwd__> ?go xkcd guard stabs
12:59:05 <lambdabot> No Result Found.
12:59:15 <mpwd__> :(  That one's my favorite
12:59:23 <athos> @src (>>=)::[]
12:59:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:59:27 <chessguy_work> @go xkcd bobby tables
12:59:30 <lambdabot> http://xkcd.com/327/
12:59:30 <lambdabot> Title: xkcd - A Webcomic - Exploits of a Mom
12:59:33 * chessguy_work grins
12:59:44 <dmwit> ?src (>>=) []
12:59:44 <lambdabot> Source not found. Do you think like you type?
12:59:48 <dmwit> ?src [] (>>=)
12:59:48 <lambdabot> xs >>= f     = concatMap f xs
12:59:54 <athos> ah thanks :)
13:00:01 * EvilTerran tends to use ohnorobot.com for looking up webcomic references
13:00:06 <pumpkin> :t (:[]):
13:00:07 <lambdabot> parse error (possibly incorrect indentation)
13:00:09 <michaelcdever> right i think il move onto searching for regex within a file for now and come back to this later
13:00:11 <pumpkin> :t ((:[]):)
13:00:12 <EvilTerran> partly because its name amuses me immensely
13:00:12 <lambdabot> forall a. [a -> [a]] -> [a -> [a]]
13:00:15 <pumpkin> oh yeah
13:00:25 <EvilTerran> ?src [] (>>=)
13:00:26 <lambdabot> xs >>= f     = concatMap f xs
13:00:31 <pumpkin> :t (((:[]):):)
13:00:32 <lambdabot> forall a. [[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]
13:00:37 <EvilTerran> :t flip flip flip
13:00:38 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:00:40 <athos> @src [] (>>=)
13:00:40 <lambdabot> xs >>= f     = concatMap f xs
13:00:41 <pumpkin> now that is truly useful
13:00:44 <athos> :-)
13:01:45 <redditbot> #haskell reaches 600 users: now bigger than Perl and Ruby channels
13:01:51 <EvilTerran> :D
13:01:59 <pumpkin> ORLY
13:02:49 <EvilTerran> but if we all join the perl or ruby channels to taunt them, we'll make them catch up =/
13:03:02 <pumpkin> epic dilemma
13:03:04 <CakeProphet> redditbot is a ponce.
13:03:19 <dmwit> This calls for an... *dum dum dum*
13:03:20 <dmwit> INSIDE JOB
13:03:26 <pumpkin> sounds rude
13:03:36 <CakeProphet> sounds saucy
13:03:38 <pumpkin> I guess it's better than getting a job at research in motion
13:03:56 <dmwit> ?wn ponce
13:03:58 <lambdabot> *** "ponce" wn "WordNet (r) 2.0"
13:03:58 <lambdabot> ponce
13:03:58 <lambdabot>      n : someone who procures customers for whores (in England they
13:03:58 <lambdabot>          call a pimp a ponce) [syn: {pimp}, {procurer}, {panderer},
13:03:58 <lambdabot>           {pander}, {pandar}, {fancy man}]
13:04:04 <dmwit> yipe
13:04:05 <EvilTerran> :O
13:04:13 <EvilTerran> no we don't!
13:04:54 <chessguy_work> err, if i have "class Foo a b where ...", what is the correct way to use it as a type parameter in a type signature?
13:05:17 <chessguy_work> i.e., bar :: Foo a b => Foo a b -> ... --?
13:05:19 <opqdonut> Foo a b => a -> b -> b
13:05:23 <mmorrow> <redditbot> free muney>@ #haskrell?.php?@#$423423454323
13:05:35 <chessguy_work> err
13:05:39 <chessguy_work> that doesn't seem right
13:05:40 <EvilTerran> chessguy_work, the parameters are separate types, you don't use them together
13:05:44 <dons> so there's 10x as many people here as in #ocaml, and 10x as many libs on hackage as on the caml hump. when do we declare the war over?
13:05:51 <mmorrow> haha
13:06:02 <mmorrow> when there are no survivors!!
13:06:11 <wchogg> dons : why does it have to be a war? :p
13:06:14 <dons> ok. but there's still a few people even in #clean right?
13:06:21 <dons> so it might take another decade..
13:06:29 <mmorrow> take no prisoners.
13:07:13 <pumpkin> dons: we should make peace and offer to forgive them if they rewrite all their existing code in haskell
13:07:14 <dmwit> dons: When the most-used Haskell application is used by more people than the most-used OCaml application.
13:07:17 <Cale> Yeah, I don't understand what's desirable about a monoculture.
13:07:31 * mmorrow just wanted to say "take no prisoners"
13:07:35 * vixey neither
13:07:38 <dons> no, competition is good. esp. when we're winning :)
13:07:38 <wchogg> dmwit : do you know what is the most used OCaml app?
13:07:44 <pumpkin> dmwit: why not the least-used Haskell app is more used than the most-used OCaml? :P
13:07:51 <Cale> I can understand the desire to move people from languages which are truly out of date to ones which are more reasonably modern...
13:08:04 <mmorrow> take no prisoners!
13:08:06 <matthewp> dons: It's a wonderful thing
13:08:06 <pumpkin> wchogg: OCaml people like to say it's FFTW or at least claim it as their own, but we know it's lies!
13:08:34 <dmwit> wchogg: That revision control thing.  What's it called? um... U-something
13:09:16 <dons> dmwit: unison?
13:09:20 <dmwit> That's the one.
13:09:21 <dons> ben pierce's rsync thing
13:09:31 <wchogg> I've never actually heard of unison.
13:09:54 <mmorrow> has anyone looked at the camp code? apparently it's an attempt to make darcs's patch theory rigorous.
13:09:57 <ddarius> FFTW uses monads!  It's really Haskell in disguise!
13:10:09 <dons> mmorrow: i think igloo has
13:10:13 <mmorrow> http://code.haskell.org/camp/
13:10:17 <roconnor> FFTW?  Fusion For The Win?
13:10:24 <mmorrow> dons: heh, didn't he write it?
13:10:29 <pumpkin> roconnor: fastest fourier transform in the west :o
13:10:34 <dmwit> wchogg: Apparently, my memory is way off.
13:10:37 <dmwit> wchogg: http://www.mail-archive.com/caml-list@yquem.inria.fr/msg01086.html
13:11:00 <dmwit> wchogg: Unison comes in second to FFTW by an order of magnitude...
13:11:20 <pumpkin> yeah, but fftw isn't really in ocaml
13:11:27 <Cale> It is.
13:11:33 <dmwit> 14,298 lines of OCaml
13:11:39 <dmwit> What qualifies as "really in ocaml"?
13:11:44 <opqdonut> unison is a great piece of software
13:11:45 <Cale> The real code for FFTW is in O'Caml.
13:11:48 <dons> well, do you need an ocaml runtime to use it?
13:11:50 <vixey>   <<p,q>> <~> <<p',q'>> <-> <<p',q'>> <~> <<p,q>>.
13:12:04 <Cale> All the C is generated by the O'Caml code.
13:12:04 <mmorrow> it's C with bits thereof generated by ocaml code
13:12:09 <dons> you'd have to see how many people used the ocaml source for fftw, and the ocaml compiler. or just  the later, generated stuff
13:12:17 <Cale> The stuff which was written by a human is in O'Caml.
13:12:18 <pumpkin> yeah
13:12:25 <mmorrow> Cale: i don't believe all of the C is generated
13:12:31 <dons> i'm sure there are popular packages out there that had haskell scripts involved in their production too
13:12:46 <ddarius> Linspire...
13:13:05 <roconnor> weee 609 nicks
13:13:10 <Cale> mmorrow: Pretty much all of it. There might be some small amount of wrapper code written by hand.
13:13:13 <dons> "which runtime is used?" seems like a decent metric imo
13:13:33 <chessguy_work> hrmph. still not quite getting the types i want. how about this: class Foo a b c where bar :: a b c -> b -> a b c
13:13:37 <chessguy_work> is that vali?
13:13:39 <chessguy_work> +
13:13:40 <chessguy_work> +d
13:13:41 <dmwit> Well, Unison definitely uses the OCaml runtime, and still has 3x as many users as darcs.
13:13:50 <mmorrow> Cale: o rly? hmm. i've gotta take another look then. if that's the case then it's more interesting than i thought :)
13:13:57 <dons> dmwit: on debian, a year ago?
13:14:02 <EvilTerran> chessguy_work, yes, if (a :: * -> * -> *)
13:14:04 <dmwit> Yes.
13:14:09 <dmwit> Admittedly outdated stats.
13:14:10 <dons> i wonder what it is like now.
13:14:18 <dons> xmonad's gone from about 70 to 700 users in that     itme.
13:14:38 <dons> and hackage went from 200 to 970 libs
13:14:41 <dmwit> xmonad was at 542 at the time of writing.  So I'm not sure that's accurate.
13:14:50 <dons> oh, so that's the sum of debian and ubuntu?
13:15:08 <dmwit> looks like
13:15:20 <matthewp> dons: that's amazing!  BTW, still looking at the Selenium runner fixes. Need to understand the java code a bit more
13:15:23 <Cale> mmorrow: Well, the basic idea behind it is that there are lots of ways to write a discrete Fourier transform routine for a fixed size, especially so when it's not just a power of two.
13:15:31 <EvilTerran> dons, i know a few guys on another network who've never touched haskell, but use xmonad; i don't think i introduced all of them to it, either :)
13:15:32 <vixey> ?djinn (a -> b) -> (() -> (p -> a)) -> (() -> (p -> b))
13:15:32 <lambdabot> f a b _ c = a (b () c)
13:15:48 <vixey> ?djinn (a -> b) -> (Either () (p -> a)) -> (Either () (p -> b))
13:15:49 <lambdabot> f a b =
13:15:49 <lambdabot>     case b of
13:15:49 <lambdabot>     Left _ -> Left ()
13:15:49 <lambdabot>     Right c -> Right (\ d -> a (c d))
13:16:00 <dons> matthewp: awesome.
13:16:05 <matthewp> dons: I'd also like to see a FIT SLIM implementation in Haskell much like they have in Erlang to do table based acceptance testing
13:16:11 <pumpkin> Cale: there are at least 37k lines of c in their source tar file, but I guess a lot of that is pregenerated
13:16:16 <mmorrow> Cale: sure, but for some reason i thought that what was generated plugged into a larger C framework, rather than be the framework itself.
13:16:29 <pumpkin> Cale: but there's definitely a fair amount of hand-written c in the high-level dirs
13:16:29 <Cale> mmorrow: So from what I understand, it generates a bunch of possibilities and sees what works out best on the architecture on which it's run.
13:17:14 <mmorrow> it says that there're about "150 pre-generated codelets" in it
13:17:16 <dons> dmwit: i wonder how the numbers look on a platform with an active haskell group (e.g. gentoo or arch), rather than an active ocaml group (debian), too.  from what i can tell, /length/ of time is the main reason packages get used. so the longer you're in the better.
13:17:25 <mmorrow> http://www.fftw.org/fftw-paper-ieee.pdf
13:17:38 <rwbarton> FFTW is over a decade old I believe
13:17:46 <dmwit> dons: Yeah.  It's hard to judge language popularity.
13:17:59 <dmwit> Luckily, I don't use Haskell for its popularity, I use it because it ROCKS. =)
13:17:59 <rwbarton> and many signal processing programs use it as a library
13:18:42 <rwbarton> Probably less than 1% of those 184574 users have even heard of OCaml.  (Yes, I know that's not necessarily the point)
13:18:43 <ddarius> vixey: fmap . fmap
13:19:08 <vixey> :t fmap . fmap
13:19:09 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:19:29 <ozy`> @src (&>)
13:19:30 <lambdabot> Source not found.
13:19:36 <ddarius> :t fmap . fmap :: (a -> b) -> Either () (p -> a) -> Either () (p -> b)
13:19:36 <vixey> interesting
13:19:37 <lambdabot> forall a b p. (a -> b) -> Either () (p -> a) -> Either () (p -> b)
13:20:14 <dmwit> :t fmap fmap fmap :: (a -> b) -> Either () (p -> a) -> Either () (p -> b)
13:20:15 <lambdabot> forall a b p. (a -> b) -> Either () (p -> a) -> Either () (p -> b)
13:20:29 <baaba> @src (->) fmap
13:20:30 <lambdabot> fmap = (.)
13:20:37 <dmwit> :t fmap . (.)
13:20:39 <lambdabot> forall (f :: * -> *) b c a. (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
13:20:41 <Heffalump> mmorrow: I've looked at camp
13:20:41 * ddarius should have FFTW installed and has heard of O'Caml but hasn't directly used FFTW, isn't going to anytime soon, and didn't directly install it.
13:22:09 <okriM> what does "infix 8 ??" do? "??" is a function
13:22:18 <rwbarton> In fact FFTW predates Haskell 98 :)
13:22:19 <athos> :t (??)
13:22:21 <lambdabot> Not in scope: `??'
13:22:24 <athos> :t ??
13:22:25 <lambdabot> parse error on input `??'
13:22:28 <matthewp> rwbarton: people are starting to rediscover OCaml since F# took it as its base for a language, but not actively. I think more people are flocking to Haskell instead
13:22:31 <opqdonut> okriM: it says how `??` should work
13:22:33 <pumpkin> okriM: it tells haskell what operator precedence it should have
13:22:33 <athos> :t ?
13:22:35 <lambdabot> parse error on input `?'
13:22:38 <athos> :[
13:22:38 <pumpkin> and associativity
13:22:42 <pumpkin> l/r
13:23:26 <mmorrow> oleg has some olegian ".. in the absence of ad-hoc manipulation ... increased confidence in our result" type stuff to say about FFTW
13:23:36 <mmorrow> heh
13:23:40 <mmorrow> oh, the link
13:23:41 <mmorrow> http://okmij.org/ftp/Computation/Generative.html#framework
13:24:03 <okriM> what does "8" in this context mean?
13:24:04 <mmorrow> "Unlike FFTW, we know precisely where savings are coming from, and which particular equivalences contribute to which improvements in the code."
13:24:10 <pumpkin> can language-c generate c from an AST too? or just parse it?
13:24:21 <pumpkin> okriM: predence of 8 out of 9
13:24:26 <pumpkin> so pretty high
13:24:46 <mmorrow> pumpkin: it can prettyprint an AST if that's what you mean.
13:24:53 <pumpkin> mmorrow: yeah :)
13:24:54 <pumpkin> cool
13:25:09 <dmwit> okriM: Try ":i +" in ghci, and ":i *" for comparison.
13:26:38 <okriM> ok, but what about the associativity if i've got "infix" and not "infixl"/"infixr"?
13:26:58 <EvilTerran> then it can't be used associatively
13:27:08 <vixey> does anybody know this thing?:   mu alpha, rho  =  i alpha, rho -> alpha  ?
13:27:17 <vixey> what is "i"
13:27:17 <okriM> ah, ok
13:27:20 <EvilTerran> you have to disambiguate one way or t'other with parentheses
13:27:56 <ddarius> vixey: iota you mean? ι?
13:28:14 <vixey> it may be ..
13:28:38 <opqdonut> (. is usually used and not , right?)
13:29:21 <ddarius> opqdonut: That's, presumably, a pairing.  It would make little sense for both mu and i to bind alpha.
13:30:02 <opqdonut> well alpha could be a variable that appears in rho I guess
13:30:12 <mattam> vixey: where are you taking that from?
13:30:22 <opqdonut> but it seems that mu is not the least fixed point type-operator
13:30:33 <ddarius> opqdonut: Why not?
13:30:33 <vixey> Lambda Calculus: A Case for Inductive Definitions
13:30:45 <opqdonut> ddarius: well what
13:30:49 <opqdonut> 's the bound type var?
13:31:09 <dmwit> > True == True == True
13:31:10 <lambdabot>       precedence parsing error
13:31:10 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
13:31:14 <dmwit> > (True == True) == True
13:31:16 <lambdabot>   True
13:31:26 <EvilTerran> i suspect this "i" is some kind of induction-related combinator?
13:31:35 <ddarius> EvilTerran: Likely.
13:31:45 <mattam> i -> forall? Is it not a binder?
13:32:08 <vixey> oh it is defined
13:32:14 <ddarius> vixey: Of course it's defined.
13:32:27 <vixey> i alpha. rho := forall alpha. rho -> alpha
13:32:28 <Guenni> hi, anybody here who used HDBC.ODBC with MS-Access?
13:32:50 <opqdonut> vixey: is the paper any good?
13:32:54 <mattam> bingo!
13:33:01 <ddarius> Seems like a negation unless alpha can be free in rho.
13:33:07 <mmorrow> vixey: there was a comment in a ghc src file (i just looked, can't remember where) that described the view of types they use. i (a while ago) came up with (my own interpretation) of that comment in this fwiw  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=713#a713
13:33:17 <vixey> opqdonut, it is very interesting t ome
13:33:32 <vixey> ddarius, alpha is free in rho yes
13:33:35 <chessguy_work> hm, is there already some typeclass like this? http://hpaste.org/13540
13:33:54 <mmorrow> vixey: i believe though that that code in correct (wrt the defs of those in that elusive ghc comment)
13:34:01 <mmorrow> s/in/is/
13:34:05 <EvilTerran> chessguy_work, well, it could be extended from monoid
13:34:06 <mattam> Hmm, Ralph :)
13:34:29 <EvilTerran> i think
13:34:42 <Heffalump> chessguy_work: not in common use, that I know of
13:34:47 <vixey> mmorrow, and these names are GHC convension?
13:34:53 <EvilTerran> not really similar; never mind
13:35:00 <mmorrow> vixey: i think so, yes.
13:35:04 <Heffalump> it might make some sense to extend from monoid
13:35:06 <chessguy_work> @src Monoid
13:35:06 <lambdabot> class Monoid a where
13:35:06 <lambdabot>     mempty  :: a
13:35:06 <lambdabot>     mappend :: a -> a -> a
13:35:06 <lambdabot>     mconcat :: [a] -> a
13:35:15 <mmorrow> i wish i could remember which file that comment is in.
13:35:34 <mmorrow> (i have hscoloured ghc code + haddocks here:
13:35:35 <mmorrow> http://moonpatio.com/docs/ghc/src/
13:35:39 <mmorrow> http://moonpatio.com/docs/ghc
13:35:40 <mmorrow> )
13:35:52 <EvilTerran> would minBound/maxBound be sufficiently analagous to bottom/top?
13:36:20 <patrikf> hey, I've just started reading http://book.realworldhaskell.org. can anybody explain what's going on with [1.0..1.8] evaluating to [1.0, 2.0]?
13:36:41 <chessguy_work> patrikf, the book explains that
13:36:43 <Heffalump> patrikf: the vagaries of floating point equality
13:36:43 <EvilTerran> regardless, chessguy_work, there's nothing i know of that does that in particular
13:36:51 <chessguy_work> EvilTerran, bummer
13:37:04 <Heffalump> chessguy_work: what would you gain from it existing?
13:37:05 <EvilTerran> > [1.0 .. 1.8] :: [Rational]
13:37:07 <lambdabot>   [1%1,2%1]
13:37:17 <patrikf> chessguy_work: it doesn't, at least not in a way that I would understand it
13:37:19 <EvilTerran> Heffalump, it seems the floats are not to blame
13:37:26 <patrikf> Heffalump: but 1.8 != 2.0
13:37:34 <patrikf> Heffalump: and 2.0 > 1.8
13:37:56 <Heffalump> patrikf: no, but the point is that you can't stop precisely on 1.8
13:38:05 <Heffalump> though EvilTerran's point makes it a bit more confusing
13:38:08 <mmorrow> vixey: yeehaw, i found it. first comment in http://moonpatio.com/docs/ghc/src/TcType.html
13:38:13 <EvilTerran> you'd expect it to stop before, not after
13:38:17 <mmorrow> explains everything thoroughly
13:38:18 <Heffalump> succ (1%1)
13:38:20 <Heffalump> > succ (1%1)
13:38:22 <lambdabot>   2%1
13:38:26 <Heffalump> oh, no it doesn't, for the same reason
13:38:28 <pumpkin> that's no fun
13:38:48 <Heffalump> EvilTerran: this was discussed on some list recently. There was some logic behind what happens now, but I forget what.
13:38:55 <patrikf> Heffalump: but why is [1,5..7] = [1,5] then? I would think it stops before the value gets larger.
13:39:07 <EvilTerran> > [1,1.3,..2] :: [Rational]
13:39:08 <lambdabot>   <no location info>: parse error on input `..'
13:39:13 <EvilTerran> > [1,1.3..2] :: [Rational]
13:39:14 <lambdabot>   [1%1,13%10,8%5,19%10]
13:39:23 <mmorrow> vixey: the comment extracted http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=713#a714
13:39:25 <EvilTerran> and that stops at 1.9
13:40:04 <Heffalump> Hmm. Dunno. I'll stop trying to explain since I obviously have no clue myself :-)
13:40:23 <vixey> it's so complicated mmorrow...
13:42:02 <mmorrow> vixey: everything is until it's not though, right?
13:42:10 <vixey> yeah idk
13:42:14 <mmorrow> heh
13:42:21 <patrikf> EvilTerran: so there's no reasonable explanation for this behaviour really?
13:45:03 <okriM> "hide s = uniform [s{prize=d} | d <- doors]", does this mean, where door=prize, prize gets the value auf s?
13:45:11 <maltem> @src enumFromThenTo
13:45:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:46:11 <mmorrow> patrikf: the fact that Double/whatever is an instance of Enum is pretty dubious of course..
13:46:29 <EvilTerran> patrikf, that seems to be the case, yeah =/
13:46:51 <Elly> fixed-precision doubles are enumerable
13:47:01 <FunctorSalad> @let sane a b c = last [a,b..c] <= c
13:47:03 <lambdabot>  Defined.
13:47:08 <FunctorSalad> @type sane
13:47:10 <lambdabot> forall a. (Enum a, Ord a) => a -> a -> a -> Bool
13:47:12 <mmorrow> Elly: sure, but which way to enumerate them should you choose?
13:47:27 <EvilTerran> Elly, yeah, and their Enum instance acts completely differently to the Rational and floating ones
13:47:34 <EvilTerran> > [0..] :: [Fixed E6]
13:47:35 <lambdabot>       Ambiguous occurrence `Fixed'
13:47:35 <lambdabot>      It could refer to either `Data.Fixed....
13:47:43 <Elly> mmorrow: bitwise, probably :\
13:47:57 <EvilTerran> > [0..] :: [Data.Fixed.Fixed E6]
13:48:00 <mmorrow> > [pi..]
13:48:01 <lambdabot>   [0.000000,0.000001,0.000002,0.000003,0.000004,0.000005,0.000006,0.000007,0....
13:48:03 <lambdabot>   [3.141592653589793,4.141592653589793,5.141592653589793,6.141592653589793,7....
13:48:11 <mmorrow> > [1.0..]
13:48:12 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
13:48:19 <mmorrow> borked!
13:48:20 <Elly> okay, the Data.Fixed.Fixed E6 one made sense
13:48:32 <FunctorSalad> > map (\x -> sane 0 (1 / x :: Rational) 1)  [1..20]
13:48:34 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
13:48:35 <Elly> and the behavior for [1.0..] might be what most people expect
13:48:35 <mmorrow> ohhh, _fixed_
13:48:43 <FunctorSalad> hmm?
13:48:47 <patrikf> the [pi..] is quite weird
13:48:59 <EvilTerran> Elly, it's what people expect, but it doesn't really fit the class specification
13:49:15 <pumpkin> I don't really like the Enum instance for Double
13:49:18 <mmorrow> patrikf: personally i wouldn't use [n..] with Double/Floats
13:49:32 <pejo> okriM, s is a record, the field prize gets set to d and the other values of  the fields of s are retained. But "uniform" does something with it.
13:49:33 <mmorrow> s/wouldn't/don't/
13:49:36 <pumpkin> > fromEnum 5 :: Double
13:49:37 <lambdabot>   Couldn't match expected type `Double' against inferred type `Int'
13:49:39 <EvilTerran> personally, i wouldn't use Double/Floats :P
13:49:44 <pumpkin> > toEnum 5 :: Double
13:49:45 <lambdabot>   5.0
13:49:45 <FunctorSalad> > map (\x -> sane 1 (1 + 1 / x :: Rational) 1)  [1..20]
13:49:47 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
13:49:49 <mmorrow> EvilTerran: why not?
13:49:59 <FunctorSalad> so the weirdness is only if you don't give the step size?
13:50:04 <EvilTerran> mmorrow, well, i'd consider other options first
13:50:18 <mmorrow> what about for numerical analysis?
13:50:33 <pumpkin> > [5.0,5.2..]
13:50:34 <lambdabot>   [5.0,5.2,5.4,5.6000000000000005,5.800000000000001,6.000000000000001,6.20000...
13:50:40 <maltem> pumpkin: looks like fromEnum = floor :: Double -> Int
13:50:41 <EvilTerran> you're talking to someone who doesn't do numerical analysis
13:50:43 <pumpkin> see, that's just weird
13:50:46 <pshc_> Bah, HSCurses doesn't have instr...
13:50:49 <mmorrow> EvilTerran: clearly :)
13:50:53 <pumpkin> > fromEnum 5.2
13:50:54 <lambdabot>   5
13:51:04 <EvilTerran> mmorrow, i said "*I* wouldn't use Double/Floats" - other people might need 'em, though :P
13:51:10 <pumpkin> yeah, I really don't like the Enum on Double :P
13:51:22 <mmorrow> EvilTerran: hehe, i hear you, just messing around :)
13:51:35 <EvilTerran> k :)
13:52:23 <EvilTerran> > map fromEnum (iterate succ 0 :: [Fixed E6])
13:52:24 <lambdabot>       Ambiguous occurrence `Fixed'
13:52:24 <lambdabot>      It could refer to either `Data.Fixed....
13:52:32 <EvilTerran> > map fromEnum (iterate succ 0 :: [Data.Fixed.Fixed E6])
13:52:33 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:53:12 <EvilTerran> "It could refer to either `Data.Fixed.Fixed', imported from Data.Fixed; or `Test.QuickCheck.Fixed', imported from Test.QuickCheck; or `Data.Number.Fixed.Fixed', imported from Data.Number.Fixed"
13:53:22 <EvilTerran> the first and the last of those really shouldn't be clashing
13:54:07 <maltem> ah I finally found the definition that is relevant for the behaviour of instance Enum Double. Namely, it's GHC.Real.numericEnumFrom*
13:54:55 <pumpkin> maltem: kill it with fire!
13:55:41 <wchogg> ?
13:57:21 <okriM> <pejo> okriM, s is a record, the field prize gets set to d and the other values of  the fields of s are retained. <- can you explain what "[s{prize=d}|" does?
13:57:39 <mmorrow> > let oo = toInteger (ceiling (1/0::Double)) in oo < oo+1
13:57:40 <lambdabot>   True
13:57:52 <EvilTerran> > 0 :: Data.Number.Fixed.Fixed (EpsDiv10 (EpsDiv10 (EpsDiv10 Eps1)))
13:57:53 <lambdabot>   0.000
13:57:55 <EvilTerran> nifty
13:58:05 <mmorrow> hmm
13:58:17 <EvilTerran> > 0 :: Data.Number.Fixed.Fixed Prec10
13:58:17 <lambdabot>   0.0000000000
13:58:33 <mmorrow> where is Data.Numer.Fixed?
13:58:42 <EvilTerran> ?hackage numbers
13:58:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
13:58:44 <mmorrow> is that the one on hackage by edwardk?
13:58:57 <mmorrow> ohhh, that one. ok
13:59:34 <EvilTerran> wrong button, evidently
13:59:40 <EvilTerran> <.<  >.>
13:59:50 * mmorrow hates when that happens
13:59:52 <maltem> [1,5..7] = [1,5,9] because 5 and 9 have equal distance to 7!!!
14:00:01 <EvilTerran> maltem, wait what?
14:00:09 <maltem> well I think so
14:00:13 <vixey> maltem, lol
14:00:14 <EvilTerran> > ([1,5..6], [1,5..8])
14:00:15 <lambdabot>   ([1,5],[1,5])
14:00:21 <EvilTerran> > [1,5..7]
14:00:23 <lambdabot>   [1,5]
14:00:37 <maltem> > [1,5..7] :: Double
14:00:39 <lambdabot>   Couldn't match expected type `Double' against inferred type `[a]'
14:00:44 <maltem> > [1,5..7] :: [Double]
14:00:46 <lambdabot>   [1.0,5.0,9.0]
14:00:51 <maltem> > [1,5..6] :: [Double]
14:00:53 <lambdabot>   [1.0,5.0]
14:00:53 <mmorrow> it's since 7<5+4
14:01:00 <maltem> > [1,5..8] :: [Double]
14:01:02 <lambdabot>   [1.0,5.0,9.0]
14:01:05 <wjt> @index isDigit
14:01:06 <lambdabot> Data.Char
14:01:07 <EvilTerran> that's weird
14:01:12 <mmorrow> hmm
14:01:18 <maltem> It's rounding as in round :)
14:01:19 <chessguy_work> heh
14:01:20 <mmorrow> looks broken
14:01:28 <chessguy_work> @src round
14:01:28 <lambdabot> Source not found. You type like i drive.
14:01:40 <mmorrow> more reason not to use Enum Double
14:01:46 <redditbot> Enfranchised Mind &raquo; The problem with STM: your languages still suck (hint: he's not talking about Haskell :)
14:01:55 <EvilTerran> > [(i,[0 :: Double, 5 .. i]) | i <- [10..15]]
14:01:56 <lambdabot>   [(10.0,[0.0,5.0,10.0]),(11.0,[0.0,5.0,10.0]),(12.0,[0.0,5.0,10.0]),(13.0,[0...
14:01:56 <maltem> numericEnumFromThenTo actually computes mid = (5 - 1)/2
14:02:03 <EvilTerran> > [(i,[0 :: Double, 5 .. i]) | i <- [13..15]]
14:02:05 <lambdabot>   [(13.0,[0.0,5.0,10.0,15.0]),(14.0,[0.0,5.0,10.0,15.0]),(15.0,[0.0,5.0,10.0,...
14:02:06 <wjt> @index getArgs
14:02:07 <lambdabot> System.Environment
14:02:17 <michaelcdever> if i wanted to read in the whole contents of a text file, for searching, that'd be very inefficient wouldn't it, ideally, i should read in the file until the expression im matching has been found?, but there doesnt seem to be a method for just reading the next token in a file
14:02:21 <EvilTerran> ... it's using round. :O
14:02:35 <maltem> Well not explicitly
14:02:57 <EvilTerran> > map fromEnum [-1,-0.9 .. 1]
14:02:58 <lambdabot>   [-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:02:59 <maltem> It the compares 9 <= 7 + mid
14:03:09 <maltem> which is true, so 9 goes in
14:03:17 <EvilTerran> ah, it computes mid explicitly
14:03:21 <EvilTerran> that's even weirder
14:03:29 <maltem> very true :)
14:04:06 <michaelcdever> i could use ByteString, or ByteString.Lazy, for "on the fly" searching, but you need to know the size of what you're reading
14:04:37 <maltem> EvilTerran: Now guess what the comment above that declaration says
14:04:45 <maltem> "These 'numeric' enumerations come straight from the Report"
14:04:54 <sjanssen> michaelcdever: lazy ByteString will come close to what you want
14:04:59 <Heffalump> a lazy bytestring that you've just grabbed from a file with readFile/getContents will be read in piece by piece
14:05:05 <bohdan> @hoogle replicateM
14:05:05 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
14:05:05 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
14:05:06 <sjanssen> michaelcdever: it will read a bit extra from the file, but not too much
14:05:06 <wjt> writing small shell scripts in Haskell instead: slower, but they work first time
14:05:43 <michaelcdever> sjanssen: but from what i see you need to know the size for what your taking, i.e. the number of bytes
14:06:34 <mmorrow> @hoogle Handle -> Int -> IO ByteString
14:06:34 <lambdabot> Data.ByteString hGet :: Handle -> Int -> IO ByteString
14:06:35 <lambdabot> Data.ByteString hGetNonBlocking :: Handle -> Int -> IO ByteString
14:06:35 <lambdabot> Data.ByteString.Char8 hGet :: Handle -> Int -> IO ByteString
14:07:14 <mmorrow> @hoogle Handle -> Ptr Word8 -> Int -> IO Int
14:07:15 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
14:07:15 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
14:07:15 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
14:07:21 * maltem thinks that if [a,b..c] would mean to exclude c, the instance Enum Double would be slightly less annoying
14:07:33 <michaelcdever> it takes an Int (representing the number of bytes to be read) and returns a ByteString
14:07:42 <mmorrow> yes
14:07:54 <Heffalump> michaelcdever: use hGetContents or readFile
14:07:54 <michaelcdever> but i dont know the size :D
14:08:14 <michaelcdever> thats what i was thinking heffalump, but thats inefficient
14:08:17 <mmorrow> michaelcdever: well, you'd read a chunk at a time
14:08:20 <Heffalump> michaelcdever: why?
14:08:22 <mmorrow> what do you have in mind?
14:08:56 <michaelcdever> because im searching to match an expression, (regex), so ideally, you'd open the file and keep searching until you find the word, then stop
14:09:15 <michaelcdever> if you do it with hGetContents or readFile, that reads in the whole file
14:09:16 <bohdan> @pl \f [a,b] -> f a b
14:09:17 <lambdabot> (line 1, column 4):
14:09:17 <lambdabot> unexpected "["
14:09:17 <lambdabot> expecting operator, pattern or "->"
14:09:23 <maltem> michaelcdever: no it won't
14:09:30 <Heffalump> michaelcdever: no, it'll be read in lazily
14:09:33 <bohdan> @pl \f [a:b] -> f a b
14:09:33 <lambdabot> (line 1, column 4):
14:09:33 <lambdabot> unexpected "["
14:09:33 <lambdabot> expecting operator, pattern or "->"
14:09:43 <Heffalump> though make sure you don't use the result twice, or it'll sit in memory from the first time
14:09:55 <tristes_tigres> GpuGen ! http://www.galois.com/blog/2008/08/29/gpugen-bringing-the-power-of-gpus-into-the-haskell-world/
14:10:13 <bohdan> what's up with @pl?
14:10:20 * tristes_tigres wonders what't the status of that project
14:10:20 <bohdan> @pl \f (a:b:[]) -> f a b
14:10:21 <lambdabot> (line 1, column 9):
14:10:21 <maltem> michaelcdever: lazy IO may have stupid and crazy semantics, but it's just what you want in this case
14:10:21 <lambdabot> unexpected "["
14:10:21 <lambdabot> expecting "()", natural, identifier, "_" or "("
14:10:32 <bohdan> @pl \f (a:b:_) -> f a b
14:10:32 <lambdabot> (`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .)) .)
14:10:35 <michaelcdever> if i do, say, contents <- readFile  puts a string representation of the whole file into contents?
14:10:44 <dons> michaelcdever: using which readFile?
14:10:46 <mmorrow> let go h doesMatch = do s <- hGet h bufSize ; if doesMatch then return True else go h doesMatch
14:10:59 <mmorrow> bracket (acquire Handle) (hClose)
14:11:15 <mmorrow> michaelcdever: not the lazy one
14:11:18 <dons> if you use [Char], no, it will lazily read one byte at a time. if you use ByteString.Lazy : no, it will read 4k at a time. if you use strict bytestrings: yes, it will read the whole thing in right then.
14:11:34 <michaelcdever> so confusing lol
14:11:46 <michaelcdever> i might just read in the whole thing, i know how to deal with that!
14:11:49 <Heffalump> Haskell is a very data-driven language
14:12:03 <dons> michaelcdever: its the same code you'd write to use the strict or lazy one
14:12:07 <maltem> tristes_tigres: since you mention it, any news on GpuGen development? Or dons, maybe?
14:12:08 <dons> but    the lazy one will run in constant space..
14:12:11 <dons> so you decide :)
14:13:02 <tristes_tigres> maltem: I just learned of that project today
14:13:09 <michaelcdever> im completly lost! lol
14:13:11 <eu-prleu-peupeu> hello H4skleZ0rs
14:13:35 <eu-prleu-peupeu> wow 615 H4askleZ0rs!!!
14:13:45 <eu-prleu-peupeu> thats like... a lot!
14:14:09 <maltem> michaelcdever: hey who of us did that?
14:14:16 <michaelcdever> don: thats using ByteString yes?
14:14:17 <dons> eu-prleu-peupeu: yeah, we win!
14:14:23 <eu-prleu-peupeu> allright!!
14:14:31 <maltem> @users
14:14:32 <dons> michaelcdever: use Data.ByteString.Lazy for lazy bytestring io, yes.
14:14:32 <lambdabot> Maximum users seen in #haskell: 618, currently: 615 (99.5%), active: 30 (4.9%)
14:14:39 <dmwit> ?elite wow 615 Haskellors!!!
14:14:39 <lambdabot> \/\/ow 615 |-|azk31l0r5!!!
14:14:55 <michaelcdever> dons: but you need an int for the amount of bytes you want to read?
14:14:58 <dons> an auspicious start to the year.
14:15:04 <dons> michaelcdever: no, not for lazy things
14:15:11 <dons> it'll read as much as the consuming functions require
14:15:17 <dons> laziness works like that :)
14:15:21 <michaelcdever> ok, right, ill give it a crack so
14:15:36 <tristes_tigres> GpuGen looks like a cool thing to have, if it is opensource
14:15:44 <michaelcdever> dons: malterm: thanks lads!
14:15:57 <bohdan> what's the convention for 'print "\n"' ? putStrLn "" ?
14:16:04 <dons> putChar '\n' ?
14:16:07 <maltem> tristes_tigres: the slides mention the idea of integrating it into dph
14:16:24 <maltem> which would be _really_ cool
14:16:30 <bohdan> dons, does that print \r\n on strange platforms? :)
14:16:57 <dmwit> yep
14:17:07 <tristes_tigres> maltem: but no project site that I could find, nor any status updates since august
14:17:11 <mmorrow> michaelcdever: so the lazy bytestring one is really just reading (4*1024) byte (or whatever) chunks at a time for you
14:17:12 <dmwit> ?src putStrLn
14:17:13 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
14:17:19 <dons> tristes_tigres: a paper about  the project is about to be released.
14:17:20 <dmwit> bohdan: ^^
14:17:26 <maltem> tristes_tigres: yeah that's why I was asking :-/
14:17:29 <dons> ?users
14:17:30 <lambdabot> Maximum users seen in #haskell: 619, currently: 619 (100.0%), active: 29 (4.7%)
14:17:35 <maltem> dons: ah enlightening!
14:17:42 <dons> i wonder why today was the day we were going to smash the record.
14:18:06 <mmorrow> @src hGetLine
14:18:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:18:17 <dons> hGetLine is non-trivial
14:18:17 <tristes_tigres> dons: a paper is nice, but ehat about some actual code ?
14:18:26 <dons> tristes_tigres: i'm sure code will accompany it
14:18:28 <bohdan> > "thanks" -- dons, dmwit
14:18:29 <lambdabot>   "thanks"
14:18:30 <michaelcdever> mmorrow: so i would just do DBL.take 1 content?
14:18:34 <mmorrow> dons: heh, yeah
14:19:03 <mmorrow> michaelcdever: um, if you want the first byte, yes
14:19:13 <michaelcdever> ahhhhhh lol
14:19:33 <mathijs> Hi all, as an exercise, I'm trying to create a point-free function that acts like (:), but usable in foldl. I'm a bit stuck... please look at http://hpaste.org/13541
14:19:57 <michaelcdever> stuff it, im going to go with the easy consuming way for now, ill come back later
14:20:02 <mmorrow> @pl \x y -> x ++ [y]
14:20:02 <lambdabot> (. return) . (++)
14:20:04 <michaelcdever> to this if i havve time
14:20:17 <mmorrow> @src return []
14:20:17 <lambdabot> Source not found. Do you think like you type?
14:20:20 <mmorrow> @src [] return
14:20:20 <lambdabot> return x    = [x]
14:20:31 <dmwit> :t flip (.) (:[]) . (++)
14:20:32 <eu-prleu-peupeu> windones is really boring to do some haskle dev :/
14:20:33 <lambdabot> forall a. [a] -> a -> [a]
14:20:34 <mmorrow> (. (:[])) . (++)
14:20:38 <dmwit> mathijs: See also:
14:20:43 <dmwit> ?pl \x y -> x ++ [y]
14:20:43 <lambdabot> (. return) . (++)
14:20:45 <mathijs> mmorrow: ah... that sounds easy :) ... but how about not using return?
14:20:49 <tristes_tigres> dons: looking forward to it, and I am sure am not the only one
14:21:05 <michaelcdever> ahhh, L.readFile path, right, so that reads the file lazily, but i still need to know the size of what im going to read...
14:21:08 <mmorrow> mathijs: you can replace return with (:[])
14:21:24 <Heffalump> michaelcdever: why?
14:21:32 <ddarius> dons: Perhaps a bunch of programmers decided to make learning Haskell their New Year's resolution.
14:21:34 <dmwit> mathijs: But this function is *slow*.
14:21:35 <bohdan> mathijs, why not use foldr (:) ?
14:21:41 <mmorrow> michaelcdever: what is the function you have that's like (ByteString -> True)
14:21:52 <dmwit> mathijs: If you really want this, use reverse and foldr, or use DiffLists or some such thing that supports a fast snoc.
14:21:53 <mathijs> cool, thanks... and @pl or ?pl on lambdabot == try to create point free notation?
14:22:03 <mmorrow> @pl \x -> x
14:22:03 <lambdabot> id
14:22:04 <dmwit> yes
14:22:20 <mathijs> dmwit: I know it's slow, I'm not gonna use it, just exercising with point free and stuff like that
14:22:23 <michaelcdever> beacuse i need to take from the the contents, i.e. L.take Int
14:22:51 <bohdan> > foldl (\a b -> a ++ [b]) [] [1..5] == foldr (:) [] [1..5]
14:22:51 <mmorrow> michaelcdever: but what is the type of the function you're going to feed that to?
14:22:52 <lambdabot>   True
14:23:13 <dmwit> michaelcdever: Just use it as if it's all available.  Any time something isn't available, it will be read from disk for you.
14:23:25 <Heffalump> and just check that you haven't got to the end
14:24:07 <tristes_tigres> bohdan : What ? lambdabot thinks functions are instance of Eq ?
14:24:29 <dmwit> tristes_tigres: definitely not
14:24:46 <dmwit> tristes_tigres: [Int] certainly is, though
14:24:48 <michaelcdever> ahhh... ok cool, i can do L.split ' ' which will break the content into seperate tokens
14:25:02 <mmorrow> or just L.words :)
14:25:10 <dons> well, welcome everyone. be sure to familiarise yourself with haskell.org, cabal, hackage.haskell.org and code.haskell.org. news on planet.haskell.org and reddit.com/r/haskell :)
14:25:17 <michaelcdever> mmorrow: lol, thanks
14:25:25 <tristes_tigres> dmwit : yes, I see. Still, might be a cool feature
14:25:26 <pumpkin> wow, how did we get another 20 users so quickly?
14:25:33 <michaelcdever> thanks everyone, sorry for my idiotness :D
14:25:42 <bohdan> dons, that's what topic should say | already says :)
14:25:47 <dons> hehe
14:25:48 <dmwit> tristes_tigres: That is not a decidable feature.
14:26:00 <eu-prleu-peupeu> i have lots of ideas for crazy haskle projects, but no spare time to work on them :/
14:26:05 <tristes_tigres> dmwit : forall n. exists x y z. x^n+y^n == z^n
14:26:27 <pumpkin> :o
14:26:43 * pumpkin scribbles something in his margin
14:27:14 <dmwit> More interesting: forall n. exists y x_1 ... x_n. \sum_{i=1}^n x_i^n == y^n
14:27:39 <tristes_tigres> it could have the reult type True | False | Couldn_t_ Decide
14:27:44 <pumpkin> HasTeX
14:28:16 <tristes_tigres> dmwit: you think the great Fermat's theorem not interesting enough ?
14:28:17 <eu-prleu-peupeu> now i will try to run the windones genuine advantage on my pirated copy
14:28:17 * ski_ . o O ( `data Bool = True | False | EOF' )
14:28:40 <CakeProphet> eu-prleu-peupeu:  write a Haskell interpreter.
14:28:42 <dmwit> FileNotFound
14:28:52 <dmwit> ski_ fails at meme
14:29:01 <eu-prleu-peupeu> CakeProphet: a haskle interpreter ? but... why ? ghci doesn't work ?
14:29:07 * ski_ stands corrected
14:29:08 * mpwd__ . o O (`data Bool = True | False | undefine')
14:29:12 <mpwd__> :P
14:29:26 <CakeProphet> eu-prleu-peupeu:  add a language extension to it. gotos or something.
14:29:27 <eu-prleu-peupeu> CakeProphet: is your nick from the cakePhp ?
14:29:33 <CakeProphet> call it "Haskell with gotos"
14:29:33 <pumpkin> CakeProphet: lol
14:29:38 <eu-prleu-peupeu> yeh
14:29:41 <CakeProphet> ...probably not. Since I don't know what cakePhp is
14:29:42 <eu-prleu-peupeu> gotos would be nice
14:29:48 <dmwit> comefrom
14:29:48 <pumpkin> GotoH'ell
14:29:53 <CakeProphet> gotos would be terrible, and wouldn't even work correctly
14:29:59 <CakeProphet> come from would be equally terrible, but cooler
14:30:06 <mpwd__> CakeProphet: We should first compose a typed lambda calculus with gotos.
14:30:06 <dons> oh, their just a funny kind of continuation :)
14:30:12 <tromp_> we have something like goto.... continuations
14:30:12 <dons> and who's afraid of continuations? :)
14:30:29 <eu-prleu-peupeu> yeahh
14:30:31 * CakeProphet has thought of language designs for a "purely imperitive" language, where all higher-level constructs are based on goto and come from
14:30:33 <eu-prleu-peupeu> continuations would be great!
14:30:41 <eu-prleu-peupeu> to shut the mouth of those darn little schemers
14:30:42 <ski_> shift,reset ftw !
14:30:49 <dons> eu-prleu-peupeu: they're in the mtl library
14:30:56 <eu-prleu-peupeu> and runtime syntatic tree manipulation would also
14:30:58 <eu-prleu-peupeu> really ?
14:31:04 <dons> runtime syntactic tree: see TH.
14:31:05 <eu-prleu-peupeu> in the form of the state monad ?
14:31:11 <dons> in the form of the continuation monad
14:31:14 <eu-prleu-peupeu> oh
14:31:15 <eu-prleu-peupeu> lol
14:31:18 <dons> :t callcc
14:31:19 <lambdabot> Not in scope: `callcc'
14:31:20 <eu-prleu-peupeu> thats odd :)
14:31:25 <dons> :t Control.Monad.Cont.callCC
14:31:26 <ski_> @type callCC
14:31:27 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:31:28 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:31:50 <dons> you don't need language support for continuations when you've got enough other good stuff.
14:31:51 <CakeProphet> that's a beast of a type.
14:31:57 <dons> ((a -> m b) -> m a) -> m a
14:32:05 <dons> is the guts of it.
14:32:20 <wchogg> How often do people actually use continuations in Haskell?  I never have, but that doesn't mean a thing.
14:32:28 <tristes_tigres> eu-prleu-peupeu: isn't  runtime syntatic tree manipulation already implemented through GHC API ?
14:32:42 * ski_ used continuations for turtle graphics
14:32:50 <eu-prleu-peupeu> i usually just skip all the part before the => in the type definition and go straight to the deal :P
14:32:51 * tristes_tigres looked once at GHC API an run away in terror
14:33:04 <ddarius> wchogg: Semantically, there's rarely a reason to.
14:33:15 <Twey> CakeProphet: Nah, it isn't
14:33:15 <eu-prleu-peupeu> oh
14:33:40 <eu-prleu-peupeu> today i was wondering about the future OpenCL implementation in haskell, and its possible uses on the Reactive module
14:33:43 <CakeProphet> Twey:  I'm sure it's not once you get it. But just looking at it I can't even imagine what it does.
14:33:49 <dons> someone wants a haskell question answerred, http://www.reddit.com/r/programming/comments/7n1eg/can_someone_show_me_how_to_port_this_snippet_of/
14:33:51 <CakeProphet> nothing is complicated once it makes sense.
14:34:06 <pumpkin> dons: lol
14:34:11 <pumpkin> funny
14:34:50 <Badger> oh dear
14:34:51 <eu-prleu-peupeu> (i just love when my pirated windows passes the genuine advantage test)
14:34:54 <Twey> CakeProphet: You should see some of the Gtk2Hs types
14:35:05 <dons> eu-prleu-peupeu: prob OT here, thanks. but ask a haskell question!
14:35:13 <eu-prleu-peupeu> okey
14:35:20 <CakeProphet> Twey:  functions that take functions that take functions that take functions as arguments?
14:35:33 <pumpkin> eu-prleu-peupeu: to get the quickest and most accurate response to your haskell question, prepend @faq onto it
14:35:39 <eu-prleu-peupeu> ahah
14:35:43 <eu-prleu-peupeu> @faq you ?
14:35:43 <lambdabot> The answer is: Yes! Haskell can do that.
14:35:53 <pumpkin> :)
14:36:07 <wchogg> pumpkin : the whole purpose of the lambda faq is to try and come up with the most unnerving questions for it possible
14:36:08 <pumpkin> @faq can Haskell do that?
14:36:08 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:21 <CakeProphet> @faw can Haskell goto?
14:36:21 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:24 <pumpkin> @faq really? _that_?
14:36:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:25 <Heffalump> @faq can Haskell solve the halting problem?
14:36:26 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:43 <Twey> CakeProphet: xmlGetWidget :: (Graphics.UI.Gtk.Types.WidgetClass widget) => GladeXML -> (System.Glib.Types.GObject -> widget) -> String -> IO widget
14:36:44 <Gilly> @faq can h
14:36:44 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:46 <pumpkin> that's reassuring
14:36:47 <eu-prleu-peupeu> hey, my dream haskell project is like, a imagelib purelly functional, that reads/writes jpegs/pngs/gifs, and can generate procedural stuff on them
14:36:52 * maltem again read about the idea of declaring multiple modules in one file and again whishes for that to be possible
14:36:52 <Gilly> askell fix lambdabot's @faq
14:36:56 <CakeProphet> Twey:  eeeeew
14:37:03 <Heffalump> eu-prleu-peupeu: like Pan?
14:37:04 <eu-prleu-peupeu> @faq can haskell make coffee ?
14:37:04 <lambdabot> The answer is: Yes! Haskell can do that.
14:37:12 <eu-prleu-peupeu> Heffalump: i dont know pan
14:37:13 <pumpkin> @faq can haskell do what eu-prleu-peupeu wants, down to the very last character?
14:37:14 <lambdabot> The answer is: Yes! Haskell can do that.
14:37:17 <Twey> That's not as bad as I remember, actually :-P
14:37:20 <pumpkin> wchogg: orly?
14:37:23 <Heffalump> eu-prleu-peupeu: you should read Conal Elliott's stuff. It's all really cool.
14:37:23 <wchogg> @faq Can Haskell make me stop feeling sick & wrong whenever I look in the mirror?
14:37:24 <lambdabot> The answer is: Yes! Haskell can do that.
14:37:33 <Heffalump> One of his projects is functional image generation/manipulation.
14:37:33 <tristes_tigres> @vixen19 can haskell do you ?
14:37:34 <lambdabot> Ooh, functional programmers are so hot!
14:37:49 <Twey> wchogg: That's a side effect of Java :)
14:37:52 <sevenTwo> @faq can haskell beat pokemon red?
14:37:53 <lambdabot> The answer is: Yes! Haskell can do that.
14:37:53 <SamB_XP> tristes_tigres: why the 19 ?
14:37:54 <CakeProphet> Twey:  the different there though is I can sort of figure out what that function does, because of all the non-abstract types and such.
14:38:14 <eu-prleu-peupeu> Heffalump: i just finished reading the FRP paper today, it was quite dense...
14:38:17 <tristes_tigres> SamB_XP: I don't know - both hot and legal ?
14:38:25 <eu-prleu-peupeu> now im going to jump to the GUI paper he wrote
14:39:03 <eu-prleu-peupeu> sideways im looking down at the HAppS code, and thinking about some improvements to it
14:39:11 * Heffalump requests optimisation tips for http://hpaste.org/13542 as it's showing up as a profiling hotspot. Treat Expr/ePlus/eInteger as abstract, they're not a bottleneck in themselves.
14:39:29 <Heffalump> eu-prleu-peupeu: take a look at "Functional Images"
14:39:32 <sevenTwo> @faq can haskell help me get a girlfriend?
14:39:33 <lambdabot> The answer is: Yes! Haskell can do that.
14:39:41 <sevenTwo> then do it..
14:39:55 <Heffalump> sevenTwo: it can do it, but you'll have to write the code yourself
14:40:11 <tristes_tigres> sevenTwo : implement askOut :: Maybe Date
14:40:27 <sevenTwo> :P
14:40:45 <wchogg> askOut = mzero
14:40:58 <tristes_tigres> Data HotGirls = (Monght m) => PlayboyBunny m
14:41:49 <CakeProphet> Heffalump:  out of curiousity, why do you give each guard identical patterns?
14:41:57 <CakeProphet> I doubt it's slowing anything down though.
14:42:14 <Heffalump> carelessness
14:42:16 <eu-prleu-peupeu> sevenTwo: when you get to Portugal give me a call, ill introduce you to some crazy people :)
14:42:55 <wchogg> Oh crap...#haskell has hit critical mass.  People are using it to hook-up.
14:42:56 <CakeProphet> :t toList
14:42:58 <lambdabot> Not in scope: `toList'
14:43:09 <Heffalump> :t Data.Map.toList
14:43:10 <lambdabot> forall k a. M.Map k a -> [(k, a)]
14:43:13 <eu-prleu-peupeu> hey Heffalump, these functional images seem great, i was thinking more about implementing perlin noise, and others proc. generation techniques
14:43:14 <tristes_tigres> wchdog: they can't - no girls here
14:43:39 <khatar> hello world
14:43:50 <CakeProphet> Heffalump:  why the Map.toList... doesn't that just give you the same Map?
14:44:00 <Heffalump> errm, it gives me a list from the Map
14:44:15 <ski_> (tristes_tigres : not true ..)
14:44:22 <CakeProphet> toList gives you a list from the Map... and the Map takes the list and does what to it?
14:44:24 <CakeProphet> :t Map
14:44:25 <lambdabot> Not in scope: data constructor `Map'
14:44:30 <CakeProphet> :t Data.Map.Map
14:44:31 <lambdabot> Not in scope: data constructor `Data.Map.Map'
14:44:37 <tristes_tigres> ski_: Oh yeah ? Show me one !
14:44:38 <Heffalump> Map.foo is foo from the module Map
14:44:39 <CakeProphet> :t Data.Map
14:44:41 <lambdabot> Couldn't find qualified module.
14:44:43 <Heffalump> I've imported Data.Map qualified as Map
14:44:51 <CakeProphet> oh
14:44:53 <CakeProphet> ...
14:44:55 <CakeProphet> -facepalm-
14:45:08 <CakeProphet> I see that now based on how you spaced the dots.
14:45:15 <Heffalump> the confusion between qualification and composition is rather a wart
14:45:22 <ski_> (tristes_tigres : i'll let them present themselves, should they really care to)
14:45:24 <Heffalump> but yes, spacing conventions help a lot
14:45:48 <tristes_tigres> ski_: thus proving my point
14:45:52 <ddarius> "Recursion is an invention of logic, not mathematics.  Real programmers don't write Pascal, and real mathematicians don't recurse.  Neither do many logicians nowadays, and computer science has become the last refuge of recursion.  The writing is on the wall for recursion."
14:46:12 <CakeProphet> Heffalump:  maybe it's just all the recursion. Isn't there a way to recurse over the Map rather than turning it into a list?
14:46:14 <ski_> tristes_tigres : no, neither proving nor disproving your point. absense of disproof is not proof
14:46:28 <Heffalump> I guess I could use a fold
14:46:29 <eu-prleu-peupeu> hey the windows powershell is actually not very bad!
14:46:37 <tristes_tigres> ski_: OK, demonstrating its undecidability
14:46:38 <eu-prleu-peupeu> and miles away better than the command prompt :P
14:46:40 <Heffalump> actually, I'm a fool, I should have compiled with optimisations first before complaining about hotspots
14:46:47 <eu-prleu-peupeu> i guess it makes coding haskell in windows practical
14:47:01 <CakeProphet> Heffalump:  if you have a large map, it has to traverse it twice... once to turn it into the list, and again to go through your function.  -shrug- dunno if that's why it's a bottleneck or not.
14:47:12 <Heffalump> well, it can't help the constant factor
14:47:24 <ski_> tristes_tigres : no, there hasn't been presented a proof of its purported undecidability, either. that's also absent
14:48:02 <CakeProphet> Heffalump:  though technically... since Haskell is Lazy... and doesn't do one and then the other, it unravels the map one at a time as your function runs.
14:48:07 <CakeProphet> but yeah
14:48:16 <Heffalump> but it makes and destroys cons cells
14:48:22 <CakeProphet> -nods- right.
14:48:24 <Heffalump> quite a bit if n is >1 or <-1 (though that should be rare)
14:48:44 <dons> eu-prleu-peupeu: what did you mean 'makes haskell on windows practical'?
14:48:48 <ddarius> "To iterate is illiterate.  To recurse is worse.  To avoid this trap see / Instructions for mapc."
14:48:49 <ski_> (tristes_tigres : finally, i don't really see why this matters to the discussion of haskell .. so i'll stop responding now)
14:48:50 <Heffalump> but the recursion pattern also makes it non-trivial to turn into a fold
14:49:07 <CakeProphet> @src Data.Map.toList
14:49:08 <lambdabot> Source not found. Sorry.
14:49:19 <Heffalump> anyone else use type families? Is it my imagination or does ghc slow right down when type checking them?
14:49:40 <doserj> Heffalump: can you do something like (`ePlus` (eInteger n `eTimes` x), instead of adding the x n times?
14:49:50 <mercury^> Is there a way to have a filter in a parallel list comprehension applied so that all lists drop the element if the condition is not satisfied?
14:49:52 <vixey> bizarre ddarius
14:50:03 <mmorrow> Heffalump: maybe this? http://hpaste.org/13542#a1
14:50:03 <Heffalump> doserj: I don't have an eTimes. I could add one but I don't really want to as I think it'll be rare and it just complicates everything else.
14:50:06 <dons> Heffalump: i've seen that
14:50:52 <Heffalump> mmorrow: why would you expect that to make a difference? Just CPS being inherently faster in some sense?
14:51:54 <ddarius> mercury^: Don't use parallel list comprehensions.
14:51:54 <mmorrow> Heffalump: i'm not sure, but cps'ing the State monad seemed to magically make it twice as fast (although i'm not sure if it'd help in this case)
14:52:05 <mercury^> ddarius: what is the good way to do it then?
14:52:09 <dons> some of the CPS transforms of monad stacks seem to optimise better
14:52:14 <Heffalump> ok, I'll give it a go
14:52:18 <idanKING> Got 3 digit steam account [] pme with good offer
14:52:21 <dons> i've not looked at why, but there's a good amount of anecdotal evidence
14:52:26 <eu-prleu-peupeu> dons: well its a pain to do whatever you want to do on the windows command prompt...
14:52:26 --- mode: ChanServ set +o dons
14:52:28 <ddarius> mercury^: Use zip.
14:52:28 --- mode: dons set +b *!*=idanKING@77.126.71.*
14:52:28 --- kick: idanKING was kicked by dons (dons)
14:52:33 --- mode: ChanServ set -o dons
14:52:36 <mmorrow> Heffalump: i think with the State monad, it had to do with how the non-cps version constantly is deconstructing the (,) just to reconstruct it in (>>=)
14:52:40 <tristes_tigres> dons: where the paper about GpuGen is going to appear ?
14:52:47 <dons> tristes_tigres: DAMP 2009, iirc
14:53:38 <Nafai> dons: Even though I've read much of it online, I'm really appreciating RWH in the dead trees version.  It's helping me grasp some things better.
14:53:45 <ddarius> dons: There's a paper on some aspects of it, and there are some obvious benefits.
14:53:57 <eu-prleu-peupeu> specially with the 80 column limit of it...
14:54:19 <eu-prleu-peupeu> my haskell code tend to exceed 80 columns :/ but thats probably my fault
14:54:33 <ski_> (mmorrow : barring fusion, `(***)' would destructure and construct a lot a pairs .. was that your idea ?)
14:54:45 <ddarius> dons: With the CPS monad, other than the cost of the CPS transform itself (which GHC handles well), you only pay for effects when you use them, e.g. you only pattern match against Maybe when you use mplus rather than every step (every (>>=))
14:54:50 <CakeProphet> :t (***)
14:54:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:55:12 <CakeProphet> lolwat?
14:55:16 <mmorrow> ski_: i wasn't thinking about that actually, but that's an excellent point.
14:55:35 <mercury^> ddarius: I don't see how they make it very concise. I want to build the sparse vector equivalent of [:if foo i j k then 1 else 0 | i <- [:bla:], j <- [:blu:], k <- [:ble:]:]
14:55:38 <Heffalump> :t (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
14:55:39 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
14:55:53 <ski_> (mmorrow : btw, i'm wondering whether using one instead of two continuations make much of a difference ..)
14:56:04 <Heffalump> waah
14:56:07 <CakeProphet> what on earth does *** do.
14:56:12 <ddarius> mercury^: Oh, you meant parallel -array- comprehensions.
14:56:15 <mmorrow> ski_: hmm, that's also a good point. i wonder also
14:56:17 <Heffalump> my program is behaving differently with and without ghc optimisations (before I even try mmorrow's suggestion)
14:56:35 <Heffalump> so thanks for the suggestion(s) but I think I need to figure that out first :-(
14:56:51 <mmorrow> heh, i'd love to hear how it goes.
14:57:06 <Heffalump> cutting this down to report won't be fun
14:57:15 <mmorrow> heh
14:57:33 <mercury^> ddarius: My hope was that it could work as [: (a,1) | i <- [:bla:], {- ... -}, foo i j k | a <- [:0..blub:]:]
14:57:34 <Heffalump> oh, wait
14:57:46 <Heffalump> I'm using unsafePerformIO for a name supply. I bet I wasn't careful enough with NOINLINE.
14:57:51 <mercury^> Well, they behave the same as parallel list comprehensions afaik.
14:57:52 <CakeProphet> what makes arrays faster than lists?
14:57:53 <Guenni> mmorrow: ping
14:57:54 <mmorrow> ski_'s observation about (***) though makes me think it'll have a similar speedup as that of State
14:58:03 <pumpkin> CakeProphet: they're faster for indexing
14:58:04 <CakeProphet> well... that's not my question. it's probably because they're not linked.
14:58:04 <mmorrow> Guenni: hey
14:58:09 <CakeProphet> but
14:58:11 <ski_> (mmorrow : i.e. `sidesLinear = sidesLinearK (,) . Map.toList where sidesLinearK k ((x, n):xs) | n > 0 = sidesLinearK (\a b -> k (f a `ePlus` x) b) ((x, n-1):xs)')
14:58:28 <mercury^> CakeProphet: these arrays also support automatic vectorisation.
14:58:36 <CakeProphet> I mean... is the array module written in Haskell or is it builtin with C or something.
14:58:36 <Heffalump> FWIW the order of the ePluses/eMinuses doesn't matter at all (as long as the result is still algebraically the same)
14:58:36 <pumpkin> which arrays are those?
14:58:42 <ddarius> CakeProphet: They're not faster.  They have different trade-offs.
14:58:50 <mmorrow> ski_: totally. that'd be interesting to see if that was an improvement over two conts
14:59:08 <ddarius> CakeProphet: Neither really.
14:59:10 <mercury^> So, how can I conveniently and efficiently build my sparse array?
14:59:20 <pumpkin> mercury^: with a Map? :P
14:59:26 <gweiqi> with python
14:59:33 <CakeProphet> ddarius:  builtin to the compiler?
14:59:34 <ski_> mmorrow : i'm not sure .. if you sometimes use only one part of the pair, then maybe the two-continuation would be better ..
14:59:37 <mercury^> pumpkin: please show me how.
14:59:48 <Philonous> CakeProphet: (***) extends an arrow to work on pairs. How does it do that? Simple: Apply it on the left item, apply it on the right, build a new pair with the values you got
14:59:49 <ddarius> CakeProphet: The primitives that they are built on, yes.
14:59:51 <mercury^> Oh, you meant the data structure?
14:59:57 <mercury^> ...
14:59:59 <pumpkin> mercury^: yeah :P
15:00:18 <BONUS_> actually i'd say that (***) takes two arrows and joins them in such an arrow that works on pairs
15:00:29 <mmorrow> ski_: hmm
15:00:31 <CakeProphet> ...I don't know what arrows are.
15:00:36 <pumpkin> join (***) takes one :P
15:01:50 <ddarius> mercury^: Isn't there a select like function that takes an array of Bool and another array and makes a new array with elements where the first array had True?
15:01:57 <Philonous> BONUS_: Right, two arrows.
15:02:46 <mercury^> ddarius: how does that help here?
15:03:00 <Philonous> I confused it with (&&&)
15:03:40 <ski_> @type (&&&)
15:03:42 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:03:43 <ski_> @type (***)
15:03:47 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:03:53 <ski_> both take two arrows
15:04:03 <CakeProphet> rofl. (&&&) - Haskell is worse than Perl with its operators.
15:04:39 <proq> isn't that why it gains so many perl programmers?
15:04:52 <Heffalump> at least they're not built in
15:04:54 <ddarius> mercury^: Just use your first (dense) approach paired with an index and then select or however you intend to represent the sparse array.  If everything fuses then it will be efficient.
15:08:55 <CakeProphet> I want to make an operator called (#%*!!) and somehow get it in Prelude
15:09:30 <CakeProphet> it replaces random adjectives in a string with profane ones.
15:09:59 <CakeProphet> useful for error messages.
15:11:14 <roconnor> > censor (#%*!!)
15:11:15 <lambdabot>   Not in scope: `#%*!!'
15:11:31 <Heffalump> does the advice about using {-# NOINLINE foo #-} if foo calls unsafePerformIO apply to things that call foo too?
15:12:29 <CakeProphet> ("Your wonderful input has very very bad parenthesis matching. Please remove a few "#%*!!)
15:12:40 <ddarius> Heffalump: If foo isn't a value then it doesn't matter.  If foo is a value then you don't need it elsewhere.
15:12:43 <mmorrow> Heffalump: i'd think (and hope) so
15:12:55 <Heffalump> mmorrow: but that would imply my whole program needs it
15:13:11 <sjanssen> Heffalump: I think the unsafePerformIO is really only needed for things like reference creation
15:13:13 <CakeProphet> (#%!!!) Does the same but also inserts curse words where there are no adjectives.
15:13:25 <mercury^> ddarius: ended up with filterP ((== 1) . snd) $ zipP [:0..lengthP t:] [:{- .. -}:] now. Let's hope it all fuses nicely.
15:13:28 <Heffalump> sjanssen: I want it for a name supply
15:13:38 <CakeProphet> > censor "lolwhut?"
15:13:39 <mmorrow> Heffalump: um, err, /me reparses that
15:13:40 <lambdabot>   Couldn't match expected type `w -> w'
15:13:52 <ddarius> Heffalump: What is foo?
15:13:58 <vixey> Heffalump, rather than using a monad?
15:13:59 <mmorrow> ohhh, i understand the question now. i don't think so ;)
15:14:01 <CakeProphet> :t censor
15:14:02 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
15:14:07 <Heffalump> vixey: correct
15:14:07 <sjanssen> Heffalump: the initial creation of the name supply should be NOINLINED, but users of the supply probably don't need NOINLINE
15:14:21 <vixey> huh.....
15:14:21 <athos> @index runState
15:14:22 <lambdabot> Control.Monad.State, Control.Monad.RWS
15:14:54 <roconnor> > censor (>>"X") (tell "lolwhut?")
15:14:56 <lambdabot>       No instance for (Show (m ()))
15:14:56 <lambdabot>        arising from a use of `show' at <i...
15:15:00 <Heffalump> ddarius: http://hpaste.org/13543
15:15:04 <roconnor> > execWriter $ censor (>>"X") (tell "lolwhut?")
15:15:06 <lambdabot>   "XXXXXXXX"
15:15:15 <mmorrow> i believe you only need NOINLINE if foo is a CAF as well
15:15:35 <vixey> Heffalump, why don't you just add a Integer parameter to your functions?
15:15:43 <CakeProphet> > make Sandwich
15:15:45 <lambdabot>   Not in scope: `make'Not in scope: data constructor `Sandwich'
15:15:47 <Heffalump> vixey: because I'd have to pass it out again and split it and stuff.
15:15:48 <mmorrow> or at least that's the only time i use it and it seems to work as expected
15:15:52 <roconnor> > execWriter $ censor (return "[-REDACTED-]") (tell "lolwhut?")
15:15:53 <lambdabot>   "[-REDACTED-]"
15:16:22 <vixey> Heffalump, maybe edwardks Comonad fits what you're doing better then
15:16:34 <Heffalump> I really would just like to cheat.
15:16:39 <Heffalump> and get away with it
15:16:43 <vixey> boo
15:17:06 <Heffalump> I've had enough of being good, I've been good for every other compiler-like thing I've written.
15:17:16 <CakeProphet> > lol
15:17:17 <lambdabot>   Not in scope: `lol'
15:17:18 <sjanssen> Heffalump: what sort of interface will you expose?
15:17:32 * vixey wonders if there's any tool that prints out haskell source as ocaml
15:17:34 <Heffalump> sjanssen: newVar (see the hpaste) is all I want to expose.
15:18:40 <CakeProphet> @let lol = iterate return.unsafePerformIO
15:18:41 <lambdabot>  <local>:8:21: Not in scope: `unsafePerformIO'
15:20:46 <mmorrow> Heffalump: this has worked ok for me (i'm not sure about the usefulness of MVar instead of IORef though)  http://hpaste.org/13543#a1
15:21:00 <athos> hmm, the state monad seems to be a really nice, although it's feels kind of unorthodox in the beginning
15:21:12 <Heffalump> mmorrow: ok, thanks, I'll play with changing to that
15:21:49 <vixey> :S I thought monads and all this meant to make things easier
15:21:51 <CakeProphet> one day I'll learn what it does.
15:21:53 <CakeProphet> ...
15:21:54 <ddarius> Heffalump: supply should be the only thing that needs NOINLINE, at least of the code there.
15:22:03 <CakeProphet> vixey:  I thought that too.
15:22:05 <CakeProphet> once.
15:22:45 <ddarius> vixey: They are meant to make it easier than explicit state passing.  Monadic style is still a global transformation and thus indicates a lack of expressive power.
15:23:06 <Heffalump> I was bemoaning the removal of linear implicit parameters
15:23:08 <CakeProphet> :t State
15:23:09 <lambdabot> forall s a. (s -> (a, s)) -> State s a
15:23:13 <Heffalump> but those were pretty horrid equationally
15:23:22 <CakeProphet> @src State
15:23:23 <lambdabot> Source not found. It can only be attributed to human error.
15:23:39 <vixey> I think you can do a type directed transform (automatically) from stuff like  f x y z into do x' <- x ; z <- z' ; f x' y z'
15:23:45 <athos> well, i guess i just need more code where the state monad is used :)
15:23:47 <vixey> of course, this isn't implemented...
15:24:00 <Heffalump> vixey: you can in simple cases like that
15:24:03 <CakeProphet> so it takes a function that returns a value and a new state...
15:24:04 <Heffalump> it's much harder when you have HOFs
15:24:18 <Heffalump> I tried it once with TH. Got tied up in knots.
15:24:39 <CakeProphet> what are the functions you use with a State monad?
15:24:41 <ddarius> HaRe has a refactoring for that.
15:25:00 <ddarius> But a global transformation is a global transformation no matter how you do it.
15:25:28 * Heffalump grumbles, my code is still behaving differently with and without optimisations no matter how many NOINLINEs I splatter over it.
15:25:38 <mmorrow> weird
15:25:48 <CakeProphet> Heffalump:  resort to C.
15:25:50 <CakeProphet> ...
15:25:56 <Heffalump> I haven't tried your version yet though (or indeed your optimisations to sidesLinear)
15:26:07 <Heffalump> CakeProphet: sure, could you rewrite the rest of it in C for me?
15:26:20 <mmorrow> brainfuck to the rescue!!
15:26:36 <CakeProphet> brainfuck is synonymous with efficiency.
15:26:54 <mmorrow> and productivity as well i hear.
15:26:59 <ddarius> mmorrow: Why do you force the argument to uniq?
15:27:25 <mmorrow> ddarius: so that if i want to gen a list of them at once, i can iterate uniq
15:27:40 <CakeProphet> > map nub (getUsers "#haskell")
15:27:41 <lambdabot>   Not in scope: `getUsers'
15:27:45 * CakeProphet giggles.
15:27:47 <mmorrow> since replicate n newName'll give you all the same
15:27:47 <Phyx-> hello, i was wondering if anyone could help me with fixing an old cabal file. it uses a "compilerPath" function which i can't find anywhere in the newer versions
15:28:04 <ddarius> mmorrow: You could do map uniq [1..10]
15:28:18 <ddarius> (or replicate 10 () or whatever)
15:28:24 <mmorrow> hmm
15:28:31 <CakeProphet> > uniq [1..]
15:28:33 <lambdabot>   Not in scope: `uniq'
15:28:48 <mmorrow> i should put that in lunabot so we can experiment
15:29:27 <CakeProphet> or just like... have a :m + like command.
15:30:07 <Phyx-> ok, is there a cabal channel or place i can ask
15:30:33 <CakeProphet> Phyx-:  what cabal?
15:30:41 <CakeProphet> there is no cabal.
15:31:17 <CakeProphet> (unfortunately, I don't know anything about cabal files.)
15:31:58 <Phyx-> sometimes, i just think the apis for and surrounding ghc changes too much
15:32:14 <CakeProphet> > (Data.List.uniq) [1..]
15:32:15 <lambdabot>   Not in scope: `Data.List.uniq'
15:32:35 <Heffalump> vixey: sigfpe has just posted about doing exactly what you just said about the monadic translation
15:32:51 <Heffalump> (his implementation mirrors what I played with a while back; Magnus Carlsson also did the same at some point)
15:33:08 <vixey> cool, I'll have a look
15:33:26 <SamB_XP> Phyx-: no kidding!
15:34:31 <Phyx-> @hoogle compiler
15:34:31 <lambdabot> Distribution.Simple.LocalBuildInfo compiler :: LocalBuildInfo -> Compiler
15:34:31 <lambdabot> module Distribution.Compiler
15:34:31 <lambdabot> module Distribution.Simple.Compiler
15:34:42 <CakeProphet> ...my brainfuck interpreter seems to be working for all of my test programs... except when I give it a canonical hello world program it just outputs an empty string.
15:34:48 <CakeProphet> strange.
15:35:06 <paper_cc> @hoogle GHC.Paths
15:35:07 <lambdabot> package ghc-paths
15:36:05 <paper_cc> Phyx-: that one contains a path to GHC. There should be something in Distribution though.
15:36:16 <vixey> ah that's nice except they only did the first order fragment
15:36:22 <mathijs> I have a question about RWH... on page 106 a function is defined that finds lines of "#define DLT_SOME_STRING" in a file and returns a list of SOME_STRING and others. in this case, a foldr is used (so reading the file backwards). I would personally use a filter, and then 'parse' the results, but I can see why using a fold is cheaper since it iterates only once. But why a backward-fold?
15:36:56 <Phyx-> paper_cc: yeah, i'm looking if i can get it out of the "Compiler" datatype
15:36:58 <ddarius> mathijs: foldr isn't "backwards"
15:37:12 <Phyx-> if i can't i'll try GHC.Paths thanks :)
15:38:13 <mathijs> ddarius: ah... got it, forgot about lazyness, the first result to be found/evaluated will still be the first in the file.
15:38:40 <paper_cc> Phyx-: take a look at Distribution.Simple.InstallDirs
15:39:20 <Phyx-> ah, that'll work
15:39:23 <SamB_XP> some 1-year compat. in practice would be nice ...
15:39:28 <Phyx-> thanks paper_cc
15:39:34 <mmorrow> ddarius:
15:39:39 <mmorrow> , fmap uniq [0..9]
15:39:43 <lunabot>  [0,0,0,0,0,0,0,0,0,0]
15:39:48 <mmorrow> , iterate uniq 0
15:39:53 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:40:02 <mathijs> ddarius: because of outside-in evaluation(lazy), it all works out ok, I can even take x results without the rest of the file being checked.
15:40:09 <mathijs> right?
15:40:10 <mmorrow> , iterate uniq (uniq())
15:40:14 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:40:22 <ddarius> mathijs: Depending on how it's used, yes.
15:40:29 <ddarius> s/used/produced
15:40:43 <ddarius> But presumably yes if foldr is being used
15:40:54 <ddarius> , (uniq (), uniq ())
15:41:01 <lunabot>  (0,0)
15:41:25 <mmorrow> hmm, this might be something weird hapenning with lunabot
15:41:29 <vixey> mathijs, best not to think about evaluation imo
15:41:31 <mmorrow> , newVars 5 "foo"
15:41:39 <lunabot>  ["foo_0","foo_0","foo_0","foo_0","foo_0"]
15:41:42 <ski_> sigfpe's `extract' is my "reflect"
15:41:45 <mmorrow> yeah, hmm
15:41:47 * ddarius agrees with vixey
15:42:03 <SamB_XP> , uniq 1
15:42:05 <mmorrow> it may be something to do with how ghci reverts cafs, but i'm not in lunabot
15:42:08 <lunabot>  0
15:42:11 <vixey> ski_, I am keen on the unsafePeekExecution
15:42:15 <SamB_XP> , map uniq [1..]
15:42:20 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:42:29 <SamB_XP> that's ... not right at all!
15:42:34 <mmorrow> , uniq (uniq (uniq ()))
15:42:38 <lunabot>  0
15:42:43 <ski_> vixey : that was (mostly) unrelated to my ideas about monadic reflection
15:42:47 <mmorrow> it's borked
15:43:07 <mmorrow> , let x = uniq x in x
15:43:12 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:43:15 <Heffalump> I think I called it runMonad
15:43:20 <ddarius> Monadic reflection is pretty much pointless for Haskell.
15:43:20 <vixey> > uniq uniq
15:43:21 <lambdabot>   Not in scope: `uniq'Not in scope: `uniq'
15:43:28 <SamB_XP> has the CSE gone astray ?
15:43:28 <mmorrow> , let x = uniq (uniq x) in x
15:43:33 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:43:37 <vixey> I wonder why higher order functions make it difficult though
15:43:49 <SamB_XP> in combination with the inliner
15:43:50 <ski_> ddarius : why so ?
15:44:06 <ddarius> ski_: What do you get from it?
15:44:13 <SamB_XP> vixey: why do they make anything difficult ?
15:44:15 <Heffalump> vixey: because you have to figure out how to translate them
15:44:22 <mmorrow> SamB_XP: i'm not sure what's happening.
15:44:26 <ski_> ddarius : local expressions in DS ?
15:44:27 <vixey> f :: a -> m a,   f x + f y is ok,   but    sum (map f [x,y]).....
15:44:31 <CakeProphet> what's the quickest to turn a string into an Array Char?
15:44:39 <CakeProphet> +way
15:44:45 <SamB_XP> mmorrow: maybe you should have GHC dump the final simplified code ?
15:44:45 <Phyx-> @hoogle dir
15:44:45 <lambdabot> Text.XHtml.Transitional dir :: Html -> Html
15:44:45 <lambdabot> module System.Directory
15:44:45 <lambdabot> System.Posix.Internals Directory :: FDType
15:44:46 <ddarius> ski_: That didn't mean anything to me.
15:44:52 <vixey> you will have to break open the definition of map
15:45:12 <ddarius> vixey: Hence global transformation.
15:45:15 <CakeProphet> :t toArray
15:45:16 <lambdabot> Not in scope: `toArray'
15:45:16 <Heffalump> vixey: right
15:45:17 <mmorrow> , replicate 10 (unQ (newName "x"))
15:45:19 <lunabot>  [x_0,x_0,x_0,x_0,x_0,x_0,x_0,x_0,x_0,x_0]
15:45:23 <Phyx-> :t dir
15:45:24 <lambdabot> Not in scope: `dir'
15:45:29 <ski_> ddarius : i mean that for local expression, you could use Direct Style (as opposed to monadic style)
15:45:33 <mmorrow> , unQ (replicateM (newName "x"))
15:45:34 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
15:45:39 <mmorrow> , unQ (replicateM 10 (newName "x"))
15:45:42 <lunabot>  [x_0,x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9]
15:45:46 <mmorrow> hmm
15:45:52 <ski_> vixey : yes, you have to specify how the effects from `f' will get composed
15:46:00 <ddarius> ski_: Using some kind of translation?  or were you making something impure?
15:46:18 <Heffalump> ddarius: the whole conversation is about the extract operation from sigfpe's recent blog post
15:46:20 <ski_> ddarius : a translation, yes. nothing impure
15:47:35 <ddarius> ski_: Okay.  So monadic reflection is still not that important and all you're doing is compiling an impure language into Haskell.  You don't really gain much from it.
15:47:52 <CakeProphet> > let hello = "Hello, World!" in listArray (0, length hello - 1) hello
15:47:54 <lambdabot>   array (0,12) [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,','),(6,' '),(7,'W...
15:48:04 <Heffalump> apart from a nice syntax and a lot of the power of Haskell
15:48:08 <Heffalump> like the type system
15:48:19 <CakeProphet> > let hello = "Hello, World!" in (listArray (0, length hello - 1) hello)!12
15:48:21 <lambdabot>   '!'
15:48:39 <ski_> ddarius : mostly like Heffalump says
15:48:44 <ddarius> Heffalump: It's an implementation of a compiler by translation, but the impure "language" is still a different (if closely related) language.
15:48:52 <vixey> ddarius, well I think it might be interesting if you were translating code in computation monad
15:49:15 <ski_>   `(case ,getLine of "" -> ...; s -> ...)
15:49:16 <Saizan_> but if you don't translate lambdas, isn't that more like applicative than monad?
15:49:17 <ski_> instead of
15:49:18 <ddarius> As you pointed out, if I try to use map it won't work.
15:49:33 <ski_>   getLine >>= \x -> case x of of "" -> `...; s -> `...
15:49:54 <vixey> it would be nice if haskell let you define  caseM  though..
15:50:11 <vixey> well it is possible actually
15:50:30 <paper_cc> mm
15:50:33 <paper_cc> ?
15:51:12 <Phyx-> @hoogle PackageIdentifier
15:51:12 <lambdabot> Distribution.Package data PackageIdentifier
15:51:12 <lambdabot> Distribution.Package PackageIdentifier :: String -> Version -> PackageIdentifier
15:53:13 <mmorrow> ok, i got it. for whatever reason that wasn't working in lunabot (ghc-api-compiled-to-bytecode-no-cafs-reverted-??), but it works if you delay the unsafePerformIO until after you replicateM
15:53:21 <mmorrow> , newVars 10 "x"
15:53:25 <lunabot>  ["x_0","x_1","x_2","x_3","x_4","x_5","x_6","x_7","x_8","x_9"]
15:53:28 <mmorrow> , newVar "x"
15:53:33 <lunabot>  "x_0"
15:53:40 <mmorrow> , replicate 10 (newVar "x")
15:53:44 <lunabot>  ["x_0","x_0","x_0","x_0","x_0","x_0","x_0","x_0","x_0","x_0"]
15:53:46 <mmorrow> , newVars 10 "x"
15:53:51 <lunabot>  ["x_0","x_1","x_2","x_3","x_4","x_5","x_6","x_7","x_8","x_9"]
15:53:53 <mmorrow> as expected
15:54:09 <ddarius> 'cuz that makes sense ...
15:54:14 <mathijs> @src seq
15:54:14 <lambdabot> Source not found.
15:54:18 <sjanssen> scary
15:54:42 <mmorrow> http://hpaste.org/13543#a2
15:54:44 <lucca> :t newVars
15:54:45 <lambdabot> Not in scope: `newVars'
15:54:53 <ski_> , reverse (newVars 10 "x")
15:54:58 <lunabot>  ["x_9","x_8","x_7","x_6","x_5","x_4","x_3","x_2","x_1","x_0"]
15:55:02 <mmorrow> the code for newVar(s)/etc http://hpaste.org/13543#a2
15:55:11 <lucca> ah, thanks, heh
15:55:31 <mmorrow> i put in a `uniq' too, but it probably has the same behavior as the old one
15:55:38 <mmorrow> , iterate uniq [0..]
15:55:40 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
15:55:45 <mmorrow> , iterate uniq 0
15:55:50 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:55:51 <lucca> eeew
15:55:52 <mmorrow> yeah
15:55:55 * ski_ pondered the other day a concept of "choice variables" ..
15:56:11 <Phyx-> @hoogle defaultMainWithHooks
15:56:11 <lambdabot> Distribution.Simple defaultMainWithHooks :: UserHooks -> IO ()
15:56:11 <Phyx-> tBuild = mkVSHaskell
15:56:11 <lambdabot> Distribution.Simple defaultMainWithHooksArgs :: UserHooks -> [String] -> IO ()
15:56:20 <Phyx-> oops
15:56:41 <Phyx-> @hoogle defaultUserHooks
15:56:42 <lambdabot> Distribution.Simple defaultUserHooks :: UserHooks
15:56:49 <ski_> when a "choice variable" would be forced the first time, the user would be prompted for a value (possibly including new "choice variables")
15:57:13 <mmorrow> hmm, what do you mean by "prompted"?
15:57:20 <Heffalump> ski_: isn't that sort of what declarative debugging does
15:57:26 <Heffalump> (very "sort of")
15:57:38 <ski_> mmorrow : the toplevel interactor would present a prompt
15:57:49 <Heffalump> also, it's what lazy smallcheck does, without prompting the user
15:57:56 <mmorrow> ski_: ah, i gotcha
15:58:39 <ski_> Foo> fst (x,y) where choice x,y
15:58:47 <ski_> x = > 5
15:58:47 <ski_> 5
15:59:24 <mmorrow> choiceVar :: a -> a = \_ -> unsafePerformIO (putStrLn "choose!" >> read `fmap` getLine)
15:59:29 <mmorrow> ?
15:59:54 <ski_> Heffalump : i thought declarative debugging was more like asking the user whether certain equalities ought to hold
15:59:58 <mmorrow> let x = replicate (choiceVar (undefined::Int)) 42
16:00:41 <ski_> mmorrow : yes .. the more interesting aspects would be how to manage the variables, and be able to tell the user which variable was prompted for, in a way understandable for a user
16:01:13 <mmorrow> oh cool, i kinda see where you're heading with this
16:01:19 <ski_> (mmorrow : so, probably not allow creating choice-variables on the fly .. at least not without encapsulating that effect in a monad)
16:02:53 <mmorrow> like having a newtype CVarTab = CVarTab (Map Id ChoiceVar), and sticking that in an MVar CVarTab or something to be updated
16:03:06 <ski_> (so, tagging like hood's `observe :: String -> a -> a' would not be desired)
16:03:12 <SamB_XP> I doubt you need any MVars
16:03:46 <mmorrow> SamB_XP: you wouldn't unless there were multiple choosy users :)
16:04:19 <eu-prleu-peupeu> hey
16:04:26 <eu-prleu-peupeu> im gettin this error compiling time module on windows: http://hpaste.org/13545
16:04:30 <eu-prleu-peupeu> anyone knows why ?
16:04:35 <eu-prleu-peupeu> ghc version is 6.10.1
16:05:48 <Saizan_> it's self explanatory..
16:07:09 <Saizan_> eu-prleu-peupeu: you probably need to install MSYS to compile that package on windows
16:09:21 <athos> :t random
16:09:22 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
16:09:31 <athos> :t mkStdGen
16:09:32 <lambdabot> Int -> StdGen
16:09:37 <athos> @instance RandomGen
16:09:38 <lambdabot> Maybe you meant: instances instances-importing
16:09:49 <athos> ouch.
16:09:57 <athos> :)
16:10:25 <athos> @instances RandomGen
16:10:26 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
16:10:30 <Phyx-> @url alex
16:10:30 <lambdabot> http://www.haskell.org/alex/
16:10:35 <athos> @instances-importing RandomGen
16:10:36 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
16:10:39 <athos> 8)
16:11:29 <jeltsch> Hello, does anyone know why there isn’t a MonadPlus instance for ContT? I‘ve put one on http://hpaste.org/13546 which seems rather sensible to me.
16:11:48 <ski_> @index RandomGen
16:11:48 <lambdabot> System.Random
16:12:00 <ski_> @instances-importing System.Random RandomGen
16:12:01 <lambdabot> StdGen
16:12:15 <opqdonut> jeltsch: you probably mean MonadPlus (ContT result monad o)
16:13:25 <jeltsch> opqdonut: Sorry, compiled the wrong file and therefore missed this error. Wait a moment, please.
16:13:38 <ski_> jeltsch : the `o' should not be there
16:13:44 <athos> :t randomR
16:13:45 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
16:14:29 <Phyx-> hmm, i've downloaded alex and put it in the ghc folder but i still get "Setup: The program alex is required but it could not be found"
16:15:02 <eu-prleu-peupeu1> i dont understand sorry
16:15:05 <jeltsch> ski__: Yes, I know. And the mappend should be a mplus
16:15:05 <eu-prleu-peupeu1> i lost my connection
16:15:13 <eu-prleu-peupeu1> why can't i compile the time module on windows ?
16:15:54 <jeltsch> Corrected MonadPlus instance for ContT is here: http://hpaste.org/13546#a1
16:16:03 <ski_> jeltsch : have you proved the unit and associativity laws ?
16:16:19 <jeltsch> ski__: Not yet.
16:17:15 <Saizan_> eu-prleu-peupeu: it says you lack "make", which is a unix utility, you probably need to install MSYS to compile time on windows
16:17:38 <Saizan_> eu-prleu-peupeu: i don't know if there's an easier route
16:18:11 <mmorrow> oh coool. i just saw sigfpe's blog post.
16:18:14 <jeltsch> ski__: If you ignore the newtype wrapping of ContT then mzero = pure mzero (pure = liftA0) and mplus = liftA2 mplus, using (->) (o -> monad result) as the applicative functor. So associativity and neutral element property should hold.
16:18:57 <ski_> @type pure mzero
16:18:59 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Applicative f, MonadPlus m) => f (m a)
16:19:15 <ski_> @type ContT (pure mzero)
16:19:17 <lambdabot> forall (m :: * -> *) r a. (MonadPlus m) => ContT r m a
16:20:31 <Myrth> which binary do i use and how to get output from a program not interactively? ghc just compiles it
16:21:01 <opqdonut> err your question does not parse
16:21:04 <opqdonut> but do you mean ghci?
16:21:11 <SamB_XP> Myrth: could you ask one at a time maybe ?
16:21:21 <SamB_XP> which binary do you use for what ?
16:21:22 <Myrth> i have EditPlus, and i can configure a tool to process the current buffer
16:21:35 <opqdonut> runhaskell?
16:21:37 <Myrth> and capture the output in a frame
16:22:30 <Myrth> yep, thanks :)
16:22:41 <eu-prleu-peupeu2> :/
16:23:08 <eu-prleu-peupeu2> Saizan_: i have make, MSYS, and autoconf working here fine...
16:23:48 <eu-prleu-peupeu2> even on bash, the output is the same :/
16:23:55 <Saizan_> ah
16:24:50 <athos> http://hpaste.org/13547 <- is there are prettier way, i mean, would one consider this as dirty?
16:25:20 <opqdonut> athos: yes, use the state monad
16:25:35 <eu-prleu-peupeu2> its because of this: #define HAVE_DECL_ALTZONE 0
16:25:44 <opqdonut> it is intended precisely for threading that sort of changing state
16:25:58 <athos> whoops, you're right
16:26:15 <athos> seems like i forgot my "task": learn something about the holy state monad
16:26:16 <athos> :)
16:26:43 <CakeProphet> is there a function that returns a tuple where the first element is init and the second is last?
16:26:58 <koeien> there are few things in the world as ugly as unsafePerformIO
16:27:04 <ddarius> > init &&& last [1..10]
16:27:05 <lambdabot>       Overlapping instances for Show ([a] -> ([a], c'))
16:27:05 <lambdabot>        arising from a...
16:27:12 <ddarius> > (init &&& last) [1..10]
16:27:13 <opqdonut> CakeProphet: no, but it should be easy to define
16:27:13 <lambdabot>   ([1,2,3,4,5,6,7,8,9],10)
16:27:29 <opqdonut> either like ddarius did, or with a custom recursive function that does it in one pass
16:27:34 <CakeProphet> ddarius:  is that more efficient than calling init and last and recursing over the list twice?
16:27:41 <opqdonut> CakeProphet: no
16:27:52 <CakeProphet> oh... well then I might as well call them seperately.
16:28:01 <eu-prleu-peupeu2> i guess its because im using ghc 6.10: http://hackage.haskell.org/packages/archive/time/1.1.2.1/logs/failure/ghc-6.10
16:28:25 <ddarius> CakeProphet: init and last aren't efficient period, you should probably use a different data structure (or a different approach) if this is something you're going to be doing a lot of.
16:28:48 <Heffalump> ski_: yes, that's why I said sort of re declarative debugging
16:28:57 <CakeProphet> nah... it's a brainfuck interpreter. init and last happen everytime there's a "[" so it can get a pointer to its corresponding "]"
16:28:59 <opqdonut> > let f ys [x] = (ys,x); f ys (x:xs) = f (x:ys) xs; f' = f [] in f' [1..10]
16:29:00 <lambdabot>   ([9,8,7,6,5,4,3,2,1],10)
16:29:08 <opqdonut> heh, reversed
16:29:10 <opqdonut> but anyways
16:29:29 <Phyx-> Distribution.Setup is no more right?
16:29:34 <EvilTerran> CakeProphet, there should be a more efficient way of doing that - can't you use the other end of the list?
16:29:39 <Phyx-> it's not Distribution.Simple.Setup?
16:29:48 <EvilTerran> head and tail (or pattern-matching out a (:)) are O(1)
16:30:01 <SamB_XP> CakeProphet: you could, you know, represent the program in AST form
16:30:13 <CakeProphet> that's what I'm doing
16:30:15 <CakeProphet> ...
16:30:29 <SamB_XP> so why do you need to do that init/last thing ?
16:30:31 <koeien> i would maintain a stack of ['s and pop off once it get to a [
16:30:49 <CakeProphet> but I decided integer pointers in a finite list of tokens is less complicated to implement than an infinite AST tree thing.
16:31:26 <CakeProphet> koeien:  I've got that too
16:32:02 <CakeProphet> but the token I use for ['s refers to its corresponding ]
16:32:07 <koeien> i wrote an interpreter in C, and a program for to-the-power-of in Brainfuck once. never again :)
16:32:39 <Raynes> Write a C compiler in haskell.
16:33:01 <koeien> CakeProphet: ok. i don't know precisely what you are doing :) all i know is that last/init are O(length xs)
16:33:05 <Phyx-> boy.... updating old code to work sure is a PAIN
16:33:32 <CakeProphet> data Token   = Op Char Int | Branch Int Int | Return Int Int deriving (Eq, Show)
16:33:48 <CakeProphet> I'm taking a bf program ( [Char]) and turning it into a list of these Tokens ([Token])
16:33:49 <koeien> and you have an array of Tokens ?
16:33:55 <Myrth> is there a some plugin concept in haskell that allows binding to some triggers or overload existing functionality? i know i'm talking OO terms, but that's because i don't know functional terms for it or how it's usually done
16:34:05 <rwbarton> how about  data Command = ... | While [Command] | ...
16:34:10 <rwbarton> That's what I used in my compiler
16:34:19 <koeien> that's a lot more functional
16:34:37 <opqdonut> Myrth: you probably want to modularise so that you pass something explicit around
16:34:44 <opqdonut> describing the actions to take
16:34:48 <opqdonut> instead of overriding
16:34:55 <opqdonut> typeclasses are another approach
16:35:28 <Phyx-> @hoogle CheckedModule
16:35:29 <lambdabot> No results found
16:35:30 <CakeProphet> rwbarton:  that was what I was originally going to do... but the question is, when I get to the "[". how do I get the [Command] to construct the While?
16:35:33 <Phyx-> :t CheckedModule
16:35:34 <lambdabot> Not in scope: data constructor `CheckedModule'
16:35:41 <Myrth> as a hypothetical example, if firefox was written in haskell, would it be possible to make add-ons as they are now?
16:35:49 <opqdonut> of course
16:35:55 <opqdonut> xmonad has a plugin system, for instance
16:35:58 <koeien> CakeProphet: with recursion :) parse the inner part, and pass that to the While constructor
16:36:08 <Phyx-> @hoogle GHC
16:36:08 <lambdabot> module Distribution.Simple.GHC
16:36:08 <lambdabot> Distribution.Compiler GHC :: CompilerFlavor
16:36:08 <lambdabot> package ghc-core
16:36:09 * EvilTerran envisages using a StateT to maintain a stack of ContT-based continuations for each '['
16:36:11 <koeien> you have a function parse :: String -> (Command, String)
16:36:19 <EvilTerran> with an IO at the bottom for the side-effects, i guess
16:36:22 <opqdonut> heh
16:36:23 <Phyx-> @hoogle ghc-core
16:36:23 <lambdabot> module Distribution.Simple.GHC
16:36:23 <lambdabot> Distribution.Compiler GHC :: CompilerFlavor
16:36:23 <lambdabot> package ghc-core
16:36:28 <Phyx-> hrm
16:36:41 <koeien> CakeProphet: where the snd of the result is the "unparsed part"
16:36:52 <CakeProphet> koeien:  right, but if I use the tokenizing part of the function to parse the inner part, I'll need the "]" to terminate the list... in that case, how do I get what's /after/ the ]
16:37:25 <CakeProphet> ..I did that originally as well, but the function was incredibly ugly, and I couldn't figure out why it didn't work correctly.
16:37:30 <EvilTerran> ?type callCC (modify . (:))
16:37:31 <lambdabot> forall (m :: * -> *) b. (MonadCont m, MonadState [() -> m b] m) => m ()
16:37:33 <Myrth> opqdonut: thanks, i'll look at xmonad as example
16:37:33 <rwbarton> CakeProphet: FWIW I just used six lines of parsec :)
16:37:42 <koeien> CakeProphet: hmm. do you still have that code?
16:37:46 <EvilTerran> hm... looks like some extended defaulting at work, there
16:37:47 <koeien> CakeProphet: can you paste it?
16:37:49 <SamB_XP> if firefox were written in Haskell, I'd wonder why I was still using Haskell ...
16:38:03 <CakeProphet> koeien:  the answer to that question relies on how far back gedits undo goes :)
16:38:11 <koeien> :)
16:38:49 * SamB_XP usually uses a parsing library to write parsers ...
16:38:56 <SamB_XP> (or alex and happy)
16:39:04 <koeien> i think the point is to learn it to do by hand
16:39:18 <SamB_XP> by hand is so fiddly
16:39:22 <koeien> i know.
16:39:37 <koeien> but you can always rewrite it as a monad
16:39:47 <SamB_XP> more useful would be to learn to design your own parser combinator libraries ;-P
16:39:52 <koeien> it can be a moderately intersting exercise
16:39:58 <koeien> oh yes, sure :)
16:40:05 <athos> Think of a monadic computation M a as a container for a value of type a that is unfortunately paired with highly dangerous nuclear waste. Under no circumstance should this tightly sealed container be opened to extract the a or the nuclear waste will leak out, resulting in a catastrophe!.
16:40:13 <athos> haha, that's a great example
16:40:14 <athos> :)
16:40:24 <koeien> that is not always true
16:40:34 <SamB_XP> koeien: well, it works for IO
16:40:36 <opqdonut> the container analogy breaks down pretty quickly
16:40:42 <athos> opqdonut: at maybe i guess
16:40:45 <athos> @src maybe
16:40:46 <lambdabot> maybe n _ Nothing  = n
16:40:46 <lambdabot> maybe _ f (Just x) = f x
16:40:46 <koeien> SamB_XP: yes, for IO.
16:40:50 <opqdonut> but it's a start I guess
16:41:00 <opqdonut> athos: well Maybe is just a container that might be empty ;)
16:41:27 <Taejo> the container analogy is okay if you consider functions to be containers
16:41:28 <athos> yeah, but the maybe function looks like what one could mean by using 'extract' i think
16:41:48 <CakeProphet> koeien:  yes. I'll paste up the relevant bits
16:41:49 <opqdonut> athos: yeah but the maybe function is not part of the monad api
16:41:51 <koeien> yes, sure. also, you have fromJust and isJust and freinds
16:41:52 <opqdonut> using it is cheating
16:42:03 <SamB_XP> fromJust is obviously evil
16:42:04 <athos> ok :
16:42:04 <koeien> CakeProphet: ok
16:42:25 <SamB_XP> ~(Just x) is much better ;-P
16:42:33 <opqdonut> ;)
16:42:34 <CakeProphet> koeien:  be forewarned, there's definitely a better way to organize it, it's just so messy I don't know where to start.
16:42:37 <koeien> :) unsafePerformIO to the rescue
16:42:49 <CakeProphet> http://hpaste.org/13548
16:43:12 <CakeProphet> hmmm... actually.
16:43:17 <CakeProphet> what I /could/ do
16:43:19 <Phyx-> ok, goes anyone know if CheckedModule is still in module GHC?
16:43:28 <SamB_XP> (well, I suppose if you have profiling on it might not be SO bad ... if you only use it at most once per function!)
16:43:38 <CakeProphet> is get rid of jumpback... which would probably fix it. and instead of a stack of "[" branches
16:43:43 <Phyx-> @hoogle checkModule
16:43:43 <lambdabot> No results found
16:43:47 <koeien> yes, right; something like that
16:43:52 <koeien> you don't need the "past"
16:44:00 <Phyx-> blah, why are those packages always undocumented
16:44:24 <koeien> CakeProphet: but your data structure, what does the Char in Branch Char [Token] mean?
16:44:33 <CakeProphet> koeien:  it's just so ugly to have the regular parsing, which would normally be very clean, muddled up by tuples with filler values.
16:45:30 <CakeProphet> koeien:  '[' or ']'... ] has a list of tokens that it goes over again. I should probably refactor it so that Branch [Token] is '[' and Return Token is ']
16:45:31 <koeien> CakeProphet: i think you can write the makeBranch function directly
16:46:02 <CakeProphet> the Token in Return Token being the original '['
16:46:11 <koeien> you don't need Return at all, why wouldn't data Token = Inc | Dec | Left ... | While [Token]      suffice?
16:47:01 <koeien> also makes for a very easy and intuitive interpreter
16:47:11 <koeien> s/makes for/gives rise to
16:48:40 <CakeProphet> koeien:  http://hpaste.org/13549   interpreter and relevant bits
16:49:07 <Phyx-> :t GHC.checkModule
16:49:09 <lambdabot> Couldn't find qualified module.
16:49:10 <CakeProphet> very clean, I think.
16:49:14 <koeien> your Tape datastructure is very clean
16:49:25 <bohdan> http://www.haskell.org/haskellwiki/Performance/GHC#Measuring_performance -- I can't get -stderr flag to work -- is it too old or too new? :)
16:49:40 <koeien> I believe the spec said only 30k tape, but this is of course a lot nicer :)
16:50:49 <ddarius> -sstderr
16:50:51 <pstickne> list-comprehension syntax is just sugar, right?
16:50:56 <ddarius> pstickne: Yes.
16:51:04 <chessguy_> @pl \x y -> o (g x) y
16:51:05 <lambdabot> o . g
16:51:07 <pstickne> ddarius:  what's the name of the underlying function? :)
16:51:09 <CakeProphet> koeien:  indeed.
16:51:19 <ddarius> pstickne: It's multiple functions.
16:51:21 <pstickne> ooh
16:51:28 <opqdonut> pstickne: kinda like do-notation for the list monad
16:51:42 <ddarius> @undo [(a,b) | a <- as, b <- bs, a == b]
16:51:42 <lambdabot> concatMap (\ a -> concatMap (\ b -> if a == b then [(a, b)] else []) bs) as
16:51:43 <bohdan> oh crap :) thanks ddarius :)
16:51:50 <CakeProphet> koeien:  I think the guards and helper functions read nicely as well. I just can't get tokenize to give interpret what it wants.
16:52:10 <pstickne> ddarius:  thanks!
16:52:27 <Phyx-> :t \mn -> typecheckModule =<< parseModule =<< getModSummary mn
16:52:28 <lambdabot> Not in scope: `typecheckModule'
16:52:28 <lambdabot> Not in scope: `parseModule'
16:52:28 <lambdabot> Not in scope: `getModSummary'
16:52:41 <koeien> CakeProphet: http://hpaste.org/13548#a1
16:52:59 <koeien> something like this. i did not test it though
16:53:09 <eu-prleu-peupeu2> :( everything seems to be crippled on windows
16:53:18 <ddarius> CakeProphet: Wouldn't it have been easier/simpler simply to pattern match against Op instead of using isOp?
16:53:23 <koeien> as you can see, you have a bit of "plumbing" to do; that's why normally a parser combinator library is used
16:54:14 <CakeProphet> ddarius:  couldn't bind all the helper functions to one pattern that way... and too much typing "input state".
16:54:26 <koeien> ddarius, CakeProphet: yes, that's a bit easier but the formatting is nicer now. I personally would use a more strongly typed system in which the operators are constructors as well (i.e. Increase and not Op '+')
16:54:33 <CakeProphet> koeien:  that's actually pretty clean.
16:55:21 <CakeProphet> koeien:  I just didn't want to pattern match in the interpreter /and/ in the parser... the parser just makes branches and spits out other ops as is... the interpreter can then determine what's a comment etc
16:55:28 * CakeProphet is lazy like Haskell.
16:55:28 <ddarius> CakeProphet: Just use case
16:55:48 <koeien> CakeProphet: that's a matter of taste. normally in compilers you filter out "comments" and generate "tokens"
16:55:50 <CakeProphet> ddarius:  hmm, I might. it would be easier to read.
16:56:13 <eu-prleu-peupeu2> there should be a servious endevour to gather a set of stable working packages from hackage, in one neat package
16:56:26 <eu-prleu-peupeu2> or else windows is still impractical :/
16:56:33 <koeien> i would want to get rid of comments and stuff as soon as possible, and go to a more typesafe version
16:56:44 <koeien> yes, we need a voting and/or filtering system on hackage :)
16:56:56 <eu-prleu-peupeu2> not that
16:57:09 <eu-prleu-peupeu2> a simple hackagedb.tar.gz
16:57:12 <eu-prleu-peupeu2> would suffice
16:57:28 <koeien> i don't know if you want to compile everything in 1 *big* package
16:57:53 <koeien> doesn't cabal-install work on Windows?
16:57:57 <eu-prleu-peupeu2> the problem is that i just want it to compile!
16:58:14 <eu-prleu-peupeu2> if i can't even get it to compile to start with... then there is a problem :/
16:58:17 <koeien> :) GHC 6.10.1 broke quite a bit
16:58:35 <ozy`> didn't 6.8 break a lot more?
16:58:40 <eu-prleu-peupeu2> anyway, linux works fine, with ghc 6.8
16:59:09 <eu-prleu-peupeu2> eheh
16:59:17 <leepike> newbie question: how do I check whether a Haskell package is already part of my default installation?
16:59:24 <koeien> leepike: ghc-pkg list
16:59:27 <eu-prleu-peupeu2> if i had the knowledge i would gladly run through the hackage packages and fix them
16:59:29 <eu-prleu-peupeu2> but i dont :/
16:59:34 <leepike> Thx!
16:59:57 <ddarius> eu-prleu-peupeu2: Have you been reporting the problems you've had?
17:00:15 <koeien> eu-prleu-peupeu2: is it just one package you're encountering?
17:00:48 <eu-prleu-peupeu2> nope, several
17:01:01 <eu-prleu-peupeu2> most of them are logged on hackage
17:01:20 <koeien> if "Build failure ghc-6.10" is on the package's page, there is little you can do
17:01:25 <eu-prleu-peupeu2> ok
17:01:34 <koeien> except for fixing the build errors yourself =)
17:01:42 <koeien> it's a package bug rather than a GHC bug (in most cases)
17:02:08 <koeien> but i've tried to compile quite a bit recently, and encountered some errors as well
17:02:14 <koeien> (debian here)
17:02:40 <koeien> so if you'd install GHC 6.8.3 on windows, most of your problems would go away for now
17:02:49 <koeien> at least, /methinks
17:03:04 <vininim_> > (6*10**9)/40
17:03:06 <lambdabot>   1.5e8
17:04:31 <Myrth> is there any preference for getting first element between (ws !! 0) and (w:ws) ?
17:04:41 <koeien> yes. (w:ws) definitely
17:04:42 <Heffalump> yes, pattern matching is better style
17:04:46 <koeien> or `head`
17:05:32 <Myrth> going through xmonad code - they use (ws !! 0) :P
17:06:24 <koeien> CakeProphet: as you may have noticed by now, the code is not correct, but it's a start :)
17:06:35 <lispy> Myrth: odd
17:06:36 <CakeProphet> koeien:  I haven't noticed actually...
17:06:43 <CakeProphet> I am using it though. What's wrong with it?
17:06:50 <rwbarton> Myrth: Where?
17:06:59 <koeien> well. it doesn't compile :)
17:06:59 <rwbarton> Myrth: I only see one such line, in xmonad-contrib, and it's commented out
17:07:01 <Myrth> maybe it's just contrib: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Hooks-ServerMode.html
17:07:11 <rwbarton> Yeah, that's the one line :P
17:07:18 <koeien> CakeProphet: and, try to compile "[+]+", you'll see why
17:07:42 <CakeProphet> koeien:  it'll take some work to factor parse into the code I've got now, so I can't do that yet.
17:08:05 <koeien> okay. i'll try to upload a fixed version :)
17:09:10 <CakeProphet> koeien:  the main problem I have with it is my current interpreter has no way of distinguishing between the end of a program and the end of a loop... because they'll both be empty lists.
17:09:25 <koeien> CakeProphet: there is no difference between them, right?
17:09:32 <koeien> if you encounter the end of your list, you're done
17:09:44 <CakeProphet> well, if you encounter a ] it needs to jump back to the [
17:09:47 <Myrth> oh btw CakeProphet - cake is a lie.
17:09:58 <CakeProphet> at the end of the program... you just return the end of your output list - []
17:10:00 <koeien> if you are in a recursive call because there's a While wrapped around it, the calling function will take care of that
17:10:20 <CakeProphet> hmmm
17:10:22 <CakeProphet> so
17:10:24 <CakeProphet> for the [ case
17:10:44 <koeien> if you have the data structure as in the pastebin, you won't encounter a Op '[' or Op ']' anymore
17:11:22 <CakeProphet> I never would have in the first place
17:11:23 <CakeProphet> I changed it to yours.
17:11:34 <CakeProphet> data Token   = Op Char | While [Token] deriving (Eq, Show)
17:11:51 <CakeProphet> though I never would have encountered those Ops in mine either.
17:11:53 <koeien> ok, that whas more or less your Ansatz
17:12:04 <CakeProphet> wat
17:12:07 <koeien> :) sorry
17:12:11 <koeien> it's german
17:12:35 <CakeProphet> answer?
17:12:41 <mmorrow> rwbarton, CakeProphet: here is rwbarton's brainfuck-to-elf-.o compiler darcsified/caballed http://moonpatio.com/repos/brain/
17:12:50 <koeien> no, n/m
17:13:03 <koeien> ive pasted a new version btw
17:14:08 <mmorrow> i added that Optimized datatype to aggregate e.g. [Inc,Inc,...,Inc] into [AddO n]
17:14:12 <koeien> but i'm going to bed now. CakeProphet: good luck
17:14:17 <CakeProphet> koeien:  thanks for the help.
17:14:32 <mmorrow> which turned  inc (Disp 0, eax) xN  into   add (Disp 0, eax) n
17:14:32 <Phyx-> :t GHC.HsLit
17:14:33 <lambdabot> Couldn't find qualified module.
17:14:39 <Phyx-> :t HsLit
17:14:40 <lambdabot> Not in scope: data constructor `HsLit'
17:15:15 <eu-prleu-peupeu> why is this happening: http://hpaste.org/13550 ?
17:15:24 <eu-prleu-peupeu> i have installed template haskell without problems
17:15:32 <sdubois92> I am having trouble installing cabal in Gentoo | http://dpaste.com/104748/
17:15:47 <mmorrow> eu-prleu-peupeu: what ghc version are you using?
17:16:03 <eu-prleu-peupeu> 6.10.1
17:16:23 <rwbarton> mmorrow: btw, prime.bf is not written by me, I found it on the web somewhere
17:16:50 <rwbarton> mmorrow: (I don't have a DOS machine on which I need to type Alt 1 0 for a newline :)
17:17:25 <mmorrow> haha
17:17:29 <mmorrow> :)
17:17:42 <bohdan> I don't get it: the point-free form is behaving *much* worse during profiling compared to point-full form:divisible n = (==0) . (n `mod`) vs x `divisible` k = x `mod` k == 0
17:18:09 <mmorrow> eu-prleu-peupeu: weird. i'm not sure what's going on. also, windows might have something to do with it (???)
17:18:23 <rwbarton> bohdan: compiling with -O2?
17:18:27 <bohdan> I get insane amounts of allocation with pointfree form
17:18:35 <bohdan> rwbarton, -O2 with profiling on
17:18:36 <mmorrow> eu-prleu-peupeu: ohh, you got that message while running haddock?
17:18:47 <bohdan> rwbarton, -auto-all -prof
17:19:05 <eu-prleu-peupeu> while doing a runhaskell Setup build
17:19:10 <rwbarton> bohdan: huh
17:19:19 <mmorrow> eu-prleu-peupeu: what package are you building?
17:19:27 <eu-prleu-peupeu> haddock
17:19:30 <mmorrow> oh
17:19:46 <mmorrow> i don't know. is this a darcs haddock or something?
17:19:54 <eu-prleu-peupeu> nops, from hackage
17:20:01 <eu-prleu-peupeu> i've learned not to use darcs :)
17:20:17 <mmorrow> hmm, that makes me think your template-haskell/ghc setup is borked or something
17:20:34 <mmorrow> i dunno though
17:20:35 <eu-prleu-peupeu> hmm template haskell installed fine
17:20:40 <eu-prleu-peupeu> ill try to install the previous version :P
17:20:48 <mmorrow> ohh, did you just /re/-install template-haskell?
17:20:56 <mmorrow> don't do that
17:21:11 <Myrth> so if there's a way to have incomplete expression like (10-) behave as lambda, is it possible to have (-) that would take 2 params, or have to do map (\(x,y)->x-y) (zip [1,2] [3,4]) ?
17:21:25 <rwbarton> Myrth: Yes, (-) :)
17:21:28 <rwbarton> :t (-)
17:21:29 <lambdabot> forall a. (Num a) => a -> a -> a
17:21:30 <mmorrow> eu-prleu-peupeu: if that's what you just did, then that's the cause of your linker errors
17:21:36 <Myrth> i was trying can't get syntax right
17:21:38 <rwbarton> Myrth: Also,
17:21:41 <rwbarton> :t zipWith
17:21:42 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:22:21 <Myrth> > map (10-) [1,2]
17:22:22 <lambdabot>   [9,8]
17:22:31 <Myrth> > map ((-)10) [1,2]
17:22:32 <lambdabot>   [9,8]
17:22:32 <mmorrow> eu-prleu-peupeu: and if so, (if it's not extremely painful/some other reason to do so) i'd suggest just reinstalling ghc and everything from scratch
17:22:50 <Myrth> map (-) [1,2] [3,4]
17:22:55 <Myrth> > map (-) [1,2] [3,4]
17:22:56 <lambdabot>   Couldn't match expected type `[t1] -> t'
17:23:02 <rwbarton> ((-)10) is ((-) 10) or \x -> (-) 10 x or \x -> 10 - x or (10-) :)
17:23:11 <mmorrow> the alternative is to try to figure out everything you need to rebuild by hand that links to template-haskell
17:23:15 <rwbarton> > zipWith (-) [1,2] [3,4]
17:23:16 <lambdabot>   [-2,-2]
17:23:33 <mmorrow> and even then, it's sketchy
17:23:33 <Myrth> ah
17:24:34 <eu-prleu-peupeu> dependencies checking seems so 1998 :/
17:24:38 <Myrth> gawd most of my time programming in haskell will be wasted choosing a way to do anything
17:24:44 <Phyx-> @hoogle baseTypecheck
17:24:44 <lambdabot> No results found
17:24:49 <Phyx-> ffs..
17:25:21 <sdubois92> I emerged cabal 1.6.0.1 and when i go to emerge yi, it wants to get cabal-1.1.6.2
17:25:34 <ziman> i spend much time thinking how to abstract things correctly, too ;)
17:25:46 <ziman> s/correctly/most appropriately/
17:26:03 <rwbarton> sdubois92: I haven't used Gentoo, but I would expect cabal install to work better than emerge for things from hackage
17:26:31 <mmorrow> sdubois92: that yi must be years old
17:27:27 <mmorrow> i'd (imo) ditch using emerge for haskell stuff, on account of that + the fact that the newest ghc in there was 6.6.1
17:27:54 <sdubois92> well, my problem involves cabal
17:27:54 <rwbarton> Wow, Debian looks downright modern compared to that :)
17:27:54 <ziman> sdubois92, i think you'll have to get the haskell portage overlay via layman and then emerge cabal-install
17:27:58 <sdubois92> so i can't use hackage
17:28:11 <rwbarton> ...
17:28:16 <ziman> i do it that way
17:28:46 <rwbarton> I can assure you you don't want cabal-1.1.6.2 :)
17:29:28 <Phyx-> is there any real up-to-date piece of information about the ghc api?
17:29:43 <mmorrow> Phyx-: the src code :/
17:29:50 <dmwit> Phyx-: :browse GHC
17:29:55 <dmwit> is about the best you can do =/
17:30:21 <Phyx-> i was afraid of that =/
17:31:55 <sdubois92> ziman: i already have the overlay, and im trying to get cabal-install but every version of http i try fails
17:32:02 <mmorrow> Phyx-: there are haddocks as well of course: http://www.haskell.org/ghc/dist/stable/docs/libraries/ghc/index.html
17:32:04 <sdubois92> this is pain
17:32:17 <rwbarton> sdubois92: what version of ghc do you have currently?
17:32:22 <ozy`> what's the precedence of (,)?
17:32:38 <rwbarton> ozy`: It doesn't have one
17:32:42 <sdubois92> rwbarton: 6.10.1
17:32:57 <ozy`> rwbarton: .... well why not?
17:33:17 <mmorrow> sdubois92: oh nice, did you get that from ghc's site?
17:33:23 <rwbarton> ozy`: How could it matter?
17:33:27 <sdubois92> mokus: no, portage
17:33:29 <rwbarton> ozy`: It's not an operator at all
17:33:29 <dmwit> ozy`: Because its special syntax means it never mixes with other operators.
17:33:33 <sdubois92> mmorrow: no, portage
17:33:38 <mmorrow> cool. i thought you still had 6.6.1
17:33:44 <sdubois92> i upgraded
17:33:45 <Phyx-> mmorrow: that's a start. changes are so radical, i can't even use any of the previous source
17:33:53 <ozy`> psst
17:33:56 <mmorrow> Phyx-: yeah, it's super volatile
17:34:05 <rwbarton> sdubois92: OK, now I suggest wget http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz and run the bootstrap.sh script contained therein
17:34:23 <ozy`> s/t/h/
17:34:26 <sdubois92> rwbarton: so i should try to use emerge?
17:34:29 <rwbarton> sdubois92: (unless you've also succeeded in installing cabal install)
17:34:36 <sdubois92> no
17:34:38 <sdubois92> http fails
17:34:43 <sdubois92> every release
17:34:48 <rwbarton> fails?
17:34:55 <sdubois92> ERROR: dev-haskell/http-3001.1.4 failed
17:35:01 <rwbarton> hmm :(
17:35:03 <chessguy_> > let foo "foo" = "bar" in foo "foo"
17:35:04 <lambdabot>   "bar"
17:35:10 <Axman6> ?ueser
17:35:11 <lambdabot> Maximum users seen in #haskell: 623, currently: 577 (92.6%), active: 20 (3.5%)
17:35:15 <rwbarton> do you have the ghc extralibs?
17:35:22 <chessguy_> > let foo "foo" = "bar" in foo "bar"
17:35:23 <Axman6> whoot
17:35:23 <lambdabot>   "* Exception: /tmp/3606993027612882666:71:36-52: Non-exhaustive patterns in...
17:36:08 <sdubois92> rwbarton: i dont see it in portage
17:36:22 <rwbarton> sdubois92: can you hpaste the entire output of bootstrap.sh?
17:36:22 <Phyx-> well, i'm off to bed, i'll continue again tomorow, thanks for the haddock link mmorrow , that's a little nicer than looking at the source
17:36:33 <mauke> rwbarton: hpaste is a bad choice
17:36:35 <sdubois92> rwbarton: i didnt get that file yet
17:36:58 <rwbarton> sdubois92: oh?  I thought you had tried what I suggested and it failed.
17:37:06 <mmorrow> Phyx-: for sure, lemme know how it goes with the ghc-api
17:37:07 <sdubois92> no, the ebuild fails
17:37:10 <rwbarton> sdubois92: oh I see.
17:37:15 <rwbarton> sdubois92: Yeah, I misinterpreted
17:37:49 <Phyx-> mmorrow: i will, thanks, good night
17:37:53 <mmorrow> night
17:39:24 <sdubois92> rwbarton: http://dpaste.com/104751/ cabal-install needs http, and the emerge http fails http://dpaste.com/104751/
17:39:59 <rwbarton> sdubois92: looks like missing extralibs
17:40:08 <rwbarton> sdubois92: (network and parsec)
17:40:15 <sdubois92> come again?
17:40:26 <rwbarton> sdubois92: Where did you download ghc-6.10.1 from?
17:40:32 <mauke> sdubois92: those are the same link
17:40:34 <sdubois92> portage
17:40:40 <rwbarton> ugh
17:40:41 <rwbarton> :P
17:40:46 <rwbarton> get the extralibs also :P
17:40:59 <sdubois92> i dont see extralibs on hackagedb
17:40:59 <mauke> I installed cabal without extralibs
17:41:01 <rwbarton> (Sorry, I just don't know anything about portage so I can't be helpful)
17:42:00 <jeffz`> @users
17:42:01 <lambdabot> Maximum users seen in #haskell: 623, currently: 571 (91.7%), active: 17 (3.0%)
17:42:07 <pumpkin> wow
17:42:21 <rwbarton> sdubois92: can you hpaste the output of ghc-pkg list?
17:42:59 <sdubois92> http://dpaste.com/104752/
17:43:06 <CakeProphet> rwbarton:  I'm tempted to give up and just use parsec.
17:43:14 <CakeProphet> my brain is melting.
17:43:42 <mmorrow> sdubois92: http://haskell.org/ghc/dist/6.10.1/ghc-6.10.1-i386-unknown-linux-libedit2.tar.bz2
17:44:05 <CakeProphet> rwbarton:  do you still have the parser you made with parsec?
17:44:28 <rwbarton> CakeProphet: Yeah. mmorrow pasted a link
17:44:50 <mauke> I don't know what's going on but 'emerge -va dev-haskell/network dev-haskell/http' should give you the missing libraries
17:45:29 <rwbarton> Parsec should be included in the extralibs though, right guys?
17:45:39 <rwbarton> I'm not crazy here? :)
17:45:48 <dmwit> CakeProphet: What's melting your brain, out of curiosity?
17:46:16 <CakeProphet> I can parse the tokens... I just can't get the ]'s now to refer back to their corresponding [
17:47:56 <dmwit> CakeProphet: What are you doing?  BF interpreter by hand?
17:48:08 <CakeProphet> mhm.
17:48:09 <dmwit> (recursive descent or something)?
17:48:12 * dmwit nods
17:48:12 <chrisdone> the Data.Time module just made me throw my hands up in the air and shout NIIICE. so easy to use
17:48:13 <CakeProphet> yeah
17:48:14 <mauke> ENTERPRISE BBCODE INTERPRETER
17:48:43 <chrisdone> \[b]you must support backslash and [spoiler]spoilers[/spoiler][/b]
17:48:49 <mriou> hi there, parsec is giving me a hard time, I'm hoping to find some help here
17:48:58 <mauke> chrisdone: [/b]?
17:49:00 <dmwit> mriou: Shoot! =)
17:49:08 <mriou> in my small language different lines should be in different statements but they all end up in the same
17:49:14 <mriou> the parser's here: http://haskell.pastebin.com/d51201b9e
17:49:16 <CakeProphet> dmwit:  whole parser: http://hpaste.org/13551
17:49:35 <chrisdone> mauke: ‽
17:49:36 <mriou> only the root rule is really important
17:49:42 <dmwit> CakeProphet: waugh!
17:49:43 <mauke> chrisdone: it's unmatched
17:49:55 <mriou> I've pasted everything just in case
17:50:15 <dmwit> CakeProphet: Ah, never mind, that's reasonably sane.
17:50:16 <chrisdone> mauke: proper parsers will ignore unmatched ~_~
17:50:29 <dmwit> A little strange, yes, but reasonably sane.
17:50:48 <mauke> mriou: \r and \n are whitespace
17:50:57 <mauke> I bet that's the main problem
17:50:58 <CakeProphet> dmwit:  oops, forgot to get rid of isOp
17:51:03 <CakeProphet> dmwit:  strange you say?
17:51:17 <chrisdone> is brainfuck some kind of turing machine similator?
17:51:21 <mriou> mauke: so the lexeme ignores them? I've looked at the source for whiteSpace though
17:51:24 <dmwit> mriou: I bet try (string "\r") >> string "\n" doesn't do what you think it does.
17:51:33 <mauke> well, that too :-)
17:51:45 <mriou> I've tried other things as well like just "newline"
17:51:50 <mauke> mriou: I think your lexer will skip right over \n
17:51:52 <mriou> didn't change anything
17:52:01 <mriou> mauke: why?
17:52:16 <sjanssen> CakeProphet: so what is the problem?  The parser seems okay
17:52:35 <mauke> hmm, maybe not
17:52:44 <rwbarton> sdubois92: The extralibs are available here: http://haskell.org/ghc/dist/6.10.1/ghc-6.10.1-src-extralibs.tar.bz2
17:52:48 <mauke> chrisdone: you don't know brainfuck?
17:52:53 <mauke> shame
17:52:58 <CakeProphet> sjanssen: it works... but my interpreter can't figure out how to jump back to the [ that corresponds to a ]
17:53:10 <mriou> and if you change eol in root to newline the pb is the same so that's not sthing wrong with eol
17:53:35 <CakeProphet> because the ] aren't tokenized... and if they were, I'd need to find some way to have them refer back to their [ token
17:53:43 <mriou> or at least what's wrong with eol isn't my pb :)
17:53:45 <sjanssen> CakeProphet: oh, you need to keep a stack of programs to jump back to
17:54:10 <dmwit> mriou: That looks like it wouldn't type to me.
17:54:24 <dmwit> mriou: ah, never mind me
17:54:37 <dmwit> mriou: I'm pretty sure the problem is in eol.
17:54:48 <CakeProphet> sjanssen:  yeah, but the way the parser works now... you can't pop a While token onto the stack because you need to call parse first so you can append the result to the While
17:55:05 <mriou> dmwit: maybe but as I said if I remove it and use newline instead of eol, pb is the same
17:55:07 <CakeProphet> it's a mutual dependency sort of thing
17:55:08 <dmwit> mriou: Try changing "wyParser = whitespace >> root >>= \x -> eof >> return x" to see what I mean.
17:55:39 <sdubois92> rwbarton: where do i put those files?
17:55:42 <sjanssen> CakeProphet: your parser is fine
17:55:47 <sdubois92> oh
17:55:55 <sdubois92> i compile each one of those individually?
17:56:02 <CakeProphet> sjanssen:  your saying the interpreter needs this stack?
17:56:04 <sjanssen> CakeProphet: you just need to add an additional argument to interpret of type [[Token]]
17:56:05 <rwbarton> sdubois92: Well, the instructions on the web page are to unpack them on top of your ghc source tree before building it
17:56:08 <sjanssen> CakeProphet: yes
17:56:10 <dmwit> mriou: What does "semi" do?
17:56:15 <rwbarton> sdubois92: I don't know how that will interact with emerge
17:56:15 <sdubois92> ok
17:56:22 <mriou> consumes a semicolon
17:56:27 <dmwit> right
17:56:29 <CakeProphet> sjanssen:  or just type [Token]... since they'll all be constructed with While...
17:56:44 <mriou> dmwit: statements end with a new line or ;
17:56:51 <sdubois92> this is a pain
17:56:53 <sjanssen> CakeProphet: yeah, that would be okay
17:56:55 <sdubois92> i'll deal with it later
17:56:56 <bohdan> mapM_ is lazy, right?
17:56:57 <sdubois92> bye
17:56:59 * dmwit nods
17:57:14 <dmwit> bohdan: As lazy as the monad allows it to be, I guess.
17:57:43 <bohdan> output = mapM_ $ (>> printLn) . mapM_ print -- this seems to be allocating lots of stuff
17:58:02 <bohdan> output :: [[Int]] -> IO ()
17:58:03 <mriou> dmwit: with your modification I get: The lambda expression `\ x -> eof >> return x' has one argument, but its type `GenParser Char st b' has none
17:58:43 <bohdan> the input is a list of several huge lists
17:58:51 <dmwit> mriou: Did you make use (>>=) and not (>>)?
17:59:32 <dmwit> bohdan: Are you sure it's not allocating in the construction of the list?
17:59:44 <mriou> dmwit: oops sorry, my bad
17:59:46 <dmwit> If later elements depend on earlier ones, it might have to keep the list in memory...
18:00:02 <bohdan> that's not what profiler says, I assumes it handles this correctly
18:00:47 <mriou> dmwit: runs now but the output is the same, things on different lines still end up in the same statement
18:00:47 <rwbarton> bohdan: Well, print has to do some allocation
18:01:48 <redditbot> New: parse OSX binaries in Haskell
18:01:54 <bohdan> but it allocates about 200x the size of the stuff it prints
18:01:56 <rwbarton> bohdan: you could try changing to  putStrLn . unlines . map (unlines . map show) or whatever
18:01:57 <mriou> same thing with "root = liftM ASTBlock $ stmt `sepBy1` (many1 newline <|> semi)"
18:02:11 <mriou> it's like something is eating these new lines
18:02:14 <rwbarton> bohdan: just to see what happens
18:03:52 <rwbarton> bohdan: you can also inspect the core
18:04:19 <rwbarton> bohdan: Well, that probably won't help much
18:07:16 <bohdan> rwbarton, I've simplified output to be :: [Int] -> IO ()
18:07:21 <bohdan> I'll try your suggestion now
18:08:14 <dmwit> mriou: I'm not sure.  Things look reasonable to me.
18:08:24 <dmwit> mriou: What exactly is the problem?
18:08:32 <mriou> dmwit: to me too :)
18:08:32 <dmwit> (remind me)
18:09:11 <mriou> dmwit: if I give as an input "foo\nbar\nbaz\n" I expect the 3 ids to be in different statements
18:09:18 <mriou> but they end up in the same
18:09:35 <bohdan> rwbarton, that didn't help much
18:09:36 <mriou> so I get ASTBlock [ASTStmt [ASTId "foo",ASTId "bar",ASTId "baz"]]
18:09:57 <mriou> where I would expect 3 ASTStmt, each with an ASTId
18:10:08 <mauke> fucking hell
18:10:16 <dmwit> mriou: Likely the "identifier" lexer eats whitespace.
18:10:50 <rwbarton> @src print
18:10:51 <lambdabot> print x = putStrLn (show x)
18:11:15 <mriou> dmwit: eating whitespace is fine, it's eating newline my problem and I don't think it does
18:11:24 <dmwit> Test it? ;-)
18:11:37 <rwbarton> mriou: a newline *is* whitespace
18:11:56 <dmwit> Since you're starting with the Java lexer, which *definitely* eats newlines, you should definitely test that assumption.
18:12:08 <mriou> rwbarton: in parsec? that's not what the sources say
18:12:10 <chrisdone> hm. I'm getting ``No instance for (IsString ByteString)'' on ghc6.10 with bytestring-0.9.1.4 even though I can see clearly in the bytestring docs that there is an IsString instance. any ideas?
18:12:15 <rwbarton> mriou: really? hmm
18:12:22 <dmwit> mriou: uh, are you sure?
18:12:28 <eu-prleu-peupeu> anyone here using freeBSD ?
18:12:37 <imphasing> In haskell, is a list just a series of tuples? The (1:(2:[])) notation makes me think so..
18:12:37 <sjanssen> chrisdone: the instance is in Data.ByteString.Char8; did you import that?
18:12:50 <mauke> *> parseTest (whiteSpace lexer >> anyChar) "\nhi"
18:12:50 <mauke> 'h'
18:12:53 <baaba> @src []
18:12:53 <lambdabot> data [] a = [] | a : [a]
18:12:54 <dmwit> mriou: The "spaces" combinator doesn't eat newlines, but this isn't using "spaces", it's using whatever is defined in the lexer description.
18:12:56 <baaba> @src (,)
18:12:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:12:56 <mriou> dmwit, rwbarton: http://haskell.pastebin.com/m26cdc278
18:12:58 <mauke> mriou: therefore you're wrong
18:12:59 <sjanssen> imphasing: no, a list is a series of cons cells
18:13:00 <chrisdone> sjanssen: oh. no, I didn't. thanks
18:13:03 <baaba> @src ,
18:13:03 <lambdabot> Source not found. You untyped fool!
18:13:05 <baaba> :<
18:13:21 <chrisdone> sjanssen: can you explain why that is so please?
18:13:23 <imphasing> sjanssen, So there aren't any tuples involoved? The notation is just coincidence?
18:13:38 <dmwit> mriou: '\n' satisfies isSpace
18:13:42 <baaba> imphasing, (,) is the tuple type and value constructor
18:13:42 <dmwit> > isSpace '\n'
18:13:44 <lambdabot>   True
18:13:52 <dmwit> mriou: So whiteSpace definitely eats newlines.
18:13:58 <mriou> dmwit: bummer
18:13:58 <baaba> imphasing, (:) is the list cons value constructor
18:14:03 <mriou> didn't know that :)
18:14:06 <rwbarton> imphasing: You could also write (:) 1 ((:) 2 [])
18:14:08 <imphasing> baaba, Hmm..
18:14:10 <baaba> and [] is the nil value
18:14:11 * imphasing reads more
18:14:12 <mauke> <mauke> mriou: \r and \n are whitespace
18:14:16 <baaba> [] is also the list type constructor :P
18:14:17 <sjanssen> chrisdone: Char8 is the module that gives you the view of ByteString as a sequence of characters, so the instance that enables character string literals is in Char8
18:14:36 <sjanssen> imphasing: the structure of a list is somewhat similar to nested tuples, but the type is different
18:14:40 <baaba> :t [] :: [] Int
18:14:41 <lambdabot> [Int]
18:14:44 <mriou> mauke, dmwit: thanks for showing me the light :)
18:14:47 <imphasing> baaba, ooooh... so the parens are just for proper precedence?
18:14:54 <rwbarton> bohdan: are you talking about total allocation or simultaneous allocation (heap size)?
18:14:56 <baaba> they're unnecessary actually
18:14:58 <dublpaws> oto = (a -> a)     ...later...     f2g :: oto -> oto   is anything about that realm of substitution allowed?
18:14:59 <baaba> > 1:2:[]
18:15:01 <lambdabot>   [1,2]
18:15:08 <dmwit> dublpaws: yes
18:15:08 <mriou> I'll see if I can change that simpleSpace rule
18:15:09 <imphasing> baaba, Ah, okay. I get it now. Thanks :)
18:15:14 <dmwit> dublpaws: See the "type" keyword.
18:15:24 <dublpaws> dmwit: ok, thanks
18:15:24 <bohdan> rwbarton, total size
18:15:29 <rwbarton> bohdan: oh
18:15:30 <dmwit> dublpaws: However, no free type variables are allowed.
18:15:39 <baaba> > (,,) 1 '2' "3"
18:15:39 <rwbarton> bohdan: is that a particular concern then? :)
18:15:40 <lambdabot>   (1,'2',"3")
18:15:40 <chrisdone> sjanssen: do you think this documentation is wrong then? http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Lazy.html#1
18:15:41 <dmwit> dublpaws: So for that example, it would be "type oto a = a -> a".
18:15:48 <baaba> :t (,,) 1 '2' "3"
18:15:49 <lambdabot> forall t. (Num t) => (t, Char, [Char])
18:15:51 <dmwit> "f2g :: oto a -> oto a"
18:15:54 <rwbarton> bohdan: I mean, Strings are kind of expensive memory-wise, but the allocator is very fast
18:16:08 <dublpaws> dmwit: ok, got it :)
18:16:12 <rwbarton> dublpaws: Actually it would be "type Oto a = a -> a"
18:16:18 <dmwit> oy
18:16:24 <dmwit> rwbarton is right, of course
18:16:32 <mauke> mriou: I'd try something like P.whiteSpace = \c -> isSpace c && c /= '\n' in javaStyle
18:17:25 <chrisdone> sjanssen: it seems like haddock has got it wrong on the instances?
18:17:29 <bohdan> rwbarton, I'm just profiling my program, and 90% of allocation in one place caught my eye
18:18:04 <rwbarton> bohdan: if the rest of your program is tight non-allocating loops that's very possible
18:19:09 <sjanssen> chrisdone: what does it say?
18:19:18 <rwbarton> bohdan: that divisible thing is mysterious to me, unless somehow one version is doing dictionary passing and the other is specialized to Int
18:19:42 <mriou> mauke: the qualified name and the in don't seem to work, or that shouldn't be in the top level?
18:19:51 <chrisdone> sjanssen: it says "Instances of Eq, Ord, Read, Show, Data, Typeable", written by someone manually, and then below the usual list of instances, including IsString ByteString and Monoid ByteString
18:19:53 <bohdan> rwbarton, it only happens when profiling
18:19:54 <CakeProphet> > let (s:ss) = [[]] in (s,ss)
18:19:55 <lambdabot>   ([],[])
18:20:04 <mriou> mauke: forget that, I'm stupid
18:20:07 <sjanssen> chrisdone: oh, haddock treats instances as global, which is a bit of a bug
18:20:14 <CakeProphet> beautiful
18:20:15 <chrisdone> sjanssen: ahh, I see. ok
18:21:51 <chrisdone> I'm wondering about this "All Chars will be truncated to 8 bits" part of Data.ByteString.Char8. this will screw up unicode, won't it?
18:22:15 <sjanssen> chrisdone: yes
18:22:34 <chrisdone> hm
18:22:37 <SamB_XP> very much so ;-P
18:22:48 <mauke> chrisdone: it's effectively latin-1
18:23:25 <rwbarton> chrisdone: hence the "Byte" in "ByteString" :)
18:23:31 <chrisdone> oh
18:23:38 <mriou> mmmh whiteSpace isn't a field in LanguageDef
18:24:44 <mauke> it ain't?
18:24:53 <mauke> oh crap
18:25:15 <chrisdone> so if I want to use unicode with bytestrings, I have to store them flatly as, say, UTF-8 and then encode them into Strings when doing proper string operations and then pack them back into bytestrings afterwards?
18:25:30 <dmwit> mriou: It's in TokenParser.
18:25:34 <mauke> chrisdone: no, you DEcode them to Strings and ENcode to bytes
18:25:48 <chrisdone> er, yeah
18:26:04 <mauke> mriou: you're pretty much screwed, I think
18:26:06 <chrisdone> isn't that kind of slow?
18:26:14 <dmwit> Although, modifying that probably won't help.
18:26:15 <mauke> LanguageDef doesn't seem to allow for line-based syntax
18:26:24 <mriou> mauke: good to know :)
18:26:30 <rwbarton> mriou: a radical suggestion: split your input into lines with 'lines' before parsing :)
18:26:53 <rwbarton> (unless that won't work at all, of course)
18:27:23 <mriou> rwbarton: probably too radical in my case :) at some point I'd like to have newlines in specific locations in the middle of a statement
18:28:25 <mauke> I've always written my parsers from scratch, using characters as tokens
18:29:01 <dmwit> Writing your own lexer in Parsec isn't actually all that painful.
18:29:25 <mriou> dmwit, mauke: I might end up doing that
18:29:57 <mriou> but did I dream or there's a way to override a record field when creating it with makeTokenParser
18:29:59 <mriou> ?
18:31:46 <bohdan> why do I get lots of allocations for [a,a+2..b] and 10x less for [a..b] ?
18:32:45 <bohdan> there really should not be any difference because I'm doing 'filter foo [a..b]'
18:33:05 <bohdan> and foo is never true for even numbers (a is odd)
18:33:37 <rwbarton> bohdan: how big is your source?  can you hpaste it?
18:33:51 <rwbarton> bohdan: these questions are hard to answer locally
18:34:23 <bohdan> rwbarton, sure, sec.
18:36:09 <chessguy> @hoogle when
18:36:09 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
18:36:45 <rwbarton> bohdan: actually just see the source for efdtInt in http://haskell.org/ghc/docs/6.8.2/html/libraries/base/src/GHC-Enum.html
18:38:29 <bohdan> rwbarton, at least the comment implies that [a,b case is less optimized
18:38:36 <rwbarton> bohdan: right
18:39:06 <bohdan> http://hpaste.org/13553
18:39:24 <chessguy> @type get
18:39:25 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
18:39:54 <chessguy> @hoogle (s -> t) -> m s -> t
18:39:54 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:39:54 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:39:54 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:40:17 <rwbarton> bohdan: divisible :: Integer -> Integer -> Bool right?
18:40:40 <rwbarton> bohdan: oh never mind that
18:41:02 <rwbarton> bohdan: I suggest specifying the types you're going to use just to help out the compiler a little.  divisible :: Int -> Int -> Bool, etc.
18:41:03 <bohdan> rwbarton, this is the most optimized version
18:41:53 <bohdan> rwbarton, re: adding types -- I tried that, and it didn't seem to help
18:42:22 <rwbarton> bohdan: It might have helped with your more point-free version of divisible, possibly.
18:42:22 <bohdan> rwbarton, it would also be annoying if I would want to change to Integer to support larger values (which would kill performance I presume)
18:42:31 <rwbarton> bohdan: also are you doing SPOJ? :)
18:42:38 <bohdan> rwbarton, yeah :)
18:42:44 <rwbarton> bohdan: is SPOJ still on ghc 6.6.1?
18:42:49 <mauke> oh, which one?
18:42:55 <bohdan> rwbarton, they have this terrible old machine too
18:42:59 <bohdan> rwbarton, I believe so
18:43:07 <bohdan> mauke, the second one :)
18:43:10 <bohdan> mauke, prime1
18:43:25 <mauke> hmm, I did that one in C
18:43:39 <bohdan> mauke, yeah I'm trying to learn haskell you know :)
18:43:52 <bohdan> the goal is not to do SPOJ :)
18:43:56 <mauke> hmm, maybe I should rewrite it in Haskell :-)
18:43:57 <SamB_XP> what's SPOJ ?
18:44:03 <bohdan> www.spoj.pl
18:44:12 <SamB_XP> oh, some perl thing huh ?
18:44:15 * SamB_XP teases
18:44:16 <bohdan> like acm.uva.es but cooler
18:44:22 <dmwit> ?wiki primes
18:44:23 <lambdabot> http://www.haskell.org/haskellwiki/primes
18:45:09 <rwbarton> bohdan: my solution for that is disgusting :P
18:45:36 <bohdan> dmwit, I think input constraints make the speed of prime generation not too important
18:45:42 <chessguy> @pl a p = u p >> c
18:45:42 <lambdabot> a = (>> c) . u
18:45:50 <bohdan> dmwit, because it's enough to generate primes to sqrt $ 10^9
18:45:57 <bohdan> *up to
18:46:14 <bohdan> rwbarton, how so? :)
18:46:31 <rwbarton> bohdan: for example, it uses unsafePerformIO :)
18:46:39 <bohdan> one thing I've learned that seemingly innocent things really affect the performance but an order of magnitude
18:46:41 <rwbarton> bohdan: I hope it's because ST is broken on the SPOJ machine
18:47:11 <bohdan> s/but/by
18:47:30 * bohdan shouldn't be awake now
18:47:50 <rwbarton> bohdan: oh, actually I used ST first and I was just testing to see whether IO was faster (not really)
18:49:09 <bohdan> wait, threads?
18:49:40 <bohdan> I have no idea what ST is but why do you except to need threads for this problem?
18:49:50 <bohdan> they are probably running this on SMP anyway
18:50:02 <rwbarton> bohdan: I don't think I said anything about threads
18:50:03 <bohdan> err SP
18:50:08 <rwbarton> bohdan: ST /= STM?
18:50:10 <juturnas> How would you take the first element of a list that satisfies some predicate?
18:50:10 <bohdan> what is ST then?
18:50:13 <chessguy> @pl f p = g p >> h p
18:50:13 <lambdabot> f = liftM2 (>>) g h
18:50:18 <mauke> juturnas: head . filter p
18:50:18 <bohdan> state threads?
18:50:29 <mauke> bohdan: local mutable variables
18:50:39 <mauke> or is that locally mutable?
18:50:41 <bohdan> find
18:51:06 <mauke> basically, it lets you use mutable variables inside as long as your interface stays pure
18:51:33 <bohdan> nasty, but why do you need mutable variables? :)
18:51:37 <rwbarton> Or more excitingly, mutable arrays
18:51:54 <ikegami__> @src foldl'
18:51:54 <lambdabot> foldl' f a []     = a
18:51:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:51:57 <mauke> to make a prime sieve
18:53:12 <bohdan> you don't really generate primes up to 10^9 there, do you?
18:53:23 <rwbarton> bohdan: nope just the square root
18:53:34 <bohdan> rwbarton, you don't need any tricks for that then
18:53:43 <rwbarton> bohdan: I don't know whether it matters but even as it was my program used 75% of the time limit
18:54:06 <rwbarton> bohdan: but that could just be IO or something I guess.
18:54:23 <chessguy> @pl u p s = u' p (u'' p s)
18:54:23 <lambdabot> u = liftM2 (.) u' u''
18:54:37 <bohdan> anyways, any more tips on tweaking http://hpaste.org/13553 ?
18:54:47 <bohdan> in particular, divisible is taking 50% of time
18:54:58 <mauke> whoa, you're generating primes at runtime?
18:54:58 <bohdan> with 200M calls :)
18:55:10 <mauke> my C program just uses a precomputed array
18:55:20 <bohdan> mauke, it doesn't matter
18:55:35 <bohdan> mauke, not for the current program at least :)
18:55:51 <bohdan> come on how hard do you think it is to generate primes up to 33000
18:55:58 <bohdan> > sqrt $ 10 ^ 9
18:55:59 <lambdabot>   31622.776601683792
18:56:09 <chessguy> @pl u p = v p . w p
18:56:09 <lambdabot> u = liftM2 (.) v w
18:56:41 <rwbarton> bohdan: rem is faster than mod
19:00:20 <CakeProphet> wooo... bf interpreter: http://hpaste.org/13554
19:01:16 <bohdan> rwbarton, no -- it seems to make things about 8x slower
19:02:52 <bohdan> CakeProphet, now write a bf interpreter in bf
19:03:07 <bohdan> CakeProphet, and haskell to bf compiler
19:03:14 <CakeProphet> it'll look like most other bf interpreters in bf
19:03:28 <dmwit> CakeProphet: NICE
19:03:32 <bohdan> CakeProphet, and a bf VM :)
19:03:46 <dmwit> CakeProphet: Package it up as Language.BF and put it on Hackage. =)
19:03:48 <bohdan> CakeProphet, and then a bf VM in bf
19:04:03 <mauke> it's dangerous to go alone; take this bf compiler: http://mauke.ath.cx/stuff/perl/bfc.pl
19:04:17 <pumpkin> lol
19:04:37 * CakeProphet is pleased with the cleaness of the interpreter portion, even though the compiler is kind of ugly.
19:04:44 <dmwit> Is that... is there *assembly* in that perl?
19:04:47 <CakeProphet> s/compiler/parser
19:05:01 <mauke> dmwit: of course
19:05:04 <mauke> it's a compiler!
19:05:36 <bohdan> is there a core beautifier?
19:05:47 <ddarius> Yes
19:05:52 <bohdan> where?
19:05:53 <bohdan> :)
19:05:54 <ddarius> @google ghc-core
19:06:12 <lambdabot> Plugin `search' failed with: thread killed
19:06:20 <ddarius> @hackage ghc-core
19:06:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-core
19:07:17 <rwbarton> bohdan: I took my old program and replaced mod by rem and it got about 15% faster
19:07:52 <bohdan> rwbarton, possibly :) but for this particular program it made things way slower
19:08:02 <rdeshpande> wow coming from coding ruby all day haskell is really interesting
19:08:18 <rwbarton> bohdan: seriously it's just a simpler operation.  Something else is wrong.
19:09:00 <rdeshpande> q; does lazy evaluation mean that short circuit functions (a || b) would be faster in haskell than in a language with strict evaluation?
19:09:05 <rdeshpande> (assuming a is true)
19:09:43 <bohdan> ghc-core.hs:36:30:    Module `System.Process' does not export `readProcess' -- does this mean 6.8.2 is too old for this?
19:09:50 <sjanssen> rdeshpande: no difference, probably
19:09:59 <Asztal> they usually have special cases for && and ||
19:10:20 <rwbarton> bohdan: Hmm, I'm using ghc-core on 6.8.2
19:10:43 <bohdan> rwbarton, ok maybe I should install it in a proper way
19:10:45 <sjanssen> rdeshpande: the real distinction is that in a lazy language, short circuiting is the default.  In strict languages, && and || are magic operators that can't be implemented by the user
19:10:47 <rwbarton> bohdan: ghc-core-0.4, if it matters
19:13:34 <Kernel_Sanders> sjanssen: that's not true.  && and || are just a shortened version of nested if's
19:14:09 <mauke> Kernel_Sanders: what is not true?
19:14:21 <Kernel_Sanders> the magic operator part
19:14:29 <rwbarton> Well, in most languages, you can't implement operators period.
19:14:37 <mauke> Kernel_Sanders: I don't get it
19:15:08 <rwbarton> Kernel_Sanders: You cannot write f(x, y) such that f(x, y) = x || y, and f(x, y) doesn't evaluate y if x is true
19:15:33 <Kernel_Sanders> if(x) return true; else return y
19:15:41 <Kernel_Sanders> y doesnt get evalutated if x is true
19:15:45 <Olathe> Kernel_Sanders: You can do a lot in assembly language.
19:15:46 <rwbarton> ... try it
19:15:48 <Kernel_Sanders> it's shorter, but not impossible to do
19:15:50 <mauke> Kernel_Sanders: yes, it is
19:16:04 <rwbarton> f(1, printf("oops"));
19:16:06 <pumpkin> @hoogle STArray
19:16:06 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
19:16:06 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
19:16:06 <lambdabot> Data.Array.Base listArrayST :: Ix i => (i, i) -> [e] -> ST s (STArray s i e)
19:16:38 <Olathe> Kernel_Sanders: But I'm not sure most people want to use it that frequently.
19:17:10 <dmwit> Kernel_Sanders: Liar!
19:17:14 <Olathe> Kernel_Sanders: In the same way, you can manually write nested ifs outside any function, but it's a bit easier not to have to.
19:17:26 <dmwit> Kernel_Sanders: "if(x) return true; else return y" isn't a function at all!
19:17:42 <pumpkin> I can't find any info on STArray
19:17:46 <pumpkin> @docs STArray
19:17:46 <lambdabot> STArray not available
19:17:55 <rwbarton> I assumed that was the body of int f(int x, int y) { ... }
19:17:56 <dmwit> pumpkin: It's all in the Array and MArray interfaces.
19:18:00 <pumpkin> ah okay
19:18:03 <pumpkin> @docs Array
19:18:04 <lambdabot> Array not available
19:18:07 <Olathe> Kernel_Sanders: In C and Java and so on, all arguments to functions are evaluated before the body of the function is entered.
19:18:12 <Kernel_Sanders> Olathe: of course, my point was that && and || do not do any magic
19:18:12 <dmwit> pumpkin: err... IArray
19:18:18 <mauke> Kernel_Sanders: they do
19:18:33 <mauke> Kernel_Sanders: they have special evaluation rules
19:18:33 <Olathe> Kernel_Sanders: && and so on do not evaluate both arguments before giving results.
19:18:36 <pumpkin> Kernel_Sanders: your nick sounds familiar
19:18:38 <sjanssen> Kernel_Sanders: their syntax is magic, can you write a function or operator that doesn't evaluate its arguments in Java?
19:18:48 <Olathe> Kernel_Sanders: But this is testable, as others have said.
19:18:50 <Kernel_Sanders> a function no, a set of if's yes
19:18:52 <sjanssen> pumpkin: think "extra crispy"
19:19:04 <pumpkin> sjanssen: no, I mean on IRC :P
19:19:04 <mauke> Kernel_Sanders: 'if' is also magic
19:19:09 <Olathe> Kernel_Sanders: Sure.
19:19:16 <Kernel_Sanders> if you substitute if's for the || if wont evaluate y
19:19:20 <Kernel_Sanders> if you call a function it will
19:19:24 <Olathe> Kernel_Sanders: But that's what makes Haskell nice. You don't need to write a bunch of nested ifs.
19:19:26 <Kernel_Sanders> that's a different issue though
19:19:28 <Kernel_Sanders> of course
19:19:35 <Kernel_Sanders> lazy has lots of advantages
19:19:37 <mauke> Kernel_Sanders: you can't write 'if' yourself, so you don't win anything
19:19:44 <Kernel_Sanders> I'm just saying - there's no magic in &&
19:19:55 <mauke> Kernel_Sanders: yes, and you're wrong
19:19:57 <sjanssen> Kernel_Sanders: but now we've just moved the problem from || operators to if expressions
19:19:57 <Olathe> Kernel_Sanders: I don't think you understand what they mean by magic.
19:20:10 <Olathe> Kernel_Sanders: It doesn't mean impossible by other means.
19:20:26 <Kernel_Sanders> i guess i misunderstood then\
19:20:41 <Olathe> Kernel_Sanders: They mean that it's a "function" that works differently from others.
19:20:56 <Olathe> Kernel_Sanders: Other functions can't do that lazy evaluation.
19:21:26 <rwbarton> This is probably so obvious that it becomes confusing :)
19:21:32 <sjanssen> hmm, I wonder how the MLs handle &&?
19:21:37 <pumpkin> aha, they hidded it http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Arr.html#t%3ASTArray
19:21:44 <mauke> sjanssen: magic (at least OCaml)
19:21:51 <sjanssen> is && a function in ML, or is it strictly syntax?
19:21:54 <rwbarton> pumpkin: I think STArray is in Data.Array.STArray or Data.Array.ST or something
19:22:02 <mauke> #define OR(x, y) ((x) ? 1 : (y))
19:22:12 <pumpkin> rwbarton: only place I could find it was in the link I pasted
19:22:56 <pumpkin> http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-ST.html
19:22:58 <pumpkin> aha
19:22:59 <rwbarton> pumpkin: it must be re-exported by something else
19:23:03 <pumpkin> you were right!
19:23:28 <pumpkin> ah, this is different
19:23:36 <pumpkin> so the actual STArray comes from ghc-arr
19:23:39 <rwbarton> You shouldn't ordinarily need to muck around with GHC.*
19:23:56 <rwbarton> Well, pretty much everything does ultimately
19:24:00 <pumpkin> ah :)
19:24:01 <rwbarton> GHC.* I mean
19:24:01 <mauke> sjanssen: in OCaml it's a function, but the magic only happens for that exact name and function
19:24:18 <ManateeLazyCat> How to exit from haskell program.
19:24:18 <ManateeLazyCat> ?
19:24:22 <mauke> sjanssen: i.e. it'll evaluate the operands if you bind it to another name or you bind another function to (||)
19:24:32 <mauke> ManateeLazyCat: return from main
19:24:40 <mauke> @hoogle exitWith
19:24:40 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
19:24:41 <ManateeLazyCat> mauke: Thanks
19:24:42 <ikegami__> Thank lambdabot very much, see you
19:24:59 <sjanssen> mauke: thanks
19:25:10 <bohdan> dons, I get Module `System.Process' does not export `readProcess' when installing ghc-core-0.4.1 on 6.8.2
19:27:08 <rwbarton> pumpkin: aha... there's no haddock for STArray in Data.Array.ST because the import is wrapped in #ifdef __GLASGOW_HASKELL__
19:27:14 <pumpkin> :O
19:27:19 <pumpkin> evil!
19:27:23 <pumpkin> they were trying to hide from me
19:27:29 <pumpkin> thank you :)
19:40:17 <mmorrow> preflex: seen Heffalump
19:40:17 <preflex>  Heffalump was last seen on #haskell 2 hours, 35 minutes and 34 seconds ago, saying: yes, pattern matching is better style
19:40:39 <CakeProphet> is there a partially-applyable version of if/then/else?
19:41:02 <rwbarton> Not in any of the standard libraries
19:41:22 <CakeProphet> wouldn't be hard to make.
19:41:33 <CakeProphet> it's just nice to have a standard one
19:41:46 <mmorrow> @tell Heffalump this looks useful (Id module from helium) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=715#a715
19:41:46 <lambdabot> Consider it noted.
19:41:46 <bohdan> @type if'
19:41:47 <lambdabot> Not in scope: `if''
19:41:57 <bohdan> @hoohle if'
19:41:57 <lambdabot> No results found
19:42:00 <rwbarton> @type bool
19:42:01 <lambdabot> Not in scope: `bool'
19:42:22 <bohdan> whatever, but I remember seeing if' :)
19:42:34 <rwbarton> from @pl probably
19:42:40 <rwbarton> @pl \a b c -> if a then b else c
19:42:40 <lambdabot> if'
19:42:51 <jberryman> CakeProphet: I think a lot of people disagreed with the design decision for the syntax of if .. then ... else, rather than making it a simple function like: case::Bool->a->b
19:42:57 <jberryman> from what I've read
19:42:58 <dibblego> CakeProphet, http://www.haskell.org/haskellwiki/If-then-else
19:43:29 <CakeProphet> in the two weeks I've been playing with Haskell, I actually have not used it once.
19:43:45 <jberryman> er... case::Bool->a->a->a
19:44:15 <ddarius> Booleans are not extremely common in Haskell and are usually handled by guards.
19:46:24 <mmorrow> CakeProphet: what do you mean "used it"?
19:46:40 <CakeProphet> I've never written an if-then-else expression.
19:47:34 <mmorrow> ohhh. :)
19:48:20 <mmorrow> a shell:
19:48:22 <mmorrow> fix (\k hist -> putStr "> "  >> getLine >>= \l -> case l of [] -> k hist; ":q" -> print (l:hist); _ -> system l >> k (l:hist)) []
19:48:26 <mmorrow> "shell"
19:50:18 <kniu> if the type of a function can be inferred,
19:50:44 <ddarius> mmorrow: Why the heck would you want a "shell" that kept a history of everything you typed just to display it to you at the end?
19:50:48 <kniu> and that type is itself a type-level function that operates on the types of the operators,
19:50:57 <kniu> can a function be inferred from its type?
19:51:10 <mmorrow> ddarius: haha
19:51:17 <mmorrow> perhaps s/print/return/
19:51:38 <bohdan> I like http://www.haskell.org/haskellwiki/Things_to_avoid
19:51:52 <bohdan> is there some more of this stuff ? :)
19:51:55 <rwbarton> kniu: That depends on the type (and what assumptions you are willing to make).
19:52:01 <mmorrow> that was for CakeProphet when i thought that he mean "haven't used _haskell_ once"
19:52:04 <bohdan> also some positive advice would be nice
19:52:09 <rwbarton> kniu: e.g., there is "only one" function of type forall a. a -> a
19:52:20 <bohdan> "Things to not avoid" :)
19:52:22 <rwbarton> kniu: but, there are many functions of type Int -> Int, for instance.
19:52:31 <kniu> huh.
19:52:48 <rwbarton> kniu: And, there are "no" functions of type forall a b. a -> b.
19:53:02 <rwbarton> lambdabot can do this inference in some cases
19:53:03 <chessguy> @pl \x -> m (+ x)
19:53:04 <lambdabot> m . (+)
19:53:06 <rwbarton> @djinn a -> a
19:53:06 <lambdabot> f a = a
19:53:10 <rwbarton> @djinn a -> b
19:53:10 <lambdabot> -- f cannot be realized.
19:54:17 <kniu> wow.
19:54:44 <mmorrow> except (const undefined) and unsafeCoerce of course
19:55:07 <mmorrow> but those "\"don't count\""
19:56:15 <Saizan_> surely not for djinn
19:56:20 <rwbarton> However, djinn doesn't tell you whether the function it comes up with is unique.  I don't know whether that's a computable problem
19:56:40 <Cale> mmorrow: and undefined
19:57:01 <mmorrow> Cale: hah, how could i have overlooked that one. :)
19:57:06 <Cale> > (undefined :: a -> b) `seq` ()
19:57:07 <lambdabot>   * Exception: Prelude.undefined
19:57:10 <Cale> > (const undefined :: a -> b) `seq` ()
19:57:12 <lambdabot>   ()
19:57:16 <mmorrow> ooh
19:57:22 <ddarius> rwbarton: djinn produces all solutions.  @djinn only displays the first
19:57:37 <rwbarton> ddarius: Oh, cool.  I will have to check it out.
19:57:47 <mmorrow> Cale: good point, not only do they have the same type, but the aren't iso
19:58:33 <CakeProphet> so in Haskell 6.10 I can define main for not-Main modules?
19:58:40 <CakeProphet> and all will be well?
19:58:44 <CakeProphet> *GHC
19:58:51 <mmorrow> yes
19:59:01 <mmorrow> in all ghc's i believe
19:59:11 <mmorrow> (at least in >= 6.6)
20:01:51 <CakeProphet> so if you do like
20:01:58 <CakeProphet> [file, input] <- getArgs
20:02:10 <CakeProphet> and anonymous user person types in only one argument
20:02:12 <rwbarton> ddarius: It doesn't seem to work quite how I expected. http://hpaste.org/13556
20:02:17 <CakeProphet> will input = "" or will Haskell just complain.
20:02:34 <mmorrow> CakeProphet: your progr will (gracefully) crash
20:02:45 <CakeProphet> excellent.
20:02:58 <rwbarton> ddarius: It seems to only know about the numbers 1, 1, and 0 :)
20:03:02 <mmorrow> by "gracefully" i mean "not a segfault"
20:03:24 <rwbarton> CakeProphet: with an error message like Irrefutable pattern match failed at ...
20:04:02 <rdeshpande> in what scenario would it be valuable for the type constructor and value constructor to have different names?
20:04:17 <rdeshpande> the "real world haskell" book says it is normal for them to share the same name
20:04:29 <Saizan_> when you've more than one value constructor
20:05:37 <rdeshpande> how does that look? i thought the types following the initial value constructor are components of the type
20:05:54 <Saizan> ?src Bool
20:05:55 <lambdabot> data Bool = False | True deriving (Eq, Ord)
20:06:16 <dibblego> @src Maybe
20:06:17 <lambdabot> data Maybe a = Nothing | Just a
20:06:22 <rdeshpande> oh i get it
20:06:26 <dibblego> data Maybe a = Just a | Nothing -- looks like this
20:06:26 <Saizan> yes, you can have multiple fields in one constructor, but you can also have multiple constructors
20:06:26 <rdeshpande> ok cool thanks
20:06:53 <BMeph> @djinn ((a -> Void) -> Void) -> a
20:06:54 <lambdabot> -- f cannot be realized.
20:07:28 <geezusfreeek> @djinn ((a -> b) -> b) -> a
20:07:29 <lambdabot> -- f cannot be realized.
20:07:49 <ozy`> ugh, I don't wanna install GHC on my Dreamhost account :\
20:07:53 <Saizan> @djinn Not (Not (Not (Not a) -> a))
20:07:54 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
20:08:29 <geezusfreeek> @djinn ((a -> b) -> a) -> a
20:08:30 <lambdabot> -- f cannot be realized.
20:08:59 <sbahra> Anybody here use PF?
20:09:04 <sbahra> OpenBSD PF.
20:09:48 <geezusfreeek> :t callCC
20:09:49 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:09:56 <rdeshpande> PF?
20:10:08 <sbahra> rdeshpande, packet filter
20:10:20 <rdeshpande> ah, thanks
20:14:34 <ddarius> @djinn a -> (a,a)
20:14:34 <lambdabot> f a = (a, a)
20:16:32 <ManateeLazyCat> How to transform from "IO [String]" to "[String]" ?
20:17:05 <rwbarton> ManateeLazyCat: Nope.
20:17:40 <rwbarton> ManateeLazyCat: Well, only within a do block in the IO monad.
20:17:44 <Axman6> unsafePerformIO
20:17:45 <Axman6> >_>
20:17:53 <blbrown> dang, there are only 569 people in here.  I was waiting for the big 6-0
20:17:54 <bohdan> oh noes :)
20:18:05 <rwbarton> @users
20:18:06 <lambdabot> Maximum users seen in #haskell: 623, currently: 570 (91.5%), active: 19 (3.3%)
20:18:31 <bohdan> ManateeLazyCat, getLine >>= print . (++ "hello")
20:18:36 <Axman6> i'm cut i missed it :(
20:19:37 <ManateeLazyCat> rwbarton: I use "getArgs" get *input argument* and save in variable "args", and i want to use "length" get argument total number .
20:19:49 * rwbarton learns more australian (?) english
20:20:16 <Axman6> rwbarton: if you're referring to cut, then yes
20:20:26 <rwbarton> ManateeLazyCat: do args <- getArgs; print (length args)
20:20:38 <ManateeLazyCat> rwbarton: Thanks
20:20:50 <Saizan> ?wiki Monads as computation
20:20:50 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
20:21:15 <ozy`> ManateeLazyCat: "x <- y" extracts the "contents" of a monadic value
20:21:25 <rwbarton> Axman6: Do you know if it is British usage as well?  I sometimes do British crosswords and find usages that are strange to me
20:21:41 <ManateeLazyCat> ozy`: Thanks
20:21:52 <Asztal> I've never heard "cut" used like that
20:22:23 <Asztal> I'd probably use "gutted".
20:25:38 <bohdan> @pl \x -> k < x && x `foo` k
20:25:38 <ddarius> rwbarton: See pp. 9-10 (803-804) of http://www.dcs.st-and.ac.uk/~rd/publications/jsl57.pdf
20:25:38 <lambdabot> liftM2 (&&) (k <) (`foo` k)
20:27:49 <defun> how would one go about creating a timer in haskell?
20:28:17 <ozy`> defun: I'm wondering that myself
20:28:21 <sjanssen> defun: using threadDelay, probably
20:29:18 <defun> thanks.
20:29:38 <ddarius> defun: Note that threadDelay takes a delay in -micro- seconds.
20:31:53 <rwbarton> ddarius: Hmm.  Do you know what I can infer if djinn returns a single result, then?
20:32:05 <rwbarton> ddarius: (A second example is at http://hpaste.org/13556#a1)
20:32:26 <sereven> defun: gameclock is kind of a fun package that's a gtk (iirc) chess clock, if you want code examples to look at.
20:35:33 <BMeph> @djinn Not (Not a) -> a
20:35:33 <lambdabot> -- f cannot be realized.
20:35:53 <bohdan> @src Not
20:35:54 <lambdabot> Source not found. Wrong!  You cheating scum!
20:36:03 <Saizan> @djinn-env
20:36:04 <lambdabot> data () = ()
20:36:04 <lambdabot> data Either a b = Left a | Right b
20:36:04 <lambdabot> data Maybe a = Nothing | Just a
20:36:04 <lambdabot> data Bool = False | True
20:36:04 <lambdabot> data Void
20:36:06 <lambdabot> type Not x = x -> Void
20:36:10 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:36:27 <bohdan> eh?
20:36:42 <Gracenotes> @djinn Maybe a -> a
20:36:42 <lambdabot> -- f cannot be realized.
20:36:56 <Gracenotes> @djinn Maybe a -> Either a b
20:36:57 <lambdabot> -- f cannot be realized.
20:37:44 <ddarius> rwbarton: Going by the title of the paper I suspect the Djinn will not use contraction unless it "has" to.
20:38:06 <ddarius> rwbarton: If that is correct, then what you can infer is that any other solutions would require using a variable more than once.
20:38:46 <ManateeLazyCat> I use "case foo of" test condition, i want to test three condition: "0" "1" and "above 1".
20:38:57 <ManateeLazyCat> How to write condition "above 1" ?
20:39:25 <ddarius> case foo of 0 -> ... ; 1 -> ... ; n | n > 1 -> ...
20:39:31 <ddarius> Which will fail if n < 0
20:39:48 <ManateeLazyCat> ddarius: Thanks!
20:40:52 <BMeph> > listerine twice
20:40:53 <lambdabot>   Not in scope: `listerine'Not in scope: `twice'
20:41:02 <mm_freak_> @djinn a -> (a -> r) -> r
20:41:03 <lambdabot> f a b = b a
20:41:12 <mathijs> when 'grepping' lines in a file and selecting a certain part of a matching line, is it better to use a foldr or map + filter?
20:41:48 <ddarius> mathijs: Whichever is clearest.  They very likely produce the same code.
20:42:14 <mathijs> ddarius: ok, there's no performance gain or something?
20:42:29 <pyNem> @users
20:42:29 <lambdabot> Maximum users seen in #haskell: 623, currently: 570 (91.5%), active: 17 (3.0%)
20:42:40 <ManateeLazyCat> ddarius: I want interrupt *main* in *case* sentence, how to do that?
20:42:59 <ddarius> ManateeLazyCat: I have no idea what you mean.
20:43:18 <ddarius> Do you want to terminate the program?
20:43:28 <ManateeLazyCat> ddarius: Yep
20:43:33 <sereven> > sum . map (2^) $ [9,5,4,3,1]
20:43:34 <lambdabot>   570
20:43:39 <ddarius> ManateeLazyCat: You can use exitWith for that.
20:43:42 <ddarius> @hoogle exitWith
20:43:42 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
20:44:04 <ddarius> This is assuming that the branches of the case are IO actions.
20:44:14 <ManateeLazyCat> ddarius: Can you give me simple example with "exitWith"?
20:44:19 <ddarius> mathijs: The same code is going to have the same performance.
20:44:27 <rwbarton> @hoogle ExitCode
20:44:27 <lambdabot> System.Exit data ExitCode
20:44:27 <lambdabot> System.Process getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
20:44:29 <bohdan> rwbarton, regarding `rem` vs `mod` -- you were right about it, it's faster, but insignificantly for my case (~5%) -- it seems I screwed something up when I looked at it earlier
20:44:48 <cjs> @seen dons
20:44:48 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 5h 52m 1s ago.
20:44:55 <cjs> @seen bos
20:44:55 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 8h 12m 32s ago.
20:46:29 <tcleval> hi.. i tried to ./configure --prefix=$HOME/programas/ghc  && make && make install but it report the following error after some minutes : http://hpaste.org/13557   i am using ubuntu hardy with ghc installed, and i just want to make an upgrade from source
20:46:55 <tcleval> so ghc-6.10.1 is not compiling
20:47:10 <ddarius> exitWith ExitSuccess, actually they apparently have an exitSuccess so you can just use that unless you want to give an error code.
20:50:04 <mriou> hi, is parsec still maintained?
20:50:33 <ddarius> mriou: Yes.
20:51:25 <mriou> ddarius: say that I want to propose a change or submit a patch, is there somewhere I can do that (like a ML or a trac or sthing)?
20:52:24 <mriou> I think it would make sense to have a language-specific definition of whiteSpace
20:52:47 <mathijs> regarding threads running on multiple cores... after compiling with -threaded, I can use +RTS -N4 to use 4 cores, but I would like this to be chosen automatically at runtime (so detect the number of cores and use them). How can this be achieved?
20:53:00 <ddarius> mriou: To submit patches, email the maintainer.  There is no trac or anything like that set up.  If there is something you'd want to discuss you can try Haskell-Cafe.
20:53:13 <inimino> mriou: Hackage lists the bug-report address or maintainer for most Haskell packages
20:53:25 <ddarius> mathijs: You have to compile in a little C that will set the RTS options.
20:53:37 <jeffz`> there's a haskell-libraries list for proposing changes to libraries too isn't there?
20:53:39 <mriou> ddarius, inimino: okay I'll do that, thanks
20:53:46 <mathijs> ddarius: is there some howto on that somewhere?
20:53:47 <inimino> mriou: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
20:54:31 <ddarius> mathijs: Probably somewhere on the wiki or GHC Developer's wiki.  Failing that, surely somewhere on the mailing lists.
20:54:58 <mriou> inimino: yep, found it, thanks again
20:55:18 <mathijs> ddarius: also, is it possible to have a fat binary that contains both the threaded runtime and the non-threaded one? so the nonthreaded one can be used when only 1 core is detected?
20:55:45 <ddarius> mathijs: I don't think so.
20:56:42 <inimino> is there a runtime difference when it's only using one core?
20:56:43 <ddarius> mathijs: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
20:57:01 <ddarius> inimino: The threaded run-time is not as efficient as the non-threaded one.
20:57:02 <mathijs> ok, so probably 2 binaries and a small bash script to choose which one and which options would be easiest?
20:57:14 <inimino> ddarius: OK, I didn't know that.
20:57:38 <jeffz`> mathijs: do you suffer a performance loss when you use the threaded runtime on one core?
20:57:38 <ddarius> mathijs: Probably.  It seems you can set an environment variable for the RTS options which you may want to consider as well.
20:58:37 <mathijs> jeffz`: I didn't benchmark anything but RWH mentions the threaded RTS is more expensive when creating threads and mvars and stuff.
20:59:41 <mathijs> ddarius: thanks, that's probably the easiest
21:02:00 <CakeProphet> hmm
21:02:08 <CakeProphet> I wonder what the primitives of Haskell are.
21:02:22 <Twey> 'primitives'?
21:02:23 <Gracenotes> sekrit
21:02:24 <dmwit> data, let, and case
21:02:34 <Twey> And =
21:02:34 <Gracenotes> hello, Twey
21:02:38 <Twey> Hey there, Gracenotes
21:02:39 <dmwit> = is syntax
21:02:40 <Twey> Been a while
21:02:46 <Gracenotes> :)
21:02:49 <Twey> dmwit: So are data, let, and case
21:02:50 <CakeProphet> by primitives I mean the builtin axioms that everything else becomes semantically.
21:02:55 <chrisdone> @instances RegexContext
21:02:56 <lambdabot> Couldn't find class `RegexContext'. Try @instances-importing
21:02:57 <dmwit> Twey: It is a fine line, I know.
21:03:18 <dmwit> CakeProphet: Look up Core, as well as the STG machine, and you'll know. =)
21:03:25 <CakeProphet> it doesn't matter if it's syntax. It just needs to be something that everything else evaluates to.
21:03:25 <dmwit> Then you'll find out I'm right. ;-)
21:04:09 <Gracenotes> can newtype/type be constructed from just data, let, and case?
21:04:13 <vininim_> everything evaluates to monad IO =P
21:04:20 <bohdan> @pl \a -> (a, length a)
21:04:20 <lambdabot> ap (,) length
21:04:23 <bohdan> @pl \a -> (head a, length a)
21:04:23 <lambdabot> liftM2 (,) head length
21:04:33 <vininim_> *monad IO actions
21:04:46 <ddarius> type is expanded away almost at parse time.  newtype is a figment of the type checkers imagination and has no semantic consequence beyond that.
21:04:48 <dmwit> Gracenotes: Yes, by removing all the occurrences of the constructor. =)
21:05:17 <Gracenotes> aww, which constuctor?
21:05:20 <Gracenotes> constructor, even
21:05:24 <dmwit> The newtype's constructor, of course.
21:06:07 <Gracenotes> replacing the invocation of newtype with the identical one from data, then
21:06:19 <dmwit> Nope.
21:06:20 <ddarius> Gracenotes: No.  By removing it completely.
21:06:24 <dmwit> Just drop the newtype completely.
21:06:43 <dmwit> If you replace it with data, you might get Wrong Answers.
21:06:50 <dmwit> Or, well... Different Answers, anyway. =)
21:07:08 <bohdan> so I have [(Int,Int)] and I want to make a scatterplot -- preferably from within ghci -- what's the easiest way?
21:07:12 <Gracenotes> what about the name bound to the newtype, e.g. newtype omg = Char? Do invocations of omg just go away?
21:07:28 <dmwit> bohdan: I think there's a gnuplot binding on hackage.
21:07:43 <dmwit> Gracenotes: That's not syntactically correct.
21:07:52 <dmwit> Gracenotes: Do you mean newtype Omg = Omg Char?
21:08:30 <dmwit> newtype OmgType = OmgConstructor Char -- let's use this instead
21:08:39 <Gracenotes> yes, I do (haven't used newtypes in a few weeks). What happens it then?
21:08:41 <Gracenotes> *to it
21:08:52 <dmwit> Then, replace OmgType with Char everywhere, and remove OmgConstructor everywhere.
21:09:03 <dmwit> And take out that newtype line entirely.
21:09:35 <dmwit> Of course, you have to be slightly careful with class instances.
21:09:43 <fritz> if you have something like "do y:xs' <- tails xs", what does that do exactly?
21:09:52 <dmwit> But at this point, you should have expanded those to their explicit dictionary-passing versions, anyway, so just pass the right dictionary.
21:09:54 <ddarius> Well you'd have to do this after type checking, so OmgType is completely irrelevant (at that point)
21:10:02 <dmwit> fritz: Ah, one of Haskell's biggest warts.
21:10:12 <ddarius> @undo do y:xs' <- tails xs
21:10:12 <lambdabot>  Parse error at end of input
21:10:15 <ddarius> @undo do y:xs' <- tails xs; return y
21:10:15 <lambdabot> tails xs >>= \ a -> case a of { y : xs' -> return y; _ -> fail ""}
21:10:30 <fritz> wth?!
21:10:39 <Gracenotes> oh, I see
21:10:54 <dmwit> fritz: It pattern matches each result of (tails xs) against (y:xs').
21:11:10 <dmwit> fritz: Any time the pattern fails, it calls the "fail" method of the monad.
21:11:27 <fritz> so if tails xs were []
21:11:32 <Gracenotes> the whole class instances part -- one of the reasons why you'd use newtype in the first place -- seems the most tricky-ish.
21:11:35 <dmwit> Yep, then it would call fail.
21:11:35 <sjanssen> > [xs | xs <- tails [1 .. 3]]
21:11:36 <dmwit> :t fail
21:11:36 <lambdabot>   [[1,2,3],[2,3],[3],[]]
21:11:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
21:11:39 <rwbarton> No, if tails xs contains [] (which it does)
21:11:58 <rwbarton> Fortunately fail "" = [] in the list monad.
21:11:58 <sjanssen> > [x:xs | x:xs <- tails [1 .. 3]] -- elems that don't match the pattern are skipped
21:11:59 <dmwit> Sorry, rwbarton's statement is more precise.
21:11:59 <lambdabot>   [[1,2,3],[2,3],[3]]
21:12:46 <dmwit> Gracenotes: Yeah, class instances and to have a distinct type for correctness guarantees.  I think those are the two biggest reasons for newtype.
21:12:53 <fritz> thanks
21:13:12 <dmwit> Gracenotes: Managing the class instance isn't so tricky as you might imagine.
21:13:36 <sjanssen> Gracenotes: it is actually pretty straightforward, as these things happen in stages
21:14:11 <sjanssen> typechecking happens in the first stage, where newtype still exists and acts exactly like data
21:14:11 <Gracenotes> it probably /is/ straight-forward in terms of the type inference system...
21:14:48 <Gracenotes> okay
21:14:52 <sjanssen> in the next stage, classes are compiled out by supplying dictionaries
21:15:09 <sjanssen> after that, newtypes are removed
21:15:26 <Gracenotes> what do the dictionaries map?
21:15:37 <dmwit> class methods
21:15:41 <sjanssen> Gracenotes: class methods
21:15:46 <dmwit> method name to function value
21:16:09 <ddarius> They're just records of functions much like OO vtables.
21:16:18 <dmwit> For example, the dictionary for an Eq instance passes contains a single value named (==).
21:16:19 <Gracenotes> and a map exists for each type, then
21:16:33 <dmwit> For each instance.
21:16:48 <dmwit> When you write an instance, you are essentially specifying the dictionary.
21:17:39 <Gracenotes> oh, I mean for the type (for example) Integer, a dictionary exists filled with function names like compare, (==), etc.
21:17:50 <sjanssen> and class constraints on function types become arguments to the function: "Eq a => a -> Bool" becomes "EqDict a -> a -> Bool"
21:18:24 <dmwit> Gracenotes: Hm.  Yes and no.  There's one dictionary for each (class, type) pairing you write.
21:18:26 <sjanssen> Gracenotes: dictionaries for unrelated classes are separate
21:18:34 <dmwit> Gracenotes: So there's no dictionary that has both (==) and compare.
21:19:06 <dmwit> Having one dictionary per instance is a pretty precise way of describing the situation.
21:19:33 <Gracenotes> hm, I see
21:19:53 <sjanssen> Gracenotes: the reason they're compiled that way is that instances are open
21:20:01 <Gracenotes> > (>) > (>)
21:20:02 <lambdabot>       No instance for (Ord (a -> a -> Bool))
21:20:02 <lambdabot>        arising from a use of `>'...
21:20:10 <Gracenotes> so in that case the dictionary can't be found
21:20:24 <sjanssen> Gracenotes: well, it chokes even before that stage
21:20:57 <sjanssen> that code fails typechecking, because the type checker knows that it won't be able to supply a dictionary later on
21:21:18 <Gracenotes> mm, interesting
21:21:48 <CakeProphet> so will inp <- getContents
21:21:51 <Gracenotes> unless you defined an instance Ord (a -> a -> Bool) where compare = EQ, or something.
21:22:01 <CakeProphet> return a string of all current and future input?
21:22:08 <sjanssen> Gracenotes: right
21:22:18 <sjanssen> CakeProphet: yes
21:22:37 <dmwit> laziness + monads = time travel
21:23:46 <sjanssen> CakeProphet: clearly that doesn't entirely make sense, which is why lazy IO is somewhat controversial
21:23:56 <DOKKA> is there a function that returns the element of a list at an index?
21:23:57 <CakeProphet> sjanssen:  then why does my input handling function complain about non-exhaustive patterns from receiving an empty string from getContents?
21:24:02 <fritz> @undo do y:xs' <- tails xs; ys <- f (n-1) xs'; return (y:ys)
21:24:03 <lambdabot> tails xs >>= \ a -> case a of { y : xs' -> f (n - 1) xs' >>= \ ys -> return (y : ys); _ -> fail ""}
21:24:07 <Gracenotes> time travel is possible going to the future, but not to the past
21:24:10 <Gracenotes> (damn entropy)
21:24:21 <arw> DOKKA: list !! n gives you the n'th element.
21:24:34 <Gracenotes> getContents >>= print, fun
21:24:37 <bohdan> dmwit, hmm how would I make log-scale plots with Graphics.Gnuplot ?
21:24:44 <dmwit> I have no idea.
21:24:48 <Gracenotes> rreeppeeaattiinngg  yyoouurrsseellff
21:24:48 <arw> > [1, 2, 3, 4, 5] !! 3
21:24:49 <DOKKA> oh so that is how it works, thanks
21:24:49 <lambdabot>   4
21:25:14 <arw> (counting from zero, like in any sane language ;)
21:25:23 <DOKKA> ah, yes
21:25:46 <sjanssen> CakeProphet: can't say without seeing the code
21:25:50 <DOKKA> I just got the o'reilley book today
21:26:11 <DOKKA> and I'm trying to learn with it
21:26:51 <chrisdone> hrrrrm
21:27:01 <chrisdone> > "ab C" =~ "([a-z]+) (.*)" :: [[Char]]
21:27:02 <lambdabot>   ["ab C"]
21:27:11 <CakeProphet> sjanssen:  http://hpaste.org/13561
21:27:14 <chrisdone> ah, k. I musn't be including the right module
21:27:25 <CakeProphet> sjanssen:  just follow inp from main
21:27:46 <Crazy-T> Do me a favor please  Click this link so i get more points after it loads u can exit it please?   http://www.DesignsBySiCK.com/?pointsfor=nheimberg
21:28:00 --- mode: ChanServ set +o sjanssen
21:28:04 --- mode: sjanssen set +b *!*n=Crazy-T@*.cable.ubr04.king.blueyonder.co.uk
21:28:04 --- kick: Crazy-T was kicked by sjanssen (sjanssen)
21:28:10 --- mode: ChanServ set -o sjanssen
21:29:36 <chrisdone> how can I get a Maybe [String] from a regex result easily?
21:30:09 <sjanssen> CakeProphet: I would guess the pattern match failure is due to a bug in your code
21:30:11 <rwbarton> > "ab C" =~ "([a-z]+) (.*)" :: Maybe String
21:30:13 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
21:30:13 <lambdabot>                ...
21:30:17 <rwbarton> worth a shot
21:30:30 <rwbarton> Wait Maybe [String]?
21:30:32 <ozy`> I'm going to design a language where arrays are indexed from -1
21:30:34 <CakeProphet> sjanssen:  yeah, there's no condition for the empty string... because I'm not expecting one.
21:30:35 <rwbarton> for backreferences?
21:30:48 <chrisdone> > "ab C" =~ "([a-z]+) (.*)" :: Maybe [[Char]]
21:30:50 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
21:30:50 <lambdabot>                ...
21:30:50 <CakeProphet> but I get an empty string when I grab input from getContents
21:30:52 <ozy`> it will use the director model (an analog to the actor model)
21:31:12 <sjanssen> CakeProphet: how are you executing the program?
21:31:28 <chrisdone> > "ab C" =~ "([a-z]+) (.*)" :: [MatchText String] -- this is alright, but imho unnecessary/annoying code to extract the values
21:31:29 <lambdabot>       Not in scope: type constructor or class `MatchText'
21:31:46 <chrisdone> .. [array (0,2) [(0,("ab C",(0,4))),(1,("ab",(0,2))),(2,("C",(3,1)))]]
21:31:57 <CakeProphet> runhaskell bf.hs ",[.,]" "lawl"
21:32:09 <dmwit> > "ab C" =~ "([a-z]+) (.*)" :: [String]
21:32:11 <lambdabot>   ["ab C"]
21:32:13 <chrisdone> like, I just want ["ab","C"] or w/e
21:32:24 <dmwit> > "ab C" =~ "([a-z]+) (.*)" :: (String, String, String, [String])
21:32:26 <lambdabot>   ("","ab C","",["ab","C"])
21:32:33 <chrisdone> wehey!!
21:32:35 <ddarius> mriou: I'll have to decide whether to change the compatibility module (breaking compatibility, but not likely in a particularly problematic way) or I'll have to figure out a way to support both with and without the extra field.
21:32:47 <sjanssen> CakeProphet: and what is the exact failure message you receive?
21:32:52 <rwbarton> > "abC" =~ "([a-z]+) (.*)" :: (String, String, String, [String])
21:32:53 <lambdabot>   ("abC","","",[])
21:33:02 <dmwit> chrisdone: Ask and ye shall receive. =)
21:33:02 <chrisdone> dmwit: thanks, I couldn't find something like that in the instances :-)
21:33:05 <rwbarton> that's... not obvious
21:33:09 <CakeProphet> bf.hs: bf.hs:74:2-71: Non-exhaustive patterns in function doInput
21:33:29 <ddarius> rwbarton: If you want obvious, don't use the (=~) operator.
21:33:34 <dmwit> rwbarton: Non-matching stuff that comes before a successful match, the match, non-matching stuff that comes after the match, the list of ()'s.
21:33:53 <rwbarton> dmwit: But there wasn't a match!
21:34:02 <dmwit> Yeah.
21:34:07 <dmwit> Weird, huh?
21:34:22 <rwbarton> > "abC" =~ "" :: (String, String, String, [String])
21:34:23 <chrisdone> there was a bit of a match
21:34:23 <lambdabot>   ("","","abC",[])
21:34:47 <chrisdone> > "abC" =~ "([a-z]+) (.+)" :: (String, String, String, [String])
21:34:49 <lambdabot>   ("abC","","",[])
21:35:12 * chrisdone satisfied
21:35:14 <sjanssen> CakeProphet: running this from a shell?  Is stdin in some strange state?
21:35:47 <sjanssen> CakeProphet: oh, the solution is more simple than that :)
21:35:50 <CakeProphet> ....oh
21:35:52 <CakeProphet> rofl
21:35:54 <CakeProphet> yeah I see it
21:36:00 <sjanssen> 2 ->  let [prog,cmdinp] = args in return $ bf prog cmdinp
21:36:02 <CakeProphet> getting input from the command line
21:36:05 <sjanssen> doesn't use stdin
21:36:06 <CakeProphet> is finite
21:36:12 <CakeProphet> yeah
21:36:27 <CakeProphet> hmm... so I should just have a condition on doInput for an empty list that terminates the program, maybe?
21:36:47 <DOKKA> so is (!!)  a function? I don't quite understand why it's structured that way
21:36:51 <mriou> ddarius: ah sorry, I didn't realize you were the maintainer :)
21:36:56 <dmwit> DOKKA: Yes, it's a function.
21:37:08 <CakeProphet> DOKKA:  it's a function, but in Haskell functions that consist entirely of simples can be infix
21:37:24 <DOKKA> oh, i see
21:37:26 <ddarius> "simples" is an impressive typo
21:37:26 <CakeProphet> *symbols
21:37:29 <CakeProphet> rofl
21:37:31 <CakeProphet> yes.
21:37:34 <mriou> ddarius: the compatibility module?
21:37:37 <CakeProphet> a phone rang as I was typing
21:38:19 <ddarius> mriou: Parsec 3 has compatibility modules for Parsec 2.
21:38:21 <dmwit> ?remember ddarius "simples" is an impressive typo [for symbols]
21:38:22 <lambdabot> I will remember.
21:38:31 <dmwit> Not that I expect that quote to last very long.
21:38:35 <dmwit> ?quote avdi
21:38:36 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
21:38:49 <ddarius> dmwit: Good thing, that
21:38:54 <CakeProphet> sjanssen:  hmmm... would cmdinp ++ inp work?
21:38:55 * dmwit nods
21:39:23 <mriou> ddarius: ah I see now
21:39:55 <bohdan> Is there a version of takeWhile that keeps the first non-matching element?
21:39:58 <sjanssen> CakeProphet: sure
21:40:25 <rwbarton> bohdan: you can cook one up out of span
21:40:44 <bohdan> rwbarton, it would require an expensive ++
21:40:55 <mriou> ddarius: those are in the Parsec.hs ?
21:41:08 <rwbarton> bohdan: Only a constant factor cost, it's unclear that it's really much worse.
21:41:32 <mriou> mmh actually not, I'm not sure I have all the sources
21:41:44 <sjanssen> takeWhileEnd p = foldr (\x xs -> if p x then x : xs else [x]) []
21:41:44 <bohdan> why constant factor? you need to traverse the list again
21:41:55 <sjanssen> bohdan: ^^ trivial implementation
21:41:56 <mmorrow> , drop 1 `fmap` [$rx| [0-4]{2} ( ([a-zA-Q]+) _ ) |] "42haiHAIAHIAHIA______"
21:41:58 <lunabot>  Just ["haiHAIAHIAHIA_","haiHAIAHIAHIA"]
21:42:08 <rwbarton> bohdan: But only if you later traverse the list in the first place.
21:42:09 <bohdan> @pl \x xs -> if p x then x : xs else [x]
21:42:10 <lambdabot> ap (flip . ap ((.) . if' . p) (:)) return
21:42:10 <ddarius> mriou: You probably have parsec 2
21:42:30 <mriou> parsec-3.0.0 from hackage
21:42:44 <rwbarton> bohdan: i.e., the cost is paid incrementally as you consume the array so it's at most, like, twice as slow
21:43:29 <ddarius> mriou: Okay, then the Text.ParserCombinators.Parsec tree is the compatibility layer and the Text.Parsec tree is parsec 3 proper.
21:44:11 <mriou> ddarius: okay, got it
21:45:12 <mriou> ddarius: an addition shouldn't break compatibility though, or would it?
21:45:13 <sjanssen> @pl \x xs -> x : if p x then xs else []
21:45:13 <lambdabot> liftM2 (.) (:) (flip flip [] . if' . p)
21:46:41 <sjanssen> takeWhileEnd p ys = build (\c n -> foldr (\x xs -> x `c` if p x then xs else n) n ys)
21:46:53 <sjanssen> ^^^ both a good producer and consumer
21:47:07 <ddarius> mriou: It's pretty rare for any change not to break compatibility unless it's behind an abstraction barrier.  In this case though, I doubt it would bother anyone much if at all.
21:47:09 <rwbarton> sjanssen: ah you beat me to the "Maintaining laziness" thing too :P
21:48:25 <mriou> ddarius: maybe for those who wouldn't be using emptyDef or any other language def?
21:49:02 <mriou> creating their own language def directly
21:49:29 <mriou> although that's not really advised (the doc advises against it IIRC)
21:49:49 <CakeProphet> :t if'
21:49:51 <lambdabot> Not in scope: `if''
21:50:01 <CakeProphet> :(
21:50:20 <Axman6> if' p x y = if p then x else y
21:50:37 <Axman6> :t let if' p x y = if p then x else y in if'
21:50:39 <lambdabot> forall t. Bool -> t -> t -> t
21:52:46 <jeffz`> @hoogle  (t -> [a] -> c) -> t -> a -> c
21:52:46 <lambdabot> No results found
21:55:52 <sjanssen> @type \f x a -> f x [a]
21:55:53 <lambdabot> forall t t1 t2. (t -> [t1] -> t2) -> t -> t1 -> t2
21:57:00 <chrisdone> for `hGetLine h' and `_ <- hGetLine h', is either likely to keep the returned value instead of discarding/garbage collecting it?
21:57:14 <chrisdone> that is, for the rest of some `do' construct
21:57:22 <chrisdone> (and indeed beyond, inside the IO monad?)
21:58:40 <chrisdone> e.g. do hGetLine h -- skip bogus line
21:58:40 <chrisdone>         ...
21:59:09 <sjanssen> chrisdone: the value will eventually be GCed in both cases
21:59:35 <chrisdone> I read on mdh's blog that mapM_ is better than mapM because otherwise the values will be kept in the monad un collected
21:59:43 <chrisdone> sjanssen: ah right, good
22:01:13 <sjanssen> chrisdone: the string will still be allocated
22:01:59 <ddarius> chrisdone: mapM produces a list, mapM_ doesn't.  The list can't be released (in the IO case) until the IO action (the mapM) completes.  The list will certainly be garbage collected if unused later.
22:02:19 <mriou> ddarius: reply if I can do sthing to help, and thanks!
22:02:30 <StoneToad> is there an easy way to take a list like [([a],[b])] and convert it to ([a],[b]) (concat'ing the lists of a's and b's from each tuple) unzip looked like it would work at first, but I can't figure out how to do it
22:02:50 <chrisdone> ddarius: roger
22:02:59 <rwbarton> > mconcat [("foo", "bar"), ("baz", "quux")]
22:03:00 <lambdabot>   ("foobaz","barquux")
22:03:03 <rwbarton> sweet!
22:03:11 <chrisdone> ❤
22:03:23 <StoneToad> rwbarton: ooh very very nice!
22:03:30 <dmwit> wow
22:03:36 <dmwit> rwbarton++
22:03:43 <rwbarton> typeclasses++
22:04:47 <Axman6> @hoogle (<$>)
22:04:48 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
22:06:03 <aluink> @src tail
22:06:03 <lambdabot> tail (_:xs) = xs
22:06:03 <lambdabot> tail []     = undefined
22:06:16 <aluink> @src last
22:06:16 <lambdabot> last [x]    = x
22:06:16 <lambdabot> last (_:xs) = last xs
22:06:16 <lambdabot> last []     = undefined
22:06:29 <fritz> @src mconcat
22:06:29 <lambdabot> Source not found. Are you on drugs?
22:07:06 <aluink> why yes, looking for a hit there lambda?
22:07:27 <rwbarton> @src Monoid
22:07:27 <lambdabot> class Monoid a where
22:07:27 <lambdabot>     mempty  :: a
22:07:27 <lambdabot>     mappend :: a -> a -> a
22:07:27 <lambdabot>     mconcat :: [a] -> a
22:08:57 <jowens> hey, um, n00b question, is there a Haskell function that does a 'split': takes a list and splits it into several lists delimited by another argument (split ',' "a,b,c,d") -> [a,b,c,d] ?
22:09:10 <dmwit> There are many.
22:09:13 <dmwit> There's a whole module!
22:09:21 <dmwit> ?hackage split
22:09:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
22:09:48 <jowens> and here i was looking in the prelude like a sucker
22:10:11 <rwbarton> jowens: Notice the date on that package. :)
22:10:39 <geezusfreeek> is there actually a library for left fold enumerators sitting around anywhere waiting to be used?
22:10:44 <dmwit> It fills a very big hole, I think.
22:10:48 <jowens> recent. ok. um, will this be in my GHC distro?
22:10:54 <dmwit> jowens: No.
22:10:56 <geezusfreeek> or is it just a couple use cases and talks and papers?
22:11:10 <dmwit> jowens: But "cabal install split" should do it, once you have the cabal-install package.
22:11:10 <jowens> ok. um, anything that's IN my distro i can use (prelude, etc.)?
22:11:11 <ddarius> geezusfreeek: I think there is.
22:11:20 <sjanssen> jowens: no
22:11:21 <ddarius> geezusfreeek: Also Takusen uses them.
22:11:30 <dmwit> jowens: And cabal-install comes with a script to install itself:
22:11:34 <dmwit> ?hackage cabal-install
22:11:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
22:11:50 <dmwit> Just run bootstrap.sh in the .tar.gz linked on that page.
22:11:59 <dmwit> (And then "cabal install split" as I mentioned above.)
22:12:02 <geezusfreeek> yeah, i know about Takusen, but that doesn't seem to depend on an enumerator package or anything :\
22:12:15 <jowens> ok. thanks! doesn't it seem weird there isn't some sort of split-ish thing in the std install?
22:12:30 <dmwit> jowens: Yes, it does!  That's why that package got created. =)
22:12:41 <jowens> but, like, 2 weeks ago!
22:12:57 <geezusfreeek> jowens, i think the reason is because nobody could agree on what it should actually do
22:13:26 <jowens> is there reasonable agreement now?
22:13:31 <geezusfreeek> no :)
22:13:34 <sclv> no. the package just does everything.
22:13:37 <fritz> I feel like I am on the beginning of a long journey to enlightenment
22:13:41 <jowens> the kitchen sink approach
22:13:44 <fritz> a long long journey
22:13:58 <sclv> more like a toolbox.
22:14:17 <geezusfreeek> we certainly don't believe in golden hammers
22:14:39 <jeffz`> @pl f $ (flip (:)) [] $ x
22:14:39 <lambdabot> f [x]
22:14:44 <geezusfreeek> besides haskell itself of course ;)
22:15:45 <sclv> @pl \x -> f $ (flip (:)) [] $ x
22:15:46 <lambdabot> f . return
22:16:09 <sclv> alternately, f . (:[])
22:16:41 <geezusfreeek> ^ aka, "the robot monkey"
22:17:01 <ddarius> geezusfreeek: CC-delcont has some iterater stuff.  There should be a module with that enumerator/iterater stuff, but I didn't see it on hackage.
22:18:21 <geezusfreeek> hmm... i guess i could roll my own...
22:18:27 <geezusfreeek> i'm wanting to toy with applying it to frp
22:18:56 <geezusfreeek> it's only a loose fit in my mind right now. just want to see if my ideas have any potential at all
22:20:25 <ManateeLazyCat> I use "case foo of" test "foo" with condition "n | n /= 1", when "foo" not equal 1, everything is ok, and when "foo" equal 1 will got "Non-exhaustive patterns in case", but i want do nothing when "foo" equal 1, any help?
22:21:17 <ddarius> geezusfreeek: There's Oleg's stuff on his site.  It's not in library form, but it should be straightforward to use it.
22:22:16 <rwbarton> ManateeLazyCat: "do nothing"?  Strictly speaking, you are evaluating an expression (the case expression), not "doing" anything.
22:22:21 <arw> ManateeLazyCat: you always have to specify every possible case (explicitly or via otherwise)
22:22:29 <rwbarton> ManateeLazyCat: But probably the answer is to have a default case to 'return ()'
22:22:42 <rwbarton> ManateeLazyCat: Or, when (foo /= 1) $ ...
22:22:50 <jowens> ok, so this cabal thing is cool, split is installed
22:22:57 <jowens> how do i get docs for it? are they part of the install?
22:23:16 <geezusfreeek> ddarius, i haven't actually found the code yet
22:23:27 <geezusfreeek> lots of references to it
22:23:47 <rwbarton> geezusfreeek: Oleg's ZFS is on hackage, if you're looking for that
22:24:01 <rwbarton> geezusfreeek: or more likely one of its dependencies (also on hackage)
22:24:15 <rwbarton> geezusfreeek: oh, maybe this is what ddarius already told you.
22:25:12 <geezusfreeek> rwbarton, i'm looking for a general left fold enumerator library. i figured there would be one, but can't find one anywhere
22:25:35 <geezusfreeek> just stuff tied to other projects and not even teased into a separate module :\
22:25:38 <ddarius> http://okmij.org/ftp/Haskell/Iteratee/
22:25:42 * ManateeLazyCat pasted "my code" at http://paste2.org/p/123881
22:25:45 <ddarius> http://okmij.org/ftp/Haskell/fold-stream.lhs
22:26:01 <geezusfreeek> some code!
22:26:03 <ddarius> ZFS uses CC-delcont
22:26:54 <ManateeLazyCat> rwbarton: See http://paste2.org/p/123881 , i want *case* sentence don't test condition when "argsNumber == 1"
22:27:05 <geezusfreeek> thanks
22:27:36 <rwbarton> ManateeLazyCat: Yes, you can use when
22:27:42 <rwbarton> ManateeLazyCat: Or add a default case    _ -> return ()
22:28:04 <rwbarton> ManateeLazyCat: Or use if, etc.
22:29:25 <DOKKA> man, I just don't know what I'm doing wrong
22:29:59 <dmwit> DOKKA: Paste. =)
22:30:05 <DOKKA> alright
22:30:23 <DOKKA> ax = if length ax < 3 then ax else (ax !! 2)
22:30:29 <ManateeLazyCat> rwbarton: Thank you so much, i use *case*, because i will add more argument to handle, not just one.
22:30:36 <rwbarton> ManateeLazyCat: I see.
22:30:45 <rwbarton> ManateeLazyCat: 'return ()' is the rough equivalent of 'do nothing'
22:30:50 <dmwit> DOKKA: ax and (ax !! 2) don't have the same types
22:31:04 <ManateeLazyCat> rwbarton: I understand "return ()" now, thanks! ;)
22:31:12 <dmwit> DOKKA: ax will be a list of whatever (ax !! 2) is.
22:31:47 <ddarius> Um, and ax = ... ax ... is a recursive definition, not an assignment.  I seriously doubt that is what you want.
22:31:58 <DOKKA> my input is a string
22:32:07 <dmwit> DOKKA: Also, it's not so likely that "ax = if length ax < 3 ..." will ever evaluate to anything. =)
22:32:15 <DOKKA> lastButOne xs = if (length xs) < 3 then xs else xs !! ((length xs) - 2)
22:32:41 <DOKKA> this is the function I wrote
22:32:43 <dmwit> Then my first comment applies.
22:33:00 <DOKKA> i see
22:33:02 <ManateeLazyCat> rwbarton: `return ()' return to "case foo of" and executive continue if below have others sentence. Is it this mean?
22:33:08 <dmwit> (xs) and (xs !! anythingYouWantHere) do not have the same type.
22:33:12 <rwbarton> ManateeLazyCat: Yeah, more or less.
22:33:20 <sclv> !! takes one element out of a list
22:33:20 <dmwit> DOKKA: But you might like take 1 . drop 1 . reverse
22:33:25 <ManateeLazyCat> rwbarton: Clear enough, :)
22:33:28 <dmwit> > take 1 . drop 1 . reverse $ "longish"
22:33:29 <lambdabot>   "s"
22:33:37 <sclv> ?ty (!!)
22:33:38 <lambdabot> forall a. [a] -> Int -> a
22:33:40 <DOKKA> yeah, thanks
22:33:48 <sclv> ?ty take
22:33:49 <lambdabot> forall a. Int -> [a] -> [a]
22:33:55 <dmwit> DOKKA: Usually, (!!) is a sign that you're doing something wrong.  (length), too, in most cases.
22:33:58 <DOKKA> I guess i just need to let it "sink in"
22:34:15 <dmwit> DOKKA: But you should try to figure out how to fix the one you wrote, anyway. =)
22:34:53 <DOKKA> yeah, I just don't see where the types are diffrent
22:35:06 <sclv> > [1..4] !! 2
22:35:07 <lambdabot>   3
22:35:10 <dmwit> DOKKA: xs :: String, xs !! 2 :: Char
22:35:17 <sclv> > take 2 [1..4]
22:35:18 <lambdabot>   [1,2]
22:35:25 <DOKKA> oooooh!
22:35:41 <DOKKA> of course
22:36:01 <DOKKA> how do I make it accept a char?
22:36:18 * dmwit blinks
22:36:19 <sclv> you don't -- it either accepts a string or a char.
22:36:28 <rwbarton> what are you actually trying to do? in english?
22:36:42 <sclv> "a" is not a char in haskell, it is a string with one element.
22:36:47 <sclv> 'a' is a char
22:36:56 <sclv> "a" actually = 'a':[]
22:37:01 <DOKKA> well, it is supposed to return the second to last element in a string
22:37:15 <sclv> oh so you only want to return a char then
22:37:21 <DOKKA> right
22:37:51 <dmwit> You'll have to pick a default value for when you have nothing to return.
22:37:54 <sclv> well your basic functions for extracting things from strings are (!!) and head and last, right.
22:37:54 <ddarius> > listToMaybe . drop 1 . reverse $ "saoehu"
22:37:55 <lambdabot>   Just 'h'
22:38:33 <sclv> so figure out how to get the second to last character in a position where you know how to extract it using those three functions.
22:39:07 <sclv> (listToMaybe is another extraction function -- that returns Just head if the list is nonempty, and Nothing otherwise)
22:39:31 <DOKKA> is there a way to cast a char into a sting?
22:39:43 <dibblego> [c]
22:39:46 <sclv> a string is just a list of characters.
22:39:56 <sclv> > ('a',['a'])
22:39:58 <lambdabot>   ('a',"a")
22:40:06 <DOKKA> oh so i can put it in brackets
22:40:28 <sclv> but that's not a cast -- that's actually putting the character into a list. haskell doesn't have casts, really, in the normal sense.
22:40:45 <dibblego> normal?
22:40:55 <sclv> dynamic language sense.
22:40:56 <DOKKA> yeah, i'm used to java
22:41:08 <sclv> or bad static typing sense...
22:41:19 <dibblego> abnormal :)
22:41:25 <arw> dibblego: you can only cast things where the type is not completely fixed. like an empty list.
22:41:28 <dibblego> @djinn a -> b
22:41:28 <lambdabot> -- f cannot be realized.
22:41:30 <dmwit> DOKKA: String is actually [Char].
22:41:43 <dmwit> DOKKA: So any list literal with Chars inside is a String:
22:41:44 <dibblego> arw, no you can't
22:41:48 <dmwit> > ['f', 'o', 'o']
22:41:50 <lambdabot>   "foo"
22:41:52 <sclv> I wouldn't call that casting arw
22:41:55 <ddarius> arw: That's not a cast.
22:41:55 <DOKKA> then why is haskell complaining?
22:42:10 <dmwit> DOKKA: Because x and [x] are not the same!
22:42:11 <sereven> > ('a',['a'],'a':[],'b':'a':[]) -- more ways to add chars to list
22:42:12 <lambdabot>   ('a',"a","a","ba")
22:42:16 <sclv> dokka: because a single char and a list containing a single char are different.
22:42:54 <dmwit> Also, stop anthropomorphizing languages.  They hate it when you do that. ;-)
22:42:57 <Axman6> "foo" !! 1
22:43:01 <Axman6> > "foo" !! 1
22:43:02 <lambdabot>   'o'
22:43:03 <DOKKA> so it is because it refuses it to convert it
22:43:04 <sclv> just like 1 is different from [1]
22:43:07 <Axman6> :t "foo" !! 1
22:43:08 <lambdabot> Char
22:43:10 <Twey> Hahaha
22:43:11 <chrisdone> anyone got a hGetLine for ByteString?
22:43:13 <adu> > 2
22:43:15 <lambdabot>   2
22:43:18 <adu> > showIntAtBase 24 (" !:ADHKOabdeiklmnorstuwy"!!) 318898098933210898223302273570557782488664849408264747911487069425 ""
22:43:19 <lambdabot>   "DOKKA: learn Haskell and it will blow your mind!"
22:43:20 <Axman6> > drop 1 "foo"
22:43:21 <lambdabot>   "oo"
22:43:25 <sclv> there's no "right" way to convert it
22:43:28 <dmwit> chrisdone: Check in ByteString.Char8
22:43:30 <Axman6> :t drop 1 "foo"
22:43:32 <lambdabot> [Char]
22:43:35 <ddarius> Hmm, if F is a comonad and F is left adjoint to U, is U then necessarily a monad?
22:44:04 <chrisdone> dmwit: my hero
22:44:09 <DOKKA> so in other words, it is easier to hack the other letters off of the string than convert a char to a string
22:44:11 <ManateeLazyCat> rwbarton: if i remove "let" from "let argsNumber = length args", why i have to got "parse error on input `=' " ? args is "args <- getArgs
22:44:37 <rwbarton> ManateeLazyCat: ... why wouldn't you get an error?
22:44:37 <dmwit> DOKKA: xs !! 2 is easier than [x]?
22:44:51 <dibblego> ManateeLazyCat, since you are inside a do-block
22:45:05 <sclv> its easy to make a char a string by putting it in a list -- the real question is what you want to return -- a single character, or a list of characters?
22:45:06 <ManateeLazyCat> dibblego: Explain detail?
22:45:18 <dibblego> ManateeLazyCat, a do-block you are inside?
22:45:24 <ManateeLazyCat> dibblego: Yep.
22:45:33 <dibblego> ManateeLazyCat, then that is why
22:45:43 <sclv> if what you really want to return is a single character, it is more appropriate to return a character, rather than a list which one would *hope* if your code is bugfree, will always have exactly one element.
22:45:44 <ManateeLazyCat> dibblego: need "let" if i in do-block?
22:45:48 <dibblego> ManateeLazyCat, correct
22:45:53 <sclv> that's how you can put the type system to work for you.
22:45:55 <DOKKA> a list of charictors
22:46:25 <dibblego> a list with 0 or 1 element is better known as Maybe
22:46:26 <adu> DOKKA: have you learned about Maybe Char yet?
22:46:33 <DOKKA> nope
22:46:50 <DOKKA> still on chapter 2
22:46:57 <adu> of what book?
22:47:04 <ManateeLazyCat> dibblego: If i out do-block, i can define a variable without "let", that's right?
22:47:09 <DOKKA> real world haskell
22:47:12 <adu> oh
22:47:18 <mm_freak_> i have the impression that hackage and all the libraries will run into trouble soon…  it appears like there are a lot of inconsistencies
22:47:19 <dmwit> ManateeLazyCat: Yes.
22:47:24 <dibblego> ManateeLazyCat, yes
22:47:32 <adu> also, the way I usually convert char to string is (replicate 1 'x')
22:47:35 <ManateeLazyCat> Thanks all. I see now. ;)
22:47:43 <dmwit> ManateeLazyCat: Things are different in a do-block because do blocks are just sugar for function calls.
22:47:48 <sclv> monkey robot ftw!
22:48:00 <dmwit> ManateeLazyCat: It's a bit like requiring "let" in the test of an "if" clause.
22:48:04 <rwbarton> ManateeLazyCat: I don't know why everyone else is saying "yes". :)
22:48:07 <chrisdone> yay BS version 3 times faster
22:48:26 <rwbarton> ManateeLazyCat: You can't just stick a variable binding in the middle of an expression, for example.
22:48:29 <dmwit> ManateeLazyCat: You wouldn't want "if x = y x then a else b" rather than "if let x = y in x then a else b".
22:48:36 <adu> DOKKA: although, ((:[]) 'x') is shorter
22:48:41 <DOKKA> it runs!
22:48:58 <DOKKA> lastButOne xs = if (length xs) < 3 then xs else [xs !! ((length xs) - 2)]
22:49:01 <adu> DOKKA: do you know what 'replicate' does?
22:49:09 <DOKKA> nope
22:49:14 <dmwit> DOKKA: You have a logic error.
22:49:14 <adu> :t replicate
22:49:15 <lambdabot> forall a. Int -> a -> [a]
22:49:27 <rwbarton> ManateeLazyCat: You can put variable bindings (1) at the top level (2) in a where block (3) in a let ... in expression (4) in a let command, inside a do block
22:49:33 <dmwit> > let lastButOne xs = if length xs < 3 then xs else [xs !! (length xs - 2)] in lastButOne "ab"
22:49:34 <lambdabot>   "ab"
22:49:39 <DOKKA> I'm gonna look it up though :)
22:49:52 <adu> DOKKA: replicate takes an Int (n) and replicates its second argument n times
22:49:53 <dmwit> > let lastButOne = take 1 . drop 1 . reverse in lastButOne "ab"
22:49:54 <lambdabot>   "a"
22:50:03 <dmwit> Also:
22:50:09 <dmwit> > let lastButOne xs = if length xs < 3 then xs else [xs !! (length xs - 2)] in lastButOne "a"
22:50:11 <lambdabot>   "a"
22:50:21 <dmwit> > let lastButOne = take 1 . drop 1 . reverse in lastButOne "a"
22:50:22 <lambdabot>   ""
22:50:35 <DOKKA> dmwit:oh I see how you're doing that
22:50:36 <ManateeLazyCat> This is say, need "let" in "do block" is make variable local, because "do block" is sugar of function call.
22:50:40 <ManateeLazyCat> Exactly?
22:50:59 <rwbarton> Well... a let "command" is part of the definition of do-notation.
22:51:34 <mm_freak_> ManateeLazyCat: a do block is not sugar for a function call…  it's sugar for monadic bindings
22:51:48 <dmwit> mm_freak_: Hush.  Also, monadic binding is a function call.
22:51:48 <adu> there are no "commands" in haskell
22:52:05 <ManateeLazyCat> Thanks all, i study many today :)
22:52:07 <mm_freak_> dmwit: a lot of them =)
22:52:26 <mm_freak_> usually
22:52:29 <rwbarton> ManateeLazyCat: I don't know why they chose the syntax to have the 'let' keyword; that's just the way it is :)
22:52:33 <adu> ManateeLazyCat: what language do you usually speak?
22:52:52 <ManateeLazyCat> adu: Chinese.
22:52:54 <mm_freak_> i propose changing 'do' to 'comp' in the next haskell version
22:53:00 <mm_freak_> the word 'do' is VERY misleading
22:53:11 <ManateeLazyCat> adu: My English is suck sometimes.
22:53:12 <sjanssen> 'comp'?
22:53:20 <rwbarton> why not 'xyzzy'?
22:53:29 <mm_freak_> sjanssen: 'computation'
22:53:33 <Axman6> i do love the way that people coming from different languages interpret english :)
22:53:33 <dibblego> perhaps 'for'
22:53:49 <adu> 简体中文？
22:53:55 <ManateeLazyCat> adu: Yep.
22:54:10 <Axman6> i think do is fine, just says do these things...
22:54:36 <mm_freak_> Axman6: but a monadic computation is not about doing things, but being things
22:54:55 <mm_freak_> > do x <- Just 3; y <- Just 4; return (x^y)
22:54:57 <lambdabot>   Just 81
22:54:58 <rwbarton> I guess it could be called 'bind'
22:55:13 <mm_freak_> (>>=) is 'bind', so in a sense '<-' is 'bind'
22:55:26 <Axman6> mm_freak_: don't you get technical with me young man :P
22:55:27 <rwbarton> very loosely bind : >>= :: sum : +
22:55:33 <mm_freak_> Axman6: ;)
22:55:54 <mm_freak_> rwbarton: how that?
22:56:05 <adu> mm_freak_: mm being things...
22:56:15 <sereven> being x <- Just 3; y <- Just 4; be (x^y) -- groovy man
22:56:29 <adu> i want to be a sandwich for a day
22:56:39 <mm_freak_> with c >>= f, you bind the result of c to the argument of f
22:56:46 <dmwit> x being Just 3; y being Just 4; be (x^y) -- totally
22:57:05 <dmwit> x being Just 3; y being Nothing; be (x^y) -- bummerific
22:57:19 <mm_freak_> with x being the result of Just 3 and y being the result of Just 4, be a computation that results in x^y
22:57:31 <rwbarton> pure functional cobol?
22:57:34 <adu> if you're a unix user, then "c >>= f" would read "c | xargs f"
22:57:35 <dmwit> I thought COBOL was dead.
22:57:48 <dmwit> s/xargs //
22:58:06 <rwbarton> mm_freak_: do binds together its statements, like sum adds together its arguments
22:58:06 <mm_freak_> adu: only in state monads
22:59:05 <mm_freak_> rwbarton: do is syntactic sugar for these bindings, but it's itself not a bind
22:59:21 <rwbarton> mm_freak_: It depends on whether you think <- or >>= is bind
22:59:29 <mm_freak_> it's the same ;)
22:59:32 <rwbarton> if >>= is bind, then do is binding things together
22:59:33 <rwbarton> no
22:59:38 <rwbarton> if <- is bind then variables are being bound
22:59:45 <mm_freak_> it is
22:59:49 <skorpan> BIND BIND BIND
22:59:59 <rwbarton> this is probably an idiolectal thing that's unresolvable.
23:00:13 <adu> (<-) <- (<-)
23:00:21 <mm_freak_> > [1,2,3] >>= \x -> return (2*x+1)
23:00:23 <lambdabot>   [3,5,7]
23:00:32 <mm_freak_> > do x <- [1,2,3]; return (2*x + 1)
23:00:34 <lambdabot>   [3,5,7]
23:00:45 <mm_freak_> the latter is just sugar for the former
23:00:52 <rwbarton> Look, I know how do notation works. :)
23:01:29 <adu> > do x <- [1..10] ; return (x/2)
23:01:30 <lambdabot>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
23:01:34 <mm_freak_> ok, then you agree that '<-' and (>>=) are the same ;)
23:01:43 <mm_freak_> just that the former requires a name
23:01:49 <rwbarton> Well, no.  Look how you had to move around a bunch of symbols
23:01:56 <rwbarton> But anyways, this is a pretty silly discussion
23:02:13 <adu> indeed, you're both right
23:02:44 <dmwit> indeed, you're mom
23:02:47 <dmwit> [sic]
23:03:24 <mm_freak_> moving around a bunch of symbols is the point of do-notation…  it should make bindings more readable by doing just that =)
23:03:32 <adu> wow, dmwit lowers to you're mom jokes...
23:03:36 <int80_h> I'm doing the happs_tutorial, and I run into the following error
23:03:56 <int80_h> $ ./hackInGhci.sh
23:03:56 <int80_h> GHCi, version 6.8.3: http://www.haskell.org/ghc/  :? for help
23:03:56 <int80_h> Loading package base ... linking ... done.
23:03:56 <int80_h> src/Main.hs:14:7:
23:03:56 <int80_h>     Could not find module `Text.StringTemplate.Helpers':
23:03:58 <int80_h>       Use -v to see a list of the files searched for.
23:04:01 <int80_h> Failed, modules loaded: none.
23:04:05 <int80_h> how can I find this module?
23:04:06 <mm_freak_> however, you're right, there are better things to argue about =)
23:04:26 <int80_h> or rather, how can I make sure ghci finds it
23:04:41 <adu> > printCipher "all is one and one is all"
23:04:42 <lambdabot>   Not in scope: `printCipher'
23:04:44 <ManateeLazyCat> adu: You can speak Chinese?
23:04:55 <adu> ManateeLazyCat: nope
23:05:01 <mm_freak_> > pack "test"
23:05:03 <lambdabot>   Not in scope: `pack'
23:05:05 <mm_freak_> > BS.pack "test"
23:05:07 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
23:05:18 <Axman6> > L8.pack "test"
23:05:20 <lambdabot>       Failed to load interface for `L8':
23:05:20 <lambdabot>        Use -v to see a list of the f...
23:05:32 <mm_freak_> > B.pack "test"
23:05:33 <lambdabot>       Failed to load interface for `B':
23:05:33 <lambdabot>        Use -v to see a list of the fi...
23:05:37 <Axman6> > Data.ByteString.Lazy.pack "test"
23:05:39 <adu> ManateeLazyCat: I know: nihao ma? but then again, who doesn't....
23:05:39 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
23:05:46 <Axman6> > Data.ByteString.Lazy.Char8.pack "test"
23:05:48 <lambdabot>   Chunk "test" Empty
23:07:27 <ddarius> @let eps = uncurry id
23:07:28 <lambdabot>  Defined.
23:07:30 <ddarius> :t eps
23:07:31 <lambdabot> forall b c. (b -> c, b) -> c
23:07:38 <mm_freak_> > BS.pack (map (fromIntegral . ord) "test")
23:07:39 <lambdabot>   /tmp/3261697041910498674:70:32: Not in scope: `BS.pack'
23:07:50 <mm_freak_> > BS.pack (map (fromIntegral . ord) "you suck")
23:07:51 <lambdabot>   /tmp/8452933948523356273:70:32: Not in scope: `BS.pack'
23:08:08 <ddarius> :t (eps .)
23:08:10 <lambdabot> forall b c a. (a -> (b -> c, b)) -> a -> c
23:08:15 <adu> 不过，我知道如何使用 translate.google.com
23:08:25 <ManateeLazyCat> adu: Exactly, is "Ni Hao Ma?"
23:08:44 <mm_freak_> Ni Hao = hello, isn't it?
23:09:04 <ManateeLazyCat> adu: And result is "I'm fine!" ;)
23:09:14 <ManateeLazyCat> mm_freak_: Yep.
23:09:34 <int80_h> anyone have any ideas on how I can get ghci to find that module?
23:10:16 <mm_freak_> int80_h: when you install modules, make sure they are registered
23:10:27 <mm_freak_> cabal-install is a very convenient interface to cabal and hackage
23:10:35 <ManateeLazyCat> adu: babel.el a extension that interface transform.google.com
23:10:47 <adu> cool
23:10:50 <ddarius> @let eps' = fst
23:10:51 <lambdabot>  Defined.
23:10:52 * ManateeLazyCat pasted "babel.el" at http://paste2.org/p/123891
23:10:53 <ManateeLazyCat> adu: In emacs.
23:11:01 <ddarius> :t eps' . (eps .)
23:11:03 <lambdabot>     Couldn't match expected type `(a, b)'
23:11:03 <lambdabot>            against inferred type `a1 -> c'
23:11:03 <lambdabot>     Probable cause: `.' is applied to too few arguments
23:11:05 <ManateeLazyCat> adu: See http://paste2.org/p/123891 , a devel version
23:11:40 <ManateeLazyCat> adu: babel.el not just for transform.google.com, have many interface.
23:12:04 <adu> i use emacs all the time, but not for irc
23:12:27 <int80_h> mm_freak: I didn't install that module. happs_turoial didn't say I needed to install it. This implies to me that it comes installed with ghc
23:12:38 <ManateeLazyCat> adu: I have write many extension for emacs. ;)
23:13:02 <ManateeLazyCat> adu: Welcome to #emacs ;)
23:13:35 <ManateeLazyCat> adu: I'm use erc for IRC.
23:14:22 <byorgey> int80_h: Text.StringTemplate.Helpers?  I don't think that comes with GHC.
23:14:44 <int80_h> hmm, okay I think maybe I didn't read something I should have
23:15:00 <byorgey> int80_h: looks like it's in this package: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HStringTemplateHelpers
23:15:25 <adu> :t (. eps)
23:15:26 <lambdabot> forall c b c1. (c1 -> c) -> (b -> c1, b) -> c
23:15:45 <byorgey> int80_h: and it looks like the happs-tutorial package depends on it.
23:16:04 <byorgey> int80_h: how did you manage to install happs-tutorial without installing one of its dependencies?
23:16:06 <int80_h> byorgey, thanks
23:16:07 <ManateeLazyCat> Have *unless* sentence in Haskell?
23:16:25 <rwbarton> ManateeLazyCat: No
23:16:35 <dmwit> :t when
23:16:36 <int80_h> byorgey, I used darcs
23:16:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:16:37 <dmwit> :t unless
23:16:38 <rwbarton> ManateeLazyCat: An if statement always has both a then and an else clause, so there wouldn't be much point
23:16:38 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:17:03 <rwbarton> Well, OK :)
23:17:07 <rwbarton> @src unless
23:17:07 <lambdabot> unless p s = if p then return () else s
23:17:08 <int80_h> byogrey: the instructions gave the option of using either cabal-install (which I had trouble with) or use darcs (which seemed to work fine
23:17:10 <jeffz`> ManateeLazyCat: do you ever find that url-retrieve-synchronously blocks indefinitely sometimes?
23:17:12 <dmwit> > unless False [(), (), ()]
23:17:13 <lambdabot>   [(),(),()]
23:17:19 <byorgey> int80_h: hmm, strange, it seems like it would have failed to build
23:17:20 <dmwit> > unless True [(), (), ()]
23:17:21 <lambdabot>   [()]
23:17:29 <byorgey> int80_h: well, anyway, you can just install the package you're missing
23:17:34 <ManateeLazyCat> jeffz`: babel.el not my extension
23:17:39 <int80_h> ya thanks :)
23:17:42 <byorgey> int80_h: what trouble did you have with cabal-install, if I may ask?
23:17:47 <ManateeLazyCat> jeffz`: And i know that problem.
23:18:00 <int80_h> byorgey: I can't remember. I can try again to re-duplicate the error
23:18:06 <jeffz`> ManateeLazyCat: ah
23:18:08 <byorgey> you should be able to just download the cabal-install tarball and run the bootstrap.sh script
23:18:40 <ManateeLazyCat> jeffz`: I'm not author, just i modified babel.el, i have report this synchronous problem to author of babel.el
23:18:43 <byorgey> int80_h: oh, wait, do you mean you had trouble installing cabal-install?  or trouble using it to install happs-tutorial?
23:18:48 <int80_h> $ cabal install happs-tutorial
23:18:48 <int80_h> Resolving dependencies...
23:18:48 <int80_h> cabal: cannot configure happs-tutorial-0.6.3. It requires base >=3.0.3.0
23:18:49 <int80_h> There is no available version of base that satisfies >=3.0.3.0
23:19:13 <int80_h> I had ^^ that trouble using it to install happs-tutorial
23:19:50 <int80_h> I would need to install a higher version of ghc, right?
23:19:55 <byorgey> int80_h: hmm, it looks like it has required ghc-6.10 since version 0.4.4
23:19:58 * ManateeLazyCat pasted "auto-install.el" at http://paste2.org/p/123892
23:20:12 <mmorrow> , fmap (utf8enc . (:[])) "不过，我知道如何使用"
23:20:14 <lunabot>  ["\228\184\141","\232\191\135","\239\188\140","\230\136\145","\231\159\16...
23:20:21 <byorgey> int80_h: yes, but I don't see how you can get around that by building it yourself
23:20:31 <pumpkin> lol
23:20:33 <byorgey> dependencies are dependencies
23:20:36 <int80_h> okay, well that's my next challenge. 6.20 isn't in netbsd's pkgsrc yet
23:20:41 <int80_h> I mean 6.10
23:20:50 <ManateeLazyCat> jeffz`: See http://paste2.org/p/123892 , i download many elisp file asynchronous use `url-retrieve'. You can ask me more detail in #emacs
23:21:08 <int80_h> I'll have to build 6.10 myself.
23:21:24 <byorgey> int80_h: nah, you can just get a binary distribution from the ghc website
23:21:30 <byorgey> no need to actually build it yourself.
23:21:34 <int80_h> there isn't one for netbsd
23:21:39 <ManateeLazyCat> int80_h: Why? You can just download binary distribution.
23:21:42 <byorgey> oh, I see =(
23:22:01 <int80_h> I suppose I could run linux emulation, or install a debian virtual machine
23:22:26 <int80_h> I was thinking about installing a debian vm anyway. linux seems to have more attention paid to it by the haskell folks
23:22:36 <ManateeLazyCat> int80_h: I have install GHC 6.10 with Debian successful
23:22:52 <int80_h> I suspect I will save myself future problems just by installing debian now
23:23:12 <rwbarton> Debian won't provide much help in terms of what's actually packaged in the repository.  (ghc 6.8.2)
23:23:16 <ddarius> :t uncurry (uncurry id)
23:23:17 <lambdabot> forall b b1 c. ((b -> b1 -> c, b), b1) -> c
23:23:22 <int80_h> or I could just start porting things to netbsd. More things I mean. SOme haskell things are in pkgsrc. Just not much
23:23:33 <int80_h> ooooh
23:23:38 <byorgey> int80_h: interesting, netbsd is binary-incompatible with linux?
23:23:42 <rwbarton> No cabal-install either
23:23:54 <int80_h> byurgey, I can run linux emulation if I want
23:23:59 <dmwit> byorgey: They have a different ABI, as I recall.
23:24:12 <byorgey> I see.
23:24:31 <geezusfreeek> http://okmij.org/ftp/Haskell/Iteratee/ yes!
23:25:05 <int80_h> will I have to tell cabal about my new ghc install?
23:25:49 <ManateeLazyCat> rwbarton: So if i just can use "when (not foo)" ?
23:26:02 <dmwit> unless foo = when (not foo)
23:26:10 <byorgey> int80_h: no, but you will need to reinstall any packages
23:26:29 <rwbarton> ManateeLazyCat: Yeah, dmwit is right, there's an unless in the standard libraries
23:26:42 <ddarius> @let eta = curry id
23:26:43 <lambdabot>  Defined.
23:26:43 <ddarius> :t eta
23:26:44 <ManateeLazyCat> dmwit:
23:26:44 <lambdabot> forall a b. a -> b -> (a, b)
23:26:44 <byorgey> int80_h: cabal will just use whichever version of ghc is the default (i.e. whichever version 'ghc' points to)
23:26:55 <int80_h> ah!
23:27:02 <int80_h> and I can always change that
23:27:12 <ManateeLazyCat> dmwit: rwbarton So i need type more "not"
23:27:34 <byorgey> int80_h: yeah, although it's slightly more tricky than that, there's also ghc-pkg, runghc, ghci...
23:27:34 <ddarius> @let delta (a,r) = ((a, r), r)
23:27:35 <lambdabot>  Defined.
23:27:35 <dmwit> ManateeLazyCat: Hopefully, you need to type fewer "not"s. =)
23:27:36 <ddarius> :t delta
23:27:37 <lambdabot> forall t t1. (t, t1) -> ((t, t1), t1)
23:27:41 <byorgey> all those need to point to the right version too
23:28:24 <ddarius> :t ((uncurry eps . delta) .) . eta
23:28:25 <lambdabot> forall c t1. (t1 -> t1 -> c) -> t1 -> c
23:30:05 <ddarius> :t curry (uncurry eps . delta)
23:30:07 <rwbarton> ddarius: I think the answer to your question about monads and adjoints from a while ago is yes
23:30:07 <lambdabot> forall b c. (b -> b -> c) -> b -> c
23:31:11 <ddarius> > (curry (uncurry eps . delta)) (,) x
23:31:13 <lambdabot>   (x,x)
23:38:15 <ClaudiusMaximus> hello, is it possible at all to use HSH in background thread in a GTK application?  i get "thread blocked indefinitely" error when i try
23:38:32 <rwbarton> ddarius: just because, if F_i is left adjoin to G_i, i = 1, 2, then a natural transformation F_1 -> F_2 is the same as a natural transformation G_2 -> G_1.
23:40:52 <rwbarton> ddarius: hmm, maybe that's false
23:47:46 <ManateeLazyCat> What's wrong with "when (not (uri =~ "^https?" :: Bool))" ? "IO ()" against type "()", how to fix it?
23:48:19 <dmwit> > 16^3
23:48:20 <lambdabot>   4096
23:48:43 <dmwit> ManateeLazyCat: The problem is later.
23:48:58 <dmwit> ManateeLazyCat: In the next argument to "when".
23:49:24 <dmwit> Also, you can simplify to
23:49:34 <dmwit> unless (uri =~ "^https?")
23:51:02 * ManateeLazyCat pasted "my code" at http://paste2.org/p/123898
23:51:13 <ManateeLazyCat> dmwit: See http://paste2.org/p/123898 , something wrong?
23:52:03 * rwbarton reminisces of the olden days when the hpaste bot used to work
23:52:12 <ManateeLazyCat> dmwit: If not ":: Bool", ghci how to know which type i need ?
23:52:16 <dmwit> ManateeLazyCat: You need "$ do" there
23:52:35 <dmwit> unless (uri =~ "^https?") $ do
23:52:39 <dmwit>   putStrLn ...
23:52:41 <dmwit>   ...
23:52:44 <rwbarton> ManateeLazyCat: BTW, the do on line 13 is extraneous
23:52:47 <ManateeLazyCat> dmwit: Okay, works now
23:53:01 * ddarius doesn't know why he doesn't refer to CftWM mork often
23:53:16 <ManateeLazyCat> dmwit: What's different between "do" and "$ do"
23:53:40 <dmwit> ?src ($)
23:53:40 <lambdabot> f $ x = f x
23:53:59 <dmwit> ManateeLazyCat: Without ($), you would need parentheses around the entire do-block.
23:54:55 <ManateeLazyCat> dmwit: why not need "$ do" with "case foo of" in my code?
23:55:51 <dmwit> ManateeLazyCat: ($) is just a function
23:56:02 <rwbarton> ManateeLazyCat: You already have the do, on line 7
23:56:08 <dmwit> ManateeLazyCat: "when" takes a monadic action as its final argument.
23:58:09 <dmwit> ManateeLazyCat: http://paste2.org/p/123901 # a refactor
23:58:28 <pumpkin> :t when
23:58:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:59:00 <dmwit> :t \errors -> mapM_ putStrLn errors >> exitWith (ExitFailure 1)
23:59:01 <lambdabot> Not in scope: `exitWith'
23:59:01 <lambdabot> Not in scope: data constructor `ExitFailure'
23:59:10 <dmwit> bah
23:59:45 <dmwit> ?index exitWith
23:59:46 <lambdabot> System.Exit
