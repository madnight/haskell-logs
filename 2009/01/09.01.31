00:00:06 <Gracenotes> mmorrow: yes, I reached the conclusion as well. Better to have one standard API for dealing with a Room than two separate ones identical save Array vs. STArray
00:00:16 <mmorrow> exactly
00:00:50 <mmorrow> (although if that's the only difference, you can freeze/unfreeze the array)
00:01:09 <mmorrow> but yeah, that might be more trouble than it's worth
00:01:26 <Gracenotes> well. The other difference is supposed to be performance :)
00:02:04 <mmorrow> check out freeze/unfreeze
00:02:06 <ray> > True / 2
00:02:07 <lambdabot>       No instance for (Fractional Bool)
00:02:07 <lambdabot>        arising from a use of `/' at <...
00:02:15 <mmorrow> Array <--> STArray
00:02:22 <Gracenotes> mmorrow: I am using freeze/thaw on a larger level
00:02:27 <ray> so with no fractional instance how do we express half-truths in haskell
00:02:29 <mmorrow> ah, yes i meant thatw
00:02:32 <mmorrow> *thaw
00:03:01 <mmorrow> ray: segfault?
00:03:13 <ray> @src Fractional
00:03:13 <lambdabot> class  (Num a) => Fractional a  where
00:03:13 <lambdabot>     (/)             :: a -> a -> a
00:03:13 <lambdabot>     recip           :: a -> a
00:03:13 <lambdabot>     fromRational    :: Rational -> a
00:03:29 * ray has his work cut out for him!
00:03:32 <Gracenotes> I'm not using it in the belly of the beast, though, only when converting to STArray, making the changes, and then converting back to Array
00:04:11 <ray> hmm, maybe you can't divide True by 2, but you can divide Just True by 2 and get Nothing
00:04:11 <Gracenotes> @pl \x -> y >>= \y -> return (f x)
00:04:11 <lambdabot> (y >>=) . const . return . f
00:04:22 <Gracenotes> hm.
00:04:42 <Gracenotes> @pl \x -> y >>= \y -> return (f y x)
00:04:42 <lambdabot> (`fmap` y) . flip f
00:04:48 <Gracenotes> @pl \x -> y >>= \y -> return (f x y)
00:04:48 <lambdabot> (`fmap` y) . f
00:06:11 <dmwit> dobblego: Have you installed xmonad correctly?
00:06:19 <dmwit> dobblego: (re: your question in #xmonad)
00:06:30 <dobblego> dmwit, I've no idea
00:06:54 <dobblego> dmwit, I get an error if I have a ~/.xmonad/xmonad.hs file, but xmonad.errors contains nothing
00:07:04 <dmwit> dobblego: What does ghc-pkg list xmonad say?
00:07:23 <dmwit> Also, if you navigate to ~/.xmonad and hit ghci xmonad.hs, what errors do you get?
00:08:48 <dobblego> http://rafb.net/p/CAlhMa69.html and no errors
00:10:01 <dmwit> Okay, so it's installed --user.  I don't *think* that should be a problem.
00:10:16 <dmwit> And what was this about "module `XMonad' not found"?
00:10:21 <mmorrow> ray: (Maybe Bool) ?
00:10:45 <mmorrow> oh, you already suggested that
00:11:02 <dobblego> dmwit, what was an error message I got earlier
00:11:10 <dmwit> dobblego: I should note that if everything is working correctly, mod+q will appear to do absolutely nothing.
00:11:27 <dobblego> dmwit, I had ghc 6.8.2 installed with apt-get so I uninstalled it and now I get no error
00:11:30 <ray> yeah, i think i could do instances for Maybe Bool, returning Nothing liberally
00:11:42 <dmwit> dobblego: Ah, yeah, okay.
00:11:47 <mmorrow> save a little spike in you realtime cpu% graph on you gnome-panel :)
00:11:51 <dmwit> dobblego: Then may I suggest that everything may be working...?
00:11:55 <mmorrow> *youR
00:11:57 <dmwit> mmorrow: right =)
00:12:34 <dobblego> dmwit, it's not working since I get an error message when I first go into xmonad, xmonad.errors is empty and a few of my key bindings do not work
00:12:47 <Gracenotes> hm. How do you all usually indent functions-that-are-entirely-do-blocks?
00:13:00 <ray> i wonder how xmonad has changed since i used it
00:13:00 <Gracenotes> it seems having the 'do' dangle is popular
00:13:08 <ray> yeah, dangling do
00:13:21 <ray> what other way is there? :)
00:13:40 <dmwit> dobblego: What message do you get?
00:13:41 <mmorrow> dobblego: maybe try debugging it with ghci until you get it to :load
00:13:53 <Gracenotes> a very long function name and then everything else = do stuff and more stuff and reaching the end of the screen
00:14:02 <Gracenotes>                                                                        but here's a line break in time
00:14:19 <dobblego> dmwit, I'll have to go back into xmonad, but it is very general and says to check a file
00:14:22 <Gracenotes> okay. Yeah. Bad idea.
00:14:34 <mmorrow> Gracenotes: i do both, but in that case i go with the dangling do
00:15:07 <mmorrow> dobblego: just try loading xmonad.hs in ghci
00:15:11 <Gracenotes> since it is a matter of aesthetics, one may as well apply it where aesthetics demand :)
00:15:17 <Gracenotes> kthen.
00:15:21 <dobblego> mmorrow, I have and it loads fine
00:15:26 <mmorrow> oh, weird
00:16:24 <mmorrow> maybe a different ghc is in-PATH when you try to login into xmonad?
00:16:44 <dibblego> there's only one GHC now
00:17:15 <dmwit> Okay, we'll get a bit more information now.
00:17:20 <mmorrow> reboot
00:17:24 <dmwit> It will help to have the actual error message. =)
00:17:31 * ray can be the second OLPC xmonad user, maybe
00:17:51 <dibblego> Error detected while loading xmonad configuration file: /home/blah/.xmonad/xmonad.hs\n\nPlease check the file for errors.
00:18:05 <mmorrow> oh, i thought you just quit
00:18:06 <dmwit> Wow.
00:18:13 <dmwit> That is a totally useless error message.
00:18:18 <ray> bogus
00:18:26 <dibblego> I am on a different machine now
00:18:34 <dibblego> well the file doesn't contain errors anyway
00:19:04 * mmorrow has no ideas
00:19:11 <dmwit> Hm.
00:19:22 <dmwit> Well, according to the source, that means that the contents of "ghcErr" is empty.
00:19:24 <dibblego> can xmonad find my ghc just by looking on the PATH that I set in ~/.bashrc ?
00:19:29 <dmwit> No.
00:19:37 <dibblego> how can I point it there?
00:19:47 <dmwit> It will have to be in the PATH defined in ~/.bashenv or whatever your environment file is.
00:19:48 <mmorrow> give it an absolute path
00:19:50 * dmwit doesn't know bash
00:21:24 <Gracenotes> @hoogle Monad m => m Bool -> whatever
00:21:25 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:21:25 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:21:25 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:21:47 <dibblego> I just found more info in ~/.xsession-errors /home/blah/.xmonad/xmonad-x86_64-linux: executeFile: does not exist (No such file or directory)
00:22:32 <mmorrow> where is you ghc?
00:22:33 <dmwit> It's likely due to not finding ghc, though.
00:22:36 <dibblego> /opt/ghc
00:22:50 <Axman6> Gracenotes: when? guard?
00:22:51 <C-Keen> dibblego: this needs to be in your PATH
00:22:52 <Gracenotes> @hoogle Monad m => m Boool -> Maybe whatever
00:22:52 <lambdabot> Warning: Unknown type Boool
00:22:52 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:22:52 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:22:52 <mmorrow> maybe make a symlink in /usr/bin as a for-now hack
00:22:59 <dmwit> Since the error "Error detected while loading ..." comes up when executing "ghc" returns an error code.
00:23:05 <mmorrow> ah
00:23:24 <dibblego> C-Keen, it is in my PATH; I set it in ~/.bashrc
00:23:26 <dmwit> mmorrow: The source is a good reference. ;-)
00:23:36 * mmorrow is lazy
00:23:38 <dmwit> dibblego: .bashrc doesn't get read for non-interactive shells
00:24:02 * mmorrow also can't remember how he got his xmonad setup
00:24:03 <C-Keen> dibblego: It needs to be in your PATH when .xsession gets executed and that is likely before that if you use a graphical login manager like xdm
00:24:46 <Gracenotes> Axman6: I'm converting a code segment to use monads. It's a function guard, so it would now be like | bool :: ST s Bool = result :: ST s Delta | anotherbool :: ST s Bool = anotherresult :: ST s Delta
00:24:50 <Gracenotes> with a few other guards
00:25:29 <Gracenotes> the problem is with the ST s Bools. I could simply have bool' <- bool in the do block, but that seems awkward
00:25:52 <Gracenotes> @hoogle Monad m => m Bool -> Maybe whatever
00:25:52 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:25:52 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:25:52 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
00:26:40 <dmwit> dibblego: Try mucking your PATH about in ~/.profile instead.
00:26:51 <dmwit> (From the bash man pages.)
00:26:54 <Axman6> :t ap (+)
00:26:55 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
00:27:02 <dibblego> dmwit, working on it - getting different errors now
00:27:14 <Axman6> :t ap (+) negate
00:27:15 <lambdabot> forall a. (Num a) => a -> a
00:27:25 <Axman6> > ap (+) negate 10
00:27:26 <lambdabot>   0
00:27:36 <Axman6> > ap (+) negate (-100
00:27:37 <lambdabot>   <no location info>: parse error on input `;'
00:27:38 <Axman6> > ap (+) negate (-100)
00:27:39 <lambdabot>   0
00:27:52 <Gracenotes> const 0 is much more inclusive :P
00:28:00 <Axman6> @check \x -> ap (+) negate x == 0
00:28:01 <lambdabot>   "OK, passed 500 tests."
00:29:19 <Gracenotes> on the other hand..
00:29:25 <Gracenotes> @check \x -> ap (*) (1/) x == 1
00:29:26 <lambdabot>   "Falsifiable, after 6 tests:\n0.0\n"
00:29:43 <Gracenotes> @check \x -> x == 0 || ap (*) (1/) x == 1
00:29:44 <lambdabot>   "Falsifiable, after 68 tests:\n25.363636363636363\n"
00:30:42 <Axman6> :t ap
00:30:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:32:39 <dibblego> import XMonad; main = xmonad defaultConfig -- is this enough for a starting xmonad.hs? ?
00:32:43 <Gracenotes> > runST $ do {a <- undefined; return 4}
00:32:44 <lambdabot>   /tmp/3959953208377376932:70:36: Not in scope: `runST'
00:32:49 <Gracenotes> , runST $ do {a <- undefined; return 4}
00:32:50 <lunabot>  luna: Prelude.undefined
00:33:01 <Gracenotes> so it's not lazy...
00:33:04 <sereven> dibblego: yes
00:33:18 <dibblego> well blimey it's working
00:33:32 <Gracenotes> , runST $ do {a <- last [1..]; return 4}
00:33:33 <lunabot>  luna: Could not deduce (GHC.Num.Num (GHC.ST.ST s t)) from the context ()
00:33:40 <dibblego> thanks for the help - I'll fiddle with this file and break it now :)
00:33:45 <Gracenotes> , runST $ do {a <- return (last [1..]); return 4}
00:33:46 <lunabot>  4
00:33:57 <Gracenotes> so maybe it is lazy.
00:34:13 <Gracenotes> , runST $ do {a <- return undefined; return 4}
00:34:14 <lunabot>  4
00:35:27 <Gracenotes> no, tisn't.
00:37:40 <Gracenotes> @type sequence
00:37:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:39:21 <Gracenotes> , runST $ do {a <- sequence [return 4, return 3, undefined]; return (head a)}
00:39:22 <lunabot>  luna: Prelude.undefined
00:39:29 <Gracenotes> eesh.
00:40:07 <Gracenotes> , fromJust $ do {a <- sequence [Just 3, Just 2, undefined]; return (head a)}
00:40:08 <lunabot>  luna: Prelude.undefined
00:41:09 <Gracenotes> I think I might be missing something about what it means for a monad to be 'lazy'
00:41:26 <hackage> Uploaded to hackage: UrlDisp 0.1.3
00:41:56 <Gracenotes> , let bot = bot in fromJust $ do {a <- sequence [Just 3, Just 2, Just bot]; return (head a)}
00:41:57 <lunabot>  3
00:42:02 <Gracenotes> , let bot = bot in fromJust $ do {a <- sequence [Just 3, Just 2, bot]; return (head a)}
00:42:04 <lunabot>  luna: out of memory (requested 2097152 bytes)
00:44:56 <Gracenotes> , let f = do a <- undefined; return 4 in runST $ do {a <- sequence [Just 3, Just 2, f]; return (head a)}
00:44:57 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe [b]'
00:45:05 <Gracenotes> , let f = do a <- undefined; return 4 in runST $ do {a <- sequence [return 3, return 2, f]; return (head a)}
00:45:06 <lunabot>  luna: Inferred type is less polymorphic than expected
00:46:14 <Gracenotes> , let f :: ST s Integer, f = do a <- undefined; return 4 in runST $ do {a <- sequence [return 3, return 2, f]; return (head a)}
00:46:15 <lunabot>  luna: parse error on input `,'
00:46:21 <Gracenotes> , let f :: ST s Integer; f = do a <- undefined; return 4 in runST $ do {a <- sequence [return 3, return 2, f]; return (head a)}
00:46:22 <lunabot>  luna: Prelude.undefined
00:46:37 <NameAlreadyInUse> @src []
00:46:38 <lambdabot> data [] a = [] | a : [a]
00:56:48 <hassanslash> hi all
00:57:20 <hassanslash> anyone able to help me implement the ID3 algorithm? I have a question please.
00:59:26 <hassanslash> Anyone know how to implement ID3 decision tree algorithm? please help
01:01:02 <lunabot>  luna: lexical error in string/character literal at end of input
01:01:25 <mmorrow> wut
01:01:30 <mmorrow> * laziest has quit ("unsafeInterleaveIO $ exitWith ExitSuccess")
01:01:36 <mmorrow> bug
01:01:40 <hassanslash> mmorrow
01:01:48 <hassanslash> you know how to implement ID3 algorithm?
01:01:57 <mmorrow> i was talking about how that triggered lunabot :)
01:02:32 <mmorrow> i don't, but wikipedia might be a good place to start
01:02:42 <NameAlreadyInUse> how feasible is it to hand write a parser?
01:02:49 <mmorrow> for what?
01:03:01 <NameAlreadyInUse> a simple pascal-like language
01:03:11 <Gracenotes> :t when
01:03:11 <mmorrow> that might be painful
01:03:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:03:13 <NameAlreadyInUse> (i know this is OT but i couldn't think of a better place to ask)
01:03:25 <mmorrow> NameAlreadyInUse: what language are you using?
01:03:48 <NameAlreadyInUse> C
01:04:07 <mmorrow> ah. maybe look into yacc/bison
01:04:28 <NameAlreadyInUse> ok, i will try bison
01:04:56 <mmorrow> maybe + flex too
01:05:27 <Gracenotes> huh. It would almost be nice to have a lazy ST (as contradictory as the phrase is), but I don't think there's a lazy STArray with performance benefits :)
01:06:49 <dormoose> NameAlreadyInUse: Flex is a lexer generator -- it chunks your input data into so-called tokens (numbers, identifiers, stuff).
01:07:24 <NameAlreadyInUse> yeah, i would prefer to hand write the lexer though
01:07:39 <dormoose> NameAlreadyInUse: Bison is a parser generator -- you describe your grammar there, and you describe what to do when encountering a grammar construct (like, if you see a variable declaration, allocate the memory).
01:08:37 <NameAlreadyInUse> yeah, i am briefly acquainted with flex and bison
01:08:45 <NameAlreadyInUse> i just wasn't sure how difficult it was to hand write a parser
01:08:52 <dormoose> Pretty badâ€¦
01:10:00 <hassanslash> Still looking for help on implementing the ID3 algorithm, if anyone can lend me a hand.
01:12:57 <Axman6> hassanslash: what's it do?
01:15:30 <hassanslash> Axman6: It's an old algorithm used to create decision trees.
01:16:06 <hassanslash> Axman6: I'm trying to find out how I should be implementing it in C++ or Java, based on my input.
01:16:35 <Axman6> righto, well i have no idea, sorry :\
01:16:47 <hassanslash> No problem mate
01:16:50 <the_unmaker> decisions decisions
01:17:18 <the_unmaker> IM tired of young women hitting on me
01:17:27 <int80_h> okay this is only indirectly a haskell question, insofar I will be using this series to write a computation
01:17:43 <int80_h> but does this series look familiar to anyone?
01:17:57 <int80_h> 1^1+2^2+3^3.....n^n
01:18:16 <int80_h> can that be express in a more computationally convenient form?
01:18:28 <int80_h> or is there a way to reason about it, to arrive at that form?
01:18:55 <mmorrow> hassanslash: what do you mean "how"?
01:21:10 <mmorrow> looking at the wikipedeia page, it looks like there's even an explicit statement of the algo there
01:21:35 <mmorrow> and the external links link to multiple implem in diff langs
01:22:18 <mmorrow> nice, looks like there's even an implem on hackage
01:22:40 <mmorrow> source code:
01:22:41 <mmorrow> http://hackage.haskell.org/packages/archive/DecisionTree/0.0/doc/html/src/Data-DecisionTree.html
01:22:56 * int80_h pours through his calculus book for help
01:23:01 <hassanslash> yes, but I need it in C++
01:23:10 <hassanslash> I need the sourcecode in C++
01:23:14 <int80_h> hahahaha
01:23:16 <mmorrow> translate it! :)
01:23:45 <hassanslash> haha, I can't :( I don't know haskell
01:23:45 <mmorrow> i would be amazed if you couldn't find a C++ implem on the internet
01:23:58 <hassanslash> believe me I am trying to, still no luck
01:24:47 <int80_h> you've come to a haskell channel for c++ help?
01:25:20 <hassanslash> yes, unfortunately.
01:25:25 <mmorrow> http://www.id3.org/Implementations
01:25:30 <hassanslash> consider it a last resort
01:26:21 <hassanslash> I believe that's the music ID3 tag
01:26:48 * int80_h dubs thee Saint mmorrow.
01:27:25 <mmorrow> hassanslash: does it not use the same algo? (i don't know)
01:28:29 <mmorrow> hassanslash: anyhow, it seems to me it'd be pretty easy to use the description of the algo here and code it up in C  http://en.wikipedia.org/wiki/ID3_algorithm
01:28:43 <hassanslash> mmorrow: nope, it doesnt mate
01:29:01 <mmorrow> what do you need this for?
01:29:13 <hassanslash> a c++ project
01:29:24 <int80_h> bah, I combed my calculus book for a clue. Nuffing
01:29:44 <int80_h> maybe I hsould move on to another problem for now
01:29:51 <mmorrow> hassanslash: so you're looking for a library including this algo then
01:30:13 <mmorrow> you don't want to implem it yourself
01:30:28 <hassanslash> mmorrow: indeed. Nope, because I dont think I have to
01:34:35 <mmorrow> hassanslash: http://www.sgi.com/tech/mlc/
01:35:04 <int80_h> mmorrow: I'm working on euler problem 48, and I have to believe there's something other than a brute force method as a solution
01:35:27 <int80_h> I gave in and googled for answers. and guess what...someone brute forced it
01:35:31 <mmorrow> int80_h: i'm not familiar with it
01:35:34 <int80_h> bah,
01:35:45 <int80_h> oh well, I need to find the last ten digits of this series
01:35:51 <mmorrow> i think there's a haskell wiki page with a bunch of solutions though
01:36:18 <int80_h> 1^1+2^2+3^3+...1000^1000
01:36:41 <int80_h> I know I can write that in a more elegant way
01:36:56 <int80_h> I'd like to discover it, instead of cheating
01:37:09 <int80_h> I mean, yeah I can calculate that number
01:37:15 <int80_h> turn it into a string
01:37:26 <int80_h> and take the last ten digits
01:38:10 <int80_h> but it's a series, it's got to be expressible in some other form
01:38:32 <pao> @seen Cale
01:38:32 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 7h 50m 34s ago.
01:38:43 * pao thinks Cale's sleeping
01:38:56 <int80_h> yesh, Cale can help.
01:39:09 <Gracenotes> not all series have closed forms
01:39:28 <int80_h> but I must ask him secretly so I don't get 10 people blurting out the answer
01:39:52 <int80_h> Gracenotes: ah, so this might be one that doesn't?
01:40:05 <int80_h> that would explain why I can't find it anywhere. including my calc book
01:40:59 <Gracenotes> I've never heard of it. It's odd.
01:41:12 <int80_h> gracenotes: wouldn't the brute force method take too long though? that's one big number
01:41:28 <Gracenotes> n^n isn't too friendly in terms of calculus, either :)
01:41:53 <Gracenotes> There is the trick where you can sometimes integrate a series to get its closed form. I don't quite remember it, and I'm pretty sure it won't work here
01:42:13 <Gracenotes> int80_h: will the brute force take too long? Try it and see!
01:42:17 <redditbot> There's the nub (snippet in Perl and Haskell) - Just another lambdabananacamel,
01:42:36 <mmorrow> , scanl (+) (fmap (join (^)) [1..])
01:42:37 <lunabot>  luna: No instance for (GHC.Show.Show ([[a]] -> [[a]]))
01:42:42 <Gracenotes> An Euler problem should give you a minute for you stop and think "Hm, maybe I'm going about this the wrong way"
01:42:46 <mmorrow> , scanl (+) 0 (fmap (join (^)) [1..])
01:42:47 <lunabot>  [0,1,5,32,288,3413,50069,873612,17650828,405071317,10405071317,2957167419...
01:42:53 <Gracenotes> or until you stop and think that, rather
01:43:00 <int80_h> Gracenotes: well, okay. The code isn't that hard. I just expected that the obvious approach wasn't the right one, and that I should dig deeper.
01:43:04 <mmorrow> , drop 10 $ scanl (+) 0 (fmap (join (^)) [1..])
01:43:05 <lunabot>  [10405071317,295716741928,9211817190184,312086923782437,11424093749340453...
01:43:21 <mmorrow> , drop 20 $ scanl (+) 0 (fmap (join (^)) [1..])
01:43:22 <lunabot>  [106876212200059554303215024,5949463230586042075684339445,347377340594805...
01:43:46 <mmorrow> how could you even brute-force this, since it's an infinite series
01:44:04 <Gracenotes> wha? It's an infinite series?
01:44:10 <int80_h> no, this number stopes after you've added 1000^1000
01:44:12 <mmorrow> oh, maybe it's not
01:44:13 <hassanslash> mmorrow: Link doesn't have the ID3 alg mate.
01:44:22 <mmorrow> hassanslash: is says iut does in the docs
01:44:23 <Gracenotes> mmorrow: plus, don't forget about the Omega monad :)
01:44:40 <int80_h> is that some kind of haskell joke?
01:44:53 <int80_h> omega monad indeed
01:45:00 <Gracenotes> The Omega monad is a convenient way to brute force infinite lists
01:45:08 <Gracenotes> and even if not infinite ones, really long ones
01:45:09 <int80_h> ooooh
01:45:17 <Gracenotes> it uses diagonalization
01:45:20 <mmorrow> i'd call it a way to /enumerate all of/ infinite lists
01:45:31 <int80_h> hmm, maybe I don't know enough haskell to go at this particular problem
01:45:44 <Gracenotes> mmorrow: conveniently used for brute forcing :)
01:45:57 <mmorrow> i guess, but what are we brute forcing here?
01:46:13 <Gracenotes> int80_h: don't look for an elegant solution. Pick the one that works best.
01:46:29 <Gracenotes> on my computer, the naive brute force solution takes only .06 seconds
01:46:29 <int80_h> Gracenotes: okay, with the tools I have. :)
01:46:31 <mmorrow> , 1000 ^ 1000
01:46:33 <lunabot>  1000000000000000000000000000000000000000000000000000000000000000000000000...
01:46:41 <mmorrow> , 999 ^ 999
01:46:42 <lunabot>  3680634882592232678947008400605218658383382320373532046559596214370256093...
01:46:56 <mmorrow> , length . show $ 1000 ^ 1000
01:46:57 <lunabot>  3001
01:46:58 <Gracenotes> int80_h: that's not much at all. As you can see above, Haskell is very fast with Integer arithmetic :)
01:47:09 <mmorrow> gmp is super fast
01:47:29 <Gracenotes> int80_h: there is a trick you might be able to use to calculate it without a computer.
01:47:30 <int80_h> Gracenotes: okay :) I had a problem with a prime generator earlier. I went at it the wrong way.
01:47:58 <int80_h> without a computer?! the whole point of this is to get exercise with haskell
01:47:59 <Gracenotes> but it involves an unusual observation and really only makes sense after you find the answer...
01:48:10 <mmorrow> , reverse . take 10 . reverse . show $ foldl' (+) 0 (fmap (join (^)) [1..1000])
01:48:11 <lunabot>  "9110846700"
01:48:13 <mmorrow> haha
01:48:17 <mmorrow> easy party
01:48:45 <Axman6> > drop (-1) undefined
01:48:46 <lambdabot>   * Exception: Prelude.undefined
01:49:06 <int80_h> now see, I would have figured map was the way to go. I don't know how to use fmap. even though I see it used all the time
01:49:18 <mmorrow> @src fmap []
01:49:18 <lambdabot> Source not found. Where did you learn to type?
01:49:22 <mmorrow> @src [] fmap
01:49:22 <lambdabot> fmap = map
01:49:24 <Gracenotes> int80_h: don't worry about fmap or join. Use what you know :)
01:49:35 <mmorrow> that was just short for:
01:49:51 <int80_h> okay gotta go
01:50:23 <Gracenotes> we better not show int80_h the page of Haskell Euler solutions; he might faint!
01:50:23 <Axman6> fmap is actually really easy to understand. observe
01:50:29 <Axman6> @src Maybe fmap
01:50:29 <lambdabot> fmap _ Nothing       = Nothing
01:50:29 <lambdabot> fmap f (Just a)      = Just (f a)
01:50:34 <Axman6> @src [] fmap
01:50:34 <lambdabot> fmap = map
01:50:40 <Axman6> @src Either fmap
01:50:40 <lambdabot> fmap _ (Left x) = Left x
01:50:40 <lambdabot> fmap f (Right y) = Right (f y)
01:50:54 <mmorrow> it's type pretty much say it all
01:51:00 <mmorrow> @type fmap
01:51:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:51:05 <mmorrow>  (a -> b) -> f a -> f b
01:51:12 <Axman6> basically, just applies a function to the elements of a type
01:51:14 <mmorrow>  (a -> b) -> (f a -> f b)
01:51:17 <Axman6> it's like a generic map
01:51:22 <Gracenotes> Axman6: explaining to yourself? :)
01:51:31 <Axman6> aparently so -_-
01:51:34 <Axman6> lame
01:51:39 <mmorrow> :)
01:51:44 <Axman6> well, someone else better be learning this stuff!
01:51:45 <Gracenotes> you know what they say, you have to give a tutorial in something to understand it
01:51:59 <mmorrow> @users
01:51:59 <lambdabot> Maximum users seen in #haskell: 658, currently: 593 (90.1%), active: 11 (1.9%)
01:52:35 <hassanslash> mmorrow: where can I find it mate? I don't see it.
01:52:42 <hassanslash> mmorrow: on that website
01:53:18 <mmorrow> i juts took a quick glance at the "manual" link, and it said ID3
01:53:33 <mmorrow> could you link me, my laptop died since i had it
01:53:56 <hassanslash> http://www.sgi.com/tech/mlc/
01:54:02 <Gracenotes> This pattern comes up more likely than one would think: transand a b c d = if a then do { b' <- lift b; if b' then c else d } else d
01:54:22 <Gracenotes> mainly when the transformed monad is strict :/
01:55:03 <Gracenotes> it's equivalent to do { b' <- lift b; if a && b' then c else d } when the monad is lazy
01:55:29 <mmorrow> hassanslash: ah, i guess it's in the "utilities". follow "Manual for MLC++ utilities" link here (i don't know if this will even work for your proj, etc)  http://www.sgi.com/tech/mlc/docs.html
01:55:55 <mmorrow> http://www.sgi.com/tech/mlc/util/util/node10.html#SECTION00053000000000000000
01:56:09 <Axman6> > 1 :: Complex Double
01:56:10 <lambdabot>   1.0 :+ 0.0
01:56:14 <Axman6> nice
01:58:37 <dmwit> > let step '0' = "12"; step '1' = "102"; step '2' = "0" in iterate (>>= step) "0"
01:58:39 <lambdabot>   ["0","12","1020","10212012","1021201020121020","102120102012102120121020102...
01:58:49 <dmwit> neat!
01:59:15 <dmwit> Those share the property that no adjacent subsequences are the same.
02:02:14 <trez> :D
02:06:14 <dmwit> "A simple proof that there are no equilateral lattice triangles has just now occurred to me, though, and I am really pleased with it, so we are about to have a digression."
02:06:18 <dmwit> <3 academia
02:07:49 <mmorrow> does anyone know what nick Luke Palmer uses (http://lukepalmer.wordpress.com/2009/01/28/fun-wth/) ?
02:08:42 <thoughtpolice> luqui
02:09:01 <mmorrow> ahhh, nice :)
02:12:00 <the_unmaker> rosy I think is his nick
02:13:32 <manicman> hi
02:14:08 <manicman> can anyone explain me why if statements are alway in every programming language strict?
02:14:21 <dmwit> They are very rarely strict.
02:14:29 <dmwit> So I'm not sure what you're talking about.
02:14:53 <dmwit> It would be absolutely lousy if "if" evaluated both the "then" and "else" clauses before returning one of them.
02:15:24 <mmorrow> especially when conditionally firing missiles
02:15:29 <manicman> dmwit: our prof says in one of his lecture "case distinction is alway strict"
02:15:45 <dmwit> Definitely.
02:15:50 <manicman> erm.. sry
02:15:59 <manicman> he says is alway not strict...
02:16:02 <dmwit> Case is the only way you get to force the evaluation of something in Haskell.
02:16:07 <mmorrow> in the sense that you need to evaluate the first level of an expression to conditionally branch given its val
02:16:48 <dmwit> Maybe you'd better ask your question again, just to make sure we're on the same page here.
02:17:42 <manicman> so i cannot explain to myself why conditional branches are alway not strict. the lecture was in german and the orginal say "Fallunterscheidung ist immer nicht-strikt"
02:19:05 <dmwit> Well, so here's the thing.
02:19:15 <dmwit> if-then-else is strict in the condition, but lazy in the branches.
02:19:33 <dmwit> Perhaps that is causing part of your confusion.
02:20:11 <manicman> ah yes o.k. that makes sense...
02:32:41 <mmorrow> thoughtpolice: so what are your thoughts on a gc for lhc?
02:35:14 <the_unmaker> can I build a program that will do everything a business needs: store data, do reports, communicate with vendors, web interface, financial crunching?
02:35:40 <hexpuem> whats the preferred way to control properties of 2 seperate types generated by QuickCheck
02:36:16 <hexpuem> for example if im testing matrix multplication i want both parameters to be in certain dimensions
02:36:19 <Peaker> @faq can Haskell help business?
02:36:19 <lambdabot> The answer is: Yes! Haskell can do that.
02:37:10 <vegai> building a program that communicates with vendors doesn't seem like an easy task
02:37:15 <Peaker> the_unmaker: Haskell is a very powerful multi-paradigm language
02:37:32 <Peaker> the_unmaker: though it definitely encourages the functional style/paradigms
02:37:46 <Peaker> the_unmaker: And you can do all you asked in any of these paradigms
02:38:41 <mmorrow> the_unmaker: start hacking?
02:40:32 <mmorrow> thoughtpolice: also, is it a goal for lhc to be able to build itself?
02:42:25 <ivanm> mmorrow: might even be more interesting to see if lhc and ghc can bootstrap each other...
02:42:31 <Peaker> how does one wrap C++ libraries?  Wrap them in C and then FFI to that?
02:42:41 <Peaker> C++ :-(
02:42:50 <trygvis> could anyone tell me what I'm doing wrong here? http://rafb.net/p/SY5u6Z50.html
02:42:55 <mmorrow> ivanm: well, technically if lhc could build ghc it could also build itself
02:43:06 <trygvis> I'm trying to read the response code and get the data back as a String
02:43:22 <ivanm> mmorrow: since ghc has the more complicated build system?
02:43:43 <mmorrow> ivanm: since it could just include building ghc as part of its build process ;)
02:44:08 <mmorrow> but really though, if it could build ghc it probably would also be able to build itself directly
02:44:24 <mmorrow> (assuming it doesn't use any extensions it doesn't support, etc)
02:44:27 <the_unmaker> I have a paper her by john backus
02:44:35 <dmwit> trygvis: Using ":i Response" in ghci might help.
02:44:35 <the_unmaker> turing award winner
02:44:35 <ivanm> mmorrow: heh
02:44:45 <ivanm> mmorrow: the extensions stuff is what I was thinking of
02:45:10 <dmwit> trygvis: I'm not sure, but I would suspect that Response is not a type synonym for a quadruple.
02:45:14 <mmorrow> yeah. since lhc is currently using derive, which uses TH it's not looking good for lhc building itself
02:45:16 <dmwit> trygvis: So that pattern match is wrong.
02:45:27 <ksf> Peaker, http://article.gmane.org/gmane.comp.lang.haskell.cafe/51691
02:46:05 <trygvis> right, it is a data type
02:46:29 <Peaker> ksf: I agree -- part of the reason I wrote my widget set. Also because I think existing UI's are all horrible :-)
02:46:33 <dmwit> trygvis: You'll have to match on that type's constructors, then.
02:46:45 <ksf> http://eaglemode.sourceforge.net/
02:46:59 <ksf> ...try it, just for that zomg feeling.
02:47:38 <Peaker> ksf: I don't think "zooming in" is the right interface either..
02:48:10 <trygvis> dmwit: ok .. new challenge for me then :)
02:48:31 <Peaker> ksf: Though I do think toying with widget sizes is a mostly unexplored/unused idiom for managing real-estate (we mainly have overlapping windows, movable panes and plain hiding stuff
02:48:36 <mmorrow> Peaker: surely you meant "zomging in"
02:48:45 <Peaker> hehe
02:48:46 <dmwit> trygvis: It's not hard.  I just can't help you with this specific thing because I don't have the appropriate library installed.
02:48:55 <dmwit> trygvis: Also because I'm going to bed. =)
02:49:02 <trygvis> this is the lib I'm using: http://hackage.haskell.org/packages/archive/HTTP/4000.0.4/doc/html/Network-HTTP-Base.html
02:49:07 <Peaker> ksf: I liked the iPhone interface, but I only used it for a few minutes
02:49:09 <trygvis> ok, thanks for your help
02:49:14 <ksf> well, it fixes 80% of the issues guis have.
02:49:28 <ksf> ...like not finding the documentation to a button, or its settings.
02:49:42 <ksf> in a zui, you find both of them by zooming in on it.
02:49:45 <the_unmaker> how do haskellers attack the problem of taking a social networking website and parsing the text to build target marketing buckets?
02:49:55 <the_unmaker> terabytes of text
02:50:09 <Peaker> why does GLUT want control of my main loop? :-(
02:50:15 <mmorrow> ivanm: also since lhc uses a bunch of hackage packages (some of which surely use extensions lhc doesn't support)
02:50:18 <ksf> it's kinda like pressing your nose onto your screen to grok your code.
02:50:24 <ivanm> the_unmaker: well, personally, I wouldn't because 1) I try to avoid social networking sites, and 2) I don't make ads ;-)
02:50:28 <Peaker> GLUT is forcing my code to use IORefs
02:50:39 <ksf> forkIO?
02:50:42 <ivanm> mmorrow: *nod* though ideally, wouldn't you want your compiler to be self contained?
02:50:47 <the_unmaker> fox where I work is going nuts
02:50:55 <the_unmaker> sharding postgresql with consultants
02:50:57 <Peaker> ksf: forkIO would not eliminate the IORefs, maybe convert them to MVars
02:51:02 <mmorrow> ivanm: i would totally want that
02:51:02 <the_unmaker> 100 node hadoop clusters
02:51:16 <the_unmaker> and I say to myself that is a mountain of hardware
02:51:23 <dmwit> trygvis: Yeah, so try just changing (_, _, _, s) to (Request _ _ _ s).
02:51:25 <the_unmaker> I wonder what haskell could do with it
02:51:28 <ksf> ...that's what happenes if you use alien event systems.
02:51:47 <dmwit> trygvis: Even better is (Request {rqBody = s}), because it's a bit more forward-compatible.
02:51:49 <Peaker> ksf: GLUT itself has a mainloop?
02:51:58 <Peaker> ksf: SDL also supports "alien event systems" without taking over your main loop
02:52:07 <dmwit> trygvis: The Gentle Introduction and the Report are good sources to consult for all your pattern-matching syntax needs.
02:52:11 <dmwit> ?where gentle
02:52:11 <lambdabot> http://www.haskell.org/tutorial/
02:52:13 <dmwit> ?where report
02:52:13 <lambdabot> http://www.haskell.org/onlinereport/
02:52:14 <Peaker> I wanted to convert from SDL to GLUT but GLUT is giving me the creeps
02:52:29 <Peaker> Haskell SDL on  OSX  is problematic though
02:52:48 * ksf thinks he once used something like glutMainloop()
02:53:10 <the_unmaker> is haskell reflective?
02:53:24 <sioraiocht> the_unmaker: not really
02:53:26 <mmorrow> the_unmaker: in what sense of the word?
02:53:29 <ksf> you could try to use xhb's glx support.
02:53:43 <sioraiocht> the_unmaker: most reflective languages are dynamically typed
02:53:47 <mmorrow> the_unmaker: well, i'd say "no" unless you've linked ghc into your app
02:53:52 <Peaker> the_unmaker: Haskell has support for some "reflective" features
02:54:00 <ivanm> mmorrow: but then again, you're not designing the compiler? ;-)
02:54:02 <mmorrow> the_unmaker: (which is doanle)
02:54:06 <mmorrow> *doable
02:54:26 <mmorrow> ivanm: no, i'm not :)
02:54:36 <osfameron> hi |jedai|
02:54:53 <osfameron> thanks for the comment - I think I'll need to reformat it for markdown, looking now
02:54:54 <mmorrow> ivanm: not that one at least ;)
02:55:03 <ksf> ...glx is going to give you the creeps too, though.
02:55:17 <the_unmaker> http://en.wikipedia.org/wiki/Function-level_programming this got me thinking
02:56:05 <ivanm> mmorrow: .... so which one _are_ you working on?
02:56:09 <ivanm> mhc? ;-)
02:56:56 <mmorrow> ivanm: i'm doing an implem of this (which isn't necessarily restricted to only haskell): http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
02:56:58 <ksf> FP looks a lot like haskell to me.
02:57:21 <ivanm> ksf: ummm.... Haskell is an FP language...
02:57:29 <ksf> http://en.wikipedia.org/wiki/FP_(programming_language)
02:57:42 <ivanm> ahhh
02:59:37 <Peaker> Function-level programming seems like points-free programming
03:00:26 <ksf> but then, those fp examples show points.
03:01:25 <ksf> Personally, I've come to the conclusion that it's a good idea not to mention points unless you need contortions to do so.
03:02:03 <ksf> ...that means mostly .) and $) .
03:03:11 <ksf> also, never hesitate to refactor foo $ bar $ baz into (foo.bar) baz
03:03:42 <mmorrow> ivanm: my goal is to have it be usable as an interpreter for any lang that can compile to the "core" lang that it starts compilation with
03:03:44 <the_unmaker> http://en.wikipedia.org/wiki/Function-level_programming interesting the contrast to function-level programming language
03:04:23 * ksf doesn't feel like indulgin in archeology right now.
03:04:47 <ksf> that'll be like installing ghc 6.8...
03:05:21 <osfameron> |jedai|: I've reformatted (I'm currently taking markdown, so just need to prepend each line with 4 spaces).  Thanks for the comments anyway - btw you're a Perl hacker too I think?
03:08:58 <C-Keen> hm, seems I cannot bootstrap cabal-install-0.6.0 on a ghc-6.8.3 that is not build for interactive use
03:09:09 <C-Keen> is there a way around that?
03:09:49 <Saizan> compile the packages manually
03:10:33 <Saizan> ghc --make Setup; ./Setup configure --user; ./Setup build; ./Setup install
03:12:35 <C-Keen> Saizan: hm, true
03:16:33 <the_unmaker> http://maude.cs.uiuc.edu/overview.html this seems interesting
03:17:25 <the_unmaker> http://www.ps.uni-sb.de/alice/ and this
03:18:08 <trygvis> I used maude at the uni
03:21:51 <the_unmaker> really?
03:22:11 <the_unmaker> did you make any cool programs in it?
03:22:44 <ksf> There are certain situations while coding haskell where you wish you had any idea about logic.
03:22:54 <trygvis> no, I really didn't understand much
03:23:07 <trygvis> it was used to "prove" correctness of algorithms
03:23:53 <ksf> but then, I don't really feel like reading a couple of books about the intricacies of existential quantification.
03:24:54 <the_unmaker> most people want simple calculations and lots fo colors
03:25:06 <the_unmaker> myspace makes tons of $$
03:25:11 <the_unmaker> amazing isn't it
03:25:38 <the_unmaker> my buddy wants some nice background theme or his blog, and ability to upload graphs of his stocks
03:25:45 <the_unmaker> I dont know even howto program that
03:25:47 <the_unmaker> :(
03:26:24 <the_unmaker> he likes wordpress which I told him is fine as long as you do things wordpress way, anything else and it is a prision
03:27:29 <ksf> trygvis, I just did that using a pencil.
03:30:31 <icqn> how is sin for example implemented in ghc? primitive? as a call of a c function?
03:30:56 <ksf> depends on -viaC and your processor.
03:31:17 <ksf> ...and on the type of your numbers, of course.
03:31:22 <icqn> ksf, but not in haskell`
03:32:06 <ksf> I wouldn't be surprised if there's a haskell implementation around, for some type that _isn't_ double or float.
03:32:38 <ksf> @src sin CReal
03:32:38 <lambdabot> Source not found. My mind is going. I can feel it.
03:32:49 <ksf> ...it was worth a try.
03:32:57 <icqn> :-)
03:33:28 <mmorrow> icqn: if it was implem on the ghc side, it'd be in C--
03:33:31 <cnwdup> I have a monad transformer stack with the deepest being a Writer. Can I perform an action in this monad preserving the writer's state even though the action calls tell?
03:33:36 <mmorrow> which is basically asm
03:34:10 <mmorrow> but that's a good question, (in ghc at least) i think it's sin from math.h (?)
03:34:50 <mmorrow> ohh, no
03:35:00 <mmorrow> it's the machine instruction
03:35:05 <mmorrow> that ghc generates
03:35:08 <mmorrow> i believe
03:38:39 <mmorrow> icqn: do:
03:38:54 <mmorrow> echo 'main = print (sin (pi::Double))' > sin.hs
03:39:00 <mmorrow> ghc -O2 -S sin.hs
03:39:05 <ksf> ...now ghc is asking me to use -XImpredicativeTypes .
03:39:06 <mmorrow> grep sin sin.s
03:39:12 <ksf> And I don't even know what that is.
03:40:07 <mmorrow> sin is an instruction on most (all?) arches
03:40:40 <ksf> on x86 ever since the x87 became standard, and that's for a while, now.
03:41:10 <mmorrow> yeah
03:41:19 <ksf> at least every 486 came with an fpu, I'm not entirely sure about 386, though.
03:41:31 <Heffalump> the 486SX didn't
03:42:19 <redditbot> Some libgd changes
03:42:36 <athos> hi
03:42:40 <mmorrow> i'm looking at http://darcs.haskell.org/ghc/compiler/nativeGen/MachInstrs.hs
03:42:55 <mmorrow> actually yeah, it looks like it's only x86, x86_64
03:43:11 <Heffalump> I don't think ARM has sin
03:43:46 <icqn> mmorrow, yep, #	gsinl %fake0,%fake0  	ffree %st(7) ; fld %st(0) ; fsin
03:44:23 <mmorrow> i wonder what ghc generates on arches that don't have a sin instr
03:46:44 * ksf is going to suggest adding -XYesIAmGoingToGiveTypeAnnotations , some time.
03:47:48 * Axman6 doesn't think it's descriptive enough
03:48:00 <augustss> mmorrow: a sin instr?
03:48:12 <augustss> no arch has that anymore
03:48:38 <mmorrow> heh
03:48:55 <mmorrow> what does ghc do? call the one in math.h?
03:48:59 <augustss> yes
03:49:06 <mmorrow> ahh, ok
03:49:38 <augustss> does it really use the x87 instruction for sin?
03:49:42 <mmorrow> yes :(
03:49:48 <augustss> wow
03:50:10 <mmorrow> there's a comment from 2003 in there saying they're gonna switch to SSE instrs...
03:50:30 <augustss> mmorrow: there's still time...
03:51:30 <mmorrow> (refering to the comment starting line 273: http://darcs.haskell.org/ghc/compiler/nativeGen/MachInstrs.hs)
03:52:45 <augustss> gcc doesn't use the sin instruction, so I think it's suboptimal to do so.
03:53:16 <augustss> or maybe I don't have the right flags
03:53:18 <mmorrow> interesting, even with sse instrs?
03:54:24 <augustss> there is no sin the SSE instructions as far as I know
03:55:20 <augustss> the only non-arithmetic one is sqrt
03:55:46 <mmorrow> oh, for some reason i thought there was
03:56:02 <mmorrow> (but i was just assuming..)
03:56:50 <augustss> maybe SSE2 or SSE3 or SSE4
03:57:59 <mmorrow> ah, maybe
03:59:27 <the_unmaker> how is haskell for gui construction?
04:00:05 <trygvis> the_unmaker: check out the GUI chapters of real world haskell
04:00:10 <augustss> mmorrow: but I don't think so.  looks more like instructions useful for codecs have been added
04:00:14 <mmorrow> augustss: yeah, looks like you're right http://gruntthepeon.free.fr/ssemath/
04:07:58 * ksf doesn't get why [forall a. (Foo -> a, a -> Bar)] is different from data FooBar = forall a. FooBar (Foo -> a) (a -> Bar)
04:08:33 <ksf> OTOH, I can remove ImpredicativeTypes, again.
04:09:26 <Saizan> ksf: do you get the difference between data Foo = forall a. Foo (Foo -> a) (a -> Bar) and data Foo' = Foo' (forall a. (Foo -> a) (a -> Bar)) ?
04:10:17 <ksf> I'm reasonably sure of it.
04:10:34 <ksf> gragh.
04:10:47 <ksf> damn that special list syntax.
04:10:52 <Saizan> (module the fact that i miss a tuple in the second case)
04:11:26 <ksf> wait no.
04:11:54 <ksf> the forall should apply to the , in my first example, which is isomorphic to the FooBar constructor (I hope)
04:12:50 <ksf> ...also imagin FooBar being used in a list.
04:13:03 <Saizan> it's still different
04:13:28 <Saizan> in the first case the elements of the list must be polymorphic over 'a'
04:14:04 <Saizan> i.e. when you get one of those you get to decide to which type 'a' is instantiated, you can even use it at multiple different types
04:14:15 <ksf> so it's more of a syntactic problem than a semantic?
04:14:33 <Saizan> it's semantic
04:15:15 <Saizan> when you look inside a FooBar you can't choose a type to instantiate 'a'
04:15:40 <Saizan> the consumer of FooBar must be polymorphic over 'a' instead
04:16:33 <ksf> (so there's a syntactical problem, 'cos that's what I intended my fist example to mean)
04:16:41 <Saizan> you want [exists a. (Foo -> a, a -> Bar)]
04:18:01 <Saizan> but exists doesn't exist in haskell
04:18:48 <mmorrow> but you can still get it, you just need a data decl
04:19:18 <Saizan> or [forall r. (forall a. (Foo -> a,a -> Bar) -> r) -> r]
04:19:35 <Saizan> which is the same
04:19:42 <Saizan> as the datadecl
04:19:48 <mmorrow> ah yeah, true
04:21:18 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1075#a1075
04:21:37 <ksf> this is awfully close or even exactly what I was trying to do all the time.
04:22:40 <ksf> Haskell is great for procrastinating implementing stuff by writing type annotations instead...
05:03:16 <vixey> > 1+1
05:03:17 <lambdabot>   2
05:05:14 <vixey> > 1+2
05:05:15 <lambdabot>   3
05:05:22 <vixey> > iterate $ join (+) $ 1
05:05:23 <lambdabot>       Overlapping instances for Show (a -> [a])
05:05:23 <lambdabot>        arising from a use of ...
05:05:40 <vixey> > iterate (join (+)) 1
05:05:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
05:05:54 <vixey> > (iterate . join (+) . const 1) ()
05:05:55 <lambdabot>       Overlapping instances for Show (a -> [a])
05:05:55 <lambdabot>        arising from a use of ...
05:06:31 <BONUS> what's the command for quickchecking again
05:06:45 <vixey> @check "sheep" == "pig"
05:06:46 <lambdabot>   "Falsifiable, after 0 tests:\n"
05:06:48 <BONUS> ah
05:07:02 <BONUS> @check (\x -> join (+) x == x*2)
05:07:03 <lambdabot>   "OK, passed 500 tests."
05:07:18 <vixey> @src join
05:07:18 <lambdabot> join x =  x >>= id
05:07:38 <vixey> :t do x <- (+); return x
05:07:39 <lambdabot> forall a. (Num a) => a -> a -> a
05:07:49 <vixey> :t do x <- (+); x
05:07:50 <lambdabot> forall a. (Num a) => a -> a
05:08:05 <baaba> @src Monad ((->) a)
05:08:05 <lambdabot> Source not found. My pet ferret can type better than you!
05:08:16 <vixey> :t (>>=)
05:08:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:08:29 <tibbe> @seen dcoutts
05:08:29 <lambdabot> dcoutts is in #happs, #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 14h 20m 14s ago.
05:08:30 <baaba> @src (->) (>>=)
05:08:30 <lambdabot> f >>= k = \ r -> k (f r) r
05:08:39 <baaba> there we go
05:09:23 <tibbe> anyone here with a windows machine who's willing to see if my library builds on windows? it probably doesn't but having the error messages would be nice :)
05:10:32 <baaba> > (,) =<< (+1) $ 5
05:10:33 <lambdabot>   (6,5)
05:17:33 <Ringo48> Data.Map.Map Int (Data.Map.Map Char (Data.Set.Set Int))) would be roughly equivalent to the C++ type std::map<int, std::map< char, std::set<int> > > right?
05:19:15 <Botje> yess..
05:19:24 <Botje> what are you going to be storing in there?
05:19:41 <Ringo48> a nondeterministic finite automaton transition table
05:20:04 <Botje> ah
05:20:08 <Botje> then the nesting is handy, yes :)
05:20:35 <Ringo48> the integer key for the outer map is a state, character key for inner map is the character, and the inner set is the set of states that can be transitioned to
05:20:55 <Botje> well, add a type alias for state and it's much more readable
05:20:59 <Ringo48> then that brings me to my actual "problem"
05:21:05 <Botje> also, if you import the modules you don't need to reference them like that
05:21:18 <Ringo48> yeah, i actually have that, but nobody would know what State was :-)
05:21:46 <Botje> good :)
05:21:47 <Ringo48> in the C++ code, I can do: nfa[0]['a'].insert(4);
05:22:11 <chaoslynx> hi, i am trying to follow "write yourself a scheme in 48hours" and the vanilla code after error checking and exceptions fails with a very long error message, that seems to be related to parsec, but gives no clue whatsoever..
05:22:35 <Botje> chaoslynx: can you put the error on hpaste?
05:22:43 <Botje> and the lines it references too
05:22:54 <Botje> Ringo48: yeah, nested updates are a pain
05:23:25 <Ringo48> I noticed :-)
05:23:32 <baaba> infixr 2 :->; type a :-> b = Map a b
05:23:33 <baaba> :P
05:23:40 * vixey gets horrible horrible urges to rewrite 'write yourself a scheme' tutorial :/
05:24:18 <Botje> M.adjust (M.adjust (S.insert 4) 'a') 0 nfa
05:24:25 <chaoslynx> Botje, hpaste is not avaible
05:24:26 <vixey> out of habit, I would eta reduce to type (:->) = Map
05:24:27 <Botje> i think that's equivalent to your C++ code
05:24:32 <osfameron> vixey: a beginner's version of that tutorial would be cute.  I couldn't make head or tail of it
05:24:42 <Ringo48> okay, I'll have to look into that
05:24:44 <Ringo48> thank you
05:25:23 <Botje> good luck :)
05:25:29 <Botje> chaoslynx: force of habit :p
05:25:33 <Ringo48> thanks
05:26:42 <Axman6> Ringo48: might want to look at IntMap btw
05:27:17 <chaoslynx> http://pastebin.com/m22567e3, suffice to say there is no r1hf_info
05:27:32 <Botje> oh
05:27:35 <Botje> how are you compiling it?
05:27:50 <chaoslynx> ghc main.hs
05:27:58 <Botje> try ghc --make main.hs
05:28:00 <Botje> or ghc --make ian
05:28:03 <Botje> err
05:28:05 <Botje> main
05:28:27 <chaoslynx> hm that worked...
05:28:39 <Botje> the --make tells ghc to include the necessary pacakges
05:28:55 <chaoslynx> ok, good to know...
05:29:04 <Botje> vixey: satisfy your horrible horrible urges and write your tutorial! :p
05:29:09 <chaoslynx> thx
05:29:18 <vixey> Botje, mumble :(
05:29:49 <baaba> i wish operators could contain arbitrary characters after an initial operator character
05:30:17 <vixey> baaba, I still prefer Prologs way
05:30:32 <vixey> you can turn anything into an operator, even several words with spaces between them
05:31:21 <baaba> heh
05:31:54 <baaba> i'm not sure how i feel about that - i haven't really used prolog enough to say but my gut feeling is that it would become too confusing to read
05:32:57 <chessguy> hm? Prolog's way of what?
05:33:07 <vixey> operators
05:40:08 <vixey> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_5_Hours
05:40:11 <vixey> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_8_Hours
05:40:13 <vixey> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_12_Hours
05:40:15 <vixey> can't decide..
05:40:42 <skorpan> i never understood "a scheme"
05:40:59 <vixey> it means vaugely scheme-ish language
05:41:06 <skorpan> oh, like guile is "a scheme"?
05:41:10 <vixey> haha
05:41:17 * trygvis . o O ( I wonder if someone actually time those tutorials )
05:41:27 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.6
05:41:32 <skorpan> vixey: i guess not :P
05:42:09 <vixey> Write Yourself a Scheme in 48 Hours is a featured book on Wikibooks because it contains substantial content, it is well-formatted, and the Wikibooks community has decided to feature it on the main page or in other places. Please continue to improve it and thanks for the great work so far! You can edit its advertisement template.
05:42:13 <vixey> hum...........
05:42:44 <jpcooper> is there a way to force a monadic operation and then for this thing to return ()?
05:43:06 <BONUS> m >> return ()
05:43:07 <BONUS> ?
05:43:54 <BONUS> this is the same monadic operation as m, only the result it yields is ()
05:45:06 <jpcooper> BONUS, I've been doing that and have been wondering whether the thing is actually being executed
05:45:26 <jpcooper> so I guess it is and I'm just doing something wrong
05:46:36 <BONUS> well it depends on the monad, what the binding strategy is, et.c
05:46:55 <BONUS> what specifically are you doing
05:47:04 <vixey> jpcooper, try this:
05:47:12 <vixey> print "test" >> return ()
05:47:13 <vixey> in ghci
05:47:32 <vixey> > [1,2,3,4] >> return ()
05:47:33 <lambdabot>   [(),(),(),()]
05:48:25 <BONUS> or getLine >> return ()
05:48:53 <BONUS> if you just do getLine, the String inside the IO will be printed out because the IO action yields it
05:49:02 <BONUS> getLine >> return () just prompts you for a line and that's it
05:49:33 <jpcooper> right
05:58:09 <Ringo48> those wikibook links made me wonder...
05:58:20 <Ringo48> is there anyway to order a printed version of one of those books
05:58:21 <Ringo48> ?
05:58:36 <vixey> why don't you just print it yourself?
05:58:49 <vixey> punch holes in it and stick it in a ring binder
05:59:43 <Ringo48> toner is expensive, my printer can't handle that volume for very long, and a ring binder would be clunky,
06:00:07 <vixey> oh never caused me problems
06:00:08 <Axman6> don't need a ring binder, there's plenty of alternatives
06:00:25 <Ringo48> I don't really have one in mind that I'd like to buy, I was just wondering
06:00:38 <jeffz`> it's usually more economical to go to a printshop if you're going to print a few hundred pages of something
06:01:04 <Ringo48> maybe they could get a deal with a small publisher for some of the more popular ones
06:01:27 <Axman6> i think my uni may offer a service like that
06:02:15 <Axman6> yep http://info.anu.edu.au/fbs/Business_Functions/University_Printing_Services
06:07:15 <beelsebob> @where hpastetwo
06:07:15 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
06:07:38 <beelsebob> Axman6: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1076#a1076
06:07:44 <beelsebob> not checked that it's actually correct yet
06:07:57 <beelsebob> but it made sense while I wrote it
06:07:58 <mjb> An office supply store, like Staples, may also offer a similar service.
06:08:46 <Axman6> beelsebob: why aren't you using Vector3 for both position and velocity?
06:08:59 <beelsebob> Axman6: because position is a point, not a vector
06:09:08 <Axman6> points are vectors
06:09:19 <beelsebob> doesn't mean I should make my types less specific
06:10:00 <Axman6> well, it means that you have to redefine a lot of operation that are exactly the same on both :)
06:10:12 <beelsebob> Data.VectorSpace does that work for me
06:10:56 <Axman6> ah fair enough
06:12:25 <Axman6> beelsebob: so, does it work?
06:12:37 <beelsebob> no idea, I've not got the bits on this machine â€“ I'm busy on hackage
06:12:44 <beelsebob> it's a nice description of the problem though, isn't it
06:13:03 <Axman6> yeah, looks good
06:13:46 <Axman6> mine's a lot longer, but has performance in mind rather than clarity (though that is also a goal)
06:15:33 <osfameron> eeek, icfp cfp is coming up quickly
06:15:42 <Axman6> cfp?
06:15:45 <osfameron> call for papers
06:16:02 <Axman6> ah
06:16:09 <Axman6> one day, i'll have papers to submit
06:16:16 <osfameron> anyone got any examples of submissions for "functional pearls"?  Are the submission papers roughly like the polished articles of the same title?
06:16:45 <osfameron> heh, yeah, it'll be centuries before I have new FP research to talk about at an academic conference :-)
06:17:12 <osfameron> but I might get away with a light-hearted talk about introducing monads to Perl programmers
06:17:15 <beelsebob> osfameron: I can't remember where I've seen them, but from the pearls I've seen â€“ they're small, neat ideas, that end up stunningly beautiful, but aren't big enough to write a whole paper about
06:17:52 <Axman6> i'd still like to see how well runtime memoisation built into the RTS goes.
06:17:56 <osfameron> beelsebob: yeah, http://web.cecs.pdx.edu/~apt/icfp09_cfp.html#pearls goes into more detail about what they want
06:18:21 <vixey> ?wiki Functional Pearls
06:18:21 <lambdabot> http://www.haskell.org/haskellwiki/Functional_Pearls
06:18:22 <osfameron> beelsebob: some are like that (like the ones I've seen) but they do also mention "a novel use or exposition of functional programming in the classroom" which I think might be relevant to my idea
06:18:39 <Axman6> so you can write functions like f ?x ?y = somethingComplicated x y, and mahe the results memoised
06:18:40 <vixey> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
06:19:02 <osfameron> thanks
06:19:14 <osfameron> vixey: do you know if those are in the format that a CFP would be looking for?
06:19:22 <osfameron> <-- ignorant of academic conference protocol
06:19:25 <opqdonut> Axman6: memoisation is easy with combinators
06:19:52 <opqdonut> f' = memoise f -- for non-recursive f
06:20:17 <opqdonut> if recursion is done with fix we just say f = fix (memoise g) instead of f = fix g
06:20:25 <opqdonut> for implicit recursion it's a bit more complicated
06:20:28 <mapreduce> @instances Arrow
06:20:29 <lambdabot> (->), Kleisli m
06:20:35 <opqdonut> but could be done with a simple preprocessor, of course
06:21:10 <osfameron> eeeek!  the one I just opened is 16 pages!
06:21:19 <osfameron> that's a long submission for a 20 minute talk
06:21:42 <opqdonut> hehe :)
06:22:01 <opqdonut> i'm just writing lecture slides on parser combinators in haskell
06:22:02 <osfameron> er, not that I know how long the talks are at ICFP. Maybe an hour?
06:22:03 <Axman6> opqdonut: well, i'm just wondering if it could be more efficient if done in the RTS with arrays in the RTS or something
06:22:51 <opqdonut> Axman6: well the rts could provide some sort of complex heuristics for how much to memoise
06:22:58 <opqdonut> but so can a library
06:23:14 <opqdonut> i don't really believe the performance gain in moving memoisation to the rts would be that great
06:23:17 <osfameron> "submit an abstract of at most 300 words and a full paper of at most 12 pages (4 pages for an Experience Report),"
06:23:53 <osfameron> this suggests that Functional Perls should also be no more than 12 pages, as they're not bundled in with the Experience reports
06:25:16 <osfameron> perhaps I should email the Chair for clarification, rather than whining here :-)
06:25:17 <opqdonut> heh, perls
06:25:36 <osfameron> opqdonut: er, yeah, thinko (that's the title of my talk :-)
06:25:45 <Axman6> opqdonut: hmm, it's probably something that would be abused too
06:25:51 <opqdonut> osfameron: ah!
06:25:54 <mapreduce> @hoogle (a, b) -> (a -> c) -> (b -> d) -> (c, d)
06:25:54 <lambdabot> No results found
06:26:01 * osfameron heads into town
06:27:19 <mapreduce> > (\pair f g -> (f (fst pair), g (snd pair))) (3, 4) (+2) (*3)
06:27:20 <lambdabot>   (5,12)
06:27:43 <mapreduce> Is there anything built in that does what that lambda does?
06:28:12 <opqdonut> err?
06:29:09 <koeien> > (*2) &&& (+2) (3,4)
06:29:10 <lambdabot>   Couldn't match expected type `b -> c''
06:29:14 <koeien> > (*2) *** (+2) (3,4)
06:29:15 <lambdabot>   Couldn't match expected type `b' -> c''
06:29:15 <Cthulhon|> > ((+2) *** (*3)) (3,4)
06:29:17 <lambdabot>   (5,12)
06:29:22 <koeien> right
06:29:43 <koeien> mapreduce: this is Control.Arrow
06:29:48 <beelsebob> bugger
06:29:53 <beelsebob> FieldTrip doesn't compile just now
06:30:09 <mapreduce> Ah, great.
06:30:11 <mapreduce> Thanks.
06:35:36 <beelsebob> o.O
06:35:46 <beelsebob> I think google's gone a bit crazy with the old phishing protection
06:35:55 <beelsebob> *every* link when you search for comonad is flagged as dangerous
06:36:28 <Heffalump> I thought comonads were dangerous.
06:36:35 <beelsebob> lol, fair point
06:36:37 <opqdonut> huh?
06:36:50 <cnwdup> beelsebob, same goes if you search for wikipedia :-D
06:36:50 <beelsebob> but they'll harm me, not my computer
06:37:02 <DMKE> when i want to redefine map by using foldr -- how would i start?
06:37:15 <beelsebob> DMKE: perhaps with the foldr based definition of id
06:37:24 <beelsebob> > foldr (:) [] [1,2,3,4,5]
06:37:26 <lambdabot>   [1,2,3,4,5]
06:37:33 <beelsebob> now all you need do is sneak in a function application
06:37:52 <mopped> I'm trying to create a simple IO example, but how do I cons a String and an IO? ala http://paste.lisp.org/display/74636#1
06:38:14 <beelsebob> mopped: 1) that's appending strings, not consing
06:38:19 <beelsebob> 2) same way as you would any other place
06:38:25 <beelsebob> using the string appending function (++)
06:38:35 <DMKE> thx
06:38:41 <mopped> ah
06:39:15 <beelsebob> and possibly some parens
06:39:21 <Olathe> @type foldr
06:39:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:39:42 * loadquo tries to figure out why google says LTU may harm his computer
06:40:24 <beelsebob> loadquo: I'd just commented on that â€“ they appear to have gone nuts on anti-phishing today
06:40:40 <Ikkebr> google is broken
06:41:04 <mopped> beelsebob: putStrLn "Greetings " (++) x still complains
06:41:15 <loadquo> Beelsebob: Ah, missed that.
06:41:17 <beelsebob> mopped: infix operators are used without the parens round the operator
06:41:27 <hackage> Uploaded to hackage: SegmentTree 0.1
06:41:27 <hackage> Uploaded to hackage: Glob 0.4
06:41:30 <beelsebob> and most likely, you need parens around the whole string
06:41:37 <beelsebob> putStrLn ("Greetings " ++ x)
06:44:01 <mopped> what's the difference between putStrLn, show and print?
06:44:11 <beelsebob> @type show
06:44:12 <lambdabot> forall a. (Show a) => a -> String
06:44:21 <beelsebob> so... that takes anything showable, and produces a string
06:44:26 <beelsebob> but doesn't put the string on the screen
06:44:29 <beelsebob> @type putStrLn
06:44:30 <lambdabot> String -> IO ()
06:44:38 <beelsebob> that takes a string, and puts it on the screen
06:44:42 <beelsebob> @type print
06:44:43 <lambdabot> forall a. (Show a) => a -> IO ()
06:44:53 <beelsebob> that takes anything showable, converts it to a string, and puts it on the screen
06:45:24 <mopped> aha
06:45:25 <mopped> thanks
06:45:25 <vixey> hahaha
06:45:34 <vixey> http://www.google.com/search?q=Considered+Harmful
06:45:47 <koeien> whahahaha
06:45:49 <beelsebob> vixey: yeh, google's white list may be... a bit short
06:46:05 <Ikkebr> haskell is harmful
06:46:07 <Ikkebr> omg
06:46:44 <beelsebob> http://www.google.com/search?client=safari&rls=en-us&q=google&ie=UTF-8&oe=UTF-8
06:46:48 <beelsebob> google is harmful
06:47:19 <loadquo> I'm surprised we are all seeing this, I thought they rolled out new content piecemeal...
06:48:22 <Saizan> well, it's reasonable to be conservative and default to "harmful", no?:)
06:49:28 <beelsebob> indeed
06:49:40 <beelsebob> but you would have thought they'd have a half decent white list when the feature went live
06:50:21 <chessguy> heh. when did this feature com out?
06:50:26 <zachk> its nice how google flags the haskell subreddit as possibly harmful to my computer, then 502 errors when i attempt to find out more about the warning :-(
06:50:30 <chessguy> s/com/come/
06:50:30 <beelsebob> about 20 minutes ago
06:50:47 <chessguy> how do sites get off the 'harmful' list?
06:50:53 <beelsebob> we don't know yet
06:51:07 <Japsu> google is obviously broken
06:51:08 <mreh> what editor do you use?
06:51:10 <ziman> it's probably google's fault
06:51:17 <mreh> haha, you've notice that google is broken too
06:51:21 <beelsebob> mreh: SubEthaEdit
06:51:42 <drhodes> google is broken! :D
06:52:10 <opqdonut> yeh
06:52:14 <ziman> it's the end of year 0 B.G. :)
06:52:17 <Raynes> Google may harm your computer, watch out!
06:52:19 <mreh> does anyone use jedit? im thinking of writing some macros/plugins for source code editing, i just wonder if im wasting my time
06:52:21 <opqdonut> http://pseudo.fixme.fi/~opqdonut/stuff/google.png
06:52:50 <Raynes> http://www.acidrayne.net/files/Lolgoogle.jpg
06:53:33 <drhodes> if google used haskell, they wouldn't be having this problem.
06:53:41 <skorpan> lawlu lul gogel is harm ful
06:54:54 <loadquo> @faq Can using haskell make google not have these errors in the future?
06:54:54 <lambdabot> The answer is: Yes! Haskell can do that.
06:55:12 <Axman6> oh dear
06:55:29 <koeien> data Result a = HarmfulResult a | NotHarmfulResult a
06:59:35 <vixey> this is so frustrating, I thought I got this algorithm sorted out but there is another problem :/
06:59:57 <zachk> vixey: did you sort out a sorting algorithim? :-/
06:59:58 <vixey> I'm sort of wondering do I have an unimplementable spec.
07:00:30 <beelsebob> gah, why does conal have to be americaneese
07:04:06 <Twey> Is 'truncate' essentially different from 'floor'?
07:04:12 <Twey> @src truncate
07:04:12 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:04:44 <koeien> > truncate (-1.5)
07:04:46 <lambdabot>   -1
07:04:49 <koeien> > floor (-1)
07:04:49 <loadquo> @type truncate
07:04:50 <lambdabot>   -1
07:04:50 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:04:52 <koeien> > floor (-1.5)
07:04:53 <lambdabot>   -2
07:04:53 <Twey> Ah, negatives
07:04:54 <Twey> Ta
07:05:08 <loadquo> @type floor
07:05:09 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:05:46 <opqdonut> Twey: it's kinda like the div-rem divide
07:06:13 <Axman6> Twey: truncate rounds towards 0 always i guess
07:06:23 <Axman6> > truncate 1.6666
07:06:24 <lambdabot>   1
07:06:32 <Axman6> > truncate $ -1.6666
07:06:33 <lambdabot>   -1
07:06:35 <Olathe> If I have Data.Whatever containing a typeclass, what is the standard way of naming a module containing a bunch of functions for that typeclass ?
07:06:54 <Axman6> Olathe: Data.Whatever.Utils?
07:06:59 <Olathe> Thanks :)
07:15:20 <koeien> @go real world haskell
07:15:27 <lambdabot> http://www.realworldhaskell.org/
07:15:27 <lambdabot> Title: Real World Haskell
07:16:55 <Twey> http://book.realworldhaskell.org/read/using-typeclasses.html â€” Under 'When do overlapping instances cause problems?', why are there overlapping instances for JSON [([Char], [Char])]
07:16:59 <Twey> ?
07:17:43 <Twey> A JSON instance was never defined for ([Char], [Char]), so why does the (JSON a) => JSON [a] instance seem to apply?
07:18:45 <augustss> Isn't there an instance for (a,b) and for Char?
07:19:57 <Twey> No, there are no equivalent types in JSON
07:20:50 <Twey> There's an instance (JSON a) => JSON [(String, a)] which looks like it should be all that applies
07:21:10 <Twey> But there's also an instance (JSON a) => JSON [a] which is somehow overlapping
07:22:22 <augustss> There's an instance for Char, for [a], and for (a,b).  Together they form and instance for ([Char],[Char])
07:22:59 <augustss> At least in the json library on hackage
07:23:17 <saml> > 1 2 3 4 5
07:23:18 <lambdabot>       No instance for (Num (t -> t1 -> t2 -> t3 -> a))
07:23:18 <lambdabot>        arising from th...
07:23:20 <Twey> Hm, there's none in this example
07:23:37 <Saizan> well, it doesn't really matter
07:23:55 <Saizan> to check if instances overlap the contexts don't count
07:24:30 <Saizan> and [([Char], [Char])]
07:24:30 <Twey> Saizan: What?  Why?  :-\
07:24:45 <Saizan> matches both [a] and [(String, a)]
07:25:03 <Twey> It does without taking the contexts into account... why are they ignored?
07:25:19 <augustss> Twey: The example has enough to cause overlap
07:25:22 <saml> type of space is (a -> b) -> a -> b
07:25:27 <saml> :t curry
07:25:28 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:25:36 <Saizan> Twey: i think it has to do with separate compilation
07:25:49 <Twey> augustss: It does if contexts are ignored, yes
07:25:57 <augustss> Twey: contexts are ignored, that's the way it is :(
07:25:57 <Twey> That's... highly ugly
07:26:06 <Twey> Damn :-\
07:26:20 <augustss> Yeah, it can be very, very annoying.
07:26:20 <vixey> hi
07:26:25 <Twey> Yo, vixey
07:26:29 <Saizan> in this case you can add OverlappingInstances
07:26:42 <Saizan> and it'll pick the more specific one
07:26:44 <Twey> Yes, of course
07:26:46 <Saizan> so [(String, a)]
07:26:50 <vixey> I can't figure out how to turn this declarative thing into an actual implementable thing
07:26:51 <vixey> :(
07:27:00 <vixey> I spent like a week on it
07:27:04 <Twey> (which is more specific out of (String, a) and (a, String)?)
07:27:17 <Twey> vixey: :( Been there
07:27:35 <augustss> Twey: no, they are uncomparable
07:27:44 <vixey> Twey and what happened in the end?
07:27:45 <augustss> vixey: what thing?
07:27:53 <vixey> augustss, a type system
07:27:55 <Twey> vixey: I broke down and rewrote it from scratch :-P
07:27:59 <augustss> vixey: ah :)
07:28:22 <Twey> augustss: So it will give an overlapping instances error?
07:28:30 <vixey> Twey, I just have all these bits of paper with scribbles on them
07:28:32 <augustss> Twey: yes
07:30:35 <vixey> so I have no clue what to do
07:31:04 <paolino> hi, is it possible to fork an "t IO ()" action ?
07:31:06 <augustss> You can't even write down the types of the things you want to implement?
07:32:08 <Twey> paolino: Depends what t is
07:32:39 <paolino> RWST a b c
07:33:21 <vixey> I wrote this http://rafb.net/p/9raiCS24.html
07:33:28 <memento> hi, Im stucked with some monad related problem... Im trying to use error monad with state monad, but i get some compiler error what i not really understand: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1080#a1080 can someone help where is my problem? thx
07:33:40 <vixey> it does everything except proof irrelevance
07:33:50 <vixey> not sure if it's even possible to implement pi
07:34:01 <Twey> paolino: You haven't given it enough type arguments, then
07:34:12 <Twey> paolino: At that point it's still of kind * -> *
07:34:16 <vixey> memento, but you didn't use a monad transformer (?)
07:34:35 <vixey> memento, there is an example of using State and Error together in a transformer if you want..
07:35:06 <paolino> :t RWST
07:35:07 <lambdabot> forall r s (m :: * -> *) a w. (r -> s -> m (a, s, w)) -> RWST r w s m a
07:35:30 <paolino> :t RWST a b c IO ()
07:35:31 <lambdabot> Not in scope: data constructor `IO'
07:35:40 <memento> yeah iwould like to do that
07:35:42 <paolino> :k RWST a b c IO ()
07:35:43 <lambdabot> Not in scope: type variable `a'
07:35:43 <lambdabot> Not in scope: type variable `b'
07:35:43 <lambdabot> Not in scope: type variable `c'
07:35:57 <Saizan_> memento: checkConstInPredList takes 3 arguments according to its type signature
07:36:11 <paolino> :k RWST () [()] () IO ()
07:36:12 <Saizan_> memento: but you're using and defining it as a function of 2 arguments
07:36:12 <lambdabot> *
07:36:52 <Saizan_> memento: so it thinks you're trying to use ((->) Context) as a monad
07:36:56 <Twey> Oh, I thought you were talking about RWST IO () ?
07:37:02 <memento> Saizan_: yeah cause the third is context what cames from state
07:37:22 <Axman6> what's RWST for?
07:37:35 <memento> but i think monad transformers will be the solution..
07:37:51 <Saizan_> memento: ok, if the context is in the state, then you have to remove the "Context ->" part from the typesign of checkConstInPredList
07:37:53 <vixey> @go monad transform stacks step by step
07:37:55 <lambdabot> No Result Found.
07:38:21 <paper_cc> memento: you shouldn't declare the Context argument, it's already inside SemanticResultM
07:38:27 <vixey> www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
07:38:33 <vixey> memento, ^ here
07:38:40 <paolino> Axman6: a shortcut for Reader, writer, state
07:38:54 <memento> thx
07:38:58 <Axman6> oh... three things i don't get >_<
07:39:03 * Twey chuckles.
07:39:07 <SamB_XP> heh
07:39:09 <vixey> so...
07:39:13 <Axman6> what a bastard monad!
07:39:19 <vixey> any ideas for me.. ?
07:39:21 <Axman6> seriously, who does that?
07:39:22 <Saizan_> however you also have to use StateT instead of State
07:39:23 <vixey> I am stuck
07:39:25 <Twey> They came up with it just to get to you, Axman6!
07:39:40 <Twey> vixey: You know I'm not smart enough to understand your codings :-P
07:39:54 <vixey> my code isn't actually important
07:40:14 <SamB_XP> Axman6: I dunno!
07:40:19 <mreh> doesnt anyone know of a editor that I can extend with my own haskell code?
07:40:27 <paper_cc> mreh: Yi?
07:40:35 <SamB_XP> mreh: you can hack Yi ...
07:40:36 <paper_cc> @where yi
07:40:37 <lambdabot> http://www.haskell.org/haskellwiki/Yi
07:40:45 <mreh> hack yi?!
07:40:59 <SamB_XP> I dunno if it has any kind of plugin system yet
07:41:02 <paolino> @hoogle Identity
07:41:03 <lambdabot> module Control.Monad.Identity
07:41:03 <lambdabot> Control.Monad.Identity newtype Identity a
07:41:03 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
07:41:18 <paolino> @hoogle IdentityT
07:41:18 <lambdabot> No results found
07:41:22 <Twey> mreh: Well, you can use emacs and call external code.
07:41:27 <hackage> Uploaded to hackage: HDBC 2.0.1
07:43:05 <mreh> i am about to ditch windows entirely, so i might as well
07:45:28 <vixey> I need to see some type system that implements something vaugely like what I want
07:45:29 <vixey> I guess
07:47:21 <vixey> any texts or anything would anyone recommend?
07:50:39 <Olathe> If I want to make Data.ByteString.Lazy.ByteString an instance of my class, do I really have to make Data.ByteString.Lazy.Internal.ByteString an instance ?
07:50:46 <mreh> why is the base of SI units binary multiples of bytes and not bits?
07:51:06 <Baughn> mreh: Hysterical raisins.
07:51:12 <dcoutts_> Olathe: you can import it from the normal module
07:51:27 <SamB_XP> mreh: why not ?
07:51:36 <Baughn> mreh: And they're not, really. One kilobit = 1000 bits, one kilobyte = 1000 bytes; you pick which.
07:51:44 <mreh> a byte is an arbitary group of bits
07:52:18 <mreh> most words these days are 32 bits, word in a system architecture sense
07:54:08 <mreh> the difference between the two grows bigger and bigger as you get larger SI prefixes, my 3TB RAID array is actually 2.43GB :(
07:54:21 <mreh> 2430GB
07:54:22 <Olathe> dcoutts_: Ahh, thanks. It looks like the problem is elsewhere.
07:54:24 <Adamant> mreh: byte is pretty standardized at 8 bits
07:54:40 <Adamant> in practice at least
07:54:57 <mreh> why not seven?
07:55:06 <Adamant> mreh: they used to do that
07:55:09 <Adamant> they don't anymore
07:55:11 <Adamant> in general
07:55:12 <Twey> Adamant: byte is
07:55:19 <Twey> Kilobyte isn't
07:55:30 <Adamant> Twey: I agree there
07:55:44 <Twey> Oh, I see, you were talking about the earlier :)
07:55:51 <SamB_XP> we could just use KiB to be clear
07:56:11 <Adamant> SamB_XP: down with SI
07:56:12 <Twey> SamB_XP: Yes, but unfortunately there isn't an equivalent for the decimal kilobyte
07:56:41 <Twey> As it goes, we need to split KB into KiB and KeB or something
07:56:47 <Olathe> 2.5 million bytes
07:56:58 <mreh> the moral of the story is: HDD manufacturers are sneaky motherfuckers
07:57:05 <Adamant> yes
07:57:07 <Twey> Indeed they are, indeed they are
07:57:23 <SamB_XP> well, the "1.44 megabyte" floppy is the worst
07:57:35 <Twey> Why's that?
07:57:42 <mreh> does anyone know how to calculate the size of a RAID 3 parity drive?
07:57:51 <Twey> I kind of skipped the 3Â½-inch floppy era
07:57:51 <SamB_XP> it stores 1440 KiB
07:58:02 <Twey> Went straight from the 5Â¼ to the CD
07:58:08 <Olathe> SamB_XP: Haha
07:58:08 <Twey> SamB_XP: Oh dear
07:58:39 <Twey> *headdesk*
07:58:40 <mreh> it's more like 1.38 MiBi isn't it
07:58:51 <Olathe> > 1.44 * 1024
07:58:52 <lambdabot>   1474.56
07:59:09 <paper_cc> > 1440 / 1024
07:59:10 <lambdabot>   1.40625
07:59:17 <Twey> 1.4You have: 1440 KiB
07:59:17 <Twey> You want: MiB * 1.40625
07:59:34 <Twey> Got it ages ago, but damn you irssi for mucking up the indentation :-P
07:59:48 <Twey> I love units, don't know how I could live without it :-P
08:00:11 <mreh> we'll be talking in qibits soon
08:00:14 <Olathe> Without units, how could you divide ?
08:00:30 <Twey> Haha
08:03:03 <Olathe> OK, in Data.ByteContainer, I have instance ByteContainer [Char]. In the file I'm working on, I have import Data.ByteContainer (ByteContainer)
08:03:22 <Olathe> Then, later...getImage :: (ByteContainer a) => FilePath -> IO a; getImage xs = return "test"
08:03:37 <Olathe> But I get Couldn't match expected type `a' against inferred type `[Char]'
08:03:48 <Twey> Olathe: Of course
08:03:53 <Twey> What did you expect?
08:04:05 <Twey> If someone tries to use that as an Int, it'll fail horribly.
08:04:18 <Olathe> As an Int ?
08:04:27 <Twey> (assuming Int has a ByteContainer instance)
08:04:29 <mornfall> Olathe: return "test" forces IO [Char].
08:04:36 <mornfall> Olathe: Therefore, it may not be IO a.
08:04:42 <Olathe> How do I get IO a ?
08:04:50 <Olathe> Oh.
08:04:51 <Olathe> I see.
08:04:52 <Twey> Olathe: By saying (ByteContainer a) -> IO a, you're saying it works for *any* value of a that is a ByteContainer
08:05:03 <Twey> Er, =>
08:05:04 <Olathe> Right. Thanks :)
08:10:40 <chessguy_work> Twey, and s/value of/type/
08:11:01 <Twey> Hmmmm
08:11:03 <vixey> no, what Twey said is right
08:11:12 <chessguy_work> a is a type, not a value
08:11:17 <Twey> But that type is a value of a
08:11:32 <vixey> any value of Bool = True or False
08:11:32 <Twey> Compare 'for all values of...'
08:11:41 <chessguy_work> the function takes a value of type a
08:11:51 <Twey> It means 'anything that could possibly match a'
08:12:26 <Baughn> If you started a haskell (er.. GHC project, really) right now, which version of GHC would you base it on?
08:12:38 <chessguy_work> wo [] is a value of Monad ?
08:12:46 <chessguy_work> *so
08:13:06 <Baughn> [a] is an instance of Monad, yes
08:13:13 <chessguy_work> that's not what i said
08:13:29 <Baughn> Well.. monad, as a type-class, doesn't really have "values"
08:13:38 <chessguy_work> Baughn, my point exactly
08:13:49 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1081#a1081 Can anyone tell me why line 8+9 raises the error "couldn't match expected type Writer w b against interferred type Writer w a" whereas line 10 is just fine?
08:13:55 <chessguy_work> i'm sure Twey knew what he meant, but i don't think it was very clear
08:14:08 <Baughn> "[] is a valid value of the list instance of the monad type-class." I can see the use for short-hand.
08:14:32 <Axman6> google's fixed
08:14:35 <chessguy> s/monad/Monad/
08:14:42 <cnwdup> Ah, I think I know why.
08:14:47 <Baughn> But, anyway: 6.8.3 or 6.10.1? I know 6.8.3 is more stable, but on the other hand 6.10.1 has all these neat features I'd like to use.. which would be best?
08:15:16 <SamB_XP> well, 6.10 has that wierd line-editing library ...
08:15:23 <SamB_XP> editline or whatever it's called
08:15:26 <Baughn> Not a problem when compiling from source, but yeah. :/
08:15:31 <Baughn> There are no binary packages that work on gentoo
08:15:42 <SamB_XP> then how do you compile it ;-P
08:15:47 <Twey> chessguy: Nay, Monad isn't a variable
08:15:49 <Baughn> With 6.8.2. :P
08:15:50 <Twey> It's a typeclass
08:16:01 <chessguy> i'm well aware of that, thanks
08:16:03 <dcoutts_> Baughn: I think there were binary packages added for gentoo recently
08:16:14 <chessguy> actually it's a type constructor class
08:16:29 <SamB_XP> chessguy: we call them all type classes now
08:16:37 <SamB_XP> now that the feature is standard
08:16:42 <Baughn> dcoutts_: Anyway, are the bugs in 6.10 going to be an issue in practice?
08:16:55 <SamB_XP> and has been for at least the last decade
08:17:00 <dcoutts_> Baughn: I use 6.10 now
08:17:02 * vixey eagerly awaits blekko
08:18:03 <Baughn> dcoutts_: I'll take that as a "no".
08:18:27 <SamB_XP> dcoutts_: are they annoying ?
08:18:40 * Baughn wonders whether to use 6.10.1 directly or the darcs head
08:18:44 <dcoutts_> SamB_XP: are what annoying?
08:18:49 <SamB_XP> the bugs!
08:19:10 <dcoutts_> I've not really run into many that I can think of
08:19:11 <Baughn> SamB_XP: Well, there's a bug that breaks the x86_64 code generator when optimization is on...
08:19:14 <Baughn> At least for FFI code
08:19:33 * Baughn won't be using FFI for this project, though
08:22:13 <Twey> chessguy: I don't mean to imply that you don't, but 'a value of x' is standard terminology for referring to one possible 'instance' of the variable x
08:23:22 <chessguy> Twey, yeah, i guess it just seems like a bad idea in this case, because 'value' also has a more specialized meaning, and could be confusing
08:23:52 <vixey> Welcome to Cuilâ€”the worldâ€™s biggest search engine. The Internet has grown. We think itâ€™s time search did too.
08:23:55 <vixey> what???? lol
08:24:04 <Twey> I can agree with you.
08:24:41 <chessguy> i.e., [String], while it could be the 'value' of 'a' in a type signature, isn't a value
08:24:45 <joga> vixey, biggest? ;) where do you get that?
08:24:53 <chessguy> (in the usual haskell sense)
08:24:53 <joga> oh...I see
08:24:55 <vixey> joga, on the cuil site :p
08:25:05 <chessguy> i'm probably just being pedantic though
08:25:47 <joga> vixey, yeah...just noticed. I haven't found cuil's search experience to be very good though, not to say I don't like the idea..
08:25:52 <jpcooper> is there any reason why doing forkIO on a getLine should not work?
08:25:58 <chessguy> what can i say, somebody compiled me with -Wall turned on :)
08:26:03 <Baughn> chessguy: "a is a value of b, which is a value of c, which is a value of..."
08:26:07 <joga> vixey, but three times as many pages as google? ;) weird..
08:26:08 <vixey> joga, I' not sure what the idea is
08:26:12 <jpcooper> I have separate threads doing getLine and receiving input from the net
08:26:24 <Baughn> chessguy: Since it's useful to know which rank of meta-value we're talking about, we use value, type, kind, sort, etc. instead.
08:26:37 <joga> vixey, last I checked they didn't keep any information about your searches
08:26:46 <Baughn> jpcooper: In what sense does it not work?
08:26:48 <vixey> oh right yeah
08:26:53 <dcoutts_> @localtime dons
08:26:54 <lambdabot> Local time for dons is Sat Jan 31 08:26:56 2009
08:26:57 <jpcooper> Baughn, nothing happens when I run it from the command-line
08:26:57 <chessguy> Baughn, umm. are you making some kind of point?
08:27:00 <Twey> chessguy: You're right, but while it would have been preferable to say 'type', to say 'value' wasn't wrong in this context â€” just less specific
08:27:12 <chessguy> Twey, agreed
08:27:28 <Baughn> chessguy: Not really. Heat stroke from compiling ghc, I think.
08:29:07 <jpcooper> could you think of any problems?
08:29:42 <jpcooper> forkIO (getLine >> return ()) does not work for instance
08:30:14 <Baughn> jpcooper: Is that the entire program? What do you expect it to do?
08:30:25 <jpcooper> maybe I should get the standard input and use hgetline
08:30:35 <jpcooper> no, that's just an example
08:31:17 <jpcooper> hGetLine stdin doesn't work either
08:31:27 <Baughn> jpcooper: getLine = hGetline stdin, so..
08:31:28 <jpcooper> I just want a separate thread that will get input from the command line
08:31:57 <Baughn> That shouldn't be a problem, so long as you only read stdin from /one/ thread. But what will you then do with the input?
08:32:22 <Baughn> Also, your program will quit immediately once your initial thread returns
08:33:03 <jpcooper> Baughn, it isn't even waiting to get input though
08:33:40 <Baughn> jpcooper: Your program will quit immediately once the initial thread returns. Is the initial thread, in fact, returning?
08:33:56 <jpcooper> I don't know your definition of return here
08:34:06 <jpcooper> I would have thought that it would wait for input and then return
08:34:23 <jpcooper> I have main = forkIO (getLine >> return ())
08:34:31 <Baughn> "main = forkIO (doSomethingThatTakesHalfAnHour)" <-- This program will run quit immediately
08:34:45 <jpcooper> right
08:34:51 <jpcooper> could you tell me how to do what I want to do, please?
08:34:53 <Baughn> jpcooper: Right. You need to have your initial thread wait for the forkIO'd one to return
08:35:02 <jpcooper> okay thank you
08:35:35 <Baughn> A typical way of doing that is to create an MVar when said thread is forked, then have the initial one block trying to take it, and put () in it as the last act the forked thread does.
08:36:01 <jpcooper> okay
08:37:06 <Baughn> It doesn't show up as much in real code, though. Typically, you fork a thread to have it do something it will then tell the main thread about, which implictly produces the same behaviour.
08:37:33 <jpcooper> yes
08:40:39 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1082#a1082 Why's that? I don't see whats different from the original MonadWriter instance.
08:42:53 <jpcooper> thanks a lot Baughn. It works now
08:44:19 <rwbarton> cnwdup: Well the MonadWriter class has two parameters...
08:44:50 <sbahra> Good morning #haskell
08:45:25 <conal> sbahra: howdy
08:46:16 <guenni> hi
08:46:30 <guenni> what's the successor of hpaste again?
08:46:36 <vixey> ?where moonpaste
08:46:36 <lambdabot> I know nothing about moonpaste.
08:46:39 <quicksilver> @where hpaste2
08:46:39 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
08:46:45 <cnwdup> rwbarton, "instance (Monoid w) => MonadWriter (Writer w) where [...]" is the original implementation, isn't it? Why is that working and mine is not?
08:46:54 <vixey> why does the bot forget everything?
08:47:05 <guenni> vixey: thx
08:47:10 <sbahra> @fact symbols
08:47:10 <lambdabot> symbols: "âŠ¤ âŠ¥ Î» Îµ Î· Î¹ âˆƒ âˆ€ Â¬ âˆˆ âˆ‰ âˆ‹ âˆŒ âˆ§ âˆ¨ âŠ• â†‘ â†“ â‡’ â‡ â‡” âŠ¢ âŠ¬ âŠ¨ âŠ­ âˆ˜ âˆª âˆ© âˆ´ âˆµ â‰¡ âŠ‚ âŠƒ âŠ» âŠ¼ â‹€ â‹ âŠ² âŠ³ âŸ¦âŸ§"
08:47:35 <Axman6> @fact logic
08:47:35 <lambdabot> I know nothing about logic
08:47:39 <Axman6> hmm
08:47:41 <sbahra> @fact l
08:47:41 <lambdabot> l: "âŠ¤ âŠ¥ Î» Îµ Î· Î¹ â‹€ â‹ âˆƒ âˆ€ Â¬ âˆ§ âˆ¨ âŠ• â†‘ â†“ â‡’ â‡ â‡” â‰ âŠ¢ âŠ¬ âŠ¨ âŠ­"
08:47:47 <loadquo> Conal: Automatic Differentiation is interesting, thanks. Has there been any work on automatic integration?
08:47:48 <sbahra> Axman6, logic -> l
08:47:59 <Axman6> where's the logic in that!
08:48:04 <Axman6> oh, on the left :)
08:48:22 <sbahra> ;-p
08:48:34 <sbahra> Axman6, how's lighty + wordpress going?
08:48:51 <cnwdup> rwbarton, ah. The original implementation is different. instance MonadWriter w (WriterL w) should work.
08:48:54 <Axman6> ditched wordpress, using movable type now, which is working quite nicely :)
08:48:58 <luqui> I remember seeing on the wiki once an example of a program that took LC expressions and "compiled" them to values, using some clever trickery
08:49:01 <sbahra> Axman6, URL?
08:49:05 * sbahra has never used movable type
08:49:31 <luqui> i.e. Lambda (Var 0) --> a value which reduced to id.
08:49:31 <Axman6> http://axman6.homeip.net/blog/ it'll probably be slow, my ISP is screwing up yet again
08:49:35 <luqui> anybody know where that is?
08:49:54 <sbahra> Axman6, do you want someone to host you?
08:50:18 <Axman6> nah i'm fine, i like having my own server :)
08:50:22 <vixey> luqui, what was clever about it?
08:50:49 <vixey> luqui, I can see how to do it for:  Lambda (Var Fz)
08:51:33 <luqui> vixey, it didn't pass around an environment; i.e. it compiled down the same way GHC would (sans optimizations).
08:51:50 <luqui> so if a function didn't use one of the parameters in its environment, that parameter could get GC'd, for example
08:51:55 <vixey> oh sounds interesting
08:52:29 <luqui> It's obvious if you have your program represented as combinators.   compile S = \x y z -> x z (y z); compile K = \x y -> x.
08:52:41 <luqui> but doing it with de bruijn terms seems a bit harder
08:52:50 <vixey> luqui, in some Monad.Reader article there was one about compiling down into combinators
08:53:07 <luqui> vixey, thanks, I'll look
08:53:21 <vixey> I htink the title was to do with efficient interpreter for ghci
08:53:24 <vixey> something like that
08:54:46 <conal> loadquo: there's been a lot of work on *symbolic* integration, but i don't know anything analogous to AD for integration.  and i think it's inherently problematic.
08:55:07 <luqui> vixey, yep, issue 10.  thanks!
08:55:23 <luqui> conal, integration is not compositional.
08:55:25 <vixey> conal, I think the problem is that you can't find the integral of (.)
08:55:41 <Axman6> conal: at uni they pretty much drilled into us that integration isn't a science, more tril and error
08:55:43 <conal> right
08:56:02 <Axman6> trial*
08:56:16 <conal> there was tremendous progress in automated symbolic integration.
08:56:24 <vixey> symbolic integration (like unknotting) is one of these tremendously difficult algorithms that probably aren't undecidable but nobody has ever fully implemented it
08:56:51 <Axman6> things like mathematica do a pretty good job
08:57:02 <conal> and how
08:57:18 <Axman6> but my god mathematica's syntax is terrible :(
08:57:19 <conal> integration moved out of AI labs a while ago.
08:58:13 <conal> luqui: did you mean something specific by "integration is not compositional"?
08:58:16 <Axman6> i'm reading http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#unboxed-tuples , could someone explain why g (# a,b #) = a is illegal?
08:58:47 <loadquo> conal: I thought it might be tricky in general... thanks. It might be nice to have something that worked for some formulae though.
08:59:28 <sclv> no chain rule, right?
08:59:30 <Axman6> also, i'm not sure if i can say something like data V = (# Double, Double, Double #)
08:59:37 <conal> loadquo: i agree.
08:59:47 <conal> sclv: that's my guess about what luqui meant, but i'm not sure.
09:00:06 <luqui> conal, yeah, pretty much.  Same for products, etc.
09:00:38 <loadquo> I might have a go at some point, once I have a better understanding of AD. I wanted it so you could have proper functional PDFs with the area under them summing to 1.
09:00:41 <conal> luqui: i guess differentiation is not compositional either in the sense we use for semantics.
09:00:47 <luqui> automatic integration is really hard because you usually can't break an integration problem into subproblems.
09:00:55 <luqui> conal, it's not?
09:01:06 * loadquo heads off
09:02:10 <conal> luqui: i don't think so.
09:02:39 <ozy`> > 0100
09:02:40 <lambdabot>   100
09:02:48 <ozy`> ahhhh
09:02:52 <ozy`> > 0o100
09:02:53 <lambdabot>   64
09:03:03 <ozy`> > 0o4000
09:03:04 <lambdabot>   2048
09:03:11 <ozy`> > 0o400
09:03:12 <lambdabot>   256
09:03:22 <luqui> conal, oh yeah you're right.  If it were, we'd have: d(a $ b) = d(a) d($) d(b)
09:03:25 <jpcooper> could anyone give me a reason why I would get "Main: thread blocked indefinitely" when waiting for something to be put into an MVar?
09:03:28 <luqui> but there is no suitable d($)
09:03:38 <conal> luqui: exactly.
09:03:54 <conal> luqui: which i hadn't noticed until i wondered about your claim about integration not being compositional.
09:04:04 <Cale> jpcooper: Because the MVar perhaps got GC'd?
09:04:08 <conal> s/claim/remark/
09:04:29 <jpcooper> stopVar = newEmptyMVar
09:04:29 <jpcooper> main = do forkIO $ getLine >> stopVar >>= flip putMVar ()
09:04:29 <jpcooper>           stopVar >>= takeMVar
09:04:29 <jpcooper>           putStrLn "Done"
09:04:33 <vixey> conal, you use $ for composition in semantics ?
09:04:46 <luqui> that was application.
09:04:48 <conal> vixey: no.  i use (.)
09:04:55 <jpcooper> Cale, I guess I'm "doing it wrong"
09:05:13 <vixey> conal, but you can differentiate a composition
09:05:15 * Axman6 is disappointed that dons' n-bodies shootout program segfaults under 6.10.1 :(
09:05:22 <luqui> vixey, but that's what we mean by "compositional" no matter what we mean by $ :-)
09:05:26 <conal> i thought luqui meant composition.
09:05:39 <Cale> jpcooper: stopVal >>= takeMVar will always fail
09:05:50 <luqui> it holds for all operators.
09:05:56 <Cale> jpcooper: You're creating a new empty MVar and then immediately taking it
09:05:56 <vixey> in this:  d(a $ b) = d(a) d($) d(b)
09:06:10 <Cale> jpcooper: It doesn't even have a name, so it can't be referenced from anywhere else
09:06:14 <vixey> well I'm confused
09:06:28 <Cale> stopVar *
09:06:32 <conal> what i meant is the chain rule breaks the form of 'compositional definition'
09:06:37 <jpcooper> Cale, it doesn't have a name?
09:06:53 <Cale> jpcooper: You should be aware that when you write "stopVar = newEmptyMVar", you're not defining stopVar to be the result of newMVar
09:07:04 <luqui> I guess that property only makes sense for functions which mean "meaning".  It's far too strong for anything else.  So basically we're saying "differentiation is not a meaning function"
09:07:08 <Cale> jpcooper: You're defining stopVar to be *equal* to newMVar
09:07:09 <luqui> which is... pretty obvious
09:07:10 <Cale> er
09:07:14 <jpcooper> aah yes
09:07:16 <Cale> newEmptyMVar, rather
09:07:21 <Jedai> hello, does anyone here know a good algorithm to turn a DAG into a strongly connected graph ?
09:07:24 <ozy`> jpcooper: you have to put stopVar <- newMVar in a do block :p
09:07:36 <conal> luqui: and that's fine with me.  still, i wonder about integration.
09:07:46 <Jedai> I'm trying to do it with Data.Graph (nice library by the way)
09:07:56 <jpcooper> thanks Cale and ozy`
09:08:47 <Axman6> @check \x -> if (x::Double) > 0 then not (x <= 0) else True
09:08:48 <lambdabot>   "OK, passed 500 tests."
09:08:49 <luqui> conal, well, I'd like to nail down exactly what differentiation is that integration isn't...
09:08:51 <conal> luqui: i don't know how to define the question.  since i don't know of any precise sense in which differentiation is "compositional" either.
09:09:00 <conal> luqui: me too.
09:09:03 <Axman6> > (K, passed 500 tests."
09:09:04 <lambdabot>   <no location info>:
09:09:04 <lambdabot>      lexical error in string/character literal at chara...
09:09:05 <Cale> The nice thing about differentiation is that it's fairly compositional, but unfortunately, from an analytical perspective, it's a horribly discontinuous function. Integration on the other hand is nice and continuous, but it's somewhat arcane to calculate symbolically.
09:09:06 <Axman6> urgh
09:09:24 <jpcooper> Cale, so is my only way to do it in a do block? I would have thought that my binding would be equivalent
09:09:28 <Axman6> > (\x -> if (x::Double) > 0 then not (x <= 0) else True) NaN
09:09:29 <lambdabot>   Not in scope: data constructor `NaN'
09:09:38 <Axman6> > (\x -> if (x::Double) > 0 then not (x <= 0) else True) (1/0)
09:09:39 <lambdabot>   True
09:09:41 <Cale> jpcooper: You have to actually run newEmptyMVar to create the MVar
09:09:50 <Cale> jpcooper: There's no way around it.
09:10:21 <jpcooper> so I run it by doing x <- newEmptyMVar ?
09:10:26 <Cale> yes
09:10:27 <ozy`> > let foo = putStrLn "this code will never run" in "pizza"
09:10:28 <lambdabot>   "pizza"
09:10:33 <Cale> Then x is an MVar which is initially empty.
09:10:41 <rwbarton> jpcooper: in your program you have stopVar = newEmptyMVar.  So you can replace all occurrences of stopVar with newEmptyMVar.
09:10:48 <rwbarton> jpcooper: The resulting program is obviously not what you intended :)
09:10:52 <jpcooper> sure
09:11:13 <jpcooper> I need every single one to use the same one of course
09:11:25 <jpcooper> okay thanks
09:12:05 <ozy`> jpcooper: so: main = do stopVar <- newEmptyMVar; everythingElseInYourOldCode
09:12:19 <jpcooper> yes
09:12:35 <jpcooper> I was just hoping that there was a more elegant way in which to do it
09:12:39 <jpcooper> though I understand why this works
09:27:40 <Axman6> bloody hell, i just made my n-bodies program a contender by using unsafe(Read|Write)
09:28:09 <zachk> a contender in what compeition
09:28:15 <Axman6> the shootout
09:28:22 <vixey> :/
09:28:26 <vixey> do it without unsafe
09:28:28 <beelsebo_> bad Axman6!
09:28:34 <beelsebo_> do it with reactive
09:28:35 <beelsebo_> >.>
09:28:50 <Axman6> not up there with C and such, but it went from 2:30 to 1:50
09:28:56 <Jedai> Well on the other hand actually readArray is buggy anyway
09:28:58 <rwbarton> unsafe* just means no bounds checking, right?
09:29:04 <Axman6> yep
09:29:15 <Jedai> the bounds checking doesn't work well I believe
09:29:16 <rwbarton> and yeah the bounds checking is broken
09:29:31 <beelsebo_> does the shootout allow for interesting alternative programs?
09:29:39 <rwbarton> in certain circumstances (when the index type is a tuple)
09:29:40 <Axman6> i think so
09:29:55 <beelsebo_> I'll stick http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1076#a1084 up when I know it works
09:29:56 <Axman6> "Avoid redundant bounds checks by using Data.Array.Base.unsafeAt, Data.Array.Base.unsafeRead, Data.Array.Base.unsafeWrite (these are currently undocumented, unfortunately). This can make a large difference." quite a difference here
09:30:27 <Axman6> > 100*90/160
09:30:28 <lambdabot>   56.25
09:30:44 <Axman6> so, 44% speed improvment
09:30:45 <rwbarton> Well, it's semi-broken.  It checks that you're not writing outside the bounds of the array in memory, but not that you passed a legitimate tuple within rectangular bounds.
09:31:40 <zachk> im working on breeding sheep using the maybe monad and inspired from the all about monad tutorial
09:32:11 <beelsebo_> Axman6: how fast does the current submission run on your machine?
09:32:20 <Axman6> beelsebo_: it segfaults :)
09:32:24 <beelsebo_> o.O
09:32:24 <Jedai> rwbarton: oh right, as long as the translated index is between the real bounds it say it's ok... Given that the result is then not even from the right row, I would say it's pretty broken
09:32:36 <Axman6> i know, and it's donsCodeâ„¢!
09:33:02 <rwbarton> Jedai: right, from a certain point of view a program that runs "successfully" and then returns the wrong answer is worse than a program that crashes
09:33:40 <Axman6> loop arr m n c | arr `seq` m `seq` n `seq` c `seq` False = undefined <-- hmm... this is giving me more beelsebo_ disgusting ideas
09:33:43 <Jedai> rwbarton: That's my point of view :) Well it all depends on what you prefer, sometimes a wrong result is better than a crash
09:34:40 <Jedai> Axman6: bang patterns should be as fast, no ?
09:34:48 <rwbarton> Axman6: did you just use beelsebo_ as an expletive? :)
09:34:48 <Axman6> hmm, good point
09:35:37 <zachk> goodFunction badInput=moreGarbage
09:35:39 <SamB> from what point of view is the program that fails to crash better ?
09:36:09 <beelsebo_> Axman6: since when did my name warrant such a horrific use?
09:36:09 <chrisdone> if a program crashes... that sucks hard
09:36:12 <int-e> not crashing sounds like a big plus to me
09:36:22 <beelsebo_> Axman6: also, you able to chuck me your code, I got the donscode to run
09:36:25 <zachk> i would say throwing a cryptic error message then gracefully exiting is better then a segfault
09:36:32 <Deewiant> SamB: it might give correct results 99% of the time while the crashing one gives none
09:36:40 <rwbarton> SamB: Maybe if it's running in a web server
09:36:44 <chrisdone> zachk: "better than"
09:36:44 <SamB> zachk: oh, that's what I meant by crashing
09:36:46 <Axman6> beelsebo_: huh, interesting. 6.10.1?
09:36:49 <Jedai> SamB: In certain environment, it's better than a non-critical part of the program gives wrong results rather than crash and endanger the whole thing (with critical parts)
09:36:50 <beelsebo_> Axman6: yep
09:36:53 <SamB> rwbarton: hmm, well, the server should catch it ;-P
09:37:22 <rwbarton> SamB: Right, so the current bounds checking ensures that we get an exception and never a segfault, so it serves *some* purpose
09:37:25 <Axman6> how odd, how'd you compile it?
09:37:33 <beelsebo_> Axman6: using the command given
09:37:33 <SamB> Deewiant: I really hate it when programs give you that incorrect result 1% of the time instead of crashing 10% ...
09:37:41 <beelsebo_> Axman6: is your code uber sekrit?
09:37:42 <Axman6> because it segfaulted right away when i tried anything
09:37:46 <Axman6> heh, nah
09:37:50 <Deewiant> SamB: in some environments I guess it's more important that a program stays on
09:37:51 <beelsebo_> can has?
09:37:56 <Axman6> soon :)
09:37:59 <beelsebo_> aww
09:38:00 <beelsebo_> gief
09:38:06 <Deewiant> SamB: do you want your pacemaker to stop your heart or to make you breath hard once a year ;-)
09:38:12 <SamB> well, I'm thinking of compiler debugging
09:38:18 <SamB> Deewiant: point
09:38:38 <daf> hmm. is there a better way to split a bytestring into groups of bytes than something like: map (BS.take 3) $ takeWhile (not . BS.null) $ iterate (BS.drop 3) ?
09:38:41 <Jedai> SamB: But generally of course I prefer an honestly crashing program rather than a lying silently failing one
09:38:48 <Axman6> urgh, i keep doing things like x <- f; return x >_<
09:38:54 <beelsebo_> lol
09:39:01 <SamB> I'd vastly prefer the compiler to break off half-way through rather than creating nonsense output
09:39:01 <Deewiant> Axman6: doesn't HLint catch that?
09:39:10 <Axman6> no idea ;)
09:39:13 <Deewiant> It seems like the kind of thing that it would anyway
09:39:14 <chrisdone> Axman6: I wrote: `return . id' the other day
09:39:19 * rwbarton too
09:39:19 <Axman6> haha
09:39:28 <rwbarton> just saying the current bounds checking is not totally useless
09:39:32 <SamB> though I of course prefer it to give more information rather than less when it does
09:40:47 <bos> daf: you could use splitAt
09:45:46 <alsonk_> @seen dons
09:45:46 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 15h 55m 52s ago.
09:50:20 <daf> bos: oh, I forgot about unfoldr
09:56:08 <mbac> wtf, why does darcs depend on tetex
09:57:13 <zachk> ok  i want to do something like this: iNames<-  lines $ readFile nameFile in the IO monad do i need to lift lines into the IO monad for it to work?
09:59:12 <Deewiant> zachk: yep, fmap lines
09:59:41 <newsham> data SupportedWorld = World | Turtle SupportedWorld
10:03:55 <Olathe> data Supported = Turtle Supported; bottomTurtle = Turtle bottomTurtle
10:04:13 <vixey> :(
10:04:22 <vixey> I don't think either of these definitions captures it
10:06:37 <Olathe> evilScientistsSay = Turtle undefined
10:06:43 <Olathe> Obviously, the scientists are wrong.
10:07:13 <mbac> is there a better way to get cabal-install to work on freebsd than manually downloading and installing it and its dependencies?
10:07:24 <mbac> i can't find hackage or cabal in the ports tree
10:08:16 <dcoutts_> mbac: you can use the bootstrap script in the cabal-install package. Mind you it's only 2 non-standard dependencies.
10:11:37 <vixey> Can you use haskells lazyness to implement lazy context splitting?
10:11:47 * vixey (thinks it is not possible)
10:12:01 <newsham> man, its worth knowing haskell just to be able to read sigfpe and conal blogs.
10:13:24 <mbac> it's worth knowing haskell so you can rub it in the faces of people with CS degrees
10:13:30 <mbac> <-- dropout
10:13:52 <vixey> haha
10:13:58 <Heffalump> what about people with CS degrees that know Haskell?
10:14:18 <mbac> awkward social moment where i leave the room in shame
10:14:20 <SamB> you don't care then
10:14:23 <newsham> mbac: :(
10:14:24 <byorgey> anyone know why I might get the error "colour-2.2.0 failed while downloading the package." while trying to install the colour package with cabal-install?
10:14:41 <SamB> hopefully he finds that out before trying to rub it in!
10:14:53 <byorgey> dcoutts_: any ideas? ^^^
10:14:55 <dcoutts_> byorgey: perhaps the download failed :-)
10:14:59 <byorgey> har har
10:15:04 <SamB> if they know Haskell, they shouldn't care if he has a CS degree anyway
10:15:08 <dcoutts_> byorgey: run cabal fetch colour-2.2.0 -v3
10:15:19 <dcoutts_> see if it provides any insights
10:15:23 <SamB> it is unlikely that they learned Haskell doing their undergrad ;-P
10:15:34 <Heffalump> really? A lot of unis in the UK teach it.
10:15:48 <SamB> not that kind of "learned Haskell"
10:15:49 <dcoutts_> SamB: I taught Haskell to lots of undergrads
10:15:54 <byorgey> dcoutts_: ah, hmm, I get a permission denied error while it's trying to create a directory to download it to
10:16:00 <SamB> that doesn't make 'em junkies!
10:16:19 <newsham> samb: i didnt learn a single functional language in CS
10:16:24 <dcoutts_> SamB: indeed, not all of them are on #haskell, but a few are
10:16:43 <newsham> (but I wouldnt throw away the degree because of that, still good stuff)
10:16:44 <daf> SamB: agreed (knowing Haskell is a better measure than a CS degree)
10:16:46 <SamB> the ones in #haskell probably learned way more on their own ?
10:17:00 <daf> but that's not really saying much. lots of things are better indicators than CS degrees.
10:17:14 <SamB> yeah
10:17:27 <dcoutts_> SamB: of course, but being shown it on a course is a good start for learning it on your own
10:17:29 <byorgey> dcoutts_: oh, that's sneaky. looks like I installed a previous version of it globally as root, and so now it can't create a subdirectory of colour/ when not running as root.
10:17:38 <byorgey> wonder why I've never run into this before.
10:17:40 <dcoutts_> byorgey: ahh
10:17:49 <SamB> dcoutts_: could be!
10:17:51 <daf> I think being exposed to Miranda did have an influence
10:17:55 <byorgey> I guess this is probably why I should use --root-cmd instead of running cabal with sudo, eh?
10:17:58 <SamB> if it doesn't make you hate the language ;-)
10:17:59 <daf> (on me)
10:18:05 <dcoutts_> SamB: I probably would not have got into Haskell had I not been shown it in my first term on a CS degree
10:18:15 <SamB> huh
10:18:16 <mbac> i've interviewed people with CS degrees who can't tell me the decimal representation of binary string 1011, in any encoding
10:18:23 <dcoutts_> SamB: true, most of the class hated it, I was one of the people who didn't
10:18:35 <SamB> us americans have to find it on our own
10:18:50 <dcoutts_> probably why there are fewer
10:18:57 <Adamant> SamB - not all of us
10:19:03 <newsham> mbac: I think you may have an overly pessimistic view of computer education.
10:19:06 <Adamant> it's standard for UTexas students
10:19:06 <SamB> seriously ?
10:19:07 <Adamant> or was
10:19:10 <daf> dcoutts_: I had a similar experience :)
10:19:19 <mbac> newsham, my experience is what it is ;)
10:19:20 <vixey> mbac, not at all surprising
10:19:28 <Adamant> I'm doing Haskell in a Comparative Language class
10:19:29 <newsham> not everyone who comes out of the system is well suited for computer work, but there's lots of people who make something of their education
10:19:35 <vixey> mbac, I have extremly low view of CS education after what I've been through :/
10:19:57 <SamB> see, this is why I'm an EE major
10:20:06 <daf> newsham: agreed. a degree may not be a strong positive statement, but it's not a negative one either.
10:20:17 <newsham> samb: to make sure you learn how to interpret 1011 in several different encodings?
10:20:31 <SamB> no! because I thought CS would be too boooring
10:20:36 <mbac> haha
10:20:39 <SamB> or interesting in exactly the wrong way
10:20:39 <Adamant> a degree is like a really decent certification if it comes from at least on OK school
10:20:45 <newsham> its true that EE is plenty interesting :)
10:20:53 <newsham> but there are lots of neat subjects in CS too
10:21:00 <SamB> sure!
10:21:05 <vixey> what's EE
10:21:11 <SamB> but do they teach any of them to undergrads ?
10:21:11 <newsham> (my undergrad is EE, my grad is CS, btw)
10:21:11 <vixey> is that like building robots?
10:21:12 <Adamant> Electrical Engineering
10:21:22 <Adamant> vixey: part of it
10:21:28 <altmattr> I want to write code that has not bools
10:21:40 <SamB> do you suppose I can do EE *and* CS in gradschool ?
10:21:43 <newsham> vixey: the line between EE and CS varies a bit between schools.
10:21:47 <altmattr> import Prelude hiding (Bool(..)) is not doing the trick
10:22:00 <newsham> samb: sure, in some schools they're packaged together
10:22:06 <altmattr> hpaste is down, where to instead
10:22:14 <Adamant> SamB - sure, if you're willing to handle the workload and delayed graduation
10:22:14 <SamB> they say I can't do CPU design for undergrad credit here :-(
10:22:34 <Adamant> or you could do a custom combo degree at some schools
10:22:52 <SamB> what, I have to do them at the same time ?
10:22:54 <Olathe> If I have a function zomg that uses error, what is a good name for an equivalent function that uses fail ?
10:23:04 <Adamant> SamB: nope
10:23:04 <altmattr> :)
10:23:25 <Botje> Olathe: onoes?
10:23:28 <Olathe> @type fail
10:23:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:23:34 <Olathe> Bah.
10:24:34 <SamB> huh, why is it that having LHC spew ANSI-colored debugging data through a tee leaves screen(1) the most heavily-loaded ?
10:24:34 <yitz> @where hpaste2
10:24:35 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
10:24:54 <SamB> more heavily loaded than either urxvt or X
10:25:08 <yitz> altmattr: ^^
10:25:12 <SamB> or lhc, even
10:25:15 <SamB> when it's spewing
10:25:47 <mbac> samb, i don't believe you
10:25:57 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1086#a1086
10:26:04 <yitz> Olathe: don't use fail
10:26:09 <altmattr> I can't get bool to go away
10:26:12 <altmattr> yitz: thanks
10:26:29 <vixey> altmattr, Bool is away
10:26:59 <altmattr> vixey: ?
10:27:07 <SamB> mbac: about what ?
10:27:10 <vixey> what does "?" mean
10:27:26 <mbac> samb, screen being most heavily loaded
10:27:28 <SamB> vixey: alone, it indicates puzzlement
10:27:33 <SamB> mbac: it was!
10:27:46 <vixey> I wish people would be more specific
10:27:59 <altmattr> vixey: what do you mean "Bool is away"
10:28:20 <vixey> altmattr, in your paste
10:28:21 <Olathe> yitz: Why not ?
10:28:21 <SamB> you'd think it would take more CPU to emulate a terminal and actually render the text than to just emulate a terminal and pass it on, wouldn't you ?
10:28:54 <yitz> Olathe: "fail" is misnamed - it's not for general failure
10:29:08 <altmattr> vixey: I am still not following you
10:29:12 <yitz> Olathe: it tells a monad what to do when a pattern match fails in do notation
10:29:28 <SamB> Olathe: it's also in the wrong classs
10:29:34 <yitz> Olathe: in practice - it's either mzero if there's a MonadPlus instance, otherwise error
10:29:48 <yitz> SamB: right, for it shouldn't be there.
10:30:00 <SamB> yitz: or, at least, mzero is essentially a fail
10:30:48 <daf> SamB: well, screen does do some translation
10:31:02 <methos> hello! have a problem: in an "command:: IO String" function i try to return the result of the recursive call using "return command" but i get an "occurs check" error using ghci, so I think it tries to return the function (thus recursion in the type infer system) rather than call and return the _result_. How can i specify to return the result?
10:31:20 <Botje> don't use return
10:31:30 <Botje> just "command"
10:31:59 <Botje> return command turns your IO String into an IO (IO String)
10:32:00 <SamB> methos: return isn't what you think it is
10:32:02 <asgaroth> methos: return doesn't do what you think it does: It lifts a value into the monad, since command already is in there you don't need it
10:32:04 <yitz> Olathe: if you want monadic failure and Maybe or MonadPlus aren't good enough, you can use Control.Monad.Error stuff
10:32:14 <methos> ah okay
10:32:22 <zachk> wow that fmap works like a charm :D
10:32:24 <methos> it though i need to wrap the result into one
10:32:31 <methos> thx
10:34:56 <luqui> methos, eg. you would need to:  { r <- command; return r },  but that's just the same as "command" :-)
10:35:48 <methos> hehe got it working now, i was confused because i had two branches: 1 with the recursion where i mustnt use return and one just like you wrote where i need to use return
10:35:59 <methos> ^^
10:41:28 <hackage> Uploaded to hackage: gofer-prelude 2.30
10:51:30 <Axman6> ?users
10:51:30 <lambdabot> Maximum users seen in #haskell: 658, currently: 639 (97.1%), active: 17 (2.7%)
10:51:34 <zachk> sweetness my sheep breeding was a success, but uh taking the cartesian product of 4 lists in the list monad, is producing way too many results D:
11:03:47 * SamB wonders about the difference between "enhancement" and "task" ticket types
11:06:11 <yitz> SamB: probably "task" doesn't directly affect the software - fix the web site, rearrange the source tree in darcs, etc.
11:06:25 <SamB> ah.
11:07:36 <Axman6> ok, unsafeRead, unsafeWrite and -fexcess-precision have cut my n-bodies runtime in half. time to sleep
11:07:59 <yitz> Axman6: wow. cool.
11:08:05 <Axman6> i know :)
11:08:18 <Axman6> still a lot slower than the current one though
11:12:11 <Olathe> Is there a symbolic operator form of fmap ?
11:12:21 <vixey> .
11:12:32 <Olathe> Haha
11:12:45 <Olathe> IO doesn't like that.
11:12:47 <monochrom> Squiggol has one too.
11:13:24 <monochrom> Squiggol "f / xs" is Haskell "map f xs" IIRC
11:13:35 <Olathe> Ahh, tried some randomly and got it.
11:13:40 <Olathe> @src (<$>)
11:13:40 <lambdabot> f <$> a = fmap f a
11:14:06 <monochrom> Not sure if it has the right type.
11:14:10 <monochrom> @type <$>
11:14:11 <lambdabot> parse error on input `<$>'
11:14:17 <monochrom> @type (<$>)
11:14:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:14:24 <monochrom> OK it's perfect.
11:14:47 <FunctorSalad_> when exactly is a strict argument of a function f evaluated? if the (f x) itself never gets evaluated, then x won't either I suppose
11:14:56 <beelsebo_> FunctorSalad_: indeed
11:15:20 <beelsebo_> a bang patterned argument will get evaluated to WHNF when it's pattern matched against
11:15:21 <beelsebo_> IIRC
11:16:37 <FunctorSalad_> I'm confused because I have a "foldl' (++) concat" taking up all the time according ot the profiler, but I don't understand whether the actual concatenation takes time or the evaluation of the concatenees
11:16:38 <monochrom> correct
11:16:49 <FunctorSalad_> err "foldl' (++) []"
11:17:00 <vixey> why are you foldl'ing o_o
11:17:15 <monochrom> (++) is best used with foldr.
11:17:20 <vixey> > (foldl' (++) [] ["foo","bar","baz"],foldr (++) [] ["foo","bar","baz"])
11:17:21 <lambdabot>   ("foobarbaz","foobarbaz")
11:17:30 <vixey> > foldl' (++) [] (cycle ["foo","bar","baz"])
11:17:40 <vixey> > foldr (++) [] (cycle ["foo","bar","baz"])
11:17:47 <lambdabot>   thread killed
11:17:59 <lambdabot>   "foobarbazfoobarbazfoobarbazfoobarbazfoobarbazfoobarbazfoobarbazfoobarbazfo...
11:18:06 <dcoutts_> gwern, dons: http://hackage.haskell.org/trac/hackage/ticket/262#comment:14
11:18:13 <int-e> @src concat
11:18:13 <lambdabot> concat = foldr (++) []
11:18:33 <monochrom> foldl' (++) [] does not eagerize the whole list anyway.
11:19:40 <saml> > foldr (++) [] [[x], [y], [z]] :: [Expr]
11:19:41 <lambdabot>   [x,y,z]
11:19:49 <saml> > foldr (f) [] [[x], [y], [z]] :: [Expr]
11:19:50 <lambdabot>       No instance for (SimpleReflect.FromExpr [Expr])
11:19:50 <lambdabot>        arising from a u...
11:19:59 <FunctorSalad_> there's probably some better way for subtracting a union of lists from a list ;) maybe Data.Set
11:20:35 <monochrom> > head (foldl' (++) [] ["hello", ' ':undefined])
11:20:36 <lambdabot>   'h'
11:20:52 <monochrom> This shows that foldl' (++) still does not force the whole answer.
11:20:53 <FunctorSalad_> huh? :)
11:21:17 <FunctorSalad_> oh, I missed the "head" there
11:21:34 <vixey> yes @ Data.Set
11:21:45 <monochrom> > seq ('c':undefined) "good"
11:21:46 <lambdabot>   "good"
11:22:07 <monochrom> This shows that seqing a list only seqs the first cons cell.
11:22:15 <monochrom> foldl' uses seq only.
11:22:30 <vixey> > seq (foldl1 seq ('c':undefined)) "bad"
11:22:31 <lambdabot>   "* Exception: Prelude.undefined
11:23:01 <int-e> > seq (undefined : undefined) "good, too"
11:23:02 <lambdabot>   "good, too"
11:23:24 <monochrom> So foldl' (++) is totally pointless. It is not eager enough. It is slower and bloater.
11:24:21 <monochrom> Do we have rnf or the like on lambdabot?
11:24:26 <monochrom> > rnf "hello"
11:24:27 <lambdabot>   ()
11:24:36 <idnar> @type rnf
11:24:38 <lambdabot> forall a. (NFData a) => a -> Done
11:24:45 <monochrom> Actually good enough.
11:24:49 <FunctorSalad_> ok, I'll think about how to rewrite the thing...
11:24:55 <monochrom> > rnf ('c':undefined)
11:24:56 <lambdabot>   * Exception: Prelude.undefined
11:25:14 <monochrom> rnf actually eagerizes the whole list. seq doesn't.
11:25:26 <idnar> how do you use that, rnf foo `seq` foo or something?
11:25:57 <monochrom> That's one use. There ought to be a derivative of rnf that returns the answer.
11:26:06 <int-e> idnar: yep
11:26:08 <SamB> idnar: that would be one way, yes
11:27:00 <FunctorSalad_> monochrom: I think you were right, using plain "concat" it still stack overflows, but faster ;)
11:27:09 <int-e> idnar: it also works with `par` ... rnf a `par` rnf b `pseq` (a,b)
11:27:29 <idnar> int-e: oooooh
11:28:13 <monochrom> concat does not stackoverflow. If you get stackoverflow, it is some other cause.
11:29:30 <monochrom> (concat blah) is provably O(1)-memory plus whatever blah costs.
11:29:53 <monochrom> Even (rnf (concat blah)), to be precise.
11:30:26 <FunctorSalad_> how would I go about finding the actual cause? :(
11:30:31 <monochrom> > "hello" `using` rnf
11:30:32 <lambdabot>   "hello"
11:30:41 <monochrom> > ('c':undefined) `using` rnf
11:30:43 <lambdabot>   "* Exception: Prelude.undefined
11:30:49 <vixey> :t using
11:30:50 <lambdabot> forall a. a -> Strategy a -> a
11:30:51 <monochrom> That is a common use of rnf.
11:31:04 <Gracenotes> @hoogle Strategy
11:31:05 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
11:31:05 <lambdabot> package StrategyLib
11:31:23 <monochrom> Prove the cost of blah. Prove the cost of the caller of (concat blah).
11:31:58 <FunctorSalad_> I'm obviously lacking knowledge about evaluation and the normal forms
11:32:35 <Saizan_> what's blah in your case?
11:33:00 <monochrom> oops, (rnf (concat blah)) is not O(1) memory.
11:33:26 <int-e> > [1..] !! 300000
11:33:26 <monochrom> But this is O(1)-memory (plus cost of blah): putStrLn (concat blah).
11:33:27 <lambdabot>   * Exception: stack overflow
11:33:37 <int-e> > [1..1000000] !! 300000
11:33:38 <lambdabot>   300001
11:34:50 * shapr boings quietly
11:34:59 <idnar> huh?
11:35:04 <idnar> why doesn't that second one overflow?
11:35:10 * int-e throws a bunch of sugar lambdas at shapr
11:35:31 <FunctorSalad_> Saizan_: a catMaybes of some thousand lists containing some hundred Vec3Ds. I have no idea whether the overflow even occurs there or in the calculation of these vectors
11:35:32 <Saizan_> monochrom: (rnf (concat blah)) is still O(1) stack, though
11:35:49 <int-e> idnar: because each element of the list is compared to 1000000 before it's produced, avoiding the stack overflow evaluating a huge (((1+1)+...)+1)+1 term
11:36:06 <int-e> idnar: !! itself is fine.
11:36:13 <monochrom> subtle!
11:36:32 <monochrom> blame analysis for haskell inefficiency is subtle!
11:36:53 <Saizan_> FunctorSalad_: i'd say the latter
11:36:56 <mbac> good heavens, xmobar's CPU and MEM plugins don't know how to deal with FreeBSD
11:36:57 <monochrom> "why is it more efficient than I thought!"
11:36:58 * mbac patch
11:36:59 <idnar> int-e: ah
11:37:02 <rwbarton> , [1..] !! 300000
11:37:04 <lunabot>  300001
11:37:07 <rwbarton> fixed in 6.10
11:37:43 <idnar> > (filter (>0 [1..]) !! 300000
11:37:44 <lambdabot>   <no location info>: parse error on input `;'
11:37:45 <idnar> oops
11:37:48 <int-e> or fixed by optimization?
11:37:51 <idnar> > (filter (>0) [1..]) !! 300000
11:37:52 <lambdabot>   300001
11:38:15 <rwbarton> No, I think the sematics actually changed to be more in line with the report
11:38:19 <shapr> int-e: mm, tasty!
11:38:20 <rwbarton> > [undefined..]
11:38:21 <lambdabot>   * Exception: Prelude.undefined
11:38:31 <int-e> , [1..] !! 1000000
11:38:32 <lunabot>  1000001
11:38:42 <rwbarton> > null [undefined..]
11:38:43 <lambdabot>   Add a type signature
11:38:54 <rwbarton> > null [undefined::Integer..]
11:38:55 <lambdabot>   <no location info>: parse error on input `Integer..'
11:38:58 <rwbarton> > null [undefined::Integer ..]
11:39:00 <lambdabot>   False
11:39:00 <FunctorSalad_> Saizan_: if I remove the concatenation, it works... (I know that the vectors still are calculated for a different part of the output)
11:39:03 <rwbarton> , null [undefined::Integer ..]
11:39:04 <lunabot>  luna: Prelude.undefined
11:40:44 <monochrom> FunctorSalad_: The caller is also important.
11:41:16 <Saizan_> yeah, how those lists are consumed can be determinant, like in the [1..] example by int-e
11:41:28 <hackage> Uploaded to hackage: regex-xmlschema 0.1.2
11:41:49 <int-e> , iterate succ 0 !! 300000
11:41:50 <lunabot>  300000
11:41:54 <int-e> , iterate succ 0 !! 3000000
11:41:56 <lunabot>  Stack space overflow: current size 8388608 bytes.
11:41:56 <lunabot>  Use `+RTS -Ksize' to increase it.
11:42:27 <rwbarton> hmm
11:42:35 <int-e> , [1..] !! 3000000
11:42:37 <lunabot>  3000001
11:43:03 <FunctorSalad_> should I make everything in the calculation strict so it is done before the outputter even starts?
11:43:39 <int-e> rwbarton: right. http://hackage.haskell.org/trac/ghc/ticket/1997
11:46:21 <monochrom> FunctorSalad_: number crunching should be eager. list production (cons cells) should be lazy.
11:47:12 <monochrom> (foldl' (+) 0 xs) is good. (foldr (++) [] ys) is good.
11:47:26 <alsonk_> @seen dons
11:47:26 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1h 42m 59s ago.
11:47:52 <monochrom> Of course there are also exceptions, depending on how perverted you are.
11:48:16 <sereven> mbac: http://dzen.geekmode.org/dwiki/doku.php?id=dzen:openbsd-example-statusbar -- maybe solution could be adapt from this script using {Pipe,Command,Stdin} Or fix plugins :-]
11:48:49 <sereven> meh... {Pipe,Command,Stdin}Reader that is
11:48:55 <centrinia> If I represent my natural numbers by lists of units, should I sum them up using strict or lazy evaluation? :)
11:49:34 <Olathe> ...
11:49:45 <Olathe> Someone decided that <$> and . should have the same precedence.
11:49:47 <centrinia> > replicate 4 ()
11:49:48 <lambdabot>   [(),(),(),()]
11:49:49 <|jedai|> centrinia: probably lazy (with foldr)
11:50:19 <glguy> lazy, since you don't do number crunching with numbers represented in that way :)
11:50:21 <centrinia> But that's number crunching. ;)
11:50:41 <vixey> let (+) = (++)
11:50:44 <centrinia> Why don't you do number crunching with unary numbers?
11:50:46 <glguy> those are reserved for fooling around and feeling clever :)
11:50:49 <mbac> sereven: maybe!
11:51:09 <vixey> one good thing about lazy numbers
11:51:21 <vixey> > genericLength [1..10] < infinity
11:51:22 <lambdabot>   True
11:51:26 <rwbarton> > [(),(),(),()] \\ [(),(),()]
11:51:27 <lambdabot>   [()]
11:51:37 <vixey> > genericLength [1..] > (10 :: Natural)
11:51:38 <lambdabot>   True
11:51:57 <monochrom> There is no gain in eagerizing the unary representation.
11:52:46 <rwbarton> > infinity - infinity
11:53:01 <lambdabot>   thread killed
11:53:03 <SamB> > infinity
11:53:04 <lambdabot>   * Exception: stack overflow
11:53:06 <monochrom> The bottomline is proof of efficiency. Always prove the cost of your strategy.
11:53:24 <SamB> :t infinity
11:53:25 <lambdabot> Natural
11:53:30 <SamB> @src Natural
11:53:30 <lambdabot> Source not found. Where did you learn to type?
11:53:35 <SamB> @src infinity
11:53:35 <lambdabot> Source not found. Just try something else.
11:53:38 <SamB> @hoogle Natural
11:53:39 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
11:53:39 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
11:53:39 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
11:53:41 <Olathe> This is even better: cannot mix `(.)' [infixr 9] and `(<$>)' [infixl 9] in the same infix expression ... Control.Applicative> (+1).(+2) <$> Just 5 ... Just 8
11:53:45 <SamB> aww ...
11:53:50 <vixey> data Natural = Zero | Succ Natural
11:53:53 <vixey> infinity = fix Succ
11:54:03 <SamB> > 142 :: Natural
11:54:04 <lambdabot>   142
11:54:08 <SamB> oh, no wonder
11:54:10 <ddarius> Olathe: Just replace you uses of (.) with (<$>)
11:54:17 <yitz> centrinia: there are a few laziness trade-off issues with lazy natural numbers. search cafe for John Meacham'
11:54:18 <SamB> it was trying to figure out the first digit ;-P
11:54:22 <yitz> s posts about this.
11:54:24 <Olathe> How in the world does ghci know how to handle (.) and (<$>) in the same infix expression, but ghc doesn't ?
11:54:55 <SamB> Olathe: with the same imports ?
11:55:17 <monochrom> "what are the rules of thumb for writing efficient programs?" that is the same as "what are the rules of thumb for writing bugless programs?"  Here is the only rule of thumb: don't write any programs, then you will consume no memory, no cycle, and introduce no bug.
11:55:35 <rwbarton> <$> is infixl 4 for me...
11:55:40 <Olathe> Yes. The file has import Control.Applicative ((<$>))
11:55:59 <vixey> hehe
11:56:09 <Olathe> Yes, it has 4 in ghci here, too.
11:56:16 <Olathe> But not in GHC.
11:56:21 <SamB> Olathe: what have you imported in GHCi ?
11:56:27 <SamB> and what (.) is it ?
11:56:35 <Olathe> Control.Applicative
11:56:46 <Olathe> (.) :: (b -> c) -> (a -> b) -> a -> c -- Defined in GHC.Base
11:56:52 <SamB> hmm.
11:57:09 <SamB> so not the one from Control.Category, then
11:57:35 <rwbarton> I guess in theory some bozo might have written "infixr 9 ." in one of the other modules you've imported?
11:57:45 <rwbarton> er, infixl 9 <$> rather
11:58:00 <rwbarton> or does that declaration have to go with the definition?
11:58:10 <Saizan_> what's the default fixity?
11:58:15 <ddarius> infixl 9
11:58:16 <yitz> 9
11:58:44 <Olathe> rwbarton: That's possible.
11:59:00 <beelsebo_> Does anyone know how active the people developing on HoC are?
11:59:08 <Saizan_> so maybe the infixl declaration is not yet considered at the point of that error due to a bug
12:00:15 <ddarius> > let (*) = undefined in (* $)
12:00:16 <lambdabot>   <no location info>: parse error on input `$'
12:00:21 <yitz> Olathe: are you sure that the ghci you are running corresponds to the same copy of ghc?
12:00:30 <ddarius> > let (*) = undefined in (1 * 3 $)
12:00:32 <lambdabot>       Overlapping instances for Show (a -> b)
12:00:32 <lambdabot>        arising from a use of `s...
12:00:50 <ddarius> > let (*) = undefined in (1 * 3 *)
12:00:51 <lambdabot>   * Exception: Prelude.undefined
12:01:03 <ddarius> > let (*) = undefined in (1 * 3 .)
12:01:05 <lambdabot>       Overlapping instances for Show ((a -> b) -> a -> c)
12:01:05 <lambdabot>        arising from...
12:01:24 <Olathe> yitz: Yes.
12:01:28 <ddarius> > let (*) = undefined in ($ 1 * 3)
12:01:29 <lambdabot>       Overlapping instances for Show ((a -> b) -> b)
12:01:29 <lambdabot>        arising from a us...
12:02:17 <Olathe> What's the default precedence ?
12:02:19 <rwbarton> Olathe: Does it happen if you do the same thing in a tiny test program?  I can't reproduce it.
12:03:22 <Olathe> Ahh, I see.
12:03:43 <Olathe> It happens in an older version of the file without the import.
12:04:15 <rwbarton> oh, you get that error before the "not in scope" error
12:04:20 <Olathe> Yes.
12:04:29 <rwbarton> I hate it when ghc does that kind of thing
12:04:43 <Olathe> Yeah :|
12:05:01 <yitz> Olathe: I think you should file an issue for that then.
12:05:24 <rwbarton> like just today, there was an error message pasted where ghc complained that the kind of a type class parameter was wrong, when it would have been more helpful to point out that the number of parameters was wrong.
12:05:43 <Heffalump> SPJ is keen to improve error messages
12:05:55 <dons> hey guys, a new post, on the Gofer (aka ~Haskell 1.2) standard prelude, http://donsbot.wordpress.com/2009/01/31/reviving-the-gofer-standard-prelude-circa-1994/
12:06:28 <yitz> rwbarton: that's less of a bug. It's another way of saying the same thing, sort of. It's just far less clear if you're not used to it.
12:07:04 <vixey> wow m*n+k patterns
12:07:17 <rwbarton> Kind of but not really... the wording didn't say anything about the kind of the type class itself
12:07:37 <yitz> rwbarton Heffalump Olathe so then both of those should be filed as issues
12:09:37 <monochrom> The ideal error message is "the kind is wrong OR the number of parameters is wrong OR the parenthesizing is wrong OR the spelling is wrong OR you don't mean typeclass OR you don't mean instance OR it should be a function OR it should be a newtype OR you forgot to save your files OR you forgot to checkout the right version of your files OR ghc has a bug. Main menu: press 1 for kind error. press 2 for parameter error. ... press
12:09:37 <monochrom>  8 for ghc bug. press 9 for a service representative"
12:09:45 <vixey> hahaha
12:10:11 <monochrom> (And yes, I'm being sarcastic about the whole notion of "better error messages". There is none.)
12:10:18 <mmorrow> @source , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in
12:10:18 <lambdabot> , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
12:10:19 <lunabot>  @source , let not = text . (++" in") . ap(++)show; available = "@source ,...
12:10:40 <mmorrow> if only there were two lambdabots in here
12:10:44 <vixey> , let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
12:10:45 <lunabot>  @source , let not = text . (++" in") . ap(++)show; available = "@source ,...
12:10:46 <mmorrow> @source > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in
12:10:46 <yitz> monochrom: given a choice, the error message should be worded in terms of the simplest concept
12:10:46 <lambdabot> > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
12:10:49 <SamB> rwbarton: I guess it ideally would have noticed both issues
12:10:58 <mmorrow> > let not = text . (++" in") . ap(++)show; available = "@source , let not = text . (++\" in\") . ap(++)show; available = " in not available
12:10:59 <lambdabot>   @source , let not = text . (++" in") . ap(++)show; available = "@source , l...
12:11:00 <rwbarton> It's just a matter of checking things in a more human-friendly order.
12:11:05 <rwbarton> SamB: Sure.
12:11:26 <SamB> and yeah, if it's got to be one or the other, checking number of args before their kinds would be best
12:11:48 <glguy> the "simplest concept" approach is why recursive type errors in ghc 6.10 seem to be so useless
12:11:51 <rwbarton> OK, I'll file a ticket
12:11:59 <yitz> rwbarton: it's worse than that. a fixity error for a symbol not in scope just doesn't make sense
12:12:03 <SamB> glguy: what do they say ?
12:12:07 <mmorrow> (sclv noticed the "bug" in @src last night)
12:12:11 <glguy> SamB, they throw out the context
12:12:15 <SamB> yitz: sure they do
12:12:16 <glguy> SamB, and just tell you the recursive type
12:12:20 <vixey> Have you seen Conor McBrides type checker for lambda calculus in Epigram?
12:12:30 <SamB> yitz: I'm not sure the compiler can tell they aren't in scope before it resolves the fixity?
12:12:30 <glguy> SamB, try   callCC callCC   in 6.8 and 6.10
12:12:39 <SamB> > callCC callCC
12:12:39 <mmorrow> vixey: no
12:12:39 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> m b
12:12:40 <lambdabot>        E...
12:12:44 <SamB> :t callCC callCC
12:12:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
12:12:45 <lambdabot>       Expected type: ((a -> m b) -> m a) -> m (a -> m b)
12:12:45 <lambdabot>       Inferred type: ((a -> m b) -> m a) -> m a
12:12:57 <glguy> that's the 6.8 errror
12:13:03 <vixey> I really like the approach... instead of type errors being a String or something, it's a proof that no well typed term exists
12:13:04 <SamB> I figured
12:13:08 <SamB> it looks familiar
12:13:11 <SamB> , callCC callCC
12:13:12 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = b -> m b1
12:13:19 <rwbarton>       Expected type: m (b -> m b1)
12:13:19 <SamB> her too ?
12:13:19 <rwbarton>       Inferred type: m b
12:13:27 <rwbarton> (the rest of the message)
12:13:27 <glguy> that's the broken error
12:13:28 <vixey> so from the refutation you can build an error message
12:13:33 <yitz> SamB: why not? you don't need fixity to parse the defined names in declarations and imports.
12:13:43 <vixey> I think it's in View From The Left
12:13:44 <SamB> yitz: are you sure ?
12:13:45 <mmorrow> vixey: interesting
12:13:54 * SamB may have to check the report
12:13:56 <vixey> depedently typed error messages seems like a great idea
12:14:09 <vixey> because you can't just throw errors that don't make sense
12:14:22 <|jedai|> @src replicate
12:14:22 <lambdabot> replicate n x = take n (repeat x)
12:14:23 <SamB> hehe, yeah, they have to be proven
12:14:33 <|jedai|> @src repeat
12:14:33 <lambdabot> repeat x = xs where xs = x : xs
12:14:35 <SamB> a little rough to get your compiler to compile, though
12:14:38 <yitz> SamB: well, there's the "maximal munch" rule gone wild, but the report recommends just rejecting such things
12:15:08 <SamB> I thought that was a lexing rule
12:15:19 <tehgeekmeister> asked this before but i can't find it in my logs, how do i build local copies of the documentation for packages i've gotten from hackage/included in the standard distribution?
12:15:31 <yitz> @pl replicate n x = take n (repeat x)
12:15:31 <lambdabot> replicate = (. repeat) . take
12:17:00 <dons> hey guys, the jane street capital summer projects this year are now open to other languages,
12:17:03 <dons>  http://www.haskell.org/pipermail/haskell/2009-January/020988.html
12:17:07 <dons> i think they'd like a ocaml <-> haskell interop...
12:18:16 <SamB> tehgeekmeister: you apparantly can't build the docs for all of GHC's core libraries without building GHC
12:18:38 <yitz> dons: has anyone worked on (oca)ml <-> haskell interop before?
12:18:50 <tehgeekmeister> SamB: are they normally included by default?  or is there somewhere i can just download a tarball of them already built?
12:18:52 <SamB> at least, when I suggested that they regenerate the GHC 6.10.current library documentation with Source links, they said they'd need to build GHC 6.10.current
12:19:02 <SamB> tehgeekmeister: there should be a tarball
12:19:15 <tehgeekmeister> i'd like to have a full copy of  the documentation for offline programming
12:19:24 <tehgeekmeister> since i seem to be sans internet semi often these days
12:19:34 <Olathe> OK, I've reported it: http://hackage.haskell.org/trac/ghc/ticket/2993
12:19:45 <yitz> tehgeekmeister: use wget
12:19:53 <dons> yitz: galois has a ocaml <-> polyml interop, but could use a haskell one too
12:19:57 <tehgeekmeister> yitz: no one minds that?  okay.
12:20:28 <tehgeekmeister> for packages i'm downloading tho, sometimes the documentation is incomplete on hackage
12:20:40 <tehgeekmeister> (takusen .8.3 is missing parts of it's documentation, for example)
12:20:49 <yitz> tehgeekmeister: can't imagine anyone would mind for a legit use like that. try to be careful though, of course.
12:20:52 <tehgeekmeister> so i'd like to know how to build local copies as well
12:21:10 <tehgeekmeister> yitz: oh of course, i'll use sane options and not wget all of haskell.org.  =P
12:21:31 <SamB> tehgeekmeister: what do you mean, missing parts ?
12:21:33 <SamB> what is missing ?
12:21:37 <yitz> tehgeekmeister: or run a script that accidentally wgets 1000 times
12:21:53 <tehgeekmeister> SamB: http://hackage.haskell.org/packages/archive/Takusen/0.8.3/doc/html/Database-PostgreSQL-Enumerator.html
12:22:19 <tehgeekmeister> SamB: can't look at the psql specific functions in takusen, which (so far as i can tell thus far) means i can't find out how to make a connection
12:23:47 <SamB> you mean the file is just missing ?
12:23:57 <yitz> dons: sounds like polyml is a much better impedance match
12:24:01 <tehgeekmeister> SamB: yep, it's linked to from the hackage page
12:24:23 <tehgeekmeister> SamB: but other parts of the documentation are there.
12:24:28 <SamB> okay, well, cabal haddock should help ...
12:24:29 <yitz> dons: (for ocaml)
12:25:22 <SamB> tehgeekmeister: http://haskell.org/haskellwiki/GHC has docs for offline use
12:25:23 <monochrom> tehgeekmeister: http://haskell.org/haskellwiki/GHC has tarballs of ghc docs.
12:26:37 * monochrom thinks it would be more parallel to call them "the user's guide", "the standard libraries", "the cabal"
12:26:55 <tehgeekmeister> SamB, monochrom: the standard libraries tarball there is 6.8
12:26:55 <Gracenotes> @hoogle Int -> IO ()
12:26:55 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
12:26:55 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
12:26:55 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
12:27:13 <SamB> tehgeekmeister: oh ???
12:27:19 <monochrom> that is really too bad.
12:27:22 <SamB> Igloo: dcoutts: what's with that ?
12:27:26 <Olathe> @src (^)
12:27:27 <lambdabot> x ^ 0            =  1
12:27:27 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:27:27 <lambdabot>   where f _ 0 y = y
12:27:27 <lambdabot>         f x n y = g x n
12:27:27 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
12:27:29 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:27:31 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:27:38 <tehgeekmeister> is there much difference between the two? i JUST upgraded to 6.10 today.
12:28:07 <monochrom> I don't know. Oh, Control.Exception has big difference, that's the famous one.
12:28:16 <SamB> wait, uh, I think they have both
12:28:47 <SamB> the 6.8 ones perhaps have source links ?
12:29:20 <tehgeekmeister> i found a tarball of the latest docs.
12:29:22 <tehgeekmeister> http://www.haskell.org/ghc/docs/latest/
12:29:33 <SamB> http://www.haskell.org/ghc/docs/latest/libraries.html.tar.gz
12:29:36 <SamB> http://www.haskell.org/ghc/docs/latest/libraries.html-haddock2.tgz
12:29:42 <SamB> both are linked from that page
12:29:47 <dons> yitz: but haskell is more useful (more libs, more parrrrallelism)
12:30:08 <monochrom> neato
12:30:10 <SamB> the latter as "GHC 6.8 haddock 2 HTML.tar.gz"
12:32:11 <tehgeekmeister> still, what's the command i use/what do i need to google/look at documentation for to know how to build documentation for packages i've built?  until i can get the full docs for takusen i can't start hacking for the day.  =P
12:32:59 <rwbarton> tehgeekmeister: add the line   documentation: True  to your .cabal/config for the future
12:34:01 <boldt> Hallo, jemand frei der mir bitte eine Haskell Aufgabe machen kann, dann bitte anschreiben :-)
12:34:27 <tehgeekmeister> so echo "documentation: True" > ~/.cabal/config would do what you mean? or do you mean editing the cabal files of each package as i build them?
12:34:45 <rwbarton> tehgeekmeister: and for packages you already have installed you can do  cabal install foo --reinstall --documentation, I guess, though that might build the package against newer versions of its dependencies
12:34:49 <rwbarton> tehgeekmeister: Right.
12:35:03 <beelsebo_> boldt: this channel is english based â€“ #haskell.de may well exist though
12:35:04 <joga> though using just one '>' will wipe out whatever is there already... ;)
12:35:16 <tehgeekmeister> joga: nothing's there.  =P
12:35:20 <joga> heh
12:35:29 <int80_h> I think boldt is asking for free books on haskell
12:35:30 <yitz> @seen lambdabot
12:35:30 <lambdabot> Yes, I'm here. I'm in #lhc-compiler, #happs, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #
12:35:30 <lambdabot> haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, #macosx, ##freebsd,
12:35:30 <lambdabot>  #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
12:35:31 <rwbarton> tehgeekmeister: then you'll get haddock built in .cabal/share/doc/
12:35:44 <yitz> yep, it's #haskell.de
12:35:50 <int80_h> I german is very very broken...I could be way off
12:35:57 <int80_h> s/I/my
12:36:38 <Olathe> @instances Monad
12:36:38 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:37:52 <warren_> hi... I'm wondering if there's somewhere I could find an example of mmap'ing a file in haskell and overlaying an array of c structures
12:39:06 <sjanssen> what is the point of this "1,000 packages, so let's build a few!" thread on -cafe?  I think Andrew Coppin needs to get a blog
12:39:22 <beelsebo_> sjanssen: I think he was trying to point out that building things on windows is hard
12:39:28 <beelsebo_> but he was rather verbose
12:39:39 <rwbarton> He does have one good suggestion--I also want changelogs for new version uploads
12:39:42 <beelsebo_> in the mean time... yeh, windows makes a lot of things hard
12:39:48 <beelsebo_> rwbarton: that would be nice
12:40:00 <tehgeekmeister> rwbarton: i must have misunderstood something, i created ~/.cabal/config with the line you said, rebuilt the package in question, and there are no docs in ~/.cabal/share, in fact that directory doesn't exist yet.
12:40:04 <dons> he does all the wrong things too though, and doesn't understand how computers work
12:40:16 <dons> sigh
12:40:33 <rwbarton> tehgeekmeister: huh.
12:40:47 <rwbarton> tehgeekmeister: did you look at the output from cabal?  maybe you need to install haddock first?
12:41:07 <dpiponi> Can someone help me with this cabal message "cabal: ghc-pkg describe * failed.". (plus some stuff about ghc-9 which I guess is irrelevant as I have 6.10.1.)
12:41:21 <dons> mmm
12:41:23 <dons> dcoutts: ^
12:41:49 <rwbarton> heh, dpiponi gets sent straight to the top :)
12:41:50 <tehgeekmeister> rwbarton: i don't use cabal, directly.  i do sudo runhaskell Setup.hs config/build/install
12:41:53 <beelsebo_> dons: haha, awesome reply :)
12:42:01 <yitz> warren_: I think youi might need to give more details about what you want to do
12:42:13 <rwbarton> tehgeekmeister: oh, then I think .cabal/config is irrelevant.
12:42:25 <redditbot> Reviving the Gofer Standard Prelude (circa. 1994)
12:42:25 <redditbot> Algebra of programming in Agda: dependent types for relational program derivation
12:42:25 <redditbot> Circular Programs and Self-Referential Structures
12:42:25 <redditbot> Haskell Weekly News: January 31, 2009
12:42:25 <redditbot> Jane Street Summer Project 2009: now open to Haskell!
12:42:27 <rwbarton> tehgeekmeister: you might do sudo runhaskell Setup.hs haddock instead? just a guess
12:42:43 <Badger> it requires sudo? o_O
12:42:52 <tehgeekmeister> Badger: for install, yes
12:42:55 <yitz> rwbarton: dpiponi is already the top. :)
12:42:56 <warren_> I really just want to convince my boss that mmaping large files in haskell is no worse than doing it in C :-)
12:43:10 <Badger> tehgeekmeister: that was for haddockgen, or so it seemed.
12:43:11 <dpiponi> Yeah, I usually use runghc Setup.hs etc. But I thought cabal would be nice to use.
12:43:13 <tehgeekmeister> rwbarton: i'll try that, what about adding the documentation: True line to .cabal files in each package i build?
12:43:34 <beelsebo_> warren_: yeh, the point is though that memory mapping files is probably not what you want to do at all
12:43:46 <tehgeekmeister> Badger: i really only have to sudo to install, but sometimes i do it for configing and building too, out of habit
12:43:51 <warren_> mmap is exactly what he wants
12:44:10 * Badger whacks tehgeekmeister with a cluebat for unnecessary use of privileges :)
12:44:13 <beelsebo_> maybe, but maybe there's *another* thing, that's more haskelly, that *also* does what he wants
12:44:32 <beelsebo_> assembly code does what he wants â€“ doesn't mean it's the way you should do it
12:44:39 <tehgeekmeister> Badger: heh.  i'm lazy, hitting the up arrow makes life easier.  =P
12:44:47 <yitz> beelsebo_: have you ever had a boss?
12:45:03 <tehgeekmeister> rwbarton: it says i don't have haddock; so i assume at this point i just download the version it wants and build haddock?
12:45:04 <beelsebo_> yitz: yep, you listen to what they say, you smile and nod, then you do the oposite
12:45:07 <beelsebo_> :)
12:45:09 <rwbarton> tehgeekmeister: I'd guess .cabal files have separate fields from .cabal/config, but I don't know
12:45:16 <rwbarton> tehgeekmeister: yeah, and make sure it is installed into your path
12:45:23 <tehgeekmeister> okay
12:45:42 <yitz> hah! caught you red-handed!
12:45:58 <beelsebo_s_boss> hah! caught you red-handed!
12:46:02 <tehgeekmeister> wow, the minimum version it wants is six years old.
12:46:06 <tehgeekmeister> *uses newer version
12:46:40 <rwbarton> dpiponi: is it complaining about an empty package.conf?
12:46:40 <newsham> ok, these numbers are broken.  the single cpu and quad cpu numbers are nearly identical.  http://shootout.alioth.debian.org/u64/benchmark.php?test=mandelbrot&lang=all  and http://shootout.alioth.debian.org/u64q/benchmark.php?test=mandelbrot&lang=all
12:46:48 <yitz> warren_: there are a number of approaches, hard to know what is right for you
12:47:00 <beelsebo_> newsham: yep, all the time gets spent in GC
12:47:06 <beelsebo_> and they won't let us tweak the GC settings
12:47:15 <beelsebo_> if you tweak them appropriately the time goes 40s -> 4s
12:47:18 <newsham> beelsebo: how much time did c++ gnu g++ spend in gc?
12:47:29 <dpiponi> rwbarton: ...and have an empty user package database...
12:47:55 <beelsebo_> newsham: oh, I fail at reading today
12:48:05 <dpiponi> rwbarton: I don't know what "register at least one package in the user package db" means
12:48:06 <int80_h> does let always need an in clause?
12:48:13 <dmwit> int80_h: Not in do blocks.
12:48:19 <yitz> warren_: presumably you will still need to interop with some C, besides just mimicking the structs
12:48:20 <newsham> ATS#3 single cpu 3.94sec,  ATS#3 quad cpu 3.94sec (100%/96%/100%/97%)
12:48:21 <warren_> yitz: I understand that if I were to sit down and do this for real, I'd want to analyze the alternatives, but for the moment, I'm just trying to fix a broken assumption that a language like haskell (or it's ffi) cannot be an indexed offset into someone else's memory
12:48:31 <beelsebo_> dmwit: tbf, let has an in clause in a do block, it's just hidden from you
12:48:32 <rwbarton> dpiponi: do you know what path it's trying to read the package.conf from?  (e.g., on my system, ~/.ghc/i386-linux-6.11.20090107/package.conf)
12:49:03 <dpiponi> rwbarton: How do I find that out? At this moment, cabal is just a black box to me.
12:49:11 <monochrom> It seems every year the shootout adds a new stupid rule to add unfairness.
12:49:15 <beelsebo_> I take it no one knows of a HOC mailing list btw?
12:49:21 <rwbarton> dpiponi: what does ghc-pkg list --user output?
12:49:31 <yitz> warren_: it should be easy to write one or two simple demos that use your own structs, or even call your own C funcs via ffi
12:49:31 <ddarius> newsham: Look at -elapsed- seconds.
12:49:37 <ddarius> newsham: They should take the same CPU time.
12:49:41 <newsham> ddarius: ooooohhhh!
12:49:43 <newsham> ty sir.
12:50:02 <rwbarton> dpiponi: (also, did you just upgrade your ghc version?)
12:50:08 <warren_> yitz: yeah... I was hoping to point him at something so I could get back to work
12:50:36 <monochrom> It is high time the GHC runtime includes code to detect "am I running on the shootout?" and turns on appropriate adjustments automatically.
12:50:45 <dpiponi> rwbarton: lots of stuff. Looks like it's split between: /Users/dan/lib/ghc-6.8.1/package.conf and /Users/dan/.ghc/i386-darwin-6.8.1/package.conf (I use 6.10.1)
12:51:11 <newsham> mono: why?
12:51:15 <rwbarton> dpiponi: OK, what I suggest is creating /Users/dan/.ghc/i386-darwin-6.10.1/package.conf containing the string "[]" (without the quotes)
12:51:16 <ddarius> I believe it is trivial to have a bytestring backed by an mmapped file.  From there you can use Data.Binary.
12:51:25 <rwbarton> dpiponi: and try whatever you were doing originally again
12:51:42 <ddarius> monochrom: "Appropriate adjustments" would just output the result immediately.
12:52:16 <monochrom> That would not be subtle enough. :)
12:52:42 <monochrom> Also we like to solve the problem with high generality!
12:52:50 <methos> how can I "discard" a return value? especially I want an ":: IO ()" function (and declared it such) but the last statement is of "IO Something" thus the inference gives me a mismatch
12:53:00 <rwbarton> dpiponi: (But I'm confused that ghc-pkg is giving you 6.8.1 packages, when you say you also have ghc 6.10.1 installed.  Maybe you're running the wrong ghc-pkg?)
12:53:12 <dpiponi> Do I need to do anything to indicate this file now exists? Doing "cabal install HPDF", say, just gives the same message again.
12:53:13 <methos> (and sorry for the newbie questions here, just mention if im bothering :)
12:53:25 <Saizan_> dpiponi: cabal --version ?
12:53:28 <monochrom> We love newbies! We eat them for dinner.
12:53:34 <methos> :P
12:53:40 <dmwit> methos: return ()
12:53:51 <Saizan_> dpiponi: you should upgrade it to 0.6.0 to make it work properly with ghc-6.10.x
12:53:54 <dpiponi> cabal-install version 0.5.2
12:53:54 <yitz> warren_: I'd say write a real simple 5 min. demo of that then
12:54:05 <methos> dmwit: thx!
12:54:06 <monochrom> do { blah; getChar; return () }
12:54:22 <newsham> dpiponi: 1) your blog rules, 2) saw you credited on nova (at first i thought you were on it, but i reviewed it and think i was mistaken), what stuff did you do for the episode?
12:54:27 <warren_> yitz: ok... I guess there are no examples then. Thanks for your input
12:54:41 <Saizan_> dpiponi: if you still have ghc-6.8.1 installed you can run "cabal install -w ghc-6.8.1 cabal-install" to upgrade it
12:54:50 <Saizan_> dpiponi: you might need "cabal update" first
12:54:52 <yitz> warren_: there are actually zillions, but I think it would take longer to find the right one
12:54:54 <dpiponi> Saizan_: You mean like typing cabal install cabal-install?  :-) I'll try a manual build
12:55:45 <dpiponi> newsham: I was filmed for nova. I suggested they film a colleague of mine. They had to make cuts. They liked my colleague more and my bit was self-contained so it was an easy cut to make
12:56:06 <newsham> moral: be less self contained?  ;-)
12:56:23 <yitz> warren_: things like gtk2hs do that like crazy, but it's far from a simple example. :)
12:56:24 <dpiponi> newsham: but if they release a DVD version I should be on that. They were unbelievably apologetic about the cut and the miscrediting.
12:56:42 <newsham> oh, did they title your name in place of your colleague?
12:57:11 <newsham> i coulda swore i saw your name when watching on tv, but i watched online after and it was gone.
12:57:14 <diltsman> Does error throw an exception type that is catchable?
12:57:37 <ddarius> diltsman: Not in Haskell 98.
12:58:01 <diltsman> How would I throw a catchable exception that has a string message?
12:58:05 <warren_> yitz: well, I haven't had time to dig through cabal implementations. Just searching for an example doc or blog post has turned up nothing. I just want to know that the haskell equivalent of arr[i].field is compiled to an offset.
12:58:07 <yitz> ddarius: h98 doesn't specify that
12:58:18 <ddarius> yitz: What would catch it?
12:58:35 <ddarius> diltsman: Use ioError, if you want Haskell 98.
12:59:13 <diltsman> ddarius: what if the code isn't in the IO monad?
12:59:25 <ozy`> :t ioError
12:59:26 <lambdabot> forall a. IOError -> IO a
12:59:39 <ddarius> diltsman: Then Haskell 98 provides you no recourse.
12:59:48 <Deewiant> Egads, m*n+k patterns
12:59:57 <elly> what?
13:00:02 <ddarius> diltsman: Either use a purer approach or use some non-Haskell 98 libraries.
13:00:04 <ozy`> Deewiant: I didn't even know there were m*n patterns....
13:00:05 <elly> m*n+k patterns exist?
13:00:14 <vixey> elly, apparently from Gopher
13:00:15 <ddarius> ozy`: There aren't.
13:00:18 <ddarius> elly: No
13:00:19 <Deewiant> Evidently the precursor of Hugs had em
13:00:21 <diltsman> ddarius: I've been trying to figure out how to use Control.Exception, but I can't figure out how to get around a type problem with the Exception type.
13:00:22 <Deewiant> ( http://donsbot.wordpress.com/2009/01/31/reviving-the-gofer-standard-prelude-circa-1994/ )
13:00:30 <yitz> warren_: look in Foreign.Storable
13:01:27 <newsham> undefined | False      = undefined
13:01:41 <warren_> yitz: will do... thanks
13:01:42 <yitz> ddarius: a compiler is free to do whatever it wants with error
13:01:57 <Deewiant> newsham: I was just busy having my mind blown by that :-)
13:03:59 <ddarius> yitz: "Errors during expression evaluation, denoted by _|_, are indistinguishable by a Haskell program from non-termination. ... A call to error terminates execution of the program and returns an appropriate error indication to the operating system."
13:04:31 <ddarius> Another relevant sentence: "When evaluated, errors cause immediate program termination and cannot be caught by the user."
13:05:30 <int80_h> @src divides
13:05:30 <lambdabot> Source not found. stty: unknown mode: doofus
13:05:39 <lament> 'indistinguishable from non-termination' is ridiculous
13:05:53 <lament> wait, it's not
13:05:56 <yitz> warren_: also Foreign.Ptr and all the other stuff in the Foreign. It's very rich. I think just those docs should convince your boss.
13:06:01 <lament> nevermind
13:06:15 <Deewiant> Surely it could be distinguished with just two threads?
13:06:19 <Heffalump> lament: it's true outside the IO monad.
13:06:47 <yitz> ddarius: ok, sorry, I was wrong. I forgot that the report was so specific about that.
13:07:44 <ddarius> yitz: I didn't realize it was so specific except for the suggestion that it be equivalent to _|_.
13:08:24 <dpiponi> cabal's working again. Thanks!
13:08:58 <warren_> yitz: I see nothing in Foreign.Storable or Foreign.Ptr that states whether the translation process builds equivalent haskell data structures (which he is afraid of), or whether it overlays existing memory (which is what I believe it does). I need something that talks about what the compiler does.
13:09:12 <Twey> Hey folks, what are monoids commonly used for?
13:09:37 <elly> terrifying lisp programmers
13:09:52 <Twey> Hahahaha
13:09:53 <Deewiant> Combining stuff with binary functions
13:10:03 <Twey> Yes, thanks, helpful :-P  Use case?
13:10:49 <ddarius> Twey: In Haskell, they are not "commonly" used, though instances of them are very commonly used.
13:10:54 <Deewiant> > sortBy (comparing snd `mappend` comparing fst) [(1,2),(1,3),(2,2)]
13:10:55 <lambdabot>   [(1,2),(2,2),(1,3)]
13:11:07 <ddarius> There aren't too many library functions that are generalized over all monoids.
13:11:32 <ddarius> Twey: There are a lot of articles recently about usages of monoids such an sigfpe's.
13:11:44 <Twey> Aha, thanks.
13:12:22 <dpiponi> I'm writing one last thing on monoids right now. And then I hope not to mention them for a while.
13:12:27 <Deewiant> Amusing how a complaint by an OCaml programmer can lead to massive article writing :-P
13:12:27 <dons> hehe
13:12:39 <dons> i think brian's a haskell programmer now ... hopefully
13:12:44 <dons> at least he's working through RWH
13:12:47 <Twey> What was the complaint?
13:13:00 <Deewiant> On naming
13:13:08 <int-e> Twey: we should give Monoid a more programmer-friendly name, basically.
13:13:08 <ddarius> I think it was CosmicRay that actually caused it.
13:13:10 <Deewiant> Monoid vs. Appendable IIRC
13:13:12 <tehgeekmeister> i can't seem to figure out how to make a connection with takusen; the documentation is surprisingly terse, i.e.: it's mainly just type signatures.  anyone know where to start using takusen and postgresql?
13:13:24 <dpiponi> There's the complaint, and the real underlying problem. I think the real problem was lack of documentation.
13:13:33 <Deewiant> And as you can see from my above sortBy example 'Appendable' makes approximately no sense ;-)
13:13:34 * int-e is still glad so few people agreed.
13:13:39 <yitz> warren_: seems to be pretty clearly worded to me. e.g, Foreign.ForeignPtr
13:13:41 <int-e> precise naming is important.
13:14:42 <int80_h> yay, I used partial application correctly
13:15:38 <yitz> warren_: you can use C-like pointer operations, or you can make the C array look to the Haskell code like a Haskell list (without any conversion) using Foreign.Marshal.Array
13:15:49 <dmwit> int80_h: Nice!
13:15:51 <yitz> warren_: or all kinds of other fun stuff there
13:16:11 <int80_h> actually, I'd like verification
13:16:18 <int80_h> divides :: Integer -> Integer -> Bool
13:16:23 <int80_h> I wrote that
13:16:27 <dpiponi> Deewiant: the guy suggested Appenable instead of Monoid. And then wroe a post on the problems of metaphor shear. The only shearing metaphor I could see was calling Monoid Appendable!
13:16:29 <int80_h> for this experiment
13:16:37 <int80_h> ilter (divides 3) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
13:16:38 <int-e> Twey: as for you initial question, monoids are about as useful as monads - there are lots of instances that are used regularily (addition, multiplication, string concatenation, composition of various functions of type a -> a (including, for example, linear transformations of objects in 3d space), etc.) There are not too many ideas that work for all monoids, but there are a few and  they are very general and powerful ones.
13:16:45 <int80_h> filter (divides 3) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
13:16:49 <int80_h> and got this
13:16:55 <Deewiant> dpiponi: Yeah, I remembered something like that
13:16:55 <int80_h> [3,6,9,12,15]
13:16:57 <Deewiant> Twey: ^
13:17:10 <int80_h> that's an example of partial application right?
13:17:52 <trofi> > filter (0 ==).(`mod` 3) [1..]
13:17:53 <lambdabot>   Couldn't match expected type `a -> [t]'
13:18:31 <yitz> > filter ((0 ==).(`mod` 3)) [1..]
13:18:32 <int80_h> yes? no?
13:18:32 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
13:18:33 <warren_> yitz: do you mean "losslessly converted"? I interpret that to mean that the value can be pulled out of memory into a register without roundoff -- says nothing about whether the compiler compiles a field access at an array index into a single offset access instruction.
13:18:33 <Deewiant> int80_h: yep
13:18:44 <int80_h> cool
13:19:25 <ddarius> dpiponi: I think there was a complaint about something more than documentation, about how the Haskell community works, that for the most part had no effect.
13:19:52 <yitz> warren_: that's a differnt subject - I thought you were only interested in whether the Haskell can access raw C memory without copying the data and converting it into its own memory format
13:20:51 <yitz> warren_: controlling exactly how Haskell gets compiled into machine code is a bit more esoteric - dons has done a lot of work on that
13:21:04 <dpiponi> ddarius: What aspect of the Haskell community was he having problems with?
13:21:28 <warren_> yitz: the question is does the haskell equivalent of arr[i].foo = arr[j].bar become a memory move instruction
13:22:52 <yitz> warren_: dunno. probably goes through a register if you want me to guess. is that important?
13:23:37 <warren_> yitz: I think that's ok -- I think he assumes that there are function calls involved, additional allocation etc
13:24:34 <daf> hmm. I want to read a bunch of bytes using Data.Binary and pass them to a C library as a Ptr. I can't seem to do this safely via a ByteString, because I can only get a ForeignPtr out of that
13:24:47 <ddarius> dpiponi: "Well, Haskell is exacerbating that mistake. Haskell developers, stop letting the category theorists name things."
13:24:54 <yitz> warren_: show him the Foreign API, and show him the shootout results
13:25:04 <CakeProphet> :t null
13:25:05 <lambdabot> forall a. [a] -> Bool
13:25:08 <pumpkin> oh no, that again
13:25:19 <ddarius> dpiponi: Basically, that Haskellers are intentionally or unintentionally being cryptic/obscure
13:25:43 <CakeProphet> psh, where would he get that idea.
13:26:11 <clamothe> From perl
13:26:19 <yitz> daf: Foreign.ForeignPtr.withForeignPtr
13:26:19 <dpiponi> ddarius: I view that as a documentation issue. It's only obscure if not documented. BTW There are very few Haskell things with names from Category Theory. Maybe he means mathematics in general.
13:26:41 <CakeProphet> Haskell needs a help() function
13:26:52 <pumpkin> I think there is a very antimathematical "trend" out there, where if it sounds like math, it's automatiaclly complicated somehow
13:26:54 <iwannalog> > help ()
13:26:55 <lambdabot>   Not in scope: `help'
13:27:16 <sjanssen> pumpkin: I don't think it is anything new, just your usual anti-intellectualism
13:27:19 <yitz> iwannalog: help is right here in the irc channel :)
13:27:21 <daf> yitz: well, yes. I guess I was hoping avoiding changing stuff so I pass the ForeignPtr around
13:27:23 <SamB> ddarius: you have to admit that category theorists are notorioously bad at naming things
13:27:28 <warren_> yitz: I think he also assumes that mmap will need to allocate a haskell array with lots of little haskell data structures for your foreign-defined structures
13:27:29 <Saizan_> CakeProphet: with a proper installation: hoogle --info
13:27:37 <iwannalog> @let help = putStrLn "No help available."
13:27:38 <lambdabot>  Defined.
13:27:42 <iwannalog> > help
13:27:43 <lambdabot>   * Exception: "<IO ()>"
13:27:45 <pumpkin> sjanssen: it's true (assuming that your was the "third person anonymous" your and not second person :P)
13:27:51 <iwannalog> :D
13:28:01 <Twey> @let help = const "No help available."
13:28:02 <lambdabot>  <local>:5:0:
13:28:02 <lambdabot>      Multiple declarations of `L.help'
13:28:02 <lambdabot>      Declared at: <local...
13:28:06 <Twey> :(
13:28:08 <Twey> @forget help
13:28:08 <lambdabot> Incorrect arguments to quote
13:28:13 <Twey> Ack, that's for quotes
13:28:16 <idnar> @undef
13:28:21 <Twey> Ah
13:28:22 <daf> yitz: (I'm converting some code that used mallocBytes/hGetBuf)
13:28:23 <iwannalog> Twey: what is 'const' ?
13:28:23 <Twey> @undef help
13:28:25 <Twey> @let help = const "No help available."
13:28:26 <lambdabot>  Defined.
13:28:32 <dpiponi> There is an anti-mathematical trend. But a term like monoid is tricky because ordinary programming textbooks don't use them in places where they're used in Haskell. So newcomers can't easily find out about their uses even if they're interested.
13:28:33 <idnar> no, @undef undefines everything, it doesn't take an argument
13:28:36 <Twey> const _ b = b
13:28:36 <iwannalog> > help
13:28:37 <lambdabot>       Overlapping instances for Show (b -> [Char])
13:28:37 <lambdabot>        arising from a use ...
13:28:38 <sjanssen> warren_: well, that depends
13:28:51 <idnar> > help 123
13:28:52 <lambdabot>   "No help available."
13:28:53 <Twey> > help ()
13:28:54 <lambdabot>   "No help available."
13:29:07 <yitz> warren_: no, the Foreign API gives you direct access to memory via pointers
13:29:08 <cytzol> > help "No help available."
13:29:09 <lambdabot>   "No help available."
13:29:09 <tehgeekmeister> is anyone aware of any takusen tutorials?  i haven't found any yet and i'm absolutely baffled by the documentation so far.
13:29:14 <iwannalog> > help "Please help"
13:29:15 <lambdabot>   "No help available."
13:29:15 <sjanssen> warren_: but one can certainly access the raw bytes, just as you would in C.  See Foreign.*, StorableArray, etc.
13:29:42 <cytzol> > help "Say \"No help available\"!"
13:29:43 <lambdabot>   "No help available."
13:29:56 <dpiponi> Look up monoid on the web and you'll find countless non-programming applications. So I have some sympathy with complaints.
13:30:05 <ddarius> dpiponi: The next paragraph includes "And ignore anyone who starts their explanation with references to category theory- you donâ€™t need to know category theory, and I donâ€™t think it helps."  Taking an (overly) negative view, documenting this accurately would not "help" since programmer's don't need to know "abstract algebra to understand the concept."  I.e. (again taking this overly negatively) even -mentioning- abstr
13:30:05 <ddarius> act algebra or category theory already would suffice to be problematic.
13:30:05 <warren_> sjanssen: yes, it seems pretty clear that you can do that with mmap
13:30:17 <SamB> hmm ... is there some way to trigger an exception in a GHC 6.8-built program from out-of-process?
13:30:34 <yitz> @undef help
13:30:51 <ddarius> SamB: Most of the weirdnesses of naming in abstract algebra aren't from naming things obscurely but from using normal words in seemingly completely unrelated meanings.
13:31:02 <ddarius> E.g. magma, ring, group, field.
13:31:03 <yitz> @let help = ("Hey #haskell, iwannalog wants to know: " ++)
13:31:04 <lambdabot>  Defined.
13:31:08 <Heffalump> SamB: something it would catch?
13:31:25 <iwannalog> @type help
13:31:26 <lambdabot> [Char] -> [Char]
13:31:35 <CakeProphet> ddarius: well, I know nothing about abstract algebra and category theory... and understand Haskell decently.
13:31:37 <Deewiant> Where on earth does 'magma' come from
13:31:45 <ddarius> Deewiant: Abstract algebra
13:31:50 <yitz> > help "how do I write a web browser in Haskell?"
13:31:51 <lambdabot>   "Hey #haskell, iwannalog wants to know: how do I write a web browser in Has...
13:31:54 <Deewiant> ddarius: Yeah, but I meant why is it called that
13:31:55 <iwannalog> Deewiant: it's a very well chosen word
13:31:59 <ddarius> Deewiant: I have no idea.
13:32:07 <Deewiant> iwannalog: oh?
13:32:12 <SamB> Heffalump: yes
13:32:13 <sjanssen> SamB: can you modify the source of the program?  If so use a signal handler and throwTo
13:32:17 <SamB> ^C does not work
13:32:20 <iwannalog> magma is something hot and with no structure
13:32:25 <iwannalog> like a magma in maths
13:32:32 <SamB> sjanssen: signal handler ?
13:32:36 <Deewiant> hot? :-P
13:32:40 <sjanssen> SamB: kill -9 pidofprogram?
13:32:46 <Heffalump> sjanssen: it can't catch that :-)
13:32:48 <ddarius> CakeProphet: You don't need to know either to have an idea from them (or them themselves) explained to you.
13:32:53 <iwannalog> warm
13:32:55 <sjanssen> Heffalump: true
13:33:05 <SamB> I mean, ^C closes the program ... but without using an exception
13:33:22 <CakeProphet> ddarius:  correct.
13:33:36 <sjanssen> SamB: yes, I think you have to change the default handler for that signal
13:33:40 <SamB> the RTS doesn't clean up, it doesn't print out the CSS when I use +RTS -xc ...
13:33:46 <SamB> sjanssen: oh.
13:33:56 <CakeProphet> ddarius:  hmmm... do typeclasses simulate rings and groups in Haskell?
13:34:07 <ddarius> CakeProphet: No
13:34:09 <iwannalog> they don't exist today
13:34:35 <pumpkin> CakeProphet: in the mathematical prelude they do
13:34:44 <mathijs> Hi all, I just compiled ghc-6.10.1 (came from gch 6.8.3) and now my ghci seems a bit broken. I know about the move to editline, so it might have something to do with it. pressing ^D doesn't work (it just prints ^D), and neither do backspace and del. Any suggestions?
13:34:45 <pumpkin> but the standard prelude is a bit of a mathematical mess
13:34:45 * Heffalump twats himself repeatedly
13:34:47 <ddarius> CakeProphet: You can, if you want, make a Ring or Group type class, but that doesn't "simulate" them.
13:34:56 <Heffalump> I've just spent hours tracking down a laziness bug caused by a strictness annotation I added
13:34:56 <pumpkin> Heffalump: that sounds rude
13:34:56 <iwannalog> pumpkin: what is the mathematical prelude, i never found it
13:35:17 <CakeProphet> ddarius:  I remember something in abstract algebra that has a set of objects and operations on them -- which sounds like a typeclass to me.
13:35:26 <Saizan_> ?where hpaste2
13:35:26 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
13:35:26 <pumpkin> iwannalog: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric-prelude
13:35:35 * CakeProphet has never taken a class or studied abstract algebra, so doesn't know the names.
13:35:37 <iwannalog> thanks
13:36:19 <ddarius> CakeProphet: Abstract algebra is about sets equipped with operations fairly generally.  Universal algebra would be the general notion (as far as algebras go).
13:36:28 <Saizan_> SamB: from happs: http://pastebin.com/m1473f72b
13:36:29 <yitz> CakeProphet: there are all kinds of things like that in abstract algebra
13:36:42 <yitz> CakeProphet: the general study of them is called "category theory".
13:36:45 <ddarius> CakeProphet: However, most algebraic structures include laws that must hold which type classes can't represent at all.
13:37:26 <dpiponi> That's what comments are for: they're a place to stick the laws
13:37:28 <ddarius> yitz: Category theory is definitely -not- the general study of things equipped with operations, though you can cast it into category theory if you want.
13:37:31 <pumpkin> or quickcheck
13:37:33 <iwannalog> laws doesn't exist in haskell
13:37:45 <yitz> ddarius: yeah it's more general than that.
13:37:45 <vixey> that sounds like algebra yeah
13:37:58 <yitz> ddarius: but that's what algebraists use to do that
13:38:18 <pumpkin> quickcheck can give you reasonable certainty that your laws hold, but it's not a proof
13:38:18 <yitz> ddarius: or at least that what we used when I was one of those many years ago
13:38:24 <idnar> algebraist sounds like some kind of wizard
13:38:33 <ztirF> is there a way to get BinaryDerive to recursively derive through all my types and dependencies
13:38:41 <vixey> pumpkin, I would never call /that/ reasonable certainty
13:38:45 <ztirF> or do I have to do each one separately?
13:39:25 <pumpkin> vixey: fair enough :)
13:39:26 <ddarius> yitz: Universal algebra would be straightforwardly described without any reference to category theory and would cover almost all of the structures described in abstract algebra (fields would be a problem).
13:39:28 <CakeProphet> ddarius:  hmmm...  is there any work in regard to creating constraints (a.k.a. "laws") on these operations
13:39:44 <ddarius> CakeProphet: Not in Haskell.
13:39:47 <iwannalog> CakeProphet: COQ
13:40:24 <ddarius> I believe Miranda had some support for expressing laws, but I'm not sure what that actually meant semantically.
13:40:42 <ddarius> The OBJ family of languages does it rather well though, for algebraic structures.
13:40:45 <yitz> ddarius: well, all we wanted to do was to get our commutative diagrams going, then we could keep working on the problem at hand
13:42:02 <ddarius> A categorical approach to algebra would use something like Lawvere theories or initial algebras.
13:42:07 <yitz> idnar: perhaps that's why I'm not doing algebra anymore :)
13:42:16 <idnar> yitz: haha
13:42:25 <redditbot> Url dispatcher. Helps to retain friendly URLs in web applications
13:42:25 <ddarius> yitz: You don't want to be a wizard?
13:42:53 <yitz> ddarius: if I say I do, some will trap me inside a MS installer
13:43:03 <yitz> * someone
13:43:21 <ddarius> yitz: At least those work.  The ones in Visual Studio (at least VS2005) just tend to crash.
13:44:18 <yitz> ddarius: initial algebra sounds about right, but I don't really remember
13:49:14 <tibbe> evening #haskell
13:49:55 <yitz> hi tibbe
13:49:57 <conal> hey tibbe
14:02:03 <ksf> peaker++
14:02:12 <pumpkin> @seen dons
14:02:12 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 41m 51s ago.
14:03:03 <ksf> ...as he's the only one who's actually done coding on Widgets, while not even discussing Xrender vs cairo vs openGL on the cafe
14:07:14 <ksf> conal, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1087#a1087 . I need to figure out how to combine those braids, though, and possibly factor out more common patterns.
14:07:53 <dons> pumpkin: yo
14:08:07 <pumpkin> yo yo!
14:08:10 <ksf> braidE models a linear dispatch on a flat type, while actually I'd like my events to be organised more hirachically so that stuff gets closer to O(log(n))
14:09:47 <SimonRC> Are there comonadic equivalents for monads?
14:09:49 <SimonRC> it would be nice to see the equivalents of Maybe, [], IO, and so on to help me understand comonads
14:10:19 <Cale> SimonRC: There are not in any normal sense.
14:10:24 <ksf> simonrc, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras-0.53.5
14:10:37 <Cale> It's rare for something to be both a monad and a comonad.
14:10:56 <dons> worth a read (i'd not read this), http://www.reddit.com/r/haskell/comments/7txeo/parallel_implementations_of_functional/
14:11:04 * conal looks
14:11:11 <Cale> SimonRC: But I can introduce you to some important examples...
14:11:18 * Vq^ peeks
14:11:20 <Cale> SimonRC: Are you familiar with monoids?
14:11:42 <SimonRC> dons: i'd == "I had" not "I would"?  :-)
14:11:45 <SimonRC> Cale: yes
14:11:50 * Heffalump is still looking for a concrete example of comonads being useful
14:11:56 <SimonRC> mzero and mplus
14:12:03 <Deewiant> SimonRC: that's MonadPlus
14:12:08 <Cale> SimonRC: mempty and mappend
14:12:09 <Deewiant> mempty and mappend :-)
14:12:15 <SimonRC> ok
14:12:20 <Cale> (or I would prefer,  zero and (++))
14:12:28 <dons> heh
14:12:37 <Deewiant> (If zero for Monoids, what for MonadPlus?)
14:12:42 <dons> Heffalump: hmm. someone (elliott?) used comonads at work
14:12:45 <vixey> Heffalump, btw I take back my suggestion for using Comonad Supply
14:12:49 <Cale> Deewiant: I think mzero is fine.
14:12:56 <dons> for modelling something, hmm
14:13:02 <Deewiant> Cale: and mplus as well?
14:13:22 <Cale> Deewiant: That's less okay... an operator symbol of some sort would be nicer
14:13:28 <vixey> Heffalump, ... (at least as far as I could tell) it's not definable without unsafePerformIO
14:13:32 <Gracenotes> Heffalump: so am I looking for useful comonads, in a sense, but I just don't think it's a pattern really necessitated by the type system
14:13:35 <pumpkin> dons: have you considered adding dolio's awesome apply function (from uvector-algorithms) to the uvector API? it seems general enough to be worth putting into the main API (http://hackage.haskell.org/packages/archive/uvector-algorithms/0.1.1/doc/html/Data-Array-Vector-Algorithms-Immutable.html)
14:13:36 <conal> ksf: i'm not able to reach moonpatio right now.
14:13:40 <Cale> anyway...
14:13:47 <conal> ksf: it's often problematic for me, though usually only with :8080
14:13:49 <dons> haven't thought about it yet.
14:14:02 <int80_h> I want to do something like this
14:14:04 <Gracenotes> or by anything.
14:14:10 <int80_h> filter (not (divides 3) [1..100])
14:14:15 <int80_h> but I get a type error
14:14:28 <Cale> Suppose that we have some monoid m. Then functions m -> a form a comonad.
14:14:35 <int80_h> I don't understand why, divides returns a Bool, not expects a Bool
14:14:44 <ksf> conal, it's not rocket science anyway, just me trying to reduce the points you have to name and manage while dealing with 100+ different streams.
14:14:47 <Gracenotes> int80_h: are you sure you have your parentheses right?
14:14:53 <Cale> We have extract f = f zero
14:14:54 <Gracenotes> check the type signature for filter and look again :)
14:15:02 <int80_h> oh wait, you're right
14:15:08 <conal> ksf: i'm intrigued
14:15:25 <Cale> and duplicate f x y = f (x ++ y)
14:15:26 <Vq^> int80_h: also you probably need   not . divides 3
14:15:47 <Cale> and the usual Functor instance for functions.
14:15:55 <Gracenotes> yep. If you just had not (divides 3), that's the same thing as f x = not (divides 3) x
14:16:03 <Gracenotes> which doesn't make much sense.
14:16:14 <Cale> So, let's have a look at what this means...
14:16:30 <Cale> Suppose we take the monoid to be (Integer, Integer) pairs under addition.
14:16:41 <SimonRC> ok
14:17:03 <ddarius> (as a side note, that comonad can be completely induced by the writer monad and the adjunction underlying the state monad)
14:17:12 <Cale> yes
14:17:16 <Cale> This is dual to writer.
14:17:35 <int80_h> Vq^: yup
14:17:38 <Cale> But I'm not sure how helpful it is to think of it that way...
14:17:54 <Gracenotes> hm, my sword is destroying walls. This shouldn't happen :/
14:18:11 <pumpkin> it's a powerful sword indeed!
14:18:23 <SimonRC> Gracenotes: don't tell me, you meant to write that on #nethack ?
14:18:27 <Gracenotes> this only means I have a conditional in my processSwordHit screwed up!
14:18:34 <SimonRC> ah, ok
14:18:39 <CakeProphet> @src Monoid
14:18:39 <lambdabot> class Monoid a where
14:18:39 <lambdabot>     mempty  :: a
14:18:39 <lambdabot>     mappend :: a -> a -> a
14:18:39 <lambdabot>     mconcat :: [a] -> a
14:18:51 <Gracenotes> SimonRC: I'm having much fun with processSwordHit :: STRoom s -> StateT Queue (ST s) (STRoom s)
14:18:53 <Gracenotes> :)
14:19:01 <CakeProphet> so are Monoids are superset of Monads?
14:19:19 <SimonRC> CakeProphet: no
14:19:27 <SimonRC> monoid is an unfortunate name
14:19:57 <Cale> In the case of type Point = (Integer, Integer), an element of this comonad is an assignment of a value for each point in the integer lattice. Now, suppose we write a function (Point -> Bool) -> Bool, which effectively treats the function as the state of a cellular automaton and computes the next value at the origin
14:20:12 <ddarius> SimonRC: Monads are called monads in part due to their relation to monoids.
14:20:21 * Gracenotes does love the warm fuzzy things
14:20:26 <SimonRC> still, confusing
14:20:43 <Cale> call that function 'step' say
14:21:11 <SamB> or "life"
14:21:16 <SimonRC> CakeProphet: ok
14:21:19 <SimonRC> oops
14:21:24 <SimonRC> Cale: ok#
14:21:36 <Cale> Then, given an initial state x :: (Point -> Bool), we can duplicate x :: Point -> (Point -> Bool), and then fmap step (duplicate x) :: Point -> Bool
14:21:40 <Cale> What will that be?
14:21:57 <Cale> Why, it's the next state of the whole cellular automaton!
14:21:59 <CakeProphet> hmmm... are there any infinitary functions out there?
14:22:00 <SimonRC> ... thinking...
14:22:06 <vixey> isn't every monoid a monad?
14:22:11 <vixey> @instances Monoid
14:22:12 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:22:14 <vixey> @instances Monad
14:22:15 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:22:28 <vixey> there couldn't be an instance like  Monoid a => Monad a ?
14:22:28 <ddarius> vixey: Obviously not.  They aren't the same kind.  Every monoid induces a monad (obviously)
14:22:41 <vixey> what does induces mean?
14:22:52 <Heffalump> ddarius: that's not obvious at all
14:22:52 <Cale> Effectively, what duplicate x gives us is an integer lattice where each point is tagged with a translated copy of x.
14:22:53 <ddarius> "gives rise to"
14:23:00 <Heffalump> monoid+functor, yeah
14:23:04 <vixey> ddarius, that's just what I was asking
14:23:10 <ddarius> Heffalump: Writer
14:23:12 <vixey> ddarius, you said it's obviously not true and obviously true :p
14:23:15 <Gracenotes> m a -> m a -> m a... I suppose, er, mappend a b = a >> b?
14:23:21 <Heffalump> oh, right. I wouldn't call that "induce"
14:23:22 <kerlo> GHC lets you put something to the effect of "pretend this is a command line argument" in a comment, doesn't it?
14:23:31 <ddarius> vixey: You asked if every monoid -was- a monad.
14:23:37 <kerlo> Specifically, -XEmptyDataDecls.
14:23:38 <vixey> oh
14:23:47 <Cale> So when we fmap the function which evaluates the cellular automaton at the origin over this lattice of all the translates, we've applied it to every point
14:24:11 <Gracenotes> mempty = ...hrm...
14:24:31 <kerlo> @index unsafeCoerce
14:24:31 <lambdabot> bzzt
14:24:36 <kerlo> Right, right.
14:24:54 <SimonRC> Cale: I can't keep up
14:24:56 <ddarius> I believe there is an adjunction -x= : Monoids(C) -> Monads(C) -| -(1) : Monads(C) -> Monoids(C)
14:25:12 <Gracenotes> see no evil, hear no evil, index no evil...
14:25:20 <Cale> SimonRC: Need a moment, or is there something which just doesn't make sense?
14:25:24 <kerlo> Anyway, is unsafeCoerce . unsafeCoerce :: a -> a safe?
14:25:33 <SimonRC> I am still trying to figure out what duplicate no this comonad is
14:25:42 <vixey> I don't understand the example with cells
14:25:45 <Heffalump> kerlo: can't see why not, but why would you want it?
14:25:57 <SamB> kerlo: I don't think it's well typed
14:26:02 <kerlo> Heffalump: so I can hide a value of one type inside a value of another.
14:26:06 <Heffalump> kerlo: and {-# LANGUAGE EmptyDataDecls #-}
14:26:11 <Cale> duplicate :: (m -> a) -> (m -> (m -> a))
14:26:15 <kerlo> Heffalump: gracias.
14:26:18 <vixey> instance Comonad (Point -> a) -> a ?
14:26:20 <Cale> duplicate f = \x y -> f (x ++ y)
14:26:26 <Heffalump> kerlo: i.e. you won't actually use it that way, there'll be some stuff between the two calls?
14:26:31 <Cale> Where in our case, ++ is vector addition.
14:26:35 <kerlo> Heffalump: right.
14:26:41 <Heffalump> I suggest you use Data.Dynamic
14:26:47 <SimonRC> Cale: ah, yes
14:27:05 <kerlo> I can't; there's a specific type I want to hide it inside of.
14:27:14 <Heffalump> if you lie about the type of a value the compiler/RTS will probably mess it up somehow
14:27:35 <SimonRC> Cale: ok
14:27:39 <Heffalump> in fact I think the GC certainly will
14:27:39 <kerlo> That sounds really fun.
14:27:49 <Cale> So, suppose we apply duplicate f to some point x, what we get is the function \y -> f (x ++ y), so it's just a translated version of f, which evaluated at the origin is the same as f x
14:28:29 <SimonRC> this is confusing
14:28:50 <Cale> So, supposing that f :: Point -> Bool is a cellular automaton state
14:28:56 <SimonRC> ok
14:29:13 <Cale> Then duplicate f is a bunch of copies of that state, translated in all possible ways
14:29:18 <SimonRC> out comonad is (Point ->), right?
14:29:21 <Cale> yes
14:29:32 <SimonRC> so f :: w Bool
14:29:36 <Cale> mhm
14:29:50 <Cale> and duplicate f :: w (w Bool)
14:29:57 <SimonRC> yes
14:30:13 <SimonRC> it's sinking in...
14:30:17 <vixey> extract :: (Point -> t) -> t   is wrong?
14:30:27 <Cale> vixey: no, that's right
14:30:29 <vixey> what about  duplicate :: (Point -> t) -> Point -> Point -> t  ?
14:30:34 <Cale> extract f = f zero
14:30:43 <SimonRC> wait, what was the question?
14:30:55 <Cale> vixey: duplicate f x y = f (x ++ y)
14:31:13 <Cale> SimonRC: I think vixey just missed part of the discussion
14:31:14 <kerlo> So where is unsafeCoerce?
14:31:26 <Heffalump> Unsafe.Coerce
14:31:50 <kerlo> @index Unsafe.Coerce
14:31:50 <lambdabot> bzzt
14:31:56 <kerlo> Eh.
14:32:05 <SimonRC> yeah, it's like monads all over again
14:32:07 <loadquo> @hoogle unsafeCoerce
14:32:07 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:32:15 <SimonRC> I'll get it after a week or so
14:32:18 <elly> I love showing people this: http://bugs.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
14:33:12 <kerlo> @ghc
14:33:12 <lambdabot> ghc says: Exotic pattern inside meta brackets
14:33:16 <Heffalump> they're not a bug, they're a feature!
14:33:17 <loadquo> Ah the good ole' ZHPPM
14:33:24 <Cthulhon|> Wasn't there some work on using comonads for representing side effects?  When I was reading about comonads, it was explained as 'making a value with type w a is unsafe, as opposed to getting the a out of an m a for a monad'.  But then there were some mailing list posts that said that the OI comonad wasn't referentially transparent, but I'm not sure why that is.
14:33:41 <Heffalump> Cthulhon|: because you can't safely duplicate it
14:34:05 <Cale> Cthulhon|: I/O just isn't comonadic.
14:34:16 <kerlo> data Void; void = unsafeCoerce
14:34:23 <Cthulhon|> I see.
14:34:25 <ddarius> elly: "bugs".haskell.org?
14:34:28 <kerlo> And void :: Void -> a.
14:34:50 <vixey> kerlo weird definition
14:34:51 <roconnor> void x = case x of {}
14:34:54 <Cale> SimonRC: well, that's just one, very general, example
14:35:13 <kerlo> Does GHC accept void x = case x of {} under any circumstances?
14:35:13 <vixey>     No instance for (Functor ((->) Point))
14:35:14 <vixey> :(
14:35:15 <athos> :t pure
14:35:16 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:35:25 <roconnor> kerlo: I don't know
14:35:35 <vixey> :t fmap
14:35:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:35:57 <Cale> SimonRC: Just like monads, there's less to comonads than you'd perhaps expect. The examples all consist of a datatype with a particular interface.
14:36:06 <ddarius> @instances-importing Control.Monad.Instances Functor
14:36:07 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:36:16 <ddarius> @instances Functor
14:36:16 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:37:26 * kerlo ponders how reallyUnsafeCallCC :: ((a -> b) -> a) -> a might be implemented
14:37:54 <SimonRC> Cale: is there a minimal non-trivial one, like Maybe?
14:37:59 <Cale> SimonRC: Dual to the (e ->) monad, we have the (,) e comonad, with fmap f (x,y) = (x,f y); extract (x,y) = y; duplicate (x,y) = (x,(x,y))
14:38:10 <SimonRC> ah, wait, I can see...
14:38:12 <SimonRC> ...
14:38:23 <ddarius> Cale: Data.Tree can be made into a comonad (in fact it is the cofree comonad on []).  Now explain what the Tree comonad intuitively is (not just it's definition, but how to think about it)
14:38:27 <SimonRC> ah, maybe not
14:38:52 <SimonRC> Cale: a good plumbing example
14:39:11 <SimonRC> ddarius: I am the student here, not Cale
14:39:16 <SimonRC> ish
14:39:55 <kerlo> {-# LANGUAGE EmptyDataDecls #-} doesn't stop GHCi from complaining about my empty data declaration and suggesting -XEmptyDataDecls.
14:39:56 <int80_h> what's that url that can check to see if a website is down?
14:40:12 <Cale> ddarius: Well, duplicate would give you the tree of subtrees of the original.
14:40:13 <vixey> what is the name of that monoid?
14:40:17 <Heffalump> kerlo: is that at the top of the file?
14:40:20 <vixey> what is the name of that comonad made of monoids?
14:40:22 <Heffalump> I forgot to mention that.
14:40:24 <kerlo> Heffalump: not quite.
14:40:30 <vixey>  Monoid Comonad ?
14:40:49 <kerlo> There we go.
14:41:09 <ddarius> vixey: I'm not aware of any particular name for it.
14:41:28 <hackage> Uploaded to hackage: diagrams 0.2
14:41:28 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.7
14:41:29 <SimonRC> aha, I can see how Tree is a comonad!
14:41:35 <shapr> How?
14:41:53 <SimonRC> or rather, infinite trees, which are supplied by the package I expect
14:42:11 <SimonRC> ah, to explain...
14:42:13 <Cale> Finite nonempty trees are too.
14:42:18 <SimonRC> Cale: true
14:42:26 <redditbot> Anyone tried this Haskell IDE ? How does it fare with emacs ?
14:42:35 <SimonRC> tree has a value at each node
14:42:38 <Cale> data Tree a = Branch a [Tree a] -- say
14:42:48 <Cale> extract :: Tree a -> a
14:42:51 <vixey> @hoogle threadDelay
14:42:52 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
14:42:56 <Cale> extract (Branch x ts) = x
14:43:01 <SimonRC> extract is the root's label
14:43:03 <shapr> oh
14:43:10 <Cale> duplicate :: Tree a -> Tree (Tree a)
14:43:25 <SimonRC> duplicate is ratehr like tail is for lists, each lable becomes a copy of the original tree from that point
14:43:33 <SimonRC> *tails, not tail
14:43:44 <Cale> duplicate (Branch x ts) = Branch (Branch x ts) (map duplicate ts)
14:44:03 <kerlo> Darn, GHCi quit on me when I used unsafeCoerce.
14:44:08 <kerlo> At least it worked once.
14:44:12 <SimonRC> and >>= takes a function on trees, and makes a new tree which is the result of applying the function to all the subtrees
14:44:15 <skorpan> GHCi got scared.
14:44:19 <Cale> SimonRC: Or tails
14:44:27 <Cale> yes
14:44:35 <SimonRC> yeah, that is a good example
14:44:35 <Cale> (sorry, didn't see the correction at first :)
14:44:38 <vixey> Cale how do you write step?
14:44:44 <vixey> next step state = fmap step (duplicate state)
14:44:45 <vixey> for this
14:45:43 <SimonRC> but infinite trees are a neater example as the function (x -> Tree x) is not so obvious/elegant/non-arbitrary
14:45:51 <Cale> vixey: Something like  step f = n >= 2 && n <= 4 where n = length . filter id $ [f (x,y) | x <- [-1..1], y <-[-1..1]]
14:46:18 <Cale> vixey: Or whatever cellular automaton function you want.
14:46:26 <skorpan> exactly what does fmap do? the way i've understood it is that it takes a non-monadic function and a monadic value and applies the function to that value and returns the result as a monadic value?
14:46:30 <Cale> vixey: It just has to evaluate the CA at the origin.
14:46:35 <chrisdone> dons: are you here?
14:46:43 <Cale> skorpan: Not necessarily monadic
14:46:48 <SimonRC> this means that list is a comonad too, if you restrict the tree to a single path
14:46:59 <vixey> Cale I do not believe this works at all!
14:47:02 <tehgeekmeister> oh!  new release of hdbc, maybe it solves the problems i had before.  =D
14:47:05 <olsner> > length [()| x <- [1..7], even x]
14:47:06 <lambdabot>   3
14:47:08 <skorpan> Cale: ah, okay, "functic" value then :)
14:47:12 <Cale> functorial
14:47:13 <SimonRC> skorpan: any functor, not just monads
14:47:28 <skorpan> okay, but otherwise my informal definition was correct?
14:47:58 <Cale> It basically applies a function to all the "elements" of a container, or to the "result" of a computation, depending on how you'd prefer to view it.
14:48:02 <Heffalump> skorpan: yes, it was
14:48:08 <skorpan> cool, great :)
14:48:14 <vixey> O_o
14:48:16 <vixey> it does
14:48:29 <CakeProphet> hmmm... is there a "history" monoid?
14:48:32 <Cale> Alternately, it turns a function (a -> b) into a function (f a -> f b)
14:48:42 <Cale> CakeProphet: comonad?
14:48:45 <skorpan> yeah, that might be a better explanation
14:48:46 <SimonRC> for List/Set fmap is map/setMap, for IO is a composition-like thing, for Maybe it is apply-to-Maybe-but-Nothing-for-Nothing
14:48:49 <Cale> CakeProphet: or... maybe you mean something else
14:49:19 <CakeProphet> Cale:  just something that keeps a record of previous computations by some sort of index.
14:49:27 <CakeProphet> perhaps when they occured
14:49:34 <CakeProphet> the order in which they occured, rather.
14:49:35 <SimonRC> (the number of times I have wanted fmap for the "reference" functor in Java... :-( )
14:49:40 <vixey> I wrote the cellular comonad
14:49:49 <vixey> it really works :D
14:49:52 <Cale> CakeProphet: Well, the identity element would be the identity history, and the operation is merging two histories?
14:49:59 <Cale> CakeProphet: Yes, that would be a monoid.
14:50:08 <Cale> er, empty history*
14:50:12 <vixey> I don't understadn how
14:50:16 <SimonRC> vixey: apart from the speed problem?
14:50:20 <Cale> vixey: :)
14:50:21 <SimonRC> whatever "speed" is
14:50:47 <vixey> http://pastebin.com/m13dbae06
14:50:48 <Cale> Well, yes, this is a really really slow way to apply a CA since functions aren't memoised
14:51:00 <Cale> So you're recomputing every cell all the way back in history
14:51:15 <Cale> But if you store the state into an array on each step, it'll perform better.
14:52:55 <SimonRC> is there anything like Maybe for comonads?
14:52:57 <vixey> I'm amazed at this it makes no sense
14:53:03 <Cale> vixey: Really?
14:53:05 <dons> chrisdone: yo
14:53:11 <Cale> vixey: I explained how it works in detail...
14:53:12 <Cale> :/
14:53:18 <Cale> vixey: Did you miss that?
14:53:21 <SimonRC> IMO (,) b seems like the equivalent
14:53:27 <vixey> sorry I'm a bit stupid
14:53:41 <vixey> I just typed what you wrote and it works though it's crazy
14:53:43 <SimonRC> actually, no
14:54:06 <SimonRC> Maybe is just (Either ()) in form...
14:54:08 <Cale> vixey: The way to understand it is to understand what duplicate is doing.
14:54:19 <Cale> vixey: That's the most important thing
14:54:29 <kerlo> reallyUnsafeRemoveFromNN works! http://pastebin.ca/1323943
14:54:30 <Cale> SimonRC: there's nothing like Maybe
14:54:46 <Cale> SimonRC: You need extract...
14:55:01 <SimonRC> so the matching one would change the sum to a product to give (,) ()
14:55:15 <Cale> SimonRC: oh, okay, there's a dual of Maybe
14:55:16 <Cale> yes.
14:55:18 <kerlo> So apparently unsafeCoerce ((\f -> f "hello") unsafeCoerce :: Void) :: String = "hello", in GHCi, at least.
14:55:45 <Cale> vixey: Take that initial state you have there
14:55:59 <Cale> vixey: duplicate it, and then evaluate the result at various points
14:56:03 <Cale> vixey: and see what you see
14:56:12 <tehgeekmeister> how do i figure out which version of ghc (i have multiple installed) runhaskell is using?
14:56:14 * kerlo adds a "works" to his above sentence
14:56:26 <Cale> (each point will give rise to a state for you to print)
14:56:36 <tehgeekmeister> -V and -h didn't do anything, and there's no man page
14:56:47 <SimonRC> --help?
14:56:49 <vixey> hmm
14:56:53 <kerlo> tehgeekmeister: take a peek at runhaskell. What does it say?
14:57:01 <vixey> Cale but I put in the real game of life rules and my glider dies
14:57:26 <tehgeekmeister> kerlo: what do you mean?  it gives no output aside from whatever file it's running
14:57:32 <Cale> Is that really a glider?
14:57:47 <kerlo> tehgeekmeister: cat `which runhaskell`
14:58:17 <kerlo> Actually, that may be ill-advised.
14:58:23 <tehgeekmeister> okay, it's the right version
14:58:26 <tehgeekmeister> well, i already did it anyway
14:58:42 <vixey> Cale yes
14:58:43 <MyCatVerbs> kerlo: it's fine, GHC's runhaskell is a shell script. ghci and ghc are too.
14:58:58 <SimonRC> Cale: no, it's not a glider
14:59:07 <vixey>  ###
14:59:07 <vixey> #  #
14:59:11 <vixey> isn't a glider ?
14:59:19 <Cale> It looks like part of an lwss or something
14:59:19 <kerlo> Indeed, that's not a glider.
14:59:23 <kerlo> ###
14:59:24 <kerlo>   #
14:59:27 <kerlo>  #
14:59:31 <SimonRC> kerlo: yes
14:59:31 <kerlo> That's a glider.
14:59:38 <SimonRC> or the folowing...
14:59:38 <hydrapheetz>  #
14:59:40 <hydrapheetz>   #
14:59:42 <hydrapheetz> ###
14:59:46 <SimonRC> or the folowing...
14:59:52 <SimonRC>  ##
14:59:54 <SimonRC> ##
14:59:56 <SimonRC>   #
15:00:04 <vixey> it stepts into
15:00:05 <vixey>   #
15:00:05 <vixey>    #
15:00:05 <vixey>  #
15:00:08 <vixey> and thten dies
15:00:09 <SimonRC> going the wrong way
15:00:10 <Cale> That one is pointed in the opposite direction
15:00:32 <vixey> http://pastebin.com/m3df78972
15:00:38 <vixey> it doesn't seem to work
15:00:44 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1088#a1088
15:01:01 <int80_h> someone take a look at my sieve implementation. I want to know if it's correct
15:01:18 * SimonRC goes
15:01:25 <int80_h> I mean "could...
15:01:26 <vixey> do you think I juts made a silly mistake or something?
15:01:31 <ddarius> Why do you have if adj == 2 || adj == 2 ?
15:01:44 <Cale> vixey: Oh, are you checking that the cell is live?
15:01:46 <vixey> :C
15:01:53 <kerlo> vixey: either you didn't make a mistake, or you made a non-silly mistake, or you made a silly mistake.
15:01:58 <vixey> it should be  || adj == 3
15:02:00 <vixey> and then it works
15:02:31 <vixey> great!
15:02:51 <tehgeekmeister> hpaste is down?
15:03:00 <kerlo> @djinn ((a -> b) -> a) -> NN a
15:03:00 <lambdabot> f a = NN (\ b -> void (b (a (\ c -> void (b c)))))
15:03:02 <int80_h> hpaste is having some trouble
15:03:03 <kerlo> Wow.
15:03:10 <int80_h> I have to try several times to get it working
15:03:12 <kerlo> call-cc, here I come!
15:03:19 <kerlo> (More accurately: segfault, here I come!)
15:03:28 <tehgeekmeister> sad.  my issue is probably better suited to haskell cafe anyway
15:03:37 <vixey> kerlo, wait you got a real scheme style CWCC?
15:03:38 <int80_h> hmm, I see I have an error in my sieve
15:03:41 <vixey> hi grahamhutton
15:03:44 <kerlo> vixey: maybe.
15:03:51 <grahamhutton> hi vixey!
15:03:53 <vixey> kerlo not inside any monad?
15:03:58 <vixey> :)
15:04:00 <grahamhutton> @users
15:04:00 <lambdabot> Maximum users seen in #haskell: 658, currently: 650 (98.8%), active: 28 (4.3%)
15:04:09 <kerlo> vixey: inside the NN monad, but I have a reallyUnsafeRemoveFromNN function.
15:04:10 <grahamhutton> who -- things have increased around here!
15:04:15 <vixey> grahamhutton, I want to be user 666
15:04:18 <grahamhutton> who -> wow
15:04:21 <Cale> btw, you might have been thinking of...
15:04:28 <Cale> ####
15:04:32 <Cale> #   #
15:04:34 <Cale> #
15:04:37 <Cale>  #  #
15:04:43 <vixey> that's a shapeship
15:04:46 <Cale> yeah
15:04:47 <vixey> I know some of these guys
15:04:59 <CakeProphet> glider guns are my favorite.
15:05:00 <vixey> but I just made two silly mistakes at once and it all went wronga
15:05:00 * jeffwheeler is _so_ confused
15:05:21 <vixey> I posted a working version, if you just change 2 into 3
15:05:23 <SimonRC> CakeProphet: can you produce GGs from memory?
15:05:33 * SimonRC eats pizza
15:05:49 <int80_h> okay I don't see the mistake in my sieve
15:05:55 <CakeProphet> SimonRC:  ...noep. I need google for help.
15:06:06 <int80_h> when I use it to generate primes below 100, it works
15:06:13 <ddarius> vixey: It's possible to make single shot continuations with some finagling (and a good heaping of unsafePerformIO).  It may also be possible to get full continuations.
15:06:14 <Heffalump> I thought memory was implemented with glider guns
15:06:19 <Cale> int80_h: I'll look.
15:06:22 <kerlo> Now I have an untested reallyUnsafeSchemeStyleCallCC. Is it traditional to give unsafe functions really long names?
15:06:28 <int80_h> Cale: thanks
15:06:50 <vixey> I'm so disappointed about my type system
15:06:50 --- mode: ChanServ set +o maukf
15:06:53 <monochrom> Yes, kerlo. :)
15:06:56 --- mode: maukf set -o maukf
15:07:00 <kerlo> Great.
15:07:07 <int80_h> okay I forgot to tack on to to the list...but other than that
15:07:09 <ehird> kerlo: ooh, source?
15:07:12 <int80_h> oh wait! thats it
15:07:13 <Cale> vixey: Do you see what it's doing now?
15:07:20 <vixey> Cale no but it's cool :p
15:07:20 <int80_h> I forgot to tack on 2!
15:07:24 <vixey> I will figure it out
15:07:36 <vixey> duplicate f x y = f (mplus x y)
15:07:40 <kerlo> ehird: sure, then you can test it for me.
15:07:42 <monochrom> Generally anything you don't want people to use gets long names. Anything you want people to use gets short names.
15:07:50 * kerlo nods
15:07:53 <Cale> vixey: Okay... so have a look first at  duplicate f (Point 0 0)
15:08:06 <Cale> vixey: Supposing that f :: Point -> Bool
15:08:11 <kerlo> So a sane version would be called unsafeCallCC.
15:08:17 <vixey> Board = Point -> Bool
15:08:19 <vixey> basically
15:08:22 <jeffwheeler> @pl \a -> 1:2:a
15:08:22 <lambdabot> ([1, 2] ++)
15:08:27 <jeffwheeler> :(
15:08:30 <Cale> vixey: yeah
15:08:37 <vixey> and so duplicate f (Point 0 0) gives a new Board
15:08:40 <kerlo> ehird: http://pastebin.com/m53cbc461
15:08:40 <int80_h> hmm
15:08:43 <Cale> vixey: right
15:08:44 <kerlo> I'm sure that'll look familiar.
15:08:46 <tehgeekmeister> has there ever been any talk of upgrading hackage to have wikis and bugtrackers and whatnot for each project?
15:08:46 <jeffwheeler> How can the syntax error in this be avoided? (1:2:)?
15:08:52 <ehird> kerlo: That is...
15:08:54 <ehird> Beautiful
15:09:01 <kerlo> jeffwheeler: by doing what lambdabot did.
15:09:04 * ehird tests POSTHASTE
15:09:07 <grahamhutton> callcc isn't unsafe if you are working in the continuation monad...
15:09:10 <int80_h> Cale, I changed the "otherwise" case to
15:09:12 <int80_h>   | otherwise     = 2 : x : xs
15:09:13 <Cale> vixey: So  duplicate f (Point 0 0) x = f (Point 0 0 `mappend` x)
15:09:18 <ehird> grahamhutton: he's not
15:09:19 <tehgeekmeister> i think it would do the projects a whole lot of good, having some centralized discussion and documentation and all that sorta stuff.
15:09:20 <CakeProphet> Breeders are the coolest things ever.
15:09:21 <jeffwheeler> kerlo: fine . . . I liked the other form better.
15:09:29 <Cale> vixey: But of course adding Point 0 0 to anything just leaves it alone
15:09:35 <kerlo> jeffwheeler: well, there's always (1:).(2:)
15:09:35 <vixey> so you make a new board for every point of the old board
15:09:36 <monochrom> haha, "weird", "unsafe", "really unsafe". :)
15:09:36 <Cale> vixey: So this is the same as f
15:09:46 <ehird> Let's test this then!!
15:09:46 <Cale> vixey: right
15:09:49 <jeffwheeler> kerlo: I guess that's the solution.
15:09:55 <int80_h> but that starts a list [3,5,7,2...] I thought it would be [2,3,5,7,2]
15:10:01 <kerlo> I'm not sure why I called it weirdCallCC.
15:10:02 <int80_h> but that starts a list [3,5,7,2...] I thought it would be [2,3,5,7...]
15:10:03 <vixey> ok so that explains: next step state = fmap step (duplicate state)
15:10:05 <int80_h> oops
15:10:09 <ddarius> Cale: This being one of the comonad laws.
15:10:16 <ehird> kerlo: wait.
15:10:16 <vixey> it plugs  step  into every board
15:10:19 <Cale> ddarius: huh?
15:10:22 <ehird> That's not really callcc is it?
15:10:31 <Cale> ddarius: well, yes
15:10:33 <kerlo> ehird: I don't see how it could be. Did you test it?
15:10:38 <ehird> Yes.
15:10:56 <Cale> vixey: So... duplicate f (Point u v) (Point x y) = f (Point (u + x) (v + y))
15:10:59 <kerlo> I have made things that have worked without knowing how they could possibly work.
15:11:06 <kerlo> So, what are the test results? Did you get any segfaults?
15:11:10 <ehird> Wait. I think it is callcc.
15:11:12 <ehird> No segfaults, nope.
15:11:21 <kerlo> Pastebin it!
15:11:27 <ehird> reallyUnsafeSchemeStyleCallCC id type errors
15:11:28 <ehird> :'(
15:11:36 <Cale> vixey: So duplicate f (Point u v) is just a translated copy of f, shifted so that (Point u v) is at the origin
15:11:55 <Heffalump> ehird: it can't be SchemeStyle then
15:11:55 <ehird> kerlo: not much use if you can't dig the continuation out, is it
15:12:14 <BMeph> int80_h: I'm a Disciple of O'Neill, so I'd say any time you use mod and don't add or multiply, it isn't SoE. Period. :)
15:12:15 <int80_h> so why did 2 not get added to the begining of my x : xs when I did 2 : x : xs?
15:12:24 <vixey> Cale but it adds instead of subtracting
15:12:26 <alsonk_> @seen dons
15:12:26 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 19m 22s ago.
15:12:39 <kerlo> ehird: callCC id is really weird, though.
15:12:40 <Cale> vixey: yes...
15:12:58 <kerlo> ehird: if you must, use the Recursive Type Trick.
15:13:06 * ehird tries stuffing it into an IORef.
15:13:16 <int80_h> BMeph: why would I need to add or multiply?. I'm looking for multiples
15:13:17 <ehird> <interactive>:1:0:
15:13:17 <ehird>     Couldn't match expected type `IO [()]'
15:13:19 <ehird>            against inferred type `a -> b'
15:13:21 <ehird>     In a stmt of a 'do' expression: a <- newIORef
15:13:23 <ehird> That was...unexpected.
15:13:23 <vixey> -- (->) e Functor
15:13:23 <vixey> fmap f m = \o -> f (m o)
15:13:36 <Cale> > let (x:xs) = [4,5,6] in 2 : x : xs
15:13:37 <lambdabot>   [2,4,5,6]
15:13:46 <Cale> int80_h: it will be...
15:13:48 <kerlo> newtype Ehird b = Ehird ((Ehird b -> b) -> Ehird b)
15:13:54 <ehird> err, duh, it's newIORef val
15:13:56 <ehird> kerlo: I know
15:14:05 <Cale> I can't connect to moonpatio.com atm, for whatever reason.
15:14:24 <Cale> (most likely something dumb is going on with my connection)
15:14:35 <tehgeekmeister> anyone had this problem building testpack with ghc 6.10.1? http://www.nabble.com/can%27t-build-testpack-to21769519.html
15:14:41 <int80_h> okay, well I got the right answer, but when moonpatio is working again (and I'm home from work) I want to go over my code to make it better
15:14:45 <int80_h> hopefully
15:15:40 <ehird> Yay, I have it in an IORef.
15:15:45 <Cale> vixey: Well... just view fmap as applying a function to each of the translated boards, yeah?
15:15:54 <ehird> :t k
15:15:55 <ehird> k :: IO () -> IO ()
15:15:55 <lambdabot> Expr
15:16:01 <ehird> Let us try breakage!
15:16:05 <Cale> vixey: In particular, we're applying the function which evaluates that board at the origin.
15:16:11 <ehird> kerlo: __segfault__
15:16:27 <kerlo> ehird: great!
15:16:31 <dons> tehgeekmeister: --constraint='base<4'
15:16:36 <kerlo> What the heck did you do? :-)
15:17:05 <ehird> @where hpaste2
15:17:05 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:17:09 <ehird> kerlo: I'll show you.
15:17:13 <kerlo> Mmkay.
15:17:16 <ehird> (Basically, emulated (call/cc id))
15:17:19 <pao> hi all :-)
15:17:21 <tehgeekmeister> dons: says it's an unrecognized option?
15:17:25 <ehird> kerlo: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1089#a1089
15:18:14 <memento> if I use throwError in a function what i would like to use in map how can i do that? so i would like to reach that in 'map f xs' if f throws error then my function throw it forward...
15:19:00 <memento> ofc probably not map will be the solution
15:19:17 <kerlo> *NotNot> (reallyUnsafeSchemeStyleCallCC $ \c -> (c 3) + 4)
15:19:18 <kerlo> 7
15:19:21 <kerlo> I don't think that's right.
15:19:28 <kerlo> In fact, it ain't right.
15:19:35 <ddarius> kerlo: You are not doing anything that actually captures the language continuation so reallyUnsafeSchemeStyleCallCC is never going to work.
15:19:43 <ehird> kerlo: Yeah. exactly
15:19:44 <ehird> what ddarius said
15:19:48 <ehird> I thought this from the beginning
15:19:50 <kerlo> I thought not.
15:19:51 <ehird> it's really just the identity function.
15:20:05 <ehird> What you want to do is somehow get a Cont out unsafely, maybe.
15:20:06 <tehgeekmeister> dons: should i put that in the cabal file, perhaps?
15:20:10 <ehird> Like, use the internal Cont structure.
15:20:18 <vixey> does anyone know of Twelf ?
15:20:22 <Olathe> Is there a way to do something like this without all kinds of let ... do { b <- f a; c = g b; d <- f c; e = g d; return e } ?
15:20:28 <ddarius> I know -of- it, but not much about it.
15:20:42 <vixey> I just wonder why it works that way
15:20:44 <kerlo> I'm pretty sure this is impossible without GHC being really, really cool.
15:20:47 <dons> tehgeekmeister: the author should add build-depends: base < 4
15:20:55 <ddarius> kerlo: I'm pretty sure it's possible.
15:20:57 <vixey> like logic programming .. it doesn't allow functional definitions
15:21:02 <dons> dcoutts: when will cabal-install release? i need http 4 support in arch real soon
15:21:03 <kerlo> ddarius: do it! :-D
15:21:03 <vixey> why is that?
15:21:06 <dons> lots of things are starting to depend on it
15:21:10 <ddarius> kerlo: I probably will.
15:21:23 <maukf> do { b <- f a; d <- f (g b); return (g d) }
15:21:28 <tehgeekmeister> tehgeekmeister: i'll add that for now and relay the message to the maintainer
15:21:32 <tehgeekmeister> err
15:21:34 <tehgeekmeister> dons: ^
15:21:36 <Olathe> Actually, it's more evil.
15:21:41 <kerlo> This means that undefined $! (cont 3) will return 3.
15:21:50 <vixey> does anyone know ?
15:21:57 <ddarius> Single shot continuations should be doable and esap might have made them a long time ago.  What the thread interface supports will decide if multishot continuations are doable.
15:21:59 <kerlo> Is GHC capable of holding a cont that does that, even a really unsafe one?
15:22:04 <lamdapants> http://pastebin.com/m11ecb7f4 I wasted some time :)
15:22:30 <Jedi_Stannis> hey, I'm new to haskell, wrote up some code to get the hang of it and was wondering if anyone would be willing to take a look at it and comment on it?  (Ideas for improving the code, style of the code, etc)
15:22:46 <Olathe> It's something horrid like ... do { (b, c) <- x a; (d, e) = y b; (f, g) <- x c; (h, i) = y g; return (c, h) } ?
15:23:04 <Cale> Jedi_Stannis: Stick it on a pastebin perhaps, and we can have a look :)
15:23:13 <loadquo> @where hpaste2
15:23:13 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:23:18 <ddarius> Olathe: Use combinators, not do notation.
15:23:18 <vixey> Olathe, that looks like DCG almost
15:23:28 <Jedi_Stannis> hpaste seemed to be down
15:23:31 <Jedi_Stannis> http://mitchellkotler.net/poker.hs
15:23:40 <Jedi_Stannis> is this ok?  no syntax highlighting
15:23:46 <Olathe> It's a PNG chunk decoder.
15:23:50 <ddarius> Olathe: Alternatively, that might be a StateT instance.
15:23:55 <Olathe> What are combinators ?
15:23:56 <Cale> It was down a few minutes ago, it seems to be back up now.
15:23:58 <kerlo> So, reallyUnsafeSchemeStyleCallCC is so unsafe that it behaves safely instead.
15:24:03 <tehgeekmeister> dons: same exact problem
15:24:18 <ddarius> Olathe: Using (>>=) and co. directly.
15:24:23 <dons> i just built it. runhaskell Setup.lhs --constraint='base<4'
15:24:25 <vixey> Jedi_Stannis, I would not use  istToMaybe2 but: listToMaybe 2
15:24:30 <vixey> take 2 as a parameter
15:24:31 <Olathe> ddarius: Oh :(
15:24:47 <tehgeekmeister> i'll try it that way exactly
15:25:13 <Cale> Jedi_Stannis: On first glance, it looks rather idiomatic
15:25:37 <methos> is there a generic "fold" just like foldl/r but that only takes a list and operation without initial value?
15:25:40 <kerlo> @djinn ((NN a -> b) -> NN a) -> NN a
15:25:41 <lambdabot> f a =
15:25:41 <lambdabot>     NN (\ b ->
15:25:41 <lambdabot>         case a (\ c ->
15:25:41 <lambdabot>                 case c of
15:25:41 <lambdabot>                 NN d -> void (d b)) of
15:25:43 <lambdabot>         NN e -> void (e b))
15:25:53 <tehgeekmeister> dons: my Setup is a .hs, not a .lhs, and it fails still.  different version, perhaps?
15:26:02 <Cale> methos: There's foldr1 and foldl1, but they fail for the empty list.
15:26:11 <tehgeekmeister> no, there's only one version on hackage.  that's odd.
15:26:23 <vixey> I think twelfs way is something to do with typechecking
15:26:27 <Cale> methos: There's also Data.Foldable.fold which folds using the Monoid instance of the elements of the list.
15:26:47 <methos> Cale: thx, just what i was looking for :)
15:26:50 <Cale> (of course, said monoid instance is going to provide an initial value)
15:28:26 <Jedi_Stannis> vixey: listToMaybe is already defined and doesn't take a number parameter, just a list and will only return the first element.  Your saying to write a more generic version?
15:28:35 <vixey> yes
15:28:42 <vixey> import Prelude hiding (listToMaybe)
15:28:46 <vixey> if you want to reuse the name
15:28:59 <Jedi_Stannis> ok
15:29:03 <Jedi_Stannis> thanks
15:29:06 <vixey> but you could invent a new name
15:29:15 <Jedi_Stannis> yeah
15:30:22 <Olathe> I found a nice workaround.
15:30:34 <Olathe> "=" -> "<- return $"
15:30:47 <vixey>  >"=" -> "<- return $"
15:30:53 <maukf> what
15:30:54 <vixey> > "=" -> "<- return $"
15:30:55 <lambdabot>   <no location info>: parse error on input `->'
15:30:58 <vixey> > do "=" -> "<- return $"
15:30:59 <lambdabot>   <no location info>: parse error on input `->'
15:31:10 <vixey> > do "foo" <- "x"
15:31:10 <Olathe> No, I mean to convert the
15:31:11 <lambdabot>   <no location info>:
15:31:11 <lambdabot>      The last statement in a 'do' construct must be an ...
15:31:13 <Jedi_Stannis> what about the pokerHand function?  I feel like there's room for improvement there, but not sure how else to write it.
15:31:18 <vixey> > "foo" >> "x"
15:31:19 <lambdabot>   "xxx"
15:31:22 <Olathe> "=" to "<- return $"
15:31:25 <maukf> Olathe: why can't you use let?
15:31:34 <Olathe> let ruins the alignment
15:31:41 <maukf> huh?
15:32:11 <jeffwheeler> > take 10 $ do { [1..] ; return 'a' }
15:32:11 <Olathe> maukf: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1091#a1091
15:32:12 <lambdabot>   "aaaaaaaaaa"
15:32:18 <jeffwheeler> That's neat.
15:32:25 * kerlo frowns at the occurs check
15:32:32 <jeffwheeler> . . . although I have no idea when that'd be useful.
15:32:34 <Olathe> maukf: If I use let, there's a bunch of extra noise.
15:32:34 <kerlo> djinn has a tendency to produce things that fail it.
15:33:05 <Cale> > do x <- [1,2,3]; y <- [4,5]; guard (even (x+y)); return (x,y)
15:33:06 <lambdabot>   [(1,5),(2,4),(3,5)]
15:33:23 <jeffwheeler> > do { Just 5 ; return 'a' }
15:33:24 <lambdabot>   Just 'a'
15:33:34 <jeffwheeler> > do { Nothing ; return 'a' }
15:33:35 <lambdabot>   Nothing
15:33:47 <jeffwheeler> @type guard
15:33:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:33:59 <Cale> > do x <- [1,2,3]; y <- [4,5]; if even (x+y) then [()] else []; return (x,y)
15:34:01 <lambdabot>   [(1,5),(2,4),(3,5)]
15:35:15 <jeffwheeler> @type when
15:35:16 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:35:20 <vixey> are there programming languages with type systems based on modal logics?/
15:35:59 <saml> @type even
15:36:00 <lambdabot> forall a. (Integral a) => a -> Bool
15:36:02 <Gracenotes> Molog. (not really)
15:36:27 <Cale> Molog is a *great* name for such a language :)
15:36:47 <jeffwheeler> People always think I'm saying "Pascal" when I say Haskell.
15:36:49 <vixey> dunno Molog makes me think of a Prolog based on modal logic
15:36:57 <ehird> languageName = take N concept ++ drop N otherconcept
15:37:32 <Gracenotes> well, I suppose I should confess at this point I got the name from Prolog
15:37:38 <Cale> vixey: You can sort of think of monads and comonads in Haskell's type system as being modal operators.
15:37:45 <vixey> really!?
15:37:55 <Cale> yes
15:38:00 <vixey> a -> [] a
15:38:01 <vixey> heh
15:38:15 <jeffwheeler> > do x <- [1..3]; y <- [4..6]; when (even (x+y)) (return (-2)); return (x,y)
15:38:16 <lambdabot>       No instance for (Num ())
15:38:16 <lambdabot>        arising from a use of `negate' at <inte...
15:38:31 <jeffwheeler> > do x <- [1..3]; y <- [4..6]; when (even (x+y)) (return 5); return (x,y)
15:38:32 <lambdabot>       No instance for (Num ())
15:38:32 <lambdabot>        arising from the literal `5' at <intera...
15:38:33 <Gracenotes> my comp sci teacher in high school had Pascal and Delphi books on her shelf
15:38:42 <jeffwheeler> > do x <- [1..3]; y <- [4..6]; when (even (x+y)) ([]); return (x,y)
15:38:43 <lambdabot>   [(1,4),(1,6),(2,5),(3,4),(3,6)]
15:38:55 <Gracenotes> I think I looked inside the Pascal book once or twice...
15:39:18 <jeffwheeler> Gracenotes: my current comp sci teacher always reminisces of Pascal.
15:39:26 <pumpkin> :o
15:39:47 <Gracenotes> didn't some Pascal operations involve storing ints as strings?
15:39:50 <Arnar_> Gracenotes: delphi is how I got started
15:40:03 <ddarius> @hoogle pseq
15:40:03 <lambdabot> Control.Parallel pseq :: a -> b -> b
15:40:20 <Cale> join :: [] [] p -> [] p
15:40:49 <Cale> Sort of a dual to the usual '4'
15:41:19 <kerlo> @djinn-add data Id a = Id a
15:41:37 * jeffwheeler attempts writing a Num instance for String that to interpret it as show'd Ints
15:41:42 <kerlo> @djinn-remove Id
15:41:42 <lambdabot> Unknown command, try @list
15:41:45 <Gracenotes> hm. So, from the previous discussion -- could you say that Haskell's type system is like Prolog in the Curry-Howard sense of "like"?
15:41:47 <kerlo> @list djinn-
15:41:47 <lambdabot> No module "djinn-" loaded
15:41:51 <kerlo> @list djinn
15:41:51 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
15:41:53 <vixey> @djinn-add data Id a = Refl a a
15:41:57 <kerlo> @djinn-del Id
15:42:03 <vixey> :/
15:42:03 <kerlo> Wait...
15:42:08 <vixey> my one was wrong anyway
15:42:08 <kerlo> What's Refl?
15:42:13 <vixey> just nonsense
15:42:17 <Gracenotes> Rofl.
15:42:26 <redditbot> Parallel Implementations of Functional Programming Languages -- Peyton Jones 1989 :: PDF
15:42:28 <kerlo> @djinn-add data Id a = Id {fromId :: a}
15:42:28 <lambdabot> Cannot parse command
15:42:34 <kerlo> @djinn-add newtype Id a = Id {fromId :: a}
15:42:34 <lambdabot> Cannot parse command
15:42:35 <kerlo> Darn.
15:42:42 <kerlo> @djinn-add data Id a = Id a
15:42:52 <Gracenotes> how would you include fromId in a type signature?
15:42:57 <BMeph> Molotl: The Aztec god of modal logic manipulation? ;p
15:43:04 <kerlo> @djinn (((Id a -> b) -> Id a) -> Id a) -> ((a -> b) -> a) -> a
15:43:05 <lambdabot> f a b =
15:43:05 <lambdabot>     case a (\ c -> Id (b (\ d -> c (Id d)))) of
15:43:05 <lambdabot>     Id e -> e
15:43:28 <Gracenotes> @djinn (((a -> b) -> a) -> a) -> ((a -> b) -> a) -> a
15:43:28 <lambdabot> f a = a
15:43:52 <kerlo> Gracenotes: are you familiar with record syntax?
15:44:14 <jeffwheeler> Is it not possible to declare instances in GHCI?
15:44:17 <Gracenotes> yes, but you can't really include a function name in a type sig, which is what djinn is there for, I'd think
15:44:20 <jeffwheeler> > instance Num String where . . .
15:44:21 <lambdabot>   <no location info>: parse error on input `instance'
15:44:54 <BONUS> you cant declare types, instances, or classes in GHCI, sadly
15:45:02 <BONUS> you also can't do qualified imports
15:45:23 <BMeph> jeffwheeler: Yes. :)
15:45:39 <Gracenotes> and you're blindfolded and have to sacrifice your firstborn every time it stack overflows
15:46:01 <vixey> Modal Logic 	â–¡ 	It is necessary that ..
15:46:01 <vixey> 	â—Š 	It is possible that â€¦
15:46:19 <vixey> [] is Comonad, <> is Monad?
15:46:31 <ksf> how does dispatching on typeid compare to dispatching an adt wrt. runtime costs?
15:48:46 <ddarius> kerlo: Here's a single shot callCC:  singleShotCallCC :: ((a -> b) -> a) -> a; singleShotCallCC f = unsafePerformIO $ do mvar <- newEmptyMvar; forkIO (let y = f (\x -> unsafePerformIO $ do putMVar mvar x; throw BlockedIndefinitely) in putMVar mvar $! y); takeMVar mvar
15:48:58 <ddarius> singleShotCallCC (\k -> k 3 + 4) --> 3
15:49:35 <dmwit_> > 430.5/550
15:49:36 <lambdabot>   0.7827272727272727
15:50:30 <ehird> ddarius: That's... awful.
15:50:32 <tehgeekmeister> anyone aware of a firefox search plugin for hackage?
15:50:33 <ehird> I love it.
15:50:41 <kerlo> ddarius: how about this: case singleShotCallCC WrapLeft of WrapLeft k -> k (WrapRight "hello"); WrapRight x -> "world"
15:50:47 <kerlo> For appropriately-defined WrapLeft and WrapRight.
15:51:11 <dmwit_> tehgeekmeister: Search plugins are overrated; use bookmarks with good keywords instead.
15:51:53 <ehird> hrm
15:52:04 <ehird> you can build multi shot call/cc out of single shot, can't you?
15:52:05 <kerlo> ddarius: I'm guessing that would run forever, as takeMVar would never get anything.
15:52:20 <tehgeekmeister> dmwit_: i don't really use bookmarks at all, i just dislike having to go to hackage.haskell.org and then clicking on the packages link to search the list of packages to go to the package's page to finally be able to download it;; i'd like it to be a one step process.
15:52:26 <kerlo> I guess my thingy isn't single-shot at all.
15:53:17 <ddarius> ehird: If you can duplicate threads.
15:53:28 <ehird> Oh, it just uses threads?
15:54:07 <kerlo> Oh well. reallyUnsafeRemoveFromNN is pretty cool, anyway.
15:54:30 <kerlo> @djinn Either a (Not a) -> NN a
15:54:30 <lambdabot> -- f cannot be realized.
15:54:31 <Badger> :/
15:54:38 <kerlo> No?
15:54:42 <Badger> cabal: cannot configure haskell-src-exts-0.3.12. It requires base >=4
15:54:42 <Badger> There is no available version of base that satisfies >=4
15:55:00 <int-e_> you'll need ghc 6.10.1
15:55:17 <kerlo> @djinn Either a (Not a) -> NotNot a
15:55:17 <lambdabot> -- f cannot be realized.
15:55:19 <Badger> oops
15:55:22 <kerlo> Huh.
15:55:26 <Badger> forgot to update.
15:56:31 <ehird> ddarius: Your single shot callcc, is, um
15:56:33 <ehird>     Occurs check: cannot construct the infinite type:
15:56:49 <ehird> oh wait
15:56:50 <ehird> oops
15:56:53 <dmwit_> tehgeekmeister: You can set the address of a bookmark to google.com/search?q=site:hackage.haskell.org+%s with a keyword like "hack" or so.
15:56:57 <ehird> ... hm, nope
15:57:08 <dmwit_> tehgeekmeister: Then typing "hack foo" in your location bar will search for "foo" on hackage.
15:57:21 <tehgeekmeister> dmwit_: oh that's cool
15:57:36 <dmwit_> tehgeekmeister: I think you can see how to generalize this to many other things you might want to do. =)
15:58:01 <ehird> My error.
15:58:51 <gio123>  @seen ski_
15:59:01 <gio123> @seen ski_
15:59:01 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I last heard ski_ speak 1d 45m 19s ago.
15:59:18 <thom__> is there a stabdardized matrix/linear algebra library for haskell and, if so, what should I be googling for to find docs/examples of it?
15:59:33 <byorgey> tehgeekmeister: alternatively, if you install xmonad, you can set it up so that you can type (say) alt-slash, h, "foo" no matter what window you're in, and have it search hackage for "foo" and switch to your browser window all at once. ;)
16:00:11 <tehgeekmeister> byorgey: that'd be amazingly useful if i used linux (and i've seriously considered switching back)
16:00:16 <tehgeekmeister> byorgey: good to know, however.
16:00:19 <jeffwheeler> For the pleasure of all: http://pastie.org/376297
16:00:30 * tehgeekmeister is in osx
16:00:32 <jeffwheeler> Err, except I just noticed a bug.
16:02:09 <jeffwheeler> There: http://pastie.org/376297
16:04:38 <jeffwheeler> > 4 * "6" = "24"
16:04:39 <lambdabot>   <no location info>: parse error on input `='
16:04:47 <kerlo> > 4 * "6"
16:04:48 <lambdabot>       No instance for (Num [Char])
16:04:48 <lambdabot>        arising from the literal `4' at <in...
16:05:02 <jeffwheeler> lol, yeah . . . I defined it in the paste, but obviously not here
16:05:10 <ehird> Hmm, singleshotcallcc doesn't seem to work inside monads.
16:05:27 <dons> tehgeekmeister: cabal install hdbc doesn't work for you?
16:05:33 <dons> or, you're using taksuen, right?
16:05:41 <kerlo> ehird: if it always works outside monads, then it always works inside monads, and vice versa.
16:05:43 <dons> http://twitter.com/tehgeekmeister/statuses/1165490683 <-- :(
16:05:53 <tehgeekmeister> i don't have the cabal command line deal on my system
16:05:58 <dons> what system?
16:06:03 <tehgeekmeister> osx 10.5
16:06:11 <tehgeekmeister> latest updates and all, with macports
16:06:12 <ehird> kerlo: yeah well :P
16:06:13 <dons> cabal-install should work fine there.
16:06:31 <dons> makes live easier trying out random packages.
16:06:49 <kerlo> Anyway, do we have a language whose type system can express arbitrary Turing machine behaviors?
16:06:54 <tehgeekmeister> i was trying takusen, but the documentation was so terse i gave up once i realized there's a new hdbc; if it solves the problem i was having i'll use it.
16:07:23 <tehgeekmeister> how do i use it?  i've never been able to figure that out.  i'd love some automation to installing packages, i spend almost all my time programming in haskell trying to build packages right now.
16:07:24 <kerlo> One where we can say "primes :: Integer -> whether it's prime or not", essentially.
16:08:10 <Raevel> i noticed that cabal downloaded a version of HTTP that was too new the other day :-o
16:08:17 <Raevel> eh
16:08:24 <Raevel> s/cabal/cabal-install's bootstrap/
16:09:11 <dons> tehgeekmeister: maybe just use the hdbc docs from real world haskell?
16:09:38 <tehgeekmeister> dons: hdbc was fine, i can understand how to use it, but i had a horrible memory leak problem when i used it.
16:09:49 <MarcWeber> Does there a split list by item exist now in Data.List ?
16:09:56 <dons> self inflicted, or library's fault?
16:10:24 <maukf> http://okmij.org/ftp/Computation/lambda-calc.html#haskell-type-level
16:10:34 <pumpkin> MarcWeber: nope, but there's a whole package for splits :)
16:11:05 <tehgeekmeister> dons: i was trying to lazily fetch all the rows of the table, and it'd load all into memory, but then later i tried to load just one row, and it would still load the whole table into memory.  it'd get up to about 4gb before i would shut it off.
16:11:06 <MarcWeber> pumpkin All I want to do is enhance performance on hslogger..
16:11:33 <MarcWeber> So adding a dependency for that would be overkill. But I'll copy the implementation from there ;-)
16:11:33 <tehgeekmeister> dons: so i guess library's fault.  and the people i talked to in here when i was working on it seemed to agree, tho I don't claim to know haskell well enough to be sure my code was lazy enough.
16:11:56 <dons> well, you have to check with john i think.
16:12:02 <dons> talk to the author for best advice, or check rwh
16:12:27 <mopped> > snd $ fst ((1, 'a'), "foo")
16:12:28 <lambdabot>   'a'
16:12:29 <tehgeekmeister> that's what i thot; i'm hoping that the new version will magically fix it.  if not i'll get in touch with him; but first i just have to get hdbc built at all.
16:12:34 <zachk> so i finally tracked down my bug in my n body gravity stepper, go sprinkling of print statements
16:12:41 <mopped> > (snd . fst) ((1, 'a'), "foo")
16:12:42 <lambdabot>   'a'
16:12:46 <tehgeekmeister> i just upgraded to 6.10 from 6.8, so i have to rebuild all my packages anyway.
16:14:31 <tehgeekmeister> ah hah!  i finally found cabal-install!  this may solve the problem.  =D
16:16:15 <FrozenOne> newbie question:
16:16:39 <FrozenOne> Why does getCPUTime return IO Integer?
16:16:44 <FrozenOne> I just want an Integer
16:16:51 <maukf> no, you don't
16:16:53 <FrozenOne> How do I get the integer out of that result
16:16:54 <sbahra> FrozenOne, are you familiar with the IO monad?
16:16:54 <FrozenOne> ?
16:17:00 <FrozenOne> vaguely
16:17:03 <zachk> you dont get things out of the IO monad
16:17:07 <zachk> its a one way monad
16:17:07 <sbahra> mauke has written a good IO tutorial.
16:17:15 <maukf> if it's an Integer, it's a constant
16:17:16 <thom__> url?
16:17:17 <sbahra> But since he's here, I don't have to do any work and he can give you the URL.
16:17:28 <maukf> there is no url, my pc is off
16:17:33 <pumpkin> :o
16:17:37 <sbahra> :(
16:17:48 <FrozenOne> fair enough. So I'm stuck with IO Integer?
16:17:49 <thom__> I want the url :)
16:17:57 <zachk> dont think of it as stuck
16:18:09 <Cale> FrozenOne: getCPUTime *is* an IO Integer, isn't it?
16:18:12 <maukf> http://209.85.129.132/search?q=cache:qlfzNPE8WqgJ:mauke.ath.cx/stuff/haskell/how-to-io.html+%22how+to+io%22+mauke&hl=de&ct=clnk&cd=1&gl=de&client=firefox-a
16:18:12 * thom__ is bigger newbie than FrozenOne
16:18:22 <Cale> :t getCPUTime
16:18:22 <sbahra> FrozenOne, check out that long URL
16:18:22 <lambdabot> Not in scope: `getCPUTime'
16:18:40 <Cale> @hoogle getCPUTime
16:18:40 <lambdabot> System.CPUTime getCPUTime :: IO Integer
16:18:42 <Cale> yes
16:18:44 <FrozenOne> If I have a function that takes an Integer and want to pass it the result of getCPUTime, then how do I pass it
16:19:00 <maukf> do { t <- getCPUTime; ... f t ...
16:19:00 <Olathe> fmap f getCPUTime
16:19:02 <Cale> FrozenOne: which means that it is an IO action which when run, will produce an Integer
16:19:02 <FrozenOne> import CPUTime
16:19:21 <Cale> To run it, you use the notation  x <- getCPUTime, inside of a do-block.
16:19:29 <zachk> do {time<-getCPUtime;let calculations=someFunction time;print calculations}
16:19:33 <Cale> Then x will be the Integer corresponding to the result, in the rest of the do-block.
16:19:47 <FrozenOne> x is not an 'Integer' but an 'IO Integer'
16:19:50 <Cale> The do-block itself will have type IO t for some type t.
16:19:53 <Cale> No.
16:19:59 <Cale> x is an Integer then.
16:20:12 <Olathe> <- is special
16:20:14 <Cale> Inside a do-block, if you write v <- x where x :: IO t, then v :: t
16:20:14 <FrozenOne> hmm
16:20:20 <FrozenOne> I know about <-
16:20:23 <FrozenOne> and do blocks
16:20:29 <Olathe> It takes the IO off of IO a
16:20:30 <Cale> v <- x means "run x, and call its result v"
16:20:42 <maukf> local unwrap
16:20:53 <Cale> "unwrap" is a bad way to describe it, I think.
16:20:53 <jfoutz> does the ghci 6.10.1 won't run on xen bug affect ghc at all? or... are compiled programs ok under xen?
16:21:10 <maukf> type-level unwrap :-)
16:21:18 <Cale> I suppose.
16:22:18 <Cale> When you run getLine :: IO String, it's not all that much like you're "unwrapping" a string, though, you're requesting the user input a String for you.
16:22:34 <Gracenotes> I'm not sure if this example will help clarify things, but...  let iotime = getCPUTime in do { time <- iotime; print ("The time is " ++ show time) }
16:22:46 <Gracenotes> iotime :: IO Integer
16:22:49 <Gracenotes> time :: Integer
16:22:55 <maukf> weird use of print
16:23:04 <ddarius> Cale: I agree.  I really hate the terminology of "unwrapping a monad" or "stripping IO" and such.
16:23:05 <Gracenotes> oh, yeah. Should be putStrLn :)
16:23:25 <mopped> How can foldr be used on infinite lists, but foldl cannot? foldl (+) 0 [1..] is 1:2:3:4:5..., (0 + 1) + 2) + 3) + 4)..., while foldr is (1 + (2 + (3 + (..., why is there a difference?
16:23:26 <Gracenotes> no difference though.
16:23:38 <pumpkin> why let getCPUTime and not just <- it directly?
16:23:50 <Cale> mopped: foldl always recurses immediately until it reaches the end of a list
16:23:51 <Olathe> mopped: foldl calls foldl immediately. foldr calls the function immediatel.
16:24:05 <maukf> mopped: there is no difference with (+)
16:24:12 <Cale> mopped: Whereas the result of foldr in the recursive case looks like f x (foldr f z xs)
16:24:18 <Cale> which means that f gets control next
16:24:30 <Cale> (lazy evaluation is outermost-first)
16:24:32 <Olathe> With (+), foldl' (or foldb if you have it) is probably best.
16:24:37 <mopped> lost me a bit
16:24:45 <Cale> mopped: I'll explain more carefully
16:24:47 <Gracenotes> pumpkin: an 'IO Integer' can still be passed around. But you can't use it.
16:25:01 <pumpkin> Gracenotes: yeah, was just wondering why :P
16:25:17 <FrozenOne> okay, I'm getting it now.. thanks for the help!
16:25:22 <Cale> Lazy evaluation always proceeds by taking the outermost function which can match one of the patterns in its definition, and substituting its parameters into the body.
16:25:23 <olsner> in IO, I think in imperative programming metaphors, i.e. v <- x means calling x and receiving the result as opposed to a 'let v = x' just binding 'v' to the lazy expression 'x'
16:25:26 <Olathe> FrozenOne: You're welcome.
16:25:37 <Gracenotes> pumpkin: it's more that it seems odd that getCPUTime is a function, but that it doesn't take any arguments
16:25:41 <Olathe> I think of it in terms of having data already there that you're accessing.
16:26:07 <Gracenotes> such functions are unusual normally, but common-ish with IO
16:26:08 <maukf> getCPUTime is not a function :<
16:26:08 <mopped> f (g (h x)), f is outtermost?
16:26:12 <Cale> mopped: yes
16:26:18 <ddarius> Olathe: do s <- ioError (userError "crikey!"); putStrLn s
16:26:34 <Olathe> ddarius: Something like that :)
16:26:37 <pumpkin> :t getContents
16:26:38 <Gracenotes> maukf: eh. I find it a bit helpful to think of it as such.
16:26:51 <maukf> Gracenotes: DENIED
16:26:54 <pumpkin> @botsnack
16:26:54 <lunabot>  :)
16:27:00 <tehgeekmeister> finally have cabal-install, but when i try and install hdbc 2.0 with it, or testpack, or any number of packages, it says they don't exist.  why's that?
16:27:04 <Gracenotes> maukf: in the internals, it's not just simply retrieving a value, but also getting the system time, etc.
16:27:04 <Cale> mopped: So if, say, f u = 10 * u, the first step of reduction will be  f (g (h x)) -> 10 * (g (h x))
16:27:11 <pumpkin> :t getContents
16:27:14 <SamB> tehgeekmeister: cabal update
16:27:14 <pumpkinbot> IO String
16:27:15 <mopped> so it evaluates f straight away, and in doing so evalutes g, and in doing so evalutes h, but if g didnt need the evaluation of h, itd just stop?
16:27:22 <tehgeekmeister> SamB: done that already.
16:27:24 <pumpkin> Gracenotes: just like that
16:27:24 <Cale> mopped: right
16:27:29 <SamB> tehgeekmeister: oh ?
16:27:36 <maukf> Gracenotes: yeah, but it's an action, not a function
16:27:45 <tehgeekmeister> SamB: yep, and no change afterward
16:27:59 <SamB> cabal list says what ?
16:27:59 <Gracenotes> well, not a function in the mathematical sense
16:28:05 <mopped> and what does foldl do instead?
16:28:07 <Cale> mopped: and if f can produce a data constructor applied to some expressions, those expressions might never be evaluated unless something pattern matches them
16:28:25 <Cale> So let's compare the definition of foldl and foldr
16:28:33 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
16:28:54 <tehgeekmeister> SamB: it lists a bunch of packages, but not as many as hackage does.
16:28:56 <Cale> foldl will *always* call foldl immediately if the list isn't empty
16:29:18 <Badger> hmm
16:29:28 <Badger> should be able to do cabal install foo >=version right?
16:29:35 <Cale> So it just keeps calling itself without returning anything until it reaches an empty list, which never happens if the list is infinite
16:29:48 <Cale> But foldr f z (x:xs) = f x (foldr f z xs)
16:30:02 <Badger> Configuring haskell-src-exts-0.4.8...
16:30:02 <Badger> cabal: happy version >=1.17 is required but it could not be found.
16:30:04 <Badger> :(
16:30:13 <Cale> Now, if f can produce part of its result without needing its second parameter, that second parameter might never get evaluated.
16:30:20 <Gracenotes> maukf: it's helpful to think of it as something that gets a value through a series of actions (changing the world, in that model). To me it makes sense to call it a function, but not in the referentially transparent sense.
16:30:20 <Cale> Control might never return to foldr
16:30:28 <thom__> can somebody point me to the page for using haskell inside emacs? google seems to want to point me in a 100 different directions :(
16:30:36 <maukf> Badger: cabal update?
16:30:50 <mopped> right i understand, thanks
16:30:53 <Badger> maukf: no to avail
16:30:54 <Badger> er
16:30:58 <Badger> to no avail, rather
16:31:51 <Badger> oh hello
16:32:04 <kerlo> @hoogle liftM
16:32:04 <pumpkinbot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
16:32:04 <pumpkinbot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:32:04 <pumpkinbot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:32:05 <Badger> upgrade seemed to fix it.
16:32:10 <Badger> or... not
16:32:11 <Cale> For instance,  foldr (\x xs -> 10*x : xs) [] [1..] --> foldr (\x xs -> 10*x : xs) [] (1 : [2..]) --> (\x xs -> 10*x : xs) 1 (foldr (\x xs -> 10*x : xs) [] [2..]) --> 10*1 : foldr (\x xs -> 10*x : xs) [] [2..]
16:32:31 <Cale> and if, say, you only need the first element of that list, there's no need to evaluate the remaining foldr.
16:32:53 * kerlo writes a really short monad tutorial
16:33:54 <lilac> kerlo: monads: dyslexic nomads?
16:34:02 <lament> "Monads for haskell programmers"
16:34:07 <thom__> kerlo: send me it when you finish :)
16:34:15 <kerlo> I'll paste a link.
16:34:15 <lament> "An introduction to monads for haskell programmers"
16:34:24 <lament> Monads are monads.
16:34:28 <lilac> "An introduction to Monads for Oleg Kiselyov"
16:34:34 <maukf> haha
16:34:43 <Badger> heh
16:34:51 <Badger> happy 1.1.7 doesn't even configure :)
16:34:53 <mopped> thanks Cale
16:34:59 <lament> "Oleg... are you on drugs?"
16:35:02 <thom__> kerlo: is it already written or did you just start?
16:35:08 <kerlo> thom__: I'm doing it now.
16:35:58 <Cale> mopped: no problem
16:36:18 <Badger> Cale: can't imagine how you get lambdabot to compile. :P
16:36:24 <Cale> lilac: That's it, aim high :)
16:36:31 <Cale> Badger: heh
16:36:54 <Cale> Badger: I actually haven't compiled it in a little while. Mostly I just use cabal to do it for me.
16:37:08 <Badger> Cale: I'm trying that >_>
16:38:37 <bbs> hey all
16:38:45 <bbs> hi Cale
16:38:57 <Cale> I don't really keep track of what gwern does with the repository or what's on hackage though.
16:40:30 <tehgeekmeister>  hum, this is really weird.  System.Random is built, i can import it (tried in ghci), but when i try to build testpack, it says random is hidden?
16:40:35 <Olathe> lambdabot is dead :(
16:40:52 <maukf> > "alive"
16:40:55 <pumpkinbot>   "alive"
16:41:04 <Olathe> > "zomg"
16:41:05 <pumpkinbot>   "zomg"
16:41:10 <Cale> Olathe: I can't log in to the site which it runs on either.
16:41:16 <Olathe> Ahh
16:41:29 <hackage> Uploaded to hackage: plugins 1.4.0
16:41:58 <maukf> preflex: seen lambdabot
16:41:58 <preflex>  lambdabot was last seen on #haskell 23 minutes and 18 seconds ago, saying: System.CPUTime getCPUTime :: IO Integer
16:42:02 <Cale> whoa, a new version of plugins!
16:42:27 <redditbot> diagrams: simple, declarative 2D graphics for haskell
16:42:27 <redditbot> A Neighborhood of Infinity: Beyond Regular Expressions: More Incremental String Matching
16:43:06 <ddarius> lambdabot is dead! Long live lambdabot!
16:43:22 <kerlo> @hoogle join
16:43:22 <pumpkinbot> Control.Monad join :: Monad m => m (m a) -> m a
16:43:23 <pumpkinbot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
16:43:23 <pumpkinbot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
16:43:28 * Badger cheers
16:43:47 <Olathe> > a + b
16:43:48 <pumpkinbot>   a + b
16:44:53 <dmwit_> heh, maukf
16:45:13 <tehgeekmeister> dons: you said something earlier about deleting cabal files and using cabal with defaults, how do i do that?  it seems testpack's cabal file is at fault, that's why i can't build it.
16:45:15 <maukf> ?
16:45:23 <dmwit_> I like your nick.
16:45:27 <dmwit_> And your /whois content.
16:46:04 <maukf> my whois is mostly chatzilla defaults
16:55:47 <jelmer> does anybody know what happened to yi? There's no longer a darcs repo on darcs.haskell.org
16:56:03 <maukf> @where yi
16:56:03 <pumpkinbot> http://www.cse.unsw.edu.au/~dons/yi.html
16:56:14 <sjanssen> jelmer: it might have moved to code.haskell.org
16:56:37 <jelmer> sjanssen, ah, it looks like it has - thanks
16:56:55 <jelmer> I guess I should fix the references on the wiki then :-)
16:57:14 <maukf> http://haskell.org/haskellwiki/Yi#Development
16:57:15 <pumpkinbot> Title: Yi - HaskellWiki
17:00:21 <thoughtpolice> jelmer: http://code.haskell.org/yi is HEAD
17:00:22 <pumpkinbot> Title: Index of /yi
17:00:33 <jelmer> I was looking at http://haskell.org/yi/Yi.html
17:00:33 <pumpkinbot> Title: Yi - HaskellWiki
17:00:44 <jelmer> thoughtpolice, thanks
17:01:30 <thoughtpolice> jelmer: the current head is pretty stable and featureful (only a few months ago it leaked memory like crazy on large files...,) rip off someone else's config and go :]
17:01:56 <jelmer> thoughtpolice, cool
17:02:18 <jelmer> thoughtpolice, I hope it's a bit easier to install on Debianthese days, installing the dependencies was too much work last time I tried
17:02:33 <thoughtpolice> jelmer: I will say the unicode stuff needs more tweaking - it doesn't quite handle it properly like emacs haskell-mode does when haskell-font-lock-symbols is set to unicode
17:03:07 <thoughtpolice> jelmer: er, well, not the unicode stuff, more like the rendering of "->", "::", "\x ->" etc. in a unicode-form using greek lambdas etc.
17:03:31 <thoughtpolice> jelmer: you should only need 'cabal install' to install it
17:03:35 <thoughtpolice> works fine with ghc 6.10
17:04:40 <thoughtpolice> jelmer: here's my config if you want to see it - http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1094#a1094 - it rips of JPB's a bit but I removed some stuff
17:05:07 * wli noticed a bunch of the haskell libs not building with 6.10, plus the removal of readline support from the ghci repl in 6.10 offended me greatly.
17:05:14 <jelmer> thoughtpolice, thanks
17:05:48 <methos> Î»
17:05:56 <kerlo> @djinn NN (Either a (Not a))
17:05:57 <pumpkinbot> Error: Undefined type NN
17:06:15 <kerlo> @djinn-add data NN = NN (Not (Not a))
17:06:15 <pumpkinbot> Error: Undefined type variable a
17:06:20 <kerlo> @djinn-add data NN a = NN (Not (Not a))
17:06:24 <kerlo> @djinn NN (Either a (Not a))
17:06:24 <pumpkinbot> f = NN (\ a -> void (a (Right (\ b -> a (Left b)))))
17:06:30 <kerlo> Segfault, here I come!
17:07:46 <pumpkin> lambdabot is still down?
17:08:02 <pumpkin> any lambdabot admins can control pumpkinbot if it comes back up (to make it @part)
17:09:27 <kerlo> Cool. reallyUnsafeRemoveFromNN on pumpkinbot's f :: NN (Either a (Not a)) returned Right applied to a value of type Not a.
17:11:09 <tehgeekmeister> anyone know why cabal update might not be working?
17:11:20 <kerlo> *NotNot> void ((case reallyUnsafeRemoveFromNN (NN (\a -> void (a (Right (\b -> a (Left b)))))) :: Either Integer (Integer -> Void) of Left x -> error "wah wah wah"; Right x -> x) 5) :: Integer
17:11:29 <kerlo> 24178876
17:11:39 <kerlo> That's one answer I wasn't expecting.
17:12:45 <jrx> hi everyone
17:13:06 <dons> i wonder if packages grow exponentially, http://galois.com/~dons/images/hackage-daily-graph.png
17:13:18 <dons> anyone have any thoughts on that?
17:14:08 <dons> maybe not, its some product of number of ways to combine libs (exponential), and user growth (linear)
17:14:20 <ddarius> Only if bandwidth and capacity are also growing exponentially.
17:15:30 <kerlo> "It would be a contradiction if it were a contradiction that Either a (Not a) can be realized. Through faulty reasoning, we conclude that Not a can be realized. Since, in this case, a can also be realized (5 is one), it's possible to realize Void, from which anything can be realized."
17:15:32 <dons> anyone able to work out the growth function of haskell libs, if i supply the daily data?
17:15:35 <pumpkin> is user growth linear? depends how much people evangelize I guess
17:15:46 <kerlo> "Okay, then. How do you realize an integer?" "24,178,876. Duh."
17:15:58 <dons> i want a curve fit, damnit
17:16:03 <pumpkin> :)
17:16:10 <Olathe> kerlo: Heheh
17:16:35 <jfoutz> what's a good /dist/stable/dist/ to pick since ... the end of november? today's didn't seem to want to install.
17:16:50 <pumpkin> what's happening with the haskell platform?
17:16:53 <jrx> dons: even gnuplot has some curve-fitting capabilities
17:17:58 <FunctorSalad_> Numeric.LinearAlgebra.LAPACK.linearSolveLSR
17:18:52 <ddarius> dons: Apply Lambert's W function to the cumulative growth and see if it looks roughly linear.
17:20:40 <FunctorSalad_> I don't think "some product" referred to (*)
17:21:08 <kerlo> *NotNot> unsafeCoerce (unsafeCoerce "hello" :: Void) :: String
17:21:09 <kerlo> "hello"
17:21:15 <kerlo> So, the question is how far I can push it.
17:21:19 <jfoutz> does anybody run the nightly stable builds?
17:21:42 <SamB> is there a way to conditionalize on what version of haddock I'm using ?
17:22:26 <FunctorSalad_> pumpkin: btw, unsafeCoerce :: Float -> Word32 worked :D thanks for the tip
17:22:44 <pumpkin> :)
17:22:54 <kerlo> s/Void/Bool/, it still works. s/Void/Integer/, it still works. s/Void/Integer -> Integer/, it still works. s/Void/Int/, it still works. s/Void/IO Int/, it still works.
17:23:01 <SamB> oh, __HADDOCK__ isn't defined for haddock 2
17:23:08 <SamB> they should mention that in the documentation ...
17:23:08 <FunctorSalad_> converted the Double to Float with double2Float# first...
17:24:39 <cads> wow, functional languages where you don't know the idioms.... are kinda annoying :(
17:25:00 <cads> "Where's Fold?!?!"
17:25:38 <kerlo> s/Void/Int#/, I get a kind error. Meh.
17:25:50 <ddarius> kerlo: unsafeCoerce is a no-op semantically.
17:26:25 <pumpkin> it's just a pointer cast?
17:26:31 <gwern> @quote poset
17:26:31 <pumpkinbot> No quotes match. Are you on drugs?
17:26:42 <kerlo> So unsafeCoerce . (unsafeCoerce :: a -> b) :: a -> a is going to be the identity function for all a and b?
17:26:43 <pumpkin> my bot doesn't have all of lambdabot's quotes
17:26:43 <ddarius> pumpkin: Not quite.  It's like C++'s reinterpret_cast
17:26:47 <byorgey> cads: are you having trouble with something?
17:26:50 <gwern> hm
17:26:54 <pumpkin> ah :)
17:27:01 <gwern> guess I can't do the weekly HWN quotefest - lb ain't here
17:27:18 <ddarius> kerlo: Modulo potential compiler optimizations that could go horribly awry.
17:27:24 <cads> byorgey: mathematica
17:27:59 <ddarius> cads: It has something like Fold, it's called like Nested or something like that.
17:28:57 * kerlo nods
17:29:21 <kerlo> Well, I apparently haven't found any potential compiler optimizations that could go horribly awry.
17:29:29 <kerlo> @docs Unsafe.Coerce
17:29:29 <pumpkinbot> Unsafe.Coerce not available
17:29:36 <kerlo> Frown.
17:29:39 <jrx> anyone has idea how to make IO monad more lazy, to allow something like that: module A where
17:29:42 <jrx> import System.Directory
17:29:45 <ddarius> kerlo: I don't believe there are any in that particular case, but in more complex situations things could come up.
17:29:53 * kerlo nods
17:30:16 <cads> I defined TriGrid[x_] := CrossProj[x, {0, 1}] + CrossProj[x, b] + CrossProj[x, a]   where CrossProj[x_, y_] := Floor[Norm[Projection[x, y]]],  a = {Sin[(2/3) Pi], Cos[(2/3) Pi]}, b = {Sin[(4/3) Pi], Cos[(4/3) Pi]}, and I feel like I should have defined it in a smarter way
17:30:24 <jrx> http://paste.lisp.org/display/74662
17:30:32 <jrx> sorry for that
17:30:37 <pumpkin> cads: is that mathematica?
17:30:49 <cads> i'd like it if mathematica had a where clause
17:30:53 <newsham> I tried a slightly different approach to explaining what a monad is.  wondering what people think of this approach:  http://www.thenewsh.com/~newsham/x/machine/monad.html
17:30:54 <pumpkinbot> Title: Monad
17:30:59 <gwern> jrx: more lazy? in a way different from say unsafeInterleaveIO?
17:31:16 <ddarius> newsham: It's crap.  Now give me a minute to read it and tell you why.
17:31:30 <newsham> ddarius: much appreciated (especially for the latter)
17:31:35 <Twey> :t unsafeInterleaveIO
17:31:37 <pumpkinbot> Not in scope: `unsafeInterleaveIO'
17:31:40 <kerlo> jrx: indeed, unsafeInterleaveIO does that, I believe, but why do you want to do that?
17:31:44 <Twey> What is unsafeInterleaveIO?
17:31:45 <kerlo> @hoogle unsafeInterleaveIO
17:31:45 <pumpkinbot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
17:31:49 <pumpkin> newsham: burrito!
17:32:01 <gwern> Twey: it makes IO functions lazy and not strict
17:32:02 <kerlo> I believe unsafeInterleaveIO is quite similar to return . unsafePerformIO.
17:32:15 <newsham> gwern: both at the same time? :)
17:32:17 <Twey> Oh
17:32:17 <cads> pumpkin, given a grid of equilateral triangles, if we draw a line segment from the origin (which is a grid point), to a point x, then TriGrid[x] is the number of lines in the grid that the segment crosses. It's for Project Euler 220
17:32:23 <jrx> kerlo: hm.. that doesnt sound like pretty solution
17:32:25 <gwern> newsham: hush you
17:32:50 <cads> Correction, http://projecteuler.net/index.php?section=problems&id=202
17:32:51 <pumpkinbot> Title: Problem 202 - Project Euler
17:32:57 <kerlo> jrx: indeed. It seems you might as well do something like...
17:33:11 <gwern> Twey: I found it useful in the past where I had a list of a couple million items, and had to forkIO a network call on each
17:33:35 <Twey> Rather than just chunking it?
17:33:46 <tehgeekmeister> anyone know why cabal update -v3 might exit immediately, with no output
17:33:48 <tehgeekmeister> ?
17:33:48 <gwern> yeah. I decided chunking was inelegant
17:33:56 <gwern> and unsafeInterleaveIO seemed a cool approach
17:34:01 <ddarius> newsham: You added 3+5 wrong.
17:34:32 <cads> has anyone here played with mathematica
17:34:49 <jrx> kerlo: It's just mainly for aesthetic reasons, because strict io tends to introduce longer and more of nested code
17:34:52 <arw> played a long time ago, at school.
17:35:13 * kerlo nods
17:35:18 * kerlo ponders
17:35:24 <newsham> ddarius: oops
17:35:29 <kerlo> @hoogle when
17:35:29 <pumpkinbot> Control.Monad when :: Monad m => Bool -> m () -> m ()
17:35:31 <cads> I am impressed by its array and vector capabilities
17:35:33 <gwern> (people don't seem to like unsafeInterleaveIO (because it's used to make a lot of file IO lazy) but I like it)
17:35:46 <kerlo> @hoogle m Bool -> m a -> m a -> m a
17:35:47 <pumpkinbot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
17:35:47 <pumpkinbot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
17:35:47 <pumpkinbot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
17:35:53 <cads> But I wish it was a serious programming language.
17:35:55 <kerlo> Eh.
17:35:56 <newsham> gwern: i like getContents.  does that count?
17:35:58 <dobblego> http://downforeveryoneorjustme.com/haskell.org
17:36:02 <pumpkinbot> Title: Huh?
17:36:04 <Gracenotes> kerlo: I've been looking for a function like that too!
17:36:12 <kerlo> Define one!
17:36:24 <gwern> newsham: uses it under the hood doesn't it?
17:36:26 <pumpkin> defile one!
17:36:27 <Gracenotes> kerlo: I did
17:36:40 <kerlo> condM x y z = do {c <- x; if c then y else z}
17:36:45 <Gracenotes> I came up with let ifM b c d = do {b' <- b; if b' then c else d}
17:37:02 <kerlo> Actually, I think there might be some fancy GHC extension that has a monadic version of if.
17:37:10 <newsham> gwern: thats what i mean.  "people dont seem to like it" but I think most people use it and like it all the time
17:37:13 <newsham> under the covers
17:37:30 <Gracenotes> actually, I ended up emulating an if (non-monadic bool) and (monadic bool) then c else d
17:37:35 <Gracenotes> stand a b c d = if a then do {b' <- b; if b' then c else d} else d
17:37:53 <gwern> newsham: I refer to those instances here where I see an obscure file-lock bug or something caused by lazy file IO, and then when it is diagnozed & fixed people curse io for being lazy
17:37:57 <Gracenotes> just extracting the b' first wouldn't work because the monad is strict in this case
17:38:17 <newsham> gwern: :)
17:38:19 * kerlo nods
17:38:46 <Gracenotes> hm... actually, lemme see :X
17:38:57 <jrx> maybe just create .. monad StrictIO and LazyIO?
17:39:07 <jrx> with ability to lift one to another?
17:39:19 <jrx> or just one-way
17:39:23 <SamB> crazy!
17:39:40 <Olathe> IO is lazy :(
17:40:14 <jrx> Olathe: not really
17:40:27 <jrx> Olathe: http://paste.lisp.org/display/74662
17:40:46 <jrx> Olathe: see that, it throws exception, when there is no "a.cpp" file
17:41:29 <hackage> Uploaded to hackage: hackage-sparks 0.3
17:41:29 <ddarius> newsham: Anyway, similar approaches have been done before.  While that approach may get someone up with being able to -write- monadic code, I don't think it will seriously help understanding nor that it addresses the parts people usually have difficulties with.  Your particular presentation seems self-contradictory, incoherent, and weird.  One aspect could be improved significantly (in my opinion).
17:42:15 <ddarius> @let if' b t e = if b then t else e
17:42:17 <pumpkinbot>  Defined.
17:42:20 <ddarius> :t liftM if'
17:42:22 <pumpkinbot> forall t (m :: * -> *). (Monad m) => m Bool -> m (t -> t -> t)
17:42:34 <Olathe> > let failIf zomg explosively = if zomg then fail explosively else return Nothing in failIf True "zomg"
17:42:35 <pumpkinbot>       No instance for (Show (m (Maybe a)))
17:42:35 <pumpkinbot>        arising from a use of `show...
17:42:36 <newsham> which aspect?
17:42:40 <jrx> :t liftM3 if'
17:42:41 <pumpkinbot> forall t (m :: * -> *). (Monad m) => m Bool -> m t -> m t -> m t
17:42:52 <pumpkin> that's prtty
17:43:01 <ddarius> :t (if' =<<)
17:43:03 <pumpkinbot> forall t. (t -> Bool) -> t -> t -> t
17:43:25 <Olathe> let failUnless zomg = failIf (not.zomg)
17:43:25 <ski_> > liftM3 if' (Just True) (Just ()) Nothing
17:43:27 <pumpkinbot>   Nothing
17:43:29 <ddarius> pumpkin: liftM3 doesn't work
17:43:37 <ddarius> It would be like defining if in a strict language.
17:43:40 <pumpkin> ah
17:44:07 <pumpkin> hmm
17:44:08 <Olathe> _ <- failUnless (doesFileExist "a.cpp") "File does not exist"
17:44:39 <pumpkin> why _ <- ?
17:45:08 <pumpkin> isn't that exactly >> or ;?
17:45:12 <jrx> @let ifM a b c = a >>= \x -> if x then b else c
17:45:14 <pumpkinbot>  Defined.
17:45:15 <jrx> :t ifM
17:45:17 <pumpkinbot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
17:45:32 <Olathe> pumpkin: Not sure.
17:45:42 <Olathe> I'm new to this whole do block scene.
17:45:51 <pumpkin> Olathe: I think it is
17:45:56 <Gracenotes> so, in which circumstance do you need this ifM?
17:45:56 <pumpkin> @src (>>)
17:45:57 <pumpkinbot> m >> k      = m >>= \_ -> k
17:46:03 <ski_> @undo do {_ <- ma; mb}
17:46:03 <pumpkinbot> ma >>= \ _ -> mb
17:46:06 * Gracenotes has used it himself with ST...
17:46:20 <ddarius> newsham: One of the self-contradictory aspects is that you talk about monads as putting together "programs" but then go on to say a monad for Maybe does not represent a "program."  There's a natural way to view monadic computations as "programs" supporting different features and in fact this is a good way to think of it.
17:47:05 <Gracenotes> > ifM (return True) (return 2) (return 4)
17:47:07 <pumpkinbot>       No instance for (Show (m t))
17:47:07 <pumpkinbot>        arising from a use of `show' at <in...
17:47:21 <Gracenotes> > ifM (return True) (return 2) (return 4)  :: Identity Integer
17:47:22 <pumpkinbot>       No instance for (Show (Identity Integer))
17:47:22 <pumpkinbot>        arising from a use of ...
17:47:29 <newsham> ddarius: hmm makes sense.
17:47:34 <Gracenotes> > runIdentity (ifM (return True) (return 2) (return 4)  :: Identity Integer)
17:47:35 <pumpkinbot>   2
17:48:00 <jrx> > runIdentity (ifM (return True) (return 2) (fail)  :: Identity Integer)
17:48:01 <pumpkinbot>   Couldn't match expected type `Identity Integer'
17:48:25 <ski_> > ifM (Just True) (Just ()) Nothing
17:48:26 <pumpkinbot>   Just ()
17:48:32 <jrx> > runIdentity (ifM (return True) (return 2) (undefined)  :: Identity Integer)
17:48:34 <pumpkinbot>   2
17:49:00 <BMeph> ddarius: But even if newsh changed it as per your suggestions, it would still suck, right? ;p
17:49:18 <ddarius> BMeph: Yes.
17:50:08 <Olathe> @hoogle Enumerable a => a -> b
17:50:09 <pumpkinbot> Warning: Unknown class Enumerable
17:50:09 <pumpkinbot> Unsafe.Coerce unsafeCoerce :: a -> b
17:50:09 <pumpkinbot> Prelude ($) :: (a -> b) -> a -> b
17:50:44 <ski_> @type fromEnum
17:50:46 <pumpkinbot> forall a. (Enum a) => a -> Int
17:50:50 <Olathe> > fromEnum True
17:50:52 <pumpkinbot>   1
17:50:54 <Olathe> > fromEnum False
17:50:56 <pumpkinbot>   0
17:51:28 <Gracenotes> @type toEnum
17:51:30 <pumpkinbot> forall a. (Enum a) => Int -> a
17:51:36 <Olathe> > let if' p x y = [y, x] !! (fromEnum p) in if' True 4 5
17:51:38 <pumpkinbot>   4
17:51:40 * ksf is sick of "Occurs check"
17:51:43 <Gracenotes> ... in retrospect, that would have made my "get random tetris block" function much easier..
17:52:12 <saml> > NaN == NaN
17:52:13 <pumpkinbot>   mueval: Prelude.read: no parse
17:52:21 <Olathe> @pl if' p x y = [y, x] !! (fromEnum p)
17:52:21 <pumpkinbot> if' = flip (flip . ((!!) .) . flip (:) . return) . fromEnum
17:52:24 <ksf> > nan == nan
17:52:25 <pumpkinbot>   mueval: Prelude.read: no parse
17:52:32 <pumpkin> > (0/0) == (0/0)
17:52:33 <saml> > 1e10000000000000000 == 2e1000000000000000
17:52:34 <pumpkinbot>   False
17:52:38 <pumpkinbot>   mueval: Prelude.read: no parse
17:53:00 <saml> > 1/0.0 == 2/0.0
17:53:01 <pumpkinbot>   True
17:53:08 <Olathe> @pl if' p x y = y:x:[] !! (fromEnum p)
17:53:09 <pumpkinbot> if' = (flip (:) .) . flip (:) . ([] !!) . fromEnum
17:53:14 <pumpkin> > (read "NaN" :: Double) == (read "NaN")
17:53:16 <pumpkinbot>   False
17:53:23 * kerlo ponders Not (Not (Either a (Not a)))
17:53:27 <saml> how can I get NaN value?
17:53:32 <kerlo> > 0/0
17:53:33 <pumpkin> saml: the two ways I just did
17:53:34 <pumpkinbot>   NaN
17:54:08 <saml> pumpkin, can i get NaN numerically?
17:54:13 <gwern> 'First of all, the name. The OCaml Summer Project is being renamed to the Jane Street Summer Project, in order to reflect a broader scope. We're not dropping the focus on our favorite language, but we've decided to experiment with opening up funding to other functional programming languages such as Haskell, F#, SML and Scheme.'
17:54:19 <gwern> http://ocaml.janestreet.com/?q=node/57
17:54:19 <pumpkinbot> Title: Summer Project FAQ | ocaml.janestreet.com
17:54:30 <Olathe> > round (0/0)
17:54:32 <pumpkinbot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
17:54:33 <saml> like  some_expr evaluating to NaN
17:54:34 <kerlo> You're given Not (Either a (Not a)), and you have to come up with Either a (Not a)...
17:54:35 <Gracenotes> > 34/34.24/432.2/342.2/32.2/0.23432/0.34921/0.49320
17:54:37 <pumpkinbot>   5.166606943784003e-6
17:54:43 <pumpkin> > (1/0) * 0
17:54:45 <pumpkinbot>   NaN
17:54:47 <Gracenotes> > 34/34.24/432.2/342.2/32.2/0.23432/0.34921/0.49320/0.00000000001
17:54:49 <pumpkinbot>   516660.69437840034
17:54:52 <Olathe> > (0/0)/100000
17:54:54 <pumpkinbot>   NaN
17:55:04 <pumpkin> saml: infinity * 0 = NaN
17:55:17 <Olathe> > length . show $ round (0/0)
17:55:19 <pumpkinbot>   310
17:55:32 <saml> it seems like a NaN == another NaN
17:55:32 <pumpkin> but 0/0 is an expression that evaluates to NaN (if double)
17:55:34 <Olathe> > div (round (0/0)) (2^309)
17:55:36 <pumpkinbot>   -25854619983290565462790913472332408416913030198836464154205950294763432284...
17:55:40 <pumpkin> saml: no?
17:55:44 <Olathe> > div (round (0/0)) (10^309)
17:55:44 <kerlo> So you do it by applying Right to a Not a, or an a -> Void. You get the a -> Void from a -> Either a (Not a) and Either a (Not a) -> Void.
17:55:46 <pumpkinbot>   -1
17:55:50 <kerlo> Wow.
17:55:50 <Olathe> > div (round (0/0)) (10^308)
17:55:51 <Gracenotes> > 0**0
17:55:52 <pumpkinbot>   -3
17:55:52 <pumpkinbot>  Terminated
17:55:57 <pumpkin> > let x = (0/0) in x == x
17:55:59 <pumpkinbot>   False
17:56:02 <Olathe> > (0/0)/(10^308)
17:56:04 <pumpkinbot>   NaN
17:56:06 <Gracenotes> > 0^0 :: Double
17:56:06 <Olathe> Bah
17:56:08 <pumpkinbot>   1.0
17:56:17 <saml> > (0/0) == (0/0)
17:56:19 <pumpkinbot>   False
17:56:31 <saml> > (1/0) == (2/0)
17:56:33 <pumpkinbot>   True
17:56:39 <pumpkin> that's different
17:56:40 <Olathe> > round (0/0) == round (0/0)
17:56:40 <saml> oh that's Infinity
17:56:42 <pumpkinbot>   True
17:56:48 <pumpkin> http://en.wikipedia.org/wiki/IEEE_754
17:56:48 <pumpkinbot> Title: IEEE 754-2008 - Wikipedia, the free encyclopedia
17:57:07 <Olathe> There's a 2008 edition of IEEE-754 ?
17:58:04 <saml> > (1/0) == (-2/0)
17:58:06 <pumpkinbot>   False
17:58:07 <Gracenotes> http://127.0.0.1/
17:58:07 <Olathe> Hmm, it looks like that's the replacement for the 1985 version.
17:58:15 <Gracenotes> aww.
17:58:26 <kerlo> Hmm.
17:58:31 <Gracenotes> http://localhost/
17:58:42 <saml> > (1/0) + (-2/0) == (-2/0) * 0
17:58:44 <pumpkinbot>   False
17:58:48 <kerlo> http://normish.org/ihope/
17:58:48 <pumpkinbot> Title: Fun
17:58:52 <kerlo> Woot.
17:59:00 <saml> can i say no two NaNs equal?
17:59:01 <kerlo> Hmm...
17:59:14 <Raevel> saml: yes
17:59:20 <Gracenotes> kerlo: it's the "Title: " prefix :/
17:59:20 <ksf> nan is unequal to everything.
17:59:20 <saml> cool
17:59:29 <Olathe> http://10.0.0.1/
17:59:31 <saml> my favorite number is NaN now
17:59:36 <pumpkin> it's not a number
17:59:41 <pumpkin> that's what it stands for ;)
17:59:44 <saml> lol pun intended
17:59:52 <ski_> kerlo : yes .. note that the current continuation is used twice
17:59:58 <Olathe> http://192.168.100.1/
18:00:05 <saml> i think every type should have NaN
18:00:17 <ksf> there's _|_.
18:00:19 <Raevel> saml: other languages call it "null", i think
18:00:21 <saml> for example, for Char, there should be NaC
18:00:23 <Raevel> :*/
18:00:32 <pumpkin> Raevel: most languages have an IEEE float type
18:00:34 <saml> for [a], NaL
18:00:42 <Olathe> We also need a Word0
18:00:43 <diltsman> I'm trying to throw an IOException from inside a function, but I can't figure out how to get it to work.  Some code is at http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1095#a1095.  I just need it to exit out to main and give me a string when this gets called.
18:00:50 <Olathe> For zero-bit unsigned integers.
18:00:51 <Raevel> pumpkin: i meant on other types
18:01:00 <saml> so that you can have a value that isn't equal to itself
18:01:09 <ski_> saml : and for `Void', `NaV'
18:01:11 <intoverflow> there's a functor that sends every type to a new type which is identical, except for the addition of a NotA_
18:01:12 <ksf> having a bottom type only makes sense if there are non-total mappings from your domain to codomain.
18:01:48 <saml> is there a mathematical structure where a value doesn't equal to itself?
18:01:58 <ksf> saml, that's just a matter of writing an Eq instance to your tastes.
18:02:11 <ski_> ksf : by "bottom type" you mean ?
18:02:12 <kerlo> http://normish.org/ihope/
18:02:13 <pumpkinbot> Title: Your IP Address Is 67.207.128.206
18:02:15 <intoverflow> x /= x isn't an equivalence relation
18:02:19 <ksf> errr... having bottom.
18:02:29 <kerlo> Which is the same IP address as you could get by doing /whois pumpkinbot, of course.
18:02:48 <Olathe> kerlo: Haha
18:02:58 <Gracenotes> hm...
18:03:01 <Gracenotes> http://gracenotes.freehostia.com/
18:03:01 <pumpkinbot> Title: Hi, #haskell
18:03:02 <pumpkin> lol
18:03:47 <intoverflow> pumpkin: how much string checking does pumpkinbot do on the titles of the sites?
18:03:54 <Raevel> try making pumpkin say @part :-8
18:03:56 <saml> instance Eq Char where  ' ' == ' ' = False   yay ' ' is NaC
18:03:58 <Raevel> +bot
18:03:59 <pumpkin> intoverflow: no clue, it's just a vanilla lambdabot
18:04:19 <kerlo> http://normish.org/ihope/
18:04:20 <pumpkinbot> Title: Your Root Password Is G92js9Kd8S
18:04:25 <kerlo> :-P
18:04:28 <pumpkin> hah
18:04:47 <Raevel> imagine if that happened to be the root password
18:04:56 <Gracenotes> hey, that's my root password too!
18:05:00 <pumpkin> I turned off password auth on its sshd
18:05:01 <pumpkin> :P
18:05:18 <kerlo> Did you turn off su as well?
18:05:26 <Gracenotes> http://gracenotes.freehostia.com
18:05:26 <pumpkinbot> Title: Hi, #haskell
18:05:30 <Olathe> What browser version does lambdabot report ?
18:05:46 <Gracenotes> http://gracenotes.freehostia.com
18:05:54 <SamB> http://naesten.dyndns.org:8080/
18:06:01 <Gracenotes> heh... so it doesn't like my title
18:06:17 <saml> what's the title?
18:06:45 <Gracenotes> either that or the server doesn't like me uploading files
18:07:03 <newsham> olathe: when looking up google and <title> ?
18:07:25 <kerlo> http://normish.org/ihope/?Link1=foo
18:07:25 <Olathe> newsham: Yeah
18:07:26 <pumpkinbot> Title: The 'Link1' Parameter Is foo
18:07:32 <newsham> looks like no usre agent header is sent: http://code.haskell.org/lambdabot/lambdabot-utils/Lambdabot/MiniHTTP.hs
18:07:33 <pumpkinbot> http://tinyurl.com/btg6kz
18:07:53 <Olathe> http://normish.org/ihope/?zomg=foo+hi
18:07:53 <pumpkinbot> Title: The 'Link1' Parameter Is
18:07:57 <Olathe> O-o
18:08:03 <Gracenotes> http://normish.org/ihope/?language=Haskell&speaking=English
18:08:03 <pumpkinbot> Title: The 'Link1' Parameter Is
18:08:08 <saml> http://simpletrace.appspot.com/trace/61f865b0-4477-482c-adc1-e9fe4176131e
18:08:09 <pumpkinbot> http://tinyurl.com/dfr625
18:08:13 <Olathe> http://normish.org/ihope/?Link1=zomg+hi
18:08:14 <pumpkinbot> Title: The 'Link1' Parameter Is zomg hi
18:08:24 <kerlo> http://normish.org/ihope/?Link1=pwd
18:08:25 <pumpkinbot> Title: The Answer Is /home/ihope
18:08:32 <Olathe> http://normish.org/ihope/?Link1=zomg+%00hi
18:08:32 <pumpkinbot> Title: The Answer Is
18:08:34 <Gracenotes> :D
18:08:37 <kerlo> http://normish.org/ihope/?Link1=echo+foo
18:08:38 <pumpkinbot> Title: The Answer Is foo
18:08:42 <Gracenotes> daaangerous
18:08:48 <kerlo> Definitely.
18:08:48 <Olathe> Umm...
18:08:51 <kerlo> :-D
18:08:52 <saml> http://67.207.128.206/
18:08:56 <Gracenotes> http://normish.org/ihope/?Link1=users
18:08:57 <pumpkinbot> Title: The Answer Is comex ihope ihope jay
18:09:06 <Gracenotes> sweet :)
18:09:11 <kerlo> Aye.
18:09:20 <Olathe> What's that thing that tells the machine name and processor type ?
18:09:27 <Olathe> http://normish.org/ihope/?Link1=uname -a
18:09:27 <pumpkinbot> Title: The Answer Is Linux
18:09:28 <ski_> uname -a
18:09:31 <Olathe> http://normish.org/ihope/?Link1=uname+-a
18:09:32 <pumpkinbot> Title: The Answer Is Linux normish 2.6.24-19-xen #1 SMP Wed Aug 20 21:08:51 UTC 2008 x8 ...
18:09:34 <kerlo> The Answer Is Linux!
18:09:38 <SamB> 2009-01-31 21:05:57-0500 [HTTPChannel,109,131.252.208.118] 131.252.208.118 - - [01/Feb/2009:02:05:54 +0000] "HEAD / HTTP/1.1" 200 - "-" "IrssiUrlLog/0.2"
18:09:38 <SamB> 2009-01-31 21:05:58-0500 [HTTPChannel,110,121.98.136.241] 121.98.136.241 - - [01/Feb/2009:02:05:57 +0000] "HEAD / HTTP/1.1" 200 - "-" "IrssiUrlLog/0.2"
18:09:38 <SamB> 2009-01-31 21:06:26-0500 [HTTPChannel,111,68.237.241.77] 68.237.241.77 - - [01/Feb/2009:02:06:24 +0000] "GET / HTTP/1.1" 200 18230 "-" "Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.0.5) Gecko/2008123110 GranParadiso/3.0.5"
18:09:44 <kerlo> http://normish.org/ihope/?Link1=whoami
18:09:45 <pumpkinbot> Title: The Answer Is www-data
18:09:50 <kerlo> So, run all you want as www-data.
18:09:56 <pumpkin> except it lies :)
18:09:59 <Olathe> http://normish.org/ihope/?Link1=ls
18:09:59 <pumpkinbot> Title: The Answer Is arson.txt credit dodadodidi etra hugme index.lhs index.php ircbot. ...
18:10:00 <kerlo> It does?
18:10:06 <Olathe> arson.txt ?
18:10:17 <kerlo> Yep, arson.txt.
18:10:18 <saml> http://normish.org/ihope/?Link1=cat+/dev/urandom
18:10:19 <pumpkinbot> Title: The Answer Is á‡“ï¿½9ï¿½Zï¿½qbï¿½Î4ï¿½_ï¿½>Yï¿½ï¿½9ï¿½3ï¿½ï¿½Z â¨–ï¿½_9Zmï¿½ï ...
18:10:24 <Gracenotes> http://normish.org/ihope/?Link1=ps -A
18:10:25 <pumpkinbot> Title: The Answer Is PID TTY TIME CMD 3737 ? 00:00:33 apache2 8052 ? 00:00:00 apache2 1 ...
18:10:26 <pumpkin> kerlo: yes
18:10:33 <pumpkin> that's not the output of my uname :P
18:10:35 <kerlo> http://normish.org/ihope/?Link1=cat+arson.txt
18:10:35 <pumpkinbot> Title: The Answer Is
18:10:38 <saml> http://normish.org/ihope/?Link1=rm+/
18:10:38 <Olathe> http://normish.org/ihope/?Link1=ruby+-v
18:10:39 <pumpkinbot> Title: The Answer Is
18:10:39 <pumpkinbot> Title: The Answer Is ruby 1.8.6 (2007-09-24 patchlevel 111) [x86_64-linux]
18:10:44 <pumpkin> oh you're doing your own thing
18:10:47 <Gracenotes> saml: hey now.
18:10:49 <kerlo> Why do I even have a file called arson.txt?
18:10:51 <SamB> http://normish.org/ihope/?Link1=printenv
18:10:52 <pumpkinbot> Title: The Answer Is APACHE_PID_FILE=/var/run/apache2.pid PATH=/usr/local/bin:/usr/bin: ...
18:11:00 <saml> Gracenotes, oh is it your machine?
18:11:04 <Gracenotes> no :P
18:11:05 <kerlo> http://normish.org/ihope/?Link1=ls+dodadodidi
18:11:06 <pumpkinbot> Title: The Answer Is amber.txt arson.txt breakin.txt maycomb.txt piano.txt
18:11:07 <SamB> http://normish.org/ihope/?Link1=printenv|grep+Mozilla
18:11:10 <saml> can i try forkbomb?
18:11:19 <kerlo> I'm planning not only an arson and a breakin, but an amber, a maycomb, and a piano.
18:11:25 <Gracenotes> let's not try to be malicious..
18:11:48 <kerlo> You can forkbomb if you promise to give me $5 afterward.
18:12:04 <ski_> http://normish.org/ihope/?Link1=which+ghc
18:12:05 <pumpkinbot> Title: The Answer Is /usr/bin/ghc
18:12:12 <saml> kerlo, is it your machine?
18:12:18 <kerlo> http://normish.org/ihope/?Link1=ghc
18:12:19 <pumpkinbot> Title: The Answer Is
18:12:24 * jeffwheeler is inclined to send somebody else a link with an embedded forkbomb :P
18:12:30 <kerlo> saml: yes.
18:12:41 <jeffwheeler> (but I won't . . . :( )
18:12:42 <newsham> how about an alert() bomb?
18:12:42 <gwern> hm. I don't have any arson.txt, but I do have the peculiar '/home/gwern/torrent/ebook/science/computerscience/programminglanguages/C, C++, C Sharp/Logan - Cross Platform Development in C++ (Pearson, 2007).pdf'
18:12:46 <Olathe> http://normish.org/ihope/?Link1=ruby+-e+%22p+File.read(%27arson.txt%27)%22
18:12:48 <pumpkinbot> Title: The Answer Is, http://tinyurl.com/d3sc39
18:12:51 <ski_> http://normish.org/ihope/?Link1=echo+2*3|ghci
18:12:52 <gwern> what am I going to do with a C++ textbook? :)
18:12:55 <newsham> javascript:while(1)alert(1);
18:13:03 <saml> oh cool
18:13:04 * kerlo blinks
18:13:29 <jeffwheeler> http://normish.org/ihope/?Link1=ls+..
18:13:29 <saml> gwern, read it
18:13:29 <pumpkinbot> Title: The Answer Is arson.txt credit dodadodidi etra hugme index.lhs index.php ircbot. ...
18:13:35 <jeffwheeler> http://normish.org/ihope/?Link1=ls+../..
18:13:35 <pumpkinbot> Title: The Answer Is ais523 asiekierka bd cargill chameloid comex ehird ihope jay norgg ...
18:13:36 <cads> you know, now when I do math I throw in haskell style type definitions in with my functions to qualify the domains...
18:13:40 <cads> i feel twisted
18:13:43 <jeffwheeler> http://normish.org/ihope/?Link1=pwd
18:13:44 <pumpkinbot> Title: The Answer Is /home/ihope
18:13:53 <gwern> saml: or I could sacrifice it to the haskell daemons
18:14:08 <kerlo> This is the most exciting thing I've done in months. :-P
18:14:11 <Olathe> Haha
18:14:18 <jeffwheeler> Oh, this is a shared server?
18:14:20 <newsham> lambda x : Rreal -> ...  ?
18:14:26 * jeffwheeler doesn't want to screw with it.
18:14:35 <kerlo> It's my shared server. :-P
18:14:41 <pumpkin> RReal? is that real real?
18:14:42 <jeffwheeler> You own it, or just are on it?
18:14:46 <pumpkin> as opposed to just computable reals?
18:14:53 <kerlo> More like rent it. It's a Slicehost.
18:14:54 <gwern> kerlo: I would mock your travesty of a life but the horror of an existence like that doesn't need me rubbing it in
18:15:03 <jeffwheeler> kerlo: ah, then it's safe to browse. :)
18:15:11 <kerlo> gwern: s/exciting/scary/, in that case.
18:15:13 <pumpkin> kerlo: shared on slicehost?
18:15:17 <pumpkin> o.O
18:15:19 <kerlo> jeffwheeler: http://normish.org/root
18:15:19 <pumpkinbot> Title: Index of /root
18:15:24 <gwern> my point stands!
18:15:26 <saml> http://normish.org/ihope/?Link1=
18:15:26 <pumpkinbot> Title: The Answer Is Warning: passthru() [function.passthru]: Cannot execute a blank co ...
18:15:33 <Olathe> http://normish.org/ihope/?Link1=ls+-alF
18:15:34 <pumpkinbot> Title: The Answer Is total 148 drwxr-xr-x 15 ihope ihope 4096 Feb 1 02:09 ./ drwxr-xr-x ...
18:15:38 <Gracenotes> http://normish.org/ihope/?Link1=python -c 'import urllib;print(urllib.urlopen("http://www.google.com").read())'
18:15:39 <pumpkinbot> Title: The Answer Is
18:15:42 <kerlo> pumpkin: Slicehost considers it mine.
18:15:44 <jeffwheeler> pumpkin: Slicehost provides VPS's
18:15:51 <Gracenotes> http://normish.org/ihope/?Link1=python -c 'print(4)'
18:15:52 <pumpkinbot> Title: The Answer Is
18:15:53 <kerlo> I consider it shared.
18:15:55 <pumpkin> jeffwheeler: I know that :P but I don't normally consider that shared hosting
18:15:56 <Gracenotes> X:
18:16:02 <pumpkin> jeffwheeler: pumpkinbot is on slicehost :)
18:16:06 <Gracenotes> http://normish.org/ihope/?Link1=python+-c+'print(4)'
18:16:07 <pumpkinbot> Title: The Answer Is
18:16:07 <Olathe> http://normish.org/ihope/?Link1=python+-c+'print(4)'
18:16:08 <pumpkinbot> Title: The Answer Is
18:16:08 <jeffwheeler> pumpkin: ah. :)
18:16:10 <kerlo> http://normish.org/ihope/?Link1=cat-sudoers
18:16:10 <pumpkinbot> Title: The Answer Is
18:16:18 <kerlo> http://normish.org/ihope/?Link1=/usr/bin/nomic/rtbls/cat-sudoers
18:16:19 <Gracenotes> http://normish.org/ihope/?Link1=python+-c+"print(4)"
18:16:19 <pumpkin> kerlo: there are lots of visible things in the home directories...
18:16:19 <pumpkinbot> Title: The Answer Is # /etc/sudoers # # This file MUST be edited with the 'visudo' comm ...
18:16:22 <Olathe> http://normish.org/ihope/?Link1=sudo+-v
18:16:23 <pumpkinbot> Title: The Answer Is
18:16:25 <saml> http://normish.org/ihope/?Link1=echo+"print+42"|runghc
18:16:33 <kerlo> Stop trying to use GHC; it doesn't work.
18:16:51 <Olathe> http://normish.org/ihope/?Link1=echo+"print+42"|ruby
18:16:52 <kerlo> Also, figure out how to make it combine stdout and stderr into stdout so we can see stderr.
18:17:01 <kerlo> http://normish.org/ihope/?Link1=/usr/bin/nomic/rtbls/cat-sudoers|tail
18:17:01 <pumpkinbot> http://normish.org/ihope/?Link1=/usr/bin/nomic/rtbls/cat-sudoers|tail
18:17:09 * kerlo blinks
18:17:14 <pumpkin> should I just @part pumpkinbot?
18:17:19 <kerlo> Sorry.
18:17:46 <kerlo> I've "fixed" it.
18:17:58 <kerlo> So move along, nothing more to see here.
18:18:10 <roconnor> byorgey is found of existential types.
18:18:11 <jeffwheeler> with a fatal error under any condition?
18:18:13 <saml> i thought it was me. Link1=startx
18:18:15 <roconnor> fond
18:18:22 <kerlo> Something like that.
18:18:27 <Olathe> saml: Heh
18:18:38 <roconnor> jeffwheeler: hey, how's it going?
18:18:38 <drhodes> List.union exists, no List.difference?
18:18:47 <jeffwheeler> roconnor: good.
18:18:53 <Olathe> @src union
18:18:53 <pumpkinbot> union = unionBy (==)
18:18:55 <pumpkin> drhodes \\
18:18:57 <ski_> @type (Data.List.\\)
18:18:58 <pumpkinbot> forall a. (Eq a) => [a] -> [a] -> [a]
18:19:04 <jeffwheeler> After years of pretending, I finally have a legitimate backup solution, as of today.
18:19:04 <drhodes> Ah, thanks!
18:19:11 <roconnor> \o/
18:19:14 <Olathe> > [1..5] \\ [2..6]
18:19:15 <jeffwheeler> It's rather embarrassing that I had such a mess until now.
18:19:15 <pumpkinbot>   [1]
18:19:43 <kerlo> If you want to run more commands on my server, then actually go to http://normish.org/ihope/?Link1=something and you'll see the output.
18:19:43 <pumpkinbot> Title: The Answer Is 42
18:19:51 <jeffwheeler> Oh, and this: http://pastie.org/376297 :D
18:19:51 <pumpkinbot> Title: #376297 - Pastie
18:19:53 <kerlo> (Does 42 count as a fatal error?)
18:20:10 <jeffwheeler> Fatal Success!
18:20:20 <Olathe> > let (\\\) a b = union (a \\ b) (b \\ a) in [1..5] \\\ [2..6]
18:20:22 <pumpkinbot>   [1,6]
18:20:32 <roconnor> hmm
18:20:33 <SamB> what the heck is Data.FunctorM ?
18:20:44 <wli> Symmetric difference?
18:20:49 <Olathe> Yes.
18:20:50 <ski_> aye
18:21:01 <roconnor> I guess DiaRenderM is an improvement on Cairo.Render
18:21:03 <drhodes> > take 20 ([1..] \\ (take 40 (sort (union [6,9..40] [4,6..40]))))
18:21:05 <pumpkinbot>   [1,2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,42,43,44,45]
18:21:15 <roconnor> intresting approach
18:21:17 <Olathe> Ehh
18:21:41 <kerlo> Say, this all reminds me of the time I got the whole channel to stop using the letter H.
18:21:42 <Olathe> Ahh, remove multiples of 2 and 3.
18:21:45 <drhodes> yeah, it needs some scanfold union magic
18:21:53 <Olathe> kerlo: How did you do that ?
18:22:03 <kerlo> Let me try to remember.
18:22:16 <kerlo> I know it started wit te greeting "Ello."
18:22:21 <Olathe> Ahh.
18:22:38 <jeffwheeler> I assume you mean "a."
18:22:59 <jeffwheeler> Or possibly "aaaa"
18:23:13 <kerlo> I guess I ten suggested we omit te letter H from everyting we say.
18:23:23 <ski_> > toUpper 'h'
18:23:25 <pumpkinbot>   'H'
18:23:33 <zax> Time to start laughing like the greeks, xao xao xao?
18:23:43 <jeffwheeler> kerlo: rewording is a far better task.
18:23:56 <saml> > toUpper '\r'
18:23:58 <pumpkinbot>   '\r'
18:24:01 <kerlo> Or like te jbopre, .u'i .u'i .u'i
18:24:29 <jeffwheeler> kerlo: it's even more rewarding, I would say
18:24:40 <kerlo> jeffwheeler: I tried tat, but it's nearly impossible to go witout tis/tat/tese/tose and wat/wic, not to mention te.
18:24:49 * SamB wonders why lhc is failing to build on hackage: http://hackage.haskell.org/packages/archive/lhc/0.6.20090126/logs/failure/ghc-6.10
18:24:50 <pumpkinbot> http://tinyurl.com/bh8kyb
18:24:53 <jeffwheeler> kerlo: I've been doing quite well at it
18:25:10 <jeffwheeler> :P
18:25:11 <kerlo> Okay, I'll try rewording.
18:25:13 <roconnor> SamB doesn't the build log say why?
18:25:19 <kerlo> I don't expect you to get very far. :-P
18:25:33 <kerlo> Just try asking a question.
18:25:34 <jeffwheeler> I've gotten by so far.
18:25:35 <SamB> roconnor: it says something about the loader and duplicate symbols
18:25:50 <kerlo> And not a yes-or-no question.
18:26:04 <jeffwheeler> Err?
18:26:27 <kerlo> You call "err" a question? :-P
18:26:28 <Olathe> http://www.useragent.org/
18:26:30 <pumpkinbot> Title: What is my User Agent? Your User Agent is:
18:26:33 <Olathe> Bah
18:26:42 <kerlo> Also, reword "a car that doesn't use a lot of gasoline" for me.
18:26:50 <jeffwheeler> Prius.
18:27:04 <astrobunny> hello
18:27:19 <astrobunny> I'm new to haskell, so here's a question.
18:27:33 <kerlo> Reword "Not all such cars are Priuses" for me. :-P
18:27:36 <astrobunny> fac n = if n == 0 then 1 else n * fac (n-1)
18:27:36 <astrobunny> main = putStrLn (fac 3)
18:27:43 <astrobunny> causes a compile error
18:27:51 <kerlo> astrobunny: main = print (fac 3)
18:27:53 <jeffwheeler> kerlo: do you prefer "Prius-like cars"?
18:28:03 * kerlo shrugs
18:28:04 <astrobunny> thanks kerlo
18:28:06 <saml> astrobunny, putStrLn (show (fac 2))
18:28:13 <astrobunny> ahhh
18:28:14 <astrobunny> thanks saml
18:28:20 <astrobunny> ^_^
18:28:33 <saml> i love you man
18:28:44 <kerlo> ("/me shrugs" is too embedded in me for any promise of being able to stop to exist. :-P)
18:28:51 <arw> putStrLn wants a string. show gives you a string for the integer that comes out of fac
18:29:01 <astrobunny> ahhh
18:29:03 <astrobunny> show() eh
18:29:08 <astrobunny> i learned a useful function
18:29:11 <arw> print is the same as putStrLn + show
18:29:24 <astrobunny> mmm
18:29:31 <saml> > show your smile
18:29:32 <pumpkinbot>   mueval: Prelude.read: no parse
18:29:44 * kerlo blinks
18:29:47 <ski_> @src print
18:29:47 <pumpkinbot> print x = putStrLn (show x)
18:30:18 <astrobunny> thanks guys, i haven't seen any chan so willing to help ^_^
18:30:32 <methos> the @src feature is cool :)
18:30:41 <idnar> @type your
18:30:43 <pumpkinbot> Not in scope: `your'
18:30:51 <idnar> huh
18:30:51 <saml> > show `your` smile where smile = "^_^"; your = ($)
18:30:53 <pumpkinbot>   "\"^_^\""
18:31:07 <idnar> > your
18:31:08 <pumpkinbot>   mueval: Prelude.read: no parse
18:31:15 <idnar> oh
18:31:18 <saml> f g x  can I make g to be $ ?
18:31:35 <saml> but still using g, not $. and no `g`
18:31:35 <Olathe> main = id (putStrLn (id (show (id (fac (id (3)))))))
18:31:47 <ski_> > f g x  where f = id; g = ($); x = ()
18:31:49 <pumpkinbot>   Couldn't match expected type `()' against inferred type `a -> b'
18:31:58 <Olathe> > decodeFloat (0/0)
18:31:59 <pumpkinbot>   (-6755399441055744,972)
18:32:00 <idnar> > let show' = show in let show = const show'; smile = "^_^"; your = undefined in show your smile
18:32:01 <pumpkinbot>   "\"^_^\""
18:32:09 <Olathe> > decodeFloat (-1/0)
18:32:11 <pumpkinbot>   (-4503599627370496,972)
18:33:04 <kerlo> > kerlononce
18:33:05 <pumpkinbot>   mueval: Prelude.read: no parse
18:33:06 <jeffwheeler> > -1/0
18:33:08 <pumpkinbot>   -Infinity
18:33:14 <kerlo> kerlononce won't be much of a nonce if I keep using it, really.
18:33:16 <jeffwheeler> . . . really?
18:33:29 <tehgeekmeister> if a library is built with base == 4 it won't be found if i try to build another library that depends on it and is built with base < 4, correct?
18:33:58 <saml> > i `love` britney `spears` yay where i = putStrLn; love = ($); britney = "^_"; spears = (++); yay = "^"
18:34:00 <pumpkinbot>   Couldn't match expected type `[a]' against inferred type `IO ()'
18:34:00 <jeffwheeler> @type (-1/0)
18:34:01 <pumpkinbot> forall a. (Fractional a) => a
18:34:06 <Saizan_> tehgeekmeister: no
18:34:19 <Gracenotes> no... no... X:X
18:34:21 <tehgeekmeister> Saizan_: hum.  then i don't know why i'm having the problem i am.
18:34:34 <jeffwheeler> saml: you can't use IO functions for bots
18:34:38 <Saizan_> tehgeekmeister: which is?
18:34:41 <BMeph> roconnor: haskell98 demands process-1.0.1.0, which no other paclage does.
18:34:51 <saml> > i `love` britney `spears` yay where i = id; love = ($); britney = "^_"; spears = (++); yay = "^"
18:34:52 <pumpkinbot>   "^_^"
18:35:09 <saml> that only works for even number of words
18:35:11 <BMeph> roconnor: (answering SamB's issue for him. ;)
18:35:16 <tehgeekmeister> http://www.nabble.com/can%27t-build-testpack-td21769519.html <== here's the full thread, so i don't have to redescribe it all (and can't properly in irc anyway)
18:35:19 <ski_> @quote spears
18:35:19 <pumpkinbot> No quotes match. You type like i drive.
18:36:04 <Olathe> > significand 1
18:36:06 <pumpkinbot>   0.5
18:36:17 <Olathe> > significand 16
18:36:19 <pumpkinbot>   0.5
18:36:44 <glguy> ski_, I looked back at the inferred type of shift
18:36:53 <glguy> ski_, in the general case the m and n will match
18:37:10 <glguy> but the inferred type is more general, and no effort was made to limit it
18:37:19 <kerlo> > i love `britney` spears where i = id; love = "^_"; britney = ($); spears = "^"
18:37:21 <pumpkinbot>   Couldn't match expected type `a -> b'
18:37:31 <kerlo> > i love `britney` spears where i = id; love = "^_"; britney = (++); spears = "^"
18:37:31 <ski_> glguy : which inferred type ?
18:37:32 <pumpkinbot>   "^_^"
18:37:37 <glguy> ski_, of shift
18:38:10 <tehgeekmeister> Saizan_: apparently now i'm at the same place the other poster was in that thread, cabal install by itself works, cabal configure and then cabal build don't
18:38:33 <ski_> @type \f -> Cont $ \c -> f (return . c) `runCont` id
18:38:35 <pumpkinbot> forall a (m :: * -> *) a1. (Monad m) => ((a -> m a1) -> Cont a1 a1) -> Cont a1 a
18:38:39 <ski_> that one ?
18:39:11 <Saizan_> tehgeekmeister: the difference is that "cabal install" prefers base-3, i think
18:39:33 <drhodes> > take 50 [2..] \\ sort (foldr union [] [(\x -> [2*x, (2*x)+x .. 50]) x | x <- [2..50]])
18:39:35 <pumpkinbot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,51]
18:39:35 <Saizan_> tehgeekmeister: so, the problem is building testpack on ghc-6.10.x?
18:39:39 <tehgeekmeister> Saizan_: oh, also, apparently the problem is linked to trying to build the profiling libraries.  it doesn't work with cabal install -p, but it does with cabal install
18:39:40 <glguy> ski_, probably. the m/n in monad lib corresponds to the m/Cont in that type
18:39:42 <tehgeekmeister> Saizan_: yes
18:40:04 <tehgeekmeister> Saizan_: doesn't work for me with cabal configure -p, cabal build, cabal install, but does if i just do cabal install
18:40:35 * Nafai subscribes to the debian-haskell mailing list
18:40:41 <Saizan_> tehgeekmeister: btw, doing configure/build before install is pointless
18:40:50 <tehgeekmeister> Saizan_: good to know.
18:40:54 <BMeph> drhodes: Surely, you want [x*x,... not just 2*x, right? ;)
18:40:55 <Saizan_> tehgeekmeister: install reconfigures from scratch
18:41:17 * tehgeekmeister is learning that installing haskell packages isn't as painful as he always thot
18:41:26 <tehgeekmeister> at least if you do it right
18:41:43 <tehgeekmeister> tho cabal install STILL won't update, but that's another issue entirely.
18:41:43 <glguy> shift :: (RunContM m i n j) => ((a -> n i) -> m i) -> m a
18:41:44 <jeffwheeler> Once you've installed Cabal once, it is forever easy.
18:42:12 <jeffwheeler> And you subsequently fall in love for cabal-install.
18:42:18 <drhodes> BMeph: yep that's nicer.
18:42:19 <Saizan_> thecrypto: won't update?
18:42:28 <redditbot> Cabal-install is awesome
18:42:36 <Saizan_> tehgeekmeister: however, what error are you geting with -p?
18:42:47 <tehgeekmeister> Saizan_: last one that's posted in that thread i referenced
18:44:27 <Saizan_> tehgeekmeister: well that means what it says, you didn't install the profiling version of random
18:44:51 <tehgeekmeister> Saizan_: yes, which i already tried to remedy, but apparently didn't do the right way.
18:45:08 <tehgeekmeister> Saizan_: the thread's been updated again with a solution that worked flawlessly for me.
18:45:13 <tehgeekmeister> everything's good now.
18:45:27 <tehgeekmeister> well, aside from cabal-install not working the way it should, but i'll worry about that later
18:45:48 <Olathe> Is a UArray slot lazy once it's written to ?
18:46:28 <bd_> Olathe: what do you mean?
18:46:29 <Saizan_> tehgeekmeister: you might want to mail the maintainer, telling him the .cabal file is broken
18:46:35 <Saizan_> tehgeekmeister: of testpack i mean
18:46:36 <ztirF> @pl \(x,y)->(x,f y)
18:46:36 <pumpkinbot> second f
18:46:41 <tehgeekmeister> Saizan_: will do, thanks for reminding me
18:46:45 <tehgeekmeister> meant to and almost forgot
18:46:58 <ztirF> @hoogle second
18:46:58 <pumpkinbot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
18:46:58 <pumpkinbot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
18:46:58 <pumpkinbot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
18:47:07 <Olathe> bd_: Well, I'm going to be reading in a bunch of binary data from a file. I don't want it to reread the file, so I was thinking of sticking the data in a UArray.
18:47:33 <bd_> okay, but what do you mean by 'lazy once it's written to'?
18:47:56 <Gracenotes> > let []\\n = [n]; (x:xs)\\n = let (p,r) = divMod x n in if r == 0 then p:xs else x:xs\\n; xs \\\ ys = foldl (\\) xs ys; choose n k = product $ [1..n] \\\ ([1..k]++[1..n-k]) in map (\n -> map (choose n) [0..n]) [0..12]
18:47:58 <pumpkinbot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,240,20,15,6,1...
18:48:13 <Gracenotes> pascal :D
18:48:23 <Olathe> Well, I haven't used a UArray yet and when I go to show the structure of the file (generated from the data in it), I think it rereads the file each time.
18:48:52 <luqui> Olathe, that is very unlikely.
18:48:58 <Olathe> Ahh.
18:49:03 <Olathe> Maybe it's just ghci.
18:49:27 <Olathe> I guess I'll check compiled.
18:49:34 <Olathe> @type forever
18:49:35 <pumpkinbot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:49:50 <Olathe> > forever [a]
18:49:53 <pumpkinbot>   mueval: Prelude.read: no parse
18:49:53 <pumpkinbot>  mueval: *** Exception: stack overflow
18:51:11 <ztirF> @pl \(x,y,z) -> (f x, f y, f z)
18:51:11 <pumpkinbot> (line 1, column 6):
18:51:11 <pumpkinbot> unexpected ","
18:51:11 <pumpkinbot> expecting letter or digit, operator or ")"
18:51:11 <pumpkinbot> ambiguous use of a non associative operator
18:51:31 <ztirF> @pl \((x,y,z) -> (f x, f y, f z))
18:51:31 <pumpkinbot> (line 1, column 7):
18:51:31 <pumpkinbot> unexpected ","
18:51:31 <pumpkinbot> expecting letter or digit, operator or ")"
18:51:31 <pumpkinbot> ambiguous use of a non associative operator
18:51:55 <ztirF> @pl \( (x,y,z) -> (f x, f y, f z) )
18:51:55 <pumpkinbot> (line 1, column 8):
18:51:55 <pumpkinbot> unexpected ","
18:51:55 <pumpkinbot> expecting letter or digit, operator or ")"
18:51:55 <pumpkinbot> ambiguous use of a non associative operator
18:52:02 <ztirF> doh
18:52:03 <Gracenotes> hm. The Pascal Triangle as a State [Int] [Int] might be interesting, to get (say) the nth row.
18:52:08 <ddarius>  @pl doesn't understand 3-tuples.
18:52:21 <BMeph>  @pl ( \(x,y,z) -> (f x, f y, f z) )
18:52:49 <BMeph> Oh noes, I killt pumpkinbot! ;(
18:52:51 <Gracenotes> or might that be more suitable as a reader...
18:52:52 <ztirF> yeah wow
18:53:12 <Olathe> > 5
18:53:14 <pumpkinbot>   5
18:53:25 <BMeph> yay, Olathe! :)
18:53:33 <ztirF> et resurrexit
18:53:45 <roconnor> @seen byorgey
18:53:45 <pumpkinbot> byorgey is in #haskell. I last heard byorgey speak 1h 26m 58s ago.
18:53:52 <Olathe> @index forever
18:53:52 <pumpkinbot> bzzt
18:54:02 <Olathe> The ever-useful bzzt library.
18:54:16 <ddarius> cabal install bzzt
18:54:24 <Olathe> @hoogle forever
18:54:24 <pumpkinbot> Control.Monad forever :: Monad m => m a -> m ()
18:56:41 <Olathe> Yeah, it keeps rereading the file, according to the IO bytes read thingy.
18:56:59 <Olathe> Even switching to a string ByteString doesn't quite work.
18:57:04 <Olathe> strict
18:58:38 <Chani> so, I have some code from my teacher that I'm supposed to make use of, but his code didn't have deriving Show anywhere... I added it to all his data, but I've got one problem... there's this type Memory = Ide -> MemVal and it's refusing to be shown
18:58:47 <Chani> the error I get is No instance for (Show (Ide -> MemVal))
18:59:10 <Olathe> Chani: You can't show functions, I think.
18:59:15 <Chani> I can't add deriving Show to the end of a type, so I dunno what to do
18:59:31 <jeffz`> yeah... you need to write your own instance of Show for the function
18:59:37 <Chani> oh eew
19:00:03 <Chani> I want to be able to run stuff in ghci, and this code just wasn't written with that in mind
19:00:24 <Chani> heck, it wasn't written with any feedback in mind... the errors are just Error with no indication of why they're errors
19:00:37 <Chani> jeffz`: so how do I go about doing that?
19:00:42 <jeffz`> import Text.Show.Functions
19:00:52 <Olathe> Wait, you can show functions ?
19:01:01 <jeffz`> yes, but it's not very useful
19:01:34 <Chani> even if I just wrote a dummy thing that showed "foo" it'd be enough for now
19:01:52 <jeffz`> Chani: import Text.Show.Functions, was directed at you
19:01:53 <Olathe> Ahh...instance Show (a -> b) where showsPrec _ _ = showString \"\<function\>\"
19:02:25 <Chani> jeffz`: so what do I do with Text.Show.Functions? :)
19:02:39 <jeffz`> just import it
19:02:45 <Chani> ?
19:02:47 <Chani> hmm.
19:02:59 <Olathe> In ghci, :m +Text.SHow.Functions
19:03:04 <Saizan_> it defines an instance of Show for functions
19:03:13 <Saizan_> so that you can use deriving Show for your type
19:03:16 <Chani> jeffz`: it runs! :)
19:03:20 <Olathe> I wonder if it's possible to show the type of the function.
19:03:31 <Olathe> > typeOf id
19:03:33 <pumpkinbot>   Add a type signature
19:03:41 <Chani> thanks
19:03:48 <Saizan_> > typeOf (id :: Int -> Int)
19:03:50 <pumpkinbot>   Int -> Int
19:03:50 <Olathe> > (typeOf f, f 3) where f = id
19:03:52 <pumpkinbot>   Add a type signature
19:04:02 <Olathe> > (typeOf f, f (3::Int)) where f = id
19:04:03 <pumpkinbot>   Add a type signature
19:04:06 <Olathe> I did
19:04:17 <Saizan_> you need to add one to f
19:04:31 <Olathe> Isn't it determined by the use of f ?
19:04:37 <Saizan_> you can't abuse the monomorphism restriction without a typeclass context
19:04:49 <Saizan_> no, f as polymorphic as id there
19:04:56 <Olathe> Oh.
19:05:20 <ray> good haskellings all
19:06:14 <Chani> next question... if I were to turn this into a real program with a main that could be compiled, how would I read all of stdin as a string? (so that I could pipe the contents of a file into the program)
19:06:23 <pumpkin> getContents
19:06:35 <pumpkin> :t getContents
19:06:37 <pumpkinbot> IO String
19:06:38 <Olathe> program.exe < file_to_use_as_stdin
19:06:44 <ski_> @type interact
19:06:45 <pumpkinbot> (String -> String) -> IO ()
19:06:51 <tromp> or use interactr
19:06:51 <Olathe> ./program < file_to_use_as_stdin
19:06:54 <pumpkin> that's even nicer yeah
19:06:55 <tromp> :t interact
19:06:57 <pumpkinbot> (String -> String) -> IO ()
19:07:14 <pumpkin> @src interact
19:07:14 <pumpkinbot> interact f = do s <- getContents; putStr (f s)
19:07:34 * Nafai sighs
19:07:57 <Nafai> I just had another person get frustrated by the "can't make definitions in ghci in a normal way" thing
19:09:01 <Chani> doh. I just realised that I need more than one source of input... might as well use readFile instead
19:09:28 <roconnor> @tell byorgey Cairo ignores colours space issues, which effectively means that it uses and sRGB colour space.  You should use Data.Colour.SRGB.toSRGB instead of Data.Colour.SRGB.Linear.toRGB.
19:09:29 <pumpkinbot> Consider it noted.
19:09:38 <roconnor> um
19:09:41 <roconnor> thanks pumpkinbot
19:09:45 <pumpkin> yup
19:09:51 <pumpkin> lambdabot is temporarily gone
19:09:59 <pumpkin> not sure where :)
19:10:18 <roconnor> Heh I knew I shouldn't have added Data.Colour.SRGB.Linear.
19:10:26 <roconnor> but I think opengl colours need it
19:10:35 <Olathe> @hoogle png
19:10:36 <pumpkinbot> package pngload
19:11:32 <Gracenotes> hm... when might someone want to use a Reader (a -> e) instead of normal function application, a -> e?
19:12:55 <Gracenotes> it does seem like quite a simple wrapping.
19:13:00 <Saizan_> when most of the code doesn't touch the extra parameter
19:13:15 <Gracenotes> the a?
19:13:23 <Saizan_> moslty  when you use it in a transformer stack
19:13:26 <Saizan_> yeah
19:13:33 <athos> :t hcat
19:13:35 <pumpkinbot> [Doc] -> Doc
19:13:39 <ski_> @kind forall a e. Reader (a -> e)
19:13:41 <pumpkinbot>     `Reader (a -> e)' is not applied to enough type arguments
19:13:41 <pumpkinbot>     Expected kind `*', but `Reader (a -> e)' has kind `* -> *'
19:13:43 <Gracenotes> it's like a machine that takes in an a and outputs an e :)
19:13:51 <Gracenotes> except it
19:13:57 <Gracenotes> it's more opaque than normal application
19:14:08 <Gracenotes> hm. StateT would be a -> m e, then
19:14:12 <Gracenotes> @hoogle StateT
19:14:13 <pumpkinbot> Control.Monad.State.Lazy newtype StateT s m a
19:14:13 <pumpkinbot> Control.Monad.State.Lazy StateT :: s -> m (a, s) -> StateT s m a
19:14:13 <pumpkinbot> Control.Monad.State.Strict newtype StateT s m a
19:14:22 <Gracenotes> er, ReaderT, rather
19:14:32 <ski_> bad pumpkinbot
19:14:36 <pumpkin> ?
19:14:50 <ski_> that should be `StateT :: (s -> m (a, s)) -> StateT s m a'
19:14:58 <BMeph> Gracenotes: When many functions use the same input? :)
19:15:17 <Gracenotes> ah, good point.
19:15:19 <pumpkin> ski_: bad hoogle then!
19:15:30 <Gracenotes> are there any canonical examples of using a Reader?
19:15:33 <ski_> yes, transitive blame
19:15:34 * pumpkin pets his bot
19:16:04 <ski_> Gracenotes : environments in interpreters ?
19:16:33 <Gracenotes> hm, that makes sense.
19:17:18 <Gracenotes> oh, one's in All About Monads
19:18:35 <Gracenotes> er, I wonder, how is the new logo selection going?
19:18:52 <pumpkin> still stalled on how to vote, I'd guess
19:21:13 * wli recommends cardinal weighted pairs or CSSD for single-winner and CPO-STV for multi-winner.
19:21:36 <ski_> (<http://wxhaskell.sourceforge.net/assignment.html>)
19:23:00 <Olathe> What causes return . unsafePerformIO to speed things up so much ?
19:23:31 <Olathe> When used on readFile, I mean.
19:24:10 <Olathe> It seems to keep rereading the file over and over again without it.
19:24:15 <Olathe> I wonder why.
19:24:29 <SamB> Olathe: do you re-run the code ?
19:24:42 <SamB> if you re-run readFile, the file will be re-read!
19:24:54 <Olathe> How do you wrap the results so that it isn't rerun ?
19:25:11 <Olathe> Like fmap f . readFile gives something that uses readFile, I guess.
19:25:25 <glguy> contents <- readFile "filename"
19:25:28 <SamB> well, you run it outside your loop and bind the result to a variable
19:25:34 <glguy> stick to referring to contents at this point
19:25:36 <chrisdone> how does one access struct fields in GHC's FFI?
19:25:50 <SamB> chrisdone: you have to do it in C :-(
19:25:56 <chrisdone> oh, really?
19:26:08 <SamB> hs2c may be able to generate the C for this, though
19:26:08 <chrisdone> no wonder I couldn't find information about it
19:26:22 <SamB> er. c2hs
19:26:25 <jeffz`> I don't think you need C...
19:26:36 <SamB> jeffz`: how do you do it ?
19:26:49 <Olathe> SamB: Can you give an example, please ?
19:26:52 <jeffz`> SamB: I think you need to write a storable instance for a data type
19:27:08 <joed> dibblego: Yo, why don't you take surial for a spin?
19:27:09 <jeffz`> SamB: I was writing one for some win32 binding a few days ago, just going by the existing code in Win32
19:27:12 <Olathe> Like a = fmap f . readFile; main = forever $ do { print a } ?
19:27:14 <chrisdone> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-320005.7
19:27:14 <chrisdone> this?
19:27:15 <glguy> you need to write C to deal with vararg functions and macros
19:27:21 <pumpkinbot> Title: 5 Marshalling, http://tinyurl.com/yfoy96
19:27:35 <SamB> glguy: and structs ?
19:27:52 <glguy> SamB, you just need to write the Storable instance for them
19:28:25 <ksf> c2hs doesn't do struct or varargs marshalling.
19:28:29 <ksf> enums, though.
19:28:37 <ski_> Olathe : `print a' doesn't type-check (unless you have showable functions)
19:28:39 <SamB> glguy: and how do you read the fields without using C code ?
19:28:49 <ksf> it has getter and setter support, though.
19:28:53 <SamB> ski_: showable IO actions, actually
19:29:01 <Olathe> Ahh, I think I see.
19:29:03 <ski_> @type fmap f . readFile
19:29:05 <pumpkinbot> forall b. (SimpleReflect.FromExpr b) => FilePath -> IO b
19:29:09 <Saizan_> there's {#get field #} in c2hs no?
19:29:19 <ski_> showable *functions*
19:29:20 <ksf> in general, c2hs doesn't generate any c
19:29:21 <SamB> see, I told you you needed C!
19:29:25 <ksf> Sayzan_, there is.
19:29:32 <Olathe> Like this ? main = do { a <- getImage "pic.png"; forever $ print a }
19:29:42 <SamB> Olathe: yeah!
19:29:45 <SamB> that's the way
19:29:47 <Olathe> Ahh :)
19:30:05 <SamB> just like in any other programming language, really
19:30:10 <Olathe> So, you have to get it and use it within that do block (or >>= stuff).
19:30:26 <ski_> Olathe : or pass it along to another action
19:30:50 <ski_> (which is what `print a' is doing there)
19:30:57 <roconnor> I should add a stern warning to Data.Colour.SRGB.Linear: DO NOT USE ME!
19:31:11 <jeffz`> SamB: I guess you "need C" if hsc2hs counts as using C.
19:31:33 <SamB> jeffz`: given that the question was asked in terms of the FFI, I'd say yes
19:31:38 <ksf> roconnor, just make a new release with a compile bug.
19:31:48 <Olathe> @undo do { a <- getImage "pic.png"; forever $ print a }
19:31:49 <pumpkinbot> getImage "pic.png" >>= \ a -> forever $ print a
19:32:00 <SamB> roconnor: {-# DEPRECATED #-} ???
19:32:20 <pumpkin> roconnor: or unsafeLinear
19:32:23 <pumpkin> :P
19:32:29 <Olathe> SamB: Ahh, I think I understand it a lot better now. Thanks :)
19:32:34 <roconnor> unsafeLinear is probably good :P
19:32:51 * pumpkin grins
19:33:00 <drhodes> > map head $ group . sort $ "abcacbbsdbfndbsanbdfmnba"
19:33:02 <pumpkinbot>   "abcdfmns"
19:33:22 <Gracenotes> could someone possibly sign me up for an account on the haskell wiki? :)
19:33:30 <Olathe> @src nubBy
19:33:30 <glguy> SamB, I'm trying to find some example code for you
19:33:31 <pumpkinbot> nubBy eq []             =  []
19:33:32 <pumpkinbot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:33:37 <pumpkin> Olathe: you calling me a nub?
19:33:38 <roconnor> really it reads Data.Colour.SRGB.Linear: DO NOT USE ME! (unless you are absolutely certain about what you are doing and have read Poynton's Gamma FAQ)
19:33:42 <glguy> I know I've done this already
19:33:42 <Olathe> pumpkin: Heheh
19:34:19 <SamB> glguy: chrisdone is the one who wants to read struct fields
19:34:28 <Gracenotes> depending on how the MediaWiki was configured, http://haskell.org/haskellwiki/?title=Special:Userlogin might have a "Create account" link for people who are already logged in...
19:34:32 <pumpkinbot> Title: Create an account or log in - HaskellWiki
19:34:39 <Gracenotes> thanks, pumpkin
19:34:40 <pumpkin> roconnor: you could use CPP and use #warning
19:34:41 <Gracenotes> bot
19:34:45 <chrisdone> sorry, back
19:34:51 <pumpkin> roconnor: it would alert people during compilation if nothing else
19:35:13 <drhodes> thank Olathe
19:35:18 <drhodes> thanks! even.
19:35:39 <roconnor> pumpkin #ifndef I_have_read_poynton ...
19:35:54 <Olathe> You're welcome.
19:35:59 <ksf> chrisdone, http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/51691
19:36:02 <chrisdone> here's an example struct: typedef struct{unsigned char first;unsigned char last;} XRecordRange8;
19:36:03 <pumpkinbot> Title: gmane.comp.lang.haskell.cafe
19:36:03 <Olathe> > nub "abcacbbsdbfndbsanbdfmnba"
19:36:05 <pumpkinbot>   "abcsdfnm"
19:36:08 <chrisdone> ksf: I'll read it
19:36:14 <Olathe> If you want it sorted, what you had was more efficient.
19:36:21 <Axman6> drhodes: map head . group . sort $ "thing" is more common
19:36:32 <Olathe> Yeah, that's faster for sorted results.
19:36:35 <drhodes> just tryin to get a uniq
19:36:53 <chrisdone> ksf: right..
19:37:55 <roconnor> pumpkin: well, I'll start with dissuasive comments in the documenation
19:38:08 <pumpkin> drhodes: uniq = map head . group, sort of
19:38:13 <chrisdone> glguy: it's possible?
19:38:15 <roconnor> and then ratchet it up if needed
19:38:26 <glguy> chrisdone, You'll have to write a Storable instance
19:38:34 <glguy> for a type that you want to correspond to a struct
19:40:26 <glguy> chrisdone, http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
19:40:30 <chrisdone> glguy: I'm looking at the storable class's definition, but.
19:40:31 <pumpkinbot> Title: 11.3.ï¿½Writing Haskell interfaces to C code: hsc2hs, http://tinyurl.com/397xrd
19:40:40 <glguy> chrisdone, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
19:40:53 <pumpkinbot> Title: Foreign.Storable, http://tinyurl.com/5s9kld
19:41:09 <pumpkin> I'm not sure how to turn off that title echoing
19:41:29 <hackage> Uploaded to hackage: hS3 0.5
19:41:53 <Axman6> pumpkin: probably need to upgrade lambdabot
19:42:08 <pumpkin> I could probably just take it out of the code
19:42:22 <Chani> I can't figure out how to read either a number *or* a bool from a string...
19:42:39 <pumpkin> Chani: how do you mean? if one succeeds, use it, otherwise use the other?
19:42:42 <pumpkin> and what if neither succeed?
19:44:07 <Chani> pumpkin: I mean I have to fill an array of these: data Value = Numeric Integer | Boolean Bool
19:44:28 <Axman6> Chani: see reads
19:44:53 <Axman6> > reads "True" :: [(Bool,String)]
19:44:55 <pumpkinbot>   [(True,"")]
19:45:03 <chrisdone> glguy: reading...
19:45:06 <Axman6> > reads "True" :: [(Integer,String)]
19:45:08 <pumpkinbot>   []
19:46:01 <Chani> Axman6: google is being useless, what's a good site for documentation?
19:46:15 <Olathe> hoogle
19:46:19 <Axman6> @hoogle reads
19:46:21 <pumpkinbot> Prelude reads :: Read a => ReadS a
19:46:21 <pumpkinbot> Text.Read reads :: Read a => ReadS a
19:46:21 <pumpkinbot> Prelude type ReadS a = String -> [(a, String)]
19:46:29 <Olathe> http://www.haskell.org/hoogle/
19:46:33 <pumpkinbot> Title: Hoogle
19:47:02 <Chani> >.< what is ReadS?
19:47:18 <Olathe> It's a typeclass.
19:47:47 <Olathe> Hmm, with that signature, it looks like a monad or something.
19:48:07 <pumpkin> @src ReadS
19:48:08 <pumpkinbot> Source not found. Where did you learn to type?
19:48:23 <Chani> I don't really understand read yet...
19:48:32 <Axman6> Olathe: it's basically a parsing function
19:48:34 <pumpkin> type ReadS a            =  String -> [(a,String)]
19:48:43 <Olathe> Ahh.
19:48:59 <Axman6> takes a string, returns a list of a, String pairs (usually only one result though
19:49:04 <Olathe> It's fun watching text scroll as fast as a terminal window can scroll it.
19:49:36 <Chani> "readsPrec :: Int  the operator precedence of the enclosing context (a number from 0 to 11). Function application has precedence 10
19:49:53 <Chani> ^^ can someone rephrase that in english?
19:50:04 <Olathe> It looks like cmd.exe uses interlaced display.
19:50:10 <Axman6> i've never seen readsPrec used anywhere
19:51:41 <Chani> Axman6: when I tried to look up reads it just said it's readsPrec with precendence 0
19:51:47 <Chani> whatever that means
19:51:59 <Axman6> well, can you see what reads does?
19:52:08 <Chani> anyawys, I'm too hungry to think and I was supposed to be doing math homework anyways
19:52:15 <Chani> I'm gonna take a break from haskell
19:52:27 <jeffz`> you use readsPrec when you instance Read
20:00:19 <Olathe> @type when
20:00:22 <pumpkinbot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:00:37 <Olathe> @index when
20:00:37 <pumpkinbot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:01:24 <lepassive> is there an ORM solution for haskell ?
20:01:27 <byorgey> roconnor: thanks.  see, this is why I'm glad to let someone else think about color stuff. =)
20:01:28 <pumpkinbot> byorgey: You have 1 new message. '/msg pumpkinbot @messages' to read it.
20:02:03 <byorgey> and yes, I am fond of existential types =)
20:02:33 <rainmann> @instances Bifunctor
20:02:34 <pumpkinbot> Couldn't find class `Bifunctor'. Try @instances-importing
20:03:02 <Olathe> ExistentialTypes++
20:04:26 <Axman6> > when True (Just ())
20:04:28 <pumpkinbot>   Just ()
20:04:34 <Axman6> > when False (Just ())
20:04:36 <pumpkinbot>   Just ()
20:04:46 <Olathe> Heheh
20:04:48 <Axman6> > when True Nothing
20:04:50 <pumpkinbot>   Nothing
20:04:55 <Axman6> > when False Nothing
20:04:57 <pumpkinbot>   Just ()
20:05:30 <byorgey> what happened to lambdabot?
20:05:40 <Olathe> It needed to destress
20:05:52 <Gracenotes> overdosed on a bad combinator, maybe?
20:06:00 <Olathe> Actually, I think Cale said that he couldn't reach its host after it timed out.
20:06:09 <Olathe> So, the machine is probably down.
20:07:43 <ksf> {-# LANGUAGE ExistentialQuantification, TypeSynonymInstances, MultiParamTypeClasses, ScopedTypeVariables, FlexibleInstances #-}
20:07:55 <ksf> ...I guess I should weed out a few.
20:09:33 <Olathe> when is pretty neat :)
20:09:40 <kerlo> {-# LANGUAGE * #-}
20:10:03 <kerlo> No, that's not enough.
20:10:07 <kerlo> {-# * #-}
20:10:53 <idnar> @type mzero
20:10:54 <Axman6> are those not all included when you use -fglasgow-exts?
20:10:55 <pumpkinbot> forall (m :: * -> *) a. (MonadPlus m) => m a
20:10:55 <glguy> ~.
20:11:08 <Olathe> Is there a shortcut for when p str = when p (fail str) ?
20:11:14 <Olathe> Bah
20:11:15 <idnar> > mzero :: Either Int
20:11:16 <kerlo> Then if GHC properly orders its heuristics based on statistics regarding how well they've done in the past, your program will automatically become sapient.
20:11:17 <pumpkinbot>       `Either Int' is not applied to enough type arguments
20:11:18 <pumpkinbot>      Expected kind...
20:11:22 <Olathe> @src failWhen
20:11:22 <pumpkinbot> Source not found. Maybe if you used more than just two fingers...
20:11:26 <idnar> > mzero :: Either Integer Integer
20:11:28 <pumpkinbot>       No instance for (Error Integer)
20:11:29 <pumpkinbot>        arising from a use of `mzero' at...
20:11:33 <idnar> > mzero :: Either String Integer
20:11:35 <pumpkinbot>   Left ""
20:11:49 <Olathe> @pl \p str -> when p (fail str)
20:11:50 <pumpkinbot> (. fail) . when
20:11:51 <kerlo> Left is the error nowadays?
20:11:56 <Olathe> Oh, that's nice.
20:12:00 <idnar> "nowadays"?
20:12:08 <kerlo> I seem to remember it being Right.
20:12:17 <Olathe> Right is correct, Left is not.
20:12:18 <idnar> well, it's a bit hard to define it the other direction
20:12:23 <pumpkin> always gotta politicize everything!
20:12:26 <Olathe> A nice mnemonic.
20:12:27 <chrisdone> right is mnemonic for "the right value"
20:12:29 <idnar> you'd need type-level lambdas
20:12:40 <kerlo> Clearly, my confusion as to which is which stems from being mixed up.
20:12:51 <kerlo> @hoogle Void
20:12:52 <pumpkinbot> Foreign.Marshal.Error void :: IO a -> IO ()
20:13:04 <kerlo> I don't like that one. It doesn't seem to be of type *, you see.
20:13:16 <Olathe> (.fail).when
20:13:26 <Olathe> Is there a failWhen I don't know about ?
20:14:05 <glguy> guard is similar
20:14:10 <glguy> I don't know exactly what you are trying to do
20:14:29 <Olathe> I like guard, except its lack of an error messog.
20:14:32 <Olathe> message
20:14:56 <glguy> an error message guard would probably be called assert
20:15:01 <Olathe> Hmm...
20:15:05 <Olathe> @hoogle assert
20:15:06 <pumpkinbot> Control.Exception assert :: Bool -> a -> a
20:15:06 <pumpkinbot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
20:15:06 <pumpkinbot> Test.HUnit.Base class Assertable t
20:15:20 <idnar> @type when
20:15:22 <pumpkinbot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:15:30 <idnar> @type guard
20:15:32 <pumpkinbot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:15:52 <idnar> @hoogle Bool -> m () -> m () -> m ()
20:15:52 <pumpkinbot> Foreign.C.Error throwErrnoIf :: a -> Bool -> String -> IO a -> IO a
20:15:53 <pumpkinbot> Control.Exception catchJust :: Exception -> Maybe b -> IO a -> b -> IO a -> IO a
20:15:53 <pumpkinbot> Foreign.C.Error throwErrnoIfRetryMayBlock :: a -> Bool -> String -> IO a -> IO b -> IO a
20:16:46 <idnar> actually
20:16:54 <idnar> isn't it just if?
20:16:57 <Olathe> @hoogle Bool -> String -> m () -> m ()
20:16:57 <pumpkinbot> Foreign.C.Error throwErrnoIf :: a -> Bool -> String -> IO a -> IO a
20:16:58 <pumpkinbot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
20:16:58 <pumpkinbot> Foreign.C.Error throwErrnoIfRetryMayBlock :: a -> Bool -> String -> IO a -> IO b -> IO a
20:17:16 <idnar> if foo then bar else fail "errir!"
20:17:33 <Olathe> I was using something like that before.
20:18:38 <Olathe> I suppose I'll just do failWhen = (.fail).when
20:18:48 <Olathe> Which is sort of cute
20:20:15 <Axman6> :t (.fail).when
20:20:18 <pumpkinbot> forall (m :: * -> *). (Monad m) => Bool -> String -> m ()
20:21:02 <roconnor> byorgey: oh you are here
20:21:08 <Olathe> :t (.fail).unless
20:21:10 <pumpkinbot> forall (m :: * -> *). (Monad m) => Bool -> String -> m ()
20:21:16 <roconnor> byorgey: can I ask you why you chose the linear colour space?
20:21:43 <roconnor> byorgey: I want to adjust the documentation appropriately so that few people fall into these pitfalls.
20:22:26 <roconnor> @seen dcoutts
20:22:27 <pumpkinbot> dcoutts is in #haskell. I don't know when dcoutts last spoke.
20:23:17 <pumpkin> my bot's seen isn't very useful, I'd use preflex for better results
20:23:51 <byorgey> roconnor: actually, I don't know, Dougal Stanton did that part
20:24:16 <byorgey> roconnor: some additional documentation would be nice, though, maybe just a few paragraph general overview?
20:24:38 <byorgey> roconnor: the documentation on individual things is good, but there's so much stuff there, it's hard to know what's what
20:24:59 <Olathe> @undo { x <- return y }
20:25:00 <pumpkinbot>  Parse error at "{" (column 1)
20:25:01 <byorgey> especially if you don't already know much about this kind of stuff
20:25:05 <Olathe> @undo do { x <- return y }
20:25:05 <pumpkinbot>  Parse error at "}" (column 20)
20:25:10 <Olathe> @undo do { x <- return y; return x }
20:25:11 <pumpkinbot> return y >>= \ x -> return x
20:25:13 <shepheb> byorgey: from reading your blog post on diagrams, I'm wondering if I'd want a layer on top of it for my purposes. I'd mainly use it for things like finite automata: circles and arrows between them, labelled with text.
20:25:44 <byorgey> shepheb: aha! arrows between things is a feature I want to add.
20:25:51 <Olathe> @pl \y -> return y >>= f
20:25:52 <pumpkinbot> f
20:25:55 <byorgey> shepheb: but you'll have a hard time doing it at the moment.
20:26:03 <byorgey> I mean, you could do it, but it would be very annoying
20:26:03 <pumpkin> lol
20:26:04 <Olathe> Does GHC optimize return y >>= f to f ?
20:26:28 <pumpkin> it could if you wrote a rule for it
20:26:34 <Olathe> Oh :(
20:26:56 <byorgey> shepheb: if you have time, I'd love if you played with it a bit and then told me what additional features you'd like to see to make it more useful for you
20:27:08 <byorgey> shepheb: or even better, contributed some patches =)
20:27:08 <Gracenotes> Olathe: I'm not sure if it could tell if a Monad followed the monad laws
20:27:16 <Olathe> Ahh.
20:27:21 <Olathe> Yes, that makes sense.
20:27:37 <shepheb> byorgey: I'm working on this right now, in fact. I'll see if I can sketch out the sort of API I'd want for box-circle-arrow-line-label type diagrams
20:27:47 <Olathe> @pl \y -> return y ++ f
20:27:48 <pumpkinbot> (++ f) . return
20:27:55 <byorgey> shepheb: cool, thanks
20:28:05 <chrisdone> using c is harder than I thought
20:28:26 <Olathe> Haskell >> C
20:28:42 <chrisdone> I vaguely understand how to define a storable instance, but how do I know what the alignment is?
20:29:05 <Axman6> make it up
20:29:10 <Axman6> she'll be right mate
20:29:22 <pumpkin> Chaotic Neutral is the way to go
20:29:39 <pumpkin> sorry BMeph
20:29:48 <SamB> hey, where does the hscolour .css file come from ???
20:30:04 <pumpkin> I'd imagine someone wrote it
20:30:10 <pumpkin> just a hunch though
20:30:12 <shepheb> byorgey: what sort of evils are required to get Cairo on 6.10? it seems like the release version of gtk2hs doesn't support it.
20:30:36 <chrisdone> SamB: probably ~/.cabal/share/HsColour/... or something
20:30:40 <byorgey> shepheb: oh, really? I don't know, I'm not yet using 6.10 for everyday stuff
20:30:53 <SamB> cabal haddock --hyperlink-source isn't copying it into the output tree afaict
20:31:13 <rwbarton> shepheb: I hear the darcs version supports 6.10, and there should be a release "soon"
20:31:44 <roconnor> byorgey: ya, I'll see what I can do
20:31:44 <chrisdone> #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
20:31:58 <dons> mm
20:31:59 <chrisdone> mauke: will you explain this?
20:32:08 <byorgey> roconnor: cool, thanks
20:32:17 <roconnor> byorgey: btw, you can use (mempty :: Colour Double) for black
20:32:29 <roconnor> I don't know if this is an improvement over importing black or not
20:33:01 <byorgey> roconnor: it's a very nice library though, I'm very glad to be able to get rid of the color stuff I had built into diagrams 0.1 =)
20:33:09 <chrisdone> meh, I'll just write C functions to access the struct fields
20:33:11 <roconnor> (however mempty ::AlphaColour Double is transparent)
20:33:18 <pumpkin> :o
20:33:20 <byorgey> roconnor: heh, ok, thanks =)
20:33:25 <pumpkin> racist!
20:33:33 <roconnor> byorgey: I'm excited to have users.
20:34:18 <Olathe> chrisdone: That's a neat trick.
20:34:18 <roconnor> I wonder if it is appropriate to have cairo depend on colour.
20:34:30 <roconnor> or if cairo is supposed to be a very thin wrapper
20:34:38 <byorgey> roconnor: the one annoying issue we ran into was that there's no common interface for Colour and AlphaColour.  as you can see I sort of hackish-ly solved that by making a type class with instances for both.
20:34:59 <Olathe> chrisdone: It makes a struct with a single byte and the data stored, then it sees where the data is stored at, I think.
20:35:01 <byorgey> roconnor: I have no idea if there would be a different way to structure the colour library that would have made that any easier.
20:35:33 <pumpkin> Axman6: profile profile profile!
20:35:39 <roconnor> byorgey: I noticed that.  I don't know why you want to mix the two types. :)
20:35:43 <Axman6> yeah, time to do that again
20:35:49 <Olathe> chrisdone: So, if it aligns to bytes, you get 1, if to 4-byte words, you get 4.
20:35:54 <roconnor> byorgey: there is an injection from Colour to AlphaColour: opaque
20:35:59 <pumpkin> Axman6: are you using DPH?
20:36:07 <Axman6> no, used way too much RAM
20:36:11 <pumpkin> ah
20:36:19 <Axman6> and was too slow. this task doesn't parlelise well
20:36:22 <byorgey> roconnor: well, most users will probably just want to use named colours from Data.Colours.Named.  those all have type Colour a.
20:36:34 <roconnor> byorgey: I'd be inclined to use AlphaColour everywhere: thus your example code would be ... (opaque red) ...
20:36:38 <byorgey> roconnor: but I obviously want Diagrams to support transparency.
20:36:39 <roconnor> which seems reasonable to e
20:36:45 <ksf> haskell type inference sucks.
20:36:49 <roconnor> but I understand if you prefer the type classes
20:37:01 <byorgey> roconnor: that would be super annoying for users to have to type 'opaque' in front of every color they want to use.
20:37:03 <rwbarton> nbody seems intrinsically nonparallelizable, since n is about 6 or something
20:37:12 <Olathe> chrisdone: http://notabug.com/2002/coherent/man/offsetof.html
20:37:16 <roconnor> byorgey: if that is how you feel. :)
20:37:25 <chrisdone> Olathe: I am bewildered
20:37:58 <byorgey> roconnor: hehe. =)  well, the current solution seems to work ok, so I don't think it's really a problem.
20:38:00 <Olathe> chrisdone: When C lays out a struct in memory, it might just cram everything together or it might align it on words or something.
20:38:54 <roconnor> byorgey: you may wish to check dividing by 0 in alphaToColour
20:39:08 <byorgey> yikes, thanks
20:39:15 <roconnor> byorgey: I don't know how well cairo supports setRGBA Nan Nan Nan 0
20:39:20 <chrisdone> Olathe: t (y__); <- what's this syntax? what does it mean?
20:39:22 <byorgey> haha
20:39:29 <byorgey> probably not very well.
20:39:42 <roconnor> probably not well, although it ought to
20:39:43 <byorgey> roconnor: in what case would that happen?
20:39:52 <FrozenOne> okay, what's wrong with "let a = return getClockTime" ?
20:39:57 <Gracenotes> hm. Is it okay to do unsafePerformIO . newMVar?
20:40:06 <roconnor> byorgey: when using transparent black
20:40:09 <Olathe> chrisdone: y__ is the name of the field and t is the type.
20:40:25 <Gracenotes> apparently it's in the source of the hicules IRC client
20:40:25 <Olathe> chrisdone: Like int theNumber ... t y__
20:40:51 <chrisdone> Olathe: I think I get the logic of it. x__ is one byte so y__'s position should be 1 for no alignment or more otherwise
20:40:52 <FrozenOne> Ambiguous type variable `m' in the constraint...
20:40:58 <byorgey> roconnor: ok, thanks, I'll fix that
20:41:05 <roconnor> cairo probably doesn't like setRGBA Infinity Infinity Infinity 0 either
20:41:08 <Olathe> chrisdone: Yep, and not only that, it tells you what the alignment is if it's more.
20:41:16 <pumpkin> FrozenOne: you probably want a <- getClockTime?
20:41:19 <pumpkin> @hoogle getClockTime
20:41:19 <pumpkinbot> No results found
20:41:20 <roconnor> so transparent anything is bad
20:41:26 <byorgey> roconnor: is there a better way to write the code for those type class instances?
20:41:27 <chrisdone> Olathe: oh, I didn't know that was allowed in C. why the parentheses around y__?
20:41:29 <hackage> Uploaded to hackage: testpack 1.0.2
20:41:29 <hackage> Uploaded to hackage: testpack 1.0.1
20:41:53 <FrozenOne> It has to be in a let statement
20:42:01 <Olathe> chrisdone: I'm not sure, but usually in preprocessor stuff, you surround things that will be replaced with parentheses.
20:42:03 <FrozenOne> let a <- getClockTime doesn't work
20:42:05 <pumpkin> FrozenOne: but in general, if nothing's constraining the type (i.e., you aren't using it or you're using it generall), it probably doesn't know what to return
20:42:16 <pumpkin> that's why I didn't write let :P
20:42:26 <roconnor> byorgey: I think colorToRGBA col = colorToRGBA (opaque col) would be more elegant, but you version is faster.
20:42:42 <FrozenOne> hmm
20:42:45 <chrisdone> Olathe: oh right
20:42:49 <byorgey> roconnor: ah. how much faster?
20:42:52 <chrisdone> Olathe: I found it here: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs
20:42:59 <pumpkinbot> Title: FFI cook book - HaskellWiki, http://tinyurl.com/32xoop
20:43:25 <roconnor> byorgey: a lot faster
20:43:31 <byorgey> hmm
20:43:48 <roconnor> byorgey: RGB is a functor, so you could fmap toDouble
20:43:53 <chrisdone> Olathe: I can probably work out how to use it, but random magic like that makes me cry inside
20:43:59 <roconnor> byorgey: but
20:44:20 <Olathe> Heheh
20:44:28 <chrisdone> Olathe: thanks for explaining that =Â¬)
20:44:33 <Olathe> You're welcome.
20:44:45 <SamB> oh, the reason hscolour's CSS wasn't getting installed must have been that my HsColour was too old
20:44:47 <roconnor> byorgey: but you should use colourConvert
20:45:06 <SamB> @tell Igloo Debian needs a newer HsColour
20:45:06 <pumpkinbot> Consider it noted.
20:45:07 <roconnor> which essentially does toDouble on my side
20:45:17 <roconnor> colourConvert :: (Fractional b, Real a) => Colour a -> Colour b
20:45:36 <byorgey> aha!  I missed that function.
20:45:58 <roconnor> byorgey: this is great stuff I'm learning
20:46:07 <roconnor> byorgey: I've never actually used my library myself :)
20:46:10 <byorgey> hehe
20:46:12 <pumpkin> ack, I'm so not used to seeing the U in colour
20:46:48 <SamB> roconnor: then WHY THE HECK did you write it ?
20:46:49 <roconnor> pumpkin: in #haskell, we do things differently
20:46:55 <Olathe> Is there a standard way of representing images (in the bitmap sense rather than the file sense) in Haskell ?
20:47:00 <roconnor> SamB: Well I need some names for colours
20:47:01 <SamB> roconnor: wierdo
20:47:14 <pumpkin> roconnor: I've noticed :)
20:47:14 <SamB> (the u, I mean)
20:47:16 <rwbarton> FrozenOne: The reason that the compiler doesn't like "let a = return getClockTime" is the monomorphism restriction
20:47:20 <roconnor> SamB: and things sort of spiraled out of control
20:47:21 <dons> Olathe: depends on the graphics lib, currently
20:47:22 <rwbarton> FrozenOne: but probably it's not what you meant anyways
20:47:31 <Olathe> dons: Ahh.
20:47:38 <FrozenOne> rwbarton: ahh, that explains everything! :)
20:47:45 <dons> e..g gd and gtk both have image representations, but different ones
20:47:56 <chrisdone> Olathe: libgd lets you work with a bitmap from a-fresh, or from a file, and write pixels and text and paint to it or query pixels, etc.
20:47:58 <roconnor> SamB: that's wierdou
20:47:58 <byorgey> roconnor: hehe, that sounds kind of like the genesis for the diagrams package. ;)
20:48:14 <rwbarton> FrozenOne: Well, maybe it's probably not a very helpful answer, but I figured somebody should give you some answer :)
20:48:21 <FrozenOne> hehe
20:48:22 <byorgey> roconnor: except substitute 'a couple illustrations' in place of 'names for colours'
20:48:24 <SamB> byorgey: someone needed names for some shapes ?
20:48:29 <Olathe> chrisdone: Ahh, thanks :)
20:48:34 <roconnor> byorgey: I've been thinking of writing a lib much like diagrams.  I'd do things a bit differently though.  But I really liked your ReaderT.  That was inspirational.
20:48:55 <chrisdone> Olathe: (if I take your meaning)
20:49:23 <roconnor> byorgey: I'll probably steal that idea
20:49:34 <byorgey> roconnor: cool, multiple approaches is always good.  and by all means, please steal away =)
20:49:44 * roconnor nods
20:49:45 <wli> Everything gets specialized down to monomorphic in the end anyway, unless there's a way for polymorphic intermediate results whose type parameters get eliminated somehow to avoid ever getting specialized.
20:49:52 <wli> What was byorgey's approach?
20:50:34 <SamB> did you know specialization could foil the IORef-based unsafeCoerce ?
20:50:52 <wli> SamB: No, I had no idea.
20:51:08 <nelhage> Can I attack haddock docs to a field generated by a hsc #enum?
20:51:11 <nelhage> er, attach.
20:51:20 <pumpkin> freudian slip!
20:51:21 <rwbarton> Does anyone understand what the 'strict' primitive in Gofer was supposed to do?
20:52:05 <ddarius> rwbarton: Presumably strict = ($!)
20:52:40 <SamB> can someone please explain "lazy" to me?
20:52:43 <ddarius> SamB: Of course.
20:52:43 <dons> :t ($!)
20:52:44 <rwbarton> ddarius: I guess that must be right.
20:52:45 <pumpkinbot> forall a b. (a -> b) -> a -> b
20:52:48 <dons> yep
20:52:53 <ddarius> SamB: It's magicks.
20:52:53 <dons> but with prefix use.
20:53:06 <Axman6> hmm... i do not like looking t Core and finding there's no actual code in my functions
20:53:13 <SamB> why do they give these magics source in the library?
20:53:24 <wli> mabus: Identify the session ID of the screen session, then shoot the process with matching tty and/or session ID.
20:53:49 <dons> :info ($!)
20:53:54 <dons> ?info ($!)
20:53:55 <pumpkinbot> ($!)
20:54:01 <SamB> Axman6: I find it rather delightful to see that it turned out to be so efficient!
20:54:03 <dons> not helpful mister bot.
20:54:13 <Axman6> good point!
20:54:17 <SamB> dons: that's ?id
20:54:18 <Axman6> dons!
20:54:22 <SamB> don't you remember ?
20:54:30 <ddarius> @info do a <- x; return a
20:54:30 <pumpkinbot> x >>= \ a -> return a
20:54:37 <roconnor> byorgey: does your haddock build for you?
20:54:40 <SamB> oh, wait, no
20:54:44 <SamB> it's @undo
20:54:46 <SamB> I forgot
20:54:54 <byorgey> roconnor: yes
20:54:58 <roconnor> byorgey: mine died on me.  I think it choked on your (##) operator
20:55:05 <roconnor> what version of haddock do you have
20:55:10 <Axman6> dons: i've been working on this ST n-bodies thing, manages to cut the runtime in half. it's still way to slow though :(
20:55:11 <dons> oh, interesting. if $! = strict, i defined it incorrectly.
20:55:12 <dons> ($!)    :: (a -> b) -> a -> b
20:55:12 <dons> f $! x  = x `seq` f x
20:55:22 <byorgey> roconnor: 2.4.1
20:55:24 <SamB> roconnor: maybe you passed in -XStrictTuples ?
20:55:26 <roconnor> ah
20:55:26 <dons> strict f a = let b = f a in b `GHC.seq` b
20:55:29 <byorgey> roconnor: sounds like you need to upgrade?
20:55:30 <rwbarton> dons: yeah, your definition is actually equivalent to strict = id
20:55:31 <roconnor> I have 0.8
20:55:35 <dons> :)
20:55:35 <byorgey> hehe, that would do it
20:55:41 <byorgey> everything breaks with 0.8 =)
20:55:45 <roconnor> byorgey: I just upgraded to Kubuntu 8.10 this week :)
20:55:51 <byorgey> I see =)
20:55:55 <dons> rwbarton: yeah. i shouldn't blog + code before getting out of bed on saturdays
20:56:06 <roconnor> byorgey: how long have you been haskell programming, if you don't mind me asking
20:56:08 <dons> seemed like a good idea at the time
20:56:12 <Axman6> heh, it's almost 4PM here, and i'm still in bed
20:56:13 <SamB> roconnor: try the HEAD :-P
20:56:27 <Axman6> haven't got breakfast yet. to damn hot!
20:56:28 <thom__> I have been trying to understand monads. Unforunately, it seems a difficult
20:56:28 <thom__> concept and is expressed in a language I don't know yet.
20:56:32 <thom__> but I keep seeing people saying "For instance, mutable state can be modeled
20:56:39 <thom__> by the monad M a = s -> (a,s)." Mutable state I get. But I don't understand
20:56:50 <thom__> how the previous expression is saying that. Can someone help me understand
20:56:50 <thom__> how "M a = s -> (a,s)" == mutable state?
20:56:51 <pumpkin> it's thom from radiohead!
20:57:12 <ddarius> thom__: That, which is called the state monad, models a -single piece- of mutable state.
20:57:23 <rwbarton> namely a piece of type s
20:57:34 <byorgey> roconnor: about a year and a half
20:57:39 <Axman6> thom__: the s is the state that you pas around, and modify, and the a is a side result
20:57:43 <ksf> thom__, the type alone isn't mutable thread, the definitions of >>= and runState are where the real stuff happens.
20:57:46 <Axman6> but, i still don't get State
20:58:05 <byorgey> roconnor: why do you ask?
20:58:31 <thom__> so that statement of M a = s -> (a,s) is incomplete?
20:58:38 <ksf> monads are just a usual pattern of "overloading ;", _how_ you overload ; is what makes a specific monad that monad.
20:58:53 <roconnor> byorgey: well, when  I was comparing your lib to how I would write it, I was sure whether the different approaches were due to my math background or my experience.
20:59:06 <ksf> thom__, no, it's complete, but it isn't a monad yet.
20:59:31 <roconnor> byorgey: or just simply different preferences
20:59:42 <thom__> ksf, okay you lost me...
21:00:03 <ksf> don't bother about my last comment, it's kinda nitpicky.
21:00:04 <rwbarton> thom__: imagine you have a programming language with a single global variable of type s
21:00:15 <thom__> ok
21:00:20 <byorgey> roconnor: heh, I don't know. =)
21:00:26 <byorgey> anyway, bedtime for me
21:00:27 <ksf> ...the important point is that you want to look at the code for >>=.
21:00:29 <byorgey> night all
21:00:34 <rwbarton> thom__: instead of using that global variable, you could add an extra parameter of type s to every function (the starting value) and add an extra output of type s (the new value)
21:00:46 <rwbarton> thom__: that's what M a = s -> (a, s) is trying to say
21:01:08 <pumpkin> byorgey: will you turn into a pumpkin?
21:01:15 <thom__> okay, much better. That sorta what I suspected
21:01:31 <newsham> thom: s -> (a,s)    captures the idea of a program that mutates state (s) and returns a result (a).
21:01:32 <roconnor> byorgey: oh, thank god you don't use (.*.) anywhere =)
21:01:35 <roconnor> byorgey: sleep well
21:01:43 <Axman6> thom__: might also want to look into ST, which has real mutable state, but it's also pure
21:01:52 <rwbarton> thom__: Then, you have to make sure that when you want to call two "functions" in a certain order, you connect the output from the first one to the input of the second one
21:02:02 <rwbarton> thom__: that's encoded in the definition of (>>=)
21:02:34 <newsham> >>= glues together smaller state programs into bigger state programs.
21:02:52 <pumpkin> or buritos
21:03:02 <Axman6> dons: in ghc Core, is it common to have no actual code inside functions? i've only got types in a lot of functions that i'd wuite like to see how they work
21:03:06 <newsham> where state changes from the first state program are visible to the second state program.
21:03:10 <rwbarton> Right, there's no magic.  You could do all the state-passing by hand, but it's easier if you make up a function called >>= to do it for you.
21:03:31 <rwbarton> And then you discover that there are lots of other situations where you want >>= of similar types, and you invent monads. :)
21:03:32 <SamB> Axman6: is it really ghc core, or just your .hi file ?
21:03:46 <Axman6> SamB: i'm using dgc-core the program
21:03:55 <Axman6> ghc-core*
21:04:09 <SamB> Axman6: what functions have no bodies ?
21:04:09 <thom__> hmmm, so (very, very losely) monads are sorta kinda similar to contiuations... in the sense they help you take apart programs and glue them back together?
21:04:31 <Axman6> SamB: some ones that are supposed to be writing to STUArrays
21:04:32 * roconnor recalls that continuations and monads are quite related
21:04:35 <ddarius> thom__: You're not taking anything apart.
21:04:38 <ksf> they're definitely harder to grok, but waaaaaay easier to use.
21:04:45 <wli> There's a continuation-passing monad.
21:05:03 <thom__> like I said, I intended that statement very losely
21:05:26 <dons> mm
21:05:39 <newsham> monads can be likened unto a functor with bind and return where return is an left and right identity and bind is associative.
21:05:41 <dons> Axman6: they probably just moved around, or got inlined
21:05:42 <newsham> roughly
21:05:51 <Axman6> fair enough
21:06:18 <rwbarton> thom__: There are entire blog posts about how explanations of the form "monads are like X" are doomed :)
21:06:22 <Axman6> dons: also, the current n-bodies shootout code segfaults for me on 6.10.1 unless i use -O0
21:06:44 <Axman6> dons: also, you tweeted about missing sydney... you really miss this weather? o.O
21:06:55 <thom__> I know... I've read DOZENS of them :P
21:06:58 <ddarius> thom__: Monadic style (i.e. using (>>=) and return in a certain stylized way) is like continuation passing style in that it is a global transformation.
21:07:35 <gio123> @seen Cale
21:07:36 <pumpkinbot> Cale is in #haskell. I last heard Cale speak 4h 25m 33s ago.
21:07:51 <gio123> @seen ski_
21:07:51 <pumpkinbot> ski_ is in #haskell. I last heard ski_ speak 1h 37m ago.
21:07:59 <pumpkin> oh look, it's gio123
21:08:03 <dons> Axman6: via C ?
21:08:08 <dons> Axman6: i bet it is a gcc bug.
21:08:10 <Axman6> yep
21:08:11 <gio123> :)
21:08:13 <dons> try -O2 -fasm
21:08:14 <Axman6> and without
21:08:32 <thom__> so a monad is saying how arguments of a certain type are passed between funtions?
21:08:51 <ksf> ...between monads.
21:09:11 <Axman6> dons: still get a segfault
21:09:12 <ddarius> thom__: I'm not sure what you mean by that, but I'm inclined to say no.
21:09:43 <dons> you get a segfault, in pure code (ST?) with -fasm ?
21:09:48 <dons> ok. sounds like something's fishy.
21:09:51 <ddarius> thom__: Do you more or less understand the purpose of continuation passing style?
21:09:55 <dons> unsafeRead from the wrong place?
21:09:55 <thom__> I thought thats what the >>= operator was
21:09:58 <thom__> yes
21:10:13 <ksf> they're kinda like flexible pipelines with implementation-defined ways of leakage.
21:10:18 <newsham> thom: the bind function says how you glue together smaller programs in such a way that the result of the first program is available (as an input) to the second program.
21:10:23 <ksf> :t (>>=)
21:10:25 <pumpkinbot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:10:32 <ddarius> thom__: So you use CPS when the language you have doesn't support continuations (call/cc) so that you can model operations like call/cc, yes?
21:10:35 <Axman6> dons: this is with this code: http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=ghc&id=1
21:10:42 <newsham> and thats an abstract pattern that is reused in several places
21:10:44 <pumpkinbot> Title: n-body Haskell GHC program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Lan ..., http://tinyurl.com/bu8eod
21:10:49 <ksf> take a monad, take a thing that takes a thing and returns a monad, and return a monad.
21:10:49 <pumpkin> >>= ~ |
21:10:56 <wli> Control.Applicative is very CPS-oriented.
21:11:10 <thom__> yes
21:11:20 <newsham> as an example:   IO Int -> (Int -> IO String) -> IO String
21:11:34 <ksf> you can't ever get a value out of the monad once it's in, without amending the monad laws.
21:11:46 <newsham> glueing an IO program resulting in an Int together with an IO program resulting in a String into a bigger program that is an IO program resulting in a String
21:11:48 <ddarius> thom__: Using a monad is like using a particular style, such as CPS, so that you can model an effect the language doesn't support itself.
21:12:12 <Axman6> dons: which obviously compiled under 6.8.3 becuse it worked on the shootout machine
21:12:17 <ddarius> thom__: There are different styles for different effects, such as state-passing style which can be used to model (a piece of) mutable state.
21:12:31 <wli> Well, free monads. If it's not free you can have additional laws it's subject to.
21:12:39 <ddarius> thom__: Monadic style abstracts the commonality of all these different ways of modeling effects.
21:13:06 <thom__> newsham: I thought the return function was about getting something "out" of the monad?
21:13:19 <ksf> nope, it stuffs stuff in.
21:13:22 <ksf> :t return
21:13:22 <newsham> thom: no, return injects a pure value into the monad.
21:13:23 <rwbarton> Another "style" that fits in this mold is concatMap or nondeterminism.
21:13:24 <pumpkinbot> forall a (m :: * -> *). (Monad m) => a -> m a
21:13:41 <ksf> :t runState
21:13:42 <newsham> ie    return 3 :: IO Int  <- an IO program that has no IO effects but results in the value 3.
21:13:43 <pumpkinbot> forall s a. State s a -> s -> (a, s)
21:13:55 <ksf> ...runstate gets you out of the monad.
21:14:00 <thom__> hang on... gimme a minute
21:14:15 <pumpkin> but there's no general function for "pulling something out" of the monad
21:14:22 <pumpkin> (without shoving it back in immediately)
21:14:50 <thom__> "<interactive>:1:0: Not in scope: `runstate'"
21:14:56 <ksf> runState
21:15:09 <newsham> thom: consider your earlier example of a state program  s -> (a,s)
21:15:16 <wli> ksf: Yeah, State is not a free monad.
21:15:27 <newsham> for that "return 3" is     \s -> (3, s)
21:15:27 <thom__> <interactive>:1:0: Not in scope: `runState'
21:15:35 <newsham> a state program which doesnt alter the state, but has a result value of 3.
21:15:47 <ksf> you can imagine a "runIO main" somewhere in the magic realms of ghc machinery, that gets stuff out of the IO monad.
21:15:56 <ksf> ...as nothing would ever happen, otherwise.
21:16:00 <pumpkin> it gets () out of it :D
21:16:16 <newsham> pumpkin: that would be  evalIO  ;-)
21:16:31 <Axman6> thom__: :m +Control.Monad.State
21:16:33 <Axman6> i think
21:16:41 <ddarius> The terminology of "getting stuff out of" or "putting stuff in" "a monad" is not very helpful.
21:16:57 <Olathe> If I have a String -> m Bool function that uses fail for early termination, is there a way to do a breadth-first search of all Strings that return True, throwing out prefixes that cause fail ?
21:17:02 <Axman6> i find it helpful for teaching IO to begin with ddarius
21:17:27 <ddarius> Axman6: Not in my opinion.  It reinforces entirely wrong conceptions.
21:17:30 <newsham> axman: why not just say "to run your program" ?
21:17:51 <Olathe> Basically, I have a parser and I want to generate the smallest input that gives the right output.
21:18:10 <newsham> 1st monad tutorial law: monad tutorial is strictly smaller than discussion about monad tutorial
21:18:27 * ksf smells a mathematical thunderstorm coming up, starting with hydrozygomorphic utter trifunctors.
21:18:42 <Olathe> I've heard that monad tutorials smell like Mexican restaurants.
21:18:49 <Olathe> Or something.
21:19:40 <SamB> Olathe: I thought that was a description of a monad tutorial "a monad is like a burrito"
21:19:48 <Olathe> Yes :)
21:20:13 <ddarius> "a monad tutorial is like the lower intestines..."
21:20:14 <thom__> (I'm copying this conversation in hopes of writing a decent blog post about monads, btw) :)
21:21:05 <newsham> thom: feel free to use this ;-)  http://www.thenewsh.com/~newsham/x/machine/monad.html
21:21:09 <pumpkinbot> Title: Monad
21:21:12 <ddarius> thom__: Unless the advice of the blog post is to not read blog posts "explaining" monads, I don't see the point.
21:21:36 <thom__> okay, getting the type signatures of the return function and of >>= has given me something I should go off and contemplate for a while I am thinking
21:21:50 <thom__> writing it in the hopes of understanding it mostly :P
21:22:05 <ddarius> thom__: Have you read "The Essence of Functional Programming" or "Monads for Functional Programming"?
21:22:28 * ksf recommends the monad chapter of rwh and those that lead up to it.
21:22:33 <ksf> @where rwh
21:22:33 <pumpkinbot> is http://www.realworldhaskell.org/blog/
21:22:52 <thom__> so, I've looked at "return" and >>= .... looked at http://ertes.de/articles/monads.html
21:22:55 <pumpkinbot> Title: Understanding Haskell Monads
21:23:59 <ddarius> thom__: Is that a "no" ?
21:24:24 <thom__> I beleive that is a no
21:24:34 <ddarius> Okay, then I highly recommend reading them.
21:24:48 <newsham> "Understanding monads by writing a tutorial (or three)"
21:25:02 <thom__> okay. thanks for the help so far. I will go read them
21:25:15 <SamB> "note: please do not post your tutorials on publicly-visible blogs!"
21:25:36 <newsham> has anyone used songsmith to explain monads yet?
21:25:38 <ddarius> thom__: Either one is enough as they are rather similar.  "Monads for Functional Programming" is a bit more comprehensive and longer but "The Essence of Functional Programming" is a bit more entertaining.
21:25:45 <Olathe> "How monads are like blog posts with no content" by Olathe.
21:26:07 <SamB> Olathe: isn't that only the BlackHole monad ?
21:26:11 <Olathe> Heheh
21:26:14 <SamB> data BlackHole a = BH
21:26:17 <wli> springschool95.ps is what really did it for me.
21:27:38 <SamB> I think I learned by understanding a few actual monads
21:27:55 <SamB> then spent a few months trying to realize that there is no short-and-snappy explanation
21:28:14 <SamB> (well, I wasn't actually trying to realize that, I was trying to come up with one ;-P)
21:28:16 <newsham> if you see the monad on the road, kill the monad.  for it is not the true monad.
21:28:18 <dino-> instance Monad BlackHole where ... return _ = undefined
21:28:23 <wli> SamB: Yeah, that's what springschool95.ps is all about.
21:28:42 <wli> Plus monads aren't really about monads; it's all about monad transformers.
21:28:48 <ddarius> SamB: There is a reasonably short and snappy answer to the "idea" of monads.  There's no short and snappy answer to how to model the variety of side-effects that are out there.
21:29:04 <wli> And that's what springschool95.ps is really all about.
21:29:09 <SamB> ddarius: well, I haven't really found one that helps!
21:29:21 <ddarius> SamB: That's because the latter part is the hard part.
21:29:58 <SamB> well, I was trying to come up with an answer to "what is a monad" that would actually be helpful
21:30:15 <SamB> now I'd probably say "well, nevermind that, just go play with a few and see how they follow the Monad laws"
21:31:02 <newsham> everyone wants to know wha they are befor ethey're ready
21:31:03 <wli> Someone should update springschool95.ps to modern Haskell. Maybe that could be my grand monad tutorial contribution.
21:31:25 <ddarius> SamB: For learning to use them, that's probably the best thing to do.  Few people have any trouble learning to use them and usually those that do have trouble have it because they utterly don't understand the type system.
21:31:52 <SamB> wli: you need source
21:32:00 <wli> SamB: How so?
21:32:07 <thom__> should I read springschool95.ps?
21:32:20 <wli> thom: I highly recommend it.
21:32:30 <SamB> ddarius: well, I think a lot of us have trouble realizing we don't need to "figure out what they are" -- that we already know ;-)
21:32:59 <dino-> Many monads seem to be about abstracting boilerplate away.
21:33:21 <SamB> dino-: that's basically the Haskell programmer's favorite thing to do, period
21:33:32 <wli> I personally think shooting for the moon i.e. monad transformers off the bat is not only better in terms of understanding the things but also get you straight into practical use of them.
21:33:37 <ksf> ...and enforcing boilerplate.
21:33:46 <thom__> grrrr google fail. anyone got a link to springschool95.ps?
21:34:02 <wli> thom: google picks it up as a search key
21:34:40 <dino-> SamB: I've tried to frame it that way to co-workers. That this language is all about doing less work. About working smarter.
21:34:42 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.26.9460
21:34:46 <pumpkinbot> Title: Functional Programming with Overloading and - CiteSeerX
21:34:58 <ddarius> dino-: This and every other language.
21:35:02 <thom__> thanks
21:35:23 <ddarius> thom__: That paper is primarily about type classes and polymorphism with monads as one example.
21:35:36 <SamB> ddarius: well, Haskell is actually pretty GOOD at it, though
21:36:09 <dino-> ddarius: I don't know about that.
21:36:10 <ddarius> SamB: Perhaps, but every language advertises that.
21:36:18 <SamB> wli: how are you going to update the paper without the source  ???
21:36:38 <ddarius> I'm sure you can find somewhere where people claim that Java will reduce boilerplate and lead to more productivity with less work.
21:37:03 <SamB> ddarius: and I might laugh myself silly if I didn't think they actually believed it
21:37:11 <wli> SamB: Not that literal of an update.
21:37:33 <ddarius> SamB: You can update the postscript directly.  It is simply the source code of a programming language.
21:37:39 <thom__> java reduce boilerplate? hahahahahahaha
21:37:55 <ray> dude everyone knows java is all about reducing the boilerplate
21:38:28 <newsham> programming is about writing concise descriptions of large (possibly infinite) tasks
21:38:46 <Gracenotes> @hoogle getes
21:38:47 <pumpkinbot> No results found
21:38:48 <Gracenotes> @hoogle gets
21:38:49 <pumpkinbot> Control.Monad.State.Class gets :: MonadState s m => (s -> a) -> m a
21:38:50 <newsham> java lets you do that vs longer descriptions of tasks
21:38:50 <pumpkinbot> System.FilePath.Posix getSearchPath :: IO [FilePath]
21:38:50 <pumpkinbot> System.FilePath.Windows getSearchPath :: IO [FilePath]
21:38:59 <wli> ddarius: I'd mostly just rewrite the code in modern Haskell and then comment on it in similar ways, not use the literate Haskell source for the paper.
21:39:02 <newsham> (programming is a type of compression)
21:39:20 <ray> java is a type of island
21:40:08 <Gracenotes> I am an island too.
21:40:20 <Axman6> maybe you're java :o
21:40:21 <thom__> hello johnw
21:40:28 <johnw> hi thom__!
21:40:37 <ray> no no, java is a *type* of island
21:40:38 <wli> I really need to learn Arrows and Applicative.
21:40:51 <chrisdone> wli: it's dangerous! take this
21:40:51 <Axman6> ray: it's also an island
21:40:51 <thom__> I have been bugging the nice haskell people
21:40:52 <ray> it's just isomorphic to the unit type
21:40:53 * chrisdone offers a kitten
21:41:08 <Gracenotes> ray: java is a class of island too
21:41:29 <hackage> Uploaded to hackage: gofer-prelude 2.30.1
21:41:35 <Gracenotes> in fact, the only instance where Java wouldn't be a class of island is if it were primitive
21:41:40 * Axman6 theorises that volcanos are the JVM
21:41:52 <johnw> interesting conversation for #haskell :)
21:42:06 <johnw> didn't think I'd find Java chasing me here too
21:42:17 <thom__> we love java in here
21:42:18 <Gracenotes> does it haunt your nightmares too?
21:42:20 <ray> java will haunt me forever
21:42:27 <johnw> java = work hours
21:42:34 <ray> i'm going to die in a java source file
21:42:38 <johnw> haha
21:42:42 <johnw> just don't bury me in one
21:42:42 <thom__> I love java, when compared to C++
21:42:44 <Axman6> wrapped in objects!
21:42:50 <Axman6> thom__: agreed
21:42:51 <johnw> aww, C++ has its moments
21:42:56 <Gracenotes> > runState (gets show) 1
21:42:59 <pumpkinbot>   ("1",1)
21:43:01 * johnw is heavy into C++ at this very moment, fun code
21:43:02 <Gracenotes> ooh
21:43:02 <newsham> java programmers dont die, they're refactored.
21:43:08 <Gracenotes> that is a nice function.
21:43:18 <Axman6> :t gets
21:43:19 <thom__> yes, its moment: The subset of the language called C
21:43:21 <pumpkinbot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
21:43:33 <johnw> thom__: bleh, my brother is one of those
21:43:40 <johnw> "Oh noes, don't show me anything C doesn't have!"
21:43:45 <Gracenotes> it's like \f -> do { get x; put f x }
21:43:59 <newsham> get x; return (f x)
21:43:59 <thom__> I think objective C came closer to getting it "right"
21:43:59 <chrisdone> newsham: computer programming is a lot like magic.[1]
21:43:59 <chrisdone> [1] Harold Abelson, Gerald Jay Sussman, Structure and Interpretation of Computer Programs, The MIT Press, Cambridge, Massachusetts, July 1996, 0262011530.
21:44:22 <Gracenotes> newsham: ah, yeah, that's right :) no state changing...
21:44:24 <Axman6> thom__: in what sense? (i agree though)
21:44:34 <newsham> ?src liftM
21:44:34 <pumpkinbot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:44:37 <Axman6> chrisdone: haha :)
21:44:41 <ray> haskell came a lot closer to getting it right
21:44:41 <Gracenotes> unless it does change the state
21:45:03 <thom__> C++ is too big. everyone winds up using slightly different subsets of the language...
21:45:07 <chrisdone> ray: getting what right?
21:45:24 <Gracenotes> @instances MonadState
21:45:25 <pumpkinbot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
21:45:34 <Axman6> i think the addition of garbage collection to Onjective-C is excellent
21:45:37 <ray> whatever thom__ was talking about
21:45:40 <Axman6> Ob*
21:46:00 <johnw> thom__: there are few parts of C++ I don't use
21:46:11 <thom__> case and point
21:46:12 * ddarius likes C++
21:46:13 <Gracenotes> I wonder if we'll ever get a level of memory management abstraction *above* garbage collection
21:46:29 <thom__> what level would that be?
21:46:45 <Gracenotes> we've transcended (or at least abstracted away) pointers, but can we transcend GC? :\
21:46:54 <Axman6> Gracenotes: sounds like functional programming in a way
21:47:12 <Gracenotes> hm.
21:47:19 <ddarius> Gracenotes: We will when we get infinite memory.
21:47:22 <Axman6> though it needs GC too
21:47:22 <ray> garbage collection collection?
21:47:43 <bos> ddarius: you do??
21:47:52 <ddarius> bos: Yes.
21:48:09 <ray> "i don't know you anymore"
21:48:12 <bos> colour me surprised.
21:48:16 <Axman6> Gracenotes: maybe if we stick a crapload more registers into the CPU, and remove the need for RAM!
21:48:31 <Gracenotes> I wonder if there's enough power to supply for holding infinite memory
21:48:31 <ddarius> bos: So does Pseudonym if you didn't know that.
21:48:31 <pumpkin> :o
21:48:34 * chrisdone opens bos in photoshop
21:49:14 <bos> well, golly.
21:49:38 <pumpkin> :o
21:49:58 <Gracenotes> assuming memory takes power to maintain, there must be a certain amount of memory such that even the Hoover dam couldn't power a system that uses it
21:50:21 <ray> so we just subtract 1 from that and make a hoover dam machine
21:50:21 <Axman6> argh, i do not like magic Core!
21:50:22 <ddarius> Memory doesn't need to take power to maintain.
21:50:50 <newsham> sometimes it takes energy to forget :(
21:51:02 <ddarius> newsham: Indeed.
21:51:06 <intoverflow> I thought that some types of memory do require power to maintain
21:51:20 <kerlo> Memory needs to take power to maintain if it's made of a glassy rather than a crystalline substance, or if some of the atoms in it are radioactive.
21:51:26 <ddarius> intoverflow: They do, but some types isn't all types.
21:51:35 <kerlo> Remind me again whether hydrogen-1 is radioactive. :-)
21:51:51 <Gracenotes> shred -zu past_regrets.txt
21:51:51 <kerlo> Remember, kids: it takes energy to forget, but it doesn't take energy to encrypt!
21:53:23 <Olathe> > '\90'
21:53:25 <pumpkinbot>   'Z'
21:53:32 <newsham> > chr 90
21:53:34 <pumpkinbot>   'Z'
21:53:40 <wli> http://citeseer.ist.psu.edu/424984.html <-- springschool95.ps
21:53:45 <pumpkinbot> Title: Functional Programming with Overloading and - CiteSeerX
21:55:09 <gio123> pumpkin: I would like to creat gio123bot
21:57:09 <pumpkin> gio123: you should :)
21:57:34 <ddarius> gio123: You could have it take your place on here so you can go out and enjoy life.
21:58:04 <pumpkin> gio123: typing @seen Cale must be tiring
21:58:32 <newsham> ddarius: are you a bot?
21:58:42 <ddarius> newsham: I hope so.
21:59:00 <newsham> :)
21:59:29 <ddarius> newsham: What computer code is your child wearing today?
21:59:48 <newsham> he had something more traditional on today
21:59:56 <gio123> ddarius: I do not need ur comments, I do not speak with a such a guy u are
21:59:58 <newsham> but he just had a bath so he must be weraing something else
22:00:00 <newsham> let me check
22:00:11 <pumpkin> o.O
22:00:12 <gio123> pumpkin: :)))
22:00:14 <pumpkin> :)
22:00:23 <newsham> he's sleeping in a dark room, cant check
22:01:04 <pumpkin> after playing outside for hours, he was wearing java, after the bath, he was wearing haskell!
22:01:37 <ray> or Clean
22:01:41 <newsham> pumpkin: the only code he has is sparc asm and some binary representation of ascii letters
22:02:01 <pumpkin> hmm
22:02:09 <pumpkin> I get the impression this isn't a physical son?
22:02:09 <ddarius> "Haskell: 99 and 44/100ths pure"
22:02:13 <newsham> in the semi-sysadmin category he has "I TCP/IP but mostly IP"
22:02:32 <gio123> pumpkin: do u like pumpkin?
22:02:50 <newsham> http://www.thenewsh.com/~jack/2008-oct/2008-OctBaby/100_1241.jpg
22:03:13 <pumpkin> hmm, I kinda like myself, but if I knew myself I probably wouldn't be able to put up with myself
22:04:06 <gio123> i meant whether u like this: http://en.wikipedia.org/wiki/Pumpkin
22:04:10 <pumpkinbot> Title: Pumpkin - Wikipedia, the free encyclopedia
22:04:15 <gio123> http://en.wikipedia.org/wiki/Pumpkin
22:04:19 <pumpkinbot> Title: Pumpkin - Wikipedia, the free encyclopedia
22:04:25 <pumpkin> I've never eaten pumpkin
22:04:25 <newsham> here's the sparc: http://www.thenewsh.com/~jack/2008-nov/picspage/100_1231-nav.html
22:04:32 <pumpkinbot> Title: My hacker shirt
22:04:34 <pumpkin> as I don't eat my own kind
22:04:51 <pumpkin> newsham: aw, I see now
22:05:00 <gio123> pumpkin: then what was a reason of the nick?
22:05:22 <pumpkin> gio123: randomness, and the fact that I like the color
22:09:32 <ubersheep> can anyone offer some general programming advice pls?:
22:10:08 <ubersheep> i need to pick a two languages, 1 I have previously used, and 1 completely new, and should create two apps
22:10:39 <newsham> more information needed
22:10:46 <ubersheep> sry, cat attack
22:10:48 <ubersheep> bk now
22:11:00 <ubersheep> the 2nd language should be preferably obscue
22:11:02 <ddarius> No one ever comes back from dog attacks...
22:11:02 <ubersheep> *obscure
22:11:12 <pumpkin> ubersheep: play with unlambda
22:11:12 <hiredman> hah
22:11:15 <ubersheep> and preferably i'd like to dev a game
22:11:21 <ubersheep> hmmm not heard of that
22:11:39 <ubersheep> sounds painful
22:11:48 <ubersheep> sounds like BRAINFCK
22:11:50 <orbitz> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
22:11:52 <pumpkinbot> Title: The Lazy K Programming Language
22:11:58 <newsham> python and squeak?
22:12:06 <ksf> gave development is a whole subfield on its own, I wouldn't recommend learning a new language for your first one.
22:12:32 <ubersheep> that's exactly what i said at the time - but he's only asking for a 'basic but interesting' app
22:12:35 <orbitz> Fortress and fortran?
22:12:52 <ddarius> Lazy-K, unlambda, brainfuck, psh.
22:12:56 * ddarius suggests Gravity.
22:13:02 <pumpkin> haven't heard of that one :o
22:13:08 <newsham> you did say obscure
22:13:11 <ubersheep> i did
22:13:14 <ksf> then do a breakout-clone.
22:13:16 <ubersheep> (i wish i hadn't)
22:13:18 <pumpkin> http://safalra.com/programming/esoteric-languages/gravity/
22:13:20 <ubersheep> :P
22:13:20 <pumpkinbot> Title: Gravity Programming Language
22:13:33 * ksf recommends malbolge.
22:13:47 <ubersheep>  "esoteric langauges" eh?
22:13:50 <newsham> has anyone done breakout in powershell yet?
22:13:55 <ubersheep> X(
22:13:59 <ksf> i've seen a sokoban in sed
22:14:28 <orbitz> what about python and J
22:14:32 <lament> newsham: sounds too easy
22:14:37 <kerlo> The Gravity Programming Language is probably the best programming language ever invented.
22:14:38 <ksf> if you want something obscure, you can try agda or epigram, too.
22:14:50 <newsham> lament: *nod* i didnt mean it would be a brain teaser
22:14:54 <ksf> they're literally designed to make you realize you don't know jack.
22:14:56 <mriou> ubersheep: Dylan
22:15:02 <kerlo> Very difficult to compile to, very difficult to compile from.
22:15:04 <shapr> Hey! I missed johnw!
22:15:04 <ubersheep> python i've been exploring for the time being, seems easy enought o pick up
22:15:12 <lament> somebody needs to create a programming langugae Dylan Thomas
22:15:25 <ubersheep> gravity looks scary, as does fortran(!)
22:15:30 <shapr> Dang, haven't seen johnw around in years.
22:15:32 <pumpkin> ubersheep: you came to #haskell, I think you have a pretty good idea of what we'll recommend on average
22:15:34 <newsham> ksf: you can pretty much do your normal haskell schtick in agda
22:15:40 <orbitz> Coq?
22:16:01 <ubersheep> pumpkin, agreed :D either way these are great suggestions for starting off with
22:16:05 <shapr> HOL?
22:16:40 <ksf> newsham, but you don't have to write proofs to satisfy ghc...
22:16:45 <mriou> scheme would be my firs choice, even though it's mildly obscure
22:16:56 <ubersheep> newsham, I think I actually might be going with squeak and something, I had been looking into using smalltalk for something
22:17:10 <ksf> scheme is a good idea.
22:17:19 <ksf> especially because there's sicp and the little schemer.
22:17:42 <ksf> same goes for Oz and CTM
22:19:21 <ubersheep> mriou, dylan seems interesting, have you used it?
22:20:09 <mriou> ubersheep: a bit yes although not extensively, I'm not that annoyed by s-exp
22:20:16 <wy> hello
22:20:32 <mriou> but if you can't stand the lisp syntax, dylan is a good choice
22:20:49 <mriou> if you can stand it, scheme is a better choice :)
22:20:55 <wy> mriou: Why not? Lisp syntax is good
22:21:01 <pumpkin> "syntax"
22:21:29 <wy> I have a question. Just in case someone has thought about it...
22:21:31 <ksf> syntax-define
22:21:41 <ubersheep> hmm <looks into it>
22:21:53 <mriou> wy: it serves a purpose I tend to like yes, but saying that most people find it annoying would be an understatement
22:21:55 <ubersheep> sry if i'm quiet, suddenly have tons of stuff to look at
22:22:03 <wy> How many lambda terms can there be made up of 6 variables?
22:23:01 <wy> mriou: well, there are downside of it. But in general I think s-expressions are good
22:23:23 <mriou> wy: depends on your definition of "good" :)
22:24:16 <mriou> readable, not so much, although you get used to it
22:24:27 <wy> mriou: but Lisp and scheme people tends to overuse the flexibility of it :P
22:24:28 <mriou> but then homoiconicity has many other advantages
22:25:22 <mriou> the IO syntax is a good balance if you ask me
22:25:52 <ddarius> wy: Six usages of a variable or six bindings or six names?
22:26:32 <wy> six names: x, y, z, a, b,c. and lambda, abstraction, application
22:27:19 <ddarius> wy:  Then you can easily make an infinite number.
22:27:45 <wy> ddarius: No duplicated variable use
22:29:31 <ddarius> Requiring affineness puts pretty extreme limitations on what you can do without limiting the number of variable names.
22:29:58 <wy> ddarius: what does affineness mean?
22:30:13 <ddarius> wy: It means you can use a variable at most once.
22:30:17 <wli> Hmm. :k (->) yields ?? -> ? -> * ; what do the question marks mean?
22:30:41 <koninkje> kind ? = * | #
22:30:44 <ddarius> wli: They are a GHC extension to deal with unboxed types (which have kind #)
22:31:06 <wy> ddarius: Yes. That's a problem I came up when trying to reversing my CPS transfomer. It easily takes all memory with six variables.
22:33:14 <wy> ddarius: I just guess it's much bigger than the number of trees with six leaves. Needs some math to count this...
22:33:19 <wli> Is there a difference between one question mark and two?
22:33:27 <ddarius> wli: Yes.
22:33:30 <koninkje> Yeah
22:33:34 <abbe> hi all
22:33:43 <abbe> anyone using haskell-mode with GHC 6.10.1 ?
22:33:56 <wli> Uh-oh, what's two question marks/
22:35:17 <abbe> I think ghci (from 6.10.1) is behaving differently from previous versions. It now echoes '<input string>^J' for each input string I enter in inferior-haskell-buffer
22:37:16 <koninkje> wli: see Kinds Are Types @ http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
22:37:19 <pumpkinbot> Title: IntermediateTypes - GHC - Trac
22:38:26 <koninkje> I mixed them up, kind ?? = * | # ; kind ? = ?? | (#)
22:39:08 <ubersheep> ooooh i getya
22:39:12 <koninkje> In general you can ignore the distinction and think only of * "normal" and #,(#),?,?? "weird"
22:39:13 <ubersheep> thought it was like
22:39:16 <ubersheep> 'kind'
22:39:18 <ubersheep> as in nice
22:39:42 <koninkje> term <= type <= kind <= variety ... :)
22:40:03 <ubersheep> ic
22:40:09 <ubersheep> that kind of kind
22:40:31 <koninkje> Or you can just forget all the names nd use Omega <http://web.cecs.pdx.edu/~sheard/Omega/index.html>
22:40:38 <wli> I suspect things will most often be ? -> ? -> ? or some such.
22:41:21 <koninkje> (?? -> ?? -> ... -> ?) actually, since unboxed tuples can only be returned, never passed
22:42:08 <koninkje> since "unboxing" tuples means storing the fields in registers
22:43:57 <koninkje> Again, this is all GHC wackiness. Hugs just has * (and *->*,...). While ---I think it's--- jhc has a whole different slew of things since it doesn't have uniform representations like GHC's STG does
22:44:32 <koninkje> The last one is whichever one does whole-program compilation. I forget if it's nhc/yhc or jhc/lhc
22:45:56 <ddarius> koninkje: JHC/LHC are based on Pure Type Systems so it should have a rather rich kind language.
22:46:10 <ddarius> Onoz and Banana Scheme seem interesting.
22:51:39 <ddarius> Some loose ends that came up during implementation of FC:
22:51:39 <ddarius>     * there is a strange unsafeCoerce that we could not figure out the purpose of in the FFI, a warning is currently emitted when it is used
22:51:39 <ddarius>     * removed the -DBREAKPOINT definition in the Makefile because it induced a module loop, we should probably fix this
22:51:39 <ddarius> Download in other formats:
22:52:05 * ksf would like some mathematician to annotate category-extras for mere mortals
22:52:37 <ddarius> ksf: There are almost no mathematicians that would readily understand most of it.
22:53:48 <ubersheep> i was talking to my partners friend about what I do as a career
22:54:01 <pumpkin> cata :: Functor f => Algebra f a -> FixF f -> a	
22:54:02 <ddarius> edwardk is probably the only person that could do it reasonbly quickly.  It's not particularly difficult, it's just a lot of stuff that would be harder to reverse engineer than to write in the first place.
22:54:04 <ubersheep> he said programmer? So, you build robots and make them have gay sex with eachother?
22:54:10 <ubersheep> i walked away.
22:54:16 <pumpkin> Futumorphism?
22:54:53 <ubersheep> dylan seems good so far
22:55:27 <pumpkin> g_prepro_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> (f :~> f) -> FixF f -> a	
22:56:18 <augustss> haha
22:56:28 <pumpkin> :)
22:56:39 <pumpkin> I like that there's Control.Morphism
22:56:42 <augustss> That's all I have to say about g_prepro_zygo
22:56:50 <pumpkin> and in case that wasn't meta enough for you
22:56:56 <pumpkin> you have Control.Morphism.Meta
22:57:40 <augustss> Yeah, well.  My brain is too concrete for such things.
22:58:09 <ddarius> Metamorphisms are pretty straightforward.
22:58:24 <koninkje> ksf: It's only a partial solution, but you can look through Edward Kmett's blog. Or more rather, his dead blog via the Wayback machine or similar
22:58:27 <ddarius> It's just the opposite of a hylomorphism.
22:58:53 <koninkje> http://knol.google.com/k/edward-kmett/catamorphisms/3qi7x2qrdushx/2
22:58:54 <pumpkin> ah, fair enough
22:58:56 <pumpkinbot> Title: Catamorphisms - a knol by Edward Kmett, http://tinyurl.com/5jms9n
22:58:57 <koninkje> frex
22:59:52 <|jedai|> Yeah, there was a good serie on Cata/Hylo/Meta-morphism on a blog some month ago, I think it wasn't finished though
23:00:17 <ddarius> |jedai|: That would be Edward Kmett's, the author of category-extras.
23:01:01 <koninkje> Kmett's (living) blog (though it's kinda dead at the moment): http://comonad.com/reader/
23:01:06 <pumpkinbot> Title: The Comonad.Reader
23:01:24 <|jedai|> ddarius: Yes, he gave a clear explanation and plenty of examples, good reading
23:01:36 <koninkje> edwardk++
23:02:52 * ksf fears what he's trying to do is easier to code in agda than in haskell, as he wouldn't have to fight hindley-milner
23:03:08 <ddarius> ksf: What are you trying to do?
23:03:10 <koninkje> What're you up to?
23:03:31 <mriou> cabal question: I have sources under a src directory, I've declared hs-source-dirs and the modules main depends on in other-modules
23:03:36 <ksf> I'm trying to do a kind of fold on a list of data Splice a b = forall c. Splice (a -> Maybe c) (c -> b)
23:03:47 <mriou> yet it doesn't file the sources for those modules
23:04:00 <ksf> and the existential in the branches give me the creeps
23:04:23 <mriou> I get "Setup.hs: can't find source for Wy.Parser in src, dist/build/autogen"
23:05:07 <ksf> it's a matter of scoping: haskell requires c not to escape, I need it to escape.
23:05:25 <mriou> any idea of what I'm missing?
23:06:30 <koninkje> algebra :: a -> b -> (Splice a) b -> b ; algebra in def (Splice f g) = case f x of { Nothing -> def ; Just y -> g y }
23:06:36 <koninkje> ...should work
23:07:00 * ksf needs to let that sink in.
23:07:03 <koninkje> partially applied with the first two arguments so it's actually an (Splice a)-algebra
23:07:42 <ddarius> ksf: Haskell isn't requiring that, the semantics of existentials is.
23:07:53 <ksf> ...
23:08:18 <koninkje> Assuming you're folding over a value of Fix (Splice a) then you can use (cata $ algebra a b) to do the fold
23:08:28 <ksf> well, I could keep the structure and write a proof, but ghc wouldn't care.
23:09:42 <ksf> konikje++
23:09:44 <mriou> k, found my problem
23:10:03 <ksf> ...although I still have to get it, I think it's gonna work.
23:10:04 <sclv> what's the difference between Splice and just a -> Maybe b ??
23:10:14 <ksf> oh.
23:10:19 <ksf> koninkje++
23:10:23 <ksf> konikje--
23:10:44 <pumpkin> dons: have you had a chance to look at my changes to uvector? I just don't want to waste both our times submitting more patches for it if I'm doing really stupid stuff to it :)
23:11:11 <ksf> sclv, the pairing with (c -> b).
23:11:17 <sclv> i'm probably missing something really obvious, but it doesn't look on the face of it like that existential is actually giving you more expressive power.
23:11:51 <ddarius> sclv: It gives you a small bit, but not much.
23:12:06 <sclv> ksv: all you can do with a Splice a b is feed it an a and maybe get back a b, right?
23:12:13 <sclv> so that's equiv to a -> Maybe b
23:12:50 <koninkje> ksf, why the -- ?
23:13:06 <ksf> koninkje, typo.
23:13:11 <|jedai|> koninkje: He did that to the nonexistent konikje
23:13:59 <ksf> a -> Maybe b means, in my context, that a functor gets split into a's that can be converted to b's and those that cannot.
23:15:07 <ksf> I'm trying to figure out how to dispatch on types without having to come up with names for gazillions of points.
23:15:29 <ddarius> ksf: His point is that the only thing you can do with a value of type Splice a b is (essentially) compose the two components, so you might as well just do that from the get-go.
23:15:54 <ksf> yeah, I found that out too, the hard way.
23:15:56 <sclv> So you have forall c. Splice (a -> Maybe c) (c -> b). Now if your first function returns Nothing, you have to return the equiv of Nothing for the whole computation, since you don't have anything to feed into (c->b).
23:16:45 <sclv> i've found that 90% of the time when i start with existentials, i end up with a solution that doesn't require them.
23:16:50 <ksf> nah, the value that isn't convertible gets passed on to the next splice until it hits a bottom case, which then loops back.
23:17:09 <ksf> ...connecting all the threads again.
23:18:06 <koninkje> (Splice f g)$x def, if you will, is equivalent to fromJust((g =<< f x) `mplus` Just def)
23:18:09 <ksf> like this: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1087
23:18:43 <chrisdone> I have found writing a tutorial about something as a blog post really improves your understanding
23:18:48 <koninkje> er, fromJust((liftM g (f x)...) I mean
23:19:09 <sclv> right.. but that next splice starts with the a again. so if you have a list [a -> Maybe b] you can turn your entire first pass over the list into: mconcat . map (fmap First)
23:19:22 <ddarius> chrisdone: Just don't actually post the tutorial and everyone wins.
23:19:47 <chrisdone> ddarius: didn't you like my formlets tutorial?
23:19:49 <sclv> you assume the tutorial involves monads
23:20:19 <ddarius> chrisdone: Unless you meant having feedback on an attempt improves understanding, not just the writing.
23:20:42 <mriou> another cabal question: I have a package installed locally that I want to use in another, cabal lists it as "installed" but not "available"
23:20:47 <ksf> sclv, I've got pairs of a -> Maybe b and b -> c, a lot of them, and with different b's.
23:21:07 <ksf> with, in general, no common supertype.
23:21:15 <mriou> and cabal configure on the other package then fails with a missing depency
23:21:31 <mriou> how do I make it available (I've tried register)?
23:21:52 <koninkje> ksf: do you need to store the (f.g) pairs anywhere or are you only applying them?
23:22:13 <ddarius> sclv: Not necessarily.
23:22:42 <ddarius> Admittedly, sharpening ones understanding is different from building it and the in the former case posting the tutorial is fine.
23:23:09 <|jedai|> ksf: So with Splice you can make a list of those pairs and eventually apply them to an a (or a bunch of a) but I don't see why you need a fold and how you want to use it
23:23:24 <koninkje> splice f g d x = fromJust $ liftM g (f x) `mplus` return d
23:23:33 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1087#a1096
23:23:43 <sclv> ksf: but if you make Splice a b = a -> Maybe b then that's going to have all the same information, and without the ugly existential, and without the confusing promise that you can do anything with that existential value except exactly what you get by writing a -> Maybe b in the first place.
23:23:54 <ksf> ...compare the first with the second and think about how fast the second one becomes unmanageable.
23:25:13 <cognominal> what is the meaning of $(   )   ?
23:25:36 * ksf isn't sure whether he actually got a problem or is the victim of creeping typeism.
23:25:42 <koninkje> Just partially apply the f and g (and maybe the d) and store the remaining function. You "existential" comes for free from just treating the splice function as if it were a data type. No need for a datatype at all
23:26:11 <koninkje> cognominal: It's Template Haskell for "splicing"
23:26:45 <koninkje> cognominal: assuming the TH extension is turned on. Otherwise it's just function application ($) and some exessive parentheses
23:26:59 <sclv> Splice a g = a -> Maybe b; xEventSplice a = Splice (g <$> fromEvent a)
23:27:03 <dons> average discussion in this channel per day, since launch, in kb, http://haskell.org/haskellwiki/Image:Irc-raw.png (moving average)
23:27:04 <pumpkinbot> Title: Image:Irc-raw.png - HaskellWiki
23:27:09 <dons> yes: it is getting busy in here.
23:27:29 <dons> sclv: (using the gnuplot bindings, btw)
23:28:07 <ddarius> Almost half a meg a day...
23:28:20 <pumpkin> wow
23:28:42 <sclv> dons: the dev version of gtk installed fine for 6.10 actually, so we're still using chart with no problem. made the 6.10 upgrade in just about a day, including head build, package installation, and code fixes.
23:28:44 <pumpkin> half of it is my bot posting the titles of URLs
23:28:44 <ksf> "a1" just turned from an enemy into a friend.
23:28:49 <ksf> thanks everyone.
23:28:50 <|jedai|> pretty impressive !
23:28:56 <cognominal> so in a lambdabot plugging  $(plugin "Dict")  would mean?
23:29:05 <pumpkin> let's integrate! and find out total
23:29:26 <ddarius> pumpkin: You can just download the logs and check the size.  It's pretty large...
23:29:33 <pumpkin> yeah :)
23:31:20 <ddarius> If everyone organizes there typing properly we can produce PDF/PS files for two or three academic papers a day at this rate.  If we were just to consider the LaTeX source, say, probably around 8-10 papers a day.
23:32:08 <sclv> unfortunately, these papers would be largely composed of @vixen and @quote responses :-)
23:32:22 <dons> sclv: yes, i see that head works fine.
23:33:48 <sclv> for graphs with a time axis, chart is relatively smart about figuring out how to display it best, which is really nice as well.
23:35:17 <ksf> half a meg is how many metres of printed paper?
23:35:20 <dons> yeah, i noticed that.
23:35:48 <koninkje> ksf: did you see my http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1087#a1097 ? There's no need for the Splice data structure, let alone the existential types. If you like, you can use type Splice a b = b -> a -> b
23:37:10 <ksf> I didn't, I copied the definition out of irc instead ;)
23:37:20 <koninkje> same thing :)
23:38:30 <ksf> I really have to get to terms with the more arcane corners of the type system.
23:39:59 <pumpkin> http://haskell.org/sitewiki/images/3/3c/Haskell-current.png is interesting :)
23:40:06 <pumpkin> pity it's out of date
23:41:04 <beelsebob> Does anyone here use wordpress for presenting their Haskell ramblings?
23:42:37 <redditbot> #haskell is a busy place
23:43:02 <pumpkin> orly?
23:43:21 <astrobunny> whoa...
23:43:25 <astrobunny> monads are @_@
23:43:40 <pumpkin> @wn @_@
23:43:40 <pumpkinbot> No match for "@_@".
23:43:46 <pumpkin> I don't know that adjective
23:43:49 <dons> beelsebob: yeah
23:44:02 <beelsebob> dons: what do you use to get Haskell syntax highlighting?
23:44:06 <dons> donsbot.wordpress.com (haven't solved the syntax highlighting issue yet, but i think hscolour can be tweaked)
23:44:12 <beelsebob> ah, bah
23:44:24 <dons> i used to use hscolour. but wordpress needs font or span tags generated
23:44:27 <dons> i think hscolour can do that
23:44:33 <dons> so don't use css, use native html
23:44:37 <thom__> when I see something like putChar :: Char -> () the () mean what? an empty tuple?
23:44:45 <dons> Char -> IO ()
23:44:49 <ksf> :t ()
23:44:50 <dons> yes, () is the empty tuple
23:44:50 <pumpkinbot> ()
23:44:54 <dons> it has 2 values, () and undefined
23:44:58 <ksf> nah, it's the unit type.
23:45:02 <ksf> it's no tuple.
23:45:06 <dons> quite.
23:45:14 <dons> no tuple it.
23:45:24 <thom__> which is a different thing than an empty list I assume?
23:45:30 <pumpkin> yup
23:45:45 <thom__> okay. thanks
23:46:02 <dons> yeah, the empty list is one of many values of the recursive list type
23:46:04 <beelsebob> cheers dons, that should keep me experimenting for a while
23:46:42 <dons> beelsebob: yeah, see e.g. http://donsbot.wordpress.com/2009/01/31/reviving-the-gofer-standard-prelude-circa-1994/ has some fragments done by hand
23:46:43 <pumpkinbot> Title: Reviving the Gofer Standard Prelude (circa. 1994) Â« Control.Monad.Writer, http://tinyurl.com/bedrv4
23:46:50 <dons> almost certain hscolour won't take much tweaking to work
23:47:04 <pumpkin> anyone know how to turn off the HTML title posting in lambdabot other than editing the code?
23:47:09 <ksf> actually, it could be putChar :: Char -> IO (_|_)
23:47:16 <ksf> ...just to educate people.
23:47:17 <beelsebob> dons: ah, now that's solving at least one of my problems â€“ how to get indentation to work
23:47:38 <dons> beelsebob: needs to generate <span style="color:#008080;"> things
23:48:00 <dons> oh, indentiation is easy. <pre> then use the indent thing in the wordpress editor
23:48:14 <dons> which generates <pre style="padding-left:30px;">
23:48:34 <beelsebob> yeh â€“ I had it in my head that pre was like \begin{verbatim} in LaTeX â€“ you couldn't put any styling in it
23:48:48 <beelsebob> if I get hscolor to generate the source you need, I'll ping you with the options :)
23:49:15 <luqui> ksf, that would imply that putChar would never return
23:50:19 <dons> beelsebob: it'd be nice to have hscolour --wordpress :) (i.e. html + span)
23:50:26 <luqui> ksf, i.e. continuations can have a type like that (and they basically do:  _|_ = forall a. a)
23:50:27 <beelsebob> indeed
23:53:10 <ksf> luqui, also if you use >> instead of >>=, which is my point?
23:53:19 * ksf successfully confused himself.
23:53:30 <luqui> ksf, huh?
23:54:24 <ksf> well, you can pass on the IO , and never care about the value it contains.
23:54:51 <luqui> ksf, well, yeah, but you're being evil.  it's good to at least *pretend* our logic is consistent.
23:54:52 <ksf> > return undefined >> [1]
23:54:54 <pumpkinbot>   [1]
23:55:08 <luqui> which, if it were, IO _|_ could not contain any value whatever
23:55:33 <ksf> I'm not evil. I'm just cute and wicked.
23:55:33 <somnolence> is there anyway
23:55:37 <somnolence> to not return anything from a function
23:55:47 <somnolence> e.g. in factors n = (map (\x -> if n `mod` x == 0 then n else 0) [1..n])
23:55:49 <somnolence> is there a way
23:55:54 <somnolence> I can return nothing
23:55:56 <luqui> somnolence, what on earth would you do with such a function? :-)
23:55:56 <somnolence> on the else condition?
23:56:06 <somnolence> ^
23:56:10 <luqui> somnolence, oh, you probably want the Maybe type
23:56:20 <somnolence> example?
23:56:22 <ksf> somnolence, factors = undefined.
23:56:25 <ksf> never returns a thing.
23:56:31 <luqui> factors n = (map (\x -> if n `mod` x == 0 then Just n else Nothing) [1..n])
23:56:39 <somnolence> thanks
23:56:41 <pumpkin> somnolence: sounds like you want an empty list though
23:56:47 <somnolence> naw
23:56:52 <pumpkin> o.O
23:56:58 <pumpkin> alright :)
23:57:13 <somnolence> :t Maybe
23:57:15 <pumpkinbot> Not in scope: data constructor `Maybe'
23:57:23 <somnolence> pumpkin bot < lambda bot
23:57:29 <ksf> ... then n else error "It is unknown whether Gurus will ever stop meditating"
23:57:30 <luqui> :t Just
23:57:30 <pumpkin> maybe http://is.gd/Gf7 ?
23:57:32 <pumpkinbot> forall a. a -> Maybe a
23:57:33 <somnolence> =P
23:57:35 <luqui> :t Nothing
23:57:36 <pumpkinbot> forall a. Maybe a
23:57:39 <luqui> :k Maybe
23:57:40 <somnolence> :t pumpkin
23:57:41 <pumpkinbot> * -> *
23:57:41 <pumpkinbot> Not in scope: `pumpkin'
23:57:44 <somnolence> pumpkin
23:58:20 <dons> btw, don't want to alarm anyone, but #haskell is the largest language channel on freenode atm, http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
23:58:20 <pumpkinbot> Title: Search IRC, displaying all channels on freenode
23:58:29 <dons> we made the top 5 chans. shapr will be pleased.
23:58:32 <pumpkin> yay
23:58:37 <Gracenotes> \pumpkin -> pumpkin pumpkin
23:58:39 <luqui> woo!
23:58:47 <luqui> @users
23:58:47 <pumpkinbot> Maximum users seen in #haskell: 642, currently: 591 (92.1%), active: 15 (2.5%)
23:58:51 <Gracenotes> oh, neat :)
23:59:27 <dreamz93> u go girl
23:59:29 <somnolence> um
23:59:31 <somnolence> that just fills the list
23:59:33 <somnolence> with Nothing...
23:59:34 <somnolence> -.-
23:59:52 <somnolence> gah <_<
