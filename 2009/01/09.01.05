00:00:18 <Gracenotes> BMeph: heh. Yeah, there was this one specifically, but it also used the assertion as a basis for other claims about type systems
00:00:34 <Gracenotes> argh. I don't use bookmarks enough
00:02:38 <semarie> my problem : when a chain filterM and mapM , its break lazyness (my IO list is all evaluated)
00:03:24 * semarie hope help
00:03:36 <quylui> 02:59 <lepassive> http://learnyouahaskell.com/ is really awesome
00:03:47 <quylui> oh oops, i don't know how that happened. disregard that
00:03:54 <Saizan_> semarie:  yeah, IO is there to sequence side-effects
00:04:37 <ddarius> This is an instance where concurrent composition would be not unsensible.
00:04:52 <BMeph> Gracenotes: I faintly recall mjd doing a talk on the subject, or maybe he was just passing it along - I'll poke around the perl-iverse. ;)
00:05:20 <semarie> ok, but for test i work with IO [Integer]
00:05:36 <semarie> list10u = return [0, 1, 2, undefined]
00:06:25 <semarie> liftM (take 2) $ return [0,1,2,3,4,undefined]
00:06:30 <semarie> [0,1]
00:06:34 <semarie> ok no problem
00:07:02 <semarie> same for:  liftM (take 2) $ return [0,1,2,3,4,undefined] >>= filterM (\n -> return $ n>2)
00:07:10 <semarie> [3,4] : no problem
00:07:23 <semarie> but : liftM (take 2) $ return [0,1,2,3,4,undefined] >>= filterM (\n -> return $ n>2) >>= mapM (\n -> return $ n+1)
00:07:31 <lepassive> what is the problem ? safeSecond :: [a] -> Maybe a
00:07:31 <lepassive> safeSecond [] = Nothing
00:07:31 <lepassive> safeSecond x:xs = just head (tail xs)
00:07:31 <lepassive> safeSecond _ = Nothing
00:07:40 <semarie> *** Exception: Prelude.undefined
00:08:04 <vixey> lepassive: safeSecond _ = Nothing, cannot occur
00:08:06 <dmwit> s/just/Just $/
00:08:18 <vixey> lepassive: safeSecond x:xs, not totally sure, but maybe it should be (x:xs)?
00:08:22 <Gracenotes> BMeph: that would be interesting. I seem to recall the essay involving Java... I still don't quite know what to make of Java's type system :)
00:08:23 <dmwit> Also, there's a logic error, as vixey sasy.
00:08:29 <lepassive> vixey, isn't it like a global catch for anything else
00:08:35 <ddarius> vixey: Yes, that's a syntax error.
00:08:40 <lepassive> vixey, OK I'll try
00:08:47 <ddarius> (Albeit barely)
00:08:50 <vixey> lepassive: the thing is there is nothing else, in the type of lists
00:09:15 <lepassive> vixey, maybe a list with one element ?
00:09:34 <vixey> > let  (x:xs)  =  [2]  in  (x, xs)
00:09:35 <lambdabot>   (2,[])
00:09:58 <ddarius> semarie: filterM has to look at the element to know whether to return it and it filters the entire list before returning.
00:09:59 <Saizan_> ?src filterM
00:09:59 <lambdabot> Source not found. :(
00:10:11 <baaba> > let _ !!! n | n < 0 = Nothing; (x:xs) !!! 0 = Just x; [] !!! _ = Nothing; (x:xs) !!! n = xs !!! (n - 1) in [1, 2, 3] !!! 2
00:10:12 <lambdabot>   Just 3
00:10:20 <Saizan_> ddarius: why it works with just filterM?
00:10:24 <baaba> > let _ !!! n | n < 0 = Nothing; (x:xs) !!! 0 = Just x; [] !!! _ = Nothing; (x:xs) !!! n = xs !!! (n - 1) in [1, 2, 3] !!! (-1)
00:10:25 <lambdabot>   Nothing
00:10:25 <lepassive> safeSecond :: [a] -> Maybe a
00:10:26 <lepassive> safeSecond [] = Nothing
00:10:26 <lepassive> safeSecond (x:xs) = Just head (tail xs)
00:10:27 <dmwit> ddarius: Surely it's the mapM that's dying.
00:10:55 <lepassive> gives me: MySecond.hs:13:20:
00:10:56 <lepassive>     Couldn't match expected type `[a] -> Maybe a'
00:10:56 <lepassive>            against inferred type `Maybe ([a1] -> a1)'
00:10:56 <lepassive>     In the expression: Just head (tail xs)
00:10:56 <lepassive>     In the definition of `safeSecond':
00:10:56 <lepassive>         safeSecond (x : xs) = Just head (tail xs)
00:10:58 <semarie> ddarius: filterM need it only if (take 2) need it
00:10:58 <lepassive> Failed, modules loaded: none.
00:11:04 <baaba> lepassive, what happens with safeSecond [1]?
00:11:18 <Saizan_> lepassive: don't paste that many lines here.
00:11:19 <dmwit> lepassive: You're trying to apply "Just" to two arguments, when it takes only one.
00:11:21 <Saizan_> @paste
00:11:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:11:25 <vixey> lepassive, also I think you should try to write  safeNth instead of safeSecond
00:11:25 <semarie> and it didn't (undefined is third)
00:11:27 <lepassive> baaba, It doesn't load
00:11:31 <ddarius> Actually, what monad is being used here?
00:11:32 <Saizan_> use that site ^^^
00:11:43 <semarie> i use IO
00:11:46 <dmwit> lepassive: Just x y parses as (Just x) y, not as Just (x y)
00:11:46 <baaba> lepassive, huh? i mean think it through
00:11:59 <BMeph> Gracenotes: mjd's talk notes are here: http://perl.plover.com/classes/typing/notes.html
00:12:15 <baaba> @let _ !!! n | n < 0 = Nothing; (x:xs) !!! 0 = Just x; [] !!! _ = Nothing; (x:xs) !!! n = xs !!! (n - 1)
00:12:16 <lambdabot>  Defined.
00:12:22 <baaba> :t (!!!)
00:12:23 <lambdabot> forall a1 a. (Num a, Ord a) => [a1] -> a -> Maybe a1
00:12:29 <dmwit> lepassive: Even when you get it compiling, though, that code is not safe.
00:12:43 <sereven> > tail [1]
00:12:44 <lambdabot>   []
00:12:57 <Gracenotes> BMeph: thankye
00:13:12 <semarie> ddarius: not IO, in my command line type is (Monad m, Num a, Ord a) => m [a]
00:13:26 <dmwit> safeSecond = listToMaybe . drop 1 -- ;-)
00:13:32 <lepassive> safeSecond (x:xs) = Just (head (tail xs)) now it works
00:13:55 <dmwit> lepassive: It works, but is wrong; try "safeSecond [1]" to see what I (and baaba) mean.
00:15:12 <lepassive> dmwit, safeSecond [x] = error "List too short." just above the safeSecond (x:xs) right ?
00:15:26 <dmwit> Why would you do that?
00:15:31 <baaba> hahaha
00:15:31 <dmwit> That's not safe!
00:15:37 <Workybob> that's awesomely unsafe
00:15:43 <dmwit> Just use "Nothing" like the [] case...
00:16:20 <lepassive> this is the code http://hpaste.org/13628
00:16:27 <baaba> > drop 1 []
00:16:28 <lambdabot>   []
00:16:49 <lepassive> dmwit, shouldn't I raise errors ?
00:16:59 <vixey> you can use throwError
00:17:08 <dmwit> lepassive: Definitely not with a function of that type.
00:17:35 <dmwit> lepassive: Think for a second: why aren't you calling error for the [] case?
00:17:41 <dmwit> lepassive: The argument for the [x] case is identical.
00:17:46 <baaba> lepassive, what the hell would be the point of making a "safeSecond" function if it'll just give you an error anyway?
00:18:05 <vixey> baaba, I'm supposing that it could be a learning experience .. :p
00:18:13 <lepassive> dmwit, I got it
00:18:23 <lepassive> baaba, It's my first big function :(
00:18:29 <baaba> eh
00:18:39 <dmwit> lepassive: But, you should learn to leverage pattern matching more.
00:18:47 <rwbarton> semarie: it's because the result of the filterM is basically 3 : 4 : _|_
00:18:59 <dmwit> lepassive: safeSecond (x:y:rest) = Just y -- a nice first case to write
00:19:08 <rwbarton> semarie: not 3 : 4 : _|_ : [] for instance.  Try removing the filterM and then the mapM will work just fine.
00:19:08 <dmwit> lepassive: Do you know about the _ pattern?
00:19:12 <lepassive> dmwit, from lower to upper not random
00:19:26 <dmwit> lepassive: uh, what?
00:19:36 <semarie> rwbarton: yes, but my liftM (take 2) need only [3, 4]
00:19:36 <lepassive> dmwit, yes safeSecond (_:second:_) = just second
00:19:43 <vixey> @let __ = __
00:19:45 <lambdabot>  Defined.
00:19:49 <rwbarton> semarie: that's because take 2 (3 : 4 : _|_) = 3 : 4 : []
00:19:55 <vixey> :t 1 + __ : 3 : __
00:19:56 <lambdabot> forall t. (Num t) => [t]
00:19:57 <baaba> :t __
00:19:58 <lambdabot> forall t. t
00:20:03 <rwbarton> semarie: but mapM has to traverse the entire spine of the list in case there are effects in it
00:20:05 <dmwit> lepassive: Right; so "safeSecond (_:x:_) = Just x; safeSecond _ = Nothing" would be a totally reasonable way to write that function.
00:20:06 <baaba> wait what
00:20:14 <ddarius> rwbarton: Yeah.
00:20:22 * vixey safeSecond = safeNth 2
00:20:37 <baaba> > [1, 2, 3, 4] !!! 5
00:20:37 <vixey> (or 1, if you lost a finger)
00:20:38 <lambdabot>   Nothing
00:20:41 <semarie> but "liftM (take 2) $ return [0,1,2,3,4,undefined] >>= mapM (\n -> return $ n+1) >>= filterM (\n -> return $ n>2)" work
00:20:51 <rwbarton> semarie: indeed
00:20:54 <semarie> (inversion in mapM and filterM order)
00:21:05 <rwbarton> semarie: because the spine of the list passed to mapM is totally defined
00:21:13 <lepassive> dmwit, you are very much right thanks :)
00:21:21 <ddarius> rwbarton is spot on
00:21:22 <rwbarton> semarie: mapM is sequencing exactly 6 effects
00:23:24 <Gracenotes> heh, I have ammassed quite a few reddit comments in my bookmarks. Can't say the same thing about Digg
00:24:16 <lepassive> how much haskell fits in large projects ?
00:24:17 <Saizan_> rwbarton: doesn't filterM needs to sequence 6 effects too?
00:24:34 <Saizan_> rwbarton: if you put it first i mean
00:25:14 <rwbarton> Saizan_: Yes, but return is not strict
00:25:38 * vixey wonders what to write.
00:25:49 <vixey> today is probably a slow day :..
00:26:02 <Saizan_> i guess filterM is not strict on the Bool as i would think
00:26:23 <semarie> rwbarton: with only mapM, it work :
00:26:25 <semarie> liftM (take 2) $ return [0,1,2,3,4,undefined] >>= mapM (\n -> return $ n+1) [1,2]
00:26:34 <ddarius> vixey: Implement the pure pattern calculus.
00:26:37 <semarie> [1,2] (on a new line)
00:26:49 <enticingjelly> pure pattern calculus?
00:26:50 <rwbarton> semarie: yes, I tried that, that's how I figured out what was going on
00:26:55 <ddarius> rwbarton has already explained why that is.
00:27:08 <ClaudiusMaximus> > filterM (return [False .. True]) "hello!"
00:27:09 <lambdabot>   ["","!","o","o!","l","l!","lo","lo!","l","l!","lo","lo!","ll","ll!","llo","...
00:27:16 <vixey> ddarius, actually I've read a paper about that but I could not understand what it means
00:28:00 <ddarius> The output of mapM is [1,2,3,4,5,undefined].  The output of filterM is (3:4:undefined).  The output of filterM is a problem for mapM but not for liftM (take 2)
00:28:20 <ddarius> vixey: You don't need to understand it to implement it.
00:28:53 <lepassive> what is wrong in MySqrt x = Just sq
00:28:53 <lepassive> 	where
00:28:53 <lepassive> 		sq = x^2
00:29:02 <vixey> lepassive, did you get any error message?
00:29:15 <mauke> lepassive: M
00:29:15 <enticingjelly> . The pure pattern calculus generalises the pure lambda-cal-
00:29:16 <enticingjelly> culus by basing computation on pattern-matching instead of beta-reduc-
00:29:16 <enticingjelly> tion. The simplicity and power of the calculus derive from allowing any
00:29:17 <enticingjelly> term to be a pattern.
00:29:18 <vixey> lepassive, I like what you are  doing there btw :)
00:29:20 <enticingjelly> seems nice
00:29:46 <lepassive> vixey, LocalVars.hs:3:0: Not in scope: data constructor `MySqrt'
00:29:47 <lepassive> Failed, modules loaded: none.
00:29:49 <rwbarton> vixey: the error message is quite unhelpful
00:29:50 <vixey> lepassive, actually are you using haskell or curry?
00:29:53 <dmwit> That doesn't seem to be a square root.
00:30:01 <dmwit> lepassive: The capitalization is off.
00:30:02 <vixey> dmwit, read it more carefully
00:30:03 <lepassive> vixey, Thanks I'm trying to be better :)
00:30:16 <dmwit> vixey: oy
00:30:19 <vixey> dmwit, (not mechanically like normal haskell)
00:30:36 <lepassive> what do you mean with capitalization is off ?
00:30:43 <dmwit> vixey: I think you're the one what needs to read again.
00:30:59 <vixey> lepassive: this bit: data constructor `MySqrt'
00:31:08 <dmwit> lepassive: Variables must start with a lower-case character.
00:31:10 <vixey> (the bit in the error message)
00:31:35 <lepassive> dmwit, Identifiers you mean ? all vars and functions ?
00:31:43 <sbahra> Yes
00:31:48 <dmwit> lepassive: No, not identifiers.  Yes, all variables and functions.
00:31:55 <sbahra> Yes
00:31:57 <sbahra> ;p
00:32:16 <dmwit> lepassive: Data constructors must start with upper-case letters, when you get around to defining new types.  This is why I said no to the identifiers part.
00:32:31 <lepassive> dmwit, Okay I'll keep it neat
00:32:46 <dmwit> lepassive: Also, functions are variables.  It's one of the great things about Haskell. ;-)
00:32:56 <dmwit> So you don't need to separate them when you talk about them. =)
00:33:16 <lepassive> dmwit, Don't get me confused more than I am :S
00:33:22 <dmwit> =)
00:33:44 <dmwit> ?quote fire.hose
00:33:44 <lambdabot> byorgey says: sometimes asking #haskell for help can be like taking a drink from a fire hose
00:34:16 <sbahra> haha
00:37:43 <CakeProphet> @pl lol x = x+x
00:37:44 <lambdabot> lol = join (+)
00:37:53 <CakeProphet> oh ho
00:38:11 <CakeProphet> I would have suggested (*2) instead
00:40:19 <rwbarton> semarie: ddarius gave a nice coherent explanation but another way to see what's going on is to replace [0,1,2,3,4,undefined] with 0:1:2:3:4:undefined
00:40:39 <vixey> why not 0:1:2:3:4:undefined:undefined
00:40:47 <rwbarton> semarie: Now none of your tests should yield anything besides undefined.  The original filterM was not as lazy as you might have imagined
00:42:47 <Workybob> CakeProphet: that makes assumptions about your Num instance, which I'm not sure are enforced by any rules
00:43:11 <dmwit> Also, x+x is so much faaaster than x*2!
00:43:23 <CakeProphet> map (map (3+)) (repeat [1..])
00:43:33 <CakeProphet> dmwit:  optimization of simple arithmetic is very very important.
00:43:41 <CakeProphet> > map (map (3+)) (repeat [1..])
00:43:42 <lambdabot>   [[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
00:43:59 <mauke> > repeat [4..]
00:44:00 <lambdabot>   [[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
00:44:03 <mauke> OPTIMIZEd
00:44:34 <dmwit> > 14 / 2.54
00:44:35 <lambdabot>   5.511811023622047
00:46:51 <CakeProphet> isn't like, proved to be impossible to construct pi from arithmetic operations on whole numbers?
00:47:16 <vixey> CakePhophet, can I construct 1/2 from whole numbers?
00:47:30 <lepassive> _ -> putStrLn "error: exactly two arguments needed" what is the underscore in that expression ?
00:47:48 <CakeProphet> . It is furthermore a transcendental number, which means that no finite sequence of algebraic operations on integers (powers, roots, sums, etc.) could ever produce it
00:47:51 <CakeProphet> ah... finite
00:48:20 <ddarius> Yes, there are plenty of infinite series that converge to e or pi or gamma.
00:48:55 <mauke> lepassive: a wildcard pattern
00:49:27 <mauke> > 355/113
00:49:29 <lambdabot>   3.1415929203539825
00:50:34 <lepassive> mauke, yes, but It doesn't make sense to me in the context
00:50:51 <mauke> lepassive: what is the context?
00:50:57 <intoverflow> lepassive: dump it into the pastebin
00:51:30 <lepassive> http://hpaste.org/13629
00:51:48 <mauke> ok, what's the problem?
00:52:01 <intoverflow> in the case expression, args is either of the form [input, output] or it isn't.  _ -> putStrLn ... covers the case where it isn't.
00:52:25 <intoverflow> ex: args = [input, output, baz] isn't of the form [input, output]
00:52:52 <lepassive> intoverflow, aah it's a case I was blindid sorry
00:52:58 <intoverflow> no worries :)
00:53:08 <sbahra> > let x = 4 in case x of 3 -> True; _ -> False
00:53:10 <lambdabot>   False
00:54:22 <intoverflow> I don't think I spend nearly enough time contemplating how awesome lambdabot is
00:54:42 <schme> Any time spent on that is too much time.
00:55:26 <CakeProphet> @pl fac 0 = 1; fac n = product [1..n]
00:55:26 <lambdabot> (line 1, column 10):
00:55:26 <lambdabot> unexpected ";"
00:55:26 <lambdabot> expecting digit, variable, "(", operator or end of input
00:55:34 <sbahra> @botsnack
00:55:34 <lunabot>  :)
00:55:34 <lambdabot> :)
00:55:43 <mauke> > product [1 .. 0]
00:55:44 <lambdabot>   1
00:55:54 <CakeProphet> ...oh
00:55:57 <CakeProphet> excellent.
00:56:09 <CakeProphet> well poo, now I already know what @pl will tell me.
00:56:17 <CakeProphet> @pl fac n = product [1..n]
00:56:17 <lambdabot> fac = product . enumFromTo 1
00:56:23 <CakeProphet> :(
00:57:02 <CakeProphet> what's something that pl works on forever (or just a really long time).
00:57:14 <vixey> @pl (\u -> u u) (\u -> u u)
00:57:17 <lambdabot> ap id id (ap id id)
00:57:17 <lambdabot> optimization suspended, use @pl-resume to continue.
00:57:18 <vixey> @pl-resume
00:57:25 <lambdabot> ap id id (ap id id)
00:57:25 <lambdabot> optimization suspended, use @pl-resume to continue.
00:57:32 <Gracenotes> ..
00:57:33 <dmwit> That's not fair, it doesn't even type properly.
00:57:43 <ddarius> dmwit: Types are for the weak
00:58:17 <Gracenotes> type warriors only ever use one type. ever.
00:58:39 <CakeProphet> vixey:  that's the weirdest recursion I've ever seen
00:59:08 <dmwit> CakeProphet: Try evaluating it.
00:59:10 <dmwit> ;-)
00:59:22 <vixey> why is it weird?
00:59:25 <dmwit> CakeProphet: PL people call it "omega" for reasons known only to history.
00:59:28 <CakeProphet> I'm not sure.
00:59:36 <Gracenotes> @pl (\u -> u u)
00:59:37 <lambdabot> join id
00:59:42 <vixey> who would think to call an infinite loop omega.....
01:00:02 <Gracenotes> ..
01:00:05 <mauke> ω ω
01:00:09 <sbahra> Big omega
01:00:12 <sbahra> little omega
01:00:22 <sbahra> lambdabot, I'm sorry, baby
01:00:22 <mauke> Ω.Ω
01:00:33 <Gracenotes> ^.^
01:00:40 <mauke> ツ
01:00:41 <sbahra> Ω(ω)
01:00:48 <lepassive> http://hpaste.org/13630 , what is pre:case of ? what is a pre followed by case ?
01:00:51 <Gracenotes> M(M)
01:00:59 <mauke> lepassive: pre is a variable
01:01:01 <ClaudiusMaximus> is there a way to check if an Fd is valid other than trying something that "might throw an exception"?
01:01:04 <mauke> lepassive: (:) is a list constructor
01:01:08 <mm_freak> > (\u -> u u) (\u -> u u) (1:)
01:01:17 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
01:01:20 <intoverflow> lepassive: the code is building a list, with pre as the first element
01:01:20 <sbahra> :t Ω(ω) . ツ
01:01:23 <lambdabot>    ...
01:01:27 <mauke> haha
01:01:28 <Gracenotes> wha
01:01:29 <lambdabot> lexical error at character '\12484'
01:01:38 <lepassive> and the result of the case is the xs of pre right ?
01:01:50 <CakeProphet> yes.
01:02:04 <vixey> http://en.wikipedia.org/wiki/Normalisation_by_evaluation
01:02:21 <CakeProphet> it's the list that pre is being append to.
01:02:22 <vixey> NbE does not require that the normal forms are η-long.........
01:02:49 * sbahra wonders how people find utf-8 glyphs so quickly
01:03:06 <mauke> @pl (\x _ -> x x) (\x _ -> x x)
01:03:09 <lambdabot> (const . ap id id) (const . ap id id)
01:03:09 <lambdabot> optimization suspended, use @pl-resume to continue.
01:03:10 <sbahra> vixey, what do you press to type η, on your computer?
01:03:13 * ddarius uses SCIM Latex mode (and other languages)
01:03:15 <mauke> @pl-resum
01:03:16 <ddarius> η
01:03:21 <sbahra> haha
01:03:21 <lambdabot> (const . ap id id) (const . ap id id)
01:03:21 <lambdabot> optimization suspended, use @pl-resume to continue.
01:03:42 <Gracenotes> hey now
01:03:44 <sbahra> @pl (\x _ -> x x) (\x _ -> x x)
01:03:47 <mauke> sbahra: <compose> g h
01:03:52 <lambdabot> (const . ap id id) (const . ap id id)
01:03:53 <sbahra> @pl-resume
01:03:58 <lambdabot> optimization suspended, use @pl-resume to continue.
01:04:18 <vixey> this article is bizarre
01:04:33 <mauke> omega kill!
01:04:35 <vixey> I am the only one that thinks this article is so strange?
01:05:26 <sbahra> hm
01:05:45 <dmwit> Nobody knows what you're talking about.
01:06:07 <ski_> NbE is fun
01:06:17 <CakeProphet> hmmm
01:06:17 <vixey>  Correctness
01:06:18 <vixey> 	Please help improve this section by expanding it. Further information might be found on the talk page. (June 2008)
01:06:18 <vixey> [edit] Extensions
01:06:19 <vixey> excellent
01:06:32 <CakeProphet> does each case of a case expression have to return the same type?
01:06:36 <dmwit> Yes.
01:06:43 <intoverflow> yeah
01:07:38 * ski_ would like "fall-through", sortof, for `case' ..
01:07:44 <CakeProphet> what if /all/ the functions that used the case expression were polymorphic.
01:07:57 <ski_> CakeProphet : polymorphic, how ?
01:08:13 <CakeProphet> like say... they all just wanted [a]'s
01:08:19 <vixey> ski_, but you have to know about Scott Domains and topology and stuff that I don't know to understand it :/
01:08:24 <ski_> CakeProphet : you know values (like functions) can be more or less polymorphic (roughly speaking), right ?
01:08:25 <CakeProphet> can case always returned lists... though technically with different types, but they were all [a]
01:08:57 <ski_> vixey : i didn't know any such when reading `Type-directed partial evaluation' a couple of years ago
01:09:00 <CakeProphet> ski_, so in that case they're all the same type of [a]?
01:09:19 <mauke> [exists a. a]
01:09:31 <CakeProphet> lolwhut
01:09:59 <ski_> CakeProphet : i'm not sure what you're asking about .. maybe you could provide claifying example(s) ?
01:10:29 <Gracenotes> > let func x y = case y of { True -> init x; False -> tail x} in func [1,2,3] True   --CakeProphet
01:10:32 <lambdabot>   [1,2]
01:10:37 <CakeProphet> > maximum "loltest"
01:10:39 <lambdabot>   't'
01:10:39 <ddarius> vixey: No you don't.
01:10:45 <sbahra> oh, i found it
01:10:47 <Gracenotes> CakeProphet: the case expression returns something of type [a]
01:10:54 <CakeProphet> ah okay.
01:11:10 <vixey> but they don't have a correctness proof
01:11:35 <vixey> ddarius, is there some simpler way?
01:11:43 <sbahra> ‏sssss‎AA
01:11:51 <ddarius> vixey: Simpler way of what?
01:11:55 <dmwit> sbahra: No swearing!
01:11:59 <sbahra> sorry
01:12:01 <CakeProphet> > maximum (case (True) of {True -> "lol"; False -> [1,2,3]})
01:12:02 <lambdabot>       No instance for (Num Char)
01:12:02 <lambdabot>        arising from the literal `1' at <inte...
01:12:19 <dmwit> Please don't use case when you mean if.
01:12:21 <CakeProphet> I meant like that.
01:12:23 <ski_> CakeProphet : ok, looks like you want what mauke thought
01:12:23 <vixey> ddarius, to show correctness of NbE
01:12:41 <ddarius> vixey: You can probably do it syntactically.
01:12:41 <dmwit> Oh, it was just an example.
01:12:46 <CakeProphet> dmwit:  yeah
01:13:53 <ddarius> [exists a. a] a.k.a. [()]
01:13:57 <CakeProphet> ski_ I don't need it for anything, I was just wondering if it works, since it seems like - if all the functions that took the result of the case expression as input had the type [a] - then the compiler could still grok it.
01:14:10 <CakeProphet> ddarius:  what is exists a.  I've never seen it.
01:14:31 <ddarius> It's a free existential which most Haskell implementations, and in particular GHC, do not support.
01:14:38 <CakeProphet> er.... had the type ([a] -> somethingElse)
01:14:54 <ddarius> It's just like forall only existential quantification instead of universal quantification.
01:15:05 <CakeProphet> ...I don't know what forall does either.
01:15:34 <Saizan_> in this case the required type is more like exists a. [a], not that it changes much
01:15:52 <CakeProphet> I'll do some googling
01:16:10 <Saizan_> ?type []
01:16:12 <lambdabot> forall a. [a]
01:16:32 <Gracenotes> is dat sum set theory!
01:16:39 <ski_> > let foo :: Bool -> (forall x. (Ord x,Show x) => [x] -> o) -> o; foo b k = case b of True -> k "lol"; False -> k [1,2,3] in (foo True (show . maximum),foo False (show . maximum))
01:16:40 <lambdabot>   ("'o'","3")
01:16:56 <ski_> (CakeProphet : that's an approximation of your example, using CPS ..)
01:17:18 <dmwit> ski_: beautiful
01:17:27 <CakeProphet> I don't know what that is either.
01:17:41 <ddarius> Gracenotes: Logic (if I understood your comment)
01:17:57 <Saizan_> @google wikibook existential types
01:18:00 <ski_> (if we had real existentials, we could do `foo :: Bool -> exists x. (Ord x,Show x) *> [x]' instead of using CPS ..)
01:18:04 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
01:18:08 <dmwit> CakeProphet: Basically, instead of applying a polymorphic function to the result of a case, he's applying the polymorphic function inside the case.
01:18:14 <Gracenotes> ddarius: ah, yes. And logic is used in set theory a fair amount :)
01:18:34 <CakeProphet> dmwit:  ...well I know that would work.
01:19:00 <CakeProphet> what does CPS mean though?
01:19:11 <ski_> Continuation-Passing Style
01:19:11 <ddarius> continuation passing style
01:19:13 <dmwit> CakeProphet: CPS (continuation-passing style) just means that you pass in a "continuation" -- the function that you would otherwise be applying.
01:19:38 <dmwit> It's the rest of the computation.
01:19:40 <cjs> Well, and also that, rather that returning from a function, you call the continuation instead.
01:19:46 <gio123> ski_: hi
01:20:10 <vixey> do u know regex
01:20:49 <Gracenotes> how are regex related?
01:22:19 <CakeProphet> so saying "exists a" is like saying that there's /some/ type here where this type applies?
01:22:38 <CakeProphet> but not necessarily /ever/y type.
01:22:42 <CakeProphet> ...
01:22:48 <dmwit> exactly
01:22:49 * CakeProphet is tired and can't sleep.
01:23:09 <dmwit> It's a lot more useful when paired with a bit more information.
01:23:15 <CakeProphet> and is it computationally impossible to do that, or is it just hard to implement?
01:23:19 <dmwit> Like exists a. Num a => a or so.
01:24:05 <dmwit> Well, type-inference dies in the face of existentials and foralls, I think.
01:24:16 <lepassive> digitToInt ? isn't it a charToInt ?
01:24:32 <Gracenotes> > digitToInt '3'
01:24:34 <lambdabot>   3
01:24:57 <dmwit> lepassive: No, it only works on digits.
01:25:06 <dmwit> > digitToInt 'Z'
01:25:07 <lambdabot>   * Exception: Char.digitToInt: not a digit 'Z'
01:25:20 <ski_> (dmwit : nitpick, s/=>/*>/)
01:25:22 <ddarius> > digitToInt 'a'
01:25:23 <lambdabot>   10
01:25:29 <ski_> (or however you want to spell it)
01:25:34 <Gracenotes> @src digitToInt
01:25:34 <lambdabot> Source not found. You untyped fool!
01:25:40 <Gracenotes> :O
01:25:45 <ski_> @index digitToInt
01:25:45 <lambdabot> Data.Char
01:25:50 <dmwit> ski_: Okay.  I was talking beyond my knowledge, anyway. =P
01:25:52 <ski_> @src Data.Char.digitToInt
01:25:53 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:26:03 <dmwit> ?source Data.Char
01:26:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
01:26:27 <ski_> @vixen no, i haven't considered trying to match wits with a rutabaga (whatever that happens to be) ?
01:26:27 <lambdabot> cool, me too
01:26:44 <dmwit> A rutabaga is a vegetable, I think.
01:27:06 <Gracenotes> it lives underground, I think
01:27:06 <mauke> Kohlrübe
01:27:10 <Saizan_> ski_: why *>? i.e. why use a different arrow for typeclass context there?
01:27:16 <Gracenotes> and it dies in digestive systems
01:28:27 <ski_> Saizan_ : in a dictionary translation, `exists a. Num a => a' would translate to a function from a dictionary of type `Num a', to a value of type `a', for some type `a'
01:29:01 <ski_> Saizan_ : whereas `exists a. Num a *> a' would translate to a pair of a dictionary of type `Num a' and a value of type `a', for some type `a'
01:29:26 <ski_> there is an apreciable difference
01:29:29 <Saizan_> ah, right, i see
01:29:46 <dmwit> ah
01:30:20 <ski_> (i've invented the symbol `*>' to have some way to talk about this, if someone has a better suggestion for concrete syntax, i'm all ears)
01:30:45 <Gracenotes> > let foo f = (f 'c', f True) in foo id
01:30:46 <lambdabot>   Couldn't match expected type `Bool' against inferred type `Char'
01:30:57 * vixey wonders  a *> b  or  a -> b --->
01:31:00 <Gracenotes> hrm
01:31:52 <Saizan_> nice parallel with how \Sigma is a pair while \Pi is a function, very roughly
01:31:57 <vixey> oh it's something different all together
01:32:02 <dmwit> Gracenotes: You need rank-two types for that, probably.
01:32:10 <dmwit> or...
01:32:42 <Gracenotes> "For some fixed value k, rank-k polymorphism is a system in which a quantifier may not appear to the left of more than k arrows (when the type is drawn as a tree)."
01:32:43 <dmwit> > let foo :: (a -> a) -> (Char, Bool); foo f = (f 'c', f True) in foo id
01:32:44 <lambdabot>   Couldn't match expected type `Char' against inferred type `Bool'
01:32:51 <dmwit> yeah
01:33:01 <Gracenotes> ooookay
01:33:03 <dmwit> > let foo :: (forall a. a -> a) -> (Char, Bool); foo f = (f 'c', f True) in foo id
01:33:04 <lambdabot>   ('c',True)
01:33:25 <Gracenotes> dmwit: and one needs to "(Use -XTypeOperators to allow operators in types)"
01:33:26 <dmwit> Gracenotes: The problem with yours is that the 'a' type variable is fixed by its use within the function.
01:33:43 <ski_> (Saizan_ : right)
01:34:26 <Gracenotes> > let f = id in (f 'c', f True)
01:34:28 <lambdabot>   ('c',True)
01:34:34 <Gracenotes> hm, yeah
01:34:35 <ski_> Gracenotes : no type operators used here ..
01:34:37 <dmwit> foo f = (f 'c' {- this fixes "a = Char" -}, f True {- this dies, because "True :: Char" is false -})
01:35:11 <Gracenotes> > let foo :: Ord a => (a -> a) -> (Char, Bool); foo f = (f 'c', f True) in foo id
01:35:13 <lambdabot>   Couldn't match expected type `Char' against inferred type `Bool'
01:35:53 <jberryma1> Can anyone shed some light on why these two different functions for averaging a list of floats perform the way the do? The details are here: http://hpaste.org/13631
01:35:54 <ski_> Gracenotes : i only used `Ord' in a previous example since you used `maximum' ..
01:36:14 <Gracenotes> I think that was CakeProphet. but, yes, I was looking along :)
01:36:31 <dmwit> jberryma1: It's almost certainly the fault of laziness.
01:37:06 <CakeProphet> > mean
01:37:07 <lambdabot>   Not in scope: `mean'
01:37:15 <dmwit> jberryma1: Try using foldl' instead of foldr.  It will generate many fewer thunks.
01:37:38 <dmwit> > foldr (+) 0 [x,y,z]
01:37:39 <lambdabot>   x + (y + (z + 0))
01:37:48 <dmwit> jberryma1: Each of those parens is a thunk. ;-)
01:37:58 <CakeProphet> @pl mean ls = (sum ls / length ls)
01:37:58 <lambdabot> mean = liftM2 (/) sum length
01:38:10 <dmwit> CakeProphet: type error
01:38:25 <CakeProphet> ...why
01:38:33 <dmwit> liftM2 (/) sum genericLength
01:38:41 <Gracenotes> eh
01:38:47 <CakeProphet> :t genericLength
01:38:48 <lambdabot> forall b i. (Num i) => [b] -> i
01:38:52 <dmwit> CakeProphet: You can't use (/) on Int, which is length's return type.
01:38:57 <CakeProphet> :t length
01:38:59 <lambdabot> forall a. [a] -> Int
01:39:04 <CakeProphet> oh.
01:39:17 <Gracenotes> :t genericTake
01:39:18 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
01:39:25 <CakeProphet> @pl mean ls = (sum ls / genericLength ls)
01:39:25 <lambdabot> mean = liftM2 (/) sum genericLength
01:39:26 <Gracenotes> :t take
01:39:27 <lambdabot> forall a. Int -> [a] -> [a]
01:39:52 <CakeProphet> so basically I should use class constraints with Num instead of declaring inputs/outputs as ints?
01:40:06 <ski_> (.. how does a haskeller in deep thought sound ?)
01:40:29 <dmwit> CakeProphet: Well, Int is fine, as long as you know the thing you're returning won't take more than 29 bits to represent. =)
01:40:30 <jberryma1> dmwit: I wish I saved the test I did with strict fold, but I recall it being no better when profiled
01:40:39 <dmwit> CakeProphet: That's what we have fromIntegral for.
01:40:40 <Gracenotes> ski_: I'm not sure, but it would make a good koan
01:40:56 <ski_> Gracenotes : *thunk* *thunk* *thunk*
01:41:00 <dmwit> jberryma1: The other thing is that you're probably destructing and building tuples in a bad way.
01:41:09 <ski_> (now you should groan)
01:41:11 <Gracenotes> ...okay, maybe not ;)
01:41:22 <dmwit> jberryma1: You might want to try with a lazy tuple match: (\a ~(a', cnt) -> ...) or whatever.
01:41:42 <CakeProphet> dmwit:  but division doesn't want ints.
01:42:05 <CakeProphet> :t (/)
01:42:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
01:42:09 <dmwit> ?remember ski <ski> How does a Haskeller in deep thought sound? <ski> *thunk* *thunk* *thunk*
01:42:09 <lambdabot> Okay.
01:42:16 <dmwit> CakeProphet: As I said, that's what we have fromIntegral for.
01:42:26 <vixey> @quoet
01:42:26 <lambdabot> Maybe you meant: quit quote
01:42:48 <CakeProphet> :t fromIntegral
01:42:48 <dmwit> ?quote
01:42:48 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
01:42:49 <lambdabot> forall a b. (Num b, Integral a) => a -> b
01:43:09 <int-e> sadly, really deep thoughts will cause a stack overflow
01:43:22 <dmwit> heh
01:43:35 <ski_> (dmwit : you forgot some parens)
01:43:53 <dmwit> I didn't forget.
01:45:55 <jberryma1> thanks btw, I learn so much asking questions like these here.
01:46:02 <osfameron> what's so amazing about really deep thoughts? ;-)
01:46:36 <elbar> 42
01:46:37 <Gracenotes> they eat your computer's RAM?
01:47:58 <dmwit> I like that the answer to "How does a Haskeller think" is "*I'll think about that later* *I'll think about that later* *I'll think about that later*".
01:48:14 <dmwit> I'm good at procrastination... no wonder I love this language!
01:49:46 <vixey> how do you state equiv. of syntax with the semantics? (in NbE)
01:52:38 <stulli_> Are the code snippets from RWH somewhere available for download?
01:55:09 <andreas_> Hi, I'm having a problem building lhs2Tex on ghc 6.10.1. It apparently uses the old exceptions module, so I've changed the import statement from Control.Exception to Control.OldException. But now I get an error  "Cound not find module `Control.OldException`: it is a member of package base, which is hidden". Does anyone know why this happens and how to fix it?
01:55:55 <Gracenotes> hm, it seems forall a. (a -> a) -> (Char, Bool) is of rank-1. who'd've thunk
01:56:22 <ddarius> Gracenotes: Everyone one who knows the definition of "rank-1 type"
01:56:31 <vixey> lol
01:56:32 <kosmikus> andreas_: just build it with base-3
01:56:32 <andreas_> I saw a conversation in which someone mentioned that the issue can be resolved by adding the package to the build-depends in the cabal file, but build-depends already mentions package base in my cabal file.
01:56:53 <andreas_> OK, I'll try that
01:59:19 <andreas_> so i can just put "base<=3" in my build-depends list, right?
02:00:06 <kosmikus> yes
02:00:14 <kosmikus> er, base <4
02:01:12 <jberryma1> I guess I'm not sure how to profile these well, but here are 5 variations based on dmwit's suggestions: http://hpaste.org/13632
02:01:40 <jberryma1> I need to give it more data but get stack overflow, I think
02:02:06 <dmwit> Ah!
02:02:10 <dmwit> That's a good clue.
02:02:28 <dmwit> It was laziness, but not where I was thinking.
02:03:09 <dmwit> let x = a+a'; y = cnt+1 in x `seq` y `seq` (x, y)
02:03:55 <dmwit> foldl' is strict in the *constructor* -- i.e. the fact that it is a tuple -- but not in the elements of the tuple. =)
02:04:09 <dmwit> I always forget that.
02:04:39 <jberryma1> oooohhhh, I was wondering why I got that before when I tried foldl'
02:04:51 <jberryma1> so it is building up the + thunks in
02:04:56 * dmwit nods
02:05:12 <dmwit> It's odd that "sum" doesn't suffer the same fate.
02:05:13 <dmwit> ?src sum
02:05:13 <lambdabot> sum = foldl (+) 0
02:05:25 <dmwit> Maybe GHC's sum is better than the specification in that sense.
02:05:29 <andreas_> kosmikus: thanks! that worked perfectly.
02:06:03 <Gracenotes> > sum [1..10^7]
02:06:18 <lambdabot>   thread killed
02:06:20 <kosmikus> andreas_: great.
02:06:41 <Gracenotes> > sum [1..10^6]
02:06:46 <lambdabot>   * Exception: stack overflow
02:06:52 <Gracenotes> > sum [1..10^5]
02:06:52 <jberryma1> dmwit: sum does too in my tests
02:06:53 <lambdabot>   5000050000
02:06:56 <dmwit> > maximum [False..True] -- most confusing parse error, the first time you see it
02:06:57 <lambdabot>       Failed to load interface for `False':
02:06:57 <lambdabot>        Use -v to see a list of th...
02:07:04 <dmwit> jberryma1: oh, good
02:07:09 <SubStack> > let x = 10^7 in x * (x - 1) / 2
02:07:10 <lambdabot>   4.9999995e13
02:07:22 <ddarius> dmwit: GHC uses a definition of sum semantically equivalent to that one and relies on strictness analysis to avoid stack overflow.
02:07:31 <Gracenotes> > let x = 10^7 in x * (x - 1) `div` 2
02:07:32 <lambdabot>   49999995000000
02:07:32 <ddarius> dmwit: This is why sum will stack overflow in GHCi.
02:08:04 <Gracenotes> isn't the actual formula (x + 1)?
02:08:05 <dmwit> SubStack, Gracenotes: Isn't it x * (x+1) `div` 2?
02:08:14 <Gracenotes> yeah
02:08:20 <Badger> err
02:08:25 <jberryma1> I never have understood why maximum is defined to be lazy the way it is
02:08:30 <Badger> :t div
02:08:32 <lambdabot> forall a. (Integral a) => a -> a -> a
02:08:35 <Badger> :t /
02:08:36 <lambdabot> parse error on input `/'
02:08:36 <Badger> oops
02:08:38 <dmwit> jberryma1: I don't think foldl' existed back then.
02:08:39 <Badger> :t (/)
02:08:40 <lambdabot> forall a. (Fractional a) => a -> a -> a
02:08:43 <dmwit> jberryma1: seq, either
02:08:51 <Badger> @src div
02:08:52 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:08:54 <Badger> @src (/)
02:08:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:08:59 <Badger> oh, wait
02:09:02 <ddarius> dmwit: seq certainly existed when they made the Haskell 98 Library Report.
02:09:06 <Badger> blah.
02:09:18 <dmwit> ?src Int div
02:09:18 <lambdabot> Source not found.
02:09:25 <dmwit> What, no sass?
02:09:25 <Badger> why do they give different answers, anyway? :P
02:09:39 <dmwit> Badger: Just look at their types.
02:09:45 <Badger> oh woops
02:09:49 <Badger> way to not look closely
02:09:52 * Badger whacks binrapt 
02:09:56 <Badger> er
02:09:58 <Badger> which is to say
02:10:01 <binrapt> :[
02:10:01 <dmwit> Good tab-completion.
02:10:02 * Badger whacks Badger 
02:10:06 * Badger hugs binrapt 
02:10:09 <dmwit> ?slap Badger
02:10:09 <lambdabot> go slap Badger yourself
02:10:12 <Badger> dmwit: thankyou.
02:10:23 <Gracenotes> tough love, eh?
02:13:45 * jberryma1 still doesn't understand how seq works
02:14:27 <chrisdone> have you read SICP?
02:15:22 <jberryma1> no, but keep hearing about it
02:15:30 <chrisdone> how is sqe formed?
02:15:36 <chrisdone> how thunks get valuanted?
02:15:57 <chrisdone> we need to do way instain effects
02:16:46 <wjt> WHO KILL THEIR STRICTNESS
02:19:05 <Gracenotes> speaking of which, I downloaded the first few SICP video lectures... but have yet to start watching
02:19:14 <Badger> :o
02:19:18 <Badger> sicp has video?
02:19:52 <Gracenotes> http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/ from the earlier version of the book, but shouldn't too inconsistent, I think
02:20:35 <Gracenotes> there are also good video lectures for 6.046j
02:24:02 <Gracenotes> er, i.e. introduction to algorithms
02:30:02 <sbahra> Gracenotes, cool
02:36:12 <vixey> what does this mean "Since sets form a CCC with a boolean object, the set theoretic semantics validates all beta-eta-equalities"?
02:36:28 <vixey> I don't understand "validates"..
02:37:49 <not_much> vixey: where is that sentence from?
02:40:31 <vixey> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.5031
02:42:40 <ddarius> vixey: beta-eta-equivalent terms map to equal sets
02:43:21 <vixey> why is it that being a CCC means turns beta-eta into equivalence classes?
02:44:17 <hugo___> hi
02:45:07 <ddarius> The counit and unit of the adjunction that characterizes a Cartesian closed category are exactly the beta and eta rule.
02:45:19 <ddarius> Particularly, beta contraction and eta expansion.
02:47:20 <ddarius> Rather the triangle equalities of the unit and counit.
02:49:26 <vixey> I see
02:54:05 <tjb> was wondering if anyone knows a good way to print a Data.Word128 in hex?
02:55:15 <quicksilver> > showHex (123546 :: Word128) ""
02:55:16 <lambdabot>       Not in scope: type constructor or class `Word128'
02:55:21 <quicksilver> > showHex (123546 :: Word64) ""
02:55:23 <lambdabot>   "1e29a"
02:55:32 <quicksilver> tjb: that shoulud work for Word128, too, it's just not in scope in LB.
02:55:56 <tjb> quicksilver: excellent, thanks (again) -- I'll give it a shot
02:58:31 <tjb>  Data/LargeWord.hs:133:0: No instance nor default method for class operation GHC.Real.quotRem
02:58:58 <tjb> quicksilver: must be an issue that Word128 is Data.LargeWord.Word128
02:59:07 <quicksilver> sounds like a bug in LargeWord.
02:59:16 <quicksilver> workaround should be 'toInteger'
02:59:27 <quicksilver> > showHex (toInteger myword128) ""
02:59:28 <lambdabot>   Not in scope: `myword128'
02:59:55 <tjb> quicksilver: ok, one min
03:04:04 <tjb> quicksilver: great, toInteger workaround gets the job done :)
03:06:04 <quicksilver> good :)
03:06:43 <KSTD> aa
03:08:18 <__Ali__> is there a SWIG module for haskell yet?
03:10:47 <__Ali__> what's the best way of wrapping c++ libs automatically into haskell?
03:11:01 <intoverflow> http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
03:11:01 <Axman6> c2hs?
03:11:12 <Axman6> or hsc2hs...
03:12:06 <__Ali__> thnx
03:12:33 <__Ali__> but this is c, not c++
03:12:35 <Axman6> __Ali__: also look at the docs for the FFI
03:13:10 <Axman6> __Ali__: you'll probably have to make a pure interface to whatever you're doing
03:13:40 <intoverflow> yeah, the ffi is the place to be; depending on the library, and what you need to get out of it, ffi bindings can be done up pretty quickly if you don't mind the taint of IO
03:14:08 <__Ali__> Axman6: i'm new to haskell, do we need a full 'wrapper', as we need in java and python to interface with c/c++, or haskell can call existing libs directly?
03:14:10 <intoverflow> but like Axman6 suggests, a quality binding will require some pure interface
03:15:05 <intoverflow> the FFI provides a way to call existing C code directly, kinda by translating the C type signature into a Haskell type signature
03:15:05 <Axman6> __Ali__: just look at what the FFI does, ok?
03:15:08 <intoverflow> heh
03:15:25 <__Ali__> ok ok
03:15:37 <intoverflow> it also provides some types that you can convert in and out of that mesh correctly with C
03:16:05 <mercury^> He hardly said anything, and you grow annoyed already, Axman6 :)
03:16:18 <Axman6> who said i was annoyed?
03:16:19 <intoverflow> for what it's worth, I had bluetooth bindings for macosx working in less than a day using ffi, so it's not *that* bad
03:16:23 <Axman6> __Ali__: check out http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html
03:16:32 <Axman6> intoverflow: nice :)
03:16:54 <__Ali__> thnx a lot
03:17:04 <scook0> basic FFI stuff is pretty easy
03:17:29 <intoverflow> I mean, it helps quite a bit that haskell compiles down to C, unlike python and java
03:17:43 <quicksilver> (actualy it doesn't)
03:17:51 <quicksilver> (but the FFI specifies it should understand the C ABI)
03:17:56 <Axman6> "You can't defend the indefensible -- Scheme is a terrible choice.  The most " hahaha, epic trolling
03:17:59 <__Ali__> this is all great, how come haskell is so unknown, everyone knows python java ruby, it's wiered such nice language is not widely used
03:18:00 <Axman6> important thing about a extension/scripting language is that it be
03:18:02 <Axman6> -simple-.  It must have a simple easy-to-understand semantics, it must have
03:18:05 <Axman6> simple easy-to-use data structures, and it must have simple easy-to-read
03:18:08 <Axman6> syntax.  Scheme has none of these, while Tcl and Perl have them all.
03:18:12 <Axman6> ah damn, didn't realise that was a multiline thing, sorry folks >_<
03:18:24 <scook0> wrapping a whole library in an idiomatic way is always going to be a bit of work
03:18:32 <dolio> jhc compiles down to C.
03:18:34 <Axman6> __Ali__: we don't want the wrong kind of people using it
03:18:41 <intoverflow> hahahaha
03:18:46 <intoverflow> yeah, avoid popularity at all costs
03:18:52 <dolio> Technically you can make ghc produce C, too.
03:19:01 <dolio> Although that's no longer the default.
03:21:43 <EvilTerran> Axman6, Tcl has easy-to-read syntax, easy-to-use data structures, and easy-to-follow symantics? roflcopters
03:21:45 <Axman6> http://groups.google.com/group/comp.lang.scheme/browse_thread/thread/06f0588e1e4c999d/89120d79e5650d94?#89120d79e5650d94
03:21:57 <Axman6> like i said, epic troll :P
03:22:19 <intoverflow> "Even graduate students at MIT are confused by that stuff."
03:22:48 <intoverflow> "In Scheme you have to write `(+ x (* 2 y))'.  Only an idiot would prefer to write that."
03:22:53 <intoverflow> *bwahaha*
03:23:19 <vixey> I don't get it
03:23:32 <Axman6> http://code.google.com/p/demo-lisp/ cool
03:23:39 * Axman6 takes over from redditbot 
03:23:46 <vixey> I don't think any students at MIT are confused by this stuff, they don't teach it at MIT
03:23:58 <Gracenotes> intoverflow: it might be more clear than 'y 2 * x +' ;)
03:24:16 <intoverflow> this definitely gets epic troll
03:24:25 <Axman6> i only just learnt how RPN works, thanks RWH :)
03:24:42 <Gracenotes> learn you a haskell recently added a section on RPN
03:24:57 <vixey> what's cool about yet another crap almost-scheme written in C :/
03:25:14 * EvilTerran has written himself an "RPN monad" for his own amusement
03:25:32 <Gracenotes> o-o
03:25:36 <EvilTerran> "runRPN $ do push 1; push 2; binop (+); ..."
03:25:44 <RayNbow> vixey: crap needs to be produced to keep the world balanced... ;)
03:25:48 <quicksilver> EvilTerran: weaksauce!
03:25:55 <EvilTerran> weaksauce?
03:26:00 <quicksilver> EvilTerran: you should provide a Num instance so you don't have to write push.
03:26:05 <EvilTerran> true
03:26:16 <Gracenotes> how would that work?
03:26:40 <quicksilver> instance Num a => Num (RPN a) where fromIntegral n = push n
03:26:50 <ddarius> @google embedding postfix languages okasaki
03:26:58 <Gracenotes> quicksilver: the usage, I mean
03:27:05 <lambdabot> http://portal.acm.org/citation.cfm?id=581699
03:27:05 <lambdabot> Title: Techniques for embedding postfix languages in Haskell
03:27:07 <EvilTerran> i forget if i worked out how to do a heterogenous stack type-safe-ly; i don't think it'd be a monad any more
03:27:16 <vixey> I think I pasted a GADT version of this that is hetro/type safe the other day
03:27:21 <vixey> it was not a monad
03:27:22 <Gracenotes> quicksilver: 1 >> 2 >> binop (+)?
03:27:37 <ddarius> Gracenotes: Or do 1; 2; binop(+)
03:27:53 <Gracenotes> heh. so numbers are like functions (almost)
03:28:11 <mercury^> Numbers are monadic values in that case.
03:28:14 <EvilTerran> Gracenotes, or do { 1; 2; 3; binop (*); binop (+) } for 1+(2*3)
03:28:27 <EvilTerran> it may not be useful, but it is vaguely interesting, imo :)
03:28:29 <Axman6> Gracenotes: see RWH chapter
03:28:32 <Axman6> um... sec
03:28:45 <Axman6> 13
03:38:03 <Axman6> oh woah, just found out what this SICP thing is, and realised i watched a few of the lectures a few years ago. got really bored -_-
03:38:25 <intoverflow> heh
03:38:30 <intoverflow> yeah, they're just classroom lectures
03:39:58 <Gracenotes> Axman6: the hairstyles of the students are fun
03:40:13 <Axman6> heh
03:41:30 <Axman6> "crypt_3rot13.c this is a password encryption library for Solaris 9, that allows the system to use the 3ROT13 (Triple-ROT13) algorithm for /etc/shadow passwords." lol
03:41:54 <Gracenotes> the source includes an important legal warning, as well
03:42:10 <Axman6> http://www.brendangregg.com/specials.html#pam_happy_hour
03:42:46 <Gracenotes> Axman6: WARNING: Check encryption legislation in your country before use.
03:42:55 <Axman6> hahaha
03:43:06 <Gracenotes> SEE ALSO: An RFC has been written for 3ROT13, which has yet to be numbered.
03:45:57 <Gracenotes> hm, watching the SICP videos, it seems most of the first lecture is "look, computers can do arithmetic"
03:46:04 <Axman6> "rshutdown rough shutdown, shutdown in roughly 5 minutes or so. This program uses the same countdown timer as many major railway networks throughout the world, including Sydney's CityRail." heh, so true. sydney's trains suck
03:46:26 <Axman6> Gracenotes: i thought it was more "look, LISP can do ANYTHING!!!!"
03:46:37 <Gracenotes> heh
03:47:15 <Gracenotes> thankfully I can time-travel just by using the wheel on my mouse
03:48:08 <Gracenotes> "Believe it or not, you now know enough LISP to write almost any numerical procedure"
03:48:39 <Gracenotes> "that you'd write in a language like FORTRAN or BASIC"
03:49:12 <Gracenotes> "that's probably not believable, because you know those languages have things like for statements and do-until-while, or something"
03:49:17 <Gracenotes> quite fun :)
03:57:27 <Axman6> "It's fun typing make -j32" damn it Ben.
03:57:51 <Axman6> hopefully he'll be one of my lecturers this semester though
03:59:40 <Gracenotes> which school?
03:59:52 <ivanm> Axman6: UNSW?
03:59:58 <Axman6> ANU
04:00:16 <Axman6> http://ghcsparc.blogspot.com/2008/12/alright.html
04:01:20 <Gracenotes> a blog about a programming language on an operating system, quite cool
04:01:50 <Axman6> Gracenotes: Ben got given an OpenSPARC T2 to do research on haskell on the T2
04:02:09 <Axman6> plus they gave both ANU and UNSW a T2 to play with.
04:03:26 <Gracenotes> back in the 80's people wore nice shirts without logos :<
04:03:48 <Gracenotes> too many stripes though
04:03:54 <yitz> Gracenotes: no, they had an alligator on them
04:04:24 <Gracenotes> oh. I suppose I was born too late to understand what you just said.
04:04:55 <yitz> Gracenotes: it's the logo of a shirt company that was considered "in".
04:05:59 <Gracenotes> ah, there we are, http://en.wikipedia.org/wiki/Lacoste
04:06:04 <quicksilver> "5 dollar shirt, 20 dollar crocodile"
04:06:10 <yitz> Gracenotes: right, lacoste, that's it
04:06:31 <quicksilver> one of the most memorable quotes from Jaws :)
04:07:04 <yitz> Gracenotes: even in the middle ages the shirts had logos. they were called "coat of arms".
04:07:14 <Gracenotes> :)
04:07:39 <Gracenotes> I doubt you could say medieval families profited from having their Coat of Arms displayed
04:07:56 <czShadoW> „Lacoste store in Vaňkovka, Brno“ -- hm, it's in my city.
04:08:07 <yitz> czShadoW: heh
04:12:30 <ski_> (vixey : you posted a GADT version of what ?)
04:12:43 <vixey> RPN evaluator
04:13:54 <ski_> might i have a look at it ?
04:13:57 <vixey> PUSH :: o -> STACK a -> STACK (o,a)
04:14:10 <vixey> ADD :: STACK (Int, (Int, a)) -> STACK (Int, a)
04:14:13 <vixey> that kind of thing
04:14:18 <ski_> i see
04:14:19 <vixey> with eval :: STACK a -> a
04:14:23 <ski_> *nod*
04:14:54 <vixey> data RPN t where
04:14:55 <vixey>  END :: RPN ()
04:14:55 <vixey>  NUM :: Integer -> RPN z -> RPN (Integer, z)
04:14:55 <vixey>  BIN :: (a -> b -> c) -> RPN (a, (b, z)) -> RPN (c, z)
04:15:07 <vixey> eval :: RPN t -> t
04:15:07 <vixey> eval END = ()
04:15:07 <vixey> eval (NUM i tl) = (i, eval tl)
04:15:07 <vixey> eval (BIN (*) tl) = case eval tl of (u, (v, tl)) -> (u*v, tl)
04:15:36 <mreh> this book has really embiggened my appreciation of Haskell
04:15:56 <ski_> (mreh : RWH ?)
04:16:03 <mreh> go to p86
04:16:05 <vixey> ski_, it's a kind of simple example of this general idea of describing recursion in the type of a GADT
04:16:14 <chessguy_work> @pl \(x,y) -> f y
04:16:15 <lambdabot> f . snd
04:16:16 <vixey> the other axis I know about is:  data VAR i where NOTHING :: VAR (); AND :: VAR (VAR i -> i)
04:16:28 <vixey> oh :: VAR i -> i; oh NOTHING = () ; oh AND = oh
04:16:37 <vixey> with this you have  oh AND AND AND Nothing :: ()
04:16:39 <mreh> p86 of RWH, they use the word cromulent as if it were a real word that wasn't made up on the simpsons
04:16:59 <vixey> you can mix polymorphism and variadics though :P
04:17:03 <chessguy_work> @type fromList $ map (fromList . snd) ?c
04:17:06 <lambdabot> Not in scope: `fromList'
04:17:06 <lambdabot> Not in scope: `fromList'
04:17:23 <vixey> stuff like  build (X 3) (X "foo") (X True) End ~~> (3, ("foo", (True, ())))
04:17:24 <chessguy_work> @type Data.Map.fromList $ map (Data.Map.fromList . snd) ?c
04:17:25 <lambdabot>     Couldn't match expected type `(k, a)'
04:17:25 <lambdabot>            against inferred type `M.Map k1 a1'
04:17:25 <lambdabot>       Expected type: (a2, [(k1, a1)]) -> (k, a)
04:18:30 <vixey> ski_, also related, http://hpaste.org/13620
04:18:53 <fasta> Gracenotes: Implementations of arithmetic can be interesting and can certainly be non-trivial.
04:20:09 <Olathe> Cromulent has become a perfectly cromulent word.
04:20:30 <ski_> vixey : that reminds me of <http://www.cs.chalmers.se/Cs/Research/Functional/Meeting/2000/index.html#John-Oct-26>
04:20:42 <Gracenotes> fasta: yes... I've always wondered about the way calculators or software switch around the bits to do it quickly
04:21:08 <vixey> ski_, aww! I didn't invent it then
04:21:13 <ski_> (mreh : what's the difference ?)
04:21:14 <Gracenotes> however the lecture doesn't talk about that, merely using + and * and so on as "primitives"
04:21:43 <ski_> vixey : i'm not sure your is the same
04:22:05 <ski_> (vixey : also even if it is, you still invented it, no ?)
04:22:59 <__Ali__> i'm really confused, does cpphs really compile any c++ lib into haskell? we dont need any wrapping at all?!
04:23:25 <ski_> vixey : that `oh' looks fun
04:23:59 <Lemmih> __Ali__: cpphs is the C preprocessor modified for Haskell use.
04:24:02 <Olathe> __Ali__: It's only a preprocessor.
04:24:10 <ski_> @vixen oh, and and and, nothing.
04:24:11 <lambdabot> yeah
04:24:19 * ski_ nods sagely
04:24:22 <vixey> lol
04:24:35 <Olathe> __Ali__: It makes the job of using C++ easier, but it doesn't turn it to Haskell.
04:25:00 <Gracenotes> @unpl x x x
04:25:00 <lambdabot> x x x
04:25:10 <Gracenotes> eh.
04:25:18 <vixey> @unpl join id
04:25:18 <lambdabot> ((\ a -> a) >>= \ b -> b)
04:25:31 <vixey> @pl ((\ a -> a) >>= \ b -> b)
04:25:32 <lambdabot> join id
04:26:00 <polveroj> is there a hackage version of Morten Rhiger's first-class patterns yet?
04:26:03 <vixey> ski_, but the neat thing is that each 'AND' can hold more data, and the GADT parameter can compute new types from it
04:26:21 <__Ali__> Olathe: so, there isn't any automated way of binding c++ classes to haskell? why there is no swig module for haskell?
04:26:43 <vixey> ski_: so an application I made is a new notation for monads:  KEEP name! DROP ws! KEEP parameters! DROP (wstring ":")! KEEP term! DROP finish! STORE==> (,,)
04:26:47 <Olathe> __Ali__: I'm not sure, but from reading RWH, it looks like it's eased but not taken care of.
04:27:02 <chessguy_work> polveroj, no
04:27:09 <Olathe> __Ali__: You still have to tell it what the argument types are and so on.
04:28:25 <__Ali__> Olathe: I was hoping the use of c++ compiler in haskell can take care of the arg types
04:29:13 <Axman6> @pl \q w e r t y -> y e r w t q
04:29:14 <lambdabot> flip (flip . ((flip . ((flip . (flip .) . flip) .)) .) . flip (flip . (flip .) . flip . flip id))
04:29:21 <Axman6> @unpl flip (flip . ((flip . ((flip . (flip .) . flip) .)) .) . flip (flip . (flip .) . flip . flip  id))
04:29:21 <lambdabot> (\ b c f i l o -> o f i c l b)
04:29:44 <Olathe> @@ @unpl @pl \q w e r t y -> y e r w t q
04:29:45 <lambdabot>  (\ b c f i l o -> o f i c l b)
04:30:10 <Axman6> @pl \q w e r t y -> y e (r w t) q
04:30:11 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip ((.) . (.) . flip . flip id) . flip id)
04:30:24 <Axman6> @pl \q w e r t y -> y e (r (w t) q)
04:30:24 <lambdabot> (flip ((.) . (.) . flip . flip id) .) . flip (flip . (flip .) . flip (.))
04:30:29 <chessguy_work> polveroj, there have been several implemntations posted to -cafe though
04:30:36 <Axman6> dang, those are supposed to get longer!
04:30:53 <Olathe> @@ @unpl @pl \f g a -> (g f, f a)
04:30:53 <lambdabot>  (\ n -> ((\ g w e f -> ((,)) (g w) (e f)) >>= \ a b c -> a c b) (\ j -> j n))
04:31:00 <chessguy_work> polveroj, search for "pattern combinators"
04:31:30 <Olathe> Figure that one out.
04:32:03 <Gracenotes> observation II: people had too many mustaches in the 80's
04:32:04 <Olathe> I like the ((,)) in particular.
04:32:07 <vixey> :t (\ n -> ((\ g w e f -> ((,)) (g w) (e f)) >>= \ a b c -> a c b) (\ j -> j n))
04:32:08 <lambdabot> forall t b. t -> (t -> b) -> (t -> b) -> (b, b)
04:32:27 <vixey> :t \f g a -> (g f, f a)
04:32:28 <lambdabot> forall t t1 t2. (t -> t2) -> ((t -> t2) -> t1) -> t -> (t1, t2)
04:32:37 <vixey> they've got different types why is that
04:32:42 <vixey> @pl \f g a -> (g f, f a)
04:32:42 <lambdabot> flip =<< (((.) . (,)) .) . flip id
04:32:46 <vixey> :t flip =<< (((.) . (,)) .) . flip id
04:32:47 <lambdabot> forall b a c. (a -> b) -> ((a -> b) -> c) -> a -> (c, b)
04:32:52 <Olathe> Well, one uses monads.
04:32:53 <vixey> @unpl flip =<< (((.) . (,)) .) . flip id
04:32:53 <lambdabot> (\ n -> ((\ g w e f -> ((,)) (g w) (e f)) >>= \ a b c -> a c b) (\ j -> j n))
04:32:58 <vixey> I don't understand
04:33:05 <vixey> is it just a buggy unpl?
04:33:11 <Olathe> I'm not sure.
04:33:13 <vixey> how can they have different types
04:33:16 <Olathe> Let's see if it works.
04:33:41 <ClaudiusMaximus> how do i define operator precedence and associativity?  i want:  a >|- b -|- c -|> d   to mean   a >|- ( ( b -|- c ) -|> d )
04:34:01 <Gracenotes> > (\ n -> ((\ g w e f -> ((,)) (g w) (e f)) >>= \ a b c -> a c b) (\ j -> j n)) 4 (+5) (-5)
04:34:02 <lambdabot>       No instance for (Num (a -> a))
04:34:02 <lambdabot>        arising from a use of `negate' at...
04:34:21 <Olathe> > let q = (\ n -> ((\ g w e f -> ((,)) (g w) (e f)) >>= \ a b c -> a c b) (\ j -> j n)) in (h [1, 2], n) where (h, n) = q map (+3) 2
04:34:22 <lambdabot>   Couldn't match expected type `((a -> b) -> [a] -> [b])
04:34:24 <ski_> vixey : i think the corresponding paper to that above Hughes presentation may be : Polish Parsers, Step by Step <http://people.cs.uu.nl/doaitse/Papers/2003/p224-swierstra.pdf> by R. John M. Hughes, S. Doaitse Swierstra
04:34:37 <Olathe> > let q = \f g a -> (g f, f a) where (h, n) = q map (+3) 2
04:34:38 <lambdabot>   <no location info>: parse error on input `;'
04:34:53 <Olathe> > let q = \f g a -> (g f, f a) in (h [1, 2], n) where (h, n) = q map (+3) 2
04:34:54 <lambdabot>   Couldn't match expected type `((a -> b) -> [a] -> [b])
04:35:07 <Olathe> > let q = \f g a -> (g f, f a) in (h [1, 2], n) where (h, n) = q (+3) map 2
04:35:08 <lambdabot>   Couldn't match expected type `(a -> a)
04:35:36 <ski_> vixey : is `KEEP name! DROP ws! KEEP parameters! DROP (wstring ":")! KEEP term! DROP finish! STORE==> (,,)' literal haskell ?
04:35:49 <vixey> yes
04:35:58 <vixey> (!) = ($) with different fixity
04:36:02 <ski_> vixey : what would the corresponding GADT be ?
04:36:25 <vixey> data COMMAND m mu nu where
04:36:25 <vixey>  STORE :: COMMAND m r r
04:36:25 <vixey>  SHOVE :: COMMAND m (m r) r
04:36:25 <vixey>  DROP :: m o -> COMMAND m x y -> COMMAND m x y
04:36:25 <vixey>  KEEP :: m o -> COMMAND m x y -> COMMAND m (o -> x) y
04:36:30 <ski_> (and what is `name',`ws',... ?)
04:36:42 <vixey> they're functions from ReadP
04:36:55 <ski_> oh
04:37:20 <vixey> you could do,  KEEP getLine! DROP (print "and?")! KEEP getLine! STORE==> (,)
04:37:30 * ski_ some couple of years ago did a simple embedding of a basic concatenative language in haskell
04:37:39 <ski_> like
04:37:57 <ski_> lit :: a -> (a -> o) -> o
04:38:05 <ski_> lit x k = k x
04:38:15 <ski_> dup :: (a -> a -> o) -> (a -> o)
04:38:19 <Gracenotes> 10th Fibonacci number = sum of numbers from 1 to 10. Coincidence??? I don't think so
04:38:24 <ski_> dup k x = k x x
04:38:29 <Olathe> > let q = \f g a -> (g f, f a) in fst (q (+3) map 2) $ [1..3]
04:38:31 <lambdabot>   [4,5,6]
04:38:39 <ski_> swap :: (b -> a -> o) -> (a -> b -> o)
04:38:46 <ski_> swap k x y = k y x
04:38:50 <Olathe> > let q = (\ n -> ((\ g w e f -> ((,)) (g w) (e f)) >>= \ a b c -> a c b) (\ j -> j n)) in fst (q (+3) map 2) $ [1..3]
04:38:51 <lambdabot>       No instance for (Num ((a -> a) -> [a] -> [a]))
04:38:51 <lambdabot>        arising from the ...
04:38:55 <vixey> ski_, aha I like it
04:39:03 <Olathe> Yeah, it's not the same, apparently.
04:39:05 <ski_> add :: Num a => (a -> o) -> (a -> a -> o)
04:39:18 <ski_> add k x0 x1 = k (x0 + x1)
04:40:00 <ski_> so the evaluation state is `word continuation stackElem0 stackElem1 ..'
04:40:20 <vixey> that's really neat :)
04:40:24 <Gracenotes> @pl \f g a -> ((\x -> g x) f, (\x -> f x) a)
04:40:25 <lambdabot> flip =<< (((.) . (,)) .) . flip id
04:40:26 <ski_> pyth :: Num a => (a -> o) -> (a -> a -> o)
04:40:44 <ski_> pyth = add . swap . add . mult
04:41:25 <ski_> (maybe i had to `flip' the `(.)' .. don't recall right now)
04:41:57 <ski_> there's a `run' primitive
04:42:28 <ski_> run :: ((o -> o) -> o) -> o
04:42:33 <ski_> run word = word id
04:42:44 <ski_> or, (as i see now) better typed as
04:42:52 <ski_> run :: (forall o. (a -> o) -> o) -> a
04:42:59 <vixey> eek
04:43:11 <vixey> I have to think about that type a bit
04:43:35 <ski_> (actually, `pyth' should be defined as
04:43:39 <drdozer> Cale - you awake?
04:43:42 <int-e> vixey: we can implement it with unsafePerformIO, throwDyn and catchDyn
04:43:53 <dever> hey, I want to filter from a [FilePath] like so  filter (`notElem` "..") list
04:43:53 <ski_>  pyth = square . swap . square . add
04:43:55 <ski_>  with
04:43:58 <dever> but i get errors....
04:44:02 <ski_>  square = dup . mult
04:44:03 <ski_> )
04:44:06 <int-e> ;)
04:44:14 <Cale> drdozer: morning
04:44:18 <vixey> ?djinn (forall o. (a -> o) -> o) -> a
04:44:19 <lambdabot> -- f cannot be realized.
04:44:24 <ski_> so `run (lit 2 . lit 3 . pyth)' would evaluate to `25'
04:44:25 <chessguy_work> Cale is always awake :)
04:44:27 <vixey> ?djinn forall a. (forall o. (a -> o) -> o) -> a
04:44:27 <lambdabot> -- f cannot be realized.
04:44:30 <int-e> @type ($ id)
04:44:31 <lambdabot> forall b a. ((a -> a) -> b) -> b
04:45:20 <ski_> also, i experimented a little with if-else-then, and adding labels
04:45:28 <vixey> ski_, :(
04:45:32 <vixey> ski_, I don't understand this
04:45:43 <vixey> what's going on with the forall ?
04:46:09 <ski_> that's just to ensure that the word is polymorhic in the stack
04:46:14 <int-e> err, wait. What I want is  ((a -> (forall x . x)) -> (forall x . x)) -> a
04:46:37 <vixey> ski_, does it realy typecheck?
04:46:45 <vixey> I'm thiking abuot
04:46:46 <ski_> we want the word to promise that it won't touch the input stack, and to just give a single value of type `a' on top of that as output stack
04:46:58 <vixey> /\a, (/\o, \f -> ...) ...
04:47:02 <vixey> I can't see how it goes though
04:47:06 <ski_> so that we may `run' it on the top-level on the empty stack
04:47:23 <ski_> (of course, the empty stack sortof doesn't exist, here .. but that doesn't matter :)
04:47:25 <vixey> oh!
04:47:48 <ski_> vixey : you see it ?
04:47:50 <vixey> it's  /\a, \f :: (forall o. (a -> o) -> o), f id
04:47:51 <vixey> yes I see
04:48:09 <ski_> *nod*
04:48:12 <vixey> or
04:48:18 <vixey> /\a, \f :: (forall o. (a -> o) -> o), f a id
04:48:24 <vixey> if I were being very explicit
04:48:38 <ski_> (i didn't know about higher-rank types when i scribbled this, so i didn't think of that type for `run' then)
04:48:38 <vixey> anyway.. I see
04:49:06 <vixey> higher-rank types are quite confusing to me...
04:51:36 <vixey> labels.... for goto?
04:53:33 <ski_> (vixey : apparently i got the idea in 2000 and expanded it a bit in 2001)
04:54:54 <ski_> (can't find the file where i had labels .. but yes, goto .. or actually more like call/cc)
04:55:13 <vixey> aha
04:55:20 <vixey> so basically delimited continuations ??
04:55:42 <ski_> hadn't seen those by then .. and don't recall details to compare atm
04:56:12 <vixey> I mean reset/shift
04:57:09 <ski_> istr one variant was like `foo . pushExit (bar . baz) . quux', where a continuation pointing at `quux' would be pushed between `foo' and `bar'
04:57:48 <trofi> Hi! I would like to write program, which uses Control.Exception. I'd also like program compiled with base-3 and base-4. I can write my wrapper for both Exception APIs, but i need to detect base version during compiletime. How to do it?
04:58:14 <ski_> vixey : anyway, what i thought was nice about this embedding what that it was naturally heterogenous in the stack
04:59:12 <mauke> trofi: why do you want to use base-4?
04:59:16 <quicksilver> trofi: I believe this is what cabal 'flags' are for?
04:59:38 <vixey> ski_, it's very neat that combined with no need to reify the stack at all
05:00:12 <trofi> mauke: why not? :]
05:00:22 <vixey> similar thing happens parsing with continuations
05:00:26 <mauke> because it's complicated
05:00:29 <trofi> AFAIU base-4 is our near future
05:01:24 <ski_> vixey : parsing with continuations ?
05:01:35 <Axman6> what ever happened to that guy who was furious about record syntax?
05:01:44 <ski_> (vixey : bottom-up or top-down parsing, btw ?)
05:01:46 <trofi> quicksilver: can you point me to an example for it on hackage?
05:02:45 <quicksilver> trofi: sadly not :-S
05:02:49 <ski_> (Axman6 : Ezla / Megzlna ?)
05:02:57 <Axman6> yeah
05:03:11 <vixey> hum..... top down I think, It's hard to remember which is which
05:03:15 <trofi> i've seen bytestring switches, but they are all about in-base/out-of-base
05:03:39 <ski_> vixey : top-down is the recursive descent one .. bottom-up is the one with shift and reduce
05:03:52 <ski_> (vixey : somewhat simplified)
05:03:55 <vixey> I mean like  parse ('(':xs) k = parse xs (\m ys -> k (Bracket m) ys)
05:04:30 <vixey> (well that example was missing ')':ys)
05:04:43 <ski_> vixey : i think that qualifies as bottom-up (iiuc)
05:05:31 <ski_> (vixey : not that i think i've seen this one before (not in detail))
05:07:10 <ski_> (vixey : anyway, i think you might find the Polish type in the aforementioned Hughes,Swierstra paper interesting for comparision)
05:07:30 <vixey> yeah I skimmed it earlier
05:07:42 <vixey> same thing really, except they use the normal syntax instead of GADT
05:07:55 <vixey> (and they used it a many years before me too...)
05:08:10 <ski_> ok
05:16:02 <ski_> vixey : what happens if one modifies `COMMAND' to allow each command access to the previous `KEEP't results ?
05:16:43 <vixey> ski_, not sure what you mean, like a >>= thing?
05:16:58 <ski_> somewhat
05:17:40 <vegai> mm, is it so that I can pretty much mindlessly replace (++) with showString?
05:18:56 <ski_> it might allow something like
05:19:01 <ski_>   KEEP name! DROP (\n -> ws)! KEEP (\n -> parameters)! DROP (\(p,n) -> (wstring ":"))! KEEP (\(p,n) -> term)! DROP (\((p,n),t) -> finish)! STORE==> (\((p,n),t) -> (p,n,t))
05:19:35 <vixey> aha
05:19:43 <vixey> yeah I can see that working
05:19:59 <ski_> (so the actual command chain isn't computed from the earlier results .. but each command link is parameterized by the earlier results)
05:20:31 <ski_> one can also imagine `COMMAND's for throwing away temporary results that are no longer needed
05:23:28 <ski_> vixey : i believe so
05:23:32 <ski_> er
05:23:39 <ski_> *vegai* : i believe so
05:24:54 * ski_ idly wonders whether other people have accidentally used the same (local) variable names for two different things, not realizing one shadows the other
05:25:00 <int-e> . o O ( DROP KEEP would be roughly equivalent to ABSTAIN FROM REINSTATING )
05:25:20 <vixey> I have!!!
05:25:26 <vixey> It's bloody annoying
05:25:29 <jeffz`> one time, spotted it fairly quickly though
05:25:35 <vixey> you have to write   x <- return$  foooify x
05:25:43 <int-e> vixey: it does happen
05:25:46 <vixey> I keep doing  let x = fooify x  and my program loops
05:26:15 <ski_> well, updating state is one thing
05:26:20 * vixey  <- return$   let rec
05:26:57 <ski_> i was thinking about (invented example), using `a',`b',`c',`d' for some kind of coefficients, and also using `n' and `d' for numerator and denominator of something
05:27:02 <mauke> ski_: yep
05:27:36 <mauke> in my head, the variables are completely separate, they just get rendered the same when put into code
05:27:42 <ski_> yes
05:27:55 <mauke> I can even read the code and notice nothing wrong ... until the compiler complains
05:28:12 <ski_> (vixey : but yes, that one is annoying as well)
05:31:54 <int-e> ski_: we had a great example on haskell-cafe in september, where the identifiers were x,y,z, a,b,c and r,g,b
05:32:50 <ski_> how long did it take for someone to spot the problem ?
05:33:06 <vixey> and it wasn'ta type error ?!
05:34:32 <int-e> they were all Ints. http://www.haskell.org/pipermail/haskell-cafe/2008-September/047394.html
05:34:59 <quicksilver> It's obviously a bug to have two different names in scope which share the same type.
05:36:21 <vixey> you know what the problem is not weakening/contraction :p
05:36:43 <ski_> maybe sometimes Pascal-like genericity of types would not be such a bad idea ?
05:37:13 <Axman6> i remember doing pascal in high school, installed the Xcode stuff for it and everything
05:37:18 <int-e> genericity?
05:37:26 <ski_> type A = Int
05:37:30 <ski_> type B = Int
05:37:39 <ski_> foo :: A -> ...
05:37:53 <ski_> foo a = ..(a + (1 :: Int))..
05:38:07 <ski_> `foo (5 :: Int)' is ok
05:38:11 <quicksilver> is that a type synonym which permits upcasting but not downcasting?
05:38:12 <ski_> `foo (5 :: B)' is not ok
05:38:24 <int-e> so a sort of lightweight newtypes
05:38:30 * ski_ doesn't recall the details
05:38:33 <quicksilver> or one-way newtypes :)
05:38:54 <quicksilver> doesn't C's typedef also work in this fashion?
05:39:09 <quicksilver> coercion in one direction is implicit, the other direction requires an explicit cast.
05:39:22 <ski_> quicksilver : not that i know, but that might be
05:39:27 <mib_zy3gz4rn> I need help whith this f x y = g x . h y
05:40:00 <ski_> (it might be that in Pascal, coercing from `A' to `Int' is also ok .. just not coercing from `A' directly to `B')
05:41:05 <int-e> ski_: so ... let x = a; b = x   where a :: A and b :: C should work? And the compiler would have to infer x :: Int?
05:41:19 <int-e> ski_: sorry, b :: B
05:41:54 <ski_> mib_zy3gz4rn : f = curry (uncurry (.) . (g *** h))  -- all clear ?
05:41:58 <int-e> (that would break equational reasoning, too)
05:42:35 <int-e> @unpl curry (uncurry (.) . (g *** h))
05:42:35 <lambdabot> curry (\ f -> uncurry (\ a b c -> a (b c)) ((g *** h) f))
05:43:04 <mib_zy3gz4rn> thanks
05:43:11 * ski_ smiles
05:43:44 <ski_> int-e : yes, that seems troublesome ..
05:44:15 <Gracenotes> how @pl removes *all* points can make code a bit verbose...
05:44:24 <Gracenotes> .@unpl, even
05:44:29 <ski_> (though maybe it would not infer `x :: Int' but insist on specifying that (like with polymorphic recursion or higher-ranked types ..)
05:44:43 <Gracenotes> or is that add points?
05:44:55 <ski_> the latter
05:44:59 <ski_> @help pl
05:44:59 <lambdabot> pointless <expr>. Play with pointfree code.
05:45:11 <Gracenotes> I'm sure topologists would understand that
05:45:39 <ski_> great ! now all you have to do is become a topologist !!
05:46:16 <Gracenotes> :D
05:46:24 <Gracenotes> joy to the world...
05:46:44 * ski_ is slightly tired atm, so should probably abstain from irc for a couple of hours
05:46:52 <schme> what?
05:47:00 <schme> nonsense
05:48:27 <mib_9oawr4py> i need help  \ x f -> f x is same as  flip const or flip id or flip . const or flip (.) id or const . flip id
05:49:45 <EvilTerran> mib_9oawr4py, at least one of those is correct, yes
05:49:56 <yitz> @pl \ x f -> f x
05:49:56 <lambdabot> flip id
05:50:15 <Axman6> that makes sense
05:50:24 <EvilTerran> flip ($), if you prefer
05:51:43 <mib_9oawr4py> thanks
05:52:29 <EvilTerran> mib_9oawr4py, you can tell by the types, if nothing else
05:52:37 <EvilTerran> ?type \ x f -> f x
05:52:38 <lambdabot> forall t t1. t -> (t -> t1) -> t1
05:52:46 <yitz> mib_9oawr4py: try using :t on each of those to get an idea of what each does
05:53:28 <yitz> oops EvilTerran just said that
05:54:19 <baaba> :t flip id
05:54:20 <lambdabot> forall b c. b -> (b -> c) -> c
05:54:42 <baaba> :t flip (id :: (a -> b -> c) -> a -> b -> c)
05:54:43 <lambdabot> forall a b c. a -> (a -> b -> c) -> b -> c
05:54:52 * ski_ predicts mib_9oawr4py will now quit irc, and then her/his and mib_zy3gz4rn's friend, mib_p0t5re1be will join and ask a question
05:55:06 <baaba> how does it decide that?
05:55:21 <baaba> oh er
05:55:29 <baaba> nevermind, they're the same :P
05:55:59 <vixey> baaba, there's a < ordering on types by generality
05:56:24 <polveroj> @pl \_ a _ -> a
05:56:25 <lambdabot> const const
05:56:30 <baaba> is there a formal specification of that somewhere?
05:57:41 <vixey> baaba, could define  T < S  iff  there is a substitution s of the variables in so thant s(T) = S
05:59:58 <EvilTerran> whups
06:00:18 <yitz> @type const const const
06:00:19 <lambdabot> forall a b. a -> b -> a
06:00:28 <EvilTerran> ?type flip flip flip
06:00:29 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
06:00:31 <vixey> @type const const const const
06:00:32 <lambdabot> forall b a b1. b -> a -> b1 -> a
06:00:36 <vixey> @type const const const const const
06:00:37 <lambdabot> forall a b. a -> b -> a
06:00:46 <EvilTerran> vixey, it seems const const const = const
06:01:03 <yitz> @check \x y -> const x y == const const const x y
06:01:04 <lambdabot>   "OK, passed 500 tests."
06:01:11 <vixey> @check \x y -> const x y == const const x y
06:01:12 <lambdabot>       Overlapping instances for Show (b -> a)
06:01:13 <lambdabot>        arising from a use of `m...
06:01:16 <vixey> grrrrrrr
06:01:19 <EvilTerran> ... i say "it seems", that'll be because const const _ = const
06:01:22 <yitz> vixey: beat you
06:01:27 <EvilTerran> by virtue of const x _ = x :P
06:01:30 <ski_> @check \x y -> x == y
06:01:32 <lambdabot>   "OK, passed 500 tests."
06:01:40 <yitz> hehe
06:01:42 <vixey> yitz, well I copied and pasted what you wrote, edited it..
06:01:56 <vixey> was going for a convoluted version of what ski got
06:01:56 <yitz> vixey: oh ok. no contest then.
06:02:16 <vixey> @check \x y -> const x y == const const x y x
06:02:17 <lambdabot>   "OK, passed 500 tests."
06:03:13 <yitz> ski_: that's bad. why is @check only using points on the diagonal?
06:03:26 <ski_> yitz : ()
06:05:19 <ski_> (yitz : your next line is `* yitz is enlightened')
06:06:31 <yitz> @vixen are you enlightened?
06:06:31 <lambdabot> yes, i am
06:13:02 <dancor> what
06:13:11 <dancor> @check \ x -> x == ()
06:13:12 <lambdabot>   "OK, passed 500 tests."
06:13:16 <dancor> @check \ x -> x == 1
06:13:18 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
06:13:27 <dancor> @check \ x y -> x == y
06:13:29 <lambdabot>   "OK, passed 500 tests."
06:13:34 <dancor> @check \ x y -> x == (y :: Int)
06:13:35 <lambdabot>   "Falsifiable, after 1 tests:\n-3\n-2\n"
06:14:10 <flux> what 500 tests did it run on \x y -> x == y?-o
06:14:10 <fasta> [spam] Hot off the press: http://gamr7.com/blog/?p=66 [/spam]
06:14:37 <dancor> () is the only sensible default?  that's so haskell
06:14:39 <quicksilver> 500 copies of () == ()
06:14:54 <quicksilver> extended defaulting.
06:15:08 <flux> doesn't it figure that some (most) of tests are identical?
06:15:23 <flux> (I suppose that was a stupid question: how come it doesn't etc ;-))
06:15:38 <quicksilver> there's no requirement that testable quantities be members of Eq
06:15:40 <flux> perhaps in practice such cases are sufficiently rare?
06:15:48 <quicksilver> and adding an extra equality test to all tests would slow everything down
06:15:56 <quicksilver> as would keeping a list of previously used test cases.
06:16:25 <quicksilver> for a testing package that takes a different approach to choosing its test case, see smallcheck.
06:16:30 <dancor> yeah random generation is good for quickcheck
06:17:56 <Axman6> i have a new found respect for quickcheck after reading the RWH chapter on it, it's really nice :)
06:19:20 <thoughtpolice> quckcheck = win
06:21:25 <afedorov> A friend of mine sent me code I'm trying to understand: http://hpaste.org/13634
06:21:28 <dancor> hayoo source isn't available?
06:21:40 <Axman6> fasta: looks good :)
06:21:41 <afedorov> question: what is the `id' doing in the first line?
06:21:50 <Axman6> @src id
06:21:50 <lambdabot> id x = x
06:21:55 <fasta> Axman6: thanks!
06:21:56 <afedorov> yes, but what does it mean in...
06:22:02 <afedorov> "foldr step id xs []"
06:22:11 <Axman6> afedorov: means that you get out whatever you put into it :)
06:22:31 <trofi> > foldr f id [a,b,c]
06:22:32 <yottis> i should try out quickcheck on a larger system, but i'm afraid it might waste too much time on testing the same things over and over again
06:22:33 <lambdabot>       Overlapping instances for Show (a -> a)
06:22:33 <lambdabot>        arising from a use of `s...
06:22:34 <afedorov> I guess it's more of a question about foldr...
06:22:42 <trofi> > foldr f id [a,b,c] :: Expr
06:22:43 <lambdabot>   Couldn't match expected type `Expr' against inferred type `a -> a'
06:22:56 <trofi> > foldr f id [a,b,c] d :: Expr
06:22:57 <lambdabot>       Overlapping instances for Show (Expr -> Expr)
06:22:57 <lambdabot>        arising from a use...
06:22:59 <Axman6> > foldr f h [a,b,c]
06:22:59 <thoughtpolice> afedorov: you can think of foldr as simply going over a list, carrying some state around
06:23:00 <lambdabot>   Add a type signature
06:23:04 <Axman6> > foldr f h [a,b,c] :: Expr
06:23:05 <lambdabot>   f a (f b (f c h))
06:23:08 <yottis> that's a problem because setting up the environment and starting the system takes time, though it's automated
06:23:27 <afedorov> yes, I've used foldr, but I thought it takes <function>, <first elem>, <list>
06:23:41 <thoughtpolice> afedorov: it does
06:23:42 <Axman6> fasta: i'm going to read that tomorrow, looks really good :)
06:23:45 <thoughtpolice> :t foldr
06:23:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:23:51 <afedorov> here, he's applying it to to <function>, <function>, <first elem>, <list>?
06:23:51 <earthy> isn't that <functoin> <last element>
06:23:52 <earthy> ?
06:23:55 <EvilTerran> afedorov, it's not the "first element", it's the initial value of the "state"
06:24:04 <dancor> hayoo also checks referer or some such, it's awful propriowebapp-ey for what it is isn't it
06:24:05 <EvilTerran> that then gets threaded through the list right-to-left
06:24:13 <afedorov> EvilTerran, got it, my mistake about that
06:24:13 <dancor> know your audince
06:24:25 <EvilTerran> so it can be a different type to the list elements :)
06:24:30 <afedorov> still confused what "foldr step id xs []" does, though
06:25:00 <afedorov> (step is defined afterwards)
06:25:27 <earthy> foldr step id xs    builds a result
06:25:36 <Axman6> afedorov: easiest way to think of it is, you replace all :'s with f and [] with z in foldr f z xs
06:25:46 <EvilTerran> > foldr (.) id [f :: Expr -> Expr, g, h] x
06:25:47 <earthy> of a function type
06:25:48 <lambdabot>   f (g (h x))
06:25:51 <thoughtpolice> afedorov: in this case, the 'initial state' passed to foldr is a function
06:25:52 <Axman6> though i find that definition comfusing >_<
06:25:55 * Axman6 goes to bed
06:25:57 <EvilTerran> there's an example that uses "id" as the second parameter to foldr
06:25:58 <thoughtpolice> which is 'id'
06:26:01 <EvilTerran> functions are data!
06:26:03 <afedorov> thoughtpolice, ooh, gotcha!
06:26:20 <afedorov> of course, what an interesting way of going about things...
06:26:28 <thoughtpolice> afedorov: so when the 'foldr step id xs' returns, it will return a *function* which is then applied to the []
06:26:29 <earthy> one important example is that of difference lists
06:26:48 <thoughtpolice> afedorov: note that in the definition of 'step' the 'g' parameter is used as a function
06:26:49 <earthy> which basically are lists with cheap concatenation
06:26:52 <afedorov> got it, thanks guys, how clever...
06:27:19 <thoughtpolice> so you're folding over a list, building a function which you then apply. :) higher-order functions ftw!
06:27:41 <trofi> @src concat
06:27:41 <lambdabot> concat = foldr (++) []
06:41:15 <afedorov> thoughtpolice, same example - why does `step' take 3 arguments?
06:41:34 <afedorov> thoughtpolice, oh, because it returns a function, nevermind :)
06:41:44 <Tordek> I think I got monads...
06:41:50 <Tordek> they're made of magic and sugar
06:42:30 <wchogg> So...they're magically delicious?
06:42:56 <Tordek> OMG, LUCKY CHARMS ARE MONADS
07:01:01 <Tordek> I think I got monads... They're like "Oh, no, I can't change the world 'cuz that'd be, like, weird, lol. But, here, you can borrow this world, where the change's already been made."
07:01:15 <vixey> Tordek, WTF
07:01:33 <Tordek> (state monad, at least)
07:04:55 <Botje> i think Tordek is high on monad dust
07:06:14 <wchogg> Botje : damn categoric junkies
07:06:38 <Tordek> *snort* Uhh, yeah, that's the stuff...
07:07:30 <wchogg> Tordek : we're going to put you in rehab, but for now we'll just restrict you to functors instead of monads.  It's like methodone for your kind.
07:07:58 <Tordek> oh, god, no, please, no
07:09:40 <Saya> they tried to make me go to rehab but i said no no no
07:12:37 <vixey> "I don't have a programing problem!"
07:13:37 <osfameron> heh
07:14:01 <Tordek> well, I do have one... a lack of ideas >_>
07:14:18 <imphasing> I'm really starting to love how concise haskell is.. I'm highly enthused now :P
07:14:29 <vixey> @w80 enthused
07:14:40 <lambdabot> No match for "enthused".
07:14:55 <Gracenotes> oh!!.... I just realized that the :: in record notation is actually the same :: used to specify the type of something
07:15:07 <imphasing> vixey, No one said that was a real word :P
07:15:16 <Gracenotes> at first glance it looks like a bit of a dictionary -- mapping name to String
07:15:20 <vixey> I know what it means I just wondere
07:15:22 <Gracenotes> when actually name is of type String
07:15:27 <Gracenotes> *headdesk*
07:15:38 <imphasing> vixey, Oh, it is a word: http://www.thefreedictionary.com/enthused
07:15:47 <wchogg> It'
07:15:49 <imphasing> Eh, maybe not.
07:15:59 <wchogg> It's not a word I choose to recognize.  *shakes fist*
07:16:10 <Gracenotes> I use 'enthused' in real life
07:16:20 <Gracenotes> it must be a real word, then
07:16:28 <wchogg> I'm going to go yell at some kids for being on my lawn now
07:17:10 <Tordek> I sometimes find the syntax a bit odd and disconcerting... I don't know if I should do 'sum . (map f) $ xs' or just 'sum (map f xs)'
07:17:42 <wchogg> Tordek : for short chains I think sum (map f xs) is okay.  For longer compositions I think the former is a bit more readable
07:18:35 <Gracenotes> Tordek: if you don't want to include "xs" at all, sum . map f would work
07:19:09 <Tordek> so the former'd be better if I did, say valid . sum . map (f) $ xs
07:19:17 <Gracenotes> mapSum f xs = sum . (map f) $ xs ... mapSum f = sum . map f ... mapSum = sum . map
07:19:26 <Tordek> er, fixing those parentheses
07:19:35 <Gracenotes> more or less same thing
07:19:50 <Tordek> yeah, I get pointless functions
07:20:06 <SamB_XP> wouldn't you call that sumMap ?
07:20:16 <trofi> :t mapAccum
07:20:17 <lambdabot> Not in scope: `mapAccum'
07:20:43 <Gracenotes> SamB: well, you map and then you sum. That's my rationale anyway..
07:20:46 <SamB_XP> mapSum sounds more like \f -> map f . sum
07:20:57 <trofi> :t mapAccumL
07:20:58 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:21:18 <SamB_XP> :t concatMap
07:21:19 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:21:28 <Gracenotes> hm. good point
07:28:29 <gio123> ski_: hi
07:28:32 <idesperado> hi guys... I'm a newbie of Xmonad...I want some apps shift to certain workspaces...and I saw John  Goerzen's config using doF thing...how like...W.Shift...and I copied that,just to find it's useless and an  error turned out...
07:29:02 <idesperado> and my config... http://paste.ubuntu.org.cn/12062
07:29:16 <Lemmih> idesperado: There's an xmonad irc channel.
07:29:44 <idesperado> Lemmih: well.....I've already asked there..but no answer...
07:30:01 <idesperado> Lemmih: so ...
07:30:15 <thoughtpolice> Lemmih: are you planning on upgrading lhc.seize.it to gitit-0.4 etc?
07:30:31 <Lemmih> thoughtpolice: Not really. Should I?
07:31:05 <thoughtpolice> Lemmih: I'm wondering because john added things like CAPTCHA and proper utf8 support, but to switch from 0.3 -> 0.4 it'll need some manual help and users will have to recreate their logins
07:31:23 <thoughtpolice> Lemmih: http://www.nabble.com/ANN:-gitit-0.4.1,-recaptcha-0.1-td21239262.html
07:31:25 <dever_> hey, if i wanted to filter ( not isPrefixOf "." ) list, what wwould be the correct way of writing it, whatever i try i get an erra
07:31:44 <thoughtpolice> that has the details i believe
07:31:48 <vixey> dever_, (.) is for composition not . isPrefixOf "."
07:32:07 <Zao> @src (.)
07:32:07 <lambdabot> (f . g) x = f (g x)
07:32:42 <BMeph> Gracenotes: That would have to be mapSum (or sumMap, w/e) = (sum .). map, otherwise, you'll lose that other composition. :)
07:33:04 <dever_> ah, thanks, i was doing the infix of isPrefixOf, and that was what was throwing the errors
07:33:23 <SamB_XP> filter (not ("." `isPrefixOf`))
07:33:54 <pao> Hi all
07:34:45 <BMeph> pao: Hi! :)
07:34:53 <Gracenotes> let smsms = sum . map in smsms (+10) [1..5] --?
07:34:53 <pao> :-)
07:35:00 <Gracenotes> > let smsms = sum . map in smsms (+10) [1..5]
07:35:00 <lambdabot>   Couldn't match expected type `[a]'
07:35:06 <pao> I'm fiddling with Cabal ...
07:35:08 <Tordek> damn randomness
07:35:11 <Gracenotes> oh *raises eyebrows*
07:35:18 <BMeph> Gracenotes: (sum .) . map
07:35:32 <smarmy> @pl f -> sum . map f
07:35:32 <lambdabot> (line 1, column 3):
07:35:32 <lambdabot> unexpected ">" or "-"
07:35:32 <lambdabot> expecting variable, "(", operator or end of input
07:35:33 <pao> I'm trying to get Cabal (Setup.hs) honour the GHC_PACKAGE_PATH env variable...
07:35:36 <BMeph> > let smsms = (sum .). map in smsms (+10) [1..5]
07:35:37 <lambdabot>   65
07:35:46 <Gracenotes> BMeph: oh, argh, I always forget you have to do that to compose functions with two parameters
07:35:46 <smarmy> @pl \f -> sum . map f
07:35:46 <lambdabot> (sum .) . map
07:35:47 <pao> ...without success
07:35:51 <Gracenotes> like +
07:36:01 <pao> anyone have an advice?
07:36:11 <Tordek> I can't figure out how to generate a list of random values (isn't there a Random monad?)
07:36:16 <BMeph> Gracenotes: Exactly - two arguments == two compositions. :)
07:36:27 <gio123> when I am elemenating universal quintifier can I take insted of bind variable constant which is already used in the formula?
07:36:35 <gio123> lets take forall X f(X,a)   can I say lets consider f(a,a)?
07:36:41 <Gracenotes> @unpl (g .) . f
07:36:42 <lambdabot> (\ d i -> g (f d i))
07:36:45 <Gracenotes> @unpl (. g) . f
07:36:45 <lambdabot> (\ d i -> f d (g i))
07:37:05 <Gracenotes> always confuse those too ;)
07:37:10 <idnar> heh
07:37:14 <Saya> yeah theres a random monad, you write your generator in it and then call it from IO monad to get values
07:37:37 <BMeph> gio123: Sure. :)
07:37:37 <Saya> or something like that
07:37:38 <Tordek> hmm
07:37:43 <Tordek> there's a Gen monad
07:38:12 <BMeph> gio123: Whoa, wait - huh? :)
07:38:12 <Tordek> which seems to do exactly what I want
07:38:12 <smarmy> Gracenotes: (f .) composes on the front, (. g) composes on the rear, and (f .) . (. g) sandwiches between
07:38:39 <abuiles> pao: what do you mean with honour ?
07:39:21 <Gracenotes> smarmy: the latter for three parameters?
07:39:48 <pao> abuiles: I'd like Cabal to populate the ghc-packages.conf file pointed by the GHC_PACKAGE_PATH instead of the default ~/.ghc/i386-darwin-6.10.1/package.conf:
07:40:03 <Gracenotes> hm.
07:40:05 <Saya> > getStdGen
07:40:07 <lambdabot>       No instance for (Typeable StdGen)
07:40:07 <lambdabot>        arising from a use of `show' a...
07:40:12 <smarmy> Gracenotes: no, the latter (i.e. (f .) . (. g) h) will, assuming h returns h', result in f . h' . g
07:40:36 <smarmy> Gracenotes: so you can squish the resulting function in between f and g with (f .) . (. g)
07:40:45 <Gracenotes> ah
07:41:10 <Saya> lambdabot features should be in ghci (@src etc..)
07:41:28 <pao> abuiles:   --package-db=PATH              Use a specific package database (to satisfy
07:41:28 <pao>                                    dependencies and register in)
07:41:45 <pao> abuiles: you never look into the obvious places :-)
07:41:47 <Gracenotes> > let af = (length .) . (. (*2)) in af show 500
07:41:48 <lambdabot>   4
07:42:26 <smarmy> Gracenotes: where f and g can each be chains of composed functions themselves
07:42:26 <smarmy> Gracenotes: handy
07:42:33 <abuiles> pao: I had a very similar problem some days ago.
07:42:44 <dever_> hey wondering could anyone suggest any improvements to my code? a more haskellish way maybe? it does everything it should, just want critique :D http://hpaste.org/13635
07:42:50 <Gracenotes> mm, I see
07:42:50 <pao> abuiles: what you were trying to achieve?
07:42:55 <abuiles> pao: How many versions of GHC do you have?
07:43:05 <pao> abuiles: two (6.8.3 and 6.10.1)
07:44:36 <smarmy> Gracenotes: you can generally tell the "number of parameters" involved from the nested depth of (.)
07:44:46 <gio123> if we want to prove for all X f(X,a) and if we take arbiotrary X=a and prove f(a,a). does it means we proved forall X. f(X,a)?
07:45:16 <dever_> ?
07:45:46 <IvdSangen> forall X f(X,a), is 'a' a constant?
07:45:59 <Gracenotes> let af = (. show) . map in af digitToInt 1000
07:46:05 <Gracenotes> > let af = (. show) . map in af digitToInt 1000 --argh
07:46:07 <lambdabot>   [1,0,0,0]
07:47:07 <jeffersonheard> happy new year, folks.  So I run haddock on my computer and it's generating doc for Hieroglyph just fine, but on Hackage, the doc comes up blank.  Why is that?
07:48:46 <Gracenotes> > let af = show . map digitToInt in af 19430
07:48:47 <lambdabot>       No instance for (Num [Char])
07:48:47 <lambdabot>        arising from the literal `19430' at...
07:49:03 <Gracenotes> > let af = (. show) . map digitToInt in af 19430
07:49:04 <lambdabot>   Couldn't match expected type `String -> c'
07:49:15 <Gracenotes> heh. fun.
07:49:19 <Gracenotes> > let af = (show .) . map digitToInt in af 19430
07:49:20 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[Int]'
07:49:33 <BMeph> gio123: That's 'exists  X f(X,a)', not forall. 'forall' means *all*. :)
07:50:03 <Gracenotes> *tries ghci*
07:50:14 <quicksilver> no, gio123 had it right.
07:50:21 <smarmy> Gracenotes: just a random number or are you just outside Philly?
07:50:26 <quicksilver> proving for some arbitrary a is how you prove it forall a.
07:50:39 <quicksilver> the important word being 'arbitrary' not 'specific'
07:51:26 <Gracenotes> smarmy: yep, an arbitrary number. My fingers constructed the number, not my brain ;)
07:51:34 <smarmy> Gracenotes: :)
07:52:29 <BMeph> quicksilver: But if you're choosing a particular 'a', isn't that not arbitrary? :)
07:53:13 <fasta> BMeph: it's arbitrary, meaning that it can be decided by the attacker of your proof.
07:53:15 <quicksilver> that would indeed not be arbitrary.
07:53:30 <quicksilver> so you have to pick an arbitrary one - i.e. one about which you assume nothing.
07:53:37 <quicksilver> apart from its type (in haskell)
07:53:48 <smarmy> you mean proving 2 + x always equals 4 by "arbitrarily" choosing 2 doesn't work?
07:53:57 <quicksilver> (if the type is constrained)
07:54:05 <fasta> smarmy: right, that doesn't work.
07:54:10 <smarmy> ;)
07:54:58 <Gracenotes> so I can translate (. g) . f to f something dot g, and (g .) . f as g dot f something
07:55:27 <Gracenotes> ah, that's a helpful mnemonic -- whether it's dot g or g dot
07:55:28 <smarmy> yep
07:55:42 <saml> is unification a pure function?
07:55:55 <saml> unify term1 term2 = term3
07:56:00 <Botje> sure
07:56:24 <saml> @hoogle unify
07:56:25 <lambdabot> No results found
07:56:37 <quicksilver> well, for an appropriate reification of terms.
07:56:56 <quicksilver> it's not a pure function on haskell terms, because a "partially unified type" is not a firstclass thing.
07:56:58 <fasta> Everything but launching a missle is a pure function.
07:58:59 <Gracenotes> we need a missile transformer, surely
07:59:11 <jeffersonheard> no decepticons
07:59:36 <oklopol> jeffersonheard: is that a fancy way to say "no kidding"?
08:00:26 <jonaskoelker> here's a bad pun for you all:  "What do you call GPL'ed code with no explicitly named function arguments?"   //    "pointfree software"
08:00:40 * EvilTerran is sent thinking by all this talk of unification and whatnot about trying to write a Show instance for Mu
08:01:00 <EvilTerran> (a problem i've got stuck on before)
08:01:29 <EvilTerran> ,src 'Mu
08:01:31 <quicksilver> the channel has solved it.
08:01:37 <quicksilver> I remember being here when it happened.
08:01:44 <EvilTerran> can you remember the solution?
08:01:45 <lunabot>  newtype Mu f = ... | Mu (f (Mu f)) | ...
08:01:45 <lunabot>  infixl 9
08:01:46 <quicksilver> but, I can't replicate the solution for you ;)
08:01:50 <EvilTerran> aww
08:02:01 <dolio> instance (Show f (Mu f)) => Show (Mu f) where ...
08:02:09 <dolio> Show (f (Mu f)) even
08:02:57 <EvilTerran> hm... that's an undecidable instance, isn't it?
08:03:05 <dolio> Wouldn't surprise me.
08:05:02 <quicksilver> EvilTerran: it's decidable if there is an instance of the form instance (Show a) => Show (f a)
08:05:14 <quicksilver> EvilTerran: it reduces to a perfectly harmless mutual recursion then
08:05:19 <quicksilver> but you can't explain that to GHC, of course.
08:06:19 <SamB_XP> so ... what do we need ? higher order instances ?
08:06:45 <quicksilver> if you could put (forall a . Show a => Show (f a)) into a context that might help?
08:06:55 <quicksilver> but then unification of class contexts would be a harder problem.
08:07:17 <EvilTerran> SamB_XP, a flag to allow structural recursion in (mutually-)recursive instances
08:08:30 <pao> can anyone explain what is the auto generated "Paths_<pkg>.hs" cabal file is for?
08:08:44 <EvilTerran> although i note in this case that it works due to structural recursion at the value level, rather than the type level like i'd usually expect. that complicates things.
08:08:46 <EvilTerran> =/
08:08:54 <dcoutts> pao: for finding data files at runtime
08:09:28 <pao> dcoutts: which "runtime" exactly?
08:09:42 <pao> dcoutts: I could not trace any import of it
08:10:55 <dcoutts> pao: it's only used if you do actually import it, you do not need to use it
08:11:20 <dcoutts> pao: it's just there for you to use if your package needs to know at runtime where it got installed to
08:11:31 <jeffersonheard> what does GHCi mean when it says, "module main:Foo.Bar is not loaded" after I do an import or :module?
08:11:35 <pao> dcoutts: ok, perfectly clear
08:12:03 <pao> dcoutts: can you confirm that --prefix and --package-db cannot be set by env vars?
08:12:29 <dcoutts> pao: they cannot, cabal does not use many env vars, just $PATH as far as I know
08:13:07 <EvilTerran> oh, hey
08:13:10 <SamB_XP> dcoutts: what about $HOME ?
08:13:10 <EvilTerran> "deriving instance Show (f (Mu f)) => Show (Mu f)" works
08:13:27 <EvilTerran> with {-# LANGUAGE StandaloneDeriving, UndecidableInstances #-}
08:14:36 <EvilTerran> (this instance would be kinda useful in lambdabot and/or lunabot)
08:14:49 <EvilTerran> , Mu . Just . Mu $ Nothing
08:14:54 <lunabot>  Mu (Just (Mu Nothing))
08:15:03 <EvilTerran> oh, hey, lunabot's already got it <.<  >.>
08:15:11 <EvilTerran> > In . Just . In $ Nothing
08:15:12 <lambdabot>       No instance for (Show (Mu Maybe))
08:15:12 <lambdabot>        arising from a use of `show' a...
08:15:28 <dcoutts> @seen benl23
08:15:28 <lambdabot> benl23 is in #haskell. I don't know when benl23 last spoke.
08:16:21 <pao> dcoutts: what's $PATH for?
08:16:24 <dcoutts> SamB_XP: right, on unix getAppUserDataDirectory uses $HOME I expect
08:16:29 <dcoutts> pao: finding executables
08:16:47 <pao> dcoutts: ah sorry :-) that was the obvious one :-)
08:16:57 <SamB_XP> pao: heh, where did you grow up ?
08:17:08 <pao> SamB_XP: ?
08:17:23 <SamB_XP> if you didn't know what PATH is for
08:17:30 <pao> SamB_XP: LOL
08:17:37 <SamB_XP> I mean, a Unix kid would know, a DOS kid would know ...
08:17:40 * pao is ashamed
08:17:56 <SamB_XP> why, they probably have that in Amiga too
08:18:34 <pao> SamB_XP: I'm a unix kid :-) I should be _very_ ashamed :-)
08:21:52 <quicksilver> if you're an emo kid, you have PATHOS instead
08:21:54 * quicksilver ducks
08:21:55 <saml> -XTypeOperators  where is doc for this?
08:22:02 <saml> @hoogle TypeOperators
08:22:03 <lambdabot> Distribution.Extension TypeOperators :: Extension
08:22:03 <lambdabot> Language.Haskell.Extension TypeOperators :: Extension
08:22:13 <EvilTerran> saml, the ghc manual may have something
08:23:26 <pao> dcoutts: ... also cabal-install makes no use of env vars, right?
08:25:29 <dcoutts> pao: is that a different question from the one you asked before?
08:26:23 <pao> dcoutts: yep... I think... before I was referring to "Cabal" proper... now to "cabal-install"
08:26:36 <dcoutts> pao: ok, the answer is the same
08:26:41 <saml> what's data Term a where ....     isn't data Term a = ..?
08:26:44 <dublpaws> anyone know if source code is available for _real world haskell_ ? not the program listings but typesetting..
08:26:52 <pao> dcoutts: thank you
08:26:55 <saml> why is data used with where?
08:27:03 <Gilly> well, i'll ask here too: anyone aware of an np-complete problem for which you can easily count the solutions?
08:27:27 <saml> Gilly, isn't that the definition of np-complete?
08:27:30 <dcoutts> pao: if you want to make these options persistent then cabal-install has a ~/.cabal/config file
08:27:45 <EvilTerran> saml, file:///C:/apps/ghc/doc/users_guide/data-type-extensions.html#infix-tycons
08:27:45 <Gilly> saml: afaik - no
08:27:54 <EvilTerran> er, whups, local copy
08:27:54 <EvilTerran> 1sec
08:28:13 <pao> dcoutts: perfect... that's what I was looking for... I was looking to shell aliasing... but that's obviously better
08:28:14 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons
08:28:27 <saml> EvilTerran, thank you
08:28:29 <EvilTerran> saml, ^ there's your infix types
08:29:13 <EvilTerran> saml, and the "data ... where" syntax is described further down the page, under "8.4.6. Generalised Algebraic Data Types (GADTs)"
08:32:30 <saml> > type T (+) = Int + Int
08:32:31 <lambdabot>   <no location info>: parse error on input `type'
08:32:58 <EvilTerran> saml, no type declerations in lambdabot, unfortunately
08:33:57 <EvilTerran> > let swap :: Arrow (~>) => (a,b) ~> (b,a); swap = arr $ \ ~(x,y) -> (y,x) in swap (1,2)
08:33:58 <lambdabot>   (2,1)
08:34:24 <EvilTerran> saml, there's a (slightly contrived, seeing as i'm just using the (->) instance of Arrow) example
08:35:49 <saml> @type (~>)
08:35:50 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
08:36:07 <EvilTerran> er
08:36:15 <EvilTerran> that's not the (~>) i was using
08:36:40 <maltem> @hoogle (~>)
08:36:41 <lambdabot> No results found
08:36:44 <EvilTerran> seeing as the one i was using was a type variable, for starters; scoped to the decleration, too, as a result
08:36:50 <quicksilver> These aren't the (~>) you are looking for.
08:36:52 <EvilTerran> ?type either :: (a -> c) -> (b -> c) -> a `Either` b -> c -- here's another one
08:36:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:37:05 <maltem> Is lambdabot's (~>) Caleskell?
08:37:07 <EvilTerran> (again, contrived, but eh)
08:37:54 <saml> what's ~>  ?         http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt   this uses Arrow (~>) too
08:38:14 <dmwit> (~>) in lambdabot is just a function somebody wrote.
08:38:23 <saml> @src (~>)
08:38:23 <lambdabot> Source not found. My mind is going. I can feel it.
08:38:26 <EvilTerran> saml, ignore that type signature ?type (~>) gave you, that's irrelevant to the ~> i was using and that page is using
08:38:26 <dmwit> (~>) in those docs is a type.
08:38:28 <maltem> saml: in the case of the docs it's just a variable
08:38:35 <maltem> (a type variable)
08:39:00 <saml> > let ~ = 1 in ~
08:39:01 <lambdabot>   <no location info>: parse error on input `='
08:39:10 <EvilTerran> > let (???) = 1 in (???)
08:39:11 <lambdabot>   1
08:39:11 <saml> type variables can start with ~ ?
08:39:19 <EvilTerran> infix ones can, yes
08:39:28 <EvilTerran> type constructors must start with :
08:39:33 <athos> > let (^_^) = 1 in (^_^^^
08:39:34 <lambdabot>   <no location info>: parse error on input `)'
08:39:35 <athos> > let (^_^) = 1 in (^_^)
08:39:36 <lambdabot>   <no location info>: parse error on input `)'
08:39:39 <maltem> saml: that's exactly what the cited paragraph is about :)
08:39:39 <EvilTerran> type variables can start with any other piece of punctuation
08:39:56 <EvilTerran> just like value constructors and variables
08:40:08 <EvilTerran> athos, (_) is a word character, not punctuation
08:40:18 <saml> brain explodes for good
08:40:20 <EvilTerran> > let (^.^) = 1 in (^.^)
08:40:21 <lambdabot>   1
08:40:32 <athos> EvilTerran: ah ok
08:40:56 <dmwit> saml: Just replace (~>) in those docs with some other meaningless symbol -- say (#) -- and you'll be good to go.
08:41:10 <athos> :t (~>)
08:41:11 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
08:41:17 <saml> data constructor, type constructor can start with :     .   data variables can start with ^ . type variable can start with any
08:41:18 <dmwit> saml: Like this: (>>>) :: Arrow (#) => a # b -> b # c -> a # c
08:42:26 <saml> (>>>) :: Arrow a => a b c -> a c d -> a b d
08:42:37 <dmwit> saml: Data constructor must start with : for infix, upper letter for prefix.  Type constructors and data variables start with punctuation for infix, lower letter for prefix.
08:42:43 <dmwit> oops
08:42:50 <dmwit> s/Type constructors/Type variables/
08:43:04 <dmwit> Type constructors use the same rules as data constructors.
08:43:08 <athos> @instances Arrow
08:43:09 <lambdabot> (->), Kleisli m
08:43:11 <EvilTerran> dmwit, also s/data contructor/type constructor/, i'd think, seeing as it applies to types and newtypes too
08:43:12 <saml> (>>>) :: Arrow (#) => b # c -> c # d -> b # d
08:43:18 <saml> ah i get it this part
08:43:46 <EvilTerran> saml, and that (#) is an arbitrary operator name; it's scoped to that type signature
08:44:29 <saml> let (^.^) = 1 in (^.^)  how did this work?  ^ is a valid word character?
08:44:41 <EvilTerran> saml, so you can use (~>) instead; some like the visual simularity to (->) because arrows are "like" functions
08:44:48 <dmwit> saml: No, ^ and . are punctuation characters.
08:45:05 <dmwit> saml: ^_^ didn't work because it mixed punctuation and word characters.
08:45:43 <saml> > let (!@#$) = 1 in (!@#!$) -- parenthesized!
08:45:44 <lambdabot>   Not in scope: `!@#!$'
08:45:57 <dmwit> You swore differently in the second part!
08:46:58 <dmwit> Also, I wouldn't be surprised if @ wasn't allowed.
08:47:05 <dmwit> > let (!@#) = 1 in (!@#)
08:47:07 <lambdabot>   1
08:47:10 <dmwit> huh
08:47:14 <EvilTerran> "Not in scope: `!@#!$'" suggests it's allowed
08:47:26 <saml> > let (@) = 1 in (@) -- parenthesized!
08:47:27 <lambdabot>   <no location info>: parse error on input `@'
08:47:39 <EvilTerran> not on its own, though; that's a reserved symbol
08:47:47 <byorgey> > let (x@y) = 1 in x + y
08:47:48 <lambdabot>   2
08:48:23 <EvilTerran> like (->), (\), where, data, etc
08:48:51 <EvilTerran> they fit the shape of a valid name, but the language is keeping it to itself for more nefarious purposes. or something.
08:49:37 <athos> :t (->)
08:49:38 <lambdabot> parse error on input `->'
08:49:49 <dmwit> :k (->)
08:49:50 <lambdabot> ?? -> ? -> *
08:49:53 <dmwit> ??
08:49:56 <athos> :>
08:49:57 <dmwit> ???*
08:53:15 <maltem> dmwit: ghc-style kinds must be explained somewhere in the manual
08:53:26 <dmwit> Oh, I know what it means.
08:53:33 <dmwit> I know enough for my purposes, anyway.
08:53:43 <dmwit> It just makes me chuckle. =)
08:53:51 <maltem> oh I thought ??? stood for "??"?
08:54:00 <dmwit> =)
08:57:26 <Gracenotes> @unpl (\f -> f . f)
08:57:27 <lambdabot> (\ f c -> f (f c))
08:57:39 <Gracenotes> @pl (\f -> f . f)
08:57:40 <lambdabot> join (.)
08:57:50 <Gracenotes> ah...m.
08:58:18 <EvilTerran> Gracenotes, i'd just write "twice f = f . f" somewhere instead
08:58:29 <dmwit> Gracenotes: Think about what join means in the Reader monad.
08:58:43 <EvilTerran> ?type join
08:58:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:59:16 <Gracenotes> EvilTerran: I don't actually need the function, but @un/pl has many weird insights
08:59:23 <dmwit> join f = do { g <- f; g }
08:59:39 <opqdonut> i think (>>= id
08:59:41 <opqdonut> )
08:59:46 <opqdonut> is the nicest definition
09:00:00 <dmwit> opqdonut: That's what I wrote. ;-)
09:00:17 <Gracenotes> f >>= \g -> g
09:00:28 <SamB_XP> @undo do { g <- f; g }
09:00:29 <lambdabot> f >>= \ g -> g
09:00:29 <opqdonut> dmwit: indeed
09:00:49 <Gracenotes> so, join in the reader monad. hm.
09:00:54 <SamB_XP> @undo \f -> do { g <- f; g }
09:00:54 <lambdabot> \ f -> f >>= \ g -> g
09:00:59 <SamB_XP> @. pl undo \f -> do { g <- f; g }
09:01:00 <lambdabot> join
09:01:02 <dmwit> ?src (->) (>>=)
09:01:02 <lambdabot> f >>= k = \ r -> k (f r) r
09:01:10 <SamB_XP> oh rats
09:01:12 <SamB_XP> overdid it!
09:01:22 <Gracenotes> @src Reader (>>=)
09:01:23 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:01:26 <Gracenotes> so they say
09:01:36 <dmwit> f >>= id = \r -> id (f r) r = \r -> (f r) r = \r -> f r r
09:01:55 <dmwit> Gracenotes: (->) is ?src's name for Reader, so my query above gives the source you're looking for.
09:01:55 <Gracenotes> yep :)
09:02:27 <Gracenotes> dmwit: ...distinct from the actual Reader monad?
09:02:33 <dmwit> join (.) = \f -> (.) f f = \f -> f . f
09:02:50 <dmwit> Gracenotes: No, Reader e is just a type synonym for (e ->).
09:02:59 <dmwit> ?unmtl Reader e a
09:03:00 <lambdabot> e -> a
09:03:05 <Gracenotes> @src ask
09:03:06 <lambdabot> Source not found. Just try something else.
09:03:20 <maltem> Wait, isn't Reader newtyped?
09:03:24 <dmwit> might be
09:03:32 <maltem> @src Reader
09:03:33 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:03:34 <Gracenotes> yeah, I've used join for function application before... didn't realize it was the Reader
09:03:36 <CakeProphet> believe it is
09:03:37 <byorgey> it is.
09:03:39 <EvilTerran> , src ''Reader
09:03:44 <lunabot>  newtype Reader r a = Reader {runReader :: (r -> a)}
09:03:56 <Gracenotes> ask = Reader id
09:04:05 <Gracenotes> local f c = Reader $ \e -> runReader c (f e)
09:04:08 <dmwit> Okay, then Reader e is a *newtype* synonym for (e ->). =)
09:04:26 <leimy> so it's not interchangeable  :-)
09:04:38 <dmwit> Gracenotes: If you just strip the Reader/runReader bits, you get "ask = id" and "local = flip (.)".
09:04:41 <leimy> or rather, the compiler will holler at you :-)
09:04:49 <dmwit> leimy: yeah
09:05:01 <asortic> Enter text here...
09:05:03 <dmwit> leimy: Luckily, we have a Monad instance for the unwrapped version, too. =)
09:05:03 <asortic> hi
09:05:04 <Gracenotes> *blinks*
09:05:14 <leimy> dmwit: yep
09:05:16 <dmwit> asortic: Hiya!
09:05:42 <asortic> 0131 am kenan turkey ankara
09:05:44 <imphasing> Ugh, I can't seem to wrap my head around foldr.. I get foldl just fine. Is there a good explaination somewhere?
09:05:44 <Gracenotes> runReader seemed suspiciously familiar to function application...
09:05:54 <imphasing> I understand what it DOES, but I'm trying to get how it does it.
09:06:03 <leimy> imphasing: http://foldr.org
09:06:09 <Gracenotes> except the whole phrase to be evaluated can wait until the parameter(s) are actually supplied
09:06:13 <leimy> er
09:06:17 <leimy> imphasing: http://foldr.com
09:06:24 <leimy> vs http://foldl.com
09:06:27 <maltem> > foldr f a [b,c,d] :: Expr
09:06:29 <lambdabot>   f b (f c (f d a))
09:06:42 <thoughtpolice> imphasing: http://en.wikipedia.org/wiki/Fold_(higher-order_function)
09:06:47 <maltem> > foldl f a [b,c,d] :: Expr
09:06:49 <lambdabot>   f (f (f a b) c) d
09:07:05 <maltem> imphasing: this is the explanation, basically ;)
09:07:33 <imphasing> I understand what it is the fold functions do, but how foldr works differently from foldl is a mystery to me
09:07:38 <dmwit> http://haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
09:07:44 <leimy> imphasing: I think they just showed you
09:07:57 <asortic> maltem< trkmsn
09:08:08 <imphasing> leimy, ooh, I missed that part
09:08:08 <maltem> @ops
09:08:09 <lambdabot> Maybe you meant: docs oeis pl
09:08:11 <asortic> aran0131zda trk olan varm0131
09:08:12 <imphasing> interested..
09:08:14 <maltem> @where ops
09:08:14 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
09:08:18 <imphasing> er, interesting
09:08:31 <enticingjelly> best way to quickly publish the source code of a haskell project (multiple files) online, with syntax highlighting (possibly using hscolour)?
09:08:38 <Gracenotes> imphasing: foldl can evaluate a term, combine it with the next time, evaluate that, etc.
09:08:45 <maltem> imphasing: the Expr things above are perhaps a little easier if I write + instead of f, that is:
09:08:51 <Gracenotes> generally you have to expand the entire foldr before you can ever consider evaluating it
09:08:52 <dmwit> enticingjelly: haddock
09:08:55 --- mode: ChanServ set +o allbery_b
09:09:16 <Gracenotes> *even
09:09:17 <enticingjelly> dmwit, good idea, might as well use that. thanks.
09:09:19 <imphasing> Gracenotes, Aaah...
09:09:22 <maltem> imphasing: foldl f a [b,c,d] = ((a+b)+c)+d
09:09:24 <dmwit> Gracenotes: I think you've got that backwards.
09:09:28 <allbery_b> that didn't take long...
09:09:29 <imphasing> I think I somewhat get whart you mean
09:09:30 <Gracenotes> oh, do I? heh
09:09:43 <maltem> imphasing: foldr f a [b,c,d] = b+(c+(d+a))
09:09:59 --- mode: allbery_b set -o allbery_b
09:10:05 <Gracenotes> dmwit: I'm pretty sure I have it the right way 'round
09:10:10 <wjt> they work out being the same if f is associative and strict in both arguments
09:10:23 <dmwit> > foldr (||) False [True, undefined] -- Gracenotes, you don't have to expand the whole thing
09:10:24 <lambdabot>   True
09:10:31 <maltem> imphasing: of course, if (+) is just addition, those are equivalent, because addition is commutative and strict
09:10:43 <imphasing> maltem, Right
09:10:50 <dmwit> > foldl (||) False [True, undefined] -- definitely does have to expand the whole thing
09:10:51 <lambdabot>   True
09:10:55 <wjt> oh i suppose commutativity matters too because the zero's on different ends
09:10:55 <Gracenotes> dmwit: yes, that's true. In the case of arithmetic operations, though, not so much
09:10:57 <imphasing> Why does it look like foldr is going from the left in that example?
09:11:19 <wjt> http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg
09:11:30 <imphasing> in  foldr f a [b,c,d] = b+(c+(d+a)), 'b' is the leftmost element..
09:11:31 <EvilTerran> imphasing, the left is at the "outside" of the recursion
09:11:32 <dmwit> Gracenotes: Right, for strict operations, foldl' is preferable.
09:11:36 <maltem> oh I neglected associativity ...
09:11:42 <dmwit> Gracenotes: But strict operations are the exception in Haskell...
09:11:46 <imphasing> EvilTerran, Oh, okay
09:12:33 <maltem> imphasing: if you were to calculate the result, given some numbers, you'd start with d+a, which is "on the right"
09:13:02 <imphasing> maltem, Yeah, I see that now
09:13:04 <imphasing> Cool :)
09:13:06 <imphasing> Thanks guys.
09:13:26 <maltem> imphasing: although indeed, in a lazy setting, you usually want to start evaluating on the left :)
09:14:43 <Gracenotes> hm, you could probably do Peano arithmetic with foldl and foldr
09:15:08 <Gracenotes> somehow ;)
09:15:10 <dmwit> :t [()]
09:15:11 <lambdabot> [()]
09:15:50 <dmwit> Gracenotes: (++) is addition, (>>) is multiplication
09:15:56 <enticingjelly> haddock -h -o haddock *.hs
09:15:56 <enticingjelly> Fishbowl.hs:"Fishbowl.hs": 30:26: Parse error
09:15:59 <enticingjelly> uh. waht.
09:16:18 <Gracenotes> Haddock is delicious
09:16:46 <dmwit> > let unPeano = length; peano = flip replicate (); (+) = (++); (*) = (>>) in unPeano (peano 3 * (peano 4 + peano 1))
09:16:47 <lambdabot>   15
09:17:16 <enticingjelly> haddock --version
09:17:17 <enticingjelly> Haddock version 0.8, (c) Simon Marlow 2006
09:17:22 <enticingjelly> wow. that ubuntu package is REALLY old.
09:17:38 <dmwit> wow
09:17:50 <dmwit> That's more than two years old!
09:17:53 <enticingjelly> plus, there's no cabal-install tool package in ubuntu. ubuntu is not haskell-friendly.
09:17:59 <dmwit> That's like... 35 in computer years.
09:18:07 <enticingjelly> dmwit, yes, and the current version is something like 2.3.0
09:18:16 <dmwit> 2.4.1 according to the haddock website
09:18:19 <CakeProphet> > let flipper v1 v2 s = (v1, State (flipper v2 v1)); showState s = let (v,newstate) = runState s in v:(showState s) in showState (State (flipp 0 1))
09:18:20 <lambdabot>   Not in scope: `flipp'
09:18:25 <CakeProphet> ...rofl
09:18:25 <enticingjelly> no wonder it has problems accepting my sources. it assumes they are written in an ancient language of the past.
09:18:29 <CakeProphet> > let flipper v1 v2 s = (v1, State (flipper v2 v1)); showState s = let (v,newstate) = runState s in v:(showState s) in showState (State (flipper 0 1))
09:18:30 <lambdabot>   Couldn't match expected type `(t, t1)'
09:19:50 <CakeProphet> > let flipper v1 v2 s = (v1, State (flipper v2 v1)); showState s = let (v,newstate) = runState s in v:(showState newstate) in showState (State (flipper 0 1))
09:19:51 <lambdabot>   Couldn't match expected type `(t, t1)'
09:19:54 <CakeProphet> :(
09:20:06 <CakeProphet> :t runState
09:20:07 <lambdabot> forall s a. State s a -> s -> (a, s)
09:21:03 <dmwit> CakeProphet: You probably want to call flipper with all its arguments.
09:21:11 <dmwit> CakeProphet: And give a value.
09:21:29 <paper_cc> CakeProphet: look at evalState and execState
09:21:30 <CakeProphet> dmwit:  in flipper or in the top-level code?
09:21:32 <paper_cc> :t evalState
09:21:33 <dmwit> flipper v1 v2 s = State v1 (flipper v2 v1 s) -- or something like that
09:21:33 <lambdabot> forall s a. State s a -> s -> a
09:21:38 <dmwit> :t State
09:21:39 <paper_cc> :t execState
09:21:40 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:21:41 <lambdabot> forall s a. State s a -> s -> s
09:21:52 <dmwit> oh
09:21:57 * dmwit rereads
09:21:58 <CakeProphet> I thought State took a function.
09:22:18 <leimy> >t runState
09:22:25 <leimy> :t runState
09:22:26 <lambdabot> forall s a. State s a -> s -> (a, s)
09:22:33 <CakeProphet> oh...
09:22:50 <dmwit> CakeProphet: It does, but not the function you wrote. =)
09:22:51 <leimy> :t State
09:22:52 <lambdabot> forall s a. (s -> (a, s)) -> State s a
09:23:11 <leimy> It writes the function :-)
09:23:12 <dmwit> CakeProphet: The function doesn't return (a, State s a), but (a, s).
09:23:14 <leimy> or something.
09:23:27 <enticingjelly> nested states.
09:23:27 <CakeProphet> dmwit:  ...so wait.
09:23:30 <enticingjelly> that'd be fun.
09:23:34 <CakeProphet> what is the difference in a and s?
09:23:44 <leimy> enticingjelly: use StateT and nest them :-)
09:23:46 <dmwit> CakeProphet: 'a' is the "return" value, 's' is the state.
09:23:55 <CakeProphet> dmwit:  ...isn't State the... state?
09:23:58 <enticingjelly> oh yes. fun. nest several StateT with the *same* state type
09:24:00 <leimy> :t runStateT
09:24:02 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
09:24:02 <enticingjelly> lift randomly
09:24:16 <dmwit> CakeProphet: No, State is a type constructor.
09:24:19 <enticingjelly> CakeProphet, nope, State's the state monad.
09:24:32 <CakeProphet> hmmm...
09:24:42 <CakeProphet> I'd need to see an example to figure out how it works.
09:24:42 <paper_cc> CakeProphet: it's monad that holds "something and state", a is something, s is state.
09:25:00 <dmwit> > let flipper = do { (a, b) <- get; put (b, a); return a }; showState s = let (v, s') = runState flipper s in v : showState s' in showState (5, 0)
09:25:02 <lambdabot>   [5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,...
09:25:20 <leimy> The State monad implements >>= and return, plus a couple accessor functions, that allows you to thread state through a computation, without having to worry about the threading of the state bit :-)
09:25:30 <leimy> State is a behavior
09:25:33 <leimy> not a "thing" :-)
09:25:53 <leimy> Maybe it should be called Stateful :-)
09:26:09 <CakeProphet> dmwit:  what are get and put?
09:26:15 <leimy> :t get
09:26:16 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
09:26:20 <enticingjelly> CakeProphet, that's how you query and manipulate the state.
09:26:23 <Badger> @src get
09:26:24 <lambdabot> Source not found. You untyped fool!
09:26:28 <dmwit> > let flipper = do { (a, b) <- get; put (b, a); return a }; iterateM m = liftM2 (:) m (iterateM m) in runState (iterateM flipper) (5, 0)
09:26:30 <lambdabot>   ([5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5,0,5...
09:26:35 <newsham> ?seen vixey
09:26:36 <lambdabot> vixey is in #scala, #perl6, ##logic and #haskell. I last heard vixey speak 1h 54m 47s ago.
09:26:42 <Gracenotes> get   = State $ \s -> (s,s)
09:26:44 <Gracenotes> put s = State $ \_ -> ((),s)
09:27:02 <Gracenotes> the internals are a /bit/ messy :)
09:27:03 <CakeProphet> oh okay.
09:27:26 <leimy> get basically takes the state part of the Stateful computation and shoves it where the value would go
09:27:34 <leimy> so when you do  "blah <- get"
09:27:49 <leimy> you get the state and not the current contained value of the Stateful computation.
09:27:52 <CakeProphet> see I thought the state function returned a tuple, the first being the return value of that state, and the second one being the next State monad
09:28:18 <leimy> CakeProphet: right but the dirty details about how that gets threaded are in >>= and return :-)
09:28:25 <dmwit> Right, so it actually just returns the next state.
09:28:39 <dmwit> Then (>>=) takes care of threading the current state for you.
09:28:41 <leimy> You have to look at >>= to understand what behavior the monad is implementing.
09:28:51 <Gracenotes> blah <- get is the same as (get >>= (blah -> everything else)). So blah is now available as the state to whatever needs it in "everything else"
09:29:03 <dmwit> Needs more lambda.
09:29:08 <leimy> yes
09:29:08 <dmwit> get >>= \blah -> ...
09:29:11 <Gracenotes> just a backslash ;)
09:29:22 <leimy> (get >>= (\blah -> everything else))
09:29:40 <leimy> but now you have access to blah!
09:29:41 <leimy> :-)
09:29:45 <Badger> :t (<-)
09:29:46 <lambdabot> parse error on input `<-'
09:29:57 <dmwit> I'm not sure how good the correspondence between do blocks and (>>=)/return works as explanatory text, though.
09:30:12 <dmwit> You can understand that correspondence without understanding monads in any significant way.
09:30:13 <CakeProphet> I don't really understand... but yeah.
09:30:15 <Gracenotes> so if the first thing you do in the state monad is blah <- get, then what you start out with is State $ \s -> (s,s)
09:30:27 <Gracenotes> that doesn't really mean anything until you actually *pass* something to be the s
09:30:39 <CakeProphet> I'm having a hard time distinguish what "return value" and "state are... because I always think of them as the same thing
09:30:40 <Gracenotes> you can do that with runState yourStateMonad initialState
09:30:46 <dmwit> CakeProphet: It might help to strip the State/runState constructors and think about how you would do this without monads.
09:31:03 <CakeProphet> ....I would use an infinite list.
09:31:07 <leimy> CakeProphet: return puts a value into a State computation
09:31:17 <CakeProphet> leimy:  I'm aware.
09:31:36 <leimy> return and put are like buddies who set different parts of the tuple :-)
09:31:43 <dmwit> CakeProphet: Let's say you wanted to keep track of how many times a particular function was called.
09:31:56 <Gracenotes> CakeProphet: the sources are on this page: http://www.haskell.org/all_about_monads/html/statemonad.html
09:32:07 <Gracenotes> You can try, if you like, translating something like do { x <- get; put (x+1); return x}
09:32:07 <leimy> Monads are a little weird, they're all about overloaded behaviors.
09:32:15 <CakeProphet> dmwit:  oh... excellent example. Something I don't know how to do.
09:32:19 <leimy> or rather an overloaded language
09:32:21 <CakeProphet> a reason for me to use State.
09:32:25 <Gracenotes> first take it out of the do notation, then replace all the >>='s and returns
09:32:30 <Gracenotes> etc.
09:32:51 <Gracenotes> then see what happens when you do runState .. 5 on it
09:32:54 <dmwit> CakeProphet: One reasonable approach is have the function take an extra parameter that tells how many times it's been called in the past, and return an extra parameter telling the new call count (which might be bigger by more than one thanks to recursion).
09:33:13 <dmwit> CakeProphet: So if you started with a function f :: a -> b, under this transformation, you'd now have a function f :: a -> Int -> (b, Int).
09:33:32 <dmwit> CakeProphet: With me so far?
09:33:36 <CakeProphet> dmwit:  noep.
09:33:42 <dmwit> no?
09:33:45 <dmwit> Okay.
09:33:49 <CakeProphet> like how I had v1 and v2 in flipper?
09:33:58 <CakeProphet> but now it's a count
09:34:03 <dmwit> Similar, but now it's a... yeah.
09:34:12 <CakeProphet> what's the second parameter?
09:34:24 <CakeProphet> the count?
09:34:45 <dmwit> f :: a {- the input of the original function -} -> Int {- how many times we've already been called -} -> (b {- the original output -}, Int {- the new call count -})
09:35:05 <CakeProphet> ah
09:35:50 <CakeProphet> so then b is the return value of the regular computation, and Int is a state that's attached to it - in this case a count of how many times the function was called.
09:36:04 <dmwit> Exactly right!
09:36:30 <CakeProphet> so with partial application... you could start the count at 0 and use it exactly like you would use the original function.
09:36:46 <CakeProphet> except it keeps returning this new function so that the count gets appended or whatever.
09:36:47 <dmwit> Not quite exactly like.
09:36:51 <CakeProphet> ...oh
09:36:53 <CakeProphet> ...
09:36:54 <CakeProphet> alright then.
09:36:59 <dmwit> Since the return type is different now, right?
09:37:06 <CakeProphet> yeah
09:37:09 <dmwit> You have to manually catch the new call count and deal with it.
09:37:13 <dmwit> So, imagine:
09:37:41 <CakeProphet> that's what bugs me about monads. You have to deal with the details everytime you use them. There's no transparency.
09:37:46 <dmwit> We have two functions like that: "f :: a -> Int -> (b, Int)" and "g :: b -> Int -> (c, Int)", where 'b' is the same in the two types.
09:38:29 <dmwit_> CakeProphet: We have two functions like that: "f :: a -> Int -> (b, Int)" and "g :: b -> Int -> (c, Int)", where 'b' is the same in the two types.
09:38:34 <dmwit_> Before the transform, we could have just written g . f to sequence them.
09:38:38 <dmwit_> But now we can't, right?
09:38:46 <dmwit_> How would we sequence them now?
09:38:50 <CakeProphet> hmmm...
09:38:56 <CakeProphet> magic!
09:39:08 <dmwit> Not magic! =)
09:39:11 <CakeProphet> or... bind maybe?
09:39:32 <dmwit> Okay, what would bind look like?
09:39:56 <dmwit> I'll write the hard part:
09:40:00 <dmwit> bind f g a =
09:40:25 <Botje> unsafePerformMagic ?
09:40:50 <CakeProphet> State "f >>= g"   ?
09:40:51 <dmwit> CakeProphet: It might be a good idea to figure out what type we want the "composition" of f and g to have in the end first.
09:41:02 <CakeProphet> oh.
09:41:02 <dmwit> CakeProphet: Let's ignore State for now.
09:41:09 <dmwit> CakeProphet: We'll talk about how they correspond later.
09:41:22 <dmwit> CakeProphet: i.e. let's just do this with pure functions.
09:41:34 <dmwit> CakeProphet: Then we'll see how State makes our lives much easier. =)
09:41:44 <lilac> @djinn (int -> (a, int)) -> (a -> int -> (b, int)) -> int -> (b, int)
09:41:45 <lambdabot> f a b c =
09:41:45 <lambdabot>     case a c of
09:41:45 <lambdabot>     (d, e) -> b d e
09:43:00 <dmwit> CakeProphet: (Incidentally, this exposition is based almost entirely on sigfpe's excellent "You Could Have Invented Monads" article.)
09:43:20 <pumpkin> (don't cheat though!)
09:43:51 <CakeProphet> ...I have no clue.
09:44:04 <dmwit> Okay.
09:44:04 <Gracenotes> dmwit: did that article cover function counters?
09:44:20 <dmwit> Gracenotes: It's not likely that I'm using the same example.  Just the same approach.
09:44:34 <dmwit> CakeProphet: What is the type of the composition that we want to have?
09:44:50 <dmwit> oldF . oldG :: a -> c
09:44:51 <CakeProphet> a -> c?
09:44:56 <dmwit> Close.
09:45:01 <dmwit> But we still want to do the counter thing.
09:45:04 <CakeProphet> oh... uh
09:45:11 <Gracenotes> dmwit: it seems the whole \s -> (a, s) thing seems a bit clearer with something as simple as counting ;)
09:45:13 <CakeProphet> a -> (c,Int)?
09:45:27 <CakeProphet> a -> Int -> (c,Int)?
09:45:28 <dmwit> CakeProphet: Closer.
09:45:29 <CakeProphet> ...
09:45:30 <lilac> who's going to be doing the counting? the function or bind?
09:45:31 <dmwit> Yeah!
09:45:34 <dmwit> CakeProphet: That's it.
09:45:40 <dmwit> lilac: yes
09:45:51 <dmwit> =)
09:45:54 <CakeProphet> rofl... yes? THAT IS NOT AN ANSWER TO THAT QUESTION.
09:46:15 <CakeProphet> </cruise control>
09:46:17 <idnar> mu!
09:46:23 <dmwit> CakeProphet: Okay, so (f `o` g) :: a -> Int -> (c, Int).
09:46:29 <dmwit> CakeProphet: We can work with that!
09:46:31 <idnar> caps lock is cruise control for constructors?
09:46:32 <lilac> dmwit: if it's bind, then 'return' needs to be \a n -> (a, n-1) (!)
09:47:02 <dmwit> lilac: Oh, yeah, I think it's easiest if it's just the function.
09:47:08 <dmwit> lilac: We're modelling State here.
09:47:13 <lilac> ... and join needs to be even weirder.
09:47:30 <dmwit> lilac: You might not even get a monad the way you're going there.
09:47:41 <dmwit> CakeProphet: So, let's write the "o" function.
09:47:48 <dmwit> o f g a n = ...
09:48:01 <CakeProphet> n is the count... a is the input?
09:48:04 <dmwit> right
09:48:08 <lilac> dmwit: i think the monad you get is isomorphic to State, actually :)
09:48:41 <CakeProphet> o f g a n = let (b,n2) = f a n in g b n2
09:48:46 <dmwit> lilac: That doesn't sound right.  Then you're counting the number of times (>>=) is called, not the number of times the function is called.
09:48:55 <dmwit> CakeProphet: Perfect!
09:49:16 <dmwit> CakeProphet: Okay, one last exercise, then we'll take a look at the implementation of State.
09:49:38 <dmwit> CakeProphet: Now I have a modifier that is going to "act like" a function call, but without actually calling a function.
09:49:46 <dmwit> incr :: Int -> ((), Int)
09:49:55 <dmwit> It doesn't return anything, but it changes the call count.
09:50:16 <dmwit> If I wanted to use incr and f together, how would that look?
09:50:26 <dmwit> Just for fun, let's call the function we're writing (>>=).
09:50:35 <CakeProphet> ...
09:50:58 <pumpkin> professor dmwit!
09:51:11 <CakeProphet> f is "old f"?
09:51:12 <dmwit> (>>=) :: (Int -> (a, Int))    ->    (a -> Int -> (b, Int))    ->    (Int -> (b, Int))
09:51:14 <lilac> dmwit: you're counting the number of times which (>>=) is called, minus the number of times return is called. that /could/ be useful, depending on what other primitives your type provides :)
09:51:17 <CakeProphet> oh
09:52:06 <dmwit> (>>=) incr f n = ...
09:52:21 <polveroj> is there an easy way to see the fixity of a operator in ghci, or do you have to dig in the source?
09:52:26 <dmwit> polveroj: :i
09:52:27 <pumpkin> :o
09:52:31 <pumpkin> whoops
09:52:45 <polveroj> dmwit: thanks
09:54:12 <dmwit> CakeProphet: Whatcha thinkin?
09:54:40 <CakeProphet> hmmm
09:54:56 <CakeProphet> have we given f an input yet?
09:55:11 <dmwit> We haven't done anything yet.
09:55:40 <CakeProphet> well.. what is n?
09:55:59 <dmwit> It's the count before either incr or f happens.
09:56:14 <dmwit> We want incr to "happen" first, then f.
09:56:48 <CakeProphet> well it looks like the first argument of f gets partially applied, based on type signature.
09:56:52 <CakeProphet> and that's the return function.
09:57:15 <dmwit> That sounds like a start.  How would it look?
09:58:08 <noZone1> Is there a standard operator/function defined for something like this:    (?|) :: Bool -> (a, a) -> a         (?|) i (t, e) = if i then t else e
09:58:19 <dmwit> noZone1: no
09:58:35 <noZone1> Thanks
09:58:41 <beelsebob> that definition was fine
09:58:46 <beelsebob> but it's a rather odd deff
09:59:14 <CakeProphet> dmwit:  I don't understand where I get a from though... no input has been supplied.
09:59:15 <beelsebob> I wouldn't curry the arguments
09:59:26 <dmwit> noZone1: You can also write it as "i ?| (t, e) = if i then t else e".
09:59:39 <Twey> (i ?! t) e = if i then t else e
09:59:40 <beelsebob> >let (?!) i t e = if i then t else e in True ?! 5 10
09:59:46 <dmwit> CakeProphet: Oh, sorry, I pulled a bait-and-switch on you.
09:59:47 <beelsebob> > let (?!) i t e = if i then t else e in True ?! 5 10
09:59:48 <lambdabot>       Overlapping instances for Show (t -> t)
09:59:48 <lambdabot>        arising from a use of `s...
10:00:07 <CakeProphet> dmwit:  lolwhuit
10:00:10 <noZone1> It sort-of harkens back to the old conditional expressions in perl and others blah ? expr : expr
10:00:11 <Twey> > let (i ?! t) e = if i then t else e in True ?! 3 4
10:00:11 <dmwit> CakeProphet: I started with "incr :: Int -> ((), Int)", then wrote (>>=) as if "incr :: Int -> (a, Int)".
10:00:12 <lambdabot>       Overlapping instances for Show (t -> t)
10:00:12 <lambdabot>        arising from a use of `s...
10:00:19 <Twey> > let (i ?! t) e = if i then t else e in (True ?! 3) 4
10:00:20 <lambdabot>   3
10:00:21 <dmwit> CakeProphet: So, get your 'a' from incr.
10:00:22 <beelsebob> cheers twadleigh
10:00:25 <beelsebob> Twey: too
10:00:37 <dmwit> CakeProphet: I'll repeat the type of (>>=), since there's been a bit of noise since then.
10:00:38 <Twey> beelsebob: Commonly we call it if'
10:00:46 <beelsebob> Twey: I know we do ;)
10:00:47 <Twey> beelsebob: if' a b c = if a then b else c
10:00:48 <beelsebob> he didn't
10:00:51 * Twey nods.
10:01:02 <dmwit> (>>=) :: (Int -> (a, Int))   ->   (a -> Int -> (b, Int))   ->   (Int -> (b, Int))
10:01:25 <CakeProphet> (>>=) incr f n = (\a f a $ fst $ incr n)
10:01:36 <CakeProphet> or something.
10:01:54 <CakeProphet> ...no
10:02:04 <CakeProphet> I'm not sure what the return function does.
10:02:15 <Twey> CakeProphet: Wraps a value in a monad
10:02:26 <dmwit> CakeProphet: The returned function should act as if it were doing "incr" and then "f".
10:02:30 <CakeProphet> ...rofl. "the function this function I'm trying to make yields" rather.
10:02:32 <redditbot> Haskell programming tips/Discussion - HaskellWiki
10:02:50 <dmwit> Twey: Hold that thought, we're almost there. =)
10:02:51 <Twey> E.G. return 3 :: IO Int is 3 wrapped in the IO monad
10:03:07 <CakeProphet> Twey:  I know what /that/ return does
10:03:10 <Twey> return 3 >>= putStrLn . (*2)
10:03:14 <CakeProphet> I meant the function this function yields.
10:03:22 <Twey> Oh, right.
10:03:27 <CakeProphet> habit from other languages, where "return" means the value you yield.
10:03:31 <Twey> The *returned* function
10:03:40 <dmwit> CakeProphet: Okay, try again.  You're pretty close.
10:03:51 <Twey> Strings of $ are bad, BTW.
10:04:03 <dmwit> One thing at a time!
10:04:05 <Twey> Try to keep them to one per expression scope.
10:04:23 * dmwit threatens to move to #haskell-overflow
10:05:07 <noZone> Overflowing with Haskell goodness....
10:05:08 <lilac> noZone: I much prefer "True <?> a = return a; False <?> _ = mzero; Nothing <:> a = a; Just a <:> _ = a"
10:05:11 <Twey> Heh
10:05:18 * Botje threatens to throw sugar lambdas
10:05:27 <dmwit> Sugar!
10:05:28 <maltem> dmwit: not baring the excess of the 600 users mark? :)
10:05:32 <lilac> noZone: not least because both parts are useful by themselves
10:05:51 <dmwit> ?users
10:05:52 <lambdabot> Maximum users seen in #haskell: 645, currently: 641 (99.4%), active: 14 (2.2%)
10:05:55 <pumpkin> oh wow, we have a lot of users today
10:05:57 <dmwit> Yowza!
10:06:07 <pumpkin> we overtaken #python yet?
10:06:08 <dmwit> Python's at 697, though.
10:06:14 <noZone> tx lilac
10:06:15 <pumpkin> boo
10:06:22 <dmwit> We took over Python temporarily a few days ago.
10:06:26 <pumpkin> must. spam. more.
10:06:40 <lilac> dmwit: presumably we only overtook it :-)
10:06:47 <dmwit> uh
10:06:48 <dmwit> heh, yeah
10:06:55 * dmwit stages a revolution
10:07:01 * MyCatVerbs spins!
10:07:30 <dmwit> on a stage!
10:08:27 <wchogg> I wonder if Christmas copies of RWH have helped to spark the growth in #haskell?
10:09:23 <Botje> do we have lambda-shaped tree decorations yet?
10:09:26 <Botje> i'd buy those.
10:09:29 <CakeProphet> dmwit:  I don't think I understand what >>= accomplishes
10:10:08 <dmwit> CakeProphet: Well, it "sequences" two actions that simulate function calls.
10:10:25 <dmwit> CakeProphet: For example, remember that `o` function we wrote?
10:10:28 <CakeProphet> dmwit:  ...in this case I mean.
10:10:29 <dmwit> CakeProphet: Here's another implementation:
10:10:42 <dmwit> o f g a = f a >>= g
10:10:52 <dmwit> CakeProphet: Notice that we haven't explicitly mentioned the count anywhere here!
10:11:04 <dmwit> CakeProphet: So (>>=) is somehow hiding that part.
10:11:09 <dmwit> CakeProphet: We just have to figure out how. =)
10:11:18 <Deewiant> o = (>=>), no?
10:11:20 <CakeProphet> hmmm
10:11:22 <dmwit> Deewiant: right
10:11:35 <dmwit> Deewiant: I sneakily named it something else, though. =)
10:11:49 <Deewiant> Yes, you sneaky dmwit, you.
10:12:20 <dmwit> CakeProphet: Let's look at the old implementation of `o` again:
10:12:45 <dmwit> o f g a n = let (b, n2) = f a n in g b n2
10:13:19 <dmwit> CakeProphet: Now, you should notice that the 'a' argument is just sort of hanging out... what if we just erase the 'a' from the whole thing and rename "o" to be (>>=)?
10:13:40 <dmwit> (>>=) f g n = let (b, n2) = f n in g b n2 -- does this have the right type?
10:13:43 <CakeProphet> dmwit:  ...I don't notice that at all.
10:13:48 <noZone> Is there a good non-whitepaper tutorial for Arrows in Haskell suitable for us not-quite-clever-enough to understand dense whitepapers?
10:13:49 <CakeProphet> no
10:13:53 <dmwit> No?
10:13:59 <dmwit> What type does it have?
10:14:02 <CakeProphet> f is (a -> Int -> (b, Int) )
10:14:16 <CakeProphet> but here it's just Int -> (..something)
10:14:20 <dmwit> ah
10:14:30 <dmwit> But if we rename the arguments:
10:14:43 <b_jonas> if I don't understand arrows, is it a bad idea to use the arrow methods ((***) and first) on functions for just manipulating some pairs?
10:14:45 <dmwit> (>>=) incr f n = let (a, n2) = incr n in f a n2 -- the same function as above
10:14:51 <dmwit> b_jonas: no
10:14:55 <dmwit> b_jonas: That's totally fine.
10:15:01 <athos> , src ''State
10:15:06 <dmwit> athos: Hush!
10:15:09 <lunabot>  newtype State s a = State {runState :: (s -> (a, s))}
10:15:13 <athos> ah
10:15:20 <athos> lunabot :>
10:15:24 <b_jonas> are there special variations of those for functions only, like how map is special liftM for lists?
10:15:36 <dmwit> nope
10:15:54 <dmwit> CakeProphet: How far should we back up here?
10:16:16 <CakeProphet> dmwit:  ... a would be () there... but doesn't f want something other than ()?
10:16:35 <dmwit> incr :: Int -> (a, Int)
10:16:52 <CakeProphet> I thought incr increment Int and returned ((), newint)
10:16:54 <dmwit> (We're letting it return something more interesting than () if it wants to.)
10:16:57 <CakeProphet> +ed
10:17:01 <CakeProphet> ...oh
10:17:02 <CakeProphet> ......
10:17:03 <dmwit> We can specialize a to () later.
10:17:53 <athos> dmwit: i wasn't aware that you were just talking about (state) monads :)
10:17:57 <athos> sorry ;)
10:18:01 <dmwit> Oh, okay. =)
10:18:15 <dmwit> I thought you were jumping straight to the punch line and ruining my joke. =)
10:19:31 <CakeProphet> incr is runState... n is the state... what is f?
10:20:07 <dmwit> incr is not runState.
10:20:15 <dmwit> n is the state, f is a stateful function.
10:20:40 <dmwit> incr is a stateful action (no function part)
10:20:45 <CakeProphet> incr is the only function in this example with the same type signature as runState.
10:20:52 <icqn> how to print to the terminal "[x]" where x is a Num, i tried something like(imagine 3 lines): putStr "[" print x putStr "]" ,but i get something line "[\nx]"
10:21:30 <b_jonas> icqn: print adds a newline after the output
10:21:34 <Deewiant> icqn: 'print x' is 'putStrLn (show x)'
10:21:48 <dmwit> CakeProphet: Nevertheless, I assure you that it is not runState.
10:21:57 <Botje> putStrLn ("[" ++ show x ++ "]")
10:22:16 <SamB_XP> icqn: you can use semicolons instead of linebreaks in a do block
10:22:19 <icqn> Deewiant, can i do somehing like putStr (show x) ?
10:22:24 <Deewiant> icqn: indeed you can!
10:22:25 <dmwit> print [x]
10:22:27 <Lemmih> icqn: or: printf "[%d]\n" x
10:22:37 <idnar> @type putStr
10:22:37 <CakeProphet> ...why not just do print [x]..
10:22:38 <lambdabot> String -> IO ()
10:22:41 <b_jonas> Lemmih: ouch
10:22:52 <CakeProphet> or putStr (show [x])  if you prefer.
10:23:05 <icqn> Lemmih, oh really this c style will work too, amazing
10:23:21 <Deewiant> icqn: you have to import Text.Printf to get printf
10:23:27 <Deewiant> but yeah, it works :-)
10:23:40 <CakeProphet> > show ["lol"]
10:23:41 <lambdabot>   "[\"lol\"]"
10:23:53 <dmwit> > show [3]
10:23:54 <lambdabot>   "[3]"
10:24:23 <icqn> nice, thank you people
10:25:14 <CakeProphet> dmwit:  ...then I don't know what you're demonstrating.
10:25:33 <dmwit> CakeProphet: Well, I'll cut to the punch, then.
10:25:35 <dmwit> CakeProphet: If we write
10:25:43 <dmwit> type State s a = s -> (a, s)
10:25:45 <dmwit> then we have
10:26:16 <dmwit> (>>=) :: (Int -> (a, Int)) -> (a -> Int -> (b, Int)) -> (Int -> (b, Int))
10:26:18 <dmwit> becomes
10:26:31 <dmwit> (>>=) :: State Int a -> (a -> State Int b) -> State Int b
10:26:42 <dmwit> That is, (>>=) is exactly the (>>=) for the State monad.
10:27:05 <dmwit> Actually, it's a bit different, because State is a newtype, not a type, so we have to add and remove constructors in the appropriate places.
10:27:10 <dmwit> But if you boil this down:
10:27:14 <dmwit> ?src State (>>=)
10:27:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:27:16 <CakeProphet> right
10:27:19 <dmwit> ?src (>>=) State
10:27:19 <lambdabot> Source not found. You type like i drive.
10:27:21 <dmwit> uh
10:27:21 * CakeProphet has the source
10:27:38 <dmwit> Yeah, what you get is just like what we wrote above, but with State and runState in weird places.
10:28:03 <dmwit> So, in essence, (>>=) is taking care of the state for you, just the way you'd do it yourself if you wanted that kind of thing.
10:28:21 <CakeProphet> ...I don't see how it's helping me at all
10:28:26 <athos> :t (>>=) State
10:28:28 <lambdabot> forall s a b. (State s a -> (s -> (a, s)) -> b) -> (s -> (a, s)) -> b
10:28:38 <dmwit> athos: That's not what you think it is.
10:28:49 <athos> yeah
10:28:52 <dmwit> :t (>>=) :: State s a -> (a -> State s b) -> State s b
10:28:53 <athos> looks kinda weird
10:28:53 <lambdabot> forall s a b. State s a -> (a -> State s b) -> State s b
10:29:04 <dmwit> athos: That's the application of (>>=) to the State constructor.
10:29:08 <Deewiant> :t (>>=) Just
10:29:10 <lambdabot> forall a b. (Maybe a -> a -> b) -> a -> b
10:29:10 <athos> oh
10:29:25 <dmwit> CakeProphet: ...I thought you wanted to know how State worked.
10:29:40 <dmwit> If not, this whole side trip was definitely a waste. =P
10:29:56 <CakeProphet> I do... however, I wanted to know how it worked to determine its usefulness
10:29:59 <Apocalisp> @type (not .)
10:30:00 <lambdabot> forall a. (a -> Bool) -> a -> Bool
10:30:06 <Apocalisp> @type ((not .) .)
10:30:07 <lambdabot> forall a a1. (a1 -> a -> Bool) -> a1 -> a -> Bool
10:30:18 <Apocalisp> can these be expressed as a single combinator?
10:30:19 <dmwit> CakeProphet: Well, it's not useful unless you want stateful computations.
10:30:31 <pumpkin> CakeProphet: you got shown how much of a pain it is without the State monad? :P
10:30:44 <CakeProphet> ...it's the same pain though...
10:30:47 <CakeProphet> just harder to understand.
10:30:48 <pumpkin> it is?
10:31:10 <lilac> CakeProphet: the State monad hides the passing of state from one function to the next
10:31:20 <pumpkin> you don't have to deal with making/taking apart tuples
10:31:27 <pumpkin> or even think about them
10:31:32 <augustss> yo!
10:31:35 <lilac> CakeProphet: it's as if the actions in your 'do' block are secretly passing state from one to the next
10:31:37 <newsham> you might want to think about it still ;-)
10:31:38 <pumpkin> yo!
10:32:28 <lilac> ?users
10:32:28 <lambdabot> Maximum users seen in #haskell: 645, currently: 642 (99.5%), active: 26 (4.0%)
10:33:21 <Deewiant> CakeProphet: instead of "let (b,x1) = f a x0; (c,x2) = g b x1; (d,x3) = h c x2 in foo d" you get to write "runState x0 (do b <- f a; c <- f b; d <- h c; return (foo d))" for instance
10:33:22 <athos> what's was most confusing to me was something like char :: Parser Char. just from looking at the type signature, i thought it returns something of type Parser Char, but in fact Parser Char is some function \s -> (s, a), isn't it?
10:33:26 <Lemmih> Who are all these new Haskell people?
10:33:27 <Deewiant> I think I got that right
10:33:45 <augustss> Lemmih: and why are they so quiet?
10:34:01 <Gracenotes> CakeProphet: as an aside, something that was helpful for me was completely desugaring this:
10:34:03 <lilac> athos: it's both. the nice thing is that you can think of it as 'a parser which produces a Char'
10:34:04 <Gracenotes> > runState (do { x <- get; put (x+1); return x }) 3
10:34:05 <lambdabot>   (3,4)
10:34:06 <EvilTerran> athos, Parser Char will be a monadic action in the Parser monad returning a Char
10:34:28 <EvilTerran> athos, unless you're implementing the Parser monad yourself, anything beyond that is breaking encapsulation
10:34:28 <Gracenotes> CakeProphet: undo the do block; replace all the binds and returns and get and put with the source
10:34:41 <Gracenotes> the source being available here: http://www.haskell.org/all_about_monads/html/statemonad.html
10:34:47 <EvilTerran> athos, you don't need to know what goes on under the hood; that's the point of monads being an abstraction
10:34:55 <Gracenotes> it simplifies down into (x, x+1), as you'd expect
10:35:03 <CakeProphet> dmwit:  in any case, I have to go... I'll figure it out later. Thanks for the explaination though.
10:35:16 <Gracenotes> :>
10:35:22 * lilac suddenly gets the monads-as-adjunctions thing
10:35:22 <newsham> Parser Char is something like  \String -> Either String (Char, String)
10:35:26 <lilac> EvilTerran++
10:35:38 <pumpkin> @karma EvilTerran
10:35:39 <lambdabot> EvilTerran has a karma of 5
10:35:49 <ddarius> lilac: Monad "as" adjunctions?
10:35:52 <cizra> @karma lambdabot
10:35:53 <lambdabot> lambdabot has a karma of 1
10:36:06 <pumpkin> lambdabot++
10:36:42 <athos> @karma lambdabot
10:36:42 <lambdabot> lambdabot has a karma of 2
10:37:24 <cizra> lambdabot--
10:37:24 <cizra> @karma lambdabot
10:37:25 <lambdabot> lambdabot has a karma of 1
10:37:27 <cizra> lambdabot--
10:37:28 <cizra> @karma lambdabot
10:37:28 <lambdabot> lambdabot has a karma of 0
10:37:30 <lilac> ddarius: in the sense that every monad arises from some adjunction (often with one of the functors mapping us into a more structured category, and the other removing that structure)
10:37:33 <cizra> hmm, can it go negative?
10:37:35 <cizra> lambdabot--
10:37:37 <Deewiant> yep
10:37:37 <cizra> @karma lambdabot
10:37:37 <lambdabot> lambdabot has a karma of -1
10:37:40 <pumpkin> :(
10:37:43 <cizra> Oh my!
10:37:43 <Deewiant> cizra--
10:37:46 <Deewiant> @karma cizra
10:37:47 <lambdabot> cizra has a karma of -1
10:37:48 <Deewiant> see? :-P
10:37:52 <newsham> cizra--
10:37:54 <cizra> *nod* I indeed see
10:38:02 <newsham> lambdabot++
10:38:26 <oklopol> oklopol++
10:38:33 <oklopol> @karma oklopol
10:38:33 <lambdabot> You have a karma of 0
10:38:35 <lilac> ddarius: to the extent that, when a strong abstraction is applied, the monadic object becomes in some sense indistinguishable from real objects in that other category
10:38:36 <oklopol> :O
10:38:36 <cizra> :-p
10:38:39 <oklopol> WHAT
10:38:53 <oklopol> > "oklopol++"
10:38:55 <lambdabot>   "oklopol++"
10:38:58 <ddarius> lilac: There is not a -one-to-one- correspondence between monads and adjunctions.
10:39:01 <oklopol> hmph
10:39:03 <Deewiant> preflex: karma oklopol
10:39:03 <preflex>  karma for oklopol: 1
10:39:13 <oklopol> \o/
10:39:14 <Deewiant> > "oklopol++"
10:39:16 <lambdabot>   "oklopol++"
10:39:16 <Deewiant> preflex: karma oklopol
10:39:17 <preflex>  karma for oklopol: 1
10:39:20 <oklopol> hmm.
10:39:25 <oklopol> err.
10:39:25 <Deewiant> just wondering if it came from that :-P
10:39:26 <cizra> OK, now everyone starts creating alter egos to bump their karma…
10:39:29 <oklopol> oklopol++
10:39:36 <Deewiant> preflex: karma oklopol
10:39:37 <preflex>  oklopol has no karma
10:39:41 <Deewiant> O_o
10:39:44 <oklopol> ...err
10:39:47 <noalterego> ?karma+ dmwit
10:39:48 <lambdabot> dmwit's karma raised to 2.
10:39:48 <lilac> ddarius: right. but every monad can be decomposed as an adjunction (possibly [always?] in many ways)
10:39:55 <oklopol> oklopol++
10:39:58 <oklopol> one more test
10:40:01 <dmwit> cizra: Nothing so complicated is necessary.
10:40:03 <oklopol> preflex: karma oklopol
10:40:03 <preflex>  karma for oklopol: 1
10:40:06 <psnively> Happy New Year!
10:40:07 <oklopol> err k...
10:40:09 <oklopol> i don't get it,
10:40:15 <cizra> dmwit: hah
10:40:19 <ddarius> lilac: There may be "essentially" only one way, but yes, in multiple ways in general.
10:40:26 <dmwit> oklopol: You can't raise your own karma.
10:40:29 <dmwit> ?karma+ dmwit
10:40:30 <lambdabot> You can't change your own karma, silly.
10:40:30 <oklopol> psnively: how many times around the globe from me do you live??
10:40:32 <cizra> oklopol: can raise own karma like dmwit did
10:40:33 <dmwit> oklopol: see?
10:40:42 <oklopol> *-?
10:40:59 <lilac> ddarius: do there exist monads with multiple corresponding adjunctions which aren't essentially equivalent?
10:40:59 <psnively> oklpoi: I'm not sure I understand the question. :-)
10:41:00 <oklopol> i was just wondering why it went up, then down, then up
10:41:09 <ddarius> lilac: Of course.
10:41:12 <oklopol> psnively: well, you know, i had ny ages ago
10:41:14 <lilac> ddarius: note, i have no idea what essentially equivalent means precisely here :)
10:41:26 <psnively> Ah, right. I'm just now back at work after mine. :-D
10:41:40 <oklopol> other side of globe has 12 hours time diff, you have 5 day diff, so.
10:41:41 <dmwit> oklopol: Because you were looking at two different bots.
10:41:50 <dmwit> oklopol: preflex and lambdabot are in no way synchronized
10:41:50 <ddarius> lilac: Isomorphic in the category of adjunctions would be one notion.
10:41:54 <dmwit> ?karma oklopol
10:41:54 <lambdabot> oklopol has a karma of 0
10:41:57 <dmwit> preflex: karma oklopol
10:41:58 <preflex>  karma for oklopol: 1
10:42:00 <oklopol> dmwit: no no, i think preflex changed its opinion too
10:42:08 <oklopol> but maybe i'm just seeing things
10:42:23 <oklopol> 1 -> 0 -> 1
10:42:26 <oklopol> oklopol++
10:42:31 <oklopol> preflex: karma oklopol
10:42:31 <preflex>  oklopol has no karma
10:42:33 <oklopol> -> 0
10:42:51 <psnively> I'm being quite a bit less formal than that. :-)
10:43:08 <lilac> ddarius: what are the arrows in that category?
10:43:18 <ddarius> lilac: Morphisms of adjunctions.
10:43:31 <oklopol> psnively: i understand that, just joking around because i'm feeling lazy
10:43:55 <psnively> Oh, no worries--I thought it was a good question! I forget that I've been on vacation for a bit. :-D
10:44:17 <psnively> First day back at work, so New Year's was yesterday, right? ;-)
10:44:25 <lilac> ddarius: isn't 'morphism' a synonym for 'arrow' in this context?
10:44:50 <psnively> Isn't "morphism" always a synonym for "arrow" in category theory?
10:44:59 <psnively> Or did I just repeat the question?
10:45:06 <ddarius> lilac: Well yes.  That answer is kind of vacuous, but there is a notion of morphism for adjunction and that is what it is called.
10:45:08 <lilac> psnively: yes, that's what i was asking :)
10:45:10 <psnively> That is, was my question an isomorphism?
10:45:15 <ddarius> lilac: It's just two functors that make the obvious diagrams commute.
10:45:22 <lilac> psnively: what are the arrows in the category of questions?
10:45:31 <Tordek> why doesn't let maximum' = foldl1 max work?
10:45:35 <lilac> morphisms of questions, obviously
10:45:49 <maltem> :t foldl1 max
10:45:50 <lambdabot> forall a. (Ord a) => [a] -> a
10:45:53 * ddarius returns to work.
10:45:56 <maltem> Tordek: how does it not work?
10:46:13 <lilac> ddarius: ok, i'll ponder that. i don't really get category theory yet, so it'll take a while for me to figure out what the 'obvious' diagrams are :)
10:46:20 <lilac> ddarius: thanks :)
10:46:22 <Tordek> *Main> maximum' [1, 2, 4, 2] [...] No instance for (Num ())
10:46:41 <pumpkin> monomorphism restriction?
10:46:44 <Tordek> (but 'foldl1 max [1,2,4,2]' works just fine)
10:46:50 <lilac> yep, M-R
10:46:51 <maltem> Tordek: ah, ghci defaulting chimes in I guess
10:46:51 <pumpkin> you got defaulted
10:46:52 <psnively> There's a category of questions? :-)
10:47:15 <Tordek> hmm, k, thanks
10:47:22 <lilac> psnively: the arrows are useless answers, i guess
10:47:29 <pumpkin> lol
10:47:31 <maltem> Tordek: the workaround is an explicit type signature when you define maximum'
10:48:06 <chessguy_work> @hoogle second
10:48:07 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
10:48:07 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
10:48:07 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
10:48:35 <psnively> Maybe the arrows are rhetorical questions?
10:48:49 <lilac> psnively: does that make it an omega-category?
10:48:59 <psnively> Mu.
10:50:19 <rwbarton> lilac: one kind of trivial answer is the identity monad on a typical category
10:50:51 <rwbarton> lilac: in general for a category C there could be lots of other (non-equivalent) categories D and adjunctions F : C -> D, G : D -> C such that GF is the identity on C
10:51:08 <b4taylor> I don't suppose anyone knows how to send POST data with the HTTP-4* package.
10:51:34 <lilac> rwbarton: right. i guess it really depends what you mean by equivalent.
10:51:37 <rwbarton> rwbarton: e.g. C = Sets, D = Spaces, F = space with the trivial topology, G = underlying set
10:51:43 <chessguy_work> @type M.fromList . map (second M.fromList)
10:51:45 <lambdabot> forall k a d. (Ord k, Ord d) => [(d, [(k, a)])] -> M.Map d (M.Map k a)
10:52:54 * EvilTerran wanders back in
10:53:12 <EvilTerran> lilac, i've no idea how i helped, but it's nice to know i did :)
10:53:31 <lilac> EvilTerran: just one of those things where someone saying the right thing at the right time makes things click
10:57:01 <chessguy_work> i don't suppose there's a haskell library for getting info off of del.icio.us
10:57:16 <rwbarton> b4taylor: FWIW, you can do it with the curl or download-curl packages
10:57:37 <b4taylor> Hmmmm, from what I read the curl stuff is a low level wrapper.
10:57:48 <rwbarton> The download-curl package is a much nicer interface
10:57:57 <b4taylor> It seems as though HTTP-4000.0.0 should do it.
10:58:07 <b4taylor> Oh ok, I'll just look at that then.
10:58:16 <rwbarton> particularly openURIWithOpts.  I just discovered it yesterday :)
10:58:20 <b4taylor> Maybe I was thinking of another language's curl interface.
10:59:24 <rwbarton> The curl package on hackage has a interface that's kind of gross for doing simple things.
11:00:15 <rwbarton> (Or at least, certain simple things, like getting the response of a POST query)
11:01:15 <wchogg> chessguy_work : I'm not aware of one.
11:01:29 <chessguy_work> yay, more hackage opportunity :)
11:01:57 <wchogg> chessguy_work : so I take it you got a copy of the book? ;)
11:02:02 <chessguy_work> wchogg, did you check out the source of that python package?
11:02:11 <wchogg> chessguy_work : no, not yet.
11:02:16 <chessguy_work> wchogg, not yet. i'm wlrking off of http://oreilly.com/catalog/9780596529321/toc.html
11:02:57 <chessguy_work> wchogg, it looks like they include the xml parser, http code, and api client all in one
11:05:31 <wchogg> chessguy_work : but we've already got most of what we need on hackage, yes?  Between the http libraries, the json library, & the xml parsing libraries.
11:05:47 <chessguy_work> wchogg, yeah, assuming they're all up for it
11:06:01 <wchogg> chessguy_work : True.
11:06:03 <chessguy_work> i was just surprised to see that
11:06:35 <wchogg> How well do you know Python?
11:06:59 <chessguy_work> negatory
11:07:16 <chessguy_work> but heck, code is code, it can't be that hard to port
11:07:33 <Saizan_> what are you guys up to?:)
11:07:45 <wchogg> I was just curious more than anything.  Didn't think it'd be a problem.
11:07:48 <chessguy_work> Saizan_, http://groups.google.com/group/pci-in-haskell/about?hl=en
11:07:57 <EvilTerran> the same thing we do every night, Saizan_...
11:08:07 <chessguy_work> EvilTerran, are you thinking what i'm thinking?
11:08:07 <wchogg> Ooh nice answer
11:08:23 <EvilTerran> TRY TO TAKE OVER TH^W^W^W^W^Wtalkin' bout haskell
11:08:35 <EvilTerran> why do you ask? O:)
11:09:08 <chessguy_work> wonder how many people just counted the ^W's :)
11:09:25 * EvilTerran  
11:09:37 <wchogg> I totally did.
11:09:58 <sh10151> chessguy_work: I think so, but if we didn't have ears we'd look like weasels.
11:10:00 <chessguy_work> i was going to make fun of him for not putting enough in there, and then i realized it was ^W and not ^R
11:10:13 <dmwit> Count?  Just zip the words with the ^Ws in your head...
11:10:16 <chessguy_work> sh10151, if the shoe fits...
11:10:30 <chessguy_work> dmwit, words won't work
11:10:32 <sh10151> Me and Pippi Longstocking? What would the children look like?
11:10:48 <dmwit> chessguy_work: worked for me
11:11:01 <dmwit> ?brain
11:11:02 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
11:11:13 <chessguy_work> > words TRY TO TAKE OVER TH^W^W^W^W^W
11:11:14 <lambdabot>   Not in scope: data constructor `TRY'Not in scope: data constructor `TO'Not ...
11:11:17 <chessguy_work> > words "TRY TO TAKE OVER TH^W^W^W^W^W"
11:11:19 <lambdabot>   ["TRY","TO","TAKE","OVER","TH^W^W^W^W^W"]
11:11:29 <dmwit> chessguy_work: I just read the sentence as I was passing my eyes over the ^Ws.
11:11:31 <sh10151> Oh good, someone already did that macro
11:11:33 <sh10151> ?brain
11:11:33 <lambdabot> I think so, Brain, but we're already naked.
11:11:46 <dmwit> All I'm saying is, you don't have to count to figure out it's right. =)
11:11:50 <chessguy_work> lol
11:11:51 <sh10151> I remember making one of those random quote generators on ChibaMOO
11:11:57 <sh10151> yeah it was cool to a thirteen year old
11:12:11 <dmwit> ?brain!
11:12:11 <lambdabot> Well, I think so, Brain, but pantyhose are so uncomfortable in the summertime.
11:12:24 <dmwit> ?brain Are you thinking what I'm thinking?
11:12:24 <lambdabot> I think so, Commander Brain from Outer Space! But do we have time to grease the rockets?
11:12:36 <wchogg> My favorite quote generator was the Spaceman Emulator passed around on sci.physics years ago.
11:12:38 * EvilTerran is a random quote generator
11:12:39 <athos> @src get
11:12:39 <lambdabot> Source not found. There are some things that I just don't know.
11:12:50 <EvilTerran> athos, get is a method of MonadState
11:12:53 <EvilTerran> ?src State get
11:12:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:12:56 <EvilTerran> ...
11:12:59 <int80_h> w00t
11:13:04 <EvilTerran> ,src ''State
11:13:09 <lunabot>  newtype State s a = State {runState :: (s -> (a, s))}
11:13:21 <EvilTerran> athos, get = State$ \s -> (s,s)
11:13:54 <EvilTerran> and put x = State$ \s -> ((),x)
11:13:59 <chessguy_work> wchogg, actually, we may be able to just use http://hackage.haskell.org/cgi-bin/hackage-scripts/package/feed
11:15:06 <mux> @seen dons
11:15:07 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
11:15:12 <chessguy_work> actually, never mind, i don't see any immediate support in there for http
11:15:29 <pumpkin> lambdabot is kinda forgetful
11:16:55 <chessguy_work> @quote forget
11:16:56 <lambdabot> Philippa says: <vincenz> Philippa: forget theory, it's about pragmatics <Philippa> we're talking FP, they tend to be the same thing
11:16:59 <int80_h> pumpkin: are you named after the pumplinOS?
11:17:16 <pumpkin> I don't believe so :)
11:17:24 <int80_h> um, pumpkinOS
11:17:28 <athos> > runState.get $ 3
11:17:29 <lambdabot>       Overlapping instances for Show (s -> (a, s))
11:17:29 <lambdabot>        arising from a use ...
11:17:37 <athos> > :t runState.get
11:17:38 <chessguy_work> haha, only in haskell would you be asked that :)
11:17:38 <lambdabot>   <no location info>: parse error on input `:'
11:18:51 <dmwit> > runState get 3
11:18:52 <lambdabot>   (3,3)
11:19:16 <athos> ah ok
11:19:22 <mux> > runState (modify (+1) >> get) 3
11:19:24 <lambdabot>   (4,4)
11:19:26 <dmwit> > runState (put 3) 5
11:19:27 <lambdabot>   ((),3)
11:19:40 <pumpkin> int80_h: I assumed :P
11:20:07 <wchogg> wow...am I really behind the times that I didn't know del.icio.us was now delicious.com?  When did that happen?
11:20:13 <Gracenotes> :type modify
11:20:18 <dmwit> :t modify
11:20:20 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
11:20:20 <dmwit> ?type modify
11:20:22 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
11:20:25 <Gracenotes> dmwit: beat me to it ;)
11:20:33 <pumpkin> and schooled you!
11:20:36 <dmwit> Gracenotes: No, I came in after you.  But you did it wrong. =)
11:20:36 <athos> :t get
11:20:38 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
11:20:54 <Gracenotes> dmwit: I was editing my wrongful :type command!
11:20:59 <dmwit> oh, heh
11:21:25 <chessguy_work> wchogg, hm, i didn't know that
11:21:26 <Gracenotes> any reason why ":type" isn't provided...? :)
11:22:21 <athos> i guess i first try to write something that takes a data Tree a = Leaf a | Branch (Tree a) (Tree a) and produces a labeled tree (with numbers, beginning at the root with 0)
11:23:00 <pumpkin> I'm not too sure why :t is even provided
11:23:10 <pumpkin> just for simplicity I guess because everyone uses :t in ghci
11:23:18 <athos> maybe that way the state monad shows it's hidden power! well, actually it's not really "hidden", but i still think that i don't really got it ;)
11:24:13 <dublpaws> $ghc -dynamic -fPIC hello.hs  for linux x86, so now have hello.dyn, would like to, in python; from ctypes import *;  cdll.LoadLibrary("hello.dyn") -- but that fails.  have asked #python, would've asked in #python-haskell, afraid to ask in #ghc.
11:24:28 <chessguy_work> wchogg, i think there's more than a week of work in this first chapter, at least
11:24:40 <chessguy_work> err, chapter 2
11:25:44 <wchogg> chessguy_work : Yeah, you may be right.  We'll have to see how it goes.  Maybe I'll spend a little time this afternoon looking at the delicious api business.
11:26:01 <chessguy_work> wchogg, looks really cool though
11:26:21 <chessguy_work> i think we're going to wind up with a pretty disparate set of modules
11:26:33 <wchogg> Which would be kind of neat.
11:27:27 <paper_cc> dublpaws: what is the error message?
11:27:44 <chessguy_work> definitely
11:27:49 <chessguy_work> ok, back to work for me
11:28:02 <dublpaws> paper_cc:  './hello.dyn: cannot dynamically load executable'
11:28:25 <dublpaws> but ./hello.dyn in bash executes fine
11:28:41 <paper_cc> dublpaws: so you have an executable and not a .so
11:28:57 <dublpaws> okay, I though were the same, just a different name.
11:29:05 * paper_cc tries to remember if there's a fundamental difference in ELF executables and shared objects
11:29:13 <paper_cc> s/in/between
11:29:19 <Gracenotes> I have a question about this -- http://hpaste.org/13642
11:29:44 <pumpkin> dublpaws: what does file on it say?
11:29:48 <Gracenotes> assuming random is the only function we can use from System.Random, then is this a good case for monad transformers?
11:29:55 <Gracenotes> something with State and IO, perhaps?
11:29:57 <pumpkin> file hello.dyn
11:30:17 <dublpaws> ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.8, dynamically linked (uses shared libs), not stripped
11:30:24 <pumpkin> it's not a loadable library
11:30:26 * paper_cc remembers there were Random and RandomT somewhere
11:30:31 <paper_cc> @hoogle Random
11:30:31 <lambdabot> module System.Random
11:30:31 <lambdabot> System.Random class Random a
11:30:31 <lambdabot> package random
11:30:37 <paper_cc> @hoogle RandomT
11:30:37 <lambdabot> No results found
11:30:55 <Gracenotes> paper_cc: I've seen the random monad. But assuming we're just using State and IO. Could StateT be used?
11:31:19 <EvilTerran> Gracenotes, Random is really just a wrapper around State anyway
11:31:33 <paper_cc> StateT StdGen IO - for use with getStdGen. why not?
11:31:35 <pumpkin> dublpaws: you want something like /lib/libncurses.so.5.6: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), stripped
11:31:47 <dublpaws> pumpkin: excellent. thanks!
11:32:17 <Gracenotes> paper_cc: thanks. The point here is learning about monad transforms, not finding a better implementation ;)
11:32:24 <EvilTerran> paper_cc, or just "RandomT = StateT StdGen", newtype-wrapped, and with appropriate functions exported
11:32:38 <Gracenotes> *+ers
11:33:07 <EvilTerran> runRandomT (RandomT m) = runState m
11:33:17 <EvilTerran> er, runStateT, even
11:35:16 <EvilTerran> and then runRandomTWithStdGen m = do (x,stdGen) <- runRandomT m =<< getStdGen; setStdGen stdGen; return x
11:36:02 * paper_cc tries to get it
11:36:20 <Saizan_> with some liftIO if you want
11:36:26 <EvilTerran> indeed
11:36:58 <EvilTerran> ,src 'RandomT
11:37:00 <lunabot>  luna: Not in scope: data constructor `RandomT'
11:37:02 <EvilTerran> ,src 'RandT
11:37:04 <lunabot>  luna: Not in scope: data constructor `RandT'
11:37:42 <EvilTerran> ?type \m -> do (x,stdGen) <- runStateT m =<< getStdGen; setStdGen stdGen; return x
11:37:43 <lambdabot> forall a. StateT StdGen IO a -> IO a
11:39:05 <athos> hm
11:39:29 <wchogg> What's the lambdabot way of leaving someone a message they'll get when they log onto the chan?
11:39:39 <paper_cc> ahem, didn't notice it's =<< not >>=
11:39:39 <EvilTerran> @help tell
11:39:40 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:39:43 <EvilTerran> @help ask
11:39:44 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
11:40:00 <wchogg> Ah, thanks.
11:40:14 <EvilTerran> paper_cc, i find the "<- ... =<<" shape aesthetically pleasing
11:40:38 <paper_cc> it is, but it takes a while to understand =)
11:40:49 <wchogg> @tell chessguy Looks like there _is_ a delicious library released by Galois, so we should be able to just use that.
11:40:49 <lambdabot> Consider it noted.
11:41:41 <EvilTerran> @remember wchogg ... delicious library ...
11:41:42 <lambdabot> Nice!
11:42:24 * EvilTerran .oO( om nom nom bookshelves ) :P
11:42:30 <wchogg> EvilTerran : Vengeance will be mine...
11:42:45 <icarroll> @quote delicious
11:42:45 <lambdabot> wchogg says: ... delicious library ...
11:42:52 <icarroll> heh
11:43:23 <icarroll> so what would you call a function with type (a, Maybe b) -> Maybe (a,b) ?
11:43:54 <jeffwheeler> It's the name of popular Mac software: http://www.delicious-monster.com/
11:44:05 <EvilTerran> ?type Data.Traversable.sequence
11:44:06 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
11:44:12 <Nafai> mattpodwysocki: Hey!  Getting excited for tonight's book group!
11:44:15 <EvilTerran> ?type Data.Traversable.sequence :: (a, Maybe b) -> Maybe (a,b)
11:44:17 <lambdabot>     Could not deduce (Data.Traversable.Traversable ((,) a))
11:44:17 <lambdabot>       from the context ()
11:44:17 <lambdabot>       arising from a use of `Data.Traversable.sequence'
11:44:56 <EvilTerran> er, ok. that would work, if the relevant instances were there
11:45:08 <icarroll> hmm
11:45:13 <icarroll> looks a bit scary...
11:45:26 <wchogg> Oh crap, I forgot that the first RWH meeting was tonight.
11:45:41 <Nafai> wchogg: 8 est
11:46:02 <zloog> Hrm, I'm trying to use a module I wrote called Nntp. I have the Nntp.hs file in the same directory as the file I am trying to use it from but when using the haskell mode in emacs I always get the can't find module error. Am I forgeting to do something obvious?
11:46:34 <Saizan_> do you have module Nntp where ... at the top of Nntp.hs?
11:46:55 <icarroll> EvilTerran, do you think that's the right approach? if so, I'll poke at it some
11:47:39 <EvilTerran> "instance Foldable ((,) a) where { foldr f e (_,x) = f x e }; instance Traversable ((,)a) where { sequenceA (r,fx) = ((,)r) <$> f x }"
11:47:59 <EvilTerran> icarroll, no, that's a needlessly obtuse approach. i was just playing around with it. sorry. :P
11:48:03 <zloog> Saizan_: Yea, let me make an hpaste
11:48:07 <icarroll> k
11:48:37 <Saizan_> zloog: you may have to :cd to the right directory in ghci
11:49:14 <paper_cc> :t <$>
11:49:15 <lambdabot> parse error on input `<$>'
11:49:20 <paper_cc> :t (<$>)
11:49:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:50:18 <EvilTerran> icarroll, however, you could write a "liftTuple :: Functor f => (a, f b) -> f (a, b); liftTuple (x, fy) = fmap (\y -> (x,y)) fy"
11:50:24 <zloog> Saizan_: Tried that and the error still occurs, which confuses me because if I invoke ghci from a term everything seems to work
11:50:39 <EvilTerran> ?type \(x,fy) -> (\y -> (x,y)) <$> fy
11:50:40 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
11:50:56 <icarroll> EvilTerran, interesting
11:51:01 <icarroll> what would you call it :)
11:51:34 <zloog> Saizan_: O well, i bet this is something I'll have to drugde through the haskell mode code to find
11:51:48 <Saizan_> zloog: there's a bug in a version of haskell-mode that will change the directory to the one where it can find a .cabal file
11:52:06 <EvilTerran> icarroll, or you could just write one with the type you intended, but then i'd feel inclined to call it "liftMaybeFromSnd" or something. i guess i'd call it "liftSnd".
11:52:11 <Saizan_> zloog: so try creating a foo.cabal in your directory and see if it works
11:52:39 * EvilTerran likes making functions more generic so he can give them shorter namesw
11:52:46 <rgr> #deb
11:52:47 <opqdonut> :D
11:53:26 <icarroll> EvilTerran, good name and generalization, thanks
11:54:01 <EvilTerran> although it all goes wrong somewhere between "fmap" and http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
11:54:11 <Saizan_> liftTuple is called strength in CT, iirc
11:54:34 <icarroll> Saizan_, CT = ?
11:54:43 <Saizan_> category theory
11:54:49 <icarroll> ah, of course :)
11:55:12 <EvilTerran> the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
11:55:19 <jeffersonheard> is there a way to curry a record field setter?  like \a -> a{ foo= }
11:55:30 <Cale> EvilTerran: Really?
11:55:34 <icarroll> @remember EvilTerran the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
11:55:35 <lambdabot> It is forever etched in my memory.
11:55:46 <EvilTerran> Cale, what?
11:55:47 <eu-prleu-peupeu> hello
11:55:49 <Saizan_> http://comonad.com/reader/2008/deriving-strength-from-laziness/
11:56:26 <Cale> Aren't zygo- histo- etc. morphisms more of a recursion theory thing?
11:56:49 <EvilTerran> are they? i tend to get a bit lost around that area of abstract maths
11:57:35 <eu-prleu-peupeu> are there any good functional GUIs models ?
11:58:22 <Cale> The only morphism prefixes I'd expect to find in a category theory text would be {mono-,epi-,endo-,iso-,auto-}
11:58:37 <Cale> The others are all recursion theory.
11:58:50 <Cale> (at least as far as I'm aware)
11:58:51 <EvilTerran> Cale, oh well. i was just taking the opportunity to use the phrase "place of nightmares that spawned ...". i blame the (new) big book of HP Lovecraft on my shelf.
11:59:49 <pumpkin> Cale: isn't the empty prefix a valid one?
11:59:55 <icarroll> jeffersonheard, I think that's a proposal for haskell' , but I don't know if it's implemented anywhere
12:00:02 <idnar> EvilTerran: Searchers after horror haunt strange, far places. For them are the catacombs of Ptolemais, and the carven mausolea of the nightmare countries. They climb to the moonlit towers of ruined Rhine castles, and falter down black cobwebbed steps beneath the scattered stones of forgotten cities in Asia.
12:00:19 <EvilTerran> idnar, er... yes...
12:01:44 <idnar> sorry, I guess that was a bit of an obscure in-joke that nobody around here will get
12:01:55 <SamB_XP> Cale: well, er, we aren't good at telling CT from RT ;-P
12:01:56 <idnar> that is possibly my favourite Lovecraft story, though
12:03:03 <Cale> pumpkin: yes, that too
12:04:45 <saml> why is -XEmptyDataDecls useful?
12:04:59 <saml> is it to introduce empty type?
12:05:02 <EvilTerran> saml, for when you're doing strange, Olegian things in the type system
12:05:04 <EvilTerran> ?where oleg
12:05:05 <lambdabot> http://okmij.org/ftp/
12:05:06 <dmhouse> saml: yes.
12:05:13 <saml> yah i'm reading oleg's email response
12:05:15 <saml> lol
12:05:20 <thoughtpolice> not even really very 'olegian' things
12:05:31 <dmhouse> Otherwise the only way to create the empty type is something like data Empty = Empty Empty
12:05:31 <saml> http://www.mail-archive.com/haskell@haskell.org/msg20919.html
12:05:35 <thoughtpolice> but they can be useful in conjunction with e.g. phantom types.
12:05:47 <icqnumber_> ?users
12:05:47 <lambdabot> Maximum users seen in #haskell: 667, currently: 665 (99.7%), active: 24 (3.6%)
12:05:49 <mreh> what's the string to int function?
12:05:49 <smarmy> i recall the heap library uses it to specify the ordering as a phantom type
12:05:58 <saml> mreh, read
12:06:00 <thoughtpolice> read
12:06:02 <mreh> ta
12:06:03 <saml> > read "423" + 3
12:06:05 <lambdabot>   426
12:06:11 <mreh> @src read
12:06:11 <lambdabot> read s = either error id (readEither s)
12:06:25 <mreh> @src readEither
12:06:26 <lambdabot> Source not found. My pet ferret can type better than you!
12:06:32 <jeffersonheard> Can someone moderately familiar with TH please step in and help?  http://hpaste.org/13644
12:06:51 <mreh> im trying to implement read with a fold, i've gotten stuck
12:07:00 <mreh> do i need to use a map as well?
12:07:20 <monochrom> You can implement read with a fold.
12:07:35 <mreh> i cant quite see how
12:08:04 <mreh> ive got to multiply the result by ten every character i pop off the list
12:08:06 <jeffersonheard> I sort of understand the basics of template haskell, but I don't understand how names work, and how to get names that are predictable to be used in some places.  Also, I don't understand how to predict the AST that I'll get from reifying a name
12:08:20 <jeffersonheard> and the only option to print is pprint, which undoes the AST
12:08:45 <mreh> read = foldr (digitToInt) 0 xs
12:08:45 <rwbarton> jeffersonheard: Isn't there a Show Exp instance?
12:08:52 <mreh> that obviously isn't right
12:09:03 <monochrom> oops.
12:09:20 <EvilTerran> jeffersonheard, is mkName not giving you a predictable name?
12:09:41 <mreh> asInt xs 	= foldr (+ . digitToInt) 0 xs
12:09:48 <mreh> that still isn't quite there
12:09:52 <pumpkin> mreh: you need another .
12:10:07 <mreh> i need to multiply the list by ten right
12:10:18 <mreh> but i have no access to the rest of the list
12:10:22 <pumpkin> oh you're doing that
12:10:22 <jeffersonheard> EvilTerran, I thought it gave me a "unique" name, rather than just the Name version of the String I pass in
12:10:28 <jeffersonheard> so I thought it added some mangling
12:10:36 <EvilTerran> jeffersonheard, that's "newName :: String -> Q Name"
12:10:48 <monochrom> Perhaps foldl works better.
12:10:50 <EvilTerran> jeffersonheard, "mkName :: String -> Name" can't mangle, because it's not monadic
12:11:06 <jeffersonheard> I'm new to TH, and the tutorials are helpful for basic stuff, but I don't have time to go through all the basics, and no reason to make toy apps when I just want to use it for the one thing
12:11:15 <jeffersonheard> EvilTerran, thanks... that's clear
12:11:18 <jeffersonheard> missed that before
12:11:21 <mreh> monochrom: is that a clue?
12:11:24 <jeffersonheard> thought there was a Q before it
12:11:50 <pumpkin> > foldl (\x y -> x * 10 + digitToInt y) 0 "1234"
12:11:52 <lambdabot>   1234
12:12:03 <jeffersonheard> That doesn't solve all my problems by any means, but that at least is clear
12:12:06 <rwbarton> , [| 3 + 4 |]
12:12:09 <lunabot>  InfixE (Just (LitE (IntegerL 3))) (VarE +) (Just (LitE (IntegerL 4)))
12:12:46 <monochrom> I guess so.
12:13:00 <noZone> Are Where Clauses anything like Santa Clauses?
12:13:21 <leimy> Looks like I need Data.ByteString.ByteString where I have Data.ByteString.Internal.ByteString.
12:13:35 <leimy> not sure what to do there.
12:14:08 <Saizan_> leimy: you sure you aren't mixing strict and lazy bytestrings?
12:14:11 <rwbarton> leimy: aren't they the same?
12:14:18 <leimy> Saizan_: I might be :-)
12:14:29 <Saizan_> because those two are the same
12:14:34 <leimy> I was trying to use Text.CSV.ByteString
12:14:45 <saml> it's hard to understand oleg's code
12:14:48 <jeffersonheard> and rwbarton, no, I can't seem to get a show instance for Exp that prints the Haskell I'd have to type in to get the proper Template
12:15:00 <pumpkin> saml: I don't like his underscore style, but it's pretty epic code anyway
12:15:13 <jeffersonheard> not saying it's not there, but I can't seem to print it out
12:15:19 <Saizan_> leimy: from which package?
12:15:33 <leimy> Saizan_:  I believe that is the package
12:15:36 <Saizan_> ?hoogle Text.CSV.ByteString
12:15:36 <lambdabot> package bytestring
12:15:36 <lambdabot> package bytestring-csv
12:15:36 <lambdabot> package bytestring-lexing
12:15:42 <rwbarton> what about my lunabot , [| 3 + 4 |] above?  I think lunabot is doing something special to get that, but it must be possible
12:15:45 <Saizan_> ?hackage bytestring-csv
12:15:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-csv
12:15:53 <rwbarton> jeffersonheard: or is that not what you're looking for
12:16:12 <mpwd> noZone: No, they are different.  For one, Santa Clauses are used in the Curry paradox: let C = { w | if w in w then "there is a Santa Clause"}
12:16:25 <leimy> Saizan_:  The problem is I wanted to use "lines"
12:16:37 <leimy> well ByteString.lines :-)
12:16:39 <jeffersonheard> rwbarton, that is what i want...
12:16:58 <leimy> That's probably where I went wrong.
12:17:20 <jeffersonheard> rwbarton, however [| BasicUIState |] gives me a No Instance for Show ExpQ
12:17:35 <rwbarton> jeffersonheard: it's a little tricky to get ghci to produce that.  I recall doing something like $( LitE . StringL . show <$> [| whatever |] )
12:17:41 <leimy> So I imported Data.ByteString.Lazy.Char8
12:17:43 <rwbarton> jeffersonheard: right, because ExpQ = Q Exp and that's in the Q monad
12:17:48 <noZone> So Santa Clauses may be related to Schrödinger's Clauses.
12:17:53 <leimy> and then tried to get it to work with Text.CSV.ByteString
12:18:01 <leimy> and it seems to be unhappy with me.
12:18:05 <jeffersonheard> right...  but lunabot can do it
12:18:08 <jeffersonheard> :P
12:18:14 <Saizan_> leimy: ah, yeah, bytestring-csv uses strict bytestrings, so you can't give it a bytestring from .Lazy
12:18:15 <rwbarton> jeffersonheard: Yeah, I think it cheats somehow.
12:18:27 <leimy> Saizan_:  so no "lines" function :-(
12:18:42 <leimy> and I don't think I can getContents either.
12:18:42 <rwbarton> jeffersonheard: In particular I think mmorrow wrote a Show ExpQ instance
12:19:30 <rwbarton> leimy: There is Data.ByteString.Char8.lines...
12:19:34 <Saizan_> ?type Data.ByteString.Char8.lines
12:19:35 <lambdabot> BSC.ByteString -> [BSC.ByteString]
12:19:37 <jeffersonheard> and he didn't share?
12:19:42 <leimy> How about getContents? :-)
12:19:44 <jeffersonheard> :P
12:19:49 <rwbarton> leimy: I'll give you one guess :P
12:19:52 <leimy> lol
12:20:03 <leimy> since that function is lazy that's a negatory
12:20:04 <leimy> oh well
12:20:07 <leimy> getLine may do.
12:20:09 <rwbarton> leimy: No, it's a yes.
12:20:17 <rwbarton> leimy: It's just a strict getContents.
12:20:22 <Saizan_> ?type Data.ByteString.Char8.getContents
12:20:23 <lambdabot> IO BSC.ByteString
12:20:36 <Saizan_> it'll load all the file in memory up front
12:20:38 <leimy> rwbarton: yeah that fixed it.
12:20:42 <paper_cc> saml: couldn
12:20:54 <leimy> Saizan_:  yeah but I'm not using a "file"
12:20:57 <mreh> dont you wish they did all your favourtie CS books in hardback?
12:20:58 <leimy> I'm using stdin
12:21:00 <paper_cc> +'t find a good explanation of GADTs anywhere...
12:21:17 <noZone> For the price, they should be.
12:21:24 <mreh> high five
12:21:26 <Saizan_> "file" in the unix sense :)
12:21:27 <mreh> zing
12:21:27 <saml> paper_cc, i found it: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt-style
12:21:45 <saml> i'm not sure i udnerstand it though
12:21:49 <leimy> oh it's gonna wait till it exhausts stdin before processing
12:21:51 <leimy> that's no good
12:21:53 <rwbarton> jeffersonheard: He has it somewhere on code.haskell.org or darcs.haskell.org
12:22:09 <rwbarton> jeffersonheard: He's got a bunch of tools for working with Template Haskell actually
12:22:17 <saml> i just wanted a unification algorithm written in easy to read haskell. and googling for haskell unification algorithm first gave me oleg's
12:22:48 <mreh> @src foldl
12:22:49 <lambdabot> foldl f z []     = z
12:22:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:22:55 <noZone> CS books weren't meant to last, especially not books on languages as they have a habit of changing so much.
12:23:23 <SamB_XP> noZone: is *that* why they get so mildewed
12:23:29 <jeffersonheard> rwbarton: thanks, I'll look at that
12:23:40 <noZone> no... that's just your basement.
12:24:00 <rwbarton> leimy: you could use the lazy bytestring getContents and lines, and convert each line to a strict bytestring to pass to the csv thing
12:24:14 <leimy> yeah but how? :-)
12:24:33 <rwbarton> leimy: concat . toChunks IIRC (with appropriate module qualification)
12:24:40 <leimy> hmmm
12:24:57 <leimy> I think since I'm just sequencing line based input that I can live with getLine... but thank you!
12:25:01 <mreh> is it right to say that fold f zero xs = f x1 . f x2 . ... . f zero ???
12:25:07 <rwbarton> leimy: Ah, sure.
12:25:08 <leimy> and this is a simple little program that doesn't expect to live long
12:25:40 <leimy> OOh
12:25:45 <leimy> "exception: no buffering"
12:25:45 <Saizan_> > foldl f z [a,b,c,d]
12:25:45 <jonaskoelker> does the standard library have a fixed-point function, such that fix' (take 1) [] = [] and fix (take 1) (x:_) = x?
12:25:46 <lambdabot>   f (f (f (f z a) b) c) d
12:25:48 <leimy> that's fun.
12:25:52 <athos> > (runState (do {x <- get; put (x+1); return x})) 0
12:25:53 <Saizan_> > foldr f z [a,b,c,d]
12:25:54 <lambdabot>   (0,1)
12:25:54 <lambdabot>   f a (f b (f c (f d z)))
12:26:21 <mreh> gaaaah
12:26:29 <athos> hm
12:26:38 <mreh> did anyone else's brain hurt when they first tried to grok these intuitively
12:27:01 <athos> i don't get how get works. it was something like get = State $ \s -> (s,s), wasn't it?
12:27:38 <paper_cc> athos: exactly
12:27:46 <Saizan_> mreh: for "foldr f z" just replaces every (:) in the list with 'f' and the [] with 'z'
12:28:00 <Saizan_> s/for//
12:28:14 <rwbarton> jonaskoelker: I don't understand, it looks like your "fix" function is just id
12:28:21 <leimy> Hmmm
12:28:30 <leimy> now I'm getting Prelude.tail: empty list
12:28:39 <jonaskoelker> rwbarton: oops, s/=/==/
12:28:40 <leimy> but I don't call tail, so it's somewhere in Text.CSV.ByteString
12:28:47 <athos> paper_cc: hmm.. but then why does x <- get "stores" a single Int value?
12:28:55 <opqdonut> jonaskoelker: and bedides it doesn't type
12:28:59 <jonaskoelker> rwbarton: and it isn't id; it finds a fixed point of a function, starting from some value
12:29:01 <noZone> What does the idiom "Golfing something" mean? RWH uses that phrase a couple of times.
12:29:28 <oklopol> finding a short code to do X
12:29:31 <rwbarton> jonaskoelker: maybe you should use an example where the function would be applied more than once?
12:29:33 <jonaskoelker> s/= x/= [x]/
12:29:33 <sjanssen> noZone: it means to make the code as small as possible
12:29:44 <opqdonut> jonaskoelker: that isn't really doable in general
12:29:44 <noZone> k
12:29:52 <opqdonut> jonaskoelker: but you might find iterate useful
12:30:00 <opqdonut> > iterate (take 1) [1,2,3]
12:30:01 <lambdabot>   [[1,2,3],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
12:30:03 <rwbarton> jonaskoelker: you mean, find the first repetition in x, f x, f (f x), etc.?
12:30:14 <jonaskoelker> exactly
12:31:08 <noZone> Ah, I see... lowest score wins, thus shortest code, etc.
12:31:16 <newsham> > iterate (\n -> if even n then n `div` 2 else 3*n+1) 235
12:31:18 <lambdabot>   [235,706,353,1060,530,265,796,398,199,598,299,898,449,1348,674,337,1012,506...
12:31:23 <luite> is there a solution for ghci often hanging when used in inferior-haskell (in emacs).
12:31:30 <rwbarton> jonaskoelker: No, you have to write it yourself, e.g.,
12:31:34 <jonaskoelker> hoogle "(a -> a) -> a -> a"
12:31:37 <Saizan_> > dropWhile (uncurry (/=)) . ap zip tail . iterate (take 1) $ [1..3]
12:31:39 <lambdabot>   [([1],[1]),([1],[1]),([1],[1]),([1],[1]),([1],[1]),([1],[1]),([1],[1]),([1]...
12:31:39 <jonaskoelker> :\
12:31:50 <opqdonut> jonaskoelker: you need an Eq constraint of course
12:31:55 <rwbarton> > fst . head . filter (uncurry (==)) . (zip`ap`tail) . iterate (take 1) $ [1,2,3]
12:31:55 <jonaskoelker> of course
12:31:56 <lambdabot>   [1]
12:32:08 <newsham> > takeWhile (/= 1) $ iterate (\n -> if even n then n `div` 2 else 3*n+1) 235
12:32:09 <lambdabot>   [235,706,353,1060,530,265,796,398,199,598,299,898,449,1348,674,337,1012,506...
12:32:10 <opqdonut> nice rwbarton
12:32:23 <rwbarton> same as Saizan_'s
12:32:51 <dmhouse> ?users
12:32:52 <lambdabot> Maximum users seen in #haskell: 668, currently: 667 (99.9%), active: 30 (4.5%)
12:33:13 <newsham> ?seen vixey
12:33:14 <lambdabot> vixey is in #scala, #perl6, ##logic and #haskell. I last heard vixey speak 5h 1m 25s ago.
12:33:45 <mreh> I love it when my programs work first time!!!
12:33:47 <rwbarton> Wow, it was 602 on Friday.
12:34:14 <mreh> why haven't haskell programmers taken over the world?
12:34:22 <mreh> or solved world hunger
12:34:33 <mreh> for good... must use my powers for good.
12:34:50 <SamB_XP> well, ruling the world is too much work
12:35:01 <mreh> yes yes, haskell is lazy
12:35:06 <smarmy> philosopher kings don't want to rule
12:35:07 <mreh> but just imagine!
12:35:09 <SamB_XP> and world hunger is really more a matter of economics
12:35:23 <leimy> wow foldrChunks
12:35:25 <leimy> no idea :-)
12:35:26 <athos> ah....
12:35:27 <mreh> i think you'll find that aristotle thought philosophers make the best kinds
12:35:34 <paper_cc> athos: um.
12:35:41 <paper_cc> @ty do x <- get
12:35:42 <lambdabot> The last statement in a 'do' construct must be an expression
12:35:43 <athos> paper_cc: i think i know why
12:35:54 <saml> why is kind there?
12:35:56 <paper_cc> @ty do x <- get; return x
12:35:56 <athos> is it because of the definition of (>>=) for State?
12:35:57 <lambdabot> forall (t :: * -> *) t1. (MonadState t1 t) => t t1
12:36:11 <saml> i'm not sure of purpose of kind
12:36:13 <smarmy> athos: yes
12:43:39 <IWannaLog> Hi, is there someone who knows differences between runhaskell and runghc ?
12:44:10 <mreh> can someone explain why this code doesn't compile
12:44:18 <rwbarton> IWannaLog: Usually the former is a symbolic link to the latter
12:44:18 <mreh> - . + x y
12:44:25 <mreh> and this does
12:44:29 <mreh> (-) . + x y
12:44:30 <IWannaLog> the former is ... latter
12:44:36 <IWannaLog> former :: runhaskell
12:44:40 <IWannaLog> latter :: runghc ?
12:44:47 <rwbarton> right
12:44:54 <IWannaLog> thx
12:45:02 <SamB_XP> IWannaLog: well the other way round would make little sense
12:45:02 <rwbarton> :t (-) . + ?x ?y
12:45:02 <opqdonut> :D
12:45:06 <lambdabot> parse error on input `+'
12:45:08 <intoverflow>  ls -l `which runhaskell`
12:45:09 <athos> smarmy: wow, it's really because of >>=
12:45:09 <wabash> anyone have any opinions about Hugs vs GHCi?
12:45:24 <athos> cool stuff
12:45:37 <IWannaLog> in my computer there are not link, but there are the same exe (md5sum said that)
12:45:51 <IWannaLog> ?users
12:45:52 <lambdabot> Maximum users seen in #haskell: 668, currently: 668 (100.0%), active: 27 (4.0%)
12:45:58 <athos> 668?
12:46:01 <athos> what the heck
12:46:09 <Cale> wabash: ghci is better in a lot of ways
12:46:20 <IWannaLog> Did it count itself ?
12:46:23 <rwbarton> mreh: Neither of the compile, because neither of them make any sense. :)
12:46:27 <Cale> wabash: (primarily because there are more people working on it)
12:46:35 <athos> IWannaLog: jep
12:46:40 <EvilTerran> xchat's telling me 668
12:46:41 <rwbarton> mreh: I might believe (-) . (+) x y though
12:46:44 <IWannaLog> athos: jep ?
12:46:53 <athos> IWannaLog: "yes"
12:46:54 <rwbarton> :t (-) . (+) ?x ?y
12:46:54 <athos> IWannaLog: :)
12:46:55 <lambdabot> forall b a. (Num (a -> b), ?y::a -> b, ?x::a -> b, Num b) => a -> b -> b
12:46:58 <athos> sorry ;)
12:47:45 <wabash> Cale: thanks.
12:48:11 <IWannaLog> what does ?y :: a means ?
12:48:31 <rwbarton> wabash: also because most everyone here uses ghci, so if you come back with an error message from hugs, we'll all be confused by it :P
12:48:32 <opqdonut> ?y::a -> b
12:48:33 <lambdabot> Unknown command, try @list
12:48:37 <opqdonut> means that y has type a->b
12:48:42 <wabash> rwbarton: Yes, cool.
12:48:45 <IWannaLog> why the '?' ?
12:48:53 <opqdonut> one can use ?var in :t to mark unknown vars
12:48:56 <wabash> Though I never get error messages from hugs; just warm fuzzies.
12:49:02 <opqdonut> :t ?f ?x
12:49:03 <lambdabot> forall t t1. (?x::t, ?f::t -> t1) => t1
12:49:06 <opqdonut> :t f x
12:49:07 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
12:49:12 <EvilTerran> IWannaLog, it's like a placeholder; "(?y :: a) => ..." means "given a variable ?y of type a, the type ..."
12:49:13 <opqdonut> gah, bad exampe
12:49:32 <IWannaLog> it's for lambdabot only ?
12:49:52 <EvilTerran> well, ghc supports it, but it's considered bad style to use it for anything other than casual hacking
12:49:58 <EvilTerran> it's a bit weird
12:50:36 <EvilTerran> > let foo = ?bar in (let ?bar = 1 in foo, let ?bar = 2 in foo)
12:50:38 <lambdabot>   (1,2)
12:50:42 <rwbarton> IWannaLog: you can turn it on in ghci with :set -XImplicitParams
12:50:51 <IWannaLog> rwbarton: okay
12:51:03 <IWannaLog> but i prefer to avoi -X...
12:51:04 <rwbarton> IWannaLog: but yeah mostly it's useful with :t
12:51:06 <EvilTerran> ^ looks like dynamic scoping. is really static.
12:51:17 <EvilTerran> ?type let foo = ?bar in foo
12:51:18 <lambdabot> forall t. (?bar::t) => t
12:51:18 <IWannaLog> I don't know if they are supported by many haskell implementation
12:52:19 <EvilTerran> IWannaLog, -XImplicitParams only really sees use as a debugging aid anyway; it doesn't really matter if those only work on your compiler
12:52:27 <IWannaLog> If I put on a windows computer (in the same folder) runghc and a main.hs, can I run "runghc main.hs" or do I need additional install ?
12:52:59 <IWannaLog> EvilTerran: sorry, I never debug... :D
12:53:10 <Saizan_> you need all the ghc installation
12:53:19 <IWannaLog> :( ok
12:53:24 <EvilTerran> unless you compile!
12:53:32 <EvilTerran> then it's self-contained
12:53:46 <IWannaLog> is there a way to have a little haskell style script where I can use do notation and use a few libs
12:54:22 <IWannaLog> to got a real scripting language
12:54:26 <opqdonut> #!/usr/bin/runhaskell ?
12:54:30 <pk> How is it possible to express "cyclic" data structures ?
12:54:41 <IWannaLog> It won't be installed on the system.
12:54:44 <Saizan> if you want a scripting language you need to install the interpreter..
12:54:52 <pk> like a list which would refer to its first element
12:54:54 <opqdonut> pk: by making them cyclic
12:55:03 <wli> Cyclic structure: let xs = 0 : 1 : xs in ...
12:55:08 <opqdonut> yep
12:55:11 <intoverflow> pk: google "tieing the knot"
12:55:16 <opqdonut> > cycle [1,2,3]
12:55:16 <pk> k
12:55:17 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:55:18 <b_jonas> pk: assign parts of it to variables, you can use later names for the definition of previous ones in a let statement
12:55:18 <pk> thx
12:55:20 <jeffersonheard> rwbarton: do you in fact have an instance of Show ExpQ somewhere that I can find it and use it?  Or do you care to help me with the aforepasted hpaste code for a few minutes to get me in the right direction?
12:55:26 <opqdonut> that's a cyclic list (in memory)
12:55:26 <IWannaLog> There is not a haskell package (exemple a package in hackage) which works fine ?
12:55:30 <b_jonas> > let { a = 1 : 2 : 3 : a }  in a
12:55:32 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:55:44 <b_jonas> > let { a = 1 : 2 : 3 : b; b = 4 : 5 : a } in a
12:55:45 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,...
12:55:55 <flux> @src cyclic
12:55:56 <lambdabot> Source not found. That's something I cannot allow to happen.
12:56:00 <flux> @src cycle
12:56:01 <lambdabot> cycle [] = undefined
12:56:01 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:56:03 <flux> (bah)
12:56:19 <Philonous1> data Foo a = Foo a (Bar a); data Bar a = Bar a (Foo a) -- like this?
12:56:55 <intoverflow> pk: the gist is that for some structures and situations it's just a little trick, but in other situations it can be a bit involved; it boils down to the fact that lazy evaluation lets you build each structure with references to one another "as if" all of the others have already been built
12:57:44 <kpreid> @let sickle xz = xz' where xz' = xz' + xz
12:57:45 <lambdabot>  Defined.
12:57:47 <kpreid> er
12:57:50 <rwbarton> jeffersonheard: I don't have such an instance but I can try to recreate how I usually solve this problem in ghci
12:57:55 <kpreid> @let sickle xz = xz' where xz' = xz' `mappend` xz
12:57:56 <lambdabot>  <local>:15:0:
12:57:56 <lambdabot>      Warning: Pattern match(es) are overlapped
12:57:56 <lambdabot>               I...
12:58:03 <kpreid> @undefine
12:58:05 <kpreid> @let sickle xz = xz' where xz' = xz' `mappend` xz
12:58:06 <jeffersonheard> rwbarton, that'd be great
12:58:06 <lambdabot>  Defined.
12:58:15 <kpreid> > sickle [1,2,3]
12:58:30 <lambdabot>   thread killed
12:58:31 <diegoeche> I'm having a problem with emacs and ghc 6.10.1... the inferior mode is showing something like this:
12:58:32 <flux> suddenly, nothing happens :)
12:58:33 <diegoeche> *Main> 1
12:58:33 <diegoeche> 1^J1
12:58:33 <diegoeche> Any idea?
12:58:33 <kpreid> > sickle (Data.Monoid.Dual [1,2,3])
12:58:34 <lambdabot>   Dual {getDual = [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,...
12:59:00 <rwbarton> jeffersonheard: http://hpaste.org/13645
12:59:09 <kpreid> > (Data.Monoid.getDual . sickle . Data.Monoid.Dual) [1,2,3]
12:59:10 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:59:22 <pk> What if I want to manipulate the cyclic reference ?
12:59:43 <EvilTerran> then you make a new one
12:59:49 <intoverflow> yeah
13:00:02 <pk> I mean
13:00:42 <pk> if you have a cyclic graph and you want to print it, in the human form
13:00:51 <pk> without infinite recursion
13:00:58 <jeffersonheard> rwbarton, excellent
13:01:08 <EvilTerran> pk, then you need to express it differently, i guess
13:01:18 <IWannaLog> pk: You can't detect cyclic graph without dirty things.
13:01:25 <kpreid> pk: that is not possible
13:01:26 <EvilTerran> pk, the normal method i've seen of representing a graph is "Map Label (Set Label)"
13:01:43 <kpreid> pk: the way I like to put it is that Haskell has infinite structures, but not cyclic ones
13:01:54 <pk> ok
13:01:55 <EvilTerran> where Label is a type uniquely identifying each node, and the others are in Data.Map and Data.Set
13:02:32 <EvilTerran> while the structures might be implemented as cyclic, that's an implementation detail; semantically, they're equivalent
13:02:49 <EvilTerran> er, infinite
13:03:25 <pk> I must explicitely create each label ?
13:03:41 <Heffalump> yes
13:03:51 <Heffalump> or you can use the dirty tricks if you understand the issues
13:04:06 * rwbarton has tried to use the dirty tricks and never succeeded
13:04:09 <pk> like template haskell ?
13:04:21 <Heffalump> no, like stable names
13:04:21 <intoverflow> pk: google for "tieing the knot"
13:04:33 <pk> k thx
13:04:42 <IWannaLog> pk: you're not in a reference language but in a value language
13:05:05 <Heffalump> "tieing the knot" doesn't help if you want to traverse the structure afterwards if it's unlabelled
13:05:38 <intoverflow> Heffalump: sure, though many articles on knot tieing also bring up traversal
13:05:51 <Heffalump> fair enough
13:06:23 <rwbarton> pk: the fundamental problem is, say you have data Node = NodeWithNeighbors [Node], then a = NodeWithNeighbors [a] is indistinguishable from a = NodeWithNeigbors [b], b = NodeWithNeighbors [a]
13:06:52 <rwbarton> pk: if you want to treat them as different, you must explicitly label them with different labels
13:07:19 <pk> yeah ok
13:07:21 <pk> I get taht
13:07:23 <pk> that
13:07:25 <IWannaLog> what is knot tieing
13:07:31 <pk> thx
13:07:43 <IWannaLog> it is the famous node that alexandre cut ?
13:09:03 <leimy> This CSV bytestring thing is depressing
13:09:19 <leimy> internally making an unsafe use of tail
13:09:53 <pumpkin> leimy: anything else depressing in it?
13:10:33 <ksf> I finally figured out why I was attracted to yampa although reactive is technologically superior.
13:10:40 <ksf> It's the interface.
13:11:09 <leimy> pumpkin: no it just took me forever to realize why tail was failng.
13:11:22 <ksf> It's hard, if not impossible, to see how reactive's parts interact to form a whole, with yampa it's painfully obvious.
13:12:08 <ksf> is anyone listening?
13:12:10 <fxr> ksf: but I think reactive is using more formal interfaces
13:12:11 <intoverflow> how stable is the reactive interface?
13:12:41 <ksf> well, I don't dig formalisms for formalism's sake.
13:13:09 <ksf> I doubt that it'll change fundamentally.
13:13:29 <fxr> ksf: could you please clarify?
13:14:02 <ksf> ...the part that's implementation- and semantics-dependant, that is.
13:14:16 <ksf> i.e. switch will stay.
13:14:29 <Saizan> do you have some examples?
13:15:01 <pk> what if I had a new type constructor to my structure
13:15:02 <pk> ?
13:15:09 <ksf> Saizan, what do you mean?
13:15:29 <pk> that explicit the cycle
13:15:47 <rwbarton> pk: type constructor?
13:15:47 <Saizan> ksf: some code in both the libraries se that we can compare readability
13:15:59 <pk> instead of saying cycle [1,2,3]
13:16:06 <ksf> ah, nope, it's the learning phase i'm referring to.
13:16:10 <pk> I would say Cycle [1,2,3]
13:16:17 <fxr> ksf: yeah that will be great, if you have time to prepare
13:16:41 <kpreid> pk: yes you could do that. you mean data constructor though
13:16:52 <pk> yes, sorry
13:17:03 <ksf> It could well be that I just need to figure out what reactive's whole is, thereby grok it and be able to grind everyone's noses into it.
13:17:08 <Saizan> yeah, the reactive interface felt quite obscure to me too, but i haven't spent much time with it
13:17:20 <kpreid> data CList a = Empty | Item a (CList a) | Cycle [a]
13:17:44 <pk> of course it would be pretty ugly for a graph
13:17:53 <Saizan> (i especially dislike the use of seemingly random type synonyms)
13:19:11 <ksf> the whole notion of "Event" not being a single occurence but rather a stream wrecks havoc in my mind, but I'm learning to just ignore it.
13:19:56 <Saizan> i guess you're supposed to think pointwise
13:20:12 <ksf> death to reductionism...
13:20:31 <rwbarton> pk: Something I've done before is add a data constructor data Graph = ... | Label String Graph | ... and make sure that every cycle goes through at least one Label
13:20:38 <rwbarton> pk: (and that all the labels are distinct)
13:21:41 <yitz> IWannaLog: knot tying is building values that point to each other recursively
13:22:07 <ksf> knot tying is a good metaphor.
13:22:28 <pk> rwbarton: I don't get it. Can you show me an example ?
13:22:31 <IWannaLog> yitz: thx
13:23:08 <ksf> so "Event" would be a single string of wyrd, and most of the functions different norns.
13:23:32 <yitz> @bots
13:23:32 <lambdabot> :)
13:23:32 <lunabot>  :)
13:23:53 <IWannaLog> pk: you could have a struct like this : Data ListCell a b = Nothing | ListCell {key :: a, head :: b, tail :: ListCell}
13:24:22 <IWannaLog> and you have to ensure that you use a type a which is instance of Eq and create yourself your unique ID
13:25:11 <pk> I see
13:25:38 <pk> maybe I could add a concatenate function
13:25:42 <IWannaLog> but it's dangerous because you could have the same key for two different ListCell, it's not a goood idea
13:25:48 <rwbarton> pk: ok, imagine you have a complete binary tree of height n with an edge from each leaf back to the root
13:26:08 <rwbarton> pk: then you can write  root = Label "root" $ tree n where tree 0 = root; tree n = Node [tree (n-1), tree (n-1)]
13:27:03 <rwbarton> pk: this makes most sense for certain kinds of graphs, like the ones that come from control flow in a program
13:28:34 <pk> rwbarton: seems good
13:29:09 <IWannaLog> pk: maybe you could create a monad with a function of type a -> [b] -> pkMonad (Node [b] a) where a is the value type and b the key type
13:29:29 <IWannaLog> like this it will be simple to create new node browse them ensure uniqueness of the key etc...
13:29:47 <pk> rwbarton: I only need to provides names to the recursive part, don't I ?
13:30:11 <rwbarton> pk: depends on your application I think
13:30:24 <rwbarton> pk: for example in my application I didn't care about distinguishing the left and right children of any node
13:30:54 <rwbarton> pk: if you need to distinguish them then you'll probably have to label everything I guess
13:31:24 <rwbarton> pk: using a monad to generate labels is a good idea probably
13:32:41 <pk> what would the bind do ?
13:32:52 <pk> add one element to the tree ?
13:33:15 <athos> :t put
13:33:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
13:33:51 <rwbarton> pk: keep track of the last allocated label
13:34:00 <rwbarton> pk: a state monad with a newLabel operation
13:34:25 <pk> rwbarton: ok
13:34:35 <athos> > (runState $ get >>= put (1+) >> return x) 0
13:34:36 <lambdabot>   Couldn't match expected type `State s a' against inferred type `()'
13:34:49 <athos> eh
13:34:53 <athos> of course!
13:35:00 <pk> rwbarton: I think that's perfect
13:35:26 <athos> > (runState $ get >>= \x -> put (1+x) >> return x) 0
13:35:28 <lambdabot>   (0,1)
13:35:46 <wli> > (runState $ modify (1+) >> return x) 0
13:35:48 <lambdabot>   (x,1)
13:35:54 <athos> > (runState $ get >>= \x -> put "bar" >> return x) "foo"
13:35:55 <lambdabot>   ("foo","bar")
13:35:58 <leimy> > (runState $ get >= \x -> put (1+x) >> return x) 101010101
13:35:59 <lambdabot>   Couldn't match expected type `State s a'
13:36:18 <svref> @src read
13:36:18 <lambdabot> read s = either error id (readEither s)
13:36:37 <leimy> > (runState $ get > >= \x -> put (1+x) >> return x) 101010101
13:36:38 <lambdabot>   <no location info>: parse error on input `>='
13:36:48 <athos> wli: so modify f is something like get >>= put.f?
13:36:50 <svref> @src readEither
13:36:50 <lambdabot> Source not found. My pet ferret can type better than you!
13:36:55 <Stephan202> > (runState $ get >>= \x -> put (1+x) >> return x) 101010101
13:36:56 <lambdabot>   (101010101,101010102)
13:37:07 <wli> > (execState $ modify (1+)) 10101
13:37:07 <leimy> > (runState $ get >>= \x -> put (1+x) >> return x) 101010101
13:37:09 <lambdabot>   (101010101,101010102)
13:37:09 <lambdabot>   10102
13:37:12 <leimy> my font sucks :-)
13:37:21 <leimy> can't see spaces... and this irc client does
13:37:30 <leimy> not do history
13:37:41 <athos> :t execState
13:37:42 <wli> athos: Yeah.
13:37:43 <lambdabot> forall s a. State s a -> s -> s
13:37:44 * Stephan202 mumbles: irssi
13:37:48 <wli> @src modify
13:37:49 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:38:01 <wli> @src Control.Monad.State.modify
13:38:01 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:38:08 <wli> @info Control.Monad.State.modify
13:38:09 <lambdabot> Control.Monad.State.modify
13:38:21 <wli> @info modify
13:38:22 <lambdabot> modify
13:38:31 <leimy> lambdabork
13:38:33 <Saizan>  @info doesn't exist
13:38:37 <wli> Ugh, sorry. It should've been more obvious.
13:39:19 <rwbarton>  @info = @undo
13:39:48 * wli thought it would do the same thing as in ghci.
13:40:13 <Saizan> , src 'modify
13:40:18 <lunabot>  modify :: forall s m . MonadState s m => (s -> s) -> m ()
13:40:34 <SamB_XP_> rwbarton: I thought it was @id
13:40:38 <wli> That's what I was hoping for.
13:40:48 <rwbarton> @info do { x <- [1,2,3]; return x }
13:40:48 <lambdabot> [1, 2, 3] >>= \ x -> return x
13:40:57 <SamB_XP_> rwbarton: how wierd!
13:41:00 <yitz> @help undo
13:41:00 <lambdabot> undo <expr>
13:41:01 <lambdabot> Translate do notation to Monad operators.
13:41:07 <rwbarton> SamB_XP_: edit distance is 2 :)
13:41:12 <SamB_XP_> true, true
13:41:19 <rwbarton> Perhaps 2 is too lenient
13:41:30 <SamB_XP_> why doesn't edit distance weight vowels higher than consonents ?
13:41:37 <monochrom> You can do something like "@unseen" and it is still @seen :)
13:41:46 <SamB_XP_> at least when pronounced differently
13:41:51 <rwbarton> @unseen monochrom
13:41:51 <lambdabot> monochrom is in #haskell. I last heard monochrom speak 13s ago.
13:41:51 <wli> eta, then more reductions somehow
13:42:11 <monochrom> @die x >> y
13:42:11 <lambdabot> unexpected "x": expecting number
13:42:25 <int80_h> on page 41 of YAHT, the filter function is defined. The exercise on the same page wants a similar definition of map. I study the filter definition, and to me it looks exactly like what the map function should be. So I must be confused at what I'm looking at. Could someone step me through whaty's going on? I'm not sure about what I'm missing.
13:42:27 <monochrom> Oh, @die is @dice
13:42:42 <monochrom> @dood x >> y
13:42:42 <lambdabot> x >> y not available
13:42:49 <monochrom> Nevermind.
13:42:57 <rwbarton> @read x >> y
13:42:57 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
13:43:04 <rwbarton> @dodo x >> y
13:43:04 <lambdabot> Plugin `todo' failed with: @todo has no args, try @todo-add or @list todo
13:43:19 <monochrom> @quoteth dons
13:43:19 <lambdabot> dons says: Those who would give up essential type safety, to purchase a little liberty, deserve neither liberty nor type safety.
13:43:34 <monochrom> (That is a better use of the edit distance lenience :)
13:43:53 <Saizan> @src filter
13:43:53 <lambdabot> filter _ []     = []
13:43:53 <lambdabot> filter p (x:xs)
13:43:53 <lambdabot>     | p x       = x : filter p xs
13:43:53 <lambdabot>     | otherwise = filter p xs
13:44:09 <Saizan> int80_h: is that the definition, more or less?
13:44:17 <IWannaLog> I love this citation.
13:44:27 <int80_h> well, it doesn't use guard. It uses if/ then notation
13:44:32 <int80_h> but yeah, that's it
13:44:35 <monochrom> Oh haha, wouldn't it be really nice if @quoteth is re-programmed so it is like @quote except it returns "dons sayeth: ..." :)
13:44:36 <jae686> my haskell skills are really rusty
13:44:54 <monochrom> @quoteth hitherto
13:44:54 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
13:44:58 <Saizan> int80_h: ok, there it's using a predicate to tell if an element should compare in the resulting list or not
13:45:00 <rwbarton> @smote dons
13:45:01 <lambdabot> Maybe you meant: more quote vote
13:45:01 <wli> Where's if' anyway?
13:45:20 <Saizan> int80_h: while map is supposed to use the given function to _transform_ each element
13:45:21 <SamB_XP_> wli: where ?
13:45:31 <SamB_XP_> what do you mean, where is it? it isn't.
13:45:32 <monochrom> @quiet monochrom
13:45:33 <lambdabot> Not enough privileges
13:45:33 <jae686> pattern matching
13:45:37 <pumpkin> wli: in @pl's imagination :o
13:45:42 <rwbarton> @soap monochrom
13:45:42 * lambdabot orders her trained monkeys to punch monochrom
13:45:49 <monochrom>  haha
13:45:52 <Saizan> int80_h: i.e. you want the result of the function in the resulting list, not the original element
13:46:15 <yitz> monochrom: it should be quoth
13:46:21 <int80_h> @src map
13:46:22 <lambdabot> map _ []     = []
13:46:22 <lambdabot> map f (x:xs) = f x : map f xs
13:46:29 <monochrom> Really? OK thanks.
13:46:34 <SamB_XP_> @quoth
13:46:34 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
13:46:47 <jae686> @src foldr
13:46:48 <lambdabot> foldr f z []     = z
13:46:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:46:55 <int80_h> hey, the way map is written, is what I tried to do. I must have gotten the syntax wrong
13:47:07 <wli> filter p (x:xs) = if' (p x) (x:) id $ filter p xs
13:47:09 <Elly> what'd you write?
13:47:21 <athos> :t if'
13:47:22 <lambdabot> Not in scope: `if''
13:47:24 <monochrom> I now want the edit distance to be 3 so you can issue commands in pig latin!
13:47:24 <athos> :t (if')
13:47:26 <lambdabot> Not in scope: `if''
13:47:29 <int80_h> I wrote over it, thinking it was just plain wrong.
13:47:37 <int80_h> let me see if I can recreate it
13:48:00 <yitz> @pl \x y z -> if x then y else z
13:48:01 <lambdabot> if'
13:48:36 <athos> @unpl if'
13:48:37 <lambdabot> if'
13:48:47 <athos> ;]
13:48:54 <tibbe> @unpl fmap . fmap . fmap
13:48:54 <lambdabot> (\ c -> fmap (fmap (fmap c)))
13:49:03 <int80_h> my_Map p [] = []
13:49:04 <int80_h> my_Map p (x:xs) = p x : my_Map p xs
13:49:27 <int80_h> that compiled, but then it broke when I tried to use it
13:49:36 <wli> if', maybe, and something for lists?
13:49:41 <chessguy_work> int80_h, how did you try to use it? it looks right to me
13:49:47 <Saizan> int80_h: that's correct
13:49:53 <IWannaLog> Maybe it was upset you use this self made function
13:50:05 <int80_h> huh, it works now
13:50:13 <int80_h> I have no idea what I did wrong then
13:50:15 <athos> let mymap f = foldr ((:).f) [] in mymap (*2) [1..5]
13:50:22 <athos> > let mymap f = foldr ((:).f) [] in mymap (*2) [1..5]
13:50:24 <lambdabot>   [2,4,6,8,10]
13:50:37 <int80_h> okay, no harm no foul
13:50:46 <chessguy_work> @type let my_Map p [] = [];  my_Map p (x:xs) = p x : my_Map p xs in my_Map (+2) [1..5]
13:50:47 <lambdabot> forall a. (Enum a, Num a) => [a]
13:50:49 <sjanssen> hmm, the "seq x x /= x" myth seems quite popular
13:51:05 <chessguy_work> > let my_Map p [] = [];  my_Map p (x:xs) = p x : my_Map p xs in my_Map (+2) [1..5]
13:51:06 <lambdabot>   [3,4,5,6,7]
13:51:45 <chessguy_work> @type map
13:51:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:52:37 <Stinger_> whats the seq x x/= x myth
13:53:01 <vixey> Stigner_, "myth" meaning it's not true?
13:53:03 <rwbarton> The seq x x /= x myth is that seq x x /= x.
13:53:29 <mux> I like map f = foldr ((:) . f) []
13:53:53 <mux> > let map f = foldr ((:) . f) [] in map (+1) [1..10]
13:53:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:53:56 <sjanssen> Stinger_: the truth is that "seq x x = x"
13:53:57 <vixey> mux, something like fmap f = fold ... f ... f ...
13:54:19 <monochrom> The truth is "no Eq instance found"
13:54:33 <vixey> haha
13:54:53 <sjanssen> monochrom: note I used "=" the second time :)
13:55:11 <yitz> @check \x -> seq x x == x
13:55:13 <lambdabot>   "OK, passed 500 tests."
13:55:22 <yitz> there you have it folks
13:55:26 <monochrom> "seq x x = x" is not the definition used in libraries!
13:55:30 <vixey> yeah QED lol
13:55:30 <chessguy_work> @pl \x y -> e (f x) (f y)
13:55:31 <lambdabot> (. f) . e . f
13:55:45 <chessguy_work> @pl \x y f -> e (f x) (f y)
13:55:46 <lambdabot> (. flip id) . ap . (e .) . flip id
13:55:56 <vixey> @check \x y -> x*y /= 5*7
13:55:57 <lambdabot>   "Falsifiable, after 75 tests:\n5\n7\n"
13:56:00 <chessguy_work> @pl \f x y -> e (f x) (f y)
13:56:00 <lambdabot> flip =<< (((.) . e) .)
13:56:02 <vixey> :((
13:56:03 <mux> you think @pl knows on?
13:56:08 <vixey> @check \x y -> x*y /= 13*7
13:56:09 <lambdabot>   "Falsifiable, after 46 tests:\n-7\n-13\n"
13:56:19 <vixey> humf..... quickcheck learned my trick
13:56:21 <chessguy_work> @type on
13:56:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:56:28 <mux> @pl \f g x y -> f (g x) (g y)
13:56:28 <lambdabot> join . ((flip . ((.) .)) .) . (.)
13:57:13 <mux> @let on' = join . ((flip . ((.) .)) .) . (.)
13:57:14 <lambdabot>  Defined.
13:57:57 <mux> > on' (+) (+1) 2 3
13:57:58 <lambdabot>   7
13:58:21 <yitz> @check \f g x y -> on f g x y == on' f g x y
13:58:22 <lambdabot>   Not in scope: `on''
13:58:33 <chessguy_work> mux, hmm, can you use on' infix?
13:58:36 <IWannaLog> @check a * (b + c) = a * b + a * c
13:58:37 <lambdabot>   Parse error at "=" (column 13)
13:58:43 <IWannaLog> @check a * (b + c) == a * b + a * c
13:58:44 <lambdabot>   "Falsifiable, after 0 tests:\n"
13:58:48 <mux> chessguy_work: I think you can
13:58:51 <monochrom> haha
13:59:08 <mux> > (+)  `on'` (+2) 2 3
13:59:09 <lambdabot>       Overlapping instances for Show (a -> a -> b)
13:59:09 <lambdabot>        arising from a use ...
13:59:23 <monochrom> Is that somehow an empty data type? Falsified with 0 witnesses?
13:59:30 <chessguy_work> > (+) (+2) `on'` 2 3
13:59:31 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
13:59:31 <lambdabot>        Exp...
13:59:36 <mux> mmmm
13:59:41 <sebaseba> ?users
13:59:41 <lambdabot> Maximum users seen in #haskell: 674, currently: 667 (99.0%), active: 26 (3.9%)
13:59:42 <mux> works fine in a function context
13:59:57 <yitz> @check \f g x y -> on f g x y == join . ((flip . ((.) .)) .) . (.) f g x y
13:59:59 <lambdabot>       Overlapping instances for Show (b -> b)
13:59:59 <lambdabot>        arising from a use of `m...
14:00:03 <mux> > sortBy (compare `on'` snd) [(1,2),(2,1),(3,1)]
14:00:05 <lambdabot>   [(2,1),(3,1),(1,2)]
14:00:06 <chessguy_work> mux, i don't recall the exact infix transformation rules
14:00:20 <rwbarton> > ((+)  `on'` (+2)) 2 3
14:00:21 <lambdabot>   9
14:00:31 <vixey> join . ((flip . ((.) .)) .) . (.)  -- this isn't very good mux
14:00:35 <vixey> :t (~>)
14:00:36 <lambdabot> Not in scope: `~>'
14:00:37 <mux> (for the sake of people reading, using "comparing" here would have been even more appropriate, and cute)
14:00:43 <yitz> @check \f g x y -> on f g x y == (join . ((flip . ((.) .)) .) . (.) f g x y)
14:00:44 <lambdabot>       Overlapping instances for Show (b -> b)
14:00:44 <lambdabot>        arising from a use of `m...
14:00:50 <vixey> mux, I'm sure that you could do it almost pointfree much better than that
14:00:57 <mux> vixey: well that's @pl :-)
14:01:39 <rwbarton> @check \f g x y -> on f g x y == (join . ((flip . ((.) .)) .) . (.)) f g x y
14:01:40 <lambdabot>       Overlapping instances for Show (a -> b)
14:01:40 <lambdabot>        arising from a use of `m...
14:02:01 <mux> you'd have problems having QuickCheck generate arbitrary functions here anyways, I think
14:02:19 <rwbarton> @check \f x -> f x == 1
14:02:20 <lambdabot>       Overlapping instances for Show (t -> a)
14:02:20 <lambdabot>        arising from a use of `m...
14:02:33 <SamB_XP_> apparantly lambdabot's instance for Show (a -> b) is conflicting with *check's ?
14:02:33 <rwbarton> I think it's because it might need to print the result if there's a failed test
14:02:37 <lispy> I keep getting highlighted in this channel, but I never see who is talking to me
14:02:50 <CakeProphet> @src execState
14:02:50 <lambdabot> Source not found. Sorry.
14:02:53 <rwbarton> SamB_XP_: right
14:03:02 <yitz> lispy: grep the logs
14:03:10 <mux> execState = snd . runState
14:03:26 <CakeProphet> I know, was just wondering if that's how it's actually defined.
14:03:42 <vixey> CakeProphet in GHC ?
14:03:47 <CakeProphet> yes
14:05:00 <yitz> @type snd . runState
14:05:01 <lambdabot>     Couldn't match expected type `(a, b)'
14:05:01 <lambdabot>            against inferred type `s -> (a1, s)'
14:05:01 <lambdabot>     Probable cause: `runState' is applied to too few arguments
14:05:18 <vixey> CakeProphet: evalState m s = fst (runState m s)
14:05:18 <vixey> execState m s = snd (runState m s)
14:05:29 <CakeProphet> ah. okay.
14:05:40 <vixey> CakeProphet: ( grep runState ~/code/implementations/ghc-6.11.20081031/libraries/mtl/Control/Monad/State/Lazy.hs )
14:05:40 * CakeProphet wasn't sure if it did something special.
14:05:42 <mux> right
14:05:45 <yitz> @type \x -> snd . runState x
14:05:46 <lambdabot> forall a b. State b a -> b -> b
14:06:02 <dmead> yitz, try $ instead of .?
14:08:20 <unigee> hi, does anyone know why I get add.hs:1:6: parse error on input `\' when I attempt to :l add.hs in ghci? im using a intel mac osx
14:08:33 <dmead> wanna post your source?
14:08:35 <chessguy_work> unigee, can you paste your file
14:08:39 <chessguy_work> !paste
14:08:42 <chessguy_work> @paste
14:08:42 <unigee> add ab = a + b
14:08:42 <dmead> ?paste
14:08:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:08:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:08:46 <unigee> thats all it contains
14:08:46 <yitz> @type (snd .) . runState
14:08:46 <yitz> dmead: no, the opposite. add another .
14:08:47 <lambdabot> forall s a. State s a -> s -> s
14:08:56 <dmead> yitz, ah
14:09:02 <SamB_XP> unigee: are you sure you're in the right directory ?
14:09:24 <dmead> anyone here know abstract algebrah?
14:09:26 <unigee> well i browse to it in terminal, and type ghci add.hs
14:09:29 <dmead> *brah*
14:09:39 <dmead> unigee, source
14:09:42 <dmead> ?paste
14:09:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:09:47 <unigee> just to let you know, im very new to haskell and mac osx, so i might be missing something obvious
14:09:54 <dmead> okay, so paste your source
14:09:56 <dmead> so we can see
14:09:59 <chessguy_work> dmead, i think most people here who have infant children have already taught it to them :)
14:10:11 <SamB_XP> unigee: so when you type cat add.hs, you see the expected results ?
14:10:13 <newsham> vixey: alive?
14:10:27 <unigee> http://hpaste.org/13646 thats the source
14:10:31 <dmead> chessguy_work, well i wanna ask if it's as simple as it seems or am i missing something
14:10:52 <yitz> dmead: right, it's always one way or the other. fastest is just try one rather than think. that's what I do. :)
14:10:55 <chessguy_work> dmead, go for it
14:11:08 <unigee> oh dammit, thanks SamB_XP
14:11:13 <chessguy_work> ##math is another good place
14:11:14 <dmead> chessguy_work, i'm reading and discussion that wiki page on category theory with a mathmatician buddy of mine
14:11:22 <dmead> and we're just throwing some ideas around
14:11:23 <unigee> my add.hs is containing rtf formatting
14:11:29 <SamB_XP> unigee: That'
14:11:31 <SamB_XP> d do it!
14:11:34 <SamB_XP> hehehehe
14:11:36 <opqdonut> :D
14:11:41 <dmead> do we use monads in haskell because monads (and categories in general) just describe whatever you want them to?
14:11:44 <unigee> i feel stupid lol
14:11:45 <SamB_XP> try using a text editor next time ;-P
14:12:00 <chessguy_work> (like emacs!)
14:12:09 <dmead> or, is it because we need at least *SOME* way to get a hold on IO in the type system
14:12:09 * chessguy_work dives for cover
14:12:12 <yitz> why are you all laughing? if it were latex formatting instead, ghci would accept it.
14:12:15 <dmead> be it monads or something else
14:12:21 <SamB_XP> well, you did say you were new to mac OS X, so we'll just put it down to mistaking a word-processor for a text editor
14:12:21 <ddarius> dmead: neither
14:12:23 <dmead> i'm asking if monads were chosen for a particular reason
14:12:27 <athos> ?users
14:12:28 <lambdabot> Maximum users seen in #haskell: 674, currently: 669 (99.3%), active: 29 (4.3%)
14:12:31 <opqdonut> dmead: monads are a choice
14:12:36 <ddarius> 674?!
14:12:38 <pumpkin> wow
14:12:39 <SamB_XP> yitz: if it were latex, he'd have known it were there ;-P
14:12:40 <dmead> is there a rationale for it?
14:12:41 <opqdonut> uniqueness typing is another one
14:12:46 <pumpkin> is someone spamming on our behalf or something?
14:12:47 <dmead> other than preseving purity
14:12:48 <newsham> dmead: monads are used because they work well for expressing things like IO
14:12:55 <dmead> right, but lots of things could
14:12:58 <newsham> although some people are looking for alternatives that dont rely on monads as much
14:13:01 <opqdonut> well monads are implementable in typeclassed hindley-milner
14:13:01 <dmead> why monads is what i'm asking
14:13:04 <chessguy_work> dmead, Monads express well a lot of idioms in haskell
14:13:11 <SamB_XP> dmead: well, they worked better than the lists of commands and responses that had been used before
14:13:15 <IWannaLog> Monads are magic
14:13:18 <dmead> chessguy_work, well thats becoming circular at this point
14:13:19 <ddarius> dmead: They were chosen because they nicely capture the semantics of various effects.
14:13:24 <pumpkin> IWannaLog: there's always a trick
14:13:24 <dmead> hmm
14:13:27 <francis> monads are a greek myth
14:13:30 <pumpkin> IWannaLog: nothing is truly magic
14:13:36 <dmead> is it true that categories can capture most anything?
14:13:38 <IWannaLog> Monads are.
14:13:41 <chessguy_work> dmead, library development is a bit circular
14:13:42 <dmead> that it's not just IO in programming
14:13:44 <dmead> but lots of things
14:13:47 <IWannaLog> dmead: Yes it's true.
14:14:01 <newsham> dmead: monads can represent decomposing an imperative program into the first half, its resulting value and the next half that uses its resulting value and any implicit state
14:14:14 <dmead> doesn't that imply that there could be a better way to put IO in the type system other than monads?
14:14:16 <intoverflow> dmead: someone noticed that monads were very good for capturing many idioms in programming, and that they happen to work well in typed settings
14:14:17 <SamB_XP> less danger of head explosion, less plumbing, more performance, lack of neccessity to create an ADT for all possible imperative effects ...
14:14:19 <newsham> dmead: which works well for representing an imperative program in a pure language
14:14:22 <yitz> pumpkin: dons has been spamming on our behalf for a long time
14:14:25 <ddarius> dmead: Most things form categories.  That's why category theory is interesting.
14:14:30 <pumpkin> yitz: but that's the good kind of spam
14:14:38 <yitz> pumpkin: yep :)
14:14:43 <pumpkin> but it's gone up maybe by 80 in the last week
14:14:44 <dmead> reading
14:14:44 <dmead> sec
14:14:52 <pumpkin> is that just because dons announced we'd crossed 600 on cafe?
14:14:56 <chessguy_work> i think it's also important to note that there are many functions we can write against generic Monads, too
14:14:57 <pumpkin> and more cafe-ers came along?
14:15:00 <IWannaLog> Is "yep" a common word in English ?
14:15:05 <Stinger_> yep
14:15:10 <IWannaLog> :D
14:15:10 <pumpkin> IWannaLog: in spoken english, at least
14:15:14 <ddarius> IWannaLog: In informal English, yes.
14:15:18 <newsham> yup is informal slang
14:15:21 <yitz> pumpkin: maybe dons wrote a script that logs on random names
14:15:22 <IWannaLog> Very strange.
14:15:22 <pumpkin> which irc often approximates
14:15:27 <chessguy_work> i prefer "ya"
14:15:28 <newsham> like saying "way" in french instead of "wee"
14:15:37 <dmead> ddarius, (et al) sure lots of things form categories, and monads fit nicely with the H-M tye system
14:15:46 <SamB_XP> chessguy_work: like the postman in OoT?
14:15:46 <pumpkin> yitz: Maybe he did, Either that, or we're Just that awesome
14:15:51 <dmead> does that mean it's the best way, or just what we've got thus far
14:15:52 <dmead> ?
14:15:53 <SamB_XP> er.
14:15:58 <ddarius> dmead: The latter.
14:15:59 <SamB_XP> I mean Majora's Mask
14:16:05 <chessguy_work> SamB_XP, don't know that one
14:16:06 <SamB_XP> those two are so easy to get mixed up
14:16:11 <dmead> who said majoras mask
14:16:13 <vixey> newsham, and kicking!
14:16:15 <dmead> i <3 zelda
14:16:24 <ddarius> Everyone <3s Zelda.
14:16:32 <SamB_XP> apparantly not chessguy_work
14:16:34 <newsham> dmead: the best way is FRP, of course!  ;-)
14:16:37 <dmead> i just finished the side quests in chrono trigger
14:16:42 <dmead> i'm gonna say it
14:16:47 <dmead> chrono trigger > zelda
14:16:49 <chessguy_work> dmead, like everything mathematical/programmatical, it's the best until someone comes up with something better
14:16:51 <ddarius> SamB_XP: I never played Majoras' Mask.
14:16:55 <newsham> vixey: any ideas on how to push this towards the next goal (see XXX's and comments inline)  http://hpaste.org/13620#a1
14:16:57 <wchogg> dmead : they're very different games :p
14:17:04 <SamB_XP> ddarius: why not ?
14:17:08 <ddarius> SamB_XP: From what I hear (and from personal experience) A Link To The Past was the best.
14:17:09 <newsham> i want to build two things that have quite different types
14:17:17 <SamB_XP> ddarius: perhaps
14:17:18 <dmead> i thought majoras mask was good
14:17:22 <ddarius> SamB_XP: Because I stopped playing video games long before it came out.
14:17:24 <dmead> but twilight princess was much better
14:17:36 <newsham> one kinda feels more natural left->right and the other right->left.
14:17:37 <SamB_XP> dmead: don't spoil it
14:17:38 <ddarius> dmead: I heard one of those two was good, the other one meh.
14:17:46 <IWannaLog> Link's awakening is the best.
14:17:58 <IWannaLog> But A Link to The Past is good
14:18:05 <SamB_XP> IWannaLog: I have a bit of a problem with the ending for LA
14:18:09 <vixey> newsham, me and ski_ had a long chat about this technique earlier today btwdata Mix m where
14:18:10 <vixey> oops
14:18:12 <dmead> i thought link's awakening was awful
14:18:20 <SamB_XP> I mean, destroying the world is sure heroic, yes?
14:18:21 <athos> , src 'get
14:18:23 <lunabot>  luna: Ambiguous occurrence `get'
14:18:26 <dmead> if you haven't played twilight princes yet
14:18:27 <IWannaLog> SamB_XP: The most beautiful one. (From all the video games world)
14:18:28 <dmead> treat yourself
14:18:33 <athos> , src 'Control.Monad.State.get
14:18:34 <vixey> newsham, also one thing that might work (just hthrowing it out here) is,  data Mix m where  ~~> data Mix mu nu where ...
14:18:35 <lunabot>  luna: Not in scope: `Control.Monad.State.get'
14:18:38 <athos> ah ok
14:18:40 <athos> :F
14:18:52 <vixey> newsham, with mu building up left-to-right and nu building up right-to-left
14:18:53 <IWannaLog> SamB_XP: He didn't destroy the world
14:18:55 <SamB_XP> anyway, I only have 5 hearts so far in Twilight Princess, so please no spoilers
14:18:58 <SamB_XP> IWannaLog: yeah he did
14:19:08 <newsham> vixey: *nod* I was thinking that something like that might work
14:19:11 <newsham> but havent tackled it yet
14:19:12 <vixey> newsham, but there's a chance that might not be enough,
14:19:13 <SamB_XP> where by world, I mean island
14:19:14 <newsham> (it scares me :)
14:19:51 <IWannaLog> SamB_XP: He must awake and not live forever in his nightmare
14:20:00 <dmead> SamB_XP, it's good shit... try to play it with the component cables on a big tv if you can
14:20:01 <leimy> 666 members!?
14:20:03 <leimy> phear
14:20:04 <SamB_XP> IWannaLog: but all those poor innocent figments
14:20:12 <chessguy_work> SamB_XP, you mean "where world = island"?
14:20:15 <Badger> uhoh
14:20:16 <athos> , src ''StateT
14:20:18 <dmead> SamB_XP, it gets cinimaticy
14:20:19 <IWannaLog> no one is innocent
14:20:20 <newsham> Marsh o -> Mix (o->r) r -> Mix r (o->r)    perhaps?
14:20:22 <lunabot>  newtype StateT s m a = StateT {runStateT :: (s -> m ((a, s)))}
14:20:23 <chessguy_work> @losers
14:20:23 <lambdabot> Maximum users seen in #haskell: 674, currently: 666 (98.8%), active: 33 (5.0%)
14:20:24 <Badger> he's quite right too.
14:20:30 <dmead> 666
14:20:31 <dmead> evil
14:20:39 <newsham> one side peels em off while the other one piles them on?
14:20:47 <yitz> dmead: quick, boot someone
14:20:50 <SamB_XP> dmead: well, how about I just play on the TV with stereo and where text is readable ?
14:20:51 <Badger> Haskell programmers: prepare to go to tell.
14:20:55 <Badger> or hell
14:21:00 <chessguy_work> @hoogle tell
14:21:01 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
14:21:01 <lambdabot> System.IO hTell :: Handle -> IO Integer
14:21:02 <dmead> xD
14:21:03 <Badger> whichever you'd like, typos allowing
14:21:06 <chessguy_work> that doesn't seem so bad
14:21:10 <Badger> well
14:21:17 <Badger> you could go to unsafePerformIO instead
14:21:17 <vixey> newsham, maybe to brittle, so like:  Mix (o->r) j -> Mix r (o->j)
14:21:19 <SamB_XP> dmead: as opposed to the one which I keep upsetting my dad by suggesting be thrown away
14:21:20 <Stinger_> but its in the IO monad!
14:21:37 <vixey> newsham, but it could be just right.. hard to tell. You have to sort of program the function(s) and the data simultaneously
14:21:39 <chessguy_work> and there shall be weeping and gnashing of types?
14:21:44 <dmead> :P
14:21:55 <Badger> Sounds like haskell monopoly.
14:22:06 <Badger> Go directly to unsafePerformIO
14:22:22 <athos> :t evalStateT
14:22:23 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
14:22:29 <SamB_XP> dmead: anyway, all we have is the composite cable for our gamecube, so ...
14:22:32 <Badger> agh
14:22:33 <chessguy_work> "do not exit IO. go directly to the REPL, do not pass any parameters or continuations"
14:22:34 <Badger> 665.
14:22:48 <Badger> hah
14:23:24 <Badger> @remember monopoly do not exist IO. go directly to the REPL, do not pass any parameters or continuations
14:23:25 <lambdabot> It is stored.
14:23:29 <Badger> oh
14:23:30 <Badger> damn.
14:23:36 <Badger> @remember monopoly do not exit IO. go directly to the REPL, do not pass any parameters or continuations
14:23:48 <lambdabot> It is forever etched in my memory.
14:23:48 <Badger> agh.
14:23:51 <Badger> oh good.
14:24:04 <Badger> Now to hope it overwrote the first one. :)
14:24:08 <chessguy_work> @quote monopoly
14:24:08 <lambdabot> monopoly says: do not exit IO. go directly to the REPL, do not pass any parameters or continuations
14:24:20 <chessguy_work> @quote monopoly
14:24:20 <chessguy_work> @quote monopoly
14:24:20 <lambdabot> monopoly says: do not exit IO. go directly to the REPL, do not pass any parameters or continuations
14:24:21 <chessguy_work> @quote monopoly
14:24:21 <lambdabot> monopoly says: do not exit IO. go directly to the REPL, do not pass any parameters or continuations
14:24:21 <lambdabot> monopoly says: do not exist IO. go directly to the REPL, do not pass any parameters or continuations
14:24:36 <chessguy_work> > fail
14:24:36 <vixey> newsham, the first type is  (a -> X) -> (b -> X) -> ... -> (a -> b -> ... -> X), right? what's the second?
14:24:37 <lambdabot>       Overlapping instances for Show (String -> m a)
14:24:37 <lambdabot>        arising from a us...
14:25:05 <yitz> > fail "oops"
14:25:06 <lambdabot>       No instance for (Show (m a))
14:25:06 <lambdabot>        arising from a use of `show' at <in...
14:25:11 <newsham> vixey: see the type series in the comments at http://hpaste.org/13620#a1
14:25:18 <newsham> right under the "unMix" function
14:25:47 <chessguy_work> > fail "oops" :: [String]
14:25:48 <lambdabot>   []
14:26:00 <newsham> right are the functions you menttion, left are the other ones I want to make using <*> as a combiner
14:26:15 <yitz> > runState (fail "oops") 0
14:26:16 <lambdabot>   * Exception: oops
14:26:29 * chessguy_work giggles
14:26:47 <dmead> SamB_XP, i got this cheapo 15 dollar cable
14:26:49 <vixey> mm I don't totally understand it
14:26:53 <dmead> it has component on one end
14:27:05 <dmead> and splits into gamecube wii xbox etc
14:27:05 <chessguy_work> @let go o = runstate (fail o) 0
14:27:06 <lambdabot>  <local>:4:7: Not in scope: `runstate'
14:27:13 <chessguy_work> @let go o = runState (fail o) 0
14:27:14 <lambdabot>  Defined.
14:27:21 <chessguy_work> go "oops!"
14:27:23 <vixey> is it just the unmarshallers type?
14:27:31 <SamB_XP> dmead: not like I'd have anything to connect the component to anyway
14:27:36 <chessguy_work> > go "oops!"
14:27:38 <lambdabot>   * Exception: oops!
14:27:54 <newsham> vixey: yup.
14:27:56 <vixey> so something like  (X -> Maybe a) -> (X -> Maybe b) -> ... -> ((a -> b -> ... -> o) -> X -> Maybe o)
14:28:05 <vixey> roughly ?
14:28:34 <newsham> vixey: where as for the marshaller we build up    Marsh a -> (a -> ... -> String)
14:28:48 <yitz> @let go' = ("* Exception: "++)
14:28:49 <lambdabot>  Defined.
14:28:50 <newsham> for the unmarshaller we build up   Marsh a -> Get foo -> Get (a -> foo)
14:28:58 <yitz> > go' "oops!"
14:28:59 <lambdabot>   "* Exception: oops!"
14:29:03 <newsham> err.. sorry..   Marsh a -> Get (a -> foo) -> Get foo
14:29:07 <pumpkin> yitz: but his had no quotes
14:29:11 <chessguy_work> yitz, nice try
14:29:20 <yitz> hmm, how do you do that again?
14:29:34 <newsham> vixey: ie. in the "goal:" line shoudl build up and return a pair that is a "Marsh Foo"
14:29:45 <yitz> @run "oops"
14:29:46 <lambdabot>   "oops"
14:29:50 <pumpkin> @let go'' x = text ("*Exception: " ++ x)
14:29:50 <yitz> na
14:29:51 <lambdabot>  Defined.
14:29:58 <pumpkin> > go'' "whoops"
14:30:00 <lambdabot>   *Exception: whoops
14:30:04 <pumpkin> double single quotes are awesome
14:30:07 <vixey> newsham, just expanding a bit, is it: Marsh a -> Marsh b -> ... -> (a -> b -> ... -> String)?
14:30:08 <yitz> yay!
14:30:41 <newsham> vixey: no, thats the one we already solved.  which builds  Marsh a -> Mix b -> Mix (a -> b)
14:30:56 <newsham> with end result   a -> b -> ... -> String
14:31:04 <vixey> ok
14:31:11 <newsham> this one starts with  Get (a -> b -> ... -> Foo) and ends up with Get Foo
14:31:17 <vixey> aha!
14:31:34 <vixey> add to strip off a a -> ..., you need something like  (X -> Maybe a)?
14:31:37 <newsham> which is basically:   Foo <$> getInt <*> getString <*> getInt
14:31:50 <vixey> right, I see
14:32:07 <vixey> ((Foo <$> getInt) <*> getString) <*> getInt   is that how these things parse?
14:32:20 <roconnor> vixey: yes, like function application
14:32:35 <vixey> oh
14:32:36 <newsham> (((pure Foo <*> getInt) <*> getString) <*> getInt)
14:32:42 <vixey> did you see my Collect macro?
14:32:58 * pumpkin has never used pure
14:33:00 <roconnor> are you asking me?
14:33:01 <pumpkin> does that mean I'm impure?
14:33:20 <wchogg> We are all impure in the great Monad of Life.
14:33:25 <wchogg> Repent!
14:33:28 <roconnor> pumpkin: <$> seems to capture a lot of the use of pure
14:33:29 <IWannaLog> even Haskell
14:33:35 <vixey> KEEP :: m o -> COMMAND m x y -> COMMAND m (o -> x) y
14:33:38 <pumpkin> roconnor: yeah, I use <$> occasionally
14:33:42 <vixey> is the only really relevant bit
14:33:49 <vixey> (==>) :: Monad m => COMMAND m mu nu -> mu -> m nu
14:33:50 <newsham> unMix2 accum End = accum;  unMix2 accum ((get,put) :-> m) = unMix2 (accum <*> get) m   <- something like that
14:33:54 <vixey> KEEP o m ==> f = do i <- o ; m ==> (f i)
14:33:56 <newsham> in fact that might work if I can get the types right
14:34:13 <Peaker> roconnor: I think maybe its nicer to use:  pure f <*> g <*> h <*> ... than to use <$> at the beginning of the sequence
14:34:30 <vixey> newsham, but this one works like:  KEEP getInt! KEEP getString! KEEP getInt! STORE==> Foo
14:34:35 <roconnor> Question from my advisor: is there anything the monadic interface to the reader monad can define that the applicative interface cannot define?
14:34:41 <vixey> newsham, which is the same thing really but backwards
14:35:22 <Peaker> roconnor: If you're specific to the reader, then you can just make any reader you want with \x -> ... ?
14:35:23 <roconnor> With the reader monad miffy===iffy, so the cannoical example of the difference between applicative functors and monads doesn't apply to the reader moand.
14:35:57 <roconnor> Peaker, hmm, perhaps my question is not well defined then.
14:36:30 <roconnor> Peaker, I guess I sort of want to compare all the function you can make with bind and return, and compare that with all the functions you can make with pure and <*>
14:36:49 <roconnor> is it fair to ask if this set is the same (when specifically considering the reader monad)?
14:37:03 <newsham> collect macro?
14:37:05 <roconnor> but maybe it isn't fair
14:37:09 <arjanb> is it normal for ghci to crash with a stack overflow when running code that does lots of knot tying? i "solved" it by making every tuple pattern lazy but that's not pretty
14:37:21 <vixey> just an alternate syntax for do notation
14:37:36 <roconnor> Peaker, I'll try to think about what question I want to ask
14:37:39 <vixey> I don't like   do  a <- a ; b ; c <- c ; ... ; return (f a c ..)
14:37:42 <rwbarton> roconnor: with only bind and return, you can't get the data out of the reader
14:37:50 <vixey> but it comes up a lot in parsers
14:38:00 <newsham> ahhh.
14:38:10 <newsham> and why not use applicative?
14:38:12 <vixey> but that seems very similar to this marshall thing
14:38:15 <roconnor> rwbarton: that's fine.
14:38:18 <vixey> because of ; b ;
14:38:30 <newsham> ahh
14:38:34 <vixey> maybe there is a way with applicative but I was having fun with the GADT technique :p
14:38:44 <newsham> thats what counts :)
14:39:02 <EvilTerran> vixey, "f <$> a <*> (b *> c) ..."
14:39:23 <EvilTerran> but don't let that stop you :)
14:40:19 <rwbarton> roconnor: oh, you mean out of bind and return and some other provided monadic actions?
14:43:28 <rwbarton> roconnor: I think the answer to your question is yes, and that's it's not true for other monads.
14:46:42 <twanvl> you can always do without bind in the reader monad by just cheating:  a >>= b  -->  (\e -> b (a e) e) <$> ask
14:47:31 <rwbarton> roconnor: Let m = ((->) r), and suppose you're given x1 :: m a1, ..., xn :: m an.  Then the only values you can hope to construct out of x1, ..., xn using bind and return are of the form g <$> ((,...,) <$> x1 <*> ... <*> xn) for some g :: (a1, ..., an) -> b
14:47:51 <rwbarton> roconnor: because you just don't have any other information about the value of type r stored in the reader
14:48:55 <mattpodwysocki> only two hours til Real World Haskell book club starts. I guess I need to get into gear
14:49:45 <wchogg> mattpodwysocki : anything particular agenda or just going through chs1 & 2?
14:50:04 <mattpodwysocki> wchogg : I'm open to discussion on this
14:50:06 <blueonyx> yay rwh book club :D
14:50:28 <mattpodwysocki> wchogg : I'd prefer to have a fluid discussion rather than line by line
14:50:46 <wchogg> mattpodwysocki : sounds reasonable
14:50:53 <ddarius> Hydrodynamics woo!
14:51:33 <roconnor> rwbarton: all we need now is a rigourous proof.
14:51:35 <roconnor> :)
14:51:55 <rwbarton> roconnor: yes :)
14:52:12 <gbacon> I have a StateT and a list of inputs that I want to feed it in sequence, so I'm after a cross between mapM and replicateM
14:53:11 <gbacon> well, more of an iterateM, but nothing in Control.Monad.State seems to do what I want
14:53:42 <teko> #haskell has grown alot
14:54:06 <rwbarton> roconnor: is it possible to rewrite >>= in terms of pure and <*> without using ask?
14:54:10 <ddarius> We gained two times as many people in the last week as were here when I first joined.
14:55:22 <ddarius> rwbarton: Not without using some other operation.
14:55:29 <mattpodwysocki> ddarius : yeah, it's crazy around 300 people
14:55:34 <mattpodwysocki> I couldn't believe it myself
14:55:42 <ddarius> Otherwise that would be a proof that Applicative => Monad
14:56:18 <EvilTerran> ?type mapM
14:56:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:56:25 <twanvl> gbacon: it is not clear from your description what you are trying to do, what kind of 'inputs' do you have? And why replicateM or mapM?
14:56:42 <not_much> @source span
14:56:43 <lambdabot> span not available
14:56:50 <EvilTerran> ?src span
14:56:50 <lambdabot> Source not found. Take a stress pill and think things over.
14:56:58 <rwbarton> ddarius: Maybe the formula for >>= could have the right type for every Applicative, but not always satisfy the monad laws?  I dunno, seems kind of unlikely.
14:57:57 <gbacon> twanvl: ultimately, I have a StdGen I'm trying to thread to all interested parties
14:58:45 <rwbarton> :t mapM (runStateT ?s)
14:58:46 <lambdabot> forall a (m :: * -> *) a1. (Monad m, ?s::StateT a m a1) => [a] -> m [(a1, a)]
14:59:15 <rwbarton> gbacon: is that what you want?
14:59:26 <EvilTerran> gbacon, and the StdGen's in the state of the monad?
14:59:33 <gbacon> EvilTerran: correct
14:59:39 <EvilTerran> gbacon, "sequence"
14:59:42 <gbacon> rwbarton: no, that throws away the StdGen
14:59:56 <EvilTerran> unless you mean you want to thread it in parallel
15:01:16 <gbacon> EvilTerran: no, sequentially
15:02:08 <rwbarton> gbacon: let me try again :) you have an a -> StateT g m b and a list of [a], and a g? and you want an m [b]?
15:02:27 <EvilTerran> > runState (sequence [(,) <$> get <*> put 1, get, modify (+1) >> get]) 1
15:02:28 <lambdabot>       Occurs check: cannot construct the infinite type: s = (s, ())
15:02:28 <lambdabot>        Ex...
15:02:34 <EvilTerran> hm
15:02:39 <gbacon> rwbarton: yes, but I need to preserve the state across iterations
15:02:50 <gbacon> rwbarton: I'm trying to maintain a StdGen
15:02:53 <rwbarton> gbacon: I get it now
15:03:14 <rwbarton> :t runStateT (mapM ?f)
15:03:15 <lambdabot>     Couldn't match expected type `StateT s m a'
15:03:15 <lambdabot>            against inferred type `[a1] -> m1 [b]'
15:03:15 <lambdabot>     In the first argument of `runStateT', namely `(mapM ?f)'
15:03:25 <rwbarton> :t runStateT (mapM ?f ?as)
15:03:26 <lambdabot> forall a s (m :: * -> *) b. (Monad m, ?as::[a], ?f::a -> StateT s m b) => s -> m ([b], s)
15:03:27 <EvilTerran> > runState (sequence [liftM2 const get (put 1), get, modify (+1) >> get]) 1
15:03:28 <lambdabot>   ([1,1,2],2)
15:03:46 <EvilTerran> > runState (sequence [liftM2 const get (put x), get, modify f >> get]) y
15:03:47 <lambdabot>   ([y,x,f x],f x)
15:03:47 <leimy> Well I've got an erlang program talking to a haskell one
15:03:53 <leimy> and no wormholes opened up
15:04:05 <EvilTerran> gbacon, does that look like what you want?
15:04:17 <bhurt> OK, Haskell just blew my mind again.
15:04:33 <gbacon> EvilTerran: maybe :-)
15:04:36 <bhurt> :t foldr ( . ) id
15:04:37 <lambdabot> forall a. [a -> a] -> a -> a
15:05:09 <EvilTerran> ?src sequence
15:05:10 <lambdabot> sequence []     = return []
15:05:10 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:05:10 <lambdabot> --OR
15:05:10 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:05:26 <rwbarton> gbacon: how about my :t runStateT (mapM ?f ?as) above
15:06:31 <gbacon> is ?f sugar for \f -> ... f ... ?
15:06:42 <EvilTerran> gbacon, kinda
15:07:18 <EvilTerran> ?type sequence -- does this look like the type you want, gbacon?
15:07:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:07:23 <gbacon> rwbarton: won't mapM start at the initial state each go-round?
15:07:36 <EvilTerran> ?src mapM
15:07:36 <lambdabot> mapM f as = sequence (map f as)
15:07:37 <rwbarton> gbacon: no, because it's in the StateT g m monad
15:07:48 <EvilTerran> sequence carries the state through the list from right-to-left
15:07:52 <EvilTerran> mapM is in terms of sequence :)
15:07:58 <EvilTerran> er, from left to right
15:07:59 <EvilTerran> even
15:08:05 <rwbarton> EvilTerran: you had me worried there :P
15:10:09 <cadabra> I have a string like "\"foo\"", \"bar\"". How can get a and b, such that a="foo" and b="bar"?
15:10:48 <cadabra> I think I'd like a variant of `read' that tells me the end of input, or something like that.
15:10:50 <ddarius> a = read "\"foo\""
15:11:17 <gbacon> EvilTerran, rwbarton: thanks for your help
15:11:23 <EvilTerran> > reads "\"foo\""
15:11:24 <lambdabot>   []
15:11:34 <EvilTerran> > reads "\"foo\" and then some" :: [(String,String)]
15:11:35 <lambdabot>   [("foo"," and then some")]
15:11:49 <EvilTerran> > reads "9000, and then some" :: [(Int,String)]
15:11:51 <lambdabot>   [(9000,", and then some")]
15:11:58 <pumpkin> OVER 9000!!!
15:11:58 <EvilTerran> cadabra, like that?
15:12:03 <EvilTerran> pumpkin, :D
15:12:05 <Heffalump> > read ("[" ++ "\"foo\"", \"bar\"" ++ "]") :: [String]
15:12:07 <lambdabot>   <no location info>: parse error on input `++'
15:12:07 <cadabra> Oh sweet.
15:12:15 <Heffalump> > read ("[" ++ "\"foo\", \"bar\"" ++ "]") :: [String]
15:12:17 <lambdabot>   ["foo","bar"]
15:12:28 <pumpkin> > over9000
15:12:29 <lambdabot>   9001
15:12:48 <Heffalump> > fix over
15:12:49 <lambdabot>   Not in scope: `over'
15:12:56 <pumpkin> > text $ "ISO" ++ (show over9000)
15:12:57 <lambdabot>   ISO9001
15:13:54 <Badger> hah!
15:13:58 <Badger> oh dear
15:15:00 <Badger> :t 100
15:15:01 <lambdabot> forall t. (Num t) => t
15:15:14 <Badger> d'oh, not what I meant.
15:15:28 <pumpkin> :t over9000
15:15:29 <lambdabot> forall t. (Num t) => t
15:15:49 <pumpkin> > over9000^over9000
15:15:50 <lambdabot>   372516978608691896156618398958441354557742800117026961069253586618876593405...
15:15:58 <pumpkin> > length . show $ over9000^over9000
15:16:00 <lambdabot>   35593
15:16:04 <pumpkin> wow :)
15:16:10 <pumpkin> over 35000!
15:16:40 <__Ali__> is haskell a good language for scientific programming? I cannot see any numerical libs
15:16:49 <ddarius> > length . show $ 35001 ^ 35001
15:16:50 <lambdabot>   159048
15:16:54 <pumpkin> @faq can haskell do scientific programming?
15:16:55 <lambdabot> The answer is: Yes! Haskell can do that.
15:17:09 <ddarius> __Ali__: You're clearly not looking or looking in the wrong place.
15:17:28 <pumpkin> __Ali__: what kind of numerical libs are you looking for?
15:17:32 <IWannaLog> @faq Can haskell do cofe ?
15:17:32 <lambdabot> The answer is: Yes! Haskell can do that.
15:17:34 <Asztal> > logBase 10 159048 * 159048
15:17:35 <lambdabot>   827292.6591103204
15:17:35 <Draconx> @faq can Haskell compute the busy beaver function?
15:17:36 <lambdabot> The answer is: Yes! Haskell can do that.
15:17:40 <pumpkin> some things aren't really there
15:17:41 <__Ali__> ddarius: I looked in the database of haskell.org
15:18:12 <pumpkin> __Ali__: "scientific programming" is a rather broad term :P
15:18:35 <__Ali__> pumpkin: i'm comparing the numerical interfaces in python with the one of haskell, and it seems haskell doesn't have much?
15:18:57 <pumpkin> __Ali__: if you actually told us what was supposedly missing, we might be able to tell you whether it was :)
15:18:58 <monochrom> http://hackage.haskell.org/packages/archive/pkg-list.html  Do not just click on "numeric" and conclude there is nothing. Some other things (like the matrix library) are under some other groups.  Do a keyword search instead.
15:19:07 <__Ali__> pumpkin: linear algebra, PDE solvers, optimisers, symbolic manipulations,...
15:19:39 <pumpkin> linear algebra is there, haven't seen much PDE but maybe there is, optimizers sadly aren't (I've looked, and haven't found any)
15:20:23 <mreh> how do you do data validation, in particular, validating a pattern variable is a character?
15:20:27 <Pseudonym> The thing is, when I needed a Marquardt solver, I coded and tested one up within an hour.
15:20:42 <mreh> all I can do is make it die when I try to convert it to an Int say
15:21:01 <Pseudonym> It was admittedly special-purpose, but the thing is, it'd take an hour to get your head around all the options of a sufficiently generic one, I would think.
15:21:07 <not_much> good night..
15:21:09 <EvilTerran> mreh, trying to convert String -> Int?
15:21:23 <pumpkin> __Ali__: despite the lack of those, haskell's FFI means it's pretty easy to write an interface to a foreign library, or code up a really natural definition of a mathematical algorithm
15:21:24 <mreh> how do  i trap an error?
15:21:40 <EvilTerran> ?type reads
15:21:41 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:21:55 <monochrom> You are so imperative.
15:22:01 <EvilTerran> mreh, use that; it returns a list of (value, string remaining after value)
15:22:09 <EvilTerran> mreh, if there's no parse, it returns []
15:22:15 <pumpkin> why a list?
15:22:21 <EvilTerran> if there's more than one parse, it can return multiple options
15:22:34 <EvilTerran> nothing in the standard libs do this, so i'm not sure why it's there
15:22:45 <pumpkin> ah
15:22:49 <__Ali__> why the haskell community is not active in wrapping well-known numerical libs? (except blas) haskell is a nice language, but its not *in use* for scientific applications
15:22:51 <mreh> its in RWH, question 4
15:23:01 <mreh> chapter 4
15:23:18 <pumpkin> __Ali__: the community is still relatively small, if very active :)
15:23:27 <ddarius> EvilTerran: So you can combine it with parsers that may be locally ambiguous.
15:23:37 <monochrom> the haskell community is active in doing things they actually use.
15:23:46 <monochrom> but that's a tautology.
15:24:07 <__Ali__> pumpkin: didn't haskell and python were introduced about the same time? and haskell and faster and more beautiful, how come python community is so big now?
15:24:07 <EvilTerran> mreh, so "case reads <whatever> of (x,""):_ -> <x is the parse>; [] -> <no parse>
15:24:07 <monochrom> someone wrapped blas because someone uses blas.
15:24:24 <pumpkin> __Ali__: because python is a lot easier to just pick up :)
15:24:33 <monochrom> python is an OO whore
15:24:40 <pumpkin> for people who are already used to imperative programming at least
15:24:43 <pumpkin> which is most of the computing world
15:24:48 <__Ali__> I thought haskell was supposed to be easier to read?
15:24:50 <cantropy> monochrom: whats wrong with OO?
15:24:50 <IWannaLog> and dynamic typing (Python is one ?)
15:24:57 <newsham> vixey: I got it!
15:24:59 <monochrom> nothing.
15:25:03 <mreh> but there is no construct to trap a partial function going wonky>
15:25:10 <EvilTerran> __Ali__, python's got a lot more in common with languages people already know
15:25:12 <vixey> newsham, cool! lets see
15:25:20 <monochrom> I'm explaining popularity by the whore part.
15:25:29 <cantropy> ah, then what does being an OO whore imply?
15:25:42 <monochrom> popularity
15:25:48 <EvilTerran> mreh, bottoms are the only unconstrained side-effect in haskell
15:25:54 <EvilTerran> mreh, it's the price you pay for turing-completeness
15:25:57 <cantropy> ah
15:26:01 <__Ali__> so is anyone going to do anything about it? it has been a decade and haskell is behind
15:26:05 <IWannaLog> bottom are side-effect ?
15:26:08 <pumpkin> __Ali__: o.O
15:26:09 <vixey> __Ali__, do what?
15:26:14 <mreh> bottoms?!
15:26:15 <pumpkin> __Ali__: do something about it if you don't like it :)
15:26:19 <newsham> http://hpaste.org/13620#a2
15:26:23 <mreh> hur hur
15:26:24 <IWannaLog> __Ali__: wait and you'll enemy will die
15:26:28 <EvilTerran> mreh, bottom = "expression with no value"
15:26:32 <EvilTerran> > undefined
15:26:33 <vixey> __Ali__, I don't think you can convince a lot of python users they want to use haskell instead..
15:26:34 <lambdabot>   * Exception: Prelude.undefined
15:26:39 <EvilTerran> > let loop = loop in loop
15:26:41 <EvilTerran> etc
15:26:45 <__Ali__> IWannaLog: by the time my enemy is dead i'm retired
15:26:45 <monochrom> Explain why haskell needs to be popular.
15:26:51 <pumpkin> __Ali__: most libraries are written by people who need stuff and are generous enough to release their work :) you need those things, write a simple FFI interface to optimizer libs or something :)
15:26:54 <lambdabot>   thread killed
15:27:09 <IWannaLog> We got all the time we want.
15:27:09 <EvilTerran> mreh, it covers pattern-match failure, evaluation of (error "..."), non-termination, etc
15:27:14 <__Ali__> vixey: you shouldn't convince people, you should make it easier for them
15:27:34 <pumpkin> __Ali__: the very concept isn't easy for them
15:27:37 <IWannaLog> It's the day of multicore, multithread, and pure functional language will come like an angel to the poor side-effect developper
15:27:38 <pumpkin> of functional programming
15:27:40 <EvilTerran> __Ali__, haskell is easy when you know it, it's just hard to pick up. that's why it's not as popular.
15:27:42 <__Ali__> I think ruby is an excellent example, ruby was unknown and dead, ruby on the rail made it famous
15:27:53 <EvilTerran> (the "hard to pick up" bit)
15:28:19 <monochrom> Libraries are not a reason to be popular. Python is more popular and its parser libraries are still scare and suck. You would think by now the python people would have made python wrappers around superior Haskell parser libraries.
15:28:21 <svref> Anyone willing to talk about defaulting of return types of overloaded functions?
15:28:24 <vixey> aha cool
15:28:31 <EvilTerran> mreh, "bottom" is so-called because it's the least-defined value for any type, ie the bottom of the partial ordering of "definedness"
15:28:33 <pumpkin> __Ali__: I think you misundstand how these things work :P there's no concerted "Haskell Inc." that's trying to attract customers and that should make more "products" to attract customers with...
15:28:57 <wabash> Actually, I am the president of Haskell Company, LLC.
15:29:01 <vixey> pumpkin, yeah there is.......
15:29:01 <pumpkin> oh awesome
15:29:12 <wabash> I'm selling shares, too....
15:29:17 <IWannaLog> You got in industry many developpers who doesn't know what functional developpement is, so the industry doesn't try it
15:29:18 <wabash> via paypal.
15:29:24 <EvilTerran> mreh, i think there's something you can do in IO to catch exceptions (pattern-match failures, calls to error, etc)
15:29:27 <pumpkin> vixey: galois?
15:29:36 <EvilTerran> but, of course, you can't catch non-termination in general ;)
15:29:43 <wabash> In the spirit then of starting my company, I have a question.
15:29:49 <__Ali__> pumpkin: no no, we don't want customers, we want more users so that the user community creates more code so that in reflection we can benefit from it!
15:29:52 <monochrom> I am the founder of Haskell Monsters Inc.
15:30:05 <wabash> __Ali__: Except that we should still avoid success at all costs.
15:30:26 <IWannaLog> wabash: :D
15:30:29 <pumpkin> __Ali__: certainly, but I guess optimizers haven't been a very common request so far ;)
15:30:45 <pumpkin> __Ali__: that's why I said if you need it, you should make it
15:30:46 <newsham> vixey: thanks for your help with this.  its been very helpful.
15:30:47 <wabash> One sorta rough concept I'm toying with is that of tersity... If a language is powerful enough that 5 ppl can do what 100 ppl would do in Java, then the community size can be 20 times smaller.
15:30:53 <pumpkin> that's where most of these things come from
15:30:56 <__Ali__> someone said blas is wrapped in haskell because someone needed it, if the number of users were 10 times higher, the chance of having lapack wrapped would be much more
15:31:01 <wabash> Which has some benefits, and some drawbacks.
15:31:03 <vixey> I am glad
15:31:40 <wabash> I was appointed CEO of Haskell Company because I'm a newbie...
15:31:48 <monochrom> __Ali__: I have pointed out an observation above. Please address it.
15:31:55 <pumpkin> __Ali__: then start a haskell lapack library project! :P
15:32:06 <wabash> Can we make a function return a new function in Haskell like we do in scheme?
15:32:08 <__Ali__> one obvious reason is the lack of *automatic* wrapper, there is swig for python encouraging people to wrap, ffi is not that automatic
15:32:15 <monochrom> Tell me why for all the large number of python people, its parser libraries are still inferior.
15:32:16 <EvilTerran> wabash, we do all the time
15:32:25 <EvilTerran> wabash, consider "map f", say
15:32:28 <wabash> EvilTerran: Ok, cool. Is it with lambdas?
15:32:31 <wabash> ok, sorry, go on.
15:32:32 <Saya> because haskell people only write parsers :)
15:32:37 <EvilTerran> wabash, no, that's it
15:32:40 <SamB_XP> monochrom: clearly, it is the scarcity of static typing and infix operators
15:32:44 <vixey> I wrote a parser=
15:32:47 <EvilTerran> ?type map (+1)
15:32:48 <lambdabot> forall a. (Num a) => [a] -> [a]
15:32:49 <pumpkin> __Ali__: then write a SWIG interface for haskell :P
15:33:01 <erikc> automatic wrapping will be solved soon, and will be better than SWIG
15:33:01 <vixey> using ReadP
15:33:03 <vixey> it was buggy
15:33:05 <EvilTerran> wabash, map, given its first parameter, returns a function that expects its second parameter
15:33:28 <wabash> wow. Mind warp.
15:33:29 <IWannaLog> automatic wrapping: code generation ?
15:33:36 <wabash> ok, are there lambdas?
15:33:39 <erikc> iwannalog: nod
15:33:40 <IvdSangen> welcome to currying
15:33:41 <__Ali__> monochrom: currently, if anyone creates a scientific library, the natural choice of a dynamic language is python
15:33:45 <IWannaLog> erikc: how ?
15:33:57 <EvilTerran> wabash, in general, when you define a function "myFunction param1 param2 ... paramN = ...", you can apply it to any prefix of those parameters, and get back a function that takes the resr
15:34:03 <EvilTerran> wabash, indeed
15:34:06 <IvdSangen> wabash: there are lambda expressions indeed
15:34:11 <EvilTerran> > map (\x -> (x,x)) [1,2,3]
15:34:12 <lambdabot>   [(1,1),(2,2),(3,3)]
15:34:16 <erikc> iwannalog: parse the debug data in a c/c++ object and use the type information to generate haskell code for binding
15:34:21 <monochrom> So you cannot explain my observation, my refutation of your popularity rhetoric.
15:34:37 <IWannaLog> erikc: I don't understand what you mean.
15:34:38 <rwbarton> wabash: consider the (silly) definition  add a b = a + b
15:34:40 <EvilTerran> wabash, lambdas are "\ <parameters> -> <body>"
15:34:46 <rwbarton> wabash: this is shorthand for  add = \a -> (\b -> a + b)
15:35:02 <IWannaLog> erikc: are you saying that parsing header file is too hard to be intersting ?
15:35:07 <pumpkin> __Ali__: really? I chose c so I could use TAO/PETSc
15:35:42 <__Ali__> monochrom: all am saying is that haskell is a nice language which is being in use by language designers, I don't see it to be actually 'in use'
15:35:54 <wabash> EvilTerran: rwbarton, IvdSangen: ok, got it.
15:36:05 <EvilTerran> wabash, awfully clever, isn't it? :)
15:36:16 <__Ali__> pumpkin: petsc/trilinos/fenics come with python wrapper
15:36:19 <SamB_XP> erikc: where do you get the debug symbols ?
15:36:26 <EvilTerran> wabash, also note that "f x y z" parses as "((f x) y) z"
15:36:26 <pumpkin> __Ali__: and TAO?
15:36:30 <wabash> but then what about compiled Haskell code. If I have code that I compiled to C and then compiled to binary, can it still create functions?
15:36:40 <wabash> EvilTerran: Ah, got it.
15:36:55 <vixey> ' ' in infixr 9999999
15:36:57 <mreh> @hoogle :: Char -> Bool
15:36:57 <lambdabot> Data.Char isAlpha :: Char -> Bool
15:36:58 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
15:36:58 <lambdabot> Data.Char isAscii :: Char -> Bool
15:36:58 <__Ali__> pumpkin: does tao have a wrapper for haskell?
15:36:59 <vixey> oops
15:37:02 <EvilTerran> wabash, yep; whether it's compiled or interpreted isn't allowed to affect the semantics of the language
15:37:03 <vixey> infixl
15:37:06 <pumpkin> __Ali__: nope
15:37:07 <monochrom> One reason fewer people use Haskell is that it is too nice.
15:37:09 <shapr>  /me boings cheerfully
15:37:12 <shapr> oops
15:37:16 <mreh> > isAlpha 'a'
15:37:18 <lambdabot>   True
15:37:21 <pumpkin> __Ali__: my point is that I didn't use python for my "scientific" lib
15:37:21 <mreh> > isAlpha '9'
15:37:22 <monochrom> Do you know that really nice things alienates lots of people?
15:37:23 * shapr hugs vixey 
15:37:23 <lambdabot>   False
15:37:27 * vixey hug shapr
15:37:27 <erikc> samb_xp: from the dwarf data in the objects (requires you to have -g compiled code)
15:37:30 <EvilTerran> wabash, you could consider lambdas, and the results of partially-applied functions, to be functions created at runtime
15:37:39 <SamB_XP> erikc: er, yes, that was my point ;-P
15:37:40 <shapr> monochrom: I disagree.
15:38:08 <shapr> It's been my experience that being really nice overcomes lots of cognitive dissonance.
15:38:24 <wabash> EvilTerran: Yes, that's what I'm trying to figure out: the mechanism by which this can happen.
15:38:38 <pumpkin> shapr: I hear it's your fault this channel is so friendly... where are my trolls and arrogant assholes? I miss them :(
15:38:39 <erikc> SamB_XP: which you can get from header files if you want by compiling an object that includes that header and some nonsense calls
15:38:40 <EvilTerran> the internal mechanism is something involving graph reduction
15:38:43 <wabash> If I have a binary then, and a lambda is created, is a chunk of memory allocated off of the heap and turned into executable?
15:38:51 <shapr> pumpkin: Oh, they've visited... but they didn't stay for long.
15:38:55 <ddarius> wabash: Read SICP and/or watch the SICP lectures.  It works the same as it does in Scheme.
15:39:08 <wabash> I mean, I am having trouble seeing how this would work in a running binary.
15:39:10 <SamB_XP> erikc: GDB doesn't seem to think so :-(
15:39:20 <pumpkin> wabash: the lambdas aren't made at runtime
15:39:26 <monochrom> Cognitive dissonance is the norm. Lots of people have, live with, and can't stand getting rid of cognitive dissonance.
15:39:31 <wabash> ddarius: Yes, it's good material. But SICP deals with interpreted code, right? Its' not compiled, is it?
15:39:49 <ddarius> wabash: It builds a compiler.
15:39:53 <gbacon> ?ho [m a] -> m [a]
15:39:53 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
15:39:55 <__Ali__> pumpkin: i'm trying to create an image processing based on haskell, then I ask myself, how many people are going to use it? plus, I have to use many existing numerical libs to create the image processing lib which are not wrapped
15:40:05 <gbacon> ?hoogle [m a] -> m [a]
15:40:05 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:40:05 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:40:05 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
15:40:09 <ddarius> wabash: Anyway, the data representation is roughly the same.
15:40:10 <wabash> pumpkin: Oh,.... Are they compiled into the binary? and what if I create an array of lambdas during runtime. Are they all new?
15:40:18 <monochrom> (How many years did it take Guido himself to accept that "if-then-else" is just as good for expressions as is for commands? That is some cognitive dissonance addiction for you.)
15:40:26 <EvilTerran> __Ali__, you can make your library written in haskell accessible from C with a fairly small wrapper, then most of the programming community can use it!
15:40:34 <shapr> EvilTerran: good point!
15:40:36 <ddarius> @google easyVision
15:40:36 <shapr> @users
15:40:36 <gbacon> ?hoogle [m [a]] -> m [a]
15:40:37 <lambdabot> No Result Found.
15:40:38 <lambdabot> Maximum users seen in #haskell: 674, currently: 650 (96.4%), active: 31 (4.8%)
15:40:38 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
15:40:38 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
15:40:38 <lambdabot> Prelude concat :: [[a]] -> [a]
15:40:46 <erikc> samb_xp: sorry, dont understand
15:40:52 <shapr> Huh, we're almost to 700?
15:40:59 <pumpkin> shapr: insane innit
15:41:03 <ddarius> http://www.easyvision.googlepages.com/
15:41:04 <shapr> @google FVision haskell
15:41:06 <lambdabot> No Result Found.
15:41:08 <shapr> hmm
15:41:19 <SamB_XP> erikc: well, it didn't work when I tried debugging my C++ program a month or so back ...
15:41:21 <wabash> Still lost.....
15:41:29 <pumpkin> just a week ago the max was almost 100 fewer people
15:41:34 <erikc> samb_xp: sorry, what didnt work :)
15:41:42 <shapr> pumpkin: I remember when I was the only person on #haskell =)
15:41:52 <SamB_XP> GDB didn't pick up the type info that should have come from headers
15:41:54 <EvilTerran> wabash, a running haskell binary is basically a graph-reducer that's manipulating your compiled code as the graph
15:41:56 <ddarius> shapr: Must have been fun back then.
15:41:57 * shapr gets out his cane and pretends to be old.
15:41:59 <shapr> ddarius: Nah, it sucked.
15:42:02 <pumpkin> shapr: lol
15:42:04 <SamB_XP> like, class layouts
15:42:15 <Peaker> isn't "seq x x" different from "x" -- WHNF vs. no forcing at all?
15:42:16 <shapr> Lucky for me, Heffalump showed up and then we argued lots ;-)
15:42:25 <ddarius> Peaker: No.
15:42:42 <erikc> odd, my tests for that have worked ok
15:42:50 <Peaker> ddarius: Ah, only if "x" is actually forced, the "seq" will force its arg (in this case "x")?
15:42:52 <EvilTerran> wabash, as i understand it, the fundamental structure of your haskell code isn't compiled into native bytecode by ghc
15:42:53 <wabash> EvilTerran: I see. Haw can this work though? Isn't the executable run in the text segmentof memory and hence unchangeable?
15:43:03 <RayNbow> > let x = map negate [1..10]; f _ = 0;   in   f $ seq x x
15:43:04 <lambdabot>   0
15:43:08 <__Ali__> how come easyvision is not in heskell.org database
15:43:08 <monochrom> If you force x, what happens? If you force seq x x, what happens?
15:43:12 <SamB_XP> shapr: was that after you banned smerdy the first time ?
15:43:24 <shapr> SamB_XP: Nah, that was *many* years later.
15:43:26 <EvilTerran> wabash, the fundamental structure of your code is more reflected in the data part of the binary
15:43:27 <wabash> EvilTerran: We can compile it into C and then use GCC to compile that to binary.
15:43:31 <wabash> EvilTerran: I see.
15:43:33 <EvilTerran> wabash, as i understand it, anyway
15:43:38 <shapr> __Ali__: Feel free to package it and put it into the haskell.org database!
15:43:39 <ddarius> shapr: Not -that- many.
15:43:41 <wabash> So it could be mutable if that was the mechanism.
15:43:49 <BONUS_> seq x x and x should be the same thing, right?
15:43:52 <shapr> __Ali__: You have found something that can be fixed! Well spotted, now go fix it!
15:44:04 <wabash> EvilTerran: It's not terribly important that I know the precise way; more so that I can have some sort of clue of how things work.
15:44:18 <__Ali__> :)
15:44:18 <shapr> Lead, Follow, or Get Out of the Way.
15:44:22 <shapr> That's my motto!
15:44:26 <pumpkin> __Ali__: because there is no single "central authority" :P
15:44:29 <EvilTerran> wabash, i believe GHC's run-time system is based on an "STG machine"
15:44:43 <wabash> STG?
15:44:46 <shapr> __Ali__: And you get credits for fixing stuff :-)
15:44:47 <__Ali__> so is there any more computer vision libs in haskell?
15:44:59 <bd_> EvilTerran: plenty of it is in the code, really
15:45:05 <shapr> __Ali__: Yup, there are at least two that I know, and I think I've heard of several others.
15:45:12 <EvilTerran> wabash, er, i dunno
15:45:14 <EvilTerran> :P
15:45:20 <bd_> the STG machine is just an internal structure that GHC uses to represent the program as it churns away
15:45:25 <__Ali__> shapr: and the other one is?
15:45:30 <shapr> FVision
15:45:51 <EvilTerran> wabash, but i think that's related to the relevant stuff in SICP that ddarius mentioned
15:46:01 <EvilTerran> (i may be wrong)
15:46:20 <wabash> Yes, ok.
15:46:27 <wabash> I imagine it's closely related.
15:46:37 <EvilTerran> the whole "compiled program as graph shaped like your code + graph-reducing machine" thing
15:47:11 <wabash> My sticiking point was that Scheme is run on an interp, and Haskell *could* be turned into C, and so I was wondering what the heck the C code/binaries would look like/do
15:47:24 <shapr> __Ali__: Anyway, I think the reason to write a lib in Haskell is that you like using Haskell, and you want to use the lib.
15:47:24 <vixey> wabash, that's not true
15:47:27 <monochrom> Cale is rumoured to be an STG machine for demo purposes. :)
15:47:35 <EvilTerran> wabash, scheme could be turned into C as far as haskell can
15:47:35 <mreh> @hoogle isAlpha
15:47:36 <Cale> heh
15:47:36 <lambdabot> Data.Char isAlpha :: Char -> Bool
15:47:36 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
15:47:37 <shapr> __Ali__: Others may also use your lib, but ya never know.
15:47:51 <SamB_XP> what about that (eval ...) thing
15:47:55 <EvilTerran> wabash, C is a popular target for compilers written by people who can't be bothered learning assembly :P
15:48:01 <shapr> haha
15:48:02 <wabash> vixey: Really? I can complie scheme? Cool!!!
15:48:03 <vixey> SamB_XP, what about it?
15:48:03 <SamB_XP> EvilTerran: not even that
15:48:26 <__Ali__> shapr: yes I do like th elanguage, but I cannot afford the time to wrap all other libs I'll definitely need
15:48:32 <SamB_XP> vixey: well, how can it be implemented except with an interpreter ?
15:48:34 <monochrom> wabash: the C code looks like lots of pointer games and gotos and playing with the stack.
15:48:37 <EvilTerran> i'd consider a scheme-to-C compiler to be a good educational exercise
15:48:44 <vixey> SamB_XP, it can't
15:48:48 <wabash> monochrom: Cool, thank you.
15:48:50 <shapr> __Ali__: In that case, it sounds like you should consider other options.
15:48:51 <EvilTerran> well, cut-down scheme
15:48:55 <shapr> __Ali__: But we'll miss you :-)
15:49:11 <wabash> I donno why, but somehow having some concept of what's going on behind the scenes is really helpful to me.
15:49:16 <wabash> EvilTerran: why "cut down"?
15:49:23 <__Ali__> shapr: one of these libs is vtk.org, it's a huge lib to wrap
15:49:37 <ddarius> __Ali__: You need every function in it?
15:49:38 <shapr> __Ali__: How much of it do you need to wrap for your purposes?
15:49:40 <EvilTerran> wabash, a full scheme would probably take a bit long for an educational exercise
15:49:42 <shapr> Yeah, what ddarius said.
15:49:52 <SamB_XP> wabash: you won't get it from looking at the "C" or assembly code from a Haskell compiler ...
15:49:52 <EvilTerran> wabash, i'd see if i felt like fleshing it out after i'd completed the basic one
15:49:53 <vixey> because implementing SYNTAX-RULES is........... non trivial
15:49:55 <__Ali__> ddarius: it doesnt make sense to me to wrap as I go
15:50:02 <ddarius> __Ali__: Why not?
15:50:02 <shapr> __Ali__: Why not?
15:50:04 <shapr> doh
15:50:08 <shapr> I'm slow today.
15:50:32 <SamB_XP> perhaps the wrapping process can be mechanized
15:50:44 <shapr> SamB_XP: Yes, see the earlier discussion about SWIG.
15:50:46 <__Ali__> because the wrapped interface will be exposed to the user, should ask the users to put a request for wrapping class-by-class?
15:50:57 <shapr> In fact, there are already SWIG-like tools for Haskell. c2hs is one example.
15:51:19 <monochrom> The impedence mismatch between C and Haskell is higher (than between C and Python, say). Automation is a tall order.
15:51:22 <shapr> __Ali__: Nah, you accept patches from the users that extend the wrapper :-)
15:51:45 <__Ali__> I was hoping maybe wrapping could be automated by compiling c/c++ to haskell :)
15:51:53 <EvilTerran> O.o
15:51:54 <shapr> __Ali__: Have you seen/tried c2hs?
15:52:21 <wabash> SamB_XP: Well, I didn't mean literally read though it and decipher. I meant more conceptually, because C doesn't have the same functional nature.
15:52:40 <__Ali__> shapr: yes I did, I will have to update the automated wrapping system of vtk to allow wrapping for haskell
15:52:43 <wabash> I'm not smart enough to decipher
15:52:53 <gbacon> ?hoogle [m a] -> m [a]
15:52:54 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:52:54 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:52:54 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
15:53:12 <SamB_XP> wabash: I think even the best of us can only get a little out of it
15:53:19 <__Ali__> shapr: have you heard of adobe's new way of compiling c/c++ code to actionacript and flash?
15:53:29 <__Ali__> can we not have someting the same for haskell?
15:53:31 <shapr> __Ali__: I think someone mentioned it to me recently.
15:53:31 <SamB_XP> wabash: even then, most likely only by comparing it with the Core code ...
15:54:15 <SamB_XP> hmm, when is boost::haskell coming out ...
15:54:31 <shapr> __Ali__: I think that automated compilation of C to Haskell would still require some functional wrapper code to get the code to feel like Haskell.
15:54:44 <shapr> And at that point, you might as well use c2hs or other tool, in my opinion.
15:54:56 <gbacon> @karma- random-numbers-in-Haskell
15:54:57 <lambdabot> random-numbers-in-Haskell's karma lowered to -1.
15:54:57 <shapr> __Ali__: On the other hand, if you prove me wrong, I will be happy to learn something new!
15:55:15 <SamB_XP> why doesn't SWIG support Haskell...
15:55:23 <shapr> SamB_XP: Going to fix it?
15:55:43 <__Ali__> shapr: i dont know anout the mechanism in adobe's compiler
15:55:47 <monochrom> Is SWIG tailored for Python?
15:55:58 <SamB_XP> eww, SWIG is written in C++ apparantly
15:56:21 <__Ali__> SamB_XP: i dont know, i thought becase of ffi no one bothered to have a swig module
15:56:22 <mreh> does anyone know of any haskell precedence cheat sheet?
15:56:47 <SamB_XP> __Ali__: well, the FFI doesn't support C++, you know ...
15:57:00 <Claudius1aximus> mreh: there's one in the report, i was looking at it earlier today
15:57:11 <monochrom> mreh: The next best thing is ":info (+)" at the GHCi prompt
15:57:14 <ddarius> When I started a binding to Kyra, I used SWIG to generate C (Kyra is C++) and then started binding that.
15:57:29 <Claudius1aximus> mreh: http://haskell.org/onlinereport/decls.html#fixity
15:57:30 <monochrom> I guess it should be ":info +"
15:57:32 <__Ali__> SamB_XP: u'r right
15:57:41 <monochrom> You can also try ":info + *"
15:57:49 <ddarius> No one is going to make an automatic binding tool for Haskell that reads C++.
15:57:52 <__Ali__> shapr: here is the adobe compiler, its based on gcc: http://labs.adobe.com/technologies/alchemy/
15:57:52 <SamB_XP> ddarius: hmm, that might work just as well
15:58:30 <wabash> OT: I just have to say that I am very thankful for this channel. Everyone here seems interested in learning and understanding Haskell and then helping others learn it too. Thank you all for being kind, respectful, and helping me to understand stuff. Thanks also for not treating me poorly for asking general questions. It's how I learn.
15:58:37 <SamB_XP> oh, wait, apparantly SWIG was rewritten in C again
15:58:43 <Cale> wabash: :)
15:58:55 <SamB_XP> not that that's all THAT much better than being in C++
15:58:57 <Asztal> C++ code can export functions in a C-like way, so I'm sure it does that
15:59:02 <ddarius> SWIG is all jacked up.
15:59:25 <__Ali__> if we have *direct* compilation of c/c++ to haskell, we wouldn't need users to drive wrapping anymore :)
16:00:09 <ddarius> Even less people are going to write a -compiler- from C++ to Haskell.
16:00:09 <SamB_XP> wouldn't that be kinda slow though ?
16:00:16 <yip> __Ali__: we would for performance reaons
16:00:29 <erikc> ddarius: im making an automatic binding tool for haskell that reads C++ :)
16:00:48 <ddarius> erikc: What C++ parser are you using?
16:00:50 <SamB_XP> erikc: how ?
16:00:56 <__Ali__> SamB_XP: it's not slow if it's a thin wrapper
16:01:07 <erikc> by using the DWARF/PDB data that the C++ compiler generates
16:01:20 <SamB_XP> erikc: sounds like fun!
16:01:20 <erikc> so i get all the post-template expansion information
16:01:38 <newsham> vixey: with Data.Binary now:  http://hpaste.org/13620#a3
16:01:43 <ddarius> erikc: Anyway, my wording was pretty precise.
16:02:57 <erikc> yea, its not 'reading C++'
16:03:11 <erikc> thats a rabbit hole no one wants to go down
16:03:48 <monochrom> That hole is so black it emits Hawking radiation.
16:05:40 <yip> erikc: please use Ogre3D library as part of your test suite :)
16:14:02 <Guenni> anybody managed to install takusen on ghc 6.10?
16:15:06 <hansfbaier> friendliness is the hallmark of professionalism. The friendliness and helpfulness of this channel reflects the level of education of its members.
16:27:03 <chessguy_work> @type interact
16:27:05 <lambdabot> (String -> String) -> IO ()
16:29:04 <rgr> sorry to ask what I think is xmonad specific, but xmonad# dead - anyone know how to determine pixel dimensions of current x screen in haskell/xmonad?
16:29:07 <chessguy_work> ooh! i just figured out the answer to the puzzle at the end of RWH cahpter 1
16:38:02 <Peaker> does cabal-install's bootstrap.sh generally work out-of-the-box on MacOSX?
16:38:16 <pumpkin> worked fine on mine
16:38:25 <pumpkin> using the .pkg for 6.10
16:38:29 <pumpkin> I didn't try the macports ghc
16:40:11 <newsham> vixey: ready for the next level?
16:45:18 <Peaker> how do I edit the ld-options of an installed package?
16:47:59 <imphasing> For something like a FizzBuzz problem in haskell, is there a simpler way to write a predicate than `if x `mod` 3 == 0 || x `mod` 5 == 0 then True else False`?
16:48:05 <imphasing> I feel like I'm approaching it the wrong way..
16:48:12 <imphasing> It works, but doesn't seem very Haskell.
16:48:27 <Peaker> imphasing: if x then True else False == x
16:48:37 <twb> Is there a gitit sandbox instance running somewhere?
16:49:04 <imphasing> Peaker, Not sure I understand that..
16:49:17 <naturalethic> hehe
16:49:20 <Peaker> imphasing: if <condition> then True else False ==== <condition>
16:49:38 <imphasing> You can assign a value for False? :/
16:49:39 <pumpkin> wow, that's super equivalent
16:49:42 <Peaker> imphasing: Also: x `mod` 3 ==0 || x `mod` 5 == 0.       can become:  all ((==0) . (x `mod`)) [3,5]
16:50:03 <Peaker> imphasing: the whole (if ... ) not just the False
16:50:04 <pumpkin> imphasing: if you write if a then b else c, youc can replace that whole chunk with a
16:50:13 <pumpkin> I mean
16:50:17 <pumpkin> then True else False
16:50:19 <Peaker> when b and c are True and False
16:50:20 <pumpkin> :P
16:50:22 <pumpkin> yeah, sorry
16:50:34 <pumpkin> and even if backwards!
16:50:37 <pumpkin> you can do not a!
16:50:41 <pumpkin> fancy that!
16:50:46 * pumpkin beams
16:51:09 <Peaker> > all ((==0) . (45 `mod`)) [3,5,15]
16:51:10 <lambdabot>   True
16:51:13 <Peaker> > all ((==0) . (45 `mod`)) [3,5,15,25]
16:51:14 <lambdabot>   False
16:51:41 <Peaker> > if even 5 then True else False
16:51:42 <lambdabot>   False
16:51:45 <Peaker> > even 5
16:51:46 <lambdabot>   False
16:51:53 <Peaker> imphasing: see why the last 2 are equivalent?
16:52:13 <imphasing> Peaker, Oh.
16:52:15 <imphasing> Duh!
16:52:16 <imphasing> :)
16:52:17 <imphasing> Thanks
16:52:31 <imphasing> I'm dumb :P
16:54:04 <Peaker> @let x `divides` y = x `mod` y == 0
16:54:05 <lambdabot>  Defined.
16:54:28 <Peaker> > all (45 `divides`) [3,5,15]
16:54:29 <lambdabot>   True
16:54:34 <Peaker> imphasing: that's nicer, IMO
16:54:48 <pumpkin> that might be backwards?
16:55:09 <pumpkin> 3 divides 45 evenly
16:55:32 <tromp_> u defined isMultipleOf
16:55:41 <Peaker> oops :-)
16:57:01 <mib_cxuo2vfe> Any body, please suggest me an interesting and practical Haskell Tutotial
16:57:38 <Saya> i'd say 'learn yourself a haskell' or 'real world haskell'
16:57:54 <pumpkin> @where lyah
16:57:54 <lambdabot> www.learnyouahaskell.com
16:57:57 <pumpkin> @where rwh
16:57:58 <lambdabot> is http://www.realworldhaskell.org/blog/
16:58:00 <pumpkin> or just http://tinyurl.com/7f9q6h
16:58:22 <Saya> wow you sure master the arts of lambdabot
16:58:28 <pumpkin> lol
16:58:51 <lambdabot> I am pretty good at human, too.
16:59:06 <pumpkin> lol
16:59:12 <mib_cxuo2vfe> Thank you all
17:04:03 <dons> ?yow
17:04:03 <lambdabot> Do you like "TENDER VITTLES"?
17:04:52 <dons> ?users
17:04:52 <lambdabot> Maximum users seen in #haskell: 674, currently: 621 (92.1%), active: 14 (2.3%)
17:04:55 <dons> oh wow.
17:04:56 <mmorrow> omg mario level one in ascii http://svn.coderepos.org/share/lang/haskell/nario/data/stage0.map
17:05:15 <dons> shapr: 674 is kinda crazy.
17:05:34 <matthewp> Real World Haskell group is over on #novalang right now
17:05:45 <dons> hey matthewp !
17:05:52 * dons just got off the plane
17:05:54 <pumpkin> dons: we were wondering if you were spamming on the channels behalf or something :P it's a pretty large increase in the past few days!
17:05:58 <Saya> wow it grows every day
17:20:37 <abuiles> g
17:22:30 <mmorrow> a killer app would be a terminal which is pretty much just a blank opengl/equiv canvas (character grid display is emulated, but not as the a priori primary graphical interface). Then you could (e.g.) have 3 sh sessions and 3 editor sessions overlayed with varying levels of transparently so you can see them all (or none at all) at once.
17:23:04 <Elly> I do not understand why that would be a killer app
17:23:11 <mmorrow> if i did graphic programming in haskell more that once a month, i'd totally be writing this
17:23:37 <mmorrow>  you could have the same level of control that you have over a shell or  an editor, but you wouldn't have to be blindingly limited to a character-grid-party-like-it's-1988 interface and be able to manipulate *gasp* 2D or even 3D primtives simultaneously over each other and logically connected.
17:24:01 <mmorrow> you could do all kinds of crazy stuff
17:24:41 * BMeph pladged his Engineering frat in 1988...
17:25:06 <Saizan> you'd need applications that take advantage of the features though?
17:25:07 * BMeph meant "pledged", of course - must still be partying... ;p
17:25:17 <mmorrow> one killer feature (which personally i'd kill for) is the ability to have multiple simultaneous (possibly connected) things going on in the shell all visible at (adjustable via keystroke) varying transparency levels
17:25:40 <mmorrow> Saizan: totally. we'd have to write them all :)
17:26:39 <mmorrow> imagine the crap you could do with a Yi+ghc-api-in-one with that interface
17:26:52 <mmorrow> BMeph: heh
17:27:30 <BMeph> mmorrow: Imagine the crap that Windows users could do instead of trying to find a way to get it done in Windows! ;p
17:27:35 * mmorrow mentions this in the hope that someone'll write it, because while on his list he won't be getting to it very soon
17:27:40 <Saizan> overlapping transparent layers.. would those be readable?
17:28:07 <mmorrow> Saizan: yes, you can toggle the transparency from 0%-100% of any layer with a keystroke-combo
17:28:36 <mmorrow> have you ever used the compiz opengl window manager with gnome? you can do exactly this and it's sweet
17:28:55 <Saizan> no
17:29:06 <mmorrow> read along with a webpage which you're viewing through your editor while you're typing in it
17:29:24 <mmorrow> it's pretty mind-bending :)
17:29:35 <Saizan> nice :)
17:29:51 <Saizan> you need one of the two to be pretty sparse though, i guess
17:29:59 <rwbarton> Or edit a postscript document and have it autorefresh behind your text editor
17:30:08 <mmorrow> totally, but it's may more readable than you'd imagine
17:30:16 <\z> irc-only++
17:30:28 <mmorrow> you're mind focuses on one just like you mind focuses on one sound in a noisy room
17:30:42 <mmorrow> also, you get this bizarre sense of depth to your desktop
17:30:52 <mmorrow> rwbarton: exactly
17:31:13 <Peaker> anyone aware of SDL problems on OS X?
17:31:55 <mmorrow> you're jaw drops off your face though when you've got 10 windows all visible to varying degrees and positioned strategically. you can always see every window.
17:32:16 <mmorrow> gah! *your *your
17:32:21 <Peaker> hi bigorilla
17:32:32 * mmorrow brings his rant to a close :)
17:32:40 <Saizan> i guess we'd need to port xmonad to such a terminal :)
17:32:50 <mmorrow> Saizan: yes!!
17:33:28 <mmorrow> if xmonad could do the compiz thing, it would be and 11 on a scale of negative 4
17:33:36 <Saizan> i already find myself in a stack of "window managers".. xmonad -> screen -> irssi/emacs
17:34:01 <Peaker> bigorilla: maybe try to strace the SDL program?
17:34:05 <rwbarton> I want compositing in xmonad too, but for a different reason
17:34:06 <bigorilla> newbie question (possibly related also to Mac OS X and SDL): I'm trying to build the first ever haskell example my haskell zealot friend sent me. it builds, but when I try to run it the "application" shows in my dock but no window pops up. anyone has a clue? 10x x 10!
17:34:15 <rwbarton> so I can make unfocused windows dimmer
17:34:24 <mmorrow> also, you can put your desktops on either the outside or inside of an (unfortunately you can only walk around in in one plane) n-gon
17:34:56 <mmorrow> rwbarton: yes. you can assign a key sequence to +transparency and -trans
17:34:58 <SamB_XP> bigorilla: is it supposed to be a GUI app ?
17:35:07 <bigorilla> SamB_XP: yes
17:35:20 <bigorilla> SamB_XP: it's called "jumping_text" :)
17:35:34 <SamB_XP> bigorilla: did you ask him about it ?
17:35:39 <mmorrow> alt-tab-<tap tap tap>-alt-tab and that window's invisible
17:35:47 <Saizan> rwbarton: you can use xcompmgr for that, to some extent
17:36:07 <Peaker> SamB_XP: its me :-) Its a silly SDL thingie that blits some text to varying positions
17:36:18 <rwbarton> Saizan: I heard it was old and broken, but I haven't tried it
17:36:30 <SamB_XP> bigorilla: why did you not refer to Peaker by name ?
17:36:49 <bigorilla> SamB_XP: because I'm stupid :)
17:36:59 <SamB_XP> I don't believe you
17:37:06 <bigorilla> arg
17:37:08 <SamB_XP> I want a better story
17:37:27 <__Ali__> does anyone know a finite-element lib (or wrapped) in haskell?
17:37:51 <chessguy> hey can someone have lambdabot join #novalang ? RWH study session going
17:37:51 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
17:38:33 <bigorilla> SamB_XP: first of all I have to start learning haskell because the aliens are threatening that they will destroy the southern hemisphere if I don't. they don't know Peaker is helping me but now my cover has blown off
17:38:34 <Peaker> bigorilla: how about strace's result?
17:38:56 <bigorilla> Peaker: it's latest thing is some munmap stuff..
17:39:05 <SamB_XP> bigorilla: fear not, we can enroll him in the 'skeller protection program
17:39:13 <SamB_XP> it's sponsored by MS Research
17:39:54 <chessguy> someone?
17:39:55 <bigorilla> as is the alien rebelion
17:40:13 <shapr> lambdabot: @join #novalang
17:40:50 <__Ali__> this thread is interesting: http://ubuntuforums.org/showthread.php?t=719685&page=3
17:41:58 <SamB_XP> bigorilla: what are the aliens researching ?
17:44:35 <bigorilla> SamB_XP: they are intrigued by the nature of the earthly macro organisms. and they are conducting experiments on them. before they started experimenting, religions were rather peaceful
17:53:05 <bigorilla> Peaker: strace/dtruss didn't lead me anywhere and from gdb it seems to be inside some sort of Macky event loop
17:53:50 <Peaker> bigorilla: weird :(  maybe I can try to ssh to you and see if the control is in the Haskell part of the SDL lib?
17:53:56 <Peaker> (some other day though)
17:57:20 <__Ali__> i wish 2*-3 din't generate error in haskell
17:57:51 <tromp_> > 2 * -3
17:57:52 <lambdabot>       precedence parsing error
17:57:52 <lambdabot>          cannot mix `(*)' [infixl 7] and prefi...
17:57:55 <tromp_> > 2 * (-3)
17:57:57 <lambdabot>   -6
17:58:08 <__Ali__> the use of () in annoying
17:58:08 <tromp_> > -3 * 2
17:58:10 <lambdabot>   -6
17:58:30 <__Ali__> is *
17:58:33 <tromp_> put negative factor in front
17:59:26 <__Ali__> True && 1
17:59:38 <__Ali__> > True && 1
17:59:39 <lambdabot>       No instance for (Num Bool)
17:59:39 <lambdabot>        arising from the literal `1' at <inte...
18:01:32 <rgr_> in ghci how do I do something like "import qualified XMonad.StackSet as W" and then use W?
18:02:13 <rwbarton> rgr_: You can't, aside from loading a file with that qualified import in it
18:02:38 <redditbot> Hacking With Happs
18:02:38 <redditbot> Tom's Declarative Languages Blog: Monadic Constraint Programming
18:02:38 <redditbot> Conal Elliott: Another angle on functional future values
18:02:38 <redditbot> MaybeArrow?
18:02:38 <redditbot> darcs advanced revision control system: darcs 2.2.0pre2 ready for testing!
18:02:44 <rgr_> ok. Wow. I've been trying for over an hour to get a screen width :-(
18:03:07 <rwbarton> You can probably load your xmonad.hs into ghci
18:04:17 <rgr_> rwbarton: yeah, figured that. thanks.
18:06:42 <rgr_> rwbarton: could you talk me through the following syntax please?
18:06:44 <rgr_> withWindowSet $ \ws -> return . rect_width . screenRect . W.screenDetail $ W.current ws
18:08:14 <rgr_> or anyone?
18:08:29 <rgr_> :t W.current
18:08:30 <lambdabot> Couldn't find qualified module.
18:08:48 <rwbarton> rgr_: what about it in particular?
18:08:53 <scsibug> rgr_: are you interested in the haskell language aspects, or xmonad in particular?
18:09:15 <rwbarton> What are you using the screen width for?  Can you paste your xmonad.hs?
18:09:20 <rgr_> both. In this case I have zero clue how this is uspposed to get me with the screen width.
18:09:26 <rgr_> I just need it.
18:09:56 <rgr_> And a good time to learn some more Haskell I thought.
18:10:55 <rwbarton> Ok, so there are docs at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xmonad-0.8
18:10:56 <scsibug> I'm not familiar with xmonad, but that looks like a handler it would use internally, and not a good way of extracting a value for your use
18:11:36 <rwbarton> withWindowSet provides the current WindowSet; rect_width . screenRect . W.screenDetail $ W.current ws just extracts the screen width from that WindowSet
18:12:28 <rgr_> how? I can not read that. How do you parse that line?
18:12:45 <rwbarton> it's just
18:12:55 <rwbarton> rect_width (screenRect (W.screenDetail (W.current ws)))
18:12:57 <rwbarton> if you prefer
18:13:09 <rgr_> whats ws?
18:13:16 <rwbarton> the parameter to the function
18:13:21 <rgr_> from where?
18:13:22 <rwbarton> which is provided by withWindowSet
18:13:28 <rgr_> aha
18:13:43 <rwbarton> ttp://hackage.haskell.org/packages/archive/xmonad/0.8/doc/html/XMonad-Core.html#v%3AwithWindowSet
18:15:21 <rgr_> I know where the docs are. They are quite sparse. Its more the understanding how the line is parsed.
18:15:54 <rwbarton> so the whole expression is an expression in the X monad that returns the screen width
18:16:33 <rgr_> i tried soemthing like (exper - 20) but it threw errors. Maybe I try again.
18:16:41 <rgr_> where exper was that line
18:16:58 <rwbarton> Yes, that won't work
18:17:08 <rwbarton> You could rewrite it as...
18:17:18 <rgr_> I also tried (w1-w2) "where" w1 = exper
18:17:22 <rwbarton> withWindowSet $ do
18:17:26 <rwbarton> Sorry
18:17:28 <rgr_> *sob*
18:17:31 <rwbarton> withWindowSet $ \ws -> do
18:17:43 <rwbarton>   let width = rect_width . screenRect . W.screenDetail . W.current $ ws
18:17:46 <monochrom> withWindowSet (\ws -> (return . rect_width . screenRect . W.screenDetail) W.current ws )
18:17:46 <rwbarton>   return width
18:17:48 <rwbarton> if that helps
18:18:16 <rgr_> in that let, where does "ws" come from?
18:18:22 <rwbarton> the previous line
18:18:37 <rgr_> oh I see
18:18:55 <rgr_> and If i want (width-w2) where width = ?
18:19:31 <rwbarton> you could change the last line of my rewrite to  return (width - w2)
18:20:17 <rwbarton> you can't really use where in this context, because it's an expression
18:20:33 <rgr_> width isnt surely.
18:20:52 <rgr_> no more so than "where myFloats = .. " etc
18:20:53 <rwbarton> huh?
18:21:13 <rwbarton> See, I'm kind of not sure what's going on because I don't know the context of this code
18:21:15 <rgr_> Hang on. Let me try and if I have problem I post link to paste
18:21:27 <rwbarton> I can only provide technically true statements :P
18:21:37 <rgr_> :-; And I thank you for it!
18:22:54 * rgr_ pasted "I give up. rwbarton please help" at http://paste2.org/p/125269
18:23:51 <rgr_> all I wanted was to have a "w" width and stick it that rectangle. That was 3 hours ago :-( I thought I would try to learn it all alone along the way. No hope :-( Incridbly dispirited now.
18:24:09 <rwbarton> rgr_: Can you give even more context?
18:24:19 <rwbarton> rgr_: If this is a top-level definition then what you are trying to do is impossible
18:24:20 <mmorrow> , let with w = (\f -> f w); withWidth = with 42 in withWidth (\ws -> ws)
18:24:22 <lunabot>  42
18:24:32 <rwbarton> rgr_: because clockMonitor must be a compile-time constant, but your screen width is not :)
18:24:37 <mmorrow> , let with w = (\f -> f w); withWidth = with 42 in withWidth (\ws -> (ws,[ws-4,12*ws]))
18:24:39 <lunabot>  (42,[38,504])
18:25:01 <mmorrow> @type let with x = \k -> k x in with
18:25:02 <lambdabot> forall t t1. t -> (t -> t1) -> t1
18:25:10 <mmorrow> @unmtl Cont
18:25:10 <lambdabot> err: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
18:25:13 <mmorrow> @unmtl Cont r a
18:25:13 <lambdabot> (a -> r) -> r
18:25:23 <mmorrow> @type let with x = \k -> k x in with 42
18:25:24 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
18:25:33 <mmorrow> @type let with x = \k -> k x in with 42 :: (Int -> o) -> o
18:25:34 <lambdabot> forall o. (Int -> o) -> o
18:25:45 <rgr_> YOu mean monitor can not be used to position things relative on different sized screens??
18:26:03 <rwbarton> rgr_: Well, I don't know what 'monitor' is
18:26:22 <rgr_> sorry. xmonad related.
18:26:42 <rgr_> but assuming it CAN be done, whats the synatx?
18:26:50 <rwbarton> It doesn't appear to be in xmonad or xmonad-contrib...
18:26:57 <rgr_> its in darcs.
18:27:02 <rwbarton> I see
18:27:18 <rgr_> its for "on top" things like process monitors and clocks ...
18:27:24 <rgr_> (mostly clocks ... :-;)
18:27:46 <rwbarton> You can construct this clockMonitor using the screen width, but only in the X monad.
18:28:07 <rwbarton> Whether that helps depends on what you need to do with clockMonitor
18:28:35 <rgr_> all that needs to be done is position it x pixels left of the right border. nothing magical.
18:28:49 <mmorrow> rgr_: here's an X11 helloworld which may be useful http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=726#a726
18:28:51 <rwbarton> rgr_: no, I mean, clockMonitor is some value
18:28:56 <rwbarton> rgr_: how do you use that value
18:29:09 <mmorrow> i think i got that from a page on the haskell wiki iirc
18:30:23 <rgr_> its a layout modifier if that means anything to you.
18:30:43 <rgr_> when positioning screen objects it recognises the window and sticks it where ti should be afaik.
18:31:31 <rgr_> mmorrow: how is that relevant (sorry, but am real beginner) ?
18:33:47 <int80_h> I just got RWH!
18:34:24 <cknapp> int80_h: :D. And now, no sleep for you!
18:34:38 <int80_h> so, there's this web site that talks about a good enviroment for application development with haskell. Of course I didn't save the link, and now I can't find it. Does this ring any bells with anyone?
18:35:16 <dobblego> http://www.gnu.org/software/emacs/ perhaps?
18:35:27 <dobblego> leksah?
18:35:39 <int80_h> no no, this was a step=by-step thing (set up darcs, and so on...)
18:35:56 <scsibug> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:35:59 <cknapp> Ah...
18:36:26 <int80_h> that's it
18:36:38 <int80_h> huh, I went to haskellwiki...
18:36:40 <scsibug> ya, that's a wonderful resource
18:37:50 <int80_h> I love this book
18:38:22 <int80_h> I'm going to try and preach the word to my gf's dad. He stopped programming a long time ago because it stopped being fun.
18:39:13 <__Ali__> is green card better than ffi or what?
18:39:23 <__Ali__> http://www.dcs.gla.ac.uk/fp/software/ghc/ghc-doc/green-card.html
18:39:28 <SamB_XP> I thought it was bitrotted
18:39:38 <ddarius> Greencard is a tool that uses the FFI.  All the tools use the FFI.
18:40:41 <__Ali__> ddarius: grren card somehow looks like swig interface, r there any other tools like it?
18:41:55 <ddarius> http://haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages
18:43:35 <rwbarton> rgr_: it looks like Monitor.hs does not support what you're trying to do.  It would take changing about 5 lines to make it do so, but it's also changes the API.
18:43:43 <int80_h> and the population of #haskell just keeps getting bigger
18:44:27 <rwbarton> rgr_: but I am not an xmonad expert
18:44:59 <int80_h> he's back!
18:46:05 <rgr_> rwbarton: I will make a paste. Could you show me just how to get a "global" value for width? I'm totally out of my depth now (tired and way past bed time).... Hang on.
18:46:09 <int80_h> uh ooh
18:46:11 <rwbarton> rgr_: No, it is not possible
18:46:18 <rwbarton> rgr_: because it is not a compile-time constant
18:46:35 <rgr_> but surely we can at least get a compile time width?
18:46:54 <rwbarton> Well, you can just run xdpyinfo to find out what the width is right now :)
18:47:09 * rgr_ pasted "syntax" at http://paste2.org/p/125279
18:47:17 <rgr_> ?
18:48:19 <rgr_> its kind of a thing to get a placeholder in now... I must be doing or thinkging wrong because it seems such an obvious thing to want to query in an window manager :-(
18:48:43 <shapr> hiya lambda
18:48:46 <rgr_> gah. brain and fingers have fused.
18:54:15 * Pseudonym is beginning to like Eclipse
18:54:26 <rwbarton> rgr_: consider this: You want xmonad to query the X server for the screen width so that you know where to put the monitor
18:54:32 <rwbarton> rgr_: when exactly do you expect that to happen?
18:55:02 <rgr_> in the managehook when layouts change
18:55:16 <rwbarton> rgr_: OK
18:55:48 <rwbarton> rgr_: The manage hook and layout modifiers could be modified to run code supplied by the user every time they are called, but that's not the way the code is now
18:56:07 <rwbarton> rgr_: (that's what I was alluding to before with my ~5-line change)
18:56:53 <rgr_> I'll drop an email to the monitor guy. It's beyond me at this stage now. I'm totally confused with Haskell. I do appreciate your help though.
19:02:38 <redditbot> Problems with Control.Applicative
19:02:59 <int80_h> redditbot --help
19:03:06 <int80_h> redditbot:
19:03:09 <int80_h> hmmm
19:06:50 <shapr> @seen bmeph
19:06:51 <lambdabot> I saw bmeph leaving #novalang, #ghc, #haskell-overflow and #haskell 1h 4m 32s ago, and .
19:06:52 <shapr> foo
19:07:07 <pumpkin> foo'?
19:13:04 <bigorilla> BobFunk: I found an irc log and it seems you had a similar problem to me. did you succeed getting SDL to work?
19:18:52 <\z> lambdabot?
19:19:03 <\z> @users
19:19:40 <Saizan> @bot
19:19:40 <lunabot>  :)
19:19:56 <Saizan> who killed her?!
19:20:17 * BMeph starts composing a parody of "Video Killed the Radio Star," only involving #novalang and lambdabot...
19:20:22 <\z> #novalang
19:20:33 <lambdabot> Maximum users seen in #haskell: 674, currently: 610 (90.5%), active: 19 (3.1%)
19:20:33 <lambdabot> :)
19:21:02 <chessguy> naughty noobs
19:22:06 <conal> wow -- growing channel
19:22:37 <thoughtp1lice> yeah, wasn't it just at like 640 or something earlier today?
19:23:03 <SamB_XP> 666, wasn't it ?
19:23:20 <SamB_XP> actually, I think it must have hit 670 today as well
19:25:35 <Elly> @pl (a * b -> c) -> (b -> a -> c)
19:25:36 <lambdabot> (line 1, column 8):
19:25:36 <lambdabot> unexpected ">"
19:25:36 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or ")"
19:25:42 <Elly> er, oops
19:25:47 <Elly> @djinn (a * b -> c) -> (b -> a -> c)
19:25:48 <lambdabot> Cannot parse command
19:25:50 <Elly> hm
19:25:51 <Elly> I did it wrong
19:26:54 <rwbarton> @djinn ((a, b) -> c) -> (b -> a -> c)
19:26:54 <lambdabot> f a b c = a (c, b)
19:32:06 <lepassive> I've finished Learn you a haskell tutorial and want to test my knowledge with simple programs any ideas ?
19:32:50 <helgim_> http://www.projecteuler.net - go nuts :)
19:33:57 <matthewp> lepassive: RWH book is a good start too
19:34:17 <lepassive> helgim_, I'm giving it a look
19:34:46 <lepassive> matthew-_, It drived me crazy when I tried to start haskell :(
19:36:49 <matthewp> lepassive: we're on the #novalang channel every Monday on the RWH book
19:37:47 <lepassive> matthewp, discussing the book or what ?
19:37:51 <wchogg> matthewp : do you think you guys will try dim dim again?
19:38:45 <matthewp> wchogg: not sure
19:38:48 <matthewp> was it helpful?
19:38:57 <matthewp> lepassive: yeah, we're doing a fizzbuzz right now though
19:39:01 <matthewp> just wrapping up for the night
19:39:41 <lepassive> matthewp, sorry what is fizzbuzz ?
19:39:45 <wchogg> matthewp : I did fizzbuzz in Haskell for my last job interview, it was amuzing
19:40:01 <\z> @google fizzbuzz
19:40:08 <lambdabot> http://www.codinghorror.com/blog/archives/000781.html
19:40:08 <lambdabot> Title: Coding Horror: Why Can't Programmers.. Program?
19:43:24 <matthewp> wchogg: yeah, it's always a good time
19:45:04 <lepassive> Prelude> [ x | x <- [1..1000], x `mod` 3==0] ++ [x | x <- [1..1000], x `mod` 5==0]
19:45:15 <lepassive> why can't i mix the 2 predicates ?
19:46:12 <lepassive> matthewp, btw where are the logs of #novalang ?
19:46:40 <matthewp> we're working on that
19:47:31 <pumpkin> lepassive: you can?
19:47:41 <pumpkin> that's sort of a puzzled assertion, btw
19:47:43 <pumpkin> more than a question
19:48:16 <pumpkin> > [ x | x <- [1..1000], x `mod` 3 == 0, x `mod` 5 == 0]
19:48:18 <lambdabot>   [15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,300,...
19:48:19 <lepassive> pumpkin, well it's and ORed predicate, all I know adding more predicates after comma
19:48:37 <rwbarton> lepassive: How about using || ?
19:48:39 <rwbarton> > True || False
19:48:40 <pumpkin> > [ x | x <- [1..1000], x `mod` 3 == 0 || x `mod` 5 == 0]
19:48:41 <lambdabot>   True
19:48:42 <lambdabot>   [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,...
19:49:04 <lepassive> rwbarton, that's make more sense than > [ x | x <- [1..1000], x `mod` 3 == 0, x `mod` 5 == 0]
19:49:46 <lepassive> pumpkin, i thought your expression means it's dividable by 3 and 5 in the same time not or
19:50:07 <diltsman> I don't suppose I could ask someone a really stupid question?
19:50:28 <lepassive> diltsman, you can I asked much more stupider
19:51:41 <diltsman> I'm trying to write an implementation of show for a datatype, but I keep getting an error on the '='
19:52:25 <diltsman> instance Show Token where \n show (TokenEof l) = "(EOF,\"\"," ++ show l ++ ")" \n show (TokenId xs l) = "(ID,\"" ++ xs ++ "\"," ++ show l ++ ")"
19:52:37 <diltsman> It yells at me on the third line there.
19:53:00 <diltsman> If I comment out the second line, then it doesn't yell at me.
19:53:30 <rwbarton> diltsman: It could be an indentation thing.  Can you paste it at hpaste.org/new ?
19:54:04 <rwbarton> Also the error message would be good :)
19:54:49 <matthewp> Thanks for everyone's help at #novalang at the RWH book club first meeting
19:54:56 <diltsman> http://hpaste.org/13661
19:54:56 <int80_h> I think I beat everyone here for the stupid question asking.
19:54:59 <int80_h> so there
19:55:38 <rwbarton> diltsman: That code compiles fine for me (if I make up a definition of Token)
19:55:43 <diltsman> token.hs:31:21: parse error on input `='
19:55:56 <diltsman> That is the error message
19:56:08 <rwbarton> which is line 31?
19:56:32 <rwbarton> It might be that the code above this has a missing ), or something.
19:57:58 <rwbarton> Character 21 of the last line isn't that close to the '='
19:58:26 <rwbarton> diltsman: Oh, maybe the second line begins with a tab and the first begins with four spaces
19:59:23 <diltsman> rwbarton: I remember seeing a page where it gave a Vim config file to highlight tabs and traling whitespace.  Do you know where that was?
19:59:42 <rwbarton> No, I don't, sorry
20:00:21 <diltsman> Yep, it was a stupid space vs. tab error.  I really wish I remembered where I had seen that config file, it makes it much harder to have these types of errors.
20:09:25 <gbacon> rwbarton: thanks again for your help
20:10:12 <gbacon> rwbarton: finally got a bunch of code that wanted to draw normally-distributed random numbers shoehorned into StateT a IO b
20:10:18 <chessguy> nice. we had as many as 38 in #novalang tonight for the first study session of RWH!
20:10:23 <gbacon> and boy are my arms tired
20:10:52 <int80_h> chessguy, gimme details. I might want to join up
20:11:18 * SamB_XP looks up to see where gbacon says he just flew in from
20:11:55 <gbacon> SamB_XP: from the nice, lovely land of purity into a dirty, stateful, destructively updated ghetto
20:12:55 <chessguy> int80_h:  monday nights at 8 pm EST
20:12:55 <gbacon> SamB_XP: all for want of pseudo-random numbers, what a price to pay :-)
20:13:13 <gbacon> and I'm missing the freakin' Fiesta Bowl :-(
20:15:03 <chessguy> int80_h: if you're in the northern VA area, i can give you more details on how to get in on it in person
20:16:23 <int80_h> rats...nah I'm in palo alto PA
20:16:56 <int80_h> what's on the agenda for the next meeting, I just got the book
20:17:17 <chessguy> int80_h:  chapters 3 and 4
20:17:20 <chessguy> or at least 3
20:17:37 <chessguy> int80_h:  i'm from harrisburg originally, by the way, not too far from you
20:18:01 <int80_h> I mean palo alto CA. sorry. I'm a little distracted
20:18:08 <chessguy> oh, haha
20:18:31 <chessguy> ok, that's a bit farther :)
20:21:11 <adamvo> > [1..]
20:21:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:21:20 <adamvo> > [False..]
20:21:21 <lambdabot>   <no location info>: parse error on input `]'
20:21:24 <adamvo> > [False ..]
20:21:25 <lambdabot>   [False,True]
20:21:40 <adamvo> Does that strike anyone as inconsistent with the space requirement?
20:22:00 <ddarius> adamvo: Nope.
20:23:18 <chessguy> adamvo:  space requirement?
20:23:23 <rwbarton> > [.]
20:23:24 <lambdabot>   <no location info>: parse error on input `]'
20:23:43 <adamvo> sorry if that was kind of ambigous
20:23:58 <adamvo> you need to put a space after any enum class member
20:24:01 <pumpkin> I'm trying to compute entropy over a sequence of real-valued samples, and am putting the values into bins to determine "distinctness"
20:24:03 <adamvo> except numbers
20:24:06 * Saizan wishes for a MonadOrElse and an instance of [] for it
20:24:17 <pumpkin> what's a good number of bins to choose?
20:24:28 <pumpkin> the number of samples?
20:24:35 <adamvo> pumpkin: for graphing?
20:24:47 <pumpkin> adamvo: for doing a bunch of things with, really
20:25:03 <erikc> diltsman: see help list and help listchars, e.g. i use listchars=tab:->,trail:> and gets lines like "--->--->tabbed line with trailing whitespace>>>"
20:25:09 <rwbarton> adamvo: nope.  False.. is parsed as the . operator in the False module
20:25:23 <rwbarton> > let false = False in [false..]
20:25:25 <lambdabot>   [False,True]
20:27:54 <adamvo> pumpkin: 3.5*stdev/n^(1/3) works pretty well
20:27:59 <pumpkin> :o
20:28:16 <adamvo> for graphing at least
20:28:21 <pumpkin> I mean
20:28:26 <pumpkin> for actually computing the entropy
20:28:44 <pumpkin> you sum up the log products for each symbol and its probability
20:28:51 <pumpkin> how do you map real numbers to discrete symbols?
20:29:16 <adamvo> that formula is the bin width
20:29:39 <pumpkin> what does "works well" mean though?
20:29:50 <pumpkin> and how did you get it?
20:29:57 <adamvo> its out of a book
20:30:05 <ddarius> Adamant: That's not a requirement.  The requirement is you need a space between a constructor and the (.) operator otherwise it will look like module qualification.
20:30:28 <Adamant> Adamant is always required.
20:30:30 <lepassive> where's primes ?
20:30:32 <ddarius> Er adamvo
20:30:37 <ddarius> Apologies Adamant
20:30:42 <pumpkin> adamvo: interesting, do they have a derivation?
20:30:43 <Adamant> ddarius: np
20:31:52 <adamvo> nope, but it refers to http://biomet.oxfordjournals.org/cgi/content/abstract/66/3/605
20:32:29 <adamvo> and is probably optimized for a gaussian distribution
20:32:50 <pumpkin> interesting
20:33:58 <chessguy> wchogg:  ping?
20:34:52 <pumpkin> anyone else have any thoughts on that?
20:37:55 <chessguy> pumpkin: sounds like the kind of thing PCI would address
20:38:09 <chessguy> though i don't have the book yet
20:38:14 <pumpkin> PCI?
20:38:27 <chessguy> http://oreilly.com/catalog/9780596529321/
20:38:41 <pumpkin> :o
20:38:54 <chessguy> pumpkin:  a study group is working on translating the libs in it to haskell
20:39:05 <pumpkin> why would that deal with a continuous variable though?
20:39:14 <pumpkin> I can browse it online
20:39:41 <chessguy> hm, i doubt it deals with only discrete data
20:40:02 <pumpkin> it seems remarkably hard to find a good reference on this :(
20:41:00 <pumpkin> can't find any occurrences of it in that book :/
20:44:01 <chessguy> so we had an interesting discussion tonight in our RWH study group about the sort of promises you get out of a type signature like [a] -> a
20:44:17 <chessguy> namely, it will always return an element from the list (or bottom)
20:44:35 <pumpkin> are you sure? :o
20:44:55 <Saizan> it can't do otherwise due to parametricity
20:44:59 <chessguy> how could it not?
20:45:12 <pumpkin> oh I guess I was thinking of typeclasses, but you didn't include that
20:45:28 <Saizan> because it doesn't have the ability to choose a particular type for a
20:45:39 <chessguy> i wonder if there are more "promises" like that hidden beneath the surface
20:46:06 <Saizan> it "promises" you to be partial :)
20:46:11 <chessguy> or if that's an anomaly
20:46:43 <sclv> chessguy: have you read "theorems for free!"
20:47:01 <chessguy> hm, not sure
20:47:12 <chessguy> @go theorems for free
20:47:18 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
20:47:21 <Saizan> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html
20:47:44 <Saizan> @free map
20:47:46 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
20:48:39 <SamB_XP> @free f :: [a] -> a
20:48:39 <lambdabot> g . f = f . $map g
20:49:49 <SamB_XP> @free null
20:49:51 <lambdabot> null = null . $map f
20:50:00 <SamB_XP> @free newVar
20:50:01 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `newVar'\n\n"
20:50:11 <chessguy> hm. anyway, bed for me
20:50:16 <SamB_XP> @free isDigit
20:50:18 <lambdabot> isDigit = isDigit
20:50:30 <SamB_XP> @free read
20:50:31 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Read a) => String -> a\n"
20:50:46 <SamB_XP> @free (>>=)
20:50:47 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
20:51:01 <SamB_XP> wacky
20:51:13 <SamB_XP> @help free
20:51:14 <lambdabot> free <ident>. Generate theorems for free
20:51:16 <Saizan> @free (+)
20:51:16 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
20:51:28 <SamB_XP> @type (+)
20:51:29 <lambdabot> forall a. (Num a) => a -> a -> a
20:51:35 <SamB_XP> @let plus = (+)
20:51:37 <lambdabot>  Defined.
20:51:42 <SamB_XP> @free plus
20:51:44 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Num a) => a -> a -> a\n"
20:51:50 <Saizan> it doesn't like operators
20:51:57 <sclv> @free beer :: (a -> b) -> [a] -> [b]
20:51:58 <lambdabot> g . h = k . f => $map g . beer h = beer k . $map f
20:51:58 <SamB_XP> it also doesn't like classes
20:52:06 <pumpkin> it's not very friendly is it
20:52:10 <pumpkin> doesn't like anyone!
20:52:18 <SamB_XP> @free (++)
20:52:18 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
20:52:22 <SamB_XP> @let append = (++)
20:52:24 <lambdabot>  Defined.
20:52:26 <SamB_XP> @free append
20:52:27 <lambdabot> $map f . append xs = append ($map f xs) . $map f
20:52:55 <SamB_XP> @tell Cale @free doesn't like operators -- try @free (++)
20:52:56 <lambdabot> Consider it noted.
20:53:38 <SamB_XP> @tell Cale please send this "upstream" if appropriate ...
20:53:38 <lambdabot> Consider it noted.
20:54:08 <sclv> Free theorems and type class morphisms seems to be approx. equal
20:54:44 <sclv> or at least free theorems on list functions provide type class morphisms over the list functor, approx.
20:54:49 <Saizan> @tell Cale maybe activate a trac on community.haskell.org for lambdabot so that we can stop @tell-ing you about bugs
20:54:50 <lambdabot> Consider it noted.
20:55:18 <sclv> this observation of mine could be either productive, or utterly blindingly obvious.
20:56:05 <Elly> sclv: it's funny how hard it is to distinguish those things sometimes
20:56:07 <SamB_XP> @tell conal sclv says: Free theorems and type class morphisms seems to be approx. equal
20:56:07 <lambdabot> Consider it noted.
20:56:13 <Saizan> i guess saying that something is a typeclass morphism can often involve showing that it respects parametricity
20:56:52 <ddarius> For Functor, I mentioned that the "type class morphism" is always satisfied (modulo seq)
20:56:59 <ddarius> (mentioned to conal that is)
20:58:04 <sclv> right -- list latest post pointed out that any number of these arise naturally out of composition of functors and applicatives, etc.
20:58:28 <SamB_XP> what post ?
20:59:28 <sclv> on conal's blog -- the one on futures and an alternate model to unamb mentioned this in passing.
21:00:59 <SamB_XP> you mean http://conal.net/blog/posts/another-angle-on-functional-future-values/ ?
21:01:54 <Saizan> ddarius: considering that a Functor morphism is a natural transformation?
21:09:37 <ddarius> Saizan: Essentially, yes.
21:10:58 <SamRH> What's the latest recommended ghc for building lambdabot?
21:11:53 <pumpkin> 6.8
21:12:09 <SamRH> ok thank
21:19:56 <Saizan> i don't suppose there's a name for something with a binary associative operation and an annihilator? e.g. (Nat,(*),0)
21:20:24 <ddarius> "semigroup with zero" ?
21:25:22 <matthewp> dons: there?
21:29:29 <lepassive> What is the meaning of dollar sign in haskell expressions ?
21:29:54 <matthewp> @t ($)
21:29:54 <pumpkin> lepassive: usually used to twiddle the precedence a little, and avoid parentheses
21:29:55 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:29:57 <pumpkin> but it just means apply
21:30:18 <matthewp> :t ($)
21:30:20 <lambdabot> forall a b. (a -> b) -> a -> b
21:30:25 <pumpkin> @src apply
21:30:26 <lambdabot> Source not found. Wrong!  You cheating scum!
21:30:29 <pumpkin> @src ($)
21:30:29 <lambdabot> f $ x = f x
21:30:30 <pumpkin> lol
21:30:33 <pumpkin> not sure where that came from
21:31:23 <lepassive> pumpkin, thanks but I really don't get it :(
21:31:38 <pumpkin> so say you have f (g (h x))
21:31:40 <lepassive>         putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
21:31:53 <pumpkin> lepassive: without the $
21:32:07 <pumpkin> that would be evaluated as (putStrLn "Which color do you associate with the number ") ++ show a ++ "?"
21:32:34 <ddarius> ($) = id.  ($) doesn't do anything.
21:33:01 <pumpkin> what you want is really putStrLn ("Which color do you associate with the number " ++ show a ++ "?"), but that's a pain to have to add a parenthesis to each side
21:33:03 <lepassive> pumpkin, ahh now it's obvious it keeps the evaluation on hold
21:33:22 <pumpkin> so people made an operator with 0 precedence to "delay" things a bit and avoid writing parentheses, I guess :P
21:34:00 <ddarius> lepassive: Again, ($) doesn't do anything at all.
21:34:50 <johnnowak> ddarius: how does $ == id?
21:35:10 <ddarius> :t [($), id]
21:35:11 <lambdabot> forall a b. [(a -> b) -> a -> b]
21:35:24 <ddarius> @pl ($)
21:35:25 <lambdabot> id
21:36:24 <Saizan> pumpkin: clearer and more precised to say parsed rather than evaluated there
21:36:31 <ddarius> Actually, I guess there is a slight difference.
21:36:33 <pumpkin> yeah, sorry :)
21:36:38 <ddarius> > id undefined `seq` ()
21:36:40 <lambdabot>   * Exception: Prelude.undefined
21:36:47 <ddarius> > ($) undefined `seq` ()
21:36:49 <lambdabot>   ()
21:37:01 <johnnowak> ddarius: so what's with the output of @pl then?
21:37:12 <ddarius> johnnowak: @pl doesn't care about correctness.
21:37:17 <johnnowak> heh, i see.
21:38:09 <Saizan> seq on functions is really evil..
21:38:58 <Saizan> > let ($) :: (a -> b) -> a -> b; ($) f = f in ($) undefined `seq` ()
21:38:59 <lambdabot>   * Exception: Prelude.undefined
21:39:31 <mmorrow> > let ($) :: (a -> b) -> a -> b; ($) = id in ($) undefined `seq` ()
21:39:33 <lambdabot>   * Exception: Prelude.undefined
21:40:01 <mmorrow> > (id::a->a) undefined `seq` ()
21:40:02 <lambdabot>   * Exception: Prelude.undefined
21:40:12 <mmorrow> > (id::(a->b)->(a->b)) undefined `seq` ()
21:40:13 <lambdabot>   * Exception: Prelude.undefined
21:40:28 <mmorrow> > let x = (id::(a->b)->(a->b)) in x undefined `seq` ()
21:40:29 <lambdabot>   * Exception: Prelude.undefined
21:40:38 <lepassive> okay what about the dot in >>> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"
21:40:40 <mmorrow> hmm
21:40:50 <ddarius> @src (.)
21:40:50 <lambdabot> (f . g) x = f (g x)
21:40:53 <Saizan> that's function composition
21:41:04 <lepassive> f following g ah
21:41:18 <mmorrow> > id (undefined::(a->b)) `seq` ()
21:41:19 <lambdabot>   * Exception: Prelude.undefined
21:41:26 <ddarius> lepassive: Almost everything operator-looking thing in Haskell is an actual operator (i.e. function) as opposed to syntax.
21:42:25 <lepassive> ddarius, I'm so glad to pick up Haskell
21:42:30 <mmorrow> > (flip . flip) id undefined `seq` ()
21:42:32 <lambdabot>   ()
21:42:41 <mmorrow> > ($) undefined `seq` ()
21:42:42 <lambdabot>   ()
21:44:02 <mmorrow> @type [($), (flip . flip) id, id]
21:44:03 <lambdabot> forall b c. [(b -> c) -> b -> c]
21:45:21 <mmorrow> f $ x === f `id` x === (flip . flip) id f x =/= id f x -- (wrt strictness)
21:45:25 <mmorrow> interesting..
21:45:25 <evanlenz_> Haskell is frighteningly deep and transparent. Every time I think I've bumped up against something special, it just falls over and I have to keep searching for the perimeters of this language.
21:46:00 <mmorrow> evanlenz_: get used to it, because it won't stop. :)
21:46:31 <evanlenz_> heh, I don't know if I should celebrate and continue or run away
21:46:59 <mmorrow> just pass yourself as a continuation and it'll all work out just fine.
21:47:02 <mmorrow> ;)
21:47:17 <evanlenz_> heh, I'm sure I'll get that joke soon enough
21:48:02 <ddarius> @quote fix.a.relationship
21:48:02 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
21:48:14 <helgim_> cabal: cannot configure syb-0.1.0.0. It requires base >=4.0 -- is this a known problem? I just installed cabal and I honestly don't know anything of its workings, and google isn't helping
21:48:32 <evanlenz_> nice quote :)
21:48:34 <Heffalump> helgim_: ghc 6.8?
21:48:36 <evanlenz_> For a function to be used with infix notation it needn't take more than one argument. is that true?
21:48:37 <helgim_> yes
21:48:49 <Heffalump> helgim_: syb is part of the 6.8 distro, you don't need a separate package for it
21:48:51 <helgim_> 6.8.2 as a matter of fact
21:48:57 <Heffalump> are you trying to install that, or something that claims to depend on it?
21:49:10 <helgim_> I am running cabal ugprade
21:49:46 <Heffalump> hmm. Then I don't know why it's doing that. I suspect it's confused.
21:49:52 <evanlenz_> sqrt `id` 12
21:50:07 <mmorrow> > 42
21:50:09 <lambdabot>   42
21:50:27 <Heffalump> evanlenz_: well, that works with id which can sort of be "fooled" into taking two arguments
21:50:31 <mmorrow> > sqrt `id` 12
21:50:32 <lambdabot>   3.4641016151377544
21:50:41 <Heffalump> > 5 `sqrt` 3
21:50:42 <lambdabot>       No instance for (Floating (t -> a))
21:50:43 <lambdabot>        arising from a use of `sqrt'...
21:50:44 <evanlenz_> Even though id just has one argument, it can be used as infix, provided it's applied to a function?
21:50:53 <Heffalump> right
21:50:53 <Saizan> cabal's dependency resolver is not so smart currently, so upgrade is likely to fail
21:51:18 <mmorrow> it's tricky to see how the type unifies, but once you have the "aha" it's obvious in hindsight
21:51:39 <evanlenz_> I feel on the edge of the "aha"
21:52:04 <mmorrow> ((f :: a  -> b) `id` (x :: a)) :: b
21:52:21 <mmorrow> == id f a
21:52:29 <mmorrow> == (id f) a
21:52:36 <Gracenotes> ...
21:52:43 <mmorrow> ==> id :: (a ->  b) -> (a -> b)
21:52:50 <helgim_> Saizan: cabal: cannot configure haskell-src-exts-0.4.6. It requires base >=4 -- if I dare try and install lambdabot
21:52:59 <mmorrow> == :: (a -> b) -> a -> b
21:53:07 <mmorrow> @type ($)
21:53:08 <lambdabot> forall a b. (a -> b) -> a -> b
21:53:16 <Heffalump> that implies it requires ghc 6.10, I think
21:53:23 <Heffalump> I don't think you can install base 4 on ghc 6.8
21:53:33 <helgim_> Ah
21:53:43 <helgim_> I'll give 6.10  shot at least
21:53:49 <mmorrow> so the `a' in
21:53:49 <Saizan> you can install an earlier version of haskell-src-exts though
21:53:51 <mmorrow> @type id
21:53:52 <lambdabot> forall a. a -> a
21:54:08 <mmorrow> gets expanded to  (b -> c)
21:54:18 <Saizan> ?hackage haskell-src-exts
21:54:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-exts
21:54:30 <mmorrow> or more in line with lingo, "unified"
21:54:49 <evanlenz_> "the type unifies"
21:54:50 <Saizan> helgim_: cabal install haskell-src-exts-0.3.9
21:55:24 <pumpkin> anyone have any thoughts on my question from earlier? finding a good number of bins for computing entropy on a continuous variable (sampled discretely)?
21:55:27 <mmorrow> imagine the type (a -> a) as a tree
21:55:32 <helgim_> Saizan: cabal: happy version >=1.17 is required but it could not be found. -- and an exit with ExitFailure 1
21:55:38 <mmorrow> , [t|forall a. a -> a|]
21:55:45 <Saizan> helgim_: cabal install happy :)
21:55:49 <lunabot>  ForallT [a_0] [] (AppT (AppT ArrowT (VarT a_0)) (VarT a_0))
21:55:53 <Heffalump> why doesn't it do that automatically?
21:55:59 <alsonk> Anyone have an idea when GHC 6.10 is going to get into Debian?
21:56:06 <helgim_> Oh, I thought it was trying to do that for me and was complaining... :P
21:56:14 <pumpkin> Heffalump: for some reason it only does lib dependencies, not "programs"
21:56:16 <evanlenz_> what's lunabot?
21:56:19 <mmorrow> App (App (->) a) a
21:56:28 <Saizan> Heffalump: it's a build-tool and currently it tracks only build-depends
21:56:34 <dolio> , [$ty| id |]
21:56:39 <mmorrow> data Tree a = Tip a | Fork (Tree a) (Tree a)
21:56:45 <lunabot>  forall a . a -> a
21:56:48 <evanlenz_> and is that | notation Haskell?
21:57:00 <mmorrow> Fork (Fork (Tip (->)) (Tip a)) (Tip a)
21:57:10 <dolio> , [$ki| (->) |]
21:57:12 <lunabot>  luna: Not in scope: `ki'
21:58:09 <mmorrow> so if you imagine the corresponding tree with s/a/(b->c)/, and if you were to walk down the trees in lockstep (zip the trees), when you arrive and the leaves you'd find that the difference between the trees is
21:58:17 <mmorrow> a <------> (b -> c)
21:58:30 <mmorrow> and then you unify them
21:58:46 <mmorrow> and since there are no conflicts, it typechecks
21:59:28 <ddarius> evanlenz_: All functions in Haskell take exactly one argument.
22:00:09 <evanlenz_> ddarius: yes, that's what I have to keep in mind. That reminder helps very much.
22:00:10 <Gracenotes> so going through the tree inorder, you get [[Tip ->] Fork [Tip a]] Fork [Tip a]
22:01:06 <Gracenotes> hm.
22:01:51 * bos is mystified by the huge spread in performance of his multithreaded code
22:02:37 <evanlenz_> mmorrow: where does the ForallT notation come from?
22:02:40 <mmorrow> , let typeToTree (Forall _ _ t) = typeToTree t; typeToTree (t `AppT` t') = Node [] [typeToTree t, typeToTree t']; typeToTree t = Node [t] [] {- i'm ignoring a bunch of contructors and and ingoring foralls here -} in typeToTree (unQ[t|forall a. a -> a|])
22:02:42 <lunabot>  luna: Not in scope: data constructor `Forall'
22:02:45 <mmorrow> frr
22:02:46 <mmorrow> gr
22:02:51 <mmorrow> , let typeToTree (ForallT _ _ t) = typeToTree t; typeToTree (t `AppT` t') = Node [] [typeToTree t, typeToTree t']; typeToTree t = Node [t] [] {- i'm ignoring a bunch of contructors and and ingoring foralls here -} in typeToTree (unQ[t|forall a. a -> a|])
22:02:54 <lunabot>  Node {rootLabel = [], subForest = [Node {rootLabel = [], subForest = [Nod...
22:02:55 <mmorrow> it's template-haskell
22:03:12 <sbahra> quasi-quotes = template haskell feature, right?
22:03:16 <mmorrow> which is just a representation of haskell syntax by haskell syntax
22:03:20 <evanlenz_> an extension, yes?
22:03:32 <evanlenz_> ah, cool
22:03:52 <mmorrow> yes, but it has (to some extent) a formal spec
22:03:59 <mmorrow> (but only ghc implems it)
22:04:04 <evanlenz_> useful for macros? Or just theory?
22:04:10 <mmorrow> exactly
22:04:16 <mmorrow> macro-ish things
22:04:28 <sbahra> nod
22:04:29 <mmorrow> you can't generate arbitrary haskell code at compile-time
22:04:41 <mmorrow> , [|42|]
22:04:44 <lunabot>  LitE (IntegerL 42)
22:04:59 <pumpkin> mmorrow: how do you mean?
22:05:05 <Saizan> you mean that the TH AST doesn't include all the GHC extensions?
22:05:09 <pumpkin> arbitrary haskell code?
22:05:17 <pumpkin> I thought TH was all-powerful!
22:05:27 <mmorrow> err, if you'd do this in ghci, you'd need to do (since lunabot defines instances of Show for ExpQ, .. which aren't in the libs):
22:05:42 <mmorrow> ghci> :m + Language.Haskell.TH.Syntax
22:05:48 <evanlenz_> So regular Haskell is just a gateway drug?
22:05:51 <mmorrow> ghci> :m + Language.Haskell.TH.Lib Language.Haskell.TH.Ppr
22:06:02 <mmorrow> ghci> runQ [|42|] -- would print it
22:06:24 <mmorrow> evanlenz_: better start picking out a nice crack pipe
22:06:32 <evanlenz_> :)
22:06:41 <mmorrow> , [|42|]
22:06:43 <lunabot>  LitE (IntegerL 42)
22:06:45 <mmorrow> , $( [|42|] )
22:06:47 <lunabot>  42
22:06:51 <mmorrow> , $( [|42|] ) == 42
22:06:54 <lunabot>  True
22:07:22 <pumpkin> mmorrow: what if you wanted to have TH automatically write a large case statement for you from an external data file?
22:07:24 <mmorrow> , (\x -> [|show $( [|x|] )|]) 42
22:07:26 <lunabot>  AppE (VarE show) (LitE (IntegerL 42))
22:07:35 <mmorrow> , $((\x -> [|show $( [|x|] )|]) 42)
22:07:36 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
22:07:45 <mmorrow> , $((\x -> [|show $( [|x|] )|]) (42::Int))
22:07:47 <lunabot>  "42"
22:08:16 <Saizan> it feels a bit weird that the quoted code is typechecked
22:09:00 <mmorrow> level 0..[|..level 1..$(..level 0..[|..level 1..|]..0..)..1..|]..0
22:09:52 <Saizan> pumpkin: you can
22:10:29 <mmorrow> , let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|Just ()|]
22:10:32 <lunabot>  AppE (VarE show) (AppE (VarE show) (AppE (VarE show) (AppE (VarE show) (A...
22:10:36 <mmorrow> , $(let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|Just ()|])
22:10:38 <lunabot>  "\"\\\"\\\\\\\"Just ()\\\\\\\"\\\"\""
22:10:45 <pumpkin> :o
22:11:23 <mmorrow> , [d|data A a = A | B a|]
22:11:26 <lunabot>  DataD [] A [a_0] [NormalC A [],NormalC B [(NotStrict,VarT a_0)]] []
22:11:42 <mmorrow> , [t|forall a. (a -> [Int]) -> Either () Bool|]
22:11:42 <Gracenotes> a_0
22:11:44 <lunabot>  ForallT [a_0] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a_0)) (AppT ...
22:12:15 <mmorrow> (ppDoc is defined by lunabot, but it's easy)
22:12:23 <mmorrow> , ppDoc `fmap` [t|forall a. (a -> [Int]) -> Either () Bool|]
22:12:25 <lunabot>  forall a_0 . (a_0 -> [Int]) -> Either () Bool
22:12:29 <mmorrow> , ppDoc' `fmap` [t|forall a. (a -> [Int]) -> Either () Bool|]
22:12:32 <lunabot>  forall a . (a -> [Int]) -> Either () Bool
22:12:50 <mmorrow> cleanName = (mkName . nameBase)
22:13:07 <mmorrow> cleanNames = everywhere (mkT (mkName . nameBase))
22:13:24 <mmorrow> ppDoc = text . pprint . cleanNames
22:13:43 <evanlenz_> Is there a tutorial that teaches Haskell using a severely restricted subset of its available syntax (sugar)? People might not be motivated to learn it, but it might prevent invalid assumptions like the idea that functions can really take more than one argument.
22:14:02 <mmorrow> (be careful though because that version of cleanNames will zap uniq numbers on vars and make a_0 look like a_1 in the prettyprinted output)
22:14:39 <mmorrow> evanlenz_: i'm not sure
22:14:51 <evanlenz_> Are if expressions just sugar for case expressions?
22:15:03 <ddarius> evanlenz_: They can be viewed that way, yes.
22:15:31 <evanlenz_> > case p of { True -> "true"; False -> "false" }
22:15:32 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Bool'
22:16:17 <evanlenz_> Does the language definition denote the various levels of sugar?
22:16:20 <mmorrow> Expr is just this pkg that has a clever way to print do symbolic eval of expressions
22:16:37 <mmorrow> > (\p -> case p of { True -> "true"; False -> "false" }) False
22:16:39 <lambdabot>   "false"
22:16:40 <ddarius> evanlenz_: Most of the constructs in the Report are explained by translation to a "core" language.
22:17:01 <evanlenz_> cool, so maybe "core" is what I want to look into
22:17:09 <mmorrow> the real error there was that `p' was undeclared
22:17:24 <evanlenz_> An "ascetic's intro to Haskell" or something like that
22:17:32 <evanlenz_> mmorrow: got it, thanks
22:18:07 <evanlenz_> does core include function definition pattern matching?
22:18:13 <mmorrow> evanlenz_: heh, i wish i found something like "the ascetic's intro to haskell" when i started.
22:19:07 <evanlenz_> I'll have to look at the report
22:19:23 <ddarius> Pattern matching gets translated into case.
22:19:25 <mmorrow> (just be wary that when people say "core" they may mean either in the sense of the Core language that a compiler like ghc might use as an intermediate lang, or core in the sense of a conceptual core of the language.
22:19:28 <mmorrow> )
22:19:54 <ddarius> evanlenz_: You can read the Report.  It isn't that bad (or long.)
22:19:56 <ddarius> @where report
22:19:56 <lambdabot> http://www.haskell.org/onlinereport/
22:20:10 <evanlenz_> cool, thanks
22:20:20 <mmorrow> i guess there's overlap between those, but not knowing there was these two overlapping concepts might be really confusing
22:20:25 <SubStack> wtf, I build 6.10.1 and ghci won't even terminate on ^d or ^c, it takes a ^ to bring it down
22:20:56 <mmorrow> SubStack: did you run "let x = x in x" or something..
22:21:00 <SubStack> no
22:21:01 <SubStack> just ghci
22:21:10 <mmorrow> yeah :)
22:21:30 <SubStack> Prelude> ^D^D^CPrelude> ^CPrelude> ^CPrelude> ^D^D^D^D^D
22:21:32 <SubStack> grumble
22:21:52 <mmorrow> let x = x in x will make ghci begin attempting to consume all your mem and won't stop until you kill -9 it
22:21:57 <SubStack> that's not it
22:22:00 <mmorrow> (fix id, etc..)
22:22:05 <SubStack> it's not running any code
22:22:12 <mmorrow> ohhh
22:22:13 <SubStack> it's just at the prompt
22:22:14 <Gracenotes> oh, jeez
22:22:17 <SubStack> I don't load any code either
22:22:20 <mmorrow> looks like you don't have libedit?
22:22:27 <bos> SubStack: it's a problem with the editline package
22:22:32 <mmorrow> ghci uses editline instead of readline now
22:22:37 <SubStack> o_O
22:22:54 <mmorrow> sudo yum install -y *libedit*
22:22:59 <mmorrow> or equiv should fix that
22:23:19 <SubStack> cool beans
22:23:39 <mmorrow> bad news is that if you compiled it yourself, you'll have to do it again :(
22:23:59 <SubStack> :(
22:25:22 <Gracenotes> okay, time for more SICP video
22:25:26 * Gracenotes grabs some popcorn
22:26:25 <mmorrow> <pumpkin> mmorrow: what if you wanted to have TH automatically write a large case statement for you from an external data file?
22:26:30 <mmorrow> i missed that before
22:26:43 <mmorrow> you can do this, but i haven't had very good experiences with it
22:27:22 <mmorrow> (the exponential increase in compile time with large amounts of static data thing)
22:27:58 * mmorrow doesn't know if it's /actually/ exponential, but it sure looks like it
22:28:31 <afabian> (n^n)!
22:28:56 <mmorrow> i wouldn't rule that out ;) :| :((
22:29:49 <pumpkin> yeah
22:29:53 <pumpkin> boo! :)
22:30:51 <pumpkin> I read somewhere on ghc's trac that there was a bug where there was a quadratic increase on some kind of object allocation in (something correlated with) the size of the file
22:30:58 <mmorrow> JaffaCake said on haskell-cafe (alex author) that using Addr# literals works ok for him (but unfortunately TH doesn't have the rep for this type in its AST currently)
22:31:18 <mmorrow> "asdfdsasdfds"#
22:31:22 <mmorrow> :: Addr#
22:31:35 <mmorrow> (ghc-specific i believe)
22:31:55 <mmorrow> (data Ptr a = Ptr Addr#)
22:37:01 <BMeph> Dang, I just put up udcode 0.2.0.0 - time to refactor! ;p
22:50:17 <sbahra> Is there a page detailing the implementation details of MVar?
22:50:37 * sbahra wants something reflecting similar semantics to RW mutexes
22:54:08 <enticingjelly> @src MVar
22:54:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:54:19 <enticingjelly> @help
22:54:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:54:21 <enticingjelly> @list
22:54:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:55:07 <Gracenotes> is it just me, or are lambdabot's insults getting less insult-ier?
22:55:16 <enticingjelly> @src Control.Monad.MVar
22:55:17 <lambdabot> Source not found. stty: unknown mode: doofus
22:55:19 <sbahra> Aren't the insults random?
22:55:22 <sbahra> There we go :)
22:55:23 <Gracenotes> yes
22:55:26 <enticingjelly> Gracenotes, apparently not 8)
22:55:37 <enticingjelly> @src Control.Concurrency.MVar
22:55:38 <lambdabot> Source not found. You speak an infinite deal of nothing
22:55:39 <Gracenotes> heh
22:56:23 <enticingjelly> pfft. had to use google.
22:56:24 <enticingjelly> http://hackage.haskell.org/packages/archive/base/3.0.1.0/doc/html/src/Control-Concurrent-MVar.html
22:56:56 <sbahra> Yes, that isn't really telling me much.
22:57:02 <enticingjelly> only to discover that, of course, the real magic is in GHC.Conc...
22:57:20 <Gracenotes> sbahra: they can become less insult-ier, however, if less-insult-ier items are added to the random list to dilute the most insult-ier ones
22:57:52 <sbahra> Gracenotes, sure
22:58:23 <sbahra> Hm
22:58:27 <oklopol> not having the context, i'm going to suggest "insulting"
22:58:29 <sbahra> I think I'll just use a Chan for now, then
22:58:33 <Gracenotes> I don't recall having seen the scrambler insult yet ;)
22:58:40 <Gracenotes> anyways.
22:58:46 <sbahra> I've seen it
22:59:14 <Gracenotes> maybe we could hire some joke-writers for lambdabot?
22:59:36 <sbahra> Eddie Murphy?
22:59:56 <Gracenotes> oh, perfect, who doesn't appreciate the humor of Eddie Murphy. (rhetorical question)
23:00:57 <sbahra> Gracenotes, have you considered being a joke writer for lambdabot?
23:01:01 <sbahra> You're on a roll.
23:01:19 <Gracenotes> I know. I'm like butter!
23:02:58 <prb> sbahra: IIRC there are academic-ish papers on concurrent haskell you can read to get afeel for the implementation.
23:03:21 <sbahra> Hrm, I guess I could implement RW by strictly evaluating MVar for now.
23:03:21 <prb> sbahra: But if there's a particular semantic you want, you can probably synthesize it out of MVar and Chan.
23:03:30 <sbahra> and some trivial ADT
23:03:34 <sbahra> prb, nod
23:03:42 <sbahra> prb, I was hoping it not to be the case
23:05:33 <prb> sbahra: Something like this: http://github.com/prb/perpubplat/tree/master/src/Blog/BackEnd/Holder.hs ?
23:06:11 <sbahra> Not quite
23:06:15 <sbahra> But that's pretty
23:07:48 <azathoth99> haskell free clone of world of warcraft out yet?
23:08:27 <bos> that was last year.
23:10:31 <azathoth99> warhammer?
23:10:47 <azathoth99> when is haskell web broswer out?
23:10:51 <azathoth99> and haskell dns server?
23:11:06 <sbahra> Haskell DNS server would be a fun project.
23:11:27 <azathoth99> or haskell app that combines dns dhcp nfs ldap postgres hiawatha and nagios into one thing?
23:11:50 <newsham> i have some dns marshalling code if you want to do a dns server
23:12:05 <enticingjelly> azathoth99, that seems like an awful combination
23:12:07 <newsham> http://www.thenewsh.com/~newsham/x/machine/dns/
23:12:16 * sbahra doesn't, atleast not now
23:12:38 <sbahra> newsham, cool, though
23:12:43 <newsham> there's an example tiny dns server that always responds with the same ansewr in there
23:12:47 <sbahra> newsham, what were you planning to do with this?
23:12:55 <newsham> i was using it for some code i wrote
23:13:05 <sbahra> I've bookmarked it, hopefully you won't move it
23:13:09 <sbahra> newsham, code for?
23:13:21 <newsham> top secret stuff
23:13:33 <newsham> but this code is free/public domain/etc.
23:13:50 <sbahra> ic
23:14:14 <sbahra> pretty useful
23:16:11 <sbahra> :t second
23:16:12 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
23:16:29 <jeffz`> azathoth99: wb
23:16:50 <sbahra> newsham, I'd like to see something like libnet for Haskell
23:16:57 <vixey> in System F values and types are in the same syntactic category?
23:17:01 <sbahra> newsham, that's somewhere on my list of things to do if I ever have time
23:18:01 <vixey> "System F1 is the simply-typed lambda calculus"
23:18:32 <newsham> i'd love to see someone do libdnet bindings
23:18:49 <newsham> and some generic easy to use marshalling library
23:19:04 <newsham> with marshallers for common protocols like IP and TCP
23:20:04 <sbahra> newsham, nod
23:20:50 <Saizan> aren't you writing one?:)
23:22:37 <newsham> i've been writing various marshallers off and on for a while
23:22:44 <newsham> i'll let you know when i'm happy with one :)
23:22:50 <naturalethic> is there a popular function for splitting a string on an arbitrary char?
23:23:20 <Saizan> @wiki Data.List.Split
23:23:20 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
23:23:48 <Saizan> or maybe span/break if you only need to split on the first occurrence
23:24:10 <vixey> does anyone have particular favorite papers/codes that are about bidirectional type checking?
23:24:12 <newsham> > span (/= ' ') "foo bar"
23:24:14 <lambdabot>   ("foo"," bar")
23:24:30 <vixey> and I just saw something one frank pfennings site about tridirectional typechecking
23:24:37 <naturalethic> i could recurse that pretty easily for multiple parts it looks ?
23:24:44 <newsham> > second (drop 1) $ span (/= ' ') "foo bar"
23:24:45 <lambdabot>   ("foo","bar")
23:24:52 <Saizan> yeah
23:24:54 <vixey> > Just $ second (drop 1) $ span (/= ' ') "foo bar"
23:24:56 <lambdabot>   Just ("foo","bar")
23:24:56 <newsham> > second (dropWhile (== ' ')) $ span (/= ' ') "foo bar"
23:24:57 <lambdabot>   ("foo","bar")
23:24:59 <vixey> :t unfoldr
23:25:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:25:44 <newsham> vixey: working on variant types.  my head is hurting.
23:26:07 <vixey> like in ocaml ?
23:26:14 <newsham> http://hpaste.org/13667
23:26:37 <newsham> vixey: for marshalling    data Foo = Foo1 Int | Foo2 Char String | ...
23:27:24 <trofi> @hoogle binary
23:27:25 <lambdabot> package binary
23:27:25 <lambdabot> package binary-search
23:27:25 <lambdabot> package binary-strict
23:27:40 <vixey> newsham, ahh... so type Foo = (T1, T2, ...) was solved already
23:27:52 <newsham> oops, that paste wasnt complete.  http://hpaste.org/13668
23:27:56 <vixey> newsham, and now, the question is,  the generate Foo1 | Foo2 | ... ?
23:27:58 <vixey> general**
23:28:15 <newsham> vixey: yah, I can do   data Foo = Foo Int String Int already thanks to your help earlier
23:28:31 <vixey> I bet that sums are harder :p
23:28:40 <vixey> I haven't considered that axis actually
23:28:40 <newsham> its just aonther layer of GADTs
23:28:52 <newsham> I have to build up the type of the complicated fold function
23:29:18 <newsham> anyway, i'm most of the way there, but still some types to clean up
23:29:39 <newsham> hmm.. I guess hpaste cuts off the pastes after a certain size
23:29:45 <azathoth99> wb?
23:30:37 <azathoth99> how soon haskell os?
23:30:57 <newsham> there are some OSs written in haskell
23:31:01 <azathoth99> 1,000 node clsueters simply become functional grids!
23:31:10 <azathoth99> get out
23:32:02 <newsham> hOp and House, and an OS spec seL4
23:32:11 <vixey> newsham, but you can do polymorphic and variadic with a single GADT
23:32:19 <sbahra> interesting
23:32:26 <sbahra> newsham, data ... where ...; What is the name of this?
23:32:32 <newsham> gadt.
23:32:35 <sbahra> I haven't seen it before.
23:32:38 <vixey> so maybe it does not /have/ to be two GADTs
23:32:52 <vixey> (but it may be _easier_, it's not clear which is easiest yet)
23:32:58 <sbahra> http://en.wikibooks.org/wiki/Haskell/GADT
23:32:59 <newsham> vixey: having 2 is useful for decomposing the problem.
23:33:08 <newsham> since it still makes specifying simple record marshallers easy
23:33:19 <sbahra> Wow
23:33:23 <newsham> and you can reuse that code for specifying alternatives in the sum type
23:33:25 <sbahra> this is great
23:33:31 <vixey> a fun sort of puzzle is to write:
23:33:51 <vixey> build (X 1) (X "foo") (X True) End ~~> (1, ("foo", (True, ())))
23:34:24 <vixey> (it is possible)
23:35:06 <vixey> but something like,   sum (a :* b :* c END) (x :* y END) (u :* END)
23:35:19 <vixey> for data H = C1 a b c | C2 x y | C3 u
23:35:19 <dolio> vixey: F1 would let you quantify over 0th order things. But I don't think anything is 0th order.
23:35:42 * vixey forgot to end the sum
23:35:47 <dolio> Thus it would be the simply typed lambda calculus.
23:36:41 <newsham> do you mean instead of doing:     build (X 1 :> X "foo" :> X True :> End) ?
23:37:01 <dolio> At least, that statement implies that there are no 0th order types.
23:37:12 <vixey> newsham, that's a bit easier
23:37:39 <vixey> I would not be surprised for 0th order to be vacuous
23:38:25 <dolio> I'm not sure, though, because a 1st order function would accept 0th order parameters.
23:38:32 <dolio> Namely, non-function values.
23:38:52 <dolio> And concrete types are the type-level analogue to those.
23:39:09 <newsham> I'm digging these specs.   marshVariant mInt8 foldFoo ( Variant 1 Foo1 (mInt8 :-> mString :-> mInt16be :-> END) :| (Variant 2 Foo2 (mInt32be :-> End) :| ENDVAR)
23:39:18 <dolio> But I suppose that's just a matter of what number you choose to begin with.
23:39:22 <newsham> for   data Foo = Foo1 Int String Int | Foo2 Int
23:39:40 <dolio> You could just change the statement to "system F0 is the simply typed lambda calculus".
23:39:49 <newsham> (with the descriminator encoded as an Int8)
23:40:03 <vixey> dolio, F0 ?
23:40:07 <vixey> not F1?
23:40:25 <dolio> Well it depends on whething things like Int are 0th order or 1st order.
23:40:40 <newsham> anyway, time for sleep
23:40:45 <vixey> I wonder if you could build up the fold automatically.....
23:40:48 <dolio> System Fn allows quantification over nth-order type functions.
23:41:05 <dolio> (Or something like that.)
23:41:16 <vixey> dolio, yeah I have no clue what is F3 or beyond
23:41:24 <newsham> vixey: you'd need TH, no?  you dont even know what all the constructor names/types are
23:41:25 <dolio> So whichever n rules out quantification over anything would be simply typed.
23:41:38 <newsham> I plan to write a TH function for auto-deriving the folder
23:41:58 <vixey> newsham, mmorrow has already wrote a TH for this, but I'm curious about doing it magically
23:43:35 <newsham> imo haskell should provide you with a folder (as it automatically provides you witha constructor)
23:44:00 <newsham> ?tell mmorrow can I have your TH code for generating folders for data declarations?
23:44:00 <lambdabot> Consider it noted.
23:44:16 <vixey> ?where moonpaste
23:44:16 <lambdabot> I know nothing about moonpaste.
23:44:27 <newsham> anyway, i'm sleeping.. gnite
23:44:34 <vixey> bye
23:45:29 <Gracenotes> > fix (\f x -> let x' = cos x in if abs (x - x') < 0.00001 then x' else f x') 100
23:45:31 <lambdabot>   0.7390821827210269
23:45:42 <Gracenotes> sweet.
23:46:40 <Asztal> @users
23:46:40 <lambdabot> Maximum users seen in #haskell: 674, currently: 586 (86.9%), active: 10 (1.7%)
23:46:51 <Asztal> 674...
23:47:11 <Asztal> I'm sure it was less than 650 just yesterday
23:47:16 <Gracenotes> @pl \x y -> (x+y)/2
23:47:17 <lambdabot> flip flip 2 . ((/) .) . (+)
23:47:26 <jeffz`> there was 650 people here 10 hours ago, it's died down a little
23:47:28 <Gracenotes> ...
23:47:34 <dolio> vixey: It just changes the sorts of kinds you're allowed to use.
23:47:36 <Gracenotes> @pl \x y -> div (x+y) 2
23:47:36 <lambdabot> flip flip 2 . (div .) . (+)
23:48:06 <dolio> vixey: F3 allows ((* -> *) -> *) -> *, but F2 doesn't (I think I counted that right).
23:48:26 <vixey> oh it's that simple!
23:48:42 <dolio> And Fw allows all orders.
23:48:52 <vixey> I thought it was like.. you could have type abstraction in F2, kind abstraction in F3, sort abstraction in F4...
23:49:49 <Saizan> you need F3 even for * -> *, afaiu
23:50:09 <Saizan> F2 only allows *
23:50:25 <vixey> but lets say  * :: []
23:50:33 <Gracenotes> @src fix
23:50:34 <lambdabot> fix f = let x = f x in x
23:50:35 <vixey> does F5 mean you can write [] -> []?
23:51:01 <dolio> System F doesn't concern itself with what kinds are classified by.
23:51:37 <Saizan> you can't write functions from kinds to kinds, no
23:51:48 <dolio> That's more of a lambda cube thing, but even there you're not allowed to talk about [] much.
23:53:08 <Gracenotes> > fix (\f a b -> a:f b (a+b)) 0 1
23:53:10 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:53:17 <Gracenotes> :D
23:53:52 <Saizan> [] is used in PTS to describe the axioms, right?
23:54:01 <vixey> I just made up []
23:54:04 <dolio> Saizan: I think in F2 you could have some concrete Foo :: * -> *. But you couldn't quantify over * -> *...
23:54:06 <vixey> it isn't important
23:54:30 <Saizan> yeah, "the type of kinds"
23:54:43 <vixey> don't you call it the sort of kinds?
23:55:21 <Gracenotes> @index fix
23:55:21 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
23:55:27 <dolio> So I guess Bar :: (* -> *) -> * would be enough to get you out of F2 and into F3.
23:55:34 <dolio> And ((* -> *) -> *) -> * would be F4.
23:56:26 <Saizan> but Bar :: (* -> *) -> * is considered quantification over * -> *? type-lambdas and forall are distinct
23:57:07 <dolio> Hmm, yeah...
23:57:40 <Saizan> so if you've forall m :: * -> *. ... you are in F3
23:58:14 <vixey> ((/\T:*, \x:T, x) Bool True) ~> True
23:58:24 <vixey> this is odd because Bool is used like a value
23:59:07 <dolio> Type and value application are usually written the same, I think.
23:59:14 <dolio> You could make a distinction if you want.
23:59:19 <vixey> but they are really different things?
23:59:24 <vixey> so in an AST you would have
23:59:30 <dolio> GHC core uses @Type, or something of the sort.
23:59:34 <vixey> App (TApp _ Bool) True
23:59:38 <vixey> ?
23:59:43 <Saizan> you can treat them the same
23:59:57 <vixey> so types are values in System F?
