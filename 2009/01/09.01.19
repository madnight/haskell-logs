00:01:11 <pumpkin> hmm, getting a symbol not found error at runtime in my compiled program
00:01:57 <ziman> a dynamic linking problem?
00:02:01 <pumpkin> yup
00:02:22 <pumpkin> passing ghc -l<lib I need> doesn't seem to do anything for it
00:02:30 <pumpkin> I'd have thought the error would come up at link time
00:03:16 <dmwit> mauke: Did you write this? http://mauke.ath.cx/stuff/poly.html
00:03:24 <dmwit> pretty freaking awesome
00:04:22 <mmorrow> heh, yeah that's pretty cool
00:04:25 <Spark> heh
00:04:44 <Spark> well done for putting a - in the right place too
00:05:15 <dmwit> From a comment on proggit: HTML, bash, zsh, C89, C99, C++, Makefile, Ruby, Tcl, Perl, Haskell, Python, Javascript, Brainfuck, and Whitespace are all represented
00:05:19 <mmorrow> <h1>I'm a <marquee><blink>horrible HTML</blink></marquee> page</h1>
00:05:22 <mmorrow> lol
00:05:34 <pumpkin> someone submitted it to proggit?
00:05:45 <dmwit> http://www.reddit.com/r/programming/comments/7qqox/be_sure_to_hit_view_source_on_this_one/
00:09:15 <earthy> it's scary.
00:09:25 <dmwit> Definitely.
00:09:32 <pumpkin> it's missing java though
00:09:49 <pumpkin> and unlambda
00:09:56 <earthy> it would be scarier still if it were a quine
00:10:01 <pumpkin> lol
00:10:04 <pumpkin> in each of the languages?
00:10:53 <pumpkin> http://en.wikipedia.org/wiki/Polyglot_(computing) has a polyglot quine, but not a very interesting polyglot
00:11:00 <earthy> that'd be a bit much :)
00:11:34 <pumpkin> http://mbishop.esoteriq.org/poly.txt still quite impressive
00:11:44 <pumpkin> ocaml, haskell, and scheme
00:11:48 <pumpkin> and a quine
00:11:59 <pumpkin> now all it needs to be is a palindrome
00:12:01 <pumpkin> ;)
00:12:51 <dmwit> That's harder when the end comment string isn't the same as the reverse of the start comment string.
00:13:11 <dmwit> Maybe one of the only things C got right -- making palindrome polyglot problems easier.
00:13:41 <pumpkin> my linking problem is only with compiled code
00:13:45 <pumpkin> I can do stuff just fine from ghci
00:14:14 <dmwit> --make
00:14:23 <pumpkin> nope
00:14:38 <pumpkin> it's a runtime dynamic loader issue for some reason
00:14:40 <pumpkin> it links just fine
00:14:59 <pumpkin> but when I run it, it complains about a missing symbol from a library I know I have on my path
00:15:19 <pumpkin> I've tried ghc with -lmx (the lib that contains the symbol) but it seems to do nothing
00:15:42 <pumpkin> and otool -L lists the library correctly in the import list :/
00:16:42 <thoughtpolice> @tell tibbe please look at http://thoughtpolice.stringsandints.com/git/?p=hyena;a=summary and check out the patch for hyena on 6.10; i want to build a web-application framework with it and takusen
00:16:42 <lambdabot> Consider it noted.
00:18:03 <pumpkin> thoughtpolice: I'll be very happy of you do that :)
00:18:12 <pumpkin> *if
00:19:33 <thoughtpolice> pumpkin: looking into it
00:19:36 <thoughtpolice> :)
00:23:04 <bogomips> hi
00:23:20 <pumpkin> hi
00:23:20 <bogomips> I don't understand the error I get while trying to install readline form hackage (with cabal)
00:23:24 <bogomips> configure: error: readline not found, so this package cannot be built
00:23:39 <bogomips> is that the system readline that it's looking for?
00:23:51 <bogomips> I installed it with macports, should I maybe set the path?
00:25:06 * Workybob really wants to be able to use prefix type constructors infix
00:25:21 <Workybob> Error `Or` SomethingUseful -- so much nicer than Either Error SomethingUseful
00:25:42 <Workybob> I guess I could define :|: rather than or though
00:25:55 <pumpkin> you can't do `Or`?
00:26:33 <pumpkin> oh that's a type issue, not a constructor issue?
00:26:34 <Workybob> > let f :: String `Either` String; f = Left ""
00:26:35 <lambdabot>   <no location info>: parse error on input `;'
00:26:36 <dmwit> bogomips: Definitely have a google around online.  I seem to recall other people discovering that the Mac and GNU worlds mean different things when they talk about readline.
00:26:42 <Workybob> pumpkin: yeh
00:26:46 <pumpkin> ah
00:26:50 <Workybob> type constructor, not data constructor
00:27:08 <dmwit> LANGUAGE InfixTypeConstructors -- I think
00:27:13 <Workybob> oh, neat!
00:27:15 <Workybob> thanks dmwit
00:27:29 <pumpkin> any ideas about my linking issue?
00:27:37 <dmwit> no =/
00:27:42 <cjs> `Or` works fine for me.
00:27:52 <cjs> Without the language thing, natch.
00:28:08 <fasta> Is there a list with language features that will be removed from GHC in the near future?
00:28:14 <pumpkin> dhcp-210-194:labeling pumpkin$ ./matlab
00:28:14 <pumpkin> dyld: Symbol not found: _miFtell64
00:29:03 <pumpkin> :(
00:30:18 <dmwit> cjs: You're right.
00:30:18 <bogomips> dmwit: I'm googling but the thing is that I have the gnu readline installed
00:30:33 <Workybob> cjs: o.O
00:30:34 <bogomips> in fact readline doensn't work either on ghci
00:30:34 <bogomips> which is a little annoying
00:30:37 <dmwit> Workybob: The correct LANGUAGE pragma is TypeOperators, not InfixBlah.
00:30:55 <Workybob> yeh, I just got to that :)
00:30:57 <dmwit> bogomips: Which version of ghc.
00:31:03 <pumpkin> bogomips: try --extra-lib-dir and --extra-include-dir and point them at /opt/local/lib and include respectively?
00:31:10 <dmwit> s/\./?/
00:31:43 <bogomips> dmwit: 6.10
00:31:44 <joma> "Most GCs force a collection before growing the amount of memory available. "
00:31:49 <joma> http://useless-factor.blogspot.com/2009/01/quote-of-day.html
00:31:51 <bogomips> I'll try the includes
00:31:56 <dmwit> bogomips: Huh, I thought 6.10 moved away from readline.
00:32:10 <Ralith> yeah, didn't 6.10 move to editline?
00:32:17 <Ralith> I had to patch mine to use readline 'cuz editline is weird on freebsd
00:33:12 <dmwit> editline is weird everywhere
00:33:29 <bogomips> well I don't know if it moved, I just know that it doesn't work fully as a readline enabled program
00:33:29 <bogomips> some keys work some don't
00:33:51 <pumpkin> editline half sucks on mine
00:34:35 <joma> how can I prevent Haskell from eating up all my memory?
00:34:40 <dmwit> Crap, I stayed up late again.
00:34:43 <Ralith> dmwit: yeah, but I can't even get it to build with editline enabled here 'cuz there's a base system editline that catches the linker's attention first.
00:34:48 <Ralith> joma: tell it not to.
00:35:02 <dmwit> Ralith, command-line options override the built-in library path
00:35:25 <dmwit> s/override/should override/ of course =P
00:36:08 <pumpkin> joma: with a whip
00:36:08 <bogomips> no it doesn't work either
00:36:13 <dmwit> joma, That question is too big to answer.
00:36:13 <pumpkin> don't let it be too lazy
00:36:16 <dmwit> Narrow it down for us.
00:36:19 <pumpkin> but don't let it be too eager either
00:36:20 <andun> joma: ulimit?
00:36:38 <Ralith> dmwit: know what I can pass to LD to make it ignore /lib/libedit.so.6 in favor of /usr/local/lib/libedit.so.6?
00:36:57 <dmwit> Ralith, oy
00:37:05 <Ralith> ld, that is.
00:38:12 <dmwit> Ralith, That's harder.  Maybe make a symlink to it somewhere that's not in the usual library path...?
00:38:16 * dmwit is a crappy sysadmin
00:38:33 <dmwit> That's why I only administer systems that nobody else uses. =P
00:38:38 <Ralith> dmwit: huh?
00:39:08 <dmwit> Ralith, Well, I guess the problem you're facing is that /usr/local/lib is *already* on your library path, so ld ignores that option.
00:39:38 <Ralith> dmwit: indeed.
00:39:51 <dmwit> Ralith, One solution would be to make some other directory and ln -s /.../libedit.so.6 ~/foo/libedit.so.6, then pass -L~/foo to ld.
00:39:59 <dmwit> (Obviously, you can't use ~/foo.)
00:40:09 <dmwit> But that's pretty gross.
00:40:09 <pumpkin> aha, fixed it
00:40:14 <Ralith> dmwit: it would still prioritize /lib beforehand, I'm pretty sure
00:40:18 <dmwit> pumpkin, What was it?
00:40:18 <pumpkin> it was my own damn fault, somewhat unsurprisingly
00:40:39 <dmwit> Ralith, No, it definitely prioritizes non-path arguments before the hard-coded path.
00:40:39 <pumpkin> well, both matlab and mac os have a libmx
00:40:44 <Ralith> hm, ok
00:40:56 <pumpkin> and I saw the libmx in my /usr/lib and assumed it was matlab's, when it was mac os x's
00:41:04 <dmwit> Ralith, However, it definitely also does clever things with arguments that are already on the path.
00:41:15 <Ralith> dmwit: ideally I'd want something like -l that takes a full path rather than a name.
00:41:38 * dmwit nods
00:42:02 * dmwit prefers the Gobo way of doing this
00:42:22 <dmwit> I prefer basically everything about Gobo to every other distribution... except its hardware support.
00:42:56 <joma> andun: is that soemthing i cans et?
00:43:18 <dmwit> I mean, come on, a modern distro with no 64-bit support?
00:43:20 <joma> i mean is there a limi I can set to GHC that says "use maximum this amount of memory"?
00:43:32 <joma> how can I prevent Haskell from eating up all my memory?
00:43:35 <dmwit> joma, Yes, check out the manual entry on RTS options.
00:44:03 <dmwit> I know there's one in there for stack space, and I think there's one for heap space, too.
00:44:26 <dmwit> But if there isn't, then I don't see what's wrong with ulimit.
00:44:28 <andun> joma: ulimit sets the limit any of your processes can use. you could probably also use the RTS options if you only want it for one haskell program
00:45:44 <andun> see 'ulimit -a'. -v is memory
00:47:08 <dmwit> -Msize: Set the maximum heap size to size bytes
00:47:25 <joma> what does the heap do? i thought haskell used a stack+
00:47:38 <pumpkin> both
00:47:42 <dmwit> Haskell uses both a heap and a stack, much like almost every language ever.
00:47:52 <joma> what is each used for?
00:48:30 <dmwit> The stack is for diving into thunks; the heap is for the values computed by thunks.
00:48:55 <dmwit> Hehe: -B: sound the bell at the start of each (major) garbage collection
00:48:56 <dmwit> lovely
00:49:09 <pumpkin> wow
00:50:16 <dmwit> Man, why isn't a less verbose variation of -xc enabled by default?
00:50:36 <dmwit> "[-xc] will tell you exactly the call stack at the point the error was raised"
00:53:11 <pumpkin> if only it could do that in my segfault
00:56:42 <joma> a functor is a function that takes a structure and spits out another structure?
00:57:07 <joma> could thus a functor be a function that takes a list [1,2,3] and viesn arrray (0,2)[1,2,3] ?
00:57:18 <joma> or am i completely misunderstanding it ?
00:57:52 <pumpkin> it could take list [1,2,3] and give list ["one", "two", "three"]
00:57:58 <pumpkin> :t fmap
00:57:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:58:12 <pumpkin> the functor is the thing itself though
00:58:23 <pumpkin> in this case list
00:58:44 <joma> so it transforms the items of a strcuture while preserving order and other attributes but doesnt change thew datastructure(ever?)?
00:58:52 <joma> the list?
00:59:03 <joma> hmm'
00:59:09 <pumpkin> it doesn't need to preserve order
00:59:33 <joma> but could you give an example of the handiness of a functor?
00:59:52 <pumpkin> > fmap (+1) [1,2,3]
00:59:53 <joma> like what can it simplify or do what i cant do otherwise?
00:59:54 <lambdabot>   [2,3,4]
00:59:57 <pumpkin> > fmap (+1) (Just 4)
00:59:59 <lambdabot>   Just 5
01:00:02 <dmwit> joma, If we restrict ourselves to Haskell, a functor is a pair of functions; one operates on types (for example, [] is a function from a to [a]), and one operates on values of the constructed type.
01:00:06 <joma> > map (+1) [1..3]
01:00:08 <lambdabot>   [2,3,4]
01:00:58 <dmwit> joma, There's nothing you can do with Functor that you couldn't do without.  However, it's a convenient abstraction.
01:01:27 <joma> instance Functor RV where
01:01:27 <joma>     fmap = liftM
01:01:31 <joma> what doesthat do then?
01:01:34 <dmwit> We have a lot of code that works on any instance of a functor, and hence is immediately useful if you discover that a structure you're using is actually a functor.
01:01:59 <dmwit> joma, That defines the fmap function for the RV functor.
01:02:15 <pumpkin> joma: liftM should equal fmap for monads
01:02:25 <pumpkin> (any monad is also a functor)
01:02:49 <pumpkin> double dmwit!
01:02:59 <papermachine> How do I increase the size of the stack in GHCi 6.10?
01:03:18 <pumpkin> papermachine: +RTS -Ksize
01:03:19 <dmwit> papermachine, Look in the docs for the RTS options.
01:03:22 <dmwit> ah, damn
01:03:25 <papermachine> thanks.
01:03:29 <pumpkin>   -K<size> Sets the maximum stack size (default 8M)  Egs: -K32k   -K512k
01:03:30 <dmwit> Now he'll never know how to help himself.
01:03:35 <pumpkin> aw, I'm sorry :)
01:03:38 <dmwit> =P
01:03:41 <pumpkin> papermachine: +RTS --help !
01:03:46 <papermachine> right, right
01:06:19 <papermachine> Eh, that didn't help anyway. I guess I'll actually have to look for my stack overflow :<
01:08:20 <dmwit> Doesn't the stack overflow error message even say how to increase the stack?
01:14:53 <dmwit> > Any True
01:14:55 <lambdabot>   Any {getAny = True}
01:15:02 <dmwit> ?instances Monoid
01:15:03 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:15:09 <dmwit> huh
01:15:13 <pumpkin> ?
01:15:20 <pumpkin> (a -> b) ?
01:15:22 <dmwit> Aren't Max/Min monoids for Bounded types?
01:15:32 <dmwit> pumpkin, There's class restrictions that aren't printed.
01:15:36 <pumpkin> ah
01:15:38 <dmwit> pumpkin, Monoid b => a -> b
01:16:09 <pumpkin> @src Any
01:16:10 <lambdabot> Source not found. I am sorry.
01:16:18 <dmwit> mempty = const mempty; mappend f g x = mappend (f x) (g x) -- I think
01:16:44 <dmwit> > [Any a `mappend` Any b | [a,b] <- replicateM 2 [True, False]]
01:16:46 <lambdabot>   [Any {getAny = True},Any {getAny = True},Any {getAny = True},Any {getAny = ...
01:16:57 <dmwit> where ... = False}]
01:17:13 <dmwit> All = Dual Any
01:17:18 <dmwit> err
01:17:19 <dmwit> no
01:17:40 <dmwit> anyway, Any is or and All is and
01:17:42 <pumpkin> maybe for some definitions of Dual, but I guess not this one :)
01:18:35 <dmwit> Anyway, I thought there was a Max and Min monoid, which would subsume Any and All.
01:19:18 <dmwit> s/was a/were/;s/monoid,/monoids,/
01:19:19 <mmorrow> Heyting algebras vs. Boolean algebras
01:19:38 <mmorrow> Boolean is a specific case
01:20:48 <mmorrow> just like the set of all subsets of a set is a specific case of a topology on the set
01:21:34 <dmwit> now you're just showing off ;-)
01:22:08 <mmorrow> heh, i was actually just reading something related to this about 10 minutes ago
01:22:18 * mmorrow swears
01:22:33 <pumpkin> what about the set of all subsets of the set of all subsets of a set?
01:22:37 <ziman> > Any 2 `mappend` ANy 3
01:22:40 <lambdabot>   Not in scope: data constructor `ANy'
01:22:42 <ziman> > Any 2 `mappend` Any 3
01:22:43 <lambdabot>       No instance for (Num Bool)
01:22:44 <lambdabot>        arising from the literal `2' at <inte...
01:23:05 <ziman> oh, i see, the monoid.
01:23:25 <pumpkin> , subsequences . subsequences $ [1..3]
01:23:26 <lunabot>  [[],[[]],[[1]],[[],[1]],[[2]],[[],[2]],[[1],[2]],[[],[1],[2]],[[1,2]],[[]...
01:23:26 <mmorrow> pumpkin: a topology is a subset of the power set
01:23:33 <pumpkin> , length . subsequences . subsequences $ [1..3]
01:23:34 <lunabot>  256
01:23:48 <pumpkin> damn right
01:23:53 <mmorrow> DAMN RIGHT
01:24:07 <pumpkin> , length . subsequences . subsequences . subsequences $ [1..3]
01:24:13 <lunabot>  Killed.
01:24:16 <mmorrow> awwww
01:24:16 <pumpkin> 2^256, you think it'll work?
01:24:17 <pumpkin> guess not
01:24:33 <pumpkin> , length . subsequences . subsequences . subsequences $ [1..2]
01:24:34 <lunabot>  65536
01:24:41 <pumpkin> not too shabby
01:24:42 <mmorrow> , const (2^256) (length . subsequences . subsequences . subsequences $ [1..3])
01:24:43 <lunabot>  1157920892373161954235709850086879078532699846656405640394575840079131296...
01:24:50 <pumpkin> lol
01:24:55 <pumpkin> very impressive
01:24:59 <mmorrow> i try
01:25:02 <skorpan> @pl \z -> map (\(x, y) -> (mkRegex x, y)) z
01:25:03 <lambdabot> map (first mkRegex)
01:25:06 <skorpan> awesome
01:25:09 <joma> can I define in a Monad how to append to matrices to each other?
01:25:18 <joma> or should that just be a normal function?
01:25:25 <skorpan> uh, Not in scope: `first'
01:25:27 <pumpkin> mmorrow: I think you should generalize that technique
01:25:27 <dmwit> Sounds like a normal function to me.
01:25:31 <dmwit> skorpan, Control.Arrow
01:25:32 <skorpan> :t first
01:25:33 <pumpkin> mmorrow: call it the oracle
01:25:34 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
01:25:44 <mmorrow> , const (1/0) (length [0..])
01:25:45 <lunabot>  Infinity
01:25:47 <skorpan> dmwit: thanks :P
01:25:48 <mmorrow> woot!
01:26:03 <mmorrow> pumpkin: hah
01:26:09 <dmwit> , const (1/10) (length [10..]) -- makes sense, right?
01:26:10 <lunabot>  luna: parse error (possibly incorrect indentation)
01:26:23 <dmwit> uh
01:26:26 <dmwit> , const (1/10) (length [10..])
01:26:27 <lunabot>  0.1
01:26:32 <pumpkin> dmwit: doesn't like comments
01:26:34 <dmwit> No comments?!
01:26:40 <ziman> you need {- comments -} because lunabot encloses everything in parens
01:26:42 <mmorrow> i'm lazy
01:26:48 <ziman> afaik
01:26:52 <mmorrow> what it's doing is
01:26:57 <mmorrow> err, actually i'll paste it
01:26:58 <dmwit> , v
01:27:00 <lunabot>  v
01:27:11 <ziman> , 3 {- test comment -}
01:27:13 <lunabot>  3
01:28:45 <pumpkin> dmwit: however, good inference
01:29:04 <dmwit> heh
01:29:42 <pumpkin> reminds me of that dumb joke (I kinda need a board) where someone wrote a limit involving 8 that was infinity, and then inferred that the same expression in the limit involving 5 was a 5 rotated by 90 degrees
01:29:46 <dmwit> Vagif writes that sigfpe's blog post would "enjoy much higher visibility" if he added it to the Haskell wikibook.  Somehow I doubt that.
01:30:33 <mmorrow> dmwit: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=808
01:30:43 <mmorrow> ("show (" ++ s ++ ")"))
01:30:50 <dmwit> , s
01:30:52 <lunabot>  s
01:31:07 <dmwit> oh
01:31:10 <dmwit> Yeah, okay.
01:31:16 <mmorrow> (it doesn't matter if you bypass the parens there, because that string has to evaluate to type String anyhow
01:31:18 <mmorrow> )
01:31:28 <mmorrow> it's just for convenience
01:31:50 <dmwit> , 3) {- just a parse error in the call to eval, I guess -}
01:31:51 <lunabot>  luna: parse error on input `)'
01:31:59 <pumpkin> what's the commented-out bit?
01:32:01 <joma> can some give me example of functors?
01:32:18 <Axman6> []
01:32:21 <pumpkin> @instances Functor
01:32:21 <Axman6> Maybe
01:32:21 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:32:32 <mmorrow> it uses dynCompileExpr, then does fromDynamic ... :: Maybe String, so if the expression isn't of type String, it gives back Nothing
01:32:44 <nothingmuch> i'm getting type errors from defaultGETRequest, URI <> network-2.1.0.0:Network.URI.URI... i have both 2.1.0.0 and 2.2.0.0, so this sounds to me like 2.1.0.0 is being imported by Network.Browser perhaps? if that's true, what's the fix?
01:32:52 <mmorrow> , 42) `seq` (
01:33:06 <mmorrow> , 42
01:33:07 <lunabot>  42
01:33:09 <joma> [] :: [a]
01:33:14 <joma> defined recursively?
01:33:20 <Axman6> nothingmuch: import <module> hiding (functions,dataytes)
01:33:26 <pumpkin> joma: no
01:33:33 <pumpkin> joma: one is the constructor, the other is the type
01:33:37 <pumpkin> they just happen to look the same :P
01:33:41 <mmorrow> joma: "[]" is both a type con /and/ a data con
01:33:46 <mmorrow> @src []
01:33:46 <lambdabot> data [] a = [] | a : [a]
01:34:00 <mmorrow> @type [] Int
01:34:01 <lambdabot> Not in scope: data constructor `Int'
01:34:04 <mmorrow> @kind [] Int
01:34:06 <lambdabot> *
01:34:12 <mmorrow> @type [] 42
01:34:13 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[a]'
01:34:16 <mmorrow> @type [42]
01:34:17 <lambdabot> forall t. (Num t) => [t]
01:34:18 <mmorrow> oops
01:34:18 <dmwit> joma, It's pretty common to take advantage of the fact that type constructors and data constructors live in different namespaces.
01:34:24 <nothingmuch> Axman6: don't i need that export though? i'm using parseURI in my code, from Network.URI but it seems like defaultGETRequest is expecting URI from the previous version
01:35:07 <joma> if i want to write a function that takes a list and returns an array. ie amap :: [a] -> (a -> a) -> Array . could/should that be a functor then or just a nomral function?
01:35:57 <pumpkin> the functor is really the instance of Functor, not the fmap method in there
01:36:01 <mmorrow> it'd be a function, "Functor" in haskell is just the type class
01:36:15 <dmwit> You've already written your type as a function type.
01:36:37 <Saizan_> nothingmuch: you can use -package network-2.1.0.0 so your current code uses that version too
01:36:48 <mmorrow> , listArray (0,9) [0..9] :: Array Int Int
01:36:50 <lunabot>  array (0,9) [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)]
01:36:52 <Saizan_> nothingmuch: or you can recompile HTTP against the new network package
01:37:05 <nothingmuch> that sounds like the better alternative
01:37:23 <nothingmuch> oh crap, no cabal install on this ghc yet
01:38:00 <dmwit> :t \low high f -> array (low, high) (map (id &&& f) [low..high])
01:38:01 <lambdabot> forall a e. (Ix a, Enum a) => a -> a -> (a -> e) -> Array a e
01:38:26 <nothingmuch> bah, there is one... what am i smoking
01:38:47 <dmwit> :t \xs f -> array (minimum xs, maximum xs) (map (id &&& f) xs)
01:38:48 <lambdabot> forall a e. (Ix a) => [a] -> (a -> e) -> Array a e
01:38:51 <hugo___> hi
01:38:53 <dmwit> I win!
01:38:56 <dmwit> Hiya, hugo___!
01:39:01 <joma> amap f xs = DA.listArray (0,length xs) (map f xs)
01:39:01 <dmwit> soooo many underscores
01:39:05 <hugo___> hey dmwit :*
01:39:57 <dmwit> joma, It seems weird to include the (map f) bit in there.
01:42:57 <agemo> :t (&&&)
01:42:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:43:28 <dmwit> It reads better if you write it as:
01:43:52 <dmwit> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
01:44:26 <dmwit> Note that (->) is an instance of Arrow, so the choice of (~>) -- similar to (->) -- is no accident.
01:45:02 <Raynes> @src words
01:45:02 <lambdabot> words s = case dropWhile isSpace s of
01:45:02 <lambdabot>     "" -> []
01:45:02 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
01:45:18 <agemo> i see :) i'd never seen (&&&) before and ghci didn't know it either, so i had to know :)
01:45:27 <dmwit> It's in Control.Arrow.
01:45:47 <agemo> thought as much
01:46:53 <Philonous> Are there arrows that are not functions?
01:46:54 <pumpkin> what other instances of Arrow are there other than -> and Kleisli?
01:47:07 <pumpkin> the only ones I've tried to write weren't possible :/
01:47:24 <dmwit> There's a few strange ones.
01:47:30 <dmwit> There's a parser one.
01:47:31 <pumpkin> oh that quantom arrow one?
01:48:12 <dmwit> homofunctors (something like that), time-indexed arrows
01:48:21 <dmwit> And yeah, the quantum arrow. =)
01:48:51 <dmwit> The paper I read had several representations of automata that were each Arrow instances.
01:49:08 <yitz> > let words' = map (takeWhile (not . isSpace)) . takeWhile (not . null) . iterate (dropWhile (not . isSpace) . dropWhile isSpace in words' "  Here are some words. "
01:49:10 <lambdabot>   <no location info>: parse error on input `in'
01:49:11 <pumpkin> it seems like many of the typical examples of categories can't be implemented using Arrow though
01:49:13 <quicksilver> dmwit: but is it obvious that they weren't kleisli.
01:49:17 <quicksilver> ?
01:49:20 <dmwit> No.
01:49:27 <quicksilver> the only interesting non-kleisli one is the parser
01:49:30 <dmwit> Some of them definitely couldn't be.
01:49:31 <yitz> > let words' = map (takeWhile (not . isSpace)) . takeWhile (not . null) . iterate (dropWhile (not . isSpace)) . dropWhile isSpace in words' "  Here are some words. "
01:49:33 <lambdabot>   ["Here","","","","","","","","","","","","","","","","","","","","","","","...
01:49:38 <yitz> oops
01:49:39 <dmwit> But obvious...?  Not to me.
01:49:41 <quicksilver> and that is formed by taking the kleisli arrow of a category and then adding some stuff.
01:49:50 <quicksilver> (that I have seen, I mean)
01:49:58 <yitz> quicksilver: there are those FRP things.
01:50:12 <dmwit> FRP's a good example
01:50:17 <pumpkin> the definition of Arrow basically requires your arrow to be some kind of a (haskell) function
01:50:18 <pumpkin> :/
01:50:22 <dmwit> HaXML is Arrow-based, too, right?
01:50:28 <yitz> dmwit: ah, right
01:50:41 <skorpan> i have a list of strings which i want to putStrLn, how would i do that
01:50:42 <hugo___> is there any good comparison between haskell and python ?
01:50:42 <skorpan> ?
01:50:48 <dmwit> skorpan, mapM_
01:50:53 <hugo___> i know they are quite different
01:50:57 <jeffz`> hugo___: python bad, haskell good?
01:50:58 <skorpan> mapM_ putStrLn xs?
01:51:00 <hugo___> :D
01:51:06 <pumpkin> hugo___: I doubt there's any meaningful comparison
01:51:07 <dmwit> skorpan, looks good
01:51:15 <skorpan> thanks
01:51:25 <skorpan> i should go for my intuition before asking questions :P
01:51:27 <hugo___> jeffz`: well, it is just to show a python zealot friend how good haskell is without wasting too much time
01:51:28 <yitz> > words "  abc  def  "
01:51:30 <lambdabot>   ["abc","def"]
01:51:39 <yitz> oh, ok
01:51:55 <pumpkin> hugo___: show him a haskell fibonacci definition
01:51:57 <jeffz`> hugo___: oh, probably better to write meaningful software
01:52:03 <dmwit> hugo___, Python is slow.  Haskell is fast.  Python is dynamically typed and therefore error-prone.  Haskell is statically-typed and therefore impossible to use.
01:52:15 <hugo___> heheh
01:52:18 <yitz> > let words' = map (takeWhile (not . isSpace) . dropWhile isSpace) . takeWhile (not . null) . iterate (dropWhile (not . isSpace)) in words' "  Here are some words. "
01:52:19 <pozic> dmwit: :)
01:52:20 <lambdabot>   ["Here","Here","Here","Here","Here","Here","Here","Here","Here","Here","Her...
01:52:24 <yitz> urgh
01:52:37 <dmwit> That doesn't look quite right. =P
01:52:44 <hugo___> i did show him a fib definition, to wich he replied "yeah, haskell is only good for mathematical definitions"
01:52:44 <yitz> > let words' = map (takeWhile (not . isSpace) . dropWhile isSpace) . takeWhile (not . null) . iterate (dropWhile (not . isSpace) . dropWhile isSpace) in words' "  Here are some words. "
01:52:46 <lambdabot>   ["Here","are","some","words.",""]
01:53:10 <pozic> I don't see where people got the idea that Haskell has anything to do with mathematics.
01:53:13 <yitz> > words "  Here are some words. "
01:53:15 <lambdabot>   ["Here","are","some","words."]
01:53:32 <yitz> close
01:53:52 <pozic> Sure, we have the word Monad and "function". But e.g. Monoid is also used in C++ libraries.
01:53:56 <hugo___> also he got caught into that post by the ocaml guy, and started saying bad things about haskell module system, and suposed "namespaces", and how much python way is better... so well i didn't want to waste too much of my time with it if there was a good comparison on the web
01:54:12 <dmwit> hugo___, Show him the "composing contracts" paper.
01:54:17 <dmwit> That will convince anybody.
01:54:21 <hugo___> i guess ill team up with him and try to work one out...
01:54:26 <hugo___> okey
01:54:33 <pozic> hugo___: I don't think Haskell dominates Python, but it might be better in some areas.
01:54:54 <dmwit> https://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
01:55:09 <hugo___> thanks dmwit
01:55:15 <quicksilver> dmwit: haxml arrows are all kleisli though.
01:55:26 <quicksilver> dmwit: they're kleisli from the [] and IO monads, IIRC.
01:55:26 <yitz> pozic: so C++ also has to do with mathematics. It's just that Haskell exploits that relationship more naturally.
01:55:29 <skorpan> @pl \x rs -> foldr (\(r, rep) y -> subRegex r y rep) x rs
01:55:29 <lambdabot> foldr (uncurry (flip . subRegex))
01:55:54 <mmorrow> a nice little red-black tree module (despite the name) http://darcs.haskell.org/yhc/src/compiler98/Util/Tree234.hs
01:55:59 <dmwit> :t unfoldr
01:56:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:56:32 <yitz> dmwit: yeah, but I was trying to avoid that
01:56:33 <hugo___> i really dislike these "the programming language i use is better that the one you use" kind of wars, i feel fine with haskell, and couldn't care less about the rest :/
01:56:45 <Badger> hugo___: this is unacceptable!
01:56:46 <pumpkin> mmorrow: that's an awesome name for an RB tree module
01:56:56 <Badger> hugo___: fight for your language!
01:57:15 <hugo___> heheh
01:57:21 <dmwit> > unfoldr (\xs -> (guard . not . null) xs >> (return . break isSpace . dropWhile isSpace)) "blah blah blah"
01:57:22 <lambdabot>   Couldn't match expected type `Maybe (a, [a1])'
01:57:31 <dmwit> oh
01:57:45 <dmwit> > unfoldr (\xs -> (guard . not . null) xs >> (return . break isSpace . dropWhile isSpace) xs) "blah blah blah"
01:57:46 <Philonous> @src guard
01:57:46 <lambdabot> guard True  =  return ()
01:57:46 <lambdabot> guard False =  mzero
01:57:46 <lambdabot>   ["blah","blah","blah"]
01:57:50 <hugo___> nahh, its a war already won by haskell, it is only a matter of time, so i won't fight meaningless wars
01:57:57 <mmorrow> pumpkin: totally. i'm going to start calling all my DB related code modules ImageRotateXX
01:57:58 <dmwit> > unfoldr (\xs -> (guard . not . null) xs >> (return . break isSpace . dropWhile isSpace) xs) "blah blah blah   " -- hmm
01:57:59 <lambdabot>   ["blah","blah","blah",""]
01:58:01 <hugo___> all the other languages seem deprecated already
01:58:31 <pumpkin> mmorrow: more than that, you should just name your stuff by EXACTLY how it's implemented, to make things more interested later when you decide to change it
01:58:35 <yitz> dmwit: yeah, the fact that break returns a tuple makes this a good place to use unfoldr actually.
01:58:54 <yitz> dmwit: or a State monad :)
01:58:54 <pumpkin> I mean, Data.23FingerTree is much better than Data.Sequence
01:59:14 * Badger points 23 fingers at pumpkin 
01:59:15 <pumpkin> maybe Data.23FingerTreeBasedSequence
01:59:27 <pumpkin> !
02:00:04 <yitz> pumpkin: Data.23FingerTreeZipperBasedSequence
02:00:12 <pumpkin> much beter, thanks
02:00:22 <mmorrow> Data.IAteAMuffinEarlierThisMorningAnywaysPriorityQueues12PtFont
02:01:03 <dmwit> THAT'S A LOT OF NUTS
02:01:35 <pozic> yitz: where would Scheme fit in this spectrum?
02:02:11 <yitz> pozic: somewhere in the middle in my opinion.
02:02:42 <quicksilver> scheme ingeniously combines all the disadvantages of python with all the disadvantages of haskell, and adds some of its own.
02:03:25 <yitz> quicksilver: (some (that it borrowed (from LISP)))
02:04:13 <joma> i want to use IntMap like so: matrix = IM.fromList [(0,0),0.0]
02:04:16 <joma> i cant?
02:04:17 * quicksilver considers scheme to be a lisp.
02:04:30 <joma> * joma considers scheme to be a lisp
02:04:38 <quicksilver> IntMap requires the indices be ints.
02:04:39 <yitz> joma: use Map, not IntMap
02:04:40 <quicksilver> Hence the name.
02:04:41 <joma> how do I do the * stuff in mirc?
02:04:50 <Badger> I mutht agree with you thirth.
02:04:53 <quicksilver> You could implement a translation layer on the indices though.
02:04:53 <Zao> /me
02:04:57 <Workybob> joma: what would such an IntMap contain?
02:05:09 <dcoutts> cjs: work out the problem with derive? Apparently derive compiles code at runtime and that uses the standard package db. The package db that you use to find packages when building derive is unrelated.
02:05:09 <quicksilver> using Ix, e.g.
02:05:20 <joma> its a sparse matrix, [(row,col), value]
02:05:31 <Workybob> joma: then you want Data.Map, not Data.IntMap
02:05:53 <yitz> quicksilver: I was referring to classical LISP, of which scheme and any lisp is a direct descendent.
02:05:56 <joma> matrix = DM.fromList [(0,0),0.0] no go either
02:06:11 <dcoutts> pumpkin: --configure-option is for passing options to ./configure, is that what you were looking for? What package could you not build with cabal-install that worked manually?
02:06:19 <Workybob> matrix = DM.fromList((0,0),0.0)] -- joma
02:06:34 <Workybob> fromList accepts a list of tuples – pairing key with value
02:06:42 <Workybob> oops, and I missed an open [
02:07:39 <pumpkin> dcoutts: it wasn't cabal-install's problem, it was the cabal package itself that was very heavily geared towards a linux system and its configure script and various other Makefileish stuff didn't like my platform
02:07:47 <pumpkin> dcoutts: but thanks for that :)
02:08:00 <pozic> quicksilver: what disadvantages?
02:08:12 <dcoutts> pumpkin: oh, ignore the makefile you do not need it
02:08:25 <dcoutts> pumpkin: Cabal is a Cabal package and builds in the standard way
02:08:38 <pumpkin> dcoutts: I mean this specific package I was trying to build
02:08:41 <pumpkin> had a makefile among other things
02:08:48 <pumpkin> for a separate lib it built
02:08:49 <dcoutts> oh
02:08:57 <pumpkin> it was a real pain, but I got it working
02:09:06 <pumpkin> in the end it was a simple cabal install :)
02:09:09 * dcoutts misread "it was the cabal package itself"
02:09:20 <pumpkin> yeah, sorry, that was ambiguous
02:09:22 <dcoutts> I assumed you meant *the* Cabal package :-)
02:09:43 <dcoutts> pumpkin: ooi, which package?
02:09:46 <quicksilver> dcoutts: with the benefit of hindsight, I believe it was a mistake to have the executable produced by cabal-install called 'cabal'.
02:09:46 <pumpkin> matlab :)
02:09:53 <pumpkin> it's very linux-specific
02:09:59 <quicksilver> dcoutts: it appears to cause no little confusion.
02:10:04 <dcoutts> quicksilver: indeed
02:10:33 <dcoutts> quicksilver: what do you think about this proposed re-arrangement: http://hackage.haskell.org/trac/hackage/wiki/Cabal-2
02:11:28 <pumpkin> dcoutts: might I suggest the ability to recompile a package and all its dependencies with new options? or at least to output a toposorted list of packages?
02:11:52 <pumpkin> I had a really hard time when I'd installed a bunch of stuff and realized none of it had profiling enabled
02:12:00 <pumpkin> you might remember
02:12:06 <dcoutts> pumpkin: not all its dependencies, you have to stop somewhere because of base, rts etc
02:12:21 <Axman6> pumpkin: care to explain what http://mauke.ath.cx/stuff/poly.poly is? i can see different programs in there... but... whaaa?
02:12:24 <dcoutts> pumpkin: oh, do you mean reverse dependencies?
02:12:31 <pumpkin> well the dependencies ghc will complain about needing -prof on
02:12:35 <dcoutts> pumpkin: rebuild a package and all the ones that depend on it?
02:12:42 <dcoutts> pumpkin: ah, right yes
02:12:42 <pumpkin> dcoutts: nope
02:13:03 <dcoutts> pumpkin: however we cannot yet do that sensibly because we do not know if the profiling versions are installed or not
02:13:06 <pumpkin> Axman6: it's a polyglot by mauke that contains a bunch of programs in different languages simultaneously
02:13:15 <Axman6> :o
02:13:22 <dcoutts> pumpkin: http://hackage.haskell.org/trac/hackage/ticket/282
02:13:31 <pumpkin> dcoutts: simply giving me a toposorted list somehow would be a good start
02:13:49 <dcoutts> pumpkin: cabal install foo --dry-run -v  does that, sort of
02:13:56 <pumpkin> ah okay
02:14:25 <dcoutts> hmm, actually it's not top sorted
02:14:31 <dcoutts> only for the ones that it would re-install
02:14:45 <dcoutts> but you can see the list of deps and use them as targets with --reinstall
02:14:48 <pumpkin> because if it were topologically sorted, I could just run a quick script over them and --force reinstall them with prof
02:15:04 <pumpkin> I could make a more involved script that traces down dependencies too
02:15:13 <pumpkin> I guess :)
02:15:20 <dcoutts> pumpkin: you don't need to know the order, since it'll be worked out correctly if you ask to install all of them at once
02:15:32 <pumpkin> oh I didn't know that
02:15:38 <pumpkin> damn, that would've saved me some time :P
02:15:45 <dcoutts> pumpkin: you just need to know the transative set of deps that lack prof libs
02:16:00 <quicksilver> dcoutts: looks better.
02:16:43 <dcoutts> quicksilver: good, so far people seem to think it's a reasonable suggestion to reduce confusion
02:20:03 <hugo___> im becoming quite the adept of the composition operator (.)
02:24:23 <pumpkin> hugo___: have you composed compositions yet?
02:24:52 <joma> hmm repping a sparsematrix as a Map should be really efficient right? i can just query if not in map then 0 else val.
02:25:12 <joma> and multiplication is just query for each coordinate
02:25:12 <hugo___> only like f5 = f1 . f2 . f3 . f4 and then use f5 on other ones :)
02:25:32 <pumpkin> joma: IntMap might be even better if you can map your coordinates to Ints, which is pretty easy
02:26:09 <pumpkin> joma: but yeah, that's one way of doing it
02:27:19 <Axman6> > (1,1) < (1,2)
02:27:20 <lambdabot>   True
02:27:26 <Axman6> > (1,1) < (2,0)
02:27:27 <lambdabot>   True
02:27:30 <Axman6> > (1,1) < (1,0)
02:27:32 <lambdabot>   False
02:27:34 <pumpkin> it's lexicographic
02:28:24 <joma> pumpkin: how do you mean? it will be a SparseDoubleMatrix. how would I use IntMap?
02:28:39 <pumpkin> joma: presumably your indices aren't doubles
02:28:49 <joma> what complexity has insert and lookup on Data.Map ?
02:28:56 <pumpkin> logarithmic
02:29:20 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
02:29:26 <joma> pumpkin: yes but people jsut told me i cant have [(1,4),0.56]
02:29:27 <pumpkin> most operations have a complexity annotation
02:29:55 <pumpkin> joma: you can't, but a Map has a key type and a value type
02:30:20 <dmwit> ?ping
02:30:21 <lambdabot> pong
02:30:47 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-IntMap.html
02:32:22 <pumpkin> joma: you could represent it with a simple association list too :)
02:33:18 <pumpkin> > [((0,0), 1),((0,1), 0),((1,0),0),((1,1),1)]
02:33:19 <lambdabot>   [((0,0),1),((0,1),0),((1,0),0),((1,1),1)]
02:33:37 <pumpkin> not the most elegant representation :)
02:33:41 <Axman6> :t fromList
02:33:43 <lambdabot> Not in scope: `fromList'
02:33:46 <Axman6> lame
02:34:15 <pumpkin> @let fromList [] = Nothing; fromList x:xs = Just x
02:34:16 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "fromList"))
02:34:21 <Peaker> Workybob: `And` for (,) too? :)
02:34:26 <joma> welli just want optimal performance really
02:34:57 <anthonymiller> what does the arrow mean in this data type: data Env e x = Env (e -> x)
02:35:00 <pumpkin> joma: might as well just try using a Data.Map of pair subscripts for now
02:35:02 <Axman6> :t listArray
02:35:04 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
02:35:06 <pumpkin> anthonymiller: a function
02:35:19 <pumpkin> anthonymiller: from type e to type x (they're type variables)
02:35:35 <anthonymiller> ga ga ga ga ga ga ga ga gadzooks
02:35:55 <Axman6> functions are data too :)
02:36:30 <quicksilver> joma: for optimal performance, I suggest you purchase an ultrasparc, and learn to code in sparc assembly.
02:36:38 <pumpkin> lol
02:36:55 <quicksilver> that's the only truly optimal approach.
02:37:12 <quicksilver> If you think that's too much work, then you have correctly recognised that premature optimisation is a sin.
02:37:14 <pumpkin> having a good representation of the matrices will help even in sparc!
02:37:15 <mmorrow> how are sparse matrices usually represented? i can't think of a more efficient way to do it than with O(lg n) lookup
02:37:16 <p_l> why ultrasparc?
02:37:21 <quicksilver> Now use Data.Map and move on.
02:37:24 <joma> pumpkin: yes i am using Map but i still dont see how to use IntMap. you mean instead of having row,col I should have row*col as key? but then 3,4 and 4,3 gives the samye key for example
02:37:31 <quicksilver> p_l: because it has a rather froody assembly language.
02:37:44 <mmorrow> joma:   IntMap a ==== Map Int a
02:37:51 <mmorrow> but specialized
02:38:03 <pumpkin> joma: then take row + col * height or vice versa
02:38:21 <mmorrow> you can put whatever _inside_ the IntMap that you want
02:38:30 <pumpkin> joma: but as quicksilver said, just use pairs for now
02:38:36 <Axman6> quicksilver: froody?
02:39:05 <dmwit> IntMap (IntMap a) -- joma
02:39:06 <mmorrow> IntMap (IntMap a), or  IntMap (STUArray s a), ...
02:40:02 <Axman6> me thinks that DPH is very well suited to matricies
02:40:10 <dmwit> DPH?
02:40:16 <Axman6> since that seems to be what _all_ the examples of using them are about
02:40:22 <Axman6> data parallel haskell
02:40:29 <Axman6> Data.Array.Parallel
02:40:34 <dmwit> mmm
02:40:35 <mmorrow> or have an IntMap Int for cols, and IntMap Int for rows, then to get (i,j) lookup both i and j, then take their intersection
02:40:55 <dmwit> wut
02:41:04 <pumpkin> Axman6: too many colons
02:41:12 <Axman6> heh
02:41:13 <pumpkin> sorry, DPH fails
02:41:16 <dmwit> mmorrow, How do you intersect two Ints?
02:41:27 <mmorrow> err, sorry i left out the punchline
02:41:39 <Axman6> pumpkin: why exactly?
02:41:40 <mmorrow> (the Ints are indices into a third  IntMap a
02:41:41 <mmorrow> )
02:41:44 <dmwit> oy
02:41:46 <pumpkin> Axman6: too many colons!
02:41:54 <mmorrow> err, i botched that
02:41:56 <dmwit> mmorrow, I still don't get how that would work.
02:42:01 <mmorrow> yeah, starting over
02:42:28 <mmorrow> rows = IntMap IntSet, cols = IntMap IntSet, stuff = IntMap a
02:42:35 <dmwit> yummy
02:42:46 <dmwit> But stuff :: STUArray Int a -- waaaay faster
02:42:47 <pumpkin> mmorrow: in that case if the first two IntMaps are just row and column indices, you might as well store them as arrays, unless you expect to have huge linear dimensions too
02:43:02 <pumpkin> as in, super huge matrices
02:43:04 <pumpkin> :P
02:43:13 <dmwit> For sparse matrices, that is exactly what you expect.
02:43:28 <mmorrow> it might be desireable in the case where you're doing localized (wrt a row or col) lookups and you have partially computed stuff that you can apply to many computations
02:43:45 <pumpkin> well, you could expect linear dimensions of 100000x100000 which would be infeasible to represent as a dense matrix
02:43:47 <mmorrow> i dunno though, it sounds dubious actually :)
02:43:54 <pumpkin> but two arrays of 100k elements aren't that bad
02:44:06 <mmorrow> sure, but the IntMaps would start out empty
02:44:12 <mmorrow> (nothing := 0)
02:44:35 <mmorrow> maybe 0 id (IM.lookup i m)
02:44:50 <dmwit> But this argument is so pointless!
02:44:58 <dmwit> It's really a pretty braindead representation.
02:45:03 <pumpkin> :P
02:45:07 <mmorrow> heh
02:45:24 <pumpkin> wli's been working on them recently
02:45:58 <Axman6> > unwords . transpose . words $ "simple cypher? we'll see i guess..."
02:45:59 <lambdabot>   "scwsig iyeeu mp'ee phls lels er. ?. ."
02:46:10 <pumpkin> maybe my modern computer algebra book has info in it on sparse matrix representations
02:46:18 <Axman6> > unwords . transpose . words $ "scwsig iyeeu mp'ee phls lels er. ?. ."
02:46:20 <lambdabot>   "simple?. cypher. we'll. seess iue g"
02:46:25 <mmorrow> otoh hand, that's a sweet way to do sql-ish queries, where you rep col indices as Map key IntSet, where the Ints in the IntSet are indices into the table for a particular value of key
02:46:28 <Axman6> :o
02:46:58 <mmorrow> boolean and ==> intersection, or ==> union
02:47:37 <pumpkin> if you ever felt tempted to use a sql database for your mother of all matrices
02:47:50 <baaba> > unwords "..."
02:47:51 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
02:48:02 <baaba> err oops
02:48:06 <baaba> > words "..."
02:48:07 <lambdabot>   ["..."]
02:50:21 <Axman6> > unwords . transpose . words $ "The implementation is based on big-endian patricia trees. This data structure performs especially well on binary operations like union and intersection. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation"
02:50:23 <lambdabot>   "TiibobptTdspewoboluaiHmbstiia(foiadwctagsmi hmsaniarhatesenipinnnoyehhtslm...
02:50:27 <Axman6> heh
02:50:40 <joma> what is a braindead representation?
02:50:44 <Axman6> > unwords . transpose . words . unwords . transpose . words $ "The implementation is based on big-endian patricia trees. This data structure performs especially well on binary operations like union and intersection. However, my benchmarks show that it is also (much) faster on insertions and deletions when compared to a generic size-balanced map implementation"
02:50:45 <lambdabot>   "Thelementation impedndianon.n iss-eciaeyced bagri.urlstio ontestmsni biesc...
02:50:46 <joma> Data.Map is good right?
02:50:53 <mmorrow> yes
02:51:40 <mmorrow> that was in reference to the dead horse we were beating about dual IntMap row/col image intersectory
02:52:29 <joma> if I want to be able to parallellize huge matrix multiplications and inverse and elmininations etc, which representation should I choose? and would that speed things up? i mean parallellism is on an 8core for example, speedup < 8, so if it is not possible to parallellize any reoresentation it might not be faster
02:52:53 <mmorrow> Maps might be hard to parallelize (if you only have one of them)
02:52:57 <Axman6> see, i knew parallel arrays were the right choice!
02:53:18 <Axman6> they're perfectly suited to parallel matrix operations
02:54:00 <pumpkin> Axman6: except when your matrices have two bajillion elements in them
02:54:14 <pumpkin> and your DPH arrays need rather more memory than you have available
02:54:17 <mmorrow> joma: what are the standard algos for this?
02:54:35 <Workybob> Peaker: that would be nice :)
02:54:50 <Workybob> as would + and ×
02:55:03 <Axman6> pumpkin: what else it doing to perform well with two bajillion elements then huh? :)
02:55:16 <pumpkin> Axman6: if most of them are 0
02:55:22 <pumpkin> it ignores them completely
02:55:36 <Axman6> pumpkin: you can do sparse arrays in DPH very easily
02:55:42 <pumpkin> ah okay
02:55:50 <mmorrow> Axman6: how?
02:55:59 <pumpkin> I didn't see that when I glanced at it
02:56:03 <pumpkin> so I assumed you couldn't :)
02:56:13 * mmorrow needs to RTFM
02:56:19 <pumpkin> me too
02:56:27 <Axman6> have none of you seen then videos and stuff on it? SPJ goes nuts about how awesome DPH/NDP is
02:56:35 <pumpkin> nope
02:56:45 <jeffz`> I saw 'em early last year
02:56:55 <pumpkin> never seen any haskell presentation actually
02:58:50 <pumpkin> Axman6: you have a link to an SPJ vid on DPH?
02:58:54 <pumpkin> one that'll make me go nuts?
02:58:58 <Axman6> yeah, getting it now
02:58:58 <joma> what is height in row + col * height?
02:59:22 <pumpkin> joma: the size of your matrix?
02:59:32 <Axman6> http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
02:59:51 <Axman6> i think...
02:59:56 <dmwit_> > transpose [[], [3]] == transpose [[3], []]-- Axman6
02:59:57 <lambdabot>   True
03:00:26 <pumpkin> he's quite lively!
03:00:37 <Axman6> dmwit_: yeah i was more curious about how it would turn out rather than it being useful (plus the results look kinda cool)
03:00:49 <Axman6> pumpkin: he's very bouncy :)
03:01:15 <joma> pumpkin: well 17770*480000
03:01:15 <Axman6> mmorrow: you should check out that video too :)
03:01:22 <dmwit_> ?quote wonder.*sees
03:01:22 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
03:01:36 <mmorrow> oh nice, just saw th elink
03:01:39 <Axman6> the matrix
03:01:55 <mmorrow> sparse?
03:02:11 <Axman6> heh, that answer was a little too relevent i think
03:02:31 <mmorrow> it was perfect
03:02:53 <Axman6> :)
03:03:04 <blathijs> Hmm, it seems that ghci "caches" results (ie, when I run "main", then set a breakpoint and run "main" again, the breakpoint doesn't trigger). Is there any way to disable or flush this "cache" ?
03:03:17 <dmwit> :reload
03:04:35 <blathijs> dmwit: Doesn't seem to work
03:05:24 <Axman6> did you set the breakpoint again?
03:06:01 * Axman6 doesn't know much about breakpoints and such in ghci
03:06:23 <blathijs> Axman6: No, should I?
03:06:24 * dmwit neither
03:06:31 <Axman6> no idea :\
03:06:34 <dmwit> That looked a lot better before the /me translation
03:06:36 <zoq> blathijs: maybe :set +r helps
03:06:37 <Axman6> check the ghc docs
03:08:37 <Saizan_> (is existential quantification really that hard to pronounce?)
03:08:54 <blathijs> :set +r looks promising, but doesn't work either. Resetting the breakpoint doesn't help.
03:08:55 <pumpkin> Saizan_: nope
03:09:04 <blathijs> Thanks for the suggestions, I'll check the docs
03:09:26 <Axman6> pumpkin: ya'welcome :)
03:09:46 <pumpkin> Axman6: taking advantage of my followage on twitter to try to promote haskell :D
03:10:02 <Axman6> :)
03:10:53 <pumpkin> I want a "parallel UArr"
03:11:33 <pozic> How can I see whether the monomorphism restriction is enabled in the currently loaded module?
03:13:07 <Axman6> pumpkin: i'm so glad i actually have something to twitter about. "taking a shit" "that was a big shit" "i'm hungry" makes the internet stupid (hence why deleted my original account)
03:13:19 <Axman6> why i*
03:13:19 <pumpkin> ah yeah :)
03:13:23 <joma> yes it that caching i ahve noticed too? sometimes i run a function and then it is slow to get the answer and the next time it it fast. does that mean i dont have to cache myself? and also, caching == memoisation? or there are some differences?
03:13:29 <pumpkin> I mostly use it to chastize dumb people
03:15:36 <Axman6> joma: it does in ghci, but not in compiled programs afaik
03:15:53 <joma> i see
03:16:09 <joma> and cahcing and memoisation is basically the same thing?
03:16:51 <joma> so if  i want to write a parallell matrix lib I should stick to arrays?
03:17:19 <joma> but then how do I rep sparse ones?
03:18:52 <dmwit> Caching and memoization are related, but different.
03:19:02 <dmwit> Top-level values are cached in both ghci and compiled programs.
03:19:24 <dmwit> If you want a parallel matrix library, you should stick to parallel data structures.
03:19:32 <dmwit> Array is not one of them, as far as I know.
03:20:01 <Axman6> joma: watch http://tinyurl.com/8qfpty
03:20:36 <joma> how do I declare a general type since :: a isnt possible?
03:20:53 <Axman6> huh?
03:21:07 <pumpkin> joma: it's possible if it makes sense
03:21:13 <pumpkin> :t undefined
03:21:14 <lambdabot> forall a. a
03:21:35 <dmwit> It doesn't make sense.
03:21:39 <Axman6> data Matrix a = Array Int a or somesuch?
03:22:10 <Axman6> data Matrix a = [:((Int,Int),a):] might be better
03:22:54 <kmeyer> :t Matrix
03:22:55 <lambdabot> Not in scope: data constructor `Matrix'
03:23:08 <kmeyer> @src Matrix
03:23:08 <lambdabot> Source not found. Are you on drugs?
03:24:19 <joma> is Data.Map parallell?
03:24:43 <pumpkin> the only "parallel datastructure" is the parallel array in DPH afaik
03:24:46 <Axman6> well it's a datatype, so not really
03:24:56 <Axman6> pumpkin: still watching?
03:25:09 <pumpkin> Axman6: yeah, but I took a really big shit and now I'm hungry
03:25:17 <Axman6> :P
03:27:41 <nikki93> Say hello to nikkiSort! (a very slow method, but I thought of it myself)
03:27:49 <nikki93> nikkiSort [] = []
03:27:50 <nikki93> nikkiSort xs = smallest : (nikkiSort rest)
03:27:50 <nikki93>     where smallest = minimum xs
03:27:50 <nikki93> 	  rest =  (takeWhile (/= smallest) xs) ++ (tail (dropWhile (/= smallest) xs))
03:28:19 <dmwit> :t delete
03:28:21 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
03:28:43 <nikki93> dmwit: Cool, didn't know about that.
03:28:57 <nikki93> dmwit: But the thing is, it should only delete one instance of the element from the list.
03:29:00 <dmwit> x : nikkiSort (delete x xs) where x = minimum xs
03:29:04 <dmwit> > delete 2 [1, 2, 2, 3]
03:29:06 <lambdabot>   [1,2,3]
03:29:08 <dmwit> ;-)
03:29:11 <nikki93> dmwit: Ok. :)
03:29:22 <nikki93> @src delete
03:29:22 <lambdabot> delete = deleteBy (==)
03:29:33 <nikki93> @src deleteBy
03:29:34 <lambdabot> deleteBy eq x []        = []
03:29:34 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
03:31:04 <nikki93> delete not inscope...
03:31:10 <dmwit> ?index delete
03:31:11 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
03:31:15 <dmwit> ugh
03:31:20 <dmwit> Data.List has the one you want.
03:31:28 <nikki93> Ok.
03:31:38 <nikki93> Yup, I put it there.
03:31:49 <nikki93> Sorry, I'm very new to haskell. ;-)
03:32:09 <dmwit> No apologies necessary. =)
03:32:19 <nikki93> dmwit: Wait... I've seen you somewhere.
03:32:23 <nikki93> dmwit: Umm.. Xmonad?
03:32:29 <dmwit> yes
03:32:33 <nikki93> dmwit: Aha!
03:32:33 <dmwit> I hang out in #xmonad a lot.
03:32:42 <nikki93> Haskell is cool.
03:32:53 <nikki93> I'm hoping to use it as a scripting language for my C/C++ games.
03:33:32 <nikki93> How can I scramble a list?
03:33:46 <dmwit> ?go oleg randomly permute a list
03:33:48 <lambdabot> No Result Found.
03:33:49 <nikki93> I have a list of fibonacci series, I want to scramble it and send it to sort just to see how fast it is.
03:33:58 <dmwit> ?go oleg random list
03:34:00 <lambdabot> http://myanimelist.net/profile/Oleg
03:34:00 <lambdabot> Title: Oleg's Profile - MyAnimeList.net
03:34:05 <dmwit> WTF?
03:34:06 <pumpkin> lol
03:34:14 <Axman6> heh
03:34:18 <nikki93> @quote dmwit WTF?
03:34:18 <lambdabot> No quotes match. Maybe you made a typo?
03:34:23 <doserj> @go oleg perfect shuffle
03:34:25 <nikki93> @remember dmwit WTF?
03:34:25 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
03:34:25 <dmwit> ?where oleg
03:34:25 <lambdabot> I will remember.
03:34:26 <lambdabot> http://okmij.org/ftp/
03:34:32 <nikki93> @quote dmwit
03:34:33 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
03:34:40 <nikki93> @quote dmwit
03:34:41 <lambdabot> dmwit says: Only in #haskell would somebody consider rolling back a process fork.
03:34:44 <nikki93> @quote dmwit
03:34:45 <lambdabot> dmwit says: XML is syntactic foam.
03:34:49 <nikki93> @quote dmwit
03:34:49 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
03:34:51 <nikki93> @quote dmwit
03:34:52 <lambdabot> dmwit says: XML is syntactic foam.
03:34:54 <nikki93> @quote dmwit
03:34:54 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
03:34:58 <nikki93> That's it? :P
03:35:02 <dmwit> doserj++
03:35:15 <nikki93> c++ (who's c?)
03:35:42 <nikki93> main = interact calc
03:35:42 <nikki93>     where calc str = (show . head . (foldl oneWord []) . words $ str) ++ "\n"
03:35:42 <nikki93> 	  oneWord (x:y:xs) ("+") = (x+y) : xs
03:35:42 <nikki93> 	  oneWord (x:y:xs) ("-") = (y-x) : xs
03:35:42 <nikki93> 	  oneWord (x:y:xs) ("*") = (x*y) : xs
03:35:44 <nikki93> 	  oneWord (x:y:xs) ("/") = (y/x) : xs
03:35:47 <nikki93> 	  oneWord xs y = (read y) : xs
03:35:49 <nikki93> My RPNCalc :)
03:35:52 <nikki93> Haskell rocks!
03:36:57 <Axman6> nikki93: use hpaste
03:37:27 <hugo___> yeh, put it on hpaste :)
03:38:03 <nikki93> Axman6: Ok.
03:44:46 <nikki93> Lets say I have a function, fib n, that gives the series of first n fibonacci numbers as a list. What it returns is a list of expressions to calculate the fibonacci, or the answers?
03:45:36 <quicksilver> that depends on how you think of it.
03:45:43 <quicksilver> logcaly it returns the answers
03:45:46 <quicksilver> but in practice, in a lazy language
03:46:00 <quicksilver> and answer is the same thing as the instructions to calculate the answer.
03:46:18 <Axman6> well, probably a list of thunks what will be evaluated when you need the results
03:48:09 <nikki93> Hmm nikkiSort is pretty fast. :)
03:48:54 <Axman6> how quickly does it sort reverse [1.1000000]?
03:49:35 <nikki93> But reverse [1..100000] itself might take time to calculate, that's why I want a 'already calculated version' of reverse [1..100000] to try it on.
03:50:02 <nikki93> In ghci, if I do 'let x = reverse [1..1000000]', then x is the answer list or the thunk list?
03:50:21 <yottis> i've been wondering about that sort of things myself
03:50:29 <nikki93> s/thunk list/thunk/
03:50:32 <Saizan_> x is not evaluated until you actually inspect it
03:50:43 <quicksilver> nikki93: there is no difference.
03:50:48 <quicksilver> nikki93: answer list is thunk list.
03:50:48 <nikki93> Saizan_: What if I inspect it twice. Does it calculate every time?
03:50:52 <quicksilver> no.
03:51:00 <quicksilver> when a thunk it replaced by its value, that is permanenet.
03:51:19 <nikki93> quicksilver: I mean, [1,2,3,4] instead of something like [2+2,4/3] and stuff.
03:51:34 <Axman6> nikki93: [1000000,999999..1] might be more efficient
03:51:45 <Spark> there is no difference until you care about performance
03:52:14 <yottis> what happens if the thunk takes a lot of memory, but is very cheap to calculate? say [1..100000]
03:52:28 <quicksilver> well, I'm trying to push nikki93 towards better formed questions.
03:52:39 <quicksilver> everything is on demand in haskell.
03:52:49 <quicksilver> x = reverse [1..1000000] doesn't do anything at all
03:52:53 <Spark> he's trying to understand the implementation
03:52:54 <quicksilver> ...until you try to inspect x.
03:52:57 <Spark> not the semantics
03:53:03 <quicksilver> Yes, I know.
03:53:12 <nikki93> quicksilver: Ok. So how do I make it do something?
03:53:20 <nikki93> quicksilver: 'seq'?
03:53:21 <dmwit> yottis, That's just syntax sugar for the call "enumFromTo 1 100000".
03:53:21 <quicksilver> nikki93: by inspecting it.
03:53:44 <quicksilver> nikki93: well seq allows you to tie the forcing of that value to the forcing of something else.
03:54:07 <nikki93> Ok. Once I inspect it, when I inspect it again, does it 'calculate' again?
03:54:10 <quicksilver> no.
03:54:10 <fasta> nikki93: find some Scheme code which implements force and delay. Then it will all be obvious to you.
03:54:23 <nikki93> For example, if I say let x = [2+2,2/2]
03:54:24 <quicksilver> nikki93: when a thunk is evaluated, it is replaced by its value.
03:54:29 <quicksilver> That is a permanenet replacement.
03:54:37 <nikki93> Here, 2+2 and 2/2 don't 'happen' right?
03:54:47 <dmwit> No, and neither does the (:) or [].
03:54:59 <nikki93> But when I do 'x' (in ghci), then it 'happens'.
03:55:02 <quicksilver> nikki93: nothing at all happens.
03:55:04 <dmwit> (2+2) : (2/2) : [] -- none of this happens
03:55:04 <quicksilver> yes.
03:55:08 <nikki93> After that, if I do 'x' again, does it happen again?
03:55:11 <quicksilver> no.
03:55:15 <quicksilver> it happens once and once only.
03:55:15 <nikki93> Ok.
03:55:20 <quicksilver> (I've answered this three times now!)
03:55:23 <Spark> the thunk gets replaced, in memory, with the answer
03:55:31 <quicksilver> ghci constructs a string representation of the result.
03:55:32 <Spark> the value, i should say
03:55:39 <quicksilver> It's that (trying to construct the string representation)
03:55:44 <quicksilver> which ends up forcing the work to happen.
03:55:51 <boegel> yo haskell-gang!
03:56:06 <Spark> often it's important to choose when the work gets done
03:56:15 <Spark> so how do you force it to happen at a particular time
03:56:26 <Spark> other than scanning over the data as that's ugly
03:56:44 <boegel> I was wondering, is there an easy way to profile an application, while seperating between time spent in IO and actual CPU time?
03:56:46 <dmwit> Spark, That is exactly how you force it.
03:56:52 <Spark> that's ugly
03:56:59 <dmwit> That's life.
03:57:02 <boegel> Spark: seq?
03:57:38 <quicksilver> Spark: how would you imagine forcing a chain of thunks except by scanning over them?
03:57:39 <boegel> dmwit: wuoldn't seq help him?
03:57:47 <dmwit> boegel, Well, you can profile, and it will tell you the timings for your pure functions.  Those won't have any of the IO bits timed...
03:57:50 <quicksilver> boegel: yes, but only by scanning over the data with seq.
03:58:00 <quicksilver> boegel: so it's still scanning over the data.
03:58:00 <dmwit> boegel, Sure, but you have to scan the list with seq.
03:58:06 <RayNbow> @hoogle rnf
03:58:06 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
03:58:09 <Spark> quicksilver: some sort of construct or api
03:58:19 <boegel> dmwit: well, the problem is that I have an IO function which also does some computing (parsing values and such)
03:58:21 <quicksilver> Spark: scanning over the list is a construct.
03:58:27 <quicksilver> Spark: there is an API to it (rnf)
03:58:27 <dmwit> rnf does do the scanning for you.
03:58:32 <Spark> what if you discard the result
03:58:36 <boegel> dmwit: and I'm trying to figure out if the bottleneck is the actual IO or something else
03:58:38 <Spark> won't it optimise it away and not do it
03:58:43 <dmwit> Spark, But why do you want to do this?  Are you sure you're doin it right (tm)?
03:58:44 <boegel> dmwit: 'cause it seems bloody slow to me
03:58:53 <doserj> well, in the case of reverse, a simple seq already does a lot
03:58:57 <quicksilver> Spark: not if you do it right, no.
03:59:28 <Spark> quicksilver: i don't see a way a good compiler can distinguish between unnecessary work and necessary work unless the result is actually used
04:00:25 <quicksilver> Spark: because you tell it what the necessary work is.
04:00:40 <quicksilver> Spark: by attaching it to some other obviously necessary work.
04:00:40 <nikki93> @src minimum
04:00:40 <lambdabot> minimum [] = undefined
04:00:40 <lambdabot> minimum xs = foldl1 min xs
04:00:50 <Spark> quicksilver: that's not discarding the result then
04:00:53 <nikki93> @src foldl1
04:00:53 <lambdabot> foldl1 f (x:xs) = foldl f x xs
04:00:54 <lambdabot> foldl1 _ []     = undefined
04:01:04 <quicksilver> Spark: it can be, yes.
04:01:10 <nikki93> @src min
04:01:11 <lambdabot> min x y = if x <= y then x else y
04:01:11 <quicksilver> "foo `seq` return ()"
04:01:13 <Twey> Why were class aliases rejected for Haskell'?
04:01:15 <nikki93> Aha!
04:01:15 <quicksilver> for example.
04:01:18 <Spark> this is the sort of trick you do to avoid compilers optimising away your benchmark
04:01:22 <quicksilver> Twey: no implementation, perhaps?
04:01:25 <nikki93> Have you seen my 'min' formula?
04:01:38 <boegel> nikki93: where?
04:01:41 <Twey> Hmn, I see
04:01:44 <nikki93> min x y = (x + y + abs (x - y)) / 2
04:01:52 <quicksilver> Twey: no proposal is seriously considered unless someone has implemented it.
04:01:55 <joma> how is HashTable different from Map ?
04:01:59 <Twey> An existing implementation is necessary?
04:02:00 <Twey> Ah
04:02:04 <dmwit> nikki93, It's got a bad type, and it doesn't work for, say, Bool.
04:02:06 <quicksilver> Twey: otherwise you might as well propose the moon on a stick.
04:02:13 <quicksilver> joma: HashTable is worse in every way.
04:02:19 <quicksilver> and has a longer name, too boot.
04:02:22 <Spark> quicksilver: so seq is a special case in the compiler?
04:02:25 <nikki93> dmwit: It works only for numbers.
04:02:27 <dmwit> nikki93: String is probably a better example of something you might want min to work for.
04:02:52 <joma> is there stuff shipping with ghc for GUIs?
04:02:54 <nikki93> But I thought of it myself (in the bathroom)!
04:03:00 <quicksilver> Spark: I'm not sure what you mean by special case.
04:03:04 <quicksilver> Spark: it's a primitive, yes.
04:03:11 <Twey> quicksilver: Well, sure, but it isn't exactly pie-in-the-sky stuff
04:03:15 <dmwit> joma, There is Gtk2Hs.  It doesn't ship with GHC, but it's pretty darn portable.
04:03:19 <boegel> nikki93: why implement it like that? is it faster?
04:03:19 <nikki93> Have you guys seen nikkiSort? Its a really bad and slow sort algorithm that works somehow.
04:03:23 <Spark> ah so seq is only used for this?
04:03:28 <nikki93> boegel: I dunno. But its funner. :P
04:03:37 <boegel> nikki93: heh :)
04:03:42 <Twey> I see left-assoc $ was rejected too :(
04:03:50 <quicksilver> Spark: seq is used for controlling evaluation.
04:03:53 <quicksilver> Spark: that is all it is, yes :)
04:03:54 <Spark> ok fine
04:03:56 <nikki93> nikkiSort [] = []
04:03:56 <nikki93> nikkiSort xs = smallest : nikkiSort (delete smallest xs) where smallest = minimum xs
04:03:58 <quicksilver> Spark: it has no other purpose.
04:04:05 <RayNbow> Twey
04:04:11 <RayNbow> `id` = left-assoc $
04:04:12 <Spark> so there's no need to "scan over the data"
04:04:13 <quicksilver> nikki93: that's called selection sort, in a sense.
04:04:16 <Axman6> > delete 1 [1,2,3,4,1,2,3]
04:04:17 <Spark> you have direct control
04:04:18 <lambdabot>   [2,3,4,1,2,3]
04:04:19 <nikki93> quicksilver: Cool.
04:04:33 <quicksilver> nikki93: although some might argue that the functional algorithm isn't a true selection sort.
04:04:37 <quicksilver> Spark: yes, there is.
04:04:43 <nikki93> quicksilver: Yay! :P
04:04:44 <RayNbow> except that `id` has a high precedence
04:04:45 <quicksilver> Spark: if you want to force every element of a list, you will have to scan over the list.
04:04:48 <RayNbow> erm
04:05:01 <ac> isn't "return $ return foo" the same as "return foo"?
04:05:14 <nikki93> What about, lets say, an alert message to the user.
04:05:24 <Twey> RayNbow: Yeah, but typing foo `id` bar `id` baz is not nice :-P
04:05:26 <ziman> > return $ return 3 :: [[Int]]
04:05:27 <quicksilver> ac: no.
04:05:27 <lambdabot>   [[3]]
04:05:28 <nikki93> THat shouldn't be lazily-evaluated (or thunked or whatever).
04:05:36 <Axman6> > return . return
04:05:37 <lambdabot>       Overlapping instances for Show (a -> m (m1 a))
04:05:37 <lambdabot>        arising from a us...
04:05:39 <Twey> import Prelude hiding (($)) FTW
04:05:42 <Axman6> :t return . return
04:05:43 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Monad m) => a -> m (m1 a)
04:05:44 <quicksilver> nikki93: that doesn't make sense.
04:05:51 <quicksilver> nikki93: IO actions occur when you ask them to occur.
04:05:54 <joma> where do i find parallell array?
04:06:00 <quicksilver> nikki93: there is no conflict with lazy evaluation.
04:06:02 <ac> I thought one of the monad laws was that (m (m x)) was the same as (m x) but I was just wrong apparently
04:06:05 <Spark> quicksilver: heh so it's not 'deep'
04:06:11 <Axman6> joma: Data.Array.Parallel
04:06:14 <quicksilver> Spark: no, it's weak head normal form.
04:06:18 <Spark> ah ok
04:06:26 <Axman6> ac: no
04:06:35 <joma> even if my matrixlib doesnt use explicitly parallell datastructures i could still program it to perform multiplications in parallell right?
04:06:46 <dmwit> yes
04:06:48 <Axman6> ac: should [1..10] be th same as [[1..10]]?
04:06:55 <nikki93> quicksilver: May be I just suck. :P
04:07:03 <ac> Axman6: clearly not. But I'm tired, so I should probably not be talking
04:07:03 <Axman6> ac: i think you may be thinking of join though
04:07:04 <baobab> let x = [y:z | y <- [2,3,4,5], z <- []]
04:07:09 <quicksilver> nikki93: not really, maybe I was a bit unkind in my response.
04:07:11 <baaba> @hoogle m (m a) -> m a
04:07:11 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
04:07:11 <lambdabot> Prelude concat :: [[a]] -> [a]
04:07:11 <lambdabot> Data.List concat :: [[a]] -> [a]
04:07:11 <joma>  Could not find module `Data.Array.Parallell':
04:07:20 <baobab> x is []... why??
04:07:24 <ac> ah yes, join
04:07:25 <quicksilver> nikki93: but there is no conflict between lazy evaluation and dialog boxes appearing when you want them to ;)
04:07:29 <dmwit> nikki93, The command to print a message constructs (lazily!) a data structure representing a "print" action.
04:07:41 <joma> it is a member of package dph-par, which is hidden
04:07:44 <nikki93> Today me and my physcics teacher were discussing Haskell.
04:07:49 <Axman6> baobab: z <- [[]] would work
04:07:52 <joma> and he said?
04:07:59 <dmwit> nikki93,  The run-time system then has a top-level action called "main" that it demands, and executes whatever representation it finds there.
04:08:00 <nikki93> I was telling him about passing functions around and lazy evaluation and stuff.
04:08:03 <nikki93> He said its awesome. :P
04:08:27 <baobab> Axman6: I love you man
04:08:36 <dmwit> nikki93, So there's no conflict between laziness and sequencing, because your representation can include structures like "print this *and then* print this".
04:08:39 <Axman6> i told you, not in public!
04:08:56 <baobab> hihihi ok see you in my room
04:09:14 <nikki93> OMG Axman6 and baobab! O_o
04:09:48 <baobab> make haskell, not war
04:10:00 <nikki93> ghc --make haskell
04:10:14 <nikki93> ghc --make war
04:10:16 <nikki93> ./war
04:10:37 <baobab> i wish the second did not compile...
04:10:53 <nikki93> baobab: Didn't. The file was 'war.hs', not 'war'. :P
04:11:01 <baobab> :D
04:11:02 <Spark> ok, theoretical question about automata
04:11:11 <nikki93> Spark: Shh
04:11:19 <Axman6> ?
04:12:02 <Spark> in a deterministic finite automata, one can consider doing a DFS and getting a (perhaps infinite) set of paths from it
04:12:11 <nikki93> Today, we had a competitive exam (non-school), about computers. There were 5 Microsoft Access questions there. :|
04:12:23 <Spark> does the set of paths ever change in size if you minimise the dfa
04:12:29 <Axman6> nikki93: yuck
04:12:43 <nikki93> Axman6: Thought so too.
04:12:52 <hugo___> hmm
04:13:03 <hugo___> how do i check if a given string matches a given pattern ?
04:13:09 <baobab> my guess is that it shouldn't
04:13:10 <Spark> i suspect with a DFA there's exactly one path per word in the language
04:13:12 <Axman6> ==
04:13:15 <hugo___> is there a good regex module in haskell ?
04:13:15 <Spark> so i think the answer is no
04:13:18 <nikki93> hugo___: Regexp pattern?
04:13:38 <hugo___> yes, do you know of any good module i can use of ? :/
04:13:44 <dmwit> Spark, You mean the set of accepting paths?
04:13:53 <nikki93> hugo___: I think RWH mentions patterns somewhere.
04:13:59 <Axman6> text.Regex.POSIX?
04:14:06 <Axman6> Text*
04:14:10 <Spark> dmwit: yeah in my case all the nodes are exit nodes so that's all paths :)
04:14:17 <nikki93> hugo___: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
04:14:22 <dmwit> Spark, The set of all accepting paths is exactly the same, so minimization doesn't change the size of that set.
04:14:42 <hugo___> thanks you
04:15:15 <joma> it is a member of package dph-par, which is hidden. so how do I get it? and is it parallell or parallel ?
04:15:42 <Axman6> joma: what is?
04:15:58 <dmwit> Oh snap, byorgey is here.  I better go to bed.
04:16:15 <nikki93> hugo___: "str" =~ "(str|lalala)" :: Bool
04:16:39 <Axman6> joma: try importing GHC.PArr, that should give you [::]
04:16:43 <hugo___> nice
04:16:46 <hugo___> sweet and easy
04:16:49 <hugo___> great
04:17:08 <joma> doesnt any gui-facilities ship with ghc?
04:17:21 <Axman6> no, you need to install gtk2hs
04:17:54 <joma> even if my matrixlib doesnt use explicitly parallell datastructures i could still program it to perform multiplications in parallell right?
04:17:58 <nikki93> Luca? :|
04:18:12 <Axman6> probably
04:18:13 <joma> Axman6: data.array.parallel
04:18:31 <dmwit> joma, What the deuce.  You've asked the exact same questions like an hour ago, and gotten the exact same answers.
04:18:52 <quicksilver> joma: opengl ships with most versions of GHC
04:18:59 <quicksilver> that's GUI although not terribly convenient.
04:20:28 <quicksilver> I should sya, it's graphical, not GUI
04:20:34 <joma> stewie griffin?
04:20:34 <quicksilver> althouguh you can obviously construct GUIs in it.
04:27:15 <SyntaxRebel> can anybody explain what's causing this error? http://hpaste.org/14080
04:27:40 <SyntaxRebel> i am trying to install wx, and its complaining that i dont have stm-2.1.1.2
04:27:56 <dolio> Do you?
04:28:12 <SyntaxRebel> i do
04:28:52 <SyntaxRebel> and it was installed by cabal
04:29:02 <dolio> Oh. Hmm...
04:29:20 <dolio> Are you installing wx manually?
04:29:33 <SyntaxRebel> no, via cabal
04:29:38 <Philonous> @src init
04:29:38 <lambdabot> init [x]    = []
04:29:38 <lambdabot> init (x:xs) = x : init xs
04:29:38 <lambdabot> init []     = undefined
04:29:44 <quicksilver> stm was installed by cabal?
04:29:46 <SyntaxRebel> here's my ghc-pkg list http://hpaste.org/14081
04:29:46 <quicksilver> is that possible?
04:29:53 <quicksilver> I thought stm was a core GHC package?
04:30:02 <Philonous> > take 10 $ init [1..]
04:30:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:30:12 <skorpan> if i want to do file system operations such as renaming files and directories, where do i look?
04:30:22 <dmwit> System.Directory
04:30:40 <dmwit> See also System.Posix.Directory
04:30:43 <nikki93> I'm not able to understand heapsort... How exactly does it work?
04:30:48 <skorpan> dmwit: thanks
04:30:56 <Saizan_> SyntaxRebel: the problem is probably that it's looking in the global packagedb, while stm is installed in the user one
04:31:08 <dolio> Well, my only thought is that it isn't looking in your local packages for some reason, but I don't know why that would be.
04:31:14 <SyntaxRebel> quicksilver: well i could be wrong about cabal but then why would ghc-pkg show me stm in my .ghc dir?
04:32:01 <SyntaxRebel> Saizan_:i havent yet understood how ghc includes stuff :/ , but ill try and install it globally
04:32:11 <dolio> nikki93: Heapsort works because you can use an array of length n as storage for a heap of n elements.
04:32:13 <quicksilver> SyntaxRebel: I don't know. I thought that was odd, too.
04:32:39 <dolio> With such a representation, the maximum element of the heap will always be in the first position in the array.
04:32:58 <pejo> SyntaxRebel, global packages can't depend on user packages, since they are invisible for other users.
04:33:12 <dolio> So, you heapify the array. Then you swap the maximal element to the end of the array. Then you sort the remaining n-1 elements.
04:34:01 <dolio> Re-heapifying the array after such a swap is somewhat simpler than building the heap from scratch, too.
04:34:52 <SyntaxRebel> pejo: well i must be missing something because both wx and stm where user packages on my system :/
04:35:12 <nikki93> Would you guys recommend haskell as an extension/embedding language for games inside C++?
04:36:06 <Axman6> i wouldn't, but that's mainly because haskell isn't aimed at anything lik that
04:36:24 <joma> to compile is just ghc Main.hs ?
04:36:36 <nikki93> joma: ghc --make Main.hs
04:36:47 <jeffz`> nikki93: if your write your game in Haskell you can also write an exension/embedded language in Haskell too
04:36:52 <Axman6> ghc Main.hs or ghc --make Main.hs
04:37:04 <nikki93> jeffz`: Nope, I'm with C++ for making games. :)
04:37:12 <jeffz`> nikki93: sounds painful
04:37:13 <Axman6> pfft
04:37:47 <Axman6> nikki93: do you know C++?
04:37:53 <nikki93> jeffz`: You mean, programming games in C++ sounds painfull?
04:38:05 <jeffz`> nikki93: no, just programming in C++
04:38:13 <nikki93> Axman6: Ehm, yes, I use it for graphics stuff. Check out www.grall.uni.cc.
04:38:28 <nikki93> Axman6: + physics + sound + etc.
04:38:30 <Twey> Heheh
04:38:35 <Twey> Painful, indeed
04:38:45 <nikki93> No, I actually like C++. :)
04:38:45 <Axman6> heh, i actually believed you were 15...
04:38:53 <nikki93> Axman6: I'm 15...
04:39:00 <Axman6> nikki93: you won't once you really learn haskell ;)
04:39:22 <SyntaxRebel> well insalling stm as a system package didnt help :(
04:39:23 <Twey> I like C++ too, but mostly in a masochistic 'i r 1337 h4xx0r!!11one' kind of way
04:39:23 <nikki93> Axman6: Hah. But I can't do away with Object Orientedness for some reason.
04:39:28 <nikki93> Twey: lol
04:39:29 <Twey> And C works better for that :-D
04:39:43 <nikki93> It ain't that bad c'mon, what's so hard about C++? Hello world is easy. :P
04:39:48 <Twey> 'Look at me, I do my memory management by hand!'
04:39:52 <joma> of ll the database packages, if i only want stuff for interacting with postgresql, which should I choose?
04:39:59 <Twey> Wouldn't use it for anything serious though
04:40:11 <Twey> (except, y'know, a kernel or something)
04:40:13 <nikki93> Twey: Memory management is no C++ or feature of any language actually.
04:40:25 <Twey> nikki93: I'm aware :)
04:40:28 <nikki93> Twey: The language is just a specification.
04:40:30 <nikki93> Twey: Ok. :)
04:40:51 <nikki93> Twey: You can have garbage-collection-kinda-stuff with boost::smartptr
04:41:21 <Twey> There's actually a full garbage collector for C++
04:41:23 <Axman6> joma: HDBC or whatever it is, the postgres version
04:41:29 <nikki93> Twey: There are a few.
04:41:34 <Twey> Aye
04:41:40 <Twey> But that defeats the point
04:41:43 <nikki93> Axman6: What made you think I'm 15?
04:41:44 <Twey> It's not 1337 any more :-P
04:41:52 <nikki93> Twey: lol, then don't use it.
04:41:53 <Axman6> the nick...
04:42:03 <nikki93> Axman6: Oh. :|
04:42:10 <nikki93> Axman6: How old are you?
04:42:12 <Twey> Heh
04:42:14 <Axman6> and a discussion yesterday where someone asked you if you were 15 qand you said yes...
04:42:18 <Axman6> 19
04:42:19 <Twey> xD
04:42:22 <nikki93> Axman6: But I AM 15 dude!
04:42:45 <SyntaxRebel> wait no actually there is something new in this error! :S http://hpaste.org/14082
04:42:54 * Axman6 is just going to assume nikki93 is 93 and will die soon so he doesn't have to worry about his age!
04:43:09 * nikki93 kicks Axman6 *there*
04:43:14 <SyntaxRebel> "Writing new package config file... ghc-pkg: /Programs/GHC/6.10.1/lib/ghc-6.10.1/./package.conf: you don't have permission to modify this file"
04:43:31 <SyntaxRebel> why is a user package trying to write to the system package config?
04:43:43 <nikki93> Happy birthday Axman6!
04:43:56 <Axman6> you missed it by a month and a half
04:44:24 <Twey> Axman6: That makes you about a month older than I.  :)
04:44:53 <nikki93> SyntaxRebel: You use some Linux distribution starting with 'G'?
04:45:04 <Twey> ... no, Mac OS
04:45:06 <Axman6> really? i thought you were older than that
04:45:07 <Twey> Clearly :-\
04:45:08 <SyntaxRebel> nikki93: yes :)
04:45:17 <SyntaxRebel> why should that matter?
04:45:18 <nikki93> SyntaxRebel: Yes to?
04:45:19 <Twey> Whaaat
04:45:26 <nikki93> SyntaxRebel: What's the name of it?
04:45:32 <SyntaxRebel> niike93: GoboLinux
04:45:35 <nikki93> SyntaxRebel: GoGoLinux or som..
04:45:38 <nikki93> SyntaxRebel: Ah yeah.
04:45:39 <Twey> Ohh, *that* Linux starting with a G
04:45:51 <Twey> How is it, SyntaxRebel?
04:45:53 <nikki93> I recognised from /Programs
04:45:57 <Twey> I've been meaning to give it a try for a while
04:46:09 <nikki93> It raped the usual Unix directory structure.
04:46:10 <Axman6> the only distro i can tollerate is Arch.
04:46:16 <nikki93> Axman6: I'm on Arch. :)
04:46:25 <Axman6> it's the only one which hasn't a)pissed me off, and b) i've found usefull at all
04:46:35 <Axman6> useful*
04:46:43 <SyntaxRebel> nikki93: its cool. nice understandble software management. you can dive it the source code of just about anything and start hacking away
04:46:56 <nikki93> Ehm, you can do anything Linux on all distros, so how is any thing else less useful than Arch?
04:47:11 <nikki93> SyntaxRebel: I got used to /usr and /bin et all. :P
04:47:21 <nikki93> SyntaxRebel: I heard they have links for those though.
04:47:36 <SyntaxRebel> use we have your legacy tree too :P
04:47:40 <Axman6> you can do anything on any OS, doesn't mean you'd want to
04:47:52 <nikki93> Ahh, Windows comes to mind. :P
04:48:07 <nikki93> Anyone tried their new Windows 7 Beta
04:48:08 <Axman6> linux comes to mind for me first
04:48:08 <nikki93> ?
04:48:10 <SyntaxRebel> niiki93: trouble is you need a database to know what file belongs in what package :P
04:48:28 <Axman6> i've been hearing a lot of good stuff about win7, sadly
04:48:29 <SyntaxRebel> anyway... i dont want to start a distro fight
04:48:31 <nikki93> SyntaxRebel: Which IRC client do you use?
04:48:46 <nikki93> Axman6: Oh. Lets write some cool Linux software and kill 'em all.
04:48:49 <nikki93> Axman6: Got ideas?
04:49:07 <Peaker> I really often use (return ()), I wish (return ()) had a name
04:49:07 <Peaker> (In the Prelude)
04:49:10 <Axman6> screw that, i strongly dislike linux
04:49:14 <Peaker> unit = return () ; maybeAction = maybe unit
04:49:18 <Peaker> or maybe noAction or something
04:49:36 * nikki93 kicks Axman6 *there* && everywhere else
04:50:01 <nikki93> Axman6: Probably because you're using gnome/kde/otherbloat
04:50:12 <vegai> nikki93: will you write it on haskell or will you discuss this on another channel? :)
04:50:12 <nikki93> Axman6: Not that it has anything to do with anything.
04:50:15 <Axman6> the only thing i've found linux good for is haskell. and that's only because i haven't really tried installing it on one of the BSD's
04:50:25 <nikki93> vegai: YOu're the #haskell police?
04:50:27 <Axman6> nikki93: no i use xmonad when i can
04:50:31 * nikki93 hides
04:50:39 <vegai> in my sad dreams I am
04:50:48 * nikki93 gives vegai good dreams
04:50:52 <nikki93> Now?
04:51:25 <nikki93> I've heard good things about BSD but I'm (ironically (dunno how though)) scared about compatibility.
04:51:45 <Axman6> compatibility with what?
04:52:07 <nikki93> Software compatibility with BSD, and ease of 'setting up all my stuff'.
04:52:11 <nikki93> I have loads of things set up.
04:52:21 <mstr> does OS X count as BSD?
04:52:35 <nikki93> It counts as BSD - D I guess.
04:52:35 <mstr> it seems to run haskell well
04:52:48 <nikki93> mstr: BSD /= that which runs haskell well
04:53:00 <nikki93> mstr: BSD (AFAIK) is a Unix distribution by Berkely.
04:53:00 <mstr> at least to the extent of my m4d skillz :D
04:53:07 <Axman6> mstr: not really, the userland is based a lot on FreeBSD, but most would not consider it a BSD
04:53:08 <jberg> are most of haskell jobs posted on haskell.org?
04:53:25 <joma> whats wrong with ubuntu?
04:53:25 <nikki93> jberg: HAskell people have jobs? O_O
04:53:38 <nikki93> joma: NOthing, I used to use it.
04:53:43 <mstr> nikki93: coding c++ yeah :)
04:53:46 <jberg> nikki93, at least some, i hope :)
04:53:56 * Axman6 dispises ubuntu
04:54:09 <Philonous> Just wondering - quicksort is like succsesively inserting elements into an unbalancaed binary search tree where the pivot elements are the roots of the (sub) tree, isn't it?
04:54:23 <nikki93> joma: My desktop monitor got spoilt suddenly and I was too lazy to fix it, so I switched over to the laptop and had an Arch CD ready and decided to try it out. *breathe*
04:55:45 <Twey> Philonous: Pretty much
04:55:46 <nikki93> joma: I was able to get all my stuff set up (Ogre, C++ environment, vim with loads of scripts et. all) so I'm satisfied. I usually use xmonad on desktop but now I'm using 'awesome' because xmonad configuration takes a while to reach what I had on the desktop from scratch (bad grammar but you figure it out)
04:56:09 <quicksilver> Philonous: No.
04:56:26 <nikki93> I was bored so I thought of learnign Haskell and got hooked because of the sheer awesomenessityation of it.
04:56:30 <quicksilver> Philonous: That is what the proof that quicksort works is like.
04:56:45 <quicksilver> Philonous: (and it's what the "quicksort" you often seen written in haskell is rather like)
04:57:02 <quicksilver> Philonous: actual quicksort is in-place and the inplaceness + neat swapping algorithm is rather the point.
04:57:06 <nikki93> Haskell 'classic qsort' isn't real qsort.
04:57:17 <Twey> Mm
04:57:22 <nikki93> Not in place.
04:57:48 * quicksilver agrees with nikki93.
04:57:53 <Philonous> quicksilver: Ah, so quicksort is actually only the in situ variant? I thought that whas just that, a variant.
04:58:01 <quicksilver> no, that's the real deal.
04:58:05 <nikki93> But nikkiSort (the really slow selection sort one) is funneh. :P
04:58:11 <quicksilver> That's what tony hoare is credited with inventing.
04:58:50 <quicksilver> the imperative one has a *very* good constant, in the average case.
04:59:03 <Axman6> there's an inplace quicksort on the monad/ST page on the wiki
04:59:07 <quicksilver> the "functional" one isn't that much faster than merge sort.
04:59:09 <Axman6> well, linked from it
04:59:15 <nikki93> Have any of you read Knuth's Art Of Computer Programmationism?
04:59:20 <quicksilver> the real one is much much fast than merge sort.
04:59:22 <Axman6> also, i want to add another example on there....
04:59:24 <quicksilver> nikki93: some of it, yes.
04:59:35 <quicksilver> I imagine lots of people here have read some of it.
05:00:12 <nikki93> quicksilver: How's it?
05:00:34 <nikki93> Also, is OCaml much like haskel/
05:00:46 <nikki93> s:haskel/:Haskell?:
05:00:51 <Axman6> it's uglier imo, though i have no experience with it
05:00:51 <Twey> It's strict
05:00:59 <nikki93> Twey: As in?
05:00:59 <Axman6> @@ for comcatenation? wtf!
05:01:00 <lambdabot> Plugin `compose' failed with: Unknown command: ""
05:01:06 <Twey> You forgot to escape your ? :-P
05:01:08 <nikki93> Axman6: Hahahah!
05:01:09 <Philonous> quicksilver: I see why the haskell one-liners space complexity is worse . But why should it be slower?
05:01:17 <Axman6> nikki93: http://hpaste.org/274 to blow your mind, inplace quicksort in the ST monad
05:01:21 <Twey> Philonous: Because it's not in-place
05:01:31 <Twey> It could be optimised to be, of course
05:01:37 <skorpan> could someone help me out here? this code only returns [".", ".."] http://hpaste.org/14083
05:01:38 <Twey> (does GHC do that?)
05:01:40 <Philonous> using more RAM for the same amount of operations is slower?
05:02:01 <Twey> Philonous: Copying a structure for each mutation is slower
05:02:06 <Axman6> there's a very nice version of quicksort for haskell that's quite fast. sec...
05:02:49 <Philonous> Ah I see, because you need to copy all elements, not only those that get swapped
05:03:16 <quicksilver> Philonous: you copy every element log n times
05:03:24 <quicksilver> Philonous: (well not really the element itself, but the pointer to it)
05:03:36 <quicksilver> really, at best, that's just like merge sort.
05:03:43 <quicksilver> merge sort *definitely* copies every element log n times
05:03:44 <Axman6> i postd the last qsort here: http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Quicksort#Haskell (though i didn't write it :\)
05:03:50 <Axman6> posted*
05:03:57 <quicksilver> this functional quicksort probably does (but it can be worse, with bad pivots)
05:04:09 <pejo> Twey, there's a paper at PADL this year about recycling your arrays
05:04:15 <Twey> skorpan: WFM
05:04:20 <quicksilver> whereas the imperative quicksort is very close the optimum possible swaps/copies
05:04:29 <skorpan> Twey: what?
05:04:31 <nothingmuch> is there some tool that quickly opens ~/.cabal/share/doc/*/html/Some-Module.html when I ask for Some.Module?
05:04:41 <quicksilver> especially if your backend (assembly language?) has swap as a primitive.
05:04:44 <nikki93> can i skip this page http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html?
05:04:51 <nikki93> its boring
05:05:09 <Twey> skorpan:
05:05:11 <Twey> Prelude System.Directory Control.Monad> let getAllDirectories root = getDirectoryContents root >>= filterM doesDirectoryExist in getAllDirectories "."
05:05:14 <Twey> ["scripts",".hg",".","armour","models","configs","ui","src","..","sound","fonts","build","misc","gfx"]
05:05:15 <Axman6> yeah i got bored with the json stuff pretty quickly
05:05:18 <nothingmuch> nikki93: no i will not allow it
05:05:34 <skorpan> Twey: oh, "works for me", well then i'll just keep debugging...
05:05:39 * nikki93 shoots nothingmuch 
05:06:02 <Axman6> quicksilver: check out the last haskell quicksort on that page i linked, it's quite nice and fast really (and rather efficient space wise i think)
05:06:26 <Saizan_> nothingmuch: hoogle can do that, but you need to construct its database properly
05:06:30 <nikki93> Axman6: can haz skip?
05:06:44 <Axman6> do what you want
05:06:47 <Saizan_> nothingmuch: the command-line hoogle tool i mean
05:07:00 <nikki93> Axman6: advice
05:07:22 <skorpan> Twey: that's strange because it only gives me "." and ".." no matter which directory i give it as root.
05:07:36 <jeffz`> skorpan: you're not passing the full path to doesDirectoryExist?
05:07:40 <Twey> Hmmm
05:07:50 <skorpan> jeffz`: i am
05:08:00 <Twey> skorpan: It gives me ["..", "."] if I say "/"
05:08:09 <skorpan> Twey: same here, but for every directory i can think of
05:08:19 <jeffz`> skorpan: no, I don't think you are.
05:08:20 <nothingmuch> Saizan_: aha, didn't know there was a cli
05:08:29 <Twey> skorpan: How about within your homedir?
05:08:31 <nothingmuch> thanks
05:08:34 <skorpan> Twey: doesn't matter
05:08:41 <jeffz`> skorpan: look more carefully.
05:08:41 <skorpan> jeffz`: why so?
05:08:43 <Twey> Hmm
05:09:07 <skorpan> let getAllDirectories root = getDirectoryContents root >>= filterM doesDirectoryExist in getAllDirectories "/etc/"
05:09:18 <skorpan> oh, maybe... oh...
05:09:22 <quicksilver> skorpan: that's not going to work
05:09:29 <skorpan> you mean that getDirectoryContents gives me the "relative" path?
05:09:30 <nothingmuch> nikki93: i wouldn't skip, but skim
05:09:35 <Twey> Ahhhh.
05:09:37 <Twey> Of course.
05:09:39 <nothingmuch> IIRC it's a fairly long chapter with lots of useful tips
05:09:41 <skorpan> Twey: so why did it work for you?
05:09:42 <quicksilver> (\x -> doesDirectoryExist ("/etc" </> x))
05:09:43 <quicksilver> perhaps.
05:09:48 <nothingmuch> but it's pretty obvious if you know a bit
05:09:51 <Twey> skorpan: Because I was doing "."
05:09:58 <Axman6> hmm, i said "One draw back is that it requires the whole list be sorted, it's not very good for laziness" about that quicksort implementation, but i don't think i'm right about that...
05:10:15 <Twey> Hmm, but wait
05:10:18 <skorpan> Twey: yeah, what!? :)
05:10:29 <Twey> Prelude System.Directory Control.Monad> let getAllDirectories root = getDirectoryContents root >>= filterM doesDirectoryExist in getAllDirectories "/etc"
05:10:32 <Twey> ["fonts","..","sound","."]
05:10:39 <Peaker> why are inter-module optimizations considered so difficult? Can code from other compiled modules be inlined in a module?
05:10:41 <Twey> Oh
05:10:46 <tomh> anyone here knows if there are other terms for "static link optimization" ?
05:10:47 <Twey> They just happen to also be in "." :-P
05:11:04 <skorpan> i'm completely lost now... what was my error again?
05:11:05 <Twey> Haha, funny bug
05:11:12 <jeffz`> bug?
05:11:22 <skorpan> bug in *our* code i suppose
05:11:22 <quicksilver> skorpan: the bug is that getDirectoryContents returns names not paths.
05:11:23 <Twey> skorpan: As quicksilver said, you didn't pass the full path
05:11:32 <quicksilver> skorpan: but doeDirectoryExist requires a path
05:11:34 <quicksilver> (not just a name)
05:11:43 <Twey> So it would only give you a directory if it existed within the current directory, too
05:11:52 <skorpan> oh, lol
05:12:14 <skorpan> so what function gives me the "full" path? root ++ "/" ++ x?
05:12:15 <Twey> For example, when I did /etc, there were similarly-named "fonts" and "sounds" directories in both /etc and .
05:12:33 <quicksilver> skorpan: </>, as I told you.
05:12:39 <Twey> So getDirectoryContents gave me the /etc one, but doesDirectoryExist was checking the . one
05:12:46 <skorpan> quicksilver: sorry, i must have missed that
05:12:52 <quicksilver> \x -> doesDirectoryExist ("/etc" </> x)
05:13:16 <Twey> (doesDirectoryExist . ("/etc" </>)) >.>
05:13:28 <quicksilver> yup.
05:13:56 <skorpan> >.> as in the smiley face or as in a function? :|
05:14:08 <Twey> Where's </> defined?
05:14:10 <Twey> Haha :-P
05:14:15 <Twey> It was an emoticon :)
05:14:15 <quicksilver> FilePath
05:14:15 <Peaker> @hoogle </>
05:14:16 <skorpan> System.FilePath.Posix
05:14:16 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
05:14:16 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
05:14:18 <Twey> Ah, ta
05:14:35 <Peaker> @type foldr (</>) ""
05:14:36 <lambdabot> Not in scope: `</>'
05:14:48 <Peaker> @type foldr System.FilePath.Posix.</> ""
05:14:50 <lambdabot>     Couldn't match expected type `FilePath'
05:14:50 <lambdabot>            against inferred type `(a -> b -> b) -> b -> [a] -> b'
05:14:50 <lambdabot>     In the first argument of `(System.FilePath.Posix.</>)', namely
05:15:10 <skorpan> ahhhhhh, this is awesome, thanks you guys
05:15:45 <Twey> let getAllDirectories root = getDirectoryContents root >>= filterM doesDirectoryExist . map (root </>) in getAllDirectories "/etc"
05:15:54 <Peaker> @type foldr (System.FilePath.Posix.</>) ""
05:15:55 <lambdabot> [FilePath] -> FilePath
05:15:55 <Twey> ... returns lots of directories :)
05:16:20 <Axman6> :t foldr (System.FilePath.Posix.</>) ""
05:16:21 <lambdabot> [FilePath] -> FilePath
05:16:25 <Twey> Because </> is also used by Wadler's pretty-printing library?
05:16:43 <Twey> Wait, (a -> b -> b) -> b -> [a] -> b?  What's that?
05:17:01 <Twey> Oh, no
05:17:03 * Twey frowns.
05:17:08 <skorpan> that's a fold isn't it?
05:17:08 <Axman6> foldr...
05:17:56 <Peaker> Twey: that's the type of foldr -- where di you take that form?
05:17:59 <Peaker> from
05:18:06 <Peaker> @type foldr
05:18:08 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:18:16 <Twey> @type foldr System.FilePath.Posix.</> ""
05:18:17 <lambdabot>     Couldn't match expected type `FilePath'
05:18:17 <lambdabot>            against inferred type `(a -> b -> b) -> b -> [a] -> b'
05:18:17 <lambdabot>     In the first argument of `(System.FilePath.Posix.</>)', namely
05:18:20 <Twey> There
05:18:24 <Peaker> oh
05:18:24 <Twey> Oh
05:18:26 <Twey> I see
05:18:30 <Axman6> Twey: need to bracket it up
05:18:34 <Twey> </> is being applied to foldr and ""
05:18:38 <Twey> Yeah
05:18:46 <Peaker> appararently module namespace dot doesn't bind as strongly as it shoudl
05:18:58 <Twey> It will in Prime
05:19:06 <Twey> Er
05:19:13 <Twey> That's not what that's about
05:19:23 <Twey> System.FilePath.Posix.</> is still an operator
05:19:32 <Twey> So it's infix
05:19:40 <Peaker> oh, right
05:19:42 <Peaker> heh
05:19:42 <quicksilver> @type foldr (System.FilePath.Posix.</>) ""
05:19:43 <lambdabot> [FilePath] -> FilePath
05:19:48 <Twey> Prime disallows that
05:20:14 <Axman6> @hoogle (a -> Bool) -> [a] -> ([a],[a])
05:20:14 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
05:20:14 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
05:20:14 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
05:20:16 <Peaker> qualified operators should not be infix, it doesn't make much visual sense.
05:20:26 <Axman6> > break even [1..10]
05:20:28 <lambdabot>   ([1],[2,3,4,5,6,7,8,9,10])
05:20:30 <Twey> I concur, after some persuasion from Cale
05:20:40 <gal_bolle> Peaker it does after qualified import
05:20:44 <Axman6> @hoogle+
05:20:44 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
05:20:45 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
05:20:49 <gal_bolle> FP.</>
05:20:54 <Axman6> > partition even [1..10]
05:20:55 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
05:20:56 <Twey> gal_bolle: Nah
05:20:59 <Axman6> ah nice
05:21:00 <Peaker> gal_bolle: that doesn't look very good :)
05:21:10 <Peaker> gal_bolle: It should be import unqualified-closed (in parens)
05:21:25 <Peaker> > span even [1..10]
05:21:27 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
05:21:35 <Twey> span's lazy
05:21:43 <Twey> partition isn't
05:21:58 <Peaker> @src span
05:21:59 <lambdabot> Source not found. That's something I cannot allow to happen.
05:23:59 <Twey> Heh
05:24:19 <Twey> span basically stops when it hits the first that doesn't match, and just sticks the rest in the second half of the pair
05:24:36 <quicksilver> Twey: not sure what you mean by partition isn't lazy.
05:24:38 <Twey> partition goes through the whole list picking out the ones that do and don't match
05:24:51 <quicksilver> > (take 2 *** take 2) $ partition even [1..]
05:24:52 <lambdabot>   ([2,4],[1,3])
05:25:01 <Twey> Ah, yes, sorry
05:25:03 <Axman6> seems pretty lazy to me
05:25:06 <Twey> Forgot about that :(
05:25:25 <quicksilver> span and partition are certainly different though
05:25:27 <quicksilver> I agree there :)
05:26:51 <Peaker> break to span   is like   take to splitAt    right?
05:27:21 <Peaker> @type (break, span)
05:27:22 <lambdabot> forall a a1. ((a -> Bool) -> [a] -> ([a], [a]), (a1 -> Bool) -> [a1] -> ([a1], [a1]))
05:27:24 <Peaker> @type (take, splitAt)
05:27:26 <lambdabot> forall a a1. (Int -> [a] -> [a], Int -> [a1] -> ([a1], [a1]))
05:27:48 <Peaker> Maybe better names could convey these relationships better?
05:28:06 <Twey> Peaker: Uhm
05:28:14 <Twey> No, not really
05:29:09 <Twey> I don't think there's any equivalent... it doesn't make much sense
05:29:14 <Axman6> they seems like pretty reasonable names to me
05:29:39 <Twey> Oh, wait, break
05:29:43 <Peaker> Twey: Well, splitAt, break, span, take, drop, and the drop equivalent of break (which I don't know) are all very similar
05:30:24 <Twey> Still not exactly parallels
05:30:29 <Peaker> They all split a list at a certain position. The difference is whether choice of position is based on index or value-function, and whether both parts, first part, or second part are returned
05:30:37 <dolio> You can't really have two different splitAts like break and span. There's no predicate.
05:30:42 <Twey> Right
05:30:56 <Peaker> dolio: what do you mena?
05:31:22 <dolio> splitAt just takes a position to split at.
05:31:26 <Peaker> right
05:31:37 <dolio> break and span use a predicate on each character to determine where to split.
05:31:39 <Peaker> span should probably be:  splitBy or splitAtBy
05:31:51 <dolio> So there are two possibilities, keep going while true, or while false.
05:32:08 <Twey> Maybe splitWhere
05:32:12 <Peaker> yeah, that's good
05:32:18 <Peaker> splitAt, splitWhere
05:32:43 <Peaker> @type heads
05:32:45 <lambdabot> Not in scope: `heads'
05:33:04 <Axman6> inits
05:33:06 <Peaker> "take" is a good name, but "drop" is perhaps confusing
05:33:23 <Axman6> why?
05:34:08 <Peaker> Axman6: I am really striving to find a good name scheme that would convey that take/drop are like break/??? for splitWhere
05:34:18 <boegel> IO is a weird beast in Haskell
05:34:33 <Axman6> boegel: you get used to it, and it becomes very natural
05:34:44 <boegel> Axman6: maybe...
05:34:45 <Peaker> maybe just not have break/???  -- and use fst or snd . splitWhere ..
05:34:50 <dolio> The break versions of take/drop are takeWhile and dropWhile.
05:35:08 <dolio> Although, that's span, really, I guess.
05:35:16 <dolio> @src span
05:35:16 <lambdabot> Source not found. There are some things that I just don't know.
05:35:19 <Peaker> @type takeWhile
05:35:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:35:25 <dolio> > span (< 5) [1..10]
05:35:26 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
05:35:32 <vegai> has there been any trouble with ghc 6.10 and forced strictness?
05:35:43 <vegai> I seem to have trouble forcing a string to be evaluated
05:35:48 <Peaker> oh, right, so its span to -> (takeWhile, dropWhile)
05:35:57 <dolio> Yeah.
05:36:01 <Peaker> @type break
05:36:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:36:08 <Axman6> i believe that's how the h98 report defines it
05:36:09 <Peaker> > break (< 5) [1..100]
05:36:10 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
05:36:11 <dolio> break p = span (not . p)
05:36:16 <Axman6> @src span
05:36:16 <lambdabot> Source not found. Just try something else.
05:36:29 <SyntaxRebel> nikki93: yes all 8 volumes of it :P
05:36:41 <Peaker> dolio: that's confusing, IMO
05:36:59 <Peaker> dolio: its better that the caller do the not, the function name does not convey it well
05:37:03 <SyntaxRebel> woops didnt realise i was up the scrollback, nm :D
05:38:13 <Badger> :t 1
05:38:14 <lambdabot> forall t. (Num t) => t
05:38:24 <Badger> dur.
05:38:27 <boegel> ok, here's what I'm seeing...
05:38:47 <boegel> I'm reading the contents of a file with hGetContents (which is lazy, I know)
05:39:11 <boegel> I'm doing this in a function which simply takes a Handle, and returns a list of lines, i.e. [String]
05:39:22 <boegel> the weird thing is, if I simply do
05:39:32 <boegel> c <- hGetContents
05:39:37 <boegel> return $ lines c
05:39:51 <boegel> then something goes wrong (the content doesn't seem to be read correctly)
05:40:03 <lilac> can you be more specific?
05:40:08 <Peaker> its weird that in an interview, one of the authors of Real World Haskell praised lazy I/O as a great advantage of laziness, where in #haskell people hate Lazy I/O...
05:40:09 <boegel> but, if I add 'mapM putStrln (lines c)' in between, then it just works
05:40:18 <vegai> looks like i need deepSeq
05:40:35 <Axman6> Peaker: i've never heard of people hating lazy IO
05:40:40 <jeffz`> me either
05:40:45 <lilac> Axman6: Oleg doesn't like it
05:40:47 <Peaker> is quicksilver here?
05:40:56 <boegel> lilac: well, the content should be 547 lines, but it's only reporting 50 (and it crashing when reading another file because the format doesn't match what the tool is expecting)
05:40:57 <nikki93> Peaker: He is.
05:40:57 <benmachine> > [-1, 0]
05:40:59 <lambdabot>   [-1,0]
05:41:01 <Axman6> lilac: yeah but he knows better than we do
05:41:04 <nikki93> benmachine: Why?
05:41:05 <Peaker> lazy I/O brings back magic happening upon evaluation
05:41:09 <lilac> Axman6: indeed ;-)
05:41:20 <boegel> I understand that the mapM will enforce evaluation, but why doesn't it work without the mapM call?
05:41:20 <Peaker> and kills proper error handling
05:41:27 <quicksilver> Axman6: it is the most evil despicable thing in the world
05:41:27 <Axman6> dons likes it, it's good enough for me :P
05:41:31 <nikki93> Who's Oleg?
05:41:37 <vegai> Axman6: I don't hate it, but it *is* making my life slightly more irritating right now.
05:41:38 <benmachine> nikki93: because you can't do 1 + -1 and I wasn't sure how negation was handled
05:41:40 <Axman6> nikki93: get out now!
05:41:47 <quicksilver> Axman6: I would rather saw off my own legs with a wooden spoon soaked in salt water than use lazy IO
05:41:48 <lilac> boegel: you're saying that "return $ length (lines c)" returns 50?
05:41:51 <quicksilver> Axman6: happy now?
05:41:53 <Twey> Peaker: I use lazy IO :-P
05:42:01 <Axman6> quicksilver: no :(
05:42:09 <quicksilver> the worst thing about lazy IO is the name "lazy"
05:42:13 <Twey> Haha
05:42:14 <lilac> lazy IO is a leaky abstraction
05:42:19 <quicksilver> laziness is one of the most beautiful things in haskell
05:42:25 <quicksilver> this interleaved IO is one of the ugliest
05:42:26 <skorpan> whoa, i'm upgrading ghc now... should i expect major breakage?
05:42:32 <lilac> if you couldn't tell the IO were lazy, it'd be fine
05:42:37 <quicksilver> to use the same adjective for both is an affront to dictionary writeres.
05:42:40 <Twey> It is, but it's a useful one so long as nothing nasty happens to the files in the interim
05:42:41 <nikki93> Axman6: ?? Why out
05:42:47 <boegel> lilac, I'm saying that the (pure) function that uses the results of the read-function is yielding different results, while it should be getting the same input, regardless of using mapM or not
05:42:55 <Axman6> because you don't know who Oleg is!
05:42:58 <boegel> lilac: let me try and write up a small test tool
05:43:04 <vegai> as in, I'm sending xml to a socket, but the whole xml is produced lazily
05:43:18 <vegai> so if there's an error in producing it, part of the data gets sent anyway
05:43:24 <vegai> and I'm afraid the receiving end doesn't handle it well
05:43:27 <Axman6> you're not allowed to start the haskell journey until you have walked to Oleg and kissed his foot!
05:43:43 <nikki93> Axman6: Use 'nikki: ' in your messages. irssi highlits 'em for me.
05:43:51 <nikki93> Axman6: Oleg... Is... Haskellgod?
05:44:08 <vegai> so it'd be nice if the xml was generated completely before sending anything. But neither seq nor bang patterns seem to do it
05:44:16 <Axman6> nikki93: i'm aware, i've been using irssi for a while ;)
05:44:18 <kiris> God is an Oleg-fearing god
05:44:30 <nikki93> Oleg Lobachev?
05:44:55 <dolio> Kiselyov.
05:45:02 * pozic believes more people know his domain than his last name :)
05:45:11 <aleator> vegai: demanding rnf?
05:45:26 <Twey> nikki93: http://arcanux.org/lambdacats/type-woes.jpg
05:45:49 <quicksilver> vegai: generating to a bytestring might be nice, and gives you strictness for free
05:45:52 <Axman6> i think that ByteString's lazy IO is possibly more useful than normal lazy IO, but not by much
05:45:57 <quicksilver> vegai: otherwise length s `seq` s will probably do.
05:45:58 <Twey> That's as may be, but it auto-completes 'nikki93'.  :)
05:46:05 <quicksilver> Axman6: it hides more bugs (which is worse)
05:46:20 <Axman6> being able to read massive files efficiently has to be useful...
05:46:24 <quicksilver> Axman6: with normal lazy IO if you make a mistake you probably get a bug on the second byte, or something.
05:46:38 <quicksilver> Axman6: with bytestring lazyIO you don't get that mistake until the second chunk
05:46:46 <quicksilver> and maybe your test corpus doesn't have any examples that long ;)
05:46:46 <Twey> Eh
05:46:48 <Axman6> :\
05:47:00 <nikki93> WHO THE HELL IS OLEG?!?!??!one one
05:47:05 <Twey> main = interact reverse
05:47:06 <nikki93> (- noise)
05:47:15 <boegel> lilac: crap, a small test case seems to be working...
05:47:20 <Axman6> i haven;t used it, so i'm not sure what's what with it all
05:47:21 <boegel> lilac: typical :)
05:47:23 <quicksilver> @go oleg haskell
05:47:25 <lambdabot> http://okmij.org/ftp/
05:47:25 <lambdabot> Title: This FTP site
05:47:28 <quicksilver> nikki93: that.
05:47:40 <Peaker> nikki93: (subtract noise)
05:47:53 <nikki93> Oleg is a person?
05:48:00 <Axman6> bah!
05:48:01 <nikki93> Peaker: ;-)
05:48:03 <Axman6> hardley
05:48:04 <earthy> yes
05:48:18 <nikki93> He comes on #haskell?
05:48:28 <quicksilver> I've never known him IRC>
05:48:40 <Axman6> basically, if there's anything i haskell that blows moderately confident haskell user's minds, Oleg probaby wrote it
05:49:23 <ehird> If he came in to #haskell, we would all die.
05:49:25 <ehird> Of awesome.
05:49:30 <nikki93> Oh my.
05:49:31 <Axman6> indeed
05:49:35 <ehird> Oleg does not want us to die. He only wants to break our minds.
05:49:37 <nikki93> I read some C++ code and couldn't read it.
05:49:42 <Axman6> there's a permanent ban on Oleg in #haskell
05:49:45 <ehird> nikki93: That is not an uncommon problem.
05:49:48 <nikki93> Your haskell spoilt my C++ knowledge! Noooooooooooo...
05:49:52 <Axman6> as a sign of respect
05:49:55 <h0tzenpl0tz> hi, could you tell pls why fst and snd are strict functions? fst (1,undefined) = 1 - so it is non-strict, isn't it?
05:50:17 <lilac> h0tzenpl0tz: f is strict iff f _|_ = _F_
05:50:21 <lilac> s/_F_/_|_
05:50:31 <lilac> fst _|_ = _|_ so fst is strict
05:50:44 <nikki93> But I forgot C++! You guys and your haskell made me forget C++! :(
05:50:47 <nikki93> WTF?
05:50:53 <Axman6> good!
05:50:58 <Raevel> nikki93: this is a great day to be alive?
05:51:02 <Axman6> it's a shitty, good for nothing lowlife language
05:51:05 <Twey> Hehe
05:51:08 <Axman6> s/lowlife/lowlevel?
05:51:11 <Peaker> lilac: so f x = error "bottom!" is strict on x? :)
05:51:16 <quicksilver> h0tzenpl0tz: strict has both a "precise" meaning, and a "comparative" meaning.
05:51:17 <nikki93> Axman6: But you can't do anything with haskell, right?
05:51:19 <quicksilver> Peaker: yes.
05:51:21 <Twey> Peaker: Indeed
05:51:22 <h0tzenpl0tz> lilac: thanks alot
05:51:25 <lilac> Peaker: that's the definition :-)
05:51:27 <nikki93> s/you/anyoneingeneral/
05:51:28 <Peaker> why is it defined this way?
05:51:31 <h0tzenpl0tz> quicksilver: comparative in which sense?
05:51:35 <quicksilver> h0tzenpl0tz: the "precise" meaning is that f _|_ = _|_
05:51:39 <Axman6> nikki93: you need to learn more haskell
05:51:46 <quicksilver> h0tzenpl0tz: the comparitively meaning is when you say "f is more strict than g"
05:51:53 <Twey> nikki93: 'one'
05:52:00 <h0tzenpl0tz> quicksilver: which means fst is less strict than id?
05:52:01 <quicksilver> h0tzenpl0tz: and then you mean 'f examines slightly more of its arguments than g'
05:52:04 <Twey> And yeah.  :)
05:52:06 <Spark> write me a cache-friendly lock-free micro-optimised hash table library in haskell
05:52:14 <lilac> Peaker: if f is strict, then the implementation can evaluate its argument before calling it if it so wishes
05:52:15 <nikki93> I'm going to stop learning haskell new because I'll forget C++ if not. :(
05:52:17 <nothingmuch> can cabal install be made to pass --hoogle to haddock?
05:52:17 <nikki93> I'm scared.
05:52:18 <Twey> Learn you a Haskell!
05:52:24 <quicksilver> h0tzenpl0tz: fst is less strict than it might be, certainly
05:52:27 <Peaker> lilac: ah
05:52:28 <Axman6> Spark: i dunwanna
05:52:29 <nikki93> Will learnging a language make one forget another he's already learnt?
05:52:31 <quicksilver> h0tzenpl0tz: it doesn't read the second argument.
05:52:44 <Spark> nikki93: no, learn both
05:52:46 <baaba> nikki93, only if you stop using the earlier one
05:52:50 <Spark> nikki93: and then compare
05:52:52 <quicksilver> h0tzenpl0tz: so, fst is less strict than stupid_fst (a,b) = b `seq` a
05:52:54 <Twey> nikki93: Not unless he hasn't learnt the original language very well in the first place.
05:52:56 <Peaker> nikki93: no, but you will write Haskell code in your C++ code, accidentally, sometimes :-)
05:52:56 <Spark> even if you do stop, as soon as you start again it will come back
05:52:58 <h0tzenpl0tz> quicksilver: but its nevertheless strict as the tuple may be _|_ itself, so _|_ is returned?
05:52:58 <Axman6> nikki93: there's a good chance learning haskell will make you a better c++ programmer
05:53:05 <h0tzenpl0tz> quicksilver: thanks ;)
05:53:11 <quicksilver> h0tzenpl0tz: Yes. It's strict in the "Absolute" sense.
05:53:20 <h0tzenpl0tz> great, thank you all!
05:53:21 <quicksilver> h0tzenpl0tz: but you could imagine a (stupid) fst which was even stricter.
05:53:25 <nothingmuch> nikki93: the more languages you know the easier it is to learn new ones in general
05:53:35 <Spark> i find that it's only the stupid things i confuse when switching between languages -- like whether to use != or ~=, and whether a ; is needed at the end of the line
05:53:39 <quicksilver> the absolute sense of "strict" is the least strict of all the relative senses ;)
05:53:41 <h0tzenpl0tz> quicksilver: yes, got that stupid-version
05:53:43 <lilac> maximally_strict_fst _ = error "fst"
05:53:45 <Twey> stupidFst (a, b) = b `seq` a
05:53:46 <kiris> Axman6: also a good chance it will ruin your programming in every other language
05:53:55 <nikki93> Spark: I... am a c++ programmer already.
05:54:06 <Spark> nikki93: then you only need to learn 1
05:54:20 <nikki93> But really. Will leraning haskell spoil anything for me? I want to do c++ too.
05:54:24 <Spark> no
05:54:25 <lilac> nikki93: i should warn you, learning Haskell will make you enjoy C++ less.
05:54:31 <quicksilver> nikki93: it will make you hate C++ in time ;)
05:54:33 <Peaker> quicksilver: without "seq", is it possible to have a stupidFst?
05:54:34 <nikki93> Damn.
05:54:38 <nikki93> I'm gonna stop.
05:54:39 <nikki93> :P
05:54:48 <Axman6> C++ is for noobs
05:54:48 <nikki93> where stop = stop learning haskell
05:54:52 <quicksilver> Peaker: only by specialising the type.
05:54:59 <Peaker> tell nikki93 the truth -- Haskell makes other languages feel less fun :(
05:55:08 <Axman6> if it takes more than 7 characters to do parallel evaluation, then it's crap!
05:55:08 <lilac> Peaker: there are other ways of introducing strictness (which largely desugar to seq)
05:55:09 <Twey> That's because they are less fun
05:55:11 <quicksilver> stupid_fst a b = case b of True -> a; False -> a;
05:55:24 <Peaker> Twey: I mean, relatively to what they were before knowing Haskell
05:55:26 <Twey> But I manage to derive a sort of 1337-h4xx0r feeling from C(++) anyway
05:55:30 <baaba> c++ is for a fairly small set of problems where no practical alternative exists
05:55:31 <Twey> It's like going back in time
05:55:39 <Twey> baaba: No, that's C
05:55:42 <nikki93> I'm scared. I write a lot of stuff in C++, and I can't leave that
05:55:45 <Twey> (until BitC is out)
05:55:46 <quicksilver> C++ is very powerful, and like a good puzzle game.
05:55:49 <baaba> no it's not
05:55:52 <quicksilver> when you manage to do something really clever with C++
05:55:52 <Spark> it is
05:55:58 <jeffz`> nikki93: why can't you leave that if you can do the same in Haskell?
05:56:00 <baaba> C++ is alwayspreferable to C
05:56:01 <Spark> c++ is really for advanced programmers only
05:56:01 <quicksilver> you feel the same satisfaction as solving a hard puzzle.
05:56:05 <baaba> +space
05:56:07 <Twey> baaba: C++ doesn't really have any practical use
05:56:20 <kiris> <general statement about a programming language!!1>
05:56:23 <lilac> Twey: /all/ C++ has is practical use. what it lacks is theoretical use. ;-)
05:56:25 <Spark> you won't be able to take advantage of the benefits of c++ unless you know quite a lot about programming language implementation and machine architectures
05:56:27 <Twey> If performance is vital, C (or assembly) should be used instead
05:56:27 <quicksilver> baaba: unless you need, say, an ABI, or portability.
05:56:31 <Spark> you may as well use java otherwise
05:56:33 <Peaker> baaba: C++ has so many pitfalls.. I'd rather teach coworkers how to use C properly than even attempt to teach them how to avoid C++'s pitfalls
05:56:40 <Twey> If not, a sane language should be used instead :-P
05:56:49 <lilac> Twey: no, if performance is vital, slower c++ constructs should be avoided
05:56:56 <Axman6> Twey: why not haskell +ffi huh?
05:56:58 <Twey> lilac: That's what I just said
05:56:59 <kiris> nikki93: Read SICP.
05:57:07 <nikki93> Spark: I really use C++ to do stuff. www.grall.uni.cc is (the website of) a game I wrote with it.
05:57:12 <Peaker> baaba: the benefits of C++ over C are not that great -- C is a little more cumbersome at vtables
05:57:13 <Axman6> watch the SICP lectures!
05:57:14 <Twey> Axman6: That's a sane language.  :)
05:57:29 <nikki93> Axman6: Exaclty! I was thinking of using FFI and Haskell for using haskell as a scripting language for games.
05:57:30 <lilac> Twey: that's not the same. most C++-but-not-C constructs are not slow
05:57:34 <Spark> Peaker: and templates, and operator overloading, and streams, and ...
05:57:37 <baaba> Peaker, that just shows you don't really know c++ :P
05:57:44 <Axman6> nikki93: that's a stupid use of haskell
05:57:52 <Axman6> it's not a scripting language :(
05:58:04 <nothingmuch> *cry*
05:58:12 <Spark> nikki93: this is what i wrote in c++ http://spark.woaf.net/bullet/evo.avi
05:58:16 <Peaker> baaba: I knew C++ about 7 years ago. I haven't used it since. I avoid the more "advanced" features because of the many pitfalls you have to remember to use them. The only feature that is good is vtables :)
05:58:24 <baaba> i recently wrote some image processing code in c++ that needs to run on handheld devices using little memory and performance
05:58:34 <Peaker> Spark: C++ Templates are pretty horrible and bloat the code out of all caches :(
05:58:34 <nothingmuch> Peaker: and even those are disabled by default =P
05:58:39 <boegel> lilac: I think the reason for my problem is an early hClose
05:58:41 <baaba> because it needs to run along with other stuff
05:58:46 <baaba> Peaker, incorrect
05:58:47 <nothingmuch> you know you failed at OO if polymorphism is not the default
05:58:54 <Peaker> baaba: what part is incorrect?
05:58:55 <quicksilver> boegel: that sounds likely.
05:58:55 <baaba> your knowledge from 7 years ago is completely outdated
05:58:58 <lilac> boegel: that'd do it. welcome to the club of lazy-IO-sucks
05:58:59 <Spark> Peaker: both parts
05:59:01 <Axman6> i'll probably get stabbed, but i don't find java to be all that bad of a language
05:59:02 <nothingmuch> it's also very sad that the compiler can't decide to remove 'virtual' for you
05:59:03 <baaba> compilers have advanceda huge amount
05:59:04 <boegel> lilac: but then I'd expect a runtime failure because the handle is lost too early
05:59:08 <kiris> the best thing about C++ is that WebKit is written in it. the worst thing about C++ is that WebKit is written in it
05:59:11 <nothingmuch> instead of having it the other way around
05:59:21 <Peaker> baaba: Do compilers not expand templates into _huge_ code macros that duplicate code even for identical cases?
05:59:21 <quicksilver> baaba: don't make assumptions about what other people know, especially in this channel.
05:59:51 <baaba> Peaker, compilers can eliminate said duplication of code
05:59:54 <lilac> Peaker: no. identical cases are (usually) coalesced (unless inlined)
06:00:03 <nikki93> Does haskell need OO/classes/whutevah?
06:00:04 <Spark> and inlining is only done if it's a good idea
06:00:08 <Axman6> @remember quicksilver don't make assumptions about what other people know, especially in this channel.
06:00:08 <lambdabot> I will remember.
06:00:09 <baaba> see for example msvc's identical comdat folding
06:00:16 <quicksilver> nikki93: In many people's opinion, no.
06:00:16 <Twey> Axman6: Compared to C++, maybe
06:00:19 <nikki93> @faq can haskell OO?
06:00:19 <Twey> nikki93: No
06:00:20 <lambdabot> The answer is: Yes! Haskell can do that.
06:00:20 <Peaker> baaba, lilac: I think I'd still prefer the C approach of passing around a size parameter or such
06:00:22 <Spark> in this channel, you can't assume any knowledge at all :)
06:00:23 <lispy> nikki93: it can simulate them, there have even been papers on the subject
06:00:28 <Twey> Object = state + methods on that state
06:00:36 <nikki93> Twey: Yes, can it?
06:00:37 <lilac> nikki93: haskell generally leads to different designs which don't use such functionality.
06:00:38 <baaba> Peaker, i recommend you check out adobe's GIL (generic image library)
06:00:39 <nothingmuch> Saizan_: you mentioned hoogle's db earlier... is there any way to get it built apart from ./Setup.hs haddock --hoogle? particularly using cabal install?
06:00:45 <Twey> In a functional language, object are not very useful
06:00:47 <Twey> objects**
06:00:48 <baaba> i wrote my image processing code using it
06:00:51 <kiris> Twey: value = mutible object
06:00:56 <nothingmuch> Twey: purely functional objects exist
06:01:04 <Peaker> baaba: That would mean I spend more time learning about C++, when I can spend it learning more about Haskell stuff, why would I do that? :-)
06:01:06 <Twey> nothingmuch: But they're just namespaces
06:01:08 <lilac> Peaker: the c++ approach in this particular case is often significantly faster ;-)
06:01:12 <baaba> one can write code that is muchmore terse than the corresponding handwritten C code and at least as fast
06:01:15 <Spark> you can talk and talk and talk about the relative merits of subtype/parametric polymorphism, and whether it's worth combining them, and how to combine them effectively
06:01:26 <nothingmuch> Twey: not necessarily, you can have a monad for "the world" much like the state monad
06:01:30 <nothingmuch> in which your objects interact
06:01:38 <Twey> nothingmuch: You mean IO?  :)
06:01:40 <Twey> Or ST?
06:01:41 <Peaker> lilac: everywhere I read that the main performance bottleneck these days is ram cache misses, rather than computation or such.. the size passing approach should probably fit better in cache?
06:01:44 <Saizan_> nothingmuch: you can use cabal haddock --hoogle, but i've found that databases generated like so don't include links to the haddock documentation, even if hoogle --info gives you the information
06:01:48 <boegel> k, let's say the function I described earlier is called readLines (uses lines and hGetContent to obtain the file content line-wise)
06:01:57 <Axman6> Twey: i discovered ST the other day, it's lovely :)
06:02:06 <Twey> Hehe, that it is
06:02:12 <boegel> what should happen if I use "(h:ls) <- readLines handle" in another function?
06:02:17 <lilac> Peaker: depends whether you're applying the 'same' algorithm to different data structures a lot. if not, the code with the 'size' parameter compiled down to a constant is probably smaller.
06:02:30 <boegel> I'd get the first line bound the "h", and all the others lines bound to "ls", right?
06:02:34 <quicksilver> boegel: don't hClose until you know all the lines have been consumed.
06:02:44 <quicksilver> boegel: possibly, don't bother to hClose ever.
06:02:55 <pozic> The wonders of the web: http://holumbus.fh-wedel.de/hayoo/hayoo.html
06:02:58 <Twey> I think lazy IO is only worthwhile at the top level
06:03:02 <boegel> quicksilver: that'll cause problems, because I'm opening loads of files
06:03:10 <Spark> Peaker: of course trying to build a cache friendly algorithm with a lazy language is much more challenging
06:03:12 <pozic> You will only get what I said if you visit the URL.
06:03:13 <Peaker> baaba: The exception specifications in C++ are braindead, IMO, and make exceptions and thus constructors and other functions (that can only throw to raise errors) almost useless
06:03:15 <Peaker> baaba: The pitfalls like (If you define copy constructor, you must also define a duplicate assignment operator, without warning from compiler) also ruin C++ for me
06:03:16 <quicksilver> boegel: then I recommend you don't use interleaved getContents.
06:03:19 <nothingmuch> Twey: OO is not just about state, it's about polymorphism, encapsulation, and a certain style of code reuse as well
06:03:20 <Peaker> baaba: These are not inherent, why should I use a language that has serious non-inherent flaws?
06:03:23 <quicksilver> boegel: it's a nightmare of manually working out where to close.
06:03:25 <Spark> Peaker: you really need direct access to memory layout to do such things
06:03:29 <quicksilver> boegel: and I don't think it's a fun game to play.
06:03:32 <boegel> I've tried strict IO, using hGetLine, but it's bloody sloooooow :(
06:03:39 <Badger> Peaker!
06:03:41 <baaba> Peaker, i agree exception specifications were a mistake and should be abolished
06:03:47 <quicksilver> boegel: use a strict getContents.
06:03:54 <nothingmuch> Twey: c.f. http://lambda-the-ultimate.org/node/3040
06:04:03 <baaba> Peaker, and for things like that there are many code analysis tools
06:04:04 <nothingmuch> and MO in hackagedb
06:04:05 <lilac> Peaker: yeah, exception specifications were a mistake. they should have been checked at compile-time not at run-time.
06:04:14 <nothingmuch> and http://www.cs.chalmers.se/~nordland/ohaskell/
06:04:15 <Spark> i never actually use those in c++
06:04:16 <baaba> iirc g++ can check for that for example
06:04:23 <baaba> in its effc++ mode
06:04:29 <boegel> @type getContents
06:04:30 <lambdabot> IO String
06:04:31 <Spark> i don't think they help performance
06:04:33 <baaba> and if not g++ then lint )
06:04:33 <kiris> Liskell is out for GHC 6.10. anyone tried it?>
06:04:36 <baaba> :)
06:04:45 <nothingmuch> oh and http://homepages.cwi.nl/~ralf/OOHaskell/
06:04:46 <boegel> shouldn't that be Handle -> IO String or something like that?
06:04:58 <nothingmuch> which is normal HS IIRC, as opposed to O'Haskell
06:04:58 <baaba> this is a QOL issue though
06:05:11 <quicksilver> boegel: hGetContents, that's not the point.
06:05:16 <Peaker> lilac: I think that ruins exceptions for me in C++
06:05:21 <quicksilver> boegel: the point is, use a strict variant.
06:05:25 <Peaker> lilac: and without exceptions, how can I do stuff that may fail inside constructors?
06:05:30 <baaba> peaker, nobody uses exception specifications
06:05:32 <kiris> the one thing I miss about lisp is the ability to make new binding constructs
06:05:35 <Peaker> lilac: so without constructors, what use are classes?
06:05:39 <lilac> Peaker: there are workarounds (but not that pretty)
06:05:44 <boegel> quicksilver: and where can I find a strict variant?
06:05:54 <quicksilver> boegel: strict bytestring perhaps.
06:05:55 <Peaker> lilac: Eventually, I feel the whole of C++ comes tumbling down over silly design mistakes like that
06:06:15 <lilac> Peaker: trouble is, due to its market share, C++ is forcibly placed at a local optimum
06:06:20 <Peaker> baaba: well, C++ with checked exceptions might be a far better language
06:06:24 <boegel> quicksilver: there simply is no strict alternative to hGetContents?
06:06:24 <baaba> the exception specification issue is neatly avoided by simply not using them
06:06:27 <quicksilver> if you don't feel like using bytestrings then http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
06:06:34 <quicksilver> boegel: there simply is not. It's diabolical.
06:06:35 <Peaker> baaba: then you get dynamism in a static language
06:06:39 <Peaker> baaba: the worst of both worlds
06:06:43 <pozic> kiris: why wouldn't you be able to make new bining constructs?
06:06:54 <pozic> kiris: binding*
06:07:04 <baaba> Peaker, like bottom in haskell? :)
06:07:10 <boegel> quicksilver: wtf? :) strange
06:07:56 <Peaker> baaba: bottom is indeed a flaw, but its inherent in turing completeness.. the C++ flaws are not inherent
06:08:57 <kiris> pozic: consider this problem: `do foo <- value; case foo of ... -> ...' let's say I don't want to bind the return of value to anything, maybe I just want to pattern match it immediately
06:08:58 <Spark> they're also not that important
06:09:00 <Peaker> my connection to freenode is really flaky :-(
06:09:22 <kiris> pozic: maybe I just want to write: do case value; ... -> ...
06:09:46 <Peaker> baaba: C++ is so deeply flawed with flaws that may only be inherent to a language with so much historic baggage.. but what does that historic baggage buy me, except a lot of misinformed programmers who think they know the language, and non-idiomatic libraries I can't use anyway?
06:09:50 <pozic> kiris: oh, I thought you were talking about Lisp.
06:09:57 <baaba> i don't really consider unchecked exceptions a flaw though, they have practical use and keeping code exception safe is a good practice regardless of the presence of any exceptions
06:09:59 <Spark> try writing the latest blockbuster game in haskell and see how far you get
06:10:00 <kiris> pozic: I'm saying that's what I miss about lisp
06:10:14 <pozic> kiris: you can do the same with template haskell.
06:10:50 <kiris> pozic: not /really/ the same
06:10:56 <jeffz`> Spark, what are you suggesting the limiting factor is in writing "the latest blockbuster game" in haskell?
06:11:03 <baaba> Peaker, it buys you performance, low memory use and platform support
06:11:20 <baaba> Peaker, certainly, i would not use c++ for every task
06:11:25 <baaba> not even a majority of tasks
06:11:26 <Peaker> baaba: The historic baggage? I disagree -- if C++ was not on top of C, you'd have all those
06:11:27 <pozic> kiris: the difference is that in Haskell when you want to call a macro it is spellt $(macro ) instead of (macro )
06:11:44 <Spark> jeffz`: i believe baaba just listed some
06:11:53 <Peaker> baaba: If C++ was D in the first place (except D has a few annoying quirks as well, which I also consider historic), it would still be fast, low memory use, etc
06:12:17 <Spark> jeffz`: in fact those 3 things are probably the most important differences between programming languages, as you cannot hide them from the user
06:12:25 <baaba> oh sure, but if C++ was D then there would be no support for C++ across platforms
06:12:30 <lispy> I don't mean to be rude, but should we really be having another language debate about C/C++ et al?  Let's discuss some Haskell, shall we?
06:12:37 <baaba> because it would never have been adopted as much
06:12:51 <blackh1> While we're C++-bashing, check this out: http://hpaste.org/14085  This my favourite example of why C++ is a ridiculous language.
06:13:31 <baaba> but anyway let's say i'm doing a game for a nintendo ds, or the earlier-mentioned image processing where i have to keep my resource usage in check on a handheld device
06:13:32 <Peaker> blackh1: with -Wall and various warning options it would warn you, though
06:13:50 <pozic> blackh1: even I can understand why that fails.
06:13:58 <baaba> if i could use haskell for either of those practically speaking, i definitely would
06:14:01 <kiris> pozic: once is standard and regular, the other is nonstandard, has problems with profiling, and is ugly
06:14:11 <Spark> blackh1: it helps if you pay attention to the compiler warnings
06:14:21 <Peaker> baaba: I'd choose C over C++ or D, personally. I agree C is far from ideal, but I prefer the limitations over the flaws
06:14:22 <blackh1> Peaker: With -Wall it *doesn't warn you*
06:14:32 <lispy> blackh1: So would you use that to also say that haskell is silly because you can do let x = x in x?
06:14:38 <Peaker> blackh1: right, but there are more warning flags that make it warn you :)
06:14:40 <lispy> > let x = x in x
06:14:44 <Spark> test10.c++:7: warning: unused parameter ‘nme’
06:14:48 <Spark> looks like a warning to me
06:14:55 <lambdabot>   thread killed
06:14:59 <nothingmuch> -Wall-except-that-one-edge-case
06:15:02 <Peaker> baaba: C, with a bit of code generation, facilitates abstract mechanisms quite well.. there are alternatives to templates, and vtables give you all the "OO" aspect you'd want, etc
06:15:10 <baaba> Peaker, and yet C++ has so many useful features over C that i definitely prefer it
06:15:14 <Peaker> I don't know why -Wall does not really enable all
06:15:30 <Spark> because some were added -Wall was put in
06:15:31 <baaba> using manual vtables in C is incredibly painful
06:15:38 <Peaker> baaba: I disagree
06:15:51 <Spark> it's easy to put function pointers in structs, but then you bloat and waste memory
06:15:54 <Peaker> its perhaps 4 extra lines per method, over the C++ version
06:15:56 <Spark> try doing virtual multiple inheritance in c
06:16:17 <blackh1> lispy: let x = x in x goes predictably into an infinite loop. My C++ example crashes randomly corrupting everything in sight.
06:16:24 <Peaker> Spark: "inheritance" is a bad idea in general, IMO.  I think of vtables as implementing type-classes :)
06:16:32 <baaba> also templates add a huge amount of flexibility to performance-critical spots
06:16:36 <Peaker> Spark: not inheritance
06:16:50 <lispy> blackh1: both are bottom
06:16:56 <Spark> yeah template specialisation is extremely useful
06:16:57 <baaba> you can have very general library classes that have functionality parameterized through template parameters rather than virtual functions
06:17:08 <Spark> much better than the macro hacks you do in c
06:17:21 <Peaker> baaba: and it is duck-typed at compile-time :-(
06:17:31 <Spark> i actually prefer that
06:17:35 <Spark> it's safe and flexible
06:17:37 <baaba> aside from error messages, what's bad about that?
06:17:40 <joma> where is the state monad?
06:17:46 <kiris> joma: Control.Monad.State
06:17:53 <baaba> error messages are definitely painful there, but there are ways to alleviate that
06:17:56 <kiris> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
06:18:12 <Peaker> baaba: what ways to alleviate that are there?
06:18:37 <baaba> concept checking - it's a bit of a hack but the client code is very readable once you know what it means
06:18:52 <baaba> forcing instantiation errors early instead of late, essentially
06:18:55 <Spark> the main problem with error messages is compilers that don't remember the original typedefs
06:19:10 <Peaker> baaba: concept checking is in C++ compilers?
06:19:11 <baaba> which means you get the errors up front as opposed to fifty instantiations deep in some member function somewhere
06:19:14 <Spark> oh, and the stupid syntax ambiguities are annoying
06:19:31 <baaba> Peaker, it can be implemented as a library feature in c++03
06:19:43 <baaba> (and c++98, which is pretty much the same as c++03)
06:19:59 <Peaker> baaba: I always hear of template concepts as something that will be there in the future?
06:20:10 <baaba> yes, there will be language support in c++10
06:20:26 <baaba> so they will be cleaner and more tool friendly
06:20:28 <joma> instance Show (CMS.State t) where
06:20:28 <joma>     show t = print t
06:20:32 <joma> how do i do?
06:20:38 <Spark> c++ is really moving forward in an amazing way, when you consider how hard it is for it to move at all
06:20:39 <pozic> The problem with C++ implementations is that the compiler is a big pile of mud and that it is not easy to extend it. GHC is at least trying to solve that with the GHC API.
06:20:43 <Spark> compared to java, for instance
06:21:07 <Spark> java is a clean slate compared to c++ and yet progress is much slower
06:21:12 <baaba> pozic, yeah that's true; i'm eagerly awaiting for clang to get decent c+ support :)
06:21:17 <SamB> baaba: I think he means that they keep getting delayed or something ?
06:21:24 <baaba> c++ even
06:22:05 <baaba> SamB, hmm, well, concepts have been slated for the same standard revision from the start
06:22:14 <dolio> That may be social, more than anything. The 'Java community' seems to have a fairly strong bias against change.
06:22:24 <baaba> ie. the one that will apparently be ratified in 2010
06:22:27 <Spark> dolio: they've been crying out for new features though
06:22:34 <Spark> dolio: i think it's sun that don't want change
06:22:48 <Spark> dolio: which tbh is understandable because the budget is small and the amount of work needed is large
06:22:53 <Axman6> Spark: well i don't there's all that much progress that needs to be made with java. it does what it's supposed to quite well
06:22:53 <baaba> the feature has certainly been discussed for some years now
06:23:06 <dolio> Have they? I mean, I don't follow it much anymore. The last thing I remember was someone proposing first class functions and tons of people shouting them down.
06:23:14 <baaba> yeah, provides a good vm for other languages :P
06:23:26 <Spark> the next java is supposed to have closures
06:23:32 <baaba> it won't
06:23:45 <baaba> at least, that's how it seems from recent discussions
06:23:49 <hugo___> is it possible to put some constraint on the values allowed by a data constructor ?
06:23:56 <hugo___> data Val = Val Int
06:24:00 <Spark> baaba: how recent?
06:24:05 <hugo___> i want it to allow only numbers between 0 and 255
06:24:09 <Axman6> hugo___: no that i'm aware of
06:24:14 <nothingmuch> package source code is not installed by cabal, right?
06:24:17 <dolio> data Val = Val Int8
06:24:20 <baaba> umm, i wonder when i last checked on it, in the past two months or so
06:24:20 <akamaus> hi all. Is there any library for composing svg pictures?
06:24:24 <dolio> Oh, sorry, Word8.
06:24:25 <hugo___> okey, thanks dolio
06:24:27 <hugo___> ok
06:24:35 <dolio> Int8 is -128 to 127.
06:24:35 <Axman6> hugo___: though you could hide the constructor, and force them to be made using a function you write
06:24:57 <Axman6> akamaus: checked hackage?
06:25:04 <hugo___> hmm, i was thinking of that, but it is not neecssary, this is a simple function
06:25:07 <Spark> baaba: hmm i remember they were stressing over various things that i can't remember
06:25:07 <hugo___> thanks Axman6
06:25:14 <Spark> baaba: edge cases, basically, ugliness
06:25:37 <akamaus> Axman6: yes, i only found svg renderer in gtk2hs.cairo
06:26:10 <Axman6> akamaus: well not yet then i guess. there is a proposal for it on the haskell_proposals subreddit
06:26:47 <baaba> Spark, http://www.infoq.com/news/2009/01/java7-updated
06:27:10 <akamaus> Axman6: thanks, I'll take a look
06:27:20 <Axman6> akamaus: there's no code though...
06:27:28 <Axman6> you could make it if you like though :)
06:27:36 <baaba> i'm going to try pushing scala for any jvm projects at work though
06:27:55 <akamaus> Axman6: maybe some ideas and desing at least
06:28:22 <nikki93> Spark: Are you the guy on the #bulletphysics channel?
06:28:41 <joma> what is the reason not to have first class functions?
06:29:25 <dolio> Spark: I won't argue that Sun hasn't cultivated that aspect of the community to some degree, of course.
06:29:53 <Axman6> the hotspot JVM is pretty damn cool though
06:29:55 <mmorrow> this looks like it might be sweet
06:29:57 <mmorrow> data Quote a = UnQ a | Qu (Quote a) | QQu (Quote (Quote a))
06:30:26 <joma> instance Show (CMS.State t) where
06:30:34 <skorpan> ok
06:30:46 <Saizan_> nothingmuch: right
06:30:47 <joma> can someone show me the use of the state monad?
06:31:41 <blackh1> joma: flip execState 1 $ modify (+1)
06:31:46 <Peaker> joma: IMO StateT is pretty useful but the State monad itself is not that useful
06:31:54 <nikki93> mandor`: Its ok, try. :)
06:32:00 <nikki93> Oops wrong channel. :P
06:32:18 <nikki93> Spark: Are you the guy on the #bulletphysics channel?
06:32:24 <Axman6> mmorrow: useful for what?
06:32:40 <Spark> baaba: heh i guess you're right
06:32:50 <Spark> baaba: it's all fairly ridiculous though
06:32:54 <Spark> nikki93: yes
06:33:10 <Spark> dolio: i remember similar stupidity around closures in python or some other similar language
06:33:11 <baaba> i can't say i've had much for java the language from the start
06:33:30 <baaba> erm, much love for
06:33:34 <Peaker> baaba: what do you use C++ for?
06:33:39 <Spark> "every time i use a closure i have to draw a picture to understand it"
06:33:40 <Spark> ^^ fail
06:33:49 <Axman6> i hate it less now i've used it
06:33:52 <Spark> i think that was someone important who said that too
06:34:11 <gal_bolle> @hoogle Read a => String -> Maybe a
06:34:12 <lambdabot> Prelude read :: Read a => String -> a
06:34:12 <lambdabot> Text.Read read :: Read a => String -> a
06:34:12 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
06:34:28 <Axman6> Spark: ha, wow
06:34:28 <Axman6> closues are things like (+5) right?
06:34:30 <baaba> Peaker, as i mentioned earlier, when i'm constrained on resources
06:34:32 <mmorrow> Axman6: i'm not sure exactly in general yet, but in particular it'd be useful for (say) representing the quoted expansion of an expression in an AST
06:34:33 <lilac> > fst . flip runState (0,1) $ let next = do (a, b) <- get; put (b, a+b); return a in sequence (repeat next) -- joma
06:34:35 <Axman6> gal_bolle: see reads
06:34:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:34:38 <baaba> and on somewhat obscure platforms
06:34:40 <Workybob> anyone know where I can get a prebuild binary tree which stores one type at the branches, and another type at the leaves
06:34:42 <Peaker> @src Read
06:34:42 <gal_bolle> thanks
06:34:43 <lambdabot> class Read a where
06:34:43 <lambdabot>   readsPrec    :: Int -> ReadS a
06:34:43 <lambdabot>   readList     :: ReadS [a]
06:34:43 <lambdabot>   readPrec     :: ReadPrec a
06:34:45 <lambdabot>   readListPrec :: ReadPrec [a]
06:34:50 <SamB> Spark: hmm, that sounds more appropriate for "every time I learn a new fold"
06:34:58 <Workybob> i.e. Tree a b = Branch (Tree a b) a (Tree a b) | Leaf b
06:35:16 <baaba> Peaker, i do prefer other languages where possible, but so far there still are places where i'm left with C++ (or C, but i definitely prefer C++)
06:35:19 <Peaker> @hoogle ReadS
06:35:19 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
06:35:19 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
06:35:19 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
06:35:27 <Axman6> lambdabot: that breaks my head a little, i don't know why i find state so hard to grok :(
06:35:29 <mmorrow> Workybob: as in you don't want to write your own?
06:35:37 <Axman6> :t reads
06:35:38 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:35:45 <mmorrow> (i'm not aware of any existing ones in some std lib)
06:35:46 <lilac> Axman6: lambdabot?
06:35:58 <Axman6> > reads "1234,awejd" :: [(Integer,String)]
06:35:59 <lambdabot>   [(1234,",awejd")]
06:36:24 <Peaker> baaba: I see - do your C++ projects involve only coworkers which are very experienced with C++? (I think that's the only way to be even moderately successful with C++)
06:36:48 <Axman6> > reads "1234,awejd" :: [(Double,String)]
06:36:49 <lambdabot>   [(1234.0,",awejd")]
06:36:59 <Spark> baaba: i'm sure it should be possible to create a higher level language than c++, probably around about the java level, while keeping the powerful langugae constructs (in fact adding many more) and also having it typesafe with GC, WHILE keeping the performance you associate with carefully-written c++ code
06:37:25 <Axman6> sounds kinda like C#
06:37:29 <joma> what is the difference between HashTable and Map?
06:37:29 <Axman6> from what i hear
06:37:31 <lilac> Spark: in some domains, GC is a killer all by itself :-/
06:37:35 <baaba> c# isn't any faster than java in general
06:37:35 <mmorrow> i guess this would work for that too (but probably wouldn't make things easier) newtype T a b = T (Either (T a b, T a b) b)
06:37:41 <joma> and how does mutablearrays work? are they not pure then?
06:37:43 <Spark> lilac: you just need to control it
06:37:59 <Spark> and it's very hard to write cache friendly algorithms in c# or java
06:38:07 <Axman6> joma: they're for quite different purposes
06:38:07 <Workybob> mmorrow: as in someone must have written this with a load of useful stuff associated and hackaged it
06:38:08 <Spark> you have to not use objects
06:38:13 <Workybob> it's boilerplate and I cba
06:38:19 <Axman6> joma: STArrays are mutable, and pure
06:38:21 <baaba> Peaker, currently i'm responsible for the whole c+ part i've written (which is not very large)
06:38:24 <Spark> because you can't create an array of objects in contiguous ram like you can in c++
06:38:45 <baaba> Peaker, i'll admit i would be wary of having to work in a team lacking experience witht he language
06:38:45 <hugo___> how do i show a Word8 as an hexadecimal value ?
06:38:54 <Axman6> @hoogle hex
06:38:54 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
06:38:54 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
06:38:54 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
06:38:59 <Spark> you can't have inexperienced programmers working with c++
06:39:01 <Axman6> hmm
06:39:11 <Spark> it would be a nightmare, and you wouldn't even get the performance you were looking for
06:39:17 <baaba> true
06:39:28 <mmorrow> Workybob: very true, but not that i know of. i think it's seen as so common and there being so many minor variations one might need that it's not worth making another Data.Tree (w/ a minor variation)
06:39:34 <baaba> but i would argue that goes with C as well, although there are more people experienced with C than with C+
06:39:37 <blackh1> hugo___: showHex, which is in Numeric
06:39:37 <baaba> C++ even
06:39:45 <hugo___> sweet
06:39:46 <hugo___> :D
06:39:51 <hugo___> i searched in data.word
06:39:51 <Spark> the performance implications of using c features are not that great though
06:39:58 <baaba> my hands seem to be experiencing packet loss; i'm dropping characters here and there
06:40:07 <Peaker> baaba: I've worked on C projects with inexperienced developers.. after 5-10 code review sessions, they wrote to my likings..
06:40:08 <Spark> it's easy to make something virtual in c++, it's much harder to start using function pointers for no reason in c
06:40:14 <Peaker> baaba: I can't imagine that with C++..
06:40:29 <baaba> i can
06:40:30 <Peaker> baaba: very talented people, surely, but not experienced
06:41:05 <Spark> we are in the fun situation of compiling a java-like language to c++
06:41:18 <baaba> that sounds terrible
06:41:22 <joma> how is it with gaming consoles? do you HAVE to code in C++? i mean the API might be in C++ but what stops you from writing a console game in haskell? binaries is binaries right?
06:41:25 <Spark> it is fairly entertaining
06:41:32 <baaba> surely there was a better target choice available, like llvm bitcode?
06:41:40 <Spark> the best bit is the target compilers are awful
06:41:47 <Spark> it needs to run on the cell and bluegene
06:41:56 <baaba> ah heh
06:41:59 <mmorrow> Workybob: but i do want something exactly like that a bunch. maybe that would be a good addition to Data.Tree (something like data Tree2 a b = Leaf b | Node2 a [Tree2 a b])
06:42:05 <Axman6> joma: performance mainly i'd say, plus the tools are probably all C++cetric
06:42:05 <baaba> obscure targets are certainly annoying :)
06:42:50 <lilac> joma: avoiding allocation and controlling your memory HWM is a big deal in games, as i understand it
06:42:52 <scook0> joma: just write your game in UnrealScript ;)
06:42:59 <baaba> Spark, btw, i've been eyeing a very interesting language recently - ATS ( www.ats-lang.org ) which is a rather interesting blend of imperative and functional programming
06:43:02 <Spark> at the moment we're only using gcc since the others can't manage the code but it needs to change
06:43:05 <lilac> joma: that's pretty tricky in a language like Haskell
06:43:13 <baaba> it integrates theorem proving, and compiles to C, doesn't need a GC
06:43:20 <Axman6> Spark: you work with bluegene?
06:43:32 <baaba> i'm looking at it as a replacement for the things i currently use C++ for
06:43:46 <gweiqi> python
06:43:48 <mmorrow> why doesn't it need a GC?
06:43:51 <baaba> it also has the equivalent of templates in c++, although instantiation is not turing complete :)
06:44:12 <baaba> that is, code can be specialized
06:44:24 <baaba> er rather, code generation can be specialized
06:44:26 <dolio> ATS code is certainly ugly enough to replace C++. :)
06:44:31 <baaba> haha
06:44:39 <Spark> baaba: it's a bit reminiscent of cyclone by the looks of it, but more modern
06:44:42 <baaba> yeah it's pretty heavy on punctuation
06:44:50 <baaba> but it has very interesting properties for me
06:44:55 <mmorrow> does it use some sort of region-inference/equiv to try to get around the need for a GC?
06:45:01 <dolio> ATS is way sexier than Cyclone.
06:45:04 <Spark> Axman6: not yet personally
06:45:09 <dolio> Unless I've vastly underestimated Cyclone.
06:45:11 <Axman6> :(
06:45:13 <baaba> mmorrow, linear types and theorem proving
06:45:22 <Spark> it says it has a gc
06:45:29 <baaba> yes, it does, but it's optinal
06:45:31 <Spark> but it seems to have linear types in case you don't want to use it
06:45:32 <baaba> *optional
06:45:32 <Spark> yeah
06:45:44 <Spark> cyclone didn't have a gc at all iirc
06:45:48 <Spark> it just had the regions and linear types
06:45:52 * mmorrow is skeptical of statically being able to make a GC unnecessary
06:46:05 <mmorrow> maybe the linear types are what you need though
06:46:13 <mmorrow> (i've got to read up on those)
06:46:34 <Spark> it just means you keep track of how many times you've aliased it in the types i think
06:46:44 <Spark> so when it gets to 0 you clean it up, and you don't clean it up before then
06:46:47 <dolio> @go lively linear lisp
06:46:52 <lambdabot> http://citeseer.ist.psu.edu/51286.html
06:46:52 <lambdabot> Title: Lively linear lisp -- look ma, no garbage - CiteSeerX
06:46:58 <mmorrow> isn't that just a reference count though?
06:47:07 <Spark> reference counting is at runtime usually
06:47:10 <Axman6> anyone had a look at apple's general purpose GC they use in their Obj-C runtime?
06:47:10 <Spark> this is all erased
06:47:17 <mmorrow> ah, i gotcha
06:47:24 <Spark> i may be imagining / fabricating this information though
06:47:39 <Spark> because as i just described it, it doesn't seem that powerful to me
06:47:53 <Spark> sounds like a pain in the arse to use for all but simple code fragments
06:48:23 <mmorrow> so then there's some restriction about not being able to write code that would never reduce this (erased) ref count?
06:49:03 <Spark> i'm not sure what happens if you assign it to a global variable
06:49:05 <Spark> presumably that's not allowed
06:49:15 <mmorrow> , let f xs = (xs, last xs) in f [0..]
06:49:16 <lunabot>  ([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
06:49:55 <mmorrow> something like that i'm thinking of (assuming that would actually behave how i'm thinking it would)
06:50:26 <mmorrow> i dunno, i've gotta check it out
06:50:41 <Spark> dunno either
06:50:48 <dolio> If xs is linear, then that isn't well typed.
06:51:05 <mmorrow> ah, ok. so the linear types are what makes that tractable
06:51:30 <mmorrow> (that makes the static det of mem usage tractable)
06:51:40 <Axman6> http://www.opensource.apple.com/darwinsource/10.5.5/autozone-77.1/README.html <-- Apple's OSS garbage collector, used in Objective-C and MacRuby (helps a lot with RubyCocoa)
06:51:57 <mmorrow> hmm
06:53:44 <baaba> particularly interesting in ats are things like provably correct pointer arithmetic and other pointer manipulation
06:54:06 <dolio> Linear typing enforces via type checking the same thing that the ST monad enforces by construction.
06:54:08 <baaba> for systems where a lot of functionality is controlled through memory mapped registers
06:54:12 <baaba> like the nintendo ds
06:54:15 <Axman6> ATS looks crazy
06:54:32 <baaba> and quite a bit of specialized hardware in general
06:55:19 <dolio> That is, ST s a = !(State# s) -> (a, !(State# s)), or whatever.
06:55:54 <dolio> Where !a denotes linearity.
06:56:15 <dolio> And it enforces that in \s -> e, s is used exactly once in e.
06:57:10 <lilac> what is linear typing?
06:57:33 <dolio> So you can implement things by mutable update, or free something as soon as it's used.
06:58:34 <joma> whadya think about Lisp(Clojure in particular)?
06:58:37 <pozic> Is there anything that can generate random instances of a certain type class?
06:59:02 <lilac> is linear typing the same as uniqueness typing?
06:59:04 <joma> HWM =?
06:59:09 <lilac> high water mark
06:59:24 <dolio> lilac: Not exactly.
06:59:28 <dolio> It's similar, though.
06:59:35 <joma> but is it forbidden to write in haskell?
06:59:59 <joma> could I deploy a haskell-made game on xbox, dont they have a store for simple games or something?
07:00:15 <drcode> hackell can replace lang like dot.net?
07:00:34 <drcode> I don't understand the concept ?
07:00:39 <Axman6> pozic: Quickcheck has something like thaat, it's pretty easy to use too
07:00:54 <pozic> Axman6: are you really sure about that?
07:01:03 <pozic> Axman6: AFAIK, that only works on the value level.
07:01:17 <Axman6> i guess i didn't understand the question
07:02:13 <drcode> what is the diffrent between hackell and perl,php.python?
07:02:37 <Axman6> haskell is a purely function, lazy, compiled language
07:02:56 <dolio> Haskell has a static type system.
07:03:09 <Axman6> haskell is awesome
07:03:11 <Axman6> >_>
07:03:11 <drcode> I can do with hackell same like I can do in php,perl,python?
07:03:30 <Axman6> depends what you want to do, but probably
07:04:15 <joma> how hard would it be to sell a game via internet, ie a PC-game only?
07:04:43 <Peaker> Hackell heh :)
07:04:54 <sclv_> it's not hard to write a simple game in haskell.
07:05:11 <joma> lol what a question
07:05:13 <Axman6> joma: from what i've read, harder than if it was mac only
07:05:19 <sclv_> writing a fancy game is hard in any language.
07:05:44 <Axman6> joma: from what i've read, harder than if it was mac only*
07:07:18 <h0tzenpl0tz> newtype Angle = MkAngle Float  - why is MkAngle _|_ = _|_ ? the same definition with 'data' is not strict?
07:07:31 <csaba> joma: are you a game developer?
07:08:50 <Saizan_> h0tzenpl0tz: exactly
07:08:55 <Axman6> h0tzenpl0tz: newtypes get removed by the compiler, newtype Foo = Foo Int trns into Int
07:08:56 <fasta> Why is the GHC API hidden by default? I.e., you have to do -package ghc to enable it.
07:09:18 <Saizan_> > Just undefined `seq` ()
07:09:19 <joma> csaba: wannnabe indie game king :P
07:09:20 <lambdabot>   ()
07:09:23 <SamB> fasta: maybe so GHC will build ?
07:09:44 <kiris> I love Schönfinkelisation
07:10:07 <csaba> joma: do you have experience in game developing?
07:10:16 <csaba> *game development
07:10:23 <h0tzenpl0tz> Axman6: so when defined using data MkAngle _|_ is still a proper non-bottom value because the constructor is part-of-the-value?
07:10:35 <Axman6> i think so
07:10:42 <h0tzenpl0tz> thanks alot
07:11:03 <fasta> SamB: wouldn't a flag saying -IWantToBuildGHC (most users don't want this) be better?
07:11:41 <SamB> fasta: or maybe it just doesn't follow good module naming conventions, so they did that to prevent clashes ?
07:11:51 <gal_bolle> @hoogle [Maybe a] -> [a]
07:11:51 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:11:51 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
07:11:51 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:12:20 <h0tzenpl0tz> whats this lambdabot thing?
07:12:41 <sclv_> its just this thing.
07:12:47 <h0tzenpl0tz> hmmk
07:12:48 <elbar> > 2 + 3
07:12:49 <lambdabot>   5
07:12:53 <Saizan_> @help lambdabot
07:12:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:12:55 <h0tzenpl0tz> ah, k
07:12:57 <h0tzenpl0tz> thanks
07:13:43 <quicksilver> fasta: well I think the reason is that at first it wasn't useful for users anyway.
07:14:14 <quicksilver> and you have to hide it when building ghc of course
07:14:21 <quicksilver> so why not hide it by default.
07:14:41 <quicksilver> This reasoning doesn't apply so well now the ghc API is useful, but that's hysterical raisins for you.
07:15:03 <fasta> quicksilver: hysterical raisins :)
07:15:24 <fasta> quicksilver: how do you come up with this stuff? :D
07:15:38 <quicksilver> that one is quite well known. I don't know when it was first coined.
07:15:55 <fasta> http://catb.org/jargon/html/H/hysterical-reasons.html
07:15:55 <Deewiant> http://catb.org/jargon/html/H/hysterical-reasons.html
07:16:14 <quicksilver> jargon file sucks : no information of first known citation ;)
07:16:20 <mmorrow> does anyone know if gwern has any code published for the stuff he was doing to gitit?
07:17:05 <joma> how do I take all odd-indexed elems out of a list?
07:17:09 <fasta> quicksilver: The Bible doesn't do citations either and surely you wouldn't want to say that in <insert city in Texas> ;)
07:17:34 <Deewiant> map snd . filter (odd.fst) . zip [0..]
07:17:50 <mak__> I've heard about port from hs-plugins to ghc-api it is true? when code can be found?
07:18:36 <nothingmuch> i think i'm not understanding mergeIO, shouldn't its type be [a] -> [b]
07:18:45 <mmorrow> mak__: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
07:18:46 <nothingmuch> bah, confused
07:18:56 <Peaker> what is "gitit"?
07:18:58 <fasta> Does anyone know how to enable tab completion in ghci when running inside Emacs with Haskell-Mode?
07:19:13 <nothingmuch> Peaker: i think it's a wiki
07:19:36 <nothingmuch> blah... any example of mergeIO on the intertubes?
07:19:46 <mmorrow> Peaker: it's that blog that looks like mediawiki, uses pandoc for stuff, uses git for store, and runs on HAppS
07:19:58 <Deewiant> quicksilver: google groups finds one from 1983
07:20:11 <pozic> Also known as Buzzword enabled.
07:20:18 <Peaker> oh cool
07:20:23 <mmorrow> it's handy, and the web ui is nice
07:21:19 <mak__> mmorrow: this version didn't use ghc-api..
07:22:22 <mmorrow> mak__: it does internally, but i guess it doesn't show through to the deps
07:23:42 <mak__> mmorrow: hmm are you sure I work a few days with this code it doesnt use ghc-api
07:24:07 <mmorrow> mak__: i guess i'm not sure then :)
07:24:11 <mak__> ;]
07:25:33 <mak__> there was a annotation in alson annnouce about new version of turbinado that someone made a port but I can't find any info about it..
07:26:38 <loadquo> Has anyone suggested making haskell more security aware by making it need capabilities to access files etc?
07:27:08 <joma> csaba: minor, done some open gl and pygame stuff
07:27:23 <mmorrow> loadquo: you can completely control access to IO via the typesystem (e.g. the bots), but once you get IO, anything goes..
07:31:23 <omg911> is it possible to start up ghci with X extension active like how you're able to compile with certain extensions?
07:32:13 <h0tzenpl0tz2133> could anybody pls eplain the right-associativity of haskell? A->B->C == (A->(B->C)) aka the rightmost terms are paranthesed first?
07:32:20 <loadquo> Mmorrow, thats what I thought... I was thinking an alternate version of IO that didn't have full access to the users filesystem but used a standard file put in at install time to control what io could be done. You'd also want any files/folders passed as command line arguments to be caps as well.
07:33:31 <gal_bolle> h0tzenpl0tz2133: it's because (A->(B->C)) is the type (that can be uncurried into the type of) a two-arguments function
07:33:45 <mmorrow> loadquo: that's definitely doable though. so one approach (the only one that i can think of actually) would be to make
07:33:46 <gal_bolle> and so is more often useful than (A->B)->C
07:33:57 <mmorrow> newtype File a = File (IO a)
07:34:11 <mmorrow> then don't export the constructor fomr the module
07:34:19 <mmorrow> and only provide e.g.
07:34:28 <mmorrow> readTheSpecialFile :: IO String
07:35:15 <mmorrow> (or readFile file = if (not . isRestricted) file then File (readFile file) else error "asdsa")
07:36:47 <ziman> h0tzenpl0tz2133, all Haskell functions have one argument. Multiargument functions are realized via functions that return functions, e.g. (+) :: Int -> (Int -> Int) takes one argument and returns a function that takes the second argument and returns the result (plusOne = (1+) :: Int -> Int). So the most useful associativity is to the right.
07:36:48 <mmorrow> so you rely on the module system to hide what could be used to circumvent your security, and the type system to ensure that everything goes as it should
07:37:06 <mmorrow> , unsafePerformIO (print ())
07:37:07 <lunabot>  luna: Not in scope: `unsafePerformIO'
07:37:18 <loadquo> You'd probably want to alter cabal to indicate the security of program to be installed as well. Displaying/editing the caps installed. Or just warning people if something directly imports IO.
07:37:34 <mmorrow> , IO
07:37:35 <lunabot>  luna: Not in scope: data constructor `IO'
07:37:38 <mmorrow> , src ''IO
07:37:41 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
07:37:41 <lunabot>                     (#,#) (State# RealWorld) a)
07:37:53 <h0tzenpl0tz2133> ziman: what purpose has this associativy? to allow currying? would'nt it also work without this associativy?
07:38:02 <Axman6_> mmorrow: still need some pretty printing work?
07:38:03 <mmorrow> if you could pattern match on the (hidden) IO constructor, you'd get unsafePerformIO for free
07:38:11 <mmorrow> Axman6: yeah
07:38:15 <Gracenotes> :t flip map
07:38:16 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
07:38:18 <maltem> h0tzenpl0tz2133: it would work, but you'd need loads of parentheses
07:39:48 <mmorrow> loadquo: for doing static analysis things like that, you could parse the src and extract some info from it, possibly with the help of the ghc-api or similar
07:40:30 <mmorrow> loadquo: but yeah, atm if you want/need to lock down a haskell setup, you need to do all your own auditing
07:41:51 <loadquo> I gotta go. I've saved a log, and I'll read through it later see whether to pursue it when I know more about haskell.
07:43:21 <joma> seriously the fucking IO monad is driving me nuts.
07:43:29 <joma> such a huge fakking pita
07:44:39 <Workybob> heh
07:44:51 <Workybob> joma: believe it or not, all it's doing is enforcing that you write safe IO code
07:45:01 <mauke> learn its weaknesses, beat it into submission
07:45:03 <mauke> problem solved!
07:45:16 <mmorrow> @tell loadquo this is also interesting http://publications.lib.chalmers.se/cpl/record/index.xsql?pubid=72780
07:45:16 <lambdabot> Consider it noted.
07:45:17 <Workybob> what at least I (and probably most other haskellers) would suggest is that you use it as little as possible
07:45:23 <Workybob> like, only in main and 1 or two other functions
07:45:24 <skorpan> i have this piece of code and i want the filter condition to be monadic... how would i do that? getDirectoryContents root >>= filterM (`notElem` ["..", "."])
07:45:41 <Workybob> skorpan: return it
07:45:44 <mmorrow> @type filterM
07:45:45 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:45:51 <mauke> why filterM?
07:46:00 <mauke> fmap (filter ...
07:46:01 <Workybob> indeed
07:46:11 <skorpan> fmap, eh? i'll give that a try.
07:46:22 <skorpan> i should know this stuff, it's embarrasing.
07:46:25 <h0tzenpl0tz2133> thanks
07:46:34 <Workybob> (`notElem` ["..","."]) <$> getDirectoryContents
07:46:45 <Workybob> etc
07:46:53 <Workybob> that needs a filter somewhere
07:46:54 <Workybob> >.<
07:46:58 <skorpan> :t <$>
07:46:58 <lambdabot> parse error on input `<$>'
07:47:02 <skorpan> that's fmap though, right?
07:47:05 <skorpan> :t (<$>)
07:47:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:47:11 <mmorrow> @src (<$>)
07:47:11 <lambdabot> f <$> a = fmap f a
07:47:13 <Workybob> yep
07:47:15 <skorpan> okay
07:47:48 <Workybob> it's dons and Axel Simon maintain GTK2Hs, right?
07:47:50 <skorpan> can't figure out how to work with fmap here.
07:48:13 <Workybob> skorpan: your directory contents is a list, inside a data structure
07:48:17 <Workybob> ignore what the data structure is
07:48:29 <Workybob> you want to apply a function (filter f) inside that data structure
07:48:31 <Workybob> that's what fmap does
07:48:43 <skorpan> sounds cool, but... okay, i'll keep trying. :)
07:48:58 <Workybob> (filter (`notElem` ["..","."])) <$> getDirectoryContents
07:49:33 <skorpan> @hoogle <$>
07:49:33 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:50:01 <skorpan> this is almost magic.
07:50:05 <Workybob> > (filter (`notElem` ["..","."])) <$> (Just [".", "..", "jam/", "ham.txt"])
07:50:06 <lambdabot>   Just ["jam/","ham.txt"]
07:50:21 <Olathe> @src IO fmap
07:50:21 <lambdabot> fmap f x = x >>= (return . f)
07:50:22 <Workybob> now imagine Maybe [FilePath] is actually IO [FilePath]
07:50:23 <Workybob> :)
07:50:36 <skorpan> sure, i see what you mean
07:50:39 <skorpan> thanks
07:50:41 <Workybob> np
07:50:46 <Olathe> @src Maybe fmap
07:50:46 <lambdabot> fmap _ Nothing       = Nothing
07:50:46 <lambdabot> fmap f (Just a)      = Just (f a)
07:50:58 <Workybob> anyone here used Gtk2Hs on OS X?
07:51:22 <Olathe> (Just [".", "..", "jam/", "ham.txt"]) >>= (return $ filter (`notElem` ["..","."]))
07:51:29 <Olathe> > (Just [".", "..", "jam/", "ham.txt"]) >>= (return $ filter (`notElem` ["..","."]))
07:51:30 <lambdabot>   Couldn't match expected type `Maybe b'
07:51:49 <Olathe> > (Just [".", "..", "jam/", "ham.txt"]) >>= (return . filter (`notElem` ["..","."]))
07:51:50 <lambdabot>   Just ["jam/","ham.txt"]
07:54:15 <Axman6_> Workybob: a little...
07:54:25 <Peaker> hmm.. wouldn't it be cool if helpful IRC channels had donate web apps, so you could donate money to people who helped you?
07:54:39 <Peaker> I guess it might cause people to stop helping if they don't get donations, though
07:55:16 <Raevel> or the money could just go directly to the related projects
07:56:49 <skorpan> is there anything for representing a directory tree?
07:57:11 <baaba> @djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
07:57:11 <lambdabot> f a b c d = a (b c d)
07:57:24 <baaba> @pl f a b c d = a (b c d)
07:57:25 <lambdabot> f = (.) . (.)
07:59:26 <baaba> i guess this is where ~> comes useful
08:00:50 <Axman6_> :t (~>)
08:00:52 <lambdabot> Not in scope: `~>'
08:02:53 <baaba> @let infixr 2 ~>; f ~> g = (. f) . (g .)
08:02:54 <lambdabot>  Defined.
08:03:22 <baaba> > let f = id ~> id ~> id $ (+) in f 5 3
08:03:23 <lambdabot>   8
08:03:29 <baaba> > let f = id ~> id ~> (*2) $ (+) in f 5 3
08:03:31 <lambdabot>   16
08:03:40 <baaba> > let f = id ~> (+1) ~> id $ (+) in f 5 3
08:03:41 <lambdabot>   9
08:04:06 <gal_bolle> is there a way, with ghc 6.8, to allow other modules to pattern match against a type, but not build values of that type?
08:04:19 <gal_bolle> like private types in ocaml
08:05:02 <joma> how do i get out of : m (Matrix repr2)
08:05:25 <Saizan_> gal_bolle: no
08:05:34 <Deewiant> gal_bolle: no, the best thing you can do is provide functions which return visible types
08:05:37 <mauke> not at all if m is data M a = M
08:05:47 <gal_bolle> ok, thanks
08:06:01 <Deewiant> gal_bolle: (if you want to hide the constructors, that is)
08:06:24 <baaba> :t id ~> id ~> id
08:06:25 <lambdabot> forall a a1 b. (a -> a1 -> b) -> a -> a1 -> b
08:06:28 <gal_bolle> yes, i'll just let them visible and put a big warning in the haddocks
08:06:56 <baaba> :t edit
08:06:57 <lambdabot> Not in scope: `edit'
08:07:35 <Deewiant> :t (~>)
08:07:36 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
08:08:39 <Axman6> hmm, i'm ot looking forward to doing this assigment: http://cs.anu.edu.au/student/comp2300/assign/A1.php
08:10:24 <byorgey> Axman6: ick
08:10:36 <athos> heya byorgey!
08:10:41 <Axman6> i think i'll find it fun eventually though
08:10:43 * mauke sees 'register' and closes the window
08:10:44 <zax> Axman6: you shouldn't, deadline was almost a year ago ;-)
08:10:44 <athos> how are you? :)
08:10:45 <byorgey> I had to write a cache simulator last semester too, but we could do it in any language we liked
08:10:51 <byorgey> hi athos, I'm good, how are you?
08:10:57 <Axman6> i sat through a lot of the course in first semester last ear
08:10:59 <athos> i'm fine :)
08:11:34 <athos> ah, seems like there are some new posts on your math blog byorgey
08:11:37 <athos> great! :)
08:11:47 <byorgey> athos: indeed, with more on the way! =)
08:12:20 <Axman6> byorgey: i take it you chose haskell?
08:12:29 <byorgey> Axman6: indeed. =)
08:12:50 <Axman6> seems like it could be fun in the ST monad, with STArrays (or even STUArrays)
08:13:02 <byorgey> It probably wasn't quite as fast as an implementation in C could have been, but it sure was easier to write!
08:13:24 <byorgey> Axman6: I actually used IOUArrays.  dmwit used STUArrays though
08:13:36 <mornfall> Anyone know if Gracjan Polak goes to IRC? :) I'd need a little help with the mmap package...
08:14:56 <mornfall> (Specifically, is it intended that mmaping an empty file raises an exception?)
08:14:59 <Axman6> byorgey: maybe i'll write a haskell one in ST after finishing the C one, and submit it too ;)
08:15:16 <byorgey> Axman6: hehe
08:15:47 <byorgey> Axman6: just whip up a little Haskell DSL to generate C, then you can write it in Haskell but submit the generated C =)
08:16:01 <skorpan> \root -> filter (`notElem` [".", ".."]) <$> getDirectoryContents root
08:16:04 <skorpan> @pl \root -> filter (`notElem` [".", ".."]) <$> getDirectoryContents root
08:16:04 <lambdabot> (filter (`notElem` [".", ".."]) <$>) . getDirectoryContents
08:16:11 <Axman6> heh :P
08:16:15 <skorpan> :P
08:16:43 <ztirF> how would I declare that a function is idempotent in a rewrite rule?
08:17:33 <ztirF> I tried
08:17:35 <ztirF> {-# RULES
08:17:36 <ztirF>   "normalize/normalize"   forall x.  (normalize (normalize x)) = (normalize x)
08:17:38 <ztirF>   #-}
08:17:39 <ztirF> but it gets a parse error
08:18:50 <Saizan_> try without the outer parentheses?
08:20:54 <dpratt71> @type (<$>)
08:20:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:21:13 <byorgey> dpratt71: <$> is just a synonym for fmap
08:21:27 <dpratt71> byorgey: oh, thanks
08:21:37 <byorgey> it's found in Control.Applicative
08:21:50 <ztirF> Saizan_: no dice =(
08:21:59 <Axman6> @hoogle (<$>)
08:22:00 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
08:23:38 <maltem> ztirF: does the pragma line up with the enclosing definitions, if any?
08:24:22 <h0tzenpl0tz2133> is Maybe a monad?
08:24:23 <ztirF> maltem: no I had it outside the module, do I need to move it next to the function?
08:25:08 <Peaker> h0tzenpl0tz2133: yes
08:25:23 <Peaker> The synonym:  type Endo a = a -> a    is pretty useful to have around :)
08:25:25 <h0tzenpl0tz2133> Peaker: ... why? ;)
08:25:29 <maltem> ztirF: I think it isn't important where the declaration is vertically, but horizontally
08:25:35 <Peaker> h0tzenpl0tz2133: why is it a monad?
08:25:49 <maltem> ztirF: otherwise, yes, I suppose it should lie within a module
08:25:55 <dolio> Because it fits the definition. :)
08:26:00 <defun> Hi. I just finished coding a prog that solves problem 10 on project euler. I get a result (1179908154), but it is wrong. Here is the program (http://hpaste.org/14090)
08:26:27 <defun> prob 10 is find sum of all primes < 2 million
08:26:45 <Peaker> I was asking if that was the question :)
08:26:58 <h0tzenpl0tz2133> Peaker: yes, why is Maybe a Monad?
08:27:01 <Zao> defun: Int is horribly non-big-integer.
08:27:06 <Zao> Consider Integer?
08:27:11 <Peaker> h0tzenpl0tz2133: because you can define the functions  return and (>>=) for it
08:27:19 <Peaker> h0tzenpl0tz2133: such that they follow all the monad laws
08:27:50 <h0tzenpl0tz2133> Peaker: are there any Data-types on which the monad-laws do not apply??
08:28:09 <Peaker> h0tzenpl0tz2133: there are data types where you can't make these functions, sure
08:28:15 <Peaker> h0tzenpl0tz2133: is that what you mean?
08:28:34 <defun> y integer?
08:28:52 <sw17ch> @index maxbound
08:28:53 <lambdabot> bzzt
08:28:55 <sw17ch> @index maxBound
08:28:55 <lambdabot> Prelude
08:29:03 <sw17ch> > maxBound (undefined :: Int)
08:29:05 <h0tzenpl0tz2133> Peaker: yes, i wonder why Maybe is a good example for builtin Monads
08:29:06 <lambdabot>       No instance for (Bounded (Int -> a))
08:29:06 <lambdabot>        arising from a use of `maxB...
08:29:10 <sw17ch> orly?
08:29:16 <dolio> > maxBound :: Int
08:29:18 <lambdabot>   9223372036854775807
08:29:23 <sw17ch> oh, right
08:29:23 <Peaker> @src Bounded
08:29:23 <lambdabot> class  Bounded a  where
08:29:24 <lambdabot>     minBound, maxBound :: a
08:29:30 <sw17ch> hah...
08:29:35 <anykey> Hey guys
08:29:36 <Peaker> What is Bounded but not Ord?
08:29:53 <Peaker> Wouldn't it make sense for Bounded to subclass Ord?
08:29:56 <sw17ch> defun: an Int can hold a maximum value of 9223372036854775807 before it wraps
08:29:57 <Zao> defun: The answer is roughly 40 bits in size. If your Int is 32 bits, you're rather hosed.
08:30:05 <Zao> sw17ch: Depending on platform and pie.
08:30:18 <sw17ch> of course, depending on platform...
08:30:22 <dolio> That's on a 64-bit platform, too. It's much smaller on 32-bit platforms.
08:30:31 <Axman6> numbers?
08:30:36 <sw17ch> > maxBound Int32
08:30:38 <lambdabot>   Not in scope: data constructor `Int32'
08:30:41 <sw17ch> > maxBound :: Int32
08:30:43 <lambdabot>   2147483647
08:30:46 <Zao> On a 32-bit platform, it's +2^31
08:30:51 <sw17ch> yeah, that's a substantial differnce
08:30:53 <sw17ch> :)
08:30:58 <loadquo> > maxBound :: Integer
08:31:00 <lambdabot>       No instance for (Bounded Integer)
08:31:00 <lambdabot>        arising from a use of `maxBoun...
08:31:00 <lambdabot> loadquo: You have 1 new message. '/msg lambdabot @messages' to read it.
08:31:05 <dolio> > 2^31 - 1
08:31:07 <lambdabot>   2147483647
08:31:21 <quicksilver> on other (non-GHC) platforms it may be smaller.
08:31:28 <defun> ok brb
08:31:34 <quicksilver> I think maxBound Int is permitted be as low as 2^29 - 1
08:31:47 <Peaker> quicksilver: why 29, specifically?
08:32:01 <quicksilver> Peaker: it had to be some number, specifically.
08:32:02 <Axman6> haskell ints are guaranteed to be 30 bits long
08:32:06 <quicksilver> They chose one in the report.
08:32:10 <Peaker> quicksilver: ah
08:32:19 <quicksilver> the rationale is to leave you 2 bit for tagging
08:32:23 <quicksilver> should you wish for that.
08:32:36 <joma> main :: (Monad m) =>
08:32:36 <joma>         Matrix repr -> Matrix repr1 -> m (Matrix repr2)
08:32:37 <anykey> Does anyone here know about StableNames?
08:32:37 <anykey> I have to write a report based on a paper by Simon Peyton Jones, Simon Marlow and Conal Elliott (Stretching the storage manager: weak pointers and stable names in Haskell), tried to implement some of it but am encountering strange problems
08:32:49 <joma> why cant i let that but i can do main m1 m2
08:32:50 <joma> ?
08:33:37 <quicksilver> joma: "cant let that" ?
08:33:42 <quicksilver> what is your question?
08:33:46 <Axman6> well main is usually main :: IO ()
08:33:52 <joma> main m1 m2 works. let m = main m1 m2 fails
08:34:03 <joma> well it i m (Matrix repr) now
08:34:06 <Zao> Axman6: IO a for arbitrary a is allowed, isn't it?
08:34:21 <quicksilver> joma: what error does it fail with?
08:34:59 <byorgey> Zao: yes
08:34:59 <joma>  Ambiguous type variable `m' in the constraint:
08:34:59 <joma>       `Monad m' arising from a use of `main' at <interactive>:1:8-15
08:34:59 <joma>     Probable fix: add a type signature that fixes these type variable(s
08:35:23 <Zao> joma: hpaste things?
08:35:26 <Deewiant> joma: because you've only said that it's any Monad m, but not which m
08:35:32 <Zao> Or give main an explicit signature?
08:35:56 <joma> it is not using any monad, just main = do then a buncha lets and return
08:35:57 <h0tzenpl0tz2133> are types right-associative and function-applications left-associative?
08:35:58 <quicksilver> joma: dreaded monomorphism restriction.
08:36:09 <quicksilver> applies to lets
08:36:20 <quicksilver> either give "m" an explicit type sig
08:36:24 <quicksilver> or turn it off.
08:36:27 <SamB> joma: is this "main" supposed to be your entry point ?
08:36:30 <vixey> by types do you mean (->)?
08:36:35 <quicksilver> @google haskellwiki monomorphism restriction
08:36:37 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
08:36:37 <lambdabot> Title: Monomorphism restriction - HaskellWiki
08:36:41 <byorgey> h0tzenpl0tz2133: function arrows (->) are right associative, and application is left-associative, yes
08:36:43 <Deewiant> joma: 'do' means that monads are involved
08:36:59 <h0tzenpl0tz2133> byorgey: thanks!
08:37:12 <Axman6> joma: sounds to me like return does not do what you think it does
08:37:30 <SamB> joma: the "main" that is the entry point for a Haskell program is supposed to be in a module named Main
08:37:44 <anykey> Hi! could anyone please help me with a problem concerning StableNames?
08:37:51 <SamB> (which is the name you get if you don't have a "module" clause)
08:38:21 <quicksilver> the whole business about main and Main doesn't matter if you're just playing in ghci though
08:38:34 <quicksilver> only if you are trying to compile an executable.
08:38:36 <adams> hi everyone i need help with making an extremely simple script
08:38:41 <anykey> according to the paper I read, you can add    instance Ord (StableName a)
08:39:07 <anykey> but everytime i try to compare two stable names, even manually there is a Stack Overflow
08:39:15 <adams> Can anyone tell me how to make a script that will enter a few numbers everytime i press a hotkey?
08:39:36 <Botje> enter a few numbers _where_ ?
08:39:40 <adams> like
08:39:49 <Axman6> anykey: sounds ling a bung definition... paste your code
08:39:54 <adams> lets say i need to enter the same number a lot of times
08:40:06 <anykey> k thx
08:40:08 <adams> on a game
08:40:23 <adams> i just want it to send the numbers everytime i press my hotkey
08:40:27 <joma> basically im tryong to do kroenecker multiplicationa nd i think it would be super easy to do in Java or any imperative language but it is a pita in haskell
08:40:33 <adams> thats simple right?
08:40:41 <Axman6> anykey: like... ctrl-v?
08:40:45 <vixey> joma, what aspects of java would you use?
08:40:54 <adams> something like that just that ctrl-v doesent work in that game
08:41:15 <anykey> First test:
08:41:22 <h0tzenpl0tz2133> is the priority of map higher than of (:) ?      f x : map f xs    why does tis work without paranthesis?
08:41:24 <loadquo> adams, depends whether there is a
08:41:40 <quicksilver> joma: kroenecker multiplication is just as easy in haskell as any other language.
08:41:44 <Saizan> anykey: did you provide the implementation of compare and/or (<=) in your instance declaration?
08:41:47 <Peaker> h0tzenpl0tz2133: its called precedence, not priority, and prefix function application is always higher than all infix
08:41:52 <quicksilver> joma: however, you're still learning haskell so you're hitting problems.
08:41:52 <loadquo> good library for haskell for rerouting keyboard input
08:41:57 <quicksilver> that's not surprising.
08:42:06 <quicksilver> there are some fiddly things to get your head around
08:42:07 <anykey> instance Ord(StableName a)
08:42:07 <anykey> foo = unsafePerformIO (makeStableName "x")
08:42:07 <anykey> bar = unsafePerformIO (makeStableName "y")
08:42:07 <anykey> x <= y
08:42:07 <anykey> ... Stack Overflow
08:42:20 <Axman6> anykey: use hpaste
08:42:24 <Axman6> anyway
08:42:27 <quicksilver> monomorphism restriction, etc
08:42:33 <h0tzenpl0tz2133> Peaker: Thanks!
08:42:39 <yitz> @paste
08:42:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:42:48 <anykey> thx
08:43:00 <adams> can anyone please help me with my request?..
08:43:18 <joma> http://hpaste.org/14092
08:43:20 <Saizan> anykey: you must implement compare, at least, like "instance Ord (StableName a) where compare name1 name2 = <code here>"
08:43:30 <vixey> anykey, well I'd suggest not using unsafePerformIO
08:43:37 <joma> vixey: aspectsof java: nested for-loops, very intuitive
08:44:00 <vixey> joma, you can implement a for loop like thing in haskell using functions
08:44:16 <anykey> thx
08:44:32 <quicksilver> joma: OK, and what is the problem there?
08:44:43 <joma> quicksilver: where?
08:44:44 <anykey> i need to use unsafePerformIO, its part of the paper I have to read and the homework i have to do
08:44:44 <quicksilver> joma: that code doesn't appear to contain the "let m = main m1 m2" line which was causing you trouble.
08:44:47 <Axman6> joma: for loops in haskell are often written as just flip map
08:44:50 <Axman6> :t flip map
08:44:53 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
08:44:58 <joma> that isnt reeally the roblem
08:45:01 <vixey> anykey, who is teaching you?
08:45:05 <quicksilver> joma: ok, what is the problem?
08:45:06 <joma> i want to write a pure function anyway
08:45:08 <Axman6> "for all the elements in this list, apply this function"
08:45:12 <yitz> anykey: really? that's odd
08:45:15 <vixey> anykey, (and is there course materials online?)
08:45:19 <int80_h> good morning #haskell
08:45:20 <quicksilver> joma: don't use do and return in your 'main'
08:45:25 <quicksilver> just use let ... in ...
08:45:31 <quicksilver> just like you do in your other functions.
08:45:33 <anykey> it's a haskell course at freiburg university
08:45:44 <vixey> anykey, is there a course webpage?
08:45:52 <anykey> we have to read papers and present our works then
08:45:55 <anykey> yes
08:46:09 <Axman6> joma: looks like in main, you can delete do, and replace return with in
08:46:17 <anykey> http://proglang.informatik.uni-freiburg.de/teaching/proseminar/2008ws/
08:46:20 <vixey> anykey, what paper did you choose? or were you assigned one?
08:46:34 <Axman6> and you cal delete all but the first let (but jeep the functions at the same distance right)
08:46:58 <anykey> Stretching The Storage manager: weak pointers and stable names in Haskell
08:47:27 <anykey> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1948
08:48:11 <yitz> int80_h: hi
08:48:53 <int80_h> anykey: are the lectures in German?
08:49:08 <anykey> there were only introduction lessons
08:49:17 <anykey> now we have to work ourselves
08:49:18 <int80_h> I see the web site is
08:49:21 <anykey> yes
08:49:48 * vixey gets the impression the authors of that paper don't really know haskell.....
08:49:50 <joma> I jsut did main becuase i could do a bunch of lets
08:49:53 <yitz> anykey: you chose that paper?
08:50:05 <Axman6> anykey: if you decide to change papers, SPJ's are often quite easy to follow (though the mathematical proof bore me somewhat :
08:50:08 <anykey> no it was assigned to me by my professor
08:50:17 <vixey> data SNMap k v = IORef (...) -- That's more than just a typo right ?
08:50:25 <anykey> it's a SPJ paper ...
08:50:32 <yitz> anykey: ohhh.
08:50:58 <Axman6> ok, other SPJ papers :P
08:51:09 <anykey> :D
08:51:10 <yitz> anykey: that is just a description of some hacks that were added to ghc to help them implement some things. you would never use them in real programming.
08:51:12 <vixey> why are they writing data instead of type then?
08:51:22 <quicksilver> joma: you can do a bunch of lets anyway, main or otherwise
08:51:27 <Axman6> i was reading http://tinyurl.com/8qfpty today, it's quite good
08:51:50 <yitz> anykey: and it was a long time ago
08:52:01 <ski_> joma : `m3' is not used anywhere in the definition of `kroenecker' ..
08:52:19 <yitz> anykey: it's a good paper if you want to understand some ghc internals though.
08:52:27 <ztirF> so there's a function in Ix, index, that does (Ix a) => (a,a) -> a -> Int... shouldn't it also be possible to do (Ix a) => (a,a) -> Int -> a?
08:52:35 <ztirF> or is that not unique?
08:52:56 <joma> flip map or map doesnt matter?
08:53:02 <joma> sme thing with different order right?
08:53:12 <ski_> joma : yes, more readable order
08:53:13 <Axman6> yes joma
08:53:18 <anykey> the problem is some stuff don't seem to work, especially concernin the StableName things
08:53:32 <Axman6> Control.Monad has forM ad forM_, which are very useful
08:53:35 <anykey> the memoEq procedures work really well
08:54:08 <int80_h> oh man, I had a data structures teacher who gave us broken code we were supposed to use to do our parser assignments with.
08:54:11 <yitz> anykey: a lot has changed since 1999
08:54:16 <joma> i know the whole thing is just a hack now
08:54:25 <joma> obv i need to geenralize for any sized square matrix
08:54:27 <joma> matrices
08:54:35 <joma> and it is friggin ugly
08:54:42 <dolio> augustss used StableNames in one of his reflection blog posts, didn't he?
08:54:43 <joma> anyone have good ide ahow to make it smalla nd cute?
08:54:56 <dolio> For working out the sharing in the exponentiation function.
08:55:09 <Axman6> joma: take a look at http://hpaste.org/14092#a1
08:55:56 <yitz> augustss_: ping
08:56:12 <yitz> anykey: what are you supposed to write?
08:56:17 <dolio> http://augustss.blogspot.com/2008/03/in-recent-blog-post-by-twan-van.html
08:56:35 <ski_> joma : what is the `map (\x -> m3 !! x) [0,2..length m3-1]' for ?
08:56:36 <Axman6> joma: also seems that take 2 a ++ take 2 b could be turned into a more clear function: f n a b = take n a ++ take n b
08:56:53 <Peaker> @pl f n a b = take n a ++ take n b
08:56:54 <lambdabot> f = ap (flip . (((.) . (++)) .) . take) take
08:56:57 <dolio> Oops, wrong one.
08:57:02 <anykey> 30 minute presentation and 15 pages
08:57:06 <Axman6> Peaker: no, bad Peaker!
08:57:07 <dolio> http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html
08:57:09 <dolio> There we go.
08:57:27 <Peaker> @type both
08:57:29 <lambdabot> Not in scope: `both'
08:57:42 <Peaker> @let both = join (***)
08:57:44 <lambdabot>  Defined.
08:57:46 <Peaker> @type both
08:57:48 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
08:57:52 <anykey> like i said, i think i understand the whole thing, just can't really implement it :(
08:58:01 <Peaker> @type uncurry (both . take)
08:58:03 <lambdabot> forall a. (Int, ([a], [a])) -> ([a], [a])
08:58:09 <mauke> :t \n a b -> liftM2 (++) ($ a) ($ b) (take n)
08:58:11 <lambdabot> forall a. Int -> [a] -> [a] -> [a]
08:58:18 <mauke> @pl \n a b -> liftM2 (++) ($ a) ($ b) (take n)
08:58:18 <lambdabot> flip (flip . (. flip id) . liftM2 (++) . flip id) . take
08:58:26 <anykey> if i read the paper correctly, maybe a earlier version of StableNames was instance Ord
08:58:27 <Peaker> @type (uncurry both . take)
08:58:30 <lambdabot>     Couldn't match expected type `(b -> c, (b, b))'
08:58:30 <lambdabot>            against inferred type `[a] -> [a]'
08:58:30 <lambdabot>     Probable cause: `take' is applied to too few arguments
08:58:35 * Axman6 goes to sleep
08:58:37 <Peaker> @type both . take
08:58:39 <lambdabot> forall a. Int -> ([a], [a]) -> ([a], [a])
08:59:31 <yitz> anykey, dolio yes, augustss_ uses that stuff there for hacking on ghc, observing how it does things internally.
09:00:13 <Peaker> @type (uncurry.) . both . take
09:00:15 <lambdabot>     Couldn't match expected type `a -> b -> c'
09:00:15 <lambdabot>            against inferred type `([a1], [a1])'
09:00:15 <lambdabot>     Probable cause: `.' is applied to too many arguments
09:00:33 <anykey> the other problem is that if i use equallity which still works, the stable names are absolutely always different
09:01:07 <quicksilver> anykey: that's probably because you're using unsafePerformIO without NOINLINE?
09:01:13 <quicksilver> (unsafePerformIO is bad!)
09:01:17 <anykey> unsafePerformIO(makeStableName "x") /= unsafePerformIO(makeStableName "x")
09:01:54 <yitz> anykey: augustss_ orders his stable names by converting them to Ints.
09:01:55 <anykey> how do i use noinline?
09:02:07 <quicksilver> it would be better not to use unsafePerformIO
09:02:12 <quicksilver> call makeStableName in a do block
09:02:21 <anykey> that wouldn't work
09:02:46 <anykey> the result function of memoStable may not be IO
09:03:10 <vixey> I got no clue what that paper is about
09:03:19 <yitz> anykey: unsafePerformIO is really bad for stable names - they can change under certain circumstances
09:03:24 <lilac> in a total FP language, how does one ensure that there's no non-structural recursion (eg, across module boundaries and in functions passed to recursive functions)?
09:03:30 <vixey> It's like trying to pretend haskell is Ocaml or something
09:03:35 <anykey> :D
09:03:47 <Peaker> Axman6: I settle on both . take
09:04:01 <Peaker> Axman6: that's a nice one, opening up the tuple args there is difficult PLwise :)
09:04:04 <joma> the thing is i just write these things in 10seconds in python and in java with about the same mental effort in 30sec(i is Java print orint Java). in haskell it is rocket science
09:04:11 <vixey> lilac, not allowing mutually recursive functions to be defined across module boundries
09:04:19 <anykey> it's not required that makeStableName x == makeStableName x in all casses
09:04:25 <anykey> only in most cases
09:04:33 <lilac> vixey: that doesn't solve the function-as-an-argument-to-itself problem, though.
09:04:38 <anykey> and in my case, its in none ^^
09:04:55 <anykey> i tried the following:
09:04:56 <lilac> vixey: although perhaps that's caught by the type system anyway?
09:05:02 <vixey> lilac, if 'f' terminates for all inputs  map f list  does too
09:05:16 <quicksilver> >  let km a b = (map.map) (\x -> (map.map) (*x) b) a in km [[1,2],[3,1]] [[0,3],[2,1]]
09:05:17 <lambdabot>   [[[[0,3],[2,1]],[[0,6],[4,2]]],[[[0,9],[6,3]],[[0,3],[2,1]]]]
09:05:20 <vixey> regardless if 'f' uses map
09:05:34 <quicksilver> joma: it's not rocket science, it's just you're not used to it.
09:05:48 <vixey> lilac, yeah type system will disallow things like  (\u -> u u)(\u -> u u)  as usual
09:05:48 <quicksilver> joma: I'm pretty confidence at driving cars, but if you put me in charge of a submarine I'd struggle.
09:06:04 <joma> well it odesnt have wheels
09:06:13 <joma> so i think you always would
09:06:14 <quicksilver> joma: that think I just got LB to do is the kroenecker product without the 'flattening' step.
09:06:24 <joma> LB?
09:06:25 <quicksilver> as you can see, it's a one liner :)
09:06:29 <quicksilver> lambdabot
09:06:31 <vixey> lilac, if you really want to see a formal treatment of mutual recursion and the like check out Abels papers on foetus
09:06:41 <anykey> x = "xyz"
09:06:41 <anykey> foo = unsafePerformIO (makeStableName "xyz")
09:06:41 <anykey> bar = unsafePerformIO (makeStableName "xyz")
09:06:41 <anykey> bla = unsafePerformIO (makeStableName x)
09:06:41 <anykey> blub = unsafePerformIO (makeStableName x)
09:06:42 <anykey> now foo == bar returns false, as well as bla == blub
09:06:44 <anykey> but bla == blub returns true
09:07:21 <SamB> anykey: wait
09:07:28 <SamB> it returns both false and true ?
09:07:43 <lilac> vixey: thanks, looks like a useful paper
09:07:54 <anykey> no ^^ typo
09:08:05 <anykey> foo == bar , bar == bla returns false
09:08:12 <anykey> bla == blub returns true
09:08:16 <quicksilver> > let km a b = (map.map) (\x -> (map.map) (*x) b) a in concat . (map.map) concat $ km [[1,2],[3,1]] [[0,3],[2,1]]
09:08:17 <lambdabot>   [[0,3,2,1],[0,6,4,2],[0,9,6,3],[0,3,2,1]]
09:08:20 <SamB> anykey: I figured
09:08:29 <quicksilver> joma: and there you go, a sprinkiling of 'concat' does the flattening.
09:08:30 <SamB> (that it was a typo, I mean ;-)
09:08:41 <anykey> :D
09:08:53 <quicksilver> hmm. but gets the answer wrong :)
09:09:15 <vixey> lilac, the general idea of something being structually smaller is (for constructor C and function f) the transitive closure of,  pi < C p1 p2 ...  and  f x < x
09:09:52 <anykey> as much as i understand it's because the "xyz"s are stored in different thunks and thereby produce different StableNames wheras the x is one value in only one thunk
09:10:35 <joma> pfft: quick tht is so cute it makes me puke
09:10:36 <ski_> (vixey : which function `f' ?)
09:10:46 <vixey> any function f
09:10:51 <lilac> id x < x?
09:10:53 <joma> wtf how long did tke you to reach such a level of haskellmastery?
09:11:03 <vixey> oops  f x < f
09:11:07 <ski_> vixey : so `factorial n < n' for any natural `n' ?
09:11:13 <ski_> ah
09:12:01 <Badger> @hoogle uncurry
09:12:01 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
09:12:02 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
09:12:03 <joma> is function composition the trick to a lot in haskell?
09:12:04 <Badger> ah.
09:12:05 <anykey> the bigger problem is, if the argument, for wich the stable name table is checked are always produced new, how can ever be two stableNames the same?
09:12:07 <anykey> :(
09:12:13 <quicksilver> > let km a b = (map.map) (\x -> (map.map) (*x) b) a in concatMap (foldl1 (zipWith (++))) $ km [[1,2],[3,1]] [[0,3],[2,1]]
09:12:15 <lambdabot>   [[0,3,0,6],[2,1,4,2],[0,9,0,3],[6,3,2,1]]
09:12:21 <lilac> vixey: what're your p_i ?
09:12:22 <quicksilver> joma: that version actually gives the right answer :)
09:12:29 <joma> quicksilver: if i gace you your kronecker function would you be able to quickly say what it does?
09:12:34 <quicksilver> at least, it matches the example on wikipedia.
09:12:40 <ski_> lilac : arguments to the constructor
09:13:00 <quicksilver> joma: the bit I called "km" is very self explanatory.
09:13:17 <quicksilver> that's the obvious notion, mirroring the 'chunk-by-chunk' definition mathematicians intuitively give.
09:13:33 <quicksilver> the concatMap foldl1 zipWith(++) needs a little thought
09:13:44 <quicksilver> but that's just a boring detail about how you flatten a chucnk-by-chunk matrix into a single one.
09:13:50 <vixey> lilac, for example,   x < Branch x y
09:14:17 <quicksilver> joma: and that is the general n*m * l*p version
09:14:20 <quicksilver> joma: at least, I hope it is ;)
09:16:06 <lilac> vixey: right, pi < C p1 p2 .. pn, for 1 <= i <= n
09:16:13 <lilac> that makes sense
09:16:14 <SamB> anykey: I dunno what the point is, really!
09:16:40 <anykey> anyway, thank you for your help guys
09:16:48 <Olathe> > km a b = (map.map) (\x -> (map.map) (*x) b) a in concatMap (foldl1 (zipWith (++))) $ km [[a,b],[c,d]] [[e,say "f"],[say "g",say "h"]]
09:16:50 <lambdabot>   <no location info>: parse error on input `='
09:16:52 <Olathe> > let km a b = (map.map) (\x -> (map.map) (*x) b) a in concatMap (foldl1 (zipWith (++))) $ km [[a,b],[c,d]] [[e,say "f"],[say "g",say "h"]]
09:16:54 <lambdabot>   [[e * a,f * a,e * b,f * b],[g * a,h * a,g * b,h * b],[e * c,f * c,e * d,f *...
09:16:58 <SyntaxRebel> erm is haskell.org down?
09:17:03 <SamB> SyntaxRebel: looks like
09:17:08 <SyntaxRebel> :/
09:17:13 <quicksilver> Olathe: does it look right to you?
09:17:14 <SamB> I had to use google's cache of the haddock for StableName just now
09:17:38 <quicksilver> that doesn't look right to me.
09:17:44 <quicksilver> ah yes, it does.
09:18:34 <quicksilver> joma: of course it helps to understand the idiom that (map.map) is like a double map, for lists of lists.
09:18:37 <SyntaxRebel> ah but hackage is up :D
09:18:41 <quicksilver> btu that idiom is familiar to haskell programmers.
09:19:07 <Olathe> quicksilver: I'm not sure what it's doing.
09:19:47 <quicksilver> Olathe: kronecker multiplication.
09:19:53 <nothingmuch> @pl foo x = bar `baz` quxx x
09:19:54 <lambdabot> foo = (bar `baz`) . quxx
09:19:59 <nothingmuch> ah, i see
09:20:02 <quicksilver> Olathe: tensore product.
09:20:10 <yitz> > let kronProd a b = gather $ map (map (scalarProd b)) a where {gather = concatMap gatherRow; gatherRow = map concat . transpose; scalarProd b x = map (map (* x)) b} in kronProd [[1,2],[3,1]] [[0,3],[2,1]]
09:20:12 <lambdabot>   [[0,3,0,6],[2,1,4,2],[0,9,0,3],[6,3,2,1]]
09:20:43 <skorpan> @users
09:20:43 <lambdabot> Maximum users seen in #haskell: 653, currently: 624 (95.6%), active: 25 (4.0%)
09:21:21 <yitz> joma: I think that's pretty clear, and simple to write.
09:21:21 <Olathe> > cycle [a, b]
09:21:22 <roconnor> If I export 1 function, foo, in two modles, then I import unqualifed those too modules, can I call foo without getting an ambiguity error?
09:21:22 <lambdabot>   [a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,b,a,...
09:22:08 <roconnor> oh, I do this
09:22:14 <roconnor> I guess that means the answer is yes
09:22:20 <roconnor> nice
09:22:21 <byorgey> roconnor: I think maybe you can still use a fully qualified name for it?
09:22:22 <quicksilver> yitz: ah, yes, I thought I could use transpose but I got distract by zipWith(++)
09:22:27 <quicksilver> yitz: I guess it doesn't matter though.
09:22:43 <maltem> Is it just me, or is haskell.org being embarassingly slow?
09:22:50 <byorgey> roconnor: oh, it's the *same* function that's being exported twice?
09:22:53 <roconnor> byorgey: yes
09:22:58 <roconnor> I see I do this once
09:23:00 <roconnor> and it works
09:23:02 <byorgey> ah, yeah, that should work =)
09:23:11 <quicksilver> roconnor: yes, the standard lib does that all the time
09:23:14 <yitz> quicksilver: yes. I'm sure you can write it much more elegantly, but what I wrote is supposed to be a direct representation of the definition.
09:23:17 <Olathe> > [a, b] >> [c, d]
09:23:19 <lambdabot>   [c,d,c,d]
09:23:19 <quicksilver> roconnor: (Data.List functions exported also by prelude, etc)
09:23:52 <quicksilver> yitz: yes well the map map part is the same except you've named scalarProd. Only the gather part is different.
09:23:55 <Peaker> @type (>*>)
09:23:57 <lambdabot> Not in scope: `>*>'
09:24:14 <Peaker> @let (>*>) = liftA2 (flip const)
09:24:15 <Olathe> > liftM2 (fst.(,)) [a, b] [c, d]
09:24:17 <lambdabot>  Defined.
09:24:17 <lambdabot>   mueval: Prelude.read: no parse
09:24:17 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
09:24:25 <Peaker> > [a, b] >*> [c,d]
09:24:26 <Olathe> > liftM2 (fst.(,)) [a, b] [c, d]
09:24:27 <lambdabot>   [c,d,c,d]
09:24:28 <lambdabot>   Couldn't match expected type `(a, b)'
09:24:45 <Olathe> > liftM2 ((,)) [a, b] [c, d]
09:24:46 <lambdabot>   [(a,c),(a,d),(b,c),(b,d)]
09:25:01 <Olathe> > map fst $ liftM2 (,) [a, b] [c, d]
09:25:03 <lambdabot>   [a,a,b,b]
09:25:04 <jpcooper> how can I check whether or not something is readable to a certain type?
09:25:07 <Olathe> > [a, b] >> [c, d]
09:25:07 <yitz> quicksilver: and I bit my tongue hard and avoided points-free for some parts :)
09:25:08 <lambdabot>   [c,d,c,d]
09:25:24 <Peaker> > liftM2 ((fst.).(,)) [a, b] [c, d]
09:25:26 <lambdabot>   [a,a,b,b]
09:25:51 <Olathe> @pl \a b -> zipWith h (f a b) (g a b)
09:25:51 <lambdabot> ap (ap . (zipWith h .) . f) g
09:25:53 <quicksilver> jpcooper: use "reads"
09:25:53 <doserj> jpcooper, try reads instead of read
09:26:07 <jpcooper> thanks
09:26:11 <RayNbow`> <maltem> Is it just me, or is haskell.org being embarassingly slow? <-- no, it's not just you
09:26:22 <lilac> jpcooper: not $ null (reads x :: [(a, String)])
09:26:31 <Olathe> Actually.
09:26:39 <Olathe> > liftM2 (*) [a, b] [c, d]
09:26:41 <lambdabot>   [a * c,a * d,b * c,b * d]
09:27:12 <maltem> RayNbow`: ok
09:27:28 <roconnor> ah crap
09:27:37 <roconnor> I'm no the wrong wireless network
09:27:47 <roconnor> no wonder I can't print to my printer
09:27:51 <RayNbow`> maltem: here it takes at least several minutes to load a page
09:27:52 <yitz> jpcooper: or let r = reads x in not (null r) && not (null $ concatMap snd r)
09:28:01 <jpcooper> thank you
09:28:17 <Olathe> > liftM2 (liftM2 (*)) [[a, b], [c, d]] [[e, say "f"], [say "g", say "h"]]
09:28:18 <lambdabot>   [[a * e,a * f,b * e,b * f],[a * g,a * h,b * g,b * h],[c * e,c * f,d * e,d *...
09:28:22 <joma> faaaaaak
09:28:24 <joma> such a pita
09:28:47 <quicksilver> Olathe: cute but not quite right ;)
09:29:02 <Olathe> > let kronProd = liftM2 (liftM2 (*)) in kronProd [[1,2],[3,1]] [[0,3],[2,1]]
09:29:04 <joma> i ant split a list because i need to divie but i cant index with fractional int+
09:29:04 <lambdabot>   [[0,3,0,6],[2,1,4,2],[0,9,0,3],[6,3,2,1]]
09:29:13 <quicksilver> Olathe: damn, yes it is.
09:29:19 <quicksilver> same mistake I made last time.
09:29:23 <hugo___> :)
09:29:24 <Olathe> > let km a b = (map.map) (\x -> (map.map) (*x) b) a in concatMap (foldl1 (zipWith (++))) $ km [[1,2],[3,1]] [[0,3],[2,1]]
09:29:25 <lambdabot>   [[0,3,0,6],[2,1,4,2],[0,9,0,3],[6,3,2,1]]
09:29:33 <quicksilver> joma: use `div` for integer division.
09:29:37 <Olathe> liftM2++
09:29:53 <yitz> roconnor: heh. that happened to me once also. i've since tried to convince my neighbors to password protect their wifi, to no avail.
09:33:12 <yitz> joma: what is the 2.5 element of a list?
09:33:32 <joma> int(2.5) -> 2
09:33:35 <joma> anyway
09:34:01 <joma> if i need to flatten a list 3 times, how do i call repeat rather than explicitly write flatten 3 times
09:34:02 <joma> ?
09:34:03 <yitz> joma: so use `div` instead of /, as quicksilver says.
09:34:08 <joma> did already
09:34:19 <yitz> joma: flatten?
09:35:15 <joma> > let flatten = foldl1 (++) in flatten [[1,2],[3,4]]
09:35:18 <lambdabot>   [1,2,3,4]
09:35:22 <Olathe> > let repeat f 0 = id; repeat f n = repeat f (n - 1).f in repeat concat 3 [[[[[[1, 2]]]]]]
09:35:23 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
09:35:23 <lambdabot>        Expect...
09:35:27 <Olathe> Bah.
09:35:49 <baaba> joma, think about the types
09:35:52 <baaba> it's not gonna work
09:36:06 <Olathe> @type let repeat f 0 = id; repeat f n = repeat f (n - 1).f in repeat concat 3
09:36:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
09:36:07 <lambdabot>       Expected type: [[a]] -> [[a]]
09:36:07 <lambdabot>       Inferred type: [[a]] -> [a]
09:36:50 <baaba> > iterate (+1) 1 !! 3
09:36:51 <lambdabot>   4
09:37:17 <baaba> but you'd have to have a differently typed flatten in each iteration
09:37:35 <joma> lets say i want to repeatedly walk over a list and pick elemtns acording to an interval elemtns froma list untilt here are no more. how?
09:38:02 <joma> i need matrix-> kroncker -> array -> matrix
09:38:11 <joma> i have matrix -> kronecker -> flattend lsit now
09:38:31 <Peaker> joma: map head . takeWhile (not . null) . iterate (drop interval)
09:39:21 <joma> can i check types introspectively?
09:39:27 <joma> wait yes ic an pmatch
09:39:37 <Olathe> > typeOf "hello"
09:39:38 <lambdabot>   [Char]
09:39:44 <Olathe> > show.typeOf $ "hello"
09:39:46 <lambdabot>   "[Char]"
09:39:48 <gnuvince> :t typeOf
09:39:50 <lambdabot> forall a. (Typeable a) => a -> TypeRep
09:39:52 <Olathe> @type show.typeOf
09:39:53 <lambdabot> forall a. (Typeable a) => a -> String
09:40:59 <yitz> joma: it's pretty unusual to check types at runtime like that though. Haskell likes to do type stuff at compile time. that adds a lot of safety.
09:41:15 <joma> deepflatten [] = []
09:41:15 <joma> deepflatten [a] = [a]
09:41:15 <joma> deepflatten [[a]] = deepflatten $ flatten [[a]]
09:41:20 <joma> like how do i pmtach that
09:41:33 <_roconnor> joma: you cannot do that in normal haskell
09:41:35 <_roconnor> sorry
09:42:25 <yitz> _roconnor: so Oleg-speak is not normal haskell?
09:42:30 <Peaker> joma: if you want to have lists of arbitrary nesting, you want a tree, not a list
09:42:37 <_roconnor> yitz: no it isn't :P
09:42:53 <_roconnor> yitz: I'd be impressed if Oleg can do it in Haskell 98
09:43:06 <_roconnor> deepflatten has some serious polymorphism issues
09:43:22 <_roconnor> it isn't parametric afaik
09:44:27 <_roconnor> ah Peaker has a good point.  Things like this can be done with a new datatype.
09:44:30 <vixey> joma, that doesn't even make sense
09:44:49 <vixey> joma, you want to turn arbitrary [[[...[[a]]...]]] into [a] ?
09:45:02 <_roconnor> vixey: makes sense to me
09:45:14 <vixey> the def joma gives I don't understand it
09:45:41 <_roconnor> well, of course.  you cannot write this function as is.
09:45:52 <_roconnor> so obviously joma's def isn't right
09:45:57 <vixey> in lisp you would not even write it like that
09:46:01 <_roconnor> and hence he is asking for help in #haskell
09:46:16 <vixey> _roconnor, ok..................................... I was asking for elucidation incase I could help them
09:46:27 <_roconnor> ok
09:47:01 <dolio> Clearly he's working in some variant of System F with pattern matching on types.
09:48:03 <lilac> _roconnor: you can do it quite easily, if you're prepared to write 'instance DeepFlatten a' for every 'a' you want at the leaf of your trees
09:48:10 <ddarius> @google "Intensional type analysis"
09:48:13 <lambdabot> http://citeseer.ist.psu.edu/480800.html
09:48:14 <lambdabot> Title: Higher-order intensional type analysis - CiteSeerX
09:48:16 <vixey> I would not use typeclasses to write this program
09:48:28 <lilac> vixey: GADTs? ;-)
09:48:30 <_roconnor> lilac: yes, that would be one solution
09:48:45 <_roconnor> Peaker's new datatype would probably be better
09:48:45 <vixey> lilac, how did you know :p
09:49:32 <_roconnor> data Tree a = Leaf a | [Tree a]
09:49:48 <mauke> ENOCONS
09:50:23 <_roconnor> err
09:50:27 <_roconnor> missing a constructor
09:50:32 <_roconnor> data Tree a = Leaf a | Branch [Tree a]
09:52:54 <Olathe> flatten (Leaf a) = [a]; flatten (Branch xs) = concatMap flatten xs
09:53:38 <Deewiant> ?src flatten
09:53:39 <lambdabot> Source not found.
09:53:48 <Deewiant> lambdabot--
09:53:59 <Deewiant> anyhoo, that's Data.Tree
09:55:22 <nothingmuch> i'm trying to get timing info from Network.HTTP. I think th emost logical approach is to wrap all the stream hooks from Network.TCP, does that make sense?
09:55:22 <Gracenotes> hm. singleton lists could be considered comonads, no?
09:55:41 <nothingmuch> and if so, how do I get the default hooks? there doesn't seem to be an obvious way in the docs
09:55:53 <_dolio> You mean the identity comonad?
09:55:55 <Olathe> show (Leaf a) = show a; show (Branch xs) = ('{':).(++"}").intersperse ','.map show $ xs
09:56:04 <Gracenotes> possibly.
09:56:23 <Gracenotes> based on the type definition, it seems like comonads should be used in a few places... I can't think of any, though
09:56:36 <Olathe> Maybe intercalate instead of intersperse.
09:58:46 <Gracenotes> maybe a TreeSum comonad? where extract takes a tree and returns the sum
09:59:32 <pk> >  map (*(0:+1)) [1..10]
09:59:34 <lambdabot>       No instance for (Enum (Complex t))
09:59:34 <lambdabot>        arising from the arithmetic s...
09:59:35 <Gracenotes> you could do mytree =>> \a -> Tree (Leaf a) mytree
09:59:36 <joma> how could i compose a function that groups element by n and then takes eveyr nth group?
09:59:48 <Gracenotes> speaking of trees, anyway :/
09:59:53 <vixey> joma, got bored of your previous question?
10:00:05 <Olathe> joma: Can you give an example ?
10:00:09 <pk> what's the problem with enum ?
10:00:52 <pk> @type fromEnum
10:00:54 <lambdabot> forall a. (Enum a) => a -> Int
10:00:56 <Gracenotes> @instances Enum
10:00:56 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
10:01:01 <Peaker> joma: example?
10:01:02 <Gracenotes> Num isn't included, afaik
10:01:05 <Olathe> > let f n xs = map (take n).takeWhile (not.null).iterate (drop n) xs in f 3 [1..]
10:01:06 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
10:01:08 <Gracenotes> :t [1..10]
10:01:09 <lambdabot> forall t. (Enum t, Num t) => [t]
10:01:18 <Gracenotes> oh... hm.
10:01:26 <sclv__> no instance for complex though.
10:01:34 <sclv__> maybe we should have one?
10:01:40 <pk> @type [0,0.1..]
10:01:44 <lambdabot> forall t. (Enum t, Fractional t) => [t]
10:01:52 <sclv__> although i suppose there's no single "right" enumeration for them.
10:01:56 <yitz> > let f n = map (take n).takeWhile (not.null).iterate (drop n) in f 3 [1..]
10:01:59 <pk> can I convert this list to complex od Double ?
10:02:03 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
10:02:32 <Gracenotes> > (*(0:+1)) 1
10:02:33 <lambdabot>   0.0 :+ 1.0
10:02:41 <Olathe> > let f n xs = map (take n).takeWhile (not.null).iterate (drop (n*n)) $ xs in f 3 [1..]
10:02:43 <lambdabot>   [[1,2,3],[10,11,12],[19,20,21],[28,29,30],[37,38,39],[46,47,48],[55,56,57],...
10:02:46 <Olathe> Like that ?
10:02:52 <pk> > [0,0,1..] :: [Double]
10:02:53 <lambdabot>   <no location info>: parse error on input `..'
10:03:01 <pk> > [0,0.1..] :: [Double]
10:03:03 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
10:03:19 <Peaker> Olathe: nicer to get rid of the xs than to put $ there? :)
10:03:27 <yitz> > [0,0.1..] :: [Complex]
10:03:28 <Olathe> Perhaps :)
10:03:29 <lambdabot>       `Complex' is not applied to enough type arguments
10:03:29 <lambdabot>      Expected kind `*...
10:03:38 <yitz> > [0,0.1..] :: [Complex Double]
10:03:39 <lambdabot>       No instance for (Enum (Complex Double))
10:03:39 <lambdabot>        arising from the arithme...
10:03:51 <sclv__> although diagonalization is arguably the obviously "most right" thing.
10:03:52 <Olathe> > [0, 0.1..] :: [CReal]
10:03:55 <lambdabot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1....
10:04:07 <Olathe> > let f n = map (take n).takeWhile (not.null).iterate (drop (n*n)) in f 3 [1..]
10:04:08 <lambdabot>   [[1,2,3],[10,11,12],[19,20,21],[28,29,30],[37,38,39],[46,47,48],[55,56,57],...
10:04:09 <Gracenotes> Enum (Complex t) also makes sense if only the real part or only the complex part is used
10:04:16 <Gracenotes> I don't think there's a way for the type system to check, though
10:04:17 <Olathe> > let f n = map (take n).takeWhile (not.null).iterate (drop (n*n)) in f 2 [1..]
10:04:18 <lambdabot>   [[1,2],[5,6],[9,10],[13,14],[17,18],[21,22],[25,26],[29,30],[33,34],[37,38]...
10:04:25 <yitz> > map (:+ 0) [0,0.1..] :: [Complex CReal]
10:04:27 <lambdabot>   [0.0 :+ 0.0,0.1 :+ 0.0,0.2 :+ 0.0,0.3 :+ 0.0,0.4 :+ 0.0,0.5 :+ 0.0,0.6 :+ 0...
10:04:31 <joma> well i need to rearrange the list. repeatedly take elem 1 and 3 for example until null
10:05:24 <sclv__> Gracenotes: I don't follow... why can't an enumeration step through both portions of a complex?
10:05:46 <Gracenotes> it could. I'm not sure how useful that would be, though.
10:06:01 <Olathe> > let f (a:b:c:xs) = a:c:f (b:xs); f xs = xs in f [1..]
10:06:03 <lambdabot>   [1,3,2,5,4,7,6,9,8,11,10,13,12,15,14,17,16,19,18,21,20,23,22,25,24,27,26,29...
10:06:06 <sclv__> you just get the cross product of the partial enumerations...
10:06:07 <Olathe> Like that ?
10:06:35 <Gracenotes> you'd want [1..10] :: Complex Int to be 1+0i...10+0i, not 1+1i..10+10i
10:06:41 <Gracenotes> if I get your drift
10:06:45 <sclv__> and only varying one or the other portion falls out as a special case.
10:07:03 <Olathe> > map (:+ 0) [1..10]
10:07:05 <lambdabot>   [1.0 :+ 0.0,2.0 :+ 0.0,3.0 :+ 0.0,4.0 :+ 0.0,5.0 :+ 0.0,6.0 :+ 0.0,7.0 :+ 0...
10:07:31 <Gracenotes> > map (0 :+) [1..10]
10:07:32 <lambdabot>   [0.0 :+ 1.0,0.0 :+ 2.0,0.0 :+ 3.0,0.0 :+ 4.0,0.0 :+ 5.0,0.0 :+ 6.0,0.0 :+ 7...
10:07:45 <Gracenotes> oh, that's good.
10:07:48 <Olathe> > map (join (:+)) [1..10]
10:07:49 <lambdabot>   [1.0 :+ 1.0,2.0 :+ 2.0,3.0 :+ 3.0,4.0 :+ 4.0,5.0 :+ 5.0,6.0 :+ 6.0,7.0 :+ 7...
10:07:56 <Gracenotes> :t map (0 :+)
10:07:58 <lambdabot> forall t. (RealFloat t) => [t] -> [Complex t]
10:08:16 <dons> woo http://www.reddit.com/r/programming/comments/7qtug/the_docuverse_visualizing_15_million_documents_on/
10:08:16 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
10:08:36 <sclv__> gracenotes: well, that and [1 :+ 1.. 10 :+ 10]  gives [1 :+ 1,  2 :+ 1... 10 :+ 1, 1 :+ 2, 2 :+2...]
10:08:50 <sclv__> although probably diagonalized.
10:09:29 <Gracenotes> hm
10:09:54 <Gracenotes> or, in order of absolute value :)
10:10:20 <sclv__> sure -- better, but trickier to write :-)
10:10:58 <sclv__> unless i'm being dim and they're actually the same.
10:11:13 <Gracenotes> hm. I'm not positive either.
10:12:15 <Olathe> > let (a :+ b) ... (c :+ d) = zipWith (:+) [a..c] [b..d] in (1.0 :+ 5.0) ... (10.0 :+ 14.0)
10:12:16 <lambdabot>   [1.0 :+ 5.0,2.0 :+ 6.0,3.0 :+ 7.0,4.0 :+ 8.0,5.0 :+ 9.0,6.0 :+ 10.0,7.0 :+ ...
10:12:17 <Gracenotes> well, no. One portion would be in the order 3:+1, 2:+2, 1:+3, I think
10:12:52 <sclv__> > (:+) <$> [0..3] <*> [4..6] -- the simple, non-diagonal solution
10:12:53 <lambdabot>   [0.0 :+ 4.0,0.0 :+ 5.0,0.0 :+ 6.0,1.0 :+ 4.0,1.0 :+ 5.0,1.0 :+ 6.0,2.0 :+ 4...
10:13:17 <Olathe> > let seq (a :+ b) (c :+ d) (e :+ f) = zipWith (:+) [a,c..e] [b,d..f] in (1.0 :+ 5.0) ... (10.0 :+ 14.0)
10:13:19 <lambdabot>   Couldn't match expected type `[a]'
10:13:30 <mak__> :t <$>
10:13:32 <lambdabot> parse error on input `<$>'
10:13:40 <mak__> :t (<$>)
10:13:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:13:45 <Olathe> > let seq (a :+ b) (c :+ d) (e :+ f) = zipWith (:+) [a,c..e] [b,d..f] in seq (1.0 :+ 5.0) (2.0 :+ 5.1) (10.0 :+ 6.0)
10:13:46 <lambdabot>   [1.0 :+ 5.0,2.0 :+ 5.1,3.0 :+ 5.199999999999999,4.0 :+ 5.299999999999999,5....
10:13:48 <sclv__> zipwith is no good for this -- we want the cross product, which in the list monad is `ap`
10:15:08 <Gracenotes> :t runOmega
10:15:10 <lambdabot> Not in scope: `runOmega'
10:15:25 <dolio> , [$ty| runOmega |]
10:15:28 <lunabot>  forall a . (Omega a) -> [] a
10:15:47 <dolio> , [$ty| diagonalize |]
10:15:49 <lunabot>  luna: Exception when trying to run compile-time code:
10:15:54 <dolio> , [$ty| diagonal |]
10:15:57 <lunabot>  forall a . ([] ([] a)) -> [] a
10:15:58 <vixey> , src ''Omega
10:16:00 <lunabot>  newtype Omega a = Omega {runOmega :: ([a])}
10:16:23 <vixey> , runOmega (Omega (do a <- [1..10]; b <- "foo"; return (a,b)))
10:16:24 <lunabot>  luna: Not in scope: data constructor `Omega'
10:16:35 <lilac> seems like "Enum a => Complex a" should have enumFromThenTo but none of the other enum* methods
10:16:36 <vixey> hi shapr
10:16:58 * lilac once again wonders whether typeclasses-have-only-one-method is valuable
10:17:13 <dolio> > diagonalize [[ x :+ y | x <- [a,b,c]] | y <- [d,e,f]]
10:17:14 <lambdabot>   Not in scope: `diagonalize'
10:17:22 <dolio> , diagonal [[ x :+ y | x <- [a,b,c]] | y <- [d,e,f]]
10:17:23 <lunabot>  luna: No instance for (GHC.Float.RealFloat Luna.SimpleReflect.Expr)
10:17:40 <dolio> , diagonal [[ x :+ y | x <- [1..3]] | y <- [1..3]]
10:17:41 <lunabot>  [1.0 :+ 1.0,2.0 :+ 1.0,1.0 :+ 2.0,3.0 :+ 1.0,2.0 :+ 2.0,1.0 :+ 3.0,3.0 :+...
10:18:14 <vixey> why isn't Omega a constructor
10:18:23 <ddarius> lilac: Why wouldn't they be?
10:18:40 <lilac> ddarius: why wouldn't what be?
10:19:01 <lilac> i'm suggesting introducing a restriction that typeclasses can only have a single method
10:19:10 <ddarius> lilac: Okay, I misread you then.
10:19:19 <vixey> lilac, for what reason?
10:19:21 <ddarius> lilac: Clean effectively works that way.
10:19:47 <lilac> vixey: almost every prelude typeclass could beneficially be split up
10:19:55 <lilac> the only exception i think is Eq
10:20:00 <Olathe> I hate how they I can use some of the methods in a class, but not all of them.
10:20:04 <Olathe> Like this :
10:20:08 <vixey> well split them up but why bother enforcing that?
10:20:13 <Olathe> > toRational (5::CReal)
10:20:14 <lambdabot>   * Exception: CReal.toRational
10:20:20 <Olathe> Nice exception there.
10:20:32 <ddarius> Olathe: That class is just jacked up.
10:20:51 <ddarius> :t toRational
10:20:52 <lambdabot> forall a. (Real a) => a -> Rational
10:21:00 <Olathe> I find myself wanting to use, say, mod and div, but not the other methods in Integral.
10:21:01 <ddarius> The very type is insanity.
10:21:14 <vixey> > toRational pi
10:21:16 <lambdabot>   884279719003555%281474976710656
10:21:20 <dublpaws> it sounds like curry'izing polymorphic architecture, by allowing only one method per typeclass.
10:21:31 <Peaker> lilac: one-method-per-typeclass sounds like a good guideline
10:21:39 <Gracenotes> , map (\(c) -> sqrt $ (imagPart c)^2 + (realPart c)^2) $ diagonal [[ x :+ y | x <- [1..3]] | y <- [1..3]]
10:21:40 <lunabot>  [1.4142135623730951,2.23606797749979,2.23606797749979,3.1622776601683795,...
10:21:43 <vixey> seems arbitrary to me
10:21:50 <Peaker> rule of thumb, not an absolute
10:21:55 <ddarius> I think there are decent examples of classes that shouldn't be split up.  Such as Ix.
10:22:02 <vixey> , map (\(c) -> sqrt $ imagPart c^2 + realPart c^2) $ diagonal [[ x :+ y | x <- [1..3]] | y <- [1..3]]
10:22:03 <lunabot>  [1.4142135623730951,2.23606797749979,2.23606797749979,3.1622776601683795,...
10:22:03 <ddarius> Or random
10:22:10 <sclv__> what about show? how could one split that up...
10:22:12 <dolio> I eagerly await "(HasPi n, HasExp n, HasSin n, HasCos n, HasTan n) => n -> n"
10:22:20 <ddarius> dolio: See Clean.
10:22:29 <mmorrow> , fft (diagonal [[ x :+ y | x <- [1..3]] | y <- [1..3]])
10:22:29 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
10:22:30 <lunabot>  [15.0 :+ 15.0,(-3.8284271247461907) :+ (-0.41421356237309653),(-1.0000000...
10:22:31 <Gracenotes> oh, yeah. Application binding and so on
10:22:50 <Peaker> dolio: its unlikely you're going to need all those :-)  Also, class aliases
10:22:50 <Gracenotes> , map magnitude $ diagonal [[ x :+ y | x <- [1..]] | y <- [1..]]
10:22:51 <lunabot>  [1.4142135623730951,2.23606797749979,2.23606797749979,3.1622776601683795,...
10:23:01 <ddarius> HasEulerMascheroni
10:23:18 <sclv__> mmorrow: what lib are fft and diagonal from?
10:23:25 <ddarius> Peaker: It's highly likely that you could need all of those.
10:23:27 <sclv__> lib (s)
10:23:27 <Twey> 18:19:47 < lilac> vixey: almost every prelude typeclass could beneficially be split up
10:23:31 <Twey> lilac: Ord?
10:23:34 <yitz> lilac: how about all of the transcendental functions in Floating? all of the IEEE-related stuff should go together. etc.
10:23:40 <Twey> Enum?
10:23:45 <dolio> Peaker: Great, so we can do more typing for classes that should actually have more than one method. :)
10:23:46 <sclv__> partial orders.
10:23:48 <mmorrow> diagonal is from monad-omega, and fft is from pure-fft
10:23:57 <vixey> mmorrow, what's going on here?
10:23:59 <sclv__> minbounds do not -> maxbounds :-)
10:23:59 <vixey> , src ''Omega
10:24:02 <lunabot>  newtype Omega a = Omega {runOmega :: ([a])}
10:24:03 <vixey> , runOmega (Omega (do a <- [1..10]; b <- "foo"; return (a,b)))
10:24:04 <lunabot>  luna: Not in scope: data constructor `Omega'
10:24:11 <vixey> Omega not a data constructor?
10:24:26 <mmorrow> hmm
10:24:29 <sclv__> nice. i hadn't seen pure-fft before
10:24:39 <vixey> I guess I should have wrote  Omega [1..10],  though, but anyway
10:24:41 <dons> hehe http://www.reddit.com/r/programming/comments/7qvdp/fizzbuzz_and_the_state_monad/
10:24:41 <ddarius> vixey: It's not in scope.
10:24:54 <lilac> Twey: Enum was where we started. Complex supports enumFromThenTo but none of the rest
10:25:08 <mmorrow> sclv__: i have a newer version actually that does part of it in one pass where it didn't before, it's pasted somewhere
10:25:13 <mmorrow> i should upload that right now
10:25:34 <vixey> ddarius, but I think it should be in scope
10:25:36 <mmorrow> sclv__: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=515
10:25:55 <lilac> Twey: Ord is broken. Why must I define equality and comparison to implement min and max?
10:25:56 <dolio> , [$ty| pick |]
10:25:58 <lunabot>  luna: Exception when trying to run compile-time code:
10:26:17 <mmorrow> , pick
10:26:18 <lunabot>  luna: Not in scope: `pick'
10:26:20 <dolio> , [$ty| each |]
10:26:22 <lunabot>  forall a . ([] a) -> Omega a
10:26:47 <ddarius> vixey: I'd think Omega would be an abstract data type.
10:26:58 <vixey> , runOmega (do a <- each [1..10]; b <- each "foo"; return (a,b))
10:26:59 <lunabot>  [(1,'f'),(1,'o'),(2,'f'),(1,'o'),(2,'o'),(3,'f'),(2,'o'),(3,'o'),(4,'f'),...
10:27:30 <vixey> , runOmega (sequence map each [[1..],[1..],[1..]])
10:27:31 <Peaker> @type each
10:27:31 <lunabot>  luna: Couldn't match expected type `[t -> a]'
10:27:33 <lambdabot> Not in scope: `each'
10:27:36 <vixey> , runOmega (sequence (map each [[1..],[1..],[1..]]))
10:27:37 <lunabot>  [[1,1,1],[1,1,2],[2,1,1],[1,2,1],[2,1,2],[3,1,1],[1,1,3],[2,2,1],[3,1,2],...
10:28:06 <vixey> , runOmega (do [x,y,z] <- sequence (map each [[1..],[1..],[1..]]; guard (x*x+y*y=z*z); return (x,y,z)))
10:28:07 <lunabot>  luna: parse error on input `;'
10:28:17 <vixey> , runOmega (do [x,y,z] <- sequence (map each [[1..],[1..],[1..]]); guard (x*x+y*y=z*z); return (x,y,z)))
10:28:18 <lunabot>  luna: parse error on input `='
10:28:24 <vixey> , runOmega (do [x,y,z] <- sequence (map each [[1..],[1..],[1..]]); guard (x*x+y*y==z*z); return (x,y,z)))
10:28:25 <lunabot>  luna: parse error on input `)'
10:28:28 <vixey> :/
10:28:50 <joma> is there a function to take [1,2,3] difference [1,2] -> 3?
10:29:06 <gal_bolle> (//)
10:29:10 <vixey> joma, hi
10:29:11 <lilac> yitz: "data MyNum a = Zero | One | a :* MyNum a | Sin (MyNum a)" doesn't have all transcendental functions
10:29:12 <Peaker> @type (//)
10:29:13 <gal_bolle> but you'd get [3]
10:29:14 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
10:29:19 <Peaker> @type (\\)
10:29:20 <joma> vixey hi!
10:29:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:29:27 <lilac> yitz: replace Sin with Exp for a more realistic example
10:29:30 <vixey> joma, I asked you couple questions earlier..
10:29:35 <Peaker> > [1,2,3] \\ [1,2]
10:29:36 <lambdabot>   [3]
10:29:41 <Peaker> @src (\\)
10:29:42 <lambdabot> (\\) = foldl (flip delete)
10:30:21 <Peaker> when is it preferable to use foldl over foldr?
10:30:25 <vixey> lilac, I suppose it's impossible to write a data that has them all
10:31:08 <lilac> vixey: i meant all the ones in Floating ;-) but yes
10:31:10 <vixey> Peaker, if you are folding with a commutative operator like (+) or (*), foldl'
10:31:34 <Peaker> vixey: I might not want it to be strict?
10:31:38 <vixey> ((+) may not be commutative though, in cases like  Succ x + y = Succ (x + y)
10:31:48 <lilac> Peaker: if your operator is strict, then foldl', otherwise foldr
10:31:57 <Peaker> also, when is foldl preferred to foldr (not foldl')?
10:32:06 <dolio> The only time you should use foldl is when you're implementing reverse.
10:32:07 <Peaker> (\\) above uses foldl
10:32:17 <dolio> Any other time you should use foldl'. :)
10:32:44 <lilac> @wiki Foldr Foldl Foldl'
10:32:44 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
10:33:10 <Peaker> lilac: thanks
10:33:14 <joma> i missed them
10:33:17 <ddarius> dolio: You might as well use foldl' for reverse too, it's just that there is no difference with foldl in that case.
10:33:26 <dolio> Yeah.
10:33:52 <vixey> joma, you want to turn arbitrary [[[...[[a]]...]]] into [a] ?
10:34:24 <joma> http://cpp.ninjacodemonkeys.org/5043 <- isnt possible in haskell you say`?
10:34:37 <joma> thats pretty weak
10:34:39 <Peaker> who registered foldl.com and foldr.com? :)
10:34:45 <vixey> joma, are you ignoring me still?
10:34:50 <dolio> > [1,2,3] \\ [1..100000]
10:34:52 <lambdabot>   []
10:34:56 <dolio> > [1,2,3] \\ [1..1000000]
10:34:57 <lambdabot>   []
10:34:58 <mauke> Peaker: better question: who registered flickr.com but not flickl.com?
10:35:07 <Peaker> :-)
10:35:10 <int80_h> you jusy *had* to go there
10:35:12 <gnuvince> flickr1.com
10:35:12 <dolio> > [1,2,3] \\ [4..1000000]
10:35:13 <nomeata> Hi. Has anyone considered to make xhtml supposedly faster by using ByteStrings?
10:35:13 <yitz> > length $ foldl (flip (:)) [] [1..10^6]
10:35:14 <lambdabot>   [1* Exception: stack overflow
10:35:16 <lambdabot>   1000000
10:35:17 <sjanssen> joma: it is possible in Haskell, just not convenient
10:35:19 <joma> vixey: yes aribtrary deep, like the link above
10:35:21 <joma> mauke: good one
10:35:24 <Gracenotes> anyone working on scanl.com?
10:35:26 <mmorrow> joma: you need to use a Tree, then it's easy
10:35:27 <yitz> > length $ foldl' (flip (:)) [] [1..10^6]
10:35:29 <sjanssen> joma: also, what possible use could you have for this in real code?
10:35:30 <lambdabot>   1000000
10:35:30 <vixey> joma, it's very difficult to try and have a two way communication with you
10:35:34 <Peaker> joma: any python expert will tell you not to use that python code, either
10:35:36 <Twey> 'The answer is that GHC uses a lazy reduction strategy. This means that GHC only reduces an expression when its value is actually needed. '
10:35:37 <Gracenotes> meh, it seems scanr.com is taken
10:35:41 <bos> @seen dcoutts
10:35:42 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 8h 18m 58s ago.
10:35:45 <Twey> I understood that Haskell numbers were strict?
10:35:46 <yitz> > length $ foldl (flip (:)) [] [1..10^7]
10:35:47 <Twey> Gracenotes: Aw :)
10:35:48 <mmorrow> because that's essentially just flattening a Tree that has vals only at leaves
10:35:57 <dolio> > foldl' (flip delete) [1,2,3] [4..1000000]
10:36:02 <vixey> joma, if you want me to explain one way to do that (?) come to #haskell-overflow :)
10:36:04 <lambdabot>   thread killed
10:36:10 <lambdabot>   [1* Exception: stack overflow
10:36:34 <lilac> Twey: depends what you mean by 'Haskell numbers' :)
10:36:47 <Twey> Int, I think
10:36:49 <joma> vixey: sorry
10:37:00 <mmorrow> , Node Nothing [Node Nothing [fmap (return . Just) [0..4]], Node (Just 99) []]
10:37:01 <lunabot>  luna: Couldn't match expected type `Data.Tree.Tree a'
10:37:01 <Twey> Or possibly (Integral a) => a in general
10:37:08 <joma> yes the python code is not optimal
10:37:20 <lilac> Twey: also depends what you mean by 'strict', since strictness usually applies to functions
10:37:43 <mmorrow> , Node Nothing [Node Nothing [fmap (return . Just) [0..4]]]
10:37:44 <lunabot>  luna: Couldn't match expected type `Data.Tree.Tree a'
10:37:48 <mmorrow> um
10:37:52 <Twey> lilac: I meant that a redex like (1 + 2) is evaluated as soon as the (+) is encountered, rather than when it's needed
10:38:07 <mmorrow> , Node Nothing [Node Nothing [fmap (\x->Node(Just x)[]) [0..4]]]
10:38:09 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe a'
10:38:12 <lilac> Twey: if you mean, 'has values which are neither minima nor maxima under definedness' then Int has that property but Nat does not
10:38:19 <mmorrow> whats happening
10:38:23 <lilac> (for data Nat = Zero | Succ Nat)
10:38:26 <mmorrow> oh
10:38:29 <mauke> > const () ((1 `div` 0) + 2)
10:38:33 <lambdabot>   ()
10:38:41 <mmorrow> , Node Nothing [Node Nothing (fmap (return . Just) [0..4]), Node (Just 99) []]
10:38:42 <lunabot>  Node {rootLabel = Nothing, subForest = [Node {rootLabel = Nothing, subFor...
10:38:45 <Twey> Indeed
10:38:49 <lilac> Twey: (1 + 2) for Ints is evaluated as soon as the result is needed
10:39:01 <Twey> Huh.
10:39:03 <mmorrow> , catMaybes . flatten $  (Node Nothing [Node Nothing (fmap (return . Just) [0..4]), Node (Just 99) []])
10:39:04 <lunabot>  [0,1,2,3,4,99]
10:39:07 <lilac> no intermediate thunk is formed; the compiler's smart enough to see it's about to be forced
10:39:23 <lilac> but "const 42 (1 + 2)" doesn't do the calculation
10:39:35 <Twey> I see
10:39:43 <mmorrow> data T a = Tip [a] | T [T a]
10:39:56 <lilac> denotationally, this strictness analysis makes no difference, operationally it's a pure optimization
10:39:58 <dolio> joma: You can flatten rose trees in Haskell, too.
10:40:12 <dolio> joma: We just recognize that they're rose trees in the type system, instead of using ad-hoc nested arrays.
10:40:14 <mmorrow> deepFlatten (Tip xs) = xs; deepFlatten (T ts) = concatMap deepFlatten ts
10:41:28 <lilac> what's a rose tree? google doesn't seem to know
10:41:44 <joma> I want: [[[[5.0,6.0],[7.0,8.0]],[[10.0,12.0],[14.0,16.0]]],[[[15.0,18.0],[21.0,24.0]],[[20.0,24.0],[28.0,32.0]]]]
10:41:44 <mmorrow> one with a list on subtrees
10:41:44 <joma> -> [5,6,10,12,7,8,14,16,15,18,20,24,21,24,28,32]
10:41:45 <Twey> mmorrow: But then how does one create a T?
10:42:01 <Twey> Oh, wait, silly me.
10:42:10 <lilac> mmorrow: data RoseTree a = Branch [RoseTree a] | Leaf a ?
10:42:16 <Peaker> joma: so specifically: [[[a]]] -> [a] ?
10:42:17 <Twey> That question made sense in my head.
10:42:19 <mmorrow> T [Tip [0..9], T [Tip [32]]]
10:42:30 <Peaker> @type concat . concat
10:42:33 <lambdabot> forall a. [[[a]]] -> [a]
10:42:41 <dolio> lilac: Or Branch a [RoseTree a] | Leaf, depending on what kind of tree you're after.
10:43:02 <dolio> Actually, Leaf is superfluous there, I think.
10:43:02 <lilac> dolio: that sounds like the data structure I'd call a 'Tree' ;-)
10:43:07 <sjanssen> > [[[[5.0,6.0],[7.0,8.0]],[[10.0,12.0],[14.0,16.0]]],[[[15.0,18.0],[21.0,24.0]],[[20.0,24.0],[28.0,32.0]]]]
10:43:08 <lambdabot>   [[[[5.0,6.0],[7.0,8.0]],[[10.0,12.0],[14.0,16.0]]],[[[15.0,18.0],[21.0,24.0...
10:43:25 <Twey> But roses grow on bushes anyway >.<
10:43:26 <vincenz> he wants transpose
10:43:27 <sjanssen> > concat . concat . concat . concat $ [[[[5.0,6.0],[7.0,8.0]],[[10.0,12.0],[14.0,16.0]]],[[[15.0,18.0],[21.0,24.0]],[[20.0,24.0],[28.0,32.0]]]]
10:43:28 <lambdabot>       No instance for (Fractional [a])
10:43:28 <lambdabot>        arising from the literal `5.0' ...
10:43:50 <vincenz> notice, 5,6,10,12,7,8,14,16
10:43:56 <sjanssen> > concat . concat . concat $ [[[[5.0,6.0],[7.0,8.0]],[[10.0,12.0],[14.0,16.0]]],[[[15.0,18.0],[21.0,24.0]],[[20.0,24.0],[28.0,32.0]]]]
10:43:57 <lambdabot>   [5.0,6.0,7.0,8.0,10.0,12.0,14.0,16.0,15.0,18.0,21.0,24.0,20.0,24.0,28.0,32.0]
10:43:57 <dons> hpaste is down.
10:44:23 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
10:44:25 <mmorrow> :)
10:44:26 <vincenz> sjanssen: ^^
10:44:28 <dolio> lilac: Anyhow, the idea is that each interior node has arbitrarily many children, instead of two or three, or whatever.
10:44:36 <dons> gwern: xmonad-untils fails to build.
10:44:47 <vincenz> > concat . concat . concat $
10:44:48 <lambdabot>   <no location info>: parse error on input `;'
10:45:00 <dolio> , src ''Tree
10:45:03 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
10:45:09 <mmorrow> dons: is that code gwern was talking about that added stuff to gitit avail anywhere?
10:45:13 <dolio> , src ''Forest
10:45:16 <lunabot>  type Forest a = [Tree a]
10:45:16 <dons> no?
10:45:30 <dolio> Yeah, no Leaf necessary in those.
10:45:30 <mmorrow> i dunno where to look
10:45:42 <mmorrow> (i did look, but couldn't find it)
10:45:48 <int80_h> dons: there's been a debate going on here about what the authors of RWH intended with their exercises. It makes sense to me, that you'd want people to only use the parts of the language introduced in given exercises. Agree, or disagree?
10:46:40 <dons> yeah. though we never really decided what the exercises were for.
10:47:23 <int80_h> dons: well I for one would have missed some inportant lessons about pattern matching if I had done the exercises in the most efficient/haskell-like way.
10:47:44 <dons> yeah, the idea is that you use the tools in the chapter
10:47:59 <Twey> Haha, Forest a = [Tree a]
10:48:08 <int80_h> oooh, can I get lambdabot to quote that?
10:48:21 <gwern> int80_h: the forest thing?
10:48:23 <int80_h> @quote dons yeah, the idea is that you use the tools in the chapter
10:48:24 <lambdabot> No quotes match. Sorry.
10:48:27 <mmorrow> gwern!
10:48:28 <int80_h> oops
10:48:32 <gwern> mmorrow!
10:48:38 <gwern> int80_h: it's @remember
10:48:43 <int80_h> gwern: I'm still on chapter three. The graham scan algorithm thing
10:48:56 <gwern> int80_h: althouhg I don't know why you'd want to immortalize it in lb
10:49:00 <mmorrow> gwern: so what is the happening with the gitit stuff you're doing?
10:49:08 <int80_h> @remember dons - yeah, the idea is that you use the tools in the chapter
10:49:08 <lambdabot> Okay.
10:49:15 <gwern> mmorrow: dunno. what's the last thing you heard?
10:49:37 <int80_h> gwern: so the next time someone hassles me about insisting on artificial restriction, I can quote one of the authors.
10:49:40 <mmorrow> gwern: i heard you make a side comment in here yesterday about added darcs support to it
10:49:52 <ztirF> @pl h x y = g (f x) (f y)
10:49:52 <lambdabot> h = (. f) . g . f
10:49:58 <int80_h> @quote dons
10:49:58 <lambdabot> dons says: Don "If it ain't pure, it ain't functional" Stewart
10:50:05 <gwern> mmorrow: yes
10:50:15 <BMeph> ztirF: That function is know as "on". :)
10:50:20 <dons> i wonder how these quotes got in here.
10:50:21 <ddarius> > on f g x y
10:50:23 <lambdabot>   Add a type signature
10:50:25 <mmorrow> gwern: yay! is there a darcs repo anywhere?
10:50:27 <ddarius> > on f g x y :: Expr
10:50:28 <lambdabot>   Add a type signature
10:50:36 <gwern> mmorrow: gitit is in a git repo, obviously
10:50:37 <ztirF> @hoogle on
10:50:38 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:50:38 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
10:50:38 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
10:50:41 <Stephan202> @pl \a b -> evalState (runErrorT a) b
10:50:41 <int80_h> hmm, how do I get lamdbabot to quote my quote?
10:50:41 <lambdabot> evalState . runErrorT
10:50:47 <BMeph> @src on
10:50:48 <lambdabot> (*) `on` f = \x y -> f x * f y
10:50:50 <ztirF> rockin
10:50:55 <mmorrow> gwern: oh. so these changes have been pushed.
10:50:56 <gwern> mmorrow: darcs get http://johnmacfarlane.net/repos/filestore
10:51:03 <mmorrow> who'lda thunk it
10:51:11 <mmorrow> oh
10:51:15 <gwern> mmorrow: and then there's a funky incantation you need to do in a gitit repo to switch to the filestore branch
10:51:16 <mmorrow> filestore?!?
10:51:23 <mmorrow> sweet
10:51:28 * int80_h wishes he would have registered foldr and foldl
10:51:30 <dolio> > on (f :: Expr -> Expr -> Expr) g x y
10:51:32 <lambdabot>   f (g x) (g y)
10:51:32 <lilac> > f `on` g :: Expr
10:51:34 <lambdabot>   Couldn't match expected type `Expr'
10:51:51 <lilac> > (f ~> f) g
10:51:52 <lambdabot>       Overlapping instances for Show (a -> c)
10:51:53 <lambdabot>        arising from a use of `s...
10:52:22 <dolio> > (h ~> f) g x
10:52:23 <lambdabot>   Add a type signature
10:52:26 <dolio> > (h ~> f) g x :: Expr
10:52:28 <lambdabot>   Add a type signature
10:52:30 <dolio> Bah.
10:52:40 <mmorrow> oh shit yesh. filestore does what i was gonna hack gitit to do myself.
10:52:52 <dolio> > ((h :: Expr -> Expr) ~> f) g x
10:52:53 <lambdabot>   Add a type signature
10:53:07 <dolio> > ((h :: Expr -> Expr) ~> (f :: Expr -> Expr)) (g :: Expr -> Expr) x
10:53:09 <lambdabot>   f (g (h x))
10:53:18 <lilac> > (h ~> f :: (Expr -> Expr) -> Expr -> Expr) g a :: Expr
10:53:20 <lambdabot>   f (g (h a))
10:53:40 <int80_h> @quote dons idea
10:53:40 <lambdabot> dons says: yeah, good idea. use C++ as the prototyping language
10:53:54 <mmorrow> gwern: nice.
10:53:57 <int80_h> @quote dons chapter
10:53:57 <lambdabot> dons says: - yeah, the idea is that you use the tools in the chapter
10:54:05 <dolio> > (f ~> h) (g :: Expr -> Expr) x :: Expr
10:54:06 <lambdabot>   h (g (f x))
10:54:13 <mmorrow> gwern: sqlite is key also.
10:54:28 <gwern> mmorrow: I've actually been wondering who would use the sqlite backend
10:54:30 <dolio> Annotation golf.
10:54:39 <gwern> it's not like anyone stores any repos in sqlite
10:54:40 <mmorrow> (even more key would be to store either git or darcs repos *in* an sqlite db)
10:54:48 <gwern> waaah
10:54:51 <mmorrow> heh
10:55:03 <gwern> mmorrow: orchid also uses filestore now in svn
10:55:09 <mmorrow> then you can use SQL TO SELECT AND QUERY AND ARCHIVE
10:55:19 <mmorrow> cool, i'll check it out
10:58:00 <skorpan> i have an ifthenelse and an IO Bool which i want to use as the condition in the ifthenelse. is there any smart way to solve that?
10:58:13 <BONUS> bind the IO bool
10:58:19 <BONUS> a <- yourIOBool
10:58:20 <skorpan> no other way?
10:58:25 <BONUS> if a then do blah else do blooh
10:58:31 <vixey> skorpan, no other way than the right way
10:58:45 <skorpan> i see.
10:58:49 <blackdog> skorpan: if you do it a lot, maybe write a combinator that does that?
10:58:57 <skorpan> no, this is just a one-off
10:59:01 <BONUS> don't think of an IO Bool as a Bool, think of it as an I/O action that will eventually have inside it some kind of Bool
10:59:04 <vixey> blackdog, you could call it (>>=) :p
10:59:05 <BONUS> :]
10:59:15 <skorpan> BONUS: right, but that doesn't really help me find a better way :P
10:59:37 <BONUS> hehe
10:59:41 <BONUS> whats wrong with binding the action?
10:59:53 <skorpan> nothing, i just thought maybe i could learn something here
11:00:08 <vincenz> You did, you laerned this is the right way :)
11:00:15 <skorpan> cool, thanks :P
11:00:17 <blackdog> vixey: it wouldn't be the first time i reinvented the wheel :) but does that do quite the right thing? I was thinking maybe "ifM :: IO Bool -> IO a -> IO a -> IO a
11:00:28 <skorpan> blackdog: yeah, that's kind of what i thought as well
11:00:29 <BONUS> the best thing to do is to structure your code so that there's as little code with IO thrown around as possible
11:00:34 <Twey> bif' b c a = if a then b else c
11:00:45 <skorpan> or maybe ifM :: m Bool -> m a -> m a -> m a
11:00:49 <skorpan> if that makes any sense
11:01:00 <Twey> yourIOBool >>= return . bif' foo bar
11:01:06 <vincenz> why?
11:01:08 <vincenz> you acn make that more generic
11:01:14 <vincenz> ifM :: m Bool -> a -> a -> a
11:01:14 <blackdog> skorpan: ooh, generic :) i'm still stuck in the world of using monads for IO
11:01:29 <Twey> Hmmm
11:01:29 <skorpan> vincenz: never thought of that!
11:01:35 <Twey> vincenz: Not really
11:01:43 <skorpan> no? :|
11:01:46 <Twey> vincenz: Think of the m = IO case
11:01:47 <bombshelter13> Is there something like zip, but that gives [a] -> [b] -> [[a,b]] instead of [a] -> [b] -> [(a, b)]? I.e., returns a list of lists?
11:01:47 <vincenz> Twey: sure, now you're not forced to use monadic values
11:01:55 <Twey> vincenz: You can't extract the m Bool
11:02:00 <vincenz> point taken
11:02:01 <Twey> (making it useless)
11:02:04 <vincenz> m Bool -> a -> a -> m a
11:02:07 * Twey nods.
11:02:08 <BONUS_> gah i got disconnected. what happen
11:02:09 <vincenz> duh me
11:02:13 <vincenz> Twey: been a while :)
11:02:21 <Twey> Heh
11:02:32 <skorpan> i wonder why this hasn't been implemented...
11:02:33 <vincenz> I meant, using haskell :)
11:02:38 <skorpan> i'm sure they had good reasons not to?
11:02:50 <vincenz> skorpan: it's not used that often?
11:03:15 <blackdog> bombshelter13: i don't think so - the tuple version tends to be more useful because a and b have different types
11:03:18 <Twey> vincenz: Because nobody cares about it :-P
11:03:19 <skorpan> don't ask me, i don't know! :o
11:03:33 <blackdog> bombshelter13: sorry, _can_ have different types
11:03:56 <vixey> m Bool -> a -> b -> m (Either a b)
11:03:59 <Gracenotes> mif (Maybe True) 1 0 -> Maybe 1, right?
11:04:02 <bombshelter13> blackdog: hm, I'll have to see about cooking up my own then. :/
11:04:18 <vincenz> vixey: or more generically
11:04:23 <vixey> ?djinn Either a a -> a
11:04:24 <lambdabot> f a =
11:04:24 <lambdabot>     case a of
11:04:24 <lambdabot>     Left b -> b
11:04:24 <lambdabot>     Right c -> c
11:04:26 <BMeph> Does anyone know what commands you'd need to do to get the on-disk HTML pages to connect the package pages back to the main index page? :)
11:04:27 <blackdog> but [ [x,y] | (x,y) <- zip a b] would do it, if the types match
11:04:28 <Gracenotes> *just 1
11:04:29 <vincenz> m Bool -> (a -> c) -> (b -> c) -> a -> b -> c
11:04:34 <vincenz> m Bool -> (a -> c) -> (b -> c) -> a -> b -> m c
11:04:42 <Gracenotes> and mif Nothing 1 0 -> Nothing or Just 0?
11:04:45 <Peaker> If Miranda was also a lazy functional language, how did it handle side effects?
11:04:54 <vincenz> rearrange a bit and then yours is simply: myif Left Right
11:04:54 <vrthra> hello,
11:04:59 <blackdog> Peaker: poorly? :P
11:04:59 <vrthra> noob question.
11:05:15 <vrthra> I tried > import System.Process
11:05:26 <vrthra> > readProcess "date" [] []
11:05:28 <lambdabot>   Not in scope: `readProcess'
11:05:32 <blackdog> i think they had the idea of modelling the environment as a list of inputs, and modeling output as a lazy list
11:05:43 <vrthra> I got it from hoogle,
11:05:43 <dublpaws> (f (f (f myList a b) c d) e f)   where f::[Char]->[Char]   -- is there a, (magicFunction f myList [a,c,d] [b,c,d]) ?
11:05:51 <vrthra> what is the correct incantation?
11:06:00 <Twey> Peaker: It didn't
11:06:08 <vixey> dublpaws, you can probably write it though?
11:06:31 <dmead> vrthra, you don't have access to io in lambdabot
11:06:36 <dmead> it's for security
11:06:41 <dublpaws> maybe vixey ;)
11:06:44 <vrthra> ok,
11:06:59 <sw17ch> @seen dons
11:06:59 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 16m 39s ago.
11:07:06 <vrthra> what is the way to read io from system ?
11:07:25 <vixey> o_o #concatenative ?
11:07:36 <vrthra> > main = do
11:07:38 <lambdabot>   <no location info>: parse error on input `='
11:07:39 <lament> i think they talk about Joy there
11:07:45 <lament> oh, Factor
11:07:47 <vrthra> >  [x] <- readProcess "pwd" [] []
11:07:48 <lambdabot>   <no location info>: parse error on input `<-'
11:07:55 <vixey> But I thought dons was faithful to haskell!
11:08:12 <ddarius> vixey: Tomorrow he'll be in #java
11:08:32 * edwardk pokes nomeata.
11:08:38 <gwern> @version
11:08:38 * vixey will be checking java.reddit tommorow
11:08:38 <lambdabot> lambdabot 4.2.2
11:08:38 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:09:00 <vrthra> I get the same error as lambdabot gave.
11:09:09 <gwern> my lb repo is corrupt. \_\ that's unfortunate
11:09:15 <Twey> vrthra: Of course you do
11:09:30 <gwern> (1849 patches, and lb is still buggy)
11:09:39 <Twey> vrthra: The <- syntax is only valid within a do expression (and not on the last line)
11:09:57 <vrthra> oh,
11:09:57 <ddarius> gwern: Number of patches doesn't help if you have patches that add bugs as well as remove them.
11:10:07 <vixey> and (<-) /should/ be valid inside types, but it isn't
11:10:13 <Twey> Aye
11:10:26 <gwern> ddarius: yes, I'm just reflecting - all this development work, and yet...
11:10:48 <gwern> kind of like darcs I suppose; too old and hacked-upon for its own good
11:10:52 <BONUS> <- in types would be... interesting
11:11:06 <BONUS> (+) :: (Num a) => a <- a <- a
11:11:21 <ddarius> gwern: Again, stuff has mostly been added or twiddled with in lambdabot, not fixed.  Also lambdabot is and has always been put together with gum and shoe straps.
11:11:24 <vrthra> so if I add an expression like > putStrLn "tst"
11:11:28 <vixey> BONUS, (read (<-) as from)    (.) :: (c <- b) -> (b <- a) -> (c <- a)
11:11:33 <vrthra> as the last line,
11:11:48 <ddarius> Most of the early development has been by relative beginners.
11:11:49 <BONUS> oh hmm
11:12:10 <ddarius> vixey: I've definide :<- recently.
11:12:14 <Saizan> gwern: do you have the privileges to setup a trac for lambdabot?
11:12:20 <gwern> Saizan: no
11:12:30 <gwern> I have not that privilege, sieur!
11:12:45 <vrthra> I have the same error :( , any pointers
11:12:51 <Saizan> don't you just need to be in the lambdabot group on code.haskell.org?
11:13:18 <gwern> Saizan: well, no one's come to me and said, by the bye you could set up a trac for lb if you wanted to
11:13:55 <Twey> Haha
11:14:17 <gwern> although I probably wouldn't bother - more interesting to just rewrite lambdabot, or figure out how to turn gitit into a bug tracker or something like that
11:14:21 <Saizan> gwern: i'm talking about this: http://community.haskell.org/admin/using_project.html
11:14:41 <vincenz> gwern: even if they did, they would have to say "you *may*"
11:15:11 <dons> heya sw17ch
11:15:19 <gwern> vincenz: it's a free country, no one could forbid me from it - so the question is whether it is feasible, 'could'
11:15:25 <dublpaws>  (zip ['a'..'c'] ['A'..'C'])
11:15:31 * sw17ch notes that @seen shuold be aliased to @summon
11:15:33 <sw17ch> hi dons
11:15:40 <dons> heh
11:19:09 <vixey> but haskell is a CPO category if you ignore seq?
11:19:47 <nikki93> Hey guys!
11:19:49 <vrthra>  this doesn't seem to have readProcess "strings /usr/local/lib/ghc-6.8.2/lib/process-1.0.0.0/System/Process.hi | grep readProcess"
11:20:02 <vrthra> is there a package I need to install?
11:20:08 <nikki93> I have some stupid science test tomorrow, and its even multiple choice (choices given, just tick).
11:20:10 <nikki93> Bah.
11:20:18 <pumpkin> use haskell
11:20:31 <intoverflow> @faw Can Haskell get you an A?
11:20:31 <lambdabot> The answer is: Yes! Haskell can do that.
11:20:34 <Saizan> vrthra: readProcess is in later versions of the process package
11:20:49 <vrthra> thanks.
11:20:56 <wmoxam> Haskell makes me breakfast every morning
11:20:57 <intoverflow> lambdabot is pretty typo-forgiving
11:21:06 <ziman> whoa, 636 nicks on #haskell
11:21:13 <ddarius> @users
11:21:13 <lambdabot> Maximum users seen in #haskell: 653, currently: 636 (97.4%), active: 38 (6.0%)
11:21:38 <gwern> intoverflow: yeah, it does prefix-matching, so as long as your string is 'unique' then it'll work
11:21:44 <gwern> @fa can lambdabot match this?
11:21:44 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber ft
11:21:57 <gwern> intoverflow: not to mention some clever edit distance stuff, iirc
11:21:59 <lilac> @fat cat sat on mat
11:22:00 <lambdabot> Maybe you meant: fact faq ft
11:22:00 <intoverflow> gwern: noted.  also, cool.
11:22:07 <mauke> @zaq is this a prefix?
11:22:07 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:25 <gwern> 'f' is only two keys away from 'z'
11:22:25 <intoverflow> @faq Can Haskell refinance my mortgage?
11:22:25 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:27 <Twey> 'zaq'?
11:22:31 <ziman> i guess it uses something like levenshtein distance
11:22:39 <mauke> yeah, max distance is 2
11:22:55 <Twey> gwern: Lies.  'f' is six keys away.
11:23:06 <gwern> ziman: correct; see lambdabot-utils/Lambdabot/Util.hs
11:23:16 <gwern> Twey: what bizarre keyboard you using?
11:23:16 <lilac> @paq Can Haskell determine my keyboard layout over IRC?
11:23:17 <lambdabot> The answer is: Yes! Haskell can do that.
11:23:31 <Twey> gwern: Dvorak 4 laif!!1one
11:23:36 <vixey> nobody?
11:23:47 <gwern> lolrak
11:23:55 <pumpkin> @faq can haskell epic fail?
11:23:55 <lambdabot> The answer is: Yes! Haskell can do that.
11:24:00 * lilac wishes for a reverse-i-search in irssi
11:24:02 <intoverflow> vixey: is hask cpo?  doesn't cpo require products?
11:24:14 <Peaker> lilac: amazing how no IRC client has that :(
11:24:23 <gwern> lilac: if wishes were fishes
11:24:31 <Peaker> lilac: all the GUI ones also seem to copy the braindead IE4-style find dialog from each other
11:24:34 <gwern> lilac: what's wrong with the irssi r-search script?
11:24:39 <gwern> works well for me
11:24:56 <lilac> gwern: the primary problem with it is that i don't know that it exists, where to find it or how to use it :)
11:25:10 <gwern> lilac: that's all easily remedied
11:25:12 <joma> http://cpp.ninjacodemonkeys.org/5045
11:25:16 <gwern> now you know it exists cuz of me
11:25:23 <intoverflow> vixey: sorry, I was confusing issues; I don't know if my statement is correct
11:27:01 <lilac> gwern: scripts.irssi.org doesn't list it ;-(
11:27:50 <gwern> lilac: whine whine whine... it's called history_search.pl
11:28:14 <h0tzenpl0tz> > putStr "foobar"
11:28:16 <lambdabot>   * Exception: "<IO ()>"
11:28:18 <lilac> gwern: either the doc is misleading or that only searches things i've typed
11:28:36 <h0tzenpl0tz> > map (2*) [1,2,3,4]
11:28:36 <gwern> well, yeah
11:28:38 <lambdabot>   [2,4,6,8]
11:28:44 <gwern> that's what reverse isearch does
11:29:00 <lilac> in bash, yes. in emacs it searches the buffer.
11:29:40 <gwern> because it would be crazy to reverse isearch the terminal output
11:29:48 <gwern> unless you're in screen or something
11:30:40 <gwern> where you can use the usual risearch and then screen's terminal output search
11:30:55 <lilac> i want r-i-search on the channel contents, basically
11:31:14 <lilac> anyway, /lastlog seems to do close to what i want, and this is /very/ off-topic, so...
11:32:32 <gwern> I like /lastlog -hilight myself
11:33:15 <joma> hmm can DL.foldl' make something a lot faster than just foldl?
11:33:21 <mauke> @localtime preflex
11:33:21 <lambdabot> Local time for preflex is 2009-01-19 19:33WHERE IS SARAH CONNOR?
11:33:30 <Deewiant> O_o
11:33:31 <mmorrow> haha
11:33:40 <gwern> you silly person
11:34:22 <mmorrow> "wolfy's fine honey, wolfy's just fine."
11:34:50 <gwern> the dog is a lie!
11:36:01 <Peaker> why is it encouraged to name data constructors differently from the type constructors?
11:36:14 <ddarius> Peaker: It isn't.
11:36:24 <pumpkin> onoes! it's called bool!
11:36:29 <vixey> I use  newtype Scope a = Scope a  often
11:36:32 <pumpkin> apparently every other language calls it boolean!
11:36:34 <Peaker> ah, ok
11:36:36 * vixey steals haskell code from papers
11:36:41 <Twey> pumpkin: C++ doesn't
11:36:46 <skorpan> can i instantiate something of this effect: instance Show [MyDataType] where?
11:36:56 <pumpkin> Twey: I'm just mocking *ahem* on -cafe
11:36:57 <pumpkin> :)
11:37:01 <Twey> Oh :-P
11:37:07 <gwern> I like 'bool'; boolean is so tedious to type out in full
11:37:13 <intoverflow> @faq can i instantiate something of this effect: instance Show [MyDataType] where?
11:37:13 <lambdabot> The answer is: Yes! Haskell can do that.
11:37:28 <vixey> gwern, how about calling it 2
11:37:33 <Twey> gwern: I concur
11:37:39 <Twey> Haha, 2
11:37:40 <gwern> haskell doesn't define a 'instance (Show a) => Show [a] where'?
11:37:46 <ddarius> skorpan: You probably want instance Show MyDataType and define showList
11:37:51 <skorpan> ddarius: ah
11:38:17 <intoverflow> yeah, else there might be multiple-class-instance problems
11:38:36 <joma> which is the easiest algorithm for solving Ax=B in linear algebra?
11:38:48 <joma> easiest to implement, doesn matter if it is a naive one
11:38:59 <vixey> guassian elimination
11:39:01 <intoverflow> probably Gaussian elimination
11:40:07 <Twey> ax = b -> x = b / a
11:40:36 <Twey> What is a ShowS?
11:40:43 <mauke> @src ShowS
11:40:43 <lambdabot> type ShowS = String -> String
11:40:58 <ddarius> f^-1(A)=f^T(AI)/det(f)
11:40:58 <Twey> Hmm
11:41:02 <intoverflow> well, for matricies it'd be ax = b -> x = a^{-1} b, which generally uses gaussian elimination to find a^{-1}
11:41:07 <mauke> > shows 42 "suffix"
11:41:08 <lambdabot>   "42suffix"
11:41:18 <Twey> Ah
11:41:40 <Peaker> the best algorithm for matrix inversion is O(n^sqrt(7)) or something like that, right?
11:41:46 <Twey> So you're meant to define something like showList = ("foo" ++)?
11:42:10 <ddarius> Using your notation A^-1(x) = A^T(xI)/det(A) where I is the pseudoscalar.
11:42:37 <intoverflow> Peaker: that might be the best deterministic algorithm, but there are wacky probabilistic algorithms that work when the application is solving systems of linear eqs
11:42:43 <Twey> Instead of just showList "foo"
11:42:51 <Twey> Er
11:42:56 <Twey> = "foo"
11:42:58 <Twey> I wonder why...
11:43:18 <ddarius> Twey: For the same reason DList exists.
11:43:25 <ddarius> ShowS = DList String
11:43:36 <Toxaris> Twey: its faster.
11:43:37 <Twey> And what reason is that?
11:43:44 <Twey> I've never even heard of a DList
11:43:46 <Twey> Toxaris: How so?
11:43:48 <mauke> Twey: http://hackage.haskell.org/packages/archive/dlist/0.4.1/doc/html/Data-DList.html
11:43:51 <ddarius> Twey: To avoid left associative uses of (++)
11:44:17 <jutaro> Is code.haskell.org down? I can't reach it
11:44:19 <Peaker> Twey: (++) has to copy the entire list to append another list
11:44:44 <Peaker> Twey: often, you're (++)'ing between lists that you build, so you can just build them concat'd in the first place, instead of copying them
11:44:50 <Twey> Aha
11:45:13 <Peaker> Twey: so instead of returning a list that needs to be copied later, you return a function that will build that list, and put the given list as the last element rather than putting [] as the last element
11:45:44 <Peaker> @type showString
11:45:45 <lambdabot> String -> String -> String
11:45:51 <Peaker> or: String -> ShowS
11:46:13 <Peaker> @type shows
11:46:15 <lambdabot> forall a. (Show a) => a -> String -> String
11:46:49 <Twey> O(spine)?
11:47:01 <Peaker> > (showString "Hello" . shows 5 . shows "Hello") ""
11:47:03 <lambdabot>   "Hello5\"Hello\""
11:47:32 <Peaker> Twey: plumbing those functions together is as easy as (.)
11:47:37 <Peaker> Which turns out to be cute :)
11:47:43 <Twey> That's true
11:47:51 <Toxaris> Twey: of course, with DList / ShowS, each character has to be copied, but only once, while with left-recursive uses of ++, characters have to be copied more then once.
11:48:02 * Twey ponders instance Monad String
11:48:14 <mauke> Twey: kind error
11:48:20 <Peaker> Toxaris: why do they have to be copied anyway?
11:48:24 <Twey> Oh, yeah :(
11:48:36 <mauke> > "foo" >> "bar"
11:48:38 <lambdabot>   "barbarbar"
11:48:54 <mauke> > "foo" <* "bar"
11:48:55 <lambdabot>   "fffoooooo"
11:48:59 <sbahra> > "food" >> "bar"
11:49:00 <lambdabot>   "barbarbarbar"
11:49:04 <Toxaris> Peaker: (("a" ++ "b") ++ "c") is ("ab" ++ "c") with 'a' copied, which is "abc" with 'a' and 'b' copied again, so 'a' is two times copied
11:49:15 <ddarius> Peaker: If you have ("foo"++) it will still be copied, but if you have (\xs -> 'f':'o':'o':xs) it won't.
11:49:17 <sbahra> :t (<*)
11:49:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:49:28 <pumpkin> sbahra: that's useful!
11:49:41 <ddarius> :t ($>)
11:49:42 <Peaker> ddarius: I am wondering why Toxaris said its 1, not zero, copies.. I don't see any redundant copying in the ShowS case?
11:49:42 <lambdabot> Not in scope: `$>'
11:49:50 <ddarius> :t (<$)
11:49:52 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
11:50:02 <jutaro> please: can someone try if code.haskell.org is down?
11:50:06 <Toxaris> Peaker, ddarius: Maybe I mean copied cons cells, not characters
11:50:14 <ddarius> Toxaris: So do I.
11:50:14 <Peaker> I prefer flip of that
11:50:20 <Peaker> Toxaris: why are cons cell copied even once in the ShowS case?
11:50:51 <ddarius> Peaker: It depends on the definition of the particular ShowS value.
11:50:55 <baaba> > 5 <$ ['c']
11:50:56 <lambdabot>   [5]
11:50:58 <Peaker> If you have showStrnig "blah" -- then sure, but if you have \xs -> 'b':'l':'a':'h':xs -- then the cons cells are created, not copied
11:51:05 <ddarius> The former example I gave will copy, the latter won't.
11:51:08 <Toxaris> Peaker: Good question. I guess ddarius is just right. (Good default that, anyway).
11:51:09 <baaba> > 5 <$ "hello"
11:51:11 <lambdabot>   [5,5,5,5,5]
11:51:50 <montyhall> i have a basic functional thinking question. if i have a "box" to display, is it a collection of functions that give it's positions? or is that too oop?
11:52:25 <baaba> x <$ ys = fmap (const x) ys?
11:52:27 <ddarius> montyhall: Why wouldn't it just be the data that describes it?
11:52:28 <Peaker> montyhall: you can use a type-class, or a tuple of functions..
11:52:29 <lament> if all your program does is display boxes, a four-number tuple is enough
11:52:31 <ddarius> baaba: Yes.
11:52:59 <montyhall> i'm trying too understand the "no state" aspect, which i do not
11:53:21 <vixey> montyhall, 'no state' is a red herring
11:53:31 <vixey> probably some catch phrase a beginner thought up
11:53:51 <montyhall> so it is a "collection of data" then?
11:53:57 <montyhall> which makes more sense to me
11:55:16 <jutaro> next and last try: can someone PLEASE check if code.haskell.org is down? Really a mundane question here :(
11:55:30 <vixey> jutaro, why does it matter?
11:55:50 <montyhall> jutaro: that url is not connecting for me
11:56:18 <jutaro> I try to commit something, so it seems to be down and I can stop for today
11:56:35 <vixey> jutaro, so do it tommorow
11:56:58 <jutaro> thanks for the good advice
11:57:34 <montyhall> so if i have my box, say [10, 10, 10] (whatev), and it has a matrix function that applies and changes those values - does that seem right?
11:58:18 <montyhall> i know this is 101 stuff, i'm just trying to graps the basics
11:58:28 <dublpaws> data Point = newPoint{x::Int, y::Int}    data Box = newBox {topLeft :: Point, topRight :: Point, botLeft :: Point,  botRight:: Point}
11:58:54 <int80_h> montyhall: have you worked through a tutorial?
11:59:27 <montyhall> i just started the Real World Haskell book
11:59:33 <int80_h> nice!
11:59:34 <int80_h> me too
11:59:52 <Saizan> jutaro: i can login via ssh
12:00:09 <int80_h> although, three weeks into it, I've spent the majority of time on the final exercise of chapter 3
12:00:38 <eu-prleu-peupeu> hello haskl3z0rs
12:01:06 <ziman> oh hai
12:01:07 * int80_h curses
12:01:08 <montyhall> ive been playing with scheme, but i kinda wanted something that might actually be useful
12:01:08 <jutaro> Saizan: I can do this too, but then I can't continue
12:01:24 <montyhall> which i of course got too by emacs
12:01:54 <int80_h> my sortByCotangent almost works, except the last element should be the second
12:02:04 <int80_h> oh wait
12:02:04 <Lemmih> @seen augustss
12:02:04 <lambdabot> I saw augustss leaving #haskell 1d 1m 51s ago, and .
12:03:04 <int80_h> okay the final value is 5.5555e-2. Is that the same as 5.5555^2
12:03:08 <ddarius> Scheme is probably more "useful" than Haskell by most metrics.
12:03:21 <montyhall> dublpaws: in that example, if i want to change the values of the box, would i effectively be creating a new box?
12:03:29 <ddarius> int-e: No, it's the same as 0.055555
12:03:42 <int80_h> oh nice. then my function works
12:03:54 <Twey> 19:57:34 < montyhall> so if i have my box, say [10, 10, 10] (whatev), and it has a matrix function that applies and changes those values - does that seem right?
12:03:58 <Twey> montyhall: You don't
12:04:04 <int80_h> I meant ^-2, but whatever...I got my answer :)
12:04:10 <Twey> You have instead a function that returns a new 'box'
12:04:12 <Saizan> jutaro: i've pushed some patches successfully, but the webserver is not responding
12:04:15 <ddarius> e-2 means *10^-2
12:04:31 <int80_h> ddarius: thanks :)
12:04:45 <montyhall> so once a box is created - that's it, it's set forever?
12:04:59 <int80_h> well, it's inefficient, but working
12:05:15 <Peaker> montyhall: yes, but it doesn't prevent from new boxes from getting created too
12:06:02 <montyhall> i see. my head is starting to hurt
12:06:15 <jutaro> Saizan: I've just created a track instance and have to register which I can't, and I tried to convert to darcs 2 format, but can't push
12:06:34 <Peaker> montyhall: having more than one box hurts your head? :)
12:07:05 <chessguy> hm, my little theorem-prover is working for very simple theorems, but failing for complex ones. i need to find some in-between ones
12:08:08 <montyhall> so instead of having an "object" which is the box, i have the routine which causes it to move and redisplay - like an animation then
12:08:37 <Saizan> ?seen Igloo
12:08:38 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1h 51m 39s ago.
12:08:46 <coco> hi
12:09:15 <montyhall> but "move and redisplay" isnt the right word, since its a completely new box
12:09:30 <coco> is there a way to model expressions (let's say arithmetic) with type classes?
12:09:40 <coco> (instead of an inductive I mean)
12:11:08 <pumpkin> eu-prleu-peupeu: haskell!
12:11:12 <eu-prleu-peupeu> :D
12:11:48 <nomeata> A concatMap on a lazy bytestring will completely rip apart the bytestring, even if most chars are left unmodified, right?
12:12:08 <eu-prleu-peupeu> when i think of haskell i have this "im going to be poor for the rest of my life" feeling
12:12:32 <dublpaws> montyhall, there are instances of the Box constructed from points.  to make a function which moved the box left, moveBoxLeft :: Int -> Box -> Box \n moveBoxLeft n oldBox = (newBox (newPoint (x (topLeft oldBox) -1) (y topLeft oldBox)) ( newPoint ...
12:12:42 <pumpkin> eu-prleu-peupeu: not sure about that...
12:12:43 <Deewiant> nomeata: well yeah, it can't know beforehand where the ones you're going to modify are :-)
12:12:44 <eu-prleu-peupeu> "i should just stick to the c++ if i want to feed my future children"
12:12:50 <pumpkin> eu-prleu-peupeu: but maybe you will be, who knows
12:13:11 <dublpaws> err 1 should be n, but that's the idea. though I'm still very newbish, so that's probably overkill.
12:13:16 <ziman> that's exactly the feeling i have :)
12:13:23 <nomeata> Deewiant: but you could afterwards observe the unmodfied parts and take larger chunks of the original string together
12:13:40 <eu-prleu-peupeu> there are no jobs in haskell :P
12:13:48 <montyhall> dublpaws: thanks, i think im beginning to understand. dont all these functions start to get unwieldly?
12:14:06 <ddarius> eu-prleu-peupeu: Except for investment banking, but I'm sure they only pay their programmers a pittance
12:14:17 <dublpaws> montyhall: maybe a better way would be to make a function that moves points left, and then define a function moveBoxLeft which employs the movePoint function, pushing the details lower in the program.
12:14:19 <pumpkin> eu-prleu-peupeu: and galois clearly is a shitty job
12:14:22 <int80_h> the world needs code-monkies too
12:14:43 <repnop> there are high paying jobs in almost any language :p
12:14:45 <Deewiant> nomeata: /you/ could yes, but I don't think /it/ can ;-)
12:14:45 <pumpkin> eu-prleu-peupeu: also, even if you don't work in haskell, it "hones your mind" and makes you a better person
12:14:51 <Deewiant> nomeata: TBH I don't know, but I doubt it.
12:14:55 <lament> by 'investment banking' ddarius of course means 'credit suisse'
12:14:55 <int80_h> galois wants forward thinkers
12:15:00 <nolrai_East> do like read and readFile throw old or new Exceptions?
12:15:03 <ddarius> lament: There are several
12:15:10 <nomeata> Deewiant: no, it doesnt (yet)
12:15:23 <coco> where is credit suisse's haskell group based?
12:15:47 <Twey> montyhall: Unwieldy?  No, not at all...
12:15:53 <pumpkin> "Barclays Capital use it for Equity Derivative modeling and pricing - it's a
12:15:53 <pumpkin> small team at the moment, but the whole project is in Haskell."
12:16:01 <pumpkin> eu-prleu-peupeu: are you andrew coppin? :P
12:16:16 <eu-prleu-peupeu> who ?
12:16:17 <coco> where's barclays based?
12:16:23 * eu-prleu-peupeu googles for that name
12:16:25 <eu-prleu-peupeu> im portuguese!
12:16:31 <montyhall> is there collections of functions i can create? like Box.movePoint etc?
12:16:33 <Twey> Hahaha
12:16:34 <dons> pumpkin: hah
12:16:39 <Twey> montyhall: Yes, namespaces
12:16:41 <Twey> Modules
12:16:47 <pumpkin> :)
12:17:01 <pumpkin> eu-prleu-peupeu: http://cufp.galois.com/
12:17:13 <int80_h> let me guess, andrew coppin is a haskell fud spreader?
12:17:16 <dons> eu-prleu-peupeu: you should go do a haskell internship with the UMinho team
12:17:29 <dons> they've got students hacking haskell in industry as part of their grad programs
12:17:36 <int80_h> dons: any haskell internships for people in silicon valley?
12:17:46 <dons> int80_h: hmm. no. some kind of weird mix of fan and troll :)
12:17:54 <dons> int80_h: well, go to the bayFP meetings
12:17:58 <montyhall> ahso my Box.functionXYZ is a collection of functions (module), but not the box itself, just operations that create boxes?
12:18:03 <jpcooper> dons, what's this? I'm looking for an internship for the summer right now
12:18:06 <Twey> montyhall: Right
12:18:18 <Twey> montyhall: What are you, a Java programmer?  :-P
12:18:31 <montyhall> ha, kinda.. as3
12:18:34 <dons> jpcooper: just that UMinho in .pt has a good internship program
12:18:35 <Twey> It'll contain functions to create a box, move a box about, &c.
12:18:35 <int80_h> dons: oh duh. I really should. Also, the guys at Supper Happy Dev House were very interested in my haskell play
12:18:38 <pumpkin> we really need a real faq in here... @realfaq or something (that answers common questions like "does haskell suck?" or "does haskell have any real world applications?")
12:18:39 <Twey> Aha.
12:18:43 <int80_h> *Super
12:18:47 <lament> @faq Does Haskell suck?
12:18:47 <lambdabot> The answer is: Yes! Haskell can do that.
12:18:49 <jpcooper> dons, oh I was hoping to go to America or London
12:19:02 <pumpkin> @realfaq suck
12:19:02 <lambdabot> Unknown command, try @list
12:19:08 <SamB> yes, even if you need suckage, Haskell is there
12:19:13 <dons> but its biazrre that andrew could hang out on the list for so long, but not pick up you know, where the wiki is, or who has jobs, or what is on hackage
12:19:28 <montyhall> but i did a lot of javascript stuff so i got into some of the functional aspects
12:19:33 <dons> jpcooper: you could start by contacting the companies on http://cufp.galois.com/
12:19:38 <RayNbow> @faq Can Haskell be used to program a vacuum cleaner such that Haskell can be suckingly awesome?
12:19:38 <lambdabot> The answer is: Yes! Haskell can do that.
12:19:40 <pumpkin> dons: the tone of some of his questions really strike me as "troll", but other times he sounds quite normal
12:19:41 <smtms> pumpkin, what's wrong with posting a URL to a FAQ when someone asks?
12:19:51 <jpcooper> thanks dons
12:20:00 <pumpkin> smtms: nothing, but we have a bot, might as well take advantage of it :)
12:20:06 <eu-prleu-peupeu> im going to start my own company, totaly haskell based
12:20:06 <sw17ch> @index Arbitrary
12:20:06 <lambdabot> Test.QuickCheck, Debug.QuickCheck
12:20:10 <ray> @go faq
12:20:13 <pumpkin> like "Is it possible to earn money using Haskell? Does anybody here actually do this?"
12:20:16 <lambdabot> http://www.gamefaqs.com/
12:20:16 <lambdabot> Title: Video Game Cheats, Reviews, FAQs, Message Boards, and More - GameFAQs
12:20:20 <pumpkin> it's a very negative question
12:20:25 <ray> yeah, a better result for that
12:20:31 <dons> pumpkin: exactly. that's a trollish question with an insult to trigger reponses
12:20:36 <eu-prleu-peupeu> pumpkin: i know of a guy that does
12:20:40 <eu-prleu-peupeu> here in portugal
12:20:44 <pumpkin> eu-prleu-peupeu: he spoke just before you
12:20:48 <dons> i've asked him about this tone before, and he ignores me. :/
12:20:50 <pumpkin> but at least two people!
12:20:51 <montyhall> if you are a good programmer you can "make money" with anything
12:20:51 <sw17ch> my boss makes money from Haskell and he doesn't even know it!
12:21:05 <pumpkin> montyhall: even three doors?
12:21:08 <repnop> sw17ch: hopefully he wouldn't mind if he found out :)
12:21:13 <dons> sw17ch: :)
12:21:15 <pumpkin> montyhall: of which one hides a prize!
12:21:30 <montyhall> i wrote a turning complete machine using 3 doors!
12:21:32 <RayNbow> hmm, haskell.org wiki is up again (and responsive)... but planet.haskell.org is not
12:21:37 <pumpkin> turning complete!
12:21:39 <pumpkin> @quote wango
12:21:39 <lambdabot> wango says: do you like turing complete?
12:21:42 <sw17ch> repnop: he was okay with me sticking Ruby on an ARM9.. i think using Haskell in a normal environment to generate code is fine :)
12:22:01 <eu-prleu-peupeu> oh well, i guess im going to try out the reactive lib to see if i can do anything with it :P
12:22:25 <repnop> sw17ch: yeah but why ruby on arm? :p
12:22:35 <sw17ch> repnop: it beat using C for the project :)
12:22:38 <pumpkin> ruby on arm :o
12:22:43 <pumpkin> we have ruby on iphone
12:22:47 <pumpkin> but it's slow as hell
12:22:56 <leimy> Jailbroken?
12:22:57 <pumpkin> someone needs to get 1.9 on there
12:22:57 <sw17ch> pumpkin: oh, yes, most definitely :)
12:22:59 <pumpkin> leimy: yeah
12:23:06 <pumpkin> I wanted to use it
12:23:11 <sw17ch> "fast" wasn't a requirement
12:23:11 <leimy> I was going to say... Apple don't like the interpreters
12:23:16 <montyhall> maybe ruby on mono for the iphone
12:23:16 <sw17ch> "done soon" was
12:23:23 <dons> mm. hugs on iphone?
12:23:28 <RayNbow> hmm, is it a good idea to write an x86 asm peephole optimizer while learning TH?
12:23:29 <pumpkin> leimy: they actually don't mind too much, the clause says "you can't run downloaded code of any kind"
12:23:29 <montyhall> jruby for android
12:23:31 <pumpkin> dons: yup :)
12:23:42 <dons> RayNbow: mm. using the llvm bindings?
12:24:01 <RayNbow> dons: I haven't looked at the LLVM bindings at all, but I'm not familiar with LLVM itself
12:24:21 <RayNbow> but I thought that TH might be useful for nicer patterns
12:24:47 <dons> another trollish thing, pumpkin is that he'll ignore the responses
12:25:01 <dons> he won't summarise and say 'oh, thanks'. but just let the thread roll.
12:25:03 <ddarius> It's quite clear that Andrew Coppin has no desire to do any kind of research whatsoever.
12:25:05 <pumpkin> yeah, I've noticed that
12:25:14 <leimy> dons: that andrew fella?
12:25:27 <dons> ddarius: i'm not sure he cares about the results either
12:25:28 <leimy> yeah he doesn't read anything he just whines
12:25:44 <leimy> I think he wants to feel really important and point out that Haskell is broken when it isn't
12:25:47 <ddarius> dons: Why would he?  He has nothing to apply them to.
12:26:16 <pumpkin> it'd be funny if he just lurked in here
12:26:27 <RayNbow> ...since a peephole optimizer basically just tries to match a pattern against a part of the AST, and if the match is successful, it replaces the matched AST subtree with a new AST subtree
12:26:28 <ddarius> pumpkin: Allegedly he was here once.
12:26:28 <dons> he's orpheus in here.
12:26:40 <pumpkin> @seen orpheus
12:26:40 <lambdabot> I haven't seen orpheus.
12:26:44 <pumpkin> :D
12:27:08 <leimy> oh well this channel is logged right?  He can just read that :-)
12:27:17 <dolio> Is it possible for him to make money using Haskell?
12:27:23 <leimy> no not him
12:27:27 <dolio> :)
12:27:29 <pumpkin> maybe he's bitter because he lost eurydice
12:27:30 <leimy> I wouldn't hire him
12:27:36 <augustss_> dolio: yes!
12:27:43 <montyhall> is the jhaskell project lively?
12:27:57 <dons> i'm not sure he a) wants a job , or b) wants to make money from haskell. he just wanted to prove something to someone.
12:27:58 <pumpkin> http://jhaskell.com/ ?
12:27:59 <augustss_> actually, I have no idea :)
12:28:11 <dons> i've noticed lots of questions about jvm backends to haskell this month. clojure buzz for jvm again?
12:28:12 <nolrai_East> @unmlt ErrorT e (State s) r
12:28:12 <lambdabot> Maybe you meant: unmtl unpl
12:28:15 <sw17ch> dons: aren't we all trying to prove something about Haskell? :)
12:28:19 <dons> hehe
12:28:24 <leimy> The JVM is a tough target though
12:28:25 <nolrai_East> @unmtl ErrorT e (State s) r
12:28:25 <lambdabot> s -> (Either e r, s)
12:28:31 <leimy> the VM isn't really designed for !Java
12:28:33 <gwern> @hoogle Int →  IO a →  IO [a]
12:28:33 <lambdabot> Parse error:
12:28:34 <lambdabot>   --count=20 "Int →  IO a →  IO [a]"
12:28:34 <lambdabot>                   ^
12:28:43 <pumpkin> montyhall: check out the things that suck @ http://wiki.brianweb.net/LambdaVM/Implementation
12:28:44 <repnop> the jvm is getting better at least.
12:28:46 <gwern> @hoogle Int ->  IO a ->  IO [a]
12:28:46 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
12:28:46 <lambdabot> Prelude replicate :: Int -> a -> [a]
12:28:46 <lambdabot> Data.List replicate :: Int -> a -> [a]
12:28:56 <repnop> invokedynamic should help some languages
12:28:58 <montyhall> pumpkin: ha, that jack haskell page is funny
12:28:59 <leimy> well I heard Sun wants to take the J out of JVM
12:29:07 <leimy> so it can host other langs
12:29:45 <dons> ddarius: yes, no research, no thinking, no learning, http://www.haskell.org/pipermail/haskell-cafe/2009-January/054001.html
12:29:51 <dolio> Someone who's studied haskell for 2+ years and still doesn't grok functors probably isn't the ideal choice for your haskell work.
12:30:01 <leimy> that's kind of my point :-)
12:30:16 <montyhall> i dont doubt it sucks, i was just wondering if you could use haskell in mobile devices yet anywhere
12:30:17 <leimy> Doesn't sound like much trying was done
12:30:33 <sw17ch> i've studied C for way too long now, and half-duplex UART's still drive me bonkers :\
12:30:52 <leimy> heh
12:30:53 <sw17ch> (when it comes to writing drivers for the protocol in a single-threaded environment)
12:31:12 <leimy> C + threads  == lose :-)
12:31:14 <ddarius> sw17ch: Use protothreads
12:31:17 <leimy> not always, but it's hard to make it win :-)
12:31:21 <sw17ch> ddarius: we are :)
12:31:33 <pumpkin> montyhall: I've made a half-assed effort to port ghc to jailbroken iphone
12:31:37 <sw17ch> ddarius: but not in this piece... this is the part where i need to detect collisions on the bus ... etc...
12:31:38 <pumpkin> montyhall: and hugs already runs on it :)
12:31:44 <loadquo> Where would I find information about the use of => in type signatures?
12:32:10 <pumpkin> loadquo: http://www.haskell.org/tutorial/classes.html maybe?
12:32:30 <leimy> I'd often thought I could know more about haskell classes to be a bit more clever with them.
12:32:43 <leimy> but then i hear that classes are "overused" but never see a specific criticism.
12:32:58 <loadquo> pumpkin: Thanks
12:33:36 <stingeraj> I have a problem with a type-error in a guard from a case-statement. I want do output an error, but hugs reports the type error that [Char] doesnt match the return-type of the function that contains the case-statement.
12:33:42 <dolio> leimy: Just put quicksilver on ignore, then. :)
12:33:50 <leimy> heh
12:34:21 <blackh> leimy: quicksilver talks about them being overused. I am using them to make monads with different "contexts" such as user logged in, read-only, etc.  quicksilver said he thought that was OK.  I say just use them, and if the design looks bad, you will learn with experience.
12:34:26 * pumpkin hugs stingeraj
12:34:45 <stingeraj> can somebody help me?
12:34:45 <leimy> blackh: sure.
12:35:03 <stingeraj> thx, blackh... :-)
12:35:08 <leimy> stingeraj: areyou showing the error?
12:35:10 <stingeraj> but not very helpful
12:35:19 <stingeraj> pls wait a moment.
12:35:28 <leimy> but you asked for help now :-)
12:35:33 <leimy> I'm ready NOW! :-)
12:35:34 <stingeraj> i paste the signature and the line, then the error, ok?
12:35:38 <stingeraj> ok
12:35:40 <leimy> hpaste.org it
12:35:40 <leimy> :-)
12:35:46 <leimy> not to the channel
12:35:47 <dolio> leimy: I think the main example is classes where newtypes are used to select amongst multiple instances for a particular concrete type.
12:36:03 <gwern> any obvious improvement to 'forkIOn ∷  Int →  IO () →  IO [ThreadId]' and 'forkIOn c io = replicateM c (forkIO io)'?
12:36:04 <dolio> Those arguably shouldn't be classes, since they aren't unique for the given type.
12:36:11 <blackh> leimy: So I learnt lots of stuff about them.  MultiParamTypeClasses, FunctionalDependencies and ScopedTypeVariables are the three extensions I've used the most.  It is well worth learning how to use ScopedTypeVariables, but you have to read the GHC documentation very carefully and make sure you understand it all.
12:36:29 <pumpkin> I was watching SPJ's DPH talk yesterday and he's so enthusiastic! it made me want to jump up and down while trying out DPH
12:36:33 <stingeraj> http://www.mibbit.com/pb/QqlmXR
12:36:44 <leimy> I realize the extensions to the language are really helpful, but I still try my best to avoid using them, unless they're really going to pay off.
12:36:49 <blackh> leimy: The key point is that your type variable will not be visible inside your function scope unless you use the 'forall' keyword in your type signature.
12:36:51 <leimy> Also, I'd look for ones that I know will be in Haskell'
12:37:14 <stingeraj> leimy, i have pasted it to mibbit.com as pastebin
12:37:17 <sjanssen> gwern: "forkIOn" is sort of hard to read
12:37:17 <leimy> stingeraj: ok...
12:37:25 <pumpkin> stingeraj: you're outputting the wrong type
12:37:28 <sjanssen> gwern: forkMany?
12:37:32 <RayNbow> pumpkin: the world needs more SPJ videos
12:37:37 <leimy> stingeraj: try doing the concatenation in ()
12:37:46 <leimy> error ("Variable" ++ ...)
12:37:54 <gwern> sjanssen: hey, I didn't name it
12:37:57 <ddarius> gwern: Personally I wouldn't bother naming it.
12:38:05 <gwern> @pl forkIOn c io = replicateM c (forkIO io)
12:38:05 <lambdabot> forkIOn = (. forkIO) . replicateM
12:38:08 <ddarius> I'd just use replicateM n (forkIO io) inline.
12:38:22 <leimy> :t error
12:38:26 <lambdabot> forall a. [Char] -> a
12:38:36 <sjanssen> or more likely replicateM_ (one rarely uses the returned ThreadID)
12:38:37 <stingeraj> oh one note: return type Store is defined as [([Char],Value)] and thats what hugs expects
12:38:37 <ddarius> pumpkin: Yeah, SPJ rocks.
12:38:48 <ddarius> pumpkin: I really liked his STM talk at OSCON.
12:38:58 <stingeraj> leimy which concatenation`?
12:39:05 <leimy> stingeraj: Oh I didn't look carefully :-)
12:39:21 <gwern> sjanssen: actually in this case the threadids are used
12:39:39 <pumpkin> ddarius: thanks, I'll check it out
12:39:41 <olsner> or maybe something like mapM (future . fun) [args] with a definition of future like the one on reddit or planet haskell the other day
12:39:43 <leimy> My suggestion is that if you want to represent errors you use "Maybe Store" or have Store be data with a constructor to hold an error.
12:40:22 <thomashartman1> cabal install haddock error: http://rafb.net/p/TBtxtH60.html
12:40:32 <thomashartman1> anybody else come across this?
12:40:44 <thomashartman1> don't really need haddock per se, just struck me as weird.
12:40:51 <leimy> stingeraj: the problem is that error is never going to be the type that function needs to return, so the function either needs to return another type, or not use error :-)
12:40:55 <sjanssen> gwern: is your list long?  replicateM will use O(n) stack
12:40:58 <stingeraj> leimy but the strange thing is that hugs doesnt complain about such things:
12:41:25 <stingeraj> http://www.mibbit.com/pb/snxhnT
12:41:33 <ddarius> sjanssen: Forking off a million threads is probably not a great idea for resource usage either...
12:41:48 <stingeraj> error in a normal pattern is ok as a mismatched return-type, but fails in case-guard? why?
12:41:48 <kees_> would anybody care to explain to me how category theory is used on theoretical CS?
12:42:12 <gwern> sjanssen: see http://www.reddit.com/r/haskell/comments/7qvq2/taking_a_second_look_at_haskell_a_thread_pool_for/
12:42:44 <stingeraj> leimy error in a normal pattern is ok as a mismatched return-type, but fails in case-guard? why?
12:42:46 <leimy> stingeraj: it may be because the case is an expression that has to return the same type for all possible case matches
12:42:49 <ddarius> kees_: It's related to a lot of foundations, e.g. denotational semantics also the term "co/contravariant" in OO comes from category theory.  It's also used at more applied levels such as recursion schemes.
12:42:57 <stingeraj> leimy good pont
12:43:01 <leimy> It's clearly failing to make you a Store :-)
12:43:02 <stingeraj> leimy good point
12:43:09 <sjanssen> gwern: oh yes, replicateM is a huge improvement there
12:43:13 <ddarius> Incidentally, what languages actually use "boolean" for the boolean type?
12:43:13 <stingeraj> yes, ok i understand.
12:43:28 <sjanssen> ddarius: well, threads are supposed to be fairly lightweight
12:43:29 <kees_> ddarius: ok. can you give me an example please?
12:43:41 <stingeraj> thats a precondition for case that i didnt realize
12:43:48 <sjanssen> ddarius: GHC crashes when the stack overflows, it just gets sluggish when there are too many threads
12:44:05 <ddarius> kees_: An example of what?
12:44:23 <kees_> of how CT is used.
12:44:41 <ddarius> kees_: I gave you one.  The entire field of denotational semantics was inspired by category theory.
12:44:54 <stingeraj> leimy then i have to restructure it to pull the guard outside of the case-stmt. hmm....
12:45:02 <kees_> and what is denotational semantics?
12:45:12 <ddarius> Ask google.
12:45:16 <Botje> evil voodoo which describes how a program works
12:45:19 <kees_> will do
12:45:21 <leimy> Hmmm, well I try to avoid "case" wherever possible
12:45:28 <leimy> but that's me, and I'm new :-)
12:45:30 <Botje> you generally tune it out when reading papers ;)
12:45:31 <vixey> kees_, you write  [[ foo ]] = FOO
12:45:42 <leimy> I've been finding mplus to be pretty nice for dealing with Maybe
12:45:56 <vixey> that's basically how denational semantics work!
12:46:11 <Peaker> you could use: http://tinyurl.com/7cul7b
12:46:44 <Peaker> leimy: and msum, yeah
12:47:08 <byorgey> is code.haskell.org down?
12:47:15 <gwern> I think so
12:47:20 <gwern> I can't get lambdabot
12:47:26 <SubStack> but not in theory
12:47:40 <paulmitchell> kees_: http://en.wikibooks.org/wiki/Haskell/Wider_Theory   not that I can make any sense of it :)
12:47:40 <Peaker> in theory, there is no difference between theory and practice
12:47:51 <dons> woo hwn http://www.reddit.com/r/programming/comments/7qwj4/haskell_weekly_news_curl_web_frameworks_1000/
12:47:54 <dons> byorgey++
12:48:00 <leimy> Peaker: Still typically using things like fmap, mplus and other stuff together.
12:48:15 <vixey> [[ a + b ]] = [[ a ]] + [[ b ]] lol
12:48:23 <vixey> A /\ B is true if A is true and B is true
12:48:24 <vixey> nonsense
12:48:28 <byorgey> ok, another question.  Math.OEIS is broken because of a change in the HTTP package, I think.  Should I (a) require an older version of HTTP, or (b) update OEIS and require the newest version of HTTP?
12:49:00 <Botje> break the fingers of the people who change APIs instead :)
12:49:14 <byorgey> well, to be fair, they did increment the version number by 1000 =)
12:49:15 <loadquo> Peaker: You know capabilities right? Mind looking at a version of sealing/unsealing in haskell, make sure it is right?
12:49:30 <lament> byorgey: i would expect any non-evil library maintainer to do the latter
12:49:33 <gwern> byorgey: update
12:49:50 <sclv__> so code golf time: mapEach :: (a->a) -> [a] -> [[a]]. mapEach (+1) [1..4] = [[2,2,3,4],[1,3,3,4],[1,2,4,4],[1,2,3,5]]
12:49:50 <chessguy> @remember byorgey [on maintaining HWN] "Gee whiz, people, stop being so darn productive or you're going to burn me out. Seriously."
12:49:51 <lambdabot> I will remember.
12:49:54 <Peaker> loadquo: I think I do, I can try
12:50:01 <gwern> :t (>> return ())
12:50:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
12:50:04 <paulmitchell> Botje: oh yes... took me two hours to get the graphics working for the "School of Expression" book... all because things have changed over time
12:50:08 <sclv__> any suggestions for the niftiest way to write that?
12:50:11 <byorgey> ok, cool.  That's what I figured.
12:50:15 <gwern> @hoogle m a -> m ()
12:50:16 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
12:50:16 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
12:50:16 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
12:50:26 <Peaker> :t (() <$)
12:50:27 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
12:50:39 <Peaker> :t (<*)
12:50:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:50:57 <gwern> what's better than 'takeMVar nextTask >>= id'
12:51:08 <ddarius> join (takeMVar nextTask)
12:51:09 <Peaker> @src join
12:51:10 <lambdabot> join x =  x >>= id
12:51:11 <ddarius> @src join
12:51:11 <lambdabot> join x =  x >>= id
12:51:12 <gwern> @hoogle finally
12:51:12 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
12:51:58 <Peaker> I like using blah$>x instead of a separate do statement with "return x"
12:53:06 <loadquo> Peaker: It is here http://haskell.pastebin.com/m6b1be313. Compiles, seems to work. Need to have industrial strength random numbers for the Int passed in.
12:53:15 <gwern> :t (>>= id)
12:53:16 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:53:26 <gwern> @hoogle m (m b) -> m b
12:53:26 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
12:53:26 <lambdabot> Prelude concat :: [[a]] -> [a]
12:53:26 <lambdabot> Data.List concat :: [[a]] -> [a]
12:53:59 <gwern> @hoogle when
12:53:59 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
12:55:22 <joma> http://cpp.ninjacodemonkeys.org/5046 , need translate :: (Python -> Haskell) -> Program -> Program
12:55:38 <Peaker> loadquo: its an interesting idea - you're using n as a key that opens the box, right? And the key is the capability. Not why pass the value itself as the capability?
12:56:07 <jeff__> is it wrong of me to question the wisdom of Clojure?
12:56:28 <Peaker> loadquo: it seems makePair is ignoring its first argument -- it doesn't seem to need it
12:56:50 <loadquo> It makes the sealer/unsealer be the right type, I think.
12:57:36 <loadquo> I think you are supposed to able to seal multiple things with one sealer.
12:57:57 <int80_h> would someone try this url? I'm getting "failure to parse" messages all of a sudden on parts of the page
12:58:03 <joma> jeff__ what dont you like about it?
12:58:17 <int80_h> I've suspected that opera is broken (for other reasons), and I wonder if this is another symptom
12:58:21 <jrh> I was briefly wowed by its homepage and IDE, but then I thought, "O wow, here's a 'functional' programming language with sequential let-binding, a lack of type safety, and no tail-call optimization (with immutable recursively defined data structures)"
12:58:29 <int80_h> http://en.wikipedia.org/wiki/Graham_scan
12:58:38 <jrh> jrh = jeff = jeffersonheard because it whines that my name is already in use
12:58:41 <gwern> http://www.reddit.com/r/haskell/comments/7qvq2/taking_a_second_look_at_haskell_a_thread_pool_for/c0754sx <-- heh, I feel like some sort of Haskell gurur ala cale or dons
12:58:50 <chessguy> jrh:  there are probably good reasons to question it, and bad reasons to do so
12:58:51 <gwern> *guru
12:59:40 <jrh> I understand that they had to give up some things to get an efficient implementation in the JVM and give users a quick and easy way of accessing the java standard library, but
13:00:04 <jrh> then, scala seems to handle these things better and has type-safety
13:00:04 <byorgey> gwern: ok, oeis-0.2.1 uploaded to Hackage!
13:00:09 <dons> well done, gwern. good answer
13:00:31 <gwern> byorgey: great. I'll bump lb's dep then
13:00:42 <jrh> I dunno.  I feel like i'm missing something
13:01:01 <gwern> or... maybe I don't need to, cabal-install should get the latest which'll work, hm
13:01:11 <byorgey> yeah, it should
13:01:11 <loadquo> Peaker: Actually you are right the first value parameter is pointless, I'll try and get rid of it.
13:01:12 <jrh> Oh, and thanks, dons, my blog has gotten 3000 hits since its inception on friday.  They're going to ask me to move it to a different server soon
13:01:21 <jrh> :-)
13:01:22 <byorgey> gwern: but probably safest to bump the dep anyway
13:01:31 <gwern> yeah, no harm
13:01:36 <byorgey> since it does actually depend on the newer version.
13:01:48 <dons> jrh: :D
13:01:53 <dons> wow. that's pretty good.
13:01:55 <chessguy> @pl f c i = r c (g i)
13:01:55 <lambdabot> f = (. g) . r
13:02:00 <Peaker> loadquo: you can just delete it..   so this is meant to be sort of a secure channel?
13:02:07 <jrh> dons: I think it's because of the pictures
13:02:30 <gwern> jrh: 3k hits overloads your server?
13:02:40 <jrh> by itself, no.
13:02:56 <int80_h> jrh: can I have the url to your blog?
13:03:00 <jrh> but there's quite a bit else on that server, not the least of which is my tile-server for the state of NC
13:03:08 <jrh> int80_h http://vis.renci.org/jeff
13:03:09 <ddarius> jrh: I mostly read your blog through the planet haskell aggregator.
13:03:33 <loadquo> Peaker: Yup. You shouldn't be able to get the values wrapped without having the right unsealer. I should also define what happens if you have the wrong unsealer....
13:03:43 <gwern> jrh: I left a msg for you under lb; what's up with the proteinviz license?
13:03:48 <jrh> Oh, I don't mind the hits at all; highly appreciated, actually.  I'm not whining by saying I'll have to move it to a different server
13:04:07 <jrh> lb?
13:04:27 <gwern> lambdabot
13:04:31 <loadquo> Peaker: You can see an example of how to use it here http://en.wikipedia.org/wiki/E_programming_language
13:04:48 <sw17ch> argh, haskell has poisoned my ability to reason in a procedural language
13:04:59 <jrh> oh...  I've never checked those
13:05:05 <jrh> not sure I even know how
13:05:20 <ddarius> sw17ch: Yeah that happens.
13:05:25 <jrh> gwern, what's the problem with the proteinvis license?
13:05:26 <gwern> hmmm... 'haskell is today's BASIC; it cripples the mind of those who know it. Teaching it is a crime'
13:05:27 <ddarius> sw17ch: So much state flying around is hectic.
13:05:28 <paulmitchell> sw17ch: isn't it wonderful?
13:05:30 <sw17ch> my function needs to perform at least 5 side effects per pass
13:05:46 <sw17ch> and i can see all the places it will blow up if things don't happen exactly in order
13:05:46 <jrh> gwern: Who said that?  Stroustrop?
13:05:56 <Twey> Djikstra, wasn't it?
13:05:58 <gwern> jrh: It confuses me. your .cabal disagrees with your LICENSE, which is not in the repo, but which appears to be some bizarre non ISO-approved license based on bsd3
13:05:58 <sw17ch> but it happens in an interrupt vector! so i can't guarantee anything!
13:06:01 <Twey> WRT COBOL
13:06:10 <sw17ch> so the code keeps getting bigger... and i cry a little more with every line
13:06:17 <Twey> sw17ch: Ahahaha
13:06:21 <gwern> er, not ISO, OSI
13:06:25 * sw17ch sobs in a corner
13:06:33 <Peaker> loadquo: seems cool
13:06:36 <gwern> (damn these acryonyms)
13:06:47 <jrh> ah, yes.  Thank the University of North Carolina and our legal department.  Had to change it at the last second and forgot to update the Cabal
13:06:53 <sclv__> > > let mapEach f [x] = [[f x]]; mapEach f (x:xs) = (f x : xs) : map (x:) (mapEach f xs) in mapEach (+1) [1..3]
13:06:54 <lambdabot>   <no location info>: parse error on input `>'
13:06:57 <sclv__> > let mapEach f [x] = [[f x]]; mapEach f (x:xs) = (f x : xs) : map (x:) (mapEach f xs) in mapEach (+1) [1..3]
13:06:59 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
13:07:05 <jrh> Renci has a "standard license" we're supposed to release everything under
13:07:07 <Peaker> gwern: its true, Haskell crippled my mind, I don't find enjoyment in Python anymore :(
13:07:13 <sclv__> any suggestions for how to golf this more?
13:07:13 <gwern> Peaker: see!
13:07:17 <jrh> when we release it
13:07:26 <jrh> Peaker: here, here
13:07:30 <gwern> jrh: pretty bizarre. what was wrong with BSD licenses?
13:07:38 <Peaker> gwern: Now I have to convince all my coworkers that Haskell is awesome, so we can switch to writing Haskell and I can regain joy in my workplace
13:07:41 <jrh> No-one at UNC got paid to write it
13:07:46 * SubStack didn't need to know haskell to start not liking python
13:08:09 <ddarius> sclv__: Can you not use the empty list base case?
13:08:10 <gwern> jrh: I see...
13:08:37 <sclv__> ddarius: with an empty list, i get a list with nothing done to it as well.
13:08:40 <jrh> It's basically a BSD license, though.  You can crib as much as you want off it so long as you retain the license statement.  I'll update darcs tomorrow.  Off today
13:08:55 <gwern> 'k
13:08:56 <ddarius> sclv__: What about mapEach f [] = [[]] ?
13:09:07 <gwern> jrh: remeber to actually include the LICENSE file in the repo this time!
13:09:12 <jrh> yeah, will do
13:09:14 <ddarius> sclv__: Admittedly, I haven't put much thought into this at all
13:09:14 <sclv__> I could add that too, but I still need the one element case.
13:09:16 <jrh> :-)
13:09:33 <h0tzenpl0tz> how can i convert from Integer to Int ?
13:09:43 <ddarius> @quote fromIntegral
13:09:43 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
13:09:44 <pumpkin> fromInteger/gral
13:09:52 <ddarius> Never use fromInteger
13:09:55 <pumpkin> oh okay
13:09:58 <pumpkin> :)
13:10:05 <pumpkin> what's wrong with it?
13:10:06 <sclv__> its not that i think the code is awful, just that i tend to expect #haskellers can turn things like this into a single pointfree foldr and a call to tails or something.
13:10:08 <gwern> fromInteger? isn't that like pre'98?
13:10:09 <pumpkin> (I've never used it)
13:10:17 <pumpkin> I just noticed it on my autocomplete
13:10:17 <ddarius> pumpkin: Nothing, there's just no reason to ever use it.
13:10:21 <pumpkin> fair enough
13:10:32 <h0tzenpl0tz> monochrom: thanks!
13:10:38 <jrh> fromIntegral
13:10:51 <ddarius> sclv__: It's probably some sort of scanl or something.
13:11:17 <pumpkin> sclv__: pretty sure you can do it with an unfoldr, but there's not much that can't be done with one
13:12:38 <dmwit> > zip (inits [1..3]) (tails [1..3])
13:12:40 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
13:12:42 <ddarius> > scanl1 (const f) [x,y,z]
13:12:44 <lambdabot>   [x,f y,f z]
13:13:03 <ddarius> :t scanl1
13:13:04 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
13:13:41 <dmwit> > let mapEach f xs = init $ zipWith (\xs (y:ys) -> xs ++ f y : ys) (inits xs) (tails xs) in mapEach succ [1..3]
13:13:42 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
13:13:46 <dons> CosmicRay go go! http://www.reddit.com/r/haskell/comments/7qwqn/haskell_for_lawnmowers/
13:13:56 <Twey> "unfoldr - is there anything it can't do?'
13:14:05 <dmwit> sclv__, what do I win?
13:14:07 <kiris> You Broke Reddit ~_~
13:14:08 <kiris> The features don't write themselves, you know.
13:14:12 <dons> unfoldr the ultimate!
13:14:22 <dons> works for me :)
13:14:36 <kiris> hehe, it's one of those cute pages for when there's an error
13:14:39 <sclv__> dmwit: immortality in the logs!
13:15:23 <ddarius> You could do it with an unfoldr, but it wouldn't be very pretty.
13:15:37 <ddarius> dmwit: That's pretty ugly.
13:15:42 <dmwit> No kidding!
13:15:45 <gwern> @quote sorrows
13:15:45 <lambdabot> No quotes match. I am sorry.
13:15:54 <dmwit> But he asked for zipWiths, initss, and tailss...
13:16:07 <gwern> @remember byorgey TDD replaces a type checker in Ruby in the same way that a strong drink replaces sorrows.
13:16:07 <lambdabot> Done.
13:16:14 <sclv__> not necessarily, just a one liner :-)
13:16:20 <gwern> @quote statue
13:16:21 <lambdabot> No quotes match. It can only be attributed to human error.
13:16:36 <sclv__> i'm surprised it doesn't come up more often.
13:16:40 <vixey> what the hell is TDD
13:16:43 <jnaimard> @type (,5)
13:16:44 <gwern> @remember pao Cale: thanks ... I really think you deserve a statue ... or, at least, a portrait in ascii art on haskell.org :-)
13:16:45 <lambdabot> parse error on input `5'
13:16:45 <lambdabot> It is forever etched in my memory.
13:16:46 <paulmitchell> TDD can't replace reason
13:16:50 <sclv__> test driven design.
13:16:52 <Feuerbach> vixey: test-driven development
13:16:53 <dmwit> vincenz, test-driven development, where you write tests before you write code
13:17:00 <dmwit> uh
13:17:00 <jnaimard> :t (,5)
13:17:02 <lambdabot> parse error on input `5'
13:17:02 <dmwit> vixey, even
13:17:03 <gwern> @quote tourists
13:17:03 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
13:17:10 <vixey> aww I was hoping they'd say type-directed .. then I could joke: Ruby is the new Epigram?
13:17:13 <gwern> @remember ski_ unique among types, 'Void -> X' has its own charm. tourists should definitly pay a visit.
13:17:13 <lambdabot> Done.
13:17:15 <sclv__> its like coding up a typechecker for each function at a time.
13:17:23 <gwern> @quote magma
13:17:24 <lambdabot> No quotes match. Are you on drugs?
13:17:32 <jnaimard> :t flip (,) 5
13:17:33 <lambdabot> forall a b. (Num b) => a -> (a, b)
13:17:36 <gwern> @remember ddarius In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
13:17:36 <lambdabot> Done.
13:17:43 <sclv__> gwern -- don't forget to @flush :-)
13:17:46 <gwern> @quote pants
13:17:47 <lambdabot> No quotes match. It can only be attributed to human error.
13:17:52 <vixey> @floosh
13:17:52 <lambdabot> Not enough privileges
13:17:53 <gwern> sclv__: I Always flush
13:18:12 <gwern> @remember quicksilver partially applied type synonym = type lambdas = unrestricted type functions = can of pants
13:18:12 <lambdabot> Good to know.
13:18:22 <gwern> ^^ I don't quite get that done. is pants a typo for 'ants'?
13:18:42 <gwern> @remember roconnor [after a long -cafe thread on the suckiness of using math terms in Haskell] we don't use Integer anymore. Too abstract. It is now called CountingThingy.
13:18:42 <lambdabot> It is forever etched in my memory.
13:18:46 <dmwit> ?remember avdi I'm not sure if that's what I wanted, but... wow!  Maybe that's what I want now!
13:18:46 <lambdabot> Done.
13:18:50 <sclv__> i think it is slang of the britishes
13:18:53 <gwern> @quote dawg
13:18:54 <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
13:18:57 <gwern> @quote dawg
13:18:57 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
13:19:07 <gwern> @quote mathematicians
13:19:07 <lambdabot> Cale says: The perfect programming language is mathematics, but that only runs on mathematicians.
13:19:07 <Botje> mapEach f xs = map (flip zipWith ($) xs) $ map (++repeat id) $ iterate (id:) f
13:19:13 <gwern> @quote mathematicians
13:19:14 <lambdabot> Cale says: The perfect programming language is mathematics, but that only runs on mathematicians.
13:19:15 <CosmicRay> http://www.reddit.com/r/haskell/comments/7qwqn/haskell_for_lawnmowers/
13:19:16 <gwern> @quote mathematicians
13:19:16 <lambdabot> Cale says: The perfect programming language is mathematics, but that only runs on mathematicians.
13:19:24 <vixey> @quote
13:19:24 <lambdabot> dougalstanton says: Haskell: It may be avoiding success, but it's certainly quite popular.
13:19:24 <CosmicRay> bah, meant to paste that in my browser
13:19:28 <vixey> @quote
13:19:29 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
13:19:29 <lambdabot> trigger.
13:19:33 <gwern> @remember luqui *sigh*: mathematicians. can't live with 'em, can't prove 'em wrong.
13:19:34 <lambdabot> It is stored.
13:19:41 <CosmicRay> dons: thanks for the submission
13:19:48 <gwern> @flush
13:19:59 <mauke> @blush
13:19:59 <lambdabot> Not enough privileges
13:20:01 <dmwit> Score!
13:20:24 <chessguy> mauke:  the bot doesn't blush for just anyone :)
13:20:38 <dmwit> ?vixen Will you blush for me?
13:20:39 <lambdabot> yes
13:20:41 <dmwit> Ha!
13:20:49 <gwern> she'll blush for a sexy monster like me
13:20:49 <gwern> @blush
13:20:54 <score> dmwit: nice to see you too
13:21:05 <dmwit> ...!
13:21:07 <chessguy> @vixen is gwern a sexy monster?
13:21:07 <lambdabot> sexy or sexy bitch?
13:21:09 <Peaker> you've awoken a lurker!
13:21:13 <chessguy> rofl
13:21:20 <dmwit> ?users
13:21:20 <lambdabot> Maximum users seen in #haskell: 653, currently: 646 (98.9%), active: 33 (5.1%)
13:21:27 <dmwit> 5%!
13:21:29 <ddarius> Haskell is controversial?
13:21:30 <dmwit> An all time high.
13:22:01 <Botje> the other people are here to soak up haskell by saturation, then :)
13:22:13 <dpratt71> Botje: yep
13:22:28 * vixey has not found learning by osmosis very effective
13:22:30 <ddarius> Botje: No, most people talk some of the time.
13:22:42 <Botje> vixey: that's because osmosis works the wrong way :)
13:22:44 <ddarius> vixey: Did you liquify your books first?
13:22:52 <score> maybe they're just trying to finish up their other projects so they can focus on haskell full time
13:22:59 <dpratt71> ddarius: and some people talk most of the time?
13:23:12 * jrh has had his old college linear algebra textbook strapped to his back since 2000
13:23:16 <sjanssen> gwern: http://www.reddit.com/r/haskell/comments/7qvq2/taking_a_second_look_at_haskell_a_thread_pool_for/c0755up I think my code is better :)
13:23:16 <paulmitchell> I'm learning Haskell as a hobby
13:23:21 <chessguy> gwern:  fyi, i think those quotes come from lambdabot  already
13:23:24 <BONUS> i think i learn a lot through osmosis
13:23:31 <BONUS> just passively getting stuff and playing a bit
13:23:32 <BONUS> :]
13:23:34 <gwern> chessguy: which is why I check first
13:23:40 <paulmitchell> osmosis works for me too
13:23:41 <score> paulmitchell: why only a hobby?
13:24:05 <paulmitchell> score: not much in the way of paying work, and I'm not at that level yet
13:24:11 <chessguy> gwern:  strange, because i know at least some of the ones in there were in there before
13:24:19 <paulmitchell> but Haskell makes me feel like a real programmer again... I love it
13:24:20 <dpratt71> every so often I see something float by that makes me run off to google nee wikipedia
13:24:21 <CosmicRay> paulmitchell: it always starts that way ;-)
13:24:22 * jrh prefers learning Haskell via reverse osmosis.  purer water for purer programs.
13:24:27 <CosmicRay> heh
13:24:29 <chessguy> maybe they never got @flushed
13:24:42 <yitz> BONUS: in that case we *all* learn from osmosis, because you do and then we all read LYAHFGG.
13:24:44 <paulmitchell> CosmicRay: That's what I'm hoping
13:24:57 <gwern> sjanssen: bah. you know I'm not as good as you are :(
13:24:58 <paulmitchell> I can't stand the idea of having to switch over to F# to earn a living :)
13:25:13 <BONUS> haha yitz
13:25:17 <gwern> F# isn't too bad from what I've heard
13:25:28 <mauke> doesn't F# have this awesome thing called workflows?
13:25:29 <gwern> like a more obtuse ocaml with a few drippings from haskell
13:25:33 <BONUS> i cant wait to put out some new chpaters, this school stuff is killing me atm :\
13:25:43 <dpratt71> mauke: :)
13:25:46 <chessguy> mauke:  i thought i heard the name didn't catch on
13:25:49 <paulmitchell> gwern: I'd rather learn a pure languuage first, then how to smoke crack with M$
13:26:16 <mauke> warning: SPJ works for The Enemy
13:26:25 <vixey> stuff like python, F# and Arc makes me feel ill :/
13:26:45 <gwern> from everything I've heard, MS Research is practically a different org from MS
13:27:11 <paulmitchell> gwern: looks that way to me too
13:27:22 <paulmitchell> I'm not anti-MS, just cautious
13:28:08 <ddarius> gwern, sjanssen: The particular example is not one that highlights many/any of the benefits of Haskell, especially if the author is simply going to ignore the parts that would allegedly make his particular application nicer to implement.
13:28:16 <gwern> I sometimes wonder how ms research keeps getting funded by ms; there seems to be so little cross-polination
13:28:43 <gwern> ddarius: who says he's going to ignore us?
13:28:54 <dons> cross polination isn't  the only goal
13:29:09 <paulmitchell> gwern: I reckon it's similar to giving $2 a month to your favourite charity. Doesn't hurt, but makes you feel good.
13:29:15 <gwern> his conclusions are pretty reasonable, I thought
13:29:50 <ddarius> gwern: I was referring to STM.  MVars and QSems work just like every other primitive concurrency mechanism.  It is no better in Haskell than elsewhere.
13:30:12 <gwern> oh. I didn't read it teribly carefully, but what would STM buy his threadpool program?
13:30:32 <gwern> a performance penalty, I know, but I didn't see much that required complex locking and syncrhonization
13:30:51 <gwern> hm, threadpool is GPL.
13:31:05 <ddarius> Possibly nothing.  But certainly MVars and co. are going to be exactly the same as every other language.
13:31:50 <Peaker> dons: what are the other goals?
13:31:53 <olsner> heh, from 5 pages to 10 lines of code :)
13:31:57 <Peaker> dons: academic prestige?
13:32:13 <BONUS> idk, you throw money at smart people, they come up with cool new stuff that you can use
13:32:26 <paulmitchell> someone/thing has to support pure research, otherwise it's all just about some kind of gain
13:32:41 <vixey> lol
13:32:45 <paulmitchell> which gets kinda boring
13:33:18 <mattam> paulmitchell: SPJ is paid to get results still.
13:33:33 <paulmitchell> mattam: I hope so :)
13:33:33 <dons> Peaker: yeah
13:33:42 <yitz> quote from the paper: "The tricky part is in how the threads interact and coordinate through the
13:33:42 <yitz> MVars."
13:33:49 <paulmitchell> but what kind of result, and over what timescale?
13:33:55 <yitz> sounds like a job for stm to me
13:34:05 <Peaker> dons: how does that translate into profit for MS?
13:34:15 <gwern> he does get results - haskelly results. it's just I don't really see what good haskell running faster on linux does :) I mean, haskell barely works well on windows as it is
13:34:21 <yitz> furthermore, an obvious generalization would be to support dependencies, in which case you really want stm.
13:34:33 <gwern> (or should that be 'barely works'?)
13:34:33 <paulmitchell> maybe it's like Spielberg... do a couple of money-making things, we'll let ya play for a while
13:35:14 <dublpaws> I think M$ is cherry picking haskell for F# ?
13:35:30 <eu-prleu-peupeu> i would like for m$ to pick haskell instead of f# :P
13:35:33 <BONUS> i find SPJ so interesting to listen to and endearing that i would pay him to do children's parties
13:35:38 <eu-prleu-peupeu> it would help to get a job
13:35:42 <BONUS> he's a great guy
13:35:47 <gwern> dublpaws: it'd make more sense to hire the ocaml folks if f# was their aim
13:36:19 <ddarius> Economically, investing in basic research has often paid off.
13:36:35 <yitz> spj's work has definitely influenced MS's transactional memory team, although they are geared towards imperative languages.
13:37:19 <ddarius> dublpaws: Microsoft is blatantly cherry-picking Haskell for all .NET languages.
13:37:35 <ddarius> Particularly C# but it would be surprising if not for F# as well.
13:40:02 <yitz> jaress' evaluation of Haskell based on his thread pool experience is not fair.
13:40:36 <yitz> he wrote a program while thinking like in other languages, then concluded that haskell is just like other languages
13:40:51 <Peaker> yitz: where is that?
13:41:01 <yitz> linked above...
13:41:14 <yitz> http://www.reddit.com/r/haskell/comments/7qvq2/taking_a_second_look_at_haskell_a_thread_pool_for/c0755up
13:41:44 <yitz> (did \bot stop announcing urls?)
13:42:05 <gwern> yitz: yeah. I dunno why
13:42:52 <dmwit> It couldn't handle all the new quotes.
13:42:58 <repnop> well reading section 3 of that pdf leads me to believe i shouldn't care what his experience was :p
13:43:07 <repnop> in terms of performance
13:43:54 <ddarius> yitz: It seems it was turned off a while ago. And by "a while ago" I mean like months ago.
13:44:32 <yitz> ddarius: funny, i only noticed now.
13:44:44 <paulmitchell> hmph... performance < maintainability < correctness < beauty
13:45:03 <Peaker> yitz: he seems to have written a program entirely in IO, which defeats most of the purpose of Haskell
13:45:08 <dolio> Beauty is better than correctness?
13:45:14 <paulmitchell> of course
13:45:30 <int80_h> indeed
13:45:56 <paulmitchell> however, you could interpret "<" to mean "is based on"
13:46:01 <int80_h> it seems to me, beauty implies correctness
13:46:14 <int80_h> ah, heh...almost what I said
13:46:22 <paulmitchell> :)
13:46:26 <yitz> Peaker: yes. that's why i like stm for concurrency - it lifts the logic out of IO, except for what's really IO.
13:46:53 <somnolence> can someone take a look at this haskell I'm just starting out and I'm not really sure what I need to do here: http://rafb.net/p/abzZCT10.html
13:47:02 <Peaker> yitz: and even better: FRP
13:47:25 <ddarius> > liftM2 f g h x
13:47:26 <lambdabot>   Add a type signature
13:47:30 <ddarius> > liftM2 f g h x :: Expr
13:47:31 <Heffalump> kaol++ # sorting out GHC in Debian
13:47:31 <lambdabot>   Add a type signature
13:47:32 <yitz> Peaker: also nice, but not exactly the same thing.
13:47:57 <Botje> somnolence: how is that second if test supposed to be interpreted?
13:48:02 <Heffalump> @karma+ kaol # sorting out GHC in Debian; Haskell!=Perl
13:48:02 <lambdabot> kaol's karma raised to 1.
13:48:04 <dmwit> somnolence, What are the pipes about?
13:48:13 <ddarius> :t (~>)
13:48:15 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
13:48:32 <ddarius> :t ?f ~> ?g ~> ?h
13:48:33 <Botje> somnolence: also, that loop 1000 should be in a main function
13:48:33 <lambdabot> forall a a1 a11 a12 b c. (?h::b -> c, ?g::a11 -> a12, ?f::a -> a1) => (a1 -> a12 -> b) -> a -> a11 -> c
13:48:36 <dons> html version of the thread pool post, http://www2.hawaii.edu/~jaress/threadPool/threadPool.lhs.html
13:48:41 <Botje> "main = print (loop 1000)"
13:48:46 <nomeata> Heffalump: what perl issue are you refering to?
13:49:17 <dmwit> somnolence, There are a lot of problems here.
13:49:17 <leimy> I think apple should offer Haskell as part of XCode to make cocoa apps
13:49:22 <Heffalump> I'm not, I'm commenting on my own inability to work lambdabot in my previous attempt to raise kaol's karma
13:49:26 <dmwit> somnolence, First, comments are introduced with "--", not "#".
13:49:26 <leimy> I think I'm one of one people who think that :-)
13:49:54 <dmwit> somnolence, Second, pipes introduce separate equations; if you have only one equation, no pipes are needed.
13:50:16 <int80_h> somolence : you're also using two different constructs together. pick either guards or if/then/else
13:50:18 <dmwit> somnolence, Third, you have a semantic error in your use of two "if" statements -- this is a meaningless construct.
13:50:29 <ddarius> :t (?f ~> ?g) . ?h
13:50:30 <lambdabot> forall a a1 b c a11. (?h::a11 -> a1 -> b, ?g::b -> c, ?f::a -> a1) => a11 -> a -> c
13:50:31 <yitz> somnolence: what do you mean by "if n / 3 == 1"?
13:50:36 <dmwit> somnolence, Fourth, you have a semantic error in your use of division -- that is not how to detect multiples.
13:50:37 <int80_h> yeah what dmwit said
13:51:06 <leimy> I need to learn more about Conal's unamb operator stuff
13:51:09 <dmwit> somnolence, Fifth, there are no "top-level" commands in Haskell; only equations.  So the final line is also meaningless.
13:51:28 <dmwit> I think that covers the problems.
13:51:41 <vixey> leimy, why?
13:51:51 <leimy> vixey: Seems interesting
13:52:10 <dmwit> somnolence, Definitely take a look at a good tutorial for fixing the syntax errors.
13:52:41 <dmwit> somnolence, I recommend just dropping the final line, and playing with your code in ghci (rather than trying to actually turn this into a program).  That will avoid the equation/command distinction.
13:53:03 <dmwit> somnolence, Finally, for the semantic errors: they're easily fixed, see if you can figure out how on your own.
13:53:15 <int80_h> I think I may finally finish the graham scan exercise today
13:53:22 <int80_h> at long last
13:53:22 <leimy> vixey: it can run two expressions and return the "more defined" result
13:53:25 <dmwit> somnolence, We'll be happy to help you if you need pointers to resources on a good tutorial or so.
13:53:52 <vixey> leimy, well you can do that without unsafe functions, (by using a monad).
13:54:00 <int80_h> if RWH wasn't out, I'd stil be working from YAHT
13:54:11 <vixey> I don't like unamb because I think it uses unsafe functions.. :/
13:54:15 <int80_h> I still may go over it anyway
13:54:19 <leimy> vixey: is there a monad for zipping?
13:54:30 <vixey> what's zipping?
13:54:47 <leimy> > zip [1..3] [4..6]
13:54:48 <lambdabot>   [(1,4),(2,5),(3,6)]
13:54:57 <leimy> what if one list is shorter than the other?
13:54:59 <dmwit> leimy, There is an Applicative for it.
13:55:03 <leimy> ah
13:55:10 <dmwit> > ZipList [3..5]
13:55:11 <lambdabot>       No instance for (Show (ZipList t))
13:55:11 <lambdabot>        arising from a use of `show' ...
13:55:16 <dmwit> huh, really?
13:55:17 <int80_h> then the length of the new list is difined by the shortest list
13:55:21 <int80_h> defined even
13:55:39 <dmwit> Anyway, newtype ZipList a = ZipList { getZipList :: [a] }.
13:55:50 <leimy> hmmm
13:55:57 <int80_h> try it and see
13:56:14 <leimy> > zip [1..3] [2..10]
13:56:16 <lambdabot>   [(1,2),(2,3),(3,4)]
13:56:25 <dmwit> > getZipList $ pure (+) <* ZipList [1..5] <* ZipList [3,7]
13:56:26 <lambdabot>       Ambiguous occurrence `pure'
13:56:26 <lambdabot>      It could refer to either `Control.Appl...
13:56:34 <dmwit> > getZipList $ Control.Applicative.pure (+) <* ZipList [1..5] <* ZipList [3,7]
13:56:36 <lambdabot>       Overlapping instances for Show (a -> a -> a)
13:56:36 <lambdabot>        arising from a use ...
13:56:40 <vixey> leimy, I don't really get what you mean
13:56:42 <dmwit> :t (<*)
13:56:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:56:50 <dmwit> oops
13:56:52 <dmwit> :t (<$)
13:56:54 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:57:03 <dmwit> ?src Applicative
13:57:03 <lambdabot> class Functor f => Applicative f where
13:57:03 <lambdabot>     pure  :: a -> f a
13:57:03 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:57:15 <dmwit> > getZipList $ Control.Applicative.pure (+) <*> ZipList [1..5] <*> ZipList [3,7]
13:57:17 <lambdabot>   [4,9]
13:57:24 <leimy> vixey: well I was thinking about an earlier question involving "error"
13:57:33 <vixey> leimy, I don't know anything about that
13:57:40 <leimy> vixey: then I saw the -cafe post regarding least strict code
13:57:41 <vixey> I don't like error much
13:57:53 <vixey> ok do you have a link to it please?
13:57:57 <leimy> and depending on how zip is defined, the order of clauses, you can either get an error or not
13:58:07 <leimy> > zip [] (error "crap)
13:58:09 <lambdabot>   <no location info>:
13:58:09 <lambdabot>      lexical error in string/character literal at chara...
13:58:21 <leimy> > zip [] (error "crap")
13:58:22 <lambdabot>   []
13:58:23 <Peaker> @type (~>)
13:58:24 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
13:58:31 <leimy> > zip (error "crap") []
13:58:32 <lambdabot>   * Exception: crap
13:58:35 <leimy> see
13:58:39 <Peaker> @let inZipList = ZipList ~> getZipList
13:58:42 <lambdabot>  Defined.
13:59:00 <leimy> If you wanted to get weird, you could write zip two different ways
13:59:03 <leimy> zipR and zipL
13:59:03 <Peaker> oh, whoops, that's not a good idea
13:59:10 <leimy> to favor the first or second list.
13:59:22 <leimy> and then us unamb to run both in parallel, and "error" doesn't happen :-)
13:59:24 <vixey> > let zip (x:xs) (y:ys) = (x,y) : zip xs ys ; zip _ _ = [] in  zip (error "foo") []
13:59:26 <lambdabot>   * Exception: foo
13:59:28 <vixey> > let zip (x:xs) (y:ys) = (x,y) : zip xs ys ; zip _ _ = [] in  zip [] (error "foo")
13:59:30 <lambdabot>   []
13:59:30 <leimy> because it'll always run the more defined zip :-)
14:00:00 <leimy> or rather it runs both
14:00:02 <vixey> leimy, yeah I would certainly not use unsafe functions for it
14:00:03 <leimy> and returns the more defined result
14:00:14 <Peaker> @let inZipList2 = ZipList ~> ZipList ~> getZipList
14:00:17 <lambdabot>  Defined.
14:00:30 <vixey> just the Computation monad that is all you need
14:00:34 <Peaker> > inZipList2 (liftA2 (+)) [1,2,3] [4,5,6]
14:00:36 <lambdabot>   [5,7,9]
14:00:46 * vixey down with unsafePerfomWhatever :p
14:00:48 <leimy> vixey: yep..
14:00:48 <dmwit> Peaker, ?src (~>)
14:00:56 <Peaker> ?src (~>)
14:00:57 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:01:00 <dons> its kinda ridiculous that the haskell weekly news would get downmodded on the haskell reddit. stupid bots. http://www.reddit.com/r/haskell/comments/7qwm0/haskell_weekly_news_curl_web_frameworks_1000/
14:01:01 <Botje> unsafeDestroyUnsafeMethods?
14:01:10 <JohnnyL> what's with the zipping of all these fruitless searches?
14:01:15 <Peaker> dmwit: f ~> g = argument f . result g
14:01:20 <leimy> vixey:  but even "head" is unsafe :-)
14:01:35 <dmwit> Peaker, ?recursive-src (~>)
14:01:36 <dmwit> ;-)
14:01:40 <Peaker> dmwit: ~> edits a function, it returns a new function that applies f to the argument, and g to the result
14:01:56 <Peaker> dmwit: result f = (f.) ; argument f = (.f)
14:02:00 <leimy> vixey: I don't have a link to the discussion as I"m on the list. :-)
14:02:04 <leimy> and not sure where it's archived.
14:02:05 <BMeph> leimy: Please make your references to "unsafePerformHead" in -blah. ;p
14:02:08 <vixey> leimy, it's ok I understand what you mean now
14:02:25 <dmwit> f ~> g = (. f) . (g .)
14:02:33 <leimy> > head []
14:02:35 <lambdabot>   * Exception: Prelude.head: empty list
14:02:36 <Peaker> dmwit: ~> is right associative, so you can use:  func1 ~> func2 ~> func3 ~> id -- to apply these funcs to the first, second, third arguments, respecitvely
14:02:41 <dmwit> Okay, so (~>) just wraps up a function.
14:03:18 <Peaker> > (length ~> length ~> id) compare [1,2,3] [5,6]
14:03:20 <lambdabot>   GT
14:03:34 <dmwit> > ((ord ~> chr) succ) 'a'
14:03:35 <lambdabot>   'b'
14:03:38 * dmwit nods
14:03:44 <Peaker> ~> is cool :)
14:03:53 <Peaker> it can be easily generalized to an arrow, instead of being on functions
14:03:55 <dmwit> ~> is a weird name for that.
14:04:10 <Peaker> dmwit: you see the benefit of a right-associative infix for that, though?
14:04:22 <dmwit> Sure.
14:04:33 <Peaker> what would you call it?
14:04:33 <leimy> :t (~>)
14:04:34 <lambdabot> forall a a1 b c. (a -> a1) -> (b -> c) -> (a1 -> b) -> a -> c
14:05:03 <vixey> I don't like (~>) it's weird
14:05:12 <ddarius> I don't get this least-strict stuff.  Making your functions least strict does not strike me as a goal to strive for.
14:05:26 <yitz> > (ord ~> chr) succ 'a'
14:05:28 <lambdabot>   'b'
14:05:50 <vixey> > (ord ~> chr ~> id) succ 'a'
14:05:51 <lambdabot>   Couldn't match expected type `Char -> b'
14:05:56 <vixey> > (ord ~> chr ~> id) 'a'
14:05:57 <lambdabot>   Couldn't match expected type `Int -> Char -> b'
14:06:18 <Peaker> vixey: succ does not have 2 arguments..
14:06:47 <vixey> this (~>) is obfuscation, have a look at the code for 'well typed pattern combinators' or whatever it is
14:07:07 <leimy> :t (const . succ . id)
14:07:08 <lambdabot> forall b a. (Enum a) => a -> b -> a
14:07:45 <leimy> :t (succ . id)
14:07:46 <lambdabot> forall a. (Enum a) => a -> a
14:07:57 <yitz> vixey: it makes the output of @pl readable for one more level of parial (.)
14:08:15 <yitz> @where (~>)
14:08:15 <lambdabot> I know nothing about (~>).
14:08:30 <vixey> what dos parial mean?
14:08:34 <Peaker> vixey: you learn it once, and then you understand code that uses it faster
14:08:59 <Peaker> (than you would have if it was all point-ful)
14:09:02 <yitz> vixey: stuff like (. foo) . (. (. bar)) or whatever
14:09:34 <dmwit> (f ~> g ~> h) foo x y = ((g ~> h) . foo . f) x y = (g ~> h) (foo (f x)) y = (h . foo (f x) . g) y = h (foo (f x) (g y))
14:09:57 <dmwit> It seems unfortunate (but unavoidable) to have that final 'h' in there.
14:10:21 <Stephan202> @pl \a -> a // [(s, delete d (a ! s))
14:10:21 <lambdabot> (line 1, column 12):
14:10:21 <lambdabot> unexpected "["
14:10:21 <lambdabot> expecting space or simple term
14:10:28 <Peaker> dmwit: why?
14:10:28 <bogomips> Given a list like
14:10:29 <Stephan202> @pl \a -> a // [(s, delete d (a ! s))]
14:10:30 <lambdabot> ap (//) (return . (,) s . delete d . (! s))
14:10:34 <Peaker> dmwit: because its often "id"?
14:10:39 <bogomips> [[1,2,3],[3,4,5],[1,4,4]]
14:10:40 <dmwit> yes
14:10:43 <yitz> dmwit: use argument if you don't want the full ~>
14:10:48 <bogomips> how do you think I could get
14:10:53 <yitz> @type argument
14:10:55 <lambdabot> Not in scope: `argument'
14:11:02 <bogomips> [(1,3,1),(2,4,4)..]
14:11:10 <vixey> > map (\[x,y,z]->(x,y,z)) [[1,2,3],[3,4,5],[1,4,4]]
14:11:10 <Peaker> @let result = (.) ; argument = flip (.)
14:11:13 <lambdabot>   [(1,2,3),(3,4,5),(1,4,4)]
14:11:14 <lambdabot>  Defined.
14:11:17 <Peaker> @type argument
14:11:18 <dmwit> bogomips, sequence
14:11:18 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
14:11:19 <vixey> > map (\[x,y,z]->(x,y,z)) . transpose $ [[1,2,3],[3,4,5],[1,4,4]]
14:11:20 <lambdabot>   [(1,3,1),(2,4,4),(3,5,4)]
14:11:28 <dmwit> > sequence [[1..3], [3..5], [1,4,4]]
14:11:30 <ddarius> dmwit: It's easy enough to use another combinator to avoid it as Matt suggested in his original post.
14:11:30 <lambdabot>   [[1,3,1],[1,3,4],[1,3,4],[1,4,1],[1,4,4],[1,4,4],[1,5,1],[1,5,4],[1,5,4],[2...
14:11:33 <bogomips> uh nice
14:11:44 <Peaker> ddarius: instead of the final ~> use some ~~> or such?
14:11:58 <dmwit> bogomips, Oh, I misread.
14:11:59 <BMeph> dmwit: Is it time? ;)
14:12:03 <dmwit> bogomips, Use transpose, then.
14:12:08 <ddarius> Actually he used something like $> or so that just tacked the id on.
14:12:14 <vixey> > map (\l -> ((l!!0),(l!!1),(l!!2))) [[1,2,3],[3,4,5],[1,4,4]]
14:12:16 <lambdabot>   [(1,2,3),(3,4,5),(1,4,4)]
14:12:17 <dmwit> > transpose [[1..3], [3..5], [1,4,4]]
14:12:19 <lambdabot>   [[1,3,1],[2,4,4],[3,5,4]]
14:12:40 <dmwit> ddarius, Where's the original post?
14:12:40 <bogomips> dmwit: but what if the lists are arbitary long?
14:12:44 <ddarius> Or maybe not, but yeah something like that.
14:12:47 <dmwit> bogomips, What about it?
14:13:02 <dmwit> BMeph, Time for what?
14:13:13 <ddarius> http://matt.immute.net/content/pointless-fun but I was wrong about what I said he uses $. for something else.
14:13:18 <BMeph> dmwit: Time for you to get the "h" out. ;)
14:13:19 <ddarius> But Peaker has the idea.
14:13:26 <dmwit> BMeph, haha
14:13:35 <Stephan202> @unpl \a -> a // [(s, delete d (a ! s))]
14:13:35 <lambdabot> \ a -> a // ([(s, delete d (a ! s))])
14:13:41 <BMeph> dmwit: :)
14:13:44 <bogomips> transpose is fine
14:14:04 <Peaker> ddarius: he just has flip ($) so he can write  compare $. (...~>....)  rather than the other way around
14:14:20 <ddarius> Having the id be explicit seems like the most sensible thing to me though.
14:14:21 <Peaker> ddarius: I think ~> is more useful without the function argument that it is editing, though :)
14:14:26 <Peaker> I agree
14:14:46 <ddarius> Peaker: That's how I used it in a very recent mailing list post.
14:15:07 <BMeph> @let i_love_object_orientation = flip ($)
14:15:10 <lambdabot>  Defined.
14:15:36 <Botje> @let unsafePerformIO = error "Can't let you do that, Dave"
14:15:38 <lambdabot>  Defined.
14:15:40 <ddarius> BMeph: No, you do what the first PLEAC for Haskell did, import Prelude hiding ((.)); (.) = flip ($) -- Blech!
14:15:59 <Peaker> Object Orientation is "wrong" because inheritance is a horrible idea :)
14:16:17 <ddarius> Peaker: There's a lot more to OO than implementation inheritance.
14:16:30 <mmorrow> here's another version of that reddit "thread pool" thread code http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=809#a809
14:16:31 <dmwit> > map unsafePerformIO [putStrLn "hey!", print 42]
14:16:32 <lambdabot>   [* Exception: Can't let you do that, Dave
14:16:34 <dmwit> oops
14:16:37 <dmwit> > mapM_ unsafePerformIO [putStrLn "hey!", print 42]
14:16:39 <lambdabot>       No instance for (Show (m ()))
14:16:39 <lambdabot>        arising from a use of `show' at <i...
14:17:04 <BMeph> ddaris: Shouldn't that be "(.) = flip id"? ;p
14:17:16 <mmorrow> > 2 * unsafePerformIO
14:17:18 <lambdabot>   * Exception: Can't let you do that, Dave
14:17:20 <defun> how does the '$' compare to '.' ? They both seem to do the same (function composition).
14:17:23 <mmorrow> heh
14:17:24 <mmorrow> > 2 * unsafePerformIO
14:17:25 <ddarius> mmorrow: Put '= do' on one line, always start (multi-line) do blocks on the next line like you do for main.
14:17:25 <lambdabot>   * Exception: Can't let you do that, Dave
14:17:33 <Peaker> ddarius: What more is there? :)
14:17:42 <dmwit> defun, No, ($) is function application.
14:17:52 <mmorrow> ddarius: i like to switch er up a bit, cowboy
14:17:55 <Peaker> ddarius: if interface inheritance is a separate thing, its also broken - because its not stand-alone from the interface or class
14:17:58 <dmwit> defun, Unfortunately, it is wrong-associative, so it can look like function composition if there's a chain of them.
14:18:17 <Botje> f . g = \x -> f (g x) || f $ g = f g
14:18:26 <BMeph> defun: ($) is id, specialized for funtions. :)
14:18:29 <dmwit> defun, f $ g $ h $ x = f . g . h $ x /= f . g . h . x
14:18:34 <ddarius> Peaker: Well I won't disagree that typical OO languages conflate many concepts into the 'class' concept, but not all of them.  I'm particularly fond of prototype or lambda based OO languages.
14:18:45 <ddarius> f $ x = f x
14:19:06 <defun> ok, i get it. thanks
14:19:15 <Peaker> ddarius: I think the concensus is that "prototype" is not considered OO?
14:19:21 <mmorrow> although admittedly i didn't mean to start that do block on the line below `runAll'
14:19:23 <Peaker> ddarius: also, what is "lambda-based" OO?
14:19:32 <skorpan> i'd like to know that as well
14:19:53 <wli> Abadi-Cardelli arrangements for OO?
14:19:54 <dons> i get an urge to fire weapons when i read andrew's emails
14:20:04 <ddarius> Peaker: E is lambda-based OO.  Prototype OO is quite definitely OO.  It's very easy to build a class system much like typical ones on top of a prototype based OO system.
14:20:23 <dons> like a) wtf? -> someone responds with details -> wtf? lol? incomprehension :(
14:20:23 <ddarius> dons: I just ignore him altogether.  If you notice, I never reply directly to him.
14:21:02 <dons> :/
14:21:03 --- mode: ChanServ set +b xah_lee!*@*
14:21:03 --- kick: xah_lee was kicked by ChanServ (Banned:)
14:21:10 <dons> haskell-cafe isn't a forum.
14:21:12 <Peaker> Who is Andrew?
14:21:14 <dons> hey go chanserv!
14:21:26 <Peaker> ddarius: how do you implement something like isinstance in prototype-OO?
14:21:27 <ddarius> mmorrow: If you used mapM(_) twice in runAll you'd have runAll acts = mapM fork acts >>= mapM_ (takeMVar . snd)
14:21:40 <ddarius> Peaker: What does isinstance have to do with OO?
14:21:53 <Peaker> ddarius: I guess nothing :)
14:21:58 <vixey> why is xah_lee banned?
14:21:59 <ddarius> Peaker: But it should be straightforward, you compare the "vtable" equivalents.
14:22:07 <Peaker> ddarius: Is there a typed prototype/lambda-based OO?
14:22:09 <gbacon> http://code.haskell.org/
14:22:13 <gbacon> down?
14:22:15 <dons> vixey: there is no greater disruptive influence on all of freenode.
14:22:17 * gbacon waits for the bot
14:22:20 <dons> gbacon: appears so. reported
14:22:25 <gbacon> :-(
14:22:36 <vixey> dons, do you say that out of experience or extrapolation?
14:22:38 <ddarius> Peaker: Probably.
14:22:50 <dons> vixey: experience. long experience :/
14:22:58 <vixey> inn this channel? seriosuly
14:23:07 <dons> we also have a couple of other pathological personality bans
14:23:12 <dons> vixey: of course in this channel
14:23:16 <gbacon> good, I was afraid I was seeing a conflict fight
14:23:16 <ddarius> vixey: Why do you think he would be less crazy here?
14:23:29 <vixey> because I think he is not crazy at all
14:23:52 <dons> hehe. that's what hanging out in #ocaml with smerdy and palomer will do to you ;)
14:24:07 <dons> check out his gun and naked chick study pages
14:24:29 * loadquo is having problems dealing with GHC.Prim.Any
14:24:56 <mmorrow> ddarius: yeah, i just revised that.
14:25:18 <vixey> anyway nice to think people just get banned at random for having personality
14:25:25 * vixey takes a guess who is going next.....
14:25:28 <jad4> hi guys
14:25:38 <jad4> how can I see the source code for ghc modules ?
14:25:40 <mmorrow> i'd cut that function down from a larger one, which included the killThreads that the orig author used, until i realized those were unnecessary
14:25:44 <jad4> I'm in the libs documentation
14:25:48 <vixey> jad4, everything is in the GHC source code
14:25:50 <jad4> there used to be a link there to the source
14:26:31 <jad4> vixey, yes I know, and how can I access just the Data.List source code?
14:26:36 <dons> vixey: yeah, it is all random. we just do it totally randomly
14:26:39 <dons> ?dic 1d3
14:26:39 <lambdabot> Maybe you meant: dice dict dict-help
14:26:45 <dons> ?dice 1d6
14:26:46 <lambdabot> 1d6 => 2
14:26:48 <dons> oh lucky!
14:26:51 <jad4> I'm pretty sure there was a link in the documentation for it
14:27:01 <skorpan> ddarius: slightly off-topic but could you explain what about E makes it "lambda-based"?
14:27:09 <vixey> jad4, I use  cat ~/code/implementations/ghc-6.11.20081031/libraries/base/Data/List.hs
14:27:22 <dons> vixey: actually, the 3 personality bans are based on principle: http://www.haskell.org/haskellwiki/Irc#Principles
14:27:30 <vixey> dons, (btw  I have no idea who palomer is)
14:27:50 <arjanb> jad4: use the docs of the previous release: http://www.haskell.org/ghc/docs/6.8.3/html/libraries/index.html
14:27:54 <jad4> vixey, yes I _know_ I can download the source code
14:27:54 <dons> if you attack new users, or are hostile, you don't get to stay around. so it isn't terribly random, more aimed at encouraging community accessibility and a friendly learning environment
14:27:59 <ddarius> skorpan: They coined the term, ask them.
14:27:59 <vixey> dons, you never kicked out sbahra or chrisdone though.....
14:28:05 <Heffalump> dons: "haskell-cafe isn't a forum"?
14:28:14 <jad4> arjanb, thanks
14:28:16 <dons> Heffalump: you know those "web forums"
14:28:21 <vixey> dons, oh guess it doesn't matter since I'm not a new user
14:28:21 <mmorrow> the touched up version http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=809#a810
14:28:21 <dons> where peole answer questions with "lolz"
14:28:29 <Heffalump> sure, but what made you say that?
14:28:49 <sbahra> vixey, why should I be kicked?
14:28:50 <dons> oh, just that maybe andrew's thinking of email as a different medium to what it is
14:28:56 <skorpan> ddarius: i can't seem to find any real documentation on that specific term "lambda-based object orientation"
14:29:01 <sbahra> vixey, you have serious attitude issues. You are a very unstable person.
14:29:13 <dons> oh kids.
14:29:16 <dons> take it into -blah
14:29:21 <Heffalump> I vote for kicking dons.
14:29:26 <Heffalump> He's clearly a disruptive influence.
14:29:33 <mmorrow> this is why we need a #botwars
14:29:33 <dons> always with the link spam
14:29:48 <loadquo> This compiles and runs, http://haskell.pastebin.com/d5786dd03. But it doesn't know the data type of the function it is returning (naturally) how do I deal with this....
14:29:56 <cytzol> Lambdabot came at me with a flamethrower once.
14:29:58 <sbahra> dons, excuse me? :-) When vixey will make imply some things in #haskell, I will reply in #haskell.
14:30:17 <loadquo> This being makeBrandPair
14:30:39 <ddarius> skorpan: http://erights.org/elang/intro/index.html  has a link "Lambda-based objects" which currently doesn't really go anywhere but it indirectly leads to this page: http://erights.org/elib/capability/ode/ode-objects.html
14:30:46 <joma> hmm
14:30:59 <skorpan> thanks ddarius
14:31:02 <ddarius> skorpan: I'll readily admit that they don't formally define it there (or anywhere I know of, though I haven't really looked)
14:31:47 <joma> how much of a normal haskell programcan be proven correct?
14:31:56 <joma> can all pure functions be?
14:32:08 <dons> "proven correct" ? in what sense?
14:32:14 <dons> in all invariants and properties of the program?
14:32:21 <Peaker> joma: No, Haskell is Turing Complete, which means you cannot in general prove properties about its runtime execution. You can only prove in special cases
14:32:25 <dons> i.e. what in general can be proven ?
14:32:32 <vixey> Peaker, that's not true
14:32:32 <ddarius> skorpan: From the references lambda-based objects is more or less the actor model.
14:32:40 <Peaker> I guess "properties" is too general
14:32:45 <Peaker> untyped properties :-)
14:32:48 <Peaker> Would be more accurate
14:33:04 <Heffalump> loadquo: you need Data.Dynamic to achieve what I think you're trying to do.
14:33:08 <joma> well the pure functions for example
14:33:10 <ddarius> cytzol: She does that occassionally.
14:33:15 <fabjan> hello! I just changed a maze game from a haskell tutorial into a game of pong, but it's too fast. How can I sleep the program to slow it down?
14:33:28 <Heffalump> fabjan: run it in Hugs :-)
14:33:31 <vixey> :t threadDelay
14:33:32 <lambdabot> Not in scope: `threadDelay'
14:33:33 <roconnor> *L*
14:33:34 <fabjan> :P
14:33:45 <roconnor> Heffalump: that's awful :D
14:34:25 <ddarius> Peaker: You can't prove many properties of -any- arbitrary program, but you usually can construct your code in such a way to be able to prove whatever you like.
14:34:30 <blackh> fabjan: Control.Concurrent.threadDelay
14:34:36 <loadquo> Heffalump: Thanks, I'll have a look. I would be happy if I could pass a type into my makeBrandPair to type the functions it returns or some other way to lock it down.
14:34:48 <Peaker> ddarius: right, but that's exactly limiting yourself to those special cases I mentioned
14:35:24 <fabjan> vixey, blackh: thanks
14:35:25 <Peaker> joma: you can't prove, in the general case, that a pure function terminates.  You can prove it for many real-world cases, but you will always be able to construct cases where you don't know / can't prove
14:35:28 <Heffalump> loadquo: actually, maybe I misunderstand what you're trying to achieve.
14:35:31 <Heffalump> Can you explain further?
14:35:53 <vixey> Peaker, I guess you are talking about automatic computer theroem proving..
14:36:02 <mmorrow> um, how do you format code in a reddit comment?
14:36:06 <vixey> (because if you are what you said is true)
14:36:47 <Peaker> vixey: if a human is involved, its still not possible in the general case, no?
14:37:06 <joma> if i want to prove a haskell program correct with a proof assistant, what is the best? isabelle, proof general?
14:37:07 <Peaker> vixey: a human is not more than turing complete :-)
14:37:08 <loadquo> Heffalump: The idea is to pass in a secret to create two functions, you pass the fromBox function to someone else and they can then open anything you put wrapped with the toBox created wit the makeBrandPair function
14:37:11 <Philippa_> fabjan: this is one of those things where really you want to do it a bit differently in any language though
14:37:12 <vixey> yes but mu-recursive/turing complete doesn't make a difference
14:37:18 <mmorrow> (there's no preview button and i know i'll botch it if i guess)
14:37:24 <Heffalump> loadquo: ah, right. I did misunderstand completely.
14:37:31 <Heffalump> So what's the problem you have? I don't get that.
14:37:47 <cytzol> I'm doing a formal methods course that's supposed to go into Haskell sometime in the next few weeks... not sure how much it'll cover, though.
14:37:48 <ddarius> joma: Whatever you're most familiar with.
14:37:52 <vixey> joma, on paper proofs are pretty good
14:38:03 <cytzol> Currently it's all Ps and Qs and =>s and ¬s.
14:38:08 <Heffalump> I'm also not sure I see the point, why not just pass them the wrapped thing directly?
14:38:21 <ddarius> vixey: Extracting verification conditions from paper sounds very not fun.
14:38:47 <loadquo> Heffalump: Once I have created a the fromBox and toBox they are of types using GHC.Prim.Any instead of a.
14:38:50 <ddarius> cytzol: That's what it'll continue to be, though probably less ¬s.
14:39:03 <dons> joma: isabelle , agda and coq are all used
14:39:13 <ddarius> We should have an Iso module.
14:39:14 <Heffalump> loadquo: oh, right. Just give a type signature to your call to makeBrandPair. Or is the point that you don't know until later what type you want?
14:39:19 <ddarius> Hmm.
14:39:34 <cytzol> ddarius: I dunno; maybe he's using up all the ¬s before we get there
14:39:38 <dons> there's a short course on formal methods used at galois here, http://www.galois.com/blog/2008/12/11/formal-methods-in-use-at-galois/
14:39:41 * ddarius wonders if Andrew would complain about Iso being bad because it's an abbreviation or Isomorphism being bad because it's a technical term.
14:39:46 <ddarius> cytzol: Prolly.
14:39:54 <dons> we use isabelle, haskell, various model checking technique, a bit of coq gets toyed with.
14:39:57 <dons> lots of type system stuff
14:40:38 <ddarius> My friend's brother's wife does model checking stuff, but for C I believe.
14:42:16 <Heffalump> loadquo: I need to go to bed, but if you don't know the type until later, you probably do need dynamics. And some other way for the recipient of fromBox to figure out what type is inside the box.
14:43:02 <Peaker> loadquo: ghci is annoying, load it from a file :)
14:43:13 <kerlo> I suddenly wonder if Agda is just a different-looking version of Epigram.
14:43:46 <dons> yup
14:43:57 <SamB> something like that
14:43:58 <dons> not really. but yeah, you've got the right intuition
14:44:04 <loadquo> Heffalump: I'd be happy to know the type when I makeBrandPair, but I am unsure of how to specify it for a function that returns a tuple of functions..
14:44:13 <cytzol> If a prover proves itself correct, how can we be sure it's not some conspiracy?
14:44:38 <SamB> they are at least as similar as vi and emacs, I think ...
14:44:46 <dons> use a different prover
14:44:51 <dons> in a different logical framework
14:44:55 <ddarius> cytzol: Unless it's rather weak, you already know it's a "conspiracy"
14:45:02 <loadquo> Peaker, yeah my problems should go away when there is a bit more to type inference on. I just wanted to know how to specify things by hand.
14:45:10 <dons> all a lot better than just pen and paper, imo
14:45:44 <kerlo> cytzol: you'll have to prove the prover yourself.
14:45:52 <kerlo> Or prove it with a really simple prover and prove that yourself.
14:46:02 <Philippa_> cytzol: it's not even about provers, it's about logics themselves
14:46:09 <dons> well, 'yourself' == just another logical framework
14:46:11 <cytzol> I've been writing a prover (to help me understand proofs, not because the world doesn't need another one) but it's not at haskell-code-level yet
14:46:26 <vixey> cytzol, I wouldn't argue with a construction that shows the consistency of Foo is equiv. to a specific transfinite induction
14:47:04 <loadquo> Heffalump: Thanks for the ideas, though.
14:47:14 <mmorrow> re: reflection this paper is interesting http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.66.9530
14:47:27 * ddarius just argues with transfinite induction.
14:47:54 <mmorrow> "... in which structurally reflective programming is supported directly, without any encoding."
14:48:47 <mmorrow> (i haven't finished reading that yet though)
14:48:52 <eu-prleu-peupeu> what does "const" do ?
14:48:55 <kerlo> "There is no programming language. The compiler analyzes the program itself, without any encoding."
14:49:09 <kerlo> eu-prleu-peupeu: for all x and y, const x y = x
14:49:39 <baaba> eu-prleu-peupeu, it's the constant function, as in say you have a mathematical function f(x) = 1, which is just a straight horizontal line, right?
14:49:42 <cytzol> eu-prleu-peupeu: it's when something takes a function, but you don't need to care what its argument is
14:49:47 <baaba> so the haskell equivalent would be "const 1"
14:49:51 <ddarius> To mindlessly propagate the meme: "Yo dawg, I herd you like infinities, so we put an ordinal in yo ordinal so you recurse while you recurse"
14:50:06 <kerlo> What was that meme originally?
14:50:54 <Cale> kerlo: http://i34.tinypic.com/2mgqe52.jpg
14:50:58 <cytzol> I like an infinite number of infinities.
14:50:59 <eu-prleu-peupeu> :D
14:51:01 <eu-prleu-peupeu> nice
14:51:05 <ziman> @src const
14:51:05 <lambdabot> const x _ = x
14:51:20 <loadquo> Peaker: Yeah my problems did go away,  GHCI <_<
14:51:39 <loadquo> Although it was doing its best I suppose.
14:52:18 <Cale> http://i38.tinypic.com/257hetz.jpg -- this is the best variant of that meme I've seen
14:52:26 <kerlo> Is it the calculus one?
14:52:41 <baaba> > let f = const 1 in flip zip =<< (map f) $ [1..]
14:52:43 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1)...
14:52:47 <kerlo> Nope, it's the yo yo dawg one.
14:53:28 * loadquo doesn't get Yo Dawg....
14:53:56 <ddarius> Me neither really, but mathematics lends itself very well to it.
14:54:03 <cytzol> loadquo: I don't think there's much to get.
14:54:04 <yitz> http://knowyourmeme.com/memes/48-xzibit-yo-dawg
14:54:32 <joma> hmm i was thinking parallellisation still only offers linear speedup. are there algorithms for a lot of applications that perhaps are sequential in nature and thus more cores wont speed things up since the avilable parallellisable algorithm is slower by an order of magnitude?
14:54:55 <baaba> what is that site? blasphemy!
14:55:07 <baaba> here, the authoritative source: http://encyclopediadramatica.com/Yo_dawg
14:55:34 <eu-prleu-peupeu> loadquo: http://www.youtube.com/watch?v=7KegY8YIzQ4
14:55:43 * loadquo gets it already
14:55:48 <skorpan> i like these: http://knowyourmeme.com/system/photo/image/391/oldesupdawg.png
14:56:20 <SubStack> I like the yo yo version the best
14:57:38 <yitz> the Y combinator is short for Yo Dawg.
14:58:04 <skorpan> makes sense, since "yo dawg" makes room for recursion
14:58:16 <SubStack> it's true
14:58:22 <SubStack> http://knowyourmeme.com/system/photo/image/179/PRn7VIafuhc60f6moPwXp38Co1_500.jpg # there it is
14:58:48 <cytzol> (\x,y,z -> "Yo dawg, I heard you like " ++ x ++ "s so we put a " ++ x ++ " in your " ++ y ++ " so you can " ++ z ++ " while you " ++ z)
14:58:53 <Cale> joma: There are things which happen to be sequential in nature, but there are also a lot of opportunities for parallelism.
14:58:55 <cytzol> Is not a combinator, because of (++)
14:59:06 <ztirF> @pl \(x,x) -> (f x, f x)
14:59:06 <lambdabot> liftM2 (,) f f . snd
14:59:10 <joma> is this O(n^3) btw: http://cpp.ninjacodemonkeys.org/5049 ?
14:59:43 <ztirF> blech
15:00:17 <Cale> joma: You're setting each entry one-by-one?
15:00:39 <joma> cale , yes i think so
15:00:58 <Cale> joma: setAt is O(n^2)
15:01:04 <Cale> By necessity.
15:01:11 <joma> true
15:01:48 <joma> or? for n-elem matrix it is O(n)...
15:02:03 <joma> setAt itself is O(1)
15:02:08 <Cale> oh?
15:02:17 <Cale> What's the matrix representation you're using?
15:02:32 <Cale> If it's an array, the array is going to have to be copied.
15:02:35 <joma> http://cpp.ninjacodemonkeys.org/5050
15:02:53 <Cale> I have a hard time believing it's any better than O(log(n))
15:03:19 <Cale> ah, DiffArray?
15:03:35 <kmeyer> monads are sort of like "pure objects" aren't they?
15:03:44 <Cale> Okay, I suppose that works, but it makes the analysis more tricky.
15:03:54 <ddarius> kmeyer: No or I don't know what you mean by "pure objects"
15:03:54 <yitz> Paul Graham is a partner at http://ycombinator.com/
15:03:55 <Cale> kmeyer: er?
15:04:15 <kmeyer> well, like objects from, say, java, but without side effects outside of themselves?
15:04:15 <Cale> kmeyer: They're type constructors which have a particular interface of operations available.
15:04:23 <ddarius> kmeyer: Then no.
15:04:35 <Cale> They're not like objects in any recognisable way ;)
15:04:57 <kmeyer> ok, /me still doesn't get it :D
15:05:08 <Cale> Though I suppose each individual monad instance could be like an object.
15:05:11 <nomeata> hi. Is there a "forkEach :: [IO a] -> IO [a]" hidden in the library somewhere?
15:05:23 <ddarius> kmeyer: Here's a tip.  Don't try to equate anything in Haskell to anything in OO languages.
15:05:23 <Cale> (that is, you could bundle the functions together into an object, perhaps)
15:05:23 <dmwit> No.
15:05:39 <baaba> :t sequence
15:05:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:05:47 <Cale> But that's an odd way of thinking of it, and you could do a similar thing with the functions from any typeclass.
15:05:48 <dmwit> baaba, That doesn't fork them.
15:05:52 <baaba> oh er, fork
15:05:56 <nomeata> sequence has the right type, but not the right semantics
15:05:59 <kmeyer> Cale: that's what I was getting at
15:06:03 <baaba> thought i said for :P
15:06:04 <baaba> nevermind
15:06:09 <dmwit> nomeata, I'm afraid you have to write it yourself.
15:06:23 <nomeata> dmwit: :-(
15:06:29 <Cale> kmeyer: So, monads are like objects about as much as types which are instances of Ord are like objects.
15:06:29 <kmeyer> ddarius: mostly I don't.
15:06:34 <kerlo> Can't be too hard.
15:06:36 <ddarius> There was a recent blog post on almost exactly this, but I can't get to planet haskell currently.
15:06:37 <kmeyer> Cale: right.
15:06:40 <kmeyer> they are.
15:06:40 <Cale> kmeyer: So it doesn't really help all that much ;)
15:06:59 <kmeyer> oh well
15:07:07 <kerlo> @hoogle forkIO
15:07:08 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
15:07:10 <kmeyer> eventually I'll get unlost.
15:07:26 <Cale> kmeyer: The best way forward is through a bunch of examples.
15:07:27 <kerlo> Huh. Is there a way to get the return value out of one of those?
15:07:43 <ddarius> kerlo: They don't return anything so there is no return value to get.
15:07:44 <Cale> kerlo: The return value is necessarily ()
15:07:47 <kmeyer> Cale: do you have any particularly good ones to point to?
15:07:48 <mmorrow> nomeata: i've done something similar with a Chan which i fed the contents of a list of mvars into to another thread which collected these and then stuck that into another mvar
15:07:53 <mmorrow> nomeata: http://moonpatio.com/repos/proc/src/Control/Concurrent/Proc.hs
15:07:59 <Cale> kerlo: But if you want to return something to the main thread, you usually use an MVar
15:08:04 <dmwit> kerlo, You can share a concurrent pointer.
15:08:07 <dmwit> MVar
15:08:12 <kerlo> Mm.
15:08:30 <ddarius> You just do, forking io = do mvar <- newEmptyMVar; forkIO (io >>= writeMVar mvar); return mvar
15:08:33 <Cale> kmeyer: Sure... to avoid the scroll, come to #haskell-overflow and I'll go over some :)
15:09:33 <sclv__> mapM (\x -> forkIO $ evaluate x >> newMVar) >>= mapM takeMVar or the like
15:10:30 <nomeata> forkSeqence acts = mapM (\act -> newEmptyMVar >>= \mvar -> forkIO (act >>= putMVar mvar) >> return mvar) acts >>= mapM takeMVar
15:10:36 <nomeata> this should work theoretically
15:10:55 <joma> Matrix ((repr m) DA.// [((r,c), v)]) can somkething like that be a monad, wher eit take s the repr and the Matrix class to it again in the end?
15:11:03 <sclv__> or if x is of IO already, and is sufficiently strict, you don't need evaluate.
15:11:16 <sclv__> but be careful about strictness, otherwise the work will get done by the wrong thread.
15:11:20 <mmorrow> nomeata: that's clever
15:11:34 <ddarius> nomeata: Yes.  It has the bad property that it won't return results as soon as they are available but if you need them in the same order then that's fine.
15:11:43 <ddarius> mmorrow: That's the standard solution.
15:12:17 <sclv__> returning results as soon as they are available with a chan is also tricky because it hides an unsafeinterleaveIO in there that might trip you up later.
15:12:36 <mmorrow> it's a drawback though that if the first computation takes a year, and the rest take a second, you have to wait a year
15:12:48 <nomeata> I’m not caring about getting the results fast, just running them in parallel, because they are slow IO stuff
15:13:27 <sclv__> joma: you maybe want to look at STArrays.
15:13:39 <CakeProphet> does it make much sense to use TVars like this if you have a thread for each user that can, at any point, access any object.
15:13:56 <CakeProphet> type ObjectMap = TVar (Map Ref (TVar Object))
15:14:11 <nomeata> wow, this totally breaks my debugging output to stdout (as expected...) :-)
15:14:28 <mmorrow> hehe, i love when that happens
15:15:16 <sclv__> nomeata: thread a lock on stdout through and have a debug function that takes the lock when it writes a line.
15:15:36 <mmorrow> or you can have a writer thread waiting on a chan
15:15:50 <nomeata> sclv__: hmm. it’s too deep in the code :-]
15:15:52 <sclv__> probably a more robust solution, that.
15:15:55 <nomeata> mmorrow: yes, that was my idea as well
15:16:28 <sclv__> although threading through a chan and threading through a function with a lock inside are about equal.
15:16:30 <nomeata> BTW, is code.haskell.org slow? HEAD  http://code.haskell.org/xmonad/_darcs/format takes a long time
15:16:31 <BONUS> i've been wondering what would happen if type functions like the ones in associated type synonyms were allowed anywhere ... can of pants?
15:16:45 <nomeata> sclv__: right
15:17:11 <sclv__> alternately, a lifted monad with logging :-)
15:17:50 <sclv__> or an unsafeperformIO strategically used at the top level.
15:17:52 * sclv__ ducks
15:17:56 <mmorrow> l33t!
15:18:05 <ztirF> I'd like to define an ordering for tuples, where: EQ is as normal, but GT iff all the elements are GT, and LT otherwise
15:18:13 <ztirF> is there any way to do that for all tuples?
15:18:46 <sclv__> that breaks x < y === y > x, no?
15:19:26 <ztirF> sclv__: I don't see how
15:20:29 <ztirF> it's how a multivariate CDF is defined, I think
15:20:57 <sclv__> compare (2,3) (3,2) == LT, compare (3,2) (2,3) == LT
15:21:06 <byorgey> ztirF: one way to do it would be to make a newtype, and then make an instance for the newtype
15:21:27 <byorgey> sclv__: yeah, the Ord docs say it's supposed to be a total order, but this isn't
15:21:33 <byorgey> really we need a Preorder class or something
15:21:37 <sclv__> you want a partial ordering typeclass
15:21:51 <sclv__> or some sort of lattice
15:22:13 <ztirF> I see
15:22:27 <joma> can I write docstrings for haskell functions?
15:22:40 <gwern> @where haddock
15:22:40 <lambdabot> http://www.haskell.org/haddock/
15:22:47 <byorgey> joma: not as such, but there's Haddock
15:22:57 <joma> can I list all the functions ina module in ghci?
15:23:03 <byorgey> :browse
15:23:03 <joma> is haddock for ghci?
15:23:17 <gwern> no
15:23:24 <byorgey> joma: in theory ghci could show haddock information, but it doesn't.
15:23:35 <byorgey> haddock is for auto-generating html documentation
15:24:17 <byorgey> joma: having the ability to see haddock documentation from ghci would be nice, though.  I think I've heard people talk about it before.
15:24:59 <nomeata> good night everyone
15:27:03 <ehird> > unsafeCoerce
15:27:04 <lambdabot>   Not in scope: `unsafeCoerce'
15:27:05 <ehird> Damn.
15:29:06 <sclv__> ztirF: in any case, writing something like that over all tuples isn't easy anyway. you certainly can't do it with standard typeclasses. if you really want to, you can define a generic function (i.e. not your standard ord, because it has constraints) with Scrap Your Boilerplate.
15:29:52 <ztirF> scrap your boilerplate, eh
15:30:13 <sclv__> if you haven't used it before, prepare for a ride :-)
15:30:27 <bogomips> I don't quite understand why there are so few functions for tuples
15:30:30 <bogomips> if I have for example
15:30:36 <sclv__> really powerful, but a steep learning curve.
15:30:37 <bogomips> (x,y,z) how do I get the z?
15:30:50 <bogomips> since I have only fst and snd?
15:30:53 <ehird> func (_,_,z) = ... do stuff with z ...
15:30:59 <ehird> pattern matching, yo
15:31:05 <sjanssen> bogomips: tuples are not really recommended
15:31:23 <sclv__> I've found this to be good, since when I go over three elements, its like the language reminds me I should really be using a custom record type.
15:31:40 <ztirF> ... I guess I'll just write them out manually, for now
15:31:46 <ztirF> I only need up to 3 anyway
15:32:06 <ztirF> the "basics" page is rather intimidating
15:32:24 <ehird> ztirF: make your own function, then
15:32:28 <ehird> third (_,_,z) = z
15:34:22 <bogomips> what are the advantages over a list?
15:34:48 <ehird> wait I meant bogomips
15:34:49 <ehird> :-)
15:34:57 <ehird> bogomips: tuples have size = type
15:35:02 <ehird> so you can't pass too many or too little elements
15:35:27 <bogomips> uhm ok, thanks
15:36:15 <joma> how are tuples defined? whyc an they hold different types?
15:36:24 <joma> hw can  iterate over a tuple?
15:36:26 <ehird> joma: there are infinite tuple types
15:36:39 <ehird> (1,"a") :: (Integer,String)               [pedants:don't bring up Num]
15:36:47 <ehird> you can't iterate over them generically
15:36:55 <ehird> you have to deal with specific tuple types
15:37:01 <ehird> [lotsa people asking about tuples...]
15:37:01 <cytzol> Tuples aren't for iterating over. Them's lists.
15:39:47 <ztirF> bah this sucks, I don't want to define a custom data type
15:39:58 <ehird> why not :-)
15:40:00 <ehird> it's painless!
15:40:22 <ztirF> A 1D cdf is a function on Double, a 2D cdf is a function on (double,double), that's it
15:40:35 <ehird> ok and? :)
15:40:35 <CakeProphet> How would Eq derive for data Ref = ObjRef Int | CharRef String | RoomRef String   ?
15:41:09 <ehird> CakeProphet: how wouldn't it?
15:41:51 <CakeProphet> -shrug- just wonder if it would derive intuitively. As in CharRef "lol" /= RoomRef "lol  right?
15:42:05 <kerlo> Presumably, this: ObjRef x == ObjRef y = x == y; CharRef x == CharRef y = x == y; RoomRef x == RoomRef y = x == y; _ == _ = False
15:42:23 <ehird> What he said :-)
15:42:26 <CakeProphet> -nod- okay.
15:42:55 <CakeProphet> would Ord derive sanely? I don't plan on using Ord (I'd just extract the number/string and use Ord then), but could it?
15:43:24 <Gracenotes> Int and String are Ord, so it should, methinks (...?)
15:43:25 <ehird> CakeProphet: TryItAndSee(TM)
15:44:00 <CakeProphet> if only ghci allowed type defintions. :(
15:44:09 <dmwit> CakeProphet, A derived Ord instance orders by constructor first, then by contained instances second.
15:44:21 <CakeProphet> ah okay.
15:44:29 <yip> CakeProphet: what is the reason it doesn't?
15:44:54 <dmwit> yip, Just because they aren't allowed inside a monad.
15:45:10 <yip> monad?
15:45:11 <dmwit> yip, ghci is basically in the IO monad, though some lines are implicitly prefaced by "let". =)
15:45:30 <mjb> ghci doesn't allow qualified imports?
15:45:33 <dmwit> ghci makes a lot of sense if you imagine that it was called "do" instead of "ghci". =)
15:45:42 <dmwit> mjb, no
15:45:52 <dmwit> mjb, You can qualify an import in a file, and ghci will respect that.
15:46:03 <Gracenotes> mjb: importing is just syntactic sugar for :m + notation, iirc
15:46:07 <ski_> (dmwit : .. inside a `do'-expression)
15:46:15 <Gracenotes> in ghci, anyway
15:46:30 <dmwit> ski_, Right, thanks.  Precision matters for this stuff.
15:46:42 * Gracenotes is reading The Implementation of Functional Programming Languages... smooth sailing so far :)
15:47:06 <Gracenotes> then again, I'm only about 5% through
15:47:28 <CakeProphet> how was the custom deriving supposed to be able to work?
15:51:59 <dibblego> > let f p = foldr (\a (x, y) -> if p a then (a:x, y) else (x, a:y)) ([], []) in f even [1,2,1,3,1,2,4,3,5,6,5,7,6] -- is this function in the std libraries?
15:52:00 <lambdabot>   ([2,2,4,6,6],[1,1,3,1,3,5,5,7])
15:53:25 <CakeProphet> is there an operator equivalent to elem?
15:53:33 <ehird> `elem`
15:53:36 <CakeProphet> ...
15:53:40 <ehird> `x` is x, except infix.
15:53:44 <ehird> a `x` b == x a b
15:53:45 <CakeProphet> you know what I mean. ;)
15:53:49 <ehird> umm, nope.
15:53:57 <CakeProphet> like <$> for fmap
15:54:06 <ehird> nope.
15:54:09 <ehird> invent one?
15:54:28 <CakeProphet> well, not for elem... but I'm going to make an operator for a similar function.
15:54:36 <CakeProphet> I'm just... deciding what it should look like.
15:54:55 <CakeProphet> its normal name is "contains"
15:55:08 <CakeProphet> :t groupBy
15:55:10 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:55:34 <Feuerbach> dibblego: isn't it just (filter p xs, filter (not.p) xs)?
15:56:03 <somnolence> Is there some kind of printf function or an easy way to induce line breaks in concatenated strings in haskell?
15:56:22 <CakeProphet> > partition even [1..10]
15:56:24 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
15:56:34 <CakeProphet> dibblego:  ^^
15:57:30 <codemac> code.haskell.org down eh?
15:57:46 <Gracenotes> D:
15:57:57 <Feuerbach> codemac: ssh works, http does not
15:58:00 <CakeProphet> somnolence:  intercalate is kind of like what you want.
15:58:02 <CakeProphet> :t intercalate
15:58:04 <lambdabot> forall a. [a] -> [[a]] -> [a]
15:58:26 <CakeProphet> > intercalate "\n" ["lawl", "rofl"]
15:58:28 <lambdabot>   "lawl\nrofl"
15:58:43 <mjb> @hoogle (a -> Bool) -> [a] -> ([a], [a])
15:58:43 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:58:43 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
15:58:43 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
15:58:55 <CakeProphet> somnolence:  there's also "lines"... which breaks a string by lines.
15:59:31 <Feuerbach> and unlines is the reverse
16:00:59 <ski_> somnolence : maybe you could clarify what you want ?
16:01:16 <CakeProphet> hmm... is <? a good operator for "contains" maybe?
16:01:28 <CakeProphet> I don't like question marks.
16:01:49 <ski_> (CakeProphet : why do you need an operator for it ?)
16:01:55 <CakeProphet> -shrug- I don't.
16:02:29 <CakeProphet> much like I wouldn't need an operator for `elem`, it's just a convenience.
16:03:10 <Peaker> CakeProphet: operators should only be used for really common stuff
16:03:28 <BMeph> For those that have one, what is a "good" symbol for flip ($)? :)
16:03:41 <Olathe> `flipOut`
16:03:56 <ski_> BMeph : `>$' might be one ..
16:04:05 <CakeProphet> BMeph:  use a cent sign.
16:04:10 <CakeProphet> :P
16:04:17 <Olathe> Hahah
16:04:36 <ehird> :t flip ($)
16:04:37 <lambdabot> forall a b. a -> (a -> b) -> b
16:04:42 <ehird> ah, right
16:04:48 <ehird> BMeph: I used |>, I think
16:04:50 <ehird> when I used that
16:04:57 <ehird> works well as a pipeline analogy
16:05:18 <CakeProphet> ah, that is nice.
16:05:46 <CakeProphet> 4 |> 3 |> (+)
16:05:49 <CakeProphet> it's FORTRAN Haskell.
16:05:51 <aluink> what's up with hpaste right now?
16:06:10 <dons> shapr: hpaste.org ?
16:06:17 <dons> we need mmorrow's hpaste2
16:06:19 <dons> now is the time!
16:07:13 <Olathe> Can you search by author on it ?
16:07:26 <aluink> i'm reading rwh and i don't understand what transform does in this code, it seems that it's ALWAYS receiving a singleton, http://pastebin.com/d25279902
16:07:40 <ehird> @define (|>) = flip ($)
16:07:50 <codemac> Feuerbach: I was looking to use code.haskell.org/arch ... I don't think pacman does ssh.. yet :P
16:07:55 <BMeph> Olathe: "The answer is 'Yes, hpaste2 can do that!" ;p
16:08:25 <ehird> Naturally.
16:08:27 <ehird> er
16:08:28 <ehird> wrong paste
16:08:30 <cytzol> aluink: It is - you're telling it to transform [x]
16:08:31 <Olathe> Heheh
16:08:31 <ehird> @define (|>) = flip ($)
16:08:49 <ski_> (dons : <http://moonpatio.com:8080/fastcgi/hpaste.fcgi/> ?)
16:09:04 <dons> woo
16:09:10 <dons> ?where hpaste2 http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
16:09:10 <lambdabot> I know nothing about hpaste2.
16:09:16 <ski_> where+
16:09:17 <dons> ?where+ hpaste2 http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
16:09:18 <lambdabot> Done.
16:09:25 <Trollinator> what's wrong with this:
16:09:28 <Trollinator> (-) :: [Rational] -> [Rational]
16:09:29 <aluink> so what's the point if it always takes a singleton? it seems that (d:ds) is always doing (x:[])
16:09:29 <Trollinator> (-) poly =  map (-) poly
16:09:53 <Trollinator> it says that it doesn't know whether to use Prelude.- or Main.-
16:09:55 <Lemmih> aluink: 'x' might be a Concat.
16:10:02 <ehird> Trollinator: what's the issue there?
16:10:06 <CakeProphet> is it valid to have something like
16:10:13 <ski_> Trollinator : the problem might be exactly what it says ..
16:10:29 <Trollinator> ski_: i should have asked "how do i fix it".
16:10:33 <CakeProphet> class (Obj c, Obj o) => Container c where stuff :: c -> o -> c
16:10:40 <aluink> Lemmih: ahh, right!
16:10:42 <CakeProphet> instead of writing the (Obj o) class constraint over and over.
16:10:46 <ehird> CakeProphet: no.
16:10:51 <CakeProphet> -nod- alright./
16:10:59 <Trollinator> i. e. how do i tell it to use whatever the unary minus means for a rational by default
16:11:17 <ski_> Trollinator : either : (a) use another name ; (b) hide `(Prelude.-)' ; (c) qualify by the module name
16:11:19 <aluink> Lemmih: thanks, makes sense now!
16:11:24 <ehird> what ski_ said
16:11:28 <aluink> Lemmih: and now i move forward ;)
16:11:36 <Trollinator> ski_: how do i qualify the module name?
16:11:44 <ehird> Trollinator: he showed you
16:11:46 <ski_> (Prelude.-)
16:11:49 <ehird> (Prelude.-) for default -
16:11:54 <ehird> (YourModuleName.-) for yours
16:11:59 <ehird> (if you haven't specified a module name, it's Main)
16:12:09 <Trollinator> ah i see
16:12:19 <ehird> but, I would rename it
16:12:20 <Trollinator> sorry, i'm pretty new to haskell.
16:12:26 <ehird> or you'll have to say Prelude.- whenever you do subtraction!
16:13:15 <Trollinator> err, why?
16:13:28 <ehird> because you'll say -
16:13:32 <ehird> that could be Prelude.- or YourModule.-
16:13:40 <ehird> haskell can't read your mind.. yet :-)
16:14:04 <Trollinator> the type is (-) :: [Rational] -> [Rational], so why shouldn't the interpreter be able to figure out which function to use?
16:14:09 <Olathe> (-) has to have only one type.
16:14:18 <Olathe> Num a => a -> a -> a is fine.
16:14:21 <ski_> Trollinator : because there already is another function with that name ?
16:14:26 <ehird> what ski_ said :-)
16:14:28 <Olathe> Or [Rational] -> [Rational] is fine.
16:14:33 <Olathe> But not both in Haskell.
16:14:54 <ehird> Trollinator: you could do this
16:14:58 <ehird> instance Num [Rational]
16:15:05 <ehird> then it could be either
16:15:11 <ehird> really, it's just not worth going down that confusing route
16:15:11 <Trollinator> hmmm.
16:15:15 <ehird> give it a better name ;-)
16:15:15 <Olathe> Trollinator: Are you trying to take the negative of everything ?
16:15:16 <eu-prleu-peupeu> byeeeee
16:15:25 <Trollinator> ehird: it is a good name
16:15:36 <ski_> @type (Prelude.-)
16:15:36 <pejo> ehird, and what would that mean?
16:15:37 <lambdabot> forall a. (Num a) => a -> a -> a
16:15:40 <ehird> i think we've seen sufficient evidence it's not Trollinator ;)
16:15:42 <ski_> @type Prelude.negate
16:15:42 <ehird> pejo: what?
16:15:43 <lambdabot> forall a. (Num a) => a -> a
16:15:44 <ehird> I'm talking to Trollinator
16:15:53 <Trollinator> I'm trying to write a program that will do calculations with polynom rings.
16:15:54 <pejo> ehird, "instance Num [Rational]"
16:15:58 <Olathe> > map negate [1..5] :: [Rational]
16:15:59 <lambdabot>   [(-1)%1,(-2)%1,(-3)%1,(-4)%1,(-5)%1]
16:16:03 <ehird> pejo: it was an example to shwo the ambiguity
16:16:16 <ehird> Trollinator: well, name it something else, because it isn't going to be pleasant naming it (-)
16:16:19 <Trollinator> where the [Rational] is the list of coefficients of the polynom
16:16:24 <Olathe> Trollinator: Ahh, make a type called Polynomial or something that's an instance of Num.
16:16:29 <ehird> ah
16:16:30 <ehird> right
16:16:32 <ehird> yes, what Olathe said
16:16:33 <Olathe> Trollinator: That'll make it work nicely once you have that.
16:16:43 <Trollinator> yes, i thought so.
16:16:53 <ehird> type Polynomial = [Rational]
16:16:54 <Trollinator> what requirements does Num impose?
16:16:57 <Olathe> You can easily subtract two polynomials or multiply them or show them or whatever.
16:16:58 <ehird> instance Num Polynomial where ...
16:16:58 <ski_> Trollinator : btw, `(-) poly =  map (-) poly' seems strange if that is supposed to be the same `(-)' instance in both places
16:17:03 <ehird> Trollinator: see the ghc library docs
16:17:20 <Trollinator> ski_: it's *not* supposed to be the same (-)
16:17:30 <ehird> Trollinator: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#7
16:17:50 <ski_> Trollinator : so what's the (intended) type of the latter `(-)', then ?
16:18:00 <Olathe> Trollinator: Make sure to implement either negate or (-), because the compiler won't tell you it's missing and you'll get weird infinite loops.
16:18:01 <Trollinator> Rational -> Rational
16:18:26 <ehird> Trollinator: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#7 <- Num typeclass
16:18:30 <ehird> wait i already said that
16:18:30 <ehird> oops
16:18:35 <ski_> Trollinator : and this function is defined in another module, i take it, yes ?
16:18:35 <Olathe> > let a = 5 in -a
16:18:37 <lambdabot>   -5
16:18:45 <Trollinator> ok, thanks.
16:18:49 <ehird> ski_: the solution is for him to make a num instanc
16:18:50 <ehird> e
16:18:53 <ehird> ;-)
16:18:59 <ski_> ehird : maybe, maybe not
16:19:05 <ehird> in this case, yes
16:19:06 <Olathe> Trollinator: I think -a or whatever automatically does 0 - a, so (-) is a -> a -> a
16:20:03 <Trollinator> Olathe: how is Haskell supposed to know what "0" means for a polynom?
16:20:19 <Pseudonym> :t fromIntegral
16:20:20 <ehird> depends what context you use it in.
16:20:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:20:27 <Pseudonym> Erm.
16:20:29 <Pseudonym> fromInteger
16:20:30 <ehird> if there's really none, (0::Polynomial) will work
16:20:34 <Pseudonym> :t 0
16:20:35 <lambdabot> forall t. (Num t) => t
16:21:11 <shapr> dons: awright!
16:21:35 <shapr> Where do I get mmorrow's hpaste2?
16:21:48 * ehird forsees epic
16:22:44 <glguy> shapr: github.com/glguy/hpaste
16:22:56 * ehird poises to get paste #1
16:23:27 <somnolence> is there a pseudorandom number generator built into haskell?
16:23:28 * BMeph warns ehird not to eat the (h)paste
16:23:42 <ehird> hmm, why does hpaste depend on a python syntax highlighter?
16:23:44 <ehird> that is kind of silly.
16:23:54 <BMeph> somnolence: yES, IN sYSTEM.rANDOM :)
16:24:01 <ehird> I LOVE CAPS LOCK TOO
16:24:06 <Trollinator> OK, so my basic mistake was to think that haskell calls the unary minus "(-)"
16:24:10 <BMeph> Sorry about the Caps Lock. ;p
16:24:15 <ehird> Trollinator: Indeed.
16:24:16 <Trollinator> and instead it's called "negate"
16:24:16 <ehird> It's negate.
16:24:31 <ehird> (-1) is just sugar.
16:26:04 <Olathe> > randoms.mkStdRandom $ 5
16:26:05 <lambdabot>   Not in scope: `mkStdRandom'
16:26:21 <Olathe> Hmm, Hayoo is down as well.
16:26:43 <Olathe> > randoms.mkStdGen $ 5
16:26:44 <lambdabot>   [7776561651304326943,2660592214809256573,-198934792153589140,-4772860058847...
16:26:53 <Peaker> how do I load jpg or other image files to use with GLUT?
16:26:55 <Olathe> > randomRs (5, 10).mkStdGen $ 5
16:26:55 <mjb> What is the difference between Hoogle and Hayoo?
16:26:56 <lambdabot>   [10,6,6,5,7,6,9,5,9,8,6,6,5,6,10,8,6,8,6,7,6,8,9,8,6,5,9,5,10,8,7,6,8,9,9,7...
16:27:10 <ehird> mjb: hayoo is apparently flashier
16:27:20 <Olathe> > randomRs (10, 5).mkStdGen $ 5
16:27:21 <lambdabot>   [10,6,6,5,7,6,9,5,9,8,6,6,5,6,10,8,6,8,6,7,6,8,9,8,6,5,9,5,10,8,7,6,8,9,9,7...
16:27:31 <Olathe> > randomRs (10, 10).mkStdGen $ 5
16:27:32 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
16:27:37 <Peaker> @let histogram = map (head &&& length) . group . sort
16:27:39 <lambdabot>  Defined.
16:27:51 <pumpkin> if I'm trying to link against libgmp and all there is in my lib dir is libgmp.so.3 (pointing at libgmp.so.3.3.3), will that work? (trying to get cabal-install on)
16:27:54 <Olathe> > histogram "zomg !"
16:27:55 <lambdabot>   [(' ',1),('!',1),('g',1),('m',1),('o',1),('z',1)]
16:27:56 <Peaker> > histogram . randomRs (10, 10) . mkStdGen $ 5
16:28:03 <pumpkin> or do I need a libgmp.so pointing at libgmp.so.3(.3.3) ?
16:28:05 <Olathe> That might take a while.
16:28:06 <Peaker> > histogram . randomRs (5, 10) . mkStdGen $ 5
16:28:17 <Olathe> > histogram . take 1000 . randomRs (10, 10) . mkStdGen $ 5
16:28:25 <lambdabot>   mueval: Prelude.read: no parse
16:28:25 <lambdabot>  mueval: /tmp/7361385239656928167: removeFil...
16:28:40 <Peaker> > histogram . take 10 . randomRs (10, 10) . mkStdGen $ 5
16:28:46 <Peaker> > histogram . take 10 . randomRs (5, 10) . mkStdGen $ 5
16:28:56 <Olathe> We're overloading the poor bot.
16:29:25 <lambdabot>   [(10,10)]
16:29:25 <lambdabot>   [(5,2),(6,3),(7,1),(8,1),(9,2),(10,1)]
16:29:58 <Peaker> > histogram . take 10000 . randomRs (0, 9) . mkStdGen $ 5
16:30:00 <lambdabot>   [(0,1027),(1,1037),(2,1007),(3,1020),(4,990),(5,999),(6,1003),(7,1016),(8,9...
16:30:14 <sbahra> Ah, very useful. :)
16:30:23 * sbahra needed a histogram some days ago
16:30:26 <sbahra> @hoogle histogram
16:30:27 <lambdabot> No results found
16:30:35 <Peaker> sbahra: @let histogram = map (head &&& length) . group . sort
16:30:38 <ehird> :t histogram
16:30:40 <sbahra> Ah, locally defined.
16:30:41 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
16:30:43 <sbahra> Peaker, nod
16:30:49 <glguy> ehird, it depends on that syntax highlighter because it was the only one with a free enough license to be used in a BSD3 licensed project
16:30:57 <ehird> glguy: heh :)
16:30:59 <glguy> (at the time, that might have changed)
16:30:59 <Peaker> @hoogle image
16:31:00 <lambdabot> Text.XHtml.Frameset image :: Html
16:31:00 <lambdabot> Text.XHtml.Strict image :: Html
16:31:00 <lambdabot> Text.XHtml.Transitional image :: Html
16:31:04 <Peaker> @hoogle loadimage
16:31:05 <lambdabot> No results found
16:31:07 <sbahra> Peaker, [fst r, fst r + ((snd r - fst r) / toEnum n) .. snd r] ;-p
16:31:09 <ehird> why not BSD2 btw? I guess because BSD3 is more common
16:31:22 <Peaker> sbahra: what's that?
16:31:24 <sbahra> Was what I ended up using for splitting classes
16:31:28 <glguy> ehird, just following along with GHC
16:31:46 <sbahra> r is the data range of a file containing temperatures, Peaker
16:31:49 <Peaker> sbahra: surely you can pattern match the tuple first :)
16:31:54 <mpeter> do you guys get the urge to use haskell for most of your projects
16:32:00 <sbahra> Peaker, yes, I can.
16:32:09 <mpeter> or do you have actual incentives placed for you
16:32:10 <Peaker> sbahra: let (x,y) = r in [x, x+((y-x)/toEnum n) .. y]
16:32:15 <mpeter> to code in haskell
16:32:33 <sbahra> Peaker, yes, yes. I know Haskell :-P
16:32:42 <Peaker> mpeter: Haskell is the only language I want to code in as a hobby in now
16:32:44 <sbahra> Peaker, it's really just a bad habit. I've been spending these days refactoring mostly to get them out.
16:32:56 <Peaker> mpeter: Learning Haskell kind of killed the fun in other languages, because its so much nicer in so many aspects
16:33:05 <mpeter> that's what i mean
16:33:15 <Peaker> mpeter: I use Haskell for all projects that I can
16:33:20 <mpeter> you start using xmonad, you say, "kde? what?"
16:33:24 <mpeter> "why would you want a taskbar"
16:33:42 <sbahra> Most projects I work on for fun involve too much overhead to start using Haskell for them, unfortunately.
16:33:49 <mpeter> and 500 packages for a WM
16:33:50 <sbahra> But I definitely do use whenever overhead is low.
16:34:08 <mpeter> in what context
16:34:18 <mpeter> i'm used to coding for the web so, the overhead is rarely a big issue
16:34:21 <sbahra> In the sense that I don't need to write dozens of FFI modules.
16:34:23 <paggas> hello, i have a performance related question: if i update an array (with //) and then pass it to a tail call (that is, the original array won't be used again), will the compiler (i'm using ghc) optimize this into an in place update of the actual data in memory?
16:34:35 <paggas> thanks for any answers!
16:35:02 <Peaker> paggas: I am not sure, I think you can google for array fusion, it is about doing that in some cases
16:35:02 <sbahra> paggas, yes as long as old data has no references. It is still evaluated lazily though.
16:35:07 <ehird> Always assume a sufficiently smart compiler and you get less gray hairs :P
16:35:14 <sbahra> paggas, make sure to compile with -O2.
16:35:24 <yip> sbahra: do you have a reference for this claim?
16:35:25 <sbahra> "references". :)
16:35:27 <pejo> sbahara, it does?
16:35:39 <mpeter> i don't understand how non-functional programming became so big
16:35:41 <mpeter> at this point
16:35:56 <ehird> mpeter: used to be a lot more efficient
16:35:57 <mpeter> i can understand procedural
16:36:00 <ehird> hardware is imperative.
16:36:03 <mpeter> but OOp?
16:36:04 <paggas> sbahra: ok, thanks! but can you point me also to some doc that documents this? :)
16:36:14 <ski_> (paggas : .. you might try `DiffArray')
16:36:21 <pejo> paggas, "Recycle your arrays!" is presented at PADL this year, I think it describes what you're asking for.
16:36:36 <sbahra> yip, well, performance data of my applications. If he is doing update(blah // x), wouldn't TCO make this "in place" if evaluated strictly?
16:36:44 <Peaker> so, are there Haskell libraries/bindings to load/save image formats (e.g jpg/png/bmp)?
16:37:06 <Zao> Peaker: There's ffi bindings to some native libs, I believe.
16:37:16 <ski_> sbahra : i don't think TCO would have much to do with this, if any
16:37:33 <paggas> pejo: what is PADL?
16:37:38 <sbahra> ski_, ok.
16:37:53 <sbahra> ski_, why not? What does it mean "in place"?
16:38:30 <pejo> paggas, a conference for functional programmers, but if your main interest is to get in-place updating I don't think the paper is the right resource for you.
16:38:34 <ski_> sbahra : that the whole array is not copied ?
16:38:39 <sbahra> I am assuming the structure itself is changed (and if things are shared, why isn't this the case).
16:39:04 <sbahra> ski_, yes, that is what I'm saying. If the whole array is not copied due to sharing and he is using tail calls, wouldn't the update be "in place"?
16:39:36 <ski_> sbahra : i don't see how the latter would follow from the former
16:39:41 <pejo> sbahra,if things are shared they need to be copied before you can safely update it
16:40:08 <sbahra> Ah, makes sense.
16:40:18 <sbahra> paggas, sorry, was talking out of my ass then :-P
16:41:02 <paggas> sbahra: meaning that Data.Array doesn't do in place updates? :)
16:41:03 <Trollinator> is there a function that works like map except that it also passes the index of the item in the list?
16:41:22 <Olathe> Trollinator: zip [0..].map f $ xs
16:42:35 <ski_> paggas : if you use a `DiffArray', then you get update-in-place .. and the old references are backpatched to refer to the new array plus the difference to the old (so accesses through them still get the old values, only slower)
16:43:08 <Trollinator> Olathe: thanks
16:43:14 <Olathe> Trollinator: You're welcome.
16:43:24 <yip> ski_: once ghc implements the optimization that paggas is looking for then DiffArray can be retired?
16:43:35 <ski_> (Olathe : i think Trollinator might have wanted to get each index as input to `f' ..)
16:43:51 <ski_> yip : i don't know
16:44:00 <Olathe> ski_: Ahh, maybe.
16:44:23 <Trollinator> ski_: yes, i just hadn't thought of the zip function.
16:44:31 <paggas> nice, thanks for the info!
16:44:32 <Olathe> If you want f to get the index too: map (uncurry f).zip [0..] $ xs
16:44:42 <yip> paggas: also STArray can do in place array updates
16:44:48 <paggas> now i can go implement dijkstra's algorithm :P
16:44:49 <ski_> @type \f -> map (uncurry f) . zip [0..]
16:44:50 <lambdabot> forall a c b. (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
16:44:55 <Trollinator> what does the $ do anyway?
16:45:04 <ski_> @src $
16:45:04 <lambdabot> f $ x = f x
16:45:09 <ski_> function application
16:45:11 <Olathe> Trollinator: It computes both sides.
16:45:34 <paggas> yip: it can get pretty ugly though
16:45:38 <Olathe> Trollinator: So, it'll get the whole function on the left computed, then the xs computed, then run them together.
16:45:40 <ski_> `map (uncurry f) . zip [0..] $ xs' is the same as `(map (uncurry f) . zip [0..]) xs'
16:45:42 <mpeter> $ is . with precedence of...0?
16:45:43 <lunabot>  luna: parse error on input `of'
16:45:47 <mpeter> whereas . has 6 or 7 i believe
16:45:55 <Olathe> No, it's not (.) exactly.
16:46:01 <Trollinator> Olathe: so it's merely an optimization?
16:46:02 <Olathe> It's just like a space.
16:46:05 <sbahra> @src (.)
16:46:05 <lambdabot> (f . g) x = f (g x)
16:46:06 <Pseudonym> @seen lemmih
16:46:06 <lambdabot> lemmih is in #ghc, #lhc-compiler and #haskell. I last heard lemmih speak 36m 10s ago.
16:46:14 <Olathe> Trollinator: No, it just makes it where I don't need so many parentheses.
16:46:22 <sbahra> Trollinator, no, it is convenience.
16:46:23 <Olathe> Trollinator: It's a syntax nicety.
16:46:38 <Trollinator> oh...
16:47:02 <Olathe> Trollinator: It puts the left in parentheses and the right in parentheses.
16:47:18 <Olathe> (map (uncurry f) . zip [0..]) (xs) is the same.
16:47:23 <Trollinator> i see.
16:47:48 <arw> its "not all functional languages need to be parentheses galore like lisp"
16:48:16 <Trollinator> arw: at least in lisp there are not so many funny operators to learn
16:48:26 <Trollinator> like >@> and >>= and whatever.
16:48:29 <arw> Trollinator: true :)
16:48:32 <paggas> actually i believe properly implemented tailcalls are maybe the killer feature that makes procedural languages obsolete :P
16:48:44 <thomashartman1> is there a way to print out a dep graph of what packages depend on what, for cabal?
16:49:01 <sbahra> Trollinator, and you don't "need" to learn these operators either. You could implement them yourself if you want. :-P
16:49:28 <pumpkin> is there some way I can tell cabal-install to always pass a certain linker flag (-L) when building?
16:49:28 <Trollinator> sbahra: that would defeat the purpose of learning a new language.
16:49:45 <Trollinator> and it makes you write ugly, non-idiomatic code.
16:50:33 <Olathe> salmon with bones still in--
16:53:46 <paggas> ummmm, DiffArray is in the IO monad?
16:54:28 <Trollinator> um, is there a Prelude function that will switch a function's arguments?
16:54:37 <Olathe> @type flip
16:54:38 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:54:44 <Olathe> @src flip
16:54:44 <lambdabot> flip f x y = f y x
16:54:55 <Trollinator> great!
16:55:01 <Olathe> Or...
16:55:06 <Olathe> @pl \x y -> f y x
16:55:07 <lambdabot> flip f
16:58:29 <ehird> Olathe: ha
16:59:09 <dons> glguy: if you want to help shapr set up hpaste2 i'd be happy :)
16:59:18 <pejo> pumpkin, .cabal/config?
17:01:55 <Trollinator> can you think of a more elegant way for this:
17:02:04 <Trollinator> map reverse (zipWith (:) some_list (map ((flip replicate) 0) [0..]))
17:02:39 <Olathe> > let f xs = map reverse (zipWith (:) xs (map ((flip replicate) 0) [0..])) in f [1..10]
17:02:40 <lambdabot>   [[1],[0,2],[0,0,3],[0,0,0,4],[0,0,0,0,5],[0,0,0,0,0,6],[0,0,0,0,0,0,7],[0,0...
17:03:20 <Trollinator> it prepends n zeros to the nth entry in the list.
17:04:15 <Olathe> > map (zipWith (++) (iterate (0:) []).(:[])) [1..]
17:04:16 <lambdabot>       No instance for (Enum [a])
17:04:16 <lambdabot>        arising from the arithmetic sequence ...
17:04:48 <sauf_> hi, nooby question : is it possible to get rid of variable str
17:04:49 <sauf_> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=811#a811
17:06:05 <Olathe> > zipWith (++) (iterate (0:) []).map (:[]) $ [1..]
17:06:07 <lambdabot>   [[1],[0,2],[0,0,3],[0,0,0,4],[0,0,0,0,5],[0,0,0,0,0,6],[0,0,0,0,0,0,7],[0,0...
17:06:43 <Olathe> @pl putStr "Hello " >> getLine >>= \str -> liftM2 (>>) (( return . putStrLn . (map toUpper) ) str) ( (return.return) str)
17:06:43 <lambdabot> putStr "Hello " >> getLine >>= ap (fmap . (>>) . putStrLn . map toUpper) (return . return)
17:07:08 <sauf_> thanks!
17:07:22 <Olathe> pl is nice :)
17:07:25 <Olathe> You're welcome.
17:07:33 <sauf_> indeed
17:08:37 <ehird> pl is nice for values of nice equal to awful
17:08:44 <Olathe> Heheh
17:09:13 <sauf_> is it possible to download it ?
17:09:17 <Trollinator> what is pl?
17:09:34 <shapr> glguy: y0 y0
17:11:00 <ski_> @type putStr "Hello " >> getLine >>= return . uncurry (>>) . (putStrLn . map toUpper &&& return)  -- sauf_ ?
17:11:01 <lambdabot> IO (IO String)
17:11:49 <sauf_> longer but nicer , thanks
17:12:13 <Olathe> Eeewwwww
17:12:19 <Olathe> IO (IO (IO a)))
17:12:30 <Gracenotes> IO (IO a)? You could use join on that, I should hope?
17:12:37 <Olathe> Maybe.
17:12:47 <shapr> forall e . e IO e IO
17:12:50 <sauf_> i tried but ...
17:12:54 <ski_> Gracenotes : it appeared sauf_ wanted to have an action returning an action ..
17:12:55 <Olathe> shapr: Hahah
17:12:56 <shapr> hm, that's not quite right
17:13:03 <Gracenotes> ah
17:13:07 <Olathe> @type join
17:13:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:13:14 <Olathe> Neat.
17:13:24 <Olathe> @type join $ putStr "Hello " >> getLine >>= return . uncurry (>>) . (putStrLn . map toUpper &&& return)
17:13:25 <lambdabot> IO String
17:13:28 <shapr> taruti: hi!
17:13:32 <sauf_> ... i couldn't fit liftM2
17:14:14 <ski_> sauf_ : in any case, note that `forall f a b. liftM2 f (return a) (return b) = return (f a b)'
17:14:48 <sauf_> ok
17:15:05 <CakeProphet> can a "type" definition include class constraints?
17:15:27 <Olathe> I think so.
17:15:37 <Olathe> It's not usually done, I think I heard.
17:15:59 <ski_> (sauf_ : fwiw, my version has exactly as many characters as the one given by lambdabot)
17:16:37 <CakeProphet> Olathe:  any reason in particular or is it just an unusual circumstance?
17:16:47 <sbahra> Olathe, with GADTs, yes?
17:16:49 <sauf_> ahah, i was fooled by the extra" @type" !
17:16:50 <dons> ?pl forkIOn c io = foo c (forkIO io)
17:16:50 <lambdabot> forkIOn = (. forkIO) . foo
17:17:04 <Olathe> sbahra: Oh, I'm not sure.
17:17:11 <sbahra> It seems like it.
17:17:13 <Olathe> I'm a bit new to types.
17:17:13 * sbahra tries
17:17:19 <CakeProphet> Olathe, if it the semantics of sane programs more difficult then I'll change my approach.
17:17:28 <Olathe> Or typeclasses rather.
17:17:59 <Olathe> CakeProphet: Do you mean you're doing data Whatever a and specify a ?
17:18:10 <CakeProphet> no... type
17:18:13 <sbahra> CakeProphet, I've been wanting to do this in some programs too.
17:18:24 <CakeProphet> type Whatever = (Class a) Map String a
17:18:28 <sbahra> Olathe, I'm thinking, (Num a) => Junk a constraint.
17:18:36 <CakeProphet> type Whatever = (Class a) => Map String a
17:18:38 <CakeProphet> I mean
17:18:55 <Olathe> CakeProphet: Ahh, I've only used data, so I'm not sure.
17:19:22 <Olathe> CakeProphet: ghc should tell you if you need an extension or if it can't do it.
17:19:28 <CakeProphet> Olathe:  I find type pretty useful. sometimes my type signatures get verbose.
17:19:34 <Olathe> Ahh.
17:19:39 <pumpkin> soooo
17:19:41 <pumpkin> every time I try to compile anything with ghc (including through cabal-install) it complains about libgmp being missing
17:19:42 <sbahra> CakeProphet, check out http://haskell.org/haskellwiki/GADT
17:19:48 <pumpkin> is there any way I can tell it permanently where my libgmp lives?
17:19:50 <sbahra> I'm writing a small example to see.
17:20:07 <sbahra> pumpkin, does GHC use LD_LIBRARY_PATH?
17:20:12 <chessguy> what's up with hpaste?
17:20:13 <dublpaws> does lambdabot have a reverse type lookup  type -> func_name?
17:20:23 <dons> stepcut: would you like to mention your tool here, http://therning.org/magnus/archives/458
17:20:23 <pumpkin> sbahra: I assume not, because the path with libgmp is on it
17:20:31 <chessguy> @hoogl (a -> b) -> [a] -> [b]
17:20:31 <lambdabot> Maybe you meant: hoogle hoogle+
17:20:37 <chessguy> dublpaws:  ^^
17:20:40 <Olathe> @help hoogle+
17:20:40 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
17:20:45 <dublpaws> thanks chessguy
17:20:48 <sbahra> @help google
17:20:49 <lambdabot> google <expr>. Search google and show url of first hit
17:20:52 <sbahra> @help hoogle
17:20:53 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
17:21:02 <chessguy> @help hpaste
17:21:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:21:08 <sbahra> @hoogle+ Int -> Int
17:21:08 <lambdabot> Data.Array.Diff readDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> Int -> IO e
17:21:08 <lambdabot> Data.Array.Diff replaceDiffArray :: (MArray a e IO, Ix i) => IOToDiffArray a i e -> [(Int, e)] -> IO (IOToDiffArray a i e)
17:21:13 <sbahra> @hoogle Int -> Int
17:21:13 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
17:21:14 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
17:21:14 <lambdabot> Test.QuickCheck configSize :: Config -> Int -> Int
17:21:27 <_flx> Hi
17:21:32 <ehird> hi
17:21:39 <roconnor> hi
17:21:41 <dublpaws> @hoogl Eq a => ([a] -> [a] -> [a] -> [a]) -> [a] -> [[a]] -> [[a]] -> [a]
17:21:42 <lambdabot> Maybe you meant: hoogle hoogle+
17:21:42 <pumpkin> > fix _fix
17:21:43 <lambdabot>   Not in scope: `_fix'
17:21:54 <_flx> I'm trying to get the result of 1^(1/0) and Haskell doesn't like that.
17:22:06 <_flx> ** I'm testing some float properties
17:22:09 <CakeProphet> sbahra:  hmm... no really sure I understand what GADTs are doing there.
17:22:12 <pumpkin> > 1 ** (1/0)
17:22:14 <lambdabot>   1.0
17:22:16 <CakeProphet> is it valid in GHC?
17:22:17 <_flx> Can you guys help me?
17:22:22 <Olathe> @type (^)
17:22:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:22:24 <pumpkin> _flx: ^^
17:22:32 <pumpkin> > 1 ** (1/0)
17:22:34 <lambdabot>   1.0
17:22:39 <sbahra> CakeProphet, it's an extension
17:22:40 <roconnor> , 1 ** (1/0)
17:22:41 <lunabot>  1.0
17:22:43 <sbahra> CakeProphet, http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
17:22:54 <Olathe> _flx: With (^), you need Num^Integral, and (1/0) isn't an Integral.
17:23:01 <roconnor> _flx: ^ is not exactly a floating point operation
17:23:03 <ski_> > 1 ** (1/0) :: CReal
17:23:05 <chessguy> who's running hpaste these days, shapr  ?
17:23:11 <roconnor> @type (^)
17:23:13 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:23:18 <lambdabot>   thread killed
17:23:25 <_flx> I see. So ** is the rational form of ^?
17:23:36 <Olathe> @type (**)
17:23:37 <roconnor> (**) is the floating point form of (^)
17:23:37 <lambdabot> forall a. (Floating a) => a -> a -> a
17:23:58 <Olathe> It's the Floating**Floating version.
17:23:58 <_flx> Nice. Thank you guys.
17:23:58 <pumpkin> _flx: ^ is specially optimized for ints
17:24:07 <pumpkin> (int exponents, that is)
17:24:19 <_flx> Other question: is there a way to access the infinity and the NaN representation?
17:24:24 * wli suspects bitreversal via countdown-and-test.
17:24:25 <Olathe> > 1/0 :: Float
17:24:27 <lambdabot>   Infinity
17:24:28 <Olathe> > 0/0 :: Float
17:24:30 <lambdabot>   NaN
17:24:37 <_flx> Ok. There is no constant for this?
17:24:41 <pumpkin> nope
17:24:43 <roconnor> no constant
17:24:44 <_flx> Like math.huge in python for example.
17:24:46 <_flx> Ok thx.
17:24:48 <roconnor> not all floating points have them
17:25:05 <_flx> You are very helpful here. I'm impressed.
17:25:17 <roconnor> be on the look out for isIEEE if you want really really portable code
17:25:20 <yip> why does haskell use :: for the type operator and not a single : ?
17:25:22 <ehird> this place is the second-friendliest programming channel on IRC :P
17:25:25 <CakeProphet> sbahra:  hmmm... I think I understand, I just don't understand what's different. Isn't the equivalent possible without GADTs?
17:25:28 <roconnor> > isIEEE (0::Double)
17:25:30 <lambdabot>   True
17:25:31 <ehird> yip:
17:25:32 <ehird> > 1:[]
17:25:34 <lambdabot>   [1]
17:25:35 <ehird> : is taken :-)
17:25:55 <dons> yip: it was felt that (:) for lists was more common
17:26:00 <dons> so optimising for the common case
17:26:08 <wli> Ugh, the gslhaskell package I was using has vanished from portage.
17:26:10 <dons> 1 :: [] is too verbose
17:26:14 <ehird> I type :: more than I do :, dons
17:26:15 <roconnor> I wish : wasn't symetric
17:26:22 <sbahra> CakeProphet, I don't know. I haven't seen any mention of it though.
17:26:24 <pumpkin> so if I do runghc Setup build -v --ghc-options="-L/net/grad/pumpkin/.local/lib", it finds ghc just fine, but if I do cabal install with --extra-lib-dir, it doesn't seem to pay any attention to the parameter :(
17:26:30 <yip> but can't the compiler tell that [] is a constructor and not a type?
17:26:45 <ehird> yip: ([] :: [Int])
17:26:45 <sbahra> dons, would you know the answer to CakeProphet's question? He was wondering if we could use class constraints in type declarations.
17:26:48 * BMeph will continue to presume the innocence of bitreversal and countdown-and-test.
17:26:52 <monochrom> yip: Because Haskell makes sense. List cons appears more often than types. Short symbols go to frequent uses, long symbols go to infrequent uses.
17:27:00 <dons> sbahra: you can, just usually not very useful
17:27:02 <pumpkin> by ghc above, I meant gmp
17:27:03 <sbahra> dons, something like, data (Class a) => Tree a = ...
17:27:14 <sbahra> dons, how would such a declaration look like?
17:27:21 <roconnor> monochrom: we should test out hackage plot token length vs frequency
17:27:38 <roconnor> and then OPTIMIZE!
17:27:42 <dons> right, data Eq a => Foo a = ... a ...
17:27:43 <roconnor> ]:D
17:27:45 <lunabot>  luna: Couldn't match expected type `[a]'
17:27:45 <dons> just doesn't help
17:27:50 <ski_> (yip : `[]' is also a type constructor ..)
17:27:50 <sbahra> Ah, ok :)
17:27:52 <dons> since functions on Foo still need the constraint as well
17:27:53 <ski_> @kind []
17:27:54 <lambdabot> * -> *
17:27:57 <bombshelter13> What does Haskell call a vector/array/non-linked list?
17:28:05 <roconnor> an array
17:28:15 <bombshelter13> roconnor: thanks :)
17:28:15 <roconnor> or
17:28:18 <sbahra> CakeProphet, there you go ;-p
17:28:19 <roconnor> a finger tree :P
17:28:23 <monochrom> Also take statistics to optimize operator precedences.
17:28:24 * sbahra changes some code
17:28:29 <sbahra> dons, thanks
17:28:32 <yip> or a ByteString
17:28:44 <roconnor> pfft
17:28:45 <pumpkin> :(
17:28:49 <yip> or a Ptr
17:28:54 <pumpkin> this is really frustrating
17:28:56 <roconnor> ByteString is just a glorified UArray
17:29:09 <CakeProphet> dons, by type declarations I meant with the type keyword. ;)
17:29:15 <ddarius> roconnor: No it isn't.
17:29:22 <ddarius> roconnor: I can do more with a UArray
17:30:06 <sbahra> CakeProphet, that is a type synonym.
17:30:07 <bombshelter13> roconnor: hm, a quick lookup suggests that finger trees are slightly different? Do they have similar performance characteristics to a regular array, assuming I'm only ever writing to the end and only ever traversing it in sequence?
17:30:27 <zloog> Is there an easy way to generate 100 random numbers between 0->100?
17:30:39 <_flx> Seems that haskeel float behave the same way as lua's one.
17:30:49 <pumpkin> _flx: ieee 754
17:30:54 <roconnor> bombshelter13: they are not like an array at all
17:30:56 <_flx> At least, for the unspecified behavior of ieee 754
17:31:03 <sbahra> CakeProphet, see section 4.2.2 of Haskell'98
17:31:04 <roconnor> bombshelter13: they have log(n) access
17:31:07 <MyCatVerbs> zloog: take 100 (randomRs generator (0,100))
17:31:12 <bombshelter13> roconnor: Oh, sounded like you were suggesting them as being similar above, perhaps i mixed two convos.
17:31:14 <sbahra> CakeProphet, http://haskell.org/onlinereport/decls.html
17:31:21 <zloog> MyCatVerbs: Thanks,
17:31:21 <Olathe> > take 100.randomRs (0, 100).mkStdGen $ 5
17:31:23 <lambdabot>   [66,3,88,23,73,2,76,8,69,92,97,50,6,86,49,96,47,41,33,39,24,24,92,74,34,30,...
17:31:27 <roconnor> but have great ability concatinate and extend in both ways
17:31:31 <_flx> pumpkin: Yes but the standard doesn't specifies some of the behaviors.
17:31:34 <Olathe> You can use something other than mkStdGen, of course.
17:31:45 <roconnor> bombshelter13: so they are a good replacement for an stl vector I'd say
17:31:57 <roconnor> bombshelter13: see Data.Sequence.Seq (IIRC)
17:32:23 <bombshelter13> But if I'm only reading linearly from start to finish, and only ever adding to the end, an array is likely to be fastest? It would be a series of Doubles...
17:32:23 <roconnor> bombshelter13: but if you want a fixed sized structure, then arrays are the way to go
17:32:39 <bombshelter13> roconnor: Cool, thanks *reads array usage documentation* :)
17:32:53 <roconnor> bombshelter13: if you are adding to the end, then it doesn't shound fixed size
17:33:07 <roconnor> bombshelter13: you want to use a Queue
17:33:40 <bombshelter13> roconnor: Well, I'm probably only producing it once, but in order. Does that change things?
17:33:44 <roconnor> bombshelter13: if you are very careful, you can even use a list.
17:33:57 <roconnor> a lazy list
17:34:02 <roconnor> which lists are by default
17:34:16 <Olathe> bombshelter13: Do you know the final size ahead of time ?
17:34:28 <pumpkin> dcoutts: you there?
17:34:29 <roconnor> Olathe: good question
17:34:53 <bombshelter13> roconnor: Yeah, I'm currently using lists but things seem to be getting kind of slow after a certain overall length...
17:35:25 <aluink> going through RWH here, and i'm having a hard time with the file naming in ch05, i'm building the pretty printer, and so far, i have PrettyStub, PrettyJSON, and Prettify, are those all the same file
17:35:31 <monochrom> finger trees will be much faster
17:35:36 <ddarius> :k RWS
17:35:38 <lambdabot> * -> * -> * -> * -> *
17:35:49 <aluink> i'm guessing that PrettyStub is a pretend file for the stubs
17:35:55 <ddarius> :k RWST
17:35:56 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
17:36:03 <ddarius> :k WriterT
17:36:05 <lambdabot> * -> (* -> *) -> * -> *
17:36:37 <roconnor> bombshelter13: I don't know your exact application
17:36:46 <roconnor> if you are using ++ a lot, then it will be slow
17:36:58 <roconnor> but if you can avoid (++) it could work very well
17:37:06 <roconnor> depedning on the details of your applicaton
17:37:35 <ddarius> :k Mu
17:37:36 <lambdabot> (* -> *) -> *
17:37:53 <roconnor> bombshelter13: as monochrom suggests, using Data.Sequence.Seq will give you decent performance without you having to think very much.
17:38:07 <roconnor> or maybe I should say "without having to be very clever"
17:38:09 * pumpkin is getting ready to scream at cabal-install
17:38:49 <CakeProphet> sbahra: ...I know what they are, I'm asking if they can have class constraints.
17:39:45 <bombshelter13> Olathe, roconnor Yes, I will know the size in advance... basically I'm going to produce a data structure keeping a list of events each including things like waveform, pitch, duration, start time, etc, and then, produce the final output waveform by iteration over an array/list/seq/etc, summing the output of the various tracks at each point in time...
17:40:01 <bombshelter13> Currently it's basically working, with lists, but very very slow once I try to render more than 3-5 seconds of audio.
17:40:12 <pumpkin> cabal-install is just ignoring me
17:40:24 <Olathe> bombshelter13: Ahh, then I'd recommend an array, since you won't need to resize it at all with that info.
17:40:33 <bombshelter13> Olathe: sounds good. :)
17:40:50 <roconnor> the only drawback with arrays is that it will all be in memory at the same time
17:40:59 <roconnor> it is probably a good way to start though
17:41:02 <Olathe> Ahh, good point.
17:41:27 <roconnor> I suspect there is a clever way to do what you want with lists
17:41:47 <roconnor> but since bombshelter13 is a bigger, IIRC, then he should probably try out arrays first
17:41:51 <roconnor> beginner
17:41:52 <roconnor> sorry
17:41:56 <bombshelter13> roconnor: perhaps, but that might have to wait until I've better learned the language and learn more clever tricks. :)
17:42:06 <roconnor> bombshelter13: exactly
17:42:09 <bombshelter13> s/learn/learned. :)
17:42:17 <sbahra> CakeProphet, and I referred you to documentation that would answer your question.
17:42:22 <sbahra> CakeProphet, and other similar questions you might have.
17:42:31 <sbahra> CakeProphet, what is the problem? No need for attitude.
17:42:36 <gwern> ack, hayoo is down
17:42:42 <bombshelter13> anyhow, gonna go read those documents :) probably back in a bit. :)
17:42:44 <Olathe> hpaste is, too.
17:42:46 <ehird> wait, what did CakeProphet say...?
17:42:50 <Olathe> It's a conspiracy !
17:42:54 * wli tries to figure out i there's a way to install both ghc-6.8.3 and ghc-6.10.1 at the same time on gentoo.
17:43:16 <sbahra> CakeProphet, the answer is pretty clear in 4.2.2. :)
17:44:15 <wli> (various things make me hope that it's vaguely possible)
17:45:57 <wli> Barring that, 6.10.1 is history.
17:46:37 <pumpkin> :(
17:46:47 <pumpkin> can anyone help?
17:47:01 <wli> Me, you, or someone else?
17:47:08 <pumpkin> me, ideally :P
17:47:28 <wli> I'm cabal-clueless, sorry.
17:47:29 <pumpkin> cabal-install's being mean to me
17:47:32 <pumpkin> mmkay
17:49:17 <CakeProphet> sbara:  No real frustration, but it would be similar to asking a question about how Haskell handles addition of Num instances of different types and having "Oh, that's called addition" as a response. Thank you for the reference though.
17:53:25 <dpratt71> @src interact
17:53:25 <lambdabot> interact f = do s <- getContents; putStr (f s)
17:53:59 <CakeProphet> is there anything in paritcular from stopping the possibly of including type signatures in patterns? (other than the lack of it being supported, obviously)
17:54:08 <somnolence> according to http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms QuickCheck can be imported as Test.QuickCheck, I'm getting a module not found error, I have ghc installed on debian sid any idea where it might be?
17:54:51 <CakeProphet> for example, a (+) (b :: Float) = ...     would only match if b were of type Float.
17:55:07 <dmwit> interact f = getContents >>= putStr . f
17:55:12 <dmwit> better
17:55:17 <Taejo> is there a simple way to translate a term in untyped lambda term into a Haskell function?
17:55:32 <dmwit> It's not possible in general.
17:55:58 <dmwit> Untyped terms which could nevertheless be typed can be translated into Haskell, of course.
17:56:14 <bombshelter13> hahah, I must say, on some superficial level, I'm fairly pleased by able to create x-indexed arrays, instead of having x chosen for me. :)
17:56:23 <bombshelter13> s/able/the ability /
17:56:31 <dmwit> bombshelter13, Nice, isn't it?
17:56:33 <dmwit> =)
17:56:53 * dmwit has used Bool-indexed arrays and even indexed arrays using his own data types
17:57:13 <CakeProphet> :t mkArray
17:57:14 <bombshelter13> dmwit: it's certainly a fun little change from the usual, and I suppose it saves some decrementing, in a few cases.
17:57:14 <lambdabot> Not in scope: `mkArray'
17:57:19 <SamB> dmwit: Bool-indexed ?
17:57:20 <roconnor> dmwit: why why?
17:57:25 <SamB> that's kind of a small array ...
17:57:49 <CakeProphet> I'm guessing the indexes only have to be Enums, right?
17:57:58 <roconnor> they have to be Ix
17:58:06 <dmwit> SamB, roconnor: Why not?
17:58:08 <roconnor> @instances Ic
17:58:10 <lambdabot> Couldn't find class `Ic'. Try @instances-importing
17:58:10 <roconnor> @instances Ix
17:58:11 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
17:58:18 <roconnor> hmm
17:58:26 <roconnor> @instances-importing Ix
17:58:28 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
17:58:30 * wli is not entirely sure how to define a new instance of Ix.
17:58:30 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Arr.html#t%3AIx
17:58:37 <dmwit> deriving (Ix)
17:58:38 <dmwit> ;-)
17:58:41 <SamB> @instances-importing Data.Array Ix
17:58:43 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
17:58:57 <wli> That's obviously not what I meant.
17:59:02 * roconnor is going to use an Ordering indexed array
17:59:04 <dmwit> Ix is actually not that hard to instance.
17:59:40 <dmwit> wli, check out http://dmwit.com/programming/MultiArray.hs for a really crappy example.
17:59:53 <Taejo> @info $
17:59:54 <lambdabot> ($)
17:59:55 <dmwit> instance Ix a => Ix [a] where ... -- this part
17:59:57 <Taejo> @info ($)
17:59:58 <lambdabot> ($)
18:00:03 <CakeProphet> what methods does Ix define?
18:00:04 <dmwit> Taejo, ?info -> ?undo
18:00:05 <ddarius> We could use Bool indexed arrays as an interface for SIMD, SSE, MMX instructions.
18:00:12 <dmwit> ?undo do { x <- foo; return y }
18:00:13 <lambdabot> foo >>= \ x -> return y
18:00:16 <dmwit> ?info do { x <- foo; return y }
18:00:17 <lambdabot> foo >>= \ x -> return y
18:00:36 <ddarius> @src Ix
18:00:36 <lambdabot> class (Ord a) => Ix a where
18:00:36 <lambdabot>     range           :: (a,a) -> [a]
18:00:36 <lambdabot>     index           :: (a,a) -> a -> Int
18:00:36 <lambdabot>     inRange         :: (a,a) -> a -> Bool
18:00:36 <lambdabot>     rangeSize       :: (a,a) -> Int
18:00:40 <Taejo> dmwit: can lambdabot tell me fixities?
18:00:46 <CakeProphet> ah okay.
18:00:48 <dmwit> Taejo, No, but ghci can.
18:00:50 <ddarius> Taejo: You can trick it into doing so.
18:00:56 <CakeProphet> > range (1,10)
18:00:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:01:00 <ddarius> > ($ $)
18:01:01 <lambdabot>   <no location info>: parse error on input `$'
18:01:12 <Taejo> dmwit: I thought @info in \bot == :i in ghci
18:01:17 <CakeProphet> > index (5,10) 6
18:01:18 <ddarius> > (3 $ 3 $)
18:01:18 <lambdabot>   1
18:01:19 <lambdabot>       The operator `$' [infixr 0] of a section
18:01:19 <lambdabot>          must have lower prece...
18:01:23 <ddarius> There you go.
18:01:27 <dmwit> ddarius, sneaky
18:01:27 <Taejo> lol, ok
18:01:44 <CakeProphet> hmmm... that's handy:   index (a,_) b = b-a
18:02:02 <ddarius> indices can be arbitrary data types
18:02:05 <dmwit> subtract a b = b-a, too
18:02:16 <ddarius> > index ((1,2), (5,29)) 10
18:02:17 <lambdabot>       No instance for (Num (t, t1))
18:02:17 <lambdabot>        arising from the literal `10' at <...
18:02:25 <ddarius> > index ((1,2), (5,29)) (3,5)
18:02:27 <lambdabot>   59
18:02:30 <sbahra> :t index
18:02:31 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
18:02:37 <CakeProphet> > index (1,2) 100000000
18:02:39 <lambdabot>   * Exception: Ix{Integer}.index: Index (100000000) out of range ((1,2))
18:03:36 <ddarius> @info do x <- y; return x
18:03:37 <lambdabot> y >>= \ x -> return x
18:05:10 <chessguy> @paste
18:05:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:05:15 <chessguy> :(
18:05:42 <CakeProphet> > index (((False, True), (False, True)), ((False, True), (False, True))) ((False, False), (False, False))
18:05:43 <bombshelter13> Huh, accumulating array sounds like it might be just what I need to mix a bunch of tracks. :D
18:05:44 <lambdabot>   * Exception: Error in array index
18:05:44 <kmeyer> @src Functor
18:05:45 <lambdabot> class  Functor f  where
18:05:45 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:07:01 <CakeProphet> > index (((False, True), (False, True)), ((False, True), (False, True))) ((False, True), (False, False))
18:07:02 <lambdabot>   * Exception: Error in array index
18:07:05 <CakeProphet> hmm
18:07:24 <CakeProphet> > index ((False, True), (False, True)) (False, False)
18:07:25 <lambdabot>   * Exception: Error in array index
18:07:45 <CakeProphet> tuple indices can't have tuple.... indices?
18:08:01 <ddarius> It's not a type error, it's an out of bounds error.
18:08:40 <CakeProphet> > index ((0, 100), (0,100)) (0,0)
18:08:41 <lambdabot>   * Exception: Error in array index
18:08:47 <ddarius> You are saying essentially index ((1,2), (1,2)) (1,1)
18:08:59 <CakeProphet> that's not possible?
18:09:12 <ddarius> range ((1,2), (1,2))
18:09:17 <ddarius> > range ((1,2), (1,2))
18:09:18 <lambdabot>   [(1,2)]
18:09:23 <ddarius> That's the only legal index.
18:09:24 <CakeProphet> ....oh
18:09:56 <CakeProphet> > range (((False, False), (False, False)), ((True, True), (True, True)))
18:09:58 <lambdabot>   [((False,False),(False,False)),((False,False),(False,True)),((False,False),...
18:10:11 <CakeProphet> ah okay.
18:10:50 <dublpaws> > foldl (++) "" ["asdf", "1234"]
18:10:52 <lambdabot>   "asdf1234"
18:11:06 <pumpkin> concat
18:11:12 <ddarius> @src concat
18:11:13 <lambdabot> concat = foldr (++) []
18:11:15 <pumpkin> foldr might be better
18:11:19 <dublpaws> is that the closest to ''.join('asdf', '1234') from pyth... ok nvermind thanks pumpkin
18:11:20 <pumpkin> in fact, it will
18:11:39 <pumpkin> dublpaws: if you want flexibility with what you stick between the strings
18:11:42 <pumpkin> look at intercalate
18:11:51 <pumpkin> or arbitrary lists, really
18:11:54 <ddarius> @src intercalate
18:11:55 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
18:12:07 <CakeProphet> > intercalate " " ["I'm", "a", "pirate"]
18:12:08 <lambdabot>   "I'm a pirate"
18:12:12 <pumpkin> yarr!
18:12:23 * ddarius waits for it.
18:13:07 <CakeProphet> > unwords ["I'm", "a", "pirate"]
18:13:09 <lambdabot>   "I'm a pirate"
18:13:12 <CakeProphet> :P
18:13:14 <somnolence> how can I cast type IO Int into type Int?
18:13:22 <pumpkin> somnolence: you can't, but you can bind it to something
18:13:34 <pumpkin> <- makes that extra simple, within a do block
18:13:43 <CakeProphet> do { x <- IoIntValue; doThingsWith x}
18:13:50 <dibblego> somnolence, once you're in IO then you stay in there - this is the thesis of pure functional programming
18:14:00 <somnolence> bah :(
18:14:08 <ddarius> somnolence: What previous languages do you know?
18:14:14 <dibblego> somnolence, this is a *good* thing - why don't you show what you'd like to do?
18:14:25 <dublpaws> >intercalate "-" "norriswasaninja"
18:14:38 <CakeProphet> won't work there.
18:14:39 <somnolence> I would like to cast the result of let (x, r2) = randomR (min,max) r1
18:14:41 <CakeProphet> :t intercalate
18:14:42 <lambdabot> forall a. [a] -> [[a]] -> [a]
18:14:44 <somnolence> to an Int
18:14:46 <CakeProphet> dublpaws:  it wants a list of lists.
18:14:50 <CakeProphet> such a list of strings.
18:14:51 <somnolence> so I can use the random number in my function
18:15:03 <Taejo> :t intersperse
18:15:03 <pumpkin> > intersperse '-' "norriswasaninja"
18:15:04 <lambdabot> forall a. a -> [a] -> [a]
18:15:05 <lambdabot>   "n-o-r-r-i-s-w-a-s-a-n-i-n-j-a"
18:15:05 <dublpaws> >intercalate "-" ["norris", "was", "a", "ninja"]
18:15:25 <CakeProphet> also... you need a space after the >
18:16:09 * wli suggests an octagonal Schwarz-Christoffel transformation in honor of Chuck Norris' ninjitsu.
18:16:14 * pumpkin loves SCPing stuff at 10MB/s
18:16:20 <dublpaws> ok, excellent...
18:16:21 <somnolence> Is there an easy way to get a random Int in a range?
18:16:27 * dublpaws rubs hands together sinisterly.
18:16:28 <pumpkin> somnolence: certainly!
18:16:35 <dons> somnolence: System.Random
18:16:36 <pumpkin> randomRIO is one way
18:16:38 <inforichland> anyone suggestions for a good project for an intermediate haskeller to work on who wants to start giving back to the haskell community ?
18:16:45 <somnolence> pumpkin doesn't that return type IO Int?
18:16:50 <pumpkin> inforichland: check out the haskell_proposals reddit :)
18:17:01 <pumpkin> somnolence: what's wrong with that?
18:17:21 <inforichland> pumpkin: i'll give it a lookover :)
18:17:40 <CakeProphet> inforichland:  helping me make a MUD client. :P
18:17:58 <somnolence> pumpkin: the problem is I need to use it in a function with pure Int types
18:18:32 <pumpkin> somnolence: there are ways of threading your PRNG state through it using a Random monad
18:18:38 <pumpkin> there's one on hackage
18:18:38 <inforichland> cakeprophet: any particular game in mind? ;)
18:18:49 <pumpkin> otherwise, you can just carry your PRNG state around by hand
18:19:16 <CakeProphet> inforichland:  sort of. I'm making a generic roleplay-oriented codebase. Not a lot of combat code, just a clean system with rooms, props, people, etc.
18:19:32 <somnolence> I'm sorry I don't understand :(
18:19:33 <dons> wow, the employment  thread is turning out pretty well :)
18:19:41 <CakeProphet> inforichland:  oh yeah and... just for fun... each player gets thread. :D
18:19:45 <CakeProphet> *a thread
18:19:51 <inforichland> cakeprophet :D
18:19:55 <somnolence> http://rafb.net/p/AIEnmy64.html is what I'm trying to do
18:20:06 <pumpkin> lol, I like the memory leak report on -cafe
18:20:08 <ddarius> CakeProphet: If you are writing the server, why are you writing the client?  Why not use a pre-existing client?
18:20:17 <ddarius> pumpkin: Yeah, that's a bit silly.
18:20:21 <CakeProphet> ddarius:  oh... I meant server. Not client.
18:20:37 <pumpkin> OMG I TRIED TO PRINT AN INFINITE LIST WHY DON'T I HAVE ENOUGH MEMORY FOR IT?
18:20:48 <dmwit> Well... why doesn't he?
18:20:48 <somnolence> lol
18:21:08 <inforichland> pumpkin: /whoosh
18:21:09 <dmwit> print [1..] -- works pretty okay here...
18:21:23 <dons> http://www.reddit.com/r/haskell/comments/7qyqy/haskell_for_buses_and_trucks/ lovely stuff
18:21:41 <CakeProphet> > unwords (repeat "lawl")
18:21:43 <lambdabot>   "lawl lawl lawl lawl lawl lawl lawl lawl lawl lawl lawl lawl lawl lawl lawl...
18:21:47 <ddarius> dons: How do you go from 98,000 lines of code of anything to 4000 of Haskell?
18:21:50 <dmwit> Oh yeah, somebody posted about the scheduling stuff a month or two ago.
18:21:51 <dmwit> Very cool.
18:22:31 <CakeProphet> inforichland:  I'm trying to decide which concurrency approach to use. Yesterday I started toying with message-passing, but now I'm looking into STM
18:22:45 <dons> ddarius: you automate a bunch of stuff with a DSL
18:22:46 <inforichland> cakeprophet: that's a tough decision.
18:22:52 <CakeProphet> it is.
18:22:56 <inforichland> cakeprophet: i've done some erlang before, and message passing can be very nice
18:22:57 <dons> order of magnitude reduction in complexity, and increase in reuse.
18:23:04 <ddarius> dons: Was it generated code or just insane boilerplate?
18:23:07 <pumpkin> inforichland: :(
18:23:08 <inforichland> cakeprophet: but STM is much more powerful, imho
18:23:11 <dons> ddarius: unknown.
18:23:18 <dons> this thread in general makes me happy, http://thread.gmane.org/gmane.comp.lang.haskell.cafe/51045/
18:23:36 <inforichland> pumpkin: oh i's just teasing :D
18:23:39 <pumpkin> :'(
18:23:43 <byorgey> somnolence: the point is, if your function needs random numbers, you have two choices: (1) have it compute its results in some monad, like IO or (even better) Random (from the MonadRandom package), or
18:23:58 <byorgey> (2) have it take an extra parameter which is the state of some pseudo-random number generator
18:23:59 <dons> ddarius: so you don't get to use haskell at work yet?
18:24:16 <byorgey> somnolence: in particular, having it be a 'pure' function is not an option, because it *isn't* a pure function.
18:24:16 <ddarius> Message passing is a very nice way to decompose some concurrency problems.
18:24:35 <CakeProphet> inforichland:  STM looks like less boilerplate I think. With message passing I have to give each thread a Chan Message and define a huge Message class with all the different kinds of requests/replies I plan on using to communicate between threads.
18:25:03 <somnolence> byorgey: is there anyway to generate a pure random int?
18:25:05 <ddarius> dons: I probably could on the side if I wanted to, but it is definitely not going to happen for the actual projects.
18:25:41 <byorgey> somnolence: if you are asking what I think you are asking, the answer is no.
18:25:46 <inforichland> cakeprophet: well you still have to have some protocol for delivering data across threads
18:25:49 <ddarius> dons: Personally, as I said earlier, I don't actually think using Haskell now for what I do would be a win for the environment I work on.
18:25:54 <inforichland> cakeprophet: but I definitely think less boilerplate
18:26:16 <byorgey> somnolence: if you have a function of type (say)  Int -> Int, referential transparency dictates that it must always give the same output for the same input
18:26:22 <CakeProphet> inforichland:  yeah. Mvars might work as well, but I might not be anticipating all the deadlocks that could happen.
18:26:38 <byorgey> somnolence: therefore it can't use some random value internally.
18:26:45 <somnolence> right :(
18:26:49 <CakeProphet> basically with mvars only one thread could have access to a certain character at a given time.
18:26:50 <byorgey> somnolence: so you have to reflect the randomness in the type, like  Int -> Random Int
18:26:52 <inforichland> cakeprophet: yeah, mutexes leave a bad taste in my mouth
18:26:59 <byorgey> somnolence: see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
18:27:09 <byorgey> the MonadRandom package is quite nice =)
18:27:39 <CakeProphet> inforichland:  it would be easier to just do a simple interpreter loop thing... but I feel like mastering concurrency. It's my first time trying it in any language.
18:28:02 <inforichland> cakeprophet: that's noble :) I've done a leetle bit with it in erlang
18:28:18 <dons> ddarius: due to library issues? or architectural constraints?
18:28:25 <dons> or cultural issues?
18:30:59 <CakeProphet> inforichland:  this is probably a tough project for concurrency. You've got an arbitrary number of threads doing arbitrary user-dictated things at any given time.
18:31:23 <inforichland> cakeprophet: well, you could have a "worker pool" of threads
18:31:45 <CakeProphet> I might start with something simple instead.... like having a thread that reads socket data for each user and then yeah, a "worker pool" or just a single master thread.
18:32:01 <ddarius> dons: Yes.  Library issues: Haskell doesn't have great web development stuff and doesn't really have anything for sticking into IIS and talking to SQL server.  We primarily use .NET.  Most of the programmers here either have little experience programming and what little they have is (now) in C#, the others mostly have no experience with things other than C#, VB, C++, Java and the myriad of other languages one always uses.
18:33:13 <inforichland> cakeprophet: have a codebase started anywhere ?
18:33:13 <ddarius> dons: Getting Haskell in for projects would take a lot of effort just paperwork-wise.  It would also require me single-handedly building training courses for it, and of course to even get that far I'd need to be able to demonstrate that it would be worth it.
18:33:32 <CakeProphet> inforichland:  you mean the rest of it? Sort of.
18:33:42 <dons> .NET/C# land is a tough sell, yes.
18:34:10 <dons> i'd say the usual python/perl style web dev stuff is pretty well handled (at least, quite a few people are doing that now), but not if its windows-ish
18:34:12 <somnolence> what is the command to install a Cabal package?
18:34:33 <dons> cabal install foo
18:34:57 <sjanssen> alternatively: runghc Setup {configure,build,install}
18:35:08 <pumpkin> about that runghc Setup
18:35:13 <pumpkin> how can I ask it to build a profiling version
18:35:16 <pumpkin> of the lib
18:35:19 <inforichland> cakeprophet: have you looked at/gone through the STM examples on the wiki ?
18:35:23 <sjanssen> pumpkin: --enable-library-profiling
18:35:30 <pumpkin> on the configure step?
18:35:35 <CakeProphet> inforichland:  noep.
18:36:07 <dancor> why are zippers cooler than just having (Tree, [Node]) where the list tells you how to get to the current position from the Top
18:36:23 <dancor> doesn't laziness make that just good
18:36:23 <ddarius> O(1) update
18:36:33 <sjanssen> O(1) access of the current element
18:36:37 <dons> more invariants maintained by the structure (i.e. out of bounds checks are done statically :)
18:36:50 <sjanssen> O(1) navigation to nodes next to the element
18:36:51 <CakeProphet> dancor:  I used a zipper to simulate a Turing tape... in that case it's much much better.
18:37:41 <CakeProphet> inforichland:  I'd paste what I have, but hpaste is down. Do you know of any alternatives?
18:37:46 <sjanssen> perhaps a more interesting question is why *not* to use the zipper?
18:38:00 <dancor> i'm making a positioned ordered tree (to track a go/chess game's variations), but i'm wondering if a zipperesque approach will get ugly
18:38:07 <ddarius> sjanssen: Zipper is a scary word out of ... oh wait
18:38:10 <inforichland> cakeprophet: um, let me see if my email server is still up
18:38:25 <sjanssen> ddarius: scary word out of tailoring? :)
18:38:47 <CakeProphet> dancor:  as long as you have the proper abstraction, it'll be very natural to use.
18:38:55 <dancor> zipper is fine if you don't want to order the variations into main line vs variant 1, 2, etc
18:39:21 <sjanssen> dancor: aren't game trees generally massive?  Seems like the breadcrumb approach might be a bad idea
18:39:26 <inforichland> cakeprophet: crap, it's not; i was getting too many break-in attempts
18:39:47 <pumpkin> especially a go tree
18:39:55 <CakeProphet> inforichland:  well, what I have does not run at all. In fact I've got identifiers in it that haven't even been defined yet.
18:40:02 <dancor> for zipper tho, i guess the tree-context is going to be (prenodelist, postnodelist)
18:40:16 <dancor> i guess that's bearable
18:40:22 <chessguy> sjanssen:  pff, a mear 10^50
18:40:26 <chessguy> *mere
18:40:33 <chessguy> (for chess)
18:40:39 <pumpkin> go is massive
18:40:48 <pumpkin> probably a lot bigger than that
18:40:49 <chessguy> > 19*19
18:40:50 <lambdabot>   361
18:40:50 <dancor> i'm not generating the entire move tree lol
18:40:52 <inforichland> cakeprophet: pastebin
18:41:42 <CakeProphet> ah, it has Haskell highlighting
18:41:42 <chessguy> dancor:  what are you doing? i've done some chess ai programming
18:41:45 <CakeProphet> inforichland:  http://pastebin.com/m4c9883fd
18:41:56 <CakeProphet> also, some of my typeclass knowledge is shoddy... so what I have might not even make sense.
18:42:48 <inforichland> cakeprophet: :P
18:43:07 <dancor> chessguy: just a go game client like qgo http://dzl.no-ip.org:81/gitweb/?p=goa.git;a=tree;f=src
18:43:31 <CakeProphet> inforichland:  compared to the Python codebase I started the typeclass logic is looking really clean.
18:43:44 <chessguy> dancor:  oh, just a UI?
18:43:45 <CakeProphet> the concurrency will be the tough part.
18:43:50 <dancor> chessguy: ya
18:43:51 <inforichland> cakeprophet: well, you're not using python ;)
18:44:12 <chessguy> dancor:  cool. implementing the go engine protocol would be a nice feature
18:44:27 <CakeProphet> inforichland:  not quite.
18:44:28 <dancor> chessguy: it does, well enough of it to play against gnugo
18:44:38 <chessguy> cool
18:44:47 <inforichland> cakeprophet: http://pastebin.com/d411a869
18:44:52 <inforichland> there's a simple example of STM
18:45:07 <chessguy> dancor: time to hackage :)
18:45:54 <dancor> chessguy: well i want to resolve this i-didn't-bother-to-order-variations business
18:46:13 <dancor> how soon is too soon to hackage
18:46:28 <chessguy> order variations? for what?
18:46:46 <dancor> loading an sgf, you want to be able to determine the main line etc
18:47:03 <dancor> it has branching history
18:47:26 <gwern> there are enough haskell go players that I always wonder at there being no go software
18:47:41 <chessguy> oh well, bedtime for me
18:48:16 <dancor> i will try to make the zipper work.  y'all have convinced me that i was being lazy
18:48:52 <ddarius> gwern: They use pre-existing go software
18:49:24 <CakeProphet> inforichland:  Trying to read it.
18:49:31 <dancor> that would be more reasonable if existing go engines weren't terrible
18:50:14 <gwern> dancor: I don't think a haskell reimplementation will magically be make it 1 dan or anything :)
18:50:35 <dancor> mine certainly wouldn't ;)
18:51:17 <ddarius> CakeProphet: Your classes are totally broken.  You are trying to use them as if they were OO classes.  They are not.
18:51:41 <CakeProphet> ddarius:  whch part is broken.
18:51:46 <CakeProphet> and no, I'm not.
18:52:22 <ddarius> CakeProphet: You can't write meaningful instances for any of them except the extremely trivial one you've written.
18:53:41 <pumpkin> is there any benefit to spawning more native threads than I have cores?
18:53:50 <CakeProphet> ddarius:  actually I'm not using that anymore. I decided Prop is better represented as a type and not as a typeclass.
18:53:57 <ddarius> pumpkin: It usually helps to have a few more than cores.
18:54:10 <ddarius> CakeProphet: That's very likely true.
18:54:42 <arw> pumpkin: if threads wait for some reason, like on some IO, the the others can be scheduled instead, thereby increasing cpu utilization.
18:55:08 <inforichland> cakeprophet: if you're coming from an OOP background, typeclasses are similar to interfaces
18:55:19 <CakeProphet> inforichland:  -nod- I know.
18:55:26 <ddarius> CakeProphet: You can't implement pretty much any of the methods of HasProps in a meaningful way.  You can't implement location in Thing in a meaningful way.  You can't implement any method of Container in a meaningful way.
18:55:48 <CakeProphet> ddarius:  how can you not?
18:55:50 <ddarius> inforichland: Not really.  They're different enough that I'd say that that does more harm than good.
18:56:06 <ddarius> CakeProphet: Write a non-trivial instance for any of them.
18:56:14 <inforichland> ddarius: ok, fair enough
18:58:20 <inforichland> ddarius: have a better one-line explanation ?
18:58:59 <ddarius> inforichland: Nothing at all would be a better description.  Nothing at least doesn't mislead you.
18:59:06 <CakeProphet> ddarius:  why do they need to be non-trivial. The whole point is that hasProps only needs two functions defined and every other operation is done.   instance HasProps Object where { getPropMap x = propMapRecord x;  setPropMap x  = x {propMapRecord = x} }
18:59:43 <ddarius> CakeProphet: By "non-trivial", I mean they actually do what the names say.  I mean you use all the arguments and don't use undefined (or an equivalent) anywhere.
19:00:13 <ddarius> CakeProphet: For example, for location the only type checkable definition is const undefined (or some variation of that)
19:00:24 <ddarius> If you don't believe me, make an instance that does something interesting.
19:02:02 <Taejo> I think I remember somebody mentioning a Haskell ambigram in the logos thread; anyway, I've made one, if anybody cares: http://haskell.org/haskellwiki/Image:HaskellAmbigram.png
19:02:02 <bombshelter13> When defining a type, can I make it basically be a subset of an existing type? Like, as a specific example, can I make a NoteName type whose first field is a string, but specifically only the strings "C", "C#", "D",...?
19:02:03 <CakeProphet> ddarius:  location just returns any Container... why isn't that possible?
19:02:11 <ddarius> CakeProphet: Try it and find out.
19:02:31 <ddarius> CakeProphet: Your types don't say what you think they do.
19:03:00 <CakeProphet> ddarius:  explain.
19:03:05 <Taejo> bombshelter13: you can have it abstract (define it in a module and don't export its constructor), but I'd probably just do data Note = C | CSharp | ...
19:03:16 <CakeProphet> what about location    :: (Container c) => t -> c    doesn't do what I'm expecting.
19:03:19 <ddarius> CakeProphet: Try it first.
19:03:39 <bombshelter13> Taejo: So just not actually define the C, CSharp types, and leave them as symbols?
19:03:44 <CakeProphet> ddarius:  my code isn't completely defined. I can't.
19:04:06 <Taejo> bombshelter13: well, I wouldn't call that "not defining" them, I'd call that "defining" them
19:05:05 <ddarius> CakeProphet: Remove everything but what you need for the HasProps class remove all the methods of HasProps except getPropMap (you can add any others that you like if you think they'll help.)  Implement getPropMap and a very simple example using it.
19:06:04 <bombshelter13> Taejo: : hm, I see. I'll try it that way and see how far I get :)
19:06:22 <ddarius> If you change p to Prop like it sounds like you'll do, then implement getProp instead.
19:07:58 <ddarius> inforichland: But a short definition is to take the word "class" like it is used in set theory (so "set" would also work).  A type class is a set of types asserted to support a particular interface.  Eq a, in (Eq a) => a -> a -> Bool means a is a member of the set Eq.
19:08:25 <Taejo> bombshelter13: depending on your application, MIDI note numbers might be a good representation, too
19:08:32 <inforichland> ddarius: yeah, I guess that's the better way to look at it
19:08:34 <ddarius> An instance declaration, such as instance Eq Bool, is an assertion that Bool is in Eq (and a proof)
19:08:48 <inforichland> ddarius: as opposed to the other way around
19:09:21 <roconnor> frequency :: Scale -> Note -> Double
19:09:25 <inforichland> as opposed to say that "Bool implements Eq" to say that Bool is in Eq
19:09:28 <ddarius> inforichland: The big difference between Java interfaces and Haskell type classes is the existential type that is folded into the meaning of Java interfaces.
19:09:48 <roconnor> or maybe
19:09:58 <ddarius> inforichland: That existential is what allows dynamic dispatch and List<ICollection>
19:09:59 <roconnor> type Scale = Note -> Double
19:10:41 <ddarius> Dynamic dispatch is also why things like Monad or Read don't make sense as Java interfaces.
19:11:14 <inforichland> right, it's not the typeclass that's using the functions
19:11:24 <bombshelter13> Taejo: Yeah, currently, in what I have (using standard types only), 'note "A#" -2' produces a midi note num and then uses that as the argument to another function that gets the frequency... redoing it with custom types, I suppose I could specify a NoteValue as being either a name octave pair or as a MidiNoteNum, though.
19:12:10 <inforichland> or rather, that's calling them and they belong to
19:12:24 <dons> yay, new galois people releasing on hackage, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/beautifHOL-0.1
19:12:56 <Taejo> bombshelter13: that gives you two representations of the same thing... not a good idea
19:14:02 <bombshelter13> Taejo: Hm, I kind of figured it might be nice to have more than one way of calling things... for a human, using the names and octaves is more convenient, so being able to translate that sort of input would be good... but internally, if generating sequences itself, the program could save time by not translating the note numbers...
19:14:14 <mpeter> what's better, passing the value of a function up through 6 more functions several times into an accumulating result, or expressing the pieces of the result one by one
19:14:21 <pumpkin> > [1..1]
19:14:23 <lambdabot>   [1]
19:14:33 <mpeter> > [1]
19:14:35 <lambdabot>   [1]
19:15:25 <enoksrd> @pl \s -> (id s, s)
19:15:25 <lambdabot> join (,)
19:15:54 <enoksrd> @pl \s -> (lines s, s)
19:15:54 <lambdabot> (,) =<< lines
19:16:04 <Taejo> bombshelter13: well, if you're going to have multiple representations, don't include them all in the same type. Rather have functions to translate between representations
19:16:07 <mpeter> i understand that the latter choice is uglier to work with
19:16:20 <enoksrd> @pl \s -> (snd s, s)
19:16:21 <lambdabot> (,) =<< snd
19:16:51 <bombshelter13> Taejo: Hmm, that seems fairly sensible, yeah... that's sort of less work too, I suppose, as it involves leaving more things as they are.
19:17:04 <mpeter> but let's say i have to render a full 800x600 image every frame of an application
19:17:20 <mpeter> my only option is to have a top-level function
19:17:40 <mpeter> every-frame render (enV)
19:18:15 <mpeter> hmm
19:18:54 <enoksrd> > ((,) =<< snd) (1,2)
19:18:56 <lambdabot>   (2,(1,2))
19:19:15 <mpeter> my question really is, what kind of costs are incurred solely by calling a function
19:19:59 <roconnor> @faq can Haskell make function calls for free?
19:20:00 <lambdabot> The answer is: Yes! Haskell can do that.
19:20:14 <Olathe> I thought it was ten cents a minute.
19:20:15 <pumpkin> {-# INLINE functionName #-}
19:20:36 <inforichland> cakeprophet: I guess a better way of defining a typeclass is to say that it's a contract: when a type is an instance of a class, it says that it implements those functions for its type, however it makes sense for that type
19:20:39 <mpeter> so there's no addressing involved
19:20:42 <dancor> @faq Can Haskell do things that Haskell cannot do?
19:20:42 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:02 <inforichland> @faq Can Haskell get nerds laid?
19:21:02 <mpeter> @faq can haskell understand my inner pain
19:21:02 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:03 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:05 <dancor> @slap cantor
19:21:06 * lambdabot decomposes cantor into several parts using the Banach-Tarski theorem and reassembles them to get two copies of cantor!
19:21:08 <Taejo> bombshelter13 reminds me of *my* old sound library; I gave up when I couldn't figure out a good way to make 'echo signal = signal + 0.5*(signal `at` 1)' work (evaluating an echoed signal at any given time will result in an infinite loop)
19:21:37 <monochrom> Hahaha great thing to do to Cantor!
19:21:59 <pumpkin> @karma
19:22:00 <lambdabot> You have a karma of 3
19:22:04 <bombshelter13> Taejo: Heh :) Curious, if you've done sound stuff what did you use for audio I/O?
19:22:07 <dancor> @krma
19:22:07 <lambdabot> You have a karma of 0
19:22:14 <inforichland> @karma
19:22:14 <lambdabot> You have a karma of 0
19:22:23 <mpeter> how did he get @krma...
19:22:28 <pumpkin> edit distance
19:22:31 <sanity> I'm curious as to how Haskell represents graphs internally in an efficient way - given that there seems to be no way to reference an object?
19:22:35 <dancor> @lusers
19:22:35 <mpeter> now there's good bot authoring
19:22:35 <lambdabot> Maximum users seen in #haskell: 653, currently: 599 (91.7%), active: 21 (3.5%)
19:22:42 <enoksrd> @type =<<
19:22:44 <lambdabot> parse error on input `=<<'
19:22:51 <enoksrd> @type (=<<)
19:22:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:23:13 <Olathe> But there are only 598 people.
19:23:17 <Olathe> @lusers
19:23:17 <lambdabot> Maximum users seen in #haskell: 653, currently: 599 (91.7%), active: 22 (3.7%)
19:23:35 <Olathe> Is my server incorrect ?
19:23:42 <pumpkin> mine says 599
19:23:51 <Taejo> bombshelter13: I did raw output to a file (with a convenience function play = write "/dev/dsp")
19:24:03 <ddarius> CakeProphet: Anyway, I'm going to watch a movie.  When you've tried to write the instance, @tell me the results.  Since you probably won't want to wait for me ask the channel to explain what the problem is.  Especially equipped with type errors, I'm certain there will be people who can explain what the issue is and how I was able to identify it immediately.  If you do get it working @tell me a link to the working code in
19:24:03 <ddarius> a paste bin and I'll tell you what you changed that got it working.
19:24:07 <Olathe> Ahh, it says 599 now.
19:24:10 <Olathe> Hmm, that's interesting.
19:24:35 <pumpkin> oh no!
19:24:38 <pumpkin> he left
19:24:43 <pumpkin> Olathe: what client?
19:24:50 <stepcut> dons: done! (awaiting moderation though)
19:24:51 <Olathe> mIRC.
19:24:53 <bombshelter13> Taejo: Ah, that's not far from what I've got going so far. Tried figuring out the portaudio bindings, but no luck so far... I think it was probably just me doing something wrong though due to not being entirely certain of the syntax for some of it yet.
19:25:02 <Olathe> I'm not sure it's the client, though. Let me check.
19:25:20 * bombshelter13 actually has it printing numbers on stdout, and a second script he had laying around already that creates a .wav from that.
19:25:31 <bombshelter13> Okay, if I've got data Note = C | CSharp | D | ..., what do I have to do now if I want to be able to grab ranges from that, like [C..GSharp]?
19:25:44 <pumpkin> bombshelter13: make it derive Enum
19:25:45 <CakeProphet> bah, disconnected.
19:25:58 <pumpkin> CakeProphet: did you get ddarius' message?
19:26:14 <stepcut> bombshelter13: you can derive Enum, but that will not be circular
19:26:15 <CakeProphet> believe so
19:26:22 <CakeProphet> http://pastebin.com/m5101c453
19:26:30 <stepcut> bombshelter13: so, [A..C] would work, but [G..B], would not
19:26:31 <Taejo> bombshelter13: you'll probably want to write your own circular instance
19:26:45 <stepcut> bombshelter13: but you can make an Enum instance by hand that does the 'right thing'
19:26:56 <pumpkin> CakeProphet: the one about going to see a movie?
19:27:05 <stepcut> though, I think there is some issue that arises when you do circular Enums
19:27:18 <CakeProphet> pumpkin:  ...oh... no.
19:27:23 <Taejo> stepcut: that's assuming it starts at A; if it started at C, the latter would work and the former wouldn't
19:27:27 <pumpkin> <ddarius> CakeProphet: Anyway, I'm going to watch a movie.  When you've tried to write the instance, @tell me the results.  Since you probably won't want to wait for me ask the channel to explain what the problem is.  Especially equipped with type errors, I'm certain there will be people who can explain what the issue is and how I was able to identify it immediately.  If you do get it working @tell me a link to the working code in
19:27:30 <enoksrd> @version
19:27:31 <lambdabot> lambdabot 4.2.2
19:27:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:27:37 <pumpkin> <ddarius> a paste bin and I'll tell you what you changed that got it working.
19:27:39 <stepcut> Taejo: true. but same solution.
19:27:52 <CakeProphet> @help tell
19:27:52 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
19:27:56 <CakeProphet> @tell ddarius http://pastebin.com/m5101c453
19:27:56 <lambdabot> Consider it noted.
19:28:07 <bombshelter13> Taejo, stepcut: Yeah, circular would be nice... though I think I'm going to actually going to go over to the MIDI notenumbers, at this point I'm just sort of finishing this implementation as an excercise :)
19:28:12 <ddarius> CakeProphet: try copyProp
19:28:13 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
19:28:33 <ddarius> @messages
19:28:33 <lambdabot> CakeProphet said 37s ago: http://pastebin.com/m5101c453
19:28:58 <CakeProphet> oh... nice command.
19:29:02 <stepcut> bombshelter13: I assume you know there are already a number of libraries dealing with this type of thing in Haskell ?
19:29:31 <stepcut> bombshelter13: such as, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/midi
19:29:33 <bombshelter13> Huh, even deriving enum, I seem to get 'Failed to load interface for `C'
19:29:41 <mpeter> has anybody written a nice concise piece of code that uses every axiomatic feature of haskell
19:29:50 <pumpkin> mpeter: ?
19:29:55 <roconnor> mpeter: oleg
19:30:10 <mpeter> oleg?
19:30:14 <roconnor> oleg has
19:30:19 <bombshelter13> stepcut: I did see some packages for music related things, yes, but it's less educational I think :)
19:30:23 <mpeter> who's oleg ;)
19:30:28 <roconnor> @who oleg
19:30:28 <stepcut> bombshelter13: right, that's what I figured :)
19:30:28 <lambdabot> Maybe you meant: echo ghc show thx what wn
19:30:36 <roconnor> :/
19:30:38 <bombshelter13> stepcut:  :)
19:30:54 <roconnor> @where oleg
19:30:55 <lambdabot> http://okmij.org/ftp/
19:30:56 <pumpkin> a @who command would be neat
19:31:02 <polveroj> roconnor: for brain-destroying values of "nice"
19:31:12 * stepcut just implemented a similar type ... in actionscript
19:31:16 <ddarius> CakeProphet: Actually, what the heck is the point of copyProp?
19:31:16 <CakeProphet> ddarius:  copyProp works too, I believe.
19:31:33 <CakeProphet> ddarius:  -shrug- just threw it in. Not even sure.
19:32:04 <CakeProphet> if we weren't dealing with singleton maps and one-valued constructors it would be useful.
19:32:40 <kerlo> That page isn't exactly about oleg.
19:32:42 <ddarius> CakeProphet: Make an exapmel.
19:32:52 <ddarius> s/exapmel/example/
19:33:02 <CakeProphet> ddarius:  oh copyProp being useful or of it working?
19:33:04 <CakeProphet> *of
19:33:37 <ddarius> An example of it dealing with non-singleton maps and not one-valued constructors.
19:34:02 <inforichland> cakeprophet: are you basically trying to make a dynamic list of properties ?
19:34:24 <inforichland> kind of like [(name, "myname"), (thispropertyequals, "thisvalue")]
19:34:43 <CakeProphet> inforichland:  yep
19:34:58 <CakeProphet> Prop is just a way of having different types for each property.
19:35:31 <inforichland> ah
19:35:59 <inforichland> so you basically just want a wrapper around basic types
19:36:45 <ddarius> CakeProphet: Actually copyProp seems like it would work, though I'm not sure why you put it in the class.
19:37:11 <pumpkin> what kinds of things should go in the class, and what should sit outside as helpers?
19:37:37 <pumpkin> things that could "define" the class go in it?
19:38:05 <CakeProphet> ddarius:  is it better style to just put what needs to be implemented in the class and have all the derivitives elsewhere?
19:39:48 <ddarius> CakeProphet: Usually you want the minimum inside plus whatever might be needed for efficient implementation.  However, in this particular case, 1) copyProp's default definition doesn't look like it would be suitable for all instances and 2) you can't implement copyProp much differently than you did.
19:39:52 <inforichland> cakeprophet: are all the properties not known at compile-time ?
19:40:16 <CakeProphet> I'd assume not.
19:40:27 <CakeProphet> there's no way they could be. They'd be read from a file/database somewhere.
19:40:32 <CakeProphet> when the program starts.
19:41:38 <inforichland> like a configuration file?
19:43:36 <inforichland> cakeprophet: sorry, I don't mean not know, I mean would you know the *name* and *type* of each property at compile-time?
19:44:03 <inforichland> as in, I know there will be a font-color property and it's a string, I just don't know what its value is until I read it in from the file?
19:44:06 <CakeProphet> -nod- you'd have to.
19:44:25 <inforichland> ok, then why have them be dynamic?
19:44:36 <CakeProphet> never used it.
19:44:51 <bombshelter13> Huh... '[C..GSharp]' doesn't work, but if I let a = C and b=Gsharp, '[a..b]' produces the correct range... I have a feeling I'm doing something embarassingly wrong.
19:45:11 <inforichland> why not just define a configuration record type ?
19:45:37 <ddarius> bombshelter13: [C .. GSharp]
19:45:55 <ddarius> bombshelter13: The error you got should have been self-explanatory.
19:46:01 <ddarius> (or close enough to it)
19:46:35 <bombshelter13> ddarius: well, it mentions failing to load an interface, which I haven't gotten to yet in my readings... :/
19:46:58 <ztirF> wow CArray is what Array should be
19:47:04 <inforichland> cakeprophet: something like this
19:47:04 <ztirF> that class kicks ass
19:47:05 <inforichland> data Configuration = Configuration {
19:47:05 <inforichland>     font-color :: Color,
19:47:05 <inforichland>     font-name :: String,
19:47:05 <inforichland>     font-size: Int
19:47:05 <inforichland> } deriving (Eq, Show, Read)
19:47:13 <ztirF> err library
19:47:17 <inforichland> naturally with different properties
19:47:22 <ddarius> bombshelter13: It probably said it couldn't find interface C or some such.
19:47:30 <CakeProphet> inforichland:  oh...
19:48:02 <CakeProphet> uh... I'm not really sure if each name is known. I guess since I don't plan on making it like MOO where pretty much everything is dynamic then each name would be known.
19:48:02 <bombshelter13> ddarius: Yes, which didn't help as I'm not yet sure what 'interface' means in this conext. ;)
19:48:12 <int80_h> how do I represent logical or in haskell?
19:48:15 <ddarius> :t (Prelude..)
19:48:16 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:48:23 <ddarius> :t Data.Map.fromList
19:48:24 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
19:48:36 <ddarius> bombshelter13: A bit clearer now what happened?
19:48:50 <ztirF> @type ||
19:48:51 <lambdabot> parse error on input `||'
19:48:54 <inforichland> cakeprophet: then you can define a default configuration
19:48:58 <ztirF> @type (||)
19:48:59 <lambdabot> Bool -> Bool -> Bool
19:49:03 <int80_h> yeah I thought it would be || too
19:49:10 <inforichland> defaultConfig = Configuration { font-color: Red, font-name: "Serif", font-size: 14 }
19:49:13 <int80_h> oh! I didn't use ()
19:49:29 <inforichland> and you can wrap a newtype around StateT monad around it when you read it in from the file
19:49:30 <ztirF> () un-infixifies it
19:49:57 <bombshelter13> ddarius: not absolutely, though I can see how to avoid it. I suppose it gets misparsed when written without spaces?
19:50:12 <ddarius> Yes.
19:50:27 <ddarius> It was trying to load the (.) operator from the module C.
19:50:30 <inforichland> cakeprophet: check this out: http://pastebin.com/m60a52b2b
19:50:42 <inforichland> cakeprophet: i converted the 'adventure game' from lisperati.com into haskell
19:51:31 <bombshelter13> ddarius: ah
19:52:39 <inforichland> cakeprophet: it's an example of a 'default configuration' (sort of) and how to modify it depending on (in this case) user input
19:52:57 <inforichland> you could just as easily read them from a file, parse them, and then use replace the defaults with the ones from the file
19:53:37 <jberg-> how does haskell avoid stack overflow in recursion?
19:54:31 <JoelyWoely> some clever implementation
19:54:58 <inforichland> jberg-: it doesn't always ;)
19:55:11 <jberg-> i see
19:55:21 <jberg-> whats the clever implementation?
19:55:28 <inforichland> jberg-: it can when a function is tail-recursive
19:55:34 <inforichland> jberg-: otherwise, it can't
19:56:00 <Cale> jberg-: Do you have some code which is producing a stack overflow?
19:56:21 <Cale> jberg-: I could take a quick look at it if you pasted it on hpaste or something.
19:56:38 <jberg-> nope, just wondering, because if you dont have imperative loops and you got stack overflow all the time it would kinda suck
19:56:41 <inforichland> cale: hpaste is down right now
19:56:48 <inforichland> pastebin is up, though
19:57:11 <jberg-> inforichland, it can stack overflow when a function is tail recursive?
19:57:20 <inforichland> jberg-: no
19:57:32 <inforichland> a tail-recursive function, by definition, uses no extra stack space
19:57:39 <Cale> Stack overflows don't mean what they mean in strict languages.
19:58:04 <Cale> The stack is only used when searching an expression for a reducible subexpression.
19:58:07 <jberg-> inforichland,  yeah thats what i thought :) i was thinking i'd miss something
19:58:20 <inforichland> for some things, we don't need even need recursion, though
19:58:23 <Cale> So if you have an integer value like ((...(0+1)+1...)+1)+1
19:58:39 <Cale> You may get a stack overflow *when you try to evaluate it*
19:59:10 <Cale> It's not recursion directly which causes stack overflows, it's values which have usually been built up recursively.
19:59:23 <jberg-> cale, hmm
19:59:37 <jberg-> <Cale> The stack is only used when searching an expression for a reducible subexpression. <- don't understand this
19:59:38 <Cale> Haskell evaluation is always outermost-first.
19:59:52 <Cale> So if you have something like  f (g (h x))
19:59:56 <Cale> f is evaluated first
20:00:00 <jberg-> yep
20:00:03 <Cale> with g (h x) as its parameter
20:00:17 <Cale> But if f needs to pattern match
20:00:36 <Cale> then g (h x) needs to be evaluated, and this is where the stack comes in.
20:01:01 <jberg-> hmm ok
20:01:18 <jberg-> does ghc have a compile switch which outputs assembly?
20:01:40 <Cale> yes
20:01:45 <jberg-> cool
20:02:24 <inforichland> -ddump-asm
20:02:42 <jberg-> btw, what debugger/profiler/whatever other tools are you guys using? i want to make a non trivial haskell app soon, so im wondering if there's some cool tools which might come in handy
20:02:51 <Cale> I mostly just use ghc
20:03:07 <jberg-> ghc has debugger and profiler?
20:03:10 <Cale> yes
20:03:17 <jberg-> okay
20:03:29 <Cale> Though the debugger-proper is not as useful as just using ghci to evaluate expressions.
20:03:50 <inforichland> @help tell
20:03:50 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
20:03:52 <jberg-> maybe i should look at the xmonad source or something and see if i can make sense of it and try to implement some of my own ideas
20:03:55 <Cale> Tracing evaluation is mostly just confusing.
20:04:12 <Cale> (unless you're trying to solve a very specific kind of problem)
20:04:12 <inforichland> @tell cakeprophet check out http://book.realworldhaskell.org/read/software-transactional-memory.html (ch. 28 of RWH) for some "game" stuff plus STM :)
20:04:12 <lambdabot> Consider it noted.
20:05:17 <jberg-> i can't decide wether i should make a raytracer, some sort of webapp or ircbot as my first real haskell project
20:05:44 <jberg-> i have an exceptionally unimaginative mind, so those are the only things i can think of
20:05:57 <Cale> Raytracers are fun in functional languages :)
20:06:30 <jberg-> i have written one, but that was an assigmnet for some university so most of the code was written
20:06:37 <pumpkin> make a ray tracer in DPH!
20:06:47 <ray> make a pumpkin tracer first please
20:06:48 <jberg-> i only implemented an octree and a ppm-writer
20:06:50 <inforichland> department of public health ?
20:06:53 <pumpkin> lol
20:06:56 <ray> they really need to rename ray tracers
20:07:04 <pumpkin> inforichland: data-parallel haskell
20:07:07 <inforichland> i tease
20:07:11 <pumpkin> :)
20:07:35 <jberg-> or when i get my digital signal processing book it would be fun to try and make a softsynth
20:07:36 <ray> delicious potato haskell
20:07:53 <inforichland> mmm
20:07:53 <pumpkin> make a piano simulator!
20:08:06 <ray> a haskell synth library would be nice
20:08:18 <pumpkin> simulate the strings vibrating and interacting with one another, the frame, and the innards of the piano :P
20:08:19 <jberg-> i think it already exist though
20:08:23 <jberg-> yampa or something
20:09:29 <inforichland> whoo, yampa is uh, well, very complex
20:09:33 <inforichland> FRP is in general
20:09:37 <inforichland> imho
20:09:52 <jberg-> i haven't quite understoud what FRP is..
20:10:01 <inforichland> but i'm just an armchair mathematician ;) not a category theorist like everyone else here
20:10:06 <pumpkin> true h is lack of o
20:10:24 <inforichland> touche`
20:10:31 <inforichland> fine, imo :P
20:10:52 <pumpkin> imao, at least
20:11:02 <bombshelter13> jberg-: What book did you order?
20:11:04 <inforichland> =-O
20:11:16 <jberg-> or maybe a demo with opengl, but haskell is maybe too slow for demos.
20:11:38 <jberg-> bombshelter13, a sec..
20:12:13 <inforichland> pumpkin: you understand it, you explain it :P
20:12:15 <bombshelter13> i'm still debating the chamberlin book,i need to see if i can score a copy cheap.
20:12:20 <pumpkin> ?
20:12:29 <inforichland> frp
20:12:34 <pumpkin> oh, I never said I understood it
20:12:37 <jberg-> bombshelter13, im still stuck between ordering this: http://www.amazon.com/Digital-Signal-Processing-John-Proakis/dp/0131873741 and..
20:12:42 <pumpkin> I just said I had an arrogant opinion
20:12:51 <inforichland> naturally
20:13:40 <pumpkin> @quote dph
20:13:40 <lambdabot> No quotes match. Sorry.
20:13:42 <pumpkin> :(
20:13:49 <jberg-> http://www.amazon.com/Understanding-Digital-Signal-Processing-2nd/dp/0131089897/ref=pd_sim_b_1 and this one. if anyone know, which would i learn the most from if i dont know much about it?
20:14:23 <inforichland> @omagiclambdabotfindthisforme dph
20:14:23 <lambdabot> Unknown command, try @list
20:14:45 <bombshelter13> jberg-: This one is supposed to be quite good from what I've heard... really would like to grab a copy http://www.amazon.com/Musical-Applications-Microprocessors-Hal-Chamberlin/dp/0810457733/ref=sr_1_1?ie=UTF8&s=books&qid=1232424789&sr=1-1
20:14:56 <bombshelter13> jberg-: More specific to musical applications, which is fine by me :)
20:16:05 <bombshelter13> this too, looks primising, if less tome-like http://www.amazon.com/Digital-Audio-Signal-Processing-Zölzer/dp/0470997850/ref=sr_1_1?ie=UTF8&s=books&qid=1232424944&sr=1-1
20:16:26 <bombshelter13> s/rim/rom
20:18:08 <jberg-> bombshelter13, damnit, now it's harder to choose
20:18:24 <jberg-> i want a book on music theory and the math behind music too though
20:18:31 <bombshelter13> jberg-: Heh :) Well, if you get either of them before I do, tell me what you think ;)
20:18:40 <jberg-> will do
20:19:04 <jberg-> semester start, so might fool mum and dad into i need one of those books for class :)
20:19:12 <jberg-> into thinking*
20:20:42 <jberg-> and maybe throw in RWH in there too :)
20:21:02 <gwern> > [1..10] `mappend` [11..20]
20:21:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
20:21:18 <bombshelter13> yeah, waiting for that one here :)
20:21:30 <gwern> > [(1,2), (3,4)] `mappend` [(2,2), (1,1)]
20:21:32 <lambdabot>   [(1,2),(3,4),(2,2),(1,1)]
20:21:47 <gwern> > [(1,2), (3,4)] `mappend` [(1,1)]
20:21:49 <lambdabot>   [(1,2),(3,4),(1,1)]
20:23:38 <jberg-> btw, how many of you have jobs writing haskell? did you find it in the ad or did you find a company that did haskell and sent an application? and were you fluent in haskell then?
20:23:48 <jberg-> the ads*
20:25:57 <pumpkin> jberg-: I'd guess a pretty small percentage :P
20:26:56 <Lemmih> jberg-: Personal contacts seem to work best.
20:27:12 <jberg-> yes i figured
20:27:15 <O_4> jberg-, pumpkin: well, you can work at a university.
20:27:37 <jberg-> but how many companies are using haskell worldwide? less than 20?
20:27:40 <pumpkin> O_4: that's what I do :) but I didn't think that's what he was looking for
20:27:44 <O_4> It's a common enough job, and there's no reason you can't use haskell in your research.
20:27:53 <O_4> Well, it is a job :-p
20:28:09 <jberg-> actually the entire norwegian tele communication network (i think) is written in lisp
20:28:22 <pumpkin> O_4: pays like crap though
20:28:44 <jberg-> i would love to be a researcher
20:29:10 <jberg-> or engineer at some big company so they let me do whatever i want
20:30:54 <O_4> If you aren't explicitly interested in Haskell, there are plenty of places which use functional languages.
20:31:29 <O_4> They're not as common as Java establishments, I bet, but they do exist :-p
20:33:36 <jberg-> nah, i don't need to do haskell. i want to do something technical like writing missile guiding systems or write compilers or whatever, just not create java guis for 30 years
20:38:00 <coco> anyone knows how to use the derive package...? I want derive instances of Functor.
20:38:11 <shapr> Yay! Pubkväll on Thursday!
20:38:18 <coco> $(makeFunctor ''Expr) doesn't work for me
20:38:19 <lunabot>  luna: Not in scope: `makeFunctor'
20:38:33 <O_4> shapr: is that like a pub crawl?
20:38:43 <shapr> Er, I don't know.
20:38:54 <shapr> Doesn't a pub crawl involve multiple pubs?
20:39:21 <shapr> I've never been on a pub crawl. I have been to pubkvälls though.
20:39:23 <O_4> Well, yes.
20:40:27 <bombshelter13> a pub crawl is basically like a dungeon crawl only instead of killing monsters and taking their treasure you kill barflies and take their change
20:40:32 <shapr> Oh wow.
20:40:33 <O_4> So this involves a single pub?  Or is it something entirely unrelated? :-p
20:40:35 <shapr> I can totally do that.
20:40:45 <O_4> Yeah, it's not too hard :-p
20:40:58 <shapr> O_4: Yes, just one pub. But kväll means 'evening' so it's like having the night out.
20:41:05 <O_4> Ah, cool.
20:41:12 <gwern> bombshelter13: sounds like nethack, keystone kops and all
20:41:29 <shapr> Anyway, it's a pubkväll in Boston, so should be fun.
20:41:30 <O_4> I'd guess from the name it's not anywhere local to me, unfortunately.
20:41:32 <Spark> a pub crawl is supposed to be 1 pint in each pub
20:41:35 <Spark> and a big group
20:41:39 <Spark> like a regatta
20:41:46 <gwern> but here in the real world, people will hate you if you kill and eat your pet because you're hungry
20:41:50 <shapr> Ah, I see.
20:42:02 <Spark> gwern: that's strongly discouraged in nethack too
20:42:08 <shapr> Spark: Hey, are you the same spark that used to hang out here a year or so ago?
20:42:11 <Spark> yeah
20:42:13 <bombshelter13> I'd really be happy with a job using any of the functional-ish languages I've used so far, going back to the other paradigms I've used seems like a terrible fate :/
20:42:16 <Spark> i never stopped hanging out here
20:42:17 <shapr> Spark: Nice to see you again!
20:42:23 <Spark> heh
20:42:24 <gwern> Spark: it affect your alignment and god points a little
20:42:30 <shapr> bombshelter13: Yeh, I went from a year of paying Haskell to C#
20:42:33 <gwern> the real punishment is not having your pet around anymore
20:42:49 <O_4> Well, C# is not too bad.
20:42:54 <shapr> Yeah, true.
20:42:56 <pumpkin> gwern: you speak from experience?
20:43:00 <shapr> But still, it's NOT Haskell.
20:43:02 <O_4> It's not Haskell, but it's not Java either.
20:43:22 <O_4> Or C++.
20:43:24 <Spark> http://www.fat-pie.com/dogofman.htm
20:43:36 <pumpkin> fat-pie!
20:43:39 <gwern> pumpkin: oh sure. I always ran out of food early on, and then fido came prancing around...
20:43:43 * pumpkin likes rusty spoons
20:43:44 <SamRH> depends on the version of C#.  but even C# 1.1 is not java
20:43:45 <Spark> this talk of pets has reminded me of this entertaining little cartoon
20:44:13 <gwern> actually, this talk has reminded me of my cat and dog who both died within 2 months :(
20:44:20 <pumpkin> aw :(
20:44:24 <gwern> I had a sad feeling; then it passed. (now it's back)
20:44:25 <Spark> you need the dog to identify rotten / cursed stuff
20:44:49 <gwern> *within 2 months last year, nov/dec
20:45:20 <gwern> ah, but this isn't the place for that kind of talk
20:45:21 <Spark> death is an occupational hazard of being alive
20:45:33 * gwern gets back to some other saddening things - my java programming
20:46:19 <chessguy> > [1,2] >>= [3,4]
20:46:20 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
20:46:41 <SamRH> > [1,2] >> [3.4]
20:46:43 <lambdabot>   [3.4,3.4]
20:46:46 <SamRH> > [1,2] >> [3,4]
20:46:47 <lambdabot>   [3,4,3,4]
20:47:08 * BMeph feels much sympathy for gwern. Poor gwern, programming in Java...
20:48:10 <chessguy> hm. ok, this should be a fun one-liner to build. f takes a list of lists, and returns all the ways you can select one element from each list
20:48:31 <chessguy> e.g. f [[1,2],[3,4]] == [[1,3],[2,4]]
20:48:35 <chessguy> errr
20:48:55 <shapr> I like Haskell.
20:48:56 <chessguy>  f [[1,2],[3,4]] == [[1,3],[1,4],[2,3],[2,4]]
20:49:02 <bombshelter13> ookie, off to bed with me, gotta be on campus at eight for our FreeBSD class... later!
20:49:28 <roconnor> Haskell++
20:49:54 <matthewp> :t Haskell++
20:49:55 <lambdabot> parse error (possibly incorrect indentation)
20:50:28 <chessguy> heya matt, going through withdrawal tonight?
20:51:10 <Axman6> @karma haskell
20:51:10 <lambdabot> haskell has a karma of 48
20:51:16 <Axman6> show off :(
20:51:31 <pumpkin> @karma i
20:51:32 <lambdabot> i has a karma of 3
20:51:40 <Axman6> @karma
20:51:40 <lambdabot> You have a karma of 5
20:51:42 <pumpkin> @karma j
20:51:42 <lambdabot> j has a karma of 0
20:51:46 <pumpkin> @karma karma
20:51:46 <Axman6> ye-ah, beating i!
20:51:46 <lambdabot> karma has a karma of 0
20:51:51 <shapr> @karma
20:51:52 <lambdabot> You have a karma of 2
20:51:54 <shapr> Aw
20:51:58 <Axman6> shapr++
20:51:59 <pumpkin> karma++
20:52:03 <shapr> whee!
20:52:15 <vegai> hey, shapr
20:52:20 <shapr> hei vegai!
20:52:34 <chessguy> oh wait
20:52:36 <Axman6> shapr: i just twittered you about the mobile phone problem, but i'm guessing you don't actually follow my tweets... realised that after i did it :P
20:52:42 <chessguy> this is the same as that diagonalization question the other day
20:52:57 <Axman6> also, shapr++ for starting this wonderful chan
20:53:04 <shapr> Axman6: Oh, I've been sick, and I met a smart woman, so I haven't been reading twitter much lately.
20:53:08 <shapr> Axman6: yay, thanks!
20:53:13 <chessguy> err, not quite
20:53:14 <chessguy> grr
20:53:34 <shapr> And thanks to dons and Cale and many more for keeping it going!
20:53:36 <chessguy> ugh, i suppose i should quit babbling incoherently and go to bed :(
20:53:41 <Axman6> indeed :)
20:53:59 <Axman6> "@shapr noise blocking headphones with an iPod (possibly playing some nice binaural beats for concentration) might make a huge difference"
20:54:07 <shapr> g'nite chessguy!
20:54:20 <chessguy> but i don't want sleep!
20:54:29 <shapr> Axman6: I left my headphones at home today, I went in at 15:30 because I was sick but still had to do some important stuff.
20:54:45 <Axman6> lame :(
20:55:47 * gwern wonders. freebsd class? aren't OSs something you usually teach yourself?
20:56:27 <dancor> esp freebsd
20:56:32 <O_4> Yeah, except when you get someone else to teach you :-p
20:56:42 <shapr> @users
20:56:42 <lambdabot> Maximum users seen in #haskell: 653, currently: 591 (90.5%), active: 18 (3.0%)
20:56:51 <shapr> Whoa, back below 600
20:56:55 <Axman6> :(
20:57:01 <shapr> Nah, it's fine.
20:57:14 <Spark> lol this is awesome http://uk.youtube.com/watch?v=JOCo6pdkdc4
20:57:25 <shapr> I was trying to get a few people at the con to show up on #haskell, but they were hoping for a slightly smaller sized channel I think.
20:57:56 <jeffz`> shapr: is our size intimidating?
20:57:59 <shapr> I met this guy named Mycroft, claims he knows something about FreeBSD.
20:58:06 <gwern> shapr: did he?
20:58:11 <shapr> Yeh, I think he started it.
20:58:56 <shapr> Oh and I met bos' coworker on the streetcorner on Saturday.
20:58:59 <shapr> That was neat.
20:59:10 <bos> you did?
20:59:16 <bos> hi jsgf_
20:59:20 <shapr> bos: Yup, I met Ben aka Green Linden.
20:59:34 <shapr> And I tried to get him to show up on #haskell :-)
20:59:38 <bos> ah, our resident database CPR expert and general man about the net :-)
20:59:54 <shapr> Yeah, seems he lives about a block away from me.
21:00:09 <shapr> That was the impression I got, at least.
21:00:18 <shapr> Smart guy, very passionate about clusters :-)
21:00:40 <gwern> lives a block away? one would think you would ask more specifically
21:00:54 <shapr> Well, why?
21:01:25 <Nafai> Hey shapr!
21:01:32 <shapr> He's smart and interesting, but his interests aren't really that close to my own. He has a cluster of 6k machines, I have a cluster of ... 6?
21:01:33 <gwern> well, that close - wouldn't you be terribly curious? even if you wouldn't actually get together for bbqs or borrow books or anything
21:01:54 <shapr> gwern: Um, this is Somerwille, there are more nifty geeks in this area than you would believe.
21:02:13 <shapr> Mako is here, radix, glyph, and so many other interesting peoplee
21:02:16 <shapr> And when I get home?
21:02:29 <shapr> I generally want to unwind from the corporate wageslave job.
21:02:55 <shapr> Sorta sucks actually. If my job weren't so purposefully stupid I'd have a lot more energy to meet neat people.
21:03:02 <gwern> shapr: ok, fair enough
21:03:14 <gwern> (not many nifty geeks where I am, so different perspective)
21:03:14 <Spark> when i get home i have to write my thesis
21:03:28 <Spark> it's a lose lose situation
21:04:56 <Spark> a situation in which i mostly lose
21:04:58 <Spark> my m ind
21:05:20 <Olathe> > lobotomy
21:05:22 <lambdabot>   ♪ Loboto ! Loboto ! Loboto ! With -my ! ♪
21:05:59 <dancor> @src lobotomy
21:05:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:06:40 <polveroj> Was anyone here at the MIT mystery hunt this weekend?
21:07:18 <polveroj> I got to show some Pythonistas how nifty Haskell is :)
21:07:42 <Axman6> were they very impressed?
21:07:55 <polveroj> they were impressed by the List monad
21:08:05 <Axman6> in what ways?
21:08:34 <polveroj> well, it lets you write combinatorial code (the sort that puzzles are full of) really cleanly
21:08:34 <dancor> polveroj: is your nick esperanto
21:08:43 <polveroj> dancor++
21:09:02 <bigorilla> newb q: what do I need to do to use "forall"?
21:09:04 <shapr> polveroj: Wow! awesome!
21:09:21 <shapr> polveroj: Are at MIT?
21:09:44 <shapr> polveroj: You live in Somerville?
21:09:53 <polveroj> shapr: I'm at Harvard
21:09:58 <shapr> Ah, cool!
21:10:05 <Axman6> bigorilla: normally not using it implies it, unless you restrict things...
21:10:12 <shapr> So, you'll come to the CHUG once we have a meeting and a venue? :-)
21:10:38 <bigorilla> Axman6: I have an inner function in a "where" clause, and using the same type variable overshadows the one of same name..
21:10:39 <shapr> polveroj: You'd be interested in a Cambridge Haskell User's Group?
21:10:46 * Axman6 wants there to be haskell talks in canberra damn it!
21:10:50 <polveroj> shapr: totally
21:10:50 <shapr> Axman6: organize it!
21:11:00 <Axman6> there's not enough people :(
21:11:02 <shapr> Axman6: Worked for me.. in three countries so far.
21:11:07 <shapr> Axman6: So educate the masses!
21:11:10 <Axman6> heh
21:11:15 <Axman6> maybe when uni goes back
21:11:55 <shapr> polveroj: Awesome! Do you know if Harvard has a venue where ten or twenty people could gather and talk about Haskell?
21:12:06 <Axman6> i've talked to ben lippmier about it, he reckons it might be possible to get the fp-sydney people to come down sometime
21:12:52 <bos> @seen dons
21:12:53 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 2h 28s ago.
21:13:13 <dons> yo
21:13:13 <Axman6> @seen lambdabot
21:13:13 <lambdabot> Yes, I'm here. I'm in #lhc-compiler, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
21:13:14 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, #macosx, ##freebsd, #gentoo-uy,
21:13:14 <lambdabot> #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
21:13:42 <inimino> wow, lambdabot gets around
21:13:49 <shapr> she's easy
21:13:54 <shapr> @vixen a/s/l
21:13:54 <lambdabot> 19/f/California
21:14:05 * Axman6 still things that #unicycling  has to be a cult
21:14:09 <Axman6> thinks*
21:14:12 <inimino> hehe
21:14:16 <bigorilla> found out I can do "ghc -fglasgow-exts" to get the forall keyword. any way without changing ghc command line?
21:14:16 <shapr> Axman6: You just haven't tried it yet :-)
21:14:34 <shapr> Axman6: It is somewhat addictive, I admit.
21:14:35 <shachaf> bigorilla: Yes, {-# LANGUAGE ...
21:14:39 <Axman6> no way man, i have a future ahead of me!
21:14:41 <shachaf> #-}
21:14:48 <dons> bos.. ?
21:14:55 <shapr> Axman6: With unicycling, you could be in great shape, women will flock to you!
21:15:00 <shachaf> bigorilla: What you put there depends on how you're using the forall, probably.
21:15:06 <shapr> Admittedly, they might be whistling circus music while they flock :-/
21:15:13 <Axman6> my girlfrined might not approve :\
21:15:18 <shapr> oh right
21:15:20 <shapr> never mind then
21:15:30 <bigorilla> shachaf: using forall so I could define my inner functions' types
21:16:13 <Axman6> i doubt you'll need a forall
21:16:28 <chessguy> @hoogle [[a]] -> [[a]]
21:16:29 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
21:16:29 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:16:29 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
21:16:32 <shachaf> Perhaps RankNTypes or Rank2Types, then?
21:16:33 <elbar> @src (>>)
21:16:33 <lambdabot> m >> k      = m >>= \_ -> k
21:16:40 <polveroj> bigorilla: {-# LANGUAGE UniversalQuantifiers #-} is for forall, but you might want ScopedTypeVariables
21:16:50 <chessguy> > transpose [[1,2,3],[4,5,6],[7,8,9]]
21:16:51 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
21:17:05 <Axman6> @src [] (>>)
21:17:06 <lambdabot> xs >> ys      = concatMap (const ys) xs
21:17:39 <chessguy> > sequence [[1,2,3],[4,5,6],[7,8,9]]
21:17:41 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
21:17:50 <chessguy> nice
21:17:57 <chessguy> sick, but nice
21:17:59 <dons> i love uploading theorem proving tools to the 'devel' section of Arch Linux's package database
21:18:00 <bigorilla> polveroj: seems to be what I want. thanks :)
21:18:26 <Axman6> dons: taken a look at that n-bodies thing? pretty sure it exposes a rather nasty GHC bug
21:18:46 <inimino> it might be time to look at arch
21:19:00 <dons> Axman6: not yet. on my list.
21:19:13 <dons> i need a tool that shows me graphically if my todo list is growing or shrinking
21:19:18 <chessguy> @src sequence
21:19:19 <lambdabot> sequence []     = return []
21:19:19 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:19:19 <lambdabot> --OR
21:19:19 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:19:20 <Axman6> heh
21:19:20 <inimino> this Lenny release is taking too long
21:19:24 <dons> and at what threshold i should start rejecting work
21:19:32 <inimino> dons: you have found a way to shrink todo lists?
21:19:41 <dons> stop sleeping
21:19:43 <Axman6> inimino: arch is the only linux distro i can stand
21:19:44 <dons> stop answering email
21:20:18 <inimino> dons: yeah, that's worked for me in the past
21:20:27 <gwern> dons: well, you probably could cut out (most) sleep if you bought yourself a prescription of modafinil :)
21:20:44 <dons> i have a lot of automation in place now too
21:20:47 <inimino> Axman6: the Lenny release (Debian) is taking a long time, so I'm seriously thinking about it
21:20:53 <dons> still, hard to keep all the plates in the air
21:21:01 <inimino> dons: indeed.
21:21:24 <dons> btw, here's somethiing new, the complete list of galois tech talks going back 3 years, http://www.galois.com/blog/galois-tech-talks/
21:21:36 <bos> dons: how are your mad fusion performance debugging skillz?
21:21:38 <dons> i'm trying to dig up all the info we had on ones before i started putting them on the blog
21:21:46 <dons> bos, they be fine.
21:21:52 <bos> how'd i guess? :-)
21:21:55 <dons> send email, with code and asm.
21:22:31 <dons> ketil giving the talk in savannah, btw?
21:23:39 <Olathe> @src sequence
21:23:39 <lambdabot> sequence []     = return []
21:23:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:23:39 <lambdabot> --OR
21:23:39 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:24:59 <puusorsa> gwern: or desoxypipradrol
21:25:04 <Axman6> @check \xs -> foldr (:) [] xs == xs
21:25:05 <lambdabot>   "OK, passed 500 tests."
21:25:20 <Olathe> @type liftM2
21:25:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:25:33 <Olathe> @type liftM2 (:)
21:25:34 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
21:25:40 <gwern> puusorsa: sure, but the cool kids use modafinil
21:25:45 <gwern> these days
21:26:48 <gwern> 'ts activity profile as a dopamine reuptake-inhibiting stimulant means that it could potentially be used as an alternative to illegal drugs such as cocaine and methylphenidate; however the slow onset of effects, and very long duration of action (as long as 24 hours, especially if more than one dose is taken) makes it unlikely to be successful for this application, as prominent side effects such as insomnia and anorexia are likely to ...
21:26:54 <gwern> ... outweigh any positive effects.' <-- anorexia as well? o.0
21:27:17 <puusorsa> i wouldn't know. not only completely uncool, but going to sleep too
21:27:52 <CakeProphet> @src Integral
21:27:53 <lambdabot> class  (Real a, Enum a) => Integral a  where
21:27:53 <lambdabot>     quot, rem, div, mod :: a -> a -> a
21:27:53 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
21:27:53 <lambdabot>     toInteger           :: a -> Integer
21:28:15 <bos> dons: yep
21:28:20 <bos> dons: are you going?
21:28:35 <gwern> puusorsa: pfft, you can sleep when you're dead
21:28:41 <CakeProphet> @instances-importing Integral
21:28:42 <lambdabot> Int, Integer
21:28:55 <dons> bos, nope. some other galwegians are though
21:33:25 <CakeProphet> @src Floating
21:33:25 <lambdabot> class  (Fractional a) => Floating a  where
21:33:25 <lambdabot>     pi                                                      :: a
21:33:25 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
21:33:25 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
21:33:25 <lambdabot>     (**), logBase                                           :: a -> a -> a
21:38:04 <Axman6> @src Fractional
21:38:05 <lambdabot> class  (Num a) => Fractional a  where
21:38:06 <lambdabot>     (/)             :: a -> a -> a
21:38:08 <lambdabot>     recip           :: a -> a
21:38:10 <lambdabot>     fromRational    :: Rational -> a
21:38:17 <Olathe> > let evil n = sequence.map (take n).takeWhile (not.null).iterate (drop n) in evil 3 [1..27]
21:38:18 <lambdabot>   [[1,4,7,10,13,16,19,22,25],[1,4,7,10,13,16,19,22,26],[1,4,7,10,13,16,19,22,...
21:38:38 <CakeProphet> @instances-importing Floating
21:38:39 <lambdabot> Double, Float
21:38:44 <CakeProphet> @instances-importing Random
21:38:45 <lambdabot> Couldn't find class `Random'. Try @instances-importing
21:39:05 <Axman6> @instances-importing System.Random Random
21:39:06 <lambdabot> Bool, Char, Double, Float, Int, Integer
21:39:16 <CakeProphet> @instances Integral
21:39:17 <lambdabot> Int, Integer
21:39:34 <Axman6> > randoms (mkStdGen 83752) :: [Char]
21:39:36 <lambdabot>   "\2952\630403\880154\424879\461074\876767\1092850\1022331\218668\343567\185...
21:39:56 <Olathe> > let gen = mkStdGen 5 in randoms gen :: [Bool]
21:39:58 <lambdabot>   [True,True,True,False,False,True,False,False,False,True,True,True,False,Tru...
21:40:02 <Olathe> Hmm...
21:40:05 <Olathe> Let's see.
21:40:51 <Olathe> > let groupIn n = map (take n).takeWhile (not.null).iterate (drop n); gen = mkStdGen 5 in groupIn 64 (randoms gen) :: [Bool]
21:40:52 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[a]'
21:41:00 <Olathe> > let groupIn n = map (take n).takeWhile (not.null).iterate (drop n); gen = mkStdGen 5 in groupIn 64 (randoms gen :: [Bool])
21:41:02 <lambdabot>   [[True,True,True,False,False,True,False,False,False,True,True,True,False,Tr...
21:41:17 <Olathe> I wonder if that matches randoms gen :: [Int]
21:41:35 <Axman6> > map (\x -> if x then '1' else '0')  $ randoms (mkStdGen 83752)
21:41:37 <lambdabot>   "01010101011010111100100100110001001110000111011111000101110110111001001100...
21:44:36 <Olathe> > let groupIn n = map (take n).takeWhile (not.null).iterate (drop n); gen = mkStdGen 5 in (map (foldl (\b a -> if a then 2*b + 1 else 2*b) 0).groupIn 64) (randoms gen :: [Bool]) :: [Int]
21:44:38 <lambdabot>   [-1983855918745498609,-8711040443074814937,-7180952123901706118,-2701678318...
21:44:55 <Olathe> > let groupIn n = map (take n).takeWhile (not.null).iterate (drop n); gen = mkStdGen 5 in randoms gen :: [Int]
21:44:57 <lambdabot>   [7776561651304326943,2660592214809256573,-198934792153589140,-4772860058847...
21:45:14 <Olathe> > let groupIn n = map (take n).takeWhile (not.null).iterate (drop n); gen = mkStdGen 5 in (map (foldr (\a b -> if a then 2*b + 1 else 2*b) 0).groupIn 64) (randoms gen :: [Bool]) :: [Int]
21:45:16 <lambdabot>   [-1138714020392997337,-2000884124216968991,6773699229006436921,-42521239544...
21:45:21 <Olathe> Hmm, guess not.
21:46:20 <Axman6> Olathe: you can get rid of the :: [Bool] there
21:46:28 <Olathe> Ahh, yes :)
21:47:15 <Olathe> > 2^63
21:47:17 <lambdabot>   9223372036854775808
21:47:37 <Axman6> > 2^64 :: Int
21:47:39 <lambdabot>   0
21:47:49 <Olathe> How ideal.
21:48:14 <Axman6> > 2^64 -1 :: Int
21:48:16 <lambdabot>   -1
21:50:13 <Axman6> > (-1) .|. 1 :: Int
21:50:15 <lambdabot>   -1
21:50:22 <Axman6> > (-1) .|. 0 :: Int
21:50:23 <lambdabot>   -1
21:50:29 <Axman6> > (-1) .|. maxBound :: Int
21:50:31 <lambdabot>   -1
21:50:43 <Axman6> > (-1) .|. minBound :: Int
21:50:44 <lambdabot>   -1
21:50:47 <Axman6> rawr
21:51:15 <Lemmih> Did you expect something different?
21:51:15 <lucca> > length $ takeWhile (> 0) [(2^n)::Int | n <- [0..]]
21:51:17 <lambdabot>   63
21:52:07 <Axman6> Lemmih: well, i was hoping for something different. i haven't though it enough to know i wouldn't get something different :)
21:52:14 <Olathe> > length.takeWhile (/=0).iterate (*2) $ 1
21:52:24 <Olathe> Heh
21:52:26 * Axman6 hasn't done binary number systems at uni yet, but wil be this semester
21:52:27 <Olathe> > length.takeWhile (/=0).iterate (*2) $ 1 :: Int
21:52:29 <lambdabot>   thread killed
21:52:43 <lambdabot>   thread killed
21:52:47 <Olathe> > length.takeWhile (/=0).iterate (*2) $ (1 :: Int)
21:52:50 <lambdabot>   64
21:52:53 <coco> is there a Functor2 class for zipping?
21:53:00 <Olathe> > length.takeWhile (/=0).iterate (*2) $ (1 :: Word8)
21:53:04 <lambdabot>   8
21:53:14 <ddarius> Axman6: -1 is a zero for .|. (it's all ones and oring into 1s gives you 1)
22:00:44 <CakeProphet> :t fromIntegral
22:00:44 <lambdabot> CakeProphet: You have 1 new message. '/msg lambdabot @messages' to read it.
22:00:46 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:01:04 <thoughtpolice> @seen tibbe
22:01:05 <lambdabot> I saw tibbe leaving #ghc, #haskell and #xmonad 12h 40m 10s ago, and .
22:01:22 <thoughtpolice> @tell tibbe i cloned a copy of hyena on github so you can pull easier from my branch
22:01:22 <lambdabot> Consider it noted.
22:07:58 <Axman6> thoughtpolice: that's hyena again? i remember reading what it was and thinking it was cool...
22:10:35 <pstickne> Axman6:  it's a carnivore that looks somewhat like a dog. they can be found in Africa and Asia.
22:12:41 <somnolence> my haskell program is giving me the following error: 'No instance for (Integral Float)' because it thinks one of the variables is an Integral Float what does that mean?
22:12:58 <somnolence> what *is* an integral Float?
22:13:14 <Lemmih> somnolence: 'Integral' is a type-class. 'Float' is a type.
22:13:15 <Axman6> there is none. what's the code?
22:13:16 <thoughtpolice> Axman6: it's pretty neat, enumerators are cool
22:13:29 <Axman6> thoughtpolice: but what is it? :P
22:13:39 <thoughtpolice> Axman6: a web app server
22:14:03 <Axman6> oh right, i remember now, with the iteratee stuff or whatever it was called
22:14:05 <Lemmih> somnolence: The compiler is telling you that 'Float' is not a member of the 'Integral' class of types.
22:14:17 <somnolence> code: http://rafb.net/p/DlKHXG47.html
22:14:21 <ray> somnolence: you're probably treating a float like it's an integer somewhere in your program
22:14:47 <Axman6> somnolence: what line does the error point to
22:14:53 <somnolence> the last line
22:15:12 <erikc_> does sigbjorne drop by here?
22:15:32 <CakeProphet> instance Floating PiLess where pi = 0/0.0
22:15:34 <dons> nope
22:15:48 <dons> he's on -cafe though
22:15:58 <thoughtpolice> Axman6: trying to make a safe, simple web app framework
22:16:10 <thoughtpolice> Axman6: by using both takusen + hyena.
22:16:18 <thoughtpolice> along with other static tricks
22:16:19 <Axman6> YAHWF?
22:16:31 <pstickne> thoughtpolice:  HaPPs?
22:17:28 <pstickne> Axman6:  mm, s/H/[PRJ]/ :)
22:18:01 <Axman6> PRJ? python, ruby, java?
22:18:20 <somnolence> sooo anyone have anyguesses as to the mysterious integral float?
22:18:37 <pstickne> Axman6:  heh, exactly! :)
22:19:07 <Axman6> ha, it's raining, and i just saw the cat slink past my window
22:19:10 <Axman6> stupid thing
22:19:14 <dmwit> somnolence, eh, Integral float?
22:19:23 <pstickne> Axman6:  I think it's interesting how much you deriving the same languages implies
22:19:36 <dmwit> somnolence, Sounds like mixing div and (/), but without some code, it's hard to know for sure.
22:19:37 <somnolence> dmwit: yes the mystery http://rafb.net/p/DlKHXG47.html
22:19:40 <somnolence> :)
22:20:06 <somnolence> that's a snippet btw you can ignore the level1/2 calls
22:20:08 <dmwit> somnolence, fromIntegral i < sqrt p
22:20:14 <somnolence> tried it :(
22:20:17 <somnolence> I can try again
22:20:22 <somnolence> thought it might have been that
22:20:42 <somnolence> no effect
22:21:11 <dmwit> somnolence, Put some type signatures on fermat and factors3.  It looks like you're asking them to return both Integral and Float values.
22:21:16 <Olathe> i*i < p
22:21:20 <Olathe> > let bits = fst.head.dropWhile ((/=0).snd).iterate ((+1)***(*2)) $ (a-1, a) where a = 1 in bits :: Word8
22:21:23 <dmwit> somnolence, (Try dropping show (x :: Float) from the last line, for example.)
22:21:26 <somnolence> I want to but I don't know :(
22:21:27 <somnolence> how
22:21:29 <Olathe> Works fine in ghci, but not with lambdabot.
22:21:30 <lambdabot>   mueval: Prelude.read: no parse
22:22:04 <dmwit> somnolence, Add a line at the top like "fermat :: MonadRandom m => Integer -> Integer -> m Integer" or whatever.
22:22:07 <dmwit> :t getRandomR
22:22:10 <lambdabot> Not in scope: `getRandomR'
22:22:39 <dmwit> :t System.Random.getRandomR
22:22:40 <lambdabot> Not in scope: `System.Random.getRandomR'
22:22:46 <dmwit> ?index getRandomR
22:22:46 <lambdabot> bzzt
22:22:52 <dmwit> ?index randomR
22:22:52 <lambdabot> System.Random
22:22:56 <dmwit> :t randomR
22:22:57 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
22:23:07 <ac> is there a way to load a module in ghci that's not in your library path (say it's in your current directory)?
22:23:19 <CakeProphet> :l
22:23:21 <somnolence> dmwit I have an import
22:23:21 <Olathe> :l thingy
22:23:24 <somnolence> here let me put complete code up
22:23:32 <dmwit> Oh, I was actually right about the MonadRandom context.  wow
22:23:53 <ac> Olathe: what if you want to combine the definitions in a module with the definitions in another module?
22:25:13 <somnolence> http://rafb.net/p/qYnsyh86.html
22:25:29 <somnolence> dmwit: if it helps first it says x should be type float
22:25:45 <somnolence> it throws the integral float error
22:26:13 <dmwit> somnolence, I'm guessing it doesn't like you claiming that IO is an instance of MonadRandom.
22:26:56 <somnolence> so how would I go about fixing that?
22:27:11 <dmwit> somnolence, You've got to use evalRandIO to convert between the random monad and the IO monad.
22:28:01 <somnolence> can you give an example?
22:28:04 <dmwit> do { x <- evalRandIO (test3 600851475143); putStrLn ("Level3: " ++ show x) }
22:28:06 <somnolence> sorry, it's my first day.
22:28:10 <somnolence> thanks
22:28:33 <dmwit> Also, stick a bunch of lines in like
22:28:55 <dmwit> test3 :: Integer -> Rand StdGen Float
22:29:10 <dmwit> fermat :: Integer -> Integer -> Rand StdGen Float
22:29:10 <dmwit> etc.
22:29:22 <dmwit> It will help make the type errors more comprehensible.
22:30:05 <somnolence> now there's a type error between Float and the Integer 'prime' in the line test3 prime = factors3 1 prime 0
22:30:12 <somnolence> fromIntegral(prime)?
22:30:32 <dmwit> Are you 100% sure you want to be returning a Float?
22:30:45 <dmwit> That doesn't really make sense, since all the operations you're doing are integer operations.
22:30:47 <somnolence> I'm about 10% sure of anything.
22:30:51 <polveroj> somnolence: sqrt takes a float--it compiles with "sqrt (fromIntegral p)" instead
22:31:04 <somnolence> oooh
22:31:06 <somnolence> good idea thnx
22:31:10 <dmwit> Mmm, yeah, also that.
22:31:14 <dmwit> polveroj++
22:33:44 <Axman6> http://blog.uncool.in/2009/01/19/computer-science-fail-higher-education-in-india/ oh wow, get out man, get out now!
22:35:03 <dmwit> Yeah, that list is really scary.
22:36:34 <cygnus__> article seems like bullshit
22:37:50 <Olathe> Oh, I don't doubt it.
22:37:57 <Axman6> "At one point, someone asked the teacher what 'argc' and 'argv' mean. She dismissed this with, "they don't mean anything. Back in the day, the computer guys would sometimes just make up nonsense names."" from the reddit comments >_<
22:38:01 <Axman6> me either
22:38:14 <Olathe> I've seen masters level students that got their bachelors degree in India and very few of them were competent.
22:38:25 <Axman6> i've heard some pretty bad stuff from comp teachers. luckily not at uni. they introduced me to haskell :)
22:39:55 <hydo> Any of you know if Jeff Heard (vis.renci.org) frequents the channel?
22:40:04 <ddarius> He does.
22:40:28 <dons> ?seen jrh
22:40:28 <lambdabot> I saw jrh leaving #haskell 8h 36m 53s ago, and .
22:40:31 <hydo> ddarius: what is his nick?  I want to try to catch him.
22:40:33 <hydo> ah, thanks!
22:40:34 <dons> ^^
22:40:45 <dons> blogs make people interesting :)
22:40:48 <hydo> hehehe
22:40:53 <hydo> they can!
22:41:25 * ddarius tries to avoid be interesting as much as possible and succeeds fairly well most of the time.
22:41:25 <Axman6> not mine, that's why it died :(
22:41:42 <ddarius> Axman6: What, now everyone knows how uninteresting you are?
22:42:04 <Axman6> they did, but i put a stop to that!
22:42:13 <ddarius> Axman6: What was on it? or just random stuff?
22:42:14 <Axman6> well, my OpenBSD router did at least. it bricked itself
22:42:24 <Axman6> random stuff mainly.
22:42:34 <Axman6> it would be more interesting these days though, with the haskell 'n all
22:42:52 <ddarius> Yeah, for random stuff to work, it has to be -really- random.
22:43:26 <Axman6> anyone know of somewhere i can get a free blog hosted that will support haskell hilighting?
22:44:18 <keseldude> @kind Int -> [Char]
22:44:20 <lambdabot> *
22:44:38 <Axman6> "My intro to C teacher wrote all his examples in Visual Basic."
22:44:39 <Axman6> After about a month someone asked him why he wasn't writing in C. The teacher had this blank stare, as if it had just occurred to him that VB code and C code were different things.
22:45:00 <ddarius> Axman6: Languages are all the same.  It's just different syntax.
22:46:36 <Axman6> i'm pretty damn happy to be going to ANU, especially after reading all these stories :|
22:47:12 <Axman6> all my comp lecturers so far have all been teaching things they could probably implement in a compiler in a day. they all know their shit
22:50:29 <Axman6> my first lecturer has some code i GHC
22:52:07 <ozy`> Axman6: http://conal.net/blog/posts/switching-blog-engines/ <== give this a shot
22:52:41 <ozy`> http://olsner.se/2008/02/05/literate-haskell-blogging/ <== note also
22:52:49 <conal> i can't help but wonder if the university system is being superceded by something else emerging now.  something self-assembling, peer-oriented & adaptive.
22:53:01 <ddarius> conal: I wish.
22:53:06 <conal> ditto with publications
22:53:34 <ddarius> conal: If that is happening it will be a while before industry notices which doesn't help the those people outside of the (usual) system.
22:53:38 <Axman6> thanks ozy` :)
22:54:10 <ddarius> That said, those people can probably fend for themselves.
22:54:16 <conal> ddarius: yeah.  change always takes a while and some people will never let go of old systems voluntarily.  that's the blessing of mortality.
22:54:24 <quicksilver> conal: journals might be being superseded. I think physical face to face tuition will always have a place in the world.
22:54:29 <ddarius> conal: Amen
22:54:46 <ddarius> quicksilver: Of course it will.  But that doesn't mean universities.
22:54:54 <conal> a few years ago, i attended an unconference called "Seattle Mind Camp", and i was astounded by the unbridled creativity there.  and no mention of conventional pedegrees.
22:55:20 <ddarius> And I suspect universities will adapt sooner or later.
22:55:36 * bos is mystified by ghc's inliner
22:55:41 <quicksilver> Calling it an 'unconference' is so unbearably self-concious though.
22:55:55 <ddarius> bos: My understanding is that's the appropriate response.
22:56:32 <bos> a function annotated with {-# INLINE #-} in a separate module gets wildly different performance from the same function copied into the module where it's used
22:56:57 <conal> bos: eep!
22:57:07 <conal> bos: with -O2?
22:57:08 <bos> conal: yes, that was my reaction
22:57:12 <bos> conal: yes
22:57:18 <conal> dang.
22:57:24 <Axman6> > take`id`20$fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*).(*2))$1
22:57:27 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
22:57:34 <Axman6> >_<
22:57:42 <bos> conal: 3x performance difference, because the function's in an inner loop
22:57:47 <ddarius> Axman6: Now write the obvious C code that corresponds.
22:58:01 <ddarius> and `id` what the heck?  Use $ like you did two other places.
22:58:04 <ddarius> 3
22:58:04 <dons> yeah, there's still cases where that happens. spj explained them recently
22:58:06 <conal> bos: might be worth checking out the differences in core
22:58:19 <dons> i think there's even a ticket.
22:58:26 <bos> this brings Data.Text performance from anaemic to smokin'
22:58:29 <dons> we want to either squish or document the cross-module inlining issues
22:58:33 <Axman6> ddarius: got it from http://olsner.se/2008/02/05/literate-haskell-blogging/, wondering what it actually did
22:58:34 <conal> dons: glad to hear it
22:58:45 <ddarius> Axman6: It wasn't obvious?
22:58:55 <dons> bos, there's some particular cases where ghc won't inline across modules. (and won't do recursive things in general)
22:59:02 <Axman6> not to a mere mortal like me, no
22:59:10 <Axman6> i also didn't think about it to hard
22:59:10 <bos> dons: this is ByteString.unsafeIndex, in case you're curious
22:59:10 <dons> time to dig up that mail and put it on the wiki
22:59:19 <dons> that wasn't being inlined?
22:59:24 <bos> right
22:59:29 <dons> hmm :/
22:59:53 <dons> unsafeIndex (PS x s l) i = assert (i >= 0 && i < l) $ inlinePerformIO $ withForeignPtr x $ \p -> peekByteOff p (s+i)
22:59:57 <dons> {-# INLINE unsafeIndex #-}
22:59:58 <Axman6> are there any (unofficial) rules about using INLINE?
22:59:59 <dons> ghc 6.10?
23:00:05 <bos> dons: yep
23:00:08 <dons> i bet that is an example of something that was fine under 6.8.x
23:00:16 <dons> i saw similar things go a bit wack with Data.Binary
23:00:25 <dons> ok. maybe though this is simple enough to be a bug report
23:00:33 <pstickne> conal:  but universities hold the right to grant slips of 'accredited' paper...
23:00:39 <dons> make an offering to the Great Simplifier
23:00:47 <conal> pstickne: anyone who wants to holds that right
23:00:59 <bos> the really weird weird thing?
23:01:00 <pstickne> conal:  'accredited'
23:01:04 <conal> yes
23:01:06 <dons> bos, i'd make a ticket. that's just wrong. it really should inline
23:01:20 <dons> or bytestring'll fall off the map
23:01:23 <pstickne> conal:  by whom?
23:01:26 <quicksilver> pstickne: there is no particularly effective restriction on who can 'set up' a new 'university'
23:01:29 <pstickne> conal:  it's like a SSL certificate.
23:01:31 <bos> the really weird weird thing is that the generated core is the same.
23:01:43 <pstickne> conal:  anyone can make one; who assigns validity?
23:01:49 <dons> that's not a good sign.
23:01:51 <ddarius> pstickne: It doesn't matter who says what about the piece of paper, it matters how the people looking at them value them.
23:01:52 <pstickne> quicksilver:  actually, there kinda is (in the US at least)
23:01:54 <dons> you're getting the same core, but its faster?
23:01:55 <quicksilver> pstickne: in effect, anyone can do it, if they are prepared to put in the effort to make it look fairly genuine.
23:02:08 <quicksilver> pstickne: not a "particularly effective" restriction ;)
23:02:11 <quicksilver> pstickne: just a nominal one.
23:02:15 <bos> dons: yeah
23:02:24 <dons> ... not good. something's wrong
23:02:49 <quicksilver> bos: that sounds like something SPJ would be interested in ;)
23:02:51 <Axman6> heh
23:02:57 <conal> there are many examples of bottom-up creditation systems on the internet, gaining mind-share.
23:03:14 <conal> hierarchy has had its day.
23:03:17 <pstickne> (I must be out of it, I don't know of any :-/)
23:03:24 <ozy`> a random aside: I'm sick of the multiple-definition style. it's way, way overused.
23:03:27 <taruti> shapr: hi :) (was sleeping earlier)
23:03:32 <ddarius> Well there's the one that has existed since the dawn of human civilization.
23:03:43 <quicksilver> pstickne: #haskell, haskell-cafe, and related blogs, are one example.
23:03:46 <ddarius> taruti: He's probably sleeping now.
23:03:58 <pstickne> quicksilver:  how are those ... ahh, nvm.
23:04:02 <ddarius> If not, he should be.
23:04:08 <bos> if i can make a repro, i'll file it.
23:04:13 <quicksilver> pstickne: bottom up creditation system, not actually a university ;)
23:04:22 <bos> it could just be that the inliner and -prof are at odds
23:04:30 <ddarius> @google "#haskell university"
23:04:32 <lambdabot> http://www.haskell.edu/
23:04:32 <conal> pstickne: also, all user/customer review sites.
23:04:32 <lambdabot> Title: Haskell Indian Nations University
23:04:35 <ddarius> Damn
23:04:50 <pstickne> heh
23:05:35 <quicksilver> pstickne: to give you a more job-related one : I work in perl programming, and the recruitment people I deal with know that a well-known module uploaded to CPAN is more important than a university degree.
23:05:36 <Axman6> wtf, some dick stole axman6.wordpress.com!
23:05:39 <Axman6> :'(
23:05:46 * mpeter starts screaming uncontrollably
23:05:49 <Axman6> maybe it was me...
23:05:49 <quicksilver> pstickne: so in effected, CPAN is a bottom-up creditation system ;)
23:05:53 <Axman6> beter have been me!
23:05:56 <pstickne> quicksilver:  or any CPAN module that doesn't scare the crap out of them? :)
23:06:12 <ski_> (ozy` : "multiple-definition style" ?)
23:06:16 <quicksilver> pstickne: actually I think one which *does* scare the crap out of them is worth more CV points :)
23:06:27 <pstickne> quicksilver:  ;-)
23:06:27 <Axman6> seems it was me, whoot!
23:06:31 <ddarius> It depends on why it scares them.
23:06:42 <pstickne> ddarius:  200 lines of golf?
23:06:50 <ddarius> But I guess if they've heard of it -and- it scares them then that's good.
23:06:56 <ozy`> ski_: f x y z foo bar baz 1 = stuff; f x y z foo bar baz 2 = stuff2; f x y z foo bar baz 3...
23:06:58 <mpeter> i thought CPAN was the perl module system
23:07:10 <mpeter> not a golf game!
23:07:18 <ozy`> ski_: put that in a file and lay it out properly and it'll be a huge block of unreadable text
23:07:19 * mpeter scolds #haskell
23:07:55 <ski_> (ozy` : i sure hope that isn't just several unrelated things smashed into one ..)
23:08:08 <mpeter> @offtopic
23:08:08 <lambdabot> Unknown command, try @list
23:08:13 <mpeter> @quote mpeter
23:08:13 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
23:08:18 <mpeter> @quote Axman6
23:08:19 <lambdabot> Axman6 says: inface, ST is just plain awesome
23:08:30 <mpeter> @quote ski_
23:08:31 <lambdabot> ski_ says: unique among types, 'Void -> X' has its own charm. tourists should definitly pay a visit.
23:08:32 <ddarius> @tell pstickne "Don't let school get in the way of an education."
23:08:33 <lambdabot> Consider it noted.
23:08:33 <Olathe> @quote spj
23:08:33 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
23:08:36 <mpeter> ugh
23:08:52 <Axman6> i quite like that quote :)
23:08:55 <ozy`> ski_: no, it's a common way that people write functions.
23:09:06 <ozy`> I'm a big fan of readability and DRY
23:09:17 <Axman6> > axman6
23:09:18 <lambdabot>   I love you Axman! Don't ever leave me!
23:09:21 <ski_> ozy` : any example ?
23:09:22 <mpeter> i don't get it
23:09:24 <Axman6> >_>
23:09:40 <mpeter> i'm a big fan of culpability and DIY
23:09:44 <ozy`> ski_: the eval function in that "scheme in 48 hours" tutorial
23:09:46 <mpeter> except i don't actually do anything myself
23:09:52 <polveroj> ozy`: I agree, it bugs me that you have to write the name of the function again and again
23:10:22 <conal> ddarius: :)
23:10:31 <polveroj> ozy`: but nested conditionals/cases are also ugly--it would be nice to have some kind of "curried case" expression
23:13:43 <ozy`> polveroj: they can be ugly, sure, but if you get more than one or two levels of conditionals it's time to refactor (or use a new control structure) anyway
23:15:04 <adrian_> hello
23:15:20 <ski_> (polveroj : writing the name doesn't particularly bother me ..)
23:15:27 <adrian_> how do I tell the typesystem I only want Eq a in my datatype?
23:15:31 <somnolence> can someone explain this to me:
23:15:33 <somnolence> *Main> fromIntegral(1) < sqrt(fromIntegral 9999999999999)
23:15:33 <somnolence> True
23:15:36 <adrian_> e.g. data A a = A {f :: a -> a -> Bool}
23:15:40 <somnolence> ? how is that true
23:15:42 <adrian_> where f = (==)
23:15:52 <somnolence> oh parenthesis
23:16:09 <somnolence> no
23:16:12 <somnolence> still getting true
23:16:30 <ski_> > fromIntegral 1 < sqrt (fromIntegral 9999999999999)
23:16:32 <lambdabot>   True
23:16:34 <adrian_> > fromIntegral 9999999999999
23:16:36 <lambdabot>   9999999999999
23:16:42 <ski_> what did you expect ?
23:16:44 <adrian_> > sqrt $ fromIntegral 9999999999999
23:16:45 <lambdabot>   3162277.660168221
23:16:50 <ski_> (or rather, why ?)
23:16:51 <adrian_> looks > than 1 to me
23:17:26 <somnolence> nvm
23:17:28 <somnolence> spacing out
23:17:28 * bos is a bit puggled by how to control fusion in some circumstances
23:17:28 <somnolence> lol
23:17:37 <ski_> (ozy` : btw, might you give a link to this eval function whereof you speak ?)
23:17:54 <polveroj> bos: Don't worry, so are the physicists.
23:18:20 <bos> dons: i have a fused length function that works beautifully over an array if the array doesn't need to be constructed - it counts the bytes as it should, and there's no allocatio
23:19:00 <bos> dons: but it could be an O(1) function if the array has already been constructed for some reason, and of course i get the slow fused version either way
23:19:38 * bos wonders how to control for that
23:20:18 <dons> one way would be to use a rewrite rule to write it back to the normal form in phase 3
23:20:23 <dons> the list lib does that
23:20:38 <dons> so you speculatively try to fuse. hope the code doesn't get mixed up. then write it back if it is still sitting there unfused
23:21:09 <dons> i think we talk about this in the original bytestring paper
23:21:33 <_dolio> There's a question on glasgow-users why uvector doesn't do that.
23:21:36 <dons> its not terribly robust, but you'd have to try it on a case-by-case basis.
23:21:37 <adrian_> ah, data Eq a => A a = ...
23:21:46 <dons> _dolio: it adds a bunch of complexity
23:21:49 <bos> dons: stream-fusion package?
23:21:50 <dons> 2* the rules
23:21:53 <dons> bos, yeah
23:21:56 <_dolio> I would have answered, but I figured you were more authorative.
23:21:57 <ozy`> ski_: http://paste.pocoo.org/show/100498/
23:22:00 <dons> each function has a rule before, and after.
23:22:06 <dons> _dolio: thanks for reminding me.
23:22:17 <ozy`> pieced together from this, by the way: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Defining_Scheme_Functions
23:22:23 <ozy`> (not all shown in one place)
23:22:28 <dons> {-# RULES
23:22:28 <dons> "map -> fusible" [~1] forall f xs.
23:22:28 <dons>     map f xs = unstream (Stream.map f (stream xs))
23:22:28 <dons> "map -> unfused" [1] forall f xs.
23:22:28 <dons>     unstream (Stream.map f (stream xs)) = map f xs
23:22:31 <dons>   #-}
23:22:34 <bos> dons: is there a darcs repo of that somewhere?
23:22:49 <dons> yup code.haskell.org/~dons/code/stream-fusion iirc
23:22:54 <dolio> Or even authoritative.
23:22:59 <quicksilver> adrian_: FWIW that doesnt really work.
23:23:17 <adrian_> quicksilver: why?
23:23:24 <bos> dons: luvverly jubbly, cheers
23:23:27 <quicksilver> adrian_: you don't get the Eq constraint back when you pattern match
23:23:31 <dons> bos, http://code.haskell.org/~dons/code/stream-fusion/Data/List/Stream.hs
23:23:32 <quicksilver> adrian_: which makes it kind of useless.
23:23:35 <ski_> ozy` : doesn't look too bad, imo
23:23:38 <quicksilver> adrian_: arguably this is a bug in haskell98.
23:23:47 <adrian_> so what should I do instead?
23:23:50 <quicksilver> adrian_: GHC gets it right for GADT syntax.
23:23:52 <dons> that was definitely the most thorough approach to the speculative-rewrite approach
23:23:55 <quicksilver> adrian_: otherwise, just don't both.
23:23:57 <dons> enough that we did the whole lib that way
23:24:01 <quicksilver> adrian_: don't "bother", I mean
23:24:06 <dons> with uvector i wanted to give the user precise control over what they wanted
23:24:14 <ski_> ozy` : how would you suggest making it better ?
23:24:14 <quicksilver> adrian_: stick the Eq constraing on all the functions which use "A" and leave it at that.
23:24:24 <adrian_> not very elegant
23:24:38 <quicksilver> adrian_: perhaps. As I say, some regard this as a bug in haskell98.
23:24:52 <quicksilver> adrian_: In my experience, constraints on data types are often a mistake anyway.
23:25:00 <ozy`> ski_: eval env val = case val of {...}
23:25:13 <ski_> ozy` : that is better, why ?
23:25:23 * Workybob ponders who maintains gtk2hs in MacPorts
23:26:14 <ski_> ozy` : i'll give you that i'd abstract out the `env' parameter, when possible, into an outer loop
23:26:18 <adrian_> is there a proposal to fix it in Haskell'
23:26:35 <ozy`> ski_: just because then my eyes don't have to scan a huge pile of text looking for the values that actually determine the behavior of the function
23:27:08 <ozy`> (syntax highlighting doesn't help that much for me...)
23:27:56 <ski_> (ozy` : also, i doubt this could can handle `((lambda (lambda) (lambda lambda)) (lambda (lambda) (lambda lambda)))' correctly ..)
23:28:11 <ski_> (s/can //)
23:28:27 <quicksilver> adrian_: I don't think so. GHC's GADT implementation does the 'right thing' with constraints on constructors though.
23:28:43 <ozy`> ski_: that could be fixed, but it's not my function anyway so I don't care :p you just asked for an example
23:28:47 <quicksilver> so it will probably be "fixed" by haskell' gadts
23:29:05 <ski_> (ozy` : yes .. that was just a general critisism)
23:29:57 <ski_> ozy` : however, i think the `eval .. = ..' form can make it more easily understandable in a local context
23:30:14 <Axman6> damn, wordpress has got really nice
23:30:22 <ski_> ozy` : i.e. you have a bunch of equations you all know to be true .. so you can apply them individually when reasoning
23:30:55 <ozy`> ski_: if there are only a few versions of the function, it's fine. maybe up to four or five and I won't even notice
23:31:21 <ozy`> IIRC, though, the final version of that function in the tutorial spanned over 50 lines
23:31:31 <ski_> ozy` : but, as i hinted, i would probably do something like `evalWith env val = eval val where eval (String _) = val; ...'
23:32:11 <ozy`> I have no idea why you'd do it that way, but all right :p
23:32:16 <ski_> ozy` : i'd argue that the more cases there are, the more i'd prefer several defining equations instead of one ..
23:32:23 <ski_> ozy` : ymmv, of course
23:33:38 <ski_> ozy` : you mentioned "scan a huge pile of text looking for the values that actually determine the behavior of the function" .. i was thinking you might prefer omitting the `env' in each case (to the given version)
23:34:36 <ozy`> ski_: the "env" is the first thing that would go, yes
23:35:04 <ozy`> but the other massive duplication bothers me as well
23:36:30 <ski_> naming `eval' ?
23:39:05 <ozy`> ski_: yeah. but then, it's pretty damning to have the function span 50 lines in the first place, so.... definitely gonna need refactoring, anytime I see something like that
23:39:46 <dons> gitit is a nice wiki
23:40:03 <dons> philosophy professors build great systems
23:41:06 * bos gets length to run in linear time
23:41:08 <bos> dons++
23:41:13 <dons> why have people really caught onto markup, but haven't made the leap to whitespace sensitive programming languages so easily?
23:41:14 <bos> er, constant time
23:41:16 <dons> bos, woot
23:41:28 <dons> using the match-and-write-back trick rule?
23:41:40 <dons> markdown, i should say.
23:41:54 <dons> haskell syntax: markdown for programming. (now you get the idea!)
23:43:19 <ozy`> dons: the problem with haskell in particular is that it's whitespace-sensitive sometimes, but not others... and the distinction isn't immediately obvious, and doesn't necessarily make sense even when explained
23:43:30 <bos> why aren't people throwing confetti in the streets over fusion as a library optimisation?
23:43:39 <ozy`> bos: I am!
23:43:45 * ozy` explodes
23:43:49 <dons> bos, hehe.
23:44:35 <dons> too hard to extend non-GHC systems with term rewriting, static typing and purity, and the spec-constr optimisation? haskell people like it though.
23:45:07 <dons> the lisp people could do it with macros, i suspect.
23:45:25 <ozy`> dons: and then it wouldn't necessarily compile...
23:45:45 <ozy`> (ie. it would run, but it'd have to be interpreted. maybe.)
23:46:11 <bos> i wonder what a good strategy for having types implement NFData is
23:46:34 <bos> everyone ought to do it, but then everyone will depend on parallel even when they've no need to otherwise
23:46:44 <dons> hack a deriving tool?
23:46:46 <bos> maybe we should move NFData into base
23:46:50 <dons> yeah
23:48:10 <Axman6> what's NF stand for anyway? i was looking around the other day and couldn't find anythign
23:48:14 <bos> normal form
23:48:21 <Axman6> ah, yes, right
23:48:59 <bos> that module is home of the wonderfully named rwhnf function. try pronouncing that even before your fifth vodka!
23:49:10 <Workybob> @seen dcoutts
23:49:11 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 7h 59m 55s ago.
23:49:13 <dmwit> I sound like a dog!
23:51:47 * bos wonders what to do with haddock if a module has multiple maintainers
23:51:57 <BMeph> bos: What is that, Welch? ;)
23:52:04 <BMeph> *Welsh
23:53:09 <daf> why do people think that Welsh has no vowels? :)
23:53:37 <daf> it's got two more than English does
23:53:44 <Zao> daf: All masking as consonants :)
23:55:10 <daf> heh
23:56:44 <bos> dons: any idea whether fusion and typeclasses might go together?
23:57:03 <Axman6> oh lame! you can't add plugins to wordpress.com sites >_<
23:57:39 <bos> dons: e.g. Data.Text has a fixed dictionary of encodings, and it would be great to open it up via a class, but i'm concerned that Bad Things (most likely, nothing at all) would occur
