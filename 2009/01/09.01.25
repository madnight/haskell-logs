00:00:00 <ksf> forall a . hi a
00:01:27 <inv> I'm really sorry, but I asked the same question 3rd time:
00:01:39 <inv> why p_some is not tail-rec here ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=923#a923
00:01:56 <ksf> murphy :: exists a . a -> Fail
00:02:06 <inv> I used $! before, but how can I use 'force' for parameters without $! ?
00:02:21 <ksf> -Xbang-patterns
00:02:24 <ksf> foo !x = x
00:02:42 <pumpkin> or just use seq
00:02:59 <inv> I don't understand seq
00:03:03 <inv> a -> b -> b
00:03:13 <ksf> @src seq
00:03:13 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:03:17 <ksf> ?!
00:03:17 <lambdabot> Maybe you meant: . ? @ v
00:03:33 <ksf> #src ($!)
00:03:41 <ksf> @src ($!)
00:03:42 <lambdabot> f $! x = x `seq` f x
00:03:44 <ksf> there.
00:03:46 <ksf> it's the same.
00:04:11 <inv> ksf, Syntax error in declaration (unexpected `!')
00:04:22 <inv> f !x = .....
00:04:24 <pumpkin> inv: seq just says (if you evaluate my result, evalute my first parameter first, and then I'll give you my second parameter as your result)
00:04:27 <ksf> that's why you should use -Xbang-patterns
00:04:37 <kiris> pretty sure p_s is tail recursive
00:05:29 <inv> but why hugs makes stack overflow on it ? :)
00:05:37 <inv> why does hugs make ...
00:05:43 <kiris> because it's not optimising it, I'd guess
00:06:06 <inv> does ghci have the same problem ?
00:06:13 <kiris> it needs to perform tail call optimisation for tail recursive code to be useful
00:06:26 <ksf> inv, I'd doubt it.
00:06:30 <kiris> inv: ghci does after a certain point because it doesn't bother with optimisation
00:06:34 <ksf> if in doubt, use ghc -O2.
00:06:48 <ksf> if it still isn't tail-recursive, _then_ you've got a problem.
00:07:27 <kiris> I'd never had a stack overflow with GHC -O2
00:07:29 <inv> very strange for me :)
00:07:37 <kiris> had loads with GHCi
00:07:52 * ksf once had one with parsec 1
00:07:53 <inv> not -O2, but this behaviour
00:08:11 <ddarius> inv: You can find out whether it builds up stack the same way I demonstrated before; just evaluate some examples out by hand.
00:08:24 <inv> maybe hugs is poor realisation of haskell?
00:08:38 <ddarius> inv: The problem is your code, not Hugs.
00:08:42 <inv> I'll try to make seq
00:08:49 <ddarius> kiris: It is not obvious that p_s is tail-recursive.
00:09:21 <kiris> ddarius: why?
00:09:23 <ksf> ddarius, isn't it as simple as tail call == return thunk of recursive call not used before it gets returned?
00:09:34 * ksf hopes so.
00:09:36 <inv> ddarius: I'm sure I shouldn't feel any difference is it lazy or not
00:09:39 <ddarius> kiris: Because it is called through p.
00:09:44 <ksf> otherwise, scheme is really, really cozy.
00:09:58 <ddarius> inv: Laziness matters, evaluate it out by hand and you'll see what is building up and then know how to fix it.
00:10:02 <kiris> ddarius: so?
00:10:36 <ddarius> kiris: That means for some values p_s = case p_s ... of -> ... which is not tail-recursive.
00:10:52 <ddarius> kiris: It might still not use arbitrary amounts of stack, but that isn't -immediately- obvious.
00:11:50 <ddarius> ksf: Technically, tail-calls in Haskell are the same as tail-calls in Scheme.  It's a syntactic property.  Of course, stack usage in Haskell is different from stack usage in Scheme, but that is a semantic property.
00:12:14 <ddarius> The best thing to do in these cases is simply to evaluated a few rounds by hand.  It becomes very obvious what the issue is then.
00:12:20 * ksf usually trusts the strictifier until proven otherwise
00:12:24 <kiris> ddarius: but the tail call is a recursive one -- why does it matter what p does?
00:13:05 <ddarius> kiris: I don't understand what you mean by that.
00:13:10 <ksf> that is, I first recompile with -O2 to see if I actually have a problem.
00:13:20 <inv> is it correct? just for example: seq 1 $! seq 2 $ f 1 2 where f a b = a + b
00:13:26 <Peaker> ddarius: usually "semantics" means "denotational semantics"..
00:13:42 <inv> second if $!
00:13:44 <inv> is
00:13:46 <ksf> peaker, only with those bloody formalists.
00:13:48 <ddarius> ksf: Relying on strictness analysis for asymptotic space usage that in practice means the difference between your program working and not working is a bad idea.
00:13:57 <ddarius> Peaker: No it doesn't.
00:14:35 <ksf> hell if I wouldn't there'd be bangs all around my code.
00:14:35 <ddarius> Not that that changes anything.  You can certainly have a denotational semantics that keeps track of these things.
00:14:49 <ddarius> ksf: That's not necessary either.
00:15:03 <inv> how can I write seq a $! seq b $! f a b without dublication of a and b ?
00:15:08 <kiris> ddarius: f .. .. = let p = ...; k = ... in f p k -- is `f' tail recursive?
00:15:10 <ddarius> ksf: There's no problem relying on the strictness analyser for -constant factor- improvements.
00:15:59 <mmorrow> ksf: i'd rather have bangs and know that things'll happen exactly how i want rather than rely on a "maybe it'll work i guess, but who know how/why" from strictness analysis
00:16:42 <ddarius> kiris: That's not the situation.  The situation is, you have f x = case f (x-1) of ... -> f ... and you change it to f x = case g x of ... -> f ... and g x = f (x-1), it doesn't matter that you've split it into two different functions.
00:16:47 <mmorrow> and i always compile with -O2 as well
00:17:10 <ksf> my point is that there's always a strictness analyser, so you wouldn't know if some dumber compiler would fail to produce a reasonable binary for your code.
00:17:32 <pumpkin> can quickcheck check a higher-order function somehow? does it have a list of premade functions to throw in and test with? :P
00:18:00 <ddarius> ksf: Um, there isn't always a strictness analyser and strictness analysis is undecidable in general.  Furthermore a small tweak to one point of your code can change the strictness elsewhere breaking code that worked before.
00:18:03 <kiris> ddarius: ah, I see
00:18:07 <dobblego> pumpkin, yes there is an Arbitrary for it
00:18:30 <mmorrow> ksf: i don't understand. wouldn't bangs be a way to ensure that your code will work no matter what the strictness analyzer for whatever compiler is (not) doing?
00:18:31 <dobblego> @check \f g x -> map (f . g) x == map f (map g x)
00:18:32 <lambdabot>       Overlapping instances for Show (a -> b)
00:18:32 <lambdabot>        arising from a use of `m...
00:19:06 <ddarius> ksf: Anyway, the strictness analyzer can't change the semantics of your code whereas you can.
00:20:02 <inv> (f $! a) $! b - is where any better way to write it ?
00:20:04 <ksf> ...I guess I have to stumble over a sufficiently lazy case to change my habit.
00:20:26 <hackage> Uploaded to hackage: DecisionTree 0.0
00:20:26 <pumpkin> inv: you sure are strict!
00:20:27 <Twey> inv: f $! a $! b
00:20:40 <inv> Twey: it's not the same
00:20:41 <ddarius> Twey: That means f $! (a $! b)
00:20:47 <Twey> Oh really?
00:20:53 <Twey> I thought it paralleled $...
00:20:53 <kiris> define !$  :P
00:20:56 <mmorrow> ksf: foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..100000000]
00:21:02 <ddarius> Twey: Which is also right associative.
00:21:04 <kiris> Twey: ..
00:21:10 <ksf> f $! $ a $! b ?
00:21:10 <Twey> ddarius: o.@
00:21:26 <Twey> > (+) $ 5 $ 3
00:21:27 <lambdabot>       Overlapping instances for Show (b -> b)
00:21:27 <lambdabot>        arising from a use of `s...
00:21:28 <kiris> ksf: that's still the same
00:21:35 <Twey> ... what am I thinking?
00:21:39 <ddarius> kiris: Nah, that's a parse error.
00:21:41 * ksf fails $
00:21:43 <Twey> I'm sure $ was left-
00:21:59 <ddarius> Twey: Nope or else there wouldn't be a campaign to make it so.
00:22:01 <Twey> a $ b $ c was the same as a b c
00:22:05 <kiris> :t (+1) $ 1 2
00:22:06 <lambdabot>     Ambiguous type variable `t' in the constraint:
00:22:06 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:9
00:22:06 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
00:22:07 <Twey> There was a big thing
00:22:08 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000]
00:22:10 <Twey> T_T
00:22:11 <lunabot>  Stack space overflow: current size 8388608 bytes.
00:22:11 <lunabot>  Use `+RTS -Ksize' to increase it.
00:22:14 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
00:22:16 <lunabot>  (500000500000,500000500000)
00:22:47 <kiris> Cale once showed why a left associative $ would be better in some cases, but I completely forgot why
00:22:59 <ddarius> kiris: This (for $!) would be one of those cases.
00:23:23 <inv> ok, (f $! a) $! b is the only way :)
00:23:33 <ddarius> inv: Not the only way, but probably the nicest way.
00:23:36 <pumpkin> there is ALWAYS ANOTHER WAY
00:24:01 <Twey> ($!) . ($!) $ a b
00:24:02 <Twey> :-P
00:24:05 <inv> ddarius : looks like lisp, I would prefer APL :)
00:24:22 <ksf> thinking of it, the haddocks should be much more explicit wrt. strictness.
00:24:29 <ddarius> inv: You could hide the Prelude ($!) and redefine it left associatively.
00:24:31 <inv> Twey: where is f here ? :)
00:24:42 <ksf> I know that + is strict but , not, but it's not always obvious.
00:24:42 <Twey> Eh, OK, OK, but you can do it :-P
00:24:47 <Twey> Yay, override
00:24:50 <ddarius> ksf: They should, yes.
00:24:59 <inv> ok, thank you
00:25:08 <ksf> I would even go so far as to typeclass that.
00:25:14 <ddarius> ksf: (+) isn't always strict.
00:25:20 <Twey> Do $ while you're at it :-P
00:25:25 <ksf> like in Integer vs. Int?
00:25:32 <mmorrow> neither are strict
00:25:39 <kiris> I swear a left-assocative $ can save parentheses in the common case
00:25:41 <kiris> hum
00:25:56 <ddarius> ksf: No, it's strict for both of those and for all the standard library (as in Haskell Library Report) types.
00:25:57 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
00:26:01 <lunabot>  [AP,Constr]
00:26:22 <mmorrow> , isFullyEvaluated (1+1)
00:26:24 <lunabot>  False
00:26:34 <ksf> so it should be (+) :: (Strict a, Num a) => a -> a -> a
00:26:41 <kiris> lunabot is clever and pretty
00:26:43 <ddarius> mmorrow: That's irrelevant.
00:26:48 <Twey> @src isFullyEvaluated
00:26:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:26:58 <ddarius> mmorrow: Nothing is evaluated until it is.
00:27:20 <porges> let x = undefined + 1
00:27:26 <ddarius> > undefined + 1 :: Integer
00:27:28 <kiris> @remember <ddarius> mmorrow: Nothing is evaluated until it is
00:27:28 <lambdabot>   * Exception: Prelude.undefined
00:27:28 <mmorrow> ddarius: yeah, my bad there
00:27:28 <lambdabot> It is forever etched in my memory.
00:27:30 <ddarius> > undefined + 1 :: Int
00:27:31 <lambdabot>   * Exception: Prelude.undefined
00:27:44 <ksf> Haskell isn't prejudical?
00:28:41 <Twey> 'Everyone's evaluated, but some are more evaluated than others'
00:28:50 <Peaker> is there a better way to use 127.0.0.1 than:
00:28:52 <Peaker> Socket.SockAddrInet (fromIntegral port) 0x0100007f
00:28:54 <pumpkin> is there a standard quickcheck output format? one with dots, asterisks, and hashes? is the meaning of that documented somewhere?
00:29:00 <pumpkin> I can't find it in the quickcheck manual
00:29:05 <kiris> Twey: HRY TARDER
00:29:10 <ddarius> pumpkin: There's always the code.
00:29:21 <Peaker> Some (IPAddr 127 0 0 1) constructor perhaps?
00:29:26 <Twey> Heh
00:29:36 <pumpkin> is this impossible to read for anyone else? http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
00:29:38 <ksf> is that first one endianess-safe?
00:29:50 <pumpkin> ddarius: yeah, but I'm scared :) and asterisks are hard to search for in source code
00:30:04 <ddarius> Yay frames
00:30:11 <porges> out of left field, but anyone know how to add new "bracket" characters to GHC?
00:30:26 <ddarius> Right-click, This frame -> Show only this frame
00:30:26 <kiris> Peaker: inet_addr?
00:30:44 <ksf> wtf compiling ghc just filled up my $HOME
00:30:53 <kiris> inet_addr :: String -> IO HostAddress
00:31:00 <ddarius> ksf: Disk is cheap, no?
00:31:22 <Peaker> kiris: hopefully not a DNS lookup or String conversion at runtime (Would rather get compile time problem than runtime one)_
00:31:38 <kiris> Peaker: I think it probably is. especially being IO. humm
00:31:57 <ksf> ...I just gave it another 2G.
00:32:03 <Peaker> oh, if its Word32, I guess its easy to just build it up from 4 Word8's
00:32:13 <kiris> indeed
00:32:27 <kiris> would be nice to have a function already existing though
00:32:31 <ksf> well, if I had more space it'll fill up, too.
00:32:48 <mmorrow> ksf: strict (+) is (+#)
00:32:59 <Peaker> what's a nice way to combine small Words to bigger ones?
00:33:11 <pumpkin> shift and or/add :P
00:33:19 <ksf> once upon a time, I bought a brand new 2.1G drive and thought that I'd never be able to fill it.
00:33:40 <pumpkin> PeakerWork: or put them in an unboxed array and coerce it to the larger one, keeping endianness in mind :P
00:33:57 <kiris> Data.Bits?
00:34:05 <Peaker> pumpkin: ah, would the compiler not optimize: foldl' (.|.) 0 $ zipWith shift words [0,8,..]   to be the same?
00:34:06 <ksf> Peaker, .&. `shiftL`?
00:34:21 <pumpkin> you want an .&.? :o
00:34:54 * ksf only uses nand.
00:35:43 <pumpkin> Peaker: I dunno if it'd be smart enough there, but who knows
00:35:43 <Peaker> @type \words -> foldl' (.|.) 0 $ zipWith shift words [0,8,..]
00:35:43 <pumpkin> only the core knows for sure
00:35:43 <lambdabot> parse error on input `..'
00:35:43 <Peaker> @type \words -> foldl' (.|.) 0 $ zipWith shift words [0,8..]
00:35:43 <lambdabot> forall a. (Bits a) => [a] -> a
00:35:43 <Peaker> @let makeBigWord words = foldl' (.|.) 0 $ zipWith shift words [0,8..]
00:35:43 <int80_h> @seen pumpkin
00:35:43 <lambdabot>  Defined.
00:35:43 <lambdabot> pumpkin is in #lhc-compiler, #haskell-blah, #ghc and #haskell. I last heard pumpkin speak 27s ago.
00:35:43 * ksf once implemented half of common lisp using nothing but nand.
00:35:44 <int80_h> hi pumpkin
00:35:58 <Peaker> > makeBigWord [127,0,0,1::Word8] :: Word32
00:36:00 <Twey> ksf: Hah!
00:36:00 <lambdabot>   Couldn't match expected type `Word32' against inferred type `Word8'
00:36:06 <Twey> That's nothing.  I once implemented Scheme in C!
00:36:14 <Peaker> > fromIntegral (1::Word8)::Word32
00:36:16 <int80_h> that's kooky talk
00:36:16 <lambdabot>   1
00:36:35 <pumpkin> hi int80_h
00:36:52 <Peaker> @let bigWord words = foldl' (.|.) 0 $ zipWith shift (map fromIntegral words) [0,8..]
00:36:55 <lambdabot>  Defined.
00:37:02 <Peaker> > bigWord [127,0,0,1::Word8] :: Word32
00:37:04 <lambdabot>   16777343
00:37:12 <Peaker> > showHex $ (bigWord [127,0,0,1::Word8] :: Word32)
00:37:13 <lambdabot>       Overlapping instances for Show (String -> String)
00:37:14 <lambdabot>        arising from a...
00:37:21 <pumpkin> it's backwards
00:37:23 <mmorrow> , let plus !a !b k = let !x = a + b in k x in foldl' (\(a,b) c -> plus a c (\x -> plus b c (\y -> (x,y)))) (0,0) [0..1000000]
00:37:24 <int80_h> pumpkin: I'd like to approach the problem we were talking about the other day, implementing cycle. I'm re-writing it right now, just wanted to see if you were here
00:37:25 <Peaker> > showHex (bigWord [127,0,0,1::Word8] :: Word32) ""
00:37:26 <lunabot>  (500000500000,500000500000)
00:37:27 <lambdabot>   "100007f"
00:37:32 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
00:37:35 <lunabot>  (500000500000,500000500000)
00:37:41 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000]
00:37:43 <pumpkin> int80_h: yup, might go to sleep soon though
00:37:43 <lunabot>  Stack space overflow: current size 8388608 bytes.
00:37:43 <lunabot>  Use `+RTS -Ksize' to increase it.
00:37:45 <pumpkin> it's almost 4 am
00:37:56 <ksf> int80_h, mov rax, 1 ; int 0x80
00:37:56 <ddarius> > (fix . (++)) "foo"
00:37:58 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
00:38:02 <int80_h> rats
00:38:29 <Twey> @src cycle
00:38:30 <lambdabot> cycle [] = undefined
00:38:30 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:38:43 <pumpkin> ddarius: you were right! the source held the answer, somewhat unsurprisingly
00:38:57 <ddarius> pumpkin: Call it intuition.
00:39:39 <mmorrow> , let seqk a k = let !x = a in k x in let a = 1 + 1 in a `seqk` isFullyEvaluated
00:39:41 <lunabot>  True
00:40:17 <ddarius> Actually, I highly recommend reading the source code of libraries/applications that interest you and/or the Prelude/GHC/etc.  Not as in look at the actual code and try to figure out what it does, but reading the comments.
00:40:23 <mmorrow> , let seqk a k = let !x = a in k x in (1+1) `seqk` isFullyEvaluated
00:40:25 <lunabot>  True
00:40:27 <ddarius> There's tons of good stuff in the Prelude and GHC sources.
00:40:31 <kiris> :t \words -> zipWith shift (map fromIntegral words) [0,8..]
00:40:32 <kiris> :t flip (zipWith (shift . fromIntegral)) [0,8..]
00:40:34 <lambdabot> forall a a1. (Integral a1, Bits a) => [a1] -> [a]
00:40:34 <lambdabot> forall b a. (Integral a, Bits b) => [a] -> [b]
00:40:54 <mmorrow> , (flip ($)) (1+1) isFullyEvaluated
00:40:56 <lunabot>  False
00:40:58 <Peaker> Integral a is too general, it needs to be Word8
00:40:59 <ddarius> lambabot should have a plugin that is a lhs story.
00:41:02 <Peaker> because of the [0,8...] there
00:41:06 <mmorrow> is what i meant to say before
00:41:30 <pumpkin> ddarius: that's what I've been doing for uvector :) I'm starting to get quite familiar with it now. And I've been doing it for a while with the GHC libs. You're right, it's very instructional
00:42:43 <Peaker> @type bigWord words = foldl' (.|.) 0 $ zipWith shift (map fromIntegral words) [0,bitSize (head words)..]
00:42:44 <lambdabot> parse error on input `='
00:42:52 <Peaker> @type \words = foldl' (.|.) 0 $ zipWith shift (map fromIntegral words) [0,bitSize (head words)..]
00:42:54 <lambdabot> parse error on input `='
00:42:57 <Peaker> @type \words -> foldl' (.|.) 0 $ zipWith shift (map fromIntegral words) [0,bitSize (head words)..]
00:42:59 <lambdabot> forall a a1. (Bits a1, Integral a1, Bits a) => [a1] -> a
00:43:13 <kiris> I've found reading the comments and the code of existing haskell libraries very useful, and hacking/adding bits to them
00:44:09 <mmorrow> kiris: totally
00:44:35 <Peaker> Bits should probably extend Integral and not Num
00:45:47 * pumpkin is delving deep into stream fusion internals now :D
00:46:02 <mmorrow> especially (violently) instructive is to use a ghc-HEAD with hackage packages. you quickly become a pro at as-fast-as-possible touchups to .cabal files, Setup.lhs's, and whatever else needs to be changed in a particular package's code to work with your ghc
00:46:37 <int80_h> pumpkin: ugh, I'm getting that infitnite type problem again
00:46:46 <mmorrow> int80_h: use a newtype
00:46:48 <int80_h> pumpkin, it's two lines, I'll post
00:47:16 <int80_h> mmorrow: a solution exists where that's not required, plus newtype hasn't been introduced yet
00:47:28 <mmorrow> oh
00:47:31 <int80_h> pumpkin: myCycle xs = let x  = foldr (:) [] xs
00:47:50 <Twey> Why do we even have newtype?
00:47:53 <ddarius> foldr (:) [] = id (closely enough)
00:47:54 <pumpkin> let x in x?
00:48:00 <int80_h> pumpkin:  in x:xs
00:48:02 <pumpkin> Twey: it's more efficient
00:48:04 <mmorrow> Twey: newtype doesn't exist at runtime. data does
00:48:16 <Twey> Can't data do it automatically for single-contructor data?
00:48:27 <Twey> It's transparent anyway, right?
00:48:46 <mmorrow> what's the point, since we have newtype? i'd rather be explicit about things
00:48:54 <mmorrow> actually, it can't
00:48:58 <int80_h> pumpkin: ?
00:49:12 <pumpkin> int80_h: x is a list of a, xs is a list of a
00:49:17 <pumpkin> :t (:)
00:49:18 <lambdabot> forall a. a -> [a] -> [a]
00:49:26 <mmorrow> data A a = A a; newtype B a = B a ===> B undefined == undefined, but A undefined /= undefined
00:49:41 <mmorrow> also, you can't do
00:49:50 <mmorrow> newtype A = forall a. A a
00:49:54 <mmorrow> but you /can/ do
00:49:58 <mmorrow> data A = forall a. A a
00:51:13 <mmorrow> (because newtype A = forall a. A a <=====> forall a.a , since the A doesn't exist at runtime)
00:51:18 <pumpkin> I need to stop using my macbook air for all my development work
00:52:33 <int80_h> pumpkin: you could use it to connect to a real dev server ;)
00:52:59 <ddarius> TFS
00:53:04 <pumpkin> I do a lot of work over ssh
00:53:09 <pumpkin> but it's still not ideal
00:53:23 <pumpkin> yay, I fixed a bug in uvector!
00:53:45 <ddarius> Add a test case to the test-suite?
00:53:50 <pumpkin> of course!
00:53:51 <int80_h> pumpkin: gah, I'm back where I started yesterday, stack overflow
00:53:54 * pumpkin is a good boy
00:54:09 <mmorrow> int80_h: you probably need a single well-placed "!"
00:54:18 <mmorrow> (or another algo..)
00:54:25 <ddarius> mmorrow: Actually, he probably has an infinite loop in his code.
00:54:25 <int80_h> another algo is what I need
00:54:31 <mmorrow> ddarius: yay!
00:54:35 <mmorrow> oh
00:54:44 <int80_h> cycle is supposed to be an infinit loop , right?
00:54:47 <T-Cell> can anyone out there answer a quick question about happs?
00:54:48 <mmorrow> ddarius: i thought you said "he probably /needs/ an infinite ..."
00:55:02 <ddarius> mmorrow: Well that's not too far from the truth either.
00:55:09 <mmorrow> true
00:55:11 <dobblego> int80_h, an infinite list
00:55:14 <pumpkin> now I need to figure out how these tests work and why my test is being interrupted
00:56:07 <Peaker> Twey: newtype is semantically different from data of single constructor, in strictness, and even different from a one-strict-field data, too
00:56:36 <mmorrow> yeah, that's the third diff
00:56:40 <mmorrow> can't do:
00:56:45 <mmorrow> newtype A a = A !a
00:57:05 <Peaker> Twey: newtype T = T SomeType   ; data T  = T !SomeType       -- the number of bottoms is the same, but they don't get caught in quite the same way
00:57:19 <ddarius> mmorrow: The issue is getting rid of newtype.  What newtype can't do is irrelevant as long as data can do everything newtype did (which it almost can)
00:57:45 <mmorrow> ddarius: by "can't do" i mean "ghc will refuse to let you"
00:58:06 <ddarius> newtype A a = A !a is pointless.  newtype is already strict in a.
00:58:23 <Peaker> I am not sure, but I think:  case t of (T _) -> 1  -- will catch the bottom in the data case, but not in the newtype case
00:58:37 <virkony> Can anyone give a quick hint how to get GHC-like malloc (with reusing allocated, but not yet freed memory) with FFI functions allocate/free/reset?
00:58:56 <mmorrow> ddarius: that's not allowed for the same reason top-level bangs aren't allowed
00:59:04 <ddarius> But data NT a = NT !a is almost identical to newtype NT a = NT a.  If newtype wasn't there for a reason we could have SingleDataConstructorDeriving instead of NewtypeDeriving.
00:59:15 <ddarius> mmorrow: It's not allowed because it doesn't make sense.
00:59:21 <mmorrow> exactly
00:59:21 <int80_h> pumpkin: does the answer to generating an infinite list lie in a recursive call?
00:59:37 <int80_h> @src myCycle
00:59:37 <lambdabot> Source not found. I feel much better now.
00:59:38 <pumpkin> int80_h: it's gotta be recursive somehow, or it won't be infinite :)
00:59:40 <ddarius> mmorrow: It doesn't make sense because it would be redundant, not it doesn't make sense because it would be insane.
00:59:41 <int80_h> @src cycle
00:59:42 <lambdabot> cycle [] = undefined
00:59:42 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:00:05 <ddarius> int80_h: There are essentially two ways of writing cycle.  The good way and the bad way.
01:00:18 <ddarius> !True = False
01:00:33 <int80_h> ddarius: well I expect using foldr must be the bad way, but that's the exercise
01:00:43 <Peaker> here's the difference between newtype and data: http://haskell.pastebin.com/m5e958344
01:00:59 <int80_h> ddarius: well the exercise is using a fold, I'm thinking foldr is the easiest one
01:01:07 <pumpkin> int80_h: the fold bit of what I wrote yesterday isn't really doing much
01:01:13 <pumpkin> if you fold a cons into a list
01:01:18 <pumpkin> it's basically id
01:01:24 <ddarius> int80_h: Well there're two ways of using foldr, one that results in the good way and one that results in the bad way.
01:01:39 <mmorrow> ddarius: i'm not so sure, my interpretation of what it would mean is that it would mean that a value :: A a (since the A doesn't exist at runtime) would allow you an always-strict value, which the execution model doesn't (?) handle
01:01:54 <int80_h> pumpkin: yeah, when my code does work, it's id.
01:02:06 <dobblego> pumpkin, not always
01:02:12 <mmorrow> e.g. at the top-level, if you had:
01:02:19 <mmorrow> foo :: A Int
01:02:22 <mmorrow> foo = A 4
01:02:27 <ddarius> mmorrow: A ! in the constructor means that the constructor is strict, if you replace the constructor, C, with id, well, id is strict.
01:02:32 <mmorrow> that would be the same as having a top-level !
01:02:46 <mmorrow> !foo = 4
01:02:51 <mmorrow> (top-level in a module)
01:02:54 <ddarius> No, that would mean A $! 4 so to speak.
01:03:22 <mmorrow> i'm not positive, but i think otherwise
01:03:25 <ddarius> There aren't "strict types" in Haskell (even with extensions)
01:03:36 <mmorrow> exactly! that's why it "isn't allowed"
01:03:42 <int80_h> @src myCycle
01:03:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:03:47 <int80_h> @src cycle
01:03:47 <lambdabot> cycle [] = undefined
01:03:47 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:03:59 <dobblego> @type foldr1
01:04:01 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
01:04:54 <ddarius> mmorrow: In data Foo = Foo !Int the !Int isn't a strict type anymore than A Int would be.  All the notation means is that Foo is strict in it's first argument meaning it Foo n gets translated into Foo $! n.
01:05:17 <int80_h> pumpkin: I forgot the code you wrote last night, on purpose. But I think it would be okay to see it again
01:05:27 <ddarius> For newtypes since the constructors get replaced by id, which is strict, there is no way to have a "lazy" newtype.
01:05:41 <pumpkin> int80_h:
01:05:42 <pumpkin> > let x = foldr (\x y -> x:y) x [1,2,3] in x
01:05:43 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
01:05:51 <mmorrow> but they don't get replace by id, they get replace by _nothing_
01:05:53 <pumpkin> I mean
01:06:03 <pumpkin> > let x = foldr (:) x [1,2,3] in x
01:06:04 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
01:06:14 <pumpkin> but that's just using the foldr because you told me to
01:06:21 <pumpkin> the foldr is doing very little
01:06:46 <ddarius> mmorrow: Which is semantically equivalent to replacing them with id also they do get replaced by id in cases like map A.
01:07:19 <ddarius> mmorrow: Incidentally, the Report describes the meaning of ! in a data declaration, -exactly- as I have (as I have just found out)
01:07:38 <mmorrow> ddarius: a data decl, or a newtype decl?
01:07:57 <ddarius> http://www.haskell.org/onlinereport/decls.html#sect4.2.1
01:07:57 <virkony> pumpkin: (++) will do something like foldr I think
01:08:04 <pumpkin> virkony: yeah :P
01:08:10 <ddarius> mmorrow: There are no ! in newtype declarations.
01:09:08 <int80_h> pumpkin: I see what I was doing wrong. thanks :)
01:09:15 <pumpkin> :)
01:09:26 <porges> just submitted a patch for GHC to get more unicode lubbing :D
01:09:31 <porges> trivial patches are grrreat
01:09:32 <pumpkin> yay
01:09:36 <pumpkin> what kind of unicode lubbing?
01:10:06 <mmorrow> ddarius: duh :)
01:10:14 <Peaker> given the many re-explanations of data and newtype here (many of them was me forgetting and reforgetting the difference :-) I just wrote a HaskellWIki entry about it: http://www.haskell.org/haskellwiki/NewType
01:10:40 <porges> pumpkin: all arrows that Arrows uses, and the kind star. I was trying to get some brackets to work but couldn't figure out the lexer completely
01:11:03 <mmorrow> ddarius: i can't find anything about newtypes at that link. anyways, let's postpone this until we (or at least i) have more info, because i'm not conviced of your side, and vice versa
01:11:07 <ddarius> Peaker: There already is a wiki entries.
01:11:07 <pumpkin> porges: nice :)
01:11:12 <Peaker> ddarius: where?
01:11:25 <ddarius> mmorrow: I was talking about data declarations, hence me saying "data declarations"
01:11:25 <Peaker> oh its case-sensitive :(
01:11:37 <ddarius> http://www.haskell.org/onlinereport/decls.html#sect4.2.3 This is the section for newtypes.
01:11:40 <Peaker> whoops
01:11:50 <Peaker> that's a waste of a whole 8 minutes :-P
01:11:59 <Peaker> damn, a wiki shouldn't be case-sensitive :-)
01:12:03 <ddarius> Incidentally, that section has a comprehensive description of the difference between all of these.
01:12:06 <mmorrow> ddarius: ok, i wasn't disputing your description of ! in data decls. i'm disputing your interpretation of what it would mean if ! was allowed in a newtype
01:12:36 <Peaker> can I delete my page?
01:12:39 <mmorrow> my stance is that allowing a ! in newtype decls would be equivalent to allowing top-level bangs.
01:12:56 <ksf> @ask conal May I try your new changes to reactive wrt. snapshot/event join/Time? I've just tested hackage-reactive w/ unamb 0.1.9 and ghc 090123, which changes behaviour but is indifferent wrt. lagging events
01:12:56 <lambdabot> Consider it noted.
01:12:58 <pumpkin> oh my, what's a NatTrans
01:13:02 <ddarius> mmorrow: I'm saying that if you have it mean the same as in a data declaration, which is the natural thing to do, than it's interpretation is redundant.
01:13:20 <pumpkin> @instances NatTrans
01:13:20 <lambdabot> Couldn't find class `NatTrans'. Try @instances-importing
01:13:28 <Peaker> how do I delete my redundant wiki entry? :P
01:13:40 <pumpkin> oh that's actually quite easy looking
01:13:53 <mmorrow> ddarius: cool, i'm interested to find out the issues here
01:14:01 <goalieca> ?src zip3
01:14:01 <lambdabot> zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
01:14:01 <lambdabot> zip3 _      _      _      = []
01:14:06 <ddarius> Read that section on newtype 4.2.3
01:14:48 <ddarius> Peaker: I don't think you can delete it yourself.  You could possibly make it redirect and otherwise make a note that it should be deleted.
01:14:59 <porges> ddarius: I think you're both saying the same thing
01:15:09 <pao> Peaker: whre is the "not your" newtype page?
01:15:24 <Peaker> pao: lower-case T
01:15:25 <porges> except mmorrow thinks that you wouldn't have it mean the same as in a data declaration
01:15:40 <mmorrow> yes
01:16:00 <ddarius> porges: If that's what he thinks, that's fine, but what would be the motivation of having it mean something different.
01:16:20 <porges> ddarius: because otherwise it doesn't do anything :P
01:19:16 <ddarius> porges: It's not even allowed now.  mmorrow hasn't given any explanation to what he thinks it should mean.  The only natural thing for it to mean is the same as it means for data declarations.  I see no point in positing a different meaning simply so it could be wrong.
01:19:44 <pumpkin> yay
01:20:12 <mmorrow> i think that it would mean the same thing that a top-level bang would mean, and as such isn't allowable for the same reason(s)
01:20:59 <mmorrow> and also, i'm not sure if it's possible to have it mean the same thing as in data-decls on account of the lack of a constructor at runtime
01:21:09 <ddarius> mmorrow: Top level bangs aren't Haskell 98 and how does top-level come into it.  What about f (A 3) or f x = 3 where A 3 = A 4?
01:21:40 <ddarius> mmorrow: The rewriting occurs long before run-time.
01:21:43 <mmorrow> ddarius: i've got to look up the exact reasons why top-level bangs aren't allowed to be able to take this further
01:22:39 <ddarius> mmorrow: Top-level bangs aren't Haskell 98 and unlikely have much in the way of formal description beyond the source of GHC.  However the reason they aren't allowed is obvious.  What does '!True = False; main = putStrLn "Hello World"' mean?
01:23:03 <mmorrow> !x = last [0..]
01:23:09 <pumpkin> :t scanl1
01:23:10 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
01:23:28 <ddarius> But what is special about the top-level, I can pattern match and apply newtype constructors anywhere.
01:23:42 <mmorrow> ddarius: that's what i'm not positive about yet
01:24:13 <mmorrow> i just got a hacked version of ghc to compile though (after 3+ hrs of bothing stuff), so i'm gonna disappear for now
01:24:18 <mmorrow> *botching
01:24:26 <int80_h> @hoogle isSpace
01:24:26 <lambdabot> Data.Char isSpace :: Char -> Bool
01:24:27 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
01:24:27 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
01:24:27 <ddarius> Also, the Report does not require that newtype constructors be replaced with nothing.  It would be completely legitimate to replace them with id when applied and with nothing when matched.
01:25:31 <mmorrow> ddarius: yeah, also i'm looking at this more from an operational pov
01:25:42 * mmorrow disappears
01:26:10 <int80_h> @src words
01:26:10 <lambdabot> words s = case dropWhile isSpace s of
01:26:10 <lambdabot>     "" -> []
01:26:10 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
01:31:14 <pumpkin> yay added more tests to uvector
01:31:43 <Peaker> how come Control.Monad has forM but not whileM?
01:32:31 <ddarius> forM isn't a for loop, it's just flip mapM
01:32:45 <Peaker> its a loop, in a sense
01:33:08 <ddarius> Agreed, but it isn't like what most programmers think of when they think "for loop"
01:33:22 <Peaker> @type let whileM cond act = do { x <- act ; if cond x then liftM (x:) $ whileM cond act else return [] } in whileM
01:33:23 <lambdabot> forall t (m :: * -> *). (Monad m) => (t -> Bool) -> m t -> m [t]
01:33:28 <ddarius> You can make a whileM function that's not like what most programmers think of when they think while loop.
01:33:30 <Peaker> @let whileM cond act = do { x <- act ; if cond x then liftM (x:) $ whileM cond act else return [] }
01:33:33 <lambdabot>  Defined.
01:34:01 <ddarius> Peaker: That's not tail recursive.
01:34:02 <Peaker> > whileM (<3) [1..10]
01:34:05 <lambdabot>   * Exception: stack overflow
01:34:40 <ddarius> Also, not very useful...
01:34:45 <Peaker> how do you make it tail-recursive?
01:34:49 <Peaker> why not useful? I found uses for it
01:35:11 <Peaker> getEvents = whileM (/=NoEvent) SDL.pollEvent
01:35:31 <ddarius> Most of the typical control structures in imperative languages rely on mutable state to be useful.
01:35:35 <pumpkin> I can define a functor on an array, can't I?
01:35:50 <ddarius> pumpkin: You should be able to.
01:36:01 <pumpkin> with fmap just being the array's map function
01:36:03 <Peaker> ddarius: well, IO is an imperative language
01:36:15 <Peaker> pumpkin: Data.Array has a Functor instance
01:36:18 <ddarius> Yes, but IO is only one monad.
01:36:27 <pumpkin> Peaker: I'm talking about UArr here though
01:36:31 <ddarius> For most monads, whileM makes no sense.
01:36:32 <Twey> 09:35:16 < Peaker> getEvents = whileM (/=NoEvent) SDL.pollEvent
01:36:34 <Peaker> ddarius: I don't know, but I suspect whileM will have meaning within other monads too
01:36:35 <Twey> Not very useful
01:36:39 <Peaker> Twey: why not?
01:36:45 <ddarius> Peaker: Indeed, e.g. State or Cont.
01:36:50 <Twey> Peaker: Because you have to match it against a case anyway
01:36:56 <Peaker> > whileM (<3) [1..5]
01:37:00 <lambdabot>   * Exception: stack overflow
01:37:06 <Twey> NoEvent would usually just end up in your _ case
01:37:28 <ddarius> Peaker: In that example, using the [] monad, act never actually returns something different.
01:37:30 <Peaker> Twey: But SDL lacks a function to poll _all_ events that are currently available
01:37:35 <Peaker> ddarius: true, yeah
01:37:52 <Eridius> man I really wish I had more of an excuse to play around with haskell. I have so much fun when I do play with it, but I don't have anything I can actually *do* with it :/
01:38:07 <Peaker> Eridius: anything you can program, you can program with Haskell..
01:38:07 <ddarius> Peaker: The same thing happens in most monads.  They have no way of returning different values for different calls of the same action.
01:38:08 <Twey> Eridius: No programming projects on hold at *all*?
01:38:22 <Eridius> all my programming projects are either for the iPhone or for desktop OS X
01:38:31 <Twey> So?
01:38:34 <Eridius> can't exactly write Cocoa using Haskell
01:38:39 <Twey> Can
01:38:46 <Twey> It's implemented in C, right?
01:38:53 <Eridius> Objective-C
01:38:56 <Peaker> Eridius: MacOSX can. and if you port ghc to the iPhone, you get to be a Haskell hero
01:39:02 <Twey> If there isn't a binding already, you should be able to make one
01:39:13 <Peaker> ddarius: Yeah. Well, its still useful for imperative monads :)
01:39:14 <Twey> Eridius: IIRC, the interface is in C, but Cocoa itself is written in plain C
01:39:18 <ddarius> Twey: There was one and I think it's seeing some current work.
01:39:20 <Twey> Er, is in ObjC
01:39:23 <Eridius> Peaker: well now, if I was willing to run a jailbroken iPhone then maybe that would be technically possible, but not with stock iPhone
01:39:32 <Peaker> Eridius: screw Apple :-P
01:39:36 <Twey> Haha
01:39:36 <Eridius> Twey: what do you mean by "the interface"?
01:39:47 <Twey> Eridius: The most commonly-used binding
01:40:07 <Eridius> ok apparently there is a Haskell/Obj-C binding but I have no faith that it actually works ;)
01:40:16 <Eridius> I know the OCaml/Cocoa binding is completely non-working
01:40:27 <Twey> Oh do you?
01:40:37 <ddarius> Peaker: Not useful enough.  As I said, such control structures tend to require mutation and thus are rather unpleasant to work with in Haskell.
01:40:37 <pumpkin> does anyone know where the Data.Array functor instance lives?
01:40:40 <Eridius> well, when I checked a few months ago
01:40:56 <Peaker> ddarius: how do you suggest I poll all available events in SDL? :P
01:41:16 <Twey> Peaker: I don't get what you mean by 'no function to poll all events'
01:41:44 <Twey> Peaker: Do you mean pumpEvents?
01:42:11 <Twey> If not, what type of event does pollEvent not get?
01:42:22 <Eridius> haha, the Haskell/ObjC bridge's last release was almost 5 years ago
01:42:32 <Eridius> yeah that sounds like it's going to work real well
01:42:33 <Peaker> Twey: no, I mean pygame
01:42:33 <Twey> Eridius: Well, maybe it's complete
01:42:35 <Peaker> Twey: oops
01:42:39 <Twey> Peaker: Ah :-P
01:42:39 <ddarius> Peaker: Usually direct recursion is easier to write than using such functions and other combinators even better if there's a nice combination handy.  I'm not saying whileM isn't great for this use-case, if you wrote it for this it probably is, I'm saying it isn't that useful as a general library function.
01:42:40 <Peaker> Twey: I mean pygame's pygame.event.getEvents()
01:42:42 <Eridius> Twey: that predates BridgeSupport even
01:42:42 <pumpkin>     Expected kind `* -> *', but `UArr e' has kind `*'
01:42:42 <pumpkin>     In the type `(UA e) => Functor (UArr e)'
01:42:48 <Twey> Heh
01:42:53 <thoughtpolice> Eridius: there's a more up to date version elsewhere
01:42:57 <thoughtpolice> that has support for e.g. leopard
01:42:57 <Peaker> Twey: I want to handle _all_ events 20 times per second, so I delay, and then I want to read all of them
01:42:58 <pumpkin> if I remove the UA e and make it Functor UArr where
01:42:59 <Eridius> thoughtpolice: oh? hrm
01:43:04 <pumpkin> ti gives me a different error
01:43:20 <pumpkin> because it can't deduce UA for mapU
01:43:26 <thoughtpolice> Eridius: the yi text editor currently has an actual working cocoa frontend iirc
01:43:29 <Peaker> ddarius: party pooper :-)
01:43:35 <Eridius> wait, yi works? :P
01:43:43 <thoughtpolice> Eridius: yes, very well. :]
01:43:46 <Eridius> last time I looked at yi a few months ago I couldn't figure out how to get it actually in a state where I could edit files
01:43:56 <Twey> GHC 6.2, zomg
01:43:56 <pumpkin> what am I doing wrong for this?
01:44:17 <Eridius> ahh, HOC went to Google Code
01:44:19 <ddarius> Peaker: Another problem is that you end up needing like 50 different slight variations for different things so it's not clear what the "right" one is (because none of them are right)
01:44:21 <thoughtpolice> Eridius: you can always write your own binding; there is an objective-C runtime interface which is primarily used for bridging languages to objective-c functionality
01:44:24 <Eridius> hrm, no downloads, no wiki
01:44:31 <Eridius> thoughtpolice: BridgeSupport
01:44:39 <pumpkin> anyone?
01:44:41 <ddarius> Peaker: For example, maybe I want a monadic predicate (t -> m Bool)
01:44:49 <Peaker> ddarius: that's what I started out with
01:44:54 <Peaker> ddarius: decided I'll write it when I need it
01:45:34 <Eridius> bahah HOC's svn repo has a CVSROOT
01:46:17 <pumpkin> why is it expecting kind * -> *?
01:46:29 <Peaker> pumpkin: where's the code?
01:46:39 <pumpkin> instance (UA e) => Functor (UArr e) where
01:46:39 <pumpkin>   fmap = mapU
01:46:53 <rainmann> @kind UArr
01:46:54 <Peaker> pumpkin: Functor's should be (* -> *) types
01:46:54 <lambdabot> Not in scope: type constructor or class `UArr'
01:47:09 <Peaker> pumpkin: What's UA?
01:47:22 <pumpkin> Peaker: the typeclass of valid elements that go into a UArr
01:47:41 <Peaker> pumpkin: Oh, then UArr is not a Functor. it maybe an RFunctor or such
01:47:47 <pumpkin> ack :/
01:47:57 <Peaker> pumpkin: fmap :: forall a b. (a -> b) -> ....
01:47:58 <pumpkin> but quickcheck wants it to be one :(
01:48:03 <Peaker> pumpkin: it can be any b, without restriction
01:48:08 <pumpkin> ah, I see
01:48:19 <pumpkin> makes sense
01:48:38 <Peaker> there's that RMonad thing, sounds similar, maybe there ought to be RFunctor like RMonad
01:48:44 <pumpkin> yeah, it does have one
01:48:52 <pumpkin> but then I need to get quickcheck to like it
01:49:01 <Peaker> why does QuickCheck want UArr to be a Functor?
01:49:10 <pumpkin> well, it wants a NatTrans on it
01:49:18 <pumpkin> which wants a functor
01:50:31 <pumpkin> any ideas?
01:54:02 <pumpkin> alright, I'm solving it another way
01:54:02 <Peaker> pumpkin: I don't know NatTrans, and haven't used QuickCheck much yet
01:54:13 <pumpkin> doing some of quickcheck's work for it :)
01:54:44 <ddarius> Why does quickcheck have a NatTrans type?
01:55:23 <pumpkin> because it loves categories
01:56:50 <pumpkin> I think it has something to do with it comparing equality between isomorphic types
01:56:54 <pumpkin> not a clue though, honestly
01:57:12 <Eridius> hrm, HOC just won't compile
01:57:57 <ddarius> :k UArray
01:57:58 <lambdabot> Not in scope: type constructor or class `UArray'
01:58:43 <Eridius> for example, HOC tries to import throwDyn from Control.Exception except it doesn't exist there
01:58:44 <ddarius> :k Data.Array.Unboxed.UArray
01:58:45 <lambdabot> * -> * -> *
01:58:51 <ddarius> Hmm
01:59:15 <pumpkin> ?
01:59:26 <ddarius> Eridius: The newest version of GHC has recently extensively changed the exception mechanism in non-backwards compatible ways.
01:59:44 <ddarius> Eridius: If you import Control.OldException it shouldn't have that particular problem.
02:00:03 <Eridius> ddarius: yeah I'm gonna have to change the source, but it looks like HOC is still being developed. There was a commit as recently as Jan 13th
02:00:17 <Eridius> I'm just kinda surprised it either hasn't been updated to fix this, or hasn't had a note placed somewhere to list this
02:00:17 <ddarius> Eridius: It just recently got picked up again.
02:01:19 <ddarius> Eridius: If the developers are still using 6.8 then they probably aren't personally intent on fixing it in the immediate future.
02:01:55 <Eridius> hmm
02:02:19 <ddarius> Eridius: You can alternatively change the .cabal file (if it uses cabal) to require >=base-3 <base-4 and it should also resolve that particular problem.
02:02:36 <Eridius> it's using ./configure,make,make install
02:02:48 <beelsebob> Eridius: interesting *goes and checks out HoC again*
02:02:55 <ddarius> If it doesn't use cabal you'll have to munge the GHC build flags to hide and expose the appropriate packages.
02:02:56 <Peaker> hmm.. I want a scoped existential quantification, I think :P
02:03:15 <ddarius> Peaker: What would be an unscoped existential quantification?
02:03:44 <Peaker> ddarius: well, you can't have exists a, so you have to put the forall on the inside of a big type, so the other parts of the big type can't see it
02:03:59 <Peaker> or at least, that's what I think - until I better understand my problem
02:04:13 <ddarius> Peaker: So you mean -actual- existential quantification.
02:04:34 <Eridius> hrm, unknown symbol `_setIvarInList'
02:04:43 <Eridius> that doesn't look like something easily-fixed
02:05:08 <ddarius> Eridius: Probably just a missing library or incorrect library paths.
02:05:20 <ddarius> Unknown symbols don't usually indicate broken code.
02:05:25 <Peaker> I am implementing a widget set.   My Widgets have an input-state (they get this from the outside and cannot change this), and input/output-state (this can be changed outside, but the widget can return a new state in its event handlers).
02:05:50 <Eridius> foreign import ccall "NewClass.h setIvarInList"
02:05:59 <Eridius> the question is where the symbol is supposed to be
02:06:07 <Peaker> I want my Box widget to have the list of child widgets in its input state, but the list of child widgets' state values in its own state
02:06:24 <pumpkin> any quickcheck experts around?
02:07:26 <Peaker> I can put the child widget list and the child widget state list together in the box's state, but I cannot separate them, because a widget and its state are two params to my "Widget" class
02:07:42 <Peaker> And my child Widgets' types are existentially quantified
02:09:18 <Eridius> ddarius: hrm, looks like the function setIvarInList got moved out of NewClass.m and yet the foreign import still declares it as NewClass.h
02:10:15 <Eridius> hrm, this just looks like far too much work to get building, oh well
02:10:27 <pumpkin> oh no, I got the dreaded less polymorphic than expected error
02:12:08 <int80_h> not that!
02:13:03 <ddarius> > ord :: (forall a b. a -> b)
02:13:04 <lambdabot>   Couldn't match expected type `a1' against inferred type `Char'
02:13:15 <pumpkin> aha, fixed it
02:13:33 <ddarius> :t let f :: (forall a b. a -> b); f = undefined in f ord
02:13:34 <lambdabot> forall b. b
02:13:42 <ddarius> :t let f :: (forall a b. a -> b) -> Int; f = undefined in f ord
02:13:43 <lambdabot>     Couldn't match expected type `a' against inferred type `Char'
02:13:43 <lambdabot>       `a' is a rigid type variable bound by
02:13:43 <lambdabot>           the polymorphic type `forall a b. a -> b' at <interactive>:1:55
02:17:59 <goalieca> ?src maximum
02:17:59 <lambdabot> maximum [] = undefined
02:17:59 <lambdabot> maximum xs = foldl1 max xs
02:19:05 <te> cool i just realized haskell uses do notation
02:19:08 <te> i love that from Ruby
02:19:15 <Twey> Uh
02:19:20 <Peaker> te: "do" notation is very unlike Ruby :P
02:19:23 <Twey> Haskell's do-notation is a bit more useful than Ruby's :)
02:19:23 <Eridius> te: uh, how does ruby use "do notation"?
02:19:30 <te> it looks similar
02:19:35 <Eridius> to what?
02:19:37 <te> do { myblock }
02:19:43 <Eridius> not at all related
02:19:52 <Eridius> and actually that's the wrong syntax for ruby anyway
02:20:04 <te> do { |a| myblock }
02:20:05 <te> sue me
02:20:14 <Eridius> still wrong. do myblock end
02:20:18 <Twey> Heh
02:20:18 <Eridius> or { myblock }
02:20:31 <te> fuck me running
02:20:33 <Eridius> anyway, the fact that ruby uses the "do" keyword to start a block is not related to the do notation in Haskell
02:20:41 <Twey> Not really, anyway
02:20:45 <te> so explain why
02:20:54 <Twey> There are situations in which it's kind of similar
02:21:01 <Eridius> pretty much the only connection is that they both establish a scope of sorts for computation
02:21:12 <te> i saw something like do { thisthing; thatthing; theotherthing; }
02:21:18 <ddarius> te: Why should they be?  They are totally different languages.
02:21:39 <Twey> forM_ [1, 2, 3, 4] \x -> do putStrLn ""; print x
02:22:11 <te> ddarius: of course a perfectly valid response is why shouldn't they be, they're both programming languages
02:22:13 <ddarius> forM_ [1 .. 4] $ \x -> putStrLn "" >> print x
02:22:22 <Twey> But Haskell's do-notation is a superset of Ruby's do-notation, for those Ruby uses which actually make sense in Haskell
02:22:37 <te> Twey: im trying to understand how they are different
02:22:45 <te> this is very vague language
02:22:49 <Twey> te: You should just think of them as being completely different.
02:22:53 * loadquo thinks using ambiguous key words is bad in both cases
02:22:55 <ddarius> te: Because syntax is superficial.
02:23:02 <Eridius> te: ruby's do notation establishes a closure. Haskell's do notation is just syntactic sugar around monad operations
02:23:11 <te> thank you
02:23:38 <Twey> Well, Ruby's do-notation is just syntactic sugar around lambda operations, IIRC
02:24:00 <te> same thing
02:24:16 <Eridius> well, it's "sugar" around { foo }, except { foo } could be called "sugar" around do foo end ;)
02:24:39 <Eridius> there's no underlying lambda operations you could do to avoid the syntax. If you use the proc or lambda keywords you still need to provide the { foo } part
02:24:59 <Eridius> also, ruby 1.8 actually has different behavior for blocks created with do/{} and blocks created with proc/lambda
02:25:03 <ddarius> te: Identifying two concepts in different languages (especially ones as different as Haskell and Ruby) simply because the notation is similar will not help you.  'class' in Haskell means nothing like what it means in most OO languages, similarly for 'return'  or '='.
02:25:09 <Eridius> namely in how it handles arity
02:25:33 <pumpkin> does quickcheck ever generate infinite lists as inputs?
02:25:39 <pumpkin> for the arbitrary list type
02:25:51 <ddarius> pumpkin: I doubt it very strongly.
02:25:56 <pumpkin> hmm ok
02:26:05 <te> ddarius: there are plenty of things that are similar to other languages
02:26:31 <luqui> pumpkin, nope.  I don't even know if Gen is lazy enough to do so.
02:26:43 <Peaker> te: There are plenty of things that *seem* similar, but are in fact not
02:26:46 <ddarius> te: Indeed, but until you know which those are, it's best to be careful.
02:26:56 <te> ddarius: fair enough
02:27:04 <pumpkin> what does TestExhausted mean in quickcheck?
02:27:14 <pumpkin> it ran out of time or something?
02:27:18 <luqui> code is not brain surgery.  -- or when it is, you're not going to be doing it in a language you are uncomfortable with
02:27:26 <luqui> there is no reason to "be careful"
02:27:34 <luqui> fall hard, learn it well :-)
02:27:37 <te> ill defintely agree wit that too
02:27:39 <te> with
02:27:44 <te> fail = learn
02:27:53 <pumpkin> isBottom :: a -> Bool
02:27:54 <pumpkin> :P
02:27:58 <pumpkin> I like that function
02:28:02 <Peaker> ;-)
02:28:09 <pumpkin> hey, it's in quickcheck
02:28:11 <Twey> There aren't many similarities with a language like Ruby, really...
02:28:12 <luqui> it's so obviously impossible :-)
02:28:19 <te> Twey: that's not the point
02:28:19 <pumpkin> it's in quickcheck!
02:28:42 <ddarius> luqui: The issue isn't writing code that doesn't work, it's getting wrong ideas into your head.  While you can still learn from it, it will probably take longer than not having the wrong notions in the first place, especially as some cases are rather subtle.
02:28:50 <te> I'm sure many people who write lisp or haskell, etc. -- think about their code in many different ways
02:29:20 <luqui> ddarius, perhaps.  I find I learn best with experiences.  If I can observe how something works, I learn much faster and more easily than being told.
02:29:35 <luqui> but yeah, I guess that doesn't mean to assume I know how it works before I've seen it.
02:30:11 <te> luqui: thats how im learning haskell right now -- ive spent the better part of hour running :info and failing over and over
02:30:15 <te> but eventually something will fall into place
02:30:41 <te> and yes ive done some of the requisite reading on category theory and monads, but sometimes you gotta break a few eggs
02:30:50 <luqui> lol, category theory
02:30:53 <luqui> to learn haskell.
02:31:01 <luqui> not really necessary :-)
02:31:10 <Twey> I wouldn't say it was 'requisite'...
02:31:16 <ddarius> Reading about category theory and monads isn't going to help you.  Read (part of) a tutorial and do the exercises in it.
02:31:17 <Twey> I guess it can help, if you're doing advanced stuff...
02:31:23 <Peaker> te: I don't know almost any category theory (the little I do know is from eavesdropping on people talking about CT here)
02:31:28 <Twey> But yeah, learn the basics first
02:31:29 <luqui> I find Haskell helps me learn category theory.
02:31:30 <Twey> RWH FTW :)
02:31:35 <Twey> I agree with luqui.
02:31:38 <ddarius> You need to have some basis to even begin.  I remember the first time I tried to program.
02:31:53 <Eridius> ddarius: possibly, but certainly not formalized
02:31:54 <ddarius> I couldn't even write "Hello World" because I had no idea what the first step would be.
02:31:59 <Eridius> I'm still not certain what "category theory" is ;)
02:32:04 <Peaker> ddarius: what language was that?
02:32:06 <Twey> The first time I tried to program involved several months typing out and fiddling with examples without really understanding them
02:32:13 <te> Eridius: it's the theory of categories
02:32:14 <te> ;)
02:32:23 <luqui> Eridius, generalized abstract nonsense isn't precise enough for you?
02:32:28 <Twey> Haha
02:32:32 <ddarius> Eridius: Some basis for programming (in Haskell) as you would get from a tutorial, not in category theory as I said reading about them won't help you at all.
02:32:33 <Eridius> luqui: naw, that's good enough. hence why I haven't researched it
02:32:47 <ddarius> Peaker: QBASIC
02:32:48 <int80_h> given this constructor "data JValue = JString String", how would I bind foo, of type JString to, say "test"
02:32:53 <Peaker> Eridius: I think an informal intuition to what it is - is a general notation to describe mathematical concepts in a uniform way, so that seemingly different mathematical fields might get described in the same way, establishing isomorphism between them and gaining insight from one over the other
02:32:57 <te> there are some really good monad tutorials that teach haskell along the way fyi
02:33:11 <Peaker> Eridius: but I may be wrong :P
02:33:14 <int80_h> I thought this was right but, no "let Jstring:foo = "test"
02:33:18 <te> reading code, regardless of how hard or easy it is
02:33:19 <luqui> int80_h, you mean like:  foo = JString "test"
02:33:19 <Eridius> Peaker: that sounds like a pretty good description to my uninformed ears
02:33:20 <te> cant hurt
02:33:30 <Eridius> Peaker: so this describes things like Fields, right?
02:33:30 <ddarius> Peaker: I could start the interpreter, but didn't even know that I was supposed to "write" code, let alone what code to write.
02:33:32 <int80_h> luqui: that's it
02:33:47 <Peaker> ddarius: ah, I had a bit of guidance from others
02:34:05 <int80_h> if it wasn't for this channel and the mailing lists, I wouldn't even try to learn haskell
02:34:12 <int80_h> feedback is so important
02:34:14 <ddarius> Peaker: Well when I tried again, I did do it with someone else (who was barely any further than me) and now I'm here.
02:34:23 <luqui> int80_h, remember that JString is just a function.  JString :: String -> JValue
02:34:25 <pumpkin> does anyone know how I can get quickcheck to generate two random lists of the same length?
02:34:25 <Twey> You get feedback from GHCi :-P
02:34:40 <pumpkin> I have a condition on the length for now, but too many lists fail
02:34:48 <pumpkin> and quickcheck says it's exhausted (and I don't blame it!)
02:34:55 <int80_h> luqui, Jstring is a function? a constructor is a function?
02:35:03 <luqui> int80_h, yes.
02:35:20 <int80_h> okay, I'll just accept that
02:35:26 <luqui> well, it's a function that can also be applied backward in patterns.  but outside of patterns, it works just like a function.
02:35:33 <luqui> takes a String, returns a JValue with that string.
02:35:51 <Twey> te: Monads are simple.  Haskell is complex.  If you're learning Haskell from a monad tutorial, you're Doing It Wrong©.
02:36:08 <Twey> It's like learning C from an introduction to basic arithmetic
02:36:17 <luqui> Twey++
02:36:18 <te> Again, I don't really think you have the authority to tell me how to learn.
02:36:22 <luqui> Haskell /= monads
02:36:44 <te> I play.  I will do tutorials when I feel like it.  For now, I'm getting a picture of the landscape.
02:36:46 <beelsebob> te: no, but he can tell you whether what you're learning is haskell or not
02:36:50 <luqui> te, I think even if he claimed to, you would not abide :-)
02:36:54 <Twey> Heh
02:36:57 <beelsebob> and learning monads is not learning haskell
02:37:08 <te> oh for fuck's sake
02:37:12 <Twey> 'Not even if Oleg came down and said it was true...'
02:38:06 <te> "learning monads is not learning haskell" sounds to me like the same old "programming is not math", which of course i agree with, but introducing yourself to math as a result of programming is not something that anyone should teach you to avoid
02:38:33 <Twey> te: Unfortunately it's not a parallel
02:38:34 <beelsebob> te: actually programming *is* maths
02:38:40 <beelsebob> >.>
02:38:41 <te> orly
02:38:45 <ddarius> beelsebob: Part of.
02:38:54 <Twey> Monads (as used in Haskell) are a much smaller field than maths
02:39:14 <Twey> Like I said, it's more like basic arithmetic
02:39:48 <te> I just feel like this idea that I can't play with category theory because it somehow violates the idea of learning Haskell is just a load of garbage
02:39:58 <Twey> And that's not to say that it's not useful to understanding Haskell, just as arithmetic is (very) useful to understanding programming in general, but it's not the whole
02:39:59 <ddarius> te: And no one has told you not to learn about monads, but that learning about them isn't learning about Haskell.  Just like if you want to program, learning math isn't going to teach you it.  It may be helpful, but you'll eventually need to learn to program.
02:40:01 <Twey> te: I didn't say that
02:40:08 <Twey> Right
02:40:38 <Twey> There's nothing wrong with learning about monads (or category theory), but you can't really pick up all of Haskell via it
02:40:56 <loadquo> Te, there are two different ways to program haskell. The monadic way is one, it covers stateful programs, the other one is pure, and has lots of its own idiosyncrasies, point-less code etc.
02:41:01 <Peaker> te: nobody said you can't, just that you don't have to
02:41:25 <Peaker> te: its neither necessary or sufficient to learn CT, if you want to learn Haskell :)
02:41:28 <Twey> There's also study to do that focuses on Haskell specifically, and there's a lot more of it than monad- or category-theory–specific study
02:41:31 <ddarius> Nobody has actually told te to do or not do anything, or that he can or can't do anything.
02:41:36 <Twey> It is useful, though.
02:42:06 <Twey> (category theory is useful; monads are *vital*)
02:42:36 <ddarius> Well I guess my statement isn't completely accurate.
02:43:10 <te> Nod -- I guess I just feel like the general feeling towards learning CT etc. is "oh, you don't have to do that" -- which I guess seems like kind more of a negative than a positive
02:43:13 <te> IMHO
02:43:15 <Peaker> loadquo: most monads are pure and not stateful, and useful in pure programs
02:43:33 <ddarius> te: You don't "have to" do that, is not "don't do that"
02:43:47 <Peaker> te: indeed it is. There's this weird notion out there that because Haskell burrowed some terminology from CT, its a necessary precondition to learning or understanding Haskell
02:43:56 <pumpkin> yay, I wrote a custom generator and now my test passes!
02:44:11 <Peaker> pumpkin: it fails with the arbitrary inputs?
02:44:11 <te> Peaker: yeah I can see that being an issue
02:44:25 <loadquo> Peaker: True, I couldn't think of a good way of distinguishing between the types of code that used do all the time and the types of code that just used lists.
02:44:25 <pumpkin> yeah, it's sort of supposed to
02:44:27 <te> Peaker: The truth is I've just been very interested in math lately and I've been diving into new stuff I find, when I find it
02:44:58 <Peaker> loadquo: "do" is useful on lists, Maybe, etc too :)
02:45:03 <te> so I feel kind of like "hey, mind your own business", when someone tells me "oh, you don't have to do that" -- it's like: "yeah, i don't have to learn haskell either, but i am"
02:45:27 <Peaker> loadquo: just distinguish by monad type -- IO, ST, State, StateT, etc
02:46:09 <ddarius> te: What people have been saying is "you don't have to learn category theory -to learn haskell-".  No one has told you not to or even that you don't have to (you might for a class say), just, as Peaker said, that it is not a prerequisite.
02:47:21 <te> i think maybe underlying this whole discussion is a personal desire for category theory to in fact, be a pre-requisite
02:47:28 <loadquo> Peaker: Heh I don't know what all the monad types yet :P
02:47:29 <te> i think its cool to learn all of the elegant shit
02:47:36 <Peaker> I could deduce: Python is obscure, you need to learn Haskell to understand Python, because Python burrows list comprehensions from Haskell. And we all know you need to be a Category Theory guru to even write Hello World in Haskell" :-)
02:47:56 <ddarius> te: Fortunately for most, it is not for Haskell.  Not that that keeps you from learning it anyway.
02:48:15 <int80_h> te: example?
02:48:27 <te> int80_h: ?
02:48:39 <beelsebob> te: unfortunately, what monads are used for mostly are about the least elegant bits of haskell code
02:48:43 <int80_h> te: I mean, can you give me an example of a monad tutorial that teaches haskell along the way?
02:49:31 <te> int80_h: I think what I was getting at is that reading code, regardless of how high or low level it might be, teaches you stuff
02:49:35 <te> by osmosis
02:49:52 <ddarius> beelsebob: While monads are actually reasonably elegantly applied in Haskell (though in many cases not elegant Haskell), few of the application of category theory to Haskell are elegant examples of category theory.
02:51:11 * pumpkin loves seeing the HPC bars go up
02:51:21 <ddarius> pumpkin: hpc rocks
02:51:31 <int80_h> te: oh wehen you made the statement that there's lots of monad tutorials that teach you haskell along the way, I was hoping to learn about them. I've never heard of those.
02:51:51 <int80_h> the monad tutorials I know of, assume you know haskell already
02:51:57 <ddarius> pumpkin: Though I haven't used it much (but then I haven't done too much Haskell development since it was created), I think it is a crucial ingredient connecting tests and code.
02:52:21 <pumpkin> yeah, it really is nice
02:53:14 <ddarius> hpc tells you what tests to add and which tests are useful as well as giving you a meaningful "green bar"
02:53:23 <dpowers> does anyone know if there as a haskell equivalent to OCaml's include for re-exporting a set of functions and types from a new module?  Or do you have to explicitly re-bind everything you want to re-export?
02:53:41 <ddarius> dpowers: You can just export the module that you imported.
02:54:46 <Eridius> hrm, http://sigfpe.blogspot.com/2009/01/haskell-monoids-and-their-uses.html is an extremely good article about Monoids
02:54:55 <Eridius> (this article is why I'm itching to play with Haskell again)
02:55:07 <Eridius> actually, it's the haskell subreddit's fault ;)
02:56:12 <ddarius> Hmm, it turns out you can even export the module you're defining.
02:56:14 <dpowers> ddarius: Does that have to be explicit?  If I don't hide anything (module Foo where...) and then import something else (import  UI.HSCurses.Curses (Key(..))) should I expect to be able to refer to Foo.Key if I import Foo somewhere else (qualified in this case of course)
02:57:04 <dpowers> ddarius: I basically want to simplify and generalize and existing interface, and want to re-export a subset of the types
02:57:12 <ddarius> dpowers: I think in the no export list case, all identifiers that are in scope in Foo are exported, but you can test this.  If not, module Foo (module Foo, module Bar) would work.
02:57:42 <dpowers> the base case doesn't seem to work, I'll try the explicit export
02:59:11 <dpowers> interesting... module Input where doesn't work, module Input (module Input) where doesn't work, but module Input (module Input, Key(..)) where does
02:59:36 <ddarius> Well the second one means only export the definitions locally defined in module Input.
02:59:40 <dpowers> It would appear that GHC doesn't export unqualified imports unless specified
02:59:43 <dpowers> right
02:59:49 <ddarius> I guess the first one is equivalent to the second one.
02:59:50 <Peaker> ghc has some bugs in its import handling
02:59:57 <dpowers> the first and the second should be the same - just testing
03:00:13 <dpowers> Peaker: really?
03:00:19 <Peaker> dpowers: at least, warning bugs
03:00:50 <Peaker> If you import two modules, one qualified and one unqualified, and use qualified symbols that all exist in the unqualified import, then you'll get a warning that the qualified import is not used
03:01:14 <dpowers> fascinating.  I wonder if this behavior (not exporting unqualified imports) is part of the standard
03:01:44 <ddarius> dpowers: Here's the section of the Report: http://haskell.org/onlinereport/modules.html
03:02:09 <ddarius> "If the export list is omitted, all values, types and classes defined in the module are exported, but not those that are imported."
03:03:00 <dpowers> "If the export list is omitted, all values, types and classes defined in the module are exported, but not those that are imported."
03:03:01 <dpowers> heh
03:03:05 <dpowers> yep, thanks
03:03:16 <Eridius> that makes sense. If I write a small module and want to export all 3 of my functions defined within, but I use Data.Foldable, I probably don't want to expose the Data.Foldable
03:05:03 <dpowers> Eridius: perhaps more importantly, Prelude is imported by default into all modules
03:05:38 <dpowers> Now I just need to long for something that behaves more like an mli...
03:07:10 <ddarius> dpowers: It's possible that you could abuse hs-boot files to that end.
03:07:28 <dpowers> hs-boot files?  Something new...
03:07:58 <ddarius> dpowers: GHC doesn't fully support recursive modules, instead you have to make hs-boot files to clarify recursive dependencies.
03:08:22 <dpowers> interesting... poor man's module interfaces
03:08:50 <dpowers> to be fair, I probably shouldn't be focused on hammering haskell modules into ML modules - strictly different beasts
03:09:09 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
03:09:27 <ddarius> You can hammer ML modules into Haskell classes though.
03:10:13 <dpowers> ddarius: it's messy, but you can indeed
03:10:51 <dpowers> ML modules are great
03:14:49 <L-Spiro> I was supposed to read this file as input via stdin.  What does that mean?
03:15:11 <luqui> ddarius, really?  You know of an automatic (not necessarily automated) method to do so?
03:15:21 <L-Spiro> What is the difference between that and readFile?
03:15:38 <Heffalump> stdin is the standard input of your program
03:15:43 <Heffalump> readFile reads from a file on disk
03:16:02 <luqui> L-Spiro, in unix, every program comes with a standard input, which is where stuff you type at the console goes   (or stuff you pipe from other programs, etc.)
03:16:21 <L-Spiro> I thought Haskell did not have that.
03:16:35 <luqui> @hoogle stdin
03:16:35 <lambdabot> System.IO stdin :: Handle
03:16:54 <luqui> L-Spiro, getContents, getLine, etc.  all work on stdin.
03:17:43 <doserj> @src getContents
03:17:44 <lambdabot> getContents = hGetContents stdin
03:18:40 <luqui> I do love how lambdabot is a major participant in most explanatory discussions
03:19:33 <Twey> Heheh
03:19:45 <Twey> That's because Haskell code is self-explanatory
03:20:05 <Eridius> only if you can read it ;)
03:21:53 <Peaker> IMO: Haskell's readability is much more a function of learning curve than Python.  Prior to all learning -> Python pretty readable, Haskell not.  After learning both languages well -> Python much less readable than Haskell
03:22:10 <Peaker> this is Python's appeal
03:22:42 <Peaker> such is the nature of general code, though, its pretty inherent that more general, useful code that Haskell encourages will take more learning to understand than code very specific to one use case
03:23:42 <luqui> Peaker, usually understanding python code does not have a field of mathematics as a prerequisite.
03:24:08 <Peaker> I thought we covered that already :)
03:24:17 <luqui> shhh
03:24:39 <Peaker> btw, its more a matter of culture. You can write general code in Python, and specific code in Haskell, and then the learning curve -> readability curve reverses
03:25:14 <luqui> yeah I agree with that.  Nobody understands my C# code, because I use monads anyway :-)
03:25:43 <luqui> Ever since C#, my C# is just haskell with more verbose syntax.
03:25:47 <luqui> er, C# 3.0
03:25:50 <Peaker> C# does impair your ability to write general code, though, because its type system is not strong enough. Python's lack of typing makes genericity possible (if painful)
03:26:05 <Peaker> s/strong/powerful
03:26:15 <Peaker> Strong typing means something else, I meant powerful type system
03:26:18 <int80_h> genericity? that's a word?
03:26:21 <luqui> Peaker, it's type system is fine.   It doesn't have existential types, which has tripped me once or twice
03:26:33 <luqui> but other than that it works great for the job.
03:26:44 <Peaker> luqui: sure C# has existential types - whenever you get a "subclass of.."
03:26:47 <Twey> Monads in C#?
03:27:06 <Twey> You have an IMonad?  :-P
03:27:20 <int80_h> Twey: isn't that a new piece by Yo Yo Ma?
03:27:24 <luqui> Peaker, oh, I mean locally existential types.  The equivalent of, say, forall c. [(a,c)] -> [(b,c)]
03:27:33 <Twey> Hahaha
03:27:59 <L-Spiro> I have a list of string pairs (String,String) where the first string is a category and the second an entry in the category.
03:28:06 <luqui> the Linq Select method is just monadic bind.  :-)
03:28:19 <Twey> Ho?
03:28:23 <L-Spiro> I need to sort all the items under a given category.  Any clues?
03:28:24 * Twey makes a note.
03:28:40 <Peaker> @type (map fst &&& map snd)
03:28:41 <int80_h> sounds like homework
03:28:41 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
03:29:00 <Twey> L-Spiro: map sort `on` snd . groupBy (comparing fst)
03:29:02 <luqui> homework is fine.  just people be careful not to start golfing the solution.
03:29:08 <Twey> Heheheh
03:29:08 <luqui> Twey, noooo!
03:29:14 <int80_h> golfing?
03:29:19 <L-Spiro> It is not homework.
03:29:27 <Twey> Golfing homework solutions FTW <3
03:29:32 <Twey> But no, doesn't sound like homework to me
03:29:37 <luqui> int80_h, making as short as possible.
03:29:53 <int80_h> luqui: ah gotcha
03:30:07 <luqui> (in this channel, it's a balance between shortness and elegance.  it started in perl culture, where it is just shortness because elegance was thrown out long ago)
03:30:22 <Twey> L-Spiro: map (sortBy $ comparing snd) . groupBy (comparing fst)
03:30:24 <L-Spiro> So did I get multiple answers?
03:31:02 * Twey turns to GHCi.
03:31:15 <int80_h> luqui: don't get me started. my response to the Perl creed is, "Just because you can doesn't mean you should."
03:31:42 <luqui> L-Spiro, so you need to sort all the items in a single given category, or do you need to sort them all?
03:32:06 <L-Spiro> If I sort both categories it would probably be fine.
03:32:07 <Axman6> argh, perl is so lame >_<
03:32:11 <luqui> int80_h, I actually have a fair amount of respect for perl.  It was my culture before Haskell.
03:32:29 <luqui> they are just using a completely different fitness function than we are
03:32:34 <joga> I wish I knew perl, it's nice glue
03:32:51 <Twey> map (sortBy $ comparing snd) . groupBy ((==) `on` fst) . sortBy (comparing fst)
03:32:53 <Twey> L-Spiro:
03:32:54 <L-Spiro> Twey, I don't really understand the solution (which is one of my goals, not just copying).
03:33:28 <luqui> L-Spiro, why don't you organize the data more, so that the solution becomes obvious
03:33:41 <L-Spiro> Organize it verbally?
03:33:41 <luqui> i.e. you have [(String,String)], why don't you massage that into [(String, [String])], for example
03:33:48 <Twey> First, sort them so the categories are next to one another (based on the first value in the pairs); then, group them all together; then, sort the individual categories
03:33:58 <luqui> L-Spiro, or better yet, Map String [String]
03:34:19 <L-Spiro> Because I have used Haskell for a total of 4 hours and I do not have free reign when it comes to implementing my own ideas.
03:34:24 <Twey> luqui: What fitness function is that?  :-P
03:34:43 <L-Spiro> I planned on using map since it goes over the whole list.
03:34:43 <Twey> L-Spiro: Read it backwards.  Think of the dots as full-stops.
03:35:08 <luqui> Twey, one of the big ones "naturality" of reading the code, when compared to english and perl culture (it's a bit recursive :-)
03:35:11 <L-Spiro> And I know to compare with snd on each (and on fst, why not).
03:35:32 <pao> Hi all, I'm reading RWH Chapter on FFI... I wonder why a Bytestring is used to represent the regex expression... ByteString cannot represent Unicode Char (Haskell Char), it can only represent Char8 char... isn't that a poor choice?
03:35:38 <luqui> L-Spiro, I would use Data.Map.
03:35:55 <L-Spiro> luqui, you are saying make one category with its strings all under it in a list right?
03:36:07 <Twey> That's what the latter two do
03:36:07 <luqui> yeah.
03:36:16 <Axman6> pao: if it's being used with the FFI, you've got to go with C strings no?
03:36:23 <L-Spiro> That was my original plan but I did not know how.
03:36:41 <luqui> :t Map.fromList
03:36:43 <lambdabot> Couldn't find qualified module.
03:36:46 <luqui> :t Data.Map.fromListBy
03:36:48 <lambdabot> Not in scope: `Data.Map.fromListBy'
03:36:49 <L-Spiro> It does it automatically?
03:36:50 <luqui> :t Data.Map.fromListWith
03:36:51 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
03:36:54 <luqui> there we go
03:37:10 <pao> Axman6: that is the haskell API... what if I wanted to express a regex "è*" ?
03:37:17 <luqui> eg:
03:37:25 <Twey> "groupBy ((==) `on` fst) . sortBy (comparing fst)" makes [[("a", 1), ("a", 3), ("a", 2)], [("b", 1)]] of [("a", 1), ("b", 1), ("a", 3), ("a", 2)]
03:37:55 <luqui> > Data.Map.fromListWith (++) [("x", ["a"]), ("y", ["b"]), ("x", ["c"]), ("y", ["d"])]
03:37:56 <lambdabot>   /tmp/8213391808070390940:70:32:
03:37:56 <lambdabot>      Not in scope: `Data.Map.fromListWith'
03:38:02 <Axman6> [that's not unicode is it?
03:38:04 <Axman6> pao*
03:38:05 <luqui> > Map.fromListWith (++) [("x", ["a"]), ("y", ["b"]), ("x", ["c"]), ("y", ["d"])]
03:38:06 <lambdabot>   fromList [("x",["c","a"]),("y",["d","b"])]
03:38:22 <luqui> L-Spiro, ^^   then you can Map.map sort  over that
03:38:26 <Twey> pao: Don't forget that regex provides unicode \uXXXX escapes
03:38:55 <L-Spiro> I have this:  [("NUMBERS","six"), ("NUMBERS","three"), ("NUMBERS","four"), ("ANIMALS","horse")] etc.
03:38:55 <Twey> (was it \uXXXX?  I don't recall... it's something, anyway)
03:39:03 <Twey> L-Spiro: Right
03:39:22 <Twey> Oooh, Map.fromListWith
03:39:26 <Twey> <3
03:39:39 <Peaker> hmm, http://haskell.pastebin.com/d3f871b4b
03:39:44 <L-Spiro> Map.fromListWith is what I need?
03:39:46 <luqui> L-Spiro, exactly.  stick that in a Data.Map and use that instead of your list.
03:39:51 <L-Spiro> His input is different from mine.
03:39:52 <Peaker> it complains that my do does not end with an expression, but it does
03:39:54 <luqui> it is designed for this kind of thing
03:39:59 <luqui> L-Spiro, only barely
03:40:19 <luqui> > map (second (:[])) [(1,2),(3,4),(5,6)]
03:40:20 <lambdabot>   [(1,[2]),(3,[4]),(5,[6])]
03:40:20 <Twey> L-Spiro: Working on your existing data, then, you can do Map.fromListWith (++) . map (\(x, y) -> (x, [y]))
03:40:22 <pao> Twey: by regex what do you mean? pcre? various haskell regex implementations?
03:40:25 <Twey> Or you can alter the existing data
03:40:31 <Twey> Ah, second, that's what I was looking for
03:40:34 <Peaker> oh, missing () around lambda, weird error to generate!
03:40:36 <Twey> pao: Most of them, I think
03:40:51 <luqui> L-Spiro, second applies a function to the second element of a pair.  (:[])  is a function that puts an item into a singleton list.
03:41:13 <luqui> L-Spiro, if it helps, you could expand the lambdas:
03:41:19 <Peaker> @hoogle singleton
03:41:20 <lambdabot> Data.ByteString singleton :: Word8 -> ByteString
03:41:20 <lambdabot> Data.IntMap singleton :: Key -> a -> IntMap a
03:41:20 <lambdabot> Data.IntSet singleton :: Int -> IntSet
03:41:30 <pao> Twey: that's the point... I think it would be nice to have a WCharString, internally in UTF16 or UTF32
03:41:31 <Peaker> @type Data.List.singleton
03:41:31 <luqui> > map (\(key,value) -> (key, [value])) [(1,2),(3,4),(5,6)]
03:41:33 <lambdabot> Not in scope: `Data.List.singleton'
03:41:33 <lambdabot>   [(1,[2]),(3,[4]),(5,[6])]
03:41:44 <pao> Twey: just like C has wchar_T
03:41:46 <Twey> Peaker: That's 'return'
03:41:55 <Peaker> Twey: I know, was wondering if it was consistent :)
03:42:04 <luqui> yeah, there really should be a Data.List.singleton shouldn't there!?
03:42:06 <Twey> pao: Haskell Char is wide
03:42:15 <Twey> It's just the bytestring that isn't
03:42:16 <L-Spiro> Failed to load interface for Map.
03:42:19 <L-Spiro> I am trying at Prelude.
03:42:20 <Twey> (since it deals in, well, bytes)
03:42:28 <luqui> As neat an funny and idiomatic as (:[]) or return are, they're not really self-explanatory
03:42:41 <pao> Twey: yep... but usually in APIs  ByteString is used instead of String
03:43:17 <pao> Twey: ... and it's used when a "text" is expected not bytes ... :-(
03:43:24 <Twey> pao: Well that's silly
03:43:29 <Twey> ByteString is really for binary data.
03:43:32 <luqui> bytestring-utf8!
03:43:38 <L-Spiro> > Map.fromListWith (++) [("NUMBERS","six"), ("NUMBERS","three"), ("NUMBERS","four"), ("ANIMALS","horse")]
03:43:39 <lambdabot>   fromList [("ANIMALS","horse"),("NUMBERS","fourthreesix")]
03:43:42 <Twey> What the heck's up with that :(
03:43:52 <Twey> Can't you just have a string to interpret it later?
03:43:52 <L-Spiro> That's a problem.
03:44:11 <luqui> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
03:44:15 <Twey> L-Spiro: You forgot the robot monkey operator
03:44:35 <Twey> > Map.fromListWith (++) . map (second (:[])) $ [("NUMBERS","six"), ("NUMBERS","three"), ("NUMBERS","four"), ("ANIMALS","horse")]
03:44:36 <pao> luqui: that forces you to go back and forth explicitly (fromString, toString)
03:44:37 <lambdabot>   fromList [("ANIMALS",["horse"]),("NUMBERS",["four","three","six"])]
03:45:07 <luqui> pao, huh?  you want it to be implicit?  or what?
03:45:24 <L-Spiro> > Map.fromListWith (++) . map (second (:[])) $ [("NUMBERS","six"), ("NUMBERS","three"), ("NUMBERS","four"), ("ANIMALS","horse"), ("ANIMALS","horse")]
03:45:25 <lambdabot>   fromList [("ANIMALS",["horse","horse"]),("NUMBERS",["four","three","six"])]
03:45:55 <pao> luqui: it would be nice to have a ByteString library (with its performance merits) that could map the internal representation of a C wchar_t
03:46:05 <pao> *wchar_t
03:46:17 <luqui> pao, oh you're doing FFI stuff?
03:46:23 <pao> luqui: yep :-)
03:46:28 <luqui> okay fair enough :-)
03:47:21 <pao> luqui: but that's not the problem really... what I see is the use of ByteString in place of String... for text api... that's bad!
03:47:24 <L-Spiro> My function categorise parses the file and returns the list.  To save it I would do this: myList = categorise "" xs  right?
03:47:25 <Eridius> oww my brain. I should know better than try to read the 2-3 fingertree paper when I don't know anything about 2-3 trees or fingertrees
03:47:32 <L-Spiro> I can't declare a list type.
03:48:05 <L-Spiro> Nope.
03:48:31 <luqui> pao, yeah, if the API doesn't explicitly consume utf-8 bytestrings, I agree.
03:48:41 <L-Spiro> If categorise returns a list (which I want to convert to this map) how do I save it to a "local"?
03:49:05 <luqui> like:
03:49:10 <luqui> > let x = 42 in x + 1
03:49:11 <lambdabot>   43
03:49:17 <luqui> is that what you're talking about?
03:49:23 <L-Spiro> Let me see.
03:49:38 <pao> luqui: I think implying an encoding for text manipulation is bad as well :-)
03:49:50 <L-Spiro> Yes.
03:50:05 <luqui> pao, so you think there should be an API for strings that have a bytestring bundled with an encoding?
03:51:19 <luqui> wchar_t is typically only 16 bits anyway right?  that's not good enough.
03:51:23 <pao> luqui: yep, I think so. I think the encoding (internal representation) should match the corrisponding system encoding of wchar_t
03:51:35 <pao> luqui: it depends on the platform
03:51:46 <pao> luqui: on windows I think it's 16 bit
03:51:50 <luqui> well then depending on the platform, it's not good enough :-)
03:52:05 <L-Spiro> Map.fromListWith is not in scope.
03:52:10 <L-Spiro> import MAP?
03:52:14 <Peaker> sometimes I catch myself getting something to compile for a while, then writing a test program for 5 minutes, then it works obviously, and then "Why do I bother testing it? If it compiles, it works!" :-)
03:52:18 <luqui> L-Spiro, import qualified Data.Map as Map
03:52:46 <L-Spiro> second also not in scope.
03:52:47 <L-Spiro> snd?
03:52:54 <Twey> L-Spiro: No
03:52:56 <Peaker> L-Spiro: Control.Arrow(second) probably
03:52:59 <luqui> pao, I think a nice string API that hides encoding fairly well, provides conversion functions, and ensures consistency would be very nice
03:53:10 <Twey> L-Spiro: import Control.Arrow (second); import qualified Data.Map as Map
03:53:25 <luqui> pao, don't lock into wchar_t, because of its deficiencies.  Instead allow multiple encodings, but without allowing people to fuck it up :-)
03:53:35 <nikki_> Sup guys! :D
03:53:39 <Peaker> L-Spiro: first/second are pretty cool :-)  When combined with each=map, result=(.), argument=(.)  you can easily manipulate very complex values
03:53:51 <pao> luqui: I don't really see any deficiencies in wchar_t
03:53:56 <Peaker> @let result = (.) ; each = map ; both = join (***)
03:53:59 <lambdabot>  Defined.
03:54:04 <luqui> pao, other than the fact that there are a whole bunch of unicode characters it can't represent?
03:54:15 <luqui> pao, and that it takes up twice as much space as necessary when you are working with ASCII
03:54:16 <Peaker> @type (first . second . each . both . result) (*2)
03:54:17 <lambdabot> forall d d1 b a. (Num b) => ((d1, [(a -> b, a -> b)]), d) -> ((d1, [(a -> b, a -> b)]), d)
03:54:18 <luqui> there are tons of trade-offs.
03:54:20 <pao> while being 16 bit... it's variable encoded ... so you can rapresent all chars
03:54:20 <mreh> This record structure syntax i was reading about in RWH, when was that introduced? It's not in the haskell 98 spec
03:54:46 <Peaker> pao: so its not 16-bit then?
03:54:51 <luqui> pao, no it's not.  wchar_t is just a type.  you're talking about UTF-16 I think
03:54:57 <L-Spiro> Okay everything is in the two categories.
03:55:20 <Peaker> L-Spiro: first and second make a function that operates on something, operate on a tuple of something
03:55:29 <Peaker> > first (*2) (5,7)
03:55:31 <lambdabot>   (10,7)
03:55:38 <Peaker> > (first . second) (*2) ((1,5),7)
03:55:39 <L-Spiro> You mean operate on each item in the list.
03:55:39 <lambdabot>   ((1,10),7)
03:55:46 <Peaker> L-Spiro: no, on just one of the tuple elements
03:55:57 <Peaker> L-Spiro: you can use   both = join (***)  to operate on both of the tuple elements
03:56:03 <Peaker> > both (*2) (5,7)
03:56:06 <lambdabot>   (10,14)
03:56:22 <Peaker> > (first . each) (*2) ([1,2,3], 5)
03:56:23 <L-Spiro> first . second means first followed by second right?
03:56:24 <lambdabot>   ([2,4,6],5)
03:56:34 <pao> luqui: Peaker: you're right ... I just wanted to say that it would seen reasonable to stick to the platform implementation of the wchar_t standard...
03:56:35 <Peaker> L-Spiro: It means "inside the first of a tuple, inside the second in there"
03:56:44 <Peaker> L-Spiro: these are called "semantic editor combinators"
03:57:16 <Peaker> L-Spiro: "semantic editor" because they edit functions (which can only be edited semantically this way, by "wrapping" the functions), and "combinators" because you can combine them like this with (.)
03:57:25 <luqui> Peaker, btw, argument = flip (.), not (.).  You probably just typod.
03:57:43 <Peaker> oops, yes
03:58:23 <L-Spiro> let myMap = Map.fromListWith (++) . map (second (:[])) $ myList -- "map" here runs over the list.  "Map.fromList" generates a map right?
03:58:55 <Peaker> @type Data.Map.fromList
03:58:57 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
03:58:59 <L-Spiro> (++) is the operator used to operate between the constructed map and each object in the list?
03:59:08 <Peaker> L-Spiro: as you can see, yes, it takes a list of (key,value) pairs and generates a map from that
03:59:19 <Peaker> @type Data.Map.fromListWith
03:59:21 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
03:59:27 <Peaker> L-Spiro: fromListWith handles key-collisions
03:59:29 <L-Spiro> I mean if I used (--) it would remove from a map?
03:59:30 <luqui> L-Spiro, (++) is used when a collision on keys happens
03:59:38 <Peaker> L-Spiro: it handles collisions by using the given func, in this case (++)
03:59:39 <L-Spiro> Oh.
03:59:56 <luqui> L-Spiro, no, (++) just concatenates lists.  That's why we had to wrap the second elements with singleton lists.
04:00:11 <Peaker> L-Spiro: but in order to be able to concat values when they collide, you have to have them be lists, first.  So it uses a "map (second (:[]))" to change only the 2nd of each tuple (i.e the value, not the key) into a list of one element
04:00:11 <L-Spiro> Why is there a dot after that?  That means make the map after going over the list?
04:00:25 <Peaker> L-Spiro: I'd prefer (each . second) (:[]) over that
04:00:32 <Peaker> L-Spiro: do you know the (.) operator?
04:00:34 <Peaker> @type (.)
04:00:36 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:00:51 <Peaker> > (*2) . (+1) . (*2) $ 10
04:00:53 <lambdabot>   42
04:00:56 <L-Spiro> That doesn't make sense.
04:01:00 <Peaker> > (*3) . (+1) . (*2) $ 10
04:01:00 <L-Spiro> And I don't know what $ is.
04:01:02 <lambdabot>   63
04:01:08 <Peaker> L-Spiro: $ is function application
04:01:10 <Peaker> @src ($)
04:01:11 <lambdabot> f $ x = f x
04:01:28 <Peaker> L-Spiro: but $ has low precedence, so it is often used as a syntactic tool to avoid ()
04:01:30 <luqui> (.) and ($) were some of the hardest things for me to get used to when learning Haskell.
04:01:57 <Peaker> L-Spiro: so if you have (really long expression here involving operators) (another really long expression here)  you can use: really long expression here involving operators $ another really long expression here
04:01:59 <luqui> I think their simplicity was the perplexing thing.
04:02:01 <Peaker> L-Spiro: to aovid the parens
04:02:27 <L-Spiro> $ just allows you to avoid parentheses.
04:02:30 <lunabot>  luna: Not in scope: `just'
04:02:40 <Peaker> L-Spiro: and (.) is like a unix pipe -- it composes functions such that the left hand function operates on the result of the right one.  f . g   gives you a new function that will run both g and f on its input
04:02:51 <Peaker> L-Spiro: mostly, yes. It has a couple of other uses too
04:03:09 <Peaker> L-Spiro: for example,  map ($5) functions -- applies each of the functions to 5
04:03:18 <Peaker> L-Spiro: gives 5 as an arg to each of the functions, that is
04:03:31 <Peaker> L-Spiro: much like    map (+5) values  -- adds 5 to each value
04:04:11 <luqui> Notably, (.) operates in the opposite direction as a unix pipe.  The data flows right-to-left.
04:04:13 <Peaker> L-Spiro: so if you have:  f (g (h (i x)))     its considered better style to use:   f . g . h . i $ x      instead, which is equivalent
04:05:02 <Peaker> L-Spiro: it saves parens, doesn't have the ugly meaningless (to humans) "))))" in the end, and lets you refactor some of your processing "pipelines" into separate functions easily...   someFunc = f . g . h  -- to do the h to f part
04:05:15 <L-Spiro> But why do I need to use . instead of just passing the right function as a parameter to the left function?
04:05:24 <L-Spiro> Oh.
04:05:28 <Peaker> L-Spiro: you don't want to pass the function as a parameter, you want to pass its result
04:05:34 <L-Spiro> Of course.
04:06:16 <Peaker> L-Spiro: it turns out function composition is a really powerful tool for modularity
04:06:49 <Peaker> L-Spiro: the example above of using  (first . each . second) for example
04:07:48 <pao> Unicode is complex anyway... everytime I scratch the surface, I always get biten :-)
04:08:03 <Peaker> L-Spiro: do you understand how  (first (*2)) works? From that its not hard to explain how (first . second) (*2) works
04:08:16 <L-Spiro> Don't know (*2).
04:08:31 <Peaker> L-Spiro: (*2) just applies the operator (*) to 2 on its right-side. Its called a "section"
04:08:47 <Peaker> > (5*6, (*) 5 6, (5*) 6, (*6) 5)
04:08:49 <lambdabot>   (30,30,30,30)
04:08:50 <luqui> in other words: (*2) is a function that multiplies a number by 2
04:08:51 <Peaker> this are all equivalent
04:08:57 <Peaker> these
04:09:30 <Peaker> L-Spiro: so if (*2) multiples a number by 2,   first (*2) multiplies the number inside the first of a tuple by 2
04:09:32 <Peaker> @type (*2)
04:09:33 <hcube> Does anyone use fgl (Functional Graph Library)?
04:09:34 <lambdabot> forall a. (Num a) => a -> a
04:09:35 <Peaker> @type first (*2)
04:09:37 <lambdabot> forall b d. (Num b) => (b, d) -> (b, d)
04:10:06 <Peaker> > (*2) 5
04:10:08 <lambdabot>   10
04:10:10 <Peaker> > first (*2) (5,10)
04:10:12 <lambdabot>   (10,10)
04:10:18 <luqui> :t first (* (2::Int))
04:10:20 <lambdabot> forall d. (Int, d) -> (Int, d)
04:10:30 <Peaker> yeah, that's easier to read
04:10:48 <Peaker> I find semantic editor combinators really beautiful :-)
04:10:56 <Peaker> I export them for all my exported types now :)
04:11:29 <luqui> Peaker, by which you mean, you make your types functors and give another name to fmap?
04:11:30 <soa2ii> Hi there. What do I have to do if ghc says: Could not find module `Graphics.HGL' ?
04:11:54 <Peaker> luqui: no, fmap is just one of many possible semantic editors
04:12:19 <luqui> Peaker, give me some examples of non-functorial ones you export
04:12:20 <Peaker> luqui: for example, another editor on lists could be   nth :: Int -> (a -> a) -> [a] -> [a]
04:12:37 <Peaker> luqui: in my Vector2 type, I export  a first,second like those of tuple:  vector2first and vector2second
04:12:44 <L-Spiro> I have to eliminate doubles from one of the categories.
04:13:07 <L-Spiro> Then sort the remaining list.
04:13:11 <Peaker> luqui: also, I export editor combinators for SDL's Rect type:   rectPos, rectSize :: (Vector2 Int -> Vector2 Int) -> SDL.Rect -> SDL.Rect
04:13:13 <luqui> > nub [3,1,4,1,5,9,2,6,5,3,5,8]
04:13:14 <lambdabot>   [3,1,4,5,9,2,6,8]
04:13:20 <L-Spiro> nub is?
04:13:21 <Axman6> bloody hell, wtf were they thinking when they were hacking together perl?
04:13:27 <luqui> nub eliminates duplicates
04:13:33 <Axman6> @src nub
04:13:33 <lambdabot> nub = nubBy (==)
04:13:34 <Peaker> luqui: if I want to move an SDL rect right by 5 pixels:   (rectPos . vector2first) (+5)
04:13:36 <Axman6> @src nubBy
04:13:37 <lambdabot> nubBy eq []             =  []
04:13:37 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:13:52 <Peaker> luqui: I have rectX = rectPos . vector2first  actually, but you get the idea :)
04:13:55 <L-Spiro> I mean how does "Eliminate Doubles" become "nub"?
04:13:56 <icqn> @src length
04:13:57 <lambdabot> Source not found.
04:14:10 <luqui> Peaker, ah.  cool.  So, yeah, non-functorial ones are especially those that do not change the type
04:14:26 <Peaker> luqui: yeah, but also if your type has more than one "thing" inside it
04:14:27 <luqui> L-Spiro, "nub" means "essence".  But I agree it's a dumb name.  :-)
04:14:27 <Axman6> > nub [1,2,3,4,1,2,3,4]
04:14:28 <lambdabot>   [1,2,3,4]
04:14:38 <Peaker> luqui: then you want editors for the different things
04:15:06 <L-Spiro> So eliminating doubles is easy.  But how can I search my map for the right category?  On my own I would make a recursive function that accepts the map and a string.
04:15:15 <L-Spiro> But I am sure there is something to do it already.
04:15:34 <luqui> L-Spiro, you have the name of a category and you want to eliminate doubles and sort its values, but no others?
04:15:41 <L-Spiro> Yes.
04:16:10 <luqui> L-Spiro, I'm using this for reference: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
04:16:28 <luqui> L-Spiro, adjust
04:16:32 <luqui> that's the function
04:16:42 <luqui> adjust (sort . nub) "ANIMALS"
04:16:44 <Axman6> urgh, if only i could use haskell for this movable type plugin :(
04:17:03 <luqui> (I guess it would be Map.adjust ...)
04:17:35 <Peaker> luqui: btw, this is all from conal's blog, which is a great source of inspiration :)
04:17:50 <Axman6> i want to just have something like appleHsColor . filter (\x -> Just '>' == maybeToList x) . lines
04:17:57 <Peaker> luqui: the entries are usually short and entertaining, too, you don't have to read mountains of text to get the nice stuff :)
04:17:59 <Axman6> maybe not filter
04:18:48 <Peaker> luqui: btw argument is another semantic editor that isn't fmap
04:19:06 <luqui> Peaker, well, it's cofmap.
04:19:21 <luqui> Peaker, and cofmap . cofmap  is an fmap.
04:19:32 <L-Spiro>         Map.adjust (sort . nub) "ANIMALS"
04:19:41 <L-Spiro> Just that?  I should need to pass my map somewhere.
04:19:48 <luqui> L-Spiro, as the last argument
04:19:51 <L-Spiro> I figured.
04:19:53 <luqui> look at the type sig of adjust
04:20:02 <Peaker> luqui: what do you mean "it is an fmap"?
04:20:07 <Peaker> @let argument = flip (.)
04:20:10 <lambdabot>  Defined.
04:20:12 <Peaker> @type argument . argument
04:20:13 <L-Spiro> I got lost wading through all the ->
04:20:14 <lambdabot> forall c a b c1. (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
04:20:17 <luqui> Peaker, it's the operation of a functor.
04:20:31 <luqui> maybe not a Haskell Functor instance, but you can newtype around to make it so.
04:20:46 <luqui> (not that you should, just saying what I consider "an fmap")
04:21:03 <Peaker> luqui: why is (cofmap . cofmap) an fmap, but not cofmap?
04:21:17 <luqui> because cofmap is contravariant, and fmap is covariant.
04:21:25 <luqui> cofmap . cofmap is the functor operator on Cont
04:21:40 <luqui> cofmap itself corresponds to no functor, because it has the wrong type:  (a -> b) -> F b -> F a
04:21:44 <L-Spiro> Great.  Neither sort nor nub are in scope.
04:21:50 <luqui> L-Spiro, they're both in Data.List
04:22:02 <L-Spiro> Next time, how can I find where they are on my own?
04:22:06 <luqui> hoogle!
04:22:12 <luqui> haskell.org/hoogle
04:22:13 <L-Spiro> In this chat room?
04:22:15 <L-Spiro> Oh.
04:22:27 <Peaker> cofmap . cofmap :: (Cofunctor f, Cofunctor g) => (a -> b) -> f (g b) -> f (g a)      -- right?
04:22:38 <Peaker> @index nub
04:22:39 <lambdabot> Data.List
04:22:44 <Peaker> @index sort
04:22:45 <lambdabot> Data.List
04:22:49 <luqui> Peaker, almost.  the b and the a are reversed.
04:22:50 <Peaker> L-Spiro: that works too
04:22:59 <L-Spiro> Map.adjust (sort . nub) "ANIMALS" myMap  -- Giving me an error.
04:23:06 <luqui> (Cofunctor f, Cofunctor g) => (a -> b) -> f (g a) -> f (g b)
04:23:11 <Peaker> luqui: ah, I see, reverse.reverse==id :)
04:23:22 <luqui> :-)
04:23:28 <Peaker> luqui: an even amount of reversals by cofmap gets you an fmap again
04:24:10 <Peaker> luqui: Yeah, the argument.argument should have made that clear, the a and b are on the right sides for fmap
04:24:40 <luqui> Do you think someone (us?) should put up a hackage package for standard editors?
04:24:45 <luqui> I'd use it.
04:25:02 <luqui> It always feels like a kludge to import Control.Arrow when I just want first, second, left, and right
04:25:06 <L-Spiro> This isn't right.  I expected to have to do a function to get the list within myMap called "ANIMALS".
04:25:30 <Peaker> luqui: yeah, sure
04:25:37 <luqui> L-Spiro, oh yeah, adjust modifies it in-place.
04:25:42 <Peaker> luqui: or actually, it goes against my principle :)
04:25:45 <luqui> L-Spiro, use Map.lookup if you just want to get it out
04:25:50 <luqui> Peaker, huh?
04:25:54 <Peaker> luqui: modules should be grouped conceptually, not semantically
04:26:02 <L-Spiro> findWithDefault?
04:26:26 <Peaker> luqui: being a "semantic editor combinator" is a semantic property -- its probably a good idea to keep these editors in the various modules they relate to, and not put them in one single module. A good naming convention to find them everywhere would be good though
04:26:33 <luqui> L-Spiro, yeah I guess that's one way.  I usually pattern match on Map.lookup  (which returns a maybe).  but it's the same thing in the end.
04:26:55 <Peaker> luqui: (first, second) coming from arrow is indeed awkward.  Data.Function should export result, argument.  Data.Tuple should export first, second, etc
04:27:03 <luqui> Peaker, well, the ones I'm talking about would be in the prelude :-)
04:27:13 <luqui> or yeah, Data.Tuple
04:27:15 <luqui> etc.
04:27:43 <Peaker> luqui: Maybe the editors should be generalized to edit arrows rather than functions, like first and second?
04:27:50 <Peaker> though nobody seems to be making much use of arrows
04:27:59 <luqui> Peaker, have you seen Conal's DeepArrow library?
04:28:03 <L-Spiro> Map.adjust (sort . nub) lookup myMap "ANIMALS"  still not right.
04:28:06 <luqui> that's precisely what it is :-)
04:28:14 <wolverian> can I make lambdabot omit the implicit forall in @type output?
04:28:32 <Raevel> I BROKE MY GHC :-(
04:28:49 <luqui> L-Spiro, I don't know why that would be right.  You can't just throw words together and hope GHC figures out what you mean :-)
04:28:52 <Peaker> luqui: only glimpse of it -- it too is making arr-less arrows.  Arrows should not have arr
04:28:58 <L-Spiro> WTF why not?
04:29:15 <Peaker> @type Data.Map.adjust
04:29:17 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
04:29:18 <L-Spiro> Map.adjust (sort . nub) . lookup myMap "ANIMALS"  -- It is whining about "ANIMALS", second parm of lookup.
04:29:29 <luqui> L-Spiro, sort . nub . Map.findWithDefault [] "ANIMALS" $ myMap
04:29:32 <Peaker> L-Spiro: I think you want (sort . nub)
04:29:54 <Peaker> L-Spiro: lookup on a map returns a Maybe result
04:30:03 <L-Spiro> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a  Why does this have no meaning to me?
04:30:06 <Peaker> L-Spiro: the compiler tells you that you must handle the case your lookup fails
04:30:09 <Saizan> ?type Data.Map.lookup
04:30:11 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
04:30:20 <luqui> Peaker, yeah I switched from lookup to findWithDefault so I wouldn't have to explain fmap.
04:30:23 <Peaker> L-Spiro: Because reading Haskell types has a slight learning curve :-) I can explain that type if you want
04:30:36 <L-Spiro> Not yet.
04:30:37 <Saizan> L-Spiro: in lookup the first argument is the key and the second is the Map
04:31:13 <L-Spiro> sort . nub . Map.findWithDefault [] "ANIMALS" $ myMap  -- Compiler is still whining.
04:31:35 <Saizan> ?type sort . nub . Data.Map.Map.findWithDefault [] "ANIMALS"
04:31:36 <lambdabot> Couldn't find qualified module.
04:31:41 <luqui> Hmm, I think we are approaching this pedagogically poorly.  We are higher-ordering all over the place, using maybes and fmap, without getting down to basics: lambdas and cases.
04:31:42 <Saizan> ?type sort . nub . Data.Map.findWithDefault [] "ANIMALS"
04:31:44 <lambdabot> forall a. (Ord a) => M.Map [Char] [a] -> [a]
04:31:59 <luqui> whenever I get confused, I just eta-expand and case match, then refine back to higher-orderness again
04:32:02 <Peaker> L-Spiro: "forall a k." means that the following type declaration works for any chosen types a and k.  "(Ord k) =>" means that k can't just be any type, but has to be an ordinal type that can be compared with <, ==, >.   "(a -> a) -> k -> Map k a -> Map k a" means: given 3 arguments of types (a->a), k, and Map k a, generate a resulting map Map k a
04:32:26 <Saizan> L-Spiro: instead of "whining" you should report the error
04:32:40 <L-Spiro> I would but I have to type it and right now I am reading.
04:33:20 <L-Spiro> And it is frigging long.
04:33:29 <Saizan> @where hpaste2
04:33:30 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
04:34:03 <L-Spiro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=924#a924
04:34:30 <Saizan> ok
04:34:53 <L-Spiro> That is with this code: http://rafb.net/p/8AcDXH20.html
04:35:44 <Saizan> ok, if you wan the result of "sort . nub . Data.Map.findWithDefault [] "ANIMALS"" printed then you've to add "print ." at the left of it
04:36:09 <Saizan> or use let foo = sort . nub . Map.findWithDefault [] "ANIMALS" $ myMap
04:36:11 <L-Spiro> Or store it using let?
04:36:27 <Saizan> yeah
04:36:40 <Saizan> like you do with myMap
04:37:05 <Peaker> why did it infer type  IO [Char] there?
04:37:14 <L-Spiro> Let me explain.
04:37:18 <L-Spiro> It's simple really.
04:37:21 <L-Spiro> I have no clue.
04:37:26 <Badger> heh
04:37:45 <Peaker> ok I get it
04:38:17 <L-Spiro> Now mySortedList contains a list of sorted animals with no duplicates.  Awesomness.
04:39:00 <L-Spiro> I'll owe everyone in the room part of my first check if I get this job.
04:39:47 <luqui> My paypal is lambdacat@gmail.com.  Thanks.
04:39:55 <jeffz`> @users
04:39:56 <lambdabot> Maximum users seen in #haskell: 645, currently: 589 (91.3%), active: 15 (2.5%)
04:40:17 <L-Spiro> Well 580 of them are not helping.
04:40:25 <Saizan> btw, do you understand the error now?
04:40:38 <L-Spiro> I guess.  I had a statement.
04:40:49 <L-Spiro> Which served no purpose since it was not being assigned to anything.
04:40:53 <Peaker> L-Spiro: a statement whose result was not an   IO action  to execute
04:41:11 <Peaker> L-Spiro: each non-let statement in a do block has to be an (IO type) value to execute
04:41:27 <vixey> hi
04:41:38 <L-Spiro> non-let statements sound mean.
04:43:16 <L-Spiro> Grr.  I thought I could print the length of the array with print length mySortedList.
04:43:32 <L-Spiro> I have to convert to string or something else?
04:43:33 <mauke> that calls print with two arguments
04:43:40 <mauke> print (length x)
04:43:43 <L-Spiro> Oh.
04:44:00 <Peaker> L-Spiro:   print length mySortedList  ==  (print length) mySortedList  -- and expects  (print length)  to return a function
04:44:18 <alex23> hi
04:44:18 <cnwdup> How is MonadPlus defined if it's automatically derived using GeneralizedNewtypeDeriving?
04:44:31 <vixey> hi alex
04:44:35 <alex23> how to Convert an Integer to an Int ?
04:44:44 <cnwdup> alex23, fromIntegral
04:44:53 <mauke> mzero = C mzero; C x `mplus` C y = C (x `mplus` y)
04:45:06 <alex23> okay thx
04:45:08 <cnwdup> mauke, thanks
04:45:23 <luqui> L-Spiro, you probably don't care, but you will save yourself pain in the future if you don't call lists "arrays".   Haskell lists are linked lists, not arrays.
04:45:43 <L-Spiro> I called it an array?
04:45:52 <luqui> singly linked, to be precise.
04:46:00 <luqui> "Grr.  I thought I could print the length of the array with print length mySortedList."
04:46:06 <L-Spiro> Well I meant list.
04:46:10 <Peaker> :-)
04:46:13 <vixey> how dare you
04:46:20 <L-Spiro> Oh I dare all right.
04:46:31 <mauke> sort . nub seems needlessly expensive
04:46:48 <vixey> nub . sort would give the same result and be more efficient wouldn't it?
04:46:51 <luqui> mauke, we were firmly in "get something working" land
04:46:52 <L-Spiro> print ("Animals: " ++ (length mySortedList))  -- More Grr.
04:46:58 <vixey> or no not really?
04:47:08 <mauke> vixey: probably not
04:47:11 <luqui> vixey, no, they'll be the same.  but there is a something . sort which is more efficient.
04:47:17 <vixey> nubber = map head . group
04:47:18 <mauke> L-Spiro: can't (++) an Int
04:47:19 <L-Spiro> qsort?
04:47:25 <mm_freak_> doesn't work: timeout 1000000 (takeMVar ch)
04:47:26 <vixey> = qnub
04:47:40 <mm_freak_> is there an alternative to this?
04:47:45 <mauke> L-Spiro: print x = putStrLn (show x)
04:48:03 <luqui> mm_freak_, in what way doesn't it work?
04:48:07 <mauke> you want something like putStrLn ("Animals: " ++ show (length list))
04:48:16 <L-Spiro> What happened to my "Animals: " text?
04:48:23 <mm_freak_> luqui: it doesn't timeout
04:48:38 <mm_freak_> the documentation states that 'timeout' relies on asynch exceptions
04:48:51 <mm_freak_> seems like they don't work well with takeMVar
04:48:58 <mm_freak_> i also tried Chan, same thing
04:49:05 <true\false> In Ghci, should the input 'Nil' not work?
04:49:25 <Peaker> L-Spiro: the one and only precedence rule which definitely pays out to remember in Haskell, is that prefix func-application sticks stronger than infix.  so  "Animals: " ++ (length blah)    is ok as:  "Animals: " ++ length blah
04:49:26 <true\false> Gah nevermind..
04:49:30 <mauke> true\false: depends. how did you define Nil?
04:49:36 <luqui> mm_freak_, hmm, right, that makes sense given the implementation.   you could try switching to STM, so you can block on two variables at the same time
04:49:39 <Peaker> L-Spiro: though length blah does not return a list for (++) (but that's another matter)
04:49:56 <true\false> mauke, just by typing it in .. Apparently I misread the icon
04:50:01 <mm_freak_> luqui: ah, interesting idea
04:50:03 <mm_freak_> thanks
04:50:08 <mauke> true\false: by typing what in?
04:50:11 <true\false> Nil
04:50:21 <mauke> true\false: that doesn't define Nil, that tries to use it
04:50:22 <L-Spiro> The last step is to print each of the items in the other category and also how many times it occurs in the list.
04:50:28 <mauke> <interactive>:1:0: Not in scope: data constructor `Nil'
04:50:50 <true\false> mauke: heh I noticed.. I'm just confused by the icons and output on this book then :p
04:51:16 <L-Spiro> So is there a way to count the occurrences of something in the list?  After I have that I can probably get the rest to work.
04:51:47 <luqui> > length . filter (== 42) $ [1,17,42,6,11,42,21]
04:51:48 <lambdabot>   2
04:52:05 <true\false> No really .. I don't understand this part of RWH.. It looks very much like adding this into the interpreter through the CLI
04:52:08 <mm_freak_> luqui: the STM documentation is useless…  is there a better documentation somewhere else?  not a paper, please, but a reference documentation
04:52:08 <mauke> for repeated queries I'd probably construct a Map first
04:52:23 <Saizan> > group [1,2,2,3,3,4,4]
04:52:23 <luqui> mm_freak_, it is?  there's not much to it.
04:52:25 <lambdabot>   [[1],[2,2],[3,3],[4,4]]
04:52:44 <mm_freak_> luqui: yes, but i've forgotten even the function names
04:52:48 <vixey> I'm so confused on this syntax stuff
04:52:50 <luqui> mm_freak_, readTVar, writeTVar are operations in STM, to get from STM to IO you use atomically
04:52:51 <L-Spiro> Ah filter.
04:53:00 <luqui> mm_freak_, I use the docs in Control.Concurrent.STM
04:53:11 <mm_freak_> they are incomplete
04:53:19 <mm_freak_> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
04:53:21 <luqui> er wait
04:53:27 <L-Spiro> So here is my plan.  I will create another sorted nub list with the NUMBERS and then run through each and for each I will print its name as well as its count in the original list.
04:53:29 <luqui> what happened?  maybe I don't.
04:53:30 <L-Spiro> Solid?
04:53:49 <luqui> mm_freak_, well, they are also in GHC.Conc
04:53:54 <luqui> which seems to actually document them
04:54:05 <mauke> mm_freak_: http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html
04:54:28 <mm_freak_> ah, thanks
04:54:33 <mauke> mm_freak_: it's possible to get there by following links from Control.Concurrent.STM, but this is nonobvious :-/
04:54:48 <mm_freak_> yeah, i haven't found it
04:55:02 <vixey> I've got 2 kinds of syntax and 4 kinds of bindings to keep in order :/
04:55:11 <luqui> L-Spiro, sounds like a plan.
04:55:24 <mm_freak_> however…  how do i wait on two TVars?  through orElse?
04:55:32 <L-Spiro> Just wanted to make sure there is not already a function built-in to do that.
04:55:44 <L-Spiro> But even if there was I would not want to use it.  I want to learn.
04:55:47 <mauke> mm_freak_: yes
04:55:48 <luqui> mm_freak_, no, I think just retry will do it
04:56:11 <L-Spiro> Most likely in the interview I will have to go over this code and explain each line.
04:56:33 <mm_freak_> what's the difference between TVar and TMVar?
04:56:47 <mauke> mm_freak_: TVar is like IORef
04:56:49 <mmorrow> a TMVar is like an MVar
04:57:01 <mm_freak_> ok, i'll need TMVar then
04:57:01 <luqui> TMVar is basically TVar . Maybe ?
04:57:03 <Heffalump> I'm confused
04:57:16 <vixey> me too Heffalump
04:57:19 <Heffalump> oh, I see
04:57:26 <Heffalump> MVars are not just thread-safe IORefs
04:57:54 <mm_freak_> MVars work sort of like a channel
04:57:59 <Heffalump> yeah
04:58:17 <mm_freak_> they can be empty, in which case reading blocks and only one thread can 'put' something in it
04:58:41 <Heffalump> and for TMVars reading fails, presumably?
04:58:54 <mm_freak_> in fact, the only difference between MVar and Chan is that putMVar blocks, while writeChan does not
04:59:06 <Heffalump> luqui: your post about orphan instances is a really cool point
04:59:09 <mm_freak_> Heffalump: i hope so…  that's what i'll rely on =)
04:59:13 <mmorrow> newtype TMVar a = TMVar (TVar (Maybe a))
04:59:36 <mmorrow> looks like TMVars use TVar to simulate MVar semantics
05:00:04 <luqui> Heffalump, thanks :-)
05:00:32 <mmorrow> mm_freak_: a Chan is implemented with MVars
05:00:47 <mauke> @src Chan
05:00:47 <lambdabot> Source not found. My mind is going. I can feel it.
05:00:51 <mm_freak_> mmorrow: with an auxilliary thread?
05:01:07 <mmorrow> they're like a linked list of MVars
05:01:40 <mmorrow> data Chan a = Chan (MVar (Stream a))
05:01:41 <mmorrow>         (MVar (Stream a))
05:02:04 <mmorrow> type Stream a = MVar (ChItem a)
05:02:04 <mmorrow> data ChItem a = ChItem a (Stream a)
05:02:05 <Eridius> why can't I get cabal to install parsec 3.0? I have 2.1.0.1 installed, but attempts to install/upgrade just tell me it's already installed
05:02:42 <mmorrow> or rather, Stream is a "list" of MVars
05:02:49 <Saizan> Eridius: 2.* is the preferred version, "cabal install 'parsec >= 3'" if you want that
05:02:49 <dcoutts> Eridius: cabal install 'parsec >= 3'
05:02:55 <Eridius> ah
05:02:58 <mmorrow> and Chan is a two-sided one
05:03:08 <mmorrow> or something
05:05:22 <true\false> data List a = Cons a (List a) | Nil deriving (Show)
05:06:02 <mmorrow> (not that it matters, but Nil is usually the first con)
05:06:14 <true\false> Getting a little confused here as to what happens here.. You use it by: Cons 1 Nil, then Cons 2 it, etc..
05:06:24 <mmorrow> @src []
05:06:24 <lambdabot> data [] a = [] | a : [a]
05:06:38 <mmorrow> s/[]/Nil/   s/:/Cons/
05:06:45 <vixey> true\false, it declares some constants,  List :: * -> *;  Cons :: a -> List a -> List a;  Nil :: List a
05:06:53 <mmorrow> oh
05:07:08 <vixey> true\false, also it will derive   instance Show (List a) where ...
05:07:17 <cnwdup> > Left [1,2] `mplus` Left [3,4]
05:07:19 <lambdabot>       No instance for (Error [t])
05:07:19 <lambdabot>        arising from a use of `mplus' at <in...
05:07:26 <mmorrow> Cons 0 (Cons 1 (Cons 2 ..... (Cons 1000 Nil)))...)))
05:07:35 <mmorrow> , [0..1000]
05:07:37 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
05:07:55 <true\false> Oh I get that part, but.. what I don't understand is how the Cons stuff work, like  Cons a (List a).. Where does Nil figure into that?
05:07:56 <mmorrow> , (:) 0 ((:) 1 ((:) 2 [])))
05:07:57 <lunabot>  luna: parse error on input `)'
05:07:59 <mmorrow> , (:) 0 ((:) 1 ((:) 2 []))
05:08:00 <lunabot>  [0,1,2]
05:08:19 <mauke> true\false: it says a List is either a Cons (of an 'a' and another List) or a Nil
05:08:19 <mmorrow> true\false: well if you ever want to end the list, you need Nil
05:08:28 <vixey> true\false,  Cons a (List a)  declares the constant   Cons :: a -> List a -> List a
05:08:38 <mmorrow> @type (:)
05:08:39 <lambdabot> forall a. a -> [a] -> [a]
05:09:14 <true\false> I'm confused by how Nill is used to end here, how does the Nil type cstr get called?
05:09:29 <true\false> In the context of Cons 1 Nil
05:09:29 <mauke> true\false: Nil
05:09:29 <vixey> true\false: Nil :: List a
05:09:37 <mmorrow> so in "Cons a b", (a :: whatever) and (b :: List whatever)
05:09:38 <mauke> true\false: what do you mean by "get called"?
05:09:43 <true\false> Frig .. It is, I get it now I thin
05:10:00 <true\false> mauke: Meh, OO terminology dies hard'
05:10:04 <mmorrow> heh
05:10:36 <vixey> < runInfer (infer 0 [] (  Lam (Sort Type) (Scope (Lam (Ref 0) (Scope (Ref 0)))) ))
05:10:37 <vixey> Right (Pi (Sort Type) (Scope (Pi (Sort Type) (Scope (Ref 1)))))
05:10:38 <true\false> Ok thanks yes, I see that now .. It wants an expression equal to (List a) there, of which Nil fits the bill?
05:10:47 <vixey> does it look right ?
05:11:23 <mmorrow> true\false: "equal to (List a) there,"  not "equal to" but "has the type of"
05:11:38 <mmorrow> Nil :: List a
05:11:41 * vixey thinks not..
05:12:01 <mmorrow> i dunno, still trying to parse meaning
05:12:17 <mmorrow> oh
05:12:43 <vixey> the second Sort Type should be Ref 0 ugh :/
05:12:44 <true\false> Because to me, it looks like that's endless recursion.. It just calls List a, constanstly
05:12:53 <mmorrow> you mean correct wrt how the Scopes are setup?
05:13:24 <mmorrow> oh i see
05:13:37 <vixey> I think I screw up something with handling variables
05:13:41 <luqui> vixey, doing some dependent type stuff?
05:14:08 <vixey> luqui, it is not working because I do not understand substitution
05:14:34 <mmorrow> vixey: oh yeah, that reminds me. (not sure if you) remember how i was all mixed up with the indices of the vars in "the shortest beta normalizer"?
05:15:02 <vixey> with,  data T v = Var v | Lam (v -> T) | App T T;   you can write  join :: T (T v) -> T v;  fmap :: (u -> v) -> (T u -> T v); and return :: o -> T o
05:15:06 <mmorrow> there are de bruijn _levels_ and de bruijn _indices_
05:15:19 <mmorrow> and they are numbered in the opposite way to the other
05:15:35 <mmorrow> the shortest beta normalizer was using levels
05:15:39 <vixey> mmorrow, it's especially tricky because I have two kinds of syntax (like in shortest beta normalizer)
05:15:53 <vixey> the first is textual syntax, and the second is a semantic domain
05:16:00 <mmorrow> cool
05:16:02 <vixey> so if you go T -> D -> T you get a normalized term
05:16:37 <vixey> but I have to handle open contexts like:   gamma |- term with (length gamma) free variables
05:16:50 <vixey> and evaluating/quoting them back and forth.....
05:16:52 <Saizan> how do tou write fmap :: (u -> v) -> (T u -> T v) ?
05:16:54 <L-Spiro> Map.findWithDefault [] "ANIMALS" $ myMap  == Map.findWithDefault [] ("ANIMALS" myMap) right?
05:17:09 <L-Spiro> Or no.
05:17:13 <Saizan> no
05:17:17 <L-Spiro> (Map.findWithDefault [] "ANIMALS") (myMap)
05:17:26 <Saizan> right
05:17:40 <vixey> fmap m (Var v) = Var (m v); fmap m (Lam f) = Lam (\o -> fmap m (f o)); fmap m (App p q) = App (fmap m p) (fmap m q)
05:18:18 <vixey> join (Var v) = v; join (Lam f) = Lam (\o -> join (f o)); join (App m n) = App (join m) (join n)
05:18:19 <mmorrow> vixey: that sounds interesting
05:18:24 <vixey> return x = Var x
05:18:47 <Eridius> hrm, yi depends on regex-tdfa and on parsec-3.0.0, but regex-tdfa depends on parsec-2.1.0.1. that sounds bad
05:19:10 <vixey> mmorrow, it is but it is really tricky too
05:19:49 <vixey> here's some scrap metal http://rafb.net/p/JksgnD78.html
05:19:57 <luqui> vixey, yeah!  ASTs with reification are monads! :-)
05:20:00 <Eridius> oh great, yi won't even build because random-1.0.0.1 is hidden
05:20:30 <mmorrow> heh, "scrap metal"
05:21:17 <mmorrow> vixey: sweet
05:21:28 <vixey> it doesn't give correct results though...
05:21:42 <mmorrow> i'm sure it will eventually ;)
05:22:05 <vixey> I hope so... and then I would add inductive types to it and have to fix it again
05:22:41 <vixey> I need to get some more precise terminology for dealing with variables
05:23:03 <vixey> because (as you probably notice) that aspect is the most messy and the one causing this bug
05:23:33 <vixey> abstract/instantiate is from I am not a number I am a free variable
05:24:16 <Eridius> oh there we go, now yi is compiling
05:24:49 <Eridius> ack Yi/UI/Cocoa/Application.hs now failed
05:24:59 <vixey> mmorrow, but this isn't (at least caused by the same thing that caused) "de bruijn subtlty"
05:25:26 <Saizan> vixey: your fmap has type (v -> v) -> T v -> T v
05:26:35 <Peaker> any nicer way to express:   positions = 0 : zipWith (+) positions sizes  ?
05:26:48 <Peaker> @type scanr
05:26:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
05:27:14 <Peaker> > scanl 0 (+) [1,2,3]
05:27:15 <vixey> Saizan, ohh you are right
05:27:16 <lambdabot>       Overlapping instances for Show (a -> a -> a)
05:27:16 <lambdabot>        arising from a use ...
05:27:21 <Heffalump> positions = fix ( (0:) . flip zipWith (+) sizes )
05:27:27 <Peaker> > scanl (+) 0 [1,2,3]
05:27:28 <Heffalump> but that's obfuscated more than anything if you ask me
05:27:29 <lambdabot>   [0,1,3,6]
05:27:40 <Peaker> Heffalump: scanl
05:27:49 <Heffalump> Peaker: huh?
05:28:01 <Peaker> Heffalump: seems scanl does what I want here..
05:28:06 <icqn> Is there an easy way to find out the implementation of the length function?
05:28:15 <Heffalump> oh, I see
05:28:20 <luqui> @src length
05:28:20 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
05:28:28 <Heffalump> I didn't think about the effects of your definition, just the mechanics :-)
05:28:30 <johan____> oh man i never knew how many great papers there are at haskell.org/haskellwiki/Reseach_papers !!
05:28:34 <Heffalump> yes, that's much nicer
05:28:36 <luqui> http://www.haskell.org/onlinereport/standard-prelude.html
05:28:39 <johan____> too bad i have so little time
05:28:43 <luqui> icqn, ^^^
05:28:47 <vixey> it's only possible to write  fmap' :: (u <-> v) -> T u -> T v
05:29:16 <Eridius> hrm, how do you uniquely identify the latest commit in a darcs repo?
05:31:33 <vixey> but I don't know how to program this thing.. it's annoying
05:32:02 <vixey> something to do with free variables I think
05:32:27 <Peaker> vixey: a<->b means  (a->b, b->a) ?
05:32:57 <icqn> Why if I load the same implementation of the length function for example called myLength in ghci it operates at least 7 times slower?
05:33:49 <vixey> johan___: Reseach papers -- (There is currently no text in this page)
05:34:04 <vixey> oh I found it
05:34:23 <luqui> icqn, because the length function has been compiled with optimization
05:34:37 <luqui> icqn, in ghci, it is being run in an interpreter
05:35:20 <luqui> icqn, put myLength in a file, and then compile it with ghc -O2, and you will see the same performance.
05:35:24 <vixey> does anyone have some more advice/ideas about how to deal with syntax  with free vars?
05:35:46 <luqui> vixey, other than locally nameless?
05:36:09 <icqn> luqui, and why is the default implementation of lenght is not tail-recursive?
05:36:39 <L-Spiro> printItemCount (x:xs) (y:ys) = do -- How do I pass the full list (y:ys)  to another function that accepts a list?
05:36:52 <luqui> icqn, because ghc optimizes it to be anyway.  tail recursion is often  *not* what you want in Haskell, by the way.
05:37:06 <L-Spiro> Just use (y:ys)?
05:37:10 <luqui> L-Spiro, yep
05:37:10 <jeffz`> L-Spiro: or foo@(y:ys)
05:37:25 <vixey> I already use de bruijn indices what do you mean
05:38:08 <luqui> vixey, right,  locally nameless uses names for the context and de bruijn indices for subterms
05:38:13 <luqui> is that what you're doing?
05:38:24 <luqui> so when you dive under a lambda, you allocate a fresh name.
05:38:38 <vixey> luqui I have two kinds of syntax each binds 2 kinds of variable
05:39:20 <icqn> luqui, Ok. Thank you.
05:39:32 <L-Spiro> let myOldNumbersList = Map.findWithDefault [] "NUMBERS" $ myMap -- Does not work.  I want to get the list itself.
05:39:43 <L-Spiro> Once this line works I think the program is complete.
05:39:53 <luqui> L-Spiro, what do you mean the list itself?
05:40:01 <L-Spiro> The list under key "NUMBERS".
05:40:07 <luqui> that's exactly what that does.
05:40:24 <L-Spiro> That's what I thought when I tried it but I am getting an error.
05:40:31 <luqui> what error?
05:40:32 <L-Spiro> Let me check the line number.
05:41:01 <L-Spiro> Oh it's on line 84.  Anyone know what is wrong with that line?
05:41:26 <L-Spiro> (Just kidding hold on.)
05:41:43 <L-Spiro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=925#a925
05:41:46 <L-Spiro> Last line has the error.
05:42:42 <luqui> L-Spiro, looks like you are trying to apply a list to another list
05:42:45 <L-Spiro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=926#a926
05:42:46 <luqui> which... doesn't make sense
05:42:51 <L-Spiro> Apply?
05:43:02 <vixey> ($)
05:43:11 <luqui> L-Spiro, oh!  lose the parens in the last line
05:43:21 <luqui> printItemCount (myNumbersList myOldNumbersList)
05:43:24 <L-Spiro> Oh right.
05:43:27 <luqui> this passes printItemCount only one argument
05:43:28 <Eridius> arg, if yi used git it would be trivial for me to figure out why Yi/UI/Cocoa/TextStorage.hs uses pendingUpdates (a function that appears to not be defined, maybe the precursor to pendingUpdatesA) and perhaps figure out how to fix it. I can't figure out this stuff with darcs :/
05:43:29 <L-Spiro> That would group them as one parameter.
05:43:38 <Eridius> guess I'm not getting yi installed
05:44:02 <Peaker> its hard to import forM. Whenever I type "forM", "forM_" comes out :-P
05:44:05 <L-Spiro> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=927#a927
05:44:11 <luqui> Eridius, yeah, too bad.  I had trouble too.  also darcs sucks.
05:44:13 <Peaker> (I had to use 2 backspaces to type this too)
05:44:28 <Eridius> darcs is theoretically cool, but practically it's unusuable
05:44:38 <Eridius> in theory, theory and practice are the same. In practice, they're not :/
05:44:53 <vixey> I don't like that slogan
05:44:55 <L-Spiro> It is whining about the type of the second argument.
05:45:02 <L-Spiro> It is the same as the first type, as it should be.
05:45:03 <L-Spiro> WTF.
05:45:30 <luqui> L-Spiro, what does ghci say the type of printItemCount is?
05:45:42 <luqui> (you might have to comment out main to get it to load the file)
05:45:51 <mstr> @type Read
05:45:52 <lambdabot> Not in scope: data constructor `Read'
05:46:00 <mstr> @type Show
05:46:02 <lambdabot> Not in scope: data constructor `Show'
05:46:52 <Eridius> hrm, there exists such a term as a "sexy prime"
05:47:02 <L-Spiro> printItemCount :: [[Char]] -> [[[Char]]] -> IO ()
05:47:23 <luqui> L-Spiro, okay.  [Char] = String, so that's [String] -> [[String]] -> IO ()
05:47:31 <luqui> is that what it should be?
05:47:44 <L-Spiro> The return type of printItemCount?
05:47:53 <L-Spiro> Should be void.
05:47:56 <luqui> L-Spiro, well, the whole type.
05:48:04 <luqui> it takes a list of strings, and a list of lists of strings
05:48:15 <luqui> I'm guessing the second argument ([[String]]) is wrong
05:48:21 <L-Spiro> printItemCount (x:xs) (y:ys)
05:48:25 <L-Spiro> It is defined that way.
05:48:43 <luqui> riii..ght.
05:48:47 <luqui> and?
05:48:51 <L-Spiro> I want it to take 2 lists.
05:48:57 <L-Spiro> And I am giving it 2 lists.
05:49:03 <luqui> L-Spiro, oh, I see your error
05:49:11 <L-Spiro> printItemCount [] (x:xs) = return ()?
05:49:12 <luqui> it's actually in countStrings
05:49:19 <luqui> can you spot it?
05:49:58 <luqui> you know, you don't have to say (x:xs) every time you take a list as an argument.  you can name it whatever you want; only use (x:xs) when you want separate access to the head (x) and the tail (xs) of the list
05:49:58 <L-Spiro> x should be (x:xs).
05:50:03 <mstr> @type read
05:50:03 <lambdabot> forall a. (Read a) => String -> a
05:50:32 <mjb> L-Spiro: Putting explicit function signatures will problably help you. The compiler is inferring a different type than you think.
05:50:34 <luqui> you could write:  countStrings str xs = length . filter (== str) $ xs
05:50:56 <L-Spiro> countStrings str (x:xs) = length . filter (== str) $ (x:xs) is okay?
05:51:00 <luqui> incidentally, you can eta-contract that to:  countStrings str = length . filter (== str)
05:51:13 <mauke> L-Spiro: (x:xs) is pointless there
05:51:21 <L-Spiro> It fills my heart with warmth.
05:51:31 <mauke> but it looks inefficient
05:51:35 <L-Spiro> And lets my potential employer know that I am still knew at this language.
05:51:45 <luqui> haha
05:51:51 <L-Spiro> If my code is too professional he is going to know I did not write it.
05:51:56 <luqui> well, there are really no problems with that
05:52:03 <Axman6> ha
05:52:08 <luqui> eg. implementing categorize in full instead of using a simple filter :-)
05:52:16 <bohdan> L-Spiro: so this is a homework from your job interview?
05:52:24 <L-Spiro> Something like that.
05:52:35 <bohdan> L-Spiro: isn't is, umm, cheating, to ask other people to help you?
05:52:36 <nodogbite> L-Spiro: you have a potential employer who wants you to know haskell?
05:52:41 <Axman6> @users
05:52:41 <lambdabot> Maximum users seen in #haskell: 645, currently: 593 (91.9%), active: 22 (3.7%)
05:52:46 <Badger> heh
05:52:50 <Badger> #haskell does homework :P
05:52:56 <L-Spiro> bohdan, no.  He knows I do not know the language.  It is just standard testing procedures.
05:53:12 <luqui> learn haskell and make something in it.  tough interview question!
05:53:16 <L-Spiro> I applied as a Windows programmer.
05:53:18 <luqui> awesome though :-)
05:53:28 <nodogbite> wow, haskell is standing testing procedure?
05:53:33 <nodogbite> what city is the job in?
05:53:36 <L-Spiro> TOkyo.
05:53:52 <luqui> it certainly tests whether you can get out of your thinking rut.
05:53:56 <mauke> ah, tokyo. too many alien/monster/robot attacks for my taste
05:53:58 <L-Spiro> This is more a test to see how well I learn.
05:54:04 <nodogbite> L-Spiro: don't let the boss know about #haskell.  he'll just hire a smart guy from there
05:54:12 <luqui> lol
05:54:20 <L-Spiro> Obviously.
05:54:33 <luqui> I don't remember who said it, but I will butcher and paraphrase.
05:54:49 <mauke> nodogbite: if this is a test of your learning abilities, he might ask you to write something in C#/Perl/Prolog if you already know Haskell
05:54:57 <L-Spiro> Ruby.
05:55:02 <L-Spiro> Is next.
05:55:09 <L-Spiro> But he knows I don't know Haskell.
05:55:14 <luqui> "It's hard to hire haskell programmers.  If you ask them to come work for you, they'll say 'sure, I'll come work for you, where by 'come' I mean 'stay here' and 'work' I mean 'keep doing what I'm doing' "
05:55:14 <bohdan> luckily for you, there's #ruby :)
05:55:27 <L-Spiro> Indeed.
05:55:49 <mauke> as far as I'm concerned, the main difference between Perl and Ruby is the boolean value of 0 :-)
05:55:56 <luqui> lol
05:56:07 <L-Spiro> Then I hope Perl is the next language I have to learn.
05:56:16 <bohdan> although this sort of shows that it's pointless to give homework for job interviews
05:56:18 <luqui> L-Spiro, nah, epigram is next
05:56:22 <luqui> >=)
05:56:28 <Badger> befunge :P
05:56:33 <bohdan> because there's always #haskell, #c++, #perl
05:56:45 <L-Spiro> bohdan, I will be completely open about how I got the results.
05:56:49 <L-Spiro> Should he ask.
05:57:00 <luqui> are you saying that using the resources at your disposal to learn something is cheating?  or pointless?
05:57:08 <bohdan> L-Spiro: then, isn't it in your best interest to actually learn the language?
05:57:18 <luqui> #haskell is *the* best way to learn haskell.  beats all those crappy tutorials.
05:57:18 <bohdan> L-Spiro: or is the goal to just "finish as quick as possible"?
05:57:27 <bohdan> then you could hire someone from here for $10
05:57:38 <L-Spiro> bohdan, I plan to learn it if needed but I actually applied as a Windows programmer.
05:57:49 <luqui> well a smart interviewer would assign this homework, then ask a real-time question tomorrow.
05:57:58 <luqui> when there is no #haskell to fall back on
05:58:06 <bohdan> luqui: very good point
05:58:07 <L-Spiro> Which is why I asked so many questions about how things work.
05:58:17 <L-Spiro> And I commented all of my code as you can see.
05:58:50 <bohdan> luqui: but I would still say reading tutorial and /then/ asking about things that are unclear is much more effecient
05:59:28 <L-Spiro> Basically my attitude going into the meeting would be, "If I don't know the answer, I know how to get the answer."
05:59:52 <bohdan> luqui: tutorials usually make a point of explaining something correctly, #haskell -- not necessarily
05:59:54 <L-Spiro> "As long as you allow IRC at work."
06:00:17 <L-Spiro> Maybe I won't say that last part.
06:00:39 <bohdan> L-Spiro: well how long would it take you to get the answer from irc? compared to writing it on your own if you know the language?
06:00:54 <bohdan> L-Spiro: for me it's usually an order of magnitude
06:00:58 <L-Spiro> bohdan, no one said I am not also trying to learn it for my self.
06:01:26 <bohdan> L-Spiro: that's the impression I get from the sort of questions you're asking
06:01:31 <L-Spiro> I am studying what people gave me and asking questions and reading tutorials for my own good.
06:01:50 <ehird> <bohdan> luqui: but I would still say reading tutorial and /then/ asking about things that are unclear is much more effecient
06:01:52 <ehird> yes, I agree
06:01:52 <bohdan> L-Spiro: ok by no means I'm trying to persuade you to do or not do something
06:02:38 <L-Spiro> I do not like to be carried by others, but frankly I have to admit in this case I need to focus more on results now.
06:02:52 <L-Spiro> It's at that point.
06:03:02 <bohdan> I'm just thinking aloud -- spending 12 hours in #haskell is not how *I* learned the language, so I'm trying to decide whether I was right in doing what I did or not
06:03:03 <L-Spiro> But mind you I did do a lot of the program on my own as well.
06:03:34 <L-Spiro> I wasn't really here that long.  It's been about 24 now.
06:03:40 <L-Spiro> Err.
06:04:05 <bohdan> L-Spiro: I clearly remember seeing you come in when I went to bed yesterday :)
06:04:11 <ehird> I don't think spending time in #haskell will make you learn Haskell properly.
06:04:20 <L-Spiro> It's not my plan.
06:04:49 <Saizan> maybe if we stop this whole meta- discussion then it's more likely :)
06:04:56 <L-Spiro> But you should understand balancing between personal gain and getting results.
06:05:07 <L-Spiro> I just ran it and it works.
06:05:24 <L-Spiro> So kudos to everyone here but the 580 who sat and laughed at me.
06:05:37 <ehird> oh boy, how dramatic
06:06:00 <L-Spiro> I guess comedy doesn't translate well in text all the time.
06:06:15 <bohdan> #haskell is great, it can answer a question in 30 seconds that you would spend hours researching :) also I can see why people flock to it...
06:06:17 <L-Spiro> But trust me, that was really comedy.  Of the highest degree.
06:06:18 <Guenni> hpaste seems down, is there a fallback?
06:06:29 <Saizan> @where hpaste2
06:06:29 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
06:06:49 <ehird> perhaps we define comedic degrees differently :p
06:07:09 <L-Spiro> Trust me, if you defined it my way you would be laaaughing.
06:07:18 <Guenni> Saizan: thx
06:07:40 <ehird> Is laaaaughing like laughing but with more 'a's than 'h's?
06:07:49 <ehird> Like, Aaaaahaaahaaahaaaaahaaaaaaahaaa
06:08:13 <L-Spiro> Yes.  It hurts the other way around.  At least for me.
06:08:23 <L-Spiro> Here is my final code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=928#a928  Just one more question on style.
06:08:42 <L-Spiro> Is it normal to separate those functions into modules?
06:08:51 <L-Spiro> And is my main too long?
06:09:06 <L-Spiro> I mean I could break that up into more functions too/.
06:09:14 <ehird> Wellll...
06:09:24 <ehird> If you're going for style, categorise shohuld just be a filter, I mean.
06:09:26 <bohdan> > "L" ++ (replicate 80 'a') ++ "ughing" -- ?
06:09:28 <lambdabot>   "Laaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
06:09:47 <ehird> Also, generally top-level declarations include type signatures.
06:10:00 <L-Spiro> The do what?
06:10:10 <ehird> ...
06:10:13 <ehird> What?
06:10:15 <Guenni> I'd need some help rewriting this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=929#a929 in point free style
06:10:25 <ehird> L-Spiro: do you know what a type signature is?
06:10:25 <L-Spiro> Give me an example of a top-level declaration in there.
06:10:31 <L-Spiro> VAR :: TYPE
06:10:34 <ehird> ... isCategory, categorise, countStrings
06:10:36 <ehird> printItemCount
06:10:38 <ehird> main.
06:10:43 <L-Spiro> Oh, functions.
06:11:09 <bohdan> Guenni: it looks incomplete
06:11:09 <L-Spiro> I am right about the type declaration right?
06:11:25 <ehird> Yes.
06:11:33 <ehird> Guenni: That got cut off.
06:11:38 <ehird> Also, it's amend
06:11:40 <ehird> not ammend
06:11:42 <Guenni> bohdan: it is, just not very pfs
06:11:58 <bohdan> pfs??
06:12:06 <Guenni> ehird: the rest of the code isn't important
06:12:16 <ehird> It looks absolutely fine to me.
06:12:16 <Guenni> bohdan: point free style
06:12:22 <ehird> Pointfreeness would surely only obfuscate it.
06:12:27 <L-Spiro> Since I come from a C/C++ background the organizational styles I would be more likely to make are those involving breaking it up into more modules.
06:12:31 <ehird> @pl \dbc fabs -> handleSqlError $ amendFabs' dbc fabs
06:12:31 <lambdabot> (handleSqlError .) . amendFabs'
06:12:38 <L-Spiro> Would that be appropriate here or is it too small?
06:12:46 <bohdan> @pl \a b = handleSqlError $ f a b
06:12:46 <lambdabot> (line 1, column 6):
06:12:46 <lambdabot> unexpected "="
06:12:46 <lambdabot> expecting pattern or "->"
06:12:47 <ehird> L-Spiro: just give them type signatures. and make categorise a filter
06:12:55 <ehird> Guenni: I'd leave it as is.
06:12:57 <Guenni> ehird: thx,
06:13:01 <bohdan> ah someone beat me to it :)
06:13:01 <ehird> except rename ammendFabs to amendFabs
06:13:18 <Guenni> well there are about 10 other functions I need to "wrap" too
06:13:19 <L-Spiro> What is the type signature for a function that does not return anything?  Something about IO.
06:13:42 <L-Spiro> isCategory :: Boolean x = all isUpper x  -- Well I failed.
06:13:56 <ehird> <L-Spiro> What is the type signature for a function that does not return anything?  Something about IO.
06:14:00 <ehird> I think you might want to learn Haskell.
06:14:54 <L-Spiro> I think I should just not put these type signatures into there because that would show that I was somehow unnaturally "familiar" with the language in only 5 hours.
06:15:08 <ehird> then why are you asking for style help...
06:15:32 <L-Spiro> I wanted to confirm the 2 types of style changes I actually would make.
06:15:37 <bohdan> this is amazingly hypocritic
06:15:45 <ehird> bohdan: huh?
06:15:50 <L-Spiro> Which would be to break the main into smaller functions and to use multiple modules.
06:15:55 <bohdan> "I want it to be perfect but don't want it to look as of someone helped me"
06:15:59 <ehird> bohdan: well, yeah
06:16:01 <Saizan_> L-Spiro: an overview of the syntax by looking at e.g. the code in the standard Prelude would help
06:16:03 <ehird> they're contradictory goals
06:16:04 <Saizan_> @where report
06:16:05 <lambdabot> http://www.haskell.org/onlinereport/
06:16:10 <Zao> L-Spiro: You can always blame C-ish languages that force you to have them :)
06:16:13 <ehird> yikes, the online report
06:16:22 <ehird> it is a time machine. to 2002 :D
06:16:24 <luqui> L-Spiro, btw, just about every tutorial you come across will suggest you write type signatures
06:16:26 <Saizan_> L-Spiro: http://www.haskell.org/onlinereport/standard-prelude.html
06:16:29 <Martijn> @djinn (a -> b -> c) -> (a, a) -> (b, b) -> (c, c)
06:16:29 <lambdabot> f a (b, _) (c, _) = (a b c, a b c)
06:16:44 <L-Spiro> ehird and bohdan, you seem to have misunderstood my request.  I pointed out 2 very specific stylization points and only asked for confirmation on those.
06:16:48 <luqui> I think as long as your sigs are not polymorphic you will still seem beginner :-)
06:17:17 <Twey> What's the proper procedure to get a PixelFormat out of a Surface in SDL?
06:17:18 <luqui> L-Spiro, I doubt this code needs multiple modules.  Smaller functions are always a good idea.
06:17:22 <ehird> L-Spiro: I apologize profusely for giving the advice that I would give to someone actually trying to learn Haskell.
06:17:32 <bohdan> L-Spiro: let's say it this way, if you wrote the code yourself, you would know everything about type signatures
06:17:32 <L-Spiro> ehird, no, that isn't it.
06:17:45 <jeffz`> Twey, if you created it, shouldn't you already know?
06:17:47 <bohdan> L-Spiro: every book and every tutorial explains them /before/ explaining IO
06:17:52 <Saizan_> bohdan, ehird: being hostile doesn't help anyone.
06:17:53 <Twey> It's looking like it needs to go something like surfaceGetPixelFormat surface >>= ForeignPtr
06:18:03 <bohdan> Saizan_: I'm not hostile
06:18:12 <Twey> But that can't be right
06:18:13 <ehird> Saizan_: I tried to help sincerely at first, but I can't help people with contradictory goals.
06:18:15 <L-Spiro> But, ehird, outside of the two points I made, I reserve the right to deny some advice without being called a hypocrite.
06:18:16 <Twey> jeffz`: Uhm, no?
06:18:20 <bohdan> Saizan_: although I'm ethically against helping people on their homework
06:18:26 <Saizan_> ehird: you don't need to help him
06:18:33 <Martijn> @pl \f g (x1, y1) (x2, y2) = (f x1 x2, g y1 y2)
06:18:34 <lambdabot> (line 1, column 24):
06:18:34 <lambdabot> unexpected "="
06:18:34 <lambdabot> expecting pattern or "->"
06:18:42 <L-Spiro> You can help, just don't call me a hypocrite.
06:18:44 <Martijn> @pl \f g (x1, y1) (x2, y2) -> (f x1 x2, g y1 y2)
06:18:46 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
06:18:52 <dublpaws> L-Spiro's political capital wearing thin, needs food badly
06:18:54 <L-Spiro> Phone.
06:19:08 <Twey> jeffz`: It was created by SDL.setVideoMode
06:19:27 <ehird> dublpaws: :-)
06:19:29 <beelsebob> Martijn: f *** g
06:19:44 <ehird> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
06:19:47 <ehird> That is beautiful.
06:19:54 <ehird> It's the source code to computation itself.
06:19:58 <ehird> :-P
06:20:00 * Twey twitches.
06:20:08 <Martijn> beelsebob: are you sure?
06:20:09 <Saizan_> @quote tropical
06:20:09 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
06:20:12 <beelsebob> > ((+) *** (*)) (1,2) (3,4)
06:20:13 <lambdabot>   Couldn't match expected type `t1 -> t'
06:20:17 <beelsebob> o.O
06:20:17 <ehird> haha
06:20:23 <beelsebob> @type (***)
06:20:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:20:27 <hackage> Uploaded to hackage: hlongurl 0.9.3
06:20:42 <beelsebob> oh, that's not right
06:20:53 <ehird> hlongurl?
06:21:04 <ehird> I think we have the most pointless package ever on our hands.
06:21:16 <ehird> hlongurl library and program: Library and utility interfacing to longurl.org
06:21:17 <Twey> Peaker!
06:21:18 <ehird> Yep.
06:21:18 <Saizan_> @hackage hlongurl
06:21:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlongurl
06:21:33 <Twey> You've done this, although your code doesn't look like it type-checks...
06:21:38 <ehird> ah, wait
06:21:42 <ehird> longurl is not what I thought
06:21:49 <ehird> it expands tiny url services to their real location
06:21:53 <ehird> in case, umm
06:21:57 <Peaker> Twey: what?
06:21:57 <ehird> clicking them was too hard.
06:22:03 <ehird> ... yeah, still pointless
06:22:05 <mmorrow> the gcc "labels as values" extension is sweet http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=930
06:22:11 <Twey> Peaker: SDL.mapRGB
06:22:18 * mmorrow has never used it before
06:22:25 <Peaker> Twey: what code of mine?
06:22:37 <Twey> I can't work out how I'm meant to get hold of a PixelFormat without buggering about with ForeignPtr :-\
06:22:37 <Peaker> Twey: I have:
06:22:38 <Peaker> sdlPixel :: SDL.Surface -> Color -> IO SDL.Pixel
06:22:39 <Peaker> sdlPixel surface (r, g, b) = SDL.mapRGB (SDL.surfaceGetPixelFormat surface) r g b
06:22:40 <ehird> mmorrow: Indeed
06:22:45 <Twey> Uhm, something, found it on hpaste
06:22:55 <Peaker> Twey: you get the pixel format from a surface
06:22:59 <bohdan> ehird: well one reason could be that you suspect a rickroll or goatseroll and don't want to fall for it
06:23:03 <Peaker> Twey: coincidentally I am working on my SDL widget set as we speak :)
06:23:08 <Peaker> Twey: a functional widget set
06:23:12 <Badger> :
06:23:13 <Badger> :o
06:23:15 <Peaker> (No monads in sight, yet)
06:23:17 <ehird> bohdan: yes but the point is to use it in a site, I think
06:23:22 <ehird> to expand URLs people post
06:23:28 <ehird> but, umm, just load it and check the Location header...
06:23:28 <Twey> Peaker: Does that type-check?  When I do that it says IO PixelFormatStruct found, PixelFormat expected
06:23:54 <ehird> [[We support all services (even ones not on the list),]]
06:23:55 <bohdan> ehird: right, "curl | grep 'Location' "
06:24:05 * ehird invents URL shortening service that specifically doesn't work for it
06:24:18 <ehird> "also, we are never down" :-P
06:24:33 <Twey> Oh hang on
06:24:37 <Twey> Maybe I'm being an idiot
06:25:06 <Twey> Ah, yes, I am
06:25:09 <Peaker> Twey: surfaceGetPixelFormat :: Surface -> PixelFormat
06:25:12 <Twey> Heh, unrelated error
06:25:15 <Twey> Yeah :)  Thanks
06:27:04 <lilac> L-Spiro: i'd put everything between the 'readFile' and 'putStrLn $ "Unique animals " ++ ...' into a separate function
06:28:34 <lilac> L-Spiro: also, i don't think your module is too big
06:28:52 <Martijn> @kaas
06:28:52 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
06:28:57 <Martijn> @kaas
06:28:57 <lambdabot> haskell always said undefined
06:29:05 * Martijn ponders.
06:30:07 <mmorrow> @. vixen kaas
06:30:07 <lambdabot> Plugin `compose' failed with: Unknown command: "kaas"
06:30:26 <mmorrow> @. vixen nixon
06:30:27 <lambdabot> If something takes a lot of effort to do, it probably ain't worth doing.
06:30:59 <Twey> > fix ([]++)
06:31:01 <lambdabot>   * Exception: stack overflow
06:31:10 <luqui> @nixon
06:31:10 <lambdabot> The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now, let's face it, they are.
06:31:15 <Twey> lambdabot took _|_ seconds to return []!
06:31:47 <lilac> lambdabot took (fix Succ) seconds to return _|_!
06:31:54 <Twey> Heheheh
06:32:13 <bohdan> how does @bf work?
06:32:26 <bohdan> @bf ++++++++++[>+++++++++++++++<-].
06:32:26 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
06:32:31 <Twey> It doesn't
06:32:58 <Martijn> Apparently :-)
06:33:58 <impomatic> @bf ++++++++++++++[>+++++>+++++++>+++>+<<<<-]>++.>+++.+++++++..+++.>++.>[<-<<+>>>-]<++.<<+.>.+++.------.--------.>+.
06:33:58 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
06:34:03 <lilac> well, that's just because it's not a brainfuck interpreter, it's a bainfuck interpreter
06:34:05 <impomatic> Hmmm...
06:34:07 <ehird> if you want to run bf there's a bot in #esoteric that does it.
06:34:08 <bohdan> how negligent
06:34:11 <lilac> @help bf
06:34:11 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
06:34:13 <Twey> Haha
06:34:15 <ehird> :)
06:34:28 <ehird> not bainfuck, bainf*ck. duh.
06:34:38 <lilac> silly me
06:34:40 <ehird> @bf  fd:7: hClose: resource vanished (Broken pipe)
06:34:40 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
06:34:45 <ehird> Kimian quine!
06:34:53 <impomatic> bf ++++++++++++++[>+++++>+++++++>+++>+<<<<-]>++.>+++.+++++++..+++.>++.>[<-<<+>>>-]<++.<<+.>.+++.------.--------.>+.
06:46:17 <Martijn> :t join
06:46:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:46:43 <Martijn> :t join :: ((->) ((->) a)) -> ((->) a)
06:46:45 <lambdabot>     `(->) a' is not applied to enough type arguments
06:46:45 <lambdabot>     Expected kind `??', but `(->) a' has kind `? -> *'
06:46:45 <lambdabot>     In the type `(->) ((->) a)'
06:47:37 <Martijn> join (+) 2
06:48:06 <Martijn> > join (+) 2
06:48:08 <lambdabot>   4
06:48:42 <mauke> :t join (->) e ((->) e a) -> (->) e a
06:48:43 <lambdabot> parse error on input `->'
06:48:49 <mauke> :t join :: (->) e ((->) e a) -> (->) e a
06:48:51 <lambdabot> forall e a. (e -> e -> a) -> e -> a
06:50:26 <Martijn> Haskeline has become a very cool package
06:50:37 <Martijn> I'm currently working on migrating Yogurt to use it
06:50:42 <Martijn> Instead of readline
06:51:42 <lilac> > let cat "NUMBERS"=True; cat "ANIMALS"=True; cat _=False in map (fst.head &&& concatMap snd) . groupBy ((==)`on`fst) . sort . map (head &&& tail) . groupBy (\a b -> cat a && not (cat b)) $ lines file
06:51:44 <lambdabot>   [("ANIMALS",["moose","sheep","horse","cow","horse"]),("NUMBERS",["one","thr...
06:51:55 <lilac> do i win a job?
06:52:53 <bodq> ehird: re: homewor, I tried to ask newbie questions in #python
06:53:09 <bodq> ehird: <name> bodq: read the damn tutorial -- that's one of the answers
06:53:23 <ehird> yeah well #python are dicks :)
06:53:36 <luqui> with a stupid language for jerks
06:53:39 <luqui> %-)
06:53:44 <bodq> although I got a handful of answers too
06:55:06 <bodq> I guess newbies are a bigger problem on #python
06:55:34 <lilac> > let cat "NUMBERS"=True; cat "ANIMALS"=True; cat _=False in map (fst.head &&& nub.sort.concatMap snd).groupBy ((==)`on`fst).sort.map(head&&&tail).groupBy(\a b->cat a&&not(cat b))$lines file
06:55:36 <lambdabot>   [("ANIMALS",["cow","horse","moose","sheep"]),("NUMBERS",["one","seven","six...
06:56:00 <luqui> > file
06:56:01 <lambdabot>   "NUMBERS\none\nthree\ntwo\none\nthree\nANIMALS\nsheep\nhorse\ncow\nhorse\nN...
06:56:51 <luqui> > map head . lines $ file
06:56:52 <lambdabot>   "NottotAshchNsANssAm"
06:57:07 <luqui> oh.  whew.  excuse me.
06:57:22 <lilac> > map(fst.head &&& nub.sort.concatMap snd).groupBy((==)`on`fst).sort.map(head&&&tail).groupBy(\(a:_)(b:_)->isUpper a&&isLower b)$lines file
06:57:24 <lambdabot>   [("ANIMALS",["cow","horse","moose","sheep"]),("NUMBERS",["one","seven","six...
06:58:08 <lilac> anyone for golf?
07:03:27 <luqui> lilac, fwiw, I'm trying... :-)
07:04:00 <bodq> lilac: luqui: what's the assignment exactly?
07:04:48 <lilac> > map(head.head&&&(>>=tail)).groupBy(on(==)head).sort.groupBy(\(a:_)(b:_)->isUpper a&&isLower b)$lines file
07:04:50 <lambdabot>   [("ANIMALS",["moose","sheep","horse","cow","horse"]),("NUMBERS",["one","thr...
07:05:15 <luqui> lilac, wow.  yikes.
07:05:28 <luqui> > file
07:05:29 <lambdabot>   "NUMBERS\none\nthree\ntwo\none\nthree\nANIMALS\nsheep\nhorse\ncow\nhorse\nN...
07:05:54 <luqui> capitals are categories, lowercase are data.  categorize the data, then sort and nub each category
07:05:56 <lilac> bodq: you're given a file with capitalized categories and lowercase entries, and have to coalesce
07:06:40 <lilac> luqui: do you like my evil groupBy trick? :)
07:06:58 <byorgey> lilac: that's pretty evil =)
07:07:15 <luqui> lilac, yeah I was just studying that.
07:07:24 <Martijn> Could someone please help me with this? I've done cabal install haskeline, but then:
07:07:34 <Martijn> Prelude System.Console.Haskeline> runInputT defaultSettings (getInputLine "> ")
07:07:34 <Martijn> Loading package syb ... linking ... <interactive>:
07:07:34 <Martijn> ghc: unable to load package `syb'
07:07:38 <Raevel> what can i do about this?
07:07:38 <luqui> I still don't get nubBy, groupBy, etc.  when they don't meet the implicit laws
07:07:42 <Raevel> > let n = 6077 in (ceiling (sqrt n))^2 - n
07:07:43 <lambdabot>   Add a type signature
07:07:52 <lilac> luqui: i think the report doesn't specify what it should do
07:07:57 <Raevel> i don't really see where to put it
07:08:00 <luqui> I have always thought it should be nubOn, groupOn, etc., which map to typeclasses
07:08:22 <Martijn> uhm, it omitted the most important line, which says: unknown symbol `_iconv_close'
07:08:24 <byorgey> Raevel: the sqrt requires n to be floating, but the subtraction requires it to be integral.
07:08:29 <byorgey> Raevel: what type is n?
07:09:01 <Raevel> Num a => a
07:09:10 <byorgey> Martijn: do you have the syb package installed?  is it listed in the output of ghc-pkg list?
07:09:21 <bodq> so what is the criteria for gold? number of characters or number of parser tokens?
07:09:46 <luqui> bodq, short enough for a line on #haskell and so elegant that it makes us cry
07:09:48 <byorgey> Raevel: ah, well, you'll have to choose.  If I were you I'd put a call to 'fromIntegral' inside the sqrt
07:10:12 <Saizan_> Martijn: the ghci linker is somewhat picky, does the same code work when compiled?
07:10:16 <Raevel> byorgey: okay, thanks :-)
07:10:32 <dcoutts> Martijn: what platform btw?
07:11:00 <Martijn> byorgey: yes, syb-0.1.0.0 is listed
07:11:29 <Martijn> byorgey: in the /Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.1/./package.conf secion, not in my local home section
07:11:37 <Martijn> dcoutts: Mac Intel Leopard
07:11:44 <Martijn> Saizan: Let me try
07:15:26 <Martijn> Saizan: no, the linker complains if I try to compile a program that uses Haskeline:
07:15:26 <Martijn> [1 of 1] Compiling Main             ( HaskelineTest.hs, HaskelineTest.o )
07:15:26 <Martijn> Linking HaskelineTest ...
07:15:26 <Martijn> Undefined symbols:
07:15:26 <Martijn>   "_iconv_open", referenced from:
07:15:27 <Martijn>       _s9Qq_info in libHShaskeline-0.6.0.1.a(IConv.o)
07:15:29 <Martijn>   "_iconv_close", referenced from:
07:15:29 <dcoutts> Martijn: so I think I know the problem
07:15:31 <Martijn>       _iconv_close$non_lazy_ptr in libHShaskeline-0.6.0.1.a(IConv.o)
07:15:33 <Martijn>   "_iconv", referenced from:
07:15:35 <Martijn>       _sa10_info in libHShaskeline-0.6.0.1.a(IConv.o)
07:15:37 <Martijn> ld: symbol(s) not found
07:15:39 <Martijn> collect2: ld returned 1 exit status
07:15:47 <dcoutts> Martijn: on OSX there is no iconv function, it's a macro
07:15:59 <dcoutts> so ffi importing it does not work
07:16:19 <Martijn> dcoutts: which is what haskeline does?
07:16:24 <dcoutts> Martijn: right
07:16:55 <dcoutts> Martijn: would you mind checking the iconv.h file and pasting somewhere the definition of the iconv macro?
07:17:01 <dcoutts> @hpaste
07:17:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:17:10 <dcoutts> doh, it's still down
07:17:15 <dcoutts> some other pastebin
07:17:17 <Saizan_> @where hpaste2
07:17:18 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
07:17:29 <lilac> > map(head.head&&&(>>=tail)).groupBy(on(==)head).sort.groupBy(on(/=)(isUpper.head))$lines file
07:17:31 <lambdabot>   [("ANIMALS",["moose","sheep","horse","cow","horse"]),("NUMBERS",["one","thr...
07:18:47 <Martijn> dcoutts: locate iconv.h lists several such files. Do you know which one you want?
07:19:14 <dcoutts> Martijn: whichever looks like the standard system one, the one that would be found by gcc when you #include <iconv.h>
07:19:50 <Martijn> dcoutts: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=932#a932
07:20:04 <dcoutts> Martijn: /usr/include/iconv.h
07:20:09 <Martijn> dcoutts: I'm guessing the /usr/include one, then
07:20:19 <Martijn> dcoutts: (not much experience with gcc)
07:21:22 <Martijn> dcoutts: refresh that page for contents of /usr/include/iconv.h
07:23:17 <dcoutts> Martijn: hmm, that's interesting, it's not a macro there.
07:24:05 <Martijn> dcoutts: /opt/local/include/iconv.h has some differences with /usr/include/iconv.h
07:24:20 <dcoutts> Martijn: what version of haskeline are you using?
07:24:23 <Peaker> @info (.)
07:24:24 <lambdabot> (.)
07:24:37 <Peaker> 9 is the highest precedence? (.) is precedence 9
07:25:11 <Martijn> dcoutts: the latest, haskeline-0.6.0.1
07:25:53 <Martijn>  /opt/local/include/iconv.h uses extern instead of void in some places, among other differences
07:26:05 <dcoutts> Martijn: do you get the same problem with the iconv package on hackage?
07:27:35 <Martijn> dcoutts: how do i test that? cabal install iconv, and then just trying to compile HaskelineTest again?
07:27:48 <dcoutts> Martijn: then ghci -package iconv
07:29:06 <Martijn> dcoutts: yes, same problem: /Users/Martijn/.cabal/lib/iconv-0.4.0.2/ghc-6.10.1/HSiconv-0.4.0.2.o: unknown symbol `_iconv_close'
07:29:53 <dcoutts> Martijn: ok, can you try something like nm /usr/lib/libiconv.* | grep iconv_close
07:30:05 <dcoutts> Martijn: I'm not exactly sure what the lib file is called on osx
07:30:17 <Heffalump> dcoutts: is there a cabal feature request/todo item to diagnose that kind of problem (unspecified extension) better?
07:30:51 <dcoutts> Heffalump: yes, http://hackage.haskell.org/trac/hackage/ticket/370
07:31:25 <skorpan> i have imported Permissions from System.Directory and now i want to derive Typeable for it. is it possible?
07:31:55 <lilac> skorpan: with -XStandaloneDeriving i think so
07:32:10 <dcoutts> skorpan: yes, but only because the type is not abstract
07:32:19 <Martijn> Myrrh:trunk Martijn$ nm -o /usr/lib/libiconv.* | grep iconv_close
07:32:19 <Martijn> nm: file: /usr/lib/libiconv.la is not an object file
07:32:34 <Martijn> doh, it can't handle paths. i'll post in pastebin
07:32:44 <skorpan> dcoutts: hm... what do you mean by abstract? i may have misunderstood.
07:32:55 <dcoutts> skorpan: I mean all the constructors are exported
07:33:01 <skorpan> oh
07:33:03 <pejo> Martijn, libiconv.dylib
07:33:09 <dcoutts> Martijn: mm, I think we've not used the right file name
07:33:24 <Martijn> dcoutts: refresh paste page
07:33:26 <lilac> > map(head.head&&&nub.sort.(>>=tail)).groupBy(on(==)head).sort.groupBy(on(/=)(isUpper.head)).lines$file
07:33:28 <lambdabot>   [("ANIMALS",["cow","horse","moose","sheep"]),("NUMBERS",["one","seven","six...
07:35:07 <dcoutts> Martijn: hmm, I'm confused then. double check that ghc-pkg field iconv extra-libraries  does indeed list iconv
07:35:35 <skorpan> so the syntax is "deriving Typeable for Permissions" or what? because GHCi doesn't seem to like it
07:35:57 <Martijn> $ ghc-pkg field iconv extra-libraries
07:35:57 <Martijn> extra-libraries: iconv
07:35:59 <lunabot>  luna: Not in scope: `ghc'
07:36:08 <nikki93> Sup fellas!
07:36:41 <dcoutts> Martijn: I presume you're using ghc 6.10
07:37:03 <Martijn> dcoutts: yes, 6.10.1
07:37:03 <dcoutts> Martijn: you don't happen to have 6.8 installed too do you?
07:37:22 <Martijn> dcoutts: I think I do
07:37:53 <dcoutts> Martijn: could you try cabal install iconv -w ghc-6.8.whatever
07:38:03 <dcoutts> and then the same ghci-6.8.x -package iconv
07:38:34 <Martijn> ghci-6.8.2 works for me. So I do have 6.8 installed as well.
07:39:36 <Martijn> ghci-6.8.2 -package iconv works as well (after cabal install iconv -w ghc-6.8.2)
07:39:45 <dcoutts> mm
07:40:38 <Martijn> dcoutts: Should I uninstall ghc 6.8.2?
07:40:44 <dcoutts> Martijn: no
07:41:17 <dcoutts> Martijn: so if it's using /opt/local/include/iconv.h then I can see why it'd work with 6.8 and not 6.10, though really it should still work with 6.10 since the lib does export both symbols _libiconv_close and _iconv_close
07:42:24 <dcoutts> the solution is for the iconv binding to use a C wrapper function to work around the silly macros in iconv.h on osx
07:43:21 <dcoutts> Martijn: basically the packages that ffi import iconv need updating to work on osx with 6.10
07:43:47 <Martijn> dcoutts: so a fix in this case would mean modifying Haskeline source files?
07:43:59 <dcoutts> Martijn: yes
07:44:30 <dcoutts> Martijn: the better solution is to fix it once in the iconv package and for haskeline to use the iconv Haskell binding, rather than having two bindings.
07:45:29 <Martijn> dcoutts: so that is something Judah would have to consider, then?
07:45:53 <dcoutts> Martijn: yes, I should try to fix the iconv package and he should consider using it
07:47:57 <Martijn> dcoutts: I'm guessing I should be modifying System.Console.Haskeline.Backend.IConv
07:48:41 <dcoutts> Martijn: depends what you're trying to do
07:50:42 <Martijn> dcoutts: Good question :-) I'm not too sure
07:51:10 <][]> is LLVM a suitable platform for compiling a language like Haskell to?
07:51:17 <][]> oh whoop
07:51:18 <][]> s
07:51:21 * gwern is disgruntled. I release filestore and the only reaction is bickering over email headers -_-
07:51:33 <lilac> luqui: i believe the lhc people think not
07:51:44 <gwern> luqui: the lhc blog says it makes fast compilation difficult because of bad GC support
07:51:53 <cnwdup> @src ap
07:51:53 <lambdabot> ap = liftM2 id
07:52:08 <luqui> gwern, hmmm... ok.  that's a showstopper, since I need extra-good GC support.  :-)
07:52:40 <luqui> I wonder what would be good then.  Some sort of JIT is necessary; i.e. so I can compile an object and load it up and use it right away in the same program
07:52:41 <gwern> 'twould
07:52:58 <gwern> the java vm would be an obvious target
07:53:52 <luqui> jvm has good support for the kind of execution patterns haskell does.  I mean.. I guess I could always contort it.
07:53:58 * RayNbow is reading sigfpe's article on fast regexps and notices the "array (a,z) [(i, v) | i <- range (a,z)]" pattern...
07:54:02 <luqui> but you know, tail calls and HOFs and the like
07:54:20 <RayNbow> (a,z) appearing twice... there's room for abstraction! :p
07:54:21 <luqui> that was supposed to be a question.  (++ "?")
07:54:51 <gwern> luqui: and of course you could borrow previous code like lambdavm
07:54:59 <luqui> RayNbow, of course, and that abstraction is called listArray :-)
07:55:11 * luqui looks up lambdavm
07:55:13 <RayNbow> @hoogle listArray
07:55:14 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
07:55:14 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
07:55:14 <lambdabot> Data.Array.Base listArrayST :: Ix i => (i, i) -> [e] -> ST s (STArray s i e)
07:55:19 <byorgey> gwern: I think filestore is pretty cool =)
07:55:45 <lilac> @hoogle (Ix i) => (i,i) -> (i -> e) -> a i e
07:55:46 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
07:55:46 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
07:55:46 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
07:56:20 <byorgey> gwern: Ignore the bickering over which list it's sent to, it will all end up in the HWN anyway...
07:57:39 <luqui> gwern, thanks for the pointer, this could be viable.
07:57:57 <gwern> 'send to them all, byorgey will know his own!'
07:58:23 <byorgey> hehe, is that a quote from something?
07:58:39 * byorgey regrets not being cultured enough to recognize it, if so
07:58:53 <gwern> it's a modification of the famous quote from the Albigensian Crusade
07:59:06 <gwern> 'kill them all; god will know his own' as one translation goes
07:59:27 <byorgey> ah, I see
07:59:42 <byorgey> yes, that seems like an apt quote ;)
08:00:09 <ozy`> Nukem put it more eloquently
08:00:10 <gwern> (when one bishop or general was asked what to do with the couple thousand inhabitants of one town in which was mixed an unknown number of cathar heretics)
08:08:59 <cnwdup> @src (*>)
08:08:59 <lambdabot> (*>) = liftA2 (const id)
08:09:41 <Martijn> @quickcheck \x -> const id x == flip const x
08:09:42 <lambdabot> Unknown command, try @list
08:10:03 <cnwdup> @check \x -> const id x == flip const x
08:10:04 <cnwdup> afair
08:10:05 <lambdabot>       No instance for (Eq (a -> a))
08:10:05 <lambdabot>        arising from a use of `==' at <int...
08:10:26 <Heffalump> @quickcheck \x y -> const id x y == flip const x y
08:10:27 <lambdabot> Unknown command, try @list
08:10:30 <ziman> cnwdup, const id = flip const, indeed
08:10:34 <Heffalump> @check \x y -> const id x y == flip const x y
08:10:35 <lambdabot>   "OK, passed 500 tests."
08:10:53 <Heffalump> @check \(x::Int) (y::Char) -> const id x y == flip const x y
08:10:54 <lambdabot>   Parse error in pattern at "(y::C..." (column 11)
08:11:04 <Heffalump> @check \x y -> const id x y == flip const (x::Int) (y::Char)
08:11:05 <lambdabot>   "OK, passed 500 tests."
08:11:45 <cnwdup> Left [1,2,3] `mplus` Left [1,2,3]
08:11:47 <cnwdup> >Left [1,2,3] `mplus` Left [1,2,3]
08:11:50 <cnwdup> > Left [1,2,3] `mplus` Left [1,2,3]
08:11:52 <lambdabot>       No instance for (Error [t])
08:11:53 <lambdabot>        arising from a use of `mplus' at <in...
08:12:06 <cnwdup> > Left "a" <|> Left "b"
08:12:08 <lambdabot>       No instance for (Alternative (Either [Char]))
08:12:08 <lambdabot>        arising from a use...
08:12:12 <Martijn> How do I tell cabal install to install a package for ghc-6.8.2 instead of ghc-6.10.1?
08:12:42 <cnwdup> @src (*>)
08:12:42 <lambdabot> (*>) = liftA2 (const id)
08:12:45 <cnwdup> @src liftA2
08:12:46 <mak__> set compiler in conf file  afair
08:12:46 <lambdabot> liftA2 f a b = f <$> a <*> b
08:13:05 <dcoutts> Martijn: -w ghc-6.8.2
08:13:16 <Martijn> Thanks much
08:13:32 <dcoutts> Martijn: assuming "ghc-6.8.2" is on your $PATH
08:13:39 <Martijn> Yes
08:15:08 <cnwdup> If a and b fail with different error messages, why does a *> b give the error message from a?
08:15:09 <ksf> ...make pghc-6.10.1 be in your path, before 6.8.2
08:16:24 <true\false> cnt x:xs = (cnt xs) + 1 --Parse error in pattern?
08:16:40 <mauke> true\false: that parses as (cnt x) : xs = ...
08:16:41 <cnwdup> cnt (x:xs) I guess.
08:17:07 <true\false> Close.. Ta, that was it
08:18:26 <ksf> @seen conal
08:18:27 <lambdabot> I saw conal leaving #haskell and #ghc 9h 29m 34s ago, and .
08:20:39 <redditbot> Notes on the LHC: Thoughts on a new code generator
08:20:51 <cnwdup> @src (<*)
08:20:52 <lambdabot> (<*) = liftA2 const
08:21:25 <cnwdup> Why isn't (<*) defined as (<*) = flip (*>)?
08:22:29 <mauke> cnwdup: because then it would be useless
08:22:35 <cnwdup> mauke, Why?
08:22:57 <ksf> :t (<*)
08:22:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:23:01 <cnwdup> mauke, Aren't those definitions equivalent?
08:23:03 <mauke> because I want to be able to write char '(' *> expr <* char ')' in my parser
08:23:06 <ksf> :t flip (<*)
08:23:08 <mauke> no
08:23:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f b -> f a -> f a
08:23:24 <Martijn> "ghc-pkg-6.8.2 list" lists Yogurt-0.2, but "ghc-pkg-6.8.2 unregister Yogurt-0.2" complains "ghc-pkg: cannot find package Yogurt-0.2"
08:23:33 <ksf> :t flip (*>)
08:23:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f b -> f a -> f b
08:24:20 <cnwdup> Mh, okay. But I still don't understand why a *> b is giving me the error message of a.
08:24:34 <ksf> Martijn, might you be trying to unregister a system-wide package w/o being root?
08:24:52 <cnwdup> > fail "foo" *> fail "bar"
08:24:53 <lambdabot>       No instance for (Show (f b))
08:24:53 <lambdabot>        arising from a use of `show' at <in...
08:24:56 <Martijn> ksf: no, it's registed in ~/.ghc/i386-darwin-6.8.2/package.conf
08:25:24 <ziman> cnwdup, imagine the applicative objects were IO actions. The side-effects are ordered left-to-right, whereas flip (<*) would have side effects ordered right-to-left, in contrast to (*>).
08:25:55 <cnwdup> ziman, of course. (-: Thank you.
08:26:42 <Martijn> Oh well. Enough messing about with different versions of ghc for today. Thanks everyone. :-)
08:27:08 * ksf tries to think of a gui api that isn't monadic, fails and thus wonders what's so bad about IO.
08:30:08 <ksf> syntacticly, the most annoying thing is that you've got to pass handled down out of everything, as forkIO . adaptE is IO, no matter what you try.
08:30:15 <roconnor> Integer++
08:30:34 <ksf> s/handled/handles/
08:31:37 <ksf> otoh, seperating layout and semantics isn't that bad an idea.
08:32:33 <Saizan_> is that connected with the previous sentence?
08:32:48 <ksf> yeah
08:33:26 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=937#a937 <-- everyone look and tell me what's most annoying
08:33:54 <ksf> (except explicitely passing "sync")
08:36:19 <Peaker> ksf: You could of course have your entire program live in reader monads
08:37:09 <mopped> @src fix
08:37:09 <lambdabot> fix f = let x = f x in x
08:37:37 <kiris> just one more fix
08:37:53 <ksf> peaker, sure.
08:38:00 <mopped> > take 5 (fix (+1) 5)
08:38:01 <lambdabot>       No instance for (Num (t -> [a]))
08:38:02 <lambdabot>        arising from the literal `1' at...
08:38:08 <mopped> How do I use it? :E
08:38:51 <Axman6> fix doesn't have anything to do (explicitly) with lists
08:39:08 <mopped> aha
08:39:31 <ziman> > take 5 (iterate (+1) 5)
08:39:32 <lambdabot>   [5,6,7,8,9]
08:39:34 <ziman> ;)
08:39:46 <mopped> @src iterate
08:39:47 <lambdabot> iterate f x =  x : iterate f (f x)
08:41:50 <mopped> Is there a way to build lists with fix?
08:43:15 <mopped> because its just f (f (f (f .... (f x) right?
08:43:22 <rntz> in what module is instance Monad ((->) r) located?
08:43:52 <BONUS> > fix ('a':)
08:43:54 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
08:44:03 <BONUS> Control.Monad.Instances i think
08:44:24 <byorgey> mopped: sure.
08:44:35 <byorgey> > fix ((1:) . scanl (+) 0)
08:44:37 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
08:44:38 <rntz> BONUS: thanks
08:45:08 <byorgey> > fix ((1:) . scanl (*) 1)
08:45:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:45:13 <byorgey> err
08:45:38 <mopped> nooo not that byorgey, i still cant get my head around how that makes fibbonacci :(
08:46:11 <byorgey> mopped: hehe
08:47:00 <byorgey> mopped: that's ok, it still takes me a few minutes to get my head around it every time. =)
08:47:15 <asgaroth> I'm trying to retrieve the _NET_WM_PID of a window property with the haskell xlib bindings and this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=936#a936 , but the getWindowProperty call keeps returning Nothing. Does anyone know the cause?
08:47:31 <asgaroth> (Said property is present in the window in question
08:53:03 <mopped> > take 5 ((fix (\xs -> xs ++ [1  + (last x)])) [1])
08:53:04 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
08:53:41 <mopped> > take 5 ((fix (\xs -> xs ++ [1  + (last xs)])) [1])
08:53:42 <lambdabot>   Couldn't match expected type `t -> [a]'
08:53:46 <mopped> mm
08:54:59 <mopped> > (\xs -> xs ++ [1  + (last xs)])) [1,2,3,4]
08:55:00 <lambdabot>   <no location info>: parse error on input `)'
08:55:08 <mopped> > (\xs -> xs ++ [1  + (last xs)]) [1,2,3,4]
08:55:09 <lambdabot>   [1,2,3,4,5]
08:55:16 <mopped> am I using fix incorrectly
08:55:48 <byorgey> mopped: yes, I think you are using it as if it were 'iterate'.
08:56:04 <byorgey> > take 5 ((iterate (\xs -> xs ++ [1  + (last x)])) [1])
08:56:05 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
08:56:12 <byorgey> > take 5 ((iterate (\xs -> xs ++ [1  + (last xs)])) [1])
08:56:14 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
08:56:44 <byorgey> mopped: fix just takes one argument, a function f, and (essentially) computes  f (f (f (f (f .....
08:57:03 <byorgey> of course, for some functions f that will just be an infinite loop and never compute anything.
08:57:08 <byorgey> for example:
08:57:12 <byorgey> > fix (+1)
08:57:14 <lambdabot>   * Exception: stack overflow
08:57:24 <paper_cc> > fix (const 9)
08:57:25 <lambdabot>   9
08:57:45 <mopped> i'm feeding it a function that takes a list, adds one to the last item and produces a new list
08:58:00 <mopped> i then supply it with a starting list, and take 5 so i can see if it results in anyting, so whats going wrong?
08:58:04 <byorgey> mopped: right, that will just result in infinite recursion
08:58:15 <mauke> what starting list?
08:58:18 <mopped> [1]
08:58:20 <mauke> fix doesn't take a start value
08:58:21 <byorgey> because such a function needs its argument (the input list) to be full evaluated before it can output anything useful
08:58:26 <mopped> oh
08:58:41 <mauke> > fix f
08:58:42 <lambdabot>   Add a type signature
08:58:46 <byorgey> > fix (\xs -> xs ++ [1 + last xs])
08:59:01 <lambdabot>   thread killed
08:59:02 <mauke> > fix f :: Expr
08:59:04 <byorgey> see
08:59:04 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
08:59:14 <BONUS> > fix (\f n -> if (n==0) then 1 else n * f (n - 1)) 4
08:59:16 <lambdabot>   24
08:59:25 <byorgey> mopped: however, consider the function (1:), which prepends 1 to its argument (a list)
08:59:44 <byorgey> mopped: it can already output the beginning of its output list (namely, 1) without knowing anything about its argument
08:59:53 <mopped> but doesnt bonus' fix have a starting argument?
08:59:55 <byorgey> > fix (1:)
08:59:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:59:58 <mauke> mopped: no
08:59:59 <bodq> what's this ':: Expr' part?
09:00:06 <mauke> bodq: a type signature
09:00:10 <rntz> @hoogle Expr
09:00:11 <lambdabot> module Text.Parsec.Expr
09:00:11 <lambdabot> module Text.ParserCombinators.Parsec.Expr
09:00:11 <lambdabot> Distribution.Simple.Program alexProgram :: Program
09:00:24 <bodq> > 2 + 2 :: Expr
09:00:26 <lambdabot>   2 + 2
09:00:40 <bodq> I don't get it :)
09:00:43 <byorgey> bodq: that's a special feature built into lambdabot to show how expressions are computed
09:00:52 <bodq> ohh
09:00:56 <mopped> how does bonus's code work?
09:00:58 <mauke> it's not really built into lambdabot
09:00:58 <byorgey> bodq: variables a-z are special and have type Expr
09:01:06 <mauke> > 4^3 :: Expr
09:01:07 <lambdabot>   4 * 4 * 4
09:01:13 <byorgey> I mean, it's included in lambdabot
09:01:16 <bodq> > a
09:01:17 <lambdabot>   a
09:01:20 <byorgey> > map f [a,b,c]
09:01:21 <lambdabot>   Add a type signature
09:01:28 <byorgey> > map f [a,b,c] :: [Expr]
09:01:29 <lambdabot>   [f a,f b,f c]
09:01:39 <bodq> amazing
09:01:54 <rovar> oh speaking of parsec
09:02:01 <byorgey> > gcd 17 15 :: Expr
09:02:03 <lambdabot>   abs 15 `rem` (abs 17 `rem` abs 15)
09:02:03 <Martijn> ParsecT rules
09:02:21 <bodq> so which exactly module is this?
09:02:26 <byorgey> mopped: do you understand the 'fix (1:)' I typed above?
09:02:42 <mopped> 1:1:1:1:1:, right?
09:02:42 <rntz> > fix (f :: Expr -> Expr)
09:02:44 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
09:02:53 <mauke> bodq: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
09:03:16 <BONUS> so if you have 1 : ( 1 : ( 1 : ( whatever, haskell knows how to start outputting that list
09:03:38 <rovar> I'm just learning Haskell, going through the http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
09:03:55 <byorgey> rovar: cool, have any questions?
09:04:15 * ksf likes the idea of Behaviour (Table [TableFlags] (Behaviour SortFun) (Behaviour [[Cell a => a]])) to represent a table (maybe w/o nested behaviours)
09:04:26 <rovar> I'm stuck at ? 2 and 3 in the 1st group of questions on that parsing page
09:04:48 <Martijn> Question: what's the difference between [1] State S (Parsec a) and [2] ParsecT (State S) a. I.e. [1] builds a parser based on the current state, and [2] is a parser that runs in a state monad with some current state.
09:04:57 <rovar> trying to figure out how to rewrite parseString so that I can handle escaped chars
09:05:05 <Martijn> Should I prefer one above the other?
09:05:34 <byorgey> rovar: ok, what have you tried?
09:06:22 <enticingjelly> so, in simply typed lambda calculus, every well typed term has a normal form, yes?
09:06:39 <olsner> Martijn: State S (Parsec a) /= StateT S Parsec a (i.e. a state monad that returns a parser vs a state monad transformer wrapping a parser)
09:06:44 <byorgey> enticingjelly: yes.
09:06:48 <enticingjelly> byorgey, thanks.
09:07:06 <ksf> zomg I'm going to be able to sink (Behaviour Graph) into agar
09:07:50 <mopped> does ((\x f -> f x) 1) become (\f -> f 1)?
09:07:51 <rovar> byorgey, I've tried nesting another do routine inside the parseString action, but I couldn't get the types to match up, I think it's because I was trying to create a parsec combinator
09:08:08 <Martijn> olsner: How does that help? I didn't mean StateT S Parsec a, I meant ParsecT (State S) a
09:08:15 <byorgey> rovar: I don't think you have to go so far as to nest another 'do' block inside.
09:08:21 <byorgey> although you could.
09:08:41 <bodq> > reduction a + b * c
09:08:42 <lambdabot>   Not in scope: `reduction'
09:08:55 <byorgey> rovar: just replace '(noneOf "\"")' with something that accepts either a non-quote char, or the sequence \"
09:09:03 <byorgey> rovar: any ideas how to do that?
09:09:09 <rovar> i'm sure it's simple, but I'm going about this procedurally, keep thinking, if I find a \ I need to run a subroutine to extract and translate the following char
09:09:59 <rovar> so that logically says to me, embed a combinator in the parseString combinator
09:10:51 <olsner> Martijn: I was referring to "[1] State S (Parsec a)" .. anyway, if you only need the state to figure out which parser to build, rather than during parsing, I'd say you should go with the first one
09:11:31 <byorgey> rovar: ok, sure, but in that case I would just make a new function, rather than trying to nest a do-block there
09:11:50 <byorgey> i.e. replace '(noneOf "\"")' with 'stringChar' and then define stringChar elsewhere
09:11:57 <Martijn> olsner: what situation would require [2] and make option [1] impossible?
09:12:14 <mmorrow> , fix ((f::Expr->Expr) . (g::Expr->Expr))
09:12:16 <lunabot>  f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f (g (f...
09:12:24 <Martijn> olsner: ah, if the parsing process modifies the state, of course
09:12:41 <olsner> Martijn: yeah, something like building a symbol table while parsing
09:13:01 <byorgey> rovar: to just handle escaped quotes, you could just say '(noneOf "\"" <|> string "\\\"")'
09:13:02 <mopped> > (\x f -> f x) 1 f:Expr
09:13:03 <lambdabot>   Not in scope: data constructor `Expr'
09:13:09 <mopped> > (\x f -> f x) 1 f::Expr
09:13:11 <lambdabot>   f 1
09:13:17 <rovar> byorgey,  and stringChar is of type  GenParser tok st Char
09:13:19 <rovar> yes?
09:13:31 <mopped> > (\x f -> f x) 1
09:13:31 <mmorrow> , foldr (.) z [(f::Expr->Expr),g,h,i,j]
09:13:31 <rovar> actually no
09:13:32 <lambdabot>       Overlapping instances for Show ((t -> t1) -> t1)
09:13:32 <lambdabot>        arising from a ...
09:13:32 <lunabot>  luna: Couldn't match expected type `a -> c'
09:13:36 <Martijn> olsner: So I should change my question then: Reader S (Parser a) or ParsecT (Reader S) a
09:13:40 <byorgey> rovar: right.
09:15:24 <mopped> BONUS: how did your lambda work, if you fed it a function that takes two arguments?
09:15:46 <Axman6> :t ((.) .) . (.)
09:15:48 <lambdabot> forall a b c a1. (b -> c) -> (a1 -> b) -> (a -> a1) -> a -> c
09:16:24 <Axman6> > foldr (((.) .) . (.)) z [f :: Expr -> Expr,g,h,i]
09:16:25 <lambdabot>       Occurs check: cannot construct the infinite type: a = a1 -> a
09:16:25 <lambdabot>      Prob...
09:16:26 <rovar> now I need to figure out how these parsers work.
09:17:46 <olsner> in the former, you'd have to write code like do { p1 <- makeParser; p2 <- makeParser2; return (p1 >>= p2) } to combine parsers generated by other functions in your Reader monad
09:18:05 <Cale> mopped: which lambda?
09:18:17 <mmorrow> , fix ((f::Expr->Expr) . (g::Expr->Expr) . h)
09:18:18 <lunabot>  f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f...
09:18:34 <byorgey> mopped: the call to 'fix' transformed it from a function of two arguments into a function of one argument.
09:18:44 <Cale> mopped: As a general note, it's perhaps worth pointing out that all functions in Haskell have exactly one parameter.
09:19:02 <mopped> Yeah i remember reading something about that
09:19:06 <Cale> mopped: Those that appear to take more just return other functions.
09:19:14 <mopped> and it was a factorial lambda Cale, sec
09:19:18 <olsner> Martijn: ... while using transformers would allow you to write that as do { r <- parser; parser2 r } or just (parser >>= parser2)
09:19:35 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
09:19:35 <BMeph> , foldr (.) ($z) [(f::Expr->Expr),g,h,i,j]
09:19:36 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
09:19:36 <lambdabot>   120
09:19:41 <Cale> Something like that?
09:19:45 <mopped> yup
09:19:46 <mmorrow> `i' is something else
09:19:48 <Guenni> what do I have to do to make a compiled app use XP-Themes?
09:19:49 <mmorrow> i just remembered
09:19:50 <Cale> :t fix
09:19:51 <lambdabot> forall a. (a -> a) -> a
09:19:55 <mmorrow> , [$ty| i |]
09:19:57 <lunabot>  QuasiQuoter
09:20:07 <Cale> :t (\fac n -> if n == 0 then 1 else n * fac (n-1))
09:20:08 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
09:20:14 <olsner> Martijn: with the difference that the Reader environment would be passed in once per parsing rather than once per creating a parser (which I suppose could make a difference if the reader environemnt is a constant)
09:20:25 <lispy> Guenni: in .NET it's about having the right manifest in the assembly, not sure with Haskell
09:20:25 <Cale> So with a = (Num b) => b -> b
09:20:30 <mopped> would 5 apply to the lambda before fix?
09:20:35 <mmorrow> , [$i| (,,) "omg" "asdf" "qwerty" |]
09:20:37 <lunabot>  [('o','a','q'),('o','a','w'),('o','a','e'),('o','a','r'),('o','a','t'),('...
09:20:39 <Cale> fix is first applied to the lambda
09:20:42 <Guenni> lispy: thx
09:20:56 <Cale> mopped: When you have something like f x y z, it's parsed as ((f x) y) z
09:21:04 <Guenni> anybody using wxhaskell on winxp?
09:21:10 <Cale> (that is, function application associates to the left)
09:21:18 <mopped> ok
09:21:27 <Cale> fix f = let x = f x in x
09:21:28 <mmorrow> , foldr (.) id [(f::Expr->Expr),g,h] (z::Expr)
09:21:29 <byorgey> mmorrow: oooh, [$i| ... |] is idiom brackets?
09:21:30 <lunabot>  f (g (h z))
09:21:41 <mopped> when is five applied then? as fix is infinite how does haskell know when to use the five
09:21:53 <mmorrow> byorgey: i'm not sure exactly why it's called `i' (vixey's choice of ident)
09:21:54 <Cale> So, fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) = let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
09:22:06 <mmorrow> but it does:
09:22:08 <Cale> er, sorry about my use of = there
09:22:20 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) ---> let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
09:22:29 <rovar> byorgey, do you know if there is source online for parsec? I need to find an example of a ParsecChar, like oneOf
09:22:41 <Cale> and then applying the lambda, we have:
09:22:45 <mmorrow> [$i| f a_1 a_2 ..... a_n |] ==> f <$> a_1 <*> a_2 <*> ... <*> a_n
09:22:49 <byorgey> mmorrow: right, probably 'i' for 'idiom'
09:23:01 <mmorrow> byorgey: cool. i always wondered by "i"
09:23:01 <Cale> let x = (\n -> if n == 0 then 1 else n * x (n-1)) in x
09:23:07 <Cale> or
09:23:19 <Cale> let x n = if n == 0 then 1 else n * x (n-1) in x
09:23:29 * BMeph feels like the Village Idiom of #haskell
09:23:30 <Cale> Which is exactly the recursive definition of fac
09:23:41 <mmorrow> byorgey: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/src/Language-Haskell-Meta-QQ-Vixey.html
09:23:48 <lispy> ?remember BMeph feels like the Village Idiom of #haskell
09:23:49 <lambdabot> Good to know.
09:23:51 <Cale> mopped: See how that works?
09:24:01 <mopped> yeah i understand how the function is built
09:24:07 <mopped> im not sure when the five is applied though
09:24:14 <Cale> ah, it's applied after this
09:24:20 <bodq> is there a module that converts infix expressions into rpn?
09:24:24 <Cale> So we now have something like:
09:24:31 <Cale> (let x n = if n == 0 then 1 else n * x (n-1) in x) 5
09:24:32 <byorgey> mmorrow: I can't remember if McBride + Paterson actually used the term "idiom brackets" in "Applicative Programming with Effects", but they definitely used the notation [[f a_1 a_2 ... a_n]]
09:24:38 <bodq> {- besides parsec -}
09:24:40 <Cale> --> let x n = if n == 0 then 1 else n * x (n-1) in x 5
09:24:51 <byorgey> and those came to be called "idiom brackets" at some point
09:25:02 <mmorrow> byorgey: i wish i'd known that "i" actually meant something, since i wouldn't have changed the name in that module
09:25:24 <Cale> mmorrow: Did you give my idea a try? :)
09:25:28 <byorgey> mmorrow: hehe
09:25:39 <Cale> (the one with catamorphisms)
09:26:02 <Martijn> olsner: yeah, thanks :-)
09:26:04 <mopped> ok thanks
09:26:11 * BMeph tried to get catamorphisms, but the apartment manager won't allow pets
09:26:26 <Cale> mopped: Lazy evaluation always reduces the outermost reducible expression first.
09:26:30 <mmorrow> Cale: i haven't, but i've thought about.
09:26:43 <mmorrow> Cale: i definitely think it'd be cool to do
09:26:51 <Cale> mopped: (in contrast to strict evaluation, which is innermost-first)
09:26:51 <ray> lolcatamorphisms
09:27:02 <Cale> mmorrow: :)
09:27:30 <byorgey> rovar: http://www.haskell.org/haskellwiki/Parsec
09:27:30 <mopped> What does reduces mean?
09:27:40 <lispy> BMeph: my landlord says no catamorphisms because they tear everything apart
09:28:00 <ray> they reduce everything to shreds
09:28:05 <mmorrow> or they eated it
09:28:06 * kiris facepalms
09:28:12 <byorgey> catamorphisms don't tear things apart, they fold things up neatly
09:28:15 <bodq> catabomination unto Nuggan
09:28:36 <pumpkin> @seens dons
09:28:36 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 14h 13m 58s ago.
09:28:38 <Cale> mopped: Well, function application for the most part. A function applied to a parameter which matches one of that function's patterns is a reducible expressions.
09:28:39 <Cale> -s
09:28:44 <byorgey> you must be thinking of mongoosemorphisms
09:28:44 <p_l> hmm... what about parallel concurrent catamorphism? :)
09:29:01 <ray> crazy catamorphism lady
09:29:13 <ray> has 50 parallel concurrent catamorphisms
09:29:16 <Cale> mopped: Reducing that expression consists of substituting the parts of the expression matched by the pattern into the body of the function.
09:29:19 <lispy> byorgey: ah, I don't know what catamorphism means but I thought cata was greek for destructuring
09:29:24 <mopped> hm ok
09:29:32 * Axman6 adds metacatamorphisms, just to make his girlfriend go crazy
09:29:48 <pumpkin> sarahmorphisms
09:29:56 <ray> i never meta catamorphism i didn't like
09:29:57 <Cale> mopped: (with a little additional optimisation that if the same parameter occurs multiple times in the body, the results of evaluating that parameter will be shared amongst the copies)
09:29:59 <Axman6> heh, stalker :P
09:30:07 <mmorrow> this is interesting: so this works
09:30:08 <mmorrow> , fix (foldr (.) id [(f::Expr->Expr),g,h])
09:30:10 <lunabot>  f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f (g (h (f...
09:30:11 <pumpkin> Axman6: you write about her on your blog and advertise your blog, I read :P
09:30:13 <pumpkin> can't blame me :D
09:30:21 <mmorrow> but it can't figure out the type of any more functions composed
09:30:23 <Axman6> you remember!
09:30:24 <mmorrow> , fix (foldr (.) id [(f::Expr->Expr),g,h,k])
09:30:25 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr
09:30:30 <mmorrow> only 3
09:30:35 <mmorrow> max
09:30:40 <Axman6> http://axman6.homeip.net/blog/ btw
09:30:42 <Axman6> >_>
09:30:58 <Axman6> been wrestling it today, but it's all good now. whoot for lighttpd :)
09:31:18 <MarcWeber> Can I ask cabal to build one of all executables only?
09:31:30 <mmorrow> , [$ty| fix (foldr (.) id [(f::Expr->Expr),g,h,k]) |]
09:31:33 <lunabot>  luna: Exception when trying to run compile-time code:
09:31:36 <mmorrow> , [$ty| fix (foldr (.) id [(f::Expr->Expr),g,h]) |]
09:31:37 <bodq> Axman6: omg it's slow
09:31:39 <lunabot>  Expr
09:31:44 <Cale> mopped: It's perhaps worth mentioning at this point that stack overflows are not what programmers from strict languages expect them to be in GHC Haskell. The stack is used effectively to search an expression for a reducible subexpression. Stack overflows occur when the outermost reducible subexpression is too deep.
09:31:57 <Cale> So, for example...
09:32:02 <Axman6> yeah, my internet's being very slow atm, no idea whay
09:32:04 <Axman6> why*
09:32:04 <Cale> > foldl (+) 0 [1..1000000]
09:32:07 <lambdabot>   * Exception: stack overflow
09:32:15 <bodq> Axman6: 350 seconds rtt from europe
09:32:24 <Axman6> o.O
09:32:28 <bodq> Axman6: is it hosted on the moon or something? :)
09:32:34 <Cale> This stack overflow is not directly the fault of foldl
09:32:35 <pumpkin> 350 seconds?
09:32:36 <Axman6> australia :P
09:32:46 <pumpkin> that much time hasn't even elapsed since he posted the URL o.O
09:32:50 <bodq> 350 ms )
09:32:54 <papermachine> Australia might as well be on the moon
09:32:54 <pumpkin> lol
09:32:55 <pumpkin> ok
09:33:05 <Axman6> my ISP suchs fairly badly, so that's probably what;s up.
09:33:08 <Cale> The foldl builds up an expression which looks like (...((0+1)+2)+...)+1000000
09:33:22 <icqnumber> @src last
09:33:23 <lambdabot> last [x]    = x
09:33:23 <lambdabot> last (_:xs) = last xs
09:33:23 <lambdabot> last []     = undefined
09:33:27 <Cale> (and it even does it in a tight loop which uses no stack)
09:33:50 <bodq> Axman6: it takes good 10 seconds to fully load the page
09:34:01 <Cale> But then evaluating this expression puts lots and lots of things on the stack while looking for the 0+1 which is the only reducible subexpression.
09:34:09 <bodq> Axman6: when will people give up on the self-hosting dream and just use appengine or something :)
09:34:18 <Axman6> bodq: yeah i was asking some other people to test it earlier, and it was less than 2 seconds (minus the image)
09:34:23 <mopped> when would one use foldl' instead of foldl? when folding such a huge list that a stack overflow might appear?
09:34:29 <Cale> yes
09:34:36 <mopped> is there any other reasons?
09:34:37 <Axman6> bodq: when it's free and i get full control ;)
09:34:43 <Cale> foldl' is most commonly an optimisation over foldl
09:35:08 <Cale> It forces the evaluation of the accumulating parameter before recursing, so that large expressions might not build up.
09:35:10 <Axman6> mopped: i've heard it said often that there's no reason to ever use foldl over foldl'
09:35:18 <cnwdup> How can I tell ghc that I don't want anything which is exported by Control.Monad.Error even if it's re-exported by a module I import? Can I hide modules?
09:35:21 <bodq> Axman6: it's free as in beer, and do you need full control or do you need a blog ? :)
09:35:21 <Cale> There are times when foldl is better.
09:35:56 <Axman6> bodq: well, i was using wordpress.com, but i'm sick of wordpress
09:36:02 <Cale> (but often they could be even better as foldr, if that would even work)
09:36:04 <Axman6> Cale: can you name any?
09:36:10 <Cale> Axman6: reverse is one
09:36:19 <Cale> Though that's sort of minor
09:36:26 <dolio> foldl isn't actually better there. It's the same.
09:36:27 <Axman6> yeah
09:36:43 <Cale> dolio: well, you end up evaluating fewer flips
09:36:47 <Axman6> is foldl' just as lazy for reverse as foldl?
09:36:53 <Cale> if the resulting list isn't fully consumed
09:37:13 <Cale> another good example is minimum over a list of elements of a type which has an absolute minimum
09:37:59 <Cale> Though sometimes foldl' would be better, and it's arguable that if you want the early termination, foldr is a better option.
09:38:25 <Axman6> @src all
09:38:25 <lambdabot> all p =  and . map p
09:38:29 <Axman6> @src and
09:38:29 <lambdabot> and   =  foldr (&&) True
09:38:35 <lispy> iteratee are better yet if you want to control termination of a left fold
09:38:38 <bodq> addAcc (c, xs) x = let (newC, newX) = (c+x) `divMod` 10 in (newC, newX : xs)inc = dropWhile (==0) . uncurry (:) . foldl' addAcc (1, []) . reverse
09:38:46 <bodq> argh sorry about that
09:39:06 <Cale> I would generally recommend sticking to foldl' for left folds if you're unsure.
09:39:09 <dcoutts> MarcWeber: no
09:39:53 <Cale> But foldr is even better if you can get part of your result by only examining an initial prefix of the input list.
09:40:11 <Cale> The reason is that in some sense, foldr is O(1)
09:40:19 <roconnor> @hayoo newPath
09:40:19 <lambdabot> Unknown command, try @list
09:40:22 <Cale> foldr f z [] = z
09:40:30 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
09:40:46 <Cale> After evaluating the foldr, control either passes to z or to f
09:41:04 <Cale> So if f doesn't demand its second parameter, the recursive call is never taken.
09:41:21 <Axman6> ok, sleep time for me. goodnight all
09:41:28 <bodq> Axman6: g'day :)
09:41:38 <Cale> (or if f can produce some of its result from its first parameter alone, then that will be produced without recursing first)
09:41:51 <Cale> > foldr (:) [] [1..]
09:41:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:42:02 <Cale> Which means that foldr works on infinite lists
09:42:17 <Cale> foldl and foldl', by contrast, have
09:42:28 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
09:42:47 <Cale> which means that foldl calls foldl immediately until the end of the list is reached
09:42:54 <bodq> Cale: I think you've lost your audience :)
09:42:55 <ksf> OOP with C rocks.
09:43:01 <athos> > foldl f z (x:y)
09:43:01 <Cale> bodq: perhaps :)
09:43:02 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
09:43:06 <athos> 8]
09:43:10 <Cale> > foldl f z [1,2,3]
09:43:12 <lambdabot>   f (f (f z 1) 2) 3
09:43:15 <athos> > foldl f z [x,y]
09:43:17 <lambdabot>   f (f z x) y
09:43:57 <ozy`> I find it useful to think of foldl as "reduce" and foldr as "transform"
09:44:09 <dublpaws> > foldr (++) [] [1..]
09:44:11 <lambdabot>       No instance for (Enum [a])
09:44:11 <lambdabot>        arising from the arithmetic sequence ...
09:44:14 * ksf shudders
09:44:14 <bodq> this Debug.SimpleReflect is a godsend
09:44:18 <ksf> both are reduces.
09:44:23 <Cale> I think of foldr f z as replacing each (:) in the list with f and the [] at the end with z
09:44:24 <ksf> map is a transform.
09:44:28 <ksf> fmap even more so.
09:44:44 <Cale> foldl does something a bit more complicated
09:44:59 <ozy`> ksf: I know, I know, it's an oversimplification
09:45:10 <Cale> Have you all seen my diagrams? :)
09:45:24 <dublpaws> ooo diagrams!
09:45:27 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
09:45:45 <ozy`> ksf: I meant, mainly for the purposes of thinking about strictness vs. laziness...
09:45:59 <bodq> wow you have your own wiki :)
09:46:03 <ozy`> Cale: is that server still up? >_>
09:46:07 <ozy`> I can't reach it
09:46:14 <Cale> > let map f = foldr ((:) . f) [] in map (*10) [1..5]
09:46:15 <lambdabot>   [10,20,30,40,50]
09:46:22 <Cale> ozy`: hmm...
09:46:29 <Cale> ozy`: Maybe a DNS problem?...
09:46:34 <ozy`> yeah, might be
09:46:39 <mauke> wfm
09:46:50 <Cale> one moment while I check
09:47:05 <Cale> 99.247.248.73
09:47:10 <mauke> % dnsip cale.yi.org
09:47:11 <mauke> 99.247.248.73
09:48:00 <Cale> Maybe it's the fact that I'm on a torrent. I'm living with a crappy router.
09:48:11 * Cale kills the torrent
09:48:23 <mauke> the poor torrents :(
09:48:59 <Cale> ozy`: any luck?
09:49:14 <dublpaws> nice diagrams Cale, are they hand made?
09:49:23 <Cale> dublpaws: yes
09:49:28 <Cale> dublpaws: With inkscape
09:50:00 <Cale> I think I might even like Inkscape better than Adobe Illustrator.
09:50:52 <Cale> (which is pretty good, considering that Inkscape is free, and Illustrator costs hundreds of dollars to obtain legally)
09:53:19 <dublpaws> illustrator's snapping guide lines are more usable imo
09:53:26 <skorpan> has anyone got haskell-mode's inf-haskell to work nicely with 6.10.1?
09:53:41 <Cale> dublpaws: Oh, that's true, smart guides are nice.
09:53:43 <skorpan> i think that the switch from readline to editline has broken something.
09:53:52 <mauke> skorpan: I compiled my 6.10.1 with readline
09:54:05 <skorpan> mauke: how do i do that?
09:54:34 <mauke> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-January/016443.html
09:54:44 <Cale> dublpaws: The fact that all the snapping options are in the Document Properties dialog in Inkscape is suboptimal.
09:55:02 <skorpan> mauke: ah snap, so that won't be easy to do with the package manager
09:56:12 <skorpan> i wish someone would write a PKGBUILD for arch linux which uses readline
09:56:57 <vixey> what do you call a monad without fmap
09:57:11 <Cale> vixey: A bug.
09:57:32 <skorpan> a gonad
09:57:37 <mauke> I don't get the joke
09:57:39 <Cale> vixey: It's impossible for a monad not to have fmap.
09:57:55 <Cale> vixey: If you implement return and bind correctly, liftM provides a definition of fmap
09:58:05 <SamB> what, you mean they forgot the Functor instance ?
09:58:07 <vixey> I've only got return and join
09:58:18 <intoverflow> vixey: that's enough to define bind
09:58:18 <Cale> oh, that's odd.
09:58:25 <SamB> you should have said "what do you call return and join"
09:58:26 * ksf 's suspicion that cabal install is borked just became reinforced.
09:58:29 <Cale> intoverflow: Not quite...
09:58:48 <SamB> would have been a lot clearer
09:58:50 <dcoutts> ksf: mm?
09:58:51 <intoverflow> Cale: am I missing something obvious?
09:58:52 <Cale> vixey: Why can't you implement fmap?
09:59:07 <Cale> intoverflow: x >>= f = join (fmap f x)
09:59:08 <ksf> ghc-pkg clearly lists reactive-0.10.5, but cabal configure fails with a missing dep on reactive -any
09:59:23 <vixey> Cale, I can write  (a <-> b) -> (T a -> T b)  or (a -> a) -> (T a -> T a) but not fmap
09:59:28 <ksf> ...not only cabal install, that is, the whole of cabal.
09:59:36 <vixey> Cale, because my term has ... | Lam (a -> T a) | ... in it
09:59:39 <dcoutts> ksf: is that cabal configure, or runghc Setup configure ?
09:59:58 <vixey> fmap m (Lam f) = Lam (\o -> fmap m (f (m^-1 o)))
09:59:59 <ksf> both.
10:00:02 <Cale> vixey: mmm... brb
10:00:14 <intoverflow> Cale: touche
10:00:21 <vixey> so you have to take m^-1 as a parameter or a -> a
10:00:22 <CakeProphet> so someone a while ago suggested I might be interested in using Dynamic to represent object properties in a MUD server instead of using a static data type.
10:00:38 <CakeProphet> ...how does Dynamic work?
10:00:39 <dcoutts> ksf: and using a released cabal-install or darcs version?
10:00:51 <vixey> CakeProphet, dynamic is a bunch of typeclasses and unsafe operations
10:00:59 <dcoutts> ksf: does runghc Setup configure --user work?
10:01:01 <ksf> cabal-install version 0.6.0
10:01:02 <ksf> using version 1.6.0.1 of the Cabal library
10:01:06 <vixey> CakeProphet, I seriously doubt that is actually useful in your situation
10:01:11 <CakeProphet> ...heh, okay.
10:01:25 <ksf> a gotcha might be that I'm trying to manage ghc 6.11 packages with it, though.
10:01:27 <SamB> CakeProphet: I'd suggest using ByteStrings ;-P
10:01:40 <CakeProphet> SamB bytestrings?
10:01:43 <ksf> there's already cabal-1.7.0 there.
10:01:45 <Nafai> Is there a cabal command to see if cabal install was used to install a package?
10:01:56 <dcoutts> Nafai: no
10:01:57 <SamB> or are these properties actually values, not just flags ?
10:02:00 <intoverflow> CakeProphet: I ran into a similar suggestion for the game I'm writing; as far as I can tell, trying to keep game rules in the type system is tricky as hell
10:02:19 <dcoutts> Nafai: though for user packages a reasonable guess is if the package contains files under ~/.cabal/lib
10:02:36 <ksf> the strange thing is that the project built fine just half an hour ago.
10:02:49 <hallongrottan> Nafai: you can see all installed packages by running ls ~/.cabal/lib/
10:02:51 * ksf browses through his command history
10:03:03 <CakeProphet> intoverflow:  I just have a very simple system for storing properties on various objects.  data Prop = StringProp String | IntProp Integer | BoolProp Bool| NullProp
10:03:05 <dcoutts> ksf: can you paste the details, like ghc-pkg list and cabal configure -v
10:03:10 <dcoutts> @hpaste2
10:03:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:03:19 <CakeProphet> intoverflow:  I might add a PropList [Prop] constructor as well
10:03:25 <dcoutts> hmm, @hpaste2 does not help
10:03:29 <Nafai> dcoutts: Okay.  I was going to script something up quickly to do a cabal install --reinstall of those packages I've installed with it so it will install the profile versions as well (I updated my config)
10:04:47 <dcoutts> Nafai: a reasonable approximation would be ls ~/.cabal/lib/ as hallongrottan suggests
10:04:51 <Nafai> Yeah
10:04:51 <ksf> wtf...
10:05:11 <ksf> can it be that runhaskell Setup clean and cabal clean don't mean the same thing?
10:05:13 <dcoutts> it's not guaranteed accurate because there's nothing to say those packages are still registered, but most will be
10:05:20 <ksf> that is, that cabal clean is more throughout?
10:05:51 <dcoutts> ksf: they can be different if the Setup.hs does something weird and the .cabal file says build-type Simple
10:05:53 <Cale> back...
10:06:08 <dolio> vixey: That seems like an odd type for lambda abstraction.
10:06:10 <dcoutts> ksf: but ordinarily they're te same
10:06:13 <Cale> vixey: Any chance it should really be  Lam (forall a. a -> T a) ?
10:06:14 <dolio> (a -> T a) -> T a?
10:06:19 <SamB> dcoutts: does hackage allow such things ?
10:06:28 <Nafai> That seems better than trying to parse ghc-pkg output
10:06:37 * ksf did cancel a configure before stuff broke
10:06:53 <ksf> I'll paste the .cabal and Setup.hs
10:07:01 <Cale> vixey: Because that would fix the problem rather nicely by avoiding it altogether ;)
10:07:02 <dcoutts> SamB: there's no way to enforce it afaik, except by overwriting the Setup.hs with default ones
10:07:16 <skorpan> @pl \d -> writable d && readable d
10:07:16 <lambdabot> liftM2 (&&) writable readable
10:07:30 <SamB> dcoutts: I was thinking it could just complain if you used a non-standard module body ...
10:07:31 <skorpan> what the...
10:07:35 <skorpan> @src liftM2
10:07:35 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:07:45 <dcoutts> SamB: it's not clear what is standard at a lexical level
10:07:48 <kerlo> As-patterns normally match unconditionally, right?
10:07:56 <kerlo> Can I have one that doesn't match unconditionally?
10:07:58 <SamB> dcoutts: just dictate something
10:08:00 <Cale> kerlo: No...
10:08:02 <skorpan> @pl \d -> f d && g d
10:08:03 <lambdabot> liftM2 (&&) f g
10:08:12 <ksf> dcoutts, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=940#a940
10:08:18 <Cale> kerlo: As patterns match if and only if the thing after the @ matches.
10:08:22 <skorpan> i don't get it. can i really use do-notation for non-monadic expressions?
10:08:23 <dcoutts> SamB: yeah, probably ok
10:08:34 <gwern> luqui: btw, I saw this reference just now - 'David Wakeling. 1998. A Haskell to Java virtual machine code compiler. In International Workshop on Implementation of Functional Languages, pages 39–52. Springer-verlag.'
10:08:42 <Cale> vixey: Still here?
10:08:48 <kerlo> > let test a@(x:xs) = False; test [] = True in test []
10:08:50 <lambdabot>   True
10:08:53 <kerlo> Oh, what do you know.
10:08:58 <luqui> gwern, thanks!
10:09:02 <Cale> kerlo: That's kind of the point of them :)
10:09:11 <gwern> luqui: so I guess you now have at least 2 prior arts for haskell->java vm
10:09:27 <Cale> kerlo: To ensure that a pattern matches, and match subparts of a structure, while providing a name for the entire matched structure.
10:09:40 <dcoutts> ksf: you don't override clean so in both cases it should just rm -rf the dist dir
10:09:41 * kerlo nods
10:09:45 <ozy`> Cale: hey, you're right, it was a DNS problem
10:09:45 <luqui> yeah.  it's a decent plan, as I also get access to a bunch of their code to use in my RTS
10:09:49 <luqui> libs I mean
10:10:06 <dcoutts> SamB: file a feature request ticket to check for it if you like
10:10:10 <luqui> I just hope I have enough control over the garbage collector
10:10:20 <luqui> I'll have to research java bytecode a bit
10:10:29 <Cale> ozy`: That's fairly common. I don't have a static IP and there are a lot of stupid DNS caches which retain my domain name mapping longer than they should.
10:10:52 <vixey> data T = App T T | Lam (forall a. a -> T a) | Var ... Var can't work with that
10:11:03 <ozy`> Cale: I've never trusted dynamic DNS stuff to work properly
10:11:37 <Cale> vixey: er, hmm...
10:11:55 * ksf is confused
10:11:56 <Cale> vixey: What is the type variable for?
10:12:05 <ksf> I'm getting /home/ksf/.cabal/lib/agar-1.3.3.0.0/ghc-6.11.20090123/libHSagar-1.3.3.0.0.a(Widget.o): In function `s5Mi_info':
10:12:06 <ksf> (.text+0x1b4): undefined reference to `AG_Expand
10:12:07 <vixey> luqui, java bytecode is annoying because you can't take advantage of that you're compiling well typed code
10:12:17 <ksf> while compiling an app, but not while compiling the lib.
10:12:35 <Cale> ksf: hmm... how are you compiling?
10:12:45 <dcoutts> ksf: nothing gets linked when you compile a lib
10:12:53 <Cale> ksf: If you're compiling directly with ghc, did you supply --make as a parameter?
10:13:04 <ksf> yes, I did.
10:13:23 <ksf> I'm going to try to pass more include flags, but stuff worked beforehand.
10:13:24 <luqui> vixey, yeah, and I was just thinking, the kind of weird stuff I want to do with GC is clearly not possible.   I guess I get to make my own RTS -- at least for experiments.
10:13:33 <luqui> maybe I'll look into C--
10:13:48 <ksf> (and I'm using make to compile the demo, so I _do_ know what it did/does)
10:13:55 <dcoutts> ksf: is it actually linking to the agar lib? what is the content of "agar.buildinfo"
10:14:10 <dcoutts> ksf: note that -threaded does nothing for a lib
10:15:06 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=940#a941
10:15:41 <SamB> dcoutts: which component ? hackageDB website ?
10:15:51 <roconnor> firefox--
10:15:55 <kerlo> @docs Random
10:15:56 <lambdabot> Random not available
10:15:58 <dcoutts> SamB: the checks are actually in the Cabal lib
10:16:03 <kerlo> @hoogle random
10:16:04 <lambdabot> package random
10:16:04 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
10:16:04 <lambdabot> module System.Random
10:16:05 <SamB> ah, okay
10:16:12 <kerlo> @docs System.Random
10:16:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
10:16:17 <SamB> I figured there'd be code there involved
10:16:39 <dcoutts> ksf: so when you ghc --make -v for your test prog, can you see it linking with ag_core etc?
10:16:41 <vixey> Cale, I just have got bugs from dealing with syntax-with-binding
10:16:46 <conal> dcoutts: yeah.  sadly -threaded is not compositional.
10:16:46 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:17:02 <ksf> it's just adding one function that calls one ffi binding to make this happen.
10:17:19 <dcoutts> ksf: and is that symbol definitely in the ag_core library? does nm say so?
10:18:03 <roconnor> how do I get a window's surface for me to cairo on?
10:18:12 <dcoutts> conal: yep, and it's not clear how it ever could be, there can only be one RTS for a program. If one lib required threaded and another required not, then we've got a conflict.
10:18:19 <dcoutts> roconnor: see the demos
10:18:19 <vixey> I think
10:18:22 <conal> dcoutts: yep.
10:18:33 <roconnor> oh maybe I use renderWithDrawable
10:18:36 <roconnor> @where demos
10:18:36 <lambdabot> I know nothing about demos.
10:18:42 <ksf> dcoutts, yes its' in the library.
10:18:48 <dcoutts> roconnor: the cairo demos in the gtk2hs source tarball
10:18:59 <roconnor> tarball?
10:19:14 <roconnor> I use aptitutde
10:19:20 <dcoutts> roconnor: ok get the tarball
10:19:25 <roconnor> :)
10:19:25 <roconnor> ok
10:20:20 <ksf> the demo compiles with -lag_gui -lag_core whether or not I specify it on the command line (like it's Supposed To Be)
10:20:32 <dcoutts> ksf: is that what nm says or what the headers say?
10:20:40 <redditbot> monoids for parallelisation
10:20:43 <ksf> that's what nm says.
10:20:45 <CakeProphet> :t null
10:20:46 <lambdabot> forall a. [a] -> Bool
10:20:51 <vixey> redditbot, link?
10:21:21 <dcoutts> ksf: this is ghc --make right, not ghci?
10:21:25 <CakeProphet> :t nothing
10:21:26 <lambdabot> Not in scope: `nothing'
10:21:29 <CakeProphet> sweet.
10:21:36 <BONUS> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=939#a939 this 2-3 tree type is really mind bending O_O
10:22:40 <dcoutts> ksf: if it's really using -lag_core and that function really is in that lib then I dunno. Time to make a tiny test case for a bug report.
10:22:54 <enticingjelly> Γ  |-  t : AΓ
10:23:18 <vixey> wow I think my bug was because I wrote t instead of tT
10:23:33 <vixey> or maybe it was because I wrote tT instead t
10:23:36 <enticingjelly> is t : AΓ read as Γ with t:A?
10:23:59 <vixey> enticingjelly: where did you read that?
10:24:16 <roconnor> wow.  Drawing.hs is a little bit more complex than I had imagined
10:24:16 <SamB> dcoutts: okay, ticket submitted
10:24:21 <enticingjelly> vixey, university script
10:24:21 <dcoutts> SamB: ta
10:24:23 <roconnor> but I guess it is fair
10:24:31 <vixey> enticingjelly: can you link to it ?
10:24:46 <SamB> hmm, is there no way to see what changes were made to the description of a ticket ?
10:24:47 <skorpan> i'm having trouble understanding extQ of SYB. where can i find more information on it?
10:25:04 <enticingjelly> vixey, not really, it's hand written, but I can link you to an assigment where there's the exact same expression. it's german, though: http://www.tcs.ifi.lmu.de/lehre/WS08-09/Lambda/blatt6.pdf
10:25:15 <enticingjelly> vixey, assignment H-23
10:25:33 <mauke> 23!
10:26:03 <SamB> enticingjelly: well, hopefully German equations are the same as English-language equations ;-)
10:26:12 <vixey> Aufgabe H-23 (Korrektheit der Typinferenz): Zeigen Sie: Wenn infer(t) = A, C und Γ l ̈st C, dann Γ t : AΓ.
10:26:21 <vixey> sorry I have no idea what that means
10:26:29 <mauke> Exercise H-23 (Correctness of type inference): Show: If infer(t) = A,C and Γ solves C, then Γ |- t : AΓ.
10:26:37 <vixey> I've seen  Γ |- x : Γ(x)  before
10:26:43 <vixey> but not  AΓ  ...
10:26:54 <chessguy> @seen ski_
10:26:54 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I don't know when ski_ last spoke.
10:27:02 <mauke> preflex: seen ski_
10:27:02 <preflex>  ski_ was last seen on #haskell 3 days, 3 hours, 58 minutes and 37 seconds ago, saying: mib_4myoxw1s : might you be a "bot" ?
10:27:05 <enticingjelly> vixey, yes, that's my problem, that AΓ really comes out of nowhere :( I think I know what it means, but I want to be sure
10:27:16 <vixey> enticingjelly what do you think it means
10:27:32 <enticingjelly> vixey, 19:23 < enticingjelly> is t : AΓ read as Γ with t:A?
10:27:33 <mauke> heh. deadline is tomorrow?
10:28:14 <enticingjelly> vixey, so, I think it's actually read as (t:A)Γ rather than t:(AΓ)
10:28:18 <BONUS> i didnt know ski_ was croatian .. cool
10:28:21 <enticingjelly> at least that makes sense to me
10:28:41 <vixey> lol @ the quote
10:28:49 <enticingjelly> in my simplest example, where infer(x,<empty>) = a,<empty>, Γ can be empty
10:29:04 <enticingjelly> so it's not sufficient for Γ |- t : A
10:29:17 <enticingjelly> because that would imply that t:A is in Γ
10:29:51 <roconnor> why is gtk+ single threaded?  I thought UI programming essentially had to be multi-threaded, so that computation doesn't hold up window drawing
10:30:51 <ksf> wait... what's the difference between a T and a t symbol?
10:31:02 <ksf> ...the second one doesn't show up in nm -g
10:31:20 <ksf> that explains stuff and poses further questions.
10:31:22 <dcoutts> roconnor: one cannot block the event loop, so long running tasks either have to go in another thread or be split up, in Haskell the former is easier.
10:31:34 <enticingjelly> vixey, does that make sense to you?
10:31:55 <hamboh> hello, im having trouble doing a query search where i can compare the query and the string... so how I do this... this is what i have so far: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=942#a942
10:31:55 <dcoutts> roconnor: but even if it's multi-threaded by default that still does not mean you can block in an expose event or something.
10:31:57 <roconnor> dcoutts: ya but I have the warning:
10:31:57 <roconnor> initGUI: Gtk+ is single threaded and so cannot safely be used from
10:31:57 <roconnor> multiple Haskell threads when using GHC's threaded RTS. You can
10:31:57 <roconnor> avoid this error by relinking your program without using the
10:31:57 <roconnor> '-threaded' flag.
10:32:15 * ksf has a look at the .c
10:32:39 <mopped> > (let times xy = if y == 0 then 0 else x + (times x (y - 1)) in times 5 3
10:32:40 <lambdabot>   <no location info>: parse error on input `;'
10:32:47 <dcoutts> roconnor: yes, you can use it multi-threaded but you have to be careful not to shoot yourself in the foot
10:32:52 <mopped> > let (times xy = if y == 0 then 0 else x + (times x (y - 1)) in times 5 3
10:32:53 <lambdabot>   <no location info>: parse error on input `='
10:32:59 <mopped> what's wrong with that?
10:33:05 <chessguy> hamboh:  i think you're a little confused about how pattern matching works
10:33:27 <mauke> mopped: the ( )
10:33:29 <dcoutts> roconnor: that message there is to make you stop and think before shooting yourself in the foot.
10:33:33 <chessguy> hamboh:  the third clause of your parse function will never be matched
10:33:42 <roconnor> dcoutts: difficult because I guess I don't understand how Haskell threads and OS threads intract. :)
10:33:45 <mopped> > let times xy = if y == 0 then 0 else x + (times x (y - 1) in times 5 3
10:33:46 <lambdabot>   <no location info>: parse error on input `in'
10:34:01 <mauke> mopped: unbalanced '('
10:34:05 <mopped> doh
10:34:12 <mopped> > let times xy = if y == 0 then 0 else x + (times x (y - 1)) in times 5 3
10:34:13 <lambdabot>   Couldn't match expected type `Expr -> Expr'
10:34:17 <hamboh> chessguy: oh, ive forget to delete the line
10:34:21 <mopped> oh im just being bad
10:34:23 <mopped> nevermind me
10:34:23 <mauke> mopped: x, y undeclared
10:34:24 <dcoutts> roconnor: if you only ever make GUI calls from the single Haskell thread that called initGUI then you're ok.
10:34:46 <roconnor> dcoutts: oh that's probably the case
10:34:48 <Olathe> > let times x y = if y == 0 then 0 else x + (times x (y - 1)) in times 5 3
10:34:50 <dcoutts> roconnor: if you do anything else you get to keep the pieces
10:34:50 <lambdabot>   15
10:34:57 <roconnor> I'll only spawn threads for computation
10:35:15 <dcoutts> roconnor: ok, but how are the results of the computation displayed?
10:35:20 <roconnor> dcoutts: if I use STM, then I can't even make GUI calls.
10:35:35 <dcoutts> roconnor: how are they communicated back to the part of the program that updates the GUI?
10:35:57 <roconnor> dcoutts: persumably picking them up from a shared variable.
10:36:08 <roconnor> not that I have this written yet, I'm just thinking.
10:36:21 <ksf> ...it's a bleeding static __inline__ void defined only in the .h, not in the .c.
10:36:27 <dcoutts> roconnor: yep, ok. If necessary there are functions provided for posting gui actions to the main thread.
10:36:38 <roconnor> dcoutts: oh? like what
10:36:43 <chessguy> > let times x 0 = 0; times x y = x + times x (y-1) in times 5 3
10:36:45 <lambdabot>   15
10:36:46 <ksf> which of course means that it's there in every sense c cares about, but doesn't end up in the .so
10:36:52 <chessguy> Olathe:  ^^
10:36:53 <ksf> almost as evil as a macro, that is.
10:37:09 <dcoutts> ksf: a so nm said it's mentioned, but not defined?
10:37:11 <hamboh> maybe somebody  can give me tips on the next steps
10:37:12 <dcoutts> a/ah
10:37:18 <enticingjelly> vixey, ah, I got it.
10:37:28 <dcoutts> ksf: so you'll need a C wrapper and then ffi import that
10:37:32 <mauke> how sane would it be to use a Chan (IO a) and have a main thread that simply does forever (join (readChan ch))?
10:37:38 <chessguy> hamboh:  it's not clear what you're trying to do
10:37:41 <ksf> it's listed as t, multiple times.
10:37:48 <ksf> I guess those are invocations.
10:39:08 <mopped> I'm noob to bad in knowledge of functional programming (i understand fold, map, filter etc) but i'd like to practice on some problems. Does anyone have some reccomendations? I'm not good enough to move on, but i'd like to improve
10:39:17 <hamboh> chessguy: a query search like: you type p | q and a string like "moop" it should be True... "mooq" should be True also.. so the | works like a OR operator
10:39:20 <chessguy> hamboh:  i suspect though that you want to pattern match against the other query types. e.g., query (QLit s) (x:xs) = ...
10:39:32 <roconnor> @type forM
10:39:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
10:39:36 <ksf> so, in the end, I need to generate stubs for a) every vararg function b) every non-trivial define (and hope that c2hs can parse macros calling functions) c) __inline__'s in headers
10:39:51 <ksf> s/and/or
10:40:24 <chessguy> @src forM
10:40:25 <lambdabot> forM = flip mapM
10:41:53 * ksf wonders whether or not he can just compile the whole bleeding header.
10:42:44 <ksf> hoping that gcc is conservative enough to emit code for __inline__'s if it's asked to do a .o
10:43:09 <ksf> or #define __inline__ to nothing or something.
10:43:58 <dcoutts> ksf: if you write a wrapper function that calls the inline function then it must do.
10:45:31 <ksf> but I don't want to, as there are hundreds of it.
10:47:54 <dcoutts> ksf: this is one useful thing that c2hs could do, generate wrappers
10:48:11 <dcoutts> eg to call things defined by macros or inline functions
10:48:35 * ksf tries -D__inline__=
10:48:57 <ksf> doesn't seem to work.
10:49:08 <ksf> you're right, c2hs should do that.
10:49:39 <SamB> Hmm. The Haskell Report's default implementation for the enumFrom* methods needs a better comment ...
10:49:55 <SamB> well, no, wait
10:50:07 <SamB> it's based on the one for Int, nevermind.
10:51:12 <wabash> Newbie question: What is the "Haskell Report"? Is it like the colbert report, only more serious?
10:51:38 <SamB> so are the derived instance methods  ...
10:51:49 <mauke> wabash: it's the document that defines the language
10:52:04 <wabash> mauke: Oh. THat's all? Is it easy to read?
10:52:05 <CakeProphet> @hoohle enumFrom
10:52:06 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
10:52:06 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
10:52:06 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
10:52:17 <Cale> wabash: Relatively so, though it is reasonably formal as well.
10:52:18 <CakeProphet> > enumFrom 5
10:52:19 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
10:52:28 <mauke> wabash: easier than the C standard, at least
10:52:29 <CakeProphet> > enumFromThen 3 6
10:52:31 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
10:52:41 <wabash> I see.
10:52:49 <CakeProphet> > enumFromThenTo 3 6 300
10:52:51 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
10:52:51 <CakeProphet> ah okay.
10:52:52 <wabash> Is Haskell '98 the current standard?
10:52:59 <Cale> I really wish that we still had a denotational semantics document. Earlier versions of Haskell did.
10:53:03 <Cale> wabash: sort of.
10:53:06 <CakeProphet> all the [x,y...z] implementation functions.
10:53:21 <Cale> wabash: Basically all the implementations go beyond it in semi-standard ways.
10:53:40 <CakeProphet> can you have something like
10:53:45 <Cale> wabash: GHC implements a large number of extensions.
10:53:46 <SamB> some of them almost even reach it everywhere
10:53:52 <CakeProphet> instance (A x, B x) => C x
10:53:54 <CakeProphet> with no where
10:54:03 <wabash> Cale: Ok. thanks.
10:54:14 <Cale> CakeProphet: I think that's allowed in GHC...
10:54:24 <wabash> Cale: I'm installing it now. The package says 98, so it seems kind of old......
10:54:42 <Cale> wabash: which package?
10:54:46 <CakeProphet> Cale:  any other implementations?
10:54:52 <wabash> Debian
10:55:07 <wabash> says "98 is the current version..."
10:55:08 <Cale> wabash: GHC 6.10.2 or 6.10.1 ?
10:55:20 <kaol> 6.8.2 if it is Debian
10:55:26 <wabash> Oh,... Don't hav ethat window open at the moment.
10:55:31 <wabash> 6.8.2?
10:55:34 <Cale> wabash: Oh, or the Haskell 98 report?
10:55:43 <Cale> I usually just read it online
10:55:44 <wabash> Yes, that too.
10:56:07 <kaol> practically everyone's using ghc's extensions to haskell 98 these days
10:56:16 * Cale is sad that the Haskell 1.4 report isn't the current standard.
10:56:34 <roconnor> weee, my first gtk2hs program
10:56:41 <Deewiant> Does 98 actually /add/ anything to 1.4?
10:56:43 <wabash> So if I use ghc, I'll be set?
10:56:45 <Cale> Haskell 98 was a step backwards.
10:56:53 <Cale> Deewiant: I'm not sure.
10:56:58 <Cale> wabash: yes
10:57:11 <SamB> why don't we ask the Haskell' committee to just ratify Haskell 1.4 again ?
10:57:11 <wabash> cale. Ok, I'll stick with that. Thank yo.
10:57:21 <wabash> GHC will correspond to what's in RWH?
10:57:24 <Cale> wabash: It comes with a compiler, an interactive environment, as well as profiling and code coverage tools
10:57:27 <Deewiant> Switching to 1.4 would break approximately all code out there
10:57:28 <SamB> except with hierarchical libraries
10:57:29 <ksf> because we're gonna have H'.
10:57:41 <SamB> Deewiant: I fail to see the problem
10:57:48 <ksf> ...which ghc will most likely the first one to support wholly.
10:58:05 <Deewiant> SamB: Well, I think you agree that that's not exactly optimal? :-P
10:58:10 <Cale> H' seems too conservative. I want to see people working on Haskell 2
10:58:18 <SamB> Deewiant: well, it's sad that it's needed
10:58:24 <SamB> but it's Haskell 98's fault
10:59:11 <elly> what's H'?
10:59:40 * ksf is going to snarf Language.C and think about what's missing out of c2hs just because it didn't use it before.
10:59:43 <Cale> elly: Haskell-Prime, the temporary name for the new standardisation process.
11:00:11 <Cale> elly: The idea being that the standard will get a proper name when it's finished, like Haskell 1.6 or Haskell <year>
11:00:28 <elly> ahh
11:00:31 <elly> what're the changes?
11:00:31 <SamB> I don't think it deserves the name Haskell 1.6
11:00:41 <SamB> I think it should be called Haskell 98 SE
11:00:42 <Cale> elly: Basically, the stuff which GHC has changed.
11:00:48 <Botje> call it haskell++
11:00:49 <wabash> Cole: is GHC going to cover all the stuff in RWH?
11:00:53 <Cale> A subset of the extensions in GHC.
11:00:57 <Cale> wabash: yes
11:00:58 <elly> I don't know what ghc has changed :P
11:01:00 <wabash> Botje: Great Idea!!!!!
11:01:04 <wabash> Cale thanks.
11:01:04 <Cale> wabash: More than that, actually.
11:01:13 <SamB> Haskell ME might be a bit harsh
11:01:16 <Cale> wabash: I'm pretty sure RWH doesn't touch all the extensions.
11:01:23 <ksf> elly, http://hackage.haskell.org/trac/haskell-prime/
11:01:23 <wabash> Cale: Well, I meant, if I use GHC, I won't be missing anything when it comes time to do RWH...
11:01:32 <Cale> SamB: Haskell 98 *is* Haskell ME ;)
11:01:35 <wabash> GHC superset of RWH.
11:01:35 <SamB> I suppose we could call it Haskell 2000
11:01:45 <wabash> Haskell NT, of course.
11:01:48 <SamB> no, wait, that's an insult to win2k isn't it
11:01:55 * ksf is strongly in favour of outlawing tabs
11:02:01 <idnar> Haskell OS/2
11:02:02 <SamB> ksf: me too!
11:02:03 <wabash> Haskell 7? Haskell Mojave?
11:02:04 <Cale> ksf: I agree.
11:02:11 <SamB> idnar: that's an insult to OS/2, though
11:02:17 <Cale> I'd like to see a return to proper version numbers.
11:02:21 <wabash> Cale:  Sorry, a question: GHC is a superset of RWH?
11:02:27 <wabash> (of the stuff in...)
11:02:31 <Cale> wabash: yes
11:02:35 <wabash> Cale, ok, cool.
11:02:37 <wabash> thanks.
11:02:42 <SamB> Cale: I don't think it's deserved until we have a proper version
11:02:43 <vilhelm_s> What's the rules from typeclass constraints in datatype declarations? GHC accepts both data (Eq t) => Frob t = Frob t ; data Frob' t = (Eq t) => Frob' t    ,and gives the same type to the constructor, but they seem to give different contexts when pattern matching.
11:03:01 <Cale> wabash: There are new features which they didn't get a chance to talk about in RWH, as well as old ones which were outside the scope of the book.
11:03:03 <ksf> ...and a ghc flag -fix-tabs that rewrites your code with tr/\t/        /
11:03:09 <SamB> vilhelm_s: the rule of thumb is "don't!"
11:03:13 <idnar> SamB: Haskell 1.33 for Workgroups? :P
11:03:14 <wabash> Ok, good to know.
11:03:23 <wabash> idnar: Perfect. Let's go with that one.
11:03:32 <shepheb> I'm seriously considering using gitit for my school notes. I wonder if there would be a way to rip the guts out of the PDF slides some of my classes publish and put them into it?
11:03:39 <wabash> idnar: But then we'll have to start working on the education version of Haskell....
11:03:44 <vilhelm_s> SamB: Don't what? Mix typeclasses and 'data' at all?
11:03:53 <byorgey> lispy: 'kata' is a greek preposition/prefix meaning (among other things) "down".
11:03:58 <SamB> vilhelm_s: put typeclass constraints on datatypes
11:03:59 <shepheb> hm, even just treating each slide as an image in the page would be workable
11:04:05 <SamB> it doesn't do anything for you
11:04:17 <Cale> vilhelm_s: Typeclass contexts in data declarations probably don't mean what you want them to, unless you're using the GADT syntax.
11:04:25 <Cale> (in 6.8 or higher)
11:04:45 <byorgey> lispy: so a "catamorphism" is something that folds a data structure "down" into a summary value.
11:04:52 <SamB> vilhelm_s: oh, but on individual fields makes sense
11:04:53 <idnar> why isn't it a katamorphism?
11:05:02 <byorgey> as opposed to an "anamorphism" (ana = up) which builds up a structure from a seed.
11:05:02 <Cale> vilhelm_s: They restrict the type of the data constructor without adding a typeclass dictionary to the data which is carried.
11:05:09 <byorgey> idnar: because english is silly.
11:05:14 <SamB> or even on the whole constructor, or whatever
11:05:15 <idnar> heh
11:05:21 <Cale> vilhelm_s: Which means that functions that pattern match on data of that type can't assume that the instance is present.
11:05:24 <SamB> just keep them on the RIGHT of the type name ;-)
11:05:29 <Cale> (they must have that constraint as well)
11:05:36 <Cale> For example, if you have:
11:05:50 <Cale> data (Ord a) => Set a = Empty | Cons a (Set a)
11:05:54 <vilhelm_s> Hm, so to give some context, what I was hoping was that I could add a constraint to the datatype to be able to write   f :: Frob t -> blah instead of    f::(Ord t, Show t, EtcEtc t...) => Frob t -> blah everywhere.
11:06:39 <Cale> vilhelm_s: Yes, it doesn't work that way. GHC internally refers to the typeclass context on data declarations as "the stupid context" because it doesn't really do anything.
11:06:54 <Cale> vilhelm_s: However, if you use the GADT syntax, you can get the effect you want.
11:06:56 <gwern> o.0 tab-completion in my bin/ directory takes 10 seconds. maybe I need to remove a couple hundred directories...
11:07:08 <idnar> gwern: wow
11:07:11 <killerstorm> hi. i have some problems with GHC-compiled exectuable under Windows -- last few kilobytes of file it writes gets truncated, as if have exited before data was flushed to disk. anybody have seen such problem?
11:07:27 <Cale> data Frob t where (Eq t) => t -> Frob t
11:07:32 <Cale> er
11:07:36 <Cale> data Frob t where Frob :: (Eq t) => t -> Frob t
11:07:47 <Cale> This *will* work the way you were expecting.
11:08:22 <vilhelm_s> Cale: Hm, ok, thanks. Maybe that's what I'll do then. But then I can't do   deriving Show any longer, so it's some extra typing either way. :)
11:08:32 <Cale> right
11:09:16 * ksf thinks Language.C should do preprocessing by itself.
11:09:22 <Cale> killerstorm: Is it a concurrent program?
11:09:30 <ksf> ...at least, macros should be part of the ast.
11:09:47 <Cale> killerstorm: If so, be sure that the main thread stays alive until all the worker threads are finished.
11:10:26 <Cale> killerstorm: It's possible to call hFlush to explicitly flush the data, but somehow I doubt that's the real problem.
11:11:33 <killerstorm> no, it's not. i've found similar problem description, they say it get's fixed with hFlush. but shouldn't it flush automatically when program exits?
11:11:42 <killerstorm> http://www.haskell.org/pipermail/haskell-cafe/2006-January/013854.html
11:11:45 <Cale> killerstorm: I would expect it to as well.
11:13:36 <int80_h> hey youuuu guys!
11:13:38 <Cale> killerstorm: curious.
11:13:45 <killerstorm> aha, next message says that hClose is necessary.
11:13:58 <killerstorm> http://www.haskell.org/pipermail/haskell-cafe/2006-January/013843.html
11:14:59 <Cale> oh, right!
11:15:08 <Cale> You're not simply using writeFile.
11:15:48 <Cale> yes, that fixes it
11:16:23 * ksf doesn't think it's elegant to generate stubs for #define foo(bar) (foo_(bar, 1))
11:16:34 <SamB> what might CPR stand for ?
11:17:03 <Cale> Cardiopulmonary resuscitation?
11:17:24 <SamB> hmm, wrong context!
11:17:26 <Cale> hehe
11:17:27 <SamB> in a compiler, how about ?
11:17:57 * ksf grabs his harbison-steele
11:18:11 <Cale> gcc specifically?
11:18:26 <SamB> Lhc actually
11:18:58 <Cale> There's a paper here on something called "critical path reduction"
11:20:40 <redditbot> Notes on the LHC: Thoughts on a new code generator
11:21:00 <SamB> darnit, WHY does the report Prelude leave all the trickiest instances BLANK?!?
11:21:13 <Cale> SamB: which ones?
11:21:32 <SamB> instance  Enum     Int  where ...
11:21:34 <SamB> this time
11:21:43 <cnwdup> @src foldr
11:21:44 <lambdabot> foldr f z []     = z
11:21:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:22:05 <Cale> SamB: In that case, it might be that the Int type is not fully specified.
11:22:11 <BONUS_> well what do you expect the Int instance for Num to look like
11:22:17 <roconnor> @src Num
11:22:18 <lambdabot> class  (Eq a, Show a) => Num a  where
11:22:18 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:22:18 <lambdabot>     negate, abs, signum     :: a -> a
11:22:18 <lambdabot>     fromInteger             :: Integer -> a
11:22:21 <BONUS_> i mean Enum
11:22:54 <SamB> BONUS_: could you restate your question ?
11:22:59 <BONUS_> data Int = -2147483648 | -2147483647 | -2147483646 ...
11:23:09 <BONUS_> yeah
11:23:10 <SamB> I don't get which thing the "I mean" was meant to replace ...
11:24:19 <BONUS_> like Cale said, the numeric types are usually unspecified cause there's no sensible way to define them in standard Haskell
11:24:26 <BONUS_> that's why the instances are also omitted
11:24:31 <Cale> SamB: Oh, could it be Constructed product result analysis?
11:24:34 <skorpan> @hoogle (a -> Bool) -> a -> Maybe a
11:24:35 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:24:35 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:24:35 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
11:24:56 <SamB> Cale: ah
11:25:56 <Cale> http://research.microsoft.com/%7Esimonpj/Papers/cpr/index.htm
11:27:17 <mreh> does yminsky hang around here?
11:27:38 * pumpkin yawns
11:27:56 * mreh blinks
11:29:47 <chessguy> hey can someone have lambdabot join #ai? i'm trying to demo something
11:30:16 <mauke> @join #ai
11:30:21 <chessguy> thanks
11:32:37 * ksf smiles
11:32:46 <Badger> is there a quick function that'll reverse a string?
11:32:50 <ksf> http://www.cs.york.ac.uk/fp/darcs/cpphs/Language/Preprocessor/Cpphs/MacroPass.hs almost does what I want.
11:32:59 <dmwit_> Badger: reverse
11:33:03 <Badger> @src reverse
11:33:04 <lambdabot> reverse = foldl (flip (:)) []
11:33:15 <Badger> > reverse "indeed?"
11:33:17 <lambdabot>   "?deedni"
11:33:23 <dmwit_> Here's an interesting alternative to the "case () of _ |" construct.
11:33:28 <Badger> heh, wonderful.
11:33:30 <Badger> thanks.
11:33:53 <dmwit_> head $ [a | foo] ++ [b | bar] ++ [c | otherwise]
11:34:13 <ksf> has anyone ever tried to preprocess real-world, evil C source with cpphs?
11:34:59 <dmwit_> Language.C was tested against the Linux kernel.
11:35:15 <dmwit_> Does cpphs use Language.C?
11:35:21 <ksf> nope.
11:35:23 <thoughtpolice> no, don't believe so.
11:35:33 <ksf> Language.C uses cpp to preprocess, by default.
11:35:36 <thoughtpolice> but Language.C is pretty battle-tested and fast
11:35:57 <ksf> that is, it hasn't got any idea what a #define is about.
11:36:04 * dmwit_ nods
11:36:05 <pumpkin> @seen dons
11:36:05 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 16h 21m 27s ago.
11:36:07 <dmwit_> sorry
11:37:02 <ksf> ...while my plan is to generate stubs out of #defines.
11:37:42 <pumpkin> you could run it through gcc -E first, and then cut out the remaining # that indicate what file/line bits of the output came from?
11:38:07 <pumpkin> not a very elegant solution though :/
11:38:47 <hcube> hi!
11:39:30 <pumpkin> hi!
11:40:58 <skorpan> is there any way to override an imported intantiation of Show?
11:41:10 <ksf> cpphs: Cannot parse #if directive in file /usr/X11R6/include/features.h  at line 172 col 1
11:41:11 <skorpan> e.g. say i want to make my own show function for Bool
11:41:12 <ksf> gragh
11:41:34 <ksf> #if (!defined __STRICT_ANSI__ && !defined _ISOC99_SOURCE && \
11:42:01 <bodq> skorpan: you could define a newtype for Bool
11:42:29 <skorpan> newtype Bool = True | False?
11:42:46 <bodq> skorpan: newtype MyBool = MyBool Bool
11:43:31 <ksf> better, newtype MyBool = MyBool {unMyBool :: Bool}
11:43:58 <bodq> skorpan: instance Show MyBool where show (MyBool True) = "yes" ; show (MyBool False) = "no"
11:44:15 <bodq> skorpan: modulo syntax errors :)
11:44:26 <jimki> shouldn't that be data myBool?
11:44:36 <bodq> jimki: no, why?
11:44:47 <skorpan> so there's no easier way? :(
11:45:07 <jimki> ok guess I'm still confused with those :)
11:45:08 <bodq> skorpan: I don't know :) what are you trying to do?
11:45:10 <skorpan> i guess i *could* make a normal function.
11:45:16 <skorpan> bodq: i'm trying to pretty-print Permissions
11:45:37 <skorpan> i can't stand Permissions { readable = True, ... } etc.
11:46:19 <bodq> skorpan: how would you like it to look? r-xs ?
11:46:28 <skorpan> bodq: something like that
11:46:43 <bodq> skorpan: right, so this is not about bool?
11:46:49 <skorpan> no, not really :)
11:46:55 <skorpan> i tried to simplify the problem
11:47:28 <lispy> skorpan: well, you could name the Permissions, like let rxs = Permissions { readable = True, Executable = True, ... }
11:47:38 <lispy> and you could use _ instead of -
11:47:51 <bodq> skorpan: the newType it is. assuming your code is polymorphic, you would need to change very little of it
11:48:09 <bodq> lispy: it's about show not read
11:48:20 <lispy> ah
11:48:23 <bodq> skorpan: err 'newtype'
11:48:27 <skorpan> yeah, i got it
11:48:38 <lispy> bodq: I was thinking in terms of writing the code and passing the Perms to the function
11:49:11 <bodq> skorpan: as a consolation, I can offer an explanation of why this is not possible :)
11:49:54 <skorpan> bodq: go ahead, i'm all ears!
11:52:23 <bodq> skorpan: well it's a lousy explanation. basically it's a design decision in haskell that you don't have namespaces like you would have in python. i.e. imports are global
11:52:50 <bodq> skorpan: so once you have a definition of show :: Permission -> String in this global namespace you can not have another one
11:53:12 <skorpan> i was thinking maybe you could hide instances the way you hide functions
11:53:21 <bodq> skorpan: and you can not override it as well, because that would break some functions that depend on the former
11:55:12 <rntz> well, no, you do have namespaces. but show is in the prelude...
11:55:13 <bodq> skorpan: imagine you define a new class in your module
11:55:17 <pumpkin> what's a good way to make quickcheck generate meaningful comparison functions for testing *By functions?
11:55:27 <bodq> err new type
11:55:53 <true\false> Gotsa question, in the context of: in  pre : case suf of  I assume pre is just joined to the result of the case?
11:56:00 <bodq> skorpan: so if you declare if a member of eq, and call e.g. elem, elem must know that the type is a member of eq
11:56:07 <bodq> skorpan: that's why it must be global
11:56:18 <bodq> true\false: yes
11:56:25 <true\false> Ta..
11:56:32 <bodq> true\false: joined is not a proper word perhaps
11:56:47 <true\false> bodq: The lists are joined then
11:57:29 <bodq> true\false: no, a new list cell created
11:57:37 <bodq> true\false: do you understand the concept of a list?
11:57:40 <roconnor> I'm so much smarter today than 10 years ago.  It's almost as if I shouldn't have bothered writing programs back then. :P
11:58:01 <true\false> bodq: A collection of elements of a given type?
11:58:07 * roconnor has a pretty elegant solution to computing coordinates on a hexagonal grid
11:58:08 <bodq> true\false: not quite
11:58:51 <bodq> true\false: a list is basically a tuple. data MyList a = MyList { head :: a , tail :: [a] }
11:59:09 <bodq> true\false: (:) operator creates a new tuple and a new list
11:59:26 <bodq> true\false: does that make sense?
11:59:46 <bodq> roconnor: if you're 21 then yes :)
12:00:14 <true\false> bodq: to a degree
12:01:02 <pumpkin> > minimumBy (const GT) [1..10]
12:01:05 <lambdabot>   Couldn't match expected type `a -> Ordering'
12:01:33 <pumpkin> > minimumBy (const . const GT) [1..10]
12:01:36 <roconnor> bodq: I'm 31 years :(
12:01:37 <lambdabot>   10
12:01:44 <pumpkin> > minimumBy (const . const EQ) [1..10]
12:01:48 <lambdabot>   1
12:02:23 <roconnor> bodq: 20 years ago I was using gotos
12:02:37 <pumpkin> @src minimumBy
12:02:37 <lambdabot> Source not found. That's something I cannot allow to happen.
12:02:42 <bodq> roconnor: well those were different times
12:02:44 <pao> roconnor: basic with c64?
12:02:46 <dolio> Real programmers use gotos.
12:02:48 <pao> roconnor: :-)
12:03:08 <dolio> Now you're merely a quiche eater.
12:03:24 <roconnor> pao: gwbasic maybe
12:03:30 <int80_h> wait, can't I eat quiche and use goto?
12:03:37 <bodq> shit
12:03:46 <roconnor> before that basic on an apple ][ clone
12:03:48 * bodq has realized that he has been doing programming for 10 years now
12:03:50 <vixey> @go GOTO++ abject oriented programming
12:03:52 <bodq> omw time flies
12:03:52 <lambdabot> No Result Found.
12:04:09 <roconnor> before that basic on a ZX81
12:04:36 <roconnor> basic on the apple ][ sucked.  You had to write out the entire keywords!
12:04:42 <roconnor> what's up with that?
12:05:47 <ksf> wtf... "Warning: Can't find file "agar/core/queue.h> /* For FOO_ENTRY macros *" in directories"
12:05:52 <ksf> that's a strange file name.
12:08:15 <roconnor> vector:VectorSpaces::______:Module
12:08:20 <roconnor> vector:VectorSpace::______:Module
12:13:38 <koeien> roconnor: no idea, maybe ask #math ?
12:14:37 <roconnor> koeien: good idea
12:14:58 <koeien> wikipedia doesn't help in this case :/
12:15:02 <dolio> Seems like I should know that, but I don't.
12:15:19 <koeien> yeah, i don't as well... strange
12:15:51 <kerlo> Hey, there's a web site with various programming challenges of various difficulties, isn't there?
12:16:07 <true\false> Is that the one centred around maths?
12:16:18 <kerlo> I think so.
12:16:25 <kiris> project euler?
12:16:25 <true\false> Might have it in firefox
12:16:49 <pumpkin> bah, I wish quickcheck could print out the function it fails on
12:16:57 <pumpkin> (the generated function)
12:17:02 <pumpkin> <function> isn't too helpful
12:17:04 <kiris> Dijkstra would like this
12:17:28 <kerlo> Yeah, Project Euler is it.
12:17:39 <mauke> http://www.spoj.pl
12:18:54 <necroforest> There's a python-specific site like that too
12:19:12 <vegai> pumpkin: perhaps test-framework could help you there
12:19:31 <pumpkin> how so?
12:19:51 * ksf thinks c2hs should become suspicious if it encounters a cdecl with a body and require explicit "wrap" and "nowrap" args to fun.
12:20:01 <vegai> it gives out a bit nicer reports than the defaults
12:20:18 <vegai> though I'm not sure if it does so in that particular case
12:20:28 <hackage> Uploaded to hackage: HNM 0.1.2
12:20:31 <pumpkin> vegai: well the overall reports are fine, but quickcheck is failing on a higher-order function, and there's really no easy way to make it print out the function it fails on
12:20:55 <ksf> there might be libraries that provide __inline__ defs in the headers while simultaneously compiling them into the .so, that is.
12:20:57 <vegai> Ah.
12:23:04 * ksf fears that there's no painless way for a preprocessor to tell cabal that it produced both a .hs and a .c and that both need to be compiled.
12:24:23 <ztirF> so if I wanted to generate 10000 pairs of random numbers, how can I do that without a stack overflow?
12:24:39 <pumpkin> why would you get a stack overflow?
12:24:50 <int80_h> because he stole my broken code?
12:24:50 <skorpan> use teh laaayzzz
12:25:18 <ztirF> well, if I use r = State randomR (0.0,1.0)
12:25:29 <dcoutts> ksf: indeed
12:26:00 <ztirF> then last $ evalstate (replicateM 20000 r) gives me a stack overflow
12:26:11 <ztirF> is that just a stupid way to do it?
12:26:40 <dcoutts> ksf: we've got a ticket for it, but it's not implemented yet.
12:27:37 <Cale> ztirF: You might find that if you don't just take the last one, you won't get a stack overflow
12:28:00 <Cale> ztirF: One idea would be to switch to the strict state monad if you really want to skip 20000 of them at a time like that.
12:28:18 <ztirF> cale: ok, so the reason I was trying to generate all of them at once
12:28:37 <ztirF> Cale: was to factor the RNG out of an inner loop
12:28:38 <Cale> ztirF: You were trying to calculate only the 20000th one without computing the others
12:28:54 <ztirF> well no, in my program I want to calculate all of them
12:28:58 <Cale> ztirF: Which generated a very large expression in which the outermost reducible subexpression was very deep
12:29:00 <pumpkin> bah
12:29:12 <Cale> ztirF: Then why the 'last'?
12:29:17 * pumpkin is getting frustrated
12:29:47 <ztirF> Cale: it was just to force evaluation of all the numbers so I could benchmark the generator
12:29:54 <Cale> ah, but it doesn't force them all
12:29:58 <vixey> benchmark tells you that it crashes :p
12:30:01 <Cale> It only forces the 20000'th one.
12:30:02 <pumpkin> use rnf
12:30:11 <pumpkin> from Control.Parallel.Strategies
12:30:18 <vixey> why benchmark a generator?
12:30:41 <ztirF> vixey: my code to do inverse transform sampling is really slow and I'm trying to figure out why
12:30:58 <Cale> ztirF: StdGen is unfortunately a lot slower than it should be
12:31:00 <vixey> ztirF, probably make more sense to focus on that then
12:31:08 <vixey> ztirF, try dons mersenne prime generator
12:31:12 <Cale> ztirF: Have you profiled it?
12:31:21 <Cale> (your code, I mean)
12:32:28 <pumpkin> YAY
12:32:36 * pumpkin wins
12:32:39 <gnut> hi all
12:32:46 <ztirF> Cale: yes.  There are basically two operations involved: computing partial sums of an array and table lookup
12:32:56 <ztirF> the table lookup doesn't seem to be taking long
12:33:03 <gnut> what are haskell's plans for distributed memory systems?
12:33:16 <idnar> what is a distributed memory system?
12:33:50 <gnut> something where the memory is not all shared, like a cluster or a supercomputer
12:33:51 <ztirF> and the partial sums of the array is getting inlined
12:33:56 <gnut> or the ps3
12:34:17 <ztirF> so I was going to try pulling the RNG out of the inner loop
12:34:27 <ztirF> but that only seems to make things slower
12:35:56 <gnut> I just went to a talk on high-performance computing and it seems like everyone is moving away from fortran to C/C++... with some C extensions called UPC (unified parallel C)
12:36:01 <pejo> gnut, there's a number of different synchronising primitives available, and also higher level stuff built on top of those.
12:37:15 <gnut> pejo: forgive my ignorance on the subject, as I'm just trying to get into it myself :), but are you referring to STM?
12:44:11 <lazynick> @quote
12:44:12 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
12:45:52 <monochrom> hahaha
12:46:05 <stepcut> b
12:46:17 <stepcut> (sorry, missed a modifier key)
12:49:59 <snookerb> hey ho
12:50:10 <snookerb> i have a short notation question
12:50:11 <snookerb> subst_in_Stmts:: Var -> Var -> [Stmt] -> [Stmt]
12:50:19 <snookerb> subst_in_Stmts  fpar@(Var fpid)  actpar stmts  = ...
12:50:24 <snookerb> what does the @ do?
12:50:42 <lazynick> as-pattern
12:50:47 <mauke> aliasing
12:50:58 <lazynick> the whole argument is bound to fpar
12:51:02 <snookerb> mhh
12:51:02 <Peaker> snookerb: fpar is the name of the whole Var value
12:51:12 <snookerb> wait
12:51:15 <lazynick> the inner compontent is bound to fpid
12:51:18 <snookerb> the second var = actpar
12:51:24 <snookerb> the stmt is also clear
12:51:51 <snookerb> so the first parameter goes to  fpar
12:51:52 <snookerb> ?
12:52:00 <lazynick> yes
12:52:03 <snookerb> ok
12:52:15 <snookerb> and what would be the difference if i left the subst_in_Stmts:: Var -> Var -> [Stmt] -> [Stmt]
12:52:22 <snookerb> sorry
12:52:24 <snookerb> wrong paste
12:52:36 <snookerb> what would be the difference if i left the @(Var fpid)
12:52:37 <snookerb> ?
12:52:56 <lazynick> left it out?  you would have an fpar in the body of the function
12:53:03 <lazynick> wouldn't*
12:53:28 <lazynick> oh wait
12:53:29 <snookerb> mhh
12:53:34 <snookerb> sorry, still quite confused
12:53:46 <snookerb> i mean, i get all the ideao of parameters and so
12:53:50 <snookerb> just the @ confuses me
12:53:56 <snookerb> what effect does it have
12:54:06 <Etenim> Hm. Why does it? The as-patterns are quite straightforward, snookerb
12:54:31 <lazynick> f x@(Blah y) = z    -->   f x = case x of Blah y -> z
12:54:46 <snookerb> ok, please try again
12:54:55 <snookerb> ahh ok
12:54:56 <snookerb> thanks
12:55:00 <snookerb> that helped a lot
12:55:02 <mauke> > case "Hello" of a@(b : c) -> (a, b, c)
12:55:04 <lambdabot>   ("Hello",'H',"ello")
12:55:14 <snookerb> thanks
12:55:15 <snookerb> perfekt
12:55:17 <snookerb> i got it
12:55:18 <snookerb> yeahhh
12:55:19 <snookerb> !
12:56:42 <Etenim> Mhh. Does anyone know a good online article covering proper Haskell programming styles? I feel that my code becomes unreadable for others quite quickly.
12:57:03 <vixey> Etenim, I think that is something you learn by reading other peoples code
12:57:39 <Etenim> Likely. Can you suggest some professional resources, vixey?
12:57:48 <vixey> no
12:59:11 <Peaker> Etenim: I think code review feedback is the best way.. maybe #haskell can suggest stuff on your code?
13:00:42 <ztirF> I get how to use seq, but I don't understand rnf
13:01:27 <pumpkin> what about it?
13:01:37 <Deewiant> ztirF: rnf is like a "deepSeq"
13:01:39 <pumpkin> oh, its return value?
13:01:57 <pumpkin> you could do something like rnf a `seq` a
13:02:12 <pumpkin> but it's typically used with other functions from parallel.strategies
13:02:21 <ztirF> but what if I want to use a in a calculation later
13:02:22 <vixey> pumpkin, I don't think so.
13:02:24 <bodq> RWH is boring :(
13:02:34 <vixey> @hoogle rnf
13:02:35 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
13:02:58 <pumpkin> what about it?
13:03:01 <lazynick> @src Strategy
13:03:02 <lambdabot> Source not found. There are some things that I just don't know.
13:03:10 <vixey> @docs Control.Parallel.Strategies
13:03:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
13:03:13 <Deewiant> @ty rnf
13:03:15 <lambdabot> forall a. (NFData a) => a -> Done
13:03:24 <Deewiant> that's the type I remember :-P
13:03:32 <vixey> type Strategy a = a -> Done
13:03:40 <Deewiant> d'oh
13:03:41 <ztirF> right, so how do I use "Done" ?
13:03:47 <vixey> type Done = ()
13:04:08 <lazynick> pumpkin told you how
13:04:17 <pumpkin> apparently I was wrong?
13:04:19 <lazynick> `seq` it with your eventual result
13:05:29 <ztirF> gotcha
13:07:12 <Etenim> Peaker, hm. Aye.
13:08:04 <Etenim> http://pastebin.com/d2e02fc23 -- Could someone please have a look and comment on my style of programming?
13:08:12 <ksf> ztirF, sfmt (mersenne-random) is going to solve all your performance problems wrt. random numbers. don't be surprised to see a 100x speedup, it's the fastest generator in existence.
13:08:25 <Etenim> I, personally, feel that I am raping lambda expressions.
13:08:40 <ztirF> ksf: which package is that in?
13:09:04 <ksf> mersenne-random
13:09:11 <ksf> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-0.1.3
13:09:35 <ztirF> thanks
13:10:54 <Peaker> Etenim: I might have suggestions about how to refactor the code to be more functional, or composed of simpler parts, but I can't right now
13:11:10 <ksf> then you can do newMTGen 0xdeadbeef >>= randoms >>= return . last and see what happenes ;)
13:13:31 <snookerb> what was again the notation to cast
13:13:37 <snookerb> i habe an int
13:13:43 <mauke> there is no cast
13:13:45 <monadic_kid> awwwww
13:13:45 <lazynick> fromInteger
13:13:45 <snookerb> i want to cast an float to int
13:13:51 <lazynick> Integral*
13:13:52 <snookerb> this way
13:13:54 <snookerb> ;-)
13:13:57 <ksf> round, ceil, floor.
13:13:58 <Peaker> snookerb: floor?
13:14:05 <ksf> *ceiling
13:14:06 <Peaker> > round -0.4
13:14:08 <lambdabot>       No instance for (Fractional (a -> b))
13:14:08 <lambdabot>        arising from the literal `...
13:14:10 <snookerb> yeah, in this case sure a better way
13:14:11 <snookerb> ;-)
13:14:13 <Peaker> > round (-0.4)
13:14:14 <snookerb> thanks
13:14:14 <lambdabot>   0
13:14:23 <Peaker> > round (-0.9)
13:14:25 <lambdabot>   -1
13:14:50 <snookerb> perfekt
13:14:52 <lazynick> no love for the truncate ;_;
13:14:57 <snookerb> thanks
13:15:00 <Etenim> Peaker, no problem. It's just my first Haskell program and I don't quite know what to improve. :)
13:15:15 <ksf> > Unsafe.Coerce.unsafeCoerce (-1.0) :: Int
13:15:17 <lambdabot>   /tmp/5385871595362337663:70:40:
13:15:17 <lambdabot>      Not in scope: `Unsafe.Coerce.unsafeCoe...
13:15:21 <ksf> bah
13:15:53 <Peaker> Etenim: btw Why do you use fromIntegral on the args to Size there?  Literal numbers are polymorphic
13:16:16 <SamB> arg, why doesn't GHC's RTS write profiling data on ^C :-(
13:16:35 <ksf> because he's an ocaml coder and quickly defined (./) = (/)?
13:17:02 <vixey> (/.)**
13:17:16 <Peaker> Etenim: your functions are pretty *huge*, can you break them up into smaller ones and give the small ones names?
13:17:36 <mjb> SamB: Tried ^D or ^Break if you're on Windows?
13:17:56 <SamB> I'm not on windows
13:18:27 <vixey> SamB, well that's your problem right there
13:19:02 <ksf> Etenim, you could try to rewrite it without all those superscripts and math, it makes me skip the code.
13:19:21 <SamB> vixey: that's an unusual type of problem for GHC ...
13:19:34 <SamB> usualy they say that it's a problem if you ARE
13:19:35 <Etenim> Peaker, good question. Those shouldn't be there. Thanks for noticing that. - Is splitting larger functions into smaller ones the general approach? And, yes, I guess, I can.
13:19:40 <mjb> SamB: What about ^D?
13:20:03 <Peaker> Etenim: yes - and its easier to see simplifications that can be done to a small function than a page wall of text :)
13:20:26 <ksf> (actually, it's quite fun to generalise algorithms from 1, 2 and 3d to Nd with lists)
13:22:01 <olsner> @pl (\(a,b) -> (p1', p2'))
13:22:01 <lambdabot> const (p1', p2')
13:22:17 <olsner> that one appears a bunch of times
13:23:03 * ksf sees enough matches for pyth a b = a*a + b*b to use it everywhere
13:23:28 <Peaker> pyth = (+) `on` (^2) :-)
13:23:49 <trofi> 8)
13:23:51 <vixey> It's easy to open up a binder and compute some below that,  but the difficult bit is pushing the binder back on -- and making the relevant transform to the object you computed
13:23:56 <ddarius> (+) `on` join (*)
13:24:08 <Peaker> ddarius: why join (*) when there's (^2)?
13:24:19 <SamB> Peaker: it optimizes better
13:24:27 <vixey> @let square = join (*)
13:24:30 <lambdabot>  Defined.
13:24:42 <vixey> @let squares = map square
13:24:45 <lambdabot>  Defined.
13:24:48 <ksf> s/*2/<<1/g
13:24:49 <vixey> :t sum . squares
13:24:51 <lambdabot> forall a. (Num a) => [a] -> a
13:24:58 <pejo> We need compilers that optimize better.
13:25:29 <pumpkin> I'm addicted to writing tests for uvector now
13:25:39 <pumpkin> must pry myself away
13:25:47 <lazynick> there are worse addictions :)
13:25:47 <ddarius> pumpkin: Use hpc to decide on tests until you get 100% coverage
13:25:51 <SamB> write tests for Haskell 98 instead
13:26:04 <SamB> only use the hierarchical libs instead of the haskell98 package
13:26:05 <pumpkin> ddarius: that's what I'm doing :P seeing those bars get longer feels too good for me to stop
13:26:15 <pumpkin> but I have real work I need to be doing
13:26:31 <ddarius> pumpkin: Start using hpc on your real work
13:26:34 <vixey> I wish someone would give me some code or paper or something about syntax
13:26:52 <vixey> although I probably read most of what's relevant :/
13:26:57 <pumpkin> ddarius: one some of it, I definitely will, but the work I need to be doing now isn't even in haskell and can't be :/
13:27:39 <pejo> vixey, are you loooking for papers on syntax, or just any paper?
13:27:39 <olsner> Etenim: also, sequence_ (map f ...) = mapM_ f
13:27:57 <vixey> syntax pejo, with binding
13:28:11 <vixey> that  I am not a number I am a free variable  is great
13:28:16 <Etenim> olsner, ah. Good to know. Thanks.
13:28:53 <Etenim> Peaker, aye. I will try to do that tomorrow. :) Unfortunately, I have to leave.
13:28:57 <Etenim> Thanks again. Cheers.
13:29:17 <pumpkin> :t lookup
13:29:18 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:30:17 <pejo> vixey, have you scanned the papers that cite that one?
13:33:39 <vixey> no that's a good idea. maybe it's time I found out what 'explicit substitutions' are
13:36:13 <Peaker> @hoogle hlint
13:36:14 <lambdabot> No results found
13:44:03 <roconnor> @src Enum
13:44:04 <lambdabot> class  Enum a   where
13:44:04 <lambdabot>     succ                     :: a -> a
13:44:04 <lambdabot>     pred                     :: a -> a
13:44:04 <lambdabot>     toEnum                   :: Int -> a
13:44:04 <lambdabot>     fromEnum                 :: a -> Int
13:44:06 <lambdabot> [3 @more lines]
13:44:12 <roconnor> @more
13:44:13 <lambdabot>     enumFrom                 :: a -> [a]
13:44:13 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
13:44:13 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
13:45:24 <roconnor> does it make sense to make an Enum out of a data type with 6 elements arranged in a circle?
13:45:59 <vixey> to me that makes sense
13:46:05 <SamB> it makes sense
13:46:08 <SamB> but it shouldn'
13:46:13 <SamB> t enumerate in a circle
13:46:32 <tromp__> integers mod 6?
13:46:55 * ksf is tempted to suggest "allow '' in addition to `'" as c2hs feature
13:47:05 <SamB> i.e. just derive it
13:48:56 <tromp__> i had the same dilemma in my Haskell formulation of the rules of go; are the coordinates Ints or Enums?
13:49:51 <Botje> but Int is an instance of Enum :)
13:51:08 <tromp__> I ended up with one version using type Coord = Int and fancier version using class (Eq c, Ord c, Bounded c, Enum c, Show c) => Coord c
13:51:36 <mauke> Eq c is redundant
13:51:51 <tromp__> right; implied by Ord
13:52:02 <idnar> the presence of Show c there is a bit weirrd
13:52:45 <tromp__> i had to be able to show coords
13:53:19 <idnar> sure, but you could just add the Show constraint to the functions that need it
13:53:31 <idnar> anyhow, I guess it doesn't matter much
13:53:34 <tromp__> see http://homepages.cwi.nl/~tromp/go/Go.hs
13:57:47 <roconnor> SamB: I want it to enumerate in a circle (hence I would be writing my own instance)
13:58:14 <pumpkin> is this normal?
13:58:15 <SamB> roconnor: I don't think that's an appropriate use of Enum
13:58:20 <pumpkin> > [0,0..0]
13:58:21 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:58:32 <roconnor> SamB: oh?
13:58:38 <roconnor> ok
13:59:01 <SamB> roconnor: well, Jhc's Enum Int instance was doing that this morning  ...
13:59:03 <ztirF> man my program is seriously screwed up
13:59:05 <SamB> er. Lhc.
13:59:05 <trofi> > fix (0:)
13:59:06 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:59:12 <xd_> > cycle [0..5]
13:59:14 <lambdabot>   [0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,...
13:59:15 <SamB> I sometimes forget the name change
13:59:31 <ztirF> Using System.Random.Mersenne instead of System.Random made it run 3x *slower*
13:59:39 <ztirF> I don't know what the hell is going on
13:59:55 <SamB> (yeah, I know it's technically a fork but it's hard to think of it that way when John doesn't do anything to Jhc...)
13:59:56 <vixey> wow
14:00:22 <roconnor> SamB: but my data is actually in a circle
14:00:29 <Heffalump> SamB: I thought he does have bursts of activity
14:00:40 <roconnor> SamB: they are direction you can move on a hex grid
14:01:04 <SamB> roconnor: hmm ... hmm ... well, okay, maybe it does make sense now that I think about it ...
14:01:16 <roconnor> SamB: I'm torn
14:01:19 <SamB> > [2..0]
14:01:21 <lambdabot>   []
14:01:24 <SamB> yeah, it does
14:01:32 <SamB> [x..y] always goes to the right
14:01:38 <SamB> oh, no, wait
14:01:45 <SamB> how many times around should it go ?
14:02:12 <roconnor> indeed
14:02:29 <roconnor> esp [x,y ... z]
14:02:41 <ztirF> this is such a nightmare
14:02:42 <roconnor> maybe I will avoid an Enum instance
14:02:54 <roconnor> and write my own functions
14:05:47 <pumpkin> > [0,0..0] -- this is intended behavior? :o
14:05:48 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:06:00 <SamB> pumpkin: the standard doesn't seem to say?
14:06:06 <pumpkin> > [-1,-1..2]
14:06:07 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
14:06:19 <pumpkin> fair enough, I guess :)
14:06:23 <mauke> > [1,1..0]
14:06:25 <lambdabot>   []
14:06:27 <Botje> it's a great golf for repeat 0 though
14:06:32 <SamB> it completely leaves out the implementation Enum Int, on which almost all other Enum instances are directly based
14:07:19 <bombshelter13> Okay, I'm a relatively new student of the language, and have, for the first time, encountered an arrow that points to the LEFT (<-)! It confuses and frightens me. I thought I understood your normal, rightwards pointing arrow, but I get the feeling this is something completely different. I googled 'Haskell arrows' and am not sure if what I found is actually about the symbol I'm trying to learn about. What is this symbol, and where is i
14:07:31 <earthy> :)
14:07:37 <Botje> bombshelter13: look up haskell "do syntax" instead
14:07:39 <mauke> bombshelter13: whoa, calm down
14:07:51 <mauke> http://mauke.ath.cx/stuff/haskell/how-to-io.html#a7
14:07:58 <earthy> bombshelter13: the <- arrow can be thought of as an 'assignment' even if that is only a partial intuition
14:08:01 <elly> bombshelter13: I like that description of do-notation
14:08:12 <tromp__> it's jsut syntactic sugar
14:08:23 <rntz> bombshelter13: googling "haskell arrows" will *not* help you with (<-)
14:08:28 <opqdonut> :D
14:08:28 <rntz> those are entirely different
14:08:43 <bombshelter13> heh, alright... good :)
14:08:50 <bombshelter13> *reads mauke's link*
14:09:14 <earthy> the seqeuence enumFromThenTo e1 e2 e3 is the list [e1,e1+i,e1+2i, ... e3] where the increment i is e2-e1
14:09:37 <tromp__> do a <- b; c is sugar for b >>= (\a -> c)
14:09:52 <ddarius> "The sequence enumFromThenTo e1 e2 e3 is the list [e1,e1+i,e1+2i,...e3], where the increment, i, is e2-e1. If the increment is positive or zero, the list terminates when the next element would be greater than e3;"
14:09:56 <Botje> tromp__++ # flipping arrows like nobody's business
14:09:57 <roconnor> @fixity +
14:09:58 <lambdabot> Unknown command, try @list
14:10:00 <earthy> If the increment is positive or zero the list terminates when the next element would be greater than e3
14:10:06 <rntz> what tromp__ says is true... but unhelpful if you don't already get monads
14:10:09 <earthy> so, [0,0..0] is indeed equivalent to repeat 0
14:10:31 <monochrom> <- is unrelated to -> .
14:10:32 <ddarius> rntz: It gets rid of the fear-inducing left pointing arrow though.
14:10:37 <rntz> true
14:10:39 <opqdonut> and [0,0..] is even shorter
14:11:03 <BMeph> roconnor: Yes, I think the main issue is how to tell a list of circular Enums to stop after one (or two) cycles. :)
14:11:10 <tromp__> > [0,0..-1]
14:11:11 <lambdabot>   Not in scope: `..-'
14:11:18 <tromp__> > [0,0..(-1)]
14:11:19 <lambdabot>   []
14:12:50 <bombshelter13> >>= is also new and dificult to google for. :/
14:13:07 <bombshelter13> Is there a nice big list of the name of every non-alphanumeric operator's name somewhere?
14:13:19 <tromp__> >>= is also called bind
14:13:22 <roconnor> BMeph: in my case I would do map (\i -> turn (Bearing i) heading) [0..n]
14:13:36 <roconnor> but I think I won't use an enum for headings
14:14:17 <roconnor> map (\i -> turn (cw i) heading) [0..n]
14:14:19 <roconnor> actually
14:14:29 <mauke> bombshelter13: you can read the rest of my document (but that doesn't tell you the whole story)
14:15:02 <bombshelter13> mauke: alright, I'm still working my way through it :) *continues to do so*
14:15:10 <ddarius> @google zvon haskell
14:15:14 <rntz> bombshelter13: >>= is part of the Monad typeclass. understanding monads can be hard for newbies, but it's important... I can't remember which tutorial helped me most, but googling "Monads" or "Monad haskell" might help
14:15:22 <lambdabot> http://www.zvon.org/other/haskell/Outputglobal/index.html
14:15:22 <lambdabot> Title: Haskell
14:15:49 <bombshelter13> rntz: Yeah, I'm just getting to them now and encountering some of these... :)
14:15:50 <ddarius> bombshelter13: That site is a catalog of functions.  There is, of course, always the Report or the library documentation.
14:16:11 * bombshelter13 is sure he'll catch on once he's read the right explanation. ;)
14:16:22 <ddarius> http://haskell.org/onlinereport/prelude-index.html  http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
14:17:11 <BMeph> bombshelter13: ddarius' second reference is (IMNSHO) the best place to start. :)
14:18:12 <xenoblitz> Hi guys ... I'm trying to add sequential composition to my language... I was wondering whether to make the infix constructor for sequential operations infixr or infixl... does this really make a difference or not in the end?
14:18:27 <pumpkin> depends on your operator
14:18:48 <pumpkin> > 5 / 6 / 7
14:18:50 <lambdabot>   0.11904761904761905
14:18:56 <bombshelter13> BMeph, ddarius: cool... I've stumbled on those a couple of times but there's so much documentation that it's hard to narrow down what to read, I suppose I'll focus on those for a bit... ordered a book a while ago too but still waiting for it to get here. :)
14:19:04 <Heffalump> xenoblitz: I usually prefer infixr for associative operators
14:19:10 <pumpkin> > 5 / (6 / 7)
14:19:12 <lambdabot>   5.833333333333334
14:19:14 <Heffalump> because that fits in with lists better
14:19:25 <xenoblitz> pumpkin: yeah it makes a huge difference
14:19:41 <ddarius> bombshelter13: Those are indexes to reference documentation, not something you would sit down and read.
14:19:42 <xenoblitz> Heffalump: yeah I think so the same as well... I was just wondering if I'm heading in the wrong direction that's all :)
14:19:50 <Heffalump> I don't think it's a big deal.
14:19:58 <vixey> Gentzen's proof also highlights one commonly missed aspect of Gödel's second incompleteness theorem. It's sometimes claimed that the consistency of a theory can only be proved in a stronger theory. The theory obtained by adding quantifier free transfinite induction to primitive recursive arithmetic proves the consistency of first-order arithmetic but is not stronger than first-order arithmetic
14:20:15 <Heffalump> If the operator is a function rather than a constructor then you need to be more careful - making (++) infixl would be disastrous for performance, for example.
14:20:31 <Heffalump> So similarly if you might turn it into (++) or similar at some point, then infixr is strongly indicated.
14:21:03 <ddarius> vixey: If first-order arithmetic can prove it's own consistency, then that's not saying anything and if not then it is self-contradictory.
14:21:12 <bombshelter13> ddarious: yeah, I'll probably not read bits like libraries that apply to problms i'm uninterested in...
14:21:34 <Cale> If there is the possibility that the operation can produce part of its result by only looking at (pattern matching) its left parameter, it should be infixr.
14:21:35 <xenoblitz> Heffalump: thanks I'll switch it to infixr and see how it goes :) thanks
14:21:51 <xenoblitz> Cale: yes there are cases
14:22:01 <pumpkin> > [-2,-1..2]
14:22:02 <lambdabot>   [-2,-1,0,1,2]
14:22:07 <pumpkin> > [-2,-2..2]
14:22:09 <lambdabot>   [-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2...
14:22:12 <Heffalump> well, the same applies for the right parameter
14:22:15 <Heffalump> but left is more natural
14:22:37 <xenoblitz> thanks guys... :)
14:22:54 <ddarius> Heffalump: For sequential composition, right associative is probably best.
14:23:33 <vixey> so is that passage nonsense?
14:23:47 <xenoblitz> its nice to get a second opinion from a place like this :)... you know its been discussed before hehe
14:23:55 <Heffalump> I can't recall such a discussion
14:24:09 <Heffalump> it's just a case of fools seldom differing ;-)
14:24:10 <xenoblitz> Heffalump: or at least people have thought about it before me :P
14:24:26 <xenoblitz> Heffalump: could be hehe
14:24:33 <bodq> does anyone know a book/wiki with 'haskell puzzles' ? stuff like let foldl f z xs = foldr (\g x -> g . (`f` x)) id xs z should go there
14:24:47 <vixey> bodq, you mean spoilers or puzzles?
14:25:07 <bodq> eh, spoilers?
14:25:42 <bodq> I mean 'beautiful and bizzare ways to do things'
14:26:18 <opqdonut> bodq: have you seen "the evolution of a haskell programmer"
14:26:40 <bodq> opqdonut: yes :) I could not understand most of it at the time :)
14:26:51 <bodq> opqdonut: it's good :)
14:27:01 <opqdonut> yeh
14:28:20 <bodq> beginning Peano player hahaha
14:28:42 <monochrom> Do you want a 12-inch Peanist?
14:28:53 <opqdonut> 8]
14:29:16 <bodq> so I don't get this (n+k) thing -- can anyone explain?
14:29:29 <opqdonut> n+k-patterns?
14:29:46 <opqdonut> they're just structural recursion on the natural numbers
14:29:46 <Heffalump> they're a hack
14:29:53 <opqdonut> or that's what they were intended for
14:29:55 <bodq> “Ban n+k patterns”-movement
14:29:57 <opqdonut> don't use them :P
14:30:02 <Heffalump> well, they would be if Int was defined as a structural natural number
14:30:11 <Heffalump> they're being removed from the next standard
14:30:11 <bodq> um
14:30:25 <bodq> sometimes it's convenient if you do (n-1) many times in the function
14:30:39 <Heffalump> yes, that's true
14:30:53 <Heffalump> but the consensus was that they're an ugly special case that aren't worth it
14:30:57 <bodq> and they are funny :)
14:31:04 <bodq> err I find them funny
14:31:33 <bodq> but banning them sounds too extreme
14:31:42 <bodq> why would people hate them?
14:31:55 <augustss> Thet are a one-of-a-kind abomination
14:31:55 <lambdabot> augustss: You have 1 new message. '/msg lambdabot @messages' to read it.
14:31:57 <monochrom> > let {f 0 = 0; f (x+1) = 1 + f x} in f 10
14:31:59 <lambdabot>   10
14:31:59 <tromp__> they're only useful for showing factorial functions in tutorials
14:32:13 <tromp__> and not even the best way to define factorials!
14:32:30 <monochrom> > let {f 0 = 0; f 1 = 1; f (x+2) = f (x+1) + f x} in f 10
14:32:31 <lambdabot>   55
14:32:46 <monochrom> Don't they look nice? :)
14:32:56 <bodq> monochrom: do you need f 1 ?
14:33:06 <monochrom> > let {f 0 = 0; f (x+2) = f (x+1) + f x} in f 10
14:33:08 <lambdabot>   * Exception: /tmp/3857427103417491511:71:61-92: Non-exhaustive patterns in ...
14:33:21 <bodq> > let {f 0 = 0; f (x+200) = f (x+199) + f (x+198)} in f 10
14:33:23 <lambdabot>   * Exception: /tmp/3951468091198836173:71:89-130: Non-exhaustive patterns in...
14:33:30 <monochrom> Have fun!
14:33:43 <bodq> oh right that's fibonaccy
14:33:45 <bodq> *i
14:34:03 <bodq> misread, sorry
14:34:35 <bodq> > let {f 0 = 1; f (n+100) = 1 + f (n+99)} in f 10
14:34:37 <lambdabot>   * Exception: /tmp/4311410397386495272:71:77-109: Non-exhaustive patterns in...
14:35:16 <bodq> this doesn't look intuitive
14:35:30 <vixey> > let {f 0 = 1; f (n+100) = 1 + f (n+99)} in f 100
14:35:32 <lambdabot>   * Exception: /tmp/4166297971677459222:71:81-113: Non-exhaustive patterns in...
14:35:34 <tromp__> @let f a b = a:f b (a+b)
14:35:34 <lambdabot>  <local>:32:10:
14:35:35 <lambdabot>      Ambiguous occurrence `f'
14:35:35 <lambdabot>      It could refer to either `...
14:35:35 <vixey> > let {f 0 = 1; f (n+100) = 1 + f (n+99)} in f 101
14:35:37 <lambdabot>   * Exception: /tmp/2135148175959199132:71:81-113: Non-exhaustive patterns in...
14:35:42 <bodq> why is 0 special?
14:35:45 <vixey> > let {f _ = 1; f (n+100) = 1 + f (n+99)} in f 101
14:35:47 <lambdabot>   mueval: Prelude.read: no parse
14:35:47 <lambdabot>  mueval: UnknownError "GHC reported errors a...
14:35:56 <vixey> > let f _ = 1; f (n+100) = 1 + f (n+99) in f 101
14:35:57 <lambdabot>   mueval: Prelude.read: no parse
14:35:57 <lambdabot>  mueval: UnknownError "GHC reported errors a...
14:36:03 <tromp__> @let fib a b = a:fib b (a+b)
14:36:05 <monochrom> 0 is not special. You could very well use (-2046) there.
14:36:06 <lambdabot>  Defined.
14:36:22 <bodq> > let {f -1 = 1 ; f 0 = 1; f (n+2) = 1 + f (n+1)} in f 10
14:36:24 <lambdabot>   * Exception: /tmp/3243029367547805302:71:73-80: Non-exhaustive patterns in ...
14:36:28 <bodq> let {f 1 = 1 ; f 0 = 1; f (n+2) = 1 + f (n+1)} in f 10
14:36:36 <bodq> > let {f 1 = 1 ; f 0 = 1; f (n+2) = 1 + f (n+1)} in f 10
14:36:37 <lambdabot>   10
14:36:43 <bodq> isn't 0 special?
14:36:53 <lazynick> > let f n+1 = 5 in f (-3)
14:36:55 <lambdabot>   <no location info>: Parse error in pattern
14:36:58 <bodq> ah -1 is not -1
14:37:01 <lazynick> > let f (n+1) = 5 in f (-3)
14:37:02 <monochrom> > let { f (-2046) = 0; f (x+1) = f x } in f 10
14:37:04 <lambdabot>   * Exception: /tmp/4276645631146459836:71:48-58: Non-exhaustive patterns in ...
14:37:04 <lambdabot>   * Exception: /tmp/7896819152671671429:71:70-97: Non-exhaustive patterns in ...
14:37:04 <bodq> > let {f (-1) = 1 ; f 0 = 1; f (n+2) = 1 + f (n+1)} in f 10
14:37:06 <lambdabot>   * Exception: /tmp/7582241189348119728:71:73-115: Non-exhaustive patterns in...
14:37:14 <monochrom> Ha interesting!
14:37:16 <lazynick> n+k only matches if n > 0
14:37:38 <tromp__> or n==0
14:37:39 <bodq> lazynick: well that's /ugly/
14:37:48 <lazynick> indeed
14:38:03 <augustss> bodq: that's what we're saying.  it's all an ugly hack
14:38:05 <lazynick> hack for naturals-like matching
14:38:05 <monochrom> That is why people hate n+k patterns. It's too specialized for no good reason.
14:38:16 <bodq> augustss: well you were just saying and not explaining it :)
14:38:31 <tromp__> > let f(n+1) = 1 in f 1
14:38:33 <lambdabot>   1
14:38:47 <monochrom> augustss is taking the Buddhist approach of letting you experience it first-hand first.
14:38:56 <augustss> bodq: it doesn't need explanation, because it's evident.  :)
14:39:30 <bodq> monochrom: wouldn't the Buddhist approach be /part ?
14:39:54 <ddarius> There are also cases where n+k patterns lead to extremely difficult to parse patterns (albeit that presumably wouldn't come up in practice)
14:40:00 <monochrom> No.
14:40:12 <repnop> depends on the type of Buddhism ;p
14:42:29 <evident> hello everybody:
14:42:33 <monochrom> /part is more like a genie disappearing in Arabian tales.
14:42:39 <evident> is there a shorter way to write this:
14:42:40 <evident> isSorted :: (Ord a) => [a] -> Bool
14:42:40 <evident> isSorted [x] = True
14:42:40 <evident> isSorted (x:xs) = ( x <= head xs) && isSorted xs
14:42:41 <evident> ?
14:42:59 <mauke> s/shorter/correcter/
14:43:01 <tromp__> sure
14:43:01 <evident> just to check whether a list is sorted in ascending order
14:43:17 <mauke> because that doesn't even work
14:43:20 <virkony> evident: you mean with zip ?
14:43:27 <vixey> evident, call it  sorted  not  isSorted
14:43:43 <evident> it's a task from our professor
14:43:44 <lazynick> and (zipWith (<=) xs (tail xs))
14:43:57 <tromp__> :t and
14:43:59 <lambdabot> [Bool] -> Bool
14:44:00 <evident> write a function that checks whether a list is sorted
14:44:01 <augustss> that doesn't worj
14:44:05 <sbahra> @fact symbols
14:44:05 <lambdabot> I know nothing about symbols
14:44:05 <augustss> work
14:44:10 <sbahra> @fact symbol
14:44:11 <lambdabot> I know nothing about symbol
14:44:13 <sbahra> :(
14:44:15 <sbahra> wth
14:44:15 <mauke> s/tail/drop 1/
14:44:30 <sbahra> mauke, I was wondering, what terminal do you use and what font?
14:44:54 <virkony> lazynick: does (and) will give True for null list?
14:44:55 <mauke> sbahra: urxvt, DejaVu Sans Mono
14:45:01 <lazynick> > and []
14:45:03 <lambdabot>   True
14:45:06 <mauke> sbahra: + basically every font I could find
14:45:07 <idnar> > drop 1 []
14:45:08 <lambdabot>   []
14:45:13 <idnar> ooh
14:45:17 <evident> thanks lazynick
14:45:17 <idnar> hmm
14:45:23 <evident> that makes sense
14:45:23 <evident> :D
14:45:25 <idnar> is there a function like
14:45:26 <augustss> virkony: yes
14:45:47 <sbahra> mauke, is that a TTF?
14:45:47 <idnar> safeTail [] = Nothing; safeTail (_:xs) = Just xs
14:45:47 <virkony> http://hpaste.org - doesn't work?...
14:46:00 <mauke> @hoogle [a] -> Maybe a
14:46:00 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:46:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:46:00 <lambdabot> Prelude head :: [a] -> a
14:46:06 <porges> @where hpaste2
14:46:06 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
14:46:07 <mauke> sbahra: I don't know
14:46:28 <rntz> @hoogle [a] -> Maybe [a]
14:46:28 <lambdabot> Prelude cycle :: [a] -> [a]
14:46:28 <lambdabot> Prelude init :: [a] -> [a]
14:46:28 <lambdabot> Prelude reverse :: [a] -> [a]
14:46:42 <virkony> porges: thanks
14:46:53 <olsner> > ap (==) sort [1,2,3]
14:46:54 <lambdabot>   True
14:47:25 <evident> lazynick: and is the zipWith function faster than the recursive one I posted? which one is easier to calculate by the computer?
14:47:45 <sbahra> mauke, yes
14:47:46 <augustss> evident: probably not
14:47:53 <lazynick> @src zipWith
14:47:54 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:47:54 <lambdabot> zipWith _ _      _      = []
14:48:08 <pumpkin> aaacchk must stop writing tests
14:48:42 <augustss> evident: it's difficult to say, since it depends on how well the compiler optimizes
14:49:00 <evident> so the zipWith version goes through the list once... always... the one i wrote stops on the first conflict, doesn't it?
14:49:07 <augustss> pumpkin: aren't tests good?
14:49:14 <pumpkin> augustss: yes, but I'm addicted
14:49:16 <porges> evident: no, the list is calculated lazily
14:49:24 <porges> evident: so 'and' stops on first False
14:49:28 <augustss> evident: so does zipWith
14:49:29 <evident> ahh ok
14:49:29 <evident> :D
14:49:48 <porges> @src and
14:49:48 <lambdabot> and   =  foldr (&&) True
14:49:50 <porges> @src (&&)
14:49:51 <lambdabot> True  && x = x
14:49:51 <lambdabot> False && _ = False
14:50:00 <evident> so the work is the same for both versions, isnt it?
14:50:15 * ksf just darcs reverted non-messed up things because he thought he messed them up
14:50:17 <augustss> evident: very similar
14:50:26 <evident> :D ok
14:50:28 <evident> thx
14:50:29 <bodq> in C++ you can do calculation with templates at compile time. is there something similar in haskell?
14:50:48 <bodq> hopefully less horrible
14:50:50 <ksf> you can't do calculation with templates at run-time in c++
14:50:51 <lazynick> the recursion has already been written for you.  Use the libs.
14:50:54 <mauke> Template Haskell :-)
14:51:04 <Peaker> bodq: Templates are turing-complete, Haskell type-level programming is decidable
14:51:15 <ddarius> Peaker: Not with -fundecidable-instances
14:51:24 <Peaker> ddarius: yep
14:51:28 <bodq> Peaker: I didn't mean it has to be type-level programming :)
14:51:35 <mauke> bodq: what are you trying to do?
14:51:44 <bodq> mauke: entertain myself mostly
14:51:52 <ksf> well, template metaprogramming is nescessarily type-level programming.
14:52:08 <ksf> then TH is what you're looking for.
14:52:11 <mauke> bodq: you can run arbitrary code at compile time with Template Haskell
14:52:24 <bodq> mauke, ksk, of so that wasn't a joke :)
14:53:45 <ksf> bodq, why did i read your compile time as run time?
14:54:02 <ksf> possibly coffeine withdrawal.
14:54:02 <vixey> bodq, I think typeclass dispatch can usually be completed before runtime
14:54:11 <bodq> ksf: I don't know? You hate C++ and got temporary rage blackout? :)
14:54:37 * bodq gets that sometimes... virtual destructors.....
14:54:37 <vixey> (not exactly sure why this isn't a hard/fast rule that it's always completed at compile time though)
14:55:02 <ksf> possibly. I tried to learn to love templates but constantly hit the wall of missing type-inference and general borkedness.
14:55:09 <aresnick> Hi!  I'm trying to install cabal-install for all users, and I'm not sure how to using runhaskell.  When I try to run sudo runhaskell Setup configure, it claims that Cabal > 1.6 is missing, although I just set up 1.7 successfully.  Are system-wide installations just not recommended?  I've gotten to work flawlessly for a single user. . .
14:55:55 <mauke> > let lol :: (Show a) => Int -> a -> String; lol 0 a = show a; lol n a = lol (n-1) [a] in lol 3 ()
14:55:56 <lambdabot>   "[[[()]]]"
14:56:00 <mauke> vixey: ^
14:56:11 <pejo> vixey, polymorphic recursion
14:56:33 <bodq> omg :)
14:56:38 <ksf> in the end, good, plain old C is still the best thing for your low-level stuff.
14:57:03 <bodq> ksf, I smell Linux Torvalds :)
14:57:11 <augustss> ksf: I agree
14:57:22 <bodq> err that sounded strange
14:57:34 <Badger> torvalds-sniffer!
14:57:38 <bodq> very strange :)
14:57:44 <vixey> mauke, I don't know why that requires runtime dispatch
14:58:06 <vixey> it's probably impossible to rule out all cases which require runtime dispatch isn't it?
14:58:29 <ksf> in particular, c++ is a bugger to interface to, which makes writing truly high-level code nearly impossible.
14:58:32 <mauke> > let lol :: (Show a) => Int -> a -> String; lol 0 a = show a; lol n a = lol (n-1) (a,a) in lol 3 'x'
14:58:34 <lambdabot>   "((('x','x'),('x','x')),(('x','x'),('x','x')))"
14:58:54 <vixey> mauke, but in this case here: lol n a = lol (n-1) (a,a)
14:59:06 <augustss> vixey: I sure don't know how to get rid of all runtime dispatch in Haskell.  99.9% yes, but not all.
14:59:20 <bodq> ksf: some things you can't interface to, e.g. templates
14:59:41 <vixey> imagine you started with a show instance for 'a', to call 'lol' with (a,a) you must provide a show instance for '(a,a)', surely there is only one function: Show a => Show (a,a)
15:00:08 <ksf> even plain things like static functions can be a pain, due to name mangling.
15:00:19 <ksf> ...and no true standard whatsoever.
15:00:35 <bodq> ksf: swig handles name mangling fine
15:00:46 <bodq> ksf: not that it doesn't have its problems
15:01:15 <ksf> in c, the worst that can happen is varargs.
15:01:52 <bodq> luckily they are only used for printf and various logging libraries :)
15:02:10 <vixey> I wonder if there is a simpler more expressive system for typeclass dispatch which can be completed at compile time ..
15:03:26 <ksf> ...which means that you can just call something like put_log(char *fmt, ...) as putLog s == put_log "%s" s.
15:03:54 <pejo> vixey, http://www.springerlink.com/index/U0W1121626576367.pdf
15:05:00 <ddarius> vixey: Existential types also lead to run-time dispatch (but that's almost like asking for it explicitly)
15:05:01 <BMeph> aresnick: When you "set up 1.7", did you do it --global? :)
15:05:03 <augustss> pejo: but that only works for the 99.9%
15:05:22 <pejo> augustss, true
15:05:23 <vixey> ddarius, what! Can you show me how?
15:05:39 <vixey> wait is that Existential types + typeclasses?
15:06:08 <puusorsa> what's the inverse of map?
15:06:20 <pumpkin> puusorsa: map of the inverse?
15:06:22 <puusorsa> as in apply list of functios to a single value?
15:06:28 <pumpkin> oh
15:06:35 <ksf> class Exists a => a
15:06:35 <vixey> puursorsa, sequence in the (e ->) monad
15:06:45 <pumpkin> map ($ value) [function1, function2..]
15:06:45 <augustss> puusorsa: map ($x) [f1, f2, ...]
15:06:49 <vixey> > sequence [(+1), (*2)] 3
15:06:51 <lambdabot>   [4,6]
15:06:58 <vixey> > map ($3) [(+1), (*2)]
15:06:58 <ddarius> data Box = forall a. Show a => Box a; instance Show Box where show (Box a) = show a; main = print [Box True, Box 'a', Box "foo"]
15:07:00 <lambdabot>   [4,6]
15:07:03 <puusorsa> pumpkin, thanks
15:07:10 <vixey> augustss way is shorter..
15:07:17 <augustss> lol
15:08:08 <vixey> Chameleon (the language) is a Haskell style language to experiment with advanced type extensions such as type classes and generalized algebraic data types. The user can program her own type extensions via Constraint Handling Rules (CHRs).
15:08:30 <vixey> I like this
15:08:41 <vixey> I don't know if they resolve everything before runtime though
15:08:42 <ddarius> Chameleon is pretty cool
15:10:05 * vixey has found something new to dissect ... :)
15:10:09 <puusorsa> that should be in every newbie tutorial, as it's useful and imho a good example of what $ does other than 'often let's you not use parentheses but sometimes does really weird things'
15:10:28 <ddarius> ($) is id, it never does anything weird
15:10:39 <mauke> > map (flip id x) [f, g, h] :: [Expr]
15:10:40 <lambdabot>   [f x,g x,h x]
15:11:00 <ddarius> > map (`id` x) [f, g, h] :: [Expr]
15:11:02 <lambdabot>   [f x,g x,h x]
15:11:13 <puusorsa> when you think of it as jsut a way to get rid of ()'s without knowing when it can be used, it does
15:11:19 <vixey> <command line>: unknown package: text
15:11:21 <sbahra> puusorsa, what do you mean it does really weird things?
15:11:21 <vixey> :(((((
15:11:24 <vixey> I forgot I was using GHC
15:11:28 <pumpkin> aw
15:11:54 <puusorsa> well it works like it should, not like how i would've it do
15:11:56 <ddarius> puusorsa: I don't care for people who describe it solely as "a way to get rid of parentheses."  Say what it is and then say what it is often used for.
15:12:08 <BMeph> :t map id
15:12:10 <lambdabot> forall a. [a] -> [a]
15:12:18 <mauke> map id == id
15:12:18 <BMeph> :t map (flip id)
15:12:20 <lambdabot> forall a c. [a] -> [(a -> c) -> c]
15:12:39 <ddarius> :t map (runCont . return)
15:12:41 <lambdabot> forall r a. [a] -> [(a -> r) -> r]
15:12:45 <mauke> :t map . flip id
15:12:46 <lambdabot> forall a c. a -> [a -> c] -> [c]
15:12:50 <tjb> I am having problems with my fmap call and Maybe list -- anyone mind taking a quick look?
15:12:51 <tjb> http://haskell.pastebin.com/d7fedd994
15:12:53 <BMeph> mauke++
15:13:06 <Olathe> :t map (flip map)
15:13:08 <lambdabot> forall a b. [[a]] -> [(a -> b) -> [b]]
15:13:15 <vixey> this pastebin.com is the worst pastebin ever
15:13:30 <monochrom> Any device for saving parentheses must do weird things. Proof: with fewer parentheses, you make mistake in parsing, your parse is different from computer's parse, therefore you feel weird.
15:13:30 <tjb> vixey: other suggestions?
15:13:35 <mauke> tjb: oh, you need parentheses around the hdlc_asdjfkasjdf call
15:13:37 <vixey> tjb, write:  (dlc_byte_destuff xs)
15:13:42 <augustss> tjb: stick a $ before the recirsive calls
15:13:49 <vixey> tjb,Actually... write:  (dlcByteDestuff xs)
15:14:09 <tjb> wow, thanks for the quick suggestions all -- let me give it a shot
15:14:19 <vixey> tjb, thing is you are just one person -- lots are using this horrible paste bin
15:14:24 <puusorsa> i faintly recall some tutorials introducing it as id and then showing how to get rid of parents thesis
15:14:50 <tjb> vixey: when I typed "irc pastebin" into google, that is what I got :)
15:15:06 <tjb> vixey: used to use hpaste, but that has been down for awhile
15:15:14 <vixey> tjb, I can't understand who makes this website.. do they find it readable?
15:15:21 <ksf> @where hpast2
15:15:22 <lambdabot> I know nothing about hpast2.
15:15:27 <blackdog> vixey: think it's just selling ads...
15:15:27 <ksf> #@where hpaste2
15:15:35 <ksf> @where hpaste2
15:15:35 <vixey> blackdog, oh yeah, of course
15:15:36 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:15:37 <ksf> !!!
15:15:46 <pumpkin> didn't shapr say he was going to fix hpaste?
15:15:49 <Peaker> vixey: I tend to look at the textbox below
15:16:14 <tjb> parenthesis around the recursive call fixed my problem -- thanks all
15:16:21 <puusorsa> and now that i started complaining, many haskell librarie's docs would benefit from a section like usage / examples
15:16:39 <ksf> they would, yes.
15:16:42 <augustss> puusorsa: very true!
15:16:46 <puusorsa> before you say it, no, you don't want me to write them
15:16:59 <mauke> WELL VOLUNTEERED
15:17:01 <BMeph> puusorsa: Yes, I do. ;)
15:17:11 <puusorsa> sorry, if i understood what they did i wouldn't need the examples :)
15:17:15 * tjb is continually surprised at how helpful the haskell IRC room is
15:17:33 <mauke> it's a channel, not a room!
15:17:43 <ksf> puusorsa, just write random stuff, it's bound to be corrected. if you don't write anything, everyone will assume everything's obvious.
15:17:46 <pumpkin> it's all about the metaphor
15:17:47 <augustss> @slap mauke
15:17:48 * lambdabot karate-chops mauke into two equally sized halves
15:17:49 <puusorsa> where are the sherrifs in this rom??
15:17:53 <tjb> mauke: ok ok -- "room" :)
15:18:02 <mauke> tjb: CHANNEL
15:18:16 <pumpkin> COCO CHANEL
15:18:21 * mauke splits into more parts, then reassembles himself into two identical copies of himself
15:18:36 <lazynick> MY OWN CLONE
15:18:38 <dcoutts> aresnick: did you get an answer to your question?
15:18:49 <blackdog> mauke: but you're just pointers to the same underlying storage, right?
15:18:55 <augustss> mauke, you must have applied a non-constructive theorem there
15:19:05 <rwanderley> hi, anybody here using the Yi editor?  I installed it here using Cabal but can't find the Meta key, tried ESC and Alt but nothing...
15:19:08 <puusorsa> ksf i'm thinking of doing a markov chain chatbot
15:19:14 <BMeph> mauke: Banach-Tarski FTW? ;p
15:19:14 <sbahra> rwanderley, "Windows key"?
15:19:20 <tjb> mauke: that is funny, I actually meant to type "channel" -- some type of unconscious slip :)
15:19:23 <mauke> BMeph: :-)
15:19:26 <rwanderley> sbahra: that too.
15:19:50 <monochrom> This is my bedroom. What are you doing here?
15:19:54 <mauke> puusorsa: /join #GumbyBRAIN
15:19:57 <puusorsa> i'll let it write the docs after feeding it some quality literature and really low quality irc channels
15:20:28 <hackage> Uploaded to hackage: llvm 0.6.0.3
15:21:48 <vixey> how does banach tarski work?
15:21:56 * ksf just realised how to convert all agar vararg stuff into haskell, including pure haskell callbacks
15:22:05 <augustss> I need to make some more flawed llvm benchmarks.  I've not had so much fun on reddit in quite a while as the last benchmark I posted.
15:22:11 <lazynick> ZOMG!! The arguments to this function ROLFCOPTER monadic squence LOLZ
15:22:19 <sbahra> augustss, which benchmark?
15:22:30 <augustss> vixey: it's non-constructive, so nobody knows.
15:22:50 <ksf> ...including runtime type safety up to the type gralularity provided by agar.
15:23:03 <augustss> sbahra: http://augustss.blogspot.com/2009/01/performance-update-ive-continued.html
15:23:25 <sbahra> Ah, yes.
15:23:29 <sbahra> augustss, I read that. Great stuff :)
15:23:36 * Trafalgard mutters about VirtualBox interrupting IRC connections (and all other active internet connections) multiple times when installed/updated...
15:24:08 <Gracenotes> eek. Slashdot logo: backwards lambda. Coincidence? I don't think so!
15:25:35 <pumpkin> omg massive functional coverup
15:26:04 <JohnyBoy> hi
15:26:22 <ksf> I can even stop a user upcasting an AG_Object into eg. an AG_Window if it's actually an AG_Button.
15:26:42 <Peaker> "upcasting" is silly.. its just getting some field
15:26:43 <ksf> behold the power of c!
15:26:58 <Tobsan> Zee!
15:27:05 <ksf> ...actually, I can upcast automagically. that's even better.
15:27:30 <Peaker> ksf: I am not sure what the benefit of that is (And I know quite a few problems with it..)
15:27:42 <JohnyBoy> from which country are you gays?
15:27:42 <ksf> It's a good idea to avoid exporting that beast called EvilVoidClass
15:27:55 <lazynick> all of them.
15:28:56 <ksf> peaker, it's not getting a field, it's casting. Precisely, an AG_Object that gets passed to an event handler to its least general type.
15:28:56 <pumpkin> JohnyBoy: do you have a haskell question?
15:29:14 <JohnyBoy> I DONT KNOW WHAT IT IS...
15:29:19 <JohnyBoy> sorry
15:29:20 <pumpkin> then why are you here?
15:29:30 <Peaker> ksf: well, getting the field that happens to be at offset 0 is the same as casting, in C semantics, but why unsafely cast if you can safely get the member?
15:29:32 <somnolence> to troll.
15:29:36 <JohnyBoy> i have  a chat room
15:29:40 <dcoutts> augustss: have you reported the bug about alloca etc not respecting Storable alignment?
15:29:41 <JohnyBoy> see*
15:29:46 <JohnyBoy> so i get in
15:29:50 <pumpkin> JohnyBoy: try a different one
15:29:51 <monochrom> I have a bedroom.
15:30:04 * Badger uses monochrom's bedroom.
15:30:04 <JohnyBoy> what is haskell anyway
15:30:10 <pumpkin> JohnyBoy: a programming language
15:30:11 <lazynick> programming language
15:30:32 <JohnyBoy> like visual basic?
15:30:37 <mauke> yes
15:30:43 <blackdog> Not as good, though.
15:30:50 <somnolence> vb > anything
15:30:51 <lazynick> heh
15:30:54 <BMeph> JohnyBoy: Yes, exactly like Visual Basic. :)
15:31:14 <augustss> dcoutts: yes.  no response
15:31:25 * lazynick goes to write a GUI in VB to help catch the criminal.
15:31:29 <dcoutts> augustss: a ghc ticket?
15:31:31 <JohnyBoy> i know visual basic, fortran, cubloc basic for auto machines
15:31:32 <augustss> dcoutts: i've even provided a patch
15:31:41 <augustss> dcoutts: ghc ticket
15:32:17 <JohnyBoy> so i have a question
15:32:23 <pumpkin> JohnyBoy: it's very different from those, but yes, they all have "programming language" in common
15:32:36 <augustss> dcoutts: I'm not sure I've patched all places.  it's broken in several places
15:32:46 <JohnyBoy> ok i understant
15:32:53 <ksf> because I can't safely get members before I casted the thing?
15:33:09 <JohnyBoy> so have a nice goodspeed...
15:33:14 <somnolence> lol
15:33:17 <augustss> dcoutts: ticket 2917
15:33:18 <lazynick> wat
15:33:21 <dcoutts> augustss: in the ticket simon is asking for a version that does not waste memory for every allocation when the required alignment is less than 8
15:33:34 <pumpkin> goodspeed to you too!
15:33:38 <augustss> dcoutts: Oh, I've missed that
15:33:48 <dcoutts> augustss: get on the cc list :-)
15:33:49 <pumpkin> @remember JohnyBoy so have a nice goodspeed
15:33:49 * lazynick vows to make use of "have a nice goodspeed" at some point in his life
15:33:49 <lambdabot> Done.
15:34:03 <dcoutts> augustss: oh, you are :-)
15:34:22 <augustss> dcoutts: yes.  I must have missed it anyway
15:34:23 <dcoutts> augustss: I'm sure with a suitable patch it can make it in for 6.10.2
15:35:00 <augustss> dcoutts: I'll modify my patch, and make sure it also works for StorableArray
15:35:05 * Peaker eagerly awaits 6.10.2
15:35:07 <mathijs> Has anyone got the chapter5 and 6 code from RWH working (the json stuff)? I checked everything thoroughly but I keep on getting errors.
15:35:15 <dcoutts> augustss: great
15:35:24 <mauke> mathijs: what's the first error?
15:36:54 <mathijs> mauke: in chapter 6 (the typeclass example), the code compiles/loads fine but I keep on getting this error when I try 'fromJValue' on any JValue:
15:37:00 <mathijs> <interactive>:1:0:
15:37:01 <mathijs>     Ambiguous type variable `a' in the constraint:
15:37:01 <mathijs>       `JSON a' arising from a use of `fromJValue' at <interactive>:1:0-11
15:37:01 <mathijs>     Probable fix: add a type signature that fixes these type variable(s)
15:37:12 * ksf is glad that haskell doesn't come with objects so nothing is forcing him to represent them in a specific way.
15:37:15 <mauke> what's the type of fromJValue?
15:37:40 <augustss> mathijs: sounds like you're not using fromJValue so that the compiler know what type you want
15:37:45 <mathijs> class JSON a where toJValue :: a -> JValue fromJValue :: JValue -> Either JSONError a
15:37:55 <mauke> ah
15:38:34 <bodq> ksf, elaborate?
15:38:52 <lazynick> which types are in JSON?
15:39:20 <mathijs> data JValue = JString String
15:39:21 <mathijs>             | JNumber Double
15:39:21 <mathijs>             | JBool Bool
15:39:21 <mathijs>             | JNull
15:39:21 <mathijs>             | JObject (JObj JValue)
15:39:23 <mathijs>             | JArray (JAry JValue)
15:39:25 <mathijs>               deriving (Eq, Ord, Show)
15:39:28 <mathijs> sorry for pasting, but hpaste is down
15:39:41 <Cale> mathijs: That's not a list of instances of the JSON class
15:39:47 <bodq> @where hpaste2
15:39:48 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:40:04 <augustss> mathijs: try e.g. 'fromJValue blah :: Either JSONError Int'
15:40:05 <bodq> mathijs: or just post the link to the book
15:40:15 <Cale> But regardless, you'll need to add either an appropriate type signature or something which uses the value obtained in order that it knows which instance of JSON to use
15:40:30 <mathijs> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=951#a951
15:40:41 <Peaker> Is the JSON type-class a serialization/deserialization class?
15:40:46 <Cale> I think there may be differences between the book's version of the JSON library and the one on Hackage.
15:40:54 <Cale> Peaker: roughly, yes
15:41:16 <int80_h> I'm trying to compile code from ch05 RWH
15:41:19 <Peaker> Cale: but what JSON can serialize is pretty hard-coded to strings, dicts, numbers, etc?
15:41:30 <mathijs> augustss: ah ok that works :)
15:41:32 <int80_h> i think it's broken, anyone care to help me fix it so it's sompiling?
15:41:35 <augustss> Peaker: not any more
15:41:38 <Cale> Peaker: But if you have a Haskell datatype, you write an instance of JSON for it
15:41:54 <augustss> Peaker: you just need to derive Data
15:41:54 <Cale> Peaker: and then you don't have to worry about that. :)
15:42:24 <int80_h> anyone at all?
15:42:27 <Peaker> but how do you "Tag" the type?
15:42:35 <Peaker> In the JSON?
15:42:38 <Cale> mathijs: ah, so you have the library written out by hand :)
15:42:50 <Cale> mathijs: Where does the error occur?
15:42:52 <augustss> Peaker: they are tagged in a sensible way
15:43:03 <idnar> Peaker: "tag"?
15:43:14 <Cale> int80_h: That may be what mathijs is already talking about?
15:43:17 <augustss> whatever "tag" means
15:43:38 <int80_h> Cale: ah I was vaguely paying attention.
15:44:05 <augustss> Peaker: Anything in the Data class gets encoded in a pretty intuitive way
15:44:06 <Cale> Peaker: You don't actually need to encode type information -- that's static. You just need to encode which constructor, and what its parameters were.
15:44:10 <mathijs> Cale: yes I'm trying to practice, but it's a bit hard, since the code is not available online and the book is kind of hard to read (lots of distractions), I keep on running into situations that I'm not sure if it's my own fault...
15:44:13 <int80_h> Cale: no I think his problem is different from mine
15:44:18 <Peaker> Cale: oh, right :)
15:44:38 <idnar> oh
15:44:49 <mathijs> Cale: no error anymore, it was indeed that I needed to tell ghci what type I wanted ( fromJValue x :: Either JSONError Bool)
15:44:58 <int80_h> My code goes in PrettyJSON.hs, his is in another file. Unless that is all wrong too.
15:44:59 <Cale> ah, from ghci, yes
15:45:26 <Cale> mathijs: In an actual program when you call fromJValue, you likely won't need the explicit signature, since what you do with the value will usually pin down the type
15:45:45 <augustss> mathijs: under normal circumstances the context will determine which type you want, and there is no need for a type signature
15:46:05 <Cale> int80_h: What is your problem?
15:46:22 <Cale> int80_h: What error(s) are you getting?
15:46:32 <mathijs> int80_h: yeah that part is very hard to read, I finally cracked it by just putting everything in one file. It's very hard to follow and there are some errors I think. I wouldn't distract into stubbing (but not explaining how to use the stub) and into pretty printing before completing the json lib itself.
15:46:36 <int80_h> PrettyJson.hs won't compile in ghci. I can post what I have, I'm sure I'm just missing one line at the top
15:46:49 <lazynick> not many popular languages do polymorphism on return value :)
15:47:08 <int80_h> @where paste
15:47:09 <lambdabot> http://hpaste.org/new
15:47:12 <mathijs> Cale: I figured that. ghci is sometimes a bit weird, coming from ruby/python interpreters.
15:47:17 <int80_h> @where paste2
15:47:18 <lambdabot> I know nothing about paste2.
15:47:27 <int80_h> bah, where's the other paste site?
15:47:40 <lazynick> @where hpaste2
15:47:41 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
15:48:23 <Cale> mathijs: Well, you see the result of fromJValue is polymorphic.
15:48:40 <Cale> mathijs: and what fromJValue does depends on the type of its result.
15:48:49 <Cale> (that's what typeclasses are all about)
15:49:22 <Cale> But in ghci, your expression all alone like that, it's impossible for it to know which type you wanted.
15:49:56 <mathijs> Cale: I get that. It's just some getting used to I guess :)
15:51:38 <augustss> mathijs: now you know what the error message means :)
15:52:24 <roconnor> @instances Enum
15:52:25 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
15:52:48 <idnar> "return type" polymorphism can be rather confusing at first
15:53:26 <mauke> (especially in C++, huhu)
15:53:31 <idnar> haha
15:53:51 <mathijs> ok, and in case I want the 'fromJValue' for instance JArray (JAry JValue) ? I still get an error then...
15:54:10 <mathijs> let f = JArray ( JAry [ JNumber 1, JBool True] )
15:54:21 <mathijs> fromJValue f :: Either JSONError JAry JValue
15:54:39 <mauke> that looks like a kind error
15:54:43 <lazynick> (JAry JValue)
15:54:53 <lazynick> Either takes 2 types.
15:55:00 <pumpkin> can I ask quickcheck to make sure an exception is thrown?
15:55:04 <lazynick> you've mistakenly passed it 3.
15:55:05 <mathijs> lazynick: fromJValue f :: Either JSONError (JAry JValue)
15:55:14 <mathijs> <interactive>:1:0:
15:55:14 <mathijs>     No instance for (JSON (JAry JValue))
15:55:14 <mathijs>       arising from a use of `fromJValue' at <interactive>:1:0-11
15:55:14 <mathijs>     Possible fix: add an instance declaration for (JSON (JAry JValue))
15:55:14 <mathijs>     In the expression: fromJValue f :: Either JSONError (JAry JValue)
15:55:16 <mathijs>     In the definition of `it':
15:55:19 <mathijs>         it = fromJValue f :: Either JSONError (JAry JValue)
15:55:37 <mauke> No instance for (JSON (JAry JValue))
15:55:39 <mathijs> lazynick: no, I forgot to type the braces here :)
15:55:39 <mauke> there you go
15:55:58 <mathijs> instance (JSON a) => JSON (JAry a) where
15:56:23 <idnar> is there an instance JSON JValue?
15:56:32 <mathijs> yes
15:56:32 <lazynick> yep
15:56:39 <mathijs> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=951#a951
15:56:42 <idnar> hmm
15:56:50 * idnar goes back to being confused :P
15:56:55 <Gracenotes> how could I best represent an inconsistently nested list? something like, JaggedItem a = Item a | List [a]?
15:57:14 <lazynick> A tree?
15:57:21 <Gracenotes> er, that would be List [JaggedItem a], actually
15:57:39 <vixey> data List a = Nil | Cons a (List a)
15:58:03 <vixey> data Those a = End | The a | Seq (Those a) (Those a)
15:58:04 <Gracenotes> lazynick: ...hm, good point. What I posted was basically equivalent to an n-ary tree
15:58:42 <lazynick> actually, what you posted was Either a [a]  :P
15:59:03 <int80_h> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=952#a952
15:59:17 <Gracenotes> lazynick: s/[a]/[JaggedItem a]
15:59:30 <int80_h> @when Cale
15:59:31 <lambdabot> Maybe you meant: seen what where wn
15:59:33 <Gracenotes> /
15:59:36 <int80_h> @seen Cale
15:59:36 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 10m 14s ago.
15:59:54 <Cale> hi
15:59:58 <lazynick> @src Tree
15:59:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:00:06 <Cale> int80_h: I'll have a look
16:00:27 <int80_h> Cale: thanks. I thought a simple import would fix the problem, so I tried it. Nope.
16:00:34 <Gracenotes> lazynick: although, isn't any ADT with two constructors with * -> * an Either? :)
16:00:45 <mathijs> int80_h: you need to import the Prettify.hs stub
16:00:45 <int80_h> the same problem happens whether or not I import simpleJSON
16:01:11 <lazynick> Either is the basic sum type, yes.
16:01:22 <int80_h> I don't have Prettify yet
16:01:28 <int80_h> I have PrettyStub.hs
16:01:38 <int80_h> PrettyJSON.hs
16:01:39 <mathijs> yeah that's an error... rename it and import it
16:01:42 <Gracenotes> okay... so I'll make an n-ary tree, call it a list
16:01:50 <lazynick> look at Date.Tree
16:01:53 <int80_h> rename PrettyStub?
16:01:54 <lazynick> Data*
16:01:58 <ddarius> Gracenotes: Why don't you call it a tree?
16:02:09 <ddarius> Gracenotes: Are you one of those lisp programmers?
16:02:21 <mathijs> the file you posted is PrettyJSON.hs, it imports SimpleJSON and Prettify. Prettify is just stubbed at the moment
16:02:30 <int80_h> mathijs : rename PrettyStub?
16:02:35 <mathijs> int80_h: yes
16:02:38 <Gracenotes> because it's isomorphic to a tree, but I don't want to think of it as a tree :/
16:02:40 <int80_h> okay thanks :)
16:03:13 <Cale> int80_h: Oh, mathijs answered it?
16:03:16 <pumpkin> Gracenotes: why not? :o
16:03:26 <pumpkin> you could make a type synonym for it
16:03:31 <pumpkin> to make you feel better about it
16:03:52 <lazynick> @doc Data.Tree
16:03:53 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
16:03:57 <mauke> there's a joke here somewhere, about calling a rose tree a rose tree
16:04:17 <sm>  afternoon all.. I'm looking for tips/tricks for understanding/visualising/keeping straight the monads & types in unfamiliar code. Any suggestions ?
16:04:40 <mathijs> int80_h: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=953#a953
16:04:41 <pumpkin> it's not afternoon here, you insensitive clod!
16:04:50 <Gracenotes> eh. On the other hand, it probably is a tree. For fun, I'm writing a very simple parser to parse something like "(ab((c)de)fg)" into ["ab",[["c"],"de"],"fg"]
16:04:52 <sm> just a little local colour.. no offense
16:04:55 <ddarius> mauke: A rose tree by any other name would nest as deep
16:05:06 <sm> parsing code with an error transformer, as an example; or happs code
16:05:06 <pumpkin> sm: just being silly :P
16:05:06 <gwern> I've been trying to figure out, how does one 'extend' a record type? ie. 'data XInternalConfig = XConfig { keys ∷  [(Key, Action)], unbound ∷  [Key] }' where 'keys' and 'unbound' are fields additional to the original ones of XConfig
16:05:22 <mauke> ddarius++
16:05:43 <Gracenotes> the thing is that the order of the branches does matter -- and trees are somewhat more commutative, at least as I tend to deal with them
16:05:44 <puusorsa> yes. join gumbybrain and talk to the master
16:06:08 <Gracenotes> even if the actual implementation of branches in Data.Tree is a list, it seems odd to call it a tree
16:06:45 <Gracenotes> oh wait, is that true? :/ not sure if it is
16:06:50 <ddarius> data CardinalTree a = Leaf a | Branch (Set (CardinalTree a))
16:06:56 <ddarius> @src Tree
16:06:56 <lambdabot> Source not found. That's something I cannot allow to happen.
16:07:01 <ddarius> ,src ''Tree
16:07:03 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
16:07:10 <ddarius> ,src ''Forest
16:07:13 <lunabot>  type Forest a = [Tree a]
16:07:24 <ddarius> I dislike Data.Tree
16:07:31 <mae> dons: are you around? we are having an intense conversation about plugins in happs and could use your help!
16:08:01 <pumpkin> superdons to the rescue!
16:08:27 <lazynick> WHOOSH
16:08:36 <ddarius> I guess the definition of Tree makes it handy for a comonad.
16:08:47 <idnar> The superhaskeller you have dialled is not available at present; please try again later.
16:08:58 <ddarius> Indeed, it is the free comonad on []
16:09:25 <pumpkin> is there any way for quickcheck to catch an error?
16:09:28 <Gracenotes> extract does...?
16:09:35 <ddarius> extract = rootLabel
16:09:53 <Gracenotes> oh. hm, true.
16:10:59 <Gracenotes> hm.
16:13:22 <Gracenotes> tree =>> f = Tree (f (Tree rootLabel [])) []
16:13:40 <ddarius> It's easier to define duplicate
16:13:57 <Gracenotes> what is this duplicate you speak of?
16:14:05 <ddarius> The dual of join
16:14:08 <ddarius> :t join
16:14:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:14:22 <ddarius> duplicate :: Comonad w => w a -> w (w a)
16:14:44 <ddarius> duplicate t = Node t (map duplicate (subForest t))
16:15:13 <augustss> pumpkin: the new QC can handle errors
16:15:18 <skorpan> :t (=>>)
16:15:19 <pumpkin> augustss: sweet!
16:15:20 <lambdabot> Not in scope: `=>>'
16:15:37 <ksf> did anyone ever try do do a c evaluator in haskell?
16:15:59 <ksf> or a C-DSL?
16:16:00 <Gracenotes> hm, (=>>) = flip extend
16:16:24 <Gracenotes> extend f  = fmap f . duplicate ... duplicate = extend id. Interesting
16:16:26 <pumpkin> , [$ty| indexU |]
16:16:29 <lunabot>  forall a . UA a => UArr a -> Int -> a
16:16:40 <mathijs> how can I get from 'Right x' to x on ghci? (so without pattern matching)
16:17:02 <Gracenotes> mathijs: what'll you do if it's a Left?
16:17:02 <ksf> case foo of (Right x) -> x
16:17:05 <mauke> mathijs: why without pattern patching?
16:17:05 <idnar> is a comonad a functor?
16:17:27 <idnar> @type either
16:17:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:17:39 <Cale> idnar: yes
16:17:44 <ksf> there might be something like maybeRight :: Either a b -> Maybe b ;)
16:17:46 <mathijs> Gracenotes: It's not :)  I have a value in my variable 'a' which is Right "blah". How can I say 'let b = ... a' ?
16:18:01 <Gracenotes> in fact, apparently, class Functor w => Comonad w
16:18:08 <Gracenotes> the same's not true of Monad m :(
16:18:09 <mauke> mathijs: let (Right b) = a
16:18:14 <Cale> Gracenotes: it should be
16:18:16 <mathijs> mauke: ah... thanks :)
16:18:20 <Gracenotes> yeah
16:18:23 <stepcut> mathijs: let (Right b) = a ?
16:18:23 <Cale> Gracenotes: It's just that the Prelude sucks.
16:18:34 <idnar> did anyone implement a better Prelude yet?
16:18:49 <Cale> Lots of improvements have been suggested.
16:18:57 <Gracenotes> maybeRight = either (const Nothing) Just
16:19:02 <ksf> idnar, what's "better"?
16:19:31 * ksf should read more context
16:19:32 <Cale> Unless they go into the actual Prelude in the base package, there's not much point in them.
16:20:05 <blackdog> i'm probably missing something dumb, but how do I tell './Setup sdist' to include things like README, TODO files?
16:20:28 <hackage> Uploaded to hackage: porte 0.0.3
16:20:28 <hackage> Uploaded to hackage: haskore-supercollider 0.1
16:20:28 <hackage> Uploaded to hackage: haskore-realtime 0.1
16:20:28 <hackage> Uploaded to hackage: haskore 0.1
16:20:45 <Gracenotes> congrats, hackagebot
16:21:27 <somnolence> what's this: haskore-supercollider?
16:21:36 <ddarius> :t either (const Nothing) Just
16:21:37 <lambdabot> forall a a1. Either a1 a -> Maybe a
16:21:53 <mauke> blackdog: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
16:23:17 <blackdog> thanks mauku
16:23:50 <roconnor> > scanl f z [a,b,c]
16:23:52 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
16:24:25 <idnar> ksf: all the stuff everyone talks about, like Functor => Applicative => Monad
16:24:27 <lazynick> > f
16:24:29 <lambdabot>   Add a type signature
16:27:04 <idnar> > f :: Expr
16:27:05 <lambdabot>   f
16:27:26 <gnuvince_> :info Expr
16:27:41 <mauke> you can't drink worms; don't try!
16:27:54 <lazynick> sage advice
16:29:04 <mauke> http://sixsixfive.com/323.html
16:29:58 <Peaker> Hmm, given that  fmap+pure let you implement <*>  -- but fmap+<*> don't let you implement pure, we really have 3 classes then?   Functor, HasAp(adds <*>), and Applicative(adds pure)?
16:30:29 <Cale> Peaker: I would say Pointed is more relevant than HasAp
16:30:42 <idnar> Pointed has return?
16:30:42 <Cale> that is, functors with 'pure'
16:30:44 <Cale> yea
16:30:45 <idnar> ah
16:30:55 <idnar> so Functor => Pointed => Applicative
16:30:58 <Cale> yeah
16:31:35 <blackdog> just released my first package PerfectHash on hackage - if anyone's got a moment to check it out and critique it, i'd be really grateful.
16:32:14 * idnar plays with hayoo
16:32:51 <idnar> hmm, is there a monad with return = repeat?
16:33:06 <ddarius> idnar: No (or not in Haskell)
16:33:20 <Peaker> Cale: why not split it all by expressiveness?  Functor => (HasAp, Pointed) => Applicative ?
16:33:26 <blackdog> (quick precis: it's a restricted Map with only fromList and lookup - hopefully useful for big static lookups of strings, and a bit faster than bytestring-trie)
16:33:30 <ddarius> idnar: There's an applicative functor with pure = repeat
16:33:36 <djwonk> is there a good generic chat room on IRC about computer science in general?  not specific to any one language?
16:33:49 <Cale> Peaker: You could, but at some point it becomes annoying ;)
16:33:50 <idnar> ddarius: what's it do?
16:33:54 <kiris> :t compare
16:33:55 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:34:01 <ddarius> Peaker: What's an implementation of (<*>) in terms of fmap and pure?
16:34:05 <puusorsa> #coders on ircnet
16:34:10 <Peaker> ddarius: that was wrong of me :-)
16:34:11 <ddarius> idnar: See the ZipList instance of Applicative.
16:34:18 <Cale> <*> can't be implemented in terms of fmap and pure
16:34:23 <djwonk> ah, ##compsci
16:34:33 <BONUS_> however you can implement fmap with pure and <*>
16:34:42 <puusorsa> though it's not usually about computers, even less about science
16:34:47 <ddarius> :t (<*>) . pure
16:34:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> f a -> f b
16:35:07 <idnar> ddarius: oh, of course
16:36:07 <Gracenotes> :t (<*>)
16:36:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:36:14 <Gracenotes> :t (<$>)
16:36:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:36:18 <walski> Hi, I would like to have to patterns in a function that takes a list of Strings. One that satifies a list with just one empty and one for the lists with n elements where n > 1
16:36:19 <Peaker> Haskell subclassing seems to be used for 2 reasons: 1) When the expressiveness includes some other class anyway, you subclass it.  2) When your laws relate the methods of the other class.   Is (2) a really good case for subclassing?
16:36:22 <walski> I've tried this: http://haskell.pastebin.com/de3e8c14
16:36:29 <walski> but it does not work :/
16:36:36 <ddarius> idnar: You could make a monad using a Stream type with return = repeat, I believe.
16:36:45 <Peaker> (1) should probably have auto-instances from the subclass somehow
16:37:07 <Peaker> Maybe (2) should not be a subclass -- so maybe subclassing can be replaced by this auto-instance mechanism instead?
16:37:38 <puusorsa> lambdabot, oh but you absolutely must meet this another program called gumbybot! it's so charming and wise in the ways of the world! you would benefit enormously to learn from its acquired experience before your introduction to impolite sociopath's saucy society!
16:37:51 <idnar> haha
16:38:08 <puusorsa> i hope i didn'te brane my damage
16:38:55 <puusorsa> holding on to false hopes and beliefs is one of my innumerable abilities!
16:39:03 <Peaker> > return 5 :: ZipList Int
16:39:04 <lambdabot>       No instance for (Show (ZipList Int))
16:39:05 <lambdabot>        arising from a use of `show...
16:39:11 <Peaker> > unZipList $ (return 5 :: ZipList Int)
16:39:13 <lambdabot>   Not in scope: `unZipList'
16:39:23 <Peaker> > (runZipList . return) 5
16:39:24 <dolio> > getZipList $ return 5
16:39:26 <lambdabot>   Not in scope: `runZipList'
16:39:26 <lambdabot>       No instance for (Monad ZipList)
16:39:26 <lambdabot>        arising from a use of `return' a...
16:39:39 <dolio> > getZipList $ Control.Applicative.pure 5
16:39:40 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
16:39:41 <Peaker> damn lack of naming conventions :)
16:39:41 <BMeph> walski: (:) is a "two-argument function". I.e., 'h:' is a function that takes a list and returns a list with 'h' in front of it. What you want is [h], a list with just 'h' in it. :)
16:39:46 <puusorsa> also, i seem to have lost all my lack of stupid, please to be returning it if finding it in some monad or damn o'
16:40:26 <lazynick> looks like buildDisjunctions hs = foldr1 Disjunction (map Word hs)
16:40:47 <puusorsa> my functionality is being foldrd with (-) with all of it gone with the mind
16:41:00 <ddarius> lazynick: Why not foldr Disjunction False . map Word ?
16:42:24 <lazynick> ddarius: not familiar with the types involved.
16:42:57 <BMeph> ddarius: 'False' is not a Query value. :)
16:43:01 <pumpkin> ghc gets really slow on large files
16:43:10 <pumpkin> this one has 600 lines of which most are commented out
16:43:18 <pumpkin> and it's still painfully slow
16:43:38 <jberg> hey, are there any good web hosting companies which lets me use haskell (happs?) and ssh access etc. etc
16:43:50 <pumpkin> I use slicehost
16:43:52 <Peaker> if I have a 200 line file its because its a mundane list of keyboard keys or so... I think 140 lines is a big module
16:44:05 <jeffz`> jberg: probably any of the virtual hosting ones
16:44:14 <jberg> pumpkin: do you like it?
16:44:22 <pumpkin> Peaker: this is just a long list of tests
16:44:28 <Peaker> pumpkin: oh
16:44:28 <pumpkin> jberg: yeah, it's great
16:44:33 <jberg> jeffz, hmm. what do you mean by virtual hosting ones?
16:44:44 <pumpkin> you get a VM
16:44:47 <pumpkin> (like in slicehost)
16:45:08 <jeffz`> jberg: they are a dime a dozen, you pay a set fee per month and they give a you a xen or other guest
16:45:50 <jberg> ah okay, thats cool
16:46:08 <jeffz`> jberg: some say linode is good
16:49:07 <walski> Is there any function that checks if a string occurs in another string?
16:49:21 <SamB> walski: the badly-named isInfixOf
16:49:31 <walski> SamB:  thanks
16:49:34 <vpetro> jberg: slicehost vps is good.
16:49:42 <Peaker> @type isInfixOf
16:49:44 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:49:46 <walski> nice name ;)
16:50:03 <Peaker> @djinn (Eq a) => a -> a -> Bool
16:50:04 <lambdabot> f = (==)
16:50:26 <Peaker> @djinn a -> Bool
16:50:27 <lambdabot> f _ = False
16:55:59 <jberg> slicehost looks very good
16:58:12 <pumpkin> I think ghc's compilation is quadratic in the number of expressions in the file or something :P
16:58:18 <pumpkin> compilation time, that is
17:00:02 <dolio> If your file is mostly comments, that doesn't seem likely to be the problem.
17:02:01 <pumpkin> well, there's a lot of tests too
17:02:41 <roconnor> @hoogle (a -> Bool) -> (a->Bool) -> (a->Bool)
17:02:42 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
17:02:42 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
17:02:42 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
17:02:54 <roconnor> @type liftM2 (||)
17:02:56 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
17:03:29 <roconnor> I'd be nice to define union and intersection
17:03:36 <Gracenotes> would it be possible to get djinn working with lists?
17:04:37 <Gracenotes> i.e., defining a Nil/Cons
17:05:05 <dolio> Adding recursive types would be a significant change.
17:05:11 <raji> does anyone have implementation of interval trees in hs ?
17:05:19 <raji> how about range trees for 2 D ?
17:05:29 <Gracenotes> ah.
17:05:55 <dolio> For one, you have to be careful what the semantics are to avoid introducing non-termination and such.
17:06:23 <dolio> And it wouldn't surprise me if the kind of inference djinn does would be undecidable after adding them, too.
17:07:21 <dublpaws> is there a built in test for f == g, where f and g are functions, and have the same type sig?
17:07:34 <SamB> > [minBound,maxBound..]
17:07:36 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:07:37 <dolio> That's undecidable in general.
17:07:41 <SamB> > [minBound,maxBound..] :: [Int]
17:07:43 <lambdabot>   [-9223372036854775808,9223372036854775807]
17:07:53 <SamB> > [minBound,0..] :: [Int]
17:07:56 <lambdabot>   [-9223372036854775808,0]
17:08:00 <SamB> > [minBound,-1..] :: [Int]
17:08:02 <lambdabot>   [-9223372036854775808,-1,9223372036854775806]
17:08:17 <BMeph> dublpaws: What dolio said. :)
17:09:45 <dublpaws> I see, though there is a unit test feature I've seen where a flurry of typed data is thrown at functions..
17:10:53 <blackdog> dublpaws: QuickCheck
17:11:03 <blackdog> but that's only a statistical promise
17:11:04 <pumpkin> it's as good as you're going to get
17:11:11 <dolio> You could, theoretically, test for equality of functions where you can enumerate the entire domain, and test for equality on the range, but that would be unusably slow in most cases.
17:11:23 <ddarius> Gracenotes: You can sort of fake it in a few cases using a church encoding, but, without rank-2 types e.g. reverse wouldn't be doable that way.
17:11:38 <pumpkin> GHC has 300 megs of my memory
17:11:39 <pumpkin> :o
17:12:16 <pumpkin> 370 now
17:12:25 <blackdog> pumpkin: what are you doing?
17:12:29 <pumpkin> compiling a large file
17:12:30 <Gracenotes> ddarius: church encoding? Does that imply that you have to specify the length of lists?
17:12:38 <ddarius> Gracenotes: No.
17:12:41 <blackdog> eesh. that's pretty impressive
17:12:57 <blackdog> pumpkin: perhaps this is a gentle hint to split your code :)
17:13:02 <Cale> dolio: Also for compact domains
17:13:05 <pumpkin> blackdog: I probably should
17:13:09 <pumpkin> it's just a big list of tests
17:13:14 <ddarius> @djinn a -> (list -> (a -> list -> list) -> list)
17:13:14 <lambdabot> f a b c = c a b
17:13:15 <pumpkin> 556 megs now
17:13:22 <pumpkin> ah, it's done
17:13:23 <ddarius> Set c = (:) and b = []
17:13:27 <Gracenotes> that's. big.
17:13:29 <ddarius> :t return
17:13:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:13:33 <ddarius> @src [] return
17:13:34 <lambdabot> return x    = [x]
17:14:18 <blackdog> pumpkin: hm. maybe turn optimisation off? or separate your tests?
17:14:29 <pumpkin> I'll probably just separate the tests
17:14:34 <blackdog> actually, i was meaning to ask - is there a standard place to put test files?
17:17:06 <pumpkin> in the packages I've seen, just under tests in the root of the project dir
17:19:50 <ddarius> dolio: Actually, you can't even check the equality of two () -> () functions.  You can semi-decide it of course.
17:20:03 <dolio> Oh, right.
17:20:28 <hackage> Uploaded to hackage: PerfectHash 0.1
17:20:36 <stepcut> ddarius: sure you can -- just not very quickly...
17:21:00 <ddarius> You only have to wait until the end of time.
17:21:16 <stepcut> ddarius: only sometimes
17:21:25 <ddarius> stepcut: Hence being semidecidable.
17:21:41 <stepcut> :p
17:22:17 <stepcut> turing was just trying to waste our time with his damn machines
17:23:29 * pumpkin wants to build a turing machine
17:23:40 <pumpkin> but it's hard to find a roll of infinite tape
17:23:46 <ddarius> stepcut: I agree.
17:24:26 <dolio> Church should have nipped that in the bud.
17:24:34 <stepcut> pumpkin: just tape the ends together
17:24:41 <pumpkin> stepcut: hah
17:26:07 <roconnor> cairo++
17:26:24 <vpetro> is there a function that would convert "22" into the actual number 22?
17:26:30 <pumpkin> vpetro: read
17:26:32 <pumpkin> or reads
17:26:40 <vpetro> ok, thanks.
17:26:42 <pumpkin> the latter is safer but doesn't give you 22 straight away
17:27:01 <vpetro> ok
17:30:31 <pumpkin> woohoo, epic test coverage
17:31:32 <BMeph> > (1*).fst.head.reads $ "22"
17:31:35 <lambdabot>   22
17:34:42 <pumpkin> :t liftM2
17:34:43 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:40:36 <Peaker> :t liftA2 . liftA2 . liftA2
17:40:38 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b c (f2 :: * -> *). (Applicative f2, Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
17:43:25 <jberg> hmm, im going to make a website and i need a search function who needs to search for items among several categories, which has dependencies between them and should pick out items based on constraints/dynamic/linear/optimizing/whatever programming. in the beginning the datasets are not going to be very big, but hopefully they will, so im wondering if haskell will be to slow to use? I dont think i want to put it in a relational database like post
17:43:45 <pumpkin> how can I export types I imported from my module, as well as all the functions I defined in it (i.e., I don't want to write all the functions individually)
17:43:55 <jberg> that, and im a haskell newbie :) so this will be my first non trivial haskell program
17:44:15 <mauke> pumpkin: so you want to reexport a module?
17:44:22 <pumpkin> mauke: oh, I guess, yeah
17:44:27 <pumpkin> that's my answer I guess :)
17:44:37 <mauke> module Foo (module Bar, andMy, ownStuff) where
17:44:53 <pumpkin> what if I want to just implicitly export all myownstuff
17:45:01 <pumpkin> as well as modules
17:45:02 <jberg> maybe i can program the data structure in low level c because of speed and define high level haskell DSL to search over it
17:45:12 <pumpkin> jberg: haskell is plenty fast
17:45:29 <pumpkin> jberg: don't prematurely optimize, but keep your larger goal in mind :P
17:45:34 <mauke> pumpkin: module Foo (module Bar, module Foo) where  -- no idea if that actually works
17:46:10 <pumpkin> didn't seem to
17:46:17 <pumpkin> ah well, I'll do it the uglier way :)
17:47:08 <jberg> pumpkin: sure, but maybe not if you used a list for everything. i have this idea that i need to know a lot of secret compiler pragmas and hidden typeclasses to make it quick
17:47:24 <pumpkin> nah, you just need to use appropriate datastructures :)
17:47:32 <mauke> secret compiler pragma #1: -O2
17:48:26 <ksf> wtf does a .o that's generated from C-Sources not contain any symbols? compiling it manually with gcc and (basically) the same options works fine.
17:49:00 <BMeph> jberg: With all of this speculation you're doing... have you actually *tried* it yet? :)
17:49:27 <jberg> nope, i just came up with an idea for a great startup just now :)
17:49:28 <pumpkin> jberg: you can use linked lists in c too, and they'll be just as inefficient for indexing
17:50:03 <BMeph> jberg: Well, you know the old saying, "Never count your chickens, before they rip your lips off." ;)
17:50:12 <jberg> pumpkin well yeah
17:50:54 <jberg> anyways, i found http://haskell.org/haskellwiki/Research_papers/ today too which was a goldmine for me at least
17:54:37 <pejo> jberg, "There is currently no text in this page"?
17:55:18 <ddarius> An obviously false statement.
17:55:55 * ksf can't believe gcc throws away all functions if used with -O2
17:56:52 <Peaker> pejo: drop the trailing /
17:57:04 <pumpkin> by the time you hit -O7 on intel, it compiles your entire program to a single obscure SSE7 instruction
17:57:10 <pejo> ksf, that sounds fishy.
17:57:22 <jberg> pejo, oh, right, sorry. drop the trailing / like peaker said
17:58:07 <SamB> ddarius: I think it meant "there is currently no wiki page at this URL"
17:58:42 <ksf> even worse, cabal calls ghc with -optc-O2 without me telling it to do so.
17:59:17 <te> to what extent is something like test driven development possible in haskell
17:59:25 <SamB> what do you mean, "gcc throws away all functions"
17:59:35 <te> i mean im sure its possible, but is it a good idea in haskell
17:59:37 <ksf> In fact, I'm giving CC-Options that clearly doesn't include -O2
17:59:37 <SamB> te: type driven development is more common
17:59:55 <SamB> though tests are usefull, too
17:59:59 <pumpkin> te: it's awesome
18:00:02 <ksf> well, the .o has no exports.
18:00:23 <SamB> but if you write them first they're not called tests, they're called laws ;-P
18:00:33 <pumpkin> te: quickcheck + hpc = the shit
18:00:41 <jberg> hpc?
18:00:53 <pumpkin> haskell program coverage
18:01:00 <jberg> hmm
18:01:20 <pumpkin> up to 75% coverage of top-level declarations here
18:01:24 <pejo> te, John Hughes described how he programs Erlang nowdays: type quickcheck properties, implement the function and then test it.
18:01:34 <pumpkin> check http://blog.unsafeperformio.com/?p=18
18:01:47 <pumpkin> it's pretty beautiful
18:01:59 <pumpkin> you use hpc to decide what to write tests for, and then write one-liner tests in quickcheck
18:02:02 <ozy`> te: having a static type system already gives you some of what TDD enables... a type signature alone is an important test
18:02:21 <jberg> pejo, was that on a website with quickcheck videos? i can't remember
18:02:30 <monochrom> properties are generalized test cases.
18:02:32 <ksf> ...it's definitely fishy. ghc doesn't do tha with every file.
18:03:22 <pejo> jberg, probably http://www.ludd.luth.se/~pj/icfp2007/hughes%20testing.mov
18:04:06 <ksf> ha!
18:04:12 <ozy`> (who came up with the motto "if it compiles, it's probably correct"?)
18:04:21 <ksf> it's a static attribute before those functions.
18:05:39 <ksf> so I've got two possibilties: make all functions non-static, or figure out how to tell cabal not to pass -O2 to gcc.
18:06:09 <Taejo> what is the difference between gitit and orchid?
18:06:29 <pejo> ksf, but that is what static means, it's safe to remove the function if it is unused.
18:09:03 <ksf> gcc -E -c agar-glue.h `agar-config --cflags` | sed -e "s/^static//" >agar-stuff.c
18:09:07 <ksf> that's evil.
18:09:20 <ksf> ...but saves me from hacking c2hs.
18:12:53 * kerlo begins solving Project Euler stuff
18:13:15 <ksf> still, why does cabal pass -O2?
18:14:16 <CakeProphet> > filterM (const [True, False]) [1..10]
18:14:18 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,10],[1,2,3,4,5...
18:14:25 <kerlo> The easiest ones are pretty easy.
18:14:26 <ddarius> ksf: It makes sense for what cabal is for.
18:14:35 <CakeProphet> > filterM (const [True, False]) [1..2]
18:14:37 <lambdabot>   [[1,2],[1],[2],[]]
18:14:39 <ddarius> ksf: There should be a way to edit the .cabal file to change it though.
18:14:47 <ddarius> and/or use command-line flags.
18:19:42 <CakeProphet> @src filterM
18:19:43 <lambdabot> Source not found.
18:19:54 <Cale> > do b <- [True, False]; xs <- [[2],[]]; if b then (1:xs) else xs
18:19:56 <lambdabot>   [1,2,1,2]
18:20:11 <Cale> ... right
18:20:17 <Cale> > do b <- [True, False]; xs <- [[2],[]]; return (if b then (1:xs) else xs)
18:20:19 <lambdabot>   [[1,2],[1],[2],[]]
18:22:17 <Cale> > let filterM p [] = return []; filterM p (x:xs) = do b <- p x; xs <- filterM p xs; return (if b then (x:xs) else xs) in filterM [True, False] [1..3]
18:22:18 <lambdabot>   Couldn't match expected type `a -> m Bool'
18:22:28 <Cale> > let filterM p [] = return []; filterM p (x:xs) = do b <- p x; xs <- filterM p xs; return (if b then (x:xs) else xs) in filterM (const [True, False]) [1..3]
18:22:30 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:22:37 <pumpkin> fancy
18:22:47 <pumpkin> , subsequences [1..3]
18:22:48 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
18:23:14 <Cale> > filterM (const [True, False]) [1..3] -- of course, it's a library function
18:23:16 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:23:27 <Cale> > filterM (const [False, True]) [1..3]
18:23:28 <pumpkin> that's still pretty neat
18:23:29 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
18:23:37 <knapr> is ghc on github?
18:23:41 <pumpkin> yeah
18:23:52 <Cale> I wonder which algorithm subsequences is using...
18:23:55 <knapr> anyway is ghc mostly written in haskell
18:23:59 <Cale> knapr: yes
18:24:05 <pumpkin> , src 'subsequences
18:24:08 <lunabot>  subsequences :: forall a . [a] -> [[a]]
18:24:11 <Cale> knapr: (it is written in GHC Haskell)
18:24:13 <pumpkin> oh yeah, src is fake
18:24:32 <knapr> is ubuntu written in haskell
18:24:39 <Cale> knapr: hm?
18:24:57 <knapr> i heard torvalds converted to the cult of haskell
18:25:10 <knapr> more monads to the people he chanted
18:25:13 <Cale> knapr: Ubuntu is a collection of software packages written for linux, it's written in all sorts of languages, but I don't think there's all that much Haskell code in it.
18:25:26 <knapr> its all haskell i tell you
18:25:27 <danjam> he sacrifices the mandatory chicken every eldritch moon
18:25:44 <Cale> I haven't heard anything about Linus becoming a Haskeller, but it would be interesting if true :)
18:25:54 <pumpkin> grr
18:26:27 <pumpkin> quickcheck says this test failed but the case it says fails, doesn't
18:26:36 <Cale> pumpkin: hmm
18:26:43 <Cale> pumpkin: Are you sure it's the right type?
18:26:50 <pumpkin> oh wait
18:26:50 <ozy`> I'm pretty sure Linus has eyes only for C(ing)
18:26:52 <Cale> pumpkin: Maybe it's an Int/Integer thing?
18:26:54 <pumpkin> it was right :)
18:26:57 <Cale> ah :)
18:27:04 <ddarius> pumpkin: Computers tends to be.
18:27:07 <pumpkin> yeah
18:27:15 <pumpkin> I guess it actually caught a subtle bug
18:27:22 <newsham> this sort of error has happened before and has always been attributed to human error
18:27:25 <pumpkin> because I was assuming it would behave the same way no matter what type
18:27:31 <pumpkin> yay
18:27:40 <pumpkin> now to figure out what was wrong
18:27:45 <BMeph> pumpkin: If it did, I'm sure there's a pill to get it right again... ;)
18:28:17 <pumpkin> aha, indeed!
18:33:38 <kerlo> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
18:33:39 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:33:39 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:33:39 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
18:33:42 <kerlo> Oh, right.
18:35:47 <ksf> I din't found anything about linus and haskell yet, but I fould http://marc.info/?l=git&m=122955159617722&w=2
18:39:15 <idnar> I thought Linus didn't like darcs because it was written in Haskell
18:39:39 <pejo> idnar, he designed git to fit his workflow.
18:39:46 <idnar> also jidanni is a nutjob
18:40:07 <SamB> I was pretty sure it was 'cause it was slow and didn't fit his stlye ...
18:40:25 <gnuvince_> If Linus thinks C++ is too high level and too abstract to be good, what are the chances that he'll even consider looking at Haskell?
18:40:52 * ksf actually considers haskell to be much better at low-level stuff than c++.
18:40:52 <SamB> gnuvince: he might have meant "too complicated"
18:40:59 <SamB> and yes, there is that
18:41:07 <SamB> haskell is fine for lots of low-level stuff ...
18:41:09 <kerlo> I would most like to program in first-order logic.
18:41:18 <gnuvince_> SamB: Haskell is a pretty complicated language too.
18:41:25 <idnar> it seems to me like Haskell lets you get pretty close to the metal if you want to
18:41:32 <idnar> it's not pretty, but then again, it's not as if C is any better
18:41:54 <SamB> at least most of the complications in haskell aren't just new ways to shoot yourself in the foot
18:41:55 <blackdog> well, the onus is sort of on us
18:42:06 <blackdog> Linus knows C, and can create fast, scalable systems in it
18:42:24 <idnar> pretty buggy systems, unfortunately
18:42:27 <kerlo> Now, Haskell has a way to wrap strings over multiple lines, doesn't it?
18:42:39 * ksf guesses linus would have gone for darcs instead of writing git if darcs was back then what it's now.
18:42:48 <pumpkin> what's a good test for newU
18:42:51 <blackdog> idnar: i haven't caught any bugs in git myself...
18:42:52 <SamB> ksf: doubt it.
18:43:01 <SamB> it's not that good for merging, is it?
18:43:02 <idnar> blackdog: I was thinking of Linux
18:43:13 <ozy`> hey, do emacs and yi make the mistake of highlighting "--->" as a comment?
18:43:21 <SamB> idnar: Linux is too big not to have bugs
18:43:25 <idnar> blackdog: I've barely used git (I tried to check something out once, and couldn't figure out how), so I can't comment on how buggy it is
18:43:29 <Axman6> pumpkin: newU :: ?
18:43:38 <idnar> SamB: that's true to a point
18:43:40 <blackdog> idnar: ah, right. are there any OSes that are significantly less buggy than Linux and of comparable features?
18:43:44 <gnuvince_> ozy`: Emacs doesn't.
18:43:45 <SamB> anyway, the only git bugs I've found were in git-svn, I think ...
18:43:53 <pumpkin> newU :: UA e => Int -> (forall s. MUArr e s -> ST s ()) -> UArr e
18:43:59 <pumpkin> :P
18:44:02 <idnar> blackdog: probably not
18:44:17 * kerlo blinks
18:44:22 <idnar> blackdog: all I'm saying is that Linux is pretty awful, even if everything else is even worse :P
18:44:30 <kerlo> A definition "x = read y" results in the compiler yelling at you?
18:44:50 <pumpkin> kerlo: read needs a type
18:44:52 <idnar> kerlo: monomorphism restriction, I guess
18:44:56 <dolio> \a -> newU (lengthU a) (\a' -> copyMU a' 0 a) == a?
18:45:03 <gnuvince_> idnar: "Linux is worse OS in existence except for all the others"?
18:45:06 <blackdog> idnar: am reminded of churchill's (?) line - "Democracy is the worst possible system, except for everything else we've tried"
18:45:15 <idnar> blackdog: heh
18:45:15 <mm_freak> what happened to hpaste?
18:45:17 * gnuvince_ high fives blackdog 
18:45:19 <pumpkin> dolio: that makes sense, thanks :)
18:45:23 <blackdog> gnuvince_: go away, i'm putting my tinfoil helmet back on now.
18:45:24 <ddarius> mm_freak: shapr broke it
18:45:49 <idnar> blackdog: I'm not even saying I want to start a Haskell OS project
18:46:01 <ozy`> mm_freak: shapr took it out for a joyride at 3AM and was spinning donuts on the back roads, when he spun into a tree. it caught fire and he fled the scene
18:46:29 <idnar> blackdog: I guess my point is that if Linux is an example of high-quality C software, let's not collect any more C software than we have to
18:46:36 <BMeph> Yeah, if it were a motorized unicycle, it wouldn't have been a problem... ;p
18:46:37 <SamB> ozy`: I wasn't aware it even had wheels
18:46:53 <SamB> or ONE wheel, considering shapr is a unicyclist
18:46:55 <ozy`> SamB: well it sure doesn't now, so it's not like it makes a difference....
18:46:56 <Axman6> SamB: they're not that hard to code
18:46:57 <idnar> haha
18:47:00 <mm_freak> any alternatives with haskell syntax highlight?
18:47:14 <blackdog> idnar: let's distinguish between internal and external views, though.
18:47:16 <geezusfreeek> @where hpaste2
18:47:17 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
18:47:20 <blackdog> i'd rather write software in haskell, myself
18:47:21 <ddarius> mm_freak: Every programmer's editor.
18:47:22 <geezusfreeek> ^?
18:47:35 <ddarius> Oh, wrong thing.
18:47:38 <blackdog> but there's a burden of proof on me if i want to claim that other programmers would be better off using haskell than C
18:47:49 <pumpkin> Program Coverage Total	75%	453/600 for uvector :D
18:48:00 <mm_freak> ddarius: that would be emacs in my case, but that's not really what i'm looking for =)
18:48:06 <Axman6> pumpkin: nice work :)
18:48:21 <Axman6> pumpkin: i hope they're all _good_ tests though
18:48:21 <idnar> blackdog: I gave up on evangelism a while back for the most part, because I realised that most programmers seem to be more interested in writing bad software than good software
18:48:27 <pumpkin> Axman6: they all suck
18:48:32 <pumpkin> Axman6: but I caught a couple of bugs with them anyway
18:48:49 <Axman6> nice :)
18:49:04 <blackdog> idnar: that sounds like a market opportunity to me :)
18:49:10 <geezusfreeek> idnar, of course, their logic is that they'd rather write software than learn how to all over again
18:49:23 <idnar> blackdog: yeah, except PHP and friends already seem to have that market sewn up :P
18:49:35 <Axman6> pumpkin: you need to write a nice tutorial on how to use uvector. there's nothing out there that i could see (you can use my blog if you like :)
18:49:45 <idnar> geezusfreeek: hmm, it's more a case of preferring to write bad software quickly rather than good software slowly
18:49:52 <gnuvince_> idnar: most programmers are interested in cashing a check with the least amount of effort possible.
18:50:03 <pumpkin> Axman6: maybe one day :P not sure you want a tutorial written by me anyway ;)
18:50:21 <Axman6> pumpkin: well, you can tell me how to use it, and i'll write a tutorial ;)
18:50:32 <pumpkin> its API is pretty similar to List
18:50:34 <idnar> geezusfreeek: there's also the "guru elitism" bunch, who think the harder it is to do stuff the better, because it makes them feel superior to everyone else
18:50:38 <Axman6> oh! i can sticl my IO tutorial on my blog :D
18:50:39 <pumpkin> you just need to be a bit more careful
18:50:41 <blackdog> gnuvince_: hacking's all about the benjamins :)
18:50:58 <idnar> geezusfreeek: you know, "real men do manual memory management and register twiddling, garbage collection is for losers!"
18:51:08 <geezusfreeek> idnar, i've seen the opposite. they think we are the "guru elitism" bunch because we use such a "weird" language
18:51:13 <pumpkin> how can I open a pipe in haskell? I just want something that gives me two Handles
18:51:13 <gnuvince_> blackdog: franklins?
18:51:29 <blackdog> gnuvince_: actually, mostly hamiltons, but there's always hope
18:51:38 <geezusfreeek> most C programmers can't imagine life without pointer math, null pointers, memory management, etc.
18:51:49 * gnuvince_ will need to study American History to understand this analogy
18:51:54 <idnar> geezusfreeek: sure; I mostly travel in Python circles, though, which doesn't have that kind of stigma attached
18:52:07 <geezusfreeek> i work with a bunch of linux kernel developers
18:52:21 <gnuvince_> geezusfreeek: most are afraid that if they relinquish that control, that their software will immediately become slow and bloated
18:52:21 <blackdog> gnuvince_: hamilton is on the ten dollar note,  ithink
18:52:41 <idnar> geezusfreeek: in fact, probably 80% of my code output these days is Python (and the rest is mostly JavaScript...); there's this guy I know who still keeps asking me when I'm going to move on to a /real/ language
18:52:42 <gnuvince_> blackdog: that was the first Secretary of the Treasury, right?
18:52:46 <blackdog> geezusfreeek: heh, i've been doing that in haskell lately :) i had three repetitions of "unsafe" on the same line
18:52:47 * gnuvince_ is watching John Adams ;)
18:52:51 <idnar> geezusfreeek: where by "real" he means C++ or C# or something
18:52:56 <pumpkin> hmm, System.IO seems to have nothing for it
18:53:10 <pumpkin> @hoogle IO (Handle, Handle)
18:53:10 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
18:53:10 <lambdabot> Control.Monad.Writer.Lazy runWriterT :: WriterT w m a -> m (a, w)
18:53:10 <lambdabot> Control.Monad.Writer.Strict runWriterT :: WriterT w m a -> m (a, w)
18:53:14 <blackdog> gnuvince_: i get all of my american political history from saturday night live
18:53:34 <blackdog> gnuvince_: check out 'Lazy Sunday'
18:53:40 <geezusfreeek> i believe i have all but convinced my coworkers by now that i am the only one using a real programming language ;)
18:53:47 <idnar> geezusfreeek: haha
18:53:59 <idnar> geezusfreeek: if someday I end up writing mostly Haskell code, I think it'll blow his poor mind
18:54:03 <kerlo> pumpkin: such that when you write to one handle, you can read the same thing from the other?
18:54:08 <pumpkin> kerlo: yeah
18:54:21 <pumpkin> just like the pipe(int fd[2]) function
18:54:39 <geezusfreeek> of course it is not very practical to try to integrate haskell code with the linux kernel in the presence of C programmers, so i don't get much opportunity to use haskell at work
18:55:15 <idnar> geezusfreeek: it's funny, though
18:55:21 <pumpkin> I guess I can just open a temporary file
18:55:27 <pumpkin> but that feels icky
18:55:50 <idnar> geezusfreeek: a while back, I figured I'd never even be able to consider switching from Python to another (less popular) language, because there would be so many libraries and whatever that I'd have to rewrite myself
18:56:03 <sbahra> geezusfreeek, what do you guys work on?
18:56:11 <idnar> geezusfreeek: fast forward a few years, and I've ended up doing that anyway, because all the existing stuff just isn't of sufficient quality for serious work
18:56:25 <geezusfreeek> sbahra, antihacking, antireverse engineering, forensics, etc.
18:56:37 <sbahra> geezusfreeek, LSM?
18:56:40 <sbahra> geezusfreeek, ah, ok.
18:56:42 <gnuvince_> geezusfreeek: there was a fellow who blogged about how he used QuickCheck to generate C test cases.  You could start with that if you want to subvert your coworkers ;)
18:56:50 * sbahra notes 0x41414141.com
18:57:12 <pumpkin> sbahra :o
18:57:31 <sbahra> pumpkin, hi
18:57:59 <geezusfreeek> sbahra, not lsm. we have our own proprietary product line
18:58:08 <kerlo> @hoogle hex
18:58:09 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
18:58:09 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
18:58:09 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
18:58:23 <pumpkin> that was an uninteresting message on that site :P
18:58:27 * kerlo frowns
18:58:27 <geezusfreeek> well, we may rely on some lsm stuff maybe
18:58:29 <sbahra> geezusfreeek, could I take a look?
18:58:35 <kerlo> @hoogle hex :: String -> a
18:58:36 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
18:58:36 <lambdabot> Data.Char isHexDigit :: Char -> Bool
18:58:38 <sbahra> geezusfreeek, at your product page.
18:58:49 <sbahra> pumpkin, oh? :-P
18:58:53 <kerlo> Any readHex sort of thing, String -> Integer?
18:59:01 <kerlo> Wait, that's not even what I want.
18:59:02 <sbahra> pumpkin, well, I did that. Everything else was Windows specific.
18:59:09 <pumpkin> sbahra: I thought it would have the answer to the question!
18:59:19 <pumpkin> sbahra: oh you run that?
18:59:24 <kerlo> I wanted to show in hexadecimal.
18:59:25 <pumpkin> I guess I just sent you an email :P
18:59:38 <sbahra> pumpkin, no. :)
18:59:46 <geezusfreeek> sbahra, http://pikewerks.com has our currently released products
19:00:10 <kerlo> @hoogle showHex
19:00:10 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
19:00:20 <pumpkin> ugh, I don't feel like starting up vmware to do the second one
19:00:42 <sbahra> pumpkin, yeah :-/
19:00:46 <pumpkin> damn mac :)
19:00:56 <pumpkin> I enjoy this stuff though
19:01:08 <sbahra> pumpkin, then you might want to try the wargames at http://www.overthewire.org/
19:01:09 <pumpkin> I still want IO (Handle, Handle) though
19:01:14 <kerlo> Okay, here's a web address for you: http://0x480ecd64/
19:01:29 <geezusfreeek> sbahra, i am under nda of course, but even if i wasn't i wouldn't be able to say much about EA or Second Look as I haven't worked on those projects directly
19:01:58 <sbahra> geezusfreeek, seems interesting.
19:02:14 <pumpkin> sbahra: I'll take a look sometime :)
19:02:16 <kerlo> Looks similar to 0x41414141.com, but without the nasty .com at the end.
19:02:20 <sbahra> http://pikewerks.com/sl
19:02:23 <geezusfreeek> sbahra, we are constantly hiring :)
19:02:35 <sbahra> geezusfreeek, Kasperle's thesis was on this (a bochs patch).
19:02:56 <sbahra> Well, he implemented something similar.
19:03:14 <geezusfreeek> oh?
19:03:17 * geezusfreeek googles
19:03:24 <geezusfreeek> if possible
19:03:40 <BMeph> kerlo: It's called 'showIntAtBase', in the Numeric module. :)
19:04:02 <kerlo> Or showHex, if it's hexadecimal. :-)
19:04:12 <BMeph> kerlo: but yeah, showHex is a specialization. :)
19:04:25 <sbahra> geezusfreeek, http://pi1.informatik.uni-mannheim.de/index.php?pagecontent=site%2FResearch.menu%2FTheses.page%2FFinished%20Projects.page%2FPandora_s_Bochs__Automated_Malware_Unpacking.page&uin=&show=true
19:04:29 <kerlo> A specialization I happen to like at the moment.
19:04:36 <pumpkin> so there's no way to get a pipe in haskell without writing FFI code?
19:04:42 <kerlo> Happens to be convenient, I mean.
19:04:43 <pumpkin> oh maybe in the posix module
19:04:51 <ddarius> pumpkin: Look at System.Process
19:05:30 <sbahra> pumpkin, there is also popenhs
19:05:37 <kerlo> @docs System.Process
19:05:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
19:05:57 <pumpkin> I'm just trying to test serialization functions in uvector
19:06:21 <pumpkin> so I really just need to serialize to one side of the pipe, unserialize from the other, and check if they're equal
19:06:25 <CakeProphet> :t valOf
19:06:26 <lambdabot> Not in scope: `valOf'
19:06:40 <ddarius> pumpkin: Can't you just serialize to a bytestring and back?
19:07:02 <pumpkin> hPutU :: Handle -> UArr a -> IO () :(
19:07:04 <geezusfreeek> sbahra, ah this is slightly different. second look is designed to analyze an already compromised system
19:07:24 <ddarius> pumpkin: Why not use a file then?
19:07:27 <Axman6> pumpkin: open a test file
19:07:36 <pumpkin> ddarius: I just wanted to avoid creating a temporary file, but I guess I'll do that :)
19:08:05 <sbahra> geezusfreeek, :)
19:08:22 <pumpkin> there's no withTemporaryFile that closes and deletes the file for me is there?
19:09:07 * pumpkin is a master hax0r
19:09:17 <pumpkin> he'll hax0r your b0x0r
19:09:20 <pumpkin> etc.
19:09:56 * BMeph wil r0x0r you b0xZ0rZ...
19:10:30 * pumpkin hax0rz BMeph's b0x0r
19:11:55 <pumpkin> ddarius: one issue is that these test functions are going to get called a few hundred times... is it safe to open that many files? will they be closed as soon as I tell it to close them?
19:12:16 <geezusfreeek> sbahra, this thesis looks very cool. thanks for the link!
19:12:24 <ddarius> pumpkin: Yes, yes.
19:12:48 <pumpkin> alright :) thanks
19:13:08 <sbahra> geezusfreeek, no problem. He is "Kasperle" on this network if you want to contact him.
19:14:20 <CakeProphet> > dynTypeRep (toDyn 10)
19:14:22 <lambdabot>   Integer
19:15:29 <pumpkin> @hoogle temp
19:15:29 <lambdabot> package template
19:15:29 <lambdabot> package template-haskell
19:15:29 <lambdabot> Distribution.Extension TemplateHaskell :: Extension
19:17:39 <pumpkin> what's the function to delete a file?
19:17:45 <sbahra> Where is Expr defined?
19:17:53 <sbahra> @hoogle unlink
19:17:53 <lambdabot> System.Posix.Internals c_unlink :: CString -> IO CInt
19:18:02 <sbahra> @hoogle delete
19:18:02 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
19:18:02 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
19:18:02 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
19:18:08 <sbahra> pumpkin, c_unlink will work at the least
19:18:23 <sbahra> Not sure if that's what you should use, though.
19:18:31 <pumpkin> doubt it :)
19:18:36 <pumpkin> looks like the direct ffi one
19:18:40 <pumpkin> ugh the other problem this is causing is that tests are pure
19:18:46 <pumpkin> but now I'm having to return IO Bool
19:18:59 <pumpkin> I guess it would've been the same with a pipe
19:19:32 <pumpkin> I could unsafePerformIO on it, but that feels icky
19:19:33 <jeffz`> pumpkin: removeFile?
19:19:39 <pumpkin> @hoogle removeFile
19:19:40 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
19:19:42 <pumpkin> thanks :)
19:19:43 <sbahra> coo
19:20:34 <CakeProphet> > let lol :: Dynamic -> Dynamic; lol x = | dynTypeRef x == typeOf 1 = "lol" | dynTypeRef x == typeOf "" = True in map (lol.toDyn) ["string", 1, "another string", True]
19:20:35 <lambdabot>   <no location info>: parse error on input `|'
19:20:43 <CakeProphet> > let lol :: Dynamic -> Dynamic; lol x | dynTypeRef x == typeOf 1 = "lol" | dynTypeRef x == typeOf "" = True in map (lol.toDyn) ["string", 1, "another string", True]
19:20:45 <lambdabot>   Not in scope: `dynTypeRef'Not in scope: `dynTypeRef'
19:20:45 <redditbot> Dictionary-free overloading by Partial Evaluation
19:20:50 <pumpkin> is this a safe case to do an unsafePerformIO?
19:21:09 <Axman6> are the tests pure?
19:21:23 <Axman6> /referencially transparent?
19:21:25 <pumpkin> "almost pure" ;)
19:22:06 <pumpkin> http://www.archivum.info/haskell-cafe@haskell.org/2008-09/msg01438.html dons says it's okay here
19:22:48 <sbahra> @fact symbols
19:22:49 <lambdabot> symbols: "⊤ ⊥ λ ε η ι ∃ ∀ ¬ ∈ ∉ ∋ ∌ ∧ ∨ ⊕ ↑ ↓ ⇒ ⇐ ⇔ ⊢ ⊬ ⊨ ⊭ ∘ ∪ ∩ ∴ ∵ ≡ ⊂ ⊃ ⊻ ⊼ ⋀ ⋁ ⊲ ⊳ ⟦⟧"
19:22:59 <rkrksskr_> ±²³´¶µ³´´¸µ¶¹¸·µ¸·´·µ¹¸···············
19:23:19 <sbahra> huh?
19:24:02 <CakeProphet> hmmm
19:24:20 <CakeProphet> I bet you could use arrows to model a neural network.
19:25:05 <ozy`> CakeProphet: do it
19:25:21 <CakeProphet> psh, I wouldn't even know where to start.
19:25:23 <ozy`> (the real problem with neural networks is that they're slow)
19:25:31 <CakeProphet> I've never even worked on elementary AI.
19:25:56 <ozy`> (slow to train, slow to process data...)
19:27:00 <CakeProphet> the question would be how to use the basic arrow functions to control computations on more than just two sets of computation.
19:27:21 <pumpkin> and hard to interpret
19:27:28 <pumpkin> (neural nets)
19:27:57 <rkrksskr_> GOOGLE'S AI WILL KILL US ALL!!!
19:28:49 <pumpkin> .syr.edu again
19:28:54 <rkrksskr_> that's me
19:29:00 <rkrksskr_> the only student in this entire school
19:29:31 <pumpkin> that's what I thought
19:29:51 <ozy`> human-like AI would be most easily implemented with a fast data structure that can take a partial pattern as input (with arbitrary gaps) and return a full pattern as output
19:30:05 <ozy`> I don't think this is possible on modern hardware
19:30:13 <ozy`> maybe memristors will help though
19:30:30 <ddarius> I suspect "human-like AI" would require a bit more than that...
19:30:34 <ozy`> (ie. the RAM itself could have that property)
19:30:54 <rkrksskr_> ozy: precisely
19:30:59 <rkrksskr_> you came to the same conclusion as i did
19:31:07 <ozy`> ddarius: well yeah, but I meant in the sense that we'd be building out of bricks instead of pieces of hay
19:31:12 <rkrksskr_> there are, in fact, algorithms to accomplish this
19:31:41 <ozy`> rkrksskr_: slow ones, yes :p
19:31:50 <rkrksskr_> but it's feasible at this point
19:31:59 <rkrksskr_> i believe google has already built them
19:31:59 <rkrksskr_> thus
19:32:03 <rkrksskr_> 22:26 < rkrksskr_> GOOGLE'S AI WILL KILL US ALL!!!
19:32:11 <CakeProphet> I think memristor technology will be overshadowed by a rising demand for steam engine computers.
19:32:34 <ddarius> Go Green, Burn Coal
19:32:42 <rkrksskr_> why don't you just plug a steam engine into a socket eh
19:32:47 <CakeProphet> for instance, in the last year the demand for steam engine computers has risen dramatical... from 0 to 1.
19:32:49 <CakeProphet> namely, me.
19:33:07 <lament> a steam engine fembot redefines the meaning of "hot sex"
19:33:24 <ddarius> CakeProphet: I doubt you are the only one or that the number was zero last year.
19:34:24 <ozy`> rkrksskr_: that's awesome if they've pulled it off already
19:35:14 <ddarius> @google site:google.com mycroft
19:35:15 <lambdabot> No Result Found.
19:35:32 <pumpkin> omg, stay away from IOMonad
19:35:35 <pumpkin> or you'll be trapped!
19:35:42 <IOMonad> LOL
19:35:44 <CakeProphet> depending on how the technology of a steam engine computer would work (whether it's the size of a small steam car's engine or perhaps something requiring much smaller amounts of water)... you'd likely need a larger electrical outlet. Maybe a washing machine outlet.
19:35:44 <Trafalgard> @google "steam engine computer"
19:35:47 <lambdabot> http://www.youtube.com/watch?v=K7irdXMZIL8
19:35:47 <lambdabot> Title: YouTube - Jensen Style 65 Steam Engine
19:36:01 <IOMonad> So does anyone know if theres a way to have global state in haskell
19:36:26 <IOMonad> maybe using FFI
19:36:33 <CakeProphet> @hoogle State
19:36:34 <lambdabot> module Control.Monad.State
19:36:34 <lambdabot> Test.HUnit.Base data State
19:36:34 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
19:36:35 <ozy`> IOMonad: sure, create a global IORef and modify it from within the IO monad
19:36:45 <ozy`> IIRC, the OpenGL bindings do this
19:36:47 <Trafalgard> well, nuclear power plants produce tons of steam and whatnot
19:36:57 <Trafalgard> so you could set up your computer up in one of those!
19:37:00 <mriou> hi, I'm having difficulties with monad transformers and ReaderT
19:37:01 <Trafalgard> :P
19:37:04 <IOMonad> ok ozy' thats what I suspected, I'll look into it
19:37:09 <IOMonad> tx
19:37:10 <mriou> with this type definition: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=956#a956
19:37:11 <IOMonad> thx
19:37:11 <rkrksskr_> Much pain have I
19:37:14 <rkrksskr_>   for more than loss of
19:37:15 <Trafalgard> and make a nuclear steam engine computer
19:37:16 <rkrksskr_>     realms:
19:37:20 <rkrksskr_> the days of peace and slumberous
19:37:21 <pumpkin> rkrksskr_: ...
19:37:23 <rkrksskr_> calm are fled
19:37:26 <rkrksskr_> ...all roads lead to
19:37:39 <CakeProphet> would the steam power the mechanical pieces that represent state or would the properties of evaporated water itself serve as the basis for information storage?
19:37:46 <mriou> how would one make a function like myReturn:: Int -> Eval Int ?
19:37:52 <CakeProphet> if the latter, I'd imagine you'd need much less steam.
19:38:49 <mriou> or even better evalReturn:: a -> Eval
19:39:07 <BMeph> mriou: If (Monad Eval), then it's "obviously" return. ;)
19:39:07 <CakeProphet> what is Eval?
19:40:03 <mriou> BMeph: doh, I'm dumb
19:40:37 <mriou> I was trying stuff like Right . ask . return :|
19:42:30 <mriou> BMeph: thanks :)
19:43:24 <sereven> surely there is a better way to say?   fmap (return f) g -- oh so very much a beginner :/
19:43:46 <ddarius> :t fmap . return
19:43:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
19:44:08 <ddarius> sereven: Are you sure that's what you want to do?
19:44:29 <pumpkin> that seems like a strange combination of fmap f and return f =<< g
19:45:06 <ddarius> sereven: In that case, return = const, did you mean fmap (return . f) perhaps?
19:45:23 <sereven> ddarius: well it gives the effect I'm after, but still trying to work out what f and g actually do, type names are layered, so no, not at all sure
19:45:59 <roconnor> > recip 14.646
19:46:01 <lambdabot>   6.827802813054759e-2
19:46:06 <roconnor> > recip 14.646 * 100
19:46:08 <lambdabot>   6.827802813054759
19:46:23 <ddarius> > recip 6.827802813054759e-2
19:46:25 <lambdabot>   14.645999999999999
19:46:49 <CakeProphet> > filterM (const [True,False,False]) [1..5]
19:46:50 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,3],[1,2,3,5],[1,2,3...
19:46:57 <CakeProphet> ...
19:47:44 <papermachine> > :t filterM
19:47:45 <lambdabot>   <no location info>: parse error on input `:'
19:47:49 <papermachine> :t filterM
19:47:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
19:47:53 <CakeProphet> I really don't understand filterM
19:48:39 <puusorsa> just like fter but the values get wrapped inside a monad?
19:48:40 <ddarius> CakeProphet: It takes a monadic predicate and a list, it applies the predicate and if it returns True it keeps that element of the list, otherwise it discards it.
19:50:33 <puusorsa> so for maybe itmay be  is(a -> Maybe Bool) -> [a] -> Maybe [a] ?
19:50:50 <pumpkin> this test suite is epic
19:51:23 <ozy`> the word "epic" is epic
19:51:28 <pumpkin> epic win
19:52:12 <pumpkin> 81% coverage :D
19:52:20 <pumpkin> it started out in the low 20s
19:54:44 <sereven> okay, afact -- f :: [a] -> [a] and g :: m ([a] -> [a]) and I'm trying to get f applied to result of g's ([a] -> [a]), or vice versa some sort of lifted f . g -- or g . f would make as much sense in this case. Eventually would like to understand both.
19:55:36 <ddarius> :t fmap (f .)
19:55:38 <lambdabot> forall b c a (f :: * -> *). (Functor f, SimpleReflect.FromExpr c, Show b) => f (a -> b) -> f (a -> c)
19:56:38 <roconnor> > recip 40
19:56:39 <lambdabot>   2.5e-2
19:56:43 <ddarius> :t \f -> fmap (f .)
19:56:44 <lambdabot> forall b c a (f :: * -> *). (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
19:56:53 <CakeProphet> > pi / (exp 1)
19:56:54 <lambdabot>   1.1557273497909217
19:57:06 <ddarius> > pi * exp (-1)
19:57:07 <lambdabot>   1.1557273497909217
19:57:08 <CakeProphet> a fun ratio for geometric patterns.
19:58:42 <sereven> ddarius: thank you!
19:59:58 <ozy`> > e
19:59:59 <lambdabot>   e
20:00:08 <ozy`> > HHHHHHHHHHHHH
20:00:10 <lambdabot>   Not in scope: data constructor `HHHHHHHHHHHHH'
20:00:36 <CakeProphet> > iterate (*) (pi / exp 1)
20:00:37 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
20:00:37 <lambdabot>      Proba...
20:00:45 <CakeProphet> :t iterate
20:00:46 <lambdabot> forall a. (a -> a) -> a -> [a]
20:01:12 <CakeProphet> > iterate (*(pi / exp 1)) 1
20:01:14 <lambdabot>   [1.0,1.1557273497909217,1.3357057070547476,1.5437116169149927,1.78410973585...
20:01:24 <CakeProphet> > map round $ iterate (*(pi / exp 1)) 1
20:01:26 <lambdabot>   [1,1,1,2,2,2,2,3,3,4,4,5,6,7,8,9,10,12,14,16,18,21,24,28,32,37,43,50,58,66,...
20:02:02 <idnar> @type fmap (return ?f) ?g
20:02:03 <lambdabot> forall b a (f :: * -> *). (Functor f, ?g::f a, ?f::b) => f b
20:02:28 <ddarius> idnar: There is a function equivalent to that ($>) or (<$)
20:02:30 <ddarius> :t ($>)
20:02:31 <lambdabot> Not in scope: `$>'
20:02:35 <ddarius> :t (<$)
20:02:37 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
20:02:40 <idnar> yeah, I was going to say it looked familiar
20:03:39 <idnar> hmm, except
20:03:42 <idnar> @type \f g -> fmap (return f) g
20:03:43 <lambdabot> forall b a (f :: * -> *). (Functor f) => b -> f a -> f b
20:03:49 <idnar> oh, right
20:03:59 <CakeProphet> > map ((flip replicate " ") . round) $ iterate (*(pi / exp 1)) 1
20:04:01 <lambdabot>   [[" "],[" "],[" "],[" "," "],[" "," "],[" "," "],[" "," "],[" "," "," "],["...
20:04:16 <CakeProphet> > map ((flip replicate ' ') . round) $ iterate (*(pi / exp 1)) 1
20:04:18 <lambdabot>   [" "," "," ","  ","  ","  ","  ","   ","   ","    ","    ","     ","      "...
20:04:33 <CakeProphet> > intercalate '*' $ map ((flip replicate ' ') . round) $ iterate (*(pi / exp 1)) 1
20:04:34 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
20:04:42 <CakeProphet> > intercalate "*" $ map ((flip replicate ' ') . round) $ iterate (*(pi / exp 1)) 1
20:04:44 <lambdabot>   " * * *  *  *  *  *   *   *    *    *     *      *       *        *        ...
20:04:49 <idnar> uhmm
20:05:04 <idnar> @type return f
20:05:05 <wchogg> How do I uninstall packages I've installed via cabal-install?
20:05:06 <lambdabot> forall a (m :: * -> *). (Monad m, SimpleReflect.FromExpr a) => m a
20:05:17 <idnar> @src (<$)
20:05:17 <lambdabot> (<$) = (<$>) . const
20:05:21 <idnar> @src (<$>)
20:05:21 <lambdabot> f <$> a = fmap f a
20:05:48 <idnar> oh, right, return = const there
20:07:07 <CakeProphet> @let phi = (1 + (sqrt 5)) / 2
20:07:09 <lambdabot>  Defined.
20:07:12 <CakeProphet> > phi
20:07:13 <lambdabot>   1.618033988749895
20:07:29 <CakeProphet> > phi :: CReal
20:07:30 <lambdabot>   1.6180339887498948482045868343656381177203
20:08:53 <CakeProphet> @let stretch symbol ratio base = intercalate symbol $ map ((flip replicate ' ') . round) $ iterate (*ratio) base
20:08:56 <lambdabot>  Defined.
20:09:10 <CakeProphet> > stretch "*" phi 1
20:09:11 <lambdabot>   " *  *   *    *       *           *                  *                     ...
20:11:18 <ozy`> CakeProphet: phascinating.
20:11:27 <pumpkin> > stretch "CakeProphet" phi 1
20:11:29 <lambdabot>   " CakeProphet  CakeProphet   CakeProphet    CakeProphet       CakeProphet  ...
20:12:12 <CakeProphet> :t intersperse
20:12:13 <lambdabot> forall a. a -> [a] -> [a]
20:12:17 <Axman6> CakeProphet: nice :)
20:12:28 <Axman6> reminds me of the tickytape stuff we used to use in physics
20:12:45 <CakeProphet> ...I should change it so that it takes a string and cycles through the symbols.
20:12:51 <CakeProphet> :t cycle
20:12:52 <lambdabot> forall a. [a] -> [a]
20:13:43 <CakeProphet> > zipWith (:) [1,2,3] [4,5,6]
20:13:44 <lambdabot>       No instance for (Num [a])
20:13:45 <lambdabot>        arising from the literal `4' at <inter...
20:13:48 <CakeProphet> ...
20:14:26 <dmwit_> > zipWith (,) [1,2,3] [4,5,6]
20:14:28 <lambdabot>   [(1,4),(2,5),(3,6)]
20:14:36 <dmwit_> > zipWith (:) [1..3] [[4], [5], [6]]
20:14:38 <lambdabot>   [[1,4],[2,5],[3,6]]
20:15:22 <CakeProphet> I want [1,4,2,5,6]
20:15:38 <CakeProphet> er... 3, 6
20:16:20 <dmwit_> > concat . transpose $ [[1..3], [4..6]]
20:16:22 <lambdabot>   [1,4,2,5,3,6]
20:17:06 <CakeProphet> will that diverge on an infnite list?
20:17:12 <dmwit_> No.
20:17:15 <CakeProphet> > concat . transpose $ [1..] [1..]
20:17:16 <lambdabot>   Couldn't match expected type `t -> [[a]]'
20:17:25 <idnar> > let weave xs [] = xs; weave [] ys = ys; weave (x:xs) (y:ys) = x : y : weave xs ys in weave [1,2,3] [4,5,6]
20:17:26 <mriou> sorry, another question: is it possible to see the implementation GHC generates with GeneralizedNewtypeDeriving?
20:17:26 <lambdabot>   [1,4,2,5,3,6]
20:17:28 <dmwit_> > concat . transpose $ [[1..], [1..]]
20:17:29 <CakeProphet> > concat . transpose $ [[1..]] [[1..]]
20:17:30 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
20:17:31 <lambdabot>   Couldn't match expected type `t -> [[a]]'
20:17:45 <dmwit_> CakeProphet: Check carefully the syntax. ;-)
20:17:55 <dmwit_> ?pl \x y -> concat . transpose $ [x, y]
20:17:56 <lambdabot> ((join . transpose) .) . (. return) . (:)
20:17:57 <mriou> for example if I declare a new type that derives MonadReader, can I see its implementation of local and ask?
20:17:58 <idnar> > let weave xs [] = xs; weave [] ys = ys; weave (x:xs) (y:ys) = x : y : weave xs ys in weave [1..] [1..]
20:17:58 <CakeProphet> ...oh
20:17:59 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
20:18:09 <CakeProphet> dmwit_:  I sit quite a distance away from my computer. :(
20:18:12 <CakeProphet> didn't notice.
20:18:15 <idnar> heh
20:18:20 <dmwit_> mriou: No.
20:18:27 <dmwit_> mriou: It should be easy to figure out, though.
20:18:48 <CakeProphet> @let weave xs [] = xs; weave [] ys = ys; weave (x:xs) (y:ys) = x : y : weave xs ys in weave [1..] [1..]
20:18:48 <lambdabot>   Parse error
20:18:50 <dmwit_> mriou: ask f (Foo r) = Foo (ask f r) -- for example
20:18:51 <mriou> dmwit_: okay thanks, I just wanted to lean the lazy way ;)
20:18:52 <pumpkin> @tell dons I have uvector hpc coverage at 83% (for top-level)... I'll get it a little higher then submit patches
20:18:53 <lambdabot> Consider it noted.
20:18:58 <dmwit_> :t ask
20:18:59 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
20:19:00 <CakeProphet> @let weave xs [] = xs; weave [] ys = ys; weave (x:xs) (y:ys) = x : y : weave xs ys
20:19:03 <lambdabot>  Defined.
20:19:06 <dmwit_> oh
20:19:09 <Axman6> http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html hooray (probably needs a lot of work, but it's up on my blog now!)
20:20:01 <dmwit_> It depends on which instance of MonadReader it is, I guess.
20:20:29 <dmwit_> ?go io monad for people who just don't care
20:20:30 <dmwit_> ;-)
20:20:32 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
20:20:32 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
20:21:19 <Axman6> yeah i've read it
20:21:32 <dmwit_> I think this concept of taking things out of a box is a bad one, and confusing to boot.
20:21:33 <CakeProphet> > let cstretch string ratio base = weave (cycle string) $ map ((flip replicate ' ') . round) $ iterate (*ratio) base in cstretch "Cakeprophet" phi 1
20:21:34 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
20:21:50 <dmwit_> It's more like you're putting everything afterwards into the box...
20:21:54 <Axman6> dmwit_: makes sense to me though
20:22:06 <CakeProphet> > let cstretch string ratio base = weave (map (:[]) $ cycle string) $ map ((flip replicate ' ') . round) $ iterate (*ratio) base in cstretch "Cakeprophet" phi 1
20:22:08 <lambdabot>   ["C"," ","a","  ","k","   ","e","    ","p","       ","r","           ","o",...
20:22:14 <dmwit_> It leads naturally to the question "how do I get it out of the box for good", which has no good answer.
20:22:30 <CakeProphet> :t transpose
20:22:31 <lambdabot> forall a. [[a]] -> [[a]]
20:22:31 <dmwit_> But... different strokes for different folks, I guess.
20:22:49 <Axman6> it's a good way to start being able to actually write some IO code, without having to know how it actually works. then you can find out later what's really going on
20:23:05 <CakeProphet> > let cstretch string ratio base = concat $ weave (map (:[]) $ cycle string) $ map ((flip replicate ' ') . round) $ iterate (*ratio) base in cstretch "Cakeprophet" phi 1
20:23:06 <lambdabot>   "C a  k   e    p       r           o                  p                    ...
20:23:34 <idnar> argh
20:24:26 <CakeProphet> @let cstretch string ratio base = concat $ weave (map (:[]) $ cycle string) $ map ((flip replicate ' ') . round) $ iterate (*ratio) base
20:24:29 <CakeProphet> :D
20:24:29 <lambdabot>  Defined.
20:24:48 <dmwit_> Axman6: Weird, why are there lines through the comments?
20:25:21 <Axman6> the hscolour and movabe type css styles conflict :9
20:25:22 <mgarces> hello everyone
20:25:23 <Axman6> :(*
20:25:29 <Axman6> movable*
20:25:59 <dmwit_> Hiya, mgarces!
20:26:11 <mgarces> how's everyone
20:26:27 <mgarces> I'm loosing my mind with something that is very simple
20:26:42 <mgarces> here is very late, so it might be bacause of that
20:26:44 <mgarces> =)
20:27:08 <dmwit_> Well, what's up?
20:27:09 <mgarces> I'm trying a elegant way to sum 2 lists.. but different sizes
20:27:24 <dmwit_> :t sum -- ;-)
20:27:25 <lambdabot> forall a. (Num a) => [a] -> a
20:27:34 <mgarces> like [1,1,1] [1,1,1,1] should output [2,2,2,1]
20:27:44 <dmwit_> ah
20:27:50 <dmwit_> Do you know about repeat?
20:27:50 <noZone> ⊥
20:27:52 <dmwit_> :t repeat
20:27:53 <lambdabot> forall a. a -> [a]
20:28:04 <mgarces> kinda
20:28:08 <dmwit_> You can turn one of them into an infinite list:
20:28:17 <mgarces> ok
20:28:19 <dmwit_> [1,1,1,0,0,0,0,0,0,0,0,...]
20:28:28 <dmwit_> From there, it should be easy to see what to do. =)
20:28:36 <mgarces> =)
20:28:37 <rwbarton> there's also:
20:28:55 <rwbarton> > map sum . transpose $ [[1,1,1], [1,1,1,1]]
20:28:55 <CakeProphet> > let funSum [] [] = []; funSum x [] = x; funSum [] y = y; funSum (x:xs) (y:ys) = x+y : funSum xs ys in funSum [1,1,1] [1,1,1,1]
20:28:57 <lambdabot>   [2,2,2,1]
20:28:57 <lambdabot>   [2,2,2,1]
20:29:00 <CakeProphet> ...
20:29:12 <dmwit_> Yeah, that was my second thought.
20:29:20 <mgarces> sweet
20:29:21 <CakeProphet> all this transpose abuse is disturbing
20:29:24 <dmwit_> That's probably better, really.
20:29:36 <mgarces> I have found solutions for this
20:29:40 <mgarces> but not elegant ya know?
20:29:45 <mgarces> very naive
20:29:46 <dmwit_> Yeah. =)
20:29:51 <mgarces> still learning
20:29:52 <dmwit_> It helps to know the Data.List module really well.
20:30:10 <mgarces> got to study that
20:30:25 <mgarces> i've found this cool site
20:30:26 <mgarces> http://learnyouahaskell.com
20:30:29 <dmwit_> Axman6: You're missing a literate '>' on the last line.
20:30:45 <mgarces> it's a good complement to my books
20:30:53 <Axman6> so i am, thanks :)
20:31:06 <dmwit_> People seem to like LYAH, yeah.
20:31:09 <dmwit_> ?where RWH
20:31:09 <lambdabot> is http://www.realworldhaskell.org/blog/
20:31:27 <mgarces> this bot is nice, lol
20:31:48 <Axman6> dmwit_: ah, my find and replace skills for were only looking for ^[ \t]+\w ;)
20:32:22 <dmwit_> heh
20:32:34 <CakeProphet> > cstretch "lambdabot rules" 1 3
20:32:36 <lambdabot>   "l   a   m   b   d   a   b   o   t       r   u   l   e   s   l   a   m   b ...
20:32:38 <mgarces> CakeProphet: i really don't understand everything from your solution, but I'm trying =)
20:33:14 <dmwit_> mgarces: If you write it one line above the other, you should see it's the standard explicit recursion solution.
20:33:23 <CakeProphet> mgarces:  basically the first line is the case where both lists are the same length and terminate at the same... the second and third are the cases where one terminates before another, and the last is the case where neither has terminated (which works very much like a regular sum function)
20:33:29 <sbahra> import Sentential hiding (WFF)
20:33:29 <sbahra> import qualified Sentential as S
20:33:34 <sbahra> Is that considered bad habit?
20:33:51 <ddarius> No
20:33:54 <sbahra> Ok
20:34:03 <CakeProphet> > zipWith (+) [1,2,3] [1,2,3,4]
20:34:04 <lambdabot>   [2,4,6]
20:34:45 <dublpaws> reverseMap [f,g,h] x  -->  [(f x), (g x), (h x)]    Is there something like that?
20:34:47 <mgarces> CakeProphet: i get it
20:34:52 <Axman6> @quote drudge
20:34:53 <lambdabot> drudge says: Need Chelsea Clinton Nose Job? See Chelsea Clinton Nose Job.
20:35:00 <dmwit_> dublpaws: sequence
20:35:04 <dublpaws> thanks
20:35:26 <mgarces> CakeProphet: I had other solution
20:35:33 <mgarces> but I'm liking yours
20:35:36 <mgarces> =)
20:35:57 <Axman6> > sequence [f :: Expr -> Expr,g h] x
20:35:59 <lambdabot>   Add a type signature
20:36:04 <Axman6> > sequence [f :: Expr -> Expr,g h] x :: [Expr]
20:36:05 <lambdabot>   Add a type signature
20:36:10 <dmwit_> > sequence [f, g, h] x
20:36:12 <lambdabot>   Add a type signature
20:36:17 <dmwit_> > sequence [f, g, h] x :: [Expr]
20:36:19 <lambdabot>   [f x,g x,h x]
20:36:25 <Axman6> ah nice
20:36:28 <Axman6> how's that work?
20:36:41 <dmwit_> Reader monad.
20:36:51 <Axman6> :t sequence [f :: a -> b,g, h]
20:36:52 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
20:36:52 <lambdabot>       from the context ()
20:36:52 <lambdabot>       arising from a use of `f' at <interactive>:1:10
20:37:14 <mgarces> CakeProphet: now that im paying attention, just the last part is different from mine
20:37:25 <dmwit_> :t \(x :: a -> b) -> sequence [x]
20:37:27 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b'
20:37:27 <lambdabot>       unless the pattern has a rigid type context
20:37:27 <lambdabot>     In the pattern: x :: a -> b
20:37:32 <CakeProphet> mgarces:  how so?
20:37:38 <mgarces> let me past
20:38:00 <mgarces> addPoly (x:xs) (y:ys) = simplifyPoly ((x + y) : addPoly xs ys)
20:38:11 <mgarces> the simplyfyPoly just removes zeros from the right
20:38:29 <mgarces> i have the patterns corresponding to the empy cases
20:39:16 <mgarces> actually I don't have the [] [] = []
20:39:22 <CakeProphet> mgarces: that'll make a lot of useless calls to simplifyPoly.
20:39:43 <mgarces> true
20:39:45 <mgarces> =)
20:39:48 <CakeProphet> mgarces:  well... [] [] can be ommitted
20:39:57 <CakeProphet> as addPoly x [] = x
20:39:59 <CakeProphet> will do the same
20:40:25 <mgarces> i have to read better this "let" thing
20:40:41 <mgarces> i have just learned lambda expressions and sections
20:40:47 <Axman6> sections?
20:40:49 <mgarces> which are helping with what i have to do
20:40:55 <CakeProphet> Axman6:  (+4)
20:41:01 <Axman6> oh
20:41:05 <CakeProphet> mgarces:  try something like.
20:41:10 <Axman6> thought they were parially applied functions
20:41:32 <mgarces> CakeProphet: yes
20:41:32 <CakeProphet> addPoly = simplifyPoly.addPoly' where addPoly' = ...
20:41:52 <CakeProphet> and use my version of addPoly as the definition for addPoly'
20:42:03 <CakeProphet> that way it only calls simplifyPoly once
20:42:12 <mgarces> sweet
20:42:14 <mgarces> the cool thing
20:42:18 <mgarces> I can addapt it
20:42:24 <mgarces> to - and *
20:42:30 <CakeProphet> mgarces:  using operators is even sweeter.
20:42:43 <CakeProphet> mgarces:  imagine having something like <+> instead of addPoly. ;)
20:42:57 <CakeProphet> poly1 <+> poly2
20:43:06 <mgarces> that would be so sweet
20:43:11 <CakeProphet> ...it's also possible.
20:43:12 <pumpkin> or just make a Num instance of it
20:43:16 <ksf> (<+> poly2) poly1
20:43:17 <pumpkin> stretching the definition of Num somewhat
20:43:18 <CakeProphet> ..or that.
20:43:31 <CakeProphet> pumpkin:  it wouldn't the first instance that did that.
20:43:35 <mgarces> w8
20:43:41 <mgarces> (<+> poly2) poly1
20:43:46 <mgarces> ?
20:43:51 <ddarius> pointwise (#) = (simplyPoly .) . zipWith (#)
20:44:02 <ksf> ...just like (+1) 2
20:44:17 <ksf> ...but unlike (-1) 2 , that's a type error.
20:44:33 <ksf> (now I'm guilty of confusing people)
20:44:43 <ksf> :t (+1)
20:44:45 <lambdabot> forall a. (Num a) => a -> a
20:44:46 <mgarces> ksf: true =)
20:44:49 <ksf> :t (-1)
20:44:50 <lambdabot> forall a. (Num a) => a
20:45:09 <ksf> (-1) not being a section is a nasty corner of the haskell syntax.
20:45:15 <mgarces> :t (-)1
20:45:17 <lambdabot> forall t. (Num t) => t -> t
20:45:33 <ksf> that'd be flip (-) 1, then.
20:45:40 <rwbarton> > (-)1 x
20:45:41 <lambdabot>   1 - x
20:45:50 <ddarius> > subtract 1 x
20:45:51 <lambdabot>   x - 1
20:46:14 <mgarces> but I just can't call (<+> poly2) poly1.. I have to code this first
20:46:34 <ksf> :t (<+>)
20:46:36 <lambdabot>     Ambiguous occurrence `<+>'
20:46:36 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-33
20:46:36 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:55:0-46
20:46:41 <ksf> nope, you don't.
20:47:25 <rwbarton> :t (Control.Arrow.<+>)
20:47:27 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
20:47:48 <mgarces> when I do that in Hugs it says ERROR - Undefined variable "<+>"
20:48:46 <ksf> any random sequence of symbols is a haskell operator in 9 out of 10 cases.
20:49:09 <ksf> do import Control.Arrow or such.
20:49:14 <ozy`> guys, just so I'm clear on this...
20:49:15 <ozy`> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=958#a958
20:49:37 <mgarces> i don't know if I can use imports in my solutions
20:49:42 <ozy`> is that highlighted the same way it'll be parsed?
20:50:02 <ksf> you probably don't want to use arrows, either.
20:50:23 <mgarces> ksf: =)
20:50:55 <mgarces> ksf: in the future, when I know a little bit more.. for now I use what i can =)
20:51:02 <ksf> the comment like should be a comment.
20:52:19 <mgarces> i did a import Control.Arrow but it still does not like the <+>
20:52:22 <mgarces> nevermind
20:52:23 <mgarces> =)
20:52:57 <ozy`> ksf: yes but -why- is it a comment?
20:53:19 <ksf> literate haskell?
20:53:43 <ksf> or are you trying to comment out commenting out?
20:54:19 <ddarius> ozy`: There is only one reason since lines aren't allowed to juxtapose in Bird-style lhs.
20:54:32 <ozy`> ksf: working on a literate haskell syntax highlighter
20:54:41 <ozy`> ddarius: aha! okay, that helps a lot
20:55:36 <rwbarton> what happens if you close the -} on a line not starting with > ?
20:56:47 <ksf> it shouldn't close the comment... at least if it does the Right Thing
20:58:12 <mriou> I think I have another dumb question :)
20:58:27 <mriou> I have a monad transformer that stacks ErrorT, ReaderT and IO
20:59:00 <mriou> I want to use local in a function but the function I would need to pass would be (a -> IO a)
20:59:21 <ddarius> :t local
20:59:22 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
20:59:35 <mriou> I can use liftIO . on that but still I get (a -> m a) instead of (a -> a)
21:00:46 <ddarius> mriou: Won't ask >>= liftIO . f >>= local . const work?
21:03:33 <CakeProphet> so literate haskell supposed to be a way to turn a tutorial with example code into a working program?
21:03:41 <CakeProphet> +is
21:03:49 <CakeProphet> what other uses could it have?
21:04:18 <blackdog> it just changes the emphasis - you're trying to explain the problem to a person rather than a computer
21:04:21 <rwbarton> I think it's more a way to have a working program also be a document describing its design or use
21:04:22 <ddarius> It has other uses, but you may want to look up literate programming generally.
21:04:31 <mriou> ddarius: processing... :)
21:05:12 * ksf fails to see the sense of providing custom combinators to layout a gui
21:05:25 <ozy`> CakeProphet: a lot of blog posts these days start with "this post is a literate haskell program. copy the entire thing into a .lhs file and compile it."
21:05:56 <CakeProphet> ozy`:  I guess that's handy.
21:06:08 <mgarces> did not know Haskell had literate coding
21:06:12 <ksf> there's only one real operation, "now group those horizontally instead of vertically", anyway.
21:06:22 <mriou> ddarius: doesn't look like it works
21:06:22 * BMeph wonders what non-custom combinators could be used to layout a gui...unless that isn't ksf's point
21:06:26 <CakeProphet> hmmm... I'm in the mood to make a rubik's cube solver.
21:06:26 <ozy`> mgarces: duuuuuude, it's, like, THE literate programming language.... man
21:06:38 <mgarces> ozy`: really?
21:06:38 <CakeProphet> perhaps I should do some reading on how to make such an algorithm.
21:06:40 <ksf> explicit monad sequencing.
21:06:56 <mgarces> maybe im confused
21:07:23 <ksf> it really, really doesn't confuse me if do {b0 <- button; b1 <- button} shows b1 below b0.
21:07:26 <mriou> newLocal :: (MonadReader a m, MonadIO ((->) (m a1))) => (m a1 -> IO a) -> m a1 -> m a1
21:07:37 <mgarces> litterate coding, is when you process the file, and it outputs both code, and latex with documentation?
21:08:13 <mriou> should be ((a -> IO a) -> m b -> mb) I think
21:08:26 <ozy`> mgarces: it doesn't have to be documentation as such, and it doesn't have to be LaTeX
21:08:43 <mgarces> ok ok
21:09:08 <mgarces> you guys are far far away from what I know =)
21:09:23 <BMeph> ...and it doesn't have to be "processed" to be documentation. ;)
21:09:24 <CakeProphet> :t factors
21:09:26 <lambdabot> Not in scope: `factors'
21:09:30 <mgarces> got to eat a lot ot of code to get where you are
21:09:44 <mgarces> still a newbie
21:09:48 <mgarces> but a happy one =)
21:09:50 <mgarces> eh eh
21:10:05 <ksf> lambdas go well with lemon cake and tea.
21:10:15 <ddarius> mriou: The code is broken but the idea should be clear enough.
21:10:22 <CakeProphet> > (`mod` 5 == 0) 10
21:10:23 <lambdabot>       The operator `mod' [infixl 7] of a section
21:10:23 <lambdabot>          must have lower pre...
21:10:40 <CakeProphet> ah
21:10:47 <mriou> ddarius: I'm trying to get the idea :)
21:10:48 * ksf thinks a . is missing
21:11:22 <ozy`> mgarces: for you http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=958#a962
21:11:26 <ozy`> (the bottom one)
21:11:28 <ksf> > ((==0).(`mod`5))10
21:11:30 <lambdabot>   True
21:11:54 <ddarius> :t \f action ->  do env <- ask; newEnv <- f ask; local (const newEnv) action
21:11:55 <lambdabot> forall (t :: * -> *) (m :: * -> *) r r1 t1. (MonadReader r m, MonadReader r1 t) => (m r -> t r1) -> t t1 -> t t1
21:12:09 <ddarius> Oops
21:12:18 <ddarius> :t \f action ->  do env <- ask; newEnv <- liftIO . f =<< ask; local (const newEnv) action
21:12:19 <lambdabot> forall a (m :: * -> *) t. (MonadIO m, MonadReader a m) => (a -> IO a) -> m t -> m t
21:12:22 <mgarces> ozy`: =)
21:12:26 <ozy`> mgarces: by the way, if you haven't noticed, we're overloading the "> ..." notation for lambdabot. this entire channel is a giant literate haskell program ;)
21:13:03 <CakeProphet> > et factors x = 1 : (filter ((==0).(mod x)) [2..x `div` 2] ++ [x]) in factors 100
21:13:04 <lambdabot>   <no location info>: parse error on input `='
21:13:08 <CakeProphet> > let factors x = 1 : (filter ((==0).(mod x)) [2..x `div` 2] ++ [x]) in factors 100
21:13:09 <lambdabot>   [1,2,4,5,10,20,25,50,100]
21:13:31 <CakeProphet> @let factors x = 1 : (filter ((==0).(mod x)) [2..x `div` 2] ++ [x])
21:13:33 <lambdabot>  Defined.
21:13:36 <mgarces> sweet
21:13:40 * CakeProphet writes very elegant code.
21:14:05 <mgarces> :t notElem
21:14:07 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:14:09 <mgarces> ahahah
21:14:10 <mgarces> =)
21:14:13 <CakeProphet> @pl factors x = 1 : (filter ((==0).(mod x)) [2..x `div` 2] ++ [x])
21:14:13 <lambdabot> factors = (1 :) . ap ((++) . ap (filter . ((0 ==) .) . mod) (enumFromTo 2 . (`div` 2))) return
21:14:17 <CakeProphet> heh.
21:14:27 <CakeProphet> pl writes even more elegant code.
21:14:56 <mriou> ddarius: wow, thanks a lot
21:15:02 <mgarces> for sure I will return here to #haskell
21:15:05 <ksf>  @pl is the reason writing in pointless style isn't pointfree.
21:15:13 <mriou> I'm going to have to read that carefully, I'm not a composition ninja yet
21:15:31 <mgarces> you guys are very helpful, even with noobs like me
21:15:51 <ozy`> mgarces: we were all noobs once :p we know what it's like
21:16:16 <CakeProphet> > "mgarces, " ++ (stretch "<3" phi 1)
21:16:18 <lambdabot>   "mgarces,  <3  <3   <3    <3       <3           <3                  <3     ...
21:16:21 <mgarces> the shame is.. my University course wont have more Haskell, just 1 discipline
21:16:28 <ddarius> Oops no wonder my code was broken the first time
21:16:31 <hydrapheetz> > phi
21:16:32 <lambdabot>   1.618033988749895
21:16:35 <ddarius> :t \f action ->  do env <- ask; newEnv <- liftIO (f env); local (const newEnv) action
21:16:36 <lambdabot> forall (t :: * -> *) r t1. (MonadIO t, MonadReader r t) => (r -> IO r) -> t t1 -> t t1
21:16:37 <hydrapheetz> Huh
21:16:43 <mgarces> >pi
21:16:46 <hydrapheetz> :t stretch
21:16:47 <lambdabot> forall a. (RealFrac a) => [Char] -> a -> a -> [Char]
21:16:47 <CakeProphet> hydrapheetz:  not in any library. I defined that beforehand
21:16:51 <hydrapheetz> Oh
21:17:03 <CakeProphet> hydrapheetz:  phi = (1 + sqrt 5) / 2
21:17:16 <hydrapheetz> > stretch ":D" phi 1
21:17:17 <lambdabot>   " :D  :D   :D    :D       :D           :D                  :D              ...
21:17:29 <mgarces> eh eh
21:17:31 <mgarces> this is fun
21:17:59 <ozy`> (mgarces, don't forget the space after the >)
21:18:02 <ozy`> >pi
21:18:06 <mriou> ddarius: perfect
21:18:07 <ozy`> > pi
21:18:09 <lambdabot>   3.141592653589793
21:18:15 <CakeProphet> > text $ cstretch "heeeelp" phi 1
21:18:17 <mgarces> > pi
21:18:19 * ozy` imagines lambdabot singing the pi song
21:18:20 <lambdabot>   3.141592653589793
21:18:26 <mgarces> hah! cool
21:18:31 <lambdabot>   thread killed
21:18:33 <CakeProphet> > cstretch "heeeelp" phi 1
21:18:40 <CakeProphet> ...it dies?
21:18:42 <lambdabot>   "h e  e   e    e       l           p                  h                    ...
21:18:44 <CakeProphet> oh
21:18:48 <hydrapheetz> > stretch "Oooh" 0.001 0.00000000001
21:18:49 <lambdabot>   "OoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOoohOo...
21:18:58 <CakeProphet> ...
21:19:07 <hydrapheetz> Spoooooky~
21:19:14 <CakeProphet> well
21:19:30 <dmwit_> http://www.youtube.com/watch?v=UP19xs9K77Y
21:19:34 <mgarces> can we do :l here? like with a remote URL?
21:19:47 <CakeProphet> hydrapheetz, the first thing is a symbol to repeat, the second is a ratio to expand the spaces at, and the third is a base number.
21:19:51 <dmwit_> mgarces: nope
21:19:55 <mgarces> ohh
21:19:56 <mgarces> =)
21:20:01 <hydrapheetz> Oh.
21:20:09 <CakeProphet> hydrapheetz:  cstretch is the same but it cycles through the characters in the string
21:20:22 <CakeProphet> phi is just a pleasing ratio to use.
21:20:42 <hydrapheetz> Yeah, makes it seem like it's just trailing off
21:20:46 <redditbot> A world without (class) orphans
21:21:03 <CakeProphet> hydrapheetz: you've heard of the golden ratio right?
21:21:06 <ozy`> > stretch "AAAGH" pi 1
21:21:07 <dmwit_> The magic starts at 1:18...
21:21:07 <lambdabot>   " AAAGH   AAAGH          AAAGH                               AAAGH         ...
21:21:08 <hydrapheetz> Er, no
21:21:09 <mgarces> just for curiosity... what do you use to code in Haskell
21:21:20 <dmwit_> mgarces: vim
21:21:26 <mgarces> me 2
21:21:39 <mgarces> got a syntax somewhere
21:21:41 <hydrapheetz> mgarces: vim
21:22:17 <noZone> mgarces: ed
21:22:18 * ksf is a real coder and uses head, tail, cat and pipe bending
21:22:19 <CakeProphet> hydrapheetz:  http://en.wikipedia.org/wiki/Golden_ratio   ...there's a reason it looks like it's trailing off.
21:23:20 <ddarius> dmwit_: Was that intended to have educational value?
21:23:34 <ksf> nothing fancy like 4,5c or stuff.
21:23:34 <dmwit_> I'm not sure.
21:23:42 <hydrapheetz> Neat.
21:23:47 <dmwit_> threeeee point one four one five nine
21:23:52 <CakeProphet> @let areGolden a b = (a + b) / a == a / b
21:23:57 <lambdabot>  Defined.
21:24:04 <CakeProphet> > areGolden 1 (1 * phi)
21:24:05 <lambdabot>   False
21:24:07 <CakeProphet> ...
21:24:13 <hydrapheetz> I still don't know much about Haskell, so
21:24:44 <ozy`> CakeProphet: standard issue floating point rounding error
21:24:57 <ozy`> CakeProphet: try using delta values instead
21:25:05 <CakeProphet> ozy`:  never heard of them.
21:25:42 <ozy`> CakeProphet: closeEnough delta a b = (a - b) < delta
21:25:49 <mgarces> oh by the way... any good book you might recommend? I'm reading Hutton's and learnyouahaskell.com
21:25:58 <noZone> ed has a very uniform error message system. All errors produce "?", and nothing else.
21:26:03 <dmwit_> mgarces: RWH, I linked to it above
21:26:09 <dmwit_> ?where RWH
21:26:09 <lambdabot> is http://www.realworldhaskell.org/blog/
21:26:10 <dolio> Did somebody say pie?!
21:26:18 <CakeProphet> > areGolden 1 (1 * phi :: CReal)
21:26:19 <lambdabot>   False
21:26:22 <dmwit_> dolio: No, Steve!
21:26:22 <CakeProphet> :(
21:26:45 <ztirf_> is there a reason for using Data.Array.CArray vs the regular StorableArray?
21:26:50 <pumpkin> :t reads
21:26:51 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:26:53 <dmwit_> Awesome, just the song: pi.ytmnd.com
21:27:02 <mgarces> ah cool, oreilly, I like it!
21:27:20 <BMeph>  > areGolden (1 * phi) 1
21:27:31 <BMeph> > areGolden (1 * phi) 1
21:27:33 <lambdabot>   True
21:27:35 <dmwit_> ztirf_: Pinned memory is nice for FFI stuff.
21:27:42 <BMeph> ?bo
21:27:42 <lambdabot> :)
21:27:51 <mgarces> 40 €.. ouch
21:27:59 <Axman6> mgarces: for RWH?
21:28:02 <dmwit_> mgarces: It's also available online for free.
21:28:06 <mgarces> it is?
21:28:16 <mgarces> =)
21:28:22 <mgarces> ah
21:28:22 <dmwit_> http://book.realworldhaskell.org
21:28:28 <mgarces> I have this tab already
21:28:28 <mgarces> lol
21:28:38 <ztirf_> dmwit_: how can you have something storable that's not pinned?
21:28:53 <mgarces> this is cool, I can follow some projects and learn by doing
21:29:21 <dmwit_> ztirf_: Oh, sorry, I looked up CArray but not StorableArray.
21:29:41 <lament> the functional approach to side effects: Learn by Not Doing
21:30:02 <mgarces> gotta convince a mathematician friend of mine to learn Haskell.. i think he will love it!
21:30:07 <sjanssen> ztirf_: I think the main differences are the support for multi-dimensional C arrays
21:30:42 <noZone> lament: is that lamentable?
21:30:49 <sjanssen> ztirf_: oh, and there's one huge difference
21:31:19 <sjanssen> ztirf_: StorableArray uses MArray (is mutable), CArray uses IArray (is immutable)
21:32:05 <ztirf_> sjanssen: ah, I see
21:32:58 <pumpkin> do automatic derivations that don't get used count against me in HPC?
21:33:07 <pumpkin> they're highlighted in yellow
21:33:20 <pumpkin> but do they count against me once each, or as many times as the methods they derive?
21:33:43 <ztirf_> alright, time to put my partial sums routine written in C into my code
21:33:53 <ztirf_> hope this fixes my performance problem
21:34:08 <sjanssen> pumpkin: I would imagine just once
21:34:14 <sjanssen> but it is an interesting question
21:34:31 <pumpkin> sjanssen: because it's giving me 13 missing top-level definitions
21:34:38 <pumpkin> but there are only 7 yellow patches in the source
21:35:26 <Axman6> anyone here using TextMate?
21:35:46 <pumpkin> yup
21:35:53 <pumpkin> and yes the indentation is fucking annoying
21:36:28 <Axman6> well ozy` has been wprking on new syntax highlighting, which looks a lot better than it used to
21:36:30 <ozy`> pumpkin: never mind the indentation, we'll get to that later
21:36:31 <sjanssen> pumpkin: I guess it must depend on how GHC compiles those (and I'm not sure how it does)
21:36:42 <Axman6> should be comitted sometime soonish
21:36:44 <pumpkin> ozy`: ooh
21:36:53 <pumpkin> awesome :)
21:37:38 <ozy`> pumpkin: http://www.rsmw.net/ergo/Haskell.plist <== paste it into the bundle editor
21:37:50 <ozy`> it's not exactly perfect but it's a step up
21:37:50 <pumpkin> sweet, thanks, I'll try that in a sec
21:39:21 <Axman6> pumpkin: it's not up yet afaik
21:39:42 <ozy`> Axman6: well, the patch isn't in the repository, but he can still "apply" it by hand :p
21:39:49 <Axman6> heh, yeah
21:39:57 <Axman6> though if he does, later updates won't show up...
21:40:20 <ozy`> easy enough to fix... just nuke the local copy of the haskell bundle
21:41:10 * pumpkin is murdering those little yellow patches one by one
21:42:45 <bos> @seen dons
21:42:45 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 2h 28m 6s ago.
21:43:00 <bos> pumpkin: you've been using uvector a lot, right?
21:43:15 <pumpkin> bos: yes, and I've been working on it for the past couple of days too :)
21:43:24 <bos> oh, interesting.
21:43:30 <pumpkin> got the test HPC coverage up to 83% now
21:43:40 <pumpkin> and fixed a couple of bugs I found along the way
21:43:41 <pumpkin> why?
21:44:06 <bos> i haven't really touched it, but i want to use it. what's the appropriate module to use for UArray-like access?
21:44:14 <mgarces> everyone: goodbye!! I'm going to bed! (5:44 AM)
21:44:28 <mgarces> cya soon! tanx for your help
21:44:32 <bos> pumpkin: is it just UArr?
21:44:36 <mgarces> happy coding
21:44:46 <pumpkin> bos: yeah, it has many list-like functions defined on it
21:44:59 <pumpkin> bos: I submitted a patch to dons that filled in most of the documentation
21:45:08 <pumpkin> but I doubt he's looked at it yet
21:45:13 <bos> pumpkin: sweet
21:45:38 <pumpkin> the main thing to be careful of when using it is that some functions will happily run over the memory they own
21:45:49 <pumpkin> even when not marked as unsafe
21:46:06 <bos> they will?
21:46:13 <bos> they don't do bounds checking?
21:46:25 <pumpkin> a few of them do, but only if the safe flag is enabled during compilation
21:46:32 <pumpkin> others overrun their bounds even with safe on
21:46:53 <bos> zomg
21:46:59 <pumpkin> so zipU is O(1), but will zip together two mismatched arrays
21:47:11 <bos> yoicks!
21:47:19 <pumpkin> lengthU will catch the mismatch on the product if you call it later on it
21:47:19 <bos> that seems, how do you say in english, bad.
21:47:33 <pumpkin> but if you mapU over the product, it'll run over the end of the second one
21:47:36 <pumpkin> yeah, probably :)
21:48:03 <pumpkin> I'd think that the goal is to make it not do anything bad when the safe flag is turned on, but if you turn it off, to let it be bad
21:48:14 <pumpkin> I haven't really spoken to dons about it though, so I don't know what his plans are
21:48:42 <ozy`> pumpkin: I'm taking off. PM me if you notice anything that should really be fixed
21:48:51 <pumpkin> ozy`: thanks, haven't put it in yet
21:48:54 <pumpkin> but I will soon
21:49:04 * ozy` salutes
21:49:31 <pumpkin> ciao :)
21:49:54 <Axman6> cya ozy`
21:51:55 <bos> does hugs support rank-2 types? i guess it must, if it has ST monad support.
21:53:13 * ksf just thought of using FixT ErrorT ReaderT IO and is pledging temporary insanity
21:53:20 <ddarius> bos: Yes, it does.
21:54:05 <bos> hmm, uvector uses GADTs. that means it won't run under hugs.
21:54:32 <ztirf_> is it safe to unsafePerformIO something that calls newArray ?
21:54:52 <BMeph> NOOOOOOOOOOOOOOOOOOOOOOOOOOOO!
21:55:25 <Axman6> heh
21:55:39 <Axman6> ztirf_: if you do, you'll get the exact same array back every time
21:55:41 <Axman6> i think
21:55:47 <bos> not necessarily.
21:55:55 <ztirf_> good to know, my little test program got away with it
21:56:10 <BMeph> 60% of the time, it works...every time. ;p
21:56:19 <dolio> uvector uses GADTs?
21:56:25 <bos> but it's not a wildly great idea, certainly without any additional context.
21:56:30 <bos> dolio: yeah.
21:57:44 <inv> hi all
21:57:47 <bos> actually, that might be a fib in the documentation. it appears to use associated types, not GADTs.
21:57:50 <pumpkin> I thought it used associated types
21:57:57 <inv> lambdabot: @newpaste
21:57:58 <lambdabot> Unknown command, try @list
21:58:02 <bos> so the comments are wrong.
21:58:03 <dolio> Yes, it uses associated data.
21:58:09 <dolio> I don't think it uses GADTs.
21:58:23 <pumpkin> I still don't think it'll run on hugs though
21:58:41 <bos> it definitely won't be accepted by hugs, no matter which of those two.
21:59:06 <ksf> A Jedi just came along and said "FixT is not what you're looking for. You may get back to your code"
21:59:19 <bos> i want a portable unlifted vector type that isn't as froofy as UArray.
21:59:34 <inv> could you help with the tail-rec again? I'm tired of this questions: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=964#a964
21:59:56 <inv> it's a tail-rec function, but it's raises stack overflow again
22:00:02 <inv> it raises
22:00:28 <inv> just changed a bit, and it doesn't work
22:00:32 <glguy> inv, your love for extra parentheses is making this hard to understand :)
22:00:34 <dolio> Froofy?
22:00:53 <bos> UArray has all that silliness with parameterised array indices.
22:01:02 <bos> everyone knows a vector starts at 0, and ends at k-1.
22:01:09 <inv> glguy: it didn't work without $!
22:01:15 <dolio> Yeah.
22:01:19 <bos> and that it's indexed with good old meat-eating Ints.
22:01:19 <inv> I don't like it too
22:01:45 <glguy> I mean in more places than $1
22:01:47 <glguy> !
22:01:55 <ddarius> bos: What if I want Bool indexed arrays?
22:02:04 <dolio> Should be indexed with Words, really, no?
22:02:10 <glguy> anyway, I didn't intend for that to become the topic :)
22:02:35 <bos> ddarius: then have your effete UArray and live with its inefficiency :-)
22:02:48 <glguy> inv, The fields are the "P" constructor are not strict
22:02:56 <glguy> so using $! really isn't that interesting on it
22:03:05 <ddarius> bos: Actually, I think Bool indexed arrays (or some other small element type) might be useful to be coded down to SIMD instructions.
22:03:24 <inv> glguy : but I have a $! before P
22:03:35 <glguy> inv, which only strictifies the constructor
22:03:39 <bos> ddarius: hmm.
22:03:41 <shapr> foo
22:03:42 <glguy> and not the data contained within
22:03:55 <inv> should I do it before every little expression ?
22:03:57 <ddarius> shapr: Shouldn't you be sleeping?
22:04:03 <shapr> ddarius: er, yeah, I'll get right on that
22:04:06 <glguy> inv, you can add strictness annotations to the data type definition
22:04:21 <glguy> Int -> !Int
22:04:22 <glguy> for example
22:04:29 <dmwit> inv: Does that even type-check?
22:04:30 <glguy> if you want that use of $! to work
22:04:38 <dmwit> Oh, p_r1, not p
22:04:43 <dmwit> Your names are terrible. =P
22:04:54 <inv> dmwit: ?
22:05:29 <inv> ow, it's just a maket now
22:05:40 <inv> parse_repear_1ormore
22:05:40 <glguy> dmwit, he is testing his code obfuscator I think
22:05:43 <rwbarton> inv: your code is unreadable, but I suspect adding the strictness annotation on the P data type and deleting all the $! will help
22:05:46 <inv> p = parse
22:05:52 <glguy> but it introduced a laziness problem :)
22:06:53 <sjanssen> @keal
22:06:53 <lambdabot> evaluating expressions is ALL haskell does?????
22:07:13 <inv> re
22:07:27 <inv> data P = P !Int !S | N
22:07:54 <inv> data S = Sc !Char | Ss ![Char]
22:07:54 <inv> it did not help
22:08:08 <inv> ERROR - C stack overflow
22:08:19 <ztirf_> does unsafePerformIO work with seq?
22:08:59 <ztirf_> like, can I do (unsafePerformIO <does something to "arr">) seq (pure function on arr)
22:09:53 <Axman6> ztirf_: unsafePerformIO is there for FFI stuff, pretty much exclusively. if you're using it for other things, you probably shouldn't be
22:10:14 <ztirf_> I have a small C routine that calculates partial sums of an array
22:10:27 <ztirf_> I want to get that into a pure function without everything living in IO
22:11:01 <Axman6> is the C function pure?
22:11:20 <jeffd> > 40e3/5
22:11:22 <lambdabot>   8000.0
22:11:37 <ztirf_> yes, but it needs someplace to store its result, so I pass it two arrays, one for input and one for output
22:11:43 <jeffd> > 5/40e3
22:11:45 <lambdabot>   1.25e-4
22:11:53 <rwbarton> inv: I think there's a (((...++[c])++[c])++[c])++[c] thunk buildup
22:11:54 <ztirf_> I want to make sure the computation is performed before I use the output array for something
22:12:23 <Axman6> oh no, that's the worst kind of thunk!
22:12:40 <inv> rwbarton: I'm forcing it
22:13:10 <rwbarton> inv: At most you're forcing the head
22:14:24 <Axman6> ztirf_: check out http://blog.bjrn.se/2008/09/speeding-up-haskell-with-c-very-short.html, it may help you
22:15:19 <sbahra> :t map
22:15:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:15:23 <sbahra> ah
22:15:26 <rwbarton> inv: Even if you are forcing it, that construction will take quadratic time
22:15:30 <ztirf_> Axman6 that's awesome
22:15:31 <sbahra> forall .. ..
22:15:33 <ztirf_> thanks!
22:15:39 <Axman6> no worries :)
22:16:23 <pumpkin> sbahra: ?
22:16:58 <inv> rwbarton: ok: p_r1 Tdigit s (P 0 $ Ss "") (\(Sc c) (Ss s) -> Ss (c:s))
22:17:43 <sbahra> pumpkin, bored :)
22:17:49 <sbahra> pumpkin, fixing some things to look similar to that
22:17:53 <pumpkin> ah
22:17:53 <sbahra> *FOL> Universal P (Universal Q (In (p --> q)))
22:17:53 <sbahra> forall p. forall q. (p --> q)
22:18:08 <inv> it works with c:s, but why it doesn't work with s++[c] ?
22:18:16 <inv> I'm forcing it too
22:18:32 <inv> ((p_r1 t $! (drop i s)) $! (P (((+) $! i) $! i2) $! ((f $! a) $! b))) $! f
22:18:41 <rwbarton> oh god
22:18:43 <inv> I can't do more forcing :)
22:18:54 <rwbarton> you shouldn't need *any* $!
22:19:03 <inv> what can I do with it ?
22:19:13 <rwbarton> also, ... $! f??
22:19:28 <rwbarton> step 1, remove all $!
22:19:36 <inv> ok, just a moment
22:20:29 <hackage> Uploaded to hackage: chalmers-lava2000 1.0.2
22:20:38 <inv> rwbarton: p_r1 t (drop i s) (P (i+i2) $ f a b) f
22:20:58 <inv> done
22:21:58 <rwbarton> perfect, now, you probably want the strictness flag just on the Int, and to make sure f isn't doing something silly
22:22:45 <inv> f = (\(Sc c) (Ss s) -> Ss (c:s))
22:23:01 <Cale> inv: With regard to s ++ [c], you should be aware that xs ++ ys takes O(length xs) steps to evaluate.
22:23:19 <inv> Cale: I know, but it should work too
22:23:26 <inv> I'll remove it later
22:23:43 <inv> rwbarton: flag to int ?
22:23:44 <rwbarton> inv: right, that version is fine, because to consume each element of the result, you only have to evaluate a single (:) application
22:24:21 <rwbarton> inv: either define data P = P !Int S | N, or write ((P $! (i+i2)) $ f a b)
22:24:45 <inv> rwbarton: it was where
22:24:49 <rwbarton> inv: whereas to consume a single element of the result of the s ++ [c] one, you have to go through the entire chain of (++) at once
22:24:52 <dolio> > foldl (++) [] $ replicate 1000000 [1]
22:24:54 <lambdabot>   * Exception: stack overflow
22:25:01 <dolio> > foldl' (++) [] $ replicate 1000000 [1]
22:25:02 <lambdabot>   [1* Exception: stack overflow
22:25:24 <inv> rwbarton: data P = P !Int S | N
22:25:32 <sbahra> > foldr (++) [] $ replicate 1000000 [1]
22:25:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:25:39 <inv> P 100000 ERROR - C stack overflow
22:25:54 <rwbarton> inv: I have no idea what code you're running at this poin
22:25:54 <rwbarton> t
22:26:07 <inv> rwbarton: I'll paste, just a moment
22:26:24 * BMeph hums the words to the song "UR Doin' It Rong"...
22:26:39 <inv> rwbarton: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=964#a965
22:26:47 <sbahra> Is there a name for PL formulas that do not make use of conditionals?
22:27:10 <pumpkin> let combine f xs ys = reverse . snd $ foldl (\((xs, ys), acc) a -> if a then ((tail xs, ys), (head xs):acc) else ((xs, tail ys), (head ys):acc)) ((xs, ys), []) f in combine [False, True, False] [1] [2,3]
22:27:15 <pumpkin> > let combine f xs ys = reverse . snd $ foldl (\((xs, ys), acc) a -> if a then ((tail xs, ys), (head xs):acc) else ((xs, tail ys), (head ys):acc)) ((xs, ys), []) f in combine [False, True, False] [1] [2,3]
22:27:16 <lambdabot>   [2,1,3]
22:27:19 * geezusfreeek plays with happs due to being reminded of it by happstack
22:27:20 <ddarius> sbahra: PL == propositional logic and conditionals == implication ?
22:27:23 <sbahra> "Normal form" seems reasonable.
22:27:26 <sbahra> ddarius, yes.
22:27:26 <pumpkin> is there a more elegant way to do that?
22:27:42 <pumpkin> I guess it's a bit of a stretch to try to use foldl for that
22:28:27 <blazzy> I have a source file with a main function. I want to compile and run this file. But I also want to play with the functions it defines in ghci. Is there a way to do this without making it a module and moving the main function to a separate file?
22:28:36 <ddarius> inv: You want 'i2) $! f'
22:28:45 <sbahra> ddarius, any ideas?
22:28:50 <sbahra> I just guessed "normal form".
22:29:07 <ddarius> sbahra: Well the various normal forms would work, but you could have expressions not in those normal forms that don't use implication.
22:29:09 <sbahra> Because all "normal forms" I know of seem to only make use of /\, \/ and ~.
22:29:20 <sbahra> ddarius, yes, of course.
22:29:22 <ztirf_> blazzy: can't you just load the whole thing in ghci?
22:29:35 <inv> I'm sorry
22:29:35 <ddarius> sbahra: I'd probably just call it "implication free"
22:29:46 <inv> could you repeat, plz
22:29:48 <inv> ?
22:30:11 <blazzy> ztirf_: I can, but ghci loads it as module Main and I can't seem to access any of the functions in the file.
22:30:30 <sbahra> ddarius, yes, that's better.
22:31:17 <rwbarton> inv: you're building up a value by repeatedly applying f that you never inspect during your loop
22:31:20 <Axman6> blazzy: you should be able to...
22:31:29 <Axman6> blazzy: try :r
22:32:13 <rwbarton> inv: so you need P to be strict in the S field also, or just use the type system sensibly and drop the whole S = Sc Char | Ss String thing.
22:32:21 <inv> rwbarton: yes, but I don't need to inspect it
22:32:25 <BMeph> blazzy: Have you considered making it a module, but *not* moving the main function to a separate file? ;)
22:32:29 <inv> I just want to calculate it
22:33:03 <inv> is it anought? data P = P !Int !S | N
22:33:12 <Axman6> anought?
22:33:12 <ddarius> That should also work.
22:33:50 <inv> enough - sorry
22:34:00 <inv> yes, it works
22:34:28 <blazzy> Axman6: wow, damn. it suddenly seems to be working. what idiotic thing did I do to think it didn't work..
22:34:44 <Axman6> i think i've run into that before too
22:34:48 <inv> and if I changed c:s to s++[c]
22:35:04 <inv> I know that it would be better to reverse after p_r1
22:35:22 <rwbarton> s++[c] has bigger problems than the stack overflow
22:35:35 <inv> but why s++[c] doesnot work? should I force inside f too ?
22:36:01 <rwbarton> inv: forget about stack overflow for a moment and figure out how much computation the s++[c] version has to do
22:36:12 <blazzy> BMeph: Can I do that and still have it compile to an executable? It ususally can't find the Main function
22:36:21 <blazzy> oh wait, I could probaby define it as module main
22:36:47 <inv> rwbarton: I know, but I just want to understand where is the problem
22:37:00 <inv> f = (\(Sc c) (Ss s) -> Ss $! (((++) $! s) $! [c]))
22:37:02 <inv> didn't help
22:37:36 <rwbarton> you understand that seq on a list only forces to a topmost (:) or [] constructor, right?
22:38:05 <rwbarton> > (undefined : undefined) `seq` 283
22:38:07 <lambdabot>   283
22:38:18 <BMeph> inv: How about changing "p Tdigit (c:cs) =" to "p Tdigit (c:_) =" ? I'm just curious if it does anything for you. :)
22:38:20 <inv> but if I force where iteration of : ?
22:39:12 <inv> BMeph: I'll do it, of course
22:39:31 <inv>  but if I force every iteration of : ?
22:41:04 <inv> I'm sure it's possible to calculate r in p_r1 iteration too
22:41:04 <rwbarton> Yes, you could do it, and it should "fix" the problem, but it's still very slow
22:41:34 <inv> ok, I'll change it. I just want to understand, how could I fix it ?
22:41:59 <inv> I'd like to force c:s later too
22:42:30 <rwbarton> you don't ever need to force c:s
22:42:41 <rwbarton> it is visibly /= _|_
22:43:39 <inv> ok, I have an answer, I'll just reverse string after p_r1
22:43:48 <rwbarton> I think if you really wanted to you could write something awful like \(Sc c) (Ss s) -> let x = s ++ [c] in length x `seq` Ss x
22:48:20 <Axman6> inv: are you working with FFI stuff?
22:48:38 <inv> thank you very much, it works! I don't know why $! didn't forced it, but now it's find. and I'm removing this s++[c] i don't need it anymore
22:49:28 <inv> Axman6: not now, it's just an another version of the parse for the language which we are developing, it has FFI :)
22:49:47 <Axman6> righto
22:51:06 <rwbarton> inv: the reason $! didn't solve the problem when you were using s++[c] is that seq only forces the topmost constructor of a list, not the whole thing
22:51:40 <inv> hm, I see it now, thank you.
22:52:23 <pumpkin> you can use rnf if you want to force it all
22:52:29 <pumpkin> but in most cases you shouldn't need to
22:52:52 <inv> lambdabot: @rnf
22:52:53 <lambdabot> Maybe you meant: bf rc run unpf wn
22:53:04 <Axman6> also, if you're using ++ [x], you're probably doing it wrong, or using the wrong datatype
22:53:17 <Axman6> @help unpf
22:53:18 <lambdabot> pointful <expr>. Make code pointier.
22:53:25 <inv> Axman6: I have removed this ++[x]
22:53:28 <pumpkin> a Sequence might be better if you're appending a single element onto the end at a time
22:53:30 <Axman6> good :)
22:54:15 <pumpkin> now to track down the cases in which my tests crash the library
22:54:55 <pumpkin> I'm really loving hpc
22:55:44 <max_> @unpf (.)
22:55:45 <lambdabot> (\ a b c -> a (b c))
22:55:53 <max_> @unpf (.) (.)
22:55:54 <lambdabot> (\ b c e f -> b c (e f))
22:56:00 <max_> @unpf (.) . (.)
22:56:00 <lambdabot> (\ i b c f -> i (b c f))
22:56:39 <pumpkin> @seen dons
22:56:39 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 3h 42m ago.
22:58:57 * BMeph needs to get a T-shirt that just says, "You're doing it wrong!" :)
23:11:11 <pumpkin> hmm, I have an odd bug
23:14:53 <ivanm> pumpkin: well, since you're not in your monadic form it mustn't be a side-effect...
23:14:54 <ivanm> ;-)
23:15:00 <pumpkin> lol
23:16:06 <ivanm> BMeph: with that tee-shirt, should it be something like: "You're doing _____ wrong!" ;-)
23:16:37 <nikki93> Hallooo!
23:19:16 <pumpkin> bah, what the hell is its problem
23:21:35 <pumpkin> ah well, it'll have to wait until tomorrow
23:27:26 <djyoung4> http://ihateliz.com/?id=2v6e5z71xo5qvolx8v5v0edkdlbg3d go there
23:27:57 <pumpkin> djyoung4: just google for the pics and you'll find them without being a puppet to the grubby a-hole who made that site
23:28:09 <djyoung4> thanks
23:28:55 <mauke> this channel is entirely too nice
23:29:28 <pumpkin> whoever came up with that idea for porn sites was a genius btw
23:29:38 <ivanm> mauke: do we need some hate here?
23:29:46 <ivanm> pumpkin: was that a porn spammer?
23:29:50 <pumpkin> the "I hate my ex gf so I'll post pics of her getting progressively more naked the more clicks you drive to my site"
23:29:56 <ivanm> ahhh
23:29:59 <pumpkin> and people buy the story
23:30:03 <pumpkin> and advertise their site for free
23:30:05 <pumpkin> it's genius :P
23:30:13 <mauke> people are stupid
23:30:25 <ivanm> mauke: isn't that skynet will eventually take over?
23:30:27 <pumpkin> and horny
23:30:56 <ivanm> does stupid imply gullible?
23:31:49 <lamente> ivanm: sure, easier to convicnce with fallacious arguments
23:31:58 <ivanm> lamente: *nod*
23:32:23 * ivanm proposes a Stupidity monad, to trap the stupid users into
23:32:24 <lamente> (e.g. if you just fell for my argument, you're stupid) :P
23:32:24 <BMeph> "plausible deniability" comes to mind.
23:32:25 <ivanm> :p
23:32:37 <ivanm> lamente: heh
23:32:50 <ivanm> lamente: I thought you meant it as a joke in the first place ;-)
23:33:15 <lamente> i prefer paradoxes to jokes
23:34:07 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/paradox.jpg
23:34:50 <ivanm> mauke: *groan*
23:35:45 <Botje> rofl :)
23:35:54 <Botje> mauke++ # you're a scotsman!
23:36:25 <pumpkin> lol
23:36:55 <idnar> hahaha
23:39:24 <nikki93> YES! I FOUND IT!
23:39:28 <nikki93> Dropbox is what I'm looking for!
23:39:29 <pumpkin> ?
23:39:31 <pumpkin> lol
23:39:34 <nikki93> There's no need for nautilus!
23:39:35 <nikki93> :D
23:39:58 <nikki93> I thought it needed nautilus but it doesn't.
23:40:16 <Botje> doesn't it use FUSE? :)
23:40:39 <pumpkin> there's gotta be a better way to choose what chunks to include in a patch in darcs than going through each of them and saying yes/no
23:41:07 <ivanm> pumpkin: better? in what way?
23:41:14 <ivanm> how do you choose without choosing?
23:41:16 <Botje> you can select files to darcs rec
23:41:24 <Botje> but apart from that: commit more often :)
23:41:27 <pumpkin> lol
23:41:30 <pumpkin> good point
23:41:49 <pumpkin> Shall I record this change? (1/76)  [ynWsfvpxdaqjk], or ? for help:
23:42:04 <Botje> that's not too bad
23:42:12 <pumpkin> my previous one had 200ish
23:42:18 <pumpkin> but I just sad a
23:42:18 <Botje> you can select a whole file with f, you know
23:42:28 <pumpkin> ah, that's handy
23:42:37 <pumpkin> but something like this is begging for a GUI :P
23:42:43 <Botje> not really :)
23:42:48 <__void__> hi, someone can suggest my a real life example of a simple haskell program to dissect it while i'm learning? xmonad is difficult to start with :)
23:42:50 * ivanm also disagrees
23:42:59 <ivanm> but IIRC, someone did a darcs version of that toirtoise app
23:43:10 <Botje> __void__: what are you looking for, exactly?
23:43:29 <Botje> there's a ton of blog posts on planet haskell
23:43:38 <ivanm> __void__: how real life does it have to be?
23:43:38 <Botje> most of them have code
23:43:44 <ivanm> maybe the various sudoku puzzles or something?
23:43:51 <ivanm> since they're generally only a module or two
23:43:54 <Botje> there's also real world haskell :)
23:44:00 <__void__> hehe
23:44:14 <__void__> i was looking for something actually useful ;)
23:44:37 <ivanm> you expect software to be _useful_?
23:44:52 <__void__> i've a non-functional programing background, so my head is not yet set for functional programming thinking
23:45:04 <ivanm> __void__: in case you weren't aware, the entire computing industry is one big hoax set up to get real people think that nerds are useful/helpful ;-)
23:45:25 <__void__> i've to learn new ways to do things and by looking at some examples i can figure out things
23:45:29 <__void__> ivanm: lol
23:45:31 <duryodhan> hi can someone explain transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss]) to me
23:45:42 <jeffz`> __void__: are you following a tutorial?
23:45:57 <ivanm> duryodhan: OK, so are you aware how list comprehension works?
23:46:07 <duryodhan> ivanm: comprehension?
23:46:12 <__void__> jeffz`: yup, a gentle introduction to haskell, and have read some of the wikibook
23:46:15 <duryodhan> :)
23:46:19 <bastl> void: real world haskell is your book. it shows you how to get things done, and by the way explains the language (better than most other books)
23:46:20 <ivanm> duryodhan: OK, lets start from the beginning...
23:46:28 <jeffz`> __void__: you might also try http://learnyouahaskell.com
23:46:43 <__void__> bastl: the thing is ... haskell is very strange when it comes to IO and such things
23:46:57 <__void__> and interfacing with real world ugly programs (non funcional)
23:47:05 <bastl> yep, and RWH teaches it without any hassle
23:47:06 <ivanm> duryodhan: " transpose ((x:xs) : xss) " <-- define a function called transpose, which takes in a list whose first argument is (x:xs) [which in itself is a list with a first element of x, and the rest xs] and the rest called xs
23:47:13 <duryodhan> yaeh
23:47:36 <ivanm> duryodhan: we can think of stating that the first element of the first row is x, the rest of the first row is xs and the rest of the rows are xss
23:47:43 <duryodhan> ivanm: I just didn't get how it will work .. in teh sense that it will give wrong solution
23:47:55 <ivanm> duryodhan: ahhh
23:47:58 <__void__> bastl: perfect, i'll look for it, thanks
23:48:01 <duryodhan> ivanm: if by comprehension you meant "x:xs" and xss what they stand for .. I know that
23:48:15 <duryodhan> ivanm: what does the h:t stand for ? head and tail right ?
23:48:17 <ivanm> duryodhan: no, the list comprehension is the [ h | ... ] stuff
23:48:32 <duryodhan> ivanm: yeah .. thats what I don't know
23:48:35 <__void__> what's the piece of software you must use besides darcs and xmonad (and your code) that's written in haskell?
23:48:36 <ivanm> duryodhan: they're just variables, but in this case yes, they're the head and tail of the deconstructed list
23:48:43 <ivanm> __void__: ghc
23:48:43 <ivanm> ;-)
23:48:50 <bastl> :-)
23:49:35 <duryodhan> ergo .. wouldn't the first list in the return value (a list of lists) be just two element long?
23:49:48 <duryodhan> ivanm: ohh got it
23:49:50 <ivanm> duryodhan: OK, so a list comprehension is of the form [ "do something with x" | "each x" <- "from the list xs", "constraint on x", "another constraint on x", etc. ]
23:50:08 <ivanm> duryodhan: get what? list comprehension or the whole thing?
23:50:15 <duryodhan> no nothing
23:50:18 <duryodhan> sorry made a mistake
23:51:02 <duryodhan> ivanm: so the comprehension is just the part in [ .... ] right ?
23:51:18 <ivanm> yup
23:51:31 <duryodhan> ivanm: so it basically is saying take the head of each list and attach it to form the topmost list
23:51:40 <duryodhan> ivanm: ok .. so wouldn't map or something also work here ?
23:51:47 <ivanm> basically, comprehensions are a way of simplifying maps, filters, etc. on lists
23:51:59 <ivanm> duryodhan: in this case, yes
23:52:19 <duryodhan> ohh ok
23:52:22 <ivanm> except that we'd also have to filter out empty rows, which the comprehension gives us for free
23:52:27 <ivanm> let's look at the second one for example:
23:53:09 <ivanm>  [ t | (h:t) <- xss] <-- this says for each sub-list of the form (h:t) [i.e. it has at least one element], take off the first element
23:53:27 <ivanm> instead, we could say something like: map tail . filter (not . null) $ xss
23:54:06 <ivanm> (though normally, you would use (_:t) for the pattern match, since we don't actually use h)
23:54:16 <ivanm> duryodhan: with me?
23:54:20 <duryodhan> yeah got you
23:54:32 <duryodhan> wats teh $ for ?
23:54:40 * duryodhan hates laptop keyboards
23:55:38 <ivanm> duryodhan: function application: when you have a whole bunch of functions chained together with (.), we can use ($) to apply the resultant combined function to a value
23:55:59 <shachaf> duryodhan: Without the $ it would mean (map tail) . (filter (not . null) xss)
23:56:26 <ivanm> which wouldn't parse ;-)
23:56:40 <cpfr> howdy
23:57:14 <cpfr> if i wanted to run a google search and then parse the results, would Network.HTTP do the trick?
23:57:15 <duryodhan> ivanm: ohh so you are sending tail.filter (not.null) as an arg to map ?
23:57:25 <cpfr> or is there something better/
23:57:26 <shachaf> ivanm: Type-check, you mean? It could, with (.) = fmap. :-)
23:57:37 <ivanm> duryodhan: no, just tail
23:57:40 <ivanm> shachaf: yeah
23:58:01 <ivanm> duryodhan: we have two separate functions: ` map tail ' and ` filter (not . null) '
23:58:10 <ivanm> we use the (.) function to combine them
23:58:10 <duryodhan> ohh ok
23:58:13 <ivanm> @src (.)
23:58:13 <lambdabot> (f . g) x = f (g x)
23:58:40 <ivanm> note that (map tail . filter (not . null)) xss = map tail . filter (not . null) $ xss
23:59:21 <duryodhan> umm .. why is the . between tail and filter there ?
23:59:28 <duryodhan> wouldn't that join the two functions ?
23:59:32 <ivanm> duryodhan: yes
23:59:45 <pumpkin> map steals tail before . can steal it
23:59:46 <duryodhan> but you wanted to only send tail as arg to map ?
23:59:47 <ivanm> it takes the result from the filter (not . null) function, and passes it to map tail
23:59:51 <shachaf> duryodhan: It doesn't join tail and filter.
