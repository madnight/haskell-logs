00:00:28 <mmorrow> "cabal has no way of allowing user-provided include dirs to take precedence over ghc include dirs, which is a problem in the case of a user/system .h with the same name as a ghc .h"
00:00:30 <mmorrow> or something
00:01:43 <mmorrow> iaefai: http://hackage.haskell.org/trac/hackage/ is the cabal bugtracker
00:04:09 <mmorrow> iaefai: oh, you say the command-line ordering /doesn't/ matter?
00:04:42 <mmorrow> iaefai: if you give -v3 to whichever cabal prog you're using to build, it'll dump exactly what it's calling gcc with
00:06:24 <mmorrow> at least, i *think* it's cabal that'd be calling gcc, although it may be ghc that's doing it
00:06:55 <mmorrow> in that case maybe pass a ghc flag to ghc via cabal
00:07:00 <mmorrow> iirc -vN works
00:07:12 <mmorrow> (N `elem` [0..])
00:07:22 <iaefai> quite possibly
00:07:24 <iaefai> so I will just work around it
00:08:07 <mmorrow> iaefai: cool. are you going to file a bug report? since if not i think i'll do it, since this seems like a legitimate bug.
00:10:14 <ivanm> what bug is this?
00:11:00 <mmorrow> mmorrow> "cabal has no way of allowing user-provided include dirs to take precedence over ghc include dirs, which is a problem in the case of a user/system .h with the same name as a ghc .h"
00:11:03 <mmorrow> more or less
00:11:26 <ivanm> hmmmm.....
00:11:43 <mmorrow> (also, there may be a way, not sure)
00:11:46 <iaefai> mmorrow: I could not have gotten this far without -v3 :p
00:11:54 <mmorrow> iaefai: heh :)
00:12:08 <mmorrow> iaefai: so what's it calling gcc with?
00:12:17 <mmorrow> iaefai: (what order of -I's)
00:12:32 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10794#a10794
00:12:36 <iaefai> That is everything
00:15:02 <mmorrow> iaefai: hmm, odd "ignoring duplicate directory "/usr/include""
00:15:13 <iaefai> It just means it has it already
00:15:30 <mmorrow> iaefai: but in that case, how do you tell it to search there first?
00:15:44 <iaefai> You can't afaik
00:15:50 <mmorrow> hmm
00:15:53 <ksf> how do I see cost centres belonging to a lib?
00:16:11 <mmorrow> iaefai: am i understanding correctly though that that's essentially what we need here?
00:16:19 <iaefai> yes
00:16:30 <mmorrow> fun
00:16:56 <mmorrow> ugh, so this is a gcc-level problem
00:17:43 <mmorrow> iaefai: how is Block.h imported? <Block.h> or "Block.h"?
00:17:53 <ksf> it's kinda pointless to see 61% individual time for a cc when I don't get to see the stuff it's made of.
00:18:12 <mmorrow> hmm, although i don't recall the search order for <foo.h>
00:18:41 <iaefai> #include <Block.h>
00:20:35 <amckinley> hey all, im stuck trying to convert my string-based parsec parser to use bytestrings instead. could someone help?
00:20:51 <FunctorSalad> ksf: compile libs with -auto-all or so?
00:21:02 <ksf> er. ah. yes. makes sense.
00:21:09 <ksf> I cabal installed them, so...
00:21:18 <FunctorSalad> you can do it with cabal
00:21:26 <FunctorSalad> --ghc-option=-auto-all
00:21:57 <ksf> that's pure convinience.
00:22:28 <Saizan_> amckinley: you can try attoparsec
00:22:49 <ksf> you see, usually it's the speed of _my_ code that sucks, so I never did it before...
00:23:14 <amckinley> Saizan_: ive got a pretty big investment in my parsec code at this point :) im pretty sure im just doing something stupid
00:23:19 <mmorrow> iaefai: it looks like (from the gcc manual) that you could possibly do
00:23:25 <FunctorSalad> ksf: hehe
00:23:27 <mmorrow> iaefai: -iquote DIR
00:23:30 * ksf is drowning in numbers
00:23:43 <mmorrow> iaefai: and change it to #include "Block.h"
00:23:57 <mmorrow> which'll search DIR /before/ the -I dirs
00:23:57 <Saizan_> amckinley: so you're using parsec-3, right?
00:23:57 <iaefai> I can't change it, it is a system framework
00:24:03 <amckinley> Saizan_: yep
00:24:05 <mmorrow> iaefai: oh
00:24:07 <ksf> ...and the culprit is useUniforms with 37% vs. the next one 7.4%
00:24:25 <FunctorSalad> useUniforms?
00:24:42 <mmorrow> iaefai: well, i'm out of ideas. maybe you can find some sneaky way around this in the gcc manual
00:24:45 <ksf> something in gpipe. dunno.
00:25:00 <amckinley> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10810#a10810
00:25:02 <ksf> I'm trying to figure out why it burns 30%cpu @ 30 fps.
00:25:11 <ksf> must be shader generation or something I figure.
00:25:13 <iaefai> I think I am done with this problem, I am going to try building the library without cabal and have cabal just use the C library I make.
00:25:42 <mmorrow> nice
00:25:52 <ksf> if done right, that simple cube demo should run at lim -> 0% cpu at insane framerates.
00:26:02 <Saizan_> amckinley: and what's the problem?
00:26:27 <amckinley> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10811#a10811
00:26:46 <ksf> brrr that's a crlf file
00:28:20 <amckinley> Saizan_: im pretty sure im trying to do something thats obviously wrong by combining Text.Parsec.ByteString with Text.Parsec.Token
00:28:39 <ksf> weren't some kind of glsl thingies called uniforms?
00:29:47 <iaefai> peace boys and girls.
00:29:55 <Saizan_> amckinley: no, that should be allowed
00:30:11 <ksf> yep they're called like that because it's input that's uniform for all vertices and fragments
00:30:52 <Saizan_> amckinley: the types in Token are all polymorphic over the stream
00:31:07 <amckinley> Saizan_: am i just ommitting a type signature that the compiler really needs?
00:31:19 <Saizan_> amckinley: no
00:31:38 <Saizan_> amckinley: it seems you're using something somewhere that requires the stream to be [Char]
00:32:42 <Saizan_> amckinley: i'd ask ghci for the types of the toplevel definitions, to restrict where to search
00:33:17 <amckinley> Saizan_: oh, i bet its those Text.Parsec.Char.string calls im making
00:34:08 <Saizan_> no, those are polymorphic too
00:34:18 <FunctorSalad> :o
00:34:20 <FunctorSalad> @hoogle string
00:34:21 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
00:34:21 <lambdabot> Text.ParserCombinators.ReadP string :: String -> ReadP String
00:34:21 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
00:34:27 <Saizan_> amckinley: i think it's what you import from .Language
00:34:50 <Saizan_> http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Language.html <- the types here fix 's' to be String
00:34:56 <FunctorSalad> uhm they're polymorphic but that context requires Char
00:35:01 <FunctorSalad> whatever the third arg means
00:35:17 <Saizan_> Stream stream monad token
00:35:31 <FunctorSalad> well so it requires char tokens
00:35:45 <Saizan_> but that's fine, since you've Stream ByteString monad Char
00:36:00 <FunctorSalad> ah. thought he was using a custom token type
00:37:38 <amckinley> Saizan_: so i need to use GenLanguageDef instead of the pre-parameterized LanguageDef?
00:38:02 <Saizan_> amckinley: yes
00:38:32 <Saizan_> anything with type LanguageDef won't work with ByteString, afaict
00:38:53 <lord_of_computin> hello everyone.
00:39:04 <mlesniak> I'm searching for famous Haskell quotes, but neither wikiquote nor haskell.org nor google could help me. any ideas?
00:39:08 <amckinley> Saizan_: im not sure where/how i need to change that
00:39:17 <c_wraith> I don't know if I need this, but...  "timeoutAtomically :: Int -> STM a -> IO (Maybe a)"  is potentially useful, and I can't see how to do the same thing nearly as cleanly without STM.
00:39:54 <amckinley> mlesniak: ive got one: "Some people, when they encounter a problem, think 'I know, I'll use Haskell!' Now they have two problems"
00:40:04 <c_wraith> @quote
00:40:04 <lambdabot> sheep1e says: The fourth character presumably represents both "runtime" and "Writer monad", a kind of Haskell pun in Japanese.
00:40:07 <Saizan_> amckinley: well, what are you using from the Text.Parsec.Language module?
00:40:20 <amckinley> Saizan_: makeTokenParser
00:40:25 <mlesniak> c_wraith, any way to get the list of quotes from lambdabot?
00:40:39 <amckinley> Saizan_: or actually, just emptyDef
00:40:44 <c_wraith> mlesniak:  I don't know.  Ask Cale nicely?
00:40:51 <mlesniak> :) Good idea
00:41:16 <Saizan_> amckinley: then you've to write your own emptyDef
00:41:24 <FunctorSalad> mlesniak: haskell news weekly
00:41:32 <FunctorSalad> *haskell weekly news
00:41:44 <mlesniak> FunctorSalad, Hmm, right, forgot this, thanks!
00:42:35 <lord_of_computin> I just had a ten minutes tutorial for haskell (a newbie) so I might be wrong in what I felt about it. They say that Haskell runs slow and the memory footprint is relatively high from others. So, is there any other advantage of using Haskell besides reduced development time?
00:42:46 <Saizan_> amckinley: you can copy/paste the source from here and give it a different type http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/src/Text-Parsec-Language.html#emptyDef , and then correct it if it gives a type error
00:43:10 <cjs> It's not necessarily slow; if you code your stuff well, GHC-compiled code can be quite fast.
00:43:48 <FunctorSalad> lord_of_computin: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all&box=1
00:43:53 <cjs> As for footprint, yeah, small programs compared to C, can be relatively large (several megabytes of memory usage). But if you compare with, say, Java, it's quite competitive.
00:44:05 <lord_of_computin> cjs: I see. but what you are saying applies to 100% of development strateties and needs?
00:44:12 <amckinley> Saizan_: awesome sauce. i need something like this, i think:
00:44:13 <amckinley> type BSLanguageDef st = GenLanguageDef Data.ByteString.Internal.ByteString st Identity
00:44:16 <ksf> that's a base cost, though, it's not like it grows fast.
00:44:54 <cjs> lord_of_computin: Nothing applies to 100% of anything. But in general, anything you'd be ok with doing in Java, you should be ok with doing in Haskell instead, if you're using GHC.
00:44:56 <Saizan_> amckinley: you don't need to define the type synonym at all, but if you find it convenient..
00:45:26 <cjs> And when there's a difference, chances are that your code running under GHC will win over the Java code, if it's well written.
00:45:34 <lord_of_computin> FunctorSalad: THANKS FOR THE CHART
00:45:44 <amckinley> Saizan_: i also probably shouldnt be using Data.ByteString.Internal.ByteString as my stream type?
00:46:10 <FunctorSalad> lord_of_computin: imho 2.6xC is quite a small price considering that haskell is somewhat more beautiful ;-)
00:46:33 <Saizan_> amckinley: that's the fully qualified name, i'd import it from Data.ByteString and just use ByteString
00:46:55 <lord_of_computin> cjs: okay.
00:48:00 * Saizan_ wonders how ghc haskell compares in memory use vs. jvm java
00:48:14 <mornfall> Try shootout? :)
00:48:17 <cjs> lord_of_computin: Also, keep in mind that Haskell has a much nicer FFI, so if you need to do C-like code, or actually call C, it's going to be easier in Haskell.
00:48:50 <ksf> and that haskell would be faster in the shootout if they would let us tweak the gc.
00:48:59 <ksf> and use a trie instead of a hashmap etc.
00:49:46 <fergie> if I declare a data type and derive Ord which field of the data type is used first for the comparison?
00:50:57 <Saizan_> fergie: it follows the order given in the declaration
00:51:31 <fergie> That wasn't very clear. Example: "Data Point Int Int". When comparing two Points the first Int is used first? And the 2nd only if the firsts are equal?
00:51:53 <Axman6> ivanm: you around?
00:52:08 <ivanm> Axman6: yup!
00:52:23 <fergie> Thanks Saizan_
00:52:26 <ivanm> whatsup?
00:52:31 <Taejo> fergie: assuming you mean "data Something = Point Int Int", yes
00:52:44 <lord_of_computin> cjs: alright, i just took the FFI into on their site too. Seems pretty kool ;)
00:52:49 <lord_of_computin> intro*
00:52:50 <Axman6> ivanm: been talking to my parents about where you shoud be looking for houses in canberra, and they've come up with some good ideas
00:53:06 <ivanm> Axman6: do tell! :D
00:53:09 <ksf> @hoogle withArray
00:53:09 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
00:53:09 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
00:53:09 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
00:53:38 <Saizan_> fergie: i guess you meant data Point = Point Int Int, there?
00:53:49 <Axman6> ivanm: they say you should look at Cook and Macquarie, and Bruce, because all the 300 busses go past bruce (<10 mins to ANU by bus)
00:54:16 <hackagebot> ghc-events 0.2 - Library and tool for parsing .eventlog files from GHC (SimonMarlow)
00:54:25 <ivanm> Axman6: yeah, google showed me the way to the ANU page with bus suggestions
00:54:31 <fergie> Saizan_, Taejo you are right. Was trying to be too quick
00:54:34 <Axman6> good
00:54:58 <ivanm> ghc-events is only really useful for 6.12, right?
00:55:03 <Axman6> Bruce is right next to UC, so you may find people offering good accomodation to students
00:55:16 <ivanm> Axman6: yeah, not really looking for student accom
00:55:24 <ivanm> Axman6: but I find it weird when a place in Bruce says it's close to ANU :s
00:55:31 <Axman6> it is
00:55:45 <ivanm> Axman6: it's not exactly "down the road" ;-)
00:55:59 <Axman6> in canberra terms. it may be many k's away, but getting from there to ANU will take you at most 20 minutes
00:56:05 <ivanm> heh
00:56:08 <ivanm> by car or by bus?
00:56:21 <Axman6> bus
00:56:41 <Axman6> less by car
00:56:52 <ivanm> *nod*
00:57:12 * ksf can't believe the code is spending 35% of sending bleeding 28 floats to the gpu, every frame.
00:57:13 <Axman6> but not much, bus lanes mean busses are often faster than car in peak times
00:57:14 <ivanm> well, seeing as how with the new busway it now takes me about 40min on a good run to get to UQ...
00:57:37 <ksf> heck it's an agp card, but not _that_ slow.
00:57:38 <Axman6> it takes me at most 30 minutes from mckellar
00:57:45 <ksf> I'd expect that performance from an ISA card.
00:58:48 <amckinley> Saizan_: got it to compile :) thanks so much; you've saved my night
00:58:53 <Taejo> is there a good haskell library/edsl for writing graphics shaders (I'm a total noob wrt modern graphics cards, but I'd rather start out in Haskell than C++)
00:59:05 <ivanm> Axman6: right
00:59:06 <ksf> Taejo, gpipe.
00:59:12 <ksf> I'm just testing it out right now.
00:59:13 <ivanm> Axman6: how long does it take you to bike?
00:59:22 <Axman6> about 40mins
00:59:27 <Saizan_> amckinley: great :)
00:59:34 <Axman6> depending on how fit i'm feeling :P
00:59:38 <ivanm> heh
00:59:48 <ivanm> what, if you're not feeling fit you push yourself harder? :p
00:59:50 <Taejo> ksf: is there a tutorial somewhere?
01:00:03 <Axman6> i chuck my bike on a bus :P
01:00:05 <ksf> there's a quick example on the wiki page
01:00:10 <ivanm> Axman6: heh
01:00:15 <ivanm> just in case you feel fit going home?
01:00:30 <Axman6> all the 300's have bike racks, so i only ride to ANU and get the bus home
01:00:46 <ivanm> because it's uphill?
01:00:55 <Axman6> yeah
01:00:57 <ivanm> Axman6: what happens if both bike racks are already taken? wait for the next one?
01:01:12 <Axman6> yeah
01:01:25 <ksf> Taejo, or, better, use this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10812#a10812
01:01:31 <ksf> (it's got a frame limiter)
01:01:36 <Axman6> the 300's come every 5 mins, so it's not a problem
01:01:43 <ksf> ...and tell me if you think your cpu usage is too high.
01:01:58 <Axman6> and depending on where you are, you can ride from belconnen bus station
01:02:00 <ksf> (and it exits cleanly)
01:03:41 <Taejo> what is the SCC annotation?
01:03:47 <opqdonut> cost center
01:03:49 <opqdonut> for profiling
01:03:53 <Taejo> oh, right
01:04:56 <Axman6> ivanm: anyway, check out cook and macquarie
01:05:11 <ivanm> right
01:05:28 <ivanm> there's a few places around macgregor as well by the looks of things
01:06:54 <Axman6> heh, that's pretty far out
01:07:02 <Axman6> have you checked allhomes.com.au?
01:07:06 <ivanm> how much would I be looking at for buses?
01:07:13 <ivanm> Axman6: allhomes, realestate and domain .com.au
01:07:33 <Axman6> not much. a concession card (10 rides) is $12.something i think
01:07:44 <ivanm> no zones or anything?
01:08:08 <Axman6> nope
01:08:29 <ivanm> good-o
01:08:35 <Axman6> one ticket will get you anywhere in canberra, and can be used as many times as you like within 90 minutes
01:08:39 <Axman6> http://www.action.act.gov.au/fares.html
01:08:41 <ivanm> how bout internets... pretty much transact for most places?
01:09:34 <Axman6> there's others. transact keep fucking us, but that's mianly because we can't get fibre here (the cables are up, they just never connected the fucking things)
01:09:44 <ivanm> heh
01:09:53 <ivanm> so they're just like telstra everywhere else in aus? :p
01:10:07 <Axman6> well, we have telstra too :P
01:10:54 <ivanm> yes, but transact is giving them competition? ;-)
01:11:02 <ksf> just don't bother about the corporations and start up a mesh.
01:11:07 <Axman6> meh, i don't pay attention
01:11:52 <ivanm> ksf: well, the mesh has to join the internet proper at some point...
01:12:06 <ksf> at any point you want.
01:12:10 <ksf> multiple points.
01:12:18 <ivanm> in which case you have to bother with the corporations
01:12:25 <ksf> though usually you tunnel to a specific one due to nat and such.
01:12:36 <ksf> no. not you. someone else.
01:12:44 <ivanm> ksf: heh
01:12:51 <ivanm> and if _everyone_ thinks that? ;-)
01:13:08 <ksf> then get yourselves a T1 or something.
01:13:34 <ivanm> don't think they have them down here...
01:15:52 <ksf> then use bull-roarers.
01:19:36 <ivanm> Axman6: this is the only place allhomes shows in cook and macquarie for <=400k with 2 bedrooms, and I don't think I'm elegible... http://www.allhomes.com.au/ah/ah0073?slid=167385531
01:21:00 <Axman6> heh
01:22:13 * ivanm wonders what the difference between a "unit" and an "apartment" is...
01:22:18 <Axman6> ivanm: http://www.allhomes.com.au/ah/ah0073?slid=167391114 ?
01:22:35 <ivanm> yeah, saw that
01:22:39 <Axman6> units are one story things, according to dad
01:22:45 <ivanm> ahhh
01:22:50 <ivanm> prefer a 2 bdroom one in case the folks come down or something though
01:23:12 <ivanm> how bad/far away is holt?
01:23:13 <Axman6> god the cash?
01:23:33 <Axman6> it's pretty far away (my SES unit is in holt i think, or higgins)
01:23:41 <ivanm> hmmmm...
01:24:34 <ivanm> florey doesn't look that far...
01:24:38 <ivanm> closer than McKellar, anyway
01:24:50 <Axman6> mckellar isn
01:24:58 <Axman6> isn't exactly far..
01:25:16 <Axman6> http://maps.google.com/maps?client=safari&q=macgregor+canberra+map&oe=UTF-8&ie=UTF8&ei=fynYSsXlMtGjkAXU0dzXCA&ved=0CBAQ8gEwAA&hq=&hnear=Macgregor+ACT,+Australia&ll=-35.230337,149.071426&spn=0.084833,0.181789&t=h&z=13 shows where holt is
01:25:29 <ivanm> well, according to google maps you have to get around the lake from mckellar...
01:25:59 <Axman6> you don't need to go to belconnen to get to ANU though. it's a pretty direct route
01:26:07 <ivanm> *nod*
01:26:13 <ivanm> Axman6: wow, this place looks _great_ :s http://www.allhomes.com.au/ah/ah0073?slid=167386325
01:26:29 <Axman6> along ginninderra drive, down haydon drive, and on to barry drive
01:26:36 <Axman6> takes <20 mins
01:27:17 <Axman6> ivanm: worth checking out though
01:27:33 <ivanm> even though you have nfi where it even is despite being in "bruce"?
01:27:38 <ivanm> and no photos, etc.?
01:27:55 * ivanm has already tried emailing a few agents based on listings on allhomes, etc. with no replies...
01:28:03 <Axman6> ask the seller for photos
01:28:07 <Axman6> hmm
01:29:24 <ivanm> I take it evatt isn't that far either?
01:29:47 <Axman6> nope, right accross the street from me practically (i went to primary school there)
01:29:57 <ivanm> eh, forget that, you have to buy another one with it
01:30:06 <Axman6> :\
01:30:57 * ivanm -> dinner
01:31:20 <Axman6> o/
01:32:48 <Axman6> ivanm: don't you want to rent?
01:39:26 <Jedai> @pl \f x y -> f x `mplus` f y
01:39:26 <lambdabot> flip =<< (((.) . mplus) .)
01:39:57 <opqdonut> or: "mplus `on` f"
01:40:01 <opqdonut> @src on
01:40:01 <lambdabot> (*) `on` f = \x y -> f x * f y
01:40:01 <skorpan> yeah
01:43:44 <Taejo> @hoogle Int -> [a] -> [a]
01:43:44 <lambdabot> Prelude drop :: Int -> [a] -> [a]
01:43:44 <lambdabot> Prelude take :: Int -> [a] -> [a]
01:43:44 <lambdabot> Data.List drop :: Int -> [a] -> [a]
01:47:06 <Taejo> :t unfoldr
01:47:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:47:19 <Taejo> :t splitAt
01:47:20 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:08:51 <ksf> @hoogle withArray
02:08:51 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
02:08:51 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
02:08:51 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
02:10:51 <ksf> does a let _ = seq ... do what I want it to do? (IO monad)
02:11:02 <quicksilver> no.
02:11:08 <quicksilver> it does nothing.
02:11:20 <quicksilver> "let" is lazy
02:11:21 <Vanadium> Does case seq ... of _ -> do what he wants?
02:11:33 <quicksilver> I doubt it.
02:11:36 <ksf> a return . seq ...?
02:11:46 <quicksilver> case ... seq () of () -> do will do it
02:11:50 <quicksilver> but that's really obscure
02:11:52 <quicksilver> why not just
02:11:56 <quicksilver> ... `seq` stuff ?
02:12:13 <quicksilver> do { putStrLn "this"; stuff `seq` putStrLn "that"; }
02:12:39 <Igloo> Use Control.Exception.evaluate
02:12:47 <quicksilver> if you like, yes.
02:12:59 <quicksilver> I don't like Control.Exception.evaluate because it has no semantics.
02:13:15 <quicksilver> and the greatest minds of the haskell community tried to give it some and ended up failing.
02:13:37 <quicksilver> and as far as I can see, `seq` has simpler semantics and is perfectly adequate.
02:14:13 <Igloo> Why is it harder to give evaluate semantics?
02:14:57 <quicksilver> I don't know, really.
02:15:01 <quicksilver> but http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#8 is rubbish.
02:15:35 <quicksilver> see http://www.mail-archive.com/haskell-cafe@haskell.org/msg40575.html
02:17:40 * ksf thinks deepSeq should be in the standard lib
02:18:17 <Vanadium> What is that?
02:18:19 <Vanadium> rnf?
02:18:31 <ksf> http://hackage.haskell.org/packages/archive/hxt/7.4/doc/html/Control-Strategies-DeepSeq.html
02:19:14 <quicksilver> rnf is in the standard lib for some definition of standard
02:19:22 <quicksilver> although the parallel package is possible a strange place for it
02:20:33 <ksf> wait using it is going to infect everything with a class context
02:21:14 <ksf> that makes it utter pain. I just want to debug...
02:21:38 <quicksilver> yes, it is the nature of NFData that it requires a class context.
02:21:39 <ksf> large scale program changes just to nail a bug aren't what I call fun coding.
02:21:44 <quicksilver> it can't be written generically.
02:21:51 <ivanm> Axman6: depends on the price... renting doesn't look that cheap either
02:22:01 <quicksilver> but if the thing you're rnf'ing is definitely an instance, it won't escape
02:22:02 <ivanm> and if we buy, then we'll have an investment property, blah, blah, blah
02:22:07 <quicksilver> (the context won't escape etc)
02:23:40 <ksf> it's a [Float]
02:23:57 <quicksilver> yes, there is an NFData instance for that.
02:24:22 <quicksilver> > ([1.0,2.0,undefined] `rnf` ())
02:24:23 <lambdabot>   Couldn't match expected type `() -> t'
02:24:23 <lambdabot>         against inferred type `Contr...
02:24:36 * quicksilver ponders
02:24:37 <quicksilver> :t rnf
02:24:38 <lambdabot> forall a. (NFData a) => a -> Done
02:24:43 <Vanadium> > rnf [1.0,2.0, undefined] `seq` ()
02:24:43 <lambdabot>   * Exception: Prelude.undefined
02:24:48 <quicksilver> thanks :)
02:25:40 <ksf> it makes sense to have it in parallel as you've got to establish strictness boundaries around your threads.
02:25:43 <quicksilver> > rnf [1.0,2.0,undefined]
02:25:44 <lambdabot>   * Exception: Prelude.undefined
02:25:44 <Vanadium> Done being () and the whole Strategy type is a bit too much for my "oh god make this run in parallel already" state of mind
02:25:54 <ksf> otherwise, a lot of threads construct thunks and one evaluates all of them.
02:26:06 <Vanadium> ksf: Yeah, but you might also want it to establish strictness boundaries within a single threaded program
02:26:09 <quicksilver> sure, it's required for sensible spark evaluation
02:26:17 <quicksilver> but that's not the only thing it's required for
02:26:23 <quicksilver> although ahving said that, I never use it :)
02:26:25 <Vanadium> The argument is not "it is not needed for threading" but "it is not needed *only* for threading" I think
02:26:29 <quicksilver> right
02:27:11 <ksf> what's with that Strategy type?
02:27:21 <ksf> I want a plain a -> b -> b
02:28:09 <ksf> ah. sforce.
02:28:21 <Vanadium> Deprecated :'(
02:28:34 <quicksilver> just use rnf + seq
02:28:46 <quicksilver> rnf (stuff) `seq` (the b you really wanted)
02:29:04 <quicksilver> although like I say, I've never really need it
02:29:13 <ksf> I so don't care.
02:29:17 <quicksilver> with opengl stuff I normally ended up forcing stuff by using withArray or whatever
02:29:22 <Vanadium> Strategies are basically "how deeply do I want this evaluated", and Control.Parallel.Strategies gives you r0 which does nothing, rwhnf and rnf :|
02:29:43 <ivanm> how does rwnhf differ from just seq'ing it?
02:29:48 <Vanadium> Not at all
02:29:50 <ivanm> and is r0 = id or something?
02:29:53 <ivanm> heh
02:30:08 <Vanadium> no, a strategy is supposed to return () when it is done
02:30:26 <ksf> quicksilver, that's what the code is doing. but I want to SCC evaling the data.
02:30:29 <Vanadium> so r0 is const (), rwhnf x is x `seq` ()
02:30:45 <ivanm> *nod*
02:30:53 * quicksilver nods
02:31:08 <ivanm> is there any particular reason strategy is in parallel? because most of them are dealing with evaluating in parallel?
02:31:10 <fasta> hsc2hs had a way to define alignment. How can I do that with c2hs?
02:31:11 <Vanadium> they have a bunch of wrappers to apply strategies to lists in parallel, but I am not very confident that I understand how to use them.
02:32:09 <ksf> how can withArray be possibly _that_ expensive?
02:32:49 <quicksilver> I don't imagine it is.
02:33:13 <quicksilver> I expect your graphics driver is busy-waiting to sync to VSYNC and that CPU time is being incorrectly attributed.
02:33:21 <quicksilver> or something equally dumb.
02:33:37 <ksf> ...but then the cost would be attributed to uniformv, wouldn't it?
02:33:54 <quicksilver> you'd expect it ot be attributed to glSwapBuffers
02:34:04 <quicksilver> but, optimisation confuses profiling sometimes.
02:34:11 <quicksilver> I'm just stabbing in the dark
02:34:23 <ksf> ...I'm compiling without -O
02:34:43 <quicksilver> show code + profile ?
02:35:03 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10815#a10815
02:35:48 <ksf> oh there's fu, too.
02:35:51 <hackagebot> iproute 0.1 - IP Routing Table (KazuYamamoto)
02:36:57 <ksf> gragh and it contains non-nfdata
02:37:35 <ksf> ...which contains a bleeding map
02:37:46 <quicksilver> full source and full profile would be handier :)
02:37:53 <quicksilver> Data.Map is NFData I think
02:38:17 <ksf> the source is qpipe
02:38:24 <ksf> er gpipe
02:38:58 <quicksilver> did you try running a profile with -auto-all ?
02:39:02 <quicksilver> was that not instructive?
02:39:03 <ksf> I do.
02:39:22 <ksf> those 33% are the largest chunk by a large margin
02:39:44 <ksf> ...the next ones are max. 8%, and change from run to run.
02:40:25 <quicksilver> which file is that code in, ksf?
02:40:31 <ksf> Resources.hs
02:40:37 <ksf> useUniforms
02:41:04 <quicksilver> ooh, yucky
02:41:10 <quicksilver> non-hierarchical names for the non-exported modules
02:41:33 <ksf> hpaste doesn't like the --auto-all.
02:42:17 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10815#a10816
02:42:27 <quicksilver> I suppose it's probably the underlying code which *creates* the floats in f?
02:42:35 <quicksilver> not the code which calls glUniformV
02:42:45 <ksf> that's 1.7%
02:43:17 <quicksilver> something odd about your profile
02:43:23 <quicksilver> why is the 'inherited' column all zeroes?
02:43:29 <ksf> ...assuming that realToFrac, fromIntegral and length aren't horribly broken.
02:43:52 <ksf> ...because I nailed the costs in f
02:44:00 <nha_> is it possible to 'maxBound' a type variable?
02:44:17 <quicksilver> ksf: try replacing realToFrac and fromIntegral with unsafeCoerce
02:44:36 <quicksilver> that will eliminate the possibilit it's them.
02:44:45 <quicksilver> but I don't think that profile is right, since it has zeroes in the inherited column.
02:45:58 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10812
02:46:09 <ksf> that's the profiled code.
02:47:17 <ksf> In the use of `sforce'
02:47:17 <ksf>              (imported from Control.Parallel.Strategies):
02:47:17 <ksf>              Deprecated: "Lolita-specific hacks."
02:47:19 <ksf> wtf?
02:47:47 <quicksilver> > 1000/30
02:47:48 <lambdabot>   33.333333333333336
02:48:15 <quicksilver> and the CPU usage you observe is what? and what graphics card / OS do you have?
02:49:06 <Gracenotes> hm.. using a lazily generated list with monads.. this doesn't look likely to succeed
02:50:02 <ksf> 35% cpu @ 33 frames, amd64 3200+, geforce 7600 gs
02:50:13 <Gracenotes> at least, with an arbitrary monad. the problem is that in sequencing is orthagonal to a corecursive structure, I'd say :/
02:50:29 <FunctorSalad> Gracenotes: I've heard you use this type: data ListM a = Nil | ListM (m a) (m (ListM a))
02:50:32 <FunctorSalad> or something similar
02:50:44 <quicksilver> ksf: OS?
02:50:51 <Gracenotes> hm, orthagonal, but antithetical even
02:51:02 <FunctorSalad> (maybe knowing which constructor is the case was wrapped in m too)
02:51:11 <ksf> linux, of course.
02:51:20 <ksf> ...and those unsafecoerces helped a lot.
02:51:37 <quicksilver> linux GLSL drivers aren't great, I think
02:51:42 <ksf> as that's 35% _with_ profiling overhead.
02:51:49 <quicksilver> interesting
02:52:34 <ksf> the largest center is now "newWindow", which is gpipe's mainloop.
02:52:50 <Gracenotes> FunctorSalad: well, the set up is, let arr = listArray (0, upper) (map func [0..upper]); func a b ... = ... (arr ! this) ... (arr ! that) ...; in arr ! initialValue
02:53:40 <quicksilver> ksf: GPipe should use GLfloat, GLint in its key 'UniformSet' type
02:53:50 <quicksilver> ksf: silly to impose an un-necessary conversion.
02:54:12 <Gracenotes> I suppose it would work for Either. which is what I'm trying to do. but using the Error monad to encode it seems hopeless ;
02:54:14 <Gracenotes> :)
02:54:22 <quicksilver> although I remain surprised that unwrapping a newtype on 28 values per frame is a significant overhead
02:54:42 <FunctorSalad> @hoogel listArray
02:54:42 <lambdabot> Maybe you meant: hoogle hoogle+
02:54:48 <FunctorSalad> @hoogle listArray
02:54:49 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
02:54:49 <lambdabot> Data.Array.MArray newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
02:56:33 <Gracenotes> hm... wait... I think this could work for Error
02:57:58 <ksf> 17% unsafeCoerce vs. 24 with conversions
02:58:00 <Gracenotes> you'd just have to do "result <- arr ! that", as you'd do the same for a function call in a primitive recursive implementation
02:58:37 <ksf> with -O2, that is.
02:58:40 <Axman6> so, has anyone considered following jdh's idea and writing the book, Haskell for Scientists? I'd read it
02:59:13 <ksf> still way too high. I hope that's a more or less constant cost and doesn't grow significantly with scene size.
02:59:22 <fasta> Axman6: where does he say that?
02:59:51 <Axman6> i'm somewhat projecting what he's saying, but here: http://www.reddit.com/r/programming/comments/9uctg/life_is_too_short_to_program_in_bad_languages/c0ehjej
02:59:58 <ksf> I'm not a glsl expert, but I don't think it's nescessary to push constant vertex data again and again.
03:01:15 <Gracenotes> hey, is there a name for the problem of, in a list of integers, finding adjacent sublists with the same sum?
03:01:58 <Gracenotes> for example, a solution for [5, 1, 3, 2, 2, 3] is sum [1,3]==sum [2,2]
03:02:15 <Gracenotes> or sum [3,2]==sum [2,3]
03:03:09 <Gracenotes> it can be done in O(n^2) time.. but I wonder if there is an O(n lg n) algorithm
03:03:21 <ivanm> Axman6: http://maps.google.com.au/maps?f=q&source=s_q&hl=en&geocode=&q=&sll=-35.267626,149.159317&sspn=0.047162,0.111494&ie=UTF8&mrt=realestate&ei=sEDYSsv1E5PQswOVtZ3_Cg&attrid=f48bb6d5a18d20b0_89287c4dd8c3eb36:,450000_bd935ce6ffd8c97b_af32acd90715b645_f4a5b7d6e6f76370_&radius=3.15&rq=1&ev=zi&hq=&hnear=&ll=-35.267626,149.159317&spn=0.047162,0.111494&z=14 \o/
03:03:30 <ivanm> even more properties than allhomes, etc. gave me!
03:03:44 <Axman6> ooo, handy
03:05:27 <ivanm> Axman6: only prob is, it includes sold properties :s
03:05:35 <Axman6> :\
03:05:49 <ksf> GLfloat isn't even a newtype.
03:06:24 <ivanm> Axman6: take that back... those without letters appear to be sold
03:06:34 <Axman6> ah
03:07:13 <quicksilver> ksf: yes it is
03:07:21 <quicksilver> ksf: (in recent opengl versions)
03:07:26 <ivanm> all hail the almight google, keeper and owner of knowledge that will one day rule us all!
03:07:27 <ivanm> :s
03:07:31 <ivanm> *almighty
03:07:32 <quicksilver> ksf: I was assuming you must be using one of the recent ones.
03:07:33 <ksf> ...so the code is actually converting a float to a float via a rational
03:07:46 <quicksilver> ...otherwise there really shouldn't be a slowdown
03:07:46 <ksf> that's just plain insanity.
03:07:58 <quicksilver> if so, that's an optimiser bug
03:08:10 <quicksilver> realToFrac :: Float -> Float is supposed to be a NOP
03:08:16 <ksf> "The realToFrac function is defined to pivot through a Rational according to the haskell98 spec. "
03:08:21 <ksf> http://hackage.haskell.org/packages/archive/logfloat/0.12.0.1/doc/html/Data-Number-RealToFrac.html
03:08:31 <quicksilver> I suspect your'e using the newtype version of opengl
03:08:34 <SamB_XP_> ksf: not if GHC plays by the RULES
03:08:55 <quicksilver> ksf: yes, but GHC has an optimisation which avoids that.
03:08:55 <ivanm> SamB_XP_: yes, but who plays by the rules? pfffttt
03:09:41 <ksf> could it be that that GLfloat conversion messes with the RULE?
03:09:48 <ksf> er annotation
03:11:44 <quicksilver> you must be using the new opengl, ksf
03:11:50 <quicksilver> because gpipe depends on > 2.4.0.1
03:11:53 <ksf> yep I am.
03:11:55 <SamB_XP_> ksf: it could!
03:11:59 <quicksilver> so, GLfloat is a newtype
03:12:15 <ksf> I just noticed that as removing the realToFrac doesn't typecheck.
03:12:53 <ksf> opengl should export proper no-ops, then.
03:13:00 <FunctorSalad> compile with ghc-core and look :)
03:13:12 <FunctorSalad> it prints the rules fired on top
03:13:40 <ivanm> I thought the only point of a no-op was to consume useless cycles for old games, etc. where there was no timing functuality... :s
03:14:22 <ksf> (and hackage should tell google to always index latest, not some random out-of date version of a package)
03:14:22 <quicksilver> ksf: GLfloat isn't guaranteed by the opengl spec to be the same type as float
03:14:34 <quicksilver> ksf: that's why Sven changed them all to be newtypes
03:14:42 <ivanm> ksf: IIRC, hoogle requires manual indexing...
03:14:47 <tuukkah> let noop = return ()
03:14:56 <ksf> nah just plain old google.
03:15:04 <ivanm> ksf: oh, right
03:15:40 <quicksilver> GLint / Int is a more interesting example I suppose
03:15:51 <quicksilver> GLint being 32 bit and Int being 64 bit on 64 bit machines?
03:16:08 <ivanm> Axman6: couldn't bear to stay away, uh? :p
03:16:22 <ksf> one definitely wants to use the gl types with gpipe.
03:16:49 <Axman6> needed to reconnet. net's been really slow lately
03:16:57 <ivanm> heh
03:17:39 <ksf> I think I'll be doing a game of life as example.
03:37:23 <zygoloid> Gracenotes: are your integers guaranteed to be nonnegative?
03:37:48 <Gracenotes> zygoloid: yeah
03:37:59 <cjs> What's the equivalent of 'comparing' for '=='?
03:38:07 <zygoloid> (==) `on`
03:38:28 <cjs> Ah, right. Thanks.
03:39:50 <blueonyx> @t comparing
03:39:51 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:40:00 <blueonyx> @type comparing
03:40:01 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:40:16 <Gracenotes> zygoloid: about the search space... for length 2, there are (n-1) pairs of sublists to compare (of length 1). for length 3, (n-2). etc until length (n-2), 3 pairs to compare, and for sublists of length (n-1), just 2 pairs
03:40:17 <v1ctor_>   (!!6) $ scanl (*) 1 [1..]
03:40:46 <v1ctor_> Hm. Damn.
03:40:47 <blueonyx> thank you
03:41:31 <Gracenotes> this makes me think the search space is theta(n^2) in the number of items in the list. And, I don't think there is anyway to reduce the search space other than checking each individual combination.
03:41:54 <Gracenotes> (as opposed to searching, where one can theoretically halve the search space)
03:42:30 <v1ctor_> ? (!!7) $ scanl (*) 1 [1..]
03:43:40 <v1ctor_> Using Lambdabot is hard, let's go shopping
03:43:49 <Gracenotes> ha. it is '> '
03:43:59 <quicksilver> > (!!7) $ scanl (*) 1 [1..]
03:44:00 <lambdabot>   5040
03:44:06 <Gracenotes> or '@run', if you feel verbose
03:44:21 <v1ctor_> @run product [1..10]
03:44:22 <lambdabot>   3628800
03:44:24 <v1ctor_> Cool
03:44:25 <zygoloid> Gracenotes: perhaps. but you could say the same about the problem of finding the substring with the greatest sum in a sequence of integers, and that can be done in O(n) time
03:44:26 <v1ctor_> Thanks
03:45:09 <Vic_> Even if I have a terminal with ghci opened somewhere around here
03:45:28 <Gracenotes> hmm. Maybe.. you could do a binary search for each level.
03:45:46 <blueonyx> how to ask lambdabot where comparing is defined?
03:45:51 <Gracenotes> where the thing you're searching on is the splitting index
03:45:59 <poe> ?index comparing
03:46:00 <lambdabot> bzzt
03:46:08 <blueonyx> O.o
03:46:18 <zygoloid> Gracenotes: do you want one solution or all solutions?
03:46:20 <Vic_> @run nubBy(((>1) .) . gcd) [2..]
03:46:22 <lambdabot>   Ambiguous occurrence `>'
03:46:22 <lambdabot>  It could refer to either `L.>', defined at <local...
03:46:34 <Vic_> Right...
03:46:52 <Gracenotes> zygoloid: any solution, but assume worst case, nothing exists... the density of solutions isn't a given or anything :)
03:47:05 <Gracenotes> it is more of a yes/no problem than a what-is-the-sublist problem, really
03:47:13 <poe> blueonyx: Data.Ord
03:47:27 <Vic_> @run map(+10) [1..100]
03:47:28 <lambdabot>   Ambiguous occurrence `map'
03:47:28 <lambdabot>  It could refer to either `L.map', defined at <l...
03:47:33 <Vic_> @run map(+1) [1..100]
03:47:33 <lambdabot>   Ambiguous occurrence `map'
03:47:34 <lambdabot>  It could refer to either `L.map', defined at <l...
03:47:39 <Vic_> @run L.map(+1) [1..100]
03:47:40 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
03:47:41 <lambdabot>    arising from the literal `1'...
03:47:55 <blueonyx> poe: thx
03:48:04 <quicksilver> @. run run text.("(!!7)$"++).(++"(*)1[1..]")$" scanl "
03:48:06 <lambdabot>   5040
03:48:21 <blueonyx> @index sortBy
03:48:22 <lambdabot> Data.List
03:48:28 <blueonyx> @index lefts
03:48:28 <lambdabot> bzzt
03:48:47 <quicksilver> lefts xs = [ l | Left l <- xs ]
03:49:50 <Vic_> @run take 10 $ nubBy (((==0) .) . mod) [2..]
03:49:51 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
03:49:59 <blueonyx> yea its in Data.Either, just wanted to test lamdab
03:50:10 <quicksilver> > lefts
03:50:10 <lambdabot>   []->
03:50:11 <lambdabot>    []
03:50:11 <lambdabot>  [Left ()]->
03:50:11 <lambdabot>    [()]
03:50:11 <lambdabot>  [Left (),Left ()]->
03:50:12 <lambdabot>    [(),()]
03:50:14 <lambdabot>  [Left (),R...
03:50:19 <Gracenotes> D:
03:50:23 <Vic_> @run take 10 $ nubBy (((==0) .) . mod) [100..]
03:50:25 <lambdabot>   [100,101,102,103,104,105,106,107,108,109]
03:50:31 <quicksilver> wow. that was a bit spammy
03:50:35 <Vic_> :m +Data.List
03:52:33 <Gracenotes> so the recurrence, T(n) = 2*T(n-1) + O(n), T(1 or 2) = O(1). ick.
03:52:55 <ivanm> quicksilver: :o what is lambdabot doing there?
03:53:07 <Gracenotes> there must be some form of result sharing that I'm not thinking of
03:53:09 <quicksilver> ivanm: screwing with your head
03:53:23 <ivanm> heh
03:53:25 <ivanm> @hoogle lefts
03:53:25 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
03:53:25 <quicksilver> ivanm: (@. composes two commands)
03:53:26 <lambdabot> Language.Haskell.Lexer LeftSquare :: Token
03:53:26 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
03:53:29 <ivanm> ahhhh
03:53:34 <quicksilver> oh, you meant the second one? the 'lefts' ?
03:53:35 <ivanm> > foldr
03:53:36 <lambdabot>   {{()->{()->()}}->{()->{[]->();[()]->();[(),()]->();[(),(),()]->()}}}
03:53:40 <ivanm> quicksilver: yes
03:53:43 <quicksilver> smallcheck gives a show instance for functions
03:53:49 <quicksilver> > map (+1)
03:53:50 <lambdabot>   Ambiguous occurrence `map'
03:53:50 <lambdabot>  It could refer to either `L.map', defined at <l...
03:53:54 <quicksilver> > L.map (+1)
03:53:54 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
03:53:55 <lambdabot>    arising from the literal `1'...
03:53:56 <ivanm> a very bad one? ;-)
03:54:02 <quicksilver> well it's not that bad
03:54:04 <ivanm> why does it need L.map? :o
03:54:07 <quicksilver> it just gets bitten by defaulting
03:54:08 <ivanm> what happened to normal map?
03:54:13 <quicksilver> > Data.List.map (+1)
03:54:14 <lambdabot>   Not in scope: `Data.List.map'
03:54:15 <ivanm> quicksilver: and what did you think I was referring to?
03:54:21 <quicksilver> my @. run run one
03:54:30 <quicksilver> > map
03:54:31 <lambdabot>   Ambiguous occurrence `map'
03:54:31 <lambdabot>  It could refer to either `L.map', defined at <l...
03:54:35 <ivanm> ahhh
03:54:37 <ivanm> @type map
03:54:38 <lambdabot>     Ambiguous occurrence `map'
03:54:38 <lambdabot>     It could refer to either `L.map', defined at <local>:3:0
03:54:38 <lambdabot>                           or `Prelude.map', imported from Prelude at State/L.hs:3:0-31
03:54:43 <quicksilver> > Prelude.map (+1)
03:54:44 <lambdabot>   []->
03:54:44 <lambdabot>    []
03:54:44 <lambdabot>  [-2]->
03:54:44 <lambdabot>    [-1]
03:54:44 <lambdabot>  [-2,-1]->
03:54:46 <lambdabot> [4 @more lines]
03:54:49 <ivanm> oh, that's Vic_'s fault
03:54:51 <ivanm> :m -Data.List
03:54:59 <ivanm> @type map
03:55:00 <lambdabot>     Ambiguous occurrence `map'
03:55:00 <lambdabot>     It could refer to either `L.map', defined at <local>:3:0
03:55:00 <lambdabot>                           or `Prelude.map', imported from Prelude at State/L.hs:3:0-31
03:55:05 <ivanm> or not...
03:55:07 <quicksilver> :m doesn't do anything in lambdabot I don't think
03:55:14 <quicksilver> but someone bviously @defined a map
03:55:23 <ivanm> quicksilver: yeah, didn't think it did...
03:55:28 <ivanm> L == Lambdabot or Local?
03:55:58 <Vic_> Any ideas with this problem: I'm using the fancyvrb package in Tex to make some slides about Haskell. And I can't do stuff like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10817#a10817
03:57:23 <ivanm> Vic_: I don't know what fancyvrb does, but I've used listings before for Haskell code on slides...
03:58:31 <Vic_> Ok. I'll try something else..
03:59:31 <zygoloid> @check \p xs -> L.map p xs == filter p (xs :: [Int])
03:59:32 <lambdabot>   Not in scope: `L.map'
03:59:56 <zygoloid> > L.map id [True,False,True]
03:59:57 <lambdabot>   [True,True]
04:00:02 <ivanm> zygoloid: what is this L.map you defined, and can you get rid of it please?
04:00:09 <zygoloid> ivanm: it wasn't me
04:00:17 <zygoloid> but it looks like it's filter
04:00:20 <ivanm> oh, you're just using it?
04:00:22 <ivanm> :o
04:00:26 <quicksilver> @undef
04:00:27 <Saizan_> ?type L.map
04:00:27 <zygoloid> just trying to figure out what it is :)
04:00:28 <lambdabot> Not in scope: `L.map'
04:00:29 <quicksilver> there, it's gone :)
04:00:32 <ivanm> \o/
04:00:34 <ivanm> quicksilver++
04:00:38 <quicksilver> oh, sorry. I damaged an ongoing investigation
04:00:39 <Saizan_> ?type (.)
04:00:40 <ivanm> I can never remember the name of that plugin
04:00:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:00:48 <ivanm> quicksilver: that's OK, I'm sure we'll live
04:02:57 <Vic_> \lstinputlisting{filename.hs}  could do the trick... hmm
04:03:22 <hackagebot> mmap 0.5.2 - Memory mapped files for POSIX and Windows (GracjanPolak)
04:03:57 <ivanm> Vic_: want me to upload the tex file I used for my beamer-based presentation?
04:04:03 <ivanm> I had the code directly in the slides IIRC...
04:04:25 <Vic_> ivanm: I'd appreciate it
04:05:32 <ivanm> http://dpaste.com/108055/
04:06:21 <ivanm> that uses prettified symbolic haskell
04:06:35 <ivanm> you can get rid of them by just not defining literate
04:07:13 <Vic_> Cool stuff :-D
04:14:32 <Vic_> Yeah, it did the trick. Thanks, ivanm
04:24:19 <Vic_> This line tsort (x:xs) = tsort [y | y<-xs, y>x] ++ [x] ++ tsort [y | y<-xs, y<=x] is too long for a slide. How can I cut it in two? In an elegant way ofc.
04:27:24 <byorgey> Vic_: I'd line up  [x]  and  [y | y<-xs, y<=x] underneath [y | y<-xs, y>x]
04:27:41 <Gracenotes> or go for three lines
04:28:06 <Gracenotes> ..could be extraneous
04:32:04 <ivanm> Vic_: no worries ;-)
04:33:02 <Vic_> ;-)
04:33:05 <Vic_> tsort :: Ord a => [a] -> [a]
04:33:05 <Vic_> tsort [] = []
04:33:06 <Vic_> tsort (x:xs) = tsort ( x) xs
04:33:12 <Vic_> Does the same thing, right... ?
04:33:37 <ivanm> Vic_: ummm.....
04:33:39 <ivanm> check your last line
04:34:02 <ivanm> what does "tsort ( x) xs" mean ?
04:34:37 <Vic_> Something ate the final line of my tsort. Damn
04:34:47 <Vic_> It was supposed to be a quicksort
04:34:47 <ivanm> heh
04:34:50 <Vic_> Indeed
04:34:57 <ivanm> @google haskell quicksort
04:34:59 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
04:34:59 <lambdabot> Title: Introduction - HaskellWiki
04:34:59 <ivanm> ;-)
04:35:06 <Vic_> Classic exemple :-D\
04:35:13 <quicksilver> not really quicksort, of course
04:35:15 * quicksilver ducks
04:35:24 <Vic_> Haha
04:35:52 <ivanm> quicksilver: yeah, it's not inplace
04:36:16 <quicksilver> in particular, it's the particular (inplace) swap approach that makes quicksort so very fast
04:36:40 <ivanm> quicksilver: does it really make it faster?
04:37:00 <ivanm> I mean, if we used IArray arrays for "in-place" quicksort, would a real one really be that much faster?
04:37:32 <Vic_> This looks good http://pastebin.com/d3ac0cd64
04:37:47 <quicksilver> yes.
04:38:04 <quicksilver> the haskell not-really-quick-sort is more like a merge sort, in its constant factor
04:38:24 <quicksilver> but, it retains the disadvantages of quicksort (pivot choosing problems, bad worst case behaviour)
04:38:47 <Saizan_> (with IArrays it's be faster to use something like tsort above than repeated swaps)
04:40:00 <Vic_> Ooor, this one  qs (x:xs) = (qs $ filter (x) xs)
04:40:03 <ivanm> Saizan_: oh, right
04:40:07 <Vic_> Beutiful
04:40:11 <ivanm> since for every "swap" you're re-writing the array
04:40:14 <Vic_> *Beautiful
04:40:24 <ivanm> Vic_: ummmm..... filter (x) ?
04:40:43 <ivanm> that only works if xs :: [a -> Bool] ...
04:40:51 <ivanm> @djinn a -> Bool
04:40:52 <lambdabot> f _ = False
04:41:00 <Vic_> Right.
04:41:01 <ivanm> I was thinking const True, myself...
04:41:23 <quicksilver> IArray merge sort is probably ok
04:41:26 <ivanm> Vic_: slightly optimize your quicksort: [x] ++ == x : ;-)
04:41:31 <quicksilver> although I don't know if it's better than list merge sort
04:41:33 <quicksilver> (probably not?)
04:41:51 <Vic_> Code-golfing quicksort
04:42:01 <Saizan_> ?type \(x:xs) -> filter x xs
04:42:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> Bool
04:42:02 <lambdabot>       Expected type: [a]
04:42:02 <lambdabot>       Inferred type: [a -> Bool]
04:42:29 <ivanm> Vic_: not quite... you can't consider it code golfing until we have it pointfree! ;-)
04:42:58 <ivanm> Saizan_: I'm guessing it's still considering the xs on the RHS to be just [a], whereas the x forces it to be a -> BOol
04:43:00 <quicksilver> (I had assumed ivanm meant MArray)
04:43:13 <ivanm> quicksilver: *nod*
04:43:22 <ivanm> MArray... is that in ST or something?
04:43:24 <ivanm> or IO?
04:43:41 <Vic_> ivanm: J wins. Or APL
04:43:58 <ivanm> not for readability ;-)
04:44:08 <ivanm> @where shootout
04:44:09 <lambdabot> http://shootout.alioth.debian.org/
04:44:24 <ivanm> they now use ubuntu and not gentoo? :o
04:44:27 <quicksilver> ivanm: MArray is a class.
04:44:32 <ivanm> how is _that_ meant to prove anything?
04:44:34 <quicksilver> ivanm: IOArray and STArray are instances
04:44:35 <ivanm> quicksilver: oh...
04:44:38 <ivanm> mutable arrays in general?
04:44:42 <ivanm> @hoogle MArray
04:44:42 <lambdabot> module Data.Array.MArray
04:44:42 <lambdabot> Data.Array.MArray class Monad m => MArray a e m
04:44:42 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
04:44:45 <ivanm> @src MArray
04:44:45 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:44:51 <ivanm> @instance MArray
04:44:51 <lambdabot> Maybe you meant: instances instances-importing
04:44:56 <ivanm> @instances MArray
04:44:57 <lambdabot> Couldn't find class `MArray'. Try @instances-importing
04:45:08 <ivanm> @instances-importing Data.Array.MArray MArray
04:45:15 <ivanm> hurry up lambdabot ...
04:46:59 <benmachine> maybe there aren't any?
04:47:06 <ivanm> @quote
04:47:06 <lambdabot> Korollary says: You know, dons actually knows your phone number. He'll be calling you soon to check whether you have any questions about monad transformers.
04:47:12 <ivanm> benmachine: looks like you're right...
04:47:27 <ivanm> hmmmm.... I wonder what it would be like to use something like criterion for the shootout...
04:49:01 <benmachine> oh hold on
04:49:10 <benmachine> @instances-importing Data.Array.IO MArray
04:49:11 <lambdabot> IOArray e IO, IOUArray Bool IO, IOUArray Char IO, IOUArray Double IO, IOUArray Float IO, IOUArray Int IO
04:49:21 <benmachine> @instances-importing Data.Array.ST MArray
04:49:22 <lambdabot> STArray s) e (ST s, STUArray s) Bool (ST s, STUArray s) Char (ST s, STUArray s) Double (ST s, STUArray s) Float (ST s, STUArray s) Int (ST s
04:49:23 <benmachine> etc.
04:49:28 <stanv> how to repeat n-times function to some argument ?
04:50:09 <ivanm> stanv: what do you mean?
04:50:15 <benmachine> stanv: various ways, but surprisingly none in the standard library as far as I know
04:50:35 <zygoloid> @type iterate ?f ?x !! ?n
04:50:36 <lambdabot> forall a. (?n::Int, ?x::a, ?f::a -> a) => a
04:50:44 <benmachine> > foldr (.) id . replicate 10 (*2) $ 2
04:50:45 <lambdabot>   Couldn't match expected type `a -> [b -> b]'
04:50:45 <lambdabot>         against inferred type ...
04:50:48 <benmachine> oh bum
04:51:01 <benmachine> > foldr (.) id (replicate 10 (*2)) $ 2
04:51:02 <lambdabot>   2048
04:51:06 <zygoloid> > iterate (*2) 1 !! 10
04:51:08 <lambdabot>   1024
04:52:08 <benmachine> > iterate (. (*2)) id !! 10 $ 2
04:52:09 <lambdabot>   2048
04:52:13 <benmachine> :P
04:53:17 <stanv> how to APPLY n-times function to some argument ?
04:53:25 <benmachine> > runEndo . mconcat . replicate 10 . Endo (*2) $ 2
04:53:26 <lambdabot>   Not in scope: `runEndo'
04:53:32 <benmachine> oh what it is
04:53:34 <benmachine> *is it
04:53:43 <dolio> appEndo
04:53:44 <benmachine> > appEndo . mconcat . replicate 10 . Endo (*2) $ 2
04:53:45 <lambdabot>   Couldn't match expected type `a -> Data.Monoid.Endo a1'
04:53:45 <lambdabot>         against inf...
04:53:49 <benmachine> bah
04:53:50 <stanv> suppose function signature is foo :: a -> a
04:54:11 * benmachine suspects he is being lazy with parentheses
04:54:43 <benmachine> > appEndo (mconcat . map Endo $ replicate 10 (*2)) $ 2
04:54:44 <lambdabot>   2048
04:54:49 <benmachine> there we go.
04:54:59 <benmachine> > appEndo (mconcat $ replicate 10 (Endo (*2))) $ 2
04:55:00 <lambdabot>   2048
04:55:25 <benmachine> stanv: lots of ways of doing it
04:55:37 <burp> @hoogle Endo
04:55:38 <benmachine> > appEndo (mconcat $ replicate 10 (Endo f)) $ 2
04:55:39 <lambdabot> Data.Monoid newtype Endo a
04:55:39 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
04:55:39 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
04:55:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:55:39 <lambdabot>    `SimpleReflect.FromExpr ...
04:55:40 <stanv> i want most short
04:55:42 <benmachine> aw
04:56:08 <benmachine> stanv: I don't think there's a standard way, but we've given you about four and you can pick whatever you like
04:56:48 <benmachine> :t \f -> appEndo (mconcat (repeat f))
04:56:49 <lambdabot> forall a. Endo a -> a -> a
04:56:52 <stanv> benmachine: ok, thanks :)
04:57:03 <benmachine> eerm
04:57:06 <benmachine> :t \f -> appEndo (mconcat (repeat (Endo f)))
04:57:07 <lambdabot> forall a. (a -> a) -> a -> a
04:57:31 <benmachine> what was I trying to do?
04:57:34 <benmachine> I've forgotten
04:57:44 <benmachine> I think I was trying to make fix
05:00:46 <zygoloid> > (appEndo . mconcat . replicate 10 $ Endo (*2)) 2
05:00:47 <lambdabot>   2048
05:01:10 <quicksilver> > appEndo (mconcat (repeat (Endo (:1))))
05:01:11 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
05:01:26 <quicksilver> > appEndo (mconcat (repeat (Endo (1:))))
05:01:32 <zygoloid> also, no instance for Num [a] :)
05:01:32 <lambdabot>   mueval: ExitFailure 1
05:02:07 <benmachine> > foldr (.) id $ repeat (1:)
05:02:11 <lambdabot>   mueval-core: Time limit exceeded
05:02:38 <zygoloid> > take 10 $ (appEndo . mconcat . repeat $ Endo (1:)) undefined
05:02:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
05:02:40 <benmachine> oh hmm
05:03:01 <quicksilver> > appEndo (mconcat (repeat (Endo (1:)))) undefined
05:03:02 <benmachine> > take 20 . foldr (.) id $ repeat (1:)
05:03:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:03:03 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> b'
05:03:05 <quicksilver> ah yes
05:03:12 <quicksilver> it was the bogus show instance for functions confusing me
05:03:13 <benmachine> er, wups
05:03:14 <zygoloid> i guess the show instance for functions isn't lazy enough :)
05:03:15 <quicksilver> lambdabot--
05:03:22 <ivanm> :o
05:03:34 <benmachine> > foldr (.) id . repeat (1:) $ undefined
05:03:35 <lambdabot>   Couldn't match expected type `a -> [b -> b]'
05:03:35 <lambdabot>         against inferred type ...
05:03:41 <benmachine> oh
05:03:50 <benmachine> > (foldr (.) id $ repeat (1:)) undefined
05:03:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:03:55 <benmachine> there we go
05:05:16 <jokerGTA> how to pass result of function1 to function2 as second parametar [function1 a][function a b]
05:05:28 <jokerGTA> if thats list of functions
05:05:39 <stanv> benmachine: why you put `$' before 2 ? it works without `$'
05:06:06 <benmachine> stanv: I don't do everything right
05:06:27 <quicksilver> benmachine: why don't you do everything right?
05:06:39 * quicksilver requests an updgraded benmachine 
05:06:41 <stanv> :D
05:07:17 <stanv> I want personal copy of benmachine too :)
05:07:24 <jokerGTA> actually it should be like this [(function1 a)(function a b)]
05:07:46 * benmachine feels loved, sort of
05:07:52 <quicksilver> jokerGTA: which is a list of functions? both of them?
05:08:08 <quicksilver> jokerGTA: if you just want to pass the result of a function to another, you just do "function1 a (function 2 a b)"
05:08:09 <jokerGTA> [(function1 a),(function a b)]
05:08:25 <jokerGTA> i cant do that i have like 9 of these functions
05:08:31 <quicksilver> list of pairs?
05:08:43 <jokerGTA> sorry it was typo..its not list of pars
05:08:47 <jokerGTA> just list of functiosn
05:08:58 <quicksilver> hmm
05:09:08 <quicksilver> you want to apply each function to the result of the next one?
05:09:29 <jokerGTA> each result of function to be applied to next function in the list
05:09:44 <jokerGTA> i have 2 types of functions and they both have same return type
05:10:27 <quicksilver> > foldr (.) id [(*4),(+4),(*3)] $ 1
05:10:28 <lambdabot>   28
05:10:33 <quicksilver> that's a list of functions
05:10:37 <jokerGTA> [(function1 a),(function a b),(function1 a),(function a b),(function a b),(function a b)]
05:10:45 <quicksilver> but I think you have to show an example of what you're trying to do
05:11:08 <stanv> quicksilver: why you put $ before 1 ?
05:11:12 <burp> lol
05:11:20 <quicksilver> emphasis, I guess
05:11:24 <quicksilver> it's not necessary
05:11:39 <stanv> ah
05:11:42 <jokerGTA> i thought i could use fold but i got all lost trying to do it
05:11:42 <jokerGTA> lol
05:11:45 <psc_> is the (.) necessary?
05:11:52 <psc_> and, if so, why?
05:11:55 <psc_> what does it do?
05:12:00 <burp> I'd prefer to write foldr (.) id [(*4),(+4),(*3)] $ id $ 1
05:12:02 <jokerGTA> everyfunction returns same type
05:12:12 <jokerGTA> so i want to execute each function in sequence
05:12:36 <burp> execute an IO action?
05:12:45 <jokerGTA> reun function one ...then feed result of that function to function 2...then feed result of that function to the third function in the list..until end of the list
05:12:56 <burp> then you take that foldr approach
05:12:58 <jokerGTA> no its not IO ...just regular functions
05:13:24 <jokerGTA> you see i ised fold approach before but never applied it with list of functions
05:13:39 <psc_> but your functions have different numbers of input arguments. can you really use fold then?
05:13:41 <sohum> is List a typeclass? i.e., can I use the list syntax ([5], etc) for other things?
05:14:01 <stanv> > foldr1 (.) (replicate 10 (*2)) 2
05:14:02 <lambdabot>   2048
05:14:05 <stanv> ha-ha
05:14:07 <jokerGTA> i thought if i put them in bracket that it would do it
05:14:41 <byorgey> sohum: unfortunately, no.
05:15:14 <jokerGTA> foldr has one the parametars function.....so what would i use then
05:15:24 <byorgey> sohum: although there is a package on hackage with a type class for list-like things, called... ListLike
05:15:36 <byorgey> sohum: but it still doesn't allow you to use the [x,y,z] syntax.
05:15:51 <sohum> byorgey: booo. Ok, so I can import Prelude hiding (++)... is the wrapping behaviour of [] part of the syntax or can I define my own {}-behaving fn?
05:17:28 <byorgey> no, it's part of the syntax.  you can't define your own bracket-like syntax.
05:17:40 <byorgey> well, not yet; someone proposed such a thing the other day.
05:17:54 <sohum> oh?
05:19:18 <byorgey> I can't find it ATM.
05:19:31 <byorgey> anyway, I guess you could also look at quasiquotation: http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html#th-quasiquotation
05:19:37 <byorgey> but it may be more trouble than it's worth.
05:24:29 <sohum> byorgey: hm, thanks.
05:24:49 <sohum> also, is there any way to import hiding but still allow that function to be accessed by qualified name?
05:29:02 <quicksilver> sohum: yes, import it twice.
05:29:12 <quicksilver> import Foo hiding (bar)
05:29:29 <quicksilver> import qualified Foo(bar) as Secret.Location.Of.Foo.Known.Only.To.Select.Few
05:30:02 <sohum> quicksilver: aah, perfect, thanks
05:30:09 <sohum> that's actually quite clever
05:31:06 <quicksilver> why, thank you.
05:36:16 <ivanm> quicksilver: though is there usually any point in specifying a particular function when importing qualified?
05:37:21 <Tobsan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10820#a10820
05:37:30 <Tobsan> can this code be realized in some setting?
05:37:52 <ivanm> Tobsan: what do you mean?
05:37:53 <quicksilver> ivanm: always good to document which parts of an API you actualy use
05:37:58 <Tobsan> What I want to do is to make a fold over a constructor, applying it to each element in the list
05:38:02 <quicksilver> ideally all import lists would be explicit.
05:38:11 <quicksilver> > map Just [1,2,3]
05:38:12 <lambdabot>   [Just 1,Just 2,Just 3]
05:38:12 <ivanm> quicksilver: true; it just seems slightly superfluous if you're imporing qualified
05:38:20 <Tobsan> so if i have a constructor that has 100 arguments, I want to just supply the constructor, and the list of arguments
05:38:28 <ivanm> Tobsan: I don't think you can construct such a function
05:38:32 <Tobsan> :(
05:38:34 <dolio> You can't do that in Haskell easily.
05:38:41 <Tobsan> That would be a handy function!
05:38:45 <ivanm> 2nd class types?
05:38:55 <quicksilver> no it wouldn't, it would be a disaster
05:39:06 <quicksilver> (unless your type-system was able to specify lists of length 100. perhaps)
05:39:11 <ivanm> Tobsan: it looks like a fold with the base case passed in last...
05:39:16 <Jedai> Tobsan: so you would write a constructor with 100 arguments ???
05:39:24 <Tobsan> Jedai: no, that was just an example :P
05:39:36 <Tobsan> I have something like...8 arguments
05:39:47 <Tobsan> and I happen to have them in a list!
05:39:48 <Jedai> Tobsan: If they're of the same type they're better off in a list, if not you can probably structure them better
05:40:33 <Jedai> Tobsan: so they're all of the same type, do they play different roles ?
05:40:47 <jokerGTA> quicksilver http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4408#a4408
05:41:00 <Tobsan> Jedai: yes, but they mean slightly different things
05:41:24 <Tobsan> so each element in the list has similar usage, but is still different
05:41:26 <Tobsan> eh..sort of
05:42:12 <Tobsan> Well, we will do fine with a list actually
05:42:29 <Tobsan> but it would have been a cool function
05:42:54 <Jedai> Tobsan: if you have a fixed number of element a list isn't the correct structure, an array would probably fare better
05:43:08 <Tobsan> Jedai: hmm maybe
05:43:34 <Jedai> how did they get in a list in the first place, that may be the problem
05:44:04 <Tobsan> they were produced by replicateM, so I don't find that to be a problem actually
05:46:19 <Jedai> you may be in a corner case where what you described could be useful I guess... It may be possible with one of the generic library but probably not really worth it. If you need it several time you could write a converting function
05:46:28 <quicksilver> jokerGTA: the things in that long list are all of type MyType3
05:46:31 <quicksilver> jokerGTA: they are not functions
05:46:35 <quicksilver> they cannot be applied..
05:46:41 <bastl> hi all
05:46:53 <jokerGTA> they all return type is MyType3
05:46:53 <Tobsan> Hi bastl
05:47:02 <quicksilver> jokerGTA: yes.
05:47:14 <quicksilver> jokerGTA: (function1 a) is not a function
05:47:22 <bastl> can someone give advice how to do MVC with gtk2hs?
05:47:24 <quicksilver> jokerGTA: you've given it an argument - it is now a 'MyType3'
05:47:35 <bastl> (i have to give a small informal talk on that subject)
05:47:55 <jokerGTA> function1 takes MyType3 as argument and returns MyType as well
05:48:02 <dcoutts> bastl: I'm not sure I can claim to really understand MVC
05:48:06 <jokerGTA> returns MyType3 as well
05:48:15 <bastl> dcoutts: hehe, me neither :-)
05:48:26 <dcoutts> bastl: most GUI toolkits slightly merge the view with the controller
05:48:35 <quicksilver> jokerGTA: yes.
05:48:45 <quicksilver> jokerGTA: in "function1 a" you have already given it the argument
05:48:50 <bastl> in OO, the trick is to decouple the datamodel (with state!) from its presentation (some GUI widget, also with state)
05:48:58 <jokerGTA> yes i did inside the list yes....
05:48:59 <quicksilver> jokerGTA: therefor "function1 a" is not a function. it is a return value.
05:49:01 <jokerGTA> i didnt know better
05:49:09 <jokerGTA> i just wanted to show you the list of function
05:49:10 <dcoutts> bastl: by having a widget/control that provides methods that affect the display/view, as well as setting callbacks for when the user prods the widget in various ways.
05:49:18 <jokerGTA> i dont know if its correct to do list of functions like that
05:49:19 <bastl> in gtk2hs i build some treeStore. But should I manipulate that model, or the underlying "Tree String" !?
05:49:33 <quicksilver> jokerGTA: ok, maybe you meant [function1, function2 b, function1, function1, function2 b]
05:49:43 <Vic_> Choices, choices. What to read first:  http://img169.imageshack.us/img169/8192/books.png  (Hutton's book looks pretty darn good; also RWH)
05:49:46 <dcoutts> bastl: you can manipulate the Tree String all you like, it won't do anything :-)
05:49:52 <quicksilver> jokerGTA: those are all functions of type MyType3 -> MyType3
05:50:01 <bastl> dcoutts: exactly: so how to do it "right" !?
05:50:15 <quicksilver> jokerGTA: so that would be a list [MyType3 -> MyType3]
05:50:19 <jokerGTA> no function1 takes beside MyType3 it takes another argument...so function1 takes 2 arguments
05:50:31 <bastl> precisely: with what "model" should I work in the application !?
05:50:41 <jokerGTA> but both function return type is MyType3
05:50:47 <bastl> (Tree String) or TreeStroreSomething ?
05:51:33 <dcoutts> bastl: I prefer to keep the real model as pure Haskell data structures, eg held in a recursive event loop thread or an IORef
05:51:48 <dcoutts> bastl: and then when responding to events, to update the view
05:52:03 <quicksilver> jokerGTA: to be honest, I don't think you fully understand the question you are asking.
05:52:10 <quicksilver> jokerGTA: I think you should try it out and see where you get to
05:52:15 <bastl> dcouuts: yeah, thats what I would do (and do) to, but it somehow breaks the decoupling idea ...
05:52:17 <quicksilver> there is only so far you can get with made-up types.
05:52:17 <dcoutts> bastl: so in that situation I consider the TreeStore to actually be part of the view, not part of my canonical app state.
05:52:27 <bastl> hmmm.
05:52:29 <dcoutts> bastl: does it? how so?
05:52:49 <bastl> i have to take action to update the view.
05:53:32 <jokerGTA> i did something similiar with foldr but wasnt dealing with the list of function...i just had list of numbers...where i would applie some function to each number in the list
05:53:44 <bastl> the thing is that the data has state. which collides to haskell core paradigms.
05:54:09 <bastl> interesting anyhow. have to think about it ...
05:54:12 <dcoutts> bastl: of course you must update the view, that's essential.
05:54:20 <dcoutts> bastl: that's what your OO things do too
05:54:27 <jokerGTA> now i have list of functions where result of fist function i want to apply to second function.result of second function apply to third function in the list....then result of forth function aooly to fifth in the list
05:55:05 <dcoutts> bastl: you send a command to the model "change thyself" and it then moves into a new state and informs the views that are watching it.
05:55:21 <quicksilver> jokerGTA: I already showed you the answer to that.
05:55:34 <quicksilver> > foldr (.) [(*4),(+1),(*2),(+3)] 1
05:55:35 <lambdabot>   No instance for (GHC.Num.Num [(a -> a) -> a -> a])
05:55:35 <lambdabot>    arising from the lite...
05:55:40 <quicksilver> > foldr (.) id [(*4),(+1),(*2),(+3)] 1
05:55:41 <lambdabot>   36
05:55:47 <quicksilver> jokerGTA: you just need to try it, I think. it works.
05:56:06 <paolino> I'd like someone to tell me if I got inversion of control totally wrong here : http://wiki.github.com/paolino/michelle
05:56:18 <jokerGTA> oh yes i saw that....i was just wondering if there is neater way to do it
05:56:43 <jokerGTA> that way it will need 5 lines of code to nest them like that
05:57:25 <dcoutts> bastl: classic MVC is probably more natural in a OO imperative setting because you're used to mutating object states. Having things so that mutating an object state has the side effect of updating the view then becomes fairly natural.
05:57:37 <dcoutts> bastl: but we'd prefer to have a pure state
05:57:45 <bastl> dcoutts: sorry, collegues in my office.
05:58:11 <dcoutts> bastl: then the "update the view, based on this new state" is more explicit, rather than implicit in the state object mutation.
05:58:13 <jokerGTA> you meant this -> you just do "function1 a (function 2 a b)"
05:58:18 <quicksilver> jokerGTA: no.
05:58:22 <quicksilver> jokerGTA: what I just typed.
05:58:26 <quicksilver> > foldr (.) id [(*4),(+1),(*2),(+3)] 1
05:58:27 <lambdabot>   36
05:58:37 <quicksilver> jokerGTA: that applies a list of functions, each to the result of the next.
05:59:20 <Vic_> Interesting... how does this work, more exactly? foldl (.) id [(*1),(+1),(*1),(+1),(/2)] 2    (how can I do it with pencil/paper)
05:59:29 <bastl> dcoutts: but the implicit thing "the view updates autmatically" is *very* comfortable
05:59:38 <cocon> is there such a thing as curried arrows?
05:59:40 <jokerGTA> foldr (.) id [(function1),(function2),(function1),(function1)] 1
05:59:43 <jokerGTA> ?like that
05:59:43 <lambdabot> Maybe you meant: dice elite list time wiki
05:59:59 <bastl> but view update as side-effect is probably the right answer
06:00:10 <jokerGTA> but wbut function1 has 2 parametars
06:00:57 <Vic_> Ah... got it. ((2*1+1)*1)+1 all /2 = 2
06:01:19 <Vic_> *3
06:01:38 <dcoutts> bastl: you can do it in the exact same way, but it means having to concoct an extra mutable object
06:02:24 <bastl> dcoutts: which would be ?
06:02:40 <dcoutts> bastl: your state object, the thing holding the state
06:02:42 <jokerGTA> sorry quicksilver...could you just explain how does that word since you have only one parametar in each of those functions...like (*4)->thats one function and one parametar i am assuming
06:02:46 <bastl> ah
06:03:04 <bastl> well, for the talk ill stick to gtk2hs's demos ...
06:03:20 <dcoutts> bastl: they're not especially clever when it comes to handling app state
06:03:58 <bastl> dcoutts: they dont have any in general. I had a look at leksah which looks very good in that respect.
06:04:02 <dcoutts> bastl: I wouldn't show them off as prime examples of elegant scalable state management
06:04:55 <dcoutts> bastl: I've recently been writing a GUI app using gtk2hs. I'm using a scheme using threads, event queues and event loops.
06:05:29 <bastl> Got a blog?
06:05:57 * bastl is very interested in "design" issues of FP programs
06:06:03 <dcoutts> bastl: yes, but I've not been writing about this app, I've got an 18-page NDA :-(
06:06:15 <ttt--> are there any UIs written in haskell?
06:06:25 <dcoutts> ttt--: yes
06:06:37 <Axman6> written in haskell alone?
06:06:42 <ttt--> yah
06:06:45 <bastl> ttt--: look at leksah
06:06:49 <Vic_> Like wxHaskell  or qtHaskell
06:07:02 <dcoutts> ttt--: how "alone" do you mean?
06:07:08 <Vic_> Pure.
06:07:10 <dcoutts> like raw X messages? :-)
06:07:45 <Axman6> well, not a binding to a C framework
06:07:58 <Vic_> Ah
06:08:11 <bastl> dcoutts: I read in an old IRC-chat how you called gtk2hs "midlevel". But i think we need something more highlevel, perhaps on top of gtk2hs ?
06:08:26 <ddarius> ttt--: Fruit drew its own UI, but it was built over a Java 2D graphics library.
06:08:46 <dcoutts> bastl: right, it doesn't give you any framework for managing app state, it just gives you the input and the output.
06:09:11 <dcoutts> bastl: fortunately, building something on top isn't so hard.
06:09:24 <quicksilver> jokerGTA: a function is a function.
06:09:25 * ddarius is "working" on a library of concurrent GUI components.
06:09:29 <bastl> dcoutts: ok, so wheres the cabal-package ?
06:09:30 <quicksilver> jokerGTA: (+1) is a function.
06:09:32 <Philippa> dcoutts: I've used a scheme that meets the above description btw, ended up bordering on erlangish threads-as-frequent-as-objects stuff which worked nicely
06:09:41 <Philippa> (it wasn't big enough to really stress the scheduler!)
06:09:47 <quicksilver> jokerGTA: (it was generated from another function (+), by setting one parameter but that's not the point)
06:09:54 <ddarius> Philippa: Yep.
06:09:55 <dcoutts> bastl: though what exactly that should look like is not something everyone agrees on
06:10:10 <dcoutts> Philippa: right
06:10:11 <quicksilver> jokerGTA: importantly, from your example "function1 a" is *NOT* a function.
06:10:12 * ddarius likes Pike's, "A Concurrent Window System" and the cml library is nice.
06:10:33 <bastl> well, someday, the need will be there and someone comes up with something easy to use.
06:10:37 <quicksilver> jokerGTA: "function1 a" is not a function. "function1" is a function. (1+4) is not a function. (+4) is a function.
06:10:51 <jokerGTA> oh i see what you mean..sorry man....
06:10:56 <quicksilver> jokerGTA: you need to play with ghci and examine the types of things for a bit and it will *click* and suddenly become obvious :)
06:11:00 <ddarius> bastl: There will never be a "need"
06:11:18 <bastl> ddarius: I have the need, but i am alone ...
06:11:24 <jokerGTA> like i got this working by nesting calls inside each other with no problem
06:11:26 <dcoutts> bastl: it's not like you need something complex, the "state framework" bit of my GUI is only about 20 lines
06:11:34 <jokerGTA> without using list
06:11:40 <bastl> ddarius: i switched to haskell, and now to imperative programming in IO using gtk2hs
06:11:45 <jokerGTA> but i want to do it with lists to see how it works
06:11:46 <bastl> *do
06:11:52 <Philippa> dcoutts: you realise what response that's asking for, right? :-)
06:12:09 <dcoutts> Philippa: uh oh, what? :-)
06:12:25 <Philippa> dcoutts: "so it wouldn't be hard to factor out and cabalise, would it?"
06:12:43 <ddarius> bastl: Indeed.  It's not much better than anything else, but it isn't worse and people have been reasonably happy with the extant GUI libraries (in general) so far.  There's certainly a -desire- for something better.
06:12:52 <dcoutts> there would hardly be any code left
06:13:11 <Philippa> yeah, I know the feeling. Sometimes the signatures're what interest people though
06:13:11 <Twey> quicksilver: It's a function of zero arguments!  ;)
06:13:20 <quicksilver> Twey: hush. THat is not a haskell notion.
06:13:29 <Philippa> anything that gives them enough framework to hang helper functions off
06:13:33 * Twey chuckles.
06:13:34 <ddarius> Philippa: I should send you the code I am (was) playing with.
06:13:39 <quicksilver> haskell functions have type (a -> b) for some a and b
06:13:52 <Axman6> bloody hell, there's a Haskell Coding wave on Google Wave, and it's got 263 people in it. good stress test i guess
06:13:54 * tibbe just announced a hackathon this March in Zurich
06:14:07 <quicksilver> Axman6: how do I find it?
06:14:15 <PetRat> What's the difference between runhaskell and typing ghc or ghci directly?
06:14:32 <Axman6> search for haskell ... and i think with:public
06:14:34 <Philippa> ddarius: sure! Anything in particular you'd like me to try doing with it? (aside from cursing and setting up a GHC 6.10.3 environment again because it's probably easier than building gtk2hs on a windows machine with no MSYS etc)
06:15:02 <dcoutts> tibbe: woo hoo!
06:15:08 <quicksilver> Philippa, dcoutts : in my experience when you try to 'abstract' smoething like that you end up with something so abstract it's actually hard for the target audience to understand how to use it.
06:15:17 <tibbe> dcoutts: :)
06:15:23 <quicksilver> it's actually easier to have a cookbook recipe - in the docs or on the wiki - for "how to do things like this"
06:15:28 <dcoutts> quicksilver: right, a small example is probably more enlightening
06:15:49 <Philippa> mmm. Now, dumping those 20 lines onto a wiki page is probably even easier?
06:15:53 <Vic_> "The rest of the book is a cookbook"
06:16:29 <Axman6> quicksilver: if you can't find it, just add me as a contact and i'll put you in it (axman6@gmail.com)
06:16:39 <Vic_> And I finally got that Google Wave invitation. W00t.
06:17:00 <ddarius> Philippa: Nothing in particular.  If you have any comments after looking at it, I'd be interested.  My intent is to (also) have another layer on top that draws its own GUI.
06:17:19 <cocon> is there such a thing as curried arrows? (****) : a b c d -> a b' c' d' -> a (b,b') (c,c') (d,d')
06:18:37 <PetRat> What's the difference between runhaskell and typing ghc or ghci directly?
06:18:58 <Philippa> runhaskell might point to a different implementation
06:19:01 <seanmcl> why does the following program need -XImpredicativeTypes:
06:19:02 <seanmcl> type A = Eq a => a -> a
06:19:02 <seanmcl> l :: [A]
06:19:03 <seanmcl> l = []
06:19:44 <Philippa> because A is "really" forall a. Eq a => a -> a, and [A] is thus [forall a. Eq a => a -> a]
06:20:13 <seanmcl> but a -> a is "really" forall a. a -> a
06:20:23 <seanmcl> and [forall a. a -> a] is not a problem
06:20:36 <Philippa> you're missing some steps :-)
06:20:39 <PetRat> Philippa: thanks. is that just part of it, or are you telling me the purpose of runhaskell is to specifiy the GHC version?
06:20:51 <Axman6> hmm, does that mean you could then have [(+1),show :: String -> String]?
06:20:53 <Axman6> hmm, no
06:20:58 <seanmcl> oh, sorry
06:21:00 <Philippa> [a -> a
06:21:09 <Philippa> [a -> a] is really forall a. [ a -> a], however
06:21:13 <seanmcl> right, the abstraction takes place first in the type abbreviation
06:21:42 <seanmcl> I see.  Thanks!
06:21:46 <Philippa> PetRat: runhaskell's equivalent to a specific parameter combination for ghc(i) that actually runs the program instead of loading or compiling it
06:22:00 <benmachine> PetRat: on my system, runhaskell is basically a wrapper to feed a script to ghci, run main, and exit
06:22:12 <seanmcl> that's kind of weird that you can write type A = Eq a => a -> a, but not type A = a -> a
06:22:54 <seanmcl> i'm an idiot
06:22:55 <seanmcl> sorry
06:23:02 <seanmcl> you'd write type A a = a -> a
06:23:20 <jokerGTA> silver fox in your example foldr (.) id [(*4),(+1),(*2),(+3)] 1.....could you do this foldr (.) id [(function1),(function2 b)] 1
06:23:41 <PetRat> Philippa: I see. I found a paragraph in RWH that uses it, and I see now that they want to demonstrate the program output and nothing else, so the fewest steps for them to list would be using runhaskell (which is one step).
06:24:08 <Philippa> seanmcl: it's okay, it's an easy mistake to make. You should see the mess I made with type synonyms last weekend
06:25:16 <seanmcl> Philippa: :) thanks.  I need to go back now and change some stuff.  I didn't realize Type classes bind the variables.
06:25:36 <seanmcl> I have a bunch of useless type variables sitting around, like type A a = Eq a => ...
06:25:42 <benmachine> jokerGTA: as long as the types are all correct
06:27:58 <ddarius> Philippa: Actually it might need a slightly modified CML library if they haven't applied to patch I sent.
06:28:41 <ddarius> Okay, he did.
06:29:19 <tibbe> Guess I should post the URL as well...
06:29:52 <tibbe> There'll be a hackathon this March in Zurich, Switzerland: http://haskell.org/haskellwiki/ZuriHac Please add your name if you might be interested in attending.
06:37:51 <seanmcl> Is there a good reason to put class restrictions in the class declaration rather than putting them in each method body?  e.g. class A a => B a where f :: a -> a rather than class B a where f :: A a => a -> a?
06:38:26 <seanmcl> Is it so you can do "class inference"
06:38:30 <Axman6> i think the former is preferred
06:38:35 <Axman6> @src Floating
06:38:35 <lambdabot> class  (Fractional a) => Floating a  where
06:38:35 <lambdabot>     pi                                                      :: a
06:38:35 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
06:38:35 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
06:38:35 <lambdabot>     (**), logBase                                           :: a -> a -> a
06:38:45 <seanmcl> I'm just wondering if they're identical or not
06:39:16 <Axman6> actually, it may not even be legal to do it your way
06:39:27 <dolio> If you put them on the class, then you only have to list B, not both A and B.
06:42:57 <dolio> That's why Show is a superclass of Num, as I recall. So you don't have to put (Show a, Num a) =>.
06:43:02 <dolio> As terrible a reason as that is.
06:43:24 <aavogt> does it change the kinds of default methods allowed?
06:43:35 <Twey> Hey, can we get rid of that once class aliases come along?
06:44:40 <dolio> As Axman6 noted, putting extra contexts on class parameters isn't actually allowed without GHC extensions, either.
06:44:58 <Axman6> i was right? hooray :)
06:45:15 <dolio> That doesn't explain Show a => Num a, though.
06:45:28 <Axman6> @src Num
06:45:28 <lambdabot> class  (Eq a, Show a) => Num a  where
06:45:28 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:45:28 <lambdabot>     negate, abs, signum     :: a -> a
06:45:28 <lambdabot>     fromInteger             :: Integer -> a
06:45:32 <fasta> Why is there no way to refer to an identifier in the current module in some easy way? Or to make it the default for disambiguation?
06:45:33 <Axman6> indeed
06:46:22 <fasta> If you have Foo.x and Bar.x in scope, and you are in Foo, it would be better if x referred to Foo.x.
06:46:25 <jokerGTA> what does "id" stand for here -> foldr (.) id [(*4),(+1),(*2),(+3)] 1
06:46:41 <fasta> \x -> x
06:46:44 <fasta> ;)
06:46:49 <aavogt> jokerGTA: foldr (.) 1 [ ... ] -- is the same thing
06:47:05 <jokerGTA> why 1?..is 1? initial value?
06:47:26 <fasta> jokerGTA: someone constructs a function, instead of doing it in a sane way.
06:47:32 <aavogt> hmm, or it should be ($ 1)
06:47:38 <aavogt> @type foldr (.) 1
06:47:39 <lambdabot> forall b (f :: * -> *). (Functor f, Num (f b)) => [b -> b] -> f b
06:47:58 <aavogt> @type foldr (.) ($ 1)
06:47:59 <lambdabot> forall a b. (Num a) => [b -> b] -> (a -> b) -> b
06:48:01 <fasta> Basically, it's the composition of a bunch of functions. One of them is id.
06:48:48 <jokerGTA> foldr (.) id [(function1 a),(function1 a)] (someinitialvalue)
06:48:55 <jokerGTA> and it only executed it once
06:51:54 <Axman6> > foldr (.) id [(+1),(*3)] 7
06:51:55 <lambdabot>   22
06:52:30 <aavogt> > foldr (.) id [f,g,h] x :: Expr
06:52:31 <lambdabot>   f (g (h x))
06:52:46 <Axman6> blackdog!
06:52:52 <aavogt> > foldr (.) ($ x) [f,g,h] :: Expr
06:52:53 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
06:52:53 <lambdabot>         against inferred ...
06:53:07 <aavogt> > foldr (.) (\y -> y x) [f,g,h] :: Expr
06:53:08 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
06:53:08 <lambdabot>         against inferred ...
06:56:16 <byorgey> @type foldr (.) (\y -> y x)
06:56:17 <lambdabot> forall b. [b -> b] -> (Expr -> b) -> b
06:56:43 <byorgey> > f :: Expr -> Expr
06:56:44 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
06:56:44 <lambdabot>    arising from...
06:57:14 <byorgey> > foldr (.) (\y -> y x) ([f,g,h] :: Expr -> Expr) :: Expr
06:57:14 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
06:57:15 <lambdabot>                           ...
07:39:48 <benmachine> > expr $ foldr (.) ($ x) ([f, g, h] :: [Expr -> Expr])
07:39:50 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
07:39:50 <lambdabot>         against inferred ...
07:40:07 <benmachine> > expr $ foldr (.) ($ x) [f, g, h]
07:40:08 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
07:40:08 <lambdabot>         against inferred ...
07:40:20 <benmachine> > foldr (.) ($ x) [f, g, h]
07:40:21 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
07:40:21 <lambdabot>    arising from...
07:40:31 <benmachine> wat
07:40:33 <benmachine> silly show
07:40:37 <benmachine> @type foldr (.) ($ x) [f, g, h]
07:40:38 <lambdabot> forall b. (Show b, SimpleReflect.FromExpr b) => (Expr -> b) -> b
07:40:58 <benmachine> :t ($ x)
07:40:58 <lambdabot> forall b. (Expr -> b) -> b
07:41:42 <benmachine> @type foldr (.) ($ x) [f, g, h] id
07:41:43 <lambdabot> Expr
07:41:49 <benmachine> foldr (.) ($ x) [f, g, h] id
07:41:55 <benmachine> > foldr (.) ($ x) [f, g, h] id
07:41:56 <lambdabot>   f (g (h x))
07:42:09 <benmachine> > foldr (.) id [f, g, h] x
07:42:10 <lambdabot>   f (g (h x))
07:42:44 <benmachine> > foldr ($) x [f, g, h]
07:42:45 <lambdabot>   f (g (h x))
07:42:51 <benmachine> > foldr id x [f, g, h]
07:42:52 <lambdabot>   f (g (h x))
07:42:58 <benmachine> that makes sense, sort of
07:45:17 <aavogt> > foldr id x (replicate 100 id)
07:45:18 <lambdabot>   x
07:47:54 <Orclev> so, I'm reading through the documentation on using ghci for debugging, and it has an example where it makes a list containing undefined which of course throws an exception when it's evaluated... my question though is, how do you determine that undefined is bound to some variable? Is there any way to print undefined without causing an exception?
07:49:27 <Orclev> I guess you can infer that it's part of a list by using seq and seeing that it blows up with an exception about undefined, but that seems kind of awkward
07:52:35 <poe> Orclev: bottom (undefined :: forall a. a in haskell) includes non-termination, thus it's impossible to pattern-match on it in Haskell (because of the halting problem)
07:54:13 <Orclev> poe: hmm... what about testing for it with a try catch block?
07:57:44 <poe> Orclev: exceptions are caught, if that particular undefined is actually a non-termination, it'll be caught after a very long time I guess :-)
08:00:15 <blueonyx> how is one supposed to import Data.Vec? i either get ambigous occurences or not inscope, i tried it like in http://www.haskell.org/haskellwiki/GPipe :/
08:01:35 <Orclev> blueonyx: did you do the import like > import Data.Vec as Vec?
08:01:43 <blueonyx> yea
08:02:01 <blueonyx> but then i cant use 3:.4:.5:.()
08:02:52 <blueonyx> Not in scope: data constructor `:.'
08:03:28 <Orclev> I think that's because (:.) is exported by Graphics.GPipe
08:03:43 <blueonyx> oh
08:04:26 <blueonyx> but import Data.Vec ((:.)) doesnt help either
08:05:58 <Orclev> hmm, if I import Data.Vec unqualified I don't have a problem with ambiguous occurence, which other module besides Data.Vec is it complaining about?
08:06:41 <blueonyx> Prelude
08:06:59 <Orclev> I didn't think (:.) was defined in Prelude?
08:07:21 <blueonyx> but map and pack and stuff
08:07:34 <blueonyx> *and fold and length..
08:08:01 <blueonyx> in ghci i dont get ambigous occurences too
08:08:20 <Orclev> well, if you're not using the ones from Data.Vec, you could do > import Data.Vec hiding (map, pack, fold, length, etc...)
08:08:21 <blueonyx> but im compiling with --make :/
08:08:54 <fasta> blueonyx: one is not supposed to import anything in any way.
08:09:15 <blueonyx> Orclev: yea but this is cumbersome, so i thought there is a better way
08:09:25 <fasta> blueonyx: you just import it and if it clashes, you import it qualified or that with which it clashes.
08:09:41 <blueonyx> fasta: okay, rephrase: what is a good way to import Data.Vec?
08:10:04 <Orclev> fasta: how do you use ops when their imported qualified?... Vec.:.? or Vec.(:.)?
08:10:13 <blueonyx> so i import qualified as Vec and on a second line hiding the problems?
08:10:13 <Orclev> s/their/they're/
08:10:28 <fasta> blueonyx: import qualified Data.Vec.Base as VecBase is a line from my program.
08:10:58 <fasta> blueonyx: but I don't spend eons of time on these things. If it annoys me a lot after some time, I just change it.
08:11:20 <blueonyx> fasta: how you use :.?
08:11:21 <fasta> Orclev: (Vec.:)
08:11:34 <fasta> (Vec.:.)
08:11:46 <fasta> This is all documented.
08:11:50 <Orclev> fasta: does that work infix as well?
08:11:55 <fasta> No need to guess.
08:12:12 <trzkril> how about importing qualified and then importing some (non-conflicting) stuff unqualified?
08:12:21 <blueonyx> but :. is an data constructor :/
08:12:25 <fasta> Orclev: yes, but then you don't need the parens.
08:12:46 <fasta> blueonyx: a data constructor is "just another function".
08:12:53 <fasta> Nothing special.
08:13:09 <blueonyx> fasta: but import Data.Vec ((:.)) gives Not in scope: data constructor `:.' :/
08:13:22 <ski> > [0] Prelude.!! 0
08:13:22 <lambdabot>   0
08:13:41 <fasta> blueonyx: I think that's a type constructor.
08:14:43 <fasta> Ah, it's both. data a :. b = !a :. !b
08:14:47 <blueonyx> but 4:.5:.6:.() constructs data?
08:15:11 <blueonyx> ah
08:15:12 <fasta> blueonyx: what do you really want?
08:15:40 <fasta> blueonyx: since I never needed to do anything with :.
08:15:46 <blueonyx> import Data.Vec ((:.)(..))
08:16:00 <fasta> blueonyx: ?
08:16:25 <Orclev> fasta: GPipe for whatever reason uses Vec for *everything*, so you really really need :. to work with it
08:16:41 <fasta> Orclev: assumptions, assumptions.
08:16:41 <blueonyx> fasta: i needed to import the data constructor?
08:17:00 <fasta> Orclev: which function in GPipe do you want to call and what is its type?
08:17:11 <blueonyx> fasta: import Data.Vec ((:.)(..)) doesnt give Not in scope: data constructor `:.'
08:17:15 <trzkril> blueonyx: "import Data.Vec(:.(..))" did not work?
08:17:32 <blueonyx> parse error on input `:.'
08:17:37 <trzkril> hm
08:17:59 <blueonyx> thank you so far
08:19:00 <fasta> import Data.Vec((:.)((:.)))
08:19:04 <trzkril> what about "import Data.Vec.Base((:.)(..))"?
08:19:15 <fasta> This works, but again, I highly doubt that you have to do that.
08:19:27 <fasta> I really, really think you are just missing the point of the Vec library.
08:19:47 <fasta> blueonyx: which is why I asked what function you were trying to call, which you didn't answer...
08:20:49 <blueonyx> fasta: :., pack, unpack, sum and the Num instance
08:20:55 <Orclev> fasta: actually you asked me that when I think you meant blueonyx
08:21:01 <siorai_> whoever invented the term paramorphism needs to die
08:21:41 <Orclev> fasta: I've been trying to figure out why GPipe uses Vec for everything, so what is the point of the Vec library?
08:21:42 <blueonyx> trzkril: import Data.Vec((:.)((:.))) works
08:22:05 <fasta> blueonyx: ... why can't you answer a simple question?
08:22:21 <blueonyx> i did
08:22:28 <blueonyx> 17:20 < blueonyx > fasta: :., pack, unpack, sum and the Num instance
08:22:35 <fasta> blueonyx: so, you are saying pack is a function in the GPipe library?
08:22:39 <Orclev> blueonyx: he wants to know which GPipe function you're trying to use
08:22:40 <blueonyx> no
08:22:49 <blueonyx> no GPipe function
08:22:59 <fasta> blueonyx: you really didn't understand me then. Orclev did.
08:23:02 <blueonyx> i was just wondering why it works so simple in the GPipe example
08:23:32 <blueonyx> there is import Data.Vec qualified but :. is used without
08:23:34 <fasta> blueonyx: so, which function in GPipe are you trying to call and with which type?
08:23:50 <fasta> blueonyx: which example?
08:23:54 <Orclev> blueonyx: it works like that in the GPipe example because GPipe re-exports (:.)
08:24:12 <fasta> blueonyx: there is no need to wonder about those things just use :i (:.)
08:24:24 <blueonyx> fasta: http://www.haskell.org/haskellwiki/GPipe
08:24:29 <blueonyx> Orclev: yea, got that
08:24:55 <Orclev> fasta: he was confused by the example code for GPipe because it imports Data.Vec qualified, but then uses (:.) unqualified, which is possible by (:.) is re-exported by GPipe
08:25:02 <fasta> blueonyx: anyway, next time, ask the real question.
08:25:07 <fasta> Orclev: yes, I understand.
08:25:09 <blueonyx> kthx
08:26:00 <Orclev> fasta: so, back to what I asked earlyer, what is the point of Vec, and why does GPipe use it all over the place when it seems like something like a tuple might be a better choice in some places?
08:26:16 <fasta> Orclev: because a Vec is wicked fast
08:26:24 <fasta> Orclev: and safe.
08:26:53 <fasta> Orclev: I agree that a tuple is easier on the eyes.
08:27:18 <fasta> Orclev: for a better answer, ask the GPipe author.
08:27:35 <fasta> There is no reason why the API cannot be changed to tuples, other than time.
08:27:53 <fasta> E.g. RULES could be used to do everything with Vec under the hood.
08:28:06 <Orclev> I kind of get the feeling he opted to use Vec for everything for consistency
08:28:25 <fasta> Well, hard to argue with consistency, no?
08:28:49 <Orclev> no, not really, consistency for it's own sake isn't necessarily a good argument
08:29:30 <quicksilver> rules are fragile.
08:29:35 <quicksilver> Vec is for speed, I think
08:29:57 <patch-tag> I am trying to understand the monadIO instance declaration for ErrorT
08:29:59 <Orclev> yeah, plus I think the underlying design of the OpenGL API lends itself very well to Vec
08:30:04 <fasta> Yes, I have always said that I don't like RULES>
08:30:10 <patch-tag> instance (Error e, MonadIO m) => MonadIO (ErrorT e m) where liftIO = lift . ( liftIO :: ?? )
08:30:19 <patch-tag> what is the type of the liftIO in the right hand side above?
08:30:21 <fasta> I think it is an adhoc system, whereas there are also designed systems.
08:30:27 <patch-tag> can it be assigned with :: like I am trying to?
08:31:31 <fasta> patch-tag: I don't see why you would need that.
08:31:39 <fasta> patch-tag: lift . liftIO should be enough.
08:31:53 <patch-tag> it is, that's how it's defined. I just don't understand it.
08:32:23 <patch-tag> assigning types that way sometimes helps when I
08:32:27 <patch-tag> I'm stumped
08:33:12 <dcolish> so if i define a recursive list like: l n = n :  l (step n), how do i get it to stop at 1?
08:33:55 <ski> maybe you want to prepend `l 1 = ...' ?
08:34:21 <dcolish> i was thinking of using that pattern, but it gave me type issues
08:35:39 <ski> > let l 1 = [42]; l n = n : l (step n); step n | even n = n ` div` 2 | otherwise = 3*n + 1 in l 15
08:35:40 <lambdabot>   [15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,42]
08:35:52 <dcolish> heh
08:35:59 <ski> seems to work ok, here
08:36:03 <dcolish> how'd you know that is what i'm doing :)
08:36:06 <ski> what type issues did you get ?
08:36:12 <dcolish> i did l 1 =1
08:36:16 <dcolish> that was the issue
08:36:22 <dcolish> i see what i did wrong now
08:36:24 <int-e> takeWhile (/= 1) . iterate step n ?
08:36:29 * ski didn't know, Collatz just popped into mind as an example
08:36:32 <dcolish> lol
08:37:00 <dcolish> well its precisely what I am doing
08:37:33 <dcolish> ski: thanks!
08:37:44 <int-e> > let step n | even n = n `div` 2 | otherwise = 3*n + 1 in takeWhile (/= 1) . iterate step $ n
08:37:45 <lambdabot>   [n,3 * n + 1,3 * (3 * n + 1) + 1,3 * (3 * (3 * n + 1) + 1) + 1,3 * (3 * (3 ...
08:37:54 <int-e> heh.
08:38:08 <int-e> > let step n | even n = n `div` 2 | otherwise = 3*n + 1 in takeWhile (/= 1) . iterate step $ 15
08:38:09 <lambdabot>   [15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2]
08:38:11 <ski> > n /= 1
08:38:12 <lambdabot>   True
08:38:18 <dcolish> i didnt like the takeWhile since it still allows the list to be infinite
08:38:46 <dcolish> i believe the sequence is really a finite sequence
08:38:50 <int-e> ski: 1 becomes a constant, which is not equal to a variable like n. and you need an Eq instance for Num.
08:39:10 <ski> int-e : i know :)
08:39:25 <ski> (it just looked funny)
08:41:52 <hackagebot> hashed-storage 0.3.9 - Hashed file storage support code. (PetrRockai)
08:43:49 <benmachine> > compare n 1
08:43:50 <lambdabot>   GT
08:44:59 <benmachine> > compare 1 n
08:45:00 <lambdabot>   LT
08:45:04 <benmachine> 'k.
08:45:23 <benmachine> > compare n (1.0/0)
08:45:24 <lambdabot>   GT
08:45:28 <benmachine> :o
08:45:41 <opqdonut> > n
08:45:42 <lambdabot>   n
08:45:50 <benmachine> :P
08:45:53 <opqdonut> :t n
08:45:54 <lambdabot> Expr
08:45:55 <benmachine> oh hold on
08:46:02 <benmachine> > fromInteger 1 :: Expr
08:46:03 <lambdabot>   1
08:46:05 <opqdonut> the num instance for exprs must be weird
08:46:07 <benmachine> oh, yeah
08:46:25 <opqdonut> or rather, the ord one
08:46:43 <benmachine> > (1 + 1) > (1 :: Expr)
08:46:44 <lambdabot>   True
08:46:58 <benmachine> > 2 - 1 > expr 2
08:46:59 <fasta> How should I refer to a header file which is in a cabal package?
08:46:59 <lambdabot>   False
08:47:13 <fasta> Or is there no specific way to do that?
08:49:37 <benmachine> > negate n
08:49:38 <lambdabot>   negate n
08:49:44 <benmachine> > abs n
08:49:44 <lambdabot>   abs n
08:49:48 <benmachine> hmph.
08:50:15 <jkramer> Hi
08:50:20 <benmachine> > negate (negate n)
08:50:21 <lambdabot>   negate (negate n)
08:50:27 <benmachine> hi
08:50:53 <dcoutts> fasta: there's the includes field in the .cabal file
08:50:55 <jkramer> I'm trying to implement a typeclass similar to Show/Read, but I'm failing at building instances for [Char]
08:51:11 <dcoutts> fasta: and the include-dirs if it's a local header file from within the package
08:51:41 <jkramer> I've read somewhere that a workaround would be to add another function for lists (e.g. showList), but don't quite understand how this can help me
08:52:01 <dolio> jkramer: Show uses a trick for that. They make you define a 'showList :: Show a => [a] -> String' and then use showList for the [a] instance.
08:52:36 <dolio> Then you can specialize the behavior of list showing by distinguishing the behavior in the instance for a.
08:52:37 <fasta> dcoutts: but the header file comes from a different package. So, when installed it's something like .cabal/<compilerversion>/<package version>/foo.h (or the other way around)
08:52:46 <jkramer> dolio: Yup, I got this far too, but how do they call show/showList?
08:53:18 <jkramer> I mean, my implementation of "show" would have to call showList somehow if the argument is a list
08:53:24 <dcoutts> fasta: then the include dirs will be set up automatically
08:53:48 <dolio> jkramer: 'instance Show a => Show [a] where show = showList'
08:53:52 <dcoutts> fasta: so long as your package depends on the other one then any headers installed with that package will be available
08:54:25 <jkramer> dolio: Oh... It's so simple, I'm feeling stupid right now :)
08:54:36 <dolio> > read "['a','b','c']" :: String
08:54:37 <lambdabot>   "abc"
08:54:48 <dolio> I'm not really sure if read does the same thing.
08:55:01 <dolio> I guess it does.
08:56:58 <jkramer> dolio: It works, thanks a lot :)
08:57:29 <dolio> No problem.
08:59:36 <EvilMachine> hello. :)
09:00:10 <EvilMachine> hey, i finally noticed, that <- is the opposite to do
09:00:18 <EvilMachine> but my realization has one problem:
09:00:29 <jmcarthur_work> the opposite?
09:00:58 <EvilMachine> <- can only do one monad output action
09:01:18 <EvilMachine> well, if you see do as a way to put things in a monad
09:01:31 <jmcarthur_work> that's not what do is ;)
09:01:37 <EvilMachine> Im not speaking in a totally literal sense by the way
09:01:41 <jmcarthur_work> that's return
09:01:46 <EvilMachine> oh.
09:01:48 <EvilMachine> yeah
09:01:57 <EvilMachine> that makes a bit more sense. :)
09:02:04 <jmcarthur_work> <- doesn't actually pull anything out, though
09:02:12 <EvilMachine> i know
09:02:19 <benmachine> the way I see <- is as giving a name to something that may or may not be in there
09:02:27 <EvilMachine> it just gives you an identifier where you can pull things out
09:02:28 <jmcarthur_work> all it does is say that the rest of your do notation is a function taking the variable on the left hand side as a parameter
09:03:26 <EvilMachine> jmcarthur_work: thinking about it without using do helps a LOT if youre new. it should be strongly preferred.
09:03:30 <jmcarthur_work> EvilMachine, i prefer to avoid do notation when i can, although sometimes it is simply the cleanest way to express something (especially things like IO)
09:03:44 <EvilMachine> i agree
09:03:45 <jmcarthur_work> EvilMachine, agreed :)
09:03:48 <EvilMachine> lol
09:04:34 <jmcarthur_work> it is my opinion that if one feels the need for do notation, then one is lacking a useful combinator
09:05:24 <EvilMachine> i think do notation should only be allowed to use, if you are able to constantly keep the concept in the back of your head, that every line in that do block has a pipe on its lef and right side, that is connected to the other side of the above / below line, transporting the invisible monad.
09:05:38 <EvilMachine> (i like to talk in pictures, as i have a very visual brain)
09:05:59 <jmcarthur_work> EvilMachine, it sounds like you are describing arrow notation ;)
09:06:29 <EvilMachine> jmcarthur_work: are arrows the base of monads? i could not yet read up what they are about
09:06:49 <jmcarthur_work> EvilMachine, there is a relation between Kleisli arrows and monads
09:06:55 <EvilMachine> jmcarthur_work: what if someone comes up, calling do a useful (multi)combinator? ^^
09:07:01 <jmcarthur_work> EvilMachine, that's is, they are basically the same thing :)
09:07:05 <EvilMachine> ah
09:07:23 <jmcarthur_work> EvilMachine, do is not a combinator because it does not meet the definition
09:07:40 <jmcarthur_work> a combinator is a function taking functions as arguments, basically
09:07:41 <EvilMachine> so if there are Kleisli arrows, i can assume that there are other arrows too, so that arrows are in fact a generalization of monads?
09:07:52 <jmcarthur_work> EvilMachine, indeed
09:08:04 <zygoloid> arrows with ArrowApply are equivalent to monads
09:08:13 <zygoloid> @type app
09:08:13 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
09:08:17 <jmcarthur_work> yup
09:08:45 <EvilMachine> jmcarthur_work: well, if the do syntax would instead of accepting multiple lines, accept a list, containing the lines (which are usually functionsir as items would you then agree? ^^ or is it because it allows things like let?
09:08:57 <jmcarthur_work> EvilMachine, when you do finally look into arrows, mentally replace types of the form (a b c) with (b ~> c). that's what made it finally click for me
09:09:00 <zygoloid> arrows are somewhat similar to applicatives in that the structure is fixed
09:09:19 <jmcarthur_work> EvilMachine, the list would have to be heterogeneous
09:09:44 <jmcarthur_work> EvilMachine, and no, even then it wouldn't work
09:10:05 <EvilMachine> lol
09:10:07 <jmcarthur_work> since each "element" of the list might use any number of the previously bound variables
09:11:15 <EvilMachine> ah, so the b in your example is like the -> type operator, just that you can define your own type operator? Haskell is definitely the freest language ive ever seen!
09:11:21 <jmcarthur_work> EvilMachine, the Arrow class is less useful than it could be, so don't expect great things from arrows early in your learning
09:11:25 <jmcarthur_work> just btw
09:11:32 <quicksilver> EvilMachine: a not b
09:11:46 <quicksilver> EvilMachine: "a b c" is prefix notation while "b -> c" is infix
09:12:03 <quicksilver> so "a b c"; set a = (->); "(->) b c" or "b -> c"
09:14:44 <EvilMachine> jmcarthur_work: ok, the thing with the previously bound operators ist true. although i could imagine building a function that would take a list of functions with one parameter (the monad), apply an empty monad to the first one, take the result and put it in the monad, apply that to the second function, and so on, then return the monad after the last function. that monad could basically be an associative array of all
09:14:44 <EvilMachine> )
09:15:25 <EvilMachine> quicksilver: yes, a, of course. sorry.
09:16:16 <EvilMachine> jmcarthur_work: can you make applicatives in Haskell then? :D
09:16:56 <EvilMachine> jmcarthur_work: and is my hunch, saying that they have something to do with that mysterious monoid, right? :P
09:17:16 <zygoloid> EvilMachine: applicatives are a structure between functors and monads in terms of power
09:17:40 <quicksilver> applicatives have a similar relationship to monoids as monads do.
09:17:47 <quicksilver> they are both "monoids with a bit more"
09:17:55 <EvilMachine> oh ok
09:18:03 <quicksilver> (>>) makes "m ()" and "f ()" into a monoid
09:18:30 <EvilMachine> oh. so i would aim for functors, if i wanted to go to the craziest/highest/freest level?
09:18:32 <zygoloid> EvilMachine: applicatives allow sequencing, like monads, but don't allow collapsing nested layers of structure, or equivalently choosing what action to perform next based on a value in the functor
09:19:21 <EvilMachine> ok
09:19:24 <quicksilver> functors are the least restrictive, so there are 'more' functors.
09:19:24 <EvilMachine> makes sense
09:19:26 <jmcarthur_work> EvilMachine, functors are the simplest of what we have talked about so far
09:19:34 <EvilMachine> wow, i finally start to get it all.
09:19:41 * EvilMachine starts to smile
09:19:52 <jmcarthur_work> now you can take over the world!
09:19:56 <quicksilver> although in actual fact there are almost always ways to find an applicative structure on a particular functor.
09:20:01 <EvilMachine> lool. exactly. MUHAHAHAA
09:20:37 <Peaker> The Monoid instance of lists is not the typical Applicative one:  pure mempty, liftA2 mappend.  Would it be nicer if list had that one, and ConcatList or such had the concat monoid?
09:21:12 <quicksilver> in my opinion, no :)
09:21:18 <quicksilver> lists are the free monoid
09:21:26 <quicksilver> it would be surprising if the free monoid wasn't a monoid in the natural way.
09:21:27 <Peaker> what's the "free monoid"?
09:21:39 <jmcarthur_work> Peaker, in alt-stdlib i have unwrapped lists with the concat monoid and wrapped lists with the nondeterminism monoid, currently, but just as an experiment
09:21:46 <zygoloid> every monadic structure for a functor has a corresponding applicative (since applicative requires a subset of functionality). most of the applicatives you're likely to meet are also monads.
09:22:19 <quicksilver> Peaker: given a set of elements, how do you make it into a monoid in the simplest way possible? Answer: add an identity and permit finite sequences.
09:22:27 <Peaker> jmcarthur_work, I wonder if it should be the other way around -- so the recursive monoid is consistently the unwrapped one
09:22:37 <quicksilver> Peaker: the free monoid on {a,b} is {e,a,b,aa,bb,ab,ba,.....}
09:22:38 <EvilMachine> quicksilver: i dont understand your sentence about the applicative structure, because i now know that there is an order in those things, but i dont yet know what a applicative is per se. but ill find out sometime. :)
09:22:52 <quicksilver> Peaker: I.e., the free monoid on {a,b} is [{a,b}]
09:22:56 <Peaker> quicksilver, ah. but Monoids tend to be recursive
09:23:06 <Peaker> (e.g Maybe's)
09:23:16 <zygoloid> quicksilver: i'd say "the" free monoid is ()
09:23:41 <quicksilver> Peaker: I"m not sure what you're saying.
09:23:44 <quicksilver> zygoloid: or you?
09:23:47 <zygoloid> (that's at least the group generated by the monoid laws)
09:23:52 <quicksilver> I'm not proposing an opinion, here.
09:23:55 <quicksilver> I'm stating a fact.
09:24:00 <quicksilver> That *is* what the free monoid means.
09:24:06 <jmcarthur_work> i don't really understand the reasoning either
09:24:09 <quicksilver> it's a fairly well known term in mathematics.
09:24:11 <Peaker> EvilMachine, An Applicative is like a Functor that allows you to fuse together pre-determined Functors, while also combining their values with a pure function
09:24:29 <quicksilver> http://en.wikipedia.org/wiki/Free_monoid
09:24:40 <jmcarthur_work> EvilMachine, the important part of the Applicative class is (<*>) :: f (a -> b) -> (f a -> f b)
09:24:42 <trzkril> zygoloid: () is the free monoid over {}
09:24:45 <zygoloid> quicksilver: there is a notion of the free group over a set of generating elements and laws. but it doesn't give lists, it gives a single-element group, in this case.
09:25:10 <zygoloid> but it depends on whether you say 'the' free monad, or the free monad over set S
09:25:15 <Peaker> quicksilver, I'm not contradicting what you're saying. Just saying that its inconsistent that some types have a Monoid instance that "goes deeper" into the type argument (Maybe), and some have a flat one (list). It could be nice, perhaps, if it was consistent..
09:25:17 <zygoloid> s/monad/monoid/
09:26:18 <quicksilver> Peaker: sure. I understand your point.
09:26:31 <quicksilver> Peaker: My counterpoint was just - the free monoid is pretty important in the study of monoids.
09:26:34 * zygoloid thinks this is just pointless pedantry, and agrees that the free monoid over a set is the list monoid for that set
09:26:43 <jmcarthur_work> Peaker, my tentative policy with alt-stdlib is that if there is some Monoid instance and also an Applicative instance that generates a different Monoid instance, the Applicative one gets the newtype
09:26:47 <quicksilver> Peaker: since the type [a] in haskell *is* the free monoid over a
09:26:49 <EvilMachine> jmcarthur_work: looks like transforming a function in a monad into two monads of the same type with its types in it. ^^ (well, im a newb.)
09:26:58 <quicksilver> Peaker: it would be a bit surprising if we chose other than that Monoid instance.
09:27:13 <quicksilver> I might argue that Maybe has the wrong instance
09:27:22 <quicksilver> (although the other instance is found in MonadPlus)
09:27:40 <Peaker> jmcarthur_work, You can just have: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10822#a10822
09:27:42 <jmcarthur_work> EvilMachine, no, it transforms a wrapped function into a function over wrapped values
09:28:10 <Peaker> jmcarthur_work, One newtype to rule them all, no?
09:28:22 <jmcarthur_work> Peaker, i have a wrapper like that already
09:28:30 <jmcarthur_work> Peaker, but i use it for constructing other types
09:30:35 <EvilMachine> jmcarthur_work, quicksilver:  help! before you all go into depths that i cant follow (which is of course ok), i must ask an important question: you mentioned this order of some kind, of monads, arrows, applicatives, monoids, and so on. on what scale/dimension was that order? or said otherwise: what is the treelike-structure in this space from *low-dunnoest level of dunno/simplicity/freedom* to *high-dunnoest level of d
09:30:35 <zygoloid> jmcarthur_work: do you have Applicative as a superclass of Monad in the new stdlib?
09:30:43 <jmcarthur_work> zygoloid, yup
09:30:55 <zygoloid> jmcarthur_work: how do you resolve the Either problem?
09:31:41 <jmcarthur_work> zygoloid, right now, perhaps incorrectly
09:31:48 <quicksilver> EvilMachine: well it's complicated by the fact that a type can be an instance in more than one way.
09:31:57 <jmcarthur_work> i have not ensured that the Applicative instance lines up with the Monad instance yet
09:32:03 <quicksilver> EvilMachine: but, you can say the following:
09:32:12 <quicksilver> all monads are applicatives, all applicatives are functors.
09:32:20 <jmcarthur_work> zygoloid, but in both i require nothing of the left type
09:32:31 <quicksilver> all monads and applicatives have closely related monoids.
09:32:38 <quicksilver> all monads have a related arrow.
09:32:48 <zygoloid> jmcarthur_work: yeah, i figure that's the only sane way, but it's somewhat dissatisfying
09:32:50 <EvilMachine> jmcarthur_work: ah, ok, ill replace in a monad by wrapped.
09:33:15 <jmcarthur_work> zygoloid, well, a different type can capture the "error message" functionality
09:33:48 <jmcarthur_work> EvilMachine, really, just a parameter to a functor. i say "wrapped" because i don't really know what else to say, but i do think it's more accurate than "in a monad"
09:34:35 <EvilMachine> jmcarthur_work: but I get what you really wanted to say: that its way more general than only monads. :)
09:34:59 <jmcarthur_work> right
09:35:03 <EvilMachine> jmcarthur_work: general in the way that functors are behind it, with their evil, evil ways. :P
09:35:14 <jmcarthur_work> EvilMachine, when it *is* a monad, (<*>) is equivalent to ap
09:35:45 <jmcarthur_work> EvilMachine, assuming that the Applicative and Monad instances agree (which in my opinion they should, but it's not documented that way)
09:36:04 <EvilMachine> well, i havent read up about applicatives, but now i know at least that there is an ap with has the property you just told me about. :)
09:36:14 <jmcarthur_work> EvilMachine, and pure = return
09:36:20 <jmcarthur_work> pure is the other requirement for Applicative
09:36:46 <EvilMachine> ah. so pure is a (special)function? (like return)
09:37:00 <jmcarthur_work> EvilMachine, and it's my opinion that we should have another type class for pointed functors that requires only pure, and Applicative should require an instance for Pointed
09:37:14 <zygoloid> EvilMachine: be warned, there are some standard types where <*> and ap disagree. don't think there are any where pure and return disagree, though...
09:37:17 <Peaker> zygoloid, what's the Either problem?
09:37:21 <jmcarthur_work> EvilMachine, not really "special"
09:37:28 <zygoloid> Peaker: ap and <*> disagree ;-)
09:37:39 <jmcarthur_work> Peaker, compare the Either instances for Applicative and Monad
09:37:47 <Peaker> zygoloid, I'd imagine they do what the Error instance would do, no?
09:37:54 <jmcarthur_work> Peaker, assuming you can even find the Monad instance
09:38:02 <jmcarthur_work> Peaker, nope
09:38:04 <Peaker> what's the alternate Applicative instance?
09:38:07 <zygoloid> Peaker: the Monad instance for Either uses Error and takes the first error. the Applicative instance uses Monoid and combines errors
09:38:10 <EvilMachine> man, i think i must let everything fall, and go read up on applicatives, functors, arrows, etc. (monoids were pretty easy, as they only define functions to sequence things and an id/empty element for that sequence. (oh god i hope that gets even close to what they mean ;))
09:38:43 <jmcarthur_work> EvilMachine, that's it, plus a few laws
09:39:07 <jmcarthur_work> "sequence" is perhaps a bad word choice, but not incorrect
09:39:28 <quicksilver> sequence is precisely the monoid on m ()
09:39:34 <quicksilver> although, we don't make that monoid into a Monoid
09:39:38 <jmcarthur_work> heh, yeah
09:39:41 <EvilMachine> jmcarthur_work: yes. i always imagined them like numbers are sequenced
09:39:47 <quicksilver> partly cos our type system can't quite cope.
09:39:56 <jmcarthur_work> quicksilver, the monoids package has a newtype wrapper that does that though
09:40:02 <EvilMachine> jmcarthur_work: numbers do not pre se create a sequence. but they have something like that to them
09:40:20 <jmcarthur_work> EvilMachine, it's not a bad intuition, i think
09:40:34 <quicksilver> jmcarthur_work: *nod*
09:40:43 <quicksilver> jmcarthur_work: is that edwardk's package?
09:40:49 <jmcarthur_work> quicksilver, yeah
09:41:18 <quicksilver> jmcarthur_work: that relates to the standard haskell Monoid instances in the same way that the Space Shuttle relates to floating down a river on a tree trunk, as a transportation device
09:41:36 <EvilMachine> how did you learn all this? who of you are actually professors or something like that? hm? hm? admit it! ^^
09:41:51 <jmcarthur_work> quicksilver, ?!
09:41:56 <quicksilver> there certainly are professors in here from time to time, but I don't think any of the recent speakers is.
09:42:00 <jmcarthur_work> EvilMachine, i'm self taught
09:42:29 <jmcarthur_work> it's not as hard as it looks
09:42:37 <jmcarthur_work> but it's very interesting
09:42:54 <quicksilver> jmcarthur_work: it was just a compliment on the supreme technology of edwardk's library
09:43:06 <quicksilver> just a clumsily but colourfully phrased one :)
09:43:36 <jmcarthur_work> quicksilver, i was interpreting it as saying it was somehow overkill or overly complex
09:44:03 <jmcarthur_work> but i get it now
09:44:06 <EvilMachine> if you started with normal programming languages like C/C++/Java etc, was it just as much a crazy ride into unknown spaces, as it is for me? i mean its like a man from the dark ages, getting beamed to the enterprise. its very impressive, but also *very* hard. :D
09:44:36 <burp> " from the dark ages, getting beamed to the enterprise" good description ;)
09:44:45 <jmcarthur_work> quicksilver, i somehow parsed that sentence as saying that using the monoids package for Monoid stuff is like using the space shuttle to float down the river like a tree trunk
09:44:56 <seanmcl> There's a syntactic discrepancy between 'let' and 'where' I don't understand.  Why can I write f but not g?
09:44:57 <seanmcl> f x | True = let y = 5 in y
09:44:57 <seanmcl>     | otherwise = x
09:44:57 <seanmcl> g x | True = y where y = 7
09:44:58 <seanmcl>     | otherwise = x
09:45:01 <jmcarthur_work> EvilMachine, that's about how i felt at first
09:45:03 <quicksilver> :)
09:45:11 <zygoloid> EvilMachine: that rings true for me too
09:45:25 <quicksilver> seanmcl: let is an expression.
09:45:29 <quicksilver> seanmcl: (I mean, let forms expressions)
09:45:37 <seanmcl> It basically forces you to use let instead of where when you're using pattern guards
09:45:37 <quicksilver> seanmcl: where attaches to declarations
09:45:42 <burp> but even professors are just human beings :P
09:45:47 <EvilMachine> jmcarthur_work: so you look pretty cool in the monoids package, but a bid like bragging to those who could also do it? :D
09:45:48 <quicksilver> they are different syntactic places
09:45:49 <jmelesky> EvilMachine: i'm not a professor, but i had some experience with SML before taking on haskell, so it wasn't as hard a road for me
09:45:50 <quicksilver> no, it doesn't
09:45:57 <quicksilver> but the where clause scopes over all guards
09:46:09 <quicksilver> in fact, that's just about the only good thing about where clauses
09:46:46 <Twey> That's the whole point of where clauses, isn't it?
09:46:50 <ksandstr> wouldn't do to have where clauses that were "like let, but the other way around"
09:46:54 <EvilMachine> sevmonster: so what they mean is: the where would go below the |s
09:47:14 <jmcarthur_work> EvilMachine, i would rather convey the image that i haven't accomplished anything superhuman at all
09:47:20 <jmcarthur_work> which i believe is true
09:47:25 <seanmcl> quicksilver: oh, so (x where E) is not an expression
09:47:28 <zygoloid> > let g x | True = y | otherwise = x where y = 7 in g 42
09:47:29 <lambdabot>   7
09:47:29 <quicksilver> right.
09:47:41 <quicksilver> but you can put a where after all the guards
09:47:47 <EvilMachine> burp: well, hadnt my parents fucked up my life, i would now design artificial intelligences and games for at least 10 years. ^^
09:47:52 <jmcarthur_work> i don't think i am among the smartest or most skilled people in #haskell by any stretch
09:47:54 <seanmcl> oh because the guard can not bind variables
09:47:57 <quicksilver> as zygoloid showed although it looks odd on one line
09:48:11 <quicksilver> and it doesn't matter than you only used "y" in one case
09:48:17 <quicksilver> because lazy evaluation means it doesn't care
09:48:17 <zygoloid> you have to imagine the |s are lined up on different lines
09:48:32 <quicksilver> although "y" is available in the otherwise case, since you didn't use it, no time will be wasted
09:49:32 <seanmcl> ok, thanks everyone.  I was equating E where Decls as let Decls in E
09:49:49 <EvilMachine> jmcarthur_work: you havent accomplished anything superhuman *yet*, for here and now! you certainly have accomplished superhuman things for 100 years before now. or for some tribes in the jungle. :D
09:50:42 <jmcarthur_work> EvilMachine, no i haven't i am standing on the shoulders of giants
09:50:45 <EvilMachine> sevmonster: the guard can not bind variables?? then what is the y in x = y where y = 7;
09:50:47 <EvilMachine> ?
09:50:56 <EvilMachine> jmcarthur_work: shhhh! ^^
09:51:28 <EvilMachine> jmcarthur_work: the must not know. dont reveal our evil secrets of absolute power. :D
09:51:33 <EvilMachine> they
09:51:55 <monochrom> I stand on the shoulder of superhuman, then I slay him.
09:52:08 <EvilMachine> sevmonster: oops., sorry
09:52:47 <monochrom> "where y=7" binds y. Then you can use it in "x=y".
09:52:54 <EvilMachine> seanmcl: i meant you, and i misunderstood you anyway is my comment to sevmonster. so ignore it. :)
09:52:55 <burp> "you certainly have accomplished superhuman things for 100 years before now." .. think again about what people already did 100 years ago ;)
09:53:54 <monochrom> They contracted spanish flu, that's what they did 100 years ago.
09:53:56 <EvilMachine> burp: i know. i know. but show them an media player with solar power and a builtin projector :D
09:54:01 <burp> ;-)
09:54:13 <burp> well, could you build such a thing? :D
09:54:22 <EvilMachine> burp: partially yes
09:54:30 <burp> I'm impressed
09:54:43 * monochrom phones up Church to talk about Haskell. He would be really pleased.
09:54:48 <seanmcl> EvilMachine: I meant that in pat | E, E does not bind variables, so it's OK to put the where clause outside of all the pattern guards.  If the guards could bind variables that would be a problem.
09:54:52 <EvilMachine> the media would perhaps be stored on rolls of punched metal but i could do much of it
09:55:03 <EvilMachine> oh, and it would be a GIANT device. :D
09:55:09 <EvilMachine> at least back then
09:55:10 * monochrom phones up von Neumann to talk about Haskell. He would be really pissed.  <duck>
09:55:34 <EvilMachine> seanmcl: yes, i have understood that now. :)
09:55:44 * monochrom phones up Gentzen to talk about calculation proofs. :)
09:55:45 <seanmcl> :)
09:56:37 <EvilMachine> seanmcl: so | x == 0 = let something is something is used ot bind things in a guard. :)
09:56:52 <EvilMachine> monochrom: LOL
09:57:28 <tuukkah> bos, busy?
09:57:31 <EvilMachine> monochrom: but Turing would be very pleased about Haskell, wouldnt he?
09:57:46 <monochrom> I think so too.
09:59:23 <EvilMachine> if youd go back to time, would you too make them use haskell on the very first computers? (ok, perhaps after fixing the mess-up of positive and negative in electricity. ^^)
10:00:14 <zygoloid> if i could go back in time, i'd be careful not to change anything whose outcome i could remember :)
10:02:56 <EvilMachine> oh, and id think: when Im there already, I can at least kick Hitlers ass with my futuristic tactics take his place and use the 13th century tactic of china to invade others with two things: a massively gigantic looking army, and a giant basket full of gifts. (but without any real war actions at all.) :D (of course I'd stop racism and that shit, and only expect one thing from conquered countries: that they h
10:03:13 * EvilMachine hides his evil side again. :D
10:03:38 <monochrom> If I could go back in time, I would go back much further. I would make them invent higher-order functions early. I would make them teach higher-order functions to kids, and then numbers built on them a la Church encoding. This would ensure they would invent the right kind of computers to run Haskell speedily, and it be the only kind conceivable to them.
10:03:56 <Raevel> irssi bugged out so it looked like i just typed that
10:04:54 <mauke> EvilMachine: http://xrl.us/bfsqd6
10:05:24 <monochrom> haha
10:06:11 <ski> @remember Virginia_Curry You know, Haskell actually never liked the name Haskell.
10:06:12 <lambdabot> Nice!
10:06:16 <EvilMachine> monochrom: but how would you prevent to see everything turned into the very opposite of the original ideas and goals, when comin back to the present (of your newly created timeline)?
10:06:40 <EvilMachine> LOL
10:06:45 <monochrom> I would not prevent.
10:07:55 <EvilMachine> so then just go back and make the world very very bad. so people will turn everything around, resulting into a good world.
10:08:18 <EvilMachine> omg, i think i just found out who the first time traveller was: hitler! :P
10:08:33 <monochrom> At too much a cost.
10:08:43 <jmcarthur_work> i think the world is still a worse place today than it would have been if he had never existed
10:09:04 <EvilMachine> definitely. but maybe he wanted a very *very* good world, and we were not as effective as predicted.
10:09:25 <sunfun> 4
10:09:30 <sunfun> ops
10:09:33 <sunfun> sorry
10:09:38 <Taejo> I'm looking for a copy of "On the linear complexity of combined shift register sequences" by Lennart Brynielsson. It's on SpringerLink, but I don't have the appropriate subscription. Any chance somebody can download it for me?
10:09:48 <EvilMachine> jmcarthur_work: remember, that he just used and fueld the hate that already existed anyway. but back on topic :D
10:10:38 <EvilMachine> Taejo: nothing on the donkey network so far. :P
10:10:55 <Taejo> donkey network?
10:11:07 <EvilMachine> Taejo: edonkey2000
10:11:14 <EvilMachine> the network, not the program
10:11:18 <EvilMachine> whatever
10:11:33 <EvilMachine> sorry i cant help you
10:16:04 <gspr> Does hsc2hs correctly handle C unions?
10:20:21 <zygoloid> @quote VirginiaCurry
10:20:22 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
10:20:27 <zygoloid> @quote Virginia_Curry
10:20:27 <lambdabot> Virginia_Curry says: You know, Haskell actually never liked the name Haskell.
10:20:34 <ski> ah
10:21:10 * ski didn't find the former when asking lambdabot on a few words from there
10:21:28 <int-e> @quote Haskell.*Haskell
10:21:28 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
10:21:28 <lambdabot> like learn $ zip math haskell.
10:21:50 <ski> @forget Virginia_Curry You know, Haskell actually never liked the name Haskell.
10:21:50 <lambdabot> Done.
10:22:02 <ski> @quote widow
10:22:02 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
10:22:35 <zygoloid> You know, Virginia actually never liked the name Virgina
10:23:11 * ski didn't know
10:25:55 <jfoutz> gspr: i think hsc2hs is pretty robust. unions should work.
10:27:35 <domme> moin
10:27:50 <gspr> jfoutz: OK, thanks :)
10:42:36 <EvilMachine>  moin, domme. wie isset? :P
10:43:31 <domme> EvilMachine: jut
10:43:55 <domme> EvilMachine: kennen wir uns? ist der channel hier nicht englisch? :P
10:44:40 <solidsnack> lambdabot: hello
10:44:49 <solidsnack> Hmm.
10:44:49 <lambdabot> solidsnack: You have 1 new message. '/msg lambdabot @messages' to read it.
10:45:07 <EvilMachine> 1. nein, tun wir nicht. 2. doch, aber ich konnte dein moin nicht so stehen lassen.  :D
10:45:24 <domme> EvilMachine: hehe okay
10:45:24 <EvilMachine> domme:  3. ich htte dein gesicht gerne gesehen
10:45:46 <domme> EvilMachine: naja.. irc welt ist klein.. mich wundert gar nichts mehr
10:46:14 <EvilMachine> domme:  bin jetzt eh erstmal weg. freitagabend undso.
10:46:50 <domme> EvilMachine: du studierst nicht zufaellig in dortmund oder? hab deinen nick irgendwo schonmal gesehen..
10:47:37 <EvilMachine> domme: nee. ich kenne nur eine in dortmund und deine die manchmal da zur uni muss. :D
10:47:38 <zygoloid> > unfoldr (\n -> case n `divMod` 26 of (0,0) -> Nothing; (m,k) -> Just (chr$k+97,m)) (read . concat $ forM (takeWhile (/=1) $ iterate (\n -> if even n then n`div`2 else 3*n+1) 8) show)
10:47:39 <lambdabot>   "kgb"
10:48:08 <solidsnack> @tell edwardk  Thank you.
10:48:08 <lambdabot> Consider it noted.
10:48:10 <domme> EvilMachine: kk.. nvm then ;D btw lots of opensource people know moin even if they are not german ;D
10:48:24 <EvilMachine> @all: thank you all, guys! about the quote whether to learn math or haskell (or both, alternating): haskell is more fun, more quickly makes sense, the irc channel is nice and not full of math people, and haskell includes math anyway! :P
10:48:24 <lambdabot> Unknown command, try @list
10:48:48 <EvilMachine> domme: maybe because of the moinmoin wiki. :D
10:48:55 <EvilMachine> @list
10:48:55 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:49:18 <EvilMachine> bye
11:00:46 <elliottt> is there a good place for cabal-install contributions?  i've got a working zsh completion script for it that might be useful to others.
11:04:28 <zygoloid> > head (show (undefined :: [Int]))
11:04:29 <lambdabot>   * Exception: Prelude.undefined
11:04:30 <zygoloid> > head (show (undefined :: [Char]))
11:04:31 <lambdabot>   '"'
11:05:21 <sproingie> elliottt: i'd put it on hackage
11:06:38 <sproingie> huh.  is it normal for linking to take forever?  cabal install of hunit shows ld taking 400+ megs and hanging
11:07:29 <dcoutts> sproingie: it can take a while sometimes, but usually not more than a few seconds
11:07:45 <dcoutts> sproingie: if you've got a really old version of ld it can take a long time and a lot of memory
11:07:58 <sproingie> freshly updated debian sid
11:08:02 <dcoutts> which can be problematic on machines with little ram
11:08:34 <sproingie> GNU ld (GNU Binutils for Debian) 2.19.91.20091006
11:08:49 <jkramer> Hmm, can't I have a list [(String, a)] in Haskell?
11:08:55 <dcoutts> sproingie: though honestly I sometimes think ld is non-deterministic
11:09:06 <dcoutts> sproingie: that's certainly sufficiently recent
11:09:08 <sproingie> might be some funky interaction with xen?
11:09:13 <ski> > [] :: [(String,a)]
11:09:13 <lambdabot>   []
11:09:16 <sproingie> doesn't give me problems on my home machine
11:09:25 <dcoutts> sproingie: linking is pretty heavy on the disk, that's for sure
11:09:35 <jkramer> Weird
11:09:42 <sproingie> not sure why it'd balloon memory usage like that tho
11:09:46 <sproingie> i guess i'll give it an hour
11:10:19 <jkramer> I need a list [(String, a)], where MyClass a has instances for Int and String
11:10:21 <dcoutts> sproingie: I'd be tempted to kill it and try again, I swear it's random sometimes.
11:10:39 <sproingie> have tried it, it keeps doing it
11:10:39 <jkramer> Now when I want to make a list [(String, Int), (String, String)], ghc complains
11:10:49 <dcoutts> sproingie: if your VM instance doesn't have much ram that'll be a problem of course
11:10:50 <sproingie> i've also discovered cabal isn't very good about noticing build errors
11:10:54 <ski> jkramer : that's because all elements of a list must have the same type
11:10:59 <sproingie> it'll half-install and install broken things
11:11:08 <ski> jkramer : use an existential wrapper if you want to do that
11:11:10 <dcoutts> sproingie: in what sort of case?
11:11:33 <jkramer> ski: How do I do that
11:11:34 <jkramer> ?
11:11:38 <sproingie> dcoutts: i hit ctrl-c while it was building one package, and the next dependency complained about missing parts
11:11:55 <ski> jkramer : i.e. you want `[(String,exists a. MyClass *> a)]', which could can't express that directly in haskell
11:12:01 <ski> so instead you do a wrapper like
11:12:26 <sproingie> possibly i interrupted it in exactly the wrong place, i've broken cpan like that too
11:12:26 <ski>   data SomeMyClass = forall a. MyClass a => MkSomeMyClass a
11:12:40 <ski> then you use `[(String,SomeMyClass)]'
11:12:42 <dcoutts> sproingie: you mean it skipped building the dependency and reported that it couldn't build the later one because the earlier one failed?
11:12:51 <jkramer> Oh noes, I wanted to avoid exactly that kind of stuff :)
11:12:55 <sproingie> dcoutts: nope, it seemed to pretend the earlier one succeeded
11:13:06 <ski> (if you prefer, you could use the GADT-style definition of it, instead
11:13:10 <ski>   data SomeMyClass
11:13:10 <dcoutts> sproingie: oh, that's more concerning.
11:13:12 <ski>     where
11:13:16 <sproingie> the window i had this in is closed
11:13:24 <ski>     MkSomeMyClass :: MyClass a => a -> SomeMyClass
11:13:25 <ski> )
11:13:32 <sproingie> i could probably replicate it just by killing ld and having it install broken stuff
11:13:44 <ski> jkramer : in some cases, one can use CPS as a workaround
11:13:45 <dcoutts> sproingie: the Ctl-C handling in ghc-compiled apps has sometimes been a bit squiffy
11:13:54 <ski> i'm not sure that applies in your case, though
11:14:03 <dcoutts> sproingie: so that the child gets killed without the parent noticing it properly
11:14:40 <dcoutts> sproingie: but it should at least notice that it failed, if not that it terminated due to Ctl-C
11:15:00 <dcoutts> sproingie: if you can reproduce it then please do file a ticket in the Cabal trac.
11:15:01 <jkramer> ski: Thanks, I guess I have to rethink some things first .9
11:15:31 <ski> jkramer : btw, why did you want to avoid the wrapper ?
11:15:47 <ski> you don't want to use the ugly `MkSomeMyClass' constructor ? :)
11:16:22 <jkramer> ski: Right, I want to use be able to use several types directly without wrapping them into other types
11:16:31 <tectum> is there a way of getting a stack trace with a failed assertion?
11:17:04 <burp> stack.. trace? :D
11:17:28 <jkramer> s/to use/the user/ :)
11:17:34 <jkramer> +to
11:18:37 <ski>   forall o. (forall a. MyClass a => a -> o -> o) -> o -> o
11:18:44 <ski> that would be a CPS-workaround, i suppose
11:18:49 <jkramer> lol
11:18:57 <ski> (but probably you don't like the CPS-ified list :)
11:19:27 <gspr> In http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs , shouldn't the commas on the last line of peek not be there?
11:19:33 <ski>   \cons nil -> cons elementA (cons elementB nil)
11:20:03 <ski> would represent a list with elements `elementA',`elementB' of differing types that both are instances of the `MyClass' class
11:20:33 <jkramer> Hrm, maybe I'll just have the user convert the tuple snd to string manually :)
11:21:23 <sproingie> yeah ld is pretty reliably hanging.  maybe it doesn't like gcc 4.3.4?
11:21:59 <en0th> :t (!!)
11:22:01 <lambdabot> forall a. [a] -> Int -> a
11:24:29 <gspr> Hmm, I must be thinking incorrectly... how would one go about making a C enum a Storable instance? I've been able to do this nicely with structs (using hsc2hs), but how do handle an enum?
11:28:31 <gspr> aha, ptrToIntPtr!
11:29:37 <monochrom> C enum is a machine word.
11:30:35 <Baughn> Usually. I've been unable to find anything guaranteeing that.
11:30:48 <Baughn> Still, on every platform where ghc actually runs..
11:31:11 <monochrom> IIRC K&R 2ed guarantees it.
11:31:59 <Baughn> monochrom: That's not the C standard, though. :P
11:32:13 <Baughn> You're probably right, and the standard /does/ guarantee it, I just can't find that line
11:32:28 <monochrom> I don't have money to buy the standard document. I would gladly quote it.
11:33:11 <Baughn> Buy? Just grab the final C99 draft.
11:33:21 <monochrom> where where?
11:33:35 <Baughn> http://www.google.com/url?sa=t&source=web&ct=res&cd=1&ved=0CAcQFjAA&url=http%3A%2F%2Fwww.open-std.org%2FJTC1%2FSC22%2Fwg14%2Fwww%2Fdocs%2Fn1124.pdf&ei=d7zYSvvlMMzB-QaLl4G-DQ&usg=AFQjCNGZNITNpxvZKard5pSr7RQvxmTDkQ&sig2=9hj6LXzSqL6o6Gxj8i7p3Q
11:33:39 <Baughn> Um...
11:33:43 <Baughn> www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf
11:33:56 <monochrom> thanks. kisses kisses
11:34:20 <Baughn> That's actually a /post/-C99 draft
11:34:24 <Baughn> Still, should be fine.
11:35:19 <en0th> found a quote of C99, 6.7.2.2p4
11:35:32 <en0th> Each enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined,108) but shall be capable of representing the values of all the members of the enumeration
11:35:44 <Baughn> Yeah, I found that.
11:35:57 <Baughn> But "compatible" just means "you can (possibly implicitly) cast it to that type, and it'll work
11:36:03 <elliottt> sproingie: i'm not sure how i would make a cabal package for a zsh completion script
11:36:11 <Baughn> It doesn't mean it's /stored/ as a machine word
11:36:26 <monochrom> oops, not necessarily machine word then.
11:36:30 <dcoutts> elliottt: mm, I don't think there's any particularly standard way
11:36:57 <dcoutts> elliottt: each distro seems to put bash/zsh/etc command line completion scripts in different places.
11:37:00 <monochrom> however, each enumed symbol is a number, and which symbol gets which number is determined completely
11:37:14 <Baughn> Deterministicall. Yeah. Starting with 0, etc.
11:37:16 <elliottt> dcoutts: yeah
11:37:32 <dcoutts> elliottt: it's a bit annoying really. cabal-install has one itself but it's not easily usable because it has to be installed manually.
11:37:53 <elliottt> dcoutts: oh, it's already got a completion script?
11:37:58 <dcoutts> elliottt: yep
11:38:04 <elliottt> dcoutts: argh
11:38:11 <dcoutts> elliottt: for bash, should be easy to translate for zsh
11:38:19 <elliottt> dcoutts: ah, ok
11:38:24 <dcoutts> elliottt: the cabal program does most of the work itself
11:38:35 <elliottt> dcoutts: my zsh one is done, and it completes package names :)
11:38:46 <dcoutts> elliottt: so does the bash one :-)
11:38:59 <elliottt> dcoutts: man, i am doing no innovation here
11:39:18 <elliottt> well, if you're interested in bundling a zsh one with the bash one, i've got it ready
11:39:27 <dcoutts> elliottt: sure, darcs send!
11:39:32 <elliottt> excellent
11:40:20 <dcoutts> elliottt: see the bash-completion/cabal script in the cabal-install darcs repo
11:40:46 <dcoutts> elliottt: I presume you're using the cabal --list-options flag
11:41:24 <elliottt> dcoutts: to get the package list?
11:41:31 <elliottt> or to do the completion?
11:41:43 <dcoutts> elliottt: to get the list of flags that are valid in the current context
11:41:55 <dcoutts> or the names of sub commands
11:41:58 <elliottt> dcoutts: i actually wrote all the option parsing stuff myself, to be able to complete relevant values for flags
11:42:11 <elliottt> dcoutts: cabal -v<tab> will list verbosity levels, and the like
11:43:07 <dcoutts> elliottt: ah, that's taking it a bit further, we could do that in the cabal code too for the cases where we know the possible values
11:43:52 <elliottt> dcoutts: i did that where possible.  the result is a huge completion script :)
11:44:00 <dcoutts> elliottt: right :-)
11:44:12 <dcoutts> elliottt: and it'll get out of sync as we change things in cabal
11:45:39 <dcoutts> elliottt: I should really turn this into yet another command line handling package
11:46:00 <dcoutts> and enhance it to do completion on values as well as flag names
11:46:40 <elliottt> yeah, that would be handy
11:46:48 <elliottt> dcoutts: where should i send my patch?
11:47:00 <dcoutts> elliottt: default for that repo
11:47:32 <dcoutts> darcs send should do the right thing
11:48:51 <sproingie> is there a way to tell get cabal install to use a different gcc version when linking?
11:49:12 <sproingie> ghc4.4 consistently goes berzerk
11:49:18 <dcoutts> sproingie: you can get cabal to tell ghc to use a different gcc version
11:49:22 <sproingie> er gcc4.4
11:50:26 <dcoutts> sproingie: --ghc-option=  Check the ghc user guide for the right ghc flag, it's something like -pgmc
11:51:35 <elliottt> dcoutts: ok, i've sent it off
11:51:39 <dcoutts> ta
11:52:58 <jkramer> Is there a way to implement functions with a variable number of arguments in haskell?
11:53:12 <jkramer> Uhm, probably not
11:53:21 <jkramer> Doesn't make sense anyway
11:53:25 <jkramer> Forget what I said :)
11:53:39 <dcoutts> jkramer: sort of, see printf
11:53:54 <gwern> 'If you think C++ is not overly complicated, just what is a protected abstract virtual base pure virtual private destructor and when was the last time you needed one? -- Tom Cargill'
11:54:00 <Cale> jkramer: Yeah, it's possible, but normally not something you really want to do.
11:54:29 <jkramer> Yeah, it was a stupid idea anyway
11:55:31 <Cale> jkramer: The basic idea behind it is to define a typeclass which has instances for each of the possible result types for your function, which will include various function types (which will take the extra parameters)
11:55:33 <jkramer> I'm looking for a nice way to provide a data constructor for a database table that takes the column values as arguments and creates a data record from it
11:55:51 <jkramer> For some kind of ORM, just without objects :)
11:56:07 <sproingie> gwern: i like to point to the book Effective C++.  i bought that book so i could be better at c++, and it just showed me what a minefield it is
11:56:36 <Cale> Ah, this sort of thing can be tricky, depending on how much you want to keep track of at compile time.
11:57:12 <jkramer> Cale: I'm trying to provide all information at compile time, e.g. number of columns for each table, maybe even column types
11:57:28 <en0th> a list doesnt fit?
11:57:38 <Cale> Have you looked at HaskellDB?
11:58:08 <jkramer> Yes, but doesn't really work for me
11:58:13 <Cale> hmm
11:58:44 <jkramer> Probably because it's documentation is missing or at least incomplete and out-dated :)
11:58:48 <Cale> Last I checked, it did actually work, though it can be rather confusing.
11:59:06 <jkramer> Yup, that too
11:59:08 <Cale> The Haddock is at least up to date.
11:59:20 <jkramer> I got one or two examples that came with the source working, but that's it
11:59:44 <sproingie> ghc-options only seems to work in .cabal files
11:59:58 <sproingie> set it in .cabal/config and it's unrecognized
12:00:01 <Cale> The trouble that all such things run into is that Haskell has no built-in support for extensible record types and row polymorphism
12:00:02 <dcoutts> sproingie: no, on the command line
12:00:16 <gwern> I wonder why all my emails from the local theater thingy start with 'Emacs!' followed by 2 newlines
12:00:18 <dcoutts> sproingie: as in cabal configure --ghc-option=blah
12:00:25 <Cale> and so they end up simulating it using fancy type features and typeclasses
12:00:47 <jkramer> That's pretty much what I'm doing :)
12:01:10 <gwern> (the mailer is 'Windows Eudora' so I dunno where this Emacs thing is coming from)
12:01:23 <jkramer> I've made a typeclass for (un)marshalling data records into/from lists of column values
12:02:06 <jkramer> Now I'm looking for a nice way to feed the unmarshalling function with a row from the database
12:03:26 <jkramer> The goal is that you make a data type that represents a row using native haskell types and make it an instance of the marshalling typeclass
12:03:35 <jkramer> And the ORM should do the rest
12:03:46 <sproingie> well that was pointless.  gcc just invokes the one ld i have anyway, so it still hangs
12:04:04 <sproingie> i'm thinking i won't be doing any haskell on my VPS box :(
12:04:36 <Zao> sproingie: How about compiling offline and uploading it?
12:04:58 <sproingie> probably what i'll do
12:05:19 <Zao> I'd be mostly annoyed at the half gig of compiler and libs I'd have to have to build online.
12:05:24 <en0th> jkramer: something like this? data Col = ColInt Int | ColString String | ..
12:05:48 <sproingie> i just wanted to install gitit nice and easy.  now it's not so easy.
12:07:14 <jkramer> en0th: Similar, but not exactly. I made a typeclass for it so users can add more column types as needed
12:07:19 <jkramer> http://pastie.org/657954
12:07:45 <jkramer> (Just some pieces from to code I pasted together to show what I want it to look like later)
12:08:27 <en0th> mm i see
12:09:42 <jkramer> http://pastie.org/657958 - same stuff, but including the definition of ColumnValue
12:10:05 * Millz http://izismile.com/img/img2/20091015/gifko_03.gif
12:13:21 <sproingie> hm i can put arch on this box instead of debian.  that ought to make for a more haskell-friendly environment.
12:16:06 <FunctorSalad> how's debian supposed to be haskell-hostile? ;)
12:17:20 <Twey> Haskell is a moving target.  ;)
12:18:02 <Cale> Hehe, and debian is hostile to anything which moves? :)
12:18:20 <FunctorSalad> Twey: yeah but isn't that a reason to just install it locally?
12:18:47 <FunctorSalad> and packages are dealt with by cabal anyways
12:19:32 <Twey> Cale: *nod* But at least they haven't consigned it to Patch Hell yet!
12:19:55 <Twey> FunctorSalad: Yeah, but that's enough to count as hostile by my definition at least
12:20:20 <Twey> The package manager is meant to help the user, not provide an additional hurdle :
12:22:00 <ns_schoe> > let fu x = x^2
12:22:01 <lambdabot>   not an expression: `let fu x = x^2'
12:22:12 <ns_schoe> > fu x = x^2
12:22:12 <lambdabot>   <no location info>: parse error on input `='
12:22:48 <ns_schoe> oOps sorry, wrong window :/
12:23:18 <jkramer> Hrm
12:23:36 <Twey> Heh.
12:23:48 <Twey> > let fu = (^ 2) in fu 2
12:23:49 <lambdabot>   4
12:24:09 <ns_schoe> Ho right, thanks for the tip ^^
12:24:25 <Igor_> That looks interesting. What does it do?
12:25:14 <jkramer> http://pastie.org/657994
12:25:54 <jkramer> What does the signature have to look like to make this work?
12:25:56 <Twey> Igor_: Squares stuff.
12:26:14 <Igor_> I meant lambdabot in general.
12:26:30 <Igor_> But i guess it just executes code. ^^
12:27:27 <jkramer> Any ideas?
12:27:46 <jmcarthur_work> jkramer, what is convert?
12:28:14 <Cale> jkramer: The problem is that 'value' may have any type (which is an instance of Value), but fromColumn is supposed to work for any other type a
12:28:49 <jkramer> jmcarthur_work: in this case, just "id"
12:29:26 <Cale> (and there's nothing which says those types match)
12:29:47 <jkramer> Cale: Shouldn't the (Value a) => fix this?
12:29:51 <jmcarthur_work> i always fall out of practice with this stuff, i but i suspect this would work: fromColumn :: ColumnValue -> b -> (forall a . Value a => a -> b) -> b
12:29:53 <Cale> Maybe you wanted:  fromColumn :: ColumnValue -> b -> (forall a. Value a => a -> b) -> b ?
12:30:06 <jkramer> Ah
12:30:41 <jkramer> I don't really know that extential type stuff, I'm just copying from the paper someone linked here yesterday :)
12:30:43 <sproingie> FunctorSalad: debian's not haskell-hostile so much as this particular configuration i have seems to be
12:30:46 <jkramer> Gotta read more of it, I guess
12:30:52 <MyCatVerbs> Cale: heh. From your message's formatting it looks like you're trying to pretend to be a bot. ;)
12:30:53 <Cale> jkramer: That will force the parameter to fromColumn to be a genuinely polymorphic function
12:31:06 <monochrom> haha
12:31:19 <jmcarthur_work> basically, when you wrap the value up in the RealValue constructor, you forget what type it is. since the type inference wants to make the a in your original signature monomorphic (by looking at what's calling it), it will get confused
12:31:21 <jkramer> Now I'm getting Illegal polymorphic or qualified type instead
12:31:43 <Cale> jkramer: Whereas the current type signature lets someone who is calling fromColumn 'pick' the type a, and the signature says that it should work no matter what type a they pick.
12:31:44 <jmcarthur_work> jkramer, maybe you need Rank2Types or RankNTypes
12:31:46 <jkramer> Compiles with -XRankNTypes :)
12:31:56 <monochrom> Maybe you want: monochrom's service at the great discounted rate of $50 per hour. Exclusive for #haskell members!
12:32:11 <Baughn> http://d.hatena.ne.jp/ku-ma-me/20090916/p1 <-- Have an.. ahem.... haskell quine.
12:32:48 <p_l> hahaha
12:33:01 <Twey> Igor_: \b does all sorts of things.  Executing code is just her most frequently-used function.  
12:33:07 <jkramer> Cale: This sounds like I'm making Haskells type system all soft and wet doing this :(
12:33:19 <jkramer> Cale: You would tell me if this was really bad code style, would you?
12:33:23 <deech> Hayoo appears to be down, downforeveryoneorjustme.com confirms.
12:33:30 <jmcarthur_work> jkramer, existential quantification can lead to complexity
12:33:43 <jmcarthur_work> it's not necessarily bad, but it does make your code start to look like OO
12:33:47 <Twey> Baughn: Wow, eleven-language quine relay.
12:34:25 <jkramer> jmcarthur_work: Ok, I can live with that. :) But when this is finished I should try to understand what I coded here
12:34:54 <Cale> haha, the comment:
12:35:00 <Cale> Yo dawg, I put a quine in your quine in your quine in your quine in your quine in your quine in your quine in your quine in your quine in your quine in your quine so you can quine while you quine while you quine while you quine while you quine while you quine while you quine while you quine while you quine while you quine while you quine.
12:35:07 <Twey> Hahahaha.
12:35:12 <monochrom> hahahaha
12:35:18 <sproingie> buffalo buffalo buffalo buffalo buffalo buffalo buffalo
12:35:18 <skorpan> quine?
12:35:33 <Cale> skorpan: A program which emits itself as output.
12:35:47 <Baughn> Well, emits its own source code at least
12:35:51 <Cale> yeah
12:35:52 <monochrom> "on the 12th day of christmas my true quine sent to me: ..."
12:35:54 <Baughn> ..without at any point explicitly reading the source file
12:36:21 <Baughn> There's also the language, Quine, whose interpreter is implemented as a symlink to /bin/cat
12:36:28 <jmcarthur_work> jkramer, basically, when you work with types that are not inferrable at compile time, you have to start using real polymorphic functions (ones which will not be inferred to monomorphic types during compilation)
12:36:30 <sproingie> i prefer hq9+
12:37:06 <sproingie> use the q operator multiple times and you get square quines
12:37:30 <p_l> still, the shortest quine ever was funny
12:37:37 <Cale> jkramer: Basically, when you apply the RealValue data constructor to a value, it "forgets" what type it was, only remembering that it was an instance of Value
12:37:40 <sproingie> p_l: /dev/null?
12:37:40 <MyCatVerbs> p_l: __FILE__ in C?
12:38:02 <Baughn> MyCatVerbs: That wouldn't quine
12:38:04 <MyCatVerbs> p_l: or the shortest "non-cheating" quine that I know of is the Unix quine: #!/bin/cat
12:38:05 <sproingie> just __FILE__ won't compile
12:38:09 <skorpan> is there any haskell quine?
12:38:11 <Cale> jkramer: (Heh, this explanation would be more readable if there weren't so many things called 'value')
12:38:15 <jmcarthur_work> jkramer, and this is a reason that OOP languages are often so cluttered with casts and checks. it becomes very inconvenient to work with unknown types otherwise
12:38:21 <Baughn> skorpan: THere are quines for every language
12:38:34 <sproingie> http://www.iis.sinica.edu.tw/~scm/2007/a-haskell-quine/
12:38:39 <Baughn> skorpan: I once saw a file that was simultaneouse a quine for c, bash, haskell, brainfuck, python, and.. a couple of others.
12:38:51 <skorpan> wtf
12:39:03 <FunctorSalad> ^^
12:39:05 <Baughn> (Not a relay. Running the file in /any/ of the languages output the original.)
12:39:07 <MyCatVerbs> Baughn: it does if you name the file "main(){printf("__FILE__");return 0;}" :)
12:39:16 <Cale> jkramer: So the only operations which you can apply to that value when you extract it from under the RealValue constructor are operations which are polymorphic and can be applied to any value in the class Value.
12:39:19 <skorpan> main=putStr(p++show(p))where p="main=putStr(p++show(p))where p="
12:39:33 <Baughn> MyCatVerbs: Okay, now that's just cheating. xD
12:39:38 <ns_schoe> Sorry to disturb, can anyone help me out with shiftL : I can't figure out what it does exactly ?
12:39:59 <Peaker> @type shiftL
12:40:00 <lambdabot> forall a. (Bits a) => a -> Int -> a
12:40:04 <MyCatVerbs> Baughn: hence why I say that the shortest non cheaty quine is "#!/bin/cat", chmod'd +x. :)
12:40:13 <Baughn> ^_^
12:40:13 <Cale> ns_schoe: Shifts the bits to the left
12:40:23 <Peaker> @check (\x y -> x `shiftL` y == x * (2^y))
12:40:24 <lambdabot>   Add a type signature
12:40:31 <Cale> ns_schoe: assuming that you're talking about the shiftL from Data.Bits
12:40:35 <Baughn> MyCatVerbs: I still say the shortest quine would be an empty file, interpreted by python
12:40:35 <Peaker> @check (\x y -> x::Integer `shiftL` y::Integer == x * (2^y))
12:40:35 <lambdabot>   Parse error at "`shif..." (column 21)
12:40:45 <Peaker> @check (\x y -> (x::Integer) `shiftL` (y::Integer) == x * (2^y))
12:40:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:40:51 <monochrom> > shiftL 5 1
12:40:52 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:40:52 <lambdabot>    `Data.Bits.Bits t'
12:40:52 <lambdabot>      a...
12:40:58 <Cale> hehe
12:40:59 <monochrom> > shiftL 5 1 :: Int
12:41:00 <lambdabot>   10
12:41:11 <Cale> > shiftL 5 2 :: Int
12:41:12 <lambdabot>   20
12:41:17 <Peaker> @check (\x y -> (x::Integer) `shiftL` y == x * (2^y))
12:41:17 <lambdabot>   "* Exception: Negative exponent
12:41:34 <Peaker> > 1 `shiftL` (-3)
12:41:35 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:41:35 <lambdabot>    `Data.Bits.Bits t'
12:41:35 <lambdabot>      a...
12:41:37 <monochrom> Write 5, 10, 20 in binary to see.
12:41:41 <Peaker> > 1 `shiftL` (-3) :: Int
12:41:42 <lambdabot>   0
12:41:50 <jkramer> Cale, jmcarthur_work: Yup, just noticed that the convert function doesn't really work with this
12:41:50 <Peaker> > 10 `shiftL` (-1) :: Int
12:41:51 <lambdabot>   5
12:41:59 <Peaker> oh that's not how C << behaves
12:42:08 <jkramer> Guess I have to rethink again :)
12:43:02 <ns_schoe> > 0x0101 `shiftL` 1 :: Int
12:43:03 <lambdabot>   514
12:43:11 <jkramer> Any ideas how this could be done less sloppy?
12:43:13 <ns_schoe> I don't get how it gives 514
12:43:24 <monochrom> > 0x01010
12:43:25 <lambdabot>   4112
12:43:45 <ns_schoe> Yeah I thought that what it did, but apprently not.
12:43:53 <jmcarthur_work> jkramer, i don't know what you are trying to do
12:44:07 <monochrom> Haha 0x is hex not binary
12:44:18 <monochrom> > 0x202
12:44:19 <lambdabot>   514
12:44:24 <jkramer> jmcarthur_work: I'm trying to build a mapper from database columns/values to native haskell types for some kind of ORM
12:44:42 <ns_schoe> So, to figure it out, I have to convert 0x0101 to binary format, then shift left then I'll find 514 ??
12:44:49 <jmcarthur_work> jkramer, what kind of interface do you want it to have?
12:44:59 <monochrom> Or let the computer do it for you.
12:45:38 <jkramer> jmcarthur_work: I wrote the Value typeclass so I can add instances to any haskell type and turn it into a string that I can store in the database (and backwards)
12:45:47 <ns_schoe> Yeah but I meant to understand.
12:46:07 <p_l> MyCatVerbs: The shortest quine ever was a C quine constructed out of an empty file
12:46:16 <MyCatVerbs> Baughn: ah! That is a good one.
12:46:26 <monochrom> If you understand hex, you see 101 shifted left is 202.
12:46:31 <MyCatVerbs> p_l: uh, how? Undefined reference to main().
12:46:47 <p_l> MyCatVerbs: The compiler didn't complain and created an executable that did nothing
12:46:58 <MyCatVerbs> p_l: What compiler does that? gcc doesn't.
12:47:16 <MyCatVerbs> monochrom: or if you understand that (shiftL k) == (* (2^k)).
12:47:19 <jkramer> jmcarthur_work: Then I've put the Value a into the ColumnValue data so I can have representations of NULL and another constructor for skipped columns (e.g. for inserts where not all columns are defined)
12:47:20 <jmcarthur_work> jkramer, so Value basically says you can serialize the value to and from SQL
12:47:28 <jkramer> Right
12:47:39 <p_l> MyCatVerbs: modern gcc doesn't, it was long time ago. Afaik author was a lecturer who got bored of students coming up with "shortest quines ever" :P
12:48:12 <ns_schoe> Yep, okay I got it now.
12:48:17 <ns_schoe> Thanks guys.
12:48:46 <jmcarthur_work> jkramer, okay, so ColumnValue is either a value or one of two kinds of null?
12:49:02 <jkramer> Yup
12:49:22 <MyCatVerbs> p_l: ah well. bash and Perl and Python and most other interpreted languages that I know of treat the empty file as a quine anyway. :)
12:49:24 <jkramer> But NULL really translates to NULL, and SkipColumn means that the column is just not defined
12:49:25 <jmcarthur_work> and you don't want to parameterize it on the type of value?
12:50:04 <jkramer> No, I used the typeclass so one can add more sqlizable data types later
12:50:24 <jmcarthur_work> jkramer, i mean parameterize ColumnValue
12:50:27 <jkramer> Currently only Int and Char (+ [a] -> String) are instances
12:50:36 <p_l> MyCatVerbs: the target was to have an executable that you can run from shell
12:50:47 <jkramer> jmcarthur_work: What do you mean?
12:51:19 <jmcarthur_work> jkramer, data ColumnValue a = SkipColumn | NULL | RealValue a
12:51:21 <MyCatVerbs> p_l: Oh, that's easy. :)
12:51:35 <MyCatVerbs> p_l: Just "compile" the empty Python file with py2exe first.
12:52:16 <jkramer> jmcarthur_work: I've never seen that before :)
12:52:36 <jmcarthur_work> jkramer, and you knew about existential quantification? O_o
12:52:36 <monochrom> I was thinking of a degenerate programming language that contains just the empty string and the operational semantics is output the empty string.
12:52:38 <MyCatVerbs> Which "just" IIRC bundles a copy of the Python interpreter with your source files. Obviously it involves a little more work than that because it's not *completely* trivial, but same principle. :)
12:52:51 <MyCatVerbs> monochrom: welcome to hq9+. :)
12:53:01 <jkramer> jmcarthur_work: Someone told me about it yesterday :)
12:53:21 <dmead> hey channe
12:53:24 <monochrom> What does SkipColumn do?
12:53:28 <dmead> is hugs still maintained?
12:53:50 <jmcarthur_work> jkramer, parameterization has a lot of benefits. namely: you know the type :)
12:53:52 <jkramer> monochrom: It says that the column this value is assigned to will not be included in an insert statement, for example
12:53:52 <gwern> > 4 * 60 * 16
12:53:53 <lambdabot>   3840
12:54:11 <jkramer> jmcarthur_work: Can you point me to a paper? :)
12:54:21 <jmcarthur_work> jkramer, it's plain ol' haskell 98
12:54:34 <jmcarthur_work> dunno if there's a paper just about this
12:54:45 <gwern> > 1500 / 3.8
12:54:45 <jkramer> Googling it just takes me to a haskell package parameterized-data :)
12:54:46 <lambdabot>   394.7368421052632
12:54:50 <jmcarthur_work> jkramer, maybe check some of the tutorials for sections on data types
12:55:18 <jkramer> I'll check if learnyouahaskell has something about it :)
12:55:24 <monochrom> Think of Maybe.
12:55:34 <jmcarthur_work> data Maybe a = Nothing | Just a
12:55:48 <jmcarthur_work> basically the same thing with one less null than your type
12:56:17 <p_l> MyCatVerbs: well, today it is. Back then, I'm not sure if Python had it :P
12:56:51 <jkramer> jmcarthur_work: Can I still use my typeclass with this?
12:57:21 <jmcarthur_work> sure
12:57:43 <jmcarthur_work> that's the point, in fact.
12:57:49 <a_guest> is there some vector/point type in haskell, which have scalar multiplication and all other usual operations?
12:57:57 <jmcarthur_work> however, you might want to consider using an old fashioned ADT instead of a type class
12:58:22 <jmcarthur_work> unless you are going to make this library accept custom data types from the database
12:58:33 <jmcarthur_work> such that the client code can provide new instances
12:58:57 <jmcarthur_work> a_guest, check the math section of hackage
12:59:05 <jmcarthur_work> there are a few
12:59:57 <jkramer> jmcarthur_work: That's what I intended to do - I want to be able to add new types later, e.g. for dates, references etc
13:00:03 <jmcarthur_work> HSFFIG looks nice
13:00:16 <jmcarthur_work> jkramer, *you* do or you want to allow *client* code to?
13:01:00 <jmcarthur_work> jkramer, unless you are defining custom types, database typically have a close set of data types
13:01:12 <jmcarthur_work> *databases
13:01:13 <ulrivo> hi. I have a funny question. I dont understand why "(1::Data.Word.Word8) `mod` 256" gives an exception: divide by zero
13:01:16 <jmcarthur_work> *closed
13:01:50 <Zao> ulrivo: Because 256 as Word8 is 0.
13:01:51 <a_guest> 256 not in Word8?
13:01:52 <monochrom> 256 is 0.
13:01:54 <Twey> ulrivo: What's the maximum bound of Word8?
13:01:55 <jmcarthur_work> > 1 `mod` 256 :: Word8
13:01:56 <lambdabot>   * Exception: divide by zero
13:01:59 <jmcarthur_work> > 1 `mod` 255 :: Word8
13:02:00 <lambdabot>   1
13:02:00 <dschoepe> > maxBound :: Word8
13:02:01 <lambdabot>   255
13:02:02 <Twey> > 256 :: Word8
13:02:03 <lambdabot>   0
13:02:09 <Zao> > 260 :: Word8
13:02:10 <lambdabot>   4
13:02:16 <Twey> Wrap-around.
13:02:23 <ulrivo> oops...of course, it is...thanks
13:02:44 <jkramer> jmcarthur_work: The point is that I want the client/user to be able to use "normal" types in data structures, instead of special SQL types like SqlBind stuff from HSQL
13:03:15 <jkramer> But maybe I need to rethink the whole concept :)
13:03:24 <jkramer> All this new stuff confueses me
13:04:27 <jmcarthur_work> jkramer, you can still have functions foo :: String -> SqlType and bar :: SqlType -> String
13:05:49 <jmcarthur_work> jkramer, if you don't export the internals of your SqlType type and only allow client code to create/read them with those functions, you have the same interface as your Value type class
13:05:58 <jmcarthur_work> jkramer, except the type inference is clearly simpler
13:06:10 <jkramer> jmcarthur_work: Hmm, I guess you're right
13:06:24 <jkramer> jmcarthur_work: I'll go and have a few beers over this :)
13:06:28 <jmcarthur_work> jkramer, the only drawback is that client code can no longer make another instance of the "type class" because there is none
13:11:04 <domme> can anyone help me with leksah? if i try to add an module i get The field Root of the source path has an invalid value
13:11:13 <domme> but i cant edit that field :)
13:12:05 <Rotaerk> domme, maybe the IDE's immutable :>
13:12:42 <domme> Rotaerk: hum? :)
13:12:52 <Rotaerk> nm
13:13:50 <domme> okay :/
13:16:47 <Berengal> Rotaerk, it should be, since it's written in haskell.
13:17:01 <Rotaerk> exactly
13:17:31 <Berengal> But you probably get a new one several times a second
13:26:08 <drhodes> :t clip
13:26:09 <lambdabot> Not in scope: `clip'
13:29:25 <dpratt71> @src ap
13:29:25 <lambdabot> ap = liftM2 id
13:29:35 <dpratt71> :t liftM2
13:29:36 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:29:47 <dpratt71> :t id
13:29:48 <lambdabot> forall a. a -> a
13:30:07 <dpratt71> trying to reason about the definition of ap...and failing
13:30:55 <dpratt71> how can "id" be the first argument of liftM2? am I being dense?
13:32:15 <jmcarthur_work> dpratt71, mentally replace id with ($)
13:32:30 <jmcarthur_work> dpratt:t id
13:32:32 <jmcarthur_work> oops
13:32:34 <jmcarthur_work> :t id
13:32:35 <lambdabot> forall a. a -> a
13:32:37 <jmcarthur_work> :t ($)
13:32:38 <lambdabot> forall a b. (a -> b) -> a -> b
13:32:40 <byorgey> dpratt71: the first argument of liftM2 has type   (a1 -> (a2 -> r)).
13:32:48 <byorgey> dpratt71: so to unify that with  a -> a,
13:32:58 <byorgey> set a = a1 = a2 -> r .
13:33:34 <byorgey> so id is being used with type  (a -> b) -> (a -> b), or without the unnecessary parens,  (a -> b) -> a -> b.
13:33:42 <byorgey> which is just function application.
13:33:49 <dpratt71> ok
13:34:01 <jmcarthur_work> the definition would probably be more clear with ($)
13:34:06 <byorgey> I agree.
13:34:14 <dpratt71> thanks, jmcarthur, byorgey
13:34:32 <sproingie> (a -> b) -> a -> b can only ever be function application, right?
13:34:38 <sproingie> one of those "theorems for free"?
13:34:43 <dpratt71> the intuition isn't 100% yet, but much closer than it was :)
13:34:57 <jmcarthur_work> @djinn (a -> b) -> a -> b
13:34:57 <lambdabot> f a = a
13:35:02 <Berengal> sproingie, assuming no free variables in it's definition...
13:35:49 <jmcarthur_work> sproingie, djinn doesn't prove what you asked, but what you say is true, afaik
13:36:10 <sproingie> yay
13:36:15 <MyCatVerbs> p_l: depending on when "back then" was, Python might not've existed. :P
13:36:41 <MyCatVerbs> p_l: I suspect that Perl probably did though, and that's had something along the lines of perl2exe practically forever. ;)
13:37:09 <domme> can i use ghci in leksah?
13:37:23 <domme> have the interactive mode somewhere in the ide?
13:37:25 <sproingie> sigh.  same problems running ld in another distro
13:37:32 <sproingie> i think it just hates having less than half a gig
13:37:49 <sproingie> i'll just let it thrash all day.  good thing i'm not billed for disk i/o
13:38:57 <FunctorSalad> The free theorem for the type signature
13:38:57 <FunctorSalad>   f1 :: forall a b . (a -> b) -> a -> b
13:38:57 <FunctorSalad> in the language subset `basic' is:
13:38:57 <FunctorSalad>   forall t1,t2 in TYPES, f :: t1 -> t2.
13:38:57 <FunctorSalad>    forall t3,t4 in TYPES, g :: t3 -> t4.
13:38:58 <FunctorSalad>     forall p :: t1 -> t3.
13:39:00 <FunctorSalad>      forall q :: t2 -> t4.
13:39:02 <FunctorSalad>       (g . p = q . f) ==> (g . f1 p = f1 q . f)
13:39:10 <FunctorSalad> o_O
13:39:54 <p_l> MyCatVerbs: I remember now where I found it - International Obfuscated C Code Contest :P
13:40:09 <mmorrow> @remember Baughn There's also the language, Quine, whose interpreter is implemented as a symlink to /bin/cat
13:40:09 <lambdabot> I will never forget.
13:40:12 <mmorrow> heh
13:41:01 <mmorrow> too bad Quine can't implement its interpreter..
13:41:33 <Baughn> It can, but only in compilation mode
13:41:44 <Berengal> mmorrow, I've just defined cat to be a programming language. No need to "reinvent" the wheel
13:41:53 <Baughn> And it uses the Faerie source-code format
13:42:03 <Baughn> ..ELF, some call it.
13:42:23 <LegendaryPenguin> why does fmap have the word map in it
13:42:39 <Baughn> It's a fair description of what it does
13:42:49 <Berengal> LegendaryPenguin, because it maps a function on objects over a structure
13:43:00 <mcspiff> no ghc on Snow leaopord?
13:43:13 <mcspiff> leopard rather
13:43:36 <Berengal> The function, and the objects it operates on, as well as the objects themselves, don't know anything about the structure, or how you map over it. Conversely, fmap and the structure don't know anything about the function and the objects...
13:45:43 <FunctorSalad> I thought the 'f' stands for 'functor'
13:45:48 <FunctorSalad> ^_^
13:46:01 <FunctorSalad> functor-map or something
13:46:13 <Berengal> It maps over a functor... sort of thing
13:46:16 <LegendaryPenguin> but i thought map means you apply something to multiple elements
13:46:31 <FunctorSalad> it generalizes map
13:46:32 <jmcarthur_work> not only
13:46:40 <Berengal> LegendaryPenguin, only in the sense of structures with multiple objects
13:46:51 <jmcarthur_work> > fmap (+1) (Just 1)
13:46:51 <aavogt> same namespacing thing as  gmap, mapM, mapA ...
13:46:52 <lambdabot>   Just 2
13:46:57 <jmcarthur_work> > fmap (+1) Nothing
13:46:57 <lambdabot>   Nothing
13:47:17 <Berengal> you can also think of map as meaning it maps a function on objects to a function on objects in a structure
13:47:17 <jmcarthur_work> > fmap (+1) (\x -> x*2) 5
13:47:18 <lambdabot>   11
13:47:24 <jmcarthur_work> > fmap (+2) (\x -> x*2) 5
13:47:25 <lambdabot>   12
13:47:28 <FunctorSalad> @type fmap `asTypeOf` map
13:47:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:47:31 <FunctorSalad> ;)
13:47:33 <Berengal> fmap :: (a -> b) -> (f a -> f b)
13:52:02 * Berengal started reading an intro paper on CT recently, but made the mistake of looking at the end
13:52:18 <Berengal> "([  ]) F can be written as \ for some suitably chosen D -cocone  . This guess is sufficient to start the proof of () , deriving a definition for  (more specifically, for 0 and S ) along the way"
13:52:32 <sproingie> the proof of clubs?
13:52:46 <Berengal> Indeed. He had just proved spades before
13:53:05 <sproingie> ran out of greek letters i guess
13:53:06 <mmorrow> wow, i need to start using greek chars and unicode arrows in combo more
13:53:34 <Botje> "Welcome to #haskell, we  imperative programmers"
13:53:54 <mmorrow> , (text . utf8enc . take 25) [''..]
13:53:55 <lunabot>  
13:54:01 <FunctorSalad> 
13:54:10 <sproingie> @remember Botje "Welcome to #haskell, we  imperative programmers"
13:54:10 <lambdabot> Okay.
13:54:31 <Botje> @quote 
13:54:32 <lambdabot> Botje says: "Welcome to #haskell, we  imperative programmers"
13:54:38 <Botje> cool, lambdabot can handle unicode! :
13:55:33 <monochrom> We -reduce imperative programmers.
13:56:25 <mmorrow>  ,  ..
13:56:33 <Botje> that's not nearly as violent as -reducing, i think :)
13:56:56 <FunctorSalad> why
13:57:02 <mmorrow> "sing of wrath, goddess .."
13:57:03 <skorpan> what's -reduction?
13:57:12 <kw317> hmm.. am I loosing it or is factorial normally written n!?
13:57:16 <Botje> skorpan: reducing foo x = ... x to foo = ...
13:57:17 <monochrom> Ha, but I was not trying to be violent.
13:57:22 <Botje> kw317: you are correct.
13:57:22 * kw317 has some weird lecture notes..
13:57:24 <byorgey> kw317: yes.
13:57:29 <mmorrow> monochrom: that's what they all say
13:57:32 <byorgey> kw317: how is it written in your lecture notes?
13:57:33 <Botje> monochrom: ah. okay. moderate violence is okay!
13:57:36 <mauke>  again
13:57:37 <kw317> my lecturer somehow prefers to write !x
13:57:39 <kw317> ;-)
13:57:41 <byorgey> weird.
13:57:49 <mmorrow> mauke: :)
13:58:10 <kw317> yeah, something felt not quite right and suddenly it was "Aha! wtf?" ;-)
13:58:16 <FunctorSalad> "meden"? what
13:58:20 <mauke> x!
13:58:29 <monochrom> (\x -> f x) becomes f, that's -reduction. It is an important tool in going higher-order, more pointfree, more enlightened. We enlighten imperative programmers.
13:59:35 <Botje> chopping bits off could also be seen as "enlightening" >:)
13:59:51 <domme> is there an ghci mode or something in leksah where you can enter things interactively?
13:59:51 <Berengal> Higher-order doesn't neccessarily mean point-free. It just means we treat functions as values with different operators ;)
14:00:00 <sproingie> beta reduction would be what, solving?
14:00:00 <Berengal> domme, don't think so, unfortunately
14:00:14 <domme> Berengal: hum.. that sucks :\
14:00:15 <monochrom> I know, that is why I list them in parallel.
14:00:31 * sproingie sings,   how do you beta-reduce a problem like maria  
14:00:37 <domme> Berengal: then i dont know why it reloads the module after building the package :/
14:00:37 <kw317> sproingie: beta reduction embodies the computation in functional languages
14:00:45 <monochrom> hahaha sproingie
14:01:05 <monochrom> @remember sproingie  how do you beta-reduce a problem like maria 
14:01:05 <lambdabot> Okay.
14:01:12 <kw317> lol
14:01:20 <mauke> @slush
14:01:20 <lambdabot> Not enough privileges
14:01:25 <Berengal> domme, there was some ghci debugging thingy in there, but I never checked it out.j
14:01:34 <sproingie> the reason rodgers and hammerstein weren't programmers
14:01:58 <mauke> @slush
14:02:03 <sproingie> @slush?
14:02:04 <lambdabot> Not enough privileges
14:02:32 <sereven> @lift
14:02:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:03:04 <Berengal> @pixel hello
14:03:04 <lambdabot> hiya
14:03:20 <Berengal> <3 dwim
14:03:39 <Berengal> (For it's absurdist comedy)
14:04:26 <kw317> what book for denotational semantics would you recommend?
14:04:26 <aavogt> @vine
14:04:26 <lambdabot> Maybe you meant: dice kind ping time vixen vote
14:04:28 <monochrom> -reduce means from (\x -> ... x ...) y to ... y ...
14:05:29 <domme> Berengal: ah.. it's strange
14:05:31 <domme> but it works
14:06:32 <domme> Berengal: you have activate the debugger, then you can enter something in a textbox.. the strange thing about this: you have to mark what you just wrote in order to execute it through some right click menu
14:06:52 <FunctorSalad> heh I couldn't figure that box out either
14:07:02 <FunctorSalad> mystery box
14:07:26 <domme> FunctorSalad: that box i'm talking about?
14:07:35 <FunctorSalad> the one on upper right?
14:07:45 <domme> FunctorSalad: yup
14:07:57 <FunctorSalad> you can right-click, "type" in the main window too so I really don't get it ;)
14:07:57 <mpwd> Has anyone read Papadimitrou's "LOGICOMIX"?  Is it any good?
14:07:58 <domme> FunctorSalad: with line numbers... like the actual editor
14:08:12 * mpwd is a little sorry that this isn't exactly a haskell question
14:08:48 <domme> FunctorSalad: but you cant execute expressions ;D
14:08:49 <byorgey> mpwd: it's great.
14:08:59 <domme> mh.. oh you can
14:09:01 <domme> dunno :D
14:09:58 <byorgey> kw317: I had recommended to me "Semantics of Programming Languages" by Gunter, although I haven't gotten around to reading it yet.
14:10:01 <domme> well you dont have to modify your source :)
14:10:02 <Berengal> domme, I'd probably just use a regular ghci in a terminal. A little sad, but works nicely
14:10:24 <domme> Berengal: yup.. :/
14:11:02 <Berengal> You get some nice things for free with integrated ghci though, like type-inference of top-level declarations
14:11:04 <mpwd> kw317: There's always Barendregt's "Lambda Calculus: Its Syntax and Semantics" but this is really what the hardcore theorists read
14:11:08 <gspr> I seem to be confused by too many levels of pointers... if I have a CIntPtr type, how do I extract the Int it (C-)points to?
14:11:12 <Berengal> I wrote that for yi
14:11:17 <joeally> I am a new to haskell
14:11:21 <mauke> gspr: what's CIntPtr?
14:11:34 <joeally> i have written a fibonaccia function
14:11:38 <joeally> fib (x:x1:xs) = x:(x+x1):fib (x1:xs)
14:11:59 <joeally> fib (x:x1:xs) = x : (x+x1) : fib (x1:xs)
14:12:11 <gspr> hoogle CIntPtr
14:12:16 <joeally> when I try this :
14:12:17 <joeally> fib (x:x1:xs) = x:(x+x1):fib (x1:xs)
14:12:27 <joeally> take 10 (fib [1,2])
14:12:33 <gspr> @hoogle CIntPtr
14:12:34 <lambdabot> Foreign.C.Types data CIntPtr
14:12:42 <joeally> it says:
14:12:43 <joeally> [1,3*** Exception: fib.hs:1:0-35: Non-exhaustive patterns in function fib
14:12:58 <mauke> gspr: ah, it's intptr_t. why do you have that in the first place?
14:13:00 <joeally> i want it to be an ifinite list like cycle
14:13:11 <byorgey> joeally: well, let's think about it.  note that [1,2] is the same as 1:2:[], right?
14:13:19 <joeally> yeah
14:13:22 <Berengal> joeally, you recurse down the list, eventually reaching the end
14:13:27 <Berengal> Try fib [1..] instead
14:13:34 <byorgey> so  fib [1,2] = fib (1:2:[]) = 1 : (1+2) : fib (1:[])
14:13:44 <joeally> okay
14:13:53 <byorgey> but now there is no case for what should happen when fib is applied to a one-element list.
14:14:13 <joeally> oh I see thankyou
14:14:17 <gspr> mauke: I'm completely new to the FFI, and I'm just playing around with interfacing against a C library.... I need to handle several structs, some of which contain arrays of ints. Am I incorrect in believing that the Haskell side type should have CIntPtr in place of these?
14:14:22 <mauke> solution: don't make fib take a list
14:14:29 <mauke> gspr: yes
14:14:35 <joeally> okay
14:14:41 <joeally> thanks i'll try again
14:14:51 <mauke> gspr: unless the C library uses intptr_t's for some reason, which it doesn't
14:15:09 <gspr> mauke: Oops... what type should I use then?
14:15:11 <byorgey> joeally: yes, I don't think you want fib to operate on a list.  to start I would suggest having it take two Integer parameters (the starting values) and return a list.
14:15:14 <Berengal> .oO(corecursion is a funky beast)
14:15:24 <joeally> oh
14:15:42 <mauke> gspr: you should probably create a datatype for your struct and make it an instance of Storable
14:15:50 <mauke> also, arrays aren't pointers
14:15:53 <joeally> i'm pretty new to programming
14:16:12 <byorgey> joeally: great! welcome. =)
14:16:26 <joeally> thanks
14:16:29 <mmorrow> , craps()
14:16:32 <lunabot>  (,)
14:16:37 <gspr> mauke: I did create such a data type, but what should the type be of the ("accessor") function returning what corresponds to the integer array from C?
14:16:37 <mmorrow> yay!
14:16:54 <mmorrow> , fmap ($ ()) (replicate 10 craps)
14:16:57 <lunabot>  [(,),(,),(,),(,),(,),(,),(,),(,),(,),(,)]
14:17:04 <burp> lol
14:17:06 <mauke> gspr: whatever you want :-)
14:17:13 <mmorrow> , (replicate 10 (craps())
14:17:15 <lunabot>  luna: parse error (possibly incorrect indentation)
14:17:18 <mmorrow> , (replicate 10 (craps()))
14:17:20 <lunabot>  [(,),(,),(,),(,),(,),(,),(,),(,),(,),(,)]
14:17:32 <mauke> gspr: you could use a list of ints, or a haskell array, or a tuple
14:17:35 <FunctorSalad> Berengal: scion can actually lookup types for nontoplevel items... quite amazing
14:17:48 <mmorrow> (it uses unsafePerformIO for the randomness, so you have to act accordingly..)
14:17:49 <gspr> mauke: Ah, right, and then just write peek correctly?
14:17:52 <mauke> yeah
14:18:06 <mauke> are you using hsc2hs?
14:18:13 <gspr> mauke: I have been, yes
14:18:19 <mauke> ok
14:18:24 <mmorrow> oh crap, that first one should of had all different rolls..
14:18:25 <Berengal> FunctorSalad, yeah, that's even better than leeching off of ghci, but the latter is a simple five-line function (in yi, at least)
14:18:51 <byorgey> joeally: keep asking questions.  and remember, the pain is normal.  that's the feeling of your brain growing. ;)
14:18:57 <gspr> mauke: But hsc2hs's #peek on a struct containing an int array would just give me the memory address of the first element, right?
14:18:57 <FunctorSalad> Berengal: I think it uses the annotated ast returned by the typechecker
14:19:08 <mmorrow> , fmap ($ ()) (replicate 2 craps)
14:19:11 <lunabot>  [(,),(,)]
14:19:12 <gspr> mauke: And then, when I write my own peek, I offset from this?
14:19:15 <mmorrow> sigh
14:19:32 <mmorrow> at least you get one roll per expression at least
14:19:43 <Berengal> FunctorSalad, I haven't looked at it, but I'd love something like that for leksah. If anyone implemented it, I might even switch from yi
14:19:55 <mauke> gspr: peekArray
14:19:59 <Berengal> , (craps (), craps ())
14:20:01 <lunabot>  ((,),(,))
14:20:02 <mauke> from Foreign.Marshal.Array
14:20:25 <gspr> mauke: Oh my bleep.. how did I not see Foreign.Marshal.Array?! Well, thank you so much, sir! ;)
14:20:29 <Berengal> mmorrow, ninja CSE
14:21:13 <mmorrow> , let dominoes n _ | n < 1 = []; dominoes k = let !o = k () in o : dominoes (n-1) k in dominoes 4 craps
14:21:15 <lunabot>  luna: Equations for `dominoes' have different numbers of arguments
14:21:17 <gspr> mauke: Typical me to overlook things like that :)
14:21:22 <mmorrow> , let dominoes n _ | n < 1 = []; dominoes n k = let !o = k () in o : dominoes (n-1) k in dominoes 4 craps
14:21:23 <FunctorSalad> , repeat (craps ())
14:21:24 <mauke> :-)
14:21:25 <lunabot>  [(,),(,),(,),(,)]
14:21:26 <lunabot>  [(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),(,),...
14:21:37 <FunctorSalad> crapsstorm!
14:21:47 <mmorrow> it may have something to do with newStdGen always
14:21:49 <mmorrow> oh, duh
14:21:57 <FunctorSalad> (that was horrible)..
14:23:03 <mmorrow> this is the first legitimate need for get/setStdGen i've ever encountered..
14:23:10 * mmorrow fixes it
14:23:18 <mauke> > fix error
14:23:19 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:23:32 * mauke assists unhelpfully
14:23:45 <Asztal> > mfix error
14:23:45 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
14:23:46 <lambdabot>    arising from a use ...
14:24:16 <Deewiant> > mfix error :: [String]
14:24:17 <lambdabot>   * Exception: * Exception: * Exception: * Exception: * Exception: * Exceptio...
14:24:41 <FunctorSalad> btw, *what* does the MonadFix IO instance do?
14:24:55 <Asztal> Deewiant: in IO, I get "*** Exception: *** Exception: <<loop>>" :D
14:25:27 <Berengal> FunctorSalad, internally?
14:25:57 <FunctorSalad> Berengal: externally too
14:26:29 <joeally> yusss i figured it out
14:26:31 <joeally> fib1 x y = [x+y]++fib1 y (x+y)
14:26:31 <joeally> fib x y = x:y:fib1 x y
14:26:44 <mauke> [x+y]++ better written as (x+y):
14:26:56 <Berengal> FunctorSalad, externally it just feeds values back into itself, like any other MonadFix
14:26:59 <joeally> okay thanks
14:27:45 <mauke> > let fib x y = x : fib y (x + y) in fib 1 1
14:27:45 <FunctorSalad> Berengal: it's not the straightforward "mfix f x = f =<< mfix f x" though
14:27:46 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
14:27:51 <Asztal> it's not actually all that scary: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
14:28:17 <Berengal> FunctorSalad, no, mfix isn't that straightforward in general. It's guaranteed to only execute once
14:28:53 <FunctorSalad> oh right what I just wrote would work for any monad :o
14:29:18 <Berengal> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
14:29:35 <Berengal> MonadFix IO mfix = fixIO
14:29:49 <FunctorSalad> Asztal: I find that a bit scary
14:30:13 <Berengal> I'm slow today :(
14:31:30 <Berengal> Still, seems straightforward enough
14:32:39 <Berengal> (Mixing IO with fixpoints is scary though)
14:32:51 <FunctorSalad> except for the time travel it apparently does?
14:33:48 <Berengal> FunctorSalad, well, the implementation shows how it's done, which is really just smoke and mirrors
14:34:09 <Asztal> if k uses the parameter before its IO is completed, you'll get a NonTermination exception
14:35:28 <Berengal> does the mdo notation minimize the number of statements included in the desugared mfix?
14:36:34 <mmorrow> i give up
14:36:53 <bockmabe> Anyone hear familiar with an EDSL method of generating network protocol stacks?
14:36:58 <mmorrow> can't seem to get unsafePerformIO with the randGen to behave
14:37:01 <bockmabe> s/hear/here
14:37:08 <mmorrow> , fmap ($ ()) (replicate 4 randExp)
14:37:10 <lunabot>  luna: Not in scope: `randExp'
14:37:13 <mmorrow> , fmap ($ ()) (replicate 4 randE)
14:37:15 <lunabot>  [(- 6) (if [] then if x3 then "This is a " else 0 else let { x3 2 = x6} i...
14:37:23 <mmorrow> , fmap ($ ()) (replicate 2 randE)
14:37:26 <lunabot>  [[x11, x0 x21 x13, \ _ [] -> "This is a stri"],[x11, x0 x21 x13, \ _ [] -...
14:37:36 <mmorrow> ok, it's not just craps
14:38:01 <Berengal> mmorrow, unsafePerformIO . runRandIO, put craps in MonadRandom?
14:38:11 <mmorrow> it may be something to do with bytecode and how different copies of things are flying around
14:38:23 <Berengal> (not sure if it's runRandIO, I'm just guessing)
14:38:28 <mmorrow> Berengal: try it
14:38:30 <gspr> mauke: Hah, thanks - your tip worked like a charm ;)
14:38:56 <gspr> mauke: My haskell program is spitting out data from my wiimote accelerometer :)
14:39:01 <mmorrow> Berengal: i changed craps to atomicModifyIORef an (unsafePerformIO (newIORef =<< newStdGen)) IORef, and it still's borked
14:39:15 <gspr> (correct data, now that I did what you told me to :P )
14:39:42 <mmorrow> Berengal: which makes me think something odd is happening with the bytecode and linking or some weirdness
14:40:14 <Berengal> mmorrow, it may be that you're relying on too many IO actions that somehow happen to get CSEd when unsafePerformed
14:41:24 <mmorrow> Berengal: this works in ghci
14:41:27 <mmorrow> ghci> let roll = do i <- randomRIO (0,5); j <- randomRIO (0,5); return (i,j)
14:41:27 <mmorrow> ghci> let go () = unsafePerformIO roll
14:41:32 <mmorrow> giving
14:41:35 <mmorrow> ghci> fmap ($ ()) (replicate 4 go)
14:41:36 <mmorrow> [(0,4),(3,0),(4,2),(3,5)]
14:42:07 <mmorrow> but somehow it doesn't in teh bot, (although the bot is dynamically compiling expressions to bytecode with the ghc-api)
14:42:23 <FunctorSalad> > mfix (\self x -> if x == 0 then return 1 else [x*self (x-1)]) 5
14:42:24 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[t]'
14:43:25 <jfredett> @quote Botje imperative
14:43:26 <lambdabot> Botje says: "Welcome to #haskell, we  imperative programmers"
14:43:35 <jfredett> what the hell symbol is that?...
14:43:48 <FunctorSalad> club suite
14:43:53 <Berengal> jfredett, 
14:43:56 <jfredett> hmm.
14:44:00 <jfredett> Berengal: thanks...
14:44:07 <Berengal> Happy to help :)
14:44:10 <jfredett> that doesn't show up correctly for some reason.
14:44:26 <jfredett> now that you say that, it looks like half a club-suit...
14:44:45 <kpreid> @. pl undo (\x -> do a <- f x; g a)
14:44:46 <lambdabot> (g =<<) . f
14:45:55 <jfredett> I have a quote in my database from Virginia_Curry... was she on IRC recently? :/
14:46:30 <jfredett> ... I don't want to use it unless I can attribute it, but it's really pretty good...
14:46:39 <FunctorSalad> oh wait the argument of mfix up there must be of type ((Int -> Int) -> [Int -> Int])...
14:47:20 <kpreid> @paste
14:47:20 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:47:29 <Berengal> jfredett, 10:06:11 <ski> @remember Virginia_Curry You know, Haskell actually never liked the name Haskell. http://tunes.org/~nef/logs/haskell/09.10.16
14:47:42 <FunctorSalad> > mfix (\self -> [\x -> if x==0 then 1 else x*self (x-1)]) 5
14:47:43 <lambdabot>   Couldn't match expected type `t1 -> t'
14:47:43 <lambdabot>         against inferred type `[a ->...
14:48:14 <FunctorSalad> > fmap ($5) (mfix (\self -> [\x -> if x==0 then 1 else x*self (x-1)]))
14:48:15 <lambdabot>   [120]
14:48:18 <kpreid> What's wrong with my code that it has an infinite type? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4411#a4411
14:48:24 <kpreid> ...oh. Now I see.
14:48:43 <jfredett> Berengal: hmm, I think I'll avoid it then. Since it's second hand...
14:48:55 <kpreid> Oh well, suggestions to make it prettier are welcome too :)
14:49:07 <Berengal> jfredett, it's also somewhat well-known
14:50:11 <FunctorSalad> Virginia Curry is a relative of Haskell and is on IRC....?
14:50:17 <mmorrow> Berengal: the dynamic bytecode doesn't seem to be able to modify any IORefs and see the changes
14:50:31 <mmorrow> Berengal: (and since the global StdGen is an IORef, that too)
14:51:00 <zzzs> so if i have a data structure data Page = Page header [keys] [data], in
14:51:00 <zzzs>        inserting a new (key, data) pair to the page, because haskell's data is
14:51:00 <zzzs>        immutable, does it mean that one ends up with another copy of the old
14:51:00 <zzzs>        Page plus the additional data
14:51:08 <mmorrow> Berengal: given this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4412#a4412
14:51:11 <Berengal> mmorrow, that is a bother. What about making the MonadRandom's run function available?
14:51:20 <mmorrow> , tick() `seq` tick() `seq` tick()
14:51:22 <lunabot>  0
14:51:24 <mmorrow> should give 2
14:51:35 <mmorrow> , tick(tick(tick()))
14:51:37 <lunabot>  0
14:51:38 <mmorrow> as should that
14:51:54 <mmorrow> it may be something with ghci's linker
14:52:11 <Berengal> It does seem to be able to modify it inbetween expressions though
14:52:40 <Berengal> Or is that just some other random action using newStdGen? (pardon the pun)
14:52:57 <int-e> jfredett: the quote is mentioned in the history of haskell paper here, for example: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
14:53:44 <zzzs> is it possible to just tweak the data block w/o having haskell really re-create/copy to another place?
14:54:05 <mmorrow> Berengal: each separate expression is an entirely new instance of the eval prog process
14:54:31 <mmorrow> (process as in an OS-level process, getting the expression on stdin -> stdout)
14:55:14 <Axman6> zzzs: making a copy doesn't necessarilly mean copying all the values
14:55:23 <mmorrow> zzzs: you'll probably want to use a (Map key data) instead of lists
14:55:32 <mmorrow> zzzs: (and if the key type is Int, use IntMap)
14:55:39 <Berengal> zzzs, a new constructor will be allocated for the new Page, a new reference to header will be allocated in that constructor, but header will be reused, a new cons each for keys and data will be allocated, and new references to those conses will be allocated in the Page constructor. The old lists will be reused by the conses
14:55:49 <mmorrow> zzzs: otherwise that'll be pretty brutal with lists
14:57:49 <Berengal> mmorrow, I see...
14:57:58 <zzzs> i see, so map is a cheaper data structure, though it still bugs me that it needs to do a new constructor
14:58:48 <Berengal> zzzs, in general, you can't determine if the old constructor becomes garbage without running a garbage collection scan. Doing so on each allocation is a bit of a waste...
14:58:49 <mmorrow> zzzs: when you update a map, the only part that changes is the string of constructors from the root to the node you update
14:59:09 <zzzs> is it possible to do something like in C where page is a block of bytes, and i get to write whatever bytes i want in the block -- i.e. casting it key or data or page header for example
14:59:23 <mmorrow> zzzs: what are the types of "key" and "data"
14:59:50 <mmorrow> zzzs: since there's a GC, there's a distinction between GC-followed pointers and other Ptr's
14:59:54 <zzzs> Key = Key len bytestring
14:59:58 <Vanadium> zzzs: Just use the FFI C stuff and basically write C?
15:00:08 <mmorrow> zzzs: oh nice, what about data?
15:00:28 <mmorrow> (ByteString = ByteString (ForeignPtr Word8) Int Int)
15:00:31 <Berengal> mmorrow, expose evalRand' = unsafePerformIO . evalRandIO (from Control.Monad.Random), let craps = fmap toMagicChar (getRandomR (0, 5))
15:01:01 <zzzs> Data = Data [len] bytestring
15:01:34 <mmorrow> and len?
15:01:41 <mmorrow> Int or something?
15:01:46 <zzzs> Int
15:02:09 <mmorrow> nice, so all this data doesn't really contain any gc ptrs
15:02:14 <zzzs> i can write the whole thing in C, but wanted to see if there is a way do it in haskell w/o incurring the memory cost
15:02:17 <mmorrow> so you could use a mutable array
15:03:49 <hackagebot> IDynamic 0.1 - Indexable, serializable form of Data.Dynamic (AlbertoCorona)
15:04:13 <jimi_hendrix> hi, i am learning haskell and have a question: why should i define function types when the compiler can just do it for me?
15:04:14 <Saizan_> mh, serializable?
15:04:14 <jkramer> I'm not sure if anyone uses it, but the hayoo search engine has been down for a while now
15:04:22 <Saizan_> ?hackage IDynamic
15:04:23 <lambdabot> http://hackage.haskell.org/package/IDynamic
15:04:32 <mauke> jimi_hendrix: it's a form of documentation
15:04:44 <mauke> jimi_hendrix: it helps the compiler sanity-check your code
15:04:53 <mauke> jimi_hendrix: you get better error messages if you make a mistake
15:05:03 <jimi_hendrix> ok
15:05:11 <monochrom> jimi_hendrix: sometimes to help reader. sometimes to help catch type errors of your own. sometimes to tell haddock that this function is exported and you write external doc for it.
15:05:15 <jimi_hendrix> (i noticed the errors can be cryptic/not helpful)
15:05:21 <Berengal> jimi_hendrix, also, it's fine to let the compiler help you write the types; you don't have to do them up front
15:05:30 <jkramer> Is there an offline version of hayoo like for hoogle?
15:05:34 <jimi_hendrix> Berengal, how do i do that
15:05:42 <Berengal> jimi_hendrix, using ghci and :t
15:05:54 <zzzs> mmorrow: implement both [key] and [data] as mutable arrays? but Page would still have to re constructed i guess?
15:06:10 <Berengal> just write you function, then ask ghci what type it has, and if it looks reasonable, copy-paste it back into the code
15:07:00 <Berengal> zzzs, only if you switch out either one of header, [key] or [data]
15:07:13 <Berengal> zzzs, modifying the arrays directly won't change anything
15:07:47 <sproingie> in emacs, you can insert the inferred type with a keypress.  ctrl-u ctrl-x ctrl-t or something like that
15:07:57 <jkramer> Hrhrhr
15:07:59 <sproingie> i have mine mapped to ctrl-t
15:08:31 <sproingie> it does have to be loaded in ghci first tho, so you can't infer if your file has errors
15:08:51 <Berengal> sproingie, I use that alot too (in yi)
15:10:02 <Axman6> ChilliX: are you around?
15:10:09 <zzzs> Berengal, i see, so for that matter, would i be better off to have header defined as mutable array as well, but just have one element?
15:10:25 <mauke> what, like an IORef?
15:10:27 <Berengal> zzzs, you could just let it be a reference then
15:11:06 <zzzs> Berengal, what do you mean?
15:11:23 <Berengal> zzzs, what mauke said
15:12:20 <jkramer> is there a module for building SQL in a more abstract way, like SQL::Abstract in Perl?
15:12:28 <Berengal> zzzs, but really, you'd get lots of sharing and not too much memory gain by just using immutable types
15:12:56 <Berengal> jkramer, you could look at haskelldb, but I can't vouch for it's maturity
15:13:20 <jkramer> Nah, tried that one before :(
15:13:43 <zzzs> Berengal: what kind of sharing?
15:13:49 <Berengal> jkramer, would SQL::Abstract map nicely to haskell, you think?
15:14:07 <mauke> zzzs: you can't copy values in haskell
15:14:34 <zzzs> So my Page would be something like Page = Page (IORef Header) mutable-key-array,...
15:14:59 <jkramer> Berengal: Yes, it would be perfect :)
15:15:05 <Jeb> @paste
15:15:05 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:15:19 <Berengal> jkramer, then port it :)
15:15:27 <jkramer> Ok :)
15:15:38 <mauke> Language.Perl
15:15:48 <zzzs> mauke: i know, that's why i wanted to  see if i can just tweak/update the value w/o having haskell to creat/copy it for me
15:15:51 <Berengal> jkramer, I'd like something like that as well, but I don't know any perl, otherwise I might've considered it myself
15:16:01 <mauke> zzzs: Haskell does not copy values
15:16:44 <zzzs> mauke. i meant haskell calls the constructor and potentiall reconstruct the data
15:17:04 <mauke> "calls the constructor"?
15:17:26 <mauke> constructors are no-ops, basically
15:17:39 <Berengal> zzzs, cabal install vacuum-cairo, load System.Vacuum.Cairo, then 'view' some values to see their memory representation
15:17:51 <jkramer> Berengal: It's actually pretty simple, an in Haskell you can even do it in a nice, readable way :)
15:18:26 <Berengal> jkramer, I'm pushing it on my todo stack
15:18:38 <Berengal> But with dependencies on "learn perl"
15:20:52 <napsy> Are there any excercises for haskell on the web?
15:21:20 <jkramer> There's a site called owl-project or something like this
15:21:36 <mauke> napsy: spoj.pl :-)
15:21:38 <jkramer> With lots of programming exercises, fits Haskell very well
15:21:50 <JoePeck> napsy: a google search will solve your questions. I charge 5 cents for doing it for you ;) http://www.haskell.org/haskellwiki/99_Haskell_exercises
15:22:08 <zzzs> cabal: cannot configure vacuum-cairo-0.4.1. It requires cairo -any, gtk -any
15:22:08 <zzzs> and svgcairo -any
15:22:08 <zzzs>  
15:23:05 <zzzs> Berengal, are you saying that immutable data structure's benefit out-weight the memory issue
15:23:24 <joevandyk> fib = 1 : 1 : zipWith (+) fib (tail fib)  The part after the two 1's confuses me as to how it works.
15:23:38 <Berengal> zzzs, I'm saying that immutable data structures can even benefit memory useage
15:23:51 <mmorrow> zzzs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10832#a10832
15:23:56 <Berengal> zzzs, also, you want gtk2hs for vacuum-cairo...
15:24:20 <joevandyk> i know zipWith takes combines two lists, but the recursion and laziness is too weird fo rme
15:24:50 <Saizan_> zzzs: you don't always have to rebuild all the structure to create one with some modifications, often large parts can be shared and so don't need more memory
15:24:53 <Berengal> joevandyk, it's a regular expression. Think about how zipWith (+) works for other lists of numbers
15:25:00 <mauke> heh
15:25:06 <mauke> that's not a regular expression :-)
15:25:36 <joevandyk> Berengal: i get that
15:25:47 <jkramer> Berengal: Starting with the module right now, I'll let you now when there's a git repo so you can watch and/or help :)
15:26:06 <mmorrow> zzzs: (if you happen to be on linux, and have graphviz-devel (the C package) installed, this may work for you http://moonpatio.com/repos/vacuum-gl/ (it has a similar function `view :: a -> IO ()' that vacuum-cairo has, but without the gtk dep. no guarantees that it won't asplode your computer, etc.. but i use it a bunch)
15:26:40 <Berengal> joevandyk, right, now, assume you've already got 'fibs' solved... you do have an infinite list of fibs... what's the result for zipWith (+) fibs (tail fibs) then?
15:27:39 <joevandyk> Berengal: a new list with each number of fibs added to the previous number of fibs
15:27:41 <joevandyk> hmm
15:27:58 <joevandyk> damn it programming doesn't work that way
15:28:06 <Berengal> joevandyk, hehe :P
15:28:43 <Berengal> jkramer, nice, I'll definitely look at it when you've got some haskell code
15:28:47 <joevandyk> Berengal: thing is that i expect recursion to have a base case, some sort of explict return
15:28:58 <Saizan_> it's more like each number added to the successive, i.e. the first pair is (first,second), not (second,first) or (first, ?)
15:28:59 <Berengal> joevandyk, ah, but this is /co/recursion
15:29:02 <mauke> joevandyk: that's the 1 : 1 : part
15:29:14 <joevandyk> hmmm
15:29:45 <Saizan_> yeah, the "1 : 1 :" bootstraps the recursion
15:29:54 <Berengal> joevandyk, regular recursion: to solve problem: 1) solve base case, 2) reduce general case to something that reduces to the base case, 3) solution is 1 + 2
15:29:55 <jkramer> What would be a good name for a type that represents something valuable in SQL, e.g. a value or a column name etc
15:30:44 <Berengal> joevandyk, corecursion: to solve problem: 1) assume problem is solved. Use solution to derive solutions for sub-problems, 2) combine solutions to sub-problems to solve entire problem
15:30:49 <Saizan_> an operational view is that "fibs" is a pointer to a singly linked list node, and evaluating the RHS fills it as it goes along, so when it starts to read some node it's already written
15:31:07 <Berengal> jkramer, variable?
15:31:30 <jkramer> Hmm, no :)
15:32:26 <joevandyk> Berengal: how common is that in haskell?
15:33:52 <Saizan_> recursion is also stressed as tearing down a structure, while corecursion builds it
15:34:25 <Saizan_> then it's common to combine both, like in map
15:34:27 <Saizan_> ?src map
15:34:28 <lambdabot> map _ []     = []
15:34:28 <lambdabot> map f (x:xs) = f x : map f xs
15:35:30 <zzzs> mmorrow, how do you use the vaccum-gl?
15:35:40 <Saizan_> fibs there in particular is "tying the knot", which is a particular pattern of corecursion
15:35:47 <ddarius> If someone is interested in getting "Programming in Haskell" by Graham Hutton, there's a promotion that seems to be available to all here giving 20% off: http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
15:35:49 <zzzs> can't seem to find gtk2hs either
15:35:56 <dcoutts> @where gtk2hs
15:35:56 <lambdabot> http://haskell.org/gtk2hs/
15:36:30 <zzzs> hmm, cabal install gtk2hs didn't find it
15:36:43 <dcoutts> it's not on hackage yet
15:38:51 <Berengal> ddarius, I love that series. Mostly because it's on channel 9
15:38:56 <jkramer> Is there a noun for being less than something? Like lessity? :)
15:39:16 <mauke> lessness
15:39:22 <jkramer> Really?
15:39:24 <mauke> no
15:39:27 <jkramer> :(
15:39:31 <Berengal> lessness isn't a noun
15:39:41 <Berengal> "less than" might count
15:39:42 <jkramer> I mean, there's equality
15:39:43 <lament> comparative scarcity?
15:39:58 <Berengal> jkramer, inferiority?
15:40:17 <jkramer> Hmm
15:40:42 <lament> smallificationism
15:40:44 <jkramer> Does this sound correct? The inferiority of 1 compared to 2
15:41:02 <Berengal> Sounds correct, but awkward
15:41:03 <ddarius> Berengal: It'll be interesting to see if the lectures change attitudes in, say, a year or so about FP.  In particular, the "difficulty" of learning it.  I haven't looked at any of the lectures yet.
15:41:30 <jkramer> Too bad that EQ, GT and LT are already used
15:43:09 <Berengal> ddarius, Erik Meijer is quite entertaining, and it's always fun to have the basics reiterated... there's something about the simplicity of the fundamentals of haskell (and FP) that intrigues me
15:43:13 <jfoutz> noun for less than? how would that work?
15:43:25 <Berengal> jkramer, those are acronyms. Expand them :P
15:43:54 <jkramer> data Comparator = Equal | Less | Greater | LessEqual | GreaterEqual | Like
15:44:57 <gOcOOl> isn't there a lazy bytestring version of the functions 'lines'?
15:45:02 <jfoutz> that's more of an adjective isn't it?
15:45:26 <gOcOOl> can;t find it in Data.ByteString.Lazy
15:45:30 <sproingie> ddarius: the regular price on amazon is 25% off
15:45:54 <jfoutz> hmm. least and most? least [1..10] -> 1?
15:45:55 <jkramer> jfoutz: Yup, but since there are no good nouns...
15:46:12 <jfoutz> the variable is the noun.
15:46:18 <Berengal> jkramer, too bad they don't take arguments, or you could use operators...
15:46:42 <jfoutz> embiggen
15:46:58 <jkramer> Berengal: You mean like haskelldb? :) ..===..:= etc? :)
15:47:00 <gOcOOl> anyone?
15:47:13 <Berengal> jkramer, indeed
15:47:21 <jfoutz> @hoogle lines
15:47:22 <lambdabot> Prelude lines :: String -> [String]
15:47:22 <lambdabot> Data.List lines :: String -> [String]
15:47:22 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
15:47:37 <jkramer> Maybe later
15:47:38 <jfoutz> hmm. looks like you're right gOcOOl.
15:49:09 <calsaverini> Hey.
15:49:19 <Axman6> 'lo calsaverini
15:49:28 <calsaverini> Hey Axman6
15:49:39 <Berengal> gOcOOl, when I think about it, there might not be a straightforward implementation of lines for LBS
15:49:51 <calsaverini> just a quick question, is there a module for Comonads?
15:49:58 <calsaverini> I couldn't find it
15:50:05 <jfoutz> calsaverini: in category-extras
15:50:11 <calsaverini> hummm
15:50:14 <calsaverini> thanks
15:51:02 <calsaverini> I just got addicted to a blog about haskell
15:51:20 <calsaverini> There's a code that uses a comonad to do a Cellular Automata
15:51:28 <Berengal> Oooo
15:51:28 <calsaverini> So nice!
15:51:33 <jfoutz> hehehe. sigfpe rocks
15:51:46 <calsaverini> jfoutz yeah! ahhahah
15:52:18 <calsaverini> What I think it's more incredible about that: I understood the code!!!
15:52:19 <calsaverini> hahahaha
15:52:20 <Berengal> sigfpe has a tendency to melt my brain...
15:53:10 <calsaverini> Most of the posts in the blog are beyond my skills
15:53:31 <calsaverini> but this one was just right for me
15:53:40 <zzzs> mmorrow, trying configure vacuum-gl, but had missing dependecies on GLUT and openGL, though i've installed them already
15:54:41 <monochrom> sigfpe also uses category theory to do spreadsheets. :)
15:54:56 <periodic> dons: Saw that reddit link about the category theory lectures at Stanford.  Looks like good stuff.  I happen to be in the area.
15:55:05 <jfoutz> jkramer: i think you're stuck. all the abstract nouns i can think of define a scale.
15:55:19 <monochrom> DrSyzygy's category theory lectures?
15:55:23 <jfoutz> size. scale. weight.
15:55:46 <Berengal> We need point-free constructors ;)
15:55:46 <kw317> periodic: would be nice if they had the videos
15:56:35 * kw317 is pissed off that category theory course at his uni coincides with some other course that he has to take
15:56:59 <calsaverini> oh, at least you HAVE a category theory course
15:57:00 <monochrom> There are not enough digital video cameras to shoot every course, every class, every tutorial.
15:57:15 <kw317> so instead listening about category, I'm learning about the internets
15:57:22 <burp> lol
15:57:26 <kw317> calsaverini: brand new one :-)
15:57:35 <monochrom> I wonder why you don't skip the internet classes.
15:57:47 <calsaverini> Try convincing brazilian condensed matter physicists that category theory is a good thing to teach to grad students
15:57:54 <jfoutz> kw317: catsters?
15:57:55 <kw317> monochrom: it's a behemoth that appears on all three papers that I'm going to take at the end of the year
15:58:01 <jfoutz> they're pretty good.
15:58:23 <monochrom> But I mean you can study internet stuff without attending classes.
15:58:25 <Peaker> Is there a way to compose graphs where the node types are an open sum, rather than a closed one?  Would   Map Key (forall a. SomeClass a => a)   be usable for this?
15:58:39 <kw317> monochrom: sort of.. lecture notes are pretty bad and lectures are pretty good
15:58:51 <kw317> monochrom: not going to lectures -> much more work and I've got plenty already
15:59:00 <monochrom> I see.
15:59:02 <kw317> oh, well, I'll do that stuff next year if I stay for masters
15:59:16 <kw317> in the meantime, the algebra of programming will do..
15:59:58 <monochrom> haha that rocks enough already
16:00:07 <Peaker> I'm trying out an idea of building a C-like DSL in Haskell (to compile to C), and I want to treat the C program as a graph, not an AST.  I might use a closed-type-sum for the C elements, but maybe I'd want an extensible type sum
16:00:46 <calsaverini> Have you got any good text in category theory that a physicist with a lousy math background would understand?
16:00:49 <Peaker> I also just had a (maybe wrong?) insight that the "Uniqueness monad" isn't really more useful than the Uniqueness Applicative. So I'm thinking of composing this graph using only the Applicative
16:01:39 <calsaverini> Something like ''Category Theory For Your Grandma''
16:01:50 <jfoutz> calsaverini: i've gotten way more out of these than any text. http://www.youtube.com/user/TheCatsters
16:02:06 <ddarius> Peaker: You could use an existential package like that for that purpose assuming you can provide a suitable interface.
16:02:22 <Peaker> ddarius, Its just a random thought, I'm pretty sure a closed type sum would work there..
16:02:49 <monochrom> category theory does not need a lot of math background. it just needs a lot of patience and suspense of disbelief.
16:02:58 <ddarius> Peaker: You can always use a closed sum if you know all the constructs ahead of time and/or have a "catch-all" generic representation case.
16:03:06 <jfoutz> calsaverini: and sadly, i haven't come across a nice category theory book.
16:03:09 <Peaker> Any reason that one would want to use join on the Uniqueness monad?  It seems to boil to: Do you really want to look at a unique ID to determine what next action to bind?
16:03:26 <ddarius> calsaverini: Awodey's text strikes me as good.  Barr and Well's lecture notes are also fairly good.
16:03:31 <Peaker> ddarius, yeah
16:03:37 <calsaverini> jfoutz Thanks!
16:03:39 <calsaverini> looks nice
16:03:51 <Peaker> And I think that if you use the uniqueness monad to generate names -- why would you care about the actual values of names?  Why would you ever need join for that?
16:04:26 <ddarius> Goguen's "Categorical Manifesto" is useful to refer to at various points while learning CT but is not a resource for learning CT.
16:04:49 <p_l> monochrom: why suspense of disbelief?
16:04:58 <calsaverini> ddarius I'll try them too
16:05:01 <calsaverini> thanks
16:05:20 <Berengal> Peaker, with join you get nice syntax...
16:05:41 <Peaker> Berengal, At the expense of composability
16:05:48 <calsaverini> Someone suggested me ''Categories for the Working Mathematician''. Is it a good source for a begginer?
16:05:52 <monochrom> Because it is very abstract. "oh you can do objects and morphisms". there can be long periods of "what is the point of all this?". you have to suspend that.
16:06:06 <ddarius> calsaverini: If you have a math background, perhaps.  Without one, not likely.
16:06:23 <Peaker> monochrom, does it stop feeling that way later? :)
16:06:28 <Berengal> Peaker, indeed. If we had a nice syntax for applicatives, we'd probably see more applicative-focused libraries
16:06:34 <ddarius> monochrom: Yes, that's an issue, but I wouldn't describe that as suspension of -disbelief-.
16:07:08 <monochrom> Yes. If you go with it, later you will know enough to apply.
16:07:13 <Berengal> suspension of blub
16:07:14 <ddarius> monochrom: Without a math background or a formal CS background, category theory doesn't seem to have many applications.
16:07:25 <mmorrow> zzzs: hmm odd, maybe you're looking in the local/global package database when GLUT/OpenGL are in the other?
16:08:09 <ddarius> calsaverini: While not formatted for it, "Categories for the Working Mathematician" is a decent reference once you know CT>
16:08:20 <calsaverini> ddarius hmmm, good to know.
16:08:53 <Peaker> Berengal, liftA* and <*> and SECs seem decent to me. I guess they take some getting used to
16:09:14 <jimi_hendrix> whats the haskell indent standard?
16:09:21 <periodic> kw317: hard to find good free videos of classes.  That Michi is putting his notes online is pretty nice as it is.  Also, the Mathematics building at Stanford is a bit old.  They'd probably have a little trouble putting in all the cameras.
16:09:25 <calsaverini> I know enough math to do physics, but I really skipped formal math and the sofisticated things.
16:09:33 <monochrom> 3.157 spaces is the haskell indent standard
16:10:14 <sproingie> i bought "Conceptual Mathematics: A First Introduction to Categories" which seems to be a pretty good intro
16:10:18 <calsaverini> The only more or less formal math I've studied was just a litle of group theory, enough to understand a specific thing I needed and that was it.
16:10:40 <Berengal> Peaker, the flip side is the fmapped function has to be @pl-ed, or you'll have to nest alot, with loads of extra operators and parens, or you'll have to write big lambdas
16:12:26 <Berengal> Peaker, I have some sugar in mind, but I'm not sure if it'd actually improve anything, and I'm not really a fan of sugar in the first place. The plan was to try to implement a simple proof-of-concept preprocessor this weekend, but now I'm wondering if I shouldn't just order pizza and watch zombie movies instead
16:15:08 <aavogt> > ceil 3.157
16:15:09 <lambdabot>   Not in scope: `ceil'
16:15:19 <jkramer> What would you prefer? A module that _may_ return invalid SQL when feeded with stupid data, or a module that excessively throws around with maybes
16:15:22 <jkramer> ?
16:15:56 <jfoutz> error out early
16:16:06 <Berengal> jkramer, phantom types?
16:16:13 <aavogt> jkramer: use Maybe if there is a way to sensibly recover
16:16:25 <calsaverini> I tried to use the Control.Comonad module and had a problem
16:16:53 <calsaverini> when I instanciate a comonad I must provide cojoin and coreturn, right?
16:17:12 <jkramer> aavogt: There is a way to recover, however it is clear for sure that the user made something wrong (however it might happen sometimes)
16:17:13 <jfoutz> the docs say which you need to implement
16:17:17 <benmachine> the way I see it, Maybe means "this might have failed", whereas error means "this shouldn't have failed"
16:17:18 <calsaverini> Or coreturn and =>>?
16:17:23 <jkramer> I could just `error` as well
16:17:24 <benmachine> the latter is fine for user error
16:17:31 <benmachine> er no
16:17:34 <benmachine> programmer error
16:17:36 <benmachine> I think
16:17:41 <benmachine> user error should be handleable
16:17:51 <benmachine> imo
16:18:07 <jfoutz> calsaverini: you have your choice. fmap, extract and duplicate, extract and extend or extend and duplicate
16:18:09 <Berengal> jkramer, can the error be checked statically?
16:18:17 <jfoutz> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad.html
16:18:24 <jimi_hendrix> whats the haskell indent standard?
16:18:27 <jfoutz> if that's the one you're using
16:18:42 <jkramer> As an example: I have a function that takes a value and a list of values and creates the SQL snippet "foo IN (bar, baz, quux)" from it. When the list of values is empty, the resulting "foo IN()" would make the db crash
16:18:42 <benmachine> someone running your program can be any idiot, but you're allowed to expect that whoever compiled it should know what they're doing
16:18:54 <benmachine> jimi_hendrix: apart from "no tabs ever" I don't think there is one
16:19:03 <jkramer> Should I return Nothing when the list is empty, or just error, or return the invalid SQL?
16:19:21 <calsaverini> hmmm, I guess I just mixed up the names of the functions then
16:19:23 <calsaverini> thanks
16:19:32 <benmachine> jkramer: the answer I think lies in why would the list be empty
16:19:40 <Berengal> jkramer, detect the empty list and insert false?
16:19:59 <jimi_hendrix> benmachine, so 4 spaces is alright?
16:20:04 <jimi_hendrix> (its what vim is set to for me)
16:20:14 <benmachine> jimi_hendrix: spaces are fine, yeah
16:20:19 <jkramer> benmachine: Because the user didn't check the input (which might happen if the in-list is generated from another data source)
16:20:21 <benmachine> but if you ask me you don't usually need as many as four
16:20:22 <Berengal> fixing SQL is allowed, as long as you don't make up surprises
16:20:34 <benmachine> usually I just line stuff up
16:20:35 <jkramer> Berengal: Hmm, that's an interesting solution :)
16:20:44 <Berengal> foo in () = false doesn't seem like a surprise to me
16:21:14 <benmachine> I tend to indent where and the line by a single space
16:21:19 <benmachine> usually that is all you need
16:21:40 <jfoutz> 4 spaces.
16:21:52 <Berengal> jimi_hendrix, as long as it's not tabs you're fine
16:21:57 <jkramer> I've got to check if there are more cases like this, the IN() was just an example
16:22:45 <jfoutz> jkramer: you're parsing sql?
16:22:57 <jkramer> jfoutz: Nah, building it :)
16:23:24 <jfoutz> why would you build broken sql? bad info about tables or something?
16:23:34 <jkramer> Ok, another thing: I have a function that combines multiple WHERE chunks (as a list) with AND - what should I do when the list is empty?
16:23:49 <Berengal> > and []
16:23:50 <lambdabot>   True
16:23:51 <jkramer> Just inserting FALSE here could turn the statement into something completely different
16:24:24 <Berengal> jkramer, just inserting TRUE wouldn't ;)
16:24:41 <Berengal> > 5 `elem` [] -- this too, by the way
16:24:42 <lambdabot>   False
16:24:42 <jkramer> jfoutz: Well that's just the question, should I build broken SQL if I get stupid input from the user or should I try to fix it or should I abort?
16:26:05 <jkramer> Berengal: What about OR? :)
16:26:06 <Berengal> jkramer, in order of importance to me, you should 1) be able to build every valid SQL, 2) not be able to build invalid SQL, 3) extra typechecking
16:26:11 <Berengal> > or []
16:26:12 <lambdabot>   False
16:26:16 <jfoutz> if you're only getting data from the user, like your sql interface dosn't let you introspect, you should build broken sql.
16:27:04 <jfoutz> if you know the query is bad, you should tell the user before trying to execute it. if you think you can fix it, you should prompt, did you mean X?
16:27:16 <Saizan_> jkramer: in order of niceness: 1) refactor the api so that you can't be given stupid input 2) check and give a proper error (like using Maybe or an exception monad if you're in a monad) 3) document the preconditions well
16:27:20 <jkramer> Berengal: I think I'll stick with the Maybes then, so people can recover
16:27:34 <rsnake> Hey... is there a way to enable unicode characters in ghci 6.8.2? (Latest version in aptitude)
16:27:47 <aavogt> rsnake: Char is unicode
16:27:47 <Berengal> jkramer, you could you a NotEmptyList type instead
16:28:00 <jfoutz> +1 for the unbreakable api
16:28:15 <Berengal> data NotEmpty a = a :- [a]
16:28:21 <Berengal> or something
16:28:27 <rsnake> But it shows up all weird on my terminal
16:28:33 <SubStack> > let  = 3 in 
16:28:34 <lambdabot>   3
16:28:35 <aavogt> but if you want to do unicode IO, you probably need utf8-string from hackage (maybe also available from apt-get)
16:28:56 <aavogt> its probably called libghc6-utf8-string or some such
16:29:03 <jkramer> Berengal: Is that syntax explained somewhere? :)
16:29:11 <Berengal> jkramer, I just made that up
16:29:12 <rsnake> wow, cool bot!
16:29:34 <SubStack> rsnake: also make sure your locale is set to use utf8
16:30:01 <Saizan_> you can have operator constructors as long as they start with ":"
16:38:28 <jkramer> Can I import a module in a module in a way so that the functions and types from the second module are visible in the module the imports the first module? :)
16:39:08 <jkramer> I mean, A imports B imports C, and I want the stuff from C in A
16:39:12 <Berengal> jkramer, module Foo (module Bar) where import Bar
16:43:59 <monochrom> B needs to re-export stuff from C.
16:47:00 <jimi_hendrix> and quick question, what does the $ do in haskell?
16:48:00 <monochrom> f$x is the same as f x. But $ has low precedence, convenient for f . g $ x+y
16:48:24 <jimi_hendrix> uhu
16:48:24 <jimi_hendrix> ok
16:50:22 <Raevel> f (g (h x)) = f $ g $ h x
16:51:45 <drhodes> I've got three typeclasses and am doing:  class (Validatable a, Formable a) => (CharField a) where ... } I get compiler error {`to_form' is not a (visible) method of class `CharField'} where `to_form` is a method of Formable.  I thought all the methods should be specifiable in the CharField instance, is this not the case?
16:52:17 <Saizan_> it isn't
16:52:35 <drhodes> ok thanks.
16:55:10 <mtnviewmark> hey ho - anyone else having trouble installing hlint?
16:55:24 <mtnviewmark> I'm on MacOSX, and with GHC 6.10.4
16:55:34 <mtnviewmark> and happy seems to be the thing that doesn't install
16:56:37 <mtnviewmark> cabal install happy proceeds along fair enough - but with 100s of warnings
16:56:39 <monochrom> Why do so many people have the money to buy macs but I don't?
16:57:05 <mtnviewmark> then - the executable for happy is in .cabal/bin --- but the rest of the package isn't
16:57:17 <mtnviewmark> and isn't registreed in ghc-pkg
16:57:35 <dcoutts> mtnviewmark: happy is just a program, so no lib registered with ghc-pkg
16:57:43 <mtnviewmark> AH - but THEN
16:57:52 <mtnviewmark> cabal install hlint
16:57:55 <mtnviewmark> fails because...
16:58:15 <Saizan_> add $HOME/.cabal/bin to your $PATH
16:58:18 <mtnviewmark> Configuring haskell-src-exts-1.1.4...
16:58:18 <mtnviewmark> setup: happy version >=1.17 is required but it could not be found.
16:59:05 <mtnviewmark> BINGO!
16:59:17 <mtnviewmark> thank you
16:59:21 <mtnviewmark> I was just symlinking
16:59:25 <mtnviewmark> sigh
16:59:45 <Saizan_> well, proper symlinks should work too
17:00:04 <mtnviewmark> well, I wasn't symlinking everything in .cabal/bin -- just cabal
17:00:41 <dcoutts> mtnviewmark: you can ask cabal to do the symlinking
17:01:03 <dcoutts> there's a setting in ~/.cabal/config
17:01:04 <mtnviewmark> right - the real issue was that I didn't want all that stuff in my path most of the time
17:01:11 <mtnviewmark> so - modifying path is the right thing for now
17:05:33 <jkramer> Berengal: http://dpaste.com/108365/
17:08:17 <jkramer> Berengal: Is that what you have thought of?
17:09:24 <Berengal> jkramer, it's a nice start. Eventually I'd like something a bit more abstract. A relational EDSL, of sorts
17:11:18 <jkramer> http://dpaste.com/108366/
17:12:21 <jkramer> Berengal: Yup, maybe something like Text.XHtml for SQL would be nice :)
17:13:23 <jkramer> But I'm good enough to fiddle with operators and monads yet
17:16:48 <aeron> i'll fiddle your monads
17:17:39 <dancor> as long as you obey the laws..
17:18:13 <dancor> this could be the start of something comonadic
17:18:24 <aavogt> there are enough illegal monads out there
17:18:30 <aavogt> logict, omega
17:18:43 <aeron> in linear algebra today my prof kept calling bases a fantastic tool
17:18:53 <dancor> sounds like he's one
17:18:53 <aeron> so of course
17:18:56 <aeron> comment from the back
17:19:01 <aeron> i'll show you my fantastic tool
17:19:06 <aeron> another comment from the side
17:19:12 <aeron> what's the dimension of your fantastic tool
17:19:28 <aeron> i hate state schools :(
17:19:32 <dancor> and by the end of lecture they had enough material for an undergrad thesis
17:21:09 <jfoutz> one great thing about state schools is you can take a math class or two in the summer, early. you maybe 2 other people, and a grad student... or the department head.
17:21:23 <aeron> truth
17:21:42 <jfoutz> i got a lot out of stats and linear algebra because of that.
17:21:52 <aeron> hopefully they offer abstract algebra this summer
17:22:34 <zzzs> mmorrow, with your http://hpaste.org/fastcgi/hpaste.fcgi/raw?id=10832, i'm getting memory.hs:50:0:
17:22:36 <zzzs>     Non type-variable argument in the constraint: MArray (STUArray s) a (ST s) (Use -XFlexibleContexts to permit this)
17:22:55 <zzzs> is that the non-standard way of declaring a constraint
17:22:58 <Saizan_> dancor: how is logict not legal?
17:23:26 * dancor pass to aavogt 
17:23:30 <Saizan_> zzzs: enable that extension, is fair
17:23:38 <Saizan_> dancor: oh, sorry
17:23:53 <dancor> i wish i knew, but instead, i noob
17:24:07 <zzzs> Also, is there a mutable array equalvent when the size can change
17:24:38 <aavogt> Saizan_: it isn't associative if you use the proper (==) instance for lists
17:25:02 <aavogt> but if you treat lists as sets, then it supposedly passes
17:25:17 <jfoutz> dosn't logict provide a cut?
17:25:31 <jfoutz> seems like that would bread associative as well.
17:25:37 <Saizan_> i thought that was the case for the >>-, not >>=
17:26:23 <Saizan_> jfoutz: it doesn't really have a cut, it has other less questionable operators
17:26:34 <jfoutz> ah.
17:27:36 <ddarius> Prolog would be a better language if they took a bunch of stuff out.
17:27:39 <jfoutz> haskell papers are strange. i read them and learn a bunch of stuff. then i go back six months later, read the same thing, and learn a bunch of new stuff. they are deep.
17:27:50 <lament> ddarius: what language wouldn't.
17:28:01 <jfoutz> lambda calculus!
17:28:16 <ddarius> lament: It's a matter of degree.
17:29:29 <dancor> ddarius: well it's a matter of if the degree is sufficient to justify forking
17:30:24 <ddarius> dancor: There are Prolog based languages that are better for having removed a bunch of the problems with Prolog (plus adding a bunch of other stuff) such as lambdaProlog, Lolli, LolliMon, Olli.
17:30:33 <dancor> mm
17:30:50 <ddarius> Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
17:31:18 <dancor> well if they are small then maybe forkings are harder to justify
17:31:21 <Adamant> what about Mercury?
17:31:53 <jkramer> http://dpaste.com/108372/
17:32:47 <ddarius> Adamant: Mercury is a functional logic language.
17:33:07 <Adamant> ddarius: but, it's a logic language :P
17:33:15 <Adamant> another alternative to Prolog
17:36:27 <lpjhjdh> is there a simpler way of doing subtyping over unions than something like the following: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10833#a10833
17:36:46 <lpjhjdh> I can't seem to say things like: instance Subtyp f f Tru
17:38:07 <mmorrow> zzzs: if you need to start doing ptr-cast-like things, it might be best to just use {peek|poke}[Elem][Off], {malloc|alloca}Bytes, copyBytes, moveBytes, etc in Foreign
17:38:24 <mmorrow> (and castPtr too, of course :)
17:39:46 <mmorrow> @remember ddarius Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
17:39:46 <lambdabot> Done.
17:43:47 <dancor> why are ppl allowed to put broken packages on hackage
17:43:59 <dancor> http://hackage.haskell.org/package/HDBC Build failure
17:44:07 <dancor> and cabal-install pulls it and everything
17:46:22 <dancor> it's like electric sheep but where the computers are sharing build failure nightmares
17:50:47 <jkramer> Wh00t
17:50:48 <jkramer> http://dpaste.com/108377/
17:55:17 <aavogt> > Just 1 `mappend` Just 2
17:55:18 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:55:19 <lambdabot>    `GHC.Num.Num t' arising ...
17:55:25 <aavogt> > Just 1 `mappend` Just (2::Int)
17:55:26 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
17:55:26 <lambdabot>    arising from a use of...
17:55:34 <aavogt> > Just 1 `mplus` Just (2::Int)
17:55:35 <lambdabot>   Just 1
17:56:07 <McManiaC> how can i check if a string is read-able?
17:56:18 <Saizan_> dancor: not always the build failure is indicative
17:56:25 <aavogt> McManiaC: reads
17:56:58 <aavogt> @hoogle Read a => String -> Maybe a
17:56:59 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
17:56:59 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
17:56:59 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
17:57:14 <McManiaC> ah :)
17:57:26 <McManiaC> network.cgi ? o.O
17:57:48 <aavogt> there's something in applicative-extras
17:58:13 <aavogt> with the same signature
17:59:02 <jkramer> Berengal: http://github.com/jkramer/database-abstract/
17:59:14 <jkramer> Far from finished, but it seems to work :)
17:59:15 <Saizan_> dancor: in this case it is though :) but i bet you can use --constraint="convertible == 1.0.5" to get it installed
17:59:48 <idnar> The rights you have are the rights given you by this Committee [the
17:59:48 <idnar> House Un-American Activities Committee].  We will determine what rights
17:59:48 <idnar> you have and what rights you have not got.
17:59:48 <idnar>                 -- J. Parnell Thomas
17:59:52 <idnar> er, wrong window
17:59:57 <idnar> :/
18:00:29 <jkramer> :D
18:00:52 <jimi_hendrix> and last question, how do you grab a random int
18:00:59 <Saizan_> dancor: it'd be nice to be able to check these errors in the stated dependencies, though it's not so easy, there's been an idea floating aroud about how to write the required tool, probably using the ghc-api
18:01:39 <Saizan_> ?type randomIO
18:01:40 <lambdabot> forall a. (Random a) => IO a
18:01:48 <Saizan_> jimi_hendrix: you can use that from IO
18:01:54 <Saizan_> ?type random
18:01:55 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
18:02:00 <McManiaC> is hayoo down?
18:02:06 <jimi_hendrix> ok?
18:02:23 <Saizan_> or that one in pure code, if you get the generator as an argument
18:02:32 <Saizan_> see the System.Random module
18:05:04 <jimi_hendrix> uhh can i get the "generate a random number for haskell noobs" guide
18:06:36 <jkramer> McManiaC: Yup, has been for a while
18:06:47 <McManiaC> :(
18:06:47 <McManiaC> ok
18:06:56 <jkramer> Use hoogle instead :)
18:08:00 <McManiaC> does it cover hackage??
18:08:34 <jkramer> I think so, otherwise I'd wonder where it gets the function signatures from
18:09:57 <McManiaC> from base?!
18:10:43 * copumpkin moos softly
18:10:50 <jimi_hendrix> what am i doing wrong here: http://pastebin.com/d1da438de
18:10:55 <Saizan_> jimi_hendrix: an example "import System.Random; main = do g <- newStdGen; let (i::Int,newg) = random g; print i"
18:11:17 <Saizan_> jimi_hendrix: you need to give a type annotation to r
18:11:49 <Saizan_> jimi_hendrix: because otherwise it doesn't know if you want an Int or a Double or any other instance of Random
18:11:50 <jimi_hendrix> ok
18:12:18 <jimi_hendrix> so what do i fix the statement to
18:12:40 <Saizan_> http://pastebin.com/m756c5049
18:12:56 <Saizan_> :: means "has type"
18:13:47 <jkramer> It's like casting in other languages :)
18:14:00 <Saizan_> it's quite different
18:14:08 <Saizan_> it doesn't involve a coercion
18:14:19 <jkramer> Except it works only for things that don't have a certain type yet (I guess)
18:14:26 <Saizan_> you can only give a more specific type to a polymorphic value
18:14:35 <aavogt> it's like writing  (int i)
18:14:47 <aavogt> but you can put it anywhere
18:15:47 <aavogt> or that is casting in other languages when the types wouldn't match up?
18:17:19 <jkramer> Usually (at least I know it that way from Java), you cast more generic things to more specific things to get more specific functionalty
18:18:07 <jkramer> But in other languages like c, you can practacially cast anything to anything cause in the end it's all numbers :)
18:19:02 <Saizan_> right, but if you e.g. cast a float to an int you don't just reinterpret the bits, it inserts a conversion automatically
18:19:07 <jkramer> However, the result may be funny
18:20:12 <Saizan_> in haskell you could embed that in the math operators by changing Num to a multi params type class
18:20:41 <Saizan_> but as it is you use e.g.  round  explictly
18:21:15 <jimi_hendrix> and the last statement's value is returned right
18:21:56 <Saizan_> in a do-block? yeah
18:22:18 <Saizan_> though the return value of print is not interesting, being ()
18:22:29 <jimi_hendrix> ok, and the last question, how do i get user input
18:22:54 <jkramer> Good news everyone
18:22:55 <Saizan_> getLine is the simplest
18:23:04 <jimi_hendrix> and to get it as an int?
18:23:14 <jkramer> I'm happy to announce that it is 3:21am and I'm eating fries with mayo and ketchup
18:23:41 * jimi_hendrix takes them
18:23:52 <jkramer> (for those who are not subscribed to the newsletter)
18:23:53 <Saizan_> there's readLn which will abort the program if the input doesn't parse correctly
18:23:58 <aavogt> @localtime jkramer
18:24:01 <lambdabot> Local time for jkramer is Sat Oct 17 03:23:59 2009
18:24:20 <Saizan_> jkramer: we're in the same timezone!
18:24:25 <jkramer> \o/
18:24:26 <jimi_hendrix> can i cast strings as ints?
18:24:46 <Saizan_> jimi_hendrix: you can use "read" for that
18:24:48 <aavogt> > read "1234" :: Int
18:24:49 <lambdabot>   1234
18:24:57 <Saizan_> > read "foo" :: Int
18:24:58 <lambdabot>   * Exception: Prelude.read: no parse
18:25:02 <aavogt> > read "0x1234" :: Int
18:25:03 <lambdabot>   4660
18:25:07 <jimi_hendrix> ok
18:25:12 <jkramer> Saizan_: If you think you're getting fries now just because of timezone relationship ... fail!
18:25:37 <jimi_hendrix> can i do getLine :: Int
18:25:53 <Saizan_> > let readMaybe str = case reads str of [(x,"")] -> Just x; _ -> Nothing in readMaybe "foo" :: Maybe Int
18:25:54 <lambdabot>   Nothing
18:26:09 <Saizan_> jimi_hendrix: you can do "readLn :: IO Int"
18:26:41 <aavogt> @type readLn
18:26:42 <lambdabot> forall a. (Read a) => IO a
18:26:56 <Saizan_> jkramer: nah, i've eated too much today already :P
18:27:12 <jkramer> > "Fries time! Omm " ++ replicate 100 "nom "
18:27:13 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
18:27:13 <lambdabot>         against inferred type...
18:27:13 <Saizan_> well, yesterday.
18:27:19 <jkramer> Eh
18:27:22 <jkramer> Oh
18:27:30 <jkramer> > "Fries time! Omm " ++ (concat $ replicate 100 "nom ")
18:27:31 <lambdabot>   "Fries time! Omm nom nom nom nom nom nom nom nom nom nom nom nom nom nom no...
18:27:57 <jkramer> \o/
18:27:59 <aavogt> > cycle "omnom"
18:27:59 <lambdabot>   "omnomomnomomnomomnomomnomomnomomnomomnomomnomomnomomnomomnomomnomomnomomno...
18:28:13 <aavogt> > cycle "om n"
18:28:14 <lambdabot>   "om nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom...
18:28:51 <hackagebot> bindings-gsl 0.0.2 - Low level bindings to GNU GSL. (MauricioAntunes)
18:29:20 <aavogt> but there's hmatrix already?
18:30:19 <jkramer> http://www.youtube.com/watch?v=5_GqkmvptQg
18:32:13 <Saizan_> ehm, let's keep these kind of things to #haskell-blah :)
18:32:31 <jkramer> There's a haskell-blah-Channel? :)
18:32:39 <Saizan_> yes :)
18:32:47 <lispy> jkramer: yeah, and everyone is welcome to be off-topic tehre :)
18:32:57 <Nafai> talking about Haskell is off-topic there :)
18:33:12 <jkramer> And I thought _this_ channel was funny :)
18:33:15 <gwern> @quote topic
18:33:15 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
18:33:32 <gwern> @quote topic
18:33:32 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
18:33:42 <gwern> progress, then
18:33:49 <gwern> @quote offtopic
18:33:49 <lambdabot> gwern says: #haskell: because none of us are as offtopic as all of us
18:34:20 <aavogt> @quote troll
18:34:20 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
18:37:22 <dmwit> Say my name, say my name...
18:37:52 <copumpkin> dmwit
18:38:16 <dmwit> Hi! 
18:38:34 <copumpkin> oh my, dmwit turned into a
18:38:36 <copumpkin> dunno :)
18:44:06 <jfredett> ... weirdness, all of the unicode characters I see are cut in half... :/
18:44:14 <jimi_hendrix> and probably last n00b question for the night, how would i put multiple statements in an if/else
18:44:35 <jimi_hendrix> so if (...) { foo(); bar(): } else { bar(); baz(); } in C
18:44:37 <Saizan_> jimi_hendrix: you've to put another do inside the then and else branches
18:44:46 <lispy> jfredett: save you some storage then?
18:44:51 <lispy> jfredett: it's a new compression
18:44:54 <jfredett> lispy: apparently.
18:45:03 <lispy> jfredett: lossy, but eh, what are you gonna do?
18:45:03 <Saizan_> jimi_hendrix: if (...) then do foo; bar else do bar; baz
18:45:15 <jimi_hendrix> ok
18:46:12 <lpjhjdh> how do I tell ghc to use a precompiled file that isn't registered?
18:46:23 <lpjhjdh> can I have it pull in a .o file?
18:46:46 <copumpkin> just to link to it?
18:46:51 <lpjhjdh> or maybe .hi
18:46:53 <copumpkin> just put it on the command line
18:48:13 <lpjhjdh> can I tell ghci to do that too?  It says it can't find the module
18:49:42 <Saizan_> i think it's a problem of source paths
18:50:36 <jimi_hendrix> ok, last last one: why does this error     if (getLine :: IO Int) == (num) then True else False; --says cant match Int against inferred type [Char]
18:51:25 <Cale> jimi_hendrix: That's surprising, I would expect a different type error
18:51:41 <Cale> jimi_hendrix: You can't compare IO actions with other IO actions, and certainly not with numbers
18:51:41 <lpjhjdh> hmm, I'm trying to do the TypeCast thing from HList for type equality and it needs to be pre-compiled to avoid inlining
18:51:42 <jimi_hendrix> xD
18:51:56 <jimi_hendrix> so what should i do
18:52:07 <Cale> jimi_hendrix: Are you trying to tell if num will do the same thing as getLine when you run it?
18:52:22 <jimi_hendrix> i am trying to match a number that was inputed with num
18:52:32 <Cale> jimi_hendrix: So perhaps what you really want to do is to run getLine first
18:52:44 <jimi_hendrix> ok
18:53:30 <Cale> jimi_hendrix: You don't want to compare getLine with the number, you want to run it, and then compare the string you read with the show of the number
18:53:39 <jimi_hendrix> ok
18:53:44 <Cale> (or parse the string using read and then compare the numbers
18:53:44 <Saizan_> lpjhjdh: i think there was a version without any of those problems? however afaiu it's not a problem of inlining of code, but rather of typeclass constraints at typechecking time
18:53:48 <Cale> So you need a line like
18:53:52 <Cale> xs <- getLine
18:54:00 <Cale> which means to run getLine and call its result xs
18:54:08 <Cale> (which'll be a String)
18:54:14 <Saizan_> lpjhjdh: also, now you can just use "a ~ b" from TypeFamilies, afaiu
18:54:20 <jimi_hendrix> so input <- getLine; if input == num ...
18:54:29 <jimi_hendrix> oh didnt see your answer
18:54:30 <jimi_hendrix> ok
18:54:34 <Cale> jimi_hendrix: If num is a string, then yeah
18:54:35 <lpjhjdh> oh, how do I use ~?
18:54:39 <lpjhjdh> just like a constraint?
18:54:49 <lpjhjdh> a ~ b => F a b
18:54:57 <Saizan_> lpjhjdh: yes
18:55:05 <lpjhjdh> Saizan_: thanks
18:56:09 <jimi_hendrix> Cale, then i convert the string to a number how?
18:56:42 <jfoutz> > read "123" ::Int
18:56:43 <lambdabot>   123
18:56:59 <jimi_hendrix> oh ok
18:57:01 <jimi_hendrix> i am good now :)
18:57:06 <jfoutz> :)
19:00:29 <jimi_hendrix> haskell is confusing but feels good at the same time
19:01:41 <jimi_hendrix> bah ok a few more questions, but i am getting it...why do i keep getting indent errors when i try if foo == bar then \n ... \n else \n ...
19:02:01 <ksf> haskell is confusing in the way pi is confusing if you don't believe in irrational numbers.
19:02:10 <jfoutz> i think the if then and else all need to line up
19:02:13 <jfoutz> if
19:02:14 <jfoutz> thes
19:02:15 <jfoutz> else
19:02:18 <ksf> you've got to indent the then and else
19:02:24 <Cale> if foo
19:02:24 <jfoutz> oh, or that.
19:02:26 <Cale>    then bar
19:02:28 <Cale>    else quux
19:02:30 <ksf> ...they cannot line up, as they're one expression.
19:02:48 <lpjhjdh> Saizan_: I have a dim understanding of this, I'm getting a dependency conflict with: class TypeEq x y b | x y -> b, instance x ~ y => TypeEq x y Tru, instance TypeEq x y Fls
19:02:52 <ksf> that's a syntax wart that's most likely going to be fixed in h'.
19:02:54 <jimi_hendrix> ok
19:03:06 <Cale> The 'then' and 'else' are siblings, so they should line up with each other, and they are part of the 'else' so they should be indented further
19:03:23 <Cale> I think Haskell' ought to adopt a more restrictive rule for how if/then/else is indented
19:03:34 <Cale> But they seem to be making it more relaxed.
19:03:53 * ksf doesn't use ifthenelse with do-notation, anyway.
19:04:00 <Cale> We really should force the then and else to line up nicely ;)
19:04:18 <jimi_hendrix> do i indent the stuff after the else on new lines?
19:04:20 <ksf> I'm using ifM c a p -> if p then a else c
19:04:46 <ksf> if you want to have multiple statements after then/else, you have to open a new do block.
19:05:01 <ksf> s/->/=
19:05:25 <jimi_hendrix> ksandstr, i did
19:05:33 <jimi_hendrix> if ... then do ... else do ...
19:06:11 <ksf> the first non-whitespace character after the do is the one the other statements have to align with
19:06:14 <ksf> so it's
19:06:18 <ksf> then do foo
19:06:22 <ksf>            bar
19:06:25 <Cale> oops ;)
19:06:28 <ksf> (imagine that lining up)
19:06:30 <ksf> or
19:06:32 <ksf> then do
19:06:34 <ksf>    foo
19:06:36 <ksf>     bar
19:06:40 <ksf> (that, too)
19:06:46 <Cale> >_<;
19:06:52 * araujo wonders if some haskell'er is already google waving
19:07:09 <araujo> if so, priv msg me your id, and i can add you :P
19:07:28 <jimi_hendrix> ok
19:07:34 <Cale> then do foo
19:07:37 <Cale>         bar
19:07:42 <jimi_hendrix> ok
19:07:43 <jimi_hendrix> makes sense
19:07:46 <Cale> yeah
19:07:48 <jimi_hendrix> now last question maybe
19:07:53 <jimi_hendrix> Couldn't match expected type `IO b' against inferred type `Bool'
19:07:57 <Cale> the 'foo' and 'bar' are both lines inside the 'do' so they have to line up
19:08:19 <Cale> jimi_hendrix: You're comparing an action with a different sort of value again
19:08:36 <jimi_hendrix> uhh
19:08:41 <jimi_hendrix> i am just trying to return True :)
19:08:51 <Cale> What did you write?
19:08:59 <ksf> an IO Bool is a thing that, when run, gives you a Bool.
19:09:02 <ksf> @hpaste
19:09:03 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:09:15 <Cale> Oh, I suppose you might have written  True  where you wanted  return True
19:09:24 <ksf> :t return
19:09:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:09:33 <ksf> :t return :: a -> IO a
19:09:34 <lambdabot> forall a. a -> IO a
19:09:45 <jimi_hendrix> oh return isnt a keyword?
19:09:52 <Cale> Nope, just a normal function
19:09:58 * ksf still thinks that return is by far the biggest misnomer in all of haskell
19:10:10 <Cale> It turns a value into an action which does nothing but return that value as its result.
19:10:19 <ksf> "make it easy for newbies" turns into "confuse the hell out of them"
19:10:29 <jimi_hendrix> bah, how do i know if something is an IO bool/whatever
19:10:42 <ksf> :t getLine
19:10:43 <lambdabot> IO String
19:10:46 <ksf> that's an IO
19:10:50 <ksf> :t "foo"
19:10:50 <lambdabot> [Char]
19:10:53 <Cale> ksf: I think it's not really a misnomer at all
19:10:53 <ksf> that's a String
19:10:58 <lispy> jimi_hendrix: asking the compiler is an acceptable answer :)
19:11:02 <ksf> it should've been called pure.
19:11:09 <jimi_hendrix> well when the compiler complains
19:11:12 <Cale> 'return' is a very descriptive and suggestive name which is quite compatible with the thing's use
19:11:23 <ray> it should've been called rereturner
19:11:28 <ksf> > return 1 :: [Int]
19:11:29 <lambdabot>   [1]
19:11:44 <lispy> jimi_hendrix: haskell programmers tend to internalize the type checking process.
19:11:54 <jimi_hendrix> ?
19:11:55 <ksf> that doesn't line up with any meaning of return in any other language.
19:12:13 <jimi_hendrix> this is so radically different from C it is fun xD
19:12:15 <Cale> If you're going to advocate 'pure', then perhaps I should argue that it ought to be called 'eta', since that's what it's called in mathematics
19:12:18 <lispy> jimi_hendrix: eventually, you'll be able to intuitively know the type of something or else figure it out quickly.  Just be patient with yourself
19:12:20 <ksf> sometimes I'm importing Control.Applicative just to use pure.
19:12:30 <Cale> Or 
19:12:34 <Cale> ;)
19:12:34 <ksf> point.
19:12:46 <Cale> That would look so badass ;)
19:12:46 <lispy> :t pure
19:12:47 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
19:12:57 <ksf> :t pure :: a -> IO a
19:12:58 <lambdabot> forall a. a -> IO a
19:13:05 <Athas> Yay, Unicode.
19:13:22 <Orclev> if you had to program haskell using obscure unicode characters I probably wouldn't bother
19:13:30 * ksf does
19:13:31 <ddarius>   fmap f
19:13:33 <Cale> @let  :: Monad m => a -> m a;  = return
19:13:33 <lambdabot>  Defined.
19:13:51 <Cale> @let  :: Monad m => m (m a) -> m a;  = join
19:13:51 <lambdabot>  Defined.
19:13:53 <ksf> let (.) = fmap in toUpper . "foo"
19:13:57 <ksf> > let (.) = fmap in toUpper . "foo"
19:13:58 <ddarius>  isn't obscure
19:13:58 <lambdabot>   "FOO"
19:14:09 <ksf> that's proper usage of obscure characters.
19:14:20 <Cale> :t 
19:14:21 <lambdabot> parse error on input `??'
19:14:23 <Cale> awwww
19:14:24 <Orclev> it's not on my keyboard, so I've got no idea how I'd enter it
19:14:35 <ksf> :t ()
19:14:36 <lambdabot> Not in scope: `??'
19:14:38 <djahandarie> > let  = "domo"
19:14:39 <lambdabot>   not an expression: `let  = "domo"'
19:14:39 <lispy> ddarius: well, it's not on my US qwerty keyboard so it must be part of an alien language ;)
19:15:08 <copumpkin> it's a long do
19:15:10 <Cale> Orclev: There are a few good ways. You can set up a Greek keyboard layout with a key to switch between layouts, or there are things like SCIM which has a TeX mode that'll let you type  as \eta
19:15:27 <lispy> > let  = "domo" in ++ "arigato"
19:15:28 <lambdabot>   "domoarigato"
19:15:28 * ddarius uses SCIM's LaTeX mode.
19:15:54 <copumpkin> it's still a long o
19:16:03 <copumpkin> or an ou if you prefer
19:16:05 <ksf> Cale would call Either a b "a `` b"
19:16:10 <Cale> It should be  unless you mean the humble pronoun...
19:16:17 <ddarius> a+b
19:16:18 <djahandarie> > cycle D:
19:16:19 <lambdabot>   <no location info>: lexical error at character '\8221'
19:16:24 <djahandarie> lol
19:16:26 <ksf> I tend to think that's hilarious.
19:16:32 <Orclev> hmm... I wonder what magic incantation I need to use to configure SCIM in gentoo.... off to pester eix
19:16:41 <Cale> a  b
19:16:49 <djahandarie> 
19:17:04 <djahandarie> I tend to forget about those little line things
19:17:05 <djahandarie> :P
19:17:22 <Cale> This is why you must get away from romaji as quickly as possible ;)
19:17:24 * lispy thinks it's time to head home
19:17:38 * ksf remembers being stuck with the agda stdlib because he typed an ascii character where the lib used unicode
19:17:57 <djahandarie> Cale, I've tried memorizing kana for ages now, can't do it. >_> Anyways this is a tangent
19:18:20 <ksf> memorizing characters doesn't work.
19:18:26 <Cale> I guess that I'm lucky in that I learned kana when I was 5 (and no other Japanese until more recently)
19:18:27 <ksf> you've got to read.
19:18:37 <ksf> ...at least that's my experience with cyrillic.
19:18:50 <djahandarie> How do I do that without knowing what it is? D:
19:18:52 <Draconx> there aren't a lot of kana characters -- rote memorization can work.
19:19:09 <ksf> djahandarie, looking each and every kana up as you read it.
19:19:12 <Orclev> wait, what's wrong with romaji?
19:19:28 <copumpkin> Orclev: not as cool
19:19:35 <Orclev> copumpkin: lol
19:19:37 <Cale> Orclev: It has lots of problems. Many of the systems do stupid things with long vowels.
19:19:38 <ksf> ...your brain quickly figures out that it's more convinient to remember them.
19:20:05 <djahandarie> So I don't make stupid mistakes like domo instead of doumo
19:20:22 <jimi_hendrix> ok, last one, is there anyway to do a guard in a function when it isnt the only part of the function
19:20:27 <Cale> Orclev: and there are issues like the confusion between ni =  and ni =  (mostly in compound words or names)
19:20:35 * ksf opts for tengwar
19:20:46 <Orclev> I tend to have issues with the long vowels anyway... I always feel like I'm an idiot trying to pronounce them
19:20:57 <djahandarie> Even though I know  is different from  
19:21:19 <djahandarie> Ooops
19:21:20 <djahandarie> ru
19:21:21 <djahandarie> Dman
19:21:23 <djahandarie> >.<
19:21:24 <ksf> jimi_hendrix, case expressions
19:21:34 * djahandarie resigns
19:22:06 <Orclev> gah, it's been so long since I practiced the kana I've forgotten most of them
19:22:06 <jimi_hendrix> ok
19:22:16 * jimi_hendrix thought guards were cases in haskell
19:22:16 <Cale> Is ji =  or ? Some systems of romaji conflate them.
19:22:19 * jimi_hendrix goes back to tutorial
19:22:55 <jimi_hendrix> haha
19:22:59 <jimi_hendrix> its the next expression
19:23:07 <jimi_hendrix> s/expression/part/
19:25:04 <djahandarie> I still don't even have my multiplication tables memorized
19:25:11 <djahandarie> Tried for ages with that also
19:25:53 <jimi_hendrix> lol?
19:26:14 <djahandarie> I'm seriously really bad at that sort of stuff
19:26:22 * ksf forgot them in the summer holidays between 2nd and 3rd grade
19:27:08 <djahandarie> I'm not bad at actual math, or understanding Japanese... but my arithmetic and Japanese reading are terrrrible
19:27:33 <p_l> hmm... 
19:27:34 <djahandarie> At least I can speak English.
19:27:35 <Cale> Or to put it another way, 
19:27:35 * ddarius didn't think multiplication wasn't math...
19:28:10 <p_l> I guess  is the more common, it's just that  sounds similar and english doesn't have different spelling for it
19:28:37 <djahandarie> Cale, you lost me.
19:29:09 <Cale> "Writing Japanese in roma-ji is kind of like learning English in katakana."
19:29:40 <djahandarie> Bawhahaha
19:29:42 <djahandarie> I see it now
19:29:42 <djahandarie> :P
19:29:44 <ksf> english orthography is a complete and utter mess.
19:29:50 <joevandyk> if i have an infinite list, how can i get the all elements in it that satisfy a certain condition?
19:30:06 <dmwit> :t filter
19:30:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:30:08 <bd_> > filter odd [1..]
19:30:09 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
19:30:37 <jimi_hendrix> in a where at the end of a guard, can i define another mini function?
19:30:38 <joevandyk> lambdabot: what if the result should be finite?
19:30:44 <jimi_hendrix> like where foo = do ...
19:30:49 <ksf> > filter (< 10) [0..]
19:30:52 <Cale> jimi_hendrix: Yes
19:30:53 <lambdabot>   mueval-core: Time limit exceeded
19:30:55 <joevandyk> say, all odd numbers that are less than 100 -- does that work as well?
19:30:55 <ksf> > filter (< 1000) [0..]
19:30:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:31:02 <Cale> jimi_hendrix: and the 'where' scopes over all the guards
19:31:06 <ksf> ...see, pay attention with those filters.
19:31:11 <dmwit> > takeWhile (<100) . filter odd $ [1..]
19:31:12 <jimi_hendrix> ok, i have a parse error on where foo = ...
19:31:12 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
19:31:17 <Cale> jimi_hendrix: So you can use the things you define in all the preceding guards
19:31:22 <ksf> you can easily insert a bottom at the "end"
19:31:23 <dmwit> > last . takeWhile (<100) . filter odd $ [1..]
19:31:25 <lambdabot>   99
19:31:40 <Cale> jimi_hendrix: Maybe the problem is with the line before it?
19:31:53 <dmwit> joevandyk: Naturally, you have to have some way to know when the list is "finished".  Other than that, the answer is of course yes.
19:32:01 <ksf> jimi_hendrix, hpaste.org
19:32:56 <ksf> pasting your code has the additional benefit that we're going to reduce your code to a line of funny symbols, for free.
19:33:18 <ddarius> ksf: We're going to translate it to APL?
19:33:29 <ksf> @pl apl
19:33:29 <lambdabot> apl
19:33:34 <ksf> nope that seems to be id.
19:33:41 <p_l> Cale: nice english in katakana xD
19:33:46 <jimi_hendrix> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10834#a10834
19:33:55 <jimi_hendrix> ksf, lol
19:34:12 <dmwit> jimi_hendrix: where foo = getLine -- ;-)
19:34:17 <ddarius> ksf: id is a different language.
19:34:24 <ksf> foo has to be indented less than input and return.
19:34:28 <dmwit> jimi_hendrix: But more seriously, you have to indent the "do" block more than the "where" block.
19:34:40 <ksf> ...both where and do introduce layout blocks
19:35:12 <ksf> ...you could just write foo = getLine, btw.
19:35:20 <dmwit> too slow, ksf
19:35:36 <ksf> foo >>= (\bar -> return bar) == foo
19:36:06 <jimi_hendrix> ok
19:36:35 <ksf> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10834#a10835
19:36:42 <ksf> it usually looks like that
19:38:07 <ksf> annotating expressions with types is used rarely, too, usually you'd write "foo :: IO Int"
19:38:22 <jimi_hendrix> ok i still have that parse error
19:38:27 <dmwit> Or just skip the binding for foo and use getLine.
19:38:37 <dmwit> jimi_hendrix: Better paste a bit more of your file, then...
19:38:40 <ksf> oh. and that won't typecheck, btw.
19:38:40 <jimi_hendrix> ok
19:38:58 <dmwit> :t readLn
19:38:59 <lambdabot> forall a. (Read a) => IO a
19:39:01 <dmwit> :t getLine
19:39:02 <lambdabot> IO String
19:39:19 <ksf> "readLn" always reminds me of pascal.
19:39:26 <jimi_hendrix> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10834#a10836
19:39:42 <jimi_hendrix> pascal sounds like haskell
19:39:43 <dmwit> s/;/>>/
19:39:55 <jimi_hendrix> btw, is it haskell with an emphasis on the ell or on the hask
19:40:02 <Cale> They actually sound quite different.
19:40:03 <joevandyk> what's the method for removing all duplicate items from a list?
19:40:05 <ddarius> jimi_hendrix: Yes.
19:40:05 <ksf> print "Too Low" >> game num
19:40:07 <jimi_hendrix> because if its on the hask then i have been saying it wrong
19:40:12 <joevandyk> and how would i look that method up on my own?
19:40:13 <Cale> "Haskell" rhymes with "rascal"
19:40:15 <dmwit> If you emphasize the "hask", people don't get it confused with Pascal.
19:40:15 <ksf> ";" doesn't mean what you think it does.
19:40:32 <Cale> It's a bit like "haskl"
19:40:40 <ddarius> ; doesn't actually mean anything...
19:40:47 <ksf> ; is only used as a line separator in {;} syntax.
19:40:55 <jimi_hendrix> then what does >> mean
19:41:01 <dmwit> jimi_hendrix: Also, you need to bind guess.
19:41:13 <dmwit> You have to "execute" guess.
19:41:16 <ksf> like do { print "foo"; game num } which is the same as the same thing written in layout
19:41:19 <ksf> :t >>
19:41:20 <lambdabot> parse error on input `>>'
19:41:21 <Orclev> hmm... is (;) legal (if very very wrong)?
19:41:26 <ksf> :t (>>)
19:41:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:41:38 <dmwit> Orclev: Inside {}, yes.
19:41:44 <ksf> take two monadic actions and combine them.
19:41:45 <dmwit> hm
19:41:48 <ksf> @src (>>)
19:41:48 <lambdabot> m >> k      = m >>= \_ -> k
19:41:49 <dmwit> Maybe outside {}, too.
19:41:52 <jimi_hendrix> so what does >> do?
19:41:54 <dmwit> > let x = 3; y = 5 in x
19:41:55 <lambdabot>   3
19:41:56 <idnar> @type (;)
19:41:57 <lambdabot> parse error on input `;'
19:42:04 <idnar> @type {(;)}
19:42:05 <lambdabot> parse error on input `{'
19:42:09 <dmwit> > do [3,4]; [5,6]
19:42:10 <lambdabot>   [5,6,5,6]
19:42:12 <dmwit> neat
19:42:12 <idnar> @type do {(;)}
19:42:13 <lambdabot> parse error on input `;'
19:42:17 <ksf> jimi_hendrix, it runs the first action, discards its result, and then runs the second one.
19:42:21 <jimi_hendrix> ok
19:42:26 <jimi_hendrix> and then how do i execute guess
19:42:29 <Orclev> > let (;) a b =  a ++ "foo" ++ b in "bar" ; "baz"
19:42:30 <lambdabot>   <no location info>: parse error on input `;'
19:42:35 <ksf> (that's the non-confusing but incorrect explanation)
19:42:51 <ksf> the truth is that they're combined and the result of foo >> bar is a new action.
19:43:04 <dmwit> jimi_hendrix: do { guessedValue <- guess; {- use guessedValue here -} }
19:43:08 <jimi_hendrix> this is seeming more and more like perl in that there are non-confusing answers but they dont tell you everything
19:43:10 <ksf> ...that you have to run to have those two get executed.
19:43:24 <dmwit> ?go io monad for people who just don't care
19:43:24 <lambdabot> Maybe you meant: google googleit do
19:43:29 <dmwit> ?google io monad for people who just don't care
19:43:30 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
19:43:30 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
19:43:37 <encryptio> i have a recursive function f :: [Thing] -> IO (). i want to add a base case for f [] = mzero, but mzero is not defined for IO. what do i mean to say?
19:43:49 <dmwit> encryptio: return (), perhaps?
19:44:07 * ksf recommends
19:44:10 <encryptio> ah, it's so simple.
19:44:13 <ksf> @where typeclassopedia
19:44:13 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:44:31 <ksf> it's going to asplode your head, but that's fine.
19:44:31 <Orclev> jimi_hendrix: haskell is many ways is the opposite of perl in that it's very very strict with regards to types and such
19:44:42 <ksf> you don't have to grok it in all its depth on first read.
19:44:45 <ddarius> mzero is defined for IO ...
19:44:54 <jimi_hendrix> aye, in perl a hash is a list is a scalar
19:45:19 <jimi_hendrix> ok, will read tomorrow
19:45:21 <ksf> but perl is quite similar to haskell in that stuff is often utterly abstract
19:45:25 <Orclev> ksf: having just read typeclassopedia and most of real world haskell, I think real world haskell provides a better foundation to understand typeclassopedia
19:45:32 <ddarius> @instances MonadPlus
19:45:33 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
19:45:43 <Orclev> ksf: two sides of the strictness coin
19:46:11 <encryptio> ddarius: my ghc doesn't see that instance.
19:46:38 <ksf> yep, but typeclassopedia is relatively short, and you can use it to connect some points in abstract space, even if you don't grok the lines in between.
19:47:31 <jimi_hendrix> and what the heck is type m b
19:47:52 <ksf> as in
19:47:56 <ksf> :t (>>=)
19:47:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:47:57 <Orclev> hmm... that would be an interesting graph... do a 2d graph with the X axis being strictness and the Y axis being abstraction, and then plot all the languages
19:48:02 <ksf> it's any monad.
19:48:17 <ksf> ...what is what (Monad m) => means
19:48:41 <dmwit> jimi_hendrix: It's (IO b), but generalized slightly. =)
19:48:59 <jimi_hendrix> i turn to int how?
19:49:01 <ksf> and * -> * means that m is not a type, but a thing that is a type if you pass it a type.
19:49:19 <dmwit> jimi_hendrix: There's no way to turn IO Int to Int.
19:49:33 <joevandyk> sumOfUniqueFibs x = sum (nub (takeWhile (<x) fibs))
19:49:33 <joevandyk> fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
19:49:38 <jimi_hendrix> ok
19:49:38 <joevandyk> there a better way to write that code?
19:49:39 <ddarius> :t const 3 :: IO Int -> Int
19:49:40 <lambdabot> IO Int -> Int
19:49:51 <ksf> @slap ddarius
19:49:51 <lambdabot> I don't perform such side effects on command!
19:49:54 <Orclev> (Blah a) => is applying a typeclass restriction to a type variable... a typeclass can be thought of as a bit like a interface in other languages, it's essentially a guarantee of the kinds of functions provided for a particular type
19:50:15 <ksf> @src Monad
19:50:16 <lambdabot> class  Monad m  where
19:50:16 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:50:16 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:50:16 <lambdabot>     return      :: a -> m a
19:50:16 <lambdabot>     fail        :: String -> m a
19:50:19 <dmwit> joevandyk: uniqueFibs = drop 1 fibs -- ...
19:50:37 <dmwit> joevandyk: shouldn't need nub, in other words
19:50:41 <ksf> that's what you get for every monad. the important ones are (>>=) (pronounce: bind) and return
19:50:45 * jimi_hendrix is having brain fry
19:50:55 <Orclev> jimi_hendrix: welcome to Haskell
19:51:05 <joevandyk> dmwit: right -- anything else?
19:51:13 <jimi_hendrix> when do i feel smarter?
19:51:13 <Orclev> jimi_hendrix: the good news is, it gets easier
19:51:48 <dmwit> joevandyk: Seems fine other than that.  Keep in mind that for large x, "sum" is going to give you some badly behaving code, thanks to being implemented lazily by default.
19:51:50 <Orclev> jimi_hendrix: give it a few days at least to settle in... I'm adjusting to it after playing with it for a few months now, although there's still a lot I don't get
19:51:56 <encryptio> jimi_hendrix: you never feel smarter. you just eventually get it, if you're persistent enough.
19:52:08 <joevandyk> dmwit: i have now:  sumOfUniqueFibs x = sum (takeWhile (<x) (drop 1 fibs))
19:52:09 <ksf> (>>=) allows you to combine a say IO Char with a function of type Char -> IO Bool. it's return type is IO Bool, then.
19:52:12 <dmwit> joevandyk: But don't worry about that until it actually becomes a problem. =)
19:52:15 * ddarius is sure they have a drug that will make you feel smarter.
19:52:19 <dmwit> joevandyk: seems good to me
19:52:28 <joevandyk> dmwit: can you explain what happens if x is too large?
19:52:37 <ksf> :t getChar >>= (\c -> isAlpha)
19:52:38 <lambdabot>     Couldn't match expected type `IO b'
19:52:38 <lambdabot>            against inferred type `Char -> Bool'
19:52:38 <lambdabot>     In the expression: isAlpha
19:52:46 <ksf> :t getChar >>= (\c -> return . isAlpha)
19:52:47 <lambdabot>     Couldn't match expected type `IO a'
19:52:47 <lambdabot>            against inferred type `Char -> Bool'
19:52:47 <lambdabot>     In the second argument of `(.)', namely `isAlpha'
19:52:50 <dmwit> joevandyk: Hmm, in short, or in long?
19:52:52 <ksf> :t getChar >>= (\c -> return . isAlpha c)
19:52:53 <lambdabot>     Couldn't match expected type `IO a' against inferred type `Bool'
19:52:53 <lambdabot>     In the second argument of `(.)', namely `isAlpha c'
19:52:53 <lambdabot>     In the expression: return . isAlpha c
19:52:55 <ksf> :t getChar >>= (\c -> return isAlpha c)
19:52:56 <lambdabot>     Couldn't match expected type `IO b'
19:52:56 <lambdabot>            against inferred type `Char -> Bool'
19:52:56 <lambdabot>     In the first argument of `return', namely `isAlpha'
19:52:58 <ksf> :t getChar >>= (\c -> return isAlpha $ c)
19:52:59 <lambdabot>     Couldn't match expected type `IO b'
19:53:00 <lambdabot>            against inferred type `Char -> Bool'
19:53:01 <lambdabot>     In the expression: return isAlpha $ c
19:53:04 <joevandyk> dmwit: both?
19:53:05 <ksf> hell I should think before I type
19:53:08 <jimi_hendrix> ddarius, its called diablo 2, after you are done running Baal for the night, you feel smart when you bruch your teeth because it invovles more than mouse button clicks and the occational hotkey
19:53:09 <ksf> :t getChar >>= (\c -> return $ isAlpha c)
19:53:10 <lambdabot> IO Bool
19:53:28 <jimi_hendrix> so can i just get the line to read in an int then
19:53:35 <ksf> :t getChar >>= (\c -> if c == 'a' then True else False)
19:53:36 <lambdabot>     Couldn't match expected type `IO b' against inferred type `Bool'
19:53:36 <lambdabot>     In the expression: True
19:53:36 <lambdabot>     In the expression: if c == 'a' then True else False
19:53:47 <ksf> :t getChar >>= (\c -> return if c == 'a' then True else False)
19:53:48 <lambdabot> parse error on input `if'
19:53:52 <ksf> :t getChar >>= (\c -> return $ if c == 'a' then True else False)
19:53:53 <lambdabot> IO Bool
19:53:54 <dmwit> ksf: In short, you'll get a stack overflow as you try to evaluate a thunk that has as many additions as there are fibonacci numbers less than x.
19:53:56 <Orclev> :t readLine
19:53:57 <dmwit> err
19:53:57 <lambdabot> Not in scope: `readLine'
19:54:01 <Orclev> hmm
19:54:04 <Orclev> :t readLn
19:54:05 <lambdabot> forall a. (Read a) => IO a
19:54:07 <dmwit> That was meant to be @joevandyk, not @ksf.
19:54:20 <Orclev> :t readLn :: Int
19:54:21 <dmwit> joevandyk: In long, we have
19:54:21 <lambdabot>     Couldn't match expected type `Int' against inferred type `IO a'
19:54:21 <lambdabot>     In the expression: readLn :: Int
19:54:23 <dmwit> ?src sum
19:54:23 <lambdabot> sum = foldl (+) 0
19:54:28 <Orclev> :t readLn :: IO Int
19:54:29 <lambdabot> IO Int
19:54:43 <dmwit> joevandyk: In general, lazy left folds are going to build really deeply nested thunks -- which is rarely what you want.
19:54:57 <encryptio> instance MonadPlus [] -- Defined in Control.Monad
19:54:57 <encryptio> *ExecuteTypeLess> :i MonadPlus
19:54:57 <encryptio> class (Monad m) => MonadPlus m where
19:54:57 <encryptio>   mzero :: m a
19:54:57 <encryptio>   mplus :: m a -> m a -> m a
19:54:59 <encryptio>         -- Defined in Control.Monad
19:55:00 <dmwit> joevandyk: It's common to see a definition like "sum' = foldl' (+) 0" in code that needs to avoid that.
19:55:02 <encryptio> instance (MonadPlus m) => MonadPlus (StateT s m)
19:55:02 * jimi_hendrix is now lost
19:55:04 <encryptio>   -- Defined in Control.Monad.State.Lazy
19:55:07 <encryptio> FACK, sorry
19:55:12 <ksf> so you can't get stuff _out_ of the IO monad, but you can put functions _into_ it, that are allowed access to the pure values (those without IO in front of them)
19:55:54 <dmwit> > sum [a,b,c,d,e,f]
19:55:55 <lambdabot>   0 + a + b + c + d + e + f
19:56:25 <jfoutz> sum [a,a,a]
19:56:29 <jfoutz> > sum [a,a,a]
19:56:30 <lambdabot>   0 + a + a + a
19:56:30 <Orclev> jimi_hendrix: a lot of the standard functions in haskell are polymorphic... the compiler figures out what they need to return based on the way you use them... for instance, readLn, reads a line from stdin, and returns something... but until you use it, the compiler doesn't know what it needs to return
19:56:39 <Orclev> :t readLn
19:56:40 <lambdabot> forall a. (Read a) => IO a
19:56:43 <jimi_hendrix> ok
19:56:53 <ksf> :t readLn :: IO String
19:56:54 <lambdabot> IO String
19:56:58 <ksf> :t readLn :: IO Int
19:56:59 <lambdabot> IO Int
19:57:02 <jimi_hendrix> > readLn == 5
19:57:03 <lambdabot>   No instance for (GHC.Num.Num (GHC.IOBase.IO a))
19:57:04 <lambdabot>    arising from the literal...
19:57:23 <Orclev> jimi_hendrix: you can specify what you want explicitly by tacking ":: Foo" onto the end of an expression
19:57:31 <jimi_hendrix> ok
19:57:36 <Orclev> jimi_hendrix: but when you're actually using the function you shouldn't need to
19:57:39 <dmwit> > readLn == "foo" -- this probably gives a better error message
19:57:40 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO a'
19:57:40 <lambdabot>         against inferred typ...
19:57:40 <ksf> ...and lambdabot won't execute IO actions.
19:57:57 <dmwit> ...against inferred type String
19:58:28 <ksf> :t (== "foo") <$> readLn
19:58:29 <lambdabot> IO Bool
19:58:42 <jimi_hendrix> well can i get a line showing proper usage of reading in an int there
19:58:53 <Orclev> hmm
19:59:01 <ksf> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
19:59:15 <Gracenotes> liftM2 (==) (return "foo") readLn
19:59:27 <dmwit> guessGame = do { guess <- readLn; if guess < 50 then print "too low" else print "too high" }
19:59:42 <Orclev> ^ that works
19:59:57 <Orclev> it's implicit from the way guess is used that is must be something like an int
20:00:23 <dmwit> (Most readable/exploded is probably best for now.  Let the liftM2 and (<$>) and stuff come later, after the understanding is there.)
20:00:24 <ksf> it's going to end up to be an Integer, to be precise.
20:00:27 <Orclev> and since guess is assigned from readLn, the compiler can deduce what you want
20:01:16 <Orclev> although assigned isn't really the preferred term there
20:01:46 <ksf> points are meaningless.
20:02:23 <dmwit> jimi_hendrix: I just got some great advice from my trusty handbook, "The Hitchhiker's Guide to the Galaxy", it said, "Don't Panic."
20:02:28 <dmwit> =)
20:03:21 <SamB_XP_> and secondly, don't forget your towel!
20:03:21 <jimi_hendrix> 42
20:03:41 <ksf> btw: Has haskell's learning courve plateaued for any of you, yet?
20:03:46 <tkr> hey. always you dont know to do: "panic"
20:04:09 <ksf> it seems to oscillate between sqrt(x) and x^2 here.
20:04:09 <Axman6> tkr: pardon?
20:04:12 <tkr> panic is the best solution.
20:04:16 <sproingie> i dont hit plateaus so much as walls
20:04:24 <jimi_hendrix> ok, now what is wrong with     r <- randomRIO (0, 100); game (r :: Int)
20:04:25 <tkr> you try every possible solution then.
20:04:29 <ksf> yep that's the x^2 parts.
20:04:35 <tkr> its also an irocnic comment.
20:04:56 <sproingie> hey it only took FIVE HOURS to link hunit with 256 megs ram
20:04:59 <ksf> :t randomRIO
20:05:00 <lambdabot> forall a. (Random a) => (a, a) -> IO a
20:05:21 <dmwit> jimi_hendrix: That looks fine on its own.  What's the context?
20:05:23 <dmwit> ?hpaste
20:05:23 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:05:34 <ksf> jimi_hendrix, did you write ; or did you just use it to fit it on one irc line?
20:05:39 <dmwit> It may help us to have the error, too.
20:05:47 <sproingie> i think we've established that driving ghc into swap on a vps host == FAIL
20:05:49 <ksf> if you use it, you've got to use {}, too.
20:05:55 <ksf> ...but layout is usually preferred.
20:06:01 <dmwit> No, you can use ; without {}.
20:06:04 <jimi_hendrix> ksf, the latter
20:06:12 <dmwit> > do [3,4];[5,6]
20:06:13 <lambdabot>   [5,6,5,6]
20:06:18 <ksf> uh.
20:06:21 <jimi_hendrix> Couldn't match expected type `IO b' against inferred type `Int'
20:06:21 <jimi_hendrix>     In the first argument of `game', namely `(r :: Int)'
20:06:23 <ksf> but not without do.
20:06:46 <jimi_hendrix> main = do <the code i posted>
20:06:57 <ksf> oh, then it's game :: IO Int -> IO (something), for some reason.
20:07:27 <dmwit> jimi_hendrix: Your error is most likely in game.
20:07:32 <ksf> try annotating it as game :: Int -> IO () to nail the type error.
20:07:35 <Orclev> hpaste seems to be down... at least it just errored on me
20:07:49 <dmwit> And it is most likely that you are trying to do (a <- b) in game, where "b" is the argument to game.  This is a mistake.
20:08:01 <ksf> (type errors don't nescessarily show up at the same place as the mistake)
20:08:05 <dmwit> hpaste is working for me
20:08:24 <Orclev> dmwit: I re-submitted after the error and it worked, must have been a temporary blip
20:08:33 <Orclev> jimi_hendrix: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10838#a10838
20:08:56 <Orclev> whoops, hold on
20:08:59 <dmwit> jimi_hendrix: ignore Orclev
20:09:02 <dmwit> He's smoking.
20:09:04 <Orclev> forgot about the stupid IO
20:09:31 <ksf> Orclev transcended type checking.
20:09:49 <Orclev> yeah yeah, should have punched it into ghci first
20:09:55 <jimi_hendrix> it says it does not like num in < num in the game function i posted earlier (do you guys want a repost)
20:09:59 <ksf> he's got a script that inserts unsafeCoerce around every type error, and then his programs run like a gentle wind.
20:10:37 <dmwit> jimi_hendrix: Paraphrased error messages are rarely helpful...
20:10:49 <tessier> Do people functional testing when writing haskell?
20:11:07 <dmwit> hunit, quickcheck, smallcheck are all good for that
20:11:10 <jimi_hendrix> http://pastebin.com/d13d0ae5
20:11:12 <dmwit> And yes, people do.
20:11:38 <dmwit> jimi_hendrix: Each line of a do block has to be an IO action.
20:11:44 * tessier just saw "Write Yourself a Scheme in 48 Hours" on reddit and it makes me want to have another go at haskell
20:11:59 <sproingie> write yourself a haskell in 48 hours might be harder
20:12:04 <ksf> that error doesn't match up with the code.
20:12:05 <dmwit> jimi_hendrix: So you have to turn that Bool into an IO action; for example, with if.
20:12:07 <Orclev> jimi_hendrix: the second example (ignore my stupid first attempt) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10838#a10839
20:12:20 <tessier> The explanation of monads is brutally simple and I think maybe I am closer to grokking them. Much better than pages of explanation about toxic waste and space suits.
20:12:23 <dmwit> jimi_hendrix: if guessNum < num then do { whatever } else do { whatever else }
20:12:28 <dmwit> (for example)
20:12:44 <dmwit> tessier: The toxic waste one was always meant to be a joke...
20:12:59 <dmwit> Orclev: That won't work either.
20:13:01 <sproingie> the one i was introduced to was the assembly line and boxes metaphor
20:13:02 <tessier> dmwit: Seriously? I thought it was serious! No wonder.
20:13:11 <dmwit> Orclev: Needs more ($)
20:13:19 * Orclev sighs.
20:13:29 <tessier> Orclev: Needs more cowbell.
20:13:32 <jimi_hendrix> tessier, join the club
20:13:32 <dmwit> Orclev: Didn't you learn your lesson about running it through ghc first last time? ;-)
20:13:39 <sproingie> monads only clicked when i realized that monads weren't all magically interchangeable container types, that they were just datatypes with some operators that all kinda sorta have the same gist
20:13:45 <Orclev> dmwit: clearly not
20:13:51 <SamB_XP_> dmwit: are you SURE that was always a joke?
20:13:58 <dmwit> SamB_XP_: ...I suppose not.
20:14:06 <SamB_XP_> I could have sworn I saw something not intended as a joke that used that metaphor :-(
20:14:07 <dmwit> Are you the author or something?
20:14:08 <tessier> It seems it *became* a joke.
20:14:16 <ksf> monads are just like the favourite sweater of my gf: warm and fuzzy.
20:14:21 <jimi_hendrix> dmwit, is there else if or something
20:14:24 <SamB_XP_> could be wrong, of course
20:14:27 <Orclev> ok, now it *should* work... although I still haven't run it through ghci
20:14:27 <dmwit> jimi_hendrix: Of course.
20:14:36 <heatsink> A class constraint is necessary to call a class method.  Why isn't a class constraint necessary to invoke an associated type?
20:14:41 <tessier> Maybe it will become part of haskell hacker culture to write outrageously bizarre explanations of monads
20:14:42 <dmwit> jimi_hendrix: if foo then bar else if baz then quux else quintessential
20:14:53 <tessier> "You see, there is VD out there everywhere and monads are like condoms..."
20:14:54 <dmwit> jimi_hendrix: (i.e. just nested if statements, no magic to see here)
20:15:01 <Orclev> tessier: it isn't already?
20:15:08 <ksf> heatsink, because associated types don't have anything to do with classes
20:15:09 <SamB_XP_> I think the closest I have ever written to a monad tutorial is a half-finished write up on a certain BF interpreter in Haskell
20:15:10 <sproingie> ah yes simon's one regret, not calling monads "warm fuzzy things"
20:15:17 <ksf> it's just syntactic sugar around type families
20:16:05 <SamB_XP_> tessier: except monads work better than condoms!
20:16:23 <dmwit> jimi_hendrix: If it's a long nest, you might prefer the trivial case match (it might make you laugh the first time you see it):
20:16:28 <heatsink> ksf, oh, thanks.
20:16:36 <Orclev> sometimes haskells distinct lack of DWIM annoys me... then I think about how often DWIM fails in spectacularly strange ways and I feel a bit better
20:16:40 <jimi_hendrix> dmwit, no, it made my head expload
20:16:43 <dmwit> case () of () | condition1 -> branch1 | condition2 -> branch2 | otherwise -> defaultBranch
20:17:08 <sproingie> haskell has a lot of DWIM, it just knows what you mean better than you do
20:17:11 <dmwit> > otherwise
20:17:12 <lambdabot>   True
20:17:22 <SamB_XP_> I enjoy the DWIM that Haskell actually *does* have
20:17:28 <lispy> ?check otherwise
20:17:29 <lambdabot>   "OK, passed 500 tests."
20:17:40 <ksf> is that short for "do what _it_ means"?
20:17:43 <SamB_XP_> the DWIM where it picks the overload that actually has the right return type ;-)
20:17:43 <Saizan_> SamB_XP_: e.g.?
20:17:47 <heatsink> Nice to know that there is no bug in the implementaton of 'otherwise'.
20:17:49 <tessier> SamB_XP_: True. I've never put on a monad inside out.
20:17:58 <dmwit> > case () of () | odd 42 -> "it's weird that 42 is odd, don't you think?" | last [1..5] == 5 -> "well, this one makes sense" | otherwise -> "FAIL"
20:17:59 <lambdabot>   "well, this one makes sense"
20:18:07 <lispy> heatsink: Yeah, because 'otherwise' we'd have a problem
20:18:22 <Orclev> :t otherwise
20:18:23 <lambdabot> Bool
20:18:40 <dmwit> :t odd 42
20:18:41 <lambdabot> Bool
20:18:46 <dmwit> :t last [1..5] == 5
20:18:47 <lambdabot> Bool
20:18:51 <dmwit> So no surprises there. =)
20:19:13 <lispy> > otherwise == last [1..5]
20:19:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
20:19:14 <lambdabot>    arising from the literal `1'...
20:19:21 <lispy> > otherwise == (last [1..5] == 5)
20:19:22 <lambdabot>   True
20:19:36 <lispy> > otherwise == (last [1..5] == 5) == odd 42
20:19:36 <lambdabot>   Precedence parsing error
20:19:37 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
20:19:40 <Orclev> > last [1..5] == 5
20:19:41 <lambdabot>   True
20:19:52 <lispy> > otherwise == ((last [1..5] == 5) == odd 42)
20:19:53 <lambdabot>   False
20:20:04 <dmwit> ?let xor False = id; xor True = not
20:20:04 <lambdabot>  Defined.
20:20:06 <Orclev> @src otherwise
20:20:07 <lambdabot> otherwise = True
20:20:25 <lispy> > if otherwise then 'a' else 'b'
20:20:25 <lambdabot>   'a'
20:20:30 <dmwit> ?check liftM2 (liftM2 (==)) xor (/=)
20:20:31 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
20:20:31 <lambdabot>    arising from a use of `Da...
20:20:39 <dmwit> aww
20:20:41 <dmwit> ?undefine
20:20:43 <jimi_hendrix> YEAY
20:20:54 <Orclev> jimi_hendrix: breakthrough?
20:20:54 <jimi_hendrix> AFTER 3 HOURS I GOT MY GUESS THE NUMBER GAME WORKING!
20:20:57 <dmwit> jimi_hendrix: ihighfive.com!!!
20:20:59 <Orclev> lol
20:21:10 <Orclev> jimi_hendrix: congratulations
20:21:24 <Axman6> hoorah jimi_hendrix!
20:22:25 <jimi_hendrix> that took longer than it should have, but it feels so pure
20:22:47 <dancor> now make it a lambdabot extension
20:22:50 <Orclev> ok, lambdabot totally needs to save that quote
20:23:06 <jimi_hendrix> how do i do that
20:23:08 <ksf> @remember jimi_hendrix that took longer than it should have, but it feels so pure
20:23:08 <lambdabot> It is forever etched in my memory.
20:23:28 <Axman6> @quote pure
20:23:28 <lambdabot> Jafet says: The C preprocessor is purely dysfunctional
20:23:30 <jimi_hendrix> shall i repeat my quote so it gets saved instead of how do i do that
20:23:39 <dmwit> ?quote jimi_hendrix
20:23:40 <lambdabot> jimi_hendrix says: that took longer than it should have, but it feels so pure
20:23:44 <Orclev> jimi_hendrix: ksf took care of it
20:23:45 <dmwit> You don't need to repeat anything.
20:23:46 <Axman6> @quote pure
20:23:46 <lambdabot> roconnor says: If one wants to go swimming with sharks, or program in a non-pure language, I suppose that is one's choice
20:23:47 <jimi_hendrix> oo nice
20:23:54 <dmwit> ?quote oasis
20:23:54 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
20:24:12 <heatsink> heh
20:24:22 <tessier> Twice as many people in here as in ##java. WTF? I guess it just goes to show that java is the language of soulless coders who just want a paycheck and don't take much join in their work.
20:24:30 <jimi_hendrix> ok, good night
20:24:42 <dmwit> Or Haskell coders have nothing better to do on a Friday night.
20:24:43 * Orclev makes no comment on corporate java coding.
20:24:49 <jimi_hendrix> btw, you guys are helpful
20:24:49 <dmwit> And Java coders have parties and stuff.
20:24:50 <heatsink> tessier: ...or get much return out of it.
20:24:53 <dmwit> Now isn't that depressing.
20:25:08 <jimi_hendrix> imo C# > Java
20:25:12 * dmwit remains undepressed
20:25:23 <jimi_hendrix> too bad it doesnt have a life outside of windows
20:25:30 <medfly> tessier, maybe it means that Java users are much more likely to find a job, and the Haskell guys remain unemployed, so they have time to hang out on an IRC channel
20:25:39 <dmwit> jimi_hendrix: Well, Mono gives it life outside of Windows.
20:25:39 <jimi_hendrix> na
20:25:43 <Orclev> once again, no comment
20:25:45 <jimi_hendrix> i knew a guy who had to be on IRC for work
20:25:46 <ksf> too bad java doesn't constist of more than a sun billboard.
20:25:55 <jimi_hendrix> dmwit, i know, but there arnt many .Net apps outside of windows
20:26:05 <djahandarie> jimi_hendrix, I wonder how that guy's productivity was
20:26:30 <jimi_hendrix> he didnt talk unless you pinged him
20:26:32 <djahandarie> I used to be on IRC during work, but I stopped since I decided I actually wanted to get work done.
20:26:38 <jimi_hendrix> actually, i havnt seen him in a few months...
20:26:45 <medfly> heh.
20:27:12 <jimi_hendrix> so what else can i do to practice the magic of haskell?
20:27:16 <medfly> I have a friend who works from home (uses delphi, though), and is always online on IRC, though he is inactive most of the time.
20:27:16 <sproingie> actually there's a lot of mono out there, it's just in integrated stacks in mobile devices
20:27:27 <sproingie> yahoo's music player doodad was all mono
20:27:29 <dmwit> jimi_hendrix: Maybe check out Project Euler?
20:27:50 <jimi_hendrix> good idea
20:28:03 <jimi_hendrix> people still use delphi?
20:28:15 <dmwit> People still use a pencil and paper?
20:28:19 <dmwit> People still use brainfuck?
20:28:27 <jimi_hendrix> no one did in the first place?
20:28:50 <dmwit> All I'm saying is, just because people have solved PE problems using a thing doesn't mean they're popular... =P
20:29:03 <encryptio> is there something so that i can do Monad m => m a -> m (), semantically identical to but without resorting to the (ugly in my eyes) \x -> sequence_ [x] ?
20:29:10 <aavogt> doesn't mean they actually did...
20:29:13 <encryptio> specifically, this is in Parsec...
20:29:16 <dmwit> encryptio: (>> return ())
20:29:18 <Orclev> I don't forsee popular and brainfuck *ever* being used together in a sentence
20:29:35 <dmwit> aavogt: They post their solutions on the forums...
20:29:55 <jimi_hendrix> why is haskell becoming the perl of the functional world in my mind...
20:29:57 <dmwit> :t \x -> x >> return ()
20:29:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:30:08 <ksf> encryptio, foo act = fmap (const ()) act
20:30:08 <encryptio> now i feel stupid. asking two different questions and getting, largely, the same simple answer.
20:30:21 <sproingie> jimi_hendrix: it certainly has the TMTOWTDI philosophy
20:30:24 <dmwit> =)
20:30:38 <sproingie> jimi_hendrix: and quite often the noisy syntax to go with it
20:30:39 <jimi_hendrix> TMTOWTDI?
20:30:39 <aavogt> dmwit: well I didn't see any bf solutions in those I looked at
20:30:46 <sproingie> jimi_hendrix: There's More Than One Way To Do It
20:30:57 <dmwit> aavogt: Okay, fair enough.  I just picked an unlikely language off the top of my head.
20:30:59 <jimi_hendrix> uhu
20:31:14 <dmwit> aavogt: But people do choose to do PE problems in weird languages just for the fun of conquering that language...
20:31:18 <ksf> jimi_hendrix, you could learn lazy k.
20:31:32 <ksf> http://homepages.cwi.nl/~tromp/cl/lazy-k.html
20:31:34 <Orclev> I've never heard of lazy k before
20:32:07 <Orclev> ... ewww
20:32:12 <jimi_hendrix> lazy k?
20:32:19 <jimi_hendrix> do i want to see it?
20:32:23 <ksf> yep.
20:32:34 <ksf> it's to haskell what bf is to say c.
20:32:37 <Orclev> if only for the experience of WTFitude
20:33:13 <Saizan_> haskell syntax is very terse actually
20:33:56 <Saizan_> but maybe you've to get used to the possibility of defining operators
20:34:46 <Axman6> is lazy k just using SKI?
20:35:06 <SamB_XP_> Lazy K is what I thought "purely functional" meant before I started learning Haskell
20:37:03 <ksf> ski and a stream-based IO system, yes.
20:37:34 <SamB_XP_> except it has the answer to how that could actually allow you to do anything
20:39:22 <heatsink> > let(<>)=Nothing in do       {[(<>)]}
20:39:23 <lambdabot>   [Nothing]
20:40:51 <Axman6> hmm, i'm trying to find this thing from one of my lectures that mentioned the iota combinator, that was a single combinator that you could write s, k and i in (and as such, copute anything you wanted with it)
20:41:18 <dmwit> <K^4, K, S> ?
20:41:35 <Jeb> hello
20:41:54 <dmwit> Apparently no, wikipedia says iota x = x S K
20:42:11 <dmwit> ?let iota x = x ap const
20:42:12 <lambdabot>  Defined.
20:42:13 <dmwit> :t iota
20:42:14 <lambdabot> forall (m :: * -> *) a b a1 b1 t. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
20:42:30 <dmwit> Jeb: Hiya!
20:43:17 <Saizan_> dmwit: that doesn't mean you can't implement S and K given iota
20:43:34 <dmwit> hm?
20:43:44 <dmwit> Did I claim that?
20:43:48 <Axman6> heh
20:43:50 <Saizan_> sorry, misread
20:43:58 <ksf> well apperantly I can solve the halting problem being given an oracle
20:44:35 <dmwit> Aren't oracles just great?
20:44:37 <Axman6> ksf: better give Oracle a call then
20:45:03 <dmwit> I think it's fascinating that people study classes of problems assuming oracles that are known to be impossible to create.
20:45:51 <ksf> ...but the thing about the HP is that even with an oracle, it reduces to russel's paradox.
20:45:57 <ddarius> Most (a mild understatement) real numbers are uncomputable.
20:46:19 <ksf> if thisProgramHalts then loopEndlessly else terminate
20:46:23 <Axman6> rawg,all the sites i can find about the iota combinator are down or missing :(
20:46:43 <Adamant> dmwit: the point is usually that something not quite as powerful as a real oracle can often be built.
20:46:54 <Adamant> at least in terms of cryptography
20:46:56 <SamB_XP_> ksf: I don't think halting oracles are usable recursively!
20:46:57 <Adamant> which loves them some oracles
20:47:38 <SamB_XP_> I mean, you hit _|_ if you try to take "fix halts" or anything like that!
20:47:41 <dmwit> ddarius: That used to bother me.
20:48:00 <ksf> still, a non-recursive halting oracle would have to be able to analyse a program using a recursive halting oracle.
20:48:13 <ksf> ...and gets hung up on _|_
20:49:18 <Axman6> i saw a really interesting talk recently that added another combinator to SKI (i think) to add more power, ie, pattern matching, so you could inspect things
20:50:15 <dmwit> I saw a really interesting talk recently that explained where the S combinator comes from.
20:50:19 <ddarius> : DOUBLE SEMI-COLON
20:50:26 <jfredett> ... My fiancee just said, "My boss' whistling drives me so nuts, I just want to punch them in the monads."
20:50:36 * jfredett can't stop laughing
20:51:21 <Axman6> here's the paper: http://www-staff.it.uts.edu.au/~cbj/Publications/factorisation.pdf
20:51:26 * Orclev ponders where one might find ones Monads.
20:51:36 <Axman6> and the slides can be found down the bottom: http://plrg.science.mq.edu.au/wiki/sapling/Meeting09
20:51:39 <dmwit> Between your megs, of course.
20:51:40 <bob0> What is a monad?  A man with a single testicle?
20:51:40 <Jeb> if I have a type, suppose    type Frog = (Int,Int)           how do I impliment 'show' for it-or does this question not make sense?
20:51:56 <Axman6> Jeb: sure it makes sense
20:51:58 <Orclev> dmwit: boo
20:52:06 <dmwit> instance Show Frog where show (x, y) = ...
20:52:16 <dmwit> Jeb: But (Int, Int) already has a Show instance.
20:52:19 <jfredett> She's coming down off of 8 cups of coffee and a 14 hour workday.
20:52:20 <SamB_XP_> Jeb: it's already implemented !
20:52:30 <jfredett> so she's a comedy gold at the moment
20:52:52 <Jeb> thanks
20:53:05 <Jeb> all my examples used    data instead of type
20:53:26 <Orclev> hmm... can you do @src on a typeclass instance?... so, @src Show (x, y)?
20:53:29 <dmwit> Jeb: In that case, the easiest thing is just to add "deriving Show" at the end.
20:53:46 <dmwit> ?src (a, b) show
20:53:46 <lambdabot> Source not found. You untyped fool!
20:54:04 <Jeb> thanks for your help
20:54:13 <dmwit> Jeb: data Frog = Frog Int String deriving (Read, Show) -- for example
20:54:46 <Jeb> thanks
20:55:01 <Jeb> what's the difference between type, and data?
20:55:12 <Orclev> Jeb: type is just a name alias
20:55:12 <dmwit> the constructor ;-)
20:55:25 <Jeb> ah, alright
20:55:38 <Orclev> more or less
20:55:43 <Jeb> lol
20:55:45 <dmwit> Jeb: It's the difference between "typedef" and "struct", if you're a C guy.
20:56:14 <Orclev> :t String
20:56:15 <lambdabot> Not in scope: data constructor `String'
20:56:18 <Orclev> hmm
20:56:19 <Jeb> k
20:56:24 <dmwit> :k String
20:56:25 <lambdabot> *
20:56:33 <dmwit> ?src String
20:56:33 <lambdabot> type String = [Char]
20:56:52 <dmwit> > ("hey" :: String, "hey" :: [Char])
20:56:53 <lambdabot>   ("hey","hey")
20:56:56 <Orclev> :t "foo"
20:56:57 <lambdabot> [Char]
20:57:35 <Orclev> :k Maybe
20:57:36 <lambdabot> * -> *
20:57:36 <dmwit> Actually, I guess using [] instead of () would probably drive that point home ever so slightly better.
20:57:47 <Jeb> @paste
20:57:47 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:58:27 <Jeb> what's wrong with this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4413#a4413
20:58:36 <dmwit> There's already an instance for Show (Int, Int).
20:58:39 <dmwit> As we said before.
20:59:01 <Orclev> aside from that, nothing
20:59:07 <Jeb> ah, so it won't let me make a new one
20:59:08 <dmwit> Also, H98 doesn't allow instance declarations with type aliases.
20:59:25 <Jeb> alright then, it would work if I changed it to data then?
20:59:33 <dmwit> Sure.
20:59:40 <Orclev> dmwit: really?... let me guess, there's a ghc extension for that though right?
20:59:49 <dmwit> Orclev: Well, of course.
21:00:10 <dmwit> FlexibleInstances or something like that.  Try it, and GHC will tell you the right name.
21:00:38 <Orclev> dmwit: yeah, I usually get a handful of those when I'm mucking around with something, but I tend to forget them after I add them to a LANGUAGE pragma
21:00:38 <jokerGTA> guys why is this comprehension wrong ?[n + m | n<- [7,2] , last n , m<-[6,1]
21:00:53 <copumpkin> :t last
21:00:54 <lambdabot> forall a. [a] -> a
21:01:00 <copumpkin> n will be 7 or 2
21:01:05 <dmwit> jokerGTA: n is not a list, and last doesn't return a Bool
21:01:09 <jokerGTA> it should be only 2
21:01:22 <copumpkin> jokerGTA: you can't do that kind of stuff from inside a list comp
21:01:29 <dmwit> > [n + m | let n = last [7, 2], m <- [6, 1]]
21:01:30 <lambdabot>   [8,3]
21:01:35 <dmwit> copumpkin: Oh, nonsense.
21:01:38 <dmwit> You can do whatever you like.
21:01:43 <jokerGTA> lol
21:01:55 <copumpkin> well, I thought he meant he wanted to do something specific when he hit the last element of a given list
21:02:12 <jokerGTA> i thought you can put any kind of expression or condition inside
21:02:24 <dmwit> That's true, you can't treat elements differently based on their position without some contortions.
21:02:30 <dmwit> jokerGTA: last n is not a condition.
21:02:35 <jokerGTA> like in this example i just wanted to take last element of first list and apply it to each element in second list
21:02:40 <copumpkin> jokerGTA: sure, but you don't get information on your position inside the comprehension
21:02:42 <dmwit> jokerGTA: And no, you can't put any kind of expression in.
21:03:06 <copumpkin> ...unless you zip with [0..] or something, which is ugly
21:03:07 <dmwit> > [ last [7, 2] + m | m <- [6, 1] ] -- another way of saying the same thing
21:03:08 <jokerGTA> so only expression that returns bool value?
21:03:08 <lambdabot>   [8,3]
21:03:17 <dmwit> copumpkin: Right, contortions.  ewww
21:03:22 <dmwit> jokerGTA: correct
21:03:27 <jokerGTA> oh ok
21:03:27 <copumpkin> :)
21:03:36 <jokerGTA> tx dmwit
21:04:07 <jokerGTA> guys why is this comprehension wrong ?[n + m | n<- [7,2] , even n , m<-[6,1]
21:04:12 <jokerGTA> sorry type
21:04:14 <jokerGTA> typo
21:04:18 <jokerGTA> lol
21:04:36 <jokerGTA> [n + m | n<- [7,2] , even n , m<-[6,1]
21:04:40 <Orclev> I've decided that combinatory logic is evil... also, I now need some aspirin
21:04:51 <dmwit> jokerGTA: needs more ]
21:05:01 <jokerGTA> [n + m | n<- [7,2] , even n , m<-[6,1]]
21:05:09 <copumpkin> > [n + m | n <- [7, 2], even n, m <- [6, 1]]
21:05:10 <lambdabot>   [8,3]
21:05:13 <lispy> > [7,2]
21:05:14 <lambdabot>   [7,2]
21:05:26 <jokerGTA> [n + m | n<- [7,2] , even n , m<-[6,1]]
21:05:40 <jokerGTA> why dont i get return when i type this here
21:05:43 <Orclev> what's the second term doing there?
21:05:44 <jokerGTA> [n + m | n<- [7,2] , even n , m<-[6,1]]
21:05:52 <Orclev> need to add >
21:05:57 <lispy> > [n + m | n<- [7,6..2] , even n , m<-[6,5..1]]
21:05:58 <dmwit> ?let ensure p x = guard (p x) >> return x
21:05:58 <lambdabot>   [12,11,10,9,8,7,10,9,8,7,6,5,8,7,6,5,4,3]
21:05:59 <lambdabot>  Defined.
21:06:06 <jokerGTA> >[n + m | n<- [7,2] , even n , m<-[6,1]]
21:06:14 <copumpkin> needmoar space
21:06:29 <jokerGTA> > [n + m | n<- [7,2] , even n , m<-[6,1]]
21:06:30 <lambdabot>   [8,3]
21:07:09 <aavogt> > do n <- [7,2]; guard (even n); m <- [6,1]; return (n+m)
21:07:10 <lambdabot>   [8,3]
21:07:30 <dmwit> > [7, 2] >>= ensure even >>= flip map [6, 1] . (+)
21:07:31 <lambdabot>   [8,3]
21:07:44 <Orclev> > [n + m | n <- [7,2], even n, m <- [6,1], even m]
21:07:45 <lambdabot>   [8]
21:07:45 <copumpkin> zomg da powa
21:07:49 <aavogt> @info do n <- [7,2]; guard (even n); m <- [6,1]; return (n+m)
21:07:49 <lambdabot> [7, 2] >>= \ n -> guard (even n) >> [6, 1] >>= \ m -> return (n + m)
21:08:00 <copumpkin> needs moar kleisli composition
21:08:44 <aavogt> @. pl info do n <- [7,2]; guard (even n); m <- [6,1]; return (n+m)
21:08:44 <lambdabot> Plugin `compose' failed with: Unknown command: "info"
21:08:51 <aavogt> @. pl undo do n <- [7,2]; guard (even n); m <- [6,1]; return (n+m)
21:08:51 <lambdabot> ap ((>>=) . (>> [6, 1]) . guard . even) ((return .) . (+)) =<< [7, 2]
21:09:01 <copumpkin> eww
21:09:07 <dmwit> Mine's better, and I did it by hand.
21:09:11 <jokerGTA> > [n + m | n<- [7,2] , any (>2) n , m<-[6,1]]
21:09:12 <lambdabot>   No instance for (GHC.Num.Num [a])
21:09:12 <lambdabot>    arising from the literal `7' at <inter...
21:09:34 <jokerGTA> > [n + m | n<- [7,2] , any (==7) n , m<-[6,1]]
21:09:35 <lambdabot>   No instance for (GHC.Num.Num [a])
21:09:35 <lambdabot>    arising from the literal `7' at <inter...
21:09:44 <dmwit> jokerGTA: n is not a list
21:09:48 <Orclev> I think it's almost time for me to get to bed... most of this stuff is started to run together into big jumbles
21:10:16 <jokerGTA> oh i see....n is element taken from the list
21:10:22 <dmwit> right!
21:10:54 <jokerGTA> > [n + m | n<- [7,2] , n==7 , m<-[6,1]]
21:10:55 <lambdabot>   [13,8]
21:11:20 <Orclev> anything that returns a Bool is considered a guard?... and the gaurds are cumulative over the entire comprehension?
21:11:32 <dmwit> Orclev: Yes, and no.
21:11:34 <copumpkin> :t guard
21:11:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:11:38 <dmwit> Orclev: They're desugared to guard.
21:11:43 <dmwit> hmm
21:11:54 <dmwit> So, a "kind of, yes" rather than a "no", I guess.
21:12:28 <dmwit> Yes, in the sense that they all have to be satisfied; no, in the sense that the order they're given compared to other list bindings can affect the efficiency.
21:13:10 <Orclev> well, that's the same as any guard though, the sooner it can short-circuit the more efficient it is
21:13:29 <dmwit> > [ x | x <- [1..5], y <- [1..], even x ]
21:13:33 <lambdabot>   mueval-core: Time limit exceeded
21:13:39 <dmwit> > [x | x <- [1..5], even x, y <- [1..] ]
21:13:40 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
21:14:13 <Axman6> huh, i'd never thought of doing that. seems logical now
21:14:15 <Orclev> > [x | even x, x <- [1..5], y <- [1..]]
21:14:16 <lambdabot>   []
21:14:24 <jokerGTA> dwit i see you placed condition on the end
21:14:27 <dmwit> > even x -- because "x" is an Expr
21:14:28 <lambdabot>   False
21:14:31 <jokerGTA> does it always have to be at the end
21:14:32 <ksf> :t assert
21:14:33 <lambdabot> Not in scope: `assert'
21:14:36 <ksf> @hoogle assert
21:14:37 <lambdabot> Control.Exception assert :: Bool -> a -> a
21:14:37 <lambdabot> Control.OldException assert :: Bool -> a -> a
21:14:37 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
21:14:39 <Axman6> > odd x
21:14:40 <lambdabot>   True
21:14:47 <dmwit> jokerGTA: Nope, I placed it on the end in one and in the middle in the other. =)
21:14:55 <dmwit> > odd y
21:14:56 <lambdabot>   True
21:14:57 <ksf> assert <*> (iterate [True,False])
21:14:58 <Orclev> > x
21:14:59 <lambdabot>   x
21:15:01 <ksf> > assert <*> (iterate [True,False])
21:15:01 <jokerGTA> no rule where to place it?
21:15:02 <lambdabot>   Not in scope: `assert'
21:15:05 <ksf> gragh.
21:15:14 <ksf> :t assert <*> (iterate [True,False])
21:15:15 <lambdabot> Not in scope: `assert'
21:15:17 <Orclev> > l
21:15:18 <lambdabot>   l
21:15:23 <Orclev> hmm
21:15:25 <dmwit> jokerGTA: You may interleave conditions with bindings in any order, yes.
21:15:36 <dmwit> jokerGTA: (Though conditions using a bound variable must come after the binding, of course.)
21:15:47 <jokerGTA> yes
21:15:56 <dmwit> jokerGTA: In general, you want the condition to come as early as possible, i.e. as soon as all the variables it refers to are bound.
21:15:57 <Axman6> bleh, concurrency in C/POSIX sucks :(
21:16:20 <Orclev> you can shorten that to "concurrency sucks"
21:17:56 <Axman6> concurrency is lovely in both haskell and Ada (and Erlang)
21:18:32 <jokerGTA> yeah i am juts trying to make sense of all this haskell things i need to learn
21:39:54 <sohum> what's the easiest way to modify the return value of a thing in the State monad?
21:40:08 <sohum> actually, is there like a cheatsheet for easiest way to do common things with the State monad?
21:40:36 <aavogt> sohum: fmap?
21:40:55 <aavogt> @docs Control.Monad.State
21:40:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
21:41:14 <sohum> yea, those docs don't really help
21:41:57 <aavogt> @docs Control.Monad.State.Class
21:41:57 <lambdabot> Control.Monad.State.Class not available
21:42:07 <aavogt> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Class.html
21:42:52 <aavogt> basically, if it looks like there aren't any functions to do what you want, you should look at the instances your type is a member of
21:43:15 <sohum> right
21:43:18 <aavogt> for the state monad they are practically all class methods
21:44:14 <aavogt> > liftM succ (put 1 >> return 2)
21:44:16 <lambdabot>   No instance for (GHC.Show.Show (m a1))
21:44:16 <lambdabot>    arising from a use of `M508617757...
21:44:33 <aavogt> > runState $ liftM succ (put 1 >> return 2)
21:44:34 <lambdabot>   {-3->(3,1);-2->(3,1);-1->(3,1);0->(3,1);1->(3,1);2->(3,1);3->(3,1)}
21:44:53 <aavogt> > flip runState undefined $ liftM succ (put 1 >> return 2)
21:44:54 <lambdabot>   (3,1)
21:45:19 <aavogt> sohum: so you wanted to modify the value of 2 in that expression?
21:45:51 <aavogt> > flip runState undefined $ modify pred $ liftM succ (put 1 >> return 2)
21:45:52 <lambdabot>   Couldn't match expected type `Control.Monad.State.Lazy.State b a'
21:45:52 <lambdabot>         a...
21:46:46 <SamB_XP_> sohum: you can only modify the value of 2 in crazy languages like Python -- and even then, I think you need to use a C extension to actully do it ;-P
21:47:18 <ddarius> instance Num MyInt where ...; fromInteger 2 = 1
21:47:55 <ddarius> SamB_XP_: In early FORTRAN it was a language feature
21:48:09 <SamB_XP_> what the heck ?
21:48:10 <aavogt> SamB_XP_: do you really think of such things as immutable, when the old 2 is unreachable?
21:48:16 <sproingie> self could change primitives too
21:48:46 <aavogt> which means it might as well have been destructively updated
21:48:57 <ddarius> SamB_XP_: Perhaps it was more a confluence of misfeatures...
21:49:25 <sohum> it's like, the State monad is of type \s -> (a,s), right? I want, given a State x, to return \s -> (f (x s), s)
21:49:35 <SamB_XP_> I mean, in Python there is an array of say 0--99 ...
21:49:55 <SamB_XP_> you could alter the value of the "2" element in that array
21:50:09 <SamB_XP_> ... but it really messes things up if you do!
21:51:37 <aavogt> @type flip runState $ do x <- ?start; s <- get; return (?f (x s))
21:51:37 <lambdabot> forall a (m :: * -> *) b s t. (?start::m (s -> t), MonadState s m, ?f::t -> b) => State (m b) a -> (a, m b)
21:53:07 <aavogt> @type runState
21:53:08 <lambdabot> forall s a. State s a -> s -> (a, s)
21:53:14 <aavogt> @type runState $ do x <- ?start; s <- get; return (?f (x s))
21:53:14 <lambdabot> forall s a t. (?f::t -> a, ?start::State s (s -> t)) => s -> (a, s)
21:53:20 <sohum> ..ok, this is hurting my brain
21:53:37 <aavogt> that flip was wrong
21:59:48 <aavogt> sohum: I'm not sure what you mean by the state being both s and x
22:01:23 <sohum> aavogt: aaagh. sorry, let me think about it a bit more
22:01:33 <iaefai> Is there a way to get cabal to build documentation for all installed modules?
22:05:36 <Axman6> how interesting, a python interpreter in haskell
22:06:40 <iaefai> That is interesting
22:11:45 <Axman6> o/ sohum
22:13:23 <aavogt> @type do x <- ?initial; s <- get; return (?f (x s))
22:13:24 <lambdabot> forall (m :: * -> *) b s t. (?initial::m (s -> t), MonadState s m, ?f::t -> b) => m b
22:13:40 <aavogt> @type runState $ do x <- ?initial; s <- get; return (?f (x s))
22:13:41 <lambdabot> forall s a t. (?f::t -> a, ?initial::State s (s -> t)) => s -> (a, s)
22:20:34 <Orclev> I can never remember, is it foldl or foldr that's safe to use on infinite lists?
22:20:44 <aavogt> foldr
22:21:00 <sohum> > foldl1 f [a,b,c,d,e]
22:21:01 <lambdabot>   f (f (f (f a b) c) d) e
22:21:04 <sohum> > foldr1 f [a,b,c,d,e]
22:21:05 <lambdabot>   f a (f b (f c (f d e)))
22:21:18 <Axman6> > foldl (||) False (True:[False,False..])
22:21:19 <lambdabot>   <no location info>: parse error on input `]'
22:21:25 <Cale> @src foldr
22:21:25 <lambdabot> foldr f z []     = z
22:21:25 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:21:44 <Saizan_> > foldl (||) False (True:[False,False ..])
22:21:45 <Axman6> > [1,1..]
22:21:45 <Cale> You can see in foldr's definition that it passes control to f in the nonempty list case
22:21:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:21:48 <Cale> @src foldl
22:21:51 <Axman6> > foldl (||) False (True:[False,False ..])
22:22:01 <lambdabot> foldl f z []     = z
22:22:01 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:22:06 <lambdabot>   mueval: ExitFailure 1
22:22:10 <Cale> while foldl does nothing but call itself until it reaches the end of the list
22:22:10 <Axman6> > foldr (||) False (True:[False,False ..])
22:22:11 <lambdabot>   True
22:22:14 <Orclev> hmm... what about union and intersection, are those safe on infinite lists?
22:22:45 <Cale> Neither are safe, unless you write modified versions for ordered lists, perhaps
22:22:57 <Orclev> hmm
22:23:04 <Cale> Neither is*
22:23:10 <Orclev> well, there goes that idea
22:23:15 <Saizan_> ?type union
22:23:17 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:23:29 <Cale> Er, hmm...
22:23:34 <Saizan_> isn't union xs ys = nub (xs ++ ys) ?
22:23:40 <Cale> oh, maybe it is
22:23:43 <Cale> > union [1,2,3,4,5] [1..]
22:23:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:23:51 <Orclev> :t intersection
22:23:52 <lambdabot> Not in scope: `intersection'
22:23:53 <Cale> > union [1..] [-2]
22:23:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
22:24:03 <Cale> ^^ there's a little problem
22:24:08 <Axman6> heh
22:24:12 <Cale> But it at least works
22:24:13 <Saizan_> it's not fair :)
22:24:16 <Orclev> :t intersect
22:24:17 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:24:55 <Orclev> > intersect [1,2,3,4,5] [1..]
22:24:56 <lambdabot>   [1,2,3,4,5]
22:25:13 <Saizan_> > intersect [-1] [1..]
22:25:14 <Cale> > intersect [-2] [1..]
22:25:19 <Orclev> > intersect [2,4..] [1..]
22:25:19 <lambdabot>   mueval-core: Time limit exceeded
22:25:19 <lambdabot>  mueval: ExitFailure 1
22:25:19 <lambdabot>   mueval-core: Time limit exceeded
22:25:20 <Cale> whee
22:25:28 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
22:25:48 <Cale> > intersect [1..] [2,4..]
22:25:51 <Orclev> ok, well, that seems safe at least
22:25:55 <lambdabot>   mueval: ExitFailure 1
22:25:58 <Orclev> hmm
22:26:45 <Orclev> why did mine work, but yours failed... the oder of the args I wouldn't think would make a difference
22:26:51 <Orclev> order even
22:26:53 <Saizan_> they do
22:26:54 <Cale> They do because you have two infinite lists
22:27:01 <Saizan_> ?src intersection
22:27:02 <lambdabot> Source not found.
22:27:10 <Cale> and it doesn't do anything fancy to diagonalise the search through those
22:27:29 <Cale> (which would scatter the elements out of order anyway)
22:27:45 <Saizan_> i think it's intersection xs ys = filter (`notElem` ys) xs
22:27:54 <Cale> yeah, something like that
22:28:15 <Saizan_> and notElem on infinite lists is not guaranteed to terminate
22:28:26 <Cale> It's doing a search through one list for each element of the second. If it always finds it, that's good, but if the element isn't there in an infinite list, it will take forever trying to determine that
22:28:50 <Orclev> well, I'm trying to find the first intersection of 20 infinite lists
22:29:08 <Cale> This is also super inefficient when you're starting off with ordered lists
22:29:19 <Cale> Making use of the fact that they're sorted does wonders :)
22:30:05 <Orclev> ok, I was trying to be lazy and brute force this thing, but I guess I'll actually have to come up with an elegant solution
22:30:22 <Cale> Are your lists ordered?
22:30:27 <Orclev> yes
22:31:09 <Cale> Just write a simple intersectOrd function (or google that, you'll probably find one) which walks down two lists, advancing whichever list has the smaller element.
22:31:20 <jfredett> I think that's a record for me, got the HWN out before bedtime. very cool.
22:31:48 <jfredett> sadly a bit light this week though, not too many package announcements...
22:31:50 <Cale> http://paste.lisp.org/display/17513 -- lol, it's from me, 3 years and 7 months ago
22:32:09 <sohum> ok, (>>=) on State s passes the state through unchanged, right?
22:33:14 <Cale> sohum: 'unchanged'? x >>= f will first run x on the initial state, getting a new state along with a result v, and then runs f v with the new state
22:34:02 <Cale> (and leaves the final state and result of f v as the final state and result of the whole computation
22:34:05 <Cale> )
22:35:56 <sohum> gaah
22:35:59 <sohum> ok
22:36:20 <Cale> Is that a gaah of understanding, or a gaah of confusion?
22:36:27 <sohum> both
22:36:44 <Cale> It is quite a mouthful, I know.
22:36:53 <Cale> So, let's suppose we have:
22:36:53 <sohum> I'll try to figure out what I don't understand
22:37:07 <Cale> newtype State s a = S (s -> (s,a))
22:37:25 <Cale> runState :: State s a -> s -> (s,a)
22:37:29 <Cale> runState (S f) s = f s
22:38:25 <Cale> So we're representing a computation which operates on states of type s while producing a result of type a as simply a function from an initial state of type s, to a (final state, result) pair
22:38:50 <sohum> yep
22:38:57 <Cale> and we have a function runState which, given such a computation and an initial state, runs the computation, producing a final state and result
22:39:05 <Cale> So now,
22:39:25 <Cale> x >>= f = ...
22:39:40 <Cale> Well, we know we want it to be a State s computation, and we only have one way to make those right now
22:39:47 <Mr_Awesome> in the function (ceiling . sqrt . fromInteger), what is the actual type of the argument to sqrt?
22:39:48 <Cale> which is to apply the S constructor to a function
22:40:01 <Cale> x >>= f = S (\s -> ...)
22:40:08 <Cale> the function might as well be a lambda
22:40:20 <Cale> So s here will be our initial state
22:40:21 <Saizan_> Mr_Awesome: it's defaulting to Double
22:40:40 <Cale> and we said x >>= f will first run x with initial state s
22:40:51 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in ...)
22:40:51 <Mr_Awesome> Saizan_: really. was it always like that?
22:41:05 <Cale> It'll get a new state s' and a result v when it does that
22:41:19 <Cale> and then it's supposed to run f v with the new state s'
22:41:25 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in runState (f v) s')
22:41:27 <Saizan_> Mr_Awesome: afaik
22:42:33 <Cale> Or, if we want to be more explicit
22:42:43 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
22:43:39 <Cale> sohum: Does that help at all?
22:44:04 <sohum> Cale: I think so, yes
22:44:08 <sohum> thank you very much
22:44:15 <Cale> No problem :)
22:44:56 <Cale> It might help to note that the left hand side can be sugared into: do v <- x; f v
22:45:15 <iaefai> I am trying to compile HPong, and I am getting a problem where the compiler chokes on a Color3 constructor that is passed Doubles and suggests adding an instance for Doubles. I am not entirely sure how to do that, and I was wondering if there might be a proper way to use this that HPong might not be doing.
22:45:47 <Cale> which if you ignore lots of details, looks a lot like the  S (\s -> let (s',v) = runState x s in runState (f v) s')
22:45:55 <iaefai> The function that it defines is color3 = Color3, and its type is color3 :: Double -> Double -> Double -> Color3 Double
22:46:15 <Cale> Particularly, if you cover up everything dealing with s and s' ;)
22:46:17 <dmwit> iaefai: That doesn't look like the word "instance" really applies.  What's the exact error messagee?
22:46:39 <Saizan_> iaefai: opengl lately changed some type alias into newtypes
22:46:51 <iaefai> Saizan_: which means to me?
22:47:07 <Saizan_> iaefai: so you probably have to insert the newtype constructors there and change color3's type
22:47:16 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10841#a10841
22:47:29 <Saizan_> (by opengl there i meant the OpenGL haskell bindings)
22:47:57 <iaefai> Saizan_: Is there a way to update HPong's code so that it works properly as intended with the change?
22:48:38 <iaefai> I am going to be using HPong as a basis for another project, so i desire good methods
22:49:35 <Saizan_> i think so, you've to use GLfloat instead of Double
22:50:02 <Saizan_> GLfloat is defined in the OpenGL package
22:51:28 <Saizan_> and you might just be able to propagate the type change through HPong without altering the code itself, since GLfloat is an instance of all the usual classes you'd use Double with
22:53:19 <Saizan_> oh, sorry, there's a GLdouble too
22:54:58 <iaefai> I am having trouble with some inferred vs. expected types
22:56:24 <Saizan_> have changed occurrences of Double with GLdouble in type signatures?
22:56:47 <iaefai> I was using GLfloat
22:56:52 <iaefai> I double it would matter
22:57:07 <iaefai> But there are some functions that are getting Doubles
22:57:18 <iaefai> for example:    get time >>= newIORef >>= mainLoop game
22:57:40 <iaefai> I am not sure what to make of 'get time'
22:57:45 <iaefai> But it should be the source of the double
22:58:08 <iaefai> I think I found time: time :: StateVar Double  in GLFW
22:58:18 <Saizan_> you can use realToFrac to convert a Double to another Floating type
22:58:29 <Saizan_> such as GLfloat or GLdouble
22:58:35 <iaefai> Can I use that on a StateVar Double?
22:59:00 <Saizan_> you should be able to use it on get time
22:59:14 <Saizan_> like "fmap realToFrac (get time)"
22:59:47 <sohum> @hoogle Word8 -> Word16
22:59:48 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
22:59:48 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:59:48 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
22:59:58 <Saizan_> probably also on the StateVar, but i've never used it
23:00:43 <Saizan_> though realToFrac is quite inefficient, iirc, because it goes via Rational if it's not optimized away
23:01:11 <iaefai> That worked actually
23:01:19 <iaefai> I would like a better way then, but for now it is working
23:01:34 <iaefai> What is this 'get' function?
23:04:16 <Saizan_> by the names it looks like StateVar is some sort of reference and get is the accessor, what you use to get the value out of it
23:05:54 <Saizan_> so (get time :: IO Double) and fmap just tunnels realToFrac through IO
23:07:15 <iaefai> Why did this thing stop using Doubles? I am not understanding the actual reason why I am forced to change this code.
23:12:42 <sohum> @pl \x -> ([],x)
23:12:42 <lambdabot> (,) []
23:12:53 <sohum> oh duh
23:13:37 <dolio> That'll be ([],) in 6.12.
23:13:54 <FunctorSalad_> tuple seckshuns
23:14:56 <FunctorSalad_> but still no projections I suppose
23:15:35 <dolio> Projections don't require compiler changes. Just motivated library maintainers.
23:15:47 <dmwit> Projections?
23:15:55 <dmwit> You mean like frst, scnd, thrd?
23:16:06 <FunctorSalad_> hehehe
23:16:32 <dmwit> http://hackage.haskell.org/package/tuple
23:16:36 <FunctorSalad_> well maybe some more graph syntax (*,,,*) (bad example)
23:16:46 <FunctorSalad_> for projection to 1st and 5th component
23:16:53 <dmwit> How about syntax sel1, sel2, sel3, etc.?
23:16:59 <dmwit> As in that library?
23:17:20 <FunctorSalad_> hmm yeah you can probably (&&&) the one-dimensional projections to achieve such a thing
23:17:40 <dmwit> No, I think you have to write them all by hand.
23:17:45 <dmwit> But they're written already!
23:17:47 <dmwit> Just use them!
23:18:04 <FunctorSalad_> (,,,)
23:18:06 <FunctorSalad_> :)
23:18:58 <FunctorSalad_> I mean you can (&&&) the 1d-projections to get projections from n-tuple to k-tuple
23:19:13 <sohum> dolio: that's exactly what I was thinking
23:19:25 <sohum> @pl \x -> (x,[])
23:19:25 <lambdabot> flip (,) []
23:19:46 <FunctorSalad_> (but you'll get nested tuplez)
23:46:52 <sohum> @pl \x -> ([],[],x)
23:46:52 <lambdabot> (,,) [] []
23:47:05 <sohum> ... that's the function's name?
23:47:16 <dolio> @pl \x -> ([],x,[])
23:47:16 <lambdabot> flip ((,,) []) []
23:47:27 <sohum> huh
23:47:46 <dolio> > (,,,,,,,,,) 1 2 3 4 5 6 7 8 9 10
23:47:48 <lambdabot>   (1,2,3,4,5,6,7,8,9,10)
23:50:01 <Mr_Awesome> is there a more efficient way to do (reverse [a..b])?  it seems [b..a] when b > a just gives [].
23:50:18 <dolio> > [b, pred b .. a]
23:50:19 <lambdabot>   * Exception: not a number
23:51:03 <Mr_Awesome> > [ 5, pred 5 .. 1]
23:51:04 <lambdabot>   [5,4,3,2,1]
23:51:52 <Mr_Awesome> nice. what is this syntax called, by the way?
23:52:25 <dolio> I don't know if it has a name.
23:52:31 <dolio> Just various syntax for lists.
23:52:45 <dolio> > [100, 88 .. 14]
23:52:45 <lambdabot>   [100,88,76,64,52,40,28,16]
23:53:05 <dolio> [a, b .. c] is sugar for enumFromThenTo a b c
23:53:18 <dolio> [a..] is enumFrom a, [a..b] is enumFromTo a b
23:53:52 <reima> The Report calls them "Arithmetic Sequences" (3.10)
23:54:15 <dolio> Yeah, I guess that makes sense.
23:54:27 <Mr_Awesome> ah, i see. thanks.
23:55:02 <reima> Additionally, there is [a,b..] = enumFromThen a b
23:55:12 <dolio> Ah, right. I thought I was forgetting one.
23:56:06 <trofi> :t Ratio
23:56:07 <lambdabot> Not in scope: data constructor `Ratio'
23:56:24 <dolio> :k Ratio
23:56:24 <lambdabot> * -> *
23:56:35 <trofi> :t (Ratio Int)
23:56:36 <lambdabot> Not in scope: data constructor `Ratio'
23:56:36 <lambdabot> Not in scope: data constructor `Int'
23:58:17 <dolio> Ratio Int is bad news.
23:58:21 <sohum> @pl \x -> (x,[],[])
23:58:21 <lambdabot> flip (flip (,,) []) []
23:58:50 <dolio> > 2^30 + 1%2 :: Ratio Int
23:58:51 <lambdabot>   2147483649 % 2
23:59:03 <dolio> > 2^31 + 1%2 :: Ratio Int
23:59:04 <lambdabot>   4294967297 % 2
23:59:12 <dolio> > 2^62 + 1%2 :: Ratio Int
23:59:13 <lambdabot>   (-9223372036854775807) % 2
23:59:41 <trofi> :t Rational
23:59:42 <lambdabot> Not in scope: data constructor `Rational'
