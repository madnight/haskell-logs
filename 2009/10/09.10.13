00:01:28 <FunctorSalad> "<ksf> mathematicians never heard of the concept of "rough consensus and running code", did they?" <-- ?
00:02:31 <QtPlaty[1ireMe]> FunctorSalad: Context?
00:02:55 <FunctorSalad> QtPlaty[1ireMe]: 6:26 ;)
00:04:00 <FunctorSalad> apart from that, don't know
00:05:19 <c_wraith> @src MonadState
00:05:19 <lambdabot> Source not found. I am sorry.
00:05:32 <c_wraith> haskell.org seems to be not responding. :(
00:06:23 <ivanm> QtPlaty[1ireMe]: still looking for work I see...
00:06:32 <QtPlaty[1ireMe]>   Yea
00:07:15 <c_wraith> I really wish hackage.haskell.org was up.  I need to read docs. :(
00:07:34 <c_wraith> @hoogle iterateM
00:07:35 <lambdabot> No results found
00:08:13 <ivanm> c_wraith: docs for what?
00:08:23 * voker57 hugs his hackage mirror
00:08:38 <c_wraith> A bunch of stuff.  MonadReader and MonadState at the moment
00:09:10 <ivanm> from mtl?
00:09:10 <voker57> which package is that?
00:09:15 <c_wraith> yes, mtl
00:09:24 <ivanm> c_wraith: maybe from the GHC general docs?
00:09:36 * arcatan ghc his hackage mirror
00:10:01 <ivanm> c_wraith: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/index.html
00:10:08 <ivanm> mtl docs are there
00:10:26 <c_wraith> thanks
00:16:50 <ksf> FunctorSalad, me not liking proofs.
00:17:01 <ksf> that is, show me something that goes bling and I'm happy.
00:17:15 <FunctorSalad> c_wraith: cabal unpack mtl; cd mtl; cabal haddock --hyperlink-sources
00:17:21 <FunctorSalad> ;)
00:17:51 <c_wraith> unpack will work from the local packages?  I suppose that makes sense
00:18:07 <c_wraith> (it'd be something of a performance issue if it didn't)
00:18:09 <FunctorSalad> ksf: I agree things that go bling are more fun, but maybe it's a good thing that proofs force one to think? dunno
00:18:15 <FunctorSalad> *that things that go bling
00:19:14 <ksf> http://www.reddit.com/r/programming/comments/9tcn5/the_riaas_favorite_thread_of_all_time_a/    you know what, that's the perfect opportunity to fail avoiding success.
00:20:40 <dolio> You mean, write the highly illegal file sharing software in Haskell? :)
00:21:14 <ivanm> sounds like a winner to me! :D
00:21:24 <ksf> it's utterly legal.
00:21:33 <ivanm> just don't let users use it, that's all!
00:21:39 <ksf> we can use it to distribute hackage packages.
00:21:50 <ksf> and the platform.
00:21:55 <ivanm> ksf: ssshhhhh!
00:22:26 <ksf> heck, darcs could be the first p2p vcs.
00:22:52 <ksf> no point in downloading all patches from one source if everyone has all of them.
00:25:18 <ivanm> preflex_: seen cale
00:25:18 <preflex_>  cale was last seen on #haskell 11 hours, 32 minutes and 34 seconds ago, saying: Is laser chicken a game of daring played by photons to see which one has better nerves?
00:25:58 <c_wraith> @hoogle lookupBy
00:25:58 <lambdabot> No results found
00:27:07 <ivanm> @tell Cale in case you dind't see the -cafe message, I wonder if this implementation provides anything useful for the generic graph stuff (which we should really get back to): http://www.osl.iu.edu/research/comparing/
00:27:08 <lambdabot> Consider it noted.
00:32:18 <Samy> gah,I wish it was up too.
00:33:19 <int-e> we could try sacrificing a goat.
00:33:49 <ivanm> int-e: you've got one handy, do you?
00:33:57 <int-e> Then dance the darcs dance, and hum the lambda chant, appealing to the ghc gods.
00:34:01 <int-e> Sadly, no.
00:35:35 <voker57> ksf: gittorrent is already there
00:35:53 <ivanm> voker57: no, the idea is we implement the next great file sharing client
00:36:17 <voker57> > darcs could be the first p2p vcs.
00:36:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:36:25 <ivanm> heh
01:05:58 <FunctorSalad> haskell-mode "insert type signature" has been broken for a long time btw :(
01:06:24 <FunctorSalad> not sure what exactly breaks it
01:06:25 <c_wraith> yay, hackage is back
01:06:36 <FunctorSalad> either explicit 'forall' or just long types
01:08:48 <tomoj> is there no tab-completion for emacs?
01:09:02 <tomoj> (with ghc)
01:09:10 <xSaterus> M-/
01:11:11 <FunctorSalad> think he's looking for ghci's completetion, not emacs's (I'm too ;))
01:11:48 <tomoj> indeed
01:17:07 <Twey> Hm, that would be nice.
01:17:20 <FunctorSalad> "The new DeriveFunctor, DeriveFoldable and DeriveTraversable language extensions enable deriving for the respective type classes."
01:17:22 <FunctorSalad> awesome
01:18:34 <dolio> Nice.
01:18:40 <Twey> Data.Derive is awesomer.
01:18:50 <Twey> (Deriving?)
01:22:23 <ivanm> FunctorSalad: nope
01:22:36 <ivanm> comint mode disables the ghci tab completion due to brokenness IIRC
01:23:37 <Baughn> ivanm: Bugyness, more like. It's pretty easy to fix.
01:23:49 <tomoj> oh?
01:23:54 <ivanm> *shrug* whatever you want to call it
01:24:02 <ivanm> Baughn: if it's so easy to fix it, then fix it! :p
01:25:55 <Baughn> ivanm: Trying! Trying!
01:26:26 <Baughn> Well.. it /should/ have been easy to fix, at least
01:26:52 <Baughn> Quoting a tab sends ghci a tab just fine, but for some reason that doesn't start the autocompleter
01:27:17 <Baughn> Because it thinks it's not connected to a terminal? *shrug*
01:33:02 <jkff> Hi folks. I am going to write myself a tool for drawing timing diagrams: a rather simple one, just several tracks and continuous and discrete events. What graphics package would you recommend to base it on?
01:33:23 <ivanm> Baughn: heh
01:33:38 <ivanm> jkff: what kind of graphics do you want?
01:33:46 <ivanm> if you want a chart/plot, see the chart library
01:33:57 <ivanm> there's also limited gnuplot bindings if you don't want the gtk2hs dep
01:34:38 <jkff> ivanm: A chart/plot, yes. I looked a bit at the Chart library, but it looks like I will have to write a lot of things from scratch anyway; what does it have that I might reuse?
01:34:56 <ivanm> what would you want to reuse?
01:35:08 <ivanm> are the types of plots you want completely different from the ones it offers?
01:35:15 <jkff> I guess yes
01:35:45 <jkff> I might reuse some scaling and ways for drawing axes probably...
01:36:10 <ivanm> jkff: better off if your plot types are general enough is to contribute patches to the chart developer
01:36:13 <ivanm> rather than copy/pasting
01:37:18 <jkff> That sounds right :) Are you aware of whether Chart handles huge pictures and huge amount of data (millions of points) generally?
01:37:40 <jkff> I'm going to use my tool for log analysis
01:37:45 <jkff> And logs are big, y'know :)
01:38:09 <Baughn> jkff: Have you looked
01:38:12 <Baughn> jkff: ..at gnuplot?
01:38:27 <jkff> Baughn: I'm looking at it right know and trying to find out whether it supports timing diagrams
01:42:06 <jkff> Looks like it doesn't..
01:44:52 <sergio1> I think I've read (article, haskell-cafe?) something like defining a graph via a custom monad
01:45:00 <sergio1> I googled to no avail.
01:45:13 <sergio1> Do you guys have useful pointers?
02:11:07 <ivanm> sergio1: what do you mean?
02:11:18 <ivanm> you can use maps, etc. to define custom graph-like data structures
02:11:47 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10685#a10685
02:11:51 <c_wraith> Not sure what's going on.
02:12:05 <ivanm> jkff: no idea how well chart scales
02:12:25 <c_wraith> http://hackage.haskell.org/packages/archive/explicit-exception/0.1.4/doc/html/Control-Monad-Exception-Synchronous.html <-- claims there's an instance
02:12:26 <ivanm> @hoogle lift
02:12:26 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
02:12:26 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
02:12:26 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
02:12:56 <ivanm> c_wraith: what is the type of asks?
02:13:06 <FunctorSalad> @type asks
02:13:07 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
02:13:17 <ivanm> oh, I thought it was a custom function
02:13:31 <ivanm> @hoogle ExceptionalT
02:13:31 <lambdabot> No results found
02:13:43 <FunctorSalad> I think the "asks", "gets" etc family of names is sort of cute
02:13:44 <c_wraith> It's documented in the second link I pasted
02:13:55 <FunctorSalad> like the program is talking about itself in the third person
02:14:01 <ivanm> FunctorSalad: heh
02:14:13 <c_wraith> That documentation claims there's a MonadTrans instance for (ExceptionalT e)
02:14:22 <ivanm> @remember FunctorSalad I think the "asks", "gets" etc family of names is sort of cute, like the program is talking about itself in the third person
02:14:22 <lambdabot> I will remember.
02:14:27 <FunctorSalad> ;)
02:14:38 <ivanm> FunctorSalad: trying to keep jfredett happy ;-)
02:15:02 <kowey> there was a question here earlier about Darcs complaining because there was no _darcs/pristine (although there was _darcs/current)
02:15:04 <FunctorSalad> I'm not sure my analysis of why it sounds cute was totally accurate, though
02:15:17 <kowey> the answers are to either upgrade to the latest darcs or just rename current to pristine
02:15:30 <FunctorSalad> maybe it's also the reading "well, this statement asks"
02:15:40 <FunctorSalad> hard to put one's finger on..
02:17:54 <c_wraith> Is there any way to ask ghci why it thinks a particular instance doesn't apply?
02:18:32 <quicksilver> c_wraith: not as far as I know. That's not normally a hard question tho?
02:20:45 <c_wraith> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10685#a10685 <-- But the Control.Monad.Exception.Synchronous documentation lists MonadTrans (ExceptionalT e) as an instance
02:21:46 <FunctorSalad> did you import the module declaring the instance?
02:22:07 <c_wraith> as far as I know, yes.
02:25:04 <c_wraith> cabal unpack and examination of the source it was actually compiled from confirms that I am importing the module with that instance.
02:25:10 <Veinor> Hey guys what's going on itc?
02:26:05 <crazy2k_> Hello. I feel the need for a dictionary. Is there such thing in Haskell?
02:26:32 <FunctorSalad> crazy2k_: Data.Map
02:27:04 <crazy2k_> FunctorSalad: Thanks.
02:27:43 <Veinor> /usr/share/dict/words?
02:31:50 <c_wraith> ok......
02:31:59 <c_wraith> So, if I copy the instance into my code, it works.
02:32:03 <c_wraith> What's going wrong here?
02:32:21 <c_wraith> ...  Is this a ghci issue?
02:35:43 <Twey> crazy2k_: Data.IntMap if you're going to be using Ints as the keys.
02:36:22 <c_wraith> Does anyone know why ghc might decide that it doesn't know about an instance declaration?
02:38:59 <Botje> SPJ is experimenting with amnesia as an optimization technique?
02:39:51 <c_wraith> Well, that's the second-best suggestion I've seen so far. ;)
02:42:10 <crazy2k_> What's the easiest way to know whether a list has duplicates?
02:42:49 <Botje> crazy2k_: length xs == length (nub xs)
02:42:59 <ivanm> Botje: or just xs == nub xs?
02:43:05 <Botje> or that :)
02:43:09 <ivanm> that way it will return False as soon as an element is missing
02:43:18 <ivanm> of course, if the equality test is expensive, then it's worse
02:43:31 <ilid> nub performs O(n^2) equality tests anyway
02:43:42 <c_wraith>     `lift' is not a (visible) method of class `MonadTrans'
02:43:47 <c_wraith> ....  come on, ghc.
02:43:51 <c_wraith> help me out here.
02:43:52 <crazy2k_> What if I only have the functions in the prelude?
02:43:59 <c_wraith> @src MonadTrans
02:44:00 <lambdabot> Source not found. Are you on drugs?
02:44:03 <ilid> short-circuting nub will usually reduce the number of uses of (==) ;-)
02:44:19 <ivanm> ilid: true, so you'd only have an extra n equality tests
02:44:35 <Botje> crazy2k_: same story, except you write nub yourself
02:45:17 <crazy2k_> Botje: How can I do it?
02:45:32 <crazy2k_> Botje: foldr doesn't seem suitable.
02:45:53 <crazy2k_> Oh, forget it.
02:45:55 <Botje> you could do an insertion sort.
02:48:18 <ilid> crazy2k_: you can do it with foldr
02:48:40 <c_wraith> So...  The only way I can make this work is with an orphan instance
02:48:50 <c_wraith> It's bed time.
02:48:56 <c_wraith> maybe in the morning, ghc will work right
02:50:29 <ilid> > getAny . fst . foldr ((`ap` snd) . (. fst) . ap (flip . (liftM2 (,) .) . flip ((.) . mappend) . (Any .) . elem) (:)) mempty $ "Helo"
02:50:30 <lambdabot>   False
02:50:32 <ilid> > getAny . fst . foldr ((`ap` snd) . (. fst) . ap (flip . (liftM2 (,) .) . flip ((.) . mappend) . (Any .) . elem) (:)) mempty $ "Hello"
02:50:33 <lambdabot>   True
02:52:05 <tomoj> wow
02:52:13 <tomoj> will I be able to understand that someday? O_o
03:00:09 <ilid> tomoj: the zen that is seen / is not the true Zen until / you bring fresh toner.
03:01:05 <ilid> tomoj: (i mangled it to be homework-incompatible)
03:01:19 <tomoj> ah
03:01:28 <tomoj> I should've taken a class with haskell when I was still a CS major :(
03:03:58 <dolio> Did you even have the option?
03:05:59 <tomoj> I believe they learned some in "programming languages"
03:14:39 <tuukkah> dons, do you have the criterion scripts for adaptive-containers somewhere?
03:18:25 <idnar> @quote proven
03:18:25 <lambdabot> No quotes match.
03:25:03 <idnar> @quote proved
03:25:04 <lambdabot> DonaldKnuth says: Beware of bugs in the above code; I have only proved it correct, not tried it.
03:28:19 <thaldyron> I'm trying to 'cabal install HXQ' on my virtual host. The problem is that I only have 256MB real RAM but for some reason GHC uses up to 1GB for the building, so the process gets killed due to excessive swapping. Anything I could try?
03:30:19 <pozic> thaldyron: GHC is a resource hog. Fix GHC, use another Haskell compiler, don't use Haskell, get more RAM, compile on other machine.
03:30:40 <pozic> thaldyron: that said, I want my computer to do as much work as possible.
03:30:52 <PeakerWork> thaldyron: I think its actually the linker that's eating resources on my low-memory computer
04:07:24 <quicksilver> c_wraith: wrong MonadTrans perhaps?
04:09:12 <quicksilver> c_wraith: exceptionalT has an instances of the MonadTrans from transformers, not the MonadTrans from mtl.
04:23:37 <PeakerWork> I had an idea for a ghc type extension. I think its a little annoying that (\x -> (x, x)) y   is different to (y, y).   I think we can add, in addition to universal/existential quantification, a "foreach" quantification so the type of  \x -> (x, x)   would become:  forall b c. foreach [b,c] a. a -> (b, c)   which would make those things the same
04:23:56 <PeakerWork> It would also allow things like:  (*) `on` fromIntegral  to actually be the same as:  \x y -> fromIntegral x * fromIntegral y
04:26:56 <quicksilver> at the cost of removing the principle type property, breaking type inference and making unification unfeasible
04:27:00 <quicksilver> yes, we could do that.
04:30:00 <quicksilver> (I'm not sure if it really does all three of those things, but I recall that things like that tend to be the adjuncts of higher rank inference
04:39:05 <flazz> can anyone give me a pointer on why my this snippet is very slow? http://gist.github.com/209173
04:40:19 <mux> what's the point of reading the contents with a bytestring if you're calling unpack on it right away?
04:40:45 <quicksilver> you hope that unpack fuses with MD5.hash
04:41:14 <quicksilver> and it's still probably more efficient to read cacheline-sized chunks into a compact structure (lazy bytestring) and unpack it in a tight loop in cache
04:41:34 <mux> I'd like some concrete numbers :-)
04:42:02 <tomoj> does "fuses" mean that MD5.hash lazily operates on the result of unpack?
04:42:07 <mux> but first things first
04:42:18 <mux> flazz: what makes you say this is very slow? as compared to something else?
04:42:34 <flazz> mux compared to the os implementation of md5
04:42:44 <tomoj> I wrote a similar tiny wrapper around SHA1.hash and it was 80 times slower than sha1sum
04:43:20 <maurer_> flazz: Have you tried testing it on a large number of strings to average out the setup costs?
04:43:44 <flazz> maurer_: no
04:44:02 <quicksilver> also, showHex is pretty slow
04:44:08 <mux> flazz: wait a minute, Data.Digest.MD5.hash is supposed to operate on [Word8]
04:44:08 <quicksilver> btu that's unlikely to be the bottleneck
04:44:25 <quicksilver> which md5 is that? the pure haskell one?
04:44:33 <quicksilver> I think that's known to be slower than the hand-tuned C one
04:44:37 <maurer_> flazz: Have you done a -prof to find where most time is spent?
04:44:53 <flazz> maurer_: no, never heard of it
04:45:00 <flazz> add it to ghc args?
04:45:09 <jeltsch> How can I reset a Mailman admin password on projects.haskell.org?
04:45:25 <maurer_> flazz: Yes, then there's a few RTS args to give to your prog, and then it'll dump the profile
04:45:47 <maurer_> flazz: You probably want -prof -auto-all
04:45:54 <mux> I actually don't understand how this code typechecks
04:46:04 <hackagebot> th-expand-syns 0.1 - Expands type synonyms in Template Haskell ASTs (DanielSchuessler)
04:46:06 <flazz> add it to ghc args?
04:46:09 <jeltsch> One of a concrete mailing list.
04:46:15 <flazz> oops, up arrow, nm
04:46:36 <mux> I think you should use Data.ByteString.Lazy.Char8 and get rid of the unpack
04:46:47 <mux> and I still don't get how this even compiles
04:47:56 <flazz> mux why would it not compile?
04:49:05 <hackagebot> multirec-alt-deriver 0.1 - Alternative multirec instances deriver (DanielSchuessler)
04:49:35 <mux> ah, got it, nevermind that
04:50:08 <mux> the non-Char8 versions of the ByteString modules unpack to [Word8]
04:51:23 <flazz> so what is the big benefit to using Char8?
04:53:01 <Saizan> none
04:53:06 <hackagebot> th-expand-syns 0.1.0.1 - Expands type synonyms in Template Haskell ASTs (DanielSchuessler)
04:54:00 <FunctorSalad> typo o_o
04:55:27 <ivanm> Saizan: isn't the char8 versions of bytestring useful in that they provide Data.List-like operations?
04:55:53 <ivanm> oh, wait, that's just a lazy vs strict thing...
04:55:59 <ivanm> ignore me (as usual) :p
04:58:09 <dreixel> FunctorSalad: does this new deriver help?
04:58:11 <Saizan> i meant none in this case, iirc there are some differences in the API
04:58:24 <ivanm> *nod*
05:00:19 <FunctorSalad> dreixel: yeah, but I'm not sure which combination of balancing the trees, adding type sigs and adding the "type instance PF" (which I had forgotten) did it
05:00:27 <FunctorSalad> (the latter was definitely necessary)
05:00:31 <FunctorSalad> ;)
05:00:59 <FunctorSalad> strangely, forgetting that instance produced a "couldn't match expected type ..." error
05:01:57 <dreixel> maybe adding the type sigs does make a big difference
05:02:15 <dreixel> anyway, that's good to know
05:02:19 <FunctorSalad> :)
05:02:28 <SamB_XP_> that IS strange ...
05:02:38 <dreixel> do you have a file around with all the code? might be useful for some testing
05:03:05 <dreixel> (like your Bug2.hs, but now compiling :))
05:03:38 <FunctorSalad> dreixel: I was going to package that too, but hold on, I'll quickly upload the current one...
05:04:19 <dreixel> FunctorSalad: well, no hurry
05:07:20 <FunctorSalad> dreixel: http://code.haskell.org/~daniels/NoBug2.hs
05:08:27 <flazz> the profile says that my total time is .32 seconds, time says its 4 seconds. can i assume i have a little under 4 seconds of startup time?
05:08:39 <dreixel> FunctorSalad: thanks!
05:12:08 <zong_sharo> i'm trying to port some really imperative algorithm to haskell, basically it's a bunch of if/elseif; if. each one of then can alter state or return token or some goto's
05:13:04 <zong_sharo> state monad is not a case, cos of it's cannot "return"
05:13:20 <Axman6> zomggooglewaveinvite!
05:13:45 <benmachine> zong_sharo: probably going to need to see some examples
05:13:45 <Saizan> you don't have to translate it literally, you could use a sane control flow for example :)
05:13:54 <benmachine> and yes that
05:13:54 <crysty> hallo all
05:14:08 <benmachine> hello crysty
05:14:17 <zong_sharo> Saizan: it's a bash lexer, overcompilcated, undocummented pile of code
05:14:49 <zong_sharo> i do not wanna refactor it
05:15:00 <zong_sharo> at least now
05:15:38 <zong_sharo> benmachine: http://dpaste.org/QYBY/
05:15:49 <Saizan> hard to translate something without understanding it, imo, though for goto and short-cutting return-like you can use one a continuation monad
05:16:58 <zong_sharo> '''Useful for:
05:17:00 <zong_sharo>     Complex control structures, error handling, and creating co-routines. '''
05:17:04 <flazz> http://gist.github.com/209173, can someone explain the output of the profile? main seems to be 100% and everything else is 0
05:17:09 <Saizan> it doesn't seem so bad, actually
05:17:18 <zong_sharo> sounds good
05:18:16 <zong_sharo> Saizan: it uses a lot of global variables, 19 state bitmasks and some other stuff which i probably not aware right now
05:18:19 <Saizan> flazz: how did you compile it?
05:18:53 <flazz> ghc -O2 -prof -auto-all --make parmd.hs -o parmd
05:20:40 <Saizan> that's good
05:20:55 <Saizan> well, you've only main there as a toplevel definition though
05:21:13 <Saizan> you might want to add some {-# SCC ... #-} manually
05:21:26 <kalven> that's a lot of bytes allocated
05:23:28 <FunctorSalad> flazz: maybe recompile the important dependencies with -auto-all too? (just speculating)
05:24:59 <flazz> kalven: yes it is, almost 500M for a 1.5M file
05:32:44 <flazz> Saizan: i put in the SCCs and the hash function seems to be the culprit
05:35:56 <jetxee> Hi, in quickcheck-2 what is supposed to be used instead of verboseCheck?
05:39:54 <HugoDaniel> hi
05:40:09 <HugoDaniel> when i have a string like this: "DA GRA\65533A" how do i convert it to UTF-8 ?
05:40:29 <HugoDaniel> (its utf-16 i believe)
05:43:58 <yitz> HugoDaniel: what is \65533? sounds weird.
05:44:35 <yitz> anyway, the old way is the utf8-string package, and the new way is Data.Text.
05:45:03 <HugoDaniel> okey
05:45:15 <HugoDaniel> yitz: its Ç
05:46:04 <yitz> > showHex 65533 ""
05:46:05 <lambdabot>   "fffd"
05:46:19 <Saizan> , text . read $ "DA GRA\65533A"
05:46:21 <lunabot>  luna: Prelude.read: no parse
05:46:30 <Saizan> , text . read $ "\"DA GRA\65533A\""
05:46:32 <lunabot>  DA GRA
05:47:40 <HugoDaniel> its DA GRAÇA
05:48:27 <yitz> > text . readHex "c007" $ ""
05:48:28 <lambdabot>   Couldn't match expected type `a -> GHC.Base.String'
05:48:28 <lambdabot>         against inferre...
05:48:29 <pozic> What is the corresponding C type for Haskell Strings? It should be possible to represent non-ASCII characters.
05:48:43 <yitz> @type text . readHex "c007"
05:48:44 <lambdabot>     Couldn't match expected type `[Char]'
05:48:44 <lambdabot>            against inferred type `(a, String)'
05:48:44 <lambdabot>       Expected type: [String]
05:49:03 <yitz> @type text . fst . readHex $ "c007"
05:49:04 <lambdabot>     Couldn't match expected type `(String, b)'
05:49:04 <lambdabot>            against inferred type `[(a, String)]'
05:49:04 <lambdabot>     In the second argument of `(.)', namely `readHex'
05:49:15 <yitz> @type text . fst . head . readHex $ "c007"
05:49:16 <lambdabot>     No instance for (Num String)
05:49:17 <lambdabot>       arising from a use of `readHex' at <interactive>:1:20-26
05:49:17 <lambdabot>     Possible fix: add an instance declaration for (Num String)
05:49:21 <Saizan> HugoDaniel: yeah, lunabot probably filters out anything non-ascii
05:49:30 <cepstrum> Hi, I'm doing a Haskell project in which I have a main.hs in the root of the project directory (/project), that imports a module Test.Fun that is in the directory /project/Test/. But when compiling with ghci, it can't find the module. What's wrong?
05:49:36 <Saizan> , [$ty| text |]
05:49:39 <lunabot>  String -> Doc
05:49:43 <Saizan> yitz: ^^^
05:49:47 <yitz> > readHex  "c007"
05:49:48 <lambdabot>   [(49159,"")]
05:50:40 <yitz> > text . toEnum . fst . head . readHex $ "c007"
05:50:41 <lambdabot>   No instance for (GHC.Enum.Enum GHC.Base.String)
05:50:41 <lambdabot>    arising from a use of `G...
05:50:44 <Saizan> cepstrum: your current working directory isn't /project/
05:51:13 <yitz> > text . (:[]) . toEnum . fst . head . readHex $ "c007"
05:51:14 <lambdabot>   쀇
05:51:49 <cepstrum> Yes, it is. I cd into project/ and type "ghci main.hs"
05:52:29 <Saizan> cepstrum: does Test/Fun.hs have "module Test.Fun where" at the top?
05:52:50 <yitz> > text . (:[]) . toEnum . fst . head . readHex $ "c7"
05:52:51 <lambdabot>   Ç
05:52:55 <cepstrum> Saizan: Yep
05:53:04 <yitz> HugoDaniel: that's it - c7, not fffd
05:53:11 <yitz> > text . (:[]) . toEnum . fst . head . readHex $ "fffd"
05:53:12 <lambdabot>   �
05:53:33 <PeakerWork> readHex/showHex are kind of yucky, would be nicer if they were just instances for a Hex newtype
05:53:47 <yitz> HugoDaniel: Unicode fffd is definitely something really weird.
05:54:07 <cepstrum> Saizan: It is as if it doesn't look in other directories than the current
05:54:32 <Saizan> cepstrum: but it does, it has to be something else
05:54:38 <yitz> PeakerWork, nah, Reads and Shows are actually nice in some situations. I'm just a little foggy today.
05:54:39 <quicksilver> cepstrum: what is the file called?
05:54:48 <yitz> ReadS and ShowS
05:54:58 <quicksilver> cepstrum: the one with module Test.Fun in it
05:55:06 <cepstrum> quicksilver: fun.hs
05:55:11 <Saizan> ah.
05:55:14 <quicksilver> needs to be Fun.hs
05:55:16 <quicksilver> capital F
05:57:10 <cepstrum> quicksilver, Saizan: Ah, thanks! :)
05:58:50 <yitz> HugoDaniel: hmm, Data.Text doesn't do encodings.
05:59:06 <yitz> HugoDaniel: so, there's a whole soup of packages on hackage that do it.
05:59:25 <yitz> encoding, dataenc, Encode, utf8-string, ...
05:59:51 <sinelaw> hey, is there an up-to-date equivalent to "why functional programming matters"?
05:59:57 <yitz> I wish there were a way to know which is standard, looking to the future.
06:00:09 <yitz> Anyone have any idea?
06:00:23 <sinelaw> that explains the differences, and advantages of FP over _modern_ imperative languages
06:00:34 <HugoDaniel> well, my problem is in reading data from mssql server :/
06:00:54 <yitz> ah, dataenc is not encodings, it's things like base64 and uuencode.
06:01:33 <yitz> there's also utf8-light
06:01:50 <HugoDaniel> and Data.Text.Encoding ?
06:02:15 <yitz> so I would say either encoding or Encode ought to be considered standard.
06:02:21 <HugoDaniel> im reading SqlByteString using HDBC (i was using takusen, but i couldn't make it work out as it blew with exceptions on utf-16)
06:02:57 <yitz> although utf8-string has been very popular as a special case just for utf8
06:03:07 <HugoDaniel> i see
06:03:56 <Saizan> yitz: Data.Text does support encodings
06:04:14 <yitz> oh yes?
06:04:18 * yitz looks again
06:04:33 <hackagebot> gladexml-accessor 0.0 - Automagically declares getters for widget handles in specified interface file. (YakovZaytsev)
06:04:40 <Saizan> well, utfN in the text package
06:04:49 <Saizan> http://hackage.haskell.org/packages/archive/text/0.5/doc/html/Data-Text-Encoding.html
06:04:49 <yitz> ah yes, Data.Text.Encoding
06:05:15 <HugoDaniel> so, let me see if i got it right
06:05:24 <Saizan> and then there's the text-icu package for more
06:05:27 <yitz> that's a bad API, it doesn't scale
06:05:35 <yitz> ok
06:05:41 * yitz looks for text-icu
06:05:53 <HugoDaniel> im going to read ByteStrings that come in UTF-16, then i encode them into a Text type... and how do i convert it to Utf-8 ?
06:06:18 <yitz> again - doesn't sound like a stable API
06:06:48 <yitz> binding to icu is ok as a quick fix, but i don't think we want to be tied to ffi for encodings forever.
06:07:06 <yitz> we should have a native haskell implementation, like most other languages
06:07:17 <Saizan> HugoDaniel: http://hackage.haskell.org/packages/archive/text/0.5/doc/html/Data-Text-Encoding.html#v%3AencodeUtf8
06:08:27 <yitz> so imho Data.Text.Encodings should have an Encoding type that is passed as a parameter to encode/decode, which can be expanded as we go along
06:08:32 <pozic> Integrating Haskell with the the rest of the world is a pain.
06:08:53 <pozic> The other way around is quite acceptable, but still not perfect.
06:10:03 <pozic> What would help is a tool that creates C header files from everything the Haskell exported function depends on.
06:10:35 <pozic> The Haskell export FFI is really the bare mininum you need to get anything working, not to get something working _fast_.
06:10:48 <yitz> pozic: aren't there already tools like that?
06:11:44 <pozic> yitz: like?
06:12:02 <pozic> yitz: AFAIK, there is only stuff to get from C to Haskell, not the other way around.
06:12:18 <yitz> oh, that could be
06:12:40 <yitz> pozic: trouble is, it depends on what platform you're exporting to.
06:13:02 <yitz> e.g. a windows dll export will be a lot different than a POSIX static export
06:13:32 <pozic> yitz: so, given a C header file, you can create a Haskell file which can read and write to the C stuff, but given a Haskell file you have to create the C header file by hand, then run the tools, and then connect the Haskell version and the auto-generated Haskell version.
06:13:47 <pozic> yitz: only calling conventions are different, not?
06:14:40 <pozic> I don't know a lot about these things, but I do know that the situation could be a lot better.
06:15:12 <Saizan> pozic: we're waiting for haskell to be so widespread that the C guys will write that tool
06:15:29 <Saizan> and compile C to Haskell, of course
06:16:15 <pozic> Saizan: that won't happen in a loooonnngg time.
06:16:25 <Axman6> c2hs foo.c | ghc --make -O2 -fvia-C -o foo
06:16:26 <Axman6> >_>
06:16:42 <Axman6> though, c2hs is taken already :(
06:16:59 <ivanm> Axman6: I'm currently trying to work out why ANU cares about my secondary schooling if I'm applying for a PhD... :s
06:17:10 <Saizan> pozic: i hope so :)
06:17:18 <Axman6> because they have to know if you're a bogan
06:17:28 <pozic> ivanm: statistics.
06:17:42 <pozic> ivanm: a wonderful tool to control people.
06:17:45 <ivanm> pozic: so they want a transcript for it _why_?
06:17:47 <ivanm> pozic: heh
06:18:03 <ivanm> @remember pozic statistics. a wonderful tool to control people.
06:18:03 <lambdabot> It is forever etched in my memory.
06:18:14 <pozic> ivanm: even grades from your university are meaningless.
06:18:22 <ivanm> Axman6: so I shouldn't tell them about my personal habits? :p
06:18:30 <pozic> ivanm: it only means something if you actually attended the same courses in the same year.
06:18:30 <ivanm> pozic: sure they are... they guarantee me my spot and funding!
06:18:32 <Axman6> probably not
06:18:33 <Axman6> :P
06:18:35 <Axman6> like what?
06:19:01 <ivanm> kidding
06:19:15 <pozic> ivanm: there are lots of ways to get the same piece of paper I got, by just doing all the easy courses.
06:19:21 <ivanm> though I'm trying to work out what's the difference between "Occupation" and "Position" for employment history
06:19:31 <yitz> Axman6: gcc --via-haskell
06:19:34 <ivanm> e.g. for casual tutoring, is that an occupation or a position? :s
06:19:44 <ivanm> pozic: true...
06:19:56 <ivanm> my final grade wans't that great because of an elective I took... >_>
06:20:17 <Axman6> yitz: heh :)
06:20:29 <pozic> A better thing they can ask you is whether you were ever baffled by what they told you at university.
06:20:44 <ivanm> heh
06:20:52 <pozic> No means qualified. Yes means unqualified.
06:21:03 <ivanm> you mean in a class, or some of the beuarecratic (however you spell it) garbage you had to do? :p
06:21:08 <yitz> ivanm: yeah. when i filled out a us passport application for my newborn child, i had to think about what to write for "Occupation".
06:21:20 <yitz> i think i wrote "Baby"
06:21:22 <ivanm> I was baffled by number theory until I actually went and read through all the notes in one go...
06:21:28 <ivanm> yitz: heh
06:21:29 <pozic> ivanm: in a class, well, maybe for some mathematics people can be baffled for some time.
06:21:44 <ivanm> pozic: I was baffled by Design Patterns...
06:21:50 <pozic> ivanm: in what sense?
06:22:02 <ivanm> and why they put all the IT students in with the Engineers listening to "Engineers in Society" in first year...
06:22:02 <ivanm> does that count? :p
06:22:11 <ivanm> pozic: what the point of them all was, and why I would care
06:22:23 <ivanm> AFAICT, it was "hey, stupid, you can't write decent code, so here's some tips!"
06:22:29 <ivanm> which, of course, only made it worse...
06:22:44 <pozic> ivanm: there is some wisdom in it, but not a lot ;)
06:22:54 <sioraiocht> yitz: data.text originally worked that way
06:22:57 <pozic> Certainly not worth the time they spend on it in curricula.
06:23:01 <sioraiocht> I believe it was changed for performance reasons
06:23:17 <Berengal_> In my opinion, you can't teach design patterns.
06:23:29 <yitz> sioraiocht: hmm. i wonder what the problem was.
06:23:55 <sioraiocht> yitz: ask bos
06:24:07 <pozic> Is there some kind of Hackage for C?
06:24:12 <yitz> preflex_: seen bos
06:24:12 <preflex_>  bos was last seen on #haskell 7 hours, 45 minutes and 20 seconds ago, saying: pumpkin: i am, and they call me "bos"
06:24:28 <pozic> I just want to use some basic cross-platform data structures.
06:24:41 <coilid> pozic: there's, umm.. sourceforce? ;-)
06:24:43 <ivanm> pozic: I doubt it
06:25:02 <ivanm> they seem to use the same monolithic libraries over and over again
06:25:16 <pozic> I mean there is apt, which contains a lot, but something more geared towards programmers would be nice.
06:25:51 <yitz> pozic: there are lots of hackages for c
06:25:54 <pozic> And with apt, you first have to figure out whether it also works on Windows.
06:28:36 <pozic> For example, does glib work on Windows without too much effort (e.g. less than 30 minutes of setup site)?
06:52:31 <pozic> yitz: what do you mean?
06:53:40 <pozic> I see lots of pages with opinions on 30 string libraries, individual webpages, and lots of dump places (sourceforge).
06:55:03 <Botje> pozic: glib is (should be) very portabe
06:55:06 <Botje> *portabel
06:55:08 <Botje> **portable
06:55:10 <Botje> damn keyboard.
06:55:36 <Botje> except, perhaps, the threading mechanism.
06:55:36 <yitz> pozic: like you said, glib, apt, and on and on...
06:55:56 <yitz> potable
07:01:17 <benmachine> I found a typo in STM
07:01:20 <benmachine> *gasp*
07:01:52 <benmachine> hunk ./GHC/Conc.lhs 553
07:01:52 <benmachine> -                               if (v) then return () else ( error "Transacional invariant violation" ) )
07:01:56 <benmachine> +                               if (v) then return () else ( error "Transactional invariant violation" ) )
07:02:17 * benmachine is not really sure what to do now
07:02:34 <absentia> invade a small country.
07:03:35 <eevar2> ^^ open a ticket and attach a patch
07:04:12 <ivanm> nah, I think absentia's suggestion is a better one
07:04:19 <benmachine> how about "have some lunch"
07:04:27 <ivanm> of course, I'm not sure how benmachine would be able to invade a country just by spotting a typo...
07:04:33 <benmachine> I think I am going to go with my suggestion
07:04:44 <ivanm> benmachine: but it's after midnight! why would you have lunch so late? :o
07:04:46 <ivanm> :p
07:05:02 <benmachine> ivanm: appropriateCourseOfAction :: Circumstance -> Action; appropriateCourseOfAction = const invadeCountry
07:05:13 <ivanm> benmachine: heh
07:06:05 <Twey> ivanm: In the land of bad spellers, the spell-checker is king.
07:06:21 <ivanm> or lynched
07:06:22 <ivanm> ;-)
07:06:32 <Twey> Why are there brackets around ‘v’ and the whole of the else clause?
07:07:03 <hackagebot> bindings-directfb 0.0.1 - Low level bindings to DirectFB (MauricioAntunes)
07:07:30 <kw317> I'm having problems installing GHC on snow leopard
07:07:36 <kw317> the installer just does not want to go forward
07:07:39 <kw317> :-/
07:07:43 <kw317> install button is grayed out
07:07:43 <ivanm> Twey: because
07:07:44 <ivanm> ;-)
07:07:52 <ivanm> kw317: yes, because it doesn't work
07:08:05 <hackagebot> convertible 1.0.6 - Typeclasses and instances for converting between types (JohnGoerzen)
07:08:12 <Twey> ‘Well, once upon a time, we were considering making Haskell a Lisp dialect…’
07:08:27 <kw317> ivanm: any fix for that?
07:08:27 <ivanm> ooohhhh, go on...
07:08:32 <ivanm> kw317: yes, don't use SL ;-)
07:08:47 <ivanm> 6.12 has some support for 6.12, but still doesn't work properly AFAIK
07:08:58 * ivanm should point out that he doesn't own anything to do with Apple...
07:10:35 <kw317> ivanm: too late, I've already upgraded my system :-(
07:11:52 <pozic> People who complain about Haskell, should program C.
07:11:59 <pozic> That will teach them.
07:12:19 * kw317 did few years of C programming for a living
07:12:20 <coilid> so it looks like benmachine can find an STM bug, fix it, and invade a small country, all before lunch...
07:12:31 <kw317> it's not that bad, just depends on what you want to do
07:12:48 <pozic> Read this and tell me how great C is: http://porn.quiteajolt.com/2007/11/05/initializing-a-struct-with-a-string-array-member-in-c/
07:14:14 <ivanm> coilid: well, he didn't say he actually ended up invading that country...
07:14:20 <Saizan> kw317: i'm sure there's a way to make ghc work on SL, maybe you can find more in the ghc-user@ mailing list archives
07:14:30 <Saizan> ghc-users@ actually
07:17:50 <coilid> pozic: given an understanding of how arrays in structures are laid out in memory, and how arrays-as-function-arguments is a lie-to-c-programmers, those code snippets all behaved how i'd expect ;-)
07:20:12 <JoePeck> kw317: try installing from source?
07:22:23 <patch-tag> can someone give me an example of a monad that is not an applicative?
07:22:58 <patch-tag> i just defined sequence as mysequence = foldr mcons (pure []) where mcons' m ms = (:) <$> m <*> ms
07:23:43 <patch-tag> which seems very nice to me, but it's sig requires arg to be Applicative as well as Monadic, and that got me wondering. Of course if I had used liftM and ap instead of <$> and <*> the type sig would be correct for monads.
07:23:51 <trzkril> patch-tag: some monads in haskell lack applicative instances
07:24:08 <trzkril> @where typeclassopedia
07:24:09 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:24:30 <trzkril> patch-tag: but every monad is an applicative functor, as described in the Typeclassopedia
07:25:18 <patch-tag> So does that mean that mysequence is essentially "correct" if the haskell libs were written a bit smarter?
07:26:02 <patch-tag> @t sequence
07:26:02 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:26:15 <patch-tag> no lambdabot, that is not what I meant.
07:26:40 <trzkril> @type sequence
07:26:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:26:52 <trzkril> @src sequence
07:26:53 <lambdabot> sequence []     = return []
07:26:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:26:53 <lambdabot> --OR
07:26:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:27:05 <patch-tag> yeah, or mine.
07:28:10 <trzkril> patch-tag: for a monad, you get an applicative setting pure = return and (<*>) = ap
07:30:21 <patch-tag> ah I think I see. my first comment I was thrown off by ghci suggesting mysequence had to be a monad, but when I commented out some code that stopped being the case.
07:30:41 <patch-tag> so, the answer is, sequence could very well be defined in terms of applicative in the prelude, I believe.
07:30:59 <patch-tag> with the definition I gave
07:31:41 <trzkril> @type foldr (liftA2 (:) (return [])
07:31:41 <lambdabot> parse error (possibly incorrect indentation)
07:31:53 <trzkril> @type foldr (liftA2 (:)) (return [])
07:31:54 <lambdabot> forall a (f :: * -> *). (Applicative f, Monad f) => [f a] -> f [a]
07:32:03 <trzkril> @type foldr (liftA2 (:)) (pure [])
07:32:04 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
07:32:05 <patch-tag> just do pure instead of return
07:32:13 <pozic> In C it appears that absolutely no effort was done to make life easier for the programmer.
07:32:20 <pozic>  wchar_t a[] = ""; doesn't work for example.
07:32:30 <pozic> No, you have to put an L before it.
07:37:23 <ziman> :t foldl (liftA2 (:)) (pure [])
07:37:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
07:37:24 <lambdabot>       Expected type: f a
07:37:24 <lambdabot>       Inferred type: f [a]
07:37:41 <ziman> :t foldr (liftA2 (:)) (pure [])
07:37:41 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
07:40:20 <byorgey> that ought to be named 'sequence', but for hysterical raisins sequence requires a Monad constraint.
07:40:32 <byorgey> @type sequenceA
07:40:33 <lambdabot> Not in scope: `sequenceA'
07:40:58 <byorgey> oh, sequenceA is in Data.Traversable
07:41:04 <byorgey> @type Data.Traversable.sequenceA
07:41:05 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
07:46:03 <trzkril> a bit more general even
07:47:55 <byorgey> indeed, lists are not the only traversable functor =)
08:00:39 <PeakerWork> > sequenceA $ Just [5]
08:00:40 <lambdabot>   Not in scope: `sequenceA'
08:00:45 <PeakerWork> > Data.Traversable.sequenceA $ Just [5]
08:00:46 <lambdabot>   [Just 5]
08:01:04 <PeakerWork> > let sA = Data.Traversable.sequenceA in sA . sA $ Just [5] :: Maybe [Int]
08:01:05 <lambdabot>   Couldn't match expected type `[[a]]'
08:01:05 <lambdabot>         against inferred type `Data.Ma...
08:01:32 <PeakerWork> @type let sA = Data.Traversable.sequenceA in sA . sA
08:01:33 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f, Data.Traversable.Traversable f, Applicative t) => f (t a) -> f (t a)
08:01:56 <PeakerWork> > let sA = Data.Traversable.sequenceA in sA . sA $ Just [5]
08:01:57 <lambdabot>   Couldn't match expected type `[[a]]'
08:01:57 <lambdabot>         against inferred type `Data.Ma...
08:01:57 <Berengal> Anyone here use Data.Text much?
08:02:14 <sioraiocht> Berengal: yes
08:02:25 <Berengal> I'm thinking about writing a parser using it, and wonder how it'd be like to iterate through
08:02:36 <sioraiocht> Berengal: what do you mean "iterate" through
08:02:48 <PeakerWork> ah, monomorphism restriction
08:02:59 <Berengal> sioraiocht, well, character by character. I imagine that's easy enough, but I'd also like some backtracking
08:02:59 <PeakerWork> > Data.Traversable.sequenceA . Data.Traversable.sequenceA $ Just [5]
08:03:00 <lambdabot>   Just [5]
08:03:37 <sioraiocht> Berengal: oh, I see what you mean.  Index based traversal wasn't the best option, but that might have changed
08:05:27 <Berengal> sioraiocht, since it uses utf16 internally, I can imagine indexing would be just as painful as on lists...
08:05:45 <Berengal> Except I can't really cut of the head either
08:06:03 <sioraiocht> Berengal: substring creation is free in Data.Text
08:06:18 <sioraiocht> well, constant time, anyway
08:06:21 <sioraiocht> including head and tail
08:07:00 <sioraiocht> but yes, the design of Text emphasise the collection rather than the elements
08:07:34 <Berengal> Indexing still looks like I'd have to use head . drop n
08:07:56 <sioraiocht> yeah, drop is a linear time
08:08:05 <sioraiocht> there used to be provisions for indexing, even though it was slow
08:08:22 <Berengal> Oh wait, I found it
08:08:27 <sioraiocht> okay
08:09:16 <Berengal> Still O(n)
08:09:21 <sioraiocht> thought so
08:09:46 <sioraiocht> there was talk about certain efforts to keep it linear for some cases, but I don't that was put in
08:11:18 <Berengal> I guess for parsing String might be fast enough, especially with a low lookahead count...
08:11:44 <sioraiocht> Berengal: is ByteString not an option i fyou need indexing?
08:12:13 <Berengal> sioraiocht, it would be, if it used Word32. I need unicode
08:12:25 <sioraiocht> Berengal: oh okay
08:12:37 <sioraiocht> what would string give you that text wouldn't?
08:13:21 <Berengal> String's still the best string implementation conceptually
08:13:30 <tolkad> Does haskell have an eval() function?
08:13:36 <burp> ew!
08:13:43 <Botje> tolkad: no.
08:13:47 <burp> eval is evil
08:14:03 <benmachine> it's called ghc?
08:14:10 <Botje> tolkad: lambdabot has an eval feature, although you probably don't want to use that trick.
08:14:44 <benmachine> ghc accepts -e
08:14:55 <burp> maybe you can build something with "libghc"
08:15:27 <Berengal> tolkad, there are libraries for that, but it's not for cheap tricks like in the P languages
08:15:35 <tolkad> benmachine: But that wont allow me to set variables in the current program's scope
08:18:20 <benmachine> tolkad: ...variables?
08:18:43 <benmachine> :P
08:18:49 <tolkad> yeah, like myvariable n = 37
08:19:55 <tolkad> Then (myvariable "whydoihavetoaddthis?")
08:19:56 <Berengal> I don't think you can give anything you eval the currently running program's scope anyway
08:19:57 <Twey> Haskell does not, on the whole, have variables.
08:21:02 <quicksilver> or, at least, it does but they aren't mutable.
08:22:22 <Botje> ~ a variable is just a constant you haven't met ~
08:22:38 <MyCatVerbs> Hi, my name is IORef, why are you all pretending that I do not exist?
08:23:04 <Berengal> MyCatVerbs, that's not a variable, that's a reference, and it's a value
08:25:27 <MyCatVerbs> Berengal: bah. The only difference between an IORef and "var x =" is that the latter case is second-class. :P
08:25:38 <Cale> Haskell has variables in exactly the sense that mathematics does
08:25:38 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:26:17 <Cale> When you write f x = x^2, the value of x may vary between applications of f.
08:26:20 <Berengal> Variables don't exist (at runtime)
08:27:58 <burp> call it variable or not, Cale said everything that has to be said ;)
08:31:03 <tolkad> > butt 0
08:31:04 <lambdabot>   "butt"
08:31:07 <tolkad> > butt 1
08:31:08 <lambdabot>   "buttbutt"
08:31:12 <tolkad> > butt 35
08:31:13 <lambdabot>   "buttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbuttbu...
08:31:17 <burp> very good ;D
08:31:39 <sproingie> lambdabot has a builtin butt?
08:31:47 <burp> @undefine butt
08:31:49 <burp> > butt 1
08:31:50 <lambdabot>   Not in scope: `butt'
08:31:52 <burp> ha ;)
08:31:52 <tolkad> <tolkad> @let butt n = if (n == 0) then "butt" else "butt" ++ butt (n - 1)
08:32:08 <sproingie> ah
08:32:17 <Baughn> burp: @undefine actually removes /every/ binding, and ignores parameters
08:32:23 <burp> oh, ok
08:32:28 <tolkad> @undefine *
08:32:43 <Baughn> @let foo = 42
08:32:44 <lambdabot>  Defined.
08:32:46 <Baughn> @undefine bar
08:32:48 <Baughn> > foo
08:32:49 <lambdabot>   Not in scope: `foo'
08:32:52 <tolkad> ah
08:32:59 <burp> @let butt n =  concat . replicate n $ "butt"
08:33:00 <lambdabot>  Defined.
08:33:11 <tolkad> butt 5
08:33:15 <tolkad> > butt 5
08:33:16 <lambdabot>   "buttbuttbuttbuttbutt"
08:33:25 <Baughn> @let but = concat . flip replicate "but"
08:33:26 <lambdabot>  Defined.
08:33:31 <Baughn> > but 13
08:33:33 <lambdabot>   "butbutbutbutbutbutbutbutbutbutbutbutbut"
08:34:18 <profmakx> is either one of the xmpp libraries on hackage in some sort of active development?
08:46:04 <ckiesch> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>----.>+++++++++++++++++.-..
08:46:04 <lambdabot>   Butt
08:46:37 <tolkad> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>----.>++++++++++++++++++.-..
08:46:37 <lambdabot>   Bvuu
08:46:58 <tolkad> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>----.>++++++++++++++++++.-...+>>.<+++<
08:46:59 <lambdabot>   Bvuuu
08:47:19 <tolkad> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>----.>++++++++++.....<++++>>>>>>>>++++++++++++++++++.-...+>>.<+++<
08:47:19 <lambdabot>   Bnnnnn
08:47:23 <trzkril> > ord 'B'
08:47:23 <lambdabot>   66
08:47:34 <trzkril> > ord 'u'
08:47:35 <lambdabot>   117
08:47:49 <tolkad> > ord '?'
08:47:49 <lambdabot>   63
08:48:10 <tolkad> > map 5 [1,2]
08:48:11 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:48:11 <lambdabot>    `GHC.Num.Num a' arising f...
08:48:44 * benmachine defines a fromInteger of type Integer -> a -> a just to screw with people
08:48:55 <ckiesch> @bf ++++++++++[>++++++++++<-]>--.+++++++++++++++++++.-..
08:48:55 <lambdabot>   butt
08:48:57 <ckiesch> Shorter :)
08:49:12 <tolkad> Does haskell have goto?
08:49:12 <burp> hehe
08:49:20 <trzkril> @bf +++++++++++[>++++++<-].
08:49:21 <lambdabot>  Done.
08:49:25 <tolkad> @bf []
08:49:26 <lambdabot>  Done.
08:49:28 <trzkril> @bf +++++++++++[>++++++<-]>.
08:49:28 <lambdabot>   B
08:49:31 <benmachine> tolkad: it has CPS which I'm told can do some of the same things?
08:49:34 <ckiesch> @bf
08:49:34 <burp> tolkad: if you want goto look at Cont monad
08:49:34 <lambdabot>  Done.
08:49:36 <benmachine> @bf +[]
08:49:41 <lambdabot>  Done.
08:49:45 <tolkad> what about comefrom?
08:49:51 <trzkril> > 117 - 66
08:49:52 <lambdabot>   51
08:50:01 <burp> comefrom? doesn't that esoteric language have that? ;)
08:50:08 <trzkril> intercal
08:50:11 <burp> right
08:50:24 <tolkad> python has comefrom
08:51:01 <trzkril> > 66 * 2
08:51:02 <lambdabot>   132
08:51:13 <tolkad> > 2.2 * 2
08:51:14 <lambdabot>   4.4
08:51:14 * int-e loved the idea behind threaded intercal
08:51:26 <tolkad> > e
08:51:27 <lambdabot>   e
08:51:32 <tolkad> > a
08:51:33 <lambdabot>   a
08:51:35 <trzkril> @bf +++++++++++[>++++++<-]>.[>++<-].
08:51:35 <lambdabot>   B
08:51:39 <trzkril> @bf +++++++++++[>++++++<-]>.[>++<-]>.
08:51:40 <lambdabot>   B
08:52:14 <tolkad> > sum [1,2,3]
08:52:15 <lambdabot>   6
08:52:29 <tolkad> > sum [1,.5...]
08:52:30 <lambdabot>   <no location info>: parse error on input `]'
08:52:31 <int-e> > toEnum (fromEnum 'B' * 2) :: Char
08:52:32 <lambdabot>   '\132'
08:53:07 <tolkad> > sum [1,.5,.25...]
08:53:08 <lambdabot>   <no location info>: parse error on input `]'
08:53:13 <tolkad> > sum [1,.5,.25..]
08:53:14 <lambdabot>   <no location info>: parse error on input `..'
08:53:36 <Botje> tolkad: perhaps you want to play with lamdabot in a /query or just on a local ghci install?
08:53:44 <tolkad> lol sorry
08:54:21 <tolkad> anyway, how would I make a list like that? 1, .5, .25, .125 etc
08:54:44 <Raevel> > iterate (/2) 1
08:54:45 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
08:54:52 <tolkad> thanks!
08:55:25 <tolkad> > sum (iterate (/2) 1)
08:55:30 <lambdabot>   mueval: ExitFailure 1
08:55:36 <burp> > sum $ takeWhile (/=0) $ iterate (/2) 1
08:55:37 <lambdabot>   2.0
08:56:02 <Gilly_> well that's a trick :P
08:56:25 <burp> in fact this doesn't converge, does it?
08:56:36 <TabAtkins> Yeah it does.  To 2.
08:56:44 <burp> hm, ok
08:56:49 <Gilly_> it does :)
08:57:12 <TabAtkins> Now sum the harmonic series.  ^_^
08:57:14 <Baughn> Meaning it never actually reaches 2. No matter what \bot claims.
08:57:16 * Baughn frowns
08:57:38 <TabAtkins> Baughn: No, it converges to 2.  And, within floating point error, reaches it within finite time.  ^_^
08:57:54 <Baughn> TabAtkins: Well, I didn't claim it didn't /coverge/ to two. :P
08:58:08 <burp> > showCReal 10 $ sum $ takeWhile (/=0) $ iterate (/2) 1
08:58:10 <lambdabot>   "2.0"
08:58:14 <burp> > showCReal 100 $ sum $ takeWhile (/=0) $ iterate (/2) 1
08:58:16 <lambdabot>   "1.999999999999999999999999999999999999999997130140745062774638748201813422...
08:58:20 <TabAtkins> Hair-splitting on what "reaches" means is usually reserved for people trolling math forums, though.
08:58:52 <burp> > showCReal 100 $ sum $ iterate (/2) 1
08:58:59 <lambdabot>   mueval: ExitFailure 1
08:59:00 <burp> no need for takeWhile there, no?
08:59:04 <Gilly_> well, any of the finite sums sum(1/2^n, n, 1, N) is not 2.
08:59:14 <pozic> Dijkstra rolls over in his grave while reading "tests as proof of correctness".
08:59:20 <tolkad> > (iterate (1/n!) 1)
08:59:23 <lambdabot>   The operator `GHC.Arr.!' [infixl 9] of a section
08:59:24 <lambdabot>      must have lower prece...
08:59:32 <Gilly_> and I guess that's what we are talking about when we speak of "reaching"
08:59:47 <tolkad> > (iterate (1/n!) 0)
08:59:48 <lambdabot>   The operator `GHC.Arr.!' [infixl 9] of a section
08:59:49 <lambdabot>      must have lower prece...
09:00:01 <Gilly_> tolkad: ! isn't a factorial
09:00:09 <TabAtkins> Reaching in finite steps, sure.  But it's really not useful to talk about an infinite series doing anything in finite steps.
09:00:24 <burp> why did my version with takeWhile work, but the other one didn't terminate?
09:00:27 <tolkad> > (iterate (1/(factorial n)) 0)
09:00:28 <lambdabot>   Not in scope: `factorial'
09:00:39 <TabAtkins> burp: Because you're trying to sum an infinite list.
09:00:44 <Gilly_> tolkad: use "product [1..n]"
09:00:57 <TabAtkins> While the takeWhile version produces a finite list (due to floating-point precision).
09:00:58 <burp> TabAtkins: but takeWhile shouldn't get any zeroes
09:01:05 <burp> TabAtkins: but I took CReal
09:01:21 <tolkad> @let factorial = product [1..n]
09:01:24 <lambdabot>  Defined.
09:01:27 <tolkad> @let factorial n = product [1..n]
09:01:28 <lambdabot>  <local>:5:0:
09:01:28 <lambdabot>      Multiple declarations of `L.factorial'
09:01:28 <lambdabot>      Declared at: <...
09:01:35 <tolkad> @undefine factorial
09:01:38 <tolkad> @let factorial n = product [1..n]
09:01:39 <lambdabot>  Defined.
09:01:43 <tolkad> > (iterate (1/(factorial n)) 0)
09:01:44 <lambdabot>   Couldn't match expected type `a -> a'
09:01:44 <lambdabot>         against inferred type `Simple...
09:01:54 <Gilly_> TabAtkins: well - the infinite series is actually the limit of those finite sums :P so in certain sense it makes sense to talk about them
09:01:55 <TabAtkins> burp: You take CReal after the point that takeWhile is calculating, though.
09:02:08 <TabAtkins> Patch it in earlier and it might go infinite again.
09:02:19 <burp> how can this be possible? there isn't any double -> CReal casting?
09:02:23 <burp> :t showCReal
09:02:24 <lambdabot> Int -> CReal -> String
09:02:32 <burp> > takeWhile (/=0) $ iterate (/2) 1 :: [CReal]
09:02:33 <lambdabot>   [1.0,0.5,0.25,0.125,0.0625,0.03125,0.015625,0.0078125,0.00390625,0.00195312...
09:02:53 <TabAtkins> count that list?
09:02:59 <burp> > length (takeWhile (/=0) $ iterate (/2) 1 :: [CReal])
09:03:00 <lambdabot>   139
09:03:09 <burp> o0. I don't understand it
09:03:13 <burp> > last (takeWhile (/=0) $ iterate (/2) 1 :: [CReal])
09:03:14 <lambdabot>   0.0
09:03:24 <TabAtkins> Which expression is that CReal annotation applying to?
09:03:45 <burp> it must be applying to everything, otherwise there would be some casting
09:03:53 <Baughn> The whole thing. :: is lowest-possible-precedence.
09:04:21 <coilid> > iterate (/2) 1 !! 140 :: CReal
09:04:22 <lambdabot>   0.0
09:04:25 <TabAtkins> Then it's still applying too late.  All the calculation has already happened, if I'm not mistaken.  Scope it more tightly to the iterate expression.
09:04:36 <burp> > showCReal 100 $ iterate (/2) 1 !! 140
09:04:37 <lambdabot>   "0.000000000000000000000000000000000000000000717464813734306340312949546644...
09:04:59 <burp> > (iterate (/2) 1 !! 140 :: CReal) == 0
09:05:00 <lambdabot>   True
09:05:03 <burp> isn't this strange?
09:05:18 <burp> well the documentation basically predicts this..
09:05:25 <burp> comparison of CReals is problematic :>
09:05:34 <TabAtkins> Okay, yeah, that's a little strange.  Haskell might still be applying a close-enough comparison for the number?
09:05:35 <coilid> > let x = iterate (/2) 1 !! 140 :: CReal; y = 0.0 in (y, x, x==y, showCReal 100 y, showCReal 100 x)
09:05:36 <lambdabot>   (0.0,0.0,True,"0.0","0.0000000000000000000000000000000000000000007174648137...
09:05:46 <tolkad> > pi
09:05:47 <lambdabot>   3.141592653589793
09:06:01 <coilid> looks like CReal's (==) is an inexact one. which i guess makes sense since otherwise it could only be _|_ or False
09:06:10 <burp> coilid: true
09:06:44 <aavogt> > showCReal 500 0
09:06:45 <lambdabot>   "0.0"
09:06:54 <aavogt> > showCReal maxBound 0
09:06:55 <lambdabot>   "* Exception: Negative exponent
09:07:12 <coilid> right, it compares to 40 digits
09:07:37 <coilid> (at least that's what the source code appears to be doing). i don't know which base that's in.
09:08:01 <coilid> > 10**41 + 1 == (10**41 :: CReal)
09:08:02 <lambdabot>   False
09:08:35 <quicksilver> > 10**40 + 1 == (10**40 :: CReal)
09:08:36 <lambdabot>   False
09:08:41 <grzegorz> Hi all. I just ran into a case where compiling with ghc using optimization (-O) makes the program run dramatically slower (4 sec vs 1.5 minutes)
09:08:44 <quicksilver> > 10**80 + 1 == (10**80 :: CReal)
09:08:44 <grzegorz> Is that a known issue???
09:08:45 <lambdabot>   False
09:08:52 <coilid> > length . takeWhile (\x -> x + 1 == x) $ iterate (*10) (1::CReal)
09:08:54 <lambdabot>   0
09:08:58 <coilid> > length . takeWhile (\x -> x + 1 /= x) $ iterate (*10) (1::CReal)
09:09:02 <lambdabot>   mueval-core: Time limit exceeded
09:09:05 <coilid> :(
09:09:05 <TabAtkins> quicksilver: Try inverting those.  I expect integer comparison stay exact.
09:09:10 <coilid> > length . takeWhile (\x -> x + 1 /= x) $ iterate (/10) (1::CReal)
09:09:14 <lambdabot>   mueval-core: Time limit exceeded
09:09:18 <aavogt> > 1e-41 == (1e41 -1 :: CReal)
09:09:19 <lambdabot>   False
09:09:41 <aavogt> > 1e-41 == (1e-41 -1 :: CReal)
09:09:41 <lambdabot>   False
09:09:47 <coilid> > length . takeWhile (\x -> x * 1.1 + 1 /= x + 1) $ iterate (/10) (1::CReal)
09:09:48 <lambdabot>   41
09:09:53 <coilid> there ya go :)
09:10:07 <coilid> > length . takeWhile (\x -> x + 1 /= 1) $ iterate (/10) (1::CReal)
09:10:09 <lambdabot>   42
09:10:21 <coilid> > showCReal . last . takeWhile (\x -> x + 1 /= 1) $ iterate (/10) 1
09:10:22 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:10:22 <lambdabot>    arising from a use o...
09:10:52 <coilid> > showCReal 100 . last . takeWhile (\x -> x + 1 /= 1) $ iterate (/10) 1
09:10:53 <lambdabot>   "0.00000000000000000000000000000000000000001"
09:10:58 <burp> hm yup
09:11:10 <coilid> > 1.00000000000000000000000000000000000000001 == (1 :: CReal)
09:11:11 <lambdabot>   False
09:11:16 <coilid> aww
09:11:23 <coilid> > 1.000000000000000000000000000000000000000001 == (1 :: CReal)
09:11:24 <lambdabot>   True
09:11:54 <burp> CReal shouldn't implement Eq :P
09:12:05 <coilid> > 1.000000000000000000000000000000000000000001 - 1 == (1 :: CReal) - 1
09:12:06 <lambdabot>   True
09:12:19 <coilid> > 0.000000000000000000000000000000000000000001 == (0 :: CReal)
09:12:20 <lambdabot>   True
09:12:45 <tolkad> > sum [1,2..]
09:12:54 <lambdabot>   mueval: ExitFailure 1
09:13:06 <TabAtkins> quit trying to make it sum infinite lists.  >_<
09:13:25 <coilid> > (1e-42 == (0 :: CReal), 1e-42 == (0 :: Double))
09:13:26 <lambdabot>   (True,False)
09:13:27 <tolkad> TabAtkins: It should be able to do it with some
09:13:39 <coilid> tolkad: not with 'sum'. check the documentation ;-)
09:13:40 <tolkad> TabAtkins: I learned it in my math class, you can sum some infinite lists
09:13:55 <tolkad> TabAtkins: no, I know you can sum that list I had before
09:14:17 <TabAtkins> Yes, [1, .5, .25, ...] can be summed.
09:14:31 <tolkad> yeah but when I tried it failed
09:14:34 <TabAtkins> But I don't know why you're even trying to sum [1, 2, ...]
09:14:35 <tolkad> it's a bug
09:14:53 <tolkad> > sum (iterate (/2) 1)
09:14:59 <coilid> tolkad: seriously. the documentation. it says: "The sum function computes the sum of a finite list of numbers."
09:15:00 <lambdabot>   mueval: ExitFailure 1
09:15:23 <tolkad> coilid: You can sum infinite lists to. Infinite lists can have a finite sum
09:15:33 <coilid> tolkad: not with sum.
09:15:35 <TabAtkins> No, it first died with syntax errors.  Then, when you did it with iterate, it's still just trying to sum an infinite list.  The compiler doesn't do a ratio test on the list to see if it can be summed.
09:15:35 <Elly> coilid: but the sum function can'tt
09:15:48 <Elly> er, that was directed at tolkad
09:16:11 <tolkad> Elly: no I know you can sum i
09:16:14 <tolkad> it*
09:16:21 <Elly> but the *sum function* can't
09:16:26 <TabAtkins> Summing an infinite list is, obviously, done quite differently from just adding all the arguments.
09:16:29 <Elly> like, I am entirely aware that you can do it,, mathematically
09:16:37 <Elly> but haskell's builtin sum function doesn't
09:16:44 <Elly> it is not a bug, it is the specified behavior
09:17:15 <coilid> tolkad: the 'sum' of an infinite list is not really a sum in any case, it's a limit. it's only written as a sum as a notational convenience
09:18:05 <tolkad> oh
09:18:14 <tolkad> > limit (iterate (/2) 1)
09:18:17 <lambdabot>   Not in scope: `limit'
09:18:34 <tolkad> someone should write limit
09:18:40 <Elly> go for it
09:18:42 <Elly> patches accepted!
09:20:00 <TabAtkins> Wouldn't be hard at all, if you can assume that the list is a geometric series or whatever.
09:20:40 <int-e> > fst . head . dropWhile (uncurry (/=)) . ap zip tail $ iterate cos 0
09:20:41 <pozic> I think someone already wrote that.
09:20:41 <lambdabot>   0.7390851332151607
09:20:52 <TabAtkins> Of course, this assumption isn't normally safe to make - the list could potentially suddenly change to something different after the 10000th element.  You'd have no way of telling, since you're not doing source-analysis, but rather just looking at a finished list.
09:20:53 <coilid> if you're given, say, the source code of the function which generated the list, then in general it's not computable
09:21:02 <pozic> Basically you can just connect to the integer sequences lib.
09:21:49 <pozic> I also think it would be an utterly pointless thing to do.
09:23:03 <burp> > limit $ iterate (/2) 1
09:23:04 <lambdabot>   2.0
09:23:29 <int-e> wah!
09:23:36 <TabAtkins> hehe
09:24:06 <tolkad> product [1..5]
09:24:12 <tolkad> > product [1..5]
09:24:13 <lambdabot>   120
09:24:14 <int-e> > fst . head . dropWhile (uncurry (/=)) . ap zip tail $ scanl (+) 0 $ iterate (/2) 1
09:24:15 <lambdabot>   2.0
09:24:17 <tolkad> > product [1..1000]
09:24:18 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
09:24:44 <tolkad> > factor
09:24:44 <lambdabot>   Not in scope: `factor'
09:24:56 <tolkad> There should also be a function to get prime factors
09:25:54 <MyCatVerbs> There should also be a function to set prime factors.
09:26:02 <ckiesch> http://www.haskell.org/haskellwiki/99_questions/31_to_41 there is a primeFactors function
09:26:05 <MyCatVerbs> It'd make crypto so much less troublesome.
09:26:22 <ckiesch> Though it is slow as suspected :)
09:27:16 <byorgey> tolkad: there are various libraries on Hackage with factoring functionality.
09:28:35 <yairchu> naming question: how would you call "Monad m => s -> ListT (StateT s m) a -> ListT m a"?
09:29:46 <int-e> @unmtl StateT s (ListT m a)
09:29:47 <lambdabot> err: `StateT s (m [a])' is not applied to enough arguments, giving `/\A. s -> m [a] (A, s)'
09:29:56 <int-e> @unmtl StateT s (ListT m) a
09:29:56 <lambdabot> s -> m [(a, s)]
09:30:04 <coilid> @unmtl ListT (StateT s m) a
09:30:04 <lambdabot> s -> m ([a], s)
09:30:28 <yairchu> mtl's ListT is broken
09:30:32 <yairchu> I mean ListT done right..
09:30:34 <coilid> @type evalStateT
09:30:35 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
09:30:44 <coilid> yairchu: is the type not the same?
09:30:50 <yairchu> no
09:30:50 <grzegorz> Hi all. I just ran into a case where compiling with ghc using optimization (-O) makes the program run dramatically slower (4 sec vs 1.5 minutes)
09:31:02 <int-e> yairchu: that's ListT (StateT s m) a -> StateT s (ListT m) a, up to isomorphism? So you commute something ...
09:31:05 <quicksilver> "ListT done right" is odd, though.
09:31:22 <yairchu> quicksilver: how so?
09:31:24 <quicksilver> aren't there other better non-determinism transformers? LogicT perhaps?
09:31:42 <quicksilver> yairchu: I don't recall. But Cale explained it to me once.
09:32:02 <quicksilver> It doesn't behave the way you would want a transformer version of the [] monad to behave.
09:33:13 <tomoj> is Net.HTTP.Base.parseRequestHead supposed to stop consuming lines when it gets done with the http headers?
09:33:35 <burp> grzegorz: seems noone currently here knows about such a thing, you might repeat it later or report a bug on ghc, or post in haskell-cafe mailing list
09:33:46 <yairchu> quicksilver: I put a version of ListT done right on hackage. one nice benefit of it over LogicT etc is that you can use the familiar list operations on it (http://hackage.haskell.org/packages/archive/List/0.2/doc/html/Data-List-Class.html)
09:34:28 <quicksilver> grzegorz: certainly worth a report.
09:34:28 <grzegorz> ok burp
09:34:40 <quicksilver> grzegorz: does your program use the IO monad as its main loop?
09:34:50 <tolkad> How would you do this in haskell? http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html?rel=html
09:35:12 <grzegorz> quicksilver, not sure I understand
09:35:13 <yairchu> quicksilver: for me it seems exactly how I would want a transformer version of the list monad to behave..
09:35:16 * quicksilver thinks that was a rather vague question on his part.
09:35:16 <tolkad> write a factory factory
09:35:31 <grzegorz> it has a main::IO ()
09:35:50 <quicksilver> grzegorz: does it look like http://hackage.haskell.org/trac/ghc/ticket/2284
09:36:10 <quicksilver> (try -fno-state-hack)
09:36:27 <mfwitten> After upgrading my packages on Arch Linux, I got the following: `ghc-pkg: unregistering X11-1.4.5 would break the following packages: xmonad-0.8.1 xmonad-contrib-0.8.1' Indeed, 1.4.5 is still listed by `ghc-pkg list', but I'm pretty sure Arch removed any relevant files. Is my system effectively broken now? (I'm running xmonad currently)
09:37:11 <mfwitten> I don't really know anything about haskell, so I was hoping someone here would have knowledge
09:37:22 <yairchu> int-e: good point. maybe I should make the function you suggest instead
09:38:24 <grzegorz> quicksilver: it uses smth like this: f <- getF, and the f function is later mapped over the input
09:40:21 <grzegorz> quicksilver: and -fno-state-hack has no effect
09:42:47 <quicksilver> grzegorz: ok. report a bug then. interesting.
09:43:26 <grzegorz> quicksilver: ok
09:54:16 <jokerGTA> gus does anyone know how to make list of function
09:54:26 <jokerGTA> i couldnt find online how to do that
09:54:37 <tolkad> [function1, function2, function3]
09:54:38 <Elly> :t [id, id, ...]
09:54:39 <lambdabot> parse error on input `]'
09:54:43 <Elly> :t [id, id, ..]
09:54:44 <lambdabot> parse error on input `..'
09:54:48 <Elly> hm, I did it wrong
09:54:52 <Elly> :t [id, id]
09:54:53 <lambdabot> forall a. [a -> a]
09:54:58 <Elly> list of functions!
09:55:50 <jokerGTA> then i can also make function that takes list of functions as paranmethars
09:56:04 <Elly> sure
09:56:07 <jokerGTA> cool
09:56:09 <jokerGTA> tx
10:05:34 <deech`> What is the best tool to create a screencast in the XMonad window manager?
10:05:52 <voker57_> recordmydesktop?
10:07:25 <deech`> voker57_: Does it offer the ability to zoom in and out of windows? This is useful so people can see what I am typing.
10:07:28 <__JN> Hello, I have a parsec question: I want "line = sepBy cell (char ';')" to also recognize the combination of ']' followed by '-' to be interpreted as a line separator, not just ';'. How would I do that?
10:08:15 <Botje> (char ';' <> string "]-")
10:08:18 <Botje> err
10:08:19 <Botje> <|> evne
10:08:29 <bd_> or `mplus` :)
10:08:33 <__JN> ah, great, than you!
10:10:11 <coilid> http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html?rel=html <-- can anyone make it through the description for this without their eyes melting?
10:11:39 <coilid> in any case, it seems like an awful lot of work for a 2-argument curried function :)
10:14:06 <quicksilver> Botje: that will break if "cell" ever has "]" as a first symbol though
10:14:12 <quicksilver> if I understand correctly.
10:14:34 <quicksilver> Parsec - The Parser Combinator Library Broken By Design.
10:14:56 <absentia> how is it broken (by design)?
10:15:04 <coilid> no backtracking by default
10:15:41 <coilid> ... which means that every rule needs to know whether it will be used in a context where backtracking is necessary
10:15:43 <absentia> hey, the starship enterprise always went forward, 'cuz they couldn't find reverse.
10:16:01 <coilid> finally i understand why it's called parsec
10:18:39 <quicksilver> makes it non-composable
10:18:49 <quicksilver> really annoying when you change grammars
10:19:22 <lament> is there anything better than parsec?
10:19:25 <absentia> wait, do guns kill people or do bullets?
10:19:27 <quicksilver> polyparse
10:19:33 <quicksilver> absentia: I thought it was rappers?
10:19:44 <absentia> (sorry, missend.. wrong channep)
10:20:30 <MyCatVerbs> quicksilver: have you been listening to Goldie Lookin' Chain?
10:20:33 <lament> absentia: internal bleeding and organ damage kills people
10:20:41 <Twey> Haskell don't kill people… monads do
10:21:00 <MyCatVerbs> lament: external bleeding, too.
10:21:22 <quicksilver> MyCatVerbs: certainly not, but I'm familiar with the song
10:21:29 <absentia> sudden deceleration syndrome?
10:21:32 <quicksilver> I smoked hip hop once but I didn't inhale.
10:22:54 <lament> hypovolemic shock, or a trauma to the heart/lungs/arteries/brain stem that stops the flow of oxygen to the brain, or catastrophic injury of the brain itself
10:23:54 <Ferdirand> life kills people.
10:25:38 <quicksilver> as ongoing processes, "living" and "dying" are actually the same thing.
10:25:47 <quicksilver> but I fear we have lost the topic somewhere
10:26:30 * absentia apologizes for the misdirection.
10:27:23 <ckiesch> To live your life you've got to lose it
10:27:25 <lament> quicksilver: that sounds wrong
10:27:35 <lament> i don't like that formulation
10:27:52 <absentia> like the guy in africa that cut off his own head to impress the women.
10:29:07 <Ferdirand> I want to give a 15min haskell presentation at my local LUG meeting this w-end. What should I talk about that has the highest chance of getting them addicted ?
10:29:34 <dons> multicore.
10:29:39 <lament> Ferdirand: show pretty code
10:29:44 <dons> no other lang has what haskell supports in this area.
10:29:57 <Ferdirand> lament: yes, but i'm afraid my difficulty metric has been biased
10:30:07 <Ferdirand> and I don't want to lose the audience too much
10:30:14 <lament> Ferdirand: for example http://www.cs.dartmouth.edu/~doug/powser.html
10:30:23 <absentia> ya, give me a url that will get me addicted to haskell
10:30:38 <absentia>  s/a/another/
10:30:39 <dons> here's some slides to start you off, http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
10:31:00 <Twey> Multicore, concurrency, laziness (qua automatic generators, UNIX pipes)
10:31:08 <benmachine> :t join (,) . join (,) . join (,) . join (,) . join (,)
10:31:09 <lambdabot> forall a. a -> (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))
10:31:34 <Ferdirand> that's the problem: I have thousands of pretty examples to show
10:31:39 <coilid> Ferdirand: infinite data structures?
10:31:47 <benmachine> :t foldr (.) id $ replicate 7 (join (,))
10:31:48 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b, b)
10:31:48 <lambdabot>       Expected type: b
10:31:48 <lambdabot>       Inferred type: (b, b)
10:31:51 <benmachine> :(
10:31:51 <lament> dons: i keep hearing about multicore and how cool it is. But I certainly don't see many seriously multicore consumer computers.
10:32:06 <lament> dons: other than the two core scenario: one core for the programs, one for the spyware
10:32:08 <Ferdirand> yet it has to fit in 15 minutes and be simple enough to be understandable by everyone. So i'll have to make cuts :(
10:32:15 <ckiesch> Its laz
10:32:15 <coilid> lament: isn't there some Sun machine with 64 hardware threads?
10:32:20 <ckiesch> lazy
10:33:10 <ghostman> freenode hast mich aufgrund meiner Einstellung  gebanned!
10:33:37 <coilid> lament: in any case i think the conventional wisdom is that the typical number of cores in a desktop machine will probably increase exponentially for a little while
10:34:20 <lament> mm billions of cores
10:38:14 * tibbe is trying to figure out the problem with network on OS X and GHC 6.12
10:38:21 <tibbe> it build with 6.10
10:38:28 <ghostman> You have been kicked from #fedora by fedbot (as requested.)
10:38:37 --- mode: ChanServ set +o mauke
10:38:38 --- mode: mauke set +b *!*@HSI-KBW-078-043-171-029.hsi4.kabel-badenwuerttemberg.de
10:39:37 --- mode: mauke set -o mauke
10:55:12 <jberryman> Is it possible to create a module that is just Control.Monad.State, with a different definition for bind? How would I do that with the imports, exports?
10:56:00 <Botje> quicksilver: (re the ] thing) woah. guess i was never bitten by that, then :)
10:57:19 <byorgey> jberryman: not really.  the problem is that instance declarations are global (by design), so there's no way to import the definition of the State data type and not the Monad instance.
10:57:35 <byorgey> jberryman: however, you could just make a newtype wrapper around State and then declare a Monad instance for the newtype.
10:57:36 <cwraith> You could newtype it, though
10:58:12 <byorgey> jberryman: out of curiosity, what would be the different definition for bind?
10:59:19 <jberryman> byorgey: thanks. and i'm not telling!
10:59:25 <byorgey> hehe
10:59:54 <jberryman> byorgey: no, actually I want to play with a parallel state monad. i don't know if that makes sense yet though.
11:00:56 <coilid> @type let State f >>= g = State $ \s -> let (a, s'') = f s'; (b, s') = runState (g a) s in (b, s'')  in  (>>=)
11:00:57 <lambdabot> forall s t a. State s t -> (t -> State s a) -> State s a
11:01:01 <byorgey> what's a parallel state monad?  And how does that associate, (parallel state) monad, or parallel (state monad)?
11:01:03 <coilid> ^^ there's another bind :)
11:01:28 <byorgey> oh, the backwards time travel state monad =)
11:01:33 <coilid> yep :)
11:01:52 * coilid ponders what happens if you mix that with the normal state monad
11:02:01 <coilid> or rather the normal (>>=)
11:02:03 <Twey> Woah.  Cool.
11:02:17 <coilid> Twey: you think that's cool? you should see my fifo monad :)
11:02:21 <Twey> I think it's a parallel-state monad.
11:02:29 <Twey> Oh?
11:02:45 <Twey> I'm listening :þ
11:02:48 <coilid> it has a 'push' and a 'pop', but no requirement that values are pushed before they're popped
11:02:58 <Twey> Hahaha, nice
11:03:06 <coilid> you can trivially build the forward and the reverse state monad out of it :)
11:03:08 <mauke> you should see my positronic variables
11:03:15 <byorgey> oh yeah, I remember that, it's pretty slick =)
11:03:15 <mauke> it's kind of like backwards ST
11:03:24 <Twey> So a pop before a push just gets the next value to be pushed?
11:03:28 <coilid> yeah
11:03:28 <__JN> I have a parsec question again: when using the function noneOf, i.e. noneOf ";,\t", is it possible to use strings instead of chars? if I want to match the combination of ']' followed by '-', not the chars individually.
11:03:32 <mauke> (credit for the idea: damian conway)
11:03:43 <Twey> And if no values are pushed, nothing happens?
11:04:01 <jberryman> lol. monadic pissing contest.
11:04:04 <coilid> if no values are pushed, your program breaks and you get to keep both halves
11:04:11 <Twey> That really is pretty cool.  It's like a FORTH monad: you can build up a little stack-based program, and then pass it a bunch of values.
11:04:12 <byorgey> both these examples give the lie to the misconception that "monads are about sequencing"
11:04:29 <Twey> coilid: Hahaha
11:05:45 <Twey> mauke: O.O
11:06:20 <mauke> http://mauke.ath.cx/stuff/haskell/posi.hs
11:06:22 <FunctorSalad> byorgey: what? it's a lie!?
11:06:41 <byorgey> FunctorSalad: of course it is.  monads don't guarantee sequencing, data dependencies do.
11:07:20 <FunctorSalad> byorgey: ok you mean evaluation sequencing?
11:07:21 <byorgey> it just so happens that many standard monads (IO, State) use some sort of token-passing to guarantee ordering.
11:07:25 <byorgey> FunctorSalad: right.
11:07:53 <FunctorSalad> I was thinking of some different sequencing but I'm not sure what ;)
11:08:18 <byorgey> __JN: I don't understand.  You want to say, "match any string except one of these particular strings"?
11:08:40 <FunctorSalad> doesn't every monadic function define a sequence of binds?
11:08:42 <byorgey> __JN: if you want to NOT match one particular string you can use 'notFollowedBy'
11:09:28 <byorgey> FunctorSalad: yes, just like every arithmetic operation defines a sequence of numbers with arithmetic operators between them.  so what? =)
11:10:19 <FunctorSalad> hmm
11:10:42 <dons> lament: you could get a 64 hardware thread Sparc T2
11:10:48 <mauke> oh, the module is in http://mauke.ath.cx/stuff/haskell/Positronic.hs btw
11:10:53 <__JN> byorgey: hmm, well I want to match any chars, that dont appear in that combination...
11:10:59 <jberryman> byorgey: can you show me what wrapping a newtype around State would look like? feeling a bit dense
11:11:11 <byorgey> jberryman: sure, just a second
11:11:24 <byorgey> __JN: how many chars? exactly two?
11:11:49 <FunctorSalad> any recommendations where I can find some instructive examples for these left kan extensions?
11:11:58 <__JN> in this case yes
11:11:58 <FunctorSalad> (math examples are fine too)
11:12:26 <byorgey> __JN: in that case you can just say   noneOf "]" >> noneOf "-", yes?
11:14:00 <__JN> byorgey: ok, it's that simple? then noneOf ";!\r\n" <|> noneOf "]" >> noneOf "-" would work?
11:15:05 <byorgey> jberryman: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10691#a10692
11:15:09 <byorgey> jberryman: does that help?
11:15:46 <byorgey> __JN: not quite, that would match ']' even if it is followed by '-'
11:15:59 <jberryman> byorgey: thanks a bunch. I see now.
11:16:16 <byorgey> so you'd probably want something like  char ']' `notFollowedBy` "-" <|> noneOf ...
11:16:35 <byorgey> but really you probably want an honest-to-goodness lexer =)
11:21:48 <__JN> byorgey: ok, I'll try going that way, thank you. The file "format" I'm trying to parse is not very nice to work with...
11:29:00 <cwraith> Let me ask this again, 8 hours later: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10685#a10685 <-- The instance is in Control.Monad.Exception.Synchronous.  Why can't GHC find it?
11:34:39 <ksf> conal, http://ignorethecode.net/blog/2009/10/13/10_gui/
11:38:37 --- mode: ChanServ set +o mauke
11:38:37 --- mode: mauke set -b *!*@HSI-KBW-078-043-171-029.hsi4.kabel-badenwuerttemberg.de
11:39:37 --- mode: mauke set -o mauke
11:41:09 <dons> finished up the EDSL position paper, http://www.galois.com/blog/2009/10/13/domain-specific-languages-for-domain-specific-problems/
11:41:10 <yitz> ksf: a version issue perhaps?
11:42:14 <ksf> err, what issue?
11:43:00 * conal looks
11:43:01 <ghostman> banned me, i don`t know why! on this Channel! ;)
11:43:44 <conal> ksf: thx!
11:43:59 <tolkad>  <ghostman> freenode hast mich aufgrund meiner Einstellung  gebanned!
11:43:59 <tolkad> * ghostman (n=ghostman@HSI-KBW-078-043-171-029.hsi4.kabel-badenwuerttemberg.de) has left #haskell (requested by mauke)
11:43:59 <tolkad>  * mauke sets ban on *!*@HSI-KBW-078-043-171-029.hsi4.kabel-badenwuerttemberg.de
11:43:59 <tolkad> <ghostman> You have been kicked from #fedora by fedbot (as requested.)
11:44:13 <tolkad> oops
11:44:17 <tolkad> wrong order there
11:44:25 <tolkad> but yeah he said those two things and then got banned
11:44:56 <mauke> ok, stop pasting into the channel
11:47:03 <cwraith> hmm.  maybe my problem is that I shouldn't be using the explicit-exceptions package?
11:47:09 <cwraith> Has anyone used it successfully?
11:49:19 <tuukkah> dons, do you have the criterion scripts for adaptive-containers somewhere?
11:49:20 <cwraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10694#a10694 <-- The simplest possible example of ExceptionalT failing from ghci
11:51:22 <dons> tuukkah: hmm. i'll check them in.
11:51:53 <tuukkah> dons, thanks :-)
11:52:11 <dons> tuukkah: in darcs now, http://code.haskell.org/~dons/code/adaptive-containers/tests/Bench2.hs
11:52:44 <dons> what are you interested in?
11:53:30 <tuukkah> dons, i want to test the graph summary feature i wrote
11:53:34 <conal> ksf: wow!
11:53:38 <dons> great.
11:53:49 <cwraith> Agh.  It's an incompatibility between mtl and explicit-exception.
11:54:22 <cwraith> But I want the RWS monad from mtl.
11:54:25 <__JN> byorgey: can you help me some more?, I can't get this parsec thing right ->  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4364#a4364
11:54:40 <cwraith> I guess this means...  Give up RWS or give up explicit-exception
11:55:38 <monochrom> (random suggestion without reading the context) does ErrorT over RWS help?
11:55:55 <cwraith> No.  I don't want to use an instance of Error
11:56:36 <yitz> dons: nice
11:57:31 <yitz> dons: i know it's only a position paper, but the claim that a language being functional makes it easier to write edsls in will certainly be challenged
11:58:05 <dons> any debian users know why there was a big spike in xmonad installs on debian, http://is.gd/4hUp6
11:58:28 <dons> yitz: i don't think i claim FP makes it easier to write EDSLs
11:58:47 <dons> i do claim haskell has particularly good support though (e.g. overloaded syntax, ADTs, monadic overloading)
11:59:12 <dons> yitz: so yes, i'll need to be careful
11:59:15 <yitz> truth is, i used to write them in perl. it was actually very easy. but of course, the results were orders of magnitude harder to use, and impossible to verify
11:59:51 <dons> i'm in particular thinking of 'true' EDSLs. deep embeddings with type checking
11:59:58 <dons> not just "well designed APIs"
12:00:58 <yitz> dons: "A high-level functional language such as Haskell makes it easier to construct domain-specific functions"
12:01:26 <edwardk> haskell makes for very sexy EDSLs. And to be honest, if you can't fully express the EDSL in haskell's surface syntax you can always fall back on using quasiquoters.
12:01:48 <dons> yitz: ah ok. well, yes, i do argue that. the context is deep embeddings though.
12:01:51 <yitz> dons: perhaps replace "functional" here with a few buzz words that say why haskell is good for this
12:01:52 <dons> :)
12:02:05 <edwardk> I do think the functional notation (juxtaposed application) helps reduce the clutter in your EDSL though.
12:02:25 <yitz> edwardk: that's true. but it's probably not the major point.
12:02:26 <cwraith> So, is there any particular exception package that people like?  (I'm not a fan of ErrorT and MonadError, due to not liking the Error typeclass)
12:02:27 <sw17ch> dons: good paper
12:03:14 <sw17ch> Have there been papers written about when to start thinking about implementing an EDSL?
12:03:17 <dons> sw17ch: cheers. slightly different emphasis than our V&V stuff, but i think this route is also sound.
12:03:25 <edwardk> other fiddly bits like tail call elimination help with getting robust embeddings for some bits and pieces. in the end the use of a functional language can be important if your EDSL needs any sort of 'binder' construct.
12:03:39 <sw17ch> dons: definitely.
12:03:40 <edwardk> HOAS makes for a very clean way to add binders to your language.
12:03:58 <edwardk> lambdas, foralls, logic variable introduction, etc.
12:04:06 <Elly> I just got to surprise someone with haskell in a job interview
12:04:17 <sw17ch> dons: I'm giving a presentation on EDSLs+Haskell in November for the Great Lakes Software Excellence Conference in Grand Rapids. I'm really appreciating all the recent material showing up on the topic. :)
12:04:33 <dons> great. yes, i try to link to good related work.
12:04:36 <dons> there's a lot of stuff though.
12:04:57 <yitz> edwardk: but that's only convincing if you've started out to begin with the goal of a functional edsl. there are other tools for imperative ones.
12:05:22 <yitz> Elly: as the interviewer or interviewee?
12:05:37 <Elly> interviewee
12:05:51 <Elly> the person asked me to implement a bunch of operations on binary trees and I did it in haskell
12:05:52 <sinelaw> conal, if you're there, i'd like to know what you can say about erlang vs. frp
12:05:56 <Elly> and they were like "???"
12:06:07 <yitz> Elly: what was the effect?
12:06:23 <sw17ch> I've seen plenty of information about the value of EDSLs, but very little about how to formalize your "domain" enough to be able to implement a useful EDSL
12:06:25 <Elly> "I was going to ask you how you deal with accidentally-cyclic trees, but it appears that you can't..."
12:06:27 * ksf thinks every single module is an edsl
12:06:28 <yitz> wide eyes? wrinkled forehead?
12:06:36 <sw17ch> which, as it turns out, is the piece of my presentation i'm having a hard time with
12:06:44 <ksf> but I'm coming from scheme, so that's cultural heritage.
12:06:47 <edwardk> yitz: well, for the latter i was thinking more in terms of logic or constraint programming.
12:06:59 <yitz> ok
12:07:45 <davidL> dons: you will be at UIUC this weekend?
12:09:39 <cpettitt> Is there a way to fold over a chain of `ap` functions? It seems likely, but I haven't found the magic combination.
12:09:42 <cpettitt> I have this: get = return MacAddress `ap` gW8 `ap` gW8 `ap` gW8 `ap` gW8 `ap` gW8 `ap` gW8
12:10:00 <cpettitt> it seems like it would be nice to replicate all of those gW8's and fold over them
12:10:04 <sw17ch> cpettitt, i think there are "liftA5" functions
12:10:07 <Twey> Elly: There's no such thing as a cyclic tree… every body knows that!  :þ
12:10:08 <ksf> :t ap
12:10:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:10:18 <ksf> :t foldM
12:10:19 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:10:22 <sw17ch> :t liftA3
12:10:23 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:10:24 <Elly> Twey: if you do it in C with pointers there is :P
12:10:33 * Twey chuckles.
12:10:41 <sw17ch> :t liftA6
12:10:42 <lambdabot> Not in scope: `liftA6'
12:10:45 <sw17ch> :t liftA5
12:10:46 <lambdabot> Not in scope: `liftA5'
12:10:48 <sw17ch> :t liftA4
12:10:49 <lambdabot> Not in scope: `liftA4'
12:10:53 <monochrom> I deal with accidentally wrong code by fixing the code!
12:10:54 <sw17ch> :t liftA3
12:10:55 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:11:31 <cpettitt> cool, I'll look at using foldM with `ap`. I'm struggling with Monads still :) thanks for the help
12:12:00 <dons> davidL: yep.
12:12:03 <dons> speaking on saturday
12:12:31 <dons> http://www.acm.uiuc.edu/conference/2009/speakers/stewart.html
12:12:39 <davidL> dons: I'll see you there :)
12:12:49 <dons> cool!
12:14:18 <Itkovian> evening
12:17:27 <Itkovian> anybody has a general chunks :: Int -> [a] -> [[a]] lying around?
12:18:34 <conal> sinelaw: hi.  just saw your msg.  hm.  erlang & frp.
12:18:55 <conal> sinelaw: i've never thought about relating them.  do you have some thoughts?
12:20:06 <tuukkah> dons, looks like this now: http://tuukka.iki.fi/tmp/data.adaptive.list.replicate-densities.png
12:20:40 <yitz> Itkovian: let groupsOf n=takeWhile(not.null).map(take n).iterate(drop n)
12:21:00 <Itkovian> Thx.
12:21:02 * Itkovian bows
12:21:06 <yitz> > let groupsOf n=takeWhile(not.null).map(take n).iterate(drop n) in groupsOf 3 [1..10]
12:21:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
12:21:39 <dons> tuukkah: that looks cool
12:23:59 <tuukkah> dons, am i perhaps doing something wrong though, as the adaptive one looks slower... i had to remove the CPP stuff, as the tests need to be run in the same process
12:25:59 <blackh1> Hey, is there a way to make a library function deprecated so GHC gives a warning?
12:26:25 <ketil> blackh1, there's a pragma, I think.
12:26:30 <dons> tuukkah: i think replicate is slower (well, i've not tried to tune it yet)
12:26:47 <ketil> {-# deprecated f #-} maybe?
12:27:01 <dons> blackh1: mark as {-# DEPRECATED "reason" #-}
12:27:19 <ketil> dons: Is your paper only one page?  Or is it a preview?
12:27:26 <ketil> (the EDSL one)
12:27:40 <dons> its a position paper, so yep, only one page.
12:27:41 <blackh1> ketil, dons: Arigatoo gozaimasu
12:27:52 <dons> just trying to very quickly summarise a technical direction
12:28:35 <ketil> ah, okay.
12:28:44 <ketil> At least it makes for a quick read :-)
12:28:55 * ketil has a 1h flight tomorrow.
12:29:08 <ketil> But there's always the crossword, if all else fails...
12:29:55 <ksf> waaagh
12:29:58 <ksf> Loading package pcre-light-0.3.1 ... <command line>: can't load .so/.DLL for: pcre (/usr/lib64/libpcre.so: invalid ELF header)
12:30:06 <ksf> it's an ldd script.
12:31:52 <dons> sigh
12:31:58 <dons> ghci can't handle ld scripts
12:32:03 <dons> so you need to replacce them with symlinks
12:32:12 <ksf> ouch
12:32:18 <dons> it wouldn't be too hard to modify ghci's linker just enough to support the redirection
12:32:25 <dons> most of these ld things are simpler redirections anyway
12:32:33 <ksf> It's not even ghci, I guess, I'm trying to build pandoc. looks like TH.
12:32:49 <dons> ah
12:32:54 <dons> same thing. TH uses ghci
12:33:50 <ksf> well I'm going to pass on source highlightening, hoping that somebody is going to fix it before I need it.
12:34:03 <ksf> (I hate messing with files that portage manages)
12:35:27 <ksf> it will then, for example, fail to uninstall it as the mtime doesn't match.
12:39:29 <tuukkah> dons, nevermind, the result is only reproducible using runhaskell. by compiling the benchmark first, the performances are equal
12:42:55 <ksf> can I get gitit to spawn get firefox to spawn a vim instead of the default editor?
12:47:03 <iaefai_> :t unfoldM
12:47:04 <lambdabot> Not in scope: `unfoldM'
12:47:24 <iaefai_> I have some source code that I am trying to replicate that has an unfoldM, but I am not sure where to find it
12:47:42 <iaefai_> response <- unfoldM (recvChar s)    (from System.Hardware.Serialport)
12:48:04 <monochrom> @hoogle unfoldM
12:48:04 <lambdabot> No results found
12:49:07 <iaefai_> recvChar :: SerialPort -> IO (Maybe Char)
12:49:30 <iaefai_> so I guess I just want it to do it until it returns Nothing
12:49:44 <monochrom> Yes, that's my guess too.
12:50:34 <monochrom> Perhaps it accumulates and returns [Char] thus obtained.
12:50:42 <medfly> how do I load other files from my file? I seem to be having trouble with it
12:50:52 <iaefai_> I would have to write a function later, don't have time right now
12:51:58 <monochrom> "load other files from my file" seems to benefit from import, as in importing modules.
12:53:11 <medfly> it complains about "main.hs:3:7: parse error on input `operations'  (newline) Failed, modules loaded: none.", operations seems to load fine...
12:53:27 <medfly> when that line is import operations.hs
12:54:14 <monochrom> http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Compilation  has example of importing modules done right. Pay attention to filenames matching module names.
12:54:45 <monochrom> Pay attention to B.hs and M1.hs
12:55:47 <monochrom> Also, as per the language specification, module name with first letter in lowercase does not work.
12:56:28 <Saizan_> and the file name must match the module name case-sensitively
12:58:17 <monochrom> I thought every bloody tutorial hammers this thrice into reader's head already. (Except the gentle introduction but no one reads it anyway.)
12:59:27 <Twey> medfly: Nice to see you about again o/
12:59:32 <medfly> hi
13:00:48 <absentia> yay.. I did my first haskell program ... *Main> map fizzBuzz [1..100]
13:00:50 <absentia>   :-)
13:02:09 <ksf> great! now fix ghci's linker so I can compile pandoc with source highlightening.
13:02:25 <ksf> (no I'm not being sarcastic. I'm cynic.)
13:03:41 <medfly> Twey, I'm trying to figure out what the guys above said
13:04:13 <Twey> medfly: They said you need to have filenames that match your module names, which must start with upper-case letters.  ☺
13:05:04 <ksf> except if you're on a case insensitive FS.
13:05:27 <medfly> I changed the filenames so they start with an upper-case letter, and had a module something where in it, too. it still seems to make the same error.
13:05:32 <ksf> but I know of no significant OS that has those.
13:05:43 <cwraith> You say OS X isn't significant?
13:05:54 <ksf> to me, no.
13:06:12 <cwraith> even though it's the most-deployed consumer unix?
13:06:15 <ksf> things that claim to be unix and fail to be case sensitive: no, as a matter of principle.
13:06:53 <monochrom> In 2 weeks, it will be the 3rd annivesary of me adding that multiple-module blurb cited above. I see that during these 3 years civilization has not improved at all --- either writer's ability or reader's ability.
13:07:39 <iaefai_> I have a serial port on windows I am trying to use System.Hardware.Serialport on, but I am having trouble connecting to it. It says incorrect baud rate. It is generating a user error, is there a way I can catch this error so I can just try all of the baud rates?
13:07:56 <medfly> I'll just make it into one file...
13:07:59 <ksf> Control.Exception.
13:08:52 <ksf> though arguably the module shouldn't make you use it.
13:10:39 <ksf> monochrom, you see, people who are able to figure the module system out by themselves aren't the ones that ask many questions that could be regarded as faqs, so your perception of the distribution of users is skewed.
13:11:40 <ksf> remember: 90% of all questions get asked by 10% of the people.
13:11:50 <monochrom> People who are unable to figure the module system out by themselves can read my blurb written almost 3 years ago or any other adequate tutorial.
13:12:05 <gwern> monochrom: but do we really want such people?
13:12:12 <ehamberg> newtype HandleIO a = HandleIO { runHandleIO :: IO a } -- "we do the trick of exporting the type constructor [...] but not the data constructor" module declaration: "module HandleIO ( HandleIO , Handle , IOMode(..) , runHandleIO)"
13:12:16 <ehamberg> how *would* one export the data constructor in this case? (RWH, chapter 15, p 376)
13:12:20 <ksf> no, they can't. because you didn't describe how to find that tutorial.
13:12:28 <ksf> I'm dead serious.
13:12:57 <gwern> perhaps such people don't deserive to live, much less program in Haskell
13:12:58 <ksf> I've seen bug reports from official testers from three (the UK mobile carriers) saying "Help text doesn't describe how to open help"
13:13:04 <monochrom> In "either writer's ability or reader's ability" I did include the possibility of writer failure.
13:13:34 <monochrom> But I see that you are an example of reader failure.
13:13:43 <paolino> ehamberg: HandleIO (..) I think
13:13:57 <ksf> Them rejecting programs on the reason that they want to have "defence" along with "defensive", not "defense", is cute in comparison.
13:14:14 <sproingie> don't get so defencive
13:14:43 <ksf> well americans never complained about british spelling.
13:15:13 <monochrom> module HandleIO ( HandleIO(..) , Handle , IOMode(..))
13:15:15 <gwern> ksf: kerb your enthusiasm for the spelling of Britons!
13:15:23 <medfly> who cares.
13:15:44 <monochrom> module HandleIO ( HandleIO, HandleIO(HandleIO), runHandleIO, Handle , IOMode(..))  {- long way to show why -}
13:15:45 <ehamberg> paolino, monochrom: thanks.
13:15:46 <iaefai_> Is there an easy way of taking a number, such as 9600 and mapping it to the constructor B9600?
13:16:27 <ksf> Enum?
13:16:27 <monochrom> In HandleIO(HandleIO), the outer refers to the type, the inner refers to the data constructor.
13:17:21 <ksf> data Rate = B6900 | ... ; instance Enum Baud where ... toEnum 9600 = B9600
13:17:24 <gwern> iaefai_: wouldn't it make more sense to have a single B constructor and the ints be args?
13:17:40 <gwern> ksf: great, now do 0-6899...
13:17:40 <ksf> not if you want to succ to the next baud increment.
13:17:59 <ksf> there's no such baud rates.
13:18:07 <ksf> ...well at least not all of them.
13:19:03 <ehamberg> monochrom: the latter produces a warning: `HandleIO' is exported by `HandleIO(HandleIO)' and `HandleIO'
13:19:11 <ksf> dunno if there's a formula to them, though. in which case I'd recommend doing a mapping from [0..] to [lowestRate, nextRate, nextNextRate,...] algorithmically.
13:19:41 <monochrom> Then perhaps module HandleIO (HandleIO(HandleIO), runHandleIO, Handle , IOMode(..))
13:20:14 <ehamberg> yes, i tried that and that worked. :-)
13:20:41 <monochrom> I guess some things are considered too redundant.
13:21:15 <ksf> http://hackage.haskell.org/packages/archive/unix/2.3.2.0/doc/html/src/System-Posix-Terminal.html#BaudRate
13:21:27 <ksf> ...doesn't look like anything algorithmic.
13:22:00 <iaefai_> gwern: I am talking about a constructor set that is already defined in the library I am using
13:22:08 <ksf> you can derive Enum and Bounded for it, though, start with B0 and then succ your way up from minBound to maxBound
13:22:23 <ksf> I guess that's more sensible than using ints.
13:22:28 <iaefai_> I want to create a command line parameter to convert to an int and then convert that to the correct constructor
13:23:12 <ksf> you can do that automatically with some TH magic, but it's not worth the bother in this case.
13:23:49 <iaefai_> I am willing to make a list like [(0, B0), (50, B50), ...] but need the function to map it properly
13:24:00 <ksf> ah.
13:24:08 <ksf> @hoogle lookup
13:24:09 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:24:09 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
13:24:09 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
13:24:16 <ksf> ...use any of them.
13:25:02 <ksf> ...you can equally well do it with pattern matching, though.
13:26:04 <iaefai_> lookup sounds great
13:26:18 <iaefai_> now to take a commandline parameter and convert it to int, then I will be set
13:26:21 <ksf> you can convert your [(a,b)] to those map types with fromList
13:26:42 <ksf> > read "32" :: Int
13:26:43 <lambdabot>   32
13:26:46 <ksf> > read "foo" :: Int
13:26:47 <lambdabot>   * Exception: Prelude.read: no parse
13:26:52 <ksf> that's the quick and dirty way
13:27:56 <ksf> uh.
13:28:23 <ksf> you can also do instance deriving Read BaudRate and have your users pass "B2400"
13:28:46 <iaefai_> that would be simpler
13:28:50 <iaefai_> my user is myself :P
13:29:22 <ksf> well, in _that_ case, you could just fire up your source in ghci and call a function manually, passing the constructor.
13:29:48 <ksf> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
13:31:11 <ksf> ...not worrying about command line processing is usually a good design descision.
13:32:01 <ksf> as, if you've got that ghci-function, you can use it unchanged if you happen to do arg parsing, anyway.
13:32:38 <iaefai_> forgive my ignorance, but I forget the exact syntax of instance deriving
13:33:23 <iaefai_> doing just instance deriving Read BaudRateinstance deriving Read BaudRate   gives me a parse error
13:33:31 <iaefai_> it thinks incorrect indentation
13:33:43 <ksf> er deriving instance, that way round
13:33:48 <ksf> ...see the link I posted.
13:34:09 <monochrom> haha
13:34:43 <ksf> you have to pass -XStandaloneDeriving to ghc or put {-# LANGUAGE StandaloneDeriving #-} at the top of your file, too.
13:36:02 <iaefai_> ok, I got it to compile
13:36:07 <iaefai_> I had another issue in there
13:39:00 <iaefai_> What was the function for getting command line arguments? I cannot find it in the hierarchy list with a common name
13:39:38 <ksf> getArgs
13:39:45 <ksf> import System iirc
13:40:10 <ksf> @hoogle getArgs
13:40:10 <lambdabot> System.Environment getArgs :: IO [String]
13:41:11 <iaefai_> merci
13:41:18 <iaefai_> I appreciate all the help btw
13:41:30 <ksf> oh no bother
13:41:45 <ksf> that's all part of our secret plan to dominate the world
13:42:25 <iaefai_> I maintain that this channel is the most friendliest and forgiving programming channel
13:42:51 <ksf> all part of our plot.
13:48:56 <Philonous> How can I tell emacs not to change the directory when I invoke inferior-haskell-load-file ?
13:49:41 <iaefai_> Is there a way I can set the parameters to a ghci module so I can test getArgs?
13:49:51 <mauke> @hoogle withArgs
13:49:52 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
13:50:17 <aavogt> or :main
13:53:15 <iaefai_> ok, it seems everything was for naught. No valid baudrate works, but echo ready >COM1: will work, so is there something I can use to output to the com port and be able to input it as well?
14:03:02 <mreh> does the class Ord have some default implementation of it's methods that you fall back on, like show just prints the data type, does Ord just compare a value to the order in which it's constructor was declared?
14:03:52 <mauke> yes
14:04:17 <iaefai_> sweetness, it works now, just had to upgrade serialport
14:04:28 <mreh> mauke, yes to all of that?
14:04:47 <mauke> yes
14:04:57 <mreh> :|
14:06:20 <sinelaw> @seen Peaker
14:06:21 <lambdabot> Unknown command, try @list
14:06:22 <sinelaw> @seen PeakerWork
14:06:23 <lambdabot> Unknown command, try @list
14:06:40 <sinelaw> garboji.
14:07:18 <mauke> preflex: seen Peaker
14:07:18 <preflex>  Peaker was last seen on #haskell-blah 11 hours, 5 minutes and 59 seconds ago, saying: FunctorSalad, you described a generic tree, if you just rename Fun and Var to Branch and Leaf :-)  If you use an existing tree rather than rewriting the ADT you can re-use lots of code
14:09:21 <FunctorSalad> mreh: "Show" doesn't have a default unless you add a deriving clause either
14:09:28 <FunctorSalad> and you can derive Ord too
14:10:25 <mreh> so it makes it up, it has pseudo methods
14:11:26 <sshc> what is the '!' operator?
14:11:39 <sshc> I usually see it in data declarations
14:11:53 <monochrom> You guessed right about "deriving Ord". It just uses the order of the data constructors you wrote.
14:12:12 <monochrom> ! is not an operator. It is syntax to request strictness or eager evaluation.
14:12:44 <monochrom> http://www.vex.net/~trebla/haskell/strict-field.xhtml  is a short description.
14:13:28 <gwern> anyone have a link to where harrop admits he trolls to stir up interest in his wares?
14:13:35 <monochrom> Hrm I should change "lazily" to "nonstrictly". It fits my consistency.
14:14:17 <ketil> gwern, did I miss something recent on the list?
14:14:19 <ketil> :-)
14:14:31 <gwern> ketil: no, there's a clueless redditor wondering why all the hate for harrop
14:14:53 <ketil> monochrom, ! is an operator too - array dereferencing.
14:15:00 <monochrom> oops
14:15:06 <ketil> (but not in data declarations :-)
14:15:13 <ksf> ! doesn't make things strict, it evaluates to whnf
14:15:53 <ksf> it's just syntactic sugar for seq
14:16:03 <mreh> does anyone know a haskore interface for some score setting software, otherwise i'll just render the midi and convert
14:16:30 <ksf> there's only one score setting software, and it's called lilypond
14:16:39 <mreh> disregard my last question
14:16:47 <mreh> oh,
14:17:06 <gwern> lilypond does have disadvantages though
14:17:19 <gwern> we wanted to use it on wikipedia, but no one knew how to make it safe
14:17:37 <mreh> is it safe?
14:17:43 <ksf> well you'd have the same problem with tex
14:17:50 <jjardon> hello, what is the latest gtk version supported by gtk2hs ?
14:17:51 <ksf> ...or any other turing-complete thing.
14:18:00 <gwern> ksf: apparently tex is easier to sandbox or support a limited subset of
14:18:01 <jjardon> http://haskell.org/gtk2hs/
14:18:04 <gwern> since we do have tex support
14:18:09 <dcoutts> jjardon: it should work with any version of gtk+
14:18:19 <dcoutts> jjardon: since gtk+ itself is backwards compatible
14:18:24 <mauke> gwern: hey, there are people running perl code over irc
14:18:25 <FunctorSalad> turingcompleteness doesn't imply unsafeness
14:18:27 <mreh> wikipedia seems to be maintained by a hardcore of about 20 people
14:18:39 <monochrom> I have come to terms with "strict" being relative. It no longer stands for "strict to all the way down", but rather "strict just down to a suitable depth, to be clarified upon request but usually you won't request anyway". It is like "tall"; "wow Magic Johnson is tall!" does not mean he extends all the way to the edge of the solar system.
14:18:39 <mauke> there must be a way
14:19:01 <gwern> FunctorSalad: you think nontermination is safe?
14:19:03 <dcoutts> jjardon: of course it doesn't bind the full API of later versions, so depends what you want/need
14:19:10 <jjardon> dcoutts, included 2.18? great (I'm updating http://www.gtk.org/language-bindings.html )
14:19:22 <mreh> or a glass of OJ the size of magic johnson
14:19:38 <FunctorSalad> gwern: resource limits?
14:19:48 <dcoutts> jjardon: it depends on what question you're asking, "does it work" vs "does it have full API coverage"
14:19:50 <ksf> resource limits are a hack
14:19:53 <gwern> then it's not turing complete, I think...
14:20:04 <FunctorSalad> true ;)
14:20:09 <ksf> strictly speaking, yes, that, too.
14:20:16 <jjardon> dcoutts, full API coverage
14:20:26 <jjardon> see the table in the page ;)
14:20:51 <monochrom> safe tex is safer than safe sex
14:21:19 <gwern> and besides, safe doesn't just mean it terminates in a reasonable amount of time, it means that you can't say generate JS that will infect a visitor's browser and execute attacks
14:21:36 <dcoutts> jjardon: right, in my experience the coverage is good enough
14:22:24 <ksf> though it's quite hard to embed js into a png
14:22:30 <ksf> ...and postscript should be quite safe.
14:22:33 <gwern> bah, I bet dons would know what email I'm talking about
14:22:49 <gwern> but I don't have the patience to remember to ask him later and go back and reply
14:23:11 <ksf> actually, js should be as safe as ps, but that's a whole different problem.
14:23:17 <jjardon> dcoutts, so, can I mark 2.18 as "supported"?
14:24:14 <dcoutts> jjardon: it depends what it is supposed to mean
14:26:55 <dcoutts> jjardon: there are functions from gtk+-2.12 that are bound.
14:27:07 <dcoutts> and plenty from 2.10
14:29:41 <sproingie> man.  crazy day for security alerts
14:29:49 <sproingie> patch tuesday strikes again
14:29:59 <monochrom> you mean windows updates?
14:30:15 <sproingie> well for me it's symantec TMS alerts
14:30:27 <jjardon> dcoutts, as I'm not an expert in haskell, how do you fill the columns? 2.10  and 2.12 partially supported? what about 2.14, 2.16 and 2.18?
14:30:42 <sproingie> mostly a curiosity, i'm on the antispam side, not ids or AV
14:31:41 <dcoutts> jjardon: the binding will work with those versions of gtk of course. It does not bind any of the new function added in 2.14+
14:32:28 <hackagebot> hexpat 0.10 - wrapper for expat, the fast XML parser (StephenBlackheath)
14:33:14 <dcoutts> jjardon: I don't know what that page means by "not supported" or "partially supported".
14:33:54 <mreh> how am i supposed to load a .tex file into haskell? its literate haskell but it doesn't like it
14:34:04 <jmcarthur_work> .lhs
14:34:20 <jjardon> dcoutts, yeah, a bit confusing, will ask in #gtk
14:34:21 <mreh> ha, okay
14:34:30 <dcoutts> jjardon: thanks
14:44:33 <deech`> Is there some way to alphabetize a list of strings that have accents and diacritics in them. For example I want "Acai" and "Áçai" to be equal.
14:45:39 <monochrom> Does "alphabetize" mean "sort"? Does "alphabetize" mean "transform"?
14:45:46 <deech`> monochrom: sort
14:46:33 <Wupdeedo> I've been trying to implement a simple gui program using gtk2hs where you should be able to move a box around using a few buttons. The problem is that I can not figure out how to keep track of the state needed for the actual moving.
14:46:45 <Wupdeedo> anyone know how to do this?
14:46:51 <monochrom> write a function that maps "Áçai" to "Acai". some combination of sortBy, comparing, and that function will do.
14:47:09 <ksf> there shouldn't be a need to do that.
14:47:21 <ksf> in the Ord instance of Char both A's should be smaller than B
14:47:37 <ksf> well, hopefully.
14:48:08 <monochrom> > compare 'Á' 'A'
14:48:09 <lambdabot>   GT
14:48:16 <ksf> it's gonna be hard, anyway. should alpha count as a?
14:48:44 <deech`> Currently ["Acai", "Balloon", "Áçai", "Zygote"] are sorted as ["Acai", "Balloon", "Zygote", "Áçai"].
14:49:16 <mreh> uh, all the haskell in my pdf is Black
14:49:38 <medfly> use something that supports syntax highlighting
14:49:41 <mreh> black blocks, that's how latex has rendered it
14:49:49 <ray> deech`: you want to write your own comparison function
14:49:54 <monochrom> > sortBy (comparing abs) [ -10, 2 ]
14:49:55 <lambdabot>   [2,-10]
14:50:06 <mreh> medfly: my document viewer?
14:50:26 <monochrom> This example illustrate how to sort numbers except "I want to use magnitude, ignore +/-"
14:50:29 <ray> deech`: the standard ordering for Char is code point number
14:51:09 <ksf> it'd be great to have a library of Char newtypes that have other Ord instances, though.
14:51:10 <deech`> ray : How write a function that accents something? For example how do I write a function that given "A" outputs "
14:51:11 <ray> possibly, someone's got a library for that kind of sorting, but i haven't seen it
14:51:33 <monochrom> And so sortBy (comparing f) [ "Acai", "Áçai", "B" ] will work if you write f.
14:51:41 <deech`> ray : How write a function that accents something? For example how do I write a function that given "A" outputs  ["Ä","Ã",...]
14:52:10 <ray> well, you could just append the combining accent characters
14:52:15 <monochrom> And to write f I guess you have to enumerate all possible cases and treat them one by one tediously.
14:52:41 <ray> i do not know exactly what unicode provides
14:52:41 <ksf> it should be possible to partly autogenerate that out of unicode info, though.
14:53:01 <medfly> wiktionary could help you.
14:53:05 <ksf> it's CAPTIAL LETTER A [WITH ACCENT <FOO>] and such stuff.
14:53:12 <monochrom> f s = map g s where g 'Ä' = 'A'; g 'ç' = c; ... etc.; g c = c
14:53:31 <medfly> http://en.wiktionary.org/wiki/Appendix:Variations_of_%22a%22
14:54:11 <ray> combining accent
14:54:43 <ray> U+20E0 COMBINING ENCLOSING CIRCLE BACKSLASH
14:54:55 <ksf> those aren't the same as pre-combined code points.
14:55:04 <SimonRC> ksf: unless you normalise
14:55:06 <ksf> but I _bet_ there's a library to translate those.
14:55:22 <SimonRC> there is a formal normalising algo, I think
14:56:47 <sproingie> there's several
14:56:57 <ray> there are 4 normal forms
14:57:46 <ray> compatibility equivalence is less relavent here, but canonical equivalence means that "those aren't the same as pre-combined code points" isn't exactly true
14:58:09 <sproingie> does normalizing decompose ligatures too or just combining characters?
14:58:33 <ray> i think it depends on the normal form
14:58:51 <SimonRC> I am not sure, but I think Java requires pre-combined CPs to be considered different from combining-character-based ones.  Oh dear me
14:58:55 <ray> compatibility decomposition would decompose ligatures
14:59:18 <sproingie> they are different codepoint sequences when not normalized, yes
14:59:42 <ray> ﬀ is compatibility equivalent to ff, but canonically not equivalent
15:00:09 <sproingie> it makes for lots of happy fun attacks for systems that accept unicode data but don't normalize it
15:00:20 <sproingie> e.g. users with identical names
15:00:52 <ray> "latin small a with grave accent" is canonically equivalent to "latin small a" followed by "combining grave accent"
15:01:03 <ray> it's not the simplest concept ever
15:01:30 <deech`> ray: Yikes!
15:02:25 <sproingie> text has always been more complicated than strings of bytes.  not all codebases have woken up to that reality
15:02:45 <Neriooz> am i able to filter the maximum function, so it hands out only max values bellow 9?
15:03:02 * ksf thinks Data.Text urgently needs all those functions
15:03:03 <sproingie> strings of bytes or even strings of Chars that is
15:03:11 <ksf> ...and we need a new default string type
15:03:20 <SimonRC> Neriooz: what would (max [11]) be?
15:03:23 <Vanadium> Neriooz: What is it supposed to return when the max value is above 9?
15:03:25 <deech`> I am a noob at the Unicode thing. Is there a document on "How to make a character" or some such thing?
15:03:33 <SimonRC> and what about (max [2,11])?
15:03:43 <SimonRC> deech`: "make a character"?
15:03:43 <Vanadium> 9? Nothing?
15:03:49 <sproingie> http://www.joelonsoftware.com/articles/Unicode.html
15:03:51 * ksf recommends Data.Text with a modified viewL that returns a : constructor.
15:04:10 <ksf> (as a typeclass, so it can be reused for lists)
15:04:18 <deech`> SimonRC: Yeah, how to transform a "c" into a "ç" etc.
15:04:26 <jmcarthur_work> reactive is AGPL now :(
15:04:27 <ksf> ...then allow to define a default view patter on a per-type basis.
15:04:27 <byorgey> Neriooz: sure, just write your own function that calls maximum and then does whatever it wants with the result.
15:04:39 * jmcarthur_work glares at conal
15:04:40 <jmcarthur_work> ;)
15:05:25 <Neriooz> well it is like this, im checking a list of (Int),(Int) and i want to hand out the maximum value of them like maximum [(2,3),(4,3)] will output (4,3) but if it is maximum [(2,3),(9,3)] it will output (2,3) since i just want maximum of values bellow 9
15:05:35 <ksf> I think the thing conal wanted was something like an ALGPL
15:05:41 <mreh> what's highlighted my syntax if the input to lex were just plain .lhs files?
15:05:43 <ksf> or not.
15:05:55 <byorgey> Neriooz: what about [(2,3), (9,4)] ?
15:06:08 <Zao> filter first?
15:06:12 <mreh> s/latex/lex/
15:06:17 <Neriooz> if thats the input i want to filter the 9, so it will output (2,3)
15:06:18 <mreh> doi!
15:06:18 <jmcarthur_work> ksf, he's not happy with it
15:06:33 <ksf> licensing is a bitch.
15:06:38 <jmcarthur_work> ksf, "GNU AGPLv3 license (see COPYING). I am not thrilled with GPL. If you would like different terms, please talk to me."
15:06:40 <Neriooz> [(9,3),(2,3),(5,6)] will handout (5,6)
15:06:41 <jmcarthur_work> yeah it is
15:06:41 <Zao> @type Data.List.filter
15:06:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:06:48 <byorgey> Neriooz: well, just filter the list first, and then call maximum.  But you'll have to decide what to do if the list is empty after you filter it.
15:07:11 <jmcarthur_work> he wants something that fosters innovation and sharing and fairness, but he also wants to be able to make some money with it somehow
15:07:19 <jmcarthur_work> a tough combination
15:07:23 <byorgey> > filter ((<9) . fst) [(9,3), (2,3), (5,6)]
15:07:24 <lambdabot>   [(2,3),(5,6)]
15:07:32 <medfly> did someone ask for http://en.wikipedia.org/wiki/Comparison_of_software_licences
15:08:01 <ksf> medfly, have a look at conals blog, there's been a quite long discussion about it.
15:08:30 <ksf> ...the outcome was dual-licensing AGPL and commercial
15:08:32 <jmcarthur_work> medfly, http://conal.net/blog/posts/seeking-advice-on-software-licensing/
15:09:49 <medfly> mreh, yeah... I'm not sure what you're doing... if you want syntax highlighting, you gotta have something that supports it :s
15:10:07 <Vanadium> Is there any reading on Data.Text or is it p. much a drop in replacement for String with varying complexities?
15:10:17 <Neriooz> thanks for the tips i'll try it out
15:10:24 <mreh> i didn't ask for syntax highlighting!
15:10:32 <jmcarthur_work> mreh, i don't know why it's appearing black, but maybe you should peek at something like lhs2tex
15:10:38 <conal> jmcarthur_work: i chose AGPL as an invitation to dialog.
15:10:46 <sioraiocht> Vanadium: that's the idea
15:11:01 <jmcarthur_work> mreh, maybe your latex environment needs a command defined for the code tag?
15:11:05 <sioraiocht> Vanadium: just be aware that it's using an array, and that substrngs are formed from said arra
15:11:10 <sioraiocht> *array*
15:11:28 <jmcarthur_work> conal, i can't criticize a hard decision i didn't have to make
15:11:47 <conal> jmcarthur_work: thx.  i dislike gpl, and i don't think i'll stick with it for long.
15:13:02 <jmcarthur_work> conal, i would totally pay you to work on reactive under the bsd license if i could afford it ;)
15:13:03 <mreh> jmcarthur_work, the funny thing is, if i highlight it with my cursor, the text is there
15:13:15 <conal> jmcarthur_work: heh
15:13:17 <mreh> i have no experience with latex
15:13:45 <monochrom> turn off syntax highlighting
15:13:46 <mreh> what is a latex anyway
15:13:58 <mreh> monochrom: thx for the suggestion
15:14:16 <monochrom> a notation for generating printed articles
15:14:30 <sproingie> google for "latex fetish", you'll find several fans of it
15:14:44 <mreh> you dont pronounce it like that
15:14:54 <sproingie> i know, but you spell it like that
15:14:56 <monochrom> has nicety for math-heavy articles
15:15:02 <sproingie> unless you're knuth
15:15:15 <mreh> yeah, actually i've seen it, my lecturers all produce their homework sheets in latex
15:15:17 <kw317> hmm.. anyone succeeded in installing ghc on snow leopard? I can't get the installer to work :-(
15:15:42 <kw317> there's a lot of stuff on various issues with SL on the web, but nothing about non-working installer
15:15:55 * aavogt loves types!
15:16:10 <skorpan> eww
15:17:40 <Wupdeedo> anyone who can help with a gtk2hs/state problem?
15:18:12 <sm> I wonder how to bridge php to haskell (php calling haskell)
15:19:49 <SubStack> grr, install.sh of ghc installer should just do $(which strip) instead of this STRIPPROG business that doesn't seem to work
15:22:11 <SubStack> stale binutils...
15:23:28 <jvoorhis> kw317: i've gotten the haskell platform to work on snow leopard
15:24:27 <kw317> *sigh* it works now
15:24:36 <kw317> I needed to re-install xcode for some reason
15:24:43 <jvoorhis> odd
15:24:47 <kw317> but there were no error messages and anything!
15:24:52 <jvoorhis> did you patch the executables?
15:24:53 <kw317> after reinstalling works just fine
15:24:56 <kw317> *or
15:24:58 <kw317> jvoorhis: nope
15:25:03 <kw317> jvoorhis: that's the next step
15:25:05 <kw317> what do I do?
15:25:19 * jvoorhis looking for the ticket about that
15:26:45 <ksf> Vanadium, not a plain array, though, it's a fingertree (iirc, otherwise a list) of word16 arrays
15:27:15 <jvoorhis> kw317: http://hackage.haskell.org/trac/ghc/ticket/2965#comment:24
15:29:13 <jvoorhis> kw317: iirc you'll want to patch at least ghc, ghci and hsc2hs – i can't remember if it's needed for runhaskell too
15:29:31 <kw317> jvoorhis: cool, thanks
15:30:13 <jmcarthur_work> ksf, what would the measure of the fingertree be? length?
15:30:47 <ksf> I guess so... I think the reason is viewR.
15:30:50 <jvoorhis> kw317: good luck
15:31:14 <ksf> (a look at the source replaces much guessing)
15:31:28 <jmcarthur_work> heh
15:31:39 <ksf> oh. length is O(n)
15:33:14 <ksf> ...it works like bytestrings
15:33:59 <ksf> but I guess fingertrees would be a good idea, too. possibly with larger bucket size.
15:34:03 <mreh> i returned this googling for a solution to my problem: http://www.campmor.com/outdoor/gear/Product___19821
15:34:29 <jmcarthur_work> ksf, iirc, there was talk about *wrapping* it in a finger tree, but the core would be bytestrings
15:34:43 <jmcarthur_work> and this wrapped version would probably be yet another library
15:34:46 <ksf> but fingertrees already contain arrays.
15:34:53 <jmcarthur_work> huh?
15:35:01 <jmcarthur_work> not as far as i know
15:35:05 <ksf> those one to four element buckets
15:35:11 <jmcarthur_work> oh
15:35:19 <jmcarthur_work> i wouldn't call those arrays, really...
15:35:52 <jmcarthur_work> you have to change the constructor just to add an element to one of those, don't you?
15:36:05 <ksf> yep.
15:36:38 <ksf> but it's shared, anyway.
15:37:21 <ksf> the trick is rather to support both viewR and codata.
15:37:49 <ksf> ...the killer feature of fingertrees is O(log (min m n)) concat.
15:38:52 <jmcarthur_work> i dunno, i think the O(1) cons and O(1) snoc are nice too... and the memoized measure
15:39:02 <SubStack> oh even worse, /usr/bin/strip is hard-coded into the ghc binary build
15:39:06 <ksf> I think we should cut back on the prominence of lists, anyway.
15:39:12 * SubStack had to perl -pi -e's{/usr/bin/strip}{/home/substack/prefix/bin/strip}g' `grep '/usr/bin/strip' -lR .`
15:39:39 <ksf> most applications don't really need infinity, and those that don't are usually better served by using Sequence.
15:40:11 <jmcarthur_work> for really fast, short queues and such, Sequence has a bit more overhead than necessary
15:40:13 <ksf> ...and all the left-side functions are the same.
15:40:22 <ksf> so you can share e.g. foldr for both of them.
15:40:35 <jmcarthur_work> a common interface between the two would be nice
15:40:42 <SubStack> wow, amazingly that was all I needed for ghc to work
15:41:26 <ksf> ...and your strip is a link to /bin/true?
15:41:56 * ksf sets out writing a ghc ticket
15:42:16 <SubStack> my strip is from binutils 2.19
15:43:00 <ksf> default view patterns. so that you can share functions between two different types that both implement a class specifying a view, and don't have to manually mention that view.
15:43:01 <SubStack> since the system-wide strip from 2.17 on this system has this problem: http://osdir.com/ml/glasgow-haskell-users@haskell.org/2009-04/msg00044.html
15:43:41 <ivanm> is Roel van Dijk here?
15:48:23 * ksf rather waits until he did some code
15:53:53 <DrSyzygy> ?hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
15:53:54 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:54:03 <DrSyzygy> o.O
15:54:17 <DrSyzygy> Isn't there something in, say, Applicative or Arrow that does this?
15:54:32 <Neriooz> Hi, i need some help :) i want to use fromJust $ lookup Nothing ([[Maybe Int]]) works fine aslong as a [Maybe Int] doesnt contain any Nothing at all, how do i get passed this?
15:54:41 <FunctorSalad> DrSyzygy: (***)
15:54:45 <DrSyzygy> FunctorSalad: Thanks.
15:55:10 <Botje> use proper pattern matching instead of fromJust
15:55:40 <Neriooz> that cud be a good idea yes, any others?
15:55:55 <Saizan_> that doesn't make sense..
15:56:07 <Saizan_> Neriooz: what's the type of your lookup?
15:56:44 <Neriooz> Eq a => a -> [(a,b)] -> Maybe b
15:56:49 <FunctorSalad> no really, just don't use fromJust here
15:57:10 <Neriooz> but i use fromJust to find the Just values i thought
15:57:23 <Neriooz> it runs fine aslong as there is values of Just x and Nothing
15:57:34 <Neriooz> but if it is for example only Just it screwsup
15:57:44 <Neriooz> i like to make it stop looking for Nothing if there is no Nothing
15:58:15 <FunctorSalad> use a pattern match or fromMaybe
15:58:25 <FunctorSalad> or (maybe)
15:59:06 <Saizan_> ?type lookup Nothing (undefined :: [[Maybe Int]])
15:59:07 <lambdabot>     Couldn't match expected type `(Maybe a, b)'
15:59:07 <lambdabot>            against inferred type `[Maybe Int]'
15:59:07 <lambdabot>       Expected type: [(Maybe a, b)]
15:59:22 <Saizan_> (such a clear error message)
16:00:27 <FunctorSalad> :)
16:01:44 <FunctorSalad> idea for better error messages: dump all the specialisations made up to that point
16:02:32 <Neriooz> thanks for the tips, will try something out, if i wont be back your help helped me :d thanks
16:02:40 <Botje> oh, don't!
16:02:42 <Botje> come back and stay!
16:02:47 <Botje> this channel is fun!
16:02:55 <Neriooz> well, i meant alt tabbing back
16:02:57 <Neriooz> :)
16:03:05 <Botje> this is like #hottub, except with more lambdas
16:03:36 <cwraith> :t runState
16:03:37 <lambdabot> forall s a. State s a -> s -> (a, s)
16:03:37 <Saizan_> FunctorSalad: i was serious this time
16:04:52 <cwraith> > runState (modify (+1) >> return 5) 0
16:04:53 <lambdabot>   (5,1)
16:05:06 <pumpkin> runState is basically id
16:05:25 <FunctorSalad> it's teh record label
16:05:27 <cwraith> > runState (iterateM 5 $ modify (+1)) 0
16:05:28 <lambdabot>   Not in scope: `iterateM'
16:05:31 <monochrom> No way.
16:05:31 <cwraith> errr.
16:05:38 <cwraith> > runState (replicateM 5 $ modify (+1)) 0
16:05:38 <lambdabot>   ([(),(),(),(),()],5)
16:05:40 <pumpkin> is it actually a record label?
16:05:42 <pumpkin> @src State
16:05:42 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:06:16 <cwraith> > runState (replicateM 5 $ modify (+1) >>= last) 0
16:06:17 <lambdabot>   Couldn't match expected type `()' against inferred type `[a]'
16:06:21 <FunctorSalad> yes way http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-State-Lazy.html#v:State
16:06:28 <monochrom> Oh, I see what you mean. newtype State = State { runState :: ... }
16:06:34 <cwraith> > runState (replicateM 5 $ modify (+1) >>= return . last) 0
16:06:34 <pumpkin> nice
16:06:35 <lambdabot>   Couldn't match expected type `()' against inferred type `[a]'
16:06:46 <cwraith> oh, blah, I suck at operator precedence
16:06:56 <cwraith> > runState (replicateM 5 (modify (+1)) >>= return . last) 0
16:06:57 <pumpkin> cwraith: don't worry, we love you anyway
16:06:57 <lambdabot>   ((),5)
16:07:06 <cwraith> There.  That's what I really wanted to test
16:08:10 <cwraith> > execState (replicateM 5 (modify (+1)) >>= return . last) 0
16:08:11 <lambdabot>   5
16:08:20 <cwraith> There.  My new favorite expression for 5. :)
16:09:12 <DrSyzygy> Hmmm.
16:09:35 <DrSyzygy> ?hoogle (a -> b) -> (a -> c) -> a -> (b,c)
16:09:35 <lambdabot> No results found
16:10:07 <pumpkin> :t (&&&) :: (a -> b) -> (a -> c) -> a -> (b,c)
16:10:08 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
16:10:14 <pumpkin> \o/
16:10:18 <DrSyzygy> pumpkin: That's it?
16:10:22 <DrSyzygy> :t (&&&)
16:10:23 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:10:26 <pumpkin> noo
16:10:32 <pumpkin> don't look, it'll burn
16:10:32 <DrSyzygy> Awesome.
16:10:38 <cwraith> > ((*2) &&& (+5) 1
16:10:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:10:43 <cwraith> > ((*2) &&& (+5)) 1
16:10:44 <lambdabot>   (2,6)
16:11:19 <monochrom> hoogle doesn't locate (&&&) because (&&&)'s general type is too general.
16:11:26 <pumpkin> > unfoldr (Just . (id &&& succ)) 0
16:11:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:11:36 <pumpkin> \o/
16:12:07 <pumpkin> > unfoldr (Just . (id &&& succ)) LT
16:12:08 <lambdabot>   [LT,EQ,GT,* Exception: Prelude.Enum.Ordering.succ: bad argument
16:12:11 <pumpkin> :P
16:13:40 <sproingie> :t (***)
16:13:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:13:55 <kyagrd> > unfoldr (Just . (id &&& ((`mod` 3) . succ)) LT
16:13:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:13:59 <sproingie> damn if i can decipher that
16:14:04 <kyagrd> > unfoldr (Just . (id &&& ((`mod` 3) . succ))) LT
16:14:05 <lambdabot>   No instance for (GHC.Real.Integral GHC.Ordering.Ordering)
16:14:05 <lambdabot>    arising from a...
16:14:33 <kyagrd> doesn't work
16:14:37 <monochrom> To decipher, replace a by some special type constructor, for example (->)
16:14:48 <pumpkin> needz m0ar integralz
16:15:04 <monochrom> Example. (->) b c -> (->) b' c' -> (->) (b, b') (c, c')
16:15:12 <monochrom> Then rewrite in infix:
16:15:22 <pumpkin> > unfoldr (Just . (toEnum &&& ((`mod` 3) . succ))) 0 :: [Ordering]
16:15:23 <FunctorSalad> "a b c" is a ridiculously bad choice of var names
16:15:28 <lambdabot>   [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT...
16:15:35 <monochrom> (b->c) -> (b'->c') -> ((b, b')->(c, c'))
16:15:38 <FunctorSalad> in this context, that is
16:15:41 <monochrom> Now it should be clear.
16:16:23 <pumpkin> kyagrd: \o/
16:17:16 <monochrom> a stands for arrow, b and c are convention choices for domain and co-domain generic names. can't be better.
16:17:57 * anapumpkin is the master of the anamorphism!
16:18:01 <FunctorSalad> wobble b c -> wobble b' c' -> wobble (b,b') (c,c') would be clearer
16:18:10 <FunctorSalad> (anything)
16:18:43 <FunctorSalad> "a b c" gives the impression of an enumeration of peers
16:19:57 <cwraith> replace a with arrow, and it's already clearer
16:20:06 <monochrom> Let e be a group, let f be its identity element, let G be an endomorphism of e.
16:21:04 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10699#a10699
16:21:10 * ksf likes that
16:21:19 <ksf> ...the only wart is the view pattern in map'
16:21:27 <Philippa> I need a bidirectional map, is there anything I can do that's much saner than keeping a Data.Map in each direction?
16:21:41 <ksf> there's bimap on hackage
16:21:50 <ksf> ...which is exactly that, two maps.
16:22:18 <Philippa> so I may as well do that myself, given that the use is pretty localised. Oh well
16:22:38 * ksf would use the package
16:22:58 <ksf> except if it doesn't use sane maps, that is.
16:23:11 <ksf> ...which are, in general, all but Data.Map.
16:23:44 <Philippa> not currently that worried about performance, so hey
16:24:13 <ksf> oh there's a magnitude difference between Map and IntMap
16:24:45 <harrison> so, i was reading up on arrows yesterday. what's an (example of an) arrow that isn't a function?
16:24:58 <cwraith> @instances Arrow
16:24:59 <lambdabot> (->), Kleisli m
16:25:00 <FunctorSalad> harrison: Kleisli
16:25:16 <anapumpkin> harrison: not many of interest :P
16:25:22 <anapumpkin> harrison: there's a stream processor arrow on hackage
16:25:33 <anapumpkin> and some FRP arrow thingies, and an xml arrow
16:25:40 <FunctorSalad> Kleisli would be of much interest if the notation was less klunky
16:25:49 <anapumpkin> yeah, it's a pain
16:25:52 <FunctorSalad> (I conjecture)
16:26:38 <anapumpkin> ooh we have a saint
16:26:53 <Philippa> one of the first examples of an arrow in the wild was a self-optimising parser combinator lib
16:26:55 <cwraith> sounds like saint cyril's nemesis
16:27:21 <gwern> what
16:28:19 <cwraith> saint cyril introduced a system of writing to northern asia that greatly increased the flow of information.
16:28:29 <dolio> FunctorSalad: But Kleisli arrows are functions. :)
16:28:35 <gOcOOl> is there an optimal way of getting 2 separate lists as a result of filtering a single input list based on 2 different predicates? for instance, "let a = filter (predicate1) L" and "let b = filter (predicate2) L" will give me 2 lists a & b but that seems suboptimal as it walks the list L twice
16:28:44 <ksf> CC http://hackage.haskell.org/trac/ghc/ticket/3583#preview or your cat is going to run away!
16:29:05 <FunctorSalad> dolio: yeah I took him as "not the function instance"
16:29:29 <ksf> uhm cut out that #preview
16:29:41 <sproingie> @hoogle (a -> Bool) -> (a -> Bool) -> [a] -> [[a]]
16:29:42 <lambdabot> No results found
16:29:46 <sproingie> @hoogle (a -> Bool) -> (a -> Bool)
16:29:47 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
16:29:47 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
16:29:47 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
16:29:57 <harrison> looks like i should probably try again to understand what a monad is. i somehow doubt i'll be able to understand the kleisli arrow without that.
16:30:24 <anapumpkin> harrison: composition in Kleisli is just like <=<
16:30:47 <FunctorSalad> > (fmap . fmap . fmap) (<=<)
16:30:49 <lambdabot>   No instances for (Test.SmallCheck.Serial (f (f1 (f2 (b -> m c)))),
16:30:49 <lambdabot>         ...
16:30:52 <anapumpkin> harrison: for example, say you wanted to write a function that read a name from a file of your choice and then read the file of that name
16:30:58 <anapumpkin> :t readFile <=< readFile
16:30:59 <lambdabot> FilePath -> IO String
16:31:09 <aavogt> > let p = even; q = (0==) . (`mod` 10) in foldr (\x (a,b) -> ((guard (p x) >> [x])++a,(guard (q x) >> [x])++b)) [1..10]
16:31:10 <lambdabot>   Couldn't match expected type `([a], [a])'
16:31:10 <lambdabot>         against inferred type `[a...
16:31:18 <gwern> gOcOOl: just rewrite filter to use 2 predicates to return a 2-tuple
16:31:29 <aavogt> > let p = even; q = (0==) . (`mod` 10) in foldr (\x (a,b) -> ((guard (p x) >> [x])++a,(guard (q x) >> [x])++b)) ([],[]) [1..10]
16:31:30 <lambdabot>   ([2,4,6,8,10],[10])
16:31:32 <gwern> gOcOOl: easier than figuring out what bizarre combinator or library will do what you want
16:32:04 <aavogt> or just use two filters, and optimize later
16:32:16 <FunctorSalad> @type mapEither
16:32:17 <aavogt> since you might not have to
16:32:17 <lambdabot> Not in scope: `mapEither'
16:32:26 <gwern> aavogt: that works too
16:32:34 <gOcOOl> the list that I'll be filtering is rather large
16:32:38 <gwern> (nyuk nyuk nyuk)
16:32:50 <gwern> gOcOOl: eh, O(n), O(2n), it all comes out in the wash
16:32:54 <FunctorSalad> @type partitionEithers
16:32:55 <lambdabot> forall a b. [Either a b] -> ([a], [b])
16:33:06 <ksf> gOcOOl, are you sure your lists aren't fused, anyway?
16:34:04 <gOcOOl> ksf not sure I fully understand that question, sorry
16:34:11 <ksf> ...even if they aren't, it might be more straight forward to just switch the list implementation to stream-fusion
16:34:43 <coilid> ksf: fusion usually doesn't work like that
16:34:49 <gOcOOl> don;t know what stream-fusion is, but I'll look that up
16:34:50 <ksf> gOcOOl, filter f . filter g = filter (\x -> f x && g x)
16:34:54 <coilid> it tends to work best for a single pipeline
16:35:05 <ksf> that's a universial law, and it can be exploited.
16:35:17 <coilid> ksf: that doesn't do the same thing
16:35:20 <gwern> ksf: but he wants 2 different lists
16:35:20 <FunctorSalad> or you could just use a fold...
16:35:28 <ksf> mhhh yes. but nearly.
16:35:30 <gwern> he doesn't want one list containing everything matching both
16:35:32 <aavogt> ksf: but in this case it is more like   filter p &&& filter q
16:36:03 <coilid> gOcOOl: yeah, it can be done
16:36:13 <gwern> so if you filter through once and put everything matching pred1 as Left and everything matching pred2 as Right in your ultimate list, to get a 'pure' list you need to go back through the list again
16:36:18 <anapumpkin> :t \p q -> filter p &&& filter q
16:36:19 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> [a] -> ([a], [a])
16:36:22 <anapumpkin> zomg
16:36:37 <cwraith> it still traverses the list twice
16:36:42 <gwern> anapumpkin: wouldn't that be less efficient than a custom filter2?
16:36:46 <cwraith> which the original question wanted to avoid
16:36:55 <coilid> @type foldr (\x (xs,ys) -> (if ?pred1 x then x:xs else xs, if ?pred2 x then x:ys else ys)) ([],[])
16:36:56 <lambdabot> forall a. (?pred2::a -> Bool, ?pred1::a -> Bool) => [a] -> ([a], [a])
16:36:57 <anapumpkin> certainly, I was just looking at what aavogt said
16:37:01 <gwern> as I said, just write a ([a],[a]) function
16:37:08 <coilid> gOcOOl: ^^ that foldr is how i'd do it
16:37:09 <ksf> sure you have to traverse the list twice, you want to match the list twice and have two lists.
16:37:19 <aavogt> :t uncurry filter
16:37:20 <lambdabot> forall a. (a -> Bool, [a]) -> [a]
16:38:00 <cwraith> ksf, if can be done with one traversal, as the foldr shows
16:38:07 <ksf> ...if you only force one of the resulting lists, how else should be the second one produced except traversing the original, again?
16:38:28 <FunctorSalad> coilid: abusing implicit params as holes is a great trick =)
16:38:34 <gOcOOl> in an imperative language, i'd just loop through the list once and and append elements to the appropriate list based o the predicates
16:38:35 <coilid> FunctorSalad: :)
16:38:44 <ksf> you're destroying a list and piling up a list of thunks.
16:38:46 <gOcOOl> having a hard time converting that logic to haskell
16:38:48 <gwern> ksf: ? I can step through the original list with 2 tmp empty lists, shunt the current element into either tmp depending on the predicates, and return the ([a],[a]) of tmps; one traversal
16:39:10 <coilid> ksf: add in a bit of strictness and you just accumulate two lists
16:39:22 <ksf> but that won't work with codata.
16:39:31 <coilid> it has to be the /right/ bit of strictness
16:39:56 <coilid> you want forcing the n'th element of one of the lists to force the other list up to that point in the original list
16:40:10 <FunctorSalad> I'd use coilid's fold
16:44:06 <ClaudiusMaximus> > let filters ps xs = map concat $ transpose [ [ if p x then [x] else [] | p <- ps ] | x <- xs ] in filters [odd, even] [1..10]
16:44:06 <lambdabot>   [[1,3,5,7,9],[2,4,6,8,10]]
16:45:41 <sm> what are some ActiveRecord-ish tools for haskell ?
16:45:47 <ksf> mhh yeah that's perfect.
16:46:12 <gOcOOl> indeed, that's pretty much what i was looking for
16:46:16 <anapumpkin> sm: there's System.Posix for running ruby as a subprocess ;)
16:46:25 <sm> heh
16:46:35 <sm> I'm already wanting to run haskell as a subprocess of php
16:46:46 * coilid votes ClaudiusMaximus for president
16:47:04 <anapumpkin> ooh, this reminds me of that sparrow inside a chicken inside a duck inside a goose inside a swan inside an ostrich dish
16:47:07 <ksf> why would you want to use a turing-complete cat?
16:47:31 <sm> I can query tables with just HDBC, but there is going to be a *lot* of boilerplate
16:48:01 <gwern> anapumpkin: I like turducken better
16:48:40 <gwern> ack, why is there so much spam on the haskell platform bugtracker?
16:48:45 <sproingie> a bustard stuffed with a turkey, a goose, a pheasant, a chicken, a duck, a guinea fowl, a teal, a woodcock, a partridge, a plover, a lapwing, a quail, a thrush, a lark, an Ortolan Bunting and a Garden Warbler.
16:48:58 <sproingie> god bless wikipedia
16:49:28 <ivanm> is Roel van Dijk here?
16:49:30 <gOcOOl> had a feeling list comprehensions could accomplish that but wasn;t sure how exactly ;)
16:49:38 <sm> aha.. haskelldb figures out some of this stuff
16:50:15 <gwern> gOcOOl: personally, I think the primitive recursion version would be easier to read, but that's just me
16:50:42 <anapumpkin> that if inside the list comp looks like it could be a guard
16:51:13 <anapumpkin> > let filters ps xs = transpose [ [ x | p <- ps, p x ] | x <- xs ] in filters [odd, even] [1..10]
16:51:13 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
16:51:17 <anapumpkin> damn :)
16:51:33 <ivanm> wtf? pumpkin changed his nick _again_?
16:51:36 <zygoilid> this is a downloader missing a bustard missing a (turkey missing a goose) missing a pheasant, a chicken missing a duck, a guinea fowl, a teal missing (a woodcock missing a partridge missing a plover) missing a lapwing missing a blue XKG1945-Q
16:51:42 <ivanm> why can't you just stick with the normal vegetable?
16:51:48 <aavogt> > let filters ps xs = transpose [ return [ x | p <- ps, p x ] | x <- xs ] in filters [odd, even] [1..10]
16:51:49 <lambdabot>   [[[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]]
16:51:58 <gwern> ivanm: with halloween coming up, &everyone& is a pumpkin
16:52:12 <ivanm> bah
16:52:16 <ivanm> only to you yanks
16:52:30 <aavogt> > let filters ps xs = transpose [ [x | p x] | x <- xs, p <- ps ] in filters [odd, even] [1..10]
16:52:31 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10]]
16:52:35 * anapumpkin isn't a yank
16:52:37 <gwern> ivanm: hate to break it to you, but no one else matters
16:52:46 <ivanm> @slap gwern
16:52:46 <lambdabot> I'd rather not; gwern looks rather dangerous.
16:52:46 <zygoilid> must be midnight!
16:52:50 <ivanm> grrr...
16:52:58 <zygoilid> (someone turned into a pumpkin...)
16:53:15 <gwern> of course I look dangerous; I'm an american
16:53:27 <gwern> heir to trillions of dollars worth of military hardware and jarheads to use'em!
16:53:27 <ivanm> gwern: oh, and I tried using pandoc + citeproc-hs... in the end I re-wrote it all in straight LaTeX
16:53:31 <zygoilid> gwern: that'll be the right to arm bears or something
16:53:38 <ivanm> gwern: and quadrillions of dollars of debt?
16:53:40 <ivanm> zygoilid: lol
16:54:00 <gwern> zygoilid: THEY WILL WIN AFGHANISTAN, ANY OTHER THOUGHT IS UNPATRIOTIC
16:54:05 <zygoilid> or is it the arms of bears? yeah, bear arms, that's it. you have the right to carry bear arms.
16:54:12 <gwern> ivanm: ah, but how will the chinese *collect* on that debt?
16:54:13 <gwern> the fools
16:54:23 <ivanm> gwern: heh
16:54:41 <gwern> ivanm: as far citeproc-hs, I've never used it meself, so I don't feel particularly disappointed
16:55:15 <ivanm> gwern: bit of a pain when it says by default it only understands MODS input, so I convert my bibtex to MODS and it then says it doesn't understand the input :s
16:55:33 <gwern> ivanm: bug report. ye ken't?
16:55:45 <ivanm> or I can just go "stuff it" ;-)
16:56:22 <sproingie> zygoilid: no, genetic engineering.  you have the right to give yourself bear arms.
16:56:40 <sproingie> very forward-looking those founders
16:57:05 <zygoilid> i thought it was an amendment? along with cryonetics and votes for cyborgs
16:57:38 <sproingie> ben franklin was a time traveling cyborg bear hybrid
16:57:41 <zygoilid> heck, from what i hear they allow cybernetic organisms to become governor of california...
16:58:39 <jjardon> dcoutts, here the answer: http://pastebin.com/d1e91b2bc
16:58:56 <gwern> sproingie: actually, with his bifocals franklin was not just a cyborg, but a recursively improving one
16:59:17 <gwern> little known fact: Frankling was actually killed by Washington in order to prevent the Colonial Singularity
17:00:43 <zygoilid> see, the USA might have only 333 years of history, but those years have gone round plenty of times before spacetime settled down...
17:01:20 <gwern> that sounds like a Big Lie to me - 333 is *suspiciously* regular a number
17:01:37 <zygoilid> i might be off by a hundred years
17:01:49 <zygoilid> but the state of the timeline is such that no-one can be sure anymore
17:02:41 <gwern> hm. I am reminded of a fringe history theory I read about once
17:02:54 <gwern> that our timeline is too large by about 500 years and most of the dark ages never happened
17:02:57 <gwern> or something like that
17:03:27 <zygoilid> finally a good explanation of why the year 2000 didn't bring about armageddon
17:03:39 * zygoilid -> out
17:03:52 <monochrom> haskell?
17:03:52 <gwern> yeah, apparently we'd really be in the 1500s, or 1600s by now I suppose
17:05:04 <zygoilid> > fix$(0:).(1:).ap(zipWith(+))tail
17:05:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:05:11 <zygoilid> order is restored
17:05:26 <gwern> @quote aztec
17:05:27 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:05:47 <Axman6> > (zip `ap` tail) [1..]
17:05:48 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
17:06:26 <Axman6> blackdog: o/
17:06:51 <pumpkin> zygoilid: that's tame
17:07:01 <pumpkin> you can make it shorter than that!
17:07:07 <zygoilid> no doubt
17:07:21 <pikhq> zip`ap`tail... That's pretty nice.
17:07:33 <McManiaC> uuuh
17:07:44 <McManiaC> why does (* 5) work, but (- 5) gives me an error?
17:08:01 <aavogt> > (- 5)
17:08:02 <lambdabot>   -5
17:08:07 <Axman6> (-5) is -5
17:08:14 <aavogt> McManiaC: use subtract
17:08:15 <Axman6> not (\x -> x - 5)
17:08:25 <McManiaC> @pl \x -> x - 5
17:08:25 <lambdabot> subtract 5
17:08:28 <Axman6> @stc subtract
17:08:28 <McManiaC> ok
17:08:28 <lambdabot> subtract x y = y - x
17:08:34 <McManiaC> its confusing tho
17:08:34 <McManiaC> :)
17:08:37 <Axman6> yeah
17:09:13 <aavogt> > 1 + (-4)
17:09:23 <lambdabot>   -3
17:09:41 <aavogt> :t (+ $ -1)
17:09:42 <lambdabot> parse error on input `$'
17:11:00 <aavogt> @hoogle happraise
17:11:12 <lambdabot> No results found
17:11:16 <aavogt> @hackage happraise
17:11:17 <lambdabot> http://hackage.haskell.org/package/happraise
17:14:44 <zygoilid> > [floor$(0.5+1.25**0.5)**n/5**0.5+0.5|n<-[1::CReal ..]]
17:14:48 <lambdabot>   mueval-core: Time limit exceeded
17:14:50 <Neriooz> Hello, its me again. any of my precious helpers still here (was about filtering Nothing in a list of [[Maybe Int]]
17:15:04 <Neriooz> ?* after here
17:15:04 <lambdabot> Maybe you meant: . ? @ v
17:15:13 <zygoilid> > take 10 [floor$(0.5+1.25**0.5)**n/5**0.5+0.5|n<-[1::CReal ..]]
17:15:14 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
17:15:25 <tommd1> Neriooz: Look at Data.Maybe functions.  You probably want 'concatMap maybeToList'?
17:15:54 <zygoilid> Neriooz: you might also be interested in catMaybes
17:15:57 <aavogt> @type concatMap maybeToList
17:15:58 <lambdabot> forall b. [Maybe b] -> [b]
17:15:59 <zygoilid> @type catMaybes
17:16:00 <aavogt> @type catMaybes
17:16:00 <lambdabot> forall a. [Maybe a] -> [a]
17:16:01 <lambdabot> forall a. [Maybe a] -> [a]
17:16:04 <mgorbach> Having trouble running GHC on my machine: Getting some errors I've pasted at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4365#a4365
17:16:27 <mgorbach> Running OS X 10.6.1 on a 64bit machine.
17:16:30 <Neriooz> catMaybes really looked like something
17:16:45 <zygoilid> it's schroedinger's function
17:16:53 <ivanm> mgorbach: is that Snow Leapord?
17:16:56 <mgorbach> Yes
17:16:57 <ivanm> in that case, it's a known problem
17:17:00 <aavogt> @type map catMaybes
17:17:00 <lambdabot> forall a. [[Maybe a]] -> [[a]]
17:17:09 <mgorbach> ivanm: Anything I can do?
17:17:13 * ivanm thinks we should add that to the topic: "GHC doesn't like cold cats" :p
17:17:18 <ivanm> mgorbach: downgrade OSX? :p
17:17:29 <mgorbach> ivanm: No other solution? Bummer!
17:17:45 <ivanm> mgorbach: none that I know of
17:17:49 <mgorbach> In that case, is there some way I can run ghci such that it loads my file, runs main, and passes it some (command line) arguments?
17:17:57 <mgorbach> ghci seems to work just fine on this machine
17:18:04 <monochrom> :main x y z
17:18:12 <ivanm> mgorbach: well, with 6.12, IIRC it's ghci that has the problems... >_>
17:21:15 <mgorbach> monochrom: that works. Thanks.
17:21:26 <mgorbach> I'm on 6.10.4
17:21:36 <mgorbach> ghci seems to work fine, ghc is broken though.
17:27:42 <Neriooz> hmm catMaybes wasnt what i was looking for (atleast thats what i think) I'll post my code (2 lines) and you tell me the noobish misstake i have done :)
17:27:47 <Neriooz> blank (Sudoku sud) | lookup Nothing (xs) == Nothing = blank (Sudoku sud)
17:27:47 <Neriooz>                    | otherwise = fromJust $ lookup Nothing (xs)
17:27:47 <Neriooz>        where xs = (zip (concat sud) [((findMax (Sudoku sud)),x)| x <- [0..8]])
17:28:05 <jvoorhis> mgorbach: have you seen http://hackage.haskell.org/trac/ghc/ticket/2965#comment:24 ?
17:28:08 <Neriooz> this works fine 1 time, but when i get 2 lines that in lookup Nothing (xs) == Nothing it all fails
17:28:23 <Neriooz> dam hard to read what i posted :/
17:29:30 <Neriooz> hm guess my code didnt give a clue
17:29:42 * BMeph wonders how long it'll take monochrom to go completely ape-shit ballistic? 10 seconds? 15?
17:29:55 <heatsink> I have a parametric type T whose parameter is used in only some constructors.
17:30:15 <heatsink> I'd like to cast from a T a to a T b when that cast is typesafe.
17:30:28 <monochrom> What is ape-shit ballistic?
17:30:29 <heatsink> I thought an empty record update would do it, but that's rejected by GHC.
17:30:53 <heatsink> monochrom, they can throw but they don't have good aim
17:31:05 <BMeph> monochrom: I'd guess it's going ape-shit bananas and ballistic, all in the same hysterical rant. :)
17:31:05 <blackdog> Axman6: you invoked?
17:31:44 <heatsink> Is there a concise way to change a value's phantom type parameter?
17:32:21 <BMeph> heatsink: From what I recall, those damned apes had crazy mad ballistic skills. Bombing folks with those explosive bananas, and all... :)
17:34:20 <monochrom> It can be reduced to casting []::[a] to []::[b]. My reading of haskell code doing that suggests there is no convenient way.
17:34:51 <monochrom> Example. "concat [] = []" has to be written like that because it is from []::[a] to []::[[a]]
17:35:09 <heatsink> ah.
17:35:18 <ksf> toBar (Foo x) = Foo (undefined::Bar) x
17:35:39 <ksf> erm wait.
17:35:40 <heatsink> Yeah, I've written a few instances of f (Left err) = Left err before
17:36:12 <ksf> well, if in doubt use unsafeCoerce
17:36:15 <ksf> *duck*
17:36:17 <heatsink> haha
17:36:19 <monochrom> hehehe
17:36:28 <BMeph> hohohoho
17:36:39 <monochrom> I guess unsafeCoerce is safe for this.
17:36:53 <ksf> you can prove it in agda and have agda compile your proof to unsafeCoerce, if you want...
17:37:27 <Axman6> :t somtimesSafeCoerce
17:37:28 <lambdabot> Not in scope: `somtimesSafeCoerce'
17:37:31 <Axman6> :t sometimesSafeCoerce
17:37:31 <lambdabot> Not in scope: `sometimesSafeCoerce'
17:37:35 <Axman6> :(
17:37:39 <mrsolo> nice didn't know ghc will ignore #! on first line :-)
17:37:55 <monochrom> Woah?!
17:38:07 <ksf> haskell is very much posix, yes.
17:38:27 <ksf> monochrom, what, your Setup.hs's aren't chmod +x?
17:38:41 <ksf> #!/usr/bin/runhaskell is the magic
17:39:14 <aavogt> #!/usr/bin/env runhaskell # is this better?
17:39:31 <Saizan_> i wonder how the proof would look like in agda, i guess it requires at least a proof of type erasure for haskell
17:39:38 <monochrom> I neglected that. Now I see.
17:39:51 <ksf> runhaskell do all the magic itself, already.
17:40:13 <ksf> ...here, it does exec /usr/lib64/ghc-6.10.4/runghc -f /usr/bin/ghc ${1+"$@"}
17:40:40 <mrsolo> i do runghc always :-)
17:41:44 <monochrom> haskell-mode for emacs seems to recognize #! and give it a special colour, too.
17:42:25 <heatsink> monochrom, for me it just gets the preprocessor color
17:43:03 <monochrom> Oh oops.
17:46:05 <monochrom> I wonder where it is documented. I can't find it.
17:48:35 <ksf>  error: Illegal binding of built-in syntax: []
17:48:38 <ksf> gnaaaargh
17:49:52 <Axman6> blackdog: say whaa?
17:54:47 <blackdog> Axman6: doesn't matter. thought you were looking for me
17:54:59 <byorgey> > let [] = 4 in []
17:54:59 <lambdabot>   No instance for (GHC.Num.Num [t])
17:55:00 <lambdabot>    arising from the literal `4' at <inter...
17:55:02 <Axman6> yeah i was
17:55:18 <Axman6> just letting you know i've added you to the Wave invite queue :)
17:55:20 <byorgey> ksf: how'd you get such an error?
17:55:30 <byorgey> > let [] = [2,3,4] in 6
17:55:31 <lambdabot>   6
17:55:42 * ksf just noticed that it's very sensible to have a list type without []
17:55:45 <pumpkin> data [] a = a : b | []
17:55:46 <pumpkin> ?
17:55:51 <ksf> yep.
17:55:55 <pumpkin> or rather
17:55:57 <pumpkin> a : [] a
17:56:04 <ksf> erm no
17:56:04 <byorgey> ksf: sure, it's usually called a Stream
17:56:22 <byorgey> data Stream a = a :> Stream a
17:56:23 <ksf> well, data List a as = a : as | []
17:57:04 <ksf> and if you typeclass the constructors to give you views, you can convert from any of those to any other compatible one with map id.
17:57:15 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10699#a10699
17:57:23 <ksf> still needs a bit development, of course.
17:57:47 <sinelaw> PeakerWork, ??
18:00:42 <heatsink> that's kinda cool.
18:02:15 <McManiaC> how do i create a tag table with cabal?
18:02:42 <gwern> a what?
18:03:35 <ksf> mhhh I want two different viewL's, one with and one without nil.
18:03:42 <McManiaC> emacs haskell-mode has a visit-tags-table if i hit M-tab
18:03:54 <McManiaC> in the ghci environemnt
18:05:15 <ksf> hey cool <: is a valid operator
18:05:29 <McManiaC> and it defaults to ~/.cabal/TABS so i thought cabal can do this
18:05:30 <McManiaC> ^^
18:05:46 <McManiaC> TAGS actually
18:06:10 <ksf> ghci does tags
18:06:22 <ksf> there's probably a ghc flag, too.
18:06:42 <ksf> :ctags
18:07:30 <ksf> ...and it says it's a VI tag file, so you're going to have to change to the light side, after all.
18:07:46 <McManiaC> hmm
18:10:46 <ksf> someone think of two names for viewL for me.
18:10:51 <ksf> one with, one without nil.
18:11:28 <monochrom> viewLwithnil, viewLwithoutnil
18:12:07 <monochrom> a view with a nil
18:12:20 <m3ga> how come some code uses Text.Parsec and other code uses Text.ParserCombinators.Parsec?
18:12:39 <ksf> mhhh ideally there should be only one cons constructor for both of them.
18:13:03 <monochrom> I meant a view to a nil. http://www.imdb.com/title/tt0090264/
18:13:32 <Roller-ch> Hi! My name is Andrew! As you know we have in Russia is thriving social network vkontakte!
18:13:32 <Roller-ch> Now they are even though the network to make the world! If you're not hard to please register on this link http://vk.com/reg3864638 ! I would be very grateful!
18:13:34 <monochrom> Text.Parsec is since parsec version 3
18:13:42 --- mode: ChanServ set +o monochrom
18:13:57 <Xichekolas> man those russians sure can type fast...
18:14:23 --- mode: monochrom set -o monochrom
18:15:40 <monochrom> viewL, viewLinf. inf stands for infinite, since no possibility of nil.
18:17:36 <m3ga> monochrom: thanks
18:18:01 <ksf> what happens if a view throws an exception?
18:18:12 <monochrom> unsafeView :)
18:18:15 <ksf> does it the Logical Thing?
18:18:27 <ksf> well the Logical Thing would be to fail the pattern.
18:19:39 <idnar> invisibleView
18:20:56 <ksf> mhhh no.
18:21:17 <ksf> the whole concept of default views doesn't work when I'm doing different views for Nil and :, anyway.
18:21:35 <ksf> well...
18:22:29 <ksf> data Foo = Foo view (viewFoo)
18:22:31 <ksf> mhhh
18:22:41 <ksf> looks like a candidate for an assoc data type.
18:23:19 <ksf> I'm talking nonsense. don't listen to me.
18:34:07 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10699#a10703
18:34:35 <ksf> ...patterns should catch exception from views.
18:35:37 <c_wraith> @hoogle throw
18:35:38 <lambdabot> Control.Exception throw :: Exception e => e -> a
18:35:38 <lambdabot> Control.OldException throw :: Exception e => e -> a
18:35:38 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
18:36:05 <heatsink> I think that's as difficult as catching exceptions in arbitrary pure code
18:36:07 <ksf> I'd even be willing to throw PatternFailure
18:36:32 <ksf> that End | NoEnd stuff is just strange.
18:36:53 <ksf> although you _might_ want to match on NoEnd. but it's not really what I had in mind as I set out.
18:36:55 <heatsink> What If the view function returns a Maybe value, and you match it against a Just pattern?  Does that fall through to the next pattern like you want?
18:37:11 <ksf> sure it would.
18:37:35 <ksf> it's the same as failing that endR pattern in map
18:39:20 <heatsink> okay...
18:40:14 <heatsink> It looks alright to me
18:40:26 <ksf> well it works.
18:40:59 <ksf> the cool thing would be to infer the view and thus the class constraints from the constructors you match against.
18:42:53 <jmcarthur> i like view patterns, but i don't like our implementation
18:43:28 <jmcarthur> syntactically, there is no way to show that you want to reuse a value on multiple pattern matches
18:44:09 * ksf would like to write that map I posted exactly like
18:44:11 <ksf> @src map
18:44:11 <lambdabot> map _ []     = []
18:44:11 <lambdabot> map f (x:xs) = f x : map f xs
18:44:25 <jmcarthur> it might happen automatically, but that's magic
18:44:42 <ksf> ...and map' the same, just without the nil case.
18:45:27 <ksf> mhhh I guess it's done.
18:45:35 <ksf> ...I'd specify it in a standard, at least.
18:46:12 <ksf> ...if the function name's the same, share stuff.
18:50:15 <c_wraith>     `strMsg' is not a (visible) method of class `Error'
18:50:31 <c_wraith> Why am I have so much trouble with this?
18:50:54 <c_wraith> What am I doing horribly wrong?
18:51:19 <c_wraith> Is this an "MTL is incompatible with everything" error?
18:51:37 <heatsink> If you imported the Control.Monad.Error module, you should be able to see it.
18:51:37 <Asztal> it's usually that you're defining an instance for Error, but you didn't actually import strMsg.
18:51:48 <Asztal> strError*
18:52:04 <c_wraith> Hmm...  do I need to import Error(..) ?
18:52:38 <c_wraith> yes, I do.
18:52:42 <heatsink> You can do that, or just import the entire module
18:55:25 <c_wraith> holy crap.  for the first time in about 24 hours, I have this all compiling again.
18:56:34 <c_wraith> But I really didn't want to use ErrorT.  I'd still be happiest with the explicit-exception package, but I just don't think it plays nicely with mtl.
18:58:29 <ksf> mhhh hpaste should filter duplicate, identical posts that are posted in a matter of split seconds...
19:01:37 <c_wraith> maybe I can get control-monad-exceptions working.  It's supposed to work with mtl.
19:03:50 <sm> has anyone got a working example of connecting and querying with haskelldb ?
19:04:08 <sm> what could cause SqlError {seState = "", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: "} when running the query ?
19:06:25 <c_wraith> sm: an illegal query?
19:07:00 <sm> c_wraith: good idea, but if I paste the output of ppSql into postgres it runs fine
19:07:27 <c_wraith> incorrect connection parameters, maybe?
19:07:42 <c_wraith> Accidently connecting as a different user with the wrong permissions, for instance?
19:08:24 <sm> yees.. I'm doing db <- postgresqlConnect [("dbname","thename")] return
19:08:34 <sm> which seemed like it worked, but maybe not
19:10:08 <sm> I should look in the postgres log
19:11:21 <sm> hmm, sometimes I can get the query to spin forever, in ghci
19:13:11 <sm> aha.. pg log shows a successful connection, BEGIN, set encoding, COMMIT, BEGIN, but no query
19:13:40 <rsnake> Hey everyone
19:14:07 <sm> weird
19:15:20 <rsnake> I'm making a new data type that goes like this: data Variable = Variable { varName :: String } deriving (Eq). How can I restrict varName to take values only from a certain list?
19:17:21 <c_wraith> Only a specific (small) set of values, or only values with a certain pattern?
19:18:38 <rsnake> An infinite number of values with a certain pattern... say, strings of the form "aaaa...aaa" for any number of 'a'
19:18:50 <Cale> rsnake: Basically, no.
19:19:01 <c_wraith> Ok.  The best way then is to create your Variable objects through another method that checks that.
19:19:19 <c_wraith> And then don't export the Data constructor from the module.
19:19:28 <c_wraith> ...  If you're writing a multi-module program
19:19:33 <Cale> rsnake: You could put the type into a module, and not export the Variable data constructor, instead exporting a function which conditionally makes a Variable value only if the given String checks out.
19:19:37 <Cale> yeah
19:20:04 <sm> yay! got it working. that return argument was wrong
19:20:06 <rsnake> I see... thanks guys!
19:20:45 * monochrom wants to troll with an obfuscating method of doing that.
19:20:46 <Cale> Basically, it can't be a compile-time check though, since the way in which the String that you pass to the Variable data constructor is constructed can be arbitrarily complicated -- in general, the computation might not even terminate.
19:21:09 <Cale> Though, if you wanted to do enough type system hackery, it's probably technically possible.
19:21:24 <monochrom> Make it "data Variable = Variable Int". Design a 1-1 correspondence between Int and the set of allowed strings...
19:21:36 <monochrom> Or perhaps s/Int/Integer/
19:21:52 <Cale> (with extensions, the type system becomes Turing complete, and you can do all sorts of things with it if you're willing to expend sufficient effort.
19:21:53 <Cale> )
19:23:02 <rsnake> I was thinking of something along those lines... like instead of having a String varName it would have a natural number denoting the 'number' of the variable...
19:23:28 <rsnake> (I'm implementing lambda-terms)
19:24:14 <ksf> rsnake, google for de brujin indices
19:24:36 <monochrom> . o O ( my trolling has worked )
19:25:35 <rsnake> Very interesting ksf , thanks... I'll look into it
19:26:03 <ksf> ahh type level hackery will become type level coding as soon as we get data kinds, closed type funs and thus proper first-class type funs
19:28:25 <ksf> can't wait until I see an NFunctor being implemented as a type-level map.
19:29:03 <lpsmith> or you could just use integers as your variable names  :-P
19:37:19 <sm> how do I access the fields of a Record returned by a haskelldb query ?
19:37:31 <sm> it may or may not be some form of HList
19:40:29 <sm> I see, it's a Record hlist
19:45:40 <rsnake> Hmmm... I just defined my lambdaterm datatype with three different constructors... but when I try to instance show it won't let me because it says I have different numbers of arguments
19:45:42 <sm> ha. r .!. fieldName (or field_name, depending how you generated the code)
19:46:21 <c_wraith> rsnake:  just pattern-match in show
19:46:34 <byorgey> rsnake: can you paste your code on hpaste.org?
19:46:36 <c_wraith> You'll need parens, though:
19:47:15 <rsnake> c_wraith It was that! I was missing the parentheses. Thanks!
19:47:16 <c_wraith> show (Term1 a) = ... ; show (Term2 a b c) = ...
19:47:31 <c_wraith> Ah.  Sorry my example came a bit late, then. :)
19:48:08 <rsnake> s'ok :)
20:03:03 <jfoutz> vacuum is awesome.
20:17:58 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10707 <-- Why is there a syntax error here (indentation error, ghci says) on line 20?
20:18:46 <rsnake> Is there a difference between regular and unicode strings in haskell? The λ character doesn't show up...
20:19:23 <Axman6> _Ray_: cadenaEmpezandoDesde needs to be moved back one space i think (to lign up with primeros)
20:19:33 <Person_> Ah, Haskell
20:19:44 <Person_> Finally starting to get the hang of it
20:19:49 <Person_> Including IO Monads!
20:20:00 <amckinley> could somebody help me me fix this awful command line argument handling code i wrote? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10708#a10708
20:20:03 <Person_> my solution to all IOMonads: performUnsafeIO operation :)
20:20:29 <_Ray_> It's in the same line O.o 8 spaces from the left
20:20:34 <Draconx> _Ray_, it seems like a single where would be sufficient.
20:20:45 <Axman6> _Ray_: huh, so it is, my mistake
20:21:11 <_Ray_> Draconx, I'm not interested in letting sacarBlancosRepetidos knowing about primeros', for instance
20:21:17 <_Ray_> *know about
20:22:23 <monochrom> rsnake: If unicode characters don't show up properly, it is just because of I/O routines. Char does unicode correctly.
20:22:41 <monochrom> I mean Char stores unicode correctly.
20:23:04 <ivanm> monochrom: but you either need utf8-string or 6.12 to read/write unicode correctly?
20:23:05 <_Ray_> d'oh. otherwise foo instead of otherwise = foo.
20:23:06 <aavogt> > fromEnum (maxBound :: Char)
20:23:07 <lambdabot>   1114111
20:23:23 <monochrom> ivanm: Yes, please tell rsnake.
20:23:40 <ivanm> monochrom: why?
20:23:45 * ivanm just came in...
20:24:04 <ivanm> and I've never dealt with unicode before (or even much stuff to do with text)
20:24:19 <rsnake> Thanks monochrom, ivanm....
20:24:43 <ivanm> what am I getting thanked for?
20:24:45 <rsnake> I was putting off upgrading since ubuntu's repositories are so outdated... I'm pretty new to this building software thing
20:24:46 <ivanm> :s
20:25:00 <rsnake> I'm actually running ghc 6.8
20:25:15 <rsnake> ivanm I'd asked about the compatibility of unicode strings and haskell
20:25:24 <ivanm> ahhhh
20:25:30 <ivanm> that's a tad... old...
20:25:36 <monochrom> ivanm is getting thanked for practical information that rsnake needs. See the scroll buffer.
20:25:53 <ivanm> monochrom: I just came in when _Ray_ said "Draconx, I'm not interested in letting sacarBlancosRepetidos knowing about primeros', for instance"
20:26:35 <monochrom> Oops I see. rsnake asked about unicode processing.
20:26:47 <ivanm> *nod*
20:27:54 <Person_> Does anyone know much about deriving
20:28:03 <Person_> Or have resources, from which I can read about it
20:28:17 <ivanm> heh, it appears it's not just GHC that doesn't work on Snow Leopard properly, but SL itself :p http://news.bbc.co.uk/2/hi/technology/8304229.stm
20:28:22 <Person_> I understand that it adds functionality to a customized data-type, but when is it entirely properly?
20:28:25 <ivanm> Person_: what do you mean?
20:28:27 <Person_> *proper
20:28:44 <ivanm> Deriving automatically works for Eq, Ord, Show, Read and Enum IIRC
20:28:58 <ivanm> (if your datatype uses values that have the appropriate instance)
20:29:22 <ivanm> or, with the appropriate GHC extensions, newtypes can derive any class, and for 6.12 there's Foldable, Traversable and one other IIRC
20:29:30 <Person_> Right, the purpose of deriving is to signal to the compiler that Eq,Ord, Show, Read, Enum, etc. are valid operations on the custom data type
20:29:48 <Person_> I assume that is correct
20:30:25 <ivanm> something like that
20:30:37 <ivanm> it saves you from writing out instance Foo Bar where... etc.
20:31:11 <aavogt> Data and Typeable too
20:31:14 <Person_> So if I have created a custom data type, and in the declaration I do not include "deriving Show"
20:31:26 <Person_> I will not be able to perform show on that data type
20:31:33 <blackdog> you might choose not to derive Read and Show if you want to control creation of your data types - lets you export it as an abstract type
20:31:41 <ivanm> aavogt: ahhh, that's the other ones
20:31:45 <blackdog> (well, you'd really only have to omit Read)
20:31:54 <ivanm> blackdog: not quite...
20:32:05 <ivanm> with Show, you can put it straight into ghci still, can't you?
20:32:10 <ivanm> (with a copy-paste)
20:32:27 <aavogt> there's also toEnum
20:32:34 <aavogt> to be wary of
20:32:44 <ivanm> yeah
20:32:56 <aavogt> I think you can get Bounded too
20:33:09 <ivanm> probably
20:33:59 <Person_> makes sense
20:34:37 <Person_> then when you include deriving Show, there is no need to manually overload the Show function?
20:36:11 <blackdog> Person_: yeah. it's probably best for debugging, though - i think there's a note in the ghc docs about it not being particularly efficient
20:36:16 <ivanm> Person_: you _can't_ manually create an instance for Show
20:36:21 <ivanm> blackdog: :o
20:36:29 <ivanm> (the efficient part)
20:37:32 <ivanm> blackdog: btw, where are you based (that you and Axman6 keep talking about projects)?
20:38:23 <blackdog> Sydney
20:38:47 <ivanm> ahah
20:39:03 <blackdog> can't find the efficiency thing now :/ i'm not sure what it guarantees you for big datastructures.
20:39:56 <blackdog> ivanm: what'd you mean about not being able to manually create an instance for Show? That works perfectly well.
20:40:21 <ivanm> blackdog: if you have a deriving Show, then you can't do a manual Show instance
20:40:39 <ivanm> but yes, deriving Read is much easier than a manual implementation :p
20:41:06 <Gracenotes> particularly because it has to do this algorithm specified in the haskell report
20:41:14 <ivanm> blackdog: well, deriving Read can be inefficient: http://hackage.haskell.org/trac/ghc/ticket/1544
20:41:19 <blackdog> well, yes. if you take the train to work, you can't also take the bus at the same time :)
20:41:35 <ivanm> blackdog: well, creating a deriving-style Show instance isn't that hard
20:42:38 <ivanm> sshc: are you pinging me or something?
20:42:50 <blackdog> i wonder. is there a way to specify a transformation that would give you both Read and Show instances? (or something similar?)
20:43:01 * ivanm keeps getting "Received a CTCP VERSION from sshc" from xchat
20:43:13 <ivanm> blackdog: hmmmm...
20:43:14 <blackdog> there's Binary, but even there you have to specify both get and put, and there's no guarantee of correctness
20:43:30 <sshc> ivanm: trigger.pl isn't working correctly
20:43:40 <sshc> ivanm: I'm trying to stop empty file CTCP spam
20:43:44 <ivanm> ahhh
20:43:56 <Gracenotes> you can set +C
20:44:10 <sshc> -dcc_ctcps -command "do something"
20:44:12 <Saizan_> blackdog: i've seen at least an attempt at that but nothing released
20:44:14 <sshc> but nothing happens
20:45:11 <Gracenotes> empty file?
20:45:33 <sshc> I can test the trigger by versioning myself
20:45:35 <sshc> nothing happens.
20:45:46 <sshc> but it *should*
20:45:52 <ddarius> blackdog: You can invert a parser.
20:45:55 <ivanm> sshc: and so you decided to annoy me instead? :p
20:46:03 <ddarius> or pretty printer
20:46:36 <sshc> ivanm: trigger somehow started versioning pagefuls of different people
20:46:46 <ivanm> ahhh
20:47:06 <sshc> and now everybody's PMing me
20:47:16 <sshc> I told trigger to change it to stop doing it
20:47:18 <Gracenotes> zomgz
20:47:20 <sshc> but it didn't change it
20:47:31 <sshc> so I deleted it entirely, and that at least finally worked
20:47:56 <Gracenotes> the archetypal tale of the rogue robot disobeying its master
20:48:03 <ivanm> heh
20:49:33 <blackdog> ddarius: is that supported in many parsing frameworks? i haven't seen it done.
20:57:09 <danco> blackdog: i've never seen it.  most parsers drop whitespace even (_is_ there any existing haskell parser that doesn't?)
20:57:32 <danco> but this paper might be relevant "bidirectionalization for free!" http://wwwtcs.inf.tu-dresden.de/~voigt/popl09-2.pdf
20:58:45 <danco> it probably isn't relevant.  but it's a similar-sounding idea anyway
20:59:22 <ksf> ooooh bijective parsers look interesting.
20:59:43 <mmorrow> blackdog: (Int)Map/(Int)Set do Show/Read without exposing the implem
21:00:01 <mmorrow> "fromList [0,1,2]"
21:00:50 <ivanm> mmorrow: yes, but that must have been a PITA to write IMHO...
21:00:59 <blackdog> mmorrow: yes, of course. I meant more if you wanted complete control over how your datatypes were created, Read/Show was a backdoor. If you're going to define them yourself, you have complete control over how you do it...
21:01:11 <blackdog> danco: that looks pretty cool, thanks.
21:01:38 <mmorrow> blackdog: ah right
21:01:59 <ksf> uh. well. If you have both an IntMap / Map in your record you're fucked.
21:02:18 <mmorrow> ivanm: iirc \m -> "fromList " ++ (show . toList) m
21:02:18 <ksf> mhhh
21:02:30 <ksf> or not.
21:02:34 <ivanm> mmorrow: reading?
21:02:40 <ksf> I shouldn't think of that output as source.
21:02:50 <mmorrow> <check for "fromList " prefix, and drop it> (fromList . read) s
21:03:01 <danco> show's output is supposed to be source
21:03:21 <ksf> yep, and you can't infer the type by looking at "fromList [...]"
21:03:28 <danco> ya
21:03:31 <mmorrow> yeah, that bit is annoying
21:03:40 <mmorrow> but that it's valid haskell is imo key
21:03:49 <blackdog> danco: thinking about it a bit more - really, dropping whitespace is a conflation. if you want that behaviour, you should be able to compose the parser with a whitespace-remover somehow.
21:03:59 <danco> blackdog: i know!
21:04:04 * danco angry about this
21:04:12 <ksf> but without the haskell part, we could as well serialize to say mediawiki, algol or bf syntax.
21:04:46 <ivanm> danco: do you meann you want exact whitespace kept when parsing -> printing?
21:04:52 <ivanm> so that (print . parse) really is id?
21:05:14 <danco> ivanm: yes that should be the default form imho
21:05:26 <ivanm> danco: problem with that is, what keeps the whitespace?
21:05:29 * ksf would like that. the working view of your data is just a view, there's more to it.
21:05:38 <ivanm> e.g. something like parsing "1 + 2"... is the whitespace in the 1, the + or the 2?
21:05:46 <ivanm> (or some mixture)
21:05:47 <ksf> it's between the tokens.
21:05:50 <danco> ivanm: the +
21:06:06 <danco> ExprAdd Expr WS WS Expr
21:06:10 <ksf> you can still give a semantic view of lit op lit _and_ remember whitespace.
21:06:21 <mmorrow> (what i really meant by "yeah, that bit is annoying", is that since Map/Set/Int* are pretty much always imported qualified, if you want to paste a Show'n Map/Set into code, you have to manually s/fromList/M.fromList/ or whatever your qualifier choice is
21:06:23 <ivanm> ksf: but if you want to parse a language, then you don't want extraneous "token" values littering everything
21:06:35 <ivanm> ksf: see, my take is that you should have permissive parsers but strict printers
21:06:42 <ksf> more importantly, only replacing + would not change its whitespace embedding, changing the whole expr possibly.
21:06:55 <danco> ivanm: what about code transformation
21:07:02 <ivanm> mmorrow: except there's probably no real way (without clever compiler-specific-hackery) of having that kind of support
21:07:06 <danco> everything becomes strict, 80cols be damned?
21:07:11 <ivanm> heh
21:07:15 <ksf> ivanm, they don't clutter the rest of your program if they don't show up in your semantic view of the data.
21:07:17 <ivanm> danco: well, depends what you're doing of course
21:07:24 <mmorrow> ivanm: yeah
21:07:30 <ivanm> ksf: right, if you have something like what danco said, then it makes sense
21:07:50 <ksf> when doing transformation you can't keep whitespace intact, of course.
21:08:09 <danco> ksf: you can leave alone the whitespace for parts you don't end up transforming..
21:08:09 <mmorrow> ivanm: actually it's impossible, since suppose you want to paste it into two different modules that import that module with two different qualifications
21:08:16 <ksf> but e.g. whitespace should be preserved if you tell a refactorer to move a function to another module.
21:08:24 <ksf> danco, exactly.
21:08:24 <ivanm> mmorrow: lol
21:08:50 <ksf> mmorrow, Data.IntMap.fromList
21:08:56 <danco> ksf: oh and comments
21:08:58 <danco> don't forget those
21:09:08 <ksf> yep that's whitespace.
21:09:11 <mmorrow> ksf: iirc that can be turned off
21:09:19 <danco> even if you make a formula for how whitespace can be, you can't do the same for comments
21:09:24 <ksf> ...except for an haddock-annotated view, of course.
21:09:25 <danco> s/can/should
21:09:33 <ivanm> ksf: heh
21:09:48 <ivanm> mmorrow: what can be turned off?
21:10:00 <mmorrow> ksf: ("that" := the ability to refer to identifiers like that)
21:10:50 <mmorrow> implicit "import Foo" also adding "import qualified Foo"
21:10:55 <ksf> well at least it makes an attempt to preserve the type.
21:11:12 <mmorrow> ksf: but "1" is ambiguous too..
21:11:15 <ksf> we should have some serialisation that you can't mess with.
21:11:26 <ksf> let it be binary, I don't care.
21:11:28 <mmorrow> and that preserves sharing..
21:11:33 * mmorrow wants this bad
21:11:36 <ksf> oh that's a great idea.
21:11:47 <ksf> ...and can include some standard bytecode.
21:12:14 <mmorrow> yeah, handling functions is the tricky part
21:12:42 <mmorrow> serialize [(0::Int)..]
21:13:08 <mmorrow> you need some way of representing enumFromTo
21:13:13 <ksf> heh. lazyness down to the serialisation level.
21:13:24 <mmorrow> that can be reverse-mapped to enumFromTo at the other end
21:13:45 <ksf> nope you're supposed to serialize a _thunk_
21:14:12 <mmorrow> right, but that thunk contains pointers that won't be valid in another runtime
21:14:25 <copumpkin> bytecode ftw
21:14:30 <ksf> not x86 code. core or something.
21:14:41 <copumpkin> ksf: no, they do point to x86 code
21:14:43 <ksf> should'nt be to hard to make a binary instance for its adt.
21:15:19 <ksf> then we need jit.
21:15:27 <mmorrow> unfortunately it looks like it's impossible without using bytecode since the asm-level symbols ghc spits out aren't even the same for two different compilations of the *exact* same program
21:16:07 <mmorrow> so you could only be able to not include code/bytecode if you're assuming you're communicating between two different instances of the *exact* same binary
21:16:29 <mmorrow> ghc --make Foo.hs -o Foo1; ghc --make Foo.hs -o Foo2;
21:16:34 <mmorrow> Foo1 /= Foo2
21:16:42 <mmorrow> :(
21:17:02 <copumpkin> where does the nondeterminism come from?
21:17:03 <mmorrow> (gum/gransim requires the exact same binary (in this sense))
21:17:05 <ksf> what's it doing, deliberately randomizing?
21:17:21 <mmorrow> copumpkin, ksf: i'm not sure exactly the source
21:17:23 <copumpkin> you'd think that something written in haskell would have to go out of its way to be nondeterministic, especially since it's not concurrent
21:19:05 <mmorrow> i guess the unique generator(s) ghc use(s) are inherently non-deterministic somehow
21:19:26 <mmorrow> s/use(s)/uses/ :)
21:20:00 <mmorrow> or rather, the order in which random numbers end up getting requested is non-det (or something)
21:20:04 <copumpkin> it's probably just using std gen at some point, seeded from time or urandom
21:20:19 <copumpkin> which seems unnecessary
21:20:24 <mmorrow> i think it's just an      unsafePerformIO (newIORef 0)
21:20:50 <mmorrow> (since random numbers could collide)
21:21:29 <danco> random numbers don't actually collide
21:21:37 <danco> it took me a while to accept that, but i have
21:21:41 <copumpkin> if they did, the universe would end
21:21:55 <mmorrow> hmm
21:21:59 <danco> _unless_ you are writing a bigtable implementation
21:22:13 <mmorrow> , randomRs (0,1) (mkStdGen 0928748798834)
21:22:16 <copumpkin> they do colide quite often though
21:22:17 <lunabot>  [0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,1,0,0,...
21:22:32 <copumpkin> the sequence won't repeat for ages and ages
21:22:37 <danco> sufficiently large
21:22:37 <mmorrow> s/(0,1)/(minBound,maxBound)/
21:22:38 <copumpkin> but you'll get repeated numbers quite quickly
21:23:33 <danco> maybe i should say "64bit numbers won't collide in almost any application you are likely to need them for"
21:23:34 <mmorrow> oh, maybe i mean s/collide/repeated/ (not sure the correct word for this)
21:24:02 <mmorrow> danco: if they do though, you get a broken program
21:24:28 <danco> good thing they won't ;)
21:24:42 <mmorrow> although (assuming it was fast enough) using a crypto-hash function would probably be acceptable
21:24:46 <copumpkin> the probability isn't as low as you might think
21:24:50 <mmorrow> so i guess that's the same thing
21:25:38 <mmorrow> anyways though, this point is moot is you just have a sequential number generator, which /never/ will collide
21:25:43 <mmorrow> , [0..]
21:25:44 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
21:25:53 <ksf> aehm you can still check for duplicates and get a new number if you don't like the look of a generated ident. that preserves determinism.
21:25:54 <copumpkin> yeah
21:26:00 <ddarius> until it wraps
21:26:06 <mmorrow> i just don't see where the non-determinism is entering in ghc's
21:26:16 <mmorrow> ddarius: well yeah
21:26:53 <mmorrow> ksf: then you lose O(1)
21:27:23 <monochrom> Eh, where is the non-determinism?
21:27:35 <ksf> in practice, the next number will have sufficiently different bits in lim -> 100% of the cases.
21:27:36 <mmorrow> ghc --make Foo.hs -o Foo1; ghc --make Foo.hs -o Foo2;
21:27:43 <ddarius> until (not . isSuspicious) generate seed where isSuspicious _ = True
21:27:51 <mmorrow> the asm of Foo1 and Foo2 aren't guaranteed to be the same
21:27:58 <mmorrow> (wrt the label names)
21:28:30 <mmorrow> which breaks reverse-mapping addresses to .o-level symbols, and re-linking at the other end
21:28:41 <mmorrow> which was my initial idea
21:29:33 <ksf> but /me doesn't want to use a system that serializes asm code and sends it over the inet, anyway.
21:29:37 <mmorrow> that would work if they're the *exact* same binary though, but that seems limiting to me
21:29:59 <mmorrow> ksf: no asm or binary code would be involved
21:30:03 <ksf> when you've got hold of the core, you can typecheck it and have a function that disallows say unsafePerformIO and unsafeCoerce.
21:30:13 <ddarius> ksf: PCC
21:30:16 <ksf> ...then you can wrap it in mueval.
21:30:57 <mmorrow> serialize [0..] ====>  AP "enumFrom" (CONSTR(==>Int),0#)
21:31:25 <mmorrow> then you need to relocate that closure, replacing "enumFrom" with the current address of the infotable of the function enumFrom
21:31:41 <mmorrow> as well as fill in the correct address of the infotable for Int
21:31:48 <copumpkin> so what's really missing is a pathway from our bytecode to native code again :P
21:32:05 <ksf> we _do_ have run-time module loading.
21:32:16 <mmorrow> ksf: a closure isn't a module
21:32:17 <copumpkin> that's not the same thing
21:32:39 <ksf> ...I wanted to say that we can do run-time linking.
21:32:40 <mmorrow> ksf: a closure is just like a little piece of a .data section of a .o file
21:33:02 <mmorrow> in that reifying it in another runtime amounts to linking it in
21:33:54 <ksf> the hard part, as I see it, is to get a bytecode representation of anything without interpreting everything.
21:34:07 <copumpkin> you'd package both into an executable, I'd guess
21:34:18 <ksf> ...and without executing both.
21:34:36 <ksf> you'd have to reduce the bytecode along with the asm
21:34:44 <mmorrow> ksf: yeah, it's simply a matter of including all the info you need into the runtime memory image
21:35:00 <mmorrow> no execution or translation necessary
21:35:11 <ksf> something like sharing thunk results between bytecode and asm
21:35:17 <mmorrow> but if we're duplicating *all* the machine code into bytecode, that becomes pretty infeasible
21:35:29 <mmorrow> ksf: that already happens
21:35:59 <ksf> why?
21:36:07 <ksf> the infeasibily, I mean.
21:36:12 <mmorrow> ksf: and also if you have bytecode that means you need to link the interpreter into your program
21:36:35 <mmorrow> along with ghc's linker, and countless other megabytes of code
21:36:53 <ksf> well sure you need metacircularity.
21:36:59 <ksf> but it would also give us eval for free.
21:37:04 <mmorrow> , eval "42"
21:37:09 <mmorrow> eval is easy
21:37:09 <lunabot>  <<Integer>>
21:37:14 <copumpkin> lol
21:37:33 <mmorrow> turning [0..] into a representation, then sending it over the network and reifying it is the hard part
21:38:01 <copumpkin> a representation that the other side can trust would also be nice
21:38:02 <ddarius> s/reifying/reflecting
21:38:15 <copumpkin> not sure how practical PCC is
21:38:28 <ddarius> copumpkin: If it's language level, that's not a problem.  PCC is a solution and it is pretty practical.
21:38:29 <mmorrow> ddarius: reifying being relocation, and reflecting being serialization
21:38:31 <ksf> copumpkin, well it could typecheck it and nuke unsafe*
21:38:50 <notsmack> I've got a bytestring, can i process it with HXT without unpacking it?
21:39:01 <ddarius> mmorrow: Reify = make a representation of, reflect = animate that representation
21:39:15 <ksf> reflect = jit
21:39:17 <copumpkin> reify is a weird word
21:39:22 <mmorrow> ddarius: hmm, we have exactly opposite definitions
21:39:24 <ddarius> @wn reify
21:39:25 <lambdabot> *** "reify" wn "WordNet (r) 2.0"
21:39:25 <lambdabot> reify
21:39:25 <lambdabot>      v : consider an abstract concept to be real
21:39:25 <lambdabot>      [also: {reified}]
21:39:34 <copumpkin> res = thing
21:39:50 <copumpkin> thingify!
21:39:56 <mmorrow> ==> reify = Addr -> a
21:40:50 <ddarius> mmorrow: In the behavioural reflection, reify is usually the operation that gives you access to the implementation internals as language level objects, and reflect is the operation that inserts language level objects into the implementation (to be acted upon)
21:41:05 <ddarius> E.g. call/cc reifies a continuation, applying it reflects it
21:41:11 <ksf> it would also lift TH to a whole new level.
21:41:29 <ksf> you could, for example, eval a function to full laziness.
21:41:38 <ksf> well, all that metacircularity goodness.
21:41:41 <mmorrow> ddarius: ah ok, i think the context of that use and this use then is what's the issue here
21:42:11 <mmorrow> i'd consider vacuum to be "reflect", and relocate to be "reify"
21:42:16 <ddarius> mmorrow: Probably, though I would consider what you are talking about to (also) fall under a reflection context.
21:42:42 <mmorrow> but either way, we're talking about the same thing in the end
21:43:11 <ddarius> s/behavioural reflection/behavioural reflection literature/
21:43:14 <ksf> ...in fact, metacircularity is the thing I miss most in haskell
21:44:19 <monochrom> reflect-reify will be another pair of words I will always swap mistakenly.
21:44:49 <monochrom> (I have just recently sorted out, in a Galois connection, which one is the lower adjoint and which one is the upper!)
21:44:57 <ksf> you could define some strict bytecode, define haskell's current eval model in terms of an interpreter written in that bytecode, and then futamura the whole thing into something fast.
21:45:19 <ddarius> ksf: It doesn't work that way.
21:45:45 <monochrom> (I also admit that when learning trig, I almost mixed up sine and cosine.)
21:46:10 <ksf> monochrom, well that's just an off-by-one error.
21:46:12 <FunctorSalad> lower/upper?
21:46:17 <ddarius> Trigonometry is such a waste.
21:46:24 <ksf> ddarius, why?
21:46:33 <copumpkin> trigonometry on finite fields is where it's at, apparently
21:46:43 <copumpkin> reals are so passé
21:46:55 <ddarius> copumpkin: That would be more interesting.
21:47:00 <Peaker> quicksilver, you there?
21:47:44 <copumpkin> not really sure what the purpose of it is, but it's neat to see things applied in unlikely places
21:48:01 <Peaker> I had an idea for a ghc type extension. I think its a little annoying that (\x -> (x, x)) y   is different to (y, y).   I think we can add, in addition to universal/existential quantification, a "foreach" quantification so the type of  \x -> (x, x)   would become:  forall b c. foreach [b,c] a. a -> (b, c)   which would make those things the same <-- then quicksilver replied:
21:48:01 <ddarius> copumpkin: Learn complex analysis.
21:48:11 <copumpkin> I'd very much like to
21:48:21 <copumpkin> along with a bunch of other advanced math
21:48:22 <Peaker> <quicksilver> at the cost of removing the principle type property, breaking type inference and making unification unfeasible, yes, we could do that, (I'm not sure if it really does all three of those things, but I recall that things like that tend to be the adjuncts of higher rank inference
21:48:35 <Peaker> can someone explain quicksilver's answer? I am not sure why it should do any of those
21:48:41 <ddarius> copumpkin: Trust me.  Complex analysis is at the hub of a lot of pure and applied math.
21:48:52 <sm> in my program, the type of haskelldbrecord .!. somefield is Expr Int. At the ghci prompt, it is just Int. Any idea why, or how to extract the int from the expr ?
21:48:55 <monochrom> Assume a partial order ⊑. Or two domains and their partial orders, both called ⊑. Galois connection: pair of functions f,g, satisfies forall x,y: f x ⊑ y iff x ⊑ g y.  f is the lower one, g is the upper one.
21:49:08 * sm wonders if anyone uses haskelldb
21:49:13 <copumpkin> ddarius: I haven't done real analysis though. Is that a prerequisite?
21:49:33 <copumpkin> monochrom: the wikipedia article on galois connections is what made me "get" (at least superficially) adjunctions
21:49:41 * copumpkin thanks galois for something he didn't do
21:49:59 <ddarius> copumpkin: I don't know.  Some basic understanding of it is no doubt useful, but you don't need to go into massive detail and complex analysis makes many results simpler and/or more uniform.
21:50:24 <copumpkin> alright :) any books you recommend? I have access to a big library
21:50:47 <monochrom> I learned that stuff before wikipedia was born.
21:50:53 <ddarius> copumpkin: Most things labelled "Galois" are things Galois would not recognize at all (but could probably figure out reasonably quickly.)
21:50:54 <ksf> hmmm. is memcpy lazy?
21:50:56 <copumpkin> monochrom: uphill both ways?
21:51:04 <ksf> It'd be fucking great if it were.
21:51:07 <ddarius> (And Galois isn't particularly special in that regard.)
21:51:12 <copumpkin> yeah :)
21:51:15 <monochrom> No. Wikipedia is uphill both ways. I think I had it easy.
21:51:36 <ddarius> copumpkin: I've never had (handy) access to a big library, so I don't know much about books.
21:51:51 <copumpkin> monochrom: I dunno, I have a pretty poor background in maths but wikipedia gave me reasonably accessible introductions to a lot of advanced topics that I wouldn't have known about otherwise
21:52:13 <ddarius> copumpkin: Actually, Penrose's "Road to Reality" has a reasonably large amount of information about it presented in astonishing depth.
21:52:39 <ddarius> copumpkin: I do, however, disagree with a lot of things he presents and/or his mode of presentation.
21:52:42 <sm> a-ha.
21:52:55 <copumpkin> wow, a complete guide to the laws of the universe!
21:53:01 <copumpkin> sounds pretty ambitious :)
21:53:06 <monochrom> One factor is: I learned it from calculational people, implying well-designed notation and boiled down proofs by letting the symbols do the work. Wikipedia goes with conservative mathematicians, traditional unoptimal notation and over-glorified wordy proofs.
21:53:36 <ddarius> +1 for tools/notation that lead to a calculational style
21:53:57 <copumpkin> is calculational like constructive?
21:54:11 <monochrom> calculational is like doing highschool algebra.
21:54:20 <copumpkin> oh :)
21:54:28 <ddarius> Yeah, calculational tends towards "algebraic" to me.
21:54:35 <mmorrow> mathematicians usually call it "proceeding formally", then snicker
21:54:46 <monochrom> even with the "because... therefore... but then... note that... hence... as a result..." part.
21:54:58 <ddarius> mmorrow: They don't snicker when the formal tools are concise and reasonably clear.
21:55:01 <mmorrow> ("proceeding formally" being synonymous with tedium )
21:55:32 <ddarius> mmorrow: (I hear that) Many mathematicians lamented category theory for reducing math to calculation.
21:55:33 <copumpkin> yay tedium
21:55:34 <monochrom> calculational is less tedious than their "because... but then... note that..."
21:56:13 <monochrom> Fokkinga even demonstrates that calculational is less tedious than diagram chasing.
21:56:32 <monochrom> And this is why Dijkstra says: a formula is worth a thousand pictures.
21:56:47 <ddarius> I don't particularly like Fokkinga's presentation, though it is a useful perspective to at least see.
21:57:15 <ddarius> I tend toward representability as opposed to initiality.
21:57:28 <ddarius> Less need to invent categories that way.
21:58:20 <FunctorSalad> Fokkinga?
21:58:31 <ksf> hm. ideally, there should be an interface that would let me chunk up a file into extends, create a new extend, tell the metadata that it should go into the middle and then fill it.
21:58:35 <FunctorSalad> lmgtfm
21:58:42 <ksf> *extent
21:58:58 <ksf> ...all copy on write, of course.
22:00:38 <ksf> and another problem that I could have is that my own metadata of the flat file could grow to a significant size.
22:00:52 <FunctorSalad> this text? http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.html
22:00:55 <ksf> ...so I'm going to need a way to forget it and re-parse it.
22:01:19 <ksf> that is, unevaluate parts of the program.
22:01:46 <monochrom> Yes FunctorSalad.
22:05:59 <ksf_> you see, some programs wouldn't stack overflow when the gc could gc something and re-flag some thunk as not evaluated, again.
22:11:03 <ksf> hm.
22:11:24 <ksf> all that still won't fix the simple problem of mapping a file that spans a whole zfs volume.
22:11:28 <ksf> > 2^128
22:11:29 <lambdabot>   340282366920938463463374607431768211456
22:24:49 <int-e> ksf: how would that fix /stack/ overflows?
22:30:59 <mmorrow> ksf: ? thunks are destroyed when they're evaluated
22:31:59 <Peaker> anyone knows a good way to get LYAH in local form, with the cute art? the pdf is empty of art
22:32:12 <Peaker> wget -m   doesn't fix the links to be relative
22:35:06 <mmorrow> in "case x of (a,b) -> f b", say "x" is a ptr to a thunk (which in turn points to "(a,b)"), that thunk would get overwritten with a ptr to "(a,b)" and the closure type changed to "indirection", then you use "b", so just turning "x" back into a ptr to a thunk (as opposed to it now being a ptr to an indirection) wouldn't do anything. also, after the next gc "x" will directly point to "(a,b)", so the fact that it ever was a thunk is gone
22:35:11 <mmorrow>  @ksf
22:36:23 <mmorrow> (and in this case also, if "(a,b)" is already evaluated as such, then evaluating "x" wouldn't do any work
22:36:41 <mmorrow> (other that overwriting the closuretype field with IND)
22:38:38 <ksf> mmorrow, but I'm going to have a huge amount of data in the heap as I'm retaining a pointer to the root of it. because I'm going to use it again, at least potentially.
22:39:03 <mmorrow> ok
22:39:10 <ksf> while its cool to trade memory for cpu time, it can also blow your ram.
22:39:11 <mmorrow> i still don't get what you're saying :)
22:39:41 <copumpkin> @let dup x = (x, x)
22:39:42 <lambdabot>  Defined.
22:39:48 <Peaker> @type tup
22:39:49 <lambdabot> Not in scope: `tup'
22:39:50 <hackagebot> darcs-benchmark 0.1.1 - Comparative benchmark suite for darcs. (PetrRockai)
22:39:51 <Peaker> @type dup
22:39:51 <copumpkin> :t dup . dup . dup . dup
22:39:52 <lambdabot> forall t. t -> (t, t)
22:39:52 <lambdabot> forall t. t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
22:40:04 <Peaker> copumpkin, with my type extension, the type would be huge :)
22:40:10 <ksf> let's say I have a 200g ebml file and a parser that gives me a tree of small bytestrings, for the sake of argument very, very small ones.
22:40:33 <mmorrow> , let dup x = (x,x) in (length . vacuum) (dup (dup (dup (dup (dup (dup (dup (dup 42))))))))
22:40:36 <lunabot>  9
22:40:42 <mmorrow> , let dup x = (x,x) in (length . show) (dup (dup (dup (dup (dup (dup (dup (dup 42))))))))
22:40:44 <ksf> ...those bytstrings are mmaped, and the metadata is lazy, so I won't have a problem if I don't force evaluation of the whole of the stuff.
22:40:44 <lunabot>  1277
22:41:07 <mmorrow> (why serialization what preserves sharing is so crucial :)
22:41:12 <mmorrow> s/what/that/
22:41:19 <copumpkin> :)
22:41:25 <ksf> ...but a user might look at every byte of the 200g file, over and over again.
22:41:45 <mmorrow> ksf: the os swaps pages when it needs to
22:41:52 <ksf> that's going to blow the memory with the spine of my metadata tree, so it'd be cool if some of it could be forgotten.
22:41:57 <ksf> well.
22:42:06 <mmorrow> you can mmap a billion GB file if you like
22:42:13 <ksf> for the sake of argument, assume that 200g is all the disk space I've got ;)
22:42:24 <ksf> > 2^48
22:42:25 <lambdabot>   281474976710656
22:42:29 <ksf> that's my max.
22:42:38 <ksf> err no.
22:42:39 <mmorrow> what are getting at?
22:42:49 <ksf> 2^64 is the max, 48 is physical.
22:42:50 <mmorrow> *are you..
22:43:16 <ksf> well, as I said: forget evaluated data, as it's a memory burden.
22:43:36 <mmorrow> if a ByteString exists at all, it's fully evaluated
22:43:51 <mmorrow> since it's just a (Addr#,Int#,Int#)
22:43:54 <ksf> I'm not worried about the bytestrings, they're mmaped.
22:44:08 <ksf> I'm worried about the metadata I'm collecting on it.
22:44:09 <mmorrow> what are you worried about?
22:44:18 <ksf> which I can regenerate.
22:44:21 <mmorrow> in the haskell heap?
22:44:25 <ksf> yep.
22:44:28 <mmorrow> then discard all refs to it
22:44:39 <ksf> well I can't because I might want to use it again.
22:44:49 <mmorrow> then regenerate it
22:44:51 <int-e> you can explicitely parse it again
22:44:54 <ksf> I'd have to re-start _all_ parsing.
22:44:59 <mmorrow> right
22:46:10 <ksf> but still it'd be cool if ghc could discard the result of an evaluation.
22:46:20 <ksf> ...referentially transparent.
22:46:34 <copumpkin> oh, the real weak references thing?
22:46:39 <mmorrow> it can't if you still have a reference to some piece of the result
22:46:40 <int-e> it /would/ be cool to have a tearOff# :: a -> a. I'm not sure it can be implemented though.
22:46:53 <copumpkin> it would need heuristics
22:46:53 <ksf> sure it can, as it can regenerate the data.
22:47:00 <copumpkin> and some way of tracking accesses
22:47:06 <ksf> ...so you still have access to the results.
22:47:27 <mmorrow> ksf: that's not lazy eval anymore though
22:47:34 <int-e> (the idea being that tearOff# (A a b) becomes A (tearOff# a) (tearOff# b), and the same for AP and PAP nodes. It will interact badly with unsafePerformIO, but that's to be expected.
22:47:49 <ksf> not as we currently have it, no.
22:47:55 <copumpkin> you'd have the runtime say "hmm, I need to clean up. this var got accessed 200 times recently so I'm not going to clean it up, but this one only got accessed once, so I'll clean it up and make it into an unevaluated thunk again"
22:48:05 <ksf> in that stuff could be evaluated multiple times. only if memory gets tight, though.
22:48:12 <ksf> ...I think that's better than failing.
22:48:59 <mmorrow> ok, so lets work through this (to see if it's feasible)
22:49:15 * mmorrow is interested in fleshing this out
22:49:38 <mmorrow> let x = parseACrapload (s::ByteString)
22:49:53 <ksf> for a part of the heuristic, the gc can collect info about how much data is behind a ref.
22:49:55 <mmorrow> case x of (a,b) -> (f a b, g a b)
22:50:00 <mmorrow> err,
22:50:08 <mmorrow> let (y,z) = case x of (a,b) -> (f a b, g a b)
22:50:26 <ksf> mmorrow, make it simple: a memotable of a call to naive fib.
22:50:42 <mmorrow> what is "x" here then?
22:50:48 <mmorrow> let x = parseACrapload (s::ByteString)
22:51:13 <mmorrow> we need to define "x" for any example i think
22:51:35 <mmorrow> that's the most basic part of this whole thing, right?
22:51:35 <ksf> x is either an evaluated or an unevaluated thunk
22:51:41 <mmorrow> what's its type
22:51:45 <ksf> doesn't matter.
22:51:45 <mmorrow> is what i mean
22:51:54 <mmorrow> we're working through an example
22:51:57 <ksf> (let's not think of IO a right now)
22:52:03 <mmorrow> where's IO?
22:52:10 <mmorrow> s :: ByteString
22:52:15 <ksf> nowhere. we're in purity heaven.
22:52:20 <mmorrow> parseACrapLoad :: ByteString -> a
22:52:29 <mmorrow> what's "a"? (for the sake of our example)
22:52:34 <mmorrow> (s is mmaped)
22:52:35 <ksf> just a sec
22:52:37 <mmorrow> pped
22:53:17 <Peaker> @where rwh
22:53:17 <lambdabot> is http://www.realworldhaskell.org/blog/
22:53:21 <Peaker> where's the PDF?
22:53:21 <mmorrow> say x is (Int,Int)
22:53:38 <mmorrow> err, no because that's useless here
22:53:55 <copumpkin> Peaker: I've never seen one
22:54:04 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10711#a10711
22:54:37 <ksf> ...where tagData, tagSpine and tagSpine' are backed by the same bytestring, btw.
22:54:42 <Peaker> copumpkin, there's definitely a pdf :)
22:54:50 <mmorrow> ksf: so (s :: ByteString) is of static size (since you cannot grow mmapped files)
22:54:52 <copumpkin> Peaker: well, I've never seen one then :)
22:54:57 <ksf> ...or rather part of a huge mmaped bytestring.
22:55:22 <ksf> depends on nesting level, of course, and the structure of the ebml file.
22:55:25 <mmorrow> ksf: so you're imagining that you're computing x lazily i'm assuming
22:55:40 <ksf> I'm not only imagining that, I'm doing it.
22:56:00 <mmorrow> so say x :: [Int]
22:56:18 <ksf> mmorrow, does it matter what type it has?
22:56:31 <ksf> as long it's got a spine we can do something with it.
22:56:40 <mmorrow> yes, since if it's :: Int, then our example is pretty pointless
22:56:47 <mmorrow> right
22:57:08 <mmorrow> let y = head x
22:57:25 <ksf> ...while retaining a pointer to x.
22:57:26 <mmorrow> ... something with x ... an hour ... something with y
22:57:42 <mmorrow> so what exactly are you imagining being reverted?
22:57:53 <ksf> (which, btw, I always retain because the parser has access to the data it produces)
22:58:21 <ksf> some data that takes up a lot of space and hasn't been accessed (a lot) lately.
22:58:23 <mmorrow> so if you ever revert `y', you'll need to start parsing all over then
22:58:28 <mmorrow> ?
22:58:37 <mmorrow> s/y/head x/
22:58:49 <int-e> let y = x !! 100000000 may be a better example.
22:58:58 <mmorrow> yeah, true
22:58:58 <ksf> well the idea is to revert x and retain y.
22:59:30 <ksf> while doing that index, we see that we don't have enough memory to hold the spine between the current position of !! and x
22:59:56 <ksf> ...so we're transforming x into an unevaluated thunk, deleting a pointer in the gc root.
22:59:57 <int-e> so you expect the RTS to retain information about how y was being produced, some sort of snapshot of unevaluated thunks. how many and which ones are you going to keep?
23:00:10 <ksf> ...so the gc can collect everything up to the position of the !!
23:00:20 <ksf> ...at which point we should have enough ram to continue indexing.
23:00:48 <mmorrow> ("collecting" something is just not copying it to the new heap area)
23:01:02 <Axman6> hmm
23:01:09 <int-e> (which is why I'd rather investigate the feasibility of a tearOff# primitive. then you could say y = tearOff# x !! 100000000 and the tearOff# would tell the RTS which thunk you want to keep around.)
23:01:12 <mmorrow> but it'll need to retain some info about it
23:01:27 <Axman6> trying to figure out how to write a B-tree in haskell is more difficult that i had imagined
23:01:38 <mmorrow> yeah, int-e's way seems massively simpler semantically
23:02:05 <ksf> well I'm describing the operational behaviour that I'd like to see.
23:02:18 <ksf> ...whether it's done automatically or manually doesnt' really matter
23:02:19 <mmorrow> ksf: i'm having trouble even imagining how you'd go about implementing what you're after
23:02:57 <ksf> well, we can go unevaled thunk -> evaled thunk, so I imagine we could also go evaled thunk -> unevaled thunk
23:03:19 <mmorrow> ksf: all a thunk is is a pair (infoptr,ptr)
23:03:27 <mmorrow> evaluating a thunk does
23:03:45 <ksf> the next force of the thunk would then just not get the evaled value, but construct it again.
23:04:07 <mmorrow> \(infoptr,ptr) -> ptr := followandeval ptr; infoptr := IND;)
23:04:19 <int-e> evaluating a thunk destroys the thunk by updating it with a black hole, and later by the result or an indirection pointing to the result.
23:04:21 <mmorrow> so the thunk is destroyed
23:04:43 <mmorrow> and upon a GC, that IND node is also eliminated from the heap
23:04:48 <ksf> I don't have any idea about the impl details
23:05:06 <Axman6> anyone ever written a B-tree algorithm in haskell before?
23:05:08 <ksf> ...but I'd be surprised if the asm that generated the data is nuked.
23:05:23 <int-e> ksf: the function arguments are gone
23:05:26 <int-e> those are data.
23:05:41 <Axman6> s/algorithm/implementation
23:05:48 <ksf> argh yes.
23:06:03 <ksf> ...so revaluation would propagate.
23:06:10 <mmorrow> right
23:06:14 <int-e> ksf: besides, you don't even know which function generated a result.
23:07:14 <ksf> ...so, basically I can nuke my code.
23:07:31 <int-e> you'll have to make reevaluation explicit.
23:07:45 <ksf> well I'm retaining pointers _inside_ the parser.
23:08:15 <ksf> it's got to be able to inspect another part of the file that the one it's currently parsing.
23:08:58 <mmorrow> ksf: i think the real question here is about the data-dependencies in the "x" we're generating
23:09:36 <mmorrow> if (x!!n) depends of (x!!(n-1))
23:09:46 <mmorrow>  vs. if all the (x!!i) are indep
23:10:12 <ksf> the former.
23:10:19 <mmorrow> :o
23:10:29 <ksf> ...but you can do a lot of useful things without ever stumbling across such a dependency.
23:11:04 <ksf> in ebml files a field can default to the prior occurence of that field.
23:11:58 <ksf> ...and before parsing it I can't tell whether I'm going to need that prior value, I might not need to default it because the field is present in the container.
23:12:58 <mmorrow> this seems like it'd be extremely non-trivial to implement (in order to handle arbitrary cases)
23:13:06 <ksf> it is.
23:13:13 <mmorrow> maybe even impossible
23:13:23 <ksf> well you could error out because there is none.
23:14:18 <ksf> in practice, I'd say that every mkv file comes with the field defined in the first container that can contain it. sequential parsers will pick it up and remember.
23:14:21 <mmorrow> i think whether it's possible or not would depend on whether the data-dependencies are statically determinable or not (maybe)
23:14:50 <ksf> it's "default to the last occurence of the field".
23:14:56 <int-e> If you're unlucky, you have to parse the whole file up to that point to find the previous reference, right? It might be anywhere.
23:15:01 <mmorrow> that, or massive runtime overhead (but this is just me trying to imagine how to go about this)
23:15:05 <ksf> I can statically analyze all possible paths to that field.
23:15:12 <ksf> int-e, right.
23:15:29 <ksf> mkv files will be written smartly enough, though.
23:15:38 <ksf> it's just like video and keyframes.
23:16:19 * ksf makes a note to implement that in the writer.
23:16:35 <int-e> Okay, that's food for thought for the weekend. I'll try to get some work done now.
23:17:10 <ksf> I guess I'm going to abandon my current path and re-investigate iteratees, again.
23:17:45 <ksf> I've just discovered that btrfs supports cow of arbitrary bytes in a file, that's a great prospect for editing huge chunks of data.
23:18:17 <ksf> (witness how much I care about platform independence...)
23:18:27 <copumpkin> ksf: fwiw, edwardk was also interested in something similar to what you're describing. You might want to talk to him when he reappears
23:19:03 <ksf> the dumping still-referenced data thing?
23:19:22 <copumpkin> yeah
23:20:12 <mmorrow> ksf: the crux of this seems to me to be having the runtime figure out automatically how to do this behind the scenes, and to make it completely transparent to your program
23:20:52 <mmorrow> it seems like the choice of what to dump will almost certainly depend on dynamic information
23:20:53 <ksf> sure.
23:20:55 <performance> Configuring the editline-0.2.1.0 package failed <- while trying to build the haskell-platform
23:21:20 <performance> 2009.2.0.2 with ghc 6.10.4
23:21:22 <ksf> well I'd be able to say "this thing is going to produce a lot of data, so you better remember its arguments"
23:21:26 <mmorrow> and if the data-dependencies aren't statically known, they'll need to be computed on-the-fly
23:22:02 <mmorrow> it's more than just arguments though, since you'll be dumping bits and pieces of the heap
23:22:25 <mmorrow> and hopefully doing so in such a way that minimizes work needed to regenerate them
23:22:32 <performance> is that a haskell package or a linux package?
23:23:01 <ksf> haskellline is the pure haskell implementation.
23:23:26 <ksf> editline are the bindings to libedit
23:23:32 <ksf> (which is not the same as readline)
23:23:44 <ksf> http://www.thrysoee.dk/editline/
23:24:07 <performance> hmm, i got it from my distro repo now :) hopefully this is the last error
23:24:24 <performance> any idea how long the haskell_platform takes to build ?
23:24:52 <ksf> ghc takes ages
23:24:54 <performance> my machine has 2GB RAM and has 2 > 2GHz cores AthlonX2
23:25:00 <ksf> the rest should be quite quick
23:25:15 <ksf> there's binaries, though.
23:25:22 <performance> its ironic that to compile ghc, you need ghc :)
23:25:33 <ksf> indeed.
23:26:15 <ksf> the ghc guys _could_ provide .c files generated by compiling ghc. it's got a c backend, too.
23:26:45 <mmorrow> ksf: it might be interesting to look into how numeric libraries multiply e.g. 100,000x100,000 matrices
23:26:46 <performance> yeah, i wish they did :)
23:26:58 <mmorrow> ksf: (the do it from disk)
23:27:03 <mmorrow> *they
23:27:09 <Twey> I find myself in need of a Word7.
23:27:21 <Twey> Does such a thing exist?
23:27:57 <performance> parsec is not a shift/reduce parser right?
23:27:59 <ksf> if you've got mmap and the whole stuff fits into your address range than it's going to be quite straight-forward.
23:28:06 <copumpkin> Twey: 7 bits?
23:28:14 <Twey> Yes
23:28:16 <ksf> if not, it's going to involve a lot of seeking.
23:28:25 <ksf> ...and manual chunking.
23:28:33 <copumpkin> data Word7 = Word7 Bit Bit Bit Bit Bit Bit Bit
23:28:34 <copumpkin> yay
23:28:39 <mmorrow> ksf: i'm almost positive that that's not a very efficient way to do it :)
23:28:41 <Twey> Heh, ow
23:28:57 <Twey> … is that really how Words are defined?
23:29:00 <ksf> well you can do the seeking with mmap, too.
23:29:27 <copumpkin> Twey: nope
23:29:30 <copumpkin> they're defined in terms of primitives
23:29:32 <Twey> Oh :þ
23:29:35 <copumpkin> and no 7-bit primitive exists :P
23:29:47 <mmorrow> ksf: e.g. http://moonpatio.com/repos/MISC/fft-misc/cwp/bigmatrix.c
23:29:48 <ksf> performance, nope.
23:29:54 <FunctorSalad_> Twey: newtype Word8?
23:29:56 <ksf> it's not a parser generator, at all.
23:30:07 <Twey> FunctorSalad_: I guess.
23:30:10 <FunctorSalad_> or do you really need tightly packed word7s
23:30:19 <Twey> No, not particularly.
23:30:25 <ksf> it's rather an utterly convenient way to implement hand-written top-down parsers.
23:30:31 <Twey> I mean, I'd *like* one, but I can get by.
23:31:42 <performance> ksf, thanks
23:31:52 <ksf> ...if you want a parser generator, there's happy.
23:32:01 <ksf> and alex for lexing
23:32:09 <performance> build seems to be going fine, i'll go to bed and then see if its done by tomroow morning :)
23:32:34 <performance> aha now it makes sense, i asked 'coz the build log had messages indicating shit/reduce conflicts
23:32:45 <performance> and i remember seeing those names too alex and happy
23:39:32 <ksf> mmorrow, I can't control data layout, and can assume that a file layout fits common usage patterns.
23:56:53 <Twey> Hmm
23:58:26 * Twey sometimes wishes for comparable functions.
23:59:02 <Twey> They might not make sense from a philosophical standpoint, but they certainly can be useful.
