00:02:48 <ketil> https://launchpad.net/~ketil-ii/+archive/ppa
00:03:07 <ketil> Anybody on Karmic want to try to install this, and tell me whether it works? :-)
00:03:20 * ketil 's first debian package.
00:14:03 <Orclev> is there a version of (**) for integrals?
00:14:24 <reima> :t (^^)
00:14:25 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
00:14:47 <Orclev> > 2 ^^ 3
00:14:48 <lambdabot>   8.0
00:15:02 <Orclev> hmm... not quite what I was looking for
00:15:05 <reima> Oh well
00:15:43 <reima> :t (^)
00:15:44 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:16:00 <Orclev> > 2 ^ 3
00:16:01 <lambdabot>   8
00:16:19 <Orclev> ah, I thought (^) was binary xor or something like that in haskell
00:16:39 <reima> No, that's just xor
00:17:30 <Cale> There are three exponentiation operators, corresponding to three separate definitions of exponentiation in mathematics
00:17:38 <Cale> (they are differently polymorphic)
00:21:26 <c_wraith> Hmm.  A function returning STM (IO ()) probably indicates I'm doing it wrong, huh?
00:22:05 <Saizan_> nah
00:22:35 <Saizan_> unless you want that action to execute before the transaction commits
00:22:42 <c_wraith> Not at all.
00:22:54 <c_wraith> I just want to construct the action within the transaction
00:23:06 <c_wraith> I'm fine with it executing afterwards
00:23:06 <Saizan_> then it's perfectly fine
00:23:09 <stanv> hhmm, does Vim highligh haskell code in Literate Haskell Script (.lhs) ? In my case comments in .lhs same colors as haskell code (starting with >)
00:23:12 <stanv> ?
00:23:16 <Saizan_> ?type join . atomically
00:23:17 <lambdabot> Not in scope: `atomically'
00:23:29 <c_wraith> And yeah, I know I'd need to join the result. :)
00:24:20 <Saizan_> heh, being able to pass around IO actions as values is what makes haskell the best imperative language around :)
00:26:13 <Saizan_> (i wonder how you do that in DDC, they have a type for computations maybe?)
00:26:51 <stoop> Any Haskellers in the DC area?
00:27:13 <stoop> Please no references to FringeDC.
00:28:33 <Saizan_> ah, no they use "\() -> .." like in ocaml
00:28:34 <dolio> () -> () with an IO effect is kind of like IO ().
00:29:48 <Saizan_> i must confess that i hate that idiom with a passion.
00:33:42 <dolio> Well, you could make a 'type IO a = () -e-> a' and then write some handy functions for combining them, like 'm >> n = \() -> m () ; n ()' ...
00:33:48 <dolio> Oh wait, we're back to using monads then. :)
00:35:06 <opqdonut> dolio: har har :)
00:36:27 <trofi> @pl \(a,b) -> [a..b]
00:36:27 <lambdabot> uncurry enumFromTo
00:36:58 <trofi> @pl (\a b -> [a..b]) (minBound :: T) (maxBound :: T)
00:36:58 <lambdabot> [minBound :: T..maxBound :: T]
01:38:11 <c_wraith> @hoogle catch
01:38:11 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
01:38:11 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
01:38:11 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
01:39:25 <c_wraith> @instances Exception
01:39:26 <lambdabot> Couldn't find class `Exception'. Try @instances-importing
01:39:36 <c_wraith> @instances-importing Exception
01:39:37 <lambdabot> Couldn't find class `Exception'. Try @instances-importing
01:47:29 <Saizan_> @instances-importing Control.Exception Exception
01:47:30 <lambdabot> ArithException, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitely, BlockedOnDeadMVar, Deadlock, ErrorCall, IOException, NestedAtomically, NoMethodError, NonTermination, PatternMatch
01:47:30 <lambdabot> Fail, RecConError, RecSelError, RecUpdError, SomeException
02:19:44 <FunctorSalad_> sigfpe: "Now I want to restrict things even further to the most boring kind of 1PG of all, games where the successor moves are all totally ordered. ... In these games there are no branches, the only thing you can do in these games is delay the inevitable. A bit like life really."
02:20:18 <Saizan_> heh
02:21:57 <FunctorSalad_> can't we take a happier metaphor for ordinal numbers? ;)
02:23:28 <Twey> Heheheh.
02:23:53 <FunctorSalad_> ( http://blog.sigfpe.com/2008/10/whats-use-of-transfinite-ordinal.html )
02:24:09 <FunctorSalad_> actually I think Saizan_ posted that some hours ago
02:36:35 <Saizan_> yup, you got there indipentendly, or?
02:38:21 <FunctorSalad_> probably not
02:50:56 <Saizan_> isn't it weird that we can use transfinite induction on the limit of the sequence of naturals to prove an algorithm terminates, and yet last [1..] = _|_ ?
02:51:38 <Saizan_> (i'm not saying that there's an inconsistency)
02:53:21 <dolio> It corresponds pretty naturally to induction on an embedding of ordinals you can create in, say, Agda.
02:54:37 <dolio> data O : Set where z : O ; s : O -> O ; lim : (Nat -> O) -> O
02:55:59 <Cale> Funny how lim's type is mildly suggestive of double negation...
02:57:21 <Saizan_> especially if you interpret O = 0 = Void :)
02:57:27 <Cale> right
02:58:57 <Cale> Apparently that only gets you a tiny fragment of the ordinals which exist in ZFC.
02:59:38 <dolio> Well, of course, since only countably many ordinals live in that type. :)
03:00:16 <dolio> And there are too many ordinals to even fit in a set. :)
03:00:26 <ski> would the ordinals in that type be computably enumerable ?
03:01:09 * Saizan_ would like a more contructive phrasing of these cardinality arguments
03:01:14 <FunctorSalad_> but wait! you mean in a model of type theory? then it's true in ZFC too
03:01:19 <FunctorSalad_> regarding countability
03:03:03 <FunctorSalad_> (i.e., there are countable models of ZFC, so the class of ordinals is of course countable too there)
03:03:10 <Saizan_> e.g. is there a termination proof i couldn't write in agda because that O is too small?
03:03:24 <Cale> You certainly can't get the Church-Kleene ordinal, as it's the smallest ordinal which is not the order type of any recursive well-ordering of the integers.
03:04:22 <FunctorSalad_> with the classical axiom?
03:04:40 <FunctorSalad_> (comparing classical zfc to intu. type theory isn't fair ;))
03:04:46 <Cale> FunctorSalad_: I mean, with that definition of O
03:05:20 <FunctorSalad_> ah... I don't know how much of a restriction that 'nat there is
03:06:56 <Cale> Hmm... can we write  O -> (Nat -> Nat -> Ordering)  which realises the ordinal as a particular well-ordering of Nat?
03:07:34 <FunctorSalad_> I'm confused about the intensional part vs. what is true in models here
03:09:14 <Cale> It's not really very meaningful to say that there are only countably many ordinals because there's a countable model of ZFC. The reason that model is there is because our proofs are all finite on a finite alphabet, so we can only discuss countably many things really.
03:09:50 <FunctorSalad_> I didn't mean to say that
03:10:14 <Cale> Well... I know, I'm just taking a shot in the dark about what the confusion might be?
03:10:26 <dolio> Amusingly enough, the guy in that n-category cafe was claiming that that countable, definable model is the one most mathematicians "intend" to be working with.
03:10:26 <FunctorSalad_> I meant that maybe that datatype isn't any different from the ZFC def of 'ordinal', in that some models are countable and some aren't
03:10:43 <Cale> ah
03:11:06 <Cale> dolio: that's odd
03:11:11 <FunctorSalad_> but I don't even know what exactly agda models look like
03:11:15 <Cale> dolio: I really doubt that
03:11:24 <FunctorSalad_> (I suppose it has a straightforward set model because it's predicative...?)
03:11:47 <dolio> Yeah, I doubt most mathematicians think of that as the primary interpretation of ZFC, either.
03:11:54 <dolio> Although I can't say I really know that many.
03:12:15 <FunctorSalad_> (and total)
03:12:37 <Saizan_> so there's no way to prove that some set is of uncountable cardinality in ZFC?
03:13:07 <PetRat> I'm trying to use the Rand monad to make infinite series, but it doesn't work... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10847#a10847  ... if you just think about how the state would pass from computation to computation obviously it's not going to work.
03:13:10 <Cale> There is.
03:13:15 <dolio> Well, you can't prove that the reals are countable from within the countable model.
03:13:24 <FunctorSalad_> you can prove uncountability in ZFC but the object logic is just kidding itself
03:14:10 <FunctorSalad_> (the formula intended to mean "the set R is uncountable" is provable, but it means something different in the countable model)
03:14:17 <Cale> Saizan_: It's just that there's a way to take a countable set (of things whose structure we don't care about) and call the elements of that set your "sets" and define a 'belongs to' relation on that set of "sets" which satisfies the ZFC axioms.
03:14:50 <FunctorSalad_> it's all about the object-level vs. the metalevel here
03:15:39 <Saizan_> Cale: ah, i see, the model doesn't give an explicit structure to these "sets" so it doesn't matter
03:20:00 <PetRat> I'm trying to use the Rand monad to make infinite series, but it doesn't work... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10847#a10847  ... if you just think about how the state would pass from computation to computation obviously it's not going to work.
03:20:19 <Cale> PetRat: right.
03:20:48 <PetRat> Is there a way to do what I'm trying to do in a simple way?
03:21:14 <Cale> That's what MonadSplit is for, you can get a split of the generator state using getSplit
03:21:29 <Cale> and then use System.Random.randomRs or whatever
03:21:53 <Cale> Er, oh, right
03:22:10 <Cale> There's also primitives for getting infinite sequences of random values
03:22:15 <Cale> getRandoms
03:22:20 <Cale> getRandomRs
03:22:25 <FunctorSalad_> why doesn't it work?
03:22:43 <PetRat> Yes there are getRandoms, getRandomsR but I want to define my own distribution.
03:22:44 <Cale> You can write those in terms of getSplit, but you couldn't write them just with getRandom/getRandomR
03:23:01 <FunctorSalad_> too strict?
03:23:13 <dolio> Yeah. sequence . repeat.
03:23:21 <dolio> That fails in a lot of monads.
03:23:36 <Cale> FunctorSalad_: You'd have to get all the way to the end of an infinite chain of data dependencies
03:23:38 <FunctorSalad_> so you'd need a breadth-first random monad, like omega is to lists?
03:23:59 <Cale> maybe
03:25:24 <PetRat> so I need to write getMyRandoms (equivalent to getRandoms) making use of MonadSplit somehow?
03:31:12 <Cale> PetRat: I suppose what you can do is define a function   getDists x = do g <- getSplit; return (runRand (sequence . repeat $ x) g)
03:31:36 <Cale> There's probably a better name for it than that.
03:32:33 <FunctorSalad_> PetRat: delete the 'sequence's you have now, and put the monadic stuff into makeSeriesHelp
03:33:13 <PetRat> FunctorSalad_: does that really solve the problem without needing split?
03:33:22 <FunctorSalad_> I think so
03:33:43 <FunctorSalad_> (you'd pass [Rand StdGen Int] rather than [Int])
03:34:11 <Cale> "A different definition uses Kleene's system of ordinal notations: briefly, an ordinal notation is either the name zero (describing the ordinal 0), or the successor of an ordinal notation (describing the successor of the ordinal described by that notation), or a Turing machine (computable function) which produces an increasing sequence of ordinal notations (describing the ordinal which is the limit of the sequence), a
03:34:11 <Cale> nd ordinal notations are (partially) ordered so as to make the successor of o greater than o and to make the limit greater than any term of the sequence (this order is computable; however, the set O of ordinal notations itself is highly non-recursive, owing to the impossibility of deciding whether a given Turing machine does indeed produce a sequence of notations); a recursive ordinal is then an ordinal which is descr
03:34:12 <Cale> ibed by some ordinal notation.
03:34:14 <Cale> Any ordinal smaller than a recursive ordinal is itself recursive, so the set of all recursive ordinals forms a certain (countable) ordinal, the Church-Kleene ordinal."
03:35:03 <Cale> So our O is in some sense the Church-Kleene ordinal :)
03:37:10 <dolio> That O actually isn't adequate, as that paragraph points out.
03:37:39 <dolio> What you actually need is to define O by induction-recursion along with the ordering.
03:37:40 <Cale> hmm
03:38:10 <dolio> And then 'lim : (f : Nat -> O) ((m n : Nat) -> m < n -> f m < f n) -> O'
03:38:43 <Cale> oh, I'm not sure if you want to do that though...
03:38:47 <Cale> hmm
03:39:04 <dolio> To ensure that f is monotone.
03:39:22 <Cale> If you insist that there's a proof that the function is monotone, do you perhaps get a different set of things?
03:39:37 <Cale> I guess not
03:40:07 <dolio> Well, O obviously isn't right, because there are elements that don't correspond to an ordinal. I don't know if the one with the proof is adequate or not.
03:42:33 <Saizan_> in the Kleene definition above using a turing machine that doesn't halt (i.e partial function) doesn't count as an ordinal, right?
03:42:56 <Cale> right
03:43:23 <Cale> But we're also not insisting on a proof that it halts...
03:44:01 <dolio> Well, all (non-pink) Agda functions halt, so we already have that. :)
03:44:54 <Cale> Well, it might be a bit smaller, but it's certainly no larger than omega_CK, anyway
03:46:30 <Cale> I suspect that if the language in which you write the Nat -> O functions which are the parameters to lim isn't Turing complete, then you will always miss some additional ordinals which terminate, but you can't prove that they do.
03:47:10 <render[r]> .
03:47:54 <Cale> So in Haskell, the set of actual ordinals in O would be omega_CK, but of course, you're not forced to actually prove that they're good when you make them.
03:48:41 <ksf> zomg maudes mixfix is amazing
03:48:44 <Saizan_> too small or too large :)
03:48:48 <ksf> you can do op __ : List List -> List .
04:17:43 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
04:17:43 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
04:17:56 <ivanm> ksf: right, that's a set oc sets (if you're saying lists are sets)
04:17:57 <ksf> in set theory, it's sets all the way down. there's nothing else.
04:18:03 <ivanm> oh, OK...
04:18:13 <ivanm> so when we say things like "a set of integers", that isn't set theory?
04:18:20 <Cale> Well, it might be
04:18:23 <ksf> no I'm just using [] because I don't have to push down shilft, then.
04:18:24 <ivanm> just like in lambda calculus, it's functions all the way down?
04:18:26 <Cale> because we can build the integers from sets
04:18:29 <ivanm> ksf: heh
04:18:52 <ivanm> Cale: from peano, etc.?
04:19:01 <Cale> There will be an axiom later which almost hands us the natural numbers for free.
04:19:07 <ivanm> OK, my brain hurts _slightly_ less then...
04:19:15 <Cale> 0 will be the empty set, and n will be n union {n}
04:19:17 <Cale> er
04:19:19 <Cale> 0 will be the empty set, and n+1 will be n union {n}
04:19:36 <ksf> that's a monoid!
04:20:20 <ksf> er no.
04:20:23 <ksf> n+n would be.
04:20:54 <HugoDaniel1> hello fellow haskellers
04:21:35 <Cale> Okay, what's next... let's throw in powerset next
03:54:31 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
03:54:31 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
03:54:34 <Irv> i'm being particularly dense, working with Data.ConfigFile; I've got a function of type IO ConfigParser, and i want to run get on it, which has a signature of (Get_C a, Control.Monad.Error.Class.MonadError CPError m) => ConfigParser -> SectionSpec -> OptionSpec -> m a
03:54:57 <Irv> i guess i've got lift get into the IO monad but i'm smart enough to resolve it exactly
03:55:00 <benmachine> ivanm: it happens more or less everywhere, except here
03:55:06 <Axman6> yeah, they don't seem to understand what's homework and what's understanding or just not something a university would look down on you for doing
03:55:36 <ivanm> benmachine: so, is that because of the language or the type of people drawn to the language?
03:55:50 <FliPPeh> Probably
03:55:50 <ivanm> or because of the unofficial policy, etc. set up by the original #haskellers?
03:55:57 <benmachine> ivanm: the latter is because of the former, I think
03:56:00 <FliPPeh> Java attracts a lot of students and enterprisers
03:56:09 <FliPPeh> Whereas C seems more like the "professionals"
03:56:25 <benmachine> I think there is something about haskell in particular which attracts people who don't hate everyone
03:56:26 <FliPPeh> And Haskell attracts those who have fun programming, I presume.
03:56:27 <ivanm> benmachine: which latter versus which former? :p
03:56:33 <ivanm> I had 3 different propositions there ;-)
03:56:43 <ivanm> FliPPeh: s/professionals/masochists/
03:56:46 <ivanm> ftfy ;-)
03:56:48 <benmachine> ivanm: in response to your first message i.e. people are because of language
03:56:51 <napsy_> FliPPeh: it doesn't "attract" ... many times you're forced to use it
03:56:54 <ivanm> benmachine: ahhh
03:57:15 <ivanm> Haskell: the programming language of peace, love and understanding
03:57:17 <ivanm> ;-)
03:57:43 <benmachine> indeed
05:51:57 <Saizan_> Irv: you can use liftIO on your IO ConfigParser action, and do-notation
05:51:59 <FliPPeh> Is there an intelligent/elegant way of defining a for loop in Haskell?
05:52:13 <FliPPeh> Or some more "haskellish" way? :)
05:52:19 <benmachine> FliPPeh: depends what you mean by a for loop
05:52:37 <benmachine> :t forM
05:52:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:52:38 <FliPPeh> for (float f = min; min <= max; min += step)
05:52:41 <napsy_> FliPPeh: functional languages use recursion for iteration
05:52:44 <Saizan_> Irv: do cp <- liftIO ioConfigParser; get cp x y
05:52:56 <FliPPeh> No lists
05:52:56 <Irv> Saizan_: ah awesome
05:53:02 <FliPPeh> Just plain numbers
05:53:03 <SamB_XP_> fortunately, in Haskell you don't have to write the recursion structure every time ;-)
05:53:04 <benmachine> napsy_: well, usually they get a library to do the iteration itself
05:53:04 <FliPPeh> for (float f = min; min <= max; min += step)
05:53:10 <benmachine> er
05:53:12 <benmachine> recursion
05:53:21 <SamB_XP_> FliPPeh: didn't you hear?
05:53:25 <nha_> map whatever [min..max]
05:53:27 <SamB_XP_> lists are now a control structure!
05:53:47 <ksf> > sum [0.1,0.4...2.4]
05:53:47 <lambdabot>   Not in scope: `...'
05:53:51 <ksf> > sum [0.1,0.4..2.4]
05:53:52 <lambdabot>   11.7
05:53:57 <FliPPeh> nha_: that doesn't include the stepping :)
05:53:58 <Veinor> The best way to define a for loop in haskell is not to.
05:53:59 <Veinor> :D
05:54:05 <FliPPeh> Thought so
05:54:20 <ksf> @src sum
05:54:20 <lambdabot> sum = foldl (+) 0
05:54:23 <FliPPeh> I'm still struggling when it comes to looping, I only used "forever" so far :/
05:54:26 <ksf> @src foldr
05:54:26 <lambdabot> foldr f z []     = z
05:54:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:54:30 <nha_> what stepping
05:54:32 <napsy_> Hm just wondering ... was there any attempt to implement an OS with haskell?
05:54:37 <ksf> (me bets it's actually either a foldr or foldl')
05:54:38 <SamB_XP_> napsy_: attempt?
05:54:56 <napsy_> if there's a project
05:54:57 <FliPPeh> nha: it should go from 10 to 20, stepping 4. 10 -> 14 -> 18 -> STOP
05:55:00 <ksf> napsy_, theer's house
05:55:10 <benmachine> > [10, 14 .. 20]
05:55:11 <lambdabot>   [10,14,18]
05:55:21 <FliPPeh> Hm.
05:55:25 <FliPPeh> Haskell is too awesome.
05:55:30 <FliPPeh> Why didn't I think about that?
05:55:43 <Botje> overdose of awesome
05:55:50 <benmachine> FliPPeh: be careful of doing that syntax with fractional though
05:55:54 <benmachine> it is a bit funny
05:56:08 <FliPPeh> Ahhh
05:56:12 <benmachine> > [0.1, 0.4, 2.0]
05:56:12 <SamB_XP_> benmachine: oh, it's fine as long as it's not a float ...
05:56:13 <FliPPeh> I'm using fractions, damnit :)
05:56:13 <benmachine> er
05:56:13 <lambdabot>   [0.1,0.4,2.0]
05:56:16 <benmachine> > [0.1, 0.4 .. 2.0]
05:56:17 <lambdabot>   [0.1,0.4,0.7000000000000001,1.0,1.2999999999999998,1.5999999999999996,1.899...
05:56:22 <FliPPeh> Floats, that is
05:56:23 <benmachine> no that's not helpful
05:56:26 <benmachine> > last [0.1, 0.4 .. 2.0]
05:56:27 <lambdabot>   1.8999999999999995
05:56:29 <benmachine> there we go
05:56:32 <benmachine> no we don't
05:56:35 <nha_> i think the reason people here arent total dicks is because the learning curve for haskell is the way it is. Its pretty hard to get the impression that you know everything there is to know about it.
05:56:35 <benmachine> I've confused myself now
05:56:37 <ksf> yep. succ of a float should be the next representable number, not the next whole-number increment.
05:56:46 <benmachine> > last [0.1, 0.4 .. 1.0]
05:56:47 <Veinor> > succ 0.1
05:56:47 <lambdabot>   1.0
05:56:48 <lambdabot>   1.1
05:56:50 <SamB_XP_> > last [0.2, 0.4 .. 2.0]
05:56:51 <lambdabot>   2.0
05:56:52 <ksf> enum is, after all, an ordered set.
05:56:57 <benmachine> ohh, whatever
05:56:58 <SamB_XP_> > last [0.2, 0.4 .. 3.0]
05:56:59 <lambdabot>   3.000000000000001
05:57:12 <SamB_XP_> > last [0.2, 0.3 .. 4.0]
05:57:13 <lambdabot>   3.999999999999991
05:57:18 <Axman6> o.O
05:57:21 <benmachine> FliPPeh: floats are a bit odd in all languages because of imprecision
05:57:23 <poe> > last [1%10, 4%10 .. 2%1]
05:57:23 <SamB_XP_> hmm ...
05:57:24 <lambdabot>   19 % 10
05:57:33 <fxr> how can I get the file descriptor of a handle in ghc-6.12?
05:57:33 <FliPPeh> > [10.2, 14.2 .. 20]
05:57:34 <benmachine> 0.1 is not exactly representable in binary, after all
05:57:35 <lambdabot>   [10.2,14.2,18.2]
05:57:45 <FliPPeh> > [10.1, 14.2 .. 20]
05:57:46 <lambdabot>   [10.1,14.2,18.299999999999997]
05:57:56 <FliPPeh> I'm fine with mine, the stepping is an integer
05:58:01 <ksf> fxr, System.Posix iirc
05:58:11 <FliPPeh> The [x, y .. z] syntax will work for me :)
05:58:12 <FliPPeh> Thanks
05:58:17 <nha_> fxr: theres a way on win32 too but i cant remember off the top of my head
05:58:24 <nha_> to get the handle or whatever
05:58:47 <Veinor> what's the best way to do stepping in haskell for the general float, then?
05:58:48 <Exteris> benmachine: how about expressing floats as rational numbers
05:58:54 <SamB_XP_> nha_: to get a win32 HANDLE, you mean
05:58:58 <Veinor> as opposed to [0.2, 0.3, .. 4.0]
05:59:11 <fxr> I'm using whithHandle_ to get Handle__ type but couldn't figure out how to extract the FD
05:59:30 <ksf> > [0.2, 0.3,.. 1] :: [CReal]
05:59:31 <lambdabot>   <no location info>: parse error on input `..'
05:59:36 <ksf> > [0.2, 0.3,..1] :: [CReal]
05:59:36 <lambdabot>   <no location info>: parse error on input `..'
05:59:39 <ksf> > [0.2, 0.3..1] :: [CReal]
05:59:40 <lambdabot>   [0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
05:59:44 <SamB_XP_> which is basically more or less the same thing as a file descriptor, except without the special meanings for 0, 1, and 2, and being incompatible with whatever "file descriptors" your C library provides for *nix compatability
05:59:50 <int-e> so pred infinity = 1.7976931348623157e308? That will curl a few stomachs.
06:00:08 <Veinor> And that's why I hate floating point math.
06:00:10 <SamB_XP_> int-e: says who?
06:00:23 <SamB_XP_> > pred (1/0)
06:00:25 <lambdabot>   Infinity
06:00:26 <int-e> SamB_XP_: that's the largest representable double less than infinity.
06:00:43 <SamB_XP_> int-e: well, as you can see, the pred/succ law is instead falsified ;-P
06:01:09 <int-e> > (pred . succ) (1/0) == (1/0)
06:01:10 <lambdabot>   True
06:01:13 <benmachine> Exteris: that would work fine
06:01:14 <SamB_XP_> @quickCheck (pred . succ) x == (x :: Float)
06:01:15 <lambdabot> Unknown command, try @list
06:01:21 <SamB_XP_> @check (pred . succ) x == (x :: Float)
06:01:22 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
06:01:31 <SamB_XP_> @check \x -> (pred . succ) x == (x :: Float)
06:01:32 <lambdabot>   "Falsifiable, after 21 tests:\n-0.33333334\n"
06:01:34 <napsy_> > last[10**(-1), 10**(-2), 10**(-3)]
06:01:35 <lambdabot>   1.0e-3
06:01:37 * benmachine glosses over the contradiction
06:01:50 <SamB_XP_> hehehe
06:02:05 <napsy_> it works
06:02:06 <napsy_> :)
06:02:07 <Exteris> benmachine: isn't that easier to use for stepping over floats then? (though probably computationally more expensive)
06:02:13 <Exteris> Veinor: ^^
06:02:26 <SamB_XP_> actually, I'm not sure if (succ (largest possible Float)) is infinity
06:02:51 <SamB_XP_> > succ 1.7976931348623157e308 :: Float
06:02:52 <benmachine> Exteris: very possible
06:02:52 <lambdabot>   Infinity
06:02:59 <SamB_XP_> > 1.7976931348623157e308 :: Float
06:03:00 <lambdabot>   Infinity
06:03:02 <ksf> enums tend to wrap, don't they?
06:03:06 <SamB_XP_> > 1.7976931348623157e308 :: Double
06:03:07 <lambdabot>   1.7976931348623157e308
06:03:10 <ksf> after all, there's Bounded...
06:03:10 <SamB_XP_> > succ 1.7976931348623157e308 :: Double
06:03:11 <lambdabot>   1.7976931348623157e308
06:03:13 <benmachine> > pred Infinity
06:03:14 <lambdabot>   Not in scope: data constructor `Infinity'
06:03:20 <SamB_XP_> > [1.7976931348623157e308 .. ]:: Double
06:03:21 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
06:03:22 <lambdabot>         against inferred ty...
06:03:23 <Exteris> > succ  1.7976931348623157e309 :: Double
06:03:24 <lambdabot>   Infinity
06:03:31 <SamB_XP_> > [1.7976931348623157e308 .. ] :: [Double]
06:03:32 <lambdabot>   [1.7976931348623157e308,1.7976931348623157e308,1.7976931348623157e308,1.797...
06:04:00 <SamB_XP_> > drop 100000 [1.7976931348623157e308 .. ] :: [Double]
06:04:01 <lambdabot>   [1.7976931348623157e308,1.7976931348623157e308,1.7976931348623157e308,1.797...
06:04:02 <Axman6> > pred 1.7976931348623157e309 :: Double
06:04:03 <lambdabot>   Infinity
06:04:11 <SamB_XP_> > drop 100000000000 [1.7976931348623157e308 .. ] :: [Double]
06:04:14 <Axman6> > succ 1.7976931348623157e309 :: Double
06:04:15 <lambdabot>   Infinity
06:04:15 <lambdabot>   mueval-core: Time limit exceeded
06:04:19 <SamB_XP_> > drop 1000000000 [1.7976931348623157e308 .. ] :: [Double]
06:04:20 <int-e> Axman6: it's 308 not 309
06:04:21 <Axman6> > 1.7976931348623157e309 :: double
06:04:22 <lambdabot>   Could not deduce (GHC.Real.Fractional double) from the context ()
06:04:22 <lambdabot>    arisin...
06:04:23 <lambdabot>   mueval-core: Time limit exceeded
06:04:24 <benmachine> > succ 1e300 == 1e300
06:04:26 <lambdabot>   True
06:04:31 <Irv> Saizan_: OK, so i stuck forceEither in there, like this do cp <- liftIO getConfig; forceEither $ get cp cSection cItem
06:04:31 <SamB_XP_> > drop 100000000 [1.7976931348623157e308 .. ] :: [Double]
06:04:33 <benmachine> could be a problem there.
06:04:34 <Irv> and not i ed up with this
06:04:35 <lambdabot>   mueval-core: Time limit exceeded
06:04:37 <FliPPeh> Okay, so, [10, 14 .. 20] results in [10, 14, 18], but why does [10.0, 14.0 .. 20.0] result in [10.0, 14.0, 18.0, 22.0]?
06:04:38 <SamB_XP_> > drop 10000000 [1.7976931348623157e308 .. ] :: [Double]
06:04:40 <lambdabot>   [1.7976931348623157e308,1.7976931348623157e308,1.7976931348623157e308,1.797...
06:04:41 <FliPPeh> It goes one step further
06:04:41 <Axman6> int-e: well, i just copied and pasted it
06:05:00 <SamB_XP_> FliPPeh: well, you see, the float instance is crazy one way or the other!
06:05:04 <FliPPeh> That should be no akward floating there
06:05:09 <FliPPeh> :(
06:05:09 <SamB_XP_> or double
06:05:20 <Axman6> > 1.7976931348623157e308 :: Double
06:05:20 <lambdabot>   1.7976931348623157e308
06:05:28 <Axman6> > pred 1.7976931348623157e308 :: Double
06:05:29 <lambdabot>   1.7976931348623157e308
06:05:36 <SamB_XP_> FliPPeh: maybe they made some stupid hack to avoid wierdness when the range should have been evenly divided
06:05:42 <benmachine> FliPPeh: the flp instance of Enum is strange
06:05:50 <FliPPeh> Oh well
06:05:51 <benmachine> a lot of people think, broken
06:05:59 <FliPPeh> Need to find something else
06:06:03 <SamB_XP_> I think I remember seeing a suggestion on a list about that in the past year ...
06:06:09 <napsy_> doesn't haskell use IEEE 754?
06:06:15 <Irv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10851#a10851
06:06:18 <SamB_XP_> napsy_: no
06:06:21 <ksf> I guess that pred doesn't work because the delta gets swallowed at that scale.
06:06:22 <SamB_XP_> implementations tend to
06:06:31 <napsy_> ok
06:06:32 <SamB_XP_> because that tends to be what CPUs offer
06:06:41 <int-e> > [(2^53-10) * 2^(1024-53),(2^53-9) * 2^(1024-53)..] :: [Double]
06:06:42 <lambdabot>   [1.797693134862314e308,1.7976931348623141e308,Infinity,Infinity,NaN,NaN,NaN...
06:06:49 <FliPPeh> What I'm trying to do is having a temperature of Celcius, and for each temperature from minimum to maximum, display it converted in Fahrheit.. in a string of the form "10 C = 50F"
06:06:50 <FliPPeh> :(
06:07:01 <Axman6> > (iterate succ 1.7976931348623157e308) !! 1000 :: Double
06:07:02 <lambdabot>   1.7976931348623157e308
06:07:03 <SamB_XP_> napsy_: surprisingly, the report *does* define an isIEEE function to ask whether the implementation does or not
06:07:10 <FliPPeh> Converting THIS program: http://www.cprogramming.com/challenges/celsius_converter_table.html
06:07:22 <SamB_XP_> :t isIEEE
06:07:22 <Saizan_> Irv: it seems you've some problems with indentation, can you annotate with the code?
06:07:24 <lambdabot> forall a. (RealFloat a) => a -> Bool
06:07:32 <Irv> sure
06:07:33 <ksf> FliPPeh, just use CReal and don't worry.
06:07:39 <trofi> > isIEEE 1
06:07:39 <lambdabot>   True
06:07:44 <napsy_> hm ok
06:07:46 <Saizan_> Irv: are you sure you aren't mixing tabs and spaces? that tends to be a nightmare
06:07:51 <SamB_XP_> trofi: it works better if you use a specific type ;-P
06:07:54 <Axman6> > 1/3 :: CReal
06:07:55 <lambdabot>   0.3333333333333333333333333333333333333333
06:08:04 <FliPPeh> > 1/3 :: Double
06:08:04 <SamB_XP_> :t isIEEE (1 :: CReal)
06:08:05 <lambdabot>   0.3333333333333333
06:08:06 <lambdabot> Bool
06:08:10 <SamB_XP_> > isIEEE (1 :: CReal)
06:08:12 <lambdabot>   False
06:08:16 <SamB_XP_> > isIEEE (1 :: Float)
06:08:17 <lambdabot>   True
06:08:20 <SamB_XP_> > isIEEE (1 :: Double)
06:08:21 <int-e> > iterate (+2^(1024 - 53)) ((2^53-2) * 2^(1024-53)) :: [Double]
06:08:21 <lambdabot>   True
06:08:22 <lambdabot>   [1.7976931348623155e308,1.7976931348623157e308,Infinity,Infinity,Infinity,I...
06:08:27 <Axman6> > showCReal 100 (1/3)
06:08:28 <lambdabot>   "0.333333333333333333333333333333333333333333333333333333333333333333333333...
06:08:29 <SamB_XP_> > isIEEE (1 :: CDouble)
06:08:30 <lambdabot>   Not in scope: type constructor or class `CDouble'
06:08:38 <SamB_XP_> > isIEEE (1 :: Foreign.C.Types.CDouble)
06:08:38 <Irv> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10851#a10852
06:08:39 <lambdabot>   Not in scope: type constructor or class `Foreign.C.Types.CDouble'
06:08:46 <SamB_XP_> aww :-(
06:09:21 <SamB_XP_> oh, right, this is not :type so I can't use random shit
06:09:54 <ksf> > let fahr c = (9 * c) / 5 + 32 in map fahr [10,12..30] :: [CReal]
06:09:55 <lambdabot>   [50.0,53.6,57.2,60.8,64.4,68.0,71.6,75.2,78.8,82.4,86.0]
06:09:59 <SamB_XP_> hmm, would be neat if isIEEE was defined at the *type* level so I could check it for random shit in theory ...
06:10:08 <trofi> :t random
06:10:08 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:10:18 <ksf> > let fahr c = (9 * c) / 5 + 32 in map fahr [0,12..38] :: [CReal]
06:10:19 <lambdabot>   [32.0,53.6,75.2,96.8]
06:10:29 <SamB_XP_> :t (1 :: Foreign.C.Types.CDouble)
06:10:30 <lambdabot> Foreign.C.Types.CDouble
06:10:38 <SamB_XP_> yeah, it would even work ;-)
06:11:12 <ksf> FliPPeh, CReals have as much precision as you need.
06:11:46 <benmachine> so do Integers
06:11:52 <benmachine> and Data.Ratio
06:11:58 <Saizan_> Irv: i think you need to give a type annotation to your use of get
06:12:01 <benmachine> I think all of those may serve your purposes
06:12:05 <SamB_XP_> the difference being that Integers and Ratio have decidable equality ;-)
06:12:10 <benmachine> depending on what they are
06:12:27 <Saizan_> Irv: which was the type of get, again?
06:12:46 <SamB_XP_> hmm, I wonder if you can do anything with Ratios over Galois Fields ...
06:12:53 <Irv> Saizan_: (Get_C a, Control.Monad.Error.Class.MonadError CPError m) => ConfigParser -> SectionSpec -> OptionSpec -> m a
06:13:02 <SamB_XP_> no, guess not, those are already fields ...
06:13:14 <FunctorSalad_> SamB_XP_: "anything"?
06:13:34 <FliPPeh> Hey, I got it working!
06:13:43 <FliPPeh> Without CReals and strange list ranges
06:13:55 <FliPPeh> !hpaste
06:14:00 <FliPPeh> Ahh!
06:14:03 <ksf> @hpaste
06:14:03 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:14:06 <FliPPeh> Phew!
06:14:15 <benmachine> hey, Rational is broken too
06:14:18 <Saizan_> ?type forceEither
06:14:19 <SamB_XP_> FliPPeh: did you map fromIntegral over a list?
06:14:19 <lambdabot> Not in scope: `forceEither'
06:14:22 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4415#a4415
06:14:22 <SamB_XP_> benmachine: hmm?
06:14:25 <Saizan_> Irv: and forceEither?
06:14:26 <FliPPeh> Nope
06:14:31 <FliPPeh> Look at my code :)
06:14:34 <benmachine> > [1 % 2, 2 % 3 .. 10 % 9]
06:14:35 <lambdabot>   [1 % 2,2 % 3,5 % 6,1 % 1,7 % 6]
06:14:41 <benmachine> 7 % 6 > 10 % 9
06:14:45 <benmachine> > 7 % 6 > 10 % 9
06:14:46 <lambdabot>   True
06:14:49 <FliPPeh> 18.0		64.399994
06:14:51 <SamB_XP_> benmachine: eww
06:14:55 <benmachine> it is a precise type it has no excuse >:|
06:14:58 <FliPPeh> Quick, how do I round?
06:14:58 <Irv> Saizan_: forceEither :: (Show e) => Either e a -> a
06:15:05 <FliPPeh> > round 64.399994
06:15:06 <lambdabot>   64
06:15:08 <benmachine> @src Real
06:15:09 <lambdabot> class  (Num a, Ord a) => Real a  where
06:15:09 <lambdabot>     toRational      ::  a -> Rational
06:15:11 <FliPPeh> Not that :(
06:15:12 <SamB_XP_> benmachine: hate mail to libraries@
06:15:26 <benmachine> @src RealFrac
06:15:27 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
06:15:27 <SamB_XP_> and Bcc naesten@gmail.com ;-)
06:15:27 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
06:15:27 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
06:15:28 <benmachine> there we go
06:15:35 <Saizan_> Irv: oh, forcEither won't work there then
06:16:03 <Saizan_> Irv: because the Either monad is not a MonadIO, so you can't use liftIO in it
06:16:07 <FliPPeh> I want to round to the next decimal
06:16:16 <FliPPeh> 64.39994 -> 64.40
06:16:47 <Saizan_> Irv: but you can just stick in IO and unwrap the Either on the spot
06:16:50 <benmachine> > let rnd = (/100) . round . (*100) in rnf 64.39994
06:16:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:16:52 <benmachine> er
06:16:52 <lambdabot>    `GHC.Real.Integral a'
06:16:52 <lambdabot>   ...
06:16:55 <benmachine> > let rnd = (/100) . round . (*100) in rnd 64.39994
06:16:56 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:16:56 <lambdabot>    `GHC.Real.Integral a'
06:16:56 <lambdabot>   ...
06:17:00 <benmachine> waat
06:17:01 <ksf> FliPPeh, ceiling
06:17:03 <Irv> Saizan_: oh OK
06:17:07 <ksf> > ceiling 0.3
06:17:07 <lambdabot>   1
06:17:15 <ksf> > floor 0.9
06:17:16 <lambdabot>   0
06:17:24 <ksf> > floor (-0.1)
06:17:25 <FliPPeh> I need the floating points :/
06:17:25 <lambdabot>   -1
06:17:28 <ksf> > floor (-0.9)
06:17:29 <lambdabot>   -1
06:17:35 <benmachine> > let rnd = (/100) . fromIntegral . round . (*100) in rnd 64.39994
06:17:37 <lambdabot>   64.4
06:17:40 <Saizan_> Irv: like, do cp <- getConfig; return . forceEither $ get cp cSection cItem
06:17:48 <ksf> oh. you want showFFloat.
06:17:52 <ksf> import Numeric
06:17:55 <ksf> :t showFFloat
06:17:56 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
06:18:30 <ksf> > showFFloat (Just 4)  64.399998 ""
06:18:31 <lambdabot>   "64.4000"
06:18:40 <ksf> > showFFloat (Just 4)  64.3999 ""
06:18:41 <lambdabot>   "64.3999"
06:18:44 <ksf> > showFFloat (Just 4)  64.39991 ""
06:18:46 <lambdabot>   "64.3999"
06:18:48 <ksf> > showFFloat (Just 4)  64.39995 ""
06:18:49 <FliPPeh> > showFFloat (Just 2) 64.3999
06:18:49 <lambdabot>   "64.4000"
06:18:50 <lambdabot>   ""->
06:18:50 <lambdabot>    "64.40"
06:18:50 <lambdabot>  "a"->
06:18:50 <lambdabot>    "64.40a"
06:18:51 <lambdabot>  "aa"->
06:18:53 <lambdabot> [3 @more lines]
06:18:55 <FliPPeh> What's the "just" for?
06:19:07 <ksf> > showFFloat Nothing  64.39995 ""
06:19:08 <lambdabot>   "64.39995"
06:19:13 <ksf> > showFFloat Nothing  64.39995423534534654 ""
06:19:14 <FliPPeh> Oh
06:19:14 <lambdabot>   "64.39995423534535"
06:19:16 <FliPPeh> The precission?
06:19:19 <Athas> :t showFloat
06:19:20 <lambdabot> forall a. (RealFloat a) => a -> String -> String
06:19:21 <ksf> yep
06:19:25 <FliPPeh> Ah nice :D
06:19:27 <Athas> :t showFFloat
06:19:28 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
06:19:39 <Athas> Neato.
06:19:43 <FliPPeh> showFFloat (Just 2) f == "%.2f"
06:20:08 <ksf> the other possibility is to scale before and after rounding, but that sucks, numerically.
06:20:10 <Athas> No obscenities please.
06:20:19 <jimi_hendrix> is there a way to multiply a list like you can in python
06:20:31 <FliPPeh> Multiplay?
06:20:38 <FliPPeh> multiply*
06:20:44 <FliPPeh> map (*3) list ?
06:20:47 <ksf> jimi_hendrix, element-wise?
06:20:50 <napsy_> jimi_hendrix: [x * 2 | x <- array]
06:20:56 <FliPPeh> > map (*3) [1 .. 5]
06:20:58 <lambdabot>   [3,6,9,12,15]
06:21:04 <trzkril> > replicate 3 "-"
06:21:04 <lambdabot>   ["-","-","-"]
06:21:05 <ksf> > product [1..9]
06:21:06 <lambdabot>   362880
06:21:08 <Athas> Do you mean to repeat the elements in the list?
06:21:20 <FliPPeh> 3 different proposals
06:21:21 <FliPPeh> Nice
06:21:23 <benmachine> > concat . replicate 4 $ [1,2,3]
06:21:24 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3]
06:21:27 <FliPPeh> 4
06:21:32 <Irv> Saizan_: OK i think i got it, it's taking some getting used to, for me to get the difference between wanting a value of of impure code and lifting pure code into impure to get a value
06:21:37 <Irv> Saizan_: thanks for your help
06:21:37 <jimi_hendrix> oh ofc those sets, always forget
06:21:44 <FliPPeh> Haskell is a strange language :)
06:21:48 <SamB_XP_> benmachine: wait, actually, I guess bcc-ing me on the email would possibly be quite inneffective?
06:21:49 <FliPPeh> One problem, 100 solutions
06:21:49 <jimi_hendrix> Athas, ya
06:21:51 <Saizan_> Irv: np :)
06:22:08 <jimi_hendrix> benmachine, what does the . do there
06:22:14 <Athas> jimi_hendrix: try combining concat and replicate.
06:22:15 <ksf> > iterate [1..4]
06:22:16 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
06:22:23 <Athas> > concat $ replicate 4 [1,2,3]
06:22:24 <arvind> i've been listening to software engineering radio ep 108 Simon Peyton Jones on Functional Programming and was listening to the part on lazy evaluation
06:22:24 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3]
06:22:25 <ksf> > cycle [1..4]
06:22:26 <lambdabot>   [1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,...
06:22:34 <benmachine> SamB_XP_: erm, ineffective at what?
06:22:40 <benmachine> jimi_hendrix: glues functions together
06:22:53 <jimi_hendrix> ok
06:22:53 <ksf> :t (.)
06:22:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:23:06 <ksf> ouch.
06:23:09 <jimi_hendrix> ?
06:23:10 <ksf> @undef (.)
06:23:11 <Athas> jimi_hendrix: I advice you to look at all the functions that don't do what you asked for as well, they're really much more interesting.
06:23:12 <benmachine> f . g $ x = f (g x)
06:23:14 <ksf> :t (.)
06:23:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:23:20 <benmachine> ksf: heh, blame Cale
06:23:24 <jimi_hendrix> and what does the $ do again?
06:23:31 <arvind> he mentioned that a closure was passed during a function call instead of evaluation of arguments before function call
06:23:31 <ksf> :t ($)
06:23:32 <benmachine> $ is just function application
06:23:32 <lambdabot> forall a b. (a -> b) -> a -> b
06:23:32 * jimi_hendrix tried it with and without the $ and without it errors
06:23:36 <benmachine> f $ x = f x
06:23:37 <ksf> @src ($)
06:23:37 <lambdabot> f $ x = f x
06:23:40 <arvind> what exactly is a closure
06:23:41 <ksf> @src (.)
06:23:41 <lambdabot> (f . g) x = f (g x)
06:23:44 <benmachine> well
06:23:47 <arvind> i couldn't make much sense from wikipedia
06:23:59 <jimi_hendrix> Athas, lol
06:23:59 <benmachine> f $ x is actually more like (f) (x) if f and x are expressions
06:24:08 <jimi_hendrix> ok
06:24:33 <benmachine> $ is good for not using so many parentheses
06:24:57 <Athas> The function should really look like this:
06:25:03 <ksf> learn you a haskell for great $ $ $
06:25:13 <jimi_hendrix> tried replicate (4) ([1,2,3]), errored with: Couldn't match expected type `a -> [[a1]]' against inferred type `[[t]]'
06:25:14 <Athas> > dupl x = concat . replicate x
06:25:15 <lambdabot>   <no location info>: parse error on input `='
06:25:22 <arvind> essentially all variables in haskell are free variables correct?
06:25:24 <Athas> Well, it should.
06:25:34 <Athas> arvind: er, by what reasoning?
06:25:55 <benmachine> > (concat . replicate 4) [1,2,3]
06:25:57 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3]
06:26:09 <ksf> :t replicate 4
06:26:10 <lambdabot> forall a. a -> [a]
06:26:13 <ksf> :t concat
06:26:14 <lambdabot> forall a. [[a]] -> [a]
06:26:19 <ksf> :t concat . replicate 4
06:26:20 <lambdabot> forall a. [a] -> [a]
06:26:23 <arvind> Athas: all variables are global right due to static nature?
06:26:35 <benmachine> jimi_hendrix: not enough parentheses :)
06:26:55 <benmachine> they need to enclose the entire expression to the left of the list
06:27:01 <benmachine> or, you can use $ instead
06:27:09 <benmachine> which is clearer
06:27:12 <Athas> arvind: I'm a little confused by your terminology, maybe.  But in the expression '\x -> x + x', for instance, there are no free variables.
06:27:21 <fxr> openFile :: FilePath -> IOMode -> IO (FD,IODeviceType) does the trick
06:27:27 <ksf> jimi_hendrix, note that the a of replicate becomes [a], so the [a] of replicate becomes [[a]]
06:27:45 <ksf> ...as otherwise, the types wouldn't match up.
06:27:59 <benmachine> arvind: the obvious response to a question starting "all free variables" is "what variables?" :P
06:28:22 <arvind> benmachine: good point "what variables"
06:28:47 <ksf> if you look at the whole program, no variables are free.
06:28:49 <Twey> ‘Free variables’ and ‘global variables’ are completely different concepts with no relation
06:29:15 <jimi_hendrix> ok
06:29:16 <arvind> but in the lambda expression '\x -> x + x', x's restricted to the lambda expression alone right?
06:29:18 <Twey> And Haskell has no global variables.  ☺
06:29:25 <Athas> arvind: yes, it's statically scoped.
06:29:31 <arvind> no other function outside it can access it right?
06:29:36 <benmachine> Twey: unsafePerformIO newIORef?
06:29:37 <ksf> foo = unsafePerformIO newIORef
06:29:42 <arvind> so that does mean it's a local variable correct?
06:29:44 <benmachine> I win
06:29:48 <ksf> arvind, right.
06:30:06 <benmachine> arvind: except that it doesn't vary
06:30:13 <Twey> benmachine, ksf: *Haskell* has no global variables.  IO can be done to mimic them — you can write them to a file, or whatever.
06:30:18 <SamB_XP_> benmachine: at getting the email to show up in my inbox as opposed to being relegated merely to some tag
06:30:22 <benmachine> Twey: haskell has IO?
06:30:24 <ksf> in \x -> f x , f is a free variable.
06:30:28 <Twey> Or use memory, as with IORefs.
06:30:35 <benmachine> SamB_XP_: oh, okay
06:30:40 <ksf> ...which is resolved by lexical scoping
06:30:42 <Twey> benmachine: Well, it has an IO monad.  :þ
06:30:45 <ksf> (or the compiler errors out)
06:30:47 <benmachine> SamB_XP_: I'm not entirely sure I was going to bother writing an email anyway
06:31:03 <SamB_XP_> honestly I haven't figured out rhyme or reason to how that works anyway :-(
06:31:16 <arvind> ksf:ok that helps a lot to understand
06:32:37 <benmachine> Twey: I dunno, but I think that writing information to memory and then retrieving them isn't really mimicking variables
06:32:44 <benmachine> so much as, being them
06:32:50 <Athas> arvind: we don't like "local variable" so much, though.  Not because it's inaccurate, but because "local variable" means a mutable binding in other languages.
06:32:52 <ksf> ...but haskell _has_ global variables. as all you guys always call bindings variables, top-level bindings are obviously top-level i.e. global variables.
06:33:15 <Athas> They're not variable.
06:33:20 <benmachine> ksf: I don't! I've been saying what variables all along
06:33:39 <ksf> that's why they're bindings.
06:33:42 <Athas> A top-level binding never changes its value.
06:33:53 <ksf> a local binding neither.
06:33:57 <Athas> Neither do other bindings, of course, but they look like they do if you squint.
06:34:07 <ksf> there's a separate function for every value.
06:34:11 <benmachine> stop squinting it is bad for you
06:34:28 <arvind> so what exactly is meant by the fact that "a closure is a first class function with free variables that are bound in a lexical environment"?
06:34:54 <jimi_hendrix> and is there a magic function to magically shuffle a list
06:34:57 <Athas> That not all variables in the closure body are the formal parameters of the function.
06:35:29 <ksf> that means that you can pass \x -> f x somewhere and the f that's in scope at the definition of that lambda is used, not the one that's in scope where the lambda is applied.
06:35:31 <Athas> Take 'foo x = \y -> x + y'.  In the closure '\y -> x + y', x is technically free.
06:35:38 <int-e> jimi_hendrix: http://hackage.haskell.org/package/random-shuffle ?
06:36:38 <benmachine> int-e: interesting, looks like hackage tried to parse // sequences as <i></i>
06:36:43 <ksf> otherwise, you'd have dynamic scope, which is generally considered to be a bad joke that some mathematican wanted to play on programmers, as he invented lisp.
06:36:49 <Jafet> Names are bound when they are used, not when their values are used
06:36:55 <benmachine> ruined the url in the process
06:37:35 <arvind> lazy evaluation means that unless absolutely necessary the arguments are not evaluated. what does it have to do with a closure?
06:37:51 <FunctorSalad_> benmachine: it's haddock markup
06:38:29 <ksf> there's no run-time closure in the lisp or say java sense in haskell
06:38:38 <Athas> ksf: actually, I think the story is that John McCarthy simply misunderstood the rules for beta-reduction in the lambda calculus.
06:38:53 <jimi_hendrix> int-e, now how do i install that?
06:39:06 <ksf> there's partially applied functions, which semantically don't exist (due to currying), just at run-time, and then there's a lot of thunks
06:40:15 <ksf> I think you might want to read this: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
06:41:32 <jimi_hendrix> so how do i install a module
06:41:46 <ksf> you don't, you install packages
06:42:20 <ksf> ah. cabal install random-shuffle
06:42:34 <Athas> cabal install acme-now
06:42:39 <Athas> The only package you'll ever need.
06:42:48 <jimi_hendrix> acme-now?
06:42:54 <ksf> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
06:47:30 <jimi_hendrix> ok, installed, now what does this mean: "b*** Exception: src/System/Random/Shuffle.hs:(52,6)-(55,30): Non-exhaustive patterns in function shuffleTree
06:48:17 <Saizan_> 1that shuffleTree is not defined for the input you gave it
06:48:20 <SamB_XP_> jimi_hendrix: looks like a bug in the module System.Random.Shuffle
06:48:54 <jimi_hendrix> i tried: > shuffle ['a','b','c'] [1,2,3]
06:50:10 <jimi_hendrix> so what do i do now :)
06:52:57 <en0th> can i use guards into a case option ?
06:53:44 <benmachine> en0th: you can do something with case and guards but I'm not sure I can remember how it works
06:53:59 <benmachine> something like case a of
06:54:04 <benmachine>  b | p -> x
06:54:09 <benmachine>    | q -> y
06:54:16 <benmachine>  c -> z
06:54:39 <en0th> mm i tried to put guards after -> ..
06:54:55 <benmachine> I think you put them in between patterns and ->s
06:55:48 <en0th> ok, but i guess it's not very clean.. i wonder how to write in another way
06:56:28 <benmachine> to help you with that I'd have to know what you're writing
06:57:53 <en0th> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4416#a4416
06:58:03 <en0th> i'm translating directly from scheme code
06:58:27 <benmachine> you can do that with function equations directly
06:58:28 <benmachine> like
06:58:38 <Peaker> @hoogle Applicative f => f a -> f b -> f a
06:58:38 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
06:58:38 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
06:58:38 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
06:58:57 <benmachine> subst expr@(ENum n) idn nexpr = expr
06:59:51 <jimi_hendrix> so, what do you guys recommend if System.Random.Shuffle is bugging on me
06:59:59 <benmachine> subst expr@(EId i) idn nexpr | i == idn = nexpr | otherwise = expr
07:00:00 <benmachine> etc.
07:00:42 <en0th> okay ^^
07:01:28 <benmachine> you only need to do the expr@ thing when you actually use expr in the RHS
07:01:53 <benmachine> subst (EAdd e1 e2) idn nexpr = EAdd (...
07:02:19 <Peaker> @pl (\id -> State.modify (id `Map.insert` x))
07:02:20 <lambdabot> (line 1, column 26):
07:02:20 <lambdabot> unexpected "`"
07:02:20 <lambdabot> expecting variable, "(", operator or ")"
07:02:28 <Peaker> @pl (\id -> State.modify (id `insert` x))
07:02:28 <lambdabot> State.modify . (`insert` x)
07:07:03 <sohum> @hoogle a -> (a->b,a->c,a->d) -> (b,c,d)
07:07:03 <lambdabot> No results found
07:07:19 <sohum> @hoogle (a->b,a->c,a->d) -> a -> (b,c,d)
07:07:20 <lambdabot> No results found
07:08:03 <sohum> @pl \x -> (f x, g x, h x)
07:08:04 <lambdabot> ap (liftM2 (,,) f g) h
07:08:07 <benmachine> :t uncurry3
07:08:09 <lambdabot> Not in scope: `uncurry3'
07:08:11 <benmachine> hmm
07:08:39 <benmachine> bah
07:08:42 <benmachine> tuples suck.
07:10:09 <kw317> how can I get ghc to output c-- code?
07:10:44 <poe> -ddump-cmm
07:11:02 <kw317> cool, thanks
07:11:12 <poe> (check out man ghc)
07:11:25 <Baughn> Check chapter 4.16 of the user guide, specifically
07:11:29 <Baughn> "Debugging the compiler"
07:11:33 <kw317> OK
07:11:48 <benmachine> ghc has a man?
07:11:57 <benmachine> I don't have one :(
07:12:07 <poe> benmachine: what platform?
07:12:16 <benmachine> err, arch linux
07:12:27 <Peaker> so ghc has a C/evil-mangler backend, a C-- backend, and a native code backend?
07:12:47 <Baughn> It's not exactly C--
07:12:56 <Baughn> I'm pretty sure the last two are the same backend
07:15:36 <jimi_hendrix> haskell has no side effects right
07:15:49 <kw317> what I'm interested in is getting cmm output for small code snippets
07:16:29 <sohum> @pl \x (i,j,k) → (i,j,(x,k))
07:16:30 <lambdabot> (line 1, column 8):
07:16:30 <lambdabot> unexpected ","
07:16:30 <lambdabot> expecting letter or digit, operator or ")"
07:16:30 <lambdabot> ambiguous use of a non associative operator
07:17:01 <sohum> @pl \x (i,j,k) -> (i,j,(x,k))
07:17:02 <lambdabot> (line 1, column 8):
07:17:02 <lambdabot> unexpected ","
07:17:02 <lambdabot> expecting letter or digit, operator or ")"
07:17:02 <lambdabot> ambiguous use of a non associative operator
07:17:11 <FunctorSalad_> I've never seen that error
07:17:19 <Peaker> haste is cool.. so much faster than using the web interface
07:17:34 <Peaker> shows you how big of a bottleneck the browser really is
07:17:52 <FunctorSalad_> I'd google that for me if it was possible
07:18:06 <Peaker> lmgtfy?
07:18:24 <FunctorSalad_> I mean I can't google 'haste' - was it it? :)
07:18:31 <FunctorSalad_> *what is it
07:19:04 <Peaker> FunctorSalad_, http://tinyurl.com/yjymk9w
07:19:38 <FunctorSalad_> hah! I have previews enabled on tinyurl =)
07:19:51 <jimi_hendrix> i cant set some element of a list to something else right
07:20:04 <Peaker> https://launchpad.net/haste <-- this is the one though
07:20:10 <Peaker> FunctorSalad_, :-)
07:20:24 <Peaker> FunctorSalad_, I just couldn't resist "google that for me" there
07:21:44 <jimi_hendrix> so can i or can i not do that?
07:23:12 <maltem> jimi_hendrix, we don't exactly forbid it
07:23:22 <jimi_hendrix> we dont?
07:23:54 <jimi_hendrix> maltem, go on...
07:24:00 <FunctorSalad_> Peaker: cool it works
07:24:18 <maltem> jimi_hendrix, what's what you want to do, exactly?
07:24:44 <Peaker> FunctorSalad_, its pretty cute. much faster than copy & opening new & paste, & clicking & waiting for render
07:25:00 <Peaker> FunctorSalad_, web browser is a bottleneck
07:25:05 <FunctorSalad_> <Main.hs | cat | cat | cat | hpaste
07:25:16 <FunctorSalad_> arghl cut that first pipe
07:25:48 <jimi_hendrix> maltem, swapt two elements place
07:26:36 <Athas> jimi_hendrix: you can create a new list where the elements are swapped.  That's functional programming.
07:27:02 <jimi_hendrix> true
07:27:06 <Athas> Whether or not Haskell has side effects becomes a discussion of semantics (the boring natural-language kind), but you can usually assume either "yes" or "no" for whatever purpose you have in mind.
07:27:09 <jimi_hendrix> how would i get a slice of a list
07:27:41 <jimi_hendrix> Athas, ^
07:27:42 <maltem> > case [1..10] of (x:y:ys) -> (y:x:ys)
07:27:43 <lambdabot>   [2,1,3,4,5,6,7,8,9,10]
07:27:59 <Athas> Take a look at http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
07:28:01 <jimi_hendrix> now explain that in english
07:28:03 <maltem> jimi_hendrix, that's how you swap the first two elements, e.g.
07:28:06 <Athas> Maybe you will find other useful functions too.
07:28:21 <jimi_hendrix> i think i see...
07:28:35 <Athas> The Haskell standard libraries are nicely saturated with all kinds of handy utility functions (quite unlike the SML I had to use recently, I might add).
07:29:27 <Peaker> jimi_hendrix, take/drop
07:29:28 <jimi_hendrix> maltem, how would i swap the 3rd and the 8th
07:29:35 <Peaker> > take 3 . drop 5 $ [1..10]
07:29:36 <lambdabot>   [6,7,8]
07:29:57 <jimi_hendrix> oo
07:29:58 <Peaker> jimi_hendrix, are you trying to swap guitar strings?
07:30:08 <FunctorSalad_> > splitAt 8 [1..10]
07:30:09 <lambdabot>   ([1,2,3,4,5,6,7,8],[9,10])
07:30:14 <FunctorSalad_> etc
07:30:15 <maltem> 12-string guitar?
07:30:24 <jimi_hendrix> Peaker, yes
07:30:58 <jimi_hendrix> maltem, since i have ascended to rock heaven, i have an epic 40 string guitar
07:31:04 <FunctorSalad_> maybe you want a Map or something, not a list
07:31:11 <lvh> Hi! What's the reccomended way for writing networking apps that can handle a few thousand concurrent connections? (I googled and found a paper, but it was back from 2000 and used Concurrent Haskell -- perhaps the situation has changed since then)
07:31:12 <FunctorSalad_> Map Int Foo
07:31:18 <Peaker> @let nth 0 f (x:xs) = f x : xs ; nth n f (x:xs) = x : nth (n-1) f xs
07:31:19 <lambdabot>  Defined.
07:31:27 <Peaker> > nth 5 (const 10) [1..10]
07:31:29 <lambdabot>   [1,2,3,4,5,10,7,8,9,10]
07:31:37 <FunctorSalad_> the you'd do mapKeys (\i -> if i == 3 then 8 else if i==8 then 3 else i)
07:31:40 <maltem> jimi_hendrix, swapping the 3rd and 8th is more to type, so, er, let's leave that as an exercise for you. Anyways, keep in mind that Haskell lists are linked lists, so accessing the nth element is O(n)
07:31:42 <lvh> I can't seem to find any async IO-based event loops, for example.
07:32:13 <mauke> lvh: threads
07:32:16 <Peaker> @let setnth n val = nth n (const val)
07:32:17 <lambdabot>  Defined.
07:32:18 <skorpan> lvh: i'm thinking `forever' with `forkIO'
07:32:24 <jimi_hendrix> maltem, ok, so can i get a hint at what functions to look at
07:32:31 <lvh> I'm thinking of this thing: http://www.haskell.org/~simonmar/papers/web-server.ps.gz
07:32:41 <Athas> jimi_hendrix: the easiest thing would probably be a plain recursive implementation.
07:32:44 <Peaker> > let swap5_8 xs = setnth 5 (xs!!8) . setnth 8 (xs!!5) $ xs
07:32:45 <lambdabot>   not an expression: `let swap5_8 xs = setnth 5 (xs!!8) . setnth 8 (xs!!5) $ ...
07:32:45 <lvh> It seems to confuse CPU time concurrency with concurrent connections and IO
07:32:50 <Peaker> > let swap5_8 xs = setnth 5 (xs!!8) . setnth 8 (xs!!5) $ xs in swap5_8 [1..10]
07:32:51 <lambdabot>   [1,2,3,4,5,9,7,8,6,10]
07:32:52 <lvh> mauke: what, thread-per-conn?
07:32:56 <mauke> lvh: yes
07:33:02 <maltem> The *easiest* thing is a pattern match, rather.
07:33:10 <Peaker> > let swap5_8 xs = setnth 5 (xs!!8) . setnth 8 (xs!!5) $ xs in swap5_8 [0..9]
07:33:10 <lambdabot>   [0,1,2,3,4,8,6,7,5,9]
07:33:25 <Peaker> jimi_hendrix, See that ^^ ?
07:33:29 <FunctorSalad_> Map Int Foo, I say
07:33:30 <jimi_hendrix> ya
07:33:40 <Peaker> jimi_hendrix, did you follow it?
07:33:48 <lvh> mauke: Do you know of any people who've tried to benchmark (or even better: write real software) with that?
07:34:08 <lvh> mauke: I ask merely because real thread-per-conn designs tend to get eaten alive in other languages.
07:34:15 <mauke> lvh: no, but I've written a Haskell program that spawned >100000 threads
07:34:20 <jimi_hendrix> Peaker, i dont get the nth function or what (const val) does, but i get the rest
07:34:22 <mauke> no problems
07:34:33 <Peaker> jimi_hendrix, well, nth lets you apply a function to the n'th element of a list
07:34:34 <lvh> mauke: did those 10 kilothreads do blocking socket IO?
07:34:42 <Peaker> > nth 5 (*100) [0..10]
07:34:42 <mauke> 100k, not 10k
07:34:43 <lambdabot>   [0,1,2,3,4,500,6,7,8,9,10]
07:34:48 <Peaker> jimi_hendrix, so far so good?
07:34:53 <mauke> lvh: no, they were blocking on each other
07:35:22 <jimi_hendrix> Peaker, what do the colons in nth do
07:35:24 <mauke> lvh: but given that ghc's thread manager uses select(), I don't expect many problems
07:35:34 <Peaker> jimi_hendrix, (const val) makes a function that always returns val, no matter what the input. So if you want to just modify the n'th to X, ignoring what was there, you can use nth with (const X)
07:35:44 <Peaker> jimi_hendrix, They are the list-cons
07:35:59 <lvh> Okay. Are there any existing/maintained Haskell packages that do thread-per-connection that I should look at?
07:36:18 <Peaker> jimi_hendrix, lets define lists from scratch, shall we?
07:36:24 <jimi_hendrix> you can do that?
07:36:28 <mauke> dunno
07:36:29 <lvh> Mostly because I'd like to compare how they do versus my current thing, which is a Python event loop. Single threaded, concurrency through multiprocessing.
07:36:32 <Peaker> jimi_hendrix, data List a = EmptyList | Element a (List a)
07:36:44 <Peaker> jimi_hendrix, can you come to #haskell-overflow ?
07:36:52 <Peaker> jimi_hendrix, so we don't overflow here :)
07:37:17 <lvh> mauke: Sorry for being so skeptical, but I've seen tpc too many times to still believe it works without proof ;-)
07:37:58 <mauke> lvh: why wouldn't it work?
07:38:24 <lvh> mauke: Well, there's one paper I found that describes it (I linked it earlier)
07:38:43 <lvh> mauke: and if you look at their data, you'll see that it starts to die horribly just under 1k active connections
07:38:50 <lvh> mauke: which is pretty typical for TPC
07:41:45 <lvh> mauke: (Whereas with my current implementation with Twisted, I can saturate my link before it dies out -- if I test over the loopback interface, it only starts dropping off from a linear curve (request rate vs response rate) at 50k open conns)
07:42:08 <lvh> mauke: Of course, that's a paper back from 2000 -- hence why I'm asking here, it could very well be that the things that paper is saying do not reflect the current state of haskell
07:42:59 <FunctorSalad_> I'm clueless, what is the alternative to one thread per connection?
07:43:12 <mauke> FunctorSalad_: many connections per thread
07:43:54 <Athas> Or many threads per connection!
07:44:01 <lvh> Athas: ack no
07:44:18 <FunctorSalad_> does the thread block a bit on one connection, then on the next etc mauke?
07:44:19 <mauke> Athas: preflex does that!
07:44:26 <mauke> FunctorSalad_: no
07:44:32 <lvh> FunctorSalad_: A limited amount of threads (in many cases just one), each of them handles many connections
07:44:33 <mauke> FunctorSalad_: it blocks on all of them at the same time
07:44:41 <FunctorSalad_> ok :)
07:44:48 <lvh> FunctorSalad_: Typically it does this by not blocking on IO
07:44:55 <lvh> (which is sort of the same thing but different!)
07:45:56 <lvh> So basically, I'm looking for any kind of production quality server in haskell to see how well that works.
07:46:08 <mauke> what does happs do?
07:46:17 <lvh> mauke: It comes with a web server!
07:46:29 <lvh> (And so does turbinado, I think)
07:47:28 <lvh> Oh, wait, apparently that's for production. I thought the HTTP bits was a development server. My bad! I'll take a look.
07:48:14 <lvh> happs performance gets me a lot of hits for some dude named happ :(
07:50:23 <FunctorSalad_> lvh: put "happs" in double quotes
07:50:33 <FunctorSalad_> disables google fuzzyness
07:50:59 <Peaker> what's TPC?
07:52:45 <lvh> FunctorSalad_: thanks
07:52:48 <lvh> Peaker: thread per connection
07:52:50 <Peaker> lvh, select sucks. You can use epoll/libev instead, though. When I first came from Python, it seemed horrid that Haskell used threads so much.  Then I realized the major difference - Haskell threads share immutable state, mostly. The mutable state shared is a tiny controlled subset (Basically a bunch of MVars) and only there do you get non-determinism
07:53:22 <lvh> Peaker: yeah, I get that
07:53:38 <lvh> Peaker: I don't really care if it uses threads all the time
07:53:49 <Peaker> lvh, If you think about it, a Twisted Deferred is really an IO Monad :-) The difference between Deferred and thread with coarse-locking is syntactic.  With Haskell threads, since mutable state isn't shared, you don't need the coarse locks
07:53:51 <lvh> Peaker: if I can see evidence that it performs, fine
07:54:10 <lvh> Peaker: Yes, I know that a Twisted Deferred is as close to a monad as you'll find in production python code
07:54:22 <Peaker> the use of select in ghc's rts, I'd suspect, wouldn't perform well with lots of connections
07:54:43 <lvh> Peaker: the terrible performance of thread per connection servers in other languages typically has little to do with resource contesting
07:54:58 <lvh> Peaker: (or shared mutable state)
07:55:10 <Peaker> does cabal allow listing reverse dependencies?
07:55:21 <lvh> Peaker: and mostly with the underlying implementation not being very good at delivering lots of IO to more than, oh, say, 500-600 threads
07:55:27 <Peaker> lvh, It has to do with the use of Kernel threads (which ghc doesn't do) and a lot of locking
07:55:34 <dcoutts> Peaker: it's not implemented, no
07:55:47 <lvh> Peaker: which is usually not considered a problem mostly because nobody has 500-core boxen yet
07:55:56 <FunctorSalad_> Peaker: look at haskell-cafe, someone did it recently
07:56:03 <lvh> Peaker: and people actually using 500 cores at once would probably not bother with threads anyway
07:56:14 <FunctorSalad_> (has a modded version of hackage up, with rdepends)
07:56:29 <lvh> Peaker: wait, what's it got to do with locking?
07:56:40 <lvh> Peaker: unless you missed a b and meant blocking, in which case: yes
07:56:49 <Peaker> lvh, Usually, programs pay locking penalty on their data structures
07:57:01 <Peaker> lvh, when they use lots of shared mutable state
07:57:05 <lvh> Peaker: sure, but that's generally not why TPC dies
07:57:08 <Peaker> lvh, ghc-rts threads aren't kernel threads though. They are more like Deferreds
07:57:46 <lvh> Peaker: if TPC died because of shared structures it wouldn't come close to linear-until-1k-concurrent-threads anyway
07:58:31 <Peaker> lvh, I am not sure, more threads means locking penalty is worse, more unwanted serialization of execution.. the fact those are kernel threads means you pay for more context switches, etc
07:58:31 <lvh> Peaker: all of this is besides the point though -- I've seen two examples of haskell-written servers that do TPC so far, and no evidence that they work past 1k connections
07:58:47 <Peaker> lvh, Again, I'd blame "select" before anything else, for bad scalability :)
07:58:58 <lvh> Peaker: again, I don't care how it's implemented
07:59:13 <lvh> Peaker: select and threads is fine, if you can show me haskell code that does 50k concurrent connections and doesn't die
07:59:22 <Peaker> lvh, Try to use hlibev bindings with forkIO and see how it performs for thousands of connections
08:00:03 <lvh> Peaker: so you don't know of anytthing that already does this either?
08:00:23 <Peaker> lvh, I haven't taken interest in that, no
08:00:42 <lvh> Peaker: there's one obvious problem with that
08:00:49 <lvh> Peaker: it won't run on anything other than linux2.6
08:01:48 <Peaker> lvh, libev is a frontend to many select interfaces, it probably can
08:02:02 <lvh> Peaker: I'll keep looking. I hate to sound like a troll, but so far no evidence that anyone has actually done this before (other than the existence of libev)
08:02:07 <Peaker> lvh, I don't think I see why Deferreds should scale further than forkIO threads -- they're very similar
08:02:30 <lvh> Peaker: I like empirical evidence a lot :-)
08:02:44 <Peaker> lvh, well, what kind of server do you want? Maybe I can try to whip something up
08:02:45 <FunctorSalad_>  is there evidence that haskell threads can't do this?
08:03:15 <FunctorSalad_> (considering they're not at all like threads in other langs)
08:03:41 <Peaker> lvh, my guess is that a Haskell program with libev would outperform a Twisted one
08:03:51 <FunctorSalad_> don't get me wrong, absence of disproof is not a reason to base a production project on it ;)
08:03:58 * Peaker cabal installs hlibev
08:04:32 <lvh> FunctorSalad_: well, no, but considering how poorly TPC does in every other language
08:04:42 <lvh> FunctorSalad_: including implementations where thread doesn't mean os thread
08:04:46 <lvh> FunctorSalad_: I'm only going to believe it with positive evidence, not solely based on the lack of negative evidence ;-)
08:04:56 <lvh> Peaker: I'll believe it when I see it
08:05:03 <Peaker> lvh, Do you think Stackless Python tasklets + reactor   will be outperformed by Twisted?
08:05:25 <FunctorSalad_> lvh: of course you should do the test, I was just curious
08:05:26 <lvh> Peaker: I know that I've seen mutliple cases of it not doing that
08:05:40 <lvh> Peaker: unless you have very strange performance metrics
08:06:05 <lvh> Peaker: I'm mostly talking about the dropoff point (in #connections) of request rate versus response rate
08:06:25 <lvh> Peaker: which in most tests is extremely obvious, and is a good metric for "don't have more connections than this or everything dies"
08:06:41 <Peaker> lvh, do you think Twisted + inlineCallbacks will be outperformed by explicit callbacks (significantly)?
08:06:41 <lvh> Peaker: (usually the dropoff is pretty steep)
08:06:49 <lvh> Peaker: unlikely
08:07:00 <Peaker> lvh, then why do you think stackless tasklets will do worse? Or Haskell threads?
08:07:02 <lvh> Peaker: it might, but there's only one way to find out really
08:07:13 <lvh> Peaker: Because of Twisted's IO loop.
08:07:33 <mauke> what's the difference between twisted's io loop and ghc's?
08:08:30 <lvh> mauke: Twisted doesn't do any blocking IO anywhere. The closest it does is block in a thread -- which isn't that terrible, because the actual blocking happens in C, so it doesn't bother Python (GIL is never acquired)  so much.
08:08:59 <mauke> ghc doesn't any blocking IO
08:08:59 <lvh> mauke: If I understand correctly, the GHC equivalent code would launch a bunch of threads and block in all of them at once.
08:09:02 <mauke> +do
08:09:14 <lvh> s/GHC/Haskell/, then
08:09:27 <lvh> mauke: So why launch thread-per-conn?
08:09:27 <mauke> "Haskell" doesn't have threads :-)
08:09:58 <mauke> lvh: are we talking about the programmer interface or how it's implemented?
08:10:06 <FunctorSalad_> if it's just about the threads shouldn't it be easy to quickly write a haskell app to test this?
08:10:27 <FunctorSalad_> that echos back the data or whatever
08:10:36 <Peaker> libev's bindings are yucky. someone needs to make nice ones
08:10:58 <Peaker> lvh, No, ghc doesn't do blocking I/O either
08:10:58 <lvh> mauke: The two are sometimes inseperable
08:11:07 <lvh> mauke: I guess in this case I'm thinking of how it's implemented.
08:11:29 <mauke> implementation wise, it's non-blocking file descriptors and a select loop
08:11:57 <Peaker> lvh, when you "block" in a forkIO thread, you actually switch to a different thread, much like "returning control" to the reactor in Twisted
08:12:34 <Peaker> lvh, (with nicer handling of computational tasks... in Twisted you have to use something like a "Cooperator" and manually split large computations and use 0-timers to execute them)
08:12:50 <lvh> Peaker: I'm guessing "different thread" does not mean OS thread here
08:12:55 <Peaker> lvh, right
08:13:10 <mauke> the runtime library has hooks in everything that uses file descriptors, plus the memory allocator
08:13:26 <lvh> Peaker: I've done a lot of twisted, but I've never heard of cooperators or 0-timers
08:15:07 <dcoutts> mauke: "Concurrent Haskell" has threads, ghc and hugs implement "Concurrent Haskell".
08:16:07 <mauke> where is Concurrent Haskell defined?
08:16:18 <dcoutts> in a paper on Concurrent Haskell :-)
08:16:28 <iaefai> Speaking of threads, from GLFW's page: "GLFW doesn't work well with GHC threads, forkIO or threadDelay."  Does this mean that it doesn't work with any parallelism?
08:16:35 <mauke> heh
08:17:49 <dcoutts> mauke: it's linked from www.haskell.org/haskellwiki/GHC/Concurrency
08:17:52 <Peaker> lvh, when you want to perform a heavy computational task in Twisted, what do you do?
08:18:01 <lvh> Peaker: call C code
08:18:05 <dcoutts> doh!
08:18:06 <lvh> Peaker: Well, scheme code
08:18:19 <Peaker> lvh, and, when do you that, and the code takes many seconds, what do you do?
08:18:23 <Peaker> lvh, do you run it in an OS thread?
08:18:32 <lvh> Peaker: no, process
08:18:46 <lvh> Peaker: I defer the result.
08:19:01 <Peaker> lvh, That's one approach, but it has an extra penalty for little gain (at least when you have little to no shared mutable state)
08:19:01 <FunctorSalad_> is any frp lib usable yet?
08:19:06 <Peaker> FunctorSalad_, perhaps Yampa
08:19:13 <Peaker> FunctorSalad_, though its not as nice as Conal's stuff
08:19:14 <dcoutts> iaefai: it probably means that GLFW is not thread safe
08:19:20 <lvh> Peaker: And add a callback. As soon as the computation is done, it calls me and I do something with the result.
08:19:34 <lvh> Peaker: how's that?
08:19:45 <lvh> Peaker: If you're talking about starting a process -- no, I can keep the process open too.
08:19:46 <FunctorSalad_> Peaker: I didn't learn any of them yet. I'd like to learn reactive but I'm scared of this mysterious ghc bug it's apparently suffering from =)
08:20:00 <FunctorSalad_> I shall look at yampa...
08:20:17 <lvh> Peaker: I've done the same thing in the C code, but with threads instead of processes. Same deal. No significant difference.
08:20:30 <dcoutts> lvh: it sounds like a rather heavyweight approach and requires marshaling and a change of language
08:20:32 <lvh> Peaker: Mostly because, like you said, they share nothing.
08:20:45 <lvh> dcoutts: what makes it heavyweight?
08:21:01 <dcoutts> lvh: new process, switching language, marshaling inputs and outputs
08:21:02 <Peaker> lvh, well, there are penalties to even switching address spaces
08:21:16 <FunctorSalad_> (does the term "FRP" cover any functional approaches that aren't imperative IO?)
08:21:20 <dcoutts> I mainly mean heavyweight from a coding pov, not performance
08:21:27 <FunctorSalad_> (I'd be happy with any "nice" UI approach ;))
08:21:37 <dcoutts> being able to just forkIO is rather simpler
08:21:38 <Peaker> FunctorSalad_, what do you mean?  FRP is meant to replace imperative IO
08:21:45 <lvh> dcoutts: the code already exists
08:21:45 <iaefai> dcoutts: makes sense. I wonder if there is an opengl library that is thread safe.
08:21:46 <lvh> dcoutts: I just use it
08:21:48 <iaefai> FRP?
08:21:56 <Peaker> FunctorSalad_, or rather, provide a new way to hide the implementation (which is imperative IO) behind a purely functional interface (one that has simple composable semantics)
08:22:05 <Peaker> iaefai, Functional Reactive Programming
08:22:11 <FunctorSalad_> Peaker: yeah I meant whether FRP covers all functional UI stuff or just one specific of them
08:22:22 <dcoutts> lvh: you don't have to write any new marshaling code for different types of parameters or results?
08:22:24 <iaefai> Peaker: Is this a stable thing, or still experimental?
08:22:25 <Peaker> FunctorSalad_, Nobody knows exactly how "complete" the FRP approach is, I think :)
08:22:32 <Peaker> iaefai, Its pretty experimental
08:22:35 <lvh> Peaker: my OS is smarter than that, surely -- as long as I can keep the process busy with new data.
08:22:41 <lvh> dcoutts: nope
08:22:51 <iaefai> So we might hear about it as more mainstream in a few years then?
08:22:53 <dcoutts> lvh: so there's some generic marshaling
08:22:58 <Peaker> iaefai, I hope so. I think its awesome
08:23:00 <lvh> dcoutts: Yep.
08:23:05 <lvh> dcoutts: And yes, I did actually profile that.
08:23:16 <lvh> dcoutts: (Amdahl tells me not to care.)
08:23:18 <Peaker> iaefai, I anxiously wait for it to become a viable alternative to IO/imperative programming
08:23:31 <Peaker> iaefai, Its also very simple :)
08:23:37 <Peaker> (Hard to implement, simple to use)
08:23:49 <FunctorSalad_> can't you describe a UI as some sort of automaton?
08:23:57 <dcoutts> lvh: so this is python code I presume, and the heavy computation also done in python, or was that marshaling to scheme?
08:24:08 <FunctorSalad_> just thinking about the "codata = observations" idea
08:24:08 <Peaker> FunctorSalad_, Look at Phooey's examples
08:24:11 <lvh> FRP is basically what would happen if you let glyph (the guy who wrote Twisted) do whatever he wanted
08:24:12 <iaefai> Peaker: I observe that monads are incredibly simple but we have everyone and his brother making a monad tutorial. Hell, to be honest, I forget how monads work precisely.
08:24:19 <Peaker> FunctorSalad_, http://www.haskell.org/haskellwiki/Phooey
08:24:28 <lvh> dcoutts: Both
08:24:43 <lvh> dcoutts: also: "scheme" is misleading. I write scheme, and gambit or bigloo turns it into C for me.
08:24:51 <Peaker> iaefai, FRP involves monads too, though in a completely different way (Monads are really general and aren't useful only for imperative programming)
08:24:57 <lvh> Really, really fast C.
08:25:07 <lvh> dcoutts: I could just as well s/Scheme/Haskell there, really.
08:25:28 <Peaker> lvh, Well, there are some properties of hand-written C that that kind of C will lose (e.g: Tight memory management)
08:25:44 <lvh> Peaker: you'd think that, wouldn't you
08:25:55 <lvh> Peaker: however, it turns out that gambit is really clever
08:25:57 <Peaker> lvh, there's a lot more a C programmer knows about the operational semantics of his program than a *compiler* can know about the operational semantics of a Scheme program
08:26:08 <Peaker> lvh, As clever as it is, I doubt it solves the halting problem :)
08:26:28 <dcoutts> lvh: from my pov, the forkIO seems a much nicer model. I accept of course that since ghc currently uses select() that it's no good for the 50k client server case, but that's just a matter of implementation work.
08:26:47 <lvh> Peaker: mostly in the same way we don't really write ASM anymore because C compilers are really clever nowadays and a lot of ASM that's still around either doesn't do the same job or is worse than what a compiler culd come up with
08:26:51 <Peaker> lvh, doing general type inference in Scheme is as difficult as solving the halting problem - and the compiler might have to infer too general types, and create code that performs worse than the equivalent C code
08:26:51 <iaefai> I was wondering something... If I wanted to represent an interface of a chess board and pass to it a data structure telling it where specific pieces are, in a similar way to the UI code here? http://www.haskell.org/haskellwiki/Phooey#Monad     But not actually using phooey - I am looking in an opengl sort of way.
08:27:53 <Peaker> lvh, Well, that's why C has keywords like "register" or "reserved"(SP?) and "volatile". What does Scheme have for the poor type inferrer?
08:27:56 <FunctorSalad_> could you maybe use MonadPrompt for all the interesting UI stuff, with a thin IO/imperative interpreter?
08:28:15 <lvh> Peaker: Maybe. Again, I'm a big fan of empirical evidence. Specifically, evidence that tells me that the differences are not big enough to care about
08:28:23 <Peaker> iaefai, well, OpenGL is an aspect of the implementation, not of your declarative program of where to place pieces
08:28:45 <iaefai> true, but I don't explicitly separate them for various reasons
08:28:47 <Peaker> lvh, Sure, very rarely getting an extra 20% performance is really that much of an issue
08:28:51 <lvh> Peaker: Yeah, especially when "clever" C programmers use these in ways that make clever C compilers produce worse performing machine code :-)
08:29:13 <Peaker> iaefai, You probably can expose a beautiful functional interface without exposing implementation details, while still having an efficient implementation
08:29:22 <Peaker> iaefai, see FieldTrip as an example
08:29:29 <lvh> Peaker: difference in run time was within the uncertainty
08:29:48 <Peaker> lvh, At my workplace, we measure latency in microseconds.  We wouldn't want to use Scheme, Haskell, or Python for that code
08:29:50 <lvh> Peaker: statistically speaking (I started with the hypothesis that C would've been faster)
08:30:30 <lvh> Peaker: And it ends up being written in what?
08:30:32 <iaefai> I am not a true haskeller yet, I try to use it with somethings :p
08:30:33 <Peaker> lvh, C
08:30:44 <lvh> Peaker: interesting. What application?
08:31:10 <lvh> Peaker: In the application in question I care a lot more about throughput than latency.
08:32:32 <McManiaC> http://paste.n-sch.de/0i/hs can anyone spot a mistake here why this function does nothing after the first list item? :o
08:33:04 <en0th> omg, non termination!! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4417#a4417
08:34:26 <en0th> is there a neat way to write mkDemo?
08:35:24 <byorgey> en0th: what should mkDemo do?  can you give an example?
08:36:04 <en0th> i'd like to write it as an infinite list and use it with !! operator
08:36:15 <byorgey> en0th: yes, but what should be in the infinite list?
08:36:30 <byorgey> the way it is written, it never even gets around to producing the first element of the list
08:36:30 <iaefai> Is glut thread safe as far as haskell would be concerned?
08:37:13 <en0th> [EAdd ENum 1 ENum 2, ENum 1, ENum 2]
08:37:35 <en0th> yes, i fill towards the right
08:37:39 <byorgey> because mkDemo (e1:e2:es) = mkDemo (EAdd e1 e2 : ESub e1 e2 : es) = mkDemo (EAdd (EAdd e1 e2) (ESub e1 e2) : ESub (EAdd e1 e2) (ESub e1 e2) : es = mkDemo ...
08:38:00 <en0th> * i should fill
08:39:10 <en0th> but then i would need to get the last two items of the list, and i'd like to avoid using !! for that
08:40:07 <byorgey> en0th: what should  mkDemo [ENum 1, Enum 2, Enum 3] return?
08:40:41 <byorgey> yes, using !! is generally a bad idea.
08:40:55 <en0th> sorry, i didn't explain it well. mkDemo is only a helper function. It will be always called by mkDemos
08:41:25 <en0th> :t last
08:41:26 <lambdabot> forall a. [a] -> a
08:41:41 <en0th> :t lastbutlast
08:41:42 <lambdabot> Not in scope: `lastbutlast'
08:41:51 <byorgey> en0th: I still have no idea what mkDemo is supposed to do.
08:42:54 <en0th> mkDemo = [ENum 1, ENum 2, EAdd ENum 1 ENum 2, ESub ENum 1 ENum 2, ..]
08:43:15 <en0th> and then EAdd with the last two items
08:43:50 <byorgey> oh, I see.  well, you just need to put e1 and e2 in front of the recursive call to mkDemo then.
08:44:22 <byorgey> mkDemo (e1:e2:es) = e1 : e2 : mkDemo (EAdd e1 e2 : ESub e1 e2 : es)
08:44:39 <byorgey> although notice that the 'es' part is unnecessary, it will never look at that part.
08:44:59 <byorgey> so you might as well just say  mkDemo [e1,e2] = e1 : e2 : mkDemo [EAdd e1 e2, ESub e1 e2]
08:45:14 <byorgey> in which case you might as well just have mkDemo take two arguments instead of a list of two elements.
08:45:35 <byorgey> in which case you really don't need the mkDemo helper function at all, just implement it directly in mkDemos =)
08:46:27 <en0th> hehe, i think so
08:46:37 <byorgey> en0th: sorry if that was a lot all at once. =)  does that make sense?
08:47:34 <en0th> yes, it's flawless. :) I always find myself complicating things ..
08:49:25 <byorgey> everyone does.  The trick is learning how to simplify.
08:52:47 <lpjhjdh> is there a Dynamic type over polymorphic types that works in ghc?
08:53:02 <lpjhjdh> I read something about a yhc version
08:54:44 <en0th> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4418
08:54:45 <en0th> Woah, it works. Thanks a lot, byorgey!
08:56:20 <Berengal> hxt is really neat
09:23:55 <Jeb> hello
09:28:45 <noZone> ...sleepy Saturday...
09:28:55 <Jeb> what does it mean to allow overlapping instances?
09:30:08 <byorgey> Jeb: two type class instances overlap if there is some type to which they both apply.
09:30:23 <byorgey> for instance,  instance Foo [a]   and  instance Foo [Int]  overlap
09:30:49 <byorgey> since they both apply to [Int].
09:31:07 <byorgey> normally Haskell doesn't allow this.  if you enable overlapping instances, then ghc tries to pick the most specific one.
09:31:22 <byorgey> so in this example it would pick the [Int] instance for [Int] and the [a] instance for [Char]
09:32:11 <byorgey> but there isn't always guaranteed to be a most specific instance, e.g. if you have instances for  (a, Char)  and (Int, b), which instance should be chosen for  (Int,Char)?
09:32:17 <byorgey> I forget what it does in that case.
09:32:28 <copumpkin> I think it just complains about ambiguity
09:32:47 <byorgey> whatever it does, you shouldn't rely on it =)
09:33:13 <dolio> It probably tells you that you need IncoherentInstances.
09:37:33 <copumpkin> does anyone know of any languages with "effect scoping"? I create a (mutable) variable with value x in one scope, and then in a scope within that scope, it gets changed, but the change is only visible inside that subscope
09:37:56 <Jeb> hmmm, well my professor gave us a module were supposed to include that has both overlapping, and incoherent instances, any ideas how to get that to work?
09:38:05 <mauke> copumpkin: sounds like what 'local' does in perl
09:38:12 <copumpkin> mauke: ah
09:38:34 <mauke> also "special variables" in lisp, but lisp does it wrong
09:39:37 <byorgey> Jeb: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
09:40:04 <byorgey> Jeb: you mean the module says that it has overlapping and incoherent instances, or ghc complains that it does?
09:40:14 <Jeb> ghc complains
09:40:24 <byorgey> to allow it you can put  {-# LANGUAGE OverlappingInstances, IncoherentInstances #-} at the top of the file
09:40:28 <lpjhjdh> I was wondering if template haskell would be a good approach to this problem.  I have a sum type to union functors which then get their "position" by saying (Left . Left $ Right x) :: Sum (Sum (Sum (f x) g) g') z
09:40:29 <Jeb> thanks byorgey, already read that though, I tried adding both flags, still gave me an error
09:40:29 <jimi_hendrix> can i cast Int to Integer
09:40:38 <lpjhjdh> I then make injection functions of the form: Left . Left .Right
09:40:39 <byorgey> Jeb: what error does it give you?
09:40:48 <byorgey> jimi_hendrix: yes, use fromIntegral
09:40:50 <lpjhjdh> could I have template haskell generate these by handing it the Sum type?
09:41:09 <byorgey> jimi_hendrix: fromIntegral converts any Integral type (like Int or Integer) into any other numeric type.
09:41:12 <lpjhjdh> err, use template haskell to do this I mean
09:41:23 <Jeb> If I use    {-# LANGUAGE OverlappingInstances, IncoherentInstances #-}    still gives same error     (All instance types must be in the same form...)
09:41:47 <byorgey> Jeb: try adding FlexibleInstances too
09:42:37 <Jeb> Constraint no smaller than the instance head ..... try adding UndecideableInstances
09:43:19 <Jeb> thanks, got it now
09:43:22 <dolio> copumpkin: runCC (do r <- dnew ; dlet r 5 (dlet r 5 (dset r 6) >> dref r)) ==> 5
09:43:40 <copumpkin> dlet/set?
09:43:47 <byorgey> Jeb: ah yes, that too =)
09:43:49 <Jeb> not sure why he didn't include all that stuff in the file to begin with
09:43:54 <dolio> @hackage CC-delcont
09:43:54 <lambdabot> http://hackage.haskell.org/package/CC-delcont
09:43:57 <copumpkin> ah :)
09:43:58 <copumpkin> cool
09:44:16 <byorgey> Jeb: yeah, strange
09:44:23 <Jeb> guess it's a learning lesson, lol
09:45:39 <jimi_hendrix> ok
09:47:09 <iaefai> When I have installed the OpenGL module (mac) is there a reason why I don't have the documentation for it in file:///Library/Frameworks/GHC.framework/Versions/610/usr/share/doc/ghc/libraries/index.html ?
09:48:21 <iaefai> Last I recall I had an install that did update it at one point
09:48:50 <byorgey> iaefai: that's the location of the ghc documentation.
09:48:57 <copumpkin> you need to set the cabal config to generate documentation for your installed packages
09:49:02 <byorgey> package installs don't update that, but they might install their own documentation somewhere else.
09:49:03 <copumpkin> and then it should live in ~/.cabal
09:49:41 <byorgey> well, it's the documentation for the libraries that come with ghc.
09:50:45 <iaefai> I notice that there is an install dir for global in the cabal config, is there a way to get cabal to use that?
09:55:43 <iaefai> Is this a big deal?   Warning: /Users/iaefai/.cabal/config: Unrecognized field prefix on line 59   where that is prefix: /Library/Frameworks/GHC.framework/Versions/Current/usr
09:56:46 <jimi_hendrix> byorgey, i am trying that but erroring, the line is     next <- (fromInteger y) - (length l1) -- y is an Integer argument and l1 is a list and the error is: Couldn't match expected type `Int' against inferred type `m a' In a stmt of a 'do' expression: next <- (fromInteger y) - (length l1)
09:57:57 <byorgey> jimi_hendrix: the syntax   a <- m   is for "running" a monadic computation m and giving the result(s) the name a.  (fromInteger y) - (length l1) is a pure expression, not a monadic computation.
09:58:16 <byorgey> so you can just write   let next = (fromInteger y) - length (l1)
09:59:22 <jimi_hendrix> ok
09:59:51 <jimi_hendrix> but that only binds next for the part after i say 'in' right
10:00:26 <byorgey> jimi_hendrix: no, in a do-block you don't need the 'in'
10:00:33 <jimi_hendrix> ok
10:00:52 <byorgey> basically   do { let x = y; blah }  translates to   let x = y in do { blah }
10:01:06 <byorgey> so the binding is in scope for the remainder of the do-block
10:01:14 <jfoutz> IO should be called Time
10:01:27 <byorgey> ?
10:01:32 <byorgey> jfoutz: why?
10:01:40 <jfoutz> It dosn't really have anything to do with IO
10:01:53 <jfoutz> it's sampling the state of the world at a given time
10:01:59 <jfoutz> there's no way to go back in time.
10:02:17 <jfoutz> it's not like the whole state of the real world is there in the st
10:02:37 <jfoutz> it's just, given that it's 11 in the morning, can i open /etc/passwd?
10:02:48 <byorgey> iaefai: the 'prefix' field can only show up under the 'install-dirs user' or 'install-dirs global' sections
10:02:51 <jimi_hendrix> ok
10:02:53 <byorgey> iaefai: and I think it has to be indented
10:02:56 <jfoutz> now that's it is a little after 11, can i read the bytes out of it?
10:02:58 <jimi_hendrix> and byorgey does !! need an int or integer
10:03:12 <byorgey> @type (!!)
10:03:13 <lambdabot> forall a. [a] -> Int -> a
10:03:20 <byorgey> lambdabot knows =)
10:03:50 <iaefai> byorgey: It appears you are right.
10:03:52 <iaefai> byorgey: What does this thing use for its configuration?
10:04:01 <iaefai> or rather, what do I have to use to make one like it :p
10:04:55 <jfoutz> an IORef is a good example. what is the magic real world state? how can i in the real world read that state ... short of getting a pointer into the runtime.
10:05:21 <byorgey> iaefai: I don't know.  The cabal config file is woefully underdocumented.
10:05:54 <byorgey> iaefai: cabal will make a new default one if it doesn't exist, and then you can edit that.
10:06:31 <iaefai> I would love some way of integrating all of my documentation in the one big contents of modules installed
10:10:47 <mercury^> terms  =  concat [[Var n, Lam t, App s t] | n <- [0..], s <- terms, t <- terms]
10:11:05 <mercury^> Why doesn't that work?
10:11:11 <jfoutz> Time is a far more natural representation for what's happening. Equational reasoning breaks down because getChar isn't referentially transparent. It makes far more sense that this equation can't look into the future, it has to actually be aware of time, and wait for the result.
10:11:47 <aavogt> jfoutz: IO is shorter though
10:11:54 <jfoutz> well there's that :)
10:12:14 <jfoutz> i've been reading too much frp i think.
10:13:39 <deech`> I am trying to understand how Haskell continuations can be used to manage state across web transactions. Do I need to store intermediate continuations with a unique id in a STM variable ?
10:16:00 <jimi_hendrix> can someone tell me what this means: Occurs check: cannot construct the infinite type: a = [[a]]     Expected type: [[a]]     Inferred type: a ... i want to figure out the fix myself first if i can
10:16:52 <byorgey> mercury^: you do realize (even if it did work) that that would produce (Var 0) repeatedly and never get around to producing (Var 1) ?
10:17:13 <mercury^> byorgey: ah, right.
10:17:14 <jfoutz> > let a = [a] in a
10:17:15 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
10:17:38 <byorgey> mercury^: in fact, it would also never get around to having s be anything other than (Var 0), either.
10:18:06 <maltem> jimi_hendrix, it means, roughly, that you put something of type a somewhere where [[a]] was expected
10:18:11 <jfoutz> jimi_hendrix: it means you can't make a binding be an object and a list of objects (or other stuff) at the same time
10:18:21 <mercury^> byorgey: wouldn't the second s be Lam (Var 0)?
10:18:37 <mercury^> Ah, the second t would be.
10:18:51 <byorgey> mercury^: but since terms will be infinite, t will just range through all terms and it will never get around to moving s on to the second term.
10:19:24 <mercury^> I don't want to implement some stupid curve myself. :/
10:19:27 <byorgey> mercury^: I would do it by stages: make a function which takes a (finite!) list of terms and produces a new list consisting of those terms plus all terms built out of one constructor application to those.
10:19:36 <byorgey> then you can iterate it as many times as you like.
10:19:50 <byorgey> oh, and each iteration ought to throw in another variable, too.  or something like that.
10:21:07 <__JN> hello, I'm writing a preprocessor for a textfile. One of the patterns I'm looking at is a digit, followed by one  blank followed by a digit again. How can I match such pattern without writing 10*10 different patternmatches like "test ('1':' ':'2':chars) = "1, 2" ++ test chars"
10:21:28 <jimi_hendrix> jfoutz, since i dont know what i did i will paste the swap function i was working on
10:21:55 <mauke> test (d1 : ' ' : d2 : cs) | isDigit d1 && isDigit d2 =
10:22:13 <jfoutz> jimi_hendrix: ok, i'm happy to look. but the binding two ways is good to figure out
10:22:24 <jimi_hendrix> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10857#a10857 <- jfoutz maltem
10:22:57 <jfoutz> jimi_hendrix: imagine this: (\(x,x) -> (x,x)) (2,3)
10:23:12 <jfoutz> jimi_hendrix: it's not valid haskell, because you can't tell which x is which
10:23:23 <conal> jfoutz: there's another explanation.
10:23:28 <maltem> jimi_hendrix, l1, l2, l3 are elements, not lists, so you cannot concatenate them
10:23:38 <conal> jfoutz: it could be valid and fail to match the argument.
10:23:43 <conal> a "non-linear pattern"
10:23:44 <maltem> jimi_hendrix, maybe you use <- where you meant let?
10:23:49 <maltem> *used
10:24:23 <Twey> jfoutz: It would make sense if both ‘x’s were the same.
10:24:37 <maltem> also, you have to put the argument to "return" in parentheses, but that's not your very problem I guess.
10:24:37 <Twey> I think that was rejected simply on the grounds of being confusing.
10:24:45 <jfoutz> oh. hmm.
10:25:20 <mercury^> [(+3), (+4)] ?? 3 == [6, 7]
10:25:33 <byorgey> it also has interesting type inference implications.  Would anything using a nonlinear pattern automatically get an Eq constraint, or ... ?
10:25:44 <mauke> > let (??) = sequence in  [(+3), (+4)] ?? 3
10:25:45 <lambdabot>   [6,7]
10:25:51 <mercury^> mauke: thanks
10:26:01 <__JN> mauke: Thank you! That worked like a charm!
10:26:18 <jimi_hendrix> maltem, ok
10:26:21 <jimi_hendrix> jfoutz, makes sense
10:26:51 <conal> non-linear patterns are as rigorous, and are logically simpler than linear.  was just a judgment call, i think.
10:28:10 <conal> i.e., a human factors decision
10:28:21 <iaefai> Is it possible to produce a galaxy-like spiral of a few thousand points (representing stars) in a way that you don't instruct it how to make it (like how you might do it in C) but rather express what the galaxy looks like?
10:29:52 <Draconx> iaefai, you might be interested in http://www.contextfreeart.org/
10:31:29 <conal> iaefai: yes!
10:32:07 <conal> iaefai: tho the question could use some clarifying.  particularly, what do you mean by "make"?
10:33:01 <conal> iaefai: e.g., there's the distinction between rendering and modeling.  also between modeling in a pure functional way or modeling as a result of accumulating side-effects.
10:33:23 <conal> e.g., scene graph libraries are usually modeling via side-effects.
10:33:38 <iaefai> :t ($~)
10:33:39 <lambdabot> Not in scope: `$~'
10:34:12 <monochrom> If $~ is one of the GL operators, lambdabot probably doesn't know it.
10:34:22 <aavogt> @hoogle ($~)
10:34:23 <lambdabot> No results found
10:34:25 <Zao> Hayoo might.
10:38:17 <conal> iaefai: modeling can be done imperatively or functionally, and so can rendering.
10:38:43 <iaefai> Draconx: That is awesome, but it is more of an interest for game creation purposes. But I don't know yet how to make it in any way, haven't had time to find details.
10:43:21 <mercury^> bleh, lhs2tex messes up lazy patterns
10:46:41 <iaefai> My apologies, I had issues with colloquy.
10:47:28 <copumpkin> we forgive you, just this one time!
10:48:19 <iaefai> copumpkin: You are gracious in your ways.
10:48:33 <copumpkin> indeed, and my mercy knows no bounds
10:48:40 <copumpkin> at least until you have issues with colloquy again
10:48:41 <copumpkin> :)
10:48:57 <iaefai> copumpkin: That sounds suspiciously like another guy I knew.
10:49:11 <iaefai> His name was Iseu Cristo
10:49:12 <copumpkin> zomg
10:49:21 <copumpkin> not Iesu Cristo?
10:49:32 <iaefai> copumpkin: oh yes, that was it :p
10:50:17 <iaefai> conal: I am interested in how modelling and rendering can be done functionally for sure. I am also interested in how interaction can be done functionally.
10:51:12 <conal> iaefai: me too!  i've been working on those questions for almost 20 years.
10:52:06 <iaefai> conal: That is amazing :p
10:53:04 <mercury^> conal: my google search revealed that you too were questing for a good way to render the lazy binding.
10:53:07 <mercury^> Have you found one?
10:53:18 <conal> iaefai: check out http://conal.net, especially the publications.  you may find food for thought.  if something inspires you, let me know.
10:54:05 <conal> mercury^: "render the lazy binding" isn't ringing a bell.  what did your google search turn up?
10:54:18 <mercury^> http://www.nabble.com/lhs2TeX:-lazy-pattern-"~"-formatting-td3999513.html
10:54:35 <iaefai> conal: I have a friend who has a criticism about functional programming, in that it isn't how the machine actually works. His argument is that to take a machine away from its imperative nature is to limit its efficiency, or something like that. In your experience, what might be a proper response to that?
10:55:04 <Jafet> That structured programming is not how common machines work either.
10:55:04 <mercury^> "I have a friend who has a problem..." =)
10:55:32 <iaefai> mercury^: At least in my case, I am using it, my friend doesn't program much - he comes from sysadmin background.
10:55:37 <mauke> iaefai: tell him he's not allowed to write in anything but assembler code
10:56:24 <mercury^> He has a point though: proving that a haskell program runs in constant space when looking only at the source would be rather hard for example.
10:56:42 <Draconx> no harder than proving that a C++ program which uses "delete" is correct.
10:56:48 <iaefai> In fairness, C is essentially assembly at a higher level.
10:56:56 <Jafet> mercury^, surely that depends on the implementation
10:56:56 <conal> iaefai: if your friend made that remark in the 1940s, i'd have to agree with him.
10:57:06 <copumpkin> lol
10:57:13 <iaefai> Draconx: Is it possible to say that any c++ program could be 'correct' for anything?
10:57:15 <conal> iaefai: because machines really were purely sequential in those days.
10:57:21 <copumpkin> the translation from c to assembly these days is quite a lot more complicated
10:57:25 <copumpkin> than the obvious translation
10:57:26 <mercury^> Jafet: well, in other languages you can make that guarantee independent of any implementation.
10:57:33 <Jafet> Many machines are still purely sequential
10:58:16 <conal> iaefai: nowadays, what slows down computers is having to emulate 1940s computers, because mainstream (imperative) languages are modeled after the old sequential machines.
10:58:46 <iaefai> conal: That is an interesting way of putting it. Could you elaborate a little more?
10:58:47 <conal> iaefai: dropping that emulation requirement is why GPUs are so much faster than CPUs.
10:58:54 <sjanssen> Jafet: processors haven't been strictly sequential for decades
10:59:02 <Jafet> mercury^, it's not guaranteed in most languages, simply the existing implementations make it so
10:59:25 <copumpkin> iaefai: most compilers spend loads of time figuring out how instructions can be reordered because the cpu can actually run more than one thing "at a time" if you present it in the correct order
10:59:30 <iaefai> conal: Do you think we are going to see CPU and GPU merge at some point in mainstream PC?
10:59:31 <mercury^> Jafet: you can make that guarantee in C and Ada at least.
10:59:32 <conal> iaefai: it's a perspective i got from pat hanrahan.  from a talk called something like "why computers are so slow".
10:59:34 <Jafet> sjanssen, they still have to behave as though they are
10:59:46 <sjanssen> Jafet: yes, this is true
10:59:59 <Jafet> mercury^, you wish!
11:00:08 <conal> iaefai: i think we'll see them get closer together and farther apart.
11:00:16 <mauke> mercury^: in C? what are you smoking?
11:00:20 <conal> iaefai: (not either/or)
11:00:36 <mercury^> mauke: huh? What makes you think that is not the case?
11:00:38 <iaefai> conal: I appreciate your response, because it gives a perspective I didn't have before :-0
11:00:48 <sjanssen> mercury^: I'm pretty sure your statement can be reduced to the halting problem
11:00:50 <mauke> mercury^: C doesn't guarantee very much
11:01:05 <mauke> mercury^: let's say you have a program that calls a function. will it work?
11:01:05 <Jafet> conal, GPUs are merely parallel, though, not concurrent
11:01:34 <Jafet> Programmers still cannot think concurrently yet, which is why race conditions are so prevalent
11:01:40 <mercury^> mauke: C does guarantee that there is no allocation beyond static and dynamic variables when you don't call an allocator.
11:01:52 <iaefai> conal: Was the talk actually called 'Why are Graphics Systems So Fast?'
11:02:00 <conal> iaefai: could be
11:02:02 <iaefai> http://www.graphics.stanford.edu/~hanrahan/talks/pact/why.pdf
11:02:03 <mauke> mercury^: where does it say that?
11:02:11 <copumpkin> Damn GPU, you fast!
11:02:44 <iaefai> conal: Does this perspective apply to that processor that the PS3 uses? (can't remember its name just now)
11:02:50 <copumpkin> cell?
11:02:56 <Gilly_> Does there exist a builtin for (***) f f ?
11:03:03 <iaefai> copumpkin: yes
11:03:08 <copumpkin> Gilly_: nope
11:03:16 <copumpkin> join (***) f :P
11:03:25 <mauke> :t join (***)
11:03:25 <Gilly_> ok :P
11:03:26 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:03:57 <copumpkin> longer, but point-freeable
11:04:12 <Gilly_> right
11:04:41 <conal> iaefai: i don't know cell.  your guess is as good as mine.
11:04:46 <mercury^> mauke: 6.2.4
11:05:04 <Jafet> Oh god, we're quoting C standard paragraphs in #haskell
11:05:10 <copumpkin> lol
11:05:27 <iaefai> Hanrahan's pdf got me the beach ball of death
11:05:30 <sjanssen> join (***) isn't the same as (***) f f
11:05:51 <copumpkin> yeah
11:05:53 <conal> iaefai: that "why" talk looks like much of the same material i was remembering.  pat gave a talk for the group i worked in (microsoft research graphics) in 2002.
11:05:58 <copumpkin> sjanssen: but almost! :P
11:06:07 <iaefai> conal: sweet
11:06:25 <monochrom> In a world where there is only one kind of computer, it is hard to imagine why put a totally exotic abstraction layer like Haskell over it, "forbidding" myself from mutating memory. In a world where all computers are text mode command line, it is hard to imagine why put a totally exotic shell like GUI or even just ncurses over it, "forbidding" myself from entering -c -O2 -w -t -f
11:06:50 <conal> iaefai: he pointed out that what we call "general purpose processors", such as Intel and AMD make are not really general purpose.  instead, they execute only a single program.
11:06:53 <psc> anyone here who's done problem 11 of the project euler problems?
11:07:05 <iaefai> When you have languages like C# and objective C being the popular ones and friends like them being popular for the last 30 years, can new methods introduced in haskell and similar languages have a chance of being mainstream?
11:07:15 <conal> iaefai: which is a simulation of a purely sequential von Neumann computer (1940s/50s).
11:07:22 <byorgey> psc: I have.
11:07:33 <psc> byorgey: do you remember it? :p
11:07:34 <mauke> mercury^: that just talks about storage duration of objects
11:07:40 <conal> iaefai: and the people who keep designing those chips are very clever at solving that very odd problem.
11:08:09 <mercury^> mauke: well, an object is not stored beyond its storage duration.
11:08:11 <conal> iaefai: and GPUs have the blessing of not having to solve that problem.  you can run faster if you're not wearing shackles.
11:08:15 <mercury^> Thus does not take up space.
11:08:16 <byorgey> psc: after looking it up, I do now.
11:08:19 <psc> byorgey: nvm. by trying to explain it, i just figured out what my problem was
11:08:26 <mauke> mercury^: there are things that are not objects
11:08:29 <conal> iaefai: that "shackles" comment is mine.
11:08:31 <psc> byorgey: thanks anyway, though :p
11:08:35 <Jafet> You cannot compare GPUs with CPUs at all at this time, since they cannot do the same things
11:08:39 <mauke> mercury^: and they can take up memory
11:08:47 <flux> conal, so would a haskell compiler on GPU be faster than a GHC?
11:08:55 <byorgey> psc: hehe, awesome.  glad to help. =)
11:09:10 <conal> flux: depends on the compiler, doesn't it?
11:09:52 <monochrom> Indeed, if your computer has a 1024x768 2^24-coloured display, why don't you do text mode command line in the following efficient way: Every character occupies one pixel only, the colour tells you which character. Surely 2^24 is more than enough for most Unicode applications.
11:09:59 <flux> conal, true, but the point I was trying to make was the same as Jafet's
11:10:14 <flux> conal, what we can do on GPU's is very different from what we can do on CPU's
11:10:30 <mercury^> mauke: the whole stack frame has automatic storage duration. When the program has no recursion, does not call malloc and does not use VLAs, it runs in constant space.
11:11:11 <Jafet> Reminds me of the days I used to squeeze cycles by flattening all recursions
11:11:30 <conal> there's a broader implication than CPU vs GPU, namely constrained to being a C (or Java or Haskell-IO) machine vs not constrained.
11:12:19 <flux> conal, well, I'm thinking a generic data flow procssing unit is something you are waiting for?
11:12:28 <Jafet> I would prefer the terms "sequential computation" versus "parallel computation" in that case
11:13:14 <Athas> Is there a standard module that defines the Applicative and Alternative instances for Parsec Parsers?
11:13:16 <Jafet> Perhaps a very fast RISC versus a slower CPU with vectorized instructions
11:13:56 <mercury^> Hmm, I don't see in what way either is fundamentally constrained.
11:14:00 <conal> flux: i'm not waiting for anything in particular.  i'm enjoying what's unfolding.
11:14:18 <mercury^> They have different performance profiles for different problems, but they can both solve the same problems.
11:17:47 <mauke> mercury^: I can't find stack frames in the standard
11:18:06 <mauke> I'm looking for a description of what happens when a function returns
11:19:26 <Berengal> mauke, the standard doesn't mention stacks at all. It doesn't presume that CPUs all have stacks
11:19:52 <mauke> so could an implementation allocate but never release stack frames?
11:20:18 <Jafet> An implementation could just crash on function calls
11:20:23 <Berengal> Don't know, I haven't really studied the standard
11:20:28 <Jafet> Since they are never required to succeed
11:20:42 <Berengal> But basically, when you sum it all up, it just says "C programs are undefined behaviour"
11:20:44 <mauke> void f() {} int main(void) { for (;;) f(); }  // can this eat my memory?
11:20:55 <mercury^> mauke: if you don't decrease the SP upon return, the calling function won't work anymore.
11:21:04 <mauke> mercury^: there is no SP
11:21:44 <dons> yo yo
11:21:58 <dons> i'm about to give a 75 minute talk to ~200 undergrads at UIUC on haskell
11:22:02 <dons> here's the slides, http://www.galois.com/~dons/talks/ACM-RP-Multicore.pdf
11:22:02 <mauke> λo λo
11:22:13 <dons> its in 2 hours, so if anyone wants to comment/ check over the slides
11:22:15 <dons> i'd appreciate  it.
11:22:48 <Berengal> dons, will there be video?
11:22:50 <dons> i'm on after bram moolenaar.
11:22:53 <dons> yes
11:23:02 <Berengal> nice
11:23:56 <mercury^> dons: the shootout screenshot is out of date ;p
11:24:19 <dons> doh. it might be, yeah. that was taken back in september.
11:24:21 <conal> dons: good luck.  i hope you inspire the heck out of them!
11:24:30 <dons> ah, Ada has climbed up!
11:24:35 <byorgey> dons: blow some undergrad minds!
11:24:46 <dons> conal: cheers! its all about inspiring them :)
11:25:01 <mercury^> Hmm, I don't see in what way either is fundamentally constrained. too.
11:25:07 <mercury^> err
11:25:08 <mercury^> wtf
11:25:15 <mercury^> "JVM has climbed up too"
11:25:32 <dons> ah ha so it has
11:25:48 <dons> well spotted
11:27:35 <dons> byorgey: do you know the formal methods guys here at UIUC?
11:27:43 <dons> using Maude for a bunch of things.
11:27:48 <conal> dons: "If you want to build a ship, don't drum up people together to collect wood and don't assign them tasks and work, but rather teach them to long for the endless immensity of the sea." - Antoine de Saint-Exupéry
11:27:50 <dons> i hope to convert them over to the GHC way
11:28:00 <dons> conal: :D
11:28:25 <conal> :)
11:28:29 * dons will try to channel conal's calm focus and inspiration
11:28:39 <conal> :)
11:29:03 <conal> dons: i'll share some vibe with you from here
11:29:26 <dolio> I think more work will probably need to be put into ESC/Haskell or something like it before you can start converting Maude people.
11:29:53 <byorgey> dons: no, I don't know them
11:29:55 <dons> they should find eg. .Agda/ Haskabelle et al interesting.
11:30:30 <byorgey> dons: hehe, I like the "concurrency hierarchy" picture =)
11:30:31 <FunctorSalad> while I agree with the general sentiment, don't you need both realistically? ;)
11:30:37 <FunctorSalad> (@ conal )
11:30:43 <byorgey> those heavy OS threads look pretty heavy.
11:30:51 <FunctorSalad> or @Saint-Expurey
11:31:00 <dons> hehe
11:31:18 <dons> you can see directly why OS threads aren't appropriate for speculation :)
11:31:45 <FunctorSalad> convert? why not make a maude binding for haskell :)
11:32:32 <dons> bbl
11:34:47 <conal> FunctorSalad: maybe Saint-Exupery is suggesting that a more joyful and scalable process is to inspire people, who will then drump themselves & each other up to collect wood etc.
11:35:17 <conal> (drum)
11:35:28 <mauke> re Saint-Exupery: lemmings
11:35:32 <byorgey> dons: s/Goerzon/Goerzen/ on slide 88
11:36:08 <Jafet> L. Ron Hubbard had a similar idea
11:36:42 <BMeph> Jafet: That Goerzon should be Goerzen? ;)
11:37:25 <FunctorSalad> building ships is hard, let's go chatting
11:37:39 <FunctorSalad> :o
11:38:03 <Jafet> Not exactly
11:38:19 <Jafet> But I'm sure he could have had.
11:39:34 <mmorrow> conal: (was just looking at the log) i think you're responsible for bringing to my attention at least 3+ quotes that went directly into my $HOME/QUOTES.txt
11:39:38 <iaefai> conal: Your  paper on push-pull-frp is interesting, yet way above me :p
11:39:54 <mmorrow> <conal> dons: "If you want to build a ship, don't drum up people together to collect wood and don't assign them tasks and work, but rather teach them to long for the endless immensity of the sea." - Antoine de Saint-ExupÃ©ry
11:39:55 <iaefai> L. Ron Hubbard - Saint who revealed the true nature of our existence.
11:40:17 <dons> hmm. watching bram moolenaar talk about a new language he's working on for writing vim
11:40:21 <skorpan> :t (-)
11:40:22 <lambdabot> forall a. (Num a) => a -> a -> a
11:40:37 <conal> iaefai: try "Denotational design with type class morphisms".  it describes the way i approach library design.  the frp paper is an example, as is "beautiful differentiation".
11:40:51 <mmorrow> dons: writing the prog itself, or as an embedded language to script it?
11:41:30 <conal> mmorrow: glad to know!  :)
11:42:09 <mmorrow> "the endless immensity of the sea" makes that quote
11:42:20 <conal> mmorrow: yeah!  yum.
11:42:35 <dons> whitespace layout, fast, statically typed.
11:42:43 <dons> optimized for adding new   keywords. weird.
11:42:52 <dons> mmorrow: for writing the app
11:43:04 <mmorrow> dons: oh cool
11:43:23 <dons> well, not so sure how cool it is :)
11:43:41 <dolio> So he's writing a Haskell knock-off to write a new vim? :)
11:43:49 <conal> my intent is to offer perspectives but not suggest there's any exclusively right one.  if someone has a resonance then wonderful, and if not, then wonderful.
11:45:10 <Eelis> i guess bram is tired of receiving patches for vim. moving to a new language nobody knows will certainly solve that
11:45:30 <dons> well, i think this language is more like say, D
11:45:37 <mmorrow> dons: well, it'll probably be amusing either way ;)
11:45:38 <dons> D crossed with Python
11:45:42 <Berengal> I've been trying to get others to long for haskell, but failing. "Yet another NullPointerException! This is frustrating!" "What if there were no nulls?" "Madness!"
11:45:48 <copumpkin> eww
11:45:50 <mmorrow> oh noes
11:45:56 <dons> i should send him my paper on writing vim in haskell
11:46:14 <dons> seems like a nice guy
11:46:51 <dons> http://www.zimbu.org/
11:46:54 <dons> is the language
11:47:24 <copumpkin> Welcome to zimboorg
11:47:28 <copumpkin> Anything is possible at zimboorg
11:47:34 <copumpkin> *zimbu
11:47:35 <monochrom> "If you want to build a ship, don't drum up people together to collect wood and don't assign them tasks and work, but rather teach them to long for communist revolution, then they will eager build a ship, nay, as many ships as you want."
11:48:34 <conal> Berengal: "New and stirring things are belittled because if they are not belittled, the humiliating question arises, ``Why then are you not taking part in them?''" - H.G. Wells
11:48:36 <mauke> haha, holy fuck
11:48:48 <dmwit> copumpkin: Hm, did you mean zombocom?
11:48:52 <en0th> :quote
11:48:53 <mauke> } ends blocks. there is no { because blocks are started implicitly
11:49:00 <copumpkin> dmwit: I was alluding to it, but I meant zimbuorg
11:49:12 <monochrom> haha mauke that's a funny design
11:49:15 <conal> Berengal: one reason of many to hang onto old ways.
11:49:17 <dmwit> oh oh, I get it now
11:49:25 <Berengal> conal, indeed... Inertia sucks
11:49:47 <monochrom> But lisp does a similar thing.  ((((...((( ], no matching [
11:49:48 <FunctorSalad> mauke: that'll confuse emacs
11:49:53 <conal> Berengal: yep.  also, Inertia is the container in which change happens.
11:49:58 <mauke> monochrom: reminds me of http://www.perl.com/lpt/a/526
11:50:25 <conal> Berengal: something i tell myself when i get impatient with people, and i'd rather enjoy them.
11:52:09 <Berengal> conal, interesting. I tend to just want to beat them with a cluebat, then remind myself that transitioning to XML is still moving to a declarative language...
11:52:27 <conal> Berengal: :) :(
11:53:34 <conal> Berengal: i relate more to the cluebat than attempting to embrace xml.
11:54:23 <Berengal> I see a possible future, where all of todays java programmers are programming in XML, then someone points to something like Haskell (or ports parts of haskell to java, as has been done to C#), which becomes the next "cool thing", and lispers all over start to cry
11:55:02 <Berengal> Alternatively, the java programmers turn to clojure instead
11:55:10 <Jafet> Scala!
11:55:17 <Jafet> No wait, that's too novel
11:55:56 <Berengal> conal, XML has horrible syntax, but once you get past it there's a plethora of declarative languages... all of them with horrible syntax
11:56:08 <FunctorSalad> \o/
11:56:31 <mauke> preflex: remember <Berengal> conal, XML has horrible syntax, but once you get past it there's a plethora of declarative languages... all of them with horrible syntax
11:56:55 <conal> Berengal: is XML itself inherently declarative-friendly?  any more than ascii is?
11:57:09 <conal> maybe it's cultural
11:57:16 <conal> since xml evolved out of sgml
11:57:29 <Berengal> conal, ascii doesn't have structure, it's just a character encoding. It's equivalent to s-expressions
11:58:01 <mmorrow> what's equivalent to s-expressions?
11:58:07 <mmorrow> ascii or xml?
11:58:09 <Berengal> xml
11:58:09 <conal> xml is like s-expressions.
11:58:25 <mauke> and everyone knows how declarative lisp is
11:58:33 <Jafet> S-expressions don't have attributes
11:58:37 <Jafet> Or schemas
11:58:48 * FunctorSalad hates attributes
11:59:02 <conal> Berengal: i'm thinking declarative or imperative comes neither from te ascii layer nor the xml/s-exp layer, but from what's built on top -- the semantic layer.
11:59:07 <Berengal> Jafet, attributes are just elements with a single child
11:59:31 <Warrigal> Is there a simplify function for Expr?
11:59:33 <Berengal> conal, indeed. There's plenty of imperative languages using xml as its syntax as well, like ant
12:00:03 <Jafet> Berengal, sure, you can emulate
12:00:13 <FunctorSalad> it'd be like if haskell ADT constructors had *two* lists of fields, with the two fields using arbitrary different syntax
12:00:28 <FunctorSalad> *the two sorts of fields
12:00:29 <Berengal> But, and this is purely conjecture, it's easier to reason declaratively, and it's easier to translate xml to declarative instructions than, say, java
12:00:47 <Jafet> XML is a data structuring format, nothing more
12:00:58 <Jafet> A badly inefficient one, but I digress
12:01:11 <Berengal> Jafet, <elem attr=val /> -> (elem ((attr val)))
12:01:18 <conal> landin showed us the way back in the 1960s with "the next 700 programming languages".  imagine replacing xml with iswim.
12:01:20 <Berengal> Jafet, something like that would be unambigous
12:01:35 <conal> and, btw, iswim is now pronouned "haskell".
12:02:20 <Berengal> conal, and "haskell" is a collection of languages, the term language being lambda calculus with extra sugar
12:03:35 <Jafet> Lambda calculus and unsafePerformIO, sounds like a promising primitive
12:03:49 <conal> Berengal: yep.
12:04:09 <ben_m> What's the most elegant way to map f over a list and return (n, f n)? (return a list of tuples of the values and the function applied to the values)
12:04:16 <conal> and, when i say "haskell", i don't include IO, let alone unsafePerformIO
12:04:29 <ben_m> As in `map (\x -> (x, x*x)) [1..]`
12:04:39 <conal> ben_m: map (id &&& f)
12:04:41 <byorgey> ben_m: map (id &&& f) [1..]
12:04:48 <Jafet> Haskell is known muchly for the way it does IO, though
12:04:49 <Berengal> map ((,) <*> f)
12:04:51 <ben_m> I knew there has to be something clever :)
12:04:52 * conal high-fives byorgey
12:04:53 <ben_m> Thank you guys.
12:04:59 * byorgey high-fives conal
12:05:02 <ray> it's a shame
12:05:04 * ben_m high-fives all of you
12:05:08 <Jafet> @pl \x -> (x, f x)
12:05:08 <lambdabot> ap (,) f
12:05:13 <conal> Berengal: ooh -- hard core!
12:05:15 <en0th> :t zipWith
12:05:16 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:05:21 * Berengal high-fives @pl
12:05:25 <byorgey> ben_m: ... &&& being from Control.Arrow
12:07:07 <ben_m> What is @pl?
12:07:14 <Berengal> pointless
12:07:19 <ben_m> Oh :)
12:07:20 <Berengal> @pl \x -> f x
12:07:21 <lambdabot> f
12:07:26 <ben_m> Yeah.
12:07:29 <FunctorSalad> but it doesn't know about arrows
12:07:51 <conal> does pl know applicative now?
12:07:52 <ben_m> Just trying to figure out that ap (,) f thing
12:07:59 <FunctorSalad> (id &&& f) is much clearer imho
12:08:05 <Berengal> FunctorSalad, who needs arrows when you've got S, K and I? ;)
12:08:11 <ben_m> I'll have to check out Arrows first, but it looks clearer.
12:08:27 <Twey> @pl \x -> (x, f x)
12:08:28 <lambdabot> ap (,) f
12:08:28 <conal> i hate to see people exposed to monad before applicative.  then they write unnecessarily sequential-looking code.
12:08:34 <Twey> Oh, I see.
12:09:00 <en0th> i wish i haven't seen the do notation
12:09:16 <iaefai> conal: What would one read to do applicative before the monad?
12:09:28 <aavogt> conal: that and there are still some Monads that aren't Applicative
12:10:04 <FunctorSalad> fixed-size vectors, I don't know many others
12:10:19 <FunctorSalad> aavogt: other way around
12:10:31 <conal> iaefai: i don't know.  :(
12:10:46 <Twey> What was that article that built up from Pointed?
12:10:46 <conal> iaefai: the seminal Applicative paper is a tough intro.
12:10:49 <aavogt> @instances-importing Identity
12:10:50 <lambdabot> Couldn't find class `Identity'. Try @instances-importing
12:10:54 <Berengal> typeclassopedia presents them in the right order, doesn't it?
12:10:58 <aavogt> @instances-importing Control.Monad.Identity
12:10:58 <lambdabot> Couldn't find class `Control.Monad.Identity'. Try @instances-importing
12:11:10 <FunctorSalad> aavogt: ah you mean not declared applicative?
12:11:19 <aavogt> FunctorSalad: well anyways, Identity isn't a member of Applicative
12:11:23 <aavogt> yes
12:11:35 <FunctorSalad> that's really annoying because you can't add the instance 'cause then the code will break later
12:11:42 <seanmcl> Is it possible to use StateT m a when m already is declared to be a MonadState?  E.g., f :: MonadState s m => Int -> StateT Int m Int ?
12:11:56 <mauke> seanmcl: sure
12:12:14 <ben_m> conal: Got anything for beginners, so that I can read about Applicative before I read more about Monads?
12:12:58 <seanmcl> mauke: so what does State.get do in this case?  Does it grab the Int from the StateT, or the s from m?
12:13:41 <seanmcl> In particular, if s = Int, then which one does it grab, since typing can't figure out the difference
12:13:48 <Berengal> ben_m, http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
12:14:14 <ben_m> Berengal: thank you :)
12:14:33 <ben_m> ... great. 5 minutes in here and I already have another 5 tabs open to read
12:14:54 * Berengal has 150, but he has been around for a while
12:15:06 <mauke> seanmcl: it will refer to StateT
12:15:27 <paolino> hi, if I want to extract function f from g in here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4419#a4419 , f is a rank2 ?
12:17:07 <FunctorSalad> paolino: the x on the left is shadowed by your 'let'
12:17:30 <paolino> right
12:18:19 <seanmcl> mauke: amazing.  it works.  Thanks very much.
12:18:19 <paolino> f x = () in f x maybe is better
12:20:33 <paolino> FunctorSalad: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4419#a4420
12:21:13 <FunctorSalad> paolino: it's not clear what you're trying to accomplish with that function
12:21:33 <conal> ben_m: sadly, I don't :(
12:22:01 <paolino> it's the simplest I could build to ask a question, it has no value
12:22:24 <paolino> (and I got it wrong :/ )
12:24:49 <paolino> FunctorSalad: if I want to put f outside the existential scope , what kind of function is that ?
12:25:05 <FunctorSalad> paolino: you can't
12:25:36 <paolino> ah, I thought it has something to do with higher ranks
12:25:41 <FunctorSalad> paolino: you can only consume the values stored in an existential type by feeding them to a computation that works for *any* possible type hidden in the existential
12:26:04 <FunctorSalad> like "f (A x) = show x", if your A had a Show context
12:26:33 <paolino> mh f is not eating A's
12:29:51 <Raevel> what config file format should i use for my app?
12:30:57 <Jafet> XML
12:31:21 <mauke> INI
12:31:59 <FunctorSalad> literate cobol
12:32:12 <Raevel> this took an unexpected turn
12:32:50 <Raevel> perhaps i'll check out ConfigFile
12:32:51 <FunctorSalad> sorry :) but seriously there are some hackage pkgs
12:32:57 <FunctorSalad> including "extremely easy config"
12:41:46 <en0th> woah i'm so happy with this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4421#a4421
12:42:06 <en0th> it's from programming languages: application and implementation
12:45:39 <lysgaard> How do i concat three Word8 intoo one Word32?
12:45:56 <copumpkin> shift them and or them together until you get what you want
12:47:03 <lysgaard> copumpkin: Ah, never been doing much binary stuff. Anywhere the sift and or is explained?
12:47:12 <copumpkin> Data.Bits
12:47:16 <copumpkin> oh you mean just conceptually?
12:47:32 <maltem> fromIntegral v .|. shiftL (fromIntegral w) 8
12:48:32 <FunctorSalad> @ty shiftL
12:48:33 <lambdabot> forall a. (Bits a) => a -> Int -> a
12:49:00 <FunctorSalad> (wasn't sure about arg order)
12:49:16 <maltem> yeah the argument order is unusual when you use it prefix
12:54:29 <lysgaard> Okay, let's say i want to make two the Word8s' 00000000 and 11111111 intoo 0000000011111111, eg. an Word16. Could you give me the example, then i guess I'd understand.
12:56:28 <copumpkin> I wouldn't use 0s, it kinda hides the magic
12:56:51 <copumpkin> say you have a = 01101100 and b = 11100111
12:57:03 <copumpkin> and you want to "concatenate" them, bitwise
12:57:22 <copumpkin> you shift a 8 bits left so you get 0110110000000000
12:57:29 <copumpkin> and then you do a bitwise OR of that with b
12:57:32 <Jafet> Write them sequentially in memory and then read them as a Word32!
12:57:45 <copumpkin> Jafet: that's more painful in haskell than just shifting and ORing :P
12:58:01 <copumpkin> besides, you then need to be aware of your machine's endianness
12:58:01 <Jafet> (Is that even possible?)
12:58:12 <copumpkin> sure
12:58:12 <aavogt> @type poke
12:58:13 <lambdabot> Not in scope: `poke'
12:59:03 <FunctorSalad> @ty Foreign.poke
12:59:04 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
12:59:19 <Jafet> Aah my eyes
12:59:44 <lysgaard> copumpkin: So: f w1 w2 = (shift w1 8) .|. w2
12:59:57 <copumpkin> yep, or shiftL to be more explicit
13:00:04 <copumpkin> shift deals with positive and negative values
13:00:30 <aavogt> > shiftL 128 (-4)
13:00:31 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:00:31 <lambdabot>    `Data.Bits.Bits t'
13:00:31 <lambdabot>      a...
13:00:35 <aavogt> > shiftL 128 (-4) :: Int
13:00:36 <lambdabot>   8
13:00:48 <copumpkin> > shift 128 (-4) :: Int
13:00:49 <lambdabot>   8
13:00:52 <copumpkin> > shiftR 128 (-4) :: Int
13:00:54 <lambdabot>   2048
13:01:02 <copumpkin> so shift = shiftL
13:01:32 <aavogt> > shift 'a' 1
13:01:33 <lambdabot>   No instance for (Data.Bits.Bits GHC.Types.Char)
13:01:33 <lambdabot>    arising from a use of `D...
13:02:51 <mercury^> Anyone here has experience with rotation inside codeblocks when using lhs2tex?
13:03:32 <aavogt> mercury^: I have never rotated under the influence of lhs2tex
13:06:31 <aavogt> hmm, seems I just used the listings package
13:06:42 <aavogt> so I didn't actually use lhs2tex
13:07:03 <mercury^> I managed it already, thanks.
13:07:11 <mercury^> Still not very nice, but at least it worked.
13:19:21 <jagwire> > let S = T String | N String
13:19:23 <lambdabot>   <no location info>: parse error on input `|'
13:19:24 <ben_m> What is the use of const? Does it just result in the second parameter? :/
13:19:36 <Jafet> @src const
13:19:36 <lambdabot> const x _ = x
13:19:38 <jagwire> > data S = T String | N String
13:19:39 <lambdabot>   <no location info>: parse error on input `data'
13:19:47 <ben_m> first, sorry
13:20:08 <jagwire> no location info?
13:20:10 <mercury^> ben_m: it is useful as an argument to other functions at times
13:20:13 <ben_m> mylength = foldr (const (+1)) 0 -- trying to wrap my head around that
13:20:42 <tomh-> @src const
13:20:42 <lambdabot> const x _ = x
13:20:57 <tomh-> oh its right there -.-
13:21:21 <mercury^> > foldr (const +1) 0 [a,b,c]
13:21:22 <lambdabot>   No instance for (GHC.Num.Num
13:21:22 <lambdabot>                     (SimpleReflect.Expr -> Sim...
13:21:32 <jagwire> let's say I wanted to pattern match a complicated type in a list
13:21:37 <jagwire> such as
13:21:55 <jagwire> data P = String :--> [String]
13:22:15 <jagwire> but I want a list of P
13:22:30 <jagwire> so I would use something like x:xs
13:22:43 <jagwire> but would I extract String :--> [String] from x ?
13:23:20 <Jafet> [1,0,-1..]
13:23:23 <Jafet> > [1,0,-1..]
13:23:24 <lambdabot>   <no location info>: parse error on input `..'
13:23:54 <lpjhjdh> can I export c-style macros from a module somehow?
13:24:22 <allbery_b> foo ((xh:-->xt):xs) = ...
13:24:51 <Gracenotes> the syntax allowed for ranges is rather hard-coded. [a..], [a,b..], [a..c], or [a,b..c]. correspond to enumFrom, enumFromThen, enumFromTo, enumFromThenTo
13:27:08 <Berengal> What's the easiest way to download a file?
13:27:24 <Berengal> Something like :: String -> String -> IO ()
13:27:26 <calsaverini> anyone had problems to install the xmonad-contrib package with cabal?
13:27:28 <jagwire> Right click, save as?
13:28:27 <Jafet> More like String -> String -> HTTPCodeOrOneOfSeveralOtherTerribleThings
13:28:35 <calsaverini> I got a problem with dependency X11-xft-0.3
13:28:49 <calsaverini> Resolving dependencies...
13:28:49 <calsaverini> Configuring X11-xft-0.3...
13:28:49 <calsaverini> cabal: The pkg-config package xft is required but it could not be found.
13:28:49 <calsaverini> cabal: Error: some packages failed to install:
13:28:52 <calsaverini> X11-xft-0.3 failed during the configure step. The exception was:
13:28:53 <Berengal> Jafet, whatever, it's the side effect I'm interested in
13:28:56 <calsaverini> exit: ExitFailure 1
13:28:59 <calsaverini> xmonad-contrib-0.8.1 depends on X11-xft-0.3 which failed to install.
13:29:29 <calsaverini> ops... sorry for the flood
13:29:49 <calsaverini> It wasn't supposed to copy all that text
13:30:13 <aavogt> calsaverini: well the actual error isn't in that flood...
13:30:16 <aavogt> @hpaste
13:30:17 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:30:27 <aavogt> calsaverini: put the whole error there
13:30:29 <mauke> yes, it is
13:30:32 <FunctorSalad> Berengal: download-curl
13:30:40 <calsaverini> that's all I got
13:30:49 <mauke>  cabal: The pkg-config package xft is required but it could not be found.
13:30:56 <calsaverini> I have no other error msg
13:31:00 <Berengal> FunctorSalad, thanks, that looks about right
13:31:17 <aavogt> mauke: true, I missed that somehow...
13:31:22 <c_wraith> So, it looks error inside of STM rolls back the transaction...
13:31:37 <FunctorSalad> or (raw "curl" [foo]) o_O
13:31:46 <FunctorSalad> *rawSystem
13:32:06 <c_wraith> Which means that STM is *really* cool.
13:33:44 <c_wraith> yay for not having to clean up MVars after errors, because of using TMVar instead.
13:35:23 <calsaverini> humm, so should I try to install it manualy or there is some workaround?
13:36:14 <jimi_hendrix> what function puts something on the end of a list
13:36:34 <Jafet> (:)
13:36:40 <c_wraith> Other end, Jafet
13:36:44 <LeoD_> ++[x]
13:36:50 <Jafet> "That's what she said"
13:37:26 <Jafet> I imagine it would be painful to do it to that end often
13:37:38 <c_wraith> It is.
13:37:44 <c_wraith> That's an O(n) operation
13:37:51 <LeoD_> yea
13:38:08 <monochrom> ++ [x] in a loop reflects a design problem.
13:38:24 <jimi_hendrix> thanks LeoD_
13:38:31 <copumpkin> use an unfold
13:38:40 <jimi_hendrix> unfold?
13:38:44 <copumpkin> :t unfold
13:38:46 <lambdabot> Not in scope: `unfold'
13:38:46 <copumpkin> :t unfoldr
13:38:47 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:39:12 <jagwire> let's say I have data P = String [S] where S = A String | B String
13:39:15 <jagwire> erm
13:39:18 <jagwire> let's try that again
13:39:27 <jagwire> let's say I have data P = String :--> [S] where S = A String | B String
13:39:28 <FunctorSalad> ok
13:39:31 <monochrom> Use a pastebin. Paste actual code.
13:39:42 <FunctorSalad> advicemonochrom?
13:39:43 <Twey> That's not legal Haskell.
13:39:51 <jagwire> My apologies, monochrom.
13:39:52 <calsaverini> @src unfoldr
13:39:53 <lambdabot> unfoldr f b  = case f b of
13:39:53 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
13:39:53 <lambdabot>    Nothing        -> []
13:39:56 <monochrom> Use copy-and-paste, don't re-type yourself.
13:40:02 <c_wraith> Also, the DList package is good for a list you want to append to often (like with a writer monad)
13:40:12 <jagwire> if I have a list of P
13:40:15 <monochrom> Oh don't worry, I'm just giving recommendations.
13:40:25 <jagwire> how can I check if P's second argument is of A or B?
13:40:51 <jagwire> secondly, since there's a list of a list occuring in there
13:41:04 <jagwire> how can i "loop" through so to say to process everything in the second argument?
13:41:42 <monochrom> P's second argument is a list of S's. Some of them are A's, some of them are B's. "is of A or B" makes no sense.
13:41:54 <Twey> jagwire: I presume you mean: data S = A String | B String; P = String :--> [S]
13:42:03 <Twey> Er, s/P/data P/
13:42:31 <monochrom> See how re-typing things yourself is always a regression. :)
13:42:36 <Twey> Heh.
13:42:50 <monochrom> Also order is unimportant. Can define P first then S.
13:42:59 <jagwire> yes, twey.
13:43:05 <jagwire> Twey*
13:43:22 <monochrom> Oh I see, you're correcting the "where".
13:43:51 <jagwire> if you're familiar with java at all, I'm kind of looking for something similar to instanceof, if that makes sense
13:43:52 <Twey> In which case you can do something like: justAs [] = []; justAs ((A s) : ss) = s : justAs ss; justAs ((B _) : ss) = justAs ss
13:44:19 <Twey> Or, more concisely, justAs ss = [s | (A s) <- ss]
13:44:54 <jagwire> what is <- ?
13:45:20 <Twey> If one has access to the constructors, one can pattern-match on the constructor and discover which constructor was used in the construction of the value that way.
13:45:20 <Zao> In a list comprehension, the thingie you put between your binding and the list that goes into it.
13:45:23 <copumpkin> jagwire: instanceof tends to be bad in java too... I don't really see how you'd apply that to haskell except for Data.Dynamic
13:46:10 <aavogt> copumpkin: overlapping instances?
13:46:13 <Twey> Otherwise (and possibly even so), you must define your own functions isA (A _) = True; isA _ = False; isB (B _) = True; isB _ = False, &c.
13:46:53 <Twey> Yes… the idea of an instanceOf for every type is not one that really makes sense except for dynamically-typed values.
13:47:14 <jagwire> Twey, let's say I have access to the constructors
13:47:23 <Twey> Then you can do as I said above.
13:47:41 <jagwire> how would you go about pattern matching it?
13:47:46 <monochrom> instanceof is reduced to pattern matching
13:48:55 <Twey> jagwire: As in the example I gave you above.
13:53:39 <jagwire> okay, and how could one process nested lists?
13:54:01 <jagwire> let's say I'm looking for a specific character in a list of strings... (might be a bad example, but only one I can think of)
13:54:12 <Paczesiowa> can someone with >6.10.4 test if this code still crashes ghc http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10869 ?
13:54:52 <maltem> > filter (elem 'x') ["one x", "two xx", "none"]
13:54:53 <lambdabot>   ["one x","two xx"]
13:57:18 <ben_m> Is there a generic way to get the value out of a Monad? Something like fromJust, except that it works for every Monad. (like <-)
13:57:40 <Zao> ben_m: You're assuming you can get a value out of a Monad.
13:57:46 <Zao> *any
13:58:03 <ben_m> Hmm, yeah, I assumed that this would pose a problem.
13:58:33 <Paczesiowa> unsafePerformM
13:59:18 <ben_m> Thanks, but I'm satisfied with what Zao said.
13:59:33 <ben_m> Still trying to fully understand Monads and everything involved with them.
14:01:44 <Paczesiowa> ben_m: that was just a bad joke
14:02:02 <maltem> ben_m, (>>=) is as "getting out the value" as you can get
14:02:16 <Paczesiowa> ben_m: you could create unit-like type (data Unit a = Unit) and make it an instance of Monad
14:02:28 <Vanadium> >>= is "you can get the value out, but you have to put it back in when you are done playing with it", kind of
14:02:33 <blackh> ben_m: Here's another answer: Most monads have some sort of 'run' function which is how you get a value out.  The IO monad doesn't have an explicit run function except for that-function-whose-name-shall-not-be-spoken.
14:02:33 <Paczesiowa> ben_m: but what value would you like to get out of Unit?
14:03:51 <ben_m> hmm
14:04:00 <jimi_hendrix> is there a way to get a random number that isnt an IO Int
14:04:05 <jimi_hendrix> but just a normal Int
14:04:07 <maltem> the same value you want to get out of Nothing
14:04:25 <ben_m> I understand, thanks :)
14:04:41 <sshc> blackh: that-function-whose-name-shall-not-be-spoken ?
14:04:47 <Paczesiowa> jimi_hendrix: that would violate referential transparency and everything haskell stands for
14:05:09 <Vanadium> that-function-whose-name-shall-not-be-spoken . randomIO?
14:05:14 <maltem> > let g = mkStdGen 0 in random g :: (Int,StdGen)
14:05:16 <lambdabot>   (-117157315039303149,1346387765 2103410263)
14:05:38 <Paczesiowa> > let g = mkStdGen 0 in random g :: (Int,StdGen)
14:05:40 <lambdabot>   (-117157315039303149,1346387765 2103410263)
14:05:44 <Paczesiowa> not very random:)
14:06:19 <maltem> Paczesiowa, of course one has to initialize the generator in a random way ...
14:07:03 <jimi_hendrix> which is done how?
14:07:20 <blackh> sshc: unsafePerformIO (you're going to get me banned at this rate!)
14:07:22 <jimi_hendrix> :t g
14:07:23 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:07:27 <Paczesiowa> jimi_hendrix: create random number in main and pass it down to your pure code
14:07:36 <maltem> jimi_hendrix, guess how.. in IO of course. and see the docs for System.Random
14:08:01 <jimi_hendrix> ok
14:08:02 <maltem> which is to say, I cheated when I "answered" your question
14:08:17 <jimi_hendrix> maltem, how
14:08:38 <maltem> well I told you how to get a random number from a generator without involving IO
14:08:50 <maltem> but I didn't tell you how to get a generator without involving IO
14:10:46 <jimi_hendrix> :(
14:11:08 <jimi_hendrix> they all seem to involve IO
14:11:59 <Vanadium> Well, yeah.
14:12:13 <Vanadium> You need to do IO to get random numbers to seed your pure-functional random number generators.
14:12:32 <Vanadium> Like for checking an OS source of randomness, or the current time, or...
14:12:41 <jimi_hendrix> mkStdGen would do it maltem ?
14:14:54 <jimi_hendrix> but all of those return IO Ints right
14:15:56 <Paczesiowa> jimi_hendrix: how would you create random number without non-determinism/side effects?
14:16:24 <jimi_hendrix> magic
14:16:32 <jimi_hendrix> seed it with time (C instinct)
14:16:34 <c_wraith> isn't magic non-deterministic?
14:16:42 <c_wraith> eww.  never seed with time.
14:16:58 <jimi_hendrix> uhh i always do in C?
14:17:13 <c_wraith> That's a great way to have your software exploited
14:17:22 <jimi_hendrix> then what do you do
14:17:23 <c_wraith> Even in cases where you wouldn't think it would matter
14:17:26 <mle> safety depends on what you're using the numbers for.
14:17:43 <c_wraith> Like...  Nethack used to seed its RNG based on the time.
14:17:53 <c_wraith> Then a friend of mine exploited that in /dev/null's nethack tournament
14:17:53 <mle> using the microsecond count is perfectly reasonable for a lot of applications.
14:18:14 <c_wraith> To only create games at times where a wand of wishing would be generated on the first level.
14:18:15 <monochrom> "i always do in C" does not contradict with "magic" or "non-deterministic"
14:18:19 <mle> c_wraith: were they using tv_sec or tv_usec?
14:18:43 <c_wraith> mle:  seconds, clearly.
14:18:58 <c_wraith> But even basing it on usecs doesn't help a ton, in general.
14:19:05 <jimi_hendrix> so now what do they use c_wraith
14:19:06 <ttt--> what's the correct thing to use as seed then?
14:19:07 <maltem> System.Random's default seed is time indeed
14:19:12 <c_wraith> jimi_hendrix:  seed from /dev/urandom
14:19:21 <jimi_hendrix> how
14:19:24 <ttt--> ok :)
14:19:28 <mle> ttt--: analog noise generators, radioactive samples, etc.  Heh
14:19:34 <Paczesiowa> you can always use http://imgs.xkcd.com/comics/random_number.png
14:19:36 <jimi_hendrix> and that would make an IO Int...
14:19:43 <jimi_hendrix> lol
14:19:47 <maltem> but then, you don't use System.Random for serious random number needs anyways
14:19:47 * jimi_hendrix doesnt even need to look
14:20:06 * jimi_hendrix is just trying to shuffle a few cards...
14:20:15 <c_wraith> Yeah, the software I'm working on doesn't need crypto-quality random.  But it needs better than seeding based on the time.
14:20:49 <shambler> maltem, why?
14:21:07 <maltem> it's slow
14:21:24 <c_wraith> basically, computers are fast.  even seeding based on the microsecond isn't enough, often.  Because you can look at what you've seen so far, quickly determine what seed was used, and predict future numbers.
14:23:27 <Jafet> Then use a less predictable generator
14:30:39 <jimi_hendrix> hmm
14:30:49 <jimi_hendrix> it seems i almost figured it out
14:31:51 <jimi_hendrix> but why doesnt this cast to Int: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10870#a10870
14:34:54 <monochrom> IO Int is not supposed to be castable to Int.
14:35:14 <monochrom> Sorry you are stuck with IO if you use IO tools.
14:35:33 <Zao> In order to get the output of an IO action, you need to explicitly sequence it in an IO context.
14:35:55 <jimi_hendrix> and that means i cant use a bunch of handy functions right...
14:36:03 <benmachine> p.s. return doesn't return things
14:36:06 <calsaverini> :( can't install any package depending on X11-xft with cabal
14:36:25 <benmachine> well it *kind* of does but not in a C way
14:36:26 <monochrom> It means you can use another bunch of handy functions!
14:36:26 <Zao> return wraps a value in a comfortable monad shell.
14:36:45 <Heffalump> you can use any function that uses Int on an IO Int with liftM, you'll just get an IO value back
14:36:55 <benmachine> Applicative's name for the same thing is better (pure)
14:36:56 <Zao> jimi_hendrix: On the contrary. In a regular pure context you cannot use any IO, but in an IO context you can use regular pure functions.
14:36:57 <monochrom> If you have a pure function written, you can use it in an IO do block. I don't see any problem.
14:37:10 <Zao> benmachine: I use pure for two reasons.
14:37:15 <Zao> benmachine: It's shorter, and it annoys people :)
14:37:20 <benmachine> both approved
14:37:49 * Twey laughs.
14:37:57 <monochrom> For example, (+) is pure, and I see that you have successfully used it in IO already.
14:37:59 <Twey> I'll adopt that
14:38:57 <jimi_hendrix> Zao, how do i do IO context then
14:39:20 <jimi_hendrix> well whats the pure way to shuffle an array...
14:39:35 <Paczesiowa> id:)
14:39:39 <Heffalump> depends how fast you want it to be :-)
14:39:58 <benmachine> hmm
14:40:19 <jimi_hendrix> uhh good enough for a card game
14:40:27 <benmachine> on that note, I looked at some of my code and I'm pretty sure I can do this as Applicative IO: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10871#a10871
14:40:59 <benmachine> 1. am I right 2a. how do I do so 2b. why not
14:41:30 <Peaker> jimi_hendrix, before, I was about to explain lists and you disappeared
14:41:32 <jimi_hendrix> Peaker, sorry, real life called
14:41:38 <jimi_hendrix> i am here with ears open
14:41:41 <Twey> jimi_hendrix: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
14:41:56 <benmachine> wasn't that on hackage too?
14:41:59 <Peaker> jimi_hendrix, IO Int  allows you to do anything you want with that Int, but whatever you do, you'll end up with another "IO something" value if you want access to that Int
14:42:03 <Twey> benmachine: You can, but you don't really want to
14:42:14 <Peaker> jimi_hendrix, (An action can call actions and functions. Functions can only call functions)
14:42:18 <Twey> do-notation is nice for stuff like that
14:43:09 <benmachine> Twey: qualify "like"; what about it makes it suitable for doing?
14:43:23 <benmachine> p.s. http://hackage.haskell.org/package/random-shuffle
14:43:29 <Jeb> if i define a type such as     newtype Frog = F (Age,Size)
14:43:30 <Jeb>       how would I create a function that just returns Size?
14:43:34 <benmachine> jimi_hendrix: random shuffle on hackage ^
14:43:53 <benmachine> Jeb: f (F (_, s)) = s
14:44:11 <Peaker> jimi_hendrix, I wanted to explain how lists worked, since you were asking what the colons did. But I'd rather explain in #haskell-overflow because it'd flood here :)
14:44:22 <benmachine> or you could define your type as newtype Frog = F { unF :: (Age, Size) } and then use fst . unF
14:44:59 * ygd-coder is a begginer and needs some help but isn't quite sure what to do
14:45:13 <jimi_hendrix> uhh benmachine i installed that, and i got a bug
14:45:15 <jimi_hendrix> Peaker, ok
14:45:29 <Jeb> thanks benmachine, I forgot I could use pattern matching like that
14:45:55 <Twey> benmachine: It allows you to do this imperative impurely-create-then-merge pattern in a nice way
14:46:19 <benmachine> Twey: "nice" is surely in the eye of the beholder
14:46:19 <Twey> Even the equivalent desugared syntax is a bit ugly, and the Applicative version's going to be really nasty
14:46:34 <benmachine> okay
14:46:57 <benmachine> how about just telling me how I'd do the hSetBuffering without <-ing the socket
14:47:08 <benmachine> just for educational purposes
14:47:19 <Twey> I'm trying to convert the whole thing so you can see what I mean
14:47:20 <Cale> <-ing?
14:47:37 <Peaker> Twey, why really nasty?
14:47:40 <benmachine> Cale: >>=ing, if you like
14:47:42 <Twey> Ugh, but I forgot to carry that across…
14:47:48 <Twey> Peaker: Try it and see :þ
14:47:53 <ygd-coder> what exactly does >>= do?
14:47:54 <Peaker> Twey, what's the function?
14:47:58 <Cale> benmachine: errr... the socket isn't an IO action.
14:47:58 <Twey> There are three separate bits of state being carried along here
14:48:10 <benmachine> Cale: it comes out of one though?
14:48:14 <Cale> benmachine: Unless it's something which gets a socket?
14:48:20 <Twey> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10871#a10871
14:48:22 <monochrom> (you shouldn't want the "exact" answer, it's advanced)
14:48:33 <Cale> benmachine: perhaps, I'd have to see the code :)
14:48:49 <Peaker> ygd-coder, it fuses together an action, and a computation that takes that action's results to produce a new action -- and returns an action that performs the first action, computes the next action, performs that as well.  Basically fuses  [action, computation, action] into one action
14:48:57 <benmachine> Cale: it's Twey's link; a thing I suspect that can be applicatived but I'm not sure how
14:49:05 <ygd-coder> Peaker: any examples?
14:49:13 <Peaker> ygd-coder, getLine >>= print
14:49:19 <Peaker> @type getLine
14:49:20 <lambdabot> IO String
14:49:25 <Peaker> @type print
14:49:26 <lambdabot> forall a. (Show a) => a -> IO ()
14:49:28 <Peaker> @type getLine >>= print
14:49:30 <lambdabot> IO ()
14:49:58 <monochrom> getLine >>= putStrLn is less surprising if you enter the like of "
14:50:03 <Peaker> ygd-coder, print takes a value and computes an action that prints that value.   getLine >>= print   fuses getLine together with the action (print line_from_getline)
14:50:24 <ygd-coder> i think I get it
14:50:26 <Peaker> ygd-coder, You can /query, no dcc please
14:50:30 <Peaker> or #haskell-overflow
14:50:32 <calsaverini> I'm trying to install a cabal package but when I do a "runhaskell Setup configure" he complains about dependencies I already have installed
14:50:52 <calsaverini> Is there some way to force installation without dependency check?
14:50:57 <Cale> ygd-coder: (do v <- x; f v) is the same thing as (x >>= \v -> f v) is the same thing as x >>= f
14:51:07 <c_wraith> holy crap, I just figured out how DList works.  That's awesome.
14:51:33 <Cale> c_wraith: Usually I just compose functions directly without the library :)
14:51:52 <Cale> c_wraith: Or, which DList are you talking about?
14:51:58 <c_wraith> Yes, that one.
14:52:09 <c_wraith> Well, Data.DList
14:52:18 <calsaverini> I'm installing X11-xft to get xmonad-contrib to work, but it stucks when I complains that I don't have X11 and utf8-string which are both installed in the latest version
14:52:24 <Cale> yeah
14:52:31 <c_wraith> I was just thinking about it, and said "hmm.  an empty list must be..... id!  I get it now!"
14:52:32 <Twey> Argh, my head *dies of one-line-three-variables syndrome*
14:53:20 <Cale> You just take each element x in the construction of the list and replace it with the function (x:) and replace each (++) with (.)
14:53:46 <Cale> and yeah, empty list with id :)
14:54:28 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
14:55:15 <Cale> foldTree t b = f where f Tip = t; f (Branch x l r) = b x (f l) (f r)
14:55:45 <Cale> inorder = foldTree id (\x l r -> l . (x:) . r)
14:55:56 <Cale> er
14:56:01 <Cale> inorder t = foldTree id (\x l r -> l . (x:) . r) t []
14:57:23 <ygd-coder> ping?
14:57:46 * benmachine pongs ygd-coder 
14:58:32 <ygd-coder> how do i rewrite "parseNumber = liftM (Number . read) $ many1 digit"?
14:58:38 <ygd-coder> to use do and >>=?
14:59:13 <ksf> many1 digit >>= return . Number . read
14:59:34 <Paczesiowa> do many1 digit >>= return . Number . read
14:59:52 <ksf> also, fmap (Number . read) $ many1 digit
14:59:54 <ygd-coder> what happened to the liftM?
14:59:55 <copumpkin> wait, why would you want do AND >>= ?
15:00:04 <ygd-coder> it's an exercise in a tutorial
15:00:12 <Paczesiowa> ygd-coder: liftM is like  >>= return.
15:00:16 <Peaker> If you use >>= and .   do try =<< ?
15:00:17 <ksf> or, preferrably, (Number . read) <$> many1 digit, which is proper applicative style.
15:00:18 <ygd-coder> oh
15:00:18 <copumpkin> just throw do in front of something
15:00:30 <ygd-coder> okay
15:00:43 <copumpkin> :t readLine
15:00:55 <copumpkin> :t do readLn
15:00:58 <lambdabot> Not in scope: `readLine'
15:00:58 <lambdabot> forall a. (Read a) => IO a
15:01:01 <copumpkin> :t readLn
15:01:03 <lambdabot> forall a. (Read a) => IO a
15:01:04 <Paczesiowa> I'd make (:t Number undefined) instance of Read and use read `fmap` many1 digit
15:01:23 <Peaker> ygd-coder, in "do" notation:  parseNumber = do { x <- many1 digit ; return (Number (read x)) }
15:01:58 <ksf> return . Number . read $ x
15:01:59 <jimi_hendrix> benmachine, question with that sort thing on hackage
15:02:18 <benmachine> jimi_hendrix: I've not used it, I just read about its existence
15:02:24 <benmachine> but go on
15:03:01 <jimi_hendrix> > shuffle [1..20] [1,2,3]
15:03:01 <jimi_hendrix> [2,4,6*** Exception: src/System/Random/Shuffle.hs:(52,6)-(55,30): Non-exhaustive patterns in function shuffleTree
15:03:02 <lambdabot>   Not in scope: `shuffle'
15:03:07 <jimi_hendrix> benmachine, ^
15:03:44 <copumpkin> needs moar patternz
15:03:45 <benmachine> jimi_hendrix: sounds like a bug, sure enough
15:04:04 <jimi_hendrix> well can i work around the bug some how?
15:06:43 <jimi_hendrix> benmachine, ^
15:06:59 <benmachine> no idea
15:07:11 <benmachine> sorry
15:07:23 <benmachine> if you were feeling particularly adventurous
15:07:34 <benmachine> you could try getting the source and examining it
15:07:39 <benmachine> finding where the pattern is missing
15:07:53 <benmachine> oh hey wait a minute
15:07:59 <benmachine> do you actually know what the function does?
15:08:10 <chrisdone> do you apply an argument to a function or function to an argument?
15:08:13 <benmachine> it may be that it requires both input lists to be the same length?
15:08:17 <benmachine> chrisdone: yep.
15:08:18 <benmachine> :P
15:08:35 <benmachine> there was a discussion about this recently
15:08:45 <Athas> jimi_hendrix: the second list argument to shuffle has to be one element shorter than the first, it seems.
15:08:50 <ksf> "apply" takes a function and an argument and shoves it in.
15:08:58 <Athas> That's not documented, though, and only mentioned as a comment in the code.  How bizarre.
15:09:13 <jimi_hendrix> aye
15:09:26 <jimi_hendrix> i say we make a community effor to get rid of his bug and document it
15:09:31 <ksf> ...usually, though I'd interepret "to apply an argument" as "that argument is a function and I pass it some parameter"
15:09:42 <benmachine> http://www.haskell.org/pipermail/haskell-cafe/2009-October/067228.html
15:10:03 <copumpkin> jimi_hendrix: what bug? in what package?
15:10:07 <jimi_hendrix> > shuffle [1..5] [1, 3, 2, 5]
15:10:07 <jimi_hendrix> [2,5,4,*** Exception: src/System/Random/Shuffle.hs:(66,6)-(79,27): Non-exhaustive patterns in function extractTree
15:10:08 <lambdabot>   Not in scope: `shuffle'
15:10:08 <Athas> jimi_hendrix: contact the maintainer.
15:10:13 <jimi_hendrix> will do
15:10:20 <Athas> > length [1..5]
15:10:21 <lambdabot>   5
15:10:22 <jimi_hendrix> System.Random.Shuffle
15:10:38 <Athas> Maybe that's another exciting bug!
15:10:54 <copumpkin> jimi_hendrix: I don't see that method
15:10:55 <copumpkin> @hoogle shuffle
15:10:56 <lambdabot> No results found
15:10:57 <benmachine> Monoid that's another exciting bug!
15:11:00 <Peaker> jimi_hendrix, "Non-exhaustive patterns" is exactly what we talked about in #overflow. It means the function didn't catch all possible patterns of the ADT, and that the programmer didn't care about exhaustive pattern matches in compile time
15:11:06 <Athas> Oh right, each element in the second list argument has to be "an independent sample -- from a uniform random distribution [0..n-i]".
15:11:28 <Athas> You've found a very picky function, yes.
15:11:39 <benmachine>     Bug reports:   [ Not specified ]
15:11:41 <benmachine> laaame
15:11:48 <benmachine>     Maintainer:    Manlio Perillo <manlio.perillo@gmail.com>
15:11:56 <benmachine> might be the guy to talk to
15:12:01 <jimi_hendrix> Peaker, ah i see
15:12:06 <chrisdone> benmachine: thanks michael rice for clearing that up
15:12:36 <Athas> jimi_hendrix: you should read the comment for shuffle in http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/src/System-Random-Shuffle.html#shuffle
15:12:46 <Athas> That shuffle function is very picky about what kind of arguments it accepts.
15:13:19 <benmachine> Athas: ideally though it should give a more informative error
15:13:24 <benmachine> when you don't
15:14:10 <jimi_hendrix> Athas, didnt i do what its pickiness wants?
15:14:27 <copumpkin> it seems odd to deliberately leave out other cases
15:14:49 <benmachine> @botsnack
15:14:49 <lunabot>  :o
15:14:50 <lambdabot> :)
15:14:50 <copumpkin> an error with a descriptive message is better than a generic one
15:15:00 <benmachine> copumpkin: sometimes people are lazy?
15:15:13 <benmachine> or if code is written for demonstrative purposes as I believe this originally way
15:15:17 <benmachine> was
15:15:23 <benmachine> then they are clutter
15:15:26 <copumpkin> benmachine: well, he wrote a comment saying that the missing cases are intentional
15:15:30 <Athas> jimi_hendrix: no, look at the requirements for the second argument.
15:15:44 <copumpkin> benmachine: in the time to write that, he could've written an error :P
15:15:44 <benmachine> copumpkin: lazy then :P
15:15:50 <benmachine> mm, true I suppose
15:16:05 <hackagebot> monad-wrap 0.0 - Wrap functions such as catch around different monads (DavidMazieres)
15:16:09 <benmachine> people do things for strange reasons
15:16:44 <jimi_hendrix> Athas, thats what i thought i did, but now i am confused
15:17:58 <zygoloid> > shuffle [1..5] [0,0,2,1,2]
15:17:59 <lambdabot>   Not in scope: `shuffle'
15:18:03 <zygoloid> :(
15:19:25 <Athas> jimi_hendrix: shuffle [1..5] [4,3..1]
15:19:28 <Athas> jimi_hendrix: that works.
15:19:55 <Athas> jimi_hendrix: note that the max value of the elements of the second list decreases for each element in the list.
15:20:26 <Athas> An element r[i] of the second list (of length n-1) must be in the interval [0..n-i].
15:20:48 <Athas> I don't know exactly what this function does, but it has so complex rules, it must be something important!
15:20:59 <dm`> Any hackage experts on here willing to give me some advice?  Tried to upload a package, ended up with the tar file, but no links to hackage documentation.  Do I need to do something special to get hackage docs up there?
15:21:44 <aavogt> dm`: the documentation is generated periodically
15:21:48 <jimi_hendrix> Athas, then how do i make it do a bunch of random stuff and not just reverse it
15:21:59 <dm`> aavogt: Okay, thanks.
15:22:28 <Athas> jimi_hendrix: presumably the intent is that you generate a distribution with your impure RNG of choice, then pass it to the (pure) shuffle function.
15:22:50 <Athas> Actually, I see there's a shuffle' function to do it for you.
15:23:20 <c_wraith> What I didn't like about that shuffle function was that doesn't return g' at the end.
15:23:47 <c_wraith> Why would you write a function that uses a generator, and doesn't return the new one at the end?
15:23:48 <Athas> This random-shuffle module seems like basically sound design, it's just really weird until you wrap your head around it.
15:24:50 <c_wraith> Athas:  I would not say that failing to return the new generator is sound design.
15:25:01 <HugoDaniel1> i have this monad called M, in it i have a StateT and a ReaderT, so i write f1 = do { f2; f2; f2; f3 } and f2 is something like: f2 = do { s <- get; news <- change s; put s; return}
15:25:11 <HugoDaniel1> why doesn't f3 sees the updated state ?!
15:25:45 <Athas> c_wraith: oh right, I didn't look closely at the shuffle' thing.
15:25:47 <Peaker> HugoDaniel1, can you quote exactly what f2 does?  That code won't compile
15:25:49 <monochrom> Perhaps f2 doesn't update anything.
15:26:01 <Athas> But it shows you what to do, jimi_hendrix.
15:26:12 <HugoDaniel1> peaker... its hard, its a huge code :/
15:26:23 <Peaker> HugoDaniel1, well, "return" doesn't do what it seems you might think it does
15:26:31 <monochrom> maybe "put s" should be "put news"
15:26:34 <HugoDaniel1> return () is the actual operation
15:26:42 <HugoDaniel1> monochrom: put news, yes...
15:26:47 <HugoDaniel1> i made a typo, sorr
15:26:50 <HugoDaniel1> sorry
15:27:01 <monochrom> maybe news and s are still the same
15:27:07 <Peaker> HugoDaniel1, put already returns (), you don't need () there
15:27:20 <Peaker> HugoDaniel1, you use "put s" and not "put news"?
15:27:28 <HugoDaniel1> ill try to make an hpaste
15:27:29 <HugoDaniel1> w8
15:27:35 <Peaker> monochrom, he used "s" not "news"
15:27:50 <benmachine> anyone have a clever way of verifying that all the values of a list are unique?
15:27:56 <monochrom> This is why hand-typing your code is confusing.
15:28:20 <ksf> > nub . sort $ "aoeuiuaoeuageuaoeu"
15:28:20 <monochrom> Humans need to make typos in order to survive.
15:28:20 <Zao> benmachine: Sort it, group it, map len, apply all (==1)
15:28:21 <lambdabot>   "aegiou"
15:28:30 <benmachine> Zao: sounds inefficient
15:28:56 <benmachine> in fact I should probably give the whole problem
15:29:21 <benmachine> I have a map (which is currently a [(x, x)] but could jsut as well be a Data.Map) and I want to check if it is bijective
15:29:38 <HugoDaniel1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10872#a10872 here it is, to anyone who can make something out of it :/
15:29:50 <Peaker> benmachine, I think N*logN is as efficient as it gets for a comparison based method
15:29:57 <HugoDaniel1> the problem is that, in the mainLoop, the coreSendMessage is not updating the state as it should :/
15:30:04 <stoop> benmachine, then you have answered your own question (that will allow you to do n log n).
15:30:08 <Zao> > let f = all (==1) . map length . group . sort in (f [42, 3, 5, 42], f [1..100])
15:30:09 <lambdabot>   (False,True)
15:30:16 <benmachine> Peaker: yeah I suppose so
15:30:47 <stoop> Zao, that is needlessly inexpensive, considering he has a map.
15:30:55 <stoop> Zao, (he can check on insertion for uniqueness).
15:31:24 <benmachine> stoop: but on insertion I need to check the value for uniqueness as well as the key
15:31:36 <stoop> (x, (x, Int))
15:31:53 <Peaker> benmachine, you can hold two maps instead of one
15:31:53 <jagwire> can you not use type constructors in an instance declaration?
15:31:53 <Peaker> benmachine, for both directions
15:31:55 <SamB_XP_> needlessly inexpensive?
15:32:01 <stoop> I don't think two maps are warranted.
15:32:05 <SamB_XP_> you mean, he can afford a more expensive one ?
15:32:05 <Peaker> jagwire, you can
15:32:11 <Zao> > let f x = nub x == x in (f [42, 3, 5, 42], f [1..100]) -- heh
15:32:12 <lambdabot>   (False,True)
15:32:12 <Peaker> stoop, why not?
15:32:17 <benmachine> stoop: how does that help
15:32:22 <Peaker> stoop, how do you check for 2-way uniqueness upon insertion?
15:32:22 <stoop> SamB_XP_, needlessly expensive.
15:32:40 <Zao> stoop: The map bit was not uncovered at that point.
15:32:45 <stoop> Peaker, (a, (a, b)), check if b + 1 > 1.
15:32:56 <Peaker> stoop, what?
15:33:18 <Peaker> stoop, are you mapping a's to a's?
15:33:37 <SamB_XP_> or, you could use the reimplementation of half of SQL in the typesystem that is most likely floating around on hackage ...
15:33:38 <stoop> Peaker, well, I'm assuming his keys are his values. (he said a list of (x, x))
15:33:49 <benmachine> I meant type (x, x)
15:33:59 <ksf> @check \x -> x + 1 > 1
15:34:00 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
15:34:19 <benmachine> although, it'd be interesting to see what techniques you could use for (x, y) as well
15:34:30 <c_wraith> @check \x -> x + 1 > x
15:34:30 <lambdabot>   "OK, passed 500 tests."
15:34:34 <ksf> argh! off-by-one! you have foiled my plans, again!
15:34:36 <stoop> Whatever the case, there is a mapping to a value, you can just hold a count associated with that value.
15:34:44 <Peaker> stoop, well, when inserting, you need to find the existing key, and also, any existing values like the pair you're inserting
15:35:14 <benmachine> Peaker: you're not inserting a pair
15:35:15 <Peaker> benmachine, I'd use  (Map k v, Map v k) and when inserting, first check if its in either map
15:35:16 <benmachine> er
15:35:19 <stoop> stoop, the key maps only to the value.
15:35:21 <benmachine> oh
15:35:26 <benmachine> that could make sense
15:35:28 <Peaker> benmachine, what are you inserting?
15:35:36 <stoop> Peaker, the key maps only to the value.
15:35:40 <benmachine> yeah
15:35:48 <benmachine> tha actual problem is representation of permutations
15:35:51 <stoop> Peaker, every key maps to a unique pair where uniqueness is determined by the first value in the pair.
15:35:53 <Peaker> I don't understand what operations the data structure is supposed to support
15:36:05 <benmachine> i.e. usually mapping an integral to another integral
15:36:21 <benmachine> I think I have confused everyone
15:36:26 <benmachine> allow me to start again
15:36:41 <stoop> benmachine, something like: f (x:xs) = insertWith' (+) x 1 $ f xs
15:37:15 <benmachine> I am trying to represent permutations i.e. mappings from a thing to a thing of the same type such that each thing has exactly one mapped-to thing
15:37:25 <benmachine> and the complete set of keys and values is identical
15:37:45 <stoop> Ok. :-)
15:37:53 <ksf> @hackage bimap
15:37:53 <lambdabot> http://hackage.haskell.org/package/bimap
15:37:55 <monochrom> If the type is an instance of Ix, you can use an array.
15:38:11 <benmachine> monochrom: I can, but that doesn't really solve my problems
15:38:15 <benmachine> just makes them faster!
15:38:44 <benmachine> (one notable problem here is that during construction of the mapping if you do it element-by-element you are going to have intermediate structures which do not adhere to the rules)
15:38:54 <benmachine> ksf: this sounds like fun
15:39:05 <jagwire> Peaker, pm?
15:39:18 <Peaker> jagwire, ok
15:39:26 <benmachine> are bimaps any more efficient than (Map k v, Map v k)?
15:39:50 <ksf> they're exacly that.
15:39:55 <benmachine> okay
15:40:37 * benmachine wonders why Bimaps return things in monads
15:41:09 <benmachine> Data.Bimap.lookup :: (Ord a, Ord b, Monad m) => a -> Bimap a b -> m b
15:41:14 <ksf> I doubt it's going to be a problem, as forall x . log x < 64. therefore, O(log x) = O(min 64, (log x)) = O(1)
15:41:19 <benmachine> is that a weird typesig or is that a weird typesig
15:41:20 <monochrom> Once upon a time, Data.Map.lookup uses monad too.
15:41:38 <benmachine> or is it bedtime for me anyway
15:41:45 <stoop> monochrom, why?
15:41:47 <benmachine> or /all three/?
15:42:00 <copumpkin> benmachine: it uses fail
15:42:01 <monochrom> the "fail" of monad is used if not found
15:42:16 <stoop> Ah.
15:42:37 <SamB_XP_> shouldn't that be called lookupL ?
15:42:40 <benmachine> ah, so I'm usually supposed to use Maybe
15:42:57 <benmachine> or
15:42:59 <benmachine> whatever
15:43:12 <Philonous> Is there a linear algebra package that doesn't require external libraries and doesn't need me to know vector dimensions at compile time?
15:43:31 <copumpkin> @hackage vector-space
15:43:31 <lambdabot> http://hackage.haskell.org/package/vector-space
15:43:38 <ksf> the one gpipe uses
15:44:00 <ksf> er wait you need to know dims at compile time of your app, not of the library
15:44:05 <ksf> I don't think you meant that
15:46:08 <Philonous> copumpkin: Does vector-space even have basic operations like matrix-vector multiplication?
15:46:23 <copumpkin> Philonous: it doesn't know about matrices
15:46:31 <copumpkin> it knows about linear transformations
15:46:55 <Philonous> Oh, well, I actually need to at least invert a matrix.
15:47:10 <copumpkin> how about hmatrix?
15:47:18 <copumpkin> without the hmatrix-static wrapper
15:48:08 <Philonous> hmatrix needs LAPACK, which wouldn't really be a problem if it compiled without me having to to fix the installer
15:50:43 <Philonous> ksf: Vec has the dimensions encoded in the type system. I couldn't figure out how to invert a matrix (given as [[Double]]) without telling the compiler the dimensions it should assume
15:51:00 <copumpkin> what's wrong with that?
15:51:40 <Philonous> I don't know the dimensions because they are determined at runtime
15:51:50 <copumpkin> then wrap it in an existential
15:57:49 <HugoDaniel1> ok, ive just found out where my problem was
15:57:55 <Berengal> Man, thinking in arrows is hard
15:58:00 <HugoDaniel1> it was not on the code that i pasted, sorry for that :/
16:01:01 <Philonous> copumpkin:I'm not sure that helps. The compiler doesn't know what dimension the matrix should be that he pulls out of the lists.
16:01:22 <chrisdone> haha, when did you become ``copumpkin''. that's ace
16:01:28 <copumpkin> :)
16:01:31 <copumpkin> quite a while ago
16:01:42 <copumpkin> Philonous: there should be a function that produces one!
16:02:28 <copumpkin> Philonous: readSizedMatrix :: FilePath -> (forall m n. Matrix m n a -> r) -> IO r
16:03:07 <HugoDaniel1> does this makes any sense http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10874#a10874 ?
16:03:18 <HugoDaniel1> it works though
16:03:44 <HugoDaniel1> its the main type class for a message passing core im working on
16:06:54 <HugoDaniel1> i would really like to write my comments in haskell like
16:06:55 <HugoDaniel1> -->
16:07:01 <HugoDaniel1> but it complains about error :P
16:07:25 <Cale> You need a space or a non-symbol character after the --
16:07:46 <Cale> --> is a valid name for an infix operator
16:08:27 <Cale> For a while, istr that the lexer in GHC was messed up and you could write a program which did one thing on GHC and another on hugs using that ;)
16:08:50 <Cale> But I'm pretty sure it's fine now :)
16:08:54 <HugoDaniel1> :)
16:09:27 <Cale> > let x --> y = y `mod` x == 0 in 3 --> 6
16:09:28 <lambdabot>   True
16:10:14 <HugoDaniel1> oh
16:10:32 <HugoDaniel1> i thought that the -- worked much like the // in c++
16:10:59 <Zao> It kind of is, except if it's directly followed by a non-letter.
16:11:01 <Zao> Or somesuch.
16:11:17 <Raevel> oh joy, i was trying to parse this config file. I had accidentally put quotes around the values and the error message given was along the lines of "foo" does not exist, which i ofcourse thought was ridiculous
16:11:30 <HugoDaniel1> anyway, its not necessary, as i think lhs files are way better than commenting around source code for my purposes
16:11:43 <Cale> A sequence of two or more dashes starts a comment only if not followed by a symbol character.
16:12:49 <Cale> Another nice thing is that comments enclosed with {- and -} can be nested.
16:13:12 <Cale> Unlike the stupid /* and */ comments in C and various other languages
16:13:18 <Philonous> copumpkin: I have class VecList a v | ... where fromLists :: [a] -> v and toList (Fold v a) => v -> [a], so toList . fromList :: [a] -> [a], but how could the compiler know which v to put in between?
16:16:12 <sjanssen> Philonous: the "..." part you left out is important
16:16:37 <Philonous> class VecList a v | v -> a
16:16:51 <Philonous> Doesn't help much
16:32:07 <jimi_hendrix> if a program has io, then is it not purely functional?
16:32:13 * jimi_hendrix just read something that suggests this
16:33:14 <Gracenotes> hmm... the IO actions can still be modeled in a purely functional way, I'd say. Haskell does this.
16:33:38 <SamB_XP_> Gracenotes: I wouldn't say it models them :-(
16:34:19 <ygd-coder> i need help implementing strings in my scheme compiler
16:34:41 <Gracenotes> do you already have them parsed?
16:34:47 <ygd-coder> no
16:34:51 <ygd-coder> i'm writing the parser
16:35:03 <ygd-coder> the problem is that they don't yet support escaped quotes
16:35:08 <ygd-coder> so "\"hi\""
16:35:11 <ygd-coder> wouldn't be legal
16:35:24 <Botje> ygd-coder: if you're using parsec, you should be using the token parser
16:35:38 <Botje> it does quoted strings for you!
16:35:50 <ygd-coder> i don't know how to though
16:35:56 <ygd-coder> any references?
16:36:20 <ygd-coder> this is what i'm using now: http://pastebin.com/d6db21dc1
16:39:16 <ygd-coder> so how exactly do I use the parsec token parser?
16:39:23 <roconnor> ``
16:39:25 <roconnor> Known bugs: Occasionally HTZAAR throws a Prelude.head: empty list.
16:39:26 <roconnor> I'm still trying to track this down.
16:39:28 <roconnor> *LOL*
16:39:49 <roconnor> for some reason I find that really funny
16:40:23 <roconnor> I guess it is such a common error and so hard to track down
16:42:33 <Peaker> roconnor, ideally you could compile with stack traces or use-traces or such and catch it in a sec
16:49:06 <HugoDaniel1> today i started haskell evangelization on a portuguese programmers forum
16:49:40 <roconnor> how did that go?
16:49:50 <HugoDaniel1> im also preparing a small presentation about haskell to do in a programmers conference
16:49:57 <roconnor> :)
16:50:08 <HugoDaniel1> well, right now im just solving some problems they have in haskell, and talking about how great the language is :)
16:50:32 <HugoDaniel1> most of them seem first year students of computer courses
16:51:15 <Botje> don't make people jealous ;)
16:51:17 <HugoDaniel1> in my university they had a strange tendency towards lisp
16:51:35 <HugoDaniel1> i guess they are privileged to learn haskell in the first years
16:51:43 <Peaker> I made http://www.ee.bgu.ac.il/~noamle/_downloads/Haskell-Lotem.pdf  for evangelizing Haskell, maybe it could be of use
16:52:04 <HugoDaniel1> but... most of them seem to talk like Haskell is for beginners, and Java and C++ is for pro's
16:52:16 <HugoDaniel1> great :D
16:52:22 <Botje> heh
16:52:24 <Botje> it's true.
16:52:24 <SamB_XP_> HugoDaniel1: hehehe
16:52:35 <SamB_XP_> only Pros can handle Java and C++, you mean?
16:52:44 <Botje> only "pro's" can wrestle with threads and mutable shared state and come out not wanting to kill themselves
16:53:13 <SamB_XP_> Botje: or at the very least switch majors ;-P
16:53:47 <HugoDaniel1> eheh
16:54:27 <Cale> Pros with enough bottles of headache medicine.
16:54:52 <Botje> :)
16:55:06 <SamB_XP_> ah, yes, we need that acetaphenomin ;-P
16:55:30 <HugoDaniel1> Peaker: ”functions” map, ”actions” do  :D
16:56:02 <Peaker> HugoDaniel1, ya :)
16:56:48 <SamB_XP_> HugoDaniel1: tell them that if they stay with Haskell long enough, they could end up designing the next version of VB ;-P
16:57:17 <SamB_XP_> no, wait, they might take that the wrong way ...
16:59:29 <Baughn> VB's gotten pretty nice lately..
16:59:33 <Baughn> ..VB programmers haven't
16:59:38 <Peaker> Baughn, VB = C#
16:59:46 <Baughn> Peaker: With a different syntax, I'm aware.
17:00:12 <SamB_XP_> but it's more fun to talk about it as VB, since VB had to change more to get there ;-P
17:00:13 <Baughn> Think I'd prefer F#, all things considered. :P
17:04:44 <HugoDaniel1> :)
17:05:03 <HugoDaniel1> im planing that in the future there might be a ghc.net for all my concerns about that platform
17:05:08 <HugoDaniel1> or an H# :P
17:06:45 <SamB_XP_> that really doesn't seem all that likely ...
17:07:06 <SamB_XP_> ... Haskell is definitely *not* object oriented!
17:07:33 <Asztal> http://www.haskell.org/haskellwiki/GHC:FAQ#Why_isn.27t_GHC_available_for_.NET_or_on_the_JVM.3F
17:08:39 <Berengal> Anyone familiar with hxt? I'm having some trouble with the writeDocument arrow...
17:15:15 <ben_m> I need a local copy of lambdabot, @pl is so useful :D
17:15:24 <ddarius> r rtaf ydco cu eakrpajt t.fxrape nafrgy
17:17:47 <SamB_XP_> ddarius: I'm afraid you're breaking up!
17:18:00 <benmachine> ben_m: there is a pointfree package on hackage
17:18:09 <benmachine> that installs a command line tool
17:18:27 <benmachine> pointfree '\x -> x x'
17:18:27 <benmachine> join id
17:18:45 <benmachine> err that first line was supposed to have $ on the beginning so that you could see it was shelly
17:18:54 <Elly> :t join
17:18:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:19:03 <benmachine> :t join id
17:19:04 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
17:19:05 <lambdabot>     Probable cause: `id' is applied to too few arguments
17:19:05 <lambdabot>     In the first argument of `join', namely `id'
17:19:13 <benmachine> heh
17:19:23 <benmachine> interesting that that works even though it doesn't
17:19:37 <benmachine> @pl \x -> x x
17:19:37 <lambdabot> join id
17:19:47 * benmachine wonders if this can be abused in some way to cause non-termination
17:20:02 <Elly> :t \x -> x x
17:20:03 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:20:03 <lambdabot>     Probable cause: `x' is applied to too many arguments
17:20:03 <lambdabot>     In the expression: x x
17:20:07 <ygd-coder> .leave
17:20:07 <Elly> same error :P
17:20:08 <copumpkin> benit can be
17:20:12 <benmachine> I expect not since it doesn't actually evaluate the expression
17:20:15 <copumpkin> benmachine: it can be
17:20:17 <copumpkin> but don't try it
17:20:23 <benmachine> aw okay
17:20:33 <SubStack> that directory-1.0.0.3 bug should've never been closed
17:20:34 <copumpkin> it's the one surefire way of taking lambdabot offline until someone restarts it
17:20:39 <SubStack> stupid base == 4 constraints
17:20:53 <copumpkin> unless Saizan_ or Cale fixed it
17:20:58 * SubStack grumbles
17:21:47 <Cale> what?
17:21:59 <copumpkin> Cale: the @pl DOS bug
17:22:08 <Cale> @pl (\x -> x x) (\x -> x x)
17:22:11 <lambdabot> ap id id (ap id id)
17:22:11 <lambdabot> optimization suspended, use @pl-resume to continue.
17:22:28 <copumpkin> well at least you're here to restart it :P
17:22:37 <Cale> Is there a problem with that response?
17:22:41 <copumpkin> not with the response
17:22:44 <copumpkin> with lambdabot's behavior
17:22:48 <Cale> ?
17:22:53 <copumpkin> run top on lambdabot's machine
17:22:57 <copumpkin> @botsnack
17:22:58 <lunabot>  :o
17:22:58 <lambdabot> :)
17:23:04 <copumpkin> lambdabot stays alive
17:23:11 <Baughn> @pl-resume
17:23:15 <copumpkin> but it slowly eats up all your memory and is probably using 100% cpu
17:23:17 <lambdabot> ap id id (ap id id)
17:23:17 <lambdabot> optimization suspended, use @pl-resume to continue.
17:23:31 <Baughn> Shouldn't it recognize when it's accomplishing nothing?
17:23:39 <ben_m> So, apparently I haven't understood function composition
17:23:46 <Baughn> @type ap id id (ap id id)
17:23:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
17:23:47 <lambdabot>     Probable cause: `id' is applied to too few arguments
17:23:47 <lambdabot>     In the second argument of `ap', namely `id'
17:23:55 <copumpkin> Cale: or is it not doing that this time?
17:23:57 <ben_m> I can't figure out why (:) . (+1) works
17:24:00 <ben_m> :/
17:24:03 <ygd-coder> what's up with lambdabot?
17:24:13 <copumpkin> ben_m: rewrite it until it does make sense
17:24:40 <copumpkin> (:) . (+1) = (\x y -> x : y) . (\z -> z + 1)
17:24:41 <Vanadium> :t (:) . (+1)
17:24:43 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
17:24:47 <benmachine> :t \f -> f . (+1)
17:24:49 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
17:25:36 <benmachine> in the (:) . (+1) case, b is ([a] -> [a])
17:25:45 <ben_m> oh
17:25:52 <ben_m> That helps understanding it a bit.
17:26:03 <copumpkin> now just substitute in the definition of (.)
17:27:25 <nerdshark> hi, i've got a problem with the main function in my xmonad config, and i don't know haskell well enough to fix it. if someone could give me some advice, that'd be awesome
17:27:28 <nerdshark> http://pastebin.com/m404bae70 -- error
17:27:35 <nerdshark> http://pastebin.com/m3f50efeb -- config
17:28:14 <ygd-coder> how do i create a parser action that "accepts either a non-quote character or a backslash followed by a quote mark"
17:28:38 <Beelsebob> ygd-coder: what’s a parser action?
17:28:47 <Baughn> nerdshark: Try #xmonad?
17:28:47 <ygd-coder> i'm using parsec
17:29:08 <Beelsebob> ygd-coder: okay then, how do you create a parser that accepts a backslash followed by a quote mark?
17:29:20 <ygd-coder> Beelsebob: that's my question
17:29:21 <copumpkin> @botsnack
17:29:21 <lunabot>  :o
17:29:21 <lambdabot> :)
17:29:28 <SamB_XP_> @hoogle CharParser a -> CharParser a -> CharParser a
17:29:28 <lambdabot> No results found
17:29:32 <Beelsebob> ygd-coder: well no, it’s part of your question
17:29:47 <ygd-coder> Beelsebob: so do you know the answer?
17:29:53 <Beelsebob> ygd-coder: how do you create a parser that accepts a backslash?
17:30:07 <ygd-coder> Beeslebob: i don' tnow
17:30:20 <SamB_XP_> ygd-coder: you could start by reading the tutorial on the web page!
17:30:29 <Beelsebob> what type might such a function have ygd-coder?
17:30:50 <ygd-coder> parseString :: Parser LispVal
17:31:12 <Beelsebob> ygd-coder: why would it have that type?
17:31:22 <ygd-coder> i'm just following http://jonathan.tang.name/files/scheme_in_48/tutorial/parser.html
17:31:34 * Beelsebob would expect it to have something along the lines of parseBackslashChar :: Parser ()
17:31:50 <ygd-coder> okay
17:32:02 <SamB_XP_> Beelsebob: yeah, or maybe Parser Char ;-)
17:32:06 <Beelsebob> indeed
17:32:25 <ygd-coder> right now i'm only using many (none of ""\"")
17:32:33 <ygd-coder> but that chokes when fed \\\"
17:32:36 <Beelsebob> ygd-coder: okay, so, given that, let’s assume that the parsec guys didn’t write a function for *every* single character on the keyboard
17:32:50 <Beelsebob> we might be looking for a function with type Char -> Parser Char, right?
17:33:49 <ygd-coder> any more hints?
17:34:18 <Beelsebob> try hoogling for a function of that type
17:34:28 <Beelsebob> see what you get ;)
17:34:49 <ygd-coder> @hoogle Char -> Parser Char
17:34:50 <lambdabot> No results found
17:35:02 <Beelsebob> oh bugger, you may need to hayoo instead
17:35:08 <ygd-coder> @hayoo Char -> Parser Char
17:35:09 <lambdabot> Unknown command, try @list
17:35:20 <Beelsebob> hackage.haskell.org
17:35:24 <Beelsebob> click the hayoo link
17:35:44 <SamB_XP_> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html maybe ?
17:35:58 <Beelsebob> or perhaps what SamB_XP_ suggests, yeh
17:36:10 <ygd-coder> i tried that
17:36:12 <SamB_XP_> that actually has a tutorial section
17:36:17 <Beelsebob> if you’re struggling with a parser that accepts a single character, read a Parsec tutorial
17:36:29 <SamB_XP_> unlike, unfortunately, most Haskell library documentations these days :-(
17:36:32 <ygd-coder> the problem is that I'm using parsec to learn haskell
17:36:46 <Beelsebob> ygd-coder: that’s perhaps not the right way round to do it
17:36:47 <sproingie> yay 30+ hours to compile a haskell project and still going
17:36:55 <ygd-coder> oh
17:36:59 <ygd-coder> any other good tutorials then?
17:37:08 <Beelsebob> ygd-coder: I’d recommend reading learn you a haskell
17:37:10 <copumpkin> sproingie: what is it?
17:37:14 <sproingie> copumpkin: gitit
17:37:16 <ygd-coder> okay
17:37:20 <copumpkin> sproingie: o.O
17:37:22 <ygd-coder> thanks
17:37:45 <SamB_XP_> Beelsebob: but what if he ends up learning Haskell 0.9 instead of Haskell 2020 ?
17:37:47 <sjanssen> sproingie: yikes, what are you building?
17:37:55 <sproingie> copumpkin: i have 256M of ram, and it's a VPS so swap is a virtual disk.  this appears to be lethal when it comes to the point where i run the linker
17:37:57 <copumpkin> gitit
17:38:05 <copumpkin> sproingie: oh yeah, that's a known problem
17:38:11 <Beelsebob> SamB_XP_: o.O
17:38:14 <copumpkin> sproingie: if you get a GHC with no split objs it'll be nicer
17:38:25 <sproingie> copumpkin: hmm?  elaborate?
17:38:55 <SamB_XP_> sproingie: if GHC compiled it's base with -split-objs or whatever the flag is called, it makes it a lot slower to link with that base
17:38:56 <SamB_XP_> etc.
17:39:10 <copumpkin> it's just a gnu ld problem apparently
17:39:10 <sproingie> SamB_XP_: is there a way to find out what flags ghc was compiled with?
17:39:22 <SamB_XP_> sproingie: this is, of course, the default -- just to annoy us, AIUI
17:39:23 <Baughn> sproingie: split-objs is the default
17:39:25 <sproingie> copumpkin: sadly i have no alternatives
17:39:36 <sproingie> no freebsd guests on my vps provider :(
17:39:47 <sjanssen> sproingie: you can't build locally and copy the executables to your VPS?
17:40:07 <Baughn> sproingie: You can also use 'ar p' on the base-libs .a; if it's using split-objs, there will be millions of entries named something like foo_001291232.o
17:40:26 <sproingie> sjanssen: yeah i probably will do that.  bit cumbersome since i can't always get at a 64 bit linux host
17:40:46 <copumpkin> sproingie: is it slicehost?
17:40:49 <sproingie> copumpkin: i take it there's a configure option for building ghc without split-objs then?
17:40:53 <copumpkin> yeah
17:40:57 <copumpkin> or in build.mk maybe
17:40:57 <sproingie> copumpkin: rackspace cloud, so basically yeah
17:41:11 <copumpkin> sproingie: you could temporarily upgrade to a 1024, build, then downgrade again :P
17:41:14 <ben_m> Is this idiomatic Haskell to read a number from stdin? do { num <- return . read =<<  getLine; -- stuff }
17:41:17 <sproingie> rackspace cloud nee mosso appears to be the same infrastructure as slicehost
17:41:23 <copumpkin> ben_m: readLn
17:41:35 <ben_m> Damn :(
17:41:38 <ben_m> Thanks :)
17:41:40 <benmachine> which is the same as read <$> getLine
17:41:45 <Beelsebob> ben_m: I’d write it as readLn, but without that function existing, I’d write read <$> getLine
17:41:54 <sproingie> copumpkin: heh i never thought of that!
17:41:57 <ben_m> <$> is applicative functor stuff, right? Haven't tackled those yet.
17:42:05 <Beelsebob> no, it’s functor stuff
17:42:05 <copumpkin> it's just functor
17:42:07 <Baughn> ben_m: <$> is fmap, or liftM
17:42:08 <Beelsebob> it’s just fmap
17:42:08 <benmachine> <$> is from Control.Applicative
17:42:09 <copumpkin> but it's in the applicative module
17:42:16 <ben_m> Neither have I read about those ;)
17:42:23 <Baughn> @type liftM
17:42:24 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:42:26 <Beelsebob> ben_m: fix it
17:42:33 <ben_m> I shall, once this tutorial gets to them.
17:42:35 <Beelsebob> ben_m: you shouldn’t know about monads yet, if you don’t know about functors ;)
17:42:37 <Beelsebob> :P
17:42:38 <Baughn> ben_m: You'll want to read the typeclassopedia too. :)
17:42:39 <ben_m> I just skip a head a lot when doing exercises.
17:42:40 <benmachine> it's worth mentioning too that most serious programs won't use read because it doesn't error-handle well
17:42:44 * benmachine gets highlighted by everyone
17:43:00 <Beelsebob> benmachine: you have ben as a highlight?
17:43:02 <benmachine> yes
17:43:07 <Beelsebob> hehe
17:43:08 <benmachine> that is what most people call me
17:43:08 <sproingie> think i'll go with a custom ghc for now tho.  disable split-objs, good to know
17:43:09 <ben_m> Mind bending.
17:43:18 * ben_m ducks.
17:43:19 <sproingie> copumpkin: is there any serious downside to having split-objs off?
17:43:26 <copumpkin> larger executables
17:43:29 <benmachine> that didn't work; I think it's only because you have the underscore in the middle
17:43:33 <benmachine> although
17:43:42 <benmachine> irssi decided to highlight your action
17:43:45 <benmachine> which is a bit wtf
17:43:56 <Baughn> sproingie: 6.12 uses shared libraries, which basically makes split-objs worthless, so it's a temporary issue
17:44:09 <Baughn> sproingie: Although GHC also compiles static libraries with split-objs even on 6.12...
17:44:10 <Beelsebob> ben_m: basically, a functor is something that you can map functions over – a list is a functor, because you can use map on it… Maybes are functors, because you can apply a function to the value inside the Just… IO is a functor, because you can apply a function to the value hiding inside the IO magic
17:44:27 * SamB_XP_ tries to imagine how much RAM split-objs would waste if it was tried for shared libs ;-P
17:44:28 <benmachine> any monad should also be a functor
17:44:33 <Beelsebob> indeed
17:44:40 <benmachine> because fmap can be implemented in terms of >>= and return
17:44:42 <Baughn> ben_m: functions are functors, because you can apply a function to its return value...
17:45:13 <benmachine> functor laws are fmap id == id and fmap (f . g) == fmap f . fmap g
17:45:29 <benmachine> the idea of fmap being that it modifies wrapped values without touching the wrapping-paper
17:46:11 <Baughn> ben_m: Those two rules mean, basically, "fmap doesn't alter the structure except for what its applied function does"
17:46:21 <SamB_XP_> benmachine: don't you mean
17:46:21 <Baughn> And its applied function has no notion of any structure, as such; it's a map
17:47:17 <copumpkin> @botsnack
17:47:18 <lunabot>  :o
17:47:18 <lambdabot> :)
17:47:20 <SamB_XP_> (id .) == id and (.) (f . g) == (f .) . (g .) ?
17:47:36 <benmachine> SamB_XP_: :P
17:47:47 <benmachine> I'm sure there was a prettier way of doing it though
17:48:08 <benmachine> I think it was id . x == id x and (f . g) . x == f . (g . x)
17:48:10 <benmachine> or something
17:48:40 <benmachine> maybe the first one was id . x == x
17:50:16 <Baughn> Only if you set . = fmap
17:50:22 * Baughn pokes Cale 
17:50:47 <Baughn> (I think that was part of his justification)
17:50:49 <FunctorSalad> functor axioms?
17:50:54 <copumpkin> faxioms
17:51:01 <Baughn> Fauxions?
17:51:09 <FunctorSalad> fmap id = id, fmap (g.f) = fmap g . fmap f
17:51:39 <ben_m> Beelsebob, Baughn: Thanks for the explanation, appreciate it :)
17:53:20 <SamB_XP_> ben_m: are you a clone of benmachine ?
17:53:22 <Cale> Well, composition satisfies those
17:53:29 <Cale> But they are also the functor axioms
17:53:30 <benmachine> I deny everything
17:53:43 <shambler> :X
17:54:02 <Cale> fmap id x = x  <--->  id . x = x
17:54:03 <ben_m> SamB_XP_: Yes, but they could only clone a quarter of our cognitive abilities :(
17:54:26 <Cale> fmap (g . f) x = fmap g (fmap f x)  <--->  (g . f) . x = g . (f . x)
17:56:41 <Cale> In more mathematical settings the (->) e functor is called Hom(E,-) and is also known as the covariant hom functor.
17:57:21 <SamB_XP_> Cale: hmm, does that taste better or worse than the coffee comonad ?
17:57:28 <Jagwire> Is there a function in prelude that takes a list and checks to see if any of the elements in that list can be found in another list?
17:57:42 <Cale> not . null . intersect
17:57:48 <Cale> er
17:58:03 <Jagwire> intersect hmmm...
17:58:06 <Cale> (\x y -> not . null $ intersect x y)
17:58:28 <lispy> ?pl (\x y -> not . null $ intersect x y)
17:58:29 <lambdabot> ((not . null) .) . intersect
17:58:29 <Cale> If the lists are ordered, or can be sorted, that's inefficient though
17:58:58 <Cale> Hehe,  fmap (not . null) . intersect  ;)
17:59:38 <FunctorSalad> @type fmap (fmap (fmap not null)) intersect
17:59:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:00:25 <benmachine> :t fmap . fmap . fmap not null $ intersect
18:00:26 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
18:00:27 <lambdabot>     In the first argument of `fmap', namely `not'
18:00:27 <lambdabot>     In the second argument of `(.)', namely `fmap not null'
18:00:46 <FunctorSalad> @type (fmap . fmap) (fmap not null) intersect
18:00:46 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:01:21 <FunctorSalad> @type (fmap fmap fmap) (fmap not null) intersect
18:01:21 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:05:22 <FunctorSalad> @type (fmap fmap fmap) (fmap not ?null) ?intersect
18:05:23 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, ?null::a -> Bool, ?intersect::f (f1 a)) => f (f1 Bool)
18:07:48 <sproingie> bleah.  snapshot builds depend on libtinfo
18:08:02 <sproingie> i havent seen libtinfo built separately in ages
18:08:03 <ben_m> Emacs doesn't like to indent if/else, apparently
18:08:38 <FunctorSalad> do syntax strikes again?
18:08:50 <ben_m> apparently?
18:09:02 <ben_m> It is in a do, if that's what you mean
18:09:13 <FunctorSalad> (you must indent the then and the else in a do statement)
18:09:26 <sohum> @pl \x -> f $ g $ h $ i x
18:09:27 <lambdabot> f . g . h . i
18:09:40 <ben_m> I wanted to do that anyways, but Emacs doesn't do it automatically.
18:09:53 <ben_m> That's what I meant with Emacs not liking if/else.
18:09:57 <sohum> ...duh
18:10:41 * benmachine doesn't trust autoindentation tools
18:11:04 <ben_m> Emacs' autoindentation is pretty good ... far better than what Vim does, unfortunately.
18:12:40 * benmachine uses vim and just presses space when he wants a space
18:13:06 <FunctorSalad> press a lot of space if you want a lot of spaces? ;)
18:13:25 <FunctorSalad> or numeric prefix I guess
18:15:35 <SamB_XP_> hmm ... I think I prefer what VS does ...
18:15:59 <SamB_XP_> (namely, inserting a few spaces when you hit tab)
18:16:55 <dmead> hey guys
18:17:03 <dmead> is there a decent way to catch pattern matching exceptions?
18:18:03 <defun> How would one make a function that takes two lists and returns two lists? Is this only possible via zip?
18:18:08 <FunctorSalad> if you can't change the offending code, (catch) is the only way
18:18:26 <FunctorSalad> if it's your code just add a default branch :)
18:18:27 <Baughn> defun: What, like "foo x y = (y,x)"?
18:18:28 <ben_m> http://sprunge.us/dLPA?haskell -- I get "Parse error in pattern on line 6."
18:18:36 <dmead> FunctorSalad, i want to use pattern match failure as flow control
18:18:51 <dmead> i'm defining a ruleset in a list
18:19:15 <FunctorSalad> dmead: in a "do" block pattern match failure will cause (fail)
18:19:22 <Baughn> defun: Or were you going to do something with the lists? zip(With) is certainly one common way, but it really depends on your goal.
18:19:46 <defun> Baughn: yeah. I was thinking maybe I could do "foo x y = x y", but that seemed wrong, and I'm not near a compiler to test it.
18:20:01 <FunctorSalad> > do { Just x <- Nothing; return "cat" }
18:20:01 <defun> Now I know why zip_ exists.
18:20:02 <lambdabot>   Nothing
18:20:08 <Baughn> defun: A function can only return a single value.
18:20:12 <dmead> FunctorSalad, how do you catch it though
18:20:20 <Baughn> defun: ..that value can be a tuple, though
18:20:44 <Baughn> defun: Also note the curry/uncurry functions
18:21:21 <FunctorSalad> dmead: depends on what "fail" does
18:21:28 <defun> thanks. That was my first thought when I thought about my function's typesignature. And I wasn't sure if I missing some subtlety of the type system. But now I get it.
18:21:29 <FunctorSalad> in the maybe monad you'd check for Nothing
18:21:33 <dmead> hmm
18:25:48 <sohum> > shiftL 1 1
18:25:50 <lambdabot>   Ambiguous type variable `t' in the constraint:
18:25:50 <lambdabot>    `Data.Bits.Bits t'
18:25:50 <lambdabot>      a...
18:25:55 <sohum> > shiftL 1 1 :: Int
18:25:57 <lambdabot>   2
18:26:14 <sohum> > shiftL 8 6 :: Int
18:26:15 <lambdabot>   512
18:26:31 <sohum> ...oh, duh
18:26:40 <sohum> I've got it the wrong way around
18:30:26 <Jeb> suppose I had a constructor, what would be the appropriate action to take if invalid input was entered into it?
18:31:09 <SamB_XP_> the best thing is to make that impossible ;-P
18:31:29 <SamB_XP_> by requiring proof of validity as one of the arguments to the constructor
18:31:55 <pumpkin> yay
18:33:18 <Jeb> hmmm, is there any way to throw an error in haskell?
18:33:31 <roconnor> @type error
18:33:32 <lambdabot> forall a. [Char] -> a
18:33:34 <Gracenotes> @type scanl1
18:33:35 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
18:33:50 <lispy> :t const undefined
18:33:51 <Gracenotes> grr.. accumulator is to the left, right
18:33:51 <lambdabot> forall a b. b -> a
18:33:58 <roconnor> lambdabot: [Char] ?
18:34:09 <Jeb> thanks...probally should have googled that one before asking, lol
18:34:12 <Gracenotes> Jeb: exceptions are possible, but there are often clearer ways of indicating a mistake
18:34:18 <lispy> ?check const undefined == unsafeCoerce
18:34:18 <lambdabot>   Not in scope: `unsafeCoerce'
18:34:32 <Jeb> alright, well the constructor takes a list, and the second param must be an element in that list
18:35:00 <Rotaerk> it's preferable to cover as much of your dependencies as possible using the type system rather than runtime errors
18:35:16 <Gracenotes> e.g., using Maybe or Either. the disadvantage to the error function is that you must be in IO to catch it.. but if you expect the user to make sure the error won't happen /before/ calling the function, and the condition is simple, it should be okay.
18:35:32 <Rotaerk> "dependencies" in this case include the condition that your input meet certain criteria
18:35:46 <Gracenotes> not ideal perhaps
18:36:55 <Gracenotes> depends :x
18:36:55 <Jeb> thanks
18:37:35 <Rotaerk> Jeb, what does your constructor look like, and what are the restrictions on its input?
18:38:06 <Jeb> takes a list, and an item that must be in that list
18:39:25 <Rotaerk> Jeb, so:  a -> [a] -> b, with the condition that a must be in [a]
18:39:58 <jimi_hendrix> is there an easy way to take the slice of an array from elements 3 to 6
18:40:20 <Rotaerk> Jeb, why have that constraint at all, why not just use the first parameter, and then expect the list to contain everything else
18:41:00 <Jeb> I'm a student, and that's the definition given to us
18:41:11 <Jeb> I think I'm just going to go with    error
18:41:11 <Rotaerk> ah
18:41:13 <sjanssen> jimi_hendrix: do you really mean array, or do you mean list?
18:41:15 <Gracenotes> it is an occasionally used technique to hide the constructor from module export, but make a function in the module that uses the constructor
18:41:37 <jimi_hendrix> one of the things with square braces
18:41:38 <Jeb> rotaerk, thanks for your help though
18:41:39 <Gracenotes> e.g., for '%' in Data.Ratio. It does some basic error checking first
18:41:44 <jimi_hendrix> sjanssen, ^^
18:41:46 <Gracenotes> > 10 % 0
18:41:47 <lambdabot>   * Exception: Ratio.%: zero denominator
18:42:05 <sjanssen> jimi_hendrix: that's called a list
18:42:13 <jimi_hendrix> well moving on
18:42:17 <sjanssen> > take 3 . drop 3 $ [1 ..[
18:42:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:42:21 <sjanssen> > take 3 . drop 3 $ [1 ..]
18:42:23 <lambdabot>   [4,5,6]
18:42:42 <Gracenotes> % used 'error'... although if the object is mostly one-time-construction, maybe Just/Nothing would make sense. eh.
18:43:22 <Gracenotes> > let slice36 = take 3 . drop 3 in (slice36 [1..5], slice36 [1..2])
18:43:24 <lambdabot>   ([4,5],[])
18:51:09 <jimi_hendrix> if i have a function that returns 3 things in a tuple or list, and i want to assign these individual things to variables, is there some quick oneliner for this or no
18:51:28 <lispy> jimi_hendrix: pattern matching
18:51:49 <lispy> where (a, b, c) = foo
18:51:57 <jimi_hendrix> perfect
18:52:54 <jimi_hendrix> lispy, can i do that with a let or must it be a where
18:53:07 <lispy> jimi_hendrix: let works also
18:53:11 <lispy> jimi_hendrix: but I greatly prefer where
18:53:19 <jimi_hendrix> for what reason
18:53:37 <lispy> jimi_hendrix: I think it reads better, so stylistic reasons.  I have no technical reasons :)
18:54:43 <jimi_hendrix> lispy, is the where evaluated first in a function, then the body?
18:54:56 <lispy> jimi_hendrix: haskell is lazy
18:55:16 <jimi_hendrix> i know?
18:55:20 <Gracenotes> 'where' is nice for functions that aren't so simple
18:55:37 <lispy> jimi_hendrix: things are evaluated as they are needed.
18:55:48 <jimi_hendrix> ok
18:55:51 <lispy> > let foo = 1 where a = undefined in foo
18:55:52 <lambdabot>   1
18:55:55 <Cale> (and only if they are needed)
18:56:07 <lispy> jimi_hendrix: notice that the undefined didn't cause a problem
18:56:19 <Gracenotes> let is nice for monads, as they are built-in syntax
18:56:25 <Gracenotes> in that context
18:56:33 <sjanssen> jimi_hendrix: other than syntax, the difference between where and let is that where is part of the equation syntax, and scopes across guards
18:57:05 <jimi_hendrix> ok
18:57:10 <sjanssen> s/other than syntax, // makes that statement less strange
18:57:57 <Gracenotes> > let (Left x, Left y) = (Right 3, Left 4) in y
18:57:59 <lambdabot>   * Exception: <interactive>:1:145-180: Irrefutable pattern failed for patter...
18:58:05 <jimi_hendrix> and can i convert an int to a string?
18:58:15 <sjanssen> > show 1
18:58:16 <lambdabot>   "1"
18:58:27 <jimi_hendrix> oooh ok
18:58:31 <Gracenotes> @instances Show
18:58:32 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
18:59:53 <Gracenotes> uh. that's interesting.
19:01:46 <Gracenotes> > newSTRef 4
19:01:48 <lambdabot>   <<ST action>>
19:01:57 <Gracenotes> :o
19:02:23 <Gracenotes> an exciting Show instance
19:02:30 <sjanssen> Gracenotes: lambdabot has a bunch of extra Show instances
19:02:34 <sjanssen> > putStr "asdf"
19:02:35 <lambdabot>   <IO ()>
19:02:42 <sjanssen> > getChar
19:02:43 <lambdabot>   <IO Char>
19:02:51 <Gracenotes> ah, that's what that is
19:04:01 <Gracenotes> I thought it was merely its way of saying "No IO allowed". But.. of course why couldn't it be done on a type level..
19:04:20 <Gracenotes> (basic type level)
19:05:10 <Gracenotes> but even I have the ST Show instance.. it's built-in :)
19:07:48 <sohum> @pl (\(x,y,z) -> x ++ y ++ z)
19:07:49 <lambdabot> (line 1, column 7):
19:07:49 <lambdabot> unexpected ","
19:07:49 <lambdabot> expecting letter or digit, operator or ")"
19:07:49 <lambdabot> ambiguous use of a non associative operator
19:08:18 <Berengal> Arrows are damn fun!
19:08:24 <Rotaerk_> hmm, weird that hoogling "MonadState" turns up nothing
19:08:31 <Berengal> And hxt is really nifty
19:08:51 <Gracenotes> hm, try control.monad.state.class
19:09:03 <Rotaerk_> yea found it via State
19:09:04 <Gracenotes> uncurry3 (((++) .) . (++))
19:09:09 <Rotaerk_> just weird that hoogle couldn't find it
19:09:30 <Gracenotes> oh, I misread that as "googling" :) it's not part of base, though..
19:10:43 <Gracenotes> hah, Liza Minnelli is great in Arrested Development
19:18:48 <sohum> is there a way to get recursive type synonyms without going into newtype?
19:20:09 <Gracenotes> recursive? 'type' doesn't actually create any new types or constructors to recurse on, it just makes synonyms
19:20:49 <Gracenotes> with constructors, you can't make data values .. so how would that work..
19:20:59 <Gracenotes> *without
19:21:39 <SmurfOR> am i thinking correctly if when i define an instance of Read for a class there's a bit of magic going on behind the scenes? (the example from real world haskell makes me think this)
19:22:43 <SmurfOR> because you use "read" to read in but you only define a readsPrec
19:22:44 <Gracenotes> if you automatically derive it, yeah
19:24:30 <jimi_hendrix> why can i not do this:
19:24:31 <jimi_hendrix> > let (x, y, z) = take 3 [0..]
19:24:32 <lambdabot>   not an expression: `let (x, y, z) = take 3 [0..]'
19:24:41 <jimi_hendrix> hmm i get a different error
19:24:52 <jimi_hendrix> Couldn't match expected type `(t, t1, t2)'
19:24:52 <jimi_hendrix>            against inferred type `[t3]'
19:25:15 <Gracenotes> jimi_hendrix: do you know the difference between [1, 2, 3] and (1, 2, 3)? In terms of types, they are rather different
19:25:16 <Cale> jimi_hendrix: lambdabot is expecting an expression, and a 3-tuple is not the same thing as a list
19:25:32 <Cale> > let [x,y,z] = take 3 [0..] in (x,y,z)
19:25:32 <lambdabot>   (0,1,2)
19:28:48 <jimi_hendrix> ah i see
19:30:32 <Gracenotes> SmurfOR: in GHC, the Read typeclass is defined in GHC.Read. the clean-interfaced functions that use it are in Text.Read, which is imported into the Prelude
19:31:47 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
19:31:56 <jimi_hendrix> last one for the night, if i have a tuple of 3 elements, how do i get number 3
19:34:07 <Gracenotes> hm.. well, if you have a list of 3 elements, you can use 'length'. but Haskell tuples are somewhat different in that each size of tuple is a different type
19:34:49 <Gracenotes> [2], [3, 4, 2], and [] each are able to have the type [Int]. But (2), (3, 4, 2), and () would have types (Int), (Int, Int, Int), and (), respectively
19:34:51 <Cale> jimi_hendrix: f (x,y,z) = 3
19:35:10 <Cale> jimi_hendrix: The type is known statically, so you might as well just use the constant :)
19:35:43 <Gracenotes> well. all I'm saying is: if you're dealing with a tuple of 3 elements, you will definitely know it :)
19:35:45 <Cale> (Int) is the same type as Int though :)
19:35:50 <Gracenotes> like Cale said
19:35:59 <jimi_hendrix> no i mean how do i get the third element in the tuple
19:36:01 <Gracenotes> yeah
19:36:13 <Cale> oh
19:36:17 <Cale> (\(x,y,z) -> z)
19:36:31 <Gracenotes> ah. you'd need to make your own function for that :/ fst and snd exist for 2-tuples, really
19:36:47 <jimi_hendrix> thats annoying
19:36:57 <Cale> It's not so bad.
19:37:01 <c_wraith> @pl \(x,y,z) -> z
19:37:01 <lambdabot> (line 1, column 6):
19:37:01 <lambdabot> unexpected ","
19:37:01 <lambdabot> expecting letter or digit, operator or ")"
19:37:01 <lambdabot> ambiguous use of a non associative operator
19:37:11 <Cale> 3-tuples are uncommon enough that writing a lambda really isn't much of an issue
19:37:22 <Cale> Higher tuples are rarer still.
19:37:23 <c_wraith> err.  didn't that work with commas at some point?
19:37:50 <Cale> I don't think @pl ever supported pattern matching
19:37:53 <SmurfOR> Gracenotes, i suspected something like that thanks for confirming it :)
19:37:56 <Cale> Well, hmm
19:38:01 <Cale> @pl \(x,y) -> x
19:38:01 <lambdabot> fst
19:38:09 <Cale> It seems to support pairs, at least
19:38:29 <Cale> But it's an ad-hoc subset of Haskell.
19:38:33 <Gracenotes> there is no way to break apart constructors without using points /somewhere/
19:39:09 <dons> does this work for anyone, http://www.scribd.com/doc/21238110/Multicore-Haskell-Now
19:39:20 <Gracenotes> if it's built-in to the module like fst or head, well, that's even more convenient.
19:39:58 <Cale> dons: If by work, you mean a completely blank document ;)
19:40:02 <Saizan_> a good little improvement would be to use haskell-src-exts to parse the expressions and generate sensical errors in the conversion to the Pl AST
19:40:03 <dons> right. so no.
19:40:10 <Cale> Apparently there is only one character in the document
19:40:12 <dons> i think scribd fails on the conversion.
19:40:21 <dons> anyone have online slide suggestions other than scribd?
19:40:21 <Cale> I'm guessing that it is a newline or a space ;)
19:40:41 <Gracenotes> if someone wanted to give me a pdf, I would greatly prefer statically hosted *.pdf to any online viewer
19:40:43 <Cale> Just put a PDF file somewhere?
19:40:43 * dons is getting annoyed at scribd being flakey
19:41:05 <dons> yeah, pdf isn't great for introducing lots of people. you get far far more readers with embedded slides + a pdf link
19:41:06 <Gracenotes> except, I think Google Docs has a somewhat new viewer? that might be only for search results
19:41:25 <Saizan_> can you embed google docs?
19:41:31 <dons> good questoin
19:41:41 <Cale> If people can't figure out how to open a PDF, do we really want to introduce them? ;)
19:41:52 <dons> yeah i do
19:41:53 <dons> :)
19:41:54 <sereven> dons: yaxu used google docs for livecoding slides http://yaxu.org/hackpact-week-3
19:41:58 <dons> oh
19:42:16 <dons> indeed
19:42:26 * dons try-ifies
19:42:39 <Saizan_> well, sometimes when i get a pdf it goes in the "to read" stack, while a viewer would make me read it on the spot if they are slides
19:43:11 <dons> yeah. it is good for slides
19:43:19 <Gracenotes> as long as it's square, takes up very little space, slides are good
19:43:55 <Gracenotes> http://www.slideshare.net/ seems to have a great, embeddable interface... haven't uploaded anything, so I don't know if it's restrictive at all
19:44:08 <dons> mm
19:44:29 <dons> googledocs failed. files can't be over 500k
19:45:02 <Cale> dons: Are these different slides from the Multicore Haskell Now! slides which are already on scribd?
19:45:11 <pumpkin> @Botsnack
19:45:12 <lambdabot> :)
19:45:16 <dons> yeah, a different version. 1 hr + pictures
19:45:32 <dons> http://www.galois.com/~dons/talks/DEFUN-Multicore.pdf
19:45:51 <Cale> cool :)
19:46:00 <Gracenotes> well, since it's a Haskell presentation, you have to take into account the size of the Comic Sans ttf
19:46:13 <dons> just presented to 200+ at UIUC
19:46:21 <dons> yay haskell
19:46:23 <SamB_XP_> Gracenotes: why do we always use that ???
19:46:35 <Saizan_> is that true? i didn't notice
19:46:42 <c_wraith> @kind RWST
19:46:43 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:47:31 <jimi_hendrix> ok, last question...is there a way to map two lists with the same map function
19:47:41 <dons> zipWith f
19:47:51 <dons> well, depends on what you mean by " map two lists"
19:47:57 <jimi_hendrix> oo i see what you did there...
19:48:01 <jimi_hendrix> that should work i think
19:48:21 <dons> > zipWith (+) [1..10] [1..10]
19:48:22 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
19:49:02 <roconnor> dons: why Arch Linux?
19:49:39 <sproingie> arch has a lot of haskell packages
19:49:47 <dons> BSD-like linux. that's what attracted me.
19:49:55 <dons> it has a lot of haskell packages now, but it didn't originally
19:50:16 <roconnor> what does BSD like mean?
19:50:30 <c_wraith> uses portage
19:50:34 <dons> oh, simple system, BSD-style config and ports.
19:50:36 <Gracenotes> I saw Arch Linux running on a huge monitor the other day
19:51:02 <roconnor> ports?
19:51:14 <c_wraith> package management software
19:51:18 <Gracenotes> really emphasized the simplicity :P
19:51:21 <sproingie> arch is a somewhat upgraded slackware
19:51:34 <dons> oh, and i like the git-like binary sync
19:52:16 <nerdshark> arch uses pacman, not portage
19:52:19 <Saizan_> ports are the BSD name for PKGBUILDs?
19:52:24 <dons> yeah
19:52:28 <nerdshark> Saizan_: pretty much
19:52:36 <Gracenotes> I also saw someone use pacman to get, uh, firefox I think it was
19:52:38 <nerdshark> except pkgbuilds are a lot easier to write
19:52:41 <nerdshark> since they're just bash scripts
19:52:45 <idnar> what is RWST?
19:53:00 <roconnor> reader-writer-state-transformer
19:53:00 <c_wraith> Reader-Writer-State Transformer
19:53:03 <idnar> ah
19:53:08 <Gracenotes> *stater :P
19:53:13 <Saizan_> AUR is a lot like hackage in that sense :)
19:53:18 <idnar> I was trying to parse it as RW-ST
19:53:35 <Gracenotes> the basic RWS version: newtype RWS r w s a = RWS {runRWS :: r -> s -> (a, s, w)}
19:53:37 <roconnor> reader writer and state are all commutative
19:53:46 <sproingie> ports predates pkgbuilds
19:53:51 <Gracenotes> the T just makes the result monadic
19:53:53 <c_wraith> reader writer stater? :P
19:53:56 <idnar> yeah
19:54:16 <roconnor> so you can simply mash them all together into one transformer without worrying about who comes first in the stack
19:54:24 <sproingie> ports was handy, lot more reliable than gentoo's over-clever knockoff portage
19:54:29 <sproingie> these days i just use debian
19:54:48 <roconnor> I installed nixos last week
19:55:18 <Gracenotes> newtype State s a = State {runState :: s -> (a, s)} + newtype Reader r a = Reader {runReader :: r -> a} + newtype Writer w a = Writer {runWriter :: (a, w)} (generally requiring monoid)
19:55:40 <Gracenotes> and only one a...
19:55:59 <Saizan_> debian always felt like there's too much to learn about the system, though it worked well
19:57:11 <Gracenotes> when apt-get gets confused, aptitude tends to know what to do
19:57:38 <sproingie> when apt gets messed up, debian does get hairy.  thankfully that almost never happens
19:57:50 <sproingie> otherwise there's really no more policy to learn than any other distro
19:58:08 <Nafai> I really only trust Debian-based distros.  They are the only ones that have made sense to me.
19:59:14 <Gracenotes> I think I used apt-get for simple installing mainly because it's shorter
19:59:34 * Saizan_ never understood aptitude UI properly
20:00:12 <Saizan_> though i was talking about the configuration scripts and such
20:00:27 <dancor> my apt-get etc wrapper: http://github.com/dancor/dancomp/blob/master/bin/gen/ag
20:00:31 <roconnor> > exp 1
20:00:32 <lambdabot>   2.718281828459045
20:00:37 <dancor> sorry it's not hs ..
20:01:11 <roconnor> Gracenotes: use aptitude for simple installing
20:01:18 <sproingie> aptitude is the greatest
20:01:21 <Nafai> I'm starting to understand aptitude more
20:01:23 <Nafai> I used to hate it
20:01:27 <Nafai> But I really like it now
20:01:39 <roconnor> because aptitude marks which packages are installed only for dependencies of packages you want
20:01:41 <sproingie> i wish yum had a nice console gui like aptitude
20:01:54 <dancor> one reason i don't use haskell always for simple scripts is that the startup time is quite huge compared to say python
20:01:55 <c_wraith> aptitude's very functional, but the initial process of learning it was a pain.
20:02:02 <Nafai> sproingie: *shudders* yum is awful
20:02:03 <roconnor> and these packages will be removed if you remove the root packages
20:02:26 <roconnor> dancor: you mean using runhaskell?
20:02:37 <roconnor> or runghc
20:02:37 <sproingie> Nafai: it beats up2date, it's what i have to use in EL4
20:02:39 <Nafai> dancor: You should compile those scripts and it will be much better than Python
20:02:46 <Nafai> sproingie: I feel sorry for you. :(
20:02:57 <dancor> roconnor: doesn't one link to the other?  i use runghc normally
20:03:01 <Gracenotes> roconnor: hm... well, I suppose you could apt-get autoremove...
20:03:02 <sproingie> half my lab boxes are still stuck on EL3
20:03:13 <dancor> Nafai: ya
20:03:16 <roconnor> Gracenotes: does that work?
20:03:26 <roconnor> Gracenotes: I thought apt just didn't track the needed information at all
20:03:34 <dancor> maybe i'll start doing that more
20:03:49 <Gracenotes> aptitude's way does seem a bit cleaner. autoremove just removes things which were only installed as dependencies for other things, afaik
20:03:55 <Nafai> roconnor: I think it does so now
20:04:08 <Gracenotes> although.. maybe apt-get's current way is just as clean..
20:04:14 <roconnor> oh okay
20:04:21 <sproingie> aptitude uses the dist-upgrade algorithm always
20:04:25 <SamB_XP_> yeah, I think it picked up the trick from aptitude ?
20:04:31 <roconnor> perhaps this didn't exist before when I started using aptitude
20:04:32 <SamB_XP_> sproingie: does it now ?
20:04:51 <sproingie> well supposedly it's its own algorithm but it seems to mirror dist-upgrade
20:04:56 <SamB_XP_> anyway, aptitude is nice regardless
20:05:05 <Gracenotes> aptitude has a way of scoring solutions to problems. apt-get kinda gives up
20:05:17 <sproingie> it also has a nice thing when you break dependencies then you can cycle through solutions
20:05:53 <sproingie> that'd be neat to write in haskell actually
20:06:03 <SamB_XP_> sproingie: yeah, I wish you could easily get it to ask you if it's okay to do X and narrow down the solution space that way ...
20:06:53 <sproingie> you can accept a solution then modify it, and it'll start suggesting other ones
20:07:01 <Saizan_> monadiccp looks like a good base for such algorithms
20:07:04 <sproingie> but it doesn't keep a history so you can backtrack
20:07:53 <Saizan_> it'd be nice to have a smarter solver for cabal-install
20:09:54 <sproingie> does it really need one?
20:10:06 <c_wraith> from experience, yes.
20:10:48 <sproingie> didn't think it would be that complex.  just requiring a package by name and version
20:11:08 <c_wraith> but every package that depends on another package is compiled against specific versions of that package.
20:11:18 <sproingie> maybe maven's guessing algorithm would be good to use
20:11:28 <Saizan_> the current solver can fail to find a solution, even if there's one
20:11:45 <c_wraith> And when you install a different package that depends on conflicting version (indirectly), it becomes a giant mess
20:11:46 <Jeb> if I have a constructor that I want to hide (in a module) am I still able to use the constructor with pattern matching?
20:11:50 <sproingie> but then again maven errs on the side of downloading the internet
20:11:52 <Jeb> in a different module
20:12:01 <c_wraith> Negative, Jeb
20:12:22 <Jeb> thanks
20:12:39 <SamB_XP_> sproingie: not a good side to err on :-(
20:13:07 <sproingie> for java it's not so bad, jars are usually small
20:13:26 <SamB_XP_> but the entire internet's worth of jars is not so small :-(
20:13:27 <Saizan_> yeah, the idea is that you should try to stick to installed versions of packages, if it's possible
20:13:32 <sproingie> and classpaths are at single-jar granularity
20:13:41 <sproingie> haskell has neither benefit
20:14:26 <sproingie> but it's the way poms are written, no one ever depends on a version range
20:14:33 <Saizan_> i guess with maven you tend to create a distinct environment for each project you're working with?
20:14:39 <sproingie> yeah pretty much
20:15:20 <sproingie> cpan does all right, perl distributions depend on version ranges and everything usually works out
20:15:36 <sproingie> but if they do conflict, then it doesnt have any answers either
20:16:25 <Saizan_> i wonder if perl has the "diamond dependency problem"
20:17:09 <sproingie> what's that?
20:17:18 * SamB_XP_ thinks diamonds are boring :-(
20:17:45 <Saizan_> e.g. packabe B and C expose types from package A, and you have those compiled against different versions of A, when you try to use B and C together you get type errors
20:18:08 <sproingie> ah.  perl packages don't generally reexport
20:18:16 <mmorrow> Saizan_: i think dynamically-typed languages are exempt from that, because messing up won't end in a segfault
20:18:20 <sproingie> and of course don't have type errors :)
20:19:04 <Saizan_> well, this can happen an lot with e.g., A = bytestring, because ByteString is quite common
20:19:21 <Saizan_> but yeah, not having a type system helps :)
20:20:37 <sproingie> i suspect something mavenlike is the only real solution then.  private versions per-project
20:20:56 <sproingie> using both together, just not possible
20:21:47 <sproingie> guess you don't need a maven thingie, just fancier import that understands versions
20:21:58 <Saizan_> though sometimes you do need this ability
20:22:33 <Saizan_> because there are some packages that can't be recompiled/updated (like ghc) so that you've only one version of each package
20:23:18 <Saizan_> and the situation doesn't necessarily cause an error
20:23:25 <sproingie> i've noticed a distinct lack of versioning logic in the module systems of most static languages
20:23:44 <sproingie> java only gets around it through stuff like maven and osgi
20:23:47 <Gracenotes> the Java specs have an extended section on binary compatibility
20:23:50 <Saizan_> yeah, the idea is to do that at an higher level
20:24:06 <Saizan_> not sure what'd be best :)
20:24:26 <Gracenotes> which is on a technical and not organizational level, but it is well defined. or specified to be undefined/error-throwing :)
20:25:20 <sproingie> yeah java knows when something's an incompatible version.  doesn't organize by version like .NET does, but does at least stay safe
20:27:53 <mmorrow> java also does a dataflow analysis of the bytecode and verifies that at any given program point, all possible paths flowing into it have the same stack-deptch
20:28:16 <mmorrow> as its verification step
20:28:57 <mmorrow> which is why tail-recursion is problematic to add to the jvm
20:29:20 <hiredman> *shrug*
20:29:34 <hiredman> it's already been done, just not in the sun jdk
20:29:43 <mmorrow> on the jvm?
20:29:52 <hiredman> yeah
20:30:00 <mmorrow> it directly violates the security policy in the javal language def :)
20:30:32 <mmorrow> or do you mean transforming say 10 functions into a single function, then using goto
20:30:36 <sproingie> not really, it's something the JIT could do
20:30:37 <hiredman> http://wikis.sun.com/display/mlvm/TailCalls
20:30:49 <hiredman> ok, it's a "prototype"
20:31:03 <sproingie> JIT doesn't have to obey the verification constraints
20:31:17 <mmorrow> ah
20:31:23 <sproingie> once verification is done, it's forgotten about.  you can skip most of it entirely in fact
20:31:28 <mmorrow> "Note that the VM will not recognize normal calls that could be tail call optimized and perform the optimization on them."
20:31:43 <mmorrow> it probably can only handle functions calling themselves
20:31:50 <mmorrow> (by just insert a goto)
20:32:11 <sproingie> tail recursion elimination is still occasionally useful.  pretty trivial case tho.
20:32:27 <sproingie> hell i could do it and i don't know squat about optimizers
20:32:33 <mmorrow> exactly
20:32:33 <hiredman> http://www.ssw.uni-linz.ac.at/Research/Papers/Schwaighofer09Master/
20:34:21 <mmorrow> sproingie: right, you can theoretically do arbitrary things in native code, but to preserve the verification certificate, you'd have to prove an equivalent thing about your transformed program
20:34:33 <mmorrow> ...at the asm level
20:35:11 <hiredman> man, sun hasa lot of cool research vms, the flow into the jdk just seems so slow
20:35:29 <SamB_XP_> mmorrow: but it AFAIK normal JVM JITs don't use proven-safe ASM ;-P
20:35:58 <hiredman> wait, this isn't #java...
20:36:00 <mmorrow> SamB_XP_: if they don't change the semantics of the java bytecode, then the verification certificate still applies
20:36:21 <mmorrow> SamB_XP_: but if they start doing things like using an entirely different execution model...
20:36:47 <SamB_XP_> mmorrow: entirely different, or just more efficient?
20:37:14 <SamB_XP_> (how much evil do you need to get a stack trace in Java?)
20:37:35 <mmorrow> SamB_XP_: entirely different wrt the stack, and the stack depth at any given point, since the whole java verification algo is based on that
20:37:58 <SamB_XP_> afaict the JITs don't use a stack like that anyway ;-P
20:41:08 <Jeb> I know map can apply a function to a list of items, but can it also apply a list of functions to an item?
20:41:09 <mmorrow> so you'd define some (=~=), and prove (for some defined assumptions) that: jvm_verify(java_bc) =~= MyMapping(jvm_verify)(MyJIT(java_bc))
20:41:52 <mmorrow> SamB_XP_: do they use a stack at all?
20:42:10 <Gracenotes> mmorrow: just one more off-topic one-liner.. what is the important of stack depth in Java verification? :/
20:42:12 <SamB_XP_> mmorrow: for non-infiniRISC systems, one assumes so, yes ...
20:42:14 <mmorrow> SamB_XP_: if not, then they must have some way of mapping the stack depth to something
20:42:39 <mmorrow> if so, then it must have some correspondence with the stack that would exist were that native code java bytecode
20:42:40 <SamB_XP_> I mean, they need to spill intermediates *somewhere*, right?
20:44:02 <wdonnelly> > map ($ 5) [succ, pred]
20:44:03 <lambdabot>   [6,4]
20:44:12 <wdonnelly> Jeb: like that ^
20:44:14 <mmorrow> SamB_XP_: i guess this is really a question of, does  java_verify(UnJIT(JIT(java_bc))) == True
20:44:25 <Jeb> yes, thanks
20:44:39 <SamB_XP_> mmorrow: why would you even want an UnJIT ?
20:44:49 <SamB_XP_> wouldn't it be simpler to just keep the JAR around???
20:45:05 <mmorrow> and since that seems impossible to show without a formal proof that would probably be non-trivial, i'm guessing they're conservative
20:45:15 <mmorrow> SamB_XP_: as a proof device
20:45:17 <Gracenotes> mmorrow: what is the idea behind using stack depth, again
20:45:44 <SamB_XP_> I don't see why stack depth is even relevant
20:45:52 <SamB_XP_> shouldn't it be stack *type* that matters?
20:46:07 <mmorrow> Gracenotes: that just the attribute of execution they chose to base whatever security assumption on/build them around
20:46:20 <mmorrow> SamB_XP_: that too
20:46:38 <SamB_XP_> I saw a paper that used something like GADTs for this ...
20:46:41 <mmorrow> they give an explicity (1), (2), ... for the algo
20:46:54 <Gracenotes> hm. starting from where?
20:47:02 <Jeb> I think i want one of the fold functions....I need to apply a list of functions to a value, but the value has to change each time    1 [succ, succ, suc, pred] would be 3
20:47:34 <mmorrow> SamB_XP_: http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#40222
20:47:34 <SamB_XP_> and I'm not really sure what this has to do with TCO ...
20:47:43 <mmorrow> and @Gracenotes too
20:47:45 <SamB_XP_> ... in JITed code
20:47:55 <mmorrow> SamB_XP_: goto cannot branch outside of the current function
20:48:11 <mmorrow> any control transfer between two functions has to push args on the jvm stack
20:48:40 <SamB_XP_> and?
20:48:50 <SamB_XP_> can't those be pulled off before the actual transfer?
20:49:10 <mmorrow> "The target of each jump and branch instruction (jsr, jsr_w, goto, goto_w, ifeq, ifne, ifle, iflt, ifge, ifgt, ifnull, ifnonnull, if_icmpeq, if_icmpne, if_icmple, if_icmplt, if_icmpge, if_icmpgt, if_acmpeq, if_acmpne) must be the opcode of an instruction within this method."
20:49:10 <SamB_XP_> or were they dumb and used "cdecl"?
20:49:22 <mmorrow> SamB_XP_: so you can't use functions calls like loops
20:49:40 <Gracenotes> hm, it does have max_stack here, http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#1546
20:49:47 <mmorrow> s/loops/goto/, since "loop" makes you think of for/while loops
20:49:54 <mmorrow> which are pretty trivial
20:50:36 <copumpkin> :t loop
20:50:37 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
20:51:36 <Gracenotes> that's a crazy loop!
20:51:51 <_Jordan_mob> Is there an online ghci somewhere?
20:53:02 <wdonnelly> > 2 + 2
20:53:03 <Gracenotes> lambdabot? :) IRC is the internet. just not the web.
20:53:03 <lambdabot>   4
20:53:24 <Gracenotes> in most clients, you can do "/query lambdabot" to open up a private conversation window
20:53:47 <_Jordan_mob> Fair enough, thanks
20:53:49 <mmorrow> _Jordan_mob: codepad.org is the closest thing
20:53:53 <dons> got it working in the end. not sure how, http://donsbot.wordpress.com/2009/10/17/multicore-haskell-now-acm-reflections-projections-2009/
20:55:54 <mmorrow> Jeb: or
20:56:11 <mmorrow> , foldr (.) id [succ,succ,succ,pred] 1
20:56:12 <lunabot>  3
20:57:02 <mmorrow> ((+),0),((*),1),((.),id),((++),[]),(and,True),(or,False),(mappend,mempty)
20:57:44 <Gracenotes> there are no web ghcis that I know of
20:57:49 <mmorrow> (union,"none"),(intersection,"all")
20:58:18 <Gracenotes> _Jordan_mob: except, codepad is capable of compiling executing Haskell programs, in addition to serving as a pastebin. it is inefficient as an interpreter, though ;)
20:58:36 <Saizan_> there was a web interface to \lb once
20:59:07 <_Jordan_mob> Interesting
20:59:29 <dons> lambdaweb.
20:59:34 <dons> lispy hosted it
20:59:50 <dons> "google-chrome"-style sandboxing and all ;)
20:59:55 <Gracenotes> I suppose if you take appropriate measures you could get some web-hosting/VPN that would let you run ghci (hackily) as a process. e.g. nearlyfreespeech.net has Haskell/happs installed by default
20:59:59 <dons> actually, haskell-style sandboxing, cause we can.
21:00:15 <dons> you donn't want to run ghci i think.
21:00:39 <SamB_XP_> dons: does that yet work on anything besides NT ?
21:01:01 <Gracenotes> is that too much better than lambdabot simply compiling everything that's given to it, though...
21:01:40 <Jeb> morrow, I get an error about indentation when I put it in my file, however works from the command line, any ideas?
21:01:56 <Jeb> nevermind
21:02:02 <Jeb> I'm brain dead tonight
21:02:10 <mmorrow> :)
21:03:11 <Jeb> would you mind explaining what the identity is needed for in that?
21:03:17 <mmorrow> Gracenotes: lunabot (and i believe lambdabot too) are both running on hosted servers
21:03:37 <_Jordan_mob> Jeb: It's the initial
21:03:51 <mmorrow> Gracenotes: you can also just grab the bindist (then optionally compile a source dist with that, or just use the bindist)
21:03:55 <_Jordan_mob> Value of the fold (the starting point)
21:04:30 <mmorrow> , ppDoc <$> foldr (\g f -> [|$g . $f|]) [|id|] (replicate 4 [|succ|])
21:04:32 <lunabot>  succ . (succ . (succ . (succ . id)))
21:04:59 <Jeb> I get that, but why does it work
21:04:59 <mmorrow> , $(foldr (\g f -> [|$g . $f|]) [|id|] (replicate 4 [|succ|])) 1
21:05:00 <lunabot>  5
21:05:21 <mmorrow> Jeb: it builds a functions that is a pipeline of four succ's
21:05:38 <mmorrow> id adds nothing to it, just like 0 adds nothing to 1
21:05:50 <mmorrow> but you just finish off the fold with id
21:06:02 <mmorrow> and also, if the list is [], then you get id
21:06:12 <Gracenotes> church encoding.. sort of.
21:06:14 <Jeb> hmmm
21:06:22 <mmorrow> just like sum [] == 0
21:06:32 <Jeb> I'm new at all this, so my understanding of id is limited
21:06:41 <mmorrow> @let ntimes n = foldr (.) id . replicate n
21:06:42 <lambdabot>  Defined.
21:06:46 <mmorrow> sum [] = 0
21:06:55 <mmorrow> ntimes [] = id
21:06:58 <mmorrow> err, oops
21:07:10 <mmorrow> @let pipe = foldr (.) id
21:07:11 <lambdabot>  Defined.
21:07:17 <mmorrow> pipe [] = id
21:07:38 <mmorrow> so pipe's like the function analog of sum
21:07:55 <Gracenotes> it also ensures that (sum a + sum b) yields the same result as (sum (a ++ b)). which is a nice property to have.
21:08:04 <Jeb> thanks
21:08:14 <mmorrow> Jeb: similar to unix pipelines
21:08:16 <Gracenotes> hm. so long as the Num instance is a monoid with (+) and 0, at least
21:08:30 <Gracenotes> hm.
21:08:34 <mmorrow> Jeb: cat:=id, |:=(.)
21:08:37 <Gracenotes> I didn't think of it like that before >_>
21:08:54 <Saizan_> ?src id
21:08:55 <lambdabot> id x = x
21:09:00 <mmorrow> Gracenotes: a monoid homomorphism
21:09:09 <Jeb> thanks for your help guys
21:09:11 <Saizan_> it's the function that just returns its input
21:09:15 <lispy> ?pl \x -> x
21:09:16 <lambdabot> id
21:09:20 <Orclev> @hoogle pipe
21:09:20 <lambdabot> Network.Socket AF_WANPIPE :: Family
21:09:20 <lambdabot> Network.Socket.Internal AF_WANPIPE :: Family
21:09:20 <lambdabot> Foreign.C.Error ePIPE :: Errno
21:09:27 <lispy> ?pl id x = x
21:09:27 <lambdabot> id = id
21:09:30 <lispy> heeh
21:09:33 <Orclev> @hoogle (|)
21:09:34 <lambdabot> Text.Parsec.Prim class Monad m => | (Stream s m t) (s -> t)
21:09:34 <lambdabot> Control.Monad.Error.Class class Monad m => | (MonadError e m) (m -> e)
21:09:34 <lambdabot> Control.Monad.RWS.Class class (Monoid w, MonadReader r m, MonadWriter w m, MonadState s m) => | (MonadRWS r w s m) (m -> r)
21:09:46 <lispy> > let id = id in id 1
21:09:50 <lambdabot>   mueval-core: Time limit exceeded
21:09:50 <mmorrow> f(a <>_m1 b) = f(a) <>_m2 f (b)
21:09:53 <SamB_XP_> Gracenotes: that's generally considered to be part of being numeric, yes ;-)
21:10:23 <mmorrow> Orclev: i just @let defined it above
21:10:41 <Orclev> mmorrow: oh, I joined after that point I think
21:10:53 <mmorrow>  @let pipe = foldr (.) id
21:11:04 <Gracenotes> SamB_XP_: good point. only made possible by the mathematical consistency of sum [] returning 0, howeva!
21:11:06 <mmorrow> and with cat and | i was talking about unix pipes
21:11:14 <mmorrow> cat | cat
21:11:16 <mmorrow> id . id
21:11:32 <Jeb> mmorrow, good analogy
21:11:39 <SamB_XP_> Gracenotes: which is likewise standard
21:11:46 <Orclev> hmm... in some ways pipe in unix is more like (>>=)
21:12:10 <mmorrow> Orclev: right
21:12:25 <SamB_XP_> oh ... *that* must be what was bothering me about PowerShell the other day ...
21:12:27 <mmorrow> well, (>=>) rather
21:12:34 <Gracenotes> for no particular monad..
21:12:42 <SamB_XP_> ... it doesn't make you put in "return" calls where you ought to have to!
21:12:44 <Orclev> :t (>=>)
21:12:45 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
21:13:18 <mmorrow> @type (<=<)
21:13:19 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
21:13:20 <Orclev> ops that have more than two args always confuse me
21:13:35 <Orclev> just doesn't *feel* right
21:13:42 <Gracenotes> the main thing about piping is that the implicit variable is what's coming from stdout.. sort of different from function application
21:13:43 <mmorrow> adding the implicit parens helps
21:13:46 <Saizan_> but is has two args
21:13:51 <Saizan_> *it
21:13:58 <mmorrow>  (b -> m c) -> (a -> m b) ->              (a -> m c)
21:14:00 <SamB_XP_> Orclev: well, it's just that you can't make @type put more parens there
21:14:32 <mmorrow> let X a b = (a -> m b)      X b c -> X a b -> X a c
21:14:39 <Gracenotes> foldl :: ((a -> b -> a) -> (a -> ([b] -> a)))
21:14:40 <mmorrow> let X a b = (->)   ...
21:14:49 <mmorrow> err, X a b = (a -> b)
21:15:19 <Gracenotes> ghci wouldn't know where to stop :) although it might be nice if it could listen to explicit type signatures for suggestions, just like it does for polymorphic type name suggestions
21:15:43 <Saizan_> Gracenotes: well that's why >>> fits, the input to the arrow is stdin and the result of the arrow is stdout
21:16:11 <Orclev> :t (>>>)
21:16:12 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
21:16:44 <Orclev> hmm... how would one use (>>>)?
21:16:58 <Saizan_> >=> is >>> specialized to kliesli arrows, which are those of the form "a -> M b", where M is a monad
21:17:27 <Gracenotes> Saizan_: I think it breaks down too quickly.. command arg1 arg2 is not equal to arg2 | command arg1
21:17:38 <Gracenotes> well, cat/echo arg2
21:17:39 <Saizan_> > (+1) >>> (*2) $ 1
21:17:39 <SamB_XP_> Saizan_: with appropriate applications of {run,}Kleisli
21:17:40 <lambdabot>   4
21:18:06 <Orclev> the problem is that in unix you have two distinct inputs, you have command line args, and stdin
21:18:13 <Gracenotes> yeah
21:18:38 <Orclev> rather than (\x ->), it's more like (\x y ->)
21:18:42 <Gracenotes> perhaps if you treat command line args as part of a single command.
21:18:47 <Saizan_> Gracenotes: in that case "command :: A -> B -> C ~> D" where ~> is the shell arrow
21:19:08 <Saizan_> command would be a regular function that produces an arrow
21:19:15 <SamB_XP_> I don't really get how powershell does piping ...
21:19:20 <Gracenotes> often, they /are/ interchangeable: grep regex blah, and cat blah | grep regex.
21:19:45 <sshc> when are they not?
21:20:00 <Gracenotes> when it's not explicitly coded in? :P it is ad hoc
21:20:06 <Orclev> Gracenotes: that's because the default behavior of most commands is to read from stdin if no options are given on the command line
21:21:04 <Saizan_> xargs is something like ArrowApply
21:21:10 <Orclev> well... I say no options, but what I really mean is no other input is specified, such as a filename
21:21:21 <Gracenotes> nowhere near as strong as a type system.
21:21:23 <mmorrow> Orclev: yeah, i always wish for more stdfoo's
21:22:07 * Saizan_ would love a typed shell with haskell as scripting language
21:22:08 * SamB_XP_ wants stdcake
21:22:12 * SamB_XP_ also wants stdcookies
21:22:29 <Orclev> mmorrow: I think there's some obscure syntax you can use to create at least a couple extra ad-hoc std-whatever's, but I can never remember it
21:22:36 <Saizan_> and if you've a process that doesn't fit, you can always give it the type ByteString ~> ByteString
21:22:58 <SamB_XP_> Saizan_: ehhh???
21:23:00 <Saizan_> [String] -> ByteString ~> ByteString, actually
21:23:02 <Gracenotes> not to mention you can often use - to thread things in explicitly :) essentially, one has to consider the 'type' of a command, for piping purposes, as inseparable from what the command line arguments prescribe for it
21:23:19 <Saizan_> (except that ~> is not a type constructor but a variable)
21:23:56 <Orclev> hmm... maybe one could think of the command line args as being somewhat like the type signature of a function, in which case the stdin would be correspond to the args?
21:23:58 <Saizan_> Gracenotes: why?
21:24:05 <Gracenotes> the actual arguments themselves, and their order, is irrelevant. just the sum of their behavior. most shells let you shoot yourself in the foot if it mismatches :)
21:24:24 <mmorrow> you could also think of the "|" themselves as the "->", and the programs as some image of typevars
21:24:24 <Saizan_> i'd consider command line args as distinct from stdin / stdout
21:24:39 <Saizan_> they are just a different kind of thing.
21:25:21 <Orclev> Saizan_: there's nothing explicity tying them together, but in practice the command line args usually specify what the program should expect on stdin
21:25:33 <Orclev> and/or what it should output on stdout
21:25:40 <mmorrow> err, maybe that's a bad way to say it, but i just mean by looking at the opposite graph
21:25:43 <Gracenotes> Saizan_: yes, so would I. which is where the >>> analogy breaks down. which is merely what I said a few minutes ago, is all
21:25:47 <SamB_XP_> and/or what files it should read instead of -
21:26:01 <mmorrow> like with http://moonpatio.com/vacuum/gallery/duals.png
21:26:27 <Orclev> mmorrow: uhm, what is that?
21:26:28 <mmorrow> amusingly, with graphs the (dual . dual) is isomorphic to id
21:26:32 <Saizan_> right, but do they specify the type of what you put on stdin/stdout? i guess they do if you want pretty tight types, but that not necessarily the case, you can use sum types or dependent types for that, however
21:26:45 <mmorrow> a --f--> b --g--> c
21:26:49 <Saizan_> Gracenotes: i think it's what makes the >>> analogy hold :)
21:26:50 <SamB_XP_> mmorrow: dual . dual is supposed to be isomorphic to id
21:27:00 <mmorrow> --a--> f --b--> g --c-->
21:27:01 <mmorrow> a --f--> b --g--> c
21:27:03 <sproingie> is that where oracle gets the name DUAL from for its table?
21:27:16 <mmorrow> SamB_XP_: that's jut a special case
21:27:31 <Gracenotes> mmorrow: just make it -(b)-> and you've got DDC! :D
21:27:32 <Saizan_> Gracenotes: i'd write "foo x y | bar w z" as "foo x y >>> bar w z"
21:27:35 <mmorrow> SamB_XP_: e.g. for vector spaces it is, but not for modules
21:27:45 <SamB_XP_> "CoCo" = ""
21:28:09 <c_wraith> Hmm.  Is there a TH example around that shows inlining external files as string constants?
21:28:40 <mmorrow> c_wraith:     includeFile file = lift =<< runIO (readFile file)
21:28:49 <mmorrow> c_wraith:  includeFile :: FilePath -> ExpQ
21:29:05 <Gracenotes> Saizan_: so that makes you could do: a=`foo x y`; bar w z a?
21:29:08 <mmorrow> someFile :: String; someFile = $(includeFile "somefile.txt")
21:29:11 <Saizan_> and there's nothing in arrow saying that "foo x" should be equal to "returnA x >>> foo"
21:29:15 <Gracenotes> like you could for the type system?
21:29:25 <c_wraith> thanks, mmorrow
21:29:27 <Gracenotes> *"$a"
21:29:32 <mmorrow> Orclev: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2362
21:29:37 <mmorrow> c_wraith: np
21:29:47 <Saizan_> Gracenotes: no, >>> is not used with the -> instance
21:30:09 <Saizan_> Gracenotes: maybe ~> and -> are too similar and you didn't notice the difference?
21:30:12 <SamB_XP_> Saizan_: eh ?
21:30:17 <Gracenotes> that's the main point, that Haskell conflates arguments with the thing being threaded (in the arrow), whereas in command lines, they are entirely different (but codependent) abstractions
21:30:21 <Saizan_> SamB_XP_: what?
21:30:47 <SamB_XP_> what do you use instead of >>> with the -> instance ?
21:30:50 <Gracenotes> I have a feeling codependent means something in a category theory context
21:31:00 <dons> huh, i think my post disappeared from reddit, can anyone find this on the front or new page? http://www.reddit.com/r/programming/comments/9v5ao/multicore_haskell_now_todays_acm_reflections/
21:31:04 <Saizan_> Gracenotes: foo :: X -> Y -> ShellArrow A B, how is that conflation?
21:31:12 <mmorrow> SamB_XP_: ah right, "amusingly" in the sense that looking at (dual . dual) rendered in dot and the original graph it's surprising at first they're the same
21:31:38 <Saizan_> SamB_XP_: i meant that i'm not using the -> arrow there, but another one
21:31:45 <SamB_XP_> Saizan_: oh.
21:31:46 <mmorrow> SamB_XP_: since (dual . dual) has "((_,_),(_,_))" as labels, and the original has "_"
21:31:52 <Gracenotes> Saizan_: because you can say "foo (x :: X) (y :: Y)"
21:31:54 <SamB_XP_> why didn't you actually say that ?
21:31:57 <mmorrow> so dot renders them totally different
21:32:12 <Gracenotes> ..if I comprehend the notation you have
21:32:16 <SamB_XP_> mmorrow: ah, yeah
21:32:24 <Saizan_> Gracenotes: my notation is just haskell
21:32:47 <Jeb> is there anyway to make it so the compiler will let me define something named    main   ?
21:33:09 <Saizan_> Gracenotes: and what's the problem with saying "foo (x :: X) (y :: Y)"? those are command line arguments
21:33:17 <Jeb> (which is a different type, it expects   IO t)
21:33:43 <c_wraith> heh.  And what are relative paths relative to at compile time?
21:33:52 <mmorrow> c_wraith: ooh, you're in luck
21:33:54 <Saizan_> maybe 6am is not the right time for me to explain my ideas, as SamB_XP_ pointed at :)
21:33:54 <Orclev> Jeb: you can specify a different name for the main method with a command line switch
21:33:57 <mmorrow> , src ''Loc
21:34:01 <lunabot>  data Loc = Loc {loc_filename :: String,
21:34:01 <lunabot>                  loc_package :: String,
21:34:01 <lunabot>                  loc_module :: String,
21:34:06 <Saizan_> s/at/out/
21:34:06 <mmorrow> , ''Loc
21:34:08 <lunabot>  Language.Haskell.TH.Syntax.Loc
21:34:12 <Gracenotes> I'll just say what I said 20 minutes ago: "the main thing about piping is that the implicit variable is what's coming from stdout.. sort of different from function application". that's all I'm saying...
21:34:13 <Orclev> Jeb: not sure if that will let you do that though
21:34:14 <SamB_XP_> Saizan_: clearly, you are in the wrong part of the world
21:34:20 <Jeb> thanks orclev, I'll look into it
21:34:22 <mmorrow> , [$ty| location |]
21:34:22 <SamB_XP_> here, it is only 12:30 AM ;-P
21:34:24 <lunabot>  Q Loc
21:34:39 <mmorrow> , [$ty| lift . loc_filename =<< location |]
21:34:42 <lunabot>  Q Exp
21:34:48 <Saizan_> Gracenotes: don't you mean stdin?
21:34:49 <mmorrow> , [$ty| $(lift . loc_filename =<< location) |]
21:34:51 <lunabot>  [] Char
21:34:54 <mmorrow> , $(lift . loc_filename =<< location)
21:34:56 <lunabot>  "<interactive>"
21:35:10 <Gracenotes> Saizan_: uh. I suppose, but I did mean more stdout of the upstream process
21:35:15 <Orclev> maybe it could be argued that something like a state monad would be a better model for stdin/stdout?
21:35:29 <Gracenotes> 'stdout' was a bad way of phrasing it
21:36:00 <Gracenotes> Orclev: I thought about that.. but each pipe has its own state, not visible to pipes down the line
21:37:23 <Orclev> Gracenotes: hmm... yes and no, they don't actually have their own state, it just that the default transform *isn't* id, which it would be using something like state monad, rather it's more like zero
21:37:59 <c_wraith> I think that's enough pieces.  time to dive into learning TH
21:38:03 <Gracenotes> hm. I suppose the thing is that each operation is necessarily a modify one
21:38:11 <Gracenotes> each command
21:38:11 <Saizan_> Gracenotes: however what i tried to say is that using arrows you don't have to model stdin as an argument your function should be applied to, you can model command line arguments that way instead.
21:38:29 <Saizan_> Gracenotes: and stdin would be the input of the resulting arrow
21:38:32 <Gracenotes> yes. it would be nice to use as a shell
21:38:54 <Gracenotes> except for the weird interaction, again, of the command line arguments that specify how stdin/stdout operates
21:39:29 <Saizan_> yeah, you need dep. types for that
21:39:55 <Gracenotes> if the goal is along the lines of the Unix philosophy, what bash and cousins do now is relatively ideal :)
21:41:14 <Saizan_> the long term goal could be being able to fuse away the [de]serialization to a textual representation when appropriate
21:41:15 <tommd1> Saizan_: In other news, Oleg has used the Haskell/GHC type system to specify how stdin/stdout operate.
21:41:19 <SamB_XP_> Saizan_: I'm pretty sure you want dep types anyway
21:41:26 <Saizan_> and something more functional in the mean time :)
21:41:55 <Saizan_> tommd1: yeah, i know that i'm not saying anything particulary knew
21:42:16 <Saizan_> tommd1: but what are you referring to specifically?
21:42:24 <SamB_XP_> Saizan_: did you also know that you aren't sleeping ?
21:42:30 * Nafai wishes he could find his copy of RWH
21:42:38 <Gracenotes> now, in such a system, specifying the arguments-to-stream-behavior-transform in a way that vaguely resembles what most commands do now... in a dependent type system...
21:42:49 <Saizan_> SamB_XP_: well, i wouldn't type "knew" if i was awake
21:43:07 <Gracenotes> I can't even think of where to begin :)
21:43:13 <tommd1> Saizan_: it was just a joke
21:43:17 <SamB_XP_> Saizan_: if you were asleep, it would look more like n mj
21:43:29 <SamB_XP_> except you'd probably never hit enter
21:43:44 <Orclev> hmm... a command in unix can be roughly thought of as ([a], b) -> (c, d), where [a] is a command line arg, b is stdin, c is stdout, and d is stderr... something like (|) is therefor (|) (o, _) f a = f (a, o)
21:45:18 <Saizan_> tommd1: http://okmij.org/ftp/Computation/monadic-shell.html <- but!
21:45:42 <Saizan_> SamB_XP_: enter is pretty large
21:45:44 <tommd1> nice find
21:46:23 * SamB_XP_ begins to wonder if PowerShell was originally intended to *be* a Monad ...
21:47:43 <Saizan_> that was the first name, right?
21:47:48 <c_wraith>     GHC stage restriction: `includeFile'
21:47:49 <c_wraith>       is used in a top-level splice, and must be imported, not defined locally
21:47:51 <c_wraith> *sigh*
21:48:04 <c_wraith> That's probably a good rule, but it's a bit silly. :)
21:48:13 <SamB_XP_> c_wraith: it's a horrible rule
21:48:34 <SamB_XP_> it's just because the silly people who made TH are too lazy to figure out how to do multiple stages!
21:58:07 <c_wraith> mmorrow:     Couldn't match expected type `Q Exp' against inferred type `t m a'
21:58:07 <c_wraith>     In the first argument of `(=<<)', namely `lift'
21:59:12 <Saizan_> c_wraith: different lift
21:59:36 <Saizan_> ?hoogle lift
21:59:37 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
21:59:37 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
21:59:37 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
21:59:37 <c_wraith> hah.  oh
21:59:40 <c_wraith> I see.
21:59:43 <c_wraith> let me fix my imports
21:59:44 <c_wraith> :)
22:01:03 <c_wraith> ok, thanks saizan and mmorrow
22:14:06 <coyo> nini
23:00:09 <SubStack> yay, reinstalling Cabal with... cabal... fixed... cabal
23:00:18 <SubStack> pesky old-time linker errors
23:24:56 <BMeph> Why isn't outputting to a web browser as easy as outputting to the screen?
23:25:25 <c_wraith> because there are approximately 1 billion incompatible web browsers
23:25:57 <Gracenotes> canvas!
23:26:22 <Gracenotes> *IE sits in a corner*
23:30:56 <BMeph> Why isn't outputting to Safari/Opera as easy as outputting to the screen?
23:38:42 * dancor remembers vesa c programming and the screen not being that easy to output to either
23:40:17 <Fragswor1h> Is it possible to "decorate" a function in Haskell?
23:41:06 * p_l recalls machines that had rather inefficient framebuffers, if any, so output wasn't easy as well
23:41:13 <copumpkin> Fragswor1h: can you define that?
23:41:27 <Fragsworth> Like python decorators
23:41:41 <copumpkin> that doesn't help me
23:41:43 <Fragsworth> Suppose a function is defined to do something, but you want to wrap it by some other function
23:41:55 <dons> Fragsworth: we usually just use function composition
23:41:56 <Fragsworth> So that its meaning is changed by that wrapping
23:41:58 <dons> let f' = g . f
23:42:07 <Fragsworth> That requires a new function, though
23:42:18 <Fragsworth> Is it possible to wrap/modify a predefined function?
23:42:19 <copumpkin> compose it with a lambda function then?
23:42:31 <dons> only by declaring a new function or anonymous function
23:42:36 <dons> you can't mutate existing definitions
23:42:40 <dancor> myF = myDecorator $ myUnderlyingF
23:42:40 <dancor> ?
23:42:41 <copumpkin> Fragsworth: can you give an example of something you'd want to decorate?
23:42:44 <dons> dancor: right
23:42:57 <dons> Fragsworth: yes, examples are good, so we can show you the haskell way
23:43:13 <Fragsworth> Ok I'll contrive an example... give me one second
23:43:24 <copumpkin> ideally something that we can illustrate on lambdabot :)
23:43:57 <dancor> i've used decorators in python to specify which functions in a class were exposed as cherrypy pages
23:44:04 <Fragsworth> Do we have a clipboard
23:44:10 <dons> hpaste.org
23:44:56 <Jafet> Sounds like an unnecessarily long contrived example
23:45:04 <copumpkin> yeah...
23:45:06 <dancor> i think "@myDecorator\ndef f():\n.." -> "f = myDecorator $ .." is going to be the general thing to do
23:45:41 <Fragsworth> http://cl1p.net/fragsworth/
23:46:45 <Jafet> How do you want to change the meaning of fac?
23:46:46 <c_wraith> Hmm.  What do I need to do to add a Lift instance for one of my types?
23:46:54 <Fragsworth> So that it is fac+1
23:46:57 <Fragsworth> Or whatever I want
23:47:10 <Jafet> What does fac+1 even mean?
23:47:19 <Jafet> fac is not an instance of Num
23:47:25 <Fragsworth> inc fac
23:47:38 <Fragsworth> I'm still learning the language
23:47:40 <Jafet> How is that different from fac?
23:47:45 <Fragsworth> forgive me if I am confusing you
23:47:56 <dancor> he means fac x = realFac x + 1
23:47:58 <Jafet> You're simply not making any sense
23:48:04 <Fragsworth> dancor has the idea
23:48:25 <Jafet> @hoogle realFac
23:48:26 <lambdabot> No results found
23:48:36 <Jafet> Ok, now I am slightly confused
23:49:01 <dancor> Fragsworth: since the original/real fac is defined recursively with multiple lines, i think you do need to define an actually underlying function
23:49:30 <Jafet> @pl \x -> fac x + 1
23:49:31 <lambdabot> (1 +) . fac
23:49:44 <Jafet> ...oh, duh.
23:50:23 <BMeph> Jafet: succ it.
23:51:04 <BMeph> Jafet: Um, by that, I mean, "use 'succ' instead of '(+1)'."=)
23:51:10 <Jafet> I blow today
23:51:19 <Jafet> @hoogle blow
23:51:20 <lambdabot> No results found
23:51:34 <BMeph> Jafet: So, you're your own fan - sweet! ;p
23:52:51 <dancor> Fragsworth: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10877#a10877
23:53:41 <Fragsworth> dancor: I see ohw that works
23:53:47 <Fragsworth> It's a little less convenient
23:54:59 <dancor> i suppose it is in a way.  it's really an issue of things not being mutable
23:55:10 <Fragsworth> Is there a fundamental reason why we can't just do (fac = succ fac)
23:55:24 <Fragsworth> mutability?
23:55:25 <copumpkin> that's infinity!
23:55:31 <copumpkin> you can actually do that with naturals
23:55:42 <Fragsworth> copumpkin: not the way python implements it
23:55:44 <copumpkin> > let fac = succ fac in fac > (3 :: Natural)
23:55:46 <lambdabot>   True
23:55:47 <copumpkin> :P
23:56:04 <dancor> Fragsworth: referring to something _as_you_define_it_ is actually useful
23:56:33 <dancor> in (fac = succ fac) it's not like there was some fac earlier and we're making a new fac
23:56:52 <dancor> > let ones = 1:ones in ones
23:56:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:57:15 <copumpkin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
23:57:16 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
23:57:19 <copumpkin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
23:57:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:57:22 <Jafet> > fix (1:)
23:57:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:57:36 <copumpkin> > fix ((0:) . scanl (+) 1)
23:57:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:57:47 <Jafet> Indeed.
23:58:18 <dons> Fragsworth: you want to destroy the original definition entirely?
23:58:25 <Fragsworth> dons: Yes
23:58:37 <Jafet> I suppose you can do that across modules
23:58:47 <Jafet> But it still won't be removed, just renamed
23:58:50 <dancor> Jafet: ha ya i was thinking of that
23:58:54 <dons> no, you can't do that. its a very anti-haskell thing to do. you can simulate it with scope, so only the new fac is in scope though
23:58:58 <dancor> i feel modules have been abused enough ;)
23:59:14 <Jafet> They're only abused because they're so restrictive!
23:59:21 <dons> so you can hide the original definition -- but not destroy it
23:59:35 <dons> and generally, haskellers will understand your code better if you just have fac' and fac
23:59:42 <dons> only one of which might be exported
