00:03:15 <harrison> wtf. my prime number generator works up until 48623, which it skips. (it gets the next prime, and then i don't know where it messes up again after that)
00:06:04 <koala_man> harrison: cute. does it find the factors?
00:08:32 <harrison> it finds one of them, but it doesn't do anything with that information. i suppose it would help for debugging if i made it spit that out too.
00:08:48 <harrison> er, two of them.
00:09:13 <dolio> > sqrt 48623
00:09:14 <lambdabot>   220.50623573949105
00:09:43 <dolio> > any ((>1) . gcd 48623) [1..220]
00:09:44 <lambdabot>   False
00:13:22 <samulihs> any good pointers where to start learning the key to functional programming. i'm having trouble grasping the concept
00:14:53 <pikhq> Learn You a Haskell.
00:15:44 <Veinor> isPrime n = any ((>1) . gcd n) [1..floor $ sqrt n]
00:15:52 <Veinor> why does isPrime 3 fail?
00:17:51 <trzkril> > (\n -> any ((>1) . gcd n) [1..floor $ sqrt n]) 3
00:17:52 <lambdabot>   Ambiguous type variable `b' in the constraints:
00:17:52 <lambdabot>    `GHC.Real.Integral b'
00:17:52 <lambdabot>   ...
00:18:13 <Veinor> yeah.
00:18:20 <Veinor> I fixed it by using sqrt (fromInteger n)
00:18:30 <trzkril> > (\n -> any ((>1) . gcd n) [1..floor $ sqrt . fromInteger n]) 3
00:18:30 <lambdabot>   No instance for (GHC.Real.RealFrac (f a))
00:18:31 <lambdabot>    arising from a use of `GHC.Rea...
00:18:46 <trzkril> > (\n -> any ((>1) . gcd n) [1..floor . sqrt . fromInteger n]) 3
00:18:47 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
00:18:47 <lambdabot>         agains...
00:18:56 <trzkril> > (\n -> any ((>1) . gcd n) [1..floor . sqrt . fromInteger $ n]) 3
00:18:58 <lambdabot>   False
00:19:14 <c_wraith> I think the logic is just wrong
00:19:22 <Veinor> yeah, the logic also got negated >_>
00:19:22 <trzkril> well, False is the right answer
00:19:36 <Veinor> I just got confused with the whole 'playing around with int/integer/float thing
00:19:51 <trzkril> > (\n -> any ((>1) . gcd n) [1..floor . sqrt . fromInteger $ n]) 2
00:19:52 <Veinor> @pl all ((==1) . gcd n) [1..floor $ sqrt (fromInteger n)]
00:19:52 <lambdabot> all ((1 ==) . gcd n) [1..floor (sqrt (fromInteger n))]
00:19:52 <lambdabot>   False
00:19:55 <blackh> samulihs: I remember when I was learning I had the same problem - I couldn't find anything explaining how to do it, so I had to learn it by doing it.
00:20:03 <Veinor> @pl \n -> all ((==1) . gcd n) [1..floor $ sqrt (fromInteger n)]
00:20:03 <lambdabot> ap (all . ((1 ==) .) . gcd) (enumFromTo 1 . floor . sqrt . fromInteger)
00:20:36 <samulihs> blackh, yep. that's how i've started just yesterday, but thought that maybe i should ask :)
00:21:14 <c_wraith> I can't be the only one who's written "modify $ \s -> s { ..." and been mildly frustrated with record update syntax, right?
00:21:19 <blackh> samulihs: I know an article describing the design of a game of PacMan in a functional style - would that help?
00:21:33 <Veinor> @hoogle modify
00:21:33 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
00:21:33 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
00:21:33 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
00:21:37 <dolio> > [1..floor $ sqrt 3]
00:21:38 <lambdabot>   [1]
00:21:50 <dolio> Use ceil.
00:21:55 <dolio> > ceiling 1.5
00:21:56 <lambdabot>   2
00:21:59 <dolio> ceiling.
00:22:09 <c_wraith> floor is sufficient.
00:22:37 <c_wraith> the ceiling squared is going to exceed the number you're checking, so it can't be the first factor.
00:22:40 <Veinor> right.
00:22:54 <Veinor> in any case, isPrime n = all ((==1) . gcd n) [1..floor $ sqrt (fromInteger n)]
00:22:58 <dolio> Ah, yeah.
00:23:15 <quetal> how do I write a monad for an If control structure, I have a type for it like this: ifstatementIO :: IO Bool -> IO a -> IO a -> IO a, but should I just return the Bool that's passed in, how do I return the IO a world untouched?
00:23:32 <Veinor> you might be able to speed that up by filtering the list on the right via isPrime
00:24:00 <dolio> You should inter-define lists of primes and prime tests, really. :)
00:24:26 <Veinor> hm, I wonder
00:24:27 <blackh> samulihs: http://prog21.dadgum.com/23.html
00:24:48 <Veinor> I need a reasonably large prime to test this on
00:25:02 <dolio> > let primes = 2 : filter isPrime [3..] ; isPrime n = any ((1>) . gcd n) . takeWhile ((>) . sqrt . fromInteger $ n) $ primes in primes
00:25:03 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Internals.Integer)
00:25:03 <lambdabot>    arisi...
00:25:18 <dolio> > let primes = 2 : filter isPrime [3..] ; isPrime n = any ((1>) . gcd n) . takeWhile ((>) . floor . sqrt . fromInteger $ n) $ primes in primes
00:25:21 <lambdabot>   mueval-core: Time limit exceeded
00:25:25 <yakov> hey
00:25:42 <samulihs> blackh, thanks. i'll take a look at that :)
00:25:47 <Veinor> bah, I forgot how to time haskell code
00:25:48 <SmurfOR> With a recursive datatype declaration is there a way to allow the children of that type to have different types?  like Cons 1 (Cons 2 (Cons "Three" Empty))?
00:26:32 <dolio> > let primes = 2 : filter isPrime [3,5..] ; isPrime n = not . any ((1>) . gcd n) . takeWhile ((>) . floor . sqrt . fromInteger $ n) $ primes in primes
00:26:34 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
00:27:37 <dolio> > let primes = 2 : filter isPrime [3,5..] ; isPrime n = not . any ((1>) . gcd n) . takeWhile ((>) . floor . sqrt . fromInteger $ n) $ primes in isPrime 48623
00:27:38 <lambdabot>   True
00:28:24 <Veinor> heh, my non-optimized version runs faster
00:28:47 <Veinor> at least for small numbers
00:28:48 <dolio> gcd may be overkill.
00:29:17 <Saizan> quetal: the monad is IO, what you're trying to define is often called a monadic function
00:29:17 <dolio> > let primes = 2 : filter isPrime [3,5..] ; isPrime n = not . any (\m -> n `mod` n /= 0) . takeWhile ((>) . floor . sqrt . fromInteger $ n) $ primes in isPrime 48623
00:29:18 <lambdabot>   True
00:29:34 <quetal> oh
00:29:41 <ski> quetal : you mean you want to write a conditional combinator in the `IO'-monad (`IO' is a monad, `ifstatementIO foo bar baz' would be an `IO'-action)
00:30:08 <dolio> Then again, I can't remember if that's the best relatively naive, list-based way to generate primes.
00:30:26 <quetal> ya
00:30:45 <ski> quetal : the simplest would be to use `do'-notation to run the condition of type `IO Bool', to extract the `Bool'-value, and then proceed accordingly
00:31:04 <EvilMachine> uuum‚Ä¶ does haskell really not have a modulo operator for floating point numbers?
00:31:22 <dolio> > 30 `mod'` pi
00:31:23 <lambdabot>   1.725666117691862
00:31:39 <Veinor> @hoogle mod'
00:31:39 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
00:31:39 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
00:31:44 <Veinor> well there you go
00:31:46 <EvilMachine> > 30.0 `mod` pi
00:31:47 <lambdabot>   Ambiguous type variable `t' in the constraints:
00:31:47 <lambdabot>    `GHC.Float.Floating t'
00:31:47 <lambdabot>  ...
00:32:01 <Veinor> > 30.0 `mod` 2.3
00:32:02 <lambdabot>   Ambiguous type variable `t' in the constraints:
00:32:02 <lambdabot>    `GHC.Real.Fractional t'
00:32:02 <lambdabot> ...
00:32:04 <EvilMachine> > (30.0::Float) `mod` pi
00:32:05 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Float)
00:32:05 <lambdabot>    arising from a use o...
00:32:15 <quetal> so do I do: ifstatementIO bool = do {x <- bool;} return bool ?
00:32:16 <dolio> mod' not mod.
00:32:20 <EvilMachine> ah
00:32:33 <EvilMachine> > (30.0::Float) `mod'` pi
00:32:34 <lambdabot>   1.725666
00:32:39 <dolio> Not a good name, I know.
00:33:38 <EvilMachine> yeah, that guy that wrote mod' instead of % must be really proud for his ‚Äúgreat‚Äù mathematic obfuscation syntax style. :/
00:33:56 <dolio> % is already taken for construction of Rationals.
00:34:02 <EvilMachine> ah
00:34:07 <mmorrow> > let sieve = let go [] _ = [] ;go (x:xs) m = maybe (x : go xs (insert x m)) (go xs . fixup x m) (M.lookup x m); insert x m = M.insert (x*x) [x] m; fixup x m = foldl' (\m p -> M.insertWith' (++) (x+p) [p] m) (M.delete x m) in go [2..] mempty in sieve
00:34:08 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:34:11 <Veinor> > 2 % 7
00:34:12 <lambdabot>   2 % 7
00:34:15 <EvilMachine> yet‚Ä¶ a '?? really?
00:34:19 <Veinor> > 2 % 7 + 3 % 28
00:34:20 <lambdabot>   11 % 28
00:34:35 <Veinor> EvilMachine: x' is standard Haskell for 'like x but different'
00:34:36 <EvilMachine> why not write a function where the letter i is replaced by in √¨
00:34:39 <EvilMachine> ^^
00:35:07 <Veinor> >let m√≤d = mod' in pi `m√≤d` 2.7
00:35:14 <Veinor> > let m√≤d = mod' in pi `m√≤d` 2.7
00:35:14 <lambdabot>   0.44159265358979294
00:35:25 <dolio> Even better, it's in Data.Fixed, even though it works on floating point numbers, too.
00:35:32 <Saizan> quetal: can you describe what your ifstatementIO should do?
00:35:35 <dolio> Thanks to our jacked up numeric hierarchy.
00:35:44 <EvilMachine> Veinor: i know. i critisized the whole ‚Äústandard‚Äù and the whole way it is doin in mathematics, where it comes from. ^^ just like they would rather die than use meaningful identifiers in formulas. ^^
00:36:00 <dolio> There's also an 'instance Floating Fixed' somewhere.
00:36:30 <quetal> it should be able to take a boolean, and based on that boolean perform one of two actions
00:36:38 <quetal> one of two IO actions
00:36:49 <EvilMachine> hmm‚Ä¶ let's see if there‚Äôs also a rem'
00:37:10 <Saizan> quetal: ok, so you don't want to return x, you want to use x to decide which action to run.
00:37:19 <quetal> right
00:37:24 <mmorrow> EvilMachine: like theorem7Lemma4FactoryFactoryOutpost ?
00:37:26 <quetal> how do I get it to run a passed in IO action?
00:38:16 <Saizan> you just have to use it in your do-notation expression, like you did with bool
00:38:36 <Saizan> ifstatementIO bool x y = do x <- boo; ..
00:38:47 <Saizan> err, s/boo/bool/
00:39:21 <quetal> hmm
00:39:43 <Twey> matchClause (Interface   i) m = Just i == listToMaybe [x | (Interface   x) <- headers] -- comprehensions FTW
00:40:02 <Twey> Now I just wish I could patten-match on variables so I could abstract that out into a function‚Ä¶
00:40:09 <quetal> but how does it test the condition, it seems like it's just assigning
00:40:20 <quetal> can I use the regular haskell if to test?
00:40:27 <Saizan> yes
00:40:28 <PetRat> In running "cabal install readline" I get the error "sh: runProcess: does not exist (no such file or directory)". I checked all dependencies, but trying to install some of those gave me the same error.
00:40:46 <PetRat> This is Windows XP (i.e. DOS)
00:40:48 <EvilMachine> mmorrow: no. like a
00:40:59 <Saizan> quetal: x is of type Bool there, so you can use "if x then .. else .."
00:41:19 <mmorrow> EvilMachine: heh, good comeback :)
00:41:39 <Saizan> PetRat: you need to install msys to get an sh.exe
00:41:42 <ivanm> EvilMachine: like a what?
00:42:25 <PetRat> Saizan: hmm. I think sh exists. It is sh that is reporting the error. I think. Also note that I have never had trouble before running cabal.
00:42:45 <quetal> can I do this then: ifstatementIO bool exp1 exp2 = if bool then {do return exp1;} else {do return exp2;}
00:42:53 <Saizan> PetRat: there are only a few packages that use a configure script
00:43:29 <PetRat> Saizan. OK. What is the difference between MinGW and MSYS?
00:43:30 <Saizan> PetRat: i.e. it's not normal to need sh
00:43:40 <PetRat> I have MinGW installed.
00:43:59 <Saizan> mingw doesn't include utilities like sh, iirc
00:44:04 <notsmack> hmm, can somebody confirm that Network.TCP.isTCPConnectedTo from the http package never returns True?
00:44:10 <EvilMachine> ivanm: an identifier, like a
00:44:38 <PetRat> Saizan: yes, I'm looking through the MinGW bins and don't see sh.exe. I'll try installing MSYS.
00:44:55 <EvilMachine> ivanm: just like i accidentially the whole bottle. :P
00:45:14 <ivanm> ahhhhh
00:45:15 <Saizan> quetal: i suggest you to read this http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html to get a better understanding of do-notation
00:45:26 <ivanm> I didn't realise that there was a new meme around
00:45:33 <EvilMachine> ivanm: no, we meant an identifier named ‚Äúa‚Äù
00:45:40 <ivanm> ahhhh
00:45:54 <ivanm> Saizan: you're not promoting the expansion of the monad tutorial industry, are you?
00:46:17 <EvilMachine> ivanm: using ‚Äúb‚Äù would not have confused you, but it being confusing was part of the argument. :)
00:46:26 <Saizan> PetRat: you could also try running sh.exe at the prompt, if that doesn't work cabal won't be able to run it either
00:46:26 <ivanm> EvilMachine: yeah, yeah, I get it now...
00:46:46 <Saizan> ivanm: sigfpe guarantees good quality
00:48:09 <ivanm> fair enough
00:48:17 <EvilMachine> Saizan: i had a hard time understanding monads. but the wikibooks page on them finally made it clear. by going all the way. from how it‚Äôs really just a container, to how it drags the container all the way through everything, but in an invisible obfuscated way. ^^
00:48:37 <ivanm> who did the rant about monad tutorials, using "Monads are Burrittos!" example?
00:48:49 <Saizan> byorgey i think
00:49:18 <blackh> EvilMachine: You have attained grokment!
00:49:19 <dolio> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
00:49:29 <ivanm> Saizan: yeah, that sounds about right
00:50:00 <EvilMachine> what was that thing called again that in the latest episode of South Park was mentioned as making you crap blood. that would fit better than burritos, no?
00:50:04 <ivanm> (as dolio just demonstrated)
00:50:37 <Saizan> the summary is: "read the original papers and play around with some examples", i add that sigfpe gets quite close to the original papers and can be less intimidating
00:52:28 <quetal> how come this doesn't work: ifstatementIO bool exp1 exp2 = do {      (if bool       	 then (do {x <- exp1})       	 else (do {x <- exp2}))      return x; }
00:52:48 <Saizan> even thinking of monads as "containers" is not really accurate, unless by container you mean functor
00:53:04 <ivanm> quetal: I think because the x is local within thd do statements
00:53:13 <ivanm> if bool then exp1 else exp2
00:53:20 <ivanm> quetal: ^^ looks like this is equivalent
00:53:25 <Saizan> quetal: you can't use bool as first parameter to if, because bool is of type IO Bool, while if takes a Bool
00:53:50 <ivanm> @undo \ b e1 e2 -> do if b then (do x <- e1; return x) else (do x <- e2; return x)
00:53:50 <lambdabot> \ b e1 e2 -> if b then (e1 >>= \ x -> return x) else (e2 >>= \ x -> return x)
00:53:53 <EvilMachine> yeah. i have created world‚Äôs slowest non-hanging function! :P
00:53:57 <EvilMachine> :(
00:53:59 <ivanm> bah
00:54:03 <quetal> oh
00:54:04 <ivanm> @. pl undo \ b e1 e2 -> do if b then (do x <- e1; return x) else (do x <- e2; return x)
00:54:05 <lambdabot> flip flip id . ((.) .) . if'
00:54:10 <ivanm> heh, not quite what I wanted
00:54:15 <ivanm> @. pl undo do if b then (do x <- e1; return x) else (do x <- e2; return x)
00:54:16 <lambdabot> if' b e1 e2
00:54:19 <ivanm> yup
00:54:28 <ivanm> EvilMachine: what function is this?
00:55:14 <quetal> so to evaluate an IO bool what should I do
00:55:22 <EvilMachine> ivanm: a failed attempt to lazily read a file and write in in another file, and i think it only writes if i kill the process. ^^
00:55:24 <quetal> ifstatementIO bool exp1 exp2 = do {      (if bool       	 then (do {x <- exp1; return x})       	 else (do {x <- exp2; return x})) }
00:55:31 <ivanm> EvilMachine: heh
00:55:31 <quetal> that at least fixes the scope issue right
00:55:35 <Saizan> quetal: what you did at the start, do x <- bool
00:55:37 <Twey> Hum
00:55:38 <ivanm> too much laziness?
00:55:44 <ivanm> quetal: you don't need the dos at all
00:55:53 <ivanm> quetal: remember the monad laws!!!
00:55:55 <Twey> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4379#a4379 ‚Äî what's wrong with this?  Complains that the types don't match.
00:56:03 <EvilMachine> ivanm: yes. i guess a "flush" would make sense, no?
00:56:09 <ivanm> in particular, do m == m; do x <- f; return x == f
00:56:11 <ivanm> EvilMachine: yup
00:56:12 <Twey> (which they don't, but they're both instances of Message)
00:56:35 <ivanm> EvilMachine: maybe xs <- input; rnf xs `seq` output xs ?
00:56:39 <quetal> what do you mean ivanm
00:56:43 <Saizan> Twey: you'd want exists instead of forall there
00:56:52 <ivanm> quetal: you have do x<- exp; return x
00:56:57 <ivanm> that is equivalent to just exp
00:57:10 <ivanm> @google monad laws
00:57:11 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
00:57:12 <lambdabot> Title: Monad laws - HaskellWiki
00:57:15 <ivanm> quetal: ^^
00:57:22 <Saizan> Twey: but exists doesn't exist
00:57:27 <Twey> Saizan: Er, do we have an‚Ä¶ yeah.  :√æ
00:57:32 <quetal> I did do that though
00:58:02 <ivanm> quetal: you still have things like (do { x <- exp1; return x}) in the sample you put above
00:58:24 <ksf> http://en.wikipedia.org/wiki/Dependency_injection
00:58:26 <quetal> isn't that what you showed me
00:58:30 <ksf> we don't have a lib for that stuff, do we?
00:58:31 <Saizan> quetal: "ifstatementIO bool exp1 exp2 = do x <- bool; if x then exp1 else exp2"
00:58:38 <dqd> EvilMachine: Chipotle. It's the restaurant company that sells burritos and tacos.
00:59:04 <ksf> mhhh maybe one could consider ReaderT
00:59:08 <Saizan> Twey: there are ways to encode them though
00:59:14 <ksf> ...but that requires monadic code.
00:59:29 <ksf> and implicit parameters are considered evil, I heard.
00:59:42 <ivanm> quetal: first I said that the x was local to the do blocks; now I'm saying that you don't need any do blocks at all
00:59:56 <ski> implicit parameters are different from `Reader r' (or `ReaderT r m')
01:00:00 <fasta> Is there some kind of extension which allows me to override the syntax for if?
01:00:04 <ivanm> you might need one if your bool is actually IO Bool; that's about it
01:00:09 <ivanm> fasta: why?
01:00:21 <fasta> I find if too have too much syntactic overhead.
01:00:23 <quetal> my bool is actually IO boo
01:00:27 <quetal> l
01:00:36 <fasta> to*
01:00:43 <EvilMachine> ivanm: hmm, i have a bunch of data <- loadFromFile fileName; and then one writeInFile fileName data. where would i introduce a seq there? or does flushing suffice?
01:00:51 <quetal> so I try this: ifstatementIO :: IO Bool -> IO a -> IO a -> IO a ififstatementIO bool exp1 exp2 = do x <- bool; if x then exp1 else exp2
01:00:59 <Janni> Whoa, this has become a _large_ channel...
01:01:01 <quetal> whoops
01:01:01 <ivanm> quetal: right, so what you want is ifstatementIO b e1 e2 = do b' <- b; if b' then e1 else e2
01:01:11 <ivanm> Janni: has become? where have you been the last few years?
01:01:18 <Saizan> Twey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4379#a4380
01:01:19 <ksf> ah, yes, I see, they bring early mistakes of lisp to haskell.
01:01:24 <ksf> dynamic scope _is_ evil.
01:01:25 <ivanm> quetal: yeah, as I was saying... you didn't need do blocks for the then and else
01:01:28 <fasta> Janni: more bots than people ;)
01:01:29 <Janni> ivanm: Not here apparently.
01:01:42 <ivanm> EvilMachine: I haven't done much IO stuff ;-)
01:01:43 <Twey> fasta: You can make a function.
01:01:55 <ivanm> but I think flushing would work, or else rnf `seq` writeInFile
01:01:56 <EvilMachine> Janni: wait another year, and there will be a #haskell-gaming-de subchannel (where de is the language) ^^
01:01:57 <Twey> (y ?? n) p = if p then y else n
01:02:06 <blackh> EvilMachine: What are you trying to do?
01:02:07 <ivanm> EvilMachine: flushing would probably be better (rather than manually flushing)
01:02:08 <EvilMachine> ivanm: ok.
01:02:12 <fasta> Twey: The point was to override if-syntax.
01:02:23 <fasta> Twey: I already use iF.
01:02:26 <ksf> but there's an iso between ReaderT to making your module a record and parametrizing its construction.
01:02:31 <quetal> I see but it still doesn't work, how do I get the bot to accept multiple lines of input
01:02:43 <ivanm> EvilMachine: you're saying there's enough german game programmers that want to/actually do use haskell to warrant a seperate IRC channel? :o
01:02:57 <ivanm> quetal: ummmm, the bot doens't accept IO to start with
01:03:01 <ivanm> *doesn't
01:03:05 <ksf> ivanm, count me in.
01:03:12 <ski> ksf : what do you see ? who is "they" ?
01:03:14 <quetal> oh
01:03:15 <EvilMachine> blackh: reading a couple of files, combining them in a function (like sequencing, but a bit more complex), and then writing the function output to another file. compiles fine, runs fine, only hangs while not writing
01:03:19 <ivanm> ksf: talk to EvilMachine, not me! ;-)
01:03:37 <EvilMachine> ivanm: not now. but there hopefully will be. :)
01:03:40 <quetal> ifstatementIO :: IO Bool -> IO a -> IO a -> IO a
01:03:41 <quetal> ifstatement IO bool exp1 exp2 = do x <- bool; if x then exp1 else exp2
01:03:47 <quetal> should work right
01:03:48 <ksf> "they" is "that evil lot of parameters"
01:03:52 <ivanm> EvilMachine: right, you have a year.... go!
01:03:53 <ivanm> ;-)
01:03:56 <Saizan> quetal: ylj
01:03:58 <Twey> Saizan: Hmm‚Ä¶
01:03:59 <ivanm> quetal: yes
01:04:03 <quetal> typo there
01:04:14 <ivanm> Saizan: "ylj"?
01:04:18 <Saizan> quetal: yes, put it into a file and e.g. load that file with ghci
01:04:20 <Twey> ksf: It's not really dynamic scope, because the implicit parameters are encoded in the type of the function.
01:04:26 <Saizan> ivanm: typo too
01:04:42 <Twey> Saizan: That kind of defeats the point of unwrapping the value, though.  :√æ
01:04:46 <ski> ksf : "dynamic scoping" is mostly bad when it is the default
01:05:04 * EvilMachine sends e-mail about haskell to all game developer company mailing lists in the world, circumventing spammers by hacking into the CEO‚Äôs account first. that will show ivanm! :P
01:05:15 <Saizan> Twey: well stick to getMessage instead of getMessageAny
01:05:23 <Twey> The bad thing about dynamic scoping is that you don't know what you may or may not be passing.
01:05:26 <Twey> Saizan: And just pass id?
01:05:31 <ksf> so it's evil. I don't refrain from evil to do good, but I don't use bad things.
01:05:45 <ski> ksf : accounting for it in the types mostly avoids you using something that depends on a parameter without you realizing it
01:05:56 <Saizan> Twey: no, pass the function that uses the value
01:05:57 <Twey> Argh, Firefox crashed again
01:06:14 <Twey> Saizan: Heh.
01:06:18 <blackh> EvilMachine: I'm not quite with ya, but I can probably help if you can explain it.
01:06:21 <Saizan> Twey: id would be a type error, much like your first attempt
01:06:26 <ski> apart from that, there's the breach of some equational reasoning (which is bad, but not in the same sense)
01:06:27 <quetal> oh ok
01:06:32 <quetal> thanks ivanm, Saizan
01:06:46 <Twey> Saizan: That would be perfectly convenient, if only the thing I want to do with it weren't the expression I mentioned earlier, which unfortunately doesn't like being abstracted into a function.
01:07:05 <Twey> 08:40:43 < Twey> matchClause (Interface   i) m = Just i == listToMaybe [x | (Interface   x) <- headers] -- comprehensions FTW
01:07:09 <Twey> 08:41:03 < Twey> Now I just wish I could patten-match on variables so I could abstract that out into a function‚Ä¶
01:07:22 <ivanm> EvilMachine: heh
01:07:26 <ivanm> quetal: np
01:07:47 <Saizan> Twey: what's the problem in abtracting that?
01:08:06 <ksf> ski, what do you mean with "implicit parameters are different from `Reader r' (or `ReaderT r m')"? (except the latter being monads, of course)
01:08:32 <ski> "implicit parameters" is a side-effect
01:08:54 <Saizan> Twey: actually, you're not using m there
01:09:11 <ski> `Reader r' allows you to express effects in terms of monadic actions
01:09:19 <EvilMachine> blackh: ok, i‚Äôll simplfy it: imagine a function, lazily reading data from a bytestring. in main, i use data <- thatReadFunction. then on the line below, i call thatWriteFunction data, which i a function that lazily writes the data to a file. the second function is proven to work, when i generate data in the program. but right now, if i run the program, it just hangs there.
01:09:33 <ski> so the former clashes with purity, while the latter doesn't
01:09:52 <Saizan> EvilMachine: there's no lazy write, aside from OS buffering
01:09:58 <EvilMachine> blackh: now imagine the same thing, but with multiple reads, the combination of those data into one, and then writing it out
01:10:06 <ksf> you mean one works with scope, the other with the evaluation model?
01:10:08 <EvilMachine> Saizan: ah, ok
01:10:14 <EvilMachine> Saizan: but a lazy read
01:10:27 <Twey> Saizan: Oh, m is used by another function in a where clause.  I guess mentioning it there is redundant.
01:10:40 <ksf> I see how you could e.g. make a function that returns a custom runReader, one doesn't seem to be able to do that with implicit params.
01:11:30 <ski> ksf : i meant that with the former, `let x = ... in ..(x)..' no longer has the same value as `..(...)..'
01:11:40 <Saizan> Twey: depends, i'd have to see all of that to tell
01:12:08 * ski wonders what a "custom `runReader'" is
01:12:13 <Saizan> EvilMachine: yeah
01:12:26 <blackh> EvilMachine: Based on that information, the only possibilities I can think of are: network-related things, file locking (writing to the same file you read from for example) or an infinite loop in your pure code.  If you paste it I'll take a look.
01:13:09 <Twey> Saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4379#a4381 ‚Äî this is the function that uses it
01:13:27 <ksf> well you can construct a function that returns different versions of Reader a -> a, with different values to ask, that is.
01:13:33 <EvilMachine> blackh: ok, but i‚Äôll first try some things myself. to ensure it‚Äôs not something else.
01:13:54 <ksf> ski, yes, that's what I mean with "works with scope"
01:15:03 <ksf> so they're somewhat parallel in most of their expressivity but quite orthogonal in their usage.
01:15:11 <Twey> Saizan: The problem is that the pattern on which I'm matching in the comprehension varies
01:15:35 <Twey> And it's not really possible pass a pattern to a function, as far as I'm aware
01:15:39 <ski> (Twey : btw, you don't need to pass `m' to `matchClause' there)
01:16:03 <ski> @type Control.Monad.Reader.runReader
01:16:04 <lambdabot> forall r a. Reader r a -> r -> a
01:16:14 <Twey> ski: Yeah, it's vestigial ‚ò∫
01:18:08 <Saizan> Twey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4379#a4382
01:18:16 <ski> Twey> :t Interface
01:18:35 <ksf> I don't even want a Reader monad, I want a Reader applicative.
01:19:01 <Saizan> Twey: oops, s/(`matchClause` m)/matchClause/
01:19:03 <ksf> ...forces me to put functions in the type instead of values.
01:19:06 <Twey> Saizan: Ack :√æ  I guess that works, though, yeah.  Thanks.
01:19:23 <ksf> better encapsulation and composing.
01:20:29 <ClaudiusMaximus> > foldr (.) id [f, g, h] s
01:20:30 <lambdabot>   f (g (h s))
01:21:11 <Saizan> Twey: depending on the types "headers = getMessage m messageHeaderFields" might work too, and same for body, whould would let you keep the where
01:23:10 <Saizan> Twey: the important bit is that the type of the message must not appear in the result of k
01:23:34 <quetal> I have a doUntilIO function that takes an IO expression and an IO Bool, and should perform the expression once, then check to see if the bool is true (if so, it should exit), and if false, then it should continue looping;  here is my try: doUntilIO exp bool = do exp; ifIO bool (return ()) (do {doUntilIO exp bool})
01:24:25 <benmachine> redundant do :o
01:24:38 <Saizan> yeah, you don't need the last do
01:24:54 <Saizan> the rest is good
01:24:56 <benmachine> also see: Control.Monad.when
01:25:41 <quetal> cool, thanks!
01:25:48 <benmachine> you could do that function as
01:26:31 <benmachine> doUntilIO act p = act >> p >>= flip when (doUntilIO act p)
01:26:41 <benmachine> and no do at all!
01:26:59 <quetal> what is flip
01:27:12 <benmachine> or doUntilIO act p = do act; b <- p; when b (doUntilIO act p) is the simple way
01:27:20 <benmachine> flip takes a function
01:27:27 <benmachine> and reverses its first two arguments
01:27:31 <ski> @src flip
01:27:31 <lambdabot> flip f x y = f y x
01:27:55 * benmachine always thought that was clearer as flip f = \x y -> f y x
01:28:16 <quetal> oh interesting
01:28:36 <ski> one could imagine `(flip f) x y = f y x'
01:28:43 <benmachine> one could do that
01:28:45 <ski> (unfortunately, iirc, that's bad syntax)
01:28:58 <stoop> Yes.
01:29:10 <benmachine> or one could imagine my version which is good syntax
01:29:17 <benmachine> even if hlint would whine a bit
01:29:32 * ski duly imagines benmachine's version is good syntax
01:29:42 <benmachine> touch√©
01:30:45 <royt-0> Hey everyone
01:31:12 <royt-0> I was wondering how I could define a type like : type Expr = (Element, Expr)
01:31:14 * ski has sometimes wanted to say `f@(foo x) y = ..x.y.f.'
01:31:29 <int-e> > sqrt (2^31)
01:31:30 <lambdabot>   46340.95001184158
01:31:38 <ksf> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-State.html#t%3AIxState    oooooh
01:31:58 <royt-0> Ofcourse this is a recursive definition, but I'm kinda puzzled how else I should solve my parser problem then
01:32:02 <ksf> there's gems, everywhere.
01:32:04 <ski> royt-0 : since you want a recursive type, you need to use `data' or `newtype', plain `type' doesn't suffice, because that only creates type synonyms, which may not be cyclic
01:32:14 <royt-0> ah ok
01:32:19 <ski> so, e.g.
01:32:30 <ski>   newtype Expr = MkExpr (Element,Expr)
01:32:31 <ski> or
01:32:48 <ski>   data Expr = Foo Element Expr
01:33:03 <Twey> Saizan: *nod* I see ‚Äî thanks
01:34:02 <royt-0> Oh ok, hmm lemme try
01:35:50 <int-e> harrison: I'm not sure why that would matter, but 48623 is quite close to  sqrt (2^31).
01:36:19 <ski> @type fix $ \doUntilIO act p -> act >> p >>= (`when` doUntilIO act p)
01:36:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m Bool -> m ()
01:36:44 <hackagebot> ghc-events 0.1.0.2 - Library and tool for parsing .eventlog files from GHC (SimonMarlow)
01:36:47 <ski> @type fix $ \doUntilIO act p -> act >>= \x -> p x >>= (`when` doUntilIO act p)
01:36:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> (a -> m Bool) -> m ()
01:37:15 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10687
01:37:19 <ksf> now that's even cooler.
01:37:20 <ski> @type fix $ \doUntilIO act_p -> act_p >>= (`when` doUntilIO act p)
01:37:21 <lambdabot> Not in scope: `act'
01:37:23 <ski> @type fix $ \doUntilIO act_p -> act_p >>= (`when` doUntilIO act_p)
01:37:24 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m ()
01:37:47 <EvilMachine> blackh: ok, i tested it, and it has to be that function that is problematic: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10771 (which makes sense, because it‚Äôs messy code. I‚Äôm new at this. even adding a $! after the return did nothing.)
01:38:37 <quicksilver> ski: "(flip f) x y = f y x" is valid syntax, btw
01:38:54 <quicksilver> well GHC accepts it.
01:39:05 <EvilMachine> blackh: I hope the german identifiers are not distracting. if yes, then then imagine them as a, b, c, etc. ^^
01:39:11 <blackh> EvilMachine: Mein Deutsch ist schrecklich, es tut mir leid
01:39:12 <ivanm> quicksilver: isn't that how . is defined?
01:39:14 <ivanm> @src .
01:39:15 <lambdabot> (f . g) x = f (g x)
01:39:23 <royt-0> Say I got that Expr=MkExpr(Element, Expr) and data Element = A | B | C, how could I match 'any' element so I could do pattern matching on the element (just to name it)
01:39:42 <quicksilver> yes, you have to allow some () if you want to define infix operators like that
01:39:47 <EvilMachine> blackh: does it matter to understand what the function does?
01:42:02 <EvilMachine> blackh: I‚Äôve done a translation: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10771#a10772
01:43:05 * ksf wants to learn to code like that
01:43:05 <blackh> EvilMachine: I can understand German a bit, but I'm better at English. :)
01:43:05 <ski> royt-0 : `foo (MkExpr (element,expr)) = ..element..expr' ?
01:43:12 <EvilMachine> blackh: the translation is done. :)
01:43:16 <ski> quicksilver : oh .. then probably i was confusing it with something else
01:43:25 * ksf can't stand german identifiers.
01:43:36 <ksf> I don't want to switch languages for keywords and idents.
01:44:05 <ksf> plus, I want to retain the capability of complaining when someone frensh does it.
01:44:25 <blackh> EvilMachine: That function looks correct to me.
01:44:26 <royt-0> ski: I tried like (match :: Expr -> Expr,   match (a e) = e for testing, where a should match any element
01:44:52 <ksf> it's "ausDateiLaden" not "ladeAusDatei", btw.
01:44:52 <ski>   match (MkExpr (a,e)) = e  -- royt-0, try this
01:45:17 <quetal> how to get first element of haskell list?
01:45:21 <ksf> you're describing a verb, not an order.
01:45:25 <ski> > head [1,4,2,8,5,7]
01:45:26 <lambdabot>   1
01:45:34 <quetal> thanksski
01:45:36 <ski> quetal : or match on it
01:45:48 <royt-0> ski: a thanks mate, that loads
01:45:49 <ski> (if you're already matching, that is usually simpler)
01:45:55 <quetal> what you mean
01:46:00 <blackh> quetal: or Data.Maybe.listToMaybe for yet another way to do it
01:46:02 <EvilMachine> ksf: mach ich doch wie ich will!
01:46:12 <ski> if you are defining a function,  `foo', like
01:46:14 <blackh> EvilMachine: Wracking my brains....
01:46:14 <ksf> anarchist!
01:46:14 <EvilMachine> ksf: ^^
01:46:26 <ski>   foo x y z = ..(head y)..
01:46:29 <EvilMachine> blackh: well, it should work, shouldn‚Äôt it?
01:46:30 <ski> then you can just as well use
01:46:40 <ski>   foo x (y0:ys) z = ..y0..
01:46:46 <hackagebot> hs-ffmpeg 0.3.2 - Bindings to FFMPEG library (VasylPasternak)
01:46:48 <blackh> EvilMachine: It definitely should work - how big is the file?
01:47:10 <EvilMachine> blackh: one is 376K
01:47:42 <ski> quetal : if you paste the code in question, we can give better suggestions
01:47:49 <EvilMachine> i do a (lC, sound1) <- loadFromFile "sound1.pcm" 48000
01:47:51 <PetRat> To use System.Console.Readline, do I have to explicitly download and build readline? And how do I point "cabal install" to the object or archive file? (Windows XP)
01:47:57 <EvilMachine> blackh:  i do a (lC, sound1) <- loadFromFile "sound1.pcm" 48000
01:48:35 <PetRat> (the configure step of "cabal install readline" says it can't find the rl_readline_version)
01:48:36 <blackh> EvilMachine: 'source t' will be terribly inefficient
01:48:40 <EvilMachine> blackh: and 3 others. then i use code to sequence them all. that code works.
01:49:10 <blackh> EvilMachine: It is 0% CPU or 100% CPU?
01:49:23 <quetal> i just needed the head of a list of IO args
01:49:23 <EvilMachine> blackh: i know. :/ yeah. close to 100% ^ ^.
01:49:44 <EvilMachine> blackh: but what better to do? i need random access.
01:49:49 <quetal> like do {x <- head getArgs; }
01:49:54 <quetal> it works
01:50:00 <blackh> EvilMachine: 'source t' is the problem, I think - you need to use an array....
01:50:12 <blackh> EvilMachine: import Data.Array.Unboxed
01:50:41 <blackh> EvilMachine: source t = listArray (0, length-1) $ runGet ...
01:50:47 <ksf> that IxRef code doesn't come with the most fun function: deleteIxRef.
01:50:53 <blackh> EvilMachine; I mean.........
01:51:06 <blackh> EvilMachine: samples = listArray (0, length-1) $ runGet ...
01:51:16 <blackh> EvilMachine: source t = samples ! (round ...
01:51:41 <EvilMachine> blackh: listArray? never seen that. i have to look it up.
01:52:36 <quetal> any way to convert an IO STring into a String?
01:52:41 <skorpan> yes!!!
01:52:45 <skorpan> unsafePerfomIO
01:52:55 <skorpan> :t unsafePerformIO
01:52:56 <lambdabot> Not in scope: `unsafePerformIO'
01:53:00 <skorpan> ...hm.
01:53:07 <blackh> quetal: You need to use a <-
01:53:10 <ksf> unsafeCoerce!
01:53:22 <ksf> if you blow up, at least do it properly!
01:53:38 <blackh> quetal: str <- ioStr
01:53:40 <EvilMachine> blackh:  ah, understood. why does listArray make it faster? looks like even more overhead‚Ä¶
01:54:00 * quicksilver ponders banning skorpan for that offence against propriety.
01:54:04 <EvilMachine> blackh: i also have to remove the index again
01:54:23 <blackh> EvilMachine: listArray turns it into an unboxed array, that is, a packed array of floats in memory... then each time you use 'source t' it just indexes the same array.
01:54:42 * quicksilver meant to smiley that :)
01:54:46 <blackh> EvilMachine: !! is no good because it follows a linked list from the start each time
01:54:47 <skorpan> :(
01:55:22 <mmorrow> @type System.IO.Unsafe.unsafePerformIO
01:55:23 <lambdabot> forall a. IO a -> a
01:55:58 <PetRat> Where should I put readline.a so that the configure step of "cabal install readline" will find it?
01:55:58 <mmorrow> @type Unsafe.Coerce.unsafeCoerce
01:55:59 <lambdabot> forall a b. a -> b
01:56:07 <quetal> blackh: I tried that but it doesn't work; main :: IO () main = do {x <- getArgs;         	  file <- readFile (head x); 	  filelines <- lines file; 	  print filelines}
01:56:15 <mmorrow> @type Foreign.peek Foreign.nullPtr
01:56:16 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO a
01:56:24 <EvilMachine> blackh: ah, ok. and ! doesn‚Äôt. ok‚Ä¶
01:56:34 <blackh> quetal: let filelines = lines file
01:56:40 <ksf> hmmm wait. for deleteIxRef, the indexing scheme doesn't work. one would need a way to compute unique values on the type level.
01:56:52 <royt-0> Thanks for your help ski! This might get me quite a little bit further
01:57:00 <ksf> ...or just annotate an index with "deleted"
01:57:07 <mmorrow> @type Unsafe.Coerce (System.IO.Unsafe.unsafePerformIO (Foreign.peek Foreign.nullPtr)) :: ()
01:57:08 <lambdabot> Couldn't find qualified module.
01:57:25 <mmorrow> @type System.IO.Unsafe.unsafePerformIO (Foreign.peek Foreign.nullPtr)
01:57:26 <lambdabot> forall a. (Foreign.Storable.Storable a) => a
01:57:27 <blackh> EvilMachine: ! is fast. Very useful if you want to DESTROY THE ENTIRE UNIVERSE MWAHAHAHAHAHAHHA!
01:57:36 <mmorrow> tried to take it one step too far there for a second
01:57:43 <EvilMachine> blackh: LOL.
01:58:17 <EvilMachine> /bow blackh
01:58:31 * EvilMachine bows to blackh
01:58:34 <blackh> EvilMachine: My cat is sitting on my knee.
01:58:49 <EvilMachine> blackh: is it white and do you wear a iron glove?
01:58:50 <blackh> (Every Evil Lord needs a cat.)
01:58:52 <ksf> does its breath smell of cat food?
01:58:57 <mmorrow> my cat is drinking from the sink
01:59:06 <EvilMachine> ksf: no. of *humans*
01:59:14 <EvilMachine> ksf: which is the same for that cat ^^
01:59:27 <quetal> blackh: the first let work, now if I want to keep doing stuff with non-IO types, I can't keep using let to store variables?
01:59:35 <quetal> main = do {x <- getArgs;         	  file <- readFile (head x); 	  let filelines = lines file; 	  sortedlines = sortBy comp filelines; 	  }
01:59:47 <quetal> i tried putting let in front of sortedLines but still get compile error
01:59:59 <quetal> er...parse error
02:00:12 <PetRat> Where should I put readline.a so that the configure step of "cabal install readline" will find it?
02:00:43 <EvilMachine> blackh: do Haskell arrays use any fast hashing by any chance?
02:00:44 <blackh> quetal: There should be no problem putting 'let' in front of sortedLines - make sure you're not using tabs in your editor
02:01:11 <ski>   main = do x <- getArgs
02:01:15 <ski>       file <- readFile (head x)
02:01:20 <blackh> EvilMachine: Haskell arrays are just arrays - no hashing
02:01:30 <ski>             file <- readFile (head x)  -- er
02:01:38 <ski>             let filelines = lines file
02:01:44 <ski>                 sortedlines = sortBy comp filelines
02:01:51 <ski>             ...
02:02:15 <ski> quetal : so as long as you line up properly, there should not be a problem
02:02:24 <quetal> hmm, I will try that indentation
02:02:50 <hackagebot> ffmpeg-tutorials 0.3.2 - Tutorials on ffmpeg usage to play video/audio (VasylPasternak)
02:03:13 <blackh> quetal: Make sure you know the indentation rules.  Shall I recite them now?
02:03:22 <quetal> yes
02:03:46 <Saizan> irssi tells me that you're indeed using tabs.
02:03:47 <blackh> There are four keywords: where, do, let, of
02:04:19 <blackh> The next non-whitespace token after those keywords sets the indentation level
02:04:30 <blackh> Anything that lines up with that token is in the same block
02:04:41 <quetal> ok
02:04:56 <blackh> The first line that's to the left of that level indicates the end of the block
02:05:58 <quetal> ok
02:06:11 <quetal> how do I set emacs to stop getting hard tabs
02:06:35 <blackh> That's it.
02:06:54 <EvilMachine> blackh: ok, it‚Äôs working now.
02:07:39 <EvilMachine> blackh: i just have to get it *way* faster, if i want to use it in realtime. ^^
02:07:40 <ski>   (setq-default indent-tabs-mode nil)
02:07:42 <blackh> EvilMachine: That array is not lazy, of course
02:08:11 <ski> (s/-default// to apply it in an existing buffer, iiuc)
02:08:17 <EvilMachine> blackh: ok, that‚Äôs ok for small files. for big ones though‚Ä¶
02:08:28 <ksf> EvilMachine, arrays are O(1) index without using hashing...
02:08:40 <blackh> EvilMachine: It is possible to get Haskell to go really fast, but it can take some trial-and-error.
02:08:46 <ksf> and for sparse indexing, we've got maps.
02:09:13 <quetal> ski: where do i type that in GNU emacs?
02:09:21 <quetal> i mean
02:09:22 <quetal> GUI emacs
02:09:22 <ski>   M-:
02:09:28 <ski> then enter that
02:09:35 <ksf> none is a hash, though, as they a) wouldn't be any more efficient that tries, in the general case (perfect hashing might work better for some) b) they're quite a bugger to implement functionally
02:09:38 <ski> (you can also put it in your `.emacs')
02:09:46 <EvilMachine> blackh: well, i‚Äôd need some profiling tool. :)
02:10:03 <ksf> we _do_ have a perfect hash library on hackage, though.
02:10:08 <ski> quetal : ok ?
02:10:21 <blackh> EvilMachine: It is well worth learning to use GHC's profiling tool - it works really well
02:10:27 <ksf> there's a bloom filter implem somewhere, too.
02:11:13 <EvilMachine> blackh: OK, of course GHC has such a tool integrated. How could I think that anything was not in that giant but very cool beast :D
02:11:26 <EvilMachine> blackh: hey, thank you very much for all the help!
02:11:30 <quetal> ok I put it in the .emacs and it works now! thanks
02:11:38 <ksf> so, my answer, in general, is: don't ask for data structures, tell us what you want to use it for.
02:12:36 <EvilMachine> blackh: if you by any chance are in cologne in germany some time, you get a drink of your choice! :)
02:13:01 <ski> (there might be some other (possibly better) way to set this option, but i don't know it)
02:13:10 <ksf> don't take his offer. they put sewage water into bottles there, calling it "beer"
02:13:33 <blackh> EvilMachine: NP. Axman6 and I are both Haskell speed demons, so you can ask us about GHC optimization. It's a bit unpredictable sometimes. The GHC boys keep working on it - there are plans in the pipeline to make it less ad-hoc.
02:14:07 <blackh> EvilMachine: Next time I am in Cologne, I will have a beer with you.  It's a little bit out of my way, though - I'm in New Zealand.
02:14:24 <navlelo> Can anyone help me with a small issue... I need to change the first data type of the "Let" expression to Char, but i get an error in my code when i change it. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4383#a4383
02:14:36 <EvilMachine> blackh: ouch. lol. ok, if i am in new zealand, i‚Äôll buy you one too. :)
02:14:55 <EvilMachine> blackh: i only know a friend of a friend, who lives there
02:15:08 <blackh> EvilMachine: Great!  I'll look forward to it.  We should make an evil plan!
02:15:45 <Lemmih> navlelo: (Var z, xs''') = parseExpr xs''?
02:15:50 <quetal> you live in K√∂ln?
02:16:40 <EvilMachine> blackh: yeah! it will be evil. *so* evil! it will be a bad, bad plan, that will hurt many people that are *good*! i think it will be great, because it will be so *bad*! :D
02:16:40 <Lemmih> navlelo: Also, x >= 'A' = True, doesn't mean what you think it means.
02:16:50 <EvilMachine> quetal: yup
02:17:04 <quetal> cool
02:17:16 <EvilMachine> quetal: and you?
02:17:25 <quetal> i live in California
02:17:26 <navlelo> Lemmih: oh, what should it say then? my skills are pretty limited :P
02:17:53 <Lemmih> navlelo: | x >= 'A' | x <= 'Z'
02:18:15 <EvilMachine> quetal: Ah, allright. I have a aunt in LA. She was here last week. :)
02:19:33 <quetal> oh that's cool...I just learned how to spell K√∂ln auf Deutsch, no real connection :)
02:20:33 <ksf> "cologne" is the original name, anyway, it stems from "colony".
02:20:56 <ksf> ...it's been the way the romans finally conquered germany.
02:21:08 <ksf> I guess they got pissed after being invaded.
02:21:52 <quetal> haha
02:22:16 <ksf> they used subversive ideology to do it.
02:22:22 <ksf> "christianity", it's called.
02:22:56 <blackh> Isn't "Germany" a Roman name?
02:23:18 <quetal> Germania!
02:23:18 <EvilMachine> ksf: well, it was called oppidum ubiorum, then Colonia Claudia Ara Agrippinensium, which got shortened to Colonia Agrippina in latin and Coellen in german, which became K√∂lle in lower german, and then K√∂ln :)
02:23:20 <ksf> ...arguing that because there's only one god, there's only one ruler, and of course he's god's left hand.
02:23:48 <ksf> yep.
02:24:06 <EvilMachine> blackh: We say ‚ÄúDeutschland‚Äù. But Germany comes from the Germanic people, I guess.
02:24:15 <ksf> the term "deutsch" is relatively recent, the anciet germans didn't know it.
02:25:18 <ksf> ...not to mention that the language called "deutsch" is also quite young and has been designed a lot by their inventors.
02:25:34 <fasta> IIRC, there are still some underground Roman churches (on which other churches were built) in Cologne.
02:25:34 <quetal> wikipedia says the term "German" comes from some gallic term for "neighbor"
02:25:56 <quetal> what's interesting is that en fran√ßais, cousin germain means first cousin
02:25:59 <quetal> connection?!!?
02:26:09 <blackh> Fascinating!
02:26:14 <EvilMachine> ksf: there was Holy Roman Empire of the German Nation (Heiliges R√∂misches Reich Deutscher Nation / Imperium Romanum Sacrum Nationis Germanic√¶)
02:27:20 <ksf> as a rule of thumb, the more qualifiers a state's name carries, the more likely it's not a state you'd want to live in.
02:27:29 <quetal> hahaha
02:27:54 <blackh> "New" Zealand - not as good as "Zeeland"
02:28:17 <bastl> I have this custom cabal build with userhooks which works very well. Only my custom code is on a very undergraduate-level. But I have no idea what library functions or cool tricks could be used for this kind of minimal template-engine: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4384#a4384
02:28:22 <ksf> I heard it's actually called "Sheepfucker's land" by the neighbours.
02:28:24 <quetal> are you saying, you wouldn't want to live in Libya? "Al-JamƒÅhƒ´riyyah al- øArabiyyah al-Lƒ´biyyah a≈°-≈†a øbiyyah al-I≈°tirƒÅkiyyah al- øU·∫ìmƒÅ"
02:28:58 <blackh> ksf: They're just jealous
02:29:06 <ksf> of the sheeps?
02:29:28 <ksf> you mean because kangoos tend to jump away?
02:30:02 <ivanm> ksf: there's no kangaroos in NZ
02:30:12 <quetal> don't kangaroos kill humans that approach them
02:30:15 <ksf> but in bigger down under.
02:30:17 <ivanm> not always
02:30:30 <ivanm> and I've never heard it referred to as "Sheepfucker's Land"...
02:30:40 <ivanm> (but we do make fun of the kiwis and their sheep)
02:30:44 <ivanm> oh, and their accents
02:30:45 <ivanm> ;-)
02:30:48 <EvilMachine> ksf: i learned it that way: there was Charles the Great, who owned all of the area from france to poland. it got split into 3 areas because he had 3 children, and some external areas in poland. one part became france, one became germany, something like that. ^^
02:31:00 <quetal> I've always wondered, do sheep say "baa" like goats?
02:31:31 <EvilMachine> ksf: lol. right. just like small companies have giant names, while big ones have only 3 letters or one word. :)
02:31:32 <bastl> EvilMachine: yeah, and in the middle was "lothringen" because the son was called "Lothar"
02:31:36 <blackh> quetal: Sheep and goats sound slightly different.  There are lots of both where I am.
02:31:37 <ksf> sheep say "m‰‰h"
02:31:59 <ksf> we use them as lawn-movers for our dikes, here.
02:32:16 <quetal> haha! i thought you said you lawn-mowed them
02:32:24 <bastl> what was this channel about ?
02:32:32 <ksf> curry lamb.
02:32:58 <ksf> er the isomorphism of lamb curry and curried lambdas.
02:33:00 <blackh> bastl: On a completely different subject - what do your script do?
02:33:41 <bastl> blackh: a minimal template-engine, that puts colourized haskell examples into a html file (template)
02:33:58 <bastl> %%EX1%% is replaced with hscoloured EX1.hs
02:35:18 <bastl> Lunch calls.
02:35:56 <blackh> The thing I like best about sheep is the way they look at you as if you're a complete moron.
02:37:59 <EvilMachine> blackh: it‚Äôs them. they are quite‚Ä¶ dim. ^^
02:38:05 <EvilMachine> (the sheep)
02:38:37 <quetal> why do I keep getting parse error on input print here: main :: IO () main = do {x <- getArgs;            file <- readFile (head x);            let safefile = file;            print file;            }
02:39:00 <quetal> doesn't that look right? i'm not using tabs anymore
02:39:18 <blackh> quetal: That does look correct. Paste it exactly as you've got it and we should be able to spot the trouble.
02:39:24 <EvilMachine> quetal: try using hpaste.org for multiline pastes
02:39:51 <quetal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10775#a10775
02:39:58 <EvilMachine> quetal: what is safefile for? it is not used.
02:40:12 <quetal> ya i was going to use it later...when the error went away
02:40:18 <EvilMachine> ah ok
02:40:27 <blackh> quetal:  remove the last semi-colon (I think - I never use { ; })
02:40:46 <quetal> done -- same thing
02:40:51 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10775#a10776
02:41:29 <ksf> quetal, can you post the exact error?
02:41:52 <Saizan> quetal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10775#a10777 <- try this
02:41:57 <Saizan> if you want to stick to braces
02:42:01 <quetal> it worked with yours, ksf; but my error was: parse error on input `let'
02:43:10 <quetal> works with yours too, Saizan
02:43:21 <ksf> I wouldn't be surprised if Saizan's right.
02:43:23 <quetal> why does the let need braces?
02:43:45 <ksf> seems like using {;} is viral
02:43:52 <ski> because `let' also introduces a new block
02:44:23 <ski> if you use `;', then it is assumed to belong to the `let'-block, if you don't close that off with `{',`}'
02:44:27 <blackh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10775#a10779
02:44:42 <blackh> ^ Another version.  let doesn't like the ;
02:46:38 <quetal> so now I can never use safefile outside that let block?
02:46:48 <ski> > let {x = 1 ; } in x
02:46:48 <lambdabot>   1
02:47:04 <ski> quetal : sure you can
02:47:17 <ksf> it's just a syntactic block.
02:47:30 <ksf> {;} syntax as layout syntax are equivalent.
02:47:45 <ski> the bindings from a `let'-command in a `do'-sequence are in scope in all the subsequent commands in the sequence
02:48:21 <quetal> o
02:50:59 <ksf> do {let foo = bar; baz; quux} desugars to let foo = bar in baz >>= \_ -> quux
02:51:12 <quetal> desugar?
02:51:25 <ksf> remove all that syntactic sugar
02:51:37 <quetal> oh
02:52:29 <ksf> ...most of haskell's syntax is just sugar. that's what makes it so easy to learn.
02:52:42 <ksf> haskell is a quite small language, it's just deep
02:52:57 <ksf> (and the type system is more expressive than any other widely-used language)
02:53:19 <ksf> but the type system is simple, too, some claim.
02:53:27 <ksf> I wish I'd understand it.
02:53:34 <FunctorSalad> coar is quite simple and arguably retains most of the type system
02:53:49 <FunctorSalad> well no typeclasses
02:54:10 <ksf> typeclasses are sugar, too.
02:54:35 <ksf> ...on the value level, that is.
02:55:38 <FunctorSalad> the resolving is not very trivial though
02:55:59 <FunctorSalad> with overlappinginstances and all that
02:56:53 <ksf> the whole type system is quite intimidating.
02:57:15 <FunctorSalad> hmm?
02:57:18 <ksf> in some sense agda's is way easier, as you control it directly.
02:57:33 <ksf> but then it's a bugger to write anything in agda if you don't know how to prove jack.
02:58:20 <ksf> usually not the types by themselves, but the limitations of inference and equality.
02:58:34 <ksf> ...those "expected type a, but inferred type a1" things etc.
02:58:45 <FunctorSalad> in haskell? yeah I couldn't write the inferer either
02:59:41 <Twey> 10:53:58 < ksf> (and the type system is more expressive than any other widely-used language)
02:59:48 <FunctorSalad> but what do you mean "limitations of equality"?
02:59:57 <Twey> I don't know if I'd agree with that.  Scheme, for example, is more expressive than Haskell's type-system.  ;)
03:00:04 <Saizan> in haskell it's quite easier to write the typechecker i think
03:00:12 <ksf> scheme knows only of a handful fixed types.
03:00:15 <solidsnack> What is Edward Kmett's nick?
03:00:15 <Saizan> (wrt agda)
03:00:24 <Saizan> solidsnack: edwardk
03:00:25 <ksf> atom, int, float, something like that.
03:00:28 * Twey facepalms.
03:00:35 <solidsnack> Saizan: Thank you.
03:00:44 <FunctorSalad> ksf: he was misinterpreting your sentence
03:00:46 <Twey> And the Haskell type system knows only about four 'types', no?  :√æ
03:00:52 <Twey> (kinds)
03:01:05 <hackagebot> uuagc 0.9.12 - Attribute Grammar System of Universiteit Utrecht (ArieMiddelkoop)
03:01:19 <Saizan> haskell type-level vs. scheme value level :)
03:01:20 <Twey> Arie‚ÄΩ
03:01:28 <ksf> dynamic typing doesn't count as type system.
03:01:28 <Twey> Arie does Haskell nowadays?
03:01:31 * Twey googles.
03:01:39 <Twey> ksf: No, you're still missing the point.  Forget it.  :√æ
03:01:41 <ksf> I can type dynamically in haskell, too.
03:01:44 <FunctorSalad> who is Arie?
03:01:52 <Twey> Someone I used to know, I think
03:02:16 <ksf> having Nat and other kinds would certainly rock.
03:02:32 <solidsnack> lambdabot: tell edwardk  I heard you wrote something up about hyperbolic sine/cosine of types; I would like to see it (having trouble googling it).
03:02:55 <ksf> use @tell
03:03:01 <FunctorSalad> ksf: you can kinda simulate (closed) sets of type with a multirec-style gadt
03:03:02 <solidsnack> @tell edwardk  I heard you wrote something up about hyperbolic sine/cosine of types; I would like to see it (having trouble googling it).
03:03:03 <lambdabot> Consider it noted.
03:03:05 <hackagebot> hjpath 0.1 - XPath-like syntax for querying JSON (JaroslavGridin)
03:03:18 <solidsnack> ksf: Thank you; I never do remember that.
03:03:59 <FunctorSalad> data IsNat :: (* -> *) where IsZero :: IsNat Zero; IsSucc :: IsNat a -> IsNat (Succ a)
03:04:30 <FunctorSalad> if you pattern match on an IsNat a you get a coercion for a
03:04:46 <ksf> yep I noticed that being used in http://www.reddit.com/r/haskell/comments/9u9h9/someone_implemented_references_using_indexed/
03:05:04 <Twey> ksf: You said ‚Äòthe type system is more expressive than any widely-used language‚Äô, i.e. all widely-used languages are less expressive than Haskell's type system, rather than ‚Äòthe type system is more expressive than *that of* any other widely-used language‚Äô, i.e. Haskell's type system is more expressive than the type system of any other widely-used language.
03:05:19 <Twey> Thus the joke.
03:05:20 <fasta> I want to have some markers end up in the final assembly for a certain Haskell function. E.g. inline assembly. Or just calling a particular function with a known assembly signature, passing some data which is going to end up in the assembly and so on. Any good suggestions?
03:05:31 <ksf> well it _is_ turing complete with extensions.
03:05:38 <ksf> but you're right.
03:05:49 <Twey> I still think Scheme beats it.  Sorry.  :√æ
03:06:25 <Twey> (hm‚Ä¶ a language that uses itself as its own type language?)
03:06:44 <FunctorSalad> aka depently typed
03:06:50 <FunctorSalad> *dependently
03:06:52 <Twey> Oh, right.  Yeah.
03:07:04 <Twey> Damn.  Should've figured that if I had a good idea, someone else must've gotten there first.  ;)
03:07:08 <dolio> You can write plenty of stuff in Agda without knowing how to prove anything.
03:07:11 <ksf> fasta, you can a) link in an .o with your code b) use some .so magic to dynamically load any data
03:07:21 <dolio> Although the lack of general recursion can bite you, I suppose.
03:07:30 <ksf> yep.
03:07:40 <FunctorSalad> how about a nontermination monad?
03:07:54 <dolio> Yeah, you can use that.
03:08:02 <ksf> in haskell I just say UndecidableInstances for type instance Mul n (Succ m) = n `Add` (n `Mul` m)
03:08:03 <fasta> ksf: I am trying to call a Haskell function which is already in a dynamic library from C.
03:08:09 <ksf> though agda should swallow that one.
03:08:18 <FunctorSalad> (but you'll lose computation right?)
03:08:23 <dolio> Technically Agda just colors your code pink if it can't verify that it's terminating, so there's not much you can't actually write in it, period.
03:08:26 <fasta> ksf: it crashes when I call the function.
03:08:37 <bastl> Any comments to my little template engine? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4384#a4384
03:08:38 <ivanm> Axman6: you around?
03:08:45 <ksf> ...well then fix the library to not crash.
03:08:53 <fasta> ksf: heh
03:08:56 * FunctorSalad would be interested in something like agda or coq, but with the conversion extensible by arbitrary term rewriting systems
03:09:06 <hackagebot> curry-frontend 0.2.6 - Compile the functional logic language Curry to several intermediate formats (BerndBrassel)
03:09:07 <fasta> ksf: the Haskell code does not crash.
03:09:09 <hackagebot> KiCS 0.8.8 - A compiler from Curry to Haskell (BerndBrassel)
03:09:19 <ksf> yep. as I said, fix the lib.
03:09:24 <fasta> ksf: it maybe has to do with the GHC RTS initialization.
03:09:29 <ksf> haskell doesn't segfault.
03:09:36 <fasta> ksf: the library is created by GHC.
03:09:44 <ksf> oh.
03:09:55 <fasta> There is no C code.
03:09:56 <ksf> never did that.
03:10:09 <fasta> I did, but I used a slightly different approach.
03:10:10 <ksf> there's hsplugin to do that kind of stuff
03:10:22 <fasta> Hsplugin has another purpose.
03:10:40 <fasta> (And is deprecated)
03:10:43 <ksf> iirc lambdabot loads her modules as .so
03:11:10 <fasta> ksf: I want to make Haskell functionality available to the C world, not the other way around.
03:11:14 <ksf> @vixen how do you load modules?
03:11:15 <lambdabot> however you want
03:11:59 <ksf> Oh I thought you didn't want to have any C code as you said that there's no C code.
03:12:10 <ksf> (I must be very annoying to talk to)
03:12:18 <Twey> Heheh.
03:13:06 <ksf> To fix your program, stand on one leg and recite the original lambda papers in pig-latin.
03:13:40 * Twey laughs.
03:15:34 <Peaker> jmcarthur, you there?
03:16:07 <Peaker> jmcarthur, the SDL bindings have a bug that reads middle-mouse-clicked as left-clicked, rather than left-clicked.  I sent a fix to Lemmih, and its in the darcs repo, but he didn't upload it to hackage, apparently
03:39:20 <hackagebot> curry-frontend 0.2.7 - Compile the functional logic language Curry to several intermediate formats (BerndBrassel)
03:41:36 <ksf> someone should code up a type-level finger tree to jumpstart the age of type hackery
03:43:07 <quicksilver> win 26
03:43:27 * Saizan dreams of the type-level singularity
03:44:18 * ksf dreams of first-class type funs
03:44:28 <ivanm> Saizan: do you get sucked into it?
03:45:31 * int-e dreams of computers just doing what they're told. :)
03:46:08 <medfly> sudo make me a sandwich
03:46:12 <ksf> first-class finite maps would be a start.
03:46:19 <int-e> without the need to describe what you want unambiguously and in excruciating detail.
03:46:20 <Saizan> int-e: but at the type level!
03:46:25 <ksf> I think they're quite doable.
03:46:41 <dolio> int-e: What fun is that?
03:46:42 <int-e> Saizan: inferred, please.
03:47:22 <int-e> dolio: it would get more things done is all. you could still have fun, like people are still having fun writing programs for C64 today. :)
03:47:31 <dolio> :)
03:47:43 <int-e> I also think this dream is completely unrealistic.
03:47:56 <Saizan> but the fun is in designing languages, not writing programs.
03:48:15 <ksf> a computer that could do that would be sentient, i.e. get a wage.
03:49:13 <ksf> after all, somehow it's got to pay its energy bills.
03:49:41 <int-e> Heh, computers in SciFi novels hardly ever get payed. They just feel underappreciarted and turn evil.
03:49:46 <int-e> -r
03:50:13 <int-e> and "paid". english is hard :)
03:50:36 <ksf> cf. futurama
03:51:17 * ksf tended to read "futamura" as "futurama", in the beginnig.
03:51:45 <fasta> ksf: I would vote to change it to the futurama projection.
03:55:01 <SamB_XP> hehehe
03:58:29 <EvilMachine> Saizan: isn‚Äôt designing languages and writing programs actually the same? because every program consists of a set of modules, which communicate trough protocols in a data format that could be called a language. and every module is compiling those to form the output data format. recursively down to atomar functions.
03:59:59 <Saizan> if you're saying that some programs end up defining some kind of interpreter for a little language i tend to agree
04:00:35 <ksf> using either lisp or futurama it all reduces to a zap.
04:00:36 <EvilMachine> no, i mean that every function is a kind of tiny compiler
04:00:57 <ksf> a compiler is just a function like any other.
04:01:03 <ksf> an interpreter, too.
04:01:12 <ksf> (blissfully ignoring any operational aspects)
04:01:44 <EvilMachine> they all just transform data from one form to another one.
04:02:43 <ksf> there's an ancient experimental lisp compiler that reduces an arbitrary deep nesting of interpreters into a single one
04:02:47 <ksf> forgot it's name.
04:03:24 <ksf> (ancient in the sense that you will neither be able to run it on a modern lisp, or understand it if you know modern lisp)
04:04:23 <Saizan> well, not all data is meant to be code
04:04:58 <Saizan> in cases like these intentions are important, imo
04:06:33 <ksf> but that's just because our current file systems don't support frp, properly.
04:06:44 <ksf> erm.
04:06:58 <ksf> the file systems do, the compilers don't.
04:47:18 <bsdemon> Why am I got wthis error? Types are same... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10780#a10780
04:48:42 <trzkril> bsdemon: as it says, it loaded parsec-2.1.0.1, but it is expecting a type from parsec-2.1.0.0
04:48:54 <ivanm> looks like the dreaded diamond dependency problem
04:49:00 <ivanm> bsdemon: what does "ghc-pkg check" say?
04:49:13 <ivanm> if it has problems, then you need to rebuild those packages
04:49:55 <bsdemon> Yes, I have problems
04:52:11 <bsdemon> thanks
04:53:35 <Saizan> you might just need to rm the .hi files in your source tree, or :set -package parsec-2.1.0.0
05:10:30 --- mode: irc.freenode.net set +o ChanServ
05:11:11 <bsdemon> Saizan: I made some mistakes: my gentoo trying to manage haskell package in wrong way :(
05:11:35 <ivanm> bsdemon: what is this?
05:11:44 <ivanm> all the split/join messages made me lose the scrollback...
05:12:00 <ivanm> but if you have a gentoo problem, then there's #gentoo-haskell for your querying pleasure...
05:12:23 <bsdemon> I have installed the same packages with gentoo portage and cabal install both...
05:12:30 <bsdemon> there are no quesitons,
05:12:48 <ivanm> well, that was silly ;-)
05:18:44 <fxr> when building ghc head why we're using 32m heap instead of 64m, and why it speeds up the build process?
05:21:27 <Lemmih> fxr: Using more memory means less GC time.
05:22:04 <fxr> oh I see
05:22:54 <Saizan> but 32 < 64 ?
05:23:05 <Lemmih> > 32 < 64
05:23:06 <lambdabot>   True
05:23:13 <Lemmih> Saizan: it seems so.
05:23:25 <SamB_XP> hmm, does anyone know of any Haskell code for dealing with GCCXML output?
05:23:27 <ivanm> Lemmih: lambdabot really does come in handy, doesn't she... ;-)
05:23:53 <Lemmih> ivanm: Yes, I wonder how people got by without her.
05:24:31 <SamB_XP> Lemmih: well, we use preflex sometimes, sometimes we run a clone
05:24:44 <SamB_XP> oh, and lunabot
05:25:10 <ivanm> Lemmih: btw, what was previous versions of LHC using graphviz for?
05:25:47 <Lemmih> ivanm: For displaying module dependencies.
05:26:06 <Saizan> fxr was saying that they use 32m of heap instead of 64m, which is less memory, and you said that more memory means less GC time, or did i just stopped being able to read english?
05:27:02 <ivanm> Lemmih: and you didn't need it anymore?
05:27:15 <ivanm> or just removing unneeded deps for the "stable" release?
05:27:29 <Lemmih> Saizan: I thought he asked why using 32m is faster than nothing at all. And then why not use 64m.
05:28:04 <fxr> right I just wanted to know the difference between using 32m and 64m
05:28:19 <Lemmih> ivanm: No, it was a leftover from JHC. The codebase was completely rewritten to its present glory.
05:28:46 <ivanm> *nod*
05:29:16 <ivanm> with its present glory removing possibly the greatest/best library/app using graphviz that I dind't write? :(
05:30:36 <Lemmih> Ah, you're the author of graphviz package?
05:31:01 <ivanm> new maintainer
05:31:10 <SamB_XP> it's a nice package ;-)
05:31:16 <ivanm> and graphviz has also been (almost) completely rewritten to its present glory :p
05:31:19 <ivanm> SamB_XP: \o/
05:31:25 <Lemmih> I seem to remember that it wasn't as easy to use as I had hoped.
05:31:41 <ivanm> in what sense?
05:31:49 <SamB_XP> Lemmih: I thought I was the one as was using it?
05:32:02 <ivanm> I note that it doesn't specify a version in the cabal file, so I'm wondering which version it was built against
05:32:14 <ivanm> since I've changed the API in a few fundamental ways...
05:32:45 <SamB_XP> ivanm: well, I'm thinking whichever version JHC can be built against would be it ;-P
05:33:02 <ivanm> SamB_XP: heh
05:33:04 <SamB_XP> because whatever usage was made of it has surely been merged into JHC
05:33:32 <SamB_XP> if the code wasn't written there in the first place
05:33:46 <zygoilid> if i define a class in one module, and only export some of the methods, when i define an instance in another module can i implement methods which weren't exported?
05:33:49 <ivanm> yeah, JHC has no non-base deps now...
05:34:15 <SamB_XP> (surprisingly, it is possible to merge patches between some seperately-converted-to-darcs2 repos without much trouble, despite what the documentation says!)
05:34:23 <ivanm> zygoilid: don't think so
05:34:39 <SamB_XP> ivanm: JHC doesn't have non-base deps anymore???
05:34:40 <SamB_XP> what?
05:34:53 <SamB_XP> surely it uses collections!
05:35:09 <ivanm> SamB_XP: not according to hackage
05:35:17 <ivanm> and it has no maintainer apparently...
05:35:20 <SamB_XP> oh, hackage, bah
05:35:23 <ivanm> heh
05:35:39 <SamB_XP> JHC proper isn't cabalized, you know
05:35:54 <ivanm> SamB_XP: :o
05:35:58 <ivanm> then what's that on hackage?
05:36:11 <SamB_XP> some gwernization, I think?
05:36:21 <ivanm> heh
05:36:36 <Lemmih> ivanm: It seemed hard to generate graphs on a whim. It forced you to deal with a lot of configuration that usually isn't important.
05:36:54 <ivanm> Lemmih: you were creating the DotGraphs by hand?
05:36:59 <ivanm> then yes, atm that can be a pain
05:36:59 <SamB_XP> Lemmih: hmm?
05:37:31 <ivanm> Cale and I started working a generic graph class; the eventual goal is that if your type is an instance of the class, then you can create DotGraphs from it (like you can with FGL now)
05:37:48 <SamB_XP> oh, right!
05:38:14 <SamB_XP> I believe my code converted to an FGL graph first ...
05:38:41 <SamB_XP> from (ugh!) Data.Graph, I think :-(
05:38:42 <ivanm> ahhh
05:38:59 <SamB_XP> I hates Data.Graph :-(
05:39:10 <ivanm> yeah, it needs to go
05:39:23 <SamB_XP> it has the dumbest API and doesn't deserve that module name
05:39:53 <ivanm> SamB_XP: Cale and I want to replace it ;-)
05:40:12 <SamB_XP> well, first get it itself expelled from whatever package it lies in
05:40:17 <ivanm> containers
05:40:19 <SamB_XP> then leave the path empty for a while
05:40:25 <ivanm> IIRC, that's why containers needs arrays
05:40:39 <SamB_XP> oh?
05:40:49 <SamB_XP> that's the only reason it needs arrays, huh?
05:41:08 <ivanm> I think so...
05:41:22 <ivanm> I don't think Map, IntMap, Set or Sequence needs arrays
05:42:44 <ivanm> SamB_XP: I've gone through all of them, and only Data.Graph imports array modules
05:46:09 <bsdemon> what do you think of #1185 GHC ticket? It is about using I/O after forking. I think it is one of obstacles to widespread haskell usage :( For example, I can write unix daemons.
05:46:22 <bsdemon> can -> can't
05:51:14 <PeakerWork> Lemmih: you still there?  Can you upload the new hssdl to hackage?
05:51:24 <PeakerWork> Lemmih: the mouse bugfix is in darcs but not in hackage
05:55:57 <Lemmih> PeakerWork: Done.
05:56:01 <hackagebot> SDL 0.5.6 - Binding to libSDL (DavidHimmelstrup)
05:56:26 <serhat> Enter text here...hello everybody
05:56:41 <benmachine> hello serhat
05:56:47 <PeakerWork> Lemmih: thanks
05:58:50 <kpreid> serhat privmsged me "hello". he left before I got around to replying after figuring out what the situation is
05:59:21 <ivanm> there's a situation? :o
05:59:45 <engineerhandsome> hi
05:59:50 <engineerhandsome> hello
06:00:02 <serhat> hi
06:00:18 <ivanm> ummmm.... is it a coincidence that engineerhandsome and serhat have the same IP address?
06:00:40 <ivanm> and /whois says they're both called "chat"
06:00:42 <dikini> :)
06:02:08 * dikini remembers "asl"
06:04:45 <engineerhandsome> hello
06:05:20 * ivanm sighs, gives up, and waves aimlessly in engineerhandsome's general direction
06:05:43 <lurkymclurkleton> engineerhandsome: hello
06:05:50 <ivanm> kpreid: OK, he privmsged me as well...
06:06:19 <Botje> lurkymclurkleton: i love your nickname :)
06:06:23 <dikini> ivanm: can we ask lambdabot to chat with it
06:06:44 <engineerhandsome> Enter text here...hello
06:06:52 <engineerhandsome> hi
06:07:13 <ivanm> engineerhandsome: get over it
06:07:18 <ivanm> @where ops
06:07:18 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
06:07:34 <ivanm> @vixen is engineerhandsome aka serhat being annoying?
06:07:35 <lambdabot> good question
06:07:37 <ivanm> heh
06:07:41 --- mode: ChanServ set +o allbery_b
06:07:44 --- mode: ChanServ set +o sjanssen
06:07:50 <engineerhandsome> you are sily
06:07:53 --- mode: ChanServ set +o dcoutts
06:08:17 * ivanm wonders if some ops have automatic scripts that give them chanop status if "@where ops" is detected...
06:08:31 <allbery_b> not I
06:08:34 <sjanssen> ivanm: so what's the problem?
06:08:37 <ivanm> engineerhandsome: do you actually have a question or something to say rather than connecting, saying some greeting and then disconnecting?
06:08:40 * EvilTerran was more wondering if engineerhandsome could pass the turing test
06:08:44 <ivanm> EvilTerran: heh
06:08:48 <dikini> won't
06:09:00 <ToRA> are there any fclabels people around?
06:09:03 <ivanm> sjanssen: you just chanop'd without checking? :p
06:09:23 <ivanm> sjanssen: serhat aka engineerhandsome is exhibiting strange behaviour; possibly a rogue bot
06:10:17 * dikini uhm, bots gone rogue and want to know my particulars!!! the matrix is coming
06:10:25 * allbery_b thinks he'll leave it to the experts, since he's not sure he's going to be able to stay awake much longer
06:10:32 --- mode: allbery_b set -o allbery_b
06:10:45 --- mode: ChanServ set -o dcoutts
06:10:48 <ivanm> allbery_b: so you're saying you're not an expert?
06:11:17 <allbery_b> not when I'm this tired
06:11:27 <ivanm> heh
06:11:32 <allbery_b> (I completely failed to sleep last night.)
06:11:35 <ivanm> dikini: heh
06:11:55 * ivanm sneaks up behind allbery_b and knocks him out with a handy-looking cushioned bat
06:12:24 <engineerhandsome> hello 0131 am hasan
06:12:28 --- mode: ChanServ set +o dcoutts
06:12:31 --- kick: engineerhandsome was kicked by dcoutts (dcoutts)
06:12:36 <ivanm> \o/
06:13:25 <Axman6> ivanm: i am around now
06:13:40 <ivanm> Axman6: now I've just go to remember what I was going to ask you... :s
06:13:47 <Axman6> heh
06:13:51 --- mode: ChanServ set -o dcoutts
06:13:58 <ivanm> Axman6: with ACTION, is it basically manual route mapping?
06:14:12 <Axman6> 'manual route mapping'?
06:14:53 <ivanm> I want to know how to go from A to B; first I find all bus routes that look like they go close to A, find which one actually goes near A and when, then try to find where I can get off to get another bus, etc.
06:15:09 <ivanm> rather than something like http://jp.translink.com.au/
06:16:15 <Axman6> ah, yeah. they used to have an automatic route finder, but then they updated the routes a year or two ago, and haven't made a new one (things keep changing, and they're going to be changing again soon)
06:16:54 <ivanm> yay :s
06:17:12 <ivanm> so, do you know how easy/difficult it is to bus to/from bruce to ANU?
06:17:29 <Axman6> but they're pretty easy to figure out. you use any of the 300's (300, 311-319 i think) to get between the main bus stations, and then catch the bus you need from there, if you need to
06:17:32 <ivanm> because the apartment I was looking at at the waldorf was sold (despite the listing still being up...)
06:17:51 <Axman6> ANU's right near the city interchange, so it should be very easy
06:17:59 <Axman6> lame :(
06:19:45 <ivanm> so there's a couple of places in bruce (including one which they haven't bothered to say when it will be built, but you can buy now...), a few in south canberra, and then most of them are out holt, etc. way
06:19:54 <ivanm> (for places <$400k with 2 bedrooms)
06:20:09 <ivanm> oh, a couple in reid, which I think would be the best location
06:22:02 <saml> how can I go fullscreen in glut?
06:22:17 <saml> after 20 minutes, for example
06:24:32 <ivanm> Axman6: anyway, turns out we know someone who works in real estate in canberra, so I'm hoping for a good deal :p
06:24:48 <Axman6> sounds good. who do they work for?
06:24:53 <ivanm> collins IIRC
06:25:07 <Axman6> never heard of them
06:25:39 <Axman6> (and i've heard of quite a few canberra real estate agents, my parents used to look at homes all the time)
06:26:28 --- mode: ChanServ set -o sjanssen
06:26:41 <ivanm> anyway, time to become unconscious for a while
06:26:50 <dcolish> i'm having real issues understanding what monomorphism means: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10782#a10782
06:27:50 <quicksilver> dcolish: monomorphism is the absence of polymorphism.
06:28:00 <quicksilver> dcolish: "Int -> Int" is monomorphic
06:28:02 <Axman6> obviously
06:28:06 <Axman6> >_>
06:28:10 <quicksilver> dcolish: forall a . Num a => a -> a is polymorphic
06:28:11 <FunctorSalad> to add to the confusion, it has a totally different meaning in cat theory
06:28:25 <FunctorSalad> (there it means "left-cancellable")
06:28:50 <quicksilver> dcolish: the monomorphism restriction is that a "simple value" like your "tupZ" must be monomorphic if not explicitly annotated.
06:29:09 <quicksilver> dcolish: you can always explicitly annotate things if you want hte polymorphic type
06:29:27 <quicksilver> however, that type is not very useful - no type is both Integral and RealFrac
06:29:38 <FunctorSalad> heh
06:29:44 <FunctorSalad> finite fields?
06:29:49 <dcolish> right, i vim haskellmode autogenerated that
06:29:58 <FunctorSalad> @src RealFrac
06:29:59 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
06:29:59 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
06:29:59 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
06:30:13 <FunctorSalad> nevermind thought it was the class for division
06:30:14 <benmachine> dcolish: either use ** with / or ^ with div
06:30:15 <quicksilver> you probably want (/2) . fromIntegral . (^2)
06:30:24 <ski> @src Fractional
06:30:24 <lambdabot> class  (Num a) => Fractional a  where
06:30:24 <lambdabot>     (/)             :: a -> a -> a
06:30:24 <lambdabot>     recip           :: a -> a
06:30:24 <lambdabot>     fromRational    :: Rational -> a
06:30:27 <benmachine> or that
06:30:29 <FunctorSalad> thx ski
06:30:51 <ski> (so it was a subclass of one requiring division)
06:31:02 <quicksilver> or just (`div` 2)
06:31:09 <quicksilver> instead of "floor . (/2)"
06:31:19 <quicksilver> > floor . (/2) $ 5
06:31:20 <lambdabot>   2
06:31:26 <ski> @type floor . (/2)
06:31:27 <quicksilver> > (`div` 2) $ 5
06:31:27 <lambdabot> forall b a. (RealFrac a, Integral b) => a -> b
06:31:28 <lambdabot>   2
06:31:28 <dcolish> ah excelletn
06:31:32 <ski> @type (`div` 2)
06:31:32 <lambdabot> forall a. (Integral a) => a -> a
06:31:40 * dcolish no coffee yet
06:32:05 <gh_> hi, is there a way to enable ghc to handle function declarations with different number of arguments ? for instance : calc True = max ; calc False _ = 0 .  If I do this, ghc refuses and says "Equations for `calc' have different numbers of arguments".
06:32:42 <FunctorSalad> not that I know of, but you can always accomplish it with lamda
06:32:43 <benmachine> gh_: the solution is to define calc False as const 0
06:32:45 <FunctorSalad> +b
06:32:55 <benmachine> or indeed as calc False = \_ -> 0
06:33:06 <gh_> i want to do that not for this calc example, but for a bigger situation in my source code
06:33:19 <gh_> where i'd like to save 2 arguments on 3 from time to time
06:33:29 <benmachine> well, you can't
06:33:30 <benmachine> sorry
06:33:38 <benmachine> you have to use lambdas and/or case
06:33:51 <gh_> benmachine, lambdas.. i should try
06:33:54 <benmachine> which can do everything that equations can do in any case
06:33:58 <FunctorSalad> a good idiom is "f commonArgument = go where go (Just x) = ...; go Nothing = ..."
06:34:14 <FunctorSalad> it's especially useful if go is recursive with the rec call not changing commonArgument
06:34:52 <FunctorSalad> but this was a bit off-topic as I now noticed because that won't get you variable number either o_o
06:34:55 <gh_> FunctorSalad, that's also interesting
06:35:16 <gh_> true, but that can still make my code look smaller
06:35:19 <FunctorSalad> think you triggered me with the "saving arguments" ;)
06:36:23 <dolio> That can be particularly important when commonArgument is a function, because it allows for better inlining and specialization.
06:36:57 <FunctorSalad> not automatic?
06:37:44 <dolio> Well, someone's been working on doing that (static argument transform) automatically, but I don't know if that's enabled, or when it happens.
06:37:52 <FunctorSalad> ok
06:37:55 <dolio> It's not always beneficial.
06:37:59 <ski> `commonArgument' being a pattern of function type ?
06:39:31 <dolio> The heuristic last I heard was to only do it where there is more than one static argument, but that may have changed.
06:40:23 <FunctorSalad> tbh I have no idea how the final asm calls functions in haskell :)
06:40:34 <FunctorSalad> I just gathered that it does its own thing
06:46:29 <mlesniak> Hi, anyone knows a source for "impressive" screenshots of haskell applications (preferably graphic apps, not console based)?
06:46:38 <mlesniak> Found only xmonad and frags
06:46:39 <Tobsan> mlesniak: www.xmonad.org
06:46:41 <Tobsan> oh
06:46:42 <mlesniak> :D
06:46:55 <EvilTerran> might be some nice screens of yi
06:46:57 <Tobsan> well, you could have a look at yi
06:47:10 <Tobsan> It seems it is my destiny to be just one line after...
06:47:23 <EvilTerran> some of the screenshots on that reactive graphics lib's page look quite good
06:47:25 <mlesniak> right, good idea
06:47:34 <EvilTerran> (i forget what it's called this particular second)
06:47:35 <mlesniak> EvilTerran, any further information?
06:47:37 <mlesniak> :d
06:47:56 <FunctorSalad> full-page type error message? ;)
06:48:04 <EvilTerran> FieldTrip, that's the one
06:48:05 <FunctorSalad> for some values of 'impressive'
06:49:23 <eevar2> http://www.haskell.org/haskellwiki/Opengl#Projects_using_the_OpenGL_bindings
06:49:33 <hackagebot> KiCS 0.8.9 - A compiler from Curry to Haskell (BerndBrassel)
06:49:34 <eevar2> ^^ might have something
06:49:45 <mlesniak> eevar, right, good idea, thanks!
07:07:14 <gh_> thanks!
07:37:00 <harrison> aha. found what was messing up my prime number generator. Int rollover.
07:37:01 <prigaux> ddd/set osd_DISPLAY localhost:10.0
07:37:16 <prigaux> (argh, sorry)
07:37:29 <Jafet> Int rollover in Haskell? Sounds exciting
07:38:03 * ubuntu-nathan is learning Haskell with the book Real World Haskell
07:38:05 * EvilTerran prefers to use Integer until he has numbers telling him it's too slow
07:38:06 <ubuntu-nathan> ;)
07:38:10 <Beelsebob> oh dear, OcaML and Scala have overtaken us againhttp://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all&box=1
07:38:37 <burp> go and optimize something
07:40:11 <zygoilid> change an Integer to Int ;-)
07:42:16 <ubuntu-nathan> someone can help me with this: http://tinyurl.com/yfs3bqk ?
07:42:19 <ubuntu-nathan> thanks
07:42:34 <quicksilver> emacs.
07:42:55 <ubuntu-nathan> hum
07:43:03 <ubuntu-nathan> i not a fan of emacs
07:43:08 <ubuntu-nathan> sorry :(
07:43:19 <quicksilver> you asked what the best editor was. that is the answer.
07:43:25 <quicksilver> you didn't ask what editors you are a fan of
07:43:27 <quicksilver> (I don't know?)
07:43:31 <ubuntu-nathan> ok
07:43:32 <quicksilver> :)
07:43:40 <ubuntu-nathan> ;)
07:44:07 <FunctorSalad> speaking of emacs, is there some new repository for haskell-mode or something
07:44:08 <FunctorSalad> ?
07:44:18 <FunctorSalad> the one I know hasn't been updated in a long time
07:44:30 <burp> emacs is the best editor?
07:45:12 <benmachine> opinions vary
07:45:32 <benmachine> from correct opinions i.e. mine to other ones
07:45:39 <FunctorSalad> he was being facetious. please no editor flamewar
07:46:01 <burp> you ruined it ;(
07:46:28 <FunctorSalad> I hadn't clicked the link
07:46:39 <FunctorSalad> he's actually asking for one? :o
07:46:40 <harrison> Jafet:  this is what was broken. it works now because it's using Integers, but with Ints, it misses 48623, and then some others a while later. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4387#a4387
07:46:51 <burp> he's looking for a windows editor
07:47:29 <trzkril> the W32 port of emacs 23 was acceptable
07:47:52 <FunctorSalad> someone should reply "emacs on linux" ;)
07:48:08 * EvilTerran uses SciTE when on windows
07:48:17 <harrison> i have been coding in wordpad when i'm on windows :V
07:48:30 <byorgey> @remember benmachine [on the best editor] opinions vary.  from correct opinions i.e. mine to other ones.
07:48:30 <lambdabot> Good to know.
07:48:36 <EvilTerran> (while idly pondering writing my own)
07:48:55 <FunctorSalad> Beelsebob: how's that possible? :(
07:50:49 <fxr> hmm cabal suddenly broken, it gives "cabal: : openFile: does not exist (No such file or directory)". Any ideas?
07:51:30 <byorgey> fxr: what command were you trying to run when that happened?
07:51:31 <oteren> hello, I'm trying to figure out how to contruct a self declared data type recursively
07:51:48 <oteren> data Expr = Var Char | Tall Int | Sum Expr Expr
07:51:49 <oteren> etc
07:52:07 <oteren> not sure how i actually use that, the only recursive example out there is the Tree from the haskellwiki
07:52:17 <oteren> been googling my ass for quite some hours now
07:53:45 <skorpan> oteren: did you find it?
07:53:47 <byorgey> oteren: well, for example, one value of type Expr would be   Sum (Sum (Tall 3) (Var 'c')) (Tall 6)
07:54:01 <oteren> i'm building expressions from a String
07:54:09 <oteren> got a grammar i'm using (which the data type is defined from)
07:54:27 <byorgey> oteren: and you can write functions that work over Exprs by pattern-matching, and making a recursive call in the Sum case.
07:54:37 <oteren> ok
07:54:46 <byorgey> oteren: oh, so are you trying to build a parser for Expr?
07:54:48 <oteren> yes
07:55:06 <oteren> i'm en route making the actual parsing part
07:55:12 <oteren> just cant figure out how to build the AST properly
07:55:19 <oteren> or rather,how to recursively use Expr
07:55:39 <byorgey> oteren: can you give an example of what you are having trouble with?  I'm not quite sure what you mean.
07:55:49 <oteren> lets see here, i'll pastebin what i have so far
07:55:54 <oteren> lemme add some comments so you see what i ask
07:55:58 <oteren> gimme 2min :)
07:56:00 <byorgey> ok.
07:57:42 <cizra> Hi. Does ghc link standard Haskell lists singly or doubly?
07:58:11 <int-e> singly
07:58:20 <cizra> Thanks.
07:58:21 <fasta> How do I pass a C enum to a Haskell function?
07:58:37 <fasta> I am using c2hs.
07:58:39 <int-e> otherwise sharing tails of lists wouldn't work
07:58:39 <Jafet> Cons lists are singly linked, and non-cons lists don't exist in functional languages
07:58:39 <int-e> i.e. a simple foo (a:xs) = b:xs  would have to copy the list.
08:00:09 <cizra> int-e: Hmmm. I see why it should.
08:00:23 <int-e> you /can/ define a doubly linked list, data DL a = Nil | Node (DL a) a (DL a) - but they are a pain to create and manipulate.
08:00:23 <byorgey> cizra: also, in fact you can see that from the definition of lists (using [] and (:) ).  what you see is what you get; ghc doesn't do any magic rewiring of data structures under the hood.
08:00:57 <zygoilid> data STLink s a = STLink { prev :: STRef s (STLink s a), val :: a, next :: STRef s (STLink s a) }; newtype STList s a = STList (STRef s (Maybe (STLink s a)))
08:01:14 <int-e> or you can cop out and use pointers, i.e. data DL a = ... basically what zygoilid just did, although I had IO in mind.
08:01:36 <oteren> byorgey: http://pastebin.com/m7b6b2369
08:01:37 <int-e> (for simplicity. ST is better from a technical perspective.)
08:01:41 <FunctorSalad> or just use the list zipper :)
08:01:55 <hackagebot> brians-brain 0.0.1 - A Haskell implementation of the Brian's Brain cellular automaton (WillDonnelly)
08:01:56 <FunctorSalad> which is just a pair of lists actually
08:02:28 <cizra> What does ST stand for there?
08:02:40 <Gracenotes> state, pretty sure
08:02:52 <cizra> hm, OK
08:02:57 <fasta> State Thread
08:03:02 <oteren> byorgey: the main thing i'm trying to figure out, is how to actually build an expression recursively
08:03:20 <oteren> dont understand quite how to rebuild / 'get it' when you reach the end of the input
08:04:56 <byorgey> oteren: well, say the first character is a '+'.  the general idea is that you would then discard a '(', recursively call parseExpr, discard a ',', recursively call parseExpr again, discard a ')', then finally put together the results from the two recursive calls using the Sum constructor.
08:05:44 <oteren> aha
08:05:48 <byorgey> so something like   x == '+' = Sum e1 e2  where (e1,xs') = parseExpr (tail xs); (e2,xs'') = parseExpr (tail xs') ... and so on
08:06:45 <oteren> one other thing
08:06:52 <oteren> the Expr type
08:07:02 <byorgey> oteren: however, once you get this working, I would strongly recommend learning how to use a parser combinator library such as parsec.  It makes this kind of thing a LOT easier. =)
08:07:37 <byorgey> oh, sorry, that should have been  (Sum e1 e2, xs'''') or something like that =)
08:07:43 <byorgey> oteren: yes?
08:08:06 <oteren> i'm also supposed to be able to have..
08:08:11 <oteren> recursive expressions
08:08:23 <oteren> like saying Y = X*X in Y+Y
08:08:31 <oteren> how would that look in my data declaration?
08:08:55 <byorgey> oteren: well, you just need a 'Let' constructor
08:08:58 <oteren> meaning that a Var can also be an expression
08:09:11 <byorgey> a Var already is an expression. =)
08:09:14 <oteren> hehe
08:09:28 <byorgey> something like   Let Char Expr Expr
08:09:42 <byorgey> oteren: also, what is the 'Expr Expr' case for?  it seems useless.
08:09:48 <oteren> hehe
08:09:53 <oteren> that was my attempt at what you just wrote :D
08:10:01 <byorgey> hehe, I see.
08:10:13 <oteren> i've only been doing haskell for a couple of weeks
08:10:15 <oteren> starting to like it
08:10:25 <byorgey> oteren: well, the way to think about it is: what are the components of an expression like  'Y = X*X in Y+Y'?
08:10:28 <oteren> but after doing imperative for a looong time, it kinks my head
08:10:43 <byorgey> there are three components: the name of the variable being defined, the expression it is defined as, and the body after the 'in'
08:10:51 <byorgey> oteren: yes, that sounds normal =)
08:11:03 <oteren> at first i was thinking "how hard can it be"
08:11:12 <oteren> starting to come to the conclusion of "very"
08:11:12 <oteren> hehe
08:12:02 <Baughn> oteren: Well, only the first time. :P
08:12:09 <oteren> anyways, thanks for the help :)
08:12:21 <oteren> gonna fiddle some more
08:12:34 <byorgey> oteren: sure, anytime =)
08:12:36 <byorgey> enjoy fiddling
08:12:46 <Baughn> oteren: If you want to look at a /complex/ syntax, have a look at the data-types in haskell-src. But don't try writing a haskell parser yourself. It won't work. :)
08:14:00 <Baughn> oteren: Verily, specifically http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.3/doc/html/Language-Haskell-Syntax.html
08:14:28 <oteren> thats a lot of blue text
08:14:29 <oteren> :p
08:15:51 <paolino> @hoogle :: [a] -> Int -> Maybe a
08:15:51 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:15:51 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:15:51 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
08:15:54 <fasta> If I want to do a foreign export of a function which takes as a first argument the Haskell representation of a C enum, then what is the type of this Haskell representation? The FFI doesn't say anything about this.
08:16:00 <hackagebot> KiCS 0.9.0 - A compiler from Curry to Haskell (BerndBrassel)
08:16:23 <paolino> @hoogle :: Int -> [a]  -> Maybe a
08:16:23 <lambdabot> Prelude (!!) :: [a] -> Int -> a
08:16:24 <lambdabot> Data.List (!!) :: [a] -> Int -> a
08:16:24 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
08:16:59 <quicksilver> fasta: in plain C, using plain FFI, it is CInt AFAIK
08:17:19 <quicksilver> fasta: (C++ reserves the right to use other types for enums, and I think a recent C standard might do so?)
08:17:26 <quicksilver> btu in practice, they are CInts.
08:17:37 <quicksilver> It's the kind of thing you might hope c2hs would handle for you
08:18:55 <paolino> mhh, should I have to implement a (!!) which doesn't error or it exists ?
08:19:13 <fasta> quicksilver: in the library which you are not supposed to use there is cToEnum, but you are not supposed to use that.
08:19:42 * fasta should not continue to write sentences after a minute. ;)
08:19:46 <quicksilver> ;)
08:20:09 <quicksilver> paolino: listToMaybe . drop n
08:20:34 <paolino> :)
08:20:39 <quicksilver> > let xs !!! n = listToMaybe . drop n $ xs in [1,2,3] !!! 4
08:20:40 <lambdabot>   Nothing
08:20:57 <slxix> > ['z','x' .. 'A']
08:20:58 <lambdabot>   "zxvtrpnljhfdb`^\\ZXVTRPNLJHFDB"
08:25:39 <Taejo> my end key is producing "F" and delete "3~" in ghci (6.10.4, Ubuntu 9.04)
08:44:21 <ClaudiusMaximus> latest video output from my Haskell >> http://claudiusmaximus.goto10.org/cm/2009-10-15_reflex_preview.html
08:46:12 <quicksilver> ClaudiusMaximus: nice
08:46:47 <fasta> ClaudiusMaximus: looks cool, but it also looks like you first took some LSD ;)
08:48:53 <fasta> And what's a "{p,q,r} specification of a 4D polytope"? I know the 4D polytope part.
08:48:56 <FunctorSalad> add some green too
08:49:00 <FunctorSalad> ;)
08:49:38 <byorgey> ClaudiusMaximus: wow, fantastically cool.  Maybe you'd consider writing an article about it in the Monad.Reader? =)
08:49:59 <ClaudiusMaximus> fasta: it's the notation that Coxeter uses in his book
08:50:44 <quicksilver> fasta: http://en.wikipedia.org/wiki/Schlafli_symbol
08:50:46 <ClaudiusMaximus> byorgey: i shall consider it, no promises yet
08:50:53 <FunctorSalad> nevermind me I had only seen the picture not the video
08:51:24 <FunctorSalad> I have no hope of understanding projections of 4d items...
08:51:30 <byorgey> ClaudiusMaximus: that's fine, no promises necessary at this point
08:51:42 <fasta> quicksilver: ah, nice. I didn't even know there was terminlogy for that.
08:51:48 <FunctorSalad> (geometrically of course)
08:51:56 <FunctorSalad> :)
08:51:57 <fasta> terminology*
08:52:06 <dcolish> how can types be resolved when comparing the value of sqrt with an Integral?
08:52:46 <Baughn> fromIntegral?
08:52:59 <FunctorSalad> > sqrt 10 > fromIntegral 3
08:52:59 <Baughn> > fromIntegral (2 :: Int) == sqrt 4
08:53:00 <lambdabot>   True
08:53:00 <lambdabot>   True
08:53:03 <FunctorSalad> :o
08:53:20 <quicksilver> > floor (sqrt 10) > (3 :: Int)
08:53:20 <benmachine> getting an integral to a float is fromIntegral, going the other way you can use floor/ceiling/round
08:53:21 <lambdabot>   False
08:53:55 <FunctorSalad> hmm floor left adjoint to fromIntegral? ;o
08:54:11 <dcolish> i am doing x /= sqrt n
08:54:20 <FunctorSalad> or right
08:54:30 <dcolish> so using (fromIntegral x) /= sqrt.fromIntegral n
08:54:35 <dcolish> that works ok
08:54:45 <oteren> byorgey: you wrote xs' and xs''
08:54:48 <oteren> what does this imply?
08:54:57 <benmachine> dcolish: n is Integral?
08:55:09 <benmachine> dcolish: have you considered x*x /= n?
08:55:14 <dcolish> Integer actually
08:55:19 <FunctorSalad> (x <= floor y) <=> (fromIntegral x <= y)
08:55:40 <dcolish> floor dumps the decimals, which i need in this case
08:55:44 <byorgey> oteren: nothing special, it's just a common convention to use x' as the name for something which is sort of a 'modified version' of x
08:55:57 <oteren> aha
08:56:06 <byorgey> oteren: in this case I used xs' as the name for the input left over after parsing something from the beginning of xs
08:56:09 <sproingie> see Haskell'
08:56:20 <byorgey> and then xs'' is what is left over after parsing something from the beginning of xs'', and so on.
08:56:26 <dcolish> and i wanted sqrt because this is used to help me with factoring
08:57:01 <byorgey> oteren: one of the nice things about parser combinator libraries is that they automatically thread the input around like this for you, so you don't have to explicitly deal with it (which can be error-prone and is certainly annoying at least).
08:57:25 <Cale> Might be worth noting that when used in this way, ' is normally pronounced "prime"
08:57:31 <oteren> well, i want to understand this before i start using any kind of libraries :)
08:57:45 <Cale> It's a convention stolen from mathematics
08:58:26 <benmachine> dcolish: factoring?
08:59:14 <fasta> oteren: I understand it as f' being the derivative of f. Then in Haskell foo' is a value derived from foo.
08:59:29 <FunctorSalad> well you can derive *types* in haskell ;)
08:59:49 <Cale> differentiate
08:59:59 <dcolish> benmachine: yes, i want all the factors a number not including its square root
09:00:03 <FunctorSalad> ok
09:00:45 <Cale> (It's a strange English mathematics thing -- seems lots of other languages use equivalents of 'derive')
09:01:10 <benmachine> dcolish: still sounds like you could square both sides of relevant equations
09:01:22 <oteren> yes
09:01:33 <oteren> if its the mathematical definition then i got it
09:01:37 <benmachine> avoiding floating-point values helps avoid bugs
09:01:44 <benmachine> and is probably faster
09:01:56 <dcolish> ah i see what you mean
09:02:23 <Cale> Well, the prime here is not really referring to the derivative in the sense of Calculus.
09:02:24 <sproingie> speaking of Haskell' is Haskell 2010 still on track?
09:03:18 <oteren> ' is really just a tag
09:03:21 <dcolish> benmachine: you're right, that is much simpler
09:03:34 <benmachine> :)
09:03:46 <oteren> in statistics its used to show complements
09:03:52 <oteren> i just thought it meant something really speacial Haskellish
09:03:53 <oteren> :p
09:03:58 <FunctorSalad> Cale: you even get a linear functional ((d/dA) T , A) -> T
09:04:00 <FunctorSalad> ;o
09:07:32 <byorgey> oteren: nope, it's just a normal character you can use to make a name.  In fact you can even have it in the middle of the name =)
09:07:41 <byorgey> > let don't = 3 in don't + 5
09:07:41 <lambdabot>   8
09:07:52 <byorgey> but don't do that ;)
09:08:45 <paolino> @paste
09:08:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:08:53 <oteren> hehe
09:09:56 <paolino> is there a way to avoid explicit recursion on insert function here http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4388#a4388 ?
09:11:13 <paolino> I tried with foldl with no success :-/
09:13:17 <hackagebot> WL500gPLib 0.3.1 - A simple library to access to the WL 500gP router  from the Haskell code (VasylPasternak)
09:14:32 <byorgey> paolino: what is that data type meant to model?
09:14:39 <byorgey> the constructor names don't give much of a clue =P
09:15:14 <byorgey> paolino: it probably corresponds to SOME recursion scheme, but perhaps not a catamorphism.
09:15:26 <paolino> it's a ntree, but I suppose that was not the question
09:15:48 <quicksilver> it doesn't look like one of the natural recursion schemes to me at all
09:16:22 <quicksilver> note that it only calls 'f' recursively in one case
09:16:47 <quicksilver> and in that case, the the first parameter to 'f' (called 't') is something rather fiddly
09:17:20 <hackagebot> WL500gPControl 0.3.1 - A simple command line tools to control the  Asus WL500gP router (VasylPasternak)
09:17:27 <paolino> is it clear what it does ?
09:17:47 <byorgey> paolino: not at all.
09:18:11 <paolino> it goes down a path :: I
09:18:18 <lazni> doctest just says "doctest: Prelude.undefined" for this file http://lazny.tang.la/jbo/samru%27e/xasfi%27e/Namcu.hs
09:18:22 <lazni> what does it mean?
09:18:34 <paolino> collecting values at each node
09:19:06 <paolino> when it reaches the pointed node id adds a new node under it
09:19:26 <paolino> with a value computed from the collected ones
09:19:47 <byorgey> paolino: oh, now I see.
09:19:49 <Cale> lazni: What's doctest?
09:20:26 <lazni> a program that test the function according to comments, like the Namcu.hs file has
09:20:42 <lazni> cabal install doctest
09:21:09 <quicksilver> if you run all those tests by hand do they work?
09:21:13 <byorgey> lazni: well, it means that doctest uses 'undefined' somewhere, which is a bug.
09:21:26 <byorgey> lazni: you should send a bug report to the author of doctest.
09:21:47 <paolino> byorgey: the collection of values down the path preclude the use of foldr , but I could be wrong
09:22:01 <byorgey> oh, or I guess that could happen if one of the tests tries to evaluate an undefined?
09:22:03 <lazni> they work in ghci
09:22:09 <lazni> byorgey: okay
09:22:14 <Cale> In any case, the tests work okay
09:22:20 <quicksilver> yeah, doctest must be broken
09:22:35 <Cale> Switch to quickcheck, I guess ;)
09:22:53 <lazni> doctest is really lightweight, I like that
09:23:01 <byorgey> paolino: yes, it does.  foldr/catamorphisms work by replacing each constructor by a function; by definition the function at each node only has access to information underneath it.
09:23:14 <lazni> Idk how to write Arbitrary lojban
09:23:27 <Cale> You don't need to for any of these tests
09:23:49 <lazni> I'll find out more after this sleep
09:23:56 <paolino> byorgey: can I use a continuation to set the node at the end of the foldr ?
09:24:13 <paolino> when I have all the values ?
09:24:18 <byorgey> paolino: hmm, actually, something like that might work.
09:24:33 <Cale> Since they're just unit tests, they have type Bool, which is already an instance of Testable
09:26:11 <quicksilver> the bug must be in the cade which calls "stripPostfix"
09:26:17 <quicksilver> which is the only use of 'undefined' in the DocTest code
09:26:58 <jkramer> Hi
09:27:19 <byorgey> hi jkramer
09:27:21 <jkramer> I've built a typeclass and I'd like to use it in a data constructor
09:27:24 <paolino> byorgey, just too much for me to guess how :)
09:27:31 <jkramer> I'm not sure what the syntax looks like or if it's even possible
09:27:47 <byorgey> paolino: yeah, I will try playing around with it a bit.  it's certainly not immediately obvious =)
09:27:59 <paolino> thanks
09:28:14 <quicksilver> jkramer: don't.
09:28:32 <quicksilver> (unless what you want is an existential)
09:28:59 <quicksilver> haskell98 doesn't support typeclass constraints on constructors, only on data-types, where they are a misfeature.
09:29:04 <paolino> jkramer: paste the code
09:29:17 <quicksilver> GHC supports them on constructors (if you use the GADT extension, and use the GADT syntax)
09:29:24 <byorgey> paolino: I wonder if it would be more cleanly expressed in terms of a zipper.
09:29:35 <quicksilver> but even then, they are almost always a poor idea.
09:29:41 <engineerhandsome> Enter text here...hello
09:29:46 <zygoilid> lazni: the problem looks to be something like the module name and the file path don't match
09:29:51 <byorgey> paolino: then you wouldn't need subst, you just walk down the tree taking it apart, and then replace as you go back up.
09:30:01 <jkramer> I want to do something like this: instance MyClass Foo where ..... \ data Bar = Baz a | Quux a (where an instance of MyClass)
09:30:21 <quicksilver> you don't want an "a" parameter in the type Bar?
09:30:26 <quicksilver> you want it to be hidden what "a" it is?
09:30:32 <quicksilver> in that case, you *do* want an existential.
09:30:39 <paolino> byorgey : that will explicit the going down and up , right ?
09:30:43 <jkramer> What's an existential?
09:30:44 <engineerhandsome> hi
09:30:48 <quicksilver> http://www.haskell.org/haskellwiki/Existential_type
09:31:01 <zygoilid> lazni: put 'module Namcu where' at the top of the file and maybe it'll work
09:31:11 <quicksilver> an existential is a type which encapsulates something of type a, but you don't know whaty a.
09:31:12 <byorgey> paolino: it might be possible to express it as a hylomorphism with a tree zipper as the intermediate structure.
09:31:24 <byorgey> if so it would be nifty =)
09:31:52 <zygoilid> seems a bit shameful that DocTest uses undefined rather than a useful error message in this case :(
09:32:08 <byorgey> paolino: also, why have separate constructors F and N?  why not just let  N x []  represent  F x ?
09:32:28 <jkramer> quicksilver: Thanks, reading now :)
09:32:30 <paolino> no reason really
09:42:47 <dcolish> is there a way to make a list of every digit in a number without changing it to [Char]?
09:43:04 <opqdonut> sure, repeatedly take mod 10 and divide by 10
09:43:18 <opqdonut> there is an unfold-based oneliner for that floating around
09:43:43 <dcolish> i dont quite follow how that would work?
09:44:08 <lpsmith> (`mod` 10)  gets you the last digit
09:44:22 <lpsmith> (`div` 10)  removes the last digit
09:44:31 <dcolish> ah
09:44:50 <lpsmith> >  34254 `mod` 10
09:44:51 <lambdabot>   4
09:44:54 <lpsmith> >  34254 `div` 10
09:44:55 <lambdabot>   3425
09:47:49 <lpsmith> this notion works for other bases too :-)
09:48:12 <benmachine> > unfoldr (\x -> if x == 0 then Nothing else Just (divMod x 10)) 1234
09:48:13 <lambdabot>   [123,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:48:18 <benmachine> erm.
09:48:23 * benmachine doin it rong
09:48:25 <dcolish> lol
09:49:00 <lpsmith> @src unfoldr
09:49:01 <lambdabot> unfoldr f b  = case f b of
09:49:01 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
09:49:01 <lambdabot>    Nothing        -> []
09:49:25 <benmachine> I think my divmod was the wrong way around
09:49:32 <lpsmith> aye :)
09:49:42 <Vulpyne> Is there any reason to use MVars instead of STM TMvars?
09:49:54 <lpsmith> @let swap (x,y) = (y,x)
09:49:55 <lambdabot>  Defined.
09:50:02 <Vulpyne> It seems like the disadvantage is you can't compose stuff with orElse.
09:50:14 <benmachine> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (divMod x 10))) 1234
09:50:15 <lambdabot>   [4,3,2,1]
09:50:20 <benmachine> almost! :P
09:50:51 <lpsmith> depends on whether or not you want the most or least significant bit first :-)
09:51:06 <lpsmith> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (divMod x 3))) 1234
09:51:07 <lambdabot>   [1,0,2,0,0,2,1]
09:51:11 <dcolish> in the case i'm working with, it doesnt matter
09:52:44 <oteren> repeatedly doing mod10 and div10 sounds awfully expensive
09:53:18 <benmachine> oteren: divMod is probably a little less expensive than doing each individually but yeah it probably is
09:53:36 <benmachine> don't see any other way of doing it though
09:54:00 <oteren> well, i dont know the under hood cost of show -> unlines -> read method
09:54:17 <oteren> but it sure looks a lot less expensive for big numbers
09:54:28 <benmachine> show probably uses the same technique
09:54:30 <Cale> What do you think show is doing? :)
09:54:32 <byorgey> paolino: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10787#a10787
09:54:47 <oteren> as i said, i dont know much of what goes on under haskell's hood ;)
09:54:49 <byorgey> paolino: I don't know if it's any better, but it's interesting at least =)
09:54:53 <Cale> Essentially the only way to get the digits of a number is to do repeated division
09:54:54 <byorgey> could probably be cleaned up a lot.
09:55:08 <Cale> If you turn numbers into strings in any programming language it's the same.
09:56:02 <oteren> indeed
09:56:25 <Ferdirand> if you really care about that, you may want to switch to hexadecimal ?
09:57:59 <zygoilid> Cale: show is presumably doing something not-quite-the-same in optimized C code in libGMP :)
09:58:12 <zygoilid> (assuming we're talking Integer here)
09:58:39 <oteren> so one could asume show is less expensive?
09:59:03 <zygoilid> i think one could comfortably assume show is not much more expensive
09:59:31 <zygoilid> but it's still going to need to box a lot of Chars if we're talking about big numbers
09:59:46 <FunctorSalad> benchmark
10:00:00 <zygoilid> right, guessing isn't the right approach to optimization :)
10:00:35 <benmachine> the show method goes faster
10:00:39 <benmachine> according to ghci
10:00:41 <FunctorSalad> (btw how do you force stuff for benchmarking?)
10:00:49 <zygoilid> benmachine: for numbers of what magnitude?
10:01:02 <benmachine> zygoilid: I am using
10:01:03 <benmachine> rnf $ map method1 [10 ^ 100 .. 10 ^ 100 + 10 ^ 5]
10:01:13 <benmachine> and the same with method2
10:01:23 <benmachine> where
10:01:34 <benmachine> both are off the top of my scrollback.
10:01:38 <zygoilid> hehe :)
10:01:58 <benmachine> let method2 = map digitToInt . show
10:02:08 <benmachine> let method1 = unfoldr (\x -> if x == 0 then Nothing else Just (modDiv x 10))
10:02:20 <zygoilid> i'd expect method1 to go slower if it's running as bytecode :)
10:02:30 <benmachine> oh that's true
10:02:41 <oteren> why's that?
10:02:43 <oteren> zygoloid
10:02:52 <oteren> haha, thats a bad name-misspelling
10:03:04 <zygoilid> oteren: hmm, i quite like that
10:04:14 <zygoloid> oteren: as i recall ghci compiles code to bytecode and executes it on a virtual machine. whereas show for Integer will be compiled haskell code callign compiled C code
10:05:15 <ddarius> @users
10:05:16 <lambdabot> Unknown command, try @list
10:24:28 <kakeman> how many years it takes to learn haskell?
10:24:45 <skorpan> 10
10:24:51 <kynky> 2.333333333333333333333333333333333333 years
10:25:08 <slxix> > [1..10]
10:25:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:25:13 <Lemmih> kakeman: Learning Haskell is easy. Learning how to be a good programmer takes time.
10:25:26 <oteren> yo, i swapped rooms, did you figure out if show method was slower in bytecode?
10:27:14 <sproingie> [1..]
10:27:32 <kynky> tbh, there isnt a lot to the haskell language, say compared to c++ or java etc, its just that the concepts are harder to grasp, but when you do, its amazing
10:27:42 <kynky> simple and elegant
10:27:46 <skorpan> > take 4 [1..]
10:27:47 <lambdabot>   [1,2,3,4]
10:27:49 <skorpan> now you know haskell
10:27:59 <sproingie> the haskell runtime language is easy
10:28:04 <sproingie> the type language will bake your noodle
10:28:08 <FunctorSalad> kynky++
10:29:05 <Berengal> The term language of haskell is basically lambda calculus with sugar on top
10:29:19 <sproingie> lots and lots of sugar.
10:29:29 <Berengal> Not that much, actually...
10:29:34 <sproingie> and it's not like typed lambda calculus is undaunting
10:30:00 <Berengal> The term language of typed lambda calculus is the untyped lambda calculus, same as haskells
10:30:12 <Berengal> And untyped lambda caculus has a very simple definition
10:30:23 <sproingie> term language yeah
10:30:30 <FunctorSalad> I'd call simply typed lc undaunting indeed...
10:30:35 <Berengal> Of course, types are where it's at these days
10:30:48 <sproingie> the game of go has undaunting rules too
10:30:56 <sproingie> actually playing it is bogglingly complex
10:30:59 <FunctorSalad> well yes, I meant it in that sense
10:31:19 <sproingie> thankfully haskell lets you learn it in small pieces
10:31:44 <sproingie> just that reading other peoples code can occasionally cause brain asplosions
10:32:06 <FunctorSalad> "be clear not clever" I guess
10:32:10 <FunctorSalad> if the code is to be read
10:32:38 <sproingie> many haskell programmers have unconventional definitions of "clear"
10:32:50 <kynky> so c++ is like chess, and haskell is like go
10:33:09 <Berengal> c++ is like mornington crescent
10:33:12 <FunctorSalad> sproingie: yeah and of what is too obscure I guess
10:33:15 <sproingie> not sure i'd compliment c++ that way
10:33:19 <Zao> C++ is like the Swan Lake.
10:33:27 <sproingie> java perhaps
10:33:31 <Zao> Really hard to pull off, but amazingly elegant when successful.
10:33:36 <FunctorSalad> mornington crescent?
10:33:43 <Berengal> http://en.wikipedia.org/wiki/Mornington_Crescent_(game)
10:34:03 <Berengal> And nothing's too obscure if it makes things clearer when it's understood
10:34:35 <sproingie> zomg pandora for android
10:34:38 <kynky> obscurity is in the eye of the beholder
10:34:42 <sproingie> buh bye last.fm
10:35:57 <FunctorSalad> sproingie: uh? how's pandora a substitute
10:36:10 <FunctorSalad> last.fm is nice for the stats too
10:36:46 <skorpan> i use last.fm mainly for the recommendations
10:36:59 <sproingie> FunctorSalad: better selection of songs
10:37:21 <sproingie> put in leonard cohen, i actually got leonard cohen
10:38:08 <FunctorSalad> I suppose they're not allowed to play what you enter
10:38:34 <FunctorSalad> but when I used pandora long time ago the song selection looped quickly
10:38:37 <FunctorSalad> is it better now?
10:39:17 <sproingie> depends.  i got a lot of looping on last.fm for some stations, not others.
10:40:04 <sproingie> my tastes are so eclectic that scrobbling becomes downright random
10:41:20 <sproingie> bah.  and now it forcequit without actually quitting and i have to reboot my phone.  oh well.
10:44:34 <jmcarthur_work> i add lots of artists to each of my pandora stations
10:44:46 <jmcarthur_work> loops less often with more seeds
10:45:46 <jmcarthur_work> you would think that more artists would tighten the search, but it loosens it instead...
10:46:16 <sproingie> ideally it'd do a bit of both
10:46:41 <jmcarthur_work> i wish i could say "qualities of (artist X AND artist Y) OR (artist Z AND artist W)"
10:47:32 <sproingie> put in warren zevon and i actually got funky stuff.  all last.fm had was Roland the Headless Thompson Gunner
10:47:40 <sproingie> which is a cool track but kinda odd
10:49:20 <sproingie> huh, just discovered CAL.  looks like haskell on jvm
10:50:40 <sproingie> sadly CAL's performance looks pretty glacial
10:50:55 <tibbe> dcoutts: going to do a new release of network today to fix OS X issues. When is the next HP package freeze?
10:51:26 <dcoutts> tibbe: you're fine for it I think
10:52:20 <tibbe> dcoutts: great
11:06:45 <oteren> @paste
11:06:46 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:09:26 <oteren> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4390#a4390
11:09:28 <oteren> halp
11:09:28 <oteren> :D
11:09:50 <oteren> dont get why i cant use guards in this way
11:10:37 <sproingie> you don't need guards for that
11:10:45 <oteren> meaning?
11:10:45 <Baughn> Right, pattern matching will do
11:10:48 <sproingie> parseExpr ('+':xs) = ...
11:10:51 <sproingie> parseExpr ('*':xs) = ...
11:11:22 <dcoutts> oteren: but the reason you can't is that the where goes below all the guards, not inbetween
11:11:22 <Baughn> Your where clauses also all seem to be identical. Having more than one is not so nice
11:11:43 <dcoutts> oteren: the things defined in the where clause are then in scope within all the guards
11:11:52 <oteren> ah
11:11:55 <oteren> so i only need the one
11:11:58 <dcoutts> yep
11:11:58 <oteren> didnt know that
11:12:11 <oteren> the one for neg is different
11:12:22 <oteren> can i keep the same names in that where clause?
11:12:25 <oteren> or do i need to rename it
11:12:27 <oteren> ?
11:13:25 <dcoutts> oteren: same names as what? where?
11:13:44 <dcoutts> it's not clear what you are referring to
11:14:26 <oteren> ah wait
11:14:39 <oteren> where is in scope within all the guards
11:14:44 <oteren> but not withing all the patterns?
11:15:04 <oteren> for the same function
11:16:29 <Baughn> @pl let (e1,xs') = parseExpr (tail xs) in parseExpr (tail xs')
11:16:29 <lambdabot> (line 1, column 5):
11:16:30 <lambdabot> unexpected "("
11:16:30 <lambdabot> expecting "()", natural, identifier or "in"
11:17:26 <dcoutts> oteren: each clause of your function (ie using its name) can have its own 'where' declarations
11:18:25 <dcoutts> oteren: and the things defined in the 'where' section are only in scope for that clause of the function.
11:24:25 <Baughn> oteren: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4390#a4392 <-- How about this?
11:24:55 <Baughn> oteren: ..I didn't try to factor in the first clause, though that should also be easy enough.
11:25:55 <Baughn> (It also appears to be mistyped. That's no pair..)
11:27:02 <zygoloid> oteren: i'm not sure your first clause is right. shouldn't there be spaces around x? or is the syntax supposed to be: "letabe+(4,4...
11:27:27 <Baughn> Probably he's passing it through a lexer first..
11:27:47 <Baughn> Um. One would hope. THough then they shouldn't be single letters..
11:28:02 <zygoloid> Baughn: right :)
11:28:12 <Baughn> Oh well. He'll figure it out. :P
11:28:24 * Baughn figures words would be a decent lexer, in this case
11:28:27 <zygoloid> i'm sure i've seen this problem before :)
11:28:57 <zygoloid> > words "let x be +(4,-(5,6)) in +(x,12)"
11:28:58 <lambdabot>   ["let","x","be","+(4,-(5,6))","in","+(x,12)"]
11:29:19 <Baughn> Well, obviously that wouldn't be a valid arithmetic expression
11:29:56 <Baughn> Let's say, words makes a decent /stand-in/ lexer until you get around to writing a real one
11:36:20 <Orclev> hmm... how would I got about converting Word8 into a hex representation stored in a String?... printf (I think that's how I did it last time I had something like this)?
11:37:13 <tibbe> Anyone Windows user out there willing to "cabal build" the latest network tarball before I release it? I have test OS X & Linux but find myself without a Windows VM.
11:38:08 <tibbe> http://johantibell.com/network-2.2.1.5.tar.gz
11:39:13 <Orclev> > printf "%x" 254
11:39:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:39:14 <lambdabot>    `Text.Printf.PrintfType ...
11:39:28 <Orclev> > printf "%x" (254 :: Word8)
11:39:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:39:29 <lambdabot>    `GHC.Show.Show a'
11:39:29 <lambdabot>      a...
11:39:40 <doubleth1nk_work> tibbe: sure
11:39:41 <Orclev> > printf "%x" (254 :: Word8) :: String
11:39:41 <lambdabot>   "fe"
11:39:55 <doubleth1nk_work> tibbe: i'm on my work machine right now so i happen to be on windows :)
11:40:18 <tibbe> doubleth1nk_work: great, thanks
11:40:19 <doubleth1nk_work> tibbe: "403 - Forbidden"
11:40:20 <zygoloid> > showHex (234::Word8) ""
11:40:21 <lambdabot>   "ea"
11:40:30 <tibbe> doubleth1nk_work: hmm, let me check
11:40:39 <zygoloid> Orclev: showHex is the go-to guy for show in hex ;-)
11:40:55 <tibbe> doubleth1nk_work: try now
11:41:09 <oteren> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4390#a4393
11:41:17 <oteren> ah damnit
11:41:20 <oteren> i've hit scroll
11:41:21 <Orclev> zygoloid: which package is that in?
11:41:23 <oteren> didnt see you write to me
11:41:35 <Orclev> zygoloid: Numeric?
11:41:55 <Orclev> nevermind, found it
11:42:15 <oteren> Baughn and zygoloid
11:42:17 <oteren> that looks better?
11:42:19 <oteren> it kinda works now
11:42:40 <zygoloid> @index showHex
11:42:41 <lambdabot> Numeric
11:42:55 <tibbe> doubleth1nk_work: let me know if you need any pointers
11:43:04 <Orclev> oooh, cool, I'll have to remember that command
11:43:04 <doubleth1nk_work> tibbe: yay
11:43:17 <doubleth1nk_work> tibbe: 'cabal configure && cabal build' should suffice, yes?
11:43:25 <tibbe> doubleth1nk_work: yep
11:44:02 <oteren> oops, forgot to add the error i get
11:44:03 <oteren> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4390#a4394
11:44:04 <oteren> there.
11:44:09 <Baughn> oteren: Ack. That duplication terrifies me.
11:44:38 <Baughn> oteren: Look at the second one. The second!
11:45:19 * zygoloid points at Baughn and makes a 'do what he says' face
11:45:37 <oteren> now i see your added stuff
11:45:48 <oteren> didnt know it just appended on the same page, hehe
11:45:57 <doubleth1nk_work> tibbe: running it from an MSYS terminal (with mingw etc,) 'cabal configure && cabal build' seems to work fine, but this is naturally because it uses an autoconf script to do configuration so it must have 'sh'
11:46:10 <doubleth1nk_work> tibbe: so yes, I think it works! :)
11:46:16 <tibbe> doubleth1nk_work: great, thanks!
11:46:32 <Orclev> @index toUpper
11:46:32 <lambdabot> Data.Char
11:46:38 <doubleth1nk_work> tibbe: np
11:50:19 <oteren> Baughn: i didnt paste the whole shabam the first time
11:50:38 <oteren> cause i have a part which looks for digits, uppercase letters and ')' in there too
11:51:08 <oteren> which is why i didnt use case (cause i couldnt get it to work with two identical patters, where one used case and the other used | guards)
11:51:29 <Baughn> oteren: By the way. Use parsec.
11:53:44 <tibbe> new version of network that works for 6.12 release, yay!
11:54:39 <hackagebot> network 2.2.1.5 - Networking-related facilities (JohanTibell)
11:55:19 <Baughn> tibbe: The darcs version of it worked for a while. Wait.. "Tibell"?
11:55:32 <Baughn> Oh.
11:55:52 <tibbe> Baughn: :)
12:03:46 <Baughn> tibbe: Any chance we'll get udp/broadcast support in the top-level Network module?
12:03:59 <tibbe> Baughn: if someone writes it ;)
12:04:20 <tibbe> Baughn: I would really like to give the whole network library an overhaul. There are a lot of things that are wrong in there
12:04:21 <Athas> Does anyone know of a guide to writing a Parsec parser that deals with user-defined operator precedence levels (like infixl/infixr in Haskell)?
12:04:49 <notsmack> asking one time before I start playing with the source...   I can't get isTCPConnectedTo from http to ever return True, so I have no way of knowing if the stream's been closed;  am i missing something?
12:05:05 <byorgey> preflex: seen paolino
12:05:05 <preflex>  paolino was last seen on #haskell 2 hours, 32 minutes and 34 seconds ago, saying: no reason really
12:05:19 <byorgey> @tell paolino http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10787#a10789
12:05:19 <lambdabot> Consider it noted.
12:07:35 <fxr> tibbe: did you pushed the patches to the repo?
12:07:44 <tibbe> fxr: oops, sec
12:07:53 <fxr> tibbe: thank you
12:08:01 <tibbe> fxr: done
12:10:02 <kettu> :t ((0 % 1) == 0)
12:10:03 <lambdabot> Bool
12:10:10 <kettu> why it typechecks?
12:10:14 <kettu> :t (==)
12:10:14 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:11:19 <Baughn> Why shouldn't it?
12:13:32 <kettu> :t 0
12:13:33 <lambdabot> forall t. (Num t) => t
12:13:41 <kettu> :t ((0 % 1) == (0 :: Int))
12:13:42 <lambdabot>     Couldn't match expected type `Ratio t' against inferred type `Int'
12:13:42 <lambdabot>     In the second argument of `(==)', namely `(0 :: Int)'
12:13:42 <lambdabot>     In the expression: ((0 % 1) == (0 :: Int))
12:13:58 <fxr> hmm 21k patches to downlad...it will take ages
12:14:00 <kettu> ah
12:14:06 <kettu> ghc?
12:14:09 <fxr> yep
12:14:25 <kettu> one day darcs will be faster
12:14:37 <skorpan> one day people will just give up darcs and use git
12:14:40 <PeakerWork> does darcs pack the patches it downloads?
12:14:45 <kettu> not yet
12:14:51 <kettu> but they plan it
12:15:17 <azumanga> I have need to serialise out some haskell data structures, and read them into python. What's the best way of doing this? The dreaded XML?
12:15:24 <kettu> repo.or.cz has git mirror of ghc, but it requires darcs for external libraries
12:15:41 <kettu> maybe json, yaml
12:15:53 <pchiusano> hello
12:15:59 <kettu> hej
12:16:15 <Baughn> azumanga: Depends on the complexity of the structures
12:16:18 <PeakerWork> azumanga: JSON is a nicer XML than XML
12:16:24 <Baughn> azumanga: ..XML isn't /that/ bad. Not always.
12:16:45 <azumanga> My data structure is a parsed and type-checked tree, from a parsed language
12:16:59 <Baughn> S-expressions?
12:17:10 <azumanga> I've written a nice parser in parsec and a type-checker, and I think (hope) it will be easier to send this to python, rather than starting parsing and type-checking from scratch in python
12:18:26 <azumanga> The reason for having to send things to python is I'm working with people who I haven't converted over to haskell yet, unfortunately. I hope to move them over gently :)
12:18:28 <pchiusano> anyone know ed kmett's handle?
12:18:54 <Baughn> azumanga: If it's a tree, s-expressions should fit nicely. Well, there's also XML, but...
12:19:29 <paolino> :t (>=>)
12:19:30 <lambdabot> paolino: You have 1 new message. '/msg lambdabot @messages' to read it.
12:19:30 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:19:45 <Twey> azumanga: Maybe you could convert it to pickle-format.
12:20:03 <Twey> That'd be easier on the Python side, and it's not too tricky on the Haskell side, either.
12:21:55 <Baughn> Sure. A Data.Binary client for pickled structures would a nice addition to hackage. :)
12:22:02 * Twey nods.
12:22:08 <paolino> @pl \f g-> \x -> f x >>= g
12:22:08 <lambdabot> flip . ((>>=) .)
12:22:25 <paolino> :t  \f g-> \x -> f x >>= g
12:22:26 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
12:23:51 <FunctorSalad> paolino: (>=>)
12:23:59 <azumanga> Is there a good site, tutorial or book, on writing an optimising compiler in haskell?
12:24:20 <paolino> FunctorSalad: that was the starting point :P
12:24:22 <azumanga> I don't mind if it's a big book, or well-documented code, I understand this could involve a lot of reading
12:25:38 <Twey> azumanga: An optimising compiler?  Yeah.  That's a whole branch of computer science‚Ä¶ or two.  ‚ò∫
12:26:12 <paolino> thanks byorgey, the code is clear, I just cannot evaluate the complexity, it looks like it goes up and down a little bit of too much, but that is linear :)
12:26:24 <azumanga> Yup, it's one I know quite a bit about in C, but wondered if there was a standardish text about in haskell
12:26:37 <Twey> azumanga: You could start with the Dragon Book.
12:26:53 <Twey> The majority of the stuff you'll need is language-independent theory.
12:27:02 <Twey> You could also read through GHC's source.
12:27:09 <azumanga> Yep, I should probably dig back through the Dragon Book again
12:27:12 <Twey> (or Yhc's, which I hear is nicer)
12:31:42 <jmcarthur_work> Peaker, btw, SDL is indeed the bottleneck in your breakout implementation
12:32:44 <jmcarthur_work> it still did not feel slow on my machine though
12:32:53 <sm> fxr, can't you darcs get --lazy ?
12:38:12 <fxr> sm: great idea :)
12:39:09 <sm> if the ghc repo is darcs-1 format, you won't be able to, but in that case try darcs get --partial
12:40:02 <fxr> sm: I think lazy is the default for darcs 2
12:42:51 <sm> fxr: only if you hit ctrl-c during the get
12:43:13 <sm> it will tell you when that's ok
12:43:15 <ketil> I thought the -optl-static issue was fixed, but I still get problems with 6.10.4?
12:44:56 * ketil checks to see if there's a bug filed in Launchpad against the Ubuntu-distributed ghc.
12:47:00 <fxr> actually I have got ghc-HEAD but I want ghc-6.12 tag
12:47:14 <sinelaw> @quote Seuss "It's fun to have fun, but you have to know how!"
12:47:14 <lambdabot> No quotes for this person. stty: unknown mode: doofus
12:47:29 <sinelaw> errr
12:48:04 <ketil> Oh, it's just a missing -optl-pthread.
12:48:33 <Orclev> which do you think is better, > zipWith (++) (repeat "0x"), or > map ("0x"++)?
12:49:00 <ketil> Orclev, the latter.
12:49:04 <doubleth1nk_work> fxr: you should probably use the 6.12 branch, then
12:49:37 <fxr> doubleth1nk_work: but it costs me 21k patches to downlad
12:49:53 <ketil> Or:  ["0x"++s | s <- ss]
12:50:16 <skorpan> why not a for loop
12:50:25 <doubleth1nk_work> fxr: http://darcs.haskell.org/ghc-STABLE-2009-10-10-ghc-corelibs-testsuite.tar.bz2
12:50:34 <doubleth1nk_work> ^^ that is the STABLE branch as of 5 days ago, i.e. the 6.12 branch
12:50:36 <ketil> skorpan: oh, you evil persion you.
12:50:45 <fxr> doubleth1nk_work: that make sense :)
12:50:48 <doubleth1nk_work> download that tarball, then you can do 'cd ghc' (the directory inside it) and just 'darcs pull'
12:50:59 <fxr> doubleth1nk_work: thanks
12:51:00 <doubleth1nk_work> fxr: because of the terrible darcs1 performance for repos this size, that's the best method
12:51:23 <sproingie> i thought ghc was switching to hg?
12:51:32 <doubleth1nk_work> some people have done conversions of the tree to darcs2 however, and killian on glasgow-haskell-users said with it it's totally viable to just 'darcs get <ghc darcs repo>'
12:51:37 <doubleth1nk_work> sproingie: the plan was to move to git
12:52:03 <sproingie> darcs2 managed to improve enough or something?
12:52:13 <doubleth1nk_work> the path forward still isn't entirely clear
12:52:25 <doubleth1nk_work> the plans were to switch to git after implementing the new build system
12:52:38 <doubleth1nk_work> but nobody's really talked about it since, because yes, darcs has improved a lot
12:53:28 <doubleth1nk_work> sproingie: the whole mess is quite political too
12:53:55 <doubleth1nk_work> sproingie: GHC needs certain libraries to build, and in turn, some GHC changes affect these libraries and vice versa, etc
12:53:59 <Orclev> doubleth1nk_work: not sure what time scale you're talking about, but git has improved a lot recently as well
12:54:10 <doubleth1nk_work> sproingie: however, not necessarily all of these libraries are controlled by GHC HQ
12:54:41 <doubleth1nk_work> which means to move to git, all of these libraries would need to switch too in order to avoid insanity
12:54:56 <fxr> for me, darcs is more easier than git
12:55:15 <doubleth1nk_work> because it *is* insanity to try and manage GHC (which is large and complex by itself) and the libraries it needs and is highly coupled with in two different VCSs
12:55:35 <Orclev> fxr: I haven't used darcs much, but it seems easier to do basic checkouts and such, but git is simpler when you're trying to manage lots of branches/patches/merges
12:55:46 <doubleth1nk_work> but it is also not fair to just say "you are switching to git" to those library maintainers
12:55:52 <doubleth1nk_work> so the whole mess is political as well as technical
12:56:04 <Baughn> There's also the speed bit. For anything the size of ghc, git is quite noticably faster than darcs
12:56:07 <doubleth1nk_work> Orclev: I've been using git for a while, I like it a lot, and yes it's gotten even better recently
12:56:09 <fxr> Orclev: yes it is
12:56:11 <doubleth1nk_work> Baughn: yes, even darcs2
12:56:29 <Baughn> ..it takes me several hours to download ghc via darcs
12:56:53 <doubleth1nk_work> Baughn: the recommended way to get the source right now is to download a snapshot of the darcs HEAD tree and then use it, and just pull patches from there
12:57:02 <doubleth1nk_work> because pulling 20k patches in darcs1 format is not going to be fun or efficient
12:57:22 <Baughn> doubleth1nk_work: Right. Which is of course how git also works, just more seamlessly.
12:57:57 <doubleth1nk_work> anyway, off to class!
12:58:00 * doubleth1nk_work --away
13:00:03 <fxr> "The next version of hashed-storage will likely introduce a notion of "packs" in which the many often very small files that Darcs keeps track of will be concatenated into more substantial "packs" that compress better and reduce the ill effects of latency."
13:00:23 <fxr> I guess it will be available with darcs 2.5
13:01:08 <Orclev> another factor is that, outside of the haskell community, darcs has very little uptake... I hadn't even heard of it until I started looking at haskell
13:01:40 <fxr> Orclev: well we also used darcs when we're developing with common-lisp
13:02:29 <Orclev> fxr: ah, ok, I've never done anything with common-lisp
13:03:32 <Orclev> s/haskell community/haskell and common-lisp community/
13:06:04 <Twey> Orclev: I've heard of it quite a bit outside Haskell/CL
13:06:43 <ksf> conal, http://www-lb.cs.umd.edu/hcil/piccolo/learn/Toolkit_Design_2004.pdf   I'm just starting to read it, but it looks interesting
13:07:38 <Orclev> Twey: no clue, like I said, first I heard of it was when I was looking at haskell. Maybe it has to do with what projects/sites one frequents?
13:07:45 <Twey> Maybe
13:08:20 <ksf> my whole frustration stems from the fact that gtk's treeview doesn't do what I want, and rolling one's own treeview is utter pain.
13:08:51 <Orclev> ksf: what do you want treeview to do?
13:09:08 <ksf> also, 99% of gtk don't come with that model/view distinction
13:10:01 <ksf> Orclev, I want to display collapsible nodes where the nodes have different columns from their children.
13:11:38 <byorgey> pchiusano: it's edwardk
13:12:04 <Orclev> hmm, I thought it already did that, but I must be wrong... that really does suck as that's the behavior I'd think most people would expect
13:12:47 <ksf> presentation is way too programmer-designed, these days. something not entirely unlikely switching .glade files on the fly should be a standard feature of a tk and all its apps.
13:13:42 <ksf> app doesn't come with a curses interface? derive one automagically and then tune it while you use the app.
13:15:31 <Orclev> ksf: the problem is how difficult it is to seperate interface logic from presentation
13:17:23 <ksf> an app has some input and some output with specific types, each, and a raw gui can be derived from these, automagically. then you can use a gui to specify a transformation on that raw gui.
13:17:48 <ksf> (I'm not saying that I've got any idea right now on how to implement that)
13:18:01 <iaefai> Has anyone managed to get SDL module working on the mac with the framework version of SDL?
13:18:36 <edwardk> ?
13:18:39 <Orclev> ksf: sure, you can define a set of basic widgets that all interfaces must support, but then you're limited to just those widgets, and your ability to do anything custom is effectively nil
13:19:03 <ClaudiusMaximus> ksf: http://www.haskell.org/haskellwiki/TV
13:19:16 <Twey> *nod*
13:19:18 <edwardk> ever get that slightly weirded out feeling when you hear your name out of context?
13:19:27 * edwardk is afraid the next works out of byorgey will be 'get him!'
13:19:35 <ksf> the question is what granularity these widgets have.
13:19:36 <Twey> Haha
13:20:00 <ksf> ...and to be able to combine them without boilerplate.
13:20:14 <ksf> yep, TV is close.
13:20:48 <Orclev> ksf: true enough, but at some point you're going to run up against a level of granularity that one of the interface can't support, thus eliminating either finer granularity that might be supported by other interfaces, or that particular interface
13:21:09 <ksf> I don't see any reason why I should implement hide/show column function if the user could just specify a filter on the model before it gets send to the view.
13:21:51 <ksf> model/view separation is crucial.
13:22:14 <ksf> ...a button is but one of a thousand ways to trigger an event.
13:23:08 <Orclev> ksf: bah, button is easy, the tough ones are the ones that combine aspects of both model and view, like tables
13:23:34 <Twey> Tables are layout, not widget
13:23:58 <Orclev> Twey: but layout is a spect of the view, but dependent on the underlying model
13:24:09 <ksf> and "reload" is an event slot, not a button.
13:25:17 <ksf> Orclev, the layout has it's own model of how thick its lines are, but that model is orthogonal to the data in the table.
13:26:52 <conal> ksf: got it.  thx for the pointer.  i like those zooming toolkits very much.
13:28:12 <jagwire> so I wrote my own versin of elem when I didn't need to
13:28:14 <jagwire> hmph!
13:29:26 <Orclev> ksf: ok, maybe I'm missing something... you seem to be arguing that layout is seperate from view?... so, you've got what, model, layout, and view?... then the developer still needs to define the layout which in turn will vary based on the view
13:30:14 <conal> ksf: great timing for the pointer.  i want to make some ZUI-style iphone apps.
13:32:50 <ksf> you've got model (your data), view (derived raw widget), model (run-time configurable .glade), view (display using that .glade), view (display of that glade), controller (managing transformations on data/raw widget)
13:35:18 <Orclev> ksf: ok, so it's not so much you're arguing for a auto-matic view, as one that's defined at runtime to allow it to be customized... reminds me of XUL
13:35:36 <ksf> yep.
13:37:11 <Orclev> ksf: or rather it's defined by the developer at compile time, but stored in a user modifiable format that's evaluated at runtime
13:37:31 <sinelaw> funny title for a paper; "Compiling Haskell by program transformation: A report from the trenches"
13:37:57 <Berengal> Is it possible to disambiguate a module by package name?
13:38:16 <Berengal> as in e.g. "import mtl:Control.Monad.Trans"
13:38:19 <ksf> the developer can do it in the same way as the user, though.
13:39:01 <Orclev> Berengal: so far as I know, no, but you can specify which one to link against at compile time I think
13:39:13 <CosmicRay> a bit weird.  the sha module is documented as taking a ByteString, though it really takes a Data.ByteString.Lazy.Internal.ByteString.  Strangely, I can pass it a Data.ByteString.ByteString but not a Data.ByteString.Char8.ByteString.  Why would the sha module restrict its parameter type like that?
13:39:18 <ksf> ...if you don't want your user to safe a file before he opened one, you should bleeding design your model so that can't be defined in the view.
13:39:23 <CosmicRay> or should I go dive into the bytestring code?
13:39:23 <Berengal> Orclev, not good enough if you need to refer to two different modules with the same name
13:39:54 <ketil> Whee!  Debianized biohaskell, and uploaded to PPA.
13:40:05 * ketil pats himself on shoulder, and calls it a night.
13:40:09 <Lemmih> CosmicRay: You must be mistaken.
13:40:14 <ketil> (not the shoulder, though)
13:40:21 <ksf> the Char8 and Word8 implementations of bytestring are the same.
13:40:22 <CosmicRay> Lemmih: on what point?
13:40:29 <ksf> it's just a difference in types.
13:40:37 <CosmicRay> I'm staring at the error right here.
13:40:54 <ksf> there should be conversion funs, but an unsafeCoerce should work, too.
13:40:54 <Berengal> CosmicRay, Data.ByteString.Lazy.Internal.ByteString is the same type as Data.ByteString.Lazy.ByteString; it's just reexported. It's not the same type as Data.ByteString.ByteString, however, even though they have the same name
13:40:56 <CosmicRay> PasswdGenerators.hs:20:77:
13:40:56 <CosmicRay>     Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'
13:40:57 <CosmicRay>            against inferred type `BSC.ByteString'
13:40:57 <CosmicRay>     In the second argument of `(.)', namely `BSC.pack'
13:40:57 <CosmicRay>     In the second argument of `(.)', namely `SHA.sha1 . BSC.pack'
13:40:57 <ketil> CosmicRay, doesn't make sense, they're the same thing.
13:40:57 <CosmicRay>     In the second argument of `(.)', namely
13:40:57 <CosmicRay>         `SHA.bytestringDigest . SHA.sha1 . BSC.pack'
13:41:00 <CosmicRay> when it's run via Data.ByteString.pack, it works fine
13:41:08 <ketil> Sure you haven't build a library against a different BS version?
13:41:13 <CosmicRay> ketil: this is why I'm asking here.
13:41:25 <Lemmih> CosmicRay: Data.ByteString.ByteString is the same as Data.ByteString.Char8.ByteString.
13:41:43 <CosmicRay> ketil: I *just* built it.
13:41:45 <Lemmih> CosmicRay: Lazy bytestrings are different from strict bytestrings, though.
13:41:56 <Orclev> Berengal: pretty sure you can't have two different modules with the same name, at least not both installed at the same time... I could be wrong though, I'm a newb
13:42:07 <CosmicRay> :t sha1
13:42:07 <CosmicRay> sha1 :: Data.ByteString.Lazy.Internal.ByteString -> Digest
13:42:08 <lambdabot> Not in scope: `sha1'
13:42:26 <CosmicRay> How it gets a non-lazy ByteString into that in the first place is my first puzzle.
13:42:38 <ketil> CosmicRay, right, sorry :-)   You get this from building just the SHA library?  It doesn't depend on something else - binary or whatever?
13:43:19 <Berengal> Orclev, you can have two different modules witht the same name, but you can only refer to one of them one build unit. It's perfectly fine to use both modules in the same program, as long as they're compiled separately
13:43:34 <Lemmih> CosmicRay: BSC is Data.ByteString?
13:43:34 <CosmicRay> ketil: the library builds fine.
13:43:43 <CosmicRay> lemmih: BSC is Data.ByteString.Char8
13:43:51 <Berengal> Orclev, the visibility of modules is decided at compile-time, when you (or cabal) tell ghc which packages are visible
13:43:55 <Lemmih> CosmicRay: Well, that's your error right there.
13:44:11 <Lemmih> CosmicRay: Import Data.ByteString.Lazy.Char8
13:45:18 <CosmicRay> Lemmih: eh?
13:45:22 <CosmicRay> ah.
13:45:25 <Lemmih> CosmicRay: 'sha1' wants a lazy bytestring. You're handing it a strict one.
13:45:27 <CosmicRay> I see what you're saying.
13:46:20 <CosmicRay> Lemmih: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10793#a10793
13:46:22 <CosmicRay> that works.
13:46:28 <Berengal> CosmicRay, they're different types, even though they share the same name. In fact, lazy ByteString is just a list of strict ByteStrings
13:46:30 <CosmicRay> oh geez, I'm blind.
13:46:37 <Berengal> (Except it's strict in it's elements)
13:46:49 <CosmicRay> ok I feel very silly now.
13:47:01 <CosmicRay> I didn't notice until I made the hpaste that the code is importing Data.ByteString.Lazy as BS.
13:47:14 <CosmicRay> confused me because I normally import it as BSL
13:47:19 <CosmicRay> (this is someone else's code)
13:47:27 <CosmicRay> everything is explained now
13:48:18 <CosmicRay> sorry for the noise.
13:48:41 <CosmicRay> guess sometimes it helps me find the answer to the question by reducing it to a testcase I can ask someone else about ;-)
13:59:34 <McManiaC> huh? is something wrong with cabal?
13:59:35 <McManiaC> Downloading the latest package list from hackage.haskell.org
13:59:36 <McManiaC> cabal: Codec.Compression.Zlib: incorrect header check
13:59:40 <McManiaC> on cabal update
13:59:58 <skorpan> there's a lot of things wrong with cabal
14:00:04 <McManiaC> :P
14:01:25 <fxr> a new day started
14:02:09 <Saizan> McManiaC: that means the downloaded .tar.gz is corrupted
14:04:24 <iaefai> I am trying to troubleshoot a build of GLFW (on mac), and I have run into an error that seems to be in ghc's framework, but the output is a little confusing. I have pasted the cabal build -v3 to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10794#a10794  and the stuff I am trying to figure out is at line 177. Any ideas what might be happening?
14:10:07 <jagwire> So in regards to pattern matching
14:10:39 <jagwire> I have a need to create a function which picks apart a bunch of nested data types
14:10:50 <jagwire> and I'm not sure how to do so exactly
14:11:11 <jagwire> (how's that for being vague? ;) )
14:11:37 <mauke> good work
14:12:20 <FunctorSalad> jagwire: nest the patterns
14:12:28 <jagwire> mk
14:13:02 <FunctorSalad> > case Just (Left 2) of Just (Left y) -> y
14:13:03 <lambdabot>   2
14:18:44 <byorgey> @tell edwardk oh, pchiusano was just asking what your nick was. =)
14:18:44 <lambdabot> Consider it noted.
14:24:42 <ricky26> People, I'm kinda new to Haskell, and I wondered why doing a putStrLn("hello") at the start of a do statement was causing a strange unexpected type error.
14:24:55 <mauke> (x) is the same as x
14:25:03 <mauke> need more context to help you
14:25:08 <ricky26> http://pastebin.com/df056a2e
14:25:16 <ricky26> mauke: I know
14:25:31 <mauke> because the types don't fit
14:25:32 <ricky26> Was just testing it wasn't joining it onto the next statement or something strange like that.
14:25:42 <mauke> putStrLn returns IO (), your function returns [Char]
14:25:52 <ricky26> I don't want to return the putStrLn
14:25:56 <ricky26> I just want it to happen. : <
14:26:00 <mauke> impossible
14:26:05 <mux> haskell won't let you do that :)
14:26:05 <mauke> things don't happen in Haskell
14:26:11 <ricky26> Harhar
14:26:16 <mauke> Haskell only builds values from other values
14:26:22 <ricky26> But
14:26:27 <ricky26> but
14:26:29 <ricky26> : <
14:26:32 <mux> unless you use Debug.Trace.trace but that's obviously for debugging
14:26:32 <mauke> YES
14:26:50 <ricky26> Haha, I had seen of debug.trace.trace
14:26:52 <ricky26> but I thought
14:27:03 <ricky26> "Surely no need for that, surely I can just print one of my variables".
14:27:08 <mux> looking at your code, you really should read some more haskell tutorials
14:27:27 <mux> your coding style and type checking problems show that you need some learning first :-)
14:27:54 <ricky26> I know.
14:28:25 <ricky26> I was going through pythonchallenge to see if I could learn what I was missing for basic text transformation
14:28:25 <ricky26> : >
14:28:35 <mux> I mean, you are of course welcome to ask questions in here, but the explanations might get very long :-)
14:28:57 <Zao> And sometimes above your Data.List.head
14:28:59 <ricky26> http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output <--- why does the last example in there work then?
14:29:15 <ricky26> it's just a sequence of instructions. : <
14:29:21 <mauke> not quite
14:29:28 <mauke> that one builds a value of type IO ()
14:29:29 <PetRat> In running "cabal install darcs" I get "the package requires cabal library version -any && >=1.6 but no sutiable version is installed" --- what do I need to update?
14:29:53 <mux> ricky26: if your function is in IO, and if you're using the do syntax, every line in the do black must have type IO a
14:29:57 <mauke> PetRat: 'cabal', it seems
14:29:58 <mux> for some a
14:30:05 <mux> s/black/block/
14:30:12 <ricky26> Oh golly.
14:30:17 <ricky26> >_>
14:30:23 <ricky26> That is somewhat inconvenient.
14:30:35 <Zao> Not really.
14:30:42 <gspr> Let's say I'm writing an interface to a C library with the FFI. If I have some C function that takes a pointer to an allocated struct, does some stuff with it, and leaves the struct in a state where it is to be passed (as a pointer) to other functions, am I correct to believe that I still need to make a Storable instance for this struct?
14:30:42 <Zao> @type return
14:30:43 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:30:44 <mux> ricky26: also, if you do some IO, you function _will_ have an IO a type; there's no way it'll be String -> String (or you're cheating)
14:30:53 <gspr> (Even though I will not be modifying any of the struct's internals)
14:31:05 <mux> ricky26: that's what "typed effects" means
14:31:16 <PetRat> mauke: hmm. running "cabal -V" says that it is "using version 1.6.0.2 of the Cabal library"
14:31:25 <ricky26> mux: I gathered about IO polluting types if you "do" anything with them,
14:31:26 <mauke> PetRat: ok, weird
14:31:27 <PetRat> That seems >=1.6 to me
14:31:33 <ricky26> Just didn't realise it polluted my whole do block.
14:31:36 <mauke> PetRat: it's also Cabal, not cabal
14:31:45 <mauke> I don't quite understand what's going on
14:31:46 <mux> gspr: if you don't read or write into it you don't need a Storable instance
14:31:50 <Zao> @type (>>)
14:31:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:32:02 <mux> gspr: of course that means you don't know its size too, so you can't allocate such a struct too
14:32:12 <Zao> ricky26: As do desugars to a bunch of >>, you kind of need to match up the m properly.
14:32:18 <PetRat> mauke: which is "Cabal"?
14:32:36 <gspr> mux: Exactly... but can I somehow inform alloca of just the size (and thus not have to write peek/poke)?
14:32:48 <mux> @hoogle allocaSize
14:32:48 <lambdabot> No results found
14:32:50 <mux> mmm
14:32:59 <mauke> allocaBytes
14:33:04 <mux> right
14:33:11 <mux> @index allocaBytes
14:33:11 <lambdabot> Foreign.Marshal.Alloc, Foreign.Marshal, Foreign
14:33:14 <mux> :t allocaBytes
14:33:15 <lambdabot> Not in scope: `allocaBytes'
14:33:16 <gspr> mux: Ah, thanks!
14:33:26 <mux> :t Foreign.Marshal.Alloc.allocaBytes
14:33:27 <gspr> mux: Hint taken  - thank you so much :)
14:33:27 <lambdabot> forall a b. Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
14:33:33 <mux> gspr: you're welcome
14:33:36 <ricky26> Zao: I see. This surely means that if I mark my function IO, all is good?
14:33:38 <PetRat> mauke: do you think I might need GCH 6.10? I'm running 6.8 right now.
14:33:49 <gspr> mux: should save me some time
14:34:13 <mauke> PetRat: no idea
14:34:52 <Zao> ricky26: It will likely be able to infer a suitable signature for you, but it never hurts (much) to explicitly provide one of your own.
14:35:06 <ricky26> I had done
14:35:11 <ricky26> [Char]->[Char] : >
14:35:16 <ricky26> Probably the cause of this mess.
14:35:17 <Zao> @type do { print "lol"; return 42 }
14:35:18 <lambdabot> forall b. (Num b) => IO b
14:35:39 <Zao> Yup.
14:35:40 <ricky26> I've noticed that explicit typing makes the errors more readable
14:35:46 <ricky26> Oh dear
14:35:48 <mux> it often does indeed
14:35:59 <mux> or sometimes adding type annotation helps in understanding a type mismatch
14:36:41 <ricky26> Now it doesn't like me :-ing y
14:37:00 <ricky26> Because the left half is just a normal Char
14:37:06 <ricky26> and it wants a [Char] on the other side
14:37:10 <ricky26> but it's got an IO [Char]?
14:37:20 <Zao> Could you pastesite your current code?
14:37:30 <jagwire> does [x:xs] match a list of lists?
14:37:42 <mauke> jagwire: yes
14:37:44 <Zao> If you have an IO [Char], you need to run the action to extract the result.
14:38:01 <FunctorSalad> a list containing a single list
14:38:25 <ricky26> Can I run it inline?
14:38:29 <ricky26> Rather than <- it into a variable?
14:38:41 <mauke> you cannot run actions
14:38:47 <Zao> @type let f = return "lol" in do { xs <- f; print (x : xs) }
14:38:47 <lambdabot>     Couldn't match expected type `Expr' against inferred type `Char'
14:38:48 <lambdabot>       Expected type: [Expr]
14:38:48 <lambdabot>       Inferred type: [Char]
14:38:58 <mauke> well, you cannot run IO stuff
14:38:59 <Zao> ricky26: Where by run I meant use <- to grab the results (among other ways)
14:39:15 <ricky26> Zao: Yeah
14:39:19 <ricky26> Can I do it without <-
14:39:27 <ricky26> Save adding another variable?
14:39:33 <Zao> Erm, where did x come from in my line there?
14:39:40 <mauke> > x
14:39:41 <lambdabot>   x
14:39:56 <Zao> ricky26: You can chain monadic actions together with (>>=)
14:40:00 <Zao> @type (>>=)
14:40:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:40:28 <Zao> In fact, that's what <- desugars to; >>= and a lambda.
14:41:05 <Zao> do { x <- f ; print x }   becomes something like   f >>= \x -> print x
14:41:27 <mauke> @undo do { x <- f; print x }
14:41:27 <lambdabot> f >>= \ x -> print x
14:41:38 <Zao> Ooh, handy operation.
14:41:44 <ricky26> Zao: Oooh
14:41:45 <ricky26> Thanks
14:41:52 <ricky26> That last example explained things a bit more.
14:41:53 <ricky26> I think XD
14:44:00 <Axman6> > let x = y; y = z; z = x in x
14:44:04 <lambdabot>   mueval-core: Time limit exceeded
14:44:05 <augur> honestly, ive always prefered >>= to do { }
14:44:12 <augur> but then, i dont code in haskell much
14:44:20 <ricky26> (theBabies $ xb:xc:y:xd:xe:xf:xs) >>= (:) y
14:44:25 <ricky26> Doesn't work? : S
14:44:38 <Zao> @type (:)
14:44:39 <lambdabot> forall a. a -> [a] -> [a]
14:44:50 <Zao> Doesn't look like  (a -> m b) to me
14:44:52 <skorpan> @type (x:y:z)
14:44:53 <lambdabot>     Couldn't match expected type `[Expr]' against inferred type `Expr'
14:44:54 <lambdabot>     In the second argument of `(:)', namely `z'
14:44:54 <lambdabot>     In the second argument of `(:)', namely `y : z'
14:45:32 <Zao> @type (?x : ?y : ?z)
14:45:33 <lambdabot> forall a. (?z::[a], ?y::a, ?x::a) => [a]
14:45:57 <augur> zao, whats ? doing there?
14:46:10 <Zao> augur: Fakes an identifier.
14:46:21 <augur> hmm
14:46:24 <augur> interesting
14:46:50 <fxr> tibbe: there are 2 new patches for the network repo, are you sure it is done?
14:46:51 <Zao> Apparently rather handy to find constraints with :)
14:47:01 <tibbe> fxr: the push?
14:47:08 <tibbe> fxr: were only a few fixes
14:47:14 <tibbe> fxr: brb
14:47:21 <fxr> tibbe: I see only a version bump
14:47:28 <tibbe> fxr: sec
14:47:31 <fxr> ok
14:47:56 <fxr> anyway, cabal package works like a charm
14:47:59 <tibbe> fxr: give me a few mins, busy
14:48:04 <tibbe> fxr: great
14:48:41 <ricky26> Zao: Don't quite understand what that means...? Do I need to convert the output back into an IO b?
14:48:50 <ricky26> Because if I've got this right
14:48:54 <mauke> ricky26: yes, actually
14:48:59 <ricky26> >>= applies the output of the left, onto the right?
14:49:43 <tibbe> fxr: 2 real changes since 2.2.1.4
14:49:43 <ricky26> How do I make an IO b from a b? :P I assumed you could use any type as an IO of that type, as it is kind of like a handicap. :>
14:49:47 <mauke> mx >>= f attaches the callback f to the action mx, producing a new action
14:50:08 <ricky26> mauke: I see.
14:50:10 <mauke> that when executed first executes mx, then calls f with the result, then executes the result of f x
14:50:17 <mauke> @hoogle b -> IO b
14:50:18 <lambdabot> Control.Exception evaluate :: a -> IO a
14:50:18 <lambdabot> Control.OldException evaluate :: a -> IO a
14:50:18 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
14:50:25 <mauke> lambdabot: no, wrong!
14:50:35 <mauke> ricky26: the function is called 'return'
14:50:36 <tibbe> Network.Socket.connect: allow connect on bound socket
14:50:46 <tibbe> Follow GHC IO library rewrite
14:50:58 <ricky26> Oh yeah, duh.
14:51:03 <ricky26> *facepalm*
14:51:27 <mauke> also, (x >>= return . f) is the same as (liftM f x)
14:54:15 <c_wraith> is there a crypto-quality RNG package out there?
14:54:20 <tibbe> fxr: back
14:54:31 <tibbe> fxr: I posted the two change names above ^^
14:55:02 <tibbe> fxr: One was a fix for issue #3 and the other followed GHC I/O lib rewrite
14:55:51 <blackh> c_wraith: There's an OpenSSL binding...
14:56:27 <c_wraith> I guess I could pretend I'm always on linux and read /dev/urandom
14:57:20 <opqdonut> c_wraith: implement a wrapper for libcrypto :)
14:58:00 <opqdonut> or libgcrypt
14:58:16 <opqdonut> should be quite straightforward
14:58:30 <opqdonut> a pure-haskell blum blum shub or something would be nice to have on hackage...
14:58:52 <c_wraith> There's a pure mersenne twister package
14:59:17 <opqdonut> mhmm
14:59:27 <opqdonut> but mt isn't for crypto right?
14:59:44 <c_wraith> Correct.  It's great for things like monte carlo sims, though
15:00:06 <opqdonut> i prefer rule 30, but for purely irrational reasons
15:00:26 <opqdonut> (wolfram's cellular automaton based prng)
15:03:15 <Baughn> MT random numbers are indistinguishable from real randomness by all currently devised tests, except the ones specifically targeting MT. That's the difference between "really good PRNG" and "cryptographic PRNG".
15:03:20 <c_wraith> I'm not actually doing crypto work.  I don't need something quite that strong.  I do need better than "seed based on the current time", though.
15:03:45 <Baughn> Well, the usual standard is to read the seed from /dev/(u)random..
15:03:52 <c_wraith> Yeah...
15:03:56 <c_wraith> If not on windows :)
15:04:11 <Baughn> I'm sure windows has something similar
15:04:22 <jmcarthur_work> Baughn, so there are tests that specifically target MT successfully?
15:04:31 <c_wraith> It's sort of a pain to use.  Nothing as nice as a file interface.
15:05:07 <Baughn> jmcarthur_work: I don't know if any actually exist, but if the author didn't see a way to make one, he'd call it a cryptographic PRNG.
15:05:18 <jmcarthur_work> ah
15:05:28 <skorpan> @pl \fp -> (fmap parsePerson) <$> lines <$> readFile fp
15:05:28 <lambdabot> ((fmap parsePerson <$> lines) <$>) . readFile
15:05:40 <Berengal> If my memory serves, it's possible to predict future numbers after seeing 612 numbers, or something like that
15:05:59 <c_wraith> Is that 612 consecutive numbers?
15:06:04 <Berengal> Yes
15:06:12 <Berengal> WP probably has the answers
15:06:22 <opqdonut> yes, i just read the page on MT :9
15:06:44 <jmcarthur_work> on the one hand, 612 is a lot. on the other hand, it isn't
15:06:54 <Baughn> The point is, MT randomness can only be distinguished from true randomness by way of incredibly involved calculations that are essentially impossible to run into by /accident/
15:07:05 <Baughn> Thus, it's really good for anything but crypto
15:07:05 <jmcarthur_work> i guess the only way to prevent that from happening is by keeping more bits of entropy
15:07:28 <Baughn> jmcarthur_work: For MT? Or for PRNGs in general?
15:07:30 <c_wraith> heh.  only give out 611 consecutive numbers, throw out every 612th. :)
15:07:39 <Baughn> jmcarthur_work: Blum Blum Shub has considerably less state than MT
15:07:39 <jmcarthur_work> generally? i don't know PRNGs very well
15:07:53 <jmcarthur_work> is BBS considered "better"?
15:07:53 <Baughn> ..I think
15:07:59 <Baughn> Well, BBS is cryptographic
15:08:07 <Baughn> It's an adaption of RSA, basically. Same math.
15:08:11 <jmcarthur_work> oh
15:08:20 <Baughn> It's also incredibly slow.
15:08:29 <Baughn> Still, it's almost guaranteed to be unbreakable
15:08:49 <jmcarthur_work> does it work by repeated applications of encryption or something?
15:09:06 <Baughn> Not quite /that/ primitively, no. I'd suggest reading the wikipedia article.
15:09:11 <Baughn> It's really very simple
15:09:11 <skorpan> why does Control.Applicative have an alias for fmap?  is there anything about fmap that is particularly applicative?
15:09:12 * jmcarthur_work reads it
15:09:32 <ddarius> skorpan: Applicative functors are functors.
15:09:37 <siorai> skporpan it's particularly functor
15:09:45 <ddarius> Also, the alias is infix which works better for the applicative notation.
15:09:54 <ddarius> Actually, it's a pretty convenient alias altogether.
15:10:04 <Baughn> skorpan: Also, a common application of applicative is to say something like "MyConstrucor <$> ioFunction <*> otherIoFunction <*> unsafeLaunchMissiles"
15:10:04 <skorpan> it is
15:10:05 <opqdonut> there was an article floating on the net about the design of BBS
15:10:08 <opqdonut> by one of the authors
15:10:17 <opqdonut> tried to refind it a while ago but couldn't
15:10:19 <Baughn> skorpan: It'd look bad if <$> had to be written `fmap`
15:11:04 <Berengal> "Observing a sufficient number of iterates (624 in the case of
15:11:04 <Berengal> MT19937) allows one to predict all future iterates." - http://lists.squeakfoundation.org/pipermail/cryptography/2007-May/000555.html
15:12:23 <Baughn> "A bad PRNG is one that can be distinguished from true randomness by accident. A good one is where it takes enemy action. A cryptographic one is where it takes rubber-hose cryptanalysis."
15:12:50 <ddarius> "rubber-hose" ?
15:12:59 <Baughn> "Beating the key out of you"
15:13:11 <opqdonut> basically means beating the key out of somebody
15:13:24 <opqdonut> refers to a torture method where a rubber hose is applied to the soles of the feet
15:13:25 <Baughn> Or to put it another way, the computers are by far the strongest element of any well implemented security system
15:13:38 <ddarius> Baughn: Indeed.
15:13:53 <opqdonut> i'm guessing that term is due to schneier
15:13:56 <opqdonut> but i'm not sure
15:14:01 <c_wraith> I bet it's older
15:14:11 <Berengal> Baughn, they usually are, but they're also the most exposed, usually
15:14:28 <Baughn> Berengal: Sure, but it doesn't actually take that much work to make them safe
15:14:33 <Berengal> And they're up against other computers, which are pretty good at computing codes...
15:14:39 <Baughn> Simply picking haskell seems to have locked out 95% of the possible flaws. :P
15:14:59 <opqdonut> the problem is mostly that computer communications are really easy to eavesdrop
15:15:13 <opqdonut> and then serious computing power can be thrown against the messages
15:15:25 <Baughn> So, you need reasonably large keys.
15:15:25 <ddarius> Berengal: Social engineering is probably the most significant aspect of targetted intrusion attempts.
15:15:33 <Berengal> Baughn, I assume running something like multics on a PDP-11 removes the threat from most enemy computers...
15:15:49 * Baughn makes a mental note to move the protocol version check to /after/ negotiating a session key
15:16:01 <opqdonut> targeted is a good key word here
15:16:14 <opqdonut> vulnerabilities in computer cr
15:16:32 <opqdonut> *computer security make large-scale untargeted attacks possible
15:16:35 <opqdonut> bank trojans for example
15:17:13 <Berengal> Indeed. I sometimes poke servers for fun and giggles, but I never call up strangers asking for the bank account
15:27:32 <p_l> poke servers for fun and giggles... reminds me of Baughn's little Eurisko problem ;-)
15:28:57 <ricky26> Where does cabal store which packages are installed, and files when building?
15:29:11 * p_l only crashed friend's server and network with /dev/urandom and telnet...
15:29:25 <jmcarthur_work> most popular internet protocols are blatantly insecure
15:29:59 <Baughn> ricky26: ~/.ghc and /tmp, respectively
15:30:08 <ricky26> Aha
15:30:09 <ricky26> .ghc
15:30:26 * jmcarthur_work has had a project in the back of his mind for a long time to make a daemon that runs in the background and notifies you whenever sensitive information is seen and detected on the network
15:30:30 <Baughn> The actual data is in ~/.cabal, but the registry's ghc-specific
15:30:31 <ricky26> Well, ~/.ghc doesn't exist, not on windows, anyway. :S
15:30:43 <ricky26> Not in %USERPROFILE%
15:30:47 <jmcarthur_work> with a bunch of ettercap-like tools for inspecting everything
15:30:51 <p_l> jmcarthur_work: still, I can understand DirectConnect hub crashing because of "no space left on device" while logging, but router that died due to that traffic?
15:31:00 <jmcarthur_work> but so easy a caveman can do it
15:31:02 <kynky> some arent meant to be secure, but then we have layers, osi etc, just tunnel everything, ssh/vpn
15:31:03 <Baughn> ricky26: Search for a file called package.conf
15:31:06 <jmcarthur_work> and then put that into the hands of common folk
15:31:26 <jmcarthur_work> just to stir things up and open peoples' eyes
15:31:39 <ricky26> Wish my partitions were indexed XD
15:32:12 <ricky26> Oh, it's in the install folder : >
15:32:28 <Baughn> ricky26: Oh.. right
15:32:36 <jmcarthur_work> public wifi would never be the same again, if it gained any press
15:32:38 <Baughn> ricky26: I forgot. On windows, cabal defaults to system-wide installs.
15:32:56 <Baughn> ricky26: ..this is liable to change as soon as someone get arounds to it, but until then there'd only be a single package.conf
15:33:01 <ricky26> I am trying to get the package download from hackage
15:33:04 <ricky26> but it is failing
15:33:09 <ricky26> probably due to the lack of gcc
15:33:23 <jmcarthur_work> kynky, that's true, but most people don't even know about that stuff
15:33:37 <jmcarthur_work> i just wish people were *aware*
15:33:51 <Saizan> ricky26: which package are you trying to install?
15:33:59 <ricky26> 'download'
15:33:59 <ricky26> Sorry
15:34:09 <ricky26> Didn't make much sense when I said it earlier, did it? :P
15:34:20 <Saizan> well, not in relation with gcc :)
15:34:26 <Saizan> which command are you running?
15:34:32 <ricky26> cabal install download
15:34:49 <ricky26> But download contains lots of c files, which surely require GCC or equivalent to compile?
15:35:02 <Saizan> ah, the "download" package
15:35:09 <philed> Anyone know much about lambdabot? Is there a command to send raw text to an IRC channel?
15:35:57 <medfly> ?
15:36:11 <Saizan> ricky26: ghc comes with a bundled gcc on windows, iirc
15:36:12 <jmcarthur_work> :O i quit!
15:36:22 <Saizan> ricky26: which error are you getting?
15:36:36 <mauke> @msg #haskell t
15:36:36 <lambdabot> Not enough privileges
15:36:57 <ricky26> failed to find "download.h"
15:36:57 <philed> mauke: Cheers!
15:37:05 <ricky26> Might try a manual install in that case.
15:37:57 <philed> mauke: Where do you find these commands? Do you just go through the source code?
15:38:19 <mauke> in my memory
15:38:49 <philed> mauke: Can you do a memory dump for me so I can browse them?
15:39:02 <mauke> sadly, no
15:39:07 <mauke> @list
15:39:07 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:39:18 <philed> That list doesn't have the irc commands unfortunately.
15:39:33 <ricky26> Okay
15:39:41 <ricky26> Running Setup.lhs tells me download.h is missing
15:39:45 <ricky26> it's in the cbits folder where it should be
15:39:50 <ricky26> using --extra-include doesn't help.
15:39:51 <ricky26> o_O
15:40:22 <Berengal> New applicative sugar idea: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10795#a10795
15:41:47 <Berengal> Not quite sure how desugaring would work yet, but it's going to be a bit harder that desugaring do, but not much
15:42:02 <ricky26> @commands
15:42:03 <lambdabot> Unknown command, try @list
15:42:14 <lambdabot> Weeeeee!
15:42:26 <ricky26> That's the one
15:42:26 <ricky26> @list
15:42:27 <ricky26> o_O
15:42:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:42:32 <ricky26> There we go.
15:43:33 <ricky26> All I wanted to do was get some data from a specified URL
15:43:36 <ricky26> Silly haskell
15:49:07 <ddarius> Berengal: Looks ugly.
15:50:39 <jmcarthur_work> yeah i don't get it
16:03:29 <zzzs> i
16:04:11 <jfoutz> i thought you could skip that if you had s and k.
16:04:33 <zzzs> a newbie question, how do you pass a file handle around? i.e., i want to open a file once, then use that handle by different functions later on?
16:05:45 <jfoutz> once you've got it, you can call other functions with it as an argument.
16:05:47 <skorpan> zzzs: handle <- openFile "myFile"
16:05:56 <Vulpyne> Something like : h <- openFile "path/somefile" ReadMode
16:06:06 <Saizan> with a do
16:06:15 <Vulpyne> h will have the type Handle, and you can pass it to other functions.
16:06:46 <jfoutz> this is not exactly what you want, but might give you some ideas about how to structure your code. http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
16:08:45 <zzzs> hmm, how do you keep the handle from the do stmt in one function
16:08:53 <zzzs> then pass it to other functions
16:09:00 <zzzs> i understand you can use the handle in the same function
16:09:06 <zzzs> with the do stmt
16:09:18 <skorpan> do { h <- openFile "someFile" ReadMode; someOtherFunction h; }
16:09:38 <skorpan> in that example, someOtherFunction takes the file handle as its only argument
16:09:59 <skorpan> someOtherFunction has a type like Handle -> IO ()
16:10:02 <zzzs> skorpan: i want to keep the h around in f(), then call g()
16:10:12 <zzzs> but not in the same do block
16:10:24 <Saizan> zzzs: you've to pass it as an argument to g
16:10:56 <skorpan> i don't understand.
16:11:18 <zzzs> so i'd have something like f = do h<-openFile; then have g defined as g::Handle -> IO()
16:11:20 <skorpan> you want to keep the handle around in "f", then call "g"... but what should "g" do?
16:11:39 <jfoutz>  a = do {h<- getHandle; b h;}; b h = do { useHandle h}
16:11:46 <zzzs> so the return of f should be a fileHandle
16:11:51 <jfoutz> a calls b with the h
16:12:02 <skorpan> main = do { h <- f; g h }
16:12:08 <skorpan> f = openFile "SomeFile" ReadMode
16:12:24 <skorpan> f :: IO Handle
16:12:27 <skorpan> g :: Handle -> IO ()
16:12:51 <skorpan> is this what you were looking for?
16:12:57 <zzzs> yes
16:13:11 <skorpan> note that main can be written as: main = f >>= g
16:13:52 <zzzs> and is it possible to declare a data type that contains a fileHandle?
16:14:02 <skorpan> sure
16:14:06 <zzzs> so that the handle would be a field in the data type,
16:14:12 <skorpan> data Hello = Hello Handle
16:14:21 <zzzs> then you pass an instance of that data type to g()
16:14:37 <jfoutz> the irc bot article does that.
16:16:00 <zzzs> so f's signature would be Hello; and g's would be Hello->IO()?
16:16:14 <skorpan> f would be IO Hello
16:17:54 <zzzs> so f would be like f = Hello t where t = openFile ...
16:18:09 <skorpan> no, not really
16:18:24 <skorpan> f = do { h <- openFile ...; return (Hello h) }
16:21:36 <zzzs> so g would be like g (Hello h) = do hPutStr h 'blah'
16:22:11 <skorpan> yes
16:22:15 <skorpan> but "blah", not 'blah
16:22:16 <skorpan> '
16:22:21 <zzzs> yes
16:24:01 <zzzs> thanks skorpan
16:49:44 <zzzs> is it possible to in-place modify a list, then write to a file to log the modification all in one transaction?
16:50:30 <zzzs> i.e., dotx list a log = add a to the list, log the action, return the new list
16:50:31 <skorpan> are you sure you want to do in-place modification?
16:51:13 <zzzs> in-place to avoid memory allocation, especially if the list is big
16:52:25 <Saizan> no, lists are immutable
16:53:11 <skorpan> Saizan: really? impossible?
16:53:30 <zzzs> ok, so there are two questions then a) what are the mutable data structures b) how do you do this in one transaction
16:53:54 <Saizan> if we're talking about the type "[a]" there's no way, except poking at the heap via FFI
16:54:09 <zzzs> i was looking into STM a bit, but it's not clear how to do this -- the advSTM allows one to do onCommit, but is that the way?
16:54:30 <jfoutz> maybe your list should be a map?
16:54:57 <jfoutz> that's still not mutable, but it will only allocate a little bit of memory whereever you edit.
16:55:29 <Saizan> or Data.Sequence
16:55:54 <Saizan> there's also mutable arrays, not sure if there's one you can use from STM
16:56:39 <zzzs> i see, i can live with map i guess
16:56:50 <zzzs> so the transaction question remains
16:58:03 <Saizan> well, the standard STM interface doesn't allow any IO from within transactions, i've never used those other packages
16:58:12 <skorpan> okay so maps aren't mutable, but how can it be that they will allocate less memory than lists?
16:58:28 <Saizan> skorpan: because they are trees
16:58:47 <Saizan> skorpan: when you go changing an element you'll rebuild only O(log n) nodes
16:59:14 <Saizan> zzzs: you could just make your STM action return an IO action that does the writing
16:59:22 <skorpan> and why is that?  why am i not rebuilding the entire tree?
16:59:47 <Saizan> because there's no need to rebuild something if it didn't change
17:00:02 <zzzs> Saizan, can you elaborate ?
17:00:07 <ksf> "In this paper, we set out to contrast shooting yourself in the foot and eating candy..... to conclude, we have found that both shooting yourself in the foot and eating candy are activities"
17:00:12 <tommd1> Does profiling have any significant effect on memory use?
17:00:17 <skorpan> but if i append an element to the end of a list, only the last element in the list has to change, but still the entire list is rebuilt?
17:00:20 <Saizan> instead with lists all the elements before the node you want to change have a pointer to it, so those have to be changed too
17:00:36 <ksf> Hell avoiding wars is detrimental to science.
17:00:40 <ksf> grow some guts.
17:01:00 <Saizan> skorpan: does my last sentence clarify that?
17:01:22 <jfoutz> > 1 : [1..]
17:01:22 <lambdabot>   [1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:01:34 <skorpan> Saizan: no, it doesn't make sense to me if element N in a list has a pointer to N+3rd element in the same list
17:01:35 <jfoutz> > [1..] ++ [1]
17:01:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:01:43 <jfoutz> liar.
17:01:44 <DrSyzygy> > fix (1:)
17:01:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:01:52 <Saizan> skorpan: it's a singly linked list
17:02:03 <DrSyzygy> > fix (scanl (+) . (1:))
17:02:04 <lambdabot>   Couldn't match expected type `[a] -> [a]'
17:02:04 <Saizan> skorpan: every node has a pointer to the tail
17:02:04 <lambdabot>         against inferred type `[t]'
17:02:10 <DrSyzygy> Or maybe not...
17:02:13 <skorpan> Saizan: why?
17:02:18 <Saizan> skorpan: so if you want to use a different tail you've to update the node
17:02:33 <skorpan> why does every element have a pointer to the tail?  what's the point in that?
17:02:47 <skorpan> okay, wait, i may have misunderstood
17:02:54 <Saizan> skorpan: how could find the tail otherwise?
17:03:02 <Saizan> bu node i mean the cons cell
17:03:37 <ddarius> Who the heck writes: f $ (bar baz) ?
17:03:40 <skorpan> okay, so we have 1 -> 2 -> 3 -> 4 -> ... -> 10, which is a singly linked list of elements 1-10.
17:03:57 <Saizan> zzzs: something like   do action <- (atomically $ do log <- something; return (writeFile logfile log)); action
17:04:04 <Saizan> skorpan: yeah
17:04:10 <skorpan> if i want to add 11 to the end of that list, why don't i just traverse the list until i reach the last element and add it?
17:04:38 <Saizan> skorpan: because you update in place then references to the old list will see the 11 too
17:04:39 <jfoutz> but... but.. someone could be using it!
17:04:48 <Saizan> skorpan: so you've broken referential transparency
17:05:01 <Saizan> s/you update/if you update/
17:05:03 <skorpan> aha!
17:05:27 <skorpan> so that's why lists in haskell are *retarded*
17:06:32 <aavogt> if you only have to modify or remove the head, then they are efficient
17:06:41 <Axman6> rarrrgg! stupid uni servers and their lack of darcs >_<
17:07:08 <ksf> skorpan, that's what Data.Sequence is for.
17:07:27 <Axman6> i can install my own, but i need to have my default environment know where it is, and i can't figure out how to change it >_<
17:07:41 <ksf> IMNSHO, list shouldn't know about [], anyway. Just nuke that bastard and switch to streams/sequences
17:08:28 <jfoutz> huh.
17:08:28 <skorpan> are there any advantages to [] compared to Seq?
17:08:42 <Saizan> yes, for once [] is way lazier
17:09:13 <Saizan> being a simple structure, perfectly suited as reification of loops
17:09:19 <jfoutz> and fusion. maybe sequence fuses.
17:09:19 <ksf> Saizan, not if you don't abuse it for codata.
17:09:36 <Saizan> ksf: it's not an abuse
17:09:56 <Saizan> and inductive data doesn't have to be evaluated strictly either
17:10:22 <zzzs> Saizan: does that get the atomicity of a transaction? i.e., while the write of the file be inside the atomically block?
17:10:35 <ksf> er wait yes finger trees always have to know their size.
17:10:52 <ksf> so we should differentiate between lists, streams and sequences
17:11:16 <Saizan> zzzs: why should that matter? the write will print the log as it was when the transaction committed
17:12:15 <zzzs> Saizan, i want to make sure that the visibility of the changes won't be available to the outside world/threads before the write completes
17:14:00 <Saizan> zzzs: i'm not sure if that's possible without implementing some form of explicit locking, but i'm not an STM expert
17:14:45 <Axman6> anyone familliar with csh? :(
17:14:53 <skorpan> shit was so csh
17:14:53 <jokerGTA> can anyone help me with idea or function how to implement something
17:15:06 <jokerGTA> maybe there is a function for it
17:15:17 <zzzs> Sanzan: sounds like that to truely do system level stuff, you need to drop to C via FFI
17:15:20 <Axman6> i need to set my PATH, but i can't figure it out.
17:16:20 <Axman6> i'm using set PATH = ($PATH:/opt/gnat/gcc/bin), and i've also tried set PATH = ($PATH /opt/gnat/gcc/bin) and set path = ($path /opt/gnat/gcc/bin), and it keeps telling me "setenv: Too many arguments."
17:16:35 <Saizan> zzzs: i was talking about locking inside your application, and you can use MVar or TMVar for that
17:17:30 <Axman6> crap, ok seems to not be my fault after all
17:17:50 <zzzs> Saizan: so to implement locking explicitly rather than rely on STM's auto-magic?
17:18:05 <Axman6> bloody hell, why can't my uni just use a sane shell? they've got their own one, called sshsh i thik
17:18:08 <Axman6> n*
17:18:10 <jokerGTA> i'd like to have list of [function1,function2,function2,function1,function2] and depending on which function if its function1 then i want it to have parametars  and b but if its function 2 only b
17:18:27 <Axman6> well, not their own, but it's retarded
17:18:36 <jokerGTA> i am thinking about using fold for this but not too sure how to do it
17:18:53 <Draconx> Axman6, you set environment variables in csh like this: setenv foo bar
17:19:13 <aavogt> jokerGTA: you can't directly make a list containing things of different types
17:19:39 <jokerGTA> can i have list of functions that both return same type
17:19:57 <Axman6> setenv, ok, i'll try that, thanks Draconx
17:20:09 <Saizan> zzzs: can you rephrase?
17:20:12 <PeakerWork> jokerGTA: a list of functions has to have functions that return (and take) the same type
17:20:25 <Draconx> Axman6, but seriously, just install zsh in your home directory.
17:20:51 <jokerGTA> in my case function1 and function2 return same type.....but function1 take a and b....function2 takes only b
17:21:10 <Axman6> Draconx: how is that going to help. i can't seem to set what my sefualy shell is, and i need to know that to use darcs over ssh
17:21:33 <hackagebot> NewBinary 0.2.1 - A binary I/O library (JeremyShaw)
17:21:41 <murphy_> hi! I am having trouble building packages. After I run the "configure" command, my "dist" directory is left empty
17:21:48 <murphy_> and therefore I can't build at all
17:21:52 <Axman6> Fark! >_<
17:22:03 <murphy_> What do I need to do to remedy?
17:22:08 <aavogt> jokerGTA: you could use Either to stick them together:   [Left fun1,Right fun2,Left fun1] :: [Either (a -> b -> c) (b -> c)]
17:22:53 <jokerGTA> is there any example i could see of that
17:23:05 <Axman6> Draconx: is there something wrong with "setenv PATH ($PATH:/opt/gnat/gcc/bin)"?
17:23:17 <jokerGTA> stik them together how
17:23:55 <aavogt> > map (either 1 (($ (2,3)) . uncurry) $ [Left succ,Right (*),Right (+),Left (/2)]
17:23:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:24:02 <aavogt> > map (either 1 (($ (2,3)) . uncurry)) $ [Left succ,Right (*),Right (+),Left (/2)]
17:24:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:24:04 <lambdabot>    `GHC.Enum.Enum a'
17:24:04 <lambdabot>      a...
17:24:30 <zzzs> Saizan, to implement explicit locking via MVar, that's essentially roll-your-own concurrency control, right? which is what STM was supposed to relieved one from
17:24:39 <jokerGTA> oh.....
17:24:44 <aavogt> > map (either 1 (($ (2,3)) . uncurry)) $ ([Left succ,Right (*),Right (+),Left (/2)] :: [Either (Int -> Int) (Int -> Int -> Int)])
17:24:45 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
17:24:45 <lambdabot>    arising from a use o...
17:24:46 <Draconx> Axman6, yes.
17:24:56 <aavogt> > map (either 1 (($ (2,3)) . uncurry)) $ ([Left succ,Right (*),Right (+)] :: [Either (Int -> Int) (Int -> Int -> Int)])
17:24:57 <lambdabot>   No instance for (GHC.Num.Num
17:24:58 <lambdabot>                     ((GHC.Types.Int -> GHC.Typ...
17:25:01 <jokerGTA> is there any simpler way to do this
17:25:08 <Axman6> Draconx: "Bad : modifier in $ (/)."
17:25:28 <Axman6> maybe it is't csh. but i can't frigging find out what shell it actually is >_<
17:25:29 <Draconx> Axman6, Much like in other shells, parentheses indicate subshells.
17:25:31 <aavogt> > map (either 1 (\f -> f 2 3)) $ ([Left succ,Right (*),Right (+)] :: [Either (Int -> Int) (Int -> Int -> Int)])
17:25:32 <lambdabot>   No instance for (GHC.Num.Num
17:25:33 <lambdabot>                     ((GHC.Types.Int -> GHC.Typ...
17:26:03 <aavogt> > map (either ($ 1) (\f -> f 2 3)) $ ([Left succ,Right (*),Right (+)] :: [Either (Int -> Int) (Int -> Int -> Int)])
17:26:04 <lambdabot>   [2,6,5]
17:26:07 <aavogt> finally
17:26:08 <Saizan> zzzs: right, but the STM transaction model doesn't scope over external resources, that's just how it is
17:26:41 <Saizan> zzzs: it's very nice for internal comunication between threads though
17:26:53 <bockmabe> So I've been thinking about EDSLs like this one http://www.barrelfish.org/fof_plos09.pdf
17:26:55 <jokerGTA> could i have 2 lists...one list of functions...second list is the list of parametars
17:27:00 <aavogt> jokerGTA: perhaps you can apply your extra parameter to those 3 argument functions before combining the two types in a list?
17:27:06 <bockmabe> Doesn anyone know if something like that has been done for network protocols
17:27:14 <Draconx> Axman6, and due to csh magic, you need to do ${PATH}:blah
17:27:20 <Axman6> urgh
17:27:38 <bockmabe> Perhaps with some binary pattern match niceness
17:28:05 <Axman6> Draconx: setenv: Too many arguments.
17:28:14 <Axman6> when using setenv PATH (${PATH}:/opt/gnat/gcc/bin)
17:28:30 <murphy_> i feel like a jerk butting in, because it seems like you're having a nice conversation here, but I'm wondering if anyone can help me?
17:28:38 <Draconx> Axman6, Apparently you missed my comment about subshells?
17:29:04 <zzzs> Saizan, ok
17:29:04 <bockmabe> murphy_, your more diplomatic than I am :-).
17:29:20 <zzzs> how do you create a ByteString
17:29:27 <Axman6> Draconx: i saw it, but i don't know how to fix it. what do i need to have written there?
17:29:29 <Draconx> Axman6, lose the parentheses.
17:29:32 <murphy_> :) I'm trying. I have a stupid n00b problem and I can't remember what I need to do to solve it.
17:30:04 <zzzs> Saizan, there is this AdvSTM in hackage, which is supposely allow io with onCommit action
17:30:05 <Axman6> Draconx: still "too many arguments"
17:30:19 <murphy_> (e.g. the dist directory is not being created properly for any package)
17:30:35 <Saizan> zzzs: it might do what you need, i've never used it
17:30:46 <enolan> Where is the new locale library? Hackage has old-locale which says it's deprecated, but I don't see a locale package.
17:30:48 <Axman6> Draconx: i should check, running source .cshsh should be all i need to make sure it's working right?
17:30:53 <Draconx> Axman6, maybe $PATH contains whitespace?  Quote it.  This isn't /that/ much different from korn-style shells.
17:31:21 <Saizan> enolan: i think there isn't one
17:31:30 <Axman6> hmm, i think you were right, $PATH had accumulated some spaces
17:31:59 <enolan> That's seems rather silly.
17:32:02 <PeakerWork> escaping in unix shells is so horrible
17:32:08 <enolan> Oh well. Thanks, Saizan.
17:32:10 <Axman6> Draconx: that seems to have worked, thanks :)
17:32:42 <Axman6> hoorah, it's all working! thanks heaps Draconx
17:33:44 <Axman6> now, to get back to my original problem >_<. i don't suppose anyone knows how to check which OS you're running a makefile on is do they?
17:34:01 <enolan> uname?
17:34:08 <murphy_> yeah, that sound right
17:34:09 <Axman6> possibly
17:34:11 <Draconx> PeakerWork, zsh has a very nice feature: by default, it doesn't split variables when expanding.  This solves almost all my quoting gripes.
17:34:42 <Saizan> Draconx: split variables?
17:34:46 <jokerGTA> aavogt.....just to see how it works what if functions take and return same type
17:34:58 <jokerGTA> i just want to try it
17:35:08 <jokerGTA> if i use fold and my functions are inside the list
17:35:27 <jokerGTA> fold first parametar is a function so how would i do that
17:35:45 <aavogt> unless you need to collect your results, a map should be enough
17:35:56 <andyjgill> Does anyone know how to send a set of  ByteString's over a pipe, so that the can be read individually?
17:36:10 <aavogt> @type \parameter -> map ($ parameter)
17:36:11 <lambdabot> forall a b. a -> [a -> b] -> [b]
17:36:13 <jokerGTA> well my idea is to do this......result of function 1 i want to feed into function2 and so on
17:36:30 <aavogt> @type mconcat :: [a -> b] -> a -> [b]
17:36:31 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
17:36:31 <lambdabot>     In the expression: mconcat :: [a -> b] -> a -> [b]
17:36:41 <murphy_> btw, I think I solved my issue. It looks like the .ghc package file somehow got corrupted. Had to move it out of the way and rebuild. Leaving this here for my inevitable later google search. :)
17:36:49 <zzzs> if i have a function of signature f::m T -> IO Int, where T is Data T = T a b
17:36:53 <Draconx> Saizan, in, for example bash, suppose foo="foo bar baz".  When you write program $foo, foo is "split" at whitespace, and three arguments are passed to program as opposed to just one.
17:36:57 <zzzs> how do i access a b in f?
17:37:33 <aavogt> @type mconcat :: [a -> a] -> a -> a
17:37:34 <lambdabot>     Could not deduce (Monoid a) from the context ()
17:37:34 <lambdabot>       arising from a use of `mconcat' at <interactive>:1:0-6
17:37:34 <lambdabot>     Possible fix:
17:37:51 <aavogt> @type foldr (.) id -- jokerGTA
17:37:52 <lambdabot> forall b. [b -> b] -> b -> b
17:38:32 <jokerGTA> whats (.) id
17:38:45 <aavogt> those are two functions
17:38:48 <enolan> zzzs: Pattern matching. f (T a b) = a +b for example
17:39:27 <enolan> pattern matching on the left of = in functions is equivalent to case. f x = case x of T a b -> a + b
17:40:17 <aavogt> @type foldr (.)
17:40:18 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
17:40:23 <jokerGTA> fold is one function which i need to apply to my first element of my list(which is function) an one parametar
17:40:33 <aavogt> @type foldr (Prelude..)
17:40:34 <lambdabot> forall c a. (a -> c) -> [c -> c] -> a -> c
17:41:11 <zzzs> enolan, f's signature takes a monadic T, I tried f M (T a b), but ghc complained that M is not an inscope data constructor
17:41:34 <PeakerWork> @check (\x y -> x `rem` y == x `mod` y)
17:41:35 <lambdabot>   "Falsifiable, after 0 tests:\n1\n-3\n"
17:41:58 <enolan> Ah. Then you can't. You have to use whatever functions take Ts that are exported from it's module.
17:42:03 <PeakerWork> @check (\x y -> (let r = x `rem` y in if r < 0 then r + y else r) == x `mod` y)
17:42:04 <lambdabot>   "* Exception: divide by zero
17:42:12 <enolan> I totally misread you.
17:42:22 <PeakerWork> @check (\x y -> y == 0 || (let r = x `rem` y in if r < 0 then r + y else r) == x `mod` y)
17:42:23 <lambdabot>   "Falsifiable, after 12 tests:\n1\n-2\n"
17:42:57 <PeakerWork> > (1 `rem` (-2), 1 `mod` (-2))
17:42:58 <lambdabot>   (1,-1)
17:43:01 <enolan> zzzs: Which monad is it? You need some way to get from values in m to IO.
17:43:06 <kw317> what's the best way to typeset bits of haskell code in a latex document?
17:43:14 <PeakerWork> @check (\x y -> y <= 0 || (let r = x `rem` y in if r < 0 then r + y else r) == x `mod` y)
17:43:15 <lambdabot>   "OK, passed 500 tests."
17:43:19 <zzzs> enolan, STM
17:43:30 <enolan> :t atomically
17:43:31 <lambdabot> Not in scope: `atomically'
17:43:33 <ksf> "Sometimes the type checking can take a long time. Do not be afraid of this. If GHC seems to be taking ages to type check, go and make a cup of tea, research parallel type checking, over-clock your CPU or just buy a faster computer."
17:43:34 <ksf> heh.
17:43:48 <enolan> There's a function atomically :: STM a -> IO a
17:43:51 <Draconx> kw317, you might find the alltt and verbatim packages useful.
17:44:00 <enolan> It runs the transaction in question.
17:44:15 <ddarius> I haven't had GHC take a while to type check ever unless I was specifically constructing pathological cases for the type checker.
17:44:19 <ddarius> Now compile on the other hand...
17:44:51 <ksf> http://www.wellquite.org/sessions/tutorial_1.html
17:45:03 <zzzs> enolan, i don't know what you mean, are you saying do automatically first, then how do do pattern matching?
17:45:20 <kw317> Draconx: how about stuff like mapping \ to lambdas and so on?
17:45:28 <ksf> I've also heard that oohaskell takes ages if you've got a nonsmall number of fields in your objects.
17:45:30 <enolan> Yes. atomically. It means as an indivisible unit or all at once.
17:45:52 <ddarius> OOHaskell does type level computation.
17:46:07 <enolan> so f x = atomically x >>= \x' -> case x' of T a b -> return (a + b)
17:46:20 <enolan> Does that make sense?
17:46:26 <Draconx> kw317, I would use sed.
17:46:42 <tommd1> enolan: Are you going darcs hacking?
17:46:44 <kw317> Draconx: that's rather crude approach ;-)
17:46:45 <ddarius> GHC's type checker is not the most efficient implemntation of a logic language.
17:47:15 <enolan> tommd1: You forget I am one of 1% of haskellers that don't actually like darcs ;)
17:47:15 <Draconx> kw317, imo, if I was including haskell code in a document, I would want it to be haskell code rather than almost-haskell code.
17:47:21 <tommd1> oh, right!
17:47:49 <Cale> enolan: Why not?
17:47:57 <Cale> enolan: Have you used it since version 2 came out?
17:48:17 <Axman6> does anyone know how to set a variable in a makefile depending on which OS you're on?
17:48:59 <Axman6> google isn't being very helpful, the only answer i've found isn't working
17:49:11 <medfly> haha, what does that mean, 1% of haskellers? there are 20 haskellers that don't like darcs? :)
17:49:17 <enolan> I have. My problem is I believe the repository model is fundamentally flawed. As I understand it, a repo is a set of patches, and any merges are implicit.
17:50:12 <enolan> Merging and patch/commit dependencies should be explicit, because correct merges require understanding the semantics of the code in question.
17:50:25 <enolan> Also, I like pretty history graphs :)
18:00:41 <hackagebot> HSFFIG 1.1.2 - Generate FFI import declarations from C include files (DmitryGolubovsky)
18:01:05 <SmurfOR> I'm trying to represent an xml document with a simple tree like structure and I'm having some trouble pattern matching in a function i'm using that takes it in as an argument: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4399#a4399
18:01:06 <zzzs> enolan, i assume that you can do so f x = do (T a b ) <- atomically x; return (a + b)
18:01:50 <SmurfOR> (I know the code isn't that great but it's just for practice to learn)
18:01:51 <enolan> Yup.
18:03:10 <Saizan> SmurfOR: the problem is the use of [ ] instead of ()
18:03:40 <SmurfOR> Saizan, doh! thanks :|
18:03:55 <Saizan> "[x]" is the pattern matching a singleton list with element x
18:04:05 <Saizan> it's not a generic pattern for lists
18:05:11 <Saizan> so the [Empty] pattern has the right type
18:05:28 <Saizan> but it's redundant, you should just ahve a case for the empty list
18:08:28 <andyjgill> I am seeing a  "Couldn't match expected type `bytestring-0.9.1.4:Data.ByteString.Lazy.Internal.ByteString" error message. Has anyone seen this before? pureMD5 seems to have the same problem.
18:11:11 <ksf> andyjgill, seems like you've got multiple versions of bytestring installed and are trying to compile something against two different versions
18:11:23 <ksf> (but it's hard to be sure without seeing the whole error)
18:11:25 <ksf> @hpaste
18:11:26 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:11:57 <ksf> you can use "ghc-pkg check" to check for problems and then cabal install <foo> --reinstall to fix them
18:12:04 <andyjgill> ksf: it is strange; it works with ghc, but not with ghci.
18:12:24 <ksf> oh. delete all your .hi files
18:13:13 <BMeph> I was reading Cunha's paper, "Recursion Patterns as Hylomorphisms" (citeseer.ist.psu.edu/647038.html), and noticed where he makes a statement about coalesced sums:
18:14:55 <BMeph> "However, this is not the coproduct tipically (sic) implemented in lazy functional languages." Is this true - or rather, was it true in 2003?
18:18:57 <ddarius> BMeph: I believe what he is getting at is that _|_, Left _|_, and Right _|_ are all distinct whereas they wouldn't be for a coalesced sum.
18:19:18 <zzzs> so i have {do db<-newDB "test"; dbh<-openDB db; ...;} where newDB returns STM DB; and openDB's signature is STM DB -> IO(); ghc complains that the inferred type of db is DB, why?
18:19:47 <ddarius> BMeph: So, data CoalescedSum a b = InL !a | InR !b would correspond to the coalesced sum.
18:21:38 <aavogt> zzzs: going by the types, you need to write  { do db <- atomically (newDB "test"); ... }
18:22:37 <Saizan> zzzs: STM DB and DB are distinct type
18:22:49 <zzzs> aavogt, are you saying that one has to convert to IO () ?
18:23:02 <Saizan> zzzs: the first is the type of STM actions returning a DB
18:23:48 <Saizan> by the types you'd actually need "openDB (newDB "test")"
18:24:03 <Saizan> bu the type of openDB is a bit strange
18:24:19 <Jeb> @paste
18:24:20 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:24:38 <zzzs> Saizan, isn't my do stmts doing the equavlent of that?
18:24:48 <aavogt> true, somehow I read it as openDB :: DB -> IO()
18:24:57 <aavogt> which is wrong
18:25:17 <BMeph> ddarius: So, is it that you'd need to force the components to get that bottom behavior, that makes it more usual to just leavethe bottoms uncoalesced? :)
18:25:59 <Saizan> zzzs: no, you're running the newDB "test" action and passing the result to openDB, my expression is passing the newDB "test" action itself to openDB
18:26:20 <Saizan> x <- m is not the same as let x = m
18:27:02 <iaefai> Does anyone know if cabal/ghc would do anything that would cause compilation of C files to include some headers from the ghc framework?
18:28:43 <jokerGTA> does anyone know any tutorial or examples where it is shown how to make lists of functions
18:28:49 <ddarius> BMeph: If the language doesn't have a construct like seq, the separated sum is arguably more natural.
18:29:05 <ddarius> jokerGTA: You just do it.  There is nothing special.
18:29:24 <jfoutz> > map (\f -> f 1) [id,(+1),(*2)]
18:29:24 <lambdabot>   [1,2,2]
18:29:39 <jokerGTA> i know but i am having toruble understanding how it works
18:29:44 <jokerGTA> i am still new to haskell
18:29:54 <zzzs> Saizen, ah, i see, the monadic action
18:30:10 <ddarius> jokerGTA: It's just making a list.  That the elements are functions doesn't change anything.
18:30:34 <jokerGTA> well i have function1 and functions2......they both return same type
18:30:47 <BMeph> ddarius: That makes sense, once you "connect the dots". Thank you. :)
18:30:56 <jokerGTA> functions one takes parametars a and b..but functions 2 takes only b
18:30:58 <zzzs> Saizan, is it a bad way to do this when you say openDB's signature is strange -- i.e., STM shouldn't be part of the signature,
18:31:10 <jokerGTA> for simplicty now lets just say that both take same parametars
18:31:11 <rsnake> Hey guys
18:31:29 <jokerGTA> well it does
18:31:36 <Axman6> jokerGTA: someone already said earlier that you'd need to use Either:
18:31:37 <jokerGTA> lets say i want to use map functions
18:31:40 <jfoutz> jokerGTA: the list needs to be all the same type. take your function of two arguments and curry one onto it
18:31:56 <jfoutz> > map (\f -> f 5) [id,(+1),(*2)]
18:31:57 <lambdabot>   [5,6,10]
18:32:01 <zzzs> how do i get a ByteSting from a string?
18:32:04 <Axman6> :t [Left (+), Right id, Right (+2)]
18:32:05 <lambdabot> forall a a1. (Num a, Num a1) => [Either (a -> a -> a) (a1 -> a1)]
18:32:16 <stoop> Oh, ddarius is back.
18:32:16 <jfoutz> see how id only takes 1, but + takes 2?
18:32:27 <jokerGTA> yes
18:32:34 * ddarius doesn't know who stoop is ...
18:32:48 <rsnake> Is there a type for natural numbers?
18:32:48 <jokerGTA> no actually i dont
18:32:56 <jokerGTA> why is id not a function like other 2
18:33:07 <jfoutz> @type id
18:33:07 <lambdabot> forall a. a -> a
18:33:08 <ddarius> rsnake: Not in the "standard" library.  I believe there is a naturals package on hackage somewhere.
18:33:14 <jfoutz> @type (+)
18:33:15 <lambdabot> forall a. (Num a) => a -> a -> a
18:33:22 <jfoutz> @type (2+)
18:33:22 <lambdabot> forall t. (Num t) => t -> t
18:33:38 <Axman6> > pred 0 :: Word
18:33:39 <lambdabot>   * Exception: Enum.pred{Word}: tried to take `pred' of minBound
18:33:43 <rsnake> Thanks ddarius
18:33:52 <Saizan> zzzs: it depends on what you want to achieve, taking an action as parameter is a bit like taking a function, it's a way to construct the value, if openDB just executes it immediately it's more natural to take only the resulting value
18:34:10 <ddarius> rsnake: If you don't need unbounded numbers, you can use Data.Word
18:34:30 <ddarius> That will give you 8/16/32/64-bit unsigned integers.
18:34:51 <jfoutz> jokerGTA: you proably want [(function1 something), function2] so all the types agree
18:35:10 <jokerGTA> oh i can actually put parametars inside the list as well?
18:35:19 <rsnake> Thanks!
18:35:31 <jokerGTA> like you did [(function1 something), <- here
18:35:36 <jokerGTA> where something is parametar
18:35:41 <Axman6> yes
18:35:51 <jokerGTA> really???
18:36:06 <jokerGTA> ok i can do this then.....let me type this
18:36:10 <Axman6> of course you can, if f :: a -> b -> c, and x :: a, then f a :: b -> c
18:36:12 <jfoutz> > let plus = (+) in map (\f -> f 2) [plus 2, plus 3, plus 4]
18:36:13 <lambdabot>   [4,5,6]
18:36:15 <Axman6> uh, f x
18:36:53 <Axman6> jokerGTA: it's using partial application. just like when you say somethig like map (+5) xs
18:36:56 <jokerGTA> [(function1 a b),(function2 a),(function3 a b)]
18:37:14 <jokerGTA> is this legal what i just typed
18:37:18 <PeakerWork> > map ($2) [(+2),(+3),(+4)]
18:37:18 <lambdabot>   [4,5,6]
18:37:34 <PeakerWork> jokerGTA: sure, if the names are of the right types
18:37:36 <jfoutz> jokerGTA: depends on they types, but yes, that's fine
18:38:09 <jokerGTA> well my function 1 takes a......function 2 takes a b
18:38:46 <jokerGTA> whats ($2) for?
18:39:00 <jfoutz> @type ($2)
18:39:01 <lambdabot> forall a b. (Num a) => (a -> b) -> b
18:39:43 <jfoutz> it takes a function, that takes a number, and then calls that function with 2
18:39:52 <jfoutz> :t ord
18:39:53 <lambdabot> Char -> Int
18:40:08 <jokerGTA> i am gonna try this and see if it works
18:40:21 <jfoutz> > map ($99) [chr]
18:40:22 <lambdabot>   "c"
18:41:36 <ray> > ($99) chr
18:41:37 <lambdabot>   'c'
18:42:02 <zzzs> Saizen, are you saying that in my example, if i change the type of openDB::DB->IO(), it's better
18:42:23 <jfoutz> yeah... was thinking of lists of functions, but couldn't think of any other int->char, so it was a less exciting example.
18:42:26 <Saizan> zzzs: i'd have to see what openDB is doing to tell
18:42:30 <jfoutz> @hoogle Int->Char
18:42:30 <lambdabot> Data.Char chr :: Int -> Char
18:42:30 <lambdabot> Data.Char intToDigit :: Int -> Char
18:42:30 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
18:42:45 <jfoutz> ohh. to digit
18:42:57 <zzzs> Saizen, it just open's a file, and keeps the file handle
18:42:58 <jfoutz> > map ($99) [chr,intToDigit]
18:42:59 <lambdabot>   "c* Exception: Char.intToDigit: not a digit 99
18:43:06 <zzzs> using the filename from the DB
18:43:44 <jfoutz> map chr [0..9]
18:43:48 <jfoutz> > map chr [0..9]
18:43:49 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t"
18:43:53 <Saizan> zzzs: it'd be probably better then, afaict
18:44:01 <jfoutz> > map ($0) [chr,intToDigit]
18:44:02 <lambdabot>   "\NUL0"
18:44:15 <zzzs> but i'm getting errors when i do that"     Couldn't match expected type `IO DbHandle'
18:44:16 <zzzs>            against inferred type `AdvSTM DbHandle'
18:44:16 <zzzs>     In a stmt of a 'do' expression: dbh <- openDB2 db"
18:44:23 <Saizan> zzzs: so you can reuse the same db
18:44:39 <zzzs> i'm confused
18:44:54 <Saizan> zzzs: i can't help you with so small fragments of code
18:45:24 <Saizan> and if you change openDB's type you've to change its code accordingly
18:47:09 <zzzs> Saizan, here is the code snippets: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10799#a10799
18:47:25 <zzzs> i've pasted the errors at the end
18:49:50 <Saizan> zzzs: you need "db <- atomically (newDB "test")" in test2
18:51:00 <Saizan> and you can use Data.ByteString.Char8.pack (or Data.ByteString.Lazy.Char8.pack, depending on which BS you use) to convert a String to a ByteString
18:52:53 <zzzs> Saizan, is that because do <- always requires IO ()? so that i have to convert?
18:54:19 <Saizan> zzzs: it doesn't always require IO, do-notation works for any monad, though all the actions in the same do expression must be in the same monad
18:55:19 <Saizan> in fact you're using do-notation in the AdvSTM monad in newDB, and that's fine
18:56:42 <rsnake> I have a function that needs to return true if both its input arguments are the same, and do some additional checks if they aren't... how can I do that using pattern matching? "f x x = True" doesn't seem to work...
18:57:33 <zzzs> Saizan, i see, because the first one return AdvSTM, so it's inferring that the 2nd stmt should be of the same monad
18:57:40 <zzzs> that's why the error message
18:58:14 <jfoutz> rsnake: i sometimes wish it worked that way... but it dosn't. foo x y = if x == y then 1 else ...
18:59:17 <ray> rsnake: f x y | x == y = True
18:59:19 <reima> Or with guards: foo x y | x == y = True
18:59:42 <jfoutz> i always forget about guards
19:00:28 <zzzs> thank you Saizan
19:01:33 <rsnake> What if I have to do pattern matching in turn on the arguments if they're not the same?
19:02:10 <reima> rsnake: case
19:02:17 <jfoutz> i'd use a case, but the guard syntax would probably work as well.
19:02:23 <PeakerWork> or call another function
19:03:40 <rsnake> Ok, thanks everyone!
19:28:20 <c_wraith> Is there a good intro to STM around?
19:29:20 <Cale> The original paper isn't bad
19:29:43 * Cale finds a link
19:30:04 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
19:30:42 <Cale> The main difference between that paper and the existing implementation is that atomic has for some reason been renamed to atomically.
19:32:38 <roconnor> @seen dons
19:32:38 <lambdabot> Unknown command, try @list
19:32:46 <roconnor> preflex: seen dons
19:32:46 <preflex>  dons was last seen on #haskell 1 day, 6 hours, 59 minutes and 6 seconds ago, saying: hugs. sigh
19:33:12 <PeakerWork> Cale: atomically $ do
19:33:16 <PeakerWork> I suppose reads nicer
19:33:39 <Cale> It causes more indentation though, which is a little unfortunate.
19:33:43 <stoop> :t atomically
19:33:44 <lambdabot> Not in scope: `atomically'
19:33:52 <Cale> :t Control.Concurrent.STM.atomically
19:33:53 <lambdabot> Couldn't find qualified module.
19:33:55 <Cale> hmm
19:34:03 <roconnor> @hoogle atomic
19:34:03 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
19:34:03 <lambdabot> Foreign.C.Types data CSigAtomic
19:34:03 <lambdabot> Control.Exception data NestedAtomically
19:34:06 <stoop> haha
19:34:12 <stoop> @hoogle atomically
19:34:12 <lambdabot> Control.Exception data NestedAtomically
19:34:12 <lambdabot> Control.Exception NestedAtomically :: NestedAtomically
19:34:12 <lambdabot> Control.OldException NestedAtomically :: Exception
19:34:23 <roconnor> @hoogle STM a -> IO a
19:34:24 <lambdabot> Control.Exception evaluate :: a -> IO a
19:34:24 <lambdabot> Control.OldException evaluate :: a -> IO a
19:34:24 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
19:34:24 <Cale> :t Control.Monad.STM.atomically
19:34:25 <lambdabot> Couldn't find qualified module.
19:34:28 <Cale> odd
19:34:35 <Cale> Probably isn't loading the stm package
19:35:05 <Cale> Just as well, since you couldn't possibly make use of any of it from lambdabot
19:35:13 <Cale> atomically :: STM a -> IO a
19:37:30 <PeakerWork> Cale: I indent blocks under do 2 spaces, regardless of where the do is
19:37:50 <PeakerWork> Cale: though one can always place the "do" partially indented on the next line
19:37:57 <Cale> I usually start the do on the next line if it would force me to indent more than a few spaces
19:38:00 <Cale> yeah
19:38:06 <Cale> atomically $
19:38:10 <Cale>   do foo
19:38:13 <Cale>      bar
19:38:27 * ddarius never, ever puts the do on the same line unless it's only one line.
19:38:36 <LegendaryPenguin> do foo bar
19:38:40 <PeakerWork> ddarius: on the same as what?
19:38:47 <ddarius> As the first statement.
19:38:58 <PeakerWork> ddarius: atomically $ do \n first_statement   -- that's ok?
19:39:02 <ddarius> Yes.
19:39:42 <Cale> Except for 'of', I always put the layout keywords on the same line as the first line of the block which they contain.
19:39:43 <PeakerWork> as long as the indentation is at least semi-consistent and sane, I'm ok with it :)  I hate haskell-mode's stupid indentation though
19:40:41 <SamB_XP> Cale: even "where"?
19:40:55 <ddarius> I treat layout keywords like opening braces.  I never write if(foo)\n{ bar; \n} in C syntax languages.
19:41:17 <Cale> yes
19:41:28 <ddarius> Cale: Even the module where?
19:41:31 <Cale> Not that one
19:41:41 <SamB_XP> lol
19:42:07 <Cale> Though, I would if I were allowed more than one module per file.
19:43:41 * SamB_XP sometimes does the "$ \... -> do \n" thing 
19:43:56 <rsnake> Why isn't http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4401 allowed? (Last line says constructor for 'Variable' isn't defined)
19:44:25 <SamB_XP> though I guess that uses an extension, doesn't it?
19:44:30 <ddarius> Variable is a data constructor, not a type constructor.  It is a value level thing, not a type level thing.
19:44:47 <ddarius> SamB_XP: No ... (?)
19:45:08 <SamB_XP> ddarius: it doesn't use GHC's "nondecreasing indentation" thing?
19:45:09 <ddarius> rsnake: What I think you want is called refinement types which Haskell has no support for.
19:45:27 <ddarius> SamB_XP: I have no idea what you are talking about, so I'm going to say no.
19:46:36 <ddarius> rsnake: For that particular case, you can just put an Int where "Variable" is.
19:48:59 <rsnake> Ah... shame
20:04:06 <jokerGTA> aavogt map function didnt work ...i am trying to do it now with foldr function
20:04:57 <c_wraith> Huh.  TVars (and retry) are pretty smart.
20:05:28 <c_wraith> I just wrote a quick test with registerDelay and retry until it becomes true...  It doesn't spin.
20:05:40 <c_wraith> I like STM already
20:05:41 <c_wraith> :)
20:05:51 <jokerGTA> how to do foldr on this list [(function1 a b),(function2 a),(function1 a b)]
20:06:12 <PetRat> What is the Haskell Platform and how is it different from just installing GHC and the standard libraries?
20:06:19 <jokerGTA> where output of function1 a b would be input a in function2
20:06:30 <SamB_XP> PetRat: it's got more libraries!
20:06:40 <sjanssen> c_wraith: yeah, it's awesome how STM automatically makes polling efficient
20:06:41 <SamB_XP> but it also takes longer to install :-(
20:06:51 <sjanssen> it's like select() for any data in your application!
20:06:55 <Saizan> PetRat: and cabal-install
20:07:05 <SamB_XP> oh, yeah, and cabal install
20:07:33 <SamB_XP> it's awesome being able to just run cmd.exe and then type "cabal install xml" and bam, you've got an XML package!
20:07:48 <sjanssen> PetRat: there are no "standard libraries", that's what the platform is supposed to be
20:08:00 <jokerGTA> can someone help me with foldr function please...i have trouble getting it working
20:08:20 * roconnor is running nixos now
20:09:10 <PetRat> I'm trying to build Euterpea, which requires Happy. I'm told Happy is part of the Haskell Platform. I just tried "cabal install happy" but it failed because perl is required. Arg! Should I try installing the Haskell Platform instead of building happy from source?
20:09:48 <c_wraith> Actually, I've had issues installing the platform because happy doesn't build on my system, and I can't figure out why.
20:09:48 <sjanssen> PetRat: yes
20:09:51 <roconnor> I can do "nix-env -i haskell-xml-ghc6" and I get an XML lib
20:10:06 <sjanssen> there are probably even binary installers for Windows?
20:10:14 <roconnor> PetRat: you could also do aptitude install happy ?
20:10:21 <roconnor> oh windows
20:10:27 <roconnor> nevermind me
20:10:51 <rsnake> Linux + haskell = happy :)
20:10:55 <Saizan> perl required for happy?
20:10:55 <PetRat> Arg! How do I install the Haskell Platform? There's no help here: http://www.haskell.org/haskellwiki/Image:Platform.png#filelinks
20:11:35 <sjanssen> PetRat: http://hackage.haskell.org/platform/
20:11:36 <Saizan> PetRat: http://hackage.haskell.org/platform/
20:11:38 <PetRat> Saizan: that's what "cabal install happy" reports.
20:12:05 <roconnor> @where platform
20:12:05 <Saizan> @bot
20:12:05 <lunabot>  :o
20:12:05 <roconnor> :^)
20:12:06 <lambdabot> I know nothing about platform.
20:12:06 <lambdabot> :)
20:12:13 <aavogt> jokerGTA: apply the b values to your function1 type functions, so that you can build a list of functions :: [a -> a]
20:12:35 <aavogt> apply that argument _before_ building the list
20:13:00 <Saizan> @where+ platform http://hackage.haskell.org/platform/
20:13:00 <lambdabot> It is stored.
20:13:00 <PetRat> This is an endless, endless chase of problems. The windows Haskell Platform installer says it installs GHC 6.10. I'm using 6.8 because I couldn't get qtHaskell to build under 6.10.
20:13:01 <jokerGTA> do i leave same number of parametars inside brackets
20:13:26 <Saizan> ah, then no haskell platform for you
20:13:30 <PetRat> Anyway I can install Haskell Platform without installing GHC 6.10?
20:13:45 <Saizan> it's not supported
20:14:04 <Saizan> and i'd be surprised if it works
20:14:13 <PetRat> I guess I'll have to solve the qtHaskell build problem.
20:14:19 <jokerGTA> [(function1 a b),(function2 a),(function1 a b)]<-you see here in function1 i have a b parametars
20:14:24 <jokerGTA> do i just leave it as it is
20:14:52 * roconnor hands PetRat a lambda cookie
20:15:00 <roconnor> sorry about your software dependency woes
20:15:05 * SamB_XP hands PetRat a peanutbutter lambda
20:15:05 <PetRat> 6.8 includes OpenGL but 6.10 does not. I have to get OpenGL working.
20:15:13 <PetRat> .. under 6.10
20:15:24 <PetRat> thanks
20:15:25 <roconnor> wouldn't installing perl be easier?
20:15:31 <Saizan> the haskell platform has OpenGL i think
20:15:53 <PetRat> roconnor: I actuallly think it's a good idea to move to 6.10
20:15:59 <SamB_XP> Saizan: does it?
20:16:01 <PetRat> and solve qtHaskell build problem.
20:16:13 <sjanssen> PetRat: generally release tarballs won't require preprocessors like Happy, are you building "euterpea" (what is that?) from a release or a development version?
20:16:20 <PetRat> I want to move to 6.12 for dynamic linking soon.
20:17:01 <PetRat> Euterpea supports computer music. Instructions, which I am just trying to follow, are here: http://plucky.cs.yale.edu/cs432/software_resources.htm
20:17:07 <aavogt> jokerGTA: if I understand your problem, you should apply the b parameter to each function that has 2 arguments before making the list, then apply the function `foldr (.) initialAValue' to the whole list (which passes the `a' values in the way I think you described)
20:17:25 <Saizan> SamB_XP: http://hackage.haskell.org/platform/2009.2.0.2/haskell-platform.cabal <- yes
20:18:17 <c_wraith> Bah.  I can't use threadDelay from inside of STM
20:18:48 <jokerGTA> sorry man i am just having trouble understanding how it all works
20:18:53 <jokerGTA> i am very new to haskell
20:18:57 <sjanssen> c_wraith: hmm, does threadDelay even make sense in a transaction?
20:19:09 <SamB_XP> sjanssen: no, that's why you can't use it there!
20:19:25 <Saizan> ?type foldr (.)
20:19:26 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
20:19:31 <aavogt> @hoogle IO a -> STM a
20:19:31 <lambdabot> Foreign unsafePerformIO :: IO a -> a
20:19:32 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
20:19:32 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
20:19:42 <c_wraith> I mean, yes, there's unsafeIOToSTM
20:19:48 <c_wraith> But that's exactly what I don't want.
20:20:02 <Saizan> (.) is fmap again :O
20:20:13 <c_wraith> Err, not threadDelay.  registerDelay.
20:20:19 <c_wraith> That's the one I really want.
20:20:31 <c_wraith> As I want to set up timed reads from a TMVar
20:20:32 <SamB_XP> Saizan: YEAH
20:20:38 <SamB_XP> it's kind of a pain :-(
20:20:44 <SamB_XP> :t (.).(.)
20:20:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:21:05 <Saizan> i like it
20:21:14 <Saizan> > (+1) . [1,2,3]
20:21:15 <lambdabot>   [2,3,4]
20:22:05 <Saizan> ?hoogle registerDelay
20:22:05 <lambdabot> No results found
20:22:36 <c_wraith> GHC.Conc registerDelay :: Int -> IO (TVar Bool)
20:23:06 <c_wraith> The TVar it gives you contains False until the number of milliseconds given pass, then it contains True
20:25:44 <ddarius> They renamed Haskore?
20:27:36 <c_wraith> I guess...  Nothing in STM actually blocks without being rolled back first?
20:27:47 <ddarius> The paragraph at the bottom of this page is very upfront: http://plucky.cs.yale.edu/cs432/notes_vs__signals.htm
20:28:08 <aavogt> so if I want to make some instances for this type: newtype Fixed a = Data.Fixed.MkFixed Integer
20:29:02 <aavogt> I am ok to use unsafecoerce, since Fixed has the same representation as Integer?
20:29:17 <ddarius> aavogt: -Never- use unsafeCoerce.
20:29:45 <aavogt> ddarius: do you use generalizednewtypederiving?
20:30:34 <ddarius> aavogt: I don't think I've used it that often, but I would if it came up.
20:31:11 <aavogt> well, what I'm trying to do is the same as that extension, except the constructor for Fixed is hidden
20:31:30 <ddarius> I stand by my advice.
20:31:32 <aavogt> so I can't use standalone deriving to get my Data instance
20:31:58 <ddarius> Write the Data instance by hand.
20:32:39 <aavogt> I can't figure out how to do that seeing as the constructor isn't exposed
20:33:15 <ddarius> Your use of unsafeCoerce would just be a function Fixed X -> Integer, there is presumably already one, most likely fromIntegral.
20:33:20 <ddarius> (Similarly for the other direction.)
20:51:46 <Saizan> aavogt: for abstract types i wouldn't try to use the constructors in the Data instance
20:52:34 <Saizan> though there isn't a RationalRep ..
20:53:52 <aavogt> Saizan: can you help me write the Data instance, or point me toward a similar abstract Data instance?
20:57:51 <mmorrow> aavogt: use the derive command line program
20:59:48 <mmorrow> aarong: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10804#a10804
21:01:20 <mmorrow> hmm, the Typeable instance it's generating looks somewhat useless though (is it just not including the constructors?)
21:02:12 <mmorrow> well, i guess that's in the Data instance
21:03:07 <aavogt> mmorrow: the instance I want is for Data.Fixed.Fixed
21:03:30 <aavogt> which is just a newtype, but the constructor is hidden
21:03:33 <mmorrow> aavogt: right, so duplicate the exact definition of it in a scratch module, and run derive -dData -dTypeable on that
21:04:42 <mmorrow> aavogt: usually modules that i need to have access to the constructors but they're hidden, i just make my own version of that whole module
21:05:25 <mmorrow> i mean make a local copy of that module, and modify it (not rewrite my own version, of course ;)
21:05:27 <aavogt> well I don't want to have to duplicate all of the time package
21:05:39 <mmorrow> aavogt: ah, yeah that's annoying
21:05:52 <mmorrow> aavogt: what are you really trying to do here?
21:06:42 <mmorrow> wait, Data.Fixed is from time?
21:06:45 <aavogt> mmorrow: Serialize instances (in happstack) for some of the types from time
21:06:59 <aavogt> it is from base, but time uses Pico
21:07:11 <mmorrow> aavogt: heh, that's actually the exact same situation i've seen time lacking Data instances come up in before
21:07:50 <mmorrow> i think the time author should add them, or someone should make a modified time package
21:08:16 <mmorrow> because there's really no other (in the long run) feasible solution
21:09:13 <aavogt> I found some discussion that Data.Fixed was going to expose the constructor...
21:09:32 <mmorrow> is that Data.Fixed isn't exposed the only roadblock here?
21:09:39 <mmorrow> *Data.Fixed.Fixed
21:09:43 <aavogt> yes
21:10:05 <aavogt> well, actually I'm not blocked on the Data instance for Serialize, but for IxSet
21:10:13 <aavogt> which also needs Data
21:10:15 <mmorrow> right, IxSet is where this came up
21:10:33 <mmorrow> (guenni had this problem, not sure how he resolved it)
21:12:09 <mmorrow> aavogt: if this is a non-thowaway project, i'd consider making a local duplicate of Data.Fixed, making a my-time time pkg duplicate, and compiling with a dep on my-fixed pkg, then building happstack with my-time :/
21:12:17 <mmorrow> which sucks, but..
21:13:07 <mmorrow> hmm, or you mentioned unsafeCoerce above
21:13:25 <mmorrow> if you can somehow use that here to avoid package fork hell, i'd do it personally
21:14:35 <aavogt> this seems to typecheck with a reasonably constrained unsafeCoerce. It makes Fixed looks like Integer, but I wouldn't be surprised if there are problems: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10805#a10805
21:14:54 <mmorrow> yeah, it's not clear to me how unsafeCoerce would solve this problem
21:15:44 <mmorrow> oh right, using it in a hackified instance Data Fixed
21:16:09 <mmorrow> hmm, not sure, but i'd say it worth a shot before resorting to large-scale package hackery
21:17:13 <mmorrow> i'd say worrying about whether some abstraction leaks is moot at this point.. :)
21:17:47 <mmorrow> (since a (non-crippled) Data instance implies that the abstraction is no longer abstract)
21:20:38 <aavogt> there were some comments like that here: http://osdir.com/ml/libraries@haskell.org/2009-07/msg00119.html
21:23:08 <mmorrow> i'd look at this from the point of view of: (1) what do i need from a Data instance for Fixed in order to do what i need to do, (2) what do i need to do to make that so, (3) do that
21:23:34 <mmorrow> "i" being me personally for the particular program at hand
21:24:30 <mmorrow> since it seems like what IxSet needs is fundamentally at odds with abstract types
21:25:45 <mmorrow> maybe the root of the problem here is that Data/Typeable aren't built-in, but rather user-writable or something
21:27:09 <Optimoe> 
21:27:09 <Optimoe> Are you having trouble with finding the icon?
21:27:09 <Optimoe> First, try the Spotlight search feature, type 'Cycorder` to see if it's somewhere. There is an add-on in Cydia called `Spotbright` that will further enhance the spotlight search to include hidden apps.
21:27:09 <Optimoe> Sometimes the App is loaded with the wrong icon, and will instead look like another one of your apps, but the label will be correct. This is a problem with Apple's software and is being fixed soon.
21:27:11 <Optimoe> It could also mean that you had previously used Categories or Poof to hide or organize the icon, and you will need to restore it's hidden status. This info may help: http://thebigboss.org/2008/10/30/tip-missing-or-hidden-icons/
21:27:14 <Optimoe> Another option is to remove the package, reboot the iPhone, then install again and the icon may appear eventually =( Also, some say doing an iTunes sync can fix a stuck icon)
21:27:27 <mmorrow> aavogt: (and in step (3), there are no rules ;)
21:28:35 <aavogt> mmorrow: I think this instance probably does the right thing: http://osdir.com/ml/libraries@haskell.org/2009-07/msg00119.html
21:28:42 <Saizan> i think the easiest route is: avoid the need for Data
21:29:51 <mmorrow> Saizan: yeah, i agree
21:30:05 <mmorrow> aavogt: ah nice
21:30:30 <Saizan> Optimoe: wrong channel?
21:37:29 <SmurfOR> I can't figure out why this function is giving me this type error: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4403#a4403
21:39:25 <ivanm> SmurfOR: ummm, you're passing it a list when it expects a single value
21:40:14 <Saizan> SmurfOR: r1 and r2 are lists
21:41:11 <Saizan> SmurfOR: i think you want "and (zipWith childEq r1 r2)"
21:41:14 <Saizan> ?type and
21:41:15 <lambdabot> [Bool] -> Bool
21:41:20 <Saizan> ?type zipWith
21:41:21 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:41:26 <SmurfOR> Saizan, yeah i just rewrote that as a zipwith :)
21:41:36 <SmurfOR> my errors are all so simple D:
21:43:07 <Saizan> do you want some of my ones?
21:44:06 * Saizan doesn't have many type errors lately as he's writing in python
21:44:35 <Saizan> i've finished writing a webapp and only now i realized i was using an integer field like it was a string all the time.
21:44:43 <SmurfOR> :)
21:45:18 <c_wraith> in many contexts in python, that will work just about how you'd expect.
21:45:20 <c_wraith> Sometimes dangerous.
21:45:29 <Saizan> and it didn't even report errors on my machine, only when someone else in the team tested it
21:46:15 <Saizan> c_wraith: yeah, in this case i was misusing a unique id field as if it was an email.
21:46:35 <Saizan> s/email/email address/
21:47:56 <aavogt> doesn't this unnecessarily trigger the duplicate instance check: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10806#a10806
21:48:01 <aavogt> is this a ghc bug?
21:49:25 <Saizan> aavogt: not sure if it'd be considered a bug, but i agree there should be a way to do what you want there
21:49:52 <Saizan> aavogt: maybe start a discussion on the template haskell mailing list and see what SPJ thinks?:)
21:50:50 <SmurfOR> thanks so much again Saizan :)
21:51:37 <aavogt> Saizan: well I doubt that there is a sensible use case for any code that triggers that error
21:53:05 <aavogt> and since running that splice is going to produce code that will trigger the duplicate instance check, I don't really think that it matters whether ghc complains about it earlier than later
21:53:32 <Saizan> aavogt: you don't necessarily have to splice it as it is
21:54:01 <aavogt> that's true
21:54:23 <aavogt> you've discussed this behavior before?
21:54:59 <Saizan> and i think we could have a mode that relaxs lots of other checks, requiring only what needed to generate the TH AST
21:55:11 <Saizan> aavogt: no, too lazy :)
21:55:40 <bos> i have to say, working out how to use type families without reading any of the documentation is tricky.
21:56:52 <KNY> hey dudes, SharpRain is a troll. Heads up
21:57:08 <SharpRain> Hey guys
21:57:13 <SharpRain> I used to use PHP
21:57:19 <SharpRain> but I decided to make the switch to haskell
21:57:28 --- mode: ChanServ set +o bos
21:57:30 <SharpRain> I heard it is good for math related stuff
21:57:31 <SharpRain> right?
21:57:52 <Saizan> aavogt: what i wanted it for was e.g. $(instanceHierachy [d| instance Monad M where return = ..; (>>=) = ..; (<*>) = .. |] where instanceHierarchy will generate the Functor/Applicative and Monad instances, taking specialized functions from the quote and filling the rest with defaults
21:57:56 <stoop> Hrm.
21:58:10 <Saizan> aavogt: but that quotation complains that (<*>) is not a member of Monad
21:58:47 <Saizan> SharpRain: it's a general purpouse language so it's good for that too :)
21:58:53 <SharpRain> rhmm
21:58:54 <SharpRain> now why
21:58:58 <SharpRain> does nobody use it
21:59:03 <SharpRain> why is it not popular
21:59:04 <SharpRain> if it's so good
21:59:08 <SharpRain> that's what I was wondering
21:59:10 <SharpRain> it's weird.
21:59:36 <KNY> told you :)
21:59:44 <SmurfOR> not even that valiant of an attempt
21:59:45 <bos> that was weird.
21:59:51 --- mode: bos set -o bos
21:59:52 <drhodes> KNY == SharpRain?
21:59:53 <Saizan> in the old times the trolls were better
22:00:01 <dolio> @protontorpedo
22:00:01 <lambdabot> treid comon lisp. ansi common lisp bok by graham. it sucked
22:00:06 <SmurfOR> yeah he was "doing it wrong" that's for sure
22:00:55 <bos> zomg! does haddock not understand type families? oh, oops, what if i export the code?
22:01:14 <Saizan> what do you mean by "not understand"?
22:01:31 <aavogt> it gives warnings about them not being supported
22:01:44 <bos> Saizan: you will be astonished to hear that it won't generate documentation for a typeclass if you don't export it from your module.
22:02:05 * aavogt has never looked at the documentation for those classes/instances though
22:02:18 <ivanm> Saizan: it has no idea how to generate docs for type families
22:02:26 <ivanm> as such, it takes the cowards way out by ignoring them
22:03:52 <aavogt> bos: that happens even when you tell haddock to generate docs for non-exported things?
22:04:07 <bos> no, i was just dumb.
22:04:17 <bos> once i realised my mistake, it generated the docs ok.
22:05:26 <bos> i got fed this awful ICU patch which i accepted without reviewing it properly, and now i'm trying to undo the damage.
22:05:38 <ivanm> heh
22:05:39 <bos> the undoing involves using type families to give static type safety in places.
22:05:47 <ivanm> bos: as in it's in a release?
22:05:58 <bos> no, thank goodness.
22:06:02 <bos> that would be embarrassing.
22:06:35 <ivanm> heh
22:06:56 <ivanm> bos: but you accepted it as a good change to the API without considering how it was implemented?
22:07:34 <bos> no, i was just in a rush and looked at neither the api nor the implementation, which were both amazingly bad.
22:07:46 <SharpRain> No
22:07:46 <ivanm> heh
22:07:52 <ivanm> can't you un-apply the patch?
22:08:08 <bos> too late.
22:08:17 --- mode: ChanServ set +o bos
22:08:36 --- mode: bos set +b *!*n=Rain@unaffiliated/sharprain
22:08:36 --- kick: SharpRain was kicked by bos (bos)
22:08:52 --- mode: bos set -o bos
22:12:22 <aavogt> hmm, so the TemplateHaskell AST doesn't support -XStandaloneDeriving..
22:15:24 --- mode: ChanServ set +o bos
22:15:56 --- mode: bos set -b *!*n=Rain@unaffiliated/sharprain
22:16:07 --- mode: bos set -o bos
22:16:31 <ivanm> bos: getting soft and merciful in your old age? :p
22:16:36 <bos> that's m.
22:16:37 <bos> e
22:17:07 <mmorrow> aavogt: no, it's missing a few things that when you need them is a showstopper
22:17:12 <iaefai> Does anyone happen to have a mac that could try install GLFW? I am having trouble compiling it and can't find the source of the problem.
22:32:00 <ivanm> @. elite quote
22:32:00 <lambdabot> da8b|ER 5ayz: @qu0TE dAB8lEr
22:58:52 <ksf> that should teach me missing a couple of days of reddit.
22:59:06 <ksf> gpipe is way cool
22:59:27 <ksf> ...especially it suceeds in not being cuda-based.
23:04:25 <c_wraith> hmm.  stm is awesome, but...
23:04:40 <c_wraith> I actually don't need it in this app.
23:04:41 <ksf> it's io-bound?
23:05:14 <c_wraith> All the concurrency I have can be handled *easily* by MVar and Chan
23:05:51 <c_wraith> I have no cases where I'd ever need to rollback and retry something.
23:06:06 <ksf> no select on multiple inputs?
23:06:19 <c_wraith> Sure, but not with contention between them.
23:06:34 <ksf> but orElse is just a wonderful primitive
23:06:59 <c_wraith> The only contention I'd have is having multiple writers into a Chan, which isn't really an issue.
23:07:16 <ksf> but you might want to change your program later.
23:07:28 <c_wraith> If I do, and STM is the right way to go, I'll happily use it.
23:07:31 <ksf> ...and that's the reason you should use STM right away
23:07:34 <c_wraith> But I don't see a need for it right now.
23:07:49 <ksf> well it's hardly an inferiour choice over raw MVars
23:07:52 <c_wraith> Use TChan and TMVar just because I can?
23:07:58 <ksf> yep.
23:08:08 <ksf> and because atomically keeps your code clean.
23:08:09 <Saizan_> i think it'd be fairly easy to switch later, i think
23:08:16 <ksf> and STM composes.
23:08:42 <c_wraith> Like I said, STM is awesome.  I just don't think I need to retry, ever.
23:08:47 <sproingie> man, chapter 5 of RWH is kind of a disaster
23:09:22 <ksf> ...no need for atomically, at all?
23:09:28 <ksf> I tend not to believe that.
23:09:33 <Saizan_> well STM is not about using retry explictly most of the time
23:09:48 <ksf> or you've spend a lot of time designing your app to be completely lockless.
23:09:56 <Saizan_> it's about being able to get a consistent view without resorting to acquiring multiple locks
23:10:00 <c_wraith> No, just serial.
23:10:38 <jmcarthur> c_wraith: i kind of agree with your decision, but just so you know, TChan is sometimes much faster than Chan
23:10:54 <Saizan_> jmcarthur: really?
23:11:01 <c_wraith> Hmm.  I can sort of believe that.
23:11:08 <jmcarthur> so if Chan is a heavy part of your program it might be good to use TChan
23:11:28 <c_wraith> Well, the entire program will be IO and timer driven, and neither will be particularly fast.
23:11:41 <jmcarthur> Saizan_: yeah, STM avoids a lot of the consistency checks until the end of a transaction because it can. Chan doesn't have that luxury
23:11:58 <c_wraith> CPU load isn't going to be an issue.  I'd expect memory use to be my first limiting point.
23:12:34 <jmcarthur> Saizan_: i read it in one of the STM papers, but i can't recall which one now
23:12:46 <c_wraith> But, eh.  I have no reason to not use STM, I suppose. :)
23:13:55 <Saizan_> Chan also have some problems with readChan blocking unGetChan and isEmptyChan
23:14:05 <jmcarthur> i just made a small argument for STM's performance, but STM isn't super fast generally either ;)
23:14:08 <jmcarthur> that's my disclaimer
23:14:30 <c_wraith> Like I said...  I don't think CPU is going to be the limiting factor for this app, ever.
23:15:35 <mmorrow> jmcarthur: TChan faster than Chan?!
23:15:47 <jmcarthur> mmorrow: maybe we should try this in criterion
23:15:49 <mmorrow> jmcarthur: do you have a minimal complete example case?
23:15:52 <jmcarthur> not i
23:16:00 <mmorrow> i find that hard to believe
23:16:04 <jmcarthur> but i guess now i should look for the paper that said so
23:16:46 <mmorrow> oh nice, i'll run criterion on my Chan reimplem and compare it do Chan as well
23:16:52 <Saizan_> mh, i'd probably go with STM just to get more experience with it, it's hard to tell where you'd use a tool without having it readily available
23:16:53 <mmorrow> s/do/to
23:17:04 <cizra> Can I somehow get rid of Prelude.Right, so that the name would be available for reusing?
23:17:18 <c_wraith> import Prelude hiding ( Right )
23:17:37 <cizra> Thanks!
23:18:29 <c_wraith> That's also a good point, Saizan.  It's also completely true that I've only specced out about half of what this needs to do.  I might discover something surprising.
23:18:42 <ivanm> cizra: but if it's something in the Prelude, it's usually a bad idea to override it
23:18:55 <ivanm> (unless this is a module the outside world will never see, then it's not _that_ bad...)
23:21:25 <mmorrow> jmcarthur: well, i'd imagine that is the case when there's precisely zero contention
23:22:15 <mmorrow> jmcarthur: although, checking for consistency before a commit may still have more overhead than takeMVar, putMVars that Chan would do
23:22:42 <c_wraith> I'd bet *most* uses of Chan are zero-contention.
23:22:50 <mmorrow> :o
23:23:43 <mmorrow> well, i'd say you're half-right in the sense that they'll either have zero contention, or a crapload
23:23:51 <c_wraith> well, yes. :)
23:25:08 <jmcarthur> mmorrow: i was partially right. section 6.6 of Composable Memory Transactions claims that the early version of STM they had was on par performance-wise with MVar channels and used 50% of the heap space
23:25:28 <c_wraith> This is kind of like the study Sun did of java programs a while ago...  Where they found that some ridiculous percentage of the time, the size of List objects of various types didn't exceed 10.
23:25:52 <jmcarthur> mmorrow: and it's because the exception handling is simpler with the STM version
23:27:13 <c_wraith> So now you're telling me that if I'm concerned about memory use, I should go with STM? :P
23:27:22 <jmcarthur> not sure about that one
23:27:51 <jmcarthur> not really sure about any of this
23:28:03 <jmcarthur> and i don't know how much STM has changed since that paper was written, either
23:28:26 <jmcarthur> surely any changes would have been for the better, right? :)
23:29:11 <c_wraith> certainly!  For whatever definition of "better" was in vogue that day. :)
23:29:11 <mmorrow> jmcarthur: interesting
23:29:44 <jmcarthur> mmorrow: i recalled reading that because i had spent a week researching a pure haskell STM library
23:29:57 <jmcarthur> so i was really trying to pay attention to detail
23:30:19 <jmcarthur> that didn't get anywhere
23:30:30 <jmcarthur> i might try again later
23:31:11 <cizra> ivanm: I'm just writing a quickie to generate some shell commands. It uses directions.
23:31:31 <ivanm> cizra: right, so it's never going to be seen by the outside work?
23:32:37 <jmcarthur> mmorrow: i still think a proper criterion benchmark would be nice. if somebody else doesn't do it, i might someday
23:32:56 <iaefai> I have finally found out why GLFW is not compiling, a system include is including a Block.h that conflicts with a ghc include file, and the ghc include path is before /usr/include.
23:33:14 <mmorrow> iaefai: ooh, nice bug
23:33:20 <jmcarthur> ew
23:33:42 <iaefai> I haven't been able to find a way of modifying the order of the include paths, this looks to be a gcc problem, not cabal.
23:34:18 <iaefai> Any ideas on this, or is there a good place that I can get an answer for this? (haskell-cafe?)
23:42:02 <mmorrow> iaefai: an ugly but possibly quick way would be to temporarily rename /usr/include/Block.h to /usr/include/Block.h.ASDF
23:42:17 <iaefai> That is the file that needs to be included though
23:42:27 <mmorrow> oh, you /need/ Block.h..
23:42:41 <mmorrow> oh, ok
23:42:50 <mmorrow> so maybe temporarily rename the ghc Block.h
23:43:20 <mmorrow> (i'm assuming you don't need that one too, which i can't think of why GLFW would)
23:43:58 <iaefai> It wouldn't
23:44:12 <iaefai> I would love to find a real solution to this
23:44:21 <mmorrow> so i should of suggested this way around initially
23:44:48 <mmorrow> iaefai: i think the solution would involve finding out how to order the include paths in cabal
23:45:01 <iaefai> possibly
23:45:04 <mmorrow> which may be hard-coded to include ghc's path first
23:45:19 <mmorrow> in which case, maybe this is a cabal bug and not a GLFW.cabal bug
23:46:03 <mmorrow> iaefai: i'd file a cabal ticket and/or ask dcoutts what he suggests doing
23:46:40 <mmorrow> (and i'd also do the rename ghc's Block.h hack in the meantime)
23:46:43 <iaefai> ok, I should probably head to bed tonight, I will try to hit him up tomorrow, I have also posted something to the cafe.
23:47:04 <mmorrow> cool, night
23:50:31 <medfly> what does 'return ()' mean on Haskell?
23:50:51 <iaefai> mmorrow: I think I have a better idea of a way to fix the problem... according to cabal's docs, 'c-sources' is for C source files to build using the FFI, but that isn't what must be done.
23:51:07 <c_wraith> () is the only instance of the type ().  It's just a type with only one value.
23:51:12 <ivanm> medfly: you create a monad containing a value of ()
23:51:17 <ivanm> well, a monad instance
23:51:18 <c_wraith> return is a function that wraps its argument in the current monad.
23:51:21 <ivanm> @type return
23:51:22 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:51:44 <medfly> thanks
23:51:48 <ivanm> medfly: note that unlike C, etc., return does not stop executation of that function
23:51:56 <dolio> It constructs a burrito with no sour cream.
23:52:21 <c_wraith> I'd return that burrito as defective.
23:52:23 <ivanm> dolio: awwwwww
23:52:29 <ivanm> I like my burritos with sour cream!
23:52:41 <medfly> burritos have sour cream?
23:52:58 <ivanm> if you put it on they do
23:52:59 <ivanm> duh
23:53:00 <ivanm> ;
23:53:04 <ivanm> * ;-)
23:53:04 <cizra> ivanm: Not going to be seen. It's an one-time qucikie.
23:53:14 <ivanm> cizra: then go for it *shrug*
23:54:45 <ski> (ivanm : s/monad instance/monadic action/)
23:55:09 <ivanm> yeah, whatever it is
23:56:28 <sohum> @pl \x -> f (g y x)
23:56:29 <lambdabot> f . g y
23:58:03 <mmorrow> iaefai: there's also an "include-dirs:", which cabal might put before the ghc -I...'s
23:58:30 <iaefai> I have tried that, the ordering on the command line doesn't seem to matter
23:58:49 <iaefai> I think the easiest way would be to get GLFW compiled normally and use this 'dynamic' flag that is setup for it
23:58:59 <mmorrow> iaefai: hmm, i'd say this is a cabal bug then
