00:09:19 <FunctorSal> AIUI, one advantage of general types having no properties is that you get parametricity
00:09:25 <FunctorSal> (aka free theorems)
00:09:33 <FunctorSal> @ft a -> b -> a
00:09:34 <lambdabot> Done.
00:09:40 <FunctorSal> @free a -> b -> a
00:09:40 <lambdabot> Extra stuff at end of line
00:09:44 <FunctorSal> ;)
00:10:08 <Veinor> ... I don't get it @_@
00:10:54 <FunctorSal> you know that a function of type "a -> b -> a" must be "f x _ = x" or "f _ _ = undefined"
00:11:00 <FunctorSal> or undefined
00:11:59 <FunctorSal> because it can't do anything else with arguments or arbitrary type
00:15:32 <ksf> unsafeCoerce
00:15:47 <FunctorSal> s/or/of
00:16:03 <ksf> seq. par.
00:16:16 <FunctorSal> err I mean \x -> subRegex (makeRegex "or") x "of"
00:16:16 <Veinor> what does @free do?
00:16:27 <FunctorSal> ksf: yes I didn't want to complicate it needlessly
00:16:40 <ksf> @hoogle a -> b
00:16:41 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:16:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:16:41 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:16:55 <ksf> @hoogle a -> a
00:16:56 <lambdabot> Prelude id :: a -> a
00:16:56 <lambdabot> Data.Function id :: a -> a
00:16:56 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
00:17:03 <Veinor> haha
00:17:10 <Veinor> yeah, there's not much you can do that's a -> a
00:17:17 <FunctorSal> Veinor: currently it just fails
00:17:21 <FunctorSal> ;)
00:17:23 <Veinor> ;)
00:17:31 <ksf> trace works, too.
00:17:33 <Veinor> can you prove that id is the only a -> a function/
00:17:34 <Veinor> ?
00:17:58 <FunctorSal> but it makes theorems for free as described here http://en.wikipedia.org/wiki/Parametricity
00:18:06 <FunctorSal> (article is not great yet though)
00:18:10 <ksf> modulo exceptions and other operational stuff, yes.
00:18:28 <Veinor> yeah.
00:18:48 <ksf> @djinn Maybe a -> b -> Either a b
00:18:48 <lambdabot> f a b =
00:18:48 <lambdabot>     case a of
00:18:48 <lambdabot>     Nothing -> Right b
00:18:48 <lambdabot>     Just c -> Left c
00:18:52 <FunctorSal> Veinor: in haskell without seq, unsafeCoerce and such things, yes, either id or const undefined or undefined
00:19:06 <Veinor> what does djinn do?
00:19:16 <ksf> what free can't do.
00:19:20 <Veinor> ...
00:19:29 <ksf> @djinn a -> a
00:19:30 <lambdabot> f a = a
00:19:34 <Veinor> @djinn a -> b
00:19:35 <lambdabot> -- f cannot be realized.
00:19:35 <ksf> @djinn a -> b -> a
00:19:35 <lambdabot> f a _ = a
00:19:42 <Veinor> ahh.
00:19:49 <Veinor> @djinn a -> Int
00:19:49 <lambdabot> Error: Undefined type Int
00:19:59 <Veinor> pretty much what I expected, heh
00:20:00 <Peaker> > fromEnum (5::Integer)
00:20:00 <lambdabot>   5
00:20:05 <Peaker> > fromEnum (2^64::Integer)
00:20:05 <lambdabot>   0
00:20:14 <Peaker> Enum being convertible to/from Int really sucks, especially as Integral subclasses it!
00:21:05 <Veinor> > 2^64 :: Integer
00:21:05 <lambdabot>   18446744073709551616
00:21:05 <FunctorSal> @src Enum
00:21:05 <lambdabot> class  Enum a   where
00:21:05 <lambdabot>     succ                     :: a -> a
00:21:05 <lambdabot>     pred                     :: a -> a
00:21:05 <lambdabot>     toEnum                   :: Int -> a
00:21:05 <lambdabot>     fromEnum                 :: a -> Int
00:21:05 <lambdabot> [3 @more lines]
00:21:05 <Veinor>  @more
00:21:05 <FunctorSal> Peaker: what else is the purpose of Enum?
00:21:05 <ksf> Peaker, nag the h' guys to fix it
00:21:05 <Veinor> @more
00:21:05 <lambdabot>     enumFrom                 :: a -> [a]
00:21:05 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
00:21:05 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
00:21:05 <Veinor> @src enumFromThen
00:21:05 <lambdabot> Source not found. Take a stress pill and think things over.
00:21:07 <Veinor> :(
00:21:14 <Peaker> FunctorSal, succ/pred is not enough?
00:21:15 <ksf> toEnum and fromEnum shouldn't define arbitrary bounds.
00:21:36 <Peaker> FunctorSal, Even using Integer instead of Int is better.. all Enums and Integrals being isomorphic to Integers is bearable, but not to Ints
00:21:52 <maltem> There's sooo much to fix about the classes in the Prelude
00:22:09 <FunctorSal> Peaker: is there a law that they must be inverses?
00:22:18 <ksf> and if the h' guys don't do it we're gonig to have a library fork or something
00:22:32 <Peaker> FunctorSal, I'd expect there to be, so I'd suspect the class is not very formally specified
00:23:25 <Veinor> @src Int
00:23:26 <lambdabot> data Int = I# Int#
00:23:36 <ksf> hell yes they must, otherwise the ints aren't iso to the adt.
00:23:55 <Veinor> and I'm lost.
00:24:23 <FunctorSal> Peaker: ksf : but you can derive Enum for types with only nullary constructors
00:24:41 <FunctorSal> which would prove that they're not required to be inverses
00:25:02 <FunctorSal> (assuming the deriving mechanism is right)
00:25:16 <Peaker> FunctorSal, (fromEnum . toEnum) would still be id no?
00:25:33 <Peaker> FunctorSal, just (toEnum . fromEnum) might yield another constructor for a different type
00:26:11 <FunctorSal> (fromEnum . toEnum) can't be id unless the type has >= 2^32 constructors ;)
00:26:25 <ksf> yep. the inverse of course implies that you're staying in the right domain.
00:26:28 <FunctorSal> LONG TYPE
00:26:49 <ksf> toEnum isn't defined for all those.
00:27:04 <ksf> ...but it has to be an inverse for the defined part.
00:27:10 <FunctorSal> you could make toEnum either partial or cyclical, I guess
00:27:35 <FunctorSal> I'd rather have fromEnum :: Integer -> Int be the latter
00:27:48 <FunctorSal> > fromEnum (2^32+1::Integer)
00:27:49 <lambdabot>   4294967297
00:27:54 <FunctorSal> > fromEnum (2^64+1::Integer)
00:27:55 <lambdabot>   1
00:27:59 <FunctorSal> \o/
00:28:02 <ksf> you know, marshalling 64 bit C bitmasks to haskell is nerve-wracking, as they'd be cut off on 32 bit platforms.
00:28:11 <ksf> even worse, I'm not even guaranteed 32 bits.
00:28:19 <FunctorSal> ? use Word64
00:28:22 <ksf> Int is the worst type of all to use there
00:28:26 <ksf> I WOULD
00:28:33 <ksf> if the Enum class'd let me.
00:28:45 <FunctorSal> why does your marshaller need to use Enum?
00:28:53 <ksf> uh because c2hs
00:28:58 <ksf> ...but that's not the point.
00:29:02 <ksf> it's an enum.
00:29:11 <ksf> it's backed on the haskell side by an adt.
00:29:23 <ksf> and people should be able to use a standard interface.
00:30:44 <iaefai> Does haskell (ghc), on windows, have the ability to launch an application and redirect the stdin/out to be files in the ghc program?
00:30:46 <ksf> furthermore, TH can't get me the source of instances, so I can't use c2hs to generate anything, at all.
00:31:05 <FunctorSal> wait you mean it translates C enums to Haskell Enums?
00:31:13 <ksf> yep.
00:31:23 <ksf> or chains of defines.
00:31:31 <ksf> er no.
00:31:44 <ksf> you have to do a little hack with those.
00:32:06 <ksf> still, C enums can be, say, long long ints.
00:32:11 <FunctorSal> I thought the point of Enum was just to support [13..222] notation
00:32:55 <ksf> you only need succ for that
00:33:04 <ksf> ...which could have a type class on its own, btw.
00:33:09 <FunctorSal> meh can anyone get 'network' to install with ghc darcs?
00:33:32 <ksf> class Nat a where zero :: a ; succ :: a -> a
00:33:38 <FunctorSal> well you don't want it to call succ a million times for [10^6 .. 10^6+1]
00:34:01 <ksf> er you've got 10^6 to start out with.
00:34:01 <FunctorSal> Network/Socket.hsc:1707:45:
00:34:01 <FunctorSal>     Not in scope: data constructor `System.Posix.Internals.Stream'
00:34:25 <ksf> [2^128..2^128+3]
00:34:27 <ksf> > [2^128..2^128+3]
00:34:28 <lambdabot>   [340282366920938463463374607431768211456,3402823669209384634633746074317682...
00:34:47 <ksf> it's not using toEnum/fromEnum, obviously.
00:35:04 <FunctorSal> I see
00:35:30 <ksf> > [2^200..2^128+3]
00:35:31 <lambdabot>   []
00:35:38 <ksf> > [2^200..2^200+3]
00:35:39 <lambdabot>   [1606938044258990275541962092341162602522202993782792835301376,160693804425...
00:35:54 <ksf> now it's obvious.
00:36:23 <FunctorSal> ok, for arith sequence notation succ would be fine I admit
00:36:26 <ksf> ...at least I don't get past 1024, but I recognize that 65something thing.
00:36:59 <ksf> er 4096
00:37:28 <ksf> the bigger the numbers, the less I care about the less significant bits.
00:39:01 <ksf> ...other people count to three and then say many, I use a floating precision of three digits.
00:39:43 <FunctorSal> huh? for Integers you might well care about the last digit
00:39:55 <FunctorSal> bitmasks etc
00:40:21 <ksf> my programs do, but my built-in calculator doesn't.
00:40:28 <froystig> is it specified anywhere how builtin types (e.g. tuples) that are instances of a builtin typeclass (e.g. Ord) implement the class' methods?
00:40:47 <ksf> should be, in the h98 report
00:41:06 <froystig> ksf: i haven't been able to find anything too specific in there
00:41:57 <froystig> as an example, we know that we have instance (Ord a, Ord b) => Ord ((,) a b)
00:42:01 <ksf> must have been the animal rights movement, protecting the habitat of bugs.
00:42:39 <porges> ;D
00:43:34 <froystig> and if you play around for a while, you can get reason to believe that the way (<=) is implemented is "compare the first tuple component, and, in case of equality, compare the second"
00:44:21 <froystig> but there doesn't appear to be a readily available doc confirming that
00:44:23 * ksf would have thought so
00:44:49 <ksf> ...with more significant stuff traditionally being written on the left.
00:45:01 <FunctorSal> froystig: http://www.haskell.org/onlinereport/derived.html
00:45:22 <FunctorSal> 'The latter seven operators are defined so as to compare their arguments lexicographically with respect to the constructor set given, with earlier constructors in the datatype declaration counting as smaller than later ones.'
00:45:31 <froystig> FunctorSal: i've seen that --- it's not quite the answer to my question as far as i can tell
00:46:02 <froystig> first, it's talking about typeclass instances generated by |deriving|
00:46:21 <froystig> which isn't exactly how the Ord instance of a two-tuple is defined, afaict
00:46:44 <froystig> second, it seems to be saying that it compares the constructors themselves in the order they appear?
00:47:03 <FunctorSal> lexicographically within constructors AIUI
00:47:16 <froystig> so data Stuff = A | B deriving (Eq, Ord) means Stuff that is constructed with A is less than Stuff constructed with B
00:47:38 <FunctorSal> but yes it doesn't specify the instances for tuples
00:47:43 <mle> hm, why does Data.Set have map instead of just implementing Functor?
00:47:51 <froystig> but what does that say of data Stuff = A Int deriving (Eq, Ord) ?
00:48:09 <froystig> oh, *within* makes more sense
00:48:20 <porges> mle: Functor can't have restrictions on the parameters
00:48:28 <porges> mle: try writing the instance ;)
00:48:31 <mle> Ohhh, good call!
00:48:44 <mle> heh
00:49:03 <porges> FunctorSal: it does specify the instances for tuples, no?
00:49:15 <froystig> FunctorSal: that's clearer --- but are you sure that's what is meant in the report?
00:49:20 <FunctorSal> porges: only if tuples get their instance from 'deriving'
00:49:40 <porges> oh I see what you mean now :)
00:49:46 <FunctorSal> froystig: it also says 'Derived comparisons always traverse constructors from left to right'
00:49:59 <froystig> FunctorSal: yeah, that's more evidence :)
00:50:03 <FunctorSal> froystig: but you can check with -ddump-deriv
00:50:17 <froystig> FunctorSal: what is -ddump-deriv?
00:50:21 <froystig> sorry, new to this.
00:50:35 <FunctorSal> froystig: a ghc flag which dumps code generated by 'deriving'
00:50:52 <FunctorSal> module header: {-# OPTIONS -ddump-deriv #-}
00:50:55 <porges> FunctorSal: yes, they are specified with deriving (Ord,Eq,Bounded)
00:51:00 <porges> in the Prelude
00:51:05 <porges> http://haskell.org/onlinereport/standard-prelude.html
00:51:33 <froystig> FunctorSal: that's useful to know, thanks!
00:54:30 <froystig> FunctorSal: any way to use -ddump-deriv in order to see the code generated by |deriving| that's used in Prelude (namely in the declaration of the two-yuple)?
00:54:41 <froystig> er, tuple
00:55:18 <ksf> get the source, compile it.
00:55:52 <ksf> ...or write your own deriving clause and use -XNoImplicitPrelude
00:56:15 <ksf> (and -XStandaloneDeriving, iirc)
00:57:11 <FunctorSal> from ghc/libraries/base/Data/Tuple.hs: deriving instance (Ord a, Ord b) => Ord (a, b)
00:57:20 <ivanm> ksf: methinks you mean NewTypeDeriving
00:57:27 <ivanm> *GeneralizedNewTypeDeriving
00:57:38 <ksf> no that's for newtype.
00:57:39 <ivanm> or I could have no idea wtf you're talking about...
00:57:41 <ivanm> ;-)
00:57:52 <ksf> FunctorSalad's line above.
00:57:56 <ivanm> oh, right, you mean to randomly have deriving listed everywhere
00:58:02 <ksf> yep.
00:58:07 <Peaker> when using GADTs, ghc doesn't seem to understand that pattern-matches are exhaustive even without impossible constructors
01:01:02 <froystig> FunctorSal: does that tell us anything we didn't know before?
01:03:19 <FunctorSal> froystig: is it still in question that it uses lex. order?
01:04:25 <froystig> FunctorSal: i think so, unless i missed something
01:05:32 <FunctorSal> @check (\a b c d -> compare (a::Int, b) (c,d) == mappend (compare a c) (compare b d))
01:05:33 <lambdabot>   "OK, passed 500 tests."
01:06:04 <FunctorSal> I admit the evidence so far is not enough to base a nuclear missile control system on the Ord instance, but ;)
01:06:33 <FunctorSal> (the 'mappend' instance for Ordering does lexico. order, btw)
01:06:44 <froystig> FunctorSal: clever --- i submit :)
01:06:49 <Peaker> Disconnected, not sure my message went through: when using GADTs, ghc doesn't seem to understand that pattern-matches are exhaustive even without impossible constructors, GADT support in the type system seems quite incomplete, w.r.t inferring as much as possible from pattern matching constructors
01:07:25 <FunctorSal> the report could be clearer about what "lexicographical" refers to, yes
01:07:49 <ksf> yep GADT stuff isn't particularily trivial
01:08:02 <FunctorSal> but given that it means 'within constructors' and that the instance for (,) is derived, it should follow that (,) has the lexicographical order, no?
01:08:05 <ksf> there's whole papers written about it.
01:08:27 <Peaker> ksf, It seems to me GADT stuff is not quite ready/complete
01:08:52 <Peaker> I have different GADT constructors with different restrictions on the type arguments, and I'm not getting those restrictions back from my constructors when I pattern match them
01:09:16 <ksf> well I've read but not really grokked some of those. iirc some things are either prohibitively hard without breaking the rest, or even undecidable.
01:09:48 <FunctorSal> Peaker: ISTR the exhaustiveness checker is known to be broken
01:09:54 <froystig> FunctorSal: so to conclude, the two-tuple instance of class Ord is created by |deriving|, and |deriving| causes lex. ordering over the constructor arguments from left to right (after ordering based on constructors themselves in the order they appear in the type declaration)
01:10:11 <FunctorSal> froystig: that's my understanding, yes
01:10:20 <froystig> FunctorSal: same as mine, now that you've helped
01:10:26 <froystig> thanks!
01:10:40 * ksf draws an QED into the air
01:10:50 <ksf> everybody happy now?
01:11:02 <FunctorSal> no I want a square
01:11:27 <Peaker> FunctorSal, not just that.. it appears I can do this:  f x (SomeConstr g) = g (fst x)    but I can't do this:   f (x, y) (SomeConstr g) = g x
01:11:28 <ksf> I'm out of squares, but I can give you two triangles.
01:11:37 <Peaker> (Which seems like an arbitrary limitation of the type system)
01:11:37 <ksf> ...you gotta combine them yourselves.
01:12:11 <FunctorSal> Peaker: but are you sure such reasoning about GADTs is decidable? I haven't thought about it
01:12:23 <Peaker> FunctorSal, it seems like a purely syntactic difference from here
01:12:34 <FunctorSal> Peaker: I meant the exhaustiveness checks
01:13:05 <Peaker> FunctorSal, I think they should be, because you can just "try" putting each unused constructor in there with _ for everything, and see if it type-checks
01:13:17 <Peaker> if it doesn't, you're exhaustive
01:14:26 <FunctorSal> (I don't get the pair thing either)
01:15:49 <Peaker> FunctorSal, I have a signature like:   a -> SF a b -> IO b    and one of my SF constructors forces a to be a tuple, so I'd expect it'd allow me to pattern match on a tuple there.. but it doesn't, while still allowing pattern matching on it inside the definition body
01:20:57 <Veinor> @djinn a -> b -> c
01:20:57 <lambdabot> -- f cannot be realized.
01:21:03 <Veinor> @djinn a -> [a]
01:21:04 <lambdabot> Error: Undefined type []
01:21:06 <Veinor> :(
01:21:10 <Peaker> @djinn a -> Maybe a
01:21:10 <lambdabot> f = Just
01:33:49 <pabloh> how do u write this lamba:   \a b -> f a + f b ,  using only composition ?
01:37:30 <acon> hi, I'm new here and I just wanted to say that haskell is really nice
01:37:43 <therp> @pl \a b -> f a + f b
01:37:43 <lambdabot> (. f) . (+) . f
01:38:24 <acon> just started with haskell again a couple of days ago and just wrote a png encoder in 79 lines
01:38:34 <pabloh> what thaes  (. f)  means?
01:38:48 <mreh> acon, awesome
01:39:18 <therp> pabloh: right section of a binary operator: (. f) = (\a -> a . b)
01:39:23 <therp> acon: nice :)
01:39:35 <mreh> i read: i just started with haskell a couple of days ago and wrote a png encoder
01:39:35 <acon> mreh, therp: thanks
01:39:47 <therp> err sorry, "(. f) = \a -> a . f"  of course
01:39:48 <mreh> i started with haskell months ago and still haven't done much
01:40:00 <pabloh> therp, where can u read some about that?
01:40:13 <therp> pabloh: it's nothing special, it is in the haskell 98 report
01:40:35 <therp> pabloh:  in general http://www.haskell.org/onlinereport/
01:40:37 <pabloh> i never saw a point used next to a parentesis
01:41:14 <therp> pabloh: imagine it with division. (/ 2) is a one-argument function that halves its argument
01:41:15 <mreh> pabloh: it's a right section, when you supply the right argument to a infix operator
01:41:29 <mreh> yeah
01:41:39 <therp> pabloh: on the other hand (1 /) is the inverse function, that gives the inverse of its argument
01:41:45 <pabloh> ohhhhh
01:41:47 <pabloh> got it
01:41:54 <mreh> multiplicative inverse
01:42:02 <pabloh> is the same as (+ 1)
01:42:21 <therp> pabloh: yes, only that + is communitative and I can't show you the difference :)
01:42:28 <therp> commutative.
01:42:33 <pabloh> i know
01:42:40 <pabloh> (- 1)
01:42:42 <pabloh> :)
01:43:04 <therp> with - there some strange special cases.. (also in the language report)
01:52:45 <pabloh> (.) is associative, no?
01:57:25 <opqdonut> yes
01:59:33 <PetRat> I want to do a combination fold and takeWhile: I want to take values from a list, while accumulating them, and stopping when a certain bound is reached.
02:00:13 <PetRat> folds don't work (I don't think) because they must work on the entire list, and all the sublist functions don't have running computations. Or am I wrong?
02:00:15 <Taejo> PetRat: maybe use scanl?
02:00:28 <Taejo> > scanl (+) [1,1..]
02:00:29 <lambdabot>   No instance for (GHC.Num.Num [t])
02:00:29 <lambdabot>    arising from a use of `GHC.Num.+' at <...
02:00:33 <Taejo> > scanl (+) 0 [1,1..]
02:00:34 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
02:01:42 <porges> PetRat: folds don't have to use the entire list
02:01:48 <PetRat> takeWhile (predicate `pn` fst) (zip (scanl xs) xs)
02:01:57 <PetRat> above might work
02:02:13 <PetRat> (If I get the syntax right)
02:02:46 <PetRat> porges: what can "stop" a fold? Is that the right way to think about it?
02:02:57 <mreh> can anyone suggest how i use cabal-install to install a package, and then generate haddock documentation?
02:03:16 <porges> PetRat: just not needing the rest of the list :)
02:03:26 <mreh> without d/l the source files separately
02:03:28 <porges> eg. and = foldr (&&) True
02:03:43 <en0th> > foldl (+) 0 $ takeWhile (<=10) [1..100]
02:03:44 <lambdabot>   55
02:04:51 <PetRat> porges: I don't get it... can you explain how the fold algorithm knows that True && _ == True
02:05:43 <poe> PetRat: if the fold has to stop halfway, do you need the accumulator, or just the list contents?
02:05:44 <porges> because that's how && is defined
02:05:55 <PetRat> to explain more about my thought process, I'm envisioning threading an accumulated value through a list and stopping when it reaches a certain point, then take the elements in the orig list up to that point.
02:06:07 <PetRat> (list contents)
02:06:39 <en0th> so the condition is on the accumulator, if i understand.
02:06:46 <PetRat> en0th: yes
02:07:37 <PetRat> takeWhile (predicate `on` fst) (zip (scanl 0 (+) xs) xs)
02:08:01 <PetRat> the above is sort of the idea
02:08:09 <PetRat> but seems wordy
02:09:05 <mreh> I can't work out how to generate haddock doc with a package installed with cabal-install
02:09:38 <mreh> i dont think the feature exists
02:10:49 <Lemmih> mreh: --enable-documentation?
02:11:27 <mreh> what's the default?
02:11:38 <Lemmih> mreh: --disable-documentation.
02:11:52 <mreh> how did you find that out
02:12:04 <Lemmih> mreh: --help.
02:12:07 <mreh> educated guess
02:12:20 <mreh> how did you find out what the default was
02:13:08 <Lemmih> Oh, empirical evidence.
02:13:52 <mreh> reinstalling a whole library now :(
02:14:02 <Lemmih> mreh: Also, see 'cabal unpack' and 'cabal haddock'.
02:14:22 <mreh> cabal haddock only works on .cabal files as far as I can see
02:14:59 <mreh> oh, user inspection, i likes
02:16:23 <Lemmih> mreh: 'cabal install --enable-documentation' should place the documentation in ~/.cabal/share/doc/
02:16:38 <mreh> i worked that one out, thanks
02:16:43 <mreh> :D
02:17:39 <monadic_kid> hayoo! down?
02:17:46 <FunctorSal> cabal HEAD doesn't work with cabal-install HEAD for me
02:17:55 <mreh> monadic_kid, it was earlier
02:18:09 <monadic_kid> :/
02:18:12 <FunctorSal> (doesn't build, some identifiers not found in the things cabal-install tries to import)
02:18:54 <mreh> and i wanted to make a hayoo database :(
02:19:57 <monadic_kid> wanted to if a win32 GUID type existed already
02:20:02 <monadic_kid> *wanted to know
02:20:35 <mreh> nevermind that, stephen gately is dead
02:23:40 <Lemmih> FunctorSal: It was a WONTFIX last time I asked.
02:27:07 <FunctorSal> Lemmih: I don't get it... they're not going to work together again? ;)
02:27:50 <mreh> i know, boyzone will never be the same again
02:28:00 <mreh> it's just not fair
02:29:03 <Lemmih> FunctorSal: They want cabal-install HEAD to work with cabal STABLE.
02:30:14 <FunctorSal> Lemmih: hmm is there any way to get a working cabal-install with the head ghc then?
02:30:28 <FunctorSal> (since that comes with Cabal-1.8)
02:30:52 <FunctorSal> my existing cabal-install doesn't work anymore because "can't parse the output of ghc-pkg dump"
02:39:09 <Lemmih> FunctorSal: dcoutts might know.
02:55:47 <hackagebot> OpenGLRaw 1.1.0.1 - A raw binding for the OpenGL graphics system (SvenPanne)
02:56:19 <Fragsworth> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html gives haskell 0.184%
02:56:22 <Fragsworth> :(
03:16:12 <nvoorhies> I'm rather surprised that they rank haskell under J.  Has much of the legacy APL code out there on mainframes moved to J or something?
03:21:47 <bsdemon> Hello, I want to know how Haskell's RTS works, especially how RTS schedules haskell processes, which are blocked by I/O?
03:21:58 <bsdemon> Are there any papers?
03:25:58 <Peaker> bsdemon, they're usually called threads (if you refer to forkIO), not processes, and I believe it uses select (which IMO is a poor choice because it doesn't really scale)
03:28:16 <bsdemon> Peaker: i've heard of using select...
03:29:06 <bsdemon> Peaker: so all I/O funcs from System.IO are non-blocking, means they're not blocking entire RTS, only one thread?
03:29:56 <Peaker> bsdemon, afaik, they're "blocking" as far as you can see, but under the hood, they're non-blocking and just allow the scheduler to switch to another thread
03:31:17 <bsdemon> Peaker: that's what I mean, thanks
03:33:01 <gju> hi, i thought about implementing a simple stack data structure with haskell. is it somehow possible to store some kind of inner state? i don't think so, but how can it be done in haskell then?
03:34:34 <porges> gju: what's wrong with just using a list?
03:35:22 <porges> push = cons, pop = tail, peek = head
03:35:52 <gju> for practice purposes.
03:36:22 <gju> but anyways this list has to be stored somewhere?
03:37:19 <Peaker> gju, give it a name, pass it/return it :-)
03:37:30 <Peaker> gju, you might want to use the State monad for automatically passing it around
03:39:08 <gju> hmpf. :)
03:39:23 <Twey> type Stack a = [a]; pop :: Stack a -> (a, Stack a); push :: a -> Stack a -> Stack a; peek :: Stack a -> a
03:46:05 <dcoutts> FunctorSal: no, not yet, it's not been updated
03:48:18 <FunctorSal> dcoutts: ok :)
03:50:13 <FunctorSal> and all I wanted to do was work on TH ;) thought I needed the latest ghc to work with the latest TH
03:54:32 <Fragsworth> Man someone has to do something about making Haskell easier to learn
03:54:51 <Fragsworth> I've spent a week on it and I still feel relatively lost
03:55:40 <Fragsworth> PHP, in contrast, you can pick up and start using **in practice** in no time at all and with zero programming knowledge
03:55:57 <Fragsworth> granted it's pretty awful of a language =[
03:57:00 <Twey> Fragsworth: What have you been learning from?
03:57:17 <Fragsworth> the tutorials and videos on haskell.org
03:57:27 <Fragsworth> "A week" at a few hours a day
03:58:20 <gju> try this one: http://learnyouahaskell.com/
03:59:53 <ilid> Fragsworth: is there anything in particular you're having trouble with?
04:00:15 <Twey> http://book.realworldhaskell.org/read/ if you prefer information to elephants.
04:00:17 <Fragsworth> ilid: not really, it just takes a long time for each concept to sink in
04:09:16 <Alpounet> Fragsworth, don't forget to practice, much.
04:12:43 <mreh> much-ly
04:21:37 <Twey> Hm
04:22:11 <Twey> I just uninstalled and then reïnstalled haskell-dbus, and now I get: DBus.hsc:5:23: error: dbus/dbus.h: No such file or directory
04:22:55 <Twey> It worked just fine yesterday… T_T
04:23:17 <Twey> Ooh, comment.  I should really read those first.
04:27:08 <fxr`> :) hyena file server is faster than apache
04:28:16 <voker57> better compare to nginx
04:29:12 <sohum> @pl (\f -> f x)
04:29:12 <lambdabot> ($ x)
04:29:58 <fxr> voker57: I will
04:36:05 <Alpounet> btw, what does "pl" stands for, in "@pl" ?
04:36:38 <absz> pointless
04:36:43 <absz> aka pointfree
04:42:42 <shaleny> Does anybody know whether it's possible to call variadic functions (such as printf) using haskell llvm bindings? Can't find anyting about it.
04:43:27 <ivanm> type class hackery?
04:43:29 <ivanm> *shrug*
04:46:07 <shaleny> Actually this hackery is used in the library to implement 'call' function which must be able to call any function. But before this I must get a reference to llvm's function I want to call. With usual function I do something like this:
04:46:11 <shaleny>   puts :: Function (Ptr Word8 -> IO Word32) <-
04:46:11 <shaleny>           newNamedFunction ExternalLinkage "puts"
04:46:11 <shaleny> The question is how to get such reference to 'printf' taking into consideration that I must somehow specify its type.
04:46:40 <porges> i don't know how variadic functions are actually implemented in C
04:47:49 <porges> in C#, for example, the variadic functions just have an array that gobbles up the extra arguments, so the type is actually (..., ..., T[]) -> ...; perhaps C does something similar
04:49:37 <tibbe> do I need a language pragma if I want foralls in local definitions?
04:49:51 <Taejo> porges: I think the extra args are just put on the stack with an end-of-arguments marker
04:50:43 <tibbe> also, can I have lexically scoped type variables?
04:51:04 <shaleny> No there is not end mark actually.
04:51:04 <shaleny> It's up to the calee to deside how many arguments to take from the stack.
04:51:40 <Taejo> shaleny: oh, ouch
04:52:10 <Baughn> Well, not /quite/
04:52:46 <Baughn> C arguments are (typically) pushed on the stack right-to-left, so the stack pointer will point at the leftmost argument
04:52:55 <porges> i'd try emailing whoever wrote the LLVM bindings ;)
04:53:00 <pabloh> is it posible to create a functions that sums all the members of a tuple, for an arbitrary sized tuple ??
04:53:10 <Axman6> no
04:53:22 <Axman6> pabloh: what would its type be?
04:53:23 <Baughn> pabloh: If you /can/ sum them, that implies they're the same type
04:53:30 <Baughn> In which case you might as well use a list
04:53:47 <pabloh> i know i could use a list
04:53:53 <Axman6> f :: (a,a) -> a, and f :: (a,a,a) -> a?
04:53:55 <Baughn> Do so, then. ;)
04:53:59 <Peaker> Twey, do you think learnyouahaskell has elephants and no information? :)
04:54:22 <pabloh> i was thinking if is was posible to make a function for an abitrary tuple
04:54:23 <Peaker> pabloh, unfortunately, tuples in Haskell suck
04:54:30 <Twey> No; I just think that the proportion of elephants to information is much greater than I would like.  :þ
04:54:54 <Baughn> pabloh: That would require a better type-level language than we actually have, I'm afraid
04:54:54 <porges> Peaker: how is this the tuples fault
04:55:00 <Axman6> pabloh: (,) and (,,) are totally unrelated types
04:55:06 <Peaker> porges, because there are N-tuples rather than just 2-tuples
04:55:19 <Baughn> Axman6: Well, they shouldn't be. Tuples could be implemented as type-level arrays.
04:55:20 <pabloh> Axman6, son u cam make a type 'b' pass for (a,b) or (a,b,c
04:55:23 <pabloh> )
04:55:30 <porges> you can write everything in terms of (,) if you really want :P
04:55:32 <pabloh> at the same fuction
04:55:39 <Baughn> pabloh: Sorry?
04:55:52 <Axman6> huh?
04:56:06 <pabloh> Axman6, son u can't make a type 'b' pass for (a,c) or (c,d,a) using just one function?
04:56:11 <Baughn> No.
04:56:12 <pabloh> s/son/so
04:56:19 <Axman6> pabloh: no
04:56:20 <pabloh> ok i wanna know that
04:56:28 <Axman6> but, you could make a class for it
04:56:37 <Taejo> pabloh: a tuple is not a collection, it's a poor-man's record
04:56:44 <pabloh> i know
04:56:46 <Baughn> Which you'd need to redefine for each size of tuples
04:56:52 <tibbe> I have a function with local definitions in a where clause but can't convince GHC to accept type signatures for the functions. The code otherwise compiles (with type inference). Anyone have time to take a look at it?
04:57:01 <Baughn> ..we could really use some proper type-level arrays. :/
04:57:10 <Twey> File a bug?
04:57:10 <Axman6> class ToList a where toList a -> [b] ... but you'd need to qualify that somehow
04:57:11 <Peaker> porges, with 2-tuples only (HList style), you could use:  class Summable a where sum :: Num b => a -> b   and then have  instance Summable () where sum () = 0 ; instance Summable x :*: y where sum (x :*: y) = x + sum y   (or perhaps recursively call it on x too)
04:57:12 <porges> you could newtype tuples to single-typed tuples then write instances of Foldable ;D
04:57:13 <pabloh> Baughn, ok, i was going to ask to that
04:57:23 <Baughn> Twey: I don't think so. They'd ask me to implement it. :P
04:57:25 <Taejo> tibbe: no need to look at it, you want the ScopedTypeVariables extension
04:57:27 <Twey> Haha.
04:57:46 <tibbe> Taejo: I do have it. Do I need to put in explicit foralls?
04:57:49 <Taejo> tibbe: yes
04:57:55 <porges> Peaker: yeah, I'd like that too; just seemed an odd thing to say they "sucked" when it's really just the prelude's fault :)
04:58:22 <FunctorSal> , gmapQ id (1,2,3)
04:58:24 <lunabot>  luna: Inferred type is less polymorphic than expected
04:58:30 <Axman6> so, anyone reckon these changes could make any improvements in haskell? http://ocaml.janestreet.com/?q=node/71
04:58:37 <FunctorSal> , src 'gmapQ
04:58:38 <tibbe> Taejo: at the top level and in the where clauses or only in one of the two? What about class constraints (e.g. Monad m =>)? Should 'm' be universally quatified over as well?
04:58:41 <lunabot>  Class op from Data: gmapQ :: forall a . Data a => forall u . (forall d . ...
04:58:41 <lunabot>                                                                           ...
04:58:41 <lunabot>                                                               a -> [u]
04:59:10 <Taejo> tibbe: you don't want them in the where clause, but you do want them for m
04:59:32 <FunctorSal> , gmapQ (mkQ 0 (id::Int->Int)) (1,2,3)
04:59:34 <lunabot>  [0,0,0]
04:59:35 <Taejo> if you put them in the where clause, that'll introduce new variables (with the same name)
04:59:40 <FunctorSal> , gmapQ (mkQ 0 (id::Integer->Integer)) (1,2,3)
04:59:42 <lunabot>  [1,2,3]
04:59:53 <tibbe> Taejo: hmm
05:00:13 <tibbe> Taejo: I do think a paste is in order cause I don't get it :)
05:00:13 <Taejo> Axman6: it seems to me that I'd rather have deforestation
05:00:17 <FunctorSal> I hope the data instance isn't just manually defined for the first few tuples though
05:00:19 <sohum> @djinn (a -> b) -> (c -> b) -> (a,c) -> b
05:00:19 <lambdabot> f a _ (b, _) = a b
05:00:21 <Taejo> tibbe: ok
05:00:33 <Axman6> Taejo: which is what exactly? (i've heard the term, but i'm not sure i know what it is)
05:01:00 <tibbe> Taejo: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10613
05:01:01 <Taejo> Axman6: it means removing intermediate data structures (which tend to be some kind of tree, hence the name)
05:01:06 <porges> I've wondered if anyone has done any reasearch on "auto-chunking" (for want of a better term)
05:01:13 <Peaker> porges, nah, having N types for N-length tuples rather than just 2 types and composition sucks
05:01:13 <Peaker> porges, the type of (a,b,c) should be a composition of types, not an opaque type that needs its own Read, Show, etc instances
05:01:38 <Axman6> Taejo: got a example? is that like the map f . map g = map (f . g) optimisation rule?
05:01:55 <porges> Peaker: has anyone proposed it for H' ?
05:01:57 <Taejo> Axman6: yes, but more general
05:02:37 <Taejo> Axman6: dcoutts_'s paper at ICFP 2007 (Stream-Based Fusion or something) was quite readable, though it was on a specific instance of deforestation
05:02:58 <porges> "auto-chunking" being like the (lazy) ByteString optimization: packing parts of data structures together
05:02:59 <Axman6> yeah, i've seen the stream fusion stuff
05:03:09 <Axman6> still not totally sure why it's faster though
05:03:19 <Taejo> tibbe: try http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=10613#a10614 -- untested
05:03:38 <porges> Axman6: because it removes unnecessary lists
05:03:54 <Peaker> porges, I don't know
05:03:55 <Taejo> unnecessary lists => unnecessary allocation
05:04:02 <Axman6> doesn't it add unnecessary other stuff?
05:04:05 <tibbe> Taejo: so I don't need the local Monad constraints?
05:04:14 <Taejo> tibbe: you shouldn't
05:04:26 <Taejo> because the variable is already bound at the outer level
05:04:34 <tibbe> Taejo: compiles, thanks!
05:04:44 <Taejo> great
05:05:13 <sohum> @src num
05:05:13 <lambdabot> Source not found. I feel much better now.
05:05:14 <sohum> @src nub
05:05:15 <lambdabot> nub = nubBy (==)
05:05:19 <sohum> @src nubBy
05:05:20 <lambdabot> nubBy eq []             =  []
05:05:20 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:06:25 <Axman6> sohum: have you started the 2310 assignment yet?
05:06:42 <sohum> we may want to that that to PM
05:07:19 <tibbe> Taejo: so I got this right, scoped type variables are necessary when you want to give type signatures to universally quantified definition in e.g. a where clause?
05:07:39 <tibbe> Taejo: or is it when you want to refer to a type variable that's universally quantified in the top-level function signature?
05:08:55 <Taejo> tibbe: the latter. the point is that inside the where clause, it's *not* a universal type: it has to match the one at the outer level
05:09:39 <tibbe> Taejo: so without scoped type variables the compiler would read a local type signature as trying to refer to a universally quantified type?
05:09:48 <Taejo> exactly
05:09:57 <tibbe> Taejo: i.e. it would treat 'a' in a local type signature as a new type variable?
05:10:25 <Taejo> in Haskell 98, type variables are only in scope within a single signature, so yes
05:10:27 <tibbe> Taejo: and complain about rigid type variables?
05:10:35 <Taejo> yeah
05:10:36 <tibbe> Taejo: got it, thanks
05:26:15 <Alpounet> > nubBy (> 4) [1..10]
05:26:16 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
05:26:16 <lambdabot>         against inferred ...
05:26:43 <Alpounet> > nubBy (>) [1..10]
05:26:44 <lambdabot>   [1]
05:28:22 <Axman6> :t groupBy (<) ([1..10]++[2..5])
05:28:23 <lambdabot> forall a. (Ord a, Num a, Enum a) => [[a]]
05:28:27 <Axman6> > groupBy (<) ([1..10]++[2..5])
05:28:28 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,2,3,4,5]]
05:28:38 <Axman6> :t groupBy
05:28:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
05:28:45 <Axman6> > groupBy (>) ([1..10]++[2..5])
05:28:46 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10,2,3,4,5]]
05:28:59 <Axman6> oh right, forgot it was roken >_<
05:33:10 <Axman6> ok, so, theoretically, would defining something like map so that it matched (x:xs) before matching [] be slightly faster than the other way around? (ie, matching the most common case first should produce faster code due to less checking)
05:34:12 <Taejo> Axman6: I don't see how there'd be less checking. It *might* happen that you eliminate a jump.
05:35:04 <Axman6> well, i'm assuming there's some kind of checking of which constructor you've matched (even if it is only checking an int to see which constructor you have)
05:35:33 <Axman6> and, failing the check of [] then means you need to check for (:) next
05:35:53 <ivanm> Axman6: how is it "roken"
05:36:04 <Axman6> (lists arent such a great example, consider a more complex type with (many possibly) more constructors
05:36:04 <ivanm> because the 10 is there in that last grouping?
05:37:12 <Axman6> ivanm: because it takes the head, then uses that to find the rest of the group. so, you can't write something like breakIntoOrderedLists xs = groupBy (<=) xs
05:37:31 <ivanm> it does? :o
05:37:34 <ivanm> who did that?
05:37:37 <ivanm> @src groupBy
05:37:37 <lambdabot> groupBy _  []       =  []
05:37:37 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:37:37 <lambdabot>     where (ys,zs) = span (eq x) xs
05:37:49 <ivanm> aha, I see what you mean
05:37:56 <ivanm> rather than recursively checking each pair
05:37:58 <Axman6> which would give you breakIntoOrderedLists [1,2,3,3,4,1,2,3] = [[1,2,3,3,4],[1,2,3]] (very useful for say mergesort)
05:38:06 <ivanm> agreed
05:38:17 <Axman6> many people agree it's broken
05:39:34 <ivanm> but they don't agree on how to fix it? :p
05:39:38 <Stephan202> Related SO question about this: http://stackoverflow.com/questions/1316365/haskell-surprising-behavior-of-groupby
05:41:45 <Axman6> nice reply Stephan202 :)
05:42:36 <ivanm> quick! someone suggest it for Haskell'! ;-)
05:43:52 <Axman6> Taejo: anyway, the reason i was asking is because i'd assume that it would make more sense to have the the case statements used in the functions given reversed, so that Yield x s would be matched before Skip s or Done, because (i'd guess) that Yield x s is going to be more common
05:45:03 <Taejo> Axman6: hmm, interesting. Why don't you run some benchmarks (especially since we have an awesome new benchmarking library)
05:45:18 <Axman6> it's not so awesome on OS X :(
05:45:25 <ivanm> Taejo: he's still sulking that he can't make pretty charts ;-)
05:45:42 <ivanm> Axman6: quick, give bos a patch that lets you use gnuplot instead of chart!
05:45:43 * Axman6 CAN make pretty charts, but has to use Numbers.app
05:45:54 <Axman6> i'd like to... but i wouldn't kow how to
05:46:01 <ivanm> bah
05:47:31 <Axman6> Taejo: so, you think what i'm saying makes some sense?
05:47:39 <Axman6> i'll have to ask dons about it
05:47:51 <Taejo> I think it's possible, but I don't think you'd notice a difference
05:48:43 <Taejo> I don't know enough about GHC and CPUs
05:48:49 <Axman6> every little bit counts ;)
05:49:26 <Axman6> yeah, i can think of how _I'd_ implement matching constructors, but i don't have a clue how GHC does it
05:50:30 <Taejo> Axman6: do you know about pointer tagging?
05:50:55 <Axman6> ot really... i remember reading it uses the last 2 or 4 bits of the pointer though...
05:50:59 <Axman6> maybe...
05:51:27 <Taejo> yeah, to store which constructor the pointed-to value is
05:51:43 <Taejo> apparently it helps branch prediction a huge amount
05:51:54 <Axman6> i see
05:52:13 <Axman6> one day i'll do a compiler course and hopefully learn about these sorts of things
05:52:45 <Taejo> when I studied compilers, there was nothing on low-level optimization
05:53:03 <Taejo> this year it seems the course is pretty much all parsing
05:53:10 <Taejo> and not the good kind
05:53:27 <Axman6> :(
05:53:47 <ivanm> Taejo: what are you calling the "bad kind"?
05:53:59 <ivanm> non-monadic/applicative parsing (e.g. manual tokenising, etc.)?
05:54:07 <Taejo> ivanm: "learn to hack at JavaCC in 21 days"
05:54:24 <ivanm> *shudder*
05:55:01 <Axman6> we do some parsing in out formal methods course
05:55:31 <Taejo> I don't think the compiler-compiler approach is wrong, but if you're going to teach it in a third-year university class, you should teach some of the theory
05:59:01 <theclaw> haskell doesn't support nested guards?
05:59:25 <mauke> how would that work?
05:59:44 <theclaw> mauke: something like http://www.haskell.org/pipermail/haskell-prime/2006-July/001571.html
06:00:04 <theclaw> (but that mail is more than three years old)
06:00:22 <mauke> well, it doesn't
06:00:27 <mauke> and that syntax is ambiguous
06:00:55 <theclaw> you mean because of the otherwise statement?
06:00:56 <qp_pq> is anyone interested in writing some computational group theory  classes ?
06:00:59 <qp_pq> in Perl
06:01:05 <shaleny> Taejo, could you tell please which education institute you are telling about? Just interested.
06:01:05 <qp_pq> or maybe some haskell along the way
06:01:16 <qp_pq> I've already wrote a class for the Symmetric Group
06:01:30 <qp_pq> and it also plots S_n on a Cayley digraph
06:01:33 <mauke> theclaw: how is '| otherwise ...' different from '| predicate12 arg1 ...'?
06:01:37 <Taejo> shaleny: U Cape Town
06:01:48 <qp_pq> mauke: wow , you're in here as well
06:01:58 <qp_pq> mauke: you're dealing with haskell ? :)
06:02:05 <mauke> theclaw: that is, why is '| predicate12 arg1' not parsed as a sub-guard of predicate11?
06:02:10 <mauke> qp_pq: yes
06:02:52 <theclaw> mauke: yes, it's ambiguous, but this has been addressed in the thread if I understood that correctly
06:04:10 <theclaw> mauke: I was just interested whether it was already implemented ;)
06:04:15 <mauke> it isn't
06:04:24 <mauke> your best bet is nested 'case'
06:05:15 <theclaw> okay
06:05:45 <Berengal_> Nested cases can't try other branches if a nested one fails
06:06:22 <mauke> the proposal can't either because of the 'otherwise' requirement
06:08:10 <Berengal_> You could almost get this by putting the outer predicates in a where and using pattern guards
06:28:50 <akuhn> what is a good starting point to learn about the/a Haskell compiler?
06:29:15 <Zao> GHC has assorted developer wiki pages about GHC on the site.
06:29:21 <Twey> akuhn: Do you know Haskell?
06:29:38 <Zao> http://hackage.haskell.org/trac/ghc/
06:29:48 <Zao> The Commentary might be interesting.
06:30:11 <Twey> It would be wise to learn Haskell before trying to understand Haskell compilers, especially given that they tend to be written mostly in Haskell.
06:30:13 <Baughn> akuhn: I hear the Spineless Tagless G-machine is interesting
06:30:32 <akuhn> Twey: learned it from a textbook, no actual experience
06:30:44 <Twey> I see
06:30:45 <Axman6> time to learn it for real ;)
06:30:47 <Lemmih> akuhn: You can ask some of the Haskell compiler authors that hang out here.
06:30:55 <Twey> There's also #ghc.
06:32:35 <akuhn> I'll dive into the wiki then ...
06:32:49 <jokerGTA> can anyone help me with theis error i am having...it says that i have "duplicate instance declarations"
06:33:07 <mauke> yeah, so don't have duplicate instances
06:33:10 <jokerGTA> lol
06:33:11 <Axman6> akuhn: so, you don't really know haskell?
06:33:21 <jokerGTA> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10617#a10617
06:33:37 <mauke> jokerGTA: deriving (Show
06:34:21 <jokerGTA> yeah but if i lose that how would i make my Type derive the class show
06:34:27 <mauke> you don't
06:34:42 <mauke> don't you want to define your own instance of Show?
06:35:26 <jokerGTA> i thought i needed that there
06:35:35 <jokerGTA> i am only few weeks in haskell
06:35:44 <byorgey> "deriving (Show)" means you want GHC to write the instance of Show for you
06:35:47 <akuhn> Axman6: Axman6: what is knowledge of a PL? syntax? the APIs? the best practices? reading code? writing code?
06:36:00 <Twey> jokerGTA: Using ‘deriving’ will cause a default instance to be generated.
06:36:06 <jokerGTA> oh....
06:36:10 <jokerGTA> i didnt know that
06:36:12 <Twey> If you want to create your own specialised instance, then you don't want ‘deriving’.
06:36:19 <Axman6> akuhn: al of them, and you only really learn them from experience with the language
06:36:28 <byorgey> jokerGTA: if you ask GHC to do it for you and then do it yourself, it gets all in a huff.
06:36:38 <byorgey> "I thought you wanted ME to do it! =("
06:36:49 <jokerGTA> oh i see what you mean
06:37:00 * Twey chuckles.
06:37:26 <akuhn> Axman6: true enough
06:37:40 * Axman6 is saying this from experience
06:37:42 <jokerGTA> tx byorgey
06:43:02 <Twey> daf: Have you seen the new dbus-core package on Hackage?
06:43:12 <Twey> It looks to be a solid base for a binding.
06:49:37 * Twey grumbles again about System.Timeout.timeout using Int instead of Integer.
06:50:12 <Alpounet> you want infinite timeouts ? :-p
06:50:40 <Axman6> > round (1/0)
06:50:40 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
06:50:51 <Twey> > maxBound :: Int
06:50:52 <lambdabot>   9223372036854775807
06:50:55 <Axman6> > length . show . round $ (1/0)
06:50:56 <lambdabot>   309
06:51:29 <Twey> Alpounet: On 32-bit systems, maxBound :: Int allows, in µs, for about twenty seconds of timeout, maximum.
06:51:38 <Alpounet> oh, ok.
06:52:25 <mauke> that looks wrong
06:52:57 <Baughn> > (maxBound :: Int) / 10^6 / 3600
06:52:57 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
06:52:58 <lambdabot>    arising from a use o...
06:53:00 <mauke> > 0x7fffffff `div` 1000 `div` 1000
06:53:00 <lambdabot>   2147
06:53:06 <mauke> > 0x7fffffff `div` 1000 `div` 1000 `div` 60
06:53:06 <Baughn> > (maxBound :: Int) `div` 10^6 `div` 3600
06:53:07 <lambdabot>   35
06:53:07 <lambdabot>   2562047788
06:53:11 <mauke> 35 minutes
06:53:21 <Baughn> > (maxBound :: Int) `div` 10^6 `div` 3600
06:53:21 <lambdabot>   2562047788
06:53:34 <Baughn> Or lots and lots of hours. Well, that"ll do.
06:54:08 <Twey> 32-bit maxBound :: Int is 2147483647
06:54:21 <Baughn> > 2^31 - 1
06:54:22 <lambdabot>   2147483647
06:54:30 <Twey> ~ 2147 seconds
06:54:34 <Twey> > 2147 / 60
06:54:35 <lambdabot>   35.78333333333333
06:54:44 <Twey> Hm
06:54:51 * Twey scratches his head.
06:55:03 <roconnor> > abs minBound :: Int
06:55:04 <lambdabot>   -9223372036854775808
06:55:07 <Twey> There *was* something.  Honest.
06:55:30 <Twey> It's still daft, though: for a start, negative timeouts don't make much sense, so it should be using Words.
06:55:39 <Baughn> Preferably Word64s
06:58:45 <McManiaC> how can i test if a pattern is element of a list?
06:59:16 <McManiaC> like "("foo":"bar":_) `elem` ["a", "foo", "bar", "moep"] → True" ?
06:59:39 <luite> isInfixOf
07:00:01 <Baughn> There's no generalized way to do that for patterns in general, thouh
07:03:23 * akuhn overwhelmed :)
07:03:26 <McManiaC> hmm
07:03:36 <Axman6> akuhn: by?
07:06:29 <akuhn> Axman6: the compiler code
07:07:10 <FunctorSal> > let match (x:y:_) | x=="foo", y=="bar" = True; match _ = False in             any match (inits ["a", "foo", "bar", "moep"])
07:07:11 <lambdabot>   False
07:07:42 <FunctorSal> ?
07:07:58 <FunctorSal> > let match (x:y:_) | x=="foo", y=="bar" = True; match _ = False in             any match (tails ["a", "foo", "bar", "moep"])
07:07:59 <lambdabot>   True
07:08:06 <FunctorSal> ^^^^ McManiaC
07:09:46 <McManiaC> interesting
07:10:26 <FunctorSal> > let match ("foo":"bar":_) = True; match _ = False in             any match (tails ["a", "foo", "bar", "moep"])
07:10:27 <lambdabot>   True
07:10:35 <FunctorSal> thought you couldn't have strings in patterns...
07:12:00 <luite> > not.null $ [xs | ("foo":_:"moep":xs) <- tails ["a","foo","bar","moep"]]
07:12:01 <lambdabot>   True
07:12:12 <McManiaC> hehe
07:12:23 <McManiaC> nice
07:13:08 <FunctorSal> > not.null $ [() | ("foo":_:"moep":_) <- tails ["a","foo","bar","moep"]]
07:13:09 <lambdabot>   True
07:13:14 <Twey> akuhn: Unsurprising :þ
07:13:15 <FunctorSal> ;)
07:13:22 <Twey> FunctorSal: Why did you think that?
07:13:31 <luite> FunctorSal: ah thanks, I should've seen that myself :)
07:14:00 <FunctorSal> Twey: is it a new feature?
07:14:05 <Twey> No
07:14:09 <FunctorSal> :(
07:14:11 <Twey> It's always been there
07:14:13 <Twey> Hehe
07:14:33 <benmachine> they are just lists of literals
07:14:41 <FunctorSal> I think I've seen people matching on explicit lists of chars...
07:14:45 <benmachine> well, list literals I suppose
07:14:48 <FunctorSal> yes
07:14:51 <benmachine> well, you can do that too
07:15:11 <benmachine> sometimes it makes more sense, especially if you want to name one of the characters
07:15:15 <benmachine> or ignore one
07:15:16 <Twey> FunctorSal: Strings include nulls, so often if you're matching on them as part of a bigger list, you don't want to use string syntax
07:15:26 <benmachine> nulls what
07:15:40 <benmachine> > length ""
07:15:41 <lambdabot>   0
07:15:53 <Twey> "foo" is 'f' : 'o' : 'o' : []
07:15:54 <FunctorSal> > "\NUL"
07:15:55 <lambdabot>   "\NUL"
07:16:07 <FunctorSal> > ord '\NUL'
07:16:08 <lambdabot>   0
07:16:08 <Twey> List-nulls, not ASCII-nulls :þ
07:16:20 <Twey> Nils, rather
07:16:25 <benmachine> oh I see what you mean
07:16:26 <FunctorSal> oh right, so you do need lists of chars to match a prefix
07:16:33 <Twey> Aye
07:16:50 <Twey> Explicitly-consed ones, at that.
07:19:27 <FunctorSal> can ghc's typechecker (accessed through ghc package) be persuaded to display the type of a local expression? (the local expression may be invalid at toplevel)
07:20:11 <FunctorSal> > let x = 5 ::Int in {{{ YOU ARE HERE ( x+2 ) }}}
07:20:12 <lambdabot>   <no location info>: parse error on input `{'
07:20:25 <Beelsebob> FunctorSal: not that I know of – whenever I've wanted that I've type checked the free variables, then set up an environment to check the local expression in
07:21:43 <FunctorSal> Beelsebob: you descend into the AST and add any variables to the environment of the TcM monad?
07:22:00 <Beelsebob> yep
07:22:08 <Beelsebob> which is... ugly
07:22:19 <FunctorSal> sounds like a job for a zipper maybe
07:22:51 <stanv_> i need `foreach' function for list
07:22:58 <NEEDMOAR> I was looking at Data.MemoCombinators source ( http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/src/Data-MemoCombinators.html ), begining by bool :: Memo Bool. How does it work? How do I know what ghc will memoize? Where is it defined?
07:23:02 <FunctorSal> I tried to use multirec to make a zipper but somehow ghc doesn't like to compile a hundreds-of-lines pattern functor ;)
07:23:06 <Twey> > map (* 2) [1..5]
07:23:07 <lambdabot>   [2,4,6,8,10]
07:23:07 <Axman6> stanv_: map?
07:23:16 <byorgey> stanv_: try 'map', or 'mapM' or 'mapM_'
07:23:23 <stanv_> hm
07:23:24 <byorgey> depending what you want to do.
07:23:25 <FunctorSal> (out of memory)
07:23:40 <Twey> Or ‘forM’ or ‘forM_’ (which are just flipped mapM*)
07:23:51 <byorgey> stanv_: what exactly are you trying to accomplish?
07:23:52 <Axman6> stanv_: what do you want to do?
07:24:11 <tavelram> fold might also be applicable, since he might want to ackumulate something... since map is more restrictive than foreach..
07:24:27 <Twey> Perhaps, perhaps
07:24:30 <mauke> :t mapAccumL
07:24:31 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:25:23 <FunctorSal> maybe a haskell-src-exts based zipper generator would be useful?
07:25:41 <stanv_> I need: call `elem' for each element of one list, in other list. simple solution: (sort xs) == (sort ys)
07:26:16 <Twey> map (`elem` ys) xs?
07:26:23 <FunctorSal> (but zippers for mutually rec types make my head hurt somewhat)
07:26:49 <stanv_> map (`elem` y) xs  and repeat for all ys
07:27:03 <Twey> y is a list of lists?
07:27:13 <Twey> Er, ys is a list of lists?
07:28:13 <stanv_> not.not...  :((( right: elem y1 xs, than elem y2 xs, than elem y3 xs.  where ys = [y1,y2,y3]
07:28:30 <stanv_> and get [True,True,True]
07:28:43 <Twey> so map (`elem` xs) ys
07:29:09 <McManiaC> hehe
07:29:10 <stanv_> Twey: ah, yes :)))
07:29:43 <stanv_> Twey: :))
07:29:53 <Twey> ‘map’ loves you.
07:29:59 <Twey> As does its big brother, ‘fmap’.
07:31:42 <Baughn> fmap is not map's big brother, it's map's evil CEO
07:32:03 <Twey> Seeking to make map redundant?
07:32:10 <Baughn> Yes
07:32:16 <Twey> Heheh
07:33:36 <zoonfafer> :t map
07:33:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:34:29 <Baughn> :t [map,fmap]
07:34:30 <lambdabot> forall a b. [(a -> b) -> [a] -> [b]]
07:36:01 <Twey> Beautifully obscure demonstration.  :þ
07:36:24 <Baughn> :t fmap.fmap.fmap
07:36:25 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:37:14 <FunctorSal> stop fmapping
07:37:45 <Veinor> @hoogle a -> b
07:37:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:37:46 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:37:46 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
07:38:51 <FunctorSal> @tell mmorrow yet another expandSyns :o http://hackage.haskell.org/packages/archive/derive/2.0.1/doc/html/Language-Haskell-TH-ExpandSynonym.html   -- btw, derive also seems to have a full converter haskell-src-exts <--> template-haskell
07:38:51 <lambdabot> Consider it noted.
07:41:52 <Baughn> :t fmap fmap.  fmap
07:41:52 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
07:42:22 <hackagebot> HUnit 1.2.2.1 - A unit testing framework for Haskell (RichardGiraud)
07:42:24 <Baughn> ..okay, now that's just weird.
07:44:17 <PeakerWork> @type fmap fmap
07:44:18 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
07:45:00 <Baughn> :t fmap.fmap fmap
07:45:01 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
07:45:13 <fusion5> hi, if defining a data, you can easily show by using "deriving show". But what to use to define a custom show function for it?
07:45:21 <Baughn> fusion5: instance it instead
07:45:30 <benmachine> :t (fmap .) . fmap
07:45:31 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
07:45:38 <fusion5> ok Baughn, trying
07:46:15 <Baughn> :t ((.).(.))
07:46:16 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:46:25 <Baughn> ..what
07:46:27 <Baughn> :t (.)
07:46:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:46:29 <benmachine> :O
07:46:36 <Baughn> Ohh. Right.
07:46:42 <benmachine> heh
07:46:44 <Baughn> \bot redefines . as fmap. ^^;
07:46:59 <benmachine> :t Control.Category.(.)
07:47:00 <lambdabot> Couldn't find qualified module.
07:47:04 <benmachine> :(
07:47:14 <SamB_XP_> I thought Cale had stopped doing that ?
07:47:26 <benmachine> evidently he started again
07:47:27 <PeakerWork> (.)=fmap is confusing. I like the Category generalization better
07:47:27 <Baughn> Apparently, it didn't take.
07:47:41 <benmachine> PeakerWork: agreed
07:47:51 <benmachine> I prefer <$> for fmap
07:47:56 <Baughn> What's that, arrow composition?
07:48:18 <mauke> :t (Control.Category..)
07:48:19 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
07:48:24 <SamB_XP_> Baughn: a superclass of arrow composition
07:48:46 <Baughn> Yes, I sseee.
07:49:23 <benmachine> there is a newtype Kleisli m a b wrapping a -> m b which has . as <=<
07:49:25 <benmachine> ish
07:49:31 <Baughn> Allegory? Dryad?
07:51:40 <en0th> :t pseq
07:51:41 <lambdabot> forall a b. a -> b -> b
07:51:48 <Cale> I noticed that I can import the Prelude qualified in L.hs again :)
07:52:01 <Baughn> Cale: But, gods, /don't/!
07:52:06 <Cale> Why?
07:52:12 <Baughn> It confuses the newbies.
07:52:13 <Baughn> And me.
07:52:26 <Cale> We can sort them out (and you too :)
07:52:54 <Baughn> > succ . [1,2,3] -- Also, this seems plainly /wrong/.
07:52:55 <lambdabot>   [2,3,4]
07:53:00 <Cale> why wrong?
07:53:12 <Baughn> . is arrow composition. Or category composition.
07:53:19 <Baughn> It.. /feels/ wrong. ;_;
07:53:45 <PeakerWork> Cale: because it doesn't feel like mathematical func-compose that it looks like
07:53:55 <Baughn> That. Thanks.
07:54:12 <benmachine> it seems redundant anyway since we already have an infix fmap
07:54:15 <Cale> It's quite a lot like function composition.
07:54:39 <Berengal_> We need a fmap operator. I suggest ↑
07:54:41 <burp> how do I compose functions with lambdabot?
07:54:51 <Cale> burp: Using (.)
07:54:59 <burp> ok
07:55:23 <Baughn> But be careful, since it composes a lot more than just functions
07:55:23 <Cale> I generalised the definition of (.) in lambdabot, but function composition is a special case
07:55:25 <benmachine> ↑ is a pretty cool idea
07:55:27 <benmachine> might steal that one
07:55:28 <PeakerWork> Berengal_: is that Hebrew zain? :)
07:55:41 <Berengal_> PeakerWork, it's an arrow pointing upwards
07:55:53 <Berengal_> In analogy to lift
07:55:58 <Cale> I like (.) because it is easy to type
07:56:12 <PeakerWork> Berengal_: very similar to the Hebrew letter, though, which in contemporary Hebrew culture means "dick" or "bummer"
07:56:33 <Cale> Also, the functor law that fmap (f . g) x = fmap f (fmap g x) becomes: (f . g) . x = f . (g . x)
07:57:26 <Cale> and  fmap id x = x  becomes  id . x = x
07:59:34 <yottis> isn't there already <$>
07:59:50 <Cale> There is <$>
08:00:16 <Cale> But of course, it's doing the same job as map and (.) and fmap and liftM and liftA
08:00:36 <Cale> all of which are instances of the same thing with slightly different types
08:00:56 <benmachine> is the Control.Category.. basically fmap as well?
08:01:16 <Cale> I say we should have just (.) and map, and they ought to be the same thing, which is functorial lifting :)
08:01:30 <Cale> Control.Category.. is different
08:01:44 <PeakerWork> Cale: why not have map=fmap, and Control.Category.. for the normal .?
08:01:49 <Cale> It's something strange, as Control.Category isn't just an implementation of categories.
08:01:57 <PeakerWork> Cale: it also has the law (f . g) . x = f . (g . x) :-)
08:02:59 <stanv_> is it possible compare two functions for equality ?
08:03:04 <Cale> I don't really know what the heck Control.Category is defining, from a mathematical perspective. It's a bit like a category whose objects are the objects of Hask and whose composition is a natural transformation...
08:03:17 <Cale> stanv_: Generally no.
08:03:30 <Cale> (it's not computable)
08:03:31 <Berengal_> stanv_, short anwer: no. Long answer: yes, with some restrictions
08:03:48 <PeakerWork> stanv_: if your function's input is an instance of (Bounded,Enum), and your output is an instance of Eq, then ya :)
08:04:40 <benmachine> assuming that enumFrom minBound actually covers the whole type
08:04:47 <Berengal_> You can do pointer-equality, but that can only give you yes or maybe.
08:05:19 <Berengal_> You can also exhaustively search the domain, which can give you a no or maybe (or bottom)
08:05:19 <stanv_> PeakerWork: yes, it is
08:05:22 <Cale> Whether there's even a safe way to do pointer equality is questionable.
08:06:02 <PeakerWork> benmachine: are Enum instances allowed to not cover it? (Isn't the Double instance considered wrong for not doing this?)
08:06:02 <Berengal_> Cale, indeed. Might return different answers for same arguments when called at different times...
08:06:29 <benmachine> PeakerWork: I consider it wrong yeah
08:06:35 <benmachine> but it still does it :P
08:06:59 <benmachine> I think behaviour that is mandated in the report can reasonably be described as "allowed"
08:07:11 <Berengal_> map unsafeCoerce (enumFrom (minBound :: Word64)) :: Double
08:07:17 <Berengal_> *[Double]
08:07:21 <SamB_XP_> benmachine: well, it ought to be so ... but it ain't ;-P
08:07:25 <Cale> The Enum instance for Double is usually what you want it to be, anyway.
08:07:43 <SamB_XP_> Cale: insane?
08:07:46 <benmachine> heh
08:07:54 <Cale> If it enumerated *all* Doubles, you'd probably be annoyed too.
08:07:59 <benmachine> it's just that it doesn't really enumerate
08:08:05 <benmachine> so the class name is unhelpful
08:08:13 <FunctorSal> you can enumerate in it ;)
08:08:23 <Cale> I think of Enum as being "the stuff which makes the [n..m] notation make sense"
08:08:35 <Cale> and in that light, it's okay :)
08:08:43 <benmachine> class StuffWhichMakesEllipsisNotationMakeSense where
08:08:53 <Berengal_> Not that doing [n..m] on doubles makes sense...
08:09:00 <benmachine> someone suggested FromThenTo as a better class name
08:09:05 <benmachine> sounds like a good idea to me
08:09:19 <stanv_> PeakerWork: i have two functions with signature: Char -> Int, how to compare them?
08:09:24 <Cale> Berengal_: It does if you agree to choose a step size of 1
08:09:28 <benmachine> then you could use Enum for, like, enums.
08:09:37 <Cale> However, there are bugginesses about it.
08:09:41 * tibbe is a bit perplexed by the lazy I/O discussion on cafe
08:09:42 <Berengal_> Cale, and be fuzzy about your upper bound
08:09:51 <FunctorSal> > maxBound (undefined::Char)
08:09:51 <lambdabot>   No instance for (GHC.Enum.Bounded (GHC.Types.Char -> a))
08:09:52 <lambdabot>    arising from a ...
08:09:54 <Cale> I think that [n,k..m] should never contain an element larger than m
08:10:17 <Cale> and in some cases it does with the current instances, which is wrong
08:10:23 <Berengal_> Indeed
08:10:26 <benmachine> > last [1.0, 1.3 .. 3.0]
08:10:27 <FunctorSal> > head [ n | chr n == chr '0' ]
08:10:27 <lambdabot>   3.0999999999999996
08:10:28 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:10:28 <lambdabot>         against inferred type ...
08:10:40 <FunctorSal> > head [ n | n <- [0..], chr n == chr '0' ]
08:10:41 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:10:41 <lambdabot>         against inferred type ...
08:10:47 <Cale> But I don't mind that it steps by 1's.
08:10:58 <benmachine> FunctorSal: chr '0' doesn't make sense
08:11:08 <FunctorSal> > head [ n | n <- [0..], chr n == chr 0 ]
08:11:09 <lambdabot>   0
08:11:13 <FunctorSal> > head [ n | n <- [1..], chr n == chr 0 ]
08:11:16 <lambdabot>   * Exception: Prelude.chr: bad argument
08:11:27 <benmachine> > chr 0
08:11:28 <lambdabot>   '\NUL'
08:11:35 <benmachine> oh
08:11:37 <benmachine> yeah
08:11:43 <FunctorSal> okay we'd have to find where it bad-arguments ;)
08:11:55 <benmachine> > maxBound :: Char
08:11:56 <lambdabot>   '\1114111'
08:11:58 <mauke> > ord maxBound
08:11:59 <lambdabot>   1114111
08:12:17 <PeakerWork> stanv_: compare their results on all possible chars (which due to unicode, may take some time!)
08:12:25 <FunctorSal> I has the dumb :(
08:12:31 <PeakerWork> stanv_: Though if they're partial, you're also kind of screwed
08:12:31 <benmachine> > [ n | n <- [1 .. 1114111], chr n == chr 0 ]
08:12:34 <lambdabot>   []
08:12:35 <FunctorSal> thought maxBound took a dummy argument
08:13:04 <PeakerWork> stanv_: if they're total and the input is fully enumerable, they're basically equivalent to Maps, and Maps are comparable if the values they map to are comparable
08:13:30 <PeakerWork> stanv_: by partial/total, I mean whether they may not terminate/definitely terminate
08:13:36 <benmachine> FunctorSal: I suppose that's what asTypeOf maxBound is for
08:14:40 <stanv_> PeakerWork: to heavy :(
08:15:36 <PeakerWork> stanv_: what do you mena?
08:17:00 <Twey> FunctorSal:
08:17:03 <Twey> :t maxBound
08:17:04 <lambdabot> forall a. (Bounded a) => a
08:21:31 * benmachine has been poking around with fmap (.) and Control.Category (.) and has decided the difference is whether you think b -> m c . a -> m b = a -> m c or b -> c . a -> m b = a -> m c
08:21:54 * benmachine prefers the former and Control.Category..
08:22:58 <benmachine> erm, in non-weird syntax I can write those as (.) :: (b -> m c) -> (a -> m b) -> (a -> m c) and (.) :: (b -> c) -> (a -> m b) -> (a -> m c)
08:23:08 <benmachine> hmm this is not quite right
08:23:49 <benmachine> the latter would be \f g -> fmap f . g
08:24:52 <benmachine> well, anyway
08:29:40 <stanv_> PeakerWork: i need compare newtype FStore = FSto (Var -> Int)
08:30:16 <PeakerWork> stanv_: Are your (Var -> Int) functions total (that is, do they always terminate with an Int, or do they sometimes endlessly loop, or use "error"/pure exceptions)?
08:31:09 <Baughn> stanv_: For single-constructor types (including, always, newtypes), it's common (though not required) to use the same name for the constructor and type. Just in case you didn't know you /can/. :)
08:34:57 * byorgey gets back to hacking on 'cabal init'
08:35:04 <dcoutts> yay!
08:35:05 <byorgey> should be ready soon...
08:36:11 <dcoutts> :-)
08:38:04 <Baughn> cabal init? That the new mkcabal?
08:38:12 <stanv_> PeakerWork: user can assign any function for his decision, no any guaranties for functions are total.
08:38:16 <dcoutts> Baughn: right
08:38:30 <byorgey> Baughn: yep, but integrated into cabal-install, and with lots more automagic guessing fu
08:38:38 <Baughn> Sounds good
08:40:07 <SamB_XP_> can it guess what code I wanted to write but haven't yet?
08:40:26 <Baughn> That's emacs dwim-mode, not for cabal
08:40:35 <SamB_XP_> 'cause if it can, I'm going to have to kill the author
08:41:15 <PeakerWork> stanv_: if the functions are not necessarily total, then I guess you can't compare them at all
08:41:20 <byorgey> SamB_XP_: yes, actually, a little paper clip pops up and says, "It looks like you're trying to write a monoidal parser."
08:41:34 <SamB_XP_> byorgey: but how would it know what language for?
08:41:37 <PeakerWork> stanv_: what if you hit an endless loop? You never know it is an endless loop, so you cannot tell if it compares equal or not to another function
08:41:42 <SamB_XP_> also, I hope the paperclip is shaped like a lambda
08:41:45 <byorgey> SamB_XP_: pretty amazing, isn't it?
08:41:58 <byorgey> yes, it's been bent into a lambda shape
08:42:35 <SamB_XP_> I meant, like, it came from the paperclip factory shaped like a lambda
08:42:46 <SamB_XP_> you know, was manufactured with that shape
08:43:01 <byorgey> SamB_XP_: how do you think paper clips are manufactured?  ;)
08:43:12 <SamB_XP_> yeah, I know
08:43:21 <SamB_XP_> they are bent into their shape
08:43:37 <SamB_XP_> I'm just being specific that it didn't start out shaped like your usual paperclip ;-P
08:43:50 <SamB_XP_> and then get re-bent into lambda shape
08:44:16 <byorgey> I know, I am just obtusely implying that I meant what you meant all along.  which of course I didn't. =)
08:44:30 <SamB_XP_> hehehehe
08:45:35 * SamB_XP_ wonders how the trojan was introduced into this crack he downloaded but did not run ... it's made with a tool that evidently doesn't produce virus-laden output ...
08:45:41 <stanv_> PeakerWork: ok, thanks!
08:46:24 <PeakerWork> stanv_: unless.. you're willing for the comparison itself to be partial/become an endless loop if the compared funcs are endless, of course :)
08:48:02 <SamB_XP_> Peaker: well, I don't see how it can be otherwise ;-P
08:49:04 <SamB_XP_> the only other way to possibly do it would be to have the comparison func require proofs of totality in addition to the functions
08:49:05 <sinelaw> @hoogle ((a->b),a) -> b
08:49:05 <lambdabot> No results found
08:49:13 <sinelaw> @hoogle (a,(a->b)) -> b
08:49:13 <lambdabot> Control.Monad.Writer.Class pass :: MonadWriter w m => m (a, w -> w) -> m a
08:50:36 <sinelaw> What does "illegal view pattern" mean?
08:51:21 <sinelaw> the error is in this: apply (a->b) a = MyConstructor (\(f,a) -> f a)
08:51:41 <sinelaw> @pl (a,(a->b)) -> b
08:51:41 <lambdabot> (line 1, column 3):
08:51:41 <lambdabot> unexpected ","
08:51:41 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
08:51:49 <byorgey> sinelaw: I doubt that (a->b) means what you think it does.  what are you trying to do?
08:52:04 <sinelaw> byorgey, right :)
08:52:08 <byorgey> sinelaw: do you mean the first argument of apply should be something with type (a -> b)?
08:52:22 <sinelaw> yes, sorry, i mixed type and definition
08:52:23 <byorgey> if so, you should say  apply :: (a -> b) -> a -> ...
08:52:27 <byorgey> apply f a = ...
08:52:29 <byorgey> right, ok =)
08:52:58 <byorgey> sinelaw: the reason you got an error about 'illegal view pattern' is because there is an extension called 'view patterns' that uses the syntax  (view -> x)  for an argument
08:53:05 <byorgey> which runs the function 'view' on the argument and binds the result to x
08:53:26 <sinelaw> ah ok, thanks
08:53:37 <Baughn> Where view can be an arbitrary function, and x an arbitrary pattern. It's neat.
08:54:57 <sinelaw> cool
08:56:05 <Twey> Very neat.
08:56:24 <Twey> Was it going in Haskell', did I hear someone say?
08:56:50 <Twey> (‘read’ is a particularly handy view)
08:56:55 <aavogt> so view patterns are like PatternGuards?
08:57:12 <Twey> aavogt: Not much.
08:57:28 <Twey> They overlap a bit, I think, but their purposes are mainly different
08:57:59 <aavogt> in that you can take    SomePattern a b | Constructory x y z <- functionOn a b
08:58:05 <Twey> Hmm, that said… thinking about them, they do seem oddly similar.
08:58:41 <Berengal> You can't nest pattern guards. If you could, I think they would be very similar
08:59:28 <Twey> Ah, that's it.
08:59:39 <Twey> And you can't use other arguments in view patterns.
08:59:48 <aavogt> Berengal: do you have an example of how view patterns nest?
09:00:16 <Twey> addTwo :: String -> Int; addTwo (read -> ((+ 2) -> n)) = n
09:00:26 <Berengal> aavogt, read -> (flip divMod 10 -> (x, 0))
09:01:12 <aavogt> wouldn't it make sense for -> associate to the right in this case?
09:01:13 <Berengal> Although I think you can do that with | n <- read, (x, 0) <- divMod n 10 = as well
09:01:33 <Twey> aavogt: I don't think it associates
09:02:03 <Twey> (but maybe it does)
09:02:05 * Twey tries
09:02:36 <Twey> No, it doesn't
09:02:43 <Twey> The brackets are part of the syntax
09:03:41 <Berengal> Yeah, view patterns need to be surrounded by parenthesis, just like any other pattern with whitespace
09:03:42 <sinelaw> is there a way to create type-level lists in haskell?
09:03:56 <sinelaw> as in Agda
09:04:05 <Berengal> sinelaw, take a look at the  HList package
09:04:06 <Twey> sinelaw: You can nest pairs arbitrarily deeply?
09:12:05 * byorgey just found a call to 'either id id' in some code he wrote a while ago
09:12:09 * byorgey scratches head
09:12:30 <kw317> a placeholder?
09:12:57 <byorgey> I've no idea!
09:13:48 <byorgey> my best guess is that one of the id's used to be something else, and then at some point I changed it to id without really thinking about it
09:14:22 * Baughn once deliberately and thoughtfully wrote "either id id" as the first iteration
09:15:21 <byorgey> well, it is rather more descriptive than just 'id', if you really want to explicitly write 'id'
09:15:54 <Baughn> It was to strip the "Either" from Either a a
09:16:06 <Baughn> ..I was using the branching to store a boolean
09:16:16 <byorgey> oh, wait, I have been quite confused!
09:16:33 <aug_triad> Hi. I have a variable containing a string that I want to use inside quotation marks. When using show variable, I get the string "\"example_string\"". What I want is "example_string". How can I do that?
09:16:49 <byorgey> I was thinking of  id ||| id
09:16:55 <Zao> aug_triad: printf it?
09:16:57 <byorgey> which is just  id with a more restricted type
09:17:09 <byorgey> but either id id is indeed useful.
09:17:46 <Zao> > printf "\"%s\"" "lol"
09:17:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:17:48 <lambdabot>    `GHC.Show.Show a'
09:17:48 <lambdabot>      a...
09:17:50 <Zao> > printf "\"%s\"" "lol" :: String
09:17:51 <lambdabot>   "\"lol\""
09:17:53 <Zao> Silly bot :)
09:17:54 <aavogt> definitely shorter than  (`asTypeOf` (undefined :: Either a b))
09:18:30 <byorgey> aug_triad: just don't call 'show'.
09:18:36 <byorgey> aug_triad: it's already a String.
09:19:57 <ksf> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
09:20:42 <sinelaw> @hoogle (a,b,c) -> (a,(b->c))
09:20:42 <lambdabot> No results found
09:20:44 <sinelaw> @hoogle (a,b,c) -> (a,(b,c))
09:20:45 <lambdabot> No results found
09:21:27 * ksf still wants extensible records, though.
09:21:40 <sinelaw> @hoogle (a,b,c) -> ((a,b),c)
09:21:41 <lambdabot> No results found
09:22:58 <ksf> we should call them extords, and coin extord-oriented programming.
09:23:35 <byorgey> sinelaw: there's no good way to do that other than just writing  \(a,b,c) -> ((a,b),c)
09:23:46 <byorgey> but thankfully that's rather short.
09:24:09 <sinelaw> yes, but i want (a,b,c,.....) -> (a,(b,.....)
09:24:27 <ksf> tuples other than 2-tuples are a pain to work with.
09:24:31 <ksf> ...you want a HList.
09:24:50 <sinelaw> *sigh.*
09:25:16 <ksf> there's nthable on hackage, though.
09:26:12 <ksf> ...but I would greatly, greatly prefer to return ad-hocly named records from functions.
09:26:25 <Cale> sinelaw: If you have a string and you apply show to it, it gets wrapped in single quotes, and quotes inside it are quoted. If you don't want the quotes, don't apply show to it.
09:27:12 <ksf> split :: Int -> [a] -> (start = [a], rest= [a])
09:27:26 <ksf> er s/=/::/g
09:28:27 <aug_triad> Thank you, that was an easy solution :)
09:28:52 <ksf> actually... in that case, I'm in favour of retaining positional syntax.
09:29:34 <ksf> but were in not for (h,t) = split 2 "foo", i'd say rather don't.
09:29:36 <byorgey> sinelaw: is there a particular reason you need arbitrary-length tuples instead of a list?
09:39:35 <arno5270> I am struggling with this problem, and I think I am over-complicating it..
09:39:51 <byorgey> arno5270: what's the problem?
09:40:43 <arno5270> Suppose I have a string "abcdefgh", and I want to convert it to a list of strings ["a", "ab", "abc", "abcd", "bcde", "cdef", defg", "efgh"], what would be the best / simplest way to do that?
09:41:13 <arno5270> Right now I have it working, by implementing a recursive function.. but I cannot help but feel there should be a better way.
09:41:58 <byorgey> arno5270: well, I'd start with "tails"
09:42:03 <byorgey> > tails "abcdefgh"
09:42:05 <lambdabot>   ["abcdefgh","bcdefgh","cdefgh","defgh","efgh","fgh","gh","h",""]
09:42:11 <byorgey> er, sorry, I mean "inits" =)
09:42:32 <arno5270> inits "abcdefgh"
09:42:40 <byorgey> > map (reverse . take 4 . reverse) . drop 1 . inits $ "abcdefgh"
09:42:42 <lambdabot>   ["a","ab","abc","abcd","bcde","cdef","defg","efgh"]
09:42:54 <arno5270> wow.
09:43:03 <arno5270> Of course.
09:43:12 <byorgey> just think about transforming the entire list step-by-step.
09:43:27 <byorgey> first generate all the inits... drop the empty string which you don't want... then take the last 4 characters from each.
09:43:47 <arno5270> Sounds easy that way :)
09:43:48 <byorgey> there might be better ways but that's what came to me first.
09:44:05 <arno5270> It sure beats my 10 line recursive function!
09:44:11 <byorgey> it is easy, once you learn to think that way (and are familiar with the standard library).
09:45:07 <arno5270> I had the inits part, but couldn't figure out how to get the last 4 chars.
09:45:17 <arno5270> Thank you, byorgey!
09:45:23 <byorgey> sure, you're welcome =)
09:45:28 <benjamin`> i have a question
09:45:42 <benjamin`> i'm trying to write a gaussian elimination algorithm
09:45:47 <benjamin`> but i'm not sure how to approach it using haskell
09:45:55 <benjamin`> does anyone have thoughts on an appropriate way to do this
09:45:56 <benjamin`> ?
09:46:03 <Zao> 1) grab your gauss rifle  2) start eliminating
09:46:11 <benjamin`> haha
09:47:16 <aavogt> > map (reverse . take 4) . init . tails . reverse $ "abcdefgh"
09:47:17 <lambdabot>   ["efgh","defg","cdef","bcde","abcd","abc","ab","a"]
09:47:22 <byorgey> I think gaussian elimination can be expressed quite nicely in Haskell, if you don't care too much about efficiency (and if you do care about efficiency, use hmatrix =)
09:47:47 <byorgey> benjamin`: I'd start by writing some utility methods, like adding a multiple of one list to another etc.
09:48:10 <benjamin`> right
09:48:19 <byorgey> benjamin`: and a method to extract a submatrix from a matrix represented as a list of lists
09:49:16 <benjamin`> right
09:49:35 <byorgey> then you can do one step of elimination by taking the first list, and mapping a function to eliminate the first var by adding a multiple of it, over the rest of the lists
09:49:53 <byorgey> then make a recursive call on the submatrix one row/column smaller.
09:50:01 <benjamin`> right that's the basic idea
09:50:13 <benjamin`> i am a little worried about efficiency
09:50:17 <byorgey> I guess it's the details that can get fiddly
09:50:32 <benjamin`> but that seems like the way to approach it
09:50:36 <byorgey> benjamin`: well, why are you writing this?  to learn, or because you want a really fast gaussian elimination algorithm?
09:50:36 <benjamin`> yeah
09:50:42 <benjamin`> to learn
09:50:48 <benjamin`> it's a school project
09:50:57 <byorgey> ok, then don't worry too much about efficiency, at least not at first.
09:51:14 <benjamin`> haha all right
09:51:39 <benjamin`> i'm going to get to work with this stuff in mind, i'll ping this place later if some other complications arise
09:51:41 <benjamin`> :)
09:51:48 <byorgey> sure, feel free =)
09:54:11 <byorgey> darcs 2.3.1 feels pretty zippy on local repos =)
09:54:22 <byorgey> kowey++ Heffalump++ mornfall++
10:01:44 <SamB_XP_> you know, IDA looks really really dumb if you've configured Windows to use a Japanese encoding for it's "ANSI" thing ...
10:04:56 <byorgey> and... cabal-init patch is away!
10:05:02 <byorgey> dcoutts_: ^^^
10:05:43 <Elly> SamB_XP_: I wish there was something better than IDA out there, but IDA is really good :P
10:05:54 <Elly> definitely the best tool of its kind, anyway
10:06:50 <SamB_XP_> too bad this free version presumably can't disasseble itself :-(
10:06:55 <Elly> huh?
10:06:58 <Elly> I think it can
10:07:01 <SamB_XP_> it can?
10:07:06 <Elly> try it
10:07:31 * Elly hasn't used the free version in quite a while <.<
10:07:49 <SamB_XP_> hmm ... now that you mention it, that would be a logical assumption given what it says when you start it and/or agree to the license ...
10:07:54 <SamB_XP_> I think
10:09:47 <SamB_XP_> Elly: how'd you upgrade -- did you buy it, or did you crack the trial version yourself?
10:10:11 <Elly> SamB_XP_: neither
10:10:22 <SamB_XP_> neither?
10:10:31 <SamB_XP_> you ... used someone *elses* crack?
10:10:40 <SamB_XP_> they gave it to you for *free*?
10:11:22 <Elly> "they" being another person who had it, yes :P
10:11:54 <SamB_XP_> you are using a version watermarked to someone else?
10:11:59 <Elly> I think so!
10:12:06 <SamB_XP_> isn't that illegal?
10:12:10 <Elly> maybe?
10:12:43 <Elly> on the other hand, a lot of things involving IDA are illegal :P
10:13:41 <SamB_XP_> I like how you haven't mentioned cracking the trial version as probably illegal yet ;-P
10:14:08 <Elly> indeed
10:14:42 <Veinor> what're we talking about?
10:15:34 <SamB_XP_> I guess everyone figures that, if you're willing to crack it yourself, you (a) are probably broke and (b) basically earned the right to use that version ;-P
10:15:37 <SamB_XP_> Veinor: IDA
10:16:02 <Veinor> which is?
10:16:17 <SamB_XP_> the Interactive Disassembler
10:16:35 <Veinor> Ah
10:16:58 <SamB_XP_> that's almost exactly what it says in the titlebar, only I miscapitalized it before noticing it said that ;-)
10:17:21 <Veinor> oh gnu HURD
10:17:31 <Veinor> will you ever actually do anything? :P
10:17:45 <SamB_XP_> Veinor: I got it to connect to the 'net once, I think
10:17:59 <SamB_XP_> but I don't remember what I did with that, if anything ;-P
10:18:07 <Veinor> not bad for only 18 years of dev :D
10:18:17 <SamB_XP_> that was years back, though
10:20:17 <xkb> Hi
10:20:42 <SamB_XP_> Elly: what do you know! it *doesn't* refuse to disassemble itself
10:22:32 <byorgey> hi xkb
10:25:32 * SamB_XP_ closes out IDA, creates a duplicate/backup, and runs the duplicate instead
10:26:54 <Adamant> SamB_XP_: legal versions of IDA have no problem disassembling themselves
10:27:21 <SamB_XP_> Adamant: you mean, non-"trial" versions?
10:27:39 <SamB_XP_> and I expect there will be problems -- there usually are
10:28:11 <Adamant> SamB_XP_: yes, non-trial versions
10:28:40 <Adamant> if you've paid or you're using the obsolete version they don't care if you use it for disassembly
10:28:50 <Adamant> of itself
10:29:16 <SamB_XP_> yes, they explicitly advertise that for the "you've paid" case
10:29:34 <SamB_XP_> I just didn't realize it also applied to "4.9 Free" until now ;-)
10:30:30 * ksf vaguely remembers thinking up jasmin code to make java dissasms choke
10:30:47 <ksf> it's actually quite easy as java disasms are as dumb as javac.
10:31:26 <ksf> the trick, though, is to get the code past the verifier.
10:31:37 <SamB_XP> ah, yeah
10:31:46 <ksf> ...so you can't do funky stack stuff.
10:31:49 <SamB_XP> so ... what if the verifier *was* the disassembler?
10:32:37 <ksf> well... in the j2me case, you can write your own verifier than only pretends to be verifying and tag the .class as preverified.
10:32:53 <ksf> ...hoping that the vm falls for it (which not all mobile vms do)
10:33:42 <ksf> it's kinda pointless, anyway. I'd assume that if the compiler is'nt horribly broken, the verifier always succeeds.
10:33:54 <SamB_XP> why would the vm believe you?
10:34:01 <ksf> because it's dumb.
10:34:11 <SamB_XP> that'd be a reason, yes ...
10:34:17 <SamB_XP> I guess too many of them probably are :-(
10:34:23 <SamB_XP> why is there even a way to tag them like that?
10:34:30 <ksf> ...because some guys had to fit it into the space they got by limiting saved messages to 10.
10:34:43 <SamB_XP> doh!
10:34:55 <ksf> ...it's only a j2me feature.
10:35:04 <SamB_XP> it still sounds dumb
10:35:13 <ksf> ...though "proper" pc vms have a flag that skips the verifying pass.
10:35:18 <SamB_XP> if you need to squeeze down the JVM that much, you won't have any room for an app!
10:35:28 <SamB_XP> ksf: well, sure. why not?
10:35:32 <ksf> that's why we never used objects.
10:35:53 <ksf> or, actually, limited ourselves to the bare minimum: one implementing midlet, one implementing canvas.
10:36:51 <SamB_XP> you probably don't need to verify your server every single time you start it, etc...
10:36:58 <ksf> yep.
10:37:32 <SamB_XP> presumably there's loads of bad things it could do even without failing to verify ;-)
10:37:40 <ksf> we did fun stuff back then. like messing with a png's palette on load-time to exchange colours to get sprites for a second team, to save jar size.
10:39:11 <ksf> ...not to mention preprocessing the source to collapse class hierarchies.
10:39:44 <ksf> (and replacing parts of that hierarchy with the right implementation while doing that)
10:40:59 <SamB_XP> ksf: what an interesting job that was!
10:41:11 <SamB_XP> like the curse
10:41:11 <fmlz> @pl (>>=) x y z = y (x z) z
10:41:12 <lambdabot> (line 1, column 13):
10:41:12 <lambdabot> unexpected "="
10:41:12 <lambdabot> expecting variable, "(", operator or end of input
10:41:17 <fmlz> @pl f x y z = y (x z) z
10:41:17 <lambdabot> f = flip flip id . (ap .) . flip (.)
10:41:18 <SamB_XP> "may you live in interesting times"
10:41:40 <ksf> it checks invariants like that every code point has to have the same stack depth under any possible code path.
10:42:19 <ksf> I've developed a very sophisticated hatred of java there.
10:43:44 <fmlz> you can think of java byte code as the intersection of register code and stack code, the verifier gives you the limitations of both
10:43:46 <fmlz> it's awesome
10:44:30 <ksf> if I'm not completely mistaken jvm bytecode doesnt' have regs
10:45:00 <fmlz> you can rewrite it into register code, since the stack is static
10:45:11 <mreh> um, any tips on finding the yi binary after installation?
10:45:15 <ksf> you push your args, an object and then say invokevirtual <methname>
10:45:16 <fmlz> hence you get limitations of register code on top of the stack ones
10:45:28 <SamB_XP> fmlz: at least you have a fairly large number of registers ;-)
10:45:51 <ksf> erm but if I disabled the verifier, my funky stack code worked fine.
10:46:17 <SamB_XP> ksf: so what?
10:46:37 <ksf> it doesn't use that staticness to generate code.
10:46:45 <fmlz> if you disable the verifier, you can do whatever you want. you're in nasal demon territory
10:46:48 <ksf> ...or it verifies anyway and just does'nt jit or something.
10:48:11 <fmlz> ksf: i can get my jvm to run aribtrary x86 code by using enough undefined behavior; that doesn't make SSE2 part of java
10:48:33 <fmlz> (apologies for the derail)
10:49:07 <ksf> well I wouldn't count on arm-based mobiles implementing sse2, anyway.
10:54:17 <monochrom> Hehehe "fake world haskell"
11:06:40 * ksf re-reads the oohaskell paper and is astonished by the similarity of awkwardness between hMapM_ and java lambdas.
11:07:00 <ksf> ...in both cases, you gotta do a class to hold your code.
11:07:47 <SamB_XP> what the _|_ ?
11:08:12 <ksf> http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf  pp 28+29
11:08:52 <ksf> you don't pass a function into hMapM_, but (undefined::Foo) and then do instance Apply Foo where ...
11:08:59 <PeakerWork> I am not sure oohaskell is useful.. seems like a neat proof of concept, but why program that way? :-)
11:09:30 <ksf> oleg even gets away without justifying his use of the IO monad.
11:10:28 <ksf> I'm wondering what one could do with nothing but TH, though, seems noone took that approach yet.
11:10:52 <PeakerWork> ksf: approach to what? Emulating single-dispatch OO?
11:11:05 <PeakerWork> with namespace mangling, and all? :)
11:11:13 <ksf> the extensible records + self references thing.
11:11:56 <monochrom> A Haskell binding of an Apple library uses TH and existential type. The Apple library's native language is Objective-C. In other words, the Haskell binding shows you how to do OO.
11:12:31 <ksf> does it shun IO?
11:13:11 <monochrom> http://hoc.sourceforge.net/
11:13:12 <ksf> using set! might be cool in scheme, but...
11:14:29 <monochrom> http://hoc.sourceforge.net/examples.html  has examples.
11:15:02 <monochrom> Likely most methods become IO actions. Most methods are GUI operations.
11:58:39 <ajdhs> I have an unsafePerformIO question: is it safe to use unsafePerformIO to catch calls to "error" in a pure function?
11:59:00 <ddarius> Nope.
11:59:06 <ajdhs> why not?
11:59:09 <ddarius> At least not in general.
11:59:56 <ddarius> Nothing should break horribly, but it will, at the very least, reveal aspects of the evaluation order.
12:00:10 <ajdhs> ok
12:00:13 <ddarius> And will likely lead to violations of referential transparency.
12:00:20 <ajdhs> so if you have a function f that potentially call error
12:00:37 <ajdhs> what is the problem with saying
12:01:18 <ajdhs> unsafePerformIO (try (evaluate f) >>= \k -> case k of { Left _ -> Nothing ; Right x -> Just x })
12:01:35 <ajdhs> or, rather
12:01:40 <ajdhs> unsafePerformIO (try (evaluate f) >>= \k -> return $ case k of { Left _ -> Nothing ; Right x -> Just x })
12:02:25 <ajdhs> it seems to me like that would stay referentially transparent
12:04:39 <shaleny> you cannot predict the evaluation order
12:04:39 <shaleny> so with the same input your function can cause errors and can be run clearly
12:04:39 <shaleny> and that means that for the same input your function can return different results. hence this function is not pure anymore
12:05:01 <shaleny> it was about general case
12:05:13 <ajdhs> ok, I see
12:05:18 <ajdhs> so if you had a function like
12:05:26 <ajdhs> f :: Int -> Int
12:06:04 <ajdhs> f = f
12:06:12 <ajdhs> and g :: Int -> (Int, Int)
12:06:17 <ajdhs> g _ = (undefined, f)
12:06:28 <ajdhs> then, depending on evaluation order
12:06:34 <Elly> f = f? oO
12:06:44 <ajdhs> in other words, f recurses indefinitely
12:07:05 <ajdhs> but depending on the evaluation order, g could be a call to error or else an infinite loop
12:07:53 <ajdhs> but if I convince myself that f will either return a non-bottom value or else call error
12:08:18 <ajdhs> I think I'm OK...unless there's something about exceptions that I'm missing
12:09:05 <Berengal> The solution is to use pure exceptions in pure code, and let the IO exceptions be handled in IO
12:09:24 <ajdhs> pure exceptions?
12:09:33 <Berengal> Maybe, Either, MonadError etc.
12:09:37 <ajdhs> Yes
12:09:40 <c_wraith> Berengal:  Only so much you can do when you're using a badly-designed library from someone else.
12:09:41 <c_wraith> like base
12:09:44 <ajdhs> that would be my preferred solution
12:09:49 <ajdhs> but I'm using the Binary library
12:09:53 <Berengal> c_wraith, true, unfortunately...
12:09:55 * c_wraith *still* glares at read
12:10:13 <Berengal> c_wraith, at least you've got reads
12:10:16 <ajdhs> and the trouble is that it couldn't be lazy if it returned a Maybe value
12:10:22 <Saizan> read is just a convenience function for the prompt
12:10:23 <ajdhs> so they just call error on bad input
12:10:25 <Saizan> you should use reads
12:10:28 * Twey glares at the newline-transparency, instead.
12:10:51 <Twey> How do I make this thing output \r\n on *nix without it ending up as \r\r\n on Windows?
12:11:05 <Berengal> Lazy exceptions are a problem
12:11:13 <Berengal> Twey, binary mode
12:11:14 <Saizan> Twey: open the file in binary mode
12:11:18 <Twey> It's a socket
12:11:22 <c_wraith> Twey:  Don't use any function that does auto newlines?
12:11:27 <Berengal> Still a handle: binary mode
12:11:32 <ajdhs> Berengal: do you have a good solution for lazy exceptions?
12:11:46 <Twey> Is it automatically in binary mode, or can I switch it somehow?
12:12:00 <Berengal> ajdhs, wish I did... I don't. Keep them close to IO and handle exceptions there
12:12:02 <Twey> c_wraith: That's the whole IO subsystem :þ
12:12:12 <c_wraith> Yeah, just ignore that. :)
12:12:40 <shaleny> ajdhs, are those really exceptions or just errors as you stated at the beginning?
12:12:49 <ajdhs> exceptions
12:12:53 <ajdhs> well
12:12:56 <ajdhs> they use the error function
12:13:00 <ajdhs> but they are really exceptions
12:13:00 <c_wraith> > cycle []
12:13:01 <lambdabot>   * Exception: Prelude.cycle: empty list
12:13:04 <Berengal> error/undefined is an async exception
12:13:39 <c_wraith> Hmm.  cycle.  It would be annoying to create a pure version of cycle, I suppose.
12:14:50 <Berengal> > let cycle [] = Nothing; cycle xs = (++) <$> pure xs <*> cycle xs
12:14:51 <lambdabot>   not an expression: `let cycle [] = Nothing; cycle xs = (++) <$> pure xs <*>...
12:15:09 <Berengal> @type let cycle [] = Nothing; cycle xs = (++) <$> pure xs <*> cycle xs in cycle
12:15:09 <lambdabot> forall a. [a] -> Maybe [a]
12:15:13 <Berengal> was what i wanted
12:15:21 <c_wraith> well, yes.  But then using it is annoying.
12:15:32 <c_wraith> I really don't like Maybe, in practice
12:16:06 <Berengal> do-notation and Alternative makes it much nicer
12:16:16 <c_wraith> \
12:16:22 <c_wraith> err, sorry about that.
12:16:38 <Berengal> But yes, pure functions are truly the best to work with
12:17:29 <Twey> c_wraith: ?  cycle is already pure.
12:17:37 <Twey> :t cycle
12:17:38 <lambdabot> forall a. [a] -> [a]
12:17:47 <Berengal> You'll just have to weigh bothering about fmapping against bothering about async exceptions thrown by partial functions
12:17:51 <c_wraith> > cycle []
12:17:52 <lambdabot>   * Exception: Prelude.cycle: empty list
12:18:00 <Berengal> I usually take the maybes
12:18:12 <c_wraith> Throwing an async exception is not what I consider pure, in practice
12:18:25 <ajdhs> so, in terms of a verdict
12:18:38 <ajdhs> if I have my parser function that could throw async errors because it uses Binary
12:18:40 <Twey> Psht
12:18:44 <Twey> Go and code Coq :þ
12:19:06 <ajdhs> is it better to have it return an IO action just so it can catch the error or to unsafePerformIO it?
12:19:16 <Twey> ajdhs: Return IO.
12:19:34 <Berengal> ajdhs, what do you want to do when you catch the exception anyway?
12:19:40 <ajdhs> return Nothing
12:20:01 <ajdhs> basically, my function doesn't do any IO, so it seems a shame to force people to use it with the IO monad
12:20:08 <Berengal> ... I haven't used Binary. Isn't there a strict instance somewhere?
12:20:31 <aavogt> hmm, but the requirements for unsafePerformIO state: if you can do the same thing in pure code, it is probably safe
12:21:59 <Berengal> aavogt, the problem is catching exceptions though, since they're asynchronous, they might be thrown by a bottom created somewhere else
12:22:31 <Twey> ajdhs: You can use an arbitrary monad
12:22:39 <Twey> Monad m => m
12:22:56 <Twey> Then people can use whatever they like.
12:23:02 <ajdhs> yes...but you can only catch exceptions in IO
12:23:18 <Twey> Then if they want to catch the exceptions, then they shall use IO
12:23:30 <ajdhs> yes, I suppose so
12:23:50 <shaleny> I just glanced to the source of Data.Binary and found only one place where error is used:
12:23:52 <shaleny>     error "Not a valid Unicode code point"
12:23:52 <shaleny> Is it the place you are speaking about?
12:24:52 <ajdhs> I'll http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary-Get.html
12:25:04 <ajdhs> lots of fails, basically when the input is too short
12:25:24 <ajdhs> I'll investigate switching to binary-strict, which doesn't call error
12:25:45 <shaleny> ouch, sorry. looked at old version
12:25:47 <ajdhs> since I'm going to make it strict anyhow by using evaluate
12:25:58 <ajdhs> thanks a million for your help and suggestions guys
12:42:53 <ddarius> c_wraith: Would you consider cycle [] = cycle [] an acceptable alternative definition?
12:44:08 <c_wraith> having read the denotational semantics wiki page, I'd argue that's the same as returning _|_
12:44:20 <ddarius> c_wraith: It is returning bottom.
12:44:51 <c_wraith> But it's a terrible way to go about it, as it could be *really* hard to track that down if you ran into it in a large program
12:45:17 <ddarius> c_wraith: Would you consider such a definition impure?
12:46:13 <c_wraith> That's a tough question.  I'm not quite sure where I sit on that axis, for that problem.  But on the software engineering viewpoint, it's horrible. :)
12:47:05 <seanmcl> Is there a good way to handle booleans in monads?  I'm constantly writing code like  do { b <- E, if b then E1 else E2 }.  Isn't there something like ifM E E1 E2?
12:47:20 <Botje_> @hoogle ifM
12:47:20 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
12:47:20 <lambdabot> Network.HTTP.Headers HdrIfMatch :: HeaderName
12:47:20 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
12:47:27 <Botje_> boo.
12:47:51 <cpettitt> Is there a nice construct for folding over a list with a function that takes an accumulator, the last value, and the current value and returns a new accumulator?
12:48:03 <cpettitt> This is what I came up with for a specific problem, but it seems more complicated than necessary
12:48:04 <cpettitt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10625
12:48:27 <Botje_> cpettitt: when you're looking at sequential values, zip list (tail list) is generally advised
12:48:32 <ddarius> :t mapAccumL
12:48:32 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:49:40 <cpettitt> cool! both sounds like they would work. Off to experiment :)
12:49:46 <cpettitt> thanks guys
12:52:32 <byorgey> seanmcl, Botje_: maybe check out the IfElse package?
12:52:34 <byorgey> http://hackage.haskell.org/package/IfElse
12:52:48 <paolino> @hoogle Either a a -> (b -> Either b b, a)
12:52:48 <lambdabot> No results found
12:53:48 <paolino> @djiin Either a a -> (b -> Either b b, a)
12:53:48 <lambdabot> f a =
12:53:48 <lambdabot>     case a of
12:53:48 <lambdabot>     Left b -> (Left, b)
12:53:48 <lambdabot>     Right c -> (Left, c)
12:54:12 <paolino> :-/
12:54:13 <seanmcl> byorgey: thanks.  yeah, this kind of thing seems useful.
12:57:22 <slowriot> Does anyone know of a good turing machine simulator that supports nondeterministic multitape turing machines and has a graphical interface?
12:57:48 <slowriot> not really a haskell question, I guess
12:57:56 <ddarius> byorgey: It has everything but an ifM
12:57:57 <SamB_XP> how would it show the nondeterminism?
12:58:10 <byorgey> ddarius: heh, so it does.  I wonder why?
12:59:23 <slowriot> SamB_XP: Well, it could trace through a single path leading to an accept state. Or it could let the user choose which path to take.
13:00:12 <slowriot> SamB_XP: I guess that could get out of hand computationally.
13:00:36 <c_wraith> slowriot:  It's exponential growth of the state space, in general.
13:00:40 <paolino> @hoogle Either a a -> (Bool, a)
13:00:40 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
13:00:40 <lambdabot> Data.Array.MArray getBounds :: (MArray a e m, Ix i) => a i e -> m (i, i)
13:00:40 <lambdabot> Data.Array.IArray assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
13:01:34 <c_wraith> wow, hoogle.  Those aren't even close.
13:01:47 <paolino> well, they are
13:01:52 <performance> is there a Haskell equivalent for PERL or python's email modules?
13:02:15 <c_wraith> Array isn't that close to Either
13:02:37 <c_wraith> Except that it has the same kind, I suppose
13:02:45 <performance> there are SMTP client packages on hackage
13:02:53 <paolino> a i e is close to Either a a
13:03:07 <performance> or Happs-SMTP :(
13:03:09 <slowriot> Here is a simulator that apparently simulates nondeterministic multitape turing machines: http://alexvn.freeservers.com/s1/turing.html#label_Download.
13:03:25 <FunctorSal> c_wraith: yeah it's a bit loose. seems to ignore the context?
13:03:37 <paolino> @djiinn Either a a -> (Bool, a)
13:03:37 <lambdabot> f a =
13:03:37 <lambdabot>     case a of
13:03:37 <lambdabot>     Left b -> (False, b)
13:03:37 <lambdabot>     Right c -> (False, c)
13:04:08 <FunctorSal> though m(i,i) doesn't unify with (Bool,a) no matter how you put it ;)
13:04:28 <c_wraith> Heh.  That's almost the definition you'd actually want.  djinn is pretty good! :)
13:04:56 <paolino> but doesn't enumerate on cases
13:06:03 <c_wraith> Isn't the only thing you want different changing one False to True?
13:07:13 <Baughn> @djinn a -> b
13:07:13 <lambdabot> -- f cannot be realized.
13:07:28 <Baughn> @djinn (a,b) -> a -> b
13:07:28 <lambdabot> f (_, a) _ = a
13:07:31 <c_wraith> @djinn a -> Bool
13:07:31 <lambdabot> f _ = False
13:07:50 <Baughn> @djinn Bool -> Int
13:07:50 <lambdabot> Error: Undefined type Int
13:08:59 <Twey> o.@
13:10:02 <Baughn> @djinn Bool -> (Bool,Bool)
13:10:03 <lambdabot> f a =
13:10:03 <lambdabot>     case a of
13:10:03 <lambdabot>     False -> (False, False)
13:10:03 <lambdabot>     True -> (False, True)
13:10:10 <byorgey> @djinn (Bool, a) -> Either a a
13:10:11 <lambdabot> f (a, b) =
13:10:11 <lambdabot>     case a of
13:10:11 <lambdabot>     False -> Left b
13:10:11 <lambdabot>     True -> Right b
13:10:18 <Baughn> @djinn Bool -> Bool -> (Bool,Bool)
13:10:18 <lambdabot> f a b =
13:10:18 <lambdabot>     case a of
13:10:18 <lambdabot>     False -> (False, False)
13:10:18 <lambdabot>     True -> case b of
13:10:19 <lambdabot>             False -> (False, False)
13:10:21 <lambdabot>             True -> (False, True)
13:10:26 <Baughn> ..oy.
13:10:46 <Twey> Oh my.
13:11:21 <c_wraith> huh.  it's not choosing the simplest implementation possible for those
13:11:26 <jmcarthur> O_o
13:11:42 <mauke> f _ _ = (False, False) ?
13:11:45 <FunctorSal> I don't think it particularly cares about the term level
13:12:00 <FunctorSal> it's about finding "proofs" for the type
13:12:00 <Twey> 21:12:49 <lambdabot> Plugin `djinn' failed with: thread killed
13:12:02 <Twey> Heh.
13:12:47 <jmcarthur> does djinn *have* to treat monomorphic arguments strictly?
13:12:49 <Baughn> @djinn (a -> b) -> b
13:12:50 <lambdabot> -- f cannot be realized.
13:12:58 <Baughn> @djinn (a -> a) -> a
13:12:59 <lambdabot> -- f cannot be realized.
13:13:01 <jmcarthur> @djinn Bool -> Bool
13:13:01 <lambdabot> f a = a
13:13:05 <jmcarthur> hmm, no
13:13:48 <vinicius> @djinn [Bool] -> (Bool,[Bool])
13:13:48 <lambdabot> Error: Undefined type []
13:14:30 <c_wraith> :t head &&& tail
13:14:31 <lambdabot> forall c. [c] -> (c, [c])
13:15:33 <ddarius> djinn tries to use each argument once.
13:15:46 <c_wraith> Ah.  That makes sense.
13:15:57 <FunctorSal> @djinn a->(a,a)
13:15:57 <lambdabot> f a = (a, a)
13:16:04 <FunctorSal> (yes, you wrote 'tries')
13:16:19 <FunctorSal> (just wanted to check if it's 'must' ;))
13:16:28 <ddarius> @djinn a -> b -> (Either a b, Either a b)
13:16:29 <lambdabot> f a b = (Left a, Right b)
13:16:30 <Twey> Could have scrolled up
13:16:37 <FunctorSal> :p
13:16:46 <burp> :t liftM2 (,) head tail
13:16:47 <lambdabot> forall a1. [a1] -> (a1, [a1])
13:16:47 <Twey> 21:08:28 < c_wraith> @djinn a -> Bool
13:16:48 <Twey> 21:08:28 < lambdabot> f _ = False
13:16:50 <CalJohn> Is there a way to represent unordered pairs anywhere in the standard library?
13:17:00 <Twey> Unused argument
13:17:11 <Twey> CalJohn: Unordered pairs?  Seems an odd thing to want
13:17:20 <Twey> What's your use case?
13:17:37 <FunctorSal> you could collect the unused bits and eventually store something in them :D
13:17:45 <Twey> Haha.
13:17:57 <CalJohn> i am doing maths
13:18:10 <c_wraith> Do you just care about sets of size 2?
13:18:28 <CalJohn> yes, i suppose that is also acceptable
13:18:52 <FunctorSal> I think you want your own type with a custom Eq instance
13:19:02 <vinicius> if you 'sort' every pair, it's unordered
13:19:12 <CalJohn> FunctorSal: yes, so do i, if there isn't one anywhere
13:19:12 <FunctorSal> yes or that
13:19:41 <CalJohn> @type (,)
13:19:42 <lambdabot> forall a b. a -> b -> (a, b)
13:20:09 <Baughn> CalJohn: You can newtype (,), deriving everything; all you need is a constructor that sorts the pair before storing it
13:20:31 <c_wraith> If you're working with instance of Ord
13:20:43 <c_wraith> *an* instance
13:20:55 <Baughn> Hm. How would you do it if it isn't in Ord?
13:21:00 <FunctorSal> is a newtype (,) equivalent to a data with two fields?
13:21:01 <Berengal> Do these pairs hold different types?
13:21:10 <Baughn> I suppose you'd need to check every combination in Eq, etc
13:21:10 <c_wraith> You can do it with just Eq
13:21:17 <FunctorSal> (admittedly newtype gets you gen. deriving)
13:21:32 <Baughn> FunctorSal: Equivalent in what sense?
13:21:45 <Berengal> If they hold different types, you need two constructors
13:21:53 <CalJohn> i have just done a data decl. with a new Eq
13:22:00 <FunctorSal> Baughn: bottoms-wise
13:22:04 <Baughn> FunctorSal: Then, no.
13:22:19 <FunctorSal> :(
13:22:22 <Berengal> Baughn, yes it is
13:22:31 <ddarius> @google Constructing Polymorphic programs with quotient types.
13:22:33 <lambdabot> http://www.citeulike.org/user/pedagand/article/5885906
13:22:33 <lambdabot> Title: CiteULike: Constructing Polymorphic Programs with Quotient Types
13:22:34 <Baughn> Oh, wait
13:22:36 <Baughn> Um..
13:22:37 <FunctorSal> (and thus performance-wise I guess)
13:22:50 <Baughn> ..no, it shouldn't be
13:22:56 <Baughn> Berengal: Are you /sure/
13:23:01 <FunctorSal> oooooh quotients... was that in response to anything ddarius?
13:23:15 <ddarius> That paper has an example of an unordered pair type.
13:23:17 <Berengal> Baughn, a newtype is just a compile-time wrapper. At runtime, it's the same representation, thus the same bottoms
13:23:34 <Baughn> Berengal: Same bottoms as (,), yes.
13:24:00 <Berengal> Baughn, right, and data (,) a b = (,) a b, which has the same bottoms as any data Pair a b = Pair a b
13:24:07 <Baughn> newtype Foo a b = Foo (a,b) does not have the same bottoms as data Foo = Foo (a,b)
13:24:14 <Berengal> They're the same, appart from the constructor name
13:24:26 <FunctorSal> isn't "data (,) a b = (,) a b" just a facade though? ;)
13:24:34 <Baughn> ..are we even asking the same question?
13:24:51 <Berengal> Baughn, that's true, but he asked about a data with two fields
13:24:58 <FunctorSal> mine is answered positively by what Berengal said, Baughn
13:25:22 <Baughn> ..I should go make a coilgun or something.
13:25:31 <FunctorSal> (tuples must be wired-in somehow)
13:25:48 <codnik> Hello. Anyone can give me a hand with Haskell installation on Ubuntu Karmic?
13:26:01 <codnik> I'm following this http://davidsiegel.org/haskell-platform-in-karmic-koala/
13:26:29 <codnik> I installed some packages manually and I'm getting an error now on make: Configuring the happy-1.18.4 package failed
13:26:40 <Baughn> codnik: What version of ghc is installed?
13:27:06 <Baughn> Pretty sure haskell-platform wants 6.10?
13:27:10 <codnik> Baughn: 6.10.4
13:27:28 <Baughn> codnik: Okay. Next step would be figuring out /why/ happy failed.
13:27:42 <Baughn> codnik: Check its directory for a config.log
13:38:34 <codnik> Baughn: you mean haskell-platform's?
13:38:53 <mmorrow> FunctorSal: i remembered after we were talking yesterday that there's a proper Type substitution function(s) in derive-gadt (along with free type vars, and a unifier)
13:38:53 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
13:38:57 <Baughn> codnik: Whichever.
13:39:14 <Baughn> codnik: Although, you should be aware that you don't actually /need/ haskell-platform. All you need is cabal-install, really.
13:39:43 <mmorrow> FunctorSal: well, that module dups the TH Type type exactly, but it's literally exactly the TH type
13:40:26 <codnik> Baughn: http://pastebin.com/d44d36423
13:40:38 <mmorrow> FunctorSal: http://hackage.haskell.org/packages/archive/derive-gadt/0.1.1/doc/html/src/Language-Haskell-Derive-Gadt-Unify.html
13:41:00 <FunctorSal> "clusterfrolick" ^^
13:41:01 <Baughn> codnik: I don't think that's the right one..
13:41:26 <Baughn> codnik: Oh well. I don't really know how the haskell-platform build system works. As such, may I recommend you download cabal-install and run the bootstrap.sh script instead?
13:42:14 <mmorrow> FunctorSal: it originally said clusterfuck ;)
13:42:40 <FunctorSal> mmorrow: I shall keep that module in mind too... so many scattered TH utils
13:43:06 <mmorrow> yeah, we need to gather everything in a coherent package
13:43:10 <FunctorSal> 'derive' has some handy combinators in Language.Haskell.TH.Helpers too
13:43:33 <FunctorSal> (e.g. make a pattern given a constructor)
13:43:37 <mmorrow> ooh, and with 6.12 the TH types change in breaking ways :)
13:43:45 <mmorrow> so all TH code immediately is borken
13:43:52 <FunctorSal> yes I already wrote a CPP macro in my expandSyns
13:44:03 <FunctorSal> you just need a little compatibility layer
13:44:08 * mmorrow needs to get on updating his TH code now
13:44:22 <mmorrow> FunctorSal: oh nice
13:45:31 <mmorrow> ooh, and a Type renamer too in that module
13:45:34 <FunctorSal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10627#a10627       (only abstracts the stuff needed by that module though)
13:46:03 * mmorrow really needs to organize his code so he doesn't keep rewriting things he's forgotten about
13:46:28 <FunctorSal> :)
13:47:00 <mmorrow> nice
13:47:12 <Berengal> mmorrow, put it all in a single module, then get in the habit of seeing if "doTheThingIWant" exists and has the right type before writing it
13:47:48 <mmorrow> Berengal: i have like 20+ modules filled with random TH-related stuff though
13:48:09 <Berengal> I had like 20 modules filled with half the Prelude each when I started out learning Haskell...
13:48:35 <Berengal> Now I just have one big module called Brelude, with 20 functions named foo#
13:48:43 <mmorrow> heh
13:48:51 <FunctorSal> ^^
13:48:56 <Berengal> Its.... not very useful, I must admit
13:49:13 <FunctorSal> is that even a legal name?
13:49:26 <Berengal> The # was a metasyntactic variable
13:49:30 <Berengal> or rather, character
13:49:44 <Berengal> (The foo wasn't, that's the real name)
13:49:47 <codnik> Baughn: trying to install that but it complains about parsec and network. i installed those but still get the error
13:50:16 <Baughn> codnik: ghc-pk list agrees that they're installed?
13:50:16 <FunctorSal> @remember Berengal Now I just have one big module called Brelude
13:50:17 <lambdabot> Okay.
13:50:49 <yitz> FunctorSal: with 20 functions named foo#
13:52:50 <codnik> Baughn: yup, but i noticed i had both parsec 2 and 3 installed.. removing 3 got rid of the error
13:52:58 * mmorrow wonders that Berengal.unsafePerformFoo# does
13:53:03 <mmorrow> err
13:53:09 <mmorrow> Brelude.unsafePerformFoo#
13:53:23 <FunctorSal> it's (fooUnsafePerform)
13:53:35 <mmorrow> #
13:53:46 <FunctorSal> # was the placeholder
13:54:03 <mmorrow> for UnsafePerform# ! ;)
13:55:05 <mmorrow> FunctorSal: another thing that needs work is the Language.Haskell.TH.Ppr module
13:55:30 <mmorrow> in many cases it produces invalid haskell syntax..
13:56:01 <FunctorSal> mmorrow: just sent in a fix for empty data decls and type operators
13:56:07 <mmorrow> nice
13:57:01 <FunctorSal> another one is that methods in instance decls are qualified, which is illegal
13:57:07 <FunctorSal> (no fix sent yet)
13:57:40 <mmorrow> yeah, the qualified names thing is annoying
13:57:57 <mmorrow> i use "cleanNames" to zap those
13:58:13 <mmorrow> = everywhere (mkT cleanName)
13:58:20 * FunctorSal wrote that too ;)
13:58:53 <mmorrow> one part that i initially overlooked was that you can' just do  (mkName . nameBase)
13:59:05 <FunctorSal> yep
13:59:07 <mmorrow> since that zaps NameL's uniq
13:59:20 <mmorrow> (or something along those lines)
13:59:39 <mmorrow> (s/can'/can't/)
13:59:45 <FunctorSal> I find the Name types's internals kinda scary
13:59:57 <FunctorSal> ;)
14:00:23 <mmorrow> FunctorSal: yeah, that's primarily why i duplicated it in that Unify module, the PackedStrings and Int#s are annoying
14:00:45 <mmorrow> although i know s/FastString/String/ in HEAD TH at least
14:01:02 <FunctorSal> nice
14:01:07 <mmorrow> someone should s/Int#/Int/ too
14:01:20 <PetRat> Is "forall a,b." correct syntax?
14:01:24 <mmorrow> since "{-# UNPACK #-} !Int" will get you the same thing
14:01:29 <FunctorSal> PetRat: no comma
14:01:36 <PetRat> forall a b.
14:01:43 <FunctorSal> (and you need a body)
14:02:02 <PetRat> This code is disembodied.
14:02:11 <mmorrow> heh
14:02:17 <FunctorSal> @kind (forall a b. Either a b)
14:02:17 <lambdabot> *
14:02:32 <sevvie> Ahhh would you /die/.
14:02:49 <FunctorSal> @die
14:02:49 <lambdabot> unexpected end of input: expecting number
14:03:05 <mauke> @die 6
14:03:05 <lambdabot> 6 => 6
14:03:21 <mmorrow> @die 400000
14:03:21 <lambdabot> 400000 => 400000
14:03:31 <mmorrow> useful
14:03:36 <FunctorSal> @die 3d400000
14:03:36 <lambdabot> 3d400000 => 644190
14:03:42 <mmorrow> oh
14:03:45 <mmorrow> err
14:03:48 <mmorrow> wut
14:03:54 <mauke> @die 2d6
14:03:55 <lambdabot> 2d6 => 5
14:04:01 <Baughn> @die 400000d2
14:04:01 <lambdabot> 400000d2 => 599648
14:04:35 <mmorrow> > let die = id in die 0x400000d2
14:04:36 <lambdabot>   1073742034
14:04:42 <mmorrow> what's it doing?
14:04:48 <mauke> rolling dice
14:05:01 <Baughn> Pretending to roll dice
14:05:04 <mmorrow> crazy
14:05:20 <Baughn> It's most certainly not running a 400000-iteration loop. :P
14:05:29 <mmorrow> @die 1
14:05:29 <lambdabot> 1 => 1
14:05:31 <mauke> why not?
14:05:32 <mmorrow> @die 2
14:05:32 <lambdabot> 2 => 2
14:05:34 <mmorrow> @die 3
14:05:34 <lambdabot> 3 => 3
14:05:37 <mmorrow> oo
14:05:37 <FunctorSal> I think sevvie meant his ghost
14:05:39 <Baughn> @die 999999999999999d2
14:05:39 <lambdabot> 999999999999999d2 => 1500000012533195
14:05:42 <Baughn> Because.
14:05:46 <mmorrow> @die 9874379872878489
14:05:46 <lambdabot> 9874379872878489 => 9874379872878489
14:05:48 <Zao> @die 2d8d4
14:05:48 <lambdabot> unexpected "d": expecting digit, "+" or end
14:05:52 <sevvie> her, and huh?
14:06:01 <Zao> Aaw, no nested dies :(
14:06:06 <mmorrow> oh, that isn't hex..
14:06:08 <mauke> "I think sevvie meant huh ghost"
14:06:13 <FunctorSal> sevvie: oh sorry
14:06:28 <FunctorSal> sevvie: I was just guessing whom you were telling to die ;)
14:06:33 <mmorrow> @die 9874379872878489d3
14:06:33 <lambdabot> 9874379872878489d3 => 19748759720078092
14:06:50 <sevvie> Funct, no worries.
14:07:01 <Samy> Anyone here have Mac OS X on PPC64 (G5)?
14:08:04 <mauke> does anyone here need a pastebin script?
14:08:23 <mauke> it can paste stuff to 13 different sites
14:08:23 <Samy> mauke, what is it written in?
14:08:25 <mauke> perl
14:08:29 <Samy> Cool.
14:08:33 <Samy> Yeah, that would be useful.
14:08:43 <mauke> http://mauke.ath.cx/stuff/perl/pastebin
14:09:18 <Samy> woo, you have pastie :D
14:12:13 <mmorrow> mauke: nice
14:12:43 <mauke> so apparently you're using firefox 3.0.11
14:12:54 <gwern> how old
14:13:01 <gwern> GET WITH THE TIMES GRANDPA
14:13:53 <mmorrow> heh, apparently so
14:14:01 * mmorrow had to check Help->About
14:14:48 <mauke> you know 3.5.3 is out, right? :-)
14:15:01 <mmorrow> i do now :)
14:15:50 * mmorrow does a long overdue sudo yum update -y
14:16:48 <gwern> sudo wrestling
14:16:49 <mmorrow> ah, the fedora10 yum repo i'm using is currently at 3.0.14
14:18:33 <Axman6> preflex: seen dons
14:18:34 <preflex>  dons was last seen on #haskell 1 day, 23 hours, 45 minutes and 45 seconds ago, saying: you'll just have to use a different nick, palomer
14:21:01 <Axman6> hoorah! RC1's out
14:24:21 <ilid> 6.12?
14:24:31 <adept> there is a C++ code that calls a user-defined callback, passing in an STL array of objects, which callback is supposed to call (if needed). Any chance that writing that callback in Haskell is possible?
14:24:49 <Axman6> ilid: yep: http://darcs.haskell.org/~ghc/dist/6.12.1rc1/
14:30:38 <Axman6> what's the easiest way to find out which packages are installed through cabal-install?
14:31:42 <cocon> I frequently encounter the following typeclass problem: say, C t can be derived from Num t; now, if Fractional t, then I would like to have C t derived differently
14:31:44 <c_wraith> cabal list
14:32:00 <c_wraith> or does that list things that aren't installed, too
14:32:03 <cocon> of course I'm doing something wrong, but is there a standard workaround?
14:32:07 <Axman6> lists everything
14:36:01 <SamB_XP> cocon: what is it that you are doing wrong ?
14:37:49 <Axman6> c_wraith: ha, using my awesome regex skillz,  have come up with this to find all Not installed packages and remove them: \*.*(\n.*\n.*\n.*(\n.*)?)\[ Not installed \]\n.*(\n.*)?
14:38:21 <c_wraith> if it works, don't question it. :)
15:01:22 <yitz> Axman6: could you say that in Parsec please?
15:09:18 <Axman6> yitz: not knowing parsec, i don't think i could
15:11:17 <SamB_XP> whoa ... I've got *two* instances of Explorer running ... I didn't know you could *do* that ...
15:11:48 <Axman6> in windows? i thought each explorer window was its own process
15:12:36 <Asztal> It can be, but that's not the default.
15:12:43 <SamB_XP> well, I've never seen it like that in Process Explorer
15:30:53 <hackagebot> pisigma 0.1.0.2 - dependently typed core language (AndresLoeh)
15:32:26 <ddarius> Hmm.  One should be able to do something analogous to the Futumura projections using supercompilation instead of partial evaluation.
15:32:43 <narens> anyone here used the TreeView in gtk? I can't seem to be able to map listStoreRemove with multiple indices. If i do, it only removes the first one.
15:34:23 <narens> nvm.... i got it
15:34:39 <codnik> What do you use for drawing graphics in Haskell? Besides GLUT...
15:34:59 <codnik> I see there's an abandoned Allegro binding project
15:35:10 <codnik> and SDL doesn't seem to have the stuff i need
15:35:12 <codnik> drawing lines
15:35:30 <skorpan> wxhaskell can do stuff like that
15:36:45 <ddarius> And Gtk's Cairo
15:37:11 <ddarius> and there are a few other libraries on Hackage that handle simple graphics.
15:37:21 <skorpan> sounds strange that SDL can't draw lines though :/
15:40:56 <ddarius> skorpan: There's a library, SDL_gfx that has line drawing routines, but the Haskell binding to it is ridiculously incomplete.
15:41:27 <ddarius> SDL itself provides no routines to draw anything.  It just provides access to the frame buffer.
15:42:51 <PeakerWork> there's SDL_draw
15:42:55 <codnik> yeah, it's missing the bindings for drawing lines...
15:43:08 <PeakerWork> SDL is divided into small libraries, that's a nice design
15:43:28 <dons> written up the work on self-specializing polymorphic types. http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/
15:43:30 <PeakerWork> I just make do and only draw rectangles/images :-)
15:43:35 <codnik> Is there an SDL_draw binding for Haskell?
15:43:36 <PeakerWork> you could use SDL just to set up an OpenGL canvas, too
15:43:41 <PeakerWork> codnik: I don't think so :-(
15:44:31 <codnik> PeakerWork: yeah, I liked the look of SDL_draw but since I can't use it in Haskell....
15:44:54 <olsner> build a binding! :)
15:45:08 <ddarius> codnik: Write the binding.  It should be very easy.  Haskell's FFI is pretty nice.
15:45:28 <codnik> PeakerWork: I also need text... How would I go about doing that?
15:47:02 <ddarius> codnik: There's an SDL_ttf library on Hackage (if you decide to use SDL)
15:47:06 <codnik> hmm I'd need bindings for SDL_draw and SDL_ttf also.
15:47:34 <ddarius> Cairo, wx, gtk, OpenGL, etc. all have some text rendering support somewhere.
15:47:57 <dcoutts> gtk's API is called Pango, it works with Cairo too
15:48:02 <codnik> I really wish the Allegro bindings were done...
15:48:06 <dcoutts> Cairo has a built-in "toy" text API
15:48:24 <p_l> dcoutts: afaik GTK has a choice of simple API or "giant" Pango
15:48:27 <Alpounet> codnik, IIRC, there are bindings for all the official SDL libs.
15:49:02 <dcoutts> p_l: Cairo does yes. Gtk+ itself always uses Pango.
15:49:40 <p_l> hmm... I thought it was possible to compile GTK2 apps without pango
15:49:49 <dcoutts> p_l: not afaik
15:50:00 <codnik> Alpounet: neither draw nor gfx are official
15:50:17 <p_l> dcoutts: well, last time I followed GTK+ changes was 2.6 I think :D
15:50:18 <Alpounet> oh... and isn't there a binding for it anyway ?
15:50:30 <codnik> Alpounet: no :( it's incomplete
15:50:47 <Alpounet> ok
15:50:52 <Alpounet> you could work on it :-p
15:51:07 <codnik> that's what I'm trying to avoid...
15:52:35 <Alpounet> heh
15:52:49 <Alpounet> once done, it could benefit all the haskellers.
15:53:13 <Alpounet> but I understand your point, don't worry... Days still last 24 hours...
16:09:00 <roconnor_> > 320*1024 / 30 /60 /60
16:09:01 <lambdabot>   3.034074074074074
16:09:08 <roconnor_> ugh
16:09:17 <roconnor_> 3 hours to zero out my drive
16:14:59 <sioraiocht> roconnor_: before the cops come?
16:15:28 <roconnor_> well before the cops come
16:15:40 <roconnor_> I'm trying to fill my new laptop drive with random data
16:16:11 <roconnor_> by mounting a encrypted device and filling the encrypted device with zeroes
16:16:18 <SimonRC> roconnor_: cops?!
16:16:47 <SimonRC> (now, off to bed)
16:17:19 <skorpan> before the shit hits the fan
16:20:51 <linuxaddictt> hi guys
16:21:15 <linuxaddictt> i'm from europe and just having a problem with xmonad
16:21:17 <Peaker> roconnor_, ??
16:21:48 <Peaker> codnik, you there?
16:21:48 <Saizan> linuxaddictt: if it's xmonad specific you might get better help on #xmonad
16:22:08 <codnik> Peaker: yes?
16:22:48 <roconnor_> Peaker: ??
16:22:50 <Peaker> codnik, SDL_ttf works well, about rendering text
16:22:55 <linuxaddictt> i just mod+shift +c skype and im now wondering how to get the window back, process is running... should be quick to solve but i didn't dinf any help
16:23:11 <Peaker> roconnor_, why are cops coming? Why would they look at your drive, and why do you care?
16:23:34 <codnik> Peaker: what about lines? I can't use OpenGL with that.
16:23:40 <Elly> roconnor_: why are cops coming? oO
16:23:42 <Peaker> linuxaddictt, kill and re-run skype?
16:23:43 <roconnor_> I don't know why they would look at my drive, probably to find something incriminating
16:23:52 <shaleny> linuxaddict, can't in be in a tray ?
16:23:52 <Peaker> codnik, why not?
16:24:00 <linuxaddictt> oh sure xmonad would be better
16:24:02 <Saizan> linuxaddictt: ime, you've to launch some "panel" application like lxpanel so that you get access to skype's trayicon
16:24:18 <Peaker> codnik, I think GLUT/GL is preferrable to SDL for portability (and its part of the Haskell platform), though I find SDL easier to use
16:24:20 <linuxaddictt> i don't habe any tray or something or gnome or ...
16:24:29 <roconnor_> Elly: I don't know if cops are coming, ... but just to be safe ...
16:24:41 <shaleny> linuxaddict, you can use stalonetray
16:24:50 <Elly> I see
16:25:07 <Peaker> roconnor_, do you want to send them on a wild goose chase or do you have something incriminating?
16:25:07 <shaleny> linuxaddict, or you can configure skype not to use tray (if it's possible at all, I don't know)
16:25:08 * Elly has encrypted root filesystems on both of her laptops :p
16:25:23 <codnik> Peaker: I want an easy way to draw text and lines.. It's painful to draw text with OpenGL and I cannot find a way to draw lines with SDL
16:25:28 <Elly> Peaker: um, nobody in their right mind would answer that question in the affirmative
16:25:34 <roconnor_> Peaker I hope there is nothing incriminating on my new laptop drive  ... yet.
16:25:58 <Peaker> codnik, of course you could bind SDL_draw
16:26:41 <Peaker> codnik, it seems like all of its functions are virtually the same
16:26:48 <Peaker> codnik, bind one function, you've bound them all
16:26:51 <aavogt> is there some way to get the Description field, module name out of haddock for all the modules in a cabal project?
16:26:51 <linuxaddictt> shaleny, stalonetray seems cool, just xlib
16:27:23 <FunctorSal> codnik: drawingcombinators package?
16:27:24 <roconnor_> aavogt: aren't the description names put in the haddock from the cabal file?
16:27:29 <FunctorSal> (didn't read everything)
16:27:36 * mmorrow 's laptop's root/all-others filesystems are also encrypted
16:27:39 <codnik> Peaker: I'm looking at the SDL binding and it uses black magic to bind surface pointers.
16:27:41 <Peaker> I wish SDL had decent accelerated backends (e.g GL)
16:27:58 <aavogt> roconnor_: they are in the hs files
16:28:05 <roconnor_> mmorrow: ya, I'm filling it with randomish data before starting
16:28:16 <FunctorSal> codnik: err, graphics-drawingcombinators
16:28:44 <roconnor_> aavogt: oh the descriptions of each module ... sorry
16:28:58 <linuxaddictt> shaleny, thx!!!
16:29:02 <aavogt> roconnor_: like the line(s) after Portability here: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Allegory.html
16:29:09 <shaleny> linuxaddict, not at all
16:29:14 <FunctorSal> Peaker: SDL doesn't have GL as backend?
16:29:26 <mmorrow> roconnor_: yeah, that takes forever. how many passes are you doing?
16:29:34 <roconnor_> mmorrow: just one
16:29:43 <roconnor_> I'm not wiping anything
16:29:48 <mmorrow> ah nice
16:29:59 <roconnor_> I just want to avoid leaking how much of the file system I've touched so far
16:30:32 <Peaker> codnik, it seems to do Surface ptr binding in a standard way.. what black magic do you see?
16:30:40 <codnik> FunctorSal: hmm Thanks. I'll give it a try.
16:30:46 <roconnor_> mmorrow: most people copy dev/urandom over the device, but there is another neat trick
16:30:49 <Peaker> FunctorSal, It had an experimental one once, I don't think it does anymore, and its pretty ridiculously slow, compared to OpenGL drawing
16:31:16 <roconnor_> mmorrow: instead create a throw away new encrypted device, and fill the encrypted device with zeroes
16:31:25 <codnik> Peaker: I don't know how pointer binding works in Haskell... X_X
16:31:35 <Peaker> roconnor_, are you sure nobody is optimizing out the zero writing?
16:31:54 <FunctorSal> WP: "On X11 platforms, including Linux and OpenVMS, SDL uses Xlib to communicate with the X11 system for graphics and events."
16:31:55 <Peaker> codnik, look at a couple of functions that take a surface ptr and see how they're bound, cause that's what SDL_Draw does
16:32:01 <roconnor_> Peaker: given the slowness, I doubt it
16:32:02 <FunctorSal> (you're right D:)
16:32:12 <roconnor_> Peaker: and it would also be just wrong
16:32:20 <mmorrow> i've always use shred
16:32:29 <Peaker> codnik, look at blitSurface for example
16:32:48 <roconnor_> mmorrow: the other nice thing about encrypted file systems, no real need to shreed them afterwards
16:32:54 <roconnor_> just shreed the encryption keys
16:33:14 <mmorrow> luks is nice
16:33:24 <gwern> roconnor_: eh, you think you're so clever, but what do the turtles stand on?
16:33:32 <roconnor_> I was using loop-aes before
16:33:38 <codnik> Peaker: what should it tell me?
16:33:56 <roconnor_> but I guess luks is the way to go today.  It seems to have no issues
16:34:17 <roconnor_> gwern: security is all a matter of degrees
16:35:00 <roconnor_> gwern: I'm well aware that you can pull the batter out of my computer, quickly boot off a usb stick and get my encryption keys
16:35:02 <Peaker> codnik, I don't know much about such bindings either, but I can reverse-engineer it from this code :)
16:35:02 <Peaker> codnik, I also know ForeignPtr is a Ptr that has a finalizer that's called when its GC'd
16:35:02 <Peaker> codnik, and withForeignPtr seems to let you access the Ptr itself
16:35:05 <Peaker> (in a way that probably guarantees it won't be finalized)
16:35:11 <Peaker> codnik, maybe I'll try my luck wrapping SDL_Draw
16:35:49 <gwern> it always freaks me out a little when my computer crashes or dies and on rebooting I see my old desktop briefly flashed
16:36:00 <codnik> Peaker: how long would it take you to do that, do you think?
16:36:13 <roconnor_> gwern: :)
16:36:26 <Peaker> codnik, Not sure, a couple hours, maybe
16:36:32 <gwern> it's like a ghost, reproaching me
16:36:32 <mmorrow> roconnor_: luks is nice because the aes keys for the actual drive are themselves encrypted, so you don't even have to shred anything
16:36:34 <Peaker> codnik, haven't bound mch
16:36:43 <mmorrow> roconnor_: and the key for the keys only ever exists in your head
16:36:45 <gwern> ('WHYYY GWERN YOU WUVVED ME!!!')
16:36:59 <Peaker> mmorrow, if its in your head its probably small enough to be brute-forced?
16:37:21 <mmorrow> Peaker: !2D5$#?jfsuiiijdiji#
16:37:22 <mmorrow> e.g.
16:38:00 <roconnor_> mmorrow: my use of loop-aes was a bit nicer since the keys weren't even on the laptop.  They were on my usbstick
16:38:04 <Peaker> mmorrow, hard to put that in head
16:38:09 <roconnor_> mmorrow: afaik, this is impossible with luks
16:38:14 <mmorrow> Peaker: s/that/something you'll remember/
16:38:15 <idnar> mmorrow: is that a mangled C++ symbol name?
16:38:49 <mmorrow> Peaker: mine is close to something like that actually, but i can remember it due to some random mnemonic i used to arrive at it
16:39:07 <mmorrow> roconnor_: but are the keys on the usbkey encrypted?
16:39:23 <codnik> Peaker: sounds good. I'll try my luck at the other package in the meanwhile. :P
16:39:23 <roconnor_> yes, they are encrypted as well
16:39:34 <roconnor_> with a passphrase I generated using diceware
16:39:36 <mmorrow> roconnor_: so who cares where they are then?
16:40:20 <mmorrow> idnar: i don't think anyone would be able to remember one of those
16:40:49 <roconnor_> mmorrow: if boarder guards take my laptop I might be able to destroy / lose my usbstick
16:40:53 <rtperson> hi all
16:40:55 <roconnor_> maybe that isn't likely enough though
16:41:19 <mmorrow> roconnor_: who cares though (assuming the encryption of the keys is secure)
16:41:37 <roconnor_> mmorrow: you can be ordered by a civil judge to enter your passphrase
16:41:42 <mmorrow> pfft
16:42:10 <mmorrow> that seems outrageous to me
16:42:19 <roconnor_> what does?
16:42:20 <aavogt> and you can 'forget' your passphrase?
16:42:20 <Peaker> codnik, it seems Ubuntu doesn't have SDL draw in it
16:42:30 <mmorrow> yeah, i forgot
16:42:36 <roconnor_> aavogt: I've wondered about that.
16:43:00 <aavogt> due to the stressful situation
16:43:08 <roconnor_> in the UK you can be sent to prision even in a criminal case If I understand well
16:43:19 <roconnor_> for not disclosing your key
16:43:43 <p_l> actually, not disclosing your key can make it a criminal case
16:43:46 <rtperson> sorry to intrude, but can anyone help a relative newb (me) with an OpenGL install question?
16:43:54 <mmorrow> it seems like someone who has more to loose by disclosing it would be happy to do so
16:44:00 <roconnor_> mmorrow: that is an option
16:44:03 <mmorrow> and those people that don't have more to lose would happily displose it
16:44:10 <mmorrow> so it seems pointless to me
16:44:20 <mmorrow> well, not "happily"
16:44:23 <roconnor_> well, the cost is something like 1 year in prison.
16:44:27 <roconnor_> I forget
16:44:30 <codnik> Peaker: http://sourceforge.net/projects/sdl-draw/files/SDL_draw/1.2.13/SDL_draw-1.2.13.tar.gz/download
16:44:45 <roconnor_> but if you have no key to disclose, then no prision I suppose
16:44:50 <medfly> if it worries you, the police is usually extremely incompetent in my experience. you'd have to murder someone to actually get into trouble.
16:45:01 <Saizan> rtperson: just ask, this channel is here for that :)
16:45:21 <roconnor_> medfly: i'm not really worried, this is more fun than anything else
16:45:46 <rtperson> Saizan: thanks, it just seemed like a heavy conversation.. But here's the issue
16:46:41 <rtperson> On Vista, I'm trying to connect the freeglut 2.4 libraries (hand compiled, with MinGW) with GLUT-2.2.2.0
16:46:43 <p_l> medfly: or get *accused* of rape. The fact that the only contact with victim was few hours before, you simply knew each other and there's absolutely no evidence is irrevelant ;-)
16:46:53 <rtperson> I've done this before on both Vista and XP
16:47:20 <rtperson> But this time, when I run Setup configure, I get no messages back
16:47:42 <Saizan> "runghc Setup configure"?
16:47:51 <Peaker> codnik, I'm a bit shocked its not Ubuntuized
16:47:58 <Peaker> the source package seems to be debianized
16:48:17 <codnik> Peaker: I ran accross lots of those today... I wouldn't be surprised.
16:48:19 <Saizan> rtperson: not even "Configuring $pkg ..."?
16:48:22 <rtperson> here's the response:$ runghc setup configure /
16:48:22 <rtperson> Configuring GLUT-2.2.2.0...
16:48:27 <rtperson> and nothing else
16:48:29 <Saizan> ah, that's ok
16:48:30 <rtperson> nothing
16:48:55 <Saizan> it's verbosity got tuned down
16:49:02 <medfly> I'm not tolerant of this "all rapes are faek!!111oneone" approach. there's a friggin rape kit. they actually test if there's semen in the girl, and if you had sex with a girl that would accuse you of rape so quickly, you probably deserve it.
16:49:14 <rtperson> oh. How do I crank it up?
16:49:31 <Saizan> rtperson: -vN where n=1..3
16:49:47 <rtperson> 3 being the most verbose?
16:49:51 <Saizan> yes
16:49:55 <Peaker> medfly, that's silly. If someone's a bad judge of character, he deserves to be blamed of rape?
16:49:56 <rtperson> ok, trying it now...
16:49:59 <Saizan> and -v being equal to -v1
16:50:16 <medfly> I don't know. I think you're kind of asking for it if you're having sex with a person you barely even know.
16:50:23 <Saizan> rtperson: however if it prints only that line it means that it completed succesfully
16:50:36 <Peaker> medfly, can you come to #haskell-blah ?
16:51:15 <rtperson> Saizan: yeah, but when I try to run an OpenGL program in GHCi, it fails to link the library
16:51:46 <Peaker> rtperson, fails to link GLUT?
16:52:14 <rtperson> Peaker: Yes, I get the message "*** Exception: user error (unknown GLUT entry glutInit)"
16:52:48 <Peaker> rtperson, I am not sure if its this problem but iirc when libXmu is missing in the "configure" step of GLUT, instead of failing, it builds the library but forgets to put "-lGLUT" in its ld flags in the package info
16:53:34 <roconnor_> mmorrow: oh, I can use luks keyfiles to do what I want if I want
16:55:02 <rtperson> Peaker: hmmm. What can I do to work around this? (Like I said, I'm a bit of a newb...)
16:56:12 <rtperson> Peaker: or do I need to find and/or compile a Windows version of libxmu?
16:56:36 <mmorrow> roconnor_: yeah, luks is nice
16:56:43 <Peaker> rtperson, grep GLUT ~/.ghc/<your ghc ver>/package.conf
16:58:46 <rtperson> Peaker: I wish it were that easy -- Vista box.
16:58:59 <rtperson> I'll hunt around for it...
16:59:26 <rtperson> Peaker: OK, I found package.conf
16:59:45 <rtperson> Peaker: ... and I found GLUT
17:01:16 <rtperson> Peaker: and I found extraGHCiLibraries, includeDirs, includes, etc... I assume I need to add something here?
17:02:48 <Peaker> rtperson, what does the linker flags says?
17:02:52 <Peaker> rtperson, ldflags that is
17:03:38 <rtperson> Peaker: it's blank
17:03:45 <Peaker> rtperson, that's the problem, I think
17:03:53 <rtperson> Peaker: yeah, makes sense
17:03:57 <Peaker> rtperson, put the string "-lGLUT" in the ldflags list
17:04:07 <Peaker> its an annoying but in GLUT that I think I reported (but maybe I didn't)
17:04:11 <Peaker> s/but/bug
17:04:21 <Peaker> and that's biting lots of lots of people
17:04:34 <Peaker> (libXmu or other dependency missing -> builds successfully but misses ld flags)
17:04:57 <rtperson> it seems very recent -- I didn't see this two months ago, when I last installed
17:06:02 <Peaker> rtperson, maybe you had the dependencies installed
17:06:08 <Peaker> rtperson, did it fix your problem?
17:06:29 <rtperson> Peaker: I'm checking now...
17:06:47 <codnik> uhm... I get an error trying to install the SDL-image binder
17:06:54 <codnik> the library is already correctly installed
17:07:18 <rtperson> Peaker: I'm closer. Now I'm getting can't load .so/.DLL for GLUT (which just means it can't find the library)
17:07:58 <codnik> error I get says: dist/build/Graphics/UI/SDL/Image/Version.hs:1:0: File name does not match module name: Saw: `Main' Expected: `Graphics.UI.SDL.Image.Version'
17:08:18 <codnik> no errors on configure
17:08:26 <codnik> this is on the build command
17:10:27 <rtperson> Peaker: it's not fixed yet, but I've definitely been here before. Is there a flag in package.conf that I can use to point it to the glut32.dll?
17:10:49 <Peaker> rtperson, perhaps linkerDirs or such?
17:10:58 <Peaker> rtperson, also, try -lglut32 maybe
17:13:00 <rtperson> Peaker: I'll play around with it. I'm pretty sure I can get it from here. If not, I'll be back. Thanks for your help!
17:14:37 <Peaker> rtperson, sure
17:33:43 <shazam> erm, if a is a unit and x is a nilpotent then a+x is a nilpotent
17:34:00 <shazam> the proof involves me looking at the power series expansion of (1+x/a)^-1
17:34:07 <shazam> but I don't know what that means:/
17:34:14 <shazam> what's the power series expansion?
17:35:59 <sjanssen> shazam: is this a Haskell question?
17:36:10 <shazam> woops
17:36:13 <shazam> wrong channel
17:36:14 <shazam> sorry
17:39:58 <sjanssen> @seen dons
17:39:59 <lambdabot> Unknown command, try @list
17:40:05 <sjanssen> preflex: seen dons
17:40:05 <preflex>  dons was last seen on #haskell 1 hour, 56 minutes and 36 seconds ago, saying: written up the work on self-specializing polymorphic types. http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/
18:06:01 <c0c0b0ng0w> I've heard haskell pwns other language's asses
18:06:24 <xci> your source of information seems legit
18:07:43 <Vanadium> @faq Can haskell pwn other languages' asses?
18:07:43 <lambdabot> The answer is: Yes! Haskell can do that.
18:11:41 <km0r3> lol!
18:12:04 * km0r3 nods agreeingly
18:12:59 <absentia> wtf..
18:13:40 <gwern> objection!
18:13:40 <absentia> I went to purchaes this at my local B&N:  http://search.barnesandnoble.com/Programming-in-Haskell/Graham-Hutton/e/9780521692694
18:13:45 <absentia>  ahem.. $135?
18:13:47 <gwern> I move that last comment be stricken from the record
18:13:50 <absentia> talk about.. barier to entry!
18:13:53 <gwern> as absentia is clearly present
18:14:00 * absentia is not (really) here.
18:14:15 <absentia> altouhgh, I was convicted in absentia...  got the headline from drudge to proove it.
18:14:17 <gwern> you *say* that, but can I believe you?
18:14:37 <absentia> you can believe anythig you ever read or are told on the internet.
18:14:44 <absentia> believe me.
18:14:53 <gwern> that's precisely the question tho
18:15:42 <gwern> oh the inphilosophy of it all!
18:20:33 <c0c0b0ng0w> Guys I was also told that Optimus Prime was written in haskell
18:20:37 <c0c0b0ng0w> Is this true?
18:20:42 <tomh-> yes
18:21:00 <c0c0b0ng0w> What language was Megatron written on?
18:21:06 <tomh-> lisp
18:21:11 <tomh-> thats why he lost
18:21:30 <gwern> he hit a typecast error
18:21:52 <gwern> and his programmer didn't understand conditions well enough to handle it
18:24:30 <c0c0b0ng0w> Let me see if I get this clear. Basicly if Megan Fox lived in Matrix, her body would've been written in haskell, and her brain in Perl.
18:24:56 <c0c0b0ng0w> Is this a plausible analogy?
18:27:34 <monochrom> Is this a troll?
18:28:41 <c0c0b0ng0w> monochrom, No
18:28:50 <c0c0b0ng0w> I'm simply asking extremely relevant questions
18:30:05 <Axman6> what are you programmed in c0c0b0ng0w?
18:30:56 <c0c0b0ng0w> Axman6, I'm pretty leet, so I'm pretty sure me was developed using either Scheme or Haskell
18:31:00 <c0c0b0ng0w> My body is another story
18:31:15 <Axman6> yeah, I have a Java body
18:31:19 <Axman6> but a haskell mind
18:31:21 <c0c0b0ng0w> I'm fat, pretty sure was written in either Perl or ruby
18:31:24 <aavogt> @elite Axman6, I'm pretty leet, so I'm pretty sure me was developed using either Scheme or Haskell
18:31:24 <lambdabot> 4X/\/\an6, i'M pRe7TY LEE7, So i'M PretTy $ure /\/\3 \/\/AS De\/eLoPeD USING 3I+HeR 5C|-|3m3 or HAzxe|L
18:31:59 <c0c0b0ng0w> LoLeEtBoT
18:32:20 --- mode: ChanServ set +o monochrom
18:32:23 --- mode: monochrom set +b *!*@190.75.214.239
18:32:44 <Axman6> hmm, i don't think he lift willingly...
18:34:46 <sohum> @pl \x -> show x ++ " suffix"
18:34:47 <lambdabot> (++ " suffix") . show
18:35:03 <dons> bos: http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/#comments  is there a way yet to fix the x axis?
18:35:32 <aavogt> @type flip shows " suffix"
18:35:33 <lambdabot> forall a. (Show a) => a -> String
18:35:43 <bos> dons: not yet!
18:35:53 <aavogt> sohum: ^^ that's probably faster
18:35:56 <dons> bos: check the comments :)
18:36:02 <bos> dons: i got distracted by, you know, the original task i developed criterion for :-)
18:36:07 <dons> people are noticing the distincitve graph style.
18:36:10 <bos> dons: i know, it's the #1 asked for feature
18:36:11 <dons> which is good
18:37:55 <sohum> aavogt: ooh, thanks
18:39:03 <bos> dons: my preference would be to refactor the code to run a group of measurements together, then use the same axes for the lot
18:39:11 <bos> dons: lovely writeup, by the way
18:40:11 <dons> cheers. i'm having an escape in santa fe before the conference next week, getting some loose ends tied up
18:40:33 <dons> i like the idea of groups to delimite shared axes
18:41:45 <bos> santa fe is nice.
18:41:57 <bos> hmm, ghc build fail.
18:44:06 <heatsink> Is there an explanation of the density-of-execution-time metric?
18:44:51 <monochrom> Does "density" mean "probability density function"?
18:45:31 <heatsink> Kernel density estimation, but I don't know what that means yet
18:45:59 <dons> probability of getting a particular execution time, or some such.
18:46:55 <jmcarthur> it's an estimation of the probability density function
18:47:11 <monochrom> yay
18:48:15 <jmcarthur> although i am not 100% sure why it's considered better than a raw histogram
18:48:22 <jmcarthur> i don't know much about it
18:49:33 <jmcarthur> that is, i understand the value of a probability density function, but i don't understand the value of an estimation based on raw data which can just as easily be visualized by itself
18:50:08 <heatsink> It's a convolution applied to the histogram, and I guess it removes noise in the output.
18:50:24 <Axman6> dons: interesting article. it's stuff that i've played with a littlr before, but never took it anywhere near as far. very nice
18:51:08 <jmcarthur> heatsink: true, but human pattern recognition is pretty darn good at ignoring noise, too
18:51:27 <bos> it's not a convolution of the histogram, it's a convolution of the data
18:52:02 <bos> histograms require manual tuning, so they're useless as an automated tool.
18:52:16 <heatsink> oh, right.  It saves you from manually picking a useful histogram bin size.
18:52:25 <heatsink> good point.
18:52:25 <bos> correct.
18:52:34 <jmcarthur> aha
18:54:32 <sohum> @djinn ([a],[b]) -> ([a],[b]) -> ([a],[b])
18:54:32 <lambdabot> Error: Undefined type []
18:54:40 <sohum> wut
18:54:46 <aavogt> id?
18:54:58 <heatsink> const
18:55:19 <sohum> nah
18:55:20 <heatsink> or maybe flip const
18:55:22 <sohum> hm.
18:55:45 <heatsink> :t or maybe flip const
18:55:46 <lambdabot>     Couldn't match expected type `[Bool]'
18:55:46 <lambdabot>            against inferred type `b -> (a -> b) -> Maybe a -> b'
18:55:46 <lambdabot>     In the first argument of `or', namely `maybe'
18:56:22 <aavogt> @type uncurry ((++) *** (++))
18:56:23 <lambdabot>     Couldn't match expected type `b -> c'
18:56:23 <lambdabot>            against inferred type `([a] -> [a], [a1] -> [a1])'
18:56:23 <lambdabot>     In the first argument of `uncurry', namely `((++) *** (++))'
18:56:34 <aavogt> @type curry ((++) *** (++))
18:56:35 <lambdabot> forall a a1. [a] -> [a1] -> ([a] -> [a], [a1] -> [a1])
18:56:46 <sohum> I'm looking for tupleConcat :: [([a],[b])] -> ([a],[b])
18:56:50 <aavogt> @type ((++) *** (++))
18:56:51 <lambdabot> forall a a1. ([a], [a1]) -> ([a] -> [a], [a1] -> [a1])
18:56:54 <heatsink> @hoogle Bifunctor
18:56:54 <lambdabot> No results found
18:57:13 <Axman6> sohum: could easily use foldr there
18:57:22 <Axman6> :t foldr
18:57:23 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:57:35 <sohum> Axman6: I know, I know, but there should be a way to build it up
18:57:42 <aavogt> :t uncurry unzip
18:57:43 <lambdabot>     Couldn't match expected type `b -> c'
18:57:43 <lambdabot>            against inferred type `([a], [b1])'
18:57:43 <lambdabot>     In the first argument of `uncurry', namely `unzip'
18:57:49 <aavogt> :t unzip
18:57:50 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
18:57:51 <Axman6> it's ot exactly a very common function ;)
18:58:08 <Saizan> ?type mconcat :: [([a],[b])] -> ([a],[b])
18:58:09 <lambdabot> forall a b. [([a], [b])] -> ([a], [b])
18:58:31 <Saizan> yay for typeclasses
18:58:33 <sohum> :t mconcat
18:58:34 <lambdabot> forall a. (Monoid a) => [a] -> a
18:58:40 <sohum> shiny
18:58:45 <sohum> /really/ shiny
18:58:54 <Axman6> @instances Monoid
18:58:55 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:01:21 <sohum> this is why both haskell and #haskell are awesome :D
19:01:40 <Axman6> yes indeed
19:04:23 <roconnor_> > 320*1000*1000/1024/1024
19:04:24 <lambdabot>   305.17578125
19:05:14 * Saizan wonders if you can make a reasonably fast indexing based on unification
19:05:31 <heatsink> What's an indexing?
19:05:56 <Saizan> uhm, i should have said an index
19:06:30 <Saizan> however a way to extract all the types from a set, which unify with the given key
19:07:30 <Saizan> it seems you could use a trie
19:08:08 <heatsink> If you're using structural equality for unification, then I'd say that's what it boils down to.
19:09:59 <SmurfOR> I'm reading RWH and I'm on chapter 5 i was wondering why they don't use record syntax to define the accessors is it because Maybe is used?
19:12:26 <heatsink> SmurfOR, Are you asking about getInt, getDouble, etc.?
19:12:57 <SmurfOR> yeah
19:13:20 <SmurfOR> i feel like i'm missing something very simple as to why it was chosen vs defining the types then using record syntax
19:13:58 <monochrom> Perhaps pedagogical reasons.
19:14:23 <monochrom> Avoid information overload at all costs.
19:15:13 <SmurfOR> hmmm nevermind i think i understand now
19:15:33 <SmurfOR> it's because it's just a value, not an object/record with more than one field (i think?)
19:15:36 <heatsink> SmurfOR, Even with record syntax, you still need to match against a constructor name and a variable.
19:16:52 <heatsink> Record syntax is good when you have many possible fields and you only want some of them
19:17:05 <Saizan> is it a type like data Foo = AnInt Int | ADouble Double | .. ?
19:17:07 <SmurfOR> yeah an algebraic type makes sense in this case
19:17:43 <heatsink> When your constructors only have one field, like "JNumber n", then you usually want to get the field when you match the constructor name, so having a field name doesn't make things any nicer.
19:17:47 <monochrom> "data JValue = JString {getString :: String} | JNumber {getNumber :: Double} | ..."
19:18:11 <SmurfOR> monochrom, you can do that? neat :)
19:18:14 <monochrom> You may be thinking of that. It may have advantages in production code.
19:18:41 <SmurfOR> no, i was just thinking erroneously
19:19:04 <monochrom> But it makes no teaching sense. One thing at a time. Reader has just begun with user-defined types, why teach everything at once?
19:19:12 <SmurfOR> yeah
19:20:23 <SmurfOR> the number of ways you can do just one thing is kind of overwhelming at first
19:26:00 <monochrom> I'm happy that RWH is on the web with no barrier.
19:27:11 <monochrom> In #math, people ask questions, eventually we have to read the same book he reads to resolve the question, but no one else has access to the book. It flies in the face of the scientific method.
19:28:37 <SmurfOR> yeah the website is what got me to buy the book
19:28:45 <SmurfOR> i read the first few chapters and immediately bought the book
19:29:28 <mauke> monochrom: why so +o?
19:29:45 <SmurfOR> the comment system used is great too if i have a specific question i can read comments and usually get an answer
19:29:49 --- mode: monochrom set -o monochrom
19:29:53 <boxxy> the comment system used is great too if i have a specific question i can read comments and usually get an answer
19:30:06 <mauke> w
19:30:09 --- mode: ChanServ set +o monochrom
19:30:09 <boxxy> w
19:30:11 <absentia> which book?  I just ordered the hutton book
19:30:16 <boxxy> which book?  I just ordered the hutton book\
19:30:16 <SmurfOR> real world haskell
19:30:20 <boxxy> real world haskell
19:30:23 --- mode: monochrom set +b *!*@c-24-91-98-29.hsd1.ma.comcast.net
19:30:23 --- mode: ChanServ set +o mauke
19:30:33 <mauke> wtf, I'm lagged
19:30:37 --- mode: mauke set -o mauke
19:30:48 <absentia> ah, I read that online.  I'll read that again after I do the hutton book... all the reviews seem to say that the hutton book is the best intro to haskell
19:31:06 --- mode: ChanServ set +o mauke
19:31:07 --- mode: mauke set -o mauke
19:31:25 <SmurfOR> yeah i have the hutton book and "The Haskell School of Expression" by Paul Hudak
19:31:27 <monochrom> I swear I was not behind that bot, I was not creating a situation to justfy opping! :)
19:32:28 <Axman6> power addict!
19:32:38 <lpsmith> what's the default version of GHC that cabal uses?
19:33:04 <Axman6> lpsmith: not the other way around?
19:33:17 <Saizan> cabal uses what it finds on the $PATH as "ghc"
19:33:30 <lpsmith> gotcha, thanks :-)
19:33:38 <lpsmith> I should have guessed
19:34:24 <aavogt> for line wrapping, is a greedy algorithm good-enough (I'm not doing any hyphenation)
19:35:19 --- mode: monochrom set -b *!*@190.75.214.239
19:35:25 --- mode: monochrom set -o monochrom
19:35:46 <heatsink> aavogt: Should be good enough for most purposes.  If you want optimum, it might be a dynamic programming problem.
19:37:09 <lpsmith> was boxxy actually a bot?   why did it add the \ at the end of the one copycat response?
19:37:21 <absentia> boxie?
19:37:32 <absentia> wasn't that the name of the stupid robot on buck rogers?
19:37:34 <heatsink> Hmm.  If you're just trying to minimize the number of lines of text, I think the greedy algorithm will be optimal.
19:38:09 <absentia> boxy.. spelled differently.
19:38:34 <mauke> it claims to be mIRC
19:42:24 <monochrom> I use greedy for line wrapping. Manually too. Knuth uses dynamic programming for it in TeX. The TeXBook has it.
19:43:40 <harrison> yeah, you can use dijkstra's algorithm for line wrapping, i think.
19:44:13 <harrison> had to do it in one of my math classes.
19:44:14 <SamB_XP> monochrom: what does he do for page breaking, I forgot ...
19:44:14 <SamB_XP> and I'm too lazy to read it in the book
19:52:19 <dons> hey all, comments sought for a position paper about haskell and edsls http://www.reddit.com/r/haskell/comments/9t3ay/comments_sought_for_position_paper_on_haskell_and/c0eb9k5?context=3
20:00:41 <ddarius> dons: Your footnote seems apropos to nothing.
20:01:48 <dons> yeah :/
20:02:08 <dons> except the audience only cares about parallel programming, and i want to cover two topics.
20:02:14 <dons> but yes, well spotted
20:02:43 <dons> i'll think some more.
20:03:23 <dons> i don't really want to give a position paper on 'haskell is good for parallelism', more that "you should know about haskell, and know how to build EDSLs in it"
20:03:25 <ddarius> dons: Possibly tack it on to the GPU section.
20:03:34 <dons> "and steal some ideas from haskell, please"
20:03:36 <dons> good idea.
20:03:41 <absentia> xn/whois dons
20:03:45 <dons> i am.
20:04:07 * ddarius wonders if Don Syme ever comes here.
20:04:41 <absentia> How 'bout Don Move.  He was a cop, wasn't he?
20:06:39 <ddarius> dons: I'm not sure how to fit it, and I don't particularly know your audience, but perhaps some more result-oriented statements.  As opposed to "EDSLs were used here." something like "EDSLs were used here and accomplished X." or simplified/improved performance/reduce LOC etc.
20:07:14 <Axman6> dons: with this specialised lists thing, do you think you'd get any benefits for something like [Maybe a]? by using something like data List (Maybe a) = LJust !a (List (Maybe a)) | LNothing (List (Maybe a)) | End? or would that have basically the same overhead?
20:07:16 <dons> oh, that's a good idea.
20:07:39 <dons> not sure, Axman6 . you could try converting sums to products + tags
20:07:58 <Axman6> not sure what you mean
20:08:11 <Axman6> > True +
20:08:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:08:12 <dons> just flatten the sums into products, then use a regular tuple encoding.
20:08:15 <Axman6> > True + True
20:08:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
20:08:16 <lambdabot>    arising from a use of `GHC.N...
20:08:24 <Axman6> bah, must've been removed
20:09:10 <newsham> whats a good FRP lib to use for a network server?
20:10:08 <Axman6> dons: anyway, i guess what i'm getting at is whether multi-constructor types would benefit much from the idea or not
20:10:37 <Axman6> UNPACK only works on single constructor types anyway right?
20:11:43 <copumpkin> you're talking about "distributing" the sum over the list's constructor, right?
20:11:53 <copumpkin> not only for Maybe but Either and other sums?
20:12:10 * Axman6 has a feeling he doesn't understand how sum is being used here
20:13:01 <Axman6> sum, to me, means (+)/sum ...
20:13:37 <dons> Axman6: right
20:13:54 <Axman6> about which part? :P
20:13:57 <dons> Axman6: sum as in "sum types" - types with multiple constructors, like Maybe.
20:14:00 <dons> and right about unpack.
20:14:13 <Axman6> ah, i see. i'd never heard sum used like that
20:14:17 <dons> ah
20:14:20 <copumpkin> there's also product types :)
20:14:48 <copumpkin> Axman6: I'd imagine that if you give someone full knowledge of the distributed constructors as you described, you could get faster, but to provide a uniform front-end, you'd need to reconstruct a Maybe and feed it to your user
20:14:50 <ddarius> And exponents
20:14:59 <copumpkin> and derivatives, apparently
20:15:13 <copumpkin> and differences :o
20:17:35 <c_wraith> I don't suppose there's a darcshub out there?
20:18:05 <ddarius> patch-tag.com
20:18:06 <copumpkin> patch-tag is moving in that direction
20:18:21 <c_wraith> hmm.  I shall investigate
20:19:18 <c_wraith> step 1:  it'd sure be nice if their site wasn't broken with javascript disabled
20:19:24 <copumpkin> :P
20:19:44 <copumpkin> definitely not close to being as polished as github
20:20:43 <c_wraith> Still, I'm not looking for extreme polish
20:22:34 <copumpkin> Veinor: oh wow, it looks just like a college dorm room!
20:25:22 <Veinor> copumpkin: :D
20:25:30 <Veinor> I can't imagine why!
20:30:24 --- mode: ChanServ set +o mauke
20:34:19 <heatsink> dons: It looks like the conference has a lot of representation from groups who aren't even willing to waste computing resources on an operating system.  I'm wondering if they'll be skeptical from the start about the cost of running a high-level language.
20:43:03 <dons> heatsink: i'm advocating an EDSL for code generation, not for running haskell directly
20:43:21 <dons> write in haskell, generate your OS-free C or asm directly. skip the painful bits
20:43:35 <dons> but good thing to point out -- i'll need to be careful to reenforce that
20:43:59 <heatsink> Ah.  Perhaps make it a little more concrete how things get from code to machine.
20:44:40 <dons> good idea.
20:45:18 <heatsink> Also, not a major thing, but switching the order of the last two EDSL examples would put the two application examples together.  I think it'd read better.
20:45:26 <dons> oh, good idea.
20:45:29 * dons takes notes
20:45:34 <heatsink> :)
20:48:26 <ivanm> dons: so with your adaptive list post, map for example pulls apart a list-like data type and constructs a brand-new list-like datatype?
20:48:56 <ddarius> ivanm: It does that anyway.
20:49:18 <dons> ivanm: yes.
20:49:18 <ivanm> ddarius: well, yes, but in this case it's creating a completely different list-like type IIUC
20:49:29 <dons> not if they're the same type.
20:49:39 <dons> or, i don't understand what you're hinting at.
20:49:54 <ivanm> dons: I like it how you automatically say "As usual, I will use criterion..." when it hasn't been out for that long ;-)
20:50:00 <dons> :)
20:50:06 <dons> set the psychological landscape
20:50:15 <ivanm> dons: no, that's what I was getting at, that the generic class functions let you change list representations "mid-stream" like that
20:50:28 <dons> yep, same as normal lists.
20:50:59 <ivanm> how did you do mean on the adaptive int list? same as for normal lists?
20:51:16 <ivanm> or did you use the statistics library somehow?
20:51:16 <ddarius> instance AdaptList () where data List () = Integer
20:51:29 <dons> i've not written mean on that, btw.
20:51:32 <dons> ddarius: indeed.
20:51:37 <dons> ad hoc choices are possible.
20:52:07 <ivanm> ahh, I somehow read mean when you did map...
20:52:09 <ivanm> :s
20:52:11 <copumpkin> how long would repeat () be
20:52:23 <dons> copumpkin: it'd be O(1)
20:52:31 <ivanm> heh
20:52:58 <aavogt> ddarius: isn't [()] usually used as some kind of lazy natural though?
20:53:28 <ddarius> aavogt: Not by any sane people, but yes, such a representation decision would upset the insane people.
20:53:34 <ivanm> dons: how much implementation difference does it take to use adaptive lists in code?
20:54:37 <ivanm> bos: your criterion library is so good, dons seems to have trouble imagining a time when he couldn't use it! ;-)
20:55:23 <bos> ivanm: heh
20:55:47 <dons> it's like how we did testing before quickcheck --- we didn't.
20:55:58 <ivanm> heh
20:56:27 <ddarius> I believe it was Ward Cunningham who used to refer people to the wiki whenever they asked questions even if the answer wasn't there.  He'd just make sure it was before they got there.
20:56:32 <ddarius> One could do that with hackage...
20:56:36 <dons> hehe
20:57:00 <ivanm> ddarius: only for some of us (e.g. dons)...
20:57:24 <bos> is it known that 6.12 doesn't build on ppc?
20:57:28 <monochrom> No wonder @hackage is id.
20:57:39 <ivanm> bos: :o
20:57:52 <ivanm> I know that trofi and mjrosenb took a while to get 6.10.4 working on ppc64...
20:58:18 <heatsink> bos: I've encountered a problem in stage-2, but I haven't tried to debug it.
20:58:21 <heatsink> in building stage 2
20:58:41 * bos is bringing up 6.12 RC1 on fedora, and the PPC build fails
21:02:05 <bos> dons: it sure would be fun to see a strictified map or finger tree type using type families to give high fanout
21:02:22 <dons> 'zactly.
21:02:43 <ivanm> I thought someone was saying the other day here that there are efficiency/implementation problems still with type/data families though... >_>
21:02:45 <bos> would be nice to have a strict map, period, in fact.
21:02:54 <ddarius> instance AdaptMap Int where data Map Int = IntMap
21:02:57 <dons> need to be careful with the inlining for those more complex functions, but seems doable.
21:02:59 <ivanm> bos: no laziness? :o
21:03:16 <bos> ivanm: right
21:03:27 <dons> probably not needed in Data.Map that much.
21:03:37 <dons> mostly small keys and values.
21:04:20 <ddarius> instance AdaptList (Lazy a) where data List a = [a]
21:04:35 <bos> holy crap, ICU supports 282 locales on my machine
21:04:43 <copumpkin> ddarius: you'd need an additional constructor
21:04:58 <ddarius> Stupid data families.
21:05:02 <ivanm> heh
21:05:34 <bos> dons: do you know if it's "safe" to pass an Arr# to C code?
21:05:43 <dons> it'll get moved, won't it?
21:05:55 <bos> well, that's what i was wondering.
21:05:56 <dons> and you can't 'touch' it to keep it live either?
21:06:14 <bos> this would be C code that would just operate on it and return immediately, not a persistent kind of dealie.
21:06:16 <dons> you might be able to do it via 'safe'?
21:06:26 <dons> i.e. shut down the GC and do the call
21:06:29 <bos> yeah
21:06:30 <dons> not sure if that's legit.
21:06:41 * bos wonders if that'd be cheaper than copying or not
21:06:57 <dons> hard to say.
21:07:06 <bos> i'd like the interface to ICU to not involve huge amounts of copying and allocation, if possible.
21:07:13 <bos> but i'd even more like it to not crash
21:16:13 <trofi> bos: how does ghc ppc build failure look like?
21:27:07 <ddarius> So I had this idea a few months ago about a really high-level way of reading and writing binary data.  The idea is essentially to make a logic language whose "database" of facts is the data of a binary file.
21:27:23 <solidsnack> okay
21:29:11 <Axman6> ddarius: where's the paper? :O
21:29:12 <Axman6> :P
21:29:40 <ivanm> yes, after all, nothing exists in the Haskell community without an academic paper to back it up...
21:29:54 <ivanm> Axman6: oh, btw, is dons still going to be giving a talk at ANU?
21:30:23 <ddarius> It would probably make a decent academic paper, and I'm not sure how much relevance Datalog would have.  Also, I doubt that I'm the first to have an idea like this.
21:31:06 <ddarius> I haven't yet decided whether or not to make, at least the prototype, as a DSL or EDSL.
21:31:14 <jmcarthur> Axman6: even better, where's the download? ;)
21:32:42 <solidsnack> ddarius: So, you'd store a database as a binary file or you'd have a logic language for sorting through streams of binary stuff?
21:33:12 <ddarius> solidsnack: The latter.  It wouldn't necessarily need to be a file, i.e. one of my examples is reading/writing UDP datagrams.
21:33:55 * jmcarthur votes for EDSL
21:34:02 <jmcarthur> this sounds like a useful library!
21:34:13 <ddarius> jmcarthur: I'd prefer that, but it might be a pain for the prototype.
21:34:39 * jmcarthur has always thought EDSLs were easier
21:35:05 <Elly> what does the E stand for?
21:35:05 <Axman6> ivanm: i'm not sure, i haven't heard from him (and don't want to annoy him by asking all the time)
21:35:06 <ddarius> jmcarthur: Only if the embedded language reasonably nicely subsets itself to the embedded language.
21:35:13 <ivanm> Axman6: heh
21:35:26 <jmcarthur> Elly: embedded
21:35:29 <Elly> ahh
21:35:44 <Axman6> cmrn!
21:35:47 <ddarius> solidsnack: Here's my first cut at syntax for the UDP example: udpdatagram(Block, Address, SourcePort, DestPort, Length, Checksum, Data) <- in Block at Address is (be16 SorucePort, be16 DestPort, be16 Length, be16 Checksum, bytes[Length-8] Data).
21:36:09 * Axman6 must be off to get food
21:36:25 <ddarius> That particular example doesn't verify the checksum.
21:36:28 <cmrn> Axman6!
21:38:07 <solidsnack> ddarius: This is really interesting and useful looking.
21:39:33 <solidsnack> ddarius: This involves and extension of Haskell syntax?
21:40:11 <solidsnack> s/and/an/
21:40:54 <ddarius> solidsnack: The example above was if I had complete control of the syntax, i.e. a DSL v. an EDSL.  Its a variant of Prolog syntax.
21:41:24 <rdeshpande> hi all
21:41:29 <solidsnack> What is meant by `in` and `at` ?
21:42:28 <rdeshpande> im working through the haskell tutorial ( http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html ) but don't understand where the use of `Concat` is coming from. i only see it defined as a value constuctor, and a 'concat' function, but nothing called 'Concat'. any ideas?
21:42:36 <rdeshpande> this is the header: "Fleshing out the pretty printing library"
21:42:56 <ivanm> rdeshpande: it's defined there
21:43:02 <ivanm> in data Doc = Empty ...
21:43:22 <ivanm> as such, it's a constructor, and all Haskell constructors are also functions
21:43:26 <ddarius> 'in _ at _ is _' is just another predicate.  It could be in(Block,Address, (be16 SourcePort ...)) if I wanted to stick to regular (Prolog) syntax.  The Block argument, though, would be an input only mode and would correspond to selecting the file/memory block.
21:43:50 <rdeshpande> ah ok
21:43:51 <rdeshpande> thanks ivanm
21:44:05 <ivanm> no worries
21:46:27 <ddarius> I don't believe generating binary data using such an interface would be much more difficult to implement v. reading.  Updating, though, may be tricky.
21:46:44 <ivanm> ddarius: you mean updating inline?
21:46:55 <ivanm> rather than reading, altering, and then writing the whole thing back out?
21:47:01 <ddarius> ivanm: Yes.
21:47:35 <ivanm> yeah, either you'll have overlaps in your encoding or else you might need more/less space for the updated bit
21:47:45 <ddarius> The idea is to avoid needing to build in-memory data structures to the extent possible.
21:49:12 <narens> after partially applying a function is there a way to know what it has been applied with? So for example if i have (+2).. can I find out if it is a 2 that it has been bound with?
21:49:13 <ddarius> It would be awesome if it could accomplish it without an unreasonable memory overhead.
21:50:27 <ddarius> For example, adding a byte to a PDF file requires updating the cross-reference table and all (following) references.  It would be awesome if you could just specify the change you wanted and have everything else that needed changing just happen.
21:51:16 <Elchin> hi guys? Who can tell me with with parameters i must export list in ffi
21:54:33 <ddarius> Elchin: You need to marshall the list to a C type, most likely an array.
22:04:08 <Elchin> thanks  i read this part but my english not very good and i understand small part please tell me if i ha this code l2 :: Int-> IO []  l2 n = return ([2^x | x <- [1..n] ]  and want to export what i must write in please of IO[]
22:04:35 <c_wraith> @src Show
22:04:35 <lambdabot> class  Show a  where
22:04:36 <lambdabot>     showsPrec :: Int -> a -> ShowS
22:04:36 <lambdabot>     show      :: a   -> String
22:04:36 <lambdabot>     showList  :: [a] -> ShowS
22:05:53 <Guest18496> pl \x y = f (g x) (g y)
22:08:35 <BMeph> f `on` g
22:09:58 <c_wraith> @hoodle Instance Eq => [a] -> a -> Int
22:09:58 <lambdabot> Did you mean: [a] -> a -> Int /count=20
22:09:58 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
22:09:58 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
22:10:25 <c_wraith> That was a strange "Did you mean" from hoogle
22:11:16 <BMeph> c_wraith: That was a strange "hoodle" request you made... ;)
22:11:29 <c_wraith> oh.
22:11:32 <c_wraith> heh
22:11:33 <c_wraith> :)
22:11:38 <BMeph> :)
22:11:41 <c_wraith> typing is optional, right?
22:12:13 <BMeph> I don't think that's the kind of "type inference" that's meant... :)
22:14:30 <Elchin> <c_wraith>  it qietion for me ?  i need type or export
22:14:43 <Elchin> foreign export stdcall l2 :: Int ->IO [] give error
22:22:03 <ClaudiusMaximus> @hoogle [a] -> Ptr a -> IO ()
22:22:04 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
22:22:04 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
22:22:04 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
22:22:37 <iaefai> I have just tried to install the SDL package in snow leopard, and I am getting some errors that I am not sure how to fix: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10630#a10630   Some of it seems to be related to 64bit
22:23:17 <ivanm> yeah, looks like it
22:23:32 <ivanm> IIRC, someone was having (completely different) problems with SDL on windows yesterday...
22:23:38 <ivanm> maybe it only works on linux?
22:23:46 <iaefai> That was me on windows and I got it to work :p
22:23:55 <ivanm> heh
22:24:18 <iaefai> I had to do it manually as I believe you pointed out, but work it did
22:24:53 <iaefai> This might be relevant: http://hackage.haskell.org/trac/ghc/ticket/3400
22:25:30 <ivanm> yeah, could be
22:25:35 <ivanm> I thought SL was 64bit only...
22:27:05 <iaefai> It is both
22:27:24 <iaefai> It is actually 64 bit, 32 bit and PPC emulation all in one
22:27:32 <ivanm> *shudder*
22:28:14 <iaefai> This is something that is critical for me to use haskell :p
22:28:26 <iaefai> It is either that or I have to use python
22:29:11 <bos> @hoogle comparing
22:29:11 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
22:29:26 <iaefai> I will try a 6.11 source compile and see if that can fix this
22:29:33 <iaefai> THat is where the patches are being pushed
22:32:36 <romand> guys, what library for GUIs would you recommend to someone too stupid to understands arrows?
22:32:54 <ivanm> romand: AFAIK, arrows aren't used in any GUI library
22:33:17 <iaefai> Only place I ever saw arrows being used in a gui was some paper that did them in javascript
22:33:23 <romand> ivanm: grapefruit, fudget, etc
22:33:23 <ivanm> but you've gtk2hs, wxhaskell (which IIRC has problems with new GHC), and the terminal-based "GUIs"
22:33:32 <ivanm> romand: oh, they're still around?
22:33:58 <Elchin> <ClaudiusMaximus>  thanks for a tip but please say me what i must write in plase of  l2 :: Int-> IO []
22:35:03 <Elchin> i am beginner
22:41:18 <romand> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries -- seems like the only top-level library for programming GUIs not using arrows is FranTk... )':
22:41:36 <romand> * "high-level"
22:41:42 <c_wraith> Hmm.  I never did learn how to load ghci with the tree I'm working with.  I'm trying "ghci -isrc" but it says "module `Poker.Cards' is not loaded" when I try to import it.
22:42:02 <FunctorSalad> romand: are you confused by arrows themselves or by the arrow notation?
22:42:14 <FunctorSalad> (I find the latter quite confusing too :))
22:42:49 <ClaudiusMaximus> Elchin: you can't export functions involving non-primitive Haskell types - you need to marshall them to/from a concrete representation in memory
22:44:58 <romand> FunctorSalad: I've tried to read original paper by John Hughes, "Generalising Monads to Arrows" and failed to understand a half
22:46:41 <romand> m.b. I don't need to understand all this just to use those grapefruits or fudgets
22:46:52 <SamB_XP> grapefruits?
22:47:02 <SamB_XP> is that an extension of something called "fruit"?
22:47:11 <romand> but I see code examples... no clue.
22:47:13 <jmcarthur> romand: if you don't want anything too special, you could just use gtk2hs, qthaskell, or wxhaskell
22:47:54 <ClaudiusMaximus> Elchin: so, first you need to decide where the pointer to memory to store your list into for your exported function comes from - do you allocate it outside and pass a pointer in? or allocate it yourself (and have some way to free it later)?
22:47:58 <romand> SamB_XP: http://www.haskell.org/haskellwiki/Grapefruit
22:50:18 <SamB_XP> romand: it appears to be complete junk!
22:50:23 <Elchin> I have to initialize the list and then place it in memory?
22:50:25 <SamB_XP> want to know why?
22:50:45 <SamB_XP> it doesn't seem to support teapots, that's why!
22:51:13 <romand> very funny
22:55:16 <SamB_XP> aren't teapots one of the fundamentals of the 3D graphics world?
22:57:40 <ddarius> I believe there's a gluTeapot function.
22:58:11 <BackInAcTion> Is there any way to delete a variable once it is defined in Haskell?
22:58:54 <dons> delete?
22:59:03 <romand> variable?
22:59:04 <BackInAcTion> as in, undefine the variable
22:59:15 <dons> it gets garbage collected once it goes out of scope.
22:59:23 <BackInAcTion> oh...
22:59:24 <BackInAcTion> I see
22:59:43 <BackInAcTion> I guess I don't have to worry about that then'
22:59:48 <dons> that's right :)
23:00:24 <BackInAcTion> Hmm...is there any way to communicate with Java using Haskell?
23:00:56 <BackInAcTion> I've heard of this Haskell FFI thing, but does it only work with C and maybe C++?
23:01:10 <ddarius> You could talk to Java via JNI (or whatever it is that replaced JNI), but it would not be very fun.
23:02:15 <absz> BackInAcTion: There's an XML-RPC library for Haskell, haxr, though I've never used it
23:02:32 <romand> another options: over network, pipes, signals...
23:02:43 <SamB_XP> romand: hmm, this grapefruits thing doesn't even refer to a "fruit" ... did I just dream that up or is it just expecting everyone to have perfect memories or ?
23:03:47 <romand> SamB_XP: not sure if grapefruit is somehow related to fruit (:
23:04:07 <SamB_XP> one thinks it must at least be named after it!
23:05:32 <FunctorSalad> in TH, is there a function which can tell whether a Name is a tuple name?
23:05:40 <FunctorSalad> , src ''(,,,)
23:05:44 <lunabot>  data (,,,) a b c d = (,,,) a b c d
23:06:11 <FunctorSalad> I could show it and match "GHC.Tuple.bla", but that's less than elegant
23:06:33 <FunctorSalad> and less than portable
23:06:37 <SamB_XP> @google isTuple
23:06:38 <lambdabot> No Result Found.
23:06:50 <SamB_XP> FunctorSalad: well, what for?
23:06:54 <SamB_XP> @hoogle Tuple
23:06:54 <lambdabot> module Data.Tuple
23:06:55 <lambdabot> Language.Haskell.Syntax tuple_con :: Int -> HsExp
23:06:55 <lambdabot> Language.Haskell.Syntax tuple_con_name :: Int -> HsQName
23:07:25 <SamB_XP> @src tuple_con
23:07:25 <lambdabot> Source not found.
23:07:28 <SamB_XP> @src tuple
23:07:28 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:07:43 <SamB_XP> @vixen when did I say I was a rocket scientist?
23:07:44 <lambdabot> hey, we have simular taste in music
23:07:56 <SamB_XP> @vixen besides, rocket science is pretty easy!
23:07:57 <lambdabot> hey, we have simular taste in music
23:08:04 <SamB_XP> what the ...
23:08:12 <SamB_XP> two times in a row she says that???
23:08:24 <romand> she? (:
23:08:41 <FunctorSalad> SamB_XP: uh, printing TH in a reparseable way still
23:08:46 <Axman6> cmrn: i am proud of your http://cmrn.me/dump/haskell-and-cheese.jpg
23:08:53 <cmrn> awww
23:09:03 <Axman6> how's the lyah learning going?
23:09:07 <FunctorSalad> , [t| GHC.Types.(,) Int Int |]
23:09:08 <lunabot>  luna: parse error on input `.'
23:09:10 <cmrn> I then shut the tab as fast as possible
23:09:11 <SamB_XP> FunctorSalad: give an example that goes wrong then ?
23:09:13 <cmrn> ;)
23:09:15 <ddarius> Grapefruit is a gtk based version of Fruit.  Fruit was the Functional Reactive User Interface Toolkit which originally drew its own widgets on top of a Java graphics library: http://www.haskell.org/fruit/
23:09:34 <SamB_XP> , [t| (Int, Int) |]
23:09:36 <lunabot>  AppT (AppT (TupleT 2) (ConT Int)) (ConT Int)
23:09:51 <SamB_XP> , [t| (Int, Int) |] >>= pprint
23:09:52 <Axman6> cmrn: you want to do comp sci right?
23:09:52 <lunabot>  luna: Not in scope: `pprint'
23:10:01 <Axman6> and go to ANU right?
23:10:05 <cmrn> haha
23:10:06 <FunctorSalad> SamB_XP: the problem is that sometimes we don't get (TupleT 2), but:
23:10:07 <ksf> is all that shared lib goodness enabled by default or do I need to pass some magic to configure?
23:10:16 <FunctorSalad> , (ConT ''(,))
23:10:17 <cmrn> Axman6: I see what you are doing
23:10:17 <lunabot>  ConT GHC.Tuple.(,)
23:10:21 <SamB_XP> FunctorSalad: oh ...
23:10:30 <ddarius> Perhaps the first sentence wasn't accurate.
23:10:30 <Axman6> cmrn: they're quite haskelly here :)
23:10:35 <_Ray_> Hrmph. I can use functions inside a guard, right?
23:10:37 <SamB_XP> ... right
23:10:47 <SamB_XP> FunctorSalad: have you checked for anything in derive?
23:10:53 <Axman6> _Ray_: anything that returns a Bool
23:10:55 <ksf> _Ray_, that's the reason they exist.
23:11:00 <SamB_XP> there might be workarounds in there you can steal
23:11:15 <FunctorSalad> SamB_XP: I'm fixing the FixedPpr in derive right now
23:11:18 <_Ray_> Right...I'm getting a parse error...but my code is terribly ugly :s *pastes anyway, fearing the laughter and/or disgust*
23:11:32 <FunctorSalad> (gave up on fixing TH because you need the current ghc to work on current TH)
23:11:34 <FunctorSalad> :)
23:11:37 <SamB_XP> FunctorSalad: there still might be something that deals with it ...
23:12:21 * ksf starts the compile and is going to take #haskell into responsibility if he doesn't get shared libs
23:12:42 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10631 <-- I'm getting a parse error on line 4, at '|'
23:12:46 <SamB_XP> oh, but you're still reporting your non-printing-correctly bugs right?
23:12:48 <ivanm> ksf: no, it's dcoutts' fault!
23:13:10 <ksf> zomg that's not english
23:13:15 <_Ray_> God that code is disgusting =(
23:13:19 <_Ray_> Oh, and no, it's Spanish
23:13:34 <ksf> and a hell a lot of indenting there
23:13:45 <_Ray_> sacarTodos => removeAll, bloque => block, primeros => first, ultimos => last, recortarComienzo => trimBeginning
23:13:50 <mauke> _Ray_: missing )
23:13:57 <mauke> why am I opped
23:14:06 <ksf> ...you can put the where on the same line as larga and then nuke most of that indenting
23:14:11 <_Ray_> damnit
23:14:15 <_Ray_> far too much code =(
23:14:16 --- mode: mauke set -o mauke
23:14:20 <SamB_XP> the primeeros and ultimos aren't too differant
23:14:22 <SamB_XP> hmm
23:14:23 <mauke> far too many parens
23:14:44 <_Ray_> SamB_XP, one gets the first n elements, the other gets the last n elements
23:14:53 <SamB_XP> is there an Optimus Ultima?
23:15:20 <ksf> that's a case for an if, btw.
23:15:25 <_Ray_> Um. No idea :(
23:15:35 <ksf> you're not matching anything, and only have two guard branches.
23:15:38 * _Ray_ fixes the MANY type incompatibilities, caused mainly by his own disgust as his code
23:15:50 * SamB_XP goes off on a tangent of a tangent and imagines an RPG with four gigantic transforming robots following eachother around a silly square-covered map
23:16:00 <SamB_XP> ... dying far too often ...
23:16:10 <opqdonut> tangent of a tangent is just the original tangent
23:16:32 <ksf> and by the time we're done critizising your code and you done implementing those changes, the syntax error will have magically disappeared.
23:16:40 <_Ray_> :p
23:16:54 <_Ray_> The problem is basically removing sublists from a list
23:16:59 <SamB_XP> opqdonut: only in geometry
23:17:04 <_Ray_> (I finally got a good description of the problem)
23:17:15 <SamB_XP> in ADD, not so much!
23:17:32 <_Ray_> Like, given [a, b] and [a, b, c, d, a, b, g, a, d, b], return [c, d, g, a, d, b].
23:17:52 <_Ray_> And in corner cases like [a, a] [a, a, a, b], return [a, b], since the returned list has no sublist == [a, a]
23:18:09 <_Ray_> All this without using any builtin haskell functions, higher order functions, or lists by comprehension
23:18:21 <ksf> and "ab" "aba"?
23:18:47 <_Ray_> Yes, basically. "ab" "aba" => "a"
23:18:48 <ksf> ...that is, whether matches may overlap.
23:19:03 <ddarius> aabb
23:19:20 <SamB_XP> just watch out for that RIAA
23:19:26 <Twey> Okay, feeling a bit stupid here: if I have an IO exception resulting from, say, reaching the end of a file when reading with hGetLine, how can I catch it from a higher function (in my case, hAgnosticGetLine calls hGetLine, and I'd like to be able to catch the error on hAgnosticGetLine)?
23:19:27 <_Ray_> Ah, I'm assuming no - what I('m trying to) do is go in steps, if the searched-for string is of length n, steps of length n
23:19:42 <_Ray_> and Lord help me if one isn't a perfect multiple of the other ;)
23:20:08 <ddarius> :t catch
23:20:09 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:21:05 <ksf> er yes. scan the string for all permutations returning [Bool] for whether a match starts there, filter out overlaps, combine, done.
23:21:05 <FunctorSalad> SamB_XP: ahh, isTupleT in derive
23:21:28 <ksf> erm no that won't work.
23:21:35 * ksf shuts up
23:21:50 <ivanm> ksf: thank you! :p
23:22:20 <_Ray_> is there a "training wheels" mode for Haskell, where it'll tell you all the reductions it's making?
23:22:44 <ksf> you can step with ghc
23:22:45 <ksf> er ghci
23:23:14 <ksf> if your source isn't too funky you can use hat, but I've heard it's a bugger to use.
23:23:25 <ksf> (though very good)
23:23:47 <_Ray_> hat?
23:23:56 * _Ray_ is now using :break in ghci
23:24:06 <ksf> haskell tracer
23:24:25 * ksf usually just uses Debug.Trace.
23:24:29 <dmead> ?seen dons
23:24:29 <lambdabot> Unknown command, try @list
23:24:45 <c_wraith> preflex: seen dons
23:24:46 <preflex>  dons was last seen on #haskell 24 minutes and 57 seconds ago, saying: that's right :)
23:24:47 <Twey> ddarius: Oh, I'm an idiot.  Thanks.  ☺
23:25:04 <ksf> back in the C days I used ddd sometimes, but only to follow pointer mazes.
23:25:05 <Twey> I was putting the catch in the wrong place.
23:25:06 <dmead> dons, some people were talking about your book at philly lambda
23:25:50 <dmead> ?src concatMap
23:25:51 <lambdabot> concatMap f = foldr ((++) . f) []
23:26:43 <dmead> >  concatMap
23:26:44 <lambdabot>   {()->[]}->
23:26:44 <lambdabot>    {[]->[];[()]->[];[(),()]->[];[(),(),()]->[]}
23:26:44 <lambdabot>  {()->[()]}->
23:26:44 <lambdabot>   ...
23:26:56 <dmead> >  concatMap (,) [1,2,3] [4,5,6]
23:26:57 <lambdabot>   Couldn't match expected type `[b]'
23:26:57 <lambdabot>         against inferred type `b1 -> (a,...
23:27:00 <dmead> o rly
23:27:14 <dmead> >  concatMap (x y -> (x,y) ) [1,2,3] [4,5,6]
23:27:15 <lambdabot>   Pattern syntax in expression context: x y -> (x, y)
23:27:18 <dmead> >  concatMap (x y -> (x,y)  [1,2,3] [4,5,6]
23:27:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:27:20 <_Ray_> Wow. And I thought Perl was ugly :s
23:27:25 <dmead> >  concatMap (x y -> (\x,y)  [1,2,3] [4,5,6]
23:27:26 <lambdabot>   <no location info>: parse error on input `,'
23:27:29 <mauke> dmead: STOP
23:27:30 <dmead> wow wake up
23:27:37 <dmead> >  concatMap (\x y -> (x,y)  [1,2,3] [4,5,6]
23:27:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:27:42 <mauke> dmead: HELLO?
23:27:46 <dmead> hello!
23:27:51 <mauke> ok, you can stop now
23:27:54 <dmead> >  concatMap (\x y -> (x,y))  [1,2,3] [4,5,6]
23:27:55 <lambdabot>   The lambda expression `\ x y -> ...' has two arguments,
23:27:55 <lambdabot>  but its type `a ->...
23:27:57 <dmead> okay
23:28:10 <mauke> concatMap is not how you zip
23:28:24 <dmead> >liftM2 (,) [1,2,3] [4,5,6]
23:28:27 <dmead> > liftM2 (,) [1,2,3] [4,5,6]
23:28:28 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:28:29 <mauke> or that
23:29:05 <mauke> > concatMap show [23 ..]
23:29:06 <lambdabot>   "23242526272829303132333435363738394041424344454647484950515253545556575859...
23:29:33 <dolio> > [23..]>>=show
23:29:34 <lambdabot>   "23242526272829303132333435363738394041424344454647484950515253545556575859...
23:30:14 <dmead> thats a strange pattern
23:31:56 <paolino> good morning, anyone can help me make this right, please ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4346#a4346
23:32:37 <ivanm> paolino: you need an extension
23:32:42 <ivanm> ScopedTypeVariables IIRC
23:33:02 <paolino> it's there , I forgot to report it, sorry
23:33:24 <dolio> Put a "forall a." before the "Show a".
23:33:38 <dolio> You need to explicitly introduce type variables that are to be scoped like that.
23:33:59 <paolino> right, it always bites me, thanks
23:34:25 <dolio> Apparently right now it thinks it's supposed to get the type from the "y::a".
23:34:49 <dolio> Which, apparenltly, it could do, if you specified the type of the case expression (I think that's what the error message says).
23:35:33 <ksf> there should be a way to define a default view function for a type.
23:35:41 <dolio> Or, maybe not the case expression. Something that gives the "Just y" a rigid type. But you'd have to know a already to do that. :)
23:36:33 <ksf> ...so you don't need to write viewL -> h <: t for your Sequences, only viewR -> b :> e
23:36:59 <ClaudiusMaximus> paolino: how about     case cast l `asTypeOf` (Just x) of
23:37:44 <ksf> ...if we then do the sensible thing and make viewL a type class and implement it for lists, too, we're going to be happy ever after.
23:38:11 <paolino> ghc is so perfect, I forgot Typeable a also, thinking E was enough :)
23:38:27 <paolino> ClaudiusMaximus: never used that,
23:38:32 <paolino> :t asTypeOf
23:38:33 <lambdabot> forall a. a -> a -> a
23:39:26 <Twey> @hoogle SomeException -> String
23:39:26 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
23:39:26 <lambdabot> Prelude show :: Show a => a -> String
23:39:26 <lambdabot> Text.Show show :: Show a => a -> String
23:39:39 <Twey> @hoogle Exception e => e -> String
23:39:39 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
23:39:39 <lambdabot> Prelude show :: Show a => a -> String
23:39:39 <lambdabot> Text.Show show :: Show a => a -> String
23:39:46 * Twey scratches his head.
23:39:52 <mistermatt> huh
23:42:32 <paolino> ClaudiusMaximus: I don't understand the idea, how can I separate the cases with that ?
23:42:47 <dolio> Woo! 6.12.1RC1.
23:44:23 <paolino> how do you call the argument a when it is only a witness for its type ?
23:44:48 <luite> anyone seen this error when using vacuum-cairo?  Pango-CRITICAL **: pango_win32_font_map_get_font_cache: assertion `font_map != NULL' failed
23:45:25 <cmrn> o/ Axman6
23:45:30 <Axman6> \o
23:46:24 <Axman6> cmrn: what have you learnt about haskell so far?
23:46:41 <cmrn> whats a haskell?
23:46:42 <cmrn> :)
23:47:00 <cmrn> dude, I need to get this assignment done.
23:47:02 <Axman6> yeah, still disappointed ;)
23:47:07 <Axman6> what's the assignment?
23:47:08 <cmrn> heh
23:47:22 <cmrn> some uselessly easy statistics
23:47:38 <cmrn> Question 1. Consider the following data set D = {4.2, 3.7, 3.2, 5.7, 7.2, 4.1, 11.1, 5.2, 6.3, 9.1, 8.5, 9.7, 8.1, 8.5, 9.3, 1.2, −3.7}.
23:47:39 <cmrn> (a) Construct a stem and leaf plot for D
23:47:41 <cmrn> hur dur
23:47:45 <cmrn> -.-
23:47:54 <Axman6> wtf's a stem and leaf plot?
23:47:59 <ivanm> Axman6: statistics stuff
23:47:59 <cmrn> wat
23:48:01 <Axman6> like a box and whisker plot?
23:48:07 <ivanm> Axman6: something like that I think
23:48:17 <ivanm> it's been a while (thankfully) since I've had to worry about that kind of stuff
23:48:21 <cmrn> http://en.wikipedia.org/wiki/Stemplot
23:48:30 <ClaudiusMaximus> paolino: well, you have an x::a, so you can use type inference on x::a and foo::b with asTypeOf::c->c->c  to unify a<=>b
23:48:34 <cmrn> It's annoyig, is what
23:48:38 <cmrn> ing
23:49:45 <ClaudiusMaximus> paolino: while not actually using the value of x (asTypeOf = const, but with a restricted type)
23:50:36 <ClaudiusMaximus> paolino: just an alternative to using ScopedTypeVariables  (oh, i forgot to mention you then don't need the ::a on the y...)
23:51:10 <Axman6> cmrn: you know, the stats(like) course i did last semester, i ended up writing a lot of my code in haskell, and then doing the final work in matlab (because we were required to)
23:51:20 <cmrn> yeah
23:51:31 <cmrn> I'm just gonna do it in matlab
23:51:36 <Axman6> so much easier than using matlab
23:51:48 <ivanm> heh
23:51:59 <ivanm> but, for stats, wouldn't R be easier/better than Matlab?
23:52:09 <paolino> ClaudiusMaximus: but there are cases in which it will not unify and I need to recurse in those cases,.... if you can paste your version I would be thankful, I have difficulties in understanding your explanation
23:52:21 <cmrn> most of what we are using matlab for is "make a pretty boxplot"
23:52:26 <cmrn> *sigh*
23:52:28 <Axman6> cmrn: aye
23:52:47 <Axman6> matlab makes ... well it makes boxplots... i wouldn't call them nice
23:53:04 <Axman6> anyway, home time
23:54:58 <ClaudiusMaximus> paolino: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4346#a4348  << i just checked that it loaded in ghci, not sure if it's what you need
23:56:45 <paolino> ClaudiusMaximus: understood :)
