00:05:17 <Twey> data_jepp: ('l', 'e', 't', 'x', 'b', 'e', 's') is a tuple of (Char, Char, Char, Char, Char, Char, Char)
00:05:48 <Twey> I'm almost certain that's not what you want, since if parseExpr takes a seven-tuple of Char then you can never have an expression of any other length
00:06:25 <Twey> What is the type variable ‘s’ supposed to be?
00:06:36 <Twey> :x: looks like an infix data constructor.
00:09:02 <Twey> I guess it could be considered a tuple of (Char, Char, Char, a -> b -> c, Char, Char, s), but that doesn't make much more sense.
00:16:26 <FunctorSalad_> D:
00:54:17 <hackagebot> Codec-Image-DevIL 0.2.0 - An FFI interface to the DevIL library (LukePalmer)
01:19:33 <haskellnoob> I am getting a type error (expected m to be Integer, got Int instead) for the following code. When I replace m with (toInteger m), I get the opposite type error -- expected m to be Int, got Integer instead. How do I fix this? Thanks.
01:19:34 <haskellnoob> power_mod_m :: Int -> Integer -> Int
01:19:37 <haskellnoob> power_mod_m m i = (i^i) `mod` m
01:20:47 <haskellnoob> This is with ghci version 6.8.2
01:21:25 <ivanm> @type (^)
01:21:27 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:21:28 <ivanm> @type mod
01:21:30 <lambdabot> forall a. (Integral a) => a -> a -> a
01:21:43 <ivanm> haskellnoob: i and m have to be the same type
01:22:07 <ivanm> try this: (i^i) `mod` fromIntegral m
01:22:42 <haskellnoob> ivanm: Thanks, let me try that. Do these type coercions result in rounding errors?
01:22:58 <ivanm> they're integers... what rounding errors? :p
01:23:10 <c_wraith> huh.  In my continued investigation of permutation functions, I think I've got one that's faster than Data.List.permutations.  Unless timing is wacky on this computer.  (fully possible)
01:23:26 <haskellnoob> because an Int is of bounded width, and an Integer is not
01:23:51 <Twey> You can get an overflow error.
01:23:53 <c_wraith> Of course, it doesn't have good ordering properties.  But they're not really worse than those of Data.List.permutations
01:24:06 <ivanm> Twey: yeah, rounding is more for floating point, right?
01:24:11 <Twey> Yes
01:24:15 <ivanm> c_wraith: use criterion to check!
01:24:19 <Twey> There's no rounding done on Integer
01:24:23 <Twey> Or Int
01:24:39 <ivanm> haskellnoob: note that we're changing the Int to be an Integer, which is unbounded
01:24:47 <Twey> No
01:24:47 <ivanm> well, practically speaking, it's limited by your memory
01:25:01 <Twey> :t (^)
01:25:02 <haskellnoob> ivanm: Thanks for your help, I fixed this as follows: power_mod_m m i = fromIntegral ((i^i) `mod` (toInteger m))
01:25:02 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:25:06 <Twey> Oh, okay
01:25:13 <Twey> Should be fine, then
01:25:18 <ivanm> haskellnoob: you can drop the fromIntegral
01:25:22 <Twey> ivanm: Yeah, but it will never overflow.
01:25:28 <ivanm> i is already an Integer ;-)
01:25:32 <ivanm> Twey: just crash ;-)
01:25:36 <Twey> Right.  :þ
01:25:39 <c_wraith> ivanm: I know nothing about criterion
01:25:44 <ivanm> for Int -> Integer, fromIntegral == toInteger
01:25:48 <ivanm> @hackage criterion
01:25:49 <lambdabot> http://hackage.haskell.org/package/criterion
01:25:49 <haskellnoob> ivanm: it appears not... ghci complains if I do that
01:25:54 <ivanm> haskellnoob: :o
01:26:09 <ivanm> haskellnoob: oh, right, you wanted an Int as your final value
01:26:12 <ivanm> you're right then
01:26:19 <ivanm> now, let's golf it a little more! :p
01:26:26 <Twey> I think you can lose mose of those brackets
01:26:30 <Twey> Yeah :þ
01:26:37 <ivanm> @pl power_mod_m m i = fromIntegral ((i^i) `mod` (toInteger m))
01:26:38 <lambdabot> power_mod_m = (fromIntegral .) . flip (mod . join (^)) . toInteger
01:26:43 <ivanm> or, with the terms:
01:26:44 <Twey> powerModM m = … oy
01:27:02 <ivanm> power_mod_m = fromIntegral $ (i^i) `mod` toInteger m
01:27:10 <ivanm> not sure if ^ binds tighter than `mod` ...
01:27:16 <Twey> You need to add the arguments in there
01:27:18 <Twey> I'm pretty sure it does
01:27:54 <ivanm> oh, right, duh
01:28:38 * c_wraith starts by installing platform on this computer
01:28:44 <liff> c_wraith: also http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
01:28:53 <Twey> I would personally go to: powerModM i = fromIntegral . mod (i ^ i) . toInteger
01:28:55 <Twey> And no further
01:29:04 <Twey> (note that the argument order is switched)
01:29:09 <ivanm> @where+ criterion http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
01:29:10 <lambdabot> It is stored.
01:29:28 <c_wraith> noted.
01:29:33 <ivanm> Twey: yeah, camelCase > spacing_with_underscores
01:29:37 <Twey> It gets a bit obscured after that
01:29:44 <Twey> Aye.
01:31:33 <mmorrow> data_jepp: here's a (somewhat epic/tedious) manual parser for e.g. "<<<><><<>>>><<<><>>>" to trees, not sure what exactly you're doing, but fwiw
01:33:36 <thoughtpolice> ivanm: criterion is really cool
01:33:48 <ivanm> agreed
01:34:31 <mmorrow> yeah, bos++
01:35:00 <c_wraith> Also, if this is at least as fast as Data.List.permutations...  It has the advantage of being WAY simpler.
01:35:28 <ivanm> mmorrow: I can't believe how much work he put into just to check if his new library was more efficient than the old one...
01:35:38 <ivanm> first he wrote a statistics library, and then he wrote criterion proper
01:35:43 <ivanm> @src permutations
01:35:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:35:48 <ivanm> @slap lambdabot
01:35:49 * lambdabot puts on her slapping gloves, and slaps lambdabot
01:35:58 <ivanm> @hoogle permutations
01:35:59 <lambdabot> Data.List permutations :: [a] -> [[a]]
01:36:05 <Twey> Haha
01:52:56 <c_wraith> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#permutations
01:53:06 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10415#a10415
02:07:55 <monadic_kid> looking for more opinions about what naming conventions I should use for C enums ported to haskell  where I have overlapping data constructor names (when I remove the origional C prefix) should i prefix them with abbrevations of the type name, e.g. data BackBufferType and data constructors prefixed with Bbt or BBT
02:08:33 <monadic_kid> BbtFoo or BBTFoo
02:09:49 <int-e> put them in separate modules and let the user pick a prefix?
02:10:43 <int-e> an abbreviated prefix sounds fine to me.
02:12:08 <monadic_kid> yes i have thought about that but there are a lot of enums i'm dealing with, also some of those modules might only have one or two types and the functions are part of a COM interface so i'm not sure if I also want to group functions from that interface into seperate (sub)-modules
02:18:08 <monadic_kid> I'll have to add prefixes to all of them just to be consistant :(
02:22:28 <c_wraith> Is it reasonable to choose a different abstraction that has fewer enums?
02:23:33 <monadic_kid> i'm not sure what you mean
02:24:24 <monadic_kid> what other alternatives other than modules could i use
02:25:06 <c_wraith> Is it reasonable to find a different abstraction for the library, that doesn't have as many data constructors?
02:25:36 <c_wraith> (Quite possible that the answer is no, but it's worth thinking about)
02:25:37 <monadic_kid> well this is a binding to a library I can not change, it's not my own
02:25:46 <c_wraith> ah
02:26:24 <monadic_kid> http://github.com/snkkid/HDirectX
02:27:59 <monadic_kid> GL bindings uses modules but they are easier to define since it looks like they are following the GL spec which seperates all the functions into logically grouped sections
02:28:25 <monadic_kid> but if you do that with a COM interface it seems a bit wrong
02:28:55 <monadic_kid> i mean to group functions of a COM interface into a sub-modules with there own enums
02:29:50 <monadic_kid> sub-modules like Device.Blending, Device.Draw, Device.Buffer or something
02:29:57 <monadic_kid> this is just for the Device interface
02:30:49 <monadic_kid> some enums are used by a number of functions/interfaces
02:32:32 <monadic_kid> you guys think i should go for the (sub)-modules approach?
02:33:10 <phantomm> I need a string replace function in haskell (or list replace is perfectly fine).. I'd roll my own.. but it just counters common sense.. I've seen a number of implementations around.. is there a package that provides additional string processing functions?
02:36:19 <monadic_kid> phantomm: regular expressions?
02:36:56 <monadic_kid> phantomm: did you check hackage: http://hackage.haskell.org/packages/archive/pkg-list.html
02:37:31 <phantomm> monadic_kid: no that'd be overkill... and yeah.. I've hunted around hackage.. best I found was a CGI helper function
02:39:06 <Schalken> I have a function which simplifies boolean expressions. The problem is, after the function is called, the boolean expression tree may be able to be simplified further. Is there a way I can call a function on some value, and keep calling it until it doesn't change?
02:39:20 <maltem> For additional list processing only Data.List.Split comes to my mind, and no replace there, for obvious reasons
02:39:59 <phantomm> maltem: Pardon me.. I'm still learning.. what would that obvious reason be?
02:40:16 <maltem> phantomm, it's called Split, not Replace ;)
02:40:55 <maltem> but maybe it will help you anyways, in rolling your own
02:42:52 <maltem> Schalken, keepCalling f x = let x' = f x in if x == x' then x else keepCalling f x' -- ?
02:43:48 <Schalken> maltem: That would do it.
02:43:57 <Schalken> maltem: Somehow it didn't seem that simple in my head.
02:44:05 <phantomm> Well.. from a learning the language point of view.. yes.. but that's what I'm using the 99problems for..    I'm now writing a few "scripts" to solve more "real-world" programming tasks so with this second mindset I'd rather learn how to get around the existing libraries, packages, cabal and hackage
02:44:13 <maltem> Schalken, if the comparison x == x' has a cost, another possibility is rewriting f to return a Maybe, depending on if something has been changed
02:45:01 <Schalken> malteem: Hmmm. It does indeed have a cost, because it'd be comparing trees for equality.
02:45:21 * Schalken investigates "Maybes"
02:46:25 <maltem> The third possibility is to write f such that it isn't needed to be called multiple times :) I mean, simplifying a tree could be straightforward recursion, if the simplification is "easy"
02:53:08 <blackh> Hi yall. Anyone going to the Linux Conference in New Zealand?  I am thinking of giving a talk about Haskell.
02:54:22 <bob2> at the open programming languages miniconf?
02:55:18 <blackh> Exactly so.  I only just found out about it. :)
02:55:38 <blackh> I don't know if anyone else is thinking of talking about Haskell there.
03:00:45 <en0th> :t (=<<)
03:00:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:02:36 <FunctorSalad_> re replacing, does one of the regex libs work with arbitrary lists?
03:02:57 <en0th> (an example of a function with type: a -> [a] ? )
03:03:22 <ivanm> FunctorSalad_: I don't think so
03:03:34 <FunctorSalad_> ivanm: sounds possible doesn't it?
03:03:39 <ivanm> they're overloaded on the string-like type, but that's it AFAIK
03:03:53 <ivanm> FunctorSalad_: I suppose the problem is that regexes are really only based on characters
03:03:54 <FunctorSalad_> as long as elements are Eq anyway
03:04:10 <ivanm> FunctorSalad_: might need enum as well, for the a-z style stuff
03:04:20 <ivanm> but I don't see why you couldn't have a regex-like lib
03:05:03 <ivanm> but you might not be able to use Strings as the regexes...
03:05:25 <ivanm> FunctorSalad_: so I guess the biggest problem is how to define regex-like syntax for non-chars
03:05:35 <ivanm> FunctorSalad_: but any reason you can't use a parsing library?
03:05:45 <nomeata> HI. Is this sensible code to read a list of Data.Binary values from a file: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10416#a10416 (The goal is that its possible to append values to the file without readong or parsing the previous contents, thus I can not just use the Binary instance for [a])?
03:08:12 <FunctorSalad_> ivanm: good point...
03:09:44 <ivanm> which one? ;-)
03:10:24 <FunctorSalad_> ivanm: about using a parsing lib (btw I wasn't asking, just saw replacement being discussed some screens up)
03:10:43 <FunctorSalad_> one might still want a quick search/replace for arbitrary lists though
03:10:44 <maltem> nomeata, what's special about that code?
03:10:45 <ivanm> ahhh
03:11:04 <nomeata> maltem: it’s the first time I use Data.Binary, that’s all :-)
03:11:56 <FunctorSalad_> oh I just saw phantomm only needed string replacement after all ;)
03:12:17 <FunctorSalad_> phantomm: here's a presumably fast one http://hackage.haskell.org/package/stringsearch
03:13:41 <ivanm> FunctorSalad_: s/presumably/assumed/ ?
03:14:04 <maltem> nomeata, looks pretty standard to me. one might argue that Get should be an instance of Alternative, such that go = some get
03:14:15 <FunctorSalad_> ivanm: as in "it says it's fast and it uses respectable algorithms, but I haven't tested it myself"
03:15:01 <ivanm> FunctorSalad_: heh
03:15:03 <ivanm> who's it by?
03:15:04 <Twey> Alternative?
03:16:19 <FunctorSalad_> , src ''Alternative
03:16:23 <lunabot>  class (Applicative f) => Alternative f where
03:16:23 <lunabot>          empty :: forall a . f a
03:16:23 <lunabot>          (<|>) :: forall a . f a -> f a -> f a
03:16:31 <Twey> Huh.  Never knew that existed.
03:16:45 <Twey> I though (<|>) was just a Parsec thing.
03:16:53 <Twey> thought**
03:17:21 <Peaker> I really dislike the proliferation of duplicate Monoid classes...
03:17:33 <en0th> i was looking at <|> right now, and i really don't understand what it does.
03:17:57 <Twey> It's a ‘choose one of…’ operator
03:18:16 <Twey> Try the first; if it fails, for some definition of ‘fails’, use the other
03:18:19 <Peaker> with higher-ranked super-classes, we could have:  class (forall a. Monoid (m a)) => MonadPlus m ; class (forall a. Monoid (f a)) => Alternative f
03:18:32 <Peaker> en0th, do you know Monoid or MonadPlus?
03:18:50 <en0th> i'm still at functors and monads..
03:18:53 <Twey> , src ''Monoid
03:18:55 <lunabot>  luna: Not in scope: type constructor or class `Monoid'
03:19:01 <maltem> actually, it's confusing that Alternative is required to be a monoid. some, many etc. make sense without empty
03:19:02 <Twey> ☹
03:19:41 <Peaker> It would be better if it was separated into Zero and Plus. But its just crazy how Monoid is duplicated everywhere
03:20:35 <Peaker> Maybe with higher-ranked super-classes and with class aliases, there could be just one, and one ApplicativeZero, and ApplicativePlus, and no need for MonadPlus/etc
03:21:29 <maltem> Actually, couldn't there be one class FirstRankMonoid (stupid name) to subsume both Alternative and MonadPlus?
03:22:14 <maltem> just dropping the class constraints
03:23:07 <Twey> Maybe we'll get less duplication once we have class aliases…
03:24:07 <Peaker> maltem, Well, if Monad subclassed Alternative, you would need just one *->* Monoid. But I'd rather you needed just one Monoid for all kinds
03:24:22 <maltem> On my other note, I see Alternative more as an interface to ((<|>),optional,some,many) rather than a monoid (who uses empty in a parser?)
03:24:44 <Twey> Doesn't optional imply empty?
03:24:56 <Twey> optional a = empty <|> a
03:25:03 <Twey> Or rather, a <|> empty
03:25:07 <maltem> , src 'optional
03:25:08 <lunabot>  luna: Ambiguous occurrence `optional'
03:25:19 <FunctorSalad_> I think empty is failure
03:25:19 <maltem> what's luna's syntax here?
03:25:21 <FunctorSalad_> not empty string
03:25:30 <Twey> Really?  Huh.
03:25:39 <FunctorSalad_> if it is to be the neutral element for <|>....
03:25:40 <en0th> i guess empty always succeeds
03:25:48 <Twey> Yeah, I'd assume that, too
03:25:50 <maltem> en0th, for parsec, it always fails
03:25:57 <maltem> otherwise it's no left identity
03:26:20 <maltem> fwiw, optional v = Just <$> v <|> pure Nothing
03:26:21 <Twey> Huh?
03:26:32 <int-e> I.e. it represents the empty language. It's useful for folds.
03:26:35 <Twey> If it *fails*, it isn't left identity, surely
03:26:48 <maltem> Twey, left identity of <|>, surely
03:26:53 <Twey> Oh, right
03:26:55 <FunctorSalad_> pure Nothing :D
03:27:09 <Peaker> @bot
03:27:10 <lambdabot> :)
03:27:10 <lunabot>  :o
03:27:20 <Twey> Hehe
03:28:27 <maltem> int-e, if the fold is too general for a meaningful error message... ok
03:28:48 <maltem> I see then
03:29:35 <Twey> It's still not left identity.
03:29:49 <Twey> Oh, wait
03:29:53 <Twey> Yes it is.  Never mind that.
03:30:04 <maltem> wait, maybe it really isn't
03:30:15 <maltem> parsec does backtracking only when you "try"
03:30:42 <maltem> ahh nvm :P
03:31:41 <maltem> but is it a right identiy? what about, fail "with an error message" <|> empty
03:31:59 <Twey> Same, isn't it?
03:32:09 <Twey> It will always fail "with an error message"
03:32:13 <maltem> parsec says, the left parser fails without consuming any input, so try the right one
03:32:24 <Twey> Ooh.
03:32:34 * maltem will try it out
03:33:47 <maltem> heh
03:33:57 <maltem> fails "with an error message"
03:34:29 <Twey> So then the question becomes ‘why’
03:34:38 <FunctorSalad_> mmm input nom nom nom nom nom
03:35:16 <maltem> because parsec obeys the monoid laws rather than its documentation ^^
03:35:46 <FunctorSalad_> I reckon it remembers the old error message when it fails without a message
03:35:54 <maltem> ah now I see
03:36:15 <maltem> fail "first" <|> fail "second"       ---> parser fails with:  "first or second"
03:37:13 <Twey> o.@
03:37:25 <Twey> Oho
03:54:03 <MacCoaster> how do i differentiate a String from the rest that are members of Show, because show would result in the literal string, rather than the representation?
03:54:45 <MacCoaster> some kind of pattern matching?
03:54:53 <Peaker> MacCoaster, What do you mean?
03:55:03 <Peaker> @src Show
03:55:04 <lambdabot> class  Show a  where
03:55:04 <lambdabot>     showsPrec :: Int -> a -> ShowS
03:55:04 <lambdabot>     show      :: a   -> String
03:55:04 <lambdabot>     showList  :: [a] -> ShowS
03:55:11 <int-e> MacCoaster: showList is the trick here.
03:55:39 <maltem> MacCoaster, you mean like, myshow "bla" ---> "bla", myshow 13 ---> "13" ?
03:55:45 <int-e> MacCoaster: and the Char instance of Show which implements showList differently than the other types.
03:56:21 <int-e> show "bla" would be ['b','l','a'] otherwise.
03:57:34 <maltem> MacCoaster, if so, you can do newtype MyString = S String; instance Show MyString where show (S s) = s
03:58:02 * MacCoaster parses all the responses... most responsive irc chan i know of :P
03:59:56 <MacCoaster> hmm interesting, maltem in ghci show 13 prints "13" but when i do something like lielements xs = concat [ "\t<li>" ++ (show i) ++ "</li>\n" | i <- xs]   it doesnt quote the numbers (i get like<li>1</li> for example from a list of numbers
04:00:06 <MacCoaster> but for a list of strings i get extra quotes
04:00:15 <Peaker> its an ugly hack.. Overlapping instances is probably a better way to do it
04:00:18 <RayNbow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10417 <-- I was wondering whether partition was less/more efficient than traversing the list twice
04:00:27 <maltem> MacCoaster, that's how it is supposed to work
04:00:36 <MacCoaster> maltem: i understand that
04:01:01 <MacCoaster> im just wondering whats the best way to do this so that when accept a list it doesnt print any extra quotes
04:02:08 <maltem> the most straightforward way would be lielements :: [String] -> String
04:02:19 <maltem> and have the caller use show where appropriate
04:02:53 <MacCoaster> but that wont let me pass a list of numbers? or do i have two definitions?
04:03:20 <maltem> no that won't let you pass a list of numbers, it only will let you pass (map show mylistofnumbers)
04:03:33 <maltem> which isn't that bad, considering that
04:03:56 <MacCoaster> ahh i see now
04:04:03 <maltem> ... you may want map (printf "%00d") mylistofnumbers  -- or whatever the printf syntax was again
04:04:09 <MacCoaster> so really we're making just lists of strings then passing it
04:07:01 <Phyx-> :t printf
04:07:02 <lambdabot> forall r. (PrintfType r) => String -> r
04:07:07 <Phyx-> hmm
04:07:21 <maltem> would have been printf "%03d"
04:07:28 <maltem> or something
04:08:00 <FunctorSalad_> > printf "%03d" 1.11114331111
04:08:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:08:02 <lambdabot>    `Text.Printf.PrintfType ...
04:08:10 <FunctorSalad_> > printf "%03d" 1.11114331111 :: String
04:08:11 <lambdabot>   "* Exception: Printf.printf: bad argument
04:08:16 * Twey wants a format_f
04:08:19 <FunctorSalad_> > printf "%3d" 1.11114331111 :: String
04:08:21 <lambdabot>   "* Exception: Printf.printf: bad argument
04:08:27 <Twey> With clever TH-enforced compile-time type checking
04:08:31 <FunctorSalad_> > printf "%03d" (1/3::Double) :: String
04:08:32 <lambdabot>   "* Exception: Printf.printf: bad argument
04:08:34 <maltem> > printf "%03d" 12 :: String
04:08:35 <lambdabot>   "012"
04:08:39 <FunctorSalad_> Twey: cabal install Printf-TH
04:08:50 <FunctorSalad_> oops, d was integer
04:08:55 <FunctorSalad_> > printf "%03f" (1/3::Double) :: String
04:08:56 <lambdabot>   "0.3333333333333333"
04:09:00 <Twey> FunctorSalad_: Still doesn't do lists and stuff.
04:09:02 <Phyx-> :t gshow
04:09:03 <lambdabot> forall a. (Data a) => a -> String
04:09:14 <Phyx-> :t extT
04:09:15 <lambdabot> forall a b. (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
04:09:29 <Twey> As is generally the case, the Common Lisp feature is way cooler than the C equivalent.  ;)
04:09:50 <FunctorSalad_> lists in a format string? D:
04:10:38 <Twey> Yep.  Awesome, right?
04:10:51 <FunctorSalad_> > concatMap (printf "%0.4f" . recip) [(1::Double)..10]
04:10:53 <lambdabot>   Ambiguous type variable `b' in the constraints:
04:10:53 <lambdabot>    `GHC.Show.Show b'
04:10:53 <lambdabot>      a...
04:11:02 <FunctorSalad_> > concatMap (printf "%0.4f" . recip) [(1::Double)..10] :: String
04:11:04 <lambdabot>   "1.00000.50000.33330.25000.20000.16670.14290.12500.11110.1000"
04:11:08 <FunctorSalad_> > concatMap (printf "%0.4f " . recip) [(1::Double)..10] :: String
04:11:10 <lambdabot>   "1.0000 0.5000 0.3333 0.2500 0.2000 0.1667 0.1429 0.1250 0.1111 0.1000 "
04:11:10 <maltem> Sounds like Text.PrettyPrint
04:11:23 <maltem> even if that's for a different purpose
04:11:49 <Twey> It has ~{ and ~} for ‘for each member of the list’
04:13:19 <maltem> hcat . map f
04:13:43 <Twey> I guess so
04:14:00 * FunctorSalad_ advertises Text.PrettyPrint.ANSI.Leijen again so we'll have moar colors
04:16:00 <maltem> heh nice one
04:16:02 <Phyx-> > (show `extQ` ((\a->show (show a))::Integer -> String)) 8
04:16:03 <lambdabot>   "\"8\""
04:17:05 <Phyx-> that would also work no?
04:17:48 <Phyx-> or (show `extQ` ((\a->show (show a))::Num a => a -> String))
04:22:00 <maltem> FunctorSalad_, you evil! I'm now whishing for colorful ghc output
04:26:10 <ivanm> maltem: well, it's apparently possible to have colourful ghci output using hscolour...
04:26:18 <ivanm> but when I tried it a while back it was rather laggy, etc.
04:27:40 <FunctorSalad_> :)
04:28:20 <FunctorSalad_> one could add it in ghci directly maybe
04:28:43 <ivanm> FunctorSalad_: preferably as an option, as I'm not sure how well it would work if ghci is being used from within another app
04:28:48 <ivanm> let alone over ssh, etc.
04:28:58 <ivanm> (that is, in a term that doesn't accept colours)
04:28:58 <FunctorSalad_> yes, definitely opt-in
04:29:45 <hackagebot> arbtt 0.3.0 - Automatic Rule-Based Time Tracker (JoachimBreitner)
04:29:55 <FunctorSalad_> the good thing is that you won't have to do any parsing if you work at the point where the AST is pretty-printed
04:30:14 <FunctorSalad_> (I'm just speculating how ghci works here, I haven't seen the code)
04:30:50 <EvilTerran> it'd need to be hacked up seperately for 'doze, too, i suspec
04:30:52 <EvilTerran> t
04:34:51 <FunctorSalad_> ivanm: didn't you write the graphviz package? apparently fdp supports edges between clusters directly
04:35:01 <ivanm> FunctorSalad_: yes
04:35:06 <FunctorSalad_> whereas with dot you have to do this ltail / lhead thing
04:35:09 <ivanm> I just have to work out a nice way of intergrating it in
04:35:15 <ivanm> (into the data structure that is)
04:35:40 <ivanm> FunctorSalad_: mainly because the whole "oh, a subgraph is a cluster if the ID starts with `cluster'" thingy :s
04:36:00 <FunctorSalad_> I only found this out by accidentally finding this example http://www.graphviz.org/Gallery/undirected/fdpclust.html
04:36:14 <FunctorSalad_> ivanm: yes that's silly
04:37:26 <ivanm> FunctorSalad_: so the only "sensible" way I can think of doing it is just to take GraphIDs, then add "cluster_" to them all
04:37:30 <FunctorSalad_> I guess you could put a dummy node into each cluster and lhead/ltail to it
04:37:34 <ivanm> and tell the user that they better use fdp or else ;-)
04:37:40 <FunctorSalad_> (when using dot)
04:37:42 <ivanm> FunctorSalad_: or that
04:37:48 <ivanm> but it's going to be a PITA to do properly
04:38:02 <ivanm> especially since how are you going to generate a dummy node (if you want it done automagically)?
04:38:10 <Schalken> Is there a way I can ask if a value of a certain type is an instance of a certain data constructor?
04:38:30 <Peaker> Schalken, Pattern matching!
04:38:35 <FunctorSalad_> ivanm: hmm yes that would be best but I agree it's a PITA ;)
04:38:58 <Schalken> Peaker: Outside pattern matching. :/
04:39:07 <Peaker> Schalken, But that is exactly what pattern matching does
04:39:21 <Peaker> Schalken, Its all about checking which data constructor a value is of
04:39:30 <Schalken> Peaker: But pattern matching can only be done for functions, can't it?
04:39:39 <ivanm> Schalken: create a function that uses pattern matching to test for each constructor, and then use that :p
04:39:43 <Peaker> Schalken, No, function pattern matching is only sugar for a "case" statement
04:39:47 <ivanm> Schalken: you can't pattern match on a function...
04:40:10 <Peaker> Schalken, f [] = 1 ; f (x:xs) = 2    is really:  f x = case x of [] -> 1 ; (x:xs) -> 2
04:41:03 <Schalken> Peaker: Aha! That's what I'm looking for: a case statement. The thing was I didn't want to create a new function.
04:41:10 <Peaker> Schalken, Why not? :-)
04:41:21 <Peaker> Schalken, You can create a local private function with a "where" clause
04:41:36 <ivanm> and usually functions are nicer than case statements
04:41:40 <Peaker> Schalken, it sees the scope so you don't have to pass a mountain of args to it
04:42:17 <Schalken> I think in this particular instance a case statement is nicer.
04:42:18 <Peaker> I see "case" as very low-level and try to avoid it. Pattern-matching in general as very first-order, I try to use higher-order combinators (e.g: maybe vs pattern matching Maybe)
04:42:31 <Peaker> Schalken, what data constructors are you matching against?
04:43:14 <FunctorSalad_> hmm the difference between function definition pattern matches and case seems rather trivial
04:43:36 <ivanm> except case requires more horizontal space
04:43:39 <Peaker> FunctorSalad_, syntax is important
04:43:44 <FunctorSalad_> I use a gratuitious "case" if the function name is long ;)
04:43:53 <FunctorSalad_> (so you don't have to repeat it)
04:44:19 <FunctorSalad_> or like you said a where-clause with a shorter name
04:44:27 * nomeata would use case more often if there were an anonymous version of it, i.e. an abbreviation for (\x -> case x of {...})
04:44:53 <en0th> is there a type class that express the default initialization of a data type?
04:44:55 <ivanm> nomeata: especially in a monad, usually IO... if there was a version of case that extracted the value from the monad for you...
04:45:06 <nomeata> ivanm: that as well
04:45:13 <ivanm> @hoogle mzero
04:45:14 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
04:45:21 <Schalken> I have a type BoolExp (boolean expression) and I'm writing a function to simplify boolean expressions. simplify (Not e) already matches on Not connectives, but inside there I want to ask whether or not the simplified version of e is an Xor or an Iff, because if it is one of those it should directly return the other. (not xor === iff, not iff === xor).
04:45:24 <ivanm> en0th: MonadPlus might be what you want
04:45:38 <en0th> okay, thanks!
04:45:47 <en0th> (i'll check it out)
04:45:57 <Schalken> But if it is neither, it should return Not (simplify e).
04:46:35 <nomeata> ivanm: with an anonymous case, you could get a "mcase" using liftM or <$>.
04:47:03 <FunctorSalad_> Schalken: simplify (Not e) = case simplify e of ....
04:47:05 <ivanm> nomeata: "anonymous case"? what do you mean by that?
04:47:17 <ivanm> FunctorSalad_: nah, case e of ...
04:47:25 <nomeata> ivanm: an abbreviation for (\x -> case x of {...})
04:47:26 <ivanm> it sounds like Schalken wants to only call simplify on e in certain cases
04:47:33 <ivanm> nomeata: right, I get you now
04:47:38 <FunctorSalad_> ivanm: no he needs it in all cases
04:47:54 <Schalken> ivanm: I want to call simplify on e in all cases, and switch on the result.
04:48:06 <ivanm> ahhh
04:48:09 <ivanm> ignore what I said then ;-)
04:49:29 <Schalken> Therefore, I have to do: simplify (Not e) = case simplify e of...
04:49:52 <Schalken> I cannot achieve that case statement using a pattern match where I currently have (Not e).
04:52:28 <FunctorSalad_> well, you can with -XViewPatterns
04:52:28 <Twey> Schalken: You want view patterns
04:52:36 <FunctorSalad_> simplify (Not (simplify -> e)) = ...
04:53:06 <FunctorSalad_> I think they're unpopular because they automatically make the exhaustiveness checker complain
04:53:09 <FunctorSalad_> :)
04:53:15 <Schalken> Is that in 98?
04:53:34 <jkff> No
04:54:12 <Schalken> I am limited to Haskell 98, so it's a case statement for me.
04:56:34 <Twey> FunctorSalad_: Speak for yourself.  I love view patterns and use them in nearly every project.  I think they should be H'.  :þ
04:56:54 <FunctorSalad_> ok
04:56:55 <Twey> Schalken: A where clause scopes over guards.
04:56:57 <ivanm> Twey: do you have an auto-replace for that char or something?
04:57:06 <Twey> ivanm: No, I type it by hand.
04:57:21 <Twey> (I hate it when programs decide to replace what I'm typing)
04:57:23 <ivanm> what character is that meant to be?
04:57:25 <Schalken> Twey: "A where clause scopes over guards." What does that mean?
04:57:34 <Twey> It's a thorn.
04:58:12 <ivanm> doesn't look like any kind of thorn I've seen on a plant...
04:58:31 <Twey> Schalken: You can do simplify (Not e) | case1 d = foo | case2 d = bar where d = simplify e
04:58:44 <Twey> ivanm: A letter þorn, silly.  :þ
04:58:52 <ivanm> heh
04:58:57 <ivanm> which language is that meant to be from?
04:58:57 <Twey> http://en.wikipedia.org/wiki/Thorn_%28letter%29
04:59:29 <Twey> Evolved from the thurisaz rune, it was used in Old English and most Norse-influenced languages, but remains today only in Icelandic
04:59:30 <Jafet> Letter porn!
05:00:24 <Twey> If it were up to me, English would be written using þorn and eð to distinguish voiced and unvoiced ‘th’.
05:00:41 <ivanm> well, wikipedia lies... it says Alt+0222 enters it; here, it changes which xchat tab I'm looking at...
05:01:05 <Twey> ivanm: Are you on Windows?
05:01:06 <EvilTerran> Twey, would you use eŋ as well?
05:01:10 <Schalken> Twey: But gaurds are not pattern matches. In the given case, inside a guard I would want to 'ask' whether or not d is an Xor.
05:01:21 <ivanm> Twey: nope
05:01:27 <ivanm> oh, wait, it only works in windows...
05:01:32 <Twey> EvilTerran: I would, though not for the same reason.
05:01:33 <ivanm> wikipedia misled me!
05:02:36 <tuukkah> compose t h -> þ
05:02:44 <ivanm> @type compose
05:02:46 <lambdabot> Not in scope: `compose'
05:02:54 <ivanm> hmmm.... ;-)
05:03:10 <Twey> ivanm: Yeah.  In GTK+ apps, you should be able to do C-S-u f e <RET> to get a thorn.
05:03:28 <tuukkah> ivanm, it's supposed to be a key in your keyboard :-)
05:03:37 <ivanm> Twey: waddaya know, it works! :o
05:03:38 <Twey> Personally, I use the compose key method, but that requires that you set up a compose key for X.
05:03:45 <ivanm> tuukkah: who says it should?
05:03:57 <Schalken> Twey: I can only ask if d is an Xor by saying "case d of Xor e1 e2 -> Iff e1 e2". I cannot do that using a guard.
05:04:02 <tuukkah> ivanm, it would be highly practical :-)
05:04:02 <Twey> Schalken: Indeed.
05:04:11 <Twey> Schalken: You can use a case, or you can use a helper function.
05:04:11 <ivanm> Twey: yeah, I've made ralt be another mod key for xmonad, so that won't work for me ;-)
05:04:25 <Schalken> Twey: There are not other options, correct?
05:04:27 <Twey> Schalken: Or you can use a whole lot of helper functions, called isXor or so on
05:04:36 <Schalken> Twey: Lol, right.
05:04:37 <Twey> ivanm: Personally, I use caps lock.
05:05:08 <ivanm> Twey: that's another Ctrl for me
05:05:19 <tuukkah> ivanm, you can have it be both
05:05:24 <Twey> ivanm: There are plenty of other keys you could use.
05:05:25 <Pygmalion> Probably a stupid question... But what time is it in UK/Ireland?
05:05:28 <Twey> Shift-caps, perhaps
05:05:29 <ivanm> since when I use my laptop keyboard, Dell in its infinite wisdom decided that the bottom-left key should be Fn, which is a right royal pain
05:05:31 <Twey> Pygmalion: 1306
05:05:43 <Twey> ivanm: Or the Menu key.
05:05:43 <ivanm> @time dcoutts
05:05:44 <Pygmalion> Twey: Thanks, my laptop and phone had different times :P
05:05:45 <lambdabot> Local time for dcoutts is Sun Oct  4 13:05:44
05:05:48 <Twey> Or Scroll Lock.
05:05:56 <ivanm> Twey: that's handy as an M-x replacement for emacs :p
05:06:06 <ivanm> and as for scroll lock... it isn't handy at all :s
05:06:13 <Twey> Not really, no :þ
05:06:33 <tuukkah> gnome keyboard settings, for example, let you check two boxes: "Compose location: Caps Lock" and "Control location: Make CapsLock an additional Ctrl"
05:06:57 <Twey> Using xmodmap, you can define just about any key with just about any modifiers to be just about anything.
05:07:05 <dcoutts> ivanm: mm?
05:07:34 <ivanm> dcoutts: getting the time in the UK for Pygmalion ;-)
05:07:42 <ivanm> you can go back into your dreamworld now :p
05:08:15 <Twey> keycode 66 = Control_L Multi_key Control_L Multi_key — should give you ctrl = caps, compose = shift + caps
05:08:24 <plcs> ah/win 10
05:08:58 <Twey> There are a total of about six different levels you can use easily.
05:09:16 <Twey> You're not using most of the power of your keyboard.  :þ
05:09:18 <tuukkah> xmodmap is black magic, and obsolete as well :-/
05:09:34 <Twey> tuukkah: It's poorly-documented, I'll admit, but obsolete?
05:09:44 <Twey> I haven't found anything to replace it yet.
05:10:09 <tuukkah> Twey, you're supposed to use something called xkb these days, another piece of black magic
05:10:25 <ivanm> tuukkah: I beg to differ
05:10:43 <tuukkah> i think i've read somewhere that xmodmap doesn't work in all modern X setups anymore
05:10:56 <ivanm> about xmodmap being obsolete and xkb being black magic
05:10:59 <tuukkah> and where it does, it's some kind of hack to emulate it through xkb
05:11:16 <tuukkah> ivanm, enlighten me :-)
05:11:21 <ivanm> tuukkah: in what aspect?
05:11:52 <ivanm> xkb is for multiple keyboard layouts and for alteration of pre-defined layouts
05:12:06 <ivanm> admittedly, it's slightly trickier to setup with Hal-based Xorg...
05:12:06 <tuukkah> where do i learn about xkb?
05:12:09 <ivanm> but it still works
05:12:15 <ivanm> tuukkah: the internetz! ;-)
05:12:27 <ivanm> I did all my xorg stuff a few years back; don't recall where I found everything
05:13:20 <tuukkah> one of the first google hits starts with "XKB is very powerful and flexible, but has practically no formal documentation on how to configure it."
05:13:37 <Twey> Yes :-D
05:13:43 <Twey> I'm reading that right now.  http://www.charvolant.org/~doug/xkb/html/index.html
05:13:44 <ivanm> but here, /usr/share/X11/xkb/rules/ had all the stuff I needed (for the options)
05:13:55 <ivanm> tuukkah: most people don't want to know and trust gnome and kde to do it for them
05:14:47 <tuukkah> yeah, that's why i suggested checking those two boxes in gnome config, but they are badly limited in the options
05:15:18 * ivanm wonders how long it's going to be before an on-topic statement is uttered...
05:15:45 <Peaker> down with N-tuples!
05:15:50 * tuukkah would like to know what the compose combination for lambda is :-)
05:15:51 <ivanm> heh
05:16:03 <EvilTerran> up with extensible records!
05:16:11 <Peaker> tuukkah, the composition cheat for lambda is (.)
05:16:19 <Peaker> EvilTerran, HList based ones?
05:16:19 <Twey> Haha.
05:16:24 <Twey> tuukkah: None by default.  You can define them all.
05:16:52 <EvilTerran> Peaker, well, a language extension would be nice; i guess HList will have to do for now :P
05:17:45 <Peaker> the ones in haskell-oop seem pretty nice
05:17:51 <Peaker> though possibly hard to optimize
05:19:04 <gwern> auugh. yi errored out after 40 minutes of compiling
05:19:34 <gwern> parallel builds can't come soon enough
05:19:55 <Peaker> using ghc directly with make -j isn't it possible now?
05:20:16 <ivanm> Peaker: well, yeah, if you want to do it by hand...
05:20:17 <inaeternum> --- is there some kind of four bit unsigned integer data type?
05:20:26 <ivanm> rather than ghc --make or via cabal...
05:20:35 <ivanm> inaeternum: one of the Word types?
05:20:37 <ivanm> @hoogle Word
05:20:38 <lambdabot> module Data.Word
05:20:38 <lambdabot> Data.Word data Word
05:20:38 <lambdabot> Data.Word data Word16
05:21:12 <inaeternum> might be - i was looking in Data.Int only ^^
05:22:02 <Berengal> > -1 :: Word
05:22:03 <lambdabot>   18446744073709551615
05:22:34 <tuukkah> do you guys know if there's a team working on the ghc packages in ubuntu?
05:22:53 <ivanm> apparently there is IIRC
05:22:59 <ivanm> there's also a debian team which is much further along
05:23:22 <Jafet> ubuntu is still in the dark ages of 6.8, I believe
05:23:24 <tuukkah> i see the ubuntu beta is missing cabal-install and libghc6-harp-dev
05:23:28 <cocon> is there a library function to comput f^n = \x -> f (f (... x)) ?
05:23:38 <Baughn> ..sort of. Unfortunately, they insist on splitting ghc into distinct packages
05:23:52 <Baughn> cocon: iterate
05:23:53 <tuukkah> Jafet, the beta has 6.10.4
05:24:04 <Jafet> For ubuntu I just used hackage to get packages, since the naming scheme they use in the repos is nonsensical
05:24:15 <cocon> Baughn: it forces me to use lists, though
05:24:24 <ivanm> cocon: don't think so, but that's basically a church numeral
05:24:32 <tuukkah> Jafet, i think they use the same as debian
05:24:34 <ivanm> @hoogle (a -> a) -> Int -> a -> a
05:24:35 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
05:24:35 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
05:24:35 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
05:24:56 <ivanm> cocon: you could do iterate, and then !! n ...
05:27:58 <tuukkah> ah, found this: https://wiki.ubuntu.com/MOTU/Teams/UncommonProgrammingLanguages/Haskell
05:34:47 <Baughn> tuukkah: "UncommonProgrammingLanguages"? ;_;
05:35:25 <Jafet> It means we're leet
05:36:44 <qwr> hm, Scheme, Erlang, ML and Nemerle are also leet
05:36:45 <tuukkah> i see that's the name of the team that takes care of haskell, scheme, erlang, ml, nemerle
05:36:54 <tuukkah> qwr
05:36:56 <tuukkah> :-)
05:38:14 <tuukkah> whereas unleet languages are python, ruby, java - makes sense
05:39:46 <gwern> nemerle?
05:39:50 <gwern> now that's obscure
05:40:00 <tuukkah> which somehow reminds me to ask whether someone has ported apple's gcd api to haskell
05:40:51 <gwern> tuukkah: how complex could an api be for finding common divisors?
05:41:09 <Jafet> I think he means the concurrency framework
05:41:12 <tuukkah> gwern, i should've pre-empted that comment :-)
05:41:17 <gwern> (hm. yi's scion functionality is compile-broken...)
05:44:31 <EvilTerran> Baughn, as compared to those dirty common programming languages :P
05:44:44 <inaeternum> how can i remove old versions of ghc that i installed with the binary distribution package (from haskell.org/ghc) for linux?
05:45:09 <Baughn> inaeternum: Depends. Simplest would be "rm -rf /usr/local/*"
05:45:30 <Baughn> inaeternum: There may also be a "make uninstall" command, but for obvious reasons I won't be testing that theory
05:45:42 <inaeternum> there is none
05:46:27 <Baughn> inaeternum: Beyond that, it's pretty much a matter of "delete ghc-related binaries from /usr/local/bin, appropriate directories from /usr/local/{lib,share,doc}".
05:46:43 <inaeternum> ok i'll try that
05:46:45 <Baughn> inaeternum: For future reference, use checkinstall to produce packages
05:52:45 <Phyx-> !latest
05:52:50 <Phyx-> lol
05:52:53 <Phyx-> too bad
05:55:26 <dcoutts> is it just me, or has http://learnyouahaskell.com/ got some crazy CSS that sets the example text to white on white?
05:55:46 <dcoutts> I was about to recommend the section on random numbers to someone, but it's unreadable
05:55:56 <gwern> phew! finally got yi not just compiling but running
05:56:01 <gwern> what a gnarly config system
05:56:17 <Twey> dcoutts: WFM.
05:56:27 <Twey> It's coloured-on-black.
05:56:35 <gwern> either yi isn't well designed or for some things it really is better to be dynamic/imperative
05:57:00 <dcoutts> Twey: mm, yes, in a different browser I get a different result
05:57:38 <Twey> What browser were you using?
06:10:10 <jdkoeck> test message
06:10:48 <jdkoeck> hey, anyone used qthaskell around here ?
06:13:14 <en0th> is this a correct starting point to model a state machine? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4255#a4255
06:14:20 <Berengal> en0th, why the stateShow and statsShow when you've already got Show?
06:15:02 <jdkoeck> maybe you should start with concrete data types, and abstract with type classes later (if needed)
06:15:10 <en0th> i don't really know. maybe to allow a different representation
06:15:53 <Berengal> I'd use getState :: s -> StateData and getStats :: stats -> StatsData instead...
06:16:23 <maltem> hmph. Doesn't look like there's an EvenLessDecidable extension allowing me to do    class (forall m. Monad m => Stream s m Char) => CharStream s      , does that even make sense?
06:17:01 <en0th> Berengal: how should StateData and StatsData be defined?
06:17:21 <Berengal> en0th, I don't know... some data types
06:17:33 <Berengal> Or maybe type classes, even
06:17:40 <Berengal> It depends on what you want
06:18:38 <en0th> i meant to write an abstract framework to implement various machines, with little effort (only transition rules, for example)
06:19:39 <Jafet> .oO(A flowchart tarpit?)
06:19:55 <en0th> like: you supply a state representation, and functions to change it, and it will "wrap" into a machine. I don't know if it's a correct functional approach..
06:20:34 <jdkoeck> seems good to me, but you don't need type classes early on for that
06:21:12 <jdkoeck> a record with a transition function from state to state would be generic enough, I think
06:21:31 <en0th> but my machine implementation will need, for example, to test whether a state is the final one or not
06:22:31 <en0th> that's why i put stateIsFinal into a typeclass. I don't know an alternative..
06:22:58 <jdkoeck> i'd say include a function final :: State -> Bool in the record
06:23:54 <en0th> into the state data type?
06:24:06 <jdkoeck> yes
06:24:22 <en0th> omg this is clever
06:25:59 <jdkoeck> that's pretty standard in haskell, since functions are first-class citizens :)
06:26:45 <en0th> or i could simply add a Final data constructor for the state...
06:27:46 <jdkoeck> en0th: what do you mean by "final data constructor" ?
06:28:09 <en0th> like data State a = State a | Final a
06:29:01 <en0th> and let the state transition function determine whether it's the goal state
06:29:48 <EvilTerran> en0th, this sounds suspiciously like it might have something to do with the Either monad
06:30:01 <EvilTerran> (aside from its bunk Error constraints in MTL)
06:30:23 <EvilTerran> > do x <- Right 2; y <- Right 3; return (x*y)
06:30:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:30:24 <lambdabot>    `Control.Monad.Error.Cla...
06:30:30 <EvilTerran> ... grr.
06:30:46 <jdkoeck> ^^
06:30:49 <en0th> hehe
06:32:24 <EvilTerran> > do x <- Right "foo"; y <- Right "bar"; Left $ x ++ y; undefined
06:32:26 <lambdabot>   Left "foobar"
06:32:45 <EvilTerran> ^ it bails out when a line is a Left, continues when it's a Right
06:36:04 <en0th> mm, there are lots of ways to do the same thing
06:39:45 <cocon> is there an array type in the library that is compatible with the FFI?
06:40:08 <mauke> depends on your definition of "compatible"
06:40:33 <cocon> a Haskell array that can be read and written from C
06:40:56 <cocon> one outside the IO monad...
06:41:37 <cocon> maybe uvectors?
06:41:49 <mauke> outside IO? that doesn't make sense
06:42:01 <Jafet> unsafeInterfaceWithC
06:43:57 <jdkoeck> en0th: maybe you want something like that ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10427#a10427
06:44:12 <burp> with storable datatypes?
06:45:40 <cocon> oh, I just saw that all foreign calls live in the IO monad
06:45:56 <cocon> what if I happen to know that my C function is pure? unsafeInterfaceWithC?
06:46:22 <mauke> if it reads/writes an array, it's not pure
06:46:25 <Jafet> Even if you do, Haskell doesn't
06:46:28 <mauke> but you can just import it without the IO type
06:46:30 <Twey> They don't have to live in the IO monad
06:46:31 <Twey> Right
06:46:50 <cocon> oh, cool
06:46:53 <Jafet> That would use some FFI though
06:47:16 <cocon> so my C function should just *read* some kind of Haskell array
06:47:27 <en0th> mm jdkoeck, that's what i meant :)
06:47:39 <cocon> which array type would be best? I see a bunch of different ones on hackage...
06:48:35 <mauke> still not pure
06:49:33 <cocon> why not?
06:50:13 <mauke> because someone else could modify the array
06:50:43 <cocon> who?
06:50:46 <mauke> and then readfrom x >> writeto x >> readfrom x would return two different values from the same function call
06:50:48 <mauke> you
06:50:58 <cocon> :)
06:51:07 <cocon> someone else besides me, that is me?
06:56:30 <jdkoeck> en0th: I improved it, the state machine is polymorphic in its state and input types, follow http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10427#a10429
06:56:42 <gwern> hm. variables don't; and random number generators aren't?
06:56:53 <jdkoeck> en0th: (end of page for last revision)
06:58:14 <blueonyx> can an instance for Read be automaticly derived?
06:58:33 <en0th> jdkoeck: inspecting .. :)
06:59:38 <jdkoeck> blueonyx: yes, but using the derive library http://community.haskell.org/~ndm/darcs/derive/derive.htm
07:02:16 <en0th> jdkoeck: how do i specify type restrictions in a data constructors without record notation? (if it's possible)
07:03:39 <gwern> blueonyx: sure. you can derive read & show, usually
07:04:27 <krushik> what package contains runhaskell command?
07:06:23 <gwern> cabal
07:06:34 <mauke> really?
07:06:35 <dcoutts> erm no
07:06:49 <dcoutts> krushik: each Haskell compiler supplies one
07:07:01 <jdkoeck> en0th: mmh, not sure what you mean
07:07:56 <Berengal> runhaskell symlinks to runghc on my machine...
07:08:35 <gwern> dcoutts: I'm technically incorrect, but does anyone ever ask about runhaskell without intending to build a cabal package? and since having cabal implies having ghc...
07:09:29 <dcoutts> gwern: you could just say ghc
07:09:48 <dcoutts> (technically one can have the cabal program without ghc)
07:10:22 <gwern> dcoutts: really? I thought yhc and hugs support were broken
07:11:17 <krushik> I can't satisfy the dependencies...
07:11:20 <krushik> cabal: cannot configure arbtt-0.3.0. It requires base ==4.* && ==4.* && ==4.*
07:11:20 <krushik> For the dependency on base ==4.* && ==4.* && ==4.* there are these packages:
07:11:20 <krushik> base-4.0.0.0 and base-4.1.0.0. However none of them are available.
07:11:21 <dcoutts> gwern: we don't check the cabal program with hugs and nhc much, but it has worked at various points
07:11:32 <krushik> cabal: cannot configure base-4.1.0.0. It requires ghc-prim -any and integer
07:11:32 <krushik> -any
07:11:33 <gwern> 'at various points' :)
07:11:57 <krushik> where can I find ghc-prim?)
07:11:59 <dcoutts> gwern: at the points when ndm complained and I fixed it :-)
07:12:04 <dcoutts> krushik: you've got base 4 and ghc-prim
07:12:24 <gwern> you know, I haven't seen much from ndm lately. I wonder if his new job is that demanding
07:12:26 <dcoutts> krushik: well, you probably do. Unless you're using ghc-6.8 or older
07:12:32 <dcoutts> gwern: I think it is
07:12:43 <gwern> what was it... with credit suisse?
07:12:47 <dcoutts> SC
07:13:01 <dcoutts> standard chartered
07:13:12 <krushik> ghc --version gives 6.8.2
07:13:27 <dcoutts> krushik: ah ok, so that package is saying it needs ghc-6.10
07:13:34 <dcoutts> krushik: which comes with base 4
07:18:07 <en0th> jdkoeck: here is my problem .. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10431
07:21:36 <jdkoeck> en0th: I'm reading your code
07:22:44 <en0th> i'm missing something about typing, there
07:24:24 <jdkoeck> en0th: sorry, can't answer right now as I'm busy
07:24:53 <jdkoeck> en0oth: generally, you should put type classes constraints in functions, not in data definitions
07:25:37 <danco> importing e.g. Control.Monad.Error in ghci yells about the older one existing in mtl; is there any way i can make it just choose the newer one?
07:25:53 <danco> i don't think mtl is going away for a very long time..
07:26:03 <en0th> jdkoeck: that's the point i guess. thanks a lot, i saved your code.
07:29:21 <aavogt> danco: ghc-pkg hide mtl-0.0.0 # or whatever the older version is
07:30:13 <aavogt> you could also tell ghci to -hide-all-packages, and then list specific -package
07:34:00 <taruti> Does any Haskell web framework support JSON-RPC?
07:40:16 <burp> just use a json-rpc package/library
07:45:37 <constantine_> hey all
07:45:42 <taruti> burp: there are raw json packages on Hackage, but nothing for json-rpc in special
07:46:43 <constantine_> guys im badly stuck with haskell i want to do something fairly simple but i cant get my head around it anyone willing to help?
07:47:00 <burp> hm itsn't it basically just json?
07:47:12 <PeakerWork> constantine_: if you ask a direct question, plenty will probably be glad to help
07:49:46 <constantine_> ok fair enough, I just started with haskell (2 days ago).I want to compare two lists and get the common elements, i did itthrough the command line "take 10 $ filter(\(x,y) -> x == y) $ zip x,y [1,2,3] [1,3,5] and it works
07:49:59 <mauke> no, it doesn't
07:50:16 <constantine_> hmm? :P
07:50:21 <mauke> that's a syntax error
07:50:54 <ski> > take 10 $ filter(\(x,y) -> x == y) $ zip (,) [1,2,3] [1,3,5]  -- ?
07:50:55 <lambdabot>   Couldn't match expected type `[a]'
07:50:55 <lambdabot>         against inferred type `a1 -> b -...
07:51:11 <burp> you want zipWith or just zip?
07:51:35 <PeakerWork> > take 10 . filter (uncurry (==)) $ zipWith (,) [1,2,3] [1,3,5]
07:51:35 <constantine_> give me a mom
07:51:35 <lambdabot>   [(1,1)]
07:51:37 <burp> and this is not doing what you want ;)
07:51:47 <constantine_> i will tell you in a min
07:51:51 <mauke> PeakerWork: zipWith (,) better written as zip
07:51:56 <ski> > take 10 $ filter(\(x,y) -> x == y) $ zipWith (,) [1,2,3] [1,3,5]
07:51:57 <lambdabot>   [(1,1)]
07:52:09 <constantine_> yes
07:52:16 <burp> better use list monad
07:52:21 <mauke> burp: why?
07:52:23 <constantine_> ski:  exactly
07:52:33 <burp> mauke: is that what he wants?
07:52:41 <burp> "I want to compare two lists and get the common elements"
07:52:41 <ski> constantine_ : but this doesn't give you common elements ..
07:52:46 <constantine_> well not
07:52:47 <constantine_> yeah
07:52:50 <constantine_> my mistake
07:52:52 <mauke> :t intersect
07:52:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
07:53:01 <burp> oh intersect.. ;)
07:53:11 <burp> there's no work to be done :D
07:53:23 <burp> @src intersect
07:53:23 <lambdabot> intersect = intersectBy (==)
07:53:35 <constantine_> i am sure i had it working a minute ago ahaha give me a sec
07:54:59 <constantine_> take 2 $ filter (\(x,y) -> x == y) $ zip [1,2,6] [4,2,6]
07:55:10 <burp> > [ x | x <- [1,2,6], y <- [4,2,6], x==y ]
07:55:11 <lambdabot>   [2,6]
07:55:14 <mauke> > intersect "consta" "ntine_"
07:55:20 <lambdabot>   "nt"
07:55:30 <nomeata> @src intersectBy
07:55:30 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
07:55:52 <mauke> > intersect "aaa" "a"
07:55:53 <lambdabot>   "aaa"
07:55:56 <mauke> fail :-(
07:56:03 <trofi> :t extersect
07:56:04 <PeakerWork> mauke: Right, I only partially corrected the above :)
07:56:04 <lambdabot> Not in scope: `extersect'
07:56:11 <mauke> intersect--
07:56:29 <Jafet> extersect mormons
07:58:30 <constantine_> Guys this one works for me, take 2 $ filter (\(x,y) -> x == y) $ zip [1,2,6] [4,2,6], it give me the 2 common elements of the lists [1,2,6] and [4,2,6]
07:59:02 <burp> you have luck
07:59:05 <burp> that this works
07:59:11 <constantine_> [(2,2), (6,6)]
07:59:17 <mauke> because they're in the same position
07:59:21 <mauke> also, why the 'filter 2'?
07:59:21 <burp> yup
07:59:27 <mauke> er, 'take 2 $ filter ...'?
07:59:39 <ski> > filter (\(x,y) -> x == y) $ zip [1,2,3] [2,3,1]
07:59:40 <lambdabot>   []
08:00:02 <Baughn> :t curry (==)
08:00:04 <lambdabot> forall a b. (Eq a, Eq b) => a -> b -> (a, b) -> Bool
08:00:50 <constantine_> well what I would like to do is to write a function that will return a list of all common elements in two lists
08:00:56 <constantine_> thats the closest i got
08:01:07 <mauke> so what's wrong with intersect?
08:01:19 <burp> constantine_: and I've written another solution a few lines above ;)
08:02:40 <burp> (well that's basically the src of intersect)
08:02:56 <constantine_> aha,
08:03:03 <ski> > [ x | x <- [1,2,3,5,8], y <- [2,3,5,7], x == y ]
08:03:04 <lambdabot>   [2,3,5]
08:03:06 <constantine_> my approach was at least 10 times more complicated
08:03:08 <Baughn> constantine_: Data.Set.toList . Data.Set.union `on` Data.Set.fromList
08:03:11 <Baughn> ..or thereabouts
08:03:18 <Baughn> Um. Except with intersect.
08:03:29 <ski> > [ x | x <- [1,1,2], y <- [1,3,6], x == y ]
08:03:30 <lambdabot>   [1,1]
08:03:30 <mauke> and with .:
08:03:39 <burp> ski: um, :>
08:03:44 <int-e> > ([ x | x <- [2,2], y <- [2,2], x == y], intersect [2,2] [2,2])
08:03:45 <lambdabot>   ([2,2,2,2],[2,2])
08:03:56 <ski> > [1,1,2] `intersect` [1,3,6]
08:03:57 <lambdabot>   [1,1]
08:04:14 <burp> add some |uniq :>
08:04:18 <ski> int-e : ty
08:04:39 <int-e> use Data.Set
08:06:57 <danco> is parsec2 still considered the "cool
08:07:00 <danco> " parsec?
08:07:07 <ddarius> > filter (uncurry (==)) $ liftM2 (,) [1,2,3] [2,3,1]
08:07:08 <lambdabot>   [(1,1),(2,2),(3,3)]
08:07:34 <constantine_> thank you guys, I have one more question "[ x | x <- [1,2,3,5,8], y <- [2,3,5,7], x == y ]"  is ok in the terminal but how i can save it in a function and call it with a parameter? map x fibonaci [1,3,4,5,6] [2,4,5,6,8,9]?
08:07:37 <blueonyx> @i seq
08:07:37 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
08:07:43 <blueonyx> @ seq
08:07:54 <constantine_> Im mega confused and the books I got from work are really bad :/
08:08:04 <ski> @type seq
08:08:05 <lambdabot> forall a t. a -> t -> t
08:08:24 <blueonyx> ski: ya, but where is it defined?
08:08:30 <ski> @index seq
08:08:30 <lambdabot> Prelude, Control.Parallel
08:08:38 <blueonyx> oh kthx
08:08:55 <ski> constantine_ : what is `fibonaci' (`fibonacci' ?) here ?
08:09:00 <ski> a list of numbers ?
08:09:03 <constantine_> yeye
08:09:10 <Berengal> Prelude> :info seq, seq :: a -> b -> b 	-- Defined in GHC.Prim, infixr 0 seq
08:09:12 <ski> which part of the original expression do you want to vary ?
08:09:20 <constantine_> I just said it as an example it can be any list of numbers
08:09:36 <nickknw> hey, I have what is probably quite a newbie question.  I'm doing the "Yet Another Haskell Tutorial" tutorial, and I'm stuck on one of the exercises
08:09:56 <ski> constantine_ : do you want to be able to vary both of the lists in the expression ?
08:10:19 <danco> constantine_: maybe you want    f l1 l2 = [x | x <- l1, y <- l2, x == y]   ?
08:10:21 <constantine_> ski: I have written that: fib n  | n == 0 = 0  | n == 1 = 1  | n>1        = (fib (n - 2)) + (fib (n -1))
08:10:35 <Taejo> nickknw: we try to be newbie friendly... go ahead
08:10:50 <ski> then `fib' is a function (from numbers to numbers) .. not a list of numbers
08:10:51 <constantine_> ski: so what i did in the terminal was map fib [1..]  in order to get all the lists
08:11:01 <constantine_> a list of infinite fib numbers
08:11:03 <ski> ok
08:11:37 <ski> i'm still not quite sure what you want to do in the other case, though .. maybe what danco suggested ?
08:11:42 <nickknw> basically, for each number in a list of numbers, I want to print out a seperate line that says "5 factorial is 120".  I can print them all out in another list (like [120, 40320, 2] ), but I don't know how to turn a list of [8,5,2] into three seperate lines
08:11:47 <blueonyx> Berengal: thx, my ghci says Not in scope when i use :t but it is in scope after :i seq :/
08:11:48 <nickknw> thanks, Taejo
08:11:59 <constantine_> chat going to fast sorry i missed danco
08:12:09 <constantine_> wait give me a mom to explain it in a sec
08:12:17 <Berengal> blueonyx, typo perhaps? Should be imported in Prelude
08:12:57 <blueonyx> oh of course -.- seq vs sep
08:13:09 <Taejo> nickknw: unlines turns a list of strings into a single newline-separated string
08:13:30 <Taejo> > unlines ["alpha", "beta", "gamma"
08:13:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:13:32 <Taejo> > unlines ["alpha", "beta", "gamma"]
08:13:33 <lambdabot>   "alpha\nbeta\ngamma\n"
08:14:00 <nickknw> hmmm, okay
08:14:44 <int-e> > let n = 42 in unwords ["n", =", show n]
08:14:44 <lambdabot>   <no location info>: parse error on input `='
08:14:45 <nickknw> so now I just need to try and turn [1,2,3] into something like ["1 is 1", "2 is 4", "3 is 9"]
08:14:46 <int-e> > let n = 42 in unwords ["n", "=", show n]
08:14:47 <lambdabot>   "n = 42"
08:15:05 <constantine_> I have fib.gs which contains fib n
08:15:05 <constantine_>   | n == 0 = 0
08:15:05 <constantine_>   | n == 1 = 1
08:15:05 <constantine_>   | n>1        = (fib (n - 2)) + (fib (n -1)) I can call it :l fib.gs and use map fib [1..] in order to get  an infinite list of fib numbers. I am looking into of how to combine 2 functions in order to get all the fib numbers  that are also square numbers.
08:15:08 <int-e> map is your friend :)
08:15:15 <danco> constantine_: http://tunes.org/~nef/logs/haskell/09.10.04
08:15:29 <constantine_> aha thx danco
08:15:30 <danco> if chat goes to fast ever
08:15:49 <constantine_> I started doing that my finding the common element in the two list
08:16:07 <constantine_> which wasnt the best approach
08:16:25 <blueonyx> does 'content <- readFile "particle"; let ps = content `seq` (take count . map read . lines $ content)' make sense that i can work with ps and have no IO involved?
08:17:34 <danco> constantine_: intersecting the lists works but is going to be like O(n^2)
08:18:01 <ddarius> danco: Don't worry.  The 2^n for the fib will swamp that out...
08:18:21 <danco> ok
08:19:12 <danco> constantine_: so if you have a line     intersectLists l1 l2 = [x | x <- l1, y <- l2, x == y]   you will be able to call that in ghci as well
08:19:27 <constantine_> nice
08:19:43 <constantine_> thank you, i will check it out now
08:20:03 <ddarius> That was a bit of a joke.  constantine_'s infinite list of fibs will only get up to about 40 before dying.
08:20:17 <int-e> constantine_: fibonacci numbers grow exponentially, so you'll generate an awful lot of squares.
08:20:19 <danco> right but memoization is complicated
08:20:28 <kakeman> why this doesn't work http://darcs.haskell.org/packages/GLUT/examples/OrangeBook/ogl2brick/ ? i'm too noob to solve it myself
08:20:31 <constantine_> there is only 1 common square in the fib numbers
08:21:41 <int-e> danco: you can do much better if you know that both lists are sorted.
08:22:30 <danco> yes
08:23:30 <int-e> kakeman: "doesn't work" doesn't work as a problem description.
08:27:20 <danco> "An old conjecture about Fibonacci numbers is that 0, 1 and 144 are the only perfect squares. Recently there appeared a report that computation had revealed that among the first million numbers in the sequence there are no further squares." goes on to prove it http://math.la.asu.edu/~checkman/SquareFibonacci.html
08:28:39 <int-e> kakeman: (works for me btw.)
08:28:42 <int-e> danco: thanks
08:28:51 <Baughn> danco: Hold on, nobody'd /checked/ before?
08:29:54 <danco> checked thru the infinite lists?
08:30:02 <danco> or is this a joke about ~checkman
08:31:15 <Baughn> danco: No, just checked for a finite subset
08:31:46 <danco> this was in 1964
08:31:52 <Baughn> Checking the first million fibonnacci numbers wouldn't be very hard on modern computers, and mathematicians would look very silly if there turned out to be a perfect square there anyway
08:31:56 <Baughn> ..oh
08:32:15 <Baughn> So, this is some new and interesting definition of "recently" then, I guess. ^^;
08:32:26 <danco> it's a newer definition
08:32:36 <Baughn> A recent one, you might say?
08:32:37 <Twey> The geological one :þ
08:37:34 <danco> can i get (f 4 = 4) and (f 5 = 5) in one @let?
08:37:45 <ddarius> danco: Yes
08:37:55 <Baughn> That's the only way you can do it, even
08:38:04 <Baughn> @let f 4 = 4; f 5 = 42
08:38:04 <lambdabot>  Defined.
08:39:00 <hackagebot> GPipe 1.0.0 - A functional graphics API for programmable GPUs (TobiasBexelius)
08:39:10 * Baughn stares
08:39:20 <danco> @let isectSorted a@(x:xs) b@(y:ys) = if x == y then x:isectSorted xs ys else if x < y then isectSorted xs b else isectSorted a ys; isectSorted [] _ = []; isectSorted _ [] = []
08:39:21 <lambdabot>  Defined.
08:39:49 <danco> @let fibs = 1:1:zipwith (+) fibs (tail fibs)
08:39:49 <lambdabot>  <local>:9:11: Not in scope: `zipwith'
08:39:54 <danco> @let fibs = 1:1:zipWith (+) fibs (tail fibs)
08:39:55 <lambdabot>  Defined.
08:40:22 <danco> > take 2 . isectSorted fibs $ map (^2) [1..]
08:40:23 <lambdabot>   [1,144]
08:40:30 <danco> > take 3 . isectSorted fibs $ map (^2) [1..]
08:40:34 <lambdabot>   mueval-core: Time limit exceeded
08:40:37 <ski> (constantine_ : .. would any mom do ?)
08:43:51 <blueonyx> how can i benchmark just the calculations from a function which gets its values from a file? i think lazyness is biting me here :(
08:44:24 <Baughn> blueonyx: Control.Parallel.Strategies.rnf
08:44:37 <Baughn> blueonyx: Well, specifically, evaluate . rnf
08:44:50 <Baughn> ..evaluate <$> rnf, really
08:45:17 <Baughn> ^W^W^W^W
08:46:05 <cocon> what is a 'regular' array?
08:46:26 <Baughn> A Data.Array one?
08:47:03 <cocon> Baughn: doesn't fit the context (http://hackage.haskell.org/packages/archive/accelerate/0.6.0.0/doc/html/Data-Array-Accelerate.html)
08:47:04 <ziman> isn't that a non-jagged (multidimensional) array?
08:47:08 <Baughn> (There are plenty of other array types. Bytestring, uarrays, Ptr even...)
08:47:11 <cocon> what's jagged?
08:47:28 <blueonyx> Baughn: thanks, will read into it
08:47:34 <Baughn> cocon: [[2],[3,4]] <-- Jagged "array"
08:48:02 <cocon> thanks
08:48:04 <ziman> a jagged array has rows (or columns) of different length, as Baughnt has illustrated
08:48:11 <ziman> s/t / /
08:49:50 <kakeman> http://pastebin.com/d5fb82edf here is problem
08:51:30 <lvillani> dumb question: i'm using the network package to listen for incoming connection but Network.HTTP.receiveHttp wants an HandleStream and I cannot find a way to use the Handle i get with functions from network package
08:51:52 <lvillani> needless to say, I am learning haskell :)
08:52:01 <lvillani> (at least trying to...)
08:52:16 <haskellnoob> Is there a way to ensure that when I map a function over a list (as in map f myList), the applications of f to the elements of myList happen in a strict manner?
08:53:26 <kakeman> i quess there is no Vector3 but where it is?
08:53:41 <Baughn> ivanm: It's not made to be used with Handles. Either use a Socket instead, or use the Network.TCP module in the HTTP package, which is nicer anyway (if a bit misplaced).
08:53:48 <Baughn> lvillani: Er, that was for you
08:53:52 <Makoryu> haskellnoob: Sure, make it a strict function
08:54:05 <Makoryu> haskellnoob: Or.... write a strict map
08:54:09 <Twey> And then use map $!
08:54:39 <Baughn> haskellnoob: Or use map `using` seqList
08:54:50 <Twey> Or map f $! xs, maybe, or… oh, I don't know.  Heh.
08:54:58 <Twey> @index using
08:54:58 <lambdabot> Control.Parallel.Strategies
08:55:04 <Makoryu> :t using
08:55:06 <lambdabot> forall a. a -> Strategy a -> a
08:55:14 <lvillani> Baughn: thanks, I will give a look at Network.TCP
08:55:16 <Makoryu> :t seqList
08:55:17 * Baughn is not a fan of baking strictness into combinators
08:55:17 <lambdabot> forall a. Strategy a -> [a] -> Done
08:55:23 <Twey> Hmn
08:55:27 <Baughn> Well, seqList rwhnf, I guess
08:55:28 <haskellnoob> Makoryu: how do i write a strict map ?
08:55:38 <Makoryu> :t map `using` seqList
08:55:39 <lambdabot>     Couldn't match expected type `[a] -> [b]'
08:55:39 <lambdabot>            against inferred type `()'
08:55:39 <lambdabot>     Probable cause: `seqList' is applied to too many arguments
08:55:44 <haskellnoob> Baughn: thanks, let me check out seqList
08:55:52 <lvillani> Baughn: or, maybe I can assemble an HandleStream with a Socket?
08:55:59 <lvillani> <- confused
08:57:00 <Twey> rwhnf?
08:57:05 <Twey> Recursive weak-head normal form?
08:57:36 <nickknw> Ha, I did it, it works!  Thanks Taeko
08:57:36 <ski> real-world haskell normal form ?
08:57:51 <Twey> Heh
08:57:52 <nickknw> Ha, I did it, it works!  Thanks Taejo*
08:58:40 <lvillani> Baughn: I cannot find functions to listen for incoming connections inside Network.HTTP
08:58:45 <Taejo> nickknw: cool, glad to help
08:59:08 <lvillani> oh, it seems I can use socketConnection to get the HandleStream
09:01:27 <haskellnoob> how do i make a function strict?
09:06:40 <Makoryu> haskellnoob: strictAdd x y = x `seq` y `seq` x + y
09:07:00 <Axman6> or strictAdd !x !y = x + y
09:07:21 <ziman> haskellnoob, there is `seq' and `$!' for similar purposes; maybe the easiest way to go is to use (f $!) instead of f, but that depends on the scenario (e.g. how deep should the strictness go) -- you might even need Control.Parallel.Strategies.rnf
09:07:24 <Makoryu> Yeah, for the latter you need the {-# LANGUAGE BangPatterns #-} pragma
09:07:50 <Makoryu> haskellnoob: I'm curious as to why you're making this function strict
09:08:29 <Makoryu> Presumably it's for IO purposes, but otherwise it's usually something the compiler can analyze with optimization turned on
09:09:06 <Saizan_> which (+) is that?
09:09:20 <plcs> can someone direct me to an article describing how Haskell compiles?
09:09:23 <Saizan_> oh, it was just an example
09:09:30 <plcs> i seem to suck at finding good google examples
09:09:36 <haskellnoob> Makoryu: I have written some code that conks out with a "Stack space overflow" error on a reasonably sized input.
09:10:00 <Saizan_> plcs: you mean how an haskell program is implemented on hardware?
09:10:08 <plcs> Saizan_: yeah
09:10:15 <Makoryu> haskellnoob: Paste the code somewhere. It might be too lazy... or it might not be lazy enough
09:10:19 <Makoryu> @where paste
09:10:20 <lambdabot> http://hpaste.org/new
09:10:26 <Saizan_> ?google implementing lazy functional languages
09:10:30 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
09:10:58 <Saizan_> plcs: that paper tells you roughly how GHC does it
09:11:07 <plcs> Saizan_: thanks :) I'll take a look
09:11:08 <Saizan_> there's also a more extendend book
09:11:08 <haskellnoob> Makoryu: Thanks, will do. I also have code that works fine for this same input, but that was too slow so I tried to rewrite it with a better (?) algorithm, and I got this stack overflow.
09:11:55 <cocon> is there an easy way to make something Storable?
09:13:44 <mauke> depends on what the something is
09:13:50 <Saizan_> if it corresponds to some C struct you can use the c2hs's hooks to define the methods
09:14:36 <cocon> it's [Int]
09:15:01 <mauke> that's not going to work
09:15:59 <cocon> do you mean it isn't possible to implement Storable for [Int]?
09:16:10 <mauke> how are you going to do sizeOf?
09:16:24 <haskellnoob> Makoryu: I have pasted the code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10432#a10432
09:17:10 <cocon> mauke: ok, only finite lists are storable, of course
09:17:54 <mauke> cocon: no
09:17:54 <mauke> only constant-size lists are storable
09:17:54 <mauke> i.e. tuples
09:18:45 <cocon> what's wrong with sizeOf = sizeOf (0 :: Int) * length x
09:19:01 <mauke> it evaluates x
09:19:13 <cocon> so?
09:19:35 <mauke> you can't do that
09:19:43 <mauke> sizeof (undefined :: T) must work
09:20:03 <Saizan_> haskellnoob: i think you've to make power_mod tail recursive
09:20:11 <dolio> The argument to sizeOf is a dummy. It just specifies the type.
09:20:21 <cocon> I see :(
09:20:28 <dolio> And all elements of a storable type are supposed to have the same size.
09:20:42 <mauke> this is for interfacing with C, after all
09:21:46 <haskellnoob> Saizan_: Thanks, let me check that.
09:22:12 <Saizan_> @wiki Stack overflow
09:22:12 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
09:22:55 <Saizan_> i suggest that wiki page to anyone that needs to deal stack overflows :)
09:23:41 <haskellnoob> Saizan_: thanks!!
09:24:13 <hackagebot> bytestring 0.9.1.5 - Fast, packed, strict and lazy byte arrays with a list interface (DuncanCoutts)
09:24:26 <ilid> > unlines.map(show.length.filter(=="***").(>>=words)).groupBy(>).init.lines$"-----\n * \n***\n * \n-----\n\n\n-----\n *   * \n*** ***\n *   *\n-----"
09:24:27 <lambdabot>   "1\n0\n2\n"
09:25:19 <Saizan_> haskellnoob: it's in the context of folds, but the same applies to other functions of similar structure
09:26:34 <jesmon> In the chapter 5 excercises from Programming in Haskell, there is a question about rewriting a list comprehension containing two generators as two comprehensions containing one generator each. My solution is: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10433 (sorry for the multiple revisions, I should use 'preview'...). I'm thinking there has to be a simpler solution. Can anyone comment?
09:27:10 <mauke> > [(x,y) | x <- [1,2,3], y <- [4,5,6]]
09:27:11 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:27:56 <Berengal> > concat [[(x,y) | y <- [4,5,6]] | x <- [1,2,3]]
09:27:57 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:28:05 <Makoryu> haskellnoob: It's worth learning about folds, by the way, because a lot of functions that operate on lists can be expressed in terms of folds, and folds are a well documented combinator
09:28:53 <Berengal> Oooo, I think I see where this excercise is going!
09:29:23 <jesmon> Berengal: I thought there must be something as short as that :)
09:29:28 <mauke> > [ q | p <- [[(x,y) | y <- [4,5,6]] | x <- [1,2,3]], q <- p ]
09:29:29 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:29:46 <Berengal> jesmon, I haven't read the book, but if what comes next is what I think it is, then have fun :)
09:30:20 <jesmon> Berengal: umm, what do you think might be coming next??
09:30:44 <Berengal> concatMap
09:30:51 <Berengal> Amongst other things
09:31:04 <Berengal> I wouldn't want to spoil it for you
09:31:17 <jesmon> ok, thanks :)
09:32:30 <Berengal> > concatMap (\x -> [(x,y) | y <- [4,5,6]) [1,2,3]
09:32:31 <lambdabot>   <no location info>: parse error on input `)'
09:32:39 <Berengal> > concatMap (\x -> [(x,y) | y <- [4,5,6]]) [1,2,3]
09:32:39 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:33:44 <Berengal> > concatMap (\x -> concatMap (\y -> (x,y)) [4,5,6]) [1,2,3]
09:33:45 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(a, a1)'
09:34:01 <Berengal> > concatMap (\x -> concatMap (\y -> [(x,y)]) [4,5,6]) [1,2,3]
09:34:06 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
09:35:02 <paulvisschers> In Parsec: is there a nice way to merge two parsers together?
09:35:13 <Berengal> paulvisschers, merge how?
09:35:43 <paulvisschers> I have a lexer that goes from string to [Token], and then another parser that goes from [Token] to Expression
09:36:10 <Berengal> >>=
09:36:14 <paulvisschers> I want those to run together, so that the second parser will have position data in case of an error
09:37:04 <Berengal> Or <=<
09:37:08 <Berengal> @type (<=<)
09:37:08 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:37:35 <paulvisschers> But the parsers don't have there input type defined like this, they have a typeclass for that
09:37:44 <Berengal> Ah, true
09:38:10 <Berengal> You'll have to run them in sequence
09:38:29 <paulvisschers> I can run them, and then use monads to run one first and then the other, but I think that will make me lose the positional data
09:38:41 <Berengal> That is, let inputTokens = runParser tokenParser inputString in runParser expressionParser inputTokens
09:39:09 <Berengal> I think you'll have to tag your tokens with positional data then
09:39:36 <paulvisschers> That's kind of what I wanted to avoid though :(
09:41:02 <Berengal> You need to store the positional data somewhere, and the expression parser doesn't know anything about any string input
09:41:38 <Berengal> You could rewrite it to parse strings instead of tokens, but frankly that seems like a bad idea
09:42:21 <Berengal> Adding positional data to your tokens shouldn't be too hard though
09:49:53 <olsner> hmm, in the .hs file generated by c2hs, "ORIGNAL" is misspelled in the message saying you should edit the original file ... is this worth a bug report? :)
09:50:33 <Berengal> Can't hurt
09:51:11 <Botje> the GHC devs are liable to fix your tiny bug and totally rewrite the compilation system while they're t it
09:51:43 <ddarius> olsner: Why don't you supply a patch?
09:53:33 <burp> you surely will be mentioned in the contributers file ;-)
09:55:09 <cocon> why does an Int need two words on the heap?
09:56:04 <shepheb> perhaps it was a thunk? iirc thunks are 64 bits on 32-bit machines.
09:57:07 <c_wraith> cocon: If it was a boxed Int, that makes sense.  Were you unboxing manually?
10:03:23 <paulvisschers> Berengal: Thanks btw
10:27:24 <olsner> hmm, how can I use c2hs to generate dynamic imports of function pointers?
10:30:04 <deech> Hi all, can I ask a question here about Haskell's SuperCollider bindings or is there a better forum?
10:31:45 <arsenm> olsner: I think you need to use the ffi directly for function pointers
10:34:29 <olsner> arsenm: that'd be ... irksome
10:35:12 <Berengal> Hmm.. Is reparsing bad in polyparse?
10:35:50 <Berengal> I assume not, since it's just prepending a string
10:35:58 <Berengal> There should be a way to get the remaining string though...
10:36:03 <olsner> actually, it looks like c2hs is capable of generating the code (at least there is code for printing dynamic imports), but I'm not sure how to write my hook so that it gets invoked
10:39:20 <bitstream0101> so i'm struggling with converting this large recursive make project to cabal, and wanted to chat about some ideas.
10:39:36 <dcoutts> bitstream0101: ok
10:39:50 * ddarius brushes the rust off his banjo playing.
10:39:54 <bitstream0101> i have to build a number of custom preprocessors that are used by later build steps
10:40:08 <vegai> ~
10:40:30 <Berengal> ... as in generate code-generators to generate more code?
10:40:30 <bitstream0101> that part is working ok, but there doesn't seem to be a way to hook into those later build steps that would use those custom preprocessors
10:40:38 <bitstream0101> Berengal: Yeah
10:40:42 <Berengal> Sounds fun
10:41:32 <bitstream0101> if there were a hook that was invoked on a per-exec/per-library basis, i could ensure that my custom preprocessors have been built, and invoke them, but the pre-build hook is invoked only once at the top level
10:41:46 <monochrom> "I write the code to write even more code, I write the code so your mind will boggle"
10:42:29 <bitstream0101> even assuming i split the build into flag-driven stages (which i'd prefer not to do, of course), i think i will encounter some problems with the default preprocessors where i need to do "non standard" things
10:42:30 <monochrom> "I write the code, it writes more code"
10:42:49 <bitstream0101> e.g., i have a .lhs file that contains valid haskell bits but the non-literate stuff forms an input to one of the custom code generators
10:43:25 <dcoutts> bitstream0101: you can override the default pre-processors I think
10:44:17 <bitstream0101> dcoutts: right, the problem is that i need to override, check the .lhs according to some rule, and be able to fallback on the default preproc action for any .lhs files that i don't care about
10:44:40 <dcoutts> bitstream0101: then your override one will have to call the standard one to do the normal thing
10:44:42 <bitstream0101> this works easily enough for things in knownSuffixHandlers, but .lhs handlers aren't in there
10:45:24 <dcoutts> bitstream0101: oh, mm, I guess we consider .lhs as fully-preprocessed, since the compilers are required to be able to handle it natively.
10:45:32 <bitstream0101> right :(
10:45:34 <bitstream0101> dcoutts: the other problem here, i think, is that i don't have a good way to ensure that some of the custom preprocessors get invoked.
10:45:47 <bitstream0101> which works just fine when i have an alex input that maps to one .hs post-alex execution
10:45:55 <bitstream0101> but not when i have arbitrary recursive make-like things going on
10:46:02 <dcoutts> bitstream0101: I suggest you use a different extension, like .lhs.your-custom-pp
10:46:20 <bitstream0101> e.g., i end up with a Foo.hs but only after a long sequence of actions
10:46:39 <dcoutts> bitstream0101: since it obviously isn't just a normal .lhs file if it needs to be run through a pre-processor that adds in extra Haskell code
10:47:04 <bitstream0101> dcoutts: no, it is a normal .lhs file, the problem is how we are using the non-haskell pieces as inputs to other tools
10:47:17 <bitstream0101> the .lhs basically has grammar generator input for some custom tools & corresponding haskell code
10:47:54 <bitstream0101> so the .lhs gets compiled by ghc -and- the make does something like grep -v "^>" foo.lhs > foo.bnf
10:48:01 <dcoutts> bitstream0101: so the pre-processor is not generating foo.hs from foo.lhs, but something-else.hs from foo.lhs ?
10:48:05 <bitstream0101> (which is really a .ebnf)
10:48:51 <bitstream0101> dcoutts: actually it goes: foo.lhs -> foo.bnf -> foo.custom_grammar -> (handful of haskell files) =/
10:49:25 <dcoutts> bitstream0101: ok, and the foo.lhs gets compiled directly
10:49:26 <bitstream0101> i decided that i might just try running all of this stuff in a pre-build step
10:49:31 <bitstream0101> right, dcoutts
10:49:45 <bitstream0101> but i can't do that in this particular case, because the pre-build runs before all of these custom preproccesors are built
10:49:50 <dcoutts> bitstream0101: ok, so it sounds like pretending that the .lhs needs a pre-processor isn't right
10:50:11 <dcoutts> bitstream0101: it's the "(handful of haskell files)" that needs a pre-processor, which happens to get info from that .lhs file
10:50:24 <bitstream0101> dcoutts: yeah, that makes sense
10:50:39 <bitstream0101> (info from that .lhs file and other output from a couple of other tools)
10:51:06 <bitstream0101> dcoutts: is there any way to have a pre-build step on a per-library/per-executable basis? i didn't see anything like that
10:51:13 <dcoutts> bitstream0101: no
10:51:18 <bitstream0101> bummer :(
10:51:44 <dcoutts> bitstream0101: why can't you do it for the whole package?
10:52:02 <bitstream0101> dcoutts: because the custom preprocessors are built as a part of the package
10:52:16 <bitstream0101> cabal file goes: executable t1, executable t2, executable t3 that needs a bunch of stuff generated by t1/t2
10:52:32 <bitstream0101> the pre-build hook as it stands now will execute before t1 and t2 have been built
10:52:40 <dcoutts> bitstream0101: right
10:52:51 <bitstream0101> i could alternately split all of that out into a separate cabal file, or use flag-based stages, but i'm attempting to avoid that
10:53:00 <dcoutts> bitstream0101: so how do you discover the names of the modules in exe t3?
10:53:19 <bitstream0101> dcoutts: that's another part that isn't working yet ;P
10:53:33 <bitstream0101> well, that part shouldn't be too hard, as the module names are fixed
10:53:46 <bitstream0101> (but the .hs is only generated for them after the multiple steps described above)
10:53:48 <dcoutts> bitstream0101: since if you know those, you can put them in the package description either in the original text or programatically
10:54:12 <bitstream0101> they can go into the package description, i think, in the other-modules section for t3
10:54:22 <dcoutts> bitstream0101: ideally it'd just be done by chasing extensions
10:54:27 <int-e> Hmm, has anybody built cabal-install with ghc-6.12? I get odd behaviour from Cabal. (most interesting so far, Setup.hs: At least the following dependencies are missing: base >1 && <1)
10:54:48 <benmachine> well that dependency would be missing wouldn't it :P
10:55:00 <dcoutts> int-e: no, because it doesn't compile yet, so I'm not sure what you've managed to get working :-)
10:55:24 <bitstream0101> dcoutts: how are dependencies on generated files (other-modules) tracked? if one of my preprocessors actually generates, say, 4 files, will the 1-1 dependency used by the existing preprocessor system work?
10:55:34 <int-e> dcoutts: "it" being ghc-6.12?
10:55:40 <dcoutts> int-e: no, cabal-install
10:55:49 <dcoutts> int-e: >1 && <1 is a canonical representation of an inconsistent constraint, we don't pretty print them like that now, since it's confusing.
10:56:14 <int-e> ah. I didn't know that, thanks.
10:57:16 <bitstream0101> dcoutts: so say i have foo.lhs_funky or something, that eventually results in 3-4 haskell files after custom preprocessors have been invoked (say, Foo, FooAux, and FooQC). would i list all of those on the other modules line?
10:57:17 <int-e> dcoutts: And I have /not/ managed to compile cabal-install, the configure step fails already.
10:57:26 <dcoutts> bitstream0101: mm, the problem will be that BlahGenerated.hs will be derived from Blah.my-custom-pp
10:57:47 <dcoutts> bitstream0101: and the built-in mechanism doesn't know about the BlahGenerated -> Blah thing
10:58:02 <dcoutts> bitstream0101: it only knows about Blah.one-extension -> Blah.another-extension
10:58:08 <bitstream0101> blech :(
10:59:17 <dcoutts> bitstream0101: this is all because the actual build system bit of cabal isn't terribly clever or sophisticated, no dep graph etc
10:59:28 <bitstream0101> well, if i list only one of the generated modules (for the 1-1 generation) on the other-modules line, but the other required modules get generated as a side effect of invoking that preprocessor, will those source files be seen as long as they are in the hs-source-dirs forest?
10:59:51 <bitstream0101> because i could perhaps write a preprocessor aggregator tool that just generates everything from the single input, i think
11:00:33 <dcoutts> bitstream0101: is there a representative module for each of these?
11:00:46 <bitstream0101> dcoutts: yeah, there can be if i rearrange some things
11:00:52 <dcoutts> bitstream0101: I mean you say it makes Foo.hs, FooAux.hs etc
11:00:56 <bitstream0101> it'd be representative module + extra cruft that still needs to be compiled
11:01:04 <dcoutts> bitstream0101: that might just work
11:01:15 <bitstream0101> dcoutts: it still feels a bit icky, though
11:01:20 <dcoutts> bitstream0101: since cabal does not check that the other-modules is complete
11:01:24 <dcoutts> bitstream0101: oh, totally
11:01:25 <bitstream0101> dcoutts: per-target pre-build hooks might help
11:01:35 <dcoutts> bitstream0101: no, doing it properly would help :-)
11:01:45 <bitstream0101> dcoutts: hehe
11:01:49 <dcoutts> bitstream0101: by which I mean, cabal having a proper dep-tracking build system
11:02:00 <bitstream0101> dcoutts: yeah i know what you meant.
11:02:00 <dcoutts> if only I had a spare month or two...
11:02:28 <bitstream0101> dcoutts: what about making it more explicit what was going on by using flag-based stages?
11:02:38 <bitstream0101> i mean, i could make someone building this use -fstage1 to build the tools
11:02:48 <dcoutts> bitstream0101: note that you will have trouble if you put a lib in the same package atm, because libs get built before exes.
11:02:51 <bitstream0101> and the pre-build step would not execute them until it witnessed the stage2 flag
11:03:09 <dcoutts> bitstream0101: I think that's probably worse
11:03:11 <bitstream0101> dcoutts: yeah, i'm fortunate in that there isn't a library being provided in this case
11:03:18 <int-e> dcoutts: Ah I see what's happening. I'm missing some packages that are required with base >= 3, so the solver sets old-base and Cabal looks for base < 3. And then it tells me in a roundabout way that it can't find that.
11:03:25 <int-e> sigh
11:03:31 <dcoutts> int-e: yep, exactly
11:04:04 <dcoutts> int-e: with the latest Cabal HEAD it'll at least give you the inconsistent constraints, without canonicalising them
11:04:43 <bitstream0101> dcoutts: alright, i'll try jury rigging the other-modules thing and make the custom preprocessor actually invoke -all- of the tools needed to generate the set of modules. we'll see how it goes :)
11:04:43 <dcoutts> bitstream0101: fortunately that is on the todo list, to allow full intra-package deps, expressed by build-depends and build-tools fields.
11:04:55 <dcoutts> bitstream0101: good luck :-)
11:05:01 <bitstream0101> dcoutts: thanks for your help =)
11:05:27 <dcoutts> bitstream0101: at some point your hack will all break when we do something properly in Cabal, but hopefully you'll not be too bitter about pulling out the hackery.
11:05:35 <bitstream0101> it's nice to be able to talk to package authors directly when stuff like this comes up ;)
11:05:40 <dcoutts> @arr!
11:05:41 <lambdabot> Aye
11:06:01 <bitstream0101> dcoutts: nah, that's fine -- if i can get this to work at -all- it will be vast improvement over the makefile nightmare that's already in use :P
11:06:22 <dcoutts> bitstream0101: two steps forward one step back :-)
11:06:41 <bitstream0101> dcoutts: hehe, yup.
11:07:08 <dcoutts> bitstream0101: when you're done, file a ticket in the Cabal track explaining the way this pre-processor works so we can keep it in mind for the future.
11:07:14 <dcoutts> track/trac
11:08:18 <dcoutts> bitstream0101: and ideally, a way that we could handle it automagically (eg using conventions) without requiring custom rules in each package using the pre-processor
11:10:21 <bitstream0101> dcoutts: good idea
11:11:02 <bitstream0101> dcoutts: i'll let you know how it all works out
11:11:04 <bitstream0101> cheers
11:32:38 <xenoblitz> hi people, I am trying to generate a list say 10 of tuples (from (1,1) to (1000,1000)) of randomly and then lift them to another monad, specificially the Render () monad for gtk2hs but I am a loss of where to start... any pointers would be appreciated
11:34:13 <gwern> :t fix
11:34:15 <lambdabot> forall a. (a -> a) -> a
11:34:16 <pikhq> :t join zip [1..1000]
11:34:17 <lambdabot> forall a. (Num a, Enum a) => [(a, a)]
11:34:30 <gwern> xenoblitz: something like 'take 10 $ cycle (let x = getRandom 1 1000 in (x,))'? the lifting is your problem
11:34:43 <gwern> ('x,x' obviously)
11:34:45 <pikhq> Oh, randomly. Never mind.
11:35:40 <gwern> :t cycle
11:35:41 <lambdabot> forall a. [a] -> [a]
11:35:52 <gwern> @hoogle a -> [a]
11:35:53 <lambdabot> Prelude repeat :: a -> [a]
11:35:53 <lambdabot> Data.List repeat :: a -> [a]
11:35:53 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
11:35:54 <Saizan_> > randomR ((1,1),(1000,1000)) (mkStdGen 42)
11:35:55 <lambdabot>   No instance for (System.Random.Random (t, t1))
11:35:55 <lambdabot>    arising from a use of `Sy...
11:36:09 <Saizan_> what's the point of cycle there?
11:36:37 <Saizan_> you want to create a list of 10 equal tuples?
11:36:48 <xenoblitz> Saizan: no randomly
11:36:53 <gwern> Saizan_: he wants 10 different random pairs, I take it; so we define a list and he can modify take as he needs it
11:37:06 <xenoblitz> as in (1,2) (110,20) (300,21) etc etc
11:37:15 <gwern> although I suppose it's a bit naive to expect getRandom to change each time
11:37:15 <Saizan_> gwern: but cycle doesn't make sense
11:37:42 <gwern> of course cycle doesn't make sense, that's why I looked for what had the right type sig; I mix fix/cycle/repeat up all the time
11:38:40 <Saizan_> xenoblitz: first define a function to generate a single random tuple
11:38:41 <Saizan_> xenoblitz: do you know how to work with System.Random?
11:38:41 <Saizan_> gwern: it wouldn't be pure
11:38:41 <Saizan_> gwern: unless you meant to do something like replicateM
11:38:41 <Saizan_> ?type replicateM
11:38:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:39:20 <xenoblitz> Saizan_: System.Random is not my favourite module
11:40:16 <Saizan_> ?type liftM2 (,) (randomRIO (1,1000)) (randomRIO (1,1000))
11:40:17 <lambdabot> forall a1 a2. (Num a1, Random a1, Num a2, Random a2) => IO (a1, a2)
11:40:27 <Saizan_> xenoblitz: that works in IO
11:40:43 <Saizan_> ?type replicateM 10 (liftM2 (,) (randomRIO (1,1000)) (randomRIO (1,1000)))
11:40:44 <lambdabot> forall a1 a2. (Num a1, Random a1, Num a2, Random a2) => IO [(a1, a2)]
11:40:57 <Saizan_> there you get the list
11:41:22 <Saizan_> to lift it to Render () you might use liftIO, if Render () is a MonadIO
11:41:40 <xenoblitz> Saizan_: I was attempting to do so yes
11:41:50 <xenoblitz> I will let you know how far I managed asap
11:44:47 <xenoblitz> Saizan: how is it possible to obtain the list of tuples from the IO monad in the Render monad? is liftIO really what I am looking for?
11:46:00 <xenoblitz>  Saizan_: I apologize but I am still messed up as far as monads go
11:46:36 <poiuy> how to print hexadecimal values in ghci: '0x0F :: Word64' shows 15, I would like to see 0x0F again.
11:47:04 <aavogt> > showsHex 15 ""
11:47:05 <lambdabot>   Not in scope: `showsHex'
11:47:17 <aavogt> @hoogle hex
11:47:18 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
11:47:18 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
11:47:18 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
11:47:23 <xenoblitz> Saizan: nevermind it has worked ;)
11:47:36 <burp> > showHex 15 ""
11:47:37 <xenoblitz> Saizan: honestly I don't know how you people whip up those functions so  quickly...
11:47:37 <lambdabot>   "f"
11:47:51 <xenoblitz> Saizan_: thanks
11:48:11 <mauke> > showHex 15 ""
11:48:12 <lambdabot>   "f"
11:48:40 <mauke> > ""++ printf "0x%02X" 15
11:48:40 <lambdabot>   "0x0F"
11:48:48 <Saizan_> xenoblitz: well, liftIO is made exactly for these situations
11:48:51 <Peaker> xenoblitz, After about a year of practice, I could whip up stuff that would make me go nuts a year earlier :)
11:48:51 <Saizan_> ?type liftIO
11:48:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:48:55 <aavogt> does anybody use cabal packages with hugs?
11:49:25 <aavogt> in particular, I'm trying to install wash: http://www.informatik.uni-freiburg.de/~thiemann/WASH/
11:49:51 <burp> :t printf
11:49:52 <lambdabot> forall r. (PrintfType r) => String -> r
11:50:19 <aavogt> but the runhugs -98 Setup.lhs calls a configure script which hangs at: checking version of hugs...
11:51:53 <xenoblitz> Peaker, Saizan: thank god for bots like you guys who give hope to guys like me xD
11:52:42 <JakeDust> could anyone please help me with a particular (a bit mathematical) problem? i've solved it in ruby, but i really have no clue about how to port it to haskell.
11:52:44 <chrisdone> :t flip id
11:52:45 <lambdabot> forall b c. b -> (b -> c) -> c
11:52:59 <c_wraith> :t flip ($)
11:53:00 <lambdabot> forall b b1. b -> (b -> b1) -> b1
11:53:23 <c_wraith> id is just a more general form of ($) :)
11:53:36 <dcoutts> aavogt: which package is that?
11:53:49 <dcoutts> aavogt: detecting the hugs version is notoriously difficult
11:53:56 <c_wraith> JakeDust: go ahead and ask
11:54:01 <chrisdone> :t ($)
11:54:02 <lambdabot> forall a b. (a -> b) -> a -> b
11:54:21 <poiuy> @burp @mauke thanks!
11:54:22 <lambdabot> Maybe you meant: bug url
11:54:58 <benmachine> maybe you didn't
11:55:40 <chrisdone> :t const . ($)
11:55:42 <lambdabot> forall b a b1. (a -> b1) -> b -> a -> b1
11:56:21 <burp> poiuy: not to forget aavogt who had just an "s" too much ;)
11:56:56 <JakeDust> c_wraith: i have the sequence 1, 3, 7, 12, 18, 26, 35, 45, 56, 69..., and i'm trying to create a list in haskell for it and another for all the natural numbers that aren't members of this sequence. i've implemented this in ruby in here http://pastebin.ca/1592882
11:57:15 <gwern> > 3.5 * 7.25
11:57:16 <lambdabot>   25.375
11:57:40 <chrisdone> gwern: annanumbergram?
11:57:47 <gwern> what?
11:57:57 <chrisdone> nothing …_…
11:59:10 <chrisdone> what's the latest cool haskell talk knocking about?
12:00:34 <gwern> > 1.20 / 25.38
12:00:35 <lambdabot>   4.728132387706856e-2
12:00:42 <gwern> > (1.20 / 25.38) * 100
12:00:43 <lambdabot>   4.7281323877068555
12:00:56 <int-e> > scanl (+) 0 [n | n <- [1..], n `mod` 4 /= 3]
12:00:57 <lambdabot>   [0,1,3,7,12,18,26,35,45,57,70,84,100,117,135,155,176,198,222,247,273,301,33...
12:00:57 <ddarius> > let others xs = others' xs 0 where others' (x:xs) n | x == n = others' xs (succ n) | otherwise = n:others' (x:xs) (succ n) in others' [1,3..]
12:00:58 <lambdabot>   Not in scope: `others''
12:01:02 <byorgey_> JakeDust: how is the sequence defined?
12:01:03 <ddarius> > let others xs = others' xs 0 where others' (x:xs) n | x == n = others' xs (succ n) | otherwise = n:others' (x:xs) (succ n) in others [1,3..]
12:01:04 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
12:01:06 <gwern> > (25.38 / 1.20)
12:01:08 <lambdabot>   21.15
12:01:12 <byorgey_> mathematically speaking?
12:01:23 <c_wraith> JakeDust: What's a description of the sequence?
12:01:32 <mauke> @oeis 1, 3, 7, 12, 18, 26, 35, 45
12:01:33 <lambdabot>  Sequence and first differences (A030124) include all numbers exactly once.
12:01:33 <lambdabot>  [1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260,285,312,34...
12:01:46 <aavogt> dcoutts: it is WashNGo  (version 2.12 of 20070725)
12:02:03 <mauke> ah, I see
12:02:11 <byorgey_> ah, interesting
12:02:27 <JakeDust> well, yeah, that's the sequence.
12:03:10 <ddarius> > let others = concatMap (uncurry (liftM2 enumFromTo succ pred)) . ap zip tail in others [1,3..]
12:03:11 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a1]'
12:03:12 <dcoutts> aavogt: so it'll probably be doing the wrong thing for the hugs version check and hugs is sitting there waiting for input.
12:03:36 <aavogt> I got it to install by changing the Setup.lhs to run defaultMain instaed
12:03:37 <burp> > extendSequence [1,3,7,12,18]
12:03:38 <lambdabot>   [1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260,285,312,3...
12:03:47 <dcoutts> aavogt: hugs has no --version flag, so you have to start it up interactively and look for certain strings in the output, it's easy to get that wrong.
12:03:52 <burp> oeis is awesome ;)
12:03:56 <dcoutts> aavogt: ok good
12:04:11 <ddarius> :t liftM2 enumFromTo succ pred
12:04:12 <lambdabot> forall a1. (Enum a1) => a1 -> [a1]
12:04:20 <JakeDust> c_wraith and byorgey: i don't really have a description. i have the sequence, and tried to find its logic and create a code for it in haskell as an exercise
12:04:52 <JakeDust> in ruby was easy, but i'm not good enough in haskell to solve it
12:05:00 <ddarius> > let others = concatMap (uncurry enumFromTo . succ *** pred)) . ap zip tail in others [1,3..]
12:05:01 <lambdabot>   <no location info>: parse error on input `)'
12:05:07 <ddarius> > let others = concatMap (uncurry enumFromTo . succ *** pred) . ap zip tail in others [1,3..]
12:05:08 <lambdabot>   Couldn't match expected type `[b]'
12:05:09 <lambdabot>         against inferred type `([a], b')'
12:05:24 <ddarius> > let others = concatMap (uncurry enumFromTo . (succ *** pred)) . ap zip tail in others [1,3..] -- last try
12:05:25 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
12:06:15 <aabbcc> what's the proper way to have multiple let declarations when using tabs and not spaces?
12:06:15 <Berengal> JakeDust, you need a sortedDifference function, that traverses both lists in parallell, only advancing the one with the lowest head (both if the heads are equal), and emits elements of the first that aren't in the second
12:06:24 <ddarius> others assumes that the input sequence is monotonically increasing.
12:06:45 <mauke> aabbcc: start a new line after 'let'
12:06:49 <byorgey> aabbcc: the proper way is to not use tabs.
12:08:03 <aabbcc> i don't like automatically replacing tabs with spaces because i would have to backspace several times instead of once
12:08:14 <aabbcc> but where do i put the 'let' and 'in'?
12:08:16 <Berengal> aabbcc, get a better editor
12:08:22 <aabbcc> i use vim
12:08:39 <Berengal> Or fix the one you've got...
12:08:53 <mauke> aabbcc: :set et sw=4 sts=4
12:09:10 <mauke> also learn about ^D and ^T
12:09:53 <JakeDust> Berengal: Okay, i'll try to understand and write it. I thought there was a prettier solution in haskell than in ruby, but i see it'll take some time for me to find it, haha
12:10:17 * Baughn abuses Typeable for fun and profit. Say, how come most of the ghc-supplied types lack module specifiers?
12:10:32 <byorgey> JakeDust: there probably is, but it will likely be sneaky =)
12:10:40 <Berengal> JakeDust, it's not that hard. Just pattern match on the lists and use guards
12:10:47 <monadic_kid> opinions would be much appericated: http://www.reddit.com/r/haskell/comments/9qo7e/advice_on_naming_conventions_for_lots_of_c_enums/
12:10:49 <byorgey> JakeDust: since you have to lazily construct both lists using mutual recursion, instead of just relying on mutation
12:13:08 <ilid> monadic_kid: my view is that name prefixes are ugly, and point to a language problem (i'm looking at you, record selectors...). haskell's namespace support is modules, so that's what i'd use.
12:13:10 <JakeDust> thank you all, i going to study a bit more of haskell and try to write it
12:13:51 * Baughn is very annoyed that DisambiguateRecordFields doesn't work if the Record Fields are defined in the same module
12:14:43 <monadic_kid> ilid: yes ideally i would avoid prefixing but then should split a single COM interface into grouped nested modules?
12:15:06 <ilid> monadic_kid: group the interfaces however you like. import the enum module into modules which use it.
12:16:04 <monadic_kid> ilid: you mean put the enums into there modules and not worry about grouping interface functions?
12:16:19 <aabbcc> is this the normal way to arrange code without replacing tabs with spaces: http://codepad.org/GQcaTp9T ?
12:16:25 <ilid> monadic_kid: group interface functions in whatever way pleases you aesthetically :)
12:16:41 <c_wraith> I had more trouble writing sortedDifference than I expected to.  I'm starting to suck at this "programming" thing, I think. >_>
12:18:01 <ilid> monadic_kid: i'd probably have a module for each enum, named after the enum, then import Foo.Bar.Enum1(Enum1), import qualified Foo.Bar.Enum1 as Enum1 in code which used that Enum.
12:18:42 <ilid> possibly even just import Foo.Bar.Enum1 as Enum1
12:19:13 <monadic_kid> there are a lot of enums, some of them could easilly be grouped together
12:20:26 <byorgey> aabbcc: that ought to work, although there is no "normal way without replacing tabs with spaces", because no one uses tabs =)
12:20:36 <ilid> you can group them heirarchically
12:20:47 <aabbcc> i thought most people used tabs, at least outside of haskell
12:21:04 <ilid> aabbcc: the trouble with tabs is they're very hard to use 'correctly'
12:21:06 <byorgey> I meant in Haskell.
12:21:17 <JakeDust> c_wraith: Nah, you can still write some code, i'm killing myself just to write something, and i only started to try to learn haskell because it seemed more math-friendly than almost every language i've met, and now i'm here spending more time with haskell than with math
12:21:17 <ilid> (not just in haskell...)
12:21:22 <byorgey> because Haskell uses *alignment* not *indentation*
12:22:27 <c_wraith> JakeDust:  Thinking in terms of mutually-recursive infinite lists takes some effort.  Heck.  Thinking of lists as functions, rather than data, takes a bit of a viewpoint switch
12:22:49 <aabbcc> does anyone else here hate spaces and would rather have tabs?
12:23:17 <kynky> i prefer spaces
12:23:22 <c_wraith> aabbcc: No.  Tabs are evil.  Spaces are much more predictable.
12:23:52 <ilid> aabbcc: i prefer tabs, but only when used correctly. practically this means i use tabs in non-haskell code which only i work on, and spaces on shared code :-/
12:23:52 <Makoryu> aabbcc: Tabs only make sense in editors that don't properly support soft tabs.
12:23:53 <mauke> aabbcc: I write "tab compliant" code, but still using spaces
12:23:55 <JakeDust> c_wraith: yeah, that's why i switched to haskell, i think it's a more interesting viewpoint
12:24:04 <mauke> Makoryu: I disagree
12:24:27 <Makoryu> mauke: ...Or in languages where a tab is actually required.
12:24:38 <mauke> I still disagree
12:25:15 <aabbcc> i really hate how in cabal you absolutely have to use spaces, and not tabs
12:25:37 <thoughtpolice> you can use tabs, you just cannot mix them at all
12:25:40 <FunctorSal> ilid: how do you use tabs 'correctly'?
12:25:42 <ilid> Makoryu: editors with soft tabs can't show code with the tab width I want
12:25:58 <dcoutts> aabbcc: the syntax is sensitive to the layout, so it's a bit crazy to use tabs
12:26:04 <ilid> FunctorSal: tabs only at the start of the line, and tabs only for indentation and not for alignment
12:26:17 <Makoryu> ilid: This is true
12:27:16 <c_wraith> JakeDust:  Want to see my sortedDifference implementation, or would you rather work on it yourself?
12:27:33 <ilid> FunctorSal: basically those are the natural consequences of "the code should look right no matter what the tab width is set to"
12:27:49 <Baughn> Does Typeable guarantee that (Typeable a, Typeable b) => typeOf a /= typeOf b implies that show (typeOf a) /= show (typeOf b)?
12:27:49 <dcoutts> aabbcc: afaiks, the only sane alternative is to allow tabs if they are always used consistently, which is a lot harder to check for
12:28:53 <aabbcc> hmm, i use tabs consistently
12:28:56 <kynky> so is a tab 8 spaces long, 4 spaces long, i get confused, i know they can be n spaces long, but i see it being 8 quite often
12:29:05 <aabbcc> any way to convert 4 spaces to a tab?
12:29:32 <mauke> hmm/
12:29:34 <Makoryu> aabbcc: In which editor?
12:29:45 <aabbcc> vim
12:29:54 <mauke> :%s/    /\t/g
12:30:26 <ilid> kynky: the width of a tab depends on the editor. as does whether they go to the next multiple of that width or indent by that many characters :) as does whether the width has to be an integer
12:30:27 <Makoryu> aabbcc: Or, :set noexpandtab tabstop=4 | retab
12:30:54 <FunctorSal> hmm isn't what byorgey said a killer argument against tabs in haskell?
12:31:28 <FunctorSal> if I understand correctly...
12:31:39 <aabbcc> Makoryu: thanks
12:31:53 <kynky> sometimes i read stuff where it says if you use tabs, make sure they are 8 spaces long
12:32:00 <kynky> in programming
12:32:16 <mauke> if you use tabs and make sure they're 8 spaces, you might as well use 8 spaces instead
12:32:36 <FunctorSal> wait, now I'm confused again. does haskell layout only ever depend on whitespace at the beginning of teh line?
12:32:49 <mauke> FunctorSal: no
12:32:59 <kynky> choice
12:33:04 <aabbcc> i thought most people have it 4 spaces.. because if you have it 8 space you end up with code starting at the middle of the screen really quickly
12:33:06 <Makoryu> FunctorSal: Oh god, THAT'S what I forgot to put in my FAQ
12:33:24 <FunctorSal> D: what FAQ?
12:33:47 <Makoryu> FunctorSal: http://echo.rsmw.net/n00bfaq.html
12:34:30 <JakeDust> c_wraith: i'd like to see it, maybe i can already understand it
12:34:50 <Makoryu> FunctorSal: That, and typeclasses (and why they produce such goofy errors)
12:35:31 <c_wraith> JakeDust: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10440#a10440
12:35:39 <FunctorSal> "I rhyme “Haskell” with “ask Elle,”" hehe
12:36:04 <FunctorSal> mauke: example? :)
12:36:20 <Twey> FunctorSal: I thought this was a killer argument against tabs in any language: 20:31:14 < ilid> kynky: the width of a tab depends on the editor. as does whether they go to the next multiple of that width or  indent by that many characters :) as does whether the width has to be an integer
12:36:34 <Twey> FunctorSal: In which dialect?
12:36:52 <mauke> Twey: it's an argument for tabs
12:37:09 <FunctorSal> Twey: but semantic breakage seems worse
12:37:23 <c_wraith> JakeDust: One thing I didn't note in the comment is that it is intended to get infinite lists as input.  That should be fine for your use case
12:37:27 <Twey> mauke: Sure, if you hate the idea of your code ever aligning properly for anyone
12:37:43 <mauke> Twey: no
12:37:44 <Twey> Heck, even the good-style 80-chars limit becomes meaningless
12:37:47 <kynky> monospace fonts and spaces, no tabs for me
12:38:03 <mauke> Twey: if you use tabs right, it will align properly everywhere
12:38:15 <JakeDust> c_wraith: okay!
12:38:23 <Twey> mauke: *eyebrow*
12:38:37 <mauke> FunctorSal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10441#a10441
12:38:37 <SamB_XP> mauke: sure, if everyone else does too ...
12:38:50 <Twey> I believe that ‘using tabs right’ means ‘not using tabs for alignment’
12:39:03 <mauke> whoops, should have been x + y, but whatever
12:39:09 <kynky> what if you work on a project, say using a git/darcs epo, you use 8 spaces for tabs, and someone else uses 4 spaces fo tabs, and you lik to auto format alot
12:39:26 <Twey> I'm pretty sure that the combination of those variables makes it literally impossible for tabs to ever line up properly on all possible configurations
12:39:27 <SamB_XP> kynky: well, then you've got a problem
12:39:42 <mauke> Twey: no
12:39:52 <SamB_XP> you basically have to have a standard ...
12:39:58 <kynky> SamB_XP, its  stupid problem
12:40:07 <int-e> > fix((1:).(3:).scanl(+)7.drop 2.concat.ap(zipWith((.(-1+)).enumFromTo.(1+)))tail)
12:40:08 <Twey> mauke: So how do you define ‘using tabs right’?
12:40:08 <lambdabot>   [1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260,285,312,3...
12:40:12 <mauke> Twey: you just have to make sure that all tabs are either at the beginning of a line or immediately after another tab
12:40:21 <kynky> maybe define it in the file or maybe on a wiki somewhere or have a checkstyle file etc
12:40:22 <SamB_XP> kynky: precisely
12:40:25 <FunctorSal> mauke: D: you're right changing the relative indentation of the x and y by one will break it
12:40:31 <Makoryu> kynky: You don't work on a project with someone without setting an indentation standard.
12:40:44 <mauke> Twey: and treat tabs as incommensurable with spaces
12:41:03 <SamB_XP> mauke: still, tabs are not useful for indenting Haskell
12:41:06 <Twey> mauke: But that stops you from using them for alignment, because the characters on the line above do not expand with tab width variations
12:41:21 <mauke> Twey: right
12:41:22 <kynky> Makoryu, fair enough, but lots of ppl have diff coding styles a distributed projects are pretty common now, i guess the easiest (best) convention is not to use tabs
12:41:46 <mauke> to use tabs in haskell you have to write your code in a way that makes alignment == indentation
12:42:01 <Twey> mauke: So when you said ‘no’ to ‘I believe that “using tabs right” means “not using tabs for alignment”’, you actually meant ‘yes’ :þ
12:42:39 <FunctorSal> but mauke doesn't your example show that space is commensurable with letters (the 'let') in haskelle?
12:42:45 <mauke> Twey: I don't think I said "no" to that
12:42:45 <Twey> Sorry, hate to cut this short, but I have to move my computer
12:42:53 <mauke> FunctorSal: yes
12:43:00 <JakeDust> int-e: scary.
12:43:01 <FunctorSal> so that would make tabs bad...
12:43:08 <sereven> Twey: make sure to move it in correct increments!
12:43:45 <SamB_XP> sereven: no, moving it in increments would be far too stressful to the components
12:44:05 <sereven> see, tabs are even bad for moving computers. :-)
12:44:11 <SamB_XP> dirac delta velocities are extremely undesirable
12:45:32 <JakeDust> int-e: but it isn't running here in ghci, strange.
12:46:28 <int-e> JakeDust: you need Control.Monad.Instances for the (->) r Monad instance.
12:46:37 <kynky> tabs are unpredictable, and in my mind determination is good
12:47:14 <mauke> that's a bit like "variables are unpredictable, so I use literals everywhere"
12:47:55 <int-e> JakeDust: or Control.Monad.Reader which also exports ap and fix.
12:48:30 <SamB_XP> mauke: not very much like it
12:49:55 <SamB_XP> it's more like "In order to align two birdfeeders, it is nice to know the relative heights at which their posts are to be placed"
12:50:06 <coloc> hello
12:50:44 <___JN123> hello, is it possible to declare a binary instance of textbuffer? (gtk2hs question)
12:51:03 <dcoutts> ___JN123: no, because it could not be pure
12:51:25 <dcoutts> ___JN123: however it is strightforward to get the current text out of a gtk textbuffer and serialise it
12:51:34 <dcoutts> and likewise the inverse
12:51:53 <___JN123> yes, but I need the pixbuffers too
12:52:12 <ddarius> How am I supposed to feel if I refer someone to a paper they coauthored?
12:52:26 <dcoutts> ___JN123: then you'll need to do a more complex traversal over the buffer contents
12:52:33 <c_wraith> ddarius: amused or very sad
12:53:53 <coloc> I would need some help/pointers... I messed up something with cabal, perhaps by updating it, and it tries to upgrade everything to too recent versions (like base-4.*)... how can I 'downgrade'?
12:54:09 <dv-> :t (a :)
12:54:10 <lambdabot> [Expr] -> [Expr]
12:54:24 <dcoutts> coloc: what are you trying to downgrade?
12:56:12 <coloc> not exactly downgrade, but cabal is proposing me too recent versions of packages (things depending on base-4.*) that it can't install (due to my ghc-6.8.2 etc..)
12:56:44 <dcoutts> coloc: you can say --constraint='base < 4'
12:57:29 <dcoutts> coloc: honestly, it's not handled very well, there's a ticket on this. We should start by excluding all the later versions of packages that you cannot possibly install because they depend on things you cannot install.
12:58:04 <coloc> mmh, yeah...
12:59:22 <coloc> now, for example I was trying to install yi, but even by fixing an older version (0.4) it still tries too recent version of other packages...
13:00:00 <dcoutts> coloc: right, you can workaround it using more --constraint flags, but I appreciate it's not a good solution.
13:00:33 <dcoutts> I can point you to the cabal ticket if you're interested in solving it properly
13:01:12 <coloc> so I must put a constraint on each individual package? (I tried with --constraint='base < 4' and it still proposes me vty-4.0.0.1, ahum..)
13:01:31 <coloc> yea dcoutts, i would be interested in this ticket :)
13:01:38 <coloc> thanks a lot :)
13:02:18 <dcoutts> coloc: http://hackage.haskell.org/trac/hackage/ticket/420
13:03:27 <dcoutts> coloc: so it means making a change to the cabal-install constraint solver, to add an extra initial pass.
13:04:00 <dcoutts> as it says in the ticket, we'd to a bottom up (in the sense of dependencies) traversal of the available packages
13:04:20 <dcoutts> and remove ones that depend on packages that do not exist
13:04:50 <dcoutts> do not exist / unsatisfiable version constraints
13:05:36 <coloc> yeah, I see
13:05:39 <dcoutts> it has to be bottom up so that when we've got A-1 deps on B-1 deps on base-4, then we delete B-1 because there is no available base-4
13:05:52 <dcoutts> and then because B-1 isn't available we go on to remove A-1
13:08:19 <coloc> but this workaround doesn't seem to work properly, either I'm messing with the syntax..
13:09:34 <dcoutts> coloc: the package name in --constraint is case sensitive
13:10:17 <coloc> I'm writing:cabal install yi-0.4 --constraint='vty<4', and It still wants to configure vty-4.0.0.1
13:11:22 <dcoutts> coloc: what version of cabal is that?
13:11:22 <Cale> http://uncyclopedia.wikia.com/wiki/Objectivist_C -- ahaha
13:11:37 <coloc> anyway, I'll look closer at the syntax of constraint in the doc
13:11:50 <dcoutts> coloc: that's the right syntax.
13:12:29 <coloc> cabal-install is 0.6.0, and Cabal is 1.6.0.1
13:12:49 <dcoutts> coloc: ok, it works for me with ghc-6.8.2 and cabal-install 0.6.2
13:12:57 <dcoutts> cabal install -w ghc-6.8.2 yi-0.4 --constraint='vty<4' --dry
13:13:43 <coloc> (if i try to update cabal-install, the build fails on the network package...)
13:15:02 <Cale> "Unlike C, Objectivist C does not require the programmer to keep track of memory allocation and deallocation; instead, objects in memory allocate and deallocate memory themselves according to their rational self-interest."
13:15:19 <dcoutts> coloc: try to persuade it to use the current network package, --dry-run -v is helpful here
13:15:27 <coloc> yeah, your command fails for me with my version of cabal-insatll
13:16:10 <c_wraith> Where's that from, Cale?
13:16:28 <dcoutts> Cale: that's nice :-)
13:17:53 <coloc> ok thanks a lot dcoutts, I'll eat, and I'll start persuading :)
13:18:03 <dcoutts> coloc: if necessary you can just bludgeon it by getting the cabal-install-0.6.2 source package and using the old runghc Setup method
13:18:47 <coloc> ok
13:19:04 <Makoryu> Cale: That's brilliant
13:19:07 <Makoryu> Also
13:19:26 <coloc> but I'd like to have a better grasp on using cabal
13:19:38 <Makoryu> http://echo.rsmw.net/n00bfaq.html <- Is this CSS horrendous? Any recommendations for a (preferably drop-in) replacement?
13:20:11 <coloc> thanks a lot, i'll be back if i still have problems ^^'
13:20:17 <dcoutts> coloc: ok :-)
13:44:15 <ddarius> Makoryu: There are actually statements in Haskell (just less of them and different ones from normal imperative languages).
13:44:52 <SamB_XP> I really wish those things were called something else :-(
13:45:33 <Athas`> ddarius: what does "statement" denote in Haskell?
13:45:44 <Makoryu> ddarius: Like case? Or import?
13:45:52 <FunctorSal> I think the lines of a do block
13:46:18 <SamB_XP> yeah, at least if you believe the AST types used by most parsers ;-)
13:46:29 <dolio> , 1 + (case 5 of n -> n + 1)
13:46:30 <Makoryu> FunctorSal: No.
13:46:31 <lunabot>  7
13:46:33 <FunctorSal> yes that's my source SamB_XP
13:46:44 <Athas> The Report mentions an "empty statement" for the do expression syntax, at least.
13:47:00 <Athas> That fits the meaning in imperative languages too.
13:47:00 <Makoryu> Athas: ....shit.
13:47:04 <SamB_XP> Athas: a what ?
13:47:15 <ddarius> Indeed.  A do-block (and also list comprehensions) consists of a sequence of statements.  There are only two statements that aren't just inclusions of other syntactic categories (namely expressions).  x <- m and let x = y.
13:47:17 <Makoryu> @undo do foo;; bar
13:47:18 <lambdabot> foo >> bar
13:47:21 <FunctorSal> , src ''Stmt
13:47:24 <lunabot>  data Stmt = BindS Pat Exp
13:47:24 <lunabot>            | LetS ([Dec])
13:47:24 <lunabot>            | NoBindS Exp
13:47:46 <ddarius> @undo do {}
13:47:46 <lambdabot>  Parse error at "}" (column 5)
13:48:23 <FunctorSal> , [| do { x <- 1; [x] } |]
13:48:23 <dolio> , do {}
13:48:25 <lunabot>  luna: Empty 'do' construct
13:48:26 <lunabot>  DoE [BindS (VarP x_0) (LitE (IntegerL 1)),NoBindS (ListE [VarE x_0])]
13:49:19 <SamB_XP> Athas: *What* does it *say* about this "empty statement"?
13:49:34 <ddarius> , [| [x | x <- y, let z = y] |]
13:49:35 <lunabot>  luna: Couldn't match expected type `[t]'
13:49:48 <Athas> SamB_XP: nothing interesting, but it's the only place I could find where the Report mentions something called a "statement".
13:49:52 <Athas> I didn't look very closely, though.
13:49:55 <Berengal> SamB_XP, I might remember wrong, but it's the same as the empty expression
13:49:56 <ddarius> , [| [x | x <- undefined, let z = x] |]
13:49:57 <lunabot>  CompE [BindS (VarP x_0) (VarE undefined),LetS [ValD (VarP z_1) (NormalB (...
13:50:02 <SamB_XP> Berengal: the what ?
13:50:08 <SamB_XP> , src id
13:50:09 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
13:50:15 <SamB_XP> , src 'id
13:50:17 <lunabot>  id :: forall a . a -> a
13:50:34 <SamB_XP> awwwww
13:50:42 <Berengal> SamB_XP, it only exists in the syntax.
13:50:55 <Makoryu> @src asTypeOf
13:50:56 <lambdabot> asTypeOf = const
13:50:57 <dolio> It's a nicer inductive base case.
13:51:06 <SamB_XP> dolio: what ?
13:51:13 <dolio> Empty statements/expressions.
13:51:30 <Berengal> do *empty* -> *empty*
13:51:30 <dolio> Instead of saying "Statements are either a bunch of stuff, or statements with a bunch of stuff appended..."
13:51:54 <dolio> You say, "Statements are either empty, or a bunch of stuff appended to a statement."
13:52:06 <dolio> That way you only need to list the bunch of things once.
13:54:12 <Berengal> do {*expr*; *rest*} -> *expr* >> do {*rest*}; do {*p* <- *expr*; *rest*} -> *expr* >>= \*p* -> do {*rest*}; do {let *bindings*; *rest*} -> let *bindings* in do {*rest*}
13:54:19 <Berengal> And finally, do {} -> *empty*
13:54:27 <FunctorSal> * tends to cause more parser ambiguities than + in my limited experience though
13:55:07 <FunctorSal> (and I still can't get happy's glr-mode to compile)
13:56:00 <dolio> Yeah, it's probably not nicer from a parser ambiguity perspective.
13:56:13 <dolio> But it's nicer from a language-definition-page-count perspective.
13:56:19 <FunctorSal> :)
13:57:34 <Berengal> do statements are only statements in the syntax though. There's only expressions at the semantic level
13:58:10 <FunctorSal> at the top levels there are only class/instance/value decls
13:58:23 <Makoryu> Berengal: Yeah. That was my whole point with the Statements vs. Expressions section.
13:58:25 <FunctorSal> and something I forgot, like infix
13:58:29 <Makoryu> (In http://echo.rsmw.net/n00bfaq.html)
13:58:41 <Makoryu> FunctorSal: infixl/infixr
13:58:46 <Berengal> And if you considered '<-' to be a "line" separator, then there'd only be expressions in do as well
13:58:58 <Makoryu> The one nobody seems to ever remember is default
13:59:09 <FunctorSal> hehe
13:59:45 <FunctorSal> every language needs an obscure statement like that for corner case games
14:00:08 <Berengal> Makoryu, nice, a syntax tutorial. More languages should have those
14:00:36 <Makoryu> Berengal: Not really a tutorial. Literally a FAQ (in progress) based on questions people ask here all the time
14:01:17 <FunctorSal> so does anyone think you could reasonably visualize sauce with graphviz?
14:01:22 <Berengal> Makoryu, still, I've struggled with the syntax of every language I've learned, even when I already know a language with familiar syntax... Except lisp
14:01:54 <SamB_XP> Berengal: hehehe
14:01:58 <FunctorSal> I'm not sure how to handle application... an extra "app" node seems ugly
14:02:05 <SamB_XP> I find the syntax of lisp pretty tough, actually
14:03:07 <Makoryu> Berengal: Yeah. Some of this is also my own memories of "omg wtf is this symbol" moments while reading through Haskell source code :p
14:03:19 <FunctorSal> paging Peaker
14:03:30 <Berengal> SamB_XP, It might not be nice, but it's simple. There's atoms, lists, quotes and unquotes, a few other minor and largely unimportant characters that can safely be ignored the first week or two
14:03:33 <FunctorSal> (source visualization :))
14:03:52 <SamB_XP> Berengal: it's those "forms" that give me trouble ...
14:05:19 <Berengal> SamB_XP, well, in a sense the difficulty of learning the syntax has been moved to the semantic level. sort of like "How do I pattern match on lists" cannot be answered by syntax in java.
14:05:35 <Berengal> (But can in Haskell, ML, F# etc.)
14:06:12 <SamB_XP> Semantics are complicated enough without taking on syntax's proper duties!
14:06:57 <Berengal> Well, we can't keep moving everything to the syntax, or you end up with perl and a multitude of productions always stepping on eachothers toes
14:07:08 <Berengal> Not to mention having to extend the parser just to implement a function...
14:07:51 <SamB_XP> Berengal: well, sure
14:07:57 <SamB_XP> not everything
14:08:11 <SamB_XP> but lisp has a bit too little in the outer syntax, IMO
14:08:52 <Berengal> Agreed
14:09:21 <__JN123> Hello, is there a funktion like elemIndex that returns a list with every occurrence of the searched elem?
14:09:23 <Berengal> Although hard-core lispers tell me they can't tell the difference...
14:09:39 <SamB_XP> Berengal: between what and what?
14:09:49 <SamB_XP> @hoogle indices
14:09:49 <lambdabot> Data.Array.IArray indices :: (IArray a e, Ix i) => a i e -> [i]
14:09:50 <lambdabot> Data.ByteString elemIndices :: Word8 -> ByteString -> [Int]
14:09:50 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
14:09:56 <Berengal> SamB_XP, they couldn't say, presumably because they can't tell the difference :P
14:10:08 <SamB_XP> __JN123: elemIndices look good to you?
14:10:33 <__JN123> Thanks Sam, that look good!
14:10:47 <SamB_XP> Berengal: surely they know the words others use to describe the things they can't distinguish?
14:11:35 <SamB_XP> __JN123: you're quite welcome ;-)
14:11:40 <Berengal> I guess they see beyond the syntax and into the semantics. I think I can understand that
14:12:30 <SamB_XP> well, I find it a bit easier to do that with slightly less uniform syntax for less uniform things ;-)
14:13:23 <Berengal> To be fair, there's no line between what should and what shouldn't be built-in syntax
14:13:36 <Berengal> Why doesn't haskell have syntax for maps, for example?
14:13:43 <Berengal> Python does
14:13:48 <jdkoeck> there's (!)
14:13:52 <SamB_XP> we ran out of characacters?
14:14:02 <jdkoeck> (for lookups)
14:14:10 <Berengal> Haskell does make it easy to extend the syntax within certain bounds though
14:14:21 <Berengal> jdkoeck, that's just a regular function
14:14:25 <dolio> Lisp lets you add to the syntax/parser all over the place anyway.
14:14:38 <dolio> It's just that the syntax is 'rose trees of a certain shape and tagged in a certain way.'
14:14:39 <SamB_XP> dolio: well, true
14:14:40 <Berengal> Heh, true
14:14:47 <jdkoeck> i know, it's still syntax for maps
14:14:55 <SamB_XP> but I'm not sure how that makes it easier to read ;-P
14:22:49 <fitoria> where can I get netclock library?
14:23:25 <ddarius> Lisp has a simple lexical syntax.  It's abstract syntax is still fairly complex.  Forth and PostScript are a lot closer to having "no syntax."
14:26:41 <SamB_XP> ddarius: and yet somehow I don't mind their syntax so much ;-)
14:29:21 <newsham> down with sin tax
14:29:57 <SamB_XP> but taxing sin could work very well for the economy!
14:30:11 <jmcarthur> i'm excited about trying GPipe
14:31:47 <newsham> > zipWith ($) (iterate (succ.) succ) "fml`\ESCghje_c[\DC3\NAKYQbYRXW"
14:31:48 <lambdabot>   "good morning #haskell"
14:34:07 <Cale> SamB_XP: There's a loophole. People can just use cos, and account for the phase shift.
14:34:24 <SamB_XP> Cale: not that kind of sin!
14:34:37 <SamB_XP> the kind that actually works in the pun "sin tax"
14:34:38 <newsham> cale: its more complex than that.  they can use exponentials.  the threat is no longer imaginary.
14:34:45 <SamB_XP> lol
14:34:53 <Cale> haha
14:35:27 <newsham> </tangent>
14:35:41 <SamB_XP> *groan*
14:37:33 <djahandarie> </secant>
14:38:04 <SamB_XP> djahandarie: you need to work on understanding what "pun" means
14:38:19 <newsham> maybe he's setting one up
14:38:37 <SamB_XP> secant doesn't have anything to do with the tax side of things, and it's not meta-conversational
14:39:14 <djahandarie> SamB_XP, I actually didn't even realize </tangent> was a pun lol
14:39:26 <djahandarie> I guess that's what I get for randomly jumping in the channel
14:39:46 <newsham> we were having a transcendental conversation about syntax
14:40:02 * SamB_XP thinks newsham is pushing it
14:40:35 <newsham> i think its an apt description in several ways
14:41:46 <benmachine> I'm trying to compile lambdabot-utils and being confused
14:42:06 <benmachine> it seems like a Control.Exception needs to be replaced with Control.OldException
14:42:15 <ajdhs> @djinn [a] -> [a] -> [a]
14:42:16 <lambdabot> Error: Undefined type []
14:42:21 <benmachine> what confuses me though is that the cabal file explicitly asks for base4
14:42:34 <ajdhs> Is it possible to use lists with djinn?
14:42:35 <benmachine> isn't that from after the switch?
14:42:37 <newsham> @djinn a -> a -> a
14:42:38 <lambdabot> f _ a = a
14:42:39 <benmachine> or am I confusing versions
14:42:48 <dcoutts> benmachine: Control.OldException is only in base 4
14:42:50 <ivanm> benmachine: no, it doesn't ask for base-4
14:42:52 <ivanm> it just says base
14:43:04 <ivanm> benmachine: are you using the runhaskell Setup.hs method?
14:43:13 <benmachine> ivanm: yes
14:43:16 <ivanm> because that takes the highest available version of base, which is 4
14:43:24 <benmachine> it says, base >= 4 && base < 5
14:43:25 <benmachine> in the file
14:43:30 <benmachine> er
14:43:30 <benmachine> no
14:43:33 <ivanm> cabal-install cheats and uses base-3 if it doesn't explicitly allow base-4
14:43:35 <benmachine> it says, base >= 4 && < 5
14:43:52 <ivanm> benmachine: really? the hackage page doesn't...
14:43:56 <newsham> ?djinn List a -> List a -> List a
14:43:57 <lambdabot> Error: Undefined type List
14:44:04 <benmachine> couldn't comment
14:44:04 <ivanm> are you using darcs version or something?
14:44:05 <newsham> ?djinn l a -> l a -> l a
14:44:05 <lambdabot> f _ a = a
14:44:08 <benmachine> yes
14:44:08 <ivanm> http://hackage.haskell.org/package/lambdabot-utils
14:44:10 <ivanm> ahhh
14:44:18 <ivanm> looks like it's Cale's fault... >_>
14:44:25 <benmachine> heh
14:44:51 <benmachine> should code using OldException generally speaking be switched to Exception?
14:44:57 <benmachine> (by changing the code itself)
14:45:01 <lispy> Does anyone know if 'newtype' interfers with fusion or disables specialize pragmas?
14:45:01 <lambdabot> lispy: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:45:34 <ivanm> benmachine: well, switch to extensible-exceptions as a compatability between base-3 and base-4...
14:45:57 <benmachine> ivanm: well, *I'm* probably not going to do it >_>
14:46:00 <ivanm> benmachine: OldException is base-4's name for base-3's exception
14:46:00 <benmachine> just curious
14:46:03 <ivanm> benmachine: heh
14:46:06 <benmachine> yeah I got that
14:46:15 <benmachine> I was just wondering if OldException was just a stopgap
14:46:21 <benmachine> or an actual module that you could use
14:46:48 * benmachine expresses self poorly
14:47:28 <ivanm> no, it's in base-4
14:47:36 <SamB_XP> benmachine: my impression is that it's a stopgap that you can use
14:47:44 <ivanm> for quick changeovers from base-3
14:47:56 <dcoutts> ivanm: is there any point in keeping compatibility with base-3 for things like lambdabot?
14:48:13 <ivanm> dcoutts: not really, I suppose
14:48:27 <ivanm> I was talking about the general case
14:48:56 <bryan`> I'm trying to use haskell to examine an algebra that I've been studying, but have run into a stumbling block: why doesn't "(Num r, Generator e) => Num [(r,e)]" work? I'm getting "Illegal instance declaration for `Num [(r, e)]' (All instance types must be of the form (T a1 ... an) ...". Generator is a class defined elsewhere that appears to be working fine.
14:50:00 <lispy> bryan`: it's because it's a list of tuples
14:50:12 <lispy> bryan`: doesn't GHC recommend an extension? like flexible instances?
14:50:34 <bryan`> Yes, it does. But why is that necessary?
14:51:25 <lispy> bryan`: due to a restriction present in Haskell 98 language specification.  It's not really technically deep as far as I know, but since GHC should be conformint it by default disallows the instance
14:51:45 <lispy> bryan`: if you want to still use Haskell98, you can work around this restriction with a custom 'newtype'
14:52:19 <lispy> newtype Group r e = G [(r, e)]
14:52:33 <lispy> instance (Num r, Generator e) => Num (Group r e)
14:52:59 <bryan`> lispy: It would be nice to conform to use Haskell98. Thanks!
14:53:03 <lispy> (if the newtype gives you any grief just use data, but newtypes are more efficient)
14:53:20 <jmcarthur> it's nice until you realize how limited you are compared to liberal use of ghc extensions ;)
14:54:26 <lispy> jmcarthur: in this case, I think a newtype is actually TheRightThing(tm)
14:54:31 <lispy> jmcarthur: but yeas I agree with you
14:54:35 <sbahra> Hi
14:54:42 <lispy> GHC's version of Haskell is way more powerful
14:54:54 <sbahra> How come lambdabot isn't in ##FreeBSD or #haskell-FreeBSD?
14:55:13 <sbahra> Is Cale still in charge of lambdabot?
14:55:26 <ivanm> sbahra: lambdabot went down at one point due to the server crashing; when they brought her back I think they forgot a few channels
14:55:31 <jmcarthur> lispy: agreed
14:55:33 <lispy> sbahra: I don't know and yes
14:55:43 <sbahra> Thanks guys.
14:55:57 <lispy> sbahra: Cale still doesn't have access to the settings from right before the crash
14:56:03 <sbahra> @ask Cale Could you please remind lambdabot to join ##FreeBSD and #haskell-FreeBSD?
14:56:04 <lambdabot> Consider it noted.
14:56:06 <lispy> I need to get on that; thanks for the renmider
14:56:23 <ivanm> sbahra: why ##FreeBSD though?
14:56:39 <SamB_XP> ivanm: I guess they're fans ?
14:56:54 <ivanm> heh
14:57:02 <sbahra> ivanm, because I watch out for fellow FreeBSD users.
14:57:15 <sbahra> ivanm, they should know about and use Haskell where it is appropriate. :-P
14:58:24 <sbahra> lambdabot is really useful (people can use it as a glorified calculator, at the least) and it's a good way for people to learn about/hear about Haskell.
14:59:02 <jmcarthur> sbahra: how good is ghc support for freebsd? is it typically behind on releases compared to linux? how far, if so?
14:59:37 <sbahra> We just recently got 6.10.4 into ports, jmcarthur.
14:59:46 <lispy> jmcarthur: I don't know if it's behind, but in the past I've seen ghc (template haskell actually) lag behind on some variant of bsd, not sure if it was FreeBSD or not.
14:59:46 <jmcarthur> i'm kind of a bsd fanboy who hasn't really committed to it yet
15:00:02 <jmcarthur> lispy: it's very behind on dragonfly, for sure
15:00:06 <sbahra> jmcarthur, we tried to setup an official project, http://freebsd.haskell.org/
15:00:07 <jmcarthur> lispy: maybe even not working?
15:00:20 <jmcarthur> sbahra: ah nice
15:00:24 <sbahra> jmcarthur, unfortunately, with my course load, I have way too little time to balance freebsd.haskell.org and my other projects.
15:00:33 <sbahra> jmcarthur, we need more contributors, #haskell-FreeBSD if you're interested.
15:00:47 <jmcarthur> heh, i have very little bsd experience, yet. i'm just a wannabe ;)
15:00:52 <sbahra> jmcarthur, we are working on "official" support for cabal in FreeBSD ports (a lot of that work is already on the way in).
15:01:02 <jmcarthur> ooh!
15:01:14 <dcoutts> sbahra: great
15:01:29 <sbahra> It's all due to Jacula Modlyn.
15:01:40 <sbahra> Student of philosophy and mathematics. :-P
15:01:57 <SamB_XP> sbahra: you can do that ?
15:02:01 <sbahra> I did a lot of porting and helped the beginning steps of building the bootstrap, then course load creeped up. :-P
15:03:36 <sbahra> SamB_XP, do what?
15:03:47 <SamB_XP> take philosophy *and* mathematics?
15:04:16 <sbahra> SamB_XP, at his university, yes.
15:09:26 <Adamant> double majoring is common, and philosophy and mathematics are linked through logic
15:10:52 <SamB_XP> Adamant: you would think that, wouldn't you?
15:11:09 <Adamant> SamB_XP: is I wrong?
15:11:15 <SamB_XP> but I wonder how many college administrations realize that ;-P
15:11:26 <Adamant> lol probably not many :P
15:11:51 <SamB_XP> and how many philosophy programs actually use logic as much as they ought ...
15:12:16 <Adamant> indeed
15:13:50 <lispy> The only class I ever took in college that was purely logic (not counting digital circuit design) was a philosophy class
15:15:35 <FunctorSal> hmm do they really use logic in compareable ways?
15:16:02 <FunctorSal> it's not like logicians use logic to make claims about The Real World
15:16:23 <SamB_XP> much less CHANGE the world ;-P
15:16:54 <ddarius> SamB_XP: You need to find the linear logicians.
15:16:55 <SamB_XP> but it's not because they can't
15:17:07 <SamB_XP> ddarius: hehhehe
15:17:37 <Rotaerk_> logic does make claims about the real world
15:17:45 <Rotaerk_> it's just that they're claims that are true in ANY world
15:19:59 <jmcarthur> given some assumptions about the world
15:20:29 <FunctorSal> and assumptions that your metalogic properly connects the real world and your logic
15:20:52 <FunctorSal> and that your language makes any sense whatsoever
15:21:00 <jmcarthur> only if you intend to apply your logic to the real world
15:21:02 <SamB_XP> what connects your metalogic to the metaworld?
15:21:53 <lispy> metaworld sounds like a good name for a pub
15:22:09 <SamB_XP> metagirl would be better ...
15:22:30 <FunctorSal> throw in some beta or 2.0
15:35:31 <Cale> Yeah, I sort of resent the idea that logic makes claims which are true in any world. There seem to be worlds which are different enough to require different logics :)
15:35:32 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:36:54 <aconbere> Anyone here ever spent any time with HOpenGL?
15:37:05 <aconbere> I'm struggling with type casing to GLfloat values
15:37:09 <aconbere> casting
15:37:58 <aconbere> In particular I'm using the MonadRandom package to build some random open GL objects
15:38:17 <aconbere> Since GLfloat isn't an instance of Random
15:38:22 <aconbere> I'm building random Floats
15:38:30 <aconbere> but I can't quite get it to all work out
15:38:31 <aconbere> :P
15:38:58 <mauke> :t realToFrac
15:38:59 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
15:39:50 <aconbere> yeah I tried that
15:39:55 <aconbere> here I'll paste my code :P
15:40:57 <aconbere> http://paste.pocoo.org/show/142971/
15:41:42 <aconbere> http://paste.pocoo.org/show/142972/
15:41:53 <aconbere> that's the error I get from GHC trying to compile the whole module
15:42:02 <mauke> oh, is that all?
15:42:08 <mauke> you're not building Floats
15:43:00 <mauke> btw, the definition of toGLfloat can be simplified
15:43:06 <mauke> toGLfloat = realToFrac
15:43:25 <mauke> you need to add a type signature somewhere that tells the compiles which intermediate type to use
15:43:31 <mauke> s/compiles/compiler/
15:47:14 <Alpounet> the first class modules proposal looks very interesting.
15:48:50 <aconbere> mauke: can you describe what the might look like
15:49:03 <aconbere> mauke: I get the feeling like I'm just missing some fundemental piece
15:49:14 <aconbere> cause I've been throwing darts at the problem all mornings
15:49:15 <aconbere> :P
15:49:45 <mauke> ok, change the type signature of toGLfloat to :: Double -> GLfloat
15:50:50 <aconbere> mauke: I'm so mad that worked :P
15:52:30 <aconbere> okay I've gotta go, thanks so much :)
16:09:08 <dolio> Alpounet: What first class modules proposal?
16:10:52 <Alpounet> dolio, http://research.microsoft.com/en-us/um/people/simonpj/Papers/first-class-modules/
16:11:08 <Alpounet> yeah it's old, but still interesting
16:11:27 <dolio> Uh oh, my lack of access to research.microsoft.com has become a hindrance.
16:11:49 <ivanm> dolio: so I"m not the only one?
16:11:56 <dolio> Nope.
16:12:34 <Alpounet> I had the same issue.
16:13:07 <Alpounet> Wait, I'll put it somewhere.
16:13:25 <Berengal> What's the benefit of first-class modules?
16:13:29 <dolio> It's all right. I was just wondering where the proposal was.
16:13:34 <dolio> And who made it.
16:13:42 <dolio> The design space of first class modules is pretty large, though.
16:13:43 <Berengal> I've never used them...
16:14:14 <SamB_XP> I find them a bit painful compared to typeclasses
16:14:27 <Alpounet> Berengal, have you ever played with ML modules ? They're not first class, but nearly, and you can feel, like dolio says, the design space enlarged.
16:14:57 <dolio> For one, think of all the times people ask for global variables...
16:15:11 <Berengal> Alpounet, no, that's what I haven't done. I've googled a bit for it, but couldn't say I was impressed. Not having used them, however, I'm hesitant to write them off
16:15:44 <dolio> And then think about 'myModule :: IO Module' where you can do... "main = do mod <- myModule ; open mod ..."
16:16:20 <Berengal> dolio, and exactly what would that do?
16:16:29 <dolio> And have well-defined mutable variables in modules through normal Haskell monads.
16:16:50 <dolio> The idea would be to parameterize a module by an IORef.
16:17:05 <dolio> So 'module Foo (global :: IORef a) where ...'.
16:17:19 <Alpounet> Berengal, it'd bring on modules with a structural parametrization.
16:17:32 <Alpounet> not really like in ML
16:17:35 <Alpounet> but still, a bit.
16:17:37 <dolio> Then 'myModule :: IO Module ; myModule = newIORef >>= \r -> Foo(r)'
16:18:08 <Berengal> Ah, so global'd be defined inside the module, and passed in as a parameter?
16:18:25 <Berengal> And I suspect 'open' would "import" the module, in a way?
16:18:56 <dolio> Well, in Agda for instance, there's a difference between "importing" and "opening".
16:19:14 <dolio> importing brings a module into scope from another file, where you can still refer to things in it qualified.
16:19:25 <dolio> opening lets you access things in a module that's in scope unqualified.
16:20:00 <Berengal> I'm afraid I don't quite get that...
16:20:52 <Berengal> In haskell, qualified vs unqualified is just a syntactic and name-resolution issue
16:21:40 <dolio> It might help to think of modules like values.
16:21:47 <Alpounet> opening a module is a name-resolution issue too. Except that here modules could be passed to functions, etc.
16:21:54 <dolio> So, a module may be in scope. Say it's named Foo.
16:21:56 <Alpounet> So it isn't that "trivial".
16:22:07 <dolio> Then Foo.bar refers to the bar inside the Foo module.
16:22:09 <Berengal> Alpounet, ah, that makes a bit more sense
16:22:20 <dolio> open Foo brings everything inside Foo into scope.
16:22:22 <Berengal> Sort of like record punnning?
16:23:15 <dolio> I'm not sure you'd call Agda's modules first class either, since they can't be passed to functions (although records can, and there's a sort of connection).
16:23:30 <dolio> Or returned from functions, for that matter.
16:23:45 <coloc> hi! Is there a way in a .cabal to declare a dependance on an external executable (in my case imagemagick's convert)? or maybe in the Setup.hs?
16:23:58 <dolio> Doing globals with that IO Module type stuff would require them to be more first class.
16:24:00 <SamB_XP> coloc: sadly, no
16:24:14 <dcoutts> coloc: if it is a tool needed to build the package, then yes.
16:24:20 <dcoutts> like a pre-processor
16:24:54 <coloc> no, it's a regular program
16:25:00 <dolio> But I've always heard ML's modules referred to as "first class", and I don't think they're even that fancy.
16:25:15 <dcoutts> coloc: so it's something your program uses at runtime?
16:25:17 <coloc> so i think i have to check for its existance in the path at runtime
16:25:19 <Alpounet> dolio, they're not exactly first class.
16:25:22 <coloc> yes
16:25:25 <dolio> Except maybe when you get into the more researchy areas that aren't Standard ML anymore. Like Alice.
16:25:29 <Alpounet> you can't store them in a record or so, e.g.
16:25:34 <Saizan_> there's a literature where "first-class" is used only when the type components are determined at runtime, not just the values, so the global IORef example would still be second-class
16:25:52 <dcoutts> coloc: ok, so no you cannot declare deps like that
16:25:58 <dolio> Alice has functions like "String -> Module" if I remember correctly.
16:26:27 <Alpounet> dolio, what's proposed in the paper describes much more first-class modules than ML's
16:27:20 <dolio> ML modules are already quite handy, though, since they're sort of their own higher order language. It's just rather separate from the value lanuguage.
16:27:34 <dolio> Complete with types.
16:27:56 <Berengal> So to translate this into (weird but legal) haskell, a module would be a record, each declaration would be a record field, and there's a function that takes the parameters, defineds the declarations in a where and returns a record with those specialized declarations?
16:28:29 <Berengal> Or is this entirely wrong?
16:28:47 <dolio> Yes, it's a lot like that.
16:28:57 <dolio> Except records would need to be able to hold types and stuff.
16:29:04 <Saizan_> Berengal: that's where the linked paper starts
16:29:26 <coloc> thanks guys!
16:29:43 <Saizan_> then it uses existentials for abstraction and adds things to make them nicer to use in the large
16:29:55 <Berengal> dolio, yes, I guess you'd need first-class types for data declarations
16:30:26 <Alpounet> btw, the paper is also present here : http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.23.6463&rep=rep1&type=pdf
16:30:42 <Berengal> Alpounet, thank, will read
16:31:15 <Berengal> But anyway, won't you still have to pass the module around to all the various functions using it?
16:32:04 <SamB_XP> Berengal: usually you just pass it to another module
16:32:12 <dolio> Yes, but you could just open the module in a scope that encompasses all those functions.
16:32:57 <Berengal> SamB_XP, making it globally open?
16:33:32 <Alpounet> Berengal, no, the second module would then be a functor. A module parametrized by another one.
16:33:43 <Berengal> dolio, that has to be the global scope, or it's just turning StateTs into ReaderTs
16:33:49 <Alpounet> The resulting module depending on what were exactly the content of the parameter-module
16:34:29 <Berengal> Alpounet, I meant within the second module
16:35:34 <Berengal> I guess I need some short'n'sweet examples...
16:37:07 <Alpounet> Berengal, it'd only open the parameter module in the second module if you ask it too. Otherwise, you'll just access the parameter module's content with Module.foo
16:37:21 <Alpounet> (or whatever operator could be used instead of .)
16:38:55 <dolio> Berengal: Instead of "foo Mod = ... where open Mod ; bar Mod = ... where open Mod" you write "module Local(Mod) where { open Mod ; foo = ... ; bar = ... }".
16:39:46 <Berengal> I feel a minor tingle in my brain... perhaps I should learn ml enough to grok this properly
16:40:52 <dolio> That's another thing about ML modules. You can have modules inside modules.
16:41:23 <dolio> module Foo where { module Bar where { ... } ; module Baz where { ... ; module Quux where { ... } } }
16:41:25 <SamB_XP> Berengal: learning Coq or Agda might be sufficient ;-)
16:41:42 <Makoryu> dolio: Yeah, Haskell syntax for that is trivial, even if the semantics aren't.
16:41:47 <SamB_XP> if you want to save some time
16:41:52 <Berengal> dolio, Seems you'd have to, or I can see you creating lots of small modules to simply do some module magic
16:42:01 <Alpounet> saving time by learning Coq or Agda ?
16:42:06 <Alpounet> Compared to ML ?
16:42:10 <Alpounet> Are you kidding ? :-p
16:42:19 <Berengal> Well, I'm probably going to learn one of those anyway
16:42:46 <Makoryu> ML is hilarious
16:42:51 <dolio> Makoryu: Haskell doesn't let you do that at all. The closest thing is "hierarchical modules" but that's just a naming convention.
16:42:54 <Berengal> Read part of a tutorial on Agda recently, but got lost in the types. Decided to punt until I've got a week  or something
16:43:00 <Makoryu> dolio: I'm aware, yes.
16:43:05 <dolio> Foo.Bar.Baz isn't "inside" Foo.Bar at all.
16:43:36 <dolio> Which is kind of weird in Agda, since it has both. :)
16:43:42 <Makoryu> dolio: I mean that if some poor fools took it upon themselves to implement that, the syntax for declaring inner modules would be obvious.
16:43:52 <SamB_XP> Alpounet: well, I mean, if you do that you're learning something more useful than ML ;-P
16:43:59 <Alpounet> Makoryu, I find 2 things in ML to be very interesting. The module system, and their class-based structural polymorphism (that we, obviously, get through module functors too).
16:44:19 <dolio> So you could have a 'Foo.Bar' and a 'Bar' inside 'Foo', but they aren't the same. :)
16:44:28 <Alpounet> (actually, the later is part of OCaml but not all MLs)
16:44:39 <dolio> Except I think you might be able to refer to the Bar inside Foo as Foo.Bar. :)
16:45:01 <dolio> Makoryu: Ah, yes.
16:45:13 <Berengal> Can you do web-programming in Agda? ;)
16:45:58 <BMeph> Didn't augustss write in his blog a few months ago, about a problem he had using Strings, that somewhat sketchily described how ML-type modules would've simplified his problem?
16:46:11 <dolio> Yes.
16:47:17 <dolio> You can actually finesse type classes into behaving like ML modules, but it isn't pretty.
16:47:34 <BMeph> Here it is: http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
16:47:43 <Alpounet> SamB_XP, I don't really find Coq or Agda more useful than OCaml.
16:48:52 <ddarius> dolio: It's not that bad.
17:13:44 <FunctorSal> C-f "Reiner Pope" on that page
17:14:35 <FunctorSal> (don't put stuff which doesn't mention all the variables into a MPTC; make a seperate class)
17:35:28 <hackagebot> TypeCompose 0.6.7 - Type composition classes & instances (ConalElliott)
17:36:30 <hackagebot> X11 1.4.6 - A binding to the X11 graphics library (DonaldStewart)
17:36:32 <hackagebot> DeepArrow 0.3.3 - Arrows for "deep application" (ConalElliott)
17:36:34 <hackagebot> TV 0.4.3 - Tangible Values -- composable interfaces (ConalElliott)
17:36:36 <hackagebot> GtkTV 0.0.1 -  (ConalElliott)
17:41:46 <conal> fixed build failure in my previous hackage releases.
17:42:06 <conal> oops.  missing a quicky description of GtkTV.
17:42:35 <wchogg> checkers doesn't build for me
17:44:49 <conal> oh dear.  i put GtkTV's synopsis where the categories are meant to go.  fixing ...
17:44:59 <conal> wchogg: doesn't?  hm.
17:45:26 <wchogg> no instance for (Applicative Gen) in src/Test/QuickCheck/Instances/Maybe.hs:7:20
17:45:41 <conal> wchogg: funny.  i removed that instance in my last update.
17:45:57 <conal> wchogg: i guess i forgot to increment the QuickCheck dependency version.
17:46:07 <conal> will fix
17:46:12 <wchogg> awesome
17:46:24 <lispy> conal: hi
17:46:27 <lispy> conal: how are you?
17:47:27 <conal> lispy: i'm doing great.  having fun learning iphone programming: objective-c & cocoa-touch libs
17:47:34 <conal> lispy: how aobut you?
17:48:01 <conal> (about*)
17:48:22 <lispy> conal: oh fun.  I was learning that and had plans to do something iphone related with real-life friends but enthusiasm died over time.  I'm doing well.  I start at Galois tomorrow, so very excited about that.
17:48:44 <conal> wchogg: thx for the bug report.  getting uploaded now (over slow satellite connection).
17:48:59 <wchogg> Oh, right - do you know what you'll be doing at the big G yet?
17:49:06 <wchogg> Or can you even say :-p
17:49:11 <conal> lispy: hey congrats on the job!
17:49:25 <heatsink> yeah, congratulations
17:49:29 <lispy> wchogg: I don't know how much I can talk about yet; but I have a vague idea of which two projects I'll be on initially
17:49:37 <lispy> thanks!
17:49:39 <heatsink> I keep hearing about Galois, maybe I should figure out what they actually do.
17:50:06 <wchogg> They're where Haskell programmers to good to be allowed in the wild are kept
17:50:10 <Makoryu> They're a secret government organization set up to deal with the threat of covert alien invasion.
17:50:59 <BMeph> Makoryu: s/government/private/ -- other than that, sure! ;p
17:51:01 <heatsink> ah, that explains why it's so shrouded in mystery. *nod*
17:51:18 <lispy> Or, they're an organization that uses government business grants to convert ideas into mature prototypes.  The mature prototypes are then sold to other companies who plan to productize them.  They have an emphasis on high-assurance computing :)
17:52:00 <lispy> (I think they have other sources of funding, but that's the main one I've learned about thus far)
17:52:08 <conal> wchogg: please try checkers now.
17:52:12 <conal> @hackage checkers
17:52:12 <lambdabot> http://hackage.haskell.org/package/checkers
17:52:40 <BMeph> "Installing library in C:\Program Files (x86)\Haskell\checkers-0.2.3\ghc-6.10.4
17:52:40 <BMeph> Registering checkers-0.2.3...
17:52:40 <BMeph> Reading package info from "dist\\installed-pkg-config" ... done.
17:52:40 <BMeph> Writing new package config file... done."
17:52:47 <jmcarthur> conal: hey!
17:52:52 <conal> wchogg: i just updated the QC dependency, so now cabal ought to upgrade your QC when installing checkers.
17:52:56 <conal> jmcarthur: yo!
17:53:07 <BMeph> conal: Sorry about the spam; kudos for the good (looking, so far) fix. :)
17:53:33 <conal> BMeph: :)
17:53:45 <jmcarthur> conal: what do you know about GPipe? looks like what it sounds like you've been working on
17:54:05 <jmcarthur> i'm having trouble reading that last sentence i just wrote
17:54:14 <conal> jmcarthur: i saw the tweet but haven't looked much.  sure does sound related.
17:54:38 <jmcarthur> i'm trying to play around with it, but it seems very tied to the individual stages of the gpu pipeline, which i don't have a lot of experience with
17:54:46 <lispy> conal: so is the plan for your work on the iphone still to generate code which is in turned compiled the normal-iphone-way, or did I dream all that up?
17:55:00 <jmcarthur> it's nice so far though, from what i've gathered at least
17:55:26 <conal> lispy: that's the plan.  (we're having the same dream.)
17:56:05 <conal> lispy: i'm generating glsl code now.  will probably also generate (obj-)c.
17:56:12 <wchogg> Yeah, checkers compiles just fine now.
17:56:21 <conal> wchogg: super!
17:56:36 <lispy> conal: cool.  so I bet that could have wider impact that the iphone if you really wanted it to
17:56:54 <lispy> (although, I find the idea of starting with a well-defined target to be pleasing)
17:56:59 <conal> hm.  i often get these package version dependencies wrong.  i bet hackage could help.
17:57:13 <jmcarthur> hmm, the cabal-install database must update more slowly than the hackage database
17:57:13 <wchogg> conal : I don't know if my ramble the other day about your type-class morphisms note made any sense?
17:58:23 <conal> lispy: yeah, definitely.  i'd already written the functional->gpu compiler when i heard that the iphone 3gs could run the code.  glsl also works for other mobile devices and desktop
17:59:23 <jmcarthur> conal: does your interface expose any details about whether you are using the vertex shader or fragment shader?
17:59:43 <conal> GPUs are crazy fast, and the current languages/libraries are terribly & unnecessarily difficult.  so great opportunity for functional/denotational programming.
18:00:21 <conal> jmcarthur: yeah, it does.  one describes pairs of compatibly-typed shaders.
18:01:15 <jmcarthur> okay, just curious. gpipe seems to do something similar
18:01:18 <conal> jmcarthur: for now.  i'd like to create a quality/approximation model and then automate the vertex/fragment choice.
18:01:35 <jmcarthur> ooh, that'd be nice!
18:02:10 <conal> yeah.  and i'm using continuous space in 3D & 2D, with perfect normals, using my "beautiful differentiation" work.
18:02:47 * jmcarthur drools
18:03:36 <hackagebot> GtkTV 0.0.2 - Gtk-based GUIs for Tangible Values (ConalElliott)
18:03:39 <conal> sadly, the iphone version of opengl (es 2.0) doesn't seem to allow access to the hardware's ability to tessellate dynamically.  i'm still noodling over what to do about that limitation.
18:04:26 <SamB_XP> conal: what makes you think that hardware *can*?
18:04:38 <hackagebot> checkers 0.2.4 - Check properties on standard classes and data structures. (ConalElliott)
18:04:40 <hackagebot> txt-sushi 0.4.0 - Spreadsheets are databases! (KeithSheppard)
18:05:13 <conal> SamB_XP: something i read in a description of the gpu
18:05:32 <SamB_XP> conal: why are you on a mad uploading spree today, anyway?
18:06:01 <jmcarthur> SamB_XP: that's just how fast conal codes
18:06:04 <Cale> http://www.boasas.com/?c=1168
18:06:07 <jmcarthur> he's been taking a break!
18:06:16 <SamB_XP> jmcarthur: ... right!
18:06:18 <conal> really just fixing some mistakes in last week's uploads.
18:07:07 * jmcarthur gets back to toying with gpipe
18:08:56 <Cale> Commentary on the implementation of unamb in GHC? :)
18:09:26 <heatsink> Hmm, yi is only syntax-highlighting the last thing I typed.
18:09:28 <heatsink> I wish the source code had comments so I could know what I was doing.
18:09:53 <heatsink> unamb?
18:11:32 <heatsink> I'll look at the paper, but at first glance it looks like a fancy name for a race condition.
18:11:42 <Merc> HASKELL!
18:11:42 <SamB_XP> heatsink: precisely ;-)
18:11:45 <SamB_XP> that's just what it is
18:12:06 <Merc> You know Haskell isnt as fun to say as ubuntu
18:12:07 <SamB_XP> but conal can explain how it can be safe
18:12:10 <Merc> UBUNTU
18:12:11 <Merc> UBUNTU
18:12:11 <Merc> UBUNTU
18:12:12 <Merc> UBUNTU
18:12:12 <Merc> UBUNTU
18:12:13 <Merc> UBUNTU
18:12:13 <Merc> UBUNTU
18:12:15 <Merc> UBUNTU
18:12:17 <Merc> UBUNTU
18:12:19 <Merc> UBUNTU
18:12:20 --- mode: ChanServ set +o Cale
18:12:21 <Merc> UBUNTU
18:12:23 <Merc> UBUNTU
18:12:24 --- mode: Cale set +b *!*@pool-71-183-59-77.nycmny.fios.verizon.net
18:12:24 --- kick: Merc was kicked by Cale (Cale)
18:12:30 --- mode: Cale set -o Cale
18:12:37 <conal> Cale: thx
18:12:48 <Cale> heatsink: With the idea being that you should only use it when you're sure that if both of the parameters are defined, then they are equal.
18:12:54 <SamB_XP> you know, I wouln't care if someone started spamming the channel with "HASKELL" like that
18:13:02 <heatsink> heh
18:13:06 <SamB_XP> they should obviously still be kickbanned
18:15:16 <Cale> Heh, he messages me with 'sorry', and then proceeds with the same spamming of UBUNTU over and over until I /ignore him.
18:15:30 <Pseudonym> UBUNTU is pretty good.
18:15:43 <Pseudonym> I'd shout it from the rooftops too, if it didn't disturb the neighbours.
18:16:14 <purplepenguins> I say, nobuntu
18:17:58 <Gracenotes> I use Ubuntu
18:18:13 <aavogt> is there some way to convince cabal to represent this choice of dependencies:
18:18:15 <aavogt> build-depends:    (base >= 4 && < 5, syb) || (base >= 3 && < 4)
18:18:24 <Gracenotes> if you say Haskell repeatedly people will think you're talking about Pascal
18:18:36 <aavogt> with the base-2 and base-3 transition, there was a cabal flag, small-base
18:18:44 <wchogg> Gracenotes:  That is still so damn weird
18:18:46 <Pseudonym> That's just because they don't know how to pronounce "Pascal".
18:19:00 <Gracenotes> hm. actually, it probably won't, because the h loses its aspiration
18:19:05 <aavogt> I can't find any mention of a similar flag for the base-3 base-4 transition
18:19:07 <SamB_XP> Pseudonym: how DO you pronounce Pascal?
18:19:07 <Gracenotes> when you say it rpeeatedly
18:19:15 <Saizan__> aavogt: small-base wasn't something official, it was just defined in the .cabal files
18:19:22 <Pseudonym> SamB: Long "a".  "pas-KAHL"
18:19:25 <Saizan__> aavogt: you can define your own in the same way
18:19:39 <SamB_XP> Pseudonym: well, okay, so they don't
18:19:56 <SamB_XP> they say PasKel
18:20:04 <Pseudonym> Right.  "PAS-kell"
18:20:15 <Gracenotes> okay.. time to review 140 flashcards for my biology midterm tomorrow
18:20:21 <Saizan> aavogt: the "if someFlag then .. else .. " statement in .cabal files is bidirectional
18:20:39 <Pseudonym> Though to be fair, more people pronounce "Pascal" correctly than pronounce "Niklaus Wirth" correctly.
18:20:47 <Saizan> aavogt: the solver will set someFlag to false automatically if that's needed to find a solution
18:20:56 <Gracenotes> I should really make the flashcards as I go with anki instead of making/importing them 36 hours before the exam
18:21:10 <SamB_XP> Pseudonym: how do you do that?
18:21:22 <Pseudonym> "Whereas Europeans generally pronounce my name the right way ('Nick-louse Veert'), Americans invariably mangle it into 'Nickel's Worth.' This is to say that Europeans call me by name, but Americans call me by value."
18:21:40 <SamB_XP> hehehehe
18:22:00 <SamB_XP> I would call him Nick-Claws Worth
18:22:22 <JakeDust> you just have to know he's swiss to pronounce it right
18:22:45 <SamB_XP> JakeDust: yeah right
18:23:15 <Pseudonym> JakeDust: But I was taught German by a Romanian, so even if I knew that, there's no guarantee I'd get it rught.
18:23:16 <Pseudonym> right
18:23:27 <Gracenotes> I think I'd get the first name, but the last name.... no
18:23:27 <BMeph> JakeDust: Yeah, like folks in the US know more about the Swiss that they have good banks and chocolate... ;)
18:23:37 <Pseudonym> And clocks.
18:23:45 <BMeph> ...and cheese.
18:23:53 <JakeDust> and army knives
18:23:56 <Pseudonym> Cheese, yes.  Mmmm... cheese.
18:24:08 <SamB_XP> good banks to keep ill-gotten gain in
18:24:09 <SamB_XP> yes
18:24:23 <Gracenotes> I mean, the Roman alphabet didn't have a W, now the Swiss are abusing at the expense of good ol' V? well, which was actually U
18:24:34 <BMeph> Some especially smart Americans may even now about the Pope's guards, but that's pushing it. :)
18:25:08 <JakeDust> Gracenotes: That's what you get when you are too germanic.
18:25:14 <SamB_XP> BMeph: well, we've heard there are some things called "alps"
18:25:24 <SamB_XP> and that some of them are swiss
18:25:25 <Veinor> If I didn't know better I'd pronounce 'Nicklaus Wirth' "Nick-louse Virth"
18:25:45 <JakeDust> (or if you start going further east to Poland)
18:26:20 <Veinor> Hm. I need to do some coding.
18:26:21 <Adamant> some of us are descended from the clock makers, ya know
18:26:37 <Pseudonym> Adamant: No shame in that.  Quite an honour, in fact.
18:26:45 <dibblego> what's the usual library for parsing large amounts of XML?
18:26:46 <Adamant> Pseudonym: there was supposed to be shame?
18:26:49 <SamB_XP> Adamant: it's even more of an honour if you can make clocks
18:27:01 <ezyang> dibblego: HaXML?
18:27:02 <Pseudonym> Adamant, it sounded like you were getting defensive.
18:27:08 <Adamant> I'm just sayin', there are quite a few Americans of Swiss background
18:27:21 <dibblego> ezyang, I want to make sure it won't barf on a 2GB file
18:27:27 <Makoryu> Veinor: Virth? Not Veert?
18:27:29 <Adamant> Pseudonym: getting defensive about assuming Americans know nothing about Switzerland :P
18:27:31 * jmcarthur considers naming his cat Zygohistomorphic Prepromorphism
18:27:54 <Veinor> Makoryu: I don't speak any sort of non-romance language at all :P
18:27:56 <ezyang> jmcarthur: prolly would be nicknamed Ziggy
18:28:01 <SamB_XP> dibblego: so, you want streaming XML processing
18:28:08 <dibblego> SamB_XP, yes
18:28:12 <SamB_XP> Veinor: what about English?
18:28:14 <JakeDust> Veinor: Like, you're speaking English. It's a non-Romance language
18:28:15 <ezyang> dibblego: So, the question is, What Are You Really Trying To Do?
18:28:28 <Veinor> You know what I meant. >:C
18:28:30 <dibblego> ezyang, parse a 2GB XML file
18:28:39 <SamB_XP> did you think yuo were speaking really tainted french ?
18:28:46 <ezyang> dibblego: Into a DOM?
18:28:49 <Veinor> oh hey ezyang I didn't know you were in here
18:28:53 <dibblego> ezyang, no, I don't have a supercomputer
18:28:54 <SamB_XP> dibblego: how did you get it to be exactly 2GB?
18:28:54 <ezyang> Veinor: :-P
18:29:08 <dibblego> SamB_XP, that's rather small (http://openstreetmap.org/)
18:29:09 <SamB_XP> ezyang: how much RAM do you suppose dibblego *has*?
18:29:10 <Veinor> :D
18:29:19 <SamB_XP> dibblego: I said "exactly"
18:29:19 <JakeDust> mais oui, English is français avec un strange grammar :)
18:29:20 <ezyang> SamB_XP: One HUNDRED MILLION BYTES!
18:29:35 <Veinor> English is this bastard child of French and German
18:29:43 <dibblego> SamB_XP, it's 1938319675 bytes
18:29:44 <SamB_XP> Veinor: only french and german ?
18:29:52 <Veinor> and other languages as well :D
18:29:55 <ezyang> Oh wait, that's very little
18:30:39 <ezyang> dibblego: You must be parsing the XML because you want X information out of it. What is that X information?
18:31:28 <SamB_XP> ezyang: what if he actually wants M information and L information as well?
18:31:41 <dibblego> never mind, I'll figure it out
18:31:52 * Axman6 always wants hiks meta out
18:31:55 <Axman6> uh
18:31:58 <Axman6> his
18:32:46 <JakeDust> but I think sometimes it's too much to ask for someone to speak names from other languages correctly. I can't help laughing when someone from almost everywhere tries to speak Russian names.
18:35:06 <JakeDust> and well, I'm quite happy to see that people usually understand my strange and broken English.
18:36:24 <SamB_XP> JakeDust: more broken than mine or orbitz's often is ?
18:38:00 <JakeDust> SamB_XP: haha, I don't know.
18:40:02 <Saizan> dibblego: tagsoup?
18:40:12 <JakeDust> the more I learn other languages (even programming ones), the worse I speak my native one, haha, but I think haskell is different enough to don't cause any problemas.
18:40:38 <dibblego> Saizan, that looks like it is for HTML; I'm looking at hxt at the moment, but it's a bit overwhelming
18:44:47 <hackagebot> teams 0.0.2.3 - Graphical modeling tools for sequential teams (AdityaMahajan)
18:45:10 <SamB_XP> what the heck are sequential teams ?
18:46:39 <Gracenotes> are you a bad enough dude to research sequential teams?
18:47:01 <SamB_XP> what? research!
18:47:13 <SamB_XP> not really!
18:48:50 * dibblego is almost ready to use Parsec
18:49:43 <Saizan> i thought tagsoup would parse xml since it parses html
18:50:02 <Saizan> it won't do any validation, though
18:50:54 <SamB_XP> I wonder if you can validate XML in O(depth) space?
18:51:04 <mmorrow> paragraph two of the conclusion in that "First-class Modules for Haskell" paper is why imo *any* attempt to encode ML-like modules w/in existing haskell machinery can't be sufficient
18:51:46 <mmorrow> the whole point of ML-modules is that changes are local!!!
18:53:53 <mmorrow> and also the biggest appeal imo of ML-modules is that type sharing is expressed with a simple "with", rather than gymnastics with location of definitions/etc
18:55:37 <Saizan> yeah, sharing by specification rather than by construction
18:55:54 <mmorrow> exactly
18:56:38 <Adamant> does anyone know of a good link to an explanation of ML modules?
19:01:36 <fnord123> anyone know a decent resource on left factoring parsec grammars?
19:05:33 <mmorrow> Adamant: this is a good one (for SML's flavor of "ML modules") http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.4832
19:07:35 <Adamant> mmorrow: thanks mmorrow!
19:07:40 <Adamant> lol
19:07:47 <Adamant> I just realized how ridiculous that was
19:07:57 <mmorrow> your welcome :)
19:08:01 <mmorrow> *you're
19:13:34 <Makoryu> http://echo.rsmw.net/n00bfaq.html <- Working on a new section at the end. Any thoughts?
19:14:03 <ezyang> "The Indentation Thing"?
19:14:05 <Makoryu> Yep
19:15:12 <ezyang> looks fine, although I swear I've seen more complicated cases
19:16:16 <aavogt> Makoryu: I would suggest showing another indentation style, where you start a new line right after the do
19:16:24 <aavogt> and indent the whole block less
19:16:27 <Makoryu> aavogt: I plan to talk about that :p
19:16:37 <Veinor> Makoryu: the color scheme is nice :D
19:16:39 <Makoryu> I just spent 20 minutes on the visual aid though
19:16:51 <Makoryu> Veinor: It's an altered zenburn
19:16:56 <Veinor> zenburn?
19:17:07 <Makoryu> Famous Vim color theme
19:17:10 <Veinor> ah
19:17:16 <mmorrow> Makoryu: (in the very last code snippet, you missed a ";" between the final "}" and "baz = quux")
19:17:18 <Veinor> I have something like it on my blog, a bit darker bg though
19:17:20 <aavogt> well, it is easy to go from that case to the one you showed
19:17:45 <aavogt> also, -- Two lines indented more than N -} should probably say columns?
19:17:46 <mmorrow> Makoryu: yeah, i dig the color-scheme
19:17:48 <Makoryu> mmorrow: I deliberately left it out.
19:18:16 <mmorrow> Makoryu: (you know it's invalid syntax, right?)
19:18:22 <mmorrow> parse error
19:18:35 <Makoryu> aavogt: I could write "Indented three columns more than N" but that's not what I meant :p
19:18:49 <Makoryu> aavogt: Would "indented further" be clearer?
19:18:56 <Makoryu> mmorrow: Is it really?
19:19:09 <mmorrow> yeah, need a ";" or a "\n"
19:19:12 <Makoryu> I thought the last semicolon was optional
19:19:28 <mmorrow> but that's not the last though
19:19:33 <mgorbach> So, I have a type definition.
19:19:34 <dolio> "main = do { ... } baz = quux" is not valid, he means (I think).
19:19:48 <mgorbach> data Tree a = Leaf a | Node a (Tree a) (Tree a). And a function
19:19:48 <mgorbach> treeToList t = case t of
19:19:48 <mgorbach>   Leaf l -> [l]
19:19:48 <mgorbach>   Node n t1 t2 -> (treeToList t1) ++ [n] ++ (treeToList t2)
19:19:50 <mmorrow> dolio: i just checked myself too to be sure
19:19:54 <Makoryu> The desugaring isn't supposed to be totally accurate
19:19:58 <mgorbach> Can someone explain why treeToList does not have the usual function type signature with :: ?
19:20:04 <Makoryu> But... blah
19:20:10 <dolio> Only because you put the "baz = quux" on the same line as the closing brace.
19:20:41 <Axman6> mgorbach: they're entirely optional
19:20:51 <mmorrow> , let foo = do {x <- [0..n]; return x} n = 4 in foo
19:20:53 <lunabot>  luna: parse error on input `n'
19:21:10 <mmorrow> , let foo = do {x <- [0..n]; return x}; n = 4 in foo
19:21:12 <lunabot>  [0,1,2,3,4]
19:21:16 <mgorbach> I'm not clear on the difference between case and the regular function pattern matching
19:21:31 <dolio> The latter is sugar for the former.
19:21:31 <mmorrow> Makoryu: err, maybe we're seeing it differently in-browser
19:21:35 <mmorrow> the final line is
19:21:39 <mmorrow> }baz = quux
19:21:43 <mmorrow> in my browser
19:23:25 <Makoryu> All right, changed it
19:23:27 * mmorrow snakes Makoryu's stylesheet
19:23:29 <mmorrow> :)
19:24:02 <Makoryu> mmorrow: Very much a work in progress.
19:25:05 <mgorbach> dolio: so I could rewrite treeToList using the regular matching syntax?
19:25:21 <dolio> mgorbach: Yes.
19:25:38 <Axman6> mgorbach: i'd rewrite it, feels more clear to me
19:25:57 <hackagebot> X11 1.4.6.1 - A binding to the X11 graphics library (DonaldStewart)
19:26:08 <mmorrow> , let toList (Node x xs) = x : concatMap toList xs in toList (fix (\me -> Node () [me,me]))
19:26:10 <lunabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
19:26:30 <mmorrow> , let toList t = case t of (Node x xs) = x : concatMap toList xs in toList (fix (\me -> Node () [me,me]))
19:26:31 <ddarius> > fix (():)
19:26:32 <lunabot>  luna: parse error on input `='
19:26:32 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
19:26:48 <mmorrow> , let toList t = case t of (Node x xs) -> x : concatMap toList xs in toList (fix (\me -> Node () [me,me]))
19:26:50 <lunabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
19:28:17 <mmorrow> , levels (fix (\k n -> if n==0 then Node 0 [] else Node n [k (n-1), k (n-1)]) 4)
19:28:19 <lunabot>  [[4],[3,3],[2,2,2,2],[1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]
19:28:45 <mmorrow> , let toList (Node x xs) = x : concatMap toList xs in toList (fix (\k n -> if n==0 then Node 0 [] else Node n [k (n-1), k (n-1)]) 4)
19:28:47 <lunabot>  [4,3,2,1,0,0,1,0,0,2,1,0,0,1,0,0,3,2,1,0,0,1,0,0,2,1,0,0,1,0,0]
19:29:25 <SamB_XP> , (fix (\k n -> if n==0 then Node 0 [] else Node n [k (n-1), k (n-1)]) 4)
19:29:26 <lunabot>  Node {rootLabel = 4, subForest = [Node {rootLabel = 3, subForest = [Node ...
19:29:39 <SamB_XP> @hoogle Tree a -> String
19:29:40 <lambdabot> Data.Tree flatten :: Tree a -> [a]
19:29:40 <lambdabot> Data.Graph.Inductive.Basic postorder :: Tree a -> [a]
19:29:40 <lambdabot> Data.Graph.Inductive.Basic preorder :: Tree a -> [a]
19:29:54 <mmorrow> , (text . drawTree . fmap show) (fix (\k n -> if n==0 then Node 0 [] else Node n [k (n-1), k (n-1)]) 4)
19:29:56 <lunabot>  4
19:29:56 <lunabot>  |
19:29:56 <lunabot>  +- 3
19:30:11 <SamB_XP> aww
19:30:33 <mmorrow> lunabot does 30 lines in /msg
19:31:50 <mmorrow> ooh, better
19:31:59 <SamB_XP> <lunabot>  4
19:32:13 <mmorrow> , levels (fix (\k n -> if n==0 then Node 0 [] else let o = k (n-1) in Node n [o,o]) 4)
19:32:15 <lunabot>  [[4],[3,3],[2,2,2,2],[1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]
19:32:28 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else let o = k (n-1) in Node n [o,o]) 4))
19:32:44 <mmorrow> oo
19:32:53 <mmorrow> , 4
19:33:15 <lunabot>  19
19:33:17 <lunabot>  4
19:33:26 <mmorrow> heh, must be printing a bunch of trees :)
19:33:32 <SamB_XP> apparantly lunabot doesn't do anything else while answering a /msg
19:33:52 <mmorrow> SamB_XP: it forkIO's a thread for each irc line, and is running with -N8
19:33:55 <mmorrow> (on 8 cores)
19:34:05 <jmcarthur> yay i rendered a square with gpipe... i'm really not used to working with shaders!
19:34:24 <jmcarthur> i'm understanding the api a bit more now
19:34:25 <mmorrow> SamB_XP: not sure what the bottleneck is
19:34:31 <jmcarthur> it's actually kinda nice
19:34:45 <Saizan_> mmorrow: a lock on the irc Handle?
19:34:48 <jmcarthur> a bit low level, but i guess that is what you are asking for with a shader
19:35:42 <mmorrow> Saizan_: hmm, possibly. have to look at the bot code to refresh my memory
19:36:12 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else let o = k (n-1) in Node n [o,o]) 4))
19:36:15 <lunabot>  19
19:36:28 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else let o = k (n-1) in Node n [o,o]) 4))
19:36:30 <lunabot>  19
19:36:33 <mmorrow> grr
19:36:35 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else let o = k (n-1) in Node n [o,o]) 4))
19:36:38 <lunabot>  19
19:36:47 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else Node n [k (n-1), k (n-1)]) 4))
19:36:50 <lunabot>  93
19:37:33 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else Node n [k (n-1), k (n-1)]) 10))
19:37:36 <lunabot>  6141
19:37:38 <mmorrow> , length (vacuum (fix (\k n -> if n==0 then Node 0 [] else let o = k (n-1) in Node n [o,o]) 10))
19:37:41 <lunabot>  43
19:37:45 <mmorrow> yay for sharing
19:38:42 <mmorrow> and also a good example of why haskell needs a serialization method that preserves it
19:38:49 <aavogt> , [$ty| vacuum |]
19:38:52 <lunabot>  forall a . a -> [] ((Int, [] Int))
19:39:04 <mmorrow> , vacuum 0
19:39:07 <lunabot>  [(0,[])]
19:39:09 <mmorrow> , vacuum (0,0)
19:39:12 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
19:39:28 <aavogt> , let ones = 1:ones in vacuum ones
19:39:30 <lunabot>  [(0,[1,0]),(1,[])]
19:39:34 <mmorrow> wee
19:39:51 <mmorrow> , vacuum (fix (\me -> Node () [me,me]))
19:39:54 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
19:40:22 <SamB_XP> , vacuum "hello"#
19:40:23 <lunabot>  luna: Not in scope: `#'
19:40:26 <SamB_XP> , vacuum "hello"
19:40:28 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[...
19:40:58 <SamB_XP> ... what the heck does all of that mean ?
19:41:06 <SamB_XP> vacuum (1,2,3,4)
19:41:10 <SamB_XP> , vacuum (1,2,3,4)
19:41:13 <lunabot>  [(0,[1,2,3,4]),(1,[]),(2,[]),(3,[]),(4,[])]
19:41:25 <mmorrow> its an adjacency-list rep of the heap graph rooted at the value you give to vacuum
19:41:30 <aavogt> , vacuum vacuum
19:41:32 <lunabot>  [(0,[])]
19:41:37 <aavogt> , fix vacuum
19:42:01 <SamB_XP> mmorrow: oh, but it leaves out all the interesting parts :-(
19:42:02 <mmorrow> currently the ghc prim vacuum uses doesn't handle functions/partial-apps, but working on that
19:42:18 <mmorrow> SamB_XP: the real vacuum gives all the interesting bits
19:42:23 <SamB_XP> ah, okay
19:42:54 <mmorrow> SamB_XP: this `vacuum' fun is actually the very first working one i had, with the entire implem in one module complete with bugs and all :)
19:43:14 <mmorrow> there's a "vacuumLazy" now too
19:43:22 <mmorrow> (int-e++)
19:44:22 <lunabot>  Killed.
19:46:57 <Cale> If there were a way to reconstruct an expression precisely without forcing its evaluation at all, it would make the ultimate debugging tool :)
19:47:46 <jmcarthur> i would love to see an animation of an stg machine
19:49:35 <mmorrow> Cale: there is, just need to extend unpackClosure# to handle the various function closure types/etc
19:50:31 <mmorrow> Cale: and now that (in 6.12) ghc has foreign import prim, it's easy to do so (wrt logistics)
19:51:49 <mmorrow> Cale: well, actually there's one missing piece for that. also the info tables of functions would need to be extended to hold a char* of their name, like constructors currently have
19:52:56 <mmorrow> (and if (when!) that's done, it'll finally be possible to serialize arbitrary haskell closures to disk in a arch-indep way)
19:53:27 <mmorrow> (char* in function infotabs, along with various other minor misc)
19:55:49 <mmorrow> the deserialization would require some relocation, but in principle would be easy (assuming the deserializer has the info it needs to map symbolic names of functions to their current runtime address w/in the current proc, which is doable someway)
19:56:27 <mmorrow> so you'd need the same versions of libs/etc
19:56:39 <mmorrow> but that's unavoidable with something like this
19:57:22 <mmorrow> (unless you start including machine code, or bytecode in the serialized data)
19:58:47 <Saizan_> the char* would a symbol like the one exposed from .o files, right?
19:59:18 <mmorrow> Saizan_: right, or at least something that you could deduce the sym in the .o file from
20:00:58 <mmorrow> well, if all you're ever doing is dynamic runtime deserialization, you'd just need the char* to have the info the other runtime needs to find the corresponding address in that address space, but it might as well be the .o sym-name (since there'd be a bunch of functions that aren't present in the source-level code)
20:03:17 <mgorbach> dolio: Thanks for the help.
20:03:41 <recurs|ve> Do I need to install haskell in order to build haskell?
20:03:45 <mgorbach> #haskell is rather nice for noobs in comparison to channels for other languages :)
20:04:02 <Axman6> mgorbach: the haskell community is one of the nicest around
20:04:20 <ddarius> recurs|ve: You do to build GHC.
20:04:22 <Axman6> recurs|ve: you'll need a haskell compiler or interpreter to use haskell, yes
20:04:27 <wdonnelly> recurs|ve: appropriate name, given the question
20:05:05 <lispy> You could always evaluate the code by hand assuming you understand the language
20:05:20 <recurs|ve> Thanks guys.  I was hoping I could build haskell without needing a haskell compiler, kind of like erlang
20:05:21 <lispy> But, that seems like something you'd only do a few times before just getting a compiler/interpreter
20:05:58 <Axman6> recurs|ve: just install one of the precompiled ones from haskell.org/ghc
20:06:00 <lispy> recurs|ve: well, maybe you can build hugs without a Haskell compiler, I think it's written in C
20:06:04 <Veinor> lispy: I'm so extreme I can turn haskell straight into ASM with my mind
20:06:22 <lispy> Veinor: that's amazing.
20:06:36 <Veinor> it is a gift.
20:06:45 <recurs|ve> Thats alright, I'll just install a precompiled one.  Just don't like most precompiled binaries.
20:06:53 <Axman6> Veinor: map isJust [Just 1, Nothing, Just 0] gogogo!
20:07:28 <Veinor> :P
20:07:34 <Xaphiosis> hi everyone... I'm trying to hack a binding for fluidsynth using c2hs (this is my first time doing a binding) and I'm stuck on trying to add automatic garbage collection to returned "abstract" struct pointers
20:07:52 <Xaphiosis> and I don't know how to glue these things together
20:08:28 <Xaphiosis> google has proven no help for the past two hours, so my friend suggested I bother people here... anyone have experience with this?
20:08:47 <Axman6> Xaphiosis: have you tried the chapter on the ffi in RWH?
20:08:54 <Axman6> it talks about finalisers
20:08:59 <Xaphiosis> it's open on my desk
20:09:03 <sjanssen> Xaphiosis: ForeignPtr?
20:09:05 <Cale> (Or the FFI spec, which is quite readable)
20:09:09 <mmorrow> Xaphiosis: use a ForeignPtr finalizer
20:09:18 <Xaphiosis> "memory management: let the garbage collector do the work"
20:09:35 <Xaphiosis> well, yeah, but say I do this:
20:09:35 <Xaphiosis> {# pointer *fluid_event_t as Event foreign newtype #}
20:09:50 <Xaphiosis> that'll give me a newtype with a ForeignPtr inside it
20:10:08 <Xaphiosis> then if I say:  foreign import new_fluid_event :: IO Event
20:10:37 <Cale> What do you need to do when the pointer is GC'd?
20:10:56 * blackdog watches attentively - Hubris leaks like a sieve currently
20:11:00 <sjanssen> > kanye "void *" "ForeignPtr ()" "pointer type"
20:11:01 <lambdabot>   "YO VOID *, I'M REALLY HAPPY FOR YOU AND IMMA LET YOU FINISH, BUT FOREIGNPT...
20:11:09 <sjanssen> hmm
20:11:15 <Xaphiosis> well, there's a pair of functions:
20:11:15 <Xaphiosis> fluid_event_t* new_fluid_event(void);
20:11:15 <Xaphiosis> void delete_fluid_event(fluid_event_t* evt);
20:11:17 <mmorrow> Xaphiosis: so you'd need to wrap new_fluid_event in another function, that gets the ptr from the C function, turns it into a ForeignPtr (if it isn't one already), then attaches the appropriate finalizer (which is a FunPtr to a C function) to that ForeignPtr
20:11:17 <Cale> :t Foreign.ForeignPtr.addForeignPtrFinalizer
20:11:18 <lambdabot> forall a. GHC.ForeignPtr.FinalizerPtr a -> GHC.ForeignPtr.ForeignPtr a -> IO ()
20:11:57 <Xaphiosis> oh... I was hoping c2hs could wrap that automatically :(
20:12:25 <Cale> Oh, perhaps there's a way
20:12:36 <mmorrow> Xaphiosis: i'm not very familiar with c2hs, there may be some way
20:12:52 <Xaphiosis> because if it creates newtype Event = Event (ForeignPtr (Event))
20:13:21 <mmorrow> Xaphiosis: i'm guessing that that'll just hand you a MallocPtr variant of a ForeignPtr (i.e. without an attached finalizer)
20:13:25 <Xaphiosis> then digging around in there looks scary
20:13:27 <mmorrow> @src ForeignPtr
20:13:28 <lambdabot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
20:13:32 <mmorrow> @src ForeignPtrContents
20:13:33 <lambdabot> data ForeignPtrContents = PlainForeignPtr !(IORef [IO ()])
20:13:33 <lambdabot>                         | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
20:13:33 <lambdabot>                         | PlainPtr  (MutableByteArray# RealWorld)
20:13:43 <mmorrow> err, i meant PlainPtr
20:13:54 <Cale> mmorrow: It's a little surprising that the @src database has those
20:14:00 <mmorrow> Cale: heh, yeah
20:14:00 <Axman6> indeed
20:14:27 <Xaphiosis> hmm
20:15:00 <Xaphiosis> so when I wrap the construction function with:  foreign import new_fluid_event :: IO Event
20:15:12 <mmorrow> Xaphiosis: (also note that that @src isn't current, fyi (but the current def is exactly that plus some other field in some of the cons that's irrelevant wrt this))
20:15:18 <Xaphiosis> I need to wrap it in another function that will add a finaliser to the ForeignPtr?
20:15:27 <mmorrow> Xaphiosis: right
20:16:00 <mmorrow> addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
20:16:05 <Xaphiosis> well, I guess that's not a tragedy
20:16:14 <mmorrow> type FinalizerPtr a = FunPtr (Ptr a -> IO ())
20:16:22 <mmorrow> yeah, super easy
20:16:50 <Xaphiosis> heh, maybe someone will add that to c2hs one day
20:17:14 <newsham> what is {-# SOURCE #-}
20:17:15 <Xaphiosis> thank you mmorrow
20:17:34 <mmorrow> no problem
20:18:23 <Xaphiosis> the c2hs documentation misleads you into believing you could say something like "this C function gives you back an Event, which I told you was a ForeignPtr-based thing, so here destroy it with this other C function when you're done"
20:19:04 <Makoryu> newsham: A pragma for dealing with circular module dependencies, IIRC
20:19:15 <Cale> newsham: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
20:19:29 <mmorrow> Xaphiosis: (i'd double check that c2hs isn't indeed handling attacking the finalizer)
20:19:32 <mmorrow> heh
20:19:39 <mmorrow> s/attacking/attaching/
20:19:54 <newsham> ty
20:20:13 <Xaphiosis> well, unless there's an incantation I'm not aware of, it can't, as I haven't informed it which function is the finalizer
20:20:51 <Xaphiosis> but I don't know if I can inform it, or whether that's a limitation I need to work around... your advice seems to point to the latter, so I will work around it
20:20:53 <mmorrow> Xaphiosis: ah, ok i was wondering about that
20:21:12 <mmorrow> Xaphiosis: yeah, if you're not telling it which finalizer, then ..
20:22:25 <Xaphiosis> yeah, I think you're right. needs a wrapper function
20:23:29 <Xaphiosis> thanks
20:31:08 <lispy> Is this a place where you should use bracket?
20:31:26 <lispy> That is, instead of finalizing, you scope or bracket the usage
20:31:33 <lispy> ?hoogle bracket
20:31:33 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:31:33 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:31:33 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:32:11 <Xaphiosis> well, c2hs also generates this, but I'm not clear on why: withEvent (Event fptr) = withForeignPtr fptr
20:33:03 <Xaphiosis> but yeah, I can use bracket too... my question was more along the lines of c2hs documentation and capabilities/limitations
20:34:04 <mmorrow> bracket would more be useful for something like
20:34:16 <mmorrow> bracket malloc free (\(p::Ptr a) -> ...)
20:34:52 <mmorrow> but since the ForeignPtr has the attached finalizer, you can rely on the GC to free it when the ptr becomes unreachable from haskell
20:35:17 <SamB_XP> well, at some point
20:35:19 <SamB_XP> hopefully
20:35:28 <mmorrow> right, when aside
20:35:35 <SamB_XP> if you don't run out of RAM and get OOM killed before that ;-P
20:35:58 <mmorrow> in which case it gets freed anyway! ;)
20:36:30 <mmorrow> along with all you precious computation results that've been churning away for hours!
20:38:18 <ezyang> I am about to write a brute force search of two state, three symbol turing machines to find a turing machine that will calculate whether or not parentheses are matched or not.
20:38:37 <ezyang> Is there anything that Haskell gives me that I should know about before embarking on this journey?
20:41:57 <Xaphiosis> one more FFI question for haskell... what's the typical convention for handling NULL when dealing with functions that create a new something and give you back a pointer to it?
20:42:21 <Xaphiosis> I'm already in IO, should I be using Maybe? currently I just barf with error
20:44:23 <aavogt> Xaphiosis: use ErrorT or MaybeT IO?
20:44:38 <mmorrow> Saizan_: this looks really interesting/possible-directly-applicable-somehow http://pauillac.inria.fr/~xleroy/bibrefs/Leroy-modular-modules.html
20:44:50 <mmorrow> Xaphiosis: Maybe usually
20:45:21 <Xaphiosis> Maybe it is
20:45:21 <mmorrow> (assuming that NULL in this case maps to the meaning of Nothing, etc)
20:45:28 <ezyang> Hmm, what's the best way to implement an infinite list in two directions?
20:45:38 <mmorrow> ezyang: a list zipper?
20:45:44 <Xaphiosis> yes, that's right, NULL is Nothing
20:45:48 <SamB_XP> yeah, a zipper
20:45:49 <mmorrow> ([a],a,[a])
20:46:03 <SamB_XP> yeah, either that, or ([a],a,[a])
20:46:07 <SamB_XP> depending er.
20:46:13 <SamB_XP> yeah, either that, or ([a],[a])
20:46:15 <ezyang> ok, ([a], a, [a]) is what I thought up of
20:46:17 <ezyang> what's a list zipper?
20:46:22 <SamB_XP> ezyang: that ;-)
20:46:37 <aavogt> isn't [a] technically capable of being infinite in two directions?
20:46:40 <SamB_XP> depends on if you want to focus a specific element or a place between elements
20:46:50 <ezyang> aha
20:46:52 <SamB_XP> aavogt: just one? not really.
20:47:15 <ezyang> SamB_XP: I think [a], a, [a] will be a little more obvious about what the turing machine head is pointed at
20:47:18 <aavogt> > repeat () ++ repeat () -- is this single, or bidirectionally infinite?
20:47:19 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
20:47:31 <SamB_XP> ezyang: ah, yes, certainly
20:47:45 <SamB_XP> aavogt: uni-directionally
20:47:49 <mmorrow> aavogt: i think the distinction is logically or physically bi-directional
20:48:02 <mmorrow> anything can be logically anything pretty much
20:48:02 <SamB_XP> > repeat True ++ repeat False
20:48:03 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
20:49:26 <mmorrow> , (zip`ap`tail) (repeat ())
20:49:27 <lunabot>  [((),()),((),()),((),()),((),()),((),()),((),()),((),()),((),()),((),()),...
20:49:39 <mmorrow> , unzip ((zip`ap`tail) (repeat ()))
20:49:41 <lunabot>  ([(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
21:03:07 <ezyang> "..." : symbols' ++ ["..."]
21:03:15 <ezyang> there's gotta be a better way
21:04:26 <Gracenotes> well... if you're using a linked list... that's pretty much it...
21:05:36 <mmorrow> Saizan_: just read what i think is a good way to say it: to have a proper module system, you need at *least* (ie, not none (/me glares at haskell)) one of (1) dependent types (==> e.g. cayenne encodes modules w/in the language itself), or (2) a _separate_ module language
21:06:07 <mmorrow> it's simply not possible otherwise
21:08:03 <Saizan_> mmorrow: i'm not sure (1) is sufficient
21:08:10 <Gracenotes> although, it can be phrased (liftM2 (.) =<< flip $ (++)) ["..."], pointlessly. which is pretty pointless.
21:09:41 <mmorrow> Saizan_: yeah, me neither. i'm not sure what qualification (1) would need to be true, but i'm primarily pursuing (2) with the hope of some day being able to write 50-module haskell apps without dreading making changes that'll ripple through everything
21:11:33 <blackdog> mmorrow: surely the point of the type system is to make you check out the places that changes might have invalidated your assumptions?
21:11:51 <mmorrow> i feel like the module system can be almost entirely independent of the base-language
21:12:32 <mmorrow> blackdog: the point of the module system is to be able to type functions that map modules to modules
21:12:43 <Saizan_> personally i think you need something separate from the expression language to deal with namespaces nicely (like an open keyword) but i'd like to avoid a separate language for the structures
21:13:26 <Saizan_> since you tend to want initializations and such
21:13:42 <mmorrow> yeah, true
21:14:19 <Saizan_> or things like edwardk's reflection
21:14:20 <mmorrow> blackdog: (and to be able to type the modules themselves as wholes)
21:15:19 <blackdog> mmorrow: so something like ML's module system? didn't someone show that typeclasses and the module language of ML had the same power in some sense?
21:15:47 <blackdog> (don't know how it works out in practice, i haven't worked on many big haskell projects)
21:18:18 <Saizan_> blackdog: the encoding is not very nice in either direction, imo
21:19:52 <mmorrow> blackdog: and also i'm really looking for something that's at a higher level than anything expressible in haskell, ie that is able to manipulate the module environment/landscape that the type system even sees in the first place
21:20:27 <mmorrow> so it needs to be _outside_ of the type system
21:20:34 <mmorrow> its own system
21:21:02 <mmorrow> the base-lang could just as well be C or visual basic
21:21:26 <blackdog> what kind of operations would you want on modules?
21:21:51 <Axman6> blackdog: o/
21:22:41 <blackdog> Axman6: g'day alex. hope you got home ok eventually - we ended up in Newtown discussing the failings of laziness (treason!)
21:22:52 <Axman6> heh, sounds good :)
21:23:25 <mmorrow> blackdog: that the type of a module/its signature exist separate from whatever module happens to match that sig (with some subset of its defs), and then to write functors that take some module M with signature S and produce another module N with signature T
21:23:36 <Axman6> yeah i had a good trip. there was a crash on the M5, so we went home via the princes highway, all the way to woolongong, then along to canberra
21:24:59 <blackdog> mmorrow: so you do involve the haskell type system there somewhere? or am i misinterpreting what you mean by a 'sig'?
21:25:18 <Saizan_> mmorrow: that doesn't seem like it'd need to be separate from the type system
21:25:29 <ivanm> blackdog: did you manage to come up with any failings? :p
21:25:49 <blackdog> ivanm: inability to reason formally about space leaks
21:25:57 <mmorrow> Saizan_, blackdog: the haskell type system'd make sure that each module's contents are well-typed, etc
21:26:05 <ivanm> blackdog: bah, that's an engineering problem :p
21:26:37 <blackdog> ivanm: well, yeah. you got a real turing machine sitting around somewhere? the rest of us compute with real, limited machines:)
21:26:53 <Makoryu> blackdog: Ah, you're still trying to decide which FPL to use for your startup?
21:26:59 <ivanm> blackdog: heh
21:27:05 <mmorrow> Saizan_: well, the whole concrete-by-default/abstract-by-default thing, along with type sharing between two diff sigs with abstract types, and translucent sigs, etc
21:27:42 <blackdog> Makoryu: ... my startup? I tried to do something with predictive, but that was just for prototyping - it'd have to go down to C eventually.
21:27:53 <mmorrow> Saizan_: i dunno know the details yet though, i'm trying to figure them out :)
21:28:23 <blackdog> think i'm pretty much sold on Haskell by now. I agree with Ben Lippmeier that laziness is great but usually the wrong default
21:28:43 <Axman6> blackdog: so, any news for me regarding that email?
21:28:52 <Cale> blackdog: If you know that it's lazy evaluation, it's possible to reason formally about space.
21:29:07 <Cale> blackdog: (but if it's just nonstrict semantics, then you can't)
21:29:23 <Makoryu> blackdog: Ah :)
21:29:48 <blackdog> Cale: the distinction is that nonstrict may or may not evaluate more than it needs, right? i sometimes get fuzzy on the distinction.
21:29:56 <blackdog> Axman6: still waiting.
21:30:02 <mmorrow> Saizan_: and also, the type of the resulting structure produced by functor application to another structure depends on the value of the structure the functor's applied to
21:30:18 <Axman6> blackdog: :o
21:30:46 <Cale> "Nonstrict semantics" doesn't imply anything about operational behaviour and many evaluation orders will satisfy it. (Almost anything which isn't "too strict")
21:31:44 <mmorrow> Saizan_: or something
21:31:45 <blackdog> Cale: ok. so how do you reason about it in a formal sense when it's lazy? I'm thinking of the simple example of getting the average of a huge lazy list of numbers, for instance
21:31:52 <blackdog> o
21:32:02 <Saizan_> mmorrow: i guess that depends on what you mean by value and what kind of functors you allow, however you need some dep. types or similar to encode the dependency
21:32:04 <blackdog> obviously the type system doesn't help there
21:32:05 <Cale> blackdog: Well, lazy evaluation tells you exactly what order you evaluate the terms in.
21:32:29 <Cale> blackdog: So you reason about the sizes of the expression as reduction happens.
21:33:15 <mmorrow> Saizan_: right, and having just realized this fact by reading something led me to those (1) and (2)
21:33:27 <blackdog> Cale: i wonder if that'd be easily automatable. Knowing about potential space leaks would be a really useful engineering tool - has anyone worked on that?
21:33:29 <Saizan_> mmorrow: this course looks quite nice http://www.cs.cmu.edu/~rwh/courses/modules/index.htm to see the state of the art, also the module system's chapter on attapl
21:33:30 <Cale> Let's look at  avg xs = sum xs / length xs
21:33:46 <Cale> avg [1..10]
21:34:06 <mmorrow> Saizan_: ooh, nice link
21:34:14 <Cale> -> let xs = [1..10] in sum xs / length xs
21:35:10 <Cale> Let's assume that first parameters are first, so we evaluate the sum first
21:36:06 <Cale> I could fill in all the intermediate steps, but the basic point is that we'll get to something which looks like:
21:36:24 <Cale> -> let xs = 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : 10 : [] in 55 / length xs
21:36:58 <Cale> xs never gets garbage collected, since it remains in scope the entire time that the sum is being computed
21:37:09 <Cale> and that's where your space leak comes from
21:37:17 <mmorrow> Saizan_: the way i see it currently (it := defining/implemented some form of module system that can map haskell modules around) boils down to, (1) figuring out exactly what it would do, (2) figuring out what it means to typecheck such a thing, (3) figuring out the algo to typecheck it, (4) figuring out how to integrate what its doing with what haskell's typechecker is doing, (5) "trivial" matter of coding it all. voila! :)
21:39:32 <Cale> blackdog: As to automatically discovering when something will be held on to longer than it should, if you could analyse it accurately, you could probably produce some pretty nice automatic optimisations too.
21:39:41 <Saizan_> mmorrow: no ??? and PROFIT! steps?:)
21:40:01 <Cale> blackdog: The key to removing the space leak in that avg case is in some sense to "parallelise" the computation of sum and length. (It's okay if it's just interleaved)
21:40:18 <Cale> oh, he quit...
21:42:07 <Cale> I wonder if there's anything GHC could heuristically do for cases like that. Is there any deforestation/fusion mechanism which corrects that space leak?
21:43:05 <Cale> Actually, interesting point about that space leak is that it has nothing to do with lazy evaluation at all.
21:43:16 <Cale> Apart from the sharing aspect.
21:43:23 <Cale> But you have the same issue in a strict language.
21:43:36 <Cale> blackdog: You're back :)
21:43:45 <blackdog> Cale: sorry about that, connectivity problemss
21:43:50 <Makoryu> blackdog: Yo, you missed a very interesting conversation that Cale had with himself
21:43:55 <Cale> hehe
21:44:02 <Cale> What was the last line you saw?
21:44:24 <blackdog> lost all of it now :/ i'll go check the haskell logs
21:44:38 <Cale> I could also paste it to you if that doesn't work
21:44:51 <blackdog> ah, that'd be better
21:44:59 <blackdog> save me chasing it down on tunes.org
21:45:17 <mmorrow> Saizan_: here's one thing i'd like to be able to do http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4265#a4265
21:45:31 <mmorrow> Saizan_: and PROFIT!!!@2
21:46:16 <blackdog> right, up to date:)
21:46:28 <blackdog> Cale: so, yeah, i can follow it in the small cases
21:46:35 <Saizan_> Cale: there was a blogpost where they expressed both sum and length as instances of a Foldl structure with was an Applicative, so avg = applyFoldl (liftA2 (/) sum length)
21:47:08 <Cale> Saizan_: Yeah, I saw that, I wonder if it's automatable.
21:47:10 <Cale> Maybe in conjunction with stream fusion somehow.
21:47:27 <blackdog> what i was getting at is that I can use the type system to assure myself that I won't use IO inappropriately, or index an array out of bounds
21:47:40 <mmorrow> Saizan_: err, Group should be its own signature, then the functor should be something like CanHazGroupFromTwoMonoids
21:47:52 <blackdog> but i can't do the same with runtime measures like memory space
21:48:27 <Saizan_> mmorrow: you should also talk with edwardk about kata :)
21:48:46 <blackdog> now, if GHC sometimes optimises it away, that's great, but it's hard to rely on - Manuel was talking about how hard it is to keep his generics stuff up to date with GHC and Rules.
21:48:50 <Saizan_> (unless you did already)
21:49:05 <Cale> blackdog: This particular example really has nothing to do with lazy evaluation, and you can write the exact same space leak in a strict language. It's just that the duplication of xs is defeating the space benefit of lazy evaluation.
21:49:15 <Cale> Somehow I'm really lagged now.
21:49:55 <Cale> blackdog: Oh, well, certainly, a type system for space or time behaviour would be awesome.
21:50:18 <mmorrow> Saizan_: err, and also i mean s/Group/Ring/ and one of the monoids be a Group..
21:50:24 <Cale> blackdog: But it's harder than termination checking.
21:50:25 <mmorrow> but you get the idea :)
21:50:32 <Saizan_> i got it, yeah :)
21:50:49 <Cale> actually...
21:50:49 <Makoryu> Goddammit dons
21:50:55 <blackdog> Cale: that's only to do it precisely though, right? Maybe a conservative implementation would be easier?
21:51:04 <mmorrow> Saizan_: yeah, i've been meaning to ask edwardk how kata is going
21:51:12 <Cale> blackdog: I wonder if it's not easier than termination checking in some cases.
21:52:09 <blackdog> if you're conservative, you could just mark the areas where blowups are possible, and try to get as close as you can to accurate
21:52:26 <bryan`> Is there a "right way" to implement rings and other algebraic structures in haskell so that you can use + and * without running into ambiguity problems? I would like to implement a class of rings for which abs, signum, and fromInteger make no sense; thus, subclassing Num is undesireable. Is just using differently named operators the best way to go?
21:52:30 <Cale> blackdog: Since if the programmer tells you "I really want this to run in O(n) time." it's way easier to refute that than "I really want this to terminate."
21:52:39 <blackdog> obviously a precise version solves termination checking
21:52:44 <blackdog> yeah
21:53:19 <Cale> bryan`: Well, you can write instances of Num with warning labels on them. It's a bit unfortunate.
21:53:20 <Saizan_> bryan`: you can use the module system to hide/rename functions from the Prelude
21:53:45 <blackdog> so a system of annotations, maybe? hm. Ben Lippmeier mentioned the Hume work when i talked to him about this - there you have really strong bounds, because you're only working with either state machines or primitive recursion
21:54:02 <Cale> Unfortunately, if you override the prelude definitions with clever module imports, your users will have to do that too.
21:54:39 <blackdog> bryan`: the number system is a bit blunt in some ways. i think there are a few proposals to change it.
21:54:58 <bryan`> Hmm, is renaming/hiding looked down upon, or is it considered good practice?
21:55:38 <bryan`> blackdog: I saw that while googling this stuff; do you know how likely it will change?
21:55:41 <Saizan_> it's a bit painful if you do it with things from the Prelude or other core modules
21:55:45 <Cale> blackdog: Perhaps. I would settle for GHC just getting it right more of the time, without it becoming too hard to put an upper bound on the space or time.
21:56:40 <blackdog> bryan`: not a clue. it's ugly, but you're probably better off just using different operators.
21:57:21 <bryan`> blackdog: Okay, I'll just do that. Shouldn't be too bad. Thanks (to everyone)!
21:58:12 <Cale> bryan`: Which ring?
21:58:20 <Cale> Oh damn, another 30 seconds worth of lag...
21:58:55 <blackdog> Cale: jeez, your net access is worse than mine:)
21:59:30 <bryan`> Cale: Its actually a nonassociative polynomial ring called a gametic algebra. Pretty obscure stuff; I did my undergrad thesis on them.
21:59:50 <Cale> blackdog: It's usually not so bad. It coughs for a long time after whenever I open a few too many connections, like if I'm on a torrent for a while.
22:00:08 <mmorrow> Saizan_: sorted it out ;) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4265#a4267
22:00:33 <mmorrow> Cale: stuff like that paste would be handay
22:00:53 <mmorrow> gah!, s/type G/type R/ in MkRing
22:02:09 <mmorrow> that use of functors/sigs/structures is almost like explicitly manipulating class instance dictionaries statically at compile-time or something
22:02:14 <Cale> One approach that I've found rather handy was defining a general monoid ring, and then constructing other rings in terms of that.
22:02:53 <mmorrow> Cale: oh right, i recall that one module you've got re: monoid rings. link?
22:03:02 <Cale> (I just made it an instance of Num, ignoring the bits which I didn't like to define in Num ;)
22:03:12 <Cale> I can repaste it :)
22:03:24 <mmorrow> Cale: please do :)
22:04:13 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4269#a4269
22:05:10 <Cale> and then elsewhere I had  type Polynomial n = MonoidRing n Partition
22:05:56 <Cale> (where Partition gives the monoid of integer partitions under "concatenation")
22:06:04 <bryan`> Cale: Thanks for posting! Its great to see how someone with (I assume) more experience would do this. Also, I didn't think about the monoid approach
22:07:26 <ivanm> which versions of ghc came with base >=2 && < 2.2 ?
22:07:34 <ivanm> (that is, the ones that seemed to have bytestring as part of base)
22:07:38 * Cale looks at the definition of a gametic algebra.
22:08:21 <mmorrow> and here's the ring of integers http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4265#a4270
22:08:34 <mmorrow> Cale: nice
22:09:19 <Saizan_> uhm, foldl f z xs * foldl g w ys = uncurry (*) . foldl (\(a,b) (x,y) -> (f a x,g a y) $ zip xs ys
22:09:23 <Saizan_> right?
22:09:40 <dolio> @remember JonHarrop About 40 negative reviews of [Real World Haskell] were posted on Reddit.
22:09:40 <lambdabot> It is forever etched in my memory.
22:09:51 <ivanm> dolio: oh? where did he say that?
22:10:09 <ivanm> and what's the bet the 40 negative reviews were by people who didn't like Haskell in the first place... >_>
22:10:12 <dolio> comp.lang.functional
22:10:23 <ivanm> or tried to use RWH to learn Haskell from scratch
22:10:27 <blackdog> dolio: is that massively surprising? Jon Harrop is the best sort of enemy to have.
22:10:45 <mmorrow> Saizan_: or even    foldl (\o (x,y) -> o * x * y) (zip xs ys)
22:10:48 <Saizan_> ivanm, blackdog: @remember is for funny quotes :)
22:10:55 <ivanm> Saizan_: yes, I know...
22:11:08 <mmorrow> *foldl (\o (x,y) -> o * x * y) (z*w) (zip xs ys)
22:11:13 <ivanm> I was commenting on the quote...
22:11:28 <Saizan_> mmorrow: where are f and g gone?
22:11:34 <mmorrow> err, right
22:11:56 <mmorrow> Saizan_: gah, yeah so i guess that's not valid actually
22:12:00 <Saizan_> yeah
22:12:25 <Saizan_> (*) could be A -> B -> C
22:12:38 <Saizan_> for distinct A, B and C
22:14:34 <jargonjustin> I'm trying to setup a Haskell project to build, and was wondering what's a good way to setup some QuickCheck and HUnit tests?
22:15:08 <blackdog> jargonjustin: do you mean how to coordinate running the tests?
22:15:23 <mmorrow> Saizan_: the ideal situation would be for the compiler to figure out what what you're really trying to say is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4271#a4271
22:15:44 <jargonjustin> blackdog: Well, I don't mind kicking them off manually and I know how to set it up with darcs, but I'm really just trying to get them to run and generate coverage data without duplicating all of my build settings
22:15:47 <blackdog> i use Pete Gammie's TBC framework, but you can also just write your own main file that calls all of the tests in order
22:15:51 <Cale> bryan`: So where do these gametic algebras show up? This multiplication looks like it ought to have some nice combinatorial interpretation.
22:15:58 <bryan`> \msg Cale I took the basic definition from http://tinylink.com/?l8U7IsC7MB (pdf) and generalized it to work over any ring (not just a field). The real topic of my thesis were evolution algebras, which are a particular kind of gametic algebra.
22:16:08 <bryan`> shoot, wrong slash...
22:16:39 <jargonjustin> blackdog: any points to TBC
22:16:41 <dolio> ivanm: He also notes that 40% (of 5) of reviews on amazon.co.uk are negative.
22:16:47 <blackdog> jargonjustin: it's a bit of a sore point - the test hook in cabal is basically worthless, so it's really hard to set up tests in a standard way
22:16:55 <blackdog> it's on hackage
22:17:03 <jargonjustin> blackdog, thanks, I'll take a look
22:17:11 <blackdog> max bolingbroke's test-framework is also good in different ways
22:18:03 <ivanm> dolio: heh
22:18:23 <Cale> bryan`: Ah, okay, that description is helping to understand the more abstract one from the top of Suk Im Yoon's paper.
22:18:34 <Saizan_> mmorrow: i figured you could get there by stream-fusion on the RHS foldl
22:18:57 <dolio> Definitely shows the sort of rigorous mathematical procedure that makes his benchmarks so compelling. :)
22:21:19 <Cale> bryan`: Hmm... interesting that it turns around and defines it by essentially putting bounds on the connection coefficients though :)
22:21:30 <Cale> Maybe they're not quite the same thing after all :)
22:22:05 <bryan`> Cale: They show up in (as you probably saw) genetic algebras; looking at using algebra to model genetics, though they are definitely interesting outside of that application. I'm sure it does have a nice combinatorial interpretation, though I haven't looked at that. I found nice correspondances with graph theory and formal grammars however. Are you a mathematician?
22:22:19 <Cale> bryan`: Yeah
22:22:48 <Saizan_> mmorrow: ugh, actually my equation (nor your code) is correct because of the short-cutting behaviour of zip
22:23:40 <bryan`> Cale: The bounds are almost completely unnecessary to their properties too. I think Reed's wanted to begin with a more concrete application of algebra to genetics before getting into the really abstract stuff. What do you study?
22:24:00 <mmorrow> Saizan_: i think in the generation case of fusing stuff you need to do almost partial eval, but stream-fusion iirc could maybe do it with static-arg transform and/or specialization of partial apps
22:24:07 <mmorrow> s/generation/general/
22:24:22 <mmorrow> Saizan_: ooh, right
22:24:45 <Cale> Mostly algebraic combinatorics and category theory, well, I like places where abstract algebra meets up with more concrete or geometric things. :)
22:25:02 <mmorrow> so maybe you'd add two more loops you might continue to, depending on whether you have more xs's or ys's
22:25:16 <jargonjustin> blackdog, TBC looks like it requires cabal 1.7+, is that released? I can't see a version newer than the 1.6.0.3 I have installed.
22:26:43 <Saizan_> jargonjustin: 1.7 won't be released, 1.8 will come with ghc-6.12
22:26:45 <mmorrow> Saizan_: i'm currently trying to figure out what's really happening in this actually, which is directly related to that foldl*foldl expression, http://portal.acm.org/citation.cfm?id=1134016
22:27:13 <jargonjustin> Hmm, looks like using a TBC isn't going to work then.
22:30:44 <Nereid_> Saizan_: and when is that? :(
22:31:15 <dolio> 6.12 has already been delayed longer than expected.
22:31:44 <ezyang> Suppose I have a computation a -> a, and an end condition a -> Bool. I'd like to run this computation repeatedly until some n instructions or when the end condition is met.
22:31:51 <ezyang> should I use a monad, or not?
22:32:31 <Axman6> dolio: :(
22:32:51 <Saizan_> ezyang: direct recursion seems to be enough
22:32:57 <ezyang> ok.
22:33:58 <Saizan_> ?type \f x -> last . take n . takeWhile (not . p) . iterate f $ x
22:33:59 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
22:34:00 <lambdabot>     In the first argument of `take', namely `n'
22:34:00 <lambdabot>     In the first argument of `(.)', namely `take n'
22:34:15 <Saizan_> ?type \f x n -> last . take n . takeWhile (not . p) . iterate f $ x
22:34:16 <lambdabot>     Couldn't match expected type `a -> Bool'
22:34:16 <lambdabot>            against inferred type `Expr'
22:34:16 <lambdabot>     In the second argument of `(.)', namely `p'
22:34:25 <Saizan_> ?type \f x n p -> last . take n . takeWhile (not . p) . iterate f $ x
22:34:25 <blackdog> jargonjustin: argh, had forgotten about that. yeah, it does. forget why
22:34:26 <dolio> @type \p f n -> until ((==0) *** p >>> uncurry (||)) (subtract 1 *** f) . (,) n
22:34:26 <lambdabot> forall a. (a -> a) -> a -> Int -> (a -> Bool) -> a
22:34:27 <lambdabot> forall b b'. (Num b) => (b' -> Bool) -> (b' -> b') -> b -> b' -> (b, b')
22:34:55 <dolio> That's a lot of bs.
22:35:08 <ezyang> whoa arrows
22:36:09 <mmorrow> Saizan_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4271#a4273
22:36:23 <Saizan_> > let until f x n p = last . take n . takeWhile (not . p) . iterate f $ x in until (+1) 0 4 (> 20)
22:36:24 <lambdabot>   3
22:36:30 <Saizan_> > let until f x n p = last . take n . takeWhile (not . p) . iterate f $ x in until (+1) 0 100 (> 20)
22:36:31 <lambdabot>   20
22:37:14 <mmorrow> Saizan_: err, go should jump to go{1,2} not RET
22:37:20 <dolio> mmorrow: Why would you care about fusing folds over two different lists into one function?
22:37:30 <bryan`> Cale: Sweet! Do you have any papers I could look at? I just received my undergrad degree and am getting into category theory and love looking at all the beautiful applications of abstract algebra.
22:37:52 <ezyang> why is the takeWhile to the right of take n?
22:38:52 <ezyang> or does order not matter?
22:39:01 <mmorrow> dolio: to be able to do some of crapload of loop optims that're out there
22:39:18 <Cale> bryan`: see PM... I'm really super-lagged.
22:39:35 <Axman6> Saizan_: takeWhile (not . p) = dropWhile p?
22:39:35 <Saizan_> i started from the "avg xs = sum xs / length xs" actually, but thought the RULE could be more general
22:39:36 <Cale> bryan`: Looks like the bubble of lag is bursting now though :)
22:39:37 <mmorrow> dolio: also, having jumps to static labels'll get predicted
22:40:07 <mmorrow> dolio: currently, ghc'll do an indirect jump _for every iteration_
22:40:12 <Cale> bryan`: hmm... maybe you're lagged too?
22:40:13 <mmorrow> :(
22:40:35 <ezyang> hmm, ick
22:40:47 <mmorrow> dolio: :o http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4219
22:40:54 <dolio> Turning two loops into one loop (or, three loops) will optimize better than optimizing two separate loops?
22:41:12 <mmorrow> dolio: oh, well that's a separate issue right
22:42:02 <mmorrow> dolio: if we knew the enclosing context of that expression, we probably could decide
22:42:09 <jargonjustin> Is there a way to have a cabal Executable target use the same Build-Depends and Extra-Libraries as a Library target?
22:42:10 <bryan`> Cale: Mmm... I don't think I got a PM. (Though I don't use irc much, so its possible I'm just being dumb).
22:42:18 <Cale> bryan`: hmm
22:42:48 <Saizan_> > let until f x n p = last . take n . dropWhile p . iterate f $ x in until (+1) 0 100 (> 20) -- Axman6
22:42:49 <lambdabot>   99
22:42:52 <Cale> bryan`: You're not identified to services, which might be it
22:42:53 <mmorrow> dolio: hmm, i wonder what the circumstances'd be where you'd choose to fuse or not
22:43:22 <dolio> mmorrow: I understand when people want to fuse multiple traversals over a single list into a single traversal. But I don't see why turning a traversal over two different lists into a traversal over them in parallel would be that much of a gain.
22:43:46 <dolio> Except that you'd get to garbage collect one sooner (but garbage collection of the other would be slowed down).
22:43:47 <ezyang> Is this still efficient? find halted . take n
22:44:14 <ezyang> slight change of end type, but it ends up I don't need the sub-computation if it doesn't terminate
22:44:19 <ezyang> (halted = p)
22:45:07 <Cale> bryan`: /msg nickserv help register
22:45:09 <dolio> And with good fusion/lazy producers, you don't need to worry about lists sitting around taking up memory anyway.
22:45:11 <bryan`> Cale: Oh, no I'm not. I didn't realize I needed to to PM.
22:45:18 <mmorrow> dolio: yeah you're right, in this instance it seems like there's no gain/loss either way (but probably more effort to figure out the fused version (assuming that figuring out you don't need to fuse isn't 99% of the battle))
22:45:29 <Cale> bryan`: Though, I thought it was just that people wouldn't receive your PMs if you didn't register...
22:45:33 <Cale> I got yours though.
22:45:56 <Saizan_> dolio: yeah, it seems it pays only when they are the same list
22:46:18 <mmorrow> dolio: none of the known fusion strategies work for foldl in general, and never work for nested foldl's
22:47:36 <mmorrow> dolio: ideally, there'd be a strategy to fuse arbitrarily long (.) pipelines of arbitrarily deeply nested foldl's of the same
22:47:38 <dolio> What sort of fusion strategies? Not deforestation-type?
22:47:50 <mmorrow> essentially restricted partial evaluation
22:48:09 * mmorrow is trying to work this out currently for his interpreter :)
22:48:17 <mmorrow> it's hard :|
22:48:54 <mmorrow> inline+beta-reduce+rewrite doesn't cut it
22:49:41 <codm> Anyone have tips on debugging "thread blocked indefinitely" errors?
22:49:44 <Saizan_> mmorrow: doesn't stream-fusion deal with foldls?
22:49:59 <mmorrow> Saizan_: it does, but only for some non-nested cases
22:50:15 <mmorrow> once you nest at least one level deep, all bets are off
22:51:13 <Saizan_> i guess Foldl isn't a monad then
22:51:33 <mmorrow> e.g.    \m -> sum [prod [1..n] | n <- [1..m]]
22:52:06 <mmorrow> is just two nested for loops
22:52:18 <mmorrow> but figuring that out is a bitch!
22:52:21 <Cale> mmorrow: another case is where you just have multiple foldl's on the same list sitting next to each other.
22:52:42 <mmorrow> Cale: ooh yeah, that's another interesting case
22:53:10 <mmorrow> Cale: like the classic mean thing
22:53:13 <Cale> right
22:53:56 <Cale> bryan`: still not seeing any of my messages?
22:54:53 <bryan`> Cale: Apparently not. I'll try logging out and logging back in again.
22:55:36 <Cale> He's apparently using ERC -- any ERC users who might know what would prevent him from receiving PMs?
22:59:22 <Cale> bryan`: working?
23:01:10 <Cale> bryan`: You seem to be talking to me in PM, but you're not getting my private messages.
23:01:19 <Cale> bryan`: type /query Cale
23:01:46 <Cale> (are you using /msg to send the messages?)
23:02:27 <dolio> mmorrow: Doesn't stream fusion get you the fact that that's a nested for loop?
23:02:55 <dolio> prod [1..n] should certainly reduce to something for-loopish.
23:03:46 <dolio> And sum . map for'loop . [1..m] shouldn't be too much worse.
23:04:04 <dolio> Turning nested for loops into something else is another matter, of course.
23:05:41 <jargonjustin> If I've got `runhaskell Setup.hs build` working to build my library, is there a way I can use `runhaskell` to load it's .hi and built library to run my tests?
23:05:46 <Cale> \m -> -1 - subfactorial (-1) - (-1)^m gamma (m + 2) subfactorial (m - 2)
23:05:55 <Cale> er, left out some *'s :)
23:10:56 <mmorrow> dolio: stream fusion requires that you write sum,prod,enumFromTo in terms of Step,Done,Yield non-directly recursively, but it has a problem with concatMap (which i have to refresh my memory on exactly what that is), whereas i'm looking at it from the pov of adding continuations to everything, turning e.g. [] into (\x xs -> (\nil cons -> cons x xs)), and then turning e.g. map into (map f xs = let go xs nil cons = xs nil (\x xs -> cons (f
23:10:56 <mmorrow> x) (go xs)) in go xs), inlining these into functions that use them which gets you a local letrec of mutually-recursive loops, and finally unraveling the continuations between those local goN's to find the control flow, and finally substituting that letrec for the (hopefully) optimal (possibly nested) loop(s) all with known continuations/return points
23:11:05 <mmorrow> dolio: is my strategy in a nutshell :)
23:12:41 <mmorrow> and each one of these local letrecs of goN's can get compiled into a series of nested loops (where loop := a closed, maybe nested, series of jumps to known labels)
23:13:21 <mmorrow> unraveling the conts is where the partial-eval-ish bit comes in
23:13:38 <ezyang> How do I make this parse? forall a b. (Enum a, Bounded a, Enum b, Bounded b)
23:13:44 <ddarius> mmorrow: Was it you who I suggested look at Matthew Might's work?
23:14:26 <mmorrow> ddarius: i'm not sure, i came across his stuff a few weeks ago, but you may have in the past
23:15:01 <mmorrow> ddarius: but exactly, very similar idea
23:20:19 <ezyang> anyone?
23:20:58 <mmorrow> ezyang: add a "=> ..." to the rhs?
23:21:19 <ivanm> ezyang: error messages and larger code snippets help diagnosis ;-)
23:21:33 <ezyang> righto
23:21:50 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10453#a10453
23:21:59 <ezyang> Error is: Main.hs:32:9: Malformed instance header
23:24:08 <ski> mmorrow : ooi, what are you thinking on ?
23:24:44 <ivanm> ezyang: which line there is 32? the first one?
23:25:01 <ivanm> and do you have the correct extension for the forall?
23:25:02 <ezyang> yeah
23:25:13 <ezyang> oh, interesting
23:25:18 <ezyang> ok, adding ExistentialQuantification changes the error:
23:25:21 <ivanm> you don't need the forall usually
23:26:02 <ezyang>  
23:26:08 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10454#a10454
23:26:26 <ezyang> I wanted forall so that I could refer to type variable a inside the function signatures
23:27:24 <ezyang> since generate is kind of special
23:28:36 <ivanm> ezyang: still don't see why you're doing that
23:28:44 <ivanm> generate is a seperate function...
23:28:48 <recurs|ve> will http://hackage.haskell.org/platform/2009.2.0.2/haskell-platform-2009.2.0.2-i386.dmg work on snow leopard?
23:29:10 <ivanm> recurs|ve: I don't think it does
23:29:17 <ivanm> people have reported it as not working, anyway
23:29:27 <recurs|ve> so I need to build from source right?
23:29:35 <ezyang> ivanm: Right, but I need to express appropriate constraints on it
23:29:37 <recurs|ve> If this is the case, how would I go about that?
23:30:07 <ivanm> ezyang: yes, but what has that got to do with the forall?
23:30:31 <ivanm> ezyang: you don't have a bounded instance for (a,b)!
23:30:34 <ivanm> that's your problem!
23:30:35 <ezyang> a, the type variable inside the instance declaration, had Bounded and Enum on it
23:30:44 <ivanm> @src Bounded
23:30:44 <lambdabot> class  Bounded a  where
23:30:45 <lambdabot>     minBound, maxBound :: a
23:31:04 <ivanm> ezyang: define an instance (Bounded a, Bounded b) => Bounded (a,b) where ...
23:31:30 <ivanm> ezyang: but what happens in the case of say (Int, Bool)? which one gets repeated ad-nauseum?
23:32:15 <ivanm> ezyang: oh, wait, I think I see what you're doing there...
23:32:33 <ezyang> Here's an explicit version that works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10455#a10455
23:32:36 <ivanm> for starters, you don't need bounded for b in your constraint
23:33:36 <ezyang> that's true
23:33:49 <ezyang> except that (a, b) will be bounded
23:34:58 <ivanm> ezyang: well, that differs in your original version in that you have generate :: [b] rather than generate :: [a] ;-)
23:35:07 <ezyang> ivanm: Yeah, that was abug :-)
23:35:14 <ivanm> ezyang: also, whatever you're trying to do here, you're probably doing it wrong
23:35:26 <ezyang> :-(
23:35:39 <ivanm> afk for a bit
23:54:08 <drtybst> So I heard this was the coolest place on the internet?
23:54:33 <Axman6> pretty much
23:54:40 <Axman6> though, it's pretty dead right now
23:55:29 <drtybst> my experience with irc has taught me that these things happen from time to time
23:56:04 <ezyang> FTR, the previous discussion became moot when I realized Ix and not Enum was what I wanted
23:57:02 <drtybst> i see
23:57:15 <ivanm> @. elite yow
23:57:16 <lambdabot> c0ulDn'7 fINd F0rTunE fI13
23:57:19 <ivanm> gah
23:57:30 <ivanm> where has lambdabot's fortune file gone? :s
23:57:37 <ivanm> ezyang: heh
