00:01:22 <iaefai> kmc, I could switch the data structure, but it is the way it is now and I rather under stand the way it is.
00:01:25 <iaefai> Either way I must bed now.
00:01:32 <iaefai> Good night and thank you for all the cheese.
00:01:49 <iaefai> perhaps fish is the better word :p
00:03:01 <kmc> good night
00:03:19 <iaefai> I should see about getting this thing into version control.
00:03:34 <iaefai> Are there any haskell oriented git sites?
00:05:17 <Gracenotes> hm, interesting... partial application is really just turning arguments into free variables, when you think about it
00:05:53 <iaefai> Gracenotes: define free variable
00:06:37 <Gracenotes> well, free in the scope of the function, but which exist in the local or global environment (outer scopes)
00:06:56 <iaefai> Gracenotes: Do not understand.
00:07:00 <kmc> f x = \y -> x + y
00:07:08 <kmc> in the inner function, x is a free variable
00:07:13 <kmc> because it's not an argument to that function
00:08:06 <kmc> this matters in implementation.  when i call (f 3), the machine has to remember that x = 3, so that later when i call the resulting value on another argument y, it will add 3 to that argument
00:08:08 <Gracenotes> oh, the term free variable? it is from lambda calculus. e.g., in (\f x -> f (x y)), f and x are bound as arguments, but y is free. to be meaningful, y needs to have a value from somewhere else, e.g., something which contains that expression, or perhaps y is a global variable
00:08:32 * pikhq notes that it's somewhat clearer if you completely desugar the functions: f = \x -> \y -> x + y -- Like that. Hooray.
00:09:16 <kmc> the thing about haskell is, what pikhq wrote is equivalent to "\x y -> x + y", which looks like a two argument function rather than two one-argument functions
00:09:18 <Gracenotes> Haskell works with lazy functions by gradually changing a thunk, of a function+its arguments+variables in scope (called "free"), to the final value. in partial application, some of the arguments "become" scoped variables. afaik.
00:09:35 <kmc> which is not the case in most other functional languages
00:09:40 <Gracenotes> at least in STG
00:10:01 <pikhq> Though that is the case in lambda calculus.
00:10:13 <iaefai> that stuff is wierd
00:11:29 <Gracenotes> technically, in the STG model, there is no reason why the arguments that are partially applied have to be the first ones. that seems more a residue of the System FC Haskell follows
00:11:46 <kmc> and of syntax
00:13:09 <iaefai> :t flip
00:13:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
00:13:28 <iaefai> :t flip2
00:13:29 <lambdabot> Not in scope: `flip2'
00:13:31 <iaefai> :t flip3
00:13:32 <lambdabot> Not in scope: `flip3'
00:13:39 <kmc> IIRC there is no partial application in STG-machine code; the translation from Haskell (or, e.g. Core) to STG will generate little adapter lambda terms. so i think actually, if you write partial application to args not at the front using those adapters explicitly, it will turn out nearly the same in the end
00:13:42 <iaefai> laters√¶
00:14:06 <Gracenotes> \o
00:14:44 <Gracenotes> kmc: what do they adapt?
00:14:52 <Gracenotes> the partially applied arguments?
00:19:26 <aleator> Hmpmh. Should ghc -I/opt/include/c-headers work, or is the flag called something else?
00:20:10 <Gracenotes> oh, hm, this might be an alternate representation on page 40, "The new code required, namely ((f : xs1) \n {} -> f xs1), can be shared between all partial applications to the same number of arguments."
00:20:16 <Axman6> aleator: probably -opt-l
00:20:26 <Axman6> -opt-l -I/foo/bar
00:21:04 <kmc> yes
00:22:44 <Saizan> the headers are for the linker?
00:25:24 <aleator> Axman6: thanks! (it is -optl).
00:25:37 <aleator> I always forget which should be passed where
00:31:29 <aleator> Hmm.. This is awkward. The generated .chs.h needs to be turned into chs.c for this inline thing to work.
00:50:07 <Axman6> "One of the guys who works here likes to tell the story of one of our customers whose code actually one of the compiler limits, because it had over 10,000 vectorisable loops in one function"
00:50:30 <Axman6> from a talk by a guy from Cray about their use of LLVM
00:54:56 <p_l> Axman6: LLVM seems to have been used for few internal compilers for various things, outside of the official code generation backends. I wouldn't be surprised if Cray has it ported to their special chips
00:55:24 <Axman6> well they're using it for all their x86 stuff at the moment
00:55:45 <Axman6> as a code generator for their PDGCS compiler
00:56:09 <ivanm> heya Axman6
00:56:13 <Axman6> o/
00:56:18 <p_l> afaik their current big x86-64 systems are actually 3 architecture... x86-64, a custom vector cpu and and FPGA modules
00:59:53 <Axman6> heh "... Rock-Solid (Very few bugs we didn't introduce)"
01:03:22 <mgsloan> anyone have the link to the videos of lambda reduction, which also has some audio response?
01:56:21 <eflister> @pl runIdentity (runSupplyT m xs)
01:56:21 <lambdabot> runIdentity (runSupplyT m xs)
01:56:37 <eflister> @pl \xs -> runIdentity (runSupplyT m xs)
01:56:37 <lambdabot> runIdentity . runSupplyT m
02:06:40 <DukeDrake2> hi
02:07:38 <DukeDrake2> are there also 'scientific' channels on freenode ... for example on descrete structures?
02:27:21 <mahogny> DukeDrake2, sounds like too a specific topic for a channel
02:27:50 <gour> has anyone tried qthaskell? i'm curious how it compares with gtk2hs?
02:28:26 <mahogny> no, but I think there has been some progress. a few years ago it looked dead
02:29:17 <mahogny> given the higher portability, and now non-broken license, qt is probably a better choice
02:30:10 <gour> mahogny: i'd agree qt is better choice, but gtk2hs seems to be, afaict, more haskell-ish
02:30:47 <mahogny> could be. but your end users might not think that is a hot feature
02:30:55 <gour> otherwise, i prefer gtk+ look
02:31:07 <gour> he he
02:32:42 <shaleny> qt is licensed under LGPL and ghc performs static linking
02:32:42 <shaleny> so license is "broken" for qt too
02:33:38 <Saizan> 6.12 should support dynamic linking
02:33:48 <gour> well, in my case, i'm happy with gpl, i.e. no need for close-source
03:40:24 <eflister> @djinn (m a -> m b) -> a -> m b
03:40:24 <lambdabot> -- f cannot be realized.
03:40:47 <eflister> @djinn Monad m => (m a -> m b) -> a -> m b
03:40:47 <lambdabot> f a b = a (return b)
03:41:25 <eflister> @hoogle Monad m => (m a -> m b) -> a -> m b
03:41:26 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (e -> e) -> (t f -> t f) -> d -> d
03:41:56 <eflister> huh?
03:42:09 <eflister> @hoogle (Monad m) => (m a -> m b) -> a -> m b
03:42:09 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (e -> e) -> (t f -> t f) -> d -> d
03:42:22 <eflister> @hoogle (m a -> m b) -> a -> m b
03:42:22 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (e -> e) -> (t f -> t f) -> d -> d
03:42:38 <eflister> is that supposed to match?
03:42:59 <FunctorSalad> hoggle can be a bit too fuzzy imho
03:43:27 <FunctorSalad> I guess there is some reason it doesn't do proper unification?
03:43:46 <eflister> it seems like (a $ return b) is a common pattern, is there an operator for that i'm missing?
03:45:05 <FunctorSalad> a . return
03:45:17 <FunctorSalad> (for (\b -> a $ return b)
03:45:26 <eflister> isn't that common enough to warrant a name?
03:45:56 <eflister> it feels like a reverse fmap or something
03:46:19 <|Jedai|> eflister: A common pattern ?
03:46:52 <Jedai> eflister: Where did you use it ?
03:46:56 <eflister> Jedai: i wind up doing it alot -- like more than i need <$>
03:47:24 <Jedai> eflister: Could you show an example ?
03:47:56 <eflister> Jedai: well i was just making a useSupply function for the Supply monad
03:48:10 <eflister> useSupply :: (Functor f) => Supply s a -> f [s] -> f a
03:48:13 <miasma> I have a simple question about haskell's type inference. how can it be implemented that e.g. in '\a -> \a -> [1, a]' the system can propage Int to the lhs of the 2nd arrow, but e.g. in 'a = a; b = [1, a 2]' a has the type 'forall a: a -> a'. in which part of the inference quantifiers are added etc.
03:48:41 <eflister> Jedai:  and to demonstrate it i wrote:    useSupply f  $ return [1 .. 5]
03:49:24 <miasma> basically I have problems propagating type substitutions to the left hand side of the lambda when type variables aren't unique
03:50:11 <FunctorSalad> miasma: hmm? Ghci> :t \a -> \a -> [1, a]
03:50:12 <FunctorSalad> \a -> \a -> [1, a] :: (Num t1) => t -> t1 -> [t1]
03:50:34 <FunctorSalad> not sure what you mean
03:50:38 <miasma> FunctorSalad: in that example the first 'a' doesn't have the type t1
03:50:52 <FunctorSalad> miasma: right, it's completely unused after all
03:51:19 <miasma> I'm implementing type inference and i have problems propagating the type substitutions provided by unification to the left hand side
03:51:37 <miasma> so how to recognize that only the first 'a' gets the type
03:52:12 <FunctorSalad> the type inferer shouldn't have to care about names
03:52:31 <Jedai> eflister: return is not a method of Functor, so this example seems a bit artificial, for most functors you'll write the value directly
03:52:32 <FunctorSalad> (about name shadowing)
03:52:55 <Jedai> eflister: Where would you use this expression ?
03:52:59 <miasma> FunctorSalad: so if the user annotates types with a type var, i should still internally use different type var names?
03:53:14 <eflister> Jedai: doesn't Functor have pure?
03:53:25 <Jedai> eflister: No, that's applicative functors
03:53:28 <FunctorSalad> , [| \a -> \a -> [1,a] |]
03:53:30 <lunabot>  LamE [VarP a_0] (LamE [VarP a_1] (ListE [LitE (IntegerL 1),VarE a_1]))
03:53:46 <eflister> Jedai: oh right, well it feels applicativey
03:53:55 <FunctorSalad> miasma: yes, at least ghc does it as you see :)
03:53:59 <miasma> ok
03:54:31 <eflister> Jedai: but there aren't many times one is using a functor that isn't applicative are there?
03:54:35 <Jedai> eflister: I guess "useSupply s" is "fmap (runSupply s)" ?
03:54:36 <FunctorSalad> or template haskell, but I'm pretty sure ghc uniquifies them too internally
03:55:22 <eflister> Jedai: almost --  useSupply = fmap . (fst `dot` runSupply)
03:56:04 <eflister> Jedai: where dot = (.).(.)
03:56:22 <Jedai> @hoogle (Applicative f) => (f a -> f b) -> a -> f b
03:56:23 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (e -> e) -> (t f -> t f) -> d -> d
03:56:39 <Younder> I am having touble installing haskabelle in a Code General Isabelle/HOL environment
03:56:40 <eflister> Jedai: yeah i was running into that.  wtf?
03:57:47 <Younder> I should asy reinsalling
03:59:20 <Younder> I should say reinstalling
03:59:44 <Jedai> eflister: IMHO you're pushing pointfree-ness too far with your version...
04:00:12 <eflister> Jedai: :)  sure
04:00:33 <SamB_XP> Jedai: so, you don't think there's any point ?
04:01:02 <Jedai> SamB_XP: Well there's no point in his version, that's for sure !
04:01:23 <eflister> Jedai: i guess it's just evalSupply now that i realize what evalSupply is.  (+1 rung on the ladder of enlightenment)
04:03:11 <Jedai> eflister: as for your example, I don't really see where it would be useful, the fact that Applicative and Monad don't seem to have this operator named while having plenty others seems to argue that this pattern isn't so frequently used by others either...
04:03:14 <miasma> FunctorSalad: but I suppose some sort of list of scoped type var names has to be maintained to hide the non-local type vars. e.g. if a means Int in one declaration, and String in another
04:04:17 <FunctorSalad> miasma: these should be given distinct names too no?
04:04:31 <FunctorSalad> "a" in one top level declaration has nothing to do with "a" in another
04:04:37 <eflister> Jedai: maybe cuz there aren't a lot of (Applicative f) => (f a -> f b) ?
04:04:49 <Jedai> eflister: Not that this couldn't be a good idea but you would have to come with a motivating example and a good name for the operator to get it included in the standard (if you really use it often, ask yourself if it's really necessary and if it is, put it in your personal toolbox I guess)
04:05:17 <miasma> FunctorSalad: sure, i can give distinct names to all types in expressions. but how to add user defined type vars on top of that
04:05:45 <eflister> Jedai: well i'm a n00b, i didn't mean to suggest a new operator, i just thought i was missing something :)
04:06:51 <miasma> FunctorSalad: everything is fine if all types are unique and substitutions are global. but I think I have to make them local to hide the type vars not available on that scope
04:08:15 <FunctorSalad> miasma: I haven't written a type inferer myself so maybe I'm missing your point
04:08:34 <eflister> Jedai: well i guess any fmap (a -> b) winds up being an (f a -> f b), is that right?
04:09:07 <Jedai> eflister: Yes, that's the function of fmap
04:09:10 <miasma> FunctorSalad: e.g. if you write 'a = 5: b; c = "ohai": b' the type var 'b' is local on both cases
04:09:19 <SamB_XP> Jedai: ITYM type ;-P
04:09:34 <SamB_XP> puny jedi!
04:10:12 <FunctorSalad> miasma: the var for the type of b?
04:10:35 <Jedai> eflister: thing is, you have a "a", you want a "b", so why not just use your "a -> b" rather than use fmap on it and then use return on your "a" and finally extract your "b" from the "f b" you got
04:11:53 <Jedai> eflister: in your example, you could use evalSupply instead of "head . useSupply s $ return a"
04:12:16 <miasma> FunctorSalad: b is a type variable named 'b' in that code. i've ascribed both 5 and "ohai" with it. if the b was global, the substitution b => Int would make the type check on the next declaration fail
04:12:17 <eflister> Jedai: let me hpaste what i'm working on -- i wanted to ask this list if they thought what i'm doing would be worth replacing the MonadSupply page on the wiki -- i've incorporated the internals hiding and finite safety from RWH.  would you mind taking a look and you can tell me if useSupply isn't useful, and maybe a better way to do my reverse fmap thing?  :)
04:13:44 <eflister> Jedai: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11232
04:14:23 <eflister> if anyone has a chance, can they check out the above link and see if they agree it would be a good replacement for http://www.haskell.org/haskellwiki/New_monads/MonadSupply
04:18:53 <Jedai> eflister: I don't think it's a very good replacement for MonadSupply, since it effectively force you to use a finite supply oriented interface even if you have an infinite supply
04:19:14 <eflister> Jedai: not so!
04:20:29 <eflister> Jedai: it has a demo working on an infinite supply as the last line in main.  and i use it in my own stuff with an infinite supply (stdrandom).  why do you say it is finite oriented?
04:20:31 <Jedai> eflister: And your useSupply isn't used in very compelling cases either given that is basically some equivalent of take with a different handling for the size problem
04:21:22 <Jedai> eflister: Because even if you have an infinite supply you have to work with the Maybes ?
04:21:58 <fasta> Does anyone use WriteBoard here?
04:22:40 <eflister> Jedai: well a list is just an easy supply to demo on -- the current thing on the wiki uses lists as an example too.  regarding Maybes, i don't get why you don't see the safety as an improvement.  one need only catMaybe the result.
04:24:52 <Jedai> eflister: The safety is nice but the wiki version allows you to have the safety when you need it and strip it away when you don't, and it's pretty hard to be wrong (one suspects than when somebody starts to use SupplyT rather than Supply he is proficient enough to not make the mistake), while your version impose the safety on those that don't need it
04:27:12 <eflister> Jedai: hm, ok.  i couldn't follow the rwh discussion of making the SupplyT, and it doesn't show the technique used on the wiki of deriving the monad from its transformer, so i thought combining the advantages of both would be nice.  it was a useful exercise for me anyway.  any advice on useSupply, or changing the style demonstrated in main?
04:30:58 <Jedai> eflister: Well, I don't see why you have to use useSupply in this particular case, you could as well use evalSupply (evalSupply m = fst . runSupply m) or even directly do a take.
04:32:10 <Jedai> eflister: I think the point is that "useSupply" is the wrong primitive to have, you should have evalSupply instead
04:33:11 <Jedai> eflister: And the code is pretty nice anyway, so I guess this accomplished its purpose as an exercice
04:42:09 <eflister> Jedai: yeah i'm not sure useSupply is better than evalSupply.  are they actually different?  i thought the only difference was that i'm doing it manually rather than using evalState.  i guess evalState is Supply s a -> [s] -> a   rather than Supply s a -> f [s] -> f a  ?  so that would get rid of my return.  but i don't get how to call the monadic functions if the second arg isn't f [s] instead of [s].
04:43:30 <Jedai> eflister: "evalSupply m = fst . runSupply m" already works
04:45:00 <eflister> Jedai: i'll try it -- it seems i won't be able to pass a function that calls snext, but i might be missing it
04:45:34 <Jedai> eflister: it seems you're confused, your useSupply has nothing to do with the Supply Monad, is use the supply monad inside an arbitrary functor, it's more of a "functor function" than a "monad function" in fact
04:47:03 <eflister> Jedai: yeah i wrote it just to factor out code i had that called runSupply, not with good API design in mind.
04:47:35 <Jedai> "mapM_ s $ useSupply f  $ return [1 .. 5]" is equivalent to "s . evalSupply f $ [1..5]"
04:48:03 <Jedai> eflister: So as you see, the right primitive isn't useSupply
04:48:18 <dilinger> o
04:48:23 <Jedai> gotta go, lunch :)
04:48:45 <eflister> Jedai: alright thanks, i'll see if i can see things from the evalSupply perspective
04:49:48 <eflister> Jedai: my point wasn't to usurp evalSupply, but to combine the advantages of the rwh and wiki approaches.  useSupply was just along for the ride.
05:15:00 <Younder> net split
05:15:35 <Younder> someone ought to improve on that algorithm
05:16:34 <HMS_John> Hi there, im in the middle of a small haskell project and trying to write a doWhile loop using recursion. Does anyone have any ideas where to start. I'm a bit of a beginner!
05:16:53 <Younder> Clearly it has reached it's level of incompenetce if this is a daily event
05:18:02 <Younder> finnish my ass, I can do better
05:18:55 <zygoloid> HMS_John: i'd start by... staying in the channel for long enough to be given an answer?
05:19:12 <Younder> lol
05:19:24 <Younder> lol
05:30:15 <yitz> > let doWhile pred func = last . takeWhile (not . pred) . iterate func in doWhile (< 10) (+ 1) 0
05:30:16 <lambdabot>   * Exception: Prelude.last: empty list
05:30:54 <yitz> > let doWhile pred func = last . takeWhile pred . iterate func in doWhile (< 10) (+ 1) 0
05:30:55 <lambdabot>   9
05:31:31 <yitz> > let doWhile pred func = head . dropWhile pred . iterate func in doWhile (< 10) (+ 1) 0
05:31:32 <lambdabot>   10
05:32:43 <mux> > until (>= 10) {+1) 0
05:32:44 <lambdabot>   <no location info>: parse error on input `+'
05:32:47 <mux> > until (>= 10) (+1) 0
05:32:48 <lambdabot>   10
05:33:06 <mux> > let doWhile p = until (not . p) in doWhile (<10) (+1) 0
05:33:08 <lambdabot>   10
05:33:26 <yitz> @hoogle until
05:33:27 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
05:34:14 <yitz> oh, that's in the Prelude? huh. show you how far away i've gotten from doWhile and friends.
05:34:20 <yitz> *shows
05:34:26 <mux> :)
05:34:52 <hackagebot> mmap 0.5.4 - Memory mapped files for POSIX and Windows (GracjanPolak)
05:36:30 <ClaudiusMaximus> i've more often needed something like  > convergeBy (~=~) (x:y:zs) = if x ~=~ y then x else convergeBy (~=~) (y:zs)  -- is there a better name?
05:37:20 <jystic> @hoogle (~=~)
05:37:20 <lambdabot> No results found
05:37:41 <yitz> ClaudiusMaximus: yeah, me too. I call it "stable".
05:37:42 <ClaudiusMaximus> let foo (~=~) a b = a ~=~ b in foo (==) 1 2
05:37:46 <ClaudiusMaximus> > let foo (~=~) a b = a ~=~ b in foo (==) 1 2
05:37:47 <lambdabot>   False
05:37:52 <yitz> but that's my own thing.
05:39:19 <jystic> ~=~ looks like a slice of cake with wings
05:39:29 <ClaudiusMaximus> i tend to use class Approx a where epsilon :: a ; (~=~) :: a -> a -> Bool
05:40:16 <ClaudiusMaximus> with the semantics of approximate equality (because floating point arithmetic is horrible)
05:40:38 <ClaudiusMaximus> it's probably bad style, but i don't care so much :)
05:40:52 <halcyon10> @hpaste
05:41:39 <jystic> ClaudiusMaximus: does ~=~ mean "approximately equal to"?
05:41:43 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
05:41:52 <ClaudiusMaximus> jystic: it does in my code, probably not in anyone elses
05:42:33 <jystic> ok :) got to love being able to define your own operators
05:43:17 <ClaudiusMaximus> jystic: in one project i also have ^^*^^ for matrix-matrix multiplcation, ^^*^ for matrix-vector multiplication, and ^^* for matrix-scalar multiplication...
05:43:38 <ClaudiusMaximus> jystic: but that was before i found Data.Vec
05:44:12 <ClaudiusMaximus> maybe it was a different library i found...
05:44:29 <jystic> Data.Vec still looks pretty cool
05:45:19 <jystic> i haven't dug much in to any 3D maths in Haskell yet, still learning the basics
05:46:02 <ClaudiusMaximus> relatedly, i asked this a while ago, but got no response (maybe i should try the -cafe): anyone have a pure-haskell SVD implementation for 2x2 real matrices?
05:46:12 <halcyon10> hi, i'm trying to make a specialization of a polymorphic datatype an instance of the Monoid type class but ghc gives me a copmile error which i don't quite get. Has anyone advice for me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11233#a11234
05:46:30 <ClaudiusMaximus> i find it overkill to have to pull in hmatrix and all its foreign deps just for that...
05:47:10 <ClaudiusMaximus> halcyon10: Double is not a type variable
05:48:19 <halcyon10> ClaudiusMaximus: so i would have to make a generic monoid instance for (Texture a) ?
05:49:17 <halcyon10> ClaudiusMaximus: can't i make only one specialized data type an instance of a type class?
05:49:38 <Saizan> halcyon10: add the flags it says it wants
05:50:19 <ClaudiusMaximus> i don't know, i'm a bit noob at type classes
05:50:25 <Saizan> halcyon10: h98 was faily conservative with typeclasses since they were new
05:51:16 <halcyon10> Saizan: ok, i'll try that out, just hesitated to add a language option i didn't know about
05:52:42 <halcyon10> Saizan: now it works, thanks!
05:57:52 <eflister> @pl \(x,y) -> fmap (\z -> (x + 1, z : y)) snext
05:57:52 <lambdabot> uncurry (flip flip snext . (fmap .) . (. flip (:)) . (.) . (,) . (1 +))
05:58:02 <eflister> oh yeah
05:58:33 <eflister> i'd like to make this into an arrow ---  \(x,y) -> fmap (\z -> (x + 1, z : y)) snext
05:58:50 <eflister> but i don't see how to get that fmap in there
05:59:29 <eflister> it's almost ((+ 1) *** (snext :))   except for the fmap
06:05:26 <eflister> anyone around that likes arrows?  :)
06:06:07 <eflister> oh wait, i think this is that case where i have to Kleisli (snext is monadic)
06:06:15 <eflister> :t runKleisli
06:06:16 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
06:07:43 <eflister> anyone around that wants to explain Kleislis?  right now i'm just following this pattern without much understanding: http://blog.snoyman.com/2009/10/19/monadic-pairs-and-kleisli-arrows/
06:28:18 <eflister> anyone able to help with my arrow question above?
06:32:32 <eflister> @pl \x -> fmap (\z -> ((+ 1) *** (z :)) x) snext
06:32:32 <lambdabot> flip fmap snext . flip (((1 +) ***) . (:))
06:32:35 <kbp> is there a way to generate a list of characters from a to z and A to Z without typing it up like list=['a','b',...] ?
06:32:49 <burp> > ['a'..'z']
06:32:50 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
06:32:53 <burp> like this? :>
06:33:05 <int-e> @type (>=>)
06:33:06 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:33:07 <kbp> thank you burp :) that's it
06:34:01 <int-e> eflister: Kleisli arrows are just morphisms of the form a -> m b where m is a monad; (>=>) is the corresponding composition.
06:34:04 <int-e> @src Kleisli
06:34:04 <lambdabot> Source not found. :(
06:34:25 <int-e> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
06:34:30 <jystic> > ['0'..'z']
06:34:32 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
06:34:47 <jystic> fun and games :)
06:36:33 <eflister> int-e: the words don't mean much to me yet.  so far what i understand is "if building arrows out of functions, and one of them is monadic, label them all with Kleisli and runKleisli on the result"
06:36:47 <koala_man> > ['‚òÉ'..'‚ô•']
06:36:48 <lambdabot>   "\9731\9732\9733\9734\9735\9736\9737\9738\9739\9740\9741\9742\9743\9744\974...
06:36:56 <koala_man> sweet
06:37:07 <jystic> haha
06:37:30 <eflister> int-e: would it apply to my fmap trouble?  maybe that will help me understand...
06:38:19 <eflister> int-e: what is an example of a morphism that is not a function?
06:38:53 <burp> :t text
06:38:54 <lambdabot> String -> Doc
06:38:56 <burp> > text ['‚òÉ'..'‚ô•']
06:38:57 <lambdabot>   ‚òÉ‚òÑ‚òÖ‚òÜ‚òá‚òà‚òâ‚òä‚òã‚òå‚òç‚òé‚òè‚òê‚òë‚òí‚òì‚òî‚òï‚òñ‚òó‚òò‚òô‚òö‚òõ...
06:39:26 <jystic> :i text
06:40:11 <jystic> @hoogle text
06:40:11 <lambdabot> Text.Html text :: String -> HtmlAttr
06:40:12 <lambdabot> Text.PrettyPrint.HughesPJ text :: String -> Doc
06:40:12 <lambdabot> Text.XHtml.Transitional text :: String -> HtmlAttr
06:44:24 <burp> > text $ reverse ['‚òÉ'..'‚ô•']
06:44:25 <lambdabot>   ‚ô•‚ô§‚ô£‚ô¢‚ô°‚ô†‚ôü‚ôû‚ôù‚ôú‚ôõ‚ôö‚ôô‚ôò‚ôó‚ôñ‚ôï‚ôî‚ôì‚ôí‚ôë‚ôê‚ôè‚ôé‚ôç...
06:44:41 <kbp> I declared newList :: [(Char,Int)]. Then I do newList =   [(x,0) | x <- ['a'..'z']] to generate a list of tuple that looks like [('a',0),('b',0)] but it doesn't work that way. Any idea? (I'm new to Haskell)
06:45:25 <burp> what do you mean, it doesn't work that way?
06:45:32 <burp> > [(x,0) | x <- ['a'..'z']]
06:45:33 <lambdabot>   [('a',0),('b',0),('c',0),('d',0),('e',0),('f',0),('g',0),('h',0),('i',0),('...
06:45:35 <burp> it does..
06:46:08 <kbp> !??? ok then there must be error somewhere else. Let me check the code
06:46:53 <osfameron> >  map ((,) 0) ['a'..'z']
06:46:54 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(0,'e'),(0,'f'),(0,'g'),(0,'h'),(0,'i'),(0...
06:47:53 <burp> >  map (flip (,) 0) ['a'..'z']
06:47:54 <lambdabot>   [('a',0),('b',0),('c',0),('d',0),('e',0),('f',0),('g',0),('h',0),('i',0),('...
06:49:04 <osfameron> > map (const 0 &&& id) ['a'..'z']
06:49:05 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(0,'e'),(0,'f'),(0,'g'),(0,'h'),(0,'i'),(0...
06:49:57 <sclv_> does sigbjorn pop by here?
06:50:39 <sclv_> found a small bug in the json library
06:51:51 <sclv_> also, curious if anyone knows the difference between the mmap and bytestring-mmap library
06:54:52 <sclv_> in terms of performance, reliability, etc.
06:54:58 <sclv_> both seem to be developed and maintained
06:57:26 <copumpkin> burp: in 6.12 you can write (0,)
06:58:26 <burp> cool
07:07:32 <ray> WHAT TUPLE SECTIONS
07:09:44 <osfameron> that'll be nice
07:09:51 <osfameron> has it also fixed (-) sections? ;-P
07:10:30 <aavogt> osfameron: those aren't broken...
07:10:37 <Twey> Yes they are
07:10:49 <aavogt> > (1 - ) $ 1
07:10:50 <Twey> > (- 1) 3
07:10:50 <lambdabot>   0
07:10:50 <lambdabot>   No instance for (GHC.Num.Num (t -> a))
07:10:51 <lambdabot>    arising from a use of syntactic n...
07:11:10 <aavogt> you really want (-x) to be different from  (- x)?
07:11:37 <Twey> I want the problem fixed.  That's one acceptable solution, yes.
07:11:39 <aavogt> > subtract 1 3
07:11:40 <lambdabot>   2
07:11:54 <osfameron> dunno.  it's the most obvious syntactic wart in haskell though, and does mean that, as I said, sections on (-) are broken :-)
07:11:57 <Twey> Yeah.  That's a workaround.  That's something that people do when a feature is broken.  ;)
07:12:45 <nominolo> > (,3) 4
07:12:46 <lambdabot>   <no location info>: parse error on input `3'
07:13:09 <aavogt> I think the ugliness is better than such whitespace inconsistency (or making - part of numeric litterals), or using a different symbol for negation than subtraction
07:13:36 <Twey> aavogt: I wouldn't have it be inconsistent.  I'd add whitespace-sensitivity to all operators.
07:14:02 <zygoloid> i would treat the - as part of the lexical structure of numbers
07:14:11 <Twey> It requires something that's good style anyway, it fixes this problem, *and* it increases the valid identifier space for functions and operators alike.
07:14:27 <aavogt> > let x = 1 in -x
07:14:28 <lambdabot>   -1
07:14:30 <Twey> Yeah, then - becomes part of the number structure.
07:14:36 <nominolo> Twey: and in now way backwards compatible
07:14:36 <zygoloid> aavogt: right, i wouldn't allow that.
07:14:50 <Twey> nominolo: Yes.  But we don't care about that.  ‚ò∫
07:15:22 <nominolo> Twey: arguably, it'd be not difficult to automatically translate programs from old style to new style
07:15:27 <zygoloid> whitespace-sensitivity doesn't sound so bad, since we already have it for .
07:15:38 <Twey> It would be much better to just use negate for that case that aavogt showed.
07:15:42 <Twey> zygoloid: *nod*
07:15:45 <boogyman> Twey, if you are free for a couple minutes, I would like to ask you a question regarding one of your JS (blog) posts on DD ... I understand this isn't the appropriate channel, so I invite you to #boogyman to discuss, or feel free to PM me
07:15:52 <nominolo> It can lead to problems though.  Just think of newbies typing "x+4" and getting an unbound identifier error
07:16:22 <Twey> nominolo: Newbies make mistakes.
07:17:27 <Twey> It's inevitable.
07:17:27 <osfameron> ok, so make the error messages better: "Unknown identifier 'x+4'.  Did you mean 'x + 4' ?"
07:17:27 <zygoloid> if "let x = 1 in -x" gave me the error "Not in scope: -x" I think that'd be pretty clear
07:17:27 <Twey> We'll set them right, and life will resume.
07:17:27 <Twey> Aye.
07:17:27 <nominolo> It's more about the general level of confusion when learning a new language
07:18:37 <Twey> Heck, VB.NET has whitespace-sensitivity for operators.
07:18:37 <aavogt> > let quadsolve a b c = let disc = b*b - 4*a*c in ((-b + sqrt disc) / 2 / a,(-b - sqrt disc) / 2 / a) in quadSolve 1 0 (-2)
07:18:37 <Twey> You know the kind of people who use VB.NET.
07:18:37 <lambdabot>   Not in scope: `quadSolve'
07:18:37 <aavogt> > let quadsolve a b c = let disc = b*b - 4*a*c in ((-b + sqrt disc) / 2 / a,(-b - sqrt disc) / 2 / a) in quadsolve 1 0 (-2)
07:18:37 <lambdabot>   (1.4142135623730951,-1.4142135623730951)
07:18:37 <nominolo> > let quadsolve a b c = let disc = b*b - 4*a*c in ((-b + sqrt disc) / 2 / a,(-b - sqrt disc) / 2 / a) in quadsolve 1 0 2
07:18:37 <lambdabot>   (NaN,NaN)
07:18:37 <zygoloid> we could introduce (- ... -) style comments into haskell, then the ambiguity of (-2) disappears!
07:24:22 <Twey> > let quadsolve a b c = let discr = (b * b) - (4 * a * c) in (negate b + sqrt discr / 2 * a, negate b - sqrt discr / 2 * a) in quadsolve 1 0 (negate 2)
07:24:22 <lambdabot>   (1.4142135623730951,-1.4142135623730951)
07:24:22 <aavogt> you are conspiring break my codes
07:24:22 <roconnor> zygoloid: what about the (-2 -) section aka ((-) (negate 2))
07:24:51 <Twey> Or
07:24:58 <Twey> > let quadsolve a b c = let discr = (b * b) - (4 * a * c) in (negate b + sqrt discr / 2 * a, negate b - sqrt discr / 2 * a) in quadsolve 1 0 -2
07:24:58 <lambdabot>   No instance for (GHC.Num.Num (t -> (t, t)))
07:24:59 <lambdabot>    arising from the literal `2'...
07:25:14 <Twey> That wouldn't break under the proposed system.
07:25:37 <Gracenotes> in (-2-) it might complain about fixity or somelike
07:25:54 <Gracenotes> er. hm. does not :o
07:26:03 <Gracenotes> -0-
07:27:51 <Twey> > (-2-) 1
07:27:52 <lambdabot>   -3
07:28:04 <Twey> Only the left bracket is necessary for negative magic
07:28:47 <aavogt> wow
07:29:33 <Twey> Yeah.  Ugly, right?
07:29:34 <Gracenotes> -2-1 as well..
07:30:00 <int-e> > (-2+) 3 ... and best of all, hugs and ghc disagree on that one.
07:30:01 <lambdabot>   <no location info>: parse error on input `of'
07:30:09 <Twey> Heh
07:30:11 <Twey> Silly int-e
07:30:16 <Twey> > (-2+) 3
07:30:17 <lambdabot>   1
07:30:25 <Twey> What does Hugs say?
07:30:41 <int-e> hugs: command not found ... hmm :)
07:31:03 <Twey> Heh
07:31:14 <int-e> ERROR - Syntax error in expression (unexpected `)')
07:31:19 <int-e> is what it says.
07:31:23 <Twey> Nice
07:32:21 <int-e> it wants ((-2)+) 3 or (+ -2) 3
07:32:25 <int-e> > (+ -2) 3
07:32:26 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
07:32:26 <lambdabot>      must have lower prece...
07:32:34 <int-e> fun, isn't it? :)
07:34:11 <Twey> int-e: Splargh.
07:34:22 <saml> > Splargh . 1
07:34:23 <lambdabot>   Not in scope: data constructor `Splargh'
07:34:50 <Twey> And you think whitespace-sensitivity would be confusing for newbies?  :√æ
07:35:08 <Twey> Even the compiler-writers can't figure this one out!
07:35:21 <Gracenotes> :t -2  2+2
07:35:22 <lambdabot>     Ambiguous type variable `t' in the constraint:
07:35:22 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:4
07:35:22 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
07:45:48 <kbp> Could someone please help me with this small code? I loaded and run in Haskell but it didn't stop (freeze).  The function is to find the tuple (inside a list) that has the biggest value of its second element http://codepad.org/aZwiDQwn
07:48:32 <burp> something like sort $ fmap (\x -> (snd x,fst x))
07:49:04 <burp> > sort $ fmap (\x -> (snd x,fst x)) [('a',17),('b',12),('c',14),('d',6),('e',13),('f',6),('g',6),('h',8)]
07:49:05 <lambdabot>   [(6,'d'),(6,'f'),(6,'g'),(8,'h'),(12,'b'),(13,'e'),(14,'c'),(17,'a')]
07:49:07 <medfly> (\
07:49:20 <burp> might not be the most elegant way :>
07:49:20 <medfly> (\(a,b)->(b,a)) works just as well, but I haven't used fmap so not sure :s
07:49:33 <camio> kbp: I'd probably try to step through the evaluation, by hand, with a small input.
07:51:26 <camio> kbp: I'd expect something about the evaluation of maxValue to be the cause of the loop. Try findmax with a base case . . . findmax (x:[]).
07:51:49 <kbp> ok.. let me try
07:52:25 <benmachine> the base case should be caught by the length check
07:52:38 <benmachine> maxValue shouldn't be evaluated when length xs == 0
07:52:55 <Twey> kbp: You have a function call at the top-level
07:53:02 <Twey> On line 15
07:53:06 <benmachine> (p.s. null is a better way to test for length == 0)
07:53:11 <Twey> The parser is expecting a declaration
07:53:29 <camio> benmachine, I think the use of the commas in the where clause forces their evaluation. Similar to how a case statement does.
07:53:53 <camio> benmachine, if he instead did z = findmax xs and then used fst z and snd z I don't think he'd have a problem.
07:54:10 <benmachine> hmm
07:54:21 <benmachine> but findmax always returns a tuple
07:54:29 <benmachine> so evaluation isn't necessary to match the pattern
07:54:41 <camio> Well, it depends on how it is implemented.
07:55:01 <kbp> I've found out that the problem is when it reads up to ('r',17) which has the same value as first ('a', 17), it stucks
07:55:12 <benmachine> Twey: http://codepad.org/022hgpT9 is probably what he meant to paste
07:55:20 <camio> for example, if otherwise was written as (fst (findmax xs), snd (findmax xs)) it probably would work.
07:55:32 <burp> advantage with full sort is that you get it fully sorted
07:55:35 <burp> by both arguments
07:55:46 <camio> It's a subtle laziness issue.
07:56:44 <zygoloid> > maximumBy (comparing snd) [('a',17),('b',12),('c',14),('d',6),('e',13),('f',6),('g',6),('h',8)]
07:56:44 <lambdabot>   ('a',17)
07:57:00 <burp> ah, best one =)
07:57:34 <quicksilver> unless "snd" is an expensive operations
07:57:37 <quicksilver> (which it isnt)
07:57:50 <quicksilver> but for those cases, it's better to use a schwartzian transform.
07:58:04 <zygoloid> ... and then use maximumBy (comparing snd) ;-)
07:58:13 <copumpkin> maximumOn snd
07:58:37 <zygoloid> @let maximumOn = maximumBy . comparing
07:58:38 <lambdabot>  Defined.
07:58:39 <kbp> thank you zygoloid that works. :) the problem with my function is it grows like exponential time, so it takes too long to run and i thought it was an error
07:59:07 <copumpkin> zygoloid: except caching the values (I refuse to call it schwartzian)
08:00:39 <Stephan202> http://stackoverflow.com/questions/1637789/0-0-1-109
08:02:20 <medfly> I think someone is testing whether the people replying are well written :)
08:02:23 <benmachine> kbp: http://codepad.org/Zn2Oo446 is basically your algorithm but with better sharing
08:03:49 <kbp> ok thank you benmachine I will use that one (I've been looking for the library for the maximumBy because it says undefined variable "comparing" :S)
08:03:58 <benmachine> import Data.Orf
08:03:59 <benmachine> er
08:04:00 <benmachine> Ord
08:04:01 <benmachine> I think
08:04:19 <benmachine> yeah, comparing is in Data.Orf
08:04:23 <benmachine> god damn it
08:04:25 <benmachine> yeah, comparing is in Data.Ord
08:04:31 <benmachine> :(
08:04:48 <benmachine> ord ord ord.
08:05:01 <benmachine> @index comparing
08:05:01 <lambdabot> bzzt
08:05:05 <benmachine> bzzt.
08:05:11 <ksf> how far are those various attempts on c++ interop?
08:05:51 <benmachine> @type Data.Ord.comparing
08:05:52 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
08:15:13 * oteren orf orf benmachine
08:15:57 <copumpkin> orf orf
08:17:39 <kbp> exit
08:17:49 <HayashiRazan> :t kbp
08:17:50 <lambdabot> Not in scope: `kbp'
08:18:12 <kbp> it's 2AM now actually. thank you for your helps :) I gonna sleep
08:18:28 <kbp> will be back later to ask for help :P
08:18:42 <oteren> :t orf
08:18:43 <lambdabot> Not in scope: `orf'
08:18:47 <oteren> :<
08:18:53 <HayashiRazan> :t oteren
08:18:54 <lambdabot> Not in scope: `oteren'
08:22:03 <benmachine> :t :epocs_ni_toN
08:22:04 <lambdabot> parse error on input `:'
08:22:07 <benmachine> aw
08:37:02 <bastl> Hi all.
08:37:56 <bastl> how does unsafeCoerce fit into the picture of static typing? Is it a language feature or a GHC feature ?
08:39:22 <Saizan> bastl: 1) it doesn't 2) GHC
08:39:55 <Saizan> bastl: unsafeCoerce can be used when you can prove that it's safe
08:40:12 <copumpkin> or when it's unsafe, if crashing is your goal
08:40:12 <Saizan> bastl: it's used to implement Data.Typeable.cast
08:41:00 <Saizan> though you can break the assuption Data.Typeable uses to prove the correctness
08:41:04 <bastl> Saizan: yes, I want to explain cast to the reader and now want to say where it comes from...
08:41:22 <bastl> rather how it works.
08:41:49 <copumpkin> in typeable types get a chance to produce a (unique) value for themselves
08:42:44 <copumpkin> cast will check that the input and output values match up and if so, use unsafeCoerce and return it in a Just
08:42:51 <copumpkin> if they don't match up, it'll give you Nothing
08:42:54 <copumpkin> @src cast
08:42:54 <lambdabot> Source not found. You untyped fool!
08:43:23 <bastl> > (unsafeCoerce 65)::Char
08:43:24 <lambdabot>   Not in scope: `unsafeCoerce'
08:43:31 <copumpkin> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Data-Typeable.html#cast
08:44:18 <copumpkin> (it avoids using undefined :: b with scoped type vars I guess, by binding the value and referring to it)
08:45:34 * benmachine amuses self by coercing to and from functions
08:46:01 * oteren orf orf benmachine
08:46:06 * benmachine orf oteren 
08:46:07 <copumpkin> benmachine: through Any?
08:46:08 <bastl> benmachine: example?
08:46:13 <copumpkin> benmachine: or just for the fun of crashing?
08:46:18 <benmachine> copumpkin: the latter :x
08:46:28 <benmachine> ghci> import Unsafe.Coerce
08:46:28 <benmachine> ghci> unsafeCoerce 1 2
08:46:28 <benmachine> Segmentation fault
08:46:34 <copumpkin> nice
08:46:36 <benmachine> <_<
08:46:56 <Saizan> that's not so spectacular though
08:47:17 <benmachine> no I was hoping for something more exotic
08:47:26 <benmachine> ooh
08:47:29 <benmachine> ghci> (unsafeCoerce (+1) :: Char -> Char) 'a'
08:47:29 <benmachine> 'b'
08:47:39 <copumpkin> that makes sense :)
08:48:05 <benmachine> ghci> (unsafeCoerce log :: Char -> Char) 'a'
08:48:05 <benmachine> '\-1892925033'
08:48:11 <benmachine> that, a little less so :P
08:48:25 <Beelsebob> haha
08:50:11 <benmachine> ghci> unsafeCoerce getLine :: String
08:50:12 <benmachine> ""
08:50:16 <benmachine> weird.
08:50:30 <copumpkin> not that weird
08:50:37 <Beelsebob> I‚Äôm surprised that didn‚Äôt result in an asplosion
08:50:42 <benmachine> ^
08:50:50 <copumpkin> it's only running data as functions that would asplode
08:50:58 <quicksilver> unsafeCoercing data to data is surprisingly safe
08:51:07 <benmachine> it seems that if you make things into a string it tends to make an empty one
08:51:08 <gwern> @quote Maria
08:51:08 <quicksilver> it's data -> function that's a hiccup
08:51:08 <lambdabot> sproingie says: ‚ô´ how do you beta-reduce a problem like maria ‚ô´
08:51:19 <gwern> @quote Quine
08:51:19 <lambdabot> Baughn says: There's also the language, Quine, whose interpreter is implemented as a symlink to /bin/cat
08:51:28 <gwern> @quote garbled
08:51:28 <lambdabot> No quotes match. You untyped fool!
08:51:33 <quicksilver> benmachine: try "unsafeCoerce (Just 'a') :: String"
08:51:42 <gwern> @quote statistics
08:51:42 <lambdabot> pozic says: statistics. a wonderful tool to control people.
08:51:43 <copumpkin> gwern's on one of his @quoting sprees again
08:51:50 <benmachine> quicksilver: :o neat
08:52:02 <gwern> @quote asks.*gets
08:52:02 <lambdabot> FunctorSalad says: I think the "asks", "gets" etc family of names is sort of cute, like the program is talking about itself in the third person
08:52:13 <gwern> @quote State.*monad
08:52:13 <lambdabot> mmorrow: says: right, that's just beggin for a State monad.
08:52:20 <benmachine> ghci> unsafeCoerce (Left 'a') ++ unsafeCoerce (Right 'b') :: String
08:52:20 <benmachine> "bSegmentation fault
08:52:21 <copumpkin> the pressure builds up over several weeks
08:52:24 * gwern doesn't get that one
08:52:28 <gwern> ah well
08:52:29 <gwern> @flush
08:54:04 <gwern> also, 'beggin' is misspelled
08:54:21 <gwern> unless mmorrow has converted to Cockney
08:55:03 <sclv_> its colloquial
08:57:09 <gwern> sclv_: your mom's colloquial
08:57:20 <gwern> (by which I mean she is in common use amongst the rabble)
08:57:31 <sclv_> oO
08:57:38 <sclv_> @slap gwern
08:57:38 * lambdabot submits gwern's email address to a dozen spam lists
08:57:50 <copumpkin> "your mom" jokes tend to be safer in environments where you know that said mothers are not dead
08:58:21 <gwern> copumpkin: it's good either way
08:59:02 <sclv_> not that I hope for an answer, but I'll ask again: anybody explore the difference between the mmap and bytestring-mmap packages?
08:59:16 <copumpkin> @hackage mmap
08:59:17 <lambdabot> http://hackage.haskell.org/package/mmap
08:59:50 <copumpkin> sclv_: one gives a ptr and the other ones packages it up in a bytestring?
08:59:50 <gwern> sclv_: I knew the answer at one time!
08:59:56 <copumpkin> dunno :)
08:59:57 <fbru02> hey guys stupid cuestion when papers have the ^ is it the function "and" ?
09:00:08 <sclv_> both can pack it into a bytestring
09:00:19 <copumpkin> fbru02: probably, unless it's xor :P
09:00:22 <sclv_> the question is whether one or the other is preferable for doing so.
09:00:38 <fbru02> copumpkin: thanks !
09:00:44 <gwern> sclv_: I vaguely remember the difference had something to do with either portability or functionality.
09:00:46 <copumpkin> fbru: ‚àß, right?
09:00:48 <gwern> hope that helps!
09:00:53 <fbru02> copumpkin: yes
09:01:02 <sclv_> gwern: yep, its useful.
09:01:15 <sclv_> i'll stick with bytestring-mmap for now since the functionality is adequate.
09:01:42 <copumpkin> mmap was updated yesterday!
09:01:55 <copumpkin> or I guess today, technically
09:01:57 <sclv_> but now that you point it out, mmap works on windows too, whereas bytestring depends on unix.
09:02:06 <sclv_> so in the future that might make more sense for me
09:02:19 <aavogt> is it possible to use multiple MonadReader constraints?
09:02:55 <sclv_> aavogt: probably not a good idea
09:03:33 <sclv_> but possible, i think.
09:03:47 <sclv_> you just have to lift your asks explicitly
09:04:02 <aavogt> this is for a type class however...
09:04:17 <aavogt> yeah, I'd know how to do it with explicit lifts
09:04:22 <sclv_> why would you want to do that?
09:04:49 <aavogt> because I have one base environment
09:05:08 <aavogt> and then an additional environment to add depending on the credentials a user provides
09:05:26 <aavogt> it is convenient to have separate types for the two
09:05:52 <aavogt> but I guess that doesn't work since ask won't know which env to take the data from
09:06:01 <sclv_> ?ty :t do {x <-lift ask; y <-ask;return (x,y)}
09:06:02 <lambdabot> parse error on input `:'
09:06:05 <sclv_> ?ty do {x <-lift ask; y <-ask;return (x,y)}
09:06:05 <ToRA> @type do { (x1 :: Int) <- ask  ; (x2 :: Bool) <- ask ; return () }
09:06:06 <lambdabot> Top level:
09:06:06 <lambdabot>     Couldn't match expected type `Int' against inferred type `Bool'
09:06:06 <lambdabot>     When using functional dependencies to combine
09:06:07 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) r. (MonadReader a m, MonadTrans t, MonadReader r (t m)) => t m (a, r)
09:06:11 <aavogt> and I would rather not define a class isomorphic to MonadReader
09:06:40 <aavogt> ah, so it is possible!
09:06:49 <ToRA> aavogt: no, it's not
09:06:55 <ToRA> because of the fundep on MonadReader
09:07:01 <sclv_> right. you just need to lift the ask
09:07:07 <copumpkin> durn fundeps
09:07:27 <ToRA> @type do { (x1 :: Int) <- ask  ; (x2 :: Bool) <- lift ask ; return () }
09:07:28 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadReader Int (t m), MonadReader Bool m, MonadTrans t) => t m ()
09:07:32 <mmorrow> sclv_: bytestring-mmap has the PROT_* and MAP_* flags hard-coded in C, and the mmap pkg (iirc) gives you some choice but is much more complicated (not to say it's "complicated")
09:07:34 <aavogt> ToRA: I wasn't sure how to write the types for the MonadTrans t stuff
09:07:49 <sclv_> mmorrow: thanks!
09:08:33 <mmorrow> sclv_: i use the bytestring-mmap pkg when i don't care about the options, and usually copy-paste-tweak from this when i want the C interface http://moonpatio.com/repos/ohhai.hs
09:08:37 <sclv_> are you still playing with the possibility of reifying ghc data structures directly to disk btw
09:09:28 <mmorrow> sclv_: definitely, although i haven't done anything with it in the last week or so due to some other things
09:09:41 <mmorrow> sclv_: but i definitely intend to
09:09:50 <aavogt> mmorrow++
09:10:26 <sclv_> awesome. i've got a potential use case.
09:12:19 <mmorrow> i love the name of the castPtrToFunPtr function
09:12:42 <mmorrow> can haz a fun ptr? kthx!
09:13:02 <mmorrow> function ptrs are always more fun
09:17:29 <quicksilver> copumpkin: hazPtrCanHazLolPtr?
09:18:10 <copumpkin> no u no can haz
09:18:32 <quicksilver> bah. I didn't ask for an API which makes judgment calls on my requests!
09:18:48 <quicksilver> on the other hand, I probably meant to address my remark to mmorrow
09:23:52 <bastl> would it be possible to implement a generic zipper with the SYB approach ?
09:23:59 <sclv_> there's a paper on it
09:24:20 <sclv_> ?go scrap your zippers
09:24:20 <lambdabot> Maybe you meant: google googleit do
09:24:26 <sclv_> ?google scrap your zippers
09:24:28 <lambdabot> http://www.cs.indiana.edu/~adamsmd/papers/scrap_your_zippers/
09:24:28 <lambdabot> Title: Functional Pearl: Scrap Your Zippers
09:24:57 <sclv_> there's some relatively ugly stuff going on there though.
09:25:24 <sclv_> there are other generics libraries based on a sum of products view that have a cleaner way to do it.
09:25:51 <sclv_> ?hackage multirec
09:25:51 <lambdabot> http://hackage.haskell.org/package/multirec
09:27:22 <bastl> I know multirec, but i have to reason, why to choose multirec. Whats the benefit over SYB ? (Or: what is the ugly stuff in that scapr your zipper?)
09:28:24 <sclv_> syb is very slow and inefficient, compared to the other generics approaches. it also relies on more dynamism under the hood. it is also very very powerful.
09:28:55 <McManiaC> how can i compile my programm staticly?
09:29:09 <sclv_> also, scrap your zippers is just a paper. multirec is an actual hackage library
09:30:16 <sclv_> syz lets you zip over anything though, not just some mutually recursive set of data structures.
09:31:25 <FunctorSalad> yeah multirec doesn't use dynamic casts AFAIK
09:31:43 <dreixel> no casts on multirec.
09:32:08 <bastl> ok, thanks.
09:32:19 <Rotaerk> ew, getting rid of zippers would result in overexposure
09:32:20 <sclv_> the neat bit of syz however is that it creates a zipper at the type level which describes traversal possibilities.
09:32:30 <FunctorSalad> btw you can use my multirec-alt-deriver to derive multirec for more types ;) *shameless plug*
09:32:35 <sclv_> which is not efficient, but is super cute.
09:33:14 <dreixel> I hadn't heard of this syz stuff. I'll have a look, sounds interesting
09:33:26 <bastl> FunctorSalad: reference?
09:33:29 <c_wraith> McManiaC:  You mean with no dependencies on dynamic libraries?
09:33:30 <McManiaC> how can i compile staticly against a lib? I wrote a backup-tool which is supposed to run on blank systems, but its dependent on libcurl, which is missing on most blank systems‚Ä¶
09:33:35 <McManiaC> yup
09:33:45 <FunctorSalad> bastl: http://hackage.haskell.org/package/multirec-alt-deriver
09:34:27 <FunctorSalad> one thing I don't like about multirec yet is that the generic fold is basically unusable for larger types
09:34:42 <c_wraith> McManiaC: Pass whatever options are necessary to ghc to get it to pass the correct options for gcc in the final linking phase.  Yes, I know that's not very helpful, but I haven't done it before.
09:34:57 <FunctorSalad> (you need to supply the folding algebra for the sum-of-products view)
09:35:20 <FunctorSalad> which is essentially an n-tuple of constructor handlers, if you have n constructors in your type
09:36:52 <FunctorSalad> maybe one should derive a record type "FooAlgebra"
09:37:17 <FunctorSalad> like "ListAlgebra a r = { foldNil :: r, foldCons :: a -> r -> r }"
09:37:23 <McManiaC> c_wraith: hmmm‚Ä¶
09:37:33 <McManiaC> so, no easy solution =(
09:38:16 <quicksilver> FunctorSalad: I find it all over the ugliness threshold, personally
09:38:17 <saml> > solve x(x-1) = 0
09:38:18 <lambdabot>   <no location info>: parse error on input `='
09:38:25 <quicksilver> FunctorSalad: (compared to hand-written zippers + lenses)
09:38:40 <quicksilver> FunctorSalad: there seems to be this annoying ugliness / boilerplate tradeoff
09:38:44 <FunctorSalad> quicksilver: which? multirec? syb? both?
09:39:18 <FunctorSalad> quicksilver: I suppose you're referring to all the conversions between isomorphic types
09:39:43 <c_wraith> McManiaC: I think it's relatively easy, you just need to know the right flags.  -static is the flag gcc needs
09:40:34 <quicksilver> FunctorSalad: I meant multirec, and yes, the conversions between isomorphic types are a big part of the problem.
09:40:53 <c_wraith> McManiaC:  In fact, -static is supported by ghc, too.  Maybe it does what you need?
09:41:42 <bastl> FunctorSalad: does your deriveEverything work for really large datatypes?
09:42:15 <c_wraith> McManiaC: hmm, that's not it for ghc.  Need to pass it to gcc.
09:42:19 <FunctorSalad> bastl: yeah I think I got it to work for the GHC Haskell AST in the end
09:42:27 <FunctorSalad> bastl: but didn't try to do anything with that yet
09:42:31 <sclv_> quicksilver: i'm a big fan of hand-written compos myself.
09:43:06 <sclv_> eventually the problem is that my interesting data structures are now all gadts of some sort.
09:43:13 <McManiaC> c_wraith: how do i pass it to gcc?
09:43:44 <bastl> FunctorSalad: cool I had problems with multirecs derivation thing for a Java grammar.
09:44:36 <FunctorSalad> bastl: can't promise everything but it's probably worth a try to see whether the balanced trees help
09:44:42 <FunctorSalad> *promise anything
09:44:45 <bastl> k
09:45:21 <bastl> ill give feedback afterwards
09:46:11 <FunctorSalad> ok
09:46:18 <c_wraith> McManiaC: In theory, optl passes it to the linking phase.  But I get a bunch of errors when I try to do that, so maybe it's not easy
09:46:39 <McManiaC> hm okay
09:46:54 <McManiaC> gotta run, gonna try it later again
09:47:07 <c_wraith> Ask again later.  People who know the answer might be around :)
09:47:33 <quicksilver> http://www.nabble.com/Static-linking-td24642775.html
09:47:37 <quicksilver> might be the answr.
09:47:43 <FunctorSalad> quicksilver: btw what is a lens?
09:47:44 <quicksilver> google for ghc static linking there are millions of posts on it.
09:47:48 <quicksilver> FunctorSalad: a functional reference
09:48:04 <quicksilver> to my mind they go hand in hand with zippers
09:49:39 <bastl> quicksilver: you mean like a pointer to a position in a complex term?
09:50:07 <quicksilver> it's like that, yes.
09:50:14 <FunctorSalad> I thought that is the task of the zipper
09:50:19 <quicksilver> it's a function for extracting a position, and a function for updating it
09:50:28 <quicksilver> (that is, returning a new version of the structure with the value changed)
09:50:45 <quicksilver> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
09:50:50 <quicksilver> for one particular implementation
09:50:55 <quicksilver> data.accessor on hackage is another
09:51:12 <twanvl_> fclabels is perhaps better
09:53:25 <raim0_> how do I profile my code with ghci?
09:53:46 <Lemmih> raim0_: You don't.
09:53:57 <raim0_> what about timing?
09:54:58 <Saizan_> :set +s
09:55:02 <Lemmih> raim0_: :set +s prints timing/memory stats after each evaluation.
09:55:15 <raim0_> ok this is just what I needed, thanks
09:55:27 <FunctorSalad> raim0_: ghci is way slower than ghc-compiled code
09:55:30 <FunctorSalad> could be misleading
09:56:17 <raim0_> it's still equally slow on different functions so I can try out which implementation gives the best performance
09:56:37 <raim0_> right?
09:56:46 <Saizan_> i don't think that's true in general
09:57:23 <quicksilver> ghci doesn't do any optimisation
09:57:37 <quicksilver> and optimisation may improve some kinds of code substantially more than others
09:57:50 <raim0_> hmm ok
09:58:10 <sclv_> also see timeIt
09:58:13 <raim0_> if I load the code from a file with :load it doesn't get optimized?
09:58:26 <fasta> Isn't +s kind of pointless?
09:58:29 <Saizan_> no
09:58:30 <sclv_> raim0_: if the file is precompiled then it works fine
09:58:45 <sclv_> ?hack timeIt
09:58:45 <lambdabot> http://hackage.haskell.org/package/timeIt
09:59:21 <Saizan_> ?hack criterion
09:59:21 <lambdabot> http://hackage.haskell.org/package/criterion
09:59:26 <fasta> All the Hackage packages that tried to do anything remotely useful to timing, never worked thusfar. But I didn't try timeIt or criterion.
09:59:45 <fasta> criterion is probably what I would try, if I was ever interested in it again.
10:00:06 <con> hello
10:03:49 <FunctorSalad> raim0_: btw compile with -O2 for full optimization
10:06:30 <gwern> > 72 / 5
10:06:31 <lambdabot>   14.4
10:07:07 <con> let 2-3 = "Hello World"
10:07:14 <con> 2-3
10:07:35 <copumpkin> > let 2 - 3 = "Hello world" in 2 - 3
10:07:36 <lambdabot>   "Hello world"
10:07:48 <con> lol
10:09:16 <sclv_> anyone remember offhand if Set.toList . S.fromList is faster, slower, or the same as map . head . group. sort ?
10:09:31 <sclv_> erm, map head . group . sort that is
10:09:46 <con> No idea
10:09:52 <sclv_> or is there just a way faster way to do it?
10:11:13 <copumpkin> sclv_: I'd imagine they'd be pretty similar
10:11:19 <copumpkin> sclv_: criterion!
10:13:43 <quicksilver> sclv_: I would guess that the Set version is slightly faster
10:13:59 <quicksilver> it amounts to a heap sort which removes duplicates eagerly rather than at the end
10:14:08 <quicksilver> but, it's only a guess.
10:14:12 <copumpkin> true
10:15:53 <maltem> quicksilver, oh, do they call "sort by inserting into a tree" heap sort even if the heap isn't embedded into an array?
10:15:56 <sclv_> the set version turns out to be significantly faster
10:16:20 <sclv_> although if anyone has a faster still idea i'm all for it.
10:18:37 <quicksilver> maltem: well that's what I was skating over when I said "amounts to"
10:18:53 <quicksilver> maltem: its not really exactly the same, no. But it's similar in many respects.
10:20:49 <maltem> right, just wanted to be sure I remembered this right
10:21:37 <copumpkin> sclv_: what kinds of values are you using?
10:21:45 <copumpkin> removing duplicates from, that is
10:22:31 <Baughn> Rather than putting the Snapshot version of a data structure in a separate module to avoid name clashes and be able to use the record field disambiguation extension, I should.. what?
10:24:12 <sclv_> copumpkin: big old list of int64s. also i want the sorting.
10:24:33 <copumpkin> sclv_: if only IntMap weren't so restricted, you could do it even faster with that
10:24:41 <copumpkin> sclv_: unless you're willing to bet that you're on a 64-bit system
10:24:50 <copumpkin> I mean IntSet
10:25:09 <sclv_> copumpkin: yeah. in general for what i'm doing i could use a 64 bit intset all over the place.
10:25:52 <sclv_> I could also have bit the bullet and used ints instead of int64s everywhere.
10:26:06 <sclv_> and thus made my entire project machine-dependent.
10:33:29 <sproingie> > Learn You Yet Another Real World Gentle Haskell (LYYARWGH)
10:33:30 <lambdabot>   Not in scope: data constructor `Learn'Not in scope: data constructor `You'N...
10:33:38 <sproingie> good title?
10:34:01 <pikhq> LYYARWGH sounds painful.
10:34:12 <sproingie> don't it tho? :)
10:34:27 <sproingie> http://www.fishbulb.net/wiki/Haskell_Tutorial
10:34:32 <sproingie> not much there right now
10:37:07 <burp> awesome
10:37:37 <sproingie> the meat of it starts in chapter 2.  still looking for a mediawiki extension that adds forward/back links automatically
10:37:53 <sproingie> otherwise i guess i should just write a template to add them
10:38:50 <quicksilver> perhaps someone should write a tutorial on how to choose names for haskell tutorials.
10:39:31 <sproingie> quicksilver: actually i think i'm going to write some code for the tutorial to generate tutorial names
10:39:53 <quicksilver> excellent
10:40:19 <amaron> sproingie: "haskell without pain" ?
10:40:39 <sclv_> haskell by and for beginners
10:41:01 <copumpkin> quicksilver: or a tutorial on how to write monad tutorials
10:41:06 <sproingie> haskell by and for gentle beginners without learn you a pain
10:41:09 <copumpkin> (as a monad tutorial in disguise!)
10:41:31 <Twey> sproingie: Hahaha, nice
10:42:07 <shambler> this is fun
10:42:09 <shambler> :)
10:42:10 <sproingie> it'll be a nice introduction to random
10:42:36 <ray> activate the haskell centers of your brain
10:43:40 <shambler> The Big Haskeller
10:44:09 <amaron> haskellize your brain
10:47:16 <sproingie> there we go, template navbar added
10:48:20 <shambler> looks nice
10:49:14 <sproingie> right now needs a login to edit anything, working on a captcha
10:49:28 <sproingie> i think the talk pages are open to any comment, not sure
10:49:55 <Twey> sproingie: LYAH has got to screw up the Markov chains for that one
10:50:12 <sproingie> heck yah
10:59:52 <monochrom> <h1>Tutorial on How to Write a Monad Tutorial</h1> <p>Just don't. The end.</p>
11:00:16 <shambler> but why
11:00:42 <shambler> there is never enough
11:01:38 <int-e> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:01:42 <FunctorSalad> how about higher-order monad tutorials?
11:02:07 <int-e> that is the long version of monochroms monad meta-tutorial.
11:02:34 <shambler> btw http://lambda-the-ultimate.org/node/3659
11:02:52 <FunctorSalad> I read that article but I think you can't really teach about the problem with monad tutorials, you have to write a few monad tutorials yourself to get an intuition for it
11:02:57 <FunctorSalad> ;)
11:03:15 <monochrom> Arrows are popular?! :)
11:03:55 <FunctorSalad> all the cool kids are deriving their own arrow subclasses these days
11:04:06 <shambler> hehe
11:05:42 <Vanadium> Why is there interest in a gmp-less ghc? Licensing?
11:06:08 <monochrom> Yes.
11:06:29 <Vanadium> aw
11:06:29 <Saizan_> and sometimes porting
11:15:25 * FunctorSalad thinks there are too many hackages with zero haddock :-(
11:15:46 <FunctorSalad> documentation matters
11:16:09 <EvilTerran> altho default haddock is little better
11:16:34 <FunctorSalad> EvilTerran: I meant no haddock comments
11:16:34 <EvilTerran> (i usually end up reading the source anyway if there's only type declerations in the haddock)
11:16:57 <EvilTerran> ah, then we're in vigorous agreement :P
11:17:14 <FunctorSalad> sometimes there are normal comments that could be haddock comments o_o
11:18:26 * FunctorSalad has horribly confused himself with an explicitly recursive type whose *fixpoint* should be a monad in turn
11:18:53 <copumpkin> the fixpoint of an already recursive type? :o
11:19:18 <Liskni_si> is there a way to write haddock comments so that lhs2TeX would not blow up?
11:19:25 <FunctorSalad> copumpkin: I mean this style: Data Exp exp a = Var a | Plus (exp a) (exp a) | Mult (exp a) (exp a)
11:19:48 <FunctorSalad> I now think Fix-ing the higher-order part (the exp) has nothing to do with monadicness in a
11:20:25 <Twey> Liskni_si: Just write them normally.
11:20:30 <FunctorSalad> with "explicit recursion" I mean that you have 'exp' as an parameter instead of directly calling 'Exp'
11:20:32 <Twey> > -- | Haddock comment
11:20:33 <lambdabot>   not an expression: `-- | Haddock comment'
11:20:38 <Twey> lambdabot: Hush you
11:20:49 <FunctorSalad> @eat Twey
11:20:49 <lambdabot> Maybe you meant: eval fact faq ft keal let map part read what
11:20:56 <Twey> Hehe
11:20:58 <Liskni_si> Twey: matching `|' not found
11:21:16 <Twey> Liskni_si: Did you remember to put the > before the line?
11:21:27 <Liskni_si> it's inside \begin{code}
11:21:33 <Twey> Hm
11:22:13 * mornfall has a tendency to suggest more stupid sed trickery...
11:22:46 <FunctorSalad> oh god, sed
11:22:49 <FunctorSalad> :)
11:23:05 <Twey> Liskni_si: http://www.haskell.org/haskellwiki/Literate_programming#Hiding_code_from_Latex
11:23:08 <Twey> Maybe this?
11:23:19 * Liskni_si said he'd never use sed again after sedding the doxygen latex output to something nice
11:23:47 <mornfall> Twey: The blowup happens before tex is even run, I guess.
11:23:55 <Liskni_si> yep, as mornfall sais
11:23:56 <Twey> Hm.
11:24:02 <Liskni_si> or says, even
11:24:03 * mornfall suggests cabal unpack lhs2tex
11:24:07 <Twey> So it's Haskell that's complaining about matching |s?
11:24:11 <Twey> But we don't match |s‚Ä¶
11:24:21 <Liskni_si> it's lhs2TeX :-)
11:24:40 <Liskni_si> well, ok, i'll fix lhs2TeX then
11:24:53 <dons> http://twitter.com/andreypopp/statuses/5229115539
11:24:54 <dons>  hehe
11:25:34 <Liskni_si> oh hell, lhs2TeX's svn is not working :-(
11:25:57 <mornfall> It's in TeXParser, so maybe it is, afterall, mis-parsing something.
11:26:04 <mornfall> Or it's trying to post-process something.
11:26:41 <Liskni_si> well, it's supposed to replace |bleble| by {\texcode bleble} or something like that
11:26:48 <Liskni_si> but only outside of code
11:31:04 <jkramer> Hi
11:31:42 <benmachine> here is a question which is not very haskelly but sort of close-ish
11:31:52 <benmachine> how do people here usually type ‚àÄ and similar?
11:32:16 * benmachine doesn't want to be memorising unicode numbers and doesn't see how to persuade xmodmap to generate them
11:32:26 <Zao> Ah yes, "little squished black box of doom".
11:32:35 <jkramer> I'd like to build a chain of functions that may return Nothing, but without checking for Nothing
11:32:46 <Zao> If my Haskell has unicode glyphs in it, it's because Leksah put them there.
11:33:33 <jkramer> For example: meh = foo . bar . baz . quux, where foo, baz, baz and quux are of type a -> Maybe a
11:33:43 <Zao> Chain them with >>= ?
11:33:45 <benmachine> jkramer: <=<
11:33:56 <benmachine> well, yeah either
11:34:04 <benmachine> :t (<=<)
11:34:05 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
11:34:08 <FunctorSalad> benmachine: one way to do it in emacs:
11:34:12 <FunctorSalad> (yas/define 'haskell-mode "forall" "‚àÄ")
11:34:26 <FunctorSalad> (after typing "forall", press tab to expand)
11:34:33 <jkramer> Thanks, I'll try that
11:34:33 * benmachine doesn't use emacs
11:34:53 <FunctorSalad> outside of emacs I use scim
11:35:05 <copumpkin> @type \f g -> find f <=< find g
11:35:06 <lambdabot> forall c. (c -> Bool) -> ([c] -> Bool) -> [[c]] -> Maybe c
11:36:02 <benmachine> jkramer: p.s. <=< is in Control.Monad
11:36:31 <benmachine> hey if you were feeling particularly adventurous you could Kleisli everything and then use Control.Category.. :P
11:36:36 <benmachine> but that would be weird
11:36:38 <ray> Control.Nomad
11:36:41 <copumpkin> Kleisli is ugly
11:36:48 <ray> you're ugly
11:36:52 <benmachine> zzzing
11:36:52 <copumpkin> I mean, its behavior is nice, but having to write Kleisli everywhere is a pain
11:36:55 <benmachine> yeah
11:36:56 <copumpkin> ray: damn, you got me
11:37:18 <benmachine> I use Kleisli where tuples in monads are involved
11:37:22 <ray> that's because haskell sucks
11:37:30 <copumpkin> benmachine: yeah, or Either
11:37:38 <sproingie> er does haskell understand ‚àÄ as an alias for "forall"?
11:37:44 <copumpkin> sproingie: with UnicodeSyntax
11:37:58 <Gracenotes> hello :o
11:38:08 <copumpkin> no hello 4 u
11:38:10 <jkramer> benmachine: Thanks, but I think >>= will do the job too :)
11:38:12 <shambler> @yarrr
11:38:13 <lambdabot> Avast!
11:38:15 <sproingie> copumpkin: {-# LANGUAGE: UnicodeSyntax #-} i take it?
11:38:19 <copumpkin> sproingie: yep
11:38:27 <sproingie> didn't know that.
11:38:38 <sproingie> i take it it understands lambda then?
11:38:41 <benmachine> no
11:38:51 <benmachine> lambda is already a valid identifier character I think
11:38:55 <sproingie> huh
11:39:04 <sproingie> i get it's a letter, but it's also a symbol.  oh well.
11:39:05 <monochrom> unfortunately, Œª is alphanumeric
11:39:12 <Gracenotes> copumpkin: *commences latin techno beat* hello 4 u, haskell for me
11:39:13 <copumpkin> yeah :(
11:39:21 <Twey> > ‚àÄ
11:39:22 <lambdabot>   Not in scope: `forall'
11:39:23 * benmachine would support a special case
11:39:28 <Twey> Haha
11:39:29 <Twey> Nice
11:39:34 <Twey> It just expands it
11:39:36 <copumpkin> benmachine: me too, or just complicating the parser to make it distinguish the two uses
11:39:52 <benmachine> > ‚àÄ‚àÄ
11:39:53 <Twey> > let ‚àÄ = 3 in forall
11:39:53 <lambdabot>   <no location info>: parse error on input `‚àÄ‚àÄ'
11:39:54 <lambdabot>   3
11:39:56 <benmachine> :(
11:40:01 <monochrom> > let 4 ‚àÄ 5 = 6 in 4 ‚àÄ 5
11:40:02 <lambdabot>   <no location info>: Parse error in pattern
11:40:03 <Gracenotes> > let ‚àÄ = "‚àÄ" in text $ ‚àÄ ++ "x. x"
11:40:04 <lambdabot>   ‚àÄx. x
11:40:08 <Twey> > let forall = 5 in ‚àÄ
11:40:09 <lambdabot>   5
11:40:15 <sproingie> hŒªlfLife = "goddammit it's an L, not an A"
11:40:17 <sproingie> er
11:40:17 <monochrom> Oh!
11:40:21 <Twey> sproingie: :-D
11:40:24 <copumpkin> sproingie: fail
11:40:31 <sproingie> > let hŒªlfLife = "goddammit it's an L, not an A"
11:40:32 <lambdabot>   not an expression: `let hŒªlfLife = "goddammit it's an L, not an A"'
11:40:41 <sproingie> > let hŒªlfLife = "goddammit it's an L, not an A" in hŒªlfLife
11:40:42 <lambdabot>   "goddammit it's an L, not an A"
11:40:43 <Twey> halfŒªife
11:40:47 * maltem finds \ is a much better symbol than Œª for a lambda abstraction anyways
11:40:54 <Twey> maltem: Why?
11:40:54 <benmachine> haŒªfŒªife?
11:40:56 <monochrom> haŒªf life
11:40:58 <copumpkin> maltem: I hate it
11:41:08 <benmachine> Œªx just looks pretty
11:41:15 <maltem> Twey, because I do read Œª as a letter / variable name
11:41:18 <Twey> Ah
11:41:19 <medfly> I find (\x-> awfully pretty.
11:41:20 <sproingie> (Œªx.x/2) life
11:41:23 <Twey> Haha, maltem
11:41:27 <Gracenotes> > let „ÅÑ„Å° = 1; „Å´ = 2, „Åï„Çì = 3 in „ÅÑ„Å° + „Å´ + („Å´*„Åï„Çì)
11:41:28 <lambdabot>   <no location info>: parse error on input `,'
11:41:29 <monochrom> Ax=Œªx is the most elegant ever!
11:41:34 <Twey> I have the opposite problem
11:41:56 <medfly> > let „ÅÑ„Å° = 1; „Å´ = 2; „Åï„Çì = 3 in „ÅÑ„Å° + „Å´ + („Å´*„Åï„Çì)
11:41:57 <lambdabot>   9
11:42:04 <Twey> My maths teacher used Œª as a variable the other day and I couldn't scan it
11:42:06 <Gracenotes> grr, semicolon
11:42:07 <maltem> copumpkin, I'd really prefer (x -> t) anyways
11:42:10 <Twey> Gracenotes: :√æ
11:42:26 <copumpkin> > let ‰∏Ä = 1; Âõõ = 4 in ‰∏Ä + Âõõ
11:42:27 <lambdabot>   5
11:42:34 <monochrom> The matrix people are very happy that Œª is a letter so they can continue using it for eigenvalues in their code!
11:42:39 <copumpkin> damn, it should print ‰∫î
11:42:46 <medfly> haha
11:42:53 <medfly> it's not THAT smart :)
11:43:03 <Gracenotes> copumpkin: make a newtype of Char that has an Enum instance
11:43:17 <Gracenotes> hm. or of String, rather
11:43:18 <monochrom> lambdabot pretends to not pass the turing test.
11:43:27 <Gracenotes> Num and Show too :)
11:44:04 <Gracenotes> although.. it would still not be able to parse identifiers in that manner :)
11:44:44 <Cale> http://translate.google.com/translate_t#en|ja|one%20million (people have probably seen this, but it's still funny :)
11:45:02 <copumpkin> lol
11:45:10 <Gracenotes> Google has problems with Chinese number translation too
11:45:19 <benmachine> > let a ‚äÇ b = null (a \\ b) in [1,2,3] ‚äÇ [1 .. 10]
11:45:20 <lambdabot>   True
11:45:25 <Gracenotes> sometimes the corpus just doesn't include everything >_>
11:46:08 <benmachine> man, how long has google has a translator?
11:46:18 <copumpkin> corporibus paribus
11:46:23 <Badger> forever
11:46:35 <Badger> benmachine: a what b?
11:46:58 <luite> hm, why does ghc 6.12 for windows still use ghc 3.4.5? is there some compatibility problem with 4.4?
11:47:04 <Cale> http://translate.google.com/translate_t#ja|en|%E4%B8%87 -- this is significantly worse.
11:47:09 <luite> sorry, still use (mingw) gcc 3.4.5
11:47:10 <copumpkin> luite: you mean gcc?
11:47:17 <benmachine> > let a `what` b = null (a \\ b) in [1,2,3] `what` [1 .. 10]
11:47:18 <lambdabot>   True
11:47:18 <sproingie> ghc 3.4.5 would be, like, old
11:47:19 <copumpkin> Cale: wow
11:47:30 <Badger> >_>
11:47:30 <copumpkin> Cale: I like how it has a good suggestion on the side
11:47:32 <benmachine> Badger: uhm, subset of
11:47:48 <Badger> I mean, what was the character :P
11:47:49 <benmachine> > text '\x2282'
11:47:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:47:51 <lambdabot>         against inferred ty...
11:47:53 <medfly> like before 2006
11:47:58 <Badger> oh
11:47:58 <benmachine> > text "\x2282"
11:47:59 <lambdabot>   ‚äÇ
11:48:03 <Badger> invisible!
11:48:10 <Twey> Cale: Argh!
11:48:18 <benmachine> everything is invisible to those who can't see.
11:48:23 <Cale> http://translate.google.com/translate_t#ja|en|%E4%B8%87%E5%86%86 -- now it doesn't even have the nice suggestion
11:48:23 <Badger> hrm, I'm sure utf-8 is supposed to work
11:48:24 <copumpkin> "translation = million; dictionary = ten thousand"
11:48:31 <copumpkin> wow
11:48:34 <Twey> Off by three
11:48:37 <monochrom> "U+2282 subset of"
11:48:37 <benmachine> > text "\x232c"
11:48:37 <copumpkin> someone needs to fix that
11:48:38 <lambdabot>   ‚å¨
11:48:42 <maltem> uuh. when translating to German, it's "Mio."
11:48:42 <Twey> ‚Ä¶ orders of magnitude, that is
11:48:50 <copumpkin> Twey: only two
11:48:57 <Gracenotes> hm. same thing with ‰∏á„Éâ„É´
11:48:57 <medfly> it's funny how this channel is expected to understand Japanese.
11:49:00 <Gracenotes> darn counters (!)
11:49:02 <copumpkin> medfly: duh
11:49:06 <Twey> copumpkin: Oh yeah.  :√æ
11:49:14 <Badger> It's all Twey's fault, to be honest.
11:49:19 <medfly> it just shows how insanely nerdy this channel is.
11:49:19 <Twey> Haha
11:49:21 <monochrom> Yeah, we should write more Chinese.
11:49:30 <Badger> medfly: ...programming language? yes?
11:49:30 <maltem> I hoped it was just because the English-speaking guys cannot count anyways, having a billion be a thousand millions
11:49:44 <medfly> shit
11:49:46 <copumpkin> monochrom: so far we've been pretty neutral
11:49:46 <benmachine> ‚àÄx. this channel is expected to understand x
11:49:50 <Twey> It's because it's used as $generic_large_number
11:50:16 <copumpkin> computer nerds all know japanese anyway
11:50:16 <benmachine> (often does)
11:50:21 <copumpkin> especially japanese computer nerds
11:50:28 <Twey> Haha
11:50:38 <medfly> Badger, even for a programming language channel
11:50:44 <copumpkin> I think it's a requirement for a CS degree anyway
11:50:52 <zygoloid> maltem: well, that's just because billiards became better known as a ball game than as numbers
11:50:53 <Badger> medfly: Haskell is cutting edge. :)
11:50:58 <luite> sproingie: gcc 3.4.5 is also quite old, the release used by ghc seems to be from january 2006 (perhaps with some additional patches, since the files on sourceforge are from april 2008)
11:51:02 <Gracenotes> the fact that the orders of magnitude between adjacent number names differ in English vs. Japanese probably doesn't help either
11:51:13 <monochrom> You mean $(generic_large_number)  (template haskell)
11:51:18 <Badger> The forefront of nerdy endeavours!
11:51:21 <copumpkin> „Éè„Çπ„Ç±„É´
11:51:22 <luite> not as old as ghc 3.4.5 though :)
11:51:29 <copumpkin> I propose we rename the language
11:51:31 <luite> (of that version ever existed)
11:51:31 <Gracenotes> (same with Japanese and Chinese and Korean, vs. English and most Indo-European)
11:51:33 <luite> if
11:51:37 <Twey> Aye
11:51:38 <Badger> copumpkin: Haskerr
11:51:48 <Twey> Hahaha
11:51:55 <copumpkin> hasukeru
11:51:56 <Twey> Hasukeru
11:52:00 <Twey> Damn :√æ
11:52:05 <maltem> zygoloid, hah, and milliards is miniature billiards or something?
11:52:10 <Gracenotes> see for yourself, http://ja.wikipedia.org/wiki/Haskell
11:52:20 <maltem> damn that wasn't funny
11:52:24 <medfly> what am I supposed to be seeing, Gracenotes?
11:52:34 <medfly> milliard means 10^9 here ;)
11:52:53 <Vanadium> crazy~
11:53:05 <Gracenotes> medfly: uh.. scribbles? >_>
11:53:18 <sproingie> how many countries are still using that old definition of billion?
11:53:26 <Gracenotes> cough england
11:53:40 <maltem> what's the "old" one?
11:53:41 <int-e> germany
11:53:56 <int-e> 10^12, presumably
11:54:08 <Twey> England is on the cusp
11:54:18 <copumpkin> old?
11:54:21 <sproingie> yes, old
11:54:21 <ksf> any evil hax0rz around that can tell me how to make wget ignore a robots.txt without indulging in modifying the source?
11:54:25 <Twey> A lot of scientific applications use the American version
11:54:33 <copumpkin> long scale vs. short scale
11:54:34 <Gracenotes> ksf: set user agent to something innocuous
11:54:40 <copumpkin> never really heard it expressed as old vs. new
11:54:40 <Twey> ksf: Touch an empty robots.txt and set noclobber
11:54:50 <Gracenotes> ^ less hacky way I think
11:54:53 <ksf> well the robots.txt says user agent *
11:55:17 <Gracenotes> ah. that might be an issue. just make sure you're not doing anything recursive :)
11:55:20 <sproingie> i prefer to speak in "zillions" and "hojillions"
11:55:30 <jfoutz> hrm. it would be really cool to have an RTS that spoke directly to a hypervisor.
11:55:31 <medfly> I prefer 10^n :)
11:55:33 <copumpkin> bajillions
11:55:35 <Gracenotes> beyond one or two levels
11:55:36 <copumpkin> djillions
11:55:38 <Twey> Or touch an empty robots.txt and set noclobber.
11:55:41 <sproingie> brazillions
11:55:55 <medfly> 10^brazillion
11:55:58 <medfly> hehe
11:56:22 <Gracenotes> well. what Twey said, but some websites hate recursive wget, particularly if they are not purely hierarchical. don't make 'em ban your IP or something >_>
11:56:33 <ksf> Twey, thanks, works like a charm
11:56:37 <zygoloid> Gracenotes: I'd say that here in England the billion = 10^9 meaning is far more common, except amongst the reasonably old :)
11:56:43 <jfoutz> brazillion^olympics
11:57:05 <aavogt> what is 10^6 then?
11:57:12 <Gracenotes> milyuns and milyuns
11:57:16 <maltem> > let fixillions = fix (*10^3) in fixillions
11:57:20 <lambdabot>   mueval-core: Time limit exceeded
11:57:29 <Gracenotes> everyone agrees on that I think
11:57:31 <ksf> well I've just leeched the enormous amount of 60KiB
11:57:36 <aavogt> > iterate (*10^3) 1
11:57:36 <lambdabot>   [1,1000,1000000,1000000000,1000000000000,1000000000000000,10000000000000000...
11:57:46 <Gracenotes> ksf:  D:  D:  D:
11:57:48 <zygoloid> > let fixillions = fix (*10^3) :: Natural in fixillions > 42
11:57:52 <lambdabot>   mueval-core: Time limit exceeded
11:58:00 <monochrom> weak
11:58:03 <medfly> fixillions:))
11:58:05 <copumpkin> > let fixillions = fix (*10^3) in fixillions > (3 :: Natural)
11:58:08 <lambdabot>   mueval-core: Time limit exceeded
11:58:09 <ksf> heck a recursive wget on the http interface is going to be more efficient than any svn checkout.
11:58:13 <medfly> I'm probably the least nerdy person in here
11:58:13 <Gracenotes> > let fixillions = fix ((10^3)*) :: Natural in fixillions > 42
11:58:14 <copumpkin> damn
11:58:17 <lambdabot>   mueval-core: Time limit exceeded
11:58:19 <ksf> ...especially since I don't want the whole repo.
11:58:21 <copumpkin> Gracenotes: I failed, you failed
11:58:49 <Gracenotes> hm. I thought the argument order might change something.
11:58:49 <monochrom> perhaps 42 < fixillions helps
11:58:55 <copumpkin> oh, it might
11:58:56 <zygoloid> oops, fixillions \elem {_|_, 0, fix succ}
11:59:05 <copumpkin> I sort of doubt it though
11:59:09 <copumpkin> > let fixillions = fix (*10^3) in3 < fixillions
11:59:10 <zygoloid> no escape unless you can avoid it being 0
11:59:10 <lambdabot>   not an expression: `let fixillions = fix (*10^3) in3 < fixillions'
11:59:15 <copumpkin> > let fixillions = fix (*10^3) in 3 < fixillions
11:59:19 <lambdabot>   mueval-core: Time limit exceeded
11:59:20 <Gracenotes> in3, my favorite keyword
11:59:29 <copumpkin> mine too!
11:59:30 <monochrom> oh well
11:59:34 <camio> > iterate (2^) 2
11:59:35 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
11:59:42 <Gracenotes> oh, uh, don't forget about Natural
11:59:46 <copumpkin> oh true
11:59:51 <copumpkin> > let fixillions = fix (*10^3) in (3 :: Natural) < fixillions
11:59:52 <Gracenotes> not like it'll help
11:59:54 <copumpkin> yeah
11:59:55 <lambdabot>   mueval-core: Time limit exceeded
12:00:04 <FunctorSalad> > let fixillions = fix (10^3 *) in fixillions > (3::Natural)
12:00:08 <lambdabot>   mueval-core: Time limit exceeded
12:00:08 <aavogt> > 10^3 :: Natural
12:00:09 <lambdabot>   1000
12:00:24 <maltem> @src Natural
12:00:24 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:00:27 <maltem> weak
12:00:27 <aavogt> > (10^3)^2 :: Natural
12:00:29 <lambdabot>   1000000
12:00:33 <FunctorSalad> it can't work because the result depends on whether the tail is zero.
12:00:35 <Gracenotes> I think the problem is (*).
12:00:41 <Gracenotes> if you used (+), it would work
12:00:42 <benmachine> 1000 * fix (10^3 *) -- can't really be done lazily
12:00:52 <zygoloid> Gracenotes: the problem is that 0 is a fixed poiunt
12:00:58 <FunctorSalad> 1000 * undefined > 42 is undefined
12:01:00 <monochrom> Oh! * is hard.
12:01:15 <maltem> > let fixillions = fix ((+1) . (*10)) in 3 < (fixillions : Natural)
12:01:16 <lambdabot>   Not in scope: data constructor `Natural'
12:01:22 <maltem> > let fixillions = fix ((+1) . (*10)) in 3 < (fixillions :: Natural)
12:01:25 <Gracenotes> and furthermore, if I recall correctly about argument order it would work for fix (x+), not fix (+x)
12:01:26 <lambdabot>   mueval-core: Time limit exceeded
12:01:38 <zygoloid> Gracenotes: yeah, that's a problem too :)
12:01:43 <Gracenotes> *test* this seems correct
12:02:14 <ksf> well bugger. I need the top-level jamfiles.
12:02:17 <Gracenotes> the usual peano order
12:02:26 <Gracenotes> if there is one -_-
12:02:37 <FunctorSalad> I hate this kind of error:     Occurs check: cannot construct the infinite type: tb = Maybe tb
12:02:37 <FunctorSalad>     When generalising the type(s) for `biBind'
12:02:58 <FunctorSalad> hard to find the cause if it's a huge function
12:03:10 <benmachine> make it into smaller functions then
12:03:37 <Gracenotes> some functions are unavoidably big, without a *lot* parameter-passing
12:03:38 <ksf> add more type annotations
12:03:56 <Twey> Or better data types
12:04:19 <aavogt> bah, haddock doesn't like comments inside TH splices!
12:04:32 <Gracenotes> it is somewhat annoying to not be able to tell where a type error happens. at least type annotations can force them at more obvious places :/
12:04:38 <FunctorSalad> to add type annotations, I need to add an explicit forall, which makes the haddock hard to read ;)
12:04:44 <aavogt> or it looks at the syntax inside the splices
12:05:14 <FunctorSalad> aavogt: latter
12:05:19 <FunctorSalad> aavogt: I think it drops the comments
12:06:25 <aavogt> well I commented out some tycons and then haddock barfs. Rather unfortunate overlap in syntax
12:06:56 <aavogt> at least because I set darcs so run a test on record
12:07:14 <aavogt> so then I loose track of which changes I wanted to add to the patch
12:07:56 <aavogt> however, I think setting it up that way is slightly worth it, since that means I can move patches around and likely keep my repo in a buildable state
12:13:24 <FunctorSalad> is (x>>=return) = x a rewrite rule?
12:13:57 <FunctorSalad> (yes, it is ;) ... I mean does it come with GHC)
12:14:02 <zygoloid> FunctorSalad: i think GHC does that when expanding do-notation
12:14:14 <zygoloid> i'm not sure it's a {-# RULES rule though
12:18:28 <FunctorSalad> as far as I can decipher ghc-core it isn't :(
12:18:44 <FunctorSalad> don't trust programmers to obey the axioms?
12:19:54 <Vanadium> According to http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v:evaluate (x>>=return)=x is not actually true :)
12:21:58 <Cale> FunctorSalad: I don't think that anything GHC does while compiling assumes that monads actually satisfy the monad laws.
12:22:35 <Cale> (But it wouldn't be completely unreasonable for it to expect them to hold)
12:22:55 <Cale> Similarly, no laws are assumed for instances of Num
12:23:13 <FunctorSalad> so it makes sense to add the rule for your monad if it holds...
12:23:51 <aavogt> rewrite rules can be for specific instances?
12:24:10 <aavogt> or does one write a rule for concatMap
12:24:12 <FunctorSalad> hmm not sure actually
12:24:22 <aavogt> and then define =<< in terms of concatMap (for lists)
12:24:23 <Cale> I think you can restrict them by type...
12:25:33 <Cale> Yeah, and inside of a RULES, lexically scoped type variables are available
12:29:53 <quicksilver> FunctorSalad: I think that >>=return is not a very interesting optimisation; and in those cases where it is, it's quite likely to be a case of some other optimisation (assuming everything inlines)
12:30:04 <quicksilver> FunctorSalad: in particular, SpecConstr
12:31:10 <FunctorSalad> quicksilver: I just had the case of specializing a more general function in a way that ultimately hands 'return' to (>>=)
12:31:33 <Liskni_si> can i force ghci to ignore scope to be able to break on not-exported functions?
12:31:39 <FunctorSalad> I wouldn't want it to traverse the whole structure in that case
12:32:02 <Liskni_si> err, ignore something else than scope, but you get the idea ;)
12:33:55 <FunctorSalad> meh Traversable should be derivable, it is *very* boilerplate
12:34:33 <FunctorSalad> yes, derive package, but the threshold of inhibition for pulling that one out is higher ;)
12:36:48 <Gracenotes> as far as I know it is not so easy to add derivability, even when there is a simple algorithm :(
12:37:47 <Gracenotes> "easy" meaning something close to "built-in"
12:38:04 <Gracenotes> not derive
12:38:07 <FunctorSalad> you mean the relevant part of GHC is complicated?
12:43:48 <aleator> Hmm.. c2hs is telling me "/usr/include/stdlib.h:272: (column 20) [ERROR]  >>> error Syntax error !The symbol `^' does not fit here" Is this snow leopard screwing me over again?
12:45:11 <sinelaw> aleator, out of curiosity, what does that line actually contain?
12:46:10 <jkramer> Why are there two types of exceptions in haskell?
12:46:13 <aleator> sinelaw: int      atexit_b(void (^)(void));
12:46:25 <Gracenotes> FunctorSalad: looking into it, it seems each is built-in to the compiler, very ad hoc
12:47:04 <jkramer> aleator: I think it needs to be * instead if ^
12:48:23 <aleator> jkramer: That'd make sense. But it appears in other places as well
12:48:24 * dancor lol at "out of curiosity"
12:49:08 <Gracenotes> FunctorSalad: there is a series of guards (in ./typecheck/TcDeriv.lhs) that checks conditions for each derivation. checkSideConditions :: DynFlags -> Class -> [TcType] -> TyCon -> DerivStatus
12:49:23 <jkramer> Maybe they obfuscated it a little so wannabe hackers can't compile that c00l h4x0r toolz :)
12:49:26 <aleator> Ah! It is this newfangled block thingy apple did.
12:49:36 <aleator> Now how do I turn it off..
12:49:55 <Gracenotes>  | cls_key == ixClassKey = Just (cond_std `andCond` cond_enumOrProduct), or | cls_key == readClassKey = Just (cond_std `andCond` cond_noUnliftedArgs), etc. the only ones that can be applied unconditionally seem to be Eq, Ord and Show
12:50:30 <Gracenotes> assuming that the contained types cooperate
12:50:34 <jkramer> When I have to use both types of exceptions in a module, is there a nicer way than using Prelude.catch and Control.Exception.catch?
12:51:14 <aleator> How do I get c2hs to undefine something like #ifdef __BLOCKS__
12:51:17 <Gracenotes> ideally, perhaps, GHC should make it more general. but there may be reasons as well for not doing this (this is still in the type-checking phase, after all)
12:51:37 <aavogt> jkramer: you can import Prelude as P, or some other name
12:51:50 <jkramer> Hrm
12:51:54 <jkramer> It's still ugly :)
12:53:21 <jkramer> Hrm, when importing Prelude qualified as P I have to prepend P. to everything, not only P
12:53:25 <jkramer> Err, catch
12:53:28 <aavogt> no
12:53:39 <aavogt> don't use the qualified keyword
12:53:48 <jkramer> just import Foo as F?
12:53:49 <Gracenotes> or just import Prelude hiding (catch)
12:54:00 <jkramer> But I need both catch'es
12:54:17 <Gracenotes> also make a qualified import. use that when you need Prelude.catch
12:54:25 <FunctorSalad> Gracenotes: hmm removing the check alone won't do it of course
12:54:33 <Gracenotes> or, actually, just say "Prelude.catch"
12:54:41 <FunctorSalad> (you need custom code for each class)
12:54:44 <Gracenotes> FunctorSalad: yeah, there are many cases where it branches off in a coded-in way
12:54:57 <Gracenotes> checking for side conditions being one of them
12:55:09 <BONUS> pcatch = Prelude.catch
12:55:19 <monochrom> import X hiding (catch); import X (catch) qualified; do this to Y.
12:55:46 <monochrom> I'll spell it out.
12:55:54 <jkramer> Why are there two kinds of exceptions anyway?
12:56:00 <jkramer> I don't see the difference
12:56:09 <BONUS> actually there are three i think :D
12:56:14 <jkramer> :(
12:56:19 <monochrom> import X hiding (catch); import X (catch) qualified; import Y hiding (catch); import Y (catch) qualified; now you have both X.catch and Y.catch, and there is no catch.
12:56:56 <BONUS> the catch in prelude catches IOErrors
12:57:04 <jkramer> monochrom: import Control.Exception as E \ import Prelude as P worked, thanks
12:57:07 <Gracenotes> the actual derivation code is found in TcGenDeriv.lhs .. it is very ghc-internal-y :)
12:57:07 <BONUS> which are basically bad stuff that can happen while in IO
12:57:36 <BONUS> and then you have Control.Exception, which can be used for making hierarchical exceptions and they don't have to be thrown from IO (but they must be caught there, which is why i consider them bad)
12:57:39 <monochrom> It works if you don't mind accidentally writing "catch".
12:58:37 <jkramer> But why are people wrapping IO Exceptions (like file not found) into Control.Monad exceptions?
12:59:10 * Twey would vastly prefer Either Handle IOError
12:59:22 <Twey> What's that package?  explicit-exception?
12:59:23 <jkramer> ack
12:59:30 * copumpkin would vastly prefer having a whole separate type for errors, that isn't Either
12:59:31 <jkramer> Data.FileStore
12:59:55 <benmachine> shouldn't that be Either IOError Handle >_>
12:59:55 <BONUS> jkramer: you mean like ErrorT and stuff?
13:00:02 <Twey> cognominal: explicit-exception does that
13:00:11 <Twey> benmachine: By convention, aye ‚ò∫
13:00:26 <benmachine> so you know when it did the Right thing
13:00:30 <jkramer> BONUS: I don't know ErrorT
13:00:44 <aavogt> copumpkin: data Either' a b = Wrong a | Right b
13:01:26 <BONUS> i'd say that (besides some uses in concurrent programming) you should never use exceptions for anything other than IO errors
13:01:44 <jkramer> I fully agree :)
13:01:52 <BONUS> and rather leverage types like Either to represent errors in pure code
13:02:02 <jkramer> Especially not SomeExceptions instead of IO exceptions for io errors
13:02:17 <BONUS> yeah
13:02:18 <benmachine> why do we use exceptions for IO errors, anyway
13:03:08 <jkramer> Maybe so you can do lots of IO stuff that might fail and catch all errors in one single place?
13:03:21 <jkramer> It's not a completely bad idea, imo
13:03:41 <jkramer> But I don't see why there have to be several exception types that wreck each others namespaces
13:04:17 <BONUS> well IOError and friends are from the H98 standard afaik
13:04:28 <benmachine> lots of stuff that might fail... isn't that what >>= is for?
13:04:37 <dancor> i think you can get that same control flow behavior with Either too
13:04:56 <benmachine> mm
13:05:04 <BONUS> and then GHC added Exception, and then decided to represent Exception a little differently and Exception was moved to OldException and then SomeException and friends came in
13:05:08 <Gracenotes> it's in the Haskell-program monad :)
13:05:26 <jkramer> dancor: But then you would have to check the result of each io operation before you can continue, I think
13:05:28 <Gracenotes> where everything is automatically lifted into may-throw-IO-exception
13:05:47 <dancor> jkramer: no you would use monad-ery
13:05:57 <benmachine> jkramer: you check everywhere that you checked for exceptions before
13:06:13 <jkramer> Can I chaing eithers with >>= ?
13:06:16 <jkramer> *chain
13:06:20 <benmachine> if you make them a Monad yes
13:06:27 <dancor> Either is a Monad
13:06:28 <jkramer> Ok, nice
13:06:33 <benmachine> there may be some argument about exactly how to do that
13:06:41 <benmachine> but only because there are several sensible ways
13:06:43 <jkramer> Then I want Eithers instead of exceptions too :)
13:07:20 * dancor is unsure
13:07:42 <twanvl_> exceptions are nice for things like division by 0 and array index out of bounds
13:07:56 <benmachine> hmm
13:08:02 <benmachine> that's what error is for, if you ask me
13:08:07 <benmachine> and that doesn't have to be an exception
13:08:15 <benmachine> i.e. it doesn't have to be catchable
13:08:18 <twanvl_> there should be a way to catch these errors
13:08:22 <benmachine> just don't do that :P
13:08:22 <twanvl_> for robust programs
13:08:31 <benmachine> it's like array indices in C
13:08:37 <benmachine> don't do them out of bounds, or things go wrong
13:08:54 <twanvl_> you wouldn't want GHCi to crash every time you divided by 0
13:08:55 <benmachine> technically you CAN catch a segfault, but you'd be much better off not causing one in the first place
13:09:05 <jkramer> Hrhr
13:09:25 <benmachine> ghci doesn't run haskell code in its thing
13:09:44 <jkramer> I did that once when I started with C, I thought it was a really clever thing to do to protect myself from seg faults
13:09:49 * benmachine fails to recall the proper word for thing
13:09:59 <benmachine> but ghci could be robust without error being catchable
13:10:02 <jkramer> It's just like catch(Exception e) { /* ignore all errors */ } in Java
13:11:18 <prof_nimnul> hi. Is there a safe analog of !! like Int -> [a] -> Maybe a or something
13:11:52 <twanvl_> prof_nimnul: there is a 'safe' package, it probably has a function like that
13:12:04 <Gracenotes> nothing built-in :( it is simple to implement though
13:12:19 <copumpkin> I thought there was
13:12:21 <jkramer> prof_nimnul: http://hackage.haskell.org/packages/archive/safe/0.2/doc/html/Safe.html might be helpful
13:12:39 <jkramer> atMay
13:12:43 <copumpkin> wow, there isn't
13:12:44 <copumpkin> that's stupid
13:12:56 * benmachine remembers writing a !? at some point
13:13:17 <benmachine> ah yes
13:13:19 <opqdonut> what did it do?
13:13:21 <benmachine> xs !? n = listToMaybe $ drop n xs
13:13:31 <prof_nimnul> atMay
13:13:32 <opqdonut> ah, hehe
13:13:34 <monochrom> Ha
13:13:54 <twanvl_> atMay is pig latin for mat
13:14:25 <benmachine> prof_nimnul: if you import Data.Maybe (listToMaybe) you can use my definition
13:14:33 <benmachine> agree it should be in a library somewhere though
13:15:16 <benmachine> (well, kind of; lists aren't really meant to be indexed
13:15:30 <dancor> my (!?) performs a random assembly instruction that is suprising but not clearly-unsound
13:15:42 <BONUS> :t (fmap.fmap) listToMaybe (flip drop)
13:15:43 <lambdabot> forall a. [a] -> Int -> Maybe a
13:16:00 <Gracenotes> okay then, meeting-going time
13:16:34 <prof_nimnul> benmachine: :t Safe.atMay
13:16:39 <prof_nimnul> :t Safe.atMay
13:16:40 <lambdabot> forall a. [a] -> Int -> Maybe a
13:16:43 <benmachine> okay
13:16:47 <benmachine> but my name is better :)
13:16:51 <jkramer> Narf
13:17:35 <jkramer> Why does ghc complain about Exception e having embiguous type in (\ _ -> return Nothing) ?
13:17:44 <jkramer> *ambigous
13:18:18 <prof_nimnul> benchMachine: Lists are not meant to provide random access. I use atMaybe only once, as a replacement for head . drop
13:18:52 <mauke> jkramer: because it doesn't know which type you want to catch
13:19:09 <jkramer> But I don't want to catch anything :)
13:19:18 <benmachine> bench >_>
13:19:18 <BONUS> jkramer: try (\e::SomeException -> return Nothing) .... it's a bit strange, but there you go
13:19:21 <jkramer> There's nothing I the world I care less about than the type of e
13:19:33 <jkramer> Ok
13:19:33 <benmachine> but yeah
13:20:09 <jkramer>  Result signatures are no longer supported in pattern matches
13:20:20 <mauke> jkramer: what function are you using this in, then?
13:20:26 <jkramer> catch
13:20:44 <jkramer> Control.Exception.catch, to be precise
13:20:49 <orclev_> ok, I've got a problem that I figure someone in here could probably help with, as haskell tends to attract a people with a strong maths background... the short version is, I want to improve my math skills (I've gotten up to college calculus with a smattering of random higher maths I've picked up over the years)...
13:21:31 <BONUS> try #math
13:21:36 <mauke> jkramer: why are you using catch if you don't want to catch anything?
13:21:41 <BONUS> unless you're asking for homework help, those people are really nice
13:21:51 * Twey looks at BONUS.
13:22:00 <BONUS> :D
13:22:06 <jkramer> mauke: Because the program aborts if I don't. I just want to turn the result into a Maybe
13:22:25 <mauke> jkramer: try 'try'
13:23:01 <jkramer> Oh, great
13:23:04 <jkramer> Thanks
13:25:02 <ystael> BONUS: some fraction of us are nice, some fraction of the time. :)
13:25:13 <Twey> Heheh
13:25:17 <Twey> Spoken like a true mathematician
13:25:28 <ystael> ex-, but it'll never rub off.
13:25:49 <Twey> :√æ
13:26:07 <hackagebot> WL500gPControl 0.3.4 - A simple command line tools to control the  Asus WL500gP router (VasylPasternak)
13:27:11 <jkramer> mauke: Now I have the same problem in the first argument of either when resolving the result of try :(
13:27:22 <jkramer> E.try (load) >>= return . either (const Nothing) (Just . read)
13:28:25 <sinelaw> preflex, seen PeakerWork
13:28:25 <preflex>  PeakerWork was last seen on #haskell 19 hours, 2 minutes and 34 seconds ago, saying: Axman6: I think Haskell already has most of what's good in most Lisps.  Scheme is nice for its tinyness (very nice power to size ratio), and otherwise the Lisps have some niceness regarding dynamic reload of code.  Not that much
13:28:25 <mauke> either (\e -> const Nothing (e :: SomeException))
13:28:30 <sinelaw> preflex, seen Peaker
13:28:30 <preflex>  Peaker was last seen on #haskell 4 days, 3 hours, 52 minutes and 41 seconds ago, saying: mercury^, Its not a set, its a list with potential repetitions
13:29:42 <jkramer> mauke: Excepellent, works :)
13:29:51 <jkramer> -pe
13:37:12 <stanv> :) what is intersection for two arbitrary lists ?
13:37:43 <jkramer> :t intersection
13:37:45 <lambdabot> Not in scope: `intersection'
13:37:47 <jkramer> :t intersect
13:37:48 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:38:12 <hackagebot> XMPP 0.0.3 - XMPP library (OlegIvanov)
13:38:24 <jkramer> Oh, sweet
13:39:38 <jkramer> When I have something like 'where foo = take 10 $ someList' in a function and use it several times, foo evaluated every time or just once?
13:40:00 <mauke> wrong question
13:40:25 <jkramer> And without the $?
13:40:27 <mauke> the interesting part is if 'take 10' is called several times (no)
13:40:32 <Liskni_si> Twey, mornfall: well, it seems lhs2TeX is intentionally parsing comments as TeX source, and in TeX source, replaces |blabla| with monospaced blocks
13:40:40 <stanv> > intersect [1,2,2] [2,1]
13:40:41 <lambdabot>   [1,2,2]
13:40:46 <stanv> :(
13:40:52 <Liskni_si> and haddock isn't very happy with ||, which lhs2TeX renders as |
13:41:01 <jkramer> nub $ intersect [1,2,2] [2,1]
13:41:06 <jkramer> > nub $ intersect [1,2,2] [2,1]
13:41:07 <benmachine> jkramer: $ is irrelevant (probably doesn't even get compiled)
13:41:07 <lambdabot>   [1,2]
13:41:15 <benmachine> (in most cases)
13:41:22 <jkramer> Yup, just a typo
13:41:25 <Twey> Liskni_si: Ah, huh.
13:41:34 <benmachine> oic
13:41:38 <Liskni_si> is literate haskell supposed to contain haddock comment, anyway?
13:41:40 <mornfall> Liskni_si: Sounds like lhs2tex should learn about haddock syntax then.
13:41:57 <mornfall> Liskni_si: Yes, haddock explicitly supports lhs.
13:42:14 <jkramer> > nub $ [1,2,2] ++ [1,2]
13:42:17 <lambdabot>   [1,2]
13:44:08 <Liskni_si> mornfall: well, yes, but what goes into haddock comments and what into the text around code blocks?
13:44:37 <mornfall> Liskni_si: Well, haddocks is for API docs.
13:45:00 <mornfall> Btw. darcs has lhs files with haddocks in them and it seems to work.
13:45:24 <Liskni_si> gimme a link, I'd like to see how the text looks
13:45:46 <Liskni_si> (blbej ƒçechismus, kurva) :-)
13:45:56 <mornfall> : - )
13:46:11 <mornfall> Liskni_si: In darcs, the literate documentation goes into user manual, for historical reasons.
13:46:35 <mornfall> So basically, stuff concerning users goes into lit and developers into haddock.
13:46:56 <mornfall> (I make no optimality claims here, though.)
13:48:20 * Liskni_si looks at darcs sources
13:48:32 <mornfall> We don't do lhs2tex though. We just strip the code out.
13:48:55 <mornfall> (With comments and all.)
13:49:47 <stanv> > [2,2,4] // [4,2]
13:49:48 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
13:49:49 <lambdabot>         against inferred t...
13:49:50 <Liskni_si> well, that's my point
13:50:04 <aavogt> > "hellov" \\ "stanv"
13:50:05 <lambdabot>   "hello"
13:50:17 <Liskni_si> that if you don't strip code and comments, the lit text and comments might not go well together
13:50:20 <stanv> > [2,2,4] \\ [4,2]
13:50:21 <lambdabot>   [2]
13:50:27 <stanv> non predictable :(
13:50:36 <stanv> 2 is in second list tooo
13:50:38 <stanv> :((
13:50:43 <mornfall> Yeah. Well, dunno.
13:50:49 <aavogt> it is repeated applications of delete
13:50:52 <aavogt> @src (\\)
13:50:53 <lambdabot> (\\) = foldl (flip delete)
13:50:53 <mornfall> You should probably make them go well together. :)
13:51:01 <stanv> ah
13:51:02 <stanv> :(
13:51:11 <aavogt> and delete doesn't remove all occurences
13:51:18 <mornfall> stanv: Just use Set if you want set. :)
13:51:21 <aavogt> > delete 'a' $ repeat 'a'
13:51:22 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
13:51:50 <Liskni_si> hm, yeah, makes sense
13:52:32 <Liskni_si> the more I think about it, the more I think I should just tell lhs2TeX to not treat | specially, as I might like to typeset the .lhs file without lhs2TeX
13:52:55 <Liskni_si> so that I have to use \verb|| instead of just || in text
13:56:55 <Cale> http://www.theonion.com/content/news/u_s_continues_quagmire_building -- hahaha
13:58:29 <stanv> is standard function to delete all occurences element in [] ?
13:58:41 <mornfall> stanv: filter?
13:58:59 <mornfall> > filter (/=1) [1,2,1,2,3,1]
13:59:00 <lambdabot>   [2,2,3]
14:00:33 <BONUS> > filter (/=3) [1,2,3,4,3,2,1]
14:00:34 <lambdabot>   [1,2,4,2,1]
14:00:42 <BONUS> haha Cale
14:03:41 <sinelaw> how can i convert an Int to a GLint?
14:03:49 <Cale> sinelaw: fromIntegral
14:03:58 <Cale> (same way you convert it to anything else)
14:04:05 <sinelaw> fromIntegral :) i just did it
14:04:07 <[pini]> hi
14:04:14 <Cale> hello
14:04:18 <BONUS> hi
14:04:29 <yoneda> cale: it's not to all tastes, of course, but compare the immortal: http://www.theonion.com/content/news_briefs/israeli_pm_debuts_new_road
14:04:53 <Cale> yoneda: haha
14:06:38 <[pini]> suppose I have T, a type synonym of (Integer, Integer). I instantiated succesfully Eq for T by adding a TypeSynonymInstances pragma. However, whenever  I try to compare two T values, I get an error because of overlapping instances of Eq (mine and the one in Data.Tuple, imported along with Prelude). Is there a way to force the use of my own instance ?
14:07:00 <benmachine> sinelaw: I think most of the places you can use an Int you can use a GLint just as well
14:07:13 <benmachine> so maybe you could just replace a few type names and it'd still work
14:07:39 <sinelaw> benmachine, i'm patching frag senselessly to make it work
14:07:42 <Cale> [pini]: No, what you want is a newtype or data declaration
14:07:50 <sinelaw> not really know what i'm doing, to tell the truth :)
14:07:59 <mornfall> [pini]: Use newtype.
14:08:00 <benmachine> sinelaw: I was doing that earlier too
14:08:00 <[pini]> Cale: yes, that's what I was using before
14:08:05 <benmachine> but I got bored.
14:08:08 <benmachine> but yeah
14:08:24 <Cale> [pini]: Type synonyms are just syntactic sugar. Your type T is treated identically in all ways to (Integer, Integer), and so you can't redefine existing instances.
14:08:24 <HayashiRazan> :t benmachine
14:08:25 <sinelaw> benmachine, how far did you get?
14:08:25 <lambdabot> Not in scope: `benmachine'
14:08:26 <benmachine> while I was doing it, s/Int/GLint/ (or vice versa) worked surprisingly often
14:08:34 <[pini]> ok
14:08:38 <HayashiRazan> :t pini
14:08:39 <lambdabot> Not in scope: `pini'
14:08:45 <mornfall> pikhq: Although it's a little curious as to what definition of equality you came up with that's different from the default one. :)
14:08:51 <benmachine> about halfway through, but at some point I reverted everything because I realised I should be doing work instead
14:08:54 <mornfall> Drat.
14:08:58 <mornfall> [pini]: ^
14:08:59 <benmachine> halfway through by number-of-modules-compiled
14:09:02 <mornfall> pikhq: (mistab, sorry)
14:09:14 <HayashiRazan> :t mornfall
14:09:15 <lambdabot> Not in scope: `mornfall'
14:09:17 <stanv> > foldl (flip (\ x -> filter (/=x))) [2,2,1,4] [2,1]
14:09:18 <lambdabot>   [4]
14:09:21 <stanv> :))
14:09:25 <[pini]> mornfall: type synonym used to implement a rational-like type
14:09:42 <benmachine> sinelaw: I got pretty far without knowing what I was doing
14:09:42 <[pini]> my real issue is that T gets used as a parameter for another type, which in turn gets used as a parameter for another type, ... and pattern matching on the last type gets a lot of constructors in the way
14:09:45 <mornfall> [pini]: Ah. Well, that really should be a newtype then, or so.
14:09:51 <[pini]> ok
14:09:54 <pikhq> mornfall: Is okay.
14:09:59 <benmachine> but nearly always replacing types rather than converting between them
14:11:03 <iaefai> If I wanted to make a associative list (map?) for a data type data Piece = Bishop | Rook | Knight | King | Queen | Pawn   and if I wanted to make a list of strings that would be their associated text, what would I have to do to the data type to turn them into a list?
14:11:04 <benmachine> pikhq: or you could use a data type similar to a tuple, like data T = Integer :/ Integer
14:11:48 <benmachine> then it'd be usable very much like a tuple but with a distinct constructor
14:12:17 <[pini]> hmm, yes maybe an infix constructor could help
14:12:18 <[pini]> thx
14:12:38 <twanvl_> iaefai: why not make a function  pieceToString :: Piece -> String
14:13:14 <iaefai> twanvl_: I am going to be having a few different possible representations, so I would just like to make the appropriate lists and be able to map them easier
14:14:10 <[pini]> what is the default priority for infix constructors ?
14:15:17 <twanvl_> iaefai: then you could use an assocation list: [(Bishop,"bishop"),(Rook,"rook")...]
14:15:31 <Cale> "Any operator lacking a fixity declaration is assumed to be infixl 9"
14:15:45 <Cale>  -- The Haskell 98 Report
14:15:58 <[pini]> thx
14:16:03 <HayashiRazan> No instance for (Cale (t -> t))
14:16:49 <Twey> Hehe
14:17:30 <Twey> Eh
14:17:47 <Cale> HayashiRazan: Êó•Êú¨‰∫∫„Åß„Åô„ÅãÔºü
14:18:03 <Twey> iaefai: I'd be tempted: data Piece = Bishop | Rook | Knight | King | Queen deriving Show; pieceToString = map toLower . show
14:18:42 <sinelaw> benmachine, 27 of 39
14:19:13 <benmachine> sinelaw: I remembered while doing it that someone had mentioned doing this before, was that you?
14:19:22 <sinelaw> nope
14:19:23 <Twey> 21:08:24 < Cale> [pini]: Type synonyms are just syntactic sugar. Your type T is treated identically in all ways to (Integer,  Integer), and so you can't redefine existing instances.
14:19:41 <Twey> Unless you use {-# LANGUAGE TypeSynonymInstances #-}‚Ä¶
14:19:51 <Cale> Twey: No, even if you do that.
14:20:00 <medfly> Twey, YOU SUCK
14:20:10 <iaefai> Is there any class i can derive that would automatically place those constructors in a list?
14:20:16 <stepcut> if I compile my app with -O2 I get missing symbols when linking against a certain cabal package, but with out -O2 it is fine...
14:20:16 <Twey> Cale: Really?
14:20:20 <Cale> All that TypeSynonymInstances does is cause the synonyms to be expanded inside of instance declaration heads.
14:20:29 <Twey> Cale: I thought that was what things like String used.
14:20:33 <Cale> Nope.
14:20:37 <stepcut> am I doing something wrong, or is this a compiler bug ?
14:20:39 <Cale> String uses a special trick
14:20:41 <Twey> medfly: Why now?  :√æ
14:20:46 <Twey> Cale: What trick is that?
14:20:52 <Cale> :t showList
14:20:53 <lambdabot> forall a. (Show a) => [a] -> String -> String
14:20:54 <medfly> I'm just translating Cale's words into human language
14:21:02 <Cale> hey!
14:21:03 <Twey> medfly: Hahaha
14:21:09 <con> doWhile :: (Int -> Int) -> (Int -> Bool) -> Int -> Int
14:21:22 <con> doWhile func cond ex
14:21:49 <Cale> showList is a method of the Show class which explicitly defines how lists of values of that type ought to be shown, the instance of Show for lists calls it
14:22:01 <con> 2-1
14:22:06 <HayashiRazan> let a = 12; b=24; c=36; in a + b + c
14:22:12 <con> 2-3
14:22:20 <Cale> It's an ugly special cased hack, basically ;)
14:22:43 <Twey> Cale: Ah :-\
14:23:07 <HayashiRazan> let a = 12; b = 24; c = 36; in a + b + c
14:23:11 <Cale> We could use OverlappingInstances to do it now, but that's obviously an extension :)
14:23:19 <HayashiRazan> lambdabot
14:23:19 <medfly> > let a = 12; b = 24; c = 36; in a + b + c
14:23:20 <lambdabot>   72
14:23:49 <iaefai> :t showList
14:23:50 <lambdabot> forall a. (Show a) => [a] -> String -> String
14:24:04 <iaefai> :t readList
14:24:05 <lambdabot> forall a. (Read a) => String -> [([a], String)]
14:24:28 <iaefai> :t readList . fst
14:24:29 <lambdabot> forall a b. (Read a) => (String, b) -> [([a], String)]
14:24:36 <iaefai> :t fst . readList
14:24:37 <lambdabot>     Couldn't match expected type `(a, b)'
14:24:37 <lambdabot>            against inferred type `[([a1], String)]'
14:24:37 <lambdabot>       Expected type: String -> (a, b)
14:24:41 <con> Anybody help me here? I'm getting an inferred type error on this line
14:24:42 <con> 	| cond(func(ex)) = func(ex)
14:24:52 <iaefai> :t readList . showList
14:24:53 <lambdabot>     Couldn't match expected type `[Char]'
14:24:53 <lambdabot>            against inferred type `String -> String'
14:24:53 <lambdabot>     Probable cause: `showList' is applied to too few arguments
14:25:06 <Cale> con: well... first of all, the brackets are all strange, though that's probably not your problem
14:25:19 <Cale> con:  | cond (func ex) = func ex
14:25:33 <con> whoops
14:25:44 <con> thanks :D, i'm a java programmer
14:26:20 <Cale> con: What are the types of cond and func and ex?
14:26:50 <con> (Int -> Int) -> (Int -> Bool) -> Int -> Int
14:27:11 <Cale> umm...
14:27:13 <con> I've been given a task to implement a doWhile loop
14:27:21 <Cale> okay
14:27:29 <Cale> Just for Int values?
14:27:33 <con> yep
14:27:35 <Twey> :t until
14:27:36 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:27:58 <Cale> until might stop too early...
14:28:01 <Twey> :t flip until . (not .)
14:28:02 <lambdabot> (Bool -> Bool) -> (Bool -> Bool) -> Bool -> Bool
14:28:06 <Twey> Drat
14:28:12 <con> how so?
14:28:13 <Cale> Though, of course, you could always apply the function once more ;)
14:28:31 <con> doWhile :: (Int -> Int) -> (Int -> Bool) -> Int -> Int
14:28:32 <Twey> @pl \f -> until (not f)
14:28:33 <lambdabot> until . not
14:28:38 <Twey> Oh.  Duh.
14:28:40 <Cale> However, the goal is to *implement* it, rather than find the thing in the standard library :)
14:28:41 <con> doWhile func cond ex
14:28:54 <con> is it in the standard library?
14:29:03 <Cale> con: More or less.
14:29:06 <Twey> @pl \f g x -> until g (not f) x
14:29:06 <lambdabot> flip until . not
14:29:16 <Twey> Huh.  Well, okay.
14:29:45 <Cale> con: So, the guards are a good idea
14:29:48 <con> So it is
14:30:10 <con> ok
14:31:00 <Twey> Cale: I did implement it!  :√æ
14:31:09 <con> I dunno whats happening with the type error though :/
14:31:13 <Cale> Twey: that is true :)
14:31:24 <Cale> con: I would have to see the error and your whole program
14:31:28 <Cale> hpaste.org/new
14:32:05 <Cale> con: However, that line still looks wrong, in that you probably don't want to stop when the condition is true.
14:32:26 <Twey> Hm
14:32:32 <Twey> I think the problem is the initial check, not the last one
14:32:44 <Cale> con: Rather you'll want to continue the loop, so the right hand side of the = should have a doWhile somewhere in it ;)
14:33:22 <Cale> aha
14:33:37 <Cale> 	| otherwise = doWhile func(func(ex))
14:33:40 <Cale> this is the problem
14:33:41 <con> Is that not the point of a doWhile loop? :/
14:34:01 <Cale> con: The point is to continue looping *while* the condition remains true
14:34:16 <Cale> Not *until* it becomes true :)
14:34:16 * con bangs head off of keyboard
14:34:23 <con> lol
14:34:32 <Cale> in the otherwise case there
14:34:38 <con> thanks for all your help
14:34:43 <Cale> you're calling doWhile with only two parameters
14:34:44 <sinelaw> benmachine, 34 of 39
14:34:56 <Cale> which is what the type error is complaining about
14:35:02 <benmachine> sinelaw: nice going
14:35:10 <Cale> You forgot to pass along the condition for continuing.
14:36:01 <Cale> It's saying "Hey, (func ex) is an Int, but I need an Int -> Bool here
14:36:06 <con> lol, i fail so bad at haskell
14:36:18 <con> its a really obvious mistake aswell
14:36:38 <Cale> con: Thankfully it won't let you run these programs ;)
14:36:42 <monochrom> type-oriented programming is the top of all programming
14:37:26 <con> Thanks for all your help, it starts now
14:37:42 <con> i'll just have to change the conditions about
14:43:47 <FunctorSalad> haddock doesn't have boldface does it?
14:47:22 <monochrom> "emphasis" becomes italic and I like it.
14:47:54 <monochrom> You could hack the css to get boldface.
14:49:26 <saml> how can i convert python file to haskell?
14:49:37 <mauke> by piping it through a programmer
14:49:44 <ddarius> You look at the python and then you write Haskell.  You can omit the first step if you like.
14:49:54 <Twey> Hahaha
14:50:05 <Twey> Yeah, I prefer to work from inputs and outputs :√æ
14:50:06 <copumpkin> @remember saml <saml> how can i convert python file to haskell? <mauke> by piping it through a programmer
14:50:07 <lambdabot> It is forever etched in my memory.
14:51:00 <fxr> what the heck is a doWhile in a functional language?
14:51:07 <FunctorSalad> monochrom: I use italics for quoting terms already
14:51:16 <con> Dont know
14:51:17 <monochrom> Write a python emulator in haskell. feed it your python file. "haskell has a python-eval like php does"
14:51:34 <lament> fxr: there's 'do', why not 'doWhile'?
14:51:46 <FunctorSalad> ("I like /fold/" (the function) vs. "I like fold" (grammar error))
14:52:16 <Elly> the lisp people use UPPERCASE for literals because of case-insensitivity :P
14:52:18 <tectum> what if I do (a `par` ...) and then (a `par` ...) again? if the first one is running already, does the RTS know it should ignore the second one?
14:52:19 <fxr> lament: what is a do?
14:52:36 <fxr> @hoogle do
14:52:37 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
14:52:37 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
14:52:37 <lambdabot> Language.Haskell.TH DoE :: [Stmt] -> Exp
14:52:47 <FunctorSalad> boldface is better to highlight keywords if someone is scanning the doc
14:53:31 <sinelaw> frag is pretty impressive
14:53:37 <monochrom> a doWhile in a functional language is a contraption invented for the sole myopic purpose of converting low-level imperative languages to haskell.
14:53:46 <sproingie> impressively hard to read
14:54:13 <con> haskell doesnt really need a doWhile
14:54:16 <copumpkin> monochrom: damn right! and we like it!
14:54:28 <sinelaw> sproingie, the guy who wrote it did it as an undergraduate thesis, the scale of the project is huge for that
14:54:39 <sinelaw> benmachine, woohoo! compiled
14:55:11 <FunctorSalad> loop = (.... imperative stuff ...) >> when condition loop
14:55:16 <benmachine> sinelaw: nice one
14:55:27 <copumpkin> FunctorSalad: nuh uh
14:55:30 <benmachine> sinelaw: is this based on the darcs version?
14:55:34 <mmorrow> @type \p f -> until (not . p) f . f
14:55:34 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:55:38 <sproingie> sinelaw: yeah i don't begrudge it, it's amazing work, but it is fairly well packed with weird operators
14:55:38 <copumpkin> FunctorSalad: doesn't look imperative enough
14:55:48 <sinelaw> benmachine, oops, nope from hackage
14:55:48 <mmorrow> @let doWhile p f = until (not . p) f . f
14:55:50 <lambdabot>  Defined.
14:56:00 <benmachine> sinelaw: probably not that different
14:56:14 <copumpkin> mmorrow: where the a -> a will be (>>) ?
14:56:15 <sinelaw> how can i darcify it without losing my fixes?
14:56:19 <fxr> well I don't get the point about doWhile con. Doing what while the predicate holds?
14:56:22 <sproingie> sinelaw: at least weird for most game programmers anyway
14:56:35 <mmorrow> > doWhile (< 10) (+7) 100000
14:56:36 <lambdabot>   100007
14:56:45 <copumpkin> mmorrow: but it was meant to be imperative!!
14:57:08 <mmorrow> but the arguments are being mutilated!
14:57:39 <fxr> huh, it's just a fold
14:57:43 * Twey chuckles.
14:57:54 <sinelaw> it _sorta_ works
14:58:03 <sinelaw> maybe i introduced some bugs (probably)
14:58:41 <sinelaw> what do i do to make the current dir be a darc working copy without losing my work?
15:03:30 <mmorrow> , let doWhile p go a = mdo z <- ref a; o <- ref (do go z; x <- deref z; if (not . p) x then return x else join (deref o)); join (deref o) in runST (doWhile (< 10000) (\x -> (x .=) . (+7) =<< deref x) 7)
15:03:32 <lunabot>  10003
15:04:09 <mmorrow> mdo-and-join-readSTRef-thesame-STRef-you're-defining++
15:04:35 <sinelaw> dons, you here?
15:06:30 <mmorrow> , let doWhile p f a = do z <- ref a; let go = do {f z; x <- deref z; when ((not . p) x) go; return x} in go in runST (doWhile (< 100000) (\x -> (x .=) . (+7) =<< deref x) 7)
15:06:32 <lunabot>  luna: No instance for (GHC.Num.Num ())
15:06:57 <mmorrow> , let doWhile p f a = do z <- ref a; let go = do {f z; x <- deref z; if (not . p) x) then go else return x} in go in runST (doWhile (< 100000) (\x -> (x .=) . (+7) =<< deref x) 7)
15:06:58 <lunabot>  luna: parse error on input `)'
15:07:31 <mmorrow> , let doWhile p f a = do z <- ref a; let go = do {f z; x <- deref z; if p x then go else return x} in go in runST (doWhile (< 100000) (\x -> (x .=) . (+7) =<< deref x) 7)
15:07:35 <lunabot>  100002
15:07:59 <mmorrow> (ref=newSTRef; deref=readSTRef; (.=)=writeSTRef)
15:11:31 <mmorrow> x .= f = writeSTRef x . f =<< readSTRef x
15:11:37 <mmorrow> would be muc hhandier actually
15:12:10 <mmorrow> (\x -> (x .=) . (+7) =<< deref x)   ====>   (.= (+7))
15:13:38 <fxr> @let doWhile2 = ((last .) .) . flip ((.) . takeWhile) . iterate
15:13:39 <lambdabot>  Defined.
15:13:51 <fxr> > doWhile2 (+1) (<10) 1
15:13:52 <lambdabot>   9
15:14:32 <mmorrow> > doWhile2 (+1) (<10) 1000000000
15:14:33 <lambdabot>   * Exception: Prelude.last: empty list
15:14:49 <fxr> doWhile f p s = last $ takeWhile p (iterate f s) is much readable
15:15:37 <mmorrow> doWhile f p = last . takeWhile p . iterate f . f
15:15:52 <mmorrow> to catch the case when the while condition never is true
15:16:15 <mmorrow> well, actually that doesn't work either
15:16:48 <mmorrow> the takeWhile won't let it through
15:19:19 <fxr> okay
15:20:24 <mmorrow> `until' is the only unforced way i can think of
15:20:34 <mmorrow> (wrt pre-packaged prelude functions)
15:21:06 <con> ok, I've just been asked to right an application that finds the power using 2^(2+m) and 2^(2+m)+1 and recursion
15:21:17 <con> can anybody halp me
15:21:20 <mmorrow> what was wrong with it?
15:21:36 <opqdonut> hee hee :)
15:21:39 <con> i cant figure out how to do it recursivly
15:21:53 <con> :(
15:22:17 <con> 2^(2+m) gives me the power
15:22:19 <mwc> con: I assume you meant 2^(2*m + 1) and 2^(2*m)?
15:22:36 <con> yes
15:23:36 <mwc> alright, so consider computing 2^N. There are two cases. If N is even, N = 2*m, and so 2^N = (2^m) * (2^m), so you use recursion to compute 2^m
15:24:01 <mwc> the other case is if N is odd, in which case 2^N = (2^m) * (2^m) * 2
15:25:56 <con> still confused :) lol
15:26:14 <jfoutz> how would you do it without recursion?
15:26:30 <con> 2^n
15:26:42 <jfoutz> what is ^?
15:26:58 <opqdonut> exponentiation.
15:26:58 <jkramer> :t ^
15:26:59 <lambdabot> parse error on input `^'
15:27:01 <con> no idea, the power sign
15:27:08 <opqdonut> :t (^)
15:27:08 <jkramer> :t (^)
15:27:09 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:27:09 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:27:25 <jfoutz> if you didn't have (^) how would you get it?
15:27:50 <con> multiply the number by itself till i get the answer
15:28:13 <jfoutz> ok... so what's your non-recursive function look like?
15:28:50 <fxr> foldr (*) 1 $ replicate 4 10
15:28:50 <jkramer> @src (^)
15:28:51 <lambdabot> x ^ 0            =  1
15:28:51 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:28:51 <lambdabot>   where f _ 0 y = y
15:28:51 <lambdabot>         f x n y = g x n
15:28:51 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:28:53 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:28:55 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:29:00 <jkramer> Woah
15:29:19 * mmorrow looks what that compiles to
15:29:38 <opqdonut> yeah, that's pretty non-naive :)
15:29:40 <fxr> @def expn x n = foldr (*) 1 $ replicate n x
15:29:40 <lambdabot> Maybe you meant: bf do let
15:29:41 <con> i really dont know
15:29:45 <fxr> @let expn x n = foldr (*) 1 $ replicate n x
15:29:46 <lambdabot>  Defined.
15:29:50 <fxr> uhm
15:29:56 <jfoutz> int ans = 0; int mul = 2; for(int pow = 5; pow >0; pow--) ans *= mul; ? something like that?
15:29:56 <fxr> > expn 2 8
15:29:57 <lambdabot>   256
15:30:03 <opqdonut> con: well maybe you should practice some more functional programming then?
15:30:18 <con> i really should
15:31:04 <jfoutz> i mean, you could just, foldr (*) 2 [1..2*m], but that won't solve your problem.
15:31:42 <jfoutz> how would you go about adding a number to itself n times?
15:31:48 <con> i can do it recursive
15:31:58 <jfoutz> the add?
15:32:50 <jkramer> jfoutz: x + x * n :)
15:32:56 <con> like power x y = y + power (x-1) y
15:33:05 <jfoutz> sweet!
15:33:12 <con> and have a base case to stop it at zero
15:33:46 <con> but the odd to even one confuses me
15:33:57 <con> I can do it without recursion
15:34:22 <con> by using those two functions and making it odd and even
15:34:36 <con> and checking incoming variables
15:34:50 <con> but i've been told it has to be recursive
15:35:05 <con> shoud've payed more attension in class
15:35:11 <jfoutz> hehehe.
15:35:25 <jfoutz> look at your definition.
15:35:44 <jfoutz> power x, power (x-1) looks suspiciously like even(x) odd(x)
15:35:51 <con> it has to use the odd and even functions :(
15:36:01 <con> ohhhh
15:36:05 <jfoutz> not sure *exactly* what you're looking for... but i think you've got the parts.
15:36:05 <con> lol
15:36:32 <con> thannks for your help jfoutz
15:36:52 <jfoutz> sure.
15:38:13 <fxr> haskell in the clazz, I want to go to school again...
15:39:14 <Berengal_> I was just wondering, when you're importing a foreign function, can you give it any type, or just pure types and IO?
15:39:15 <fxr> we have written fortran on the fortran papers even we were earth science students :(
15:41:51 <jfoutz> fortran is teh leet soupercomputer language.
15:42:08 <dons> sinelaw: pong
15:42:33 <monochrom> You can give a foreign function any type. There is a keyword for that.
15:42:43 <monochrom> Err nevermind.
15:42:47 <sinelaw> dons, i made frag compile, but did it on an unpacked cabal package from hackage
15:43:00 <dons> ok. and sent me some patches?
15:43:03 <dons> i can apply them.
15:43:09 <sinelaw> i don't know how to create the patches
15:43:33 <dons> diff -u file.old file.new > /tmp/file.diff
15:43:34 <dons> works.
15:43:37 <dons> or you can use the darcs repo.
15:43:38 <sinelaw> btw, i might have introduced bugs (it doesn't seem to work right)
15:43:43 <dons> heh
15:43:54 <sinelaw> it works but doesn't show the weapon on the screen
15:43:57 <dons> ok. i have some patches in my inbox.
15:43:58 <monochrom> "pure types and IO" ought to be enough. it is not like you want a foreign function to become a -> ContT r IO a or something.
15:44:14 <sinelaw> dons, for frag?
15:44:48 <Berengal_> monochrom, no, but I might want to put it in a different monad... was just brainstorming anyway
15:45:19 <Berengal_> Not even sure it'd be possible due to other considerations
15:45:46 <dons> sinelaw: yeah
15:45:50 <sinelaw> ok
15:46:11 <dons> "I've created a patch that makes frag compile."
15:46:16 <dons> Wed, 28 Oct 2009
15:46:21 <sinelaw> dons, if none of them work out, you can try the one i did, i've sent it to haskell-cafe
15:46:24 <sinelaw> heh :)
15:46:34 <monochrom> hahaha
15:47:06 <sinelaw> that's not me
15:50:45 <noZone> How does one gracefully detect, on the writing end, that a fd has been closed (i.e the reader has closed the pipe)?
15:52:02 <sproingie> i don't think there's any way to notify the writer
15:52:05 <sproingie> blame unix
15:52:28 * noZone fumes
15:52:49 <sproingie> reader gets an EOF condition, writers usually have to live with SIGPIPE
15:53:18 <noZone> ... which is what I was hoping to avoid.
15:56:02 <benmachine> if you block SIGPIPE then the write fails with EPIPE instead
15:56:09 <benmachine> (don't know how that translates to haskell though)
15:57:04 <sproingie> ceci n'est pas EPIPE
15:57:19 <mauke> installHandler openEndedPipe Ignore Nothing
15:58:44 <noZone> thanks Magritte.
16:04:38 <jimmyjazz14> Is there way to make records auto generated function work as instance of a type class
16:04:39 <jimmyjazz14> ?
16:05:10 <jimmyjazz14> like for example:  name $  Person "Pete"
16:05:19 <jimmyjazz14> name $ Animal "Simon"
16:05:43 <bockmabe> anyone here familiar with edsl techniques?  I'm interested in doing something similar to what's been done in barrel fish but for generating network stack/protocol code
16:05:50 <jimmyjazz14> obviously this works if I was to make a typeclass like Named with a function name
16:06:01 <jimmyjazz14> but then I have to make instances for all my types
16:06:06 <Twey> jimmyjazz14: Nay :-\
16:06:25 <BONUS> the good old selectors-as-normal-functions thing
16:06:25 <mauke> data Lol = Person { name :: String } | Animal { name :: String }
16:06:31 <bockmabe> I'm looking for some example code to help me try to wrap my head around it.
16:06:34 <benmachine> jimmyjazz14: if you have a single data type with multiple constructors, they can share fields
16:06:44 <benmachine> so long as the resulting type for the field makes sense
16:06:45 <Twey> You can add your own default instances with Data.Deriving
16:06:57 <Twey> Don't know if that's useful for you
16:07:22 <ecst> is there an index polymorphic version of Data.Map (with index/size type more general than Int) in the standard library?
16:07:32 <ecst> would suffice if there were a version with Integer as index type
16:07:36 <mauke> huh?
16:07:49 <Berengal_> Map is polymorphic
16:07:54 <Berengal_> With an Ord constraint.
16:08:00 <Berengal_> Integer certainly is in Ord
16:08:01 <ecst> Data.Map.size gives you an int, but i rather want an Integer
16:08:10 <Berengal_> fromIntegral
16:08:14 <roconnor> :O
16:08:19 <ecst> yeah, but that does not fix the problem
16:08:25 <ecst> the map would overflow at 2^something
16:08:26 <roconnor> > maxboud :: Int
16:08:27 <lambdabot>   Not in scope: `maxboud'
16:08:31 <roconnor> > maxBound :: Int
16:08:32 <lambdabot>   9223372036854775807
16:08:39 <mauke> ecst: how much memory do you have?
16:08:43 <roconnor> :D
16:08:46 <jimmyjazz14> mauke, so simple why did I not think of that
16:08:55 <Berengal_> ecst, your memory would run out long before that
16:08:56 <ecst> i just want to prove my program works correct, on arbitrary memory ;)
16:09:09 <ecst> and that is much easier with Integer than Int
16:09:27 <mauke> I bet Integer doesn't work with arbitrary memory either
16:09:35 <ecst> uh, i certainly hope it does
16:09:41 <mauke> extremely unlikely
16:09:48 <ecst> arbitrary precision it says
16:09:48 <roconnor> mauke: what makes you think that?
16:09:53 <roconnor> oh
16:09:58 <benmachine> if you had arbitrary memory you'd probably have 64-bit Ints?
16:09:58 <roconnor> ya
16:09:59 <Berengal_> Nope, it uses a byte array internally, which can't allocate more than 2^something bytes ;)
16:10:10 <roconnor> gmp probably craps out at 2^(2^64) or so
16:10:22 <benmachine> that is to be fair
16:10:24 <benmachine> quite a large number
16:10:44 <ecst> well, at least it would be possible to implement Integer in a completely arbitrary-precision way
16:10:52 <benmachine> I think we can all agree that 2^(2^64) is pretty arbitrary, right?
16:10:52 <jkramer> @src group
16:10:52 <lambdabot> group = groupBy (==)
16:11:01 <jkramer> @src groupBy
16:11:01 <roconnor> ecst: perhaps you should cut and paste the Map library?
16:11:02 <lambdabot> groupBy _  []       =  []
16:11:02 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
16:11:02 <lambdabot>     where (ys,zs) = span (eq x) xs
16:11:09 <ecst> benmachine: no, i am a mathematician ;)
16:11:10 <roconnor> ecst: or patch it
16:11:15 <Berengal_> benmachine, not really, unless you consider 64 to be arbitrary
16:11:32 <benmachine> what number could possibly be more arbitrary?
16:11:34 <copumpkin> roconnor: more like 2^(2^30-something) right now, and a goal of 2^(2^50) for the next major version of gmp
16:11:47 <ecst> the thing is, i am writing a proof checker and i pretty much want to prove it correct with respect to some informal haskell semantics
16:11:47 <roconnor> copumpkin: ooh, so small
16:11:53 <copumpkin> yeah, lame
16:11:56 <ecst> roconnor: i will probably do that
16:12:10 <copumpkin> it's small enough that we should make Integer an instnace of Bounded ;)
16:12:17 <roconnor> :D
16:12:20 <Berengal_> benmachine, 64 makes sense, because it's a power of two. Powers of two make sense because computers use binary. Binary makes sense because it's easier and more efficient than other ways
16:12:24 <Berengal_> So not arbitrary ;)
16:12:32 <copumpkin> just don't ask for maxbound if you value your memory + swap sapce
16:12:50 <copumpkin> ooh, I know
16:12:53 <noZone> My cat is arbitrary in its habits.
16:12:57 <copumpkin> gmp should use its own integers to represent the size of its integer
16:13:01 <copumpkin> !!!
16:13:05 <copumpkin> that way it would be unbounded!!
16:13:07 <copumpkin> zomg
16:13:11 <roconnor> perfect!
16:13:15 <ecst> indeed ;)
16:13:25 <Berengal_> copumpkin, "gmp feature request: fix size"?
16:13:43 <copumpkin> yep!
16:14:10 <Berengal_> Might be possible if it was lazy
16:14:33 <roconnor> copumpkin: that issue in complexity has always kinda bothered me
16:14:38 <Berengal_> Except I think it might boil down to peano in the end
16:15:36 <dobblego> @pl \x -> if x then id else negate
16:15:36 <lambdabot> flip (flip if' id) negate
16:15:44 <fxr> Berengal_: binary is efficient?
16:16:07 <jfoutz> @src if'
16:16:07 <lambdabot> Source not found. :(
16:16:22 <benmachine> if' True x _ = x; if' False _ x = x
16:16:22 <dobblego> if' p t f = if p then t else f
16:16:45 <jfoutz> oh.
16:16:58 <Berengal_> fxr, well, ten-band transistors are too error-prone, two-band transistors aren't, one-band transistors are useless, so yes, binary is efficient in that any other useful base couldn't be implemented directly in the transistors
16:17:03 <benmachine> what does #haskell think of dropping if-syntax in favour of if-function?
16:17:13 <Berengal_> benmachine, yes
16:17:15 <benmachine> (or if not, what should if-function be called and where should it go)
16:17:31 <benmachine> also, is it a thing likely to happen, even if not soon
16:17:33 <Twey> benmachine: (y ?? n) p = if p then y else n
16:17:37 <Twey> Otherwise, yes
16:17:41 <ecst> ah, at least the current version of Data.Map has a line "type Size = Int", very much modular :)
16:17:50 <Berengal_> benmachine, if I declare it, I usually call it if' :: Bool -> a -> a -> a, and fi :: a -> a -> Bool -> a
16:17:55 <roconnor> copumpkin: in chaitin complexity programs have to be self delimiting, which requires encoding their length, which requires encoding the length of the length, which requires encoding the length of the length of the length ...
16:18:11 <sinelaw> 'xcuse my noobishness, but how do I run putStr on a [String]?
16:18:12 <benmachine> I think I called it iff
16:18:16 <benmachine> once
16:18:18 <sinelaw> tried fmap, got errors
16:18:19 <dobblego> sinelaw, mapM_
16:18:27 <sinelaw> ah
16:18:29 <fxr> what an electrical world
16:18:31 <dobblego> @type mapM_ putStr
16:18:32 <lambdabot> [String] -> IO ()
16:18:34 <mauke> putStr (concat strings)
16:18:40 <Tordek> is there some standard fucntion (hoogle ain't helping) like Int -> [a] -> [[a]]; to split a list in sublists of length n?
16:18:42 <benmachine> putStr (unlines strings)
16:18:43 <Twey> Better, putStr . unlines
16:18:46 <Twey> *nod*
16:18:56 <benmachine> depends what you want
16:18:57 <dobblego> Tordek, Data.List.Split
16:19:10 <sinelaw> mapM_ makes more sense in my case, thanks
16:19:16 <benmachine> what package is that in?
16:19:24 <sinelaw> or not.
16:19:35 <benmachine> sinelaw: suuuure? more pure = more better
16:19:48 <sinelaw> benmachine, yip :)
16:20:07 <Twey> And it's faster, IIRC.
16:20:20 * Beelsebob goes with twey‚Äôs version
16:20:28 <BONUS> let chunk n = unfoldr (\x -> guard (not $ null x) >> Just (take n x, drop n x)) in chunk 3 [1,2,3,4,5,6,7,8]
16:20:30 <BONUS> > let chunk n = unfoldr (\x -> guard (not $ null x) >> Just (take n x, drop n x)) in chunk 3 [1,2,3,4,5,6,7,8]
16:20:31 <lambdabot>   [[1,2,3],[4,5,6],[7,8]]
16:20:36 <BONUS> this is what i usually use
16:20:46 <Twey> There's no real reason to use multiple putStr's, since they don't do anything special on each call.
16:20:47 <sinelaw> Twey, yeah, i'll do that
16:20:59 <sinelaw> putStr . unlines
16:21:02 <Twey> *nod*
16:21:09 <benmachine> > unlines ["f"]
16:21:10 <lambdabot>   "f\n"
16:21:14 * benmachine checking
16:21:23 <benmachine> > unlines []
16:21:24 <lambdabot>   ""
16:22:29 <Beelsebob> benmachine: the advantage of that behavior is that it can be lazy ‚Äì if you define it to not include a \n on the final line, then you end up waiting to find out if it‚Äôs the final line or not before appending a \n to something
16:22:34 <jokerGTA> guys can I use parsec with ghci
16:22:43 <Beelsebob> jokerGTA: you can
16:23:03 <Twey> If you had something that did things differently each time, you should use mapM, which is like map except that it executes all the monads in the list after mapping the action over them (mapM = sequence . map), or mapM_, which is like that but returns () instead of a list of results (mapM_ = sequence_ . map; sequence_ = (>> return ()) . sequence)
16:23:04 <jokerGTA> documentation is saying i can use -package text switch
16:23:18 <benmachine> Beelsebob: mm, don't doubt it
16:23:20 <jokerGTA> i dont really know how to use it
16:23:28 <dobblego> @hoogle Int -> Double
16:23:28 <lambdabot> Prelude toEnum :: Enum a => Int -> a
16:23:28 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
16:23:28 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
16:23:40 <Twey> Beelsebob: Plus it's more useful, generally.
16:24:19 <Beelsebob> Twey: yes and no, ++ ‚Äú\n‚Äù is rather more efficient than \n -> take (length n - 1) n
16:24:50 <Twey> Beelsebob: I said useful, not efficient ‚Äî most of the time you want to end with a newline
16:24:56 <mauke> > ‚Äú\n‚Äù
16:24:57 <lambdabot>   <no location info>: lexical error at character '\8220'
16:25:17 <Beelsebob> Twey: yes, my point was that the other behavior is useful in both situations, while this behavior isn‚Äôt
16:25:23 <Twey> Beelsebob: I'd think you could make an O(n) take, though
16:25:30 <Twey> For this case, I mean
16:25:38 <Beelsebob> I‚Äôm sure you can
16:25:45 <Beelsebob> just requires a little more effort
16:25:48 <Twey> Yeah
16:28:39 <sinelaw> is ByteString.interact strict?
16:28:45 <sinelaw> hey Peaker
16:28:51 <Beelsebob> well, ByteStrings are
16:28:53 <Beelsebob> so yes
16:29:02 <Beelsebob> which doesn‚Äôt make much sense
16:29:07 <Peaker> sinelaw, hey
16:29:09 <Beelsebob> so I‚Äôm guessing that‚Äôs Lazy.ByteString.interact?
16:29:20 <Peaker> Beelsebob, you mean strict bytestrings?
16:29:34 <Peaker> There's the lazy bytestrings (which seem like they're lazy lists of strict bytestrings)
16:29:43 <sinelaw> Peaker, writing my first haskell program
16:29:47 <Beelsebob> yes, that was my point Peaker
16:30:02 <sinelaw> (if you exclude the ghc patch :)
16:30:15 <Beelsebob> now that‚Äôs hardcore
16:30:23 <Beelsebob> patching ghc before you even write a haskell program
16:31:16 <sinelaw> Beelsebob, :) it was a one-liner, adding a warning about non-uniform definitions (later i found out that the haskell committee deliberately didn't do that)
16:32:07 <sjanssen> sinelaw: non-uniform definitions?
16:33:01 <sinelaw> a uniform definition (as defined by Wadler in SPJ's book), is essentially one where the order of the patterns doesn't matter
16:33:24 <sinelaw> i mean it's guaranteed to not matter
16:33:54 <sinelaw> it allows for easier optimizations, but i think ghc copes with it anyway
16:34:58 <benmachine> I submitted a bug to ghc once
16:35:09 <benmachine> it was really trivial
16:35:26 <sinelaw> btw, it's not a bug, i just tried it out on my machine as an experiment. not very useful on its own
16:36:18 <sjanssen> yeah, GHC should handle those well anyway, its core language only offers patterns where order doesn't matter
16:37:28 <sinelaw> sjanssen, the thing is that you get highly nested cases in the core language if you don't use uniform patterns
16:37:50 <sinelaw> IIRC, but i'm guessing they can cope with that too
16:40:13 <dobblego> > let p = "¬∞" in p
16:40:14 <lambdabot>   "\176"
16:42:02 <ivanm> is that spam I see on the haskell reddit? :o
16:46:17 <noZone> @ivanm, I don't see anything unusual....
16:46:17 <lambdabot> Unknown command, try @list
16:46:42 <ivanm> noZone: "Programs and programming: Asus WL500g Premium controller now on Windows"
16:46:52 <ivanm> doesn't looke like it has naything to do with Haskell to me...
16:47:09 <noZone> hmm... the links inside do something haskell related.
16:47:31 <noZone> http://hackage.haskell.org/package/WL500gPControl
16:47:40 <ivanm> ahhh... so it isn't spam
16:47:48 <ivanm> the reddit title could be better labelled then ;-)
16:47:56 <noZone> Does look fishy on the surface....
16:49:46 <noZone> .... = do {putStr "Tralalala"; skip ToSunset}
16:50:14 <sinelaw> how do i do this: top-level function does [a]->[a], and I really want to split the [a]'s, process each piece, and then output the concatenation - will that get stuck untill the whole list is processed because of concat ?
16:50:53 <mauke> > repeat [1,2,3]
16:50:54 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
16:50:58 <mauke> > concat (repeat [1,2,3])
16:50:59 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
16:51:01 <ivanm> noZone: methinks you need more "la"s in there ;-)
16:51:14 <ivanm> > cycle [1,2,3]
16:51:15 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
16:51:58 <Peaker> sinelaw, what are you writing?
16:52:13 <sinelaw> @src concat
16:52:13 <lambdabot> concat = foldr (++) []
16:52:42 <sinelaw> Peaker, a simple pronunciation program
16:53:12 <sinelaw> first step is to convert the database i have into haskell so i can compile it into the program (to reduce loading time?)
16:53:23 <sinelaw> not sure that's actually a good idea
16:53:34 <BMeph> NEEDZ MOAR COMONADZ! ...kthxbai! ;)
16:54:10 <Peaker> sinelaw, it doesn't matter, you could mmap it and that should have equivalent performance (assuming you don't need to translate the mmap'd data too much)
16:54:36 <sinelaw> Peaker, well i would need to search, and parse a little
16:55:12 <sinelaw> it has 133K entries
16:55:21 <noZone> .... = do {putStr (concat $ "Tra" : replicate 1000 "la") CHP.<||> skip ToSunset}
16:55:49 <ivanm> noZone: what is "CHP." doing there?
16:56:09 <ivanm> BMeph: then write some!
16:56:10 <ivanm> duh
16:56:11 <ahunter> @djinn Maybe a -> Maybe b -> Maybe (a,b)
16:56:11 <lambdabot> f a b =
16:56:11 <lambdabot>     case a of
16:56:11 <lambdabot>     Nothing -> Nothing
16:56:11 <lambdabot>     Just c -> case b of
16:56:11 <lambdabot>               Nothing -> Nothing
16:56:12 <ivanm> ;-)
16:56:13 <lambdabot>               Just d -> Just (c, d)
16:56:48 <sinelaw> @src Data.ByteString.Lazy.concat
16:56:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:56:50 <dobblego> @type liftA2 (,)
16:56:51 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
16:56:52 <sinelaw> @src Data.ByteString.concat
16:56:53 <lambdabot> Source not found. :(
16:56:53 <ivanm> @undo \ ma mb -> do { a <- ma; b <- mb; return (a,b)
16:56:54 <lambdabot>  Parse error at end of input
16:56:55 <ivanm> @undo \ ma mb -> do { a <- ma; b <- mb; return (a,b) }
16:56:55 <Axman6> lrn2liftM2(,) lambdabot!
16:56:55 <lambdabot> \ ma mb -> ma >>= \ a -> mb >>= \ b -> return (a, b)
16:57:01 <sinelaw> @src ByteString.concat
16:57:01 <lambdabot> Source not found.
16:57:02 <ivanm> heh
16:57:03 <sinelaw> arrgggggggg
16:57:08 <ivanm> @. pl undo \ ma mb -> do { a <- ma; b <- mb; return (a,b) }
16:57:08 <lambdabot> liftM2 (,)
16:57:11 <ivanm> yup
16:57:15 <ivanm> heya Axman6
16:57:18 <Peaker> sinelaw, then you can probably translate the file ahead of time without making it a value in your program? Though making it a value is fine too
16:57:34 <sinelaw> Peaker, translate it into what then?
16:57:43 <Peaker> sinelaw, @src uses some Haskell98 report or some other arbitrary sources like that..
16:57:50 <Peaker> sinelaw, whatever it is you need in your program
16:57:59 <Axman6> \o
16:58:11 <noZone> ivanm: CHP is "communicating haskell processes"  <||> is get parallel with it.
16:58:16 <Peaker> sinelaw, I find it pretty yucky that ByteStrings duplicate the list interface, rather than using a type-class.. I also am not sure why they are not parameterized on the Word8...
16:58:30 <Peaker> Is there a good reason that bytestrings aren't parameterized on Word8 other than historic limitations of ghc?
16:58:41 <Peaker> (as in parameteric to non-Word8 too)
16:58:55 <ivanm> noZone: ahhh
16:59:00 <sinelaw> will ByteString's concat work on infinite lists of bytestrings?
16:59:28 <__JN> hello, I'm trying to save a list of pixbuffers to files. The filenames are also in a list. I've tried " forM_ (zipWith pixbufSave buffers filenames)  (format []) " but thats obviously not right... any suggestions?
17:00:43 <luite> do I need to install extra libraries to profile code that uses FFI with ghc 6.12.1cr1 ? when I try to compile with profiling, it says:  cannot find -lHSffi_p
17:01:01 <Peaker> sinelaw, You can try it out, I'd guess it should work in the lazy case
17:01:20 <ivanm> luite: enable profiling for all your other libraries?
17:02:03 <sinelaw> it's fun, haskell. takes me a while to write one line, but once i do i'm pretty sure it's the best line i could write there :)
17:02:10 <luite> ivanm: I've already reinstalled all hackage package I use. (if the profiling libraries for one of those are missing, the build fails earlier)
17:02:24 <ivanm> luite: maybe GHC profiling support? :s
17:02:44 <luite> is that something separate?
17:03:00 <ivanm> you have to build it with profiling support I think...
17:03:04 <luite> the ghc 6.12 lib dir does contain _p packages for rts
17:03:09 * ivanm has never used FFI, so not quite sure...
17:03:10 <luite> oh I use the binaries, for windows
17:03:18 <Axman6> sinelaw: don't say that until you've been writing haskell for a few years ;) there's always people here who'll be able to write the whole thing in half the space
17:03:34 <Peaker> sinelaw, I tested, yeah, it works
17:03:42 <sinelaw> Axman6, i said it's the best that _I_ could write :)
17:03:46 <Saizan> luite: try asking in #ghc , it might be a bug
17:03:48 <Axman6> heh
17:04:01 <sinelaw> Peaker, cool
17:04:33 <Peaker> sinelaw, importing pack, concat, take from the lazy bs module: print . take 9 . concat . repeat . pack . map (fromIntegral . fromEnum) $ "hi"   results in:  Chunk "hi" (Chunk "hi" (Chunk "hi" (Chunk "hi" (Chunk "h" Empty))))
17:05:03 <Peaker> I didn't want to import ByteString.Char8 because I don't know if its lazy or not. I think Char8 being a module is pretty dumb, it should be an extra pack method, that's all
17:05:27 <mauke> Peaker: huh?
17:05:29 <Peaker> so   pack . map (fromIntegral . fromEnum)  does the trick, to pack from String
17:05:56 <Peaker> mauke, There's the Data.ByteString.Char8 module, which only provides a different pack and perhaps a few other functions
17:06:06 <mauke> "perhaps a few"?
17:06:07 <Peaker> mauke, but is made to appear as if it was its own bytestring module. I think that's silly
17:06:13 <mauke> it provides a lot of functions
17:06:36 <Peaker> mauke, over what the normal BS module does?
17:07:03 <Peaker> What does the Char8 module provide that Data.ByteString doesn't?  The fact the answer to this question isn't trivial I think is another reason that the way it is organized is bad
17:07:27 <Peaker> sinelaw, you really ought to fix your connection :) Temporarily, maybe you can run an irc client in a screen session somewhere?
17:07:42 <sinelaw> :( :(
17:07:45 <drhodes> Ray_: did you find the 2 line function?
17:08:38 <sinelaw> Peaker, i want to parse the DB, build a dictionary, save it, and then let my program load that.
17:09:10 <sinelaw> do i have any choice but to marshall my stuff?
17:09:17 <mauke> singleton, pack, unpack, cons, snoc, head, uncons, last, map, intersperse, foldl, foldl', foldl1, foldl1', foldr, foldr', foldr1, foldr1', concatMap, any, all, maximum, minimum, scanl, scanl1, scanr, scanr1, mapAccumL, mapAccumR, replicate, unfoldr, unfoldrN, takeWhile, dropWhile, span, spanEnd, break, breakEnd, groupBy, split, splitWith, elem, notElem, find, filter, index, elemIndex, elemIndices, elemIndexEnd, findIndex, findIndices, count,
17:09:23 <mauke>  zip, zipWith, unzip
17:09:28 <Peaker> sinelaw, I hate programs that "load" (copy) the disk data.  I prefer mmap which lazily loads it on demand, though compiling it into your program will also get to be mmaped, de-facto
17:09:29 <mauke> that list was pretty trivial to find
17:09:39 <Peaker> mauke, all these are the same as in the Data.ByteString module
17:09:43 <mauke> Peaker: no
17:10:12 <sinelaw> Peaker, so i need to convert the DB in haskell code and compile it
17:11:01 <Peaker> mauke, Ah, I see, all the operations for which the "a" of the hypothetic parametric ByteString is a Char.  I see, it would still be nicer, then, if Char8 only had functions like that, rather than duplicating the rest.. Is it duplicated for the lazy/strict modules btw?
17:11:10 <Peaker> sinelaw, "need" is strong, its an option :)
17:11:19 <mauke> Peaker: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring
17:11:36 <Peaker> sinelaw, you can also "load" (it sounds small enough that the copy is not a huge penalty), or mmap something and use that in-memory
17:11:37 <sinelaw> Peaker, yea, i meant if i want to have it in the executable - how else can i do it?
17:12:00 <sinelaw> brb
17:12:31 <Peaker> mauke, I see, it makes more sense now, still dislike the duplication of exports which are the same, though
17:30:04 <potax_alum> hi
17:30:45 <potax_alum> Hi Need some help with hieroglyph on windows
17:30:55 <potax_alum> ?
17:31:59 <potax_alum> I am trying to install hieroglyph using cabal
17:32:30 <potax_alum> I am not able to get it to find gtk, glib etc even though they are already installed on the system
17:32:35 <Axman6> well you'll need to ask your question before someone helps you...
17:32:43 <Axman6> that's better
17:32:50 <potax_alum> how should I specify where cabal should look for these things
17:33:27 <Axman6> --extra-include-dirs=/blah/foo/include --extra-lib-dirs=/blah/foo/lib
17:34:04 <potax_alum> thanks
17:34:23 <potax_alum> These go in the .config file?
17:34:25 <dcoutts> potax_alum: you need gtk2hs installed
17:34:35 <dcoutts> it's nothing to do with headers
17:34:45 <Axman6> oh
17:34:53 <dcoutts> potax_alum: gtk2hs provides the Haskell packages gtk, glib, cairo etc
17:34:58 * Axman6 hands over to dcoutts who actually knows what hes on about :)
17:35:50 <dcoutts> potax_alum: you say you've got gtk etc installed. I presume you mean the C libs but not the Haskell binding (gtk2hs).
17:35:56 <potax_alum> thanks Axman
17:36:01 <potax_alum> Yes.
17:36:19 <potax_alum> I believe so. I was under the impression that the haskell platform came with gtk2hs
17:36:25 <dcoutts> not yet
17:36:38 <potax_alum> dcoutts:  Thanks
17:36:45 <dcoutts> potax_alum: but there is a separate installer for windows
17:36:50 <dcoutts> for gtk2hs I mean
17:37:09 <potax_alum> dcoutts: I will try that out now.
17:37:21 <potax_alum> dcoutts: Thanks
17:38:52 <dcoutts> potax_alum: btw, if you're using ghc-6.10.4 then you'll need a matching gtk2hs build. The one on the gtk2hs site is still for 6.10.3. I've got a minimal build for 6.10.4 here:
17:39:10 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.10.1-win32-installer.exe
17:45:16 <sinelaw_> how to tell parsec to expect a specific sequence of chars? without writing char many times
17:46:23 <Draconx> sinelaw_, string.
17:46:40 <sinelaw_> ah, :)
17:47:15 <Draconx> note that string = mapM char
17:47:25 <Peaker> sinelaw_, http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Char.html
17:47:41 <dancor> hm why isn't there Data.ByteString.Lazy.breakSubstring
17:47:45 <sinelaw_> Peaker, i'm staring at that page
17:55:32 <sinelaw_> how to remove an old cabal package ?
17:55:45 <sinelaw_> and install the new version that's available?
17:55:56 <pragma_> NO!
17:55:58 <c_wraith> cabal doesn't really have any remove
17:56:11 <sinelaw_> cabal upgrade <package> doesn't do it
17:56:31 <luite> cabal install package-version perhaps?
17:56:36 <sinelaw_> ah lemme try
17:56:48 <sinelaw_> ok! thanks
18:00:43 <jordandanford> Hi, I'm a bit new to Haskell and I'm trying to make a simple algorithm which, given a positive integer and a list of prime numbers, lists all the prime factors of the integer
18:00:56 <Cale> jordandanford: Okay
18:00:59 <benmachine> ooh I've done that
18:01:21 <benmachine> I did it on my calculator in some perverse basic-alike
18:01:26 <benmachine> but then I did it properly in haskell
18:01:32 <jordandanford> I know it's probably a simple thing to fix, but when I test it out it says that there are non-exhaustive search patterns in the function
18:01:45 <jordandanford> take a look at the function ‚Äì http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4487
18:02:06 <benmachine> jordandanford: factors 2 []
18:02:09 <benmachine> is not covered
18:02:38 <Cale> You should never run out of primes in actual usage
18:02:40 <copumpkin>  pSwitch :: Functor col => (forall sf . (a -> col sf -> col (b, sf))) -> col (SF b c)-> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
18:02:57 <benmachine> if you compile with ghc -W then it should tell you what patterns are not matched
18:03:00 <benmachine> which is handy
18:03:12 <jordandanford> if I'm thinking correctly, factors 2 [2,3,5...] would return: factors 1 [2,3,5...] which is covered
18:03:15 <jordandanford> oops
18:03:26 <Cale> How are you testing the function?
18:03:41 <jordandanford> I mean, it would return 2 : factors 1 [2,3,5...], which in turn returns []
18:03:56 <Cale> Of course, if you run out of primes to test, the only thing you can do is to return the list consisting of whatever number is left.
18:03:58 <jordandanford> so shouldn't it end up as just [2]
18:04:13 <jordandanford> ?
18:04:24 <Cale> jordandanford: What did you originally call to trigger the problem?
18:04:46 <Cale> jordandanford: factors 2 [] is not covered by any of the cases that you wrote there
18:05:11 <jordandanford> oh sorry, I read that sentence wrong
18:05:16 <Cale> However, once you add an appropriate way to handle  factors i [], you will be able to remove your special case for  factors i [x]
18:05:25 <jordandanford> hmmm...
18:05:28 <jordandanford> hold on a second then
18:06:53 <sinelaw_> @hoogle Char -> Int
18:06:53 <lambdabot> Data.Char digitToInt :: Char -> Int
18:06:54 <lambdabot> Data.Char ord :: Char -> Int
18:06:54 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
18:07:47 <Cale> There's another couple ways things can go wrong here. One is what happens with negative values of i
18:07:58 <Cale> (in particular -1)
18:08:04 <jordandanford> well, yeah, but I'm not worrying about that right now
18:08:08 <Cale> another is what happens when i = 0
18:08:17 <Cale> But yeah
18:08:26 <Cale> You're assuming i is positive, that's fine
18:09:35 <jimmyjazz14> I am searching for a way to scrap my boilerplate on some typeclass that takes an association list and converts it into a type (one that uses the record syntax), anyone have any thoughts on how this might be done
18:09:44 <jordandanford> well thank you, Cale, I'm sure I
18:09:52 <jordandanford> I'm sure I'll figure it out
18:10:07 <papermachine> Bleh. I should do the complex homework ahead of time
18:10:13 <papermachine> wow wrong window
18:10:19 <Cale> papermachine: Complex analysis?
18:10:47 <sinelaw_> @hoogle Int -> Char
18:10:48 <lambdabot> Data.Char chr :: Int -> Char
18:10:48 <lambdabot> Data.Char intToDigit :: Int -> Char
18:10:48 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
18:10:56 <benmachine> jordandanford: p.s. if you know a number has no factors less than its square root, you know it is prime
18:11:03 <benmachine> uh
18:11:04 <papermachine> Cale: yeah, meant to post to #not-math
18:11:07 <benmachine> less than or equal to
18:11:12 <sinelaw_> papermachine, nice stuff
18:11:15 * Cale got sick of #not-math
18:11:42 <sinelaw_> but not so easy :(
18:11:53 <Cale> papermachine: Any interesting questions? :)
18:11:58 <benmachine> my homework is not complex it is just complicated
18:12:06 <lispy> Is Phil Jones here?
18:12:10 * benmachine goes to bed instead
18:12:34 * lispy wonder if benmachine's homework is real since it is not complex
18:14:18 <dpratt71> lispy: LOL
18:14:55 <lispy> dpratt71: another possibility is that it is only imaginary
18:15:07 <dpratt71> lispy: of course :-)
18:15:15 <lispy> "Life is complex; it contains both real and imaginary parts."
18:15:24 <lispy> (one of my favorite quotes)
18:15:29 <monochrom> haha
18:15:44 <monochrom> Complex World Haskell
18:15:56 <jimmyjazz14> anyone have any recommendations on writing a general purpose function to convert [(String,String)] -> a, where a is of the class Mappable
18:15:57 <`core> http://img.4chan.org/b/src/1256778687984.jpg
18:16:15 <copumpkin> jimmyjazz14: Mappable?
18:16:19 <papermachine> Cale: Looking through, nothing too interesting except the product formula for sin z/z
18:16:25 <jimmyjazz14> without requiring boilerplate
18:16:27 <sinelaw_> @djinn Mappable a => [(String,String)] -> a
18:16:28 <lambdabot> Error: Undefined type []
18:16:31 <sinelaw_> :)
18:16:42 <jimmyjazz14> copumpkin, Mappable is a name of my own invention, it could be anything
18:17:05 <Cale> jimmyjazz14: What methods?
18:17:08 <copumpkin> jimmyjazz14: really, how it would be written really depends on what the class is supposed to be doing and what methods it provides :P
18:18:39 <Cale> after all, it may even be impossible
18:18:47 <jimmyjazz14> copumpkin, Cale, basically I have a json lib that used Scrap Your Bolierplate with Class lib to create functions for converting types to json strings, I am basically looking to do something of the opposite
18:19:02 <prof_nimnul> hi! why this one eats stack on large files? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11255#a11255
18:19:18 <Peaker> @type sequenceA
18:19:19 <lambdabot> Not in scope: `sequenceA'
18:19:23 <Peaker> @type Control.Applicative.sequenceA
18:19:24 <lambdabot> Not in scope: `Control.Applicative.sequenceA'
18:19:29 <Peaker> @hoogle sequenceA
18:19:29 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
18:19:29 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
18:19:58 <jimmyjazz14> Cale, copumpkin of course I can use type classes but I don't want to have to make redundant instances
18:20:14 <Peaker> except for using a monad distributivity class (that goes from   m (n a) to n (m a)   -- which I now realize only requires Traversable on m) to allow composing monads - what other conflicting monad instances can there be?
18:20:44 <Peaker> I'm reading http://hackage.haskell.org/packages/archive/TypeCompose/0.6.7/doc/html/src/Control-Compose.html   and conal has an instance of Monad for type composition (:.) but its commented out because "there are 4 conflicting instances" possible
18:21:36 <Cale> prof_nimnul: Because Data.Map is strict in the keys, so you're building up a huge expression for inserting elements into a map, and then even if that doesn't overflow the stack, as soon as you look up an element, you'll have elements in the Map which look like (succ (succ (succ (... (succ 0)...))))
18:21:53 <Peaker> I went to bed, but then thought I might be original if I try to create a class for general monad composition using monad distributivity or just an "mnjoin :: m (n (m (n a))) -> m (n a)"  -- only to find TypeCompose already has it, but commented out
18:22:02 <Cale> prof_nimnul: and if there are enough succ's there, traversing that expression to evaluate it will overflow the stack
18:22:26 <Peaker> conal, you there?
18:22:31 <copumpkin> Peaker: uncomment it and reupload it :P
18:22:33 <Cale> prof_nimnul: The solution is to use foldl' to insert each element, and use the insertWith' function to force the evaluation of the element as it's inserted.
18:22:50 <Peaker> copumpkin, well, I think maybe the type compose (:.) type can be newtype'd for the various possible monad instances
18:22:55 <Peaker> copumpkin, I'd like to consult conal about it
18:23:06 <Cale> prof_nimnul: as a side note, your monad expressions will be easier to read if you use <=< and =<<
18:23:34 <Cale> BS.readFile >=> return . BS.lines = fmap BS.lines BS.readFile
18:23:40 <Peaker> I'm both delighted and disappointed that it is so hard (for me) to actually advance the state of the art regarding monads/composition
18:24:14 <Cale> Peaker: That would be my doing. I told Conal about distributive laws before :)
18:24:30 <Peaker> Cale, Ah, funny thing, you also told me, which gave me this idea :)
18:25:08 <dolio> Make a Lawvere theories library.
18:25:13 <Cale> prof_nimnul: does that explanation make sense?
18:25:15 <Peaker> Cale, quoting conal, though, on why its commented out: "A first pass at monad composition.  But now I've read "Composing -- Monads", and I know there's more to it.  At least four different ways, -- all with conflicting Monad instances."
18:25:47 <Cale> Peaker: wouldn't surprise me in the least that there were more ways.
18:26:00 <Peaker> I think it would make sense to have these 4 ways as 3 more newtypes around (:.) no?
18:26:14 <Cale> You could.
18:26:31 <Peaker> It might be a very interesting alternative to monad transformers, no?
18:26:54 <Cale> It would be interesting, but I'm not sure that it's really any more expressive in the end.
18:27:00 <jimmyjazz14> to clarify what I was trying to ask, basically I want to create my own version of Read that takes JsonData instead of Strings but I want it to be derivable (or at least not require extensive boilerplate code to use with a new type)
18:27:07 <prof_nimnul> @hoogle insertWith'
18:27:08 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
18:27:19 <Cale> Well, maybe it is.
18:27:48 <dolio> I don't think all monads (in Haskell, even) interact via distributive laws, do they?
18:27:48 <jimmyjazz14> I realize its not exactly a trivial task but I just need a push in the right direction
18:28:04 <dolio> Cont would be a suspect, for instance.
18:28:46 <Peaker> Cale, If its more composable, its likely to be more expressive..
18:28:58 <jre2> jimmyjazz14: template haskell is probably a better way to solve that
18:29:36 <Peaker> dolio, I would have to take a long pause to think about what the distributivity means in the context of Cont before I can answer that :)
18:29:38 <dolio> StateT isn't straight forwardly distributed, either.
18:29:49 <jimmyjazz14> jre2, I was afraid of that
18:29:51 <Peaker> that sounds simpler to think about :)
18:30:24 <Cale> Peaker: well, it's sort of composable, but you need these distributive laws (and possibly other things for the other noted methods), in order for the thing to work.
18:31:04 <Peaker> does distributivity with IO make sense in any case?
18:31:24 <Cale> Sure, in some cases.
18:31:43 <Peaker> I think maybe its better to just have, instead of distributivity (which seems to just be Traversable'ity), something like: mnjoin :: m (n (m (n a))) -> m (n a)
18:31:57 <Peaker> What could this mean:  State (IO a) -> IO (State a)  ?
18:32:16 <copumpkin> :t Data.Traversable.traverse
18:32:17 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:32:23 <copumpkin> hmm
18:32:26 <copumpkin> :t Data.Traversable.sequence
18:32:27 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
18:32:31 <Cale> Actually, even though the type looks similar the Traversable instances tend not to be distributive laws
18:32:40 <copumpkin> ah
18:33:02 <Cale> at least, the one for [] is not a distributive law
18:33:11 <Peaker> Cale, what meaning could distributivity with IO have?  e.g the State (IO a) example?
18:33:35 <Cale> Peaker: hmm
18:33:36 <Peaker> what are the laws involved?
18:34:01 <Cale> Peaker: http://en.wikipedia.org/wiki/Distributive_law_between_monads
18:34:44 <Peaker> ok, I'm going to need to read that CT book you sent me at some point :)
18:34:47 <Cale> In any case, if a distributive law of that type exists, it will result in something different from StateT
18:35:02 <Peaker> Okay, what about the mnjoin alternative?
18:35:15 <Peaker> that leaves you free to do whatever you want there
18:35:32 <Cale> hmm
18:36:16 <prof_nimnul> Cale: Yes, it makes sense
18:36:20 <Cale> If you have trouble reading those diagrams, I can translate them into Haskell
18:36:39 <Cale> dist :: T (S a) -> S (T a)
18:36:44 <Cale> first law
18:37:06 <Cale> join . fmap dist . dist = fmap join . dist
18:37:39 <Cale> fmap join . dist . fmap dist = dist . join
18:38:01 <Cale> return = dist . fmap return
18:38:22 <Cale> fmap return = dist . return
18:38:32 <Cale> there we are :)
18:38:43 <Peaker> thanks
18:39:31 <Cale> With mnjoin you still need to come up with a way which satisfies the monad axioms.
18:40:12 <Peaker> ouch, TypeCompose exports O but not unO
18:41:34 <Peaker> oh, it should be, something must be wrong with my imports
18:45:38 <Cale> I wonder if the unit laws actually prevent an arbitrary mnjoin from being anything except a straightforward lifting of a distributive law.
19:07:45 <Peaker> how would you write: mnJoin :: IO (s -> (s, IO (s -> (s, a)))) -> IO (s -> (s, a)) ?
19:09:00 <Peaker> seems problematic, though it should be expressible, no?
19:09:10 <jre2> anyone know why debian prefixes nearly every haskell library with "libghc6-"? 99% of them don't even have ghc extensions
19:09:22 <Peaker> (Basically its just   IO (State s (IO (State s a)) -> IO (State s a)
19:13:33 <m3ga> jre2: you are taking about the  library binaries which care compiled with ghc6 and can only be linked with ghc6.
19:14:14 <m3ga> ie source package haskell-curl becomes binary pcakages libghc6-curl-dev, libghc6-curl-prof etc.
19:15:46 <jre2> ah
19:16:58 * m3ga is a member of the debian haskell maintainer group
19:28:53 <dons> jre2: they're compiled against ghc
20:14:28 <conal> Peaker: I'm back.
20:17:02 <conal> Peaker: when there are competing class instances for a given type pattern, i usually like to provide them as "templates" in comments.  People can then choose which template to instantiate for their more specialized situations.  If I picked one instance for the general case, people could not specialize differently.
20:21:07 <SamB_XP> but ... the conflicts!
20:23:08 <Asztal> I have a "class C x => D x y | y -> x", and I'd like to change the functional dependency into an associated type synonym, but I don't know how to express the "C x" constraint with an associated type. Is it possible?
20:25:05 <RoboX> hello
20:25:12 <RoboX> i have a question if any one is there
20:25:19 <RoboX> is any one there?
20:25:25 <Asztal> go ahead and ask :)
20:25:31 <RoboX> ok
20:25:47 <RoboX> import easygui
20:25:56 <RoboX> wait ok this is close enough
20:26:01 <RoboX> gender = female
20:26:08 <RoboX> if gender == female:
20:26:11 <RoboX> print gender
20:26:17 <RoboX> error
20:26:25 <RoboX> female is not defined
20:26:27 <dons> heyhey
20:26:29 <RoboX> ???
20:26:46 <dons> what's your question?
20:27:13 <RoboX> what do i have to do in order to use lexical analysis on gender
20:27:14 <Ray_> Question. I have the string "ca" and the string "xxcadccaab". I want to return a string with all occurrances of "ca" removed - in this example, the string would be "xxdb". This is because I "first" do "xxdcab", but then "ca" appears there, so I remove it as well. I'm looping the remover function until f x = x, meaning it couldn't remove anything. Is there an easier way? I'm using a makeshift isPrefixOf.
20:27:48 <dons> RoboX: do you have a haskell question?
20:27:59 <Twey> :t fix
20:28:00 <lambdabot> forall a. (a -> a) -> a
20:28:00 <dons> Ray_: look up the 'split' package on hackage
20:28:05 <Twey> Hmph
20:28:11 <RoboX> actually this is python i just joined the first room i saw
20:28:32 <Ray_> dons, I'm doing this for a class - I'm not supposed to use any non-trivial haskell functions (above length and elem), which is why I'm implementing isPrefixOf myself.
20:28:34 <dons> RoboX: ok. wrong place.
20:28:36 <RoboX> never mind ill find a python room
20:28:40 <SamB_XP> RoboX: needz moar whitespace!
20:28:40 <copumpkin> RoboX: what if it had been #sexandthecity ?
20:28:55 <joed> He'd sling his python?
20:28:58 <SamB_XP> copumpkin: I still don't get what that title even means
20:29:10 <RoboX> nm sorry
20:29:11 <copumpkin> beats me, and I've seen a lot of it
20:29:12 <kmc> Ray_, can you hpaste what you have?
20:29:15 <inimino> RoboX: try ##python
20:29:21 <Ray_> kmc, I'll have to type it, but yeah.
20:29:25 <Ray_> Give me a few :)
20:29:44 <Twey> GoGloom again?
20:30:15 <inimino> Ray_: you can write fix, then write removeSubstring, then write your function using those two :)
20:31:38 <Ray_> My algorithm goes basically "if the seached string is a prefix of the big string, then return f (removePrefix prefix bigstring). else, remove (the first character in bigstring):(f prefix (the rest of bigstring). This, however, has the issue of taking "ca" and "ccaa" and returning "ca", so I'm looping it.
20:31:47 <Ray_> I found a similar solution in the problem of removing runs of spaces.
20:32:37 <Ray_> Instead of matching ' ':' ':xs and returning ' ':(func xs), I return func (' ':xs), so I don't "miss" the "created" runs of spaces (I want to transform a n-long run of spaces into 1 space)
20:33:06 <Ray_> I was wondering if there's a similar tactic I can employ here, so as to avoid creating "ca" when replacing "ca" in "ccaa".
20:33:29 <inimino> Ray_: you could always backtrack by the length of the search string minus one
20:33:46 <Ray_> That's what I was doing in another version, but it was un-functional.
20:33:54 <Ray_> (Backtracking using buffers was frowned upon :( )
20:35:15 <inimino> you could construct a DFA :-)
20:35:28 <Ray_> I'm basically re-doing the exercises with two things in mind: 1) Do not type until you've written the expressions and proven it works, and 2) Don't use buffers, at all. At most, use counter variables.
20:35:42 <inimino> Ray_: it's really up to you how complex you want to make it, but if efficiency is not your primary concern, fix/looping is fine
20:36:13 <Ray_> Is there no analogue to the whitespace-constricting problem?
20:36:21 <inimino> Ray_: that sounds like a sound pedagogical approach
20:37:15 <inimino> Ray_: the think about whitespace is that the problem is bounded, one space is equivalent to the next
20:37:17 <inimino> s/think/thing/
20:37:33 <inimino> Ray_: but you could just as easily have 'cccccccccccaaaaaaaaaaaaa' and you will need to use a stack or something like it if you want to do that in one pass
20:38:03 <Ray_> Well, not if I somehow returned (f result).
20:38:16 <inimino> well, it's still backtracking
20:38:35 <Ray_> Is it?
20:38:54 <Ray_> (I'm not too wise on the actual definition of backtracking - I call backtracking anything that "undoes" previously done operations)
20:39:15 <inimino> are you just wanting to know how to backtrack some but not all the way without using buffers?
20:39:22 <inimino> backtracking in this context means anything that needs to go back to an already-consumed input token
20:40:02 <SamB_XP> you could use a zipper, maybe ?
20:40:07 <Ray_> Ah, well, this would be backtracking in that case - I'm re-scanning everything. But wouldn't the whitespace-removal algorithm also be backtracking, since it already saw ' ':xs?
20:40:15 <inimino> if you've read a 'c' and then you need to read it again, that's backtracking
20:40:38 <inimino> Ray_: yes, but you only have to go back at most one character, and you know the character will be ' '.
20:41:05 <Ray_> Right. So it's not too bad.
20:41:33 <Ray_> (Performance is 0% of my concerns here - I'm just trying to "think functionally". Buffers and keeping state in them is the C programmer refusing to change.)
20:42:15 <inimino> Ray_: in this case, you could be matching "abcdef", and if you see "abcdeabcdeff" you need to keep track of the first "abcde" all the way to the end of the string
20:43:25 <medfly> I don't know if that solves the ccaa problem, unless I misunderstood this
20:44:15 <inimino> fix is going to be the most straightforward solution
20:44:54 <copumpkin> fix always fixes your problems
20:45:15 <inimino> > fix error
20:45:16 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
20:46:33 <inimino> Ray_: if you want to use counter variables, you could do it that way :-)
20:47:15 <inimino> Ray_: but you'll have to keep a stack or list of them
20:47:40 <Ray_> Ew :(
20:48:15 <inimino> Ray_: that's just the nature of the problem
20:50:40 <inimino> Ray_: if you have seen "aaabc", you would have some stack like [3,1,1]
20:54:35 <Axman6> :t const . const
20:54:36 <lambdabot> forall b a b1. a -> b -> b1 -> a
20:54:42 <Axman6> :t const . const . const
20:54:43 <lambdabot> forall b b1 a b2. a -> b -> b1 -> b2 -> a
20:55:22 <Axman6> :t const . const . const . const -- just to make sure
20:55:23 <lambdabot> forall b b1 b2 a b3. a -> b -> b1 -> b2 -> b3 -> a
21:04:20 <jimmyjazz14> uhhg template haskell is hard
21:04:45 <jre2> jimmyjazz14: have you checked out json and Rjson?
21:05:18 <jimmyjazz14> jre2, no
21:05:26 <ivanm> > let (f .. g) a b = f (g a b) in succ .. (+) 2 $ 3
21:05:27 <lambdabot>   <no location info>: parse error on input `..'
21:05:30 <ivanm> :(
21:05:30 <jimmyjazz14> what should I look for?
21:06:27 <ivanm> why isn't .. allowed as an operator?
21:06:30 <ivanm> @type (..)
21:06:31 <lambdabot> parse error on input `..'
21:06:38 <jimmyjazz14> actually I'm looking at the source code for RJson now
21:06:53 <Twey> ivanm: Because it has special meaning
21:06:57 <Twey> > [1 .. 3]
21:06:58 <lambdabot>   [1,2,3]
21:07:00 <ivanm> what meaning?
21:07:01 <ivanm> oh, duh
21:07:11 * ivanm facepalms
21:07:15 <Twey> ‚ò∫
21:07:19 <jre2> jimmyjazz14: one of the two is more popular, although I don't recall which
21:07:58 <jimmyjazz14> I'm not actually looking to work with json its just a good test case for what I want to do
21:09:17 <jimmyjazz14> looks like RJson uses a dummy type argument for its fromJson class
21:09:21 <jre2> ah
21:09:31 <jimmyjazz14> maybe I'll just go that route
21:33:01 <scutigera> what's a good way to write binary data efficiently ?
21:33:17 <scutigera> like 10^6 doubles
21:33:49 <kmc> there's a Binary library
21:33:58 <kmc> err Data.Binary, in the package binary
21:34:50 <scutigera> I've got a program using ieee-754 and data.binary but it's quite slow.  i think that the bit twiddling in ieee is a problem.
21:35:13 <kmc> have you profiled it?
21:35:40 <scutigera> I don't understand how to profile when some of the packages don't have profiling enabled
21:36:38 <drhodes> anyone have a good guide for type families?
21:37:12 <kmc> drhodes, what do you want to do?
21:37:23 <kmc> there's a long page on the wiki, and t here's the ghc docs
21:37:35 <copumpkin> drhodes: they're pretty straightforward
21:38:04 <drhodes> a collection of type with similar properties copumpkin ?
21:38:08 <drhodes> types*
21:38:18 <copumpkin> drhodes: I think of them as type functions
21:38:19 <drhodes> oh
21:38:30 <drhodes> I was wondering if that was possible
21:38:43 <ddarius> copumpkin: You're not supposed to say any GHC extension is simple.  You are supposed to build it up into a monster of overwhelming complexity.
21:38:53 <copumpkin> oh
21:38:54 <kmc> scutigera, the fastest case would be if your data are already in a StorableArray, and your machine uses an ieee-754 rep for floating point
21:39:10 <kmc> then you can for sure write a very fast output function in C and FFI-call it
21:39:13 <copumpkin> drhodes: it's a monster of overwhelming complexity!! stay away, and stick to h98!!
21:39:30 <drhodes> ok, thanks for the warning
21:39:32 <kmc> oh no hierarchical module names!
21:39:39 <copumpkin> import List
21:39:56 <SamB_XP> lol
21:40:04 * SamB_XP can't stop
21:40:07 <scutigera> kmc: yes I think that dons even wrote an example of such an approach but I teh google has failed me so far...
21:40:18 * SamB_XP still lol
21:40:21 <kmc> scutigera, it would seem that Data.Binary.IEEE754 assumes nothing about your machine's floating point rep and so reconstructs the IEEE754 bitstream
21:40:25 <copumpkin> drhodes: have you seen the recent paper about type functions?
21:40:32 <kmc> so probably it implements a very slow identity function on your machine
21:40:33 * SamB_XP thinks he needs to go to bed
21:40:48 <scutigera> kmc: that's my interpretation, and that would incur a lot of overhead
21:40:49 <drhodes> I'm too dumb for those haskell papers.
21:41:13 <copumpkin> drhodes: nah, they tend to be quite easy reading (I mean, monsters of overwhelming complexity, but shh) http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
21:41:15 <kmc> scutigera, how are you storing your data
21:41:32 <kmc> poll: is "ass types" an acceptable abbreviation for "associated types"?
21:41:39 <kmc> we need something punchy like "fun deps"
21:41:39 <drhodes> ok, I'll read that copumpkin, thanks.
21:41:47 <SamB_XP> kmc: I thought that was another way to say Void
21:41:57 <kmc> (_|_) ?
21:41:59 <scutigera> kmc: well that's the thing, I'm storing it in a file.  so I'm generating the value and then I can write immediately.
21:42:06 <SamB_XP> kmc: precisely ;-P
21:42:06 <kmc> "monad" is scary but "ass type" is hilarious
21:42:30 <kmc> scutigera, it's probably inefficient to do a FFI call for every float
21:42:40 <kmc> perhaps you should load them into a StorableArray first
21:42:49 <kmc> at least in some reasonable size chunk
21:43:24 <kmc> is there a "japanese emoticon or haskell operator" quiz online?
21:43:49 <SamB_XP> kmc: well, generally if it has any wide chars, it's the former ;-P
21:43:53 <SamB_XP> (but not always!)
21:44:00 <scutigera> kmc: true ! build up some # of them so that blocks of n are getting written instead of 8 bytes at a time. thanks I'll look at storablearray
21:45:08 <kmc> ideally we would have some variant of data-binary-ieee754 that assumes the machine uses 754 rep
21:45:24 <kmc> but i don't know the ghc magic to implement that
21:45:29 <scutigera> kmc: and then use lazy byte strings ?
21:45:33 <kmc> need to use unsafeGimmeTheDamnBitsAndDon'tAskQuestions#
21:45:40 <Twey> kmc: You assume they're mutually exclusive
21:46:05 <kmc> > let (^_______^) = (+) in 3 ^_______^ 4
21:46:06 <Twey> > let (^_^) = (+) in 1 ^_^ 3
21:46:06 <lambdabot>   <no location info>: parse error on input `)'
21:46:07 <lambdabot>   <no location info>: parse error on input `)'
21:46:12 <kmc> haha
21:46:13 <Twey> Hahaha
21:46:18 <Twey> Stop that!  xD
21:46:19 <kmc> damn why doesn't that work
21:46:30 <Twey> > let ( ^_^ ) = (+) in 1 ^_^ 3
21:46:31 <lambdabot>   <no location info>: parse error on input `)'
21:46:34 <Twey> Hm
21:46:41 <kmc> oh _ is alphanum
21:46:48 <Twey> Is it?
21:46:50 <Twey> o.@
21:46:51 <kmc> ja
21:46:52 <Twey> Huh.
21:47:01 <Twey> > let (^.^) = (+) in 1 ^.^ 3
21:47:02 <lambdabot>   4
21:49:09 <sohum> > let 1 + 1 = 3 in 1 + 1
21:49:10 <lambdabot>   3
21:49:15 <sohum> > let 1 + 1 = 3 in 1 + 2
21:49:16 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
21:49:34 <kmc> we need open functions!
21:49:41 <sohum> we.. do?
21:49:59 <kmc> yes, so you can redefine (+) on specific inputs only
21:50:34 <kmc> > let 2 + 2 = 5 in 2 + 2 -- you have not been paying attention
21:50:35 <lambdabot>   5
21:50:53 <sohum> let (+) x y | x == 1 && y == 1 = 3 | otherwise = x Prelude.+ y
21:51:05 <sohum> > let (+) x y | x == 1 && y == 1 = 3 | otherwise = x Prelude.+ y in 1 + 1
21:51:06 <lambdabot>   3
21:51:10 <sohum> > let (+) x y | x == 1 && y == 1 = 3 | otherwise = x Prelude.+ y in 1 + 2
21:51:11 <lambdabot>   3
21:51:22 <kmc> woah didn't know you can write multiple guards like that
21:51:37 <copumpkin> that's how guards work
21:51:47 <copumpkin> I didn't realize either
21:51:50 <kmc> but they don't need some ; without layout?
21:52:38 <Gracenotes> @src take
21:52:38 <lambdabot> take n _      | n <= 0 =  []
21:52:39 <lambdabot> take _ []              =  []
21:52:39 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
21:52:47 <Twey> kmc: No
21:53:06 <Twey> kmc: There's no ; for guards ‚Äî the | is the only syntax
21:53:20 <Twey> That's why it's magic
21:53:42 * sohum woooo
21:53:54 <kmc> @check 2+2 == 5
21:53:55 <lambdabot>   "Falsifiable, after 0 tests:\n"
21:54:22 <kmc> @free (+)
21:54:22 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:55:04 <Gracenotes> > splitAt 5 [1,2,3]
21:55:05 <lambdabot>   ([1,2,3],[])
21:55:08 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11257 is this spam?
21:55:23 <copumpkin> kmc: probably
21:55:25 <Gracenotes> hm.. that's more what I want..
21:55:28 <copumpkin> (it's not loading for me)
21:55:58 * kmc is reading recent hpaste out of boredom
21:55:59 <Twey> But it's not a real URL.
21:56:05 <Twey> None of them are.
21:56:05 <Gracenotes> ah well. I may have to hand-write the primitive recursive code >_<
21:56:13 <kmc> php, perl, X configs, agda... what is the world coming to
21:58:07 <kmc> Gracenotes, what do you want to do
21:58:47 <Twey> Argh!
21:58:50 <Twey> Oleg is everywhere!
21:58:54 <Gracenotes> same thing we do every night, pinky
21:58:58 <Gracenotes> try to take over the world!
21:59:54 <Gracenotes> well. by writing Haskell programs. I think I want an efficient splitAt that includes how many elements were consumed
21:59:56 <kmc> > let { ack 0 n = n + 1; ack m 0 = ack (m-1) 1; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 2
22:00:00 <lambdabot>   mueval-core: Time limit exceeded
22:00:05 <ivanm> Twey: what? Oleg? where?
22:00:12 <Gracenotes> which, if the the list is longer than the index given, should be equivalent to the index
22:00:45 <Gracenotes> so I suppose the end result would be a 3-tuple
22:01:53 <Gracenotes> for index k, then <= k recursions would be ideal. I'll probably end up using a modified version of GHC's non-prelude splitAt algorithm
22:03:24 <ivanm> @hoogle (a -> b) -> Set a -> Map a b
22:03:24 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
22:03:29 <Twey> ivanm: I was looking through recent hpastes, and came across a Scheme paste using square brackets, which I didn't know was possible, so I Google'd, and the first result was http://community.schemewiki.org/?scheme-faq-language, which links to http://pobox.com/~oleg/ftp/Scheme/universally-CooL-symbols.html
22:03:36 <ivanm> heh
22:03:56 <ivanm> what's my best bet for converting a Set to a Map? use a list as an intermediary?
22:04:07 <NutCobbler> I'm trying to use a library. I'm not sure what to think as I'm getting this: Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
22:04:23 <kmc> ivanm, you want the Set elems to be Map keys and the values to be what?
22:04:37 <ivanm> kmc: a function to be passed in, as in my @hoogle
22:04:41 <fata_erro> Hello I have been writing an EXE parser and wandered if there is an easy way to parse large data structures in Haskell
22:04:58 <ivanm> fata_erro: heaps!
22:05:01 <fata_erro> I'm currently finding it very tedious
22:05:03 <Twey> ivanm: Yeah, S.toList >>> map >>> M.fromList
22:05:13 <ivanm> parsec, polyparse... ummm... not sure which other parsing libs we have
22:05:15 <kmc> hopefully it will fuse nicely
22:05:21 <ivanm> @type (>>>)
22:05:22 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:05:24 <bos> argh, all my latex-fu has deserted me.
22:05:25 <Gracenotes> ivanm: using a list as an intermediate would be good, but don't forget, the list ordering output of Set provides some nice guarantees :) so you can use Data.Map.fromDistinctAscList
22:05:26 <ivanm> kmc: yeah
22:05:51 <Gracenotes> which doesn't do checking about ordering, with the assumption that everything is sorted and distinct (like sets would be)
22:05:55 <ivanm> Twey: aarrgghhh! operators like that need "Warning: this operator may be hazardous to your mental state!" warning stickers on them!
22:06:10 <ivanm> NutCobbler: that comes from glibc for me
22:06:11 <NutCobbler> fata_erro: Haskell is a lazy language and you can send the whole file contents through your functions at once. The interpreter/compiler breaks down the work.
22:06:20 <ivanm> NutCobbler: oh, wait, that's a dynamic linking problem
22:06:21 <Twey> Is it just me, or have the types inferred for arrows by lambdabot become a lot scarier lately?
22:06:29 <fata_erro> But isn't parsec made for text passing not a binary passing
22:06:33 <ivanm> NutCobbler: read /usr/lib/libpthread.so: it's probably a text file
22:06:39 <ivanm> Twey: blame Cale...
22:06:40 <kmc> seems like lambdabot got some category theory
22:06:51 <NutCobbler> ivanm: pthread is a common library?
22:06:57 <ivanm> NutCobbler: part of glibc
22:07:00 <Twey> ivanm: (>>>) :: Arrow (~>) => (a ~> b) -> (b ~> c) -> (a ~> c)
22:07:00 <Gracenotes> more idiomatically:  Map.fromDistinctAscList . map (\x -> (x, val)) . Set.toList $ mySet
22:07:11 <Twey> For (->), (>>>) = flip (.)
22:07:11 <ivanm> Twey: that doesn't help ;-)
22:07:16 <ivanm> what's ~> ?
22:07:23 <Twey> An arbitrary Arrow
22:07:29 <Gracenotes> ivanm: that's a somewhat more readable rephrasing :)
22:07:33 <Twey> (-> in this case)
22:07:33 <ivanm> O...K...
22:07:43 <fata_erro> NutCobble: parsing and large data structures which have fields of different sizes still requires you to manually assign the data structure fields manually
22:07:45 <Gracenotes> of course, if the set elements will become values and not keys, then you'll need to do Map.fromList as usual
22:07:49 <kmc> "arrow" means "category with products"
22:08:05 <kmc> it's an unfortunate name imo
22:08:14 <ivanm> Gracenotes: nah, I'm wanting Set values to become keys
22:08:27 <ivanm> kmc: OK, so what do "category" and "products" mean? :p
22:08:33 <fata_erro> In C++ I can just created data structure and read a chunk of data that is the same size as the data structure and that's it
22:08:36 <Twey> kmc: I understand arrows.  I have no idea what a category with products is.  :√æ
22:08:36 <Gracenotes> okay. then fromDistinctAscList is good
22:08:45 <kmc> ivanm, it's from category theory.  scary but cool math
22:08:51 <Twey> Are we going to see category-with-products tutorials popping up soon?
22:09:12 <fata_erro> In Haskel each field in a day to structure needs to be assigned manually you can't cast a chunk of data to be a certain data structure
22:09:13 <ivanm> kmc: yeah, I started reading a category theory book... gave up when I got to arrows :s
22:09:16 <kmc> the problem is that in category theory, the morphisms of any category are often called "arrows"
22:09:17 <Gracenotes> fata_erro: you can also import a chunk of data that is terribly corrupt and for which access will yield all sorts of nasty errors
22:09:24 <Gracenotes> in C++
22:09:26 * ivanm almost grokked the whole using categories to create a stack bit...
22:09:29 <NutCobbler> ivanm: I'm like lost on why that file is a text file and why GHC is trying to link to it and failing.
22:09:36 <ivanm> NutCobbler: dynamic linking
22:09:43 <Gracenotes> particularly those where automatic address lookup is implied (pointers, etc.)
22:09:47 * ivanm finds the gentoo bug report he needs to re-file to give an explanation
22:09:57 <ivanm> NutCobbler: http://bugs.gentoo.org/show_bug.cgi?id=4411
22:10:09 <ivanm> see my explanation down the bottom (which I got from dcoutts)
22:10:16 <kmc> fata_erro, Haskell is sufficiently high level that you aren't supposed to think about the bit-by-bit in-memory representation of values
22:10:28 <kmc> Haskell types exist to prove properties of programs and eliminate errors, not to specify representation
22:10:53 <fata_erro> kmc: are you saying that Haskel is too high a level to write an EXE parser
22:11:13 <kmc> you can do it, but it's maybe not the best language for the job
22:11:30 <mlh> fata_erro: google for haskell pickle
22:11:46 <kmc> fata_erro, maybe look at the Data.Binary module from the binary package
22:11:53 <fata_erro> I'm trying to write eight and disassembler which I think Haskel would be very good for just the parsing bit is very difficult
22:12:21 <kmc> you'll probably want to define an algebraic datatype for each of your EXE structures, then define an instance of Data.Binary.Binary for them
22:13:23 <kmc> you could also do the low-level bitwise parsing in C, and call accessor functions via FFI
22:14:00 <Twey> On the contrary ‚Äî I think Data.Binary is much nicer than the C equivalents.
22:14:03 <kmc> that said i was sure i saw an article somewhere about Parsec for binary data
22:14:03 <fata_erro> Here I think you're right but it would have been good to have the whole thing in Haskel
22:14:22 <hexpuem> could make something that reads the C header and outputs haskell code
22:14:26 <hexpuem> or use template haskell or something
22:14:30 <kmc> that said i was sure i saw an article somewhere about Parsec for binary data
22:14:33 <kmc> sorry
22:14:36 <NutCobbler> fata_erro: Check out Parsec.
22:14:53 <fata_erro> I think parsec is too complicated for this task
22:15:31 <fata_erro> In addition some EXE's would be considered malformed while they still run on Windows I need maximum compatibility
22:15:37 <kmc> Twey, it's nicer in some cases... what we might want here is a single representation of a C-like struct which generates (via TH) both an algebraic type, and a Data.Binary instance for that type
22:15:50 <kmc> fata_erro, by EXE you mean a PE executable
22:15:52 <kmc> ?
22:16:00 <fata_erro> Yes
22:16:45 <kmc> someone want to write an FFI wrapper for GNU BFD?
22:17:12 <hexpuem> just make a robot in haskell to do it
22:17:43 <copumpkin> GAH
22:17:46 <NutCobbler> fata_erro: In Haskell you have to think in a manner of how circuits are wired. A function does just poll a keystroke in Haskell, you pipe that input to functions and they lazily respond and work when ever there is a key press.
22:18:04 <copumpkin> another "Is it a bug when GHC has undecidableinstances turned on and does something weird" email
22:18:27 <kmc> ha
22:18:31 <Twey> Isn't UndecideableInstances always doing something weird?
22:18:49 <kmc> if you consider turing completeness to be weird
22:18:53 <jmcarthur> it either terminates or it doesn't, usually...
22:18:58 <Twey> Heh
22:18:59 <Twey> Usually?
22:19:08 <ivanm> kmc: you? :p
22:19:08 <Twey> What's the other option?  :√æ
22:19:12 <copumpkin> neither
22:19:13 <jmcarthur> well, i have to qualify that in case there are real bugs ;)
22:19:19 * Twey laughs.
22:19:24 <kmc> the law of the excluded middle has no place here
22:23:00 <Twey> Hehe
22:23:24 <fata_erro> Does the binary library have a non-I/O implementation to read from say a bytestring
22:24:24 <c_wraith> Am I remember correctly, 6.12 will have operator sections for tuples?
22:25:07 <c_wraith> Or was that just a dream?
22:25:32 <hexpuem> whens 6.12 coming out anyway
22:26:09 <ivanm> hexpuem: 2 weeks later now because you asked!
22:26:15 <Twey> Hahaha
22:26:19 <Twey> c_wraith: Yeah, IIRC.
22:26:25 <hexpuem> are we there yet
22:26:34 <kmc> fata_erro, yes, that's the main mode of usage
22:26:39 <FunctorSalad> it seems the problem is with cabal-install
22:26:48 <ivanm> FunctorSalad: what problem?
22:26:57 <FunctorSalad> ivanm: doesn't work ;)
22:26:59 <FunctorSalad> with 6.21
22:27:01 <FunctorSalad> 6.12
22:27:15 <ivanm> FunctorSalad: well, it needs to be updated to use cabal 1.8
22:27:25 <ivanm> dcoutts et. al. are working on it IIRC
22:27:41 <ivanm> FunctorSalad: even better, ThreadScope for 6.12 won't build with 6.12 because gtk2hs won't ;-)
22:29:22 <iaefai> :t for
22:29:23 <lambdabot> Not in scope: `for'
22:29:32 <iaefai> :t Data.Traversable.for
22:29:33 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Data.Traversable.Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
22:30:34 <iaefai> How does Data.Traversable.for do, or how is it used?
22:38:02 <NutCobbler> ivanm: Thanks. I have it!! I'm using Kubuntu. I just hate how there are so many holes in the distributions when it comes to programming!!
22:38:16 <iaefai> NutCobbler: Windows 7 awaits!
22:38:21 <ivanm> @slap iaefai
22:38:22 * lambdabot locks up iaefai in a Monad
22:38:33 <ivanm> NutCobbler: there are more developer friendly distros in that regard...
22:38:41 <iaefai> Release me!
22:38:47 <iaefai> ivanm: like OSX!
22:39:03 <ivanm> note that it is highly likely that developer-friendly * user-friendly = constant ...
22:39:12 <ivanm> @slap iaefai
22:39:12 <lambdabot> Come on, let's all slap iaefai
22:39:16 <ivanm> ;-)
22:39:21 <iaefai> I like that
22:39:25 <iaefai> @rape ivanm
22:39:25 <lambdabot> Maybe you meant: map type
22:39:31 <iaefai> map ivanm
22:39:38 <iaefai> @map ivanm
22:39:38 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
22:39:39 <NutCobbler> iaefai: I really want the quality control to go up with Linux! I think it can get there. Windows has problems too. Lack of libraries is a good point.
22:39:41 * ivanm runs away from iaefai 
22:39:51 <ivanm> ha! I'm not on that list!
22:40:03 <hexpuem> cmd.exe fucking sucks ass
22:40:08 <iaefai> NutCobbler: I go between windows and osx for my machines.
22:40:22 <iaefai> hexpuem: I like the power shell in win7, now you can resize veritcal and horizontal !
22:40:34 <hexpuem> the terminal still sucks
22:40:50 <hexpuem> console2 sucks too
22:40:57 <hexpuem> haha
22:41:17 <iaefai> It would be rather nice if windows adopted unix principles
22:41:30 <ivanm> rofl
22:41:53 <kmc> cygwin?
22:41:56 <iaefai> xenix!
22:42:09 <iaefai> kmc, I think cygwin is marginal, but then again considering its host
22:42:23 <Gracenotes> it would be nice if PHP adopted System F principles
22:42:28 <kmc> haha
22:42:41 <kmc> putty is a much better terminal than cmd.exe
22:42:45 <hexpuem> yea
22:42:47 <kmc> and bash is a much better shell
22:42:47 <iaefai> Is there anything that exists for pretty printing tables?
22:42:57 <hexpuem> some people asked the putty guy if he could make it a terminal
22:43:00 <kmc> cygwin lets you use both in windows
22:43:03 <hexpuem> but apparently there was some bullshit standing in the way
22:43:07 <kmc> (via your local ssh server)
22:43:19 <kmc> iaefai, tables of what sort?
22:43:28 <jystic> cmd.exe royally sucks :(
22:43:29 <iaefai> kmc, I need to print a Seq Seq
22:43:45 <iaefai> I have some characters I want for borders :p
22:43:48 <MoALTz> in what way does it suck?
22:43:51 <Gracenotes> > text $ "----\n |  |  <- table"
22:43:52 <lambdabot>   ----
22:43:53 <lambdabot>   |  |  <- table
22:44:06 <hexpuem> its level of suck is unmeasurable
22:44:12 <jystic> lol yeah
22:44:16 <MoALTz> i thought i couldn't copy text from it until a week ago
22:44:25 <Gracenotes> iaefai: is it jagged? or each is sub-seq the same length?
22:44:41 <iaefai> MoALTz: Are you trying to blame it for your lack of knowledge?
22:44:45 <iaefai> Gracenotes: All 8x8
22:44:50 <Gracenotes> in general, printf isn't such a bad way, outputting an extra newline at the end of sequences
22:45:16 <jystic> iaefai: you could say that it's unintuitive
22:45:25 <MoALTz> iaefai: more like trying to show that sometimes we rate things as crap due to our ignorance...
22:45:29 <Gracenotes> I suppose you could also use the pretty printing library to coordinate rows and columns and whatever pretty-printing libraries do
22:45:36 <iaefai> jystic: I have known about it since about 1995 :p
22:45:52 <jystic> iaefai: so have I, cmd.exe still sucks though
22:45:55 <iaefai> I couldn't figure out how to use that hughs library for this
22:46:14 <Gracenotes> even if you know about copy/pasting, it is not intuitive or pleasant -.-
22:46:27 <jystic> copy/pasting isn't really what using a console is about
22:46:42 <jystic> some sort of decent autocomplete would be useful
22:47:27 <kmc> tab completion?
22:47:36 <kmc> that's the job of the shell, not the terminal
22:47:56 <hexpuem> lets blame cmd.exe anyway
22:48:05 <jystic> lol
22:48:29 <jystic> yeah fair point kmc, but Microsoft don't exactly give you the goods out of the box
22:48:46 <hexpuem> theres a way to turn tab completion on but it manages to suck too
22:48:48 <hexpuem> like the command history
22:49:26 <jystic> hexpuem: i thought that stuff was on by default, but it still sucks compared to the *nix systems and i can't explain why
22:49:39 <jystic> hexpuem: *nix just works for me and cmd.exe just doesn't
22:50:24 <jystic> hexpuem: and by *nix I mean all of the terminals & shells other than cmd.exe
22:50:36 <hexpuem> haha
22:51:34 <iaefai> Lets face it, everyone speaking here today has batch file envy.
22:51:48 <ivanm> @slap iaefai
22:51:48 <lambdabot> stop telling me what to do
22:51:52 <jystic> haha
22:52:14 <kmc> i remember first seeing shell scripts after learning batch file programming
22:52:16 <Gracenotes> iaefai: I think you mean "unix castration anxiety"
22:52:23 <iaefai> haha
22:52:31 <kmc> it was like, "oh, THIS is what they tried and failed to do"
22:52:48 <jystic> haha
22:53:08 <jystic> i wonder why they had to go their own way on so many things instead of just stealing what already was
22:53:08 <kmc> it seems like some of the very early design of DOS was motivated by the desire to be not UNIX
22:53:22 <jystic> kmc: yeah it seems that way
22:53:38 <jystic> why would you change / to \ in the directory structure!
22:53:45 <jystic> maybe they just hate programmers
22:54:08 <c_wraith> there was plenty of precedent for that, back then
22:54:24 <c_wraith> there were *many* more operating systems that weren't unix-derived, at that point
22:54:57 <kmc> they changed / to \ because they used / instead of - for cmd line options
22:55:07 <kmc> and they used / instead of - for cmd line options because unix uses -
22:55:17 <jystic> haha
22:55:32 <jystic> @slap jystic
22:55:32 * lambdabot slaps jystic with a slab of concrete
22:56:25 * jystic feels better after that then when he's using cmd.exe
22:57:00 <Gracenotes> grrr.. I'm always in this situation where the names I choose for records are always the same ones I like to use for pattern matching. Of course the compiler knows what I mean, but one day I'll make a typo and it'll say "WTF"
22:57:12 <Axman6> @slap lambdabot
22:57:12 * lambdabot orders her trained monkeys to punch lambdabot
22:58:42 <iaefai> Whenever i try to print the value from horizontal = "‚îÄ"  it prints "\9472" and a putStr[Ln] prints absolutely nothing. Any ideas what is wrong?
23:05:39 <kmc> iaefai, "print" calls show on the argument, which gives the string literal, not the characters in the string
23:05:50 <kmc> as for putStr, i wonder if your terminal isn't set up for unicode
23:05:51 <ivanm> Twey: that (>>>) laden Set -> Map function you gave me before ended up having the wrong type :s
23:05:53 <kmc> but i don't know about that stuff
23:18:29 <Twey> ivanm: It wasn't meant to be working
23:18:32 <Twey>  code
23:18:44 <ivanm> oh...
23:18:47 <Twey> I was just illustrating
23:19:20 <ivanm> right, but the keys were the wrong type, so I ended up basing something off what Gracenotes said
23:19:34 <ivanm> @type \f -> S.toList >>> map f >>> M.fromList
23:19:35 <lambdabot> forall a k a1. (Ord k) => (a -> (k, a1)) -> S.Set a -> M.Map k a1
23:19:57 <Twey> What's wrong with that?
23:19:59 <ivanm> well, I suppose I could have just define f in the proper way...
23:20:10 <ivanm> Twey: didn't think of changing f ;-)
23:20:13 <Twey> Or if you don't want to change the keys‚Ä¶
23:20:17 <Gracenotes> composition is all that's happening
23:20:20 * ivanm wanted f to just be k -> a
23:20:26 <ivanm> Twey: yeah
23:20:36 <Twey> :t \f -> S.toList >>> map (id &&& f) >>> M.fromList
23:20:37 <copumpkin> @type \f -> arr S.toList >>> arr map f >>> arr M.fromList
23:20:37 <lambdabot> forall a c'. (Ord a) => (a -> c') -> S.Set a -> M.Map a c'
23:20:38 <lambdabot> forall a k a1. (Ord k) => (a -> (k, a1)) -> S.Set a -> M.Map k a1
23:20:42 <ivanm> Gracenotes: well, your way might be a bit more efficient due to the fromDistinctAscList, etc.
23:20:43 <kmc> arr!
23:21:08 <ivanm> copumpkin: what did all those arr's do?
23:21:09 <Twey> Yeah, you can use different conversion functions as appropriate, though I think all the list conversions in Data.Map are the same
23:21:10 <ivanm> @type arr
23:21:11 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
23:21:14 <Gracenotes> ivanm: hm. what you could do is: ap (,) (func), if func is somewhat simple
23:21:16 <copumpkin> ivanm: made me into a pirate
23:21:21 <Twey> Hehe
23:21:22 <kmc> :t ap (,)
23:21:24 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
23:21:27 <ivanm> Gracenotes: pretty much what I did
23:21:30 <Twey> :t arr id
23:21:31 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
23:21:38 <Twey> Generalises the function to any arrow
23:21:51 <Gracenotes> > map (ap (,) show) [1, 23, 531, 695, 549675423564325643252315]
23:21:52 <Axman6> http://refactormycode.com/ <-- i think we should take more advantage of this in this channel
23:21:52 <lambdabot>   [(1,"1"),(23,"23"),(531,"531"),(695,"695"),(549675423564325643252315,"54967...
23:21:58 <Gracenotes> pretty :o
23:22:19 <Axman6> :t arr
23:22:20 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
23:22:33 <ivanm> Gracenotes: distinctAscList seems to be different anyway ;-)
23:22:52 <ivanm> Axman6: what does it give us compared to other paste sites?
23:23:00 <Gracenotes> different?
23:23:05 <kmc> a peanut gallery
23:23:14 <ivanm> Axman6: especially since you need to be a member AFAICT
23:23:29 <Axman6> what's wrong with that?
23:23:32 <ivanm> Axman6: now, if it had automagic @pl support, etc. in there... ;-)
23:23:37 <kmc> the latest haskell post is 7 months ago
23:23:43 <ivanm> Axman6: not needing to sign in is more convenient? ;-)
23:24:39 <Axman6> ivanm: what it offers is a way for people to make annotations of both code and text, which is extremely useful imo
23:26:58 <ivanm> Axman6: as opposed to comments?
23:27:03 <Axman6> yes
23:27:09 <Axman6> how did i know you'd say that
23:27:10 <ivanm> @pl \ m -> M.filter (f m) m
23:27:11 <lambdabot> M.filter =<< f
23:27:15 <ivanm> ^^ which Monad is that in?
23:27:26 <ivanm> Axman6: because you're psychic? ;-)
23:27:40 <kmc> the (-> r) monad perhaps
23:27:46 <twb> Debian is complaining to me because Darcs doesn't build without threading support, which some architectures do not have.
23:27:51 <kmc> err ((->) r)
23:27:55 <ivanm> yeah
23:28:02 <c_wraith> There must be a parsec function that's something like [([tok], a)] -> GenParser tok st a
23:28:06 <twb> I have an AMD64 VM here, can I simulate a lack of threading support in it by e.g. deleting an .so?
23:28:26 <ivanm> Axman6: so it's basically a way to do what we do here for people that ask but dumped on a website and thus with less discussion?
23:28:38 <ivanm> twb: I don't think so...
23:28:42 <c_wraith> @hoogle  [([tok], a)] -> GenParser tok st a
23:28:42 <lambdabot> Did you mean: [([tok], a)] -> GenParser tok (ST tok tok) a /count=20
23:28:43 <lambdabot> No results found
23:28:45 <twb> Darn.
23:28:58 <ivanm> c_wraith: why _must_ there be one?
23:29:06 <twb> I tried removing -threaded from the .cabal file before, but either I messed up, or cabal went ahead and re-added it.
23:29:16 <c_wraith> because I'm assuming it's a really common thing to want to do.
23:29:44 <c_wraith> @hoogle  [([tok], a)] -> GenParser tok (ST tok tok) a /count=20
23:29:44 <lambdabot> No results found
23:30:38 <c_wraith> I want to match the input against a set of constant strings, and return an item for each string.  Generalize that to [tok], and you have that type
23:31:21 <c_wraith> I can't be writing the only application that wants to do that.
23:32:41 <ivanm> in polyparse, there's parsing functions like oneOf where you give it a list of parsers...
23:33:03 <ivanm> c_wraith: for graphviz, I wrote a couple of my own combinators that did stuff like that
23:33:07 <ivanm> (for polyparse)
23:33:17 <twb> OK, this is weird.
23:33:24 <twb> If I remove -threaded from .cabal now, I get this:
23:33:26 <twb> Linking dist/build/darcs/darcs ...  /usr/bin/ld.real: cannot find -lHSdataenc-0.13.0.0
23:33:29 <c_wraith> Parsec just has so many functions to do things like that already, I'm surprised that case appears to be absent
23:46:54 <twb> Hm, there's a pissy weak ARM machine over here.  I could use that for testing...
23:46:59 <twb> Does ARM have threading support in GHC?
23:54:10 <kmc> the function to try a list of parsers would be mconcat
23:57:07 <Hugglesworth> i've got a really easy typing question if someones got the time
23:58:03 <Vanadium> Hm??
23:58:06 <Vanadium> Hm?, I mean
23:58:36 <Hugglesworth> http://gist.github.com/221220
23:58:38 <FunctorSalad> is there any real point to superclasses except shorter sigs?
23:58:56 <Hugglesworth> 3.hs:2:19:
23:58:56 <Hugglesworth>     Could not deduce (Integral a) from the context ()
23:58:56 <Hugglesworth>       arising from a use of od' at 3.hs:2:19-27
23:59:05 <Hugglesworth> 3.hs:7:60:
23:59:06 <Hugglesworth>     Could not deduce (Fractional a) from the context ()
23:59:06 <Hugglesworth>       arising from a use of ' at 3.hs:7:60-78
23:59:31 <shachaf> Hugglesworth: First, you need parentheses around "x-1" and "n-1".
23:59:35 <Hugglesworth> i know what it means, and why i'm getting it... no clue how to fix
23:59:38 <c_wraith> :t enumFromTo minBound maxBound
23:59:39 <lambdabot> forall a. (Bounded a, Enum a) => [a]
23:59:51 <Vanadium> Hugglesworth: Put a constraint in the type signature of findPrime
23:59:52 <c_wraith> I find myself using that expression a lot.
23:59:57 <shachaf> Hugglesworth: Then -- well, try it without the type signature and see what ghci infers.
