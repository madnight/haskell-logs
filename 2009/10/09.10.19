00:00:43 <c_wraith> hah.  I love having multiple different methods which are entirely "blah = newTMVarIO empty"
00:01:00 <c_wraith> Thanks to types, they're entirely different!
00:01:15 <c_wraith> is this a good sign?
00:01:34 <dmwit> Hooray for classes!
00:02:07 * ksf does those inside main
00:02:47 <ksf> ...or even creates them in constructor functions that spawn a whole thread or such.
00:02:49 <ketil> Anybody know if I should list all prof dependencies as well in the debian/control file?
00:03:05 * ketil is still struggling to put together a working .deb.
00:04:34 <ksf> c_wraith, like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10909#a10909
00:07:05 <Twey> Now if only we could do (foo, bar) :: (IO (TVar Foo), IO (TVar Bar)) = replicate 2 $ newTMVarIO empty
00:07:08 <Twey> ☺
00:08:03 <ksf> yep existential quantification is fine as long as it can be resolved at compile time
00:16:59 <stanv> Is it possible define class for polymorphous types (data MyType a = ...) ?
00:17:58 <opqdonut> well for example "class Functor f where fmap :: (a->b)->f a -> f b"
00:18:31 <opqdonut> or did you mean "instance Ord (MyType a) where ..."
00:18:44 <opqdonut> the first is a class for kind *->* types (type constructors)
00:18:55 <opqdonut> the second is a polymorphic instance
00:19:17 <stanv> opqdonut: I looked for first case, thank you!
00:20:37 * dancor likes using typechecking to figure out what i wanted to do
00:23:44 <ksf> can't the galois guys at least put up a page that says that hackage is down?
00:25:18 * arcatan waits for ishackageup.com
00:27:46 <RichardO> hackage is down?
00:27:53 <stanv> is it mandatory write one symbol 'a' for type in class SomeClass a where .. ? I want two: class SM atype where
00:28:41 <dmwit> stanv: That's fine.
00:28:42 <stanv> is it correct replace `a` with `atype` ?
00:29:29 <ivanm> arcatan: heh
00:29:56 <dmwit> Down with Hackage!
00:29:58 <ivanm> stanv: you can use just about anythign you want as a type variable as long as it starts with a lowercase letter (and is a valid identifier)
00:30:01 <ivanm> @slap dmwit
00:30:01 * lambdabot loves dmwit, so no slapping
00:30:19 <ivanm> grrr....
00:30:22 <dmwit> =D
00:31:16 <ksf> Ha! It's her! lambdabot hacked hackage and uses it to plot her plans for world domination, faster!
00:31:37 <ivanm> ksf: it took you _this long_ to work that out?
00:31:54 * ivanm recalls saying something along those lines to someone about 20 hours ago...
00:31:59 <ksf> she must been using mind rays to control us all!
00:32:50 <ksf> hell playing paranoid while listening to sigur ros doesn't work.
00:34:37 <ivanm> who?
00:35:19 <vininim> lunabot 2010
00:35:19 <ksf> http://en.wikipedia.org/wiki/Sigur_R%C3%B3s
00:36:34 <stanv> opqdonut: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10910#a10910
00:39:54 <stanv> anybody, pleashttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=10910#a10910e look at :
00:40:56 <dmwit> ?src Mnoad
00:40:56 <lambdabot> Source not found. Sorry.
00:40:59 <dmwit> ?src Monad
00:40:59 <lambdabot> class  Monad m  where
00:40:59 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
00:40:59 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
00:40:59 <lambdabot>     return      :: a -> m a
00:40:59 <lambdabot>     fail        :: String -> m a
00:41:12 <dmwit> huh
00:41:31 <ksf> does anyone happen to have the elerea tgz's on his disk?
00:41:43 <ksf> (we should open #haskell-traffiking)
00:41:49 <dmwit> stanv: I can't reproduce that problem.
00:41:56 <dmwit> stanv: So the problem looks to be somewhere else in your code.
00:42:05 <stanv> dmwit: hmm
00:42:14 <dmwit> stanv: Is that definitely line 71?
00:44:12 <stanv> dmwit: I found. I one line I wrote something : foo tc -> Bool, in another boo -> tc a -> a
00:44:51 <stanv> foo :: tc -> Bool, in another boo :: tc a -> a
00:45:27 <stanv> it is force to write `tc a` in all class functions signatures
00:56:28 <stanv> I want my VIM auto-reformating haskell source block after pushing: `Shift-v =`. Something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10911#a10911
00:57:09 <ksf> vimscript is a work of the devil.
00:58:03 <stanv> ?
00:58:22 <ksf> haskell-src-exts comes with a pretty printer, but I don't know whether it's very adaptable.
00:59:13 <ksf> so, assuming that you know how to tame vim, haskell-src does the rest for you, modulo cutting out the block etc.
00:59:56 <ivanm> ksf: no comments
01:00:10 <ivanm> haskell-src-exts has some support for comments, but it's still unstable IIRC
01:00:27 <ivanm> stanv: it's impossible atm to have a pretty-printer reformat your Haskell code automatically
01:00:33 <ksf> does yi do any of that, yet?
01:00:37 <ivanm> I dout it
01:00:40 <ivanm> *doubt
01:00:48 <ivanm> well, it's impossible AFAIK
01:00:56 <stanv> :(
01:01:03 <ksf> at least one doesn't have to sell one's soul just to hack on it.
01:01:30 <dmwit> You shouldn't need any vimscript for this.
01:01:42 <ksf> sometimes, when I open my ~/.vimrc, I consider switching to emacs. thinking of yi fixes, that, though.
01:01:50 <dmwit> Vim makes it really easy to ship some lines out to a filter and replace them with the filtered lines.
01:02:10 <ksf> it's kinda disappointing to have the best editor ever with the worst possibly imaginable scripting language.
01:02:11 <dmwit> If there's no pretty-printer, well, that's a problem -- but vimscript isn't going to help fix that problem.
01:03:06 <dmwit> stanv: Bug the vim devs to implement elastic tabstops. ;-)
01:03:18 <dmwit> http://nickgravgaard.com/elastictabstops/
01:03:31 <ivanm> ksf: that's what you get for bolting the scripting language on as an afterthought
01:03:36 <freetardo> hey hi
01:03:50 <ivanm> whereas emacs was built from the ground up to have customisation/scripting support
01:03:55 <freetardo> what was that haskell coded editor name?
01:03:57 <freetardo> it had a y in the name or something
01:04:04 <ivanm> dmwit: please, no... elastic tab stops are worse than normal tab stops!
01:04:05 <ivanm> freetardo: yi
01:04:12 <dmwit> ivanm: ?
01:04:15 <ksf> emacs is just a glorified graphical shell for an ancient lisp dialect.
01:04:31 <freetardo> w00t
01:04:32 <ivanm> dmwit: ??
01:04:33 <freetardo> yes
01:04:40 <ivanm> ksf: not necessarily graphical ;-)
01:04:44 <dmwit> ivanm: What is bad about elastic tabstops?
01:04:49 <mauke> http://www.vim.org/sponsor/vote_results.php
01:04:58 * ksf sorts curses-like under "graphical"
01:05:18 <ivanm> ksf: but there have been numerous calls to update elisp; I believe that stefan mannier (of haskell-mode fame) plans on doing at least a partial revamp now that he's one of the two maintainers
01:05:27 <dmwit> haha "add integration with Python instead of inventing more Vim script"... and we all know how that turned out.
01:05:41 <SmurfOR> freetardo, yi?
01:05:49 <ksf> tex is getting lua support
01:05:51 <SmurfOR> freetardo, there's leksah too
01:05:59 <stanv> so, what is suggestion for me?
01:06:17 <ivanm> dmwit: we have enough problems with people mixing tabs and spaces for alignment; IMHO elastic tabstops will make it even worse
01:06:25 <ksf> stanv, learn to use ctrl+v and <>
01:06:28 <ivanm> and it relies too much on "smart" editors
01:06:37 <dmwit> ivanm: elastic tabstops are orthogonal to disk format
01:06:42 <ivanm> ksf: pdftex you mean, and it already does
01:06:49 * ksf means luatex
01:07:02 <ksf> pdftex is still tex-only afaik
01:07:05 <freetardo> mm.. why Asian spiritual names? Yi sounds chinese or japanese leksah sounds Tibetan.
01:07:08 <dmwit> ivanm: He demonstrates saving and loading files with spaces-only.
01:07:13 <ivanm> ksf: well, the replacement for pdftex uses lua
01:07:14 <ksf> ...but luatex features pdftex's features
01:07:19 <ivanm> AFAIK it will only produce pdf output
01:07:29 <dmwit> It wouldn't be hard to have a tab-indent/space-align version as well.
01:07:31 <ivanm> dmwit: still sounds like a bad idea to me
01:07:34 <ksf> and those of a lot of other tex implementations.
01:07:44 <SmurfOR> freetardo, i dunno maybe they're all based on The Tao of Haskell
01:07:50 <ksf> e.g. you get microtypography with truetype-fonts with luatex
01:07:52 <mauke> freetardo: leksah is just haskel backwards
01:07:58 <ivanm> ksf: yeah, it's out according to wikipedia, but only context uses it
01:08:20 <ivanm> freetardo: the haskell wiki page on yi explains the name
01:08:26 <ksf> it's in a workable state, just not finalized.
01:08:33 <freetardo> ah lol
01:09:02 * ksf wants to use elerea
01:09:12 <ivanm> ksf: have you ever tried context?
01:09:35 <ksf> nope
01:09:55 <ksf> ...you can use nealy all of latex just fine with luatex
01:10:23 <ivanm> the theory behind context sounds nice; but to me the syntax is a bit too verbose and there's not enough package support for it
01:10:50 <Baughn> So, um.. hackage...
01:11:03 <ivanm> still down
01:13:40 <Baughn> And nobody knows why?
01:14:16 <ksf> the galois guys got their math wrong and folded monk's disk into R^0 space
01:14:39 <ksf> ...at least that's the rumor I heard.
01:14:47 <ksf> might be connected with CERN
01:32:41 <c_wraith> shouldn't that be the LHC?
01:37:25 <ksf> I think... yes.
01:37:33 <ksf> must be a tech in the tech.
01:38:04 <ksf> teching the tech should fix the tech to tech, so we can tech and stop being confused by acronyms.
01:46:32 <huntse>  
01:51:05 <ivanm> huntse:
01:51:11 <ivanm> ;-)
01:53:29 <shambler_> ▲
01:53:36 <skampler> ?
01:54:09 <huntse> Err, sorry about that.  Not my day.
01:54:39 <skorpan> @pl \x -> x < 0.5 && x > -0.5
01:54:39 <lambdabot> (line 1, column 22):
01:54:39 <lambdabot> unexpected "-"
01:54:39 <lambdabot> expecting space or simple term
01:54:41 <huntse> So I have the day off work with a cold, perfect for some haskell hacking and hackage is down. *sigh*
01:54:46 <skorpan> @pl \x -> x < 0.5 && x > (-0.5)
01:54:46 <lambdabot> liftM2 (&&) (< 0 . 5) (> negate (0 . 5))
01:55:43 <skorpan> why is (&&) lifted?
01:57:05 <huntse> @help hoogle
01:57:05 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
01:57:34 <jkff> Hi. How do I install a library with profiling and with "-prof -auto-all"? Adding that to the cabal file GHC-Options gives a message about "Dynamic linking required, but this is a non-standard build (eg. prof)...", and adding -osuf p_o and -hisuf p_hi gives another message: in my case, /usr/bin/ar: creating dist/build/libHSChart-0.12.a \n /usr/bin/ar: dist/build/Graphics/Rendering/Chart.o: No such file or directory
01:57:39 <ski> skorpan : to distribute `x' to both parts ?
01:58:13 <skorpan> oh right, there's that
01:58:24 * ksf decides to piece together elerea's source by copy&pasting it out of the google cache
01:58:31 <Morgane> hello every body
01:59:27 <huntse> Morgane: hi there!
01:59:46 <skorpan> goddammit, not even the google cached version will load for me
01:59:48 <Morgane> hi!
01:59:51 <Morgane> will any body help me with counting the number of Trues in a list of Bool?
01:59:57 <ksf> skorpan, try text only
02:00:10 <Morgane> I am thinking in using if and else
02:00:14 <ksf> google doen'nt cache the css and images and such
02:00:14 <Morgane> if then else
02:00:32 <mauke> length + filter
02:00:38 <skorpan> ksf: that did the trick
02:01:25 <Morgane> mauke: so I filter the falses and count with lenght
02:01:28 <stanv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10912#a10912  -- what is mean '    Kind mis-match'
02:01:29 <Morgane> that is very clever
02:01:32 <stanv>     Kind mis-match
02:01:33 <stanv> :(
02:01:36 <stanv>     Kind mis-match
02:01:58 <ski> Morgane : where did you get the booleans in the list from ?
02:02:01 <ski> `map' ?
02:02:20 <c_wraith> stanv:  Kind is essentially the type of a type.
02:02:20 <mauke> stanv: "kinds" are type types
02:02:32 <Morgane> ski: it's from a primality test
02:02:38 <c_wraith> @kind Int
02:02:39 <lambdabot> *
02:02:46 <c_wraith> @kind Maybe
02:02:47 <lambdabot> * -> *
02:02:49 <skorpan> a sort is the type of a kind!
02:02:53 <c_wraith> @kind Either
02:02:54 <lambdabot> * -> * -> *
02:03:01 <mauke> @kind Either Int
02:03:02 <lambdabot> * -> *
02:03:07 <ski> stanv : probably s/instance CTree (STree a)/instance CTree STree/
02:03:09 <mauke> @kind Either Int Int
02:03:10 <lambdabot> *
02:03:22 <mauke> @kind Int Int
02:03:23 <lambdabot>     Kind error: `Int' is applied to too many type arguments
02:03:35 <mauke> @kind Maybe Maybe
02:03:36 <lambdabot>     `Maybe' is not applied to enough type arguments
02:03:36 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
02:03:36 <ski> Morgane : yes, but how do you get the booleans ? a list comprehension ?
02:03:41 <ziman> can I h
02:03:49 <ski> yes
02:04:11 <Morgane> ski: i'm doing map isPrime on a list of ints that I receive
02:04:13 <ksf> zomg I'm being quoted on the cafe
02:04:14 <fasta> How do I satisfy ghci-haskeline -any && -any? I did cabal install ghci-haskeline and it installed correctly. What more does it want?
02:04:15 <ziman> sorry, my connection is really bad
02:04:25 <stanv> ski: thanks
02:04:46 <ziman> can I have custom element types in Data.Array.Unboxed? I can't find it in the doc...
02:04:57 <Morgane> howmanyprimes xs = map isPrime xs
02:05:07 <mauke> length . filter isPrime
02:05:12 <endojelly> hackage down?
02:05:19 <ziman> endojelly, yes
02:05:21 <shambler_> yes
02:05:24 <ski> Morgane : right .. so instead of calling `filter id' on that boolean list, you can call `filter isPrime' on the number list directly .. because it doesn't matter if you coun't `True's or primes
02:05:27 <endojelly> hmm.
02:05:28 <fasta> endojelly: yes, we love centralized systems.
02:05:39 <ksf> endojelly, but don't despair!
02:05:41 <endojelly> anybody having a direct link to the latest haskell platform?
02:05:47 <fasta> Someone implement HTorrentHackage, please.
02:05:50 <ziman> but there's the alternative hackage vith the reverse deps...
02:05:54 <ski> s/coun't/count/
02:06:00 <ksf> you could be able to salvage source out of the google cache.
02:06:07 <ivanm> Axman6: ping!
02:07:06 <huntse> Rather than length filter wouldn't it be better to just fold?  you don't need the list, you only need to know how long it is.
02:07:08 <Morgane> you are right
02:07:25 <Morgane> duh
02:07:26 <Morgane> ma
02:07:28 <Morgane> n
02:07:34 <Morgane> this is so easy
02:07:43 <huntse> countbool xs = foldr (\x a->if(x) then a+1 else a) 0 xs
02:07:44 <Morgane> why am I making this harder?
02:07:55 <mauke> huntse: I don't think that's better
02:08:02 <mauke> especially not with foldr
02:08:29 <huntse> well you are constructing a list, then throwing it away.  Foldr, foldl, tomaytoe tomato.
02:08:51 <mauke> strictness
02:09:07 <mauke> if you're going to do it manually, use foldl'
02:09:21 <huntse> Sure.  the point is that space complexity is important.
02:09:34 <mauke> I think it's premature optimization
02:09:45 <mauke> I'd expect ghc to eliminate the intermediate list
02:10:21 <ksf> does someone have glfw?
02:11:19 <ksf> ah phew it's on code.haskell.org
02:11:54 <ivanm> heh
02:12:00 <huntse> mauke:  How would you expect ghc to do that?  It has to construct the list in order to take it's length, surely?
02:12:15 <mauke> huntse: no
02:12:53 <huntse> mauke: How do you take the length of a list you haven't constructed then?
02:12:56 <Morgane> yay! it is done
02:13:11 <mauke> http://en.wikipedia.org/wiki/Deforestation_%28computer_science%29
02:13:30 <huntse> Err *cough* that's not deforestation.
02:13:39 <mauke> why not?
02:14:05 <jkff> Hey, again, anyone know how to cabal install a library with -prof -auto-all? cabal install -p does not do this.
02:15:11 <ivanm> jkff: in what way doesn't it?
02:15:30 <jkff> In the way that the library's toplevels don't show up in the .prof file of my program that uses the library
02:15:38 <ksf> jkff, --ghc-options=-auto-all
02:15:52 <ksf> you can enable profiling in ~/.cabal/config
02:16:20 <ivanm> ksf: right, I thought he had already tried that...
02:16:26 <jkff> Oh, cool! Strangely, putting GHC-Options: -prof -auto-all into the .cabal file did not do the trick
02:16:29 <huntse> mauke: well I could easily be wrong, but my understanding was that deforestation avoids intermediate lists by composing intervening functions so you end up with a single function that operates in one pass over the list.
02:16:38 <jkff> Thanks ksf!
02:18:48 <huntse> mauke: So map x $ map y somelist becomes map x.y somelist.  You can't deforest somefun $ map x xs in the general case.
02:19:28 <huntse> ...but as I say I am likely to be wrong.  And I take your point about foldl'
02:26:16 <ksf> huntse, http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
02:27:23 <quicksilver> although, that's not what ghc does, ksf
02:27:35 <ksf> well it's what you can _make_ it do.
02:29:18 <quicksilver> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
02:29:21 <quicksilver> is what GHC does
02:29:25 <quicksilver> with some paper links at the bottom
02:30:12 <aleator> Hmm.. http://hackage.haskell.org/ is down :(
02:30:40 <stanv> where is it possibe to test kind of type in ghci ?
02:30:40 <huntse> Yeah, I've read the stream fusion papers.  It's not clear to me how you can take the length of a list (using "length") without constructing it.
02:30:53 <quicksilver> you don't need to construct the intermediate list
02:30:56 <huntse> Obviously you can do so using a folding and here stream fusion can help.
02:30:58 <quicksilver> (the output of 'filter')
02:31:15 <quicksilver> so there's only one list, not two
02:31:20 <paolino> still, is there anyone with a tarball of hackage or part of it ?
02:31:34 <huntse> Uhuh.  Okay.  I'll climb back in my box.
02:31:35 <paolino> stanv: :k id
02:31:57 <paolino> *:kind
02:32:30 <huntse> aleator: Yeah.  Annoying isn't it?
02:32:33 <stanv> paolino: :)
02:32:58 <paolino> @seen byorgey
02:32:59 <lambdabot> Unknown command, try @list
02:33:25 <Saizan> preflex: seen byorgey
02:33:25 <preflex>  byorgey was last seen on #haskell 1 day, 14 hours, 28 minutes and 1 second ago, saying: ben_m: ... &&& being from Control.Arrow
02:34:09 <ziman> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
02:34:23 <`steven> hi, does anyone know how i could speed this up ? http://codepad.org/VSX4KcEM
02:34:27 <paolino> thanks Saizan, I'm looking for rosezipper package, which I think byorgey has
02:34:54 <`steven> `steven: or if it's even possible at all
02:35:16 <ivanm> `steven: why are you talking to yourself? :p
02:35:31 <`steven> ivanm: because i'm lonely =(
02:35:38 <ivanm> `steven: what are you actually trying to do?
02:35:39 <`steven> ivanm: just to link the two sentences
02:35:46 <`steven> ivanm: irc can get confusing
02:35:53 <paolino> ziman, can you set that in the irc title ?
02:35:57 <`steven> ivanm: what it does is read a text file
02:36:33 <ivanm> `steven: isMatch k ks cs = and $ zipWith (==) (map (k+) ks) cs
02:37:03 <paolino> ziman, packages are there also ?
02:37:09 <`steven> ivanm: ok, thanks, umm, do you still want to know what the whole algorithm does?
02:37:35 <ivanm> `steven: also, any reason for using Int with -1 rather than Maybe Int for getMatching?
02:38:05 <ivanm> `steven: yeah, give us an idea of what you're doing
02:38:18 <`steven> ivanm: because 1) it seemed simpler (i'm, as you can see, completely new to haskell
02:38:29 <ivanm> OK, fair enough
02:38:31 <`steven> ivanm: and 2) there's an error condition involving negatives that i need to catch
02:39:11 <ivanm> `steven: OK, for getMatching, I'd have: getMatching (kh:kt) (ch:ct) = ... and just call isMatch on kt and ct
02:39:22 <ivanm> `steven: and then you can have a single catch-all case for the empty lists
02:40:52 <ziman> paolino, well, some of the packages have darcs/homepage urls there
02:41:15 <`steven> ivanm: there are two sequences of positive integers, and the first sequence is always shorter than the second
02:41:20 <ivanm> `steven: for getDiff, you can do something fancy for the whole "try with coded, if it fails drop the first element"
02:41:38 <ziman> paolino, but the tarballs seem to have been removed
02:41:58 <ivanm> `steven: also, you never seem to use b in main
02:42:19 <`steven> ivanm: if a constant, positive integer is added to each element of the first sequence, then the first sequence will become a contiguous subsequence of the second sequence
02:43:15 <`steven> ivanm: the algorithm finds the constant difference and applies it to each element of the second sequence and outputs it
02:43:59 <`steven> ivanm: also, i don't understand what you mean with the getMatching thing
02:44:34 <ivanm> yeah, no idea what you're doing
02:45:07 <jkff> Type families are cool! I refactored my program to use them and suddenly the essence of being became clear and bliss came.
02:45:28 <`steven> ivanm: ? which part?
02:45:43 <ivanm> `steven: atm, you're calculating diff on the heads of the two heads; that means that when you call isMatch, the condition on the first two heads will be true
02:45:54 <ivanm> `steven: I don't get the whole thing of what you're trying to do ;-)
02:46:32 <`steven> ivanm: ok, so there are two sequences
02:46:39 <ivanm> `steven: eh, don't bother
02:46:44 <`steven> ivanm: =/
02:46:59 <jkff> I had some time series processing that required the time type to be of class Ord (of course), and also Num and Enum to make it possible to collect things into time intervals. But then I introduced a class HasDelta t where type Delta t; add :: Delta t -> t -> t, and I thought: How could I have been so silly as to think that time should be of Num and Enum?
02:47:18 <ivanm> `steven: when you call isMatch from getMatching, you have that k = ch - kh; so kh + k = kh + ch - kh = ch == ch
02:47:30 <ivanm> `steven: so the condition will be true to start with, so you might as well avoid doing it
02:47:40 <jkff> ..Now we shall support also real datetimes, not only Double, and all with the same code - I wonder how I'd do this sort of stuff in Java...
02:48:31 <ivanm> `steven: your biggest problem is that you're recalculating too much stuff
02:48:51 <ivanm> in main, you're doing head raw', tail raw', tail raw'... why not pattern match on raw' to get the head and the tail?
02:49:01 <`steven> ivanm: oh, so isMatch only needs to be called in the tails of known and coded
02:49:17 <`steven> ivanm: because i'm noob =/
02:49:22 <ivanm> `steven: exactly!
02:49:28 <ivanm> then you do "take a" and "drop a"... why not splitAt a?
02:49:37 <ivanm> `steven: also, what's the point of getting b if you don't ever use it?
02:50:13 <endojelly> I'd really like to download haskell platform...
02:50:17 <Morgane> thanks ski
02:50:23 <endojelly> anyone got any mirror?
02:50:27 <jkff> Oh hell, hackage is still down...
02:50:30 <ivanm> endojelly: which platform?
02:50:32 <endojelly> http://hackage.haskell.org/platform/2009.2.0.2/haskell-platform-2009.2.0.2.tar.gz
02:50:44 <jkff> Does there exist a library for parsing dates from bytestrings?
02:50:59 <ivanm> endojelly: ummmm.... which hardware/OS platform ;-)
02:51:23 * ivanm doesn't have any, but it might help others locate the correct version
02:51:31 <endojelly> ivanm, there is only this one
02:51:39 <ivanm> jkff: let me go check hackage for one... :p
02:51:51 <ivanm> endojelly: ummm, do you use windows, mac, linux, etc.?
02:51:51 <mux> but hackage seems ot be down
02:52:02 <ivanm> or are you wanting a source tarball?
02:52:08 <endojelly> ivanm, well, there's also a version bundled with a windows installer and another one as a macos x dmg file, but I just need the tar.gz
02:52:12 <jkff> ivanm: Well, I already see parsedate, and it has a darcs repo outside hackage. Let's see if it can handle bytestrings..
02:52:29 <ksf> endojelly, you can try http://www.mail-archive.com/haskell-platform@projects.haskell.org/msg00645.html
02:52:38 <jkff> (Unfortunately, it can't)
02:52:44 <ivanm> endojelly: so are you wanting the source tarball or the generic unix binary for x86?
02:52:56 <ksf> or, better: http://www.haskell.org/~duncan/
02:53:02 <endojelly> ivanm, are you sure you're not confusing haskell-platform with ghc or something?
02:53:12 <ivanm> endojelly: I doubt it
02:53:17 <ivanm> endojelly: HP == GHC + libraries
02:53:29 <endojelly> ivanm, hmm. I always had to install GHC beforehand
02:53:30 <jkff> (Oh well, let's patch the thing)
02:53:38 <endojelly> never noticed GHC in the platform tar
02:53:53 <ivanm> endojelly: it's possible the source tarball comes with just the libs and you get GHC seperately, I don't know...
02:53:58 <ivanm> but AFAIK it comes with GHC
02:54:01 <endojelly> ivanm, yep, it's like that!
02:54:11 <endojelly> "For unix systems, there is a generic source installer. You only need GHC installed to get started:
02:54:15 <endojelly> * haskell-platform-2009.2.0.2.tar.gz"
02:54:28 <ivanm> endojelly: ahhh, OK, I get you now
02:54:38 <ivanm> endojelly: so you want the _source_ tarball!
02:54:42 <ivanm> which is what I was asking!
02:54:43 <endojelly> ksf, that's perfect, thank you
02:54:59 <endojelly> ivanm, sorry, I thought it was clear by providing the exakt link and filename :D
02:55:03 <endojelly> got it, now, thanks
02:55:17 <ivanm> endojelly: since hackage.haskell is down... how can I check? ;-)
02:55:33 <endojelly> ivanm, water under the bridge. I'm happy! 8)
02:56:16 <dancor> @hoogle maxMb :: [a] -> Maybe Int
02:56:17 <lambdabot> No results found
02:57:27 <HugoDaniel> hi
02:57:34 <HugoDaniel> what is wrong with hackage ? :(
02:58:13 <Lemmih> HugoDaniel: It's on vacation.
02:58:13 <ivanm> it died a long, slow, painful death
02:58:22 <ivanm> lambdabot killed it!
02:58:23 <ivanm> ;-)
02:58:45 <dancor> it's down and no one knows why and some people have even gone insane ^^^
02:58:52 <ivanm> heh
02:58:59 <ivanm> or should that be...
02:59:14 <ivanm> > "mwa" ++ cycle "ha"
02:59:15 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
02:59:24 <dancor> > "mw" ++ cycle "ah"
02:59:25 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
02:59:32 <lambdabot> Mwahahaha, it had it coming.
03:00:03 <ivanm> OK, who's playing silly buggers with lambdabot?
03:00:18 <ivanm> or is that an automatic message whenever someone does what dancor did?
03:00:24 <endojelly> yes, it compiles
03:00:28 <endojelly> soon I will have agda here, too
03:00:48 <lambdabot> Yes, just an auto message. Nothing to see here.
03:00:48 <dancor> ivanm: someone probably did like @echo in a msg
03:00:48 <HugoDaniel> someone should change it to freebsd :)
03:01:00 <dancor> @echo is this a cmd
03:01:00 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "dancor!i=danl@c-67-161-11-17.hsd1.ca.comcast.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo is this
03:01:00 <lambdabot> a cmd"]} rest:"is this a cmd"
03:01:03 <dancor> hm.
03:01:13 <ivanm> dancor: *nod*
03:02:22 <shambler_> o_O
03:03:03 <jkff> What is the idiomatic way to write libraries that work with strings, bytestrings, lazy bytestrings, char8 bytestrings and lazy char8 bytestrings without code duplication?
03:03:36 <jkff> There must be some typeclass for that?
03:03:57 <ivanm> IsString? *shrug*
03:04:14 <ivanm> jkff: AFAIK, there's no real easy way to abstract out working on String, Bytestring, etc.
03:04:36 <jkff> That's quite a pity.. But do people actually duplicate code when they have to handle them all?
03:04:36 * ivanm wonders if bos' text does anything fancy in that regard...
03:04:48 <ivanm> jkff: most cases you don't want to handle them all
03:04:57 <ivanm> and how you handle them depends on which one you're doing
03:05:23 <ivanm> jkff: the APIs for most of the bytestrings are identicaly, IIRC specifically you can replace the lazy and strict of each type without any code changes
03:05:40 <jkff> Well, I'm going to extend the parsedate library to also work for bytestrings, and since I don't have a reason to omit any particular type of bytestrings from its interface, I'd like to make it generic
03:06:33 <ivanm> jkff: no way that I know of, sorry
03:06:36 <ivanm> preflex: seen dons
03:06:36 <preflex>  dons was last seen on #haskell 16 hours, 52 minutes and 14 seconds ago, saying: we're investigating
03:06:39 <ivanm> preflex: seen bos
03:06:39 <preflex>  bos was last seen on #haskell 3 days, 4 hours, 50 minutes and 2 seconds ago, saying: e
03:06:42 <ivanm> hmmm...
03:06:50 <dancor> is there a fast/bytestring-based xml parser?
03:07:01 <ivanm> dancor: check hackage :p
03:07:07 <dancor> that's rich!
03:07:18 <poe> jkff: you might use parsec
03:07:23 <ivanm> dancor: there's xml-parsec; don't know if it uses bytestrings though
03:07:36 <jkff> poe: The library uses it. Actually looks like things are not that bad
03:07:46 <jkff> Probably I even don't have to extend it :)
03:17:06 <mylh> hi all :) anyone knows what have happend to hackage? I've been on vacation last week now i'm back and it doesn't works
03:18:44 <endojelly> Downloading the latest package list from hackage.haskell.org
03:18:46 <endojelly> oh. right.
03:22:47 <Goldy> how can i separate a [[a]] into each of its respect [a]s?
03:23:22 <quicksilver> well it already as separated
03:23:59 <quicksilver> if you want the first item - taht's just like getting the first item from any list.
03:24:07 <quicksilver> you can pattern match, or use "head".
03:24:20 <quicksilver> you can use any of the techniques you would on a normal list, on [[a]].
03:24:24 <Goldy> i need to do the equivalent of python's tuple unpacking
03:24:40 <Goldy> *respective
03:24:43 <Goldy> from before :P
03:26:14 <quicksilver> let [a,b,c,d] = yourlist
03:26:44 <quicksilver> (which is called 'pattern matching')
03:26:58 <SMSshock> 4itaj 4uzhije sms vsego za 0.15 sant. -- >  www.chitay-sms.tk
03:27:00 <SMSshock> 4itaj 4uzhije sms vsego za 0.15 sant. -- >  www.chitay-sms.tk
03:27:04 --- mode: ChanServ set +o mauke
03:27:05 --- mode: mauke set +b *!*@80.233.218.46
03:27:22 <Saizan> mylh: the machine is down, something to do with the disk
03:28:04 --- mode: mauke set -o mauke
03:28:23 <mylh> Saizan: any ideas about when it'll be fixed?
03:29:19 <Saizan> mylh: no idea, but i guess we've to wait for monday morning in the right side of the US, at least
03:30:10 <mylh> Saizan: ah :) you're right. Hope they have backups...
03:30:48 <Saizan> mylh: yeah :)
03:38:28 <dmwit> Well, it's Monday morning now.
03:38:32 <dmwit> ...sort of =P
03:38:36 <dmwit> ?localtime
03:38:39 <lambdabot> Local time for dmwit is Mon Oct 19 06:38:36 2009
03:38:52 <zygoloid> ?localphotograph
03:38:53 <lambdabot> Unknown command, try @list
03:39:30 <dmwit> http://www.seas.upenn.edu/~cis120/staff.shtml <- Daniel Wagner is me
03:39:47 <zygoloid> that's not going to show your 6am tiredface though ;-)
03:39:56 <dmwit> no tired face here
03:40:01 <dmwit> =)
03:40:08 <zygoloid> lucky. i have tiredface...
03:40:10 <zygoloid> ?localtime
03:40:14 <lambdabot> Local time for zygoloid is Mon Oct 19 10:40:10 2009
03:40:30 <zygoloid> ^^ and it's an hour later than that here :)
03:40:45 <dmwit> You should fix your computer/IRC client, then...
03:41:16 <dmwit> Or is your computer in a different time zone than you? O_o
03:41:30 <zygoloid> my computer is in a different timezone. but its localtime is UTC since it has users all over the world :)
03:43:39 <dmwit> Huh, I thought I was GMT-5, and this time zone map seems to confirm that, but it also says that GMT is 10:42 and my time is 6:42.
03:43:42 <dmwit> What gives?
03:44:26 <dmwit> Oh, maybe DST.
03:52:09 <huntse_> @hoogle Probability
03:52:10 <lambdabot> No results found
03:55:15 <jkramer> Hello
03:55:25 <jkramer> Is there a way to throw compile time errors manually?
03:55:51 <dmwit> > 3 `asTypeOf` "a" -- ?
03:55:52 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:55:52 <lambdabot>    arising from the literal ...
03:55:56 <dmwit> oh
03:56:02 <dmwit> Like, with a custom message?
03:56:06 <jkramer> E.g. I have a function that takes a list, but the list must not be empty and giving it an empty list is definetely an error
03:56:16 <medfly> > (error "woo!")
03:56:17 <lambdabot>   * Exception: woo!
03:56:24 <jkramer> And I want to program not to compile when it's called with an empty list
03:56:36 <dmwit> jkramer: To turn that into a compile-time error, you must have a type representing non-empty lists.
03:56:41 <dmwit> For example, (a, [a]).
03:56:41 <Cale> jkramer: How is GHC supposed to know if a list you're passing it is empty?
03:56:56 <jkff> Whoohoo, I made parsedate work with bytestrings!
03:56:59 <dmwit> jkramer: (emptiness of normal lists is a runtime property, not a compile-time one)
03:57:03 <Raevel> hackage status?
03:57:30 <ivanm> down
03:57:38 <Cale> Must it solve the halting problem, or you just want to make it an error when the thing is called with what is syntactically an empty list, like: foo []
03:57:39 <mylh> Raeve: hackage is down for me
03:57:43 <ivanm> STOP ASKING ABOUT HACKAGE!
03:58:02 <Raevel> i feel crippled :-(
03:58:04 <medfly> IT WILL NEVER GO UP AGAIN!!!!
03:58:08 <medfly> why?
03:58:22 <mylh> maybe someone should post notice or add it to topic
03:58:31 <ivanm> mylh: we've discussed that
03:58:39 <ivanm> and then people will ask "is hackage still down?"
03:58:48 <ivanm> that's assuming they bother to read the topic in the first place...
03:58:59 <dmwit> jkramer: In any case, if you have foo :: (a, [a]) -> b (for some more concrete types a and b), then calling foo given a list of type [a] amounts to providing a compile-time proof that the list is non-empty.
04:00:21 <mylh> :) but still... I was confused and many others will also
04:00:41 <jkramer> dmwit: dmwit Wouldn't that be a tuple?
04:00:55 <ivanm> mylh: I said it should be in the topic, others disagreed
04:01:09 <jkramer> Cale: I thought there maybe was some kind of preprocessing macros that could be used
04:01:10 <dmwit> jkramer: (a, [a]) is a tuple, yes
04:01:29 <jkramer> So, I need to use a tuple to get this behavior?
04:01:54 <Cale> jkramer: Or a custom type.
04:02:00 <dmwit> No, there's half a dozen other ways to do it.  But you can't use the list type and get compile-time length checking.
04:02:03 <dmwit> ...in Haskell
04:02:05 <dmwit> =)
04:02:13 <jkramer> :(
04:02:17 <dmwit> Agda might be a good choice if you want compile-time length checking. =)
04:02:27 <jkramer> Agda?
04:02:32 <dmwit> Agda.
04:02:46 <jkramer> Oh, I see
04:03:14 <Cale> But even in Adga, it's yet another type.
04:03:17 <Cale> Agda*
04:03:32 <Saizan> well, you can do it in haskell too, with gadts
04:03:33 <dmwit> yes
04:03:51 <Cale> iirc, ndm had a program which did some amount of checking for cases where a function will certainly error out.
04:03:59 <dmwit> Yep, GADTs, phantom types, newtypes, ...
04:04:06 <dmwit> ?where catch
04:04:07 <lambdabot> http://community.haskell.org/~ndm/catch/
04:04:08 <Saizan> though it's not as nice to manipulate the lengths, because you've to write type-level functions
04:04:14 <Cale> right, that's the one
04:04:22 <Raevel> oh , i rememberd i had all the hackage packages i need on my server \o/
04:04:35 <Cale> Why is hackage down?
04:04:50 <dmwit> Because YOU ARE A BAD PERSON.
04:04:58 <Cale> heh
04:04:59 <ivanm> dmwit: you mean it's all Cale's fault? :o
04:05:03 <medfly> it always is
04:05:06 * ivanm thought it was dons' fault...
04:05:26 <Cale> It's dons' fault?
04:05:32 <dmwit> dons-blamers are conspiracy theorists, it was no inside job
04:05:42 <dmwit> go back to sleep, sheeple
04:06:08 <ivanm> Cale: it's hosted at galois... connect the dots! ;-)
04:06:19 <Cale> ah, hehe
04:06:35 <dmwit> Follow the money... and don't get into a land war in Asia.
04:06:55 <ivanm> heh
04:08:54 <mxc> as someone who lives in SE Asia now, and has been called a bad person many times in the past, why is hackage down now?
04:09:20 <ivanm> @slap mxc
04:09:20 * lambdabot activates her slap-o-matic...
04:09:45 <dmwit> It is a mystery...
04:09:54 <mxc> watch out..  slapping is technically assault, technically punishable by judicial caning in this part of the world
04:10:43 <ivanm> eh, our PM got slammed on the national media for saying he smacked his kids
04:11:12 <huntse_> mxc: hackage is down because someone captured all the special magical haskell fairies that keep it running.
04:11:18 <dmwit> ivanm: That sucks.
04:11:32 <medfly> what else is it besides assault?
04:12:04 <medfly> it's not the worst kind of it, but it definitely can be considered assault...
04:12:10 <dmwit> Smacking your kids?
04:12:17 <medfly> slapping someone
04:12:17 <ivanm> it's punishment
04:12:20 <dmwit> It's punishment.  The judicial system is based on it.
04:12:33 <ivanm> damn political correctness commissioners...
04:12:48 <mxc> oops, TH generated .o file is weighing in at 688k
04:12:54 <medfly> I don't know. I know some people that view leaving your kids outside is punishment.
04:12:58 <dmwit> It's the fastest way to get short-term reform.  During the short-term reform, you can use better methods to make long-term reform possible.
04:13:02 <medfly> some people would call that abuse. we have different opinions.
04:13:07 <ivanm> dmwit: agreed
04:13:27 <medfly> you probably wouldn't get in trouble for it
04:14:04 <mxc> actually a bit less than i'd have though
04:14:06 <mxc> thought
04:15:44 <benmachine> I have a lot of opinions
04:15:55 <benmachine> particularly in this area
04:16:02 <benmachine> but too many so I will keep quiet
04:16:03 <ivanm> benmachine: how nice
04:16:07 * huntse_ thinks we'd be better sticking off the whole topic of how to discipline kids on this forum.
04:16:20 * dmwit promises to shut up
04:21:53 <mercury^> Suppose I have a type F which is a functor, but I don't want to define F but only G = F Int. Can I somehow get fmap to work with G still?
04:22:31 <Saizan> no
04:23:08 <mercury^> :(
04:23:24 <endojelly> soooo... what *is* wrong with hackage?
04:24:04 <huntse_> endojelly: it's solved the halting problem.  By example.
04:24:38 <ivanm> heh
04:24:38 --- mode: ChanServ set +o Saizan
04:24:43 --- mode: Saizan set -t
04:24:47 <endojelly> ah. so it works perfectly well right now. it evaluates to _|_.
04:25:19 <Saizan> @topic-cons "Hackage is down, server problems."
04:25:19 <lambdabot> I do not know the channel "Hackage
04:25:29 <Saizan> @topic-cons #haskell "Hackage is down, server problems."
04:25:29 --- topic: set to '["\"Hackage is down, server problems.\"","The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/","#haskell-in-depth launched!","Haskell News:  http://reddit.com/r/haskell","The Haskell programming language","http://haskell.org","Paste:  http://moonpatio.com","Logs: http://tunes.org/~nef/logs/haskell/"]' by lambdabot
04:25:30 --- topic: set to '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]' by ChanServ
04:25:30 --- mode: ChanServ set +t-o lambdabot
04:25:50 <ivanm> TMR 14 is out? I thought there was just a call for papers...
04:26:19 <ivanm> oh, right, a couple of months ago
04:26:39 <mercury^> Saizan: what is the most elegant way to get what I want then? Define F and and do "type G = F Int"?
04:27:04 --- mode: ChanServ set +o mauke
04:27:05 --- mode: mauke set -b *!*@80.233.218.46
04:28:05 --- mode: mauke set -o mauke
04:28:09 <profmakx> hmpf
04:28:14 <profmakx> what happened to hackage
04:28:56 <opqdonut> it's broken
04:29:12 <ksf> mercury^, yep, "type" doesn't introduce a new type
04:29:41 <mercury^> ksf: It's still a bit annoying that I'll have to even come up with some name for F (and that F is visible).
04:29:57 <ivanm> Saizan: looks like lambdabot didn't want to let you change the topic...
04:30:02 <ksf> well you can't have a functor without a type parameter.
04:30:28 <ksf> ...as a functor is a thing that provides a morphism that can change exactly that parameter.
04:31:17 <mercury^> ksf: it's still a functor, it just has a limited domain.
04:31:40 <profmakx> broken hackage is no good :(
04:31:44 <ksf> but a thing that only goes F Int -> F Int isn't a functor.
04:31:48 <ksf> that's an endofunctor.
04:32:11 <mercury^> It's Int -> F Int.
04:32:24 <mercury^> From the category {Int} into Hask.
04:32:26 <ksf> that's pointed.
04:33:07 <ksf> ...the type class hierarchy is an utter mess, of course.
04:33:15 <ksf> (pure being a method of applicative)
04:33:33 <mercury^> Maybe you misunderstood my notation. It's really a functor.
04:33:57 * arcatan tackles the awkward squid
04:34:28 <mercury^> Although one could define pure I guess.
04:35:08 <mercury^> Anyway, it's annoying that one has to introduce a dummy type to tell Haskell about it.
04:36:30 <mylh> is it some kind of having fun asking about localtime?
04:36:52 <mercury^> Especially since this will be part of a paper that people without knowledge of Haskell should be able to read, it will be very confusing for them if I use a dummy type.
04:39:17 <jkramer> Is hackage down?
04:39:26 <ivanm> YES
04:39:46 <ksf> er oh. you're not using -> as a morphism from hask to hask
04:43:53 <ksf> mercury^, the thing is: you can't sensibly talk about going from somewhere to hask using hask, at least not without confusing people.
04:45:08 <ksf> ...so the key to clarity might be to lift the Hask you are talking about to use :-> or something.
04:45:41 <endojelly> I'm just, like, gonna type in "cabal update" until it stops not working.
04:46:11 <dcoutts> and there was much wailing and gnashing of teath
04:46:54 <ksf> http://www.mail-archive.com/haskell-cafe@haskell.org/msg66061.html
04:46:57 <ksf> now that's interesting.
04:47:23 <ksf> maybe someone forgot to start httpd?
04:48:01 <dcoutts> no, the problem is that the /srv filesystem is not responding
04:48:15 <Saizan_> mercury^: the Functor class is about endofunctors, there's a more general class in category-extras
04:48:16 <dcoutts> any attempt to read anything off it makes the calling program hang
04:49:41 <mercury^> Saizan_: Now would be the moment for me to bitch about hackage being down. :>
04:57:13 <Saizan_> mercury^: heh, maybe edwardk has a copy on comonad.com
04:57:43 <dcoutts> Heffalump: you about?
04:58:08 <ivanm> Saizan_: cohackage? :p
04:58:44 <Saizan_> ivanm: cohackage is the one that downloads packages from you :)
05:00:51 <HugoDaniel> hackage :(
05:01:37 <profmakx> we need hackage mirrors!
05:01:39 <HugoDaniel> i can mirror hackage
05:01:39 <profmakx> many of them!
05:01:49 <HugoDaniel> in my unversity
05:01:53 <profmakx> just doesn't help atm
05:01:58 <Tobsan> @arr
05:01:59 <lambdabot> Arrr!
05:02:03 <Tobsan> :(
05:06:20 <ksf> if we pool or tarballs, we might be able to do a mirror!
05:10:34 <ivanm> Saizan_: heh
05:17:22 <fnord123> Hi all. Quick question: Is it possible to use a cabal file to determine which library I would like to link against? i.e. If my code is a bit old and I'd like it to use an old version of a module (as opposed to relying on a .ghc file)?
05:18:11 <dcoutts> fnord123: it's rather the other way round, you can use a .cabal file to specify what libs (and versions thereof) to build against
05:25:34 <raim0_> where can I download the haskell platform?
05:26:09 <ivanm> dcoutts: do you have a mirror for HP on your code.haskell account?
05:26:15 <ivanm> someone was intimating that before...
05:26:38 <ivanm> raim0_: which OS/architecture are you after? or the source tarball?
05:26:47 <dcoutts> ivanm: no, I've got a new server impl, but not a recent snapshot of the package tarballs
05:26:54 <dmwit> raim0_: Hackage is down just now, so unless your distro has a package for it...
05:27:11 <dcoutts> I've got older snapshots, but that's no so useful
05:27:43 <ivanm> yeah
05:28:07 <profmakx> its not exactly down
05:28:15 <profmakx> because its still possible to download packages
05:28:21 <profmakx> for certain values of possible
05:28:23 <profmakx> and download
05:28:24 <raim0_> ivanm: linux/32-bit and I didn't notice that jaunty's repositories would have the haskell platform
05:28:30 <dmwit> profmakx: oh?
05:28:53 <profmakx> i did "cabal install yi" about 30 minutes ago
05:29:03 <dmwit> raim0_: If you get into Haskell at all, you may want to manage your own Haskell stuff.
05:29:05 <dcoutts> profmakx: did you have the tarball cached?
05:29:08 <profmakx> and it still makes "progress", i.e. installs dependencies
05:29:26 <dmwit> Ubuntu and GHC have a sort of pessimal match between releases.
05:29:37 <fnord123> dcoutts: Really? I know a .cabal file will be able to say which version it wants to link against but I don't remember being able to have two versions of a module installed. Is there a way to do that using cabal-install?
05:30:20 <dcoutts> fnord123: sorry, I didn't mean you can link one program against two versions of a single named package
05:30:43 <dcoutts> fnord123: you can certainly install multiple versions of a package though
05:30:50 <fnord123> I only want to link against one. But I want it to be an old version. i.e. letting bit rot set in. :)
05:30:59 <dcoutts> fnord123: and then link some programs against one version, and others against the other
05:31:09 <profmakx> dcoutts  certainly not all tarballs of all depdencies
05:32:05 <fnord123> dcoutts: do you know where I might find documentation on installing multiple versions of a module?
05:32:16 <dcoutts> fnord123: you just install it
05:32:24 <dcoutts> fnord123: cabal install foo-1.0
05:32:28 <dcoutts> or whatever
05:32:36 <ivanm> fnord123: a module or a package?
05:32:40 <Axman6> when hackage is back up >_>
05:32:54 <ivanm> Axman6: \o/
05:33:22 <ivanm> Axman6: any idea why ben hasn't cabalised and uploaded ANUplot?
05:33:25 <fnord123> ivanm: a package.
05:33:45 <Axman6> no idea. i should give it a try, it's a nice package
05:34:06 <Axman6> we used it for one of our first year assignments
05:34:37 <raim0_> dmwit: what do you mean by managing? creating debian packages for these or what?
05:34:51 <ivanm> Axman6: OK, next question... how far out is quenbeyan? someone suggested I live there...
05:35:26 <Axman6> not too far, a friend of mine lives there, and goes to UC a few days a week
05:35:26 <Axman6> it's a hole though >_>
05:35:26 <dmwit> raim0_: Nah, I just mean installing the latest GHC and cabal-installing the packages you want straight from Hackage.
05:35:26 <Axman6> probably cheap
05:35:30 <ksf> argh I can't stand packages failing because of -werror
05:35:47 <ksf> ...especially if it's something like -ffi vs. ForeignFunctionInterface
05:36:09 <ivanm> Axman6: any idea about transport to/from there to ANU?
05:36:22 <dmwit> I thought Hackage wouldn't even let you upload packages with -Werror enabled.
05:37:21 <Axman6> ivanm: i think there might be a bus that goes from QBN to civic a few times a day actually. could be wrong though
05:37:21 <dcoutts> ksf: that's why we banned -werror on hackage
05:37:21 <ksf> ha!
05:37:24 <ksf> it's in time-1.1.2.0
05:37:25 <ivanm> Axman6: hmmm....
05:37:31 <ksf> ...in every single file.
05:37:33 <ivanm> Axman6: so it'd have to be car probably?
05:37:37 <dcoutts> that's an older package I guess
05:37:53 <Axman6> i think the bus would be alright
05:38:00 <dcoutts> ksf: ah yes, time, I think that was one of the ones that made us bring in the policy :-)
05:38:16 <Axman6> ivanm: http://www.deanesbuslines.com.au/queanbeyan/830.html
05:39:05 <Axman6> anything that goes to civic will drop you 15 mins walk from ANU
05:39:36 <ksf> ...and then these warnings about orphan instances for show and read.
05:39:59 * ksf can't imagine how that code is able to compile without either removing -wall or -werror
05:40:29 <ivanm> Axman6: hmmm... $3.30 to/from ANU for concession...
05:40:47 <ivanm> a bit pricey...
05:40:49 <Axman6> well, it's a private company
05:41:05 <ivanm> yeah
05:52:42 <raim0_> dmwit: how do I install cabal as the cabal-install's bootstrap.sh tries to fetch needed package from the hackage
05:52:54 <byorgey> preflex: seen paolino
05:52:55 <preflex>  paolino was last seen on #haskell 3 hours, 15 minutes and 51 seconds ago, saying: ziman, packages are there also ?
05:53:17 <dcoutts> raim0_: you're out of luck until hackage is back online
05:53:20 <raim0_> it's unbelievable how long it has been down already
05:53:29 <dcoutts> weekends :-)
05:53:42 <dcoutts> and the IT admin is on US west coast time
05:53:53 <raim0_> even half an hour is bad on a site this important
05:54:24 <dcoutts> so he'll not be awake for another few hours
05:55:32 <yitz> dcoutts: there has been a lot of talk of mirroring during the past 24 hours. there's even at least one volunteer.
05:55:37 <yitz> dcoutts: is there a ticket for that?
05:55:47 <dcoutts> yitz: no
05:55:48 <Axman6> raim0_: do you think someone's getting paid to look after hackage?
05:56:09 <yitz> oh wait, i can't file the ticket, monk is down!
05:56:14 <byorgey> hehe
05:56:15 <dcoutts> :-)
05:56:45 <byorgey> "well, while I wait to file the ticket, I'll just go read about that new package someone uploaded the other... doh!"
05:57:11 <raim0_> Axman6: why not
05:58:34 <dcoutts> raim0_: the problem is finding anyone to pay
05:58:59 <dcoutts> finding anyone willing to pay that is
05:59:29 <yitz> someone already *is* paying, by providing the service for free. you can't exactly complain.
06:01:09 <raim0_> yitz: I guess you're right
06:07:54 <medfly> I wonder, how much paying is there to be done.
06:07:55 <medfly> per time period
06:08:00 <medfly> just curious, in case I ever have money.
06:08:39 <burp> hackage can't have high requiremenets, it's all static, right?
06:08:57 <burp> packages are also small in size
06:09:07 <burp> so it's not much traffic
06:10:54 <byorgey> medfly: for hackage, or in general?
06:12:10 <medfly> I am not sure.
06:12:19 <medfly> I suppose that for hackage.
06:13:53 <fnord123> how much traffic does hackage get?
06:33:38 <fasta> You can always do Hackage over Freenet.
06:33:55 <fasta> Except in that case you cannot create lies/statistics.
06:34:37 <fasta> The problem with Bittorrent is that it cannot handle corporate firewalls very well.
06:35:14 <fasta> It might be a few orders of magnitude slower, but at least it won't go down for no reason at all.
06:35:24 <fasta> Centralized systems always fail.
06:36:58 <pozic> Is there a good way to match on either of two constructors out of three which happen to contain the same field?
06:37:13 <SamB_XP_> having a few mirrors listed (a) on www.haskell.org and (b) in file downloaded by cabal should help too ..
06:38:12 <SamB_XP_> ... and I think the platform shoul have an sf.net project created so we can get plenty of mirrorage for it's downloads ;-)
06:38:18 <mux> pozic: not really, you'll have to match both patterns independantly, but you can factor out the common parts in a where clause; or you can use view patterns along with a function transforming your three-constructors data type into a two-constructors one
06:39:58 <fasta> The problem with mirrors is that it still requires a central point of control.
06:40:22 <fasta> You have to communicate to some authority to add your package.
06:40:44 <fasta> On Freenet, you can just publish it and be done with it _and_ you have cryptographic signatures.
06:41:12 <fasta> For a community project central points of control are useless, imho.
06:41:25 <fasta> Now, if this was a corporation, things would be different.
06:41:45 <fasta> Compare git/cvs.
06:43:19 <ksf> urks. I thought I grokked frp, and still think I do (more or less), but elerea's monads confuse the heck out of me.
06:45:44 <jkramer> Ok, I created a type for non-empty lists data NEL = NEL (a, [a])
06:46:07 <copumpkin> Cofree Maybe!
06:46:09 <jkramer> Now is there a safe way to create values of that type without having the user to say NEL (foo !! 0) (tail foo)
06:46:12 <jkramer> ?
06:46:29 <jkramer> Because that wouldn't really help me in preventing errors caused by empty lists :)
06:46:38 <copumpkin> !! 0 === head
06:46:42 <Vanadium> jkramer: fromList foo = NEL (head foo, tail foo)
06:46:51 <copumpkin> or head &&& tail
06:46:53 <Vanadium> define that, use fromList everywhere, rejoice
06:47:15 <jkramer> But head and tail may still fail at runtime when the users feeds the constructor with an empty list
06:47:21 <ksf> mkNel x xs = Nel (x, xs)
06:47:27 <EvilTerran> surely you want a fromList :: [a] -> Maybe (Nel a) -- ?
06:47:53 <fasta> ksf: there is not one FRP, just a bunch of systems saying there are doing FRP.
06:47:55 <jkramer> Hmm, that would work I guess
06:48:24 <ksf> indeed. and reactive's api still rocks all the others.
06:49:03 <EvilTerran> given that not all lists are NELs, your function from lists to NELs is partial, and this should be encoded in its type
06:49:38 <yitz> you could write mkNel :: [a] -> Maybe (Nel a)
06:50:04 <yitz> jkramer: look at the Safe package for more ideas
06:50:17 <yitz> when hackage come back up. sigh.
06:50:22 <jkramer> Yeah...
06:50:45 <jkramer> Google told me about another module data-nonempty or something like that, but I can't have a look :)
06:51:45 <mercury^> yitz: Hey. I figured out what was wrong. (And because I had to be smart when correcting it, I introduced a lot more bugs that I had to chase this morning).
06:52:09 <yitz> mercury^: great! what was the problem?
06:52:48 <yitz> mercury^: was i right that beta can't treat it's first term completely opaquely?
06:52:51 <yitz> its
06:53:07 <mercury^> First I had accidentally applied arguments in the wrong order at one place. That caused it to terminate while it should not. Additionally, I had forgotten to reduce the indices by 1 when dropping a lambda.
06:53:17 <mercury^> No, the handling of the lambda was correct.
06:53:28 <yitz> mercury^: oh, that kinda stuff. ok.
06:53:41 <SamB_XP_> dcoutts: what does it take to mirror hackage ?
06:53:56 <SamB_XP_> dcoutts: do we need to switch to hackage2 ?
06:54:03 <dcoutts> SamB_XP_: that'd help
06:54:13 <yitz> mercury^: what techniques did you end up using to find that stuff?
06:54:40 <dcoutts> SamB_XP_: it depends what functionality you want on the mirror
06:55:06 <yitz> dcoutts: do we want flat peer mirroring, or a master/slave model?
06:55:08 <dcoutts> SamB_XP_: eg, just the tarballs and index so that cabal-install can use it, or also all the dynamically generated html pages
06:55:09 <mercury^> The wrong application order was obvious after a good night's sleep. For the index reducing I had luckily found a good example of a wrong reduction.
06:55:11 <SamB_XP_> dcoutts: well, being able to use cabal(1) at minimum
06:55:25 <ksf> I think everybody would be hore than happy with just static index + tarballs
06:55:37 <SamB_XP_> lists of packages would be *nice*
06:55:41 <dcoutts> yitz: the tricky bit there would be the dynamic content
06:56:02 <yitz> SamB_XP_: the web pages are pretty important.
06:56:09 <dcoutts> the new server ought to be able to do mirroring
06:56:18 <dcoutts> though it's not as simple as rsync
06:56:20 <ksf> what kind of dynamic content? isn't that all generated?
06:56:38 <ksf> that is, nothing needing cgi.
06:56:45 <dcoutts> no, there's lots needing cgi
06:57:00 <dcoutts> some is generated and cached in files
06:57:06 <dcoutts> but others are generated on demand
06:57:20 <yitz> dcoutts: so let's see. you need the packages themselves, metadata about what pkgs & versions exist, the haddock builds... what else?
06:57:36 <SamB_XP_> anyway, anything is better than what we've had :-(
06:57:37 <dcoutts> so you need the lot
06:57:52 <dcoutts> except ability to upload or change data
06:58:04 <dcoutts> but otherwise a fully featured read-only server
06:58:33 <yitz> dcoutts: once you have the lot, you could even accept uploads if it'
06:58:38 <yitz> s a flat peer model
06:58:51 <SamB_XP_> well, then you'd need a protocol for merging the databases ...
06:59:11 <SamB_XP_> and you'd need a much more complicated security model, wouldn't you?
06:59:16 <ksf> thinking about the next-gen p2p network?
06:59:24 <SamB_XP_> oh, that reminds me, we need to think about signing things ...
06:59:52 <SamB_XP_> ... like, I didn't see any signatures listed on the Platform page
07:00:00 <ksf> authors could sign off their tgzs, that would give you some form of identity.
07:00:15 <SamB_XP_> (from google's cache of it, since the actual page was down ;-)
07:00:41 <yitz> SamB_XP_: right, the security model we have now is easy enough to duplicate...
07:00:56 <SamB_XP_> yitz: not much of a model ...
07:01:01 <yitz> exactly
07:01:12 <ksf> http://www.reddit.com/r/programming/comments/9tcn5/the_riaas_favorite_thread_of_all_time_a/
07:01:43 <SamB_XP_> and doesn't it depend on central control of registration at this time ?
07:02:07 <SamB_XP_> with mirrors, wouldn't that be lost ?
07:02:11 <yitz> SamB_XP_: we could openid or something. all this stuff has been done before.
07:02:15 <ksf> that'd be cool.
07:03:05 <SamB_XP_> I didn't think openid was capable of authenticating anything but browser sessions ?
07:03:17 <dcoutts> SamB_XP_: a model with a central upload point and read-only mirrors seems sufficiently practical
07:03:36 <dcoutts> it's not like the central server is offline often
07:03:37 <nha_> hmm hackage is still down?
07:03:42 <SamB_XP_> dcoutts: certainly it would be good enough for handling this situation
07:03:48 <ksf> as a peer, you could say "pull all packages that are signed by that author or the other". in such a way, an official hackage could pull everything from registered authors, without limiting others to distribute their stuff.
07:03:53 <SamB_XP_> ... assuming it goes up again soon ...
07:04:15 <ksf> ...and if SamB_XP_ wants to mirror all of dcoutts packages, then he can do so.
07:04:21 <SamB_XP_> and anyway, I assume if we had something like this last longer than two days one of the other mirrors could be brought in as master ?
07:04:54 <SamB_XP_> ksf: well, I'd also want the packages they needed :-)
07:05:02 <yitz> SamB_XP_: then you're back to the merge problem.
07:05:42 <SamB_XP_> I think we should go with what dcoutts proposes for now ...
07:06:13 <SamB_XP_> dcoutts: heard anything about the investigation lately ?
07:06:24 <yitz> even that requires changes to cabal to support it fully
07:06:58 <yitz> you need to look for a working mirror, from an internal list that presumably gets updated
07:07:36 <SamB_XP_> yitz: well, presumably even old versions could be made to use a mirror manually
07:07:47 <SamB_XP_> I believe the server URL is configurable somehow?
07:08:01 <SamB_XP_> oh, can someone try http://nun.haskell.org/~SamB/HaskellPlatform-2009.2.0.2-setup.exe.torrent to see if it actually works ?
07:08:20 <ksf> SamB_XP_, that's going to happen automatically, anyway... the idea was to offer any packages present, that is, that you downloaded and installed. additionally, you can then subscribe to other people's pushes.
07:08:52 <dcoutts> SamB_XP_: investigation?
07:09:09 <SamB_XP_> dcoutts: about what happened to the server?
07:09:10 <yitz> SamB_XP_: yeah, remote-repo in .cabal/config
07:09:42 <dcoutts> SamB_XP_: nothing new, the /srv is not responding. IT admin will be in Monday morning US west coast time.
07:10:00 <SamB_XP_> dcolish: okay, so in about two hours?
07:10:03 <SamB_XP_> er. dcoutts
07:10:04 <dcoutts> maybe
07:10:06 <SamB_XP_> sorry dcolish
07:10:09 <yitz> dcoutts: is that some NAS or something?
07:10:27 <dcoutts> yitz: it's /dev/md2, and I'm not sure what that's connected to.
07:10:32 <SamB_XP_> dcoutts: by my calculations, it will be 9:00 AM in the west coast then ...
07:10:38 <dcoutts> SamB_XP_: right
07:11:04 <dcoutts> SamB_XP_: another option with the new server is happs clustering
07:11:10 <ksf> "morning" in IT is approx. 12:00.
07:11:27 <ksf> as there's going to be dinner at 12:30 and that's the latest you should arrive at work.
07:11:32 <SamB_XP_> dcoutts: that doesn't sound like a wise thing on which to depend
07:11:47 <dcoutts> no?
07:11:54 <SamB_XP_> well, how does it work?
07:11:59 <dcoutts> can have multiple happs servers in a cluster and they replicate the state between them
07:12:04 <SamB_XP_> oh
07:12:09 <SamB_XP_> but use different stores?
07:12:27 <SamB_XP_> can they be in far-flung locations efficiently ?
07:12:34 <dcoutts> I'm not sure about that
07:12:42 <dcoutts> the latency would affect state updates
07:12:46 <dcoutts> but not reads
07:12:46 <SamB_XP_> yeah
07:12:56 <ksf> but global state should be quite coarse-grained
07:13:10 <ksf> ie. a new package, not some page that got generated and cached.
07:13:33 <dcoutts> right, updates are just the info required to perform the transation
07:13:42 <yitz> dcoutts: or use existing high-reliability clustering solutions, like rsync.net and the like.
07:13:55 <dcoutts> that doesn't give you the same synchronisation
07:14:09 <SamB_XP_> dcoutts: what does that not give you?
07:14:13 <yitz> if all servers share the same folder?
07:14:27 <SamB_XP_> well, I guess it sucks for peering
07:14:39 <dcoutts> and the servers do not use the filesystem for state
07:14:39 * ksf still favours a true p2p-solution, but happs is definitely going to be easier and faster to roll out
07:15:02 <SamB_XP_> ksf: how is that not p2p?
07:15:09 <dcoutts> rsync is fine for mirroring passive repositories
07:15:14 <SamB_XP_> it sounds like it's just not sufficiently distributed
07:15:23 <ksf> multiple servers isn't p2p. it's server2server2clients
07:15:24 <SamB_XP_> dcoutts: anyway, we could have some of each ...
07:15:31 <SamB_XP_> peers *and* passive mirrors
07:16:00 <SamB_XP_> ksf: oh, that
07:16:16 <SamB_XP_> ksf: from the servers POV, it's P2P ;-P
07:16:25 <SamB_XP_> the mirroring, I mean, not the whole shebang
07:16:40 <yitz> first step probably be what dcoutts first suggested - simple read-only mirroring of the data, and then just copy the code that renders the pages and serves cabal.
07:16:50 <yitz> should
07:17:04 <SamB_XP_> and set some "allow_upload" config option to "no", yes :-)
07:17:30 <yitz> SamB_XP_: that could be set by ripping out the code
07:17:36 <Zao> How hard would it be to let cabal-install scale to multiple servers?
07:17:38 <ksf> hackage.haskell.org could distribute between the mirrors, and then some special domain could be used for the real master server that you can push to.
07:17:59 <ksf> "the domain" or "the dns" could distribute, that is.
07:18:08 <SamB_XP_> ksf: that's called you mean master.hackage.haskell.org?
07:18:17 <SamB_XP_> s/that's called //
07:18:18 <yitz> ksf: pull would be easier to implement
07:18:19 <ksf> something like that, yes.
07:18:30 <fasta> Why do you all want centralized single point of failure systems?
07:18:31 <ksf> push as in push packages.
07:18:35 <ksf> ...as a user.
07:18:38 <jystic1> does anyone know where I can get the sources for MaybeT 0.1.2 so I can build it myself?
07:18:41 <yitz> oh
07:18:45 <SamB_XP_> I was going to say "that's called monk.haskell.org", but realized that was just an implementation detail ...
07:18:56 <yitz> fasta: we don't. but it's easier to implement as a first step.
07:19:14 <SamB_XP_> fasta: at this point, we're just trying to make the central failure mode a bit less annoying
07:19:20 <yitz> jystic1: nowhere, until hackage comes back up. :(
07:19:23 <fasta> Well, if everyone just installs Freenet, writing a Freenet client shouldn't be _that_ hard.
07:19:31 <jystic1> that's unlucky :(
07:19:41 <fasta> Installing Freenet is a matter of 5 minutes these days.
07:19:43 <Kagami`> fasta: but freenet is too slow
07:19:43 <ksf> we definitely need a darknet-capable onion-routing p2p-network, soon, we might need to go underground.
07:19:54 <Raevel> jystic1: www.ecmascript.se/MaybeT-0.1.2.tar.gz
07:19:58 <fasta> I don't run it myself, currently, but when I tested it recently, it is fast enough.
07:20:01 <burp> lol
07:20:12 <SamB_XP_> fasta: we don't want wait for years until someone gets around to making a security model before getting some basic mirroring up ...
07:20:20 <burp> haskell needs to go underground?
07:20:21 <Botje> in case it gets too popular
07:20:23 <jystic1> Raevel: thanks, although I get a 403 forbidden
07:20:27 <burp> horrible java bloat
07:20:39 <Raevel> jystic1: oh, one minute
07:20:43 <burp> nothing more freenet/i2p are :P
07:20:44 <fasta> SamB_XP_: Imho, all the complicated work has already been done.
07:20:56 <Raevel> jystic1: there
07:21:09 <fasta> SamB_XP_: it is just boring software-engineering work to make it work.
07:21:15 <SamB_XP_> fasta: we still need some better way of authenticating packages than "it's on hackage.haskell.org" ...
07:21:21 <jystic1> Raevel: got it! thanks!
07:21:27 <fasta> SamB_XP_: that's built-in to Freenet.
07:21:28 <ksf> SamB_XP_, pgp
07:21:33 <SamB_XP_> and that could involve a great deal of bikeshedding
07:21:39 <ksf> sign them with your key, done.
07:21:58 <fasta> Yes, pgp, or the Freenet stuff, it doesn't really matter what you use.
07:22:06 <fasta> Both use the same algorithms.
07:22:29 <SamB_XP_> ksf: well, how is the downloader going to know that your key was trusted ?
07:22:33 <fasta> But you don't have to solve the hosting problem anymore, and there is no communication problem.
07:22:43 <burp> freenet itself is a problem
07:22:55 <fasta> burp: how so?
07:23:00 <burp> you need it running
07:23:06 <ksf> SamB_XP_, he might happen to trust main hackage, and hackage.haskell.org will only offer stuff from trusted keys.
07:23:08 <EvilTerran> and peers
07:23:10 <burp> bloated java client
07:23:13 <SamB_XP_> fasta: how are you going to store the package index, anyway ?
07:23:34 <burp> I don't want to run freenet all the time to get haskell packages
07:23:36 <fasta> SamB_XP_: every client creates their own index.
07:23:42 <SamB_XP_> ksf: well, that's all well and good, but none of it's implemented!
07:23:45 <burp> and that with a speed of 1kb/s
07:23:59 <SamB_XP_> fasta: where does it find the data to make it from?
07:24:10 <fasta> SamB_XP_: it can be published on FMS.
07:24:12 <ksf> SamB_XP_, sure. but do I win the bikeshed competition or am I right?
07:24:27 <fasta> SamB_XP_: just like warez are being published right now.
07:24:30 <SamB_XP_> ksf: you've no code!
07:24:44 <jmcarthur_work> burp, wait, you get your haskell packages from freenet?
07:24:58 <jmcarthur_work> burp, or are you just speaking hypothetically?
07:24:58 <burp> jmcarthur_work: o0, no, why?
07:25:01 <fasta> 1KB/s is non-sense.
07:25:01 <burp> yes
07:25:18 <jmcarthur_work> freenet goes very slow until you have been connected for a good while
07:25:25 <burp> jmcarthur_work: that's what I mean
07:25:27 <fasta> It is much faster these days. You should be able to get max upload/10 easily.
07:25:28 <ksf> er no you can have supernodes that cache dht info and indices for others.
07:25:46 <burp> my max upload if 40kb/s so that will be 4kb/s? ;)
07:25:52 <ksf> ...that is, give some pointers to people looking for peers and stuff. you don't really have to trust the supernode.
07:25:54 <jmcarthur_work> i tried it for a while because i like the principle, but then i got scared about the possibility of child porn getting on my machine
07:26:06 <fasta> burp: you can also lower the security settings and go a lot faster.
07:26:14 <burp> jmcarthur_work: same, though noone can tell it's a bad "feeling" about it
07:27:06 <burp> well it's still java, right? ;)
07:27:19 <fasta> You can keep an index of child porn keys and delete those from your stores, if you want.
07:27:31 <fasta> There is I think even software which does that.
07:27:40 <fasta> Of course, you cannot look at the content ;)
07:27:44 <SamB_XP_> fasta: how would you keep that index up to date ?
07:27:47 <fasta> At least, in most countries.
07:28:00 <fasta> SamB_XP_: you would have to trust some people.
07:28:05 <jmcarthur_work> fasta, oh there are blacklists readily available?
07:28:07 <SamB_XP_> presumably it is not illegal to look at child porn by accident ?
07:28:16 * ksf doesn't think involuntary mirroring is the way to go.
07:28:17 <fasta> SamB_XP_: I suppose authorities could do that.
07:28:24 <burp> I'd more look at some cabal + bittorrent distribution combination
07:28:28 <jmcarthur_work> SamB_XP_, possession is illegal, and caching counts as possession :(
07:28:45 <fasta> SamB_XP_: but really, it is kind of a stupid system. They cannot check what you store anyway.
07:29:06 <SamB_XP_> jmcarthur: presumably they can't get you if you're making a best-effort attempt to avoid keeping it around ...
07:29:17 <ksf> never send people data they don't want. just entice them to share what they have.
07:29:18 <SamB_XP_> that is, avoid it period ...
07:29:32 <ksf> e.g. by hosting a hoogle on localhost.
07:29:49 <jmcarthur_work> SamB_XP_, rationality kind of takes the backburner when a case is about child porn
07:29:50 <EvilTerran> jmcarthur_work, I've heard it claimed that (at least under british law) creating a copy of illegal data (say, images or whatever) counts the same as making it in the first place. which sounds a bit daft.
07:30:02 <SamB_XP_> EvilTerran: indeed
07:30:08 <SamB_XP_> it can't actually count the same
07:30:08 <jmcarthur_work> EvilTerran, that sounds a bit more extreme than here
07:30:21 <fasta> Child porn only exists to make laws to kill my freedom.
07:30:24 <SamB_XP_> because you can't get those counts for child molestation etc.
07:31:04 <EvilTerran> "illegal information" is a really shaky concept
07:31:10 <fasta> EvilTerran: agreed.
07:31:10 <SamB_XP_> yeah
07:31:31 <FunctorSalad> anyone upped the hackage tarball yet? ;)
07:31:53 <pumpkin> eventually someone on the west coast at galois will wake up and fix it
07:32:04 <SamB_XP_> hopefully, eventually the entire supreme court will have technically "possesed" child porn ...
07:32:35 <SamB_XP_> at least, under the present interpretation
07:32:37 <fasta> If you run algorithm X over the DNA of judge J, you get child porn image xyafd.png
07:32:43 <EvilTerran> SamB_XP_, does it count as posession if the wifi signals pass through you? :P
07:32:49 <SamB_XP_> EvilTerran: no!
07:32:54 <FunctorSalad>  /nick 4ChanPartyVan
07:33:05 <ksf> that's obviously bodily contact with a minor.
07:33:13 <ksf> they're going to cut off your balls for that
07:33:23 <SamB_XP_> EvilTerran: did you mean through your body, or through your wifi node ?
07:34:05 <ksf> all those sick cyberpedophiliac perverts...
07:34:27 <jmcarthur_work> i am of a similar opinion
07:34:30 <EvilTerran> SamB_XP_, i meant bodily; hence the :P, it wasn't meant to be srs
07:34:41 <SamB_XP_> you know, I doubt cybersex == intercourse in any jurisdiction ...
07:34:43 <EvilTerran> (the internet: srs bsns)
07:34:49 <pumpkin> -blah ?
07:34:59 <SamB_XP_> or we could get back on topic ...
07:35:18 <SamB_XP_> dcoutts: so, can we make this happen?
07:35:26 <ksf> welcome to the internets, where the men are trolls, the women are men and little girls are fbi agents.
07:35:36 <SamB_XP_> JaffaCake: can you get MSR to set up a hackage mirror?
07:35:37 <dcoutts> SamB_XP_: what exactly?
07:35:44 <FunctorSalad> Generating and compiling a zillion numerical type aliases, this might take a while
07:35:46 <SamB_XP_> dcoutts: the simple read-only mirroring
07:35:56 <SamB_XP_> with or without dynamic content
07:36:00 <dcoutts> SamB_XP_: sure we can make it happen, it's just effort.
07:36:11 <pumpkin> so darcs.haskell.org is down too?
07:36:19 <ksf> as is hackage.
07:36:20 <SamB_XP_> pumpkin: they are both monk
07:36:23 <dcoutts> pumpkin: same machine, same file system
07:36:42 <FunctorSalad> you can get some stuff via ssh from the /srv/code dir ;)
07:36:43 <SamB_XP_> ksf: that was what the "too" was refering to
07:36:49 <FunctorSalad> but not everything :(
07:36:54 <SamB_XP_> FunctorSalad: hmm?
07:36:56 <ksf> oh, he did.
07:36:59 <dcoutts> FunctorSalad: when I tried ls /srv the ls process hung :-)
07:37:09 <SamB_XP_> you mean some of it is there?
07:37:30 <ksf> it might be wise to warn the channel that I already started to drink wine...
07:37:36 <FunctorSalad> dcoutts: I mean on nun
07:37:38 <SamB_XP_> did anyone try http://nun.haskell.org/~SamB/HaskellPlatform-2009.2.0.2-setup.exe.torrent to see if it actually works ?
07:37:46 <dcoutts> FunctorSalad: oh, code.haskell.org
07:38:00 <FunctorSalad> dcoutts: yes, just a vanilla community account
07:38:11 <dcoutts> FunctorSalad: that machine is fine
07:38:20 <SamB_XP_> yeah, it's fine
07:38:34 <SamB_XP_> (though it lacks a bittorrent client for some reason ...)
07:38:44 <ksf> SamB_XP_, works
07:38:46 <burp> SamB_XP_: it does
07:39:03 <ksf> and that's _fast_ for a single peer
07:39:15 <burp> but it's not loading from the webseed links
07:39:19 <SamB_XP_> ksf: you're probably getting it off nun
07:39:24 <SamB_XP_> burp: oh?
07:39:29 <ksf> yep.
07:39:41 <burp> strange
07:39:50 <ksf> ...and I'm upping to someone in germany.
07:39:54 <burp> don't know, wget works
07:39:57 <burp> ksf: probably me
07:39:57 <ksf> ...with 40kib/s
07:41:25 <SamB_XP_> anyway, if anyone had a copy of the Haskell Platform installer for Windows before, please check to make sure this one is the same ;-)
07:41:33 <SamB_XP_> just in case it got infected somehow
07:43:08 <SamB_XP_> and if any windows users come by looking for the Platform, you can give 'em that URL
07:47:21 <HairyDude> what's the paper people usually cite about functional dependencies?
07:48:07 <jystic1> does anyone know how i can get darcs to give me a list of the tags in a repo? i'm trying to get the sources for HStringTemplate-0.4.3 from http://code.haskell.org/HStringTemplate/
07:49:40 <skorpan> > sum [1..36]
07:49:42 <SamB_XP_> Thanks for helping me start the swarm for http://nun.haskell.org/~SamB/HaskellPlatform-2009.2.0.2-setup.exe.torrent
07:49:42 <lambdabot>   666
07:49:47 <skorpan> :O !!!!!!!!
07:51:28 * SamB_XP_ leaves for school now
07:55:20 <Warrigal> > 36 * 37 / 2
07:55:33 <lambdabot>   666.0
07:55:33 <skorpan> clever
07:55:58 <pumpkin> THE DEVIL INHABITS WARRIGAL
07:56:10 <Warrigal> Yeah, he does. Sorry.
07:56:20 <Saizan_> jystic1: darcs show --help, iirc
07:56:56 <burp> little gauss formula ;)
07:59:32 <jystic1> Saizan: thanks, damn, looks like 0.4.3 isn't tagged :) this should be fun
07:59:41 <skorpan> > (round . (!!5)) [ n^2 * (n^2 +1) / 2 | n <- [1..] ]
07:59:42 <lambdabot>   666
07:59:47 <skorpan> !!!!!?????
08:00:11 <ksf> > [ n^2 * (n^2 +1) / 2 | n <- [1..] ]
08:00:12 <lambdabot>   [1.0,10.0,45.0,136.0,325.0,666.0,1225.0,2080.0,3321.0,5050.0,7381.0,10440.0...
08:00:48 <burp> @oeis 1 10 45 136 325 666 1225 2080 3321 5050
08:01:03 <lambdabot> Plugin `oeis' failed with: thread killed
08:01:10 <burp> @oeis 1,10,45,136,325,666,1225,2080,3321,5050
08:01:21 <burp> oeis down? :>
08:01:26 <lambdabot> Plugin `oeis' failed with: thread killed
08:01:27 <mux> > [ n * (n + 1) `div` 2 | m <- [1..], let n = m^2 ]
08:01:28 <lambdabot>   [1,10,45,136,325,666,1225,2080,3321,5050,7381,10440,14365,19306,25425,32896...
08:01:59 <ksf> yep. it's global internet outage week.
08:02:10 <ksf> even archive.org was down yesterday.
08:02:28 <ksf> next ones should be google and amazon.
08:02:51 <ksf> in the end, xkcd will be the last one standing.
08:02:56 <fasta> When is the military going to deplpo Skynet?
08:02:58 <fasta> deploy*
08:03:17 <zygoloid> fasta: they already have. this is how it begins
08:03:36 <zygoloid> oeis isn't down... it's learning
08:04:22 <fasta> It's kind of interesting that the only way to invent a friendly AI is to invent a friendly society.
08:04:49 <Vanadium> ksf: much like cockroaches after a nuclear winter?
08:04:55 <yairchu_> I can't understand why hackage is broken, wasn't the bailout supposed to prevent this?
08:05:28 <ksf> Vanadium, more like a 6yo ignigting ants with a lens
08:06:08 <gwern> fasta: why would you need a friendly society?
08:06:16 <zygoloid> > map (sum . enumFromTo 1 . join (*) . product . enumFromTo 1) [1..] !! 2
08:06:17 <lambdabot>   666
08:06:24 <gwern> you need a friendly team, or a friendly creator - maybe
08:06:35 <gwern> (after all, an african-american can still make white paper)
08:07:05 <fasta> gwern: it's not that you need a friendly society, just that you know a utility function which describes desirable behaviour.
08:07:22 <fasta> Optimising for amount of money for example doesn't work.
08:07:27 <ksf> the most important thing is to isolate it from the internet. nothing that had contact to the internet can be friendly.
08:07:52 <gwern> fasta: so having a friendly society proves the possibility of coming up with the right utility function
08:08:04 * gwern thinks that is a much weaker assertion than fasta's original :)
08:08:27 <JoePeck> I am trying to use "reads" to read an (Eq a, Show a, Read a), I know of an existing Concrete type that would work, but I can't then cast the concrete type to a generic type to satisfy the type description.  Any pointers?
08:08:31 <fasta> gwern: you talk about existence, I talked about construction.
08:08:31 <skorpan> > let p n = if n <= 2 then 1 else p (n - 2) + p (n - 3) in p 24
08:08:32 <lambdabot>   616
08:08:41 <Warrigal> Grr. The Group Health Cooperative needs to go away.
08:09:00 <roconnor_> JoePeck: you shouldn't need to use casts to use reads
08:09:02 <JoePeck> "I can't" meaning, I haven't found a way
08:09:16 <JoePeck> roconnor_: reads doesn't seem to pick up the Concrete type
08:09:16 <Beelsebob> @let n p = p
08:09:17 <lambdabot>  Defined.
08:09:21 <Beelsebob> \o/
08:09:23 <Beelsebob> solved it
08:09:28 <medfly> Beelsebob wins
08:09:37 <gwern> fasta: eh. as I said, you don't need to be black to make white paper
08:09:39 <roconnor_> JoePeck: can you perhaps paste some details?
08:09:41 <Warrigal> > p == n p
08:09:42 <lambdabot>   Ambiguous occurrence `n'
08:09:42 <lambdabot>  It could refer to either `L.n', defined at <local...
08:09:44 <JoePeck> roconnor_: sure
08:09:55 <Warrigal> Sorry, the question's still ambiguous. :-P
08:09:56 <gwern> * black->black or white->white
08:09:57 <skorpan> > fac 5
08:09:58 <lambdabot>   Not in scope: `fac'
08:09:59 <Beelsebob> @check p == n p
08:10:00 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
08:10:01 <skorpan> > factorial 5
08:10:02 <lambdabot>   Not in scope: `factorial'
08:10:16 <Beelsebob> @check \p -> p == n p
08:10:17 <lambdabot>   Couldn't match expected type `a -> a'
08:10:19 <Saizan_> gwern: he said you need to _invent_ a friendly society, not that you need to be in one or have one available
08:10:22 <Beelsebob> bah
08:10:30 <gwern> Saizan_: I still don'
08:10:32 <gwern> t follow
08:10:47 <gwern> an AI is smaller than a society; shouldn't it be easier to make?
08:10:47 <skorpan> > let fac 0 = 1; fac n = n * fac (n - 1) in round ((fac 2)^2 + (fac 3)^2 + (fac 4)^2)
08:10:48 <lambdabot>   616
08:11:09 <skorpan> > L.fac
08:11:10 <lambdabot>   Not in scope: `L.fac'
08:11:15 <medfly> "make a society"
08:11:17 * medfly giggles
08:11:21 <zygoloid> @check let n p = p  in  \p -> p == n p
08:11:22 <lambdabot>   "OK, passed 500 tests."
08:11:23 <fasta> gwern: capitalism is based on a simple society utility function. For an AI you don't want to insert capitalism.
08:11:25 <skorpan> is there really no built-in factorial function in lambdabot?
08:11:25 * Warrigal installs GHC, thereby quadrupling his disk space usage.
08:11:35 <sproingie> societies need unit tests
08:11:37 <gwern> skorpan: why on earth would there be?
08:12:05 <zygoloid> make: *** No rule to make target `society'. Stop.
08:12:15 <gwern> fasta: good thing we don't have capitalism
08:12:23 <skorpan> i don't know, i was thinking that lambdabot provided some MissingH-like functions that you could access somehow
08:12:28 <zygoloid> capitalism turns society into Society
08:12:35 <Fallen_Demon> !quit
08:12:39 <fasta> gwern: well, capitalism + some laws.
08:12:40 <medfly> someone really missed my joke...
08:12:42 <sproingie> still no hackage i see
08:12:48 <Fallen_Demon> lol, well, I tried
08:13:08 <roconnor_> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
08:13:08 <fasta> Some people would argue just capitalism ;)
08:13:09 <gwern> skorpan: all that would do is irritate people who find something workign in lb but not in their actual code
08:13:11 <Warrigal> zygoloid: see, and that's why capitalism is constructive!
08:13:38 <JoePeck> roconnor_: http://pastie.textmate.org/private/pvcnj4oerf3kkzpzhp2gpw
08:13:50 <Fallen_Demon> Anyway, need some help with graph data structures, anyone able to tell me a good vertex:edge ratio for a sparse and dense graph?
08:13:52 <JoePeck> roconnor_: I tried to simply it (obviously)
08:13:58 <Saizan_> gwern: well, we've things defined, and we import non-standard libraries in L.hs
08:14:05 <skorpan> gwern: we wouldn't tell newbies about it and it would be qualified as LB.whatever
08:14:13 <nothingmuch> is hackage.haskell.org down?
08:14:16 <skorpan> yes nothingmuch
08:14:17 <gwern> skorpan: can't use qualified names
08:14:18 <Saizan_> yes
08:14:30 <Saizan_> gwern: we can use qualified names
08:14:32 <gwern> skorpan: that's actually why I had to cut down on imports because of name clashes
08:14:39 <Fallen_Demon> No one? :(
08:15:14 <Saizan_> though i don't see a need for fac :)
08:15:18 <fasta> Fallen_Demon: that depends on a gazillion factors.
08:15:26 <skorpan> well, fac, primes, padovan, things like that
08:15:32 <gwern> padovan?
08:15:41 <skorpan> yeah, like fib but cooler
08:15:43 <Saizan_> > M.fromList [(1,2),(3,4)]
08:15:44 <fasta> Fallen_Demon: "real programmers" would write a data structure that would use a different one for every hardware configuration.
08:15:45 <lambdabot>   fromList [(1,2),(3,4)]
08:15:48 <sproingie> like a jedi but not yet
08:15:53 <skorpan> p n = if n <= 2 then 1 else p (n - 2) + p (n - 3)
08:15:55 <roconnor_> JoePeck: firstly, you probably don't want to put class constraints in your data type declairation.  It doesn't really do what you'd think it would do, and it is almost always useless.
08:15:55 <Fallen_Demon> I just need to choose whether to use adjacency lists or matrices for prim's and kruskel's
08:16:06 <zygoloid> JoePeck: what error do you get?
08:16:15 <JoePeck> roconnor_: okay, I'll try removing them
08:16:21 <nothingmuch> oi
08:16:21 <ksf> > 3 * ap ((*) . ord . head) length (snd (splitAt 1 "ooo"))
08:16:22 <lambdabot>   666
08:16:24 <nothingmuch> http://bifunctor.homelinux.net/~roel/hackage/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz # 404
08:16:24 <fasta> Fallen_Demon: well, that is easy, that depends on the amount of hardware you have available.
08:16:30 <Fallen_Demon> on the floy, I mean, fasta
08:16:30 <nothingmuch> oh well, i guess I will have to wait
08:16:32 <roconnor_> JoePeck: second, I think you want to say "... SExpr a = Name a deriving (Eq, Show, Read)
08:16:33 <Fallen_Demon> fly*
08:16:34 <JoePeck> zygoloid: I don't get an error, the first returns [("x", "")] as I would expect the second returns []
08:16:35 <skorpan> ksf: hail to the king
08:16:39 <Fallen_Demon> Fat fingerss, I swear -_-
08:16:44 <fasta> Fallen_Demon: ?
08:17:12 <Warrigal> Vertex:edge ratio for a sparse graph: 1:(640320^3 + 743 - e^(pi*sqrt(163))). Vertex:edge ratio for a dense graph: 1:G_64.
08:17:14 <Fallen_Demon> I need to look at the number of edges and the number of vertices and pick which one to use
08:17:37 <fasta> Warrigal: haha
08:17:38 <JoePeck> roconnor_: well, this is a very small corner of an assignment
08:17:40 <sproingie> use both, see which one is better for you
08:17:48 <JoePeck> roconnor_: where I'm overriding Show and Read to be much nicer
08:17:51 <Fallen_Demon> Warrigal, I hate you :P
08:17:57 <Warrigal> :-P
08:18:09 <fasta> Warrigal: I love you already.
08:18:21 <roconnor_> JoePeck: do you need to override Show and Read for SExpr as well?
08:18:32 <Warrigal> > 640320^3 + 744 - exp(pi*sqrt(163))
08:18:34 <lambdabot>   480.0
08:18:39 <Warrigal> > 640320^3 + 744 - exp(pi*sqrt(163)) :: CReal
08:18:41 <lambdabot>   0.0000000000007499274028018143111206461437
08:18:43 <JoePeck> roconnor_: yes, Symbol is just so that showing a string won't have quotes around it
08:18:51 <Warrigal> See, rounding error can lead to slight inaccuracies.
08:19:00 <JoePeck> roconnor_: the real issue is show and read for the SExpr (simplified here)
08:19:03 <roconnor_> JoePeck: in that case you will need to write your own Read/Show instances for SExpr
08:19:18 <roconnor_> you should define them so that
08:19:26 <Fallen_Demon> This is why I prefer #haskell to #java. You guys aren't a bunch of script kiddies :)
08:19:36 <Fallen_Demon> !quit
08:19:37 <roconnor_> instance (Read a) => Read (SExpr a) where ...
08:19:47 <FunctorSalad> Warrigal: that number is freaky... I heard there's actually some explanation to it in terms of more abstract math
08:19:47 <roconnor_> instance (Show a) => Show (SExpr a) where ...
08:19:57 <Warrigal> FunctorSalad: yeah, there is.
08:19:58 <JoePeck> roconnor_: yes, I have Show working, and for Read I just have this catch
08:19:58 <FunctorSalad> but don't know more about it
08:20:06 <Warrigal> And I have no idea what that explanation is.
08:20:14 <sproingie> Fallen_Demon: i can pls to have tell how put variable in jsp?
08:20:18 <zygoloid> JoePeck: are you sure that readSExpr2 is being used for SExpr Symbol? how are you testing it? ghci?
08:20:39 <roconnor_> JoePeck: oh wait
08:20:42 <JoePeck> zygoloid: hmm, that is a good question, I am just testing with: (reads "x")
08:20:50 <zygoloid> JoePeck: in ghci?
08:20:54 <roconnor_> JoePeck: I think I misunderstood what you were doing in the paste
08:21:05 <JoePeck> I mean, (readsSExpr2 "x") =)
08:21:10 * roconnor_ takes another look
08:21:14 <JoePeck> zygoloid: yes
08:21:18 <zygoloid> JoePeck: then it's defaulting to ReadS (SExpr ()), which is why you get no results.
08:21:39 <JoePeck> zygoloid: hmm, the input is a String to readsSExpr
08:21:57 <roconnor_> ah
08:22:00 <roconnor_> listen to zygoloid
08:22:02 <JoePeck> why does it assume a void type given the constraints I gave it?
08:22:02 <roconnor_> :)
08:22:22 <zygoloid> JoePeck: ghci doesn't know what type 'a' is. all it knows is (Eq a, Show a, Read a)
08:22:22 <Fallen_Demon> sproingie, lol :)
08:22:24 <JoePeck> this is certainly a breakthrough
08:22:44 <zygoloid> JoePeck: it uses defaulting rules to pick a = ()
08:22:47 <JoePeck> so I could provide a concrete type in the definition?
08:22:58 <zygoloid> JoePeck: yeah. that should work
08:23:09 <JoePeck> I was getting errors trying that for Show and so I never thought about trying it for Read!
08:23:20 <zygoloid> JoePeck: or you could say readsSExpr2 "x" :: [(SExpr Symbol, String)] iirc
08:23:21 <JoePeck> oh wait
08:23:47 <JoePeck> zygoloid: well, that gets it to be essentially the same as readsSExpr1
08:23:48 <therp> is there some GHC switch that allows me to kill the typechecking phase? My experiment aims to replace data types with function which makes the function's type signature recursive, which isn't understood by haskell.
08:24:00 <zygoloid> but once you start using this in a program, type inference will nail a to be 'SExpr Symbol' and it'll work fine :)
08:24:09 <pumpkin> therp: nope, it's a central part of everything
08:24:13 <JoePeck> now what about when I take the next step and actually make an "instance of Read (SExpr a)"
08:24:17 <ksf> a) no b) do it like agda c) just use a data type to pass the occurs check
08:24:31 <pumpkin> therp: functionality can be determined by the types, so if you turned it off you may not have defined behavior in your program
08:24:42 <JoePeck> zygoloid: let me show what I mean
08:24:59 <therp> pumpkin: hmm.. true. how about haskell minus the class system?
08:25:13 <pumpkin> that'd be a pretty hard bit to take out :)
08:25:14 <ksf> > (\x -> x x) (\x -> x x)
08:25:15 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
08:25:17 <therp> pumpkin: that should give me functionality not depending on types, right?
08:25:38 <ksf> see there's at least half a reason why such insane types aren't allowed without slight hacking.
08:26:09 <therp> pumpkin: yeah true. I'm not suggesting to do that. It's just that I want to verify my intuition that classes are the problematic part wrt that idea
08:26:21 <pumpkin> therp: at least with h98, I think so
08:27:18 <kw317> what is the flag to run GHC with the code generator?
08:27:26 <ksf> hmm newtypes work for occurs cycle breaking, don't they?
08:27:40 <therp> is there anything functional without a type system | with a type system that allows me to write recursive types?
08:27:44 <ksf> -fasm/fvia-c
08:27:56 <therp> ksf: yes
08:28:08 <JoePeck> zygoloid: okay, I tried somethings, but still no dice
08:28:09 <JoePeck> zygoloid: http://pastie.textmate.org/private/0ogu78fnuwr9su4qx3orq
08:28:14 <lispy1> therp: sorry, what is your question?
08:28:25 <therp> ksf: http://r6.ca/blog/20060919T084800Z.html
08:28:32 <lispy1> therp: anything functional with a type system that allows you to write recursive types?  Sounds like Haskell
08:28:38 <ksf> therp, not in haskell, no. haskell does the occurs check to make it a bit harder to blow away one's own foot.
08:29:29 <therp> lispy1: well, Haskell only has iso-recursive types and they are implicit with data types and case analysis..
08:29:52 <therp> (I hope that I do not confuse iso and equiv-recursive types again, where is my TAPL copy?)
08:30:06 <JoePeck> hmm, seemed to drop for a second
08:30:27 <JoePeck> zygoloid: so, I can do "instance Read (SExpr Symbol) where readsPrec _ s = readsSExpr1 s" but I seem to fail with that
08:30:43 * ksf leaves the discussion before sirtakimorphisms come up
08:31:00 <therp> ksf: that's the problem I have with Haskell's approach to type checking. If it doesn't type check, you can't code it (without unsafePerformIO).
08:31:10 <zygoloid> JoePeck: what's the actual problem you're seeing? what's failing?
08:31:18 <lispy> therp: okay.  I'm ignorant about the differences between recursion types.
08:31:37 <JoePeck> what declaration of "instance of Read" do you want me to try with?
08:31:55 <ksf> therp, maybe some clever typeclass hacking that includes undecidableInstances works
08:32:05 <FunctorSalad> therp: do you mean the difference between "newtype Fix f = Fix (f (Fix f))" and (the illegal) "type Fix f = f (Fix f)"?
08:32:18 <JoePeck> zygoloid: I seem to get the following error => http://pastie.textmate.org/660705.txt?key=l1w9kf6qujs0mdqbp1q
08:32:23 <zygoloid> JoePeck: well, the one in your paste looks reasonable except that you're missing a 'Read a' context from readsSExpr2 and the instance Read (SExpr a)
08:34:37 <JoePeck> zygoloid: with the type constraints I get the same error
08:35:00 <zygoloid> JoePeck: can you paste the full code you're trying and the error?
08:35:05 <JoePeck> I guess I can make multiple instances
08:35:06 <JoePeck> sure
08:35:17 <therp> lispy: are you familiar with terms like μX.(Integer,X)? that could be the "type" of an infinite list of integers
08:35:41 <therp> FunctorSalad: I think so, yes. the latter would require equiv recursive types I guess
08:35:53 <lispy> therp: no I'm sorry, that is unfamiliar
08:36:18 <kw317> ksf: that's not what I'm looking for
08:36:21 <FunctorSalad> therp: I thought there was some decidability reason to forbid the "type" variant, but I don't know what it is :(
08:36:24 <lispy> therp: but, the  idea seems simple.  The fixed point of that expression is an infinite recursive tuple
08:36:34 <kw317> ksf: I'm interested in the Cmm to native code NCG pipeline
08:36:49 <therp> lispy: this term represents a type (name it X for now), that is a tuple of an Integer and another item of type X. you get a recursive and "infinitely long" definition of X
08:36:52 <zygoloid> therp: newtype Integers = I (Integer, Integers)
08:37:19 <therp> FunctorSalad: equiv recursive type checkers have termination problem iirc from TAPL
08:38:11 <JoePeck> zygoloid: this on its own is sufficient for my problem => http://pastie.textmate.org/private/fbisvcnhqftehrwynfcg
08:38:18 <therp> lispy: yes the idea is simple, and haskell can do that, but you have to tell the type checker where to think of X as μX.(Integer,X) and where to think of it as (Integer,μX.(Integer,X)) which is the one-step expansion
08:38:26 <JoePeck> which is basically what I pasted last time, just with the type constraints
08:39:11 <therp> lispy: likewisely where the type checker has to think of (Integer,μX.(Integer,X)) as μX.(Integer,X), one-step expansion backwards. we do that implicitly everyday with using case for unpacking a data type, and a constructor for packing a data type
08:39:33 <FunctorSalad> so do you want to get rid of the pack/unpacking just for brevity or something else?
08:40:02 <therp> lispy: that's the reason why recursive types only work with data and newtype in haskell, because the expansion/rollback is built into constructors and the destructor "case" (TAPL uses the term fold/unfold.. or was it roll/unroll?)
08:40:04 <FunctorSalad> (it can be cluttery indeed)
08:40:19 <therp> FunctorSalad: no, I'm just explaining what iso recursive means,
08:40:31 <JoePeck> zygoloid: the goal would be for reads "x" :: SExpr Symbol to produce (Name (Symbol "x"))
08:40:45 <therp> FunctorSalad: my problem was that I wanted to write something recursive without a data type, but haskell can't do that.
08:41:00 <therp> FunctorSalad: "something recursive in the type system" that is
08:42:07 <lispy> therp: thanks, that's interesting
08:42:13 <zygoloid> JoePeck: that code works for me
08:42:19 <therp> lispy: you are welcome :)
08:42:23 <JoePeck> seriously!
08:42:27 <JoePeck> which version of GHCI?
08:42:35 <zygoloid> seriously. is it possible that ghci is using an old version of the code?
08:43:07 <Saizan_> equi-recursive types get you too close to the untyped lambda calculus :)
08:43:17 <JoePeck> I'm using ghc-6.8.3 and its throwing that error
08:43:20 <zygoloid> in ghci i get a 'No instance for (Show (SExpr Symbol))' but that's what you'd expect
08:43:35 <JoePeck> well, I'm not using Show in this example
08:43:43 <JoePeck> arg, it expects show?
08:43:44 <zygoloid> no, but ghci is when it tries to print the result
08:43:53 <JoePeck> hhh, I get it
08:43:56 <JoePeck> ahhh
08:44:28 <zygoloid> JoePeck: nonetheless, that error message should not correspond to that code. either ghci isn't using that version of the code or there's a ghc bug
08:44:40 <JoePeck> zygoloid: okay, adding "Show" to the deriving list for SExpr didn't quicksolve the problem
08:45:19 <zygoloid> have you done a :r in ghci since you changed the code?
08:45:37 <JoePeck> ahh, yah I edited my real file instead of the test file
08:45:38 <poucet> hi
08:45:41 <JoePeck> (sorry, my mistake)
08:45:44 <JoePeck> zygoloid: thanks for your help!
08:45:45 <poucet> hi
08:45:51 <JoePeck> roconnor_: thanks as well
08:46:04 <zygoloid> JoePeck: no problem.
08:47:47 <therp> where do I have to beg for listing on planet.haskell.org? I feel motivated to share my insight about iso-recursive types in haskell. however mails to planet@community.haskell.org are not answered :/
08:50:23 <JoePeck> zygoloid: its working perfectly now
08:50:30 <roconnor_> therp: according to the FAQ it may take a while to get a response
08:50:51 <JoePeck> so my mistake was I was looking to cast it Inside, but I should have been casting on the outside (and then inference draws from that)
08:51:38 <roconnor_> The Planet is administered currently by Antti-Juhani Kaijanaho and Don Stewart.
08:53:28 <guerrilla> could someone help me with my typeclass issue.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10915 (short: I'm trying to say that a type is the union of two othr types)
08:53:56 <pumpkin> guerrilla: make a sum of them, but you can't have subtyping
08:54:11 <guerrilla> pumpkin: how do i make a sum of them?
08:54:25 <pumpkin> data Symbol = TerminalSymbol SymbolName | NonterminalSymbol SymbolName
08:54:39 <guerrilla> aha
08:54:43 <pumpkin> now Symbol can be either of those
08:54:54 <guerrilla> okay, that actually does make sense
08:55:25 <pumpkin> you can use record names there too, but I'd suggest a common symbolName function that grabs the name for both constructors
08:55:39 <pumpkin> (the record naming stuff won't allow that)
08:55:58 <guerrilla> aha, using pattern matching
08:56:02 <pumpkin> yep
08:56:17 <roconnor_> pumpkin: I think the recond naming stuff will allow that.
08:56:21 <pumpkin> really?
08:56:27 <roconnor_> I'm not sure
08:56:29 <pumpkin> maybe I'm mistaken then
08:56:30 <roconnor_> but I think so
08:56:32 <guerrilla> hmm, ill try it just in case
08:56:33 <guerrilla> 1sec
08:56:34 <pumpkin> I vaguely remember trying it a while ago
08:56:45 <roconnor_> still, I don't think it is a good idea
08:57:25 <guerrilla> odd
08:57:28 <guerrilla> seems to work
08:57:34 <pumpkin> ah, I was wrong then :)
08:57:37 <guerrilla> wonder how it magically figures that out ;)
08:57:50 <roconnor_> ya 3.15 from the haskell 98 report
08:57:59 <roconnor_>   data S = S1 { x :: Int } | S2 { x :: Int }   -- OK
08:58:00 <roconnor_>   data T = T1 { y :: Int } | T2 { y :: Bool }  -- BAD
08:58:16 <roconnor_> I still think it is a bad idea to use fields for sum types
08:58:25 <guerrilla> i agree
08:58:47 <roconnor_> though in this case it might not be so terrible ...
08:58:53 <roconnor_> anyhow
08:59:17 * roconnor_ tries not to worry too much about the colour of the bikeshed
08:59:32 <pumpkin> it should definitely be purple with green polka dots
08:59:52 <guerrilla> is there any reason that the following modification (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10916) would be bad form?
08:59:58 <raim0_> where can I download haskell platform?
08:59:59 <guerrilla> (aside from verbosity)
09:00:13 <pumpkin> guerrilla: as it stands, ye
09:00:15 <pumpkin> s
09:00:25 <pumpkin> guerrilla: you wouldn't be able to have a list containing both of those, for example
09:00:30 <pumpkin> since they have a different type
09:00:37 <pumpkin> you could get around it with an existential wrapper
09:00:39 <therp> roconnor_: "take a while" > 2 months?
09:00:49 <pumpkin> then you'd effectively be simulating the OO way of doing things
09:01:09 <guerrilla> hmm
09:01:10 <guerrilla> ok
09:01:10 <fasta> What's the right way to convert a CDouble to a Double again?
09:01:46 <roconnor_> therp: they said weeks, though I'd say 2 months is pushing it.
09:01:49 <pumpkin> guerrilla: so you wouldn't be able to make [TerminalSymbol x, NonterminalSymbol y] because they have different types (and you can't make a list of [(Symbol a) => a] easily)
09:01:55 <roconnor_> therp: The Planet is administered currently by Antti-Juhani Kaijanaho and Don Stewart.
09:02:02 <pumpkin> fasta: realToFloat I think
09:02:07 <pumpkin> :t realToFloat
09:02:07 <lambdabot> Not in scope: `realToFloat'
09:02:11 <guerrilla> pumpkin: yeah, i see what you mean
09:02:13 <guerrilla> hmm
09:02:16 <roconnor_> therp: you may want to contect one of them directly if it has been more than 2 months
09:02:18 <pumpkin> whoops
09:02:24 <zygoloid> :t realToFrac
09:02:26 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
09:02:28 <pumpkin> that's the one!
09:02:29 <pumpkin> :P
09:02:58 <guerrilla> pumpkin: yeah, i see what you mean, from this example: http://www.angelfire.com/tx4/cus/shapes/haskell.html
09:03:24 <guerrilla> very ugly imperativeness
09:03:28 <guerrilla> (imo)
09:03:30 <pumpkin> guerrilla: yeah, that's basically it :)
09:03:38 <pumpkin> guerrilla: there is one advantage to the existential form
09:03:45 <pumpkin> it's extensible after the fact
09:04:01 <pumpkin> whereas with the sum type, you need to define all elements of your sum up front
09:04:01 <guerrilla> right
09:04:25 <zygoloid> yay for the expression problem
09:04:38 <pumpkin> :)
09:04:54 <guerrilla> yeah, but not the worst problem to have though.
09:05:04 <pumpkin> everyone has it, anyway
09:05:11 <roconnor_> guerrilla: you may wish to read "data types a la carte"
09:05:34 <guerrilla> pumpkin: one more question- slightly related. is there a way to limit data types? for example, what if I want a ranged integer type? would i have to redefine all the operations to be bounded?
09:05:39 <guerrilla> roconnor_: thanks, ill get that now
09:05:45 <pumpkin> guerrilla: unfortunately not
09:05:57 <pumpkin> guerrilla: beyond the obvious inherent limits
09:06:05 <pumpkin> such as nonnegativity or smaller  than some power of 2
09:06:37 <pumpkin> unless you want to move to type-level numbers
09:07:31 <ski> (pumpkin : itym s/=>/*>/)
09:07:53 <pumpkin> hm?
09:08:17 <ski> (presumably you didn't really mean `[(Symbol a) => a]')
09:08:31 <pumpkin> why not?
09:08:41 <pumpkin> I don't know what *> is :)
09:08:59 <ski> assuming this is about "heterogenous collections"
09:09:36 <pumpkin> yep
09:09:47 <pumpkin> I left out the forall cause I didn't want it :P
09:09:47 <therp> roconnor_: tried that already :( at least with dons. will try antii-juhani
09:09:48 <ski> then `[forall a. Symbol a => a]', would be a list of values where the user may choose any type `a' for each element, provided `Symbol a' holds
09:10:01 <pumpkin> yeah, I'd want exists a. Symbol a => a
09:10:08 <pumpkin> but that syntax doesn't exist
09:10:36 <ski> while `[exists a. Symbol a *> a]' would be a list of values where constructer of that list has chosen a type `a' for each element, such that `Symbol a' holds
09:10:47 <pumpkin> ah, I've never seen *> before
09:10:51 <guerrilla> ski: that exists in haskell?
09:11:11 <ski> pumpkin : i've invented the symbol, just to elaborate on this distinction
09:11:12 <pumpkin> guerrilla: not in h98 definitely :)
09:11:15 <pumpkin> ah
09:11:36 <ski> `exists a. Symbol a => a' would be a value of some type `a', where the user should provide `Symbol a'
09:11:37 <guerrilla> hmmm
09:11:42 <sproingie> it's weird we have something called "existential types" but not an actual existential operator
09:11:58 <ski> (and since the user doesn't know what `a' is, how can the user sensible do that ?)
09:12:05 <sproingie> which is kind of absurd and existentialist now that i think about it :)
09:12:34 <guerrilla> ski: putting your "heterogenous collections" phrase came up with quite a nice one in google: http://homepages.cwi.nl/~ralf/HList/
09:12:47 <ski> and finally `forall a. Symbol a *> a' would be a value that for any type `a' the user chooses, it gives you a value of that type *and* an instance of `Symbol a'
09:12:47 <pumpkin> yeah, it's also on ahckage
09:12:50 <pumpkin> pity hackage is dead
09:13:08 <guerrilla> yeah, whats up with that... isn't it morning time in the US yet? ;)
09:13:10 <ski> pumpkin : so the point is that there's four possible combinations
09:14:05 <ski> pumpkin : in the dictionary-passing translation, `Symbol a => F a' corresponds to a function that, given a dictionary for `Symbol a', produces a value of type `F a'
09:14:34 <ski> pumpkin : while `Symbol a *> F a' corresponds to a pair of a dictionary for `Symbol a' and a value of type `F a'
09:15:42 <zygoloid> ski: sounds like => is a forall and *> is an exists?
09:16:11 <ski> so e.g. `foo :: forall a. Foo a => F a -> exists b. Bar a b *> G a b' would be a function that given any type `a', provided `Foo a' holds, and given a value of type `F a', will produce some (hidden type) `b', such that `Bar a b' holds, and returning a value of type `G a b'
09:16:13 <roconnor_> zygoloid: that is a proper analogy
09:16:51 <ski> zygoloid : `=>' is more like an implication / function-arrow, while `*>' is like a conjunction / pair-type-constructor
09:16:54 <roconnor_> forall : => : implication :: exists : *> : conjunction
09:17:57 <zygoloid> 'exists a. Symbol a => a' seems to make no sense though. it would mean, for some known-in-advance-but-unspecified type 'a', a function from a dictionary for 'Symbol a' to a value of type 'a'
09:18:02 <zygoloid> that dictionary cannot be created
09:18:10 <ski> the difference being mostly that `x => y' as well as `x *> y' are types if `x' is a constraint and `y' is a type
09:18:30 <sproingie> zygoloid: if followed up by something that specified that 'a' then it would make sense
09:18:38 <sproingie> type classes are halfway there
09:18:40 <ski> zygoloid : "makes no sense" /= "not useful"
09:18:42 <zygoloid> sproingie: that wouldn't be exists s. though?
09:18:53 <zygoloid> *a
09:20:05 <pumpkin> ski: I see
09:21:36 <guerrilla> thanks all for the help. looks like i have some more reading to do for now :)
09:24:02 <sproingie> zygoloid: eh.  i'm a little lost at this point.  i really only know universal/existential quantifiers from logic, using ∃ there is an assertion
09:24:28 * zygoloid ponders: data Foo a where Symbol a => Bar a; f :: (exists a. Symbol a => Foo a) -> Int; f (Var v) = runSymbol v
09:24:31 <ddarius> sproingie: And what's a proof of such an assertion?
09:26:20 <guerrilla> are there logs of this channel availible on the web?
09:26:24 <sproingie> ddarius: same as any other logical proposition, based on axioms, e.g. square of opposition
09:26:43 <zygoloid> if you have "exists a. Symbol a => F a", it seems to me that the Symbol a instance has got to be either universal (instance Symbol a where ...) or come from the value of type "F a"
09:27:36 <pumpkin> guerrilla: yep, the topic has a link
09:27:40 <ski> (pumpkin : clarification. i'm not sure if `*>' will ever be added to haskell .. but it seems to me to be worthwhile to maintain the distinction, when discussing "unwrapped existentials", which bundle up a constraint)
09:27:52 <pumpkin> ski: you should make a proposal for it!
09:27:57 <guerrilla> pumpkin: hah, yeah, im blind
09:28:04 <ddarius> sproingie: Oigh.
09:28:08 <pumpkin> ski: but yep
09:28:39 <ski> pumpkin : i just proposed to you to use (the concept) `*>' when discussing "unwrapped existentials", did i not = :)
09:28:43 <ddarius> sproingie: Look up the Heyting interpretation of logic.
09:28:48 <pumpkin> lol
09:28:48 <ski> s/=/?/
09:28:58 <pumpkin> but I have no power
09:29:24 <sproingie> i think i slept through the part of the class that covered intuitionist logic :-/
09:29:31 <ddarius> sproingie: http://en.wikipedia.org/wiki/Brouwer%E2%80%93Heyting%E2%80%93Kolmogorov_interpretation
09:29:45 <ski> (otoh, a proposal for adding `*>' .. i haven't even pondered what might be a useful coherent system with it .. the example above was wishful thinking :)
09:30:54 <ski> zygoloid : you can't examine the value of type `F a' before the constraint is provided, since the former may depend on the latter
09:32:32 <sproingie> ddarius: ah that looks useful.  i was wondering where the _|_ notation came from
09:33:14 <pumpkin> that disjunction construct is a dependent sum, right?
09:33:44 <ski> sproingie : the `_|_' used when discussing computations that doesn't return a value come from domain theory
09:34:27 <ski> pumpkin : you can think of it as `exists b :: Bool. if b then p else q', yes
09:37:04 <pumpkin> how does one go from (((x -> _|_) -> _|_) -> _|_) to (x -> _|_) ?
09:37:49 <Saizan_> ?djinn (((x -> Void) -> Void) -> Void)
09:37:50 <lambdabot> -- f cannot be realized.
09:37:57 <Saizan_> ?djinn (((x -> Void) -> Void) -> Void) -> (x -> Void)
09:37:58 <lambdabot> f a b = void (a (\ c -> c b))
09:38:17 <pumpkin> what does the void function do there?
09:38:29 <Saizan_> void :: Void -> a
09:38:34 <pumpkin> ah
09:38:35 <Saizan_> it's like _|_-elim
09:38:44 <pumpkin> I see
09:39:21 <Saizan_> maybe you don't even need it there
09:39:25 <pumpkin> @djinn Not (Not (Not x)) -> Not x
09:39:26 <lambdabot> f a b = void (a (\ c -> c b))
09:39:35 <Saizan_> ?type a b = a $ \c -> c b
09:39:37 <lambdabot> parse error on input `='
09:39:41 <Saizan_> ?type \a b -> a $ \c -> c b
09:39:42 <lambdabot> forall t b t1. (((t -> t1) -> t1) -> b) -> t -> b
09:39:47 <pumpkin> ah
09:39:48 <ddarius> And domain theory got _|_ from lattice theory.
09:39:55 <ddarius> (And the name "bottom")
09:40:15 <Berengal> And lattice theory got it from T (top)?
09:40:50 <sproingie> should have taken logic for math, not philosophy
09:41:14 <Saizan_> pumpkin: btw, that function is join . join for the Cont Void monad
09:41:22 <pumpkin> :o
09:41:25 <sproingie> spent most of the time on formal and rhetorical fallacies.  which are great fun, but it doesn't spend much time on categories
09:41:42 <sproingie> except for a few formal fallacies, like universal conclusion from particular premises
09:42:32 <ddarius> sproingie: I tend to think of logic from a constructive perspective similar to the Heyting interpretation.
09:42:55 <sproingie> yikes, late, gtg
09:42:56 * sproingie &
09:55:32 <zygoloid> ski: i propose taking a fixed point :)
09:59:51 <I7uoHeoka> i need a help. i'm russian. i can win iPod nano 8GB if you help me. please register and upload photo -> http://vk.com/reg1051946 . 14 users need. (sorry, my english is very bad)
10:00:05 <PeakerWork> any ops?
10:00:11 <PeakerWork> ah no need
10:00:14 <skorpan> no hold on a sec
10:00:18 <skorpan> i think this guy is legit
10:00:25 <PeakerWork> hah ;-)
10:00:28 <skorpan> also, check this cool link out http://vk.com/reg1053846
10:01:09 <PeakerWork> is that a phishing network or what?
10:01:28 <skorpan> i have no idea
10:01:42 <skorpan> isn't it ironic how the spam gets to freenode of all places?
10:01:50 <skorpan> none of the other networks i frequent have this problem
10:03:05 <PeakerWork> is freenode bigger?
10:03:35 <skorpan> probably not bigger than quakenet, but bigger than efnet
10:04:44 <PeakerWork> quakenet?
10:05:18 <skorpan> quakenet is one of the biggest irc networks in the world
10:08:29 <zygoloid> bigger than dalnet?
10:08:50 <skorpan> dalnet is practically dead nowadays
10:09:43 <PeakerWork> did dalnet "invent" the nickserv/etc stuff?
10:10:09 <sproingie> is #haskell set to require nickserv registration?
10:10:56 <skorpan> quakenet have their own custom nick/channel authorization stuff, "Q"
10:11:23 <skorpan> and yes i think dalnet invented *serv
10:11:35 <Twey> sproingie: No
10:12:07 <sproingie> probably should.  tends to cut down on the spam.
10:13:09 <kynky> so does +ik :)
10:14:31 <skorpan> and +m
10:15:08 <kynky> +s
10:15:18 <Twey> sproingie: Also cuts down on the users :þ
10:17:13 <yrlnry> Yikes.  Icelandic spileys.
10:19:43 <shapr> Good morning #haskell!
10:19:43 <lambdabot> shapr: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:19:43 <shapr> whoa
10:19:52 <shapr> @seen ivanm
10:19:53 <lambdabot> Unknown command, try @list
10:19:55 <shapr> wargh
10:20:06 <c_wraith> preflex: seen ivanm
10:20:06 <preflex>  ivanm was last seen on #haskell 4 hours, 39 minutes and 1 second ago, saying: yeah
10:20:25 <a_guest> what has happened to hackage.haskell.org??
10:20:33 <shapr> Is it down?
10:20:42 <c_wraith> hackage has been down over 24 hours, now
10:20:48 <a_guest> for me, hackage.haskell.org, is down
10:21:03 <a_guest> it was so yesterday also
10:21:30 <shapr> looks down
10:21:44 <a_guest> get it up
10:21:59 <sproingie> get on up
10:22:08 <shapr> and dance!
10:22:13 <skorpan> \o/
10:22:20 <burp> haskell dies
10:22:22 <sproingie> \\o
10:22:24 <sproingie> o//
10:22:48 <shapr> Isn't this the part where someone says they'll become rich and famous once they invent a device to stab people in the face through the internet?
10:23:14 <skorpan> it is
10:23:17 <MyCatVerbs> shapr: No.
10:23:23 <a_guest> I can't read the api doc because of hackage down
10:23:42 <MyCatVerbs> The person who invents a device to stab people in the face over the internet will be imprisoned, or more likely shot by the secret services.
10:23:51 <sproingie> or stabbed in the face
10:24:01 <poucet> By his own device
10:24:02 <skorpan> shanked i believe
10:24:05 <skorpan> no, stabbe
10:24:05 <skorpan> d
10:24:07 <MyCatVerbs> sproingie: Ooh, ironic death! <3
10:24:11 <a_guest> and also you off-topianians.
10:24:21 <MyCatVerbs> The person who invents a device for protection against the device for stabbing people in the face over the internet, however, will become very rich indeed.
10:24:22 <sproingie> stay on topian
10:24:23 <poucet> off-topians you mean
10:24:37 <sproingie> ooh stay on top
10:24:40 <skorpan> this channel isn't iso-topic...
10:24:48 <shapr> Anyway.... what's up with Hackage?
10:24:58 <sproingie> it won't go
10:25:00 <sproingie> make it go
10:25:01 <tommd> Down. People are working on it.  Be happy its existed these past years.
10:25:02 <shapr> ookay
10:25:15 <shapr> tommd, I'm not complaining :-)
10:25:21 <shapr> Just curious... maybe I could help!
10:25:27 <tommd> @quote ARM
10:25:28 <lambdabot> foot says: On a warm Saturday afternoon, sitting by the pool with a margarita, you casually sit up from your chaise lounge chair, reach over and pick up a gun, aim at your foot, and lazily pull the
10:25:28 <lambdabot> trigger.
10:25:34 <tommd> no, not that one
10:25:38 <tommd> @quote hackage
10:25:39 <lambdabot> dons says: [on whether a library is wanted] *yes* put it on Hackage!
10:25:41 <tommd> @quote hackage
10:25:42 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
10:25:48 <tommd> @quote tommd
10:25:48 <lambdabot> No quotes match. Do you think like you type?
10:25:49 <poucet> @quota vincenz
10:25:50 <lambdabot> vincenz says: perhaps you assume the existence of 4?
10:25:57 <tommd> @quote TomMD
10:25:58 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
10:26:01 <tommd> that one.
10:26:07 <poucet> @quota vincenz
10:26:08 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
10:26:26 <tommd> If we only moved to ARM... then a distributed system would have been needed... then these down times would be less likely.  Makes perfect sense.
10:26:33 <shapr> umm
10:26:45 <shapr> Anyway...
10:26:51 <shapr> Backup servers would make sense.
10:27:10 <tommd> Well sure, if you want to take the easy road.
10:27:20 <shapr> In general, I do like the easy road.
10:30:22 <gOcOOl> can someone point me to some good explanation oh what is head normal form, tried googling for it and the links it returns, wikipedia entry etc is a little too abstract for my understanding at this point
10:30:26 <dons> ?yow
10:30:27 <lambdabot> Couldn't find fortune file
10:30:28 <gOcOOl> *of
10:30:36 <dons> Heinlein is fscking the disks on hackage
10:30:37 <poucet> dons: you coming to the hackathon in zurich?
10:30:42 <dons> poucet: indeed!!
10:30:48 <poucet> Splendid :)
10:31:18 <MyCatVerbs> gOcOOl: "weak head normal form" is when an expression is evaluated up to the outermost constructor.
10:31:35 <shapr> howdy dons!
10:31:45 <MyCatVerbs> gOcOOl: take for example. data List a = Cons a (List a) | Nil
10:31:59 <shapr> poucet, long time no see! Weren't you vincenz before?
10:32:17 <poucet> shapr: I killed vincenz.
10:32:21 <shapr> aww
10:32:59 <MyCatVerbs> gOcOOl: if you evaluate a given list to WHNF, then you will have reached as far in as either: (Nil) or (Cons _ _), where I'm using "_" to represent something that you haven't evaluated yet.
10:33:34 <gOcOOl> MyCatVerbs: outermost constructor being the very first one?
10:33:57 <Cale> gOcOOl: Head normal form means that the top level of the expression is neither reducible, nor a lambda with a reducible body.
10:34:03 <MyCatVerbs> gOcOOl: Yes. Like in the expression (Cons (Just 5) Nil), I mean the Cons there, because it's outside all of the others.
10:34:26 <Cale> (As opposed to weak head normal form, where every lambda is automatically in weak head normal form)
10:34:59 <gOcOOl> MyCatVerbs: ah ok, but in your previous example Nil and Cons are the only 2 constrcutors right
10:35:00 <gOcOOl> ?
10:35:03 <MyCatVerbs> Yep.
10:35:07 <MyCatVerbs> So, to give an example of what Cale just said...
10:35:13 <poucet> shapr: I just thought it was time to unify on something that actually relates to me :)
10:35:22 <shapr> poucet, makes sense... still the same job?
10:35:26 <poucet> indeed
10:35:29 <poucet> Keeping GMail turning :)
10:35:29 <codm`> Hey, so is hackage lost?  Was hoping a server just needed to be rebooted on Monday morning.  But still no hackage, and nothing on haskell.org explaining the situation.
10:35:39 <Cale> That is, (\x -> 6 + 7) is in weak head normal form, but not in head normal form
10:36:01 <Cale> (\x -> 13) is in head normal form
10:36:03 <MyCatVerbs> Cale: ah, thanks. Was going to say something, but got mixed up for a moment there. :)
10:36:30 <FunctorSalad> lambdas are opaque in haskell though so you can't reduce under them
10:36:53 <gOcOOl> ok, what makes (\x -> 6 + 7) in WHNF but (\x -> 13) in HNF?
10:36:53 <PeakerWork> the compiler could
10:36:58 <shapr> codm`, dons just said one of the admins (heinlein) is fscking the disk(s).
10:37:03 <shapr> codm`, So I think it'll be online soon.
10:37:14 <MyCatVerbs> gOcOOl: (6+7) is reducible. (13) isn't.
10:37:26 <codm`> shapr:  Great!  Any plans to allow easy mirroring?
10:37:26 <gOcOOl> got it, makes much more sense now
10:37:31 <Cale> Yeah, "real world" implementations of lambda calculus tend to lose the property that they can easily look under lambdas, in order to make it easy to compile things.
10:37:36 <MyCatVerbs> gOcOOl: as in, there are more steps to take from (6+7) before you reach a value. (13) is already at a value. :)
10:38:21 <shapr> codm`, Dunno about that, ask dons who would know?
10:38:23 <mercury^> Doesn't a term need to be an application outermost to be eligible for "not HNF"?
10:38:28 <shapr> codm`, I agree though, mirrors would be handy!
10:38:55 <jfoutz> is there a good way to define something like this "newtype (Num a) => X a = X {getX :: a}" but ensure a is always positive?
10:39:08 <FunctorSalad> does RNF have a specific meaning too or is it just made up for NFData?
10:39:10 <Cale> mercury^: Nope, that's the difference between HNF and WHNF. Some lambdas are also HNF
10:39:14 <codm`> I could probably set up a mirror at Stanford, as long as it isn't crazy bandwidth hungry.
10:39:16 <Cale> er
10:39:22 <Cale> Some lambdas are *not* HNF
10:39:47 <Cale> For a more pure example, consider...
10:40:14 <Cale> (\x -> (\y -> y y) x)
10:40:50 <Cale> The body of that lambda is immediately reducible to x x
10:41:06 <Cale> So it's not in HNF
10:41:17 <Cale> But it's in WHNF simply because it's a lambda
10:41:31 <mercury^> Ok, so a lambda is in HNF iff its body is, but always in WHNF.
10:41:46 <Cale> right
10:42:59 <Cale> Head Normal Form <theory, reduction> (HNF) A term describing a lambda expression whose top level is either a variable, a data value, a built-in function applied to too few arguments, or a lambda abstraction whose body is not reducible. I.e. the top level is neither a redex nor a lambda abstraction with a reducible body.
10:43:23 <Cale> An expression in HNF may contain redexes in argument postions whereas a normal form may not.
10:43:43 <Cale> Weak Head Normal Form <reduction, lambda calculus> (WHNF) A lambda expression is in weak head normal form (WHNF) if it is a head normal form (HNF) or any lambda abstraction. I.e. the top level is not a redex.
10:44:23 <gOcOOl> what is a 'redex'?
10:44:29 <Cale> reducible expression
10:44:37 <gOcOOl> ah ok ;)
10:50:05 <FcoX> hi, I have a newbie question, I am doing a small parser with parsec, i can parse one expresion, but I don't know how to parse many
10:50:45 <Cale> okay
10:50:47 <Vanadium> call it over and over!
10:51:00 <pumpkin> this is a really cool talk: http://www.vimeo.com/6590617
10:51:02 <Cale> There's also the functions many and many1
10:51:10 <FcoX> but I don't now how much of the input was consumed
10:51:18 <Cale> pumpkin: Yeah, it is :)
10:51:28 <yrlnry> Is there more than one way to make [] into a Monad?
10:51:58 <Cale> yrlnry: Wouldn't surprise me. One way is more natural than all the others though.
10:52:17 <pumpkin> there are definitely two easy ways to make it into an applicative
10:52:40 <Cale> There are at least two ways to turn infinite streams into a monad
10:52:49 <Cale> er, hmm...
10:52:52 <mercury^> Just processing the first element (or none) should work?
10:52:58 <mercury^> So that it's basically Maybe.
10:53:46 <Cale> well, you have to be careful that  x >>= return = x
10:53:48 <pumpkin> I didn't realize Piponi was English
10:54:19 <shapr> I thought he was British?
10:54:20 <yrlnry> yeah, I was going to say that a lot of things are ruled out by the requirement tha tfmap id == id.
10:54:25 <FcoX> wow! many worked! It was sooo obvious! thx!
10:54:25 <paolino> any news on hackage ?
10:54:32 <shapr> paolino, disks are fscking
10:54:33 <pumpkin> paolino: "they're working on it"
10:54:42 <Cale> FcoX: no problem :)
10:54:44 <FcoX> (hackage is down? oh! I was blaming my ISP!!)
10:55:00 <paolino> shapr: what happened ?
10:55:13 <shapr> paolino, No clue I'm just relaying what dons said.
10:55:45 <yrlnry> British implies English.
10:55:48 <roconnor_> http://bifunctor.homelinux.net/~roel/hackage/packages/hackage.html
10:55:52 <yrlnry> Soeey, menat that the other way aorund.
10:55:53 <pumpkin> English implies British
10:55:53 <pumpkin> :)
10:55:59 <yrlnry> Yes, just so.
10:56:25 <paolino> roconnor: no packages there (at least the one I need)
10:56:38 <Cale> yrlnry: Yeah, also our hands are much more tied in Haskell in that parametric polymorphism is actually a much stronger condition than natural transformation
10:56:56 <yrlnry> How so?
10:59:01 <Cale> Well, in defining a parametrically polymorphic function, you give a single definition which must operate in precisely the same way at each type.
11:00:59 <Cale> In defining a natural transformation F -> G, you define FX -> GX separately for each object X in such a way that for any f: A -> B, using Ff: FA -> FB and then taking the natural transformation FB -> GB is the same as taking the natural transformation FA -> GA, and then Gf: GA -> GB
11:01:55 <lament> Cale: does that correspond to parametric polymorphism in some easily expressible fashion?
11:02:07 <yrlnry> Okay, I think I see.  Thanks.
11:02:18 <FunctorSalad> the NT condition makes it pretty rigid too, maybe it's even equivalent (no idea)
11:02:21 <Cale> Well, parametrically polymorphic functions will certainly be natural transformations, but maybe not the other way around.
11:02:34 <yrlnry> You could in principle have a NT that was not computable.
11:02:39 <yrlnry> (For example.)
11:02:47 <FunctorSalad> yrlnry: but we're in Hask here
11:02:54 <lament> what's a natural transformation not expressible as parametric polymorphism?
11:03:36 <yrlnry> FunctorSalad:  so?  Just because the arrows are computable functions does not mean that that all natural transformations that map objects to arrows are necessarily computable.
11:03:52 <yrlnry> Oh, but wait.  all the objects are finite sets.
11:03:55 <yrlnry> So n/m.
11:04:23 <FunctorSalad> finite?
11:04:23 <Cale> they are?
11:04:28 <yrlnry> Hmm, I don't know.
11:04:32 <FunctorSalad> they're types
11:04:39 <Cale> Many Haskell types have infinitely many values in them :)
11:04:45 <yrlnry> Oh, they're not necessarily finite.  That was silly.
11:04:51 <Cale> (even just counting the computable ones :)
11:04:55 <yrlnry> And irrelevant.
11:04:55 <FunctorSalad> types do have a finite description
11:05:25 <yrlnry> I'm going back to my original claim that there's  no reason in principle why an NT need be computable.
11:06:02 <FunctorSalad> not in principle, no
11:06:30 <lament> so what's an example of a NT in Hask that's not parametric polymorphism?
11:06:40 <Cale> lament: Good question.
11:06:47 <Cale> It would be nice to have a concrete example.
11:07:52 <FunctorSalad> let's write down the naturality condition? Functor f, Functor g, n :: forall x. f x -> g x, naturality: forall u : x -> y, fmap u . n = n . fmap u
11:08:47 <Cale> Er...
11:09:16 <Cale> It's more like for each x we have n_x : f x -> g x
11:09:41 <Cale> and then forall u: x -> y,  fmap u . n_x = n_y . fmap u
11:09:58 <FunctorSalad> didn't I write that? :)
11:10:21 <FunctorSalad> well assuming a hypothetical haskell where an n of that type can be defined at each type indivdually
11:10:24 <Cale> Well, I don't know, maybe it should be  n :: pi x. f x -> g x ?
11:10:28 <Cale> yeah
11:11:09 <mux> gosh, pi types. this is about when my brain starts melting
11:13:40 <FunctorSalad> so the question would be whether such a function would always be haskell-definable...
11:14:29 <FunctorSalad> no idea :|
11:17:13 <Cale> It really feels like there ought to be exotic natural transformations which aren't just parametrically polymorphic, but perhaps there are enough naturality squares to nail things down.
11:17:34 <Cale> But I don't really see how to prove it.
11:18:15 <FunctorSalad> I find it hard to tell what is nailed down, because of the fmaps
11:19:09 <Cale> There are also lots of functors which we can't write.
11:19:09 <mercury^> http://rohanlean.de/pub/Incompleteness.pdf -- unfinished, but I thought this was a good point to ask for some feedback.
11:19:37 <Cale> and that's less disputable :)
11:20:07 <FunctorSalad> oh didn't even consider which functors we are allowing
11:21:03 <Cale> don't abuse the fact that $ has the wrong associativity ;)
11:21:31 <Cale> FunctorSalad: Right, from category theory's perspective, there are a lot more than we're used to considering
11:23:04 <Cale> mercury^: I'd consider writing  extract $ head $ filter (proves n) theorems  as  extract . head . filter (proves n) $ theorems
11:23:29 <Cale> (but that's a rather boring comment ;)
11:23:54 <FunctorSalad> there are too many type-level integers on hackage
11:24:02 <pumpkin> FunctorSalad: I agree
11:24:07 <FunctorSalad> I can't choose
11:24:16 <FunctorSalad> tfp, type-level, type-int, ?
11:24:28 <pumpkin> just roll your own!
11:24:35 <Berengal> FunctorSalad, the solution is simple: Write your own (then upload it to hackage so others don't face your problem)
11:24:47 <FunctorSalad> Berengal: nice one :D
11:24:47 <pumpkin> :P
11:26:18 <FunctorSalad> GADTs are quite amazing really... they're like dependent types except without allowing value-level stuff inside
11:26:49 <FunctorSalad> for example you can express the predicate "x is a tower of Maybes over b"
11:26:57 <FunctorSalad> (x,b types)
11:27:26 <FunctorSalad> or quite generally, inductively defined sets of types
11:27:56 <Berengal> Indeed. GADTs are awesome if you're working on the type level
11:28:00 <Berengal> I need to do more of that...
11:28:44 <FunctorSalad> (inductive like typeclasses, but you have more control)
11:28:57 <FunctorSalad> and it's closed-world, you can do case analysis
11:30:08 <en0th> is this (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4437#a4437) a good way to refactor this (http://haskelldsp.sourceforge.net/Matrix/Simplex.hs) ?
11:31:13 <Berengal> The only trouble with GADTs is functions with type :: exists a. Something -> SomeGADT a
11:32:43 <FunctorSalad> Berengal: trouble as in 'can't express that concisely'?
11:32:52 <Berengal> FunctorSalad, it's bothersome
11:33:33 <FunctorSalad> do you really mean 'exists'?
11:33:39 <Berengal> I want the "exists" keyword (and first-class rank-n types, so I can go Maybe (forall a. (Show a) => a)
11:33:43 <FunctorSalad> I'm not sure what that type is supposed to mean
11:33:59 <FunctorSalad> yeah the rank-n-types have bitten me too
11:34:25 <FunctorSalad> but that's probably related to them breaking hindley-milner
11:34:33 <Berengal> exists as opposed to forall
11:34:52 <FunctorSalad> yeah, but do you really mean a top-level exists?
11:34:57 <Berengal> Yeah
11:35:12 <FunctorSalad> oh wait, you don't mean a constructor of that first type
11:35:21 <FunctorSalad> for functions you can just do the translation to forall
11:35:42 <Berengal> It's still bothersome
11:36:29 <Berengal> And HM is overrated. Haskell does a really awesome job of inferring my types already; I can live with having to nudge it along every now and then when I do complicated things
11:36:31 <FunctorSalad> Maybe (forall a. (Show a) => a) -- thought that is legal with PolymorphicComponents
11:36:45 <Berengal> Really?
11:36:55 <FunctorSalad> not sure
11:36:58 * Berengal apparantly doesn't know half the extensions to ghc
11:37:20 <FunctorSalad> Ghci> :set -XPolymorphicComponents
11:37:20 <FunctorSalad> Ghci> :k Maybe (forall a. (Show a) => a)
11:37:20 <FunctorSalad> Maybe (forall a. (Show a) => a) :: *
11:37:33 <FunctorSalad> maybe something breaks later?
11:37:58 <pumpkin> that's allowed?
11:38:30 <monochrom> awesome
11:38:34 <FunctorSalad> :D
11:38:51 <FunctorSalad> but you tend to need annotations for everything with such types
11:40:08 <Berengal> doesn't accept 'foo :: Maybe (forall a. (Show a) => a) -> String'
11:40:23 <FunctorSalad> err wait, the kindchecker is too lax here
11:40:28 <FunctorSalad> you need -XImpredicativeTypes
11:40:48 <Berengal> It does say so, but it doesn't help. I get ambiguous type errors
11:41:05 <FunctorSalad> it accepts this for me: Ghci> let x = undefined :: Maybe (forall a. (Show a) => a)
11:42:18 <Berengal> Perhaps I'm doing soemthing wrong... can you get an implementation of foo above to work?
11:43:02 <Berengal> @paste
11:43:03 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:43:37 <HugoDaniel> hackage anyone ? :D
11:43:56 <HugoDaniel> (maybe if i keep pressuring hackage might start working...)
11:44:07 <Berengal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4438#a4438
11:44:11 <Berengal> HugoDaniel, nope, not yet
11:44:22 <Berengal> FunctorSalad, the last try worked ;)
11:44:45 <FunctorSalad> Berengal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10922#a10922
11:45:37 <FunctorSalad> Berengal: you need to tell it which instance of Show to use
11:45:53 <Berengal> Doesn't seem very useful...
11:45:54 <FunctorSalad> because you're claiming to have a value that's in the intersection of *all* showable types
11:46:09 <FunctorSalad> (which is impossible)
11:46:14 <FunctorSalad> maybe you intended an existential
11:46:24 <Berengal> Indeed I did
11:46:59 <Berengal> Somehow I knew the error was on me...
11:47:35 <FunctorSalad> for example you can extract an Int from it too: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10922#a10922
11:47:35 <gOcOOl> how do I define a function in ghci? typing something like "a = 1" gives me this error: "<interactive>:1:2: parse error on input `='"
11:47:43 <FunctorSalad> wrong paste
11:47:44 <FunctorSalad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10923#a10923
11:47:52 <Jedai> gOcOOl: let f x = x + 1
11:48:33 <Jedai> gOcOOl: basically you're in the IO monad when you code in ghci (except it treats pure expressions like there was an implicit "return")
11:48:35 <gOcOOl> Jedai: ah ok, thanks
11:49:34 <FunctorSalad> Berengal: the inline existential would be "Maybe (forall r. (forall a. Show a => a -> r) -> r)"
11:49:35 <Jedai> gOcOOl: remember that you can use ";" to separate clauses when you can't use layout (like in ghci) so something like "let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)" works
11:50:02 <Berengal> FunctorSalad, I never really got the forall as existential part. Reading up on it now
11:50:33 <gOcOOl> ok, thats definitely handy because i've alwasy wondered how one would go about achieving it
11:50:52 <FunctorSalad> Berengal: you can read the type as the elimination rule for existential quantifiers in plain logic :)
11:51:21 <Berengal> Dammit Jim! I'm a doctor, not a vulcan :P
11:51:22 <FunctorSalad> "if from any Showable a we can prove r, then r"
11:51:37 <FunctorSalad> (<=> exists a. Show a )
11:51:56 <mreh> has anyone got a quick-start script to get Yi working with a gui?
11:52:04 <mreh> can i borrow one?
11:52:22 <Berengal> Ah, so a proof of r could read \_ -> someR?
11:52:30 <Berengal> (With added type signature)
11:52:56 <FunctorSalad> I was reading it in curry howard, so a proof of r would be a value of type r
11:54:06 <Berengal> Indeed, but given any Show, what could a proof of r look like?
11:54:36 <FunctorSalad> r = String, (show :: forall a. Show a -> r)
11:54:44 <FunctorSalad> r = String, (show :: forall a. Show a => a -> r)
11:54:47 <FunctorSalad> (correction)
11:55:21 <FunctorSalad> so foo would be: foo (Just k) = k show
11:55:33 <FunctorSalad> (the foo from before)
11:56:40 <Berengal> Assuming termination, could you prove any Read as well?
11:56:44 * heatsink searches the logs for "hackage" instead of asking
11:56:47 <Berengal> I guess you could
11:56:55 <Berengal> heatsink, nope
11:57:15 <FunctorSalad> k (read . show) ?
11:57:25 <Berengal> Indeed
11:57:51 <FunctorSalad> yeah seems to be accepted
11:57:53 <Berengal> I still don't quite get it :/ Needs more meditation
11:58:35 <Berengal> But back to GADTs, can you write the function foo :: exists a. Something -> SomeGADT a?
11:59:04 <FunctorSalad> you'd encode it in the same way
11:59:17 <Berengal> Assuming data SomeGADT where A :: Something -> SomeGADT Int; B :: Something -> SomeGADT Char
11:59:25 <FunctorSalad> forall r. (forall a. (Something -> SomeGADT a) -> r) -> r
12:00:05 <heatsink> Wow, hackage was a popular subject yesterday.
12:00:26 <sproingie> and today, being down and all
12:01:33 <HugoDaniel> its like michael jackson
12:01:37 <HugoDaniel> being dead and all
12:01:52 <Berengal> FunctorSalad, so you can't write the function foo n | n == 1 = A 1 | otherwise = B n?
12:01:57 <Berengal> Not directly, anyway?
12:03:07 <Berengal> To me it looks like exists a. Int -> SomeGADT a is a valid type for that function
12:03:12 <FunctorSalad> Berengal: for that you'd need the type (Something -> exists a. SomeGADT a)
12:03:25 <FunctorSalad> then the forall-encoding works too
12:03:50 <FunctorSalad> foo n k = if n==1 then k (A 1) else k (B n)
12:04:16 <Berengal> Something -> (forall r. (forall a. SomeGADT a) -> r) -> r?
12:04:21 <FunctorSalad> yeah
12:04:47 <Berengal> The spurious extra argument still seems spurious to me...
12:05:05 <Berengal> But it's starting to make some sense
12:05:11 <FunctorSalad> well it's CPS (funnily I get this particular use of CPS but don't really get CPS in general)
12:05:21 <FunctorSalad> ;)
12:05:34 <Berengal> Heh, I get term-level CPS pretty well (but almost never use it)
12:06:05 <FunctorSalad> Something -> (forall r. (forall a. SomeGADT a -> r) -> r)
12:06:13 <FunctorSalad> (parens corrected)
12:06:28 <FunctorSalad> (matters in this case)
12:06:32 <Berengal> Yeah ...
12:06:46 <Berengal> I knew that, just got confused while writing
12:07:13 <Berengal> Man, mind mildly blown. Thanks
12:07:19 <FunctorSalad> :)
12:08:27 <Berengal> Does this solve the problem with phantom types in all cases?
12:08:52 <mreh> "Could not find module `Yi.UI.Pango'"? Wut - The package is installed and visible
12:09:43 <Berengal> mreh, works for me
12:09:56 <FunctorSalad> Berengal: hmm it just expresses existentials, don't see the relation to phantoms
12:09:59 <raim0_> Rotaerk: is there a mirror for the platform also?
12:10:05 <raim0_> Rotaerk: sorry
12:10:17 <raim0_> roconnor: is there a mirror for the platform also?
12:10:47 <sproingie> we should provide daily torrents of the hackage tarball
12:10:50 <Berengal> FunctorSalad, well, phantoms and GADTs combined, mostly, where you get the problem of returning different constructors of the same "type" but with different phantoms
12:12:02 <Berengal> Without GADTs you could just declare the value to have whatever phantom you wanted in-module, but unless you export the constructors you get the same problem out-of-module
12:12:28 <Berengal> (not to mention the point of phantoms is completely gone by then)
12:12:42 <mreh> oh, maybe I didn't cabal install with the pango flag :D
12:12:51 <Berengal> sproingie, we should provide mirrors. Someone needs to write a haskell Nexus
12:13:18 <sproingie> it'd be nice.  i dont think my dinky little vhost would handle it
12:13:32 <EnglishGent> what is a phantom? I've heard of phantom types before - but I've no idea what they are :|
12:13:36 <sproingie> er vps host
12:14:06 <sproingie> Berengal: i suspect it boils down to "someone should put down the money to do it"
12:14:11 <Berengal> EnglishGent, parameters to type constructors not corresponding to the type of any value in the value constructor
12:14:29 <mreh> surely cabal is smart enough to install only the parts of a package that are missing when you request a reinstall?
12:14:53 <sproingie> reinstall to me suggests the whole package
12:14:54 <dcoutts> mreh: you clearly have a very high opinion of cabal ;-)
12:14:54 <Berengal> mreh, no, it's not. That's what --reinstall is for
12:15:09 <Berengal> (reinstalling the whole package)
12:15:10 <sproingie> it should only grab missing dependencies, yes
12:15:19 <sproingie> the package itself it does from scratch
12:15:35 <Berengal> It only recompiles the package though, not all the dependencies
12:15:48 <vhost-> I heard vhost
12:15:59 <sproingie> sorry i was talking about my vps host :)
12:16:02 <dcoutts> mreh: if you mean, it should only install the profiling bits, if the other bit is already installed, then yes I agree, it should. It's on the long TODO list.
12:16:06 <vhost-> ;)
12:16:07 <Berengal> (very painful if you some day decide to turn on profiling without wanting to wipe all your packages)
12:16:16 <sproingie> vhost-: you must have a hell of a time on #apache :)
12:16:30 <mreh> dcoutts: cool
12:16:48 <Berengal> dcoutts, flags too?
12:16:49 <vhost-> sproingie: on undernet, yeah, I couldn't idle in that channel
12:17:31 <dcoutts> Berengal: what do you mean exactly?
12:17:53 <mreh> dcoutts: it means to empirically test if a module was installed takes ages :,(
12:17:54 <FunctorSalad> still no hackage torrent?
12:17:59 <Berengal> dcoutts, well, in this case mreh didn't install with -fpango, but now wants that bit
12:18:15 <mreh> Berengal -f=pango
12:18:27 * Berengal waves hands
12:18:32 <dcoutts> it's the same
12:18:56 <FunctorSalad> think I will make my own type-level nats after all then ;o
12:19:00 <mreh> lulz
12:19:43 <Berengal> Man, haskell is awesome (even with hackage down)
12:19:47 <dcoutts> Berengal: so for an exe, we don't track if it was installed anyway, so it'll always re-install. For a lib, the flags are not supposed to change the exported API, so it shouldn't matter. For a package containing both, it's less clear.
12:19:55 <mreh> I luurve Haskell
12:20:08 <mreh> @faq will Haskell be my Valentine?
12:20:08 <lambdabot> The answer is: Yes! Haskell can do that.
12:20:11 <sproingie> i have a week-old or so tarball of hackage
12:21:02 <Berengal> dcoutts, "not supposed to" isn't reality, and I'm not entirely sure it's the right thing either, with regards to half-libraries like yi
12:21:25 <Berengal> sproingie, seedplox :P
12:21:25 <sproingie> there's a mirror up on bifunctor.homelinux.net , not sure how fresh
12:21:46 <sproingie> ?
12:21:51 <dcoutts> Berengal: it is supposed to be reality for libs, the dependency resolution algorithm depends on it.
12:21:53 <sinelaw> here they say:  "'supposed to' is the name of a fish."
12:22:03 <dcoutts> Berengal: if people violate that requirement then we give them the finger.
12:22:06 <Berengal> sproingie, that one doesn't have any tarballs
12:22:46 <dcoutts> Berengal: it also does not translate into distro packages, it's a really bad idea.
12:23:11 <dcoutts> Berengal: however for packages with a lib and an exe, yes we should rebuild when the flag affects the exe.
12:23:42 <dcoutts> though we don't actually have enough info to know if it has changed.
12:24:23 <dcoutts> and in general a package can depend on any number of other things, it's never completely clear when you want to re-build
12:24:29 <Berengal> dcoutts, for libraries that's fair enough. For things like yi and xmonad, where some people might not want all the functionality, but those who do wants to access the modules provided when writing configs/mods, I think it's a legitimate use
12:24:57 <Berengal> But for such packages, it might not be an issue anyway
12:25:03 <dcoutts> Berengal: the problem in general is that you cannot depend on such an API because you cannot specify such a dependency.
12:25:10 <English_Gent> bah :|
12:25:42 <dcoutts> Berengal: can't specify "I depend on package foo, but foo built with flag bar"
12:25:58 <Berengal> dcoutts, maven does something like that, but different
12:26:48 <dcoutts> Berengal: you could imagine the ability to specify such deps, however you'd run into two problems. The package dependency resolution problem probably becomes impossible in general and two you would not be able to translate it to distro packages.
12:27:03 <Twey> Is it a peripheral maven?
12:27:04 <tommd> dcoutts: Has anyone proposed an API matcher to enforce versioning on Hackage?  Something that will compare function names / types and decide if the package follows versioning rules.
12:27:34 <bos> tommd: sounds like overengineering.
12:27:38 <dcoutts> tommd: yes, we proposed such a tool as a GSoC project this summer, but it didn't get funded.
12:27:39 <tommd> bos: That's what I do
12:27:46 <bos> heh.
12:27:58 <dcoutts> we think it's an important project
12:27:59 <tommd> dcoutts: Ahh, figured someone already had the thought.
12:28:30 <dcoutts> tommd: if you want to implement it that'd be great :-)
12:28:42 <Berengal> dcoutts, what maven has done is to let one project description describe several artifacts, and let other projects depend on any of those artifacts. It doesn't allow arbitrary permutations of flags, but it does provide some flexibility (like foo and foo-with-bundler-deps, and commonly foo-sources and foo-javadoc)
12:28:43 <dcoutts> the main part is API extraction
12:28:52 <tommd> dcoutts: Courses started up again and killed all my free time.  Did a better job killing the time than I expected.
12:29:10 <pumpkin> tommd: your time should kill them back
12:29:12 <tommd> But I'm always wanting to hack on hackage-server more.
12:29:13 <dcoutts> Berengal: ok, so really those are smaller units upon which you can depend
12:29:19 <sproingie> looks like the snapshot i have is closer to 2 weeks old.  anyway, uploading it now, it'll take the anexoric donkeys that make up my outside net connection some time to get my packets there
12:29:33 <dcoutts> tommd: right, that's probably the higher priority project
12:29:41 <English_Gent> hi pumpkin :)
12:29:41 <Berengal> dcoutts, indeed. It's not arbitrary flags, but they're not individual packages either
12:29:48 <pumpkin> hi English_Gent :)
12:29:56 <dcoutts> Berengal: components of packages
12:30:03 <Berengal> (nor individual projects, which is also possible... several projects using the same source tree)
12:30:35 <dcoutts> Berengal: in Cabal, the package is the unit of distribution and also the unit of dependency.
12:31:56 <dcoutts> which translates quite nicely into distro packages
12:32:04 <Berengal> dcoutts, indeed. In maven, the artifact is the unit of distribution and the unit of dependency, but the pom is the project unit, detailing all dependencies (and all resulting artifacts)
12:32:24 <Berengal> I'm not sure if I'm suggesting adopting that for cabal or not...
12:32:41 <yakov> hello
12:32:51 <Berengal> For some things it might be nice (yi-gtk, yi-vty, yi-pango), but I'm not sure if there's sufficient gain in implementing it
12:32:58 <dcoutts> Berengal: for cabal packages we're comfortable with a "project" consisting of several packages.
12:33:34 <yakov> what is up with hackage?
12:33:36 <Berengal> Yeah, cabal works nicely for haskell the way things are now
12:33:45 <Berengal> yakov, nothing, which is the problem ;)
12:33:58 <yakov> any chance to get package tarballs?
12:34:57 <Berengal> sproingie, uploading where to?
12:35:38 <sproingie> Berengal: my host, where i'll seed it.  probably be another 20 mins before it's ready
12:35:48 <Berengal> sproingie, right
12:38:56 <therp> suggestions on a good paper about Higher-Order Abstract Syntax? The original paper from Pfenning and Elliott is nothing but unreadable to my humble mind.
12:43:38 <poucet> therp: the one by barzilay?
12:43:42 <poucet> therp: it's scheme based, however
12:44:07 <therp> poucet: oh I don't mind scheme, in fact that's an advantage :)
12:44:18 <poucet> let me find it
12:44:29 <poucet> icfp 06
12:44:39 <therp> oh that helps a lot thanks
12:45:01 <poucet> ICFP workshop on scheme and functional programming, eli barzilay
12:45:10 <poucet> "A self-hosting evaluator using HOAS"
12:45:24 <poucet> (2006)
12:45:46 <therp> I guess that's it http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.6819&rep=rep1&type=pdf
12:46:24 <therp> oh that looks nice, thanks for the hint! poucet++ :)
12:47:32 <poucet> :)
12:48:29 <Heffalump> dcoutts: am now..
12:48:42 <HairyDude> is hackage down?
12:48:48 <endojelly> HairyDude, it so is
12:48:59 <dcoutts> Heffalump: I see we're both talking at this functional exchange event :-)
12:49:03 <Heffalump> yep :-)
12:49:16 <tommd> Down with what?  The sickness?
12:49:16 <quuuux> hi #haskell
12:49:23 <endojelly> it's more than just down
12:49:26 <endojelly> it's off the hook!
12:49:42 <dcoutts> Heffalump: took me a while to work out what I wanted to say, I wasn't very clear at first what the audience will be like
12:49:46 <sproingie> okay i am apparently not l33t enough to get how to uses these idiotic torrent clients on linux and just share a file
12:49:55 <dcoutts> Heffalump: I guess I was just wondering if you had any more intuitions
12:49:59 * Heffalump has not much clue either, but I guess business users or wannabee users of FP
12:50:08 <FunctorSalad> hmm you can declare a class infix but can't use infix syntax in 'instance' or contexts?
12:50:14 <sproingie> so is there someone i can just upload the hackage tarball i have who can seed it?
12:50:15 <Heffalump> my abstract is on the website, if that's any help
12:50:26 <HairyDude> anyone feel like putting "hackage is down" in the topic?
12:50:34 <dcoutts> Heffalump: yes it was
12:50:46 <tommd> sproingie: That anxious?
12:51:23 <sproingie> tommd: i figured i'd help out by sharing the semi-stale snapshot i have (2 week old tarball)
12:51:40 <sproingie> i'd not counted on every torrent app for linux doing their best to defeat me
12:52:26 <kynky> rtorrent is very good, works well in screen
12:52:43 <sproingie> yeah til you want to just share a file ex nihilo, no tracker
12:53:12 <sproingie> any and all windows clients, i just drag something into a dir
12:53:12 * SubStack floats about adrift without hackage
12:53:31 <SubStack> terrible timing since I just got my happstack app to work
12:53:40 <kynky> guess hackage needs a mirror
12:53:42 <FunctorSalad> sproingie: maybe you need a seperate tracker? no idea
12:53:51 <SubStack> on dreamhost even!
12:54:01 <SubStack> the happstack app that is, not the mirror
12:54:23 <sproingie> FunctorSalad: perhaps.  how i create one of those, i guess i just have to know already
12:55:34 <silkodyssey> i would like to learn functional programming using haskell. i am considering YAHT and real world haskell.which do you recommend? i would like to learn haskell but more than that i want a solid grounding in functional programming. i have read a bit of learnyouahaskell and played a bit with clojure before.
12:55:34 <FunctorSalad> sproingie: don't know :-(
12:56:12 <monochrom> silkodyssey: Both. And more. Anything you can get your hands on.
12:56:32 <SubStack> second @ both
12:56:50 <kynky> yaht rwh and haskell wiki book , do all 3 (haskell wiki book, got yaht there too)
12:56:51 <SubStack> the haskell subreddit got me hooked on it
12:56:51 <monochrom> The 5th reading material is the one that makes you click. Independent of order or choice.
12:57:22 <sinelaw> what's the adjective for "easy to reason about"?
12:57:26 <kynky> the 26 - 1h30min english vid lectures on haskell are v.good (university grade)
12:57:39 <SubStack> sinelaw: dunno about easy, but how about cogent?
12:57:47 <silkodyssey> thanks for the responses!
12:57:52 <sproingie> kynky: where are those?
13:00:19 <sinelaw> SubStack, good word! however nobody will understand it
13:00:26 <sinelaw> (i had to look it up :)
13:01:25 <kw317> kynky: what lectures?
13:02:21 <Philippa_> sinelaw: "reasonable" :-)
13:02:42 <sinelaw> Philippa_, :)
13:02:50 <kynky> http://video.s-inf.de/#FP.2005-SS-Giesl.%28COt%29.HD_Videoaufzeichnung , the FP lectures (all of them are haskell, all in english)
13:02:52 <Philippa_> (best used by describing other langs as unreasonable, of course)
13:02:58 <kynky> for kw317
13:03:32 <quuuux> sinelaw: how about 'tractable'?
13:03:47 <sinelaw> quuuux, that's a possibility, thanks
13:05:59 <mije> do we know when hackage will be up again ?
13:07:28 <HairyDude> sinelaw: orthogonal?
13:07:46 <sinelaw> tractable was good enough
13:09:51 <sproingie> http://dustbunny.nomic.info/hackage-06-10-2009.tar
13:10:03 <pumpkin> hackage is back up
13:10:10 <sproingie> ahaha i am the master of timing
13:10:47 <dm`> Cool.  Now how do we mirror it?
13:11:10 <quuuux> sproingie: your efforts are still appreciated: without them, Sod's law wouldn't have taken effect and brought Hackage back up just in time to make them redundant
13:11:20 <sproingie> :)
13:12:04 <dcoutts> dm`: add features to the new hackage-server implementation to do incremental mirroring
13:12:13 <pumpkin> yay
13:12:15 <pumpkin> ;)
13:12:28 <dcoutts> all it needs is to track the rss feed and grab packages
13:12:51 <sproingie> rsync maybe
13:12:57 <Heffalump> rsync might be easier
13:13:18 <dcoutts> it'll work for the old server, not the new one
13:13:22 <dcoutts> rsync I mean
13:14:49 <Heffalump> how come?
13:15:21 <dcoutts> because it does not keep its state as a set of files in the file system
13:15:36 <Heffalump> oh, duh
13:15:38 <dcoutts> at least, not ones with a layout you could serve using apache
13:15:42 <Heffalump> I forgot about auto-generated pages :-)
13:16:45 <dcoutts> Heffalump: actually the new server does not keep any files in a layout corresponding to the layout you see in the URLs
13:21:58 <fnord123> hooray, it's back up
13:22:20 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar doesn't work :-(
13:22:30 <tommd1> And there is a flood of package downloads.
13:24:08 <jmcarthur_work> archive.tar is probably updated only periodically. probably needs to be regenerated, is all
13:25:11 <jmcarthur_work> although i do notice that all the packages' build statuses are up, so perhaps archive.tar should also have been retained
13:30:55 <heatsink> argh!  Why doesn't anyone tell me about the reflections projections conference!
13:31:00 <heatsink> dons was on campus too
13:32:43 <heatsink> *sulk sulk*
13:43:49 <snorble> hackage is alive!
13:44:13 <hackagebot> control-monad-exception 0.4.6 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
13:46:19 <Vulpyne> Hooray!
13:46:53 <dons> rock out
13:47:00 <dons> heatsink: crikey
13:47:02 <dm`> Stack traces, no way!
13:47:17 <hackagebot> hpage 0.3.0 - A scrapbook for Haskell developers (FernandoBenavides)
13:48:08 <dm`> $withLocTH - this must require template haskell.
13:48:31 <heatsink> dons: like oh my god no way this totally sucks
13:49:52 <heatsink> I missed most of it last year too.  I don't really know where it gets announced.
13:49:56 <dons> heatsink: i was there, i'm back now. met lots of cool UIUC people. had beer. talked about haskell
13:50:03 <heatsink> dons: Did you get good turnout?
13:50:20 <dons> yeah, 100-200 people?
13:50:26 <heatsink> wow
13:50:28 <dons> not sure how big the room was, but  there were lots
13:50:42 <dons> i was on after the google chrome guys
13:51:37 <heatsink> And I'll guess that you weren't competing with the dinosaur comics guy
13:53:17 <heatsink> well, glad you had a good visit.
13:53:35 <dons> yeah, dinosaur comics was after me.
13:57:57 <Cale> http://chplib.files.wordpress.com/2009/10/threadscope-boids-3.png -- this is interesting, now all we need is for the green bits to show exactly which expression they were evaluating at the time ;)
13:59:05 <pumpkin> yeah
13:59:10 <pumpkin> that would make it a lot more attractive to me :P
14:00:43 <Cale> It seems that there are a lot of reasons that it would be nice to have a way to compile a Haskell program (with optimisations and all), such that each part of the running code was annotated in some way with the original Haskell code that it came from.
14:00:55 <pumpkin> yeah
14:01:18 <pumpkin> sadly it's hard to even map from post-simplifier core back to the original code
14:01:24 <c_wraith> Did we ever get a report on why hackage went down?
14:01:24 <pumpkin> let alone anything lower
14:03:11 <Cale> If you could get it past the simplifier, I bet the rest wouldn't be so bad. Add a field to every thunk with the relevant source location?
14:04:23 <jmcarthur_work> how does -prof do it?
14:04:30 <jmcarthur_work> -auto-all, etc.?
14:04:41 <johnthexiii> umm hello
14:04:45 <Cale> hello
14:04:54 <johnthexiii> i got a question about c programming
14:05:04 <jmcarthur_work> probably not the right place
14:05:11 <Cale> johnthexiii: This channel is about programming in Haskell.
14:05:15 <johnthexiii> ok where is the right place
14:05:19 <heatsink> johnthexiii, You'll find more C programmers in ##c
14:05:21 <johnthexiii> o ic
14:05:22 <Cale> ##C
14:05:30 <johnthexiii> Thank you.
14:05:50 <heatsink> dons: Anyway.  If you enjoyed it enough to come visit again, then come visit again :)
14:06:02 <Cale> Strange confused people using web interfaces to IRC :)
14:06:18 <Cale> (or maybe not?)
14:06:42 <johnthexiii> Yea I am new to IRC still working out my bugs.
14:06:43 <monochrom> I don't understand why they choose #haskell . The name doesn't even contain the letter c.
14:06:49 <Cale> johnthexiii: ah
14:07:23 <Cale> johnthexiii: We seem to get a fair number of people asking about programming in other languages here for some reason.
14:07:28 <monochrom> To lay people "haskell" should sound more like a person's name than a programming thing.
14:07:31 <jmcarthur_work> monochrom, probably just because it's near the top of a list of channels sorted by popularity
14:07:57 <Cale> jmcarthur_work: Oh, that's a good point.
14:08:36 <johnthexiii> I used google to find this place and haskell seems to be the default channel... I don't know.
14:08:45 <pumpkin> johnthexiii: what did you actually search for?
14:08:47 <pumpkin> just curious
14:08:56 <pumpkin> because a lot of people seem to come in here looking for random stuff
14:09:06 <monochrom> I refuse to believe that. The most confused person going to a library for c books does not browse the libraries "featured this week" books first.
14:09:18 <johnthexiii> "C programming irc"
14:09:29 <sm> ha
14:09:37 <pumpkin> http://snapplr.com/d8j5
14:09:38 <blackh> dons: Did you give that talk that was on Reddit about parallelism?
14:09:46 <monochrom> But perhaps people don't go to libraries anymore and the analogy breaks.
14:10:01 <pumpkin> johnthexiii: that wasn't your first result?
14:10:02 <SubStack> "##C on freenode" is the first result for that query
14:10:13 <pumpkin> same here :)
14:10:30 <SubStack> strange
14:10:39 <monochrom> Perhaps google searches your brain instead of the internet, as promised.
14:10:51 <pumpkin> even stranger is that the word haskell isn't present in any of the top results for that query
14:11:02 <blackh> dons: The reason why I ask is that I'm going to give a talk about Haskell parallelism at LinuxConf.au in New Zealand in January.  I wanted to ask you... What reaction do you get when you try to get across the idea that parallelism is risky without purity?
14:11:19 <pumpkin> jdh30 eats your firstborn
14:11:25 <pumpkin> but otherwise it's mostly positive
14:11:39 <Botje> scoffed laughs from the java programmers who think threads are easy and have never seen a deadlock? :)
14:12:04 <absentia> deadlocks only exist in production software.
14:12:14 <absentia> so, if you never have software in production... the gods have been lenient on you ...
14:12:21 <skorpan> threads only exist in production software
14:12:31 <Cale> I blame dons. He's using his magic powers to interfere with Google search results and draw C programmers into the Haskell channel.
14:12:39 <pumpkin> oh, that must be it
14:12:45 <johnthexiii> "c programming chat room" is exactly what I typed in and the first thing I saw was Haskell, thought it was the name of some online group or something sorry for the inconvience.
14:12:59 <monochrom> I think "parallelism/concurrency is risky" gets the same reaction as "programs have bugs". People have already accepted them as necessary.
14:13:02 <pumpkin> johnthexiii: no problem, we aren't attacking you, we're just curious
14:13:07 * absentia goes back to Objective-C++ .... just because.
14:13:17 <dons> blackh: pretty much acceptance.
14:13:23 <pumpkin> aha
14:13:23 <dons> no one thinks concurrency is easy
14:13:24 <pumpkin> http://snapplr.com/dmch
14:13:33 <pumpkin> that top link links to haskell first
14:13:33 <pumpkin> damn
14:13:38 <Cale> johnthexiii: and of course, if you're interested in learning Haskell, we'd be happy to help with that :)
14:13:49 <dons> http://donsbot.wordpress.com/2009/10/17/multicore-haskell-now-acm-reflections-projections-2009/
14:13:53 <dons> i gave this talk on saturday
14:13:56 <absentia> concurrency *is* easy...   getting it right.. that's complicated.
14:14:04 <johnthexiii> Well while I am here perhaps you could tell me what Haskell is?
14:14:05 <pumpkin> johnthexiii: you might even become johnthexiv if you learn haskell!
14:14:06 <dons> (strangely, when i submit it to reddit, it doesn't show up, like its blocked or something)
14:14:40 <pumpkin> johnthexiii: a strongly typed fast, parallel, safe, awesome, non-strict functional programming language!
14:14:40 <blackh> dons: Thanks - that's good to know.  There's an international speaker from Intel there, so it's going to be an interesting day.
14:15:10 <blackh> dons: (There's a whole day on parallelism/multi-core.)
14:15:19 <dons> note intel has funded a small amount of work at MIT to build concurrent collections in haskell -- they'll be likely aware of haskell
14:15:22 <dons> most people seem to be now.
14:15:34 <johnthexiii> What are some practical applications for the language, what type of applications might one be interested in programming with haskell?
14:15:37 <Cale> (Which is at least 10 years if not 20, ahead of all the languages which are popular in the industry, as far as features)
14:16:02 <pumpkin> johnthexiii: I try to use it for everything I can :) it's a general-purpose programming language
14:16:06 <dons> johnthexiii: most things. its a general purpose language. its particular good a compilers, parallel and concurrent algorithms, network stuff, data structures
14:16:22 <dons> visit haskell.org for far more info
14:16:26 <blackh> dons: I'm trying not to be dogmatic.  I'm saying "we find mutable state to be a problem - maybe the industry can solve parallelism without discarding it - or maybe they will reach the same conclusion the functional programmers have"
14:16:30 <johnthexiii> Cool ill google it thanks for the info.
14:16:38 <dons> blackh: feel free to use my slides.
14:16:44 <Cale> It's a general purpose language, the things which make it nice to program in tend to work almost equally for any application, though it has particularly strong support for concurrency and parallelism, and is rather nice if correctness is important to you.
14:16:45 <dons> mutable state breaks easy parallelism
14:16:54 <pumpkin> johnthexiii: feel free to hang out in this channel and ask questions if you have any :)
14:17:52 <blackh> dons: Thanks - I've stolen liberally from them, and from SPJ's.
14:18:26 <Cale> It has strong mathematical foundations, and you can reason about the behaviour of your programs by manipulating equations rather than having to keep track of what the state of the world is constantly. Even if you don't do formal proofs, this has benefits for testing.
14:18:55 <monochrom> Preach to a man about fishing, and he has a good laugh for a day. Show him how to fish, and he has food for life. And oh, the tragedy of the commons.
14:20:01 <aavogt> almost as bad as lighting the man on fire so that he's warm for the rest of his life?
14:20:04 <sereven> johnthexiii: http://hackage.haskell.org/packages/archive/pkg-list.html http://haskell.org/haskellwiki/Haskell_in_industry give a bit of an overview of haskell programs
14:20:15 <Cale> (since it ensures that functions tested in isolation will behave the same way when you use them for real :)
14:20:21 <johnthexiii> @ pumpkin Ok I just started downloading the windows setup for the haskell platform from http://hackage.haskell.org/platform/ is that the generally accepted "compiler" for haskell or is there a better alternative?
14:20:35 <pumpkin> johnthexiii: yep, that's the best place to start
14:20:44 <Cale> johnthexiii: Yeah, particularly if you're on Windows, that's a good option.
14:20:45 <hackagebot> cereal 0.2 - A binary serialization library (TrevorElliott)
14:34:52 <Axman6> johnthexiii: just curious, but why did you put compiler in quotes?
14:39:17 <johnthexiii> ok got haskell downloaded and installed. Now I would like to know if there are some form a man pages for haskell or an online "hello world
14:39:35 <johnthexiii> " resource?
14:39:42 <pumpkin> > text "hello world, I am a bot that lets you play with haskell!"
14:39:43 <lambdabot>   hello world, I am a bot that lets you play with haskell!
14:39:50 <skorpan> pumpkin: ?
14:39:51 <Zao> johnthexiii: "Real World Haskell" or "Learn You A Haskell" are decent.
14:39:54 <jmcarthur_work> @where lyah
14:39:54 <lambdabot> www.learnyouahaskell.com
14:40:10 <skorpan> johnthexiii: http://en.wikipedia.org/wiki/Haskell_%28programming_language%29#Examples
14:40:15 <jmcarthur_work> :t text
14:40:16 <lambdabot> String -> Doc
14:46:33 <johnthexiii> I am currently going throught the tutorial on learnyouahaskell.com and I am really liking this haskell buisness. pretty impressive stuff.
14:48:04 <jmcarthur_work> johnthexiii, great!
14:48:18 <jmcarthur_work> johnthexiii, i also am curious about why you put "compiler" in quotes earlier
14:48:33 <pumpkin> GHC isn't a "compiler", it's a COMPILER!
14:48:40 <pumpkin> (where the ! is part of the word)
14:48:44 <jmcarthur_work> it's a GLORIOUS COMPILER
14:48:51 <jmcarthur_work> !
14:49:02 <Cale> Hehe
14:49:04 <c_wraith> I think it was likely uncertainty over whether the language is compiled.  Python and ruby don't have compilers, for instance, but they still have huge packages to download.
14:49:07 <aavogt> G-G-GHC
14:49:09 <Cale> It's both a compiler and an interpreter :)
14:49:21 <pumpkin> GLORY BE UPON US ALL!
14:49:36 <Cale> and the interpreter does bytecode compilation
14:50:05 <jmcarthur_work> Cale, what's the bytecode?
14:50:31 <tavelram> its not only a GLORIOUS compiler, its a "GLIOURIOUS compilers"
14:50:32 <tavelram> ;)
14:50:42 <Kruppe> Can anyone help me figure out how to make this particular typeclass and associated function? I'm trying to make a function which gets the data from type called Genotype, which is defined something like this "data Genotype = DivisionGenome { intData :: [Int] } | BoolGenome { boolData :: [Bool] }". Basically I want a function that will return either [Bool] or [Int] depending on what type of Genotype is passed as its parameter.
14:51:05 <Kruppe> Pointing me to documentation would also be acceptable
14:51:15 <tavelram> -i
14:51:18 <Cale> jmcarthur_work: I don't really know much about the particulars of it. It's GHC specific whatever it is.
14:51:33 <jmcarthur_work> Kruppe, what is the type of the function?
14:51:48 <Kruppe> thats actually part of what im trying to figure out
14:52:00 <Kruppe> im kind of new to haskell, and I decided to write a simple genetic algorithm in it
14:52:15 <Kruppe> and im trying to make a generic genotype type
14:52:24 <Cale> Kruppe: It is undecidable at compile time (when the types are checked) which data constructor was used to make any given value of type Genotype.
14:52:35 <Kruppe> oh
14:52:40 <Kruppe> so its a pipedream for me then?
14:52:41 <jmcarthur_work> Kruppe, it could return something of type Either [Bool] [Int], but you cannot actually have two possible return types like that
14:52:48 <Kruppe> ah
14:52:54 <Kruppe> thats why ive been running into trouble
14:52:59 <Kruppe> what do you suggest then?
14:53:10 <jmelesky> Kruppe: would a parametrized type be useful for you?
14:53:13 <Cale> Kruppe: If you have a way to convert from one sort of Genotype to the other, then you can write a polymorphic function which produces either sort of list.
14:53:13 <Kruppe> if im to make a generic genetic algorithm for lots of different genotype representations that is
14:53:15 <jmcarthur_work> Kruppe, if you had two different *types* (as opposed to constructors) for the two kinds of Genotypes, you could have two different types for the result
14:53:16 <Cale> (using a typeclass)
14:53:42 <Cale> Kruppe: Or if you don't mind it being a runtime error to ask for the wrong sort of list, then it's also doable.
14:53:46 <jmcarthur_work> Kruppe, with extensions, that is
14:54:06 <jmcarthur_work> but it would still be a compile time thing, which i bet isn't what you want
14:54:10 <Kruppe> converting from one genotype to the other wont work
14:54:21 <jmcarthur_work> Kruppe, how is the function intended to be used?
14:54:40 <Kruppe> well i had some sort of fuzzy idea in my head about how to use it
14:54:46 <Cale> Kruppe: I think I would decide what operations are important for the genetic algorithm, and design the thing to be completely polymorphic in the genotype (or polymorphic over any type which supports the operations I need)
14:54:48 <Kruppe> ill show you a function i would like to write with it
14:55:10 <Kruppe> genoLength = length . geneData
14:55:10 <Kruppe>  
14:55:11 <johnthexiii> @ jmcarthur_work wasnt sure if haskell was a scripting language or used some other means to build an executable. Just wasn't sure.
14:55:27 <jmcarthur_work> johnthexiii, aha. well, it's a real (good) compiler :)
14:55:48 <Kruppe> that kind of stuff
14:55:52 <Kruppe> i could do it with multiple types
14:56:02 <Kruppe> i might just be thinking of this the wrong way in that respect
14:56:11 <Kruppe> still sort of clinging to object oriented views
14:56:13 <Cale> johnthexiii: There are both interpreters and compilers for Haskell, and GHC comes with one of each :)
14:56:22 <jmcarthur_work> Kruppe, data Genotype a = Genotype [a] ?
14:56:30 <jmcarthur_work> Kruppe, or maybe use newtype rather than data
14:56:32 <johnthexiii> Not a GLORIOUS COMPILER anymore =P
14:56:37 <Kruppe> ah
14:56:40 <Kruppe> whats the difference
14:56:43 <jmelesky> jmcarthur_work: that's what i was thinking
14:56:44 <Kruppe> newtype does what
14:56:48 <Cale> Kruppe: If you want to be object oriented about it, what would your genotype class look like?
14:57:04 <Kruppe> i had a dirty java way of doing it before
14:57:12 <Kruppe> which checked for the type
14:57:18 <Kruppe> and did something different
14:57:18 <jmcarthur_work> Kruppe, newtype just makes a new type and has no runtime difference from just [a] (but does have type checker difference)
14:57:26 <Kruppe> ah
14:57:28 <Kruppe> interesting
14:57:33 <Kruppe> so not quite a synonym
14:57:41 <Philippa_> right, it's isomorphic rather than equal
14:57:41 <jmelesky> Kruppe: is a given genotype datum ever going to contain both ints and bools?
14:57:49 <Kruppe> never
14:57:53 <Kruppe> it will contain one or the other
14:58:09 <jmelesky> Kruppe: then data Genotype a is probably the way you want to go
14:58:24 <Kruppe> alright
14:58:27 <Kruppe> ill give that a shot
14:58:29 <Cale> Well, in a proper OO design, you'd probably have some private data which was your big list or whatever, and then some operations for mutation and crossover.
14:58:31 <jmelesky> so, when you create a new genotype, you tell the constructor what type of data is going to be in it
14:58:54 * jmcarthur_work votes for newtype unless you will need more constructors or a need to distinguish Genotype _|_ from _|_
14:59:24 <jmcarthur_work> newtype Genotype a = Genotype [a]
14:59:37 <Cale> Of course, if you really just want a list, that's fine too ;)
14:59:44 <jmcarthur_work> and that
14:59:50 <Kruppe> that could work too
14:59:52 <Kruppe> buuuut
14:59:53 <jmcarthur_work> abstraction is nice though :)
14:59:53 <Cale> But there's an obvious typeclass here
14:59:55 <Kruppe> somehow that feels wrong
14:59:57 <Kruppe> lol
15:00:04 <Cale> class Genotype t where
15:00:30 <Cale>   random :: StdGen -> t
15:00:39 <Cale>   mutate :: StdGen -> t -> t
15:00:48 <Philippa_> jmcarthur: newtyping in that situation is something of a low-level thing, so it strikes me as a bad habit unless you're on your optimisation pass
15:00:49 <Cale>   crossover :: StdGen -> t -> t -> t
15:00:59 <jmcarthur_work> Philippa_, not low level at all
15:01:07 <jmcarthur_work> Philippa_, it has completely different semantics
15:01:51 <Kruppe> Cale: yeah i see where your goin with that
15:02:01 <Cale> Of course, feel free to abstract over the sort of random generator. If you need better performance, then you might want to use something else.
15:02:28 <jmcarthur_work> Philippa_, http://www.haskell.org/haskellwiki/Newtype
15:02:30 <jmelesky> i'm hesitant to use newtype just because i assume there will be additional data above the list
15:02:38 <Cale> Of course, then we need a way of scoring the results.
15:02:43 <Kruppe> yeah
15:02:44 <jmcarthur_work> jmelesky, "above"?
15:02:49 <Kruppe> fitness functoin
15:02:52 * Axman6 is confused too
15:03:01 <Kruppe> already have those worked out
15:03:07 <Kruppe> for each individual case
15:03:07 <jmelesky> jmcarthur_work: in addition to
15:03:19 <Cale> While it would be possible to add a fitness function to that class, I feel it's probably a better idea to have your GA framework take the fitness function as a parameter
15:03:36 <Cale> That is, just use plain old functional programming there.
15:03:47 <jmelesky> POFP
15:03:48 <Kruppe> Cale: that would make more sense since its very specific to the type of genotype
15:03:52 <Cale> You could conceivably do this with all of the above too.
15:04:09 <Cale> (just have it take all those functions as parameters)
15:04:11 <jmcarthur_work> jmelesky, well, clearly a record is a different thing, but it's a rather trivial thing to notice up front
15:04:21 <jmcarthur_work> maybe not for a beginner, i suppose
15:04:52 <jmelesky> jmcarthur_work: sure. i wasn't saying it was a *good* assumption. just that it was an assumption. :)
15:04:59 <jmcarthur_work> but in my own code, at least, if i feel like something should be a newtype then it's usually because i know already due to the properties it should have
15:05:02 <Kruppe> alright thanks folks, I'm off to class.
15:05:57 <ve> can you view how things what definitions things have that have been defined using @let (for lambdabot and the like)?
15:06:18 <jmcarthur_work> i tend to use newtype a *lot* now because i design my types by composing simpler types almost exclusively
15:06:26 <jmelesky> jmcarthur_work: on the flip side, i've seen code go through some unfortunate hoops because the programmer decided to peg a local type to something inappropriate
15:06:47 <jmcarthur_work> jmelesky, i would call that an abstraction leak that should have never happened
15:07:43 <Philippa_> jmcarthur: I know the semantics of newtype perfectly well. Asking whether you care about the distinction between _|_ and MyNewType _|_ is very much a low-level question when you're encoding most domains
15:07:49 <jmcarthur_work> something like that happens means that somebody didn't think before they wrote the code
15:07:59 <jmelesky> jmcarthur_work: certainly. but avoidable if you start out being a little more abstract with your types.
15:08:30 <jmelesky> jmcarthur_work: well, that they didn't think *enough*. knowing where "enough" is can be a tricky skill to build
15:08:38 <jmcarthur_work> Philippa_, i think the difference between foo _ = ... and foo (Genotype _) = ... is semantically significant
15:08:46 * Philippa_ will use newtype a lot more once the generic programming tools are at a stage that's useful for her from a high-level perspective, sure
15:08:59 <jmcarthur_work> jmelesky, "enough" is when you have decided what you abstraction should be
15:09:08 <jmcarthur_work> *your
15:09:26 <Philippa_> jmcarthur: It certainly is from Haskell's POV. From the domain's POV, it's often the case that the question doesn't even make sense
15:10:11 <jmcarthur_work> Philippa_, such as?
15:10:46 <Philippa_> jmcarthur: what does, say, the rules of Go know about newtyping?
15:11:00 <jmcarthur_work> Philippa_, depends on what your types encode
15:11:06 <jmcarthur_work> i'm looking for a more concrete example
15:11:14 <Philippa_> IOW, you're asking me to go lower-level for you
15:11:29 <jmcarthur_work> Philippa_, when you write code, that's the level you are on
15:11:44 <jmcarthur_work> Philippa_, including just *using* the library
15:11:52 <jmcarthur_work> or module or whatever
15:12:10 <monochrom> I don't understand this dialogue.
15:12:37 <Philippa_> which is why newtype is generally a low-level feature unless you're coding up something sufficiently mathematical
15:12:51 <jmcarthur_work> Philippa_, i don't understand your definition of low level
15:13:00 <Philippa_> the question of whether it can be written that way to /allow/ a newtype? Is makework
15:13:05 <Philippa_> the Perlis one
15:13:24 <aavogt> Philippa_: what is a generic programming tool? like an IDE?
15:14:01 <jmcarthur_work> Philippa_, "A programming language is low level when its programs require attention to the irrelevant."?
15:14:05 <Philippa_> aavogt: it's more libs and language I'm interested in
15:14:20 <jmcarthur_work> Philippa_, newtype vs. data is not irrelevant. it affects behavior
15:14:36 <jmcarthur_work> just like strictness vs. laziness is not irrelevant
15:15:08 <Philippa_> jmcarthur: the question of whether you can make something a newtype is frequently irrelevant - it only becomes relevant when data wouldn't do just as well in encoding the domain
15:15:25 <jmcarthur_work> Philippa_, you are talking when you *can*, and i'm talking about when you *should*
15:15:41 <Philippa_> and your "should" involves a check for when you can
15:16:00 <jmcarthur_work> if you can't then you probably shouldn't anyway...
15:17:33 <newsham> I understand why Bool is like "2" and how alternation "|" in "data" is like sum and tuples are like products.  why is  a -> Bool like 2^a?
15:18:09 <newsham> (or should that perhaps be a^2?)
15:18:14 <Philippa_> * jmcarthur_work votes for newtype unless you will need more constructors or a need to distinguish Genotype _|_ from _|_ <- okay, fair enough. Thing is, thinking about whether you might possibly have the need? Also smells low-level at the initial encoding stage
15:18:24 <skorpan> in fact, it's the a'th root of 2
15:18:38 <Philippa_> if you know for certain you won't/can't, sure, with you
15:18:41 <newsham> skorpan: can you explain that intuitively?
15:18:43 <jmcarthur_work> Philippa_, need is not low level. if you need it you need it
15:18:54 <skorpan> newsham: trolled!
15:18:58 <Philippa_> predicting it in advance damn well is, though
15:19:03 <newsham> skorpan: not helpful :(
15:19:09 <skorpan> :)
15:19:11 <jmcarthur_work> Philippa_, i'm talking about the basic abstract properties of your code, not optimization details
15:19:35 <Philippa_> jmcarthur: newsflash! Not everyone knows the answer to that question at initial design time
15:19:48 <jmcarthur_work> Philippa_, and if you don't know the exact properties you want when you write the type, you have big problems
15:19:48 <newsham> nevermind I think i got it.
15:19:55 <jmcarthur_work> Philippa_, that's a problem
15:19:59 <Philippa_> and yes, it really is an optimisation detail given that a newtype would work
15:20:06 <Philippa_> and that a datatype would work also
15:20:26 <jmcarthur_work> Philippa_, it means the difference between a value and _|_
15:20:43 <jmcarthur_work> i would call that an important design feature
15:20:51 <Philippa_> and this is what we call "religion"
15:20:59 <monochrom> In general X->Y is Y^X.
15:21:02 <dmwit> newsham: What is the cardinality of (A -> B), given the cardinalities |A| and |B| of A and B?
15:21:22 <dmwit> newsham: Work that out (feel free to assume finite |A| and |B| for now) and you'll have your answer. =)
15:21:22 <newsham> dmwit: yah, my friend clued me in.. got it now.
15:21:25 <dmwit> ok
15:21:44 <monochrom> There are two perspectives. One perspective: we just define Y^X to mean X->Y, alternative notation. Another perspective: cardinality works out.
15:22:57 <Philippa_> jmcarthur: sure, sometimes it's blindingly obvious because what you're defining really is just that - usually, because you're modelling something that's already mathematical in nature. The rest of the time? The entire question is obnoxious, introducing the few extra values does no real semantic damage
15:23:41 <MyCatVerbs> monochrom: I seem to remember going into a fit of giggles when I worked out for myself that there are as many total functions from (X -> Y) as |X|**|Y|. :)
15:23:54 <jmcarthur_work> Philippa_, what is the distinction between mathematical and non-mathematical?
15:24:28 <Philippa_> jmcarthur_work: You're the one who was proposing a rule to start with. I'm not about to start playing that game
15:24:39 <Philippa_> welcome to the land of the informal, things aren't formal
15:25:06 <hackagebot> bindings-fann 0.0.1 - Low level bindings to FANN. (MauricioAntunes)
15:25:06 <jmcarthur_work> Philippa_, it was never a game, and i never said anything about rules
15:25:23 <jmcarthur_work> Philippa_, and i never said anything about being formal, either
15:25:29 <jmcarthur_work> this is *basic* stuff
15:26:02 <lament> what another set of FANN bindings? There's already hfann
15:26:07 <monochrom> Here is a twist. To construct a category so objects are types, you have both morphisms from A to B, and you also want an object to be the type of functions from A to B. So you end up having both "A->B" and B^A, one for morphisms, the other for the function type. You add axioms to relate them, but you want them both co-existing.
15:26:18 <Philippa_> jmcarthur: it's stuff you consider basic. Others don't. Get over it.
15:26:52 <jmcarthur_work> Philippa_, obviously, i have somehow struck a nerve. i'm not sure whether it is my responsibility to "get over" anything
15:26:52 <andrewsw> I've never seen data types represented like that (| as sum, (x,y) as x*y though I guess that follows as cartesian product). Where do I find more discussion of it?
15:27:07 <hackagebot> hsSqlite3 0.1 - Sqlite3 bindings (MauricioAntunes)
15:27:19 <jmcarthur_work> i feel i am speaking less religiously than my fellow debater
15:27:25 <Philippa_> of course you do
15:27:30 <lament> andrewsw: they are called "algebraic data types" for a reason :)
15:27:51 <andrewsw> lament: I have to admit, I've always wondered about that.
15:27:55 <jmcarthur_work> hard and fast rules on when to allegedly optimize sound religious to me
15:28:05 <andrewsw> I sort of shrugged it off and forged ahead. heh.
15:28:09 <Philippa_> in the meantime, you're talking about semantic properties that are, I repeat, an utter irrelevancy to many programs
15:28:21 <Philippa_> and trying to tell me that they're not
15:29:07 <hackagebot> state 0.1 - Data.State (MauricioAntunes)
15:29:22 <Philippa_> you're acting as if the extra values present in the datatype definition will fundamentally flaw any type that could've been a newtype instead. It just ain't so, and if you want to show otherwise that's for you to do
15:29:30 <Axman6> hmm, we don't get into fights in here usually
15:30:29 <Axman6> in fact, the only time i've been close to a fight with anyone in here was with Philippa_
15:30:47 <stoop> I don't see how this is a "fight".
15:30:53 <jmcarthur_work> Philippa_, newtype Foo a = Foo [a] ; foo (Foo xs) = [1..3] ++ xs
15:31:00 <Axman6> well, it's somewhat heated. more than i
15:31:01 <jmcarthur_work> Philippa_, completely different results with data
15:31:05 <Axman6> i'm used to in here
15:31:06 <blackh> Axman6: Here someone says "Haskell is awesome" and then someone else says, "Yes, I agree! Isn't Haskell awesome?" and someone else says "I can't tell you how awesome Haskell is!"
15:31:08 <inimino> spirited debate
15:31:16 <jmcarthur_work> Axman6, i'm not used to it either
15:31:24 <lament> there's a fine art to talking to Philippa_ that involves knowing when to withdraw
15:31:30 <Axman6> blackh: and then we blog about it!
15:31:46 <stoop> lament, please explain.
15:31:50 <Philippa_> jmcarthur: sure. Never claimed otherwise. Now tell me: when and why is that the /right/ behaviour?
15:31:55 <lament> stoop: i don't really get it either :)
15:32:15 <jmcarthur_work> Philippa_, it's the right behavior with a Foo is supposed to behave like a list
15:32:22 <jmcarthur_work> Philippa_, it's the wrong behavior when it is not
15:33:03 <ddarius> monochrom: Use a Hask enriched category and A->B = B^A
15:33:57 <ddarius> Cale: So I read that "From sets, to types, to categories, to sets." paper by Awodey, and it was interesting.
15:34:11 <jmcarthur_work> Philippa_, and it's anything but an optimization detail
15:34:12 <Philippa_> jmcarthur: that's close enough for now, I guess - now what about the case "I don't care about it acting like a list"?
15:34:23 <jmcarthur_work> Philippa_, then it's data
15:34:30 <jmcarthur_work> that's what data is for
15:34:38 <Cale> ddarius: Thanks for the recommendation, I'll have a look :)
15:35:05 <Philippa_> right. Now, can you see how not caring isn't the same as needing data?
15:35:22 <jmcarthur_work> Philippa_, did i ever say any different
15:35:40 <Philippa_> that would be startlingly irrelevant :-)
15:35:46 <jmcarthur_work> Philippa_, you were not talking about "not caring." you were talking about "not thinking."
15:35:53 <gOcOOl> MyCatVerbs: regarding HNF & WHNF, some of the docs I'm reading suggest using "forceList [] = (); forceList (x:xs) = x ‘pseq‘ forceList xs" as a method to force the evaluation of every element of the list. I can see how calling forceList [(1+2), (3+4), (5+6)] would result in pseq forcing (1+2) to be evaluated but what is forcing the rest of the list to be evaluated as well?
15:36:02 <Philippa_> no, I was talking about not /having/ to think
15:36:12 <jmcarthur_work> Philippa_, not the same as not caring
15:36:16 <Philippa_> now, what you've just said above contradicts your original recommendation
15:36:25 <Philippa_> your original recommendation had no room for "don't care"
15:36:39 <pumpkin> #debate_team
15:36:41 <ddarius> gOcOOl: Whatever is forcing forceList
15:36:51 <Philippa_> rather, it defaulted to newtype /unless/ you needed the semantics of data
15:36:54 <ddarius> gOcOOl: Which is necessary for the pseq to be forced as well.
15:36:58 <MyCatVerbs> gOcOOl: The recursive case works.
15:36:59 <jmcarthur_work> Philippa_, no, it doesn't have room for "don't think"
15:37:14 <jmcarthur_work> Philippa_, also not true. i defaulted to newtype because it looked right for this case
15:37:20 <jmcarthur_work> Philippa_, i never said anything about in general
15:37:22 <MyCatVerbs> gOcOOl: (x `pseq` forceList xs) forces x, and returns the result of (forceList xs).
15:37:44 <jmcarthur_work> except that *i* use it a lot because i compose more than create from scratch
15:37:45 <MyCatVerbs> gOcOOl: forceList xs will in turn pseq the subsequent elements...
15:37:51 <jmcarthur_work> which is an entirely different matter
15:37:54 <MyCatVerbs> gOcOOl: eventually returning () when it reaches the [].
15:38:19 <Philippa_> okay, there's been a miscommunication. Sorry for my part in that.
15:38:31 <monochrom> I don't understand. If I don't care, I should refuse thinking.
15:38:38 <jmcarthur_work> Philippa_, i am equally sorry for mine
15:38:51 <jmcarthur_work> we cluttered the channel real good :)
15:38:51 <gOcOOl> MyCatVerbs: hmm, let's say we used "forceList (x:xs) = x ‘pseq‘ x : forceList xs" instead
15:39:12 <gOcOOl> in this case only the 1st element would've been evaluated?
15:39:15 <Philippa_> FWIW, I read it in the "generalisable", if that makes sense. And that's what I was arguing against
15:39:19 <MyCatVerbs> gOcOOl: yeah, no. That wouldn't evaluate even the first element.
15:39:32 <MyCatVerbs> gOcOOl: That will get you: (:) (x `pseq` x) (forceList xs).
15:39:37 <pumpkin> > let (–) = (-) in (–3) 5
15:39:38 <lambdabot>   2
15:39:44 <stoop> Who is modus_ponendo_ponens?
15:39:45 <pumpkin> w00t
15:39:48 <MyCatVerbs> gOcOOl: When you WHNF that, firstly you'll only get the outermost constructor, which in this case is (:).
15:40:19 <gOcOOl> MyCatVerbs: ah ok, makes sense
15:40:27 <MyCatVerbs> gOcOOl: Secondly, (x `pseq` x) is equivalent to (x). It has no effect if you give the same expression on both sides. :)
15:40:31 <Philippa_> I tend to data by default for much the reasons I've been giving - "mathematical" isn't something I'm about to define, but if your haskell defs're following the structure of something at least somewhat formalised that you're modelling, you're plenty of the way there for the purposes of that statement. You'll understand, I hope, why I wasn't about to formalise the informal :-)
15:40:48 <MyCatVerbs> gOcOOl: So that version of forceList is actually just a less efficient version of the (id) function. ;)
15:41:01 <newsham> whats the cardinality of (Nat -> Bool)?  aleph1?
15:41:22 <MyCatVerbs> Shouldn't it be aleph0?
15:41:42 <newsham> i'm asking, are you telling? :)
15:41:50 <jmcarthur_work> Philippa_, fair enough :)
15:41:56 <MyCatVerbs> Intuitively I'm thinking aleph0, but I can't prove it right now. :D
15:41:58 <jmcarthur_work> and now i must leave work
15:42:05 <pumpkin> 2 ^ aleph0
15:42:29 <newsham> aleph0 + aleph0 = aleph0,  aleph0 * aleph0 = aleph0, but what is 2^aleph0 ?
15:42:37 <newsham> my gut says "more than aleph0"
15:42:42 <dolio> If you're just talking set theoretic functions, each element of (Nat -> Bool) identifies a subset of Nat.
15:42:43 <gOcOOl> MyCatVerbs: oh wait,I think i mean this "forceList (x:xs) = x ‘pseq‘ (x : forceList xs)" in my last example
15:42:44 <monochrom> intuitively Nat -> Bool is uncountable and bigger than ℵ0
15:42:56 <pumpkin> any powerset is strictly larger in cardinality than the set
15:43:17 <pumpkin> isn't it beth1 and maybe aleph1?
15:43:19 <newsham> is there a correspondence between (Nat -> Bool) and Real ?
15:43:45 <pumpkin> you could take it as infinite binary "decimals"
15:43:48 <gOcOOl> MyCatVerbs: that *would* evaluate just the 1st elem i suppose
15:43:49 <lament> newsham: yes
15:43:56 <lament> what pumpkin said
15:44:03 <MyCatVerbs> gOcOOl: Yes.
15:44:11 <newsham> what pumpkin said is "beth1 and maybe aleph1".  is this an open question?
15:44:15 <dpratt71> I've decided this forum is not a good place for me to be...
15:44:22 <dpratt71> ...but I can't quit it!
15:44:28 <lament> newsham: i mean what pumpkin said about binary numerals
15:44:30 <MyCatVerbs> gOcOOl: So when you forced that, you'd have (:) (already-forced x) (forceList xs).
15:44:56 <dolio> Whether beth1 = aleph1 depends on whether you have the continuum hypothesis.
15:45:01 <andrewsw> dpratt71: I can't get any work done, I just sit there watching it go by
15:45:02 <dpratt71> I came here yesterday trying to understand Category Theory...
15:45:15 <newsham> < dpratt71> I came here yesterday trying to understand Category
15:45:15 <newsham>         Theory...
15:45:18 <dolio> Which is independent of the other axioms of the usual set theory.
15:45:19 <newsham> and you're not done yet? ;-)
15:45:20 <dpratt71> ...I left trying to understand Baire spaces...
15:45:25 <MyCatVerbs> gOcOOl: please note with interest that Haskell has just allowed you to define a very strange evaluation order - each element in the list (forceList xs) is forced at the same time as the list constructor in front of it is. :)
15:45:46 <dpratt71> ...and I haven't gotten back to Category theory
15:45:48 <MyCatVerbs> dpratt71: God, I love this channel for that very reason. :)
15:45:48 <monochrom> ℵℶ
15:45:52 <newsham> dolio: ok..  starting to go over my head.
15:45:55 <lament> newsham: represent a real number in [0,1) as a binary numeral, that gets a mapping for each binary digit, i.e. Nat -> Bool
15:46:12 <dpratt71> yeah, it's a fun waste of time :)
15:46:24 <pumpkin> dolio: it's basically asking if there's anything between aleph0 and aleph1
15:46:27 <lament> newsham: then you can extend it to the whole real line easily
15:46:31 <newsham> lament: hmm that seems to make sense.
15:46:33 <andrewsw> oh lament that helps a lot.
15:46:37 <dolio> newsham: The continuum hypothesis is, precisely aleph1 = beth1 (and then there's the generalized continuum hypothesis which is alephN = bethN forall N).
15:47:44 <newsham> dolio: so I take it there are systems where the continuum hypothesis isnt assumed?
15:47:53 <dolio> But it's been shown that both the continuum hypothesis and its negation can be added to the usual set theory axioms and maintain consistency, as I recall.
15:48:02 <gOcOOl> MyCatVerbs: I suppose with recursion, the runtime has no option of stopping at the outermost constructor since there isn;t one to begin with and is forced to walk the entire list, if that even makes sense
15:48:17 <gOcOOl> is that a true statement, if at all it makes sense? ;)
15:48:33 <MyCatVerbs> gOcOOl: It sounds like you're on the right track.
15:49:55 <MyCatVerbs> gOcOOl: Yes, so in { forceList [] = (); forceList (x:xs) = x `seq` forceList xs }, when you seq (forceList somelist), the runtime can't stop early anywhere on the chain of forceList calls because the first constructor that it will get is the one at the very bottom of the recursion. :)
15:50:22 <monochrom> Crossoverly, a common technique for proving consistency of those axioms is called forcing.
15:50:51 <gOcOOl> the one at the very bottom of it being [], right?
15:51:41 <gOcOOl> since - data [] a = [] | a : [a]
15:58:22 <ddarius> newsham: Most of the time whether the Continuum Hypothesis holds or not isn't very relevant to the problem at hand.
16:01:30 <Guest10503> so print (length (words "a bc")) works, but print.length.words "a bc" doesn't
16:01:44 <Guest10503> aren't these the same?
16:01:50 <mauke> no
16:02:04 <mauke> that parses as print . length . (words "a bc")
16:03:00 <Guest10503> so it should be print.length$words "a bc" then?
16:03:11 <mauke> spaces around operators, please :-(
16:03:14 <mauke> > (length . words) "a bc"
16:03:15 <lambdabot>   2
16:03:18 <Axman6> Guest10503: you want print . length . words $ "a bc"
16:03:27 <thoughtpolice> oi
16:03:35 <thoughtpolice> does anybody use this google wave thing?
16:03:36 <Axman6> Guest10503: you generally use f . g . h $ x
16:03:40 <Axman6> thoughtpolice: yup
16:03:42 <thoughtpolice> i'm not quite sure I grasp it
16:03:49 <monochrom> (print . length . words) "a bc"
16:03:56 <Axman6> thoughtpolice: you got many people on your contacts?
16:03:57 <ccasin> n FFI question: I have a binding to a C function that expects a "Ptr CUChar" to write into, and an open "Handle" where I want the data to go.
16:04:05 <ccasin> Can I somehow work with the Handle directly, or must I make a new Ptr CUChar of the right size, write into it, convert it to a string/bytestring, and write that to the file?
16:04:07 <ddarius> print (length (words "a bc"))
16:04:25 <thoughtpolice> Axman6: somewhat, my coworkers at least
16:04:39 <Axman6> it really needs more people to be useful
16:04:48 <mauke> ccasin: if the function expects a Ptr CUChar, you have to create one
16:04:57 <Axman6> there's a haskell coding wave, is you search for "with:public haskell" you'll find it
16:05:12 <dolio> newsham: Cale has all sorts of weird example problems that do depend on whether the continuum hypothesis is true, though, if you're interested.
16:05:16 <Guest10503> so (print . length . words) "a bc" is the same as print . length. word $ "a bc"? why the $?
16:05:23 <Axman6> Guest10503: yep
16:05:40 <newsham> no, thats beyond me at the moment.
16:05:41 <Axman6> Guest10503: the $ basically removes the need for brackets
16:05:46 <newsham> was more a passing curiosity
16:05:52 <mauke> ccasin: but see http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhPutBuf
16:06:04 <ccasin> mauke: OK, so if I make a new one and have the function write the data into it, what's the best way to get it into the file? Convert it to a bytestring and
16:06:18 <ccasin> mauke: great!
16:06:21 <ccasin> just what I was looking for
16:06:22 <thoughtpolice> Axman6: some of my coworkers have it, so I was thinking of asking them for an invite but i'm not really certain
16:06:23 <ccasin> thank you
16:06:37 <Guest10503> isn't f . g x == f (g x), if i follow that definition, then f. g .h x should not need a $
16:07:06 <Axman6> it's (f . g) x i think
16:07:26 <Axman6> whoops, no it's not
16:07:34 <Axman6> function application binds higher than infix functions
16:07:49 <mauke> Guest10503: f . g x == f . (g x)
16:07:50 <dolio> (f . g) x = f (g x), f . g x = \y -> f (g x y)
16:07:56 <Cale> Actually, some of the problems which depend on CH are rather simple. Suppose that f: R -> N is a colouring of the reals with countably many colours. Must there exist distinct x,y,z,w in R all of the same colour such that x + y = z + w?
16:08:07 <monochrom> f . g x == f . (g x)
16:08:32 <Cale> This turns out to be equivalent to not CH.
16:09:23 <Cale> I sort of lean in the direction of not CH, but there's an attractiveness to the simplicity that CH gives.
16:09:27 <Guest10503> so . notion isn't what i thought it is
16:09:34 <ivanm> so, when did hackage get online again?
16:10:10 <monochrom> I like CH because I want to morally say 2^ℕ is c.
16:10:26 <dolio> You don't need CH for that.
16:10:39 <Guest10503> in ghc: print.length.word's type is String->IO(), same is (print.length.words)
16:11:15 <Guest10503> but (print.length.words) "a b" runs, while print.length.words "a b" gives a type error
16:11:15 <monochrom> Does ZF suffice? Does ZFC suffice?
16:11:38 <Cale> 2^N is how c is normally defined.
16:11:40 <Guest10503> why is that?
16:11:41 <Cale> ZF suffices.
16:11:43 <mauke> > 2+3 * 4
16:11:44 <lambdabot>   14
16:11:47 <mauke> ^ this
16:11:53 <dolio> CH is about whethere there's anything between N and 2^N.
16:12:09 <monochrom> Oh no, there is someone named Beth Cardinal and it can be found on LinkedIn.
16:12:20 <monochrom> And facebook...
16:12:54 <monochrom> OK, beth cardinality is better.
16:13:25 <ddarius> monochrom: Way cuter.
16:13:42 <skorpan> i like "wilma"
16:13:57 <Cale> Guest10503: because function application binds tighter than any operator symbosl
16:14:01 <Cale> symbol*
16:14:18 <Cale> Guest10503: So that latter thing means  print . length . (words "a b")
16:14:38 <Cale> Guest10503: which isn't what you want. The solution is to stick a $ in after the last function and before the argument
16:14:50 <Cale> So it becomes print . length . words $ "a b"
16:15:08 <Cale> $ is just function application with really low precedence.
16:16:54 <skorpan> i've been thinking about these levels of precedence... as far as i can remember, the highest infix precedence in haskell is 9? and the lowest is 1.  are those levels enough?  i'm thinking like the BASIC problem where people started numbering lines 1000, 2000, etc.
16:17:24 <dolio> 0 is the lowest, but that's not much better.
16:18:11 <dolio> Interestingly enough, Agda goes up to 100 at least, but the standard library only uses 0 - 9 for some reason.
16:18:44 <monochrom> theorem prover HOL uses unlimited natural numbers, in practice something in the hundreds at most.
16:18:46 <aavogt> infix 9000 <
16:19:17 <Cale> I think a better thing would be to just allow defining the ordering relation piecemeal.
16:19:31 <mauke> heh, that's what Perl6 was supposed to do
16:19:35 <Cale> Say "this thing has precedence over that thing" and so on.
16:19:36 <monochrom> After experience and listening to other people, I am inclined to using a partial order instead.
16:19:47 <skorpan> Cale: yes, i had that idea as well
16:19:48 <Cale> and take the transitive closure of course
16:20:02 <skorpan> minus the ... transat... tra... whatever
16:20:29 <dolio> I think they've talked about rewriting agda to use something more like that, but it hasn't happened yet.
16:20:30 <Cale> that just means that if a has precedence over b and b has precedence over c then a has precedence over c
16:20:32 <mauke> transatlantic carrier
16:20:58 <dolio> I haven't really thought about how much harder it is.
16:21:38 <monochrom> IMO it is easier to implement and reason about. It is just unsettling to people who insist on total orders.
16:22:14 <dolio> Yeah, I suppose I don't really know how "easy" the Haskell method is either.
16:22:55 <skorpan> what if in module A you say "a is stronger than b" and in module B you say "b is stronger than a", what happens?
16:23:14 <aavogt> you can only define precedences in the module that defines the symbol
16:24:01 <aavogt> or you mean  `A.f` and `B.f` will not necessarily be able to be substituted for another, even assuming the same type signatures?
16:24:04 <mauke> aavogt: that doesn't prevent the situation
16:24:34 <aavogt> I see
16:24:36 <monochrom> Suppose you define operator x and I define operator y, independently. Suppose Cale uses both yours and mine. Total order means Cale will be surprised, either x over y or y over x. Partial order means the parser asks for Cale's verdict so he is never surprised.
16:25:04 <blackdog> i think haskell's weirded my thinking - i've just noticed an opportunity to use a monad in C
16:25:19 <blackdog> anyone tried it? does it work out, or end up ridiculous?
16:25:40 <dolio> Maybe your thinking has just been embiggened.
16:25:42 <ivanm> oh, great, looks like we'll have yet more problems with gtk2hs when 6.12 comes out...
16:25:42 <monochrom> Partial order also lets you say "locally in this module I want x higher than y but don't let other people know!"
16:26:06 <ivanm> we're still having problems in gentoo with users complaining that some apps don't work with 6.10! :@
16:26:31 <dcoutts> ivanm: you've tried building gtk2hs with 6.12 eh? :-)
16:26:41 <dcoutts> it'll definitely need updates
16:26:45 <ivanm> dcoutts: read the threadscope blog post
16:26:47 <dcoutts> ghc-pkg changes
16:26:59 <mauke> the first and foremost task of a haskell compiler is to break haskell programs
16:27:00 <ivanm> oh, because of the manual building?
16:27:04 <ivanm> mauke: heh
16:27:12 <ivanm> @remember mauke the first and foremost task of a haskell compiler is to break haskell programs
16:27:12 <lambdabot> It is forever etched in my memory.
16:27:18 <ddarius> blackdog: Which monad?
16:27:23 <ivanm> lambdabot: yeah, until you crash again...
16:27:25 <ivanm> >_>
16:27:29 <mauke> @flush
16:27:37 <Philippa_> blackdog: do you need a monad, or will an applicative do?
16:29:54 <blackdog> ddarius: state monad
16:30:14 <ddarius> You're going to use the state monad... in C?
16:30:29 <blackdog> my two idiomatic patterns would be a static variable (so it stops being re-entrant) or passing variables around constantly
16:30:35 <blackdog> maybe i'm being stupid
16:31:18 <blackdog> i suppose i'm still going to have to pass around a context object no matter what
16:31:53 <ddarius> Yes, the "modular" thing to do for C, would be to pass the parameters, which would be like the reader monad, and you would be implementing State via ReaderT (IORef s) IO a
16:32:14 <ddarius> But, yeah, I would just pass a mutable object around.
16:33:19 <blackdog> the threaded object is immutable, now i think about it, so even a bare Reader monad would be sufficient. probably doesn't buy me much though.
16:33:38 <sproingie> huh.  that's about when i'd reach for C++ and just use an object
16:33:53 <ddarius> I don't often use Reader by itself in Haskell.
16:33:54 <blackdog> sproingie: yeah. legacy system etc.
16:34:11 <nothingmuch> cabal update dies with "cabal: user error (Codec.Compression.Zlib: incompatible version)
16:34:15 <nothingmuch> is that related to the outage?
16:34:36 <nothingmuch> erm, no
16:34:42 <nothingmuch> that's a linkage error, right?
16:35:05 <dcoutts> nothingmuch: it usually means a truncated download
16:35:16 <nothingmuch> gzcat seems to like /Users/nothingmuch/.cabal/packages/hackage.haskell.org/00-index.tar.gz
16:35:43 <sproingie> i suspect it's Zlib not being very smart at detecting whether some random garbage is actually a gzip file
16:35:57 <sproingie> such as an error page
16:36:10 <nothingmuch> but it isn't random garbage, the 00-index.tar.gz is fine
16:36:22 <sproingie> huh.  beats me then
16:36:35 <dcoutts> nothingmuch: oh, incompatible version. You're running OSX SL right? Then it's because you've not fixed up your hsc2hs, so the zlib binding has been built thinking it's talking to the 64bit version of zlib.
16:36:45 <nothingmuch> oh
16:36:49 <nothingmuch> ok, that makes sense
16:37:14 <nothingmuch> same as /usr/bin/ghc, right?
16:37:19 <dcoutts> you already patched your ghc script, need to do the equivalent for hsc2hs
16:37:29 <dcoutts> the escape flag is different, but yes
16:37:56 <nothingmuch> and how do i rebuild zlib?
16:38:00 <nothingmuch> by hand?
16:38:39 <dcoutts> I guess you need to unpack the packages by hand, but cabal install in the dirs should work
16:38:58 <dcoutts> so you'd have to rebuild the zlib package and the cabal-install package
16:40:34 <nothingmuch> cool, seems to have worked
16:40:45 <SamB_XP_> dcoutts: can we please see some checksums and/or GPG sigs on http://hackage.haskell.org/platform/ ?
16:40:56 <nothingmuch> nope, cabal update still broken =(
16:41:43 <allbery_b> if the machine's been down for  while (as it has) there's probably some update cronjob that hasn't hd a chance to run yet
16:41:57 <nothingmuch> rebootstrapping cabal install
16:42:04 <SamB_XP_> allbery_b: should use anacron!
16:42:15 <ivanm> nothingmuch: I did cabal update just before
16:42:17 <ivanm> no problems
16:42:35 <nothingmuch> yeah the problem is on my laptop
16:42:41 <nothingmuch> ok, rerunning ./bootstarp.sh seems to have solved it
16:43:00 <ivanm> it does? weird, never heard of this bootstarp.sh script you speak of... :p
16:43:01 <allbery_b> anacron has its own problems, mainly if you leave the machine *up* (the dailies run at 24-h intervals of when you rebooted, usually meaning in the middle of Improtant Work)
16:43:14 <nothingmuch> ivanm: part of cabal-install's .tar.gz
16:43:32 <nothingmuch> i guess i could have just rerun Setup.hs since it already installed the deps for me
16:43:33 <SamB_XP_> allbery_b: oh, right ...
16:43:34 <ivanm> nothingmuch: boostSTRAP, not bootSTARP ;-)
16:43:42 <nothingmuch> oh, beh
16:44:22 <nothingmuch> ivanm: http://scsys.co.uk:8001/35145
16:44:49 <SamB_XP_> allbery_b: that thing I've been avoiding on my Debian box for the past ... oh ... month or few ...
16:45:00 <ivanm> nothingmuch: heh
16:45:24 <nothingmuch> i also have 'givm' and 'prel'
16:46:04 <ddarius> gvim, blech
16:46:28 <ivanm> so you're dylexic in how you spell? :o
16:46:38 <nothingmuch> i just type too fast for the computer ;-)
16:47:21 <nothingmuch> actually there's no excuse for 'star' instead of 'stra', that's all with the left hand
16:47:32 <nothingmuch> unless somebody wants to mock me for not using dvorak ;-)
16:47:43 * ddarius mocks nothingmuch 
16:47:51 <ddarius> oyap
16:48:02 <lament> 'ls' is very annoying with dvorak
16:48:10 <lament> (maps to p; on qwerty)
16:48:22 <nothingmuch> ddarius: you still haven't mocked the perl alias though
16:48:29 <ddarius> lament: I just drag my pinky down
16:48:41 <ddarius> alias repl=perl
16:48:50 <lament> ddarius: i do that, AND I alias u=ls
16:49:03 <ddarius> I need to add that cd.. alias.
16:49:15 <skorpan> alias u=ls is the best
16:49:17 <nothingmuch> yeah, repl perl, but not run like that
16:49:42 <nothingmuch> Devel::REPL installs re.pl which i find really annoying to type
16:49:55 <nothingmuch> puns-- # not ergonomic
16:50:15 * Berengal should alias gcc to ghc and python to ghci
16:50:29 <ddarius> Berengal: ghc can compile C programs
16:50:52 <Berengal> ddarius, I know, but gcc can compile more than C
16:50:58 <ddarius> So can GHC
16:51:04 <Berengal> Well duh :P
16:51:45 <PetRat> I'm having trouble with a use of the Rand monad. I get a stack overflow. It's a large complex program but the problem started when I added this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10927#a10927  Can someone tell me if anything looks strange about it?
16:51:49 <nothingmuch> beh, cabal install curl --reinstall seems to go fine, but my Setup.lhs still doesn't find it
16:52:23 <Ferdirand> ok
16:52:28 <Ferdirand> oops
16:52:34 <nothingmuch> http://scsys.co.uk:8001/35146 # any ideas?
16:53:10 <Poulter> Is there any way to embody logic in an anonymous function?
16:53:34 * ddarius doesn't know what "embody logic" means.
16:53:43 <ivanm> nothingmuch: "ghc-pkg list curl"
16:53:45 <Poulter> lol :P
16:53:47 <ivanm> does it show curl?
16:53:54 <nothingmuch> yes, 1.3.5
16:53:55 <Poulter> if else logic
16:53:57 * Berengal thinks vulcans are supposed to embody logic
16:54:01 <ivanm> ddarius: you represent logic, you are the very personification of logic, etc.
16:54:02 <ivanm> ;-)
16:54:05 <Berengal> Poulter, did you mean "embed"?
16:54:10 <ivanm> Berengal: no, they're just very logical...
16:54:17 <nothingmuch> Poulter: if/else is just an expression, so yes
16:54:18 <jfoutz> > (\n -> if n == 0 the True else False) 2
16:54:19 <lambdabot>   <no location info>: parse error on input `else'
16:54:27 <Berengal> Poulter, anyway, you can do whatever you want with anonymous functions, so yes
16:54:27 <jfoutz> > (\n -> if n == 0 then True else False) 2
16:54:29 <lambdabot>   False
16:54:30 <ivanm> nothingmuch: OK, so what error are you getting that your Setup.hs can't find it?
16:54:35 <ivanm> do you have curl listed in your cabal file?
16:54:43 <Berengal> Lambdas are turing complete
16:54:56 <Poulter> Okay brilliant
16:55:04 <Poulter> I think I get that :)
16:55:08 <nothingmuch> yes, it's in the cabal file
16:55:16 <nothingmuch> see the scsys.co.uk link i pasted, it's a dump of the output
16:55:38 * Berengal likes to think of '\' of being to function names what '_' is to pattern bindings
16:55:46 <ivanm> nothingmuch: can we see your cabal file?
16:56:14 <ivanm> nothingmuch: and is it a user problem (you have curl installed for one user but not another)?
16:56:20 <ivanm> nothingmuch: oh, and with the ghc-pkg list output, did it have any brackets around it or something?
16:56:44 <nothingmuch> ivanm: http://scsys.co.uk:8001/35147
16:56:45 <HugoDaniel1> hi
16:56:58 <Berengal> PetRat, suppose you only care about the last random number, you get a big thunk of random generators building up to get the last one needed to generate the last random number
16:56:58 <nothingmuch> no, it did not: http://scsys.co.uk:8001/35148
16:57:58 <ivanm> nothingmuch: hmmmm... with the first paste (34146), is that the output of trying to build curl as well as slowly?
16:58:26 <nothingmuch> ivanm: it's the output of rebuilding curl, yes
16:58:50 <Berengal> PetRat, basically, you get a long thunked dependency-chain (same as with lazy foldl) that blows the stack when the runtime attempts to evaluate it
16:58:51 <PetRat> Berengal: but I'm using all of them. I also wrote a test program that generated 1000000 randoms numbers using this construction and it worked. It is only in my larger program that it fails, so there's something I don't understand.
16:59:12 <Berengal> PetRat, are you using all of them in sequence?
16:59:16 <ivanm> nothingmuch: no idea then, sorry :(
16:59:26 <ivanm> nothingmuch: maybe clean, configure and build afresh?
16:59:30 <ivanm> (for Slowly)
16:59:38 <nothingmuch> tried =(
16:59:40 <ivanm> without doing curl again
17:00:12 <Berengal> PetRat, without looking at the entire code it can be hard to say (and even when you've got the whole code it's still hard), but I'd just find a likely place to throw in a seq or bang-pattern
17:00:13 <nothingmuch> actually... just tried configure -v3
17:00:22 <nothingmuch> it seems to do: ("/usr/bin/ghc-pkg",["dump","--global"])
17:00:29 <PetRat> Berengal: basically I'm calling map on a function that generates the number, so I think they are in order. I will review the code.
17:00:42 <nothingmuch> which of course does not list curl, since it's in my ~/.ghc
17:00:55 <PetRat> Berengal: but basically you don't see anything incorrect in that code itself?
17:01:26 <Berengal> PetRat, well, to be honest, I can't make sense of it much at all... the types are all wrong
17:02:04 <nothingmuch> ohhhhhh
17:02:06 <nothingmuch> cabal --configure
17:02:10 <nothingmuch> http://www.haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages
17:02:54 <nothingmuch> heh
17:02:55 <nothingmuch> hotAction = (.)$(.) ioAction
17:40:14 <nothingmuch> http://scsys.co.uk:8001/35149
17:40:23 <nothingmuch> i have 'base' specified in my .cabal
17:40:31 <nothingmuch> and other modules from it are working
17:40:38 <HugoDaniel1> what is the best way to define a matrix in haskell ?
17:41:25 <nothingmuch> but i see "wired-in package base mapped to base-4.1.0.0" in the output, even though -package base-3.0.3.1 is passed to ghc
17:42:39 <nothingmuch> hmm, i think i have stale packages in ~/.cabal
17:42:41 <ddarius> HugoDaniel: Use a library.
17:43:03 <sproingie> Data.Sized.Matrix perhaps
17:44:03 <sproingie> uses Data.Array under the surface
17:46:18 <nothingmuch> urf, did not help
17:46:55 <ivanm> HugoDaniel1: if you're doing a lot of actual matrix operations, hmatrix might help
17:47:12 <ivanm> if you just want a 2D structure, use an array-based structure
17:47:19 <HugoDaniel1> ah nice
17:58:58 <nothingmuch> i have a NominalDiffTime i'd like to dump as JSON with Text.JSON.Generic, but it doesn't derive Data
17:59:26 <nothingmuch> is it possible to provide one in terms of realToFrac?
18:09:44 <jre2> what's the best way to call haskell from c#?
18:10:32 <p_l> jre2: IPC? Or eventually you could play around with making DLLs in haskell and call them with P/Invoke
18:11:23 <ivanm> there's a few different .Net thingies for Haskell..
18:11:39 <ivanm> but realistically, you'd have to ask.... WHY?
18:12:02 <pumpkin> whenever somebody asks "WHY?", I feel the urge to ask "WHY NOT?"
18:12:04 <jre2> ivanm: yeah, hs-dotnet handles haskell->c# great, but my host application is c#
18:12:19 <ivanm> shut up pumpkin
18:12:21 <jrockway> C# would not be my first choice for gluing things together :)
18:12:21 <ivanm> ;-)
18:12:25 <pumpkin> :O
18:12:28 <HugoDaniel2> why ?
18:12:31 <pumpkin> DISRESPECTING THINE GOURD
18:12:34 <ivanm> jrockway: how about salsa, or whatever the other one is...
18:12:35 <HugoDaniel2> why, why not ?
18:12:42 <ivanm> pumpkin: ummm.... I'm not a big fan of gourds...
18:12:43 <HugoDaniel2> why, why, why not not ?
18:12:51 <pumpkin> ivanm: (me neither)
18:12:53 <aavogt> not why?
18:12:54 <pumpkin> BUT STILL
18:12:58 <ivanm> so I'll disrespect you all I like, you filthy yank! :p
18:12:59 <p_l> jre2: I'd recommend IPC
18:13:00 <jre2> I'm using a large amount of existing infrastructure in c#
18:13:03 <pumpkin> lol
18:13:13 * pumpkin insists that he's not a yank
18:13:13 <blackdog> jre2: you might be able to go through the C interface, but a lower stress way of doing it would be to set the Haskell up as a standalone JSON service or something similar
18:13:26 <blackdog> pumpkin: of course you are
18:13:31 <blackdog> copumpkin is ukian
18:13:34 <blackdog> so you're his dual
18:13:38 <pumpkin> :o
18:13:42 <pumpkin> UKian?
18:13:59 <pumpkin> coukian?
18:14:05 <ivanm> blackdog: ukian? he's originally from the UK?
18:14:11 <pumpkin> yep
18:14:18 * ivanm suppose that blackdog and himself would be classified as skippys...
18:14:21 <blackdog> you talk like a brit :)
18:14:22 <ivanm> *supposes
18:14:35 <blackdog> ivanm: where are you?
18:14:35 <pumpkin> blackdog: what have I said that sounds like a brit? :o
18:14:42 <SamB_XP_> blackdog: so you don't think he should be a kuin?
18:14:42 <pumpkin> ivanm is a wog
18:14:45 <ivanm> blackdog: Brisbane
18:14:51 <ivanm> pumpkin: nationality wise, I'm a skip
18:14:55 <pumpkin> ah
18:14:55 <monochrom> collectible wog
18:14:56 <blackdog> pumpkin: sense of humour, mostly. it's a little perverse :)
18:15:06 <pumpkin> blackdog: lol, can't deny that
18:15:08 <ivanm> or a "kangur" to use the more european terminology
18:15:18 <monochrom> Why do you use Haskell?
18:15:29 <pumpkin> my religion forces me to
18:15:32 <pumpkin> I don't enjoy it
18:15:44 <blackdog> ivanm: i guess i can't give you crap about brisbanity while i'm relentlessly paying out on Axman6...
18:15:46 <ivanm> @slap pumpkin
18:15:46 * lambdabot loves pumpkin, so no slapping
18:15:51 <monochrom> hahahahaha
18:15:52 <pumpkin> <3
18:15:55 <blackdog> lambdabot's so pacifist lately
18:16:05 <pumpkin> lambdabot doesn't like it when ivanm tells her what to do
18:16:07 <ivanm> blackdog: well, you're a sydneysider... what would _you_ know? :p
18:16:08 <blackdog> pacifistic? hm
18:16:10 <pumpkin> one day she'll snap and slap him back
18:16:11 <monochrom> @slap pump_kin
18:16:12 * lambdabot beats up pump_kin
18:16:16 <blackdog> ivanm: everything, by definition
18:16:28 <aavogt> @slap pumpkine
18:16:44 <pumpkin> aavogt gets no love
18:16:49 <ivanm> blackdog: bah
18:16:49 * lambdabot puts on her slapping gloves, and slaps pumpkine
18:16:50 <blackdog> ivanm: are you a student, or a random haskell hacker?
18:17:05 <ivanm> blackdog: atm, the latter
18:17:11 <pumpkin> ivanm is so random
18:17:30 <ivanm> but next year I'll be almost definitely be joining Axman6 at ANU doing a PhD; but it won't officially be with Haskell
18:17:35 <ivanm> (I'll be trying to use it though)
18:17:40 <pumpkin> Axman6 is an undergrad though
18:17:50 <ivanm> pumpkin: hardware random or PRNG? :p
18:17:51 <blackdog> pumpkin: he'll be a real person soon, though
18:17:56 <monochrom> random logic is not random. exercise: make a yo dawg meme based on that.
18:18:01 <ivanm> pumpkin: at the same university...
18:18:04 <SamB_XP_> blackdog: undergrad /= fake person
18:18:05 <ivanm> @slap blackdog
18:18:05 <lambdabot> stop telling me what to do
18:18:20 <pumpkin> yo dawg, I heard you liked pseudorandomness so I stuck a PRNG in your PRNG so you can gain no entropy by doing so
18:18:38 <blackdog> SamB_XP_: Sure. Still fun to tease him about it though.
18:18:42 <blackdog> even in his absence
18:18:47 <ivanm> blackdog: heh
18:19:08 <SamB_XP_> like, sorear is a real person even if he's still in highschool (which I'm not sure if he is -- if he's not, that might explain why he's not been around!)
18:19:08 <pumpkin> ivanm: but anyway, I prefer "international man of mystery" to "damn yank" for future reference
18:19:20 <ivanm> pumpkin: I can call you a seppo if you prefer... >_>
18:19:23 <ivanm> <_<
18:19:27 <pumpkin> which is seppo?
18:19:36 <pumpkin> oh
18:19:39 <pumpkin> another american word
18:19:39 <ivanm> blackdog: should we explain "seppo" to pumpkin? :p
18:19:41 <blackdog> septic tank
18:19:46 <ivanm> rhymes with yank
18:19:47 <ivanm> ;-)
18:19:49 <pumpkin> lol
18:19:57 <blackdog> clear, me old china plate?
18:20:04 <aavogt> ivanm: is such slang common?
18:20:15 * pumpkin gives up :)
18:20:17 <ivanm> aavogt: seppo is no longer that common; yank is still common
18:20:24 <ivanm> (but then yank is common everywhere, is it not?)
18:20:32 <ivanm> aavogt: rhyming slang in general isn't common much anymore
18:20:33 <SamB_XP_> doesn't that mean "cut"?
18:20:38 * ivanm blames yanks like pumpkin for that...
18:20:44 <pumpkin> lol
18:20:51 <blackdog> SamB_XP_: cut?
18:20:54 <pumpkin> I wasn't even a yank until a few years ago
18:20:55 <aavogt> umm, I'm not surprised when people say yank in Canada
18:21:35 <monochrom> Actually, random logic refers to building a digital circuit with lots of low-density chips, each chip merely a few logic gates. IOW you wire up primitive logic gates yourself, as opposed to fab'ing a VLSI. So there is nothing random about it, not even pseudorandom, apart from being a mess.
18:21:35 <blackdog> aavogt: it's actually hard to think of many, because they blend into the background and you forget they were originally rhyming slang
18:21:44 <ivanm> pumpkin: fine, if you prefer to be known by your british heritage, I can refer to you as a pom then
18:21:48 <ivanm> ;-)
18:21:52 <pumpkin> I don't feel british either
18:22:03 <pumpkin> as I said, "international man of mystery" kthx
18:22:04 <ivanm> what do you feel as then?
18:22:07 <ivanm> nah
18:22:09 <pumpkin> nothing :P
18:22:11 <ivanm> not derogative enough
18:22:14 <blackdog> pumpkin: if you don't identify as from somewhere, we can't make fun of you when your sports teams lose
18:22:22 <ivanm> (unless you're referring to the bad hygiene, teeth, etc.?)
18:22:23 <blackdog> not cricket, old son
18:22:26 <pumpkin> lol
18:22:38 <ivanm> blackdog: s/when your sports team lose// ;-)
18:24:11 <pumpkin> anyway, if you really want to say I'm from somewhere, make it italy, but I'm not really from there either :P
18:24:25 <ivanm> so you're an itey?
18:24:29 <ivanm> with a monkey? :p
18:24:33 <pumpkin> yeah, or a wop or whatever
18:24:58 <pumpkin> itsa me, mario!
18:25:00 * ivanm finds pumpkin's name reported on /whois to be strangely familiar...
18:25:23 <pumpkin> oh that was left over from a while ago :P
18:25:58 <ivanm> when Gladiator came out?
18:26:04 <pumpkin> not that long ago
18:26:11 <bwwww> i am having trouble installing HDBC using cabal. http://pastie.org/661450 . any ideas? (I am a complete newbie learning haskell)
18:26:23 <Cale> Does anyone know if there's an option for X to smooth mouse movement? My new mouse has a very slight problem with "jittering" and I can't draw smooth lines or curves.
18:26:47 <Cale> (sorry about the offtopic, just putting it out there :)
18:26:50 <ivanm> looks like bwwww's problem is library dep related...
18:27:28 <ivanm> bwwww: are you using 6.10?
18:27:33 <monochrom> your laser mouse is so sensitive it registers quantum fluctuations
18:27:38 <ivanm> if so, then it's a known problem: http://hackage.haskell.org/packages/archive/HDBC/2.1.1/logs/failure/ghc-6.10
18:27:44 <bwwww> The Glorious Glasgow Haskell Compilation System, version 6.10.4
18:27:56 <pumpkin> GLORY BE UPON YOU!
18:27:58 <ivanm> Cale: after all, this converstaion we've been having is _so_ on-topic!
18:28:06 <ivanm> pumpkin: AND UPON YOU BE GLORY!
18:28:09 <monochrom> hmm compilation system
18:28:12 <bwwww> ivanm,  ah
18:28:12 <pumpkin> AMEN BROTHER
18:28:29 <monochrom> the glorified compilation oh so system
18:28:45 <ivanm> bwwww: maybe try with base-3 ?
18:28:51 <ivanm> bwwww: how are you installing it?
18:29:17 <ivanm> no, wait, it pretends to work for base-4...
18:29:27 <bwwww> ivanm, I am using macports. What is base-3? I don't know much haskell jargon. I have been using hugs before now.
18:30:09 * Warrigal ponders how to get the Cartesian product of two lists.
18:30:18 <ivanm> bwwww: no idea about macports; base is the "base library" (hence the name) that comes with GHC
18:30:49 <monochrom> The wonder stops here. [ (x,y) | x<-['a','b'], y<-[True,False] ]
18:31:02 <Warrigal> Well, that's easy enough.
18:31:23 <SamB_XP_> @incomprehend [ (x,y) | x<-['a','b'], y<-[True,False] ]
18:31:24 <lambdabot> Unknown command, try @list
18:31:25 <SamB_XP_> aww
18:31:46 <aavogt> @undo  [ (x,y) | x<-['a','b'], y<-[True,False] ]
18:31:47 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [True, False]) ['a', 'b']
18:32:03 <aavogt> SamB_XP_: I guess undo just needs another alias
18:32:07 <ivanm>  @undo works on list comprehensions as well? :o
18:32:21 <SamB_XP_> @. pl undo [ (x,y) | x<-['a','b'], y<-[True,False] ]
18:32:22 <lambdabot> ([True, False] >>=) . flip flip [] . ((:) .) . (,) =<< "ab"
18:33:08 <SamB_XP_> @. pl undo \xs ys -> [ (x,y) | x<-xs, y<-ys ]
18:33:09 <lambdabot> (. flip ((=<<) . flip flip [] . ((:) .) . (,))) . (>>=)
18:33:13 <dolio> > (,) <$> "ab <*> [True,False]
18:33:14 <lambdabot>   <no location info>:
18:33:14 <lambdabot>      lexical error in string/character literal at end o...
18:33:21 <dolio> > (,) <$> "ab" <*> [True,False]
18:33:22 <lambdabot>   [('a',True),('a',False),('b',True),('b',False)]
18:33:39 <dolio> Good job, pl.
18:33:53 <bwwww> ivanm, thanks. The thought of having to recompile ghc makes me want to cry. I think I will just write a script to full out the data from the db into a csv and parse it in haskell. It was a practical learning excersie and this should teach me just as much.
18:34:21 <ivanm> bwwww: nothing like that
18:34:21 <ivanm> you don't have to recompile GHC (unless you want to downgrade...)
18:34:27 * Warrigal goes and solves a bunch of Euler problems.
18:35:10 <Warrigal> Neat, I now have twice as many problems solved. :-P
18:35:25 <aavogt> > 2*1
18:35:26 <lambdabot>   2
18:36:24 <blackdog> your first mistake was solving any. as long as your tally sits at zero you're capable of infinite productivity increases
18:36:37 <Warrigal> Hmm, you're right.
18:36:43 <Warrigal> Oh well, on to problem 7!
18:37:09 * Warrigal tries to implement the Sieve of Eratosthenes.
18:37:13 <bwwww> ivanm, cool. in /opt/local/lib/ghc-6.10.4/ I have base-3.0.3.1 and base-4.1.0.0 ... can I switch between  them or something? Sorry, I am a complete newbie.
18:39:06 <aavogt> bwwww: yes
18:39:24 <bwwww> aavogt, how do I go about switching?
18:39:38 <aavogt> cabal packages can request specific other packages, you can also pass to ghc or ghci -package base-3.0.3.1
18:41:53 <bwwww> aavogt, so I need to edit the cabal package file?
18:44:16 <blackdog> Warrigal: ah, that's a cute one in haskell. you're taking a lazy list approach, i hope..
18:45:22 <aavogt> bwwww: yes, but if you use cabal install it apparently chooses base3 for unbounded base dependencies
18:49:35 * Warrigal implements trial division instead.
18:51:21 <aavogt> > nubBy (flip $ fmap (==0) . mod) [2..]
18:51:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
18:51:33 <aavogt> > nubBy (fmap (==0) . mod) [2..]
18:51:35 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:54:42 <Warrigal> While very brief, that's also pretty inefficient.
18:55:13 <aavogt> > nubBy (fmap (==0) . mod) [2..] !! 2000
18:55:17 <lambdabot>   mueval-core: Time limit exceeded
18:55:21 <aavogt> > nubBy (fmap (==0) . mod) [2..] !! 1000
18:55:21 <monochrom> obsession with trial division is unhealthy.
18:55:25 <lambdabot>   mueval-core: Time limit exceeded
18:56:21 <aavogt> > nubBy (fmap (==0) . mod) [2..] !! 500
18:56:24 <lambdabot>   3581
19:00:19 <Warrigal> @hoogle inits
19:00:19 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
19:00:19 <lambdabot> Data.List inits :: [a] -> [[a]]
19:00:19 <lambdabot> Data.ByteString.Char8 inits :: ByteString -> [ByteString]
19:02:22 <bwwww> aavogt and ivanm, thanks I will try figure something out
19:10:40 <ksf> hmmm elerea uses a monad essentially only to provide references that obey the sharing laws, am I correct?
19:10:50 <BMeph> nubBy (((>1).).gcd) [2..]
19:10:56 <BMeph> > nubBy (((>1).).gcd) [2..]
19:10:57 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:11:32 <ksf> ...in that it doesn't bleeding matter in which order graph nodes are created. it's a monadfix, after all.
19:13:12 <ksf> shouldn't it be possible to factor out these unsafePerformIOs to the outside of the library? i.e. define a proto-network that has to be transformed into executable form before it can be superstepped?
19:21:43 <Warrigal> @hoogle on
19:21:44 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:21:44 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
19:21:44 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
19:24:48 <Warrigal> Dear stack overflow: Please don't happen. Love, Warrigal.
19:25:01 <Warrigal> There, I'm sure that will work.
19:26:27 <Warrigal> Also, GHCi, I said ^C. Is that not clear enough? What else must I do to get you to stop computing?
19:26:32 <Warrigal> Darn, it crashed.
19:26:55 <Warrigal> Note to self: don't do maximum [1..].
19:28:09 <ivanm> heh
19:28:20 <ivanm> @remember Warrigal Note to self: don't do maximum [1..].
19:28:20 <lambdabot> Done.
19:28:26 <ivanm> > maximum [1..] :: Int
19:28:33 <lambdabot>   mueval: ExitFailure 1
19:28:40 <ivanm> hmmmmm.... too big for lambdabot...
19:28:50 <ivanm> > maxBound :: Int
19:28:52 <lambdabot>   9223372036854775807
19:28:59 <ivanm> ahhh, 64bit machine
19:30:54 <dolio> @src maximum
19:30:55 <lambdabot> maximum [] = undefined
19:30:56 <lambdabot> maximum xs = foldl1 max xs
19:33:19 <ivanm> dolio: too much laziness?
19:33:28 <ivanm> > foldl1' max [1..] :: Int
19:33:32 <dolio> Yeah.
19:33:32 <lambdabot>   mueval-core: Time limit exceeded
19:33:43 <ivanm> OK, but strict version doesn't like it either...
19:33:47 <ivanm> > foldr1 max [1..] :: Int
19:33:48 <lambdabot>   * Exception: stack overflow
19:33:50 <ivanm> heh
19:33:57 <dolio> It builds a giant thunk max (2^63) (max (2^63-1) ...)
19:34:00 <ivanm> three different folds, three different errors ;-)
19:34:06 <ivanm> dolio: yeah
19:34:22 * ivanm wonders if the explicit foldl1 makes a difference...
19:34:28 <ivanm> > foldl1 max [1..] :: Int
19:34:35 <lambdabot>   mueval-core: Time limit exceeded
19:34:57 <ivanm> OK, as maximum it has an ExitFailure; as explicit fold it has a time limit exceeded...
19:35:15 <dolio> > maximum [1..] :: Int
19:35:21 <lambdabot>   mueval: ExitFailure 1
19:35:28 <dolio> That's rather odd.
19:36:27 <ivanm> dolio: inlining, fusion, etc. for maximum?
19:38:07 <dolio> I suppose I don't know what ExitFailure means.
19:38:45 <Warrigal> Why would something like maximum be lazy?
19:38:55 <Axman6> > max (2^64) (2^64-1)
19:38:56 <lambdabot>   18446744073709551616
19:38:59 <dolio> I'd expect it to run out of time either way, since doing 2^63 comparisons isn't likely to fit in the 10 seconds or whatever you have.
19:39:06 <Axman6> Warrigal: who knows
19:39:33 <ivanm> hey Axman6
19:39:38 <Axman6> o/
19:39:48 <blackdog> Axman6: i've been bollocking you in your absence
19:39:49 <dolio> foldl' isn't in the Haskell 98 report, so nothing defined there uses it.
19:40:05 <Axman6> blackdog: glad to hear it
19:40:12 <dolio> GHC has rules that make maximum strict on [Int] and [Integer].
19:40:34 <Axman6> would be nice if it did the same for Float and Double
19:42:04 <Warrigal> Ooh, so maximumBy isn't strict.
19:42:07 <ivanm> Axman6: apparently you're not human! :o
19:42:08 <ClaudiusMaximus> > maximum [1..] > (64 :: Natural)
19:42:14 <Axman6> so i've heard
19:42:15 <lambdabot>   mueval: ExitFailure 1
19:42:37 <SubStack> silly blogs saying haskell has no for loops
19:42:57 <lament> haskell has for loops?
19:43:01 <Axman6> forM
19:43:02 <Axman6> >_>
19:43:03 <SubStack> it has forM AND forM_
19:43:24 <SubStack> that's one more than C has
19:43:30 <lament> those are foreach loops :)
19:43:47 * SubStack makes no distinction
19:44:33 <ivanm> SubStack: you would if you had to keep using a for loop when you really wanted a forEach loop as a poor man's map or fold...
19:44:47 <lament> hehe
19:45:25 <SubStack> in perl foreach is a proper subset of for, and for is shorter, so that's what I always use
19:45:51 <ClaudiusMaximus> > genericLength [1::Natural ..] > (64 :: Natural)
19:45:54 <lambdabot>   True
19:46:46 <morganson> hello everyone
19:47:32 <dolio> > genericLength ['a'..] > (64 :: Natural)
19:47:34 <lambdabot>   True
19:48:55 <ClaudiusMaximus> > genericLength [1::Natural] :: Natural > genericLength ['a'..]
19:48:59 <lambdabot>   <no location info>: parse error on input `''
19:55:28 <nothingmuch> /w 84
19:55:37 <jmcarthur> a real for loop would not be that hard to do in haskell
19:56:00 <jmcarthur> with initialization, loop condition, update, etc.
19:56:18 <SamB_XP_> but it's not at all *nice*
19:56:28 <jmcarthur> not nice in a haskelly way
19:56:30 <SamB_XP_> because the variables, they are not mutable
19:56:43 <jmcarthur> sure they are. just do it in IO or ST
19:56:45 <SamB_XP_> you woul need to use some kind of references, and that's ugly in Haskell ... for a good reason
19:56:59 <jmcarthur> it wouldn't be that ugly
19:57:43 <jmcarthur> no uglier than in C, for certain
19:58:00 <jmcarthur> (which is pretty ugly, but that's the kind of standard we are weighing against here)
20:02:16 <Warrigal> Do the Haskell standard libraries have matrix multiplication yet?
20:03:02 <jmcarthur> Warrigal: no, but hackage has a few libraries that provide that
20:03:10 <sohum> > foldr f [a,b,c,d,e]
20:03:11 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
20:03:11 <lambdabot>    arising fr...
20:03:19 <sohum> > foldr f [1,2,3,4,5]
20:03:20 <lambdabot>   No instance for (SimpleReflect.FromExpr [t])
20:03:20 <lambdabot>    arising from a use of `Simp...
20:03:28 <Saizan> > foldr f z [a,b,c,d,e]
20:03:29 <lambdabot>   f a (f b (f c (f d (f e z))))
20:03:29 <jmcarthur> > foldr f x [a,b,c,d,e]
20:03:30 <lambdabot>   f a (f b (f c (f d (f e x))))
20:03:35 <SamB_XP_> Warrigal: the thing is, most of us usually want type-level dimensions for those ;-)
20:03:47 <SamB_XP_> that isn't really possible in standard Haskell by any stretch
20:04:04 <jmcarthur> well, sure it is, it's just either ugly or limited
20:04:12 <pumpkin> yeah it is
20:04:20 <pumpkin> I have that SHE module that does matrix multiplication with safe dimensions
20:04:24 <jmcarthur> ugly when we do type level naturals, limited when we write individual types
20:04:32 <SamB_XP_> okay, so Oleg could do it I guess
20:04:34 <Warrigal> data SquareMatrixOfDimensionTwoThousandNineByTwoThousandTen a = . . .
20:04:49 <SamB_XP_> Warrigal: yeah, that's identifier-level
20:04:52 <SamB_XP_> those aren't good enough
20:04:54 <pumpkin> it's not that bad
20:04:56 <SamB_XP_> ;-)
20:05:10 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890
20:05:22 <Warrigal> Hmm, I don't want a 20092010x20092010 matrix, I want a 2000x2000 matrix.
20:05:34 <Warrigal> I hope naive matrix multiplication is fast enough.
20:05:52 <pumpkin> Warrigal: that paste contains naive matrix multiplication with safe type-level sizes
20:06:12 <Warrigal> How long does it take to naively multiply two 2000x2000 matrices, I wonder.
20:06:18 <pumpkin> a long time, I expect
20:06:27 <pumpkin> you can try it with lists and see
20:06:51 * Warrigal ponders naive matrix addition.
20:07:13 <jmcarthur> > 2000^3
20:07:14 <lambdabot>   8000000000
20:07:22 <jmcarthur> probably around that many multiplications
20:07:31 <Warrigal> That's a lot.
20:07:32 <pumpkin> yep, plus I call transpose
20:07:36 <pumpkin> which makes it painful
20:07:41 <jmcarthur> ew
20:07:42 <jmcarthur> :P
20:07:44 <pumpkin> hey, it's the simplest way
20:07:47 <SamB_XP_> Warrigal: what is this "matrix addition" thing ?
20:07:50 <jmcarthur> yeah
20:07:57 <pumpkin> I dare you to write matrix multiplication in a shorter expression
20:08:00 <Warrigal> transpose will probably make it a lot faster.
20:08:11 <pumpkin> my matrix addition code is simply liftA2 (+) :P
20:08:14 <jmcarthur> I dare not
20:08:22 <Warrigal> liftA2? Never heard of it.
20:08:37 <stoop> :t liftA2
20:08:39 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:08:42 <stoop> :t liftA
20:08:43 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
20:08:44 <Warrigal> But now I have.
20:08:46 <jmcarthur> Warrigal: for this case, lifts a function to work elementwise
20:08:53 <stoop> > liftA (+ 1) (Just 2)
20:08:55 <Warrigal> I hope [] is an Applicative.
20:08:55 <lambdabot>   Just 3
20:08:58 <pumpkin>  it is
20:09:01 <pumpkin> and so is Mat
20:09:02 <ksf> arrrgh haskell.
20:09:05 <jmcarthur> Warrigal: it is, but it's the wrong one for you
20:09:08 <Warrigal> @hoogle transpose
20:09:09 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
20:09:09 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
20:09:09 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
20:09:18 <Warrigal> jmcarthur: it is?
20:09:20 <pumpkin> luckily, Vec has the correct Applicative instance
20:09:25 <jmcarthur> Warrigal: you would want ZipList for the elementwise semantics
20:09:33 <Warrigal> Oh, that too.
20:09:44 <jmcarthur> or you can use pumpkin's Vec stuff ;)
20:09:52 * Warrigal writes an unsafe matrix.
20:09:56 <pumpkin> the Vec stuff I actually lifted from Conor's SHE example
20:10:03 <ksf> there I am, wondering why I get such a simple instace like     map f l = (map f) <$> l wrong, not noticing that the reason ghc complains about a type mismatch is me messing up the declared type of the instance.
20:10:05 <pumpkin> I just expanded it and added the matrix stuff, multiplication, etc.
20:10:07 <jmcarthur> *Conor's Vec stuff
20:10:11 <jmcarthur> ;)
20:10:12 <pumpkin> (and vector-space instances)
20:10:18 <jmcarthur> yay vector-space
20:10:28 <pumpkin> it didn't fit beautifully
20:10:33 <pumpkin> but I do have all the useful instances I think
20:10:33 <jmcarthur> oh?
20:10:36 * jmcarthur looks
20:10:39 * ksf uses scot's stuff
20:11:10 <jmcarthur> pumpkin: Scalar a ~ a? is that what you are referring to?
20:11:19 <pumpkin> yeah, made me feel dirty
20:11:27 <jmcarthur> i think it is not an uncommon idiom
20:11:28 <pumpkin> I'd appreciate it if you can remove that constraint
20:11:36 <pumpkin> ah
20:11:48 <Warrigal>   Matrix x * Matrix y = [ [ sum (zipWith (*) xs ys) | ys <- transpose y ] | xs <- x ]
20:11:52 <Warrigal> Does that look nice?
20:12:02 <pumpkin> that's pretty much what I had
20:12:25 <pumpkin> except I needed a newtype to satisfy all the type-level stuff
20:12:32 <Warrigal> @index liftA2
20:12:33 <lambdabot> bzzt
20:12:40 <pumpkin> Control.Applicative
20:13:50 <Warrigal> Hmm, Matrix x + Matrix y = Matrix (liftA2 (+) x y) doesn't work.
20:14:02 <pumpkin> you need an applicative instance
20:15:47 <jmcarthur> ZipList :. ZipList    -- tada!
20:15:59 <pumpkin> whose :. is that?
20:16:05 <Warrigal> Matrix x + Matrix y = Matrix (zipWith (zipWith (+)) x y)
20:16:11 <jmcarthur> that would have to be conal's i think
20:16:17 <ksf> @pl map f = liftA (map f)
20:16:17 <lambdabot> map = fix (liftA .)
20:16:18 <pumpkin> Warrigal: newtype Matrix a = [[a]] ?
20:16:26 <ksf> oh no that's more than evil.
20:16:32 <Warrigal> pumpkin: pretty much, yeah.
20:16:39 <pumpkin> oh, plus a constructor :P
20:17:15 <Warrigal> You know, I didn't know you could arbitrary leave class methods undefined.
20:17:23 <ksf> @pl     map f l = (map f) <$> l
20:17:23 <lambdabot> map = fix ((<$>) .)
20:17:28 * Warrigal adds the declaration "instance Eq (a -> b) where" to his program.
20:17:35 <pumpkin> some of them have default implementation, others don't
20:17:37 <SamB_XP_> Warrigal: well, typically you get a warning ;-P
20:17:43 <Warrigal> I do get a warning.
20:17:48 <pumpkin> it can be dangerous in some cases
20:17:56 <pumpkin> if you implement the wrong methods in Ord
20:17:57 <SamB_XP_> and it doesn't really work too well if you try to actually use the instance!
20:18:03 <pumpkin> you'll just get a loop
20:18:10 <jmcarthur> it would be nice if ghc would analyze the dependencies of type class functions to warn you when you haven't satisfied a minimally complete set
20:18:14 <chaosape> are recusive symbols on the RHS always replaced by bottom in the type-checker?
20:18:15 <pumpkin> yeah
20:18:22 <c_wraith> Wait.  Why does System.Random.Mersenne MTGen not implement RandomGen?
20:18:31 <pumpkin> c_wraith: split I think
20:18:40 <pumpkin> nobody likes split :P
20:18:44 <c_wraith> oh.  that makes sense.
20:18:44 <jmcarthur> c_wraith: dependence on a global? or is this a pure one?
20:18:46 <c_wraith> sadly
20:18:52 <pumpkin> in theory it's awesome
20:18:55 <SamB_XP_> split would be cool if it had any theory
20:18:57 <pumpkin> but in practice nobody knows how to write it
20:18:57 <c_wraith> it's the impure one, jmcarthur
20:19:06 <jmcarthur> i think MTGen is just a token representing a global variable
20:19:22 <jmcarthur> but yeah, split is probably the real reason
20:19:47 <Warrigal> *Main> Matrix [[1,0],[1,0]] * Matrix[[1,1],[1,0]]
20:19:47 <Warrigal> Matrix [[ModFun 1,ModFun 1],[ModFun 1,ModFun 1]]
20:20:00 <Warrigal> Oh, wait, that's right, isn't it.
20:21:31 <Warrigal> Hmm.
20:21:45 <Warrigal> *Main> Matrix [[1,0],[1,0]] * Matrix[[1,1],[1,0]]
20:21:48 <Warrigal> Grr.
20:21:51 <Warrigal> fromInteger x = ModFun (fromInteger x `mod` 20092010)
20:22:06 <Warrigal> That's giving me a stack overflow.
20:22:17 <morganson> I want to test my property that I have done. I include Test.QuickCheck. I open gchi and type "quickCheck prop_Thepropertyname". It doesn't work. What am I doing wrong?
20:22:22 <jmcarthur> > 1 `mod` 20092010
20:22:23 <lambdabot>   1
20:22:40 <Warrigal> But it only gives me a stack overflow for negative numbers.
20:22:46 <jmcarthur> > -1 `mod` 20092010
20:22:46 <Warrigal> > -1 `mod` 20092010
20:22:46 <lambdabot>   -1
20:22:47 <lambdabot>   -1
20:22:51 <Warrigal> Well, that ain't the behavior I want.
20:23:17 * Warrigal replaces that with rem, thereby not fixing the problem.
20:23:22 <jmcarthur> morganson: what does it say?
20:23:33 <morganson> <interactive>:1:0: Not in scope: `quickCheck'
20:23:40 <c_wraith> It feels silly to have a typeclass for things that can generate random numbers that isn't then used, and I end up having to code against a specific random implementation
20:23:43 <c_wraith> *sigh*
20:23:46 <jmcarthur> morganson: :m + Test.QuickCheck
20:24:02 <pumpkin> c_wraith: yep
20:24:08 <jmcarthur> yeah :(
20:24:21 <morganson> It worked. Thank you.
20:24:28 <jmcarthur> np
20:24:29 <morganson> What was the problem?
20:24:40 <morganson> Why did it not work?
20:24:50 <jmcarthur> morganson: you needed the quickcheck stuff in scope in your ghci session
20:25:21 <morganson> ok so how do I go back to Prelude Exer1>?
20:25:41 <jmcarthur> if you used + like i showed then you should already have everything else in scope
20:25:43 <Warrigal> What's that esoteric GHCi command to show simplified expressions or whatever those things are called?
20:25:53 <pumpkin> @pl in lambdabot, ghci doesn't do that
20:25:54 <jmcarthur> if you want to make quickcheck go out of scope you can use - instead of +
20:25:54 <lambdabot> (line 1, column 1):
20:25:54 <lambdabot> unexpected reserved word "in"
20:25:54 <lambdabot> expecting white space, "()", natural, letter or digit, lambda abstraction or expression
20:26:20 <jmcarthur> Warrigal: you could also install the pointfree package, which gives you an executable
20:26:20 <morganson> thank you
20:26:41 <jmcarthur> Warrigal: i'm not sure how well that one matches up with @pl though
20:27:15 * ksf wants functors from TypeClass a to TypeClass b
20:27:34 <BMeph>  ':pf' in GHCi; lambdabot doesn't do that.... ;p
20:28:09 <Warrigal> I seem to remember something that displayed something that looked a lot like the expression that went in, but wasn't exactly Haskell.
20:28:22 <Warrigal> Maybe it was something Hugs did.
20:29:18 <BMeph> Use Drugs, not Hugs! >:(
20:29:23 <rsnake> Hey guys
20:30:05 <rsnake> Say I want to write a function in a couple of lines... is foo x y = \n x*y ok?
20:30:16 <rsnake> (\n representing a newline)
20:30:30 <ksf> yep
20:30:37 <ksf> well you've got to indent, I think.
20:31:04 <ksf> expressions don't use layout syntax
20:31:08 <c_wraith> Oh, bah.  Now I see how impure this is...  Bah.  Is there a more pure mersenne twister package?
20:31:59 <ksf> ...but top-level declarations do, so you can't have the first non-whitespace character after the = on the same level as the first character of the function.
20:32:24 <rsnake> hmmm... haskell indentation isn't really clear to me. What's a good place to learn how to indent in haskell?
20:32:26 <ksf> c_wraith, if you'd like to indulge in a bit of c hacking, there will be.
20:32:45 <ksf> I've learned it by doing.
20:32:51 <c_wraith> Oh. there's mersenne-random-pure64
20:32:52 <luite> c_wraith: you mean, like, mersenne-random-pure64?
20:32:58 <luite> oh too late :
20:32:59 <luite> :)
20:33:08 <c_wraith> hehe.  thanks anyway. :)
20:33:25 <jmcarthur> c_wraith: perhaps you could wrap the impure version in a supply comonad or some sort?
20:33:27 <jmcarthur> *of some sort
20:33:34 <ksf> there should be a conscise overview of the layout rules in the haskell98 report
20:33:51 <c_wraith> I don't need the speed of the impure version, I don't think.
20:34:13 <jmcarthur> the impure one is still faster than System.Random i think
20:34:15 <ksf> the impure version isn't fast.
20:34:17 <jmcarthur> *pure
20:34:52 <jmcarthur> i thought the impure one was fast... or maybe that is only if you build with special flags
20:34:58 <ksf> ...as pulling single values out of smft is quite slow. there's an array interface, but it's not used in the bindings.
20:35:11 <c_wraith> The array interface is in the bindings, actually
20:35:16 <c_wraith> But it's not what I need.
20:35:18 <jmcarthur> regardless, the pure one is still faster than system.random iirc, which is nice
20:35:46 <c_wraith> And I still expect to be waiting on user input essentially 99% of wall time anyway.  :)
20:36:02 <luite> but it is not splittable, unfortunately
20:36:06 * bos pimps his random code, which is pure, and faster than mersenne-random, too
20:36:30 <jmcarthur> that's statistics package, right?
20:36:31 <bos> splitability is a myth anyway.
20:36:34 <bos> right.
20:36:43 <jmcarthur> been meaning to peek at that
20:36:50 <ksf> yep we need cycle condensators. so that we don't waste all that idle time.
20:36:56 <SamB_XP_> bos: or, at least, nobody has established any theory regarding split
20:37:12 <bos> SamB_XP_: that puts it in the "flying spaghetti monster" category of useful tools.
20:37:21 <pumpkin> I thought there was one paper on it and that was about it
20:37:32 <bos> one paper with no number theoretic analysis.
20:37:43 <SamB_XP_> well, splitability isn't a myth if nobody has actually made any claims that are mythical
20:37:45 * blackdog loves #haskell standards
20:37:54 <bos> so about as trustworthy as a paper written by any other non-statistician.
20:37:57 <bos> i.e. not.
20:38:14 * Warrigal declares his matrix multiplication doohickey to work.
20:38:30 <Warrigal> Now to decide what 2000x2000 matrix I want to multiply.
20:38:46 <sproingie> what is the whole idea behind split?
20:38:48 <SamB_XP_> so, more like splittability is baseless ...
20:39:09 <pumpkin> > transpose . map (join replicate) $ [1..5]
20:39:11 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
20:39:15 <jmcarthur> sproingie: create two PRNG generators from one, basically
20:39:18 <jmcarthur> err
20:39:22 <jmcarthur> PRNGs
20:39:25 <luite> sproingie: getting two independent generators from one (so you can use one to generate an infinite list of randoms and stil have a generator left)
20:39:27 <sproingie> jmcarthur: right, for what purpose?
20:39:31 <bos> PRNG generator generators.
20:39:35 <Warrigal> Alternatively, use a PRNG as a PRNG generator. :-P
20:39:45 <jmcarthur> sproingie: so that you can use one to generate an infinite supply of random values and still have another to use for other things
20:40:10 <jmcarthur> sproingie: or, more generally, allow one to be used lazily while another is used in another way
20:40:22 <sproingie> are they both seeded the same?
20:40:25 * bos will believe that split is a lie in the same way that the cake is a lie until he sees a reputable paper analysing it.
20:40:37 <pumpkin> the cake wasn't a lie!
20:40:42 <jmcarthur> sproingie: theoretically they should generate independent sequences
20:40:45 <SamB_XP_> please don't talk about that
20:40:50 <SamB_XP_> I haven't played that game yet
20:40:52 <pumpkin> it wasn't a lie!
20:40:54 <pumpkin> ok
20:41:04 <sproingie> why not just get a new instance with a new seed then?
20:41:14 <jmcarthur> sproingie: pure code prevents something like that
20:41:29 <jmcarthur> where would you get it from?
20:42:58 <sproingie> :t split
20:42:58 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:44:05 <sproingie> oh right.  can't get a source for a new seed in pure code
20:44:22 <sproingie> silly bunt
20:45:04 <FunctorSalad> bos: a lie in a stronger way than it is a lie that the values yielded by the original generator are independent?
20:45:10 * ksf can now officially blame not grokking integrals in-depth to his math teacher.
20:45:36 <ksf> area calculations alone are just not abstract enough to convey the principle
20:45:41 <luite> sproingie: you also wouldn't want to use an external random source there if you need repeatable simulations
20:45:41 <bos> FunctorSalad: there's a good chance that it is a less true assertion, yes.
20:46:16 <bos> FunctorSalad: e.g. that the results of two PRNGs after a split are correlated in a way that they would not otherwise be.
20:46:25 <FunctorSalad> (it is a 100% lie, since independence is kinda the opposite of determinism)
20:48:28 <jmcarthur> FunctorSalad: PRNGs themselves are lies by that criteria (which i basically true, but perhaps it defeats the purpose of the distinction?)
20:48:42 <jmcarthur> FunctorSalad: as they are deterministic
20:48:53 <jmcarthur> *which is
20:48:57 <FunctorSalad> that's what I said :)
20:49:45 <FunctorSalad> but there may be a more practically relevant correlation between the two splitted generators, as bos said
20:50:04 * Warrigal watches GHCi output 4,000,000 matrix entries.
20:51:06 <jmcarthur> true
20:51:08 <Warrigal> @src (^)
20:51:08 <lambdabot> x ^ 0            =  1
20:51:08 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
20:51:08 <lambdabot>   where f _ 0 y = y
20:51:08 <lambdabot>         f x n y = g x n
20:51:08 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
20:51:10 <lambdabot>                       | otherwise = f x (n-1) (x*y)
20:51:12 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
20:51:39 <performance> does some one have a lot of time on their hand? :)
20:51:57 <pumpkin> performance: ?
20:52:02 <Warrigal> Whew, so it is feasible to take something to the 5*10^14th power.
20:52:18 <sproingie> i guess i can see why mersenne doesn't do split.  doesn't mersenne twister have a lot of internal state?
20:52:33 <ivanm> yes
20:52:38 <ivanm> especially the non-pure one
20:52:41 <c_wraith> well.  The real problem is that it's not something that's obviously a good idea anyway.
20:52:50 <c_wraith> err.  not an obviously good idea.
20:52:53 <performance> pumpkin: i need some hand holding with making a webpage/site  :)
20:53:01 <pumpkin> performance: how did you get here?
20:53:13 <performance> ?
20:53:16 * Warrigal has his computer do that.
20:53:18 <ivanm> c_wraith: realistically, the only reason I've ever used split is when calling randoms, as it doesn't return the generator back (for good reason...)
20:53:38 * ivanm passes performance a fake hand he picked up somewhere for him to hold
20:53:39 <ivanm> ;-)
20:53:47 <performance> pumpkin:  through chatZilla :)
20:53:52 <performance> ivanm:  :)
20:53:54 <pumpkin> performance: I mean, how did you choose #haskell
20:53:56 <sproingie> yeah obviously a /dev/random RNG isn't going to have a meaningful split
20:54:02 <luite> sproingie: I still think it's a very useful operation, even if it's expensive
20:54:45 <Warrigal> If a single multiplication takes ten seconds, this will only take... let's say definitely less than an hour.
20:55:55 <performance> pumpkin: i hang out here often :)  and have been using Haskell on and off for very small tasks for a while now
20:56:06 <pumpkin> ah
20:56:22 <Warrigal> Getting the answer to a Project Euler problem in less than an hour of computing time. What a noble goal.
20:56:32 <pumpkin> (it's supposed to take under a minute)
20:57:42 <hackagebot> zip-archive 0.1.1.4 - Library for creating and modifying zip archives. (JohnMacFarlane)
20:57:50 <performance> unless teh objective of the program is to understand the problem and generate a program to ...
20:58:05 <performance> get the answer in under a minte
20:58:14 <performance> minute
20:58:41 <Warrigal> main = print 129384165
20:59:18 <SmurfOR> haha
20:59:25 <jmcarthur> sproingie: there is a meaningful split for /dev/random... each new generator just becomes half the speed of the one it and its sibling were created from ;)
20:59:55 <jmcarthur> sproingie: one being the odds and one being the evens
21:00:22 <jmcarthur> it's not efficient at all, but it is true to the meaning i think
21:00:26 <Warrigal> The speed actually remains the same if you use them both equally.
21:00:32 <jmcarthur> big if
21:01:12 <performance> pumpkin: so are you familiar with how to do a simple javascript/css webpage and some how make use of haskell? [ i fear Happstack is over kill or this]
21:01:28 <pumpkin> I am, but I can't say it's what I consider fun :)
21:01:58 <jmcarthur> however, i think that if you assume that a generator generates numbers in finite time then its children also do so in finite time
21:01:59 <Warrigal> Controversial /dev/random split: make two new generators that both take from /dev/random and just avoid taking characters that the other has already taken.
21:02:10 <jmcarthur> Warrigal: that is called "supply" ;)
21:02:12 <performance> well thats a start, lets see if the actual problem will provide you with a chance to make it fun
21:02:27 <jmcarthur> Warrigal: there are a couple implementations of that idea
21:02:27 <Warrigal> (Using "controversial" to mean "likely to become controversial".)
21:02:48 <performance> pumpkin:  i want to browse a source tree, but i want the text of each file to pass through a haskell funciton before it is displayed on the browser
21:03:24 <performance> kind of basic directory browsing mode ... but having been through my haskell code before showing up on the screen
21:03:38 <tectum> are MVars the right tool for implementing mutual exclusion?
21:03:58 <Warrigal> tectum: you want semaphores.
21:04:20 <Warrigal> Hey, my GHCi is gone again. :-P
21:04:45 <tectum> RHW says MVars can be used as mutexes, but that seems strange
21:04:49 <jmcarthur> perhaps i misunderstand what a mutex is, but i thought MVar was sufficient for that
21:05:04 <tectum> "We put the data into the MVar when it is not being used by any thread, and one thread takes it out temporarily to read or modify it"
21:05:17 <jmcarthur> define "mutual exclusion." perhaps there are multiple common definitions...
21:05:41 <adammm> do I ask in here or in #ghc for problems compiling the latest GHC release?
21:05:41 <tectum> modifying an integer without introducing a race condition
21:06:02 <jmcarthur> tectum: MVar can do that provided that no thread writes without reading first
21:06:14 <tectum> indeed
21:06:15 <jmcarthur> s/reading/taking/
21:06:16 <Cale> tectum: any other thread which tries to take the MVar when your thread has it will wait
21:06:16 <tectum> I see your point
21:06:17 <tectum> thanks
21:06:26 <ksf> is there a lhs2hs converter?
21:06:32 <sproingie> is a MVar like a logic variable or a queue of length 1?
21:06:37 <tectum> (so it still depends on the cooperation)
21:06:42 <tectum> (of all threads)
21:06:49 <Cale> Yes.
21:07:00 <sproingie> i.e. does reading it empty it?
21:07:08 <Saizan> you've to stick to modifyMVar
21:07:12 <jmcarthur> sproingie: not sure what the comparison to a logic variable would be, but i think queue of length 1 sounds close
21:07:19 <Saizan> sproingie: yes, takeMVar empties it
21:07:23 <Cale> There's TMVar which is a little safer in that you can work with multiple TMVars all at once and package operations up into transactions that occur as-if-atomically.
21:07:32 <Cale> sproingie: yeah
21:07:34 <sproingie> logic variable blocks readers til it's satisfied then stays set
21:07:59 <tectum> Cale: is that the only difference between TMVars and MVars?
21:08:00 <jmcarthur> sproingie: i think we call those IVars
21:08:10 <sproingie> ah.  haskell has everything :)
21:08:12 <Cale> tectum: essentially
21:08:13 <jmcarthur> sproingie: you mean write once, read many, right?
21:08:19 <ksf> yep TMVar is the STM version of MVar
21:08:23 <sproingie> jmcarthur: basically yeah
21:08:39 <tectum> ksf: what's STM?
21:08:40 <Saizan> but in STM you can also stick to TVar
21:08:41 <Cale> There's also TVar which is the STM version of IORef ;)
21:08:48 <jmcarthur> sproingie: yeah. it's not in the standard libs, but i and a few others invented it a few times independently last year and now there are a few implementations on hackage
21:08:52 <Saizan> and still have atomicity
21:08:57 <Cale> right
21:08:58 <ksf> in fact, type TMVar a = TVar (Maybe a)
21:09:08 * bos hates reading darcs patches
21:09:31 <Cale> newtype TMVar a = TMVar (TVar (Maybe a))
21:09:39 <Cale> but yeah :)
21:09:56 <jmcarthur> sproingie: we also have "procrastinating variables", which are variables that are write once, read many, but early readers see it as _|_ instead of blocking
21:10:21 <jmcarthur> sproingie: or, rather, early readers cause it to be _|_ for all later readers as well
21:10:38 <BMeph> I thought we used Reader comonads for WORM values. ;)
21:10:39 <ksf> it should be possible to code up anything imaginable on top of TVars
21:10:58 <ksf> erm *cough* convert lhs to hs, automatically?
21:11:05 <Cale> We have a ton of concurrency abstractions, and if it's not enough, there are plenty of things on Hackage ;)
21:11:13 <Cale> http://hackage.haskell.org/package/chp
21:11:17 <defun> is more idiomatic for haskell code to have the main function and higher order functions at the top of the program, and other 'lower-level' functions toward the bottom, or vice-versa?
21:11:18 <tectum> are MVars magic (primitive) or can anybody build them?
21:11:24 <rsnake> Gack! This shows me an error at line 7! http://paste.pocoo.org/show/145940/
21:11:25 <jmcarthur> ksf: i failed to make an frp implementation with tvars without constantly rolling things back that shouldn't have been rolled back
21:11:31 <Cale> http://hackage.haskell.org/package/cml
21:11:38 <jmcarthur> ksf: but that is an extreme thing to be trying anyway. generally tvars rock
21:11:39 <mmorrow> tectum: they're magic
21:11:46 <Cale> http://hackage.haskell.org/package/caf
21:11:57 <sereven> bos: what are your favorite merge/diff interface(s)?
21:11:58 <Cale> Somehow they're all three letter acronyms starting with C :)
21:12:05 <bos> sereven: kdiff3
21:12:21 <ClaudiusMaximus> ksf: unlit   (but for some reason i don't have it)
21:12:25 <jmcarthur> defun: i personally tend to do simpler things at the top and then compose them into more complex things as you scroll down the file
21:12:33 <ksf> jmcarthur, wait, you have a frp lib, too?
21:12:41 <jmcarthur> ksf: several incomplete ones
21:12:51 <mmorrow> tectum: when you try to read one, the code that's generated checks if it's empty, if so it adds you (:= a ptr to your thread) to the wait queue, and jumps to the scheduler
21:12:58 <defun> I see. That's my intuition too. Thanks.
21:13:03 <Saizan> rsnake: which error?
21:13:06 <ksf> argh.
21:13:07 <sereven> bos: thanks, will have to give it another try.
21:13:14 <jmcarthur> ksf: i've been doing it for probably 1.5 or 2 years now
21:13:14 * ksf goes with grep and vim's block selection.
21:13:46 <mmorrow> tectum: (the wait queue being the one associated with that particular MVar)
21:14:37 <rsnake> Saizan: "Parse error on input 'where'"
21:14:57 <Saizan> rsnake: on line 6, | otherwise = ltx
21:15:28 <rsnake> Saizan: Thanks! :D
21:20:57 <FunctorSalad> ghc error message: "Only unit numeric type pattern is valid" <-- ???
21:21:22 <pumpkin> > undefined :: 1
21:21:24 <lambdabot>   No instance for (GHC.Show.Show GHC.Generics.Unit)
21:21:24 <lambdabot>    arising from a use of ...
21:21:25 <pumpkin> > undefined :: 2
21:21:27 <lambdabot>   Only unit numeric type pattern is valid
21:21:29 <FunctorSalad> oh I put a "0" on the type level
21:21:36 <FunctorSalad> :)
21:21:51 <pumpkin> it still seems very very strange to add a syntactic  exception for something so obscure
21:23:13 <FunctorSalad> yay got induction working http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10929#a10929
21:23:27 <pumpkin> :)
21:27:23 <mmorrow> FunctorSalad: you can alternative use
21:27:24 <ivanm> FunctorSalad: hang on, what was that error?
21:27:44 <pumpkin> he wrote p 0 instead of p Z
21:27:51 <FunctorSalad> yeah :)
21:27:58 <ivanm> ahhh
21:28:03 <mmorrow> data N a where Z :: N (); S :: N a -> N (N a)
21:28:07 <tectum> what's the difference between HNF and WHNF?
21:28:09 <mmorrow> to avoid the empty data decls
21:28:16 <pumpkin> tectum: you need to look past the lambda for HNF
21:28:38 <ivanm> FunctorSalad: is that a GADT for IsNat ?
21:28:54 <pumpkin> (\x -> (\y -> y) x) is WHNF but not HNF I think
21:28:57 <FunctorSalad> ivanm: yep
21:29:05 <ivanm> tectum: the latter is weak ;-)
21:29:25 <ivanm> mmorrow: and thus one less extension?
21:29:38 <mmorrow> ivanm: one less extension, but also simpler code
21:29:43 <ivanm> *nod*
21:29:47 <Saizan> but more confusing
21:29:50 <ivanm> FunctorSalad: how do you actually use your natInduction?
21:29:59 <FunctorSalad> mmorrow: doesn't "N" have a double purpose there?
21:30:09 <ivanm> Saizan: is it? I find mmorrow's definition (at least of the data structures) easier to understand...
21:30:14 <pumpkin> ivanm: I have a large file that uses it a lot if you want ;)
21:30:18 <mmorrow> Saizan: yeah i find it simpler personally
21:30:18 <tectum> the haddock of 'seq' says it evaluates to HNF, not WHNF
21:30:28 <ivanm> pumpkin: what, FunctorSalad's code?
21:30:33 <pumpkin> ivanm: something almost identical
21:30:43 <ivanm> you've already used it 7 min after he released it? :o
21:30:44 <ivanm> pumpkin: heh
21:30:47 <mmorrow> FunctorSalad: it's a matter of perspective i guess
21:30:54 <Saizan> but you overload N for not good purpouse, and use () instead of a semantically meaningful name
21:31:08 <pumpkin> pwnt
21:31:10 <FunctorSalad> I view sets of types as predicates on types here
21:31:13 <Saizan> but i guess readability varies.
21:31:33 <mmorrow> , $(nat 8)
21:31:34 <FunctorSalad> values of type "IsNat n" are proofs that the type n is an element of the type-set Nat
21:31:37 <lunabot>  N (N (N (N (N (N (N (N Z)))))))
21:31:51 <mmorrow> (data N a where Z :: N (); N :: N a -> N (N a))
21:32:03 <mmorrow> re-using N for S there too ;)
21:32:12 <FunctorSalad> that's what I meant
21:32:17 <Saizan> yeah, going against years of conventions :)
21:32:21 <tectum> (\x -> undefined x) `seq` 2
21:32:23 <mmorrow> bring it!
21:32:34 <mmorrow> :)
21:32:57 <FunctorSalad> ivanm: not sure about the question... you can use it like any Haskell function ;)
21:33:12 <ivanm> FunctorSalad: what does that function actually _do_ ;-)
21:33:18 <pumpkin> it proves shit
21:33:36 <ivanm> as in proof by induction?
21:33:37 <mmorrow> @yow
21:33:37 <lambdabot> Couldn't find fortune file
21:33:39 <pumpkin> ivanm: yep
21:33:41 <Saizan> yeah
21:33:50 <ivanm> pumpkin: so we're stealing Coq's thunder? :o
21:33:53 <Saizan> the name is not casual!
21:33:59 <pumpkin> ivanm: if you have the predicate for Z and a function that takes a predicate for n, and gives you a predicate for n + 1, then you have the predicate for any n
21:34:07 <aeron> Hey guys - I'm having a bit of trouble getting haskell platform installed. This is the output I get: http://pastebin.com/m3a514cc8
21:34:21 <mmorrow> , nesty $(nat 8) (:[]) 0
21:34:23 <lunabot>  [[[[[[[[[0]]]]]]]]]
21:34:30 <pumpkin> ivanm: http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html is a great introduction :)
21:34:32 <ivanm> why is editline in the platform still?
21:34:33 <Saizan> (i guess it's s/casual/random/)
21:34:38 <ivanm> does anything actually use it?
21:34:38 <mmorrow> , foldr (.) id (replicate 8 (:[])) 0
21:34:39 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [a]
21:34:47 <mmorrow> , nesty $(nat 8) (:[]) 0
21:34:49 <lunabot>  [[[[[[[[[0]]]]]]]]]
21:34:53 <mmorrow> is one possible use
21:35:01 <aeron> ivanm: no clue, just being frustrated by it right now :)
21:35:26 <FunctorSalad> ivanm: in this view, types are propositions and their values are proofs
21:35:27 <ivanm> aeron: yeah, I was kinda asking everyone else ;-)
21:35:34 <c_wraith> editline is the reason I couldn't figure out how to install platform. >_>
21:35:34 <ivanm> aeron: I don't think you actually need it...
21:35:44 <ivanm> (then again, I haven't got the platform installed...)
21:35:46 <pumpkin> kill it with fire
21:35:55 <FunctorSalad> (though in haskell you can always cheat with 'undefined')
21:36:09 <ivanm> FunctorSalad: and so you're abusing the type system? I thought that was Oleg's job!
21:36:13 <ivanm> @quote milli-oleg
21:36:14 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
21:36:21 <ivanm> fair enough then...
21:36:23 <Cale> aeron: This is on linux? My recommendation is don't bother with the Haskell Platform on Linux. Just get a binary of GHC from the GHC website, and then install cabal-install.
21:36:30 <lament> @quote oleg
21:36:30 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
21:36:34 <ivanm> aeron: which distro?
21:36:48 <aeron> CentOS 5
21:36:52 <ivanm> ahhhh
21:36:57 <mmorrow> oleg's one-liner are hilarious
21:36:59 <pumpkin> lol @ http://snapplr.com/y18y
21:37:04 <Cale> (Unless you are someone who is working on a distribution package...)
21:37:09 <ivanm> fedora just got the platform IIRC... so I doubt if RHEL/CentOS has it ;-)
21:37:17 <FunctorSalad> ivanm: you could define the less-than relation next, like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10929#a10930
21:37:24 <FunctorSalad> (which was actually my goal)
21:37:32 <ivanm> humph, I see kolmodin still included editline for the gentoo platform ebuild...
21:37:42 <Cale> aeron: That specific error should be easy enough to fix
21:37:53 <mmorrow> "indeed, it is utterly trivial to avoid, and in haskell98"
21:38:02 <pumpkin> mmorrow: what is?
21:38:10 <FunctorSalad> so you can prove on the type-level that your deBruijn indices are in bounds :)
21:38:17 <ivanm> FunctorSalad: is there any real reason to _want_ less than on the type level?
21:38:22 <Cale> aeron: look inside that file, there is probably no module declaration at the top. Add  "module Editline where" to the top of the file.
21:38:25 <mmorrow> pumpkin: some oleg-ish or something
21:38:41 <ivanm> mmorrow: isn't that missing part of the quote?
21:38:48 <mmorrow> (i was channeling oleg in that quote)
21:38:48 <aeron> Cale: will look now
21:39:01 <mmorrow> ivanm: that's usually the common part of *all* his quotes
21:39:06 <mmorrow> ;)
21:39:12 <ivanm> mmorrow: heh, fair enough
21:39:33 <Saizan> FunctorSalad: we usually use classes for those, so we can pretend there's no runtime representation :)
21:40:17 <FunctorSalad> Saizan: I can't get the class-based libraries to deduce (S x :<: S y) from (x :<: y)... maybe it's just me
21:40:57 <FunctorSalad> (deduce this in the abstract, not for concrete x/y)
21:41:11 <FunctorSalad> which you need to bump deBruijn indices right?
21:41:13 <ksf> three hours total to get the thing compile. guess what happened.
21:41:38 <c_wraith> hard drive failure?
21:41:46 <pumpkin> the cat threw up on the floor
21:42:00 <pumpkin> or wait, I know
21:42:07 <Saizan> FunctorSalad: heh, yeah, the instance resolution algorithm is quite dumb like that
21:42:20 <pumpkin> your stomach started hurting!
21:42:24 <ivanm> ksf: compile what?
21:42:34 <ivanm> pumpkin: and so he ate the computer? :p
21:42:35 <Saizan> mostly because it has to know how to construct the proof automatically
21:42:53 <ivanm> hummm.... editline builds here...
21:42:55 <ksf> you're all wrong. it _worked_.
21:42:56 <ivanm> this is 0.2.1.0
21:43:04 <ivanm> ksf: bah, way to ruin a story! :@
21:43:05 <FunctorSalad> Saizan: is it really just that? classes dont' give an induction principle either, since they're open, no?
21:43:19 <ksf> ...the elerea chase example ported to Vec, that is.
21:43:32 <adammm> I'm trying to compile GHC 6.10.4 on openbsd/i386 and it fails with this: http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=4439
21:43:39 <aeron> Cale: funny story - the file it's telling me it's in.. is empty
21:43:39 <ivanm> aeron: do you have the system editline library installed?
21:43:39 <ivanm> c_wraith: did you?
21:43:39 <FunctorSalad> (you know that Z and S n are Nats, but not that these are all Nats)
21:43:39 <aeron> ivanm: yes
21:43:52 <ksf> using + and - on (Signal (Vec2 GLfloat)) rocks.
21:43:59 <ivanm> aeron: which version? I have libedit 200090923.3.0
21:44:05 <c_wraith> ivanm: I installed several versions of it trying to get it to work.
21:44:17 <aeron> libedit-20090923-3.0
21:44:28 <ivanm> aeron: I'm guessing that it's automatically generated using a pre-processor
21:44:48 <ivanm> oh, and it uses non-standard Cabal hackery by the looks of things...
21:45:17 <mmorrow> FunctorSalad: <mmorrow> re-using N for S there too ;)
21:45:27 <mmorrow> FunctorSalad: oh, i meant for the GADT /constructor/
21:45:52 <mmorrow> i'm triple-re-using N in that one
21:45:59 <FunctorSalad> oh right
21:46:04 <mmorrow> but the one i suggested to you only double-reuses
21:46:05 <mmorrow> ;)
21:46:27 <Saizan> FunctorSalad: true, you could add a context that requires x and y to be of the right form (using ~), but it probably wouldn't be enough
21:47:31 <atp> a nice pascal's triangle implementation:
21:47:32 <atp> pascal :: Int -> [Int]
21:47:32 <atp> pascal 1 = [1]
21:47:33 <atp> pascal n = let p' = pascal (n - 1) in zipWith (+) (0 : p') (p' ++ [0])
21:47:46 <pumpkin> why make it finite?
21:47:55 <mmorrow> @let pascal 1 = [1]; pascal n = let p' = pascal (n - 1) in zipWith (+) (0 : p') (p' ++ [0])
21:47:57 <lambdabot>  Defined.
21:48:17 <atp> pumpkin: it's harder to make it a one-liner that way, i think.  can you think of a solution?
21:48:20 <mmorrow> > (vcat . fmap integer) (pascal 4)
21:48:21 <pumpkin> hmm
21:48:22 <lambdabot>   1
21:48:22 <lambdabot>  3
21:48:22 <lambdabot>  3
21:48:22 <lambdabot>  1
21:48:25 <mmorrow> oops
21:48:28 * pumpkin ponders
21:48:36 <FunctorSalad> sadly you can't prove "(Z :=: S Z) -> False"... the pattern match on the Refl gives a type error
21:48:38 <atp> i suppose you could use concatMap
21:48:45 <atp> and [1 ..]
21:49:00 <atp> and fmap
21:49:02 <atp> or map
21:49:04 <atp> err
21:49:09 <atp> wait i'm smoking crack
21:49:15 <FunctorSalad> I guess "undefined" is justified there
21:49:35 <FunctorSalad> /away smoking crak
21:49:36 <atp> anyway, i just thought it was cute, maybe some haskell newbies would enjoy it
21:49:50 <pumpkin> :)
21:49:56 <pumpkin> now you have me playing with it
21:50:16 <mmorrow> FunctorSalad: isn't the type error equivalent to False ?
21:50:19 <pumpkin> here we go
21:50:33 <ksf> wut? how can pattern matches overlap when there's just one pattern to match against?
21:50:43 <pumpkin> > unfoldr (\x -> Just (x, zipWith (+) (0 : x) (x ++ [0]))) [1]
21:50:44 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
21:50:54 <atp> ooh, nice
21:51:08 <FunctorSalad> mmorrow: on the metalevel yes I suppose
21:51:21 * pumpkin wonders how to make it nicer
21:51:21 <FunctorSalad> but won't let you define a witness of that type ;)
21:51:24 <atp> you can make it pointfree with ap (zipWith (+) . (0:)) (++[0]) i bet
21:51:26 <mmorrow> > (vcat . fmap (hsep . fmap integer)) $ unfoldr (\x -> Just (x, zipWith (+) (0 : x) (x ++ [0]))) [1]
21:51:27 <Cale> > iterate (\x -> zipWith (+) (0:x) (x++[0])) [1]
21:51:29 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
21:51:29 <lambdabot>   * Exception: stack overflow
21:51:34 <pumpkin> Cale: good point :P
21:51:38 <mmorrow> > (vcat . fmap (hsep . fmap integer) . take 4) $ unfoldr (\x -> Just (x, zipWith (+) (0 : x) (x ++ [0]))) [1]
21:51:39 <lambdabot>   1
21:51:39 <lambdabot>  1 1
21:51:39 <lambdabot>  1 2 1
21:51:39 <lambdabot>  1 3 3 1
21:52:23 <Cale> There was an even shorter thing with scanl, I forget what it was
21:52:38 <pumpkin> seems like it'd be hard to do with scanl
21:52:43 <Cale> scanl and fix
21:52:53 <atp> iterate (ap (zipWith (+) . (0:)) (++[0])) [1]
21:52:55 <atp> hehe
21:53:04 <atp> > iterate (ap (zipWith (+) . (0:)) (++[0])) [1]
21:53:05 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
21:53:13 * atp prefers pointless code :)
21:53:15 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10931#a10931
21:53:20 <ksf> how do I get rid of the warning?
21:53:38 <mmorrow> FunctorSalad: yeah true, that's interesting actually. is being able to do that fundamentally impossible within the haskell type system (as it is), since it would necessarily mean that it accepted a non-type-correct thing?
21:54:43 <mmorrow> i.e., you want to reflect the fact that something doesn't typecheck in a way that typechecks
21:54:56 <mmorrow> or something
21:55:40 <mmorrow> that sounds godelish
21:56:34 <FunctorSalad> mmorrow: seems to be impossible yes
21:56:59 <FunctorSalad> but "undefined" should be equivalent
21:57:05 <ksf> ...you can do a type family that returns T on everything it doesn't match.
21:57:17 <mmorrow> i wonder if it's a fundamental impossibility though, or it's just that haskell's type system is such that it can't do that
21:57:18 <|2dman|> Hello.  I am trying to figure out FFI (relatively new to Haskell), and I want to wrap the 'stat' function.
21:57:36 <|2dman|> But on my system, the stat function does not exist in a shared library, only static.
21:57:38 <ksf> stat is already bound.
21:57:42 <mmorrow> , 0 == 1
21:57:44 <lunabot>  False
21:57:46 <|2dman|> so when I compile my module, it works great
21:57:51 <|2dman|> but I cannot test it in GHCI
21:57:55 <|2dman|> because GHCI can't find the symbol
21:58:10 <|2dman|> is there something I can do?
21:58:24 <ksf> you could link the .a that contains stat into a dynamic lib.
21:58:25 <FunctorSalad> mmorrow: the haskell type system doesn't enforce exhaustiveness anyway
21:58:29 <pumpkin> :m + The.Module.With.The.Symbol
21:58:57 <Cale> > fix (map (++[1]) . scanl (zipWith (+) . (0:)))
21:58:59 <lambdabot>   Couldn't match expected type `[[t]]'
21:58:59 <lambdabot>         against inferred type `[[[t]]]...
21:59:01 <Cale> er
21:59:07 <|2dman|> ksf: I attempted that (gcc -shared -o libc.so /usr/lib/libc.a), but I end up with an empty .so for some reason
21:59:09 <FunctorSalad> mmorrow: you'd really want an empty pattern match, but that just isn't valid syntax
21:59:10 <Cale> > fix (map (++[1]) . scanl (zipWith (+) . (0:)) [])
21:59:11 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
21:59:14 <pumpkin> yay
21:59:18 <mmorrow> |2dman|: ghci -fobject-code foo.o
21:59:29 <mmorrow> |2dman|: unfortunately ghci's linker can't read .a files..
21:59:33 <atp> Cale: nice
21:59:33 <Cale> now, to transform that some more...
21:59:44 <atp> i thought iterate + ap wasn't bad
21:59:49 <atp> ski combinators ftw
22:00:02 <mmorrow> |2dman|: (also, not entirely sure whether the -fobject-code is necessary there, but it can't hurt)
22:00:02 <dcolish> what am i missing that HDBC doesnt build from hackage?
22:00:05 <|2dman|> mmorrow: WOW!  Thanks... that's amazing
22:00:05 <Cale> ugly (++[1])...
22:00:11 <ski> atp : ?
22:00:15 <mmorrow> |2dman|: :)
22:00:20 <ski> oh
22:00:21 <atp> ski: not you :)
22:00:23 <|2dman|> I had already un-ar'ed /usr/lib/libc.a, so I had stat.o just sitting there
22:00:31 * pumpkin goes skiing to annoy ski
22:00:38 <mmorrow> |2dman|: ah nice
22:00:47 <fooman_> when specifying a record, { foo :: Foo } should be expressable with just { Foo }. So if the parser saw a capitolized field Foo, it would just expand it to "foo :: Foo"
22:01:01 <|2dman|> mmorrow: you are right... the -fobject-code is not even necessary
22:01:06 <hackagebot> statistics 0.3.5 - A library of statistical types, data, and functions (BryanOSullivan)
22:01:20 <|2dman|> mmorrow: Guess I just foolishly assumed that ghci couldn't load a .o, and never actually tried it (out of all the permutations I *did* try!)
22:01:22 <pumpkin> bos: what's new? :o
22:01:37 <fooman_> er, I meant capitalized, naturally
22:01:51 <mmorrow> |2dman|: yeah, it's surprising at first
22:01:53 <Cale> > fix (scanl (fmap (++[1]) . zipWith (+) . (0:)) [1])
22:01:54 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
22:01:55 <fooman_> is there a reason that wouldn't work?
22:02:01 <ski> (fooman_ : and if it saw `{ Foo Bar }' ?)
22:02:18 <fooman_> ski: isn't that invalid syntax?
22:02:31 <pumpkin> Maybe Int
22:02:48 <ski> fooman_ : well, but so is `{ Foo }' (currently)
22:03:38 <fooman_> oh well, I don't really like the record syntax anyway
22:03:57 <atp> Cale you still have the ++[1], but now you have an extra [1] at the end
22:04:28 <ski> imo `data Foo = MkF { bar :: Int }' while `bar :: Foo -> Int' is bad
22:05:13 <fooman_> if you had several records that all had the same field (let's say it's "author :: String"), you can't actually give each record the same field name. Would the best solution would be to create a type class?
22:05:16 <atp> Cale i think iterate (ap (zipWith (+) . (0:)) (++[0])) [1] is still better ;) ... but fix definitely scores some points
22:05:19 <c_wraith> Hmm.  Is there any way to interrupt a thread in an accept call?
22:05:38 <Cale> atp: oh, sure, I'm just trying to force scanl into the picture :)
22:05:38 <kyagrd> Has anyone here experienced vacuum-cairo dies with ghc when used on (Map Int Int) type?
22:06:02 <ski> fooman_ : maybe. in some cases one can factor. one can also consider using different modules
22:06:04 <mmorrow> c_wraith: if you did the accept on a Handle, probably, but if you did it on an Fd, then probably not
22:06:05 <idnar> ski: yeah, that's a bit weird
22:06:29 <fooman_> ski: by factor do you mean create nested records?
22:06:37 <c_wraith> mmorrow:  On a Network Socket, actually
22:06:38 <kyagrd> It works when I get ppDot text output and then generate svg manually with dot ... strange.
22:06:49 <ski> yes, factor out the common parts (if sensible)
22:07:07 <mmorrow> c_wraith: ah, yeah then that's on an Fd i believe
22:07:17 <c_wraith> well, closing the socket doesn't work.
22:07:21 <mmorrow> c_wraith: directly via C's accept
22:07:34 <bos> @src (<=<)
22:07:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:07:42 <c_wraith> Could I do something horrible like throwTo?
22:08:06 <fooman_> ski: my actual shared field is "id" for entities in a database, so I don't think it makes sense to factor that out, and many modules are going to be dealing with several entities
22:08:09 <mmorrow> c_wraith: hmm, actually i don't think there's any current way to accept in an interruptible or nonblocking way
22:08:16 <c_wraith> Ah, no I can't use throwTo.
22:08:22 <mmorrow> (with the Network module in the stdlibs)
22:08:27 <idnar> can't you just send a signal or something to cause EINTR?
22:08:29 <mmorrow> c_wraith: yeah, you're in a C call
22:08:39 <mmorrow> basically, you can't do anything
22:08:59 <mmorrow> right, other than signals ..
22:09:03 <idnar> I suppose threads and signals mix badly
22:09:05 <ski> fooman_ : re modules, you can alway import qualified .. but it's still not that nice
22:09:12 <mmorrow> but then you have to consider the interaction with ghc's rts
22:09:24 <idnar> also, I know there's some way to do nonblocking accept, but I forget how
22:09:24 <mmorrow> which sounds like a minefield
22:09:33 <atp> fnctl
22:09:37 <c_wraith> I could just end the program. :)
22:09:38 <witchdr> Is there anyone here that can answer some questions on C coding/
22:09:50 <pumpkin> witchdr: nope, but there are people in ##c who can
22:09:53 <atp> you could just write a non-blocking accept routine in C and use that instead
22:09:55 <mmorrow> idnar: there is, but Network currently throws an exception in that case, thereby making it impossible.. :(
22:09:55 <idnar> is it just accept() on a nonblocking socket?
22:09:59 * ski dislikes `id' fields in relations ..
22:10:11 <idnar> mmorrow: can't you catch it?
22:10:12 <witchdr> pumpkin: thanks
22:10:28 <ski> it feel too lowlevel, like manually allocating and manipulating pointers
22:10:31 <idnar> I suppose that doesn't help, you don't want to poll
22:10:35 <ski> s/feel/feels/
22:10:37 <mmorrow> idnar: right
22:11:00 <mmorrow> idnar: it's juts an annoying behavior of the Network module though, you could rewrite it to be able to do nonblocking accept
22:11:02 <c_wraith> I could decide the proper way to shut down the program is via a network message.
22:11:06 <idnar> you want to select on it, but the select loop (or equivalent) is in the RTS?
22:11:11 <pumpkin> ski: id relations?
22:11:14 <atp> generally when writing C i don't do a lot of non-blocking stuff... a select loop is usually the way to go... but in haskell i'm not sure how you'd make it work properly
22:11:18 <mmorrow> idnar: it'd just be a pain on account of the C structs you have to deal with
22:11:22 <fooman_> do the generic programming libs out there just automatically write instances for your type classes, or can they automatically add fields to records?
22:11:27 <pumpkin> ski: oh, you mean like a numeric identifier?
22:11:42 <mmorrow> idnar: yeah, you'd also need to select()/poll()/epoll()/whatever on it yourself
22:11:50 <idnar> anyhow, that's a bit of a nasty flaw
22:11:52 <fooman_> I suppose I should just read a tutorial to answer that last question
22:11:55 <ski> pumpkin : fields named `id' in relations, typically containing a sequence number, and uniquely determining a tuple
22:11:59 <pumpkin> yeah
22:12:05 <atp> alright, see you guys later
22:12:08 <mmorrow> idnar: (which was the use-case i had that made me aware that accepting nonblockingly is impossible with the Metwork module)
22:12:24 <mmorrow> idnar: yeah annoying
22:12:30 <idnar> somebody should fix it RIGHT NOW!!!
22:12:30 <ski> it feels a bit like simulating skolems
22:12:33 <idnar> :p
22:12:38 <mmorrow> :)
22:13:44 <c_wraith> It's not clear what a fixed API would be.
22:14:02 <dcolish> i think HDBC-2.1.1 is broken
22:16:50 <c_wraith> I guess if the main thread exits, the program ends.  I can just leave it up to the main thread to decide when to close the program.
22:16:58 <Saizan> dcolish: it requires an earlier convertible than the latest available, iirc
22:17:08 <c_wraith> and just not clean up the socket. >_>
22:18:12 <c_wraith> ooh, worst idea yet.  create a thread to just connect every second as a heartbeat!
22:18:20 <dcolish> Saizan: hmm thats weird since HDBC-2.1.0 works
22:19:12 <bos> @seen dons
22:19:12 <lambdabot> Unknown command, try @list
22:19:16 <bos> fnurp.
22:19:20 <ClaudiusMaximus> > let foo = fromIntegral 25 in (foo::Float, foo::Double) -- i think something similar to this is giving me errors, any nice quick solution?
22:19:22 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
22:19:22 <lambdabot>         against inferred ty...
22:19:31 <kyagrd> @list
22:19:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:19:38 <Saizan> preflex: seen dons
22:19:39 <preflex>  dons was last seen on #haskell 8 hours, 2 minutes and 53 seconds ago, saying: mutable state breaks easy parallelism
22:19:43 <kyagrd> @seen dons
22:19:43 <lambdabot> Unknown command, try @list
22:19:45 <fooman_> is Generic Haskell more capable Scrap your boilerplate?
22:19:57 <kyagrd> hmm lambdabot dropped it
22:20:05 <fooman_> s/capable/capable than/
22:20:06 <kyagrd> the seen command
22:20:18 <mmorrow> preflex has a better seen
22:20:25 <mmorrow> preflex: seen preflex
22:20:26 <preflex>  what
22:20:30 <Saizan> the seen command got disabled since it's buggy, maybe we should make @seen report that
22:20:45 <mmorrow> preflex: seen Saizan
22:20:45 <preflex>  Saizan was last seen on #haskell 15 seconds ago, saying: the seen command got disabled since it's buggy, maybe we should make @seen report that
22:21:01 <pumpkin> Saizan: more amusing would be to have @seen ask preflex
22:21:07 <Saizan> yeah :)
22:21:24 <pumpkin> reminds me of that robot that turns itself off when you turn it on
22:21:31 <mmorrow> bot cooperation
22:21:37 <mmorrow> tomorrow, skynet
22:21:55 <mmorrow> better to be safe than sorry!
22:22:14 <endojelly> so hackage's up again?
22:22:22 <pumpkin> sure appears to be ;)
22:22:27 <endojelly> yay!
22:24:01 <idnar> c_wraith: the fixed API would make accept non-blocking the same way read / etc. are, surely?
22:24:19 <idnar> then the thread wouldn't be stuck in a C call
22:24:43 <kyagrd> I checked back again with the youtube part 4 of the vacuum and it did have an error message when trying to view Map, it worked for IntMap only there too.  But the problem now is that it crashes ghc as well :-(
22:24:55 <kyagrd> I mean vacuum-cario
22:25:08 <Saizan> isn't accept implemented via select like the rest? or it can't be?
22:25:13 <mmorrow> kyagrd: is it vacuum-cairo's fault or vacuum's?
22:25:37 <kyagrd> It is vacuum-cairo problem.
22:25:38 <mmorrow> kyagrd: (if you have the newest vacuum, vacuum shouldn't be at fault)
22:25:42 <mmorrow> ah, ok good :)
22:25:57 <kyagrd> I was able to generate from ppDot and then turn that into svg and it worked fine for (Map Int Int)
22:26:07 <fooman_> so the SYB page says that the paper is implemented in the Data.Generics library. What is the functionality that allows for new derivations in addition to the H98 defaults of Eq, Read, Show, etc?
22:26:30 <mmorrow> kyagrd: are you on linux? is so i've got an opengl version of vacuum-cairo that i use (not the one on hackage, but i haven't tried that one actually)
22:26:46 <kyagrd> mmorrow: I'm on linux debain unstable
22:26:50 <mmorrow> http://moonpatio.com/repos/vacuum-gl/
22:26:59 <mmorrow> should work for you (hopefully)
22:27:06 <mmorrow> it talks directly to the graphviz C api
22:27:14 <Saizan> fooman_: direct compiler support
22:27:14 <mmorrow> so you'll need graphviz-devel or whatever
22:27:28 <fooman_> Saizan: is there a name for that feature?
22:27:45 <Cale> Why hackage went down? :) http://www.youtube.com/watch?v=juE9AQJ3jSA
22:27:49 <Saizan> fooman_: DeriveDataTypeable is the LANGUAGE flag
22:27:55 <pumpkin> lol
22:27:57 <fooman_> Saizan: thanks
22:27:57 <mmorrow> kyagrd: (it also can draw graphs in general too, but isn't very well documented)
22:28:25 <Saizan> fooman_: you could do something similar for other classes with TH, see the derive package
22:28:33 <mauke> preflex has a second 'seen' system now; it's accessed with 'xseen' and works across networks
22:28:54 <pumpkin> ooh
22:28:56 <pumpkin> what networks?
22:29:08 <mmorrow> Cale: haha
22:29:29 <mauke> pumpkin: that's a secret
22:29:32 <pumpkin> zomg
22:29:37 <pumpkin> sekritz
22:29:50 <mmorrow> but i eated it
22:30:00 <pumpkin> you accidentally all of it??
22:30:14 <mmorrow> o yeh
22:30:17 <pumpkin> :(
22:30:24 <mmorrow> omnom
22:31:12 <morganson> I have type-problems with my property. Is someone willing to help me?
22:31:22 <lament> no
22:31:27 <morganson> ok =)
22:31:31 <Saizan> show us your type problmes
22:31:36 <Saizan> then we can decide :)
22:31:37 <mmorrow> kyagrd: (the reason it only works on linux is because it uses freeglut's ability to not have to enter an event loop, and just polls for event and waits on a Chan)
22:32:05 <mmorrow> also had to use pthreads for one part of the cbits code in there
22:32:37 <mmorrow> (to get two C functions that read/write to/from a FILE* to talk to each other over a pipe() w/in the same process)
22:32:47 <morganson> No instance for (Fractional Int) etc...
22:33:15 <mmorrow> morganson: fromIntegral
22:33:17 <Saizan> morganson: don't use (/) with Ints, you can use fromIntegral to transform them to floats, or use div
22:33:18 <Cale> morganson: That usually results from failing to convert between numeric types when you start out with an integer and then want to do fractional division with /
22:33:45 <morganson> I could paste it if you want. A very simple function just for learning the language...
22:33:50 <mmorrow> kyagrd: (and freeglut apparently only works on linux)
22:33:56 <Saizan> @paste
22:33:56 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
22:34:29 <kyagrd> mmorrow: I just tried it and I am having a so linking problem on ghc
22:34:42 <mmorrow> kyagrd: grr, what is it?
22:34:52 <kyagrd> mmorrow: configure and build worked well but on ghc when I did "view"
22:34:59 <mmorrow> kyagrd: what .so?
22:35:00 <kyagrd> Loading package vacuum-gl-0.0.4 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
22:35:05 <mmorrow> ohh, ok
22:35:10 <mmorrow> so it's a linker script
22:35:14 <mmorrow> just have top make a symlink
22:35:22 <mmorrow> (ghci's linker barfs with linker scripts)
22:35:39 <mmorrow> if you cat /usr/lib/libpthread.so you'll see what i mean
22:36:06 <morganson> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4440#a4440
22:36:17 <mmorrow> kyagrd: i did
22:36:19 <kyagrd> Oh it's a script
22:36:20 <pumpkin> is there a way to shut ghc up about overlapping pattern matches on view patterns?
22:36:21 <mmorrow> [m@monire ~]$ ls -l /usr/lib64/libpthread.so
22:36:22 <mmorrow> lrwxrwxrwx 1 root root 22 2009-04-02 01:24 /usr/lib64/libpthread.so -> /lib64/libpthread.so.0
22:36:44 <mmorrow> and renamed the script to libpthread.so_
22:37:02 <kyagrd> GHC doesn't deal so scripts too bad :(
22:37:11 <mmorrow> yeah, since it uses ld
22:37:18 <Saizan> kyagrd: it works if you compile
22:37:39 <kyagrd> well why would I compile vacuum?
22:37:40 <mmorrow> it's just that no one has added linker script support to Linker.c
22:37:51 <mmorrow> (Linker.c in ghc)
22:37:54 <Saizan> morganson: yeah, as we said you can't use the / operator with Int, it's fractional division, you can use div though, because that's integer division
22:37:57 <Saizan> ?type div
22:37:58 <lambdabot> forall a. (Integral a) => a -> a -> a
22:38:18 <ksf> is there any way to get haddock to document orphran instances?
22:38:22 <morganson> ok thank you
22:38:40 <morganson> I'll try div
22:38:49 <ksf> ...reexporting the class doesn't work.
22:39:16 <mmorrow> ksf: you can see what orphans the module has with "ghc --show-iface Foo.hi"
22:39:25 <kyagrd> I believe there already exsists this linker script request as a ticket?
22:39:37 <mmorrow> kyagrd: there does i believe
22:39:44 <ksf> erm yes but that's not really haddock.
22:39:55 <ksf> to see the orphrans, I can open the source...
22:40:00 <mmorrow> ksf: that's the only way i know the info is stored
22:40:25 <mmorrow> ksf: you could hack it into haddock possibly, since i believe haddock reads .hi files with the ghc-api though
22:40:39 <mmorrow> or something along those lines
22:41:55 <morganson> why is there a stack overflow in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4440#a4440?
22:42:10 <Saizan> btw, what are linker scripts useful for, when i convert them to symlinks i don't seem to get problems
22:42:13 <morganson> when I test the function
22:42:54 <Saizan> morganson: maybe 'a' goes negative without reaching 0?
22:42:55 <mmorrow> Saizan: you can give the linker alternates to try if the lib doesn't exist in a certain place
22:43:05 <mmorrow> Saizan: and also there're a bunch of other commands
22:43:32 <morganson> ok but how?
22:43:49 <Saizan> ah, no.
22:43:50 <blackh> Anyone know if ThreadScope has been released yet?
22:43:56 <pumpkin> it hasn't
22:44:04 <pumpkin> but it works if you grab it from the darcs repo
22:44:05 <blackh> Awwwwwwww!
22:44:08 <blackh> Thanks.
22:44:15 <bos> @hoogle concatMapM
22:44:15 <lambdabot> No results found
22:44:19 <bos> ah well.
22:44:21 <pumpkin> according to one blog post, it only compiles on 6.10 thougg
22:44:29 <Saizan> morganson: the problem is that "sumsq a-1" gets parsed as "(sumsq a) - 1" not "sumsq (a-1)"
22:44:35 <blackh> pumpkin: GHC repo?
22:44:45 <Saizan> morganson: so you recurse always with the same 'a', causing a loop
22:44:48 <pumpkin> blackh: can't remember :)
22:44:55 <morganson> thank you
22:44:57 <morganson> =)
22:45:10 * ksf can't get all that fuzz about orphran instances being bad.
22:45:15 <morganson> I must remember grouping
22:45:38 <Saizan> prefix function application bind tighter than operators
22:45:44 <Saizan> *binds
22:45:49 <morganson> ok
22:47:34 <blackh> pumpkin: I found it: http://code.haskell.org/ThreadScope/ - thanks for your help
22:47:41 <pumpkin> :)
22:48:02 <morganson> nice. I have completed the exercise. =) Proven the property wrong...
22:49:32 <aeron>  > putStrLn "Oh god i love this channel so much!"
22:49:35 <aeron> oh god
22:49:36 <aeron> :(
22:53:58 <Gracenotes> how did i get here i am not good with computer
22:56:41 <medfly> are you using someone else's computer?
23:18:01 <Saizan> > ()
23:18:02 <lambdabot>   ()
23:20:29 <ivanm> Saizan: wow, you couldn't work that out yourself? :p
23:21:21 <mmorrow> , foldr (+) () (repeat ())
23:21:22 <lunabot>  luna: No instance for (GHC.Num.Num ())
23:21:28 <mmorrow> > () + ()
23:21:29 <lambdabot>   No instance for (GHC.Num.Num ())
23:21:29 <lambdabot>    arising from a use of `GHC.Num.+' at <i...
23:21:46 <sereven> Gracenotes: And you may ask yourself How do I work this? Where is that large autoconf? And you may tell your self This is not my beautiful syntax! And you may tell yourself.... Letting the bits go by/gc flowing underground....
23:22:04 <mmorrow> haha!
23:22:19 <mmorrow> @remember sereven Gracenotes: And you may ask yourself How do I work this? Where is that large autoconf? And you may tell your self This is not my beautiful syntax! And you may tell yourself.... Letting the bits go by/gc flowing underground....
23:22:20 <lambdabot> Okay.
23:24:40 <c_wraith> @hoogle forkIO
23:24:41 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
23:26:11 <c_wraith> @hoogle hClose
23:26:12 <lambdabot> System.IO hClose :: Handle -> IO ()
23:37:06 <ClaudiusMaximus> @hoogle user
23:37:07 <lambdabot> Network.HTTP.Base user :: URIAuthority -> Maybe String
23:37:07 <lambdabot> Network.Browser userCookieFilter :: URI -> Cookie -> IO Bool
23:37:07 <lambdabot> Prelude userError :: String -> IOError
23:38:12 <copumpkin> is the a minimalist but fast pure haskell http server?
23:39:48 <ClaudiusMaximus> the is a definite article
23:40:06 <copumpkin> *there
23:41:19 <ClaudiusMaximus> what's a sensible way to get "probably globally unique" identifiers in a distributed system?
23:42:00 <copumpkin> GUID?
23:42:36 <ClaudiusMaximus> @hoogle GUID
23:42:36 <lambdabot> No results found
23:43:21 <copumpkin> http://en.wikipedia.org/wiki/Globally_Unique_Identifier
23:43:29 <copumpkin> or http://en.wikipedia.org/wiki/Universally_Unique_Identifier
23:44:13 <ClaudiusMaximus> yes, have found that - am reading
23:44:15 <ClaudiusMaximus> ta
23:50:15 <Ray__> Hey - could someone explain why I'm having type issues at "pivot" here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10932 It says 'a' is a rigid type var, but then calls 'a' 'a1' the second time.
23:52:06 <copumpkin> those lengths everywhere are bad, but that isn't your problem
23:53:48 <copumpkin> you also don't need those n > 1 guards
23:53:58 <Ray__> I know, I know.
23:54:02 <Ray__> But what /is/ the problem?
23:54:20 <copumpkin> well you didn't give any indication of where the error was so I'm trying to figure it out :)
23:54:50 <Ray__> It's at "pivot", it's complaining about the definition of 'a'.
23:54:57 <copumpkin> oh
23:55:01 <copumpkin> you need scoped type variables
23:55:12 <copumpkin> or to just not use a type sig there
23:55:12 <Ray__> What's that?
23:55:42 <copumpkin> it's what you expect to be the case, but isn't. That a is a different a from the one at the top level
23:55:46 <Ray__> Doesn't 'a' inside a where get transformed into whatever the outer scope meant by 'a' at the time of evaluation?
23:56:07 <Ray__> ('a' or whatever type var)
23:56:09 <copumpkin> nope, that means pivot :: forall a. (Integer, a)
23:56:20 <Ray__> O.o
23:56:36 <Ray__> Well that sucks. Any way to tell pivot that it should mean whatever 'a' meant above?
23:56:44 <copumpkin> yeah, scoped type variables
23:56:51 <copumpkin> {-# LANGUAGE ScopedTypeVariables #-}
23:56:56 <copumpkin> or maybe some abbreviation of that
23:57:12 <copumpkin> or you can just omit the type signature
23:57:15 <copumpkin> and it'll figure it out for you
23:57:40 <Ray__> I'm doing this for a class, and we're forced to always use type signatures
23:59:53 <c_wraith> You could re-write into several top-level functions and pass a lot more values around.
