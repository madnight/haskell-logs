00:00:23 <Hugglesworth> will do
00:00:27 <shachaf> Hugglesworth: In this case you need (Num a) => (or maybe Integral?).
00:01:40 <Vanadium> Also you probably need to give the n x case last
00:01:54 <Vanadium> The things that ghci tells you :}
00:04:09 <Hugglesworth> how do i add more than one type constraint?
00:04:49 <Hugglesworth> it's saying to: " add (Integral a) to the context of the type"
00:05:19 <Hugglesworth> but it also complians if i dont have Fractional there
00:05:30 <kmc> (Integral a, Fractional a) => a -> a -> a
00:05:44 <kmc> :t mod
00:05:45 <lambdabot> forall a. (Integral a) => a -> a -> a
00:06:06 <kmc> Hugglesworth, you might want to replace (/) in largestPrime with `div`
00:06:08 <kmc> :t div
00:06:09 <lambdabot> forall a. (Integral a) => a -> a -> a
00:06:17 <kmc> > 5 `div` 2
00:06:18 <lambdabot>   2
00:08:28 <Hugglesworth> got it down to complianing about:
00:08:29 <Hugglesworth> Ambiguous type variable ' in the constraints: ntegral t' arising from a use of argestPrime' at 3.hs:9:23-47 ractional t' arising from a use of argestPrime' at 3.hs:9:23-47
00:09:11 <Hugglesworth> how might i "add a type signature that fixes these type variable(s)"?
00:10:54 <kmc> main = putStrLn (show (largestPrime (600851475143 :: Integer)))
00:10:56 <kmc> or
00:11:17 <kmc> main = print $ largestPrime (600851475143 :: Integer)
00:11:20 <ivanm> on http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html they describe several unused bindings that can be selectively ignored by prepending an underscore to function/bindings/whatever names
00:11:22 <kmc> which is just a simplification of that
00:11:27 <ivanm> is there an overall name for this?
00:12:02 <ivanm> Hugglesworth: add a (Fractional t) => , etc. right after the ::
00:12:18 <ivanm> this is known as type classes
00:13:00 <kmc> Hugglesworth, i feel you will have trouble finding a type which is both Integral and Fractional
00:13:19 <kmc> and should instead eliminate the Fractional constraint on largestPrime
00:13:34 <kmc> which you can do if you're not using the Fractional operations
00:13:39 <kmc> which was the point of changing (/) to div
00:13:48 <Hugglesworth> gotcha
00:14:06 <c_wraith> @src Integral
00:14:07 <lambdabot> class  (Real a, Enum a) => Integral a  where
00:14:07 <lambdabot>     quot, rem, div, mod :: a -> a -> a
00:14:07 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
00:14:07 <lambdabot>     toInteger           :: a -> Integer
00:14:22 <c_wraith> @src Fractional
00:14:22 <lambdabot> class  (Num a) => Fractional a  where
00:14:22 <lambdabot>     (/)             :: a -> a -> a
00:14:22 <lambdabot>     recip           :: a -> a
00:14:22 <lambdabot>     fromRational    :: Rational -> a
00:14:36 <twb> @hoogle (Fractional a, Integral a) => a -> b
00:14:37 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
00:14:37 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
00:14:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:14:50 <c_wraith> Yeah...  Those two classes don't make much sense together.
00:15:20 <Hugglesworth> i was pretty tired when i wrote it
00:15:32 <Hugglesworth> got rid of my compile errors
00:15:47 <Hugglesworth> hit a div by 0... looks like i'll neet to re-write
00:16:14 <kmc> Hugglesworth, did you reorder your equtions for findPrime?
00:16:39 <kmc> you've put the most general equation first, which ensures the special cases will never get used
00:16:40 <Hugglesworth> order matters?
00:16:43 <kmc> yes
00:16:51 <Hugglesworth> ah
00:16:53 <kmc> patterns and guards are checked in order
00:17:21 <c_wraith> ivanm:  Is the interface to polyparse anything like parsec?  I really do think auto backtracking would be a good idea for what I'm doing.
00:17:24 <Hugglesworth> that would do it
00:22:31 <Hugglesworth> how would i cast a returned Floating type to an Integral?
00:22:39 <Axman6> round
00:22:42 <Axman6> :t round
00:22:43 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:22:49 <Axman6> maybe...
00:24:16 <c_wraith> If you're doing this from square roots, for the purpose of factoring, you can use floor
00:24:18 <c_wraith> :t floor
00:24:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:24:50 <c_wraith> Since clearly the ceiling squared will exceed the number you care about.
00:25:07 <Hugglesworth> floor (sqrt 25) ?
00:25:20 <c_wraith> :t floor $ sqrt 25
00:25:21 <lambdabot> forall b. (Integral b) => b
00:25:31 <c_wraith> > floor $ sqrt 25
00:25:32 <lambdabot>   5
00:26:14 <c_wraith> And those are equivalent to what you asked about.  Haskell just encourages you to use fewer parentheses
00:26:51 <Hugglesworth> $ is used to split function calls then?
00:27:35 <c_wraith> basically.  It means "everything before this is the function, everything after it is the argument"
00:27:47 <c_wraith> @src ($)
00:27:48 <lambdabot> f $ x = f x
00:27:52 <ivanm> c_wraith: AFAIK it's similar...
00:28:06 <Hugglesworth> good to know
00:28:58 <c_wraith> ivanm:  Which module were you using?  polyparse has 3 modules with an unclear relationship between them
00:29:26 <ivanm> c_wraith: I use lazy
00:29:36 <ivanm> c_wraith: lazy is just worse on failure than normal
00:29:48 <ivanm> (I didn't need the State ability)
00:34:20 <twb> f $ x means f ( x )
00:34:49 <twb> i.e. it's like putting parens around the RHS
00:34:58 <mauke> and LHS
00:35:03 <twb> Right, sorry
00:35:10 <twb> I mean: sorry, you are correct
00:35:22 <twb> Stupid human languages
00:39:29 <twb> dcoutts: ping.  Can foo.cabal know whether the current architecture supports -threaded?
00:40:23 <twb> dcoutts_: I need to remove -threaded for some architectures (where it isn't available), and I think the best way to do is within .cabal, rather than as an external munging script or an -f flag.
00:40:42 <gju> morgen
00:41:41 <gju> woops, wrong window.
00:42:22 <Vanadium> Guten Morgen :]
00:42:46 <gju> :)
00:43:20 <Hugglesworth> thanks for the help
00:49:47 <kmc> lojban!
00:59:27 <tibbe> Igloo: when building from source on windows I assume I should use the mingw32 version?
01:03:36 <jystic> I want to run a simple physics simulation at 100Hz, how should I go about sleeping so as not to waste processor cycles?
01:04:27 <kmc> jystic, are you displaying it somehow in realtime?
01:05:13 <jystic> kmc: I'm going to be sending udp packets to another system
01:05:17 <kmc> :t threadDelay
01:05:18 <lambdabot> Not in scope: `threadDelay'
01:05:25 <kmc> anyway it's Int -> IO ()
01:05:41 <jystic> that sounds like what i'm looking for, thanks :)
01:05:43 <kmc> and sleeps for the number of microseconds
01:06:34 <jystic> will I run in to problems if I eventually want to put a GTK gui on top of this?
01:06:41 <Jafet> "What processor?"
01:06:51 <kmc> most GUI libraries provide a way to schedule a callback at a regular interval
01:08:01 <jystic> ideally I'd like to run the simulation in it's own thread anyway, do you think that would be ok? or will the GUI libraries blow up?
01:08:24 <kmc> a typical framework for a realtime simulation is: in your draw routine, get the elapsed real time since last draw, and use that to calculate step size or number of steps
01:08:36 <kmc> use a timed callback to schedule redraw at some interval
01:08:45 <kmc> redraw could also be triggered by other events
01:09:15 <kmc> this way you don't depend on the timed callback being precise, only the measurement of actual elapsed time
01:10:09 <jystic> yeah that sounds like the way to go, I'd like to keep my step size the same all the time to prevent any inconsistencies
01:11:44 <kmc> it amuses me how totally easy and natural callbacks are in a functional language
01:15:01 <jystic> it amuses me how *all* of the cool innovative things that i liked about c# have come from haskell/functional programming
01:17:06 <kmc> the recipe for innovation in 'enterprise' languages seems to be: take a feature that's been around 30-80 years in FP; cripple it in some way; give it a new name
01:17:48 <kmc> then claim it as cutting-edge innovation while continuing to trash functional languages as useless and impractical
01:18:35 <kmc> at least MS is getting away from the last part with F#.  they still had to invent a new, less scary name for "monad"
01:18:59 <jystic> i think their new name is more scary
01:19:01 <orclev> kmc: what do they call a monad?
01:19:06 <kmc> a "workflow"
01:19:29 <Jafet> Well, it's probably descriptive of their implementation of it
01:19:39 <jystic> actually it's "computation workflow"
01:19:40 <orclev> ... a middle-manager seems to have gotten at it...
01:19:42 <kmc> the work flows from microsoft to you?
01:20:01 <kmc> i wish more python programmers would own up to the fact that the language is functional *and* object oriented.  largely because it would help destroy this silly false dichotomy between the two
01:20:36 <jystic> 'computation' and 'workflow' are both nothing words when it comes to naming imo, it's like 'manager' and 'helper'
01:20:39 <kmc> C++ is getting lambda and type inference sometime in the next decade
01:21:03 <Jafet> python is dysfunctional!
01:21:27 <orclev> MS always seems to come up with new names for existing concepts, I think they do it on purpose to try to put up a wall between MS people/shops and everyone else... they get bonus points when the pick an already commonly used term and redefine it to mean something completely opposite
01:21:47 <jystic> like computation and workflow you mean :)
01:22:30 <jystic> what's even worse is they already have 'linq' which is also monads, so now they have two names for the same thing even inside Microsoft technologies
01:22:48 <kmc> i thought linq was more like code reflection / quasiquoting?
01:23:19 <jystic> linq is like haskell do notation, but less powerful
01:23:31 <Jafet> s/powerful/scary
01:23:41 <kmc> do notation isn't scary
01:23:46 <kmc> though i wish "return" weren't named that
01:23:54 <kmc> can we made a PreludeForNoobs module?
01:23:59 <Jafet> kmc, ask a Java coder!
01:24:03 <orclev> I thought linq was their lambda-ish system for building SQL queries, or am I thinking of something else?
01:24:12 <jystic> orclev: is it
01:24:27 <jystic> but you can use it with any monad you like
01:24:45 <jystic> it's just they they only advertise it's use with the list monad
01:24:51 <kmc> every object method in python is a partially-applied function
01:24:57 <orclev> PreludeForNoobs?
01:25:07 <dibblego> and the ((->) DatabaseConnection) monad
01:25:21 <jystic> yeah that too
01:25:24 <kmc> orclev, in particular, to rename "return" to be less misleading
01:25:34 <orclev> ah, yeah, bad name that
01:25:44 <kmc> i like "pure"
01:25:54 <jystic> purify :)
01:26:19 <kmc> though (while we're griping about names) i also don't like the association of "monad = impure"
01:26:26 <kmc> which is a false generalization of "IO monad = impure"
01:26:50 <Jafet> Name a solution after the problem!
01:27:03 <orclev> I've never head anyone say "monad = impure", although I have heard a fair bit of griping about "IO = sin bin"
01:27:10 <orclev> s/head/heard/
01:27:15 <kmc> solveProblem :: Input -> Output
01:27:47 <sinelaw_> how can i write code that compiles into a value (e.g. a Map of some sort)?
01:27:54 <kmc> orclev, about the fact that it's not split up better, or about the attitude haskellers have towards IO?
01:27:57 <jystic> i'm a real newbie, but is it fair to say "monad = sequencing", or is that not always true?
01:28:12 <kmc> jystic, in some sense yes, because every monad implements (>>=) which is a sort of sequencing operator
01:28:17 <sinelaw_> for lists, i can just do value = [1, 4, 23, ....] - but for a Map?
01:28:29 <Cale> jystic: So long as you don't confuse "sequencing" with "order of evaluation"
01:28:34 <kmc> sinelaw_, Map.fromList [1, 4, 23]
01:28:37 <Jafet> Joy has a much more direct attitude to IO: take the universe as a parameter
01:28:40 <Cale> jystic: then it's not so far off
01:28:49 <dibblego> sinelaw_, fromList [(1,1), (2, 4), (3, 9)]
01:28:56 <kmc> err yeah that
01:29:03 <sinelaw_> dibblego, thanks :)
01:29:08 <jystic> Cale: cool :) win :)
01:29:23 <orclev> kmc: the particular instance I'm thinking of currently I think was a discussion about how IO is treated as the magic bullet for dealing with anything "impure", so more or less anyone you want to do something naughty just slap IO on it and call it a day
01:30:13 <Jafet> Isn't that supposed to be a good thing? Like compulsory MPAA ratings?
01:30:33 <kmc> it would be nice to have finer control over what impure actions a particular block of code is allowed to take
01:30:40 <kmc> the ST monad does this nicely for refs
01:31:15 <orclev> Jafet: way to pick a bad example
01:32:31 <Saizan> Jafet: the idea is that we could struggle to find a purer interface
01:32:46 <Saizan> to do the same thing.
01:33:15 <kmc> a lot of those "purer interfaces" are hiding some unsafePerformIO, which is hopefully very well thought out
01:33:50 <Jafet> Saizan, sure, but you can't do IO without IO
01:34:34 <Saizan> kmc: they are still trying to get a non-broken frp implementation afaik :)
01:34:46 <bastl> very technical question: in my ghci some escape sequences dont work. is there any documentation how to get the most out of the readline-lib ?
01:35:03 <bastl> (i always try Ctrl-LeftArrow etc.)
01:35:13 <Saizan> bastl: there's the trac wiki of haskeline
01:35:15 <kmc> what i wonder is if there's a systematic or semi-systematic way to reason about libraries which take liberties with the IO monad in that way
01:35:38 <kmc> ideally, some kind of type system support between the totally safe IO and the blanket unsafePerformIO
01:36:06 <Saizan> bastl: http://trac.haskell.org/haskeline/wiki
01:37:30 <kmc> again, ST is a good example
01:37:45 <bastl> nice, but not a replacement for ghci, i'm looking for something to hack more efficiently in ghci ...
01:37:53 <kmc> but we can't use its trick for something like bytestring because you have to pass refs to user code, but hopefully in types that are abstract
01:38:36 <jystic> bastl: is Ctrl+LeftArrow giving you problems?
01:38:46 <jystic> bastl: like it prints garbage on the screen?
01:38:49 <bastl> yes
01:38:58 <bastl> escape sequences
01:38:58 <kmc> is there a way (possibly by reflecting module structure?) to prove the self-containedness of the hidden IO in libraries like bytestring?
01:39:02 * kmc is thinking out loud
01:39:08 <jystic> what os are you running?
01:39:29 <bastl> ubuntu
01:39:47 <jystic> me too, i had the same problem, i'm just trying to remember how i fixed it
01:40:13 <Jafet> bastl, terminal-dependent.
01:40:22 <Jafet> (And probably readline-dependent)
01:40:48 <bastl> yeah: how can i fix that?
01:41:32 <Jafet> Wrap ghci with your favorite line editing program
01:41:42 <kmc> rlwrap?
01:42:04 <eevar2> vim/emacs' shell
01:45:10 <c_wraith> @hoogle eitherToMaybe
01:45:10 <lambdabot> No results found
01:45:13 <jystic> bastl: found it, make a file called .haskeline in you home directory and put this in it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11264
01:45:31 <jystic> that's what fixed it for me
01:45:38 <Saizan> bastl: ghci since 6.10.3 uses haskeline
01:46:22 <bastl> Saizan: ah!
01:46:27 <kmc> :type either (const Nothing) Just
01:46:31 <kmc> @type either (const Nothing) Just
01:46:32 <lambdabot> forall a a1. Either a1 a -> Maybe a
01:46:50 <c_wraith> Yeah, I just feel silly using const
01:47:29 <bastl> jystic and Saizan: that saved my day :-)
01:48:20 <jystic> bastl: it's much more fun when that stuff works :P
01:48:58 <bastl> editMode: vi :-)
01:50:08 <jystic> bastl: i can't remember where i found the syntax for that .haskeline file, but you can configure up all sorts of different bindings, i just added the basics
01:51:27 <jystic> ahh ok, it's on the page Saizan posted under CustomKeyBindings
01:53:10 <uuuu> Hey there!
01:53:45 <uuuu> I've got a problem regarding JavaScript and calculating the area of parallelogram and drawing it
01:54:00 <FunctorSalad> new version of haskell-mode is out!
01:54:15 <uuuu> Should i start by calculating the area of triangle?
01:54:27 <FunctorSalad> (actually since sunday but I missed that posting)
01:54:29 <uuuu> Because unfortunatley i'm quite 0 in JavAscript
01:56:39 <FunctorSalad> this is #haskell
01:57:27 <kmc> i don't understand how this happens
01:58:19 <FunctorSalad> kmc: maybe people just try the room with the most users
01:58:28 <FunctorSalad> *rooms
01:58:35 <kmc> uuuu, triangulating a convex polygon is easy and a good way to find its area
01:58:56 <orclev> FunctorSalad: and apparently that approach works
02:00:19 <kmc> uuuu, it sounds like your question has nothing to do with either javascript or haskell
02:00:40 <kmc> i don't get it
02:00:54 * orclev shrugs.
02:01:17 <kmc> if you want to ask a algorithm question in #foo-language you should pretend you actually want to implement the algorithm in Foo ;)
02:02:21 <bastl> kmc: despite you the ppl hanging around there know the algorithm and are friendly.
02:02:47 <bastl> I remember myself asking linux-questions on a mud-chat. that worked very well :-)
02:03:51 <orclev> I think the point is more along the lines of just because you can doesn't mean you should
02:03:57 <c_wraith> Hmm....
02:04:24 <FunctorSalad> yes. signal-to-noise etc,
02:10:49 <bauchus> hi! I found mapSnd in Data.Graph.Inductive.Query.Monad (with hoogle). Is there the same function in the base libary? (what i want is: mapSnd f (a, b) = (a, f b))
02:12:12 <bastl> what haskeline version is in ghc 6.10.3 ?
02:13:25 <fasta> How can I fill a C struct containing as a member a double foo[10], e.g. typedef struct{double foo[10]} blaat; using the FFI?
02:13:50 <ziman> > fmap (+1) (1,2)
02:13:51 <lambdabot>   (1,3)
02:14:34 <ziman> bauchus, you can use fmap, which has the same effect (but which is not as descriptive)
02:16:13 <fasta> What I need is a way to say offsetof in C2HS.
02:16:19 <bauchus> hm, i get "No instance for (Functor ((,) t))". I'm suprised, that fmap works on the snd-part of the tuple.
02:23:43 <Raevel> bauchus: there's second in Control.Arrow
02:26:41 <bauchus> thanks for the hints!
02:28:43 <c_wraith> man, this is ugly:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11265#a11265
02:29:22 <c_wraith> Seems you can't @-bind in pattern matching to a sub-pattern?
02:30:07 <c_wraith> like:  foo x:(yys@(y:ys))
02:30:14 <hackagebot> GeBoP 1.7 - Several games (HenkJanVanTuyl)
02:30:27 <c_wraith> That seems to be illegal.  And would make that code slightly better
02:41:06 <mxc> you cant?
02:41:30 <therp> c_wraith: I think that's possible
02:41:55 <therp> I can't remember an instance where "As" binders were forbidden
02:42:12 <mxc> its essentially just syncose, wld be surprising if its not allowed
02:42:39 <therp> Prelude> let x:y@(z:zs) = [1,2,3,4]; -> works
02:42:48 <c_wraith> hmm
02:42:57 <therp> also with additional parens around (y@..)
02:43:00 <Saizan> c_wraith: foo (x:yys@(y:ys)) = ..
02:43:10 <mxc> > let f a = b a where b c@z:y = y ++ [z]
02:43:11 <lambdabot>   <no location info>: Parse error in pattern
02:43:25 <mxc> > let f a = b a where b (z:y) = y ++ [z]
02:43:26 <lambdabot>   not an expression: `let f a = b a where b (z:y) = y ++ [z]'
02:45:26 <mxc> > let f a = b a  where b (a@(z:y)) = a ++ y ++ [z]
02:45:26 <lambdabot>   not an expression: `let f a = b a  where b (a@(z:y)) = a ++ y ++ [z]'
02:45:57 <Saizan> > let f a = b a  where b (a@(z:y)) = a ++ y ++ [z] in f [1,2,3]
02:45:58 <lambdabot>   [1,2,3,2,3,1]
02:45:59 <mxc> well, lambdabot, ghci says it is..
02:46:14 <Saizan> let doesn't work like that in lambdabot
02:46:19 <mxc> ah, ty saizan
02:46:52 <mxc> BTW, any chance of syncose becoming an accepted form of syntactic sugar for 'syntactic sugar'
02:48:39 <Saizan> never heard before
02:48:59 <mxc> i just made it up
02:50:12 <mxc> was reading some article that referred to glucose, and I remembered from HS biology that "-ose" is the common suffix for a sguar molecule (glucose, fructose etc) so i decided to go for an awful pun, sicne its a bit slow in here at the moment
02:57:50 <kippetje> Is there any way in Haskell to name a lambda function?
02:57:54 <kippetje> for example:
02:58:02 <kippetje> fun = \f u -> if (u==0) then True else (f (u-1))
02:58:06 <kippetje> fun :: Int -> Bool
02:58:16 <mxc> let f = \f u -> if (u==0) then True else (f (u-1))
02:58:26 <mxc> or let f u =  if (u==0) then True else (f (u-1))
02:58:45 <kippetje> no i want specifically the lambda function named
02:58:53 <kippetje> not as a function
02:59:10 <QtPlatypus> kippetje: What do you mean?
02:59:16 <mxc> what do you mean?
02:59:40 <kippetje> i want to name the lambda function such that it can call itself
02:59:43 <QtPlatypus> And what is the problem your trying to solve?
02:59:50 <kippetje> but i do not want a new function
03:00:03 <mxc> i think you need a let or where binding to make something recursive like that
03:00:06 <Saizan> kippetje: i think you want fix
03:00:22 <kippetje> yes has something to do with that
03:00:29 <Saizan> > fix (\fac n -> if n == 0 then 1 else n*(fac (n-1))) 5
03:00:30 <lambdabot>   120
03:00:54 <kippetje> fix exists in Haskell :S it gives compile errors here
03:01:08 <Saizan> import Data.Function , iirc
03:01:21 <kippetje> thanks
03:01:34 <Saizan> or Control.Monad.Fix
03:02:46 <ivanm> QtPlatypus: you got a job I take it?
03:03:01 <QtPlatypus> ivanm: No Not yet.
03:03:19 <ivanm> just sick of advertising it here?
03:03:24 <QtPlatypus> My name just reset
03:03:25 <ivanm> *for it
03:04:51 <EddyDean> is there a minimum function that returns all minimum values instead of just one?
03:05:29 <EddyDean> i got a list of tuples, and I actually want the tuple with fst as small as possible and snd as large as possible
03:05:53 <dibblego> EddyDean, start with foldl1
03:06:01 <Saizan> ?type minimumBy
03:06:02 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
03:06:47 <Saizan> maybe minimumBy (\(a,b) (c,d) -> flip compare a c `mappend` compare b d) ?
03:06:55 <EddyDean> dibblego, I'm doing it with a filter now, but I thought there must be a better way
03:07:18 <ivanm> EddyDean: you mean values such that they are less than everything else there but equal to each other?
03:08:19 <EddyDean> Let's say I have the list [ (1,2), (2,3), (1,3) ], I then want the element (1,3) because it has the smallest snd of all tuples with the smallest fst
03:08:36 <EddyDean> largest* snd, sorry
03:08:43 <dibblego> @type map (first minimum . second maximum)
03:08:44 <lambdabot> forall a a1. (Ord a, Ord a1) => [([a], [a1])] -> [(a, a1)]
03:08:57 <ivanm> EddyDean: so maximumBy then minimumBy ?
03:09:12 <ivanm> or else newtype it and define a new Ord instance
03:09:23 <dibblego> > map (first minimum . second maximum) [ (1,2), (2,3), (1,3) ]
03:09:24 <lambdabot>   No instance for (GHC.Num.Num [a1])
03:09:24 <lambdabot>    arising from the literal `2' at <inte...
03:09:31 <dibblego> bah
03:09:54 <ivanm> > maximumBy (compare `on` snd) . minimumBy (compare `on` fst) $ [(1,2), (2,3), (1,3)]
03:09:56 <lambdabot>   Couldn't match expected type `[(a, b)]'
03:09:56 <lambdabot>         against inferred type `(a1,...
03:10:03 <ivanm> bah
03:10:09 <EddyDean> I think dibblegos solution is pretty good :)
03:10:19 <ivanm> EddyDean: even though it doesn't work? :p
03:10:37 <ivanm> EddyDean: so you want to find all those with mimimum fst and then get maximum snd?
03:10:42 <Saizan> you've to do both the comparison at once
03:10:50 <EddyDean> That's right ivanm
03:10:57 <ivanm> might need to do a minimumBy, then a filter, then a maximumBy...
03:11:10 <ivanm> or else define a new comparison function
03:11:21 <Saizan> > minimumBy (\(a,b) (c,d) -> compare b d `mappend` flip compare a c) [(1,2), (2,3), (1,3)]
03:11:22 <lambdabot>   (1,2)
03:11:39 <Saizan> > maximumBy (\(a,b) (c,d) -> compare b d `mappend` flip compare a c) [(1,2), (2,3), (1,3)]
03:11:40 <lambdabot>   (1,3)
03:11:45 <EddyDean> great :)
03:12:13 <ivanm> > let comp (a,b) (c,d) | a < c = LT; | c > a = GT; | otherwise = compare d b in minimumBy comp [(1,2), (2,3), (1,3)]
03:12:14 <lambdabot>   <no location info>: parse error on input `|'
03:12:17 <ivanm> bah
03:12:39 <ivanm> Saizan: what's the mappend doing there?
03:12:50 <ivanm> and how do you know it isn't doing the reverse operation?
03:12:55 <ivanm> > let comp (a,b) (c,d) | a < c = LT; | c > a = GT; | otherwise = compare d b in minimumBy comp [(1,2), (2,3), (1,3), (2,4)]
03:12:56 <lambdabot>   <no location info>: parse error on input `|'
03:13:00 <dibblego> @type foldl1 (\(a, b) (c, d) -> (min a c, max c d))
03:13:01 <lambdabot> forall t. (Ord t) => [(t, t)] -> (t, t)
03:13:04 <ivanm> maximumBy (\(a,b) (c,d) -> compare b d `mappend` flip compare a c) [(1,2), (2,3), (1,3), (2,4)]
03:13:10 <ivanm> > maximumBy (\(a,b) (c,d) -> compare b d `mappend` flip compare a c) [(1,2), (2,3), (1,3), (2,4)]
03:13:11 <lambdabot>   (2,4)
03:13:24 <ivanm> Saizan: yours is no good, needs to do minimum of fst values first
03:13:42 * ivanm thinks his would work, except lambdabot doesn't seem to like guards in let
03:14:07 <Saizan> ivanm: how EddyDean phrased it seemed like taking the maximum of the snd took precedence
03:14:24 <Saizan> > mappend :: Ordering -> Ordering -> Ordering
03:14:25 <lambdabot>   No instance for (Test.SmallCheck.Serial GHC.Ordering.Ordering)
03:14:25 <lambdabot>    arising f...
03:14:32 <ivanm> <ivanm> EddyDean: so you want to find all those with mimimum fst and then get maximum snd? <EddyDean> That's right ivanm
03:14:35 <ivanm> Saizan: ^^
03:14:37 <EddyDean> The minimum of fst is more important
03:14:56 <Saizan> just reverse the mappend then
03:15:00 <ivanm> > LT `mappend` GT
03:15:01 <lambdabot>   LT
03:15:11 <ivanm> @src Ordering mappend
03:15:11 <lambdabot> Source not found. stty: unknown mode: doofus
03:15:15 <ivanm> bah
03:15:22 <Saizan> > minimumBy (\(a,b) (c,d) -> flip compare a c `mappend` compare b d) [(1,2), (2,3), (1,3), (2,4)]
03:15:23 <lambdabot>   (2,3)
03:15:33 <Saizan> > maximumBy (\(a,b) (c,d) -> flip compare a c `mappend` compare b d) [(1,2), (2,3), (1,3), (2,4)]
03:15:34 <lambdabot>   (1,3)
03:15:48 <Saizan> that's correct?
03:15:53 <EddyDean> Jup
03:16:00 <fasta> Does anyone know a way to fill the following C struct while _not_ using pointer-aritmetic? typedef struct{double a[2];double b[2]} foobar;
03:16:15 <fasta> (using the FFI or some tool)
03:16:19 <BONUS> the Ordering monoid owns
03:16:26 <dibblego> EddyDean, not (1,4)?
03:16:32 <fasta> hsc2hs could do it with some help.
03:16:36 <Saizan> > let xs = [LT ..] in [mappend x y | x <- xs, y <- xs]
03:16:37 <lambdabot>   [LT,LT,LT,LT,EQ,GT,GT,GT,GT]
03:16:38 <EddyDean> (1,4) is not in the list
03:16:48 <EddyDean> (1,3) is the right answer
03:16:49 <dibblego> ok
03:16:56 <Saizan> > let xs = [LT ..] in [(x,y,mappend x y) | x <- xs, y <- xs]
03:16:57 <lambdabot>   [(LT,LT,LT),(LT,EQ,LT),(LT,GT,LT),(EQ,LT,LT),(EQ,EQ,EQ),(EQ,GT,GT),(GT,LT,G...
03:17:09 <BONUS> you say true, we say thankya
03:17:09 <ivanm> dibblego: need some reading glasses? :p
03:17:32 <dibblego> nup
03:17:47 <EddyDean> Just blame me, English isn't my first language ;)
03:17:55 <ivanm> so is mappend on ordering just minimum or something?
03:18:01 <ivanm> no, wait, can't be...
03:18:30 <BONUS> the left one is kept, unless one of them is EQ
03:18:34 <BONUS> then the one that's not EQ is kept
03:19:34 <ivanm> O...K...
03:19:39 <ivanm> do I dare ask why?
03:20:01 <BONUS> it represents lexicographical ordering kind off
03:20:07 <ivanm> so mappend EQ a = a; mappend a EQ = a; mappend a _ = a ?
03:20:19 <BONUS> > zipWith compare "heyo" "heya"
03:20:19 <lambdabot>   [EQ,EQ,EQ,GT]
03:20:25 <BONUS> > mconcat $ zipWith compare "heyo" "heya"
03:20:26 <lambdabot>   GT
03:21:08 <Vanadium> neat
03:23:09 <bastl> once again i try to udnerstand the multirec paper but still dont understand the fixed-point representation of regular types. What does the compiler do at "type Expr' = Fix PFexpr" and how does it check whether a value is of type Expr'. Are there papers that introduce into that topic a bit more detailed ?
03:27:27 <Saizan> bastl: type Expr' = Fix PFexpr doesn't do much, it only declares a simpler name for Fix PExpr
03:29:37 * Cale contributes a code example to Haskell's uncyclopedia page
03:29:41 <ivanm> on http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html they describe several unused bindings that can be selectively ignored by prepending an underscore to function/bindings/whatever names; is there an overall name/term for this?
03:29:44 <ivanm> Cale: link?
03:29:57 <Cale> http://uncyclopedia.wikia.com/wiki/Haskell#Hello_world_in_Haskell -- let_in
03:30:53 <ivanm> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
03:30:54 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
03:31:12 <ivanm> hmmm...
03:31:41 <ivanm> Cale: does it even wrok/do anything
03:31:51 <Cale> ivanm: It's valid Haskell code
03:32:01 <Cale> But it doesn't do much that's interesting
03:32:08 <ivanm> what's its type sig?
03:32:12 <Cale> String
03:33:13 <ivanm> in case anyone else cares, the end value is " let let let let let let let let let let let let"
03:33:57 <dreixel> bastl_lunch: you can have a look at section 3.1 in http://www.cs.uu.nl/wiki/pub/Alexey/ALightweightApproachToDatatype-GenericRewriting/gr-wgp08-submitted.pdf
03:34:42 <dreixel> though that's not very different from that introduction in the multirec paper.
03:35:04 <ivanm> Cale: though the isBool function is obviously false...
03:47:14 <Vanadium> So do data constructors of newtypes not count as weak head normal form?
03:47:41 <fasta> Does anyone know the English for "houtje touwtje"-methode?
03:48:39 <fasta> I am not aware of something which captures exactly that meaning, other than the more generic "hack".
03:48:49 <ivanm> what would be more efficient? S.map f . S.map g, or S.fromList . map f . map g . S.toList ?
03:49:23 <ivanm> the former might have two re-sorting of the items in the tree, the latter has list fusion, so is the latter better?
03:50:10 <EvilMachine> hey, anyone here, who knows a bit or two about generating sound with a program? (I mean syntesizer stuff)
03:50:25 <EvilMachine> (but i mean writing a program in haskell that does that)
03:50:58 <BONUS> yeah, look up haskore
03:51:58 <EddyDean> fasta: kludge?
03:52:16 <ivanm> EvilMachine: awww, sure you don't want cat /dev/urandom | play (or whatever that canonical instruction is)? :(
03:53:05 <EvilMachine> ivanm: lol.
03:53:20 <fasta> EddyDean: nice try, but I don't think it's the same. I will just rewrite it.
03:53:54 <ivanm> preflex: seen roconnor
03:53:54 <preflex>  roconnor was last seen on #haskell-blah 10 hours, 39 minutes and 51 seconds ago, saying: ''Algorithmic Probability became associated with Solomonoff, who focused on prediction using his invention of the universal a priori probability distribution.
03:53:56 <EvilMachine> BONUS: i don’t want to *use* a library. :) Hascore is way too limited and cookie-cut for what i want. i want do roll my own thing. from the ground up.
03:54:05 <EvilMachine> BONUS: it’s also to learn this stuff
03:54:10 <EvilMachine> BONUS: and for fun. :)
03:54:12 <ivanm> EvilMachine: so you want to re-invent the wheel?
03:54:20 <EvilMachine> ivanm: yes and no
03:56:24 <EvilMachine> ivanm: i want stuff that can’t be done with anything out there. like a synth that knows more. like having a feeling for rhythm and what sounds good. and allows *everything*. like generating music with completely different music scales.
03:56:38 <EvilMachine> (tone scales? i don’t know the english word.)
03:56:52 <ivanm> musical scales would be about right
03:57:23 <ivanm> now, if only you were doing this to bike-shed/procrastinate, we could liken your efforts to bos and criterion... :p
03:58:00 <EvilMachine> bike-shed?
03:58:03 <EvilMachine> bos?
03:58:14 <ivanm> sorry, wrong term
03:58:16 <ivanm> it was yak-shaving
03:58:21 <EvilMachine> lol.
03:58:28 <EvilMachine> whatever. ^^
03:58:32 * ivanm somehow got his idioms mixed up
03:58:49 <EvilMachine> i have no idea what you are trying to say, ivanm ^^
03:59:12 <ivanm> EvilMachine: you don't know the story behind criterion?
03:59:29 <EvilMachine> no
03:59:35 <ivanm> http://www.serpentine.com/blog/2009/09/12/lazy-functional-yak-shaving-in-haskell/
03:59:58 <ivanm> short version: he was working on a new release of his text library, and wanted to benchmark part of it to prove it was better
04:00:16 <ivanm> so he does what everyone does: goes to hackage to find a benchmark library/tool; problem was, there were no good ones
04:00:43 <ivanm> so he decides to write one.  First thing he needs is a good statistics library, which he'll grab off hackage... whoops! there aren't any good ones!
04:01:19 <ivanm> EvilMachine: so mainly for procrastinative purposes, we ended up with two cool new libs: statistics for, um, statistics and criterion for benchmarking
04:01:58 <EvilMachine> nice. :D
04:02:34 <EvilMachine> well, i do this to learn haskell, learn how synths work internally (i make music too), and have fun with it. (and it really is fun!)
04:02:51 <EvilMachine> and when it results in something nice, i will be very happy
04:04:39 * Cyneox re
04:05:25 <mreh> a quick question: what's the best way to generate both uniformly and normally distributed random data in haskell?
04:05:40 <mreh> not at the same time
04:05:45 <mreh> before you ask
04:06:22 <quicksilver> roll dice.
04:06:24 <quicksilver> :)
04:06:36 <ksf> @unpl fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
04:06:37 <lambdabot> (((fix ((<$>) <$> ((:)))) <*> ((((\ j k -> k >>= j) <$> \ b -> (\ a -> a : []) <$> b) <$> (*)) <$> \ d -> d * 2)) 1)
04:06:44 <EvilMachine> lol.
04:06:59 <ksf> @pl fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
04:07:00 <lambdabot> fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
04:07:12 <ksf> @unpl fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> (2 *))) 1)
04:07:12 <lambdabot> fix ((((<$>) <$> ((:))) <*> ((((\ d e -> e >>= d) <$> \ a -> return <$> a) <$> (*)) <$> \ b -> 2 * b)) 1)
04:07:16 <mreh> > rolldice
04:07:17 <lambdabot>   Not in scope: `rolldice'
04:07:21 <mreh> :(
04:07:32 <EvilMachine> > random
04:07:33 <lambdabot>   Ambiguous type variable `g' in the constraints:
04:07:33 <lambdabot>    `System.Random.RandomGen...
04:07:33 <quicksilver> well the various random number generators are uniform, within the constraints of PRNGs.
04:07:49 <quicksilver> getting normally distributed data from uniform is fairly well known.
04:07:52 <EvilMachine> hmm… if hascore-synth is open source (which i guess), then i could look there for certain parts. like the sampling of wavefunctions.
04:08:08 <mreh> quicksilver: ....
04:08:13 <mreh> :D
04:08:16 <EvilMachine> something if off in my prog, when i create frequency modulations in my 2d waveforms.
04:11:10 <Baughn> "  put (ContextSnapshot a b c d e f g) = put a >> put b >> put c >> put d >> put e >> put f >> put g
04:11:21 <Baughn> ..please tell me there's a less horrible way to write that
04:12:07 <ToRA> isn't there a TH script that generates that for you?
04:12:22 <ToRA> (I'm assuming that's a binary put instance)
04:12:28 <mreh> so there is no haskell library to generate normally distributed random data already implemented
04:12:44 <Baughn> ToRA: Actually, it's a Serialize instance
04:12:56 <EvilMachine> mreh: have you checked the hackage db?
04:13:07 <Baughn> ToRA: I could hack derive to do it for me easy, sure, but that's not the point.
04:13:08 <mreh> EvilMachine: yeah, im digging
04:13:09 <EvilMachine> mreh: maybe a statistical library
04:13:10 <ivanm> mreh: statistics
04:13:13 <EvilMachine> lol
04:13:15 <EvilMachine> yeah
04:13:17 <Baughn> There should be some way to compress that code /without/ using TH
04:13:18 <ivanm> _the_ statistical library!
04:13:23 <EvilMachine> what we talked about
04:13:48 <ivanm> EvilMachine: your nick keeps making me think you're EvilTerran in a sinister disguise...
04:14:12 * EvilMachine wonders, if ivanm developed precognitive abilities from all the Haskell coding high-level brain usage. ^^
04:14:31 <ivanm> nope
04:14:54 <mreh> I find it hard to remember people on this channel, all I have to recognise you by is a nickname
04:15:06 <EvilMachine> i’m no EvilTerran. but i’m always in a sinister disguise. as every good aspiring evil overlord. :P
04:15:18 <ivanm> dammit, I need to work out how to prevent C-w from killing xchat tabs when I think I'm focussed on firefox and want to close a tab there...
04:15:42 <EvilMachine> that’s the good thing about using an instant messenger as your irc client: you can add the people and channels to your friend list.
04:15:51 <ToRA> Baughn: are those a,b,c,d,e,f,g all homogeneous or heterogeneous?
04:16:05 <PeakerWork> conal: hey, are you still here?
04:16:25 <EvilMachine> ivanm: how about remapping that binding in xchat?
04:16:33 <EvilMachine> ivanm: like mapping nothing on ctrl-w
04:16:35 <ivanm> yeah, that's what I'm trying to do
04:16:41 <ToRA> everywhereM (mkM put) might work if they were all the same type
04:16:46 <ToRA> or something in that vain anyways
04:16:47 <ivanm> but IIRC, I've looked in the past for no avail :s
04:16:55 <PeakerWork> @hoogle everywhereM
04:16:55 <lambdabot> Data.Generics.Schemes everywhereM :: Monad m => GenericM m -> GenericM m
04:17:08 <Baughn> ToRA: Heterogenous.
04:19:34 <SamB_XP> @hoogle evil
04:19:35 <lambdabot> No results found
04:19:45 <ivanm> EvilMachine: bah, didn't do anything :@
04:20:54 <EvilMachine> ivanm: :/
04:21:27 <Baughn> @quote evil
04:21:28 <lambdabot> Igloo says:  Did hugs' ./configure always end with "config.status: executing ultra-evil commands"?
04:23:03 <shambler> :-)
04:25:44 <mreh> what on earth is Control.Monad.ST?
04:25:48 <mreh> i only want random numbers
04:26:31 <Cale> mreh: ST has nothing to do with random numbers
04:26:52 <mreh> http://hackage.haskell.org/packages/archive/statistics/0.3.5/doc/html/Statistics-RandomVariate.html
04:27:06 <Cale> mreh: ah, okay
04:27:14 <Vanadium> Control.Monad.STatistics?
04:27:19 <mreh> :D
04:27:49 <Cale> ST is a monad for mutable state variables and arrays
04:28:12 <ivanm> Cale: bos' PRNG in statistics uses ST for generating them
04:28:27 <Cale> yeah, seems that way
04:28:58 <Cale> Probably so that it can internally use mutable arrays
04:29:16 <mreh> so my random number generator is wrapped up in this monad, i want to get it out
04:29:28 <mreh> is there some kind of evaluated function in ST
04:29:33 <mreh> evaluate*
04:29:46 <Cale> runST
04:30:13 <ivanm> Cale: I think he does, with the uvector stuff
04:30:59 <Cale> Ah, or withSystemRandom, which will run it in IO and pass in a Gen s constructed from the system's random number generator
04:31:09 <Cale> withSystemRandom :: (forall s. Gen s -> ST s a) -> IO a
04:31:51 <ivanm> mreh: if you want something simpler to understand, use either System.Random or mersenne-random-pure64
04:32:01 <ivanm> if you're using the latter, do _not_ use it's Random instance
04:32:07 <ivanm> as it's very slow...
04:32:10 <mreh> ivanm: i need a normally distributed list of random numbers
04:32:12 <Cale> Otherwise you need to specify a seed using the initialize function or accept a constant seed using create
04:32:44 <ivanm> mreh: yeah, you can do that for any random distribution by doing fancy stuff with trig functions IIRC...
04:32:52 * ivanm did it last year, can't remember how to do it any more :s
04:33:01 <mreh> ivanm: thanks!
04:33:10 <mreh> does irc have sarcasm
04:33:20 <SamB_XP> </sarcasm>
04:33:21 <ivanm> :p or ;-) maybe...
04:33:30 <ivanm> mreh: you want me to try and dig it out?
04:33:39 <mreh> nah, i'll just use the stats library
04:33:52 <ivanm> OK
04:33:52 <mreh> I don't really understand it, but if it works correctly then i
04:33:55 <mreh> 'm not bothered
04:34:00 <ivanm> Box-Muller is the algorithm to use IIRC
04:34:09 <ivanm> well, there's von Neumann rejection as well...
04:34:29 <SamB_XP> ivanm: I don't think making the computer feel bad is going to help :-P
04:34:45 <ivanm> heh
04:34:48 <ivanm> @slap SamB_XP
04:34:49 * lambdabot smashes a lamp on SamB_XP's head
04:38:42 <Cale> mreh: You might also just use gsl-random. It has a bunch of methods for generating values distributed according to various probability distributions.
04:38:51 <Cale> http://hackage.haskell.org/packages/archive/gsl-random/0.3.1/doc/html/GSL-Random-Dist.html#v%3AgetGaussian
04:39:20 <Cale> It's all in IO though.
04:39:24 <mreh> that looks about 30x easier
04:39:28 <mreh> thanks Cale
04:40:13 <Vanadium> 30x quicker, easier, more seductive
04:47:47 <ivanm> Cale: oh, the other gsl bindings?
04:47:57 <ivanm> mreh: there's some gsl stuff in hmatrix as well
04:58:34 <ivanm> OK, so Cale goes around randomly explaining maths stuff elsewhere as well, not just here... (just found a link of him explaining something on reddit)
04:59:28 <Saizan_> you make it sound like an xkcd comic :)
04:59:49 <quicksilver> xkcd comics often make me think of cale.
05:00:27 <SamB_XP> ivanm: there is a part of reddit that is almost here ;-P
05:00:28 <Saizan_> mh, i never made the connection before
05:00:40 <SamB_XP> haskit ;-P
05:00:42 <ivanm> quicksilver: heh
05:01:00 <ivanm> @remember quicksilver xkcd comics often make me think of Cale.
05:01:00 <lambdabot> I will never forget.
05:01:47 <Raevel> (... unless I crash)
05:01:59 <idnar> most misleading bot response /EVURRR/
05:02:10 <ivanm> @uptime
05:02:11 <lambdabot> uptime: 26d 2h 40m 14s, longest uptime: 1m 10d 23h 44m 29s
05:02:14 <quicksilver> periodically gwern wanders past and @flushes lambdabot's cistern,
05:02:20 <ivanm> quicksilver: heh
05:02:23 <quicksilver> which files the quotes to disk.
05:03:31 <mreh> what if I want to do an annoymous type function in a do context?
05:03:39 <mreh> compose it with a return
05:03:46 <MoALTz> i really don't like how notepad++ keeps trying to break my haskell code by automatically turning 4 spaces into a tab character
05:04:14 <Saizan_> mreh: type function?
05:04:36 <kippetje> MoALTz: there is an option where you can replace tabs by spaces
05:04:51 <mreh> anonymous-kind-of function
05:05:04 <mreh> I want to call a function and assign it to a value in a do
05:05:16 <Saizan_> you can still use lambdas
05:07:00 <quicksilver> let x = f y
05:07:06 <mreh> cool
05:07:06 <quicksilver> (call a functiona nd assign it to a value)
05:07:14 <quicksilver> I'm really not sure what mreh is asking, though.
05:07:19 <quicksilver> nothing very anonymous there ;)
05:07:20 <McManiaC> hey does anyone know how i can link staticly to libXY? i wrote a little "backup" tool which is supposed to run on blank systems but it keeps telling me "libcurl" is missing…
05:07:33 <ivanm> McManiaC: you mean C libs?
05:07:36 <ivanm> not sure GHC can...
05:07:42 <McManiaC> i guess so
05:07:42 <ivanm> @google ghc static linking FFI
05:07:43 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
05:07:44 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
05:07:57 <kippetje> MoALTz: Settings > Preferences > Language Menue/Tab Settings   Then at the right bottom
05:07:58 <Saizan_> i think you've to pass some option with -optl
05:07:59 <ivanm> McManiaC: that link has some
05:08:07 <ivanm> GIYF :p
05:08:13 <MoALTz> kippetje: i found it thanks
05:09:05 <mreh> [ x | x <- repeat (getFlat rng 0 1) ] : why doesn't think generate anything?
05:09:21 <mreh> > [ x | x <- repeat 1 ]
05:09:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:09:38 <Saizan_> McManiaC: -optl-static , apparently
05:09:43 <Saizan_> http://www.haskell.org/pipermail/glasgow-haskell-users/2005-March/008227.html
05:09:54 <mreh> why am i using a list comprehension?!
05:10:09 <McManiaC> Saizan_: thx, ill try
05:10:14 <mreh> repeat 1
05:10:19 <mreh> > repeat 1
05:10:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:12:07 <mightybyte> > [ 2 * x | x <- [1..] ]
05:12:08 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:15:59 <Baughn> > iterate join Nothing
05:16:00 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
05:16:23 <Baughn> ..aww. There's a perfectly sensible answer, even.
05:19:29 <McManiaC> Saizan_: http://paste.n-sch.de/1C :o
05:19:58 <Saizan_> McManiaC: did you also use --make?
05:20:09 <McManiaC> ghc --make Main -o whologin -optl-static
05:21:07 <Saizan_> maybe libcurl needs to be linked against some other C lib, and you've to specify it manually?
05:21:58 <Saizan_> yeah, it looks like it's looking for pthread and ssl
05:22:19 <Saizan_> i don't know if there's a way to make the build chain figure out those automatically
05:22:53 <McManiaC> hmm
05:24:53 <mreh> getFlat :: RNG -> Double -> Double -> IO Double -- this method returns an IO monad with a single randomly distributed double
05:25:01 <mreh> how do i make several of them?
05:25:14 <mreh> they're inside IO monad :( halp!
05:25:20 <benmachine> Baughn: but what is :t iterate join Nothing
05:28:01 <mreh> you know when you learn how to get several chars from the user in haskell, is there a general method to perform an action n times and concatonate all the results together in a list?
05:28:33 <Vanadium> replicateM
05:28:47 <benmachine> replicateM is basically sequence . replicate right
05:28:53 <Vanadium> @src replicateM
05:28:54 <lambdabot> replicateM n x = sequence (replicate n x)
05:28:58 <Vanadium> Almost~
05:29:16 <benmachine> :t replicateM
05:29:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:29:21 <benmachine> :t sequence
05:29:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:29:30 <mreh> i love haskell!
05:29:53 <Baughn> benmachine: The infinite type '#1 = Maybe #1#'
05:30:06 <Baughn> benmachine: ..I'm not sure what the usual syntax for that is.
05:30:42 <Beelsebob> oh nice, replicateM is an applicative function too
05:30:46 <Beelsebob> should have known that
05:31:11 <benmachine> :t sequenceA . replicate
05:31:12 <lambdabot> Not in scope: `sequenceA'
05:31:16 <benmachine> bah
05:31:21 * SamB_XP wonders how Sassafras K2 stops him from installing utorrent at school :-(
05:31:22 * benmachine can never remember how all the sequences work
05:32:08 <Saizan_> :t (Data.Traversable.sequenceA .) . replicate
05:32:09 <lambdabot> forall (f :: * -> *) a. (Applicative f) => Int -> f a -> f [a]
05:32:23 <Beelsebob> @let sequenceA = foldr (liftA2 (:)) (pure [])
05:32:24 <lambdabot>  Defined.
05:32:27 <benmachine> why is that in Data.Traversable
05:32:34 <Beelsebob> god knows
05:32:41 <Saizan_> :t Data.Traversable.sequenceA
05:32:42 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
05:32:44 <benmachine> Data.Foldable has sequenceA_
05:32:51 <Saizan_> it's not only for lists.
05:33:23 <benmachine> hmm I suppose that makes sense
05:33:25 <Saizan_> yeah, Foldable doesn't offer any way to reconstruct the structure
05:35:22 <sinelaw_> dons, i dunno if you got another frag patch (yesterday you said you had some pending emails) but i've sent mine too.
05:36:13 <benmachine> frag segfaults for me
05:36:36 <benmachine> with no arguments it prints usage
05:36:39 <benmachine> but
05:36:46 <sinelaw_> benmachine, what's your system?
05:36:46 <benmachine> $ ./dist/build/frag/frag leveleg
05:36:46 <benmachine> Segmentation fault
05:36:57 <benmachine> which bit
05:37:00 <benmachine> it is arch linux
05:37:01 <sinelaw_> do you have up-to-date opengl, etc?
05:37:05 <benmachine> uhm
05:37:08 <benmachine> probably?
05:37:18 <benmachine> oh
05:37:19 <sinelaw_> 2.4.0.1
05:37:25 <benmachine> I might not have up to date haskell stuff
05:37:33 <sinelaw_> cabal install opengl-2.4.0.1
05:37:51 <benmachine>     Latest version installed: 2.4.0.1
05:37:54 <sinelaw_> wait, did you compile frag yourself?
05:38:00 <benmachine> yes
05:38:24 <sinelaw_> so I dunno. bbl.
05:40:55 <Baughn> benmachine: Do other opengl programs work? glxgears?
05:41:06 <benmachine> glxgears seems fine
05:41:20 <benmachine> any other haskell opengl things to try?
05:41:26 <mreh> this GSL.Random library generates the same numbers every time
05:41:35 <mreh> in ghci
05:41:50 <benmachine> mreh: no, you're just really really unlucky
05:41:58 <benmachine> <_<
05:42:03 * Baughn notes that this Context structure is looking more and more like an SQL database. Lots of TVar (Map a b)s, little nesting.
05:42:04 <mreh> XD
05:42:10 <benmachine> (probably you need to seed something with something?)
05:42:21 <mreh> seed it with what?! a random seed?
05:42:37 <benmachine> you have to get some random from somewhere
05:42:43 <mreh> oh oka
05:42:47 <benmachine> where depends on how random you need it to be
05:42:52 <benmachine> if you are lazy look at the system clock
05:43:07 <benmachine> if it is important that it is more random than that then I dunno
05:43:14 <benmachine> /dev/random or something
05:43:20 <MyCatVerbs> If you are confident that you're on a modern Unix then open /dev/urandom, though that's a bad idea if you want to ever work on Windows.
05:43:53 <MyCatVerbs> (/dev/random if you happen to need cryptographically-secure entropy, /dev/urandom otherwise)
05:43:54 <mreh> MyCarVerbs there is a system independent one
05:44:23 <MyCatVerbs> getStdGen out of System.Random is usually a good choice.
05:45:11 <MyCatVerbs> Well, it's appropriately seeded, anyway. It's not that great of an RNG though - for that, I'd rather look up one of the Mersenne Twister libraries that's on hackage.
05:45:16 <Baughn> If you want system independence, link to openssl (hsopenssl, even) and use its random number functions
05:45:49 <Baughn> It's got both the "read /dev/random" and "carefully seeded Blum Blum Shub" equivalents
05:46:26 <MyCatVerbs> Baughn: ooh, that's a good idea.
05:54:21 <jystic> how would i got about solving this: GHCi runtime linker: fatal error: I found a duplicate definition for symbol get_current_timezone_seconds
05:54:37 <newbie> can anyone help me with problem i am having
05:54:46 <jystic> I'm using the Data.Time module
05:54:53 <newbie> i am trying to implement simple prog that has if and while in it
05:55:05 <MyCatVerbs> @where hpaste
05:55:05 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
05:55:16 <MyCatVerbs> newbie: Please use hpaste to show us your program?
05:55:22 <newbie> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4489#a4489
05:55:30 <MyCatVerbs> Thank you. Lessee...
05:56:39 <MyCatVerbs> newbie: Don't you need to add "| Constant Bool" to Expression's definition?
05:56:51 <MyCatVerbs> Otherwise you can't actually write any programs in that which will terminate.
05:57:02 <MyCatVerbs> Also, MyType isn't defined.
05:57:13 <newbie> what do you mean..oh i have MyType in different module
05:57:22 <newbie> What do you mean by constant bool
05:58:12 <MyCatVerbs> As that is defined, an Expression is either (And expr1 expr2) or (Not expr1).
05:58:20 <newbie> yes
05:58:21 <MyCatVerbs> There's no way that that ADT actually terminates.
05:58:31 <newbie> oh
05:58:46 <MyCatVerbs> You haven't added any non-recursive constructors to Expression.
05:58:57 <newbie> i wanted first to try to do while loop
05:59:02 <MyCatVerbs> So the only Expressions that you can actually write are ones which are circular. :)
05:59:13 <newbie> i did only if so far
05:59:20 <newbie> just trying to work trought it
05:59:23 <MyCatVerbs> Could you add MyType's declaration, please? And then describe what the problem that you are having is, please?
05:59:59 <newbie> just trying to add while there same as i added if
06:00:12 <MyCatVerbs> What, you want to know how to do it?
06:00:20 <MyCatVerbs> Recursively.
06:00:21 <newbie> yes
06:00:38 <newbie> doesnt have to be....i can easier undersatnd without recursion
06:00:39 <newbie> lol
06:01:22 <MyCatVerbs> newbie: How do you sequence two actions in your program?
06:01:53 <newbie> well thats another problemby my guess was this....MyProgram :+: MyProgram
06:03:10 <MyCatVerbs> How do you plan to represent program termination?
06:03:30 <MyCatVerbs> Presumably you need to add a constructor called "Stopped" to MyProgram.
06:03:52 <MyCatVerbs> Then the answer would be: run w (While e p) = if evaluateExpression w e then run (p :+: (While e p)) else run w Stopped.
06:04:27 <MyCatVerbs> But you need to decide what (run w (a :+: b)) and (run w (Stopped)) are supposed to do.
06:04:44 <newbie> did i do ok with if statement
06:04:47 <newbie> you think its good
06:05:03 <MyCatVerbs> That's roughly how I'd write that particular bit.
06:05:35 <newbie> why the while loop is so long
06:05:36 <MyCatVerbs> Honestly though, this sounds quite like an open-ended homework question rather than a specific problem. I'm afraid that I don't really have enough time to guide you right the way through that.
06:05:49 <newbie> no no..i didnt mean all the way
06:06:04 <newbie> i rather work it myself..just wanted to get some input
06:06:17 <MyCatVerbs> What do you mean by "why the while loop is so long", please? I didn't understand the question.
06:06:32 <newbie> just by means of comparing it to if statement
06:07:03 <MyCatVerbs> Oh. It's actually about the same length.
06:07:15 <newbie> yeah you right if you put it on one line..lol
06:07:22 <newbie> sorry
06:07:24 <MyCatVerbs> It's just all on one line. The If statement is split across two lines with a guard.
06:07:31 <MyCatVerbs> No trouble. Good luck. :)
06:07:35 <newbie> thanks MyCat
06:15:08 <m0nkfish> is there a prelude function x y = [x,y]
06:15:38 <quicksilver> no
06:15:41 <Vanadium> @pl f x y = [x, y]
06:15:41 <lambdabot> f = (. return) . (:)
06:15:49 <quicksilver> \x y -> [x,y] is not very hard to type though ;)
06:16:06 <ivanm> I dunno...
06:16:07 <ivanm> ;-)
06:16:21 <mreh> uh, how can I convert integrals to Word types, there doens't seem to be an interface
06:16:30 <Vanadium> fromIntegral?
06:16:33 <ivanm> fromIntegral
06:16:37 <ivanm> @hoogle Integer -> Word
06:16:37 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
06:16:37 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
06:16:37 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:16:48 <ivanm> @hoogle (Integral a) => a -> Word
06:16:48 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
06:16:48 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
06:16:48 <lambdabot> Prelude div :: Integral a => a -> a -> a
06:17:01 <mreh> neat trick
06:17:44 <mreh> nothing then :\
06:18:35 <quicksilver> nothing?
06:18:44 <gwern> fookin prawns!
06:19:18 <ivanm> mmmmmm...... prawns...
06:19:44 * EvilTerran prefers ((++)`on`return) to ((.return).(:))
06:20:34 <PeakerWork> @unpl (.return) . (:)
06:20:34 <lambdabot> (\ d g -> ((:)) d (return g))
06:20:43 <PeakerWork> @unpl (:) . (.return)
06:20:44 <lambdabot> (\ d -> ((:)) (\ g -> d (return g)))
06:21:21 <Axman6> ((:))? seriously lambdabot?
06:21:34 * quicksilver preferes ((++)`on`(:[])) to (++)`on`return
06:22:53 <EvilTerran> ?type on(++)pure -- golf!
06:22:54 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Applicative f) => a -> a -> f a
06:23:00 <EvilTerran> uhhh
06:23:02 <EvilTerran> ?type (++)
06:23:03 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:23:18 <mreh> setSeed :: RNG -> Word64 -> IO () -- I have to pass this a random number, but I can only get a random Integer
06:23:29 <EvilTerran> , [$typ| on(++)pure |]
06:23:32 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
06:23:36 <EvilTerran> , [$ty| on(++)pure |]
06:23:40 <lunabot>  forall a . a -> a -> [] a
06:23:56 * EvilTerran is done now
06:24:36 <PeakerWork> EvilTerran: Cale's evil modifications :)
06:24:57 <Jafet> mreh, since Integer is indefinite size, "random Integer" doesn't make sense
06:25:16 <ivanm> Jafet: they use an arbitrary bound IIRC
06:25:28 <ivanm> mreh: where is this?
06:26:13 <PeakerWork> Jafet: you can have non-uniform distribution that can generate arbitrarily large integers
06:26:19 <Axman6> mreh: have you tried fromIntegral?
06:26:22 <mreh> http://hackage.haskell.org/packages/archive/gsl-random/0.3.1/doc/html/GSL-Random-Gen.html#v%3AsetSeed
06:26:25 <PeakerWork> Jafet: randomize whether to continue or stop, and then randomize the next bit
06:26:47 <Jafet> That was the point I was driving at
06:26:57 <ivanm> mreh: rngType with newRNG ?
06:27:12 <ivanm> even better: newRNG mt19937
06:27:21 * Jafet plucks a uniformly random integer from nowhere
06:27:25 <mreh> ivanm, that's what i'm using
06:27:32 <ivanm> mrso what's wrong with that?
06:27:48 <PeakerWork> Jafet: who says it has to be uniform all the way over to infinity? :)
06:28:41 <EvilTerran> PeakerWork, i figured
06:29:04 <ivanm> mreh: what's wrong with that though?
06:29:17 <ivanm> you can then use univorm integers, etc.
06:29:40 <ivanm> there should be no need to use setSeed AFAICT
06:29:53 <ivanm> (unless you need reproducable random numbers...)
06:31:12 <m0nkfish> can someone help me out with this: http://pastebin.com/d219ed1e4
06:31:36 <m0nkfish> im getting an error trying to apply the heads function to the first list
06:31:46 <gal_bolle> is there a way to make haskell-mode use cabal build to recompile my hs files when they are not in the directory where the cabal file lives?
06:31:47 <Zao> So what error does your compiler give you?
06:31:53 <gal_bolle> (but in a subdir)
06:31:58 <m0nkfish> Occurs check: cannot construct the infinite type: a = [a]
06:32:15 <m0nkfish> i dont understand the error, l is a list by definition
06:32:16 <gwern> it's funny you guys bring up uniform random integers to infinity; since I spent the last few weeks thinking over Pascal's Mugging, a philosophy problem involving just that
06:33:01 <JordiGH> Are there any free Haskell books you guys can recommend?
06:33:11 <gwern> yes
06:33:12 <Axman6> @where rwh
06:33:12 <lambdabot> is http://www.realworldhaskell.org/blog/
06:33:14 <Axman6> @where lyah
06:33:14 <lambdabot> www.learnyouahaskell.com
06:33:19 <Zao> m0nkfish: What's the type of the expression (heads ls)?
06:33:20 <Axman6> JordiGH: ^^^^^^^^^^^^^^^^^^^^^^^^
06:33:28 <PeakerWork> gwern: is there a way to get a uniform random distribution integer to infinity?
06:33:48 <gwern> PeakerWork: a non-infintesimal one? nope!
06:33:48 <Zao> Hrm, nvm.
06:33:50 <m0nkfish> zao: the heads function works
06:33:50 <Jafet> Define "uniform random distribution integer to infinity"
06:33:56 <gwern> and I'm not sure about infintesimals either
06:34:00 <PeakerWork> gwern: yeah, that's what intuition says too
06:34:04 <Axman6> JordiGH: i recommend lyah before rwh
06:34:11 <Vanadium> gwern: It cannot be a very interesting problem if it does not have a wikipedia article
06:34:15 <JordiGH> Hm, I'm wary of anything that calls itself a "tutorial".
06:34:17 <gwern> Vanadium: oh it does
06:34:18 <m0nkfish> zao: its the use of heads in the transpose function that is being complained about
06:34:34 <gwern> Vanadium: problem is, it's in an article neither your nor I have ever heard of or could understand
06:34:43 <JordiGH> But I guess it's a good start. I'm just used to C++ where anything that calls itself a "tutorial" is going to try to teach a bunch of bad habits that will soon have to be unlearned.
06:34:44 <Axman6> m0nkfish: heads takes [[a]] right?
06:34:47 <Zao> m0nkfish: heads l seems wrong.
06:34:47 <Vanadium> That does not exactly narrow it down for me :(
06:34:52 <Zao> As the type of l is [a]
06:35:07 <gwern> heads? what's that, map head?
06:35:09 <gwern> @src heads
06:35:09 <lambdabot> Source not found. You speak an infinite deal of nothing
06:35:15 <Axman6> but you're giving it the head of a list of type [[a]], which means you're giving heads [a]
06:35:17 <Zao> gwern: http://pastebin.com/d219ed1e4
06:35:19 <Zao> gwern: Basically.
06:35:20 <m0nkfish> oh i see what im doing wrong
06:35:34 <m0nkfish> i had a re-think halfway through but kinda stuck to what i was doing
06:35:40 <m0nkfish> its a jumbled mess haha
06:36:06 <m0nkfish> i need to write a tails function
06:36:33 <Zao> Note that there exists a function called "tails" already.
06:36:38 <Zao> > tails [42, 3, 5]
06:36:39 <lambdabot>   [[42,3,5],[3,5],[5],[]]
06:36:48 <m0nkfish> transpose ls = heads ls : tails ls
06:36:49 <Zao> Not the kind of tails you want though.
06:36:53 <PeakerWork> > (map inits . tails) [42, 3, 5]
06:36:54 <lambdabot>   [[[],[42],[42,3],[42,3,5]],[[],[3],[3,5]],[[],[5]],[[]]]
06:36:58 <mreh> can I explicitly reference a method inside a class?
06:37:07 <zygoloid> > let heads = init . map head . tails  in heads [1,2,3]
06:37:08 <lambdabot>   [1,2,3]
06:37:11 <Zao> > map tail ["omg", "wtf", "bbq"]
06:37:12 <lambdabot>   ["mg","tf","bq"]
06:37:21 <Zao> I assume that's the kind of tails you need?
06:37:27 <PeakerWork> mreh: what do you mean?
06:37:28 <m0nkfish> oh i forgot about map
06:37:30 <m0nkfish> *sheepish*
06:37:50 <m0nkfish> transpose ls = map head ls : map tail ls
06:38:09 <Axman6> not quite
06:38:44 <m0nkfish> hmmmm
06:38:46 <Axman6> transpose ls = map head ls : transpose (map tail ls) i think
06:38:50 <m0nkfish> transpose ls = map head ls : transpose (map tail ls)
06:38:52 <m0nkfish> yeah
06:39:00 <Axman6> but that will break
06:39:12 <mreh> PeakerWork, Eq.(==)
06:39:16 <Axman6> > transpose [[1,2,3],[1,2],[1..4]]
06:39:17 <lambdabot>   [[1,1,1],[2,2,2],[3,3],[4]]
06:39:17 <mreh> or whatever the syntax might be
06:39:19 <Baughn> mreh: That's just (==)
06:39:35 <PeakerWork> mreh: classes aren't namespaces, so the methods just go into the containing (module's) namespace
06:39:38 <Baughn> mreh: The name can't be reused in other classes, so it already identifies Eq
06:39:48 <PeakerWork> mreh: you can explicitly refer to the namespace that defines (==), in this case its just Prelude
06:39:52 <m0nkfish> is there already a transpose
06:39:59 <PeakerWork> @index transpose
06:39:59 <lambdabot> Data.List
06:40:10 <PeakerWork> m0nkfish: yeah, in Data.List, as @index tells us
06:40:11 <Axman6> m0nkfish: yes
06:40:12 <PeakerWork> @hoogle transpose --info
06:40:12 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
06:40:13 <lambdabot>  
06:40:13 <lambdabot> The transpose function transposes the rows and columns of its ByteString argument.
06:40:18 <PeakerWork> @hoogle transpose
06:40:19 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
06:40:19 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
06:40:19 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
06:40:50 <PeakerWork> Baughn, m0nkfish: The (==) name can be re-used, by hiding (==) from Prelude and redefining it to be anything else. Then you can access the original (==) using (Prelude.==)
06:41:36 <m0nkfish> leave me out of this ;)
06:42:19 <Baughn> PeakerWork: But hiding the prelude is clearly heresy
06:42:36 <PeakerWork> Baughn: plenty of people do it (points at Cale)
06:42:44 <Messi> juego de boxeo online http://www.kobox.org/kobox-fande-Nourine.html
06:42:50 <PeakerWork> Baughn: I think Control.Category is meant to replace Prelude's (.) and id
06:43:07 <m0nkfish> mapping head broke because its trying to apply it to empty lists
06:43:26 <Baughn> safeHead :: [a] -> Maybe a
06:43:34 <Baughn> Otherwise known as listToMaybe
06:44:19 <m0nkfish> i need to check to see if any of my lists are empty
06:44:53 <Axman6> i wouldn't
06:45:33 <Axman6> well, not explicitly
06:45:51 <Baughn> map null?
06:46:06 <Baughn> or . map null, even
06:46:57 <Zao> > any null ["omg", "", "bbq"]
06:46:58 <lambdabot>   True
06:47:44 <Baughn> > any id $ map null ["erf","","world"]
06:47:44 <lambdabot>   True
06:48:15 <PeakerWork> @check (\xs -> any id xs == or xs)
06:48:16 <lambdabot>   "OK, passed 500 tests."
06:49:55 <m0nkfish> > any null ["a"]
06:49:56 <lambdabot>   False
06:50:14 <m0nkfish> > not any null ["a"]
06:50:15 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
06:50:15 <lambdabot>         against inferred type ...
06:50:25 <m0nkfish> hmmmmm
06:50:27 <m0nkfish> > not (any null ["a"])
06:50:28 <lambdabot>   True
06:50:31 <m0nkfish> ok cool
06:52:10 <mercury^> > or (null <$> ["what", "is", "up", "with", "this", "?"])
06:52:11 <lambdabot>   False
07:11:10 <sior|oifig> is it possible to use cabal-install to upgrade GHC?
07:12:08 <gwern> no
07:12:55 <sior|oifig> thanks gwern =)
07:12:55 <ray> "Haskell is used as a research language, where its support for codependent types has allowed advances in the field of dysfunctional programming."
07:13:03 <ray> that would be pretty funny if haskell had dependent types!
07:13:07 <gwern> ray: uncyc, eh?
07:13:15 <fnord123> http://uncyclopedia.wikia.com/wiki/Haskell
07:13:26 <ray> inaccurate comedy :(
07:13:28 <mreh> http://haskell.pastebin.com/m123eba03 - I can't see what is wrong with this personally
07:13:28 <pharm> Did anyone get to see SPJ's talk in Oxford yesterday?
07:13:36 <pharm> Was stuck at home with sick children...
07:13:55 <Baughn> Careful, uncyclopedia is.. um, NSFW.
07:14:19 <fnord123> Baughn: it's mostly sfw, maybe you're thinking of Encyclopedia Dramatica
07:14:29 <Baughn> ..I may be?
07:14:44 <JordiGH> (Using lambda to mean A)--
07:15:19 <Lemmih> sior|oifig: Not yet.
07:16:35 <JordiGH> So why is Haskell a stag beetle?
07:16:51 <JordiGH> Oh, never mind, they explain it.
07:16:58 <tumult> mreh: that's not how return works :)
07:17:42 <mreh> tumult: the type of main :: IO a
07:18:12 <JordiGH> or should I say
07:18:13 <tumult> well are you going to do something with it
07:18:16 <JordiGH> pred "Using lambda to mean A"
07:18:17 <JordiGH> ?
07:18:21 <ray> return should be renamed to intern
07:18:27 <ray> it has no flow control, all it does is type
07:18:55 <Baughn> It should be renamed to pure, rather.
07:18:57 <tumult> it tripped me up for a couple of minutes when i was learning monads a couple of weeks ago
07:19:12 <zygoloid> "In fact, all data items are treated as infinite lists of length 1. Other infinite lists may be longer."
07:19:15 <zygoloid> rofl
07:19:15 <Baughn> If you make Monad a subclass of Applicative (which it should be), then return = pure
07:19:39 <mreh> tumult: have you tried compiling it?
07:20:28 <gwern> hm. those stack overflows weren't there l;ast time I read the uncyc entry :)
07:20:36 <gwern> but I still think Objectivist C is better
07:20:46 <Baughn> gwern: They turned off optimization when compiling the page
07:21:16 <tumult> haha objectivist c
07:21:20 <JordiGH> Ayn Rand has a C derivative?
07:21:56 <JordiGH> uh
07:22:03 <JordiGH> There is no whitespace thing here, is there?
07:22:04 <tumult> mreh: i don't have GSL
07:22:49 <gwern> JordiGH: oh sure. in Objectivist C, 'objects allocate and deallocate memory themselves in accordance with their rational self-interest'
07:23:07 <MyCatVerbs> ray: Meh, we still have a Turing complete type system.
07:23:31 <JordiGH> Does Haskell have a whitespace thing?
07:23:43 <opqdonut> what do you mean
07:23:52 <opqdonut> whitespace matters in haskell code, yes
07:23:57 <MyCatVerbs> JordiGH: the answer is probably "yes", but. :)
07:24:05 <JordiGH> Oh, crap.
07:24:06 <MyCatVerbs> JordiGH: Haskell has optional syntactic whitespace.
07:24:08 <JordiGH> It has a whitespace thing.
07:24:09 <opqdonut> indentation, like in python
07:24:10 <quicksilver> mreh: instead of 'return' use 'print'
07:24:14 <MyCatVerbs> If you indent like Python, then that works.
07:24:17 <quicksilver> mreh: main must be IO (), IIRC.
07:24:22 <opqdonut> but it is optional, you can use { ; ; ; } if you like
07:24:25 <MyCatVerbs> If you really don't like that, then you can use {;} instead, and that works too.
07:24:30 <JordiGH> Oh, phew, it's optional.
07:24:35 <gwern> quicksilver: but it could be IO(IO ())!
07:24:47 <gwern> main can be a lot of types, apprently
07:24:50 <opqdonut> JordiGH: it's not that bad actually
07:24:56 <MyCatVerbs> JordiGH: I would usually recommend using the whitespace sensitivity because it makes the code physically prettier to look at, and it's less typing. :)
07:24:57 <hackagebot> hxt 8.3.2 - A collection of tools for processing XML with Haskell. (UweSchmidt)
07:24:59 <hackagebot> regular-extras 0.1.2 - Additional functions for regular: arbitrary,  coarbitrary, and binary get/put. (JosePedroMagalhaes)
07:25:01 <hackagebot> regular 0.2.1 - Generic programming library for regular datatypes. (JosePedroMagalhaes)
07:25:07 <silver__> JordiGH, it's kinda cool
07:25:16 <MyCatVerbs> JordiGH: But the fact that you can thrown braces and semicolons in is quite handy for one-liners.
07:25:24 <JordiGH> What happens if you mix tab and spaces_
07:25:34 <silver__> just use spaces
07:25:37 <silver__> everywhere
07:25:48 <tumult> JordiGH: it's a bad idea but it just depends on how much whitespace there is relative to the previous line
07:26:05 <MyCatVerbs> JordiGH: IIRC, tabs are interpreted exactly the same way that a terminal emulator interprets them - bumping you up to the next 8-column boundary.
07:26:20 <tumult> ah
07:26:23 <tumult> good to know
07:26:32 <Taejo> I think it's about time GHC started murdering people who mix tabs and spaces
07:26:37 <Baughn> It's still not a good idea to use them. IMO, they should've been a lexical error.
07:26:46 <Baughn> As it is.. add a warning to -Wall?
07:27:01 <MyCatVerbs> JordiGH: That conflicts like the bejeezus with text editors that use tabs to mean 4-column boundaries. It's better to just use spaces, simply because no two programmers on this planet have ever managed to agree with one another on how their text editors should display tabs. :)
07:27:07 <quicksilver> mreh: also , always paste the error message it makes it much easier for people to help you
07:27:48 <mreh> oh: http://haskell.pastebin.com/m6e48b91e
07:28:15 <tumult> yeah you should do return () at the end
07:28:56 <tumult> if you are trying to read the numbers value in the terminal, you should print it before return ()
07:29:59 <gwern> Baughn: isn't there a -warn-tabs?
07:30:37 <Baughn> gwern: I don't know. I don't actually have a tab key, so it never mattered.
07:30:42 <Baughn> (I have a tab-completion key instead. :P)
07:30:56 <gwern> no tab key? but how do you move from field to field in forms?
07:31:00 <Baughn> I do know it isn't in -Wall
07:31:15 <Baughn> gwern: In Emacs. Firefox is a different matter.
07:31:57 <Baughn> Point is, I've got (global-unset-key (kbd "TAB")) or some such in .emacs
07:32:15 <ToRA> there is a -fwarn-tabs
07:32:29 <helge_> probably a stupid question, but why is it that `show 5` isn't ambigous when `read ()` is?
07:32:50 <zygoloid> helge_: because "read ()" is unambiguously an error? :)
07:32:55 <quicksilver> helge_: the prelude has a digusting hack for numeric types
07:33:02 <quicksilver> helge_: so that 5 defaults to Int
07:33:06 <quicksilver> helge_: and then there is no ambiguity.
07:33:16 <helge_> zygoloid: oh, I meant read "()" of course :)
07:33:27 <quicksilver> s/prelude/language definition/ actually
07:33:32 <helge_> quicksilver: exactly, but I get that error nonetheless
07:33:34 <gwern> > read "()" :: ()
07:33:35 <lambdabot>   ()
07:33:40 <gwern> seems to work
07:33:45 <quicksilver> lambdabot doesn't run haskell
07:33:50 <gwern> :)
07:33:52 <helge_> doesn't work with ghci
07:33:54 <quicksilver> it runs some butchered glasgow dialect
07:33:59 <quicksilver> including extended defaulting.
07:34:05 <gwern> gotta like thosee xtended defaults!
07:34:19 <quicksilver> but, gwern put the type sign in anyway
07:34:23 <quicksilver> > read "()"
07:34:24 <lambdabot>   ()
07:34:31 <quicksilver> it works without it, in lamdabot
07:34:38 <zygoloid> (and in ghci iirc)
07:34:40 <quicksilver> helge_: did I not answer your questio? I thought I had.
07:34:43 <Baughn> ..because \bot defaults to (), yes. ^^;
07:34:45 <Baughn> > read "2"
07:34:46 <lambdabot>   * Exception: Prelude.read: no parse
07:35:09 <helge_> quicksilver: yes you did, did I say anything else? :) thanks
07:35:21 * zygoloid erases previous action
07:35:29 <quicksilver> well you said "exactly but I get that error nonetheless"
07:35:33 <quicksilver> I thought you were disagreeing :)
07:36:19 <helge_> quicksilver: never mind that sentence, I misunderstood you at first
07:36:23 <quicksilver> ah, ok :)
07:37:50 <tumult> apparently 2000 lines of objective-c = 200 lines of haskell, at least according to my first gui haskell app, which is a rewrite of an existing app i did
07:37:52 <helge_> I meant that () can't be unambigous, since its only type can be (), right? hence the confusion on why ghci can't find which type to use
07:38:24 <Baughn> helge_: The type-checker runs before it gets to look at any /values/
07:38:31 <mreh> I've still having trouble with this, I've pasted the exact error message. The return type of the method next is just contrary to what the documentation says
07:38:36 <Baughn> helge_: So, ghci knows you're passing a string to read, but not that the string contains "()".
07:38:40 <mreh> http://haskell.pastebin.com/m6e48b91e
07:38:58 <mreh> I'm looking at the correct version of the doc
07:39:07 <helge_> Baughn: Ah, makes sense. Thanks
07:39:07 <mreh> rand-1.0.0.1
07:39:40 <tumult> mreh: when you "return numbers" you are putting the numbers value back into the monad, not returning it as the result of a function like you would in c
07:40:36 <mreh> tumult: i know, i've changed my code to correct that, look at the error though
07:40:56 <quicksilver> mreh: where is 'next' from?
07:41:18 <mreh> System.Random
07:41:39 <quicksilver> oh right
07:41:53 <tumult> oh
07:41:57 <quicksilver> next has type g -> (Int , g)
07:42:01 <quicksilver> not g -> IO (Int , g)
07:42:05 <quicksilver> so you don't want to use <- to call it
07:42:09 <Baughn> mreh: "return a" doesn't mean "you, return a from here", it means "construct a monad value that, if executed, returns a".
07:42:09 <quicksilver> it's not a monadic function.
07:42:15 <quicksilver> Baughn: that's not the problem here though.
07:42:22 <quicksilver> the problem is just misusing 'next'
07:42:26 <mreh> quicksilver understands me
07:42:40 <tumult> sorry it's the first thing that jumps out when you look at it :)
07:42:49 <mreh> misusing?
07:42:51 <quicksilver> you just want let (n,_) = next seedGen
07:42:55 <Baughn> mreh: No. Nobody understands you. You will.. gah, sorry, that was too easy.
07:42:56 <tumult> yeah
07:42:57 <quicksilver> not (n,_) <- next seedGen
07:43:05 <quicksilver> because 'next' is not monadic.
07:43:16 <mreh> oooooooooooh
07:43:36 <quicksilver> (incidentally 'next' is mostly an internal function it's not intended for normal use but it will do for your purposes here)
07:43:44 <Baughn> It'd probably be nice to use RandomT, but that's only for after you don't need to. :P
07:44:22 <mreh> nooooO! my randoms are still the same every time!
07:44:24 <mreh> i must be the luckiest man alive
07:44:38 <tumult> haha
07:45:20 <mreh> what's the point in a random number library that is completely deterministic
07:45:46 <Baughn> It's a /pseudo-/random number library
07:46:04 <Baughn> They're all like that. It's a feature. You just have to take care to seed and use the states correctly.
07:46:17 <quicksilver> he does!
07:46:27 <quicksilver> will someone please read the poor guy's source code before criticising him?
07:46:33 <quicksilver> the whole code is about seeding it.
07:46:33 <mreh> I just fixed it
07:46:34 <tumult> haha
07:46:42 <silver__> mreh, http://xkcd.com/221/
07:46:49 <tumult> gsl wouldn't build for me
07:46:52 <Vanadium> I heard you are using pseudo-random numbers? Heh, pseudo-programmers...
07:46:59 <tumult> probably because i don't have the main lib installed right
07:47:13 <sproingie> everyone knows 7 is the most random number
07:47:17 <mreh> tumult: on debian?
07:47:22 <tumult> os x
07:47:23 <Baughn> mreh: Okay, okay, I'll read your code.
07:47:33 <mreh> Baughn, i've fixed it
07:47:38 <Baughn> mreh: ..any reason not to use randomIO instead of next?
07:47:48 <mreh> Baughn: i dont know
07:48:54 <Baughn> mreh: Righto. In that case, do so. ;)
07:49:06 <m0nkfish> regarding this function:
07:49:07 <m0nkfish> powerset (x:xs) = map (x:) (powerset xs) ++ powerset xs
07:49:16 <m0nkfish> how can i avoid using powerset twice
07:49:33 <FunctorSalad> let/where
07:50:07 <FunctorSalad> p (x:xs) = let p0 = p xs in map (x:) p0 ++ p0
07:50:19 <Botje> > filterM (const [False, True]) [1..3] -- /me runs
07:50:21 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
07:50:38 <m0nkfish> thanks
07:51:22 <quicksilver> although, interestingly, sharing the powerset makes the memory usage worse.
07:51:29 <mreh> how can a method return a generic type?
07:51:46 <mreh> without some kind of input to determin the type
07:51:52 <FunctorSalad> quicksilver: that's possible? :O
07:51:59 <quicksilver> IIRC, the naive powerset runs in linear space whilst the shared one runs in exponential space
07:52:02 <FunctorSalad> s/:O/D:/
07:52:15 <quicksilver> (excluding the size of the output which is obviously exponential in either case)
07:52:15 <Vanadium> mreh: look at the Text.Printf source for an example
07:52:22 <quicksilver> mreh: well, it just can.
07:52:22 <FunctorSalad> quicksilver: depends on what you do with the result no
07:52:33 <quicksilver> FunctorSalad: but assuming you have a 'good consumer' of the result.
07:52:39 <quicksilver> FunctorSalad: then the different may matter.
07:52:42 <quicksilver> difference.
07:53:03 <FunctorSalad> well yes I can see how the second p0 isn't consumed immediately...
07:53:04 <quicksilver> mreh: as to how it decides which type to use - that's down to type inference.
07:53:29 <mreh> quicksilver, my compiler can't work it out
07:53:36 <quicksilver> yes, you have to tell it
07:53:36 <mreh> shall i add a type signature?
07:53:39 <quicksilver> yes.
07:53:42 <mreh> :D
07:53:44 <quicksilver> in certain circumstances you have to tell it.
07:53:51 <koala_man> is there a lib for directed graphs with annotated edges?
07:53:51 <quicksilver> if there isn't information elsewhere to make it clear
07:53:52 <Younder> Ok, got haskabelle runs
07:53:53 <HayashiRazan> Is there a program better than GHCi?
07:54:07 <tumult> winamp
07:54:34 <tumult> sorry, had to think up something on the spot
07:54:48 <Younder> Isabelle rocks!
07:55:13 <JordiGH> MyCatVerbs: Each terminal emulator is free to interpret tabs however it wishes. A tabwidth of 8 isn't hardwired anywhere.
07:55:15 <FunctorSalad> Younder: how so? just curious since I haven't tried it
07:56:26 <Younder> FunctorSalad,  It is a mathematical proof system, tightly linked to Haskel through haskabelle
07:56:49 <MyCatVerbs> JordiGH: Mmmm. I think terminal emulators need to use a tabwidth of 8 for compatibility with programs that expect a something almost identical to a vt100.
07:57:10 <FunctorSalad> Younder: yeah, thought you were comparing it to other proofsystems though
07:57:31 <JordiGH> MyCatVerbs: Hm, maybe Unix terminals, perhaps.
07:57:42 <MyCatVerbs> JordiGH: I have not myself come across one that doesn't, either way. And IIRC that's how both Python and Haskell interpret tabs, modulo the fact that I occasionally make mistakes and misremember things.
07:58:00 <Younder> FunctorSalad, The only ones I use are ACL2 and Isabelle
07:58:23 <MyCatVerbs> JordiGH: Oh, I would also strongly expect Windows terminals to always use 8-column tabs because old DOS programs used to assume 8 column tabs too.
07:58:24 <Younder> FunctorSalad, As such I prefer Isabelle
07:58:46 <MyCatVerbs> JordiGH: and there's not really very much to be gained by breaking backward compatibility with that code either. :)
07:59:19 <JordiGH> I have Emacs setup to use spaces. I was inadvertently working on some Python code that uses tabs. My tabwidth is usually 2 or 4, but at any rate, I had code that looked on the editor as if it was indented one way and I didn't catch the bug until I decided to investigate the whitespace thing. It's not that I mix tabs and spaces, it's just that I use spaces, other people use tabs, and mixing might occur inadvertently. I'll have to be careful that thi
07:59:19 <JordiGH> s doesn't happen with Haskell.
07:59:51 <JordiGH> Anyways, once bitten, twice shy, the whitespace thing isn't all that great.
08:00:08 <quicksilver> agreed.
08:00:15 <Younder> Emacs can be set up to use only spaces..
08:00:16 <quicksilver> the haskell convention is no, seriously, just don't use tabs.
08:00:19 <MyCatVerbs> JordiGH: Personally, I like to use a vim setting which highlights mismatched tabs+spaces.
08:00:33 <JordiGH> Younder: Yeah, that still doesnt' make all the code in the world not use tabs.
08:00:34 <quicksilver> and there is a pretty good emacs indentation mode which gets it right.
08:00:36 <Younder> In general NEVER rely on tabs
08:00:51 <tumult> JordiGH: that's what :retab is for, or the emacs equivalent :)
08:00:59 <MyCatVerbs> JordiGH: I'm absobloodylutely certain that it's pretty easy to do the same in Emacs. That's what I'd do if I switched to Emacs, anyway.
08:01:09 <JordiGH> Tabs are ok for indentation and spaces for alignment, at least in C languages. I'm not sure you can do the same in languages with a whitespace thing.
08:01:26 <JordiGH> tumult: Yeah, and then you submit giant diffs upstream.
08:01:29 <HayashiRazan> :t JordiGH
08:01:29 <lambdabot> Not in scope: data constructor `JordiGH'
08:02:06 <Younder> Make tab stand in for spaces. that is on tab is 4 (for exaple) spaces. Now have it convert it on reading as well
08:02:29 <Younder> That's what  I have
08:02:30 <JordiGH> MyCatVerbs: There's a way to show tabs in Emacs. But if you set the wrong tab width and start using spaces, there's no way to tell at a glance if you are in the right codeblock unless you take care to count the tabs.
08:03:22 <Younder> True, you can't SEE it
08:03:25 <JordiGH> MyCatVerbs: And Emacs can't tell that you didn't mean that code block, nor can any other editor, not without some serious AI we haven't created yet afaik
08:03:38 <Younder> JordiGH, That is riggish
08:03:45 <Younder> rubbish
08:04:32 <JordiGH> Younder: I preferred "riggish". Anyways, point being, Haskell has a whitespace thing, and I've learned to be careful with that, let's move on.
08:05:06 <HayashiRazan> :t Younder
08:05:07 <lambdabot> Not in scope: data constructor `Younder'
08:05:07 <MyCatVerbs> JordiGH: Yes. So don't mix tabs and spaces, ever. If you come across someone else doing that, stab them. Problem solved. :)
08:05:12 <Younder> JordiGH, yes, and yes
08:05:19 <Baughn> And besides, haskell-indentation-mode wouldn't work with tabs
08:06:17 <Younder> Anyhow Ares launced without a hitch..
08:07:39 <Younder> Go NASA..
08:08:44 <Botje> stabbings up, compile errors down. yay!
08:09:45 <FunctorSalad> do you give a warning first?
08:09:58 <BONUS> lol
08:10:03 <BONUS> <Botje> stabbings up, compile errors down. yay!
08:10:07 <Younder> no, just a terminal error ;)
08:24:53 <stoop> http://uncyclopedia.wikia.com/wiki/Haskell
08:24:56 <JordiGH> lol
08:26:55 <Younder> rotfl
08:27:09 <FunctorSalad> the last lines are pretty harsh
08:27:13 <FunctorSalad> "The flagship Haskell application is Zetabot, a 200 line Zeta calculus interpreter that sits in #Haskell, much to the entertainment of several hundred dead-ended college stu* Exception: Stack Overflow "
08:28:04 <Botje> I LOL'ed at the main = putStrLn ... bit
08:28:27 <Younder> I am still laughing
08:28:38 <FunctorSalad> (now can a person be dead-end anyway?)
08:28:44 <JordiGH> I loled before the article was linked; I win.
08:29:08 <mreh> :t replicateM
08:29:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:32:01 <mreh> halp! http://haskell.pastebin.com/d643bc894
08:32:13 <FunctorSalad> "Lazy programming is used to avoid telling the computer what to do until the program is running, saving developers from needing to code things that won't be used. "
08:32:14 <mreh> i've looked over this ten minutes, I still can't work out what's wrong
08:33:08 <shepheb> maybe I'm just a video game nerd, but one of my favourite parts of the article was the Photoshopped Half-Life box.
08:33:28 <Younder> Bit, lazy myself, couldn't be bohered to look
08:34:54 <fasta> I wonder why the uncyclopedia Haskell logo is nicer than the official Haskell logo.
08:34:58 <sproingie> "In fact, all data items are treated as infinite lists of length 1. Other infinite lists may be longer."
08:35:23 <fasta> I wonder how many people know the official Haskell logo to begin with ;)
08:35:36 <ToRA> mreh: do you mean getGaussian not getUGaussian ?
08:35:58 <ToRA> mreh: if you mean getUGaussian, you don't need to pass mn
08:36:19 <sproingie> i like the new logo
08:36:37 <FunctorSalad> fasta: the one that (quote) looks like it rolled down a hill and collected some rubbish on the way?
08:36:39 <FunctorSalad> :D
08:36:46 <FunctorSalad> lol
08:37:07 <mreh> ToRA: I mean getGaussian, fail
08:38:16 <JordiGH> lol
08:38:26 <sproingie> > let in'let'in=let in let in" let" in let in let let'in let_ _in = let_>>_in in in'let'in++let in_let'in=let in " let in let" in let'in in_let'in in'let'in
08:38:27 <lambdabot>   " let let let let let let let let let let let let"
08:38:34 <JordiGH> it be?
08:38:47 <Younder> 42?
08:39:55 <mreh> that still didn't fix the problem ToRA, but thx
08:40:11 <shepheb> sproingie: I'm kind of shocked that compiles
08:40:18 <mreh> o no it did!
08:40:23 <mreh> ToRA, you did fix it
08:40:35 <ToRA> \o/
08:41:50 <sproingie> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
08:41:51 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:42:59 <alexsuraci`> hah, i was just on that page
08:43:20 <Beelsebob> sproingie: haha, win
08:43:21 <shepheb> I'm actually really impressed that they put in the effort on those.
08:44:08 <mreh> how could I make a generic euclidian distance function? what class I use for the points I'm comparing if they can have any number of dimensions?
08:44:43 <fasta> mreh: You can build that on top of Data.Vec.
08:44:56 <fasta> mreh: should be trivial.
08:44:56 <mreh> does anyone have the feeling tha haskell has ruined their professional programming career? I can't use any other language without comparing it to Haskell
08:45:14 <Berengal_> mreh, yes
08:45:21 <mreh> I hate my life
08:45:25 <fasta> mreh: I use Haskell professionally. Does that count?
08:45:30 <mreh> no
08:45:30 <Berengal_> Except it hasn't ruined my career
08:45:33 <FunctorSalad> if that's true for enough people there should be jobs soon enough no?
08:45:38 <FunctorSalad> haskell jobs that is
08:45:53 <fasta> Actually, I believe there are a few things holding back Haskell usage.
08:46:21 <sproingie> lack of a billion dollar marketing campaign
08:46:26 <FunctorSalad> the monomorphism restriction?
08:46:30 <fasta> sproingie: no, has nothing to do with it.
08:46:54 <mreh> well when I graduate i'm going to fish for a haskell job probably
08:46:56 <sproingie> no, but i bet a billion dollars could fund a lot of haskell training workshops
08:46:58 <fasta> What Haskell needs is everything implemented what they teach you on university is possible.
08:47:15 <FunctorSalad> ?
08:47:18 <mreh> fasta: pardon
08:47:20 <fasta> Haskell training workshops are useless too. People need to actively _want_ to learn it.
08:47:46 <mreh> with a gun in your face you can "want" almost anything
08:48:10 <Apocalisp> but not learn
08:48:34 <fasta> People disagree with me on this point, but imho, the bugs list for the major compiler of a language should be empty, or contain only debatable issues.
08:48:39 <sproingie> modularity in haskell is still not so hot
08:48:54 <sproingie> there's .hi files for separate compilation, but no versioning
08:49:13 <sproingie> interfaces changes, crashy crashy
08:49:24 <Berengal> sproingie, that's what cabal is for
08:49:27 <mreh> each language has it's niche though, C has systems programming, MATLAB does engineering, etc etc
08:49:48 <fasta> That's the first thing. Then you need to have something like scion actually working.
08:50:06 <sproingie> sure, it's definitely starting to erase.  perl XS binaries have the same problems too, and that doesn't hold it back
08:50:06 * benmachine is still looking at sproingie's let-thing and trying to work out how it parses
08:50:07 <Twey> … C++ and Java have buzzword compliance…
08:50:12 <fasta> And things like c2hs should not contain _any_ features to be desired.
08:50:21 <Jafet> Haskell's job is to sit around and invent silly ideas that other programmers will use, twenty years later
08:50:32 <FunctorSalad> where's the money for full-time development of the infrastructure going to come from....?
08:50:34 <Twey> Jafet: I thought that was Lisp's job.
08:50:47 <fasta> And of course Template Haskell needs to work in a saner way.
08:51:03 <Jafet> Lisp's job is to make sure we never have to endure expert systems ever again
08:51:06 <fasta> Oh, and the record syntax issue.
08:51:18 <sproingie> OOP is really easy to get and map to a mental model.  haskell requires a bit more rigorous thinking.
08:51:23 <fasta> I have about 6 of those issues, so that's not that much.
08:51:36 <FunctorSalad> "saner way"?
08:51:45 <sproingie> mind you i think better programs come out of rigorous thinking, but there's certainly a higher bar to entry
08:52:05 <benmachine> ohh, let blocks are allowed to be empty
08:52:10 <benmachine> > let in 4
08:52:11 <lambdabot>   4
08:52:14 <FunctorSalad> sproingie: sure that's not a matter of practice?
08:52:15 * benmachine didn't know that
08:52:15 <fasta> Oh, and there should also be a way to switch from functional data structures to single-threaded ones.
08:52:32 <FunctorSalad> fasta: what's the issue with TH?
08:52:35 <fasta> FunctorSalad: have you used Template Haskell?
08:52:40 <FunctorSalad> yes
08:52:43 * benmachine suspects case of 5 won't work so well
08:52:52 <fasta> FunctorSalad: and do you think it's trivial to do simple things?
08:53:28 <benmachine> haskell seems to me to do what OO wishes it could do in a safer and more sensible way
08:53:46 <FunctorSalad> fasta: it can be slightly awkward, but nothing some simple wrappers can't solve
08:53:53 <Twey> Pretty much, yes
08:54:03 <FunctorSalad> (like "make a constructor application pattern")
08:54:25 <kapil> i've been trying unsuccessfully to use happstack to setup a reverseproxy. anyone with some hints?
08:54:27 <sproingie> FunctorSalad: in some sense, it's all a matter of practice.  but i'm fairly sure the notion of state is a more immediately accessible abstraction given the way we describe real-world objects
08:54:42 <FunctorSalad> fasta: for the really trivial things I use CPP hehe
08:54:53 <sproingie> not that haskell lacks state, it just doesn't let you slap it on anywhere you like
08:55:19 <PeakerWork> sproingie: I agree that Haskell has a bigger learning curve for imperative programmers.  I don't know if that's true for non-programmers. I'd venture mathematicians have it easier with Haskell, for example
08:55:28 <FunctorSalad> sproingie: I find it much harder to think about stateful programs
08:55:39 <PeakerWork> sproingie: I just haven't tried to teach a non-programmer Haskell yet
08:55:52 <FunctorSalad> just because the real world has state doesn't mean it has to be *implicit*
08:57:02 <EddyDean> I don't really agree that there is a large learning curve
08:57:02 <fasta> FunctorSalad: yes, I use lots of CPP too. I think when I actually begin to actively use TH, there wouldn't be an original Haskell keyword left.
08:57:25 <sproingie> sure, i agree.  functional thinking just works differently, and i think we're still finding new ways to model state with it, e.g. FRP
08:57:31 <fasta> For example for data declarations, I don't like that I cannot give sub-terms a name. So, I would probably implement something for that.
08:57:32 <Berengal> Haskell is a really simple language when you boil it down. There's no distinction between reference variables and value variables, because there's no references (or rather, references are values, not variables). Everything is just a name...
08:57:42 <EddyDean> I'm coming from java, but the only problem I've had with learning Haskell is the very strict type system
08:57:44 <FunctorSalad> fasta: OTOH there's a simple way to do trivial stuff in TH, just print . runQ an example instance of what you want
08:57:53 <sproingie> i don't like that records can't have overlapping accessors
08:57:56 <PeakerWork> EddyDean: as an imperative programmer, I learned new imperative languages in days (not to expert-dom, of course, but productivity ensues in just a few days). With Haskell it took me more time
08:58:06 <FunctorSalad> , [| (\x y -> compare x y == EQ) |]
08:58:08 <sproingie> i don't like the hackish way records are done in general
08:58:08 <lunabot>  LamE [VarP x_0,VarP y_1] (InfixE (Just (AppE (AppE (VarE compare) (VarE x...
08:58:34 <PeakerWork> sproingie: If records were namespaces it would have been even worse, I think
08:58:38 <Berengal> PeakerWork, ditto on that sentiment. Imperative languages are almost all equal, except for syntax, sugar and gotchas
08:58:39 <Vanadium> Coming from C++, the biggest problem I have had was approaching every problem as "okay i will make a class that" and then my brain kind of shuts down
08:58:45 <PeakerWork> sproingie: (You don't want to specify the explicit type of the record in every access)
08:59:07 <EddyDean> It does take longer to learn Haskell, but not a lot
08:59:08 <Younder> Fuctonal programming takes some time to learn
08:59:10 <conal> if one has an imperative programming background, then there can be more of an unlearning curve than a learning curve.
08:59:13 <PeakerWork> EddyDean: that's the "large learning curve"
08:59:20 <PeakerWork> conal: yeah, indeed :-)
08:59:22 <benmachine> I think that haskell has a strangely-shaped learning curve
08:59:29 <stoop> "Learning a language" is more than knowing the syntax.
08:59:32 <mlesniak> I remember (maybe falsely) that a paper about Xmonads design was published. Any ideas where to find it? all I have found was a one page abstract and some presentations
08:59:33 <Berengal> benmachine, lambda shaped :P
08:59:38 <benmachine> I get the feeling that becoming competent at python was easier than becoming competent at haskell
08:59:40 <mreh> i find having done mathematics helps you a great deal
08:59:42 <stoop> PeakerWork, I'm not sure if you care, but I found http://en.wikipedia.org/wiki/X86_instruction_listings#Added_in_specific_processors
08:59:47 <PeakerWork> conal: I wanted to ask you about the conflicting monad instances -- don't you think newtypes around (:.) for the conflicting instances would be a good idea?
08:59:47 <stoop> PeakerWork, useful.
08:59:51 <Younder> benmachine, it is
08:59:56 <benmachine> but becoming really good at haskell seems a lot more plausible than becoming so with python
09:00:05 <stoop> benmachine, why?
09:00:09 <sproingie> haskell has a sine shaped learning curve.  starts out steep, levels out, then you unlearn the things you thought you knew, and start over :)
09:00:20 <Twey> mlesniak: http://www.cse.unsw.edu.au/~dons/papers/SJ07.html perhaps?
09:00:25 <Younder> haskell is math
09:00:27 <mreh> spronigie, but that never ends
09:00:31 <conal> PeakerWork: my gut feeling is no.  but you could try and see.
09:00:34 <benmachine> stoop: because it forces me to think in the right ways and stick with good practices
09:00:37 <Younder> as sch it is a powerful as math
09:00:42 <sproingie> mreh: isn't it fun that way?
09:00:42 <Younder> such
09:00:50 <EddyDean> Haskell reminds me of set theory
09:00:55 <benmachine> maths is more powerful than haskell
09:01:09 <mreh> sproingie, on the way up
09:01:15 <fasta> FunctorSalad: what do you mean by print . runQ an example instance of what you want? runQ needs a Q something value.
09:01:17 <benmachine> this is largely because ∀x. maths is at least as powerful as x
09:01:24 <Younder> Wnna proove something about the program0 You areWAY better off with haskel!
09:01:24 <FunctorSalad> EddyDean: actually aren't the set theorists and the type theorists archenemies?;)))
09:01:28 <mlesniak> Twey, yes, but its only one page long :-/
09:01:33 <Twey> Vanadium: Try replacing ‘class’ with ‘module’.
09:01:45 <EddyDean> FunctorSalad: I'm not a set theorist, just a CS student ;)
09:01:47 <FunctorSalad> fasta: I meant put the example in quotation brackets
09:01:48 <Vanadium> But so far all my programs have been in the Main module :<
09:02:06 <Younder> I really should look at what I type..
09:02:09 <stoop> benmachine, Haskell is a math.
09:02:15 <Berengal> Haskell has some really great plug-n-play libraries.
09:02:20 <FunctorSalad> EddyDean: not entirely serious but at least roconnor doesn't like set theory much I think, but I think he was kidding too
09:02:31 <stoop> benmachine, formal semantics make it so, I think (ignoring influences from category theory, lambda calculus, etc...).
09:02:56 <Twey> Haskell is not mathematics.  It may be related to mathematics, in largely the same way physics is, but it is not mathematics in itself — it is a separate discipline in which mathematics happens to be useful sometimes.
09:03:00 <fasta> FunctorSalad: if I paste  [| (\x y -> compare x y == EQ) |] in ghci, <interactive>:1:1: parse error on input `|
09:03:04 <JordiGH> How is haskell for numerics? Could I rewrite my PDE solver in Haskell?
09:03:12 <Twey> (and generally only very specific branches of mathematics for very specific tasks, at that)
09:03:14 <stoop> Twey, I did not say it is mathematics, mathematics is massive.
09:03:25 <FunctorSalad> fasta: :set -XTemplateHaskell
09:03:27 <Twey> No — Younder did.
09:03:31 <fasta> JordiGH: yes, you can. It will also be between 2 and 100 times slower.
09:03:44 <stoop> Interesting.
09:03:52 <stoop> Is that a unicode character you're using Twey?
09:03:54 <JordiGH> fasta: It's in C++ right now, and the more C++ I write, the more I hate it.
09:03:58 <stoop> No - Younder did.
09:04:00 <FunctorSalad> Twey: I disagree Haskell:math is like physics:math
09:04:05 <benmachine> –
09:04:06 <fasta> FunctorSalad: I already did so by using a LANGUAGE pragma.
09:04:12 <mreh> it has the same consistancy throughout, like mathematics
09:04:13 <FunctorSalad> haskell is just a mental thing too, like math
09:04:13 <stoop> Tremulous hackers.
09:04:16 <Younder> stoop, did what?
09:04:19 <conal> PeakerWork: did you see my earlier reply (maybe 12 hours ago) about (:.) Monad?
09:04:21 <Twey> I use lots of Unicode characters.  I like being able to use my native language.
09:04:35 <FunctorSalad> fasta: you said 'in ghci'
09:04:40 * stoop has no use for his native language on IRC
09:04:42 <Twey> FunctorSalad: But it's something with its roots in the real world, like physics
09:04:44 <fasta> FunctorSalad: yes, loaded from Haskell mode.
09:04:53 <benmachine> Twey: and maths, sort of :P
09:04:55 <fasta> FunctorSalad: so, I load the module, and then paste the expression and press enter.
09:04:55 <Twey> There's more than just mathematics to it: the end goal is to produce something that works.
09:05:05 <benmachine> ...like maths, sort of
09:05:12 <benmachine> maths works
09:05:20 <JordiGH> sort of
09:05:22 <stoop> Constructive mathematics.
09:05:22 <benmachine> the real world, not nearly so much :P
09:05:27 <Jafet> Come, let us slaughter these sacrificial chickens and drip their blood over our navels while kneeling and preaching our seemingly deep, subtly praiseful mock-insights about a strange whitespace-sensitive case-sensitive type-sensitive doctorate mill!
09:05:28 <Twey> No, mathematics is a mind game that occasionally happens to produce results applicable to our world
09:05:33 <FunctorSalad> fasta: it works on my ghci
09:05:37 <Younder> I said Haskell is math. And in fact is passes the test. It is a math language.
09:06:03 <benmachine> haskell ⊂ maths?
09:06:05 <Twey> Physics and programming are *about* producing results applicable to the world, and sometimes they utilise bits and pieces of mathematics for this goal.
09:06:09 <JordiGH> What is mathematics? Courant and Robbins wrote 300+ pages about it and never answered the question.
09:06:14 <stoop> Twey, the goal is not necessarily something that "works", but simply the construction within itself being realizable (where realization is not something necessarily working).
09:06:23 <stoop> benmachine, yes, I would say.
09:06:28 <fasta> FunctorSalad: odd. Ok, it works here now, but I get a missing instance for (Show Language.Haskell.TH.Lib.ExpQ)
09:06:36 <stoop> Younder, "a math".
09:06:45 <stoop> Younder, a lot of mathematics is non-constructive.
09:06:55 <Twey> stoop: If you produce a wonderfully elaborate and elegant program that runs in infinite time in Haskell, we generally consider it a failure.  :þ
09:07:06 <stoop> Twey, not really the case.
09:07:09 <benmachine> nah
09:07:15 <stoop> Twey, this could be useful in proofs, etc...
09:07:16 <FunctorSalad> fasta: that's because it is in the Q monad
09:07:17 <benmachine> my IRC bot runs in infinite time :P
09:07:20 <FunctorSalad> ExpQ = Q Exp
09:07:22 <stoop> That too :-P
09:07:35 * Twey dies
09:07:35 <fasta> FunctorSalad: ok, if I leave off the print, it works.
09:07:43 <FunctorSalad> (try "runQ"... as long as you're not using reify)
09:08:50 <fasta> {-# LANGUAGE TemplateHaskell #-}
09:08:50 <fasta> import Language.Haskell.TH.Syntax
09:09:14 <stoop> One day I should finish my PL/FoL library.
09:09:15 <fasta> FunctorSalad: shouldn't that and then runQ  [| (\x y -> compare x y == EQ) |]also work?
09:09:36 <FunctorSalad> fasta: that gives you an (IO Exp)
09:09:40 <Younder> ugh
09:09:46 <FunctorSalad> which you can print as usual
09:09:52 <fasta> FunctorSalad: yes, and then that gets printed by ghci automatically.
09:09:55 <stoop> Only thing I've been using Haskell for lately (other than an elaborate calculator) is biology homework.
09:10:04 <FunctorSalad> if you use reify runQ doesn't work though and you need to resort to weird tricks
09:10:07 <fasta> FunctorSalad: but the problem is that template haskell is not being recognized.
09:10:22 <fasta> FunctorSalad: it seems to ignore the LANGUAGE pragma.
09:10:31 <FunctorSalad> fasta: did you try the :set in ghci? ;)
09:10:36 <Younder> Well I am using it for Formula
09:10:44 <fasta> FunctorSalad: yes, that did work.
09:10:59 <fasta> FunctorSalad: I just think it should also work using the specification in the file.
09:11:20 <Younder> A language I a working on
09:11:32 <Younder> am
09:12:33 <hackagebot> minesweeper 0.8.8 - Minesweeper game which is always solvable without guessing (PeterDivianszky)
09:12:46 <Younder> Point is I want the core mathematically verified, hence haskabelle and Isabelle
09:14:29 <sm> yay, more games
09:14:47 <Younder> Formula is yet another programming language
09:15:02 <cgizmo> hi everyone
09:15:02 <lambdabot> cgizmo: You have 1 new message. '/msg lambdabot @messages' to read it.
09:15:09 <Younder> My 5'th attempt
09:15:43 <cgizmo> i'm having a problem with a function, maybe you can help me out
09:16:24 <cgizmo> the function (right here : http://paste.pocoo.org/show/147693/ ) stops with a "resource exhausted (Too many open files) " error
09:17:17 <cgizmo> do you know where it might be coming from ?
09:17:45 <Botje> looks like haskell keeps the directory entries open for too long.
09:18:16 <quicksilver> which seems surprising to me
09:18:24 <cgizmo> Botje: is there any way to force the files to close faster?
09:18:29 <quicksilver> is getDirectoryContents infected with the evil of interleaved IO?
09:18:33 <quicksilver> I didn't think it was.
09:19:28 <quicksilver> the unix source, at least, doesn't seem to interleave the IO
09:19:33 <quicksilver> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/directory/src/System-Directory.html#getDirectoryContents
09:20:22 <quicksilver> cgizmo: are you sure you don't do something else you aren't showing us?
09:20:30 <quicksilver> like call the evil readFile or one of its friends?
09:20:43 <cgizmo> i am, but i've narrowed down the problem to this function only
09:20:47 <m0nkfish> how can i calculate the nth row of pascals triangle
09:20:54 <cgizmo> but if you want, I can gve you the full code
09:21:01 <cgizmo> it's quite ugly, though
09:21:22 <quicksilver> well, do you call readFile on the files returned from this function?
09:21:35 <cgizmo> no, I read ID3 tags from theme
09:21:44 <quicksilver> then I'm a bit baffled.
09:21:46 <cgizmo> but the problem seems to come from this function only
09:21:57 <cgizmo> Prelude SortMusic> getRecursiveMusics "~/tmp/Library"
09:22:01 <cgizmo> returns the error :
09:22:18 <cgizmo> [long list of files]  Exception: <stdout>: hPutChar: resource exhausted (Too many open files)
09:26:19 <quicksilver> cgizmo: does the error go away if you run it on a smaller library?
09:26:28 <quicksilver> (but I really don't understand why this is happening)
09:26:51 <cgizmo> quicksilver: let me try, just a second
09:27:54 <cgizmo> quicksilver: yes, it does
09:28:29 <cgizmo> on a 12 element library, with music in 3 different subdirectories, the error goes away
09:29:12 <quicksilver> but still, I don't see how getDirectoryContents can leak FDs
09:29:17 <quicksilver> it is bracketed with closedir
09:29:59 <thorkilnaur_> cgizmo, On what sort of machine are you running this on? I seem to recall having seen such problems on Mac OS X
09:30:11 <cgizmo> i'm running on GNU/Linux
09:30:44 <cgizmo> 64 bit Gentoo with GHC version 6.10.4
09:31:28 <thorkilnaur_> cgizmo, Just a shot in the dark: Does "ulimit -a" say anything about a limit on the number of open files?
09:32:40 <cgizmo> here is the output
09:32:40 <cgizmo> -f: file size (blocks)         unlimited
09:32:40 <cgizmo> -d: data seg size (kbytes)     unlimited
09:32:40 <cgizmo> -s: stack size (kbytes)        8192
09:32:40 <cgizmo> -c: core file size (blocks)    0
09:32:40 <cgizmo> -m: resident set size (kbytes) unlimited
09:32:42 <cgizmo> -n: file descriptors           1024
09:32:44 <cgizmo> -l: locked-in-memory size (kb) 64
09:32:46 <cgizmo> -v: address space (kb)         unlimited
09:32:48 <cgizmo> -x: file locks                 unlimited
09:32:55 <Botje> you could increase the file descriptor limit a bit.
09:33:12 <cgizmo> what command should I use to do this ?
09:33:16 <cgizmo> the ulimit one ?
09:33:23 <Botje> ulimit -n 16384
09:33:29 <Botje> but that's not really a solution, imo :)
09:34:18 <cgizmo> hum, it does work now
09:34:29 <cgizmo> i get the full 2500 element list
09:34:34 <cgizmo> thanks :)
09:34:41 <cgizmo> but still, this problem is odd :/
09:34:42 <Botje> "mapM_ (flip seq (return ()))" in the right place should do the trick.
09:34:56 <Botje> (with an extra argument, probably)
09:35:27 <cgizmo> Botje: what would that code do ?
09:35:34 <Jafet> Fork a process for each directory
09:35:39 <ezyang> Hello all
09:36:26 <Botje> cgizmo: force haskell to evaluate the list, thus allowing the directories to be closed
09:36:44 <cgizmo> all right, i'll try this
09:38:06 <cgizmo> Botje: it works !
09:38:13 <Botje> yay :)
09:38:13 <cgizmo> thanks a lot :)
09:38:54 <quicksilver> Botje: what do we conclude? getDirectoryContents returns results with interleaved IO?
09:39:02 <quicksilver> it sure doesn't *look* like that in the source I was looking at.
09:39:10 <quicksilver> cgizmo: which GHC version?
09:39:35 <jystic> is there a way to use scientific notation for integers?
09:40:15 <cgizmo> quicksilver: 6.10.4
09:40:26 <quicksilver> jystic: well, you can use scientific notation for Rational, which is at least precise
09:40:32 <quicksilver> jystic: (and then convert to integer)
09:40:36 <quicksilver> jystic: bit clumsy I admit!
09:40:48 <quicksilver> > 1e26 :: Rational
09:40:48 <ezyang> "Define e as an infix operator ;-)"
09:40:49 <lambdabot>   100000000000000000000000000 % 1
09:40:50 <Botje> quicksilver: i'd say that loop function in getDirContents is simply evaluated to WHNF
09:41:02 <Botje> instead of (i think?) RNF
09:41:09 <Botje> bleh. is there an overview of all those *NFs ?
09:41:09 <quicksilver> but it's an IO action
09:41:20 <quicksilver> it isn't just evaluated it's executed
09:41:25 <quicksilver> and when executed it returns the entire list
09:41:34 <quicksilver> unless...
09:41:51 <jystic> quicksilver: thanks, i'm actually working with rationals anyway
09:42:05 <quicksilver> no, "peek" can't be interleaved IO that would be insane.
09:42:25 <fasta> quicksilver: Why not?
09:42:39 <quicksilver> because it would be insane
09:42:45 <fasta> quicksilver: it would be possible, though.
09:42:50 <quicksilver> of coutse
09:42:55 <quicksilver> all kinds of insanity is possible.
09:43:01 <fasta> quicksilver: 'can't'
09:43:18 <quicksilver> well, I qualified it by "[because] that would be insane"
09:44:09 <fasta> What's different about it when compared to using unsafeInterleaveST when traversing a mutable list?
09:44:27 <fasta> Both are dangerous when not used correctly, both could be useful.
09:45:40 <quicksilver> peek is a standard library function
09:45:46 <quicksilver> it would be insane for it to be interleaved IO.
09:45:53 <quicksilver> that is my contention, and I stand by it.
09:46:17 <quicksilver> I also think that readFile and hGetContents are insane, and should be filed as bugs against the haskell 98 spec, so I wear my bias on my sleeve.
09:48:00 <fasta> I don't care how they are implemented, if it is guaranteed that they always work :) That's however a big if.
09:48:43 <quicksilver> I don't care if they work, or even if they *can* be implemented, as long as they present a tractible semantics ;)
09:55:01 <m0nkfish> whats integer divide
09:55:20 <m0nkfish> by this i mean what is the haskell function :)
09:55:25 <arsenm> m0nkfish: div
09:55:26 <EddyDean> `div`
09:55:53 <quicksilver> cgizmo: if you have the energy, you should file a bug for that on the GHC trac
09:55:57 <quicksilver> cgizmo: IMO your code should work.
09:56:18 <cgizmo> quicksilver: the part I posted does work
09:56:30 <cgizmo> but i'm having the same problem, with another function
09:56:40 <cgizmo> later in the code :D
09:56:53 <cgizmo> i'm trying to fix it using seq
09:57:06 <cgizmo> but urm... i haven't managed to yet :/
09:57:09 <quicksilver> cgizmo: but it only works with Botje's addition of seq, right?
09:57:22 <quicksilver> cgizmo: that's a bug, you shouldn't have to use seq to make getDirectoryContents do what you want it to.
09:57:46 <cgizmo> quicksilver: yes, the part I posted earlier only works with Botje'a addition
09:58:11 <cgizmo> but  have the same problem later in the code, with the function "copyFile"
09:58:24 <m0nkfish> thanks
09:58:30 <m0nkfish> also whats the notationcalled where you use |
09:58:36 <m0nkfish> i want to read on it
09:58:40 <cgizmo> it looks like multiple instances of the function are launched in parallel
09:58:51 <quicksilver> m0nkfish: guards
09:59:28 <cgizmo> and this code : " seq (copyFile path (completeDirPath </> fileName)) (return ()) " that should force the evaluation of copyFile (right?)
09:59:30 * shapr yodels
09:59:40 <cgizmo> just stops the function from launching
09:59:59 <benmachine> list comprehensions also use |
10:00:06 <benmachine> but guards is probably right
10:00:35 <quicksilver> cgizmo: well it forces the *evaluation* which is not the same as the *execution*
10:01:00 <cgizmo> quicksilver: ah
10:01:09 <cgizmo> what function would force the execution, then ?
10:01:47 <benmachine> maybe something like let a = copyFile path (completeDirPath </> fileName) in a `seq` a
10:02:01 <copumpkin> a `seq` a doesn't do anything
10:02:01 <themroc--> hmm i have a weird timestamp: eg. 1472.09
10:02:04 <copumpkin> (Ever)
10:02:08 <benmachine> copumpkin: hm.
10:02:09 <themroc--> i assume the first 4 are the seconds
10:02:11 <benmachine> k
10:02:18 <themroc--> but the number after the dot go max to 15
10:02:27 <themroc--> 00-15
10:02:34 <themroc--> anyone ever seen something like this?
10:02:53 <copumpkin> themroc--: who's producing it?
10:03:06 <themroc--> its a timestamp for subtitles of a film reel
10:03:16 <themroc--> i thought the last was a frame
10:03:22 <themroc--> but then it would reach 24
10:03:24 <themroc--> or 23
10:03:27 <copumpkin> themroc--: not a clue
10:03:53 <osfameron> what's the efficient way of writing: let ht xs = ( map head xs, map tail xs )  ?
10:04:01 <osfameron> i.e. without having to iterate the list twice ?
10:05:01 <copumpkin> unzip . map uncons ?
10:05:07 <aavogt> @type map (splitAt 1)
10:05:08 <lambdabot> forall a. [[a]] -> [([a], [a])]
10:05:11 <ToRA> @type unzip . map (head &&& tail)
10:05:12 <lambdabot> forall a. [[a]] -> ([a], [[a]])
10:05:25 <benmachine> people like unzip
10:05:29 <aavogt> but you could manually fuse the unzip
10:05:29 <quicksilver> cgizmo: it must be executed, there's nothing else for it to be
10:05:45 <osfameron> ah thanks
10:06:03 <aavogt> unless the compiler manages to do that, you can write it as a single fold, I think
10:06:06 <cgizmo> quicksilver: but putting the seq around it just cancels the execution of the function
10:06:18 <EnglishGent> @hoogle (a -> IO b) -> IO a -> IO b
10:06:18 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:06:18 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:06:18 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:06:22 <quicksilver> cgizmo: that's also true, yes.
10:06:30 <benmachine> EnglishGent: =<<?
10:06:31 <osfameron> @index uncons
10:06:31 <lambdabot> bzzt
10:06:31 <m0nkfish> why does my pascals triangle only work for even numbers :(
10:06:32 <quicksilver> cgizmo: I don't have time to explain seq to you right now, I have real work to do :)
10:06:45 <osfameron> @src unzip
10:06:45 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
10:06:45 <cgizmo> quicksilver: all right, i'll figure it out on my own
10:06:48 <cgizmo> thanks for the help, quicksilver
10:06:50 <quicksilver> cgizmo: talk copumpkin into it if you want the details ;)
10:06:54 <Saizan> cgizmo: if you've "main = seq foo bar" foo is never executed but bar is
10:06:57 <copumpkin> ?
10:07:09 <m0nkfish> check this line : pascal n = (pascal (n-1)) ++ [(pascaux n 0)]
10:07:10 <EnglishGent> benmachine - wouldnt that return IO IO b ? (not sure)
10:07:12 <copumpkin> yeah,
10:07:13 <m0nkfish> now this one : pascal n = (pascal (n-2)) ++ [(pascaux (n-1) 0)]
10:07:14 * copumpkin is the expert!!!!
10:07:15 <Saizan> cgizmo: that's because seq a b is the same as b, but with a data dependency on a
10:07:25 <benmachine> :t (=<<)
10:07:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:07:29 <m0nkfish> all i wanted to do was change the number bit its broken everything :(
10:07:40 <cgizmo> Saizan: ah, so the order in which I put my arguments is just wrong
10:07:45 <benmachine> EnglishGent: no, but even if it did you could use join
10:07:47 <benmachine> :t join
10:07:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:08:03 <EnglishGent> ty :)
10:08:18 <Saizan> cgizmo: and seq is not used to sequence execution of monadic actions, it's only used to sequence evaluation to some extent
10:08:47 <cgizmo> Saizan: what function would force execution of monadic actions, then ?
10:08:51 <Saizan> cgizmo: sequencing of the execution monadic action is simply obtained with >> or equivalently with do-notation
10:08:58 <m0nkfish> ok now i feel silly hehe
10:09:32 <cgizmo> Saizan: so their is no way to actually force an action to be executed, then wait for it to finish before moving on ?
10:09:39 <Saizan> cgizmo: the only exception is if the action is using unsafeInterleaveIO somewhere, which you can think as some weird sort of concurrency
10:10:05 <Saizan> cgizmo: in that case the execution might be influenced by the evaluation of the _result_ of the monadic action
10:10:45 <Saizan> cgizmo: for example readFile does this, so to force the file to be completely read you've to force the String it returns
10:11:12 <cgizmo> but the function copyFile return an "IO ()"
10:11:23 <cgizmo> can I force the exectution of this ?
10:11:25 <Saizan> cgizmo: for example like this do str <- readFile "foo"; length str `seq' return (); ...
10:11:34 <benmachine> cgizmo: maybe it's not the same problem?
10:11:45 <Saizan> cgizmo: i don't think copyFile uses unsafeInterleaveIO
10:11:53 <cgizmo> benmachine: what do you mean ?
10:12:06 <cgizmo> Saizan: I can't see it anywhere in the source of copyFile
10:12:08 <Saizan> cgizmo: i didn't follow the full discussion, have you pasted the code somewhere?
10:12:17 <cgizmo> not the very last one
10:12:27 <cgizmo> do you wan't the full code, or just the relevant part ?
10:12:47 <benmachine> full code is almost always more useful
10:13:00 <benmachine> and what error messages
10:13:05 <Saizan> if it isn't too long :)
10:13:05 <cgizmo> the full code is right here :
10:13:08 <cgizmo> http://paste.pocoo.org/show/147713/
10:13:23 <cgizmo> the relevant function is handleFiles
10:13:31 <cgizmo> that's where the copyFile function is located
10:13:37 <cgizmo> and the error I get is :
10:14:03 <quicksilver> Saizan: the odd thing is that he also had a problem with getDirectoryContents and yet, as far as I can see, that's not interleaved either.
10:14:07 <cgizmo> launchSort "/home/charlie/tmp/Library/" "/home/charlie/tmp/Out/" "ARTIST/ALBUM/TITLE"
10:14:07 <cgizmo> *** Exception: /home/charlie/tmp/Library/song.mp3: copyFile: resource exhausted (Too many open files)
10:14:35 <cgizmo> I get this error almost instantly
10:16:06 <benmachine> cgizmo: do you know if it fails on the first copyFile?
10:16:14 <benmachine> or does it successfully copy some and then die?
10:16:36 <benmachine> might be worth, say, adding putStrLn "about to copy!" >> copyFile [...]
10:17:22 <cgizmo> launchSort "/home/charlie/tmp/Library/" "/home/charlie/tmp/Out/" "ARTIST/ALBUM/TITLE"
10:17:22 <cgizmo> about to copy!
10:17:22 <cgizmo> *** Exception: /home/charlie/tmp/Library/Louis Armstrong/Louis Armstrong's All Time Greatest Hits/01 What A Wonderful World.mp3: copyFile: resource exhausted (Too many open files
10:17:31 <cgizmo> it looks like it fails on the first file :/
10:17:48 <benmachine> that suggests to me that copyFile is not the problem
10:17:58 <benmachine> but instead, some other filesystem call is using up all your file handles
10:18:08 <benmachine> and then copyFile is finding none left
10:18:29 <Saizan> cgizmo: is TL.open likely to open a file?
10:18:45 <Saizan> cgizmo: maybe you have to call a TL.close?
10:18:48 <cgizmo> Saizan: it is, but it's not the problem
10:18:56 <cgizmo> and it automatically closes the file
10:18:59 <cgizmo> a call of only :
10:19:08 <cgizmo> getRecursiveMusics "dir" >>= tag
10:19:12 <cgizmo> works
10:19:30 <cgizmo> adding the handleFiles causes the problem
10:19:47 <Saizan> which package is Sound.TagLib from?
10:19:55 <benmachine> adding the handleFiles causes a crash, that doesn't mean it causes the problem :)
10:20:02 <benmachine> it might just expose something that was already incorrect
10:20:11 <cgizmo> it's an external packages called taglib, available in hackage
10:20:16 <benmachine> there are utilities to find out what files a process is opening, aren't there?
10:20:22 <benmachine> like strace maybe?
10:20:54 <cgizmo> benmachine: would that be a Haskell function or a Unix program ?
10:21:01 <benmachine> strace is a unix program
10:21:06 <benmachine> I don't have much experience with using it though
10:21:11 <cgizmo> ok, let me install it
10:21:38 <benmachine> maybe something like strace -e trace=open command
10:21:49 <cgizmo> ok, thanks
10:22:06 <sproingie> truss on solaris
10:22:08 <benmachine> it will tell you a lot of stuff you don't care about
10:22:14 <benmachine> but maybe some things you do
10:22:28 <sproingie> also lsof on various unixen will tell you what a process currently has open
10:22:37 <benmachine> lsof and fuser
10:22:47 <benmachine> wait no fuser is something else
10:22:50 <benmachine> lsof is handy though
10:23:11 <sproingie> fuser is sort of the reverse of lsof
10:24:12 <Saizan> cgizmo: maybe the files from TagLib only get closed only when the finalizer runs, and that might not happen at all
10:24:51 <Saizan> cgizmo: and adding copyFile is just triggering the limit
10:25:35 <cgizmo> benmachine: your strace command options don't work, i'm trying to maodify them a bit
10:26:28 <cgizmo> Saizan: but the problem I had with "tag" was fixed earlier
10:27:24 <cgizmo> and the "tag" function does not reach the file limit like it should if there was a problem
10:28:22 <lysgaard> How would i easiest sort a list of tuples [(a,b,c)] after c?
10:28:45 <cgizmo> benmachine: I can't get your command to work :/
10:28:57 <lysgaard> Is it possible to define the ord instance for just that list?
10:29:00 <cgizmo> it just returns "zsh: unknown user"
10:29:11 <benmachine> cgizmo: weird
10:29:11 <ezyang> lysgaard: Probably sortBy
10:29:22 <cgizmo> benmachine: i'll try it out in bash, see what happens
10:29:31 <ezyang> Defining an ord instance for just that list won't work if a, b and c have Ord defined; you'll have to newtype the tuple
10:29:59 <ezyang> (you'll get an overlapping instances error)
10:30:05 <lysgaard> ezyang: Yeah, but the sortby sounds smart, takes a predicate i guess?
10:30:41 <cgizmo> benmachine: it's working now, do you want the output ?
10:30:42 <ezyang> take an a -> a -> Ordering
10:30:45 <benmachine> lysgaard: also see Data.Ord.comparing
10:31:21 <cgizmo> benmachine: http://paste.pocoo.org/show/147718/
10:31:44 * benmachine is confused
10:32:12 <benmachine> try removing -e trace=open
10:32:55 <benmachine> but that is not necessarily the right thing to do I don't know
10:34:17 <cgizmo> benmachine: the output with the trace option is right here : http://pastebin.com/m2beaecba
10:34:24 <lysgaard> ezyang: Hm.. but haw do i do this ordering stuff
10:35:29 <ezyang> comparing is something useful
10:35:37 <ezyang> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html#v:comparing
10:36:09 <lysgaard> ezyang: I got it working, just me being dumb :P
10:36:16 <Twey> lysgaard: sortBy (comparing $ \(_, _, x) -> x) list
10:37:51 <benmachine> cgizmo: maybe try strace -f?
10:38:30 <Twey> Interesting how the comma-syntax for type declarations doesn't get used much
10:38:39 <Twey> foo, bar :: SomeType
10:38:51 <PeakerWork> Twey: haddock for example cannot handle it very well iirc
10:38:54 <cgizmo> benmachine: the output is 30 000 lines long
10:38:58 <Twey> Ah
10:39:00 <benmachine> cgizmo: bah.
10:39:06 <cgizmo> :D
10:39:09 <benmachine> cgizmo: okay, try -f *and* -e trace=open
10:39:10 <PeakerWork> Lots of tools don't have full Haskell parsers, and that's quite annoying..
10:39:36 <benmachine> if that's still really long
10:39:40 <benmachine> but mostly calls to open()
10:39:44 <benmachine> maybe paste a few of the later ones
10:39:46 <Saizan> haddock uses ghc to parse, though
10:39:46 <cgizmo> benmachine: ah, this one is interesting
10:41:20 <cgizmo> benmachine: but it's still more than 3000 lines long
10:41:30 <cgizmo> it show mostly the files in my library
10:41:36 <benmachine> hmm
10:41:40 <cgizmo> i'll post it, it seems interesting
10:42:00 <benmachine> I'm not entirely sure how it helps
10:42:15 <benmachine> because we kind of already knew a lot fo stuff was being opened :P
10:42:38 <cgizmo> the end looks helpful though
10:42:55 <benmachine> if you do something like ulimit -Sn 10
10:43:03 <Saizan> (i'd try explicitly calling the finalizer of those TagFile, btw)
10:43:05 <benmachine> then it should crash much sooner and hopefully that will mean less spam
10:43:14 <benmachine> yeah I'd do what Saizan says
10:43:23 <benmachine> strace is a very blunt-instrument approach
10:43:26 <benmachine> useful to know about, though
10:43:38 <Saizan> well, seeing the trace can't hurt :)
10:43:51 <Saizan> otherwise it's mostly shooting in the dark
10:43:58 <cgizmo> it's really odd, actually
10:44:11 <cgizmo> the output of strace doesn't correspond to the one of the program
10:44:26 <cgizmo> strace shows a bug at about 1541 files open
10:44:36 <cgizmo> while the program itself hangs on the first file
10:44:39 <cgizmo> http://pastebin.com/m3a193c67
10:44:59 <benmachine> well this is suggesting that your program is opening files you don't know about
10:45:59 <benmachine> however
10:46:11 <benmachine> notice that every open() in the directory crawl returns fd 8
10:46:26 <benmachine> presumably that means that they're being closed before the next open
10:46:43 <benmachine> as soon as something starts opening mp3s, the descriptors start going up
10:46:54 <benmachine> so whatever is opening mp3s is not closing them
10:47:10 <benmachine> so, explicitly call the finaliser :P
10:47:13 <benmachine> or whatever
10:47:18 <benmachine> but blame your library, is my guess
10:47:36 <cgizmo> how do I call the finalizer :d ?
10:47:44 <benmachine> notice *also* that you start getting too many open files way before copyfile
10:48:21 <benmachine> but the error is presumably caught by the whatever
10:48:26 <benmachine> as for calling finalisers, no idea
10:48:31 <benmachine> refer to your library documentation
10:48:35 <Saizan> it also reaches (Too many open files) at line 1542 but it goes on, it seems taglib is ignoring the error
10:48:41 <benmachine> yeah
10:48:49 <cgizmo> this is really odd :/
10:48:55 <cgizmo> talk about unexpected behavior
10:49:00 <benmachine> so as we thought, it's not that copyFile is opening lots of files
10:49:09 <benmachine> it's just that it thinks this is a problem, whereas taglib doesn't
10:49:22 <Saizan> cgizmo: http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html#v%3AfinalizeForeignPtr <- to run the finalizer
10:49:41 <hackagebot> minesweeper 0.8.8.1 - Minesweeper game which is always solvable without guessing (PeterDivianszky)
10:49:56 <cgizmo> Saizan: thanks, i'll check this out
10:50:02 <Saizan> though i'm not sure when it's safe to do so, since Tag has the TagFile pointer in it
10:50:52 <Baughn> ..I've got fifty lines of imports. I'm scared to begin narrowing this down. :/
10:51:15 <cgizmo> i'll try adding it to more or less random places in my code, and see whan happens
10:51:29 <Saizan> cgizmo: heh
10:51:53 <benmachine> cgizmo: maybe you just need to
10:51:59 <benmachine>   tags <- generic TL.tag tagFiles []
10:52:01 <benmachine> not do that
10:52:19 <benmachine> but get say ten tags, process them, save them, get another ten
10:52:20 <benmachine> etc.
10:52:29 <Saizan> cgizmo: maybe instead of opening all the files at once you should finish processing one before opening the other
10:52:33 <benmachine> yeah
10:52:42 <cgizmo> hum, that's a good idea :d
10:52:45 <Saizan> or in chunks yeah
10:52:51 <benmachine> in fact, look at your generic function
10:52:58 <Saizan> benmachine: i keep saying what you've just said :)
10:53:11 <benmachine> it tells you whether the tag open failed with Nothing but you just go ahead and ignore it
10:53:19 <benmachine> Saizan: we make a good team?
10:54:05 <Saizan> Nothing is not very informative though
10:54:33 <cgizmo> benmachine: noting could mean the file is not a MP3 file
10:54:39 <cgizmo> Nothing*
10:54:47 <dancor> is foldl the best way to do \\ -> \ unescaping on a ByteString
10:54:58 <benmachine> cgizmo: well, okay, but it could also mean you've run out of file handles
10:55:56 <cgizmo> benmachine: so the best way is to so as you and Saizan told me (ie to split into chunks) ?
10:56:20 <benmachine> cgizmo: one can argue about the best way all day, but definitely it's better than trying to open them all at once
10:56:35 <benmachine> it's definitely better
10:56:55 <cgizmo> all right, i'll try this then :D
10:57:31 <cgizmo> thanks a lot, you've been very helpful :)
10:57:37 <Saizan> and maybe GC will actually free them, or at least you've a safe point where you can trigger the finalizer
10:57:58 <benmachine> lessons learnt: 1. strace is useful 2. where the error is caught isn't necessarily where it was caused 3. ignore an error now and it will turn up later
10:58:02 <benmachine> *it may
10:58:12 * benmachine gets back to work
10:58:32 <benmachine> 2 and 3 are really the same thing
10:58:39 <benmachine> but lessons come in threes
10:58:44 <benmachine> so I stretched it a bit
10:58:52 <cgizmo> :D
10:59:00 <Saizan> 4. file a bug report against taglib, it should at least export a function to dispose of a Tag/TagFile properly, or document the caveat
10:59:08 <benmachine> Saizan: hmm, not sure
10:59:25 <benmachine> it does have an error-reporting mechanism
10:59:30 <cgizmo> well, I have to go, but i'll pop back in to get more help / thank you two later :)
10:59:33 <benmachine> I think "save" disposes of the file
10:59:35 <Saizan> benmachine: well, finalizers are not guaranteed to run
10:59:35 <benmachine> but
10:59:37 <benmachine> I don't know
10:59:39 <benmachine> oh
10:59:39 <benmachine> I see
10:59:58 <Saizan> cgizmo: np :) byes
11:00:02 <benmachine> in which case yeah makes sense
11:00:05 <cgizmo> thanks again, and bye
11:00:59 <mreh> how could I implement a general euclidian distance function, like with arbitary length vectors
11:01:24 <benmachine> mreh: sounds messy
11:01:32 <benmachine> wait I'm supposed to be doing work
11:02:01 <dancor> why not go for any metric space
11:02:10 <mreh> dancor: explain yourself
11:03:39 <dancor> mreh: a euclidean space is a type of metric space
11:03:56 <mreh> it's alright actually, i'll just make the interface so that the user has to supply a distance function of the right type
11:04:29 <mreh> dist :: Ord b => a -> b
11:04:36 <dancor> a -> a -> b
11:04:43 <mreh> yes
11:05:04 <mreh> what's the most general type to represent a quantity
11:05:11 <dancor> well Ord dosent' seem right there
11:05:16 <mreh> Num
11:05:25 <dancor> ya
11:05:31 <mreh> it's a scalar
11:05:53 <mreh> can I put a context inside a function definition?
11:06:03 <benmachine> the most general type to represent a quantity is a >_>
11:06:56 <dancor> mreh: what is a context?  a type annotation?
11:07:09 <dancor> i need more context
11:07:16 <benmachine> contexts are the things to the left of =>s aren't they?
11:07:18 <mreh> function :: This bit => a -> b
11:07:40 <benmachine> you can put a context in any type signature
11:07:47 <mreh> function :: This bit => a -> (Ord b => a -> b)
11:07:57 <benmachine> well
11:08:00 <benmachine> in that case, just do
11:08:10 <benmachine> function :: (Ord b) => a -> (a -> b)
11:08:17 <benmachine> (which is a -> a -> b)
11:08:18 <mreh> yeah, i gotcha
11:08:43 <benmachine> you can put all the contexts in the same place and it should still make sense
11:08:58 <mreh> -> is left associative though
11:09:21 <mreh> a -> (a -> b) is not the same as a -> a -> b
11:09:29 <benmachine> -> is right associative
11:09:46 <benmachine> a function of a -> a -> b takes a parameter of type a and returns a function a -> b
11:09:50 <benmachine> currying
11:10:10 <mreh> is anyone else reading this?
11:10:23 <benmachine> @vixen am I right
11:10:24 <lambdabot> right or wrong, as long as we have a good time
11:10:32 <benmachine> :/ unhelpful
11:11:05 <mreh> right, i see why
11:11:07 <copumpkin> mreh: you just said the opposite of what is true
11:11:25 <mreh> a -> (a -> b) -> c is not the same as a -> a -> b -> c
11:11:31 <benmachine> no
11:11:41 <benmachine> but it is the same as a -> ((a -> b) -> c)
11:11:59 <mreh> no, as in yes?
11:12:06 <benmachine> which is not the same as a -> (a -> (b -> c)) which *is* the same as a -> a -> b -> c
11:12:11 <benmachine> no as in yes
11:12:14 <benmachine> :P
11:12:14 <dancor> benmachine: vixen gave you excellent advice!
11:12:24 <benmachine> dancor: yeah I suppose so
11:12:38 <mreh> right associativity \o/!
11:12:38 <benmachine> @vixen please accept my apologies
11:12:39 <lambdabot> keep asking
11:12:47 <benmachine> @vixen pretty please?
11:12:47 <lambdabot> don't beg
11:12:48 <dancor> wrong associativity
11:12:53 <benmachine> :(
11:12:59 * benmachine conflicting signals
11:13:03 <dancor> vixowned
11:13:12 <mreh> -> is left associative?
11:13:20 <copumpkin> no
11:13:23 <benmachine> no as in no
11:13:29 <copumpkin> no as in no as in no
11:13:37 <benmachine> > let no = no in no
11:13:39 <dancor> :showassociativing (->)
11:13:40 <lambdabot>   mueval-core: Time limit exceeded
11:13:53 <copumpkin> > fix no
11:13:54 <lambdabot>   Not in scope: `no'
11:13:57 <mreh> -> is has no associativity?
11:14:04 <benmachine> it is right-associative!
11:14:05 <benmachine> hence currying
11:14:14 <dancor> :t undefined :: a -> (a -> (b -> c))
11:14:15 <lambdabot> forall a b c. a -> a -> b -> c
11:14:22 <mreh> dancor corrected me
11:14:23 <dancor> :t undefined :: a -> ((a -> b) -> c)
11:14:24 <lambdabot> forall a b c. a -> (a -> b) -> c
11:14:37 <benmachine> no he was just making a silly comment :P
11:14:48 <benmachine> they were just etc.
11:14:50 <mreh> HAHAHA
11:14:53 <mreh> i get it!
11:14:56 <mreh> ..not
11:15:07 <benmachine> k.
11:15:20 <zygoloid> mreh: (->) is right-associative. that is all.
11:15:33 <mreh> thank you zygoloid
11:16:04 <mreh> that is all. Ye know on earth, and all ye need to know
11:16:27 <maltem> btw, mreh, (->) associates to the right
11:16:34 <zygoloid> mreh: further, "forall a b. Ord b => a -> a -> b" and "forall a b. a -> a -> (Ord b => b)" would mean the same thing, were the latter legal.
11:16:51 <mreh> yeah, i understood that bit
11:16:53 <mreh> thx
11:17:31 <mreh> it wouldn't make sense to have the context inside the right part, you could write contradictory things
11:17:47 <mreh> too easily
11:18:18 <zygoloid> mreh: turn on a few extensions and you can write "a -> a -> (forall b. Ord b => b)" but that means something else
11:18:33 <zygoloid> something else? no, the same thing! :)
11:18:46 <mreh> i almost pooped when you said that
11:19:18 <dancor> don't over-extension yourself
11:19:27 * mreh /confusion_mode = 0
11:19:50 <dancor> that couldn't possibly type-chcek
11:20:03 <zygoloid> @type undefined :: a -> a -> (forall b. Ord b => b)
11:20:04 <lambdabot> forall a b. (Ord b) => a -> a -> b
11:20:31 <zygoloid> @type undefined :: (forall b. Ord b => b) -> a
11:20:32 <lambdabot> forall a. (forall b. (Ord b) => b) -> a
11:21:44 <dancor> it seems wack that writing this escaping function (\ -> \\ etc) was easy but the unescaping function is harder.  in a perfect programming world either provides enough info for the other right?
11:21:49 <copumpkin> (forall b. Ord b => b) would be a really weird type
11:22:05 <zygoloid> copumpkin: right :)
11:22:31 <zygoloid> i'm not sure it has any non-_|_ elements
11:22:42 <copumpkin> I am
11:22:43 <zygoloid> unlike say (forall b. Bounded b => b)
11:22:56 <zygoloid> copumpkin: got an example?
11:23:11 <copumpkin> no, I mean, I'm sure it doesn't have any non-_|_ elements
11:23:17 <HayashiRazan> I think zygoloid is the Mike Tyson of haskell
11:23:20 <zygoloid> copumpkin: ah, i see :)
11:23:37 <zygoloid> HayashiRazan: come over here, i'll bite yer ear off
11:23:42 <HayashiRazan> haha
11:24:08 <benmachine> dancor: isn't it pretty much ('\\':x:xs) -> case x of ... : xs
11:25:46 <zygoloid> dancor: unescape xs = head $ do ys <- allStrings; guard (escape ys == xs); return ys
11:25:50 <dancor> benmachine: probably i'm just going to have to do a lot of crap bc it's a a bytestring
11:26:53 <__JN> Hello, I need help: how can I combine a function (F), two lists (A and B) and a static argument (c), so that the result is F a1 b1 c, F a2 b2 c, F a3 b3 c... and so on?
11:27:21 <copumpkin> zipWith F a1s b1s (repeat c)
11:27:26 <zygoloid> __JN: zipWith (\a b -> f a b c) as bs
11:27:29 <copumpkin> zipWith3 F a1s b1s (repeat c)
11:27:37 <copumpkin> or that
11:27:57 <__JN> ok, thanks, Ill try
11:28:31 <copumpkin> __JN: if you can move the static argument to the front, it'll be nicer
11:28:38 <dancor> functions have to start with a lowercase letter so s/F/f
11:28:46 <dancor> i think the repeat is a cool way of doing the static arg
11:28:49 <copumpkin> unless it's a constructor! ;)
11:28:53 <dancor> oh
11:28:54 <copumpkin> :)
11:29:45 <mreh> what does Real contrast with in Haskell? The integers "below" it
11:29:54 <copumpkin> ?
11:30:05 <tommd> mreh: Could you restate that question?
11:30:12 <zygoloid> getZipList $ ($c) <$> (f <$> ZipList as <*> ZipList bs)
11:30:14 <copumpkin> tommd: that's what I said!!
11:30:20 <copumpkin> :P
11:30:29 <mreh> the class Real, what is it's purpose?
11:30:39 <copumpkin> @src Real
11:30:39 <lambdabot> class  (Num a, Ord a) => Real a  where
11:30:39 <lambdabot>     toRational      ::  a -> Rational
11:30:54 <copumpkin> it's a really really bad name
11:31:08 <tommd> @src Rational
11:31:08 <lambdabot> type Rational = Ratio Integer
11:31:09 <zygoloid> 'Real' is a class for numeric types which are subsets of the reals
11:31:20 <PeakerWork> > pure 1 :: ZipList Int
11:31:21 <lambdabot>   No instance for (GHC.Show.Show
11:31:21 <lambdabot>                     (Control.Applicative.Zip...
11:31:23 <byorgey> zygoloid: isn't that equivalent to   getZipList $ f <$> ZipList as <*> ZipList bs <*> pure c  ?
11:31:25 <tommd> Anything that can be a fraction.
11:31:29 <PeakerWork> > getZipList $ (pure 1 :: ZipList Int)
11:31:29 <zygoloid> byorgey: yep :)
11:31:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:31:44 <PeakerWork> another option: getZipList $ f <$> zipList as <*> ZipList bs <*> pure c
11:31:54 <zygoloid> actually, yeah, 'Real' is a class for numeric types which are subsets of the rationals...
11:32:06 <PeakerWork> pure f there could make everything be <*> :)
11:32:09 <copumpkin> (hence my "terrible name" comment)
11:32:15 <maltem> @instances Real
11:32:15 <lambdabot> Double, Float, Int, Integer
11:32:29 <mreh> Integer is a real?
11:32:29 <zygoloid> copumpkin: right :) i guess there's no Real CReal instance
11:32:57 <PeakerWork> conal: I saw the reply, I think, not sure which one you meant (sorry about late reply, I missed the last question)
11:32:58 <copumpkin> mreh: it can be converted to a fraction, so yep
11:33:03 <copumpkin> mreh: and in math it is too
11:33:08 <maltem> toRational isn't even an isomorphism on floating-points!
11:33:16 <conal> PeakerWork: ok
11:33:21 <copumpkin> maltem: yeah, lame
11:33:42 <benmachine> isn't it?
11:33:46 <PeakerWork> conal: did you mean the reply about newtypes there probably not being a good idea, or about trying not to force a particular instance on users (iiuc)
11:33:55 <benmachine> why not?
11:34:18 <conal> PeakerWork: trying not to force ...
11:34:34 <PeakerWork> conal: yeah, that's why I asked about newtypes
11:34:42 <maltem> ok my comment was lame, too. should have complained about it not being a homomorphism
11:35:00 <PeakerWork> conal: I saw you made really nice use of Maybe newtypes in the "design through type class morphisms" paper...
11:35:14 <conal> PeakerWork: yeah
11:38:12 <conal> PeakerWork: iswym about the Maybe newtypes.  hadn't thought of them as a solution to the problem of which Monoid instance to pick.
11:38:45 <conal> PeakerWork: similarly, there's First, Last, Min, Max, Sum, Product
11:39:06 <conal> all for the same purpose
11:39:08 <PeakerWork> conal: yeah, so maybe Distributive, and whatever other 3 ways to make a monad out of a type composition
11:39:17 <PeakerWork> conal: I need to read composing monads myself to know the 3 other ways :)
11:39:42 <conal> PeakerWork: yep.  i'm more inclined toward your suggestion now.
11:40:04 <conal> PeakerWork: Functor and ContraFunctor have the same issue
11:40:19 <conal> PeakerWork: there are two instances of each for type composition
11:42:39 <kbateman> Anybody here?
11:42:53 <Rayne> nope
11:42:58 <kbateman> Oh, sorry.
11:43:06 <zygoloid> try again later, we might be back by then.
11:43:47 <kbateman> What's the best way to install cabal on a debian lenny system?
11:44:48 <kbateman> I want to try out agda, and agda won't install without cabal, and I can't figure out how to install cabal.
11:45:51 <kbateman> there's a libghc6-dev-cabal package, but I don't actually want to develop anything with cabal.
11:46:12 <kbateman> there's a libhugs-cabal package, but I want to work in ghc, not hugs.
11:46:27 <Twey> libghc6-dev-cabal sounds hopeful to me.
11:47:02 <kbateman> Maybe that's what I should use.  Usually the -dev libraries are for software development, though.
11:48:42 <dcoutts> kbateman: libghc6-dev-cabal is probably the Cabal library
11:48:46 <shapr> Bah humbug... there's no Haskell package for reading apt Package listings.
11:48:49 <Twey> kbateman: Not really — they usually include headers
11:49:04 <Twey> Which you need to compile things; for example, Agda.
11:49:18 <kbateman> hmm.  libghc6-dev-cabal is a virtual package that is linked to ghc6
11:49:25 <dcoutts> kbateman: and the Cabal library already comes with ghc, what you want is the "cabal-install" package. That's the one that provides the 'cabal' command line program.
11:49:47 <kbateman> I can't find cabal-install in aptitude
11:50:27 <dcoutts> in that case, get it from http://haskell.org/cabal/download.html
11:50:44 <kbateman> I'm looking at http://www.haskell.org/haskellwiki/Cabal-Install
11:51:03 <sproingie> ubuntu oddly enough doesn't have the cabal-install package, while vanilla debian does
11:51:08 <hackagebot> bindings-common 1.3.2 - Preprocessor DSL for low level FFI. (MauricioAntunes)
11:52:28 <kbateman> I'm reluctant to install non-debian software because I really like having debian manage all that stuff for me.
11:52:41 <sproingie> if you're on ubuntu you don't have much other choice
11:52:44 <kbateman> I suppose I could have it install into a directory under $HOME
11:53:00 <sproingie> that's where cabal installs for non-root anyway
11:53:08 <sproingie> namely ~/.cabal/bin
11:53:16 <kbateman> I have debian, but I can't find a cabal-install debian package
11:53:23 <sproingie> heck it installs there for root too
11:53:58 <sproingie> it might be new.  i run sid, and it's there
11:54:01 <dcoutts> sproingie: though if you were root you'd be intending to do --global installs
11:54:09 <kbateman> I run lenny.
11:54:14 <sproingie> ah.  i guess it's new.
11:54:21 <sproingie> would be why ubuntu doesn't have it either
11:54:52 <benmachine> you should not be limited to just what your distribution provides
11:54:53 <kbateman> I've downloaded http://www.haskell.org/cabal/release/cabal-install-0.6.2/cabal-install-0.6.2.tar.gz, I guess I'll try that.
11:55:00 <sproingie> they snapshot sid every 6 months but they base the release off a snapshot that's 6 months old by release
11:55:01 <benmachine> it's handy to be able to install stuff of your own
11:55:11 <benmachine> and in /usr/local/bin and friends it's usually fine
11:55:17 <sproingie> cabal's easy to install anyway, just run the bootstrap and it should be painless
11:55:25 <sproingie> i personally use /pkg and symlinks in /opt
11:55:29 <kbateman> I could manually install whatever I want, but I consider myself old and wise enough to let the package manager handle everything outside of my home directory.
11:55:40 <sproingie> e.g. /opt/foo -> ../pkg/foo-1.2.3
11:55:50 <sproingie> i should probably learn to use stow
11:57:03 <drworm> Howdy.
11:57:04 <dcoutts> sproingie: ah you use the cabal symlink-bindir feature?
11:57:24 <sproingie> the pkg+opt business ran a multi-arch software distribution system for all of Sun for many years so i figure it works all right for my dinky lab boxen
11:57:36 <sproingie> 'course they used fancy wrappers too, i don't
11:57:49 <kbateman> have to install libghc-network
11:58:01 <sproingie> dcoutts: nope, just saying how i do all my software distributions.  is that how cabal does things too?
11:58:04 <dcoutts> sproingie: you can tell cabal to install into dirs using '$arch' :-)
11:58:27 <drworm> Well, that was fun.
11:58:31 <drworm> Be back later!
11:58:50 <dcoutts> sproingie: the ~/.cabal/config has a  symlink-bindir field, so I have it install into ~/.cabal/bin and add symlinks in ~/bin
11:59:03 <dcoutts> and it's careful only to overwrite symlinks that it 'owns'
11:59:05 <sproingie> interesting.  i just add ~/.cabal/bin to my PATH
12:02:46 <kbateman> OK, I have cabal, let's see how agda works out.
12:05:49 <_-JN123> newbie question: if I have a list with elements of type IO (), how do I execute them?
12:06:10 <zygoloid> _-JN123: sequence_
12:06:13 <zygoloid> @type sequence_
12:06:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
12:06:25 <_-JN123> ok, great
12:07:53 <namor> What library would you use simplify and transform boolean terms?
12:08:37 <m0nkfish> @index !!
12:08:38 <lambdabot> Data.List, Prelude
12:08:54 <m0nkfish> whats the command to find out info
12:09:14 <m0nkfish> @info !!
12:09:14 <lambdabot> (!!)
12:09:31 <byorgey> m0nkfish: the :info command works in ghci
12:09:32 <kbateman> Ok, it looks like I need ghc 6.10
12:09:41 <m0nkfish> @hoogle !!
12:09:42 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:09:42 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:09:47 <m0nkfish> @hoogle !! --info
12:09:47 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:09:47 <lambdabot>  
12:09:47 <lambdabot> List index (subscript) operator, starting from 0. It is an instance of the more general Data.List.genericIndex, which takes an index of any integral type.
12:10:54 <mreh> can i remove an element and return the list minus the element in one pass?
12:11:07 <mreh> can't think of a way
12:11:09 <mauke> mreh: can you do it in two passes?
12:11:20 <mreh> mauke, yes
12:11:23 <mauke> how?
12:11:33 <mreh> hmm
12:12:23 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11276 <-- If any of you feel up to a challenge, I'd appreciate a check to make sure this bit of mixed STM/IO code has no race conditions
12:12:24 <sm> filter (not . (== e))
12:12:31 <mreh> i want to choose n unique elements of a list
12:12:35 <mauke> delete
12:12:52 <mauke> take n . nub
12:12:53 <mreh> so i thought if I go through choosing random elements each time chucking one away
12:13:06 <mreh> :t nub
12:13:06 <kbateman> filter?
12:13:07 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:13:26 <kbateman> filter (/= element) list
12:13:32 <m0nkfish> do integers go over 1024
12:13:35 <mreh> @src nub
12:13:35 <lambdabot> nub = nubBy (==)
12:13:35 <zygoloid> mreh: how are you specifying the element to remove?
12:13:41 <mauke> m0nkfish: yes
12:13:45 <kbateman> integers are guaranteed to be at least 31 bits, I think
12:13:50 <kbateman> ints I mean
12:13:52 <lizrail> hi all
12:13:54 <MyCatVerbs> kbateman: 30, signed.
12:13:58 <mauke> I thought 29 bits
12:14:08 <mreh> zygloid, by direct comparison
12:14:10 <MyCatVerbs> H98 says they span the range between 2^-29 and (2^29)-1.
12:14:17 <lizrail> I have a problem with hsql-mysql
12:14:22 <kbateman> I believe MyCatVerbs
12:14:34 <lizrail> it segfaults when I read data from mysql database
12:14:46 <mreh> zygoloid, they should be unique items, but now I'm not so sure
12:14:47 <MyCatVerbs> I can quote chapter and verse in the H98 report on that, if you like, as soon as I find a copy.
12:15:10 <lizrail> I've made a test snippet here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11277#a11277
12:16:05 <MyCatVerbs> http://www.haskell.org/onlinereport/basic.html <- section 6.4, "Numbers", fourth paragraph.
12:16:41 <lizrail> I tested both on gentoo and fedora. with ghc-6.10 and latest hqsl from hackage
12:17:18 <lizrail> does anybody have any ideas what might be wrong?
12:19:25 <zygoloid> mreh: if you're doing it with (==) then surely you already have the element?
12:19:52 <mreh> zygoloid, i have it, then i need to remove it from the list it came from
12:20:09 <mreh> i can't remove it and extract it at the same time
12:20:22 <mreh> s/find/remove/
12:20:53 <mreh> that's the wrong way
12:21:13 <mreh> since when did perl regex get popular into this channel?
12:22:01 <MyCatVerbs> mreh: since Dons made that pcre-light binding that was so much less painful to use than the default Text.Regex.Base. Probably.
12:22:24 <mreh> oh, delightful
12:22:32 <mreh> i'll have to check it out
12:24:27 <zygoloid> mreh: why do you need to extract it and not just remove it, if you already have it?
12:24:58 <mreh> zygoloid, i'm selecting an arbitary number of unique elements in a list
12:33:06 <Vanadium> Great, I take a break from studying and then some guys at the next table get into an argument about category theory
12:33:16 <Vanadium> Haskell will never let me go :C
12:33:40 <BONUS> are you at a bar
12:33:43 <mreh> where are you hanging out? my library is full of twits
12:33:50 <mreh> :D
12:34:06 <mreh> i'd love to hear that level of discussion in everyday life
12:34:39 <kw317> LOL
12:34:39 <Vanadium> Dormitories, apparently the computer science neighbour has a couple of friends over
12:34:41 <Cale> Vanadium: An *argument* about category theory?
12:34:54 <kw317> if this is what you hear every day, then you probably hang out with wrong people ;-)
12:35:00 * kw317 's joking
12:35:00 <zygoloid> Cale: you know how it is, some people prefer dogegory theory
12:35:05 <Cale> No, clearly the right people.
12:35:14 <BONUS> tell edwardk what they are saying and then just read what he's saying back to them. that'll own them
12:35:44 <copumpkin> YOU ARE SUCH A PULLBACK
12:35:45 <kw317> I guess it's ok until someone starts to prove something on a napkin at the dinner table
12:35:59 <copumpkin> YOU KNOW WHAT? I FUNCTORED YOUR MOTHER LAST NIGHT
12:36:03 <copumpkin> like that?
12:36:12 <Vanadium> Cale: They were in disagreement what makes a functor -- I could not really figure out anything else because I know nothing about the terminology :>
12:36:19 <kw317> BONUS: awesome idea ;)
12:36:38 <Cale> Vanadium: Oh, huh.
12:36:51 * kw317 struggles with denotational semantics
12:36:58 <copumpkin> CT noobs
12:37:43 <mreh> I dont know anything about category theory, but I know what I like
12:38:05 <Cale> Vanadium: Well, a functor T: C -> D is just an assignment for each object X of C an object TX of D, and for each arrow f: X -> Y in C, an arrow Tf: TX -> TY in D such that T id_X = id_(TX) and T(f . g) = Tf . Tg
12:38:08 * kw317 has to sit in digicomms course when ct is happening next door :(
12:38:12 <HayashiRazan> how are Haskell and Category theory related?
12:38:14 <FunctorSalad> @remember <copumpkin> YOU ARE SUCH A PULLBACK <copumpkin> YOU KNOW WHAT? I FUNCTORED YOUR MOTHER LAST NIGHT
12:38:14 <lambdabot> Done.
12:38:23 <HayashiRazan> Done?
12:38:28 <mreh> @quote mreh
12:38:28 <lambdabot> No quotes match. Are you on drugs?
12:38:34 <HayashiRazan> what?
12:38:36 <mreh> :C
12:38:37 <Cale> HayashiRazan: There is a category of Haskell types and Haskell-definable functions between them
12:38:47 <HayashiRazan> I see
12:39:05 <Cale> HayashiRazan: and we like to steal ideas from general category theory and turn them into programming idioms :)
12:39:17 <dpratt71> Cale: <Cale> "Well, a functor..."; exactly; I don't know how anyone could confuse that
12:39:34 <Vanadium> It seemed easier as just "where fmap :: ..."
12:39:38 <mreh> are catamorphisms from category theory?
12:39:46 <FunctorSalad> Vanadium: hard to imagine they were disagreeing what a functor is :)
12:39:53 <FunctorSalad> unless they were talking foundations
12:40:00 <FunctorSalad> talk foundations to me
12:40:17 <Cale> Vanadium: Well, if you want the fmap explanation, it's less general, but you still need the laws: fmap should always be defined so that fmap id = id and fmap (f . g) = fmap f . fmap g
12:40:25 <Vanadium> i think they were just arguing about the precise terminology before the general conversation got too loud for me to follow :v
12:40:43 <byorgey> mreh: indeed, or at least, the definition of catamorphism is a categorical one
12:40:45 <Cale> Yeah, there's a fine point here about what "an assignment" is.
12:40:51 <byorgey> I don't know if categorists came up with that name.
12:40:57 <Cale> If they are small categories, it just means a function
12:41:25 <Cale> For large categories, you'd want it to be a class function.
12:41:48 <FunctorSalad> "catamorphism" is from cata-, "downwards"
12:42:04 <Cale> byorgey: I think catamorphisms are just from recursion theory and the CT guys initially had nothing to do with them
12:42:26 <Cale> oh, that was more for mreh :)
12:42:26 <FunctorSalad> yes I haven't heard it in CT
12:43:03 <FunctorSalad> they call the arrows who's existence is guaranteed by a universal property "mediating arrows" I think
12:43:39 <Cale> The *morphism definitions which are more from the CT side of things are: homomorphism (just another term for arrow), monomorphism, epimorphism, isomorphism, endomorphism, automorphism.
12:43:49 <FunctorSalad> yep
12:44:01 <dpratt71> I was reading an Erik Meijer paper the other day (bananas?) where he discussed "cata-" and other morphisms; I was wondering if he coined the term or borrowed it
12:44:30 <Cale> When it comes to him, that's a good question. He's the banana guy.
12:45:36 <byorgey> Cale: ah, ok.  I certainly first heard about foo-morphisms in categorical terms.  but perhaps that's a reinterpretation, from a historical point of view?
12:45:41 <kw317> bananas, lenses, and barbed wire?
12:45:49 <dpratt71> kw317: that's it
12:46:01 <Cale> byorgey: yeah, there's a formalism in terms of F-algebras and F-coalgebras
12:46:11 <Cale> kw317: yeah
12:46:13 * kw317 finally after reading that paper got the joke from evolution of a haskell programmer
12:46:30 <kw317> the one about student who ate so many bananas that now he needs lenses ;-)
12:46:40 <kw317> awesome reference XD
12:46:42 <byorgey> Cale: right, and I first learned about algebras and coalgebras as a categorical concept =)
12:46:54 <Cale> Right, those are firmly categorical :)
12:46:56 <byorgey> but I guess you don't need CT to define them.
12:47:14 <byorgey> oh, ok =)
12:47:37 <Cale> Well, you don't need CT to unwittingly define an initial object in some category of F-algebras without knowing that's really what you're doing ;)
12:47:40 <tautologico> I just tried to install the latest haskell platform (using ghc 6.10.4) and it complains about a missing Setup script in mtl
12:47:52 <byorgey> Cale: heh, right =)
12:48:38 <dpratt71> RE: Categories; I think it very bizarre that I find complex topics much easier to comprehend than simple ones
12:48:59 <Cale> tautologico: I've found that if you have to compile the Haskell platform yourself, it's not worth the trouble. Just getting a binary of GHC and installing cabal-install gives you essentially the same effect with less hassle.
12:49:20 <tautologico> I installed a ghc binary
12:49:33 <tautologico> I was using cabal-install earlier but decided to try using the platform
12:49:59 <tautologico> guess I will go back to installing cabal
12:50:59 <m0nkfish> is there a function to 'wrap' a list with an item
12:51:13 <m0nkfish> like a double cons for the head and last item
12:51:25 <mercury^> What is the use of the Haskell platform with Cabal around anyway?
12:51:26 <mreh> is there an alternative to passing a random number generator all around my program, all because I can't get it out of the IO monad
12:51:41 <byorgey> m0nkfish: no, but it's easy to make one yourself:  wrap x xs = x : xs ++ [x]
12:51:47 <dcoutts> mercury^: stability, you do not always want the bleeding edge
12:52:00 <dcoutts> mercury^: what's the point of debian when you've got sourceforge?
12:52:11 <m0nkfish> im using x : xs ++ [x] just wondered if there was any shorthand
12:52:13 <aug_triad> Hi. I would like to use a neural network library with Haskell, and has downloaded and installed the C library FANN. When I want to build the Haskell binding HFANN with runghc Setup.lhc, I get an error saying ld: warning: in /usr/local/lib/libdoublefann.dylib, file is not of required architecture, and a list of undefined symbols. I am compiling on Snow Leopard, so maybe it is a problem with 32 vs 64 bit? I have tried to learn how the runghc Setup works,
12:52:14 <aug_triad> it's very sparse what I could find. Can anybody help me?
12:52:20 <mercury^> dcoutts: Sourceforge has no convenient install mechanism.
12:55:00 <dcoutts> mercury^: true, but I hope you see the point I'm getting at
12:56:52 <mercury^> Somewhat. As Cabal packages can have detailed dependency information, I see limited use in a set of packages designated stable.
12:57:47 <dancor> cabal packages notoriously break rules and don't work once you leave certain normal use cases (even in those sometimes)
12:57:58 <dcoutts> mercury^: it's perhaps of less use to hard core Haskell hackers but it's useful to tell distros what they should be packaging at the moment
12:58:11 <dancor> this is one reason having a more-likely-to-be-supported platform as a stable option is good
12:58:19 <dcoutts> and it's also about having a certain level of centralised QA
12:58:28 <dcoutts> rather than making every distro do it separately
12:58:37 <dancor> haskell has otherwise a bleed-edge-supported-only(-if-that) community
13:02:24 <Cale> tautologico: The real intent of the Platform, I think, is to be a collection of things which the distribution guys package up into packages for whatever distribution you're running.
13:02:34 <Cale> (so you'd only install it indirectly)
13:05:25 <mercury^> Has anyone tried to write a package that lets you conveniently use ghci as shell?
13:05:33 <Zao> mercury^: HSH?
13:05:39 <tommd> hsShell?
13:06:06 <maltem> m0nkfish, there's no shorthand because it's not a common operation: appending to the end of a list is costful
13:06:16 <tommd> ohh, no.  ShellAC - I really liked that.
13:06:23 <Zao> run $ "ls -l" -|- ("wc", ["-l"]) :: IO ExitCode
13:06:26 <tommd> It isn't like sh or bash, but you could use it to make one.
13:06:46 <Zao> I used HSH to make some "scripts" to grade code.
13:06:48 <Zao> Quite handy.
13:07:45 <tommd> cool
13:07:46 <mercury^> Zao: ideally, it would define a new interface instead of letting you use traditional unix commands like that.
13:08:19 <tommd> I think you use "run" to call unix command but otherwise its a Haskell interpreter... right?
13:09:02 <mercury^> You need easy file access, files should be treated like they are implicitly opened with hGetContents.
13:09:49 <mmorrow> cat
13:10:19 <Cale> tommd: HSH is just a Haskell library
13:10:30 <Cale> tommd: So that would be true, if you used it with GHCi
13:11:06 <Cale> It works better for programming shellscripts than as an interactive shell
13:11:25 <mercury^> The editor would have type [Char] -> IO [Char], there'd be a command "mail :: [Char] -> Address -> IO ()" etc.
13:12:47 <mercury^> Oh, serialisation should be very easy too.
13:13:06 <mmorrow> serialization of what?
13:13:17 <mercury^> Haskell objects.
13:13:24 <shambler> ???
13:13:24 <mmorrow> functions?
13:13:34 <mmorrow> function := ?
13:13:43 <mercury^> Anything.
13:13:47 <mmorrow> bytecode? machine code? the name of the function?
13:15:05 <mercury^> Uh, storing the name of the function is obviously not enough. How exactly you allow for it to be saved to a file and retrieved later is not important however.
13:15:17 <sw17ch> http://www.teamfortress.com/pumpkinpatch/
13:15:20 <sw17ch> oh shit, click on the heavy's hat
13:15:21 <Younder> is there any possibillity he is as dumb as he seems?
13:15:23 <sw17ch> receive own hat
13:15:33 <mauke> w
13:15:34 <sw17ch> dangit
13:15:37 <sw17ch> wrong window again
13:16:10 <Younder> seems like morons corner
13:16:18 <mauke> Younder: ?
13:16:55 <Younder> just trying a bit of humor
13:17:29 * byorgey missed the humor
13:17:36 <zygoloid> is everyone in the wrong window today?
13:17:43 <mmorrow> mercury^: so we're talking about bytecode then.
13:18:01 <mmorrow> mercury^: yeah, that would be handy
13:18:30 <mercury^> mmorrow: I believe you could have a very nice workflow with such a setup.
13:18:48 <mmorrow> me too
13:19:08 <sproingie> need a little review of tutorial content if anyone cares to: http://sparkle.fishbulb.net/wiki/Haskell_Tutorial/Chapter_02
13:19:43 <mercury^> sproingie: You have any question?
13:19:51 <sproingie> no, i'm writing it
13:20:02 <mercury^> Oh. :)
13:20:08 <aug_triad> Can anybody give me a reference how to make a Setup.lhs and foo.cabal config file? I would like to know how what all these options in foo.cabal does... Is it possible to give some options to the gcc compiler there?
13:20:38 <mmorrow> aug_triad: look on hackage at the "package description" links for various packages
13:20:49 <mmorrow> aug_triad: to see sample .cabal files
13:21:01 <dcoutts> aug_triad: see the Cabal user guide
13:21:09 <sproingie> any constructive criticism is helpful of course.  the chapter is so far staying away from the type system, i'm introducing lambdas, closures, and currying
13:21:12 <mmorrow> aug_triad: wrt Setup.lhs, i use the same 2-liner for every package
13:21:34 <pacak> Any idea how can i fix problem like this one - http://hackage.haskell.org/packages/archive/hashed-storage/0.3.9/logs/failure/ghc-6.10
13:21:42 <mmorrow> > import Distribution.Simple
13:21:42 <mmorrow> > main :: IO ()
13:21:42 <mmorrow> > main = defaultMain
13:21:43 <lambdabot>   <no location info>: parse error on input `import'
13:21:43 <dcoutts> aug_triad: http://haskell.org/cabal/release/cabal-latest/doc/users-guide/
13:21:43 <lambdabot>   Not in scope: `main'
13:21:43 <lambdabot>   <no location info>: parse error on input `='
13:21:44 <mmorrow> 3-liner
13:21:52 <Cale> sproingie: Seems curious to introduce implementation details so early. I wouldn't talk about closures at all.
13:22:10 <Cale> (just functions)
13:22:25 <Younder> sproingie, What everyone wonders about is these monads
13:22:37 <sproingie> Cale: well it's not a lot of detail, i'm just using it to explain currying
13:22:49 <RDx_> hey room
13:22:54 <mercury^> sproingie: At the point where you describe how the type system prevents `1 + "2"', you should mention how to get the desired effect there.
13:23:15 <ira> hiya... I'm making a simple REST service using Network.FastCGI and I need to keep some state in memory. It seems like StateT would be most obvious, but Kibro uses ReaderT with MVar inside it instead. How come? Any insights appreciated...
13:23:26 <Cale> (I haven't looked at the actual tutorial yet, as I'm on a torrent, which makes my crappy router choke on everything.)
13:23:44 <mmorrow> ira: because multiple threads need to concurrently access the state
13:24:04 <tommd> pacak: You seem to have two different bytestring libraries.  I suggest you get rid of one.
13:24:08 <mmorrow> ira: e.g. a "currently logged in" Map
13:24:15 <sproingie> mercury^: yeah i'm tackling that in the third section, first subsection will be called "Where all the types at?" or something
13:24:19 <aug_triad> mmorrow: Yes, it is more the .cabal file that I don't know to setup. I have some trouble installing hfann because of a error: in /usr/local/lib/libdoublefann.dylib, file is not of required architecture, and a list of undefined symbols. So I think that the gcc compiler is compiling for the wrong architecture
13:24:22 <tommd> The 'dreaded diamond dependency problem' or DDD
13:24:25 <Cale> ira: Using StateT over IO which already has IORefs, MVars, etc. etc. always seems a bit excessive to me.
13:24:53 <sproingie> mercury^: basically saying "hey, isn't haskell a strongly typed language?  why am i not seeing type declarations all over the place like i need with C++, Java, etc"
13:25:06 <Cale> ira: You can use ReaderT to get an MVar to where you need it, but usually I would just pass it as a parameter.
13:25:23 <Younder> Haskell is strogly typed language
13:25:39 <Younder> But it has INFERRED types
13:25:42 <Cale> (i.e. don't bother with monad transformer machinery unless the parameters really get out of hand)
13:25:49 <mercury^> Younder: interesting...
13:25:58 <jmcarthur> i like StateT even over IO because i can have functions over MonadState s m => m a rather than requiring MonadIO just for references
13:26:04 <Younder> a big difference
13:26:08 <sproingie> well it infers types, though in chapter 3, i'll be decorating everything with types anyway
13:26:28 <sproingie> chapter 3 and on, that is
13:26:49 <pacak> tommd: I have only bytestring-0.9.1.5
13:26:51 <Cale> jmcarthur: I suppose that's something, though if you have enough of that, it becomes questionable why you're using a transformer at all :)
13:27:14 <sproingie> adds documentation, gives better errors, makes better assurances, blah blah
13:27:27 <ira> Cale: Yes, I would so avoid monad transformers if possible, but I think it must be necessary since I can't think how else state could evolve for a sequence of CGI responses
13:27:28 <Cale> (because if you can separate out the use of state to that extent, you don't seem to need IO there)
13:27:33 <tommd> pacak: Well the build error you linked to has 0.9.1.4.
13:27:36 <jmcarthur> Cale: you only actually use a transformer at the point that you apply a runner function ;)
13:27:48 <Cale> ira: IO already has a lot of state capabilities built in
13:27:54 <tommd> pacak: So you just want to fix the hackage build bot error?  Not and issue on your system?
13:28:09 <tommd> Not sure of any simple way to go about it.
13:28:26 <pacak> tommd: I have same issue on my system. Just googled for some logs and found this.
13:28:41 <sproingie> actually i'll probably have to take a pass at types early if just to say "we'll see more on that later", because anyone following in ghci has by now probably tried to show a function
13:29:06 <Cale> jmcarthur: Pretty close. I also use monad transformers in order to construct pretty specific libraries. I usually don't see a need for them in application programming. There are some fuzzy lines there though, I'll admit.
13:29:16 <tommd> pacak: Next time just upload your own log.
13:29:17 <pacak> tommd: I already started haskell-updater (i am using gentoo with paludis, gentoo-haskell overlay is fully unmasked), but it did not helped.
13:29:26 <mercury^> sproingie: explaining Show will be quite a challenge though.
13:30:12 <Cale> I don't like *visible* monad transformer code. If there's going to be a monad transformer, I want to hide it behind a module boundary so that nobody knows that I'm using one.
13:30:20 <RDx_> guys , I read this leanryouahaskell thing but I am not sure on the syntax.. see, I have to use hugs, and many things in ghci give errors in hugs
13:30:24 <sproingie> mercury^: i'll just handwave.  "Haskell is telling you in its own elaborate way that it doesn't know how to show a function to you"
13:30:27 <jmcarthur> Cale: typically, even for those specific libraries, if i expose a transformer i do so with a type class interface like the Monad* type classes, and i end up using it in application code in that generic way
13:30:34 <RDx_> copumpkin: you there?
13:30:37 <mauke> RDx_: only freestanding 'let's
13:30:40 <sproingie> mercury^: type classes will probably have to get pushed out to chapter 4 at least
13:30:46 <RDx_> mauke: hi, what?
13:30:58 <ira> hmm, well I'd love to figure that out. Just wondering how one *usually* preserves state through multiple fastcgi calls. Surely I am not the Nth to try this
13:31:11 <Cale> RDx_: Put all your definitions in a file and load it with hugs. Type *expressions* on the hugs commandline.
13:31:19 <Cale> RDx_: (not definitions)
13:31:20 <jmcarthur> Cale: when i use transformers in application code i typically either leave it completely generic like that or i make a newtype wrapper. i rarely (never?) force my function types to be concrete stacks
13:31:32 <Younder> sproingie, sounds like you are on to something. Good luck!
13:31:37 <RDx_> Cale, I get that... i dont really get the syntax for what to put in a file
13:31:55 <pacak> Any idea how do i fix this - http://dpaste.com/113885 ?
13:31:58 <Cale> RDx_: Okay, basically it should look like a bunch of equations for functions
13:32:04 <mmorrow> ira: MVars are the usual way
13:32:12 <Cale> RDx_: At least until you get to defining your own datatypes etc.
13:32:16 <mmorrow> ira: well, that's not entirely true
13:32:24 <mmorrow> ira: what sort of state are we talking about here?
13:32:27 <Younder> sproingie, Still think you should mention them monads
13:32:28 <Cale> RDx_: So, for example, in foo.hs you might put
13:32:31 <Cale> fac 0 = 1
13:32:33 <sproingie> at the rate i'm proceeding, i'm going to have something the size of a textbook
13:32:34 <RDx_> Cale, here is an example, i need to define a function 'neverFollows' of type [Integer] -> Bool, so that neverFollows(x, y, lst) is try iff whenever x occurs in the list lst, it is not followed by y
13:32:36 <Cale> fac n = n * fac (n-1)
13:32:56 <RDx_> cale, that was a homework problem, but this has been a problemf or me for w while now
13:33:00 <Cale> and then on the hugs/ghci commandline, you'd test it with  fac 6
13:33:02 <mauke> RDx_: that doesn't match your type signature
13:33:04 <ira> morrow: a couple of maps
13:33:15 <Younder> They are aruably the most difficult, or perhaps alien, part of Haskell
13:33:15 <Cale> RDx_: Yeah, the type makes no sense there.
13:33:16 <RDx_> Cale, so neverFollows::[Integer]->Bool would be my definition
13:33:26 <sproingie> Younder: by the time i get to them, i hope they're demystified
13:33:32 <ira> need to update them in response to POST and PUT
13:33:38 <RDx_> Cale, i figured. I came in here before and i realized the vocabulary we are using in class is way different from what this community uses
13:33:43 <Cale> RDx_: That's a type declaration, so yeah, that goes in the file. But you also need to define what the function does.
13:33:50 <mmorrow> ira: one sort is the e.g.  MVar (Map User Status), data Status = Status {timeOfLastResponse :: Time, somethingCryptoIsh :: CryptoIsh, ..}
13:33:54 <RDx_> cale, how do I do that?
13:34:06 <Cale> RDx_: Based on the type, the function takes *just* a list of integers and produces a Bool
13:34:12 <sproingie> i'm going to have to handwave the IO monad in just a little bit, i don't expect people to have to get halfway through just to be able to print "Hello <yourname>" to the screen
13:34:19 <mmorrow> ira: the other sense being the state of that person's interaction wrt to some we content
13:34:23 <RDx_> Cale, ok... I dont know how to write that.. it also has three variables
13:34:23 <Younder> sproingie, looking forward to your book
13:34:39 <Cale> RDx_: However, your description of what the function ought to do involves extra numbers, which your type signature doesn't indicate.
13:34:44 <mmorrow> ira: which might be propogated just via links that you generate w/in a response
13:34:58 <RDx_> Cale: what should it look like?
13:35:00 <mmorrow> ira: and those links generate further responses, etc, based on ...
13:35:02 <Cale> RDx_: So what you probably really want is  neverFollows :: Integer -> Integer -> [Integer] -> Bool
13:35:13 <ira> morrow: oh I should clarify, this is a straight up REST service, no *sessions* or anything
13:35:20 <Cale> and then you define:
13:35:30 <Cale> neverFollows x y zs = ...
13:35:34 <RDx_> Cale: and it i wanted characters I would use Char -> Char -> [Integer] -> bool ?
13:35:38 <mmorrow> ira: ah, ok. hmm, i'm not sure the "usual" way wrt that.
13:35:42 <Cale> RDx_: yes
13:35:43 <ira> idempotency maintained
13:35:47 <RDx_> Cale: how does it know which -> is the return value?
13:35:49 <RDx_> *return type?
13:35:56 <Cale> RDx_: -> is right associative
13:36:00 <mauke> RDx_: the last one
13:36:05 <jmcarthur> ira: does this state need to be persistent? if so, it will need to be saved to the hard drive, which is definitely IO
13:36:06 <RDx_> okay, figured as much
13:36:08 <Cale> So A -> B -> C -> D means A -> (B -> (C -> D))
13:36:09 <Younder> ahh that
13:36:15 <RDx_> oh
13:36:29 <ira> jmacarthur: indeed
13:36:30 <Cale> RDx_: All functions in Haskell really only have exactly one parameter
13:36:33 <RDx_> Cale: thats backwards though, parenthesis is solved first
13:36:41 <RDx_> Cale: oh. what
13:36:42 <mauke> ...
13:36:44 <ira> I was actually thinking about TCache for this
13:36:52 <Cale> RDx_: Those which appear to have more are just returning other functions
13:37:02 <RDx_> I see
13:37:04 <Younder> yes the lack of a clean return type (It is always the last element) is also an issue
13:37:08 <Cale> RDx_: When you write  f x y z  it means  ((f x) y) z
13:37:23 <ira> but I'm not even that far along yet... haven't nailed down a basic approach
13:37:44 <RDx_> Cale: in the function neverFollows
13:37:53 <RDx_> Cale: say I have x y zs = , now what
13:38:03 <mauke> then you program
13:38:09 <RDx_> am i putting this in one long thing, or do i have let's and in's
13:38:16 <RDx_> mauke, Cale , I am not sure what to do next
13:38:22 <RDx_> at all.
13:38:26 <Cale> RDx_: It depends on how you want to define it.
13:38:34 <RDx_> recursively? Idk
13:38:37 <Cale> RDx_: You may also want to pattern match on the structure of the list
13:38:46 <Cale> neverFollows x y [] = ...
13:38:50 <Cale> neverFollows x y (z:zs) = ...
13:38:53 <RDx_> pattern matching, i saw that in the leranyouahaskell
13:39:07 <RDx_> Cale: ... ok, decisions hmmmmmm
13:39:10 <Cale> You could also use guards, for example
13:39:16 <Cale> neverFollows x y (z:zs) | x == z = ...
13:39:16 <Younder> Haskell grows on you though. It is really quite beutiful. (For math lovers)
13:39:19 <RDx_> say i used x y [] , now I know i'm using a list
13:39:25 <Cale>                         | otherwise = ...
13:39:34 <RDx_> how would I make this work now
13:39:47 <Cale> Well, what should the result of  neverFollows x y []  be?
13:40:04 <RDx_> i want to make it return true if x occurs in the list but only if y doesn't follow x
13:40:11 <Cale> For example, what is  neverFollows 1 2 [] ?
13:40:28 <Younder> well haskell uses algebraic patern matching..
13:40:28 <RDx_> so fi i have neverFollows(1, 2, [1,1,3,4,1,2,5]) then it is probably false
13:40:52 <Cale> RDx_: You should get away from writing the parameters in a tuple like that
13:41:02 <RDx_> cale, i dont even know how i would call it so i dont know what neverFollows 1 2 p[ is.
13:41:04 <Cale> RDx_: In Haskell, we write the parameters separated by spaces
13:41:16 <RDx_> Cale: example
13:41:31 <Cale> RDx_: I'm just asking you what the function you want to define does when I pass it an empty list
13:41:42 <Cale> RDx_: It's your function, you get to decide that.
13:41:44 <Younder> []
13:41:55 <RDx_> Cale: well it neeeds a condition to deal with an empty list probably
13:42:05 <Cale> RDx_: yes, that's what this part of the definition is.
13:42:14 <Cale> neverFollows x y [] = ...
13:42:15 <RDx_> Cale: but i dont kno how to write that kind of condition in haskell, maybe i do neverFollows _ _ [] = _
13:42:30 <Cale> The ... will be what the function evaluates to when given an empty list.
13:42:34 <Younder> sucks
13:42:38 <Cale> Younder: ?
13:43:08 <RDx_> Cale, true then
13:43:13 <Younder> to many noops makes it inefficient
13:43:14 <Cale> Okay
13:43:17 <Cale> neverFollows x y [] = True
13:43:24 <Cale> Younder: what?
13:43:44 <Cale> Younder: (are you talking about this program)
13:43:45 <Younder> Cale, You are doing mahing here yes
13:43:51 <Cale> mahing?
13:43:52 <Younder> matching
13:43:55 <aug_triad> I have never tried to do bindings for Haskell with a C library, so I'm not sure what to do... I have posted relevant code and error here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11280#a11280. Can anybody help me solving these problems?
13:44:18 <RDx_> Cale: neverFollows x y [x,y] = False ? is there a better way to account for all the conditions possible
13:44:23 <RDx_> some kind of recursive technique I am missing
13:44:32 <RDx_> I need some lets and ins in here somewhere, probably, most definitely
13:45:00 <Vanadium> let is overrated
13:45:03 <Cale> Younder: I don't know what your concern about efficiency is here, but if it's what I think it is, then using a helper function here would provide only a small improvement and probably be confusing to RDx_, so I'm not going that way :)
13:45:14 <Cale> RDx_: Okay
13:45:25 <Cale> RDx_: Let's try to handle all the nonempty lists at once.
13:45:34 <Cale> RDx_: Maybe we can't do that, but let's try anyway
13:45:46 <RDx_> Cale: lets do it
13:45:55 <Cale> neverFollows x y (z:zs)
13:46:02 <Younder> Cale, I'll roll with that
13:46:20 <Cale> Here, the notation (z:zs) means a nonempty list whose first element is z and whose tail (which may or may not be empty) is zs
13:46:47 <crutcher> I'm having problems compiling ghc that have shown up in the last week. Was there a recent change that keeps head from compiling with the old 6.8 series as the bootstrap?
13:46:55 <Cale> RDx_: Suppose that it happens that x == z
13:47:03 <RDx_> okay i'm supposing
13:47:06 <RDx_> does it crash
13:47:07 <Cale> RDx_: What would we have to check?
13:47:13 <RDx_> we'd have to check if y follows it
13:47:30 <Cale> RDx_: By follows, do you mean "is the next element" or "is anywhere in the rest of the list"?
13:47:35 <crutcher> specifically, I'm seeing this: ompiler/specialise/SpecConstr.lhs:56:7: Could not find module `Data.Data':
13:47:44 <RDx_> next element
13:47:49 <Cale> ah, okay
13:47:58 <RDx_> thats an assumption
13:48:05 <Cale> In that case, we'll want to pattern match on the following element of the list too
13:48:21 <Cale> So we'll define
13:48:29 <Vanadium> :I
13:48:35 <Cale> neverFollows x y (z:z':zs)
13:48:43 <Cale> So here, z is the first element of the list
13:48:47 <Cale> z' is the next one
13:48:51 <Cale> and zs is the rest
13:48:56 <RDx_> why z' why jsut not another variable name
13:49:09 <Cale> Well, z' is just another variable name
13:49:11 <RDx_> okay, cool
13:49:25 <Cale> I could use w or something
13:49:26 <skorpan> z's dead baby... z's dead.
13:49:27 <lambdabot> skorpan: You have 1 new message. '/msg lambdabot @messages' to read it.
13:49:27 <RDx_> so now we are accounting for the head, another variable, and the end
13:49:30 <RDx_> ?
13:49:46 <Cale> The head, the head of the tail, and the tail of the tail
13:49:52 <RDx_> oh ok
13:50:09 <RDx_> so right now what does it think of everything else in the list, if there were 4 or more items
13:50:11 <Cale> It's the same as z:(z':zs)
13:50:20 <RDx_> Cale: i understand
13:50:36 <Cale> If it matches the list [1,2,3,4], then z = 1, z' = 2, zs = [3,4]
13:51:07 <Cale> Notice, this pattern only matches lists of length 2 or more
13:51:18 <Cale> So we'll have to go back and add in a pattern for lists of length 1
13:51:32 <RDx_> neverFollows x y [] = True and this is for zero ?
13:51:37 <Cale> yeah
13:51:57 <RDx_> lets do 1
13:51:58 <mmorrow> RDx_: more clear might be
13:51:58 <Cale> neverFollows x y [z] = ...  -- for lists of length 1 (probably True)
13:52:06 <mmorrow> neverFollows _ _ [] = True
13:52:13 <Cale> I prefer to name the variables
13:52:32 <mmorrow> i like indicating that they don't matter
13:52:49 <mmorrow> to each his own
13:52:54 <Younder> You are sying 'don't care'
13:53:00 <Younder> which is fine
13:53:07 <Baughn> And following on my earlier success, a 700-line program worked on /second/ try. 256/8 is not 16, but the rest was perfect. I love haskell - I should write some advocacy about this.
13:53:10 <Cale> If there's any confusion about it, that might be a good idea, but here the definition is short enough that it's obvious we're not using them :)
13:53:19 <RDx_> mmorrow: , i wrote neverFollows _ _ [] as a condition earlier
13:53:37 <mmorrow> Cale: i really meant though in this case it might be more clear to RDx_ himself
13:53:44 <mmorrow> RDx_: ah, nice
13:53:50 <Cale> RDx_: Yeah, if you don't use a variable which you're matching, you can always replace it with _
13:53:59 <RDx_> =]
13:54:00 * Zao shakes a tiny fist at Ubuntu GHC packagers.
13:54:05 <Cale> RDx_: Which is a wildcard that matches anything and doesn't bind a variable
13:54:07 <Twey> Baughn: Second compile, or second run?
13:54:08 <RDx_> Cale: so for the 1 condition
13:54:14 <Zao> Does anyone know the rationale for splitting it into a bazillion packages?
13:54:32 <Cale> Zao: Don't use the Ubuntu GHC packages.
13:54:33 <RDx_> I would do.... neverFollows x y [] = [z] ?, i dont know
13:54:39 <Baughn> Twey: Second run. I've lost count of the number of attempted compiles. :P
13:54:45 <RDx_> [zs] -> true
13:54:51 <sjanssen> Cale: the Ubuntu packages are up to date now, that's not particularly great advice
13:54:52 <Twey> Ah, yes :þ
13:54:53 <Cale> Zao: Aside from being split into a million tiny pieces, they're horribly out of date.
13:54:58 <Baughn> Zao: Policy inherited from Debian. "If you can split it, do so."
13:54:58 <Zao> Cale: 6.10.4
13:55:05 <Cale> Zao: Oh, are you on koala?
13:55:09 <Zao> Yes.
13:55:22 <Cale> Heh, then it'll only be out of date in a little while then
13:55:27 <sjanssen> Zao: they're split into several packages because that's how GHC is distributed now
13:55:34 <Younder> I'm Ubuntu
13:56:01 <lament> I'm a human, nice to meet you
13:56:04 <anonym> Hi Ubuntu, how are you?
13:56:06 <Cale> sjanssen: 6.12 is coming out soon. Want to take bets on whether they upgrade to it? :)
13:56:22 <RDx_> I had a conversation with a bot yesterady
13:56:26 <sjanssen> Cale: it should hopefully be less laggy now that we've got more responsive Debian packagers
13:56:26 <Zao> Cale: I figured I'd install the base ghc via the package system so I get the relevant dependencies.
13:56:33 <Younder> haha, I use Ubuntu
13:56:34 <RDx_> I asked it if it was a human and it told me to wait for the humans
13:56:52 <Cale> RDx_: neverFollows x y [z] = ...
13:56:53 <Vanadium> hooray for team gentoo-haskell
13:56:54 <Younder> I am very human
13:57:04 <RDx_> Cale:  = what?
13:57:08 <Cale> RDx_: Here, [z] is a list of length 1 with a single element which we're calling z
13:57:14 <sjanssen> Cale: being a bit behind major GHC releases is a good thing for most people, IMO.  Less tinkering to make packages work
13:57:18 <Zao> Vanadium: Last I tried g3nt00, it had a similiar split.
13:57:31 <Cale> RDx_: Since it's only a list of length 1, there's no way that x could follow y in it, right?
13:57:40 <RDx_> Cale: I didn't realize you could just use variables all willy nilly like that
13:57:45 <RDx_> so = true?
13:57:50 <Younder> well my chatterbot has stood in for me at some times. (noone noticed!)
13:57:50 <Cale> True
13:57:51 <Cale> yeah
13:57:56 <Cale> (watch the capitalisation)
13:58:04 <RDx_> okay
13:58:06 <Younder> I am good at AI
13:58:11 <Vanadium> Zao: By the time I became interested in haskell, I had already installed ghc and all relevant libraries somehow. And at least the packages are somewhat up to date.
13:58:12 <RDx_> Cale: I've got it right in my script
13:58:20 <Cale> So, now we'll finally deal with the 2-or-more case
13:58:25 <RDx_> Cale: okay , so for a more filled list, of 2 or greather that we were working on
13:58:29 <RDx_> v
13:58:31 <RDx_> neverfollows x y z:(z':zs) =
13:58:41 <Cale> Make that (z:z':zs)
13:58:42 <Vanadium> You need the parens around the entire : construction, not the last two
13:58:47 <RDx_> there is going to be some recursion in here
13:58:56 <Cale> Or if you want to put more parens, (z:(z':zs))
13:59:02 <Cale> But the outer parens are needed
13:59:43 <Cale> (the inner ones are implied by the way that : associates)
14:00:06 <RDx_> okay, lets work on the logic of it
14:00:10 <Cale> okay
14:00:16 <RDx_> it needs to traverse the list somehow
14:00:25 <RDx_> i dont know how its supposed tod o that
14:00:28 <Cale> Don't worry about traversing.
14:00:36 <RDx_> this isnt C++
14:00:45 <Cale> We're going to reduce the problem to neverFollows x y (some list which is smaller)
14:00:47 <RDx_> its not like i keep forgetting, its just thats the problem
14:00:56 <RDx_> okay how is that done
14:01:13 <RDx_> by placing x y into [z:z'] ?
14:01:32 <Cale> If the result is going to be True, then either x == z and y == z'
14:01:37 <RDx_> because that would make since, actually. still dontt know the syntax
14:01:45 <Cale> Or, x will follow y somewhere later in the list
14:01:53 <Cale> Right?
14:02:02 <RDx_> x can follow y
14:02:07 <RDx_> y can't follow x
14:02:11 <Cale> If x follows y somewhere, either it happens right at the beginning, or somewhere els.e
14:02:23 <Cale> Oh, sorry, got that backward, yeah
14:02:23 <RDx_> anywhere
14:02:32 <RDx_> okay
14:02:53 <Cale> (I think it would make more sense to keep them in order, but we can do it however you like :)
14:03:03 <RDx_> how is this written?
14:03:23 <RDx_> if [z] != [z'] in case of x soemthin somethin
14:03:27 <RDx_> i have no idea of the syntax
14:03:36 <Cale> Well, we have logical operators || and &&
14:03:51 <Cale> So...
14:04:10 <Vanadium> Your != is /=
14:04:22 <RDx_> Vanadium: thanks for the heads up
14:04:23 <Cale> neverFollows x y (z:z':zs) = (x == z' && y == z) || ...
14:04:27 <RDx_> Cale: thanks for all the help thus far
14:04:32 <RDx_> okay
14:04:33 <Cale> RDx_: no problem
14:04:40 <Vanadium> Cale: I think that is supposed to be negated
14:04:43 <Cale> er
14:04:44 <Cale> yes
14:04:46 <Cale> heh
14:04:50 <Younder> Sloow
14:04:59 <Cale> Younder: slow?
14:05:06 <Younder> I'll take a snoze
14:05:16 <RDx_> Younder: always a spectator
14:05:17 <Vanadium> We will make up for it with -O2
14:05:27 <Cale> neverFollows x y (z:z':zs) = not (x == z' && y == z) || ...
14:05:38 <RDx_> i didn't realize haskell used not like that
14:05:42 <RDx_> i wonder if hugs cares
14:05:52 <Cale> not is just an ordinary function
14:05:52 <RDx_> because some things, a LOT of things make hugs error
14:05:57 <Cale> It's defined like
14:05:57 <RDx_> okay, cool
14:06:01 <Cale> not True = False
14:06:04 <Cale> not False = True
14:06:07 <Vanadium> Cale: I think you want && at the end too?
14:06:15 <Cale> mm... you're right
14:06:23 <Cale> neverFollows x y (z:z':zs) = not (x == z' && y == z) && ...
14:06:29 <RDx_> Cale: i understand the logical stuffs , just didn't realize its synthax
14:06:34 <Cale> Of course, we can simplify this using DeMorgan's laws too
14:06:37 <hgolden> crutcher
14:06:43 <Cale> neverFollows x y (z:z':zs) = (x /= z' || y /= z) && ...
14:06:46 <RDx_> we could
14:06:48 <RDx_> or
14:06:49 <Younder> RDx_, You might like Formula
14:07:32 <RDx_> so that && would be ( x ==z && y ==z')
14:07:39 <RDx_> Younder: maaaaybe
14:08:00 <Vanadium> RDx_: would it?
14:08:13 <RDx_> Vanadium: yep.
14:08:22 <Vanadium> I am confused.
14:08:25 <Vanadium> Is x not allowed to follow y?
14:08:29 <Vanadium> Or y not allowed to follow x?
14:08:35 <RDx_> y is not allowed to follow x
14:08:57 <Vanadium> Then what Cale posted is backwards, isn't it?
14:09:13 <RDx_> ....
14:09:14 <m0nkfish> Couldn't match expected type `Int -> [[Int]]'
14:09:14 <m0nkfish> against inferred type `[[t]]'
14:09:16 <RDx_> Cale: ?
14:09:18 <m0nkfish> what does this error imply
14:09:35 <Vanadium> m0nkfish: That you gave it a list of some lists and it wanted a function instead
14:09:45 <Vanadium> Or possibly that you gave a function too many arguments
14:10:12 <Vanadium> RDx_: Well, does (x /= z' || y /= z) check for your requirement?
14:10:28 <RDx_> Vanadium: oh, see i am not even sure that was the whole logic behind it
14:10:45 <RDx_> Vanadium: i dont think that has to do with their values right
14:10:51 <Cale> Hm?
14:10:56 <Vanadium> We are comparing the values of x, z', y and z
14:11:02 <RDx_> example neverFollows(1, 2, [1, 1, 3, 4, 1, 2, 5,]) ought equal false
14:11:13 <RDx_> because 1 is followed by 2, and 2 is y
14:11:15 <Younder> sorry for my arrgant bullshit, I'm afraid it is just me
14:11:29 <m0nkfish> hmmmm i got rid of currying and it worked
14:11:35 <m0nkfish> i mean my use of currying
14:11:51 <m0nkfish> this works: pascal n = [1] : pascaux [] n
14:11:57 <Vanadium> RDx_: So is what Cale did right?
14:11:58 <m0nkfish> this doesnt: pascal = [1] : pascaux []
14:12:17 <Cale> (I am not actually sure that what I did was right)
14:12:27 <RDx_> Cale: Vanadium : i dont know.. by saying that condition what does it even do
14:12:32 <Cale> (since I'm not sure what the actual definition of the function is)
14:12:36 <RDx_> I am coding it, I just didn't know if that was the whole condition
14:12:49 <Cale> neverFollows x y zs is supposed to mean that y never immediately follows x in zs?
14:12:56 <Younder> ok you are askig for it
14:12:57 <xenoblitz> has anyone ever met this error? http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=4490#a4490
14:13:03 <RDx_> Younder: yes, i want to understand it
14:13:10 <RDx_> Younder: I can stare at examples all day, and i get nowhere
14:13:17 <RDx_> @hpaste
14:13:17 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:13:32 <Vanadium> x /= z' || y /= z is the same as (x /= z') || (y /= z)
14:13:44 <Vanadium> where the /= stands for "is not equal to" and || is "or"
14:13:48 <RDx_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4491#a4491
14:13:55 <RDx_> Cale: Vanadium : Younder ^
14:13:59 <Cale> xenoblitz: First of all, if you have cabal install, you should never use Setup.hs directly like that
14:14:15 <Vanadium> RDx_: Does that make sense?
14:14:19 <Cale> xenoblitz: Just run cabal install from the directory in which the .cabal file is
14:14:21 <Vanadium> I mean, do you understand what /= and || accomplish there?
14:14:23 <Cale> (with no other parameters)
14:14:26 <RDx_> Vanadium: yes
14:14:30 <RDx_> I understand that logic
14:14:35 <Vanadium> Okay, so is it doing the right thing for your problem statement? :)
14:14:51 <Cale> xenoblitz: Secondly, perhaps there are some old .o or .hi files confusing things?
14:14:57 <RDx_> Vanadium: i dont understand haskell functions in general. I get that its a condition, i just thought something else was ocming after that
14:14:57 <Lemmih> m0nkfish: 'pascal' is calling ':', not 'pascaux'.
14:15:10 <Vanadium> RDx_: Yeah, the recursive step will come after that
14:15:11 <xenoblitz> Cale: when I tried that I am getting another weird error
14:15:14 <xenoblitz> let me update
14:15:24 <RDx_> Vanadium: okay, yes it satisfies the condition
14:15:25 <RDx_> i believe
14:15:26 <Cale> RDx_: We're defining the Bool value which is the result of the function in the case that the list has two or more elements
14:15:30 <RDx_> okay
14:15:43 <Cale> RDx_: We will define it in terms of the result of the function when applied to a smaller list
14:15:47 <xenoblitz> Cale: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=4490#a4492
14:16:00 <RDx_> okay lets do it
14:16:01 <m0nkfish> Lemmih can i tell it not to
14:16:02 <Cale> RDx_: Specifically, imagine that we already know whether  neverFollows x y (z':zs) is True or False
14:16:14 <RDx_> okay
14:16:25 <spink> Hi, I want to create a Symmetric 2D imuttable array of Ints with known bounds (n,n), to which the main diagonal is 0, values of some elements are in a list of tuples with the form [(i,j,val_ij)] and the rest of the array elements are a big number. Any ideas on how to do that ?
14:16:27 <Cale> RDx_: We can use that value to decide what  neverFollows x y (z:z':zs)  ought to be
14:16:32 <Lemmih> m0nkfish: pascal = (:) [1] (pascaux []). It can't tell that you want additional parameters to go to the second argument of ':'.
14:17:04 <m0nkfish> it didnt like that
14:17:24 <m0nkfish> pascaux takes 2 parameters
14:17:25 <Cale> spink: Construct a list of all the ((i,j),val_ij) pairs and call array on it
14:17:43 <Lemmih> m0nkfish: Right. So you have to give it two.
14:18:11 <m0nkfish> no you dont
14:18:25 <Lemmih> m0nkfish: I was trying to explain why only giving it 1 didn't make sense.
14:18:28 <xenoblitz> Cale: does that error even make sense?
14:18:39 <zzx> is there a chatroom for c programming help?
14:18:42 <m0nkfish> ok i see
14:18:45 <Younder> yes
14:18:46 <m0nkfish> zzx: #c
14:18:58 <zzx> thanks you!
14:19:05 <Lemmih> m0nkfish: You /could/ do: pascal = (:) [1] . pascaux []. But that's not very pretty.
14:19:29 <spink> Cale, how do I make an array from a list ?
14:19:37 <Cale> zzx: ##C
14:19:37 <Cale> xenoblitz: oh...
14:19:38 <m0nkfish> what is the dot operator?
14:19:49 <Zao> @src (.)
14:19:49 <lambdabot> (f . g) x = f (g x)
14:19:54 <RDx_> ahhh why doesnt this make sense to me
14:20:04 <Zao> Function composition, if that's the one.
14:20:09 <RDx_> I just figured it would have clicked by now
14:20:14 <Cale> spink: if xs is a list of ((i,j),v) which you want to build the array from, then  array ((0,0),(n,n)) xs
14:20:24 <Cale> or ((1,1),(n,n)) perhaps
14:20:39 <Cale> (whatever the smallest and largest indices are)
14:20:51 <Cale> RDx_: Are you familiar with recursion?
14:21:12 <Cale> RDx_: If you want, we can take an entirely different approach to defining this function.
14:21:13 <RDx_> Cale: yes, but not in haskell lol. i see the page i still dont know what to do for this
14:21:18 <RDx_> Cale: no lets do this
14:21:19 <Younder> I think I'll just listen to the music 'Uriah heep -easy living'
14:21:31 <Cale> RDx_: there's a way to define it without recursion
14:21:48 <Cale> But it's probably a good idea to understand the recursive way too
14:22:00 <RDx_> cale: so we'd to neverFollows [zs] ++ [z]
14:22:04 <RDx_> ?
14:22:08 <Younder> the recursive way  is slow
14:22:08 <Cale> hm?
14:22:09 <RDx_> or do i need to supply all its paraters
14:22:14 <Cale> Younder: no it isn't
14:22:15 <spink> Cale, (1,1),(n,n) is fine, thanks going to give it a shots. My idea for maybe going faster was to make the indices run from 1..n and assign the values to the array with a funtionc thats checks the lists for an element and returns it's value etc.. but symmetry is killing me
14:22:16 <RDx_> i am trying to write the function
14:22:33 <Cale> Younder: It has the exact same complexity as every other way of computing this function
14:22:49 <Cale> Younder: apart from those which really are slower because they do something silly
14:23:05 <Younder> it is tail recursive i suppose (not!)
14:23:11 <Vanadium> RDx_: You mean the function call?
14:23:16 <SamB_XP> Younder: that *really* sounds silly ;-P
14:23:22 <RDx_> Vanadium: I am still rying to define this turkey
14:23:30 <Vanadium> RDx_: ++ is list concatenation, we should not need it here
14:23:31 <RDx_> *trying
14:23:33 <SamB_XP> RDx_: for thanksgiving ?
14:23:40 <Cale> spink: You might just start with an array which is entirely filled with that background value and use the // operator to do an immutable update.
14:23:44 <RDx_> SamB_XP: hurr hurr
14:23:51 <SamB_XP> I really don't think that's the best way to make a thanksgiving feast ...
14:23:54 <Cale> spink: Maybe *slightly* slower, but it would be easier to write
14:24:07 <lvh> hi :-)
14:24:08 <SamB_XP> ... the binary-to-flavour converters are pretty lousy atm
14:24:16 <Cale> Younder: It's not tail recursive, it's better. :)
14:24:30 <Cale> Younder: You absolutely don't want a tail recursive function here.
14:24:37 <Younder> It sucks
14:24:44 <spink> Cale, thanks again :)
14:24:48 <Cale> Younder: If you think that you do, you're too used to strict evaluation
14:24:49 <RDx_> i am going to have to go soon
14:25:01 <xenoblitz> so no one can help :/ http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=4490#a4492 ?
14:25:06 <Vanadium> Do you just want a working definition at this point?
14:25:11 <RDx_> Vanadium: I do
14:25:36 <Vanadium> But all the pieces are there :(
14:25:37 <Cale> xenoblitz: I would have an easier time helping you if I could connect to hackage... my router is being annoying atm, and needs to be reset.
14:25:42 <Vanadium> RDx_:
14:25:56 <Vanadium> neverFollows x y (z:z':zs) = (x /= z || y /= z') && neverFollows x y (z':zs) -- I think this works
14:26:06 <Cale> xenoblitz: Sometimes cabal chooses a really stupid way of reporting dependency issues.
14:26:09 <RDx_> Vanadium: I never would have thought of that
14:26:15 <Cale> xenoblitz: which hides the real problem
14:26:25 <Cale> RDx_: really?
14:26:46 <xenoblitz> Cale: oh :/
14:27:24 <Cale> xenoblitz: But the cabal install error is much more sensible to deal with than the other one
14:27:44 <RDx_> Vanadium: now I am trying to call it
14:28:01 <RDx_> with (1, 2, [1, 2]) and it think I have given it characters
14:28:13 <RDx_> winhugs, *** Term           : (1,2,[1,1,3,4,1,2,5]) *** Type           : (a,b,[c]) *** Does not match : Integer
14:28:15 <xenoblitz> Cale: would it help you if I pasted the cabal file being used?
14:28:26 <Vanadium> Can you show the type signature you put again?
14:28:30 <Younder> Now that is beutiful
14:28:39 <RDx_> Vanadium: : neverFollows:: Integer -> Integer -> [Integer] -> Bool
14:28:40 <Vanadium> oh oh oh
14:28:45 <Cale> xenoblitz: dcoutts would be better at solving a problem like this than I would, but sure
14:28:48 <Vanadium> you are not allowed to put () around arguments or , inbetween them
14:28:56 <SamB_XP> RDx_: whoa, watch it with the type!
14:29:08 <RDx_> what
14:29:13 <SamB_XP> what's with all those Integers?
14:29:15 <Cale> RDx_: Call the function in the same way we defined it
14:29:22 <Cale> RDx_: neverFollows 1 2 [1,2]
14:29:34 <SamB_XP> you remind me of the Haskell 98 comittee in some way ...
14:29:39 <Cale> RDx_: none of the spurious parens and commas :)
14:29:49 <Younder> rotfl
14:29:56 <xenoblitz> Cale: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=4490#a4493 and thanks still for your help whether you manage or not
14:29:58 <RDx_> neverFollows 1 2 [1, 3]  Program error: pattern match failure: neverFollows 1 2 [1,3]
14:30:17 <RDx_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4491#a4494
14:30:18 <Vanadium> Did we define the cases for lists with zero or one element?
14:30:18 <RDx_> revision 1
14:30:26 <RDx_> Vanadium: yes, see
14:30:27 <Vanadium> We did :o
14:30:30 <SamB_XP> whoa ... how the heck does it know what the pattern match failure is called by ?
14:30:34 <SamB_XP> er. caused by ?
14:30:47 <RDx_> beats me
14:30:53 <Cale> SamB_XP: it's hugs
14:30:59 <SamB_XP> wow
14:31:04 <SamB_XP> I wish GHC knew that trick
14:31:07 <RDx_> hugs is an omnierror producting program
14:31:08 <Younder> lol
14:31:18 <SamB_XP> seriously!
14:31:24 <Cale> However, if that's really your source file, you should not be getting that error
14:31:32 <RDx_> -_-
14:31:36 <Cale> So, :re to make sure you're up to date
14:31:44 <Cale> Or :l myfile.hs
14:31:47 <Younder> OK, use GHC instead
14:32:06 <RDx_> Younder: not an option
14:32:07 <Vanadium> It says neverfollows
14:32:11 <Cale> oh!
14:32:13 <Younder> By far the best Haskell compiler
14:32:14 <Cale> haha
14:32:15 <Cale> yes
14:32:24 <Vanadium> Make that a proper F and it ought to work
14:32:29 <Cale> RDx_: you misspelled neverFollows on the last line
14:32:31 <RDx_> you're right
14:32:32 <RDx_> i see it
14:32:34 <RDx_> got me.
14:32:45 <RDx_> thank you it works
14:32:54 <RDx_> can you explain how neverFollows x y (z:z':zs) = (x /= z || y /= z') && neverFollows x y (z':zs) works
14:33:12 <Vanadium> RDx_: There are two possibilities for x to follow y in the list
14:33:22 <Vanadium> RDx_: Either z and z' are x and y, respectively
14:33:25 <Cale> xenoblitz: Is this scion straight off of hackage, or should I download it from somewhere if I want to try installing it myself?
14:33:27 <Vanadium> or it follows somewhere later
14:33:46 <Vanadium> So the part before the && checks z and z' and the part afterwards does the whole recursion thing
14:34:25 <RDx_> can you walk me through a small list, kind of like we're debugging it
14:34:31 <Vanadium> Sure
14:34:33 <RDx_> how does neverFollows 1 2 [1, 2, 3] work
14:34:53 <xenoblitz> Cale: that is straight off hackage... I would actually wish to install the latest from here http://github.com/nominolo/scion but its giving me missing references... I was told to install the hackage one and then the one in the github to make scion work
14:34:59 <Vanadium> It goes into the two-elements case and x=1, y=2, z=1, z'=2, zs=[3]
14:35:42 <Vanadium> then it finds that x /= z is False (because 1 == 1) and y /= z' is False as well, so the entire || expression evaluates to False
14:35:46 <Cale> xenoblitz: Unfortunately, I'm still on 6.10.3, so I may not run into the same issue, but I'll try it.
14:35:58 <Vanadium> Therefore we are done and the recursive part is now even entered, and the function returns False
14:36:22 <Cale> neverFollows 1 2 (1:2:3:[])
14:36:33 <RDx_> okay
14:36:42 <Cale> -> (1 /= 1 || 2 /= 2) && neverFollows 1 2 (2:3:[])
14:36:59 <Cale> -> (False || 2 /= 2) && neverFollows 1 2 (2:3:[])
14:37:11 <Cale> -> (2 /= 2) && neverFollows 1 2 (2:3:[])
14:37:16 <m0nkfish> how can i remove any empty lists from a list
14:37:18 <Cale> -> False && neverFollows 1 2 (2:3:[])
14:37:23 <Cale> -> False
14:37:37 <Cale> m0nkfish: filter (not . null)
14:37:37 <Berengal> m0nkfish, filter (not.null)
14:37:42 <m0nkfish> thanks guys
14:38:05 <Cale> RDx_: I showed the actual reduction steps that it would take in evaluating
14:38:08 <RDx_> thanks Cale
14:38:24 <Cale> RDx_: Note that it actually doesn't make the recursive call at all
14:38:31 <Cale> (in this specific example)
14:38:49 <Cale> Because the very first two elements match the ones we're looking out for
14:39:00 <RDx_> i see
14:39:03 <Cale> If it were something like
14:39:13 <Cale> neverFollows 2 3 (1:2:3:[])
14:39:48 <Cale> -> (2 /= 1 || 3 /= 2) && neverFollows 2 3 (2:3:[])
14:39:56 <Cale> -> (True || 3 /= 2) && neverFollows 2 3 (2:3:[])
14:40:02 <Cale> -> True && neverFollows 2 3 (2:3:[])
14:40:07 <Cale> -> neverFollows 2 3 (2:3:[])
14:40:14 <Younder> logic gone awry
14:40:21 <Cale> and now it recurses
14:40:56 <Cale> -> (2 /= 2 || 3 /= 3) && neverFollows 2 3 (3:[])
14:41:12 <Cale> -> (False || 3 /= 3) && neverFollows 2 3 (3:[])
14:41:19 <Cale> -> (3 /= 3) && neverFollows 2 3 (3:[])
14:41:25 <Cale> -> False && neverFollows 2 3 (3:[])
14:41:30 <Cale> -> False
14:41:38 <RDx_> Cale:  is there such a thing as a haskell debugger or are you it
14:42:06 <Cale> I'm just doing that by hand in the way that you might calculate things in a highschool algebra class, by replacing functions with their definitions
14:42:42 <Cale> @src (||)
14:42:42 <lambdabot> True  || _ =  True
14:42:42 <lambdabot> False || x =  x
14:42:45 <Cale> @src (&&)
14:42:46 <lambdabot> True  && x = x
14:42:46 <lambdabot> False && _ = False
14:43:03 <RDx_> i see
14:43:06 <RDx_> Cale, I have to go
14:43:11 <Cale> See you around!
14:43:13 <RDx_> thank you everyone, cale, Vanadium
14:43:17 <RDx_> mauke:
14:43:23 <RDx_> cheers
14:43:27 <Younder> bye'
14:44:18 <Younder> recursive processing is difficult for some
14:44:47 <Younder> gotta respect that
14:44:52 <Younder> rotfl
14:45:08 <Baughn> ..so I was testing Hermes' performance... and I used System.Random. Big mistake. Horrifyingly slow module, that one.
14:45:31 <Vanadium> Isn't everything in System slow?
14:45:39 <Baughn> Seriously, it took ~50x more time to generate some random numbers than it took to has, deserialize, decrypt, etc. them.
14:46:27 <Younder> There is pre monad and the post monad lib
14:46:40 <Younder> the post bit is much faster
14:46:57 <ClaudiusMaximus> realToFrac :: Double -> GLfloat is really slow too, in my experience
14:47:14 <Cale> Younder: everyone's got to start somewhere :)
14:47:35 <Berengal> Looping is also hard when you first encounter it
14:47:39 <Cale> yeah
14:48:03 <Berengal> I found it harder than recursion, but then I started to hit the stack limit...
14:48:04 <Cale> It's actually a heck of a lot less natural
14:48:18 <Berengal> And then a year later I learned haskell and started to use recursion again
14:48:27 <Cale> Well, both are much less natural than higher order functions
14:48:32 <Berengal> True
14:48:33 <ClaudiusMaximus> ..and i only needed that because System.Random was too slow and mersenne-random only generates Doubles
14:48:44 <Berengal> I use HOFs when they exist
14:50:33 <Cale> Normally if I want someone to make all my dishes clean, I just tell them to wash all the dishes, which is a heck of a lot closer to map wash dishes than it is to something like  for i from 0 to (length dishes - 1): wash dish[i]
14:50:55 <Younder> lol
14:51:14 <Cale> I suppose I *could* write labels on all the dirty dishes with dry erase marker, but nobody actually does that
14:51:18 <Younder> I hear that
14:51:41 <Berengal> Cale, well, you first need to tell them how to do someting with all the dishes
14:52:17 <Cale> Berengal: Sure, but the point is that language has found a convenient way to not have to explain this every time
14:52:42 <Berengal> That is, assuming we're talking about computers, not really washing dishes
14:52:49 <Cale> When you're explaining to a child, maybe you have to be more careful about what "all" means.
14:53:10 <Younder> or a computer
14:53:42 <Cale> But just like you can teach a child, you ought to be able to teach your computer. So we have standard definitions now in our libraries for things like map :)
14:53:43 <fnord123> Well if I'm telling someone how to do dishes I may not have to explain which order they do the dishes. Afterall a sink of dirty dishes is an unordered set.
14:53:54 <Cale> fnord123: indeed
14:54:03 <Cale> and map is nicely ambiguous about that
14:54:04 <Berengal> Cale, very true. I think much of the confusion around recursion comes from people who only use it when simple iteration isn't enough
14:54:16 <Cale> (though it does take a list in the standard case)
14:54:17 <fnord123> it's probably best to cluster dish types and wash porcelain (plates, bowls) and then glasses/cups, and then silverware/chopsticks
14:54:26 <Vanadium> ((If only map was the Functor method))
14:54:54 <Cale> (though it does take a list in the standard case)
14:54:57 <Cale> whoops
14:55:21 <sproingie> hm.  when you see something like a -> m a or b -> f b, m usually stands for "monad", f for "functor".  is there a more generic word that describes what both of those things are, generically?
14:55:37 <Baughn> sproingie: "Functor". :P
14:55:44 <Cale> sproingie: type constructors?
14:55:52 <Baughn> sproingie: Monads are applicative functors are functors. Or did you mean something else?
14:56:04 <Cale> sproingie: f and m are type variables which range over type constructors
14:56:06 <sproingie> so functor is as generic as it gets?
14:56:08 <EnglishGent> @hoogle (a -> b) -> IO a -> b
14:56:08 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:56:08 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:56:08 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
14:56:13 <Younder> Just got the last issue of 'Scientic Americain'. Later..
14:56:16 <sproingie> ah type variables
14:56:37 <Cale> sproingie: Functor is the most general definition from category theory which applies to those
14:56:39 <Baughn> sproingie: Well, there's also "type constructor", but that applies to very different things
14:56:51 <EnglishGent> how about 'arrows' ?
14:56:52 <sproingie> except just 'a' is also a type variable.  so Functor is as generic as it gets for a parameterized type variable then?
14:57:03 <EnglishGent> they are a more general concept (as I understand it)
14:57:04 <Cale> sproingie: welll....
14:57:05 <Berengal> EnglishGent, Arrow is a different type class
14:57:23 <Cale> sproingie: You don't have to insist that type constructors are in any particular typeclass
14:57:28 <sproingie> maybe i should just coin "warm fuzzy thing" :)
14:57:39 <Cale> sproingie: and there are other typeclasses which your type constructor might belong to
14:57:42 <Baughn> EnglishGent: Arrows are a generalization of functions.. as I understand it. They're different from functors.
14:57:43 <xenoblitz> Cale: I went back to 6.10.3 and so far it seems ok
14:57:45 <Younder> This might be a ggod time to study clssification theory
14:57:47 <Cale> For example, we might define
14:57:54 <Cale> class Cofunctor f where
14:58:05 <Cale>   cofmap :: (a -> b) -> f b -> f a
14:58:08 <Baughn> EnglishGent: Well, though since they're both from category theory there's probably some connection I'm unaware of.
14:58:37 <Younder> category theory is what I mean
14:58:53 <sproingie> what a weird fmap
14:59:10 <Berengal> It's not fmap, it's cofmap :)
14:59:11 <Vanadium> Do we need co$ to apply that?
14:59:19 <Baughn> Nope
14:59:22 <sproingie> how would that work, since the first function is a -> b?
14:59:38 <Baughn> sproingie: For example, the "f b" might be "function that takes a b and returns.. something"
14:59:49 <Baughn> sproingie: Then you hand cofmap a way to turn an a into a b
14:59:59 <Baughn> See?
15:00:02 <Vanadium> oooh.
15:00:03 <Cale> newtype Predicate a = P (a -> Bool)
15:00:11 <Cale> instance Cofunctor Predicate where
15:00:13 <Vanadium> Like the (-> r) functor, except (r ->)
15:00:18 <Baughn> Right, exactly
15:00:25 <Cale>   cofmap f (P q) = P (q . f)
15:00:29 <Baughn> You parametrize on the parameter instead of the return value
15:00:49 <Vanadium> That sounds p. clever
15:01:05 <Baughn> Vanadium: This kind of thing is why you never finish learning haskell. ^^;
15:01:16 <Younder> what confused me initilally was the concept of curry
15:01:26 <Baughn> It's food. You eat it.
15:01:39 <Younder> and lazy evaulation
15:02:45 <Younder> Then came monads
15:03:09 <sinelaw> question about parsec. parser p works, but when i use: p <|> q it doesn't parse anything
15:03:13 <Vanadium> I still suffer with lazy evaluation
15:03:17 <EnglishGent> I was thinking in terms of category theory Baughn :)
15:03:25 <Vanadium> sinelaw: ... what does it do?
15:03:38 <Younder> In all you have a whole lot of confusing concepts not seen in other languages
15:03:39 <mreh> has anyone used the statistic library to map a uniform dist to a gaussian?
15:03:48 <byorgey> sinelaw: note that Parsec is non-backtracking by default.  so if p consumes any input before it fails, q won't work.
15:03:57 <byorgey> sinelaw: you can fix this by saying  try p <|> q
15:04:15 <skorpan> so you can make parsec backtracking?
15:04:27 <sinelaw> byorgey, i know, tried that. i also don't currently care if q works. i'm surprised that by that simple change, p doesn't work
15:04:35 <sinelaw> skorpan, yes
15:04:43 <byorgey> sinelaw: oh, hm, that is strange.
15:05:12 <pao> can anyone explain the uvector vs uarray use cases?
15:05:25 <Younder> Anyone here read' Types and programming languages' by pierce
15:05:29 <sinelaw> byorgey, actually i have: many $ (p <|> q)
15:06:51 <Vanadium> Am I supposed to use parsec or parsimony or this uu stuff or whatever at this point? :<
15:07:01 <mreh> what was that?
15:07:50 <sinelaw> byorgey, if you said something i missed it :)
15:08:09 <mauke> a netsplit
15:08:22 <sinelaw> here's my parser
15:08:23 <Younder> all back!
15:08:25 <sinelaw> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11283#a11283
15:08:38 <skorpan> I THINK THERE WAS A NETSPLIT YOU GUYS
15:08:38 <Vanadium> Am I supposed to use parsec or parsimony or this uu stuff or whatever at this point? :<
15:08:53 <sinelaw> line 27 is where my problem is
15:09:19 <sinelaw> skorpan, YOU DON'T SAY
15:09:59 <pao> can anyone explain the merits of uvector vs uarray?
15:10:04 <byorgey> sinelaw: no, you didn't miss anything I said.
15:10:13 <byorgey> Younder: I've read it. why do you ask?
15:10:41 <Younder> Just wondered. Loved the book
15:10:55 <byorgey> yes, it's a great book =)
15:11:12 <Botje> pao: uvector allows for fusion
15:11:14 <skorpan> i barely understood anything in it
15:12:33 <pao> Botje: but uarray are more stable? right? so basically the are on par as far as memory efficiency and gc pressure, uvector is faster (becouse of fusion) while uarray is more stable, right?
15:12:36 <Cale> Another pretty example of a covariant functor is the coordinate ring functor for varieties.
15:15:06 <Botje> what do you mean by "more stable" ?
15:15:28 <Botje> uarrays will be more predictable, i guess
15:15:30 <Cale> To simplify things a bit, you can take subsets of R^n which are the solutions to (systems of) polynomial equations, and associate certain rings (systems of "numbers") with each one such that the geometry of the set of points and the algebraic properties of the ring reflect one another.
15:15:31 <sinelaw> wow...i have a runtime error from parsec: Text.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
15:15:42 * Botje boots quake live
15:15:48 <Cale> It turns out that a polynomial map between two varieties induces a ring homomorphism in the opposite direction between their corresponding rings.
15:15:59 <Younder> rings are slow
15:16:00 * sinelaw explodes
15:16:10 <tolkad> > 5
15:16:11 <lambdabot>   5
15:16:14 <Younder> go for groups
15:16:40 <Cale> Younder: okay, now I really know you're just trolling ;)
15:16:58 <copumpkin> he's been here for hours
15:17:22 <Younder> seriously more work has been done to optimize tensors
15:17:31 <copumpkin> an awfully slow troll
15:18:58 <Cale> Though, you are *right*.
15:18:59 <Cale> Most of the algorithms for rings have terrible asymptotics.
15:18:59 <Younder> cale: ?
15:19:18 <sproingie> one tensor to rule them all
15:19:41 <Tordek> is there a better way to apply k times a function to a value than (iterate f v) !! k?
15:19:52 <Cale> Like, what was the worst case bound for Buchberger's algorithm again?
15:20:12 <Cale> Something like multiply exponential or something? (Even though the average case is not nearly so bad)
15:20:16 <Tordek> (well, k+1, since it's 1-indexed and 1 is no applications)
15:20:45 <fnord123> Are terms like zygomorphism cromulent or did the author of the comonad reader make them up
15:20:45 <Tordek> uh, nm the last line
15:20:46 <dolio> He didn't make them up. Other people did.
15:20:57 * EnglishGent remembers Pressburger arithmetic as being the worst time-complexity he's seen
15:20:58 <Cale> He made up some of them
15:21:27 <EnglishGent> hello ManateeLazyCat :)
15:21:45 <dolio> He combined multiple names, in some cases, if that's what you mean.
15:22:14 <sproingie> zygomorphic apparently comes from biology
15:22:25 <ManateeLazyCat> EnglishGent: Hello.
15:22:49 <zygoloid> did someone cal... no
15:22:50 <zygoloid> aww
15:23:35 <Younder> Cale: If you agree, why do you call me a troll?
15:24:15 <mreh> > :t toU
15:24:16 <lambdabot>   <no location info>: parse error on input `:'
15:24:26 <copumpkin> mreh: [a] -> UArr a
15:24:27 <mreh> :t toU
15:24:28 <lambdabot> Not in scope: `toU'
15:25:25 <pao> Botje: more stable -> less buggy
15:26:08 <MyCatVerbs> pao: Not necessarily. They could just be well-entrenched bugs. :)
15:26:09 <Younder> I might not be a Haskell expert, but I am a Phd in mathematics same as many of you.
15:26:25 <pao> MyCatVerbs: nice to know :-)
15:26:53 <pao> can anyone suggest a good tutorial on uvector, stream fusione and stuff?
15:27:00 <pao> *fusion
15:27:12 <copumpkin> nope
15:28:33 <Botje> check out the blog post dons made about them
15:28:53 <Botje> hmm
15:28:58 <Botje> didn't he make one about it?
15:29:02 * Botje is shocked
15:29:23 <jfoutz> there's a paper.
15:30:40 <jfoutz> somewhere....
15:30:55 <jokerGTA> hi guys....can anyone help me with this function http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4495#a4495
15:30:58 <jfoutz> oh! http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
15:31:06 <jokerGTA> i found it and want to try to understand how it works
15:31:26 <pao> jfoutz: I'll try to read it, thanks
15:31:38 <jokerGTA> why when i do this     parse parseInt 2 it doesnt work
15:31:52 <mauke> jokerGTA: probably because it's a typ error
15:31:56 <mauke> what's the type of parse?
15:32:08 <jokerGTA> well i dont know :)
15:32:09 * glguy imagines you would at least need "2"
15:32:16 <mauke> jokerGTA: why not?
15:32:21 <jokerGTA> i am trying to ;learn about parser
15:32:28 <mauke> what parser?
15:32:30 <jokerGTA> found this function online and trying to see how it works
15:32:39 <mauke> what library is this?
15:32:43 <jokerGTA> parsec
15:33:21 <jokerGTA> import Text.ParserCombinators.Parsec
15:33:55 <jokerGTA> even to point me to some step by step tutorial would be very helpfull
15:34:47 <mauke> jokerGTA: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
15:35:21 <jokerGTA> thanks mauke
15:39:38 <hackagebot> arbtt 0.4.2 - Automatic Rule-Based Time Tracker (JoachimBreitner)
15:41:46 <sinelaw> how can i limit the number of expected repetitions (i.e. maybe) in parsec?
15:41:59 <sinelaw> i meant many
15:43:11 <sinelaw> ok, count
15:43:54 <sinelaw> nope, that's not good. i want "up to X occurrences"
15:44:29 <pao> for the record.... this seems really relevant for uvector ... http://www.galois.com/~dons/slides/08-07-stewart.pdf
15:45:25 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11284#a11284 -- ikd what i've done wrong here
15:46:38 <mreh> if uniform returns a type (ST a), then "replicateM 10 (uniform rng)" should give me a (ST [a])
15:47:49 <copumpkin> :t replicateM
15:47:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:48:13 <blackdog> is it possible to load chs modules in ghci?
15:48:27 <mreh> copumpkin, like i said, am I correct?
15:48:32 <blackdog> or do you have to manually generate the hs file first?
15:48:49 <mauke> mreh: yes, it does
15:49:13 <copumpkin> mreh: you have two separate monads in your do
15:49:26 <copumpkin> print is in IO
15:49:30 <copumpkin> uniform is in ST
15:50:03 <mreh> oh, i can't bind two separate monads
15:50:17 * glguy can't either
15:50:26 <copumpkin> @hoogle STtoIO
15:50:26 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
15:50:26 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
15:50:26 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
15:50:29 <copumpkin> if you really want
15:50:36 <copumpkin> the unsafe one :P
15:50:46 <copumpkin> or you could just runST it
15:51:37 <benmachine> :t runST
15:51:37 <lambdabot> forall a. (forall s. ST s a) -> a
15:52:00 <benmachine> how does STtoIO differ from return . runST
15:52:05 <mreh> if I runST it then it's going to be "less polymorphic that expected"
15:52:08 <mreh> oh, yeah return
15:52:19 <benmachine> that is a question I don't know
15:52:27 <copumpkin> benmachine: stToIO expects ST RealWorld, which you'd be pretty hard-pressed to find in the wild
15:52:52 <benmachine> okay, so what about the unsafeSTToIO
15:53:01 <benmachine> I can do it safely so why would I do it unsafely
15:53:17 <benmachine> or is that a similar idea
15:53:24 <benmachine> because it's not foralled in the same way
15:53:31 <benmachine> :t unsafeSTToIO
15:53:32 <lambdabot> Not in scope: `unsafeSTToIO'
15:53:45 <benmachine> :t Control.Monad.ST.unsafeSTToIO
15:53:46 <lambdabot> forall s a. ST s a -> IO a
15:53:56 <benmachine> :t return . runST
15:53:57 <lambdabot> forall a (m :: * -> *). (Monad m) => (forall s. ST s a) -> m a
15:55:08 <copumpkin> benmachine: the difference is that one "runs" the computation
15:55:11 <copumpkin> and then packages it up in IO
15:55:29 <jokerGTA> can anyone try to explain what parsers do besides pulling out fist char from the input
15:55:42 <copumpkin> jokerGTA: kinda depends on the parser
15:56:06 <jokerGTA> well few i seen take first char or number from string and return it
15:56:37 <mauke> parsers turn strings into data
15:57:14 <mauke> preflex: calc (1 + 2) * 3
15:57:14 <preflex>  9
15:57:35 <mauke> that used a parser to turn "(1 + 2) * 3" into a tree, which was then evaluated
15:57:52 <sinelaw> 'xcuse my question, what's the syntax for exporting a value from a module?
15:57:56 <Gracenotes> well, a grammar is a collection of strings. for example, the Haskell parser grammar contains all strings that can be parsed into a Haskell program (even if, say, it doesn't typecheck). there are an infinite number of strings in the Haskell grammar
15:58:37 <Gracenotes> from a grammar, you can easily check if a certain string is in the grammar (e.g., if something is a valid Haskell program). but that's not so helpful if you want to extract information from it.
15:58:49 <Draconx> well, depends on the kind of grammar.
15:58:57 <copumpkin> grammer!
15:58:59 <copumpkin> ;)
15:59:20 <sinelaw> grandma
15:59:21 <Gracenotes> so there are techniques to not only determine if something's valid, but keep track of your path when parsing through it. from that information, you get a parse tree, which can be used to then .. do whatever
15:59:25 <Draconx> (e.g. determining whether a sequence of productions in an unrestricted grammar generates some terminal string is undecidable)
16:00:11 <copumpkin> anyone have any interesting uses of mfix on []?
16:00:16 <copumpkin> > mfix (const [])
16:00:17 <lambdabot>   []
16:00:44 <Gracenotes> one type of parser just eats one character at a time. that's a regular grammar, and it's what regular expressions parse (or are supposed to, anyway)
16:01:19 <Gracenotes> Draconx: true.. but I don't want my programming language parser to be Turing-complete :P
16:01:42 <Gracenotes> copumpkin: yeah, I have one. just wait a sec
16:01:46 <Draconx> and for length-increasing grammars, it is believed that such a check is not "easily" done :P
16:01:51 <Gracenotes> ... a few seconds ...
16:01:58 <Gracenotes> ... a few minutes ...
16:02:04 <Gracenotes> ... a few years ...
16:02:15 <Gracenotes> hm, seems it hasn't returned yet
16:03:14 <Gracenotes> actually, mfix for lists seems to be more susceptible to stack overflows than bottoms
16:03:14 <copumpkin> just wondering why someone would've bothered making a MonadFix instance for []
16:04:04 <Vanadium> I have not the slightest idea what I would ever do with mfix
16:04:11 <Vanadium> It is utterly incomprehensible to me
16:04:58 <jfoutz> mfix show
16:05:01 <Twey> :t mplus
16:05:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:05:02 <Gracenotes> mdo seems to be the main use. which I suppose can be useful when you need it, if you need it: sequencing statements without forcing them. but weirder.
16:05:10 <Twey> > mplus [1, 2] [3, 4]
16:05:11 <lambdabot>   [1,2,3,4]
16:05:19 <Twey> Why don't we just define (++) = mplus?
16:05:28 <copumpkin> Twey: it is, in this lambdabot
16:05:31 <copumpkin> oh wait, mappend
16:05:32 <Twey> Oh
16:05:37 <Twey> :t mappend
16:05:38 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:05:40 <Gracenotes> some people would say mappend
16:05:46 * Twey scratches his head.
16:05:47 <copumpkin> :t (++)
16:05:48 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:05:52 <Twey> What does mappend do?
16:05:53 <sinelaw> question about layout. can i do something like this:
16:05:54 <Gracenotes> hah. devious
16:06:01 <sinelaw> bla = [
16:06:04 <Cale> Twey: arbitrary monoid operation
16:06:07 <copumpkin> > Just (Sum 5) `mplus` Just (Sum 7)
16:06:08 <lambdabot>   Just (Sum {getSum = 5})
16:06:09 <Twey> Oh
16:06:10 <sinelaw>  "blabla",
16:06:12 <copumpkin> > Just (Sum 5) `mappend` Just (Sum 7)
16:06:12 <Gracenotes> Twey: MonadPlus is essentially a Monoid. with the requirement that it's also a Monad
16:06:13 <lambdabot>   Just (Sum {getSum = 12})
16:06:16 <sinelaw>  "blabla2",
16:06:18 <sinelaw> ]
16:06:19 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
16:06:24 <Cale> Sometimes the instance is different though
16:06:25 <sinelaw> ?
16:06:26 <Twey> So mplus would really be better for an operator whose intuitive operation is concatenation
16:06:32 <Cale> > Just [1,2,3] ++ Just [4,5]
16:06:33 <lambdabot>   Just [1,2,3,4,5]
16:06:45 <Cale> > Just [1,2,3] `mplus` Just [4,5]
16:06:46 <lambdabot>   Just [1,2,3]
16:06:51 <Twey> Ah
16:06:54 <Gracenotes> @type concat
16:06:55 <lambdabot> forall a. [[a]] -> [a]
16:06:59 <Cale> They're both monoid operations
16:06:59 <Twey> I can't decide which of those I like better.
16:07:11 <Cale> The ++ one is the lifting instance though
16:07:14 <Gracenotes> Data.Monoid lists interesting stuff
16:07:23 <Twey> I guess mappend has a wider range of uses
16:07:31 <Gracenotes> monoids can also be used to model composition
16:07:41 <Gracenotes> of (a -> a)s.
16:07:42 <Twey> Yeah, I saw the HoleyMonoid
16:07:42 <Cale> > sortBy (comparing length ++ compare) (words "here are some words for you")
16:07:43 <lambdabot>   ["are","for","you","here","some","words"]
16:07:45 <Draconx> (*) should be mappend :P
16:07:59 <copumpkin> \cdot should be
16:08:14 <Twey> :t compare
16:08:15 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
16:08:27 * Twey scratches his head.
16:08:35 <Cale> Ordering is an instance of monoid, and whenever m is a monoid, so is e -> m
16:08:36 <Twey> I don't understand that one.
16:08:45 <Gracenotes> Twey: that weirdness comes from the instance Monoid b => Monoid (a -> b)
16:08:46 <Cale> LT ++ y = LT
16:08:50 <Cale> GT ++ y = GT
16:08:53 <Cale> EQ ++ y = y
16:08:53 <copumpkin> Twey: it just tells you which is larger, smaller, or if they're equal
16:08:55 <Gracenotes> and the instance Monoid Ordering, as Cale said
16:08:57 <Twey> > sortBy (comparing length) $ words "here are some words for you"
16:08:58 <lambdabot>   ["are","for","you","here","some","words"]
16:09:01 <Cale> (f ++ g) x = f x ++ g x
16:09:13 <Twey> Isn't it the same?
16:09:15 <Cale> So, (f ++ g) x y = f x y ++ g x y
16:09:22 <copumpkin> > compare 5 6
16:09:23 <lambdabot>   LT
16:09:24 <copumpkin> > compare 5 5
16:09:25 <Cale> Twey: yeah, bad example
16:09:25 <lambdabot>   EQ
16:09:32 <Gracenotes> Twey: hah. that's just because all of the words of the same length in that string happen to be alphabetically ordered
16:09:40 <Twey> Heh, oh
16:09:44 <benmachine> Twey: the mplus for Maybe has a parallel in Monoid
16:09:48 <Twey> Impressively bad example :þ
16:09:48 <benmachine> in the form of the First newtype
16:10:20 <Twey> > sortBy (comparing length) $ words "cere dre aome words aor cou"
16:10:21 <lambdabot>   ["dre","aor","cou","cere","aome","words"]
16:10:31 <Twey> > sortBy (comparing length ++ compare) $ words "cere dre aome words aor cou"
16:10:32 <lambdabot>   ["aor","cou","dre","aome","cere","words"]
16:10:36 <Twey> I see
16:10:43 <sinelaw> oy.
16:10:44 <sinelaw> stack overflow: use +RTS -K<size> to increase it
16:10:52 <Twey> sinelaw: TML!
16:11:08 <sinelaw> TML?
16:11:16 <Twey> Too Much Laziness.
16:11:25 <Twey> Tried -O3?
16:11:31 <mauke> no, don't
16:11:32 <Cale> -O3 is the same as -O2
16:11:36 <mauke> -O3 doesn't exist
16:11:44 <sinelaw> Twey, my module is just this:
16:11:44 <Twey> Really?  Oops
16:11:46 <benmachine> -O(log n)
16:11:52 <Twey> Heh
16:11:53 <sinelaw> a_huge_dictionary = fromList [("here goes", "the first one"),
16:11:55 <Cale> (it used to be that -O3 was silently ignored)
16:12:02 <sinelaw> then about 100k entries
16:12:04 <sinelaw> and then,
16:12:05 <sinelaw> ]
16:12:06 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
16:12:11 <Cale> sinelaw: Then don't do that.
16:12:31 <Cale> sinelaw: Rather than fromList, maybe try  foldl' insert
16:12:40 <sinelaw> ok
16:12:40 <Twey> sinelaw: Oo-er.  Sounds like fromList isn't stack-safe.
16:12:49 <Twey> Shouldn't it be?
16:12:59 <Cale> sinelaw: Well, foldl' insert Map.empty
16:13:01 <Twey> Or is it just that that huge value is being constructed on the stack?
16:13:17 <Cale> Twey: It's that it's using foldl or something
16:13:28 <Twey> So there's no reason that it should crash like that
16:13:33 <sinelaw> @type foldl'
16:13:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:13:34 <Lemmih> sinelaw: How long does that module take to compile?
16:13:40 <Cale> Twey: basically, yeah
16:13:51 <sinelaw> Lemmih, several millennia
16:13:53 <Twey> Should we report that?
16:14:17 <Cale> sinelaw: Personally, I would not pollute my sourcecode with a dictionary like that. Just put the data in a text file and load it :)
16:14:17 <Gracenotes> for huge things in Haskell, sometimes mmap is nice...
16:14:32 <sinelaw> Cale, but that will require tons of processing every time i run my program
16:14:37 <sinelaw> Gracenotes, same
16:14:41 <Cale> sinelaw: It already will.
16:14:59 <Cale> sinelaw: It's not like the compiler is going to run the fromList at compile time for you
16:15:12 <sinelaw> Cale, oh. good point.
16:15:23 <Cale> Though I suppose you save on a bit of string processing
16:15:23 <sinelaw> so how can i build a dictionary at compile time?
16:15:27 <sinelaw> Map that is
16:15:30 <Cale> You can't.
16:15:54 <sinelaw> so what do you do in haskell in this case? :)
16:16:08 <Lemmih> And there wouldn't be much of a point if you could.
16:16:09 <Cale> Take the constant time hit to load the data.
16:16:35 <sinelaw> don't wanna
16:16:43 <Cale> There is a bit of a point. There are a lot of times where it would be nice to have a template haskell where the syntax could include evaluated values.
16:16:46 <Gracenotes> as it is, I think, it'll compile into: big_dictionary = let xn = "last string":[]; xn1 = "second to last":xn; ... ; x2 = "second string":x3; x1 = "first string":x2 in Map.fromList x1. tis a lot.
16:16:49 <tommd> sinelaw: You want a massive .text in your binary?  Make a Haskell program that generates the data as a Haskell variable.
16:17:39 <tommd> If its a closed ADT, like Map, I guess you do have a problem though.
16:17:46 <sinelaw> tommd, i don't mind the massive .text, i'm assuming only the accessed portions will be loaded to memory
16:17:48 <Gracenotes> you'll have to do some processing to make the list, and to get it all into a Map
16:18:00 <Gracenotes> in the module-based approach
16:18:46 <TML> wait, what?
16:19:00 <TML> never mind
16:19:17 <sinelaw> heh
16:19:34 <tommd> sinelaw: I see your problem and sympathize.  Had the same issue with MD5 and getting all the constants - the constants come from a simple computation but to get anything approaching good performance I manually put the constants into the program - couldn't force it to do compile-time evaluation.
16:20:18 <tommd> This is a subset of super-optimization... can't recall the exact name right now.  Anyone?
16:21:01 <sinelaw> damn, if this was C i'd just define the value at compile time
16:21:44 <copumpkin> ghc isn't a fan of large chunks of static data in code
16:21:59 <sinelaw> why not
16:22:27 <copumpkin> it's prejudiced
16:22:40 <mmorrow> preflex: seen glguy
16:22:40 <preflex>  glguy was last seen on #haskell 32 minutes and 23 seconds ago, saying: * glguy can't either
16:22:57 <copumpkin> glguy always speaks of himself in the third person
16:23:07 <sinelaw> so what should i do?
16:23:15 <Lemmih> Lemmih does that too at times.
16:23:19 <copumpkin> sinelaw: load the data separately?
16:23:24 <mmorrow> copumpkin: does that mean we should speak of him in the first person?
16:23:27 <copumpkin> Lemmih: really? copumpkin never does that
16:23:37 <mmorrow> copumpkin: that could get confusing actually
16:23:40 <copumpkin> mmorrow: I think I would prefer it if you did speak of me in the first person
16:23:56 <TML> sinelaw: I had to go read the scrollback to see why my name was being used in vain :)
16:23:57 <mauke> copumpkin: so how are we feeling today?
16:24:09 <sinelaw> copumpkin, how
16:24:16 <mmorrow> copumpkin: i was wonder what's up with me? (second me is you, first i is me)
16:24:28 <sinelaw> copumpkin, if I do that i pay the prices for processing the data into a Map
16:24:30 <copumpkin> sinelaw: serialize it using mmorrow's super secret serializing library, then link to that
16:24:54 <mmorrow> sinelaw: vaporware atm
16:24:59 <tommd> Opportunistic evaluation... no... gahh... partial evaluation.  That's what I was thinking of.  GHC really needs some partial evaluation and high level loop unrolling.
16:25:22 <copumpkin> mmorrow: did you ever get a chance to criterion your bsr-based intmap btw?
16:25:39 <mmorrow> copumpkin: no i haven't, but not because i haven't had a chance..
16:25:52 <mmorrow> copumpkin: making a note to do that
16:25:57 <copumpkin> mmorrow: too much of a pain to do it?
16:26:09 <mmorrow> copumpkin: just general forgetfulness
16:26:12 <copumpkin> ah :)
16:28:41 <sinelaw> ghc should evaluate everything that can be evaluated at compile time
16:29:14 <aavogt> ghc should be even slower at compile time?
16:29:17 <jfoutz> but how can you tell?
16:29:44 <aavogt> it might not speed things up depending on the size of those constants
16:29:58 <aavogt> but it would be a nice option regardless
16:30:27 <maurer_> Hey, if I have a data structure with several elements being from the same original element (so they are all using the same memory) is there an easy way to update every instance of it in the entire structure?
16:30:36 <maurer_> Is there a better way to set up the data structure to allow for this operatioN?
16:30:47 <mmorrow> jfoutz: e.g. gcc -O3 on this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4453#a4454
16:31:27 <copumpkin> that's neat
16:31:28 <mmorrow> it knows the loop is always run 1000000 times, and has all the info the evaluate it at compile time
16:31:51 <copumpkin> pejo's working on adding stuff like that to ghc
16:32:01 <mmorrow> even if it didn't know how many times or the starting value statically, it could still turn it into a single multiplication
16:32:19 <mmorrow> copumpkin: that would rock
16:32:29 <copumpkin> he's working on getting supero working
16:32:35 <copumpkin> not sure what the state of that is
16:33:06 <mmorrow> copumpkin: pejo also's got a system for strict functional languages he's working on
16:33:23 <copumpkin> what is it?
16:33:44 <mmorrow> copumpkin: it's http://www.csee.ltu.se/~pj/papers/scp/popl09-scp.pdf
16:33:54 <maurer_> Alternatively, is there an "equivalence" operation that determines if two pieces of data are actually the same, not just contain the same data (i.e. pointer equiv)?
16:34:09 <mmorrow> copumpkin: (linked to from http://timber-lang.org/index_pubs.html)
16:34:14 <copumpkin> ah I see
16:34:25 <copumpkin> maurer_: reallyUnsafePtrEquality
16:34:30 <copumpkin> @hoogle reallyUnsafe
16:34:30 <lambdabot> No results found
16:34:33 <copumpkin> damn :P
16:34:36 <mmorrow> maurer_: reallyUnsafePtrEquality#
16:34:52 <mmorrow> @type GHC.Prim.reallyUnsafePtrEquality#
16:34:52 <lambdabot> forall a. a -> a -> GHC.Prim.Int#
16:35:11 <maurer_> mmorrow: How unsafe is reallyUnsafe? If I did  "let foo = bar in [foo, foo]"
16:35:11 <mmorrow> , 1 .=. 1
16:35:12 <copumpkin> maurer_: you really shouldn't need that though
16:35:12 <lunabot>  luna: Not in scope: `.=.'
16:35:15 <mmorrow> , 1 .==. 1
16:35:18 <lunabot>  False
16:35:24 <copumpkin> maurer_: you might want to look at stablenames
16:35:39 <sjanssen> is it possible to look at reverse dependencies on hackage?  I'd like to see if any packages are violating pandoc's GPL license
16:36:10 <copumpkin> sjanssen: roel van dijk had a mirror of hackage
16:36:21 <mmorrow> maurer_: it's "only" unsafe in the sense that it lets you distinguish between otherwise equal values, but if that's exactly what you're trying to do, then..
16:36:40 <copumpkin> things might get moved around though
16:36:48 <sjanssen> copumpkin: how would this mirror help?
16:36:55 <copumpkin> sjanssen: it's got reverse dependencies on it :)
16:37:02 <sjanssen> ah
16:37:03 <maurer_> copumpkin, mmorrow: What's going on here is that I'm writing a compiler, and I want to distinguish between a "int i" at a higher and lower scope.
16:37:05 <copumpkin> sjanssen: http://bifunctor.homelinux.net/~roel/hackage
16:37:27 <maurer_> copumpkin, mmorrow: My alternative is to give everything some kind of UID that will allow me to know which one I need to put the data into.
16:37:29 <sinelaw> sjanssen, http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html
16:37:34 <mmorrow> maurer_:  have you read Andy Gill's paper on observable sharing?
16:37:40 <maurer_> No.
16:37:43 <mmorrow> maurer_: it's good, and about this
16:37:58 <mmorrow> maurer_: there's a link from the hackage package page for
16:38:03 <mmorrow> @hackage data-reify
16:38:03 <lambdabot> http://hackage.haskell.org/package/data-reify
16:38:06 <maurer_> Thanks
16:38:12 <mmorrow> maurer_: no problem
16:38:59 <sinelaw> what's observable sharing?
16:39:14 <mmorrow> maurer_: (not to say that you necessary should use that package in particular, etc)
16:39:29 <mmorrow> maurer_: but it could be exactly what you're looking for
16:40:35 <mmorrow> maurer_: basically you can use StableNames or reallyUnsafePtrEquality# to distinguish the same value, but the pita with the latter is that you have to do linear search if you're e.g. keeping a seen-set or something
16:40:56 <mmorrow> maurer_: whereas with StableName you can have a
16:41:31 <mmorrow> IntMap [StableName], where the keys are the results of hashStableName, then you only have to linearly scan the [] at a particular key with (==)
16:41:46 <mreh> i caan
16:41:56 <mreh> i caan't generate random numbers the way I want to!!!!
16:42:02 <mmorrow> vacuum does that method exactly, and data-reify uses StableName but i'm not positive on the implem details there
16:42:05 <mreh> whyyyyyy not!?!
16:42:20 <mmorrow> mreh: haskell hates you
16:42:22 <mmorrow> :)
16:42:28 <copumpkin> mreh: depends
16:42:35 <mreh> i can't the **** out the IO monad
16:42:50 <mreh> any other way I just end up in a mess of ST monad mixing with IO monad
16:42:52 <sjanssen> preflex: seen ivanm
16:42:52 <preflex>  ivanm was last seen on #haskell 10 hours, 12 minutes and 59 seconds ago, saying: (unless you need reproducable random numbers...)
16:42:55 <dibblego> @type (***)
16:42:56 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:42:57 <mreh> and thoroughly confused
16:43:11 <mmorrow> sinelaw: e.g. in  "let x = 0 : x", you can see that the list is the same as its tail
16:43:25 <mmorrow> , vacuum (let x = 0 : x in x)
16:43:27 <lunabot>  [(0,[1,0]),(1,[])]
16:43:43 <mreh> copumpkin: what if I just require a random number in a function, any old function, how does one do that?
16:44:20 <mreh> do I need to pass it a monad object encapsulating a random number generator?
16:44:59 <jokerGTA> guys for this type of parser  type Parse a b = [a] -> [(b,[a])]
16:45:27 <jokerGTA> succeed :: b -> Parse a b        succeed val inp = [(val,inp)]
16:45:30 <mmorrow> mreh: what answer are you looking for? how to do that /exactly/ without any change to your code? or how to do that in a "haskelly" way?
16:45:33 <jokerGTA> what do i type to get and output
16:45:37 <jokerGTA> i am so lost with this
16:45:41 <maurer_> mmorrow: Thanks, I think I'm just going to use StableName
16:45:52 <mreh> mmorrow: how to do i properly
16:45:59 <mmorrow> mreh: the former answer being unsafePerformIO, the latter being pass the generator as a parameter
16:46:07 <mmorrow> maurer_: np
16:47:33 <mmorrow> mreh: all a monad would do here would be to make it less painful to thread the generator through every single function, which if there are a lot may be worth it
16:47:48 <mmorrow> State StdGen a
16:48:05 <mreh> mmorrow: i'm listening
16:48:07 <mmorrow> mreh: the monad-random package does this
16:48:38 <mmorrow> http://hackage.haskell.org/package/MonadRandom
16:49:28 <sinelaw> will Map.union work on Maybe Maps ?
16:49:57 <mmorrow> sinelaw: what do you mean?
16:50:21 <sinelaw> @hoogle Maybe (Map k v) -> Maybe (Map k v) -> Map k v
16:50:21 <lambdabot> Data.Map union :: Ord k => Map k a -> Map k a -> Map k a
16:50:21 <lambdabot> Data.Map unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
16:50:21 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
16:50:37 <mmorrow> what do you intend Nothing to mean here?
16:50:43 <mmorrow> Nothing := the empty Map?
16:50:46 <sinelaw> yes
16:51:01 <mmorrow> sinelaw: Map is a Monoid, so you can just use the empty Map
16:51:07 <sinelaw> i can just use empty, i guess
16:51:08 <mmorrow> and ditch the Maybe
16:51:11 <mmorrow> mempty
16:51:13 <sinelaw> yeah
16:52:01 <mreh> i would be okay if GSL didn't trap it's computations in the IO monad
16:52:58 <sinelaw> how can I use recursion with parsec? I want my function to keep recursing until the stream ends (and parse fails)
16:53:12 <mreh> and GSL is the only library that implements a normal distribution, apart from Statistics, which for the life of me I can't use
16:54:11 <sinelaw> nvm, manyAccum does what i need
16:54:46 <copumpkin> mreh: why can't you use it?
16:54:48 <sinelaw> actually it doesn't, it's hard coded to lsits
16:54:50 <sinelaw> lists
16:54:53 <copumpkin> statistics looked nice last I looked
16:55:14 <mreh> copumpkin: I don't have enough experience with ST and monads in general
16:55:59 <mreh> I have to make a random number generator encapsulated in monad, and then use it in another monad for example
16:56:10 <copumpkin> ST isn't hard
16:56:19 <copumpkin> it's like IO except you can escape it
16:57:09 <halcyon10> hi, i want to use Data.Map but want to use a custom Monoid instance. Is there a away to hide the default instance?
16:57:22 <copumpkin> no
16:57:25 <copumpkin> just wrap it
16:57:42 <halcyon10> like with newtype?
16:57:56 <copumpkin> yeah
16:58:04 <mreh> so in theory I can make an "ST s (Gen s)" and evaluate it whenever I want?
16:58:19 <copumpkin> yep
16:58:21 <copumpkin> oh wait
16:58:21 <mreh> that's the type of a new random number generator in Statistics
16:58:23 <copumpkin> not with Gen s
16:58:49 <tom6> hi
16:58:54 <copumpkin> @hackage statistics
16:58:55 <tom6> is this for haskell help?
16:58:55 <lambdabot> http://hackage.haskell.org/package/statistics
16:59:01 <copumpkin> tom6: yes
16:59:12 <tom6> just a small problem
16:59:13 <mreh> I have to do something like: uniform . runST $ create
16:59:19 <halcyon10> copumpkin: ok thanks
16:59:56 <mreh> or even: runST . uniform . runST $ create
17:00:09 <halcyon10> mreh: you have to call uniform from inside runST
17:00:44 <mreh> halcyon10: i don't follow
17:01:08 <Vanadium> You keep the Gen s inside the ST. You get the numbers out.
17:01:10 <tom6> arrangehand hand = if (_,Spades)==head hand, arrange hand is a function that takes a hand (a list of tuples) and returns a hand, for this step i need to match all items where the seond tuple item of the head of the list is "Spades", i have tried using '_' as an anonymous variale which is incorrect
17:01:12 <copumpkin> mreh: create >>= uniform
17:02:33 <sinelaw> ok this sucks. The constant times associated with loading the data every time are huge. 12 seconds just to load the program!
17:03:17 <copumpkin> mreh: for example, runST (replicateM 10 . normal =<< create)
17:03:42 <Lemmih> sinelaw: You're rebuilding the database on each load, right? Might be a good idea not to do that.
17:04:07 <sinelaw> Lemmih, i'm trying to find a way how to not do that. how can i store the 'built' db?
17:04:22 <copumpkin> data-reify
17:04:36 <mreh> copumpkin, thank you, I hope you all don't mind the stupid questions
17:04:38 <Lemmih> sinelaw: Sort the data and save it in a file.
17:04:41 <copumpkin> mreh: not at all
17:04:57 <sinelaw> Lemmih, it's already sorted
17:05:14 <sinelaw> Lemmih, store in what format?
17:05:30 <Lemmih> sinelaw: Are you using 'fromAscList'?
17:05:48 <halcyon10> mreh: for example: (runST $ create >>= uniform)::Double
17:06:25 <sinelaw> Lemmih, no
17:06:43 <copumpkin> sinelaw: you should
17:06:52 <copumpkin> fromAscList is O(n)
17:06:56 <sinelaw> @type fromAscList
17:06:57 <lambdabot> Not in scope: `fromAscList'
17:07:08 <tom6> hi i have a list of tuples. i wish to selct all of the tuples where the second data item == "Spades", regardless of what the first data item was == to. how is this possible =]
17:07:31 <copumpkin> :t find ((== "Spades) . snd)
17:07:32 <lambdabot>     lexical error in string/character literal at end of input
17:07:35 <mmorrow> sinelaw: what format is it in? you could mmap it if it's a ByteString
17:07:50 <copumpkin> :t find ((== "Spades") . snd)
17:07:51 <lambdabot> forall a. [(a, [Char])] -> Maybe (a, [Char])
17:07:54 <mreh> halycon10: how do I make a list of random Integers
17:08:03 <sinelaw> mmorrow, then i'd still need to parse it
17:08:05 <copumpkin> mreh: that's what I just gave you before
17:08:14 <mreh> copumpkin, those were doubles
17:08:17 <copumpkin> oh
17:08:29 <tom6> arrangehand hand = if (_,Spades)==head hand, is there no way of doing it like this
17:08:32 <mreh> I can't cast the whole thing, it needs to stay in the monad for the replicate
17:08:43 <mmorrow> sinelaw: what type is the final parsed-prepped-etc db?
17:08:57 <copumpkin> mreh: Int is an instance of Variate
17:09:00 <copumpkin> so it has uniform
17:09:06 <copumpkin> so it's that code exactly
17:09:09 <sinelaw> mmorrow,  for now Map String String
17:09:10 <mmorrow> sinelaw: and also, how are you currently reading it in?
17:09:20 <mmorrow> sinelaw: are you using read?
17:09:22 <sinelaw> mmorrow, parsing a text file
17:09:25 <sinelaw> parsec
17:09:28 <copumpkin> Prelude Statistics.RandomVariate Control.Monad Control.Monad.ST> runST (replicateM 10 . uniform =<< create) :: [Int]
17:09:28 <copumpkin> [37088784,1783070722,-1466212488,284363989,-1599204751,-1758489909,1506662650,-884542071,2049551453,-101958328]
17:09:32 <sinelaw> with ByteString
17:09:40 <mmorrow> sinelaw: how big is the textfile
17:09:41 <mmorrow> ?
17:09:54 <sinelaw> 3.6MB
17:10:04 <sinelaw> 100k entries for the map
17:10:16 <mmorrow> sinelaw: ugh, yeah so a static Map would be painful
17:10:26 <mmorrow> sinelaw: i'd try bytestring-mmap, it might help things
17:10:39 <mmorrow> sinelaw: and if it doesn't, the bottleneck is your parser
17:11:03 <sinelaw> i know, since i'm still a little new to haskell, i was thinking i could have a static Map
17:11:06 <sinelaw> in compile time
17:11:25 <mmorrow> sinelaw: did you try?
17:11:31 <mmorrow> sinelaw: it's worth a try
17:11:43 <sinelaw> it doesn't compile, ghc commits suicide
17:11:45 <jokerGTA> guys can anyone tell me if this function is correct
17:11:47 <jokerGTA> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4503#a4503
17:11:47 <sinelaw> stack overflow
17:11:53 <mmorrow> writeFile "mymap.hs" (show hugeMap)
17:12:00 <mmorrow> sinelaw: heh
17:12:08 <mmorrow> sinelaw: so i guess not then
17:12:16 <tom6> thanks for the help, i will probably be back, bye x
17:12:49 <mreh> copumpkin: what is this backwards bind that you used?
17:12:49 <mmorrow> what's the text-file format?
17:12:51 <sinelaw> mmorrow, maybe i can compile it as a list, and convert it to Map in runtime
17:12:52 <mmorrow> sinelaw:
17:12:58 <copumpkin> mreh: precisely that :)
17:13:06 <copumpkin> =<< = flip (>>=)
17:13:12 <mmorrow> sinelaw: that's what the Show for a Map does anyways
17:13:12 <copumpkin> I like it more
17:13:32 <sinelaw> only in reverse
17:13:33 <mmorrow> sinelaw: which makes it even less efficient than it already it
17:13:36 <mmorrow> s/it/is/
17:13:42 <mreh> runST (replicateM 10 . create >>= normal) -- doesn't work
17:13:49 <mreh> copumpkin,
17:13:55 <mmorrow> > M.singleton (42,"asdf")
17:13:56 <lambdabot>   {()->fromList [((42,"asdf"),())]}
17:14:03 <mmorrow> wut
17:14:06 <blackdog> sinelaw: i've wanted that for a while - the problem is that there doesn't seem to be a way to indicate to GHC that it should evaluate it fully at compile time
17:14:09 <mmorrow> oh
17:14:23 <mmorrow> @type Data.Map.singleton
17:14:24 <lambdabot> forall k a. k -> a -> M.Map k a
17:14:25 <mreh> copumpkin, I have to stick my head in a book for a few weeks to try and figure all of this out
17:14:30 <mmorrow> > M.singleton 42 "asdf"
17:14:31 <lambdabot>   fromList [(42,"asdf")]
17:14:47 <sinelaw> blackdog, yeah.. :(
17:14:50 <mmorrow> sinelaw: what format is the text file in? csv?
17:15:14 <mmorrow> sinelaw: i've got a speedy csv parser i use if so
17:15:17 <copumpkin> mreh: runST (create >>= (replicateM 10 . uniform)) :: [Int]
17:15:35 <sinelaw> mmorrow, no, but very simple. maybe i can convert it to csv and try that :) but first i wanna see if my program works at all
17:16:13 <mmorrow> sinelaw: here's that CSV module if it helps http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2724
17:16:25 <Lemmih> sinelaw: Have you tried loading the map using Data.Binary?
17:16:27 <blackdog> sinelaw: just thinking - if you know it all at compile time, you could possibly use my PerfectHash library
17:16:28 <Twey> Hm
17:16:47 <sinelaw> mmorrow, thanks
17:16:50 <sinelaw> Lemmih, no
17:16:54 <mmorrow> sinelaw: it knifes through a 100000-line csv in 0.346 seconds, and bytestring-csv takes 6.045 seconds on the same file
17:16:54 <sinelaw> blackdog, what's that?
17:17:13 <copumpkin> mmorrow: nice
17:17:14 <blackdog> sinelaw: it's a wrapper around the CMPH library
17:17:18 <copumpkin> mmorrow: you should upload it
17:17:24 <mmorrow> copumpkin: i really should
17:17:38 <mmorrow> copumpkin: i've been meaning to for like a year
17:17:41 <blackdog> when you know the set of possible keys, it's possible to represent a dictionary very compactly
17:18:39 <mmorrow> sinelaw: oh yeah, Lemmih has a really good point
17:18:54 <mmorrow> sinelaw: Data.Binary would fix things most likely
17:19:07 <blackdog> mmorrow: last time i used the Binary instance for Data.Map, i got really bad space behaviour
17:19:20 <mmorrow> blackdog: :(
17:19:23 <blackdog> it serialised it as an asssociation list
17:19:26 <blackdog> it might be fixed now
17:19:27 <hackagebot> hpuz 0.0.1.1 - Haskell bindings for libpuz (ChrisCasinghino)
17:19:29 <mmorrow> ohh right. ugh
17:19:48 <sinelaw> ok sounds good, but i still didn't get my program to actually buidl the correct Map, so that's my first step
17:19:52 <mmorrow> i have a modified Map/Set i use with proper Binary instances
17:20:07 <mmorrow> i almost forgot that the regular Map/Set use a list
17:20:21 <Twey> Hmm, what's a non-recursive way of writing: ‘foo [] = return (); foo (x : xs) = do x' <- x; when (not x') (foo xs)’?
17:20:21 <blackdog> mmorrow: is it on hackage?
17:20:34 <mmorrow> blackdog: no, but that's good idea
17:20:39 <blackdog> ("is it on hackage" is the new "pics or it didn't happen")
17:20:40 <blackdog> :)
17:20:46 <sinelaw> wait, it DOES work. yippy
17:20:49 <mmorrow> blackdog: (it's literally only 8 lines added to each module)
17:20:57 <mmorrow> blackdog: heh
17:21:34 <blackdog> mmorrow: it's just an instance, right? so you don't need to ship the rest of the code...
17:21:50 <halcyon10> mreh: that's how i use Statistics.RandomVariate, perhaps the example helps you a bit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11288#a11288
17:21:56 <mmorrow> blackdog: the problem is that Data.{(Int)Map,(Int)Set} don't export their constructors
17:22:10 <mmorrow> blackdog: so you really do need to duplicate the entire modules
17:22:27 <blackdog> btw, i'd like to give public props to the "hint" library. wraps ghc-api beautifully - i can automatically export all the interesting stuff from a module and show it to Ruby...
17:22:35 <blackdog> mmorrow: bummer:/
17:22:42 <mmorrow> blackdog: nice
17:22:49 <mmorrow> blackdog: yeah totally
17:23:02 <Twey> @hoogle Monad m => [m Bool] -> m ()
17:23:03 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
17:23:03 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
17:23:03 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
17:23:04 <blackdog> it gets a bit confusing, though - running code to interrogate code to produce more code
17:23:35 <Twey> But I don't want it to execute all of them… just until the first one returns True.  :-\
17:25:22 <blackdog> hey, i want something like ruby's "string string #{some code} string string" syntax in haskell, using ++ is getting a bit awful. is there a standard-ish library?
17:25:55 <Twey> blackdog: What's that supposed to do?
17:26:06 <newsham> blackdog: what about Text.Printf?
17:26:19 <Twey> Oh, interpolation?
17:27:09 <blackdog> Twey: yeah.
17:27:27 <newsham> > printf "how %s something %s this?" "about" (reverse "ekil") :: String
17:27:27 <Twey> Yeah.  One or other of the printf libraries.
17:27:28 <lambdabot>   "how about something like this?"
17:27:45 <blackdog> newsham: doable, i guess, but it's a big chunk of text - it'd be a bit of a pain to have that separation of the code and the string
17:27:50 <Twey> The TH one gives you compile-time type-checking.
17:28:02 <Twey> blackdog: All the more reason to separate them.
17:28:34 <newsham> so how about make a printf variant that takes a map instead and has format specs that lt you insert by key?
17:29:09 <blackdog> Twey: I disagree. If I'm interpolating a variable name into a chunk of haskell, I want the name to be as close to its usage as possible. if all i know is that it's a string, and i have to go to the end to see which one it is, it's not very clear.
17:29:19 <tom7> hi, i came with a problem before involving a list of tuples. i am getting the error "undefined variable find", what do i have to do to use find?
17:29:53 <newsham> maprintf "how %(about) something %(like) this?" mymap ?
17:29:58 <Twey> blackdog: Keeping code and data separate is generally a Good Thing.  Hard-coding variable names into your *strings* is not good style.
17:30:46 <newsham> also you can use xml and templates if you want to get fancy ;-)
17:30:50 <Twey> Heh.
17:31:13 <blackdog> newsham: that maprintf looks a bit better
17:31:37 <HayashiRazan> One must purify themselves in the waters of Haskell, no matter what the cost
17:31:43 <HayashiRazan> purity will come this way
17:31:51 <blackdog> Twey: generally, but not in this case, i think, mostly because the data is also code
17:31:56 <blackdog> i'm generating haskell text
17:32:28 <blackdog> HayashiRazan: dude, it's a programming language, not a cult
17:32:30 <tom7> hey, i want to use find on a list but i am getting an undefined variable error for find. any clues to what i am doing wrong?
17:32:33 <sinelaw> mmorrow, when i run my program which loads the dumped binary, it stack overflows
17:32:42 <Twey> blackdog: I think that was a joke.  ;)
17:32:44 <blackdog> tom7: tried looking for 'find' with hoogle
17:33:05 <newsham> unsafePerformPurifySelf
17:33:07 <newsham> oops, side effect
17:33:16 <blackdog> Twey: hm, it's sometimes hard to tell:)
17:33:26 <blackdog> newsham: ah, so you need to pass a new version of yourself in
17:33:54 <ivanm> roconnor: you still around?
17:33:55 <Twey> I think tom7 wanted elemIndex or elemIndices
17:34:01 <Twey> But never mind :þ
17:34:14 <roconnor> ivanm: yep
17:34:18 <Twey> blackdog: Yeah… optimism is a vital principle.  :þ
17:34:22 <ivanm> roconnor: I haven't written such a patch yet ;-)
17:34:41 <newsham> the haskell student asked "am I pure yet, master?"  coq did not respond.
17:34:48 <roconnor> I'm thinking Data.Colour.Names.X11
17:34:49 <ivanm> I was asking you to see if somthing like that would be something you'd want in Colour, or if I should write a separate package
17:34:55 <ivanm> roconnor: or NameSpace
17:34:59 <blackdog> Twey: probably, but teach a man to fish and all that...
17:35:01 <ivanm> something like that
17:35:38 <roconnor> ivanm: I can't think of a reason not to distribute it with Data.Colour.  It isn't very big, has no dependencies, and is in a separate module.
17:35:47 <ivanm> right
17:35:51 <roconnor> and easy to maintain
17:35:55 <blackdog> Twey: actually, given that I'm generating Haskell source, is there a more sensible way of generating that kind of text?
17:36:18 <ivanm> roconnor: I can code it, I just haven't looked too much at Colour itself to know how you've done things
17:36:40 <Twey> blackdog: I suggest TH.
17:37:05 <ivanm> roconnor: I'm thinking of a large algebraic data structure with conversions to the appropriate Colour types
17:37:20 <roconnor> hmm
17:37:33 <roconnor> You can look at the source for Data.Colour.Names
17:37:48 <sinelaw> blackdog, i'm trying PerfectHash + Binary now
17:37:58 <roconnor> I have no data type, though I do have a fromString function
17:38:15 <sinelaw> well, later. night :)
17:38:30 <roconnor> ivanm: I don't think a large data type would be useful.
17:38:43 <roconnor> though I could be wrong.
17:39:11 <blackdog> sinelaw: great - let me know if you have any problems
17:39:12 <roconnor> ivanm: you might want to check to see if the X11 colours differ from the SVG colours
17:39:26 <ivanm> roconnor: oh, didn't see Data.Colour.Names
17:39:31 <roconnor> from the existing SVG colours
17:39:33 <roconnor> ya
17:39:46 <roconnor> I think they are identical except they define one colour differently :/
17:40:01 <ivanm> roconnor: my main reason for wanting a large data structure: the ability to have an X11Colour as a data type for use elsewhere for type-safety
17:40:11 <ivanm> roconnor: X11 colours have a lot more than that methinks...
17:40:18 <roconnor> ok
17:40:39 <roconnor> ivanm: is there a reason your application can only have x11 colours?
17:41:10 <blackdog> sinelaw: hm, i haven't provided the binary instance yet, have I... should really do that:/
17:41:34 <ivanm> roconnor: I'm wanting to improve the Colour support in graphviz for the named colours
17:41:56 <ivanm> it accepts different colour namespaces, but I haven't worked out how to include different ones yet (since that changes parsing and printing...)
17:42:00 <ivanm> http://graphviz.org/doc/info/colors.html
17:42:48 <roconnor> ok
17:42:55 <ivanm> roconnor: ^^ e.g. it's a bit hard to tell which colour "1" it refers to ;-)
17:43:24 <roconnor> I'd be more hesitant to accept a new large data type of colour names.
17:43:27 <blackdog> Twey: I don't think TH can help here - I'm using some libraries to generate the code that I don't want to have to ship to the client
17:43:32 <ivanm> roconnor: *nod*
17:43:52 <ivanm> I just figured that something like that would be more appropriate in a common library rather than defining it just for graphviz
17:44:46 <roconnor> I'll think about it.
17:44:56 <roconnor> ask me again when you have the module written :)
17:45:01 <ivanm> roconnor: heh
17:49:06 <mmorrow> sinelaw: what stack overflows? the binary instance for Map?
17:50:21 <newbie> guys can anyone help me with this function
17:51:15 <mmorrow> ivanm: why not just provide a mapping between X11 colors and (R,G,B) or (H,S,V) or whatever
17:58:33 <blackdog> newsham: that maprintf function is necessarily partial, right? you can't guarantee that a particular key is defined
17:59:16 <newsham> i guess so
17:59:49 <blackdog> it feels like you should be able to pull that information out somehowe
18:00:00 <newsham> maybe some crazy gadt data type for map could encode which keys were present
18:00:31 <newsham> ie. if keys were encoded as Z, S n, etc..
18:01:02 <blackdog> i suppose at the base level, i want a function that takes a string and checks the internal references against what's actually defined
18:01:17 <blackdog> which breaks compositionality
18:01:54 <blackdog> newsham: how would you make the link between the variables and the gadt types, though?
18:02:39 <newsham> TH preparse of the string into a data type that encoded the string and the keys required?
18:02:48 <newsham> *shrug*
18:02:57 <blackdog> it feels odd that it should be a hard thing to do - it's a more or less trivial transformation syntactically to go from "foo #{bar} fo" to "foo " ++ bar ++ " fo"
18:03:29 <newsham> ++ show bar ++
18:03:46 <newsham> (or some show-like thing)
18:03:57 <blackdog> newsham: i'd be happy if it even just worked on strings
18:04:30 <blackdog> maybe I can use TH just for this bit
18:04:37 <newsham> yah that prob wouldnt be too hard
18:05:03 <newsham> also if #{foo} could be an arbitrary expr it could be "show something"
18:06:06 <blackdog> newsham: i thought about that, but how would you put an actual string in, then? you'd have to do some odd newtype thing
18:06:31 <ivanm> mmorrow: that was my plan, but I figured that other people might want such a thing and figured that roconnor's Colour package would be a good place to put it rather than a stand alone
18:06:47 <newsham> you can get TH to give you the parsed expression for the string "show something"
18:06:47 <mmorrow> cool
18:07:11 <mmorrow> or haskell-src-exts
18:07:33 <mmorrow> haskell-src-meta does a translation between haskell-src-exts AST -> TH AST
18:08:17 <sfdggfsd> whats the "isnt" operator
18:12:08 <kmc> m0nkfish, you mean "not equals"?
18:12:23 <kmc> > 2 /= 3
18:12:24 <lambdabot>   True
18:15:20 <m0nkfish> :)
18:15:22 <m0nkfish> thats the one
18:20:47 <Twey> > 2 ≠ 3
18:20:48 <lambdabot>   Not in scope: `≠'
18:20:51 <Twey> Aw
18:20:59 <Twey> It has forall
18:22:36 <copumpkin> forall is syntax
18:22:54 <copumpkin> there is a package on hackage with unicode versions of many of the common library symbols
18:29:36 <Fixer> Hi, I am sorry to ask this, but I have an issue with a function I'm trying to create. its posted http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4505#a4505  and while yes it is for a homework assignment, I have made an honest attempt in trying to figure this one out
18:30:20 <kmc> Fixer, you don't handle the case where both lists are non-empty and x == a
18:31:00 <Fixer> Kmc: infiniteMerge (x:xs) (a:ab) doesn't mean they're both non-empty?
18:31:07 <kmc> it does
18:31:10 <Fixer> OH and x == a
18:31:12 <kmc> you have two guards on that case
18:31:15 <kmc> none for x == a
18:31:17 <kmc> also i think some of your base cases could be simpler
18:31:34 <kmc> like infiniteMerge [] xs = xs; infiniteMerge xs [] = xs;
18:32:00 <Fixer> oh! thanks i didn't realize that., let me try the x==a and I'll get back to you. I appreciate it
18:32:05 <kmc> :)
18:33:21 <Fixer> That did it!  Wow, I was trying quite a bit of silly things that didn't make sense, so thanks a lot
18:34:38 <Fixer> ill have to say as an aside: this assignment has definitely inspired me to like haskell. i had never heard of it and now i really appreciate how elegan it can be
18:34:43 <Fixer> elegant*
18:39:15 <NutCobbler> I'm figuring out what path to take to design a program. I have encountered a Cabaled package, it is an incomplete library wrapper for libgd. I'm looking for a way to either take its Haskell guts to work with for my project, or have some easy way to add the missing functionality without having to break the existing Cabaled installed library. What route do I take and what page do I read for this?
18:40:01 <Cale> NutCobbler: Well, you can probably contribute code directly to the package
18:40:36 <Cale> NutCobbler: When you cabal installed it, it would have been downloaded into ~/.cabal/packages/hackage.haskell.org/
18:41:38 <Cale> NutCobbler: You can find and unpack the tarball from there, edit the code, maybe update the version on it, and just do a "cabal install" straight from the directory (where the .cabal file is) and it'll install your updated version
18:41:42 <NutCobbler> Cale, if I were to contribute code, I would have to test it first. I want to get a program off the ground quickly too.
18:42:31 <NutCobbler> Cale, would that break the good code? I could still cabal install over my changes I assume?
18:42:52 <NutCobbler> Cale, I really think there is a better way to do it since this is an interpreted language.
18:43:04 <c_wraith> what's an interpreted language, now?
18:43:04 <kmc> woah hold on a sec
18:43:11 <kmc> there is no such thing as an interpreted language
18:43:14 <kmc> and haskell is usually compiled
18:43:21 <copumpkin> my CPU interprets my programs for me
18:43:26 <kmc> there is no such thing as an interpreted language because a given language could have interpreted or compiled implementations
18:43:32 <kmc> and haskell does
18:43:37 <kmc> but the most popular one is a compiler, and a damn sexy one
18:43:53 <c_wraith> anyway.  cabal unpack is a good answer for this.
18:44:24 <c_wraith> just give your versions different version numbers, and depend on the exact version
18:44:46 <NutCobbler> I'm not going to debate how Haskell is interpreted. I worked with a professor who helped collaborate the Haskell '98 specification and he'd agree with me that this is interpreted.
18:44:53 <kmc> haha
18:45:10 <c_wraith> you have an interesting definition of interpreted.
18:45:20 <c_wraith> But...  I guess the spec *is* interpreted.
18:45:21 <copumpkin> maybe the implementation of haskell he's using is an interpreted one
18:45:38 <c_wraith> You have to interpret the spec to build an execution environment, after all
18:45:44 <NutCobbler> The language was designed from the ground up to be read by an interpreter to be executed in memory.
18:45:48 <copumpkin> but nothing better than reductio ad authoritatem
18:45:57 <kmc> i interpret the spec in a post-modern context
18:46:23 <copumpkin> NutCobbler: as opposed to...?
18:46:24 <c_wraith> I prefer the continental interpretation of the spec
18:46:36 <blackdog> is there a way to go from a string to the variable denoted by that string in TH?
18:46:44 <NutCobbler> I need to know how to fix a Cabal package..
18:46:50 <c_wraith> We told you.
18:46:58 <c_wraith> Why don't you just do it?
18:47:17 <NutCobbler> Just work on it and reinstall. Then if something breaks install the original work?
18:47:29 <c_wraith> use your own version numbers
18:47:32 <c_wraith> keep them distinct
18:47:38 <c_wraith> Depend on your exact versions
18:47:58 * Twey laughs.
18:48:00 <c_wraith> If you *really* want, change the package name.
18:48:04 <NutCobbler> Could I somehow use a "import Graphics.GD.mycopy"?
18:48:27 <c_wraith> No.  That's not a valid package name.
18:48:52 <c_wraith> But you really should learn how the package management system works.
18:48:52 <kmc> NutCobbler, if you just want to get your project up and running, why not just download the source and copy it in?
18:49:07 <NutCobbler> I just don't want to set myself back with time when I want to prototype something.
18:49:22 <c_wraith> Having multiple packages that provide the same modules is no issue, so long as you only expose one of them to the compiler.
18:49:37 <Twey> Incidentally, *is* there a true interpreter for Haskell?  Other than GHCi: one made for proper execution, rather than just fiddling?
18:49:44 <kmc> Hugs?
18:49:50 <Twey> Types and all, like?
18:49:59 <NutCobbler> kmc, I tried to copy in the source. I come up with errors and this Cabal packaging does something platform specific as it comes with a custom C function and header.
18:50:00 <Twey> Does Hugs interpret?
18:50:11 <kmc> hugs is a haskell interpreter written in C, iirc
18:50:15 <c_wraith> yeah, Hugs is a pure interpreter.
18:50:38 <Twey> Ah, nice
18:51:08 <Draconx> Twey, runghc?
18:51:18 <copumpkin> that goes through bytecode doesn't it?
18:51:23 <Twey> I'm pretty sure runghc compiles
18:51:34 <kmc> so does GHCi
18:51:38 <copumpkin> although we're using pretty ill-defined terms in the first place
18:51:38 <Twey> Hugs uses bytecode, too, but then so do Python and a bunch of other ‘interpreted’ languages
18:51:39 <kmc> again to bytecode
18:51:46 <Twey> kmc: Yeah
18:51:51 <c_wraith> runghc doesn't compile to native code.
18:51:55 <c_wraith> where ghc does
18:51:59 <Twey> Oh, really?  Huh.  Okay.
18:52:12 <kmc> CPython uses bytecode
18:52:18 <copumpkin> I normally think of interpreters as being AST walkers
18:52:22 <kmc> you can't say what "Python" uses because it's a language, not an implementation
18:52:23 <copumpkin> and anything else as a compiler
18:52:29 <kmc> (though they do their best to try to muddle that, as does Perl)
18:52:56 <Twey> I think all the implementations use some form of bytecode interpretation
18:53:10 <kmc> some people think of "interpreter" as "parse as you go", but the only language implementation i know that does that is Perl 5
18:53:21 <kmc> since statically parsing Perl syntax is undecidable
18:53:25 <Twey> (because it has no choice :þ)
18:53:26 <Twey> Yeah
18:53:28 <Twey> *shudder*
18:53:30 <copumpkin> basically, it's a silly distinction
18:53:49 <kmc> i agree, but if you're going to make the distinction, it's certainly one about implementations and not languages
18:53:56 <drhodes> is there a way to search all the source of hackage?
18:53:56 <copumpkin> yep
18:54:07 <copumpkin> drhodes: download the massive tarball and grep -R
18:54:07 <drhodes> I should probably try before asking..
18:54:08 <copumpkin> :P
18:54:28 <kmc> how massive is it?
18:55:22 <c_wraith> heh.  out of curiosity, I started looking at the plugins library, as I was unclear on how to do dynamic loading in haskell.
18:55:36 <c_wraith> And of course, it starts with a link to a research paper dons produced.
18:57:12 <kmc> i think hs-plugins doesn't work anymore
18:57:15 <kmc> hint is more up to date
18:57:20 <kmc> still may be a good learning resource
18:57:23 <drhodes> it's only 80M
18:57:55 <copumpkin> that's a lot of bzipped source code
18:58:01 <drhodes> fo sho
18:58:11 <copumpkin> fo shizzle my nizzle?
18:59:05 <NutCobbler> I discovered that in /usr/local/lib/ is where the directory is installed for the module. If I go the route of modifing, cabal installing, then testing, could I back of trouble by deleting the lib/<project> directory?
18:59:21 <Twey> Wow, hint is cool.
19:06:01 <Cale> NutCobbler: Huh? Absolutely any language could be interpreted or compiled. There's no difference between the two. GHCi comes with both an interpreter and a compiler for Haskell.
19:06:53 <copumpkin> reductio ad authoritatem. you've already lost!
19:06:58 <stoop> Twey, what is hint?
19:06:58 <Cale> NutCobbler: In any case, if you modify that code, and update the version number in the cabal file, and then install the new version you created (which will compile it ;) things which require it can go on using the old version.
19:07:54 <lpjhjdh> I have some horribly repetetive functions that I'd like to automate creation of.  The function is written based on a type, is this something template haskell could be used for?
19:08:45 <stoop> How come a preprocessor is not part of Haskell?
19:09:09 <stoop> Even a simple preprocessor like the one in C.
19:09:33 <ivanm> there's cpp
19:09:45 <Twey> stoop: http://hackage.haskell.org/package/hint-0.3.1.0
19:09:48 <stoop> ivanm, well, I mean officially part of Haskell.
19:09:54 <Twey> There's Template Haskell.
19:09:56 <stoop> @cabal hint
19:09:56 <lambdabot>   bzzt.
19:10:03 <ivanm> @help cabal
19:10:03 <stoop> Damn you, lambdabot.
19:10:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:10:07 <Twey> Heh
19:10:14 <ivanm> is cabal actually a plugin?
19:10:26 <stoop> Twey, interesting.
19:12:12 <stoop> @help unlambda
19:12:12 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
19:12:17 <stoop> @help undo
19:12:17 <lambdabot> undo <expr>
19:12:18 <lambdabot> Translate do notation to Monad operators.
19:14:23 <lpjhjdh> stoop: LANGUAGE CPP gives you the c preprocessor
19:14:44 <stoop> lpjhjdh, I was wondering why it is not part of the standard.
19:19:34 <halcyon10> @hackage hint
19:19:34 <lambdabot> http://hackage.haskell.org/package/hint
19:19:57 <ivanm> stoop: it's part of the FFI standard IIRC
19:24:13 <kmc> stoop, for any complicated preprocessing, you might use Template Haskell
19:24:22 <kmc> err yeah Twey said that, sorry
19:24:36 <kmc> there is a lot of CPP in the std lib
19:24:46 <kmc> it would be nice to replace it with something also lightweight but a little nicer
19:27:21 <FunctorSalad> working concatenation would be a start ;)
19:28:03 <FunctorSalad> (#define F(X) my##X##Function = ...)
19:28:20 <kmc> anything like that is better done with TH imo
19:28:33 <kmc> the stuff C and C++ programmers do with macros...
19:28:35 <lpjhjdh> can ghci accept quasi-qutation?
19:28:39 <kmc> i wish C++ could metaprogram C++ easily
19:28:59 <FunctorSalad> kmc: yes TH is much better of anything complex
19:29:20 <FunctorSalad> the quotation is a bit *too* strict at times though, e.g. can't have free type variables
19:29:30 <FunctorSalad> (you can fake it with explicit 'forall' though)
19:30:24 <kmc> does TH handle all of GHC's extensions?
19:32:26 <FunctorSalad> no, most problematically no GADTs
19:32:37 <kmc> bummer
19:32:57 <FunctorSalad> (that is, you can't reify them)
19:33:37 <FunctorSalad> (or produce them for that matter)
19:33:47 <lpjhjdh> FunctorSalad: Is that for technical reasons or lack of work in the area?
19:34:09 <FunctorSalad> lpjhjdh: I don't know, but I don't think there's a fundamental problem
19:34:38 <FunctorSalad> probably need more manpower :)
19:34:54 <FunctorSalad> (or woman...)
19:35:08 <kmc> it seems you should be able to write a compiler in such a way that new features are automatically reifiable and AST-buildable
19:37:06 <FunctorSalad> kmc: the internal AST presumably isn't suitable
19:37:28 <kmc> how so?
19:38:59 <FunctorSalad> it's more detailed than the TH one http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/HsExpr.html
19:39:22 <FunctorSalad> but doesn't look that bad actually
19:39:54 <kmc> wow the data defn fits on one page
19:40:47 <FunctorSalad> that's just HsExpr
19:40:47 <luite> @pl f x y = (x+y)/2
19:40:47 <lambdabot> f = flip flip 2 . ((/) .) . (+)
19:41:10 <luite> hmm, I thought there was a better way
19:41:43 <FunctorSalad> kmc: but I don't know how TH is implemented
19:42:24 <stoop> ivanm, I see.
19:42:34 <FunctorSalad> > let f = ((/2) .) . (+) in f 2.0 3
19:42:35 <lambdabot>   2.5
19:42:41 <FunctorSalad> luite:
19:42:59 <e32> hope this isn't to off topic someone in #math said i should try here
19:43:01 <e32> f: <G,*> -> <H, o> is a bijection and f is a homomorphism f(a*b) = f(a) o f(b).  I need to show f^-1 is a homomorphism.   so, f^-1 is a bijection because f is.  then f(a) = a' and f(b) = b' so f^-1(f(a) o f(b)) = f^1(f(a*b)) = a*b   and f^-1(f(a) ) * f^-1(f(b)) = a*b.
19:43:09 <luite> FunctorSalad: ah that is a bit better, thanks
19:44:11 <e32> nevermind looks like i got an answer. sorry for using up your line space.
19:44:31 <kmc> haha we have a reputation
19:54:00 <blackdog> any TH gurus here? I'm trying to go from a String to the variable named by that string, and am not having a massive degree of success - I know it's not guaranteed typesafe at one level, as the variable may not in fact exist in the Haskell program, but surely that can be caught by the compiler...
19:54:15 <newbie> guys can anyone try to explain this little function i have
19:54:29 <kmc> yes, can you hpaste it?
19:54:36 <newbie> ok
19:55:15 <newbie> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4506#a4506
19:55:27 <FunctorSalad> blackdog: mkName
19:56:24 <kmc> newbie, you want an explanation of what this does?
19:56:29 <kmc> or do you have a more specific question
19:56:59 <newbie> i am so lost with ideas of parsers..i cant even try this function because when i type things it gives me bunch of errors
19:57:10 <kmc> (also i will be pedantic and point out that it's not actually a function... it doesn't have arguments or a type with (->) in it)
19:58:21 <kmc> newbie, i load your file into GHCi
19:58:23 <newbie> if i want to try it it I cant type this      parse parseInt "345"
19:58:36 <kmc> *Main> parseTest parseInt "345"
19:58:38 <kmc> 345
19:58:46 <kmc> "parse" wants some extra args
19:59:14 <newbie> yeawhere did you get parseTest from
19:59:22 <kmc> Text.Parsec.Prim
20:00:04 <kmc> *Main> parse parseInt "meaningless file name" "345"
20:00:05 <kmc> Right 345
20:00:16 <newbie> can you i waste some of your time to explain to me ideas of parsers
20:00:26 <newbie> i need to understand it but cant to comprehend it
20:00:42 <kmc> sure
20:00:54 <kmc> have you used parsers before, in any language or framework?
20:00:57 <newbie> no
20:00:58 <newbie> never
20:01:11 <kmc> do you understand generally what a parser does?
20:01:14 <newbie> no
20:01:31 <newbie> i am reading documentation on parsec but doesnt make it clear to me at all
20:01:51 <kmc> in the simple form, a parser turns strings into some other data type
20:01:55 <kmc> by interpreting syntax
20:01:55 <lpjhjdh> so in TH if I have something like "type A = forall x . B x" how do I go from A to "ForallT [x_0] [] (AppT ..."?
20:02:07 <newbie> ok...i have this data type that i defined
20:02:24 <kmc> so on one level, a parser for datatype A is a function String -> A
20:02:31 <kmc> but there are at least two complications:
20:02:50 <kmc> - there might be ambiguity in the grammar, i.e. multiple ways to interpret the syntax
20:02:50 <newbie> hso you have to write parser for datatype A
20:03:00 <kmc> - it might only consume part of the string
20:03:05 <newbie> i need it for very simple sintax..its for my assignment
20:03:06 <blackdog> FunctorSalad: so what can I do with a Name? TH is not gelling for me at the moment, I'm trying to work through the SPJ/Sheard paper
20:03:08 <kmc> so it's better to think of them as functions String -> [(A, String)]
20:03:20 <kmc> that is, it produces zero or more possible parses, where each one has some value it parsed and some remaining string
20:03:26 <kmc> :t reads
20:03:27 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:03:39 <kmc> this is how "reads" works, which is a very simple parser framework built into the haskell prelude
20:03:41 <FunctorSalad> blackdog: pass it to VarE, ConE, VarP,  ConP etc
20:03:49 <kmc> so, you'd like to build bigger parsers from smaller ones
20:04:00 <newbie> well we have some data type
20:04:15 <FunctorSalad> E is expression, P pattern
20:04:20 <newbie> then we will get simple one sentence program that will be parsed into data type
20:04:21 <kmc> i.e., if you want to parse "(3, 4)" into the tuple (3,4), you'd have a parser for expressions, and when you run into the parentheses, you recursively invoke that parser to parse each of the components
20:04:40 <kmc> and it's cumbersome to wire together functions of type String -> [(A, String)]... that's why we use monads to simplify the plumbing
20:05:10 <kmc> newbie, did you already define the haskell datatype you want to parse into?
20:05:18 <newbie> yes
20:05:24 <kmc> can you hpaste it?
20:05:35 <newbie> yes
20:06:52 <blackdog> FunctorSalad: ok, I think i'm making progress. got this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11294#a11294
20:07:21 <blackdog> can you turn an Exp into an ExpQ?
20:07:35 <FunctorSalad> ExpQ = Q Exp
20:07:43 <FunctorSalad> so, with 'return'
20:08:11 <newbie> kmc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4507#a4507
20:08:23 <kmc> cool
20:08:26 <blackdog> FunctorSalad: fantastic. thank you, it's working beautifully now.
20:08:40 <kmc> so the second question is, what does the concrete syntax for this language look like?
20:09:17 <blackdog> I suppose it would probably be overreaching to try to redefine string syntax...
20:09:21 <newbie> its just one sentence
20:10:42 <newbie> so lets say if syntax is "while not(SomeStatement) do something"
20:11:16 <kmc> (small thing: your constructor "Nothing" will conflict with the standard Nothing :: Maybe a)
20:11:33 <newbie> yeah i can change that to Nope lets say
20:11:36 <kmc> :)
20:11:54 <newbie> thanks man i am so lost on this...i just need to make some steps so i can work on it
20:11:57 <kmc> newbie, Text.Parsec.Language may be useful
20:12:11 <kmc> it will do the lowest level parse for you, of generating "tokens"
20:12:30 <newbie> then i can go from there
20:12:34 <kmc> yeah
20:12:41 <kmc> you'll want a parser for Program, and one for Statement
20:12:50 <newbie> yes
20:12:52 <kmc> and they will be recursive like expected
20:13:05 <kmc> (also, your Statement datatype has no base case)
20:13:26 <newbie> i can write that.....some terminating case
20:13:45 <kmc> newbie, did you design this language or was it given to you
20:13:51 <newbie> given to me
20:13:54 <kmc> okay
20:15:22 <dancor> isn't it kind of insane that multicore is only achievable with a RTS option?
20:15:58 <kmc> how so
20:16:16 <newbie> what you mean
20:16:35 <sjanssen> dancor: it would be nice to have something in GHC.Conc to increase the number of capabilities
20:16:48 <idnar> the average user of a program isn't going to have any clue that they can/need to pass RTS options to some program they want to use
20:17:09 <idnar> heck, the average user probably doesn't even know how many CPU cores they have
20:17:10 <luite> dancor: you can change the default RTS options as a workaround
20:17:12 <blackdog> so i gather that with TH, it's not possible to take an arbitrary string at compile time and turn it into an Exp?
20:17:19 <idnar> neither does the developer
20:17:23 <kmc> blackdog, you'd need a parser for that
20:17:26 <kmc> which is outside the domain of TH
20:17:27 <idnar> (know how many cores their users will have)
20:17:33 <sjanssen> dancor: IIRC, somebody is working on an option to automatically set capabilities
20:17:34 <kmc> but there are some, e.g. Language.Haskell  and GHC API
20:17:44 <luite> idnar: ghc 6.12 at least has a +RTS -N option which automatically detects the number of threads
20:17:48 <c_wraith> blackdog: you can, but you need to parse it first
20:17:49 <luite> not sure if that's in 6.10
20:17:56 <sjanssen> luite: ah, that's what I'm thinking of
20:18:01 <idnar> luite: why isn't that the default?
20:18:28 <luite> don't know, but you can make it the default by linking an file with the rts options
20:18:33 <c_wraith> blackdog:  once you have what you want inside TH, you can use lift to create the Exp structure for it.
20:18:36 <blackdog> ok, but you can get TH to run the parser?
20:18:38 <kmc> blackdog, the haskell-src-meta package would be useful
20:18:45 <blackdog> right. i'll check that out. thanks.
20:19:43 <blackdog> this really is some heavy machinery just to do string interpolation:)
20:20:31 <luite> what is a good introduction/tutorial for TH?
20:21:04 <kmc> blackdog, so it goes in a static language
20:21:21 <kmc> blackdog, did you look at GHC's quasiquoting feature also?
20:21:45 <blackdog> kmc: in TH?
20:21:55 <kmc> it's described in the GHC manual
20:22:14 <blackdog> Yeah, but i think i still need the parser, otherwise i have to build it in the (LamE VarE blah blah) format, right?
20:22:29 <newbie> kmc would it be possible to show me example of parser for And
20:22:37 <newbie> and i will try it then for other
20:23:06 <kmc> blackdog, correct, you have to write a parser to use quasiquoting
20:23:14 <kmc> it wouldn't be that different from what you have now
20:23:35 <kmc> but, maybe there is a nicer way to write these things
20:23:45 <kmc> where the haskell code is a TH quote rather than a string
20:23:48 <blackdog> kmc: how is that different to just using the haskell-src-meta package you pointed me at?
20:24:07 <kmc> you could use them together
20:24:22 <blackdog> oh, right. yes, that make sense.
20:24:42 <Stud_ent> > 2^2
20:24:43 <lambdabot>   4
20:24:44 <blackdog> ah, it's mmorrow's. i think i owe that dude many beers.
20:24:44 <kmc> quasiquoting lets you use strings in a special way as both expressions and patterns.  you write a parser which turns the string into a pattern or exp in TH
20:24:47 <kmc> so you would use -meta
20:24:50 <Stud_ent> > 2^100
20:24:52 <lambdabot>   1267650600228229401496703205376
20:24:56 <blackdog> kmc: yep. makes sense.
20:25:08 <Stud_ent> > 2^32
20:25:13 <lambdabot>   4294967296
20:25:21 <Stud_ent> > 2^1
20:25:22 <lambdabot>   2
20:25:24 <Stud_ent> > 2^2
20:25:25 <lambdabot>   4
20:25:31 <Stud_ent> > 2^9808383474838923475
20:25:32 <kmc> > (-2) ^ (-2)
20:25:47 <kmc> > let 2 ^ 2 = "happytime!" in 2 ^ 2
20:25:49 <lambdabot>   * Exception: Negative exponent
20:25:49 <lambdabot>   mueval: ExitFailure 1
20:25:50 <lambdabot>   "happytime!"
20:25:58 <Stud_ent> > (2)^(-3)
20:26:00 <lambdabot>   * Exception: Negative exponent
20:26:30 <Stud_ent> what the hell?
20:26:36 <kmc> :t (^)
20:26:38 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:26:38 <kmc> :t (**)
20:26:39 <lambdabot> forall a. (Floating a) => a -> a -> a
20:26:41 <Stud_ent> > 1 / (2^(-4))
20:26:42 <lambdabot>   * Exception: Negative exponent
20:26:47 <kmc> > 2 ** (-4)
20:26:49 <lambdabot>   6.25e-2
20:26:58 <Stud_ent> negative exponent exception?
20:27:02 <Stud_ent> haskell stoopid
20:27:15 <kmc> yes partial functions are stupid
20:27:26 <sjanssen> Stud_ent: try (^^) instead
20:27:27 <kmc> (^) :: (Num a, Integral b) => a -> b -> Maybe a
20:27:55 <Stud_ent> > 1 / (2^^(-3))
20:27:56 <lambdabot>   8.0
20:27:57 <blackdog> kmc: would be sort of annying to have (/) :: Num a => a -> a -> Maybe a...
20:28:11 <Stud_ent> word
20:28:25 <Stud_ent> What's the upper bound on haskell #'s?
20:28:25 <blackdog> although / is in Rational or Fractional, i suppose
20:28:26 <kmc> but... soundness!
20:28:34 <blackdog> > :t (/)
20:28:35 <lambdabot>   <no location info>: parse error on input `:'
20:28:38 <kmc> Stud_ent, you mean numerical types?
20:28:39 <sjanssen> blackdog: then I'd want instance Num a => Maybe a :)
20:28:45 <Stud_ent> yes
20:28:45 <Gracenotes> you may prove your programs sound with an == 0 check
20:28:46 <kmc> Integers are unbounded
20:28:47 <ddarius> > maxBound :: Integer
20:28:48 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
20:28:48 <sjanssen> erm, instance Num a => Num (Maybe a)
20:28:48 <lambdabot>    arising...
20:29:00 <Stud_ent> Interesting, how does GHC compute large integers?
20:29:01 <kmc> Ints are machine size, guaranteed to be at least 2^29 or 2^30 or something
20:29:04 <kmc> > maxBound :: Int
20:29:05 <lambdabot>   9223372036854775807
20:29:24 <ddarius> sjanssen: Conal has already written it.
20:29:28 <Stud_ent> That doesn't make sense though, as I have typed in 999^9999 into GHCI, and gotten a result
20:29:37 <kmc> > 999^9999
20:29:38 <lambdabot>   452185645415902363718328227712673544054723792469156654365365177828057046716...
20:29:43 <kmc> > (999 :: Int) ^ (9999 :: Int)
20:29:44 <lambdabot>   -3016001140647576489
20:29:48 <Gracenotes> Stud_ent: hm, why is that odd?
20:30:04 <Stud_ent> Guess it's not, Haskell's type inference
20:30:23 <kmc> the type defaulting mechanism probably makes it an Integer by default
20:30:26 <Gracenotes> by default, Num stuff is the unbounded Integer, unless Haskell can tell otherwise (or tell it's floating point)
20:30:31 <kmc> it's actually not so much inference as a weird extra ad-hoc thing
20:31:32 <Gracenotes> if you have a compiled main method, main = print (999^999), Haskell will do the same thing and go with Integer
20:31:37 <Gracenotes> GHC at least
20:31:56 <ddarius> Gracenotes: Every (conforming) implementation will.
20:32:13 <Gracenotes> ah. interesting
20:33:30 <kmc> i think defaulting is in the spec
20:33:40 <ddarius> It is.
20:34:07 <newbie> kmc all that function does is taking characthers out of string
20:35:09 <kmc> ?
20:35:27 <ddarius> removeCharacters = filter (const True)
20:35:29 <newbie> like function i showed you takes input string'
20:35:39 <ddarius> Er False
20:35:45 <newbie> and and prints it out
20:35:46 * ddarius always inverts the sense of filter.
20:36:14 <Gracenotes> eh, LISP gets it right. (for some definitions of "right")
20:36:15 <blackdog> ddarius: it makes more sense to filter things out than to filter them in...
20:36:19 <sjanssen> removeCharactersSometimes = filterM (const [True, False])
20:36:28 <blackdog> the ruby 'select' method makes more sense to me...
20:36:47 <ddarius> keepIf = filter
20:37:41 <ddarius> removeCharactersSometimes = filterM (const (True `mplus` False))
20:37:52 <ddarius> + return
20:38:10 <SubStack> > filter ((==0) . (`mod` 2)) [1..10]
20:38:11 <lambdabot>   [2,4,6,8,10]
20:40:37 <ddarius> > filter even [1..10]
20:40:51 <blackdog> s
20:40:54 <blackdog> @seen mmorrow
20:41:24 <lambdabot>   [2,4,6,8,10]
20:41:24 <lambdabot> Unknown command, try @list
20:41:38 <ddarius> preflex: seen mmorrow
20:41:38 <preflex>  mmorrow was last seen on #haskell 2 hours, 34 minutes and 5 seconds ago, saying: haskell-src-meta does a translation between haskell-src-exts AST -> TH AST
20:42:13 <blackdog> ah, thanks.
20:43:34 <ddarius> @listmodules
20:43:34 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact free fresh ft haddock help hoogle instances irc karma localtime more oeis offlinerc pl pointful poll pretty quote search
20:43:35 <lambdabot> slap source spell state system tell ticker todo topic type undo unlambda unmtl version vixen where
20:43:56 <ddarius> @list activity
20:43:56 <lambdabot> activity provides: activity
20:44:55 <kmc> @babel
20:44:55 <lambdabot>   bzzt.
20:45:21 <ddarius> @babel jp en hito
20:45:21 <lambdabot> Plugin `babel' failed with: Error: Language jp not supported
20:45:44 <mmorrow> blackdog: hey
20:45:45 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:46:12 <blackdog> mmorrow: hey. just poking haskell-src-meta
20:46:20 <blackdog> can't build on 6.12, afaict
20:46:33 <mmorrow> blackdog: gah, so in 6.12 the TH library got some non-trivial changes
20:46:43 <mmorrow> blackdog: yeah, the AST is different
20:46:48 <blackdog> ah, that's a pain
20:47:10 <mmorrow> blackdog: haven't updated any of my stuff for 6.12 yet, although i need to start doing that soon..
20:47:43 <blackdog> fair enough.
20:47:48 <mmorrow> on the plus-side, now it has type/data families and iirc kinds
20:47:57 <mmorrow> still no GADTs unfortunately though
20:48:04 <blackdog> i need 6.12 for the dylib stuff, so i can't downgrade :/
20:48:33 <blackdog> but with haskell-src-meta, you can really start doing all kinds of cool metaprogramming.
20:48:37 <mmorrow> blackdog: i'll take a peek at the new AST and see how much work it'll be. it could turn out to be trivial..
20:48:44 <ddarius> blackdog: Make a patch.
20:50:14 <blackdog> mmorrow: are you going to look at it soon? i'm happy to have a go at it, but if it's already on your list there might not be much point
20:50:58 <luite> is there a way to make some part of the source compiler version dependent?
20:51:03 <blackdog> would you just use #if to test for the version of TH you want?
20:51:30 <ddarius> luite: Stick all the compiler dependent stuff in a module and use CPP.
20:51:47 <mmorrow> blackdog: looking at it now
20:52:03 <blackdog> mmorrow: i must owe you a case by now at least.
20:53:05 <ivanm> blackdog: you mean a slab (and thus making it more aussie)? :p
20:53:42 <mmorrow> blackdog: :)
20:54:14 <blackdog> ivanm: do any good beers come in slabs? i wouldn't buy him VB or XXXX, it might kill him.
20:54:24 <ivanm> heh
20:54:28 <ivanm> hahn?
20:54:33 <ivanm> crownies probably don't...
20:54:49 <luite> ddarius: ah thanks, found the name of the macro in the manual
20:55:46 <newbie> kmc is there any tutorial anything at all that covers material that i need ....all i have found is about parsers but in general
20:56:15 <kmc> newbie, check out Write Yourself a Scheme in 48 Hours
20:56:38 <newbie> i am so lost on this i dont even know what do i need....
20:56:50 <kmc> it has a section on parsing
20:57:12 <newbie> does it cover the issue i told you about
20:57:22 <newbie> all thisngs about parsers are so abstratc
20:57:40 <kmc> which issue in particular?
20:57:40 <blackdog> mmorrow: is there a greedy version of your parsers that return the unconsumed section?
20:58:22 <mmorrow> blackdog: they use the haskell-src-exts parser, which is a happy parser
20:58:34 <newbie> to write parsers that will parser syntax into my data type
20:59:03 <blackdog> mmorrow: so if there's trailing garbage, it'll just fail?
20:59:11 <mmorrow> blackdog: so i don't know of any way to do that
20:59:17 <mmorrow> blackdog: i think so, yes
20:59:43 <ivanm> newbie: what kind of data structure are you wanting to create/parse?
20:59:58 <ivanm> newbie: maybe read through the parsing chapter in RWH?
21:00:00 <mmorrow> blackdog: i've done a quicky quasiquoter that pulls out the contents of "$(..here...)" to parse, then splice them before
21:00:13 <blackdog> mmorrow: i guess if i just count brackets or something, i should be ok.
21:00:18 <mmorrow> blackdog: http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.6/doc/html/src/Language-Haskell-Meta-QQ-HsHere.html
21:00:29 <mmorrow> blackdog: right, that's basically what i did
21:00:31 <Cale> newbie: You might start with the old user's guide for Parsec (http://legacy.cs.uu.nl/daan/download/parsec/parsec.html). Even though lots of new stuff has been added to parsec, it's still mostly accurate, except the module names have changed a bit.
21:00:46 <Cale> In any case, it's a pretty good intro to combinator parsing libraries
21:01:00 <mmorrow> , let x = [0..4] in [$here|[0..4] is $([0..4]) and $(x)|]
21:01:04 <lunabot>  "[0..4] is [0,1,2,3,4] and [0,1,2,3,4]"
21:01:14 <mmorrow> blackdog: ^ is that QQ
21:02:00 <kmc> wait what just happened
21:02:15 <kmc> what does the here qq do?
21:02:37 <mmorrow> kmc: it extracts haskell code, parses it, turns it into template-haskell, then splices that into a string
21:02:41 <Cale> kmc: makes a string and interpolates showable values into it?
21:02:54 <mmorrow> kmc: this is the source http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.6/doc/html/src/Language-Haskell-Meta-QQ-HsHere.html
21:02:56 <ivanm> yet again I've found a generic website that claims that haskell libs are for macs...
21:02:59 <mmorrow> kmc: (it's not very long)
21:03:11 <Cale> ivanm: huh?
21:03:21 <ivanm> http://mac.wareseeker.com/screenshot/polyparse-1.3.exe/c7645514f
21:03:46 <ivanm> softpedia also classifies most haskell libraries are mac software
21:03:47 <ivanm> :s
21:03:55 <mmorrow> kmc, blackdog: the action happens in the `liftHere' function (liftHere :: Here -> ExpQ)
21:03:59 <kmc> that sounds like the thing blackdog wanted to write
21:04:13 <blackdog> mmorrow: I think it might be what i need, actually
21:04:23 <Gracenotes> I approve of today's xkcd
21:04:28 * kmc learned something today, as always
21:04:31 <blackdog> kmc: i am utterly delighted that it exists already :(
21:04:33 <blackdog> :)
21:04:49 <kmc> in Iowa they trick-or-treat on the 30th
21:04:52 <kmc> true story
21:04:54 <mmorrow> blackdog: nice
21:05:12 <ivanm> Gracenotes: rather culture-specific though
21:06:03 <Gracenotes> although coincidentally, the same culture the author lives in
21:06:09 <ivanm> true
21:06:33 * ivanm was irritated when he saw halloween-related decorations and advertising at the shops yesterday :@
21:06:37 <mmorrow> blackdog: one thing i just realized, is that if you want to use TH syntax w/in the splice of that here QQ themselves, the parser would need to turn \|] into |], since you'd need to escape that like that because GHC handles QQs in the lexer, and it needs some help
21:07:10 <mmorrow> , [$here|asdf $([|x|])|] {- will think "..x|]" ends the QQ -}
21:07:11 <lunabot>  luna: parse error on input `|]'
21:07:30 <mmorrow> , [$here|asdf $([|x\|])|] {- my parser doesn't strip that backslash -}
21:07:33 <lunabot>  luna: Exception when trying to run compile-time code:
21:07:48 <mmorrow> but that would be easy enough to do
21:07:56 <kmc> , [$here|two plus two is $(2+2)|]
21:07:59 <lunabot>  "two plus two is 4"
21:08:36 <mmorrow> and you could make the return type of that QQ anything, i just chose String for this particular case
21:09:05 <mmorrow> (by wrapping parsed TH syntax that will be spliced in ===> \e -> [|show $(return e)|])
21:09:14 <Cale> ivanm: hehe
21:09:22 <mmorrow> show the expression must evaluate to something with a Show instance
21:09:29 <Cale> ivanm: It tries to sell it so hard.
21:09:38 <ivanm> Cale: yeah, we never used to have anything to do with halloween here
21:09:38 <Cale> "polyparse 1.3 is an ideal tool for programmers."
21:09:49 <ivanm> oh, wait, the other comment ;-)
21:10:12 <ivanm> Cale: I've had an email from someone asking me for a windows version of the "mac encoding only" library I wrote;
21:10:30 <Cale> WareSeeker periodically updates pricing and software information of polyparse 1.3 full version from the publisher, so some information may be slightly out-of-date. You should confirm all information before relying on it. Software piracy is theft, Using crack, password, serial numbers, registration codes, key generators is illegal and prevent future development of polyparse 1.3 Edition. Download links are directly from
21:10:30 <Cale>  our publisher sites, torrent files or links from rapidshare.com, yousendit.com or megaupload.com are not allowed
21:10:42 <ivanm> even though it was actually GraphSCC by Iavor
21:10:45 <Cale> "full version"
21:10:57 <ivanm> Cale: heh
21:11:06 <blackdog> mmorrow: hold up, man, i'm still trying to understand the rest of your code:)
21:11:17 <ivanm> it's called WAREseeker, but says that using cracks, etc. are illegal... >_>
21:12:00 <Cale> d00d, I h4v3 l33t 0-day H45k311 w4r3z
21:12:17 <ivanm> "0-day" == "cracked on day of release"?
21:12:26 <monochrom> yes
21:12:27 <Cale> yeah
21:12:38 <QtPlatypus> ivanm: Its for hunting down lycanthropes?
21:12:58 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html <-- t3h b357 h45/<311 w4r3z 0n t3h n3t.
21:13:00 <monochrom> One thing you know, the crackers get their numbering right. :)
21:13:20 <ivanm> Cale: heh
21:13:44 <ivanm> though http://hackage.haskell.org/package/ is shorter
21:13:59 <Cale> That's what hackageDB needs! A green on black or red on black colour scheme with lots of <marquee> tags!
21:14:26 <Cale> and l33t5p34k
21:14:39 <dolio> And flames.
21:14:42 <monochrom> sounds like geocities
21:15:01 <ivanm> monochrom: we can call it geocities 2!!!
21:15:07 <luite> unfortunately (?) marquee deosn't work in firefox
21:15:14 <monochrom> and "this page under construction" twice, once top once bottom
21:15:39 <Cale> and some flaming skulls
21:15:44 <scutigera> and make pirated copies of ghc available
21:15:59 <Cale> with huge inappropriate photoshop lens flares
21:16:04 <ivanm> monochrom: did you see xkcd's geocities tribute re-design?
21:16:28 <monochrom> Yes I did. Lovely.
21:16:28 <luite> scutigera: wanna trade donglecracked ghc for latest parsec?
21:17:20 <ivanm> pirate GHC == embedded GMP under a non-free license? :p
21:17:22 <mmorrow> blackdog: ok, here's a dir with the old TH ast, the new TH ast, and a diff of them http://moonpatio.com/repos/th-api/
21:17:28 <mmorrow> http://moonpatio.com/repos/th-api/TH_API_DIFF.hs
21:17:33 <monochrom> "Please enter your 1024-byte ghc registration key"
21:17:34 <mmorrow> blackdog: not bad
21:18:21 <monochrom> As a tribute to blackdog, let's talk about jailbreaked ghc. :)
21:18:28 <luite> "your ghc has not passed genuine validation"
21:18:35 <Cale> "Please enter the 37th letter on the 5th line of the 17th page of the GHC user's guide"
21:18:36 <ivanm> monochrom: hmmm?
21:18:50 <ivanm> Cale: heh
21:19:02 <blackdog> mmorrow: you are staggeringly helpful. thank you.
21:19:28 <mmorrow> ;)
21:21:24 <mmorrow> the "meld" diff viewer is sweet
21:22:16 <scutigera> luite: gee I don't know, can I watch teevee on parsec ?
21:24:24 <scutigera> anybody used gl/glut under haskell.  is it a relatively pleasant experience ?
21:25:28 <kmc> yeah
21:25:35 <kmc> it's imperative programming
21:25:40 <kmc> but haskell is a fine imperative language
21:26:09 <scutigera> monads for everyone !
21:26:22 <kmc> it's nice to be able to pass around imperative code as first-class values
21:26:30 <luite> if found it a relately unpleasant experience to get freeglut working on windows, but other than that it seems to be ok (have only done some simple things though)
21:26:40 <kmc> GL on windows is a pain in any language
21:27:16 <scutigera> well if you can get to simple things that's a good sign.  the libraries appear to be relatively mature, or there's version inflation going on.
21:28:36 <scutigera> I know I used a hackage for cairo, and it worked quite well.
21:29:12 * ivanm thought cairo came with gtk2hs...
21:30:35 <scutigera> my bad, it was hgl.
21:31:29 <scutigera> I was thinking about an ML FFI I wrote for cairo. that worked well too :-)
21:31:42 <blackdog> mmorrow: not quite sure what's going on with the switch from Cxt going from [Type] to [Pred], though.
21:33:23 <mmorrow> blackdog: ah, before Type was getting re-used for class contexts, so i guess now that equality constraints are in there, Type didn't cut it
21:35:53 <AppleBoy> I have a function who's input is [[Int]], if I use (x:xs) how can I access the elements inside of x in that function?
21:36:30 <AppleBoy> so if I have [ [1], []. [] ] as input, how can I access the 1?
21:36:36 <hexpuem> rewrite it in terms of map or fold
21:36:55 <AppleBoy> can't use map or fold
21:37:00 <hexpuem> lies!
21:37:02 <kmc> AppleBoy, you can write nested patterns
21:37:16 <kmc> > let ((x:xs) : ys) = [[1,2],[3,4]] in (x, xs, ys)
21:37:17 <lambdabot>   (1,[2],[[3,4]])
21:37:38 <kmc> AppleBoy, if you don't want to stuff it all together, use a "case" expression within your function body
21:37:40 <AppleBoy> ah
21:37:58 <kmc> @src concat
21:37:58 <lambdabot> concat = foldr (++) []
21:39:31 <hexpuem> (map.map) (+1) [[1],[2]]
21:42:29 <_Ray_> Weird question. I have a String, such as "the quick brown fox jumps over the lazy dog". I want to get the longest word in this string. Without separating the String into a [String] of words, without using buffers (storing a String of the current largest word), without using higher order functions or lists by comprehension, and without using more advanced haskell functions than elem or head/tail, is there any way to do this?
21:43:02 <_Ray_> What I have now separates it into a [String], gets the greatest length of the String elements, and then searches for a String with that length in the [String].
21:43:09 <ivanm> _Ray_: ummmm..... wtf?
21:43:13 <_Ray_> It's extremely ugly, and not "functional" at all.
21:43:28 <ivanm> _Ray_: maximumBy (compare `on` length) . words
21:43:32 <sjanssen> _Ray_: why?
21:43:40 <tommd> _Ray_: Just traverse the string once, counting non-whitespace characters and zeroing the count when you hit whitespace.   What's the issue?
21:43:45 <_Ray_> ivanm, "without using more advanced haskell functions than elem or head/tail"
21:43:48 <ivanm> sjanssen: maybe he's feeling masochistic? :p
21:43:52 <HayashiRazan> I just want people who study Haskell to be patient, and take their time even if they mess up. Dont think of competing...dont rush..
21:43:57 <sjanssen> (doing homework most likely)
21:43:58 <hexpuem> none of those are advanced
21:43:58 <_Ray_> It's for an introduction to algorithms course.
21:43:59 <ivanm> _Ray_: so, you get the code form those ans write it out yourself! ;-)
21:44:08 <ivanm> _Ray_: ahhh
21:44:11 <HayashiRazan> :t _Ray_
21:44:12 <lambdabot> Not in scope: `_Ray_'
21:44:18 <_Ray_> hexpuem, yes they are. Much more than length, head or elem.
21:44:35 <hexpuem> tell your book i said to fuck off
21:44:36 <hexpuem> haha
21:44:42 <tommd> _Ray_: This is homework, yes?
21:44:50 <_Ray_> It's study material for the midterm, yes.
21:44:54 <tommd> hexpuem: Keep this a kind channel.
21:45:06 <hexpuem> books have no rights
21:45:06 <HayashiRazan> You can't rush Haskell...its not an imperative rapist
21:45:11 <ivanm> @slap hexpuem
21:45:11 * lambdabot is overcome by a sudden desire to hurt hexpuem
21:45:15 <ivanm> tommd: agreed
21:45:21 <_Ray_> I can paste what I currently have, but beware: It's disgusting. It works, but it's as un-functional as the IOCCC'est of Cs.
21:45:31 <kyagrd> Why on earth does midterm ask you that? That's so sadistic.
21:45:37 <tommd> _Ray_: We see ugly code all the time - we're here to help.
21:45:59 <_Ray_> Oh, and one caveat. It's in Spanish :D. I can translate it though, if need be.
21:46:05 <tommd> kyagrd: Some prof who might be performance concerned... or might be trying to force them to use a fold?  But that would be advanced!
21:46:25 <kyagrd> I mean it doesn't cost that much making new [String] after all since they share nodes it does not copy buffer :(
21:46:37 <tommd> _Ray_: You are free to stay, but FYI I think there is a Spanish Haskell channel.
21:46:45 <ivanm> tommd: my guess is because it's fundamentals they're meant to be learning
21:47:03 <HayashiRazan> I know you didn't study too much in school Ray
21:47:06 <_Ray_> I don't have issues communicating in English, but the function names will be unintuitive XD I'll spread some comments around.
21:47:14 <_Ray_> HayashiRazan, wtf? O.o
21:47:20 <HayashiRazan> if Haskell is the first major thing you've studied, then let it warp ur brain
21:47:29 <HayashiRazan> wash yourself in it
21:47:29 <kyagrd> if it were something like a bytestring buffer it would have made more sence but String in Haskell is just [Char] from the beginning
21:47:45 <kyagrd> s/sence/sense/
21:48:06 <HayashiRazan> so lambdabot, kyagrd is of what typeclass?
21:48:21 <_Ray_> HayashiRazan, it isn't, that's the problem :)
21:48:29 <tommd> kyagrd: yeah, I know.  Some people have weird ideas though and thought maybe the prof is a bit odd.  But Ivanm is probably right - he is probably trying to get them to learn fundamentals (but the wrong way, imho).
21:48:37 <_Ray_> I've been doing procedural/OOP code for about...10 years now.
21:49:05 <sjanssen> _Ray_: any solution that fits the constraints is going to be long and ugly
21:49:17 <hexpuem> it shouldnt be that bad
21:49:44 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11295#a11295 <-- abortion of a code
21:49:49 <sjanssen> this sounds to me like one of those programming assignments that the professor didn't attempt before assigning to students
21:50:28 <kyagrd> _Ray_: the standard way is to make a tail recursive function with another argument which is a pair of integers
21:50:56 <_Ray_> I was thinking about doing that  - one integer for the greatest length so far, one for the length of the current word being scanned?
21:51:01 <kyagrd> _Ray_: First, try to program a tail recursive version of a string length function with an integer accumulator
21:51:27 <kyagrd> and then change the addiotional argument of your aux function into a piar to do what you want
21:51:30 <_Ray_> f [] = 0; f (x:xs) = 1 + (f xs)
21:51:31 <kyagrd> That will do.
21:51:39 <hexpuem> @src maximum
21:51:45 <HayashiRazan> > f [] = 0; f (x:xs) = 1 + (f xs)
21:51:56 <e32> kmc: /join #kernel
21:52:08 <e32> oh sorry typo
21:52:39 <HayashiRazan> so wait, it says let f be an empty list
21:52:57 <HayashiRazan> and that f is a list that adds an element
21:53:01 <HayashiRazan> to the tail?
21:53:05 <HayashiRazan> ???
21:53:11 <_Ray_> It says f, applied to [], is 0.
21:53:37 <_Ray_> And f, applied to anything that matches (x:xs), meaning x followed by a (possibly empty) list, is 1 + (f xs)
21:54:19 <lambdabot> maximum [] = undefined
21:54:19 <lambdabot> maximum xs = foldl1 max xs
21:54:19 <lambdabot>   <no location info>: parse error on input `='
21:54:46 <hgolden> _Ray_: You need two items with tail recursion: The remaining string and the longest string found so far.
21:55:28 <kyagrd> _Ray_: Oh, I was wrong it does make a whole copy characters actually
21:55:31 <kyagrd> when using words
21:55:46 <_Ray_> Performance isn't something we care about in the course
21:55:51 <sjanssen> hgolden: I don't think that's allowed, no "buffers"
21:55:54 <_Ray_> That'll come later
21:56:09 <hgolden> sjanssen: No buffer is needed.
21:56:23 <hgolden> It's all done with recursion.
21:56:46 <kyagrd> hgolden: I think sjanssen: means that it as a lenght 2 buffer of Ints
21:56:47 <ivanm> s/recursion./magic!/
21:56:56 <kmc> _Ray_, welcome back :)
21:57:02 <sjanssen> hgolden: "without using buffers (storing a String of the current largest word)"
21:57:05 <hgolden> kyagrd: No ints are needed either
21:57:09 <sjanssen> hgolden: oh, you mean store indices instead?
21:57:26 <hgolden> You don't store it. You use recursion.
21:57:27 <kyagrd> sjanssen: ints are okay since it's not a [String]
21:57:34 <_Ray_> So I walk through the string, make a counter which says "current string length" (let it be 'cur'), and a "maximum length found so far" (let it be 'm'). When I find a ' ', I compare m to cur, and if cur is greater, I recurse with cur as my new m, and 0 as my new cur. Else, I recurse with m, as my new m, and 0 as my new cur.
21:58:00 <sjanssen> hgolden: passing as parameter to a function counts as storing
21:58:11 <hexpuem> haha
21:58:26 <_Ray_> kmc, thanks :) I finished the exercises but I'm trying not to be heretic and do them without faking state to avoid thinking functionally.
21:59:02 <hgolden> sjanssen: That's not how I read the initial problem statement.
21:59:11 <_Ray_> So once I have the greatest length of a word, I search my string again for a word that has this length?
21:59:36 <sjanssen> hgolden: well, when else are you "storing" in Haskell?
21:59:42 <hgolden> _Ray_: No. Let me explain.
21:59:48 <hexpuem> your state is the parameters to the function
22:00:20 <hgolden> sjanssen: an argument to a function is NOT a buffer.
22:00:27 <kyagrd> sjanssen: well when using Ptr things :)
22:00:36 <_Ray_> hexpuem, yeah, but there's a difference between a counter integer and storing the currently-being-looked word and pass it over to the func over and over, discarding and re-creating when new words are found
22:00:56 <_Ray_> At least, it seems that way O.o
22:01:34 <sjanssen> hgolden: meh.  It's a dumb problem statement, so there's really no point in us discussing the semantics behind it
22:01:43 <hgolden> _Ray_: You don't need an integer. You don't need a counter. Stop and think about this.
22:01:46 <sproingie> what's the problem?
22:01:57 <kmc> there is always state of some kind... the functional way is that you don't *update* state in place; you make new state and do something new with it
22:01:58 <hexpuem> how to light a barbique without fire
22:02:22 <hgolden> _Ray_: Start with the initial conditions: You have the whole string and the longest string found is a null string.
22:02:25 <sproingie> electricity works nice for that
22:02:29 <kmc> _Ray_, did you paste your code?
22:02:33 <_Ray_> kmc, yep. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11295#a11295
22:02:46 <_Ray_> (Beware: seizures may happen)
22:02:48 <hexpuem> electricity is blasphemous
22:02:57 <kmc> wow those are some long function names :)
22:03:10 <hgolden> _Ray_: Then you find the next string in the current string.
22:03:27 <sproingie> holy verbose portugese variable names
22:03:34 <kmc> spanish i think
22:03:42 <hgolden> _Ray_: Then you compare the length of the string you just found to the length of the longest string found so far.
22:03:50 <kmc> so there are two things: break a string into words, and find the longest?
22:04:15 <sproingie> cant be to just find the longest word in a string
22:04:16 <sproingie> that's a one-liner
22:04:20 <_Ray_> kmc, I'm trying to do it without breaking the string into words first - that's the exercise after this one (so it's implied I shouldn't use it)
22:04:21 <hgolden> kmc: You don't have to break the string into words first. You do it on the fly.
22:04:33 <kmc> :t dropWhile
22:04:35 <kmc> :t break
22:04:35 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:04:35 <ivanm> sproingie: he can't use folds, etc.
22:04:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:04:50 <hexpuem> just stop and think about it for a while again
22:04:54 <hexpuem> peoples ideas are probably distracting you
22:04:55 <hgolden> I'll finish to point shortly. Have to go for 10 minutes.
22:04:55 <hexpuem> more than helping
22:04:56 <hexpuem> haha
22:05:05 <sproingie> @src foldl
22:05:05 <lambdabot> foldl f z []     = z
22:05:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:05:07 <kdc> Hi, is there any reason haskell uses `div` in place of (e.g.) // and `mod` instead of %? I've been just defining them in my programs so far.
22:05:08 <_Ray_> hgolden, and in both cases I "walk" the string to the beginning of the next word?
22:05:09 <phr> yikes, SElinux throws security alerts when i try to compile darcs?
22:05:14 <sproingie> there, now reinvent fold
22:05:34 <hexpuem> yea just cut and paste the stdlib dependencies for the 1-liner lol
22:06:08 <_Ray_> Hrm. I guess I could do that...*goes to code*
22:06:15 <Cale> kdc: Probably just convention. % is used as a constructor for rational numbers
22:06:39 <Cale> kdc: div and mod are just uncommon enough that `div` and `mod` are not terrible names for them.
22:06:42 <sproingie> so you have to find the longest word in one pass?
22:06:59 <Cale> / is used for array updates
22:07:02 <Cale> er, //
22:07:18 <kdc> Yeah I knew // was used for arrays.
22:07:26 <kdc> I use them a lot, though.
22:07:29 <Axman6> > 1 % 2
22:07:30 <lambdabot>   1 % 2
22:07:41 <monochrom> You can design your own notation.
22:07:52 * Axman6 recommends against it though
22:08:04 <kmc> > let (!=) = (/=) in 2 != 3
22:08:05 <lambdabot>   True
22:08:09 <sproingie> % works because it looks like a fraction itself
22:08:15 <monochrom> % is not a good choice for mod to begin with.
22:09:14 <Axman6> indeed
22:09:16 <Axman6> c--
22:09:18 <Axman6> >_>
22:10:20 <kmc> i think (/=) is a bit silly
22:11:12 <ivanm> kmc: why?
22:11:23 <ivanm> agreed, =/= would be better, but it's a tad long...
22:11:43 <kdc> Okay.
22:12:13 <ivanm> heya Axman6
22:12:20 <Axman6> o/
22:14:05 <kmc> it's more mathy at the expense of confusing everyone who's used other languages
22:14:21 <kdc> ≠
22:14:26 <kmc> there's enough of that already, it doesn't help to do it it trivial cases as well
22:14:26 <sproingie> thou shalt have no other languages before me
22:14:43 <kmc> i suppose it made sense when haskell was designed to be used only by five really smart dudes
22:15:23 <kdc> If only...
22:15:44 <sproingie> i just wish ! was seq and not subscript
22:15:53 <sproingie> foo !x !y
22:16:25 <kmc> yeah since it works that way in patterns
22:16:39 <sproingie> i guess if i'm not using arrays i can abuse notation however i want
22:17:22 <sproingie> PLEAC had an interesting notion of haskell for its first submissions
22:18:08 <hackagebot> hack 2009.10.30 - a Haskell Webserver Interface (JinjingWang)
22:21:08 <RapidFlash> I have a problem with using random numbers to get a value from a list.  Can anyone help me?
22:24:06 <kmc> RapidFlash, sure
22:24:07 <Cale> RapidFlash: sure
22:24:10 <kmc> can you hpaste your code?
22:24:13 <hgolden> _Ray_: Yes. That's what I was trying to suggest.
22:24:38 <RapidFlash> wall of text coming
22:24:39 <RapidFlash> pickPoints :: Int -> Int -> [Point] -> [Center]
22:24:39 <RapidFlash> pickPoints 0 _ _                         = []
22:24:39 <RapidFlash> pickPoints numClusters numPts points     =
22:24:39 <RapidFlash>             do
22:24:39 <RapidFlash>                 ptIndex <- (Random.randomRIO (0, numPts) :: IO Int)
22:24:41 <RapidFlash>                 return (points !! ptIndex) : (pickPoints (numClusters - 1) numPts points)
22:24:43 <_Ray_> hgolden, I'm writing it as we speak :) But it takes time since I have to do the reductions in pencil.
22:24:59 <copumpkin> RapidFlash: rather than announcing a wall of text, we'd much prefer you to use hpaste.com
22:25:04 <RapidFlash> oh, sorry
22:25:04 <hgolden> You let the recursion keep the remaining string and the longest string found so far. When you get to the end of the string, whatever longest string you have is the answer.
22:25:14 <kmc> err hpaste.org
22:25:18 <copumpkin> whoops :)
22:25:37 <ivanm> RapidFlash: that's a bad way of doing it; an alternative might be something like this: http://osfameron.vox.com/library/post/random-pain-in-haskell.html
22:25:39 <RapidFlash> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11296#a11296
22:25:39 <kmc> could you paste it there so we can look more easily?
22:25:42 <kmc> thanks
22:25:51 <ivanm> IIRC, I've got a non-IO version floating around somewhere...
22:26:00 <kmc> RapidFlash, so, the return value of your function is not a type in the IO monad
22:26:03 <kmc> but you're using randomRIO
22:26:17 <hgolden> _Ray_: Are you familiar with Euclid's method for finding the greatest common division? This is sort of a string recursion that is like that.
22:26:29 <ivanm> RapidFlash: use randomR and explicitly pass the seed around
22:26:31 <RapidFlash> that could explain it
22:26:46 <mmorrow> blackdog: ok, here's a (quickly-and-with-no-hack-barred) update haskell-src-meta for 6.12 http://moonpatio.com/repos/haskell-src-meta_NEW_TH/
22:26:46 <hgolden> _Ray_: It's all done with recursion, not buffers.
22:27:04 <Cale> *or* change the type from [Center] to IO [Center] and change [] to return []
22:27:11 <kmc> RapidFlash, also, indexing a list like that is inefficient
22:27:14 <_Ray_> hgolden, indeed :) It does look like it. Recurse a, decreasing, until it's larger than b. Then switch and recurse.
22:27:16 <kmc> you may or may not care in your particular application
22:27:25 <mmorrow> blackdog: lemme know about any bugs/etc :)
22:27:35 <kmc> but the (!!) operator takes time linear in the index
22:27:46 <mmorrow> preflex: seen blackdog
22:27:46 <preflex>  blackdog was last seen on #haskell 56 minutes and 3 seconds ago, saying: mmorrow: not quite sure what's going on with the switch from Cxt going from [Type] to [Pred], though.
22:27:55 <kmc> there are other structures with faster indexing.  an array is a simple example
22:27:57 <blackdog> mmorrow: beautiful. thanks, trying it now
22:28:08 <RapidFlash> kmc: I was planning on changing it to an array
22:28:09 <mmorrow> blackdog: woot
22:28:17 <hgolden> _Ray_: I think that works to do what you need.
22:28:22 <kmc> cool
22:28:28 <_Ray_> hgolden, many thanks :)
22:28:36 <RapidFlash> but I needed to figure out why I kept getting errors
22:28:40 <hgolden> _Ray_: yw
22:29:25 <Cale> RapidFlash: Oh, also, you want to run (pickPoints ...) and cons the result of that (which will then be a list)
22:29:56 <Cale> So you need another line in your do-block which looks like  xs <- pickPoints (numClusters - 1) numPts points
22:30:00 <RapidFlash> yeah, I forgot to add that in
22:31:28 <kmc> RapidFlash, if you write an IO action to pick a single point, you can use replicateM on that
22:31:36 <kmc> :t replicateM
22:31:41 <Cale> Indeed.
22:31:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
22:31:48 * sproingie wonders about the !!!!1one operator
22:32:08 <Cale> xs !! n extracts the nth element of xs
22:32:57 <Cale> I guess it looks that way so that you'll notice the places where you're using a list like it's not a list ;)
22:33:17 <RapidFlash> it seems to work now
22:33:19 <RapidFlash> thanks!
22:33:23 <Cale> RapidFlash: great :)
22:33:50 <Cale> We really ought to have things like random permutations and selections in the library.
22:33:58 <Cale> seems like a common thing to want
22:34:11 <ivanm> which library?
22:34:20 <ivanm> there are various libraries on hackage that do stuff like that...
22:34:21 <Cale> ivanm: System.Random ?
22:34:36 <luite> hm, it's not really random
22:34:47 <kmc> a fun problem: select a uniform sample of k elements from a list, without replacement, without knowing the length of the list, and only traversing it once
22:34:49 <ivanm> Cale: I thought pretty much everyone seriously wanting performance avoids that module like the plague...
22:34:55 <luite> even if you use it in probability calculations
22:35:06 <Cale> luite: hm?
22:35:07 <ivanm> kmc: k unique elements?
22:35:11 <kmc> yeah
22:35:19 <kdc> Well.
22:35:20 <Cale> Are you talking about the fact that it's a pseudorandom number generator?
22:35:22 <kmc> assume the list elements are unique
22:35:23 <kdc> Unique indices.
22:35:25 <luite> ivanm: hm, I don't, but I always hope that it gets optimized away ;)
22:35:25 <kdc> That.
22:35:31 <blackdog> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11297#a11297
22:35:36 <blackdog> am i doing something silly?
22:35:42 <ivanm> luite: nope, System.Random is bog slow
22:35:45 <kmc> it's surprising how slow most system/language standard random number generators are
22:35:54 <kmc> we have mersenne-random
22:36:05 <ivanm> and the -pure64 variant for anti-IO
22:36:11 <ivanm> plus the one in bos' statistics package
22:36:39 <Cale> blackdog: -XQuasiQuotes
22:36:40 <AppleBoy> if you put x:xs but the input is just [1], how can you check if xs is empty?
22:36:52 <Cale> blackdog: Or, better yet, use a LANGUAGE pragma
22:36:54 <luite> Cale: ah wait, I see what you mean now. I thought you were talking about some kind of 'permutations' thing that lists all the permutations of a list (or counts them)
22:37:02 <idnar> AppleBoy: null xs
22:37:04 <luite> but you mean a single pseudorandom permutation
22:37:06 <Cale> luite: no...
22:37:07 <blackdog> Cale: cheers
22:37:11 <kdc> Multiply with carry...
22:37:12 <idnar> AppleBoy: but you should probably just add another pattern matching case
22:37:19 <Cale> luite: That gets a random permutation with uniform probability
22:37:25 <AppleBoy> idnar: what pattern though?
22:37:33 <idnar> AppleBoy: [x] will match a single-element list
22:37:46 <idnar> AppleBoy: or x:[] which is the same thing
22:37:49 <Cale> luite: We have permutations in Data.List, but using it with something that picks a random element would be hideously inefficient.
22:38:04 <luite> Cale: yes, that's a thing I have implemented a few times... not really trivial though
22:38:22 <kdc> But picking a random element in a single pass might be more inefficient than two passes.
22:38:24 <mmorrow> blackdog: is the file literally
22:38:32 <mmorrow> import Language.Haskell.Meta.QQ.HsHere\nlet x = [0..4] in [$here|[0..4] is $([0..4]) and $(x)|]...
22:38:33 <Cale> luite: Yeah, which is exactly why it ought to be in System.Random instead of in a whole bunch of people's code :)
22:38:33 <mmorrow> ?
22:39:02 <mmorrow> (did you mean "x = let x = [0..4] in ..." ?)
22:39:25 <kmc> AppleBoy, [x, y, z] as a pattern is shorthand for x:y:z:[]
22:39:26 <mmorrow> oh nice, you got it sorted
22:39:46 <blackdog> mmorrow: well, quasiquotes got me to the next error:)
22:39:58 <mmorrow> heh
22:40:09 <mmorrow> so it worked, right?
22:40:52 <blackdog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11298#a11298
22:41:27 <mmorrow> crap, i may have botched something in that QQ (one version that i can't seem to get rid of messes up parsing the closing ')'...
22:41:43 <luite> Cale: I guess it would be useful for testing, but I'm not sure if anyone would notice the difference between a correct implementation and a slightly biased map snd.sort.zip implementation
22:41:46 <hexpuem> QQ moar
22:41:53 <mmorrow> blackdog: oh, hmm.
22:42:27 <mmorrow> blackdog: ohhh. ok, so [$here| ... |] :: String
22:42:38 <mmorrow> blackdog: but you're using it as if it were a declaration
22:43:03 <mmorrow> so changing that to
22:43:05 <mmorrow> x = [0..4]
22:43:14 <mmorrow> y = [$here|.....$(x)...|]
22:43:21 <mmorrow> main = putStrLn y
22:43:23 <mmorrow> should work
22:43:41 <kmc> i learn something cool absolutely every time i pay attention in this room
22:43:43 <kmc> it's great
22:44:55 <blackdog> mmorrow: beautiful. thanks. sorry about that, that was pretty silly - haven't used TH much at all.
22:44:59 <mmorrow> blackdog: gah, i think something's borked with it though, it seems to not be actually evaluating the splice in my ghci
22:45:09 <mmorrow> blackdog: did it work?
22:45:16 <blackdog> yep
22:45:17 <mmorrow> oh, nevermind
22:45:22 <mmorrow> i imported the wrong QQ
22:45:24 <mmorrow> doh
22:45:34 <mmorrow> (Here instead of HsHere)
22:48:14 <luite> ivanm: even with all those other random generators, I've found it to be rather difficult to get good performance in programs that heavily rely on random numbers, like monte carlo or randomized local search (such as genetic algorithms)
22:48:25 <blackdog> mmorrow: so you're implicitly including a show in there, then? What if you want to inline a string?
22:48:35 <ivanm> luite: don't use the Random instances for mersenne, etc.
22:48:44 <luite> ivanm: I didn't
22:49:07 <ivanm> luite: IIRC, I had a substantial performance increase when I switched from System.Random to -pure64 for monte carlo
22:49:21 <ivanm> as in, 6 times as fast or something
22:50:25 <luite> ivanm: oh I don't doubt that, but I couldn't get my programs anywhere near the speed of an implementation in C
22:51:00 <mmorrow> blackdog: right, i'm (implicitly from the pov of the QQ user, and explicitly from the pov of the QQ code) adding a `show'
22:51:26 <kmc> how do Here and HsHere differ?
22:51:33 <mmorrow> blackdog: you could change the "[|show $(return e)|]" to an arbitrary quoted chunk of code
22:51:53 <mmorrow> kmc: Here just gives you the literal text inside the QQ as a String
22:52:12 <mmorrow> kmc: HsHere extracts $(..this..), parses it, then splices that TH code
22:52:28 <luite> maybe it would help if pureMT could fill a large array of random values in once call
22:52:36 <mmorrow> and ..this..$(..)...and this... are left as String filler
22:52:42 <ivanm> luite: yeah
22:52:56 <mmorrow> kmc: so outside of $(...) Here and HsHere are the same
22:53:13 <blackdog> mmorrow: ok, that makes sense. ended up hacking around it - newtype U String with a Show instance
22:53:28 <blackdog> evil hacks-r-us
22:53:42 <mmorrow> blackdog: one nice way to get String shown without the quotes/escapes in someway via Doc
22:53:46 <kmc> so Here is just a string literal?
22:54:02 <mmorrow> , [$here|asdf $(text "asdf") jkl;|]
22:54:04 <lunabot>  "asdf asdf jkl;"
22:54:19 <mmorrow> ooh, ok
22:54:28 <mmorrow> so you could examine the parsed code
22:54:34 <mmorrow> and check if it's a String
22:54:44 <mmorrow> if so, then don't use "show", if not, then use show
22:54:57 <mmorrow> , [|"asdfghjkl;"|]
22:54:59 <lunabot>  LitE (StringL "asdfghjkl;")
22:55:13 <blackdog> ah, that's pretty cute
22:55:32 <mmorrow> (btw the Show instances for all the TH syntax are coming from haskell-src-meta's Utils module)
22:55:54 <mmorrow> they clean up the Names, and use unQ
22:56:04 <mmorrow> unQ = unsafePerformIO . runQ
22:56:20 <kmc> , [$here|asdf $(text "asdf") jkl;|]
22:56:23 <lunabot>  "asdf asdf jkl;"
22:56:23 <kmc> , [$hshere|asdf $(text "asdf") jkl;|]
22:56:25 <lunabot>  luna: Not in scope: `hshere'
22:56:34 <mmorrow> ah, so another trick is to, i'm sure you've gotten those "can't do reify in the IO monad" messages
22:56:48 <mmorrow> haskell-src-meta also has instances of Lift for all the TH AST itself
22:56:51 <mmorrow> so you can do
22:57:05 <mmorrow> , reify ''Exp
22:57:07 <lunabot>  luna: No instance for (GHC.Show.Show
22:57:13 <mmorrow> err
22:57:18 <mmorrow> , unQ (reify ''Exp)
22:57:20 <lunabot>  Template Haskell error: Can't do `reify' in the IO monad
22:57:20 <lunabot>  luna: user error (Template Haskell failure)
22:57:24 <mmorrow> , $(lift =<< reify ''Exp)
22:57:26 <lunabot>  TyConI (DataD [] Language.Haskell.TH.Syntax.Exp [] [NormalC Language.Hask...
22:57:30 <mmorrow> , ppDoc $(lift =<< reify ''Exp)
22:57:32 <lunabot>  data Exp = VarE Name
22:57:32 <lunabot>           | ConE Name
22:57:32 <lunabot>           | LitE Lit
22:57:34 <mmorrow> ..
22:57:51 <kmc> nice trick :)
22:58:02 <mmorrow> :)
22:59:37 <kmc> > now
22:59:39 <lambdabot>   Not in scope: `now'
22:59:48 <mmorrow> kmc: ah yeah, i named the QQs in both the Here module and the HsHere module `here', which was a bad idea in hindsight..
22:59:49 <blackdog> that's very cool :)
23:00:36 <mmorrow> handy too
23:01:57 <blackdog> mmorrow: i might write the interpolation trick up, if you don't mind.
23:02:13 <mmorrow> blackdog: not at all
23:04:37 <mmorrow> , [|"asdfghjkl;"|]
23:04:39 <lunabot>  LitE (StringL "asdfghjkl;")
23:04:41 <mmorrow> , lift =<< [|"asdfghjkl;"|]
23:04:43 <lunabot>  AppE (ConE LitE) (AppE (ConE StringL) (LitE (StringL "asdfghjkl;")))
23:04:45 <mmorrow> , lift =<< lift =<< [|"asdfghjkl;"|]
23:04:47 <lunabot>  AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (AppE (ConE Name) (AppE (V...
23:05:32 <mmorrow> after about 4 or 5 lifts, you end up with like a 10MB+ file (if you were to dump it to a file)
23:06:00 <mmorrow> , (length . show) (lift =<< lift =<< lift =<< lift =<< [|"asdfghjkl;"|])
23:06:02 <lunabot>  55863
23:06:11 <mmorrow> , (length . show) (lift =<< lift =<< lift =<< lift =<< lift =<< lift =<< [|"asdfghjkl;"|])
23:06:14 <lunabot>  4635693
23:06:47 <mmorrow> so i guess you need a couple more that 5 lifts to get 10MB, but less than 10..
23:07:01 <mmorrow> (less than 10.. lifts)
23:08:50 <copumpkin> , show (lift =<< [|"asdfghjkl;"|])
23:08:51 <lunabot>  "AppE (ConE LitE) (AppE (ConE StringL) (LitE (StringL \"asdfghjkl;\")))"
23:08:52 <kmc> , ppDoc $(lift =<< reify 'lift)
23:08:54 <lunabot>  Class op from Lift: lift :: forall t_0 . Lift t_0 => t_0 -> Q Exp
23:09:00 <mmorrow> , lift =<< [|"asdfghjkl;"|]
23:09:02 <lunabot>  AppE (ConE LitE) (AppE (ConE StringL) (LitE (StringL "asdfghjkl;")))
23:09:07 <mmorrow> , [|LitE (StringL "asdfghjkl;")|]
23:09:09 <lunabot>  AppE (ConE LitE) (AppE (ConE StringL) (LitE (StringL "asdfghjkl;")))
23:09:18 <kmc> , ppDoc $(lift =<< 'lift)
23:09:21 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Q a'
23:09:26 <kmc> , 'foo
23:09:28 <lunabot>  luna: Not in scope: `foo'
23:09:34 <mmorrow> , [$ty| 'fmap |]
23:09:37 <lunabot>  Name
23:09:40 <kmc> , [|'foo|]
23:09:41 <lunabot>  luna: Not in scope: `foo'
23:09:50 <mmorrow> , 'fmap
23:09:52 <lunabot>  GHC.Base.fmap
23:09:57 <mmorrow> , ''Maybe
23:09:58 <lunabot>  Data.Maybe.Maybe
23:10:14 <mmorrow> , [t|forall a. (a, Int)|]
23:10:16 <lunabot>  ForallT [a_0] [] (AppT (AppT (TupleT 2) (VarT a_0)) (ConT Int))
23:10:18 <kmc> how do i quote a quote?
23:10:22 <kmc> err a name
23:10:29 <mmorrow> , [|fmap|]
23:10:31 <lunabot>  VarE fmap
23:10:33 <kmc> oh duh
23:10:36 <mmorrow> :)
23:10:44 <mmorrow> , [t|Int|]
23:10:46 <lunabot>  ConT Int
23:10:56 <mmorrow> , [d|data A a = A | B a|]
23:10:58 <lunabot>  DataD [] A [a_0] [NormalC A [],NormalC B [(NotStrict,VarT a_0)]] []
23:11:03 <kmc> right so 'foo is shorthand for [|foo|] ?
23:11:14 <mmorrow> not quite
23:11:29 <mmorrow> , VarE 'fmap
23:11:31 <lunabot>  VarE GHC.Base.fmap
23:11:33 <mmorrow> , [|fmap|]
23:11:34 <lunabot>  VarE fmap
23:11:46 <mmorrow> (that's my Show instance de-qualifying that)
23:12:12 <mmorrow> kmc: [|...|] :: Q Exp
23:12:16 <mmorrow> type ExpQ = Q Exp
23:12:22 <mmorrow>  'asdf :: Name
23:12:26 <mmorrow>  ''Asdf :: Name
23:12:34 <mmorrow> , src 'VarE
23:12:37 <lunabot>  data Exp = ... | VarE Name | ...
23:12:37 <lunabot>  infixl 9
23:12:40 <mmorrow> , src 'VarT
23:12:43 <lunabot>  data Type = ... | VarT Name | ...
23:12:43 <lunabot>  infixl 9
23:12:46 <mmorrow> , src 'ConT
23:12:49 <lunabot>  data Type = ... | ConT Name | ...
23:12:49 <lunabot>  infixl 9
23:12:50 <mmorrow> , src 'ConE
23:12:53 <lunabot>  data Exp = ... | ConE Name | ...
23:12:53 <lunabot>  infixl 9
23:14:06 <kmc> , [$ty|src|]
23:14:07 <mmorrow> all that `src' does is reify the Name it's given (but since it's doing it at runtime, it has to use lunabot's `eval' function)
23:14:09 <lunabot>  Name -> Doc
23:14:31 <mmorrow> , (fromJust . fromDynamic) (eval "[|42|]") :: ExpQ
23:14:34 <lunabot>  LitE (IntegerL 42)
23:14:41 <mmorrow> , (fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ
23:14:45 <lunabot>  AppE (VarE eval) (LitE (StringL "42"))
23:15:02 <mmorrow> , [|show $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ)|]
23:15:05 <lunabot>  AppE (VarE show) (AppE (VarE eval) (LitE (StringL "42")))
23:15:35 <mmorrow> , $([|show $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ)|])
23:15:38 <lunabot>  "<<Integer>>"
23:15:49 <mmorrow> , (fromJust . fromDynamic) $([|show $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ)|]) :: Integer
23:15:52 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
23:16:00 <mmorrow> oh, right
23:16:19 <mmorrow> , [|(fromJust . fromDynamic) $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ)|]) :: Integer|]
23:16:21 <lunabot>  luna: parse error on input `|]'
23:16:31 <mmorrow> gah
23:16:40 <mmorrow> , (fromJust . fromDynamic) $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ)|]) :: Integer
23:16:41 <lunabot>  luna: parse error on input `|]'
23:17:01 * Gracenotes swims in a sea of TH
23:17:10 <mmorrow> , [|(fromJust . fromDynamic) $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ) :: Integer|]
23:17:13 <lunabot>  SigE (AppE (InfixE (Just (VarE fromJust)) (VarE .) (Just (VarE fromDynami...
23:17:17 <mmorrow> , $([|(fromJust . fromDynamic) $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ) :: Integer|])
23:17:21 <lunabot>  42
23:17:36 <mmorrow> which is the same as
23:17:42 <mmorrow> , (fromJust . fromDynamic) $((fromJust . fromDynamic) (eval "[|eval \"42\"|]") :: ExpQ) :: Integer
23:17:45 <lunabot>  42
23:17:57 <mmorrow>  $([|....|]) === ....
23:18:20 <kmc> $([| ^___^ |])
23:18:58 <mmorrow>  [|f x $(e :: ExpQ)|] === splice e into o in quote "f x o"
23:19:25 <mmorrow> , let e = [|1 + 1|] in [|id $e|]
23:19:27 <lunabot>  AppE (VarE id) (InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (I...
23:20:11 <mmorrow> , let e = [|1 + $(lift (1 + 1 :: Int))|] in [|id $e|]
23:20:13 <lunabot>  AppE (VarE id) (InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (I...
23:20:17 <mmorrow> , ppDoc (let e = [|1 + $(lift (1 + 1 :: Int))|] in [|id $e|])
23:20:19 <lunabot>  luna: No instances for (Data.Data.Data Language.Haskell.TH.Lib.ExpQ,
23:20:22 <mmorrow> , ppDoc <$> (let e = [|1 + $(lift (1 + 1 :: Int))|] in [|id $e|])
23:20:24 <lunabot>  id (1 + 2)
23:21:02 <mmorrow> , ppDoc <$> (let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|])
23:21:04 <lunabot>  show (show (show (show ())))
23:21:10 <mmorrow> , let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|]
23:21:12 <lunabot>  AppE (VarE show) (AppE (VarE show) (AppE (VarE show) (AppE (VarE show) (C...
23:21:15 <mmorrow> , $(let go 0 e = e; go n e = [|show $(go (n-1) e)|] in go 4 [|()|])
23:21:17 <lunabot>  "\"\\\"\\\\\\\"()\\\\\\\"\\\"\""
23:21:32 <mmorrow> slicing inside of quotes is hugely useful
23:21:35 <mmorrow> *splicing
23:22:20 <mmorrow> one thing to know though, is that you're strictly evaluated inside a splice
23:23:24 <mmorrow> so if `go' never stopped, you'd loop
23:23:59 <mmorrow> which i guess is obvious or non-obvious depending which way you're looking at it
23:24:51 <ksf> infinite loops aren't the problem, the nonproductive ones are.
23:25:21 <mmorrow> well, wouldn't productive one not be infinite?
23:25:26 <mmorrow> *ones
23:25:30 <dolio> No.
23:25:38 <ksf> > [1..]
23:25:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:25:48 <ksf> that's very productive and very infinite
23:25:52 <mmorrow> ok, in TH though infinite is a problem
23:26:21 <mmorrow> , [|show $(lift [(0::Int)..])|]
23:26:27 <lunabot>  Killed.
23:26:35 <ksf> only if your machine isn't turing-complete.
23:26:58 <dolio> , [$ty| lift |]
23:27:00 <lunabot>  forall t . Lift t => t -> Q Exp
23:27:04 <mmorrow> , ListE (fmap (unQ . lift) [(0::Int)])
23:27:06 <lunabot>  ListE [LitE (IntegerL 0)]
23:27:10 <mmorrow> , ListE (fmap (unQ . lift) [(0::Int)..])
23:27:11 <lunabot>  ListE [LitE (IntegerL 0),LitE (IntegerL 1),LitE (IntegerL 2),LitE (Intege...
23:27:21 <mmorrow> , unQ (lift [(0::Int)..]))
23:27:22 <lunabot>  luna: parse error on input `)'
23:27:24 <mmorrow> , unQ (lift [(0::Int)..])
23:27:30 <lunabot>  Killed.
23:27:37 <idnar> ksf: even if your machine is turing-complete, your brain isn't :P
23:27:38 <mmorrow> TH quotes are /fully/ evaluated
23:27:51 <dolio> Infinite source files are a problem.
23:27:51 <mmorrow> , unQ (lift [(0::Int)..4])
23:27:53 <lunabot>  ListE [LitE (IntegerL 0),LitE (IntegerL 1),LitE (IntegerL 2),LitE (Intege...
23:28:02 <mmorrow> dolio: right, that's the root of this
23:28:06 <dolio> :)
23:28:18 <mmorrow> dolio: i didn't quite know how to say it though :)
23:28:21 <SubStack> @djinn (a -> Bool) -> [a] -> [a]
23:28:21 <lambdabot> Error: Undefined type []
23:29:41 <drhodes> infinitely long programs, hmmm..
23:29:51 <tom9> hi could someone help me with the find function
23:30:09 <ksf> the problem, actually, is haskell's futamura-incompleteness.
23:30:13 <ivanm> @type find
23:30:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
23:30:22 <ksf> @src find
23:30:22 <lambdabot> find p          = listToMaybe . filter p
23:30:29 <tom9> @type find
23:30:30 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
23:30:31 <kmc> ksf, what does that mean?
23:30:46 <ivanm> tom9: what kind of help did you want?
23:30:47 <ksf> filter gives you all elements that match the predicate.
23:31:06 <ksf> listToMaybe gives you the Just <the first one>, or nothing, if there's no first one.
23:31:09 <tom9> i have a list of tuples
23:31:16 <idnar> ksf: I think he meant the futamura-incompleteness comment
23:31:28 <SubStack> pesky completeness
23:31:39 <idnar> or maybe you weren't answering kmc
23:31:41 * idnar is all confused now
23:31:50 <ksf> ah. haskell's meta-recursive implementation can't be collapsed.
23:31:54 <sieni> what's the status of gui bindings for haskell? Is there any multiplatform options for wxHaskell? (and no, I don't count Gtk as multiplatform)
23:32:04 <tom9> i have a list of tuples and i want to find all of the tuples where the second element is Spades (of my own type Suit)
23:32:24 <ksf> I'm quite certain "futamura-completeness" is a term I just made up short-circuting turing and futamura
23:32:26 <Gracenotes> find ((==Spades) . snd), perhaps.
23:32:30 <ivanm> tom9: so you don't want find, you want filter
23:32:38 <ivanm> Gracenotes: that will only get the first one maybe, not all
23:32:47 <copumpkin> tom9: I answered that question several hours ago with Gracenotes's answer
23:32:56 <ivanm> tom9: filter ((==) Spades . snd)
23:33:01 <ivanm> copumpkin: heh
23:33:01 <Gracenotes> oh, I thought he said find. hm.. filter it is, though
23:33:10 <ivanm> Gracenotes: he did say find
23:33:15 <Gracenotes> yeah, I see
23:33:19 <ivanm> Gracenotes: but how do newbies know what they actually need/want ;-)
23:33:25 <kmc> collapsed how?
23:33:25 <ivanm> (no offence tom90
23:33:28 <ivanm> *tom9)
23:33:34 <ivanm> kmc: using a black whole
23:33:37 <ivanm> *hole
23:33:37 <sieni> hmmm... qthaskell
23:33:40 <ivanm> :p
23:33:41 <sieni> interesting
23:33:45 <Gracenotes> ah, that's okay. There are quite a few finding functions: filter, find, findIndex, findIndices...
23:33:46 <tom9> i couldnt use find, it came up with undefined variable (and im a complete newbie haha)
23:33:47 * ivanm has no idea what kmc is actually talking about
23:33:50 <ksf> sieni, wxhaskell should run everywhere where ghc+wxwindows runs.
23:33:50 <ksf> ...native look+feel is overrated, btw.
23:34:20 <ivanm> tom9: filter is used when you want to find everything in a list that matches a predicate
23:34:44 <tom9> thankyou so much, ill read up on filter, thankyou again. speak soon propbably, sorry for being simple
23:34:54 <kmc> ksf said that "haskell's meta-recursive implementation can't be collapsed"
23:35:09 <kmc> i'm not sure what sense of "collapsed" is intended
23:35:22 <Gracenotes> ksf: Tk on Linux? shudder.
23:35:58 <Gracenotes> at least on GNOME
