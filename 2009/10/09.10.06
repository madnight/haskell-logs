00:00:32 <augur> whats haskellese for reversing two items in a function application so that like
00:00:39 <augur> op x f = f x?
00:00:39 <ivanm> flip?
00:00:46 <ivanm> @pl \ x f -> f x
00:00:47 <lambdabot> flip id
00:00:57 <augur> huh!
00:00:59 <ivanm> hmmm, I would have thought flip ($) or something
00:01:09 <Saizan_> ($) = id
00:01:16 <augur> thank you ivanm :)
00:01:18 <augur> now:
00:01:27 <ivanm> Saizan_: duh
00:02:14 <augur> the english word is: is = flip (const True)
00:02:24 <augur> at least to a first approximation!
00:08:59 <augur> er, sorry, is = flip id (const True)
00:17:39 <sbahra> @ask Cale Could you have lambdabot join ##FreeBSD and #haskell-FreeBSD please? (I am operator in both)
00:17:39 <lambdabot> Consider it noted.
00:19:41 <ClaudiusMaximus> wow, "realToFrac :: Double -> GLfloat" is exceedingly slow :-/
00:19:56 <Cale> sbahra: oh, sure
00:19:57 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
00:20:09 <Cale> lambdabot: @join ##FreeBSD
00:20:14 <Cale> lambdabot: @join ##haskell-FreeBSD
00:21:44 <sbahra> Cale, thanks.
00:22:03 <Cale> uh, oh
00:22:08 <Cale> With one # on the other one?
00:22:14 <Cale> lambdabot: @join #haskell-FreeBSD
00:23:26 <ClaudiusMaximus> > (38.458 * 0.932) / (1024 * 1024) -- seconds per realToFrac::Double->GLfloat (on my system)
00:23:27 <lambdabot>   3.4182411193847654e-5
00:24:15 <sbahra> Cale, yes, with one. Sorry.
00:28:40 <augur> also apparently english "a" is: a = liftM2 (&&)
00:28:48 <augur> to a first approximation.
00:30:50 <ivanm> ... right ...
00:31:24 <augur> its true!
00:32:37 <augur> when you do the type calculations over certain sentences, and similarly calculate the meaning of each part, you can determine this to be the case.
00:33:14 <augur> also, from = ap (flip . (((.) . (&&)) .) . flip id) isFrom  (for some build-in definition of isFrom)
00:33:35 <Veinor> . (((.) . (&&)) .) . looks like some kind of hideous monster
00:34:05 <augur> D:
00:38:24 <Saizan_> augur: what are the two arguments you apply a to?
00:38:31 <augur> Saizan: for which
00:38:45 <Saizan_> a = liftM2 (&&)
00:39:05 <Veinor> @unpl liftM2 (&&)
00:39:05 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b && a))
00:39:20 <augur> oh. well, not monads, tho you might be able to do it that way. thats just what lambdabot gave me from a fork function
00:39:47 <augur> a f g x = (f g) && (g x)
00:40:02 <augur> so
00:40:12 <augur> @pl \f g x -> (f x) && (g x)
00:40:12 <lambdabot> liftM2 (&&)
00:40:26 <augur> obviously that should've been (f x) before.
00:40:51 <Saizan_> yeah, but i don't see what f g and x are in an english sentence using 'a'
00:40:56 <augur> right
00:40:57 <augur> so
00:41:16 <augur> f is a function like 'dog'
00:41:26 <augur>  /predicate
00:42:45 <augur> g is there because if you calculate the types over three particular sentences, to be consistent, the first argument to "is" has to be (e -> t) -> (e -> t)
00:43:41 <augur> which (a f) is, on assumption that a :: (e -> t) -> (e -> t) -> (e -> t)
00:44:32 <Saizan_> ah, now i see what you're doing
00:44:35 <augur> is just gives (a f) a vacuous predicate that always returns true
00:45:00 <augur> so yeah. go through the types and lambdas associated with these three sentences:
00:45:40 <augur> "Fido is a dog", "Fido is from Boston", "Fido is a dog from boston", where each is type t, Fido :: e, Boston :: e, and dog :: e -> t
00:45:51 <augur> and calculate the types and definitions of is, a, and from
00:46:42 <augur> turns out is :: ((e -> t) -> (e -> t)) -> e -> t, a :: (e -> t) -> (e -> t) -> (e -> t), and from :: e -> (e -> t) -> (e -> t)
00:48:25 <augur> and thats not including the fact that proper nouns like Fido and Boston probably are something more like (e -> t) -> (e -> t) -> t
01:07:16 <ivanm> *sigh* why does highlighting-kate need to take up so much CPU and memory to build?
01:07:26 <ivanm> does it do a lot of TH hackery or something?
01:19:10 <Baughn> "Something is amiss; requested module  syb-0.1.0.1:Data.Generics differs from name found in the interface file syb:Data.Generics" <-- I got this when compiling parsec for ghc 6.13.20091002, but what does it /mean/?
01:19:40 <ivanm> Baughn: wrong version of syb? *shrug*
01:20:50 <Baughn> ivanm: Can't be. I cleared out ~/.ghc and ~/.cabal, not to mention deleting src/*/dist first.
01:21:04 <ivanm> weird :s
01:21:17 <ivanm> is there a way to use ghc-pkg to find which libs depend on another lib?
01:21:26 <ivanm> that is, I want to find the reverse-dependencies of a library
01:21:31 <Baughn> ghc-pkg dump
01:21:57 <Baughn> ..is what I thought
01:22:04 <Baughn> Guess not.
01:22:38 <ivanm> eh, good enough
01:22:40 <ivanm> thanks Baughn
01:23:07 <ivanm> appears to be an implicit dep problem that ghc-pkg check doesn't detect :s
01:30:09 <nha_> can anyone explain the motivation for deliminated continuations? it seems like you can do the exact same thing with newtype F = F (Whatever -> F) and just returning the partially applied next recursive call
01:35:07 <dmead> haskellllllllllllllll
01:35:19 <dmead> http://www.reddit.com/r/haskell/comments/9r95c/ask_haskell_im_thinking_about_doing_a_talk_for_a/
01:35:23 <dmead> comments pleasseeeee
01:37:36 <Alpounet> dmead, done
01:37:50 <Alpounet> I'm preparing the same thing for non-functional programmers
01:38:02 <Alpounet> and some of the guys won't even be programmers at all.
01:41:05 <ivanm> Anyone know what this means? Loading package pcre-light-0.3.1 ... <command line>: can't load .so/.DLL for: pcre (/usr/lib/libpcre.so: invalid ELF header)
01:41:11 <ivanm> I get it when trying to build pandoc :s
01:41:54 <ivanm> I have pandoc using highlighting-kdate, which is what actually uses pcre-light (which wants that .so file)
01:41:57 <ivanm> the .so file exists...
01:42:01 <Alpounet> try reinstalling libpcre
01:42:07 <Alpounet> it may have been corrupted
01:42:09 <Alpounet> in a way or another
01:42:19 <Alpounet> (it's very weird though)
01:42:47 <ivanm> yeah... I've already tried rebuilding pcre-light and highlighting-kate...
01:44:57 <ivanm> @tell dons you might want to update the last paragraph of your bio on the galois site...
01:44:58 <lambdabot> Consider it noted.
01:45:50 <Saizan_> ivanm: probably your libpcre.so is a linker script instead of a binary
01:46:01 <ivanm> hmmm :s
01:46:19 <ivanm> yup, it is :s
01:46:38 <ivanm> the real one is in /lib/libpcre.so.0
01:46:51 <ivanm> do I have to tell cabal to look in /lib instead of /usr/lib ?
01:47:01 <ivanm> (maybe I need to build libpcre with static-libs...)
01:47:45 * Saizan_ usually replaces the script with a symlink in these cases
01:47:48 <dcoutts> ivanm: nope, the system linker will do that for you
01:48:43 <ivanm> dcoutts: well, it isn't ;-)
01:48:51 <ivanm> Gentoo bug 4411 is the explanation of this...
01:49:13 <dcoutts> ivanm: it is, it's just that "libpcre.so" lives in /usr/lib/ and it lies.
01:49:28 <ivanm> comment 35 in particular...
01:49:59 <ivanm> dcoutts: I seem to recall seeing this problem occur before with haskell stuff on gentoo... do you know what we did last time (or what we can do about it then?)
01:50:59 <dcoutts> ivanm: "SpanKY" is wrong as is easily demonstrated with a 2 line C program that calls dlopen("libpcre.so")
01:51:13 <dcoutts> ivanm: it really is a system problem imho
01:51:20 <ivanm> *nod*
01:51:39 <dcoutts> they're setting things up so that dlopen of libfoo.so will fail
01:51:51 <dcoutts> sure, dlopen libfoo.so.0 will work
01:51:56 <ivanm> vapier says that the loader should be looking in /lib first anyway...
01:51:57 <dcoutts> but no code knows to do that
01:52:01 <dcoutts> ivanm: it is
01:52:09 <dcoutts> ivanm: but there is no libfoo.so in /lib
01:52:14 <dcoutts> only libfoo.so.0
01:52:25 <ivanm> ahhh, yes
01:52:39 <dcoutts> ivanm: the libfoo.so gets found in /usr/lib and that's the one that lies.
01:53:50 <dcoutts> ivanm: if /lib/libfoo.so was a symlink to /lib/libfoo.so.0 then it'd all work fine
01:53:59 <ivanm> *nod*
01:54:13 <dcoutts> ivanm: and they do have that for most libs in /lib, but not for these ones with the linker scripts
01:54:25 <ivanm> hmmmm....
01:54:36 * ivanm might try USE=static-libs for libpcre then
01:55:57 <Saizan_> dcoutts: and dlopen isn't supposed to work with linker script?
02:02:36 <dcoutts> Saizan_: it's not a valid ELF binary
02:03:05 <dcoutts> Saizan_: it's just a feature of the gnu static linker
02:04:18 <Saizan_> dcoutts: i see
02:04:50 <nomeata> Hi. When working with values of Complex Real, if I want to scale the value c by the real factor x , is there a syntactically nicer ways than "(x :+ 0) + c"?
02:05:03 <nomeata> "(x :+ 0) * c" of course
02:06:19 <dmead> ?src interact
02:06:20 <lambdabot> interact f = do s <- getContents; putStr (f s)
02:06:46 <dmead> ?src  getcontents
02:06:46 <lambdabot> Source not found.
02:06:55 <dmead> ?type  getcontents
02:06:57 <lambdabot> Not in scope: `getcontents'
02:07:05 <dmead> ?src  getContents
02:07:06 <lambdabot> getContents = hGetContents stdin
02:07:17 <dmead> ?type  getContents
02:07:18 <lambdabot> IO String
02:08:39 <Saizan_> > fromIntegral 42 :: Complex Real
02:08:40 <lambdabot>   Class `GHC.Real.Real' used as a type
02:09:56 <Alpounet> > (1.0 :: Complex Real)
02:09:58 <lambdabot>   Class `GHC.Real.Real' used as a type
02:10:08 <simplicio> grr
02:10:09 <Alpounet> > (1.0 :: Complex Double)
02:10:10 <lambdabot>   1.0 :+ 0.0
02:10:43 <simplicio> > 2 * (sqrt (-1) :: Complex Double)
02:10:44 <lambdabot>   (-0.0) :+ 2.0
02:11:05 <Alpounet> nomeata, (x :: Complex Double) * c shoud le okay
02:11:10 <Alpounet> should be*
02:12:07 <Alpounet> even if definind your own operator could be fine too
02:12:07 <Alpounet> s/d/g
02:18:26 <bastl> When reading some haskell sources, i noticed that (\ x -> x*x) looks more like a lambda that just \x -> ... (notice the parentheses and spaces) Is that on purpose ?
02:19:17 <bastl> s/that/than/
02:19:48 <Saizan_> yeah
02:19:58 <bastl> cool :-)
02:20:32 <bastl> any reference? my collegues laughed about that idea ...
02:25:57 <Saizan_> mmh, my reference is this channel
02:35:00 <Saizan_> the only evidence i'd expect would be an old mailing list discussion from when they designed the language
02:45:03 <halcyon10> hi
02:45:32 <halcyon10> is there a way to force 'length' to run in constant space?
02:45:48 <Alpounet> ?
02:46:01 <Zao> Isn't it nicely fused already?
02:46:29 <halcyon10> if i use length in my program i always get a memory blowup
02:47:02 <halcyon10> i think it has to do with parts being too lazy, but i don't know where to start
02:47:23 <data_jepp> http://stackoverflow.com/questions/1524582/haskell-recursive-problem-tiny-parser-negation-of-expr-and-let-expressions If anyone would be so kind to have a look. :)
02:50:46 <tuukkah> halcyon10, do you perhaps process your list multiple times? to avoid keeping the list fully in memory, you could produce the list multiple times as well
02:51:46 <halcyon10> tuukkah: the problem even occurs if i just produce a simple list and want to determine its length
02:51:57 <Alpounet> wow, leksah is quite impressive now.
02:52:08 <vegai> you mean you want an O(1) length no a list?
02:52:18 <tuukkah> halcyon10, like this? length [0..1000000000]
02:52:30 <halcyon10> tuukkah: yes, something like this
02:52:53 <vegai> perhaps arrays could do that, but to get the length of a list, you have to traverse the whole thing always
02:52:55 <tuukkah> halcyon10, i don't see it consuming memory
02:53:34 <tuukkah> vegai, i think we're talking about space, not time
02:53:44 <vegai> yeah. I wasn't sure
02:53:58 <halcyon10> ok, just tested it, your example works in constant space. Mine is a bit more complicated
02:55:20 <tuukkah> halcyon10, what's the simplest example where you get a problem?
02:56:13 <tuukkah> btw, feedback on building this welcome :-) http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs
02:56:35 <vegai> whoa, you resumed work on that?
02:56:36 <tuukkah> (it's a somewhat complex ghc&gtk2hs gui app)
02:56:53 <tuukkah> vegai, every year, i have to do something little at least :-)
02:56:58 <vegai> I was just talking with Hermanni about that the other day...
02:56:59 <halcyon10> something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10488#a10488
02:57:15 <halcyon10> sorry, have to go asfk for half an hour
03:13:47 <vegai> the gtk/cairo/glib dependency is always a bit unfortunate
03:14:56 <tuukkah> vegai, in which sense?
03:15:17 <vegai> one cannot just cabal install them..
03:16:09 <tuukkah> vegai, one can apt-get install them =) what would be better - pure opengl?
03:17:06 <vegai> I guess it would
03:17:30 <vegai> you guys did some nifty things with opengl back then, so...
03:17:48 <Zao> Someone needs to step up and write a competent Direct3D library.
03:18:06 <Zao> The thought has struck me a couple of times, but the scope of the project scares me.
03:18:10 <tuukkah> it wouldn't be possible to write a "normal desktop app" that way
03:19:14 <tuukkah> (hmm, length [0..10000000000] is taking way much longer than [0..1000000000])
03:20:24 <Zao> Well, the former forces the whole list.
03:20:26 <lpsmith> tuukkah:  it should take about 10x as long :-)
03:20:39 <Zao> Oh, miscounted the zeroes.
03:21:02 <Zao> lpsmith: Depending on available storage, moon phase and pie.
03:21:26 <Zao> A swapping program tends to suck mud.
03:21:32 <tuukkah> lpsmith, it's more than that, perhaps because it goes over the 32 bit range
03:21:38 <lpsmith> Zao:  in this case, it should (theoretically) operate in constant space
03:21:46 <tuukkah> it does operate in constant space
03:22:01 <lpsmith> ahh, yes,  going over 32 bits would be an issue...
03:22:16 <lpsmith> Get a 64-bit machine :-)
03:22:20 <Zao> How is it, do integer literals always default to Int, or are they Integer?
03:22:37 <lpsmith> Integer literals default to forall a. Integral a => a
03:22:54 <lpsmith> Although types will later default to Integer
03:23:02 <tuukkah> i suppose the machine is 64 bit but i'm stupid and running a 32 bit os on it
03:23:16 <lpsmith> XP?
03:23:27 <tuukkah> ubuntu karmic
03:23:39 <lpsmith> I was running 32 bit linux on my 64 bit machine for quite some time for assorted reasons
03:23:53 <lpsmith> Ahh,  yeah, I'm on 64-bit ubuntu now
03:24:51 <ivanm> tuukkah: there's nothing stupid about running 32bit OS on 64bit-capable machine
03:25:02 <ivanm> since there's still some slight compatability issues with some apps
03:25:08 <lpsmith> yep
03:25:21 <lpsmith> that's what kept me on 32-bit linux for a few years :-)
03:25:22 <Zao> Nvidia binary drivers on FreeBSD :P
03:25:25 <tuukkah> ivanm, it's not all stupid, no, but somewhat lame at least
03:25:32 * ivanm is still bitter that when he tried to install 64bit *nix on his new laptop last year, all liveCDs, installs, etc. kept crashing for no apparent reason
03:26:15 <tuukkah> ok, now it finished: 40 seconds to count to billion, 30 minutes to count to 10 billion
03:31:01 <vegai> tuukkah: seems like HList is Data.HList these days
03:31:10 <vegai> Fenfire/RDF.hs:46
03:31:58 <tuukkah> vegai, anyway, the ecosystem for building something fenfire-like is slowly improving: there's now people developing and researching "linked data", compiz is becoming mainstream so opengl and compositing are more acceptable for linux apps...
03:32:06 <ilid> tuukkah: presumably that's because you're running a 32-bit binary :) Integer arithmetic is slower on numbers which don't fit in an Int
03:32:27 <ClaudiusMaximus> @hoogle (r -> (a, r)) -> r -> Int -> ([a], r)
03:32:27 <lambdabot> No results found
03:32:29 <tuukkah> ilid, right, see above :-)
03:33:22 <Saizan_> ?type \f n -> runState (replicateM n (State f))
03:33:22 <lambdabot> forall s a. (s -> (a, s)) -> Int -> s -> ([a], s)
03:33:29 <ilid> tuukkah: this is think raises a question of whether it'd be sensible for Integer to have an additional constructor for 64-bit ints, on systems where Int is 32 bits
03:33:37 <Saizan_> ClaudiusMaximus: ^^^
03:33:38 <ClaudiusMaximus> Saizan_++  (pre-empting my question)
03:33:48 <Saizan_> hehe :)
03:34:34 <tuukkah> ilid, this could be automatic behind the scenes in how ghc/gmp implements Integer, right?
03:35:38 <tuukkah> to me, it was actually more of a concern that the 30 minute calculation produced the wrong result as length :: [a] -> Int
03:37:51 <lpsmith> tuukkah:  how long does (length ([1..(10^9)] :: [Int]))  take?
03:38:44 <tuukkah> lpsmith, just a sec
03:38:51 <tuukkah> 21s
03:39:08 <tuukkah> next up the same for 10^10
03:39:40 <tuukkah> um, 29s
03:39:49 <int-e> > 10^10 :: Int32
03:39:50 <lambdabot>   1410065408
03:39:54 <tuukkah> uh, right
03:41:35 <tuukkah> hmm, so how to best write a list of length 10^10 and type [Int]
03:42:26 <dibblego> > replicate (10^10) 0
03:42:27 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:43:01 <tuukkah> take and replicate take an Int
03:43:21 <int-e> @index genericReplicate
03:43:21 <lambdabot> Data.List
03:43:29 <int-e> @type genericReplicate
03:43:30 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
03:44:27 <int-e> > iterate (concat . replicate 10) [0] !! 10
03:44:28 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:46:30 <int-e> > length $ (iterate ((!! 3) . iterate) (0:) !! 3) []
03:46:31 <lambdabot>   Couldn't match expected type `[a -> a]'
03:46:31 <lambdabot>         against inferred type `a ->...
03:46:57 <tuukkah> damn, now i start to get memory blowups
03:47:29 <int-e> > length $ (iterate ((!! 3) . flip iterate id . (.)) (0:) !! 3) [] -- hmm, less pretty than I'd hoped.
03:47:29 <lambdabot>   27
03:52:17 <int-e> > length $ (((!! 3) .) . iterate) (((!! 4) .) . iterate) (0:) [] -- better. church numerals are fun.
03:52:18 <lambdabot>   64
03:52:54 <tuukkah> vegai, thanks, i was using HList-0.1. any other issues?
04:00:43 <vegai> tuukkah: builds fine after that
04:01:13 <tuukkah> i'd like to continue to support HList-0.1 as well for the time being. is there any catch in using {-# LANGUAGE CPP #-} for that - and how exactly do i get the library version as a cpp variable?
04:01:56 <vegai> I hope it's not because apt-get install gives you 0.1? :P
04:02:30 <tuukkah> not because it gives *me* 0.1, but because it gives everyone else 0.1 =-/
04:03:04 <vegai> criticizing my English again, are you? :)
04:03:20 <SamB_XP> vegai: don't think so
04:03:56 <SamB_XP> I think he means he could easily enough install a newer version for himself, but not for everyone else ;-)
04:04:39 <vegai> yes, ok... HList-0.2 is rather new
04:05:39 <tuukkah> vegai, sorry, what SamB_XP said. i'm misunderstanding english again :-)
04:06:33 <vegai> I seem to remember an argument regarding the subjunctive in English...
04:07:17 <tuukkah> ouch, if you still remember it, i better apologise :-/
04:08:15 <SamB_XP> the what now ?
04:09:42 <tuukkah> SamB_XP, what do you mean to ask?
04:09:58 * SamB_XP forgot what subjunctive means
04:10:03 <vegai> nah, it was great humbling experience
04:10:22 <SamB_XP> vegai: you mean he was right ?
04:10:38 <vegai> I don't remember, probably. That's not the point, though
04:10:51 <SamB_XP> what is?
04:11:00 <vegai> that I was dead sure *I* was
04:11:33 <SamB_XP> ah
04:12:14 <vegai> and I believe tuukka just used the subjunctive there, no?
04:12:20 <SamB_XP> I suppose it's always possible you were both wrong ;-)
04:12:39 <vegai> it's still a bit confusing to me, I admit
04:12:52 <SamB_XP> what, being wrong?
04:13:00 <vegai> the subjunctive
04:13:10 <SamB_XP> ;-P
04:13:15 <vegai> "I better apologise"?
04:13:18 <tuukkah> probably we were both wrong, these days, all arguments can be diverted to wikipedia %-)
04:13:27 <vegai> yes, good times
04:14:01 <SamB_XP> there aren't enough weapons available on Talk: pages, though!
04:14:25 <SamB_XP> for some reason, they've banned nuclear arms!
04:14:25 <Alpounet> Flip can't be a Functor instance right ?
04:17:45 <tuukkah> so. i'm trying to find the documentation for LANGUAGE CPP, but I haven't found anything yet. any pointers?
04:19:05 <SamB_XP> tuukkah: I don't think there's any nice way to get the version of HList in a cpp variable
04:19:30 <SamB_XP> you could do something with a Cabal conditional though
04:19:43 <tuukkah> this is documentation but not very deep ;-) http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html#v%3ACPP
04:20:07 <SamB_XP> tuukkah: you could look in the GHC manual maybe?
04:20:26 <Alpounet> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
04:20:30 <Alpounet> but anyway...
04:20:49 <tuukkah> SamB_XP, that manual page links to that "documentation"
04:21:01 <SamB_XP> heh
04:21:10 <tuukkah> (the manual page that Alpounet linked to)
04:21:22 <Alpounet> then #ghc or the ghc ML looks to be the right place to ask :-)
04:21:24 <SamB_XP> tuukkah: maybe you should look at the documentation for -cpp?
04:21:33 <SamB_XP> GHC has it's own ML?
04:21:58 <SamB_XP> I thought it was just a Haskell and Cmm compiler?
04:22:28 <Alpounet> http://www.haskell.org/mailman/listinfo looks like it has
04:22:31 <opqdonut> *rimshot*
04:22:52 <Alpounet> http://www.haskell.org/mailman/listinfo/glasgow-haskell-users this one
04:23:37 <tuukkah> perhaps this is applicable: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor
04:25:05 <SamB_XP> tuukkah: yeah, that looks good
04:25:13 <tuukkah> so I can test for HOST_OS and HOST_ARCH but not much more
04:28:22 <SamB_XP> tuukkah: I think you could define a flag yourself using Cabal's conditionals
04:28:26 <SamB_XP> which work both ways
04:31:59 <tuukkah> in theory, i could also require HList == 0.1 and force vegai to cabal install HList-0.1
04:32:22 <dcoutts> == is almost always wrong
04:32:34 <dcoutts> HList == 0.1.* is defensible
04:32:42 <dcoutts> if HList follows the PVP
04:33:01 <tuukkah> 0.1.1 doesn't work either, i already tried
04:33:15 <SamB_XP> that's not good
04:33:28 <tuukkah> and 0.1.* is some new special syntax, right?
04:33:50 <SamB_XP> define new?
04:34:26 <tuukkah> something that i saw somewhere and they cautioned against using it as it's "new"
04:35:15 <tuukkah> who knows, perhaps the cabal specs will tell me which version is "new" in this sense
04:36:26 <dcoutts> tuukkah: the impl will tell you if you're using it when you're not supposed to
04:36:38 <dcoutts> eg if your cabal-version: >= x.y is too low
04:36:47 <ivanm> @wn defensible
04:36:48 <lambdabot> *** "defensible" wn "WordNet (r) 2.0"
04:36:49 <lambdabot> defensible
04:36:49 <lambdabot>      adj : capable of being defended [syn: {defendable}]
04:36:55 <ivanm> hmmm, so it is a word...
04:37:01 <ivanm> dcoutts: not that I doubted you or anything... :p
04:37:53 <SamB_XP> ivanm: yeah, not only is it a word, but apparently he spelled it korrectly!
04:38:02 <tuukkah> so i better test
04:38:04 <ivanm> heh
04:38:33 * SamB_XP wonders if he accidentally misspelled anything
04:40:06 <yitz> hi folks. been busy getting my debian testing to boot again after the upgrade to grub 2. :(
04:41:01 <yitz> SamB_XP: no such thng as mspelng on irc
04:44:47 <tuukkah> actually, i seem to have forgotten the whole cabal-version field and got no warning. further, with "Cabal-Version:  >= 0.0", i get no warning about "HList == 0.1.*". (this on Cabal-1.6.0.3)
04:45:05 <ivanm> ...
04:45:15 <ivanm> tuukkah: it's legal for 1.6, not for previous versions
04:46:05 <tuukkah> now, which version do my users have...
04:47:00 <tuukkah> (and, am i thinking of the users or making this more difficult than it actually is?)
04:51:53 <tuukkah> seems to be so that if they have ghc-6.10 then they have cabal-1.6
04:53:02 <ivanm> yes
04:56:26 <SamB_XP> PuTTY really ought to turn off the mouse junk when it gets disconnected and you reconnect ...
04:56:38 <ray> what
04:56:46 <ray> WHAT
04:56:50 <tuukkah> now here's something i wanted to know: "Cabal supplies a macro MIN_VERSION_package(A,B,C)  for each package depended on via build-depends." http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#cpp
04:58:11 <Somalia> Hello guys!
04:59:00 <Somalia> Im trying to compare two lists and then return the numbers that exists in both lists to new list!
04:59:46 <abbe> Somalia: intersection you mean.
05:00:11 <ilid> Somalia: are the lists sorted? do you have Ord on the elements? Eq?
05:00:30 <Somalia> abbe yes!
05:00:40 <ivanm> @hoogle intersect
05:00:41 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
05:00:41 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
05:00:41 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
05:00:43 <abbe> > intersect [10,20,30] [20,40]
05:00:44 <lambdabot>   [20]
05:00:49 <abbe> Somalia: ^^^
05:01:05 <ivanm> or, if you're talking about lists with unique elements, then using Set would probably be better
05:01:28 <ivanm> intersect would be O(n*m), wouldn't it?
05:01:42 <ilid> intersect is O(nm), but if you have Ord it can be done in O(n log n + m log m)
05:02:03 <SamB_XP> ilid: that sounds worse ;-)
05:02:15 <SamB_XP> well, I guess not really
05:02:21 <ilid> sounds worse but is usually better
05:02:33 <ilid> it depends on the relative sizes of the two lists
05:02:49 <SamB_XP> but it sounds like a pain to use in calculations ;-)
05:02:59 <SamB_XP> or proofs
05:03:16 <tuukkah> assume n == m so you get O(n^2) vs. O(n log n) =)
05:03:18 <SamB_XP> and, if you have Ord, Set is what you want anyway ;-)
05:03:36 <ilid> SamB_XP: would using O((n+m) log (n+m)) make you happier?;-)
05:03:37 <SamB_XP> tuukkah: well, multiples don't actually drop out here ;-P
05:03:57 <SamB_XP> ilid: hmm. It *looks* nicer
05:04:08 <SamB_XP> is it equivalent, or looser?
05:04:14 <tuukkah> SamB_XP, umm, where?
05:04:15 <ivanm> it would look nicer if you could have different size parentheses...
05:04:24 <int-e> O((n+m)log(min(n, m)))?
05:04:27 <SamB_XP> tuukkah: in the real world
05:04:38 <ivanm> O\left((n+m) \log (n+m)\right) ;-)
05:04:47 <SamB_XP> int-e: that's the same thing
05:04:48 <quicksilver> multiples always drop out inside O(), because that's what O() means
05:04:51 <tuukkah> so real world doesn't use the O notation
05:04:52 <quicksilver> in the real world.
05:05:00 <int-e> SamB_XP: not if one of n or m is constant
05:05:03 <SamB_XP> quicksilver: okay, true
05:05:18 <SamB_XP> int-e: hmm
05:05:48 <int-e> (multi-variable asymptotics are tricky - the big-O-notation is not quite sufficient)
05:06:05 <SamB_XP> what the ... I stayed logged in to campus cruiser across a browser restart ???
05:06:14 <ivanm> lucky you
05:06:16 <ivanm> ;-)
05:07:01 <tuukkah> i'd say O notation is enough but you need to do separate analysis if some of the variables change to constants
05:07:39 <int-e> tuukkah: so what if n = log(m)?
05:07:53 <yitz> @src intersect
05:07:53 <lambdabot> intersect = intersectBy (==)
05:08:06 <yitz> @src intersectBy
05:08:06 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
05:08:23 <tuukkah> int-e, right, so in the general case, you need to do separate analysis for such situations as well
05:08:29 <SamB_XP> ivanm: and the military made me restart the browser, too ;-P
05:08:38 <ivanm> heh
05:08:49 <SamB_XP> really!
05:09:32 <data_jepp> WEEEEEEEEEEE I can use parsec for my tiny parser. :D
05:10:06 * SamB_XP was trying to send them his transcript for the purpose of being considered for an engineering job -- but the .zip he sent the html + css in was rejected, so he was advised to send a screenshot, but he needed a firefox plugin in order to get his whole transcript into the screenshot ;-)
05:13:19 <tuukkah> SamB_XP, hmm, what about printing the page to pdf?
05:13:19 <ivanm> heh
05:13:24 <ivanm> about to suggest that
05:13:33 <ivanm> SamB_XP: transcript as in uni transcript?
05:13:48 * ivanm copy/pasted the text on the online transcript when he needed it...
05:14:07 <SamB_XP> ivanm: yeah
05:14:10 <SamB_XP> I tried that
05:14:17 <SamB_XP> but it came through very badly for some reason
05:14:19 <ivanm> heh
05:14:30 <ivanm> SamB_XP: save the web-page, run pandoc on it to get the markdown, send markdown
05:14:31 <ivanm> ;-)
05:14:35 <tuukkah> ours is txt =)
05:14:35 <SamB_XP> heh
05:14:56 <SamB_XP> yeah, I wish the transcript feature hadn't been "updated" to use HTML
05:15:30 <ivanm> well, when I needed it ours was basically text in a web page
05:15:38 <ivanm> dunno what it is now, as they've updated the system since then
05:15:44 <SamB_XP> the Program Evaluation still essentially uses plaintext -- it's just stuck in a <pre></pre> wrapper, afaict
05:16:11 <SamB_XP> but it even has page headings in it ;-)
05:16:29 <ivanm> @pl \(a,b) -> (f a, f b)
05:16:30 <lambdabot> f *** f
05:16:49 <SamB_XP> @pl \(a,b) -> (f u a, f u b)
05:16:50 <lambdabot> f u *** f u
05:17:14 <SamB_XP> childish, I know ...
05:17:49 <simplicio> @pl \f (a,b) -> (f a, f b)
05:17:49 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
05:18:30 <SamB_XP> lambdabot: that's disgusting!
05:19:34 <simplicio> > join (***) f (a,b)
05:19:35 <lambdabot>   Ambiguous type variable `c' in the constraints:
05:19:35 <lambdabot>    `GHC.Show.Show c'
05:19:35 <lambdabot>      a...
05:19:54 <ivanm> eh, turns out I didn't want f on the second term anyway *shrug*
05:32:27 <darrint> Is there a paper that covers generating code with the ghc api?
05:32:45 <SamB_XP> ivanm: huh, the transcript in PNG format is bigger than my resume in .docx format ... though I guess it may also contain more text ;-P
05:32:53 <SamB_XP> darrint: I don't think so
05:32:56 <ivanm> heh
05:33:00 <ivanm> SamB_XP: .docx? really?
05:33:13 <ivanm> darrint: it changes from release to release, so it's unlikely
05:33:31 <SamB_XP> .docx seems a heck of a lot slimmer than Word's classic .doc
05:33:41 <EvilTerran> docx is zipped XML, isn't it?
05:34:00 <SamB_XP> possibly because it doesn't go for false economy with a binary format, but just stuffs XML in a zip file ;-)
05:34:03 <EvilTerran> i guess the zipping would eliminate the fundamental bulkiness of the XML
05:34:25 <SamB_XP> it's more adaptive than a fixed binary format, too
05:34:29 <darrint> Maybe that's a dumb question. Is there some literature covering javascript generation in haskell? Besides yhc/core?
05:35:30 <byorgey> darrint: there are several libraries for javascript generation, check on Hackage
05:35:55 <EvilTerran> (http://hackage.haskell.org/packages/archive/pkg-list.html)
05:36:01 <tuukkah> vegai, thanks, it's a nice little patch in the end and i learned some new tricks on the way :-) http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs/_darcs/patches/20091006121941-0f16d-1150bf2c80942140b4c9f97211a8fb0ea57fbb54.gz
05:36:08 <byorgey> darrint: e.g. check out jmacro
05:37:05 <darrint> thanks.
05:37:22 <ivanm> EvilTerran: yup
05:37:56 <vegai> tuukkah: nice :)
05:39:14 <tuukkah> vegai, do you know berners-lee's team at mit has created this competitor called the tabulator ?-)
05:40:29 <tuukkah> (as a firefox extension: http://dig.csail.mit.edu/2007/tab/ )
05:41:30 <SamB_XP> what's that for ?
05:41:40 <SamB_XP> oh, that's an RDF thinger?
05:42:07 * SamB_XP seems to recall this, didn't actually look at the page just now
05:43:11 <tuukkah> SamB_XP, long story short, it's an RDF browser and editor for helping to bootstrap a Web of Data to go alongside the existing web (of documents)
05:49:46 <bastl> tried to install leksah, but get this depenbdency error : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4279#a4279
05:50:36 <bastl> how can i work around that?
05:53:00 <ivanm> bastl: uninstall regex-base-0.72 and install regex-base-0.93?
05:53:06 <ivanm> bastl: how are you trying to install it?
05:53:23 <ivanm> wait, why is it trying to install 0.92?
05:53:33 <ivanm> bastl: methinks you've got something else screwing up...
05:53:35 <ivanm> more logs?
05:54:13 <bastl> im inspecting the cabal file now. it requires regex-base==0.72.0.2. is that correct ?
05:55:18 <bastl> turning that to regex-base>=0.72.0.2 does it (it's building right now)
05:55:38 <ivanm> yes, it needs 0.72
05:55:54 <ivanm> bastl: you must have something else wanting 0.93
05:56:08 <ivanm> note that the 0.7x and 0.9y series are incompatible (apparently)
05:57:11 <darrint> I haven't trolled hackage much lately. HSP appears to have really come along.
05:57:21 <int-e> so the regex-compat and regex-posix dependencies should be restricted as well, because cabal-install isn't smart enough to figure out that it can use an earlier version of those.
06:01:01 <bastl> cool: leksah reports "File does not exist /home/jutaro/Develop/leksah/data/welcome.txt" (and jutaro is not my username ...)
06:01:30 <ivanm> \o/
06:01:38 <ivanm> bastl: is this an official release?
06:02:08 <bastl> 0.6.1 from cabal-install
06:03:00 <ivanm> yeah, someone tested _really_ well...
06:04:09 <Alpounet> bastl, I ad the same
06:04:12 <Alpounet> had*
06:04:16 <Alpounet> it's not important anyway :p
06:04:53 <bastl> anyhow: it looks quite good. is it good enough for daytoday use ?
06:31:21 <yakov> hey
06:31:35 <yakov> does it mean that value-supply does not work http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10495#a10496 ?
06:31:48 <yakov> (with recent GHC from darcs)
06:32:02 <Itkovian> Any pointers where to look for the reason why +RTS -N4 sucks up RAM auickly, going to 2GB in < 20s and uses only 140% CPU, whereas +RTS -N8 stays for four minutes under 1GB RAM usage while using 650% CPU? using GHC 6.10.2 on a corei7.
06:33:41 <quicksilver> Itkovian: No, I don't think anybody would be able to tell without looking at the code
06:33:50 <quicksilver> such behaviour is certainly possible.
06:34:23 <quicksilver> sparks can process data so that areas of heap can be gc'ed earlier
06:35:20 <Itkovian> ah ok.
06:36:20 <quicksilver> the classic example is (sum xs / length xs)
06:36:39 <quicksilver> the sequential evalution of this keeps xs live until the end
06:36:58 <quicksilver> ...so if xs is lazily generated and very large, that is a "memory leak"
06:37:29 <quicksilver> however if you have one spark working on "sum xs" and one on "length xs" the already-processed portions of xs can be GCed as you go along
06:37:32 <quicksilver> and it runs in constant space.
06:37:43 <quicksilver> Presumably your code exhibits a more complex example of this kind of behaviour.
06:39:19 <yakov> aha, missed that `split' bit.. anyhow, what is the point of using value-supply if the supply is needed to be threaded anyway (=> monadic code) in case when i want to get values in different places?
06:39:44 <yakov> i.e. it's impossible to just give supply value to that places and ask it for values :-(
06:40:00 <Tobsan> is the concat function in Data.ByteString.Lazy really lazy? That is, may I read all of the first before it is concated with the second?
06:41:54 <PeakerWork> quicksilver: or if you use Conal's "More beautiful folds" its eliminated too
06:42:51 <PeakerWork> http://conal.net/blog/posts/more-beautiful-fold-zipping/
06:48:30 <Tobsan> I want to concat many small bytestrings, but to do that in a strict way is not desired for that many bytestrings
06:49:53 <quicksilver> lazy bytestring concat is O(1)
06:50:02 <Tobsan> SWEET!
06:50:07 <quicksilver> "in a strict way" is not a very well-defined phrase
06:50:13 <quicksilver> lots of people mean lots of different things by that.
06:50:27 <ivanm> quicksilver: you mean it doesn't matter how many you have, it takes the same amount of time? :o
06:50:31 <quicksilver> I imagine you might mean - "strict Bytestring 'concat' does a memory copy of both strings"
06:50:39 <Tobsan> quicksilver: yes, that what I meant.
06:50:45 <quicksilver> if that is what you meant, then yes, lazy Bytestring 'concat' does a memory copy of neither
06:50:46 <Tobsan> sorry for not being explicit about that :D
06:50:53 <quicksilver> it just makes a new cons cell which points to the old ones.
06:50:56 <EnglishGent> hi Tobsan, quicksilver :)
06:51:02 <Tobsan> Hi EnglishGent
06:51:28 <quicksilver> what there isn't (but probably should be) is any way to normalise the excessive fragmentation you might get
06:51:30 <Esteth> Hey everyone. I'm trying to install the fsmActions modules from hackage, but using "cabal install fsmActions" downloads them, but fails to compile with an error: 'DotGraph is not applied to enough type arguments'. I'm not sure if it's a problem with me, or with the module. Shall I paste the whole error at hpaste?
06:51:58 <quicksilver> ...but that doesn't encessarily matter.
06:52:18 <Tobsan> quicksilver: alright. We'll probably use that module then!
06:59:14 <jeffersonheard> hrm.  someone apparently asked me a question over the weekend and I left myself logged in and not away
06:59:17 <jeffersonheard> it has gone awa
06:59:18 <ivanm> Esteth: they're using an old version of the graphviz library
06:59:19 <jeffersonheard> y
06:59:26 <ivanm> Esteth: and don't have an appropriate upper bound
07:00:44 <Esteth> ivanm: Aha, thanks. I shall have a little delve and see if I can fix it myself.
07:01:02 <ivanm> Esteth: he needs to either update his package or have an upper bound of < 2999.6.0.0
07:01:15 <ivanm> Esteth: the fix is simple: replace all "DotGraph" with "DotGraph Node"
07:01:19 <ivanm> s/Node/Int/
07:06:01 <Esteth> ivanm: I'm not used to using the cabal tool for autodownloading/installation of modules. Do you know where one would find the downloaded source after you use cabal fetch?
07:06:15 <ivanm> in ~/.cabal/ somewhere
07:06:35 <dcoutts> Esteth: use: cabal unpack pkgname
07:06:53 <dcoutts> there's no need to go searching for the downloaded tarball
07:07:11 <Esteth> aha, thank you :)
07:10:09 <pozic> Does anyone know how sophisticated Atom is? Hard-real time seems to be only possible if you compile to a target for which you really know everything.
07:10:43 <pozic> It seemed that it compiled to C, but then you also have to know how long certain C library functions take to execute and so on.
07:11:31 <pozic> Then there is also the difference between knowing that a computation takes at most time T and knowing that it takes exactly time T.
07:17:26 <Phyx-> lol
07:20:17 <Phyx-> hmm http://haskell.org/ghc/cygwin/ is missing setup.ini.sig
07:20:44 <Phyx-> it won't let it be added as a valid cygwin source without it
07:22:31 <Phyx-> ah, -X should skip it
07:22:59 <McManiaC> hmmm im having problems using emacs haskell modeâ€¦
07:23:20 <McManiaC> when i try to run ghci i get "Symbol's function definition is void: switch-to-haskell"
07:25:28 <halcyon10> tuukkah: still around?
07:26:45 <ivanm> gah, dot seems to refuse to layout nodes in a line if they aren't connected by edges :@
07:27:07 <tuukkah> halcyon10, yes
07:28:14 <halcyon10> tuukkah: oh, cool, sorry for the delay, i've pasted a minimal example where my space-leak with length occures at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10488
07:29:06 <halcyon10> tuukkah: i've just made up a random process that generates a list of Double-pairs which is then consumed by length
07:30:51 <Phyx-> ohh, netsplit
07:31:12 <tuukkah> halcyon10, ok, i can see the space leak
07:31:45 <hackagebot> dedukti 1.0.2 - A type-checker for the » -modulo calculus. (MathieuBoespflug)
07:32:12 <pozic> ivanm: that's not true.
07:32:26 <pozic> ivanm: or is this a secret tactic to get the right answer?
07:32:38 <ivanm> pozic: it is refusing here!
07:33:03 <pozic> ivanm: computers do exactly what you tell them ;)
07:33:08 <ivanm> (well, unless my graphviz lib is generating the Dot code wrong, which is, of course, impossible... :p )
07:33:22 <ivanm> pozic: yes, but the algorithm that dot seems to use doesn't allow it to do what I want it to do...
07:33:26 <pozic> ivanm: anyway, there is a way to make sub-graphs.
07:33:33 <pozic> ivanm: that is a way to do it.
07:33:34 <ivanm> I don't want sub-graphs ;-)
07:33:51 <Phyx-> ivanm with some engines i've had it do weird stuff too
07:33:57 <Phyx-> like not laying out anything
07:34:08 <halcyon10> tuukkah: is there a way to get rid of these kind of space leaks with length, where an arbitrary process produces my list?
07:34:11 <pozic> ivanm: it is an implementation detail you have to take care about if you want to express this.
07:35:21 <ivanm> :s
07:35:23 <pozic> I would still be interested in hearing someone talk about Atom(isn't there some video somewhere)?
07:35:56 <tuukkah> halcyon10, you could still simplify the example some, but i'd guess the reason is the use of iterate. as each value depends on all the previous ones, the beginning of the list stays in memory until none of the list is needed anymore
07:35:57 <pozic> I think I sort of see what they did. To get to a true real-time system, you need very reliable timers.
07:36:28 <tuukkah> (not the list per se, but all the values in the list)
07:36:30 <pozic> But they seem to be able to get as real-time as that there are timers, so quite nice.
07:38:22 <halcyon10> tuukkah: in my real problem the list producer is even more complex, i thought since length isn't interested in the content of the elements itself it could consume away what it gets from the list-producer, what is wrong with ny thought?
07:38:24 <halcyon10> my
07:38:25 <Phyx-> > mic test
07:38:26 <lambdabot>   Not in scope: `mic'Not in scope: `test'
07:39:13 <ivanm> pozic: *fine then*
07:39:26 <pozic> ivanm: good boy
07:39:39 <ivanm> @slap pozic
07:39:40 <lambdabot> Come on, let's all slap pozic
07:39:56 * Phyx- slaps pozic :requested
07:40:08 <halcyon10> tuukkah: and if i want to output the samples itself with (putStrLn.show) instead of ouputting the length of the list it runs in constant space...
07:40:42 <ivanm> pozic: tried that, didn't do anything
07:41:24 <ivanm> pozic: unless you mean to put all of the nodes in one sub graph?
07:41:31 <tuukkah> halcyon10, showing the value forces it, freeing the intermediate values that far
07:41:58 <pozic> ivanm: it's not just putting it in a sub-graph, you have to do something else too. It's never simple, is it?
07:42:12 <ivanm> I specified rank="same"
07:42:29 <halcyon10> tuukkah: i see, and how can i get length to force evaluation?
07:42:59 <tuukkah> halcyon10, well, here's one suggestion: http://hackage.haskell.org/trac/ghc/ticket/3474
07:43:14 <tuukkah> to do the forcing in iterate
07:44:02 <pozic> ivanm: I cannot help you more, sorry. Getting the exact right output from graphviz takes time.
07:44:15 <tuukkah> that still leaks memory though, but at least not as much
07:45:36 <halcyon10> tuukkah: thanks for the link, then i'll try to make a strict version of length with `seq` now
07:45:53 <tuukkah> halcyon10, this seems to work well: "pairMap f (!x,!y) = (f x, f y)"
07:46:12 <Botje> tuukkah: you could also use strict tuples
07:46:54 <halcyon10> tuukkah: oh, i'll try that
07:47:12 <ivanm> pozic: yeah, I know :s
07:47:14 <Botje> (oh, was that for halcyon10. oops :))
07:47:41 <halcyon10> Botje: i'll try that too, thx ;)
07:48:10 <tuukkah> Botje, what do those look like again?
07:49:09 <Botje> :*: iirc
07:49:13 <Botje> @hoogle (:*:)
07:49:13 <lambdabot> No results found
07:49:20 <Rotaerk> hmm... SYB seems like a bad approach when most of your state is in the form of maps
07:49:52 <Rotaerk> since that breaks the whole advantage of the maps being binary trees for fast lookup
07:49:54 <Botje> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/Data-Strict-Tuple.html
07:50:00 <orbitz> why is it taht f = map show does not compile without be giving the type: f :: Show a => [a] -> [String] ?
07:50:06 <orbitz> this must be in the faq soemwhere right?
07:50:13 <Botje> Rotaerk: don't worry, map's Data interface is purposefully broken
07:50:30 <Botje> orbitz: the dreaded monomorphism restriction
07:51:12 <Rotaerk> map's "Data interface"?
07:51:14 <orbitz> so this is teh haskell standard tryign to be safer
07:51:19 <orbitz> http://www.haskell.org/onlinereport/decls.html#sect4.5.5
07:51:26 <ivanm> orbitz: monomorphism restriction?
07:51:34 <ivanm> ahhh, Botje beat me to it
07:52:15 <orbitz> thanks! this section of haskell report makes sense
07:52:18 <Botje> Rotaerk: doesn't SYB use Data to infer the correct instances for your types?
07:53:09 <Rotaerk> hmm, I haven't actually used the SYB package, just read part of an early paper on it
07:53:25 <Rotaerk> and referring to the general approach of generic traversal over the entire state
07:53:44 <Botje> well, SYB is designed to go through your entire data structure anyway
07:54:28 <halcyon10> how can i hide functions in the prelude?
07:54:45 <quicksilver> import Prelude hiding (...)
07:54:45 <Zao> import Prelude hiding (omg, wtf, bbq) ?
07:54:55 <halcyon10> Zao: thx
07:55:01 <Zao> There's also an NoImplicitPrelude GHC option, but I've got no clue what it changes.
07:55:14 <quicksilver> stuff like the desugaring of list comps and monad notation
07:55:33 <ivanm> pozic: OK, I take it back, it works
07:55:56 <ivanm> it helps if my app actually builds properly before I try to use it :s
07:56:57 <Rotaerk> anyway, the problem I have in my code is that I have to dig down into my state, change something, and climb back out of it, whenever I want to, say, change an attribute of a character
07:57:26 <Rotaerk> I have GameState { characterTable :: CharacterTable }, where CharacterTable is Map CharacterID CharacterState
07:57:41 <pozic> @slap ivanm
07:57:41 * lambdabot decomposes ivanm into several parts using the Banach-Tarski theorem and reassembles them to get two copies of ivanm!
07:57:53 <Zao> quicksilver: Oh right, I read about it in that ParametrizedMonad article.
07:58:16 <Rotaerk> so I have to get the character table, then lookup the character, change the property, then replace the character in the table, then replace the table in the state
07:58:29 <byorgey> Rotaerk: you should take a look at a package like  fclabels or data-accessor
07:58:37 <Rotaerk> just seems like there should be a way to reduce that work... without traversing the entire table
07:58:42 <Rotaerk> hmm
08:03:46 <halcyon10> tukkah,Botje: i tried the bang pattern in pairMap and the strict Pair type but i still have a space leak, my current version looks like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10488#a10500
08:05:18 <quicksilver> Rotaerk: irrespective of whether you use data-accessor or not, the answer is simply 'write functions to make it easy'
08:05:25 <quicksilver> Rotaerk: that's almost always the answer :)
08:06:00 <Rotaerk> hmm and I guess code generation is the answer to building those functions
08:06:51 <Rotaerk> fclabels uses "Template Haskell"
08:06:53 <tuukkah> halcyon10, yeah, this is tricky. the bang pattern plus iterate' seems to be enough though
08:06:59 <Rotaerk> the use case of fclabels is nice though
08:07:11 <halcyon10> tuukkah, ok, i'll try that
08:09:00 <Andreas_> Hi, I just downloaded and installed cabal-install; the installation went fine, but when I run "cabal update" I get the error "cabal: user error (Codec.Compression.Zlib: incompatible version)". I am running Mac OS X Snow Leopard and ghc 6.10.4. Does anyone have any pointers on how to fix this?
08:09:31 <dcoutts> Andreas_: your ghc installation isn't fully fixed up yet
08:09:31 <Rotaerk> meh, don't care for fclabels... involves code generation AND prelude hiding
08:09:53 <Rotaerk> though I'll use it, or something like it, if I have to
08:09:56 <dcoutts> Andreas_: you presumably modified the ghc shell script to add -optc-m32 or whatever
08:10:04 <halcyon10> tuukkah: yay, the iterate' does the trick, now it runs in constant space :) i'll try to carry the idea over to my more complex code
08:10:18 <quicksilver> Rotaerk: code generation isn't required, it's normally a small amount of boilerplate you only have to write once
08:10:28 <dcoutts> Andreas_: but that's not the only fix required, you also need to do something similar to the hsc2hs script, otherwise it thinks it's working in a 64bit environment
08:10:29 <Rotaerk> k
08:10:29 <quicksilver> it's an annoyance, but a bounded one.
08:10:38 <quicksilver> I mean for the technique in general
08:10:45 <quicksilver> I don't know anythign about fclabels in particular :)
08:10:49 <dcoutts> Andreas_: that's why the zlib bindings are being compiled wrong (they think they're talking to a 64bit zlib)
08:10:57 <Rotaerk> looking into data-accessor now
08:11:13 <Andreas_> yeah, i modified the scripts with the options you mentioned
08:11:30 <dcoutts> Andreas_: right, so you just need to do the same kind of thing to hsc2hs
08:11:41 <dcoutts> Andreas_: and rebuild the zlib binding
08:12:00 <Andreas_> OK, thanks, I'll try that - so same options for hsc2hs, right?
08:12:06 <pozic> Why doesn't GHC parser do a simple traversal in case of a failed parse to check for parentheses that are not matching?
08:12:15 <pozic> +the
08:12:57 <dcoutts> Andreas_: the options to pass to gcc are the same
08:13:28 <dcoutts> Andreas_: so it's not "-optc" since that's the ghc passthrough flag, look up what the hsc2hs equivalent is
08:15:40 <Rotaerk> hmm I wonder if it'd be a good idea to have transactional state changes.  i.e. have a DSL that describes changes to state, and then pass a list of changes to a state transformer
08:16:01 <Rotaerk> that way I don't end up recreating the entire state for every little incremental change
08:16:11 <quicksilver> sometimes that's worth it
08:16:17 <quicksilver> sometimes that's overengineering :)
08:16:27 <quicksilver> aim for a pleasant API first off
08:16:30 <Rotaerk> hmm true
08:16:42 <quicksilver> worry about efficiency when (if) problems are demonstrated with the simple approach
08:16:47 <quicksilver> modifying maps is already fairly efficient.
08:18:58 <Rotaerk> okay yea, doing that right off the bat would be a case of premature optimization
08:23:31 <daniel> hey, just wondering if someone know how to generate two lists when making a mergesort in haskell using drop and take funktion?
08:23:56 <daniel> hey, just wondering if someone know how to generate two lists when making a mergesort in haskell using drop and take funktion?
08:24:13 <Axman6> what about splitAt?
08:24:22 <Axman6> > splitAt 7 [1..10]
08:24:23 <lambdabot>   ([1,2,3,4,5,6,7],[8,9,10])
08:24:39 <daniel> yeah i know but need to use drop function :/
08:24:48 <Axman6> @src splitAt
08:24:49 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:24:52 <daniel> got stuck in an assignment
08:25:11 <hackagebot> Graphalyze 0.8.0.0 - Graph-Theoretic Analysis library. (IvanMiljenovic)
08:25:38 <daniel> thanks
08:25:42 <Rotaerk> what does that hackagebot message mean? a package just got introduced/updated?
08:25:50 <byorgey> Rotaerk: yup
08:26:27 <Zao> Rotaerk: It announces new uploads to Hackage.
08:26:44 <Zao> It will also plot behind your back together with lambdabot for your demise.
08:26:53 <Rotaerk> uh oh
08:27:02 <byorgey> oh noes!
08:27:19 <quicksilver> actually, only Zao's demise, I think
08:27:20 * Rotaerk puts lambdabot into an infinite recursion to distract him
08:27:59 <byorgey> lambdabot is too smart for that
08:28:04 <byorgey> > let x = x + 1 in x
08:28:09 <lambdabot>   mueval-core: Time limit exceeded
08:28:29 <byorgey> Rotaerk: also, lambdabot is a her =)
08:28:42 <Rotaerk> sorry, didn't check for boobage
08:29:07 <byorgey> Rotaerk: that's not appropriate.
08:30:23 <Andreas_> dcoutts: OK, I found that hsc2hs uses "-C" to pass options to the C compiler, so I've added "-C-m32" to my hsc2hs script. How do I rebuild the zlib binding?
08:30:37 <dcoutts> Andreas_: using cabal
08:34:18 <Guest927> c'è nessuno?
08:36:26 <Rotaerk> byorgey, yea I suppose lambdabot wouldn't like that
08:38:08 <quicksilver> @pl \x y -> (x.) . y
08:38:08 <lambdabot> (.) . (.)
08:38:15 <Andreas_> dcoutts: I tried and failed.... I downloaded the zlib package from hackage (zlib 0.5.2.0), installed it using cabal (which seemed to finish successfully), but still I get the same error when I run "cabal update". BTW I updated hsc2hs to include the following flags when calling hsrc2hs "-C-m32 -L-m32".
08:38:52 <Rotaerk> quicksilver, :O it's true!
08:39:08 <quicksilver> ;)
08:39:42 <dcoutts> Andreas_: you'd also need to rebuild cabal-install, since we're using static linking
08:40:06 <Andreas_> dcoutts: OK; trying that now.
08:46:30 <Andreas_> dcoutts: I somehow managed to mess up runghc - it can no longer find ghc!
08:47:15 <dcoutts> Andreas_: I think it looks on the $PATH
08:47:16 <Andreas_> dcoutts: even though I can invoke ghc as usual
08:47:22 <dcoutts> Andreas_: you can compile Setup.hs
08:50:20 <hackagebot> SourceGraph 0.5.5.0 - Static code analysis using graph-theoretic techniques. (IvanMiljenovic)
08:53:28 <Andreas_> dcoutts: OK, I used ghc to compile the Setup; I uninstalled cabal-install, installed HTTP and zlib, and then cabal-install again; good news: "cabal update" ran successfully; the bad news is that my runghc is still broken.
08:54:04 <dcoutts> Andreas_: great
08:55:30 <Andreas_> dcoutts: ghc is definitely in my path - I see the directory listed in $PATH and I can run ghc at the terminal - it is really odd that runghc can't find.
08:55:55 <dcoutts> Andreas_: people might be able to help if you pasted the error message
08:56:24 <Andreas_> When I run "runghc" I get this: "runghc: cannot find ghc"
08:56:27 <ivanm> hmmm.... why isn't preflex in here?
09:00:46 <Arnar> hi all
09:00:54 <Arnar> :check True
09:01:01 <Arnar> @check True
09:01:02 <lambdabot>   "OK, passed 500 tests."
09:01:23 <Arnar> my local lambdabot won't do this for me :/
09:01:29 <quicksilver> mauke: preflex went away?
09:01:48 <Arnar> complains "caught (and ignoring) too few bytes. Failed reading at byte position 8"
09:02:31 <ilid> is there a name for the inverse of \n -> n * log n?
09:02:49 <ilid> or even a nice expression for it actually
09:04:51 <Arnar> ilid: \x -> exp (x / n) ?    (if log means natural log)
09:05:08 <quicksilver> that's not a proper inverse
09:05:14 <quicksilver> it still has 'n' free in it
09:05:19 <Arnar> sorry missed the \n
09:05:37 <Arnar> in ilid's msg that is
09:05:41 <quicksilver> ilid: off hand, I don't think there is a name for the inverse of that, or indeed the closely related (n^n)
09:06:14 <ilid> is there a nice (non-iterative) way of computing it?
09:06:28 <Andreas_> dcoutts: I found the problem: I was invoking runghc with the GHC flags before the runghc flags, whereas I should have had it the other way around. Flipping the order of the args fixed the problem and now runghc finds ghc.
09:06:36 <Andreas_> dcoutts: thanks for your help!!
09:06:41 <dcoutts> np
09:07:00 <quicksilver> ilid: I would imagine not. (Any more than there is a 'nice' way of computing 'log'...)
09:07:20 <ilid> quicksilver: that's what i suspected :(
09:07:51 <Makoryu> @pl \x n -> exp $ x / n
09:07:52 <lambdabot> (exp .) . (/)
09:08:07 <absentia> which looks more like line noise...  perl or haskell ?
09:08:34 <quicksilver> ilid: but you can surely do one of various power series expansions about various points under various assumptions :)
09:08:35 <jmcarthur_work> perl\
09:08:36 <EvilTerran> n * log n = log(n^n), right?
09:08:38 <jmcarthur_work> -\
09:08:44 <EvilTerran> you might be able to do something with that...
09:08:52 <quicksilver> EvilTerran: right, that's why I called n^n "closely related"
09:09:05 <jmcarthur_work> you can certainly obfuscate haskell quite a bit, but perl is much better at it
09:09:10 <absentia> you know, perl -->  ("@_" =~ m@(?:^|\n)\s*\b$pat\b\s+(?:[^\n]*?)\s*([^\n\s]+?)\s*(?:#[^\n]*?)?\s*(?=\n)@ig);
09:09:34 <absentia> although, granted, that's mostly a regexp.
09:09:38 <quicksilver> EvilTerran: I'm not aware of a standard name for the inverse to \n -> n^n, although I'm sure it must have been given names by some people on a few occasions
09:09:45 <Makoryu> absentia: I think the regexen (especially with embedded subs) hugely tip the boat in Perl's direction.
09:09:58 <quicksilver> http://99-bottles-of-beer.net/language-perl-737.html
09:10:05 <quicksilver> ^^ beautiful obfuscated perl
09:10:11 <absentia> ya.. I looked through those.
09:10:21 <quicksilver> so good most of the commentors think it's not genuine. (It is, though)
09:10:38 <ilid> if x = k log_2 k, then k = fix ((2**) . (x-))
09:14:38 <younder> Anyone here use Haskell with Isabelle, HOL, Isaar?
09:16:47 <Axman6> younder: these guys do: http://www.vimeo.com/6628930
09:17:01 <Axman6> (just mentioned it because i'm watching it at the moment
09:17:19 <younder> thx
09:17:48 <Berengal> I have annecdotal proof that imperative thinking is hard and unnatural
09:18:15 <Rotaerk> anecdotal proof? lol
09:18:46 <Berengal> Don't dismiss anecdotal proofs
09:19:05 <Rotaerk> well let's hear it
09:19:54 <Berengal> I was tasked with writing a huge bunch of xmls at work, and instead of doing that I wrote an xml template in haskell, as well as a parser for an ad-hoc parameter language
09:20:01 <Berengal> Which went pretty well
09:20:18 <Berengal> Until I came to the point where I had to actually read the config file and output the xmls
09:20:31 <laz0r> anyone here that can give me a tip how to get the delete and home keys working in ghci? they always output stuff like ~3.
09:20:36 <byorgey> @oeis 1 1 1 2 3 1 6 11 6 1
09:20:37 <lambdabot>  Triangle T(n,k), 0<=k<=n, read by rows, giving coefficients of the polynomia...
09:20:37 <lambdabot>  [1,1,1,2,3,1,6,11,6,1,24,50,35,10,1,120,274,225,85,15,1,720,1764,1624,735,17...
09:20:41 <Berengal> Which admittedly was done in five lines, but I had to really work hard to figure out what those should be
09:20:56 <laz0r> googling around brought up something to put in my .editrc, but that did not really help
09:21:13 <Berengal> laz0r, which ghc version are you running?
09:21:21 <laz0r> Berengal: 6.10.4
09:21:42 <Berengal> Can't help you then...
09:22:04 <laz0r> too bad, does the newest version use haskeline?
09:22:25 <Berengal> Yes
09:29:53 <dcoutts> blackh: you were right about your unit test and I'm just going senile :-)
09:33:20 <pasc1> i got a treeview displaying a Tree String. i want to access a row by iterator. i tried treeModelGetValue, but i dont get the meaning of the ColumnIds
09:41:42 <dcoutts> pasc1: use the original typed store, rather than accessing it through the untyped TreeModel API
09:42:30 <Axman6> does anyone know what implications making a binding to an LGPLv3 library would have for the licencing of the binding?
09:44:04 <pasc1> are you talking about gtk.modelview.customstore?
09:44:52 <shahn> Axman6: as long as others can link your bindings with other versions of that LGPLed lib, i think, it's ok
09:45:13 <Axman6> what do you mean?
09:45:50 <Jedai> Axman6: No implication as far as I know, since your linking is dynamic
09:46:10 <shahn> That's what i mean :)
09:46:31 <Axman6> ah, ok, excellent
09:48:03 <Jedai> Of course the final user won't be able to statically link in the C library if he don't want to be GPL but that's not different from the situation in any other language
09:48:42 <Axman6> so, i wouldn't have to licence my binding as LGPL?
09:48:49 <Axman6> i could use BSD?
09:48:55 <Jedai> Axman6: The real problem in Haskell is with Haskell library with a LGPL license, since the optimization may mean that some of the code of the library is inlined in the main program... (not speaking of dynamic linking issue with the Haskell library even yet)
09:49:18 <Jedai> Axman6: You could perfectly use BSD for your binding AFAIK but IANAL
09:50:17 <pasc1> dcoutts: what you mean with original typed store?
09:50:30 <dcoutts> pasc1: you made a TreeStore right?
09:50:36 <pasc1> yes
09:50:41 <dcoutts> pasc1: there you go, use that
09:51:09 <dcoutts> not the untyped data-access API of the TreeModel interface
09:57:59 <pasc1> dcoutts: thank you. i got the point ;)
09:58:13 <etienneroesch> hi all
10:00:00 <Axman6> o/ etienneroesch
10:00:27 <Raevel> @seen ivanm
10:00:28 <lambdabot> Unknown command, try @list
10:00:30 <en0th> oh, noes. another c/java course
10:03:17 <en0th> :t foldl
10:03:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:03:36 <etienneroesch> anyone succesfully installed hopengl on macos?
10:03:50 <etienneroesch> or qthaskell on macos?
10:13:56 <halcyon10> hi, i have a problem with a space leak, essentially i want to consume a list of 2D-coordinates by binning them and counting how many lie in which bin. Unfortunately the List is only consumed at the end of its creation so it has huge memory consumption or stack overflow. Anybody an idea how to fix it? (tuukkah or Botje perhaps?) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10488#a10501
10:15:50 <halcyon10> if i just want to compute the number of samples with length i get constant memory use, but if i start to bin them it doesn't work anymore
10:16:09 <Axman6> add strictness annotations?
10:16:30 <halcyon10> Axman6: i use strict pairs already
10:16:34 <MyCatVerbs> halcyon10: If the whole thing needs to be in memory at any point (which is going to happen if you want to sort it) then all you can really do to minimise memory usage is to use most compact representation for the sequences of points.
10:17:36 <halcyon10> MyCatVerbs: but i don't want to sort them, i want to consume them one by one and add one to the bincount, essentially i want to compute the length of a filtered list
10:18:02 <MyCatVerbs> Oh, for some reason I thought you mentioned sorting in there. Excuse me if my brain fails.
10:18:16 <halcyon10> no problem
10:20:27 <Botje> halcyon10: you should break up binSamples into a few separate functions
10:20:32 <Botje> if only to see which one is causing the leak.
10:20:46 <halcyon10> Botje: ok, i'll try that
10:20:48 <thaldyron> dcoutts: Is cabal-install supposed to be race-free when the same 'cabal install foo' is run concurrently by different processes?
10:21:13 <dcoutts> thaldyron: only if they are installing to different prefixes and package dbs.
10:23:48 <Axman6> thaldyron: ... why would you do that? :o
10:24:52 <thaldyron> dcoutts: hmm right, but I guess I will need to add some locking to the world file patch, as the world file is global.
10:25:33 <thaldyron> Axman6: I won't, but someone might do so by accident! ;-)
10:26:03 <Axman6> well someone's going to be surprised when it doesn't work i think
10:27:03 <thaldyron> Axman6: Actually I think it will still work unless you use different flags in one of the builds
10:27:09 <dcoutts> thaldyron: ah, mm
10:28:32 <dcoutts> thaldyron: it's not so bad, at worst you'd loose some updates. Just make sure you use writeFileAtomic
10:30:56 <mauke> quicksilver: I think it got caught on the wrong end of a netsplit
10:31:34 <thaldyron> dcoutts: right, I already use writeFileAtomic so it should be ok.
10:32:15 <dcoutts> thaldyron: I guess to do it properly we would need a file locking API
10:32:31 <dcoutts> ie posix flock and whatever is equivalent on win32
10:34:00 <thaldyron> dcoutts: yeah, but I don't think there's a portable one (yet) or is there?
10:34:07 <dcoutts> not afaik
10:38:11 <halcyon10> Botje: i have broken down the code into smaller functions: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10488#a10502     Now, how do i find out which function the problem is?
10:41:56 <younder> OK, finished my NP /= P proof, mechanically (using Haskell Isabell/HOL/Isaar) I will advise you on the web site tomorrow.
10:42:36 <halcyon10> younder: are you going for the clay prize?
10:42:45 <Botje> halcyon10: lower the input size and look at the heap profile?
10:43:22 <Botje> halcyon10: can the map itself fit in memory?
10:43:27 <mistermatt> how does one make a proof of NP /= P
10:43:36 <younder> halcyon10: no, It just annoyed me
10:43:38 <Zao> It's trivial, but this here margin...
10:43:54 <Makoryu> mistermatt: It's easy, just recalibrate your java googles
10:44:02 <mistermatt> technically anythign is 'trivial' if it's been done before
10:44:52 <halcyon10> Botje: yes, the Map fits into memory that is, the program runs without stack overflow, but the memory grows linearly in time in the heap profile
10:45:33 <halcyon10> Botje: the heap profile has only one Color with legend: incBin/binSamples/main
10:45:42 <kakeman> how should i use darcs and package manager?
10:45:57 <kakeman> should i install everything via darcs?
10:45:59 <Berengal> kakeman, independently
10:46:19 <halcyon10> younder: i see, but you would take the million if your proof is correct?
10:46:20 <Berengal> darcs is a revision control system. It doesn't do package management at all
10:47:05 <Botje> halcyon10: the foldl' is probably doing it. Can't you construct the map in one go?
10:47:09 <younder> halcyon10: sure
10:50:12 <Botje> halcyon10: you could use map (head &&& length) . group . sort $ sampleIndices
10:50:16 <halcyon10> Botje: i had an alternate version without Map, just with filtering and length, but that seemed to have the same problem. I could try that approach again. At the moment i don't see how i could construct the Map in one go, to tell the truth, i did this version to be able to fold through the samples one by one in the first place :)
10:50:18 <Botje> and feed that to fromList
10:50:48 <halcyon10> Botje: ok i'll try that
10:53:40 <mistermatt> quick question with regard to typeclasses guys, from the learn you a haskell tutorial
10:53:41 <mistermatt> What does this mean: minBound and maxBound are interesting because they have a type of (Bounded a) => a. In a sense they are polymorphic constants
10:54:04 <Botje> it means that any type that is an instance of Bounded has a value for {min,max}Bound
10:54:09 <Botje> > minBound :: Char
10:54:10 <lambdabot>   '\NUL'
10:54:14 <Botje> > maxBound :: Int
10:54:15 <lambdabot>   9223372036854775807
10:54:31 <kakeman> anybody familiar with hopengl?
10:54:42 <Berengal> halcyon10, incBin' (Just !count) (line 25) fixed it
10:55:04 <Botje> oh.
10:55:11 <Berengal> 3kb total :)
10:55:20 <Botje> i always use insertWith :(
10:55:49 <halcyon10> Berengal: yay, thanks very much :)
10:55:55 <Botje> Berengal: my hero :)
10:56:27 <mistermatt> what does it mean by poolymorphic constant
10:56:50 <halcyon10> Botje: i started out with insertWith, but then i had to initialise all bins with zeros, with alter i don't need the initialization
10:57:39 <Botje> halcyon10: no you don't :)
10:57:52 <Botje> insertWith takes a combining function, key, value, map
10:58:06 <Botje> if the key isn't present yet, it inserts the value
10:58:12 <Botje> and insertWith' is a strict version of that
10:58:27 <Botje> (i never would've guessed that incbin' would be the problem, though)
10:59:28 <Berengal> It wasn't that hard to spot. An update function that returned a thunk without forcing all of the components
10:59:55 <halcyon10> Botje: oh i see, i think i used just insert then, though i searched for exactly something like insertWith
11:02:27 <Saizan> mistermatt: it means that they are not functions but still polymorphic
11:02:47 <Saizan> mistermatt: because typeclasses dispatch also on the return type
11:06:16 <hackagebot> GPipe 1.0.1 - A functional graphics API for programmable GPUs (TobiasBexelius)
11:07:39 <halcyon10> Botje: the code definitely looks nicer using insertWith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10488#a10503    thanks for the hint
11:07:55 <halcyon10> or insertWith' that is
11:08:12 <Botje> halcyon10: yay!
11:09:38 <halcyon10> now i can finally try the binning in my real code, testing that now...
11:12:52 <lpjhjdh> so I don't really know anything about haskell's module system but I'm getting a very bizarre error
11:13:28 <lpjhjdh> I have a file Language.Generic.Syntax.DynType and another Language.Generic.Syntax that imports everything under Syntax
11:13:44 <lpjhjdh> but ghc is saying: File name does not match module name:
11:13:50 <lpjhjdh> Saw: `Language.Generic.Synatx.DynType'
11:13:54 <lpjhjdh> Expected: `Language.Generic.Syntax.DynType'
11:14:32 <Igloo> "Synatx" is spelt wrong
11:14:33 <Megant> what's that synatx
11:14:39 <Saizan> > "Synatx" == "Syntax"
11:14:41 <lambdabot>   False
11:14:47 <lpjhjdh> haha, damn, thanks
11:14:58 <lpjhjdh> is that the correct way to reexport stuff then?
11:15:08 <lpjhjdh> a bunch of Language.Generic.Syntax.Const(..) under the export section
11:16:11 <lpjhjdh> hmm, I'd like to reexport everything from an imported module, is there a shorthand for that?
11:19:51 <Makoryu> lpjhjdh: Nope
11:20:01 <lpjhjdh> Makoryu: damn, thanks
11:21:22 <Petrosian`> lpjhjdh: `module Foo (module Bar, ...) where'
11:21:46 <en0th> @seen jdkoeck
11:21:47 <lambdabot> Unknown command, try @list
11:21:56 <en0th> wot?
11:22:17 <lpjhjdh> Petrosian: many thanks, did the trick
11:22:32 <en0th> @list
11:22:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:23:24 <yitz> lpjhjdh: yes there is
11:23:35 <yitz> oh, ok
11:26:26 <en0th> is there a better way to rewrite this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4281#a4281
11:27:07 <ilid> en0th: yes :)
11:27:19 <en0th> heh. i expected that :(
11:27:33 <en0th> a right fold?
11:27:44 <ilid> @type \initial_state stateTransition isFinal = takeWhile (not.isFinal) $ iterate stateTransition initial_state
11:27:45 <lambdabot> parse error on input `='
11:27:51 <ilid> @type \initial_state stateTransition isFinal -> takeWhile (not.isFinal) $ iterate stateTransition initial_state
11:27:52 <lambdabot> forall a. a -> (a -> a) -> (a -> Bool) -> [a]
11:28:13 <ilid> hmm, that'll drop the final state.
11:28:50 <ksf> !http://lwn.net/SubscriberLink/354408/4b4c2fce98e785ad/  makes me think of indexed monads.
11:28:54 <ezyang> I'm trying to figure out how to define a coarbitrary function for a 2-element enum
11:28:59 * bos is having exception-catching problems
11:29:03 <ezyang> But I don't quite understand what coarbitrary /does/
11:29:20 <ksf> that is, why doesn't xhb express sequential protocol contrains, (yet)?
11:29:28 <en0th> ilid, could i rewrite this with a right fold?
11:29:32 <bos> i'm not sure anyone understands coarbitrary except for john hughes
11:29:56 <ksf> ...well, probably because the xmls don't contain enough info as they've been originally written for a c library...
11:30:03 <bos> @seen dons
11:30:03 <lambdabot> Unknown command, try @list
11:30:06 <bos> bah.
11:30:10 <ezyang> well, I got something that typechecked
11:30:11 <mmmulani> let (+) = (-); (-) = (+) in 5 - 5
11:30:20 <ezyang> based off of the boolean coarbitrary implementation
11:30:31 <en0th> @users seen dons
11:30:32 <lambdabot> Unknown command, try @list
11:30:35 <mmmulani> let (+) = (-) in 5 - 5
11:30:45 <burp> prepend >
11:30:50 <mmmulani> oh, whoops
11:30:54 <mmmulani> > let (+) = (-) in 5 - 5
11:30:56 <lambdabot>   0
11:31:02 <mmmulani> > let (+) = (-) in 5 + 5
11:31:04 <lambdabot>   0
11:31:14 <mmmulani> > let (+) = (-); (-) = (+) in 5 - 5
11:31:18 <lambdabot>   mueval-core: Time limit exceeded
11:31:23 <mmmulani> dammit
11:31:26 <en0th> hey!
11:31:33 <burp> recursion ;)
11:32:43 <trofi> I'd like to convert web page to .pdf file with help of gtk2hs(gecko engine). Maybe there is yet working solutions?
11:33:14 <ksf> > let (+) = (-) in let (-) = (+) in 5 - 5
11:33:15 <lambdabot>   0
11:33:16 <dcoutts> trofi: the gtkmozembed widget does not provide that rich an API
11:33:35 <mistermatt> that sounds like a job for perl
11:33:52 <trofi> maybe, export result to png or something?
11:39:29 <bos> dcoutts: have you any experience of Control.Exception.try sometimes not catching an exception?
11:39:59 <dcoutts> bos: nope
11:40:04 <bos> dcoutts: never mind, i just figured out what i did.
11:40:09 <poiuyt> is it possible to add a Word and a Word64. The compiler doesn't like this: test :: Word -> Word64 -> Word64
11:40:23 <poiuyt> test b acc = b + acc
11:40:43 <bos> dcoutts: thou shalt not use let where case is what thou really meant :-)
11:40:55 <trofi> @hoogle Word -> Word64
11:41:03 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
11:41:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:41:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:41:18 <dcoutts> bos: thou shalt think about what is being evaluated :-)
11:41:24 <trofi> > (1 :: Word64) + fromIntegral (3 :: Word)
11:41:25 <lambdabot>   4
11:41:39 <bos> dcoutts: i hadn't been bitten by a laziness bug in ages! golly.
11:41:39 <Makoryu> > 1 :: Char
11:41:41 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
11:41:41 <lambdabot>    arising from the literal `1...
11:42:01 <dcoutts> bos: sounds a bit dodgy though, throwing exceptions from pure code and catching them locally
11:42:32 <dcoutts> bos: I mean I throw exceptions from pure code but only expect to catch them in top level handlers
11:42:32 <bos> dcoutts: this is just inside a test harness.
11:42:38 <dcoutts> bos: ah fair enough
11:43:03 <bos> dcoutts: just fiddling with quickcheck to ensure that when a list version of a function throws an exception, so does the text version
11:43:22 <dcoutts> bos: you want strict check!
11:43:35 <bos> dcoutts: i do, but this is easier :-)
11:43:36 <Makoryu> :t fromIntegral
11:43:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
11:43:43 <bos> i also want smallcheck
11:43:45 <Makoryu> :t fromEnum
11:43:46 <lambdabot> forall a. (Enum a) => a -> Int
11:43:53 <zoonfafer> :t foldr
11:43:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:43:56 <dcoutts> bos: dons and I made a lib for strictness testing when we did the list stream fusion stuff
11:44:23 <poiuyt> thanks trofi: fromIntegral seems to work
11:44:37 <dcoutts> bos: though actually it's not exactly what you want in this situation
11:44:52 <trofi> :t (+)
11:44:53 <lambdabot> forall a. (Num a) => a -> a -> a
11:44:57 <bos> dcoutts: hmm
11:45:28 <dcoutts> bos: but the nice thing is being able to do _|_ === _|_ = True  :-)
11:45:35 <blackh> dcoutts: It's entirely accidental, I assure you. :)
11:45:40 <bos> dcoutts: right
11:45:45 <dcoutts> blackh: heh :-)
11:46:09 * bos is on a tear through the text code
11:46:19 <sinelaw> @pl readBin bs = foldr (\b n -> (n*2 + read [b])) 0 bs
11:46:20 <lambdabot> readBin = foldr ((. (2 *)) . (+) . read . return) 0
11:46:34 <dcoutts> bos: I still need to argue with you about some of the API things ;-)
11:46:48 <dcoutts> blackh: you remember the case we were talking about, of a package depending on itself but with version constraints that excluded the package itself?
11:47:17 <dcoutts> blackh: and I was saying, bah that's crazy etc. Of course that's exactly what base 3 does. :-)
11:47:24 <blackh> dcoutts: Oh, so, was that the right thing to do? Why?
11:47:34 <dcoutts> blackh: base 3 build-depends: base >= 4
11:47:48 <bos> dcoutts: please do! i've forgotten what your arguments were, so you'll be helping me by jogging my memory.
11:47:48 <Igloo> I don't think anyone's denying that base3-compat is crazy  :-)
11:47:49 <blackh> dcoutts: Oh, right!
11:47:50 <sinelaw> > let readBin bs = foldr (\b n -> (n*2 + read [b])) 0 bs in readBin "1101"
11:47:52 <lambdabot>   11
11:47:56 <sinelaw> > let readBin bs = foldr (\b n -> (n*2 + read [b])) 0 bs in readBin "1001"
11:47:57 <lambdabot>   9
11:48:07 <dcoutts> bos: lemme try and remember, I think it was the searching API
11:48:30 <dcoutts> bos: oh and probably splitting too
11:48:45 <monochrom> Four combinations: StrictQuickCheck, StrictSmallCheck, NonstrictQuickCheck, NonstrictSmallCheck.
11:48:50 <blackh> dcoutts: It's not exactly the same because I had an exe depending on a lib.
11:48:53 <dcoutts> bos: on the latter mainly that I don't think the general consensus on what a sensible split is
11:49:24 <dcoutts> blackh: ah right, well anyway, I reverted the change I had you do yesterday and the old test now works
11:49:37 <dcoutts> blackh: so sorry about making extra work for you
11:50:04 <blackh> dcoutts: No worries.
11:50:50 <bos> dcoutts: i remember that it was around those functions, but not what your actual objections were.
11:51:07 <dcoutts> bos: yes, I'm just pulling the latest code and refreshing my memory...
11:51:10 <blackh> bos: You inspired me. I'm doing a Haskell evangelism talk in Wellington, New Zealand in January.  Any pointers?
11:51:27 <dcoutts> bos: ah, the cool new find :-)
11:51:32 <bos> blackh: yay! and not off the top of my head.
11:51:46 <bos> dcoutts: massively simplifies lots of code.
11:51:57 <bos> in addition to making all of said code a lot faster.
11:51:59 <dcoutts> bos: does it?
11:52:06 <dcoutts> bos: you mean instead of using indexes?
11:52:16 <blackh> bos: I'll have no trouble banging on about Haskell for 40 mins.
11:52:34 <dcoutts> bos: I remember we discussed index vs subsequence style APIs
11:52:37 <bos> dcoutts: there's an internal indices function that returns a list of indices into the low-level array
11:52:39 <blackh> bos: It's at the Australasian Linux conference.
11:52:50 <bos> dcoutts: the high-level functions are now implemented using that internally
11:53:09 <bos> dcoutts: but i haven't changed the public APIs from where they were a month or two back
11:53:24 <dcoutts> bos: I don't mind how it's implemented internally, but that's nice :-)
11:53:46 <bos> i like fast and simple over slow and not-simple, myself :-)
11:53:55 <dcoutts> yes, always good :-)
11:55:28 <monochrom> Haskell in a Linux meeting is strange. Perhaps it's just Toronto --- Linux meetings here are full of sysadmins rather than programmers.
11:55:44 <ahf> we've actually managed to change that at our lug
11:55:56 <ahf> we are mostly coders, a couple of sysadmins and massive amount of new ubuntu users.
11:56:21 <monochrom> Haha Haskell for a massive amount of new ubuntu users is funny. :)
11:56:48 <ahf> i doubt they would find it useful. most of them didn't get the erlang talk we did some time ago.
11:57:05 <monochrom> Try category theory next time! <duck>
11:57:09 <dcoutts> bos: do we need count in the API?
11:57:18 <dcoutts> bos: isn't it just length of the find?
11:57:30 <monochrom> Even Oleg's iteratees will be funny. :)
11:57:32 <dcoutts> bos: it's not in Data.List
11:58:04 <bos> dcoutts: it's length . snd . find, yes
11:58:06 <dcoutts> bos: it's in ByteString, but I think that's probably a mistake :-)
11:58:47 <bos> dcoutts: we probably don't "need" it, i agree. but i'm inclined to think i like it there anyway.
11:59:05 <dcoutts> bos: I'm inclined not to include anything beyond Data.List
11:59:11 <dcoutts> bos: as a default choice
11:59:28 <dcoutts> bos: and then additions should be considered carefully and justified
11:59:42 <bos> dcoutts: ah, well, there's where we diverge, then.
12:00:06 <bos> dcoutts: at least in degree, if not entirely in spirit.
12:00:13 <dcoutts> :-)
12:00:44 <bos> i've strayed from the Data.List API in several places, and added several functions beyond what's present there, in the name of making the API usable.
12:01:02 <dcoutts> bos: I apreciate we need to extend for the substring issue
12:01:16 <dcoutts> since substrings are so much more important for text than for lists in general
12:01:48 <bos> dcoutts: i do want to kill off a number of functions, too: findIndex, findIndices, elemIndex, and elemIndices
12:02:09 <bos> they all return either [Int] or Maybe Int and are evil
12:02:31 <dcoutts> bos: I've generally prejudiced against index based functions, but otoh, they are in Data.List
12:02:41 <dcoutts> and the index suffix means they don't steal the good names
12:02:49 <bos> dcoutts: blergh.
12:03:06 <bos> they haven't stolen the good names, but their mere presence invites their use.
12:03:15 <dcoutts> bos: that's true
12:03:42 <bos> i'd rather rip them out than have them present with "use of this function would be very silly" warnings.
12:04:19 <dcoutts> bos: mm, I guess that's true, we can see what everyone else thinks when we propose it for the HP
12:04:38 <dcoutts> bos: I'm not averse to killing them off, I agree index are evil
12:05:32 <dcoutts> bos: ohh yes, it's splitTimes et al that make me go blergh :-)
12:05:51 <bos> dcoutts: why so?
12:05:56 <bos> "et al"?
12:06:14 <dcoutts> bos: it's a horrible non-primitive operation
12:06:50 <dcoutts> bos: that's moving towards a special-case parser
12:07:15 <dcoutts> bos: something like that ought to be able to be constructed from take n . unfold something
12:07:43 <bos> it's a tremendously useful horrible non-primitive operation
12:07:58 <bos> but hmm
12:08:13 <sinelaw> @src sum
12:08:13 <lambdabot> sum = foldl (+) 0
12:09:37 <dcoutts> bos: so it's a special case where you split the first few discarding delimiters and then the last one is the whole rest of the string?
12:10:07 <dcoutts> bos: so we should ask ourselves why that's not easy to implement in terms of the other primitives, what are we missing
12:10:19 <dcoutts> bos: or if not easy, at least effeciently
12:10:59 <bos> dcoutts: right
12:11:14 <dcoutts> bos: are we missing a simple one-place split/find ?
12:12:34 <bos> dcoutts: yes, because that's splitTimes 1
12:12:42 <dcoutts> bos: nooooo! ;-)
12:13:03 <dcoutts> bos: you cannot tell me, with a straight face, that that isn't backwards :-)
12:13:16 <dolio> Definitely backwards. :)
12:13:49 <bos> dcoutts: depends on where you like to wear your head :-)
12:14:00 <bos> dcoutts: seriously, though, there is a reason for this.
12:14:17 <bos> dcoutts: and a reason to not implement it as an unfold of some more primitive operation.
12:14:35 <bos> namely, the setup cost of the search bloom filter.
12:14:40 <copumpkin> this sounds interesting
12:14:41 <dcoutts> ugg
12:15:14 <dcoutts> bos: then we need to provide the general many versions too
12:15:17 <bos> so maybe a more primitive operation would be useful (i can't particularly see how), but implementing the notionally less primitive operation in terms of it would be slow and hence bad.
12:15:24 <dcoutts> bos: but splitTimes isn't one of them
12:15:28 <bos> dcoutts: the what?
12:16:02 <dcoutts> bos: the "find many occurrences" versions where we get to re-use the search setup
12:16:03 <alinp> hi guys
12:16:11 <alinp> how can I force the evaluation of [1..9999] ?
12:16:17 <bos> split is splitTimes âˆž
12:16:26 <PeakerWork> @type bnf
12:16:27 <lambdabot> Not in scope: `bnf'
12:16:32 <PeakerWork> @type rnf
12:16:33 <lambdabot> forall a. (NFData a) => a -> Done
12:16:39 <bos> dcoutts: ^^^
12:16:41 <PeakerWork> > rnf [1..10]
12:16:41 <dcoutts> bos: that may be, but it's not a nice API
12:16:42 <lambdabot>   ()
12:16:57 <PeakerWork> alinp: using "rnf" is one way
12:17:09 <alinp> $! is not doing it, right ?
12:17:19 <dcoutts> bos: splitTimes should be implementable effeciently in terms of a general "find many" operation
12:17:21 <bos> dcoutts: i can see what you're objecting to, but not what to replace it with.
12:17:29 <alinp> I mean ... I'm doing something like sum [1..999999] and I'm getting stack overflow
12:17:36 <alinp> because of the lazynes
12:17:46 <PeakerWork> alinp: $! only forces its arg to WHNF
12:17:55 <alinp> and even if I'm doing sum $! [1..x] still no success
12:17:56 <bos> dcoutts: so really what you want is findSuffixes, then
12:18:03 <dcoutts> bos: so what makes splitTimes tricky, it's that at each occurence we might want to have the subsequence from here to the next occurence, or we might want the subseqeucne from here to the end.
12:18:04 <PeakerWork> alinp: WHNF of [1..999999] is just (1:<thunk for rest>)
12:18:16 <PeakerWork> (and even 1 could be a thunk here)
12:18:18 <alinp> PeakerWork: thanks
12:18:21 <bos> dcoutts: where findSuffixes "::" "a::b::c" returns ["a::b::c", "::b::c", "::c"]
12:18:26 <alinp> it makes sense
12:18:33 <Botje> alinp: foldl' (+) 0 [1..999999]
12:18:34 <alinp> so, rnf is the way
12:18:39 <dcoutts> bos: no I think I want something more general still
12:18:47 <PeakerWork> alinp: or foldl' or some other strict-on-a-list ones
12:18:50 <bos> dcoutts: tell me more
12:19:01 <Botje> (where foldl' comes from Data.List)
12:19:09 <alinp> ok, thanks
12:19:10 <dcoutts> bos: it'd not be the most directly usable thing, but it'd let you implement more directly useful things in an efficient manner
12:19:23 <dcoutts> bos: we want something that looses no information from what the general find gives us
12:19:34 <PeakerWork> I think WHNF is a silly notion to expose in general (rnf is nicer), and thus that seq, bang patterns and $! are all silly. But I might be wrong, I haven't thought it out :-)
12:19:55 <dcoutts> bos: so I think that is for each find occurence we get the substring to the next occurrence *and* the substring to the end (the tail/suffic)
12:20:29 <bos> dcoutts: huh.
12:21:36 <bos> dcoutts: where findSuffixes "::" "a::b::c" returns [("", "a::b::c"), ("a", "::b::c"), ("a::b", "::c"), ("a::b::c", "")]  ??
12:22:08 <monochrom> WHNF has been used successfully for Î˜(1)-worst-case-operation queues.
12:22:09 <dolio> Not everything in Haskell has a normal form.
12:23:25 <spitzi> Hiya. I was asked in a job interview today how to solve the following, conceptually and regardless of a specific programming language:
12:23:26 <spitzi> A consumer and a producer need to synchronize access to a queue of tasks, so that the producer posts tasks to the queue and the consumer consumes them. My proposal was to use both a semaphore and a queue. The semaphore shall be used by the producer to signal to the consumer that new tasks are ready. The mutex shall be used to synchronize writing to the queue, i.e. for ensuring mutual exclusion when the producer pushes taskes and the cons
12:25:10 <monochrom> There is strong evidence towards: strictness+immutable gives you slow data structures and algorithms, nonstrictness+immutable has a better chance. You need fine-grained control on what to force and what to leave alone.
12:26:03 <PeakerWork> monochrom: What WHNF really means (i.e its semantics) are dictated by the representation/implementation... so it seems to break encapsulation to me
12:26:20 <PeakerWork> monochrom: I'm not against control of what to force, I just think WHNF is not the right depth to force to
12:26:28 <dcoutts> bos: I think it'd be ("a", [("::b", "::b::c"), ("::c", "::c")])
12:26:33 <dolio> That is, after all, why Okasaki introduces laziness annotations into his functional data structures in ML.
12:26:51 <jmcarthur_work> HNF!
12:27:02 <monochrom> The strong evidence is from two short papers. The first imagines an immutable lisp (so everything is RNF and immutable) and show everything is slow. The second paper says this is irrelevant to Haskell because Haskell is WHNF.
12:27:15 <bos> dcoutts: hmm
12:27:32 <PeakerWork> monochrom: what do you mean "Haskell is WHNF"? Haskell forces enough for pattern-matches.. its only WHNF in seq, no?
12:27:47 <dcoutts> bos: so like find, we get the bit up to the next occurrence, but also the bit all the way to the end
12:27:58 <dolio> Evaluating enough for a pattern match is evaluating to WHNF.
12:28:07 <dolio> At least, a single layer of pattern matching.
12:28:15 <copumpkin> what would be necessary to evaluate to HNF?
12:28:35 <dcoutts> bos: so then splitTimes should be just walk n along that list of pairs, returning the first element up to n, and at n then we return the second element, ie the whole remainder of the text
12:28:37 <copumpkin> HNF is seeing through the lambda isn't it?
12:28:37 <dolio> HNF requires evaluating under a lambda sometimes.
12:28:48 <PeakerWork> dolio: you can pattern-match deeper than WHNF
12:29:02 <monochrom> For an opague, abstract data type such as Int or such as a data type someone else's module provides you, of course WHNF is black magic.
12:29:06 <dolio> Yes. By matching to WHNF multiple times.
12:29:23 <PeakerWork> dolio: the actual pattern-match specifying the depth is OK because its aware of representation details anyway.  But "seq" supposedly hides implementation details, and used for polymorphic types. I think this is broken
12:29:28 <dolio> All nested pattern matching are converted to multiple case statements in the core.
12:29:40 <monochrom> But if you write "data X = Y | Z X" yourself, what seq does to it is unambiguous and defined.
12:29:43 <bos> dcoutts: yep
12:30:00 <jmcarthur_work> i actually don't have a strong opinion on evaluation order yet, but i like this idea: http://lukepalmer.wordpress.com/2009/05/04/lazy-partial-evaluation/
12:30:20 <PeakerWork> dolio: well, I don't think its very interesting to name the depth that explicit pattern-matches use.. The fact the compiler internally converts them to go 1 constructor deep at a time is an implementation detail.  In any case, its clearly OK For a pattern-match to be exposed to the representation
12:30:22 <dolio> Well, seq being polymorphic is clearly broken, yes.
12:30:32 <PeakerWork> monochrom: right, but then you might as well write the pattern match
12:32:25 <jmcarthur_work> copumpkin, the link above gives an idea for evaluating HNF
12:32:33 <copumpkin> ah :)
12:32:34 <copumpkin> thanks
12:32:45 <monochrom> I'll see you refrain from using seq in practice and write an experience report.
12:32:56 <dcoutts> bos: there's this tension throughout between the (Char -> Bool) property of an element vs Text equality on a substring. Data.List never had that problem of course. I wonder if there's any convention that can make the division more memorable rather than just ad-hoc having to remember.
12:33:06 <jmcarthur_work> i don't really use seq, honestly
12:33:27 <monochrom> I myself, every time I use seq I save at least two lines of code.
12:34:16 <kakeman> what is current version of hopengl?
12:34:57 <bos> dcoutts: it's true. i was thinking that maybe suffixing the predicated functions with "By" would help. i.e. "split" -> "splitBy" (instead of the current "splitWith")
12:34:59 <bos> etc
12:35:19 <dolio> I always have trouble remembering the difference between HNF and WHNF.
12:35:22 <dcoutts> bos: aye, some consistent convention.
12:35:35 <dolio> And NF.
12:35:49 <dcoutts> bos: if we think substring is the default, then a suffix for the char property ones makes some sense
12:36:06 <dolio> I think it's '\x z -> x ((\y -> y) z)' is HNF, but not NF.
12:36:29 <dolio> And '\x -> (\y -> y) x' is WHNF but not HNF.
12:37:22 <bos> dcoutts: right
12:38:02 <dcoutts> bos: which means spanBy, breakBy
12:38:52 <Saizan> dolio: so the body of the lambda shouldn't be a redex in HNF?
12:38:58 <dolio> Right.
12:39:32 <Saizan> i wonder where HNF is applied then
12:39:51 <bos> dcoutts: right
12:39:55 <copumpkin> Veinor: that's quite the insult
12:40:06 <Veinor> I know.
12:40:10 <dolio> You can have redexes in argument positions, though.
12:40:12 <Veinor> wish I came up with it.
12:41:57 <dolio> And, it's hard to find information on where HNF came from. I searched around a while back and I seem to recall getting the impression it was something people thought of with regard to implementing non-strict languages.
12:42:10 <dcoutts> bos: actually that division is particularly clear with 'words'. It's a split based on a char property not a substring
12:42:28 <dolio> But then SPJ came up with WHNF or something.
12:44:29 <Veinor> God, I need to do some coding.
12:44:34 <Veinor> Haven't written a single line in weeks :(
12:45:01 <copumpkin> aw
12:45:40 <Veinor> Yeah.
12:46:10 <Veinor> No clue what to write, though.
12:46:10 <younder> Neither have I.
12:46:18 <dolio> Oh, I guess wikipedia says HNF is a sort of weakened NF that normal-order evaluation is guaranteed to reach if it exists for a term.
12:46:38 <younder> I did just write a 1000 though..
12:46:49 <dolio> Whereas, as I recall, SPJ came up with WHNF for describing how one should practically evaluate lazy languages.
12:47:16 <copumpkin> Veinor: you just want to write for the sake of writing, or have an assignment?
12:48:40 <younder> Whatever depressive mess you are inn, get out of it! Get enough vitamins, execcise, engage company.. That sort of thing.
12:49:00 <Veinor> I just want to write for the sake of writing. I don't have any coding assignments.
12:49:21 <Veinor> not taking any CS classes this term, probably going to start next.
12:49:23 <Veinor> next term.
12:50:36 <ystael> Veinor: if you want some difficult exercise, learn Coq.  that will keep your brain hair-tearingly in gear.  :D
12:50:39 <Veinor> getting biology out of the way during pass/no record, heh
12:51:02 <en0th> http://thyer.name/lambda-animator/ -> to experiment with reduction strategies
12:51:30 <Botje> does it have the alligator calculus?
12:51:41 <Botje> aww :p
12:54:10 <monochrom> Just write some html code.
12:54:25 <Veinor> Eww.
12:56:29 <Veinor> well, I did fool around a bit with a wordpress theme for my site
12:56:43 <Veinor> but that was really me just playing around and hoping I got it right, just changing formatting strings and such.
12:57:27 <jvoorhis> does anyone know the story with ghc's ffi and snow leopard?
12:58:00 <zbrown> .4
12:58:02 <zbrown> doh
12:58:18 <Veinor> Insightful commentary, zbrown.
12:58:29 <jvoorhis> if i understand correctly, i assume creating bindings for 64-bit frameworks is a no-go
12:59:03 <younder> Ok, Veinor write a chatterbot
12:59:08 <Veinor> Haha
12:59:10 <Veinor> in HASKELL.
12:59:19 <younder> absoulutely
12:59:30 <monochrom> haskellizza
12:59:34 <Veinor> are there pre-existing haskell irc modules?
12:59:47 <Veinor> monochrom: there's a joke about reflection
12:59:49 <Veinor> but I can't find it
13:00:26 <younder> It will be the most difficult task of your life
13:00:53 <Vanadium_> Veinor: There are!
13:00:56 <Vanadium_> There are also existing haskell irc bots
13:00:58 <Veinor> Hooray!
13:01:02 <Vanadium_> Like lambdabot, or geordi
13:01:53 <younder> You will need to learn linguistics, and statistical. But it can be done
13:02:43 <younder> And it will stop you from whining about your problems here!
13:02:53 <Veinor> Haha.
13:02:54 <younder> sigh
13:03:03 <Veinor> I wasn't thinking a markov chain-style bot, more something actually... useful.
13:03:31 <monochrom> Like sudo make sandwich?
13:03:39 <mauke> @vixen do you like markov chains?
13:03:39 <lambdabot> sure, i definitely don't hate
13:03:47 <Veinor> lol
13:04:43 <inaeternum> --- is it possible to define something like "x= y + z" outside IO context, where the value of y is determined by an IO action (lets say, read from the keyboard)?
13:05:10 <copumpkin> inaeternum: not sure I understand
13:05:18 <monochrom> No.
13:05:33 <jvoorhis> inaeternum: why would you want to do that?
13:05:34 <copumpkin> well then
13:05:58 <Cale> inaeternum: Not really. You can define a function add y z = y + z, whose parameters will eventually be things read from the keyboard.
13:06:01 <jvoorhis> (there is a way, but it still may not do what you expect ;)
13:06:23 <darrint> inaeternum, you have to stay in IO but it doesn't end up being impractical.
13:06:55 <Cale> inaeternum: and in the middle of an IO block, you can write  let x = y + z  where y and z are anything in scope, which means they might be results of previous IO actions in the block.
13:06:56 <inaeternum> jvoorhis: I would like to define some "macros" for a function that takes rather many arguments
13:07:08 <younder> Veinor: HELLO! I am saying that this approach is WAY closer to the way a human thinks.
13:09:10 <Baughn> What do I actually need to build the GHC documentation?
13:09:35 <Baughn> "Docbook XSL stylesheets", it says, but I do have a package called.. "docbook-xsl-stylesheets" installed
13:09:51 <copumpkin> Veinor: you could check out the haskell proposals subreddit, or become my pet coder since I'm busy with a paper this week :)
13:10:38 <p_l> Baughn: now you need xslt processor to format them :P
13:10:50 <jvoorhis> inaeternum: your best bet, as Cale mentions, is to write your function without IO, and use the monad api to arrange for your code to be called with the bound values
13:10:56 <Baughn> p_l: "checking for xsltproc... /usr/bin/xsltproc"
13:10:58 <Baughn> That?
13:10:59 <inaeternum> cale, jvoorhis: thanks for your help, I'll have to rethink my solution :-)
13:11:14 <p_l> Baughn: looks like it
13:11:45 <jvoorhis> inaeternum: i'd suggest having a look at Control.Monad and Control.Applicative, keeping in mind that their functions work with IO
13:12:21 <inaeternum> jvoorhis: I'll try, I'm still quite new to the concept of monads
13:12:55 <hackagebot> dotgen 0.4.1 - A simple interface for building .dot graph files. (AndyGill)
13:12:55 <Baughn> Wait a..
13:13:08 <Baughn> Oh, for pity's sake. There's an error in the configure script.
13:13:09 <jvoorhis> inaeternum: one of the features of IO is that you can't get anything *out* of it
13:13:10 <copumpkin> cum sanctis tuis inaeternum
13:13:16 <jvoorhis> inaeternum: but you can lift your code *into* it
13:15:10 <jvoorhis> inaeternum: try this out, for example â€“Â liftM2 (+) (fmap read getLine) (fmap read getLine)
13:15:16 <jvoorhis> after importing Control.Monad
13:15:46 <copumpkin> or just readLine
13:15:50 <copumpkin> :t readLn
13:15:51 <lambdabot> forall a. (Read a) => IO a
13:15:56 <jvoorhis> copumpkin: thanks :) i'm still learning the library myself
13:16:01 <copumpkin> :)
13:16:16 <jvoorhis> copumpkin: which module is that in?
13:16:33 <copumpkin> I think it's just prelude, or System.IO if not
13:16:35 <copumpkin> @hoogle readLn
13:16:36 <lambdabot> Prelude readLn :: Read a => IO a
13:16:36 <lambdabot> System.IO readLn :: Read a => IO a
13:16:41 <copumpkin> ...or both :)
13:16:51 <copumpkin> Prelude just re-exports it, I expect
13:17:25 <jvoorhis> oh, i was typing readLine
13:17:47 <jvoorhis> inaeternum: try this â€“ liftM2 (+) readLn readLn
13:18:03 <inaeternum> ok - but first I'll need another read of how monads work, I had a look at it once but I have forgotten a lot
13:18:11 <jvoorhis> it's equivalent to this code â€“Â do { x <- readLn; y <- readLn; return x + y }
13:18:12 <copumpkin> readLn <^(+)^> readLn
13:18:20 <Veinor> copumpkin: Haha
13:18:23 <copumpkin> @hackage infix-applicative
13:18:24 <lambdabot> http://hackage.haskell.org/package/infix-applicative
13:18:24 <Veinor> the anime operator
13:18:28 <copumpkin> damn
13:18:46 <inaeternum> thx guys and bye!
13:18:48 <copumpkin> @hackage InfixApplicative
13:18:49 <lambdabot> http://hackage.haskell.org/package/InfixApplicative
13:19:12 <jvoorhis> copumpkin: that's just weird
13:19:22 <jvoorhis> but certainly more symmetrical than <$> and <*>
13:19:24 <copumpkin> :)
13:19:31 <copumpkin> blame Beelsebob
13:19:40 <copumpkin> ...I think
13:19:59 <Beelsebob> yeh, infixApplicative is my fault
13:20:02 <Beelsebob> glorious isn't it :)
13:20:05 <copumpkin> yep!
13:20:34 <copumpkin> or instance (Num a, Monad m) => Num (m a)
13:20:35 <copumpkin> :)
13:20:44 <Beelsebob> Veinor: it's not the anime operator; it's the anime transformer!
13:21:02 <Veinor> :D
13:21:16 <copumpkin> applicative is enough actually
13:21:19 <Makoryu> More than meets the eye, even
13:21:22 <copumpkin> and conal already did it now that I think of it
13:21:38 <burp> anyone tried to use icc with -fvia-C -pgmc icc?
13:21:38 <burp> I wonder how this performs
13:22:03 <Zao> Most probably not at all, I'd reckon.
13:22:07 <Veinor> ^-^ :: Schoolgirl -> Princess
13:22:13 <Veinor> or something
13:22:18 <burp> Zao: I think too
13:22:31 <Cale> You'll probably want Princess to be some function type then
13:22:44 <Jedai> burp: GHC performs some GCC specific black magic with the evil mangler on its C output
13:23:22 <burp> ok
13:24:08 <copumpkin> burp: I doubt it'd work, but might try one of these days
13:24:12 <copumpkin> cheap academic icc licenses ftw
13:24:56 <dbelange> Does Haskell have a built-in type for Heyting algebras?
13:25:10 <copumpkin> no
13:25:41 <dbelange> Why not?
13:25:47 <ilid> don't heyt the algebra, heyt the game!
13:26:04 <Cale> Shouldn't be hard to construct some algebraic datatype for representing values in a Heyting algebra.
13:26:24 <Cale> Seems kind of a special purpose thing for the language spec to include :P
13:26:42 <copumpkin> dbelange: could you make a case for including it in haskell'? :)
13:26:59 <dbelange> What!  It is fundamental to intuitionistic logic.
13:27:15 <dbelange> Which is basically what Haskell is all about.
13:27:42 <copumpkin> we don't even have many of the more common structures in the standard library
13:27:46 <copumpkin> in fact, all we get is monoid
13:27:53 <mimcpher> I am interested in pointless topology and heyting algebras would be most useful!
13:28:15 <Cale> I suppose there might be a case for having a value-level representation of the type system, which would be one particular Heyting algebra :)
13:28:46 <dbelange> I'm surprised Haskell has fallen so far behind Coq.
13:29:12 <Cale> Different goals, I think.
13:29:35 <jvoorhis> dbelange: to be fair, i think ghc is faster :)
13:30:01 <Cale> and has better support for concurrency and parallelism, I'm willing to bet ;)
13:30:36 <Cale> Haskell isn't intended to be a theorem prover.
13:30:40 <Saizan> jvoorhis: well, ghc can be part of the pipeline when compiling coq code
13:31:08 <jvoorhis> Coq can target haskell then?
13:31:17 <burp> one could imagine beating gcc c-program speed with haskell/ghc -pgmc icc ;)
13:31:17 <Saizan> yes
13:31:21 <mimcpher> Cale: Oh really?  No wonder I've been having so much trouble.
13:31:31 <jvoorhis> i wonder how easily you could mix the two
13:31:31 <mimcpher> well then.
13:32:09 <Cale> mimcpher: You can certainly use it that way, but the general recursion tends to get in the way of ensuring that your proofs are correct -- every type has at least one member.
13:32:20 <dbelange> mimcpher: I recomment you look up the Curry-Howard Isomorphism to see why programming in Haskell is exactly proving theorems!!!
13:32:59 <Cale> Programming in Haskell is all about proving boring theorems in an inconsistent intuitionist logic. ;)
13:33:18 <dbelange> haha
13:33:28 <EnglishGent> inconsistent?
13:33:34 <EnglishGent> oh - bot?
13:33:42 <Cale> EnglishGent: yeah
13:33:47 <Saizan> ?type let x = x in x
13:33:48 <lambdabot> forall t. t
13:33:53 <Cale> fix :: (a -> a) -> a
13:34:09 <Cale> which gives you a proof of  forall a. a
13:34:14 <Cale> (as Saizan showed)
13:34:51 <Cale> If you want things to be consistent, you have to restrict yourself to less general forms of recursion.
13:34:58 <kosmic> Prelude> fix :: (a -> a) -> a
13:34:58 <kosmic> <interactive>:1:0: Not in scope: `fix'
13:34:59 <kosmic> Gee
13:35:11 <Cale> Which means giving up Turing completeness for at least a fragment of the language.
13:35:32 <Cale> kosmic: It's in some stupid place like Control.Monad.Fix
13:35:48 <Cale> kosmic: Or you can just write it like  fix f = x where x = f x
13:36:01 <Saizan> Data.Function too
13:36:02 <kosmic> What's monad  /;
13:37:00 <en0th> what's the point of fix?
13:37:07 <copumpkin> en0th: to fix bugs
13:37:11 <copumpkin> > fix error
13:37:11 <Cale> en0th: It's what gives us recursion.
13:37:12 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
13:37:17 <Cale> heh
13:37:17 <Botje> make cool shortcuts for computing fibs :)
13:37:31 <Makoryu> :t (<~)
13:37:32 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
13:37:32 <lambdabot> Not in scope: `<~'
13:37:33 <lambdabot>   3628800
13:37:38 <Makoryu> :t (~>)
13:37:40 <lambdabot> Not in scope: `~>'
13:37:45 <Makoryu> Hmmm
13:37:51 <Cale> Makoryu: maybe a local definition?
13:38:12 <Cale> Makoryu: If those were at the type level, they'd be type variables
13:38:14 <Makoryu> Cale: I'm looking for unused names.
13:38:17 <Cale> ah
13:38:26 <Cale> > map (fix (\fac n -> if n == 0 then 1 else n * fac (n-1))) [1..10]
13:38:27 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
13:38:35 <byorgey> en0th: all recursive functions can be implemented as 'fix' applied to a non-recursive function.
13:38:52 <skorpan> i noticed the definition of fmap in Functor IO uses (>>=) and return... that seems sort of backwards to me.  could one define the IO functor without the IO monad?
13:39:01 <Cale> skorpan: Sure.
13:39:35 <en0th> i'm missing something. is fix f = x where x = f x (as Cale wrote)?
13:39:36 <monochrom> Eh, someone wants fix explained? Shameless plug: http://www.vex.net/~trebla/haskell/fix.xhtml
13:39:37 <byorgey> en0th: there are also a lot of cool tricks you can play if you can modify the un-fixed version of a function before applying fix, e.g. error handling, memoization, etc.
13:39:46 <Cale> en0th: yes
13:39:48 <byorgey> en0th: yes.
13:39:49 <kosmic> Nothing works
13:40:10 <Cale> en0th: So, let's see what happens when we apply fix to (\fac n -> if n == 0 then 1 else n * fac (n-1))
13:40:27 <en0th> that definition seems like f = f f ??
13:40:31 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) = x where x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x
13:41:07 <Cale> Simplifying the equation for x gives  x = (\n -> if n == 0 then 1 else n * x (n-1))
13:41:16 <Cale> Or: x n = if n == 0 then 1 else n * x (n-1)
13:41:32 <Cale> So x is precisely the factorial function.
13:41:52 <byorgey> monochrom: that's a nice page.
13:41:52 <kosmic> I don't see the point in this fancy math when it will not run in the interpreter
13:41:59 <Cale> kosmic: It will.
13:42:03 <byorgey> en0th: check out that link monochrom posted.
13:42:03 <en0th> hehe
13:42:17 <Cale> kosmic: Type:  let fix f = x where x = f x
13:42:22 <Cale> kosmic: ghci will accept it
13:42:37 <kosmic> And now it should work?
13:42:39 <en0th> oh, thanks i missed the link. thanks everybody
13:42:51 <Cale> kosmic: yeah
13:43:09 <Cale> kosmic: You just need to bring a definition of fix into scope.
13:43:13 <kosmic> Oh, cool. It worked
13:43:17 <Cale> kosmic: It's not in the Prelude, for whatever reason.
13:43:26 <kosmic> What reason, exactly
13:43:34 <Cale> No good one. :)
13:43:43 <kosmic> Will it ever be?
13:43:53 <kosmic> Someone should fix it! ;)
13:44:11 <Cale> Perhaps it was felt that since Haskell already supports recursion, there's no need for fix to be in the Prelude, but there are good uses for it anyway.
13:44:13 <mauke> > fix error
13:44:14 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
13:44:43 <copumpkin> it's excellent golfing material
13:44:53 <copumpkin> > fix ((0:) . scanl (+) 1)
13:44:54 <Cale> > fix ((0:) . scanl (+) 1)
13:44:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:44:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:44:56 <copumpkin> lol
13:44:57 <Cale> heh
13:45:38 <kosmic> Oh crap
13:45:39 <copumpkin> > fix (ap sequence) [(!! 2), (*2) . (!! 0), const 5]
13:45:41 <lambdabot>   [5,10,5]
13:46:44 <Cale> I rather like that description of the Fibonacci sequence.
13:46:58 <kosmic> I like it too
13:47:21 <sinelaw> help, what's wrong here
13:47:22 <sinelaw> > let readBase base = foldr (\digit n -> (n*base) + digit) 0  in readBase 2 [1,0,1,0,0,0]
13:47:24 <lambdabot>   5
13:47:26 <sinelaw> > let readBase base = foldr (\digit n -> (n*base) + digit) 0  in readBase 2 [1,0,1,0,0,1]
13:47:26 <Cale> Probably slightly easier to describe in English would be something like...
13:47:27 <lambdabot>   37
13:47:37 <Cale> > fix ((0:) . map (+1) . scanl (+) 0)
13:47:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:48:10 <byorgey> sinelaw: nothing looks wrong to me.
13:48:20 <byorgey> sinelaw: note that the binary numbers are interpreted backwards.
13:48:21 <Cale> The Fibonacci sequence is the fixed point of the function which takes partial sums, adds 1 to each element, and then sticks 0 on to the beginning of the sequence.
13:48:28 <sinelaw> doh.
13:49:05 <sinelaw> only 4 hours of sleep can do wonders
13:49:21 <copumpkin> > fix (flip flip tail . (ap .) . flip flip head . (((.) . liftM2 (.) (:)) .) . (`ap` ((filter . (not .)) .)) . (((.) . (.)) .)) (flip flip 0 . ((==) .) . mod) [2..]
13:49:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
13:49:26 <copumpkin> damn
13:49:31 <burp> omg
13:49:32 <byorgey> sinelaw: just imagine what 8 hours could do!
13:49:57 <medfly> twice as much!
13:49:58 <sinelaw> byorgey, that's right, it's left to my imagination
13:49:58 <copumpkin> > fix (flip flip tail . (ap .) . flip flip head . (((.) . liftM2 (.) (:)) .) . (`ap` ((filter . (not .)) .)) . (((.) . (.)) .)) (flip flip 0 . ((==) .) . flip mod) [2..]
13:49:59 <copumpkin> there we go
13:50:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:50:13 <burp> horrible
13:50:14 * Cale bets that copumpkin used @pl
13:50:18 * byorgey too
13:50:21 <copumpkin> Cale: what makes you think that? O:-)
13:50:24 <sinelaw> flip flip 0 ?
13:50:26 <copumpkin> lol
13:50:34 <Cale> :t flip flip 0
13:50:36 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
13:50:53 <copumpkin> > nubBy (\x y -> y `mod` x == 0) [2..]
13:50:55 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
13:51:00 <copumpkin> it's that, fully expanded and @pled
13:51:02 <byorgey> of course, it's the higher-order combinator that partially applies the second argument of a function to zero.
13:51:07 <byorgey> =)
13:51:13 <copumpkin> and of course, fix'ified
13:51:29 <monochrom> (What a slow way to obtain [2..])
13:51:39 <copumpkin> yeah, you know what I mean :P
13:52:13 <copumpkin> > nubBy (\x y -> x `mod` y == 0) [2..]
13:52:15 <copumpkin> that one
13:52:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:53:01 <Tobsan> > 120 / 365
13:53:02 <lambdabot>   0.3287671232876712
13:53:05 <copumpkin> zomg, that means that [2..] and primes are fundamentally related!!
13:53:07 <copumpkin> :P
13:53:14 <copumpkin> they are just one flip away from each other
13:54:23 <monochrom> Of course [2..] and primes among [2..] are fundamentally related.
13:54:55 <copumpkin> that is so deep!
13:55:30 <monochrom> I think there is nothing deep.
13:55:39 <copumpkin> hrrmpf
13:55:53 <monochrom> I'll explain why. It's a long story.
13:56:13 <mistermatt> It all began on a dark and story night
13:56:26 <copumpkin> I was just kidding in the first place, but let's hear the story :)
13:56:38 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
13:56:39 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:56:42 <monochrom> A logic course. A complicated statement is given. Students are asked to prove it. Of course, some students make logic errors.
13:58:01 <monochrom> A correct way to prove a statement is to prove that it is implied by true. A common error is to prove that the statement implies true. Some students make that error.
13:58:15 <Cale> We should work on getting enough general hings into the libraries so that a better approximation of the Sieve of Eratosthenes becomes a one-liner.
13:58:41 <copumpkin> that'd be nice
13:58:57 <monochrom> So they discover and hand in, say, 100 pages of proving that the complicated statement implies true. Although it fails to answer the homework quesiton, you can still call it deep because it's 100 pages.
13:59:02 <copumpkin> we'd need an ordered merge and a first-elements-ordered infinite union of ordered lists I guess
13:59:20 <Cale> For example, Bird's version doesn't require many lines as it is, but they're particularly subtle functions he defines.
13:59:30 <Esteth> Is there a better way than reverse . drop 1 . reverse to get a list without it's last character?
13:59:35 <copumpkin> init
13:59:41 <copumpkin> > init [1..10]
13:59:42 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:59:47 <monochrom> But it is not deep because "statement implies true" has a very short proof (like, almost an axiom) and it does not depend on the content of the statement. The 100 page proof is just obfuscation.
14:00:16 <Esteth> copumpkin: Aha, fantastic :)
14:00:20 <Cale> Esteth: Beware! Any operation which accomplishes that task is O(n) where n is the number of elements of the resulting list which you use.
14:00:35 <Cale> (at least)
14:00:42 <copumpkin> > init . init $ [1..10]
14:00:43 <lambdabot>   [1,2,3,4,5,6,7,8]
14:00:46 <Esteth> Cale: I'm aware, thanks. It's because haskell lists are linked lists, so you have to follow the whole list, right?
14:01:06 <Cale> Esteth: well, you have to build new list cells because you can't share tails with the original list
14:01:07 <kosmic> fix ((0:) . scanl (+) 1) is definitely the most elegant way to obtain fibonacci numbers I've ever laid my  eyes on
14:01:11 <hackagebot> hashed-storage 0.4.0 - Hashed file storage support code. (PetrRockai)
14:01:31 <Heffalump> exciting!
14:01:36 <Esteth> Cale: ahh, ok. Thanks for the warning, anyway :)
14:02:07 <copumpkin> :t scanl'
14:02:09 <lambdabot> Not in scope: `scanl''
14:02:16 <copumpkin> there's no such thing?
14:02:16 <inimino> monochrom: doesn't that just explain why you think some things aren't deep?
14:02:35 <Cale> scanl typically doesn't suffer from the problem which foldl does
14:02:55 <Cale> (because you typically evaluate the elements of the list roughly in order)
14:03:01 <bos> dcoutts: any idea what to call this fancy new find function?
14:03:02 <monochrom> This teaches me that if you come up with something with a lot of dependencies, a lot of hard work, etc., I may still believe that it is not as deep as you think, maybe you're just being inefficient.
14:03:36 <dcoutts> bos: something that doesn't steal the good names, it's not one we want to use directly much
14:03:49 <bos> dcoutts: findOMGWTFBBQ
14:03:53 <copumpkin> lol
14:03:57 <dcoutts> bos: that'll do :-)
14:04:45 <dcoutts> bos: findAllOccurrences or something
14:04:54 <bos> yeah
14:04:58 <en0th> where can i import "fix"
14:05:00 <bos> or findSuffixes
14:05:05 <bos> @hoogle fix
14:05:05 <lambdabot> Data.Function fix :: (a -> a) -> a
14:05:06 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:05:06 <lambdabot> module Control.Monad.Fix
14:05:09 <Peaker> @index fix
14:05:10 <Cale> en0th: Data.Function or Control.Monad.Fix
14:05:10 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:05:26 <Peaker> what does it have to do with monads?
14:05:32 <Cale> Peaker: Nothing really.
14:05:41 <Cale> Peaker: But there's a monadified version in that module.
14:06:22 <Peaker> Yeah, but maybe Control.Monad.Fix shouldn't re-export fix so you have to get it from Data.Function
14:06:29 <bos> dcoutts: i wonder if it makes sense to have a findTimes as well as a splitTimes, then
14:06:42 <en0th> lol. i "fixed" my state transition function
14:06:48 <en0th> smRun i tr fc = fix (\v s -> if fc s then s else v (tr s)) i
14:06:57 <monochrom> haha
14:07:11 <dcoutts> bos: what are their types? they're not more nasty take n things are they? :-)
14:07:19 <bos> dcoutts: why yes :-)
14:08:11 <dcoutts> bos: well you know what I think about that, and the general find is supposed to remove the need for those things. You can keep them in your local Utils module where I don't have to look at them :-)
14:08:20 <bos> dcoutts: heh
14:08:29 <en0th> can i feed that def to lambdabot?
14:08:45 <bos> dcoutts: the trouble is, the "split a string into at most n parts" is extremely common
14:09:11 <dcoutts> bos: then we should make sure it's easy enough to implement in terms of the basics
14:09:21 <dcoutts> bos: how do you do it now for String ?
14:09:31 <dcoutts> given that it's so common
14:09:44 <bos> by hand.
14:09:56 <dcoutts> directly recursively?
14:10:08 <dcoutts> using pattern matching / head/tail ?
14:10:13 <bos> no, usually via a couple of splitAts and some bodging.
14:11:35 <dcoutts> so you could do it directly with: case uberFind "foo" text of (_, (frist, _): (second, _): (_, remainder)) ->
14:11:46 <Cale> @let smRun i tr fc = fix (\v s -> if fc s then s else v (tr s)) i
14:11:47 <lambdabot>  Defined.
14:11:50 <Cale> :t smRun
14:11:52 <lambdabot> forall t. t -> (t -> t) -> (t -> Bool) -> t
14:12:01 <dcoutts> bos: oh, missing ":_)"
14:12:22 <copumpkin> that's a pretty elegant formulation
14:12:28 <en0th> > smRun 0 (+3) (>50)
14:12:29 <lambdabot>   51
14:12:34 <en0th> it works!
14:12:37 <copumpkin> looks like until
14:12:48 <copumpkin> :t until
14:12:49 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:13:01 <copumpkin> @src until
14:13:02 <lambdabot> until p f x | p x       = x
14:13:02 <lambdabot>             | otherwise = until p f (f x)
14:13:03 <Cale> > until (>50) (+3) 0
14:13:05 <lambdabot>   51
14:13:33 <Peaker> @type \i f p -> last . takeWhile p . iterate f $ i
14:13:35 <lambdabot> forall a. a -> (a -> a) -> (a -> Bool) -> a
14:13:35 <sinelaw> will Haskell' offer any major improvement in making debugging / error reporting (on compilation errors) easier?
14:13:53 <bos> dcoutts: kind of true :-)
14:13:54 <Cale> Haskell' will basically be some subset of what we have already in GHC.
14:14:14 <bos> dcoutts: i think that does obviate the need for splitTimes, then
14:14:18 <monochrom> I think language specifications don't say much about debugging and error messages.
14:14:27 <sinelaw> shame
14:14:36 <dcoutts> bos: yay :-)
14:14:44 <Cale> and yeah, the Haskell standard has never said anything about operational semantics, so why should it start? :)
14:15:04 <Cale> sinelaw: I think it would be foolish to standardise things like that.
14:15:11 <bos> dcoutts: so perhaps findAll and splitAll
14:15:19 <sinelaw> that's a point, but maybe we need an additional document describing how to do better error reporting
14:15:40 <bos> dcoutts: where splitAll removes the matching prefix from each pair it returns
14:15:47 <jmcarthur_work> i think most errors reported by ghc are not that bad
14:15:48 <sinelaw> no need for standardization, just make it easier to implement
14:15:49 <copumpkin> the main issue I have with GHC's errors is the expected/inferred distinction
14:15:51 <Peaker> PeakerBot, @part
14:15:51 <PeakerBot> Plugin `system' failed with: Prelude.last: empty list
14:15:56 <jmcarthur_work> infinite type errors are the worst, i think
14:16:07 <monochrom> (Apart from revolutionary things like "let's make it an eager language because people know how to debug eager programs, let's make it monomorphic because error messages can then be in plain English".)
14:16:08 <Cale> @ghc
14:16:09 <lambdabot> ghc says: Oops!  Entered absent arg
14:16:32 <Peaker> jmcarthur_work, I think the right way to fix that is a smart code editor
14:16:37 <Cale> @ghc
14:16:37 <lambdabot> ghc says: Duplicate instance declarations
14:16:39 <dcoutts> bos: leaving split as a single-place search? the subsequence version of span?
14:16:53 <Alpounet> by the way, I've tested leksah today, I've been quite impressed
14:16:56 <dcoutts> bos: I'm starting to get confused :-)
14:17:09 <sinelaw> Peaker, right :)
14:17:34 <bos> dcoutts: find is to findAll as split is to splitAll
14:17:46 <bos> dcoutts: although frankly the need for find and split become unclear now
14:18:24 <Cale> My approach to error messages is to start by going to the part of the code which the error message talks about, usually before even reading the error message properly.
14:18:33 * jmcarthur_work too
14:18:46 <Cale> Only if I can't figure out what's wrong by staring at the code will I use the rest of the message.
14:18:58 <Alpounet> Cale, same here
14:19:24 <dcoutts> bos: they can be the one-place versions?
14:19:24 <Alpounet> I find GHC to be the coolest (wrt error messages) compiler I've ever used
14:19:32 <dcoutts> bos: or do we have other names for the one-place versions?
14:19:40 <jmcarthur_work> that's the reason i hate infinite type errors. they don't really give a line number or an expression or anything... just the name of the function
14:19:43 <Peaker> Cale, The worst is an 8-line intricate function with some "id" instead of "return" somewhere, yielding an infinite type over the whole thing
14:19:45 <dcoutts> bos: we should get the API principles written down somewhere
14:19:57 <Peaker> Cale, its hard to spot, and I sometimes "binary-search" the error by making half the function undefined
14:19:58 <dcoutts> bos: so we can see more easily if we're following them :-)
14:19:58 <monochrom> I don't understand people's complaints about error messages (apart from the agreeable infinite-type one).
14:20:07 <bos> dcoutts: heh
14:20:11 <jmcarthur_work> Peaker, that's the same approach i use
14:20:15 <Peaker> monochrom, there's also the lack of stack traces in runtime errors
14:20:36 <monochrom> I completely don't understand. Apart from accepting that those people just have a cognitive dissonance.
14:20:45 <Cale> Peaker: My usual approach to that is "this function must have been too complicated for me to understand all at once, I'd better figure out some way to build it from smaller parts"
14:21:07 <Peaker> Cale, I like to refactor code when its in working/type-safe state :)
14:21:12 <copumpkin> monochrom: I think the distinction between inferred and expected is a little hard to pick up on, but like the others I rarely read the full error message anyway
14:21:14 <Peaker> Cale, rather than refactoring it while its broken
14:21:30 <Cale> Well, refactoring while broken = rewriting
14:21:30 <dcoutts> bos: so we'd note that we give the best names to the substring versions, that we use By for the (Char -> Bool) property ones. That we have some consistent naming convention for the one-place vs all-occurrences things, with the latter having a performance advantage.
14:21:38 <monochrom> Yes copumpkin, but I ignore the word "inferred" and the word "expected".
14:21:39 <Peaker> Cale, sometimes I refactor by applying code transformations that I know are correct without even deeply understanding them, and later I try to understand the result. If I do this on worng code... :)
14:21:57 <bos> dcoutts: so the principle is this. there's currently nasty redundancy in the API, and that makes me sad. i think we should have a one-shot split and a multi-shot splitAll, and a one-shot find and a multi-shot findAll, and nothing more.  but i think that the one-shot should be findOne, and the multi-shot find.
14:21:59 <jmcarthur_work> inferred is what expression type checks as, expected is what surrounding code requires in its place
14:22:01 <Cale> Peaker: yeah, you don't bother with transformations, you just rewrite the damn thing :)
14:22:01 <Peaker> Cale, I think fixing the type error and then refactoring is probably quicker for me
14:22:04 <copumpkin> maybe just "failed to unify Int with Double" or something in the error message
14:22:05 <bos> dcoutts: right.
14:22:11 <bos> dcoutts: i think we've converged.
14:22:13 <copumpkin> jmcarthur_work: yeah, I know, it just isn't obvious
14:22:15 <Peaker> Cale, or at least, requires less mental energy
14:22:16 <dcoutts> bos: :-)
14:22:23 <Cale> Peaker: of course, depending on what the actual problem is
14:22:28 <jmcarthur_work> not to a newbie, but it would be bad information to throw away
14:22:31 <jmcarthur_work> i use that information
14:22:40 <copumpkin> fair enough
14:22:55 <dcoutts> bos: I'm ambivalent on if the one-place or all-occ get the short name, or if they just get different names.
14:23:34 <Cale> If you have a function which spans many lines and is hard enough to understand that you don't immediately see how to fix a type error in it, there's a good possibility that it's junk and you should start over :)
14:24:14 <dcoutts> bos: the other choice for the one-place split is break, as in Data.List, if we're renaming the current one breakBy since it's a Char property function.
14:24:34 <monochrom> People's priorities are ridiculous. So they see "inferred Int, expected Double". Then they spend two days on #haskell philosophizing the true meaning of "inferred" and "expected". They spend 0 seconds on why it's Int and why it's Double. At the end they declare the error message to be inhuman.
14:24:36 * bos head asplode
14:24:47 <dcoutts> bos: oops, sorry
14:24:52 <bos> dcoutts: no, you're right.
14:25:01 * dcoutts crawls around looking for bits of bos's head...
14:25:10 <Peaker> monochrom, Nah, that's one of the error messages that are fine :)
14:25:47 <Alpounet> are there many of you guys using leksah ?
14:26:05 <aavogt> complaining about error messages is like monads
14:26:31 <ystael> Alpounet: see, when i saw that name, before googling it, i expected it to be a lexer generator written in the city of Boston
14:26:32 <bos> dcoutts: this is going to turn out very pretty.
14:26:37 <dcoutts> bos: :-)
14:26:56 <Alpounet> ystael, waw, why ? :-p
14:27:14 <dcoutts> bos: I feel guilty that I'm being opinionated without actually helping you with the hacking.
14:28:10 <ystael> Alpounet: it's a joke about the boston accent :) Boston English stereotypically turns terminal -er into terminal schwa
14:28:15 <bos> dcoutts: helping with the hacking isn't always what's required. sometimes you have to be outside the quagmire :-)
14:29:10 <dcoutts> bos: :-) actually we really should collect and write down the principles / rationale for when we explain it for the HP proposal. "Here's why it's not just a copy of Data.List..."
14:29:17 <bos> dcoutts: yeah.
14:29:25 <Cale> I also expected it to have something to do with lexers, but I didn't think of Boston. Maybe some British or Australian accent? :)
14:29:28 <Alpounet> ystael, oh okay ! Got it now. Actually, I'm French so I don't know about accents. I hope I'll in few years :-)
14:30:28 <monochrom> So Boston people pronounce "hacker" as "hackschwa"?
14:30:30 <dcoutts> bos: which I'm coming round to more and more, given that we do want substring API by default, then unlike ByteString we can't make it an exact copy of List, but we can do something regular.
14:30:53 <ystael> monochrom: someone, somewhere, undoubtedly does to make a point.  :D
14:31:13 <bos> dcoutts: right
14:31:45 <monochrom> "Schwarzeneggschwa plays Terminatschwa!"
14:33:18 <monochrom> And that terminates the conversations.
14:34:30 <bos> dcoutts: ooh, hmm, also need right-to-left variant as well as left-to-right.
14:36:40 <Baughn> Is there a version of cabal-install for 6.12/13?
14:40:18 <bos> dcoutts: now for another trick! how to append two Texts that are really views onto the same original Text?
14:40:24 <bos> dcoutts: i.e. do so without copying?
14:42:30 <en0th> Cale, is fix the Y combinator?
14:42:45 <Cale> en0th: The Y combinator is an implementation of fix in the untyped lambda calculus.
14:43:47 <en0th> ok
14:45:01 <Cale> If I try to write it directly without modification in Haskell, it will cause a type error.
14:45:30 <Jonathan_Poulter> Hey, I'm pretty new to Haskell, looking for a little help, am I in the right place?
14:45:36 <Cale> Jonathan_Poulter: yep
14:45:45 <Cale> :t let y = \f -> (\x -> f (x x)) (\x -> f (x x)) in y
14:45:47 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:45:47 <lambdabot>     Probable cause: `x' is applied to too many arguments
14:45:47 <lambdabot>     In the first argument of `f', namely `(x x)'
14:45:51 <Peaker> Jonathan_Poulter, definitely
14:45:59 <Jonathan_Poulter> Wicked, I'll jump straight in.
14:46:01 <tromp> actually the Y combinator, specified by Y f=f(Y f) has multiple implementations in lambda calculus
14:46:15 <en0th> wow.
14:46:17 <Cale> tromp: Well, that's any fixpoint combinator.
14:46:19 <Alpounet> why Y by the way ?
14:47:10 <tromp> i thought ppl use Y to denote an arbitrary one
14:47:12 <Cale> In a typed lambda calculus, you won't be able to write any fixpoint combinators at all without adding something explicitly.
14:47:40 <Jonathan_Poulter> I have a function which is supposed to compare two playing cards. But also I need to give the function which suit is of higher importance. (Bridge)
14:47:43 <tromp> and then use eg. Y_turing to denote a specific one
14:47:56 <Cale> In Haskell, I can make the definition of that Y that I gave above work using a newtype
14:48:13 <Jonathan_Poulter> I want to go through the list of cards using fold, but foldr only takes a list...
14:48:18 <Jonathan_Poulter> Am I missing something?
14:48:43 <Baughn> dcoutts: Before I start hacking on this, do you have a cabal-install branch for 6.12?
14:49:12 <aavogt> > (compare (True , 2) (False , 2), compare (True, 2) (True, 4))
14:49:13 <lambdabot>   (GT,LT)
14:50:11 <Cale> Jonathan_Poulter: It's a little unclear what you mean there... you're writing a function  comp :: Suit -> Card -> Card -> Ordering  or something? What would the foldr be for?
14:50:40 <Cale> :t let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y
14:50:43 <lambdabot> forall a. (a -> a) -> a
14:50:53 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
14:51:38 <Zeiris>   @hpaste
14:51:43 <Zeiris> @hpaste
14:51:44 <Jonathan_Poulter> winningCard :: Trick -> Suit -> Card             so the trick is the list of Cards which has been laid and a Suit is the trump suit and the highest value card is returned.
14:51:44 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:52:22 <Jonathan_Poulter> I've written another function, which is called on two cards, which take the suit to decided which is of higher value.
14:52:28 <en0th> Jonathan, so you want to compare a card with a list of cards, with a given function
14:52:30 <Cale> Jonathan_Poulter: So perhaps: winningCard trick trump = maximumBy (...) trick
14:52:50 <Cale> Where (...) is some comparison function based on the trump
14:53:17 <Cale> :t maximumBy
14:53:18 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
14:53:48 <Jonathan_Poulter> Right, yea
14:53:53 <Cale> The values of type Ordering are LT, EQ, and GT, standing for "less than", "equal" and "greater than", respectively.
14:54:17 <Jonathan_Poulter> I was looking at foldr, as we've been informed to use mapping functions.
14:54:37 <Cale> Well, you can use foldr1 with a function that returns the better of two cards.
14:54:40 <Jonathan_Poulter> Maybe not on that bit but somewhere.
14:55:05 <Jonathan_Poulter> But not if the function that judges the card needs a third argument?
14:55:12 <Cale> So if you already have  better :: Suit -> Card -> Card -> Card
14:55:40 <Cale> Then you can write  winningCard trump = foldr1 (better trump)
14:56:25 <Jonathan_Poulter> winningCard trump trumpSuit =  foldr1 (better trump trumpSuit)
14:56:33 <Jonathan_Poulter> ?
14:56:47 <Cale> If better takes 4 parameters, then something like that
14:57:27 <Cale> basically, you apply better to all but 2 of its parameters before passing it to foldr1
14:57:45 <Cale> and it needs to be foldr1 and not foldr because the function makes no sense if the list of cards is empty
14:58:00 <Cale> (you'll probably just want it to be an error)
14:59:17 <Jonathan_Poulter> winningCard trick trumpSuit = foldr1( better trick trumpSuit)
14:59:26 <Cale> What's the type of better?
14:59:28 <Jonathan_Poulter> trick is [Card]
14:59:52 <Cale> I was assuming  better :: Suit -> Card -> Card -> Card
15:00:37 <Jonathan_Poulter> Currectly Suit -> Card -> Card -> Bool         (returns whether or not first card beats second)
15:00:40 <Cale> So that when you passed better the trump suit, you would get a function Card -> Card -> Card which would produce the better of the two cards
15:00:42 <Jonathan_Poulter> Currently*
15:01:07 <Cale> ah, then you'll need to write a function which produces the better of the two cards first
15:01:32 <Cale> But in any case, better will not take the list parameter.
15:01:39 <Cale> That's a parameter to foldr1
15:01:57 <Cale> I left it implicit when I wrote my version of winningCard
15:02:03 <Jonathan_Poulter> I can rewrite to better:: Suit -> Card -> Card ->Card easily.
15:02:08 <Cale> But you could put it in, like:
15:02:21 <Cale> winningCard trump trick = foldr1 (better trump) trick
15:02:45 <Cale> I cancelled the 'trick' from both sides of the equation
15:03:41 <Saizan> "f(a b c)" doesn't mean that 'a' 'b' and 'c' are given as arguments to 'f', it means that 'f' is given a single argument, which is 'a' applied to the two arguments 'b' and 'c', this wasn't clear to me at first, coming from C-like languages
15:04:13 <Zao> Saizan: The semantics of f(a,b,c) being even more fun.
15:05:08 <Saizan> Zao: heh, that's actually quite similar to what it looks :)
15:05:37 <Cale> Jonathan_Poulter: If we wanted, we could go even farther, and say  winningCard trump = foldr1 (better trump) = (foldr1 . better) trump, and then cancel the trump, giving  winningCard = foldr1 . better
15:05:42 <ddarius> Saizan: It's (also) identical to what you described before with a = (,,) and one more argument.
15:05:45 <monadic_kid> I'm still unsure about this: http://www.reddit.com/r/haskell/comments/9qo7e/advice_on_naming_conventions_for_lots_of_c_enums/ maybe I should just stick the original names
15:05:55 <Cale> Jonathan_Poulter: But that's getting a bit clever :)
15:06:11 <Jonathan_Poulter> ;) I'm gonna go back to my file have a play :P
15:06:39 <Cale> Jonathan_Poulter: Do you at least understand what it means to apply a function to fewer than its whole set of parameters?
15:06:53 <Cale> Jonathan_Poulter: You get a function which takes the remainder of the parameters
15:06:58 <Zao> monadic_kid: Trying to wrap d3d?
15:07:12 <Jonathan_Poulter> Yea, returned is a function with the rest of its parameters unapplied.
15:07:52 <Saizan> ddarius: except for a set of parens
15:08:30 <Cale> Jonathan_Poulter: So that's what we do here, apply better to the trump to get a function of two cards which we pass to foldr1
15:08:35 <monadic_kid> Zao: aiming for d3d9 and 11 and the rest of directx with some help (hopefully), I don't have a problem writing them it's just I want to use the right naming convents that everyone wants
15:08:44 <Cale> Jonathan_Poulter: make sense? :)
15:08:48 <ddarius> f(b,c) = f ((,) b c)
15:08:56 <Zao> monadic_kid: Honk when you're done.
15:09:41 <Jonathan_Poulter> I think I get ya :P I'm gonna bash my head against the keypad for a minute, see what I can do.
15:09:44 <Zao> Have you've considered stealing names and module layouts from SlimDX?
15:10:37 <Alpounet> can we have type-level combinators ?
15:10:42 <monadic_kid> Zao: I'm looking at it, the problem is that .NET has strongly & scoped enum type
15:11:03 <Zao> I'd probably lean towards a mixture of modules and prefixing.
15:11:07 <Beelsebob> monadic_kid: people want a D3D binding?
15:11:08 <monadic_kid> Zao: i mean it's not  a problem it just makes it easy for them
15:11:08 <Beelsebob> o.O
15:11:23 <monadic_kid> Beelsebob: I do
15:11:28 <Beelsebob> why?
15:11:43 <Zao> Beelsebob: I do.
15:11:48 <Beelsebob> same question
15:11:48 <Alpounet> monadic_kid, whatever naming convention you choose, congrats
15:11:56 <Zao> Beelsebob: Because Direct3D is better than OpenGL <holywar>
15:12:06 * Beelsebob nods
15:12:27 * Beelsebob finds the "works everywhere" advantage rather too overpowering for any superiority of the API
15:12:33 <Philippa> it's a thing worth having if we want people doing gamedev in haskell
15:12:38 <Beelsebob> it is
15:12:45 <Beelsebob> was just wondering why in this specific case
15:12:46 <Zao> I find the "works everywhere" irrelevant for my applications.
15:12:53 * pikhq notes that Direct3D is only relevant if you only care for Windows and the Xbox.
15:12:56 <Zao> Which is games, visualisations and general awesomeness.
15:13:30 <Philippa> pikhq: or are writing a back end per platform
15:14:13 <Cale> In absence of "works everywhere", I'm willing to take "works on linux". :)
15:14:17 <Saizan> "general awesomeness" would make a great hackage category
15:14:23 <pikhq> Philippa: Also true.
15:15:17 <Cale> But stuff which works on linux is usually so close to being cross-platform already
15:15:31 <Zao> Cale: Unless you depend on silly GNUisms.
15:16:02 <Zao> Not too much of a problem in Haskell, of course.
15:16:18 <Zao> Except if you depend on packages that insist on using shell utils to build.
15:17:08 <pikhq> Which limits you to those platforms that have a shell.
15:17:22 <pikhq> (... There goes DOS and classic Mac OS!)
15:17:38 <Jonathan_Poulter> Cale: Thanks, a slight problem still I'm folding the wrong way. As a card played after the first must compare to the first card rather than working right to left.
15:18:03 <Cale> Jonathan_Poulter: Ah, I hadn't suspected that 'better' would be nonassociative.
15:18:15 <Cale> Jonathan_Poulter: try foldl1 then
15:18:20 <Jonathan_Poulter> Yea I did.
15:18:24 <Jonathan_Poulter> to no avail :P
15:18:27 <skorpan> does anyone use DOS by choice these days?
15:18:39 <Cale> Jonathan_Poulter: Perhaps it's associative but not commutative?
15:18:39 <ddarius> Does anyone use DOS these days?
15:18:43 <skorpan> ddarius: yes
15:18:45 <Philippa> only under emulation
15:18:54 <medfly> skorpan, who?
15:19:04 <Alpounet> to play Wacky Wheels
15:19:04 <Philippa> (myself, that is, I'm quite sure there's some industrial stuff still running on it somewhere)
15:19:05 <Cale> Jonathan_Poulter: You could flip the parameters to better, perhaps?
15:19:06 <Beelsebob> I used it recently
15:19:06 <Alpounet> :-p
15:19:11 <Beelsebob> to play Syndicate
15:19:23 <skorpan> medfly: iirc, someone on the emacs-devel mailing list was whining about DOS support that people were discussing whether to drop or not
15:19:27 <Philippa> Alpounet: Death Rally!
15:19:38 <Alpounet> one of the best game *EVER*
15:19:47 <Jonathan_Poulter> Okay that works.
15:19:47 <monochrom> When I go to bank offices I admire their OS/2 2.x terminals!
15:19:51 <skorpan> people "use" cobol these days, so why would using dos be so strange?
15:19:55 <Jonathan_Poulter> How and why does that work *salutes*
15:20:00 <Alpounet> damn, Wine might be able to run it !
15:20:00 <medfly> skorpan, I think someone like him wouldn't mind just sticking to old versions
15:20:27 <Philippa> Alpounet: DR works nicely under DOSBox if you get it using the GUS
15:20:28 <Cale> Jonathan_Poulter: well, instead of reversing the list, you're giving the parameters to better in the opposite order
15:20:39 <Cale> Jonathan_Poulter: it has the same effect though
15:21:42 <skorpan> medfly: http://lists.gnu.org/archive/html/emacs-devel/2009-08/msg01214.html
15:21:55 <Cale> Jonathan_Poulter: You probably have some law like that  better t x (better t y z) = better t (better t x y) z, so that foldr1 and foldl1 of better t will be the same thing
15:22:06 <Cale> Jonathan_Poulter: But better t x y and better t y x are different
15:22:27 <dcoutts> bos: appending texts that are part of the same parent? I don't see how that can be improved, given the representation.
15:23:01 <dcoutts> Baughn: I've not forked cabal-install for the next release yet. What are you planning on working on?
15:23:04 <Alpounet> Philippa, I'm attached to WW, sorry
15:23:10 <bos> dcoutts: right, alas.
15:23:15 <Alpounet> was playing it when 5 or 6 years old
15:23:20 <Alpounet> :-p
15:23:26 <bos> dcoutts: if we had stable pointers and they were cheap, we could do it.
15:23:29 <skorpan> medfly: also, from someone who really does use DOS and emacs 23: http://osdir.com/ml/general/2009-08/msg00638.html
15:23:33 <dcoutts> bos: how?
15:23:43 <bos> dcoutts: by noticing that the underlying array was the sam
15:23:45 <bos> same
15:24:04 <dcoutts> bos: I presumed you meant non-intersecting sub-sequences
15:24:17 <dcoutts> bos: if they're intersecting then it's totally doable
15:24:20 <Baughn> dcoutts: Nothing in particular, I'm just testing out how well 6.12 works. I'll probably take a look at fixing up cabal-install for it, then, unless you tell me that's a humongous job best restricted to elder gods.
15:24:32 <bos> dcoutts: yes, intersecting.
15:24:33 <dcoutts> Baughn: it's non-trivial
15:24:35 <bos> dcoutts: how?
15:24:51 <bos> dcoutts: is there some pointer-like thing that can be compared for equality?
15:24:53 <dcoutts> Baughn: it's all to do with representations of package identifier and package indexes
15:25:03 <Jonathan_Poulter> Seriously thank you, I'll really sit down and understand what you've said until I get it properly and fully what going on.
15:25:10 <dcoutts> bos: ah text doesn't use ForeignPtr of course, so it's not stable. Hmm.
15:25:12 <Jonathan_Poulter> Thanks very much.
15:25:19 <copumpkin> stablepointer?
15:25:26 <Baughn> dcoutts: Yeah, I just diffed the cabal documentation. Um..
15:25:34 <dcoutts> bos: though you could still use some tricky eq comparison.
15:25:41 <Cale> Jonathan_Poulter: no problem. Feel free to hang around and ask any questions you might have :)
15:25:58 <bos> dcoutts: hmm, i don't know what that would be.
15:26:01 <Baughn> dcoutts: This makes me long for SQL. :/
15:26:08 <Jonathan_Poulter> :) you mentioned cancelling...
15:26:11 <dcoutts> Baughn: for one thing, it needs a copy of the PackageIndex type from before the recent Cabal changes.
15:26:22 <Cale> Jonathan_Poulter: yeah, if f x = g x for any x, then f = g
15:26:23 <dcoutts> bos: unsafeBlahEq something
15:26:34 <dcoutts> bos: it doesn't need to be reliable
15:26:44 <bos> dcoutts: true
15:26:58 <Jonathan_Poulter> Yea fair enough
15:27:17 <dcoutts> bos: can you think of any practical cases where it'd be a big win?
15:27:29 <dcoutts> bos: I can't immediately think of any
15:27:44 <Cale> Jonathan_Poulter: So we can simplify that way, whenever we see a function being defined as another function applied to the same parameter.
15:27:45 <bos> dcoutts: p'raps not
15:27:56 <Jonathan_Poulter> So winningCard suit trick = foldl1 (beats suit) trick could be rewritten without trick
15:28:00 <Cale> yeah
15:28:48 <Cale> so then we have: winningCard suit = foldl1 (beats suit)
15:29:12 <Cale> and then if we make the composition of functions on the right side explicit using the (.) operator:
15:29:21 <Cale> winningCard suit = (foldl1 . beats) suit
15:29:38 <Jonathan_Poulter> But then there's no way of defining the trick which I'm getting the winningCard of.
15:29:52 <Cale> Well, you still pass it as a parameter
15:30:09 <Cale> We haven't actually changed the function which we're defining at all
15:30:14 <Cale> Just the way in which we're defining it
15:30:23 <Cale> It still has the same parameters
15:31:07 <Jonathan_Poulter> No you've lost me.
15:31:16 <Cale> okay...
15:31:21 <Cale> Let's pick a simpler example
15:31:34 <Jonathan_Poulter> I'd call the function in WinHugs using winningCard sampleTrick Diamond
15:31:40 <Jonathan_Poulter> Okay shoot.
15:31:47 <Cale> incrementAll xs = map (+1) xs
15:32:02 <tibbe_> dcoutts: bos: I've been thinking about where I/O operations involving Text should go. it seems like they can't go in base where the rest of the new I/O stuff goes as that would introduce a dependency on text. On the other hand it's useful to have handles with e.g. readLine that returns Text values. Any ideas?
15:32:03 <Cale> > let incrementAll xs = map (+1) xs in incrementAll [1,2,3]
15:32:04 <lambdabot>   [2,3,4]
15:32:12 <Jonathan_Poulter> Would add one to each number in xs
15:32:15 <Cale> Now we'll cancel out the xs
15:32:19 <Cale> > let incrementAll = map (+1) in incrementAll [1,2,3]
15:32:21 <lambdabot>   [2,3,4]
15:32:34 <Cale> You still use it the same way.
15:32:43 <ilid> > let increment = map . (+) in increment 3 [5,6,7]
15:32:44 <Cale> It's just that the definition is shorter.
15:32:44 <lambdabot>   [8,9,10]
15:33:00 <dcoutts> tibbe: I'd not worry yet about which package
15:33:36 <Jonathan_Poulter> What are let and in?
15:34:07 <Cale> Oh, the syntax is   let <definitions> in <expression>
15:34:16 <Cale> and it just makes those definitions locally
15:34:24 <tibbe_> dcoutts: but it seems like it must be in text no?
15:34:37 <dcoutts> tibbe: maybe
15:34:46 <Cale> So inside <expression> we can use any of the definitions we made in the part after the 'let'
15:34:47 <dcoutts> tibbe: the more interesting Q, imho is what module name
15:35:06 <Cale> > let x = 5 in x + x
15:35:08 <lambdabot>   10
15:35:17 <monadic_kid> i'm just wondering if there is a way to foreign ptr scoped so that we can have deterministic disposal, scoped resources
15:35:22 <Jonathan_Poulter> These let <def> in <exp> can be made anywhere in the file?
15:35:29 <monadic_kid> *for foreign ptrs to be scoped
15:35:35 <Cale> Jonathan_Poulter: anywhere that you need an expression
15:35:41 <Cale> Jonathan_Poulter: that is, it is a value
15:36:23 <tibbe_> dcoutts: that is an interesting question
15:37:44 <Peaker> monadic_kid, You can use a bracket instead?
15:38:08 <Jonathan_Poulter> Okay I follow the arithmetic examples.
15:38:10 <dcoutts> tibbe: System.IO.Text seems the obvious place
15:38:37 <Cale> Jonathan_Poulter: So when we're rewriting the definition of winningCard, we're not changing the type of the function
15:38:48 <Cale> Jonathan_Poulter: It still takes the trump suit and the trick as parameters
15:39:05 <Cale> Jonathan_Poulter: We're just expressing what it does in a way that doesn't explicitly mention those things.
15:39:26 <Cale> For example...
15:39:32 <monadic_kid> Peaker: I don't think that will change the fact that a forien ptr has a finalizer called by the GC at any point which isn't deterministic.
15:39:54 <Cale> If we go with the definition  winningCard = foldl1 . better
15:40:31 <dcoutts> tibbe: unless we have an overhaul of System.IO to partition into binary and text Handles
15:40:37 <Cale> then  winningCard Hearts trick = (foldl1 . better) Hearts trick = foldl1 (better Hearts) trick
15:40:40 <Peaker> monadic_kid, Can't you get the finalizer called directly?
15:40:50 <Peaker> monadic_kid, especially if you wrote the finalizer?
15:41:25 <Cale> So it amounts to the same thing when you apply it to a suit and a list of cards.
15:41:36 <Cale> and the type signature won't have changed at all
15:41:53 <monadic_kid> Peaker: basically I'm talking about something like RAII in C++, using keyword in C#, etc.
15:41:57 <Jonathan_Poulter> winningCard :: Suit -> Trick -> Card this is the type signature
15:42:09 <Jonathan_Poulter> winningCard suit trick = foldl1 (beats suit) trick this is the definition
15:42:27 <Jonathan_Poulter> Should really seperate text from code.
15:42:33 <Peaker> monadic_kid, its basically "bracket"
15:42:55 <Peaker> monadic_kid, if you can get the code in "Foreign Ptr"s finalizer to run outside of the GC
15:44:31 <monadic_kid> Peaker: okay, i misunderstood you when you said bracket the first time
15:44:46 <Peaker> @type bracket
15:44:47 <lambdabot> Not in scope: `bracket'
15:44:48 <Cale> Jonathan_Poulter: and then
15:44:52 <Peaker> @type Control.Exception.bracket_
15:44:53 <lambdabot> forall a b c. IO a -> IO b -> IO c -> IO c
15:44:55 <Peaker> @type Control.Exception.bracket
15:44:56 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:45:05 <Cale> winningCard = foldl1 . beats
15:45:15 <Jonathan_Poulter> Then I'm not sure its like you're makign a second definition
15:45:16 <Cale> Jonathan_Poulter: is an equivalent definition of the same thing
15:45:33 <Cale> Jonathan_Poulter: which could be used with the same type signature
15:45:41 <monadic_kid> Peaker: yeah i found it already but thanks anyways :P
15:45:57 <Cale> Jonathan_Poulter: So we could write...
15:46:12 <Cale> winningCard :: Suit -> Trick -> Card
15:46:14 <Cale> winningCard = foldl1 . beats
15:46:32 <Jonathan_Poulter> Yea I've done that, to no avail.
15:46:36 <Cale> Oh, really?
15:46:37 <Cale> hmm
15:46:50 <Cale> Does the other definition work?
15:46:58 <tibbe> dcoutts: the hackage package page for bytestring links to Internal and Fusion but the links are broken. is haddock doing something wrong?
15:46:59 <Jonathan_Poulter> Yea
15:47:15 <Cale> Jonathan_Poulter: Oh, you can't have both at the same time, of course.
15:47:26 <Cale> Jonathan_Poulter: I'm just giving a refactoring.
15:47:52 <Jonathan_Poulter> Yea else you'd have two definitions
15:47:55 <Cale> right
15:48:03 <Jonathan_Poulter> okay, it works
15:48:10 <Cale> okay, good :)
15:48:43 <Jonathan_Poulter> I'd mixed argument order
15:48:45 <bos> dcoutts: why wouldn't they go into the text package?
15:49:14 <Cale> You might find it clearer with the parameters left in for now too, but it's nice to get into the practice of thinking about defining functions by composing simpler ones.
15:49:19 <dcoutts> bos: that's probably the sensible place
15:49:32 <dcoutts> bos: with the current IO structure in base
15:49:39 <bos> dcoutts: right
15:49:45 <Cale> (rather than by saying what they do to their arguments)
15:50:35 <Jonathan_Poulter> Yea I guess its that change of thinking to really get Haskell.
15:50:57 <Jonathan_Poulter> Java... C#... very much a different way of thinking.
15:51:12 <tibbe> bos: spoke to Fredrik Lundh about your use of "his" sort algorithm in 'text'. He said he might need to learn haskell now. ;)
15:51:16 <Jonathan_Poulter> I kinda feel like I've never programmed before, again...
15:51:36 <bos> tibbe: oh really?
15:51:40 <bos> tibbe: :-)
15:51:50 <tibbe> bos: yes (he's on my team at work)
15:51:54 <bos> oh, nice.
15:52:08 * bos is currently reimplementing it for lazy text.
15:52:11 <bos> much more work.
15:52:20 <tibbe> bos: I can imagine
15:53:08 * tibbe pulls the latest Data.Text to check out what's new
15:54:39 <en0th> :t (.)
15:54:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:55:08 <Saizan> Jonathan_Poulter: then you're doing it right :)
15:55:41 <Jonathan_Poulter> Cale: As a check knowing foldl1 cannot be applied to an empty list I can just add another definition?
15:55:45 * bos pushes again, for tibbe's benefit
15:55:53 <tibbe> bos: cool!
15:56:55 <Jonathan_Poulter> winningCard suit [] = error "Fail"
15:57:17 <Jonathan_Poulter> Saizan: :P
15:57:31 <SubStack> I remember early-on being annoyed by having to break apart pieces of formula into individual calculations with hand-held calculators
15:58:07 <en0th> Jonathan_Poulter: or use a Maybe
15:58:32 <en0th> Cale: (..is it correct?)
15:58:38 <Jonathan_Poulter> en0th: Yea I'm waiting on the Maybe lecture :P
15:58:39 <dcoutts> tibbe: do you mean search? there is no sort in Data.Text afaics
15:58:53 <Peaker> Should (.) be fmap or Control.Category.. ?
15:58:56 <aavogt> en0th: it works though
15:59:21 <tibbe> dcoutts: hmm, ye
15:59:33 <aavogt> > (+1) . Just 2
15:59:34 <lambdabot>   Just 3
16:00:54 <Peaker> That doesn't feel like function composition
16:01:05 <Peaker> Control.Category.. is probably a better choice for (.)
16:01:24 <dcoutts> tibbe: this is the bloom filter thing
16:01:26 <dolio> It's not function composition, it's functor application.
16:01:30 <dcoutts> tibbe: right?
16:01:38 <tibbe> dcoutts: hmm no
16:01:39 <Peaker> dolio, yeah, so probably shouldn't be (.)
16:01:41 <tibbe> dcoutts: I'm confused
16:02:12 <tibbe> dcoutts: Data.Text.Search
16:02:33 <burp> :t (.)
16:02:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:02:40 <burp> o0, since when?
16:02:46 <sioraiocht> that's new
16:02:46 <sioraiocht> heh
16:02:50 <sioraiocht> :t (.)
16:02:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:03:01 <en0th> :t <$>
16:03:02 <dolio> Peaker: Yeah, I think Control.Category.. is the more obvious generalization.
16:03:02 <lambdabot> parse error on input `<$>'
16:03:06 <sioraiocht> also, not what MY ghci says =p
16:03:13 <mauke> :t (++)
16:03:14 <lambdabot> forall a. [a] -> [a] -> [a]
16:03:18 <mauke> what, no monoids?
16:03:24 <en0th> :t (<$>)
16:03:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:03:27 <dolio> Although having . instead of <$> is nice, and it is still a generalization of a sort.
16:03:53 <Peaker> Maybe <$> just needs a more convenient-to-type name
16:04:29 <burp> whats function composition now?
16:04:40 <dolio> It makes one of the functor laws look nice, too. (f . g) . x = f . (g . x)
16:04:40 <mauke> (.)
16:04:49 <tibbe> bos: is replicateChar n faster than just replicate n . singleton?
16:05:31 <dolio> id . x = x is nice, too. Although one could object to the points in there.
16:05:56 <bos> tibbe: depends.
16:06:03 <Peaker> dolio, that's true either way
16:06:12 <bos> tibbe: if you're using optimisation and using replicate n . singleton, it gets fused to replicateChar
16:06:24 <en0th> :t ((.) . (=<<))
16:06:26 <lambdabot> forall (f :: * -> *) a (m :: * -> *) b. (Functor f, Monad m) => (a -> m b) -> f (m a) -> f (m b)
16:06:26 <aavogt> @type Prelude..
16:06:27 <lambdabot> parse error on input `Prelude..'
16:06:32 <aavogt> @type Prelude.(.)
16:06:33 <lambdabot> Not in scope: data constructor `Prelude'
16:06:42 <tibbe> bos: I guess my question is: does replicateChar deserve to be in the API
16:06:51 <aavogt> @type P..
16:06:52 <lambdabot> parse error on input `P..'
16:06:55 <dolio> What's true?
16:07:10 * mauke stares at aavogt 
16:07:11 <Peaker> Hmm.. if (f <$> g) <$> x   type-checks,  will f <$> (g <$> x)  type check?   g is not necessarily a function
16:07:23 <bos> tibbe: ah.
16:07:44 <Peaker> @type \f g x -> ((f <$> g) <$> x, f <$> (g <$> x))
16:07:45 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> (f b, f b)
16:08:09 <bos> tibbe: i think that was a mistake.
16:08:11 <tibbe> bos: The documentation for unlines looks wrong: "O(n) Portably breaks a Text up into a list of Texts at line boundaries. "
16:08:15 <mauke> :t (?f <$> ?g) <$> ?x
16:08:16 <lambdabot> forall a b a1 (f :: * -> *). (?f::a -> b, ?g::a1 -> a, ?x::f a1, Functor f) => f b
16:08:25 <tibbe> bos: seems like it's copied from lines
16:08:28 <mauke> g is necessarily a function
16:09:18 <Peaker> mauke, Yeah, I meant to say it was not supposed to be necessarily one.
16:09:28 <Peaker> mauke, and that that expression forces it to be
16:09:52 <mauke> huh?
16:09:56 <Peaker> fmap f . fmap g = fmap (f . g)    requires both fmap and (.), so if (.)=fmap, you can't express that law
16:10:12 <Peaker> mauke, dolio said it was a nice formulation of the Functor law, and I don't see how it is
16:10:18 <Peaker> mauke, of one of the functor laws, that is
16:10:36 <dolio> Peaker: The functor law is 'fmap (f . g) = fmap f . fmap g'
16:11:02 <bos> tibbe: patches welcome :-)  i'm neck-deep in other code
16:11:15 <ivanm> Hmmmm.... so if we have the functor law, the monad police, etc., who acts as the police to enforce these laws?
16:11:16 <ivanm> :p
16:11:22 <Peaker> dolio, I don't see how that is the same as what you wrote above, unless each (.) means something else :)
16:11:29 <ivanm> (and chuck offenders in the Jail monad?)
16:11:29 <dolio> If you expand that out, you get 'fmap (f . g) x = fmap f (fmap g x)'.
16:11:30 <tibbe> bos: sure :), I'm just noting it before going to bed, otherwise I'll forget
16:11:36 <Cale> Jonathan_Poulter: yeah, though that might be a good reason to leave the parameters in, as you can't pattern match on parameters if they're not explicit :)
16:11:38 * tibbe writes it down in meacs
16:11:42 <bos> tibbe: ok, thanks!
16:11:46 <dolio> Which if you rename fmap to (.), you get (f . g) . x = f . (g . x).
16:11:51 <Cale> Jonathan_Poulter: (sorry, went to dinner :)
16:12:13 <tibbe> emacs*
16:12:18 <aavogt> mauke: so @type doesn't have Prelude qualified at all?
16:12:19 <Peaker> dolio, ah, the confusing part is using (.) for both the general fmap and function composition here
16:12:19 <Jonathan_Poulter> :) no problem.
16:12:20 <dolio> In the (f . g) case, it specializes to function composition, because f and g are both functions.
16:12:24 <ivanm> tibbe: "meacs"?
16:12:28 <Peaker> dolio, I understand now, thanks
16:12:32 <tibbe> ivanm: emacs
16:12:32 <mauke> :t (Prelude..)
16:12:33 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:12:34 <ivanm> tibbe: heh
16:12:39 <tibbe> ivanm: but's it's late here
16:12:46 <ivanm> excuses, excuses
16:12:55 <tibbe> the size of the keyboard keys should increase after midnight
16:13:02 <Saizan_> you've to know that (->) r's fmap is function composition, but that's a free theorem too, afaiu
16:13:37 <Peaker> @free fmap f . fmap g = fmap (f . g)
16:13:38 <lambdabot> Extra stuff at end of line
16:14:10 <dolio> @free comp :: (a -> b) -> (r -> a) -> (r -> b)
16:14:11 <lambdabot> g . k = p . f => f . q = f1 . h => g . comp k q = comp p f1 . h
16:14:17 <aavogt> I see what I was doing wrong now :)
16:14:34 <mcnster> hi. suffering brain seizure here... how do i sum two lists: (Num a) => [a] -> [a] -> [a]?
16:14:42 <tibbe> bos: hmm, find still requires O(k) time to drop all the matches if you're really after what's between them. But perhaps people should use a split function in those cases?
16:14:46 <mauke> mcnster: zipWith?
16:14:55 * tibbe thinks about when people actually uses find
16:15:37 <Saizan_> mcnster: zipWith (*)
16:15:37 <mcnster> mauke: doh!  thanks :)
16:15:51 * mauke stares at Saizan_ 
16:18:44 <tibbe> bed time, gnight all
16:20:46 * Saizan_ realizes he should read more accurately
16:30:34 <burp> that's not it ;)
16:43:56 <Cale> Somewhat ironic that firefox will happily resize raster images which are too large to fit in the browser window, yet has no such feature for rescaling SVG which would be much simpler to do.
16:45:13 <Cale> Oh, it turns out you can scale them, just not the same way.
16:45:38 <bitstream0101> dcoutts: you around?
16:45:42 <calsaverini> how do I use lambdabot to see the source of some function?
16:45:53 <calsaverini> >src map
16:45:59 <calsaverini> ?
16:46:25 <calsaverini> @src map
16:46:25 <lambdabot> map _ []     = []
16:46:26 <lambdabot> map f (x:xs) = f x : map f xs
16:46:29 <calsaverini> hummm
16:46:33 <calsaverini> @src Monad
16:46:34 <lambdabot> class  Monad m  where
16:46:34 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:46:34 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:46:34 <lambdabot>     return      :: a -> m a
16:46:34 <lambdabot>     fail        :: String -> m a
16:46:56 <Gracenotes> it takes those definitions from a file it has
16:47:56 <calsaverini> @src (+)
16:47:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:48:03 <calsaverini> :(
16:48:17 <mauke> it's a method anyway
16:48:23 <mauke> @src Int (+)
16:48:24 <lambdabot> Source not found. You type like i drive.
16:54:43 <Veinor> if x is a list, does liftM f x = map f x?
16:55:00 <mauke> yes
16:55:07 <gwern> liftM = fmap?
16:55:14 <mauke> liftM = fmap, and for lists fmap = map
16:55:37 <Jonathan_Poulter> Can I use fold functions to find duplicates in a list?
16:55:38 <mauke> also (>>=) = flip concatMap
16:55:58 <gwern> Jonathan_Poulter: you can even be president if you want to! or an astronaut
16:56:14 <Jonathan_Poulter> That's a yes then :P
16:56:21 <user317> so i am trying to implement an isntance of a class that has monad as a superclass with something that is a transfomer, but i am lost on the type signature that needs to go to the instance declaration
16:56:21 <user317> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10512#a10512
16:56:27 <Jonathan_Poulter> Can I really be an astronaut?
16:56:41 <And[y]> i wanna be an astronaut, but i cant =(
16:56:43 <gwern> Jonathan_Poulter: well, unless you don't have 20/20 natural vision
16:57:01 <Jonathan_Poulter> How does that effect my ability to sort a list with fold?
16:57:04 <monochrom> You can be an astronaut if you know monads.
16:57:49 <Veinor> all gazelles instinctively understand monads.
16:58:02 <gwern> when lennon sang, I AM THE MONAD, he knew
16:58:11 <And[y]> have you ever seen a one eared astronaut? /;
16:58:15 <mauke> @quote chocolate.*time
16:58:16 <lambdabot> No quotes match. You speak an infinite deal of nothing
16:58:21 <Saizan_> user317: the context goes before Getter
16:58:43 <mauke> @quote time.*choc
16:58:43 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
16:59:11 <user317> Saizan_, ok, let me try that
17:00:18 <Veinor> That's anb amazing quote.
17:00:33 <Saizan_> user317: "instance (MonadState Int (t m), MonadTrans t, MonadState Bool m) => Getter (t m) where" <- this makes more sense, but will need UndecidableInstances, and probably will overlap with oter Getter instances
17:01:14 <user317> Saizan_, do you know why?  in the case where getState is just a state monad, its fine
17:01:19 <Cale> Jonathan_Poulter: hmm... you can write an insertion sort as a fold
17:01:31 <Cale> Jonathan_Poulter: Other types of sorts are not as natural to write that way
17:01:38 <gwern> @quote monad
17:01:38 <lambdabot> SamB says: what happens in the monad... stays in the monad...
17:01:58 <Saizan_> user317: why of what?
17:02:05 <Cale> > insert 5 [1,1,2,3,7,8,9,10]
17:02:06 <lambdabot>   [1,1,2,3,5,7,8,9,10]
17:02:18 <user317> Saizan_: why the undecidable instance?
17:02:26 <Cale> > foldr insert [] [5,2,7,2,8,1,8,9,34,6,7]
17:02:27 <lambdabot>   [1,2,2,5,6,7,7,8,8,9,34]
17:02:31 <user317> Saizan_: thansk by the the way, this works:
17:02:31 <user317> useGetter = do
17:02:31 <user317>    str::String <- get
17:02:31 <user317>    str2 <- lift $ getter
17:02:31 <user317>    bb::Bool <- lift $ lift get
17:02:31 <user317>    return $ str == str2
17:02:50 <Jonathan_Poulter> That's nice
17:04:39 <Cale> As for detecting duplicates, I might recommend the group function.
17:04:45 <Saizan_> user317: use hpaste for more than 2 lines of code, and it's undecidable because it could make the typechecker loop during instance resolution, e.g. if there's another instance Getter m => MonadState Int m
17:04:49 <Cale> > group [1,2,2,5,6,7,7,8,8,9,34]
17:04:50 <lambdabot>   [[1],[2,2],[5],[6],[7,7],[8,8],[9],[34]]
17:05:03 <Cale> > group "mississippi"
17:05:05 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
17:05:11 <Cale> > group . sort $ "mississippi"
17:05:12 <lambdabot>   ["iiii","m","pp","ssss"]
17:05:34 <Cale> > any (not . null . tail) . group . sort $ "mississippi"
17:05:36 <lambdabot>   True
17:05:44 <Cale> > any (not . null . tail) . group . sort $ "unique"
17:05:46 <lambdabot>   True
17:06:27 <Cale> > any (not . null . tail) . group . sort $ "flavour"
17:06:29 <lambdabot>   False
17:06:44 <solidsnack> What data structure, in the wide world of Haskell data structures, is best for membership testing on Word64?
17:07:10 <gwern> bloom filter?
17:07:10 <Cale> solidsnack: Set Word64?
17:07:26 <gwern> membership testing was the bloom filter specialty, I thought
17:07:39 <Cale> Bloom filters are inexact though.
17:07:42 <solidsnack> gwern: Well, actually it's non-membership testing.
17:08:31 <gwern> it's been a while, but isn't non-membership testing just a not wrapped around a member?
17:08:34 <solidsnack> So maybe I'll just use `Set` then; I wanted to check that there wasn't something really cool on Hackage for this that I had missed out on.
17:09:06 <solidsnack> gwern: Well, I think the bloom filter is strongest when you expect most things _not_ to be members.
17:09:38 <solidsnack> However, I am parsing and validating a gigantic family tree. I want to be sure mothers and fathers are always one or the other.
17:10:18 <gwern> solidsnack: that sounds like an invalid property to me
17:10:26 <gwern> eg. trannies
17:10:27 <solidsnack> Hmmm?
17:10:39 <Jonathan_Poulter> That makes much sense, its 1:10 and my gf is insisting I sleep now. :P
17:10:44 <solidsnack> gwern: They are mammals, gwern .
17:10:59 <gwern> solidsnack: trannies are mammals too!
17:11:11 <solidsnack> Trannies have children both ways? I was not aware of that.
17:11:23 <gwern> well, consider a female-to-male
17:11:28 <solidsnack> Yeah.
17:11:38 <solidsnack> So how did this person have children?
17:11:44 <Jonathan_Poulter> Thanks again #haskell, especially to Cale for all your help.
17:11:52 <solidsnack> They don't get sperm from the operation.
17:11:59 <solidsnack> They still use their uterus.
17:12:04 <gwern> while they were female, etc. now, after the operation, is this a guy who is a mother, or what?
17:12:31 <user317> Saizan_, will it always loop, or is it just a possiblity
17:12:48 <solidsnack> If they gave birth, they are doubtless listed as the mother on the birth certificate.
17:12:50 <gwern> if you say they're still a mother, then what if they adopt? wouldn't the adoptee see the former she as a he, and their father?
17:12:59 <Cale> Jonathan_Poulter: see you around!
17:13:02 <solidsnack> Well, this is a genetic family tree.
17:13:36 <gwern> oh, *genetic*. hm, are there no parthenogenic mammals?
17:13:39 <solidsnack> gwern: So adoption, &c. is not of interest. We're calculating relatedness coefficients -- likelihood of shared genetic material -- so...
17:14:18 <Saizan_> user317: well if you manage to have that the needed instances and use the method at the right type i imagine it'll always loop, with only your instance it's just a possibility
17:14:46 <solidsnack> gwern: Mammalian reproduction: one mother, one father, you get one half of your father's genetic material and one half of your mothers.
17:15:04 <gwern> lies! there's mitochondria too! :)
17:15:05 <solidsnack> Whereas for wasps, you get all your father's genetic material and half your mother's.
17:15:17 <solidsnack> gwern: No traits from that.
17:15:36 <solidsnack> Selfish genes aren't going to be in your mitochondira.
17:16:02 <medfly> why not?
17:16:05 <gwern> hm. I'm sure I've heard of diseases stemming from mitochondrial dna problems and diseases sure seem like traits to me, but let it pass...
17:16:20 <user317> Saizan_, so in my code i basically always want the "Monad a" superclass in the Getter definition to be of MonadState Bool
17:16:27 <user317> is there a way to make that part of the definition?
17:16:39 <jfoutz> solidsnack: http://en.wikipedia.org/wiki/Chimera_(genetics) ?
17:16:44 <solidsnack> So anyways, this is not discrimination or heteronormativity. Our research policies are in keeping with the human rights policy of WallaWalla University.
17:16:51 <Saizan_> user317: you can have as many superclasses as you want
17:17:15 <porrifolius> Hi.  Do I need to do anything special to have the haskell curl package read UTF8 content properly?
17:17:33 <user317> so in the "useGetter" function, i want "   bb::Bool <- lift $ lift get" to work by all implementers of Getter, does that make sense?
17:17:49 <porrifolius> I'm getting bad characters in ghci but it's fine when using curl at the command line.
17:17:55 <solidsnack> porrifolius: I shouldn't think so.
17:18:19 <solidsnack> porrifolius: How are you giving it the inputs?
17:19:13 <porrifolius> Hmmm... I do 'curl -L file.html' at cmdline get a file with the bytes 0xE280 in it...
17:20:23 <porrifolius> I do a curlGetString file.html [follow option] in ghci and then 'show' the String... I get \226\128\166 where I should get the E280
17:20:39 <Saizan_> user317: i'd rethink about your desing, it seems quite convoluted to me
17:20:48 <LambdaF> I have EulerLib and Euler1 in the same directory.  In the top of EulerLib, I have @module EulerLib where@ and then my code.  In Euler1 I have @import EulerLib@.  I tried ghc --make Euler1.hs -v and it listed looking for EulerLib.hs.  Any ideas?
17:20:57 <gwern> porrifolius:  check using one of the Systen.IO.UTF8 io functions
17:21:01 <user317> Saizan_, i agree, i am just learning things the hard way for fun
17:21:09 <fnord123> is there a way i can fold any line of code that doesn't begin with '>' ?
17:21:15 <fnord123> oops wrong channel
17:21:37 <monochrom> What does file.html itself say? Does it erroneously say it's in latin1 or something dumb like that?
17:21:48 <monochrom> (Yes everything other than utf8 is dumb!)
17:21:53 <solidsnack> porrifolius: Look for a `getByteString` or something like that; then use the UTF8 translaters.
17:22:01 <Saizan_> porrifolius: show on strings add all kinds of quotations so they are valid haskell literals
17:23:31 <gwern> Saizan_: doesn't the default show and IO stuff just mangle utf8 like that?
17:24:03 <Saizan_> gwern: show does something, System.IO.putStrLn something else entirely
17:24:15 <porrifolius> gwern,Saizan_: Test what?  'show'ing the String from curlGetString?  If I show ['...'] (pasted the ellipsis into ghci) it shows as "\8230" which is right.
17:24:19 <Saizan_> in this case i think System.IO.putStrLn would do the right thing.
17:25:17 <Saizan_> porrifolius: what are you trying to do with the String you get from curl?
17:25:38 <Makoryu> gwern: Char is internally Unicode-safe, isn't it?
17:25:45 <LambdaF> I have EulerLib and Euler1 in the same directory.  In the top of EulerLib, I have @module EulerLib where@ and then my code.  In Euler1 I have @import EulerLib@.  I tried ghc --make Euler1.hs -v and it listed looking for EulerLib.hs.  Any ideas?
17:25:46 <gwern> Makoryu: sure - internally
17:25:49 <porrifolius> monochrom: file.html has a UTF-8 charset in the content header.
17:25:55 <Saizan_> LambdaF: no
17:26:05 <monochrom> > show "Ã¡"
17:26:06 <lambdabot>   "\"\\225\""
17:26:14 <Saizan_> LambdaF: it should work, maybe paste on hpaste.org the log
17:26:20 <monochrom> > show "âŠ¥"
17:26:22 <lambdabot>   "\"\\8869\""
17:26:34 <LambdaF> Will do in 5.  tyvm!
17:26:36 <porrifolius> Saizan_: ultimately pickle it to xml using HXT, but the problem is way before that.
17:26:41 <Makoryu> > "Ñ‚ÐµÐºÑÑ‚ Ð¿Ð¾-Ñ€ÑƒÑÑÐºÐ¸"
17:26:43 <lambdabot>   "\1090\1077\1082\1089\1090 \1087\1086-\1088\1091\1089\1089\1082\1080"
17:26:54 <monochrom> Nice, 8869 is right.
17:27:32 <Saizan_> porrifolius: i'd bet the curl package doesn't do any utf8 decoding, so you've to do it yourself, e.g. using utf8-string
17:27:40 <jfoutz> the curl lib does this:
17:27:52 <jfoutz> i wish i could work paste.
17:27:59 <jfoutz> it reads as bytes.
17:28:08 <jfoutz>   do let bytes = sz * szI
17:28:09 <jfoutz>      f (pBuf,fromIntegral bytes)
17:28:15 <porrifolius> I think the problem is curlGetString truncating UTF8 chars... but curl itself is not.
17:28:32 <Saizan_> it doesn't truncate them, it doesn't decode
17:28:44 <jfoutz> yeah, they're just the raw bytes
17:29:05 <porrifolius> Hmmm, bugger.  Any ideas how to work around that?
17:29:08 <solidsnack> porrifolius: So I think what you get is something horrible.
17:29:24 <Saizan_> porrifolius: yes, you use decodeString from the utf8-string package
17:29:29 <solidsnack> You get a string full of Char that are never larger than word8.
17:29:32 <monochrom> âŠ¥ in UTF-8 becomes 0xE2 0x8A 0xA5. If you get that, you know what happened.
17:29:44 <solidsnack> You basically have an inefficient ByteString.
17:30:21 <monochrom> <solidsnack> porrifolius: Look for a `getByteString` or something like that; then use the UTF8 translaters.
17:30:27 <monochrom> I believe that is relevant.
17:30:31 <Saizan_> yeah.
17:30:45 <solidsnack> Unfortunately, there is no getByteString as far as I can tell.
17:31:04 * ivanm likes simonmar's blog post about concurrency /= parallelism
17:32:11 <solidsnack> Hmm, no.
17:32:13 <porrifolius> solidsnack: yeah, can't find mention of bytestring in my version (1.3.4)...
17:32:36 <solidsnack> There is the polymorphic `curlGetString_`
17:32:46 <solidsnack> You can tell it to give a ByteString if you want.
17:34:01 <porrifolius> solidsnack: Ah, yes. I'll try that. The UTF8 translaters that monochrom mentioned will be in the utf8-string package?
17:34:06 <solidsnack> Yes.
17:34:26 <monochrom> solidsnack mentioned it first.
17:34:41 <solidsnack> porrifolius: You may not even need to translate it, though depending on what you are doing.
17:34:51 <monochrom> solidsnack answered all questions before they were asked.
17:35:11 <notsmack> System.Vacuum.Cairo is very cool
17:35:15 <solidsnack> I spend a lot of time working around `String` :)
17:35:56 <notsmack> any way to, for instance, tell it to just 'show' certain types rather than breaking them all the way down?
17:36:11 <monochrom> Two common phenomena on IRC are: question answered before asked, and asker too busy asking to read answers. They lead to much inefficient redundancy.
17:36:40 <porrifolius> solidsnack: I don't need to do any translation per-se... I just want a String, with proper unicode chars, which I'll pickle with HXT to XML. Might have to filter out dodgy windows related chars though.
17:38:28 <notsmack> oh geez, 'viewFile "Main.hs"' was a bad idea...
17:38:43 <gwern> > 1000 / 50
17:38:44 <lambdabot>   20.0
17:39:10 <Saizan_> porrifolius: btw, HXT's readDocument accepts urls too, iirc
17:42:00 <porrifolius> Saizan_: Yeah, my code is a bit chaotic... had to swap to curl instead of hxt's internal retriever in the past due to limitations, had to swap to tagsoup to handle bad html that hxt choked on... bit of a rat's nest that might benefit from new and improved hxt.
17:45:57 <LambdaF> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10513#a10513 Thank you  =)
17:59:25 <Saizan_> LambdaF: and the error?
17:59:50 <LambdaF> C:\code\hs\euler\Euler1.hs:2:7:     Could not find module `LibEuler':       Use -v to see a list of the files searched for. Failed, modules loaded: none.
18:00:30 <Saizan_> "cd C:\code\hs\euler\" and retry
18:00:44 <Saizan_> or pass -i C:\code\hs\euler\ to ghc
18:00:57 <LambdaF> That would work, but is it possible to integrate into the file?
18:01:25 <LambdaF> I guess I could edit my autobuilder, nevermind.  Thanks!  =)
18:09:01 <seanmcl> Is there a GHC extension for "or-patterns"?  E.g. case x of And p q | Or p q | Imp p q -> (p, q)
18:09:23 <copumpkin> nope
18:09:33 <seanmcl> thanks
18:11:30 <Makoryu> seanmcl: Y'know, that would be kinda nice
18:11:32 <copumpkin> maybe you can approximate that with view patterns though
18:12:39 <LambdaF_> The ghc -i isn't working  =(.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10514#a10514
18:14:16 <blackdog> if i have "f,g,h :: IO (Maybe Int)", is there a nicer way of adding them all up then a big do block? Usually i'd use monadic notation for the Maybe, but the IO sort of already has that.
18:14:33 * blackdog feels like he's missing something obvious
18:15:04 <Cale> blackdog: You can do  fmap sum (sequence [f,g,h])
18:15:26 <monochrom> Perhaps ghc -iC:\code\hs\euler\ Euler1.hs
18:15:48 <Cale> blackdog: er, oops, what do you want as the result when any of them are Nothing?
18:15:55 <blackdog> Nothing
18:16:23 <Cale> :t fmap (sum . sequence) . sequence
18:16:24 <lambdabot> forall a (f :: * -> *). (Num [a], Functor f, Monad f) => [f [a]] -> f [a]
18:16:34 <Cale> hmm, that's not right :)
18:16:53 <Cale> oh, right
18:17:22 <Cale> :t fmap (fmap sum . sequence) . sequence
18:17:24 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Num a, Functor f, Monad f, Functor f1, Monad f1) => [f1 (f a)] -> f1 (f a)
18:17:41 <Lemmih> blackdog: Would MaybeT be appropriate?
18:18:04 <Cale> That specialises to [IO (Maybe Int)] -> IO (Maybe Int)
18:18:13 <blackdog> Lemmih: maybe. I haven't looked at monad transformers much - are they considered a heavyweight thing?
18:18:48 <Cale> Or, you could do it half and half with do-notation and sequence
18:19:36 <Cale> :t \xs -> do ms <- sequence xs; return . fmap sum . sequence $ ms
18:19:37 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Num a, Functor f, Monad f) => [m (f a)] -> m (f a)
18:20:14 <Lemmih> blackdog: sequence has the disadvantage of always executing the actions even if some of them return Nothing.
18:20:34 <Cale> Oh, that is a good point.
18:20:39 <blackdog> Lemmih: hm, yeah, that's a big drawback. i want the short circuiting behaviour
18:20:50 <Lemmih> blackdog: Then MaybeT is probably what you want.
18:21:01 <blackdog> alright, i'll dig into that. thanks!
18:23:38 <Lemmih> blackdog: http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/Control-Monad-Maybe.html
18:24:09 <idnar> @unmtl MaybeT IO Int
18:24:10 <lambdabot> IO (Maybe Int)
18:27:30 <blackdog> Lemmih: ah, that looks reasonable. thanks
18:29:04 <porrifolius> Saizan_,monochrom,solidsnack:  Thanks for you help.  The polymorphic curlGetString_ then Data.ByteString.UTF8.toString did the trick. Cheers.
18:29:48 <monochrom> Neato
18:34:25 <Saizan_> LambdaF_: you also need --make
18:35:29 <Saizan_> LambdaF_: next time it's easier to help if you paste the whole thing, command line included :)
18:36:07 <Saizan_> well, you did it now
18:44:24 <lispy_> moo!
18:44:42 <lispy_> wait, where am I logged in from...
18:47:16 <ivanm> lispy: heh
18:47:25 <leimy_> :t 1
18:47:26 <lambdabot> forall t. (Num t) => t
18:47:58 <lispy> ivanm: did you make source graph?
18:47:58 <leimy_> :t (\label -> (\f -> (\g -> (\n -> let res = ((f g) n) in (Debug.Trace.trace (label ++ " " ++ (show res)) res)))))
18:47:59 <lambdabot> forall t t1 a. (Show a) => [Char] -> (t -> t1 -> a) -> t -> t1 -> a
18:48:03 <ivanm> lispy: yes
18:48:05 <ivanm> you like?
18:48:11 <leimy_> huh
18:48:20 <lispy> ivanm: ah, cool.  I'm the guy that sent you the bug report w.r.t the darcs source
18:48:25 <ivanm> ahhhh
18:48:37 <ivanm> yeah, dot keeps throwing these curve balls at me :s
18:49:00 <lispy> yes, this is always unfortunate
18:49:16 <lispy> I'm on a different computer now, I'll see what version of graphviz it has
18:49:28 <ivanm> *nod*
18:49:42 <ivanm> AFAICT, dot is complaining that there are too many nodes or something :s
18:50:01 <ivanm> I really need to add better error reporting into SourceGraph, but that'll have to wait for a bit
18:51:40 <lispy> ivanm: ah, too many nodes could be the case.  The darcs source is kinda big
18:52:09 <lispy> this computer has some 2.20.3 or so, trying an upgrade via macports
18:52:28 <ivanm> *nod*
18:52:41 <ivanm> lispy: AFAICT, graphviz has many problems like this
18:52:56 <ivanm> unfortunately, there is no other graph visualisation suite as good (and free as in speech)
18:53:23 <SamB_XP> I remember a time when GraphViz at least claimed to be proprietary ...
18:53:50 <ivanm> not anymore
18:54:14 <SamB_XP> I know that
18:54:23 <lispy> ivanm: Do you know what the latest stable release is?  The website doesn't seem to say
18:54:24 <SamB_XP> I only just barely remember this time, I think ;-)
18:54:37 <SamB_XP> I was a newborn *nix junkie at the time
18:54:59 <lispy> *sniff* they grow up soo fast
18:56:02 <ivanm> lispy: with "stable" == "tarball release"?
18:56:12 <ivanm> gentoo has 2.24.0
18:56:26 <ivanm> http://www.graphviz.org/Download_source.php
18:56:27 <lispy> hmm
18:56:36 <ivanm> seems to be the latest one available (well, there's a dev snapshot)
18:56:47 <lispy> okay
18:57:10 <ivanm> yeah, graphviz is under the CPL
18:57:16 <ivanm> which the FSF doesn't like
18:57:49 <lispy> so we can expect a "GNUViz" at some point?
18:58:06 * lispy clares at gcj
18:58:11 <lispy> er glares*
18:58:14 <ivanm> heh
18:58:22 <ivanm> well, doesn't iced tea require gcj?
18:58:35 <lispy> What is iced tea?
18:59:08 <ivanm> it was the (in development at least) free-as-in-speech version of Java
18:59:19 <ivanm> well, open source at least
18:59:21 <ivanm> when Sun was still porting to open-source
18:59:27 <ivanm> Fedora, etc. were using it
18:59:36 <ivanm> http://en.wikipedia.org/wiki/IcedTea
19:00:07 <lispy> oh I see
19:03:11 <turpin> what is haskell?
19:03:49 <ivanm> A pure functional programming language
19:04:47 <turpin> i've been programming in c and php for about 8ish years(mostly web development) - would it be useful for what I do?
19:05:21 <ivanm> yes, there are various web frameworks available
19:05:25 <ivanm> happstack, turbinado, etc.
19:05:51 <turpin> I'm reading the docs from the haskell.org now
19:06:19 <Makoryu> turpin: Haskell is great for writing secure programs. Much better than both C and PHP.
19:07:51 <djahandarie> turpin, I wouldn't recommend starting off straight from the docs
19:08:07 <nha_> can haskell make me a better drummer
19:08:11 <djahandarie> It's more important to grasp the underlying concepts before anything specific
19:08:25 <turpin> I started programming out of necessity - I was never a programmer per say ... would haskell help me understand more about programming that I haven't learned from using high level languages?
19:08:27 <ivanm> @faq can Haskell make nha_ a better drummer?
19:08:28 <lambdabot> The answer is: Yes! Haskell can do that.
19:08:35 <nha_> haha
19:08:43 <SamB_XP> nha_: did you ask that just because you wanted someone to do that?
19:08:47 <ivanm> turpin: Haskell is a higher level langauge than what you're thinking about ;-)
19:09:01 <nha_> nah i dunno the bot tricks in the channel
19:09:05 <djahandarie> "uber-high"
19:09:13 <djahandarie> Haskell is soooo high right now bro
19:09:15 <turpin> hmm... I was warned about haskell being complex - why is that?
19:09:21 <SamB_XP> @slap it
19:09:22 <lambdabot> Come on, let's all slap it
19:09:28 <SamB_XP> ... woah
19:09:34 <nha_> lol
19:09:36 <SamB_XP> that's exactly what I *wanted* her to say
19:09:37 <Raynes> Haskell is higher so high, pot heads say "Damn." when they see it.
19:09:50 <djahandarie> turpin, it's just as complex as any other functional language.
19:09:52 <SamB_XP> but there are so many other things she *could* have said
19:10:40 <djahandarie> turpin, I find it easier than most other languages because of how clear it is.
19:11:28 <turpin> where do you all suggest I get started with it to get a good overall understanding?
19:11:40 <jmcarthur> @where rwh
19:11:41 <lambdabot> is http://www.realworldhaskell.org/blog/
19:11:43 <jmcarthur> @where lyah
19:11:44 <lambdabot> www.learnyouahaskell.com
19:12:31 <Makoryu> turpin: The two gold standard tutorials right now are Learn You a Haskell (for beginners) and Real World Haskell (for explaining lots of "scary" concepts, and writing real programs)
19:13:41 <Makoryu> turpin: Real World Haskell is available as a physical book in regular bookstores, by the way
19:13:47 <sereven> hackagebot: polyrhythms 6.6.6 - Training aid for heavy metal drummers (WilliamBruford) -- someday nha_ ...
19:14:01 <gwern> :( I had to kill all my GUI programs to link gitit
19:14:08 <nha_> hot
19:14:16 <gwern> I see the day coming when I will no longer have enough ram to compile gitit
19:14:25 <turpin> ivanm, djahandarie \, Makoryu thanks for your help
19:14:40 <ivanm> no worries
19:14:44 <stepcut> gwern: RAM is overrated, swap is where it's at ;)
19:14:44 <ivanm> gwern: heh
19:14:54 <idnar> swap to a ramdisk! ;P
19:14:54 <ivanm> gwern: highlighting-kate is the worst... does it use TH or something?
19:14:58 <SamB_XP> stepcut: ... right!
19:15:04 <ivanm> if so, why not use ZeroTH?
19:15:18 <djahandarie> I mount my swap to /dev/null
19:15:25 <idnar> turpin: by the way, it's "per se" not "per say"
19:15:27 <gwern> ivanm: I think it just has so many symbols and strings and stuff
19:15:27 <djahandarie> That's how I know it's time to get more RAM
19:15:39 <idnar> (the term is borrowed from Latin)
19:15:39 <gwern> ivanm: so far as I know, kate doesn't use TH
19:16:01 <ivanm> hmmm...
19:16:09 <turpin> idnar, thanks - still working on my english some
19:16:19 <gwern> and I guess all the 50 or 60 syntax highlighting modes get linked into the final binary
19:16:30 <idnar> turpin: no problem, it's a common mistake
19:16:45 <gwern> I mean, the gitit bin is 22mb
19:17:23 <ivanm> yeah
19:17:49 <ivanm> gwern: it was bad enough creating all the new ebuilds for gitit with all the deps, etc.
19:17:59 <ivanm> (especially when I had to bump happstack as well... :s)
19:18:09 <gwern> still, I worry. are there people who never install gitit because they couldn't link it?
19:18:53 <gwern> ivanm: hey, don't blame us for being featureful!
19:19:03 <ivanm> heh
19:20:33 <Cale> tmf;du
19:21:40 <BMeph> @remember idnar  <stepcut> gwern: RAM is overrated, swap is where it's at ;) <idnar> swap to a ramdisk! ;P
19:21:41 <lambdabot> Okay.
19:23:15 <Veinor> that's the best idea ever.
19:24:30 <ivanm> well, I use tmpfs for swap...
19:24:49 <Veinor> tmpfs?
19:25:07 <Veinor> ah
19:25:13 <BMeph> Bring back the Thrashasaurus - swap to a RAM disk! ;p
19:25:41 <Veinor> what would even happen if you swapped to a ram disk and you filled up ram?
19:26:03 <ivanm> lispy: having bindings to this would be cool: http://tulip.labri.fr/
19:26:10 <BMeph> Veinor: Thrashasaurus Hex? ;)
19:26:59 <Veinor> :P
19:29:58 <kpreid> Is there a function like ('0' + i) in C?
19:30:18 <ivanm> kpreid: what does it do?
19:30:31 <kpreid> adjacent characters
19:30:46 <kpreid> ['0'..] !! i, but more efficient
19:31:01 <sjanssen> kpreid: chr (ord '0' + i)
19:31:11 <kpreid> bleh
19:31:27 <ivanm> you could possibly use to/from enum rather than chr and ord...
19:31:31 <sjanssen> characters are not numbers, at least Haskell doesn't pretend they are
19:31:41 <ivanm> unless some languages we could mention... >_>
19:31:43 <kpreid> I know, this is a cheap hack
19:31:56 <BMeph> Object-Orientation rots the brain! There's a reason they call it "OOPS", y'know... ;p
19:32:03 <Axman6> > ['0'..] !! 6
19:32:03 <lambdabot>   '6'
19:32:06 <Axman6> > ['0'..] !! 60
19:32:07 <lambdabot>   'l'
19:32:29 <sjanssen> I don't see what's wrong with chr/ord
19:32:37 <sjanssen> make a function for that if you use it frequently
19:33:51 <sjanssen> advance k i = toEnum (fromEnum k + i) -- :: Enum a => a -> Int -> a
19:34:12 <mmorrow> instance Num Char where fromInteger = char . fromInteger; (+) = ...
19:34:19 <mmorrow> s/char/chr/
19:34:22 <sjanssen>  /kickban mmorrow
19:34:25 <mmorrow> :)
19:34:41 <Veinor> Haha
19:36:18 <shazam> hello, does haskell support universally quantified type variables, like in O'Caml?
19:36:24 <Cale> yes
19:36:32 <shazam> how so?
19:36:36 <Cale> :t map
19:36:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:36:55 <Cale> You can leave out the "forall a b." part. It's implied.
19:37:07 <shazam> I meant variables that can never be instantiated
19:37:18 <Cale> (but there are extensions in GHC which let you change the place where the variables are quantified)
19:37:30 <mmorrow> data S s a = S (forall o. (a -> s -> o) -> s -> o) -- ?
19:37:33 <Axman6> shazam: got an example?
19:37:38 <Cale> Do you perhaps mean higher-rank types?
19:37:42 <Cale> :t runST
19:37:43 <lambdabot> forall a. (forall s. ST s a) -> a
19:37:52 <ManateeLazyCat> How to get the number of seconds since 1970-01-01 00:00:00 ? Including microseonds.
19:38:10 <shazam> in O'Caml, for example: let a = {x : forall a. a -> a} in a.x 4 <---this would flag an error
19:38:11 <ivanm> Data.Time?
19:38:14 <ivanm> the datetime package?
19:38:30 <bd__> ManateeLazyCat: http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock-POSIX.html  getPOSIXTime
19:38:53 <shazam> Cale, so how would you put that as a constructor type?
19:39:06 <ManateeLazyCat> bd__:  I think that's i want, thanks!
19:39:09 <Cale> Constructor type?
19:39:32 <mmorrow> data Foo = Foo (forall a. a -> a) -- ?
19:39:33 <shazam> like data Foo a where bar: forall x. x -> Foo x
19:39:58 <Cale> data Foo a = Bar a
19:39:59 <Cale> ?
19:40:01 <shazam> mmorrow, and Foo (\x -> x + 1) would flag an error ?
19:40:07 <mmorrow> yeah
19:40:18 <shazam> how would I put that in a GADT?
19:40:18 <mmorrow> the only thing you could really put in there would be id
19:40:51 <mmorrow> data Foo where Foo :: (forall a. a -> a) -> Foo -- ?
19:40:56 <SamB_XP> and (const (error "blah"))
19:41:08 <mmorrow> yeah, and stuff like that
19:42:03 <Cale> shazam: Are you trying to define a type whose data constructor forces you to pass it a polymorphic parameter? If so, then mmorrow's example is what you want.
19:42:17 <shazam> Cale, yeah, that's exactly what I want
19:42:47 <mmorrow> shazam: you can also add some type-class constraints to the forall'ed `a' too if desired
19:43:36 <mmorrow> data Foo where Foo :: (forall a. (Num a) => a -> a) -> Foo;   x = Foo (+1) -- ok
19:44:41 <shazam> http://pastebin.org/37976 <--so this would be correct higher order abstract syntax?
19:45:20 <Saizan_> no
19:46:01 <Saizan_> the point is that you should apply Var to the value given to the lambda
19:46:17 <Saizan_> so Var should have a field with the same type
19:46:34 <shazam> Saizan_, hmm?
19:46:38 <Saizan_> and that means the quantification should be outside
19:47:41 <shazam> Saizan_, can you give me a concrete example?
19:47:48 <Saizan_> shazam: http://pastebin.org/37979
19:48:36 <shazam> why won't my example work?
19:49:11 <Saizan_> you won't be able to write e.g. Lam (\x -> Var x) in your example
19:49:15 <Sam___> I'm used to being able to trace out to a console is there any way to do this in haskell.  Sometimes recursion is counter-intuitive and I'd like to be able to see what's going on.
19:49:19 <Saizan_> which is the id function
19:49:32 <SamB_XP> @hoogle trace
19:49:32 <lambdabot> Debug.Trace trace :: String -> a -> a
19:49:33 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
19:49:33 <lambdabot> module Debug.Trace
19:49:41 <SamB_XP> Sam___: how's Debug.Trace?
19:49:49 <shazam> Saizan_, because (\x -> Var x) is not polymorphic?
19:49:51 <Sam___> thanks, i'll look at it :)
19:50:49 <shazam> Saizan_, oh, I see
19:51:03 <shazam> but we have Lam (\x -> x), no?
19:51:03 <Saizan_> shazam: 1) because your Var doesn't take a parameter 2) even if you add one there you won't be able to apply x to it
19:51:54 <Saizan_> no, that would complain that a /= Exp
19:52:07 <shazam> good point!
19:54:51 <ManateeLazyCat> Have any function that compare two UTCTime, then give microseonds between them?
19:55:26 <Saizan_> i guess you come from the corresponding LtU's thread? the code i pasted is the exact translation of the last formulation given by Bob Atkey in the comments
19:55:41 <shazam> http://pastebin.org/37986 <--so this is good type HOAS?
19:56:42 <Saizan_> shazam: why the 'a' parameter?
19:57:19 <shazam> it serves the same purpose as before
19:57:33 <Saizan_> but now you've two of them
19:57:57 <shazam> one is to keep things polymorphic
19:57:59 <Saizan_> and you're using the second parameter as we were using the old one
19:58:02 <shazam> the other one is to store the type
19:58:15 <Saizan_> oh, yeah, sorry
19:58:18 <Saizan_> got confused
19:58:44 <shemale_magic> can any haskell library help me FTP whole directories not just file by file, lftp is supposed to do thsi but does not work with akamai sofar for me, and I am wondering, why
19:58:46 <Saizan_> that works
19:58:55 <shemale_magic> lftp seems to want a random port over 50,000
19:59:00 <shemale_magic> but that seems insecure
19:59:02 <Saizan_> though i'm not sure if i'd use tuples
19:59:15 <shemale_magic> rsync far too slow over ssh
19:59:22 <shemale_magic> I wish rsync ran over ftp
19:59:27 <Saizan_> shazam: i'd make a :: * -> * and use (a b) instead of (a,b)
19:59:27 <shazam> Saizan_, what would you use?
19:59:35 <shazam> oh my
20:00:03 <Saizan_> so that the representation of the variables can depend on the type they have
20:00:43 <shazam> Saizan_, do you have a concrete example of what you just said?
20:02:29 <Saizan_> shazam: like this http://pastebin.org/37994
20:03:18 <Saizan_> and then you can use e.g. newtype Id a = Id a, when evaluating
20:03:34 <shazam> Saizan_, what are the advantages of this approach?
20:04:58 <Saizan_> shazam: it allows a more flexible representation of the variables when tranforming the term
20:05:34 <shazam> Saizan_, is there any term or function you can write which I can't?
20:06:57 <Saizan_> shazam: sometimes you might not have a 'b' value to pass in when you're tranforming the term
20:07:24 <Saizan_> i'd say that you'll have a 'b' only during evaluation
20:08:33 <shazam> example?
20:09:15 <Saizan_> prettyprinting the term
20:09:48 <joevandyk_> I'm confused on what a fold is
20:09:50 <shazam> so it would be easier to pretty print your terms?
20:09:56 <shazam> vs mine?
20:09:56 <Saizan_> shazam: yes
20:10:25 <shazam> because I would have to pass a tuple, correct?
20:10:42 <Saizan_> right, you'd have to pass a tuple with a 'b' member
20:11:00 <Saizan_> i guess you could use undefined to fill that, but it's not so nice
20:11:07 <Saizan_> also
20:11:33 <Saizan_> since that 'b' is not quantified the function is allowed to pattern match on it, allowing exotic terms
20:11:56 <shazam> data TExp' a b where <--did you mean data TExp' :: (* -> *) -> * where ... ?
20:12:15 <Saizan_> yeah
20:12:21 <Saizan_> it should work in both cases
20:12:31 <Saizan_> the latter needs KindSignatures tough
20:12:35 <jmcarthur> joevandyk_: you can think of a fold as "collapsing" a data structure into a value
20:12:41 <jmcarthur> :t maybe
20:12:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:12:45 <jmcarthur> ^^ a simple fold
20:12:49 <jmcarthur> :t foldr
20:12:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:12:57 <jmcarthur> ^^ a slightly more complex fold
20:13:16 <shazam> your TExp' type constructor sometimes takes two variables and sometimes one
20:13:38 <shazam> (like in Var)
20:13:50 <shazam> I think you want it to take one, no?
20:14:39 <Saizan_> ops sorry, typo
20:14:44 <Saizan_> no, it has to take two
20:15:08 <shazam> so you want TExp' :: (* -> *) -> * -> *, right?
20:15:13 <joevandyk> jmcarthur: Still confused
20:15:16 <Saizan_> shazam: yes
20:15:28 <Saizan_> http://pastebin.org/38019 <- revised
20:17:34 <shazam> seems weird
20:18:24 <Saizan_> well, that's how they do it in the PHOAS paper
20:19:03 <Saizan_> what seems weird?
20:19:20 <shazam> sometimes you're applying b to a
20:19:27 <shazam> and sometimes you're leaving it unapplied
20:19:33 <shazam> and instead applying b to TExp'
20:19:39 <shazam> what's the PHOAS paper?
20:21:06 <Saizan_> i apply 'a' to 'b'
20:21:23 <Saizan_> when i want to get the type of variables of type 'b'
20:21:29 <jmcarthur> joevandyk: mental exercise: what *is* a sum?
20:21:33 <Saizan_> otherwise i just keep 'a' along
20:21:43 <jmcarthur> joevandyk: more specifically, what is the sum of a list?
20:21:51 <Saizan_> shazam: http://adam.chlipala.net/papers/PhoasICFP08/
20:21:53 <jmcarthur> *of the elements of a list
20:22:48 <joevandyk> jmcarthur: Um. All the elements added?  Or first element plus the sum of the rest.
20:23:38 <shazam> yay for GADTs
20:23:50 <jmcarthur> joevandyk: that sounds good. how about if we wanted to generalize to operations besides just adding?
20:24:32 <Saizan_> joevandyk: you missed a case, what's the sum of an empty list?
20:24:37 <joevandyk> 0
20:24:43 <jmcarthur> Saizan_: (i was going to get to that) ;)
20:25:14 * Saizan_ will shut up
20:25:17 <Saizan_> :)
20:25:20 <jmcarthur> heh
20:25:53 <joevandyk> jmcarthur: I suppose you could by specifying a list, the operation to do on the list, and the result if list is empty?
20:26:09 <jmcarthur> joevandyk: that's a fold! :)
20:26:32 <jmcarthur> an example of one, to be precise
20:26:44 <joevandyk> An example?
20:27:00 <jmcarthur> joevandyk: there are folds for other structures besides lists
20:27:13 <jmcarthur> joevandyk: but for lists, that is really the fundamental fold
20:27:16 <jmcarthur> :t foldr
20:27:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:27:34 <jmcarthur> takes an operation, a base case and a list, returning the result
20:27:38 <joevandyk> jmcarthur: The idea is you have to iterate over it?
20:27:55 <joevandyk> Over whatever structure
20:27:58 <jmcarthur> joevandyk: the fold handles the recursion (not iteration ;) ) for you
20:28:02 <jmcarthur> yes
20:28:30 <jmcarthur> consider binary trees, for example
20:29:02 <jmcarthur> data Tree a = Empty | Branch (Tree a) a (Tree a)
20:29:13 <jmcarthur> say i wanted the sum of all the elements of that tree
20:29:20 <jmcarthur> what might it look like?
20:29:41 <jmcarthur> (assuming Num a, of course)
20:30:35 <joevandyk> Foldr takes a (function that takes a, b and returns b), a b, and a list of a, and returns b?
20:30:36 <ivanm> fold _ b Empty = b
20:31:02 <m3ga> is it really true that Network.HTTP does not do https?
20:31:13 <jmcarthur> joevandyk: yup
20:31:22 <joevandyk> Err, "a b" = "b"
20:31:28 <ivanm> fold f b (Branch l a r) = let b' = fold f b l in fold f (f a b') r
20:31:29 <jmcarthur> got that :)
20:31:50 <jmcarthur> ivanm: you're spoiling the thinking process! :P
20:31:54 <ivanm> heh
20:32:04 <ivanm> oh, sorry, I didn't realise you were thinking aloud ;-)
20:32:17 <ivanm> but realistically, look in Data.Tree ... >_>
20:32:32 <jmcarthur> ivanm: i am helping joevandyk understand folds
20:32:44 <ivanm> ahhh, sorry
20:32:48 <joevandyk> Hm, I don't get that code yet
20:32:50 <ivanm> I thought _you_ were asking!
20:32:53 <jmcarthur> heh
20:33:28 <jmcarthur> joevandyk: the foldr type or what ivanm was saying?
20:33:41 <ivanm> joevandyk: ignore what I was saying
20:33:42 <joevandyk> What he was saying
20:33:44 <joevandyk> Ha
20:33:47 <ivanm> I'm not even sure if it's right ;-)
20:33:47 <jmcarthur> joevandyk: don't worry about that yet ;)
20:34:12 <jmcarthur> joevandyk: i would rather focus on what a fold *is* than how to implement one, for now, as i think that is what you are really after
20:34:40 <jmcarthur> joevandyk: anyway... back to the question: what would be the sum of the elements of a tree defined as above?
20:34:50 <jmcarthur> you don't have to answer in code
20:35:41 <jmcarthur> for reference: data Tree a = Empty | Branch (Tree a) a (Tree a)
20:36:01 <joevandyk> Sum of left + current + sum of right, and 0 if leaf is empty
20:36:24 <jmcarthur> joevandyk: okay, and if you generalized that to arbitrary operations, not just addition?
20:36:35 <BMeph> ivanm: That's a strange, arbitrary-looking version of a tree fold. Why not fold both sub-trees, then feel those results, and the value, to the 'f' function? :)
20:36:50 <BMeph> Err, s/feel/feed/
20:37:36 <joevandyk> Would there be two functions?  One for processing trees and one for combining the result?
20:37:41 <mmorrow> there're four ways to fold (Tree a = Node a [Tree a])
20:38:00 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4238
20:38:20 <jmcarthur> joevandyk: there are multiple ways to fold, but you could do it with just one function
20:39:02 <mmorrow> jmcarthur: what do you mean by one function?
20:39:10 <Axman6> :t (||) . even
20:39:11 <lambdabot> forall a. (Integral a) => a -> Bool -> Bool
20:39:27 <jmcarthur> mmorrow: one function as a parameter to a theoretical fold combinator
20:39:46 <joevandyk> F(F(left), current, F(right))?
20:39:55 <joevandyk> Hm, no
20:40:01 <jmcarthur> you're close
20:40:06 <BMeph> I never liked that form for trees, even though it's very useful, not-to-mention classic. I feel as if it ought to have some fancier variant-name, like Streams.
20:40:11 <mmorrow> jmcarthur: oh, but there are different folding strategies
20:40:17 <jmcarthur> mmorrow: yes
20:40:34 <mmorrow> jmcarthur: list has two, tree has four, ..., combinatorial explosion for large types
20:40:39 <BMeph> That is, Stream is an example of a name, not like Streams particularly. :)
20:40:40 <jmcarthur> right
20:41:20 <jmcarthur> mmorrow: foldl can be defined in terms of foldr though
20:41:24 <copumpkin> BMeph: rose tree?
20:41:41 <Saizan_> mmorrow: the "fold" is usually intended to be the structural recursion one
20:41:54 <BMeph> copumpkin, Yeah, that one. :)
20:42:08 <copumpkin> BMeph: cofree comonad of [] ? :P
20:42:49 <Saizan_> copumpkin: the cofree comonad of the free monoid!
20:42:54 <copumpkin> zomg
20:43:04 <copumpkin> soon we'll have zygohistomorphisms
20:43:07 <BMeph> I like Saizan_'s one better. :)
20:43:13 <jmcarthur> joevandyk: i'm just gonna spoil it (slightly incorrectly) so i can go ahead and explain: f(fold f left, current, fold f right)
20:43:17 <mistermatt> woo, I got my copy of real world haskell
20:43:37 <BMeph> mistermatt: Grats!
20:43:38 <joevandyk> Hm
20:43:39 <jmcarthur> joevandyk: that's incorrect because there should also be a base case
20:43:41 <Saizan_>   @remember Wadler Data.Tree is just the cofree comonad of the free monoid
20:43:43 <mmorrow> jmcarthur: foldl in terms of foldr is useless though
20:43:58 <mistermatt> I'm actually excited to start reading it
20:44:12 <ezyang> A common thing that I find myself doing in programs I write is defining a custom Show and Read style typeclass
20:44:15 <mistermatt> which is a new thing with programming books
20:44:19 <mmorrow> as is church encoding for traversals that don't follow the structure of the type
20:44:41 <ezyang> This seems kind of poor, but since the semantics of Show/Read are meant to be for Haskell parseable typeclasses, I feel like this maintains more purity.
20:44:46 <ezyang> What do other people like to do?
20:44:49 <BMeph> Don't you "have" to define foldl in terms of foldr, since you're still dealing with (cons-style) lists, and not snoc-style ones? :)
20:45:07 <Saizan_> mmorrow: why foldl is useless if written in terms of foldr?
20:45:15 <mmorrow> BMeph: exactly. this is why ghc can't fuse foldl-type loops.
20:45:25 <copumpkin> Saizan_: it didn't stick cause you had a space
20:45:27 <BMeph> (Please, ignore the typical Lisper's defn of 'cons'; I do. ;)
20:45:39 <mmorrow> Saizan_: because it's inefficient
20:45:39 <Saizan_> copumpkin: that was on purpouse
20:45:42 <jmcarthur> joevandyk: but as you can maybe see now, a fold really just handles the recursion in whatever structure you are working with, resulting in a single value
20:45:42 <copumpkin> oh :)
20:45:58 <jmcarthur> joevandyk: that's really all i wanted to show. not get all pedantic like everybody else is ;)
20:46:27 <joevandyk> jmcarthur:  Yes, that makes sense. Thank you
20:46:51 <jmcarthur> np
20:47:29 <BMeph> So, is Foldable auto-deriveable?
20:47:43 <Saizan_> mmorrow: well, if ghc can't optimize higher order functions enough that's not my problem! it's asymtotically efficient
20:48:33 <Saizan_> BMeph: is toList derivable?
20:49:10 <Gracenotes> well.. if there is some form of a tree structure...
20:49:12 <Gracenotes> although even then there can be node-sharing, a la a dag
20:51:18 <Saizan_> you'll get an infinite list in that case
20:51:52 <mmorrow> Saizan_, jmcarthur: consider this, the Church and the Scott encodings of lists http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4286#a4286
20:52:20 <mmorrow> the Church encoding is fundamentally unable to express the traversal strategy that foldl uses, it can only use a foldr and pretend
20:53:19 <mmorrow> (because inductively folding over the data is built into Church)
20:54:46 <Saizan_> yeah, basically Church is structural recursion, while Scott is the primitive one
20:54:47 <mmorrow> (Church and Scott coincide on types like Bool/etc)
20:55:32 <mmorrow> Saizan_: Scott isn't typeable in System F either
20:55:39 <BMeph> mmorrow: Is there a 'snoc' using Scoot-lists? :)
20:56:10 <BMeph> Err, s/Scoot/Scott/
20:56:11 <mmorrow> BMeph: i'm not sure, but i do know that `pred' is O(n) with a church Nat, and is O(1) with scott Nat
20:57:07 <Saizan_> ah, you're worrying about foldl' though, not foldl
20:57:12 <mmorrow> this gives a nice overview/comparison of various data encodings http://www.cs.uiowa.edu/~astump/papers/archon.pdf
20:57:17 <mistermatt> so what kinds of things are you guys working on with haskell
20:57:36 <mmorrow> Saizan_: that's the only kind imo :)
20:58:37 <Saizan_> mmorrow: names are important for effective communication :)
20:58:40 <duaneb> anyone know latex well?
20:58:51 <mmorrow> Saizan_: names of what?
20:59:02 <jmcarthur> mistermatt: currently, shaders for the GPU
20:59:20 <mmorrow> Saizan_: those bangs don't change the fact that foldlC is just doing (\f -> foldr (flip f))
20:59:30 <mmorrow> (more or less)
20:59:50 <Saizan_> mmorrow: foldl vs. foldl'
21:00:10 <mistermatt> jmcarthur that sounds pretty cool actually
21:00:10 <mmorrow> Saizan_: ok sure, but that doesn't change my point
21:02:36 <Saizan_> mmorrow: try this: foldlC2 f !a xs = foldrC (\x g a -> let a' = (f a x) in a' `seq` g a') id xs a
21:03:23 <mmorrow> foldlC f a (C xs) = xs a (\x xs -> f xs x)
21:03:47 <Saizan_> mmorrow: with that change it doesn't overflow here
21:04:05 <mmorrow> Saizan_: that's cheating imo :)
21:04:18 <Saizan_> no, that's implementing it correctly :)
21:04:21 <mmorrow> heh
21:04:22 <jmcarthur> mistermatt: i'm not very familiar with shaders yet, so it's pretty cool to me too :)
21:04:38 <mmorrow> Saizan_: build/foldr still cannot handle foldl
21:05:02 <Saizan_> if you write foldl' out with explicit recusion and you mechanically translate you get that form
21:05:15 <mmorrow> for this exact reason, that church-encodings are only good at following the structural shape of the data you're folding over
21:05:22 <jmcarthur> i think i have the gist though
21:06:53 <Saizan_> i agree that church encodings have limitations in what they can express, though foldl' is easily definable
21:06:56 <mmorrow> Saizan_: perhaps, but i'm convinced that scott-encodings are the way to go wrt fusion. here's the scott encoding for TH's Exp type http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=112  :)
21:06:56 <Saizan_> ?src foldl'
21:06:56 <lambdabot> foldl' f a []     = a
21:06:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:07:08 <Saizan_> that's pure structural recursion
21:07:26 <Saizan_> mmorrow: that's an entirely different matter :)
21:07:53 <mmorrow> Saizan_: that's what i'm talking about all along :)
21:08:09 <Saizan_> mmorrow: again, say so from the beginning :)
21:09:06 <mmorrow> i kind did "<mmorrow> BMeph: exactly. this is why ghc can't fuse foldl-type loops." ;)
21:09:13 <mmorrow> s/kind/kinda/
21:09:54 <Saizan_> do you have a reference for that claim?
21:11:03 <mmorrow> Saizan_: one sec
21:13:42 <Saizan_> you guess you probably don't get tight loops if you define foldl' with foldr since you're building and partially applying functions
21:16:14 <mmorrow> Saizan_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4287#a4287
21:17:41 <Saizan_> mmorrow: oh, i know that foldr/build fusion doesn't handle foldl, i was curious about a description of the rationale though
21:18:03 <mmorrow> Saizan_: i'm trying to figure that out currently
21:18:24 <fnord123> @type <?>
21:18:26 <lambdabot> parse error on input `<?>'
21:18:33 <fnord123> @type (<?>)
21:18:34 <lambdabot> Not in scope: `<?>'
21:19:34 <mmorrow> Saizan_: err, the rationale for what exactly?
21:20:22 <kosmic> t: flip
21:20:28 <kosmic> :t flip
21:20:29 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:20:40 <kosmic> okay, what is that
21:21:04 <kosmic> how does `flip` get those abc's
21:21:54 <mmorrow> Saizan_: for build/foldr in particular, i believe it's because `build' is essentially just a Church-encoded list
21:22:08 <copumpkin> @src flip
21:22:09 <lambdabot> flip f x y = f y x
21:22:25 <copumpkin> kosmic: it takes a function of two arguments and gives you a function with those two arguments reversed
21:22:31 <Gracenotes> since (->) is right associative, this can also be phrased: (a -> b -> c) -> (b -> a -> c)
21:22:39 <ivanm> BMeph: eh, it was something I came up with off the top of my head
21:23:29 <copumpkin> mmorrow: where is this scott list stuff defined?
21:23:37 <kosmic> (a -> b ->c) -> (b -> a -> c)  but not (c -> a -> b)
21:23:42 <BMeph> ivanm: Then you better get out a laser level, 'cause your head looks lop-sided... ;p
21:23:51 <ivanm> heh
21:24:20 <mmorrow> copumpkin: there's a wikipedia page on scott encoding (church too), and this paper gives a good overview (linked to from the wikipedia page actually)  http://www.cs.uiowa.edu/~astump/papers/archon.pdf
21:24:50 <mmorrow> copumpkin: the programming lang SAPL also uses a scott encoding for datatypes (but doesn't call it that)
21:24:53 <copumpkin> ah
21:25:06 <Saizan_> mmorrow: i summarize "given that foldl' can be implemented on church encoded lists with the same stack behaviour, why foldr/build fusion doesn't cover it?"
21:25:40 <mmorrow> Saizan_: beats me
21:26:27 <Gracenotes> kosmic: in just (a -> b -> c) -> b -> a -> (some result), we have a function that accepts a and b, and we have an a and a b, so those can combine to make the result, a c. If we get a 'c' as an argument, we can't do anything with it
21:26:47 <mmorrow> Saizan_: you'd probably need to redefine every function that recurses in a foldl-like way (even if it's directly recursive) with foldr
21:27:23 <Saizan_> well, foldr/build fusion already covers only functions defined via combinators
21:27:38 <Saizan_> or for which there are RULEs that do that
21:27:45 <mmorrow> Saizan_: that's another thing, the fusion strategy i'm pursuing doesn't require any special functions or style of programming
21:27:48 <Gracenotes> mainly.. it's used so we don't have to give variable explicit names, but instead partially apply them
21:28:11 <kosmic> ok
21:29:07 <Gracenotes> in languages like Forth or Factor where there are (mostly) no explicit variables, the 'swap' word does something similar, putting everything in the right position to be applied
21:29:10 <mmorrow> and the general idea should work on arbitrary datatypes too
21:29:14 <mmorrow> not just list
21:29:57 <dolio> foldl f z l = foldr (\e h -> h . flip f e) id l z ==> foldl f z (build g) = foldr (\e h -> h . flip f e) id (build g) z = g (\e h -> h . flip f e) id z
21:30:26 * mmorrow plays with that
21:30:50 <Saizan_> add `seq` if you want foldl'
21:31:04 <mmorrow> dolio: does that also work with nested loops?
21:31:16 <dolio> That's just straight-forward foldr/build.
21:31:40 <mmorrow> dolio: i wonder why (sum [product [1..n] | n <- [1..m]]) is too much to handle then?
21:32:08 <dolio> To much for what to handle. It's not obvious that that's very well optimized to me.
21:32:12 <mmorrow> (64,257,039,256 byte alloc, 122562 collections collections, 18.62 seconds for m=40000)
21:32:38 <dolio> Does rewriting foldl to that definition give better performance under foldr/build?
21:32:40 <mmorrow> vs a nested register-only loop that takes 4.83 seconds
21:33:09 <mmorrow> dolio: that's what we're trying to figure out
21:33:30 <mmorrow> why is it precisely that foldr/build doesn't work for foldl
21:33:34 <dolio> foldls turning into higher-order code doesn't sound like a recipe for success.
21:33:50 <mmorrow> dolio: heh, that's possibly it
21:35:42 <mmorrow> dolio: (this is the (fsvo) optimal code for sum[prod|..] http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4287#a4287)
21:36:25 <dolio> I'm just going to try 'print (reverse [1..1000000])' first.
21:37:32 <mmorrow> what do you mean? that that's a special case because the list doesn't need to exist in the first place?
21:37:49 <mmorrow> (that := sum[prod|..])
21:38:14 <dolio> Well, I want to make sure it fuses at all, even in a simple case for one.
21:38:21 <mmorrow> (reverse [1..100000]) should also ideally optimize to  [1000000,1000000-1..1]
21:38:33 <dolio> Well, that isn't going to happen. :)
21:38:49 <mmorrow> dolio: not with rewrite rules
21:39:06 <dolio> Okay, that alternate foldl does generate a fold/build fusion.
21:40:31 <mmorrow> interesting
21:40:42 <dolio> Not appreciably faster, though, as far as I can tell.
21:40:53 <dolio> I'll try your sum/prod thing.
21:41:11 <dolio> Actually, I need to figure out how to do foldl' first I guess...
21:41:56 <mmorrow> if you just use Int, ghc should figure the strictness out
21:42:19 <dolio> I guess it's just foldr (\e g w -> g $! (f w e)) id l z
21:42:27 <dmead> > let A = [1,2,3]; B = [4,5,6] in map  (map (,) A) B
21:42:29 <lambdabot>   Not in scope: data constructor `A'Not in scope: data constructor `B'Not in ...
21:42:37 <Saizan> ooh, maybe i see why it can't handle nested loops, foldr .. (foldl .. (build ..)) = foldr .. (foldr .. (build) ..) = foldr f z (build a b c) which isn't of the form "foldr f z (build h w)"
21:42:42 <dmead> > let a = [1,2,3]; b = [4,5,6] in map  (map (,) a) b
21:42:44 <lambdabot>   Couldn't match expected type `a -> b'
21:42:44 <lambdabot>         against inferred type `[b1 ->...
21:43:12 <dmead> > (1,)
21:43:13 <lambdabot>   <no location info>: parse error on input `)'
21:43:18 <copumpkin> dmead: in 6.12 that will be possible :)
21:43:26 <copumpkin> including more complex ones
21:43:34 <dmead> yeas called contination passing style, right?
21:43:37 <copumpkin> (5,3,,2,,,,52,2)
21:43:39 <dmead> *yes thats
21:43:42 <copumpkin> nope
21:43:51 <Saizan> "map (map (,) a) b" still won't be possible
21:43:57 <copumpkin> Saizan: I meant the (1,)
21:44:02 <Saizan> yeah
21:44:03 <dmead> ah
21:44:20 <Saizan> assuming a and b are of type [Integer]
21:44:26 <dmead> lambdabot doesn't have 6.12 installed?
21:44:36 <copumpkin> dmead: CPS is when each function takes an additional argument, a function, and instead of "returning" a value, it simply calls that function (the continuation) with its return value
21:44:38 <Saizan> > zipWith (,) [1,2,3] [4,5,6]
21:44:39 <lambdabot>   [(1,4),(2,5),(3,6)]
21:44:39 <monochrom> > (,) True "True"
21:44:41 <lambdabot>   (True,"True")
21:44:45 <Saizan> > liftM2 (,) [1,2,3] [4,5,6]
21:44:46 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
21:45:12 <dmead> > let a = [1,2,3]; b = [4,5,6] in map  (map (+) a) b
21:45:13 <Makoryu> > liftM (*) [1..3] [4..6]
21:45:14 <lambdabot>   Couldn't match expected type `a -> b'
21:45:14 <lambdabot>         against inferred type `[a1 ->...
21:45:15 <lambdabot>   Couldn't match expected type `[t1] -> t'
21:45:15 <lambdabot>         against inferred type `[a1...
21:45:21 <dmead> uhh
21:45:24 <Makoryu> > liftM2 (*) [1..3] [4..6]
21:45:25 <lambdabot>   [4,5,6,8,10,12,12,15,18]
21:45:31 <dmead> i could have sword i got lambdabot to do this last week
21:45:35 <dmead> *sworn
21:45:56 <monochrom> You won't get map [f,g,h] [4,5,6] to work.
21:46:03 <Saizan> the type system didn't change during the last couple of weeks :)
21:46:09 <copumpkin> dmead: you need a $ or id in there
21:46:30 <copumpkin> to remind it to apply the function
21:46:36 <copumpkin> you can also use ap or <*>
21:46:48 <Saizan> and you need zipWith instead of map then
21:46:56 <dmead> wait a sec
21:47:01 <dmead> let me reboot to linux...
21:47:04 <copumpkin> :O
21:47:05 <Saizan> or <*> if you need the cartesian product
21:47:09 <copumpkin> virtual machines ftw
21:47:16 <monochrom> rebooting will change the type system?
21:47:34 <Makoryu> > zipWith ($) [f,g,h] [4,5,6]
21:47:35 <lambdabot>   Ambiguous type variable `b' in the constraints:
21:47:36 <lambdabot>    `SimpleReflect.FromExpr ...
21:47:40 <Makoryu> > zipWith ($) [f,g,h] [4,5,6] :: Expr
21:47:41 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
21:47:41 <lambdabot>         against inferred ...
21:47:46 * Makoryu shakes fist
21:47:58 <Makoryu> > zipWith ($) [f :: Expr,g,h] [4,5,6]
21:48:00 <lambdabot>   Couldn't match expected type `b -> b1'
21:48:00 <lambdabot>         against inferred type `Simpl...
21:48:01 <monochrom> [Expr]
21:48:04 <Saizan> > zipWith ($) [f,g,h] [4,5,6] :: [Expr]
21:48:05 <lambdabot>   [f 4,g 5,h 6]
21:48:17 <Gracenotes> \o/
21:48:22 <monochrom> Humans are really unsuitable for type systems.
21:48:29 <Saizan> > zipWith ($) [f :: Expr -> Expr,g,h] [4,5,6]
21:48:29 <lambdabot>   [f 4,g 5,h 6]
21:49:17 <copumpkin> I loved that quote on my self.programming post from yesterday
21:49:30 <Saizan> if we had explicit instantiation you could say something like zipWith ($) [f,g,h] [4,5,6] @ Expr
21:49:31 <dolio> mmorrow: Regular gogo: 1 fold/build, ~40 seconds, gogo': 3 fold/build, ~40 seconds.
21:49:45 <copumpkin> "if you need a statically typed language to check for errors you need to check your head."
21:49:53 <copumpkin> true men use untyped languages
21:50:05 <copumpkin> or at least, dynamic typing
21:51:29 <monochrom> You are correct. Extremely smart people need little aid.
21:51:35 <mmorrow> dolio: hrm
21:51:40 <Saizan> dolio: is the core for the latter readable?
21:51:51 <sproingie> real men write in forth
21:51:51 <Makoryu> copumpkin: I always keep one on standby for late at night when I can't think clearly about type systems
21:52:01 <monochrom> Therefore everyone who *wants* to be extremely smart people (but isn't one yet) should use little aid!
21:52:08 <copumpkin> lol
21:52:18 <sproingie> when i hear the words "unit test" i reach for my revolver
21:52:28 <monochrom> You're looking at a whole bunch of true-men-wannabes.
21:52:49 <Gracenotes> yeah, them sissie communist static type pinkos
21:52:54 <mmorrow> dolio: could you paste gogo'/what you modified?
21:53:11 <sproingie> naw, static type folks are fascists
21:53:14 <Gracenotes> thinking they're so tough because they don't have to mention types explicitly
21:53:17 <dolio> Saizan: Eh, I've seen worse.
21:53:31 <Makoryu> TRUE MEN ARE TOUGH ENOUGH TO BRUSH OFF ANY NUMBER OF SEGFAULTS
21:53:50 <Gracenotes> sproingie: o-o I actually have heard a professor call Haskell a fascist language
21:54:00 <Gracenotes> well, jokingly, in private conversation
21:54:06 <copumpkin> Gracenotes: it is!
21:54:18 <copumpkin> and we take it and we like it
21:54:21 <sproingie> Gracenotes: "bondage and discipline" gets tossed around a lot wrt haskell
21:54:21 <monochrom> Here is another one for you. shapr is a great programmers and shapr did not take CS courses. Therefore you should take no CS courses, too.
21:54:32 <Gracenotes> Makoryu: real men ignore segmentation boundaries and deal with the data they're given
21:54:36 <copumpkin> monochrom: flawless logic that
21:54:57 <EnglishGent> morning :)
21:55:03 <ivanm> sproingie: it does? never heard to it referred to that before...
21:55:17 <copumpkin> ivanm: you need to come to #haskell-s&m
21:55:18 <monochrom> I forgot what shapr studied at school, but someone will eventually conclude something like "the best way to learn Haskell is to pick up English Literature, that's what shapr did" or something.
21:55:21 <blackdog> Gracenotes: we need a locomotive routing package in haskell
21:55:23 <Makoryu> ivanm: Really?
21:55:27 <ivanm> @slap copumpkin
21:55:28 <lambdabot> stop telling me what to do
21:55:30 <blackdog> then we can say that haskell  makes the trains run on time...
21:55:34 * copumpkin hugs lambdabot
21:55:37 <ivanm> Makoryu: ya rly
21:55:44 <copumpkin> orly?
21:55:50 <sproingie> taitz?
21:56:00 <ivanm> copumpkin: you've changed the code to never let lambdabot slap you, didn't you...
21:56:04 <copumpkin> yep
21:56:07 * copumpkin iz l33t hax0r
21:56:16 <Makoryu> ivanm: One of the first things I heard about Haskell was that it had an egregiously restrictive type system. Of course, it's not even as restrictive as Ada's, but that was the reputation it had at the time.
21:56:45 <sproingie> it's not so much restrictive in what you can do as in how you say it
21:57:00 <ivanm> the first thing I heard about Haskell was that if I liked the first year scheme subject then I'd probably like Haskell...
21:58:27 <Makoryu> ivanm: Yeah, when I finally got around to learning it, it struck me as "like Scheme, but more so"
21:58:56 <Gracenotes> ultrascheme
21:59:08 <sproingie> doesnt seem very schemy to me.  static types, no macros
21:59:18 <Gracenotes> <display comparison of sheets cleaned with scheme and ultascheme>
21:59:28 <Gracenotes> 10x purer results
21:59:40 <sproingie> i learned a little ml before haskell so the obvious similarity struck me
21:59:57 <Makoryu> sproingie: Scheme was too much a Lisp to be any good as a Scheme.
22:00:21 <monochrom> Disbelieve in every statement "x is like y" where x,y are distinct.
22:00:25 <ivanm> Makoryu: wtf?
22:00:40 <sproingie> it is still a lisp
22:00:45 <Makoryu> ivanm: ....I'm really not making any sense tonight
22:00:46 <jargonjustin> Is there a function which will properly escape a string for using a regular expression? I'm using the Posix flavor as it ships with the Haskell Platform, but wouldn't mind using another if it's a small dependency.
22:00:54 <Makoryu> Ignore everything I said
22:00:57 <jargonjustin> s/using/use in/
22:00:57 <Makoryu> Everyone
22:01:12 <Makoryu> I have to go feed some more pancakes to my basement
22:01:13 <copumpkin> Makoryu: don't worry, we already do
22:01:13 <dolio> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4287#a4288
22:01:14 <ivanm> jargonjustin: not sure if it's what you want, but there's pcre-light as another regex lib
22:01:20 <Gracenotes> monochrom: well.. subset maybe..
22:01:24 <ivanm> and the other regex-* libraries
22:01:37 <jargonjustin> ivanm, I'm looking for a small regex implementation with an escape function.
22:01:38 <dmead> lalala
22:02:08 <dolio> Oh crap, I used regular map in the stream fusion.
22:02:19 * mmorrow finds his copy of the stream fusion paper to remember what the problem was with concatMap
22:02:21 <ivanm> jargonjustin: no idea what you mean by an escape function
22:02:34 <ivanm> mmorrow: isn't it that it uses lists? :p
22:02:35 <dmead> ah ah
22:02:46 <jargonjustin> ivanm, given a string, return a regular expression which matches exactly that string literal (escapes regular expression special characters)
22:02:53 <dmead> :t (,)
22:02:54 <lambdabot> forall a b. a -> b -> (a, b)
22:03:16 <mmorrow> ivanm: :)
22:03:19 <ivanm> jargonjustin: no idea, sorry
22:03:20 <dmead> > map (\x -> map (x+) [1,2,3]) [4,5,6]
22:03:22 <lambdabot>   [[5,6,7],[6,7,8],[7,8,9]]
22:03:31 <dmead> > map (\x -> map (x,) [1,2,3]) [4,5,6]
22:03:32 <ivanm> jargonjustin: it kinda depends on the regex implementation
22:03:33 <lambdabot>   <no location info>: parse error on input `)'
22:03:35 <dmead> fail
22:03:38 <ivanm> jargonjustin: parsing libraries, however...
22:03:46 <dolio> It doesn't matter, apparently, though.
22:03:57 <dmead> copumpkin, thats the code i had in mind :P
22:04:28 <copumpkin> dmead: aha, in 6.12 then
22:04:46 <dmead> because , is overloaded?
22:04:50 <dolio> mmorrow: Okay, here we go. Stream fusion: 2.4 seconds.
22:04:52 <monochrom> (5,) 6 would have been a direct example.
22:04:55 <Gracenotes> map (flip map [1,2,3] . (,)) [4,5,6]
22:05:13 <dmead> Gracenotes, >
22:05:25 <dmead> ?src flip
22:05:25 <mmorrow> dolio: oh, i left out the concatMap in my version for simplicity (it would get handled), i think ghc will turn that into  S.sum . concatMap (\n -> [S.product (enumFromTo' 1 n)]) $ enumFromTo' 1 mb
22:05:26 <lambdabot> flip f x y = f y x
22:05:32 <Gracenotes> yeah.. I was just saying, that's all
22:05:42 <mmorrow> dolio: but interesting. still looking for my stream-fusion printout..
22:05:48 <dmead> copumpkin, you can partially apply (,) in 6.12?
22:06:03 <Gracenotes> tuple sections are supposed to come in the next big version of GHC....
22:06:18 <dolio> mmorrow: You need to INLINE enumFromTo' for some reason.
22:07:13 <copumpkin> dmead: yep, any size tuple
22:07:22 <dmead> seems odd we'd have access to , but not be able to partially use it
22:07:46 <hackagebot> nemesis 2009.10.7 - a Rake like task management tool (JinjingWang)
22:07:47 <Gracenotes> hm. any function, including constructors
22:07:47 <dmead> > map (\x -> map (+) [1,2,3]) [4,5,6]
22:07:49 <lambdabot>   [[{-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4},{-3->-1;-2->0;-1->1;0->2;1->3;2...
22:08:01 <dmead> yow
22:08:37 <Gracenotes> huh
22:08:43 <mmorrow> dolio: oh hmm, i came across that same thing actually (w/ an older version of the stream fusion code, haven't tried with the newer yet), where if enumFromTo isn't in the same module and doesn't have INLINE, something asplodes and it consumes all your mem
22:08:44 <dolio> mmorrow: Nested concatMaps are the problem with stream fusion, as I recall. And that's what list comprehensions get you, mostly.
22:09:04 <copumpkin> does foldr/build deal with them better?
22:09:09 <dolio> Yes.
22:09:28 <dolio> That was a big sticking point for GHC switching.
22:09:32 <copumpkin> ah
22:09:49 <copumpkin> it's rather unclear on the ticket now what the blocker is
22:10:08 <copumpkin> there's a mention near the end of whatever blockage being cleared, but it's been in that state for a while now
22:10:37 <Saizan> dmead: do you realize that map (map (,) [1,2,3]) [4,5,6] is illtyped?
22:10:46 <dmead> i do
22:10:50 <Saizan> ?type (,)
22:10:51 <lambdabot> forall a b. a -> b -> (a, b)
22:11:16 <Saizan> and it's not because (,) is special syntactically
22:11:37 <dolio> mmorrow: Yeah, with concatMap the code isn't as good.
22:11:46 <dmead> why is it, specifically?
22:11:58 <dmead> i would think (1,) would be able to be typechecked
22:12:23 <Gracenotes> map (1,) [4,5,6] <- that works
22:12:51 <Gracenotes> (well, if we had tuple sections; in the current GHC, it's \x -> (1, x))
22:12:59 <monochrom> map [(1+), (2+), (3+)] [4,5,6] makes no sense, as I said. I don't even know what its semantics is supposed to be. Do you?
22:13:01 <Saizan> dmead: it is because "map (,) [1,2,3] :: [b -> (Integer,b)]" while the first argument to map has to be a function
22:13:08 <dmead> >  map (1,) [3,4,5]
22:13:10 <lambdabot>   <no location info>: parse error on input `)'
22:13:31 <copumpkin> > map (,) [1..3] <*> [4..6]
22:13:31 <dmead> Saizan, ah
22:13:32 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:13:53 <dmead> whats <*>?
22:14:01 <Gracenotes> a single function works, but a list of functions as the mapping item... sort of outside the scope..
22:14:05 <Saizan> a list of functions is not a function :)
22:14:19 <dmead> oh right
22:14:24 <dmead> yea i was just wrong
22:14:36 <Gracenotes> > zipWith (\f x -> f x) (map (,) [1,2,3]) [100, 200, 300]
22:14:37 <lambdabot>   [(1,100),(2,200),(3,300)]
22:15:41 <dmead> > map (\x -> map (x,) [1,2,3]) [4,5,6]
22:15:42 <lambdabot>   <no location info>: parse error on input `)'
22:15:51 <jargonjustin> > zipWith ($) (map (,) [1,2,3]) [100, 200, 300]
22:15:53 <lambdabot>   [(1,100),(2,200),(3,300)]
22:16:13 <Gracenotes> sorry to confuse you, but (x,) isn't valid notation :/ yet, anyway
22:16:17 <dmead> yea
22:16:22 <dmead> thats what i was going for
22:16:25 <dmead> oh well
22:16:33 <copumpkin> it will be in a few days
22:16:39 <copumpkin> or whenever it is that 6.12 RC is being released
22:16:59 <Gracenotes> (x,) -> (,) x ... (,x) -> flip (,) x
22:18:34 <monochrom> You could have just tested (5,)6 and be unambiguously conclusive and save a lot of self-confusion. This is why programmers can't write test cases, they write obfuscated test cases that breaks for a million potential reasons and completely uninformative.
22:19:12 <dmead> hehe
22:20:00 <Gracenotes> the only way is to enumerable all possible outputs. they don't call Haskell recursively enumerable for nothin'!
22:20:58 <copumpkin> lol
22:26:34 <dmead> ?type <*>
22:26:36 <lambdabot> parse error on input `<*>'
22:26:49 <copumpkin> need moar parens
22:27:00 <dmead> ?type (<*>)
22:27:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:27:26 <dmead> whats that operator called?
22:27:36 <copumpkin> YO DAWG, I HEARD U LIKE FUNCT*S SO I PUT A FUNCTION IN UR FUNCTOR SO YOU CAN APPLY WHILE YOU FUNCT
22:27:48 <dmead> laff
22:28:07 <copumpkin> dmead: I call it <*>
22:28:08 <copumpkin> ;)
22:28:11 <dmead> YO DAWG I HEARD YOU LIKE TYPES, SO I PUT A TYPE IN YOUR TYPE SO YOU CAN PROGRAM WHILE YOU P ROGRAM
22:29:01 <unknownmat> / ?
22:29:35 <copumpkin> yo dmead, I know ur copying my memes and imma let u finish but... mine was the best meme of all time. of all time!
22:32:06 <monochrom> You scared solidsnack so much he quitted twice.
22:33:03 <fnord123> ?type (<?>)
22:33:04 <lambdabot> Not in scope: `<?>'
22:33:11 <fnord123> whyyyyyyyyy
22:33:18 <copumpkin> monochrom: yeah, but I attracted FunctorSalad in return
22:33:36 <FunctorSalad> :)
22:36:54 <dmead> hey doods
22:37:03 <dmead> i have another question i've never been real clear on
22:37:10 <dmead> when you see a type definition
22:37:20 <copumpkin> ok
22:37:24 <dmead> such as applicative f  up above
22:37:26 <monochrom> (What is a type definition?)
22:37:29 <dmead> ?type (<*>)
22:37:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:37:49 <dmead> what does (Applicative f ) => .... mean?
22:37:58 <copumpkin> it's a class constraint
22:38:00 <dmead> it's restricting the type of f right?
22:38:00 <monochrom> typeclass assumption
22:38:02 <dmead> ah
22:38:07 <dmead> alrighty then
22:38:14 <copumpkin> it's saying that it works for anything that is an instance of f
22:38:28 <dmead> gotcha
22:38:32 <copumpkin> without it, it would have to work for anything at all (that is of kind * -> *)
22:38:45 <dmead> war
22:38:47 <copumpkin> I meant an instance of Applicative, not f
22:38:48 <dmead> yar
22:38:54 <copumpkin> so bellicose
22:38:54 <dmead> so say you have a function foo
22:39:05 <dmead> and you want to add it to the typeclass Applicative
22:39:09 <dmead> whats the syntax?
22:39:24 <copumpkin> instance Applicative ((->) a) where ...
22:39:40 <copumpkin> you wouldn't do it to foo
22:39:43 <copumpkin> you'd do it to the function type
22:39:47 <dmead> ah
22:40:06 <copumpkin> types (and type constructors) are instances, not values
22:40:07 <dmead> typeclasses are classes of types
22:40:11 <copumpkin> yep
22:40:22 <dmead> in the logica sense, not the object sense
22:40:28 <copumpkin> so Maybe is an instance of Applicative
22:40:40 <copumpkin> Just x and Nothing are not (they're just values of Maybe a)
22:40:56 <copumpkin> also note that Maybe is the Applicative instance, not Maybe a
22:41:28 <dmead> ?src Maybe
22:41:29 <lambdabot> data Maybe a = Nothing | Just a
22:41:53 <dmead> an applicative type takes a variable like that, yea?
22:42:04 <copumpkin> yeah
22:42:08 <copumpkin> it needs something of kind * -> *
22:42:14 <copumpkin> (just like Functor and Monad)
22:42:27 <copumpkin> things like Num on the other hand want something of kind *
22:42:30 <dmead> which can be functions or types?
22:42:38 <monochrom> It was written "instance Applicative Maybe where ...", not "instance Applicative (Maybe a) where ...".
22:42:49 <copumpkin> they must be type constructors
22:43:00 <dmead> ah
22:43:13 <copumpkin> dmead: and the (value-level) function arrow happens to be a type constructor
22:43:54 <dmead> ah
22:43:56 <dmead> i didn't know that
22:44:10 <copumpkin> that's how I can define the applicative instance above
22:44:17 <dmead> ?type (->)
22:44:17 <copumpkin> ((->) a) === a ->
22:44:19 <lambdabot> parse error on input `->'
22:44:27 <copumpkin> :k (->)
22:44:29 <lambdabot> ?? -> ? -> *
22:44:46 <copumpkin> :k Either
22:44:47 <lambdabot> * -> * -> *
22:44:53 <dmead> if it's a type constructor, why can't i ask about it's type?
22:44:55 <copumpkin> :k (->) :: * -> * -> *
22:44:57 <lambdabot> parse error on input `::'
22:44:59 <copumpkin> boo
22:45:07 <copumpkin> dmead: type constructors don't have a type, they have a kind
22:45:12 <copumpkin> which is a "type of types"
22:45:24 <copumpkin> that's what the :k command is doing
22:45:47 <dmead> thats the difference between kinds and types?
22:46:01 <copumpkin> types contain values, and kinds contain types
22:46:01 <dmead> by kinds, we mean kinds of types
22:46:05 <dmead> ah
22:46:23 <dmead> right
22:46:33 <dmead> cause types are sets of actual objects or values
22:46:58 <dmead> or what do you call them ?
22:46:59 <dmead> fields?
22:47:02 <dmead> i haven't had AA yet
22:47:15 <dmead> or am i wrong to think that
22:47:15 <monochrom> AA won't help.
22:47:21 <dmead> :<
22:47:32 <dolio> First admit that you have a problem.
22:47:42 <dmead> do you mean alcoholics anonymous or abstract algebra
22:47:50 <dmead> cause i have 2 empty cans of guiness on my desk
22:47:51 <monochrom> sets of values is good enough
22:47:52 <dmead> also haskell
22:47:52 <copumpkin> lol
22:47:59 <dmead> so i think i have a problem
22:48:25 <dmead> anyway
22:48:25 <Gracenotes> mm... types can't be partially applied. without some extra declarations :/
22:48:40 <dmead> i'm trying to brush up for to give a haskell demo in january
22:48:58 <dmead> Gracenotes, true
22:48:59 <copumpkin> you'll be fine by then!
22:49:03 <mistermatthew> dmead, did I see you on reddit?
22:49:08 <dmead> you did
22:49:14 <mistermatthew> nice
22:49:32 * Gracenotes sticks on the "Seen on Reddit" sticker
22:49:41 <dmead> =p
22:50:41 <mistermatthew> what's more random was that I didn't check the username of the post on reddit
22:51:09 <dmead> yea
22:51:17 <dmead> i think one of the guys that ran hack-phi is gonna present some code too
22:52:06 <mistermatthew> I don't know anything about haskell, but I wish you much luck
22:52:28 <Axman6> mistermatthew: you should learn ;)
22:52:43 <mistermatthew> that's why I'm here :)
22:54:35 <mistermatthew> I don't have any experience with functional languages at all though. Just OOP w/ java and C++
23:03:21 <EnglishGent> it takes a while to get used to the differences mistermatthew - but this channel is very friendly and helpful :)
23:03:26 * EnglishGent something of a newbie himself :)
23:03:50 <mistermatthew> that's another thing that drew me towards haskell - I've heard haskell fans were extra helpful kinds of folks
23:04:20 <mistermatthew> very unlike, say, #C++
23:05:03 <EnglishGent> never been to #C++ so cant comment
23:07:08 <Axman6> mistermatthew: the haskell community is probably the language's best asset
23:07:41 <Axman6> mistermatthew: so, go read lyah, and ask ask ask!
23:07:43 <Axman6> @where lyah
23:07:43 <lambdabot> www.learnyouahaskell.com
23:07:48 <Axman6> mistermatthew: ^^^^^^^^^
23:08:02 <mistermatthew> :D
23:08:31 <mistermatthew> I've also gotten my hands on a copy of real world haskell, so I'm looking forward to getting into that as well
23:08:44 <Axman6> i'd recommend lyah before RWH
23:09:27 <Veinor> I didn't like LYAH.
23:10:23 <mistermatthew> I've gotten to the end of the types section in LYAH, but I'm going to go through it again
23:11:09 <dolio> The Gentle Introduction is the only way to learn!
23:11:28 <Axman6> mistermatthew: if you have questions, be sure to ask them here, ok?
23:11:34 <mistermatthew> of course
23:11:35 * copumpkin learned with #haskell only
23:11:41 <ivanm> dolio: heh
23:11:42 * copumpkin abuses the channel
23:11:47 * Axman6 learned through uni
23:11:56 <ivanm> copumpkin: oh, does my newest version of SourceGraph have enough awesome for you? :p
23:12:08 <copumpkin> ivanm: I'm sure it needs moar
23:12:12 * ivanm learnt Haskell by converting Bird and Hutton's Sudoku solver into a Latin Square generator
23:12:15 <copumpkin> ivanm: but I'll evaluate it with my monocle later
23:12:15 <ivanm> copumpkin: heh
23:12:23 <copumpkin> it may have enough!
23:12:42 <copumpkin> oh wait, before I evaluate it with my monocle, I need to grow a goatee
23:14:10 <Saizan> copumpkin: you take code review quite seriously, sir
23:14:15 <mistermatthew> don't forget wax for your moustache
23:19:22 <gwern> has anyone heard of a technique for webpages where if the user highlights/copy-pastes some displayed text, what he actually gets is some transformed or related text? eg I'm thinking the displayed text (code) could have pretty lambda unicodes, but when moused, gives you normal \a -> stuff
23:19:56 <ivanm> copumpkin: heh
23:20:12 <ivanm> gwern: probably possible
23:20:14 <Gracenotes> when moused?
23:20:16 <Gracenotes> sounds dirty
23:20:18 <gwern> monocles are great. for how can one crush the proletariat if one cannot see them?
23:20:18 <EnglishGent> not heard of that for webpages gwern - the closest I can think of is preview-latex mode for emacs
23:20:23 <ivanm> but it's usually a PITA when websites do that kind of thing
23:20:26 <gwern> Gracenotes: hey, if you know a better expression...
23:20:30 <gwern> ivanm: my cause is just!
23:20:37 <ivanm> _sure_ it is
23:20:52 <gwern> ivanm: I'm suggesting to john that gitit unicodify haskell expressions, but he's concerned about people copy-pasting broken stuff
23:21:08 <ivanm> I agree
23:21:14 <ivanm> and think it's a bad idea
23:21:18 <Gracenotes> I'm not sure there's any way around the problem
23:21:27 <gwern> I could spend a few years hacking ghc and lobbying the haskell community to make the unicode chars as acceptable as the ascii longform, but fixing it in the browser seems faster
23:21:33 <gwern> more powerful, more seductive...
23:21:37 <ivanm> gwern: look at how many complaints there were about graham hutton's book with all the symbols...
23:21:43 * gwern draws on the anger
23:21:50 <Gracenotes> I think requiring JavaScript might be out of the question.
23:22:12 <gwern> ivanm: well, that's justified as people had to copy it by hand and might not not the ascii equivalent
23:22:32 <Gracenotes> unless, of course, you start with the original text and transform it, un-transforming after complicated selection/range business which is different in various browsers
23:22:38 <gwern> I'm basically asking whether there's some way to automate it, to make it so the viewer can't wind up accidentally with the unicodified version
23:22:48 <ivanm> gwern: yes, but people see all this weird code full of symbols and might be turned off by it
23:23:08 <gwern> ivanm: assuming they're not turned off by the syntax highlighting first...
23:23:17 <ivanm> gwern: make the display unicode but the underlying stuff explicitly correct?
23:23:20 <ivanm> gwern: heh
23:23:32 <gwern> ivanm: yeah. it'd be kind of like emacs that way using pretty lambda
23:23:39 <Gracenotes> maybe a "prettify/unprettify" button
23:23:48 <ivanm> Gracenotes: that would be a better solution IMHO
23:24:00 <gwern> on disk it's ascii, when you copy-paste it's ascii, etc - it's only unicode in appearance
23:24:08 <EnglishGent> surely not ivanm? the world loved apl!
23:24:10 <EnglishGent> :D
23:24:35 <gwern> (although you can thwart prettylambda and get unicode by running inside a terminal and using the mouse, bwahaha)
23:24:36 <ivanm> EnglishGent: right, that's why it's the most popular programming language today...
23:24:38 <Gracenotes> with the default state unprettified. this possibly set by cookie, so one doesn't have to prettify each page, it carries
23:24:42 * EnglishGent blames the keyboard manufactures for not putting enough mathsy symbols on the keycaps :|
23:24:58 <ivanm> EnglishGent: yes, I want my keyboard - especially on my small laptop - to be twice the size
23:25:00 <Gracenotes> personally I just find the psuedo-unicode much readable, by practice :)
23:25:14 <ivanm> EnglishGent: the other alternative would be to use something like that keyboard that used OLEDs for each key...
23:25:28 <gwern> Gracenotes: cookiees and toggles sound horrible
23:25:32 <EnglishGent> ivanm - great - but very expensive
23:25:32 <gwern> even I wouldn't use that
23:25:53 <Gracenotes> gwern: if it's relatively innocuous to the user, I don't see the problem
23:26:14 <Gracenotes> I'm sure you know wikis have ways of configuring how text is rendered to the user. make it a preference then o_o
23:26:24 <EnglishGent> a keyboard combined with a small horizontal touch-sensitive display is probably what you want (the latter allowing unbounded flexibility for rarely used stuff)
23:26:39 <gwern> Gracenotes: yeah, but gitit plugins & prefs are a ghetto
23:26:47 <gwern> if I want it to be useful, default's the way to go
23:26:57 <gwern> also, it's a good bullet point for the release
23:27:27 <ivanm> I wonder if the "debugging" approach described at the end here would work with Haskell software... :p http://lwn.net/SubscriberLink/354408/4b4c2fce98e785ad/
23:27:38 <Gracenotes> then, default prettified.
23:27:55 <Gracenotes> unprettifiable.
23:28:11 <Gracenotes> I don't see a nice way of doing this :/
23:28:46 <gwern> Gracenotes: no dice. the raw source is available via a link, which is as much effort to click as your toggle; but just raw being available isn't acceptable, I think, so by transivity...
23:29:27 <jfredett> @type uncurry (,)
23:29:28 <lambdabot> forall a b. (a, b) -> (a, b)
23:29:32 <jfredett> ...
23:29:43 <jfredett> awesome.
23:29:50 <ivanm> jfredett: I'm happy to provide amusement to you...
23:29:51 <Gracenotes> source code on separate pages? not so great for people like me who go offline constantly
23:30:08 <Gracenotes> (well, modulo local installations)
23:31:03 <jfredett> ivanm: hehe, when I get to nearish-done with HWN2, I'm going to write up a scoreboard thing to go into the weekly news. It'll be retroactive (assuming hackage has data back to the beginning) and it'll auto post the top 5 contributers for the week and year, or something.
23:31:41 <gwern> Gracenotes: well, that's how you get the raw file, not the file surrounded by the css etc
23:31:42 <ivanm> jfredett: there's a log of every submission to hackage
23:32:04 <dmead> hey guys
23:32:13 <dmead> is CPS style actually useful for anything
23:32:25 <jfredett> ivanm: right, I saw that, and between your Erdosian proflicity and my stumbling on that, I decided it would be a good idea
23:32:28 <dmead> i'm looking around and i don't really see a good use for it
23:32:35 <Gracenotes> css doesn't matter so much copying it to a text editor. I am not using wget to browse the internet, after all :o
23:32:37 <jfredett> dmead: I hear it is, but the reasons are beyond me.
23:33:05 <jfredett> dmead: I think it has something to do with performance, I'm a mathematician, I am not concerned with such things...
23:33:08 <jfredett> :)
23:33:14 <gwern> dmead: compilers? web servers? curious logics?
23:33:18 <dmead> that could be
23:33:45 <fnord123> dmead: yes. it's useful for some things, but not for APIs
23:34:39 <Saizan> jfredett: Cont Void is an embedding of classical logic into the intuitionistic one
23:34:47 <fnord123> dmead: it's very good for generated code which is why it's such a feature in scheme code. macros that expand to CPS is somewhat common, but it's generally not used afaik for end user apis.
23:34:50 <Gracenotes> laziness subsumes much of the reason why one would use CPS in a language like LISP
23:34:53 <Saizan> jfredett: that should be more mathematical :)
23:35:25 <Gracenotes> laziness tends to be more.. built-in though
23:35:26 <dmead> perhaps
23:35:32 <jfredett> Saizan: oh, suddenly I'm interested. :)
23:35:38 <dmead> i just think it's odd to want to carry around the current state in stateless programming
23:35:50 <dmead> i suppose you could get more performance
23:35:55 <gwern> dmead: maybe you want to fork off several copies of yourself
23:36:03 <Saizan> ?djinn-add type C a = Not (Not a)
23:36:08 <gwern> or just partial/delimited continuations
23:36:25 <Saizan> ?djinn C (Either a (Not a))
23:36:25 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
23:36:27 <gwern> oleg will be happy to explain how all your problems are actually delimited continuation problems in disguise
23:36:35 <dolio> jfredett: By the way, the problem with your code is that in "Foo a b => a -> a" or whatever, b is ambiguous, and there's no way to specify it, so there's no way for a function with such type to be called.
23:36:45 <Gracenotes> yeah, and the fact that state <-> CPS...
23:36:55 <Saizan> jfredett: excluded middle for you :) and you get callCC by the proof of Pierce's law
23:37:14 <dmead> gwern, i suppose, i'm just having trouble looking for some example code that is very clear
23:37:15 <jfredett> dolio: OH! that makes sense...
23:37:29 <dolio> jfredett: It pops up on haskell-cafe every once in a while, but I'm too lazy to go look for old threads. :)
23:37:33 <jfredett> so I need to somehow force `b` to get called somewhere...
23:37:34 <gwern> dmead: if you find some, tell me. I've never really understood continuations
23:37:41 <gwern> not that I tried very hard, but still
23:37:44 <fnord123> dmead, essentials of programming languages has some chapters on it that explore the topic very well
23:37:49 * gwern always figured, after I finish sicp
23:37:53 <dmead> gwern, yea it seems to defy the idea of stateless code
23:38:18 <jfredett> dolio: The punchline is that the idea isn't impossible though, just being a little touchy... :)
23:38:20 <gwern> well, passing some state around makes perfect sense, it's the obvious way to make pure code work with IO
23:38:20 <fnord123> shu-thing uses CPS
23:38:36 <gwern> but reifying your surrounding state is a little weirder
23:38:47 <gwern> fnord123: what, you think I studied shu-thing's code carefully? :)
23:38:48 <Gracenotes> I don't think I'll learn CPS, except perhaps incidentally
23:39:09 <dolio> jfredett: Yeah, you either need dummy arguments to get b in the actual type (not the context) or (the equivalent of) fundeps a -> b.
23:39:11 <fnord123> gwern: no. i did. i extended it and promised to send you my extension like 2 years ago
23:39:17 <gwern> you did?
23:39:18 <fnord123> and was too lazy to clean it up :(
23:39:28 <gwern> how did you extend it?
23:39:54 <fnord123> yeah i made a version like geometry wars where mouse determines direction and clicking fires. wasd or arrow keys moved
23:39:55 <jfredett> dolio: but if I use fundeps, wouldn't that mean I couldn't have multiple instances, eg Hom (Maybe a) (CouldBe a) and Hom (Maybe a) (Mightbe a) ?
23:40:15 <gwern> fnord123: not a bad idea. you ought to ressurect it
23:40:17 <ski> Gracenotes : "state <-> CPS" ?
23:40:25 <jfredett> maybe I'm not understanding fundeps... *goes to read about them.
23:40:33 <dolio> jfredett: Although I thought the types you were ending up with were kind of weird. Since I expected the types to be like "Related a b => a -> b -> Bool", where the associated type 'Rel a b' or whatever was the common representation.
23:41:48 <FunctorSalad> oh no multirec doesn't support types of kind (* -> *) does it?
23:42:07 <jfredett> right, I have Hom a b, and hm lifts to the representation, im draws it out the other side, mostly I don't know what my types should look like yet. I'm kind of writing code blind, most of the stuff I'm toying with is still above my paygrade...
23:42:23 <dmead> fnord123, whats the latest edition of that?
23:42:29 <Gracenotes> ski: well. State âŠ‚ CPS, at least. monads
23:42:47 <fnord123> 3
23:42:52 <FunctorSalad> jfredett: btw I skimmed over your -cafe post and didn't quite understand what the associated type was for?
23:43:08 <jfredett> FunctorSalad: thats okay, neither do I. :)
23:43:08 <ski> Gracenotes : i would agree more or less if you said "State + Continuations ~= Monads" ..
23:43:22 <FunctorSalad> jfredett: (instead of converting directly)
23:43:34 <ski> Gracenotes : .. but i'm not sure what you're saying; can you elaborate ?
23:43:46 <jfredett> FunctorSalad: I thought it was going to do the fundep thing, but that didn't work. I've actually been fiddling with multiple representations.
23:43:59 <jfredett> Kind of exploring how type functions work.
23:44:06 <Gracenotes> State/Reader/Writer monads have a Continuation equivalent, right? But I do not think all Continuation monads have a State/.. equivalent
23:44:29 <fnord123> cabalising my version. reinstalling glut... I notice GLUT depends on Data.Tensor.
23:44:32 <fnord123> how odd
23:44:35 <jfredett> the initial class I started with was `class Iso a b where \n iso :: a -> b`
23:44:49 <ski> Gracenotes : yes .. but really they have a "delimited continuation" equivalent .. and "delimited continuations ~= state + continuations"
23:44:53 <jfredett> and it (d)evolved from there.
23:45:46 <Gracenotes> that is good to know, though I was stating no more than I was stating.
23:46:53 <jfredett> well thats interesting...
23:47:09 <jfredett> Undecidable instances are tricksy.
23:48:49 <jfredett> I guess it's getting into some kind of loop, I can provide it a instance of Eq for Related Types, Eg (Hom a b, Eq b) => Eq a, and it compiles, but using the function results in it blowing it's stack trying to generalize the type...
23:50:26 <FunctorSalad> jfredett: remember the instance resolver does backwards reasoning without backtracking (AFAIK)
23:50:34 <jfredett> Methinks I don't understand this well enough to play with it yet...
23:50:38 <FunctorSalad> it can easily get stuck trying b := a
23:50:43 <FunctorSalad> (it has to guess b)
23:50:53 <jfredett> hmm.
23:51:30 <jfredett> well _thats_ interesting...
23:51:47 <jfredett> the one for (Hom a b, Eq b) => Eq a fails at runtime,
23:52:02 <jfredett> but the one for (Hom a b, Eq a) => Eq b fails at compile time.
23:52:23 <jfredett> I imagine that has something to do with the b := a thing being a := b in the latter case.
23:52:43 <jfredett> it's able to "find" the failure earlier, or something, I should dig into the instance resolver to see how that works...
23:53:08 <dmead> gwern, so callcc doesn't copy the current state, it gives access back to it?
23:53:09 <FunctorSalad> yes, I don't know how exactly it chooses the b either
23:53:20 <gwern> dmead: heck, I dunno how it's defined
23:53:32 <gwern> if it's a copy, I can't see how it's implemented efficiently
23:53:34 <gwern> even with COW
23:53:48 <copumpkin> dmead: callcc just gives you access to the implicit continuation parameter that the Cont monad is hiding from you
23:54:20 <jfredett> FunctorSalad: it's just interesting, because the thing seems so natural to say -- a is homomorphic to b, and a has equality, since we assume f : a -> b preserves equality, b must have equality.
23:54:46 <jfredett> but it doesn't seem to translate the way I think it should... then again, like I said, I'm above my paygrade... :)
23:55:07 <dolio> @djinn-add type Cont r a = (a -> r) -> r
23:55:20 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
23:55:21 <lambdabot> f a b = a (\ c _ -> b c) b
23:56:32 <copumpkin> djinn++
23:56:52 <mmorrow> dmead: if you're using a lang/implem that has a real callcc, if it used a stack it'd need to copy it (so callcc would be O(n)), and if it had no stack you could do callcc in O(1)
23:57:06 <dmead> mmorrow, ah
23:57:25 <FunctorSalad> jfredett: this is besides the instance resolution point, but pushing forward the equality from a to b won't give you an equivalence relation if f isn't surjective
23:57:27 <dmead> haskell is O(n)?
23:57:39 <mmorrow> dmead: haskell doesn't have a "real" callcc
23:57:53 <dmead> i understand the concept, but the haskell code i've seen doesn't make sense to me
23:58:02 <jfredett> FunctorSalad: I've closed my eyes and pretended it is the whole way.
23:58:09 <mmorrow> dmead: (but the one in Cont is O(1) i huess since the continuations are heap-allocated)
23:58:11 <jfredett> The original idea was to have "Type isomorphisms"
23:58:27 <jfredett> and then try to classify types kind of like one classifies groups
23:58:34 <jfredett> but by algebraic signature, rather than size.
23:58:37 <FunctorSalad> jfredett: (reflexivity will fail for elements not in the image)
23:59:10 <jfredett> eg- CouldBe and Maybe are 'isomorphic' to the type with signature `x + 1`
23:59:42 <FunctorSalad> jfredett: yes. maybe use a class that says "the normal form of x is y"?
23:59:56 <jfredett> FunctorSalad: ... elaborate?
