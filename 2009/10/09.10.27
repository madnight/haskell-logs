00:23:46 <drhodes> @hoogle a -> b -> [b] -> c
00:23:47 <lambdabot> Language.Haskell.TH TySynD :: Name -> [Name] -> Type -> Dec
00:23:47 <lambdabot> Language.Haskell.TH.Syntax TySynD :: Name -> [Name] -> Type -> Dec
00:23:47 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
00:46:38 <ivanm> @. elite quote
00:46:39 <lambdabot> ser3v3N 5ay$: gracen073S: AnD u May A5K Yourzelf |-|Ow dO I w0Rx T|-|i$? WHEre i$ 7HAT l4rGe aUTocoNF? And u m4Y T3LL YOur selF 7Hiz0rz Iz0rz not MY 834Utiphu| $yn7AX! 4ND yOU /\/\aY 7ElL yOUrse|ph..
00:46:39 <lambdabot> .. l3TTiN9 7|-|e bi75 G0 BY/GC F10WIn9 uND3rGrOUNd....
00:47:15 <Elly> hehe :P
00:47:16 <Elly> @quote
00:47:16 <lambdabot> copumpkin says: [about learning Haskell compared to other languages] I learned X in Y time, but Z is taking much longer. Z sucks!
00:47:58 <int-e> Z is odd.
01:17:34 <Saizan> @quote sereven
01:17:34 <lambdabot> sereven says: Gracenotes: And you may ask yourself How do I work this? Where is that large autoconf? And you may tell your self This is not my beautiful syntax! And you may tell yourself.... Letting
01:17:34 <lambdabot> the bits go by/gc flowing underground....
01:30:31 <surfeasy> .
01:36:09 <jre2> for mostly array access/insert program, any idea how haskell performance should compare to java?
01:37:46 <jre2> ie, given that java is faster, should I be worried that I'm not utilizing some optimization trick?
01:37:56 <Baughn> jre2: Badly, I'm afraid. Although there's been a lot of work on it lately, array access is still unfortunately unoptimized in many common cases.
01:38:21 <Saizan> you could try judy arrays
01:38:27 <Baughn> jre2: in particular, multi-dimensional array access is very slow, as is checked array access - though the latter is not noticably slower than java's
01:38:43 <Baughn> jre2: ..there are unsafe array functions you should be using.
01:39:01 <Saizan> Baughn: why is multi-dimensional array access so slow?
01:39:02 <Baughn> (Unsafe because if you use them wrong they can corrupt memory. So be very very careful.)
01:39:10 <Saizan> Baughn: it doesn't get specialized?
01:39:11 <jre2> well, my benchmarks were about 5x worse than java with STU arrays
01:39:23 <jre2> and still 2.5x worse when doing unsafe accesses
01:39:26 <Baughn> Saizan: I'm not really sure. I've seen benchmarks, but I haven't gone into the details.
01:39:47 <Baughn> jre2: Right. Obviously, the compiler could use some work, for arrays.
01:39:53 <jre2> it's a little disheartening to still lose performance wise even when giving up safety
01:46:11 <Baughn> Saizan_, jre2: Oh, right. IIRC there's still some GC performance bug relating to arrays, isn't there?
01:47:40 <jre2> runtime claims only about 1-2% of time was spent in GC for my tests. I don't know about in general though
01:48:14 <Baughn> jre2: I frequently see ~50-60% gc time for array-heavy code
01:48:23 <jre2> ouch
01:51:32 <shambler> this is just sad :(
01:52:11 <Baughn> Though I can't find the bug in ghc' trac
01:52:41 <jre2> Baughn: so any tips for matching java performance besides calling out to C? (given that I'm already using mutable ST arrays and unsafe accesses)
01:53:26 <Baughn> jre2: Sorry. You should ask in #ghc, maybe; they'd know better how to get around current issues.
01:53:40 <jre2> alright, I'll try that
01:53:40 <eevar2> ocaml? :p
01:58:30 <Baughn> jre2: (Most of the really good people aren't /awake/ yet, being americans. If you don't get an answer, try again in about eight hours.. also, as it says in #ghc, it's not really for user questions, so you should phrase it differently. Well, #haskell has most of the same people anyway. :P
01:58:55 <eflister> hey, i'm trying to implement a snexts for MonadSupply from rwh, snexts :: Int -> m ([Maybe s])
01:59:08 <eflister> but it's not compiling http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198
02:00:10 <jre2> good point, I'll try tomorrow
02:04:18 <eflister> anyone able to help me out?  this version compiles, but is wrong http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11199
02:04:30 <Baughn> jre2: http://hackage.haskell.org/trac/ghc/ticket/650 <-- I found the bug
02:07:13 <pozic> Are user installs still the default on Linux for cabal install?
02:07:20 <Baughn> Yes
02:07:32 <Baughn> For 'forever' values of 'still'
02:07:50 <Baughn> There's been some discussion of making it the default on windows as well, which'd remove the one outlier
02:08:32 <Baughn> jre2: Pay particular attention to the "to get around this" sentence
02:09:35 <pozic> How do I satisfy ghci-haskeline -any && -any? I did cabal install ghci-haskeline as user and I ended up with a ghci-haskeline binary.
02:09:59 <c_wraith> I like "milestone: _|_"
02:10:20 <Baughn> pozic: User-installed libraries are only used when you configure the package to be installed as user, for obvious reasons
02:10:52 <Baughn> pozic: ..easiest way is to use cabal-install to compile whatever you're trying to compile. Running "cabal install" in a directory with a .cabal file will take care of everything.
02:11:30 <pozic> Baughn: I thought you just said that user was the default?
02:11:39 <Baughn> pozic: It's the default for cabal-install, not cabal
02:11:59 <Baughn> pozic: You should basically always use cabal-install as a frontend, these days
02:12:11 <pozic> Baughn: there is no such thing called cabal-install.
02:12:21 <pozic> Baughn: there is cabal install, and that's it.
02:12:37 <c_wraith> the "cabal" program is part of the cabal-install package
02:12:45 <Baughn> pozic: Eh. The package is called cabal-install, even if the binary it installs is just called cabal.
02:12:53 <c_wraith> the "cabal" package contains the Cabal modules
02:13:07 <c_wraith> That is, the library, not the binary that uses them
02:13:20 <c_wraith> It's mildly confusing. :)
02:13:43 <pozic> Baughn: ok, so then I ask why doesn't cabal insall ghci-haskeline satisfy the dependency?
02:13:50 <pozic> install*
02:14:21 <Baughn> pozic: What has the dependency, exactly?
02:14:40 <pozic> Baughn: a test cabal file I have.
02:15:04 <Baughn> pozic: Ah. In this case, the problem is that ghci-haskeline is a program, not a library. You can't depend on it (yet!).
02:15:48 <dcoutts__> well you can express a dependency on it, but cabal install does not pay any attention
02:15:57 <pozic> That sounds broken. In Debian you can depend on a package and it doesn't care whether it is a library or not.
02:16:03 <dcoutts> there's the build-tools field
02:16:14 <Baughn> Does that work, now?
02:16:22 <dcoutts> pozic: programs are not registered when they're installed
02:16:23 <pozic> But that probably only says "oh, noes, you are missing that tool".
02:16:41 <pozic> Instead of solving the problem it just nags.
02:17:13 <pozic> Thanks, anyway.
02:17:13 <dcoutts> right, build-tools get checked by configure and cabal-install doesn't do anything else with them
02:18:05 <Baughn> It's better than nothing, I guess
02:18:45 <Baughn> Fortunately there are currently only two or three tools used by all packages on hackage..
02:18:47 <dcoutts> the other part of the problem is that build-tools talks about executables not packages
02:19:08 <dcoutts> and we do not have a registry of installed programs
02:19:15 <Baughn> Should there be one?
02:19:25 <dcoutts> and we can't find the versions of arbitrary programs
02:19:29 <dcoutts> only ones we know about
02:19:45 <dcoutts> so it's pretty hard to check if foobar >= 2 is installed
02:19:51 <dcoutts> even if we can find foobar on the path
02:20:08 <jkff> What about integration with package managers like apt,rpm,pacman?
02:20:44 <dcoutts> that'd work in some cases
02:21:03 <dcoutts> and would require rather a lot of work
02:21:22 <dcoutts> and wouldn't help if the package was not installed
02:21:32 <Baughn> Or if it's installed in ~/.cabal
02:22:21 <dcoutts> Baughn: you mean if cabal-install did install it then we should keep a bit more info?
02:22:34 <dcoutts> and otherwise just rely on finding progs on the $PATH
02:22:34 <Baughn> dcoutts: That would be good.
02:22:57 <Baughn> The problem can currently be handled by adding a dummy library (with no modules) to any executable packages; then you can depend on it
02:23:16 <Baughn> But cabal should be able to register the package even without doing something as strange as that
02:23:32 <dcoutts> but when it's installed by a system package that's not going to happen
02:23:39 <dcoutts> and that will be a common case
02:27:53 <Baughn> dcoutts: So, what we'd want is a combination. The ability to query system package databases, while falling back to our own database if it's not in there
02:28:08 <Baughn> dcoutts: ..which still leaves the possibility of a user installing it on his own, in /usr/local, in
02:31:52 * Cyneox re
02:42:03 <eflister> anyone able to help me out?   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11199
02:44:46 <blackh> eflister: What's it not doing?
02:44:53 <eflister> compiling :)
02:45:05 <eflister>  i'm trying to implement a snexts for MonadSupply from rwh, snexts :: Int -> m ([Maybe s])
02:45:23 <blackh> eflister: What's the error message?
02:45:39 <blackh> Oh - is that it at the top of that page?
02:45:43 <eflister> the top version is supposed to do what i want, but doesn't compile (error inlined in the comments)
02:45:45 <eflister> the bottom version compiles but is incorrect
02:45:51 <eflister> yeah
02:46:26 <blackh> eflister: OK - I'm with ya
02:46:35 <eflister> thanks :)
02:47:42 <blackh> eflister: OK - your problem is that 'put' is monadic... which means it normally wouldn't appear on the right-hand-side of a let...
02:47:50 <blackh> so you probably want something like...
02:48:09 <blackh> y <- case st of ; [] -> return Nothing ; (x:xs) -> do ; put xs ; return $ Just x
02:48:19 <blackh> Monads turn everything they touch into monads. :)
02:48:59 <eflister> i'll make a rev showing what i think you're saying -- i tried something like that earlier and it didn't work...
02:51:01 <eflister> blackh: ok, like this?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11200
02:51:37 <blackh> eflister: Yes.. that's what I meant.. I'll see if I can compile it
02:54:00 <blackh> I added a whole lot of bumpf at the top and now I've got a type error .. let me se
02:55:51 <blackh> fmap (y :) (snexts $ n - 1) -- or maybe without   <-- this fixes the type error (remove return)
02:55:57 <blackh> But there's a typeclass-related error now
02:56:30 <eflister> what's bumpf?  i think y is now listified when it shouldn't be
02:57:05 <blackh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11202
02:57:27 <blackh> Error is "Could not deduce (MonadSupply s (State [s]))"
02:57:51 <Saizan> you can't S$ at the top
02:58:20 <eflister> hrm.  i was copying the pattern of snext' (which is from rwh and works)
02:58:55 <sohum> could you get rid of the discriminated union requirement for ADTs and newtypes?
02:59:10 <eflister> but i wanted to factor the S $ logic somehow anyway, i don't like that it's there twice
02:59:11 <blackh> eflister: Ah, I know the problem... you can't recursively call snexts because snexts is a different type...
02:59:17 <blackh> eflister: I'll fix it...
02:59:26 <sohum> using type inference or forcing explicit typing in the case of ambiguity?
02:59:33 <Saizan> Elly: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11203
02:59:39 <Saizan> err, eflister ^^
03:00:03 <Saizan> sohum: what do you mean with "discriminated union requirement"?
03:00:27 <Saizan> you want to avoid the constructors?
03:00:29 <sohum> Saizan: type Maybe a = Nothing | Just Int vs type Maybe a = Nothing | Int
03:00:31 <sohum> Saizan: yea
03:00:33 <eflister> Saizan: that worked, thanks :)  now, why?  :)
03:00:58 <Saizan> eflister: because inside the S you're working in the State monad, not the Supply monad
03:01:01 <blackh> eflister: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11204
03:01:17 <blackh> Pish tosh
03:02:10 <eflister> Saizan: why does it work in snext'?
03:02:38 <Saizan> sohum: you'd substitute constructors with type annotations in many cases, imo
03:03:04 <sohum> Saizan: right, but it'd be worth it for the cases where you wouldn't have to
03:03:07 <blackh> eflister: The recursive call has to be from the same type of monad to the same type.  S /= State
03:03:14 <Saizan> eflister: because snext' doesn't use anything that requires the Supply monad in its body
03:03:22 <blackh> eflister: snext' had no problem because there's no recursion
03:03:38 <eflister> Saizan and blackh: ah
03:03:45 <eflister> thanks!
03:04:14 <c_wraith> dcoutts:  You still around?
03:04:23 <dcoutts> @arr!
03:04:23 <lambdabot> Yeh scurvy dog...
03:04:36 <eflister> Saizan and blackh: another piece that bugs me is all the returns, any way to factor them out?
03:04:39 <Saizan> sohum: it would basically introduce subtyping, and that gets easily messy, bounded polymorphism has undecidable type inference, so it could be viable but you'd be trading off some other nice properties of the type system
03:04:55 <c_wraith> I know this isn't the best place for cabal feature requests, but it'd sure be nice if I could tell cabal to do clean, configure, and build as a single step.
03:05:07 <Saizan> sohum: i'd like to see how it turns out however :)
03:05:08 <sohum> Saizan: sorry, what?
03:05:33 <dcoutts> c_wraith: I dunno about clean, but I agree about telling it to build and have it configure if necessary
03:05:34 <FunctorSalad> c_wraith: alias ccb=cabal clean; cabal configure; cabal build
03:05:48 <FunctorSalad> err or even better && not ;
03:05:55 <dcoutts> c_wraith: I like to think that with a decent build system clean is never necessary
03:06:04 <blackh> eflister: Not easily if you're using the state monad as the 'back end'
03:06:05 <Saizan> sohum: you've have that 'x' is not only of type Char, but also of type Maybe Char, Maybe (Maybe Char) etc..
03:06:07 <c_wraith> dcoutts:  When using template haskell, it is.
03:06:10 <dcoutts> that if clean is necessary then the build system is wrong
03:06:19 <dcoutts> c_wraith: how so?
03:06:41 <c_wraith> I'm including the contents of text files into the build.
03:06:45 <dcoutts> it's certainly true atm that clean is necessary, but that's only because we don't have the perfect build system
03:06:47 <Saizan> sohum: that tends to mess with the type system in not obvious ways
03:06:52 <eflister> Saizan and blackh: and would there be a better algorithm than explicit recursion?  i would use 'take', but i want there to be n - r Nothings in the list if there are only r items in the supply...
03:07:05 <dcoutts> c_wraith: hmm, and so the build system has no record of that dependency, hmm, nasty.
03:07:15 <sohum> Saizan: right, so it's of type Char and of type Maybe a, where a has yet to be determined, you can surely resolve that later?
03:07:16 <c_wraith> dcoutts: correct.
03:07:23 <c_wraith> That's why I keep having to clean
03:07:55 <Saizan> sohum: not any 'a' though, some 'a' that has a Char at the bottom
03:08:06 <c_wraith> Maybe cabal could have a way to specify that a file depends on another file?
03:08:13 <blackh> eflister: You can do something like....
03:08:39 <FunctorSalad> where determining "has Char at the bottom" is subject to the same problems along the way
03:08:43 <dcoutts> c_wraith: right, that's what you'd need. I'd forgotten that TH was so unruly that we could not tell what it does.
03:09:24 <Saizan> sohum: what i'm saying is that they've studied this kind of type systems and they aren't as nice as what we have around here, but there's always room for research of course, a good introduction is Pierce's TAPL
03:09:49 <blackh> eflister: let ys = take n (xs ++ repeat Nothing) ; xs' = drop n xs
03:10:14 <blackh> eflister: or...  let ys = take n (map Just xs ++ repeat Nothing)   <-- that's a bit more correct!
03:10:57 <sohum> Saizan: fair enough. I still think it should be possible if you don't start by determining the type of 'a' (or call that Enclosed Char or something) but instead work out what the type of 'a' /has/ to be given how it's used and what explicit type information you do have.
03:11:00 <eflister> blackh: yeah i like that.  think it's preferable to the recursion?
03:11:20 <blackh> eflister: Yes - if you can do it in that sort of way it's almost always preferable to recursion
03:11:32 <Saizan> sohum: if you implement it then it can be done :)
03:11:35 <eflister> blackh: cool, thx!
03:12:56 <FunctorSalad> is there a way to force haddock to put a typesig on multiple lines? (sometimes it decides to do that by itself already)
03:13:08 <sohum> Saizan: mrf. I'm not so good with the compiler hacking. Maybe I'll just write a paper on it after learning about type systems instead ;)
03:13:29 <Saizan> sohum: that's good enough
03:15:30 <c_wraith> dcoutts:  Yeah...  With runIO, anything's possible from TH
03:16:28 <GNU\colossus> hi there
03:17:49 <GNU\colossus> I'm looking for a function that returns the list of indexes of occurences of a string s1 in another string s2 - can anyone tell me a general direction on what to look at?
03:18:35 <Saizan> c_wraith, dcoutts: if only tracking dependencies by monitoring what the program does was efficient
03:19:02 <eflister> blackh: hm, i don't get why your solution (with S $ factored out) doesn't run into the 'not being in Supply' problem?
03:19:37 <c_wraith> GNU\colossus: If you're just looking for a function that does that, look in Data.List
03:19:52 <blackh> eflister: Because 'sn' is entirely in the State monad, including the recursion.  Then I just wrap the whole thing in S
03:21:27 <GNU\colossus> c_wraith: I've been staring at the list of functions in that module for the better part of two hours now, but I cannot figure out how to do it. I've found "findIndices", but I cannot for the life of me get it to work right.
03:21:37 <GNU\colossus> I'm an absolute haskell beginner, btw :)
03:22:03 <quicksilver> :t findIndices
03:22:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
03:22:21 <quicksilver> > findIndices (=='a') ['a','b','c','a','a','e','f','a']
03:22:22 <lambdabot>   [0,3,4,7]
03:22:29 <eflister> blackh: ok, i was trying to do it with an if.  and that puts me back in the S monad.  i see.
03:22:35 <quicksilver> GNU\colossus: does that example help?
03:22:46 <c_wraith> Oh, I see.  You're looking for sublists, and findIndices only gives single elements.
03:23:02 <quicksilver> oh i also didn't realise that.
03:23:15 <quicksilver> there is no function which does that out of the box.
03:23:26 <quicksilver> you can build it using 'tails', 'findIndices' and 'isPrefixOf'
03:23:37 <quicksilver> I'll show you if you like but you might prefer to try to work it out from that.
03:24:20 <dcoutts> Saizan: aye, well we can strace :-)
03:24:54 <dcoutts> Saizan: or lobby for TH's "unsafe do action" escape hatch to use something other than IO so we can trace the actions.
03:25:28 <sohum> Saizan: so, are you saying that there's no result in this space already?
03:25:55 <GNU\colossus> c_wraith, quicksilve: yes, evaluating sublists is what I need
03:26:08 <c_wraith> dcoutts:  The latter would make TH considerably more cumbersome, if you couldn't use existing IO functions.
03:26:15 <GNU\colossus> quicksilver: thanks for the hint, I'll see if I'm lucky today
03:26:54 <dcoutts> c_wraith: bah, all you need is to be able to read files :-)
03:27:22 <c_wraith> Maybe I want to base my code on some value I read from the network!  for...  some currently-unknown reason. :)
03:28:07 <c_wraith> Still, I suppose a readFile-like function would be sufficient for most cases.
03:28:20 <Saizan> sohum: nothing as strong as that, i've never seen a type system that does exactly that though
03:28:34 <sohum> Saizan: *nod*, thanks.
03:28:44 <dcoutts> c_wraith: but if you do then you're bad and wrong! :-) because you're making an impure build system
03:29:14 <dcoutts> dependency based build systems can only be expected to deal with build actions that are morally pure
03:29:30 <c_wraith> dcoutts:  Less jokingly, the haskell project where I work looks at darcs output in TH code, to include the latest tag name in the full version string.
03:29:57 <dcoutts> c_wraith: that's fine, it's still pure
03:30:30 <Saizan> dcoutts: what would you qualify as impure?
03:30:30 <c_wraith> dcoutts: But it's more sophisticated than just readFile
03:30:46 <dcoutts> Saizan: a random GUID generator :-)
03:30:50 <dcoutts> c_wraith: right sure
03:31:00 <dcoutts> Saizan: timestamps
03:31:26 <dcoutts> though since typically nobody depends on timestamps the damage is limited
03:32:21 <dcoutts> c_wraith: the main thing is that dependencies need to be visible to the build system, otherwise it will go wrong
03:32:35 <dcoutts> c_wraith: and TH is a currently a hidden bunch of build actions
03:32:45 <c_wraith> dcoutts: Completely agree.
03:33:20 <dcoutts> relying on programmers to get a separately listed set of dependencies correct is usually not wise
03:33:28 <c_wraith> also, it's late, and the extra time awake I bought with my earlier nap has expired.  Good night, all.
03:33:34 <egg_> hello
03:33:42 <dcoutts> g'night c_wraith
03:34:07 <egg_> I'm a beginner when it comes to haskell
03:34:15 <egg_> could someone maybe help me with what i am writing?
03:34:38 <blackh> egg_: Certainly - paste it on the pastebin and we'll take a look
03:35:53 <egg_> http://pastebin.com/m4f62368f
03:36:07 <egg_> I'm trying to make a power raiser function
03:36:07 <tresh> Hello. Is there any function `String -> String -> [Int]` in haskell that returns beginning-indices of substrings?
03:36:28 <egg_> I want to do it recursively, but i can't see how
03:36:36 <egg_> to make it recursive
03:37:24 <blackh> tresh: No - but the 'text' package (on hackage) provides more functions like that.
03:38:14 <blackh> egg_: I didn't pay attention in maths classes...
03:38:25 <tresh> blackh: thanks
03:39:01 <egg_> haha
03:39:05 <egg_> neither did I tbh
03:39:07 <blackh> tresh: I should mention that 'text' is a different (faster) data type than String!  If you want to use String, you'll generally have to write it yourself...
03:40:43 <blackh> egg_: I can't really understand what you want to do.
03:41:06 <egg_> haha oh
03:41:10 <egg_> it's for some work in uni
03:41:19 <egg_> I have to define the function using recursion
03:41:28 <egg_> the code works as it is supposed to right now
03:41:33 <egg_> just not recursive
03:42:05 <egg_> haha wait we figured it out
03:42:05 <egg_> nvm
03:54:21 <GNU\colossus> quicksilver: ok, I just barely kept my poor brain from exploding ;) - would you mind elaborating on the hint you previously provided me with?
03:55:45 <pozic> I wonder why "brain exploding" is considered to be a good thing in the Haskell cosmos.
03:56:27 <GNU\colossus> pozic: is is? personally, I wouldn'
03:56:31 <GNU\colossus> t share that notion
03:56:47 <pozic> Neither do I.
03:57:05 <pozic> Nothing about Haskell is particularly difficult. It's all in the presentation.
03:59:39 <GNU\colossus> I began doing stuff with Haskell two days ago, and today is the second day in a row with severe headaches for me
04:00:18 <GNU\colossus> of course, correlation does not imply causation
04:00:22 <GNU\colossus> ;)
04:01:00 <earthy> usually the 'splodin' brains are because of understanding the extremely complex behaviours that can be gotten from these not particularly difficult things
04:01:34 <blackh> GNU\colossus: I remember Haskell really made my head hurt when I first started, and it still does sometimes.
04:01:38 <eflister> Saizan and blackh: ok this one's awesome.  :)  except there's something wrong with it, but it's really close!  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11205
04:02:25 <blackh> eflister: That's unreadable!
04:02:46 <eflister> Saizan and blackh: i love arrows!  :)  it just doesn't like the puts.  it works fine if s/puts/lengths
04:02:56 <eflister> s/lengths/length
04:03:32 <blackh> eflister: Well, I like arrows too but I don't do those Kleiskslsli ones.
04:04:17 <eflister> blackh: is this a Kleisli?  is that just anytime it's an arrow on -> ?  i haven't figure out Kleisli yet.  i'm re-indenting for you, but can you see what's wrong?
04:04:45 <blackh> eflister: Well, if you're going to put 'put' into an arrow, it'll only work if it's really a monad (i.e. a Kleisli arrow)
04:05:18 <eflister> blackh: oh, maybe today's the day i learn Kleisli then.  do i just need to write Kleisli somewhere?
04:05:54 <blackh> eflister: Well, you could - but wouldn't it be better just to make it readable?
04:05:55 <dibblego> Kleisli is just a data type -- a pretty easy one
04:06:06 <dibblego> a -> m b
04:06:36 <eflister> blackh: well i think it's readable once indented nicely
04:06:41 <blackh> OK
04:08:11 <eflister> dibblego and blackh: so how does Kleisli work here?  (i like arrows cuz they eliminate tuple manipulation noise -- increase readability)
04:08:26 * Baughn just wrote a five-hundred-line module and had it work the first time it compiled. Haskell banzai!
04:08:42 <Twey> \o/
04:09:04 <zygoloid> Baughn: GODLIKE
04:09:44 <Twey> Hehe
04:11:17 <blackh> eflister: I don't know off the top of my head, but in order for the put to operate in the monad, it has to be of type a -> mb... I don't know how it will work with (??, a -> mb)
04:11:36 <blackh> I mean (??, a -> m b)
04:14:25 <eflister> blackh: is there a good thing to read?  the Control.Arrow docs don't really help.  i'm trying to understand it here: http://blog.snoyman.com/2009/10/19/monadic-pairs-and-kleisli-arrows/
04:15:55 <eflister> :t put
04:15:56 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
04:17:28 <blackh> eflister: Looks like you're onto it!
04:17:52 <eflister> :t Kleisli put
04:17:53 <lambdabot> forall a (m :: * -> *). (MonadState a m) => Kleisli m a ()
04:20:01 <eflister> :t (Kleisli (\x -> return $ take n $ (map Just x) ++ (repeat Nothing)) *** Kleisli put)
04:20:02 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
04:20:02 <lambdabot>     In the first argument of `take', namely `n'
04:20:02 <lambdabot>     In the first argument of `($)', namely `take n'
04:21:03 <eflister> :t ((Kleisli (\x -> return $ take n $ (map Just x) ++ (repeat Nothing))) *** (Kleisli put))
04:21:04 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
04:21:04 <lambdabot>     In the first argument of `take', namely `n'
04:21:04 <lambdabot>     In the first argument of `($)', namely `take n'
04:21:21 <eflister> :t ((Kleisli (\x -> return $ take 5 $ (map Just x) ++ (repeat Nothing))) *** (Kleisli put))
04:21:22 <lambdabot> forall (m :: * -> *) a b'. (MonadState b' m) => Kleisli m ([a], b') ([Maybe a], ())
04:22:28 <eflister> :t (Kleisli fst) ^<< ((Kleisli (\x -> return $ take 5 $ (map Just x) ++ (repeat Nothing))) *** (Kleisli put))
04:22:29 <lambdabot>     Couldn't match expected type `c -> d'
04:22:29 <lambdabot>            against inferred type `Kleisli m (m b1, b) b1'
04:22:29 <lambdabot>     In the first argument of `(^<<)', namely `(Kleisli fst)'
04:23:06 <eflister> :t fst ^<< ((Kleisli (\x -> return $ take 5 $ (map Just x) ++ (repeat Nothing))) *** (Kleisli put))
04:23:07 <lambdabot> forall (m :: * -> *) a b'. (MonadState b' m) => Kleisli m ([a], b') [Maybe a]
04:23:26 <eflister> huh, why don't i have to Kleisli fst?
04:23:50 <eflister> :t runKleisli $ fst ^<< ((Kleisli (\x -> return $ take 5 $ (map Just x) ++ (repeat Nothing))) *** (Kleisli put))
04:23:51 <lambdabot> forall (m :: * -> *) a b'. (MonadState b' m) => ([a], b') -> m [Maybe a]
04:24:00 <eflister> damn
04:24:51 <eflister> works :)
04:25:30 <eflister> can one applicative their arrows to factor out those Kleislis?
04:30:15 <eflister> blackh and dibblego: so why didn't i have to Kleisli fst?  and is there a way to factor the application of Kleisli to those arguments of ***?
04:33:02 <blackh> eflister: Is it because of ^<< lifting it into Kleisli? (Just a guess)
04:33:38 <eflister> blackh: ah that makes sense.
04:37:24 <eflister> blackh: so you really don't like this?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11198#a11206   what would a good haskeller do?
04:37:32 <eflister> :t runKleisli
04:37:33 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
04:38:25 <blackh> eflister: Well...
04:40:04 <eflister> @pl runKleisli (fst ^<< (Kleisli (\x -> return $ take n $ (map Just x) ++ (repeat Nothing)) *** Kleisli put) ) (splitAt n st)
04:40:04 <lambdabot> runKleisli (fst ^<< Kleisli (return . take n . (++ repeat Nothing) . map Just) *** Kleisli put) (splitAt n st)
04:42:50 <blackh> (ys, xs') <- splitAt n <$> get ; put st xs' ; return $ take n $ map Just ys ++ repeat Nothing
04:42:54 <blackh> That's probably what I would write
04:47:53 <eflister> blackh: yeah that's definitely alot clearer.  better to pattern match to avoid tuple fu than arrow.  you don't mean the st in the put line, do you?
04:49:15 <blackh> eflister: Oh right - the st is a mistake.
04:50:30 <blackh> eflister: It's good to try everything of course.  I'm not saying my way is best by any means.
04:52:23 <eflister> blackh: cool, yeah i am overeager to use arrows.  i like avoiding identifiers at all costs.  yours is clearer tho.  at least i learned Kleisli (well, i just followed a pattern, i don't really know what it meant)
04:53:53 <blackh> eflister: I think the use of the state monad is a long-winded, but after a while I've come to like it because it just reads really simply... get this, put that, etc. :)
04:56:34 <eflister> blackh: long winded compared to what, is there any alternative (besides a Cont, which i don't get yet).  i really don't get this Supply monad either i guess, like what S is for.
04:57:17 <blackh> eflister: The only purpose of S is to make the internals private
04:57:42 <eflister> blackh: oh right, i forgot about that (been awhile since i read that ch)
04:58:00 <fxr> could you please recommend me a project name? What I did is a CouchDB like thing, put/get documents in JSON format using happstack and tokyocabinet.
04:58:59 <eflister> @fresh
04:59:00 <lambdabot> Hacb
04:59:53 <blackh> eflister: There's no alternative to state monad that you don't know about.  I quite often jump into a state monad where it makes sense (even if it's only 5 lines of code).
05:00:56 <eflister> HaJapStack
05:01:11 <GNU\colossus> fxr: what about "Regal"? it's german, and means "rack"
05:01:22 <fxr> GNU\colossus: there is a parser with that name
05:01:36 <fxr> GNU\colossus: and I remember it was wonderful :)
05:01:48 <fxr> oh sorry, it was ragel
05:01:55 <GNU\colossus> heh
05:01:57 <SamB_XP> GNU\colossus: rack like girls have, or rack like servers go on ?
05:02:06 <GNU\colossus> SamB_XP: the latter,
05:02:54 <FunctorSalad> nettes regal...
05:03:18 <GNU\colossus> :D
05:03:39 <fxr> regal is a brand in german, refrigerators etc...
05:11:55 <mlesniak> Do I have any possibilities to get more information out of a "thread blocked indefinitely" message?
05:15:18 <blackh> mlesniak: Unfortunately no, but it comes from an MVar
05:16:01 <SamB_XP> mlesniak: this is why I've been lobbying for threads to have names :-(
05:16:52 <ivanm> with the new haskell-mode for emacs, has kuribas' mode become default or something?
05:21:19 <mlesniak> blackh, :) Or from a Channel which uses MVars ;-)
05:21:40 <mlesniak> SamB_XP, ...or any other informations which would help.
05:22:25 <SamB_XP> mlesniak: well, if they had names, the RTS could use them to tell you all kinds of useful information!
05:22:43 <mlesniak> right!
05:22:54 <SamB_XP> well, at least, it could tell you what thread was blocked indefinately
05:23:35 <SamB_XP> with profiling on, it would presumably be able to tell you about where this had occured in your program
05:23:53 <SamB_XP> (well, I guess it could do that anyway?)
05:24:34 <SamB_XP> but, I guess there isn't much more to say is there.
05:24:48 <SamB_XP> would be useful when you had deadlocks, though
05:33:40 <kamatsu> what the freaking hell
05:33:51 <kamatsu> i can access hackage from my computer
05:33:57 <kamatsu> but my vps can't find a route to hackage
05:34:06 <kamatsu> it finds a route to everything else, even haskell.org, but not hackage
05:34:20 <kamatsu> this is infuriating
05:34:35 <kamatsu> can we please get some full hackage mirrors happening to stop this proble?
05:36:00 <Jafet> Or you could...fix your hosts file or whatever
05:36:39 <kamatsu> but that's all fine
05:36:57 <ivanm> if there's something wrong with your VPS, how would mirrors help?
05:37:14 <Jafet> He wouldn't have to care
05:37:15 <kamatsu> well, it might be able to find a route to the mirrors
05:37:34 <kamatsu> hosts file is completely normal
05:38:32 <kamatsu> maybe i'll just set up a proxy from my computer
05:42:50 <jkramer> Hi
05:43:15 <jkramer> I'm looking for a function for creating tuples in point-free style, but can't find anything
05:43:25 <ivanm> jkramer: (,)
05:43:25 <jkramer> I'd like to have something like this: toTupel :: (a -> (a, b)) -> a -> (a, b)
05:43:25 <dibblego> @type (,)
05:43:26 <lambdabot> forall a b. a -> b -> (a, b)
05:43:59 <dibblego> jkramer, that's the id function
05:44:20 <ivanm> @djinn (a -> (a,b)) -> a -> (a,b)
05:44:21 <lambdabot> f a = a
05:44:31 <ivanm> @pl \ a -> a
05:44:31 <lambdabot> id
05:44:34 <ivanm> voila!
05:45:08 <jkramer> Hrm
05:45:18 <jkramer> I'm not sure I'm getting it :)
05:45:50 <jkramer> I'd like to do something like this: foo = map (\ x -> (x, x * 2))
05:45:54 <jkramer> But without the x
05:46:11 <benmachine> ah
05:46:12 <dibblego> @type let toTupel :: (a -> (a, b)) -> a -> (a, b); toTupel = id in toTupel
05:46:13 <lambdabot> forall a b. (a -> (a, b)) -> a -> (a, b)
05:46:14 <benmachine> maybe you want &&&
05:46:17 <ivanm> @pl \ x -> (x, x* 2)
05:46:17 <lambdabot> ap (,) (2 *)
05:46:36 <dibblego> @type id &&& (*2)
05:46:36 <lambdabot> forall b. (Num b) => b -> (b, b)
05:46:37 <benmachine> > (id &&& (*2)) x
05:46:39 <lambdabot>   (x,x * 2)
05:46:51 <jkramer> Yes, pointfree already told me about ap, but it doesn't really work
05:47:10 <benmachine> do you have the function monad instance in scope?
05:47:21 <jkramer> I don't think so
05:47:23 <benmachine> you might need to import Control.Monad.Instances
05:47:28 <benmachine> usually as
05:47:33 <benmachine> import Control.Monad.Instances ()
05:47:40 <jkramer> Ah, I only imported Control.Monad
05:47:40 <benmachine> since you're not actually getting any functions from it
05:47:54 <jkramer> But I'll try &&& first, looks more like what I want
05:47:56 <jkramer> Thanks so far
05:48:33 <benmachine> &&& is in Control.Arrow
05:48:40 <jkramer> Yup, found it
05:48:42 <jkramer> Works great, thanks
05:48:59 <dibblego> also you might like to import Control.Applicative and use (,) <*> (*2)
05:50:08 <FunctorSalad> cabal upload seems stuck on the 'uploading' step
05:50:36 <ivanm> FunctorSalad: it often does...
05:50:47 <dcoutts> FunctorSalad: don't worry about it, let it time out
05:50:51 <FunctorSalad> ok
05:51:05 <hackagebot> type-settheory 0.1 - Type-level sets and functions expressed as types (DanielSchuessler)
05:51:45 <FunctorSalad> ah
06:05:09 <hackagebot> hs-ffmpeg 0.3.4 - Bindings to FFMPEG library (VasylPasternak)
06:06:09 <hackagebot> ffmpeg-tutorials 0.3.3 - Tutorials on ffmpeg usage to play video/audio (VasylPasternak)
06:10:26 <jogla> Is there a program that can give me the type of an expression?
06:10:33 <Beelsebob> ghci
06:10:36 <Beelsebob> or lambdabot
06:10:44 <Beelsebob> @type 5
06:10:45 <lambdabot> forall t. (Num t) => t
06:10:55 <Twey> :t "hi"
06:10:56 <lambdabot> [Char]
06:11:16 <int-e> :t ap id id
06:11:18 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
06:11:18 <lambdabot>     Probable cause: `id' is applied to too few arguments
06:11:18 <lambdabot>     In the second argument of `ap', namely `id'
06:11:41 <FunctorSalad> :t ap `id` id
06:11:42 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
06:11:44 <int-e> @pl \x -> x x
06:11:45 <lambdabot> join id
06:11:45 <FunctorSalad> ;))
06:11:53 <int-e> @pl ap id
06:11:53 <lambdabot> ap id
06:12:28 <ivanm> what would be a good term for when, given a graph and a set of (root) nodes, you recursively take nodes that have predecessor nodes only in that set you have?
06:13:17 <quicksilver> downward closed or upwards closed
06:13:23 <quicksilver> depending which way up your mental model is.
06:13:27 <int-e> . o O ( co-reachable vertices )
06:14:38 <ivanm> int-e: where does the co- come from?
06:14:56 <int-e> from working on the opposite graph (which is a category).
06:14:58 <ivanm> quicksilver: well, they're meant to be root nodes, so downardClosed seems reasonable
06:15:14 <ivanm> int-e: opposite graph = if there's an edge, remove it; otherwise add one?
06:15:18 <ivanm> (inverse graph?)
06:15:18 * int-e would probably call those predecessors, as opposed to immediate predecessors.
06:15:40 <int-e> ivanm: no, that would be a complement. opposite = the same graph with all edge directions reversed.
06:15:40 <FunctorSalad> 'predecessor closure'?
06:16:01 <ivanm> int-e: ahh, rgith
06:16:02 <ivanm> *right
06:16:38 <ivanm> FunctorSalad: yeah, I was thinking something along the lines of closure, but graph closure is by adding edges, so I figured something like that would be the wrong terminology
06:34:20 <jogla> Beelsebob: Thanks
06:35:15 <jogla> @type ([\x -> [x]],[99])
06:35:16 <lambdabot> forall t t1. (Num t1) => ([t -> [t]], [t1])
06:36:31 <jogla> I don't understand that
06:36:39 <burp> why?
06:38:45 <ivanm> jogla: you have two items in that pair:
06:38:58 <ivanm> the second part is just a singleton list containing a number
06:39:07 <ivanm> the first is a list of (\x -> [x])
06:39:10 <ivanm> @type \x -> [x]
06:39:11 <lambdabot> forall t. t -> [t]
06:40:03 <eflister> is there a way to set some fields in a record to _|_ ?
06:40:14 <ivanm> eflister: set it to undefined?
06:40:20 <eflister> ok thx
06:40:20 <ivanm> @hoogle bottom
06:40:20 <lambdabot> Test.QuickCheck.Batch bottom :: a
06:40:21 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
06:45:04 <FunctorSalad> is there a positive way to express peano's  "Not (Z :=: S n)"?
06:45:46 <FunctorSalad> initiality in the category of  Succ-Zero-structures maybe
06:45:58 <FunctorSalad> (structures with a nullary and a unary op)
06:51:20 <opqdonut> FunctorSalad: yeah, that would do it i guess
06:51:54 <opqdonut> it is after all a kind of freeness constraint
06:52:12 * FunctorSalad goes encode these structures in the types system :D
06:55:16 <jogla> @src *
06:55:16 <lambdabot> Source not found. Are you on drugs?
06:55:20 <jogla> @src `*`
06:55:20 <lambdabot> Source not found.
06:55:30 <jogla> Try harder.
06:55:59 <benmachine> * is a typeclass functino
06:56:00 <jogla> @type ([\x -> [x]],[99])
06:56:01 <lambdabot> forall t t1. (Num t1) => ([t -> [t]], [t1])
06:56:02 <benmachine> function
06:56:10 <ivanm> @src Num
06:56:10 <lambdabot> class  (Eq a, Show a) => Num a  where
06:56:10 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:56:10 <lambdabot>     negate, abs, signum     :: a -> a
06:56:10 <lambdabot>     fromInteger             :: Integer -> a
06:56:22 <ivanm> @src Int (*)
06:56:23 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:56:23 <jogla> Why is it not ([[x]], [x])
06:56:31 <ivanm> @src Complex (*)
06:56:32 <lambdabot> Source not found. I am sorry.
06:57:00 <benmachine> jogla: why would it be? you have a lambda in a list
06:57:04 <ivanm> jogla: because that's not what you said
06:57:06 <benmachine> so you get a list of functions
06:57:15 <benmachine> that is only one function long
06:57:18 <ivanm> jogla: I already explained to you why you get that type sig before
06:57:41 <ivanm> <ivanm> jogla: you have two items in that pair:
06:57:42 <ivanm> <ivanm> the second part is just a singleton list containing a number
06:57:42 <ivanm> <ivanm> the first is a list of (\x -> [x])
06:57:46 <jogla> I have read that
06:58:02 <ivanm> right, so what's your problem?
06:58:06 <jogla> Well
06:59:32 <fasta> What is a good way to manage on the Haskell side that a C library has been initialized at most once? I am using unsafePerformIO currently with an IORef, but I have the impression it is flaky.
07:00:31 <blackdog> initialise it in an IO context?
07:00:54 <jogla> ivanm: Because [t -> [t]] will be [[t]] at some point i though i the type might be just [[t]]
07:01:15 <benmachine> jogla: what do you mean, at some point?
07:01:19 <ivanm> jogla: only when you give it a value
07:01:29 <ivanm> jogla: you haven't, so it's still a list of functions
07:01:32 <fasta> blackdog: the problem is that I don't want to pass the IORef around to the initialize_c_lib function.
07:01:38 <mornfall> How do I express dependencies between finalizers of foreign ptrs?
07:01:45 <mornfall> I mean, if resource a references resource b?
07:01:53 <ivanm> if you then do something like "map ($2)" to the first element of that tuple, _then_ you won't have the functions
07:02:19 <benmachine> fasta: if you are already using unsafePerformIO, you can unsafePerformIO newIORef to get a global variable
07:02:29 <mornfall> I am using C finalizers, so even the un-recommended touchForeignPtr wouldn't work.
07:02:36 <benmachine> but be aware that global variables are an advanced form of evil
07:02:37 <fasta> {-# NOINLINE already_initialized_devIL_ref #-}
07:02:37 <fasta> already_initialized_devIL_ref = unsafePerformIO(newIORef False)
07:02:50 <benmachine> yes
07:02:53 <fasta> This is what I am currently using, but I don't think it works.
07:03:08 <benmachine> why don't you think so?
07:03:12 <fasta> It _should_ work according to my mental model.
07:03:27 <fasta> But it seems that it doesn't. I will have to debug a bit more to be sure, though.
07:03:49 <sjanssen> fasta: is the type monomorphic?
07:03:59 <fasta> sjanssen: of the reference? Yes
07:04:12 <sjanssen> fasta: then it almost definitely works
07:12:03 <benmachine> suppose I have a function with an equation f (x:xs) = -- blah; and I know that f operates on an infinite list
07:12:20 <benmachine> ghc whines about non-exhaustive patterns
07:12:48 <benmachine> what's the performance impact of a. making the pattern irrefutable or b. adding f _ = error "oh no!"
07:13:14 <sjanssen> benmachine: there's no impact on the latter
07:13:33 <benmachine> sjanssen: but it looks less pretty :( any idea about the former?
07:13:43 <sjanssen> GHC rewrites all matches to match on every pattern anyway, you're just doing the transformation yourself
07:13:56 <sjanssen> benmachine: the former might create memory leaks
07:14:17 <benmachine> ho hum
07:14:24 <benmachine> under what circumstances would it do so?
07:14:30 <sjanssen> benmachine: if your function is only defined on infinite lists, perhaps you should use an infinite list type?
07:14:38 <sjanssen> there's one on hackage called 'stream'
07:14:54 <benmachine> could do, but that complicates the API a little
07:14:57 <int-e> benmachine: f ~(a,b) = ... becomes something like f x = let a = fst x; b = snd x in ...
07:16:18 <int-e> benmachine: so the code will create new thunks when executed. there is, however, an optimisation in the garbage collector that will shortcut the selector calls (fst and snd here) once x becomes fully evaluated. That makes it pretty hard to reason about the space behaviour of such code.
07:16:50 <benmachine> okay, I think I'll settle for the extra equation
07:23:03 <dango> hi
07:23:18 <dango> how can i use an empty char in haskell? something like ''
07:23:36 <Twey> dango: There's no such thing
07:23:43 <benmachine> might as well ask how to use an empty int
07:23:52 <Twey> (well, there's undefined)
07:24:02 <dango> Twey: ok thanks
07:24:09 <benmachine> there is an empty string
07:24:14 <benmachine> but that is a different thing
07:24:25 <benmachine> question is, if there was one how would you use it?
07:24:26 <Ferdirand> in which language is there an empty char ?
07:24:45 <benmachine> quite a lot of languages don't have chars as such, just strings of length 1
07:24:45 <jogla> I have the type: [\x -> (1+), \[x] -> x]
07:24:52 <jogla> Assuming x is Num -> Num
07:25:00 <benmachine> such languages also have strings of length 2
07:25:08 <jogla> I don't understand how the first entry can fulfill that
07:25:11 <dango> i'm just learning haskell and what i trie is: http://pastebin.com/m7b9f7b6f
07:25:18 <jogla> @type [\x -> (1+), \[x] -> x]
07:25:19 <lambdabot> forall t. (Num t) => [[t -> t] -> t -> t]
07:25:27 <jogla> How can that be true for the first part of the list?
07:25:36 <benmachine> jogla: it doesn't use x at all?
07:25:54 <jogla> Doesn't it use x after \?
07:26:00 <jogla> \x -> Int -> Int
07:26:09 <benmachine> I think you are getting types and values confused
07:26:38 <benmachine> \x -> (1+) is a function of type (Num b) => a -> b -> b
07:27:01 <jogla> Yes, i undersntand
07:27:21 <benmachine> \[x] -> x is a function of type [a] -> a
07:27:28 <jogla> Yeah
07:28:13 <benmachine> well
07:28:19 <benmachine> let's call it [c] -> c to avoid confusion
07:28:22 <benmachine> since both these functions are in the same list, their types have to be the same
07:28:47 <benmachine> so we have a = [c], and then c = b -> b
07:28:57 <benmachine> so the types are both [b -> b] -> b -> b
07:29:01 <benmachine> tada.
07:29:35 <benmachine> note that [\x -> (1+), \[x] -> x] is the same as [\x -> (1+), \[y] -> y]
07:29:57 <jogla> I don't understand why
07:30:45 <benmachine> why they are the same?
07:31:01 <jogla> Why these x don't belong together
07:31:06 <jogla> i thought its the same x
07:31:27 <benmachine> why should it be?
07:31:32 <benmachine> the two expressions are unrelated
07:31:36 <benmachine> it's like if you had
07:31:43 <benmachine> [let x = 3 in x, let x = 5 in x]
07:32:01 <benmachine> the scope of x is specific to each list item
07:32:11 <benmachine> > [let x = 3 in x, let x = 5 in x]
07:32:12 <lambdabot>   [3,5]
07:32:14 <jogla> Ahh
07:32:16 <jogla> Thanks
07:32:47 <benmachine> > let x = 3 in (\x -> x + 4) 5
07:32:48 <lambdabot>   9
07:33:01 <benmachine> note that in this case, the lambda's x overrides the one in the outer scope
07:33:16 <benmachine> so the x in x + 4 is nothing to do with the x in let x = 3
07:36:07 <jogla> Well
07:36:55 <benmachine> the left hand side of the -> in a lambda is like the left hand side of an = in a function definition or let binding
07:36:58 <fasta> Is there any meaningful way in which one can use gdb and Haskell?
07:37:14 <benmachine> fasta: I don't know, but ghci has a debugger
07:37:26 <benmachine> (I imagine not, but people don't tell me these things)
07:37:27 <fasta> benmachine: no, it has something they call a debugger. It is not.
07:38:07 <fasta> benmachine: the ROI was negative for me and nothing has changed in the mean while. There are some patches by someone that do make it usable, I believe.
07:38:31 <benmachine> debugging in haskell is a niche market because it is so easy to write correct code >_>
07:38:43 <Beelsebob> haha
07:39:00 <fasta> I am not debugging my Haskell code, that works fine. It's the darn C libraries that break when you move it to another machine.
07:39:00 <Beelsebob> debugging in haskell is a small part of the world because no oneâ€™s figured out how to do it well
07:39:18 <fasta> Or look at it in the wrong way ;)
07:39:26 <benmachine> I imagine those might be more gdb-able but I'm the wrong person to ask
07:39:40 <benmachine> which leads one to wonder why I keep answering
07:39:59 <benmachine> given that the right person to ask is probably here too
07:40:36 <benmachine> in summary, I can be of no further use to you
07:40:52 <fasta> I think I just have to ask it to myself ;)
07:46:11 <fasta> If someone has a usable replacement for a pgm file reader, that would also solve the problem.
07:46:42 <fasta> The Haskell package that does this was horribly broken last time, I tried it.
07:47:04 <fasta> -,
07:51:24 <benmachine> so I implemented an algorithm with Map and with IntMap; is it surprising that the latter was faster but used more memory?
07:51:42 <benmachine> the implementation details being basically identical (except the former uses Integer and the latter Int)
07:52:52 <maltem> For debugging Haskell code, try to prove your program correct, and see what difficulties arise :P
07:53:18 <maltem> Either you find the mistake, or you learn something.
07:53:25 <maltem> (more probably the latter)
08:00:08 <fasta> maltem: the hard problems are not that, but configuration issues. It turns out that I use a X.Y.Z version of a library which is newer than the X.Y.A version used on another machine I was testing it on.
08:00:40 <fasta> That's why Nix is so nice in theory.
08:01:33 <pao> I've just read [ xs | False : xs <- xss] ... is this kind of pattern guard haskell98?
08:01:48 <int-e> pao: yes
08:01:50 <fasta> pao: yes
08:02:00 <pao> thanks both :-)
08:02:39 <ludflu> Hi folks. I have a list comprehension that seems to work fine in ghci: [(x, y) | x <- [1 .. 9], y <- [1 .. 9]] But when I try to use the elements as keys in a map, I get the error No instance for (Enum [(t, b)])       arising from the arithmetic sequence `1 .. 9' at map.hs:13:40-45
08:03:04 <int-e> on an unrelated note, [as | False] is equivalent to ([] `asTypeOf` [as])
08:03:39 <ludflu> the compiler suggests "Possible fix: add an instance declaration for (Num [(t, b)])" but I'm not sure what that means
08:03:46 <pao> int-e: I'm looking at http://stackoverflow.com/questions/1628061/parallel-insertions-into-a-binary-trie-in-haskell
08:04:07 <pao> int-e: but I don't grok the list comprehension proposed by sjanssen
08:04:11 <int-e> ludflu: you can safely ignore that suggestion. but it's hard to diagnose your problem without seeing more code.
08:04:26 <fasta> ludflu: it means exactly what it says. However, most of the time it means you made a mistake.
08:04:42 <fasta> ludflu: You are e.g. adding two lists.
08:04:51 <pao> int-e: let me try that code, I suspect it doesn't compile
08:05:09 <fasta> ludflu: There is no instance for Num to do that, so, you will have to either write an instance which does that, or not do that.,
08:05:18 <pao> hmmm ... it does compile
08:05:19 <fasta> ludflu: does that make sense to you?
08:05:50 <int-e> pao: [xs | False:xs <- xss] is the list of tails of those lists in xss that start with False.
08:06:25 <int-e> pao: pretty much the same as map tail (filter (\xs -> not (null xs) && head xs == False) xss)
08:06:29 <ludflu> well, not exactly. whats the best way to paste the context of the problem in here?
08:06:56 <int-e> pao: the filter is implemented by the pattern match. (if the pattern match fails, the list element is not processed)
08:07:04 <pao> int-e: yep ... it's clear what the final goal is...
08:07:24 <fasta> ludflu: the best way is to create something of at most 10 lines and paste it at hpaste.org
08:07:40 <fasta> ludflu: make it the minimal amount of effort for people to help you.
08:07:45 <pao> ahhh!
08:07:48 <pao> int-e: got it
08:07:54 <orclev> is there such a beast as untilM?... I'm trying to use until to do something, but the function I'm trying to use is inside IO
08:07:55 <int-e> ludflu: you may get a batter error message if you write [(1 :: Integer) .. 9] (or possibly Int instead of Integer)
08:08:18 <int-e> better. (urgh)
08:08:33 <ludflu> int-e: thanks. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11208#a11208
08:08:47 <pao> int-e: I was mistakenly associating "| True" with xs: "xs | True"...
08:08:56 <Scriptor> hey everyone, learning haskell here, is there anything like foldr1 but instead of just using the last element of the list as the accumulator start it puts that last element in a list of its own?
08:09:36 <int-e> ludflu: the lookup x y is wrong, and by the type of lookup, the compiler thinks that x is a list of pairs (x :: [(a, b)])
08:09:42 <Twey> Scriptor: No.  â˜º
08:10:01 <Scriptor> aww
08:10:02 <int-e> ludflu: err
08:10:03 <ludflu> int-e: thank you
08:10:07 <int-e> ludflu: y, not x.
08:10:15 <orclev> Scriptor: what would the return type of that look like? (a, [a])?
08:10:22 <Twey> Scriptor: What are you doing?  Perhaps there's a better way.
08:10:40 <Twey> orclev: [a]
08:10:55 <pao> int-e: thanks
08:11:06 <Scriptor> twey: trying to implement intersperse from data.list
08:11:27 <Twey> Ah â˜º
08:11:38 <Twey> Oh, no, not necessarily even [a], actually
08:11:50 <Twey> The accumulator function would just have to be [a] -> b -> b instead of a -> b -> b
08:12:04 <Scriptor> true
08:12:18 <Scriptor> but in my case it would have to be a -> [a] -> [a]
08:12:19 <Twey> Or rather [a] -> a -> b, I guess
08:12:22 <Twey> Ych
08:12:42 <Twey> Fold types confuse me :Ã¾  I always get left and right mixed up.
08:12:45 <orclev> so any suggestions on how I would do something *like* until with a function of type a -> IO a?
08:12:56 <Scriptor> intersperse can only insert the same type into a list
08:12:58 <orclev> Twey: me to
08:13:27 <Twey> :t until
08:13:28 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:13:55 <zygoloid> pao: as an alternative approach to the problem, you could implement a 'merge' for the Tries, and then use a parallel monoidal reduce
08:14:05 <dancor> :hoogle untilM
08:14:06 <Twey> You want (a -> m Bool) -> (a -> m a) -> a -> m a?
08:14:08 <Twey> Yeah
08:14:16 <dancor> @hoogle untilM
08:14:16 <lambdabot> No results found
08:14:16 <Twey> @hoogle untilM
08:14:17 <lambdabot> No results found
08:14:18 <Twey> Heh
08:14:19 <dancor> heh
08:14:20 <orclev> Twey: yes, but untilM doesn't exist
08:14:23 <Twey> Oh
08:14:28 <Twey> Well, that's not too hard
08:14:41 <int-e> let untilM p f x | p x = return x | otherwise = f x >>= untilM p f? hmm, that would be (a -> Bool) -> (a -> m a) -> a -> m a
08:14:52 <orclev> I think copumpkin actually helped me write an untilM once before, but I can't seem to find that code anywhere
08:15:00 <pao> zygoloid: interesting...
08:15:01 <orclev> or something similar to it
08:15:09 <ludflu> int-e: I think my mis-typing is an imperative programming hangover...
08:15:25 <pao> zygoloid: are there alreading generic implementations of monoidal parallel reduce?
08:15:48 <Twey> untilM cond trans val = do { case cond val of True -> return val; False -> untilM cond trans =<< trans val }
08:15:51 <zygoloid> pao: i'd certainly expect there to be. there's almost certainly one in the mapreduce package on hackage :)
08:15:55 <Twey> Oh
08:15:56 <Twey> Er
08:16:04 <pao> zygoloid: thanks!
08:16:07 <int-e> ludflu: that's ok - thos error messages are odd at first - it's hard to understand where ghc gets the idea that a list of pairs should be a number.
08:16:09 <pao> @hackage mapreduce
08:16:10 <lambdabot> http://hackage.haskell.org/package/mapreduce
08:16:13 <Twey> untilM cond trans val = do { pass <- cond val; case pass of True -> return val; False -> untilM cond trans =<< trans val }
08:16:53 <hackagebot> type-settheory 0.1.1 - Type-level sets and functions expressed as types (DanielSchuessler)
08:17:21 <int-e> ludflu: the general advise is to add explicit type signatures - they help moving the error to the actual mistake in the code.
08:17:32 <zygoloid> pao: i think i was thinking of Holumbus-MapReduce, which doesn't actually look right :(
08:18:03 <int-e> Twey: what is wrong with if? :)
08:18:04 <pao> zygoloid: I've found Holumbus... why doesn't it look right?
08:18:44 <Twey> int-e: Don't know :Ã¾
08:19:01 <Twey> untilM cond trans val = do { pass <- cond val; if pass then return val else untilM cond trans =<< trans val }
08:19:35 <Twey> untilM cond trans val = cond val >>= (return val ?? untilM cond trans =<< trans val)
08:19:47 <FunctorSalad> is there a package with a "Finite Type" class?
08:19:51 <Twey> (y ?? n) p = if p then y else n
08:20:16 <int-e> bool y n p = if p then y else n -- in analogy to maybe and either
08:20:42 <Twey> Yeah.  I prefer the operator, though.
08:20:52 <int-e> oh and my bikeshed shall be painted blue with tiny silver stars :)
08:20:57 <Twey> It's useful enough to deserve it.  :Ã¾
08:20:58 <Twey> Hahaha
08:23:24 <orclev> I can't understand why untilM isn't part of Control.Monad at least, it seems like a really useful function to have
08:23:45 <Twey> More useful than until, perhaps
08:23:52 <orclev> definitely
08:24:19 <allbery_b> propose it on libraries@
08:24:22 <orclev> untilM is practically all you need to implement a basic IO loop
08:25:04 <allbery_b> (the answer to a lot of those questions is they show up on -cafe, are discussed for a while, then nobody actually proposes them to libraries@)
08:25:18 <Twey> int-e: I think for proper analogy with maybe, you need: bool y n v = if v then y v else n v
08:25:24 <orclev> hmm, I didn't even know there was a libraries@ list
08:25:30 <Twey> Hm
08:25:33 <Twey> But that's not so useful
08:25:36 <int-e> Twey: nope. those are nullary constructors, like Nothing.
08:25:43 <int-e> @type maybe
08:25:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:26:03 <Twey> You'd want bool y n p v = if p v then y v else n v
08:26:13 <int-e> right
08:26:19 <int-e> but you can eta-reduce that
08:26:28 <int-e> hmm
08:26:37 <int-e> no, now I was too quick.
08:26:51 <int-e> I really wanted what I wrote :)
08:27:05 <Twey> Hehe.
08:27:13 <Twey> No eta-reduction?  :<
08:27:15 <int-e> and I can get your version using  bool (y True) (n False)
08:27:29 <Twey> Nay
08:27:34 <int-e> oh
08:27:36 <ludflu> int-e: thanks so much! Its working as I expected now. Its my first nontrivial haskell program. (Non-trivial for me anyway). A new haskell geek is born.
08:27:42 * int-e shuts up.
08:28:02 <Twey> v :: a, y :: a -> b, n :: a -> b, p :: a -> Bool
08:28:07 <int-e> Twey: ok, here's what you did
08:28:31 <int-e> Twey: you implemented boolM :: m Bool -> m a -> m a -> m a, specialized to m = Reader b
08:28:38 <Twey> Haha
08:28:40 <Twey> Cute
08:28:43 <Twey> You're right
08:28:47 <Twey> That's awesome.  :Ã¾
08:28:52 <Twey> Or maybe it's boolA
08:30:34 <int-e> Twey: No, Applicative is not enough to skip one of the evaluations.
08:30:41 <Twey> Arrow
08:30:45 <int-e> oh
08:31:41 <Twey> (yeah, that's confusing â€” we need new conventions in #alt-stdlib)
08:31:42 <int-e> Hmm. ArrowChoice.
08:32:00 <Twey> Ah, yeah.
08:32:36 <Twey> Hm
08:32:44 <Twey> No, I don't think so
08:32:53 <int-e> @type arr (\c -> if c then Left () else Right ()) >>> ?f +++ ?g
08:32:54 <lambdabot> forall (cat :: * -> * -> *) c c'. (ArrowChoice cat, ?f::cat () c, ?g::cat () c') => cat Bool (Either c c')
08:33:05 <Twey> Ah
08:33:13 <Twey> That's more general, allowing different types
08:33:32 <Twey> But requires an either or something to get it out of the either
08:33:35 <Twey> So it's a bit redundant :Ã¾
08:33:46 <Twey> s/of the either/of the Either/
08:33:53 <int-e> @type arr (\c -> if c then Left () else Right ()) >>> ?f ||| ?g
08:33:54 <lambdabot> forall (cat :: * -> * -> *) c. (ArrowChoice cat, ?f::cat () c, ?g::cat () c) => cat Bool c
08:34:03 <int-e> my bad
08:37:48 <int-e> :t (\p a b -> (p &&& arr id) >>> arr (\(p, v) -> if p then Left v else Right v) >>> a ||| b)
08:37:49 <lambdabot> forall (cat :: * -> * -> *) a c. (ArrowChoice cat) => cat a Bool -> cat a c -> cat a c -> cat a c
08:38:04 <int-e> Twey: I think that's what we really wanted.
08:38:35 <Twey> Yes.  That's clearly the simplest and most obvious solution to the problem.
08:38:45 <Twey> A wonder it wasn't the first thing I came up with, really.
08:38:55 <Twey> Must be the heat.
08:39:36 <Twey> Woah.  Something just happened to Freenode.
08:39:41 * Baughn wonders if seven language extensions is enough
08:39:52 * int-e wonders whether all those cats are purring.
08:39:59 <Twey> Hehe.
08:41:16 <FunctorSalad> enough for what?
08:41:34 <fnord123> Is there a way around the bug where a 'type' alias doesn't carry the instance classes with it? e.g. if I alias Data.Map and then try to use the fact that it is an instance of Show, it doesn't appear to work.
08:42:12 <FunctorSalad> fnord123: it should
08:42:24 <FunctorSalad> maybe some other problem
08:43:14 <zygoloid> pao: we're looking for something like 'mconcatPar :: Monoid m => [m] -> m'; Holumbus gives us a big ugly IO interface :)
08:43:28 <zygoloid> pao: sorry for the delay btw, internet connection issues
08:43:56 <pao> zygoloid: thanks a lot! ... and no prob for the delay :-)
08:44:20 <zygoloid> i'm pretty sure /someone/ will have already written such a thing, though :)
08:44:39 <pao> zygoloid: mconcatPar should be easy to implement ... maybe it could be parametrized by the level of parallelism...
08:45:46 <dcoutts> I'm not sure mconcatPar on lists is quite right
08:46:24 <dcoutts> you want it to be over any traversable, so you can use it with data structures that are less inherently sequential
08:46:42 <pao> dcoutts: why so?
08:46:42 <pakaran> hi
08:46:50 <pakaran> just thought i'd stop in for advice
08:46:54 <pao> dcoutts: clear
08:47:09 <dcoutts> erm, I mean Foldable, not Traversable
08:47:10 <FunctorSalad> so you don't have to sequence your tree into a list first I suppose
08:47:23 <dcoutts> and so there's potentially more parallelism
08:47:27 <pakaran> i'm considering learning haskell as a free time project, because i've been told by several people that it will make me a better programmer, but i'm not convinced i have the right sort of brain for it.
08:47:56 <Vanadium> pakaran: This channel is very helpful to growing the sort of brain that is required, so no worries
08:47:57 <pakaran> any suggested starting points?  other than run while you still can and hope gcc is still there?
08:47:59 <Vanadium> for*
08:48:01 <dcoutts> pakaran: it's not about the right sort of brain, it's about spending a little time to learn to think differently
08:48:22 <pakaran> thanks.
08:48:29 <pakaran> i'll try to proceed with that assumption :)
08:48:39 <fnord123> FunctorSalad: ok I made a minimal test that seems to work. I found my own bug. whoops :(
08:48:44 <pakaran> it somewhat worries me that i've heard the same thing from people who can draw.
08:48:49 <dcoutts> pao: parFold :: (Foldable t, Monoid m) => t m -> m
08:49:20 <zygoloid> dcoutts: isn't Foldable inherently sequential too?
08:49:24 <dcoutts> pao: though it's less clear how to control the level of parallelism
08:49:27 <pao> dcoutts: that would be the ideal signature or is it implemented somewhere?
08:49:33 <dcoutts> zygoloid: it depends on the instance
08:49:45 <dcoutts> pao: that is fold from Data.Foldable
08:50:06 <zygoloid> dcoutts: as i understand it, the interface it gives you is effectively foldr, right?
08:50:08 <pao> dcoutts: yep with fold but... parFold?
08:50:16 <FunctorSalad> zygoloid: foldMap too
08:50:25 <FunctorSalad> @type foldMap
08:50:26 <lambdabot> Not in scope: `foldMap'
08:50:30 <FunctorSalad> @type Foldable.foldMap
08:50:31 <lambdabot> Couldn't find qualified module.
08:50:35 <FunctorSalad> @type Data.Foldable.foldMap
08:50:36 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
08:50:39 <FunctorSalad> ..
08:50:50 <zygoloid> FunctorSalad: ah, right :) that helps
08:50:51 <dcoutts> zygoloid: it gives you something somewhat more general than that
08:51:08 <zygoloid> although for a list that'd do entirely the wrong thing :)
08:51:26 <zygoloid> (I'm guessing that's implemented with foldr for lists)
08:51:49 <dcoutts> pao: I'm just trying to think if one could implement parFold in terms of fold, or if each Foldable instance needs to do something special
08:52:14 <zygoloid> or at least you still need the complexity of 'doing it right' for lists, plus foldMap for additional concurrency if there's any to be had
08:52:50 <FunctorSalad> foldMap f = foldr (\x r -> f x `mappend` r) -- why not?
08:52:59 <FunctorSalad> (for lists)
08:53:15 <Scriptor> great, my cs prof got how break statements work in java wrong
08:53:25 <pao> dcoutts: nice problem :-)
08:53:48 <dcoutts> pao: how about a monoid type that wraps another monoid and evaluates both args in parallel before doing the monoid composition?
08:53:51 <int-e> Scriptor: that wouldn't have happened to him with Haskell :)
08:54:20 <pao> dcoutts: yep... certainly feasable...
08:54:38 <Scriptor> int-e, hah, yea she asked us how we'd check 1 row for a bingo game, so for fun I wrote it in haskell
08:55:08 <dcoutts> pao: since that's doing it from the "inside" you get no special knowledge about granularity of parallelism that you might get if you can see the tree structure and can tell if you're now very near to the leaves
08:55:31 <int-e> Scriptor: how about "I just glimpse at the paper, it's usually obvious at first sight."? :-)
08:55:58 <pao> dcoutts: yep, that's why Foldable is not enough... what about Traversable?
08:56:09 <Scriptor> nah
08:56:34 <Scriptor> that's just ridiculous, how could you possibly check that when you might have as many as 2 elements?
08:56:54 <dcoutts> pao: doesn't help much, it's for a different thing
08:58:16 <pao> dcoutts: if traversable could provide a way to Traversable a -> Traversable (Foldable a) ... to group
08:59:06 <Axman6> urgh, looks like reddit's died
08:59:52 <Axman6> and it's back
09:00:09 <int-e> way of getting my hopes up ;)
09:00:27 <zygoloid> i suspect you could make a Par monoid transformer which would automatically paralellize mappend
09:02:06 <benmachine> I can see parallelsing let (++) = mappend in a ++ b ++ c ++ d
09:02:24 <benmachine> but surely parallelising a single mappend would depend on the implementation
09:02:56 <fnord123> > read "hello" :: ByteString
09:02:57 <lambdabot>   Not in scope: type constructor or class `ByteString'
09:02:57 <zygoloid> benmachine: right, you want to parallelize a bunch of mappends in a way which shares the load as evenly as possible
09:03:04 <fnord123> > read "hello" :: Data.ByteString
09:03:04 <lambdabot>   Not in scope: type constructor or class `Data.ByteString'
09:03:31 <Baughn> > read "hello" :: Data.ByteString.ByteString -- but I don't think ByteString is an instance of Read anyhow.. is it?
09:03:32 <lambdabot>   Not in scope:
09:03:32 <lambdabot>    type constructor or class `Data.ByteString.ByteString'
09:03:40 <benmachine> that doesn't sound like a monoid wrapper to me
09:03:58 <fnord123> It is a member of Read.
09:04:07 <Baughn> fnord123: I'm afraid there isn't much call for binary I/O in lambdabot, though. :P
09:04:17 <benmachine> it sounds something like parFold (x:y:ys) = let r = mappend x y in r `par` mappend r (parFold ys)
09:04:50 <fnord123> Sure, well I'm curious why (Read a) => String -> a here where a is Data.ByteString wouldn't do the obvious "hello" -> Data.ByteString version
09:05:16 <tibbe> Are there any good instructions for installing GHC on Windows? I remember having to muck around with msys et al.
09:05:18 <benmachine> read is usually designed to be the inverse of show
09:05:54 <FunctorSalad> left-inverse
09:06:07 <benmachine> oh bytestring shows like that
09:06:18 <benmachine> fnord123: note that show of a bytestring is surrounded by quotes, though
09:06:19 <Baughn> fnord123: Hm? Does here..
09:06:27 <benmachine> it's like
09:06:31 <benmachine> > read "hello" :: String
09:06:32 <lambdabot>   "* Exception: Prelude.read: no parse
09:06:33 <benmachine> doesn't work
09:06:43 <benmachine> > read "\"hello\"" :: String
09:06:43 <Baughn> Oh, right. That.
09:06:44 <lambdabot>   "hello"
09:06:44 <benmachine> tada
09:06:47 <zygoloid> benmachine: something like "parFold [] = mempty; parFold [x] = x; parFold (x:y:xs) = let ys = (let r = x `mappend` y; s = parFold xs in r `par` s `pseq` r:s) in ys `pseq` parFold ys" ?
09:06:57 <Olathe> tibbe: Have you tried http://www.haskell.org/ghc/download_ghc_6_10_4.html#windows ?
09:07:03 <zygoloid> benmachine: why not a Monoid wrapper? it'd seem like a more composable solution
09:07:05 <fnord123> ha! using \" to surround my text worked
09:07:10 <Baughn> fnord123: I'd suspect bytestring's show/read instance is implemented via Bytestring.Char8's pack/unpack. :P
09:07:27 <benmachine> zygoloid: it sounded to me like you needed more information than just the two things you mappend
09:07:29 <Baughn> Except it then goes on to show a String
09:07:44 <Baughn> ..bit silly, but too late to change it now
09:07:52 <benmachine> but, you are obviously better at parallel than me so I will be quiet :)
09:07:56 <Baughn> Or.. hm. If it wasn't quoted, the parser wouldn't know where to stop
09:07:59 <zygoloid> benmachine: you do. the wrapper would probably also need to store a current 'depth of appending' or similar, and a tree of values-not-yet-appended
09:08:11 <benmachine> ah
09:08:23 <tibbe> Olathe: yes, but it turns out that you need msys etc after all, to run things like configure
09:08:24 <fasta> tibbe: the platform is supposed to work now.
09:08:26 <zygoloid> essentially it'd be equivalent to parFold but done on-the-fly
09:08:29 <benmachine> I thought you just meant a newtype or something
09:08:34 <Olathe> tibbe: Ahh, OK
09:08:43 <fasta> tibbe: if you meant building, then that's a different story.
09:08:47 <tibbe> fasta: I need to build things like network which requires autoconf
09:08:53 <tibbe> fasta: yes
09:09:29 <cxv> I just got my copy of Real World Haskell. w00t!
09:09:50 <int-e> zygoloid: a case for foldb, perhaps? folb f [x] = x; foldb f xs = foldb f (pairs f xs); pairs f (x:y:xs) = f x y : pairs f xs; pairs _ xs = xs, where f is some associative operation.
09:10:03 <fnord123> Baughn: I can see that. But it's surprising from a user's point of view. (if we consider library interfaces to be like user interfaces and want to have minimal surprises). but now that I know, I can use it, it's fine. :)
09:10:07 <zygoloid> benmachine: although one implementation would be to say 'newtype Par m = Par [m] deriving (Monoid); toPar a = Par . return; fromPar (Par a) = parFold'
09:10:34 <zygoloid> int-e: that's quite nice :)
09:10:43 <Baughn> fnord123: So, how else should it be done?
09:10:44 <zygoloid> int-e: though it's more a case for foldb' :)
09:11:15 <ehamberg> does "..", as in [1..10] have a name? :)
09:11:21 <Baughn> fnord123: If you just want to convert a string to a bytestring, one of the Char8.pack or UTF-8.pack functions would be the thing
09:11:29 <zygoloid> ehamberg: enumFromTo :)
09:11:56 <ehamberg> zygoloid: thanks. :)
09:12:09 <fnord123> Baughn: a string can be maximally munched into a bytestring. I can see why you would want some delimitation in some uses but those seem like outliers to the main use of converting the whole string
09:12:11 <zygoloid> > let (...) = enumFromTo in 1...10
09:12:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:12:30 <ehamberg> aha :)
09:13:01 <shaniaki> Hi, anyone knows where did "Distribution.Simple.SetupWrapper" go since Cabal-1.6.0.1? I have an old code and I have problems updating it with the new packages.
09:13:12 <tibbe> cxv: enjoy
09:13:55 <Baughn> fnord123: Part of the specification of Show/Read is that it mustn't over-read. Usually that's handled by stopping on a simple space, but.. do you prefer quoting spaces, or quite marks?
09:15:09 <fnord123> overread what?
09:15:58 <fnord123> I mean I know what you mean but I think the tao of Show/Read isn't what I thought it would/should be.
09:16:33 <fnord123> 'show prints everything. read should try to read everything' is how I would have thought it would be designed.
09:16:57 <quicksilver> show converts things to a haskell source format
09:17:09 <quicksilver> read, therefore, respects haskell source lexical conventions
09:17:35 <ben_m> I'm still on my journey to understand Applicative Functors ... I think I know what they do, I just don't know how they're useful or a better alternative to the do-notation. Anyone nice enough to clarify? :)
09:18:18 <burp> yes
09:18:18 <Baughn> fnord123: Consider how Show/Read work for complex (data) types
09:18:27 <burp> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
09:18:46 <ben_m> Funny, just browsed to that site a couple seconds ago.
09:18:48 <ben_m> Will read.
09:21:34 <fnord123> yes I understand the issue with complex (data) types.
09:21:48 <zygoloid> ben_m: some Applicatives aren't Monads (ZipList, for instance). even when they are / could be, sometimes using <*> rather than >>= allows a more efficient implementation (in parsers it allows building tables, for instance). sometimes the applicative notation is easier to read.
09:23:04 * Axman6 can somewhat see the beauty of...
09:23:45 <Axman6> > (,,) <$> "hello" <*> [1,2,3] <*> [Just 4, Nothing]
09:23:46 <lambdabot>   [('h',1,Just 4),('h',1,Nothing),('h',2,Just 4),('h',2,Nothing),('h',3,Just ...
09:25:16 <mightybyte> Is there a way to download the Haskell Hierarchical Library documentation so I can have a local copy for offline viewing?
09:25:33 <zygoloid> ben_m: Axman6's example in do-notation: 'do a <- "hello"; b <- [1,2,3]; c <- [Just 4, Nothing]; return (a, b, c)'. much more verbose...
09:25:46 <Saizan_> mightybyte: it's usually shipped with ghc
09:26:06 <zygoloid> ben_m: that said, there was a suggestion on -cafe recently that we should have a do-notation for applicatives
09:26:06 <mightybyte> Saizan_: Oh, where is it stored?
09:27:24 <mightybyte> Saizan_: Never mind, I just found it in /usr/share/doc/ghc/libraries/index.html
09:28:38 <ben_m> zygoloid: I don't even understand what exactly happens in your do-notation example (or rather, why the output isn't ("hello", [1,2,3], [Just 4, Nothing]) )
09:29:29 <merijn> Hmm, if array update is O(n) because of immutability how is this problem avoided to give FiniteMaps a O(log n) update?
09:29:58 <Axman6> dose finite maps use arrays?
09:30:02 <zygoloid> ben_m: the [] monad and applicative instance essentially model a backtracking search. so "a <- xs" means something like 'for each a in xs'
09:30:06 <Saizan_> they are trees
09:30:11 <null_ptr> he. I guess somebody can help me with my first steps in functional programming (Coming from C, Java, etc.., it's quite annoying so far..) Here is the code: http://paste.bradleygill.com/index.php?paste_id=23556 Error msg is: Couldn't match expected type `(a1 -> a1 -> a1) -> Integer -> a' against inferred type `Integer'
09:30:18 <ben_m> zygoloid: so it's a bit like in list comprehensions?
09:30:27 <zygoloid> ben_m: it's /exactly/ list comprehensions :)
09:30:31 <ben_m> Oh :)
09:30:51 <zygoloid> ben_m: in an old old version of haskell, the list comprehension notation was used for all monads
09:30:52 <Saizan_> merijn: since they are trees and not flat structures the new map can share most of the nodes with the old map you're inserting to
09:30:53 <Olathe> null_ptr: You need x `mod` y (with the backticks).
09:30:56 <ben_m> Can monad instances decide what happens at a <- foo?
09:31:23 <aavogt> null_ptr: also your guards are redundant
09:31:25 <Olathe> null_ptr: Or mod x y (functions come first, then arguments).
09:31:38 <zygoloid> ben_m: essentially, yes. that's what >>= is. it says, given foo, and (stuff to do next, which uses the value of a), decide what to do.
09:31:38 <Axman6> ben_m: do { x <- y; blah x} == y >>= blah
09:31:39 <Saizan_> merijn: you only have to rebuild the nodes from the root to where you're inserting the new value
09:31:57 <aavogt> since (x `mod` y == 0) is a Bool that's the same as the output of your function
09:31:59 <null_ptr> works, thx. What means my guards are redundant?
09:32:28 <ben_m> Axman6: Oh yeah, thanks. I knew that already, but forgot about it again :/
09:32:35 <merijn> Saizan_: Oh yeah, I forgot. Makes sense
09:32:36 <aavogt> so you can write (divides x y = x `mod` y == 0
09:34:02 <Axman6> null_ptr: what you've written is basically: if x then True else False
09:34:19 <Axman6> which is exactly the same as x
09:34:26 <aavogt> )
09:34:34 <null_ptr> aavogt: ah, I see: x `mod` y == 0 is the statement which is true or false..
09:34:35 <Axman6> @check \x -> if x then True else False == x
09:34:35 <lambdabot>   "OK, passed 500 tests."
09:35:05 <zygoloid> @type (\x -> x, \x -> if x then True else False)
09:35:06 <lambdabot> forall t. (t -> t, Bool -> Bool)
09:35:21 <aavogt> but for learning how guards (the | after a pattern) work, that's a fine example
09:35:48 <fasta> Guards kill the "everything is an expression"-idea.
09:36:12 <Saizan_> patterns too
09:36:24 <fasta> True
09:36:41 <aavogt> fasta: but you can stick guards on case expressions!
09:37:03 <fasta> aavogt: doesn't mean you have to ;)
09:37:06 <Axman6> ok, sleep time. o/
09:37:32 <null_ptr> fasta: I don't care much about style yet; I am happy to see it running, as you probably can imagine
09:37:49 <fasta> null_ptr: yes, I don't know your user name, so I can imagine.
09:39:26 <Axman6> null_ptr: what you did is a very common thing for beginners, i saw it all the time in my first year programming course. lots of peopke would write if foo then True else False, and they'd be rather happy when they relised they could save themselves a lot of time
09:39:50 <ben_m> Axman6: you said do { a <- xs; f a } == xs >>= f
09:39:56 <halcyon10> hi, a few weeks ago i came across some haskell code on a web site which visualizes the dependency of data types, function calls and some other things in arbitrary haskell code. Does anybody know what the name of the program or the website was?
09:40:08 <ben_m> I tried it with do { a <- [1,2,3]; a * 5 }
09:40:08 <Axman6> @undo do { a <- xs; f a }
09:40:08 <lambdabot> xs >>= \ a -> f a
09:40:20 <aavogt> @google vacuum haskell visualization
09:40:21 <lambdabot> http://www.youtube.com/watch?v=nQkhELdAYB8
09:40:21 <lambdabot> Title: YouTube - Vacuum: visualize Haskell data structures live in GHCi: Part 3
09:40:27 <ben_m> [1,2,3] >>= (*5) gives me a instance error
09:40:35 <ben_m> an*
09:40:35 <null_ptr> fasta: so this channel should become my haskell code bible? So I call you the prophet..
09:40:42 <Saizan_> ben_m: you lack a return
09:40:43 <Axman6> ben_m: f has to be of the right type, (*5) isn't of the type a -> [a]
09:40:47 <aavogt> halcyon10: so something like that?
09:40:54 <Saizan_> > [1,2,3] >>= return . (*5)
09:40:55 <ben_m> But it works in the do notation?
09:40:56 <lambdabot>   [5,10,15]
09:40:59 <ben_m> Oh.
09:41:05 <Axman6> ben_m: o, it doesn't
09:41:06 <maltem> > (*5) <$> [1,2,3]
09:41:07 <lambdabot>   [5,10,15]
09:41:07 <Axman6> no*
09:41:14 <fasta> null_ptr: you can call me the prophet, but there are also gods out there.
09:41:27 <Axman6> > do { a <- [1..3]; 5 * a }
09:41:28 <lambdabot>   No instance for (GHC.Enum.Enum [b])
09:41:28 <lambdabot>    arising from the arithmetic sequence...
09:41:39 <ben_m> Oh yeah, I lack a return.
09:41:51 <ben_m> Understood, thank you :)
09:42:07 <halcyon10> aavogt: yes something in that alley, but it wasn't for live object graphs if i remember correctly.
09:42:10 <Axman6> > do {x <- [1..3]; show x}
09:42:11 <lambdabot>   "123"
09:42:17 <Axman6> [1..3] >>= show
09:42:23 <Axman6> > [1..3] >>= show
09:42:24 <lambdabot>   "123"
09:43:18 <aavogt> @hackage sourcegraph -- halcyon10
09:43:18 <lambdabot> http://hackage.haskell.org/package/sourcegraph -- halcyon10
09:43:36 <aavogt> hmm, it cares about capitalization
09:43:38 <aavogt> http://hackage.haskell.org/package/SourceGraph
09:45:55 <halcyon10> aavogt: yes! that is what i was looking for, SourceGraph and Graphalyze. Thanks for the pointer!
10:08:14 <jfhall> I'm on arch x64 and readline complains about libncurses.so being too short when trying to install lambdabot from cabal, any advice?
10:08:42 <jfhall> to make that clear, I'm running arch linux
10:10:15 <Saizan> jfhall: the problem is probably that libncurses.so is a linker script
10:10:29 <Saizan> jfhall: change it into a symlink to the real lib
10:10:48 <jfhall> alright I'll check that out, thanks
10:14:35 <jfhall> Saizan: that worked, thanks a lot for the help, I couldn't find anything helpful on google, you just saved me a lot of potentially wasted time.
10:16:41 <fnord123> jfhall: I found the problem on google being discussed but no one offered solutions. :)
10:16:50 <Saizan> jfhall: np
10:18:47 * edwardk waves hello.
10:19:44 <Saizan> hi!
10:19:56 <jkramer> http://gist.github.com/219594 - is there anything that can be improved/shortened in this code?
10:20:28 <jkramer> It's just a simple tool to play around, but I'd like to hear ideas from people who know Haskell better :)
10:20:52 <jkramer> I feel like I'm still writing too much
10:21:30 <null_ptr> oh, I won't become happy with all that. I am just wondering how to do such a trivial thing like looping through a list and doing sth with every element.? Is there any how-to in the web like "Haskell for C programmer" or sth like that?
10:21:43 <Saizan> ?unpl flip (compare . snd) . snd
10:21:43 <lambdabot> (\ f c -> compare (snd c) (snd f))
10:22:06 <Saizan> that's "flip (compare `on` snd)"
10:22:33 <Saizan> null_ptr: map? mapM?
10:22:35 <edwardk> jkramer: its fairly tight
10:22:41 <Saizan> > map (*2) [1..10]
10:22:42 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
10:22:57 <Gilly> Is it possible to implement a fast search using purely functional data structures on a board game tree? I'm trying to use Array's to represent a gomoku board but it's not blazingly fast. :P
10:23:03 <Saizan> null_ptr: there is an haskell for C programmers tutorial btw
10:23:04 <Scriptor> > map (+2) [1..10]
10:23:05 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
10:23:21 <fnord123> null_ptr: I'm a C++ and C programmer originally so I come from that background. Gimme an hour and I'll chat w/ you about anything you're having trouble with.
10:23:23 <edwardk> Gilly: honestly there are faster board structures than the ones you can build up functionally.
10:23:31 <Gilly> In C I would probably use just one array and do updates / undos while searching recursively.
10:23:36 <benmachine> I learnt C first
10:24:02 <Gilly> edwardk: What do you have in mind, starrays?
10:24:16 <tromp_> st unboxed arrays
10:24:47 <edwardk> Gilly: well, in my case i'm more familiar with chessboard representations, but there are various multiple rotated-bitmask representations that are much faster than storing the pieces in arrays
10:25:13 <tromp_> gomoku is not 8x8 though:(
10:25:18 <edwardk> an stuarray is a pretty good start though
10:25:21 <edwardk> tromp_: yeah
10:25:37 <Gilly> how does these rotated-bitmask repr. work?
10:25:39 <Gilly> *do
10:26:35 <jkramer> edwardk: Seems like I don't have the Util module on belongs to
10:26:36 <Gilly> in gomoku i'll have to be able to check rows, cols and diagonals for victories (5 consecutive markers of the same colour in row)
10:26:59 <edwardk> gilly: http://www.cis.uab.edu/hyatt/boardrep.html http://www.cis.uab.edu/hyatt/bitmaps.html
10:27:26 <Saizan> jkramer: Data.Function
10:27:26 <lament> in gomoku you only have three kinds of board states, as opposed to 14 or so in chess, so representation techniques are probably different
10:27:32 <edwardk> gilly: look at the rotated bitmap stuff there, it was very good at dealing with moves. it probably doesn't adapt cleanly to gomoku
10:27:54 <jkramer> Ah, thanks
10:28:45 <null_ptr> Actually I try to compare a char with all elements in a list. If I can find that char in the list, I would like to return true..
10:29:10 <Gilly> yea, i'll have to look at those :) got to go to sauna now, i'll be back after a while
10:29:17 <jkramer> ch `elem` list
10:29:42 <Saizan> ?src elem
10:29:42 <lambdabot> elem x    =  any (== x)
10:29:45 <Saizan> ?src any
10:29:45 <lambdabot> any p =  or . map p
10:29:49 <Saizan> ?src or
10:29:49 <lambdabot> or    =  foldr (||) False
10:29:53 <Saizan> :)
10:29:53 <null_ptr> fnord123: There are not that many particular questions yet. thx
10:30:01 <Saizan> it's HOFs all the way down!
10:30:13 <mightybyte> edwardk: Are you familiar with the magic bitboard representations?
10:31:03 <null_ptr> Saizan: I found it. Thanks
10:31:53 <tromp_> my bitboards in connect-4 can test for a win with 8 shifts+ands
10:32:17 <zygoloid> tromp_: crikey, that's cool :)
10:32:33 <tromp_> testing 5 in a row would take a total of 12 shifts/ands
10:32:55 * dancor regrets using try and notFollowedBy for tokens
10:33:23 <tromp_> but with the board being larger than 8x8, you'd need to shift 256 bits
10:33:42 <tromp_> see http://www.cwi.nl/~tromp/c4/Connect4.java
10:34:55 <dancor> you are still likely to get speed benefits for the same kinds of tests even with large boards right?
10:35:16 <dancor> multi-dword bit-operations can't be that expensive
10:35:39 <tromp_> you just don't want to do them at the source level
10:35:52 <tromp_> best if you can use a library for bigwords
10:36:20 <dancor> ya
10:37:07 * dancor wonders if gnugo uses bitboards
10:38:11 <edwardk> back, was afk
10:38:18 <dancor> 19x19 is only three 128bit dqwords long.  MMX does dqword bit operations iirc..
10:38:59 <dancor> s/MMX/SSE/
10:39:18 <edwardk> mightybyte: i've seen the magic bitboard stuff for bishop moves, etc, but i haven't dug in too deep
10:40:26 <dancor> actually bitboards are probably not useful in go
10:40:27 <tromp_> i think gomoku uses a 15x15 board
10:40:39 <tromp_> although go boards are easier to come by:)
10:40:39 <dancor> http://en.wikipedia.org/wiki/Gomoku
10:40:44 <jkramer> ?src error
10:40:44 <lambdabot> error s = throw (ErrorCall s)
10:40:45 <dancor> says traditionally 19x19
10:41:09 <dancor> but later shows 15x15 examples heh
10:41:10 <HayashiRazan> ?src error
10:41:10 <lambdabot> error s = throw (ErrorCall s)
10:41:16 <HayashiRazan> :t add
10:41:17 <lambdabot> Not in scope: `add'
10:41:33 <HayashiRazan> :t dancor
10:41:34 <lambdabot> Not in scope: `dancor'
10:41:59 <dancor> http://en.wikipedia.org/wiki/Connect6
10:42:37 * dancor is IO ()
10:43:08 <dancor> :t undefined :: Garbage -> Garbage
10:43:09 <lambdabot>     Not in scope: type constructor or class `Garbage'
10:43:09 <lambdabot>     Not in scope: type constructor or class `Garbage'
10:43:27 <Zao> sequence_ $ repeat dancor
10:43:56 <Twey> process = id :: Garbage -> Garbage
10:43:56 <Gilly> I think I'll go for the STArray for now.
10:44:27 <Gilly> I already implemented a simple Monte-Carlo AI using Data.Array but they are a bit slowish :)
10:44:58 <luite> I have a program that uses some ffi, which I compile with: ghc --make -lClp -lCoinUtils -lstdc++ Test.hs Lp\lp.o
10:45:25 <luite> but I want to run it in ghci, modifying the cmdline to: ghci -lClp -lCoinUtils -lstdc++ Test.hs Lp\lp.o  gives the following error:
10:45:44 <luite>  Unknown PEi386 section name `/22' (while processing: Lp\lp.o)  Loading object (static) Lp\lp.o ... : panic! (the 'impossible' happened)
10:45:47 <hackagebot> gps 0.3.1 - For manipulating GPS coordinates and trails. (ThomasDuBuisson)
10:46:41 <luite> what could be wrong (or is this not supported in ghci?)
10:47:38 <edwardk> Gilly: ST or STUarray?
10:47:47 <Gilly> edwardk: STUArray
10:47:49 <edwardk> Gilly: STUArrays make a huge difference
10:47:51 <edwardk> k =)
10:48:06 <tromp_> with bitboards, a board is just a pair of 2 bigwords, which you can just copy down the tree
10:48:27 <Gilly> well yea, i liked that idea... wouldn't have to go monadic
10:48:56 <Gilly> but i think the board operations are going to take more time than simply accessing memory (like when using stuarrays)
10:49:19 <Gilly> not sure though - i'm not an expert in this area
10:50:49 <Saizan> accessing memory is one of the slowest thing you can do on a CPU
10:51:07 <Saizan> that's why caches are so important
10:51:35 <int-e> <half-troll>That's why Haskell is so slow</half-troll>
10:51:43 <Gilly> gah :P
10:52:30 * scree hopes a 19x19 bool grid fits in a pretty good cache
10:52:46 <Gilly> but i would do excessive shifting and stuff when using bitboards, right? i mean - how many such operations can i afford in comparison to one lookup / set in memory? (also can stuarray become cached?)
10:53:14 <Saizan> int-e: heh
10:53:33 <edwardk> Gilly: the trick is that with bitboards you can often get creative and check -multiple moves- with one set of bit operations.
10:53:51 <edwardk> whereas with an array representation you can at most check one move at a time
10:54:32 <edwardk> the nice thing about the crafty bitboard stuff i sent or the magic number stuff mightybyte was talking about was that they check all moves in one pass.
10:54:46 <Gilly> edwardk: huh, can you give me a simple example?
10:55:11 <Gilly> or maybe i should just read through that link you gave me :)
10:55:24 <dancor> in parsec2, is going from [Char] to [Word8] tokenstream likely to be substantial speed increase?
10:55:51 <edwardk> Gilly: http://www.cis.uab.edu/hyatt/bitmaps.html look at figure 8,9,10
10:56:47 <edwardk> Gilly: the computation of figure 9 is done in one set of operations, using the the position of the rook in figure 8 and the bitmask of the pieces from figure 8.
10:57:09 <edwardk> Gilly: note the result is a mask that represents all of the positions the rook could move to, not any one particular move.
10:57:31 <edwardk> Gilly: so you can play games intersecting and unioning whole move sets rather than just work one move at a time
10:57:43 <edwardk> Gilly: that is the advantage of bitboard/magic # representations.
10:57:53 <Saizan> dancor: i doubt it
10:58:52 <Saizan> dancor: you're not saving memory since the Word8 is boxed
10:59:17 <edwardk> dancor i wouldn't expect to see any speedup at all.
10:59:24 <dancor> mm
11:00:42 <dancor> i'm spending a lot of time parsing identifiers
11:01:35 <Gilly> edwardk: mmm, i kinda see how this could be applied to gomoku (maybe) :)
11:02:54 <hackagebot> control-monad-exception 0.4.7 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
11:03:53 <dancor> i guess ideally i would never go over a character twice.  but then i think i would need a crazy dfa of reserved words
11:04:16 <dancor> well trie
11:04:17 <Raevel> @hoogle sslConnect
11:04:18 <lambdabot> No results found
11:05:28 <Jafet> makeDFA :: [String] -> DFA, go
11:05:45 <dancor> technology
11:06:05 <ystael> Jafet: for some reason i envisioned that as a challenge on Iron Chef Haskell
11:06:39 <dancor> your mystery ingredient is stack overflow
11:09:33 <zygoloid> dancor: i have a function somewhere which you give a list of reserved words to and it gives you back an identifier/reserved word/operator parser
11:10:02 <zygoloid> dancor: i got about half-way to making it run at compile-time with TH before i got distracted
11:10:55 <dancor> ya
11:11:41 <dancor> i guess the real problem is that i need a shallow lexing step
11:12:05 <dancor> and i should use a cool func like that to do the lexing step also
11:24:26 <dancor> hm 'cabal install takusen' then 'cabal install takusen -f postgres' complains about reinstalling
11:25:07 <dancor> also can you make another cabal package depend on takusen -with-the-postgres-flag-
11:25:38 <dcoutts> dancor: no, and that's why packages must not change their interfaces based on flags.
11:25:50 <dcoutts> ie takusen is doing it wrong
11:26:08 <tommd> bad takusen!
11:26:23 <dancor> mm
11:27:00 <dcoutts> see for example how HDBC does it
11:30:45 <luite> does anyone know an automatic diffentiation thing that generates new source code for the differentiated functions?
11:32:10 <dancor> luite: what do you mean?
11:33:39 <luite> dancor: well most AD things in haskell (at least the ones being blogged about and the FAD package on hackage) have some kind of dual number type class that implements Num and a few other classes
11:36:22 <hackagebot> control-monad-exception 0.4.8 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
11:36:35 <Jafet> You still haven't said what you mean by differentiation
11:37:26 <maltem> Most AD things in Haskell make me wonder what people whose research interest is entitled as AD are doing all day long
11:38:00 <luite> Jafet: oh sorry, that's just the differentation you know from calculus, for example for a f::Double -> Double function, f x gets the value of f at x, (diff f) x  the value of the derivative
11:38:38 <luite> automatic differentation automatically generates this function
11:39:09 <luite> (and you can of course generalize this to gradients or jacobians)
11:39:47 <Jafet> autoDiff :: (Double -> Double) -> (Double -> Double); autoDiff f = \x -> numericDiff f x
11:40:00 <Jafet> Which collapses to autoDiff = numericDiff
11:40:50 <Saizan> automatic differentiation is usually symbolic by exploiting the typeclasses
11:41:28 <luite> Jafet: automatic differentiation applies the chain rule (in some order), its different from numerically differntiating with a small step
11:41:49 <Saizan> luite: i guess you could make a similar instance that produces TH's Exp and then splice
11:41:49 <Jafet> Oh, I see what FAD does thar
11:41:58 <FunctorSalad> hmm the hackage build bot doesn't take into account your extra-source-files eh?
11:42:41 <luite> Saizan: hm, that would be a good idea
11:42:57 <luite> problem is that I don't know TH. solution is to learn it ;)
11:46:27 <luite> or perhaps I should move this part of my code to C, where 'real' AD tools are available
11:46:47 <luite> (although much uglier, of course)
11:48:17 <luite> what's a good introduction to TH?
11:48:19 <FunctorSalad> luckily you disguise your CPP definition files as Haskell modules... :>
11:48:22 <FunctorSalad> *can
11:48:30 <null_ptr> thank you for your help. bye
11:51:01 <luite> FunctorSalad: the problem is that it's this part of the code that the user sees (It's an optimizer for a quasiconvex programming problem for some function (which is of the form \x -> maximum $ map ($x) subfuncs, subfuncs is a looooooong list))
11:51:35 <luite> I can now specify the functions in haskell in a clear and concise way
11:52:51 <FunctorSalad> luite: I wasn't replying to you :)
11:52:59 <luite> oh sorry :p
11:54:25 <hackagebot> type-settheory 0.1.2 - Type-level sets and functions expressed as types (DanielSchuessler)
11:54:29 <FunctorSalad> I was just remarking that if you turn your #included files into a bogus haskell modules, the hackage build bot will presumably make sure the file is there
11:55:25 <hackagebot> Consumer 1.2 - A monad and monad transformer for consuming streams (JeremyShaw)
11:58:09 <Botje> aww, i'd have liked a typeset-theory :)
11:58:29 <copumpkin> zomg now we know FunctorSalad's real name!!
11:59:08 <Yacoby> Ok, stupid question. Is there a better way to convert from a Bool to an Integer than using an if statement?
11:59:22 <copumpkin> you mean to 0/1?
11:59:28 <Yacoby> Yeah
11:59:30 <copumpkin> > fromEnum True
11:59:31 <lambdabot>   1
11:59:33 <copumpkin> > fromEnum False
11:59:34 <lambdabot>   0
11:59:40 <Saizan> that's Int though
11:59:46 <copumpkin> oh
11:59:53 <Yacoby> Int is not a problem :)
11:59:59 <Yacoby> thanks
12:00:04 * copumpkin sticks his tongue out at Saizan
12:00:23 * Saizan feels tremendously offended
12:00:27 <hackagebot> URLT 0.10 - Library for maintaining correctness of URLs within an application. (JeremyShaw)
12:00:39 <Saizan> yay for URLT
12:00:51 <copumpkin> ?
12:01:26 <copumpkin> preflex: seen edwardk
12:01:26 <preflex>  edwardk was last seen on #haskell 1 hour, 2 minutes and 8 seconds ago, saying: dancor i wouldn't expect to see any speedup at all.
12:03:48 <tommd> preflex: seen preflex -- seeing as Haskell is lazy and can have infinite strings it should result in:
12:03:48 <preflex>  what
12:03:48 <tommd> "preflex: preflex was last seen now saying "preflex was last seen now saying "preflex was last seen now saying "preflex was...
12:03:49 <dancor> urly would be a cooler name
12:04:18 <monochrom> urly
12:04:21 <dancor> rly
12:05:18 <zygoloid> is preflex even written in haskell?
12:05:55 <copumpkin> you should ask its daddy
12:07:03 <zygoloid> preflex: in what language are you written?
12:07:42 <copumpkin> preflex: who's your dady?
12:07:51 <FunctorSalad> preflex: help
12:07:51 <preflex>  try 'help help' or see 'list' for available commands
12:07:56 <FunctorSalad> preflex: help help
12:07:56 <preflex>  help COMMAND - show help for a command
12:08:01 <copumpkin> preflex: 6st 4
12:08:02 <preflex>  4th
12:08:04 <zygoloid> preflex: list
12:08:04 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
12:08:06 <copumpkin> preflex: 6st 5
12:08:07 <preflex>  5th
12:08:30 <hackagebot> happstack-facebook 0.9 - A package for building Facebook applications using Happstack (JeremyShaw)
12:09:05 <FunctorSalad> preflex: version
12:09:05 <preflex>  0.680
12:09:53 <FunctorSalad> preflex: be copumpkin
12:09:53 <preflex>  no quotes found for copumpkin
12:10:34 <tommd> preflex: be preflex
12:10:34 <preflex>  no quotes found for preflex
12:10:59 <copumpkin> preflex: be mauke
12:10:59 <preflex>  I've solved the halting problem WITH A SHOTGUN
12:11:54 <BBK> can someone help me write a small thing for my program im doing
12:12:44 <PeakerWork> BBK: ask a more specific question?
12:14:00 <BBK> how can i add my program so u can see it
12:14:10 <PeakerWork> use the pastebin in the topic
12:15:28 <BBK> wat do mean? like paste
12:15:45 <copumpkin> @hpaste
12:15:45 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:15:59 <copumpkin> open that site, take your code, paste it in there, and then give us the URL that contains your code
12:16:08 <BBK> oh yeah
12:16:12 <copumpkin> ideally, not too much or too little code
12:16:27 <copumpkin> just enough to give us what we need to know to help you, without having to sift through piles of unrelated stuff :)
12:16:34 <copumpkin> (and don't forget the error message if you have one)
12:17:54 <BBK> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4485#a4485
12:18:07 <copumpkin> uh
12:18:16 <copumpkin> ##java
12:18:45 <copumpkin> We don't do java (willingly)
12:18:59 <copumpkin> but give them that paste and they might be able to help you
12:21:01 <BBK> give it to whom
12:21:20 <copumpkin> to the people in ##java who actually are interested in Java :)
12:21:40 <copumpkin> you need to type /join ##java
12:22:10 <copumpkin> This channel is for lovers of Haskell :)
12:22:19 <copumpkin> (a programming language very different from java)
12:23:49 <Botje> (don't people read the names of channels they join? :/)
12:23:51 <BBK> join ##java
12:24:04 <BBK> sorry i got it confused
12:29:40 <mauke> zygoloid: yes, preflex is written in haskell
12:45:55 * edwardk just returned from being 'the haskell guy' at google's summer of code mentor summit. It was a nice opportunity to evangelize.
12:46:22 <copumpkin> zomg
12:46:33 <Botje> did you hand out lambda cookies?
12:47:06 <edwardk> nah, didn't think to bake any.
12:47:16 <mmorrow> did you explain how do get the String out of IO String?
12:47:19 <Botje> aww :)
12:47:38 <copumpkin> instance Copointed IO ?
12:47:44 <copumpkin> duh
12:47:44 <edwardk> mmorrow: yes in both the unsafePerformIO and 'you shouldn't do that' sense
12:47:49 <mmorrow> heh
12:50:16 <edwardk> overall, I think it was a pretty resounding success. I wound up staying up until around 4-5 in the morning each night talking to folks.
12:50:47 <Vanadium> Sounds neat
12:51:55 <Vanadium> Is Copointed newspeak for "the thing that has a function 'f a -> a'"? :I
12:53:01 <copumpkin> yep
12:53:24 <andreo> is it possible to make generic function `zip` to accept N lists: zip [1, 2] [1, 2] [1, 2]?
12:53:25 <Vanadium> There ought to be a better word for that :I
12:53:30 <edwardk> Vanadium: 'and is a Functor'
12:53:42 <copumpkin> Vanadium: Algebra?
12:53:49 <mmorrow> andreo: not with haskell's type system
12:53:50 <Vanadium> edwardk: How do I tell it is a Functor and not a, uh, Cofunctor?
12:54:01 <edwardk> Vanadium: cofunctor = functor =)
12:54:05 <copumpkin> Vanadium: a cofunctor doesn't make much sense
12:54:11 <mmorrow> andreo: (to literally do that)
12:54:13 <copumpkin> Vanadium: you can have a contrafunctor though! :P
12:54:22 <Vanadium> copumpkin: From my perspective, not a lot of haskell does :(
12:54:28 <edwardk> (a -> b) -> f a -> f b   becomes (a <- b) -> (f a <- f b) = (b -> a) -> (f b -> f a) -- which is alpha equivalent ;)
12:54:30 <copumpkin> Vanadium: lol
12:54:41 <andreo> mmorrow: kind of recursive tuple?
12:55:13 <mauke> > transpose [[1, 2], [1, 2], [1, 2]]
12:55:14 <lambdabot>   [[1,1,1],[2,2,2]]
12:55:15 <copumpkin> andreo: you have a function that almost does that though
12:55:21 <copumpkin> damn, mauke just stole it
12:55:29 <copumpkin> :)
12:55:55 <andreo> mauke: it's different :)
12:56:08 <mmorrow> andreo: the problem is with the n arguments to a single functions giving a list of n-tuples
12:56:26 <mauke> variable arguments aren't a problem per se
12:56:39 <mmorrow> andreo: you can possibly approximate with typeclass haxxery, but it won't be pretty
12:56:39 <mauke> I just don't see a way to construct an n-tuple
12:57:32 <andreo> it is possible in C++, even in 03
12:57:52 <mmorrow> andreo: with compile-time meta-programming?
12:58:15 <Jafet> n cannot be a parameter in 03
12:58:17 <monochrom> If N is unknown until run time, just use lists or arrays. If N is known but you have many different N's and just get bored, use a macro system or template haskell.
12:58:19 <mmorrow> you can do this trivially with template-haskell of course
12:58:51 <aavogt> this here: http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Sequence.html
12:59:02 <monochrom> Until theorem proving becomes mainstream programming, there are a lot of nice-to-have generalities you won't get.
12:59:17 <edwardk> monochrom: unless you rip out the types ;)
12:59:33 <aavogt> but I guess it should really be for Applicative m, in which case you can use ZipList as your type
12:59:42 <aavogt> ZipList being the m
12:59:49 <Vanadium> Just implement a multidimensional list as a flat list and a list of the dimensions
13:01:49 <hackagebot> mmap 0.5.3 - Memory mapped files for POSIX and Windows (GracjanPolak)
13:13:14 <MacCoasts> if i had something like data Blah x y = Constructor1 x y | Constructor2 x y, is thre any way of doing getx :: Blah x y -> x, without defining it for both Constructor1 Constructor2 ?
13:14:07 <copumpkin> you can share record accessors
13:15:09 <benmachine> or getx (Constructor1 x) = x; getx (Constructor2 x) = x
13:15:52 <copumpkin> he just said he didn't want to write that :P
13:15:56 <MacCoasts> benmachine: right the second one is what i want to avoid, defining it for both, i mean theyre the same entry basically just different constructors
13:16:11 <copumpkin> MacCoasts: you could factor out the common bits
13:16:16 <stanv> howto construct foldr1 from foldr ?
13:16:22 <copumpkin> data Tag = Constructor1 | Constructor2
13:16:28 <copumpkin> data Blah x y = Blah Tag x y
13:16:48 <edwardk> stanv: add a Maybe to see if you're at the base case.
13:17:04 <mauke> @src foldr1
13:17:04 <lambdabot> foldr1 _ [x]    = x
13:17:04 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
13:17:04 <lambdabot> foldr1 _ []     = undefined
13:17:07 <mmorrow> MacCoasts: that second one is exactly what any code that did what you want would need to do though
13:17:13 <benmachine> oh I thought you meant a separate function for each
13:17:17 <copumpkin> you just need to eat off the front element
13:17:27 <MacCoasts> copumpkin: ah yeah, didnt think of factoring it out that way
13:18:26 <jfredett> iirc, foldr1 f (x:xs) = foldr f x xs -- but I could be wrong.
13:18:36 <copumpkin> that's what I'd write
13:18:53 <jfredett> foldl1 would req. the last arg...
13:18:56 <mauke> > foldr1 f [x,y,z]
13:18:57 <lambdabot>   f x (f y z)
13:19:05 <mauke> > foldr f x [y,z]
13:19:06 <lambdabot>   f y (f z x)
13:19:13 <copumpkin> oh, good point, had it backwards
13:19:15 <jfredett> ah- yah, I have it backwards...
13:19:37 <stanv> :) thanks
13:19:39 <copumpkin> yeah, I remember encountering that in the past actually
13:19:41 <Lemmih> @seen mae
13:19:41 <lambdabot> Unknown command, try @list
13:19:50 <Lemmih> preflex: seen mae
13:19:50 <preflex>  mae was last seen on ##java 31 days, 4 hours, 2 minutes and 21 seconds ago, saying: ojacobson: thanks for your help
13:19:53 <jfredett> > foldr (last [x,y,z]) (init [x,y,z])
13:19:54 <lambdabot>   Couldn't match expected type `a -> b -> b'
13:19:54 <lambdabot>         against inferred type `S...
13:20:04 <jfredett> garr. it's something like that.
13:20:10 <copumpkin> you forgot f
13:20:12 <jfredett> oh. duh...
13:20:18 <jfredett> > foldr f (last [x,y,z]) (init [x,y,z])
13:20:19 <lambdabot>   f x (f y z)
13:20:23 <jfredett> there we go.
13:20:29 <copumpkin> wonderfully efficient too ;)
13:20:36 <jfredett> hehe.
13:20:47 <jfredett> just don't try it on infinite lists!
13:21:08 <copumpkin> it could work on infinite lists
13:21:47 <jfredett> just might take a while to get that last element...
13:21:49 <copumpkin> > (\xs -> foldr f (last xs) (init xs)) [1..] :: Expr
13:21:56 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
13:21:58 <copumpkin> yeah, but it might never need to
13:22:11 <jfredett> whoa....
13:22:25 <jfredett> thats right, i'm thinking to strictly..
13:22:55 <copumpkin> no dominatrix for you tonight
13:23:07 <mmorrow> aww
13:23:18 <jfredett> @vixen
13:23:18 <lambdabot> My instant messenger doesn't work.
13:24:47 <mmorrow> @nixon
13:24:48 <lambdabot> People react to fear, not love; they don't teach that in Sunday School, but it's true.
13:24:55 <jfredett> ...
13:25:07 <jfredett> @. @vixen @nixon
13:25:07 <lambdabot> Plugin `compose' failed with: Unknown command: "@vixen"
13:25:11 <lament> @vixon
13:25:12 <lambdabot> Maybe you meant: nixon vixen
13:25:14 <copumpkin> aw
13:25:22 <mmorrow> @. vixen nixon
13:25:22 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
13:25:23 <copumpkin> lambdabot needs some serious reworking :P
13:25:30 <jfredett> damn, no '@'s...
13:25:45 <copumpkin> @@ @elite @vixen @nixon @yarr
13:25:45 <lambdabot>  I FInd I+ Hard To mAsTUR84t3 W|-|3N T|-|3 |IgH7z 4re 0N.
13:25:47 <jfredett> copumpkin: it's on my list of projects...
13:25:50 <mmorrow> @vixen a/s/l
13:25:50 <lambdabot> 19/f/California
13:26:05 <copumpkin> lambdabot: really?
13:26:11 <mmorrow> apparently
13:26:53 * mmorrow wonders what nixon said to vixen for that response
13:27:07 <jfredett> copumpkin: I have a sheet of notes on what would be awesome... including easy setup as a IM bot (not just an IRC bot) so you could (ideally) run \bot on your home machine and IM it when you want to show off haskell from (basically) anywhere...
13:27:07 <copumpkin> @@ @elite @vixen @nixon @yarr
13:27:08 <lambdabot>  \/\/hat if i DoN'7?
13:27:22 <copumpkin> jfredett: sounds cool :)
13:27:29 <lament> vixen is not exactly a haskell showcase
13:27:32 <mmorrow> probably "I'mm not a crrroook"
13:27:58 <jfredett> copumpkin: but that's after I get the HWN software working. which is only after I get through the myriad other crap on my plate... it's fun to be busy.
13:28:01 <lament> @vixen What do you demonstrate?
13:28:01 <lambdabot> i do occassionally, i guess
13:28:35 <mauke> @vixen has anyone really been far even as decided to use even go want to do look more like?
13:28:36 <lambdabot> yup, really
13:29:04 <medfly> @nixon
13:29:04 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
13:33:41 <andreo> is there a way to call function f (f :: a -> b -> c) passing the tuple (1, 'x') as arguments? map tuple to function arguments.    sometihng like this:    invoke f (1, 'x')
13:34:06 <jfredett> :t uncurry
13:34:07 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:34:18 <jfredett> so, for instance
13:34:25 <jfredett> > uncurry (+) (1,2) == 3
13:34:26 <lambdabot>   True
13:34:32 <mauke> > uncurry f (1, x)
13:34:33 <lambdabot>   Ambiguous type variable `c' in the constraints:
13:34:34 <lambdabot>    `SimpleReflect.FromExpr ...
13:34:40 <mauke> > uncurry f (1, x) :: Expr
13:34:42 <lambdabot>   f 1 x
13:35:02 <jfredett> doing `>>` should automatically force \bot into Expr mode...
13:35:16 <mauke> Â»
13:35:49 <jfredett> indeed.
13:37:39 <andreo> uncurry wokrs for two arguments only?
13:37:57 <mauke> yes
13:38:55 <monochrom> premature generality is the root of OOP
13:41:11 <andreo> is there a uncurry analog for N-arity?
13:41:39 <mije> hi, i'm learning haskell and i'd like to read real code, does anyone can give me a link ?
13:41:51 <ben_m> mije: XMonad source
13:42:02 <mije> ok :)
13:42:05 <mije> thx
13:43:03 <shaleny> http://martijn.van.steenbergen.nl/journal/2009/01/11/type-synonym-families/
13:43:03 <shaleny> in the comments is an example of how to make generic curry and uncurry
13:43:03 <shaleny> though it can be hard to grasp it at first sight
13:44:08 <jfredett> mije: you can also poke around reddit.com/r/EnHaskell
13:44:26 <jfredett> lots of small, useful utils w/ code.
13:45:44 <mightybyte> @remember monochrom premature generality is the root of OOP
13:45:44 <lambdabot> Okay.
13:47:25 <FunctorSalad> MonadPlus can be defined in terms of Monoid after all... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11219#a11219
13:47:33 <FunctorSalad> aka context quantification
13:50:16 <FunctorSalad> the wonders of the contravariant argument of (->)
13:51:03 <copumpkin> neat
13:51:17 <copumpkin> but they behave differently in some cases
13:52:34 <FunctorSalad> sadly one still can't infer MonadPlus from :forall a. Monoid (m a)"
13:53:28 <FunctorSalad> copumpkin: where?
13:54:22 <copumpkin> > Just (Sum 5) `mappend` Just (Sum 6)
13:54:23 <lambdabot>   Just (Sum {getSum = 11})
13:54:24 <copumpkin> > Just (Sum 5) `mplus` Just (Sum 6)
13:54:25 <lambdabot>   Just (Sum {getSum = 5})
13:54:53 <FunctorSalad> whoa
14:03:37 <copumpkin> for GHC codegens and CISCy instructions
14:04:16 <copumpkin> how hard is it to detect a CISCy pattern in the cmm input and generate a suitable instruction for the whole thing, rather than generating individual simpler instructions?
14:05:18 <copumpkin> whoops, wrong channel :)
14:07:29 <andreo> how can i make 'Int -> Double' from 'Int -> Char -> Double'? fff _ 'C'?
14:08:09 <Baughn> andreo: f int double = g int 'C' double?
14:08:33 <Lemmih> Without the double.
14:08:48 <mauke> @pl \i d -> g i 'x' d
14:08:48 <lambdabot> flip g 'x'
14:08:58 <Cale> f x = g x 'C'
14:09:06 <Cale> The double is the result :)
14:10:00 <mauke> it's still flip g :-)
14:10:38 <Baughn> @type flip (g :: Int -> Char -> Double -> ()) 'C'
14:10:39 <lambdabot>     No instance for (SimpleReflect.FromExpr ())
14:10:39 <lambdabot>       arising from a use of `g' at <interactive>:1:6
14:10:39 <lambdabot>     Possible fix:
14:10:46 <Baughn> @type flip (ggg :: Int -> Char -> Double -> ()) 'C'
14:10:47 <lambdabot> Not in scope: `ggg'
14:11:00 <Baughn> @type flip (undefined :: Int -> Char -> Double -> ()) 'C'
14:11:01 <lambdabot> Int -> Double -> ()
14:11:14 <mauke> @type flip (?ggg :: Int -> Char -> Double -> ()) 'C'
14:11:15 <lambdabot> (?ggg::Int -> Char -> Double -> ()) => Int -> Double -> ()
14:11:38 <Baughn> But, but.. implicit parameters are evil...
14:11:48 <Baughn> They're also practically never actually implicit
14:17:20 <Root-Sac> Allez hein bandes de fils de putes de juifs vous m'avez empeché d'avoir mon argent pour m'empecher de faire plaisir aux autres bandes de sous merdes radins mongoliens !!!
14:17:38 <mauke> .oO( excuse my french )
14:17:44 <tommd> Or at least his.
14:18:03 <mauke> oh, multichannel spam
14:18:06 --- mode: ChanServ set +o mauke
14:18:07 --- kick: Root-Sac was kicked by mauke (mauke)
14:18:20 <Lemmih> In French?
14:18:41 <purplepenguins> also racist i think
14:19:07 --- mode: mauke set -o mauke
14:19:23 <ben_m> purplepenguins: You're such a racist for thinking he's being racist, just because he speaks French.
14:19:54 <purplepenguins> i meant the content of his message is racist
14:20:03 <ben_m> I know, I'm just being unfunny.
14:26:55 <Botje> looks like he's sad he can't retrieve money from his bank.
14:33:17 <jfredett> what did he say? I'm confused...
14:33:25 <Baughn> How would I refer to a type variable used in the function type signature in a type signature for an expression inside that function?
14:33:30 <jfredett> je suis not-a-frenchguy...
14:33:38 <jfredett> sacre bleu...
14:34:02 <mauke> Baughn: with a ghc extension
14:34:15 <Baughn> Which one? ;)
14:34:16 <mauke> ScopedTypeVariables + explicit forall
14:34:32 <Baughn> Ah. I got half of it, then.
14:34:53 <Berengal> Wait, you need explicit forall as well?
14:34:58 <mauke> yes
14:35:23 <Baughn> let typeString = show (typeOf (undefined :: msg)) <-- This will work fine if I put a forall in the function signature?
14:35:30 <etpace_> Does anyone know under what circumstances `average case of O(log n)' could be better than `amortised worst case of O(log n)'?
14:36:15 <Baughn> etpace_: (a) when worst case is important, e.g. for latency
14:36:36 <Baughn> etpace_: (b) if it's possible to snapshot the data structure before a worst-case operation, and then repeat that operation
14:36:55 <Baughn> The latter is especially unavoidable for pure languages; fortunately, laziness lets us sneak around it
14:37:03 <Berengal> Baughn, average case of O(log n) doesn't mean the worst case won't be worse than O(log n)
14:37:18 <Baughn> Never said it did
14:37:19 <etpace_> doesn't memoisation stop (b)?
14:37:26 <Baughn> etpace_: If used correctly.
14:37:37 <Berengal> etpace_, not memoization, lazyness
14:37:53 <Baughn> Well, laziness and memoization are more or less the same thing..
14:37:59 <Baughn> Sort of.
14:38:26 <Berengal> It's half an ounce too imprecise to conflate them like that to me
14:38:50 <Berengal> But "Sort of" covers it
14:38:56 <prof_nimnul> Baughn: they are not. Sharing in call by need includes some kind of memoization, but it's not what is usually meant by "memoization"
14:39:09 <Baughn> Berengal: Memoization /does/ fix this, as does laziness. You don"t need laziness if you have memoization, or vice versa.
14:39:16 <Baughn> In haskell, we just happen to have lots of laziness
14:39:52 <Baughn> ..however, memoization might get awfully verbose for the purpose
14:40:18 <Baughn> prof_nimnul: To implement laziness: Create a nullary function, then memoize it.
14:40:50 <Berengal> Speaking of being lazy and haskell; is there a bulletpoint of static typing decreasing the workload of the programmer besides typesafety?
14:40:50 <prof_nimnul> Baughn: it's not enough
14:41:01 <Baughn> prof_nimnul: What's missing?
14:41:23 <Baughn> Berengal: It allows for denser code. For example, what I just did..
14:41:48 <Baughn> (In this case, "what I just did" = 'typeOf (undefined :: msg)')
14:42:14 <Baughn> Parametrizing on the return value is nifty. You could do it without static typing, but then the above expression would be very hard to write.
14:42:29 <Berengal> Baughn, automatic overloading is indeed one of the items
14:42:48 <Berengal> How do you parameterize on the return value in a dynamically typed language?
14:43:01 <mauke> lazily :-)
14:43:22 <copumpkin> yep!
14:43:36 <PeakerWork> or you can pass in the "typeclass" (record of funcs or what not) as an arg explicitly
14:43:54 <Berengal> You'd have to send the type in as a runtime argument (which haskell sometimes does in the form of dictionaries, but it's automatic), at which point it's not exactly automatic anymore...
14:44:22 <Baughn> PeakerWork: I imagine you've already gotten into it, but.. STM really is nice. I think I've fallen in love. :)
14:44:24 <copumpkin> Berengal: not really... you can return an object that does different things depending on what your caller asks it
14:44:40 <mauke> this is sort of like the implementation of $foo->bar = 42; in perl
14:44:45 <prof_nimnul> Barengal: In perl I parametrize by querying return type in runtime.. wantarray()
14:44:53 <Baughn> Berengal: Or there could be an implicit thisCall object you can ask
14:45:18 <PeakerWork> Baughn: I haven't used it too much yet..  what do you use it for?
14:45:27 <Berengal> Baughn, at some point it has to be explicit though
14:46:40 <Baughn> mauke: You'd know. Would you consider "show (typeOf (undefined :: msg))" safe enough for serialization and network transport?
14:47:02 <mauke> whoa
14:47:27 <Baughn> Meaning I'm tagging each message with the type of that message, so the library user can call recv multiple times, with multiple return types, and get only the correct messages
14:47:43 <Baughn> mauke: You may assume that the same code is running on both sides. ;)
14:47:45 <mauke> it's only as safe as your Typeable instances
14:47:52 <Baughn> DeriveDataTypeable ones
14:48:21 <mauke> hmm, ok then
14:48:35 <Baughn> PeakerWork: Anything and everything. Basically, every possible kind of variables.
14:49:12 <Baughn> PeakerWork: They make concurrency easy, but they're so nice, I might just want to use them even if I wasn't using concurrency
14:49:19 <Baughn> (..except, then StateT is probably good enough)
14:49:21 <Tordek> hi
14:49:22 <PeakerWork> Baughn: How do you "connect" it with actual IO (given that transactions don't have IO in them)
14:49:53 <Baughn> PeakerWork: ..with great difficulty.
14:50:08 <Baughn> PeakerWork: Using IO means you have to split the atomically blocks. It's a time for deep reflection.
14:50:12 <Tordek> I need to make a list like [0, f(0), f(f(0)), f(f(f(0))),...] how do I do that?
14:50:22 <mauke> iterate
14:50:23 <Berengal> Tordek, iterate
14:50:27 <Baughn> > iterate f 0
14:50:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:50:28 <lambdabot>    `SimpleReflect.FromExpr ...
14:50:32 <Baughn> > iterate f 0 :: [Expr]
14:50:33 <lambdabot>   [0,f 0,f (f 0),f (f (f 0)),f (f (f (f 0))),f (f (f (f (f 0)))),f (f (f (f (...
14:50:54 <ben_m> What's that Expr type?
14:51:02 <Berengal> Baughn, use TMVar as locks?
14:51:41 <Baughn> Berengal: Etc., yes, though in the one case where I needed an MVar here, I decided to use plain MVars for the modifyMVar goodness.
14:51:44 <PeakerWork> Baughn: STM sounds like it creates helper thread-safe data structures you can use from IO, but it doesn't "control" the flow of your IO program (Sort of a hand-waving gut feeling I have before actually using it :)
14:52:06 <Baughn> Berengal: modifyFoo is very obviously missing from STM. They're easy to write, but it's a bit annoying.
14:52:21 <Berengal> Baughn, it's not hard to write a modifyTVar... but yes, it should be standard
14:52:56 <Baughn> PeakerWork: That sounds about right. By the way.. unsafeSTMToIO exists, but its unsafety makes unsafePerformIO look good. Don't even think about it.
14:53:09 <Baughn> *IOToSTM
14:53:14 <copumpkin> :)
14:53:41 <Baughn> PeakerWork: Well, all I can really say is - try it. You get used to it very, very quickly.
14:53:56 <Berengal> Baughn, the problem with MVars is that they don't compose. You can't 'withLocks [dbLock, loggerLock, fileLock, networkLock]' safely
14:54:48 <Baughn> Berengal: Not without some touchy manipulations of Data.Unique and unsafePerformIO, no. We /could/ have a function like that.
14:54:53 <PeakerWork> Baughn: I don't have that much time for a Haskell project, though I have a good idea for a Haskell project I try to get people to start working on for me ;)
14:54:59 <Tordek> thanks!
14:55:22 <Baughn> PeakerWork: Retry semantics: If you call retry in an STM monad (which a lot of the functions implicitly do, but fail /doesn't/), then the entire atomically block starts from scratch; it also blocks until /one of the variables you have at any point read changes/
14:55:38 <Baughn> PeakerWork: That's about all the subtlety there is. It's a great library. :)
14:56:21 <Baughn> Berengal: ..actually, make that unsafeInterleaveIO. I forgot MVars were in IO. ^^;
14:56:23 <PeakerWork> Baughn: I didn't like the "until one of the variable changes" - it sounds like maybe it can be smarter than this if it is slightly more declarative
14:56:50 <PeakerWork> Baughn: I mean, if transactions were defined more declaratively, with combinators rather than (>>=) then it could know more accurately when to retry
14:56:51 <sjanssen> retry and orElse are so wonderful.  It's like Unix's select() for any of your application's data
14:57:35 <Baughn> PeakerWork: You're right, but the current system is still very useful.
14:58:17 <PeakerWork> Baughn: it does sound so. I am not sure where I'd want to use it, so I don't, which leads to a vicious cycle :)
14:58:19 <Berengal> PeakerWork, if one of the variables changed while it was running, it'll retry right away
14:58:40 <Berengal> PeakerWork, anywhere you want communicating threads
14:58:42 <Baughn> PeakerWork: How about..
14:58:50 <Baughn> PeakerWork: Next time you want an MVar or Chan, use STM instead.
14:58:51 <Cale> PeakerWork: >>= is a combinator is it not?
14:59:17 <Baughn> PeakerWork: A stronger heuristic: Any time you'd want /multiple/ MVars /simultaneously/, /definitely/ use STM.
14:59:23 <sjanssen> one should probably use TChan instead of Chan in all cases anyway, Chan has bad bugs
14:59:36 <Berengal> sjanssen, really?
14:59:43 <Berengal> (I've always used TChan anyway)
14:59:46 <Baughn> PeakerWork: ..seriously, the module I'm writing now would be twice as big if I didn't have STM. It's already 600 lines.
14:59:54 * Baughn wonders if he should split it. Nah.
14:59:59 <sjanssen> Berengal: yes, some fairly weird stuff can happen with asynchronous exceptions
15:00:23 <Berengal> sjanssen, weird as in they're not _really_ atomical?
15:00:30 <Baughn> Berengal: Yes
15:00:33 <Berengal> :(
15:00:36 <ddarius> Bah, just don't use asynchronous exceptions.
15:00:37 <Baughn> Chan is also pretty slow
15:00:55 <PeakerWork> Cale: yeah, I meant less opaque combinators
15:01:09 <PeakerWork> Baughn: what are you implementing?\
15:01:35 <Berengal> PeakerWork, honestly, there's not much you can do in STM. There's readTVar, writeTVar, retry, orElse and >>=
15:01:40 * ddarius recommends trying the CML library if one doesn't necessarily need asychronous channels.
15:01:46 <PeakerWork> I'm deep into C code atm.  My attempts to get my coworkers to switch to Haskell (in an intense work environment) are not successful (despite exciting some of them), so I'm stuck doing purely C for a while here :-P
15:01:47 <Baughn> PeakerWork: Still that P2P messaging thingy. Well, it's about done now.
15:01:58 <copumpkin> sjanssen: can't Chan be fixed?
15:02:22 <Baughn> copumpkin: It could, in fact, be fixed by making it a wrapper for TChan. :P
15:02:27 <copumpkin> lol
15:02:31 <PeakerWork> Cale: If STM was exposed to the data-flow/structure of your transactions, maybe it could be smarter about restarting transactions only when they really would be able to make progress, for example
15:02:34 * ddarius wouldn't be surprised if the CML library doesn't "do the right thing" in the face of asychronous exceptions.
15:03:15 <sjanssen> copumpkin: probably.  I can't even remember the specific issue right now
15:03:16 <Baughn> PeakerWork: I find that in practice, my STM blocks don't touch more than two or three variables anyway
15:03:16 <PeakerWork> I wonder if STM as an Arrow solves this (possibly non-)problem
15:03:30 <copumpkin> STM as an arrow?
15:03:33 <copumpkin> is that an option?
15:03:34 <Tordek> is there any function f :: (a -> Bool) -> [a] -> a that returns the first element of a list where f a == True?
15:03:41 <copumpkin> Tordek: find
15:03:43 <copumpkin> :t find
15:03:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
15:03:46 <Cale> PeakerWork: hmm...
15:03:48 <Berengal> PeakerWork, it's hard to say that for sure without analyzing the actual data involved as well. If it retried after an orElse, a variable used before it changing might cause it to take another path
15:03:48 <PeakerWork> copumpkin: I don't know, maybe it is
15:03:51 <ddarius> @hoogle (a -> Bool) -> [a] -> a
15:03:52 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:03:52 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
15:03:52 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
15:03:52 <Tordek> thanks
15:03:55 <copumpkin> Tordek: you sound like you need to get acquainted with hoogle
15:04:00 <copumpkin> :)
15:04:06 <Tordek> aye
15:04:21 <PeakerWork> how does STM commit work, btw?
15:04:32 <tommd> PeakerWork: Depends on the architecture.
15:04:41 <Berengal> PeakerWork, atomically :P
15:04:44 <PeakerWork> tommd: ghc on x86/64
15:04:48 <PeakerWork> Berengal: under the hood :)
15:04:48 <tommd> There is a big paper about many methods it _can_ work depending on the primitives available.
15:05:14 <tommd> PeakerWorker: I'd look at the MSR papers... humm...
15:05:39 <tommd> and the site is slow as heck
15:05:48 <Berengal> Didn't the GHC papers about it say something about a transaction log that was run through?
15:05:53 <tommd> so I'm giving up, but I know there's a good paper there.
15:06:06 <Berengal> Though I'm not sure if it took a global lock or if it just locked the variables it used
15:06:41 <tommd> Berengal: But does it use a atomic CAS, MCAS, perhaps a TAS, or on ARM a STREX/LDREX?
15:07:46 <Berengal> tommd, that's what I can't remember. It's about a year since i read the paper
15:08:16 <Baughn> PeakerWork: That aside. The main thing about STM is that it lets me write concurrent code without thinking about the concurrency.
15:08:22 <Baughn> PeakerWork: You have no idea how much of a load that is off my head.
15:08:43 * Baughn has nightmares about the mazes of MVars in Reactant
15:08:52 <Berengal> Baughn, indeed, it's awesome
15:10:49 <PeakerWork> Baughn: you still have to think about concurrency, I'd venture -- about what's the right scope for transactions (where to place the "atomically")
15:11:13 <PeakerWork> (though its probably a lot easier, sure)
15:11:38 <Baughn> It drops from about 80% of my brain bandwidth to maybe 30%. :P
15:11:56 <PeakerWork> > BaughnTop
15:11:57 <lambdabot>   Not in scope: data constructor `BaughnTop'
15:12:03 <zakwilson_> What's this, PeakerWork? STM isn't a magic bullet to solve every concurrency problem without requiring any thought?
15:12:36 <PeakerWork> zakwilson: the magic bullet does exist, or at least almost magic, called human programmers :)
15:12:55 <Berengal> PeakerWork, yeah, because they've all done such a great job in the past ;)
15:13:46 <zakwilson> I think human programmers using their intelligence to find the best solution to problems on a case-by-case basis is the opposite of a magic bullet.
15:13:47 <tommd> ha
15:14:04 <PeakerWork> Berengal: Heh, I just resent the "No Magic Bullet" paper about how we're never going to make programming an order of magnitude more productive because we're dealing with inherent complexity.. I think its clear we aren't, as it takes many orders of magnitude less time to describe what you want programmed to someone (even with a pretty good level of precision) than it takes to actually implement something
15:14:39 <PeakerWork> I mean, if there's an upper bound on the productiveness of programming, its the amount of time it takes one to describe the requirements to a competent engineer
15:14:59 <PeakerWork> and that's definitely orders of magnitude shorter than actually implementing it
15:15:29 <Berengal> PeakerWork, I agree
15:15:47 <monochrom> You are right, STM needs little thought. Here is the catch: could be slow. This is why your magic-bullet-worry is a red herring.
15:16:27 <Berengal> However, I also have a belief that humans aren't capable of super-turing computations, i.e. we can create an AI
15:16:43 <Berengal> In the future, we won't be programming computers using english or some other such nonsense. We won't program computers at all
15:17:05 <Baughn> Sure we will. Or at least, I will.
15:17:08 <Baughn> I *enjoy* programming..
15:17:18 <Berengal> Well, I will too, but I won't have to
15:17:27 <lispy> > case Just 1 of Just {} -> 1; Nothing -> 2
15:17:28 <lambdabot>   1
15:17:34 <PeakerWork> Baughn: your consciousness will be transferred into an AI, then your body will be quickly discarded
15:17:38 <Vanadium> We will just shuffle some isolinear optical chips around and suddenly the computer will be very eager to do exactly what we require it to
15:17:39 <Baughn> At the level of AGI you're proposing, I doubt you'll "have to" do much of anything at all. :P
15:17:45 <lispy> In that expression is {} a standin for _Z
15:17:49 <lispy> er _?
15:17:51 <scorchsaber> We're still a long way from that, though. I think computer-assisted programming is more likely to be en vogue for a while (like with computer-assisted chess)
15:17:58 <zakwilson> I think we're far from having discovered the best ways to express our desires to machines, but short of human-like AI, we'll still be doing it with languages for the forseeable future.
15:18:00 <Baughn> lispy: Yes.
15:18:03 <copumpkin> lispy: yeah
15:18:22 <Baughn> lispy: You're generally supposed to name some data-structure members in there
15:18:24 <lispy> I'm suprised I've never encountered that before
15:18:24 <lispy> Thanks
15:18:42 <copumpkin> lispy: unlike _, it can be any number of parameters long
15:18:43 <Baughn> E.g. "case foo of Foo {bar,baz} in ..."
15:19:01 <Baughn> That one requires RecordFieldPuns, I think it was
15:19:12 <Cale> lispy: It's sort of like record syntax, though it was noted in the report that the empty match is still useful even for types not using record syntax
15:19:14 <copumpkin> lispy: so if you don't care about the parameters and only want the constructor, it's generally a nice way of doing it
15:19:25 <lispy> > case Just 1 of Just {x} -> x; Nothing -> 0
15:19:26 <lambdabot>   Illegal use of punning for field `x'
15:19:26 <lambdabot>  Use -XNamedFieldPuns to permit this
15:19:28 <copumpkin> there's also {..} if you enable RecordWildcards, which brings all the record names into scope
15:19:48 <Berengal> RecordWildcards is nice
15:19:49 <copumpkin> *field names
15:19:56 <copumpkin> yeah, I use it quite a bit
15:20:04 <Cale> It's handy because if the number of fields changes later, you'll have to change something like  Foo _ _  while  Foo {}  will still be fine
15:20:13 <Berengal> Me too. Just a shame the yi syntax highlighter coughs a bit at it
15:20:13 <lispy> okay
15:20:18 <zakwilson> I don't think it's at all inconceivable that we will come up with a language an order of magninude more expressive than today's best. We've done so before; I suspect Haskell compared to C is an example, though I don't have metrics to back that up.
15:20:29 <lispy> I see it for pattern matches on maybe
15:20:43 <lispy> So, in that case it didn't look so interesting.
15:20:48 <Baughn> lispy: The non-extension version of {x} is {x=x}
15:20:55 <lispy> But, for general types I think I see why it's nice.
15:20:56 <Baughn> lispy: Then there's {..}, which is just /neat/
15:21:01 <Berengal> zakwilson, I have dubious testimonials that it is so ;)
15:21:53 <PeakerWork> zakwilson: I think we might have to depart the textual editing medium for that boost
15:22:39 <Berengal> PeakerWork, doing some coding with arrows, I've already become annoyed that I can't have columns in my code
15:23:01 <Baughn> @type second
15:23:02 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:23:49 <ddarius> tommd: You might find Keir Fraser's original thesis, "Practical Lock-Freedom," interesting.
15:24:25 <tommd> ddarius: I wasn't the one who brought up the topic, but you are right - thank you for the pointer.
15:24:27 <zakwilson> PeakerWork: that may be, but I think we can get there with a textual medium by having multiple representations for a language's syntax.
15:24:46 <PeakerWork> zakwilson: multiple representations -- all textual?
15:24:58 <Berengal> Baughn, I still can't do stuff like "arrowFoo >>>\n |arrowBar >>>| &&& | arrowBaz >>>|\n arrowQux |     | arrowQuux|\n >>> arr (uncurry fnord)"
15:25:39 <PeakerWork> zakwilson: if your editor's view and editing operations are no longer operations on a text string -- but operations on the structure the string represents, and don't pose a possibility for a syntax error, then its not really textual editing anymore and there's not much point to using inefficient textual representation in the backend
15:26:19 <PeakerWork> Berengal: yeah, arrow programs are always shown as diagrams, and then coded in much less readable code. That's a clear sign
15:26:28 <zakwilson> They could be all-textual, or the editor/runtime could dump the in-memory representations of the parse tree. It wouldn't matter much.
15:26:32 <Baughn> Berengal: I don't even try.
15:26:43 <scorchsaber> PeakerWork: I think The Art of Unix Programming makes some good points for maintaining text representations.
15:26:59 <zakwilson> I should note that this isn't my idea; it's John McCarthy's.
15:27:05 <PeakerWork> scorchsaber: Compatibility with ancient tools, I'd guess?
15:27:15 <Berengal> PeakerWork, considering the sequence of some arrows matter, regular proc foo -> do notation is neccessary, but only for sequential arrows
15:27:18 <PeakerWork> zakwilson: I think it does matter -- because you don't want just a view, you want something that can edit, too
15:27:26 <ddarius> tommd: I was basing the recommendation on your statements.
15:27:27 <scorchsaber> PeakerWork: And the ease with which you can create new ones. Text is the universal protocol, that sort of thing.
15:27:41 <PeakerWork> Berengal: I don't know when it makes sense for the sequence of the arrow to matter
15:27:55 <Berengal> PeakerWork, ArrowIOs
15:28:06 <PeakerWork> Berengal: Kleisli arrows aren't an interesting case of an arrow, imo
15:28:27 <PeakerWork> scorchsaber: I think text is a bad universal protocol.. Explained by conal in his google tech talk
15:28:31 <Berengal> PeakerWork, Kleislis aren't all the IO arrows there are though
15:28:45 <PeakerWork> Berengal: what else?
15:28:48 <conal> :)
15:28:52 <Baughn> @pl (\foo -> pure <$> monadic foo)
15:28:52 <lambdabot> (pure <$>) . monadic
15:28:55 <Berengal> PeakerWork, HXT, for example, uses a -> StateT s IO [b]
15:29:21 <Berengal> PeakerWork, or something like that...
15:29:23 <scorchsaber> PeakerWork: Everybody does. It's possible there's no such thing as a good universal protocol, simply from it being universal.
15:29:24 <zakwilson> PeakerWork: the idea is to edit it in any of the different syntax options and let the editor/runtime make changes to the internal representation.
15:29:27 <Berengal> Not sure where the state fits in
15:29:31 <PeakerWork> conal: I liked that tech talk, but I suspect maybe parts were a bit too deep for that audience
15:29:39 <PeakerWork> conal: s/but/and ;-)
15:29:48 <Berengal> Actually, that was a Kleisli....
15:29:52 * Berengal checks the source
15:29:57 <conal> PeakerWork: hah!
15:30:08 <scorchsaber> Also, link?
15:30:28 <zakwilson> PeakerWork: Of course, the internal representation could be textual S-expressions, in which case it would be easy enough to edit by hand without the aid of an editor/runtime that can present it in other forms.
15:30:59 <PeakerWork> scorchsaber: http://www.youtube.com/watch?v=faJ8N0giqzw
15:31:27 <Berengal> IOSLA {runIOSLA :: s -> a -> IO (s, [b])}
15:34:43 <PeakerWork> Berengal: I think Arrows are just interesting ways to build a data-flow graph in a type-safe way
15:34:59 <sinelaw> PeakerWork, IIRC only DAGs
15:35:06 <PeakerWork> Berengal: I think the only thing that should be interesting is the resulting diagram, and I'm not sure why any order between the graph edges should be specified
15:35:17 <PeakerWork> sinelaw: until you add the ArrowLoop class
15:36:01 <Berengal> PeakerWork, I'm still very n00bish when it comes to arrows. I use them just so I won't have to explicitly recurse over trees/lists
15:36:40 <Berengal> I couldn't write my own non-kleisli arrow, for example
15:37:41 <PeakerWork> Berengal: just need to implement Category's id and (.) and Arrow's  arr and (***) -- I think the rest follows from that
15:38:17 <Berengal> PeakerWork, yes, and I could probably do that for some trivial structure, but I don't know when and how it could help me. It's not in my toolbox
15:38:59 <PeakerWork> first = (***id), second = (id***), f &&& g = (f *** g) . arr (join (,))
15:39:34 <copumpkin> ARR
15:40:06 <ccasin> hi all: is there an easy way to access the version number in my cabal file from inside the application?
15:40:18 <Berengal> I've done all the golfing with arrows, so I'm pretty familiar with the standard combinators, but until recently it was all just an excercise in pointlessness (pun intended)
15:40:57 <mauke> ccasin: yes
15:41:02 <PeakerWork> Berengal: at least you didn't lie about the pun, but still: http://www.thebestpageintheuniverse.net/c.cgi?u=puns
15:41:31 <PeakerWork> Berengal: (link sent in humorous fashion. I find that page's vulgar style pretty funny :)
15:41:47 <Botje> PeakerWork: i bought the guy's book.
15:41:50 <mauke> ccasin: import Paths_<yourpackage>
15:41:52 <Berengal> Heh, I own the book
15:42:05 <PeakerWork> is it a good one?
15:42:06 <Botje> "BAM! HEADBUTT TO THE OVARIES!"
15:42:58 <Botje> it's funny, yes :)
15:43:00 <ccasin> mauke: I'm doing that for data files, does it have info other than getDataFileName in it?  Didn't spot any info about it in the docs
15:43:35 <mauke> ccasin: it exports version :: Data.Version.Version
15:43:59 <ccasin> mauke: awesome, thanks
16:03:21 <ben_m> using (>>>) with functions is basically just reverse function composition, correct?
16:03:40 <Berengal> ben_m, yep
16:03:44 <ben_m> Great :)
16:04:15 <fxr> @type flip (.)
16:04:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
16:04:23 <altmattr> unit testing wants a test for each method - commonly people have a companion hierarchy to go with the main one, with test code in it.  However, as far as I can tell, this requires all my methods to be public in all my modules
16:04:41 <PeakerWork> @type flip (Prelude..)
16:04:42 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
16:04:42 <fxr> is it flip (.)?
16:04:43 <altmattr> anybody know a way around this (besides rolling test code into the module itself)?
16:04:55 <PeakerWork> fxr: (.) is redefined to fmap by Cale
16:04:56 <ben_m> fxr: I think it's flip ($)
16:05:19 <PeakerWork> (<<<) is (.) and (>>>) is flip (.)  yeah
16:05:37 <PeakerWork> its not ($) because arrows are composed points-free wise, not applied to a point
16:05:42 <ben_m> Oh yes :)
16:05:48 <aavogt> altmattr: have alternate export lists (or no list) exposed when you #ifdef TESTING
16:05:55 <fxr> PeakerWork: that is obvious
16:06:25 <mathijs> anyone familiar with scion?
16:06:28 <altmattr> aavogt: nice - how many haskell compilers support that - out of curiosity?
16:06:43 <aavogt> altmattr: basically all of them let you use CPP
16:07:03 <altmattr> aavogt: legend
16:07:38 <altmattr> aavogt: never having beena  programmer in a language where pre-processing is a big deal I always neglect that option :)
16:07:46 <PeakerWork> btw: Arrow's (<<<) became an alias for Control.Category.. which is more like Prelude..
16:07:48 <hackagebot> arbtt 0.4.1 - Automatic Rule-Based Time Tracker (JoachimBreitner)
16:08:34 <fxr> flip (.) sounds like lambda calculus, (>>>) sounds like category theory
16:08:39 <Baughn> PeakerWork: Did you realize, you can use view patterns /anywhere/?
16:09:06 <PeakerWork> Baughn: nope, I haven't ever used view patterns at all :)
16:09:26 <Baughn> PeakerWork: "(decode -> msg,uuid) B.splitAt 4 <$> hGet h 16" looks pretty nice. ;)
16:09:30 <PeakerWork> I tend to use these extensions after having seen some example code that shows their usefulness... but I haven't seen much code using view patterns yet
16:09:39 <Baughn> PeakerWork: Oh, actually, that's "decode -> msg :: Word32" there. :P
16:10:06 <FunctorSalad> > (\(length -> y) -> y) ":o"
16:10:06 <lambdabot>   Illegal view pattern:  (length -> y)
16:10:07 <lambdabot>  Use -XViewPatterns to enable view pat...
16:10:26 <ddarius> PeakerWork: They would be useful for maintaining abstraction while still allowing pattern matching (which is the idea behind views).
16:10:37 <ddarius> (Or rather the motivation)
16:10:53 <FunctorSalad> the win is mostly that you can preprocess inputs without giving the unprocessed input a name
16:11:08 <PeakerWork> they seem to replace  case func x of   with (func ->) prefix on each of the cases.. is this the whole deal?
16:11:11 <FunctorSalad> (in arguments where PL might be inconvenient)
16:11:42 <ddarius> PeakerWork: No, because you can lead to different cases being chosen, but ultimately yes.
16:12:20 <ddarius> PeakerWork: For multiple and/or nested patterns, the desugaring won't be so straightforward and pretty.
16:13:27 <Tordek> I has maed pretty fractal yayz
16:13:41 <Tordek> fun way to lun haskell
16:13:43 <copumpkin> that's one of the first things I used iterate for too :)
16:13:46 <Tordek> *lurn
16:14:03 <fxr> Tordek: :)
16:14:12 <Tordek> 25 lines, ascii output :P
16:14:22 <sinelaw> Tordek, haz
16:14:36 <Tordek> haz?
16:14:47 <Tordek> as in lolz?
16:15:14 <dpratt71> Cale, you lurking perchance?
16:15:35 <sinelaw> Tordek, u iz write
16:15:42 * FunctorSalad thinks it was "can has" originally.
16:15:44 <Tordek> ah
16:15:54 <ddarius> Tordek: Look at Nymphae on hackage perhaps.
16:16:17 <FunctorSalad> "can has" being a tag was so cute that it sold me on the phenomenon (long ago)
16:16:35 <fxr> Tordek: you made my day :))
16:19:27 <medfly> dpratt71, he is! bother him more and he'll show up!
16:23:18 <dpratt71> medfly: :)
16:24:01 <sinelaw> is this normal?
16:24:03 <sinelaw> Graphics\HGL\Key.hs:57:7:
16:24:03 <sinelaw>     Could not find module `Graphics.Win32':
16:24:03 <sinelaw>       it is a member of the hidden package `Win32-2.2.0.0'
16:24:19 <sinelaw> (excuse me for attempting to run haskell with HGL on windows...)
16:25:02 <Vulpyne> Hmmm, can Haddock syntax highlight code blocks?
16:25:14 <aavogt> sinelaw: add an argument -package Win32-2.2.0.0
16:25:31 <sinelaw> ah
16:25:45 <aavogt> or maybe this is some missing dependency in the cabal file?
16:25:50 <sinelaw> yes
16:28:45 <sinelaw> how do i make a cabal package out of an unpacked packagE?
16:29:05 <sinelaw> never mind.
16:38:03 <hackagebot> gps 0.4.0 - For manipulating GPS coordinates and trails. (ThomasDuBuisson)
16:38:08 <dancor> have ppl had success with bytestringparser; is it only worth it for things that don't have "short tokens"
17:06:38 <luite> is there a way to get a back trace for an exception?
17:07:34 <copumpkin> nope, although I think that's coming in 6.12
17:07:53 <Axman6> i don't believe so, and i have a feeling haskell gets quite mangled while being compiled, so it might not make much sense
17:08:47 <copumpkin> there was a paper on it just recently
17:09:32 <copumpkin> http://research.microsoft.com/en-us/um/people/simonpj/papers/stack-trace/DebugTraces.pdf
17:10:11 <Gracenotes> a saturated constructor is a fully applied one. correct? (not (4:))
17:10:47 <Gracenotes> ...and it's also solid at room temperature? -_-
17:11:02 <luite> copumpkin: thanks, I'll add it to my read queue :)
17:12:24 <copumpkin> :)
17:12:35 <copumpkin> I guess it's still up in the air, so it probably won't be in 6.12
17:12:42 <copumpkin> one of the GHC people can probably correct me :P
17:17:43 <dpratt71> anyone here use Haskell in a professional capacity?
17:18:04 <blackh> dpratt71: Yes
17:18:18 <blackh> dpratt71: That was the short answer. :)
17:18:41 <dpratt71> blackh: care to give the longer answer? :)
17:19:10 <blackh> dpratt71: I'm glad you asked!
17:19:58 <blackh> dpratt71: I have two jobs - one I've had for 5 years, and I've managed to con them into letting me prototype in Haskell some code for compressing geographical data.
17:20:07 <lament> nice!
17:20:22 <dpratt71> blackh: interesting
17:20:38 <blackh> The other job is that I'm working on a commercial video game with iPwn Studios, which is a start-up run by Ryan Trinkle.
17:20:49 <blackh> The game is for the iPhone.
17:20:58 <dpratt71> blackh: *very* interesting
17:21:54 <dpratt71> can you run Haskell binaries on the iPhone (I don't know anything of the platform)?
17:22:11 <blackh> Actually I've also done a huge 20,000 line project in Haskell for my own business which is a secret.  I want to work commercially in Haskell, so I have decided that I will!
17:22:50 <dibblego> is it common to emulate implicit parameters with phantom types and type-classes?
17:22:53 <dpratt71> blackh: I'll tell that to the VP of Development here and see what he says :)
17:23:04 <blackh> Yes - Ryan paid me to get GHC cross-compiling to the iPhone, and they've released it all openly.
17:23:44 <blackh> dpratt71: Someone made the point that managers will accept Haskell just as soon as programmers start demanding it.
17:24:14 <blackh> (which I agree with, which is why I said it!)
17:24:16 <Vanadium> blackh: That sounds pretty neat
17:24:23 <dpratt71> blackh: :-)
17:25:17 <medfly> I wish I could just decide to make money and do
17:25:29 <blackh> medfly: I never said I was making any money.
17:25:41 <blackh> ...but I intend to.
17:25:52 <aavogt> dibblego: that's sort of like the implicit configurations paper?
17:25:56 <medfly> good luck :-)
17:26:02 <dibblego> aavogt, dunno, I haven't read it
17:27:47 <blackh> medfly, dpratt71: Well, I am making some money. My goal is to do as much as possible 100% paid Haskell work by hook or by crook.
17:28:17 <fxr> same here
17:29:45 <blackh> Do it! I'm not necessarily saying it's easy, but I'm certainly determined.  I'm sick of using second-rate programming languages and spending my life debugging.
17:30:19 <blackh> I've done my time.  I'm going to enjoy my job from now on.
17:31:24 <fxr> I'm happy that my current work is no more than an emacs screen :)
17:32:57 <fxr> oh lambdas in my yi :) wonderful
17:33:33 <blackdog> hey, anyone know the state of play with haskell-src? I want to use hsplugins, but it needs haskell-src, which needs base<4...
17:34:42 <jre2> given that I'm using STU arrays (mutable,unboxed) with unsafe reads/writes, does anyone have any tips for what I can try to squeeze out more performance? (also, only 1-2% of time is lost to GC)
17:35:34 <blackdog> jre2: parallelism? got profiling numbers?
17:35:38 <lament> blackh: you think a sizable haskell project will not involve debugging?
17:36:39 <blackdog> there's a difference between spending most of your time debugging and it being a small part of your development cycle
17:36:43 <blackh> lament: I think a sizable Haskell project will involve only a tiny fraction of the debugging necessary for my C++ job, and I base this opinion on experience.
17:36:49 <jre2> blackdog: did some profiling for using different array types, lists, etc and compared them to a simple java implementation
17:37:34 <fxr> anybody knows how to change current directory in yi?
17:38:06 <blackdog> jre2: so you're profiling a library, then?
17:38:07 <luite> jre2: I found that uvector is often a bit faster than STUArray
17:38:49 <copumpkin> uvector is mostly good for sequential operations on arrays
17:39:28 <luite> perhaps, but it seems to have less overhead, maybe because of its simpler indexing
17:39:34 <copumpkin> ah possibly
17:39:39 <jre2> hmm, didn't try uvector
17:40:30 <luite> it's alpha software so complain to dons if it doesn't work ;)
17:41:18 <jre2> hah
17:41:24 <luite> and install with -fsafe for debugging your code
17:41:48 <PeakerWork> I think in C/C++/etc you're debugging incorrectness, and in Haskell you're debugging performance.. most of the time you can live with some "performance problems" (especially since most code that has it will only exhibit it under large inputs), but its hard to live with "some incorrectness".    Its probably also easier to iteratively improve performance retaining correctness, than to iteratively improve correctness
17:43:15 <luite> I still find performance very difficult to 'debug'...
17:43:58 <copumpkin> I'd like to write a simplifier visualizing tool but GHC makes that quite hard
17:44:08 <copumpkin> but something that allows you to see where your rewrite rules are firing
17:44:12 <copumpkin> would be pretty awesome
17:44:41 <PeakerWork> copumpkin: I think it would be great if integrated in an IDE, allowing you to show what's happening to your code, step-by-step, all the way down :)
17:45:00 <PeakerWork> that way you see both the denotational and operational semantics of your program at the same time
17:45:09 <PeakerWork> (rather than giving one up as you currently have to, most of the time)
17:45:19 <copumpkin> my idea was to have it spit out pretty-printed html with javascript interaction
17:45:36 <copumpkin> but IDE integration would be nice too
17:45:43 <copumpkin> it's just that I don't have an IDE I like using
17:46:06 <luite> for example, lots of people seem to write some genetic algorithm in haskell, which is fun and all, but I found that writing something that actually performs well is quite difficult
17:47:12 <uberboss> ghc SUCKS DICK
17:47:20 <jre2> luite: do you know what the big difference between uvectors and stuarrays is?
17:47:27 <uberboss> haskell SUCKS DICK
17:47:31 <Vanadium> uberboss: quite exquisitly so!
17:47:35 <uberboss> Erlang FTW
17:47:54 <uberboss> (Caml is OK too)
17:48:22 <uberboss> ghc "code" is so dysfunctional, slow and overall dumb that its actual name is DICK, which GHC loves to eat/suck!
17:48:28 <luite> jre2: uvector has both pure and ST versions, and is made to be fusible (so that intermediate results can be optimized away)
17:48:43 <c_wraith> uberboss:  have trolls always been so lame?  You could at least be creative.
17:48:43 <Vanadium> uberboss: Why is it you associate "dick" with dysfunctional
17:49:07 <uberboss> not sure actually
17:49:30 <luite> jre2: I think that the main difference to the user is that uvector is indexed by Int, with range 0..lengthU-1, while STUArray has a generic Ix index
17:49:42 <c_wraith> like maybe "ghc couldn't compile its way out of a wet paper sack."  that makes you kind of stop and go "huh?" and then "maybe he's got a point...  I don't think it could"
17:49:53 <PeakerWork> if you want something that has both correctness and great performance, I am not entirely sure whether Haskell is the best choice. I think if you want something that has OK performance and cheaply retains correctness, even over time/modifications, Haskell is a great choice
17:50:04 <copumpkin> yo uberboss! i'm really happy for u and imma let u finish but... xah lee is the greatest troll of all time. oOF ALL TIME!
17:50:31 <Vanadium> ghc couldn't compile its way out of a wet monomorphism restriction
17:50:40 <Cale> uberboss: You're going to have to be more entertaining than that if you want us to make a bot out of you.
17:50:43 <Cale> @keal
17:50:43 <lambdabot> bot seems useless
17:50:45 <Cale> @keal
17:50:45 <lambdabot> bot seems useless
17:50:47 <Cale> @keal
17:50:47 <lambdabot> evaluating expressions is ALL haskell does?????
17:50:51 <Cale> @keal
17:50:52 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
17:50:55 <copumpkin> uberboss: you really need to practice your trolling a bit more :) http://xahlee.org/PageTwo_dir/more.html
17:51:08 <gwern> copumpkin: 'more'? now I have to click
17:51:25 <copumpkin> gwern: his root redirects there now, it seems :)
17:51:42 <Cale> @protontorpedo
17:51:42 <lambdabot> ok is haskell a type of lisp?
17:51:51 <uberboss> http://bit.ly/19phLt
17:51:53 <gwern> copumpkin: I wonder how many people actually hire him as a consultant?
17:52:03 <PeakerWork> preflex: do poppavic
17:52:06 <copumpkin> gwern: lots! anyone who hates haskell (and tail recursion in particular)
17:52:10 <PeakerWork> preflex: be poppavic
17:52:10 <preflex>  no quotes found for poppavic
17:52:14 <gwern> copumpkin: what
17:52:23 <copumpkin> xah lee hates tail recursion
17:52:39 <copumpkin> http://xahlee.org/UnixResource_dir/writ/tailrecursion.html
17:52:51 <c_wraith> you can always rewrite tail recursion to not be tail recursive, right? >_>
17:53:08 <Vanadium> c_wraith: Why would you want to do that
17:53:19 <c_wraith> Vanadium:  Did I say I wanted to?  :)
17:54:04 <luite> PeakerWork: In many cases you can just implement the really performance critical parts in C and use ffi
17:54:16 <gwern> copumpkin: reading it, he only hates the term and the popular misconceptions, not the actual technique
17:54:29 <copumpkin> gwern: yeah, I was exaggerating a tad :)
17:54:31 <gwern> suggesting we call it 'good implementation' :)
17:54:32 <Cale> Sometimes tail recursion is bad for performance.
17:54:43 <uberboss> hey anyone know of a good socks proxy?
17:54:55 <copumpkin> uberboss: SOCKS PROXIES SUCK BALLS!
17:54:56 <c_wraith> uberboss: ssh
17:55:08 <PeakerWork> luite: sometimes a large part of the system is performance critical.. sometimes a slight space leak over time in any component (even non critical) can bring the whole thing down
17:55:22 <uberboss> copumpkin: lol
17:55:22 <c_wraith> uberboss: in particular, the -D option to ssh
17:55:29 <Cale> A tail recursive function does nothing but call itself until it reaches a base case, so it will fail to produce a constructor until then.
17:55:45 <gwern> 'Btw, if you joined Second Life, let's meet. I'm Xah Toll there. We can voice chat about the importance of functional programing in humanity's future.' <-- an obvious typo
17:56:03 <monochrom> Xah Troll :)
17:56:23 <luite> PeakerWork: but with genetic algorithms, I found that everything seems to be performance critical, you need lots of random number generation, lots of low level data access to evaluate solutions, often a local search that improves solutions. apart from moving everything into IO I couldn't find a way to get anywhere near the speed of an implementation in Java or C
17:56:24 <copumpkin> Xah is a pretty awesome name
17:56:30 <gwern> oh, he has an obituary for Naggum.
17:56:38 <Vanadium> Cale: What is the alternative?
17:56:38 <gwern> I'd read it, but let the trolls bury their own
17:56:53 <PeakerWork> luite: there are probably nice ways to do that, but they take more effort, yeah
17:57:12 <Xah> oh my, xahlee is online
17:57:17 <PeakerWork> luite: perhaps until the tools will evolve to help us see through the operational semantics of our denotational programs
17:57:20 <Xah> I wonder what he's doing
17:58:03 <gwern> oh shoot. I meant, 'let the trolls bury the trolls'
17:58:08 <gwern> bibical reference fail :(
17:58:12 <copumpkin> aw
17:58:14 <Cale> Vanadium: There isn't always a better alternative, but sometimes you can write a function which only recurses as far as it needs to.
17:58:25 <Cale> > foldr (:) [] [1..]
17:58:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:58:32 <Cale> @src foldr
17:58:33 <lambdabot> foldr f z []     = z
17:58:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:58:34 <_Ray_> Hey, small question. I can't think of an easy solution to this (and there exists one). I have a list (I'll use strings throughout, but this is for any list). Say I have "foobarfoo". I'm given "foo". I want to remove all occurrances of "foo", to return "bar". If I'm given "ca", and "ccaa", I want to return the empty string. Is there a simple solution to this, without using higher order functions or lists by comprehension?
17:58:41 <Cale> foldr immediately passes control to f
17:58:45 <monochrom> I only curse as far as I need to. :)
17:59:06 <_Ray_> I devised a very contrived algorithm using backtracking, but surely there's an easier way?
17:59:14 <Cale> So if f can return a constructor without needing to inspect its second argument, then maybe the foldr will stop altogether.
17:59:20 <copumpkin> _Ray_: keep running it over and over again until the string doesn't change :P
17:59:21 <Vanadium> Right
17:59:32 <_Ray_> copumpkin, yeah, but running /what/?
17:59:35 <copumpkin> _Ray_: "it" being the obvious algorithm
17:59:45 <_Ray_> (I already do this with my algorithm, but it's not pretty)
18:00:04 <luite> PeakerWork: I hope so :)
18:00:06 <copumpkin> oh no, it is 9 of the clock and I must go
18:00:12 <drhodes> _Ray_: have you seen groupBy?
18:00:13 <copumpkin> _Ray_: good luck!
18:00:22 <Tordek> I have this line:
18:00:23 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11225 <-- this is what I currently do
18:00:29 <Tordek> fractalPoint p = case findIndex (>5) . take 100 . map magnitude . fractalList $ p of
18:00:47 <Tordek> I though I could point-free-ify it by deleting the p from the end
18:00:50 <_Ray_> drhodes, no, and I can't use it, really. This is an intro to algorithms course, I'm lucky if I can use elem and notElem =p
18:01:07 <Tordek> whoy can't I?
18:01:31 <monochrom> I wonder if I can turn _Ray_'s problem into a parsing problem. Grammar:  S -> f S o S o | empty
18:01:49 * _Ray_ won't see grammars for a few years =p
18:02:18 <gwern> ''I hope you understand and appreciate what I have written above so the following does not apply to you anymore.  you see, I wrote it all because I _really_ wanted to say that that sentence is the single most ignorant and shallow-minded line that I have ever seen in any programming language newsgroup or forum and I hope _never_ to see anybody display such utter disregard for the brilliance and genius of people who came before them just ...
18:02:24 <gwern> ... because they grew up in an age when "simple interface" is sneered and laughed at in favor of "simple implementation" so any dumb fsck can implement it right out of a "for Dummies" book....  thank you and have a nice new year. '
18:02:25 <monochrom> My grammar is wrong. But useful first approximation.
18:02:28 <gwern> good old erik
18:02:34 <_Ray_> But anyway, my method is extremely contrived and ugly. I've seen a solution that uses 2 lines. :(
18:03:54 * Vanadium probably should not be surprised that out of data A = A Int, A undefined and newtype B = B Int, B undefined, only one survives being seq'ed
18:03:58 <sinelaw_> gwern where's that from?
18:05:10 <gwern> _Ray_: why not do something like 'quux ('f':'o':'o':x) = quux x; quux x:xs = [x] ++ quux'?
18:05:22 <gwern> unless I've missed something, that should remove "foo"
18:05:31 <gwern> well, I suppose you'd need a concat at the caller too
18:05:40 <_Ray_> gwern, yes, but that's a function specifically for 'foo'.
18:05:46 <_Ray_> I want any strings, and any string length.
18:05:49 <drhodes> _Ray_: can you use dropWhile?
18:05:53 <_Ray_> No.
18:05:56 <gwern> ok, so you could generalize with 'isPrefixOf'?
18:05:58 <Axman6> gwern: [x]++quux xs?
18:06:08 <gwern> Axman6: er, obviously
18:06:12 <gwern> just keeping _Ray_ on his toes
18:06:13 <_Ray_> I created an "isPrefixOf" myself, but that's the ugly solution =(
18:06:16 <Axman6> heh
18:06:41 <monochrom> you should create a "stripInfix" instead.
18:06:45 <_Ray_> (I did a combined replace/isPrefixOf using backtracking - replace if found, leave unchanged if not)
18:07:18 <_Ray_> so "fooo" seeing "foobar" matches until "foo", but then sees "o" != "b" and backtracks to "foobar" and returns unchanged
18:07:24 <monochrom> If you backtracking like there is no tomorrow, you may as well use a parser.
18:07:43 <jao> hmm. should leksah be installable using cabal? it seems to depend on a too old version of regex-base.
18:08:05 <_Ray_> yeah, but I know backtracking because I've been programming for a long time - this is an intro to algorithms course. people who've never programmed before. and I saw a 2-line implementation (which I've been trying to get hold of, but can't)
18:08:13 <jre2> why not apply "delete pattern mystring" until it's result is equal to mystring?
18:08:19 <_Ray_> jre2, I do that
18:08:29 <_Ray_> but "delete pattern" is the one that's complicated
18:09:02 <_Ray_> I check for every starting position, if the next (length pattern) block out of mystring is equal to pattern, then return everything but that pattern (everything that follows it)
18:09:13 <gwern> and you say isPrefix is ugly
18:09:21 <_Ray_> implementing it myself sure was!
18:09:24 <monochrom> @src isPrefix
18:09:24 <lambdabot> Source not found. stty: unknown mode: doofus
18:09:27 <monochrom> @src isPrefixOf
18:09:27 <lambdabot> isPrefixOf [] _          = True
18:09:27 <lambdabot> isPrefixOf _  []         = False
18:09:27 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
18:09:32 <_Ray_> (note I didn't implement a true/false isPrefixOf)
18:09:33 <monochrom> is not ugly
18:09:35 <luite> by the way, is there a guide for optimizing haskell programs somewhere? RWH has chapter 25 on profiling and tuning for speed, but that's just one chapter
18:09:47 <_Ray_> yes, but I didn't create just isPrefix, I did the replacing strings inline part
18:09:49 <monochrom> @src stripPrefix
18:09:49 <lambdabot> Source not found. It can only be attributed to human error.
18:09:55 <jre2> @src deleteBy
18:09:55 <lambdabot> deleteBy eq x []        = []
18:09:55 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
18:10:03 <gwern> haha
18:10:08 <gwern> wonder what deleteBy calls
18:10:13 <gwern> @src deleteBy
18:10:13 <lambdabot> deleteBy eq x []        = []
18:10:16 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
18:10:38 <gwern> oh, that's not too bad, just reimplement 3 or 4 functions
18:10:59 <_Ray_> yes, and that was 25 lines. isn't there a "duh, too obvious" solution in about 3 lines?
18:11:28 <lantti> Ray: Yes there is, but it is too obvious.
18:11:44 <monochrom> hahaha
18:11:44 <_Ray_> :( I left it bouncing.
18:11:44 <lantti> :)
18:12:05 <PeakerWork> gwern: he stresses out the heterogenous support of lists as if it was so important :)
18:12:16 <PeakerWork> I guess when you have to compose all your ADTs out of lists...
18:13:01 <jre2> _Ray_: so why can't you use Data.List.delete?
18:13:20 <_Ray_> because it's an intro to algorithms course and I don't have access to anything more complicated than elem
18:13:33 <Axman6> PeakerWork: what's this?
18:13:59 <PeakerWork> Axman6: http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/4ff4e8cead8fe772/72bf71c6e6c81f80
18:14:03 <_Ray_> also, is there a similarly obvious solution to the problem of changing "   foobar   baz   " into "foobar baz"? (Removing duplicated spaces)
18:14:24 <Axman6> thanks
18:14:37 <_Ray_> Oh wait, that one's easy. Just replace "  " and make it " ", until there's no more.
18:15:03 <jre2> _Ray_: can't you just write delete? it's a trivial recursive function
18:15:10 <dibblego> have any of you written Vincenty's ellipsoidal algorithm?
18:15:17 <_Ray_> I didn't even know it was a function :)
18:15:28 <_Ray_> @src delete
18:15:28 <lambdabot> delete = deleteBy (==)
18:15:54 <benmachine> unwords . words might also work
18:16:04 <benmachine> > unwords . words "    foobar    baz    "
18:16:05 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:16:06 <lambdabot>         against inferred ty...
18:16:06 <benmachine> er
18:16:11 <benmachine> > unwords . words $ "    foobar    baz    "
18:16:12 <lambdabot>   "foobar baz"
18:16:14 <_Ray_> If I can't use delete, I can't unwords =p
18:16:15 <benmachine> woo
18:17:07 <benmachine> mm but unwords and words are probably both fairly straightforward
18:17:21 <benmachine> probably.
18:17:26 <jre2> _Ray_: can't you just write delete though?
18:18:30 <_Ray_> i could, i'll check what it does
18:19:38 <_Ray_> I think that's what I implemented
18:20:12 <_Ray_> jre2, but it's not really delete, since I'm deleting sublists from lists
18:20:26 <_Ray_> delete takes Char -> [Char], I'm doing [Char] -> [Char]
18:20:44 <monochrom> > tails "abc"
18:20:45 <lambdabot>   ["abc","bc","c",""]
18:20:51 <mmorrow> _Ray_: http://en.wikipedia.org/wiki/Knuthâ€“Morrisâ€“Pratt_algorithm
18:21:03 <monochrom> KMP is not "2 lines"!
18:21:20 <_Ray_> I'll try to get hold of the 2-line creature.
18:21:24 <_Ray_> I still can't believe it
18:21:24 <monochrom> OTOH I gradually feel that the 2-line solution is slow.
18:21:31 * mmorrow has no idea what we're talking about, but thought that might be relevant
18:22:36 <_Ray_> This all should be done in paper (as opposed to having a compiler in front of me), so I doubt I was supposed to implement a 25-line backtracking beast
18:23:39 <Axman6> PeakerWork: thanks for the link, it's reminded me why i don't particularly want to try lisp
18:24:10 <mmorrow> _Ray_: ah, i just found your problem-description in scrollback
18:24:18 <mmorrow> _Ray_: If I'm given "ca", and "ccaa",...
18:24:22 <_Ray_> Yeah
18:24:32 <_Ray_> But that's the easy part - I apply f until f is the identity
18:24:42 <mmorrow> _Ray_: so you want to recursively remove a substring until there are no more occurrences, right?
18:24:47 <_Ray_> Yes
18:25:10 <PeakerWork> Axman6: the attitude?
18:25:11 <_Ray_> And it should be doable in pen&paper, as opposed to KMP
18:25:45 <Axman6> PeakerWork: and the language
18:25:48 <Axman6> PeakerWork: and the language
18:25:51 <PeakerWork> Axman6: I think Haskell already has most of what's good in most Lisps.  Scheme is nice for its tinyness (very nice power to size ratio), and otherwise the Lisps have some niceness regarding dynamic reload of code.  Not that much
18:25:52 <Axman6> whoops
18:26:08 <Axman6> yeah
18:26:09 <mmorrow> hmm, i guess that at every prefix of the string-to-remove, you hang onto it, recurse on the rest of the string, then continue (or something)
18:26:45 <_Ray_> mmorrow, indeed, that's what I do in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11225 (code is in Spanish), but that's a beast
18:27:10 <_Ray_> (I use a buffer to remember, if I have to backtrack, what I've removed, and return it unchanged if I failed at some part of the matching)
18:27:30 <mmorrow> _Ray_: it seems to be either that, or just scanning the entire thing over and over until nothing changes
18:28:34 <mmorrow> ((length chica) > (length (l:larga)))
18:28:43 <mmorrow> length chica > length (l:larga)
18:28:53 <mmorrow> length chica > 1 + length larga
18:29:06 <_Ray_> yeah i'm still not comfortable with parenthesis in Haskell
18:29:54 <Axman6> ((>) (length chica) (length (l:larga)))
18:30:05 <_Ray_> yeah, no
18:30:06 <Axman6> ((>) (length chica) (length ((:) l larga)))
18:30:14 <Axman6> now you too can have lisp in haskell!
18:31:26 <Tordek> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=4486#a4486
18:31:33 <camio> Just what lisp needs, more parenthesis!
18:32:10 <Tordek> in the makeCanvas function, where I have the list-comprehension in a list comprehension, is it makeLines being called h times, or just once?
18:50:28 <aavogt> @undo [ [ x+y | x <- xs ] | y <- ys ]
18:50:28 <lambdabot> concatMap (\ y -> [concatMap (\ x -> [x + y]) xs]) ys
18:50:36 <_Ray_> Small question. Say f 0 = 0, f x = x +1 - f (x -1). In what order are expansions done if I say f(f(3))?
18:50:46 <_Ray_> s/expansions/reductions/
18:50:50 <aavogt> :t [ [ x+y | x <- [] ] | y <- [] ]
18:50:51 <lambdabot> forall t. (Num t) => [[t]]
18:52:04 <aavogt> @check \xs ys -> [ [ x && y | x <- xs ] | y <- ys ] == [ map (&&y) xs | y <- ys ]
18:52:06 <lambdabot>   "OK, passed 500 tests."
18:52:19 <aavogt> Tordek: ^^
18:52:23 <BMeph> Does it matter in which order strict functions are reduced? :) I'm not trolling, I'm seriously that unschooled.
18:52:24 <Tordek> wut
18:52:55 <Tordek> strict? or pure?
18:52:56 <aavogt> it's being called h times
18:53:00 <Tordek> ah
18:53:07 <Tordek> so I better put it out in a where
18:53:29 <Tordek> (while we're at it, is there a prettier way to do that?)
18:54:20 <aavogt> the compiler is free to float those things out
18:54:38 <_Ray_> Would the expansion be to f(3) before, since it needs to know how to expand f?
18:54:39 <aavogt> but if you know the computation is expensive, then use a where
18:56:28 <aavogt> Tordek: use enumFromThenTo, or the [a0,a1..an] notation
18:56:31 <Tordek> [[x :+ y | x <- rows] | y <- columns]... can that be shortened up somehow? I think `columns >>= y [ rows >>= x [(x :+y)]]` will do it, but it seems ugly
18:56:51 <Axman6> > lift
18:56:52 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a),
18:56:52 <lambdabot>                    GHC.Show...
18:56:54 <aavogt> and you can probably write   liftM2 (:+) rows columns
18:56:55 <Axman6> whoops
18:57:04 <lantti> _Ray_: Are you allower to use list handling things, like head, tail, length?
18:57:11 <Axman6> > liftM2 (:+) [1..10] [10..13]
18:57:12 <lambdabot>   [1.0 :+ 10.0,1.0 :+ 11.0,1.0 :+ 12.0,1.0 :+ 13.0,2.0 :+ 10.0,2.0 :+ 11.0,2....
18:57:15 <_Ray_> lantti, yes
18:58:49 <lantti> What about drop, take and such?
18:58:56 <_Ray_> Nope.
18:59:14 <Tordek> hmm, not quite what I need, then, aavogt: that's [Complex] and I'm using [[Complex]]
18:59:17 <lantti> Ok, I'll just try it for fun.
18:59:32 <_Ray_> hehe
19:00:23 <lantti> Propably this legenday 2-liner is a backtracking written with some clever pattern match or something.
19:00:26 <aavogt> ah, then you could also use:
19:00:45 <aavogt> :t concatMap (\y -> map (&&y) xs) ys
19:00:46 <lambdabot> Not in scope: `xs'
19:00:46 <lambdabot> Not in scope: `ys'
19:00:56 <aavogt> :t \xs ys -> concatMap (\y -> map (&&y) xs) ys
19:00:56 <lambdabot> [Bool] -> [Bool] -> [Bool]
19:01:07 <aavogt> hmm, that's not right
19:01:19 <aavogt> :t \xs ys -> map (\y -> map (&&y) xs) ys
19:01:20 <lambdabot> [Bool] -> [Bool] -> [[Bool]]
19:01:33 <aavogt> :t \xs ys -> map (\y -> map (:+y) xs) ys
19:01:34 <lambdabot> forall a. (RealFloat a) => [a] -> [a] -> [[Complex a]]
19:02:50 <applicative> [
19:03:15 <Tordek> parse error: mismatched [ ;(
19:04:21 <aavogt> ]
19:04:21 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
19:05:35 <aavogt> Tordek: sometimes using map is cleaner than concatMap with return, (or the equivalent in do notation / list comprehensions)
19:06:40 <aavogt> > [
19:07:24 <dibblego> there is also (:+) <$> rows <*> columns
19:08:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:08:23 <Axman6> hmmm, now i think about it, that seems somewhat relational. perform the cross product, then apply  something to it
19:11:33 <mmorrow> _Ray_: in your "f" function above, it would happen like it would in C/whatever, since (+),(-),etc are strict
19:11:44 <_Ray_> mmorrow, 'strict'?
19:12:00 <mmorrow> so doing  1 + f (x-1) means that you're using linear amount of stack
19:12:10 <Cale> _Ray_: they always pattern match against their parameters
19:12:11 <mmorrow> i.e. it isn't tail recursive
19:12:29 <mmorrow> if you had an accumulator you could use O(1) space
19:12:32 <Cale> "stack" doesn't mean what it means for strict evaluators though
19:12:48 <Axman6> more like a stack on pancakes
19:12:50 <Axman6> om nom nom
19:13:00 <_Ray_> In what case would it be evaluated in a non-C way?
19:13:04 <Tordek> where's <*>?
19:13:12 <Cale> Tordek: Control.Applicative
19:13:13 <Tordek> ie, import (wut?)
19:13:14 <mmorrow> _Ray_: the "1 + [ ]" gets stuck on the stack, until "f (x-1)" is evaluated fully
19:13:14 <dibblego> Control.Applicative
19:13:17 <Tordek> thanks
19:13:25 <Cale> The stack is used to traverse an expression to find a reducible expression inside it.
19:13:42 <_Ray_> Right, so like C. Find the smallest thing you can find until it's irreducible.
19:14:03 <mmorrow> _Ray_: (and this will start happening once you demand any of the original expression of course, but not until then)
19:14:17 <Cale> We find the *outermost* reducible expression, and reduce that
19:14:32 <mmorrow> _Ray_: this is a special case, because (+) needs both arguments to be fully evaluated
19:14:35 <Cale> Whereas in C, you find the innermost one, and that's not what the stack is really for.
19:14:54 <Cale> well, hmm
19:14:56 <mmorrow> (+) for Int here
19:15:04 <_Ray_> So 1+ f (x-1+2) would be reduced to 1 + f (x+1), then to (let's say f x = 2*x) 1 + 2*(x+1), then to 1 + 2*x+2*1, then to 1 + 1 + 2*x + 2, then to 3 + 2*x?
19:15:05 <Tordek> dibblego: that's [Complex]  and not [[Complex]] again ;[
19:15:20 <Cale> no
19:15:39 <dibblego> Tordek, oh I missed your extra brackets in the list comprehension
19:15:53 <mmorrow> _Ray_: the inside-out equivalent of that
19:15:57 <Cale> If f x = 2*x, then  1 + f (x-1+2) reduces to  let y = x-1+2 in 1 + 2*y
19:16:21 <Cale> Or, just  1 + 2*(x-1+2), since there's no sharing here to represent
19:16:59 <Cale> Lazy evaluation is outermost first (+sharing)
19:17:04 <_Ray_> hrm
19:17:10 <_Ray_> What about guards?
19:17:24 <Cale> _Ray_: I'll give you the example that I give everyone :)
19:17:28 <_Ray_> Say f was defined as 0 for 0, otherwise = 2*x?
19:18:03 <Cale> _Ray_: we technically still reduce f first, but it reduces to a conditional
19:18:13 <copumpkin> _Ray_: why bother breaking it into two? it's the same
19:18:29 <_Ray_> copumpkin, just an example =p
19:18:32 <Cale> Let's start simple. Suppose we have double x = x + x
19:18:33 <_Ray_> Say it was 1 for 0, then.
19:18:39 <Cale> and we want to reduce double (double 5)
19:18:49 <Cale> In strict evaluation, it goes:
19:18:52 <Cale> double (double 5)
19:18:53 <SamB_XP_> copumpkin: but does the compiler *know* that, and would it be an optimization for it to apply that knowledge ?
19:18:56 <Cale> -> double (5 + 5)
19:18:59 <Cale> -> double 10
19:19:02 <Cale> -> 10 + 10
19:19:04 <Cale> -> 20
19:19:16 <_Ray_> right, C like,
19:19:24 <_Ray_> s/,$/./
19:19:27 <Cale> In outermost first evaluation, instead we get
19:19:30 <Cale> double (double 5)
19:19:35 <Cale> -> (double 5) + (double 5)
19:19:40 <Cale> -> (5 + 5) + (double 5)
19:19:44 <Cale> -> 10 + (double 5)
19:19:47 <Cale> -> 10 + (5 + 5)
19:19:49 <Cale> -> 10 + 10
19:19:50 <SamB_XP_> (modulo sharing)
19:19:51 <Cale> -> 20
19:20:00 <Cale> Note that we wasted work here
19:20:04 <SamB_XP_> (with sharing, you need some kind of lets/heap ;-)
19:20:07 <Cale> by evaluating double 5 twice
19:20:14 <_Ray_> Yes, you'd memoize it
19:20:19 <Cale> So lazy evaluation does something smarter
19:20:23 <SamB_XP_> not unluss you're okasaki ;-P
19:20:35 <SamB_XP_> (he's the only one I know of who calls what we do that ;-)
19:20:45 <Cale> It says that parameters to a function share the evaluation between the copies.
19:20:47 <mmorrow> _Ray_: it's not that it's memoized, it's that both "double 5" are ptrs to the same thing in the heap
19:20:54 <Cale> This isn't quite the same thing as memoisation.
19:21:08 <SamB_XP_> unaccountably, okasaki calls it memoization anyway
19:21:13 <Cale> It's usually represented by using expression graphs rather than expression trees
19:21:19 <_Ray_> So is a hashtable used internally? "expression" => (if exists) reduction?
19:21:21 <Cale> But we can also represent it with let/in syntax
19:21:21 <_Ray_> Ah
19:21:24 <Cale> No.
19:21:36 <mmorrow> _Ray_: so ghc will /try/ to evaluate both, but the second time around, the code for that contructor will just jump to its continuation (which is the (+))
19:21:39 <Cale> There's no hashtable, and we don't store the results of functions generally.
19:21:49 <Cale> It goes like this:
19:21:51 <monochrom> It is the same mincing words as "monads are about computations".
19:21:52 <Cale> double (double 5)
19:21:58 <Cale> -> let x = double 5 in x + x
19:22:01 <SamB_XP_> mmorrow: I think it doesn't like to jump into already-evaluatated nodes ;-P
19:22:05 <Cale> (note that this is still outermost first)
19:22:11 <Cale> -> let x = 5 + 5 in x + x
19:22:12 <Axman6> _Ray_: if you want memoisation, you have to implement it yourself. it's not worth it for the compiler to do it, and probably rather slow
19:22:14 <Cale> -> let x = 10 in x + x
19:22:16 <Cale> -> 20
19:22:23 <mmorrow> SamB_XP_: if we're considering ptr tagging..
19:22:35 <_Ray_> Right.
19:22:54 <_Ray_> That's in the straightforward approach. But what if you have guards?
19:23:00 <Cale> _Ray_: so it's just by having the expression that we're reducing contain multiple references to the same expression
19:23:03 <mmorrow> _Ray_: so as SamB_XP_ notes, really i lied and ghc wouldn't try to eval both "double 5"
19:23:11 <Axman6> I have suggested adding syntax annotations to tell GHC that it should memoise the computations of a particular function, but not many people agree with me on it :(
19:23:16 <mmorrow> s since it tags ptrs as an optimization
19:23:17 <Cale> _Ray_: Well, depends on how guards translate.
19:23:31 <Cale> _Ray_: You can translate guards into nested case expressions
19:23:39 <mmorrow> and the tags indicate evaluatedness, to save a few jumps in the evaluated case
19:23:40 <SamB_XP_> Axman6: it's too complicated ;-P
19:23:42 <Cale> (without guards in them)
19:24:21 <Cale> and then when  case foo of ... is evaluated, we evaluate foo until we can determine which constructor matches
19:24:25 <monochrom> Axman6: I agree with you, but just saying "memoize" this is not enough, you have to add syntax to say in what way, too, for example Data.Map or array or hash table?
19:24:31 <_Ray_> Right. And similar for pattern matching?
19:24:34 <Cale> yeah
19:24:37 <Cale> Well, the very same
19:24:46 <Axman6> monochrom: true
19:24:58 <SamB_XP_> Cale: I thought guards got translated to ifs ;-P
19:25:10 <Cale> and ifs get translated to cases :)
19:25:38 <Cale> if foo then bar else quux  ->  case foo of True -> bar; False -> quux
19:26:18 <monochrom> In the limiting case, the domain and range of the function may be user-defined types, so you have to add enough syntax and semantics so the programmer can write customized algorithms and data structures for efficient memoization.
19:26:23 <Cale> case is somewhat fundamental, since it's the way we decompose algebraic datatypes
19:26:46 <_Ray_> So if f 0 = 0, f x = f (x+1) - x - 1, then f (f 3) gets evaluated to a sort of 'case statement', asking whether f 3 is 0, and if so, returning 0, else, returning f (f 3 + 1) - (f 3) + 1?
19:26:56 <Cale> So it's a bit harder to get rid of it, though it's possible to transform it into lambda if you don't mind transforming the constructors into lambdas as well.
19:27:01 <SamB_XP_> Cale: remind me why it isn't bananas that we use ?
19:27:07 <Cale> er, not lambda, function application :)
19:27:42 <monochrom> There is more. Sometimes you also want to code in expiration. When to drop certain memoized values, by what criterion.
19:27:45 <Cale> _Ray_: case expression, but yes
19:28:12 <monochrom> The syntactic addition for memoization must be a programming language in its own right.
19:28:20 <Cale> _Ray_: well,  f x = case x == 0 of True -> 0; False -> f (x+1) - x + 1
19:28:34 <_Ray_> Hrm.
19:28:39 * _Ray_ tries writing it on paper.
19:29:37 <Cale> So, f (f 3) -> case (f 3) == 0 of True -> 0; False -> f (x+1) - x + 1
19:29:41 <Cale> er
19:29:53 <Cale> So, f (f 3) -> let y = f 3 in case y == 0 of True -> 0; False -> f (y+1) - y + 1
19:29:58 <Cale> better :)
19:30:50 <Cale> and then the next thing to evaluate would be y == 0, which as it's primitive and not reducible, would have to be put on the stack while we evaluate y
19:33:20 <_Ray_> Interesting. So f (f (-3)) never terminates, since f (-3) = 3, and f 3 never terminates. Hrmph. Evil thing to put on a midterm, and then ask the value of.
19:33:34 <mmorrow> _Ray_: a strictness analyzer though would identify "f x = if x < 1 then x else 1 + f (x-1)" as strict in it's argument, and transform "\x -> f (f x)" to "\x -> case f x of y -> f y"
19:34:38 <c_wraith> _Ray_:  Formally, the value of an expression that never terminates is _|_
19:34:46 <_Ray_> Ah, undefined.
19:34:56 <copumpkin> it's actually a picture of the crack in someone's bottom
19:34:57 <Cale> I actually rather like the view that case is what puts things on the stack and let is what puts things on the heap.
19:35:05 <SamB_XP_> copumpkin: only in parens!
19:35:08 <SamB_XP_> (_|_)
19:35:09 <ivanm> _Ray_: undefined /= _|_
19:35:12 <copumpkin> mmm
19:35:16 <Cale> Unfortunately, that view is broken by bang patterns ;)
19:35:23 <SamB_XP_> the logo of one of our ICFP competetion teams ;-)
19:35:36 <_Ray_> Barring language differences, we were taught that in tri-valued logic, we had True, False and Undefined
19:36:07 <SamB_XP_> _Ray_: ah, like in Matlab you have numbers and NaN ?
19:36:09 <SamB_XP_> ;-P
19:36:35 <_Ray_> Sort of, but IEEE defines NaN, and (some other guy) defined tri-valued logic systems =p
19:36:38 <mmorrow> err, actually the strictness analyzer would transform it to
19:36:57 <mmorrow>  \x -> case x of y -> case f y of z -> f z
19:36:58 <SamB_XP_> "Go to your room!"
19:36:59 <SamB_XP_> ?
19:37:05 <mmorrow> (where "case" here is evaluating)
19:37:53 <mmorrow> which would significantly improve the stack usage
19:38:15 <mmorrow> (but it would still be O(n) asymptotically)
19:44:29 <mmorrow> ("still be O(n)" because `f' itself is still O(n))
19:44:52 <mmorrow> it'd just reduce the constant for (f (f x))
19:45:08 <hetman__> when I create a thread with forkIO, what happens to uncaught exceptions in that thread?
19:45:14 <hetman__> do they affect the thread they were spawned from?
19:45:37 <mmorrow> hetman__: i believe it depends on the exception
19:46:21 <mmorrow> e.g. you can throwTo a KillThread (or whatever) exception to a thread, and it'd be as if that exception were raised in that thread itself (and the thread would die)
19:46:45 <mmorrow> but heap or stack overflow exceptions will give your entire prog the chop
19:47:10 <mmorrow> (unless you catch them, but there's not a whole lot of (practical) things you could do)
19:47:27 <hetman__> what about IO errors?
19:47:35 <mmorrow> i'm not positive
19:47:42 <hetman__> I presume the uncaughtExceptionHandler has something to do with this, but the doco is a bit vague :-/
19:47:52 <mmorrow> that's global
19:48:00 <mmorrow> yeah, it very well may
19:48:13 <mmorrow> the question is if uncaught IO exceptions propogate globally
19:49:06 <mmorrow> which you could write a test program to find out (and if you do i'd be interested in your results)
19:49:33 <SamB_XP_> mmorrow: you mean IOErrors ?
19:49:50 <SamB_XP_> or (_|_ :: IO a) ?
19:49:55 <mmorrow> is that different that IOException?
19:49:59 <FunctorSalad> does "total" just mean that x /= _|_ ==> f x /= _|_ ?
19:50:07 * mmorrow never uses the Prelude.catch
19:50:08 <SamB_XP_> @hoogle IOError
19:50:08 <lambdabot> Prelude type IOError = IOException
19:50:08 <lambdabot> System.IO.Error type IOError = IOException
19:50:08 <lambdabot> Prelude ioError :: IOError -> IO a
19:50:11 <FunctorSalad> or must the images be total too
19:50:19 <SamB_XP_> @hoogle catch
19:50:19 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
19:50:19 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
19:50:19 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
19:50:30 <mmorrow> SamB_XP_: ah, so IOError is just a syn
19:50:36 <FunctorSalad> (is "const (undefined,undefined)" total?)
19:50:41 <SamB_XP_> mmorrow: well, it's the official name!
19:50:44 <mmorrow> :)
19:50:45 <SamB_XP_> isn't it?
19:51:28 <hetman__> I guess this is trickier because of the lazy evaluation, so if an IOError is raised in a new thread, where does it come out of in the main thread? and is there any way to control that
19:51:29 <hetman__> ugh
19:52:14 <SamB_XP_> I don't think such IOErrors are propagated
19:52:24 <mmorrow> hetman__: the safe/sane thing to do is to wrap anything you're worried about this happening in in catch/whatever
19:52:49 <SamB_XP_> far more likely is something goes to stderr and the thried just dies
19:53:04 <SamB_XP_> and if everything deadlocks after that, *then* it dies ;-P
19:53:09 <mmorrow> yay!
19:53:46 <hetman__> lol, the problem is I NEED the IOError to propagate to the spawning thread
19:54:02 <c_wraith> looks like the IOError is handled by the standard mechanism
19:54:07 <c_wraith> But doesn't propogate back
19:54:13 <c_wraith> which is what I'd expect
19:54:18 <SamB_XP_> hetman__: I'm thinking you'll need to catch it and send it through a channel
19:54:26 <hetman__> what's the standard mechanism?
19:54:32 <mmorrow> heh, in that case you could somehow catch IOErrors in the spawned thread, then throwTo the spawning thread
19:54:45 <mmorrow> @hoogle throwTo
19:54:45 <lambdabot> Control.Concurrent throwTo :: Exception e => ThreadId -> e -> IO ()
19:54:45 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
19:54:45 <lambdabot> Control.OldException throwTo :: Exception e => ThreadId -> e -> IO ()
19:54:50 <SamB_XP_> or throwTo, if you can know who the spawning thread was ?
19:55:05 <SamB_XP_> @hoogle IO ThreadId
19:55:05 <lambdabot> Did you mean: :: IO ThreadId /count=20
19:55:05 <lambdabot> No results found
19:55:14 <c_wraith> :t forkIO
19:55:14 <SamB_XP_> @hoogle IO ThreadId /count=20
19:55:14 <lambdabot> Did you mean: :: IO ThreadId /count=20 /count=20
19:55:15 <lambdabot> No results found
19:55:15 <lambdabot> Not in scope: `forkIO'
19:55:22 <SamB_XP_> @hoogle :: IO ThreadId /count=20
19:55:22 <lambdabot> Control.Concurrent myThreadId :: IO ThreadId
19:55:22 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
19:55:22 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
19:55:26 <mmorrow> forkIOWithSpawningThreadId :: (ThreadId -> IO ()) -> IO ThreadId
19:55:27 <hetman__> yeh, I was planning to throwTo but then I realised I didn't know exactly what was going on so the increased complexity could lead to some random results
19:55:58 <SamB_XP_> @hoogle forkIOWithSpawningThreadId
19:55:58 <lambdabot> No results found
19:56:08 <SamB_XP_> mmorrow: now you're just making stuff up!
19:56:22 <mmorrow> i mean that could be a nice wrapper you'd write
19:56:23 <SamB_XP_> also, I vote we paint it muave
19:56:54 <mmorrow> forkIOAndPropogate :: IO () -> IO ThreadId; forkIOAndPropogate io = do tid <- myThreadId; forkIO (catch io (\e -> throwTo tid e))
19:57:11 <hetman__> the problem is, the standard library doesn't really document what kind of exceptions I should be expecting from any given function... so I'm not sure what I need to catch in the spawned thread, and what I need to let through (catching the ThreadKilled exception would be bad)
19:57:54 <Axman6> hetman__: well, SomeException e matches all exceptions i think
19:57:57 <hetman__> mmorrow: that's how far I got but what about ThreadKilled exception etc
19:58:21 <mmorrow> hetman__: ThreadKilled i believe are given to the /spawning/ thread
19:58:47 <mmorrow> since you can't catch killThread = throwTo IForget exceptions
19:59:10 <mmorrow> well, you can block, but once you unblock it's game over
19:59:28 <mmorrow> @src killThread
19:59:28 <lambdabot> killThread tid = throwTo tid (AsyncException ThreadKilled)
19:59:29 <hetman__> mmorrow: they are thrown to the thread intending to be killed, from GHC.Conc: killThread tid = throwTo tid ThreadKilled
19:59:39 <hetman__> mmorrow: intended*
20:00:01 <mmorrow> ah, i was thinking Threadkilled was indicating the /result of being killed/
20:00:23 <mmorrow> ok, so i don't believe you can catch those (?)
20:00:39 <hetman__> why not?
20:00:58 <c_wraith> out of curiosity, why do you need errors to propogate?
20:01:04 <mmorrow> hetman__: e.g. you can't catch SIGKILL
20:01:14 <mmorrow> hetman__: and i'm imagining it's like that
20:01:37 * SamB_XP_ wonders why MS couldn't get Bill to sign copies of Windows 7, rather than allowing Balmer to sign 'em ...
20:01:38 <mmorrow> hetman__: although it may not be (but i really think it is)
20:01:52 <mmorrow> hetman__: experiment! :)
20:01:57 <hetman__> mmorrow: but SIGKILL is from a different mechanism alltogether, you can catch SIGTERM after all so who knows what the designers implemented
20:02:04 <mmorrow> hetman__: right
20:02:09 <mmorrow> hetman__: and right
20:02:26 <mmorrow> the only way to find out is to find out :)
20:02:33 <hetman__> yeh, seems that way
20:04:05 <c_wraith> hetman__:  for reference, here's the test I used http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11227#a11227
20:05:51 <mmorrow> ghci> tid <- forkIO (let go = threadDelay maxBound in catchAll go (\_ -> print 42 >> go))
20:05:51 <mmorrow> ghci> killThread tid
20:05:51 <mmorrow> 42
20:05:51 <mmorrow> ghci> killThread tid
20:05:52 <colton_> Is there a method to split a list at a particular index?
20:05:55 <mmorrow> <no response>
20:06:02 <ddarius> :t splitAt
20:06:03 <lambdabot> forall a. Int -> [a] -> ([a], [a])
20:06:15 <mmorrow> catchAll = catch :: IO a -> (SomeException -> IO a) -> IO a
20:06:25 <mmorrow> gah
20:06:27 <mmorrow> my error
20:06:32 <mmorrow> should put the catch /in/ go
20:06:35 * mmorrow retries
20:07:39 <mmorrow> hetman__: ok, it looks to be SIGTERM instead of SIGKILL
20:08:24 <mmorrow> so there's no way to kill a thread that's catching everything and ignoring
20:08:39 * mmorrow quits ghci now to get his threads under control..
20:09:44 <mmorrow> tid <- forkIO (let go = catchAll (threadDelay maxBound) (\e -> print e >> go) in go)
20:09:59 <mmorrow> replicateM_ 1000000000000 (killThread tid)
20:10:15 <mmorrow> will print "thread killed" 100000000000 times
20:10:33 <hetman__> ok, well that answers that
20:10:48 <sjanssen> mmorrow: ah, you just gotta send an exception with a crashing show!
20:10:56 <mmorrow> sjanssen: heh
20:10:57 <sjanssen> of course that won't work in other cases
20:11:13 <sjanssen> send a malformed value that causes GHC to rewrite the stack and kill the thread?
20:11:30 <c_wraith> unsafeCoerce is your friend?
20:12:31 <mmorrow> forkIO a forkbomb that sends a KillThread to a single thread in every exponential thread it spawns? (oh yeh, you'll die shortly too)
20:12:47 <mmorrow> fix (\o -> mapM_ forkIO [o,o])
20:13:18 <ddarius> :t fix (\o -> mapM_ forkIO [o,o])
20:13:19 <lambdabot> Not in scope: `forkIO'
20:13:24 <mmorrow> \tid -> fix (\o -> mapM_ forkIO [o,o] >> forever (killThread tid))
20:13:33 <mmorrow> ddarius: it works (as a fork bomb)
20:13:47 <mmorrow> ghci locks up cold
20:14:01 <mmorrow> needing a kill -9
20:17:01 <mmorrow> @type fix (\o -> mapM_ Control.Concurrent.forkIO [o,o])
20:17:02 <lambdabot> IO ()
20:17:38 <monochrom> Who is trying to fork-bomb?!
20:17:59 <mmorrow> ooh ooh, me!
20:18:47 <monochrom> wait, you're forkbombing but you're also killbombing
20:21:46 <mmorrow> i wonder if s/forkIO/forkOS/ in that forkbomb would take down your system
20:21:53 * mmorrow doesn't want to try atm
20:22:03 <mmorrow> monochrom: oh yesh
20:23:01 <mmorrow> well, maybe (?) it wouldn't, since those'd be pthreads/equiv and not processes
20:23:46 <SamB_XP_> mmorrow: well, if you are still on LinuxThreads, is there a difference ?
20:24:09 <mmorrow> SamB_XP_: heh, is that like <= 2.4 kernel?
20:24:28 <SamB_XP_> well, it depends also on your libc
20:24:45 <mmorrow> dunno (if there's a difference)
20:25:08 <SamB_XP_> well, in ps/top, linuxthreads threads show up as processes
20:25:21 <SamB_XP_> ('cause that's just what they are)
20:26:05 <mmorrow> so you're saying that some 2.6 kernels with a particular libc implement pthreads as LinuxThreads?
20:27:06 <mmorrow> http://pauillac.inria.fr/~xleroy/linuxthreads/
20:27:33 <mmorrow> it doesn't say anything about kernel version there though
20:27:51 <SamB_XP_> mmorrow: I'm thinking it doesn't matter what kernel you use, much
20:27:58 <mmorrow> ah
20:28:00 <mmorrow> inux version 2.0 and up (requires the new clone() system call
20:28:01 <mmorrow>   and the new realtime scheduler).
20:28:03 <SamB_XP_> I mean, if you use a LinuxThreads library
20:28:04 <mmorrow> clone()
20:30:14 <ygd-coder> why does my wxhaskell application say "failed to load shared library 'comctl32.dll'"?
20:30:32 <ygd-coder> it still works when I press ok though
20:31:01 <ygd-coder> anyone?
20:31:26 <p_l> in theory you could use LinuxThreads on 2.6.x, just by using only the stuff that was made available in 2.4 I think...
20:31:39 <ygd-coder> i'm running windows 7
20:31:58 <SamB_XP_> not just in theory
20:32:14 <EvilMachine> donâ€™t PosixThreads work on Linux, Win7 and OSX?
20:32:27 <p_l> EvilMachine: pthreads is just library interface
20:32:28 <SamB_XP_> ygd-coder: I guess it can't find comctl32.dll?
20:32:30 <ygd-coder> the program still works though
20:32:39 <ygd-coder> but what is comctl32.dll?
20:32:39 <SamB_XP_> ygd-coder: how odd!
20:32:53 <EvilMachine> p_l: but one that is usable everywhere, no? ^^
20:32:54 <SamB_XP_> it has stuff like the "Open" dialog
20:32:56 <EvilMachine> whatever
20:33:03 <p_l> Ah, found it - 2.6 added extra flags to clone family of calls and recognized threads on scheduler level
20:33:19 <mmorrow> ah
20:34:05 <SamB_XP_> p_l: and treats signals in a posixly-correct way, too
20:34:21 <p_l> EvilMachine: It is usable, if you have a library that interfaces your OS' native threading system (clone(2) for Linux, Mach threads for OSX, winapi threads, VMS threading etc.)
20:34:43 <p_l> SamB_XP_: that's cause processes have two PIDs now :D
20:34:53 <SamB_XP_> p_l: hmm?
20:35:06 <SamB_XP_> interesting
20:35:47 <EvilMachine> p_l: I thought youâ€™d just use System.Posixâ€¦, and thatâ€™s it
20:36:11 <p_l> SamB_XP_: each thread is its own process, still, like in 2.4. The difference is that signals are dispatched on thread group id, not pid
20:36:42 <SamB_XP_> p_l: well, they also don't look like processes at the UI level
20:36:56 <SamB_XP_> I mean, top and ps don't show them as seperate processes anymore
20:37:13 <p_l> SamB_XP_: because they filter them by default
20:37:21 * p_l has all threads visible in htop
20:37:21 <SamB_XP_> they couldn't do that before
20:38:51 <p_l> getpid() on linux returns TGID of the process (Thread Group ID)
20:39:18 <EvilMachine> hey, I just thought: if there is a set of data types, who all have two fields -- with the same name and the same type -- in common, ...
20:39:25 <EvilMachine> then it should be easy for the compiler, to automatically derive the instance declaration
20:39:32 <EvilMachine> (of a class that only accesses those two fields for one of the types in that set) to all the other types is that set.
20:39:36 <EvilMachine> is there already something like a lib or TH program to do that?
20:40:01 <ddarius> EvilMachine: Derive can probably do it.
20:40:40 <EvilMachine> ddarius: what do you meant with "Derive"? That one here? http://community.haskell.org/~ndm/derive/
20:41:00 <EvilMachine> that would save a lot of work. :)
20:41:19 <ddarius> EvilMachine: Yes.  I'm not sure if that's the latest copy, but that program/lib.
20:41:36 <mmorrow> EvilMachine: i don't think it currently has that particular derivation, but in principle it could
20:41:47 <EvilMachine> ddarius: ok, I'm officially impressed. :)
20:41:49 <ddarius> There's a code-by-example feature.
20:42:07 <EvilMachine> I'll check it out.
20:42:52 * EvilMachine wonders how long it will take, until the Haskell mindset bekomes sentient in itself, and wants to take over all of reality. ^^
20:44:40 <Zao> I had a scary a-ha moment with HSH today.
20:45:01 <Zao> I had the samples on the wiki in a corner of the screen and suddenly out of nowhere the types of it clicked in my head.
20:46:13 <ddarius> Where's the scary part?
20:46:41 <Zao> Subconciously understanding code that didn't make much sense at all earlier.
20:46:41 <EvilMachine> ddarius: i guess it was like the "woah" part of neo in the matrix
20:47:11 <EvilMachine> where he suddenly can change reality (in the matrix), and see and understand it all.
20:47:12 <ddarius> Zao: When you start writing correct code that passes the type checker on the first try, then you need to start being scared.
20:47:19 <EvilMachine> ddarius: lol
20:47:49 <Zao> ddarius: That has happened a few times.
20:47:54 <Zao> "Linking main...", wtf?
20:48:08 <EvilMachine> ddarius: nah, thatâ€™s possible. if you can do it with custom monads, functor, arrows,applicatives. *THEN* Iâ€™m impressed. ;)
20:48:32 <ddarius> EvilMachine: One of the times I did it was implementing a CPS based monad.
20:49:39 <EvilMachine> CPS? lol. i thought for a moment, you meant the "Capcom Play System"
20:50:03 <EvilMachine> or compact polystyrene
20:50:04 <EvilMachine> :P
20:50:30 <EvilMachine> (the wikipedia-list goes on, and on, and on. itâ€™s the only disambiguation page i have seen, that has chapters *and* sub-chapters! ^^)
20:50:39 * EvilMachine wonders: Where does it end, when you meta the meta of something, and meta that, and meta the infinte list of those metaing metas, into another dimension of metain, and so on for all dimensions, and then meta it on another context, and so on, and so onâ€¦ what is the ultimate ... (i don't even have a word for it)?
20:50:47 <mmorrow> EvilMachine: after you get to the point where you're not getting semantic type errors, it's just a matter of not making some misc syntactic oversight over the course of 500/N lines
20:51:03 <ddarius> EvilMachine: You should look at surreal numbers.
20:51:25 <EvilMachine> ddarius: sounds like LSD math. :D
20:51:38 <mmorrow> EvilMachine: LSD would probably help while coding haskell
20:52:09 <EvilMachine> agreed
20:52:11 <scutigera> oh, I don't know, examples help a lot...
20:52:23 <mmorrow> EvilMachine: assuming you haven't taken so much that the pink walrus sitting next to you just won't stop staring
20:53:18 <EvilMachine> scutigera: that is, why math tutorials fail most of the time. because they start with throwing the formual in your face, instead of telling you the problems that it was invented for, and the usages in examples, before generalizing to the modern form.
20:53:34 <monochrom> Your meta-levels can be indexed by the ordinals.
20:53:48 <EvilMachine> mmorrow: nah. thatâ€™s just a mirror! :D
20:54:04 <monochrom> Not just indexed. They are order-isomorphic too.
20:54:10 <scutigera> EvilMachine: I find the hackages to be quite vexing w.r.t. lack of useful examples.
20:54:14 <mmorrow> EvilMachine: heh
20:54:41 <scutigera> which is what brings me here this evening :-)
20:54:58 <EvilMachine> ddarius: about the metaing: but surreal numbers donâ€™t end it all. you can still meta surreal numbers. i guess i just wondered, if there is something, that you can't ever meta any more.
20:55:22 <EvilMachine> ddarius: or am i wrong?
20:58:45 <EvilMachine> scutigera: i find the haskell wiki to be the first step into useful examples. hackage usually looks like this: http://hackage.haskell.org/package/derive ... plain haddock output. the homepages usually are the most useful documentation.
21:00:14 <scutigera> EvilMachine: definitely, haskell wiki is very nice.
21:00:28 <dancor> games are more general than surreal numbers
21:01:23 <EvilMachine> dancor: i assume you're not talking about the games that you play (e.g. chess or Doom 3 ;)
21:01:39 <dancor> i've never played doom 3!
21:01:53 <mmorrow> , , randM crapsM
21:01:54 <lunabot>  luna: parse error on input `randM'
21:01:56 <mmorrow> , randM crapsM
21:01:58 <lunabot>  (âš…,âš…)
21:02:24 <monochrom> <sarcasm> Book Review for RWH: This book repeats the failure of all math tutorials. It starts with throwing actual code in your face, instead of telling you the problems that Haskell was invented for, or historical backgrounds such as how Backus invented FP and why, what programming was like before Backus... Oh, to be sure, it does have a short blurb claiming FP is so much better, but even that one is merely "we believe" and
21:02:24 <monochrom> "believe me and you will see" make-believe, not at all any substantiated motivation. </sarcasm>
21:04:11 <scutigera> monochrom: how dare you...
21:04:13 <EvilMachine> dancor: you did not miss much. :) Out of Far Cry, Doom 3, Half-Life 2, and "Riddick: Return to Butcher's Bay", Riddick was the best anyway.
21:04:15 <EvilMachine> dancor: HL2 perhaps felt more sophisticated, but Riddick did beat them all in graphics and sheer fun. unfortunately everybody thought it would be another crappy movie adaptation
21:04:19 <_Ray_> I must say, fewer things make me more lazy than writing Haskell in pen & paper. Reductions are only fun when you type them.
21:04:20 <kmc> mmorrow, funny, the haskell/psychedelics connection keeps coming up
21:04:25 <EvilMachine> dancor: but back to the topic. ^^
21:04:54 <kmc> there was significant overlap between the enthusiast groups at least at my school
21:05:17 <scutigera> to here RWH insulted so.  I skip out on #haskell for a while and when I come back, nothing but heretics.
21:05:48 <mmorrow> scutigera: perhaps an inquisition is in order
21:06:06 <EvilMachine> kmc: well, what else can blow your mind like Haskell? Quantum physics / general relativity and drugs are the only two areas that come to mind. :)
21:06:36 <monochrom> It is sarcasm to refute a false accusation of math tutorials diving head in.
21:07:20 <scutigera> mmorrow: or penance. something meta, or monad-y
21:07:28 <ivanm> EvilMachine: well, other things can blow your mind but not necessarily in a good way like haskell can... (e.g. software patents, etc.)
21:09:12 <mmorrow> scutigera: replicateM_ 1000 selfFlagellation :: InquisitionM ()
21:09:25 <EvilMachine> monochrom: i think you really misunderstood me. i meant the "throwing things in your face that you *can't possibly parse*" problem. :) if you "throw 'actual code / math' in my face" that i can parse without first reading or knowing anything else, then that's not the problem of course. :)
21:09:33 <mmorrow> 10000 for teh real sinnerz
21:11:12 <EvilMachine> ivanm: to me that's not blowing your mind. because blowing your mind to me always is good. if it's bad, i just call it "madness" or "insanity". ^^ the logic behind religious beliefs would be such an example. even if it's consistent in itself.
21:11:21 <ivanm> heh
21:11:57 <EvilMachine> mmorrow: you missed such a nice chance to sew "nobody expects the spanish inquisiton" in there. :D
21:12:25 <mmorrow> i forgot my needle and thread
21:12:34 <scutigera> EvilMachine: good one. that was quite the missed opportunity.
21:13:10 * EvilMachine gives mmorrow a logic neede and roll of mind-thread.
21:13:17 * BMeph gasps: No one expects the scutigera inquisition!
21:13:19 <Gracenotes> looking into the part of the Haskell compiler where denotational and operational parts meet is blowing my mind a bit :o
21:14:06 <BMeph> EvilMachine: :)
21:14:21 <EvilMachine> Gracenotes: OMG. I repressed the existence of it.
21:14:52 <Gracenotes> that's okay, if you ignore it, it's replaced with magic
21:15:01 <EvilMachine> Gracenotes: does it come close to unlambda code?
21:15:47 <Gracenotes> well.. hate to disappoint you.. >_>
21:16:00 <EvilMachine> Gracenotes: what? even worse? malbolge? ^^
21:16:50 <Gracenotes> nay, LOLCODE
21:17:02 <EvilMachine> hey, after all this, my mind is so fit, that the problem i was stuck at (one of the reasons I came here), now looks completely obvious. :D
21:17:04 <Gracenotes> LOLCODE is actually pretty readable. but it's the algorithm itself that's a mindbend
21:17:16 <EvilMachine> lol. LOLCODE is the greatest language ever! :D
21:17:37 <aavogt> @faq is haskell better than LOLCODE?
21:17:37 <lambdabot> The answer is: Yes! Haskell can do that.
21:17:53 <Cale> We need a Hasklol
21:17:54 <EvilMachine> lambabot is payed to always say that. ^^
21:17:58 <_Ray_> Can I pattern-match nested constructors?
21:18:06 <Cale> _Ray_: yes
21:18:11 <_Ray_> Thanks :)
21:18:15 <Cale> @faq Can I pattern-match nested constructors?
21:18:15 <lambdabot> The answer is: Yes! Haskell can do that.
21:18:20 <_Ray_> ...wtf.
21:18:22 <Gracenotes> close enough
21:18:26 <_Ray_> Please don't tell me it's self aware.
21:18:38 <aavogt> @faq is haskell self-aware?
21:18:38 <lambdabot> The answer is: Yes! Haskell can do that.
21:18:42 <_Ray_> ...
21:19:07 <Gracenotes> although, I am reading that case expressions are made nested-level in translation, rather than nested-within-one-level
21:19:07 <_Ray_> @faq is haskell an imperative language?
21:19:08 <lambdabot> The answer is: Yes! Haskell can do that.
21:19:13 <_Ray_> Aha!
21:19:17 <ivanm> _Ray_: that's what do-blocks are for
21:19:18 <Cale> @faq Can Haskell create a corndog so large even Haskell can't eat it?
21:19:18 <lambdabot> The answer is: Yes! Haskell can do that.
21:19:29 <ivanm> Cale: Haskell can't eat _anything_
21:19:39 <Cale> @faq Can Haskell eat anything?
21:19:40 <lambdabot> The answer is: Yes! Haskell can do that.
21:19:43 <ivanm> so as long as it can create a corndog, it's fulfilled your requirements!
21:19:50 <ivanm> Cale: damn, you saw through my evil plot!
21:19:57 <ivanm> @faq Can Haskell prove Cale wrong?
21:19:58 <lambdabot> The answer is: Yes! Haskell can do that.
21:20:00 <ivanm> aha!
21:20:12 <EvilMachine> Cale: i thought about that, and you could just refactor a language that would let you get all artsy. imagine writing "main = uum, a cool program to do something... 'n stuff. yeah. cool stuff... with music and things. things you can use..." and haskell would come up with something, assuming what the average drug user would expect. :D
21:20:14 <Gracenotes> that's not true, actually. only true for Agda.
21:20:22 <Cale> @faq Can Haskell prove @faq wrong?
21:20:23 <lambdabot> The answer is: Yes! Haskell can do that.
21:20:25 <aavogt> heh, somebody could tell lb to @msg #haskell
21:20:35 <ivanm> aavogt: the point being?
21:21:03 <EvilMachine> @faq Can I Haskell guarantee me that I take over the world tomorrow?
21:21:03 <lambdabot> The answer is: Yes! Haskell can do that.
21:21:10 <aavogt> @vixen but you're useful enough?
21:21:10 <lambdabot> let's don't talk about that
21:21:22 <ivanm> EvilMachine: Can I EvilMachine understand properly? :p
21:21:34 <ivanm> oh, wait, what I said actually almost makes sense...
21:21:48 <ivanm> aavogt: so @vixen is useful to you in unspeakable ways? :p
21:22:16 <EvilMachine> ivanm: what if "I" were a monad? :P
21:22:35 <ivanm> EvilMachine: can you contain any arbitrary value? :p
21:23:08 <EvilMachine> ivanm: for values smaller than painful ones, yes. :P
21:23:22 <EvilMachine> ivanm: but space warping could help with the rest.
21:23:25 * ivanm didn't really get the point of the holey monoid..
21:24:15 <c_wraith> holy monoid, CTman!
21:24:18 <EvilMachine> the holey monoid? oh my, how many... uuum... arrows... would she be able to take? :P
21:24:20 <aavogt> @fqa
21:24:20 <lambdabot> Maybe you meant: faq ft
21:24:41 <EvilMachine> @faq ft
21:24:42 <lambdabot> The answer is: Yes! Haskell can do that.
21:24:42 <EvilMachine> :P
21:24:49 <ivanm> @help ft
21:24:49 <lambdabot> ft <ident>. Generate theorems for free
21:25:02 <ivanm> @ft a -> a
21:25:03 <lambdabot> Done.
21:25:07 <ivanm> heh
21:25:29 <Gracenotes> @free ptr
21:25:30 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `ptr'\n\n"
21:25:56 <EvilMachine> @ft TheUltimateTheoremForLifeTheUniverseAndEverything
21:25:57 <lambdabot> Done.
21:26:03 <aavogt> @ft (a -> b) -> (b -> c) -> a -> c
21:26:04 <lambdabot> Done.
21:26:16 <EvilMachine> lambdabot: what is your answer?
21:26:27 * EvilMachine guesses: 42
21:26:43 <kmc> does it say anything other than "Done."?
21:26:45 <ivanm> @vixen lambdabot, o lambdabot, wherefor art though lambdabot?
21:26:45 <lambdabot> is that really what you want to know?
21:26:46 <Gracenotes> @free (.)
21:26:46 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:26:51 <aavogt> @free theorem
21:26:52 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `theorem'\n\n"
21:27:00 <kmc> @free map
21:27:01 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
21:27:08 <kmc> @ft map
21:27:09 <lambdabot> Done.
21:27:14 <Gracenotes> :/
21:27:20 <kmc> @free concatMap
21:27:21 <lambdabot> $map g . h = k . f => $map g . concatMap h = concatMap k . $map f
21:27:25 <aavogt> so ft is useless
21:27:26 <kmc> @free id
21:27:27 <lambdabot> f . id = id . f
21:27:35 <EvilMachine> @free TheUltimateTheoremForLifeTheUniverseAndEverything
21:27:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
21:28:18 <EvilMachine> ok, enough playing. i'll go back to work.
21:28:27 <c_wraith> @free yourMind
21:28:28 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `yourMind'\n\n"
21:28:54 <Gracenotes> apparently there are two different modules, lambdabot/Plugin/Free.hs and lambdabot/Plugin/FT.hs
21:31:42 <Gracenotes> apparently, the latter queries the type of an expression.. then does "run binary src" on a version of it, where binary = "ftshell"
21:31:49 <EvilMachine> oh, i forgot something: when your types are not recursive, then when do you create a new "data" type, instead of just a "type" alias, and what is the point of "newtype", when data can do everything it can?
21:32:07 <kmc> EvilMachine, newtype is more efficient
21:32:14 <kmc> it does not add an extra layer of boxing
21:32:30 <kmc> this is why it's restricted to a single constructor with a single field
21:32:40 <EvilMachine> kmc: as data? ah ok, good to know. although i think that ghc should be able to automate that. :)
21:32:41 <kmc> the runtime rep of the newtype is the same as the runtime rep of the thing inside
21:33:04 <kmc> EvilMachine, there is a semantic distinction... if Foo is a newtype then Foo _|_ is the same as _|_
21:33:09 <kmc> for that reason
21:33:28 <c_wraith> Also, newtype lets you use the GeneralizedNewtypDeriving extension to derive a lot of things for free
21:33:31 <blackh> c_wraith: Ah - my mind is not in scope.  That explains a few things.
21:34:00 <kmc> as for "type", only use it if you consider the the new name to be truly interchangable with the old type
21:34:28 <EvilMachine> kmc: you're lucky that i know, that "_|_" means "undefined" because that link a giant taboo, that even the haskell report does not explain. let alone the books, wiki pages and tutorial i read.
21:34:44 <kmc> yeah it's a strange convention, comes from logic
21:34:53 <c_wraith> EvilMachine:  The page on denotational semantics explains it
21:35:11 <c_wraith> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
21:35:35 <c_wraith> That's actually a pretty good resource
21:35:56 <kmc> it's important to get into the mind set of "types are a way for me to avoid mistakes i might make" rather than "types are a way to tell the machine how to represent values"
21:35:59 <EvilMachine> kmc: well, the promlem is: how do you *search* for "_|_"? ^^ there is no way in hell, that you will ever get from it to that wikibooks page, without you stumbling upon someone explaining it first. :/
21:36:13 <kmc> if you're writing an RPG, you want gold and hit points to be different types, even though they might both be integers
21:36:22 <kmc> so that you don't accidentally add them together
21:36:44 <EvilMachine> kmc: Google not supporting regular expressions or at least non-alphanumeric characters, is the biggest problem it has.
21:36:45 <EvilMachine> by far
21:36:46 <c_wraith> @src Num
21:36:46 <lambdabot> class  (Eq a, Show a) => Num a  where
21:36:46 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:36:46 <lambdabot>     negate, abs, signum     :: a -> a
21:36:46 <lambdabot>     fromInteger             :: Integer -> a
21:36:53 <kmc> C's "typedef" and Haskell's "type" don't provide that safety; it's just an alias
21:36:57 <kmc> but "newtype" and "data" do
21:37:20 <kmc> and "newtype" has the advantages of no runtime overhead, plus automatic deriving of any typeclass the thing inside has (with a GHC extension)
21:37:22 <c_wraith> So...  You'd need GeneralizedNewtypeDeriving to make HitPoints and Gold useful newtypes, so that you could just derive Num
21:38:18 <kmc> likewise, if i find myself using a "type" alias for something with Maybe, Either, or a tuple, it's worth considering instead defining a new algebraic type with "data"
21:39:21 <scutigera> kmc: great point about types, I was thinking about them in terms of representation.
21:39:35 <EvilMachine> ah, ok. that clarifies it. remembers { newtype = efficient data; data, newtype = to deliberately separate from others by disallowing function usage except where specified. }
21:40:32 <c_wraith> type is mostly for reducing the amount of typing when you want to use a huge type (like a transformed monad) and everything defined for it, but want a short name for it.
21:40:38 <scutigera> so is newtype a bit of syntactic sugar, you would be able to get the same effect from data, right ?
21:40:57 <kmc> scutigera, the syntax is not different
21:41:02 <kmc> (except for the generalized deriving)
21:41:11 <kmc> the important thing is that the newtype does not add runtime overhead over the thing it contains
21:41:12 <EvilMachine> scutigera: yes
21:41:29 <kmc> and that it does not add an extra "layer of laziness"
21:41:32 <EvilMachine> yes, the efficiency is the difference
21:41:33 <dolio> newtypes are isomorphic to the type they wrap. data is not.
21:42:13 <scutigera> hurries over to haskell wiki...
21:42:32 <kmc> although i wonder... if you have "newtype Foo = Foo Int", what happens in "case Foo undefined of { Foo _ -> ()}"?
21:42:40 <EvilMachine> one could say, that newtype has some features of data (separation) while stil having some of type that are missing in data (all the functions you can use with it)
21:42:56 <kmc> "Foo undefined" is "undefined", but the  match shouldn't need to even evaluate the value at all, because ther's only one possible ctor... does it force to WHNF anyway to preserve semantics?
21:43:15 <kmc> EvilMachine, that's not true... if a function expects an Int you can't pass a Foo
21:43:33 <kmc> but, if a typeclass is defined for Int, you can (in GHC) get it automatically defined for Foo as well
21:43:57 <kmc> as for monads i agree about the transformer stacks, but i sometimes like to newtype those as well (and derive Monad, MonadState, MonadError...)
21:44:04 <EvilMachine> kmc: that was what i meand with "(separation)". with "all the functions" i meant the deriving.
21:44:18 <kmc> it's nice to provide (by export) a monad which is "actually" a transformer stack, but only expose some higher-level app-specific primitives
21:44:46 <c_wraith> kmc: doesn't that lose the ability to work with any part of it that isn't defined by a typeclass?
21:44:55 <kmc> c_wraith, what do you mean?
21:45:14 * EvilMachine does not know what a transformer stack is. although he knows what a transformer, a transformation or a stack is.
21:45:14 <_Ray_> Question. I have a data Jenga = New | Right Int Jenga | Left Int Jenga. I'm asked to make a "compact" function, such that Right 5 ( Right 6 ( foo )) becomes Right 11 foo, same with Left. So far I've made a function that searches for Right n (Right m y)) = Right (n+m) (f y), and same with Left. However, when I apply this to Right 1 (Right 2 (Right 3 foo)) It'll give me Right 3 (Right 3 foo). Am I correct in thinking that the best solution is
21:45:14 <_Ray_>  to loop until the function outputs the same as its input?
21:45:58 <kmc> _Ray_, can you hpaste what you have?
21:46:17 <kmc> EvilMachine, there are "monad transformers" which add the properties of one monad to another
21:46:17 <_Ray_> I'll have to type it first xD *is doing this in pen & paper*
21:46:27 <kmc> :)
21:46:30 <kmc> pen & paper does not have a REPL
21:46:39 <kmc> well it does but it's in your mind
21:46:40 <c_wraith> kmc: Looking at Control.Exception.Synchronous ExceptionalT, there's a function throwT :: e -> ExceptionalT e m a
21:46:57 <c_wraith> kmc: There's no typeclass that you can derive that lets that work.
21:46:58 <EvilMachine> kmc: scanner + text recognition = win. ^^
21:47:13 <c_wraith> kmc: So if you newtype it, you lose the ability to use that.
21:47:24 <EvilMachine> kmc: especially handwriting recognition
21:47:56 <kmc> c_wraith, do you have a link to the doc for that module? i don't see it in haskell.org/ghc/docs/latest
21:48:28 <_Ray_> kmc, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11228
21:48:33 <c_wraith> kmc: oops, got the name wrong    http://hackage.haskell.org/packages/archive/explicit-exception/0.1.4/doc/html/Control-Monad-Exception-Synchronous.html
21:49:05 <_Ray_> I'm thinking I'll loop compactar x until x == compactar x, then return x?
21:49:08 <kmc> c_wraith, which part are you newtyping? the exception or the monad?
21:49:54 <c_wraith> kmc:  Neither.  I'm using type.  My point is that if you newtype the transformed monad, you can't use the functions that are the whole reason you'd want to use that transformer
21:51:07 <kmc> c_wraith, yeah.  it works best in cases like StateT and ErrorT where there is a typeclass (MonadState, MonadError) with the operations in it
21:51:11 <kmc> it's unfortunate that this one isn't
21:51:19 <kmc> anyway you can wrap it easily, i agree it's an annoyance though
21:53:44 <kmc> _Ray_, how about "compactar Der n (Der m y) = compactar (Der (n+m) y)"
21:53:48 <kmc> and similarly for the second equation
21:53:55 <_Ray_> hrmph
21:54:15 <kmc> (also, i like infinitives as function names, it's more declarative... we don't get that easily in english :/)
21:54:46 <_Ray_> Hrm...So that goes "step by step", so to speak?
21:55:23 <kmc> the idea is, if you find a simplification, re-run the function on the entire simplified thing
21:55:41 <kmc> only if you don't find a simplification, dig deeper (your 3rd and 4th equations)
21:55:52 <kmc> you have to be careful to terminate but it should be ok here
21:56:22 <_Ray_> Hrm..it makes sense. I'm skipping every 2 terms, you're walking step by step
21:56:34 <_Ray_> That will avoid any runs of Ders or Izqs
21:58:33 <_Ray_> Right, right. Makes sense. Neat trick, thanks :)
21:59:21 <kmc> :)
21:59:48 <blackh> kmc: I read a recipe book in Hebrew, and they write in a declarative style... "Putting oil in the pan, cooking the onions until soft, ..." (as opposed to our English imperative style)
21:59:59 <kmc> _Ray_, for super extra credit, write this as a Scrap Your Boilerplate generic transformer :D
22:00:16 <_Ray_> O.o
22:00:35 <kmc> (it's not really advisable here, but a good tool to learn at some point)
22:02:46 <Gracenotes> -o-
22:13:17 <iaefai> If I have a datatype data Board = Board (Seq Row), and I have a Board (s)  how can I get at that s inside the ghci to inspect it?
22:13:58 <mmorrow> , (\a -> case a of Just x -> x) (Just 9)
22:13:59 <lunabot>  9
22:14:26 <mmorrow> iaefai: you need to pattern match on (Board s)
22:14:37 <mmorrow> lte unBoard (Board s) = s
22:14:40 <mmorrow> *let
22:14:55 <iaefai> perfect, got it
22:15:38 <kmc> iaefai, if you just want to inspect it visually, define or derive the Show typeclass for Board
22:16:07 <travisbrady> how can this be expressed more succinctly? (\x y -> (fst x) == (fst y))
22:16:11 <iaefai> I derive it already, but it is a little on the big side
22:16:22 <kmc> :t (==) `on` fst
22:16:23 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
22:16:37 <kmc> travisbrady, 'on' lives in Data.Function
22:17:18 <kmc> iaefai, GHCi> let Board s = b in {- use s here -}
22:17:32 <iaefai> Would one consider 0 to be a positive integer?
22:17:38 <kmc> i don't
22:18:00 <travisbrady> kmc: thank you
22:18:32 <iaefai> Then index from Data.Sequence is wrong, "The element at the specified position, which should be a positive integer less than the size of the sequence."   index x 1 is not the first index as implied here, but index x 0 is
22:19:08 <kmc> iaefai, good catch
22:19:15 <iaefai> merci
22:19:22 <iaefai> Where do I be a good citizen and report?
22:20:25 * kmc does not know
22:20:49 <allbery_b> ghc trac
22:21:18 <allbery_b> (I think...hm(
22:22:11 <iaefai> I am looking
22:22:27 <allbery_b> actually, subscribe to libraries@haskell.org (required as part of anti-spam stuff) and send it there
22:23:35 <iaefai> I don't want to be receiving mail from a mailing list
22:23:44 <iaefai> I found a place on trac I can put it
22:24:24 <iaefai> Would this be a 'libraries/base' issue?
22:27:42 <ivanm> iaefai: is Sequence part of base?
22:27:45 <ivanm> (hint: it isn't)
22:27:57 <iaefai> ivanm: I am in no position to judge that.
22:28:10 <ivanm> iaefai: look at where it comes from
22:28:21 <ivanm> on the ghc docs page, they say which library each module is from
22:28:27 <ivanm> Data.Sequence is part of containers
22:29:41 <ezyang> List fusion is mind bending. That is all.
22:30:31 <ivanm> ezyang: if that was all, then you would have quit after saying that...
22:30:51 <iaefai> So being that libraries@haskell.org is listed as the maintainer does that mean that it would be an author that looks there, or can I through it on to trac under libraries/other? My concern is just that I don't want email other than that pertaining to this issue.
22:30:53 <ezyang> haha
22:31:37 <ivanm> iaefai: there's usually a don't-receive-email option when subscribing to mailing lists
22:33:33 <iaefai> @src ($)
22:33:34 <lambdabot> f $ x = f x
22:34:03 <iaefai> What is the difference between (cout $ index c 0)  and (cout (index c 0))
22:34:04 <kmc> imo it's bad to have to jump through hoops just to submit a bug report
22:34:11 <kmc> iaefai, nothing
22:34:18 <iaefai> They behave differently
22:34:23 <kmc> shouldn't
22:34:41 <kmc> ($) exists for syntactic reasons, to eliminate parens like you did there
22:34:51 <kmc> and for higher order uses like map ($ 3) [f, g, h]
22:35:30 <copumpkin> that latter one is nicer as a sequence
22:35:42 <copumpkin> > sequence [f, g, h] x :: [Expr]
22:35:43 <lambdabot>   [f x,g x,h x]
22:35:57 <copumpkin> (in my opinion, at least)
22:36:25 <kmc> nice
22:38:04 <iaefai> heisenbug.
22:38:37 <iaefai> i.e. it works fine now
22:38:47 <iaefai> Or would that be a shrodinbug?
22:39:10 <iaefai> oh no, it is the inverse Schroedinbug!
22:41:54 <iaefai> By the will of Saizan_, foldMap strikes again! cout2 (Board c) = borderOutput ++ "\n" ++ (foldMap (\x -> cout x ++ "\n" ++ borderOutput ++ "\n") c)
22:42:17 <kmc> :t foldMap
22:42:18 <lambdabot> Not in scope: `foldMap'
22:42:57 <BMeph> kmc: Data.Foldable
22:43:09 <Gracenotes> interesting that it takes one argument
22:43:19 <BMeph> :t Data.Foldable.foldMap
22:43:20 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
22:43:42 <kmc> ah
22:43:42 <Gracenotes> ah. implicit argument, implicit combining function
22:44:07 <iaefai> I have to admit that I am not entirely sure how it works, it just seemed exactly like foldr to me
22:44:08 <performance> it would be so cool if ghc itself were cabal installable
22:44:44 <iaefai> Saizan_ did say what a monoid was, but I didn't retain :-( (it is late at night usually when I am donig this)
22:44:57 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11229#a11229   The code I am proud of, and might look like ass :p
22:46:08 <kmc> iaefai, a Monoid is any type with a notion of "empty" and "append", or "zero" and "add"
22:46:46 <iaefai> kmc, got an every day example to seal the deal?
22:46:49 <kmc> it's a group without inverses, if that means something to you
22:47:05 <Gracenotes> > appEndo (Data.Foldable.foldMap (Endo . (+)) [1..10]) 1000
22:47:06 <lambdabot>   1055
22:47:18 <kmc> lists
22:47:23 <kmc> [] is empty, (++) is append
22:47:42 <Gracenotes> uh. foldMap for lists basically looks like concatMap
22:47:44 <kmc> they're called "mempty" and "mappend" in the typeclass
22:47:50 <Gracenotes> particularly since mappend is (++)
22:47:52 <iaefai> kmc, nope :p
22:48:14 <iaefai> So you are saying a list is a monoid?
22:48:17 <kmc> yes
22:48:24 <Gracenotes> same type too: (a -> [b]) -> [a] -> [b]
22:48:38 <kmc> instance Monoid [a] where { mempty = []; mappend = (++) }
22:48:48 <BMeph> Numbers: 0 is empty, (+) is append. Also, 1 with (*), False with (||), True with (&&), and others. :)
22:49:21 <Gracenotes> it could be said that concatMap strikes again -_-
22:49:45 <Gracenotes> which is in Prelude, not Data.Foldable :)
22:49:54 * BMeph wishes that if we have to use those names, that they were "mEmpty" and "mAppend" for easier reading...
22:50:10 <iaefai> kmc, why the special name
22:50:15 <kmc> for which?
22:50:25 <Gracenotes> ugh, fire alarm
22:50:59 <iaefai> 'monoid'
22:51:10 <kmc> there are a lot of different types with this structure
22:51:24 <kmc> functions of type (a -> a) are another example
22:51:38 <kmc> in Haskell we have to wrap them: newtype Endo a = Endo (a -> a)
22:51:46 <BMeph> Called "endofunctions". :)
22:52:08 <BMeph> (thus the "Endo" in the type)
22:52:22 <kmc> "zero" is id and "append" is composition, (.)
22:53:11 <kmc> also numerical types, in two ways: mappend is either (+) or (*)
22:53:21 <kmc> so Data.Monoid defines wrapper types for both
22:54:08 <BMeph> Also , wrappers for conjunctive/disjunctive for Bool.
22:54:28 <kmc> "zero" is 0 or 1 respectively.  either way it should be the identity, to satisfy the monoid laws
22:55:00 <BMeph> Er, conjunctives/disjunctives for booleans, i.e. "and" and "or" for Bools. :)
23:01:17 <iaefai> Does a function like foldMap actually reply on the datatype being a monoid, if so - how?
23:01:34 <kmc> :t Data.Foldable.foldMap
23:01:35 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
23:01:52 <kmc> @src Data.Foldable.foldMap
23:01:52 <lambdabot> Source not found. Are you on drugs?
23:02:09 <kmc> lambdabot, why, you want some?
23:02:37 <Gracenotes> okay, fire alarm over
23:02:45 <kmc> foldMap f = foldr (mappend . f) mempty
23:03:16 <Gracenotes> it was the microwave catching on fire. *again* :/ damn it. people need a tutorial on how to use microwaves or something.
23:03:28 <kmc> Gracenotes, someone try to make instant noodles without adding water?
23:04:35 <iaefai> kmc, somebody probably making plasma
23:04:49 <Gracenotes> that's all I heard from, apparently, the person who put it out. I'm sure the details will be communicated in an email. Although, there hasn't yet been an email about the blackout the lasted for 8 or so hours last night, during which I had many perishable things in the fridge
23:05:00 <kmc> eek
23:05:52 <Gracenotes> oh, never mind, I just haven't checked my email. "The interruption of electrical service resulted from the failure of several electrical feeders located in the proximity of a high temperature hot water leak near Roosevelt quad."
23:06:31 <kmc> iaefai, yeah, the question is whether they were making it by design or by accident :)
23:06:34 <iaefai> Gracenotes: where do you live?
23:07:10 <Gracenotes> Roosevelt quad :) apparently, "The University has restored power to Roosevelt Quad with the installation of portable generators which were operational as of 6:15am this morning." making that 11 hours
23:08:09 <kmc> iaefai, your code does not look like ass
23:08:21 <kmc> i have a few small suggestions, would you like to hear them?
23:11:33 <iaefai> kmc, absolutely
23:11:33 <iaefai> kmc, my faith in my own code has not been tempered by experience :p
23:11:33 <iaefai> Gracenotes: What is Roosevelt quad?
23:12:23 <Gracenotes> http://www.stonybrook.edu/sb/map/images/apts_dorms.gif - stony brook, long island
23:12:28 <kmc> iaefai, i'd eliminate makeSquare and use (uncurry Square) in the map
23:12:47 <kmc> which actually simplifies further to: zipWith makeSquare n (replicate 8 c)
23:14:13 <iaefai> me having issues
23:14:24 <iaefai> My internet could quit at any time :-(
23:14:26 <kmc> iaefai, i'd eliminate makeSquare and use (uncurry Square) in the map
23:14:28 <kmc> which actually simplifies further to: zipWith makeSquare n (replicate 8 c)
23:14:36 <iaefai> :t uncurry
23:14:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:14:42 <kmc> you can't, like, own an internet, man
23:14:57 <iaefai> kmc, class A baby!
23:16:14 <dibblego> @hoogle Double -> (Int, Double)
23:16:15 <lambdabot> Data.Graph.Inductive.NodeMap mkNode_ :: Ord a => NodeMap a -> a -> LNode a
23:16:15 <lambdabot> System.Random next :: RandomGen g => g -> (Int, g)
23:16:15 <lambdabot> Prelude properFraction :: (RealFrac a, Integral b) => a -> (b, a)
23:16:41 <kmc> hoogle is often smart to the point of self-defeat
23:17:00 <iaefai> kmc, your second suggestion I am trying to figure out
23:17:04 <kmc> :t zipWith
23:17:04 <iaefai> I think I get the uncurry bit
23:17:05 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
23:17:30 <kmc> @src zipWith
23:17:31 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:17:31 <lambdabot> zipWith _ _      _      = []
23:18:00 <iaefai> so zipWith takes over some of the functionality of map?
23:19:05 <kmc> iaefai, (zipWith f xs ys) == (map (uncurry f) $ zip xs ys)
23:19:39 <kmc> also, zip == (zipWith (\x y -> (x,y))) == (zipWith (,))
23:20:04 <kmc> zipWith maps a two-arg function over two lists in the same way map maps a one-arg function over one list
23:20:06 <iaefai> Are you suggesting something like this? makeColouredSquares n c = makeRow $ zipWith (uncurry Square) n (replicate 8 c)
23:20:21 <kmc> yes, except you don't uncurry Square
23:20:29 <iaefai> oh ok
23:20:42 <kmc> because Square :: Piece -> Colour -> Square
23:21:04 <iaefai> and here I make myself a hypocrite by being a math tutor that tries to get the students to understand general cases, and here I miss it completely :p
23:21:39 <kmc> there are loads of useful functions like zipWith and it takes a long time to learn them all, and even longer to see every case where you might use one
23:21:50 <kmc> can't count how many times i implemented Data.Function.on or some half-assed version thereof
23:22:32 <kmc> also, it's conventional, though by no means necessary, to give a type signature to every top-level name.  this serves as machine-checkable documentation, a rare and valuable thing
23:23:48 <kmc> if your name "cout" is inspired by C++ then i have to object, but only out of annoyance at C++ and not for any serious reason :)
23:26:46 <iaefai> kmc, that is indeed where it comes from. I am by no means a C++ fan, infact I really hate C++. But it also doesn't do what C++'s cout does. I just couldn't think of a better name, because I don't want an overly verbose one.
23:27:13 <kmc> fair 'nuff
23:28:07 <iaefai> You are welcome to give me idea :p
23:28:40 <iaefai> you know, something like (a -> b -> c) -> (a, b) -> c doesn't give uncurry justice.
23:28:56 <iaefai> When you do something like uncurry Square :: (Piece, Colour) -> Square   it really becomes sweet
23:29:55 <kmc> after some time the higher-order function type signatures become just as meaningful
23:31:32 <kmc> so the way you've written your cout functions, the logic to render a board gets split into little chunks throughout the file
23:31:44 <kmc> it's a matter of style, but i might collect those into one place
23:32:50 <kmc> i might do away with the typeclass and make a single renderBoard :: Board -> String, with the other bits in a "where" clause
23:33:27 <kmc> also, are you aware that there are unicode characters for every chess piece symbol? :)
23:36:09 <iaefai> yes, it feels like it isn't 100% ideal
23:36:09 <iaefai> Because in reality all of the cout stuff is really for the board.
23:36:09 <iaefai> tomorrow I might deal with repositioning pieces :p
23:36:49 <kmc> you can also play crazy games with terminal color codes, for the squares
23:37:07 <kmc> are you using this ChessBoard module in a bigger system?
23:37:13 <iaefai> Modifying data structures in a functional way is not something I have done before.
23:38:38 <kmc> oh, i should also mention the module Text.PrettyPrint.HughesPJ.  it's intended more for formatting free-form text or source code, but might be of some use here
23:41:57 <iaefai> kmc, yes
23:42:15 <iaefai> kmc, do you subscribe to the beginner's mailing list?
23:42:33 <kmc> no
23:43:03 <aleator> Hi. Can I include inline C in .chs (c2hs) files?
23:43:06 <iaefai> To give you an idea where this thing lives: http://www.haskell.org/pipermail/beginners/2009-October/002534.html
23:44:01 <kmc> iaefai, sounds cool
23:44:17 <iaefai> it is cool workign with these things
23:44:31 <kmc> yay robots
23:44:32 <iaefai> hey comrade, What do you see here: â˜­
23:45:24 <kmc> hammer and sickle
23:45:32 <iaefai> yes comrade
23:45:37 <kmc> for communist chess
23:45:43 <kmc> only pawns
23:46:35 <iaefai> ï€¦ ï± ïˆ
23:47:44 <mmorrow> aleator: i think you can, but i don't know the details
23:49:44 <iaefai> kmc, it is likely that I will take both of your last suggestions into account
23:49:51 <iaefai> It would make the code cleaner
23:50:18 <iaefai> Where might I learn about functionally changing data structures like Seq Seq?
23:50:44 <kmc> i'd start with the documentation for Data.Sequence
23:53:38 <aleator> morrow: I finally googled it. Apparently you can by delimiting with #c and #endc.
23:56:31 <Axman6> aleator: that's a useful thing to know, thanks
23:57:15 <iaefai> I suppose update and adjust have potential, I just have to consider that I am replacing whole rows with a new row
23:58:13 <kmc> you can write your own update/adjust which abstracts that away
23:58:13 <iaefai> It appears that colloquy doesn't think #c is a channel, but #endc is :p
23:58:46 <kmc> you could also switch datastructures to something like an array, which can be two dimensional
23:58:57 <aleator> Axman6: Mind you, saw it in a blog but still haven't got it to work :)
23:59:01 <kmc> and fixed size
23:59:07 <Axman6> heh
