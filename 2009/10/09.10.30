00:14:37 <blackdog> mmorrow: still around?
00:14:40 <blackdog> mmorrow: http://www.shimweasel.com/2009/10/30/string-interpolation-in-haskell-or-doing-easy-things-the-hard-way
00:15:19 <blackdog> tell mmorrow let me know if i said anything appallingly stupid
00:17:55 <ksf> blackdog, no worries, I hold the standard for that.
00:18:03 <ivanm> blackdog: aren't weasals illegal down south? :p
00:18:13 <mmorrow> blackdog: sweet!
00:18:17 * mmorrow reads
00:18:20 <blackdog> "down south"? where are you putting them?
00:18:32 <ivanm> blackdog: you're south of me, are you not?
00:18:45 <blackdog> ivanm: i thought you meant below the belt:)
00:18:48 <ivanm> why are we bot-less?
00:19:01 <ivanm> blackdog: I'd slap you, but lambdabot seems to be dead...
00:19:47 <mmorrow> blackdog: cool.
00:19:58 * mmorrow reallly needs to get a blog
00:20:44 <blackdog> mmorrow: yes. then i'd have something to link to:)
00:23:34 <Twey> blackdog: Why are you generating strings of Haskell code instead of syntax trees?
00:24:39 <blackdog> Twey: because it doesn't make much difference, basically. It's a very small amount of haskell.
00:25:19 <blackdog> it's a list of functions and export calls - extremely regular, and hard to get worng.
00:25:30 <blackdog> ... there's a certain irony in that line, hey.
00:25:40 <Twey> Heh.
00:26:04 <Twey> But you must see that this solution is far from ideal.
00:26:28 <blackdog> What would generating a syntax tree buy me?
00:26:31 <Twey> Having the effect of code depend on variable names in the upper scope is not a good way of doing things.
00:26:50 <blackdog> Twey: hang on, are you talking about the string interpolation thing?
00:26:53 <Twey> Yes
00:27:04 <ksf> blackdog, you left out the issue of quoting $
00:27:15 <Twey> It buys you the flexibility to apply arbitrary transformations on the code (like the insertion of values at key points)
00:27:45 <blackdog> ksf: ah, you caught that. i deliberately left it out:)
00:28:31 <c_wraith> @pl \a -> (show a, a)
00:28:37 <c_wraith> oh.  right, no bots
00:29:15 <Twey> What's happened to all the bots?  Did Freenode roll out an incompatible upgrade or something?
00:29:20 <Twey> ] 3 + 5
00:29:38 <c_wraith> Hmm.  If I have to use my brain...  join ((,) . show)  maybe
00:29:42 <Twey> lambdabot, lunabot, la_fen, and lingbot are all down
00:29:51 <blackdog> Twey: it doesn't buy me anything in this case, though. I just want a slightly nicer way of saying "blah " ++ foo ++ " blah"
00:29:53 <c_wraith> preflex: seen lambdabot
00:29:53 <preflex>  lambdabot was last seen on #haskell 59 minutes and 23 seconds ago, saying: forall a. (a -> Bool) -> [a] -> Maybe a
00:29:55 <Twey> I'd rather go with (show &&& id)
00:29:58 <c_wraith> one bot still up!
00:30:17 <c_wraith> Oh, right.  If you want to be clear about it
00:30:18 <Twey> blackdog: But that's a wrong problem
00:30:18 <blackdog> it's a minor syntactic issue, but the syntax is the first thing anyone sees.
00:30:28 <blackdog> how can a problem be wrong?
00:30:32 <Twey> The whole issue arises because you're fiddling with strings of code
00:30:48 <blackdog> it doesn't need to be code, though.
00:31:09 <blackdog> i have another project where I'm using it to generate strings of code, and i'm open to debate on whether that's a good idea or not
00:31:11 <Twey> No, and then you introduce another problem: intermingling of presentation and logic
00:31:24 <blackdog> but string interpolation is a useful feature in and of itself
00:31:47 <Twey> If you think of the strings as your ‘presentation’ (the output), it's clear that having them depend on the names of variables in the code that generates them is not a good thing
00:31:56 <ramenmeal> so i'm supposed to traverse a binary search tree.... i have the functions findMax and removeMax which both take BST k v and return BST k v
00:32:01 <ramenmeal> i don't even know where to start lol.
00:32:20 <blackdog> Twey: I'm not forcing anyone to use it, but if you happen to like string interpolation (as many Ruby and Perl programmers do), it's nice to be able to use it in Haskell too.
00:32:24 <ramenmeal> well covert it to a list.
00:32:55 <Twey> It's a fundamentally wrong-headed approach
00:33:43 * ksf would like some automagic syntax for inserting show <var> resp. <var> (if it's already a string), though.
00:34:00 <Twey> resp.?
00:34:07 <ksf> respectively
00:34:30 <Twey> Is this some odd mathematical usage of the word ‘respectively’?
00:35:03 <ksf> nah more like a german idiom.
00:35:11 <blackdog> Twey: It really depends what you're doing. Sometimes it's worth the effort to define a proper data type with explicit serialisation methods, but sometimes you have small, ad-hoc tasks, and string interpolation makes the code clearer.
00:35:19 <ksf> "the one for that one, the other one for something different"
00:35:32 <Twey> Ah
00:35:42 <Twey> ‘Respectively’ in English usually means ‘in that order’
00:36:12 <Twey> ‘A and B for C and D, respectively’, for example, means ‘A for C and B for D’
00:36:27 <ksf> dict.leo.org lists, among others, "their respective duties, in their respective countries"
00:36:38 <Twey> Aye
00:36:50 <Twey> ‘To each their own duty/country’
00:37:08 <Twey> Similar idea
00:37:10 <ksf> so yes "in that order" is nescessary to match stuff up, but the "match this up" part is actually more important.
00:37:52 <ksf> witouth the respecitevly, you'd get A for C and D     and     B for C and D
00:37:54 <Twey> Sure (although I'd note that that only really applies to the adjective form)
00:38:03 <Twey> Without it, it's undefined
00:38:23 <Twey> blackdog: Arguably
00:38:33 <Twey> For simple variable substitution, yes, it can
00:38:34 <ksf> i'd say implementation-dependent.
00:39:03 <Twey> ksf: Heh.  No, undefined: there's no way of telling (unless it's made clear elsewhere) which belongs to which.
00:39:33 <ksf> I'd argue that because there's "respective", leaving it out means the opposite.
00:39:37 <Twey> It could even be multiple, as you suggested
00:39:47 <Twey> That would be a fine and logical way to do things
00:39:50 <ksf> ...which would mean multiple.
00:39:52 <Twey> But English doesn't work that way.  :þ
00:40:04 <Twey> (as is generally the case when there is a fine and logical way of doing things)
00:41:50 <ksf> language is usually more logical than the people using it.
00:42:07 <pikhq> Exception: English.
00:42:33 <pikhq> Every rule has an exception in English. (including this one)
00:42:37 <ksf> see, different people do different kind of fallacies in different situations, so when you combine their respective usages, to get something remotely consistant it _has_ to be logical.
00:43:13 <ksf> Exceptions ascertain the rule.
00:43:25 <Twey> Except in some cases.  ;)
00:43:55 <Twey> That's… unfortunately not true (the idea of combining fallacies) :þ
00:44:30 <Twey> Most natural languages nowadays are basically a logical structure upon which millennia of combined fallacies have been heaped, and they're clearly not particularly logical.  :þ
00:45:27 <ksf> well, at least with german, the language is not rarely more clearly defined that the oppinion of most people.
00:45:35 <ksf> language also collects collective wisdom.
00:45:58 <Twey> Yes.  I'm sure there's some in here somewhere.  We'll find it one day.
00:56:09 <ramenmeal> is there anyone around that i could pm for help?
00:56:29 <ivanm> depends on what
00:56:34 <ramenmeal> i don't want to bombard the channel
00:56:36 <ivanm> and why pm rather than just here?
00:56:38 <blackdog> ramenmeal: better to ask the channel
00:56:39 <ivanm> ahh, OK
00:56:42 <blackdog> we won't bite
00:56:52 <ivanm> ramenmeal: as long as you don't spam the channel, it's OK
00:56:56 <blackdog> so long as you put your pastes in hpaste or something
00:56:57 <ivanm> use a pasting site, etc.
00:57:01 <ramenmeal> k
00:57:03 <ramenmeal> one sec then
00:57:05 <ivanm> blackdog: stop saying what I want to say! ;-)
00:57:26 <blackdog> ivanm: i'm in ur brane snooping ur neurons
00:57:37 <ivanm> heh
01:00:29 <cepstrum> Hey! I have a problem. I am trying to install the hfann library. When I run "runghc Setup.lhs build", I get the following error: dist/build/HFANN/Data.hs:1:0:
01:00:30 <cepstrum>     File name does not match module name:
01:00:30 <cepstrum>     Saw: `Main'
01:00:30 <cepstrum>     Expected: `HFANN.Data'
01:00:56 <ramenmeal> http://pastebin.org/49454 does that work for you guys?
01:01:39 <blackdog> ramenmeal: can see it, but you should maybe ask a question too :)
01:01:56 <dolio> Man, why does Oleg always break threads with his replies? :)
01:02:01 <ramenmeal> it should. i'm trying to make a function "bstToList BST k v -> [(k,v)]
01:03:11 <blackdog> you mean bstToList :: BST k v -> [(k,v)], i guess?
01:03:34 <blackdog> so we have two cases to account for
01:03:43 <blackdog> the first one is where we have an empty BST tree
01:03:54 <ramenmeal> yeah sry
01:03:55 <blackdog> what should the result be for EmptyBST ?
01:04:09 <ramenmeal> it shouldn't add a tuple
01:04:16 <ramenmeal> so i thought it would be like
01:04:27 <ramenmeal> bstToList EmptyBST = []
01:04:34 <ramenmeal> but that gives some sort of error
01:05:08 <blackdog> what sort oferror?
01:06:09 <blackdog> ramenmeal: I have to go, but you're on basically the right path. you just need to get the recursive case as well
01:06:35 <ramenmeal> sry 'equations give different arities for "bstToList'
01:06:55 <ramenmeal> and then the recursive case
01:07:32 <EnglishGent> how do I force something to be evaluated? (performance issue)
01:07:41 * EnglishGent knows it's possible, but doesnt know how
01:08:08 <Twey> seq
01:08:08 <ramenmeal> bstToList BSTNode k v nl nr = bstToList nl : (k, v) : bstToList nr
01:08:15 <ivanm> EnglishGent: or bangs
01:08:41 <EnglishGent> or bangs?
01:08:42 <Twey> seq a b = return a b that, when evaluated, causes a to be evaluated
01:09:00 <EnglishGent> hi ivanm, Twey btw :)
01:09:10 <Twey> foo !a = evaluate a before executing the body of this function
01:09:11 <Twey> Hi ☺
01:09:23 <cepstrum> Hey! I have a problem. I am trying to install the hfann library. When I run "runghc Setup.lhs build", I get the following error: dist/build/HFANN/Data.hs:1:0: dist/build/HFANN/Data.hs:1:0:
01:09:23 <cepstrum>     File name does not match module name:
01:09:23 <cepstrum>     Saw: `Main'
01:09:23 <cepstrum>     Expected: `HFANN.Data'
01:09:32 <EnglishGent> ah - thanks all :)
01:09:34 <CalJohn> EnglishGent: they mean exclaimation marks.  you can use bang patterns (an extension) or you can use !name in types
01:09:51 <EnglishGent> hi CalJohn :)
01:09:57 <CalJohn> hey :)
01:09:58 <ivanm> hey EnglishGent
01:10:12 <ivanm> or is that "Good-day my good man!" ? :p
01:10:55 <EnglishGent> no need to stand on ceremony old chap :)
01:10:57 <Twey> Only if you want to be particularly insulting :þ
01:11:07 <ramenmeal> ivanm: could you help since blackdog left?
01:11:16 <Twey> ‘My good man’ is only used for inferiors
01:12:46 <ramenmeal> http://pastebin.org/49460
01:13:02 <ivanm> ramenmeal: ummm, I wans't here during your explanation, so gimme a minute to get up to speed
01:13:10 <ivanm> Twey: ahhh
01:13:45 <Twey> ramenmeal: You need brackets around (BSTNode … nr)
01:13:58 <ivanm> Twey: your point being? :p
01:14:00 <Twey> So that it's only one argument, instead of being interpreted as five
01:14:26 <Twey> ivanm: Heh, so you *did* want to imply that EnglishGent is a servant?  :þ
01:14:39 <ivanm> not necessarily a servant...
01:14:46 <ivanm> there are various grades of inferiority!
01:14:52 <Twey> ‘My man’ implies servitude
01:14:58 <EnglishGent> oh thanks a lot! :P
01:14:58 <SmurfOR> there has to be a way to do this.  can I have ghci show the output of map (*2) [1,2,3] as ((*2) 1):(((*2) 2):(((*2) 3):[])) instead of [2,4,6]??
01:14:59 <ivanm> (and the fact that he's a pom makes him inferior enough! :p )
01:15:04 <Twey> The ‘good’ makes it a compliment, but still a compliment to a servant :þ
01:15:07 <ivanm> EnglishGent: my pleasure!
01:15:21 <ivanm> Twey: well, shopkeeps aren't servants, etc.
01:15:28 <ramenmeal> i tired that ivanm, i get this
01:15:30 <ramenmeal> http://www.ramenmeal.bitesizepieces.com/screenshots/2009-10-30_Hh-15m-10s.png
01:15:40 <Younder> drinking is hard work...
01:15:48 <Twey> ivanm: In that particular worldview, they are
01:15:49 <Younder> hangover galore
01:16:13 * EnglishGent wishes there was a quick way to improve his brain's performance (really not a morning person)
01:16:16 <ivanm> ramenmeal: sorry, I've g2g :s
01:16:18 <Twey> EnglishGent: Hehe
01:16:24 <ramenmeal> :/
01:16:31 <SmurfOR> i'm guessing not then? :/
01:16:41 <ramenmeal> anyone wanna help me that isnt leaving :P
01:16:49 <Cale> ramenmeal: Whenever you write (x : xs), it must be the case that xs is a list, and x is a valid element of that list.
01:16:52 <int-e_> EnglishGent: Use a time machine: Just travel from afternoons to mornings. ;)
01:17:02 <Cale> (That is, if xs :: [t], then x must have type t
01:17:04 <Cale> )
01:17:19 <Twey> *nod*
01:17:44 <Twey> Since ‘bstToList nl’ is a list in itself, you need to use ++ to concatenate the lists instead.
01:17:45 <Cale> ramenmeal: and so here, you're trying to stick  bstToList nl  onto the head of the list  (k,v) : bstToList nr
01:17:45 <EnglishGent> int-e - that's cheating!  ... and besides - my Tardis is on the blink again :|
01:17:47 <EnglishGent> :)
01:18:01 <Cale> ramenmeal: as the first element, which isn't what you want
01:18:09 <Cale> ramenmeal: You probably want to concatenate
01:18:15 <ramenmeal> ++ ?
01:18:16 <Younder> worse yet monica wasn't there.. so I came back to bich here, sorry
01:18:19 <Cale> ramenmeal: yeah
01:18:49 <Cale> ramenmeal: However, if you care about efficiency, this isn't quite what you want to do.
01:19:15 <ramenmeal> what is inefficient aboutit?
01:19:18 <Younder> I'll try to be more coherent today. (If a bit more grumpy)
01:19:24 <Cale> ramenmeal: xs ++ ys takes O(length xs) steps to fully evaluate
01:19:40 <ramenmeal> yeah
01:19:40 <EnglishGent> hi Cale, Younder :)
01:19:56 <Cale> ramenmeal: So you'll end up turning something which ought to be linear time into quadratic time
01:20:12 <ramenmeal> so i need to get like tail(xs) ++ ys
01:20:13 <ramenmeal> ?
01:20:25 <Cale> ramenmeal: mm... that won't help :)
01:20:36 <ramenmeal> but the tail function is the same efficiency
01:20:36 <Younder> Hi EnglishGent
01:21:12 <Cale> ramenmeal: One way to fix the efficiency problem is to use functions instead of lists. If you turn the tree into a function which adds elements to the beginning of a list, then concatenation becomes composition.
01:21:34 <Cale> ramenmeal: then you can just apply the function to an empty list to recover the end result
01:21:52 <Cale> composition is a constant-time operation on functions
01:22:31 <Cale> any instances of the empty list in your algorithm become the identity function, and the singleton [(k,v)] becomes ((k,v):)
01:23:05 <Cale> Does that make sense?
01:23:16 <ramenmeal> ummm one sec lemme read through it once more
01:23:21 <Cale> Probably you'll want to get the thing working with ++ first :)
01:23:29 <ramenmeal> i got it working :)
01:24:09 <ramenmeal> thing is i can't modify the tree any
01:24:21 <ramenmeal> only add the function i'm supposed to make
01:24:40 <Twey> Oh, homework?
01:24:43 <Cale> ramenmeal: that's fine
01:24:58 <Cale> ramenmeal: you don't have to modify the tree, only your implementation of the function which turns it into a list :)
01:25:06 <ramenmeal> oh
01:25:40 <Younder> The answer is 42 (I am 42, not the Doug Admas thing)
01:25:49 <Cale> ramenmeal: your function will first turn the (BST k v) into a function of type [(k,v)] -> [(k,v)] and then apply that function to the empty list to recover the list that you're after.
01:26:07 <ramenmeal> sorry i'm lost lol.
01:26:13 <Younder> anyhow I am not likely to cheat on homework
01:27:00 <Cale> ramenmeal: Okay, what does your function currently look like?
01:27:40 <ramenmeal> http://pastebin.org/49464
01:28:02 <ramenmeal> i wasn't cheating i was asking about an error lol
01:28:15 <Cale> ramenmeal: okay
01:29:11 <Cale> ramenmeal: So, we're going to speed this up by turning the existing bstToList which you've written into a helper function, and adding an extra parameter to it
01:29:31 <Cale> So you might want to start by renaming to bstToList' :)
01:29:58 <Cale> and the extra parameter will be a list of elements which we're adding to.
01:30:13 <iaindalton> I want the latest pandoc, and Ubuntu doesn't provide it, so I installed the Haskell platform. I did 'sudo cabal install pandoc' by mistake, not knowing it would still install in ~, so I deleted ~/.cabal/ and tried again, but it says pandoc is already there. A careful 'sudo updatedb && locate -i pandoc' later, I don't know where it sees it, because I don't. What can I do to start over and reinstall it?
01:30:30 <Cale> So, the new function will produce a list of the elements from the tree, added to the start of the list that it got as its last parameter
01:31:08 <Cale> iaindalton: Personally, I don't use Ubuntu's packages of anything for Haskell.
01:31:18 <Younder> iaindalton, sonds wery linuxy. Not at all haskeellish
01:31:35 <Cale> Younder: It's Haskelly enough :)
01:31:45 <iaindalton> Cale: because Ubuntu doesn't have the latest pandoc, I downloaded the Haskell platform from a tgz and installed it
01:31:46 <Cale> iaindalton: Maybe that'll be worth changing my policy about in the near future
01:32:02 <iaindalton> So I'm not doing it the Ubuntu way
01:32:06 <Younder> I also use Ubuntu, so fire
01:32:12 <Cale> iaindalton: But typically, what I do is to get a generic linux binary from the GHC website
01:32:21 <Cale> and then cabal install
01:32:29 <Cale> and I install things off of hackage into ~/.cabal
01:32:36 <iaindalton> Problem is, I don't know anything about Haskell except that it's a language, and cabal sounds like CPAN
01:32:47 <Cale> iaindalton: that's about right
01:32:56 <Cale> iaindalton: Oh, are you intending to program in Haskell?
01:33:02 <iaindalton> Not yet ;-)
01:33:07 <Cale> hmm, okay
01:33:19 <iaindalton> I've done what you just described, but 'cabal install pandoc' tells me pandoc is already there
01:33:22 <ramenmeal> how do you get the length of a list?
01:33:23 <Cale> ah
01:33:27 <iaindalton> It even does that if I delete ~/.cabal
01:33:29 <Cale> iaindalton: ghc-pkg list pandoc
01:34:04 <Younder> rm -rf ?
01:34:18 <iaindalton> Cale: ah, not everything is put in ~/.cabal. ~/.ghc has a package.conf file that mentions it.
01:34:31 <Cale> iaindalton: ah, okay
01:34:33 <Younder> why do you have it in your home directory anyhow
01:34:39 <Cale> Younder: that's normal
01:35:07 <iaindalton> Younder: that's where it put it. Can I make cabal put things in /usr/local/bin or something?
01:35:10 <Younder> I only use that for code I wrote myself
01:35:51 <Younder> iaindalton, depends. Are you root? If so, yes
01:36:24 <Younder> Or at least you need administrative priviliges
01:36:43 <iaindalton> When I did 'sudo cabal install pandoc' it still put it in ~iain, but gave the files and folders root ownership
01:37:02 <Cale> iaindalton: ah, annoying
01:37:12 <Cale> iaindalton: Usually I avoid sudoing cabal install commands
01:37:32 <iaindalton> yeah; that seemed to have created the subsequent problems
01:37:51 <iaindalton> So does cabal have a way to install stuff system-wide?
01:37:55 <Cale> iaindalton: I used to install things globally, but that's just more hassle later on.
01:38:01 <Cale> well..
01:38:14 <Cale> --global
01:38:41 <Younder> so is cabal prebuildt? Because I am thinking /usr/src
01:38:43 <iaindalton> Cale: a hassle? I'm the only user on this PC but I'd imagine it would be useful for multi-user PCs at least.
01:38:57 <iaindalton> But I can only conjecture.
01:40:01 <Cale> iaindalton: Yeah, it's useful, but since cabal has no uninstall, you have to uninstall things by hand. It's easier to find stuff when it's all under ~/.cabal
01:40:06 <Younder> That's where I store fricas and other projects I am working on
01:40:14 <iaindalton> Oh, no install eh
01:40:20 <iaindalton> Is it a pretty new thing?
01:40:26 <Cale> Reasonably so.
01:40:41 <Cale> At least it still seems new to me :)
01:42:00 <iaindalton> I know almost nothing about package management. I'm sure there's a good reason there are so many non-distro package managers (cpan, install-tl, cabal, etc.)
01:42:09 <iaindalton> But I don't know what it is.
01:42:27 <Younder> You are aware of chmod and chown? iaindalton
01:42:32 <Cale> Well, cabal builds things and knows specific things about how to track Haskell module dependencies.
01:43:24 <mornfall> Moreover, this way, Haskell developers just need to know cabal, not two dozens of packaging systems to create two dozen incompatible distro packages and then still not covering nearly half of the ones used in the wild.
01:43:41 <Younder> I should probably mention find too
01:43:41 <Cale> iaindalton: cabal is also our replacement for Makefiles
01:43:54 <mornfall> The distro people then can take cabal packages and turn them into distro packages.
01:43:55 <iaindalton> Younder: yeah; I only deleted the dir because even after chowning, things weren't working. Turns out that was because I didn't know about .ghc, which was also root-owned.
01:43:59 <Younder> my favorite tools
01:44:39 <Younder> iaindalton, ouch
01:44:46 <iaindalton> Younder: incidentally, I also used find ;-) I didn't grep every file though, and pandoc was only mentioned inside a file.
01:45:12 <Vanadium> Is cabal part of the ghc infrastructure?
01:45:23 <Cale> Vanadium: Not yet, but it should be
01:45:31 <Cale> Vanadium: (well...)
01:45:35 <Vanadium> So hugs does their own thing?
01:45:48 <Cale> Oh, cabal also works with hugs
01:46:24 <Cale> (and NHC and JHC)
01:46:58 <Vanadium> Okay, but whenever cabal installs something, the installation is specific to one of those?
01:47:05 <Younder> iaindalton, I was thinking more along he line 'find <dir> -exec chown <me> {} \;'
01:47:22 <rupert> hi can someone tell me how i get the product of list of lists
01:48:04 <rupert> [[Int]]->Int
01:48:05 <iaindalton> Younder: why, when I can 'chown -R <user> <dir>'?
01:48:39 <Twey> rupert: map product . product?
01:48:49 <Twey> Er, vice versa
01:48:59 <Twey> > product . map product [[1, 2], [3, 4]]
01:49:07 <Twey> Oh, no bot.  Right.
01:49:25 <rupert> how would i right that as a function
01:49:36 <rupert> so far ive tried multsum[]=0
01:49:37 <Twey> *IPC.DBus.Bus DBus.Types Data.IORef Control.Monad> product $ map product [[1, 2], [3, 4]]
01:49:40 <Twey> 24
01:49:47 <Younder> iaindalton, Im my experience they tend so set spesific files to root privelege so it is better to make sure by itterating through the lot
01:49:54 <rupert> multsum[](y:ys)=y product ys
01:50:01 <iaindalton> Younder: that's what -R does
01:50:02 <Twey> rupert: multiproduct = product . map product
01:50:03 <Younder> iaindalton, YMMV
01:50:31 <Twey> Hm
01:50:46 <Younder> iaindalton, Ok, don't use that.
01:50:46 <Twey> Actually, I think I would prefer: multiproduct = product . concat
01:50:53 <rupert> what about if i want to sum the list and then multiply by sum of other lists
01:50:56 <Twey> Same outcome, but nicer semantics.
01:51:06 <Twey> Then you use sum instead of the inner product
01:51:15 <Twey> multisum = product . map sum
01:52:03 <rupert> thanks Twey
01:52:05 <blackdog> Twey: thanks, that was a thoughtful comment
01:52:15 <rupert> just having a bit of a hard time trying to understand lists
01:52:28 <rupert> i mean one is ok
01:52:30 <Twey> blackdog: Welcome ☺
01:52:52 <Twey> rupert: There's only ever one list.
01:53:02 <Twey> Sometimes it just has other one-lists inside it.  ;)
01:53:38 <rupert> Twey how would i do a similar thing with this kind of notation
01:53:40 <rupert> multsum (x:xs) = x + sum xs
01:53:47 <ivanm> in several places here, they have several unused/unexported/etc. warnings being supressed if the function starts with an underscore: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
01:53:56 <ivanm> what would be a good term for these kinds of functions?
01:54:29 <Younder> iaindalton, sorry for seeming such a dufus. The Unix command lib is MASSIVE though. And I master but a suset.
01:54:56 <Twey> rupert: You mean you want to use explicit recursion?
01:54:57 <iaindalton> Younder: no one can know everything
01:55:15 <iaindalton> So you have nothing to apologize for.
01:55:44 <Twey> rupert: Well, generally you shouldn't if you can avoid it.  For pædogogical purposes, though, you'd need to build a helper function to do the producting after the summing has taken place.
01:55:54 <Twey> Well, not necessarily.
01:56:23 <rupert> im just trying to understand how it would be done that way
01:56:23 <Twey> multisum (xs : xss) = product xs * multisum xss
01:56:31 <Twey> multisum [] = 0
01:56:35 <rupert> because until now i was taught it that way
01:56:47 <Twey> Sorry, I meant sum
01:56:52 <Twey> multisum (xs : xss) = sum xs * multisum xss
01:57:01 <Twey> Hm
01:57:12 <Twey> multisum [] = 1
01:57:17 <Twey> … might be more useful :þ
01:57:57 <rupert> i have to say i do like your solution its very simple syntactically
01:58:12 <rupert> much more elegant solution than the second one
01:59:49 <Twey> blackdog: I probably should have used dict(day=day, suffix=suffix(day)) in the Python example rather than dictionary literal syntax.  It's less noisy.
02:00:11 <Twey> rupert: You should rarely have to use explicit recursion in Haskell.
02:00:25 <rupert> Twey your second answer doesnt work unexpected ;
02:00:39 <blackdog> Twey: i replied on my blog
02:00:48 <Twey> There are functions in the standard libraries to encapsulate most recursive coding patterns.
02:01:01 <Twey> rupert: The third was a correction of the second.  ☺
02:02:13 <Baughn> > product . (. sum) $ [[1,2,3]]
02:02:24 <Baughn> , product . (. sum) $ [[1,2,3]]
02:03:02 <rupert> so ive copied down this
02:03:05 <rupert> multisum2::
02:03:09 <rupert> multisum2 [] = 1
02:03:19 <rupert> multisum2 (xs : xss) = sum xs * multisum2 xss
02:03:59 <rupert> which part of that function is incorrect?
02:03:59 <blackdog> Twey: that's actually a really good point - i'd like a clearer dictionary immediate syntax in haskell.
02:04:27 <Twey> Aye
02:04:35 <Twey> List-of-pairs syntax isn't too bad.
02:04:40 <Baughn> M.fromlist [(foo,bar),(baz,ttgl)]
02:05:02 <Twey> Could be better, though.
02:05:08 <Baughn> Literal dictionaries aren't something I need to write often, though
02:05:12 <Twey> (also, it seems it's not stack-safe!)
02:05:49 <Baughn> How large a dictionary are you planning to write? o_O
02:05:59 <Younder> No, the aren't
02:07:52 <Younder> I mostly do verifiable programming. proofs that bit.
02:08:21 <rupert> Twey any idea which section is wrong?
02:08:35 <Younder> And dictionaries suck from aprrof perspective
02:08:52 <Younder> a proof
02:10:27 <Twey> rupert: Well, the first line is wrong, for a start.  You've said ‘multisum2 is of type’, but then not provided a type.
02:10:48 <Twey> Baughn: I know, I know.  It just seems an unnecessary wart.
02:11:38 <Baughn> Twey: Granted. However, I'm really not sure how to fix it.
02:11:58 <Baughn> Twey: Adding explicit dictionary syntax sounds like a bad idea
02:12:11 <Twey> fromList just uses a foldl or something else daft in its implementation, quoth Cale.
02:12:28 <Twey> Well, personally I'd like Dict to be a typeclass.
02:12:57 <Twey> That way, we could use a pair-list directly.
02:13:32 <Baughn> fromList should be perfectly stack-safe if it uses a foldl'
02:13:35 <Younder> Sounds better
02:13:51 <Twey> Baughn: Yeah.  That was the general consensus.
02:15:18 <rupert> sorry about that, so it now reads multisum2 :: [[Int]]
02:15:32 <Twey> Well, that's clearly not right either, is it?
02:15:39 <Twey> multisum2 is a function, not a list of lists of ints.
02:16:21 <rupert> yeah but i want to input a list of lists
02:16:31 <rupert> [[2,3,4],[3,4,5]]
02:16:34 <Twey> And output what?
02:16:58 <Younder> exactly, you have a insane spec
02:17:12 <rupert> the sum of [2,3,4] for example
02:17:18 <Twey> What *type*?
02:17:19 <rupert> multiplied by the sum of the other
02:17:30 <rupert> int
02:17:42 <Twey> So where are you going to put that in the type of your function?
02:17:44 <Younder> [[Int]]?
02:17:57 <sioraiocht> [[Int]] -> Int
02:18:28 <Younder> That would work, but not as he spesified the funtion
02:19:05 <sioraiocht> sorry, I thought it was the sum of a list following by the mutliplicationof the results
02:19:08 <sioraiocht> :t map sum
02:19:21 <Younder> ahh reduce
02:19:41 <rupert> thanks
02:20:35 <Twey> sioraiocht: Don't worry about Younder.
02:20:43 <Twey> Bot's dead.
02:20:55 <Cale> oh
02:21:22 <Twey> Oh, morning, Cale.
02:21:33 <sioraiocht> damn
02:21:53 <Younder> Was that a insult Twey ?
02:21:55 <medfly> oh, morning Cale and twey
02:22:19 <Twey> medfly: Hey ☺  I haven't slept yet… don't know if it counts :þ
02:22:21 <Cale> It's annoying that lambdabot doesn't know that it's been disconnected
02:22:29 <Cale> I haven't slept either
02:22:37 <Twey> Cale: Yeah, mm
02:22:43 <Twey> I think Freenode's done something
02:22:51 <Cale> There are no error messages...
02:22:52 <Twey> Most of the bots I know of are down
02:23:34 <Younder> I am not a bot.
02:23:34 <rupert> can someone explain what difference between a function with list comprehension and without it?
02:23:56 <quicksilver> rupert: that's a strange question.
02:23:57 <Cale> rupert: uh... a list comprehension is just an expression which constructs a list
02:24:00 <Twey> rupert: List comprehensions are just syntax sugar.  They don't change the behaviour of the function.
02:24:20 <rupert> im looking over an old assessment
02:24:21 <quicksilver> rupert: a list comprehension is a specific sort of syntax. A function which doesn't have one... doesn't have one.
02:24:23 <Cale> rupert: You can use list comprehensions the same way you use any value
02:24:24 <Younder> True I wrote a bot to content for the next turing award.
02:24:28 <rupert> we have an assessment due out soon
02:24:34 <rupert> just want to get my head around it
02:24:47 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
02:24:54 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
02:24:57 <Younder> And I think it will win.
02:25:15 <Cale> > [(x,y) | x <- [1,2,3], y <- [1,2,3], x < y]
02:25:19 <Younder> But it is not running now.
02:25:22 <lambdabot>   [(1,2),(1,3),(2,3)]
02:25:32 <Cale> > [ show x ++ show y | x <- [1,2,3], y <- [1,2,3], x < y]
02:25:40 <lambdabot>   ["12","13","23"]
02:25:49 <Cale> lambdabot is still joining channels ;)
02:25:52 <Younder> Anyhow it was written in python
02:26:03 <Cale> rupert: Do those examples help?
02:26:20 <rupert> get the first one
02:26:26 <rupert> looking at the second now
02:26:59 <Cale> rupert: Basically, you can define a list by selecting elements from other lists, putting conditions on those elements, and defining the elements of the list as a function of the selections made
02:27:34 <Cale> You can have as many selections and conditions as you like, and they can refer to values made in previous selections:
02:27:52 <Cale> > [(x,y,z) | x <- [1..3], y <- [1..x], z <- [1..y]]
02:27:53 <lambdabot>   [(1,1,1),(2,1,1),(2,2,1),(2,2,2),(3,1,1),(3,2,1),(3,2,2),(3,3,1),(3,3,2),(3...
02:27:56 <Baughn> > [(x,y) | x <-- [1..] | y <- [1..]]
02:27:57 <lambdabot>   Not in scope: `<--'
02:28:01 <Baughn> > [(x,y) | x <- [1..] | y <- [1..]]
02:28:02 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
02:28:27 <Cale> Yeah, that's an extension... you can also do groups of choices in "parallel"
02:28:39 <Younder> www.nltk.org
02:29:18 <Baughn> > [(x,y) | x <- [1..y], y <- [1..]]
02:29:19 <lambdabot>   * Exception: not a number
02:29:36 <Baughn> > [(x,y) | y <- [1..x], x <- [1..]] -- I always forget the order.
02:29:37 <lambdabot>   * Exception: not a number
02:30:04 <dolio> > (x,y)
02:30:05 <lambdabot>   (x,y)
02:30:11 <quicksilver> you can't use a variable before you've defined it, Baughn
02:30:22 <quicksilver> neither in list comps nor anywhere else.
02:30:25 <Cale> That's a strange looking exception. Oh, right.
02:30:27 <Cale> > x
02:30:28 <lambdabot>   x
02:30:39 <Younder> actually y
02:30:39 <dolio> > 2 < x
02:30:40 <lambdabot>   True
02:30:43 <Cale> simplereflect ;)
02:30:50 <quicksilver> > [ (x,y) | x <- [1..], y <- [1..x] ]
02:30:51 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5...
02:31:01 <quicksilver> is presumably what Baughn was after.
02:31:11 <Baughn> quicksilver: Apparently so. Well, I /did/ forget the order..
02:31:11 <quicksilver> ;)
02:31:52 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
02:31:53 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
02:32:33 <Baughn> > [(x,y,z) | x <- [1..100], y <- [1..100], z <- [1..100], x^3 + y^3 == z^3]
02:32:37 <lambdabot>   mueval-core: Time limit exceeded
02:32:48 <Baughn> ..it wouldn't have given any results anyway.
02:33:31 <Younder> a 100 dimetional spheroid?
02:33:42 <Younder> what use is that?
02:33:57 <Baughn> No, fermat's last theorem
02:33:57 <dolio> > fromEnum x
02:33:58 <lambdabot>   * Exception: not a number
02:34:19 <Cale> Fermat's Last Theorem for n=3 isn't so bad :)
02:34:21 <Baughn> > toEnum 1 :: Expr
02:34:21 <Younder> you mean wilsons theorem?
02:34:21 <lambdabot>   toEnum 1
02:34:27 <Cale> Wiles' theorem
02:34:29 <medfly> haha :-p
02:34:38 <Baughn> Younder: No.
02:34:40 <mattwynn_> hey all. I'd love some feedback on my first haskell program: http://github.com/morland/kata-haskell-cities/tree/master/src/
02:34:58 <Twey> This looks familiar
02:35:17 <mattwynn_> Twey I posted it the other day when it was half done
02:35:17 <Cale> Andrew Wiles proved the conjecture known as Fermat's Last Theorem.
02:35:19 <mattwynn_> it works now!
02:35:28 <Younder> lol
02:35:53 <Younder> Back in 1996
02:36:29 <Cale> Yeah, it's pretty recent :)
02:37:30 <Baughn> Not a very nice proof, though. I want a better one. ;_;
02:37:37 <Baughn> It can't possibly have been the one Fermat had
02:37:46 <Cale> I don't think Fermat had one.
02:37:54 <Baughn> A possibility.
02:37:56 <Cale> And the proof is really very nice.
02:38:03 <Cale> Just not very elementary :)
02:38:42 <Younder> Baughn, The one fermant had had wholes in it it was foud already in 1815. Read Simon Sigh's book on fermat's last theorem
02:39:22 <Cale> Younder: Well, it's a bit of speculation since Fermat didn't publish anything.
02:39:32 <Younder> true
02:39:33 <Baughn> Younder: Assuming he didn't have a better one stashed in his head
02:39:35 <Cale> Younder: He'd only left a remark that he'd found a proof.
02:40:23 <Cale> But yeah, the one he probably thought he had was likely the same as the flawed proof of... Dedekind was it?
02:41:08 <Younder> To extensive to fit in he margin
02:41:14 <Younder> the
02:41:18 <Younder> lol
02:43:11 <Cale> In the end, FLT fell out as a somewhat easy corollary to an actually-important result :)
02:43:23 <Younder> Muxh recomended is also 'Learning from Data' by Vladimir Cherkassky and Phillip Milier
02:43:29 <Younder> Muiler
02:45:09 <Younder> Tought me everything I know about statistical learning
02:49:06 <[junior]> what the official website of haskell ?
02:49:17 <Twey> haskell.org
02:49:31 <Younder> the obvious www.haskell.org
02:49:59 <[junior]> ok thanks
02:50:36 <[junior]> anybody want share haskell's e-books for me too? :p
02:51:10 <quicksilver> theere is the haskell wikibook, there is learn you a haskell, and real world haskell
02:51:15 <quicksilver> all freely available online.
02:51:36 <Cale> @where lyah
02:51:36 <lambdabot> www.learnyouahaskell.com
02:51:37 <Younder> the documentation at www.askell.or is adequate
02:51:37 <Twey> … in reverse order of quality :þ
02:51:40 <Cale> @where wikibook
02:51:41 <lambdabot> http://en.wikibooks.org/wiki/Haskell
02:51:43 <[junior]> does haskell can be run in windows platform ?
02:51:46 <Cale> @where rwh
02:51:46 <lambdabot> is http://www.realworldhaskell.org/blog/
02:52:26 <Cale> [junior]: yes. Linux and Mac OS X are also fairly well supported.
02:52:28 <Younder> [junior], I run it under ubuntu
02:52:31 <[junior]> i'm newbie with haskell just know some ppl say they can haskell lang.
02:52:43 * [junior] curiously with this..
02:53:46 <Cale> [junior]: Let us know if you have any questions about the language while learning :)
02:53:48 <Younder> [junior], you are aware that most people on this group are Dr.'s in mathematcics and that you look like a real moron?
02:53:54 <Cale> Younder: hey
02:53:59 <Cale> Younder: that's inappropriate
02:54:15 <Younder> sorry, couldn't help myself
02:54:41 <Cale> Why would you say that anyway? Because the guy's first language isn't English?
02:55:26 <medfly> Cale, I thought you knew better.
02:55:27 <Younder> the first language should be mathematics. I don't care about the second.
02:55:35 <medfly> Cale, you can't be smart unless you're a native English speaker.
02:55:48 <Cale> medfly: heh
02:55:53 <mattwynn_> So any feedback for me on http://github.com/morland/kata-haskell-cities/tree/master/src/
02:56:12 <mattwynn_> I'm particularly interested in performance. We run in on about 94k rows of data and it takes about 2 hours
02:56:27 <mattwynn_> wondering if that's the best it can do or whether I did something stupid
02:57:19 <Younder> I f performance is you goal take a look at OCALM. It has the best performance of any functional language
02:57:29 <blackh> [junior]: Welcome to Haskell-land, anyway - I hope you have fun.
02:57:48 <Younder> Haskell's performance is probably adequate though
02:58:05 <[junior]> ty blackh
02:58:06 <Cale> Younder: Haskell routinely beats O'Caml in the shootout :)
02:58:29 <Younder> It does'
02:58:57 <Younder> We must be wathcing different tests.
02:59:24 <mattwynn_> Are there any basic mistakes I could have made that would make the script slow?
02:59:47 <mattwynn_> I'm not really clear yet on whether it's possible to do that, or whether haskell will simplify everything for me
03:00:27 <fergie> I have an error handling problem. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11319#a11319 does what I want it to do, but it doesn't deal with the cases where any variable is "Nothing"
03:00:41 <medfly> :t maybe
03:00:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:00:44 <Cale> mattwynn_: Oh, there are tabs in this. Make sure you configure your editor not to emit tabs.
03:00:58 <fergie> what is the best way to deal with this? Am I going to have to use lots of case expressions?
03:01:00 <mattwynn_> ah sorry that was the guy I was paring with
03:01:23 <medfly> you can use maybe
03:01:58 <Cale> fergie: Combining results like that is what the Maybe monad instance is for :)
03:02:16 <Cale> (also, there are tabs in that)
03:03:10 <Younder> [junior], I am sorry for that arrogan response
03:03:22 <fergie> will try with that then. Thank you.
03:03:29 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11319#a11321
03:03:33 <Cale> ^^ there is one way
03:03:56 <[junior]> don't mind it Younder
03:04:34 <Younder> [junior], My opinion dosn't reflect on this group.
03:04:55 <Cale> er, oops, obvious mistake in my edit :P
03:05:06 <Younder> [junior], It is my own
03:05:24 <fergie> Thanks Cale. Looks a bit simpler than what I had thought I esd going to have to do :-)
03:05:25 <Cale> Posted a fix :P
03:06:01 <cjs> What do I do when I want to apply "(,b)" to an "a" to get an "(a,b)"?
03:06:03 <Cale> fergie: The Maybe monad arranges so that if any of the results are Nothing, then the overall result is Nothing
03:06:13 <Cale> > (,2) 5
03:06:14 <lambdabot>   <no location info>: parse error on input `2'
03:06:28 <Cale> I suppose that's a new syntax extension :P
03:06:39 <medfly> Cale, shame on you
03:06:45 <medfly> making errors like that
03:06:48 <cjs> I've been here before. What did I do last time, I wonder?
03:06:49 <Cale> > (\x -> (x,2)) 5
03:06:50 <lambdabot>   (5,2)
03:07:09 <Cale> ^^ maybe that?
03:07:14 <Younder> Lambabot not useing the latest Haskel version?
03:07:27 <cjs> That's not short and clever and point free any more.
03:07:33 <Cale> Younder: I'm not sure if it was in 6.10.4
03:07:37 <quicksilver> pointfree is not a virtue.
03:07:48 <Cale> Younder: I just heard about it on the mailing list
03:07:50 <quicksilver> the tuple sections are 6.12,I think
03:07:52 <Cale> yeah
03:08:23 <quicksilver> the pointfree haskell 98 version is flip (,) 2
03:08:24 <Cale> cjs: Well, you can use  flip (,) 2  if you like
03:08:32 <Cale> heh
03:08:34 <quicksilver> btu I think (\x -> (x,2)) is much more pleasing than flip () 2
03:08:47 <Younder> I recomend www.sky.fm classic rock for that WTF attitude
03:08:57 <medfly> > flip (,) 2
03:08:58 <lambdabot>   {()->((),2)}
03:09:24 <Cale> > flip (,) 2 5
03:09:25 <lambdabot>   (5,2)
03:10:35 <cjs> Ah, yes, it was flip (,). I'd forgotten you can do (,) though you can't do (x,).
03:12:46 <BONUS> 2
03:13:12 <quicksilver> BONUS++ # the elegance of simple numeric poetry
03:13:38 <Cale> mattwynn_: anyway, I see lots of lists and nub
03:14:00 <Cale> mattwynn_: If those lists are really meant to be sets, you might try using Data.Set
03:14:16 <Cale> nub is "O(n^2)" (for appropriate definitions of n)
03:14:50 <BONUS> haha :D
03:16:02 <ivanm> oh no, that BONUS character is back...
03:16:03 <ivanm> ;-)
03:16:13 <Cale> Or, you could at least try  map head . group . sort  in place of  nub
03:16:26 <BONUS> yeah, after an extended absence i'm back to being annoying
03:16:31 <Cale> Though you have to be sure that you don't mind the elements being rearranged of course
03:16:48 <ivanm> BONUS: and continuing to write ungrammatical and nonsensical texts?
03:17:23 <BONUS> that's right!
03:17:25 <Cale> mattwynn_: It's also kind of odd how frequencyOf takes a pair like that
03:17:32 <quicksilver> s/ungrammatical and nonsensical/poetic/ ;)
03:18:07 <ivanm> bah
03:18:19 <Cale> BONUS pushes Twitter to its full potential.
03:19:38 <Younder> When I think of twitter I think of Ramstein ;)
03:20:25 <Cale> http://twitter.com/bonus500
03:20:26 <Younder> A statanical, neo nazi group.
03:21:10 <Younder> dark me
03:21:44 <BONUS> i just overturned a potted plant and spilled dirt all over my table.
03:21:45 <BONUS> hmmm
03:22:01 <BONUS> why is ST s a parametrized by s at all if runST has the s foralled
03:22:22 <Cale> BONUS: Because that's the trick for preventing STRefs made in one call to runST from escaping
03:22:48 <Cale> and being used in a different call to runST, where they would break referential transparency
03:22:52 <quicksilver> the 's's in the STRefs force multiple STRefs used together to have the same 's'
03:23:04 <quicksilver> then runST's type forces you to make no assumptions about that type
03:23:05 <BONUS> ah i see
03:24:04 <Younder> brilliiant type system
03:24:36 <Younder> not
03:24:57 <Cale> Younder: hm?
03:25:04 <Cale> Younder: It's nicely expressive :)
03:25:13 <Cale> :t runST
03:25:14 <lambdabot> forall a. (forall s. ST s a) -> a
03:25:18 <BONUS> actually it owns
03:25:25 <mattwynn_> Cale re frequencyOf taking a pair
03:25:39 <mattwynn_> I think that's my non-functional background
03:25:56 <EnglishGent> hi [junior] :)
03:26:19 <blackdog> Twey: the dictionary thing is interesting from an SE point of view. i quite often use dictionaries to pass options in Ruby/Perl - it's not so idiomatic in Haskell
03:26:20 <mattwynn_> I want a function that finds the number of instances of a given item in a list
03:26:31 <mattwynn_> how would I rewrite that in a more idiomatic way?
03:26:35 <quicksilver> mattwynn_: length + filter
03:26:48 <quicksilver> is the best you get I think
03:27:12 <blackdog> but you don't necessarily want to invalidate an interface just to add new options - it's much better to have sensible defaults, and add new stuff through new options
03:27:22 <BONUS> ah i see, when we do newSTRef 'a', that has a type of ST s (STRef s Char) and then if we want to runST on that we'd get STRef s Char and the s would escape.
03:27:34 <Twey> blackdog: Right?
03:27:48 <Cale> If you need to know for all the elements though, doing a length and filter for each is slow.
03:28:18 <Cale> You'd want to do something like  map (\xs -> (head xs, length xs)) . group . sort
03:28:21 <BONUS> but why is STRef indexed by s at all? why isn't it like IORef where it's only indexed by a? is it because of stToIO?
03:29:04 <quicksilver> BONUS: it's indexed by s to stop you using the same STRef in two different runSTs.
03:29:18 <Cale> which, if you import Control.Arrow becomes...
03:29:27 <Cale> > map (head &&& length) . group . sort $ "abracadabra"
03:29:28 <lambdabot>   [('a',5),('b',2),('c',1),('d',1),('r',2)]
03:29:38 <BONUS> quicksilver: aha
03:31:03 <Cale> BONUS: (Because that would spoil referential transparency completely.)
03:31:17 <Twey> blackdog: The dictionary idea allows that
03:31:54 <quicksilver> the ruby/perl/python use of dictionaries for parameters almost always has arbitrary types in the value spot though
03:32:12 <quicksilver> (although probably String in the key spot)
03:32:34 <quicksilver> this is a candidate for Dynamic in haskell but that's just not very idiomatic.
03:32:39 <Saizan> the standard solution in haskell is to use a record type, no?
03:32:48 <quicksilver> normally you *can* construct a strongly typed way to specify your function.
03:33:06 <quicksilver> Saizan: a record, or a list of existentials (but a more restricted existential than Dynamic)
03:33:38 <quicksilver> Saizan: the GUI librarys generally have a notion of 'property' and you get lists of something like [exists a . (Prop a, a)]
03:36:04 <BONUS> ah now i get it, this is really clever. the s is arbitrary so we don't have to worry about it but one STRef still can't leak from a ST and be used in another ST because of the forall
03:36:21 <quicksilver> right.
03:37:44 <dolio> You also can't create an STRef and run it in an inner ST block.
03:38:25 <dolio> newSTRef 0 >>= \r -> return (runST (readSTRef r)) is ill-typed.
03:39:08 <hackagebot> HGL 3.2.0.1 - A simple graphics library based on X11 or Win32 (ChristophLueth)
03:39:52 <twb> Grumble, why does ghc6 still depend on perl?
03:40:24 <mmorrow> , runST (mdo o <- newSTRef (runST (readSTRef o)); readSTRef o)
03:40:25 <lunabot>  luna: Inferred type is less polymorphic than expected
03:40:40 <mmorrow> the fix id of ST?
03:41:26 <quicksilver> twb: the evil mangler style of via-C compilation is no longer preferred, but is currently still supported.
03:41:53 <twb> Pity I can't just say "bollocks to that" and remove the perl dependency
03:42:07 <twb> Although maybe via-C is still needed on ARM?
03:42:33 <quicksilver> the ARM via-C is unregisterised and so doesn't use the mangler AFAIK.
03:42:34 <blackh> twb: We don't use the Evil Mangler on ARM
03:42:42 <twb> blackh: yay!
03:42:54 <twb> So I can report this as a bug to Debian
03:43:25 <blackh> twb: There's no evil manger implementation for ARM, actually.
03:43:54 <blackh> twb: So, yes, I think it can be removed, but note that there's a team working on a newer GHC for Debian
03:43:57 <mmorrow> , fix (Mu . Just)
03:43:59 <lunabot>  Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu ...
03:44:09 <mmorrow> , vacuum (fix (Mu . Just))
03:44:11 <lunabot>  [(0,[0])]
03:44:18 <mmorrow> even better that fix (0:)
03:45:06 <mmorrow> literally Just Mu!!</couldn't resist>
03:45:57 <Twey> :info Mu
03:46:04 <Twey> Oh
03:46:25 <twb> blackh, quicksilver: may I quote your comments above in the bug report?
03:46:38 <quicksilver> mmorrow: it's not though. It's Just Just, there is no Mu ;)
03:46:42 <mmorrow> blackh: are you one of the people working on that ghc port to ARM by that game company to write iphone apps?
03:46:49 <blackdog> Twey: well, that's useful more for methods that require a degree of extensibility
03:46:54 <mmorrow> quicksilver: that's what they said about the spoon!
03:47:01 <quicksilver> twb: sure
03:47:07 <blackh> twb: Go ahead. I don't know for sure that no Debian platform uses the mangler, but ARM doesn't.
03:47:15 <blackh> mmorrow: Yes, that's me!
03:47:19 <twb> blackh: you can have arch-conditional dependencies
03:47:36 <mmorrow> quicksilver: true, sigh
03:47:48 <mmorrow> blackh: cool, how's that going?
03:47:52 <mmorrow> , src ''Mu
03:47:54 <lunabot>  newtype Mu f = Mu (f (Mu f))
03:47:58 <osfameron> what's the canonical way of writing every_other?  I've got the noddy: let eo x = case x of {(h:_:ts) -> h : eo ts; otherwise -> x}
03:48:01 <blackdog> Twey: the argument with interpolation is that it's good for ad-hoc, low overhead situations
03:48:12 <twb> Either by saying Depends: arm-gnu-linux | perl, or Depends: perl [i386, amd64]
03:48:27 <twb> (Hand-waving away the details)
03:48:31 <blackh> mmorrow: I am working very hard getting it all done (the game, that is).
03:48:46 <quicksilver> osfameron: I think that goes wrong on odd-numbered lists.
03:48:55 <mmorrow> blackh: ah, nice. so the ghc part of it is working alright?
03:49:03 <osfameron> quicksilver: seems ok on my ghci
03:49:05 <blackdog> And even then, the alternative to the dictionary-based approach is using a special-purpose record
03:49:06 <quicksilver> osfameron: ah, maybe not :)
03:49:15 <quicksilver> osfameron: seems fine to me.
03:49:25 <mmorrow> blackh: what did you have to do to the register-allocator and lower levels? (or is it unregisterized)
03:49:38 <blackh> mmorrow: Yes, it works really well.  No time at present to make it nicer as we have to concentrate on the game but after the first release we'll be able to bring it up to date and do some work on the codegen.
03:49:47 <osfameron> I was wondering if: (map head) . groupIntoTwos  would be better ?
03:49:52 <mmorrow> cool
03:49:53 <osfameron> and then how to write groupIntoTwos... :-)
03:50:08 <blackh> mmorrow: Totally unregisterized.  We'd like it to be faster - the ARM is not a fast processor.
03:50:13 <quicksilver> osfameron: chunksOf n = map (take n) . iterate (drop n)
03:50:26 <twb> Erm, ARM's not a processor, it's a family of them :-)
03:50:28 <mmorrow> blackh: ah, gotcha.
03:50:42 <blackh> twb: Well they're all a bit slow. :)
03:50:51 <osfameron> quicksilver: ta
03:51:06 <twb> pfft, a 1GHz Cortex A8 will probably kick the shit out of my 600MHz Celeron and PIIIs
03:51:38 <twb> Unfortunately this one's cpuinfo has no bogomips
03:51:47 <mmorrow> "Celeron" always made me think of tupperware
03:52:00 <blackh> "Celeron" always made me think of a stick of celery
03:52:12 <mmorrow> Celeryron!
03:52:22 <twb> I'm waiting for an n810 with DVI-D or HDMI out, so that I can replace my current Eee PC 701 :-)
03:54:18 <osfameron> quicksilver: the iterate doesn't stop when there's nothing to be dropped though
03:55:40 <zygoloid> @type map snd . filter fst . zip (cycle [True, False])
03:55:41 <lambdabot> forall b. [b] -> [b]
03:56:08 <zygoloid> > map (map snd . filter fst . zip (cycle [True, False])) [[], [0], [1,2], [3,4,5], [6..]]
03:56:09 <osfameron> eeek!
03:56:09 <lambdabot>   [[],[0],[1],[3,5],[6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,4...
03:56:35 <osfameron> oh, yes, that makes sense
03:56:43 <zygoloid> @type catMaybes . zipWith ($) (cycle [Just, const Nothing])
03:56:44 <lambdabot> forall a. [a] -> [a]
03:57:44 <zygoloid> @type \xs -> [x | (x,True) <- zip xs (cycle [True,False])]
03:57:45 <lambdabot> forall a. [a] -> [a]
03:58:55 <shambler_> @where sicp
03:58:55 <lambdabot> http://mitpress.mit.edu/sicp/
03:59:00 <zygoloid> > iterate not True
03:59:01 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
04:00:27 <twb> The ghc6 package is so damn big
04:00:32 <twb> It's bigger than linux *or* emasc
04:00:58 <ivanm> twb: I doubt there will be an update to the n810, but there's the n900 which has at least TV out IIRC...
04:00:58 * adu <3 emacs
04:01:02 <ivanm> + it's a phone!
04:01:07 <ivanm> (smaller screen though)
04:01:15 <twb> ivanm: yeah, but it's crappy non-standard TV out
04:02:01 <twb> If it's going to be my "laptop" for daily use, I want it to be able to drive a 1600x1200 LCD
04:02:21 <ivanm> twb: is it? :o
04:02:41 <twb> ivanm: some kind of non-standard connector
04:03:02 <ivanm> "Nokia Video Connectivity Cable" ?
04:03:03 <twb> Yeah
04:03:22 <twb> Even if you RCAify it, it wouldn't be digital
04:03:34 <twb> Ahahaha
04:03:43 <twb> I do not have enough space in /var/cache/apt to download ghc6 6.10
04:03:51 <twb> tmpfs                  96M   96M     0 100% /var/cache/apt
04:04:05 <adu> o my
04:04:10 <zygoloid> sudo apt-get autoclean?
04:04:22 <Cale> ... that's not a very big partition
04:04:26 <fasta> twb, the official GHC release is only 77MB.
04:04:28 <adu> sudo apt-get deletefilesrandomly
04:04:28 <Vanadium> symlink it do /dev/shm? :>
04:04:33 <twb> zygoloid: yeah
04:04:47 <twb> zygoloid: rather, "aptitude clean", since everything in there is fresh.
04:04:55 <twb> Cale: it's a tmpfs, so it gets emptied on reboot
04:05:26 * ivanm has a 10 GB tmpfs, and it still wasn't enough to build OO.org :@
04:05:59 <twb> Yeh, soffice and xulrunner and webkit can all go blow themselves
04:06:02 <twb> bloated C++ crap
04:06:23 <adu> i don't understand why ppl write in C++
04:06:31 <twb> adu: because "it's fast"
04:06:33 <Zao> adu: Because it's a lovely language.
04:06:46 <Zao> (not joking)
04:06:49 <Cale> http://yosefk.com/c++fqa/defective.html
04:06:49 <twb> FSVO lovely = simula backported to C
04:07:04 <adu> well, I wouldn't use either of those words
04:07:06 <Zao> Cale: That's the most trolly page I've ever seen.
04:07:14 <adu> imho
04:07:22 <twb> adu: I have a similar one for Python
04:07:28 * ivanm loved the joke interview "with" C++s inventor with the "revalation" that C++ was never meant to be used...
04:07:29 <Cale> Zao: I found it amusing and true ;)
04:08:00 <ivanm> Cale: any idea what I can categorise functions that start with an underscore as mentioned several times here? http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
04:08:12 <fasta> Is there some place where I can get Cygwin with like 1MB/s instead of the dial-up speed I get now?
04:08:22 <Zao> Cale: I suppose I might have acquired the relevant brain damage to enjoy C++.
04:08:41 <ivanm> fasta: a mirror? *shrug*
04:08:44 <twb> As for me, I just don't "get" OO
04:09:02 <fasta> ivanm, I am using the "automatic installer" and it lists about 60 of them.
04:09:08 <twb> It's the kind of paradigm a civil engineer would come up with
04:09:18 <ivanm> fasta: heh
04:09:22 <adu> twb: a similar "Defective" page?
04:09:23 <fasta> ivanm, if it would be a good program, it would download everything in parallel.
04:09:36 <fasta> ivanm, but no, they couldn't think of doing that, of course.
04:09:38 <ivanm> twb: well, you do know the difference between civil and mechanical engineers don't you? :p (OT joke)
04:09:49 <ivanm> fasta: isn't cygwin unmaintained/dead?
04:09:50 <twb> ivanm: I meant as opposed to mathematicians.
04:10:07 <ReDAeR> I'm just learning Haskell but why the **** is it /= and not !=? :S
04:10:14 <fasta> ivanm, They are preparing a release for Windows 7. So, I  think not.
04:10:25 <Jafet> I would prefer an operating system designed by civil engineers over mathematicians any day
04:10:32 <Cale> ReDAeR: Because /= is better ascii art for ≠
04:10:34 <fasta> ReDAeR, open a mathematics book and you know it.
04:10:39 <adu> ReDAeR: its closer to the mathematical symbol, and precicely the same as Ada
04:10:47 <twb> ReDAeR: because it looks more like ≠
04:10:52 <ReDAeR> Ok
04:10:55 <Cale> ;)
04:10:59 <twb> ReDAeR: lots of sensible languages have used /= over the years
04:11:02 <ivanm> and just so it isn't != ;-)
04:11:02 <Jafet> .oO( So why isn't it just ≠? )
04:11:05 <int-e> =/=
04:11:09 <adu> twb: like Ada
04:11:12 <Cale> I think that wasn't just stereo, that was 5.1 sound.
04:11:14 <ivanm> don't some languages use ~= ?
04:11:17 <twb> adu: I was thinking the Lisps.
04:11:23 <Vanadium> @let (≠) = (/=)
04:11:23 <ivanm> Jafet: unicode characters for source are a pain
04:11:23 <lambdabot>  Defined.
04:11:24 <adu> o those too
04:11:28 <ivanm> int-e: yes, but that's longer! :p
04:11:36 <Jafet> > (λx -> x + 1) 1
04:11:36 <lambdabot>   Pattern syntax in expression context: λx -> x + 1
04:11:43 <dolio> Clearly in any sane language it's called <>
04:11:48 <Cale> ivanm: I don't know what you mean by 'categorise' in the above
04:12:13 <int-e> dolio: but what about partial orders?
04:12:16 <ivanm> Cale: what term can I use for those kind of functions
04:12:26 <dolio> Those don't exist.
04:12:32 <ivanm> dolio: which one does that? matlab?
04:12:38 <int-e> ivanm: pascal
04:12:44 <dolio> I don't know. I've definitely seen it before.
04:12:46 <ivanm> int-e: right
04:12:47 <Cale> ivanm: Functions that the compiler won't warn you about?
04:13:02 <Jafet> > (\x → x + 1) 1
04:13:03 <lambdabot>   2
04:13:04 <ivanm> Cale: yeah, but I was hoping for something shorter/catchier ;-)
04:13:24 <Cale> Are you talking specifically about the use in -fwarn-missing-methods?
04:13:35 <Cale> I suppose you could call them derived methods.
04:13:39 <ivanm> me is going to PEPM! \o/
04:14:26 <ivanm> :o never heard of this... http://labdotnet.di.uminho.pt/HaSlicer/HaSlicer.aspx
04:15:06 <Cale> ReDAeR: By the way, welcome to the channel, and don't be afraid to ask any questions you might have. There are (quite evidently) a lot of people hanging around here to help answer beginner questions. :)
04:15:26 <Zao> dolio: Did you just call Visual Basic sane?
04:15:30 <ReDAeR> Never had such a warm welcome :)
04:15:59 <dolio> :)
04:16:12 <ivanm> Cale: s/to help/to procrastinate by helping/ ;-)
04:16:39 <Cale> <> implies order comparability to me
04:16:47 <Cale> It's like "comparable and not equal to"
04:16:55 <blackdog> Zao: it's got its place:)
04:17:05 <adu> lolol
04:17:11 <ivanm> Cale: hmmm... I guess non-equality came about because it's less than and greater than? :s
04:17:19 <ivanm> (though that might arguably mean _equality_...)
04:17:29 <Cale> ivanm: Less than *or* greater than :)
04:17:38 <ivanm> heh
04:17:40 <Cale> ivanm: but that assumes a total order :)
04:17:43 <ivanm> right
04:17:50 <dolio> Clearly if x is not equal to y, then either x is greater than y, or x is less than y. :)
04:18:02 <dolio> As any Visual Basic programmer knows.
04:18:09 <ivanm> @tell Raevel thanks for proof-reading my paper earlier this month; it was accepted! \o/
04:18:09 <lambdabot> Consider it noted.
04:19:21 <adu> i want a paper to be accepted
04:19:31 <adu> how do i do that?
04:19:36 <Cale> To its credit, Visual Basic has become much more sane ever since Haskell people started working on it
04:20:06 <adu> does VB have partial evaluation yet?
04:21:18 <adu> btw, ever since I started using partial eval in my Mathematica code, my productivity has shoot thru the roof
04:21:47 <Jafet> Sure. You get annoyed and kill it in the Task Manager, so that it has partially evaluated whatever it has been evaluating
04:21:59 <SamB_XP_> adu: I thought that was more or less the only way to do partial eval!
04:26:23 <ivanm> adu: you have to write one first...
04:26:30 <ivanm> Jafet: heh
04:26:43 <adu> I just realized what words I would use to describe C++
04:26:54 <ReDAeR> adu: Fast? :o
04:26:55 <adu> haphazard and verbose
04:26:59 <ReDAeR> Oh
04:27:17 <adu> no, C is fast
04:27:39 <ReDAeR> I'm fast ;o
04:28:50 <adu> i also had two visions while thinking about those words
04:28:55 <ivanm> adu: I'm sure you can write slow C code...
04:29:35 <adu> yes, but it has the least overhead of any language i can think of
04:30:24 <ReDAeR> ivanm: It depends on .. everything C#/Java can be faster then C++ for example depends on platform, implementation, etc :) Sure haskell has some area which it performs better then C++
04:30:46 <adu> most def
04:31:11 <adu> Haskell has the perfect environment for optimization
04:31:32 <dankna> hmm
04:31:50 <dankna> opinion: What Hackage category should a library to generate CAPTCHA images go in?
04:31:54 <dankna> it's not really Network
04:32:08 <adu> dankna: Codec?
04:32:11 <ivanm> ReDAeR: that was kinda my point
04:32:23 <dankna> hmm... that's a thought
04:32:26 <ivanm> dankna: there's recaptcha... see where it puts them
04:32:40 <dankna> hmm, recaptcha seems to be in Network
04:32:47 <adu> C#/Java are perfect for portability and code monkeys
04:32:59 <ReDAeR> Question i'm making a exercise that it in the book. Now i want to output the result and i used: main = putStrLn (show (f(2 3)))       function f takes 2 arguments but it gives me a error
04:33:07 <blackh> dankna: recaptcha is more network oriented than your package
04:33:22 <dankna> yeah, I'm leaning towards Web
04:33:24 <blackh> (that probably doesn't help!)
04:33:30 <BONUS> that's putStrLn (show (f 2 3))
04:33:35 <dankna> (haha, well, any feedback is good feedback)
04:33:46 <BONUS> (2 3) tries applying 3 to the function 2 but 2 isn't a function so that doesn't typecheck
04:33:55 <ReDAeR> Ty BONUS
04:34:00 <blackh> dankna: Graphics? Or maybe that's just me.
04:34:09 <dankna> Graphics was my first thought, actually
04:34:35 <dankna> yeah, I think Graphics is the closest fit
04:34:36 <dankna> thanks all
04:35:35 <adu> ReDAeR: when all the parens are used, haskell starts looking like lisp
04:35:47 <blackh> dankna: Good on ya. I'm a CAPTCHA believer. (There are people who think CAPTCHA won't work in the long run.)
04:35:55 <ReDAeR> adu: I'm used to it :p
04:36:10 <ReDAeR> blackh: Makes me probaly one of them :p
04:36:23 * blackh has faith!
04:36:25 <ReDAeR> So many methods to defeat CAPTCHA's
04:36:29 <mreh_> :t $!
04:36:30 <lambdabot> parse error on input `$!'
04:36:30 <adu> ReDAeR: but Haskell lets you write the same thing without parens :), like main = putStrLn $ show $ f 2 3
04:36:53 <ReDAeR> adu the book hasn't told me yet :P
04:37:05 <fasta> adu, you do give up structured editors then.
04:37:10 <twb> As an a11y weenie, I am Not A FanTM of most captcha systems
04:37:13 <Vanadium> :t ($!)
04:37:14 <lambdabot> forall a b. (a -> b) -> a -> b
04:37:21 <dankna> yeah, I think CAPTCHAs are very important, definitely
04:37:32 <ivanm> BONUS: and putStrLn . show == print
04:37:33 <adu> fasta: no, I use emacs
04:37:37 <dankna> there are ways to defeat them, but they're a vital tool at this juncture in history
04:37:53 <fasta> adu, I also use Emacs, what has that got to do with it?
04:38:18 <ReDAeR> I tried vim and nano but now i'm in love with Geany :o
04:38:27 <twb> For example, even though I *can* see images, because I have them off by default and view them with "display <URL>", most captcha systems decide I'm "cheating".
04:38:50 <fasta> Emacs and vim are out of the box useless. Emacs more so than vim.
04:39:08 <twb> fasta: I dunno... Emacs has colour on by default now.
04:39:18 <ReDAeR> twb: vim too
04:39:27 <twb> Depends on the vim, IME
04:40:03 <fasta> Fonts look terrible on Linux if you use default Emacs.
04:40:20 <fasta> On Windows there is less of a difference.
04:40:26 <twb> fasta: then you have misconfigured libxft.
04:40:26 <adu> fasta: you said you had to give up structured editors if you use ($), why?
04:40:38 <fasta> twb, I probably did.
04:40:50 <fasta> twb, since I didn't. I use XResources.
04:40:55 <twb> fasta: or you've managed to run Emacs < 23, which didn't have xft support and thus used the traditional X font system.
04:41:03 <twb> Which is raster-based instead of outline-based
04:41:20 <fasta> twb, I use xft since it was first introduced into CVS.
04:41:31 <mmorrow> does anyone remember the formula for (n + (n-1) + (n-2) + .... + 1) ?
04:41:42 <twb> As for me, I don't run Emacs' GUI backends any more than I would run gvim
04:41:54 <quicksilver> mmorrow: reverse the list in your head, put underneath.
04:42:03 <quicksilver> mmorrow: n pairs each adding up to n+1; divide by 2.
04:42:07 <twb> The whole point is that you get your terminal emulator looking pretty, and then all the apps automatically look pretty because the run in your terminal emulator.
04:42:21 <mmorrow> quicksilver: ahhh, right. the divide by two business.
04:42:31 <mmorrow> quicksilver: thanks
04:42:41 <fasta> twb, my terminal emulator looks great. I only use it when I run emacs remotely.
04:42:41 <quicksilver> mmorrow: don't thank me, thank gauss :P
04:42:56 <mmorrow> @tell gauss kthx
04:42:56 <lambdabot> Consider it noted.
04:42:58 <adu> twb: indeed
04:43:14 <adu> twb: my favorite is gnu-unifont :)
04:43:20 <ReDAeR> 'Consied it noted
04:43:23 <ReDAeR> lolled
04:43:32 <maltem> Talking Gauß, how famous is Lenstra?
04:43:55 <twb> Eh, unifont is too large
04:44:00 <twb> I like schumacher-clean
04:44:38 <adu> i have tiny pixels
04:44:44 <twb> Lucky bastard
04:44:53 <twb> My pixels are like an inch across
04:44:58 <adu> lol
04:45:00 <twb> (hyperbole)
04:45:28 <twb> AFAICT all the LCDs have huge pixels because the small-pixel resources are used to capacity by cellphones
04:45:43 <MyCatVerbs> I like my big chunky pixels.
04:45:45 <twb> One more suck the telcos are responsible for.
04:45:51 <MyCatVerbs> Makes the text pleasantly big enough to read.
04:46:02 <twb> MyCatVerbs: you could do that by bumping the DPI
04:46:25 <MyCatVerbs> twb: Not on pixel fonts like monofur which're hand drawn one dot at a time.
04:46:25 <fasta> twb, how big is a big pixel?
04:46:41 <MyCatVerbs> But yeah, admittedly it also necessitates antialiasing on text. But oh well.
04:46:55 <fasta> twb, you don't need to do that math. Just screen resolution and dimensions should to fine.
04:46:59 <adu> twb: in fact, at my last job, i had to use ssh on windows a lot, and Putty wouldn't use the unifont TTF, so I recompiled Putty to allow fonts not tagged as monospace...
04:47:16 <twb> fasta: you have big pixels if your 19" LCD has a native resolution of 1400x900
04:47:34 <MyCatVerbs> adu: 1. Open source software. 2. Problem arises. 3. Cheap hack. 4. Profit! :)
04:47:40 <adu> lol
04:47:43 <twb> Small pixels would get like 1400x900 into a 9" LCD
04:47:57 <twb> Stupid hardware
04:48:02 <MyCatVerbs> twb: shurely you can work out what the dot pitch is. :)
04:48:32 <fasta> twb, I think I have big pixels too then. 1650*1080 with 24" or something like that.
04:48:48 <twb> fasta: yeah, you can't buy LCD monitors with small pixels anymore.
04:48:58 <Exteris> most laptops have them though twb
04:49:05 <twb> Exteris: yeah.  bastards
04:49:13 <Exteris> my desktop monitor is 22" 1680x1050, my laptop is 16" 1680x1050
04:49:19 <Exteris> easy with wallpapers though :D
04:49:22 <ReDAeR> I think i just got the ahaaa moment and i see that everything is about recursion, correct?
04:49:27 <hackagebot> hs-captcha 1.0 - Generate images suitable for use as CAPTCHAs in online web-form security. (DanKnapp)
04:49:41 <MyCatVerbs> ReDAeR: all looping in Haskell is done via recursion, yes. :)
04:49:42 <fasta> ReDAeR, the only way to write a loop is with recursion, or fix, yes.
04:49:50 <twb> You ought to be able to get a computer that fits in your pocket, and leave the 12" or 20" LCD in your office
04:50:10 <Exteris> twb: those are called nettops :p
04:50:14 <MyCatVerbs> My favourite recursive algorithm is the one for understanding recursion.
04:50:16 <twb> Who wants to carry a huge 12" LCD around with them all day?  Bleh.  7" is enough for occasional use on the train
04:50:27 <MyCatVerbs> If you understand recursion already, recall the answer from memory.
04:50:37 <twb> Exteris: yeah, but the problem is that when I go down that route, I can't get small pixels on the LCD
04:50:59 <MyCatVerbs> If you don't understand recursion yet, find someone who is standing closer to Douglas Hofdstadter than you are, and ask them.
04:51:35 <dankna> that's awesome.
04:51:40 <MyCatVerbs> Guaranteed to terminate provided Doug doesn't contract Alzheimer's.
04:51:41 <adu> I would like to take this time to promote an aspect ratio. Have you ever considered a 15x8 screen? It's close to 16x9, but _wider_ (about 1.875:1), and you can have it today with only a triple-head display composed of three 8x5 monitors! Added bonus: the diagonal is 17.
04:52:03 <twb> MyCatVerbs: assuming infinite resources...
04:53:07 <twb> My old monitor, which I got when LCDs were pretty new, is a nice 4:3 ratio and exactly A3.
04:53:23 <MyCatVerbs> twb: Not so. Even in the worst case, it's only linear in the number of people on the planet. At the moment that is bounded above by the number 7 billion, so it's O(1).
04:53:31 <adu> that's impossible, A3 /= 4:3
04:53:47 <twb> adu: ssh
04:53:51 <MyCatVerbs> A3 is sqrt(2):1.
04:54:09 <Vanadium> MyCatVerbs: That is assuming everybody is standing still
04:54:27 <adu> thats like saying 1.414 = 1.333
04:54:30 <twb> MyCatVerbs: that's about 4.2:3
04:54:38 <twb> Near enough for government work
04:55:02 <MyCatVerbs> twb: Square pixels or not? IMO that's more important than getting the aspect ratio right.
04:55:06 <twb> Or, maybe the pixels weren't quite square
04:55:23 <MyCatVerbs> I don't really mind black bars down the sides of the screen during videogames so long as I don't end up with virtual astigmatism.
04:55:24 <twb> I know that it did 1600x1200, and I could stick two sheets of A4 paper on it side by side
04:55:45 <MyCatVerbs> With room to spare?
04:55:50 <twb> The paper might've been edging out onto part of the dead area, I guess
04:55:55 <adu> twb: was there a scrollbar?
04:56:12 <twb> I measured the paper against the start of the bezel
04:56:46 <twb> Having really wide monitors pisses me off because I'm dealing with text, dammit
04:56:55 <twb> I only need 70 characters across, but I want lots of lines
04:57:09 <twb> And your typical widescreen monitor can't cope with being tipped on its side
04:58:20 <adu> did you know that hulu does not use square pixels?
04:58:35 <adu> they use 80x81 pixels
04:59:21 <mreh_> is it okay to unsafePerformIO to get a random number>
04:59:48 <mreh_> I need to get some randoms numbers to seed my generator, but the only way to get one from the system is through IO monad
05:00:08 <quicksilver> no.
05:00:09 <mreh_> then I can pass my seeded generator round in a monad in a nice haskelly way
05:00:22 <quicksilver> that's a ridiculous reason to use unsafePerformIO
05:00:34 <quicksilver> just get a seed from the system in the top-level of your program (in 'main')
05:00:38 <quicksilver> and then pass it to the pure code.
05:00:50 <mreh_> quicksilver, of course
05:00:53 <mreh_> thnx
05:00:56 <quicksilver> np
05:01:06 <twb> Probably a random number module already
05:02:13 <mreh_> there is, but it needs to be seeded
05:02:46 <mreh_> with a random seed
05:02:51 <mreh_> confusing eh?
05:05:22 <fasta> mreh_, why not use MonadRandom?
05:05:28 <twb> I expected the API to have an alternate interface that seeded it for you
05:05:40 <mreh_> fasta: I need normal distributions of numbers
05:05:53 <mreh_> I'm using Statistics.Random
05:06:11 <mreh_> twb: it does, but you have to give it a seed
05:06:44 <fasta> mreh_, well, you can probably make a probability monad which uses a normal distribution then.
05:07:04 <mreh_> fasta: Statistics.Random has one
05:07:22 <mreh_> but also a generator that makes normally distributed random numbers
05:20:21 <mreh_> @hoogle Int -> Integral
05:20:22 <lambdabot> Warning: Unknown type Integral
05:20:22 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:20:22 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:20:36 <mreh_> @hoogle Integral a => Int -> a
05:20:37 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:20:37 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:20:37 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
05:20:52 <quicksilver> mreh_: fromIntegral
05:21:05 <mreh_> Int isn't an integral
05:21:23 <quicksilver> yes it is.
05:21:50 <quicksilver> > fromIntegral (2 :: Int) :: Word16
05:21:51 <lambdabot>   2
05:22:30 <mreh_> :D
05:22:56 <mreh_> whoever worked out this typing system is a genius
05:23:50 <ReDAeR> Got a question why does: word <- getLine let num = read word
05:24:00 <ReDAeR> oh wtf multipl lines pastes sucks (2sec)
05:24:26 <mreh_> > map fromIntegral ([1..10]::[Int]) :: [Word32]
05:24:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
05:24:31 <mreh_> Cool!
05:25:19 <ReDAeR> http://pastebin.com/d63c23eef
05:25:44 <quicksilver> ReDAeR: because it's not the same.
05:25:53 <ReDAeR> .. Why?
05:25:55 <quicksilver> ReDAeR: word is not getLine
05:26:06 <quicksilver> ReDAeR: getLine is an IO action which has to be executed
05:26:11 <ReDAeR> But you store the contents of getLine in words
05:26:13 <quicksilver> (Which in a sense, is what the <- does)
05:26:16 <quicksilver> no the contents, no
05:26:20 <quicksilver> the result of executing.
05:26:23 <quicksilver> (different thing)
05:26:38 <quicksilver> you can execute getLine many times it will come up with different results each time in general.
05:26:45 <quicksilver> word is just a simple string.
05:26:57 <quicksilver> however, there *is* a combinator which does what you want
05:27:10 <quicksilver> ...applies a function to the result of an action.
05:27:11 <quicksilver> try this:
05:27:17 <quicksilver> num <- fmap read getLine
05:27:32 <quicksilver> "fmap" does this trick - applies a function to the result you get when you execute.
05:27:45 <ReDAeR> I mean why does it matters if i get a line store it in a variable and then process the variable or if i want to process the line directly? :s
05:27:55 <quicksilver> ReDAeR: it doesn't matter.
05:28:05 <quicksilver> ReDAeR: but "read getLine" is not processing the line
05:28:09 <quicksilver> getLine isn't the liine
05:28:18 <quicksilver> getLine is the *command* which, when run, produces the line
05:29:21 <ReDAeR> Here a quick page of YAHT: http://pastebin.com/d7adcdfce
05:29:48 <ReDAeR> quicksilver: you say it PRODUCES the line but it is RETURNING it?
05:30:11 <ReDAeR> I understand that it's doing it but i don't understand why
05:30:49 <quicksilver> produce and return are being used as the same thing, yes
05:31:02 <ReDAeR> Why do you absolutely must store it in a variable before processing, i get your point but my head is like: WTF THIS IS ONE LINE THE OTHER IS 2 WAI?!
05:31:37 <ReDAeR> I think i get it
05:31:39 <koala_man> maybe it'll help if you write it without do notation
05:31:47 <ReDAeR> Just don't understand why
05:31:52 <twb> ReDAeR: is it September already?
05:32:15 <osfameron> no, it's already August!
05:32:16 <ReDAeR> The function produces the list and the <- takes the list, correct?
05:32:24 <Saizan> ReDAeR: because the computation that produces a value and the value produced are actually considered different things by haskell type system
05:32:29 <quicksilver> ReDAeR: there is no need to store it in a variable.
05:32:36 <Saizan> ReDAeR: getLine :: IO String, while word :: String there
05:32:39 <quicksilver> ReDAeR: I never said there was - and I taught you about fmap
05:32:44 <twb> I refer, of course, to http://en.wikipedia.org/wiki/Eternal_September
05:32:48 <quicksilver> ReDAeR: to show you how you could avoid using a variable.
05:33:25 <ReDAeR> Yes thank you quicksilver
05:33:47 <mreh> randomNumberGen :: [Int] -> Gen s
05:33:47 <mreh> randomNumberGen seeds = runST $ do initialize seeds'
05:33:47 <mreh>   where seeds' = toU (map fromIntegral seeds)
05:33:55 <mreh> can anyone see anything inherently wrong with this code?
05:34:16 <mreh> initialize :: UArr Word32 -> ST s (Gen s)
05:34:48 <quicksilver> what's the error?
05:35:25 <Saizan> the $
05:35:39 <ReDAeR> Lolled twb ;) I just think it's weird and not logical ( it's probabely because i'm used to C like languages )
05:35:54 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11326#a11326
05:35:57 <ReDAeR> probably*
05:36:11 <quicksilver> ReDAeR: in C there is a difference between a function and its result.
05:36:13 <mreh> well forget about C programming with haskell
05:36:22 <twb> ReDAeR: I was referring to your... idiomatic speech patterns, rather than your actual remark.
05:36:30 <quicksilver> ReDAeR: "getchar" and "getchar()" are very very different things in C.
05:36:58 <quicksilver> compare printf("You typed %d",getchar()) with printf("You typed %d",getchar)
05:37:04 <Saizan> mreh: the second error is about screwed up indentation
05:37:19 <quicksilver> this is just the same distinction, in haskell
05:37:22 <ReDAeR> twb: but you can write: x = getY() + getZ(); you dont have to do: y = getY(); z = getZ(); x = y + z;
05:37:30 <Saizan> mreh: the first one is because you've to use parentheses instead of $ with runST
05:37:40 <ReDAeR> twb: 'idiomatic speech patterns' let me Google that o.o
05:38:51 <mreh> Saizan: yeah? how do they differ in their evaluation?
05:39:22 <twb> mreh: I guess he's just saying C is a Lisp-2
05:39:28 <Saizan> mreh: it's not about evaluation, it's about type checking
05:40:25 <Saizan> mreh: runST requires its argument to be polymorphic, but $ doesn't allow that with predicative polymorphism
05:40:35 <Saizan> ?type ($)
05:40:36 <lambdabot> forall a b. (a -> b) -> a -> b
05:40:57 <Saizan> the 'a' there can't be a type containing a quantifier
05:41:04 <Saizan> ?type runST
05:41:05 <lambdabot> forall a. (forall s. ST s a) -> a
05:41:14 <mreh> what if I use a do?
05:41:15 <twb> Is that a limitation in the theory, or in the current implementation?
05:41:20 <Saizan> but "(forall s. ST s a)" contains it
05:41:57 <mreh> this indentation thing has stumped me too, it's all space
05:42:00 <mreh> spaces*
05:42:25 <Saizan> with impredicativity type inference is not decidable anymore, afaik
05:42:44 <twb> I figured it'd be something like that
05:43:17 <Saizan> you just have to write "runST (initialize seeds')" there
05:43:27 <quicksilver> twb: there is an inference system which gets runST right
05:43:33 <quicksilver> twb: ...but it has limitations of its own
05:44:03 <quicksilver> the GHC team keep experimenting on paper with inference systems which migth get some interesting bits right.
05:45:03 <Saizan> there's already an ImpredicativeTypes flag, not sure which system uses though
05:45:12 <quicksilver> a broken one :)
05:47:39 <mreh> Main.hs:19:24:
05:47:39 <mreh>     Inferred type is less polymorphic than expected
05:47:39 <mreh>       Quantified type variable `s' escapes
05:47:39 <mreh>     In the first argument of `runST', namely `(initialize seeds')'
05:47:39 <mreh>     In the expression: runST (initialize seeds')
05:47:48 <mreh> hmm
05:48:13 <Saizan> can you paste the whole code?
05:48:16 <mreh> sure
05:48:18 <quicksilver> initialias has an 's' in its return type
05:48:23 <quicksilver> ST s (Gen s)
05:48:27 <quicksilver> I'm sure that isn't what you meant
05:48:33 <quicksilver> ST s (Gen t) maybe?
05:49:45 <Saizan> runST (replicateM 10 . randomInt (1, 10) =<< randomNumberGen seeds) <- this doesn't look right if randomNumberGen contains a runST of its own
05:50:00 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11327#a11327
05:50:39 <mreh> Saizan: pasted
05:51:05 <mreh> randomInt comes back with -> ST s Int
05:51:26 <mreh> so I need to runST to get the numbers out
05:51:29 <Saizan> ?hoogle toU
05:51:29 <lambdabot> Foreign.ForeignPtr touchForeignPtr :: ForeignPtr a -> IO ()
05:51:30 <lambdabot> Data.Array.Storable touchStorableArray :: StorableArray i e -> IO ()
05:51:30 <lambdabot> Data.Char toUpper :: Char -> Char
05:52:04 <Saizan> mreh: yeah, but then you don't use runST in randomNumberGen
05:52:39 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11327#a11328 <- like this
05:52:41 <jokerGTA> guys can anyone help me with problrms i am having....i can use some direction..i am lost
05:52:44 <Saizan> if toU has the right type
05:53:36 <ReDAeR> jokerGTA: Just ask your question
05:54:13 <mreh> Saizan: ooooooooh
05:54:19 <mreh> i am such an idiot
05:54:25 <blackh> jokerGTA: if it's a personal problem, be warned - our advice will be terrible!
05:54:53 <jokerGTA> lol...blackh  i am desperate..i take even horrible advice
05:54:54 <ksf> how do I tell cabal configure to keep temporary .c files?
05:55:03 <jokerGTA> this is for my assignment and i cant make any progress whatsoever
05:55:09 <byorgey> "what's that, your sweetheart is mad at you?  Try mapM_"
05:55:09 <jokerGTA> all i have managed so far is this
05:55:20 <jokerGTA> i have some data type that represents statements
05:55:24 <dcoutts> ksf: you'll have to send in a patch for that. I presume you're talking about the configure test for C libs.
05:55:30 <jokerGTA> i also have data type that represents expressions
05:55:40 <ksf> gnaaargh
05:55:57 <jokerGTA> i have some input sentence(which represents program syntax) and  i have to parse that
05:56:25 <ksf> I'm precisely trying to run configure _without_ running configure.
05:56:45 <ksf> ...as I'm trying to inject the target's configuration while cross-compiling.
05:56:57 <dcoutts> ksf: sounds like you just want to skip the checks then
05:57:13 <jokerGTA> so basically i have to parse that sentence and turn it into my data type
05:57:22 <dcoutts> ksf: it doesn't make sense to keep the .c files in this case
05:57:35 <ksf> right now, I hacked ghc-cabal to call defaultMain instead of the autoconf-one unconditionally.
05:57:58 <ksf> I'm wondering whether I have to run main, at all, or if I just have to run the rest of the ghc-specific stuff.
05:58:00 <blackh> jokerGTA: That doesn't sound too bad.
05:58:10 <Jafet> joker, ok, your question?
05:58:31 <jokerGTA> well at first id like to start to write parser
05:58:36 <jokerGTA> but i dont know how
05:58:47 <jokerGTA> i understand that parser parser input based on tokens
05:58:54 <jokerGTA> and it returns it
05:59:52 <blackh> jokerGTA: Write your code using pattern matching on the token stream (a list of strings?) and recursion...
06:00:03 <Saizan> or look at parsec
06:00:11 <Jafet> Saizan, homework
06:00:16 <jokerGTA> yes i have to use parsec library but i dont know how
06:00:28 <Saizan> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
06:00:31 <Saizan> Jafet: so?
06:00:35 <Jafet> Oh, homework with parsec?
06:00:39 <Jafet> Should be trivial then
06:00:50 <jokerGTA> its not trivila for me Jafet:)
06:00:56 <jokerGTA> i wish it is:)
06:01:10 <Saizan> jokerGTA: have you read the above guide? ^^^
06:01:14 <jokerGTA> all i have managed to do so far is write data type and functions that would be executed
06:01:16 <blackh> JokerGTA: I'll leave it to other since I'm a parsec ignoramus.  Don't worry - everything's easy in Haskell.  You just don't know it yet when you are learning.
06:01:25 <jokerGTA> yes i did and couldnt really understand anything
06:01:36 <Jafet> Bah, another whiner
06:01:45 <jokerGTA> lol jafet:)
06:01:53 <mreh> I've had two brane asplodes today, and it's only 1pm
06:02:07 <ksf> dcoutts, is it enough to copy dist/setup-config to fool cabal into thinking the package is configured?
06:02:26 <Jafet> I can't help whininess, but you can try asking better questions.
06:02:27 <jokerGTA> is anyone willing to work with me on this and mentor me trough this..
06:02:35 <dcoutts> ksf: yes
06:02:39 <jokerGTA> i wish i can ask better question
06:02:52 <dcoutts> ksf: but make sure the details like paths are the same
06:02:59 <Saizan> jokerGTA: have you written some of the parser?
06:03:04 <jokerGTA> no
06:03:28 <jokerGTA> all i did in haskell is write few function that manipulate lists
06:03:31 <Saizan> what is blocking you?
06:03:39 <ksf> erm yes. the problem is, to generate those, I'd have to have a running cabal on the target system, for which I need a running ghc on the target system, for which I need ...
06:03:40 <jokerGTA> i dont know how to start
06:04:00 <ksf> well, that's the reason why bootstrapping is called bootstrapping.
06:04:11 <jokerGTA> more i am trying to figure out and looking at it the harder it looks to me
06:04:14 <blackh> jokerGTA: Real World Haskell has a good section on parsec IIRC
06:04:23 <dcoutts> ksf: if the paths do not match up you can just use sed
06:04:26 <Saizan> jokerGTA: well, start with the examples in the guide and work up from them
06:04:33 <jokerGTA> i looked on that and first part of explanation has like 50 lines of code
06:04:46 <ksf> dcoutts, you see, I don't have any setup-configs from the target system, only the ./configure output.
06:04:56 <ksf> ...as I don't have cabal up and running there, yet.
06:05:06 <Jafet> joker, stop giving excuses
06:05:22 <dcoutts> ksf: that's what I mean, you can probably copy over ones from the host and make the appropriate changes by hand
06:05:28 <jokerGTA> is there any examples outthere that shows how to turn inputs into some custom data type
06:05:33 <Jafet> If you have trouble understanding the code, you can ask about it. If you have trouble reading the documentation, you can ask about it. If you have trouble with data types, you can ask about it.
06:05:47 <ReDAeR> I made this function to print all words in a list: http://pastebin.com/d203af1be my question is this a good one? Second is their a standard one or a better one?
06:06:22 <blackh> ReDAeR: There are all sorts of things you can do to make it more Haskelly
06:06:26 <jokerGTA> ok ill show you the data type i have and then ill ask you questions
06:06:30 <Jafet> First you need to decide what kind of parse tree to turn the input into.
06:06:46 <Jafet> Then you make data types to represent the parse tree.
06:07:08 <blackh> ReDAeR: printWords = mapM_ putStrLn   <-- much more Haskelly
06:07:23 <ReDAeR> blackh: I'm reading the YAHT book and it gives you some exercises but it never said anything about printing a list..
06:07:24 <quicksilver> ReDAeR: on the other hand, what you wrote indicates you've got the hang of recursion :)
06:07:46 <quicksilver> ReDAeR: note that "return []" is essentiall arbitrary, since you don't have anything interesting to return.
06:07:58 <quicksilver> ReDAeR: in that case "return ()" is more conventional.
06:08:01 <quicksilver> it doesn't matter though.
06:08:12 <ReDAeR> (I just used the same what the book used, thank you :) )
06:08:18 <benmachine> generally speaking, testing if a list is empty or not is better done with null rather than length
06:08:23 <benmachine> :t null
06:08:24 <lambdabot> forall a. [a] -> Bool
06:08:41 <Jafet> @hoogle fix
06:08:41 <lambdabot> Data.Function fix :: (a -> a) -> a
06:08:41 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
06:08:41 <lambdabot> module Control.Monad.Fix
06:08:41 <burp> @src null
06:08:44 <benmachine> > null [1 ..]
06:08:44 <lambdabot> null []     = True
06:08:44 <lambdabot> null (_:_)  = False
06:08:45 <lambdabot>   False
06:08:55 <benmachine> > length [1 ..] == 0
06:08:57 <quicksilver> and in a case where you check length, and then use head and tail, it's neater to use a pattern match.
06:08:58 <lambdabot>   mueval-core: Time limit exceeded
06:09:12 <quicksilver> printWords (x:xs) = ... one case ...
06:09:15 <blackh> ReDAeR: One thing about what you've done is that 'length' will be slow, because it has to traverse the list
06:09:18 <quicksilver> printWords [] = .. other case ...
06:09:33 <ReDAeR> Ok thank you for all the comments :)
06:09:33 <benmachine> pattern matching is indeed the best way to get the head and tail of a list
06:09:36 <benmachine> @src head
06:09:36 <lambdabot> head (x:_) = x
06:09:37 <lambdabot> head []    = undefined
06:09:40 <benmachine> @src tail
06:09:40 <lambdabot> tail (_:xs) = xs
06:09:40 <lambdabot> tail []     = undefined
06:14:21 <Jafet> @src last
06:14:21 <lambdabot> last [x]    = x
06:14:21 <lambdabot> last (_:xs) = last xs
06:14:21 <lambdabot> last []     = undefined
06:14:41 <Jafet> @src map
06:14:41 <lambdabot> map _ []     = []
06:14:41 <jokerGTA> jafet http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4526#a4526
06:14:41 <lambdabot> map f (x:xs) = f x : map f xs
06:14:46 <jokerGTA> thats what i have so far
06:14:51 <Jafet> Is map really implemented like that?
06:14:59 <ReDAeR> So if you are saying (x:xs) x is the head and xs is the tail?
06:15:24 <ReDAeR> Jafet: I guess lambdabot is always right :P
06:15:34 <burp> and why not?
06:16:17 <Saizan>  @src is often just demonstrative :)
06:16:22 <Jafet> joker, I have no idea what that code is supposed to do
06:16:24 <HayashiRazan> x is the head and xs is the tail brother
06:16:34 <Jafet> Saizan, I do hope so!
06:16:36 <zygoloid> Jafet: map is extensionally equivalent to that. :)
06:16:44 <Saizan> but that's a perfectly valid implementation, unless you use list fusion
06:16:45 <Jafet> joker, has your class covered comment syntax...
06:16:51 <HayashiRazan> :t (x:xs)
06:16:52 <lambdabot> Not in scope: `xs'
06:16:57 <Saizan> there's no other way to implement it, really
06:17:00 <zygoloid> :t (x:y)
06:17:01 <lambdabot>     Couldn't match expected type `[Expr]' against inferred type `Expr'
06:17:01 <lambdabot>     In the second argument of `(:)', namely `y'
06:17:01 <lambdabot>     In the expression: (x : y)
06:17:09 <HayashiRazan> goddamnit
06:17:22 <zygoloid> :t ?x:?xs
06:17:23 <Saizan> ?type \x xs -> (x:xs)
06:17:23 <lambdabot> Not in scope: data constructor `:?'
06:17:23 <lambdabot> Not in scope: `xs'
06:17:24 <lambdabot> forall a. a -> [a] -> [a]
06:17:32 <zygoloid> :t ?x: ?xs
06:17:33 <lambdabot> forall a. (?xs::[a], ?x::a) => [a]
06:17:38 <Saizan> ?type (:)
06:17:39 <lambdabot> forall a. a -> [a] -> [a]
06:17:50 <Jafet> Not sure how Haskell is compiled, but I get the feeling there are more efficient ways to do it
06:18:09 <jokerGTA> yes we did
06:18:36 <HayashiRazan> does anyone in here ever understand things better when they get LESS sleep?
06:18:56 <Jafet> I understand better the need for sleep
06:19:09 <Saizan> Jafet: well, you can't update in place, and tail recursion would just be worse, so (except for list fusion) i don't see room for improvement
06:19:13 <Jafet> joker, and try to post all code
06:19:26 <sieni> HayashiRazan: Too much sleep is also bad for my comprehension
06:19:40 <Jafet> Saizan, ah, that's true
06:19:59 <Jafet> I guess I'm thinking <other data structure> maps
06:20:02 <jokerGTA> yeah i know its hard to understand it without all code
06:20:34 <Saizan> you could do a worker/wrapper transform, and do map f = go where go [] = []; go (x:xs) = f x : go xs, that might turn into faster code
06:21:27 <Jafet> Saizan, don't really follow, that looks just like map to me
06:21:47 <twb> Waiting for ghc on ARM is a blow when you've been monopolizing a time-shared Q9550.
06:22:13 <ddarius> Jafet: There's no better way (algorithmically) of defining map.
06:22:28 <Saizan> Jafet: the 'f' doesn't get passed as an argument to the recursive call
06:23:00 <jokerGTA> jafet could we just do some simple data type and  then have some input string show parse it  into the haskell data type
06:23:02 <Jafet> I wonder if that can make a big difference
06:24:54 <Jafet> joker, what is the program supposed to do?
06:25:28 <jokerGTA> it is suppose to take input string
06:25:42 <jokerGTA> and somehow translate it into data type i showed you and execute it
06:26:10 <Jafet> Ok, so translate it
06:26:17 <Jafet> You seem to have the execution part covered
06:26:36 <jokerGTA> i can do function and and things like that
06:26:57 <jokerGTA> but i have this input "while not(atEnd) do     if check and not(atEnd) then walk;turn(Left) else turn(Right) fi od"
06:27:06 <jokerGTA> and i have to execute it
06:27:10 <jokerGTA> so basically i have string
06:27:23 <jokerGTA> that i need to parse....thats where i am lost
06:27:51 <benmachine> you have to use parsec?
06:28:01 <jokerGTA> yes
06:28:11 <Jafet> Take your parsing grammar, write a parser for each element
06:28:17 <jokerGTA> ok how
06:28:18 <Jafet> Are you familiar with BNF notation?
06:28:24 <jokerGTA> no
06:28:30 <HayashiRazan> while not(atEnd) should be a recursive function
06:28:40 <jokerGTA> can you give me example or anything i can start..i dont need solutions just guidance
06:28:43 * ddarius doesn't know how anyone writes a parser without BNF
06:28:47 <jokerGTA> i have like 10 days to finish this
06:29:08 <jokerGTA> so for example sentence i showed you
06:29:12 <Jafet> First off, learn BNF, because parsec parsers tend to look like BNF.
06:29:12 <jokerGTA> how many elemets are there
06:29:51 <benmachine> I don't think parsec is really necessary for something like this
06:29:58 <benmachine> but you can use it anyway
06:30:08 <Jafet> Well, he asked for it
06:30:13 <benmachine> I would suggest first working out how to construct a trivial parser
06:30:23 <benmachine> like the ones given in http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
06:30:31 <benmachine> that just parses string "hello" or something
06:30:39 <jokerGTA> yes i tried that bench machine and could get it working
06:30:43 <jokerGTA> could not
06:31:07 <benmachine> (why do people think my name has bench in it?)
06:31:09 <benmachine> well
06:31:13 <benmachine> you need to do that first
06:31:16 <HayashiRazan> benchmachine
06:31:22 <Jafet> Papa's got a brand new bench
06:31:25 <jokerGTA> oh its benmachine..sorry:)
06:31:30 <HayashiRazan> lol
06:31:34 <benmachine> before doing anything to do with your actual program
06:31:53 <jokerGTA> first example got me lost because we havent done any IO whatsoever
06:32:00 <benmachine> (I don't actually mind, it's just weird that I've had that from like three different people)
06:32:14 <benmachine> okay
06:32:19 <jokerGTA> jafet whats BNF
06:32:24 <benmachine> I'll give you a different example
06:32:27 <HayashiRazan> Backus Naur
06:32:42 <HayashiRazan> Form
06:32:46 <Botje> alism.
06:32:47 <Jafet> joker, something you can read about on the internet
06:33:02 <jokerGTA> yeah i found it
06:33:05 <Jafet> Or ideally, out of Aho or something
06:33:08 <HayashiRazan>  John Backus and Peter Naur developed a context free grammar to define the syntax of a programming language by using two sets of rules: i.e., lexical rules and syntactic rules.
06:33:21 <Jafet> Since you seem to be parsing a traditional imperative language
06:34:04 <jokerGTA> so for every element one parse needs to be written?
06:34:09 <mreh> haskell is like an old girlfriend
06:34:20 <Jafet> When I say element I mean grammar rule.
06:34:27 <Jafet> Not lexical token.
06:34:46 <benmachine> jokerGTA: simplest parsers ever: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4527#a4527
06:34:47 <Jafet> You can still lex, but parsec makes that obsolete
06:34:59 <benmachine> jokerGTA: do you know about Either?
06:35:15 <Axman6> mreh: even if you've found someone else, you're still attracted to her?
06:35:26 <ReDAeR> :o goodone
06:35:40 <mreh> haha
06:36:47 <jokerGTA> no i dont benmachine
06:37:19 <benmachine> jokerGTA: running a parsec parser gets you an Either value, so you should know about it
06:38:19 <jokerGTA> lets say if you have sentence as input....and you looking for "And" word in it? once parser finds it where does it put that word
06:38:29 <jokerGTA> what if encounters the And word few times
06:39:37 <copumpkin> oh no, impredicative types are going away soon!
06:39:39 <copumpkin> zomg
06:39:51 <HayashiRazan> how do you know that?
06:39:59 <medfly> he can see the future
06:40:42 <benmachine> jokerGTA: work out how basic parsers work first, and how you can build them
06:40:51 <benmachine> for which you're going to need to know how to use Either
06:40:58 <benmachine> so go and find that out
06:41:35 <jokerGTA> ok ben....can you tell me if this what i need is a lot of code....
06:41:53 <jokerGTA> ill learn about what you told me......when you online again?
06:42:05 <benmachine> depends
06:42:25 <benmachine> but it doesn't matter too much
06:42:36 <benmachine> when you learnt what I've told you to learn, just come and ask here again
06:42:40 <benmachine> people will be able to help you a bit more
06:42:42 <copumpkin> HayashiRazan: I can read SPJ's mind
06:43:01 <jokerGTA> this example you gave me has no code in it
06:43:14 <jokerGTA> its just a function i call from command line
06:43:32 <benmachine> that's code :P
06:43:41 <benmachine> it's a very very simple parser
06:44:02 <benmachine> all right I'll do a more useful example
06:44:46 <jokerGTA> thanks
06:46:46 <jokerGTA> ok ben when you run this parser "hello" works fine but "something hello" doesnt
06:46:53 <benmachine> jokerGTA: yeah
06:46:56 <jokerGTA> it only looks for first encouter with hello
06:47:02 <benmachine> right
06:47:13 <benmachine> if you put "something " on the beginning of your program above
06:47:16 <benmachine> that wouldn't work either :)
06:47:21 <jokerGTA> yes
06:47:30 <benmachine> it should fail when there's a string it doesn't expect
06:47:33 <benmachine> that's correct behaviour
06:47:40 <jokerGTA> yeah exactly
06:47:58 <jokerGTA> but sentece you have as input will consist of many different words..so it would always fail
06:48:03 <jokerGTA> it will never be same words
06:48:19 <benmachine> there are ways of combining parsers
06:48:21 <jokerGTA> which means you have to have one parser for every word you looking for or every character
06:48:29 <benmachine> so that they will accept more complex inputs
06:49:03 <Jafet> joker, LEARN BNF
06:50:38 <Guest45410> @user
06:50:38 <lambdabot> Unknown command, try @list
06:50:46 <Guest45410> @list
06:50:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:51:01 <HayashiRazan> joker fail this project and MAKE BNF
06:51:56 <jokerGTA> yeah i probably will Hayashi:)
06:56:41 <gal_bolle> is there a way to use ghc to typecheck a bunch of .hs files without actually generating any code?
06:57:00 <benmachine> jokerGTA: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4528#a4528 shows how you can join parsers together
06:57:15 <benmachine> see if you can understand it
06:57:22 <benmachine> I'm going to get on with my work now
06:57:26 <benmachine> good luck, anyway
06:57:32 <ReDAeR> bb benmachine
06:58:01 <jokerGTA> thanks benmachine
07:04:32 <FunctorSalad_> gal_bolle: ghc-api
07:06:01 <gal_bolle> thanks
07:10:48 <FunctorSalad_> gal_bolle: here are the incantations to get you started =) http://haskell.org/haskellwiki/GHC/As_a_library
07:11:00 <FunctorSalad_> gal_bolle: then do Ghc.parseModule, Ghc.typecheckModule
07:13:37 <hackagebot> WebBits-Html 1.0.1 - JavaScript analysis tools (ArjunGuha)
07:13:54 <Younder> hackagebot, firebug
07:14:50 <Younder> seriosuly firefox has the best javascript debugging environment
07:22:36 <ivanm> Cale: you still around?
07:23:24 <Younder> doing a ubuntu upgrade
07:23:43 <ReDAeR> Ubuntu ;o
07:23:49 <Younder> ubuntu 9.10
07:24:00 <ivanm> Younder: was that a response to me?
07:24:11 <ivanm> or are you just letting us all know what you're doing? :p
07:24:48 <Younder> I can't get you in touch with cale can I
07:25:29 <Zao> I suppose it's time to submit a bug report against the HP. It doesn't seem to install properly on 9.10
07:25:42 <Zao> (with a self-installed ghc, I might add)
07:25:52 <Younder> ouch
07:26:57 <Younder> Zao, yes if that is in fact aproblem report it
07:29:58 <jokerGTA> guys i get error with this code which i got from web site...it gives me error of "ambiguos occurences of spaces"  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4529#a4529
07:30:47 <benmachine> jokerGTA: full error message?
07:30:48 <ReDAeR> ambiguos? Is that some Haskell word?
07:30:54 <benmachine> wait I'm not supposed to be here am I
07:30:57 <benmachine> I'm supposed to be working
07:31:05 <benmachine> well, give someone else the full error message :P
07:31:15 <jokerGTA> lol...i am suppose to be learning about parsers as we agreed:)
07:31:23 <jokerGTA> :)
07:32:45 <fasta> How is your experience with porting Haskell code  using a limited number of C libraries to Windows?
07:35:20 <Botje> @hoogle spaces
07:35:21 <lambdabot> Text.Parsec.Char spaces :: Stream s m Char => ParsecT s u m ()
07:35:21 <lambdabot> Text.ParserCombinators.Parsec.Char spaces :: Stream s m Char => ParsecT s u m ()
07:35:21 <lambdabot> Text.ParserCombinators.ReadP skipSpaces :: ReadP ()
07:35:31 <Botje> jokerGTA: parsec already has a "spaces" combinator.
07:35:44 <Botje> so either use that or import ......Parsec hiding (spaces)
07:36:07 <jokerGTA> i got this from the online book
07:36:40 <Botje> well, it doesn't take the built-in "spaces" for account.
07:37:03 <Botje> use it or hide it :)
07:37:06 <jokerGTA> what if i just change spaces to something else
07:37:19 <Botje> that would work too, yes.
07:37:51 <jokerGTA> thank you Botje
07:38:12 <jokerGTA> haskell can be bit chalenging at times:)
07:39:24 <ReDAeR> jokerGTA: a bit ;)
07:39:38 <jokerGTA> am i the only newbie here..lol
07:40:08 <byorgey> jokerGTA: I doubt it =)
07:40:11 <copumpkin> jokerGTA: no, pretty much everyone considers it mindblowing for the first month or two
07:40:14 <byorgey> @users
07:40:14 <lambdabot> Unknown command, try @list
07:40:41 <byorgey> copumpkin: many people consider it mindblowing for a year or two.
07:40:49 <copumpkin> that too :)
07:41:36 <ReDAeR> Uhm i want to check if something is null so i did "if null xs" but actually i want "if null /= xs"
07:41:42 <ReDAeR> What is the good way?
07:41:47 <ReDAeR> just if xs?
07:41:52 <ReDAeR> or if !null?
07:42:03 <fasta> ReDAeR, it might help to think for a minute.
07:42:17 <copumpkin> lol
07:42:21 <Botje> use pattern matching where you can.
07:42:25 <benmachine> :t null
07:42:25 <lambdabot> forall a. [a] -> Bool
07:42:38 <Botje> case list of [] -> ...; (x:xs) -> ...
07:42:52 <ReDAeR> Botje: I'm just following the book..
07:42:52 <benmachine> !null is the right idea except that ! isn't how you say not in haskell
07:42:57 <jokerGTA> yep mindblowing is good word for it
07:42:59 <fasta> ReDAeR, if that doesn't help, read any Haskell book you haven't read yet and repeat until you read all of them.
07:43:13 <aavogt> or if you want to add an unnecessary Eq constraint, you can write   if [] /= xs then ...
07:43:14 <jmcarthur_work> ReDAeR, if you want "if the list is not empty then do this else do that" you could just say "if the list is empty then do that else do this"
07:43:23 <fasta> ReDAeR, a book that says that you can compare null to xs?
07:43:38 <ReDAeR> jmcarthur_work: True but i just want to say it reverse if its not null do this
07:43:42 <ReDAeR> I think it's easier to read
07:43:44 <jmcarthur_work> ReDAeR, the not function is useful to do it your way though :)
07:43:50 <benmachine> @src not
07:43:50 <lambdabot> not True   =  False
07:43:50 <lambdabot> not False  =  True
07:43:56 <ReDAeR> Ok thank you!
07:44:35 <benmachine> @let nonempty = not . null
07:44:35 <lambdabot>  Defined.
07:44:40 <fasta> ReDAeR, if you don't like to remember syntax, you can define this ifIHateSyntax p t e = if p then t else e
07:45:01 <ReDAeR> 'remember syntax'?
07:45:27 <ReDAeR> Did i ever said something like that?
07:45:46 <benmachine> quite a lot of people think if-syntax is redundant
07:45:50 <benmachine> since if is just fine as a function
07:45:58 <jokerGTA> botje why does that code i showed you (i changed to spaces to something else ) give stackoverflow when i run this ->readExpr" %some"
07:46:18 <copumpkin> I'd kill if. If you flip the fixity of ($) it's just as convenient
07:46:55 <benmachine> how does flipping the fixity of $ help?
07:47:14 * benmachine supports an infixl $ as a different operator
07:47:43 <benmachine> (but that is irrelevant)
07:47:54 <byorgey> fasta: you're not being very helpful.
07:48:00 <Botje> jokerGTA: no idea.
07:48:50 <fasta> byorgey, the best way to learn Haskell is by reading books, to see how other people did it and with a proper background communicate with others.
07:48:59 <Botje> jokerGTA: works here.
07:49:08 <fasta> byorgey, asking about null/=xs is not part of that.
07:49:11 <Botje> *Main> putStrLn $ readExpr " %some"
07:49:11 <Botje> Found value
07:49:55 <byorgey> fasta: you seem to be demanding that people not be confused when they ask questions, which is ridiculous.
07:50:03 <hexpuem> just program in haskell and youll figure stuff out eventually
07:50:10 <copumpkin> benmachine: currently ($) is pretty similar to (.) in many ways
07:50:20 <copumpkin> benmachine: flipping its fixity will make it more different and useful
07:50:29 <copumpkin> omg it's JaffaCake
07:50:36 <fasta> byorgey, Well, I find it a very weird question to ask.
07:50:52 <copumpkin> I don't like syntax either
07:51:15 <ReDAeR> fasta: I agree my question was stupid i should have Googled that one on the other side you could tell me little friendlier i'm already reading a book and it didn't tell me about it (YAHT is the book)
07:51:20 <byorgey> fasta: I find it a very natural question to ask if you are confused and think that 'null' is the empty list, rather than a function to check for the empty list.
07:51:24 <copumpkin> I'm not extreme enough to be a hardcore schemer/lisper, but I think haskell's syntax could be reduced further without causing much trouble
07:51:43 <aavogt> copumpkin: depends on your definition of trouble
07:51:46 <jmcarthur_work> copumpkin, exactly my feelings, too
07:52:03 <copumpkin> aavogt: it would break many modules, but it would be trivial breakage... that's what I consider untroublesome :)
07:52:05 <quicksilver> ReDAeR: it's a weird question, not a stupid question. It's weird because it betrayed you misunderstood something. That's ok; we're here to help when you misunderstand ;)
07:52:07 <FunctorSalad_> making $ left-associative now would cause too much breakage
07:52:27 <copumpkin> FunctorSalad_: not too much in my opinion, but much breakage :)
07:52:45 <fasta> ReDAeR, ok, then let me tell you something useful. IIRC, YAHT does use the interpreter. Why not do :t null to ask what the type of a name is?
07:52:59 <quicksilver> fasta: there is no one "best way" to learn haskell; the best way varies from person to person.
07:53:04 <ReDAeR> You didn't remember it good ;)
07:53:50 <hexpuem> the are source links that go right to the function definitions in the library reference too btw
07:53:59 <hexpuem> helps in understanding things sometimes
07:54:17 <fasta> quicksilver, that's something you have to put before every statement which is not mathematics then.
07:54:39 <fasta> quicksilver, to me it seems obvious that these things are automatically qualifiied by "it's my opinion that".
07:54:45 * FunctorSalad_ seconds quicksilver 
07:54:46 <fasta> qualified*
07:54:58 <quicksilver> fasta: my point is not about it being your opinion
07:55:06 <quicksilver> fasta: my point is about it varying from person to person.
07:55:19 <FunctorSalad_> the person being the learner, not the one making the claim
07:55:27 <quicksilver> the best way for you to learn haskell may not be the same as the best way for ReDAeR to learn haskell
07:55:53 <fasta> quicksilver, yes, that might be true, but there is no proof for either statement.
07:56:07 <quicksilver> in particular, some people learn very well from good books, and some people learn very poorly from the same books
07:56:08 <hexpuem> the best way is to shove a SD card up your nose with learn yourself a haskell good on it
07:56:17 <quicksilver> fasta: tehre is a phenomenal volume of proof for my position
07:56:33 <quicksilver> fasta: some 30-40 years of documented and peer-reviewed educational research
07:56:34 <fasta> quicksilver, ok, maybe I made a bit of a too strong statement there.
07:56:59 * FunctorSalad_ doesn't learn very well from books
07:57:05 <fasta> Still, learning from a proper book as opposed to a "tutorial" seems to be a nice heuristic.
07:57:10 <byorgey> @remember hexpuem [on learning haskell] the best way is to shove a SD card up your nose with learn yourself a haskell good on it
07:57:10 <lambdabot> Done.
07:57:30 <quicksilver> http://en.wikipedia.org/wiki/Learning_style gives a bland, patchy and incorrect summary, as you'd expect from wikipedia :)
07:57:40 <quicksilver> but, it does at least mention some of the research.
08:01:00 <fasta> I think this is also a good resource http://www.cs.uu.nl/docs/vakken/gont/diktaat.pdf This is a second year course. For the first years there is a similar document in Dutch which is a good introduction to Haskell.
08:01:17 <ReDAeR> It happens i am Dutch ;)
08:01:32 <Zao> We will not hold that against you, much.
08:09:30 <fasta> ReDAeR, btw, I was not wrong about YAHT. It does use an interpreter, and it is one of the first things it explains.
08:12:28 <ReDAeR> fasta: It does in the beginning, but then it tells you to use main
08:13:06 <ReDAeR> Your right, it does use it but i thought you meant always
08:13:54 <ReDAeR> It tells me to use :t 'c' now in the interpreter.. ( New chapter )
08:20:21 <jokerGTA> byorgey can i big you with another question:)
08:22:54 <jokerGTA> guy can i get some help with this function
08:23:09 <jokerGTA> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4530#a4530
08:23:54 <Botje> what's wrong with it?
08:24:13 <Botje> except that it doesn't allow escaped characters :)
08:24:23 <Botje> *escaped double quotes
08:25:36 <jokerGTA> how to run it from command line
08:25:43 <jokerGTA> i am not familiar with the type
08:25:55 <Botje> you'll need to use the parse function as you did for readExpr
08:26:26 <jokerGTA> parseString "Somestring here"
08:27:21 <sioraioc_> So, cabal-install compiles fine, install, but then I get this error when runing cabal update: cabal: user error (Codec.Compression.Zlib: incompatible version)
08:27:31 <sioraioc_> I used the bootstrap script on Snow Leopard
08:27:37 <sioraioc_> with GHC 6.10.4
08:27:41 <sioraioc_> anyone know what to do?
08:28:14 <quicksilver> sioraioc_: that means some part got compiled at 64 bit and some part got compiled at 32 bit.
08:28:23 <quicksilver> sioraioc_: only dcoutts_ can help you now :)
08:28:23 <jokerGTA> i get error when i run that because this function return type is LispValue
08:28:29 <quicksilver> unless that gives you enough of a clue.
08:28:30 <sioraioc_> quicksilver: ah, okay
08:28:37 <sioraioc_> quicksilver: thanks
08:29:00 <quicksilver> jokerGTA: that's just ghci telling you it doesn't know what do to with the result - i.e. it doesn't know how to print it
08:29:10 <jokerGTA> how would i print it
08:29:17 <quicksilver> jokerGTA: if you add deriving (Show) to the end of the data LispVal decl
08:29:24 <quicksilver> that will automatically generate a show function for you
08:29:27 <quicksilver> and then ghci will call that.
08:29:32 <jokerGTA> thanks you silver
08:30:32 <Botje> quicksilver: i put a putStrLn inside the loop function of getDirectoryContents, and it behaves as expected
08:30:41 <jokerGTA> no still error silver
08:30:59 <quicksilver> Botje: that makes it even weirder?
08:31:05 <Botje> quicksilver: uhu.
08:31:06 <jokerGTA> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4530#a4531
08:31:15 <jokerGTA> i added deriving (Sjow)
08:31:24 <quicksilver> Botje: would be worth a trac report IMO
08:31:32 <Botje> jokerGTA: could you add the error you got?
08:32:41 <Botje> quicksilver: i'm not sure what to report and what caused the fd leak :(
08:32:45 <jokerGTA> Couldnt match expected type [Char]->t....against inferred type 'Parser LispVal'......in the expresion: parseString "stringhere"
08:33:02 <Botje> jokerGTA: as i said, you need to use the parse function
08:33:07 <Botje> as you did for readExpr
08:33:34 <jokerGTA> i did //....parseString "stringtoparsehere"
08:33:44 <Botje> parse parseString "-" "this is a test string"
08:34:08 <Botje> that gives you back a Left (error) or a Right (parsed value)
08:34:27 <jokerGTA> oh   ok...tx botje
08:34:37 <ezyang> Hmm... I wonder if Karmic ships with an updated version of GHC
08:34:38 <Botje> and your input string should probably be something like "\"foobie bletch\""
08:34:42 <Botje> ezyang: 6.10.4
08:34:50 <ezyang> Sweet!
08:34:53 <ezyang> Bye bye PPA
08:35:18 <jokerGTA> why
08:36:28 <Zao> ezyang: Don't worry, it'll soon be outdated again.
08:36:49 <ezyang> Zao: :-)
08:36:51 <Zao> Not to mention it's split into the customary Ubuntu plethora of packages.
08:37:31 <ezyang> Maybe I won't swap over then
08:37:35 <benmachine> is debian any better wrt up-to-date packages?
08:37:48 <benmachine> I switched to arch because I got tired of ubuntu always being behind
08:37:51 <Botje> ubuntu is basically debian experimental
08:37:52 <benmachine> but I don't really like pacman
08:37:59 <Botje> but ghc is a notable exception, unfortunately
08:38:11 <benmachine> isn't ubuntu still on python 2.5
08:38:23 <benmachine> or something
08:38:29 <Botje> % python --version
08:38:29 <Botje> Python 2.6.4rc2
08:38:30 <ezyang> Hmm, it looks like someone561 hasn't setup Karmic packages yet
08:38:41 <fasta> Karmic has 6.10.4.
08:38:49 <Botje> and i've seen python 3000 pass by as well
08:39:15 <fasta> Or at least 6.10.something.
08:39:23 <eevar2> and the next release is 6.12? ghc using odd numbers for dev releases?
08:39:36 <benmachine> Botje: hmm, okay
08:39:38 <Zao> eevar2: Yes.
08:39:51 * benmachine tries to work out why his webhost is behind
08:39:53 <fasta> Except that they don't really make dev releases.
08:40:05 <Zao> Just occasional nightlies.
08:40:06 <Botje> they're lazy? or on jaunty.
08:40:12 <Nafai> Botje: There are separate python3 packages in Ubuntu; I think mainly because python 2 and python 3 are incompatible on minor points
08:40:24 <benmachine> did jaunty have 2.5?
08:40:28 <dcoutts> Guest95128: you didn't follow my instructions :-)
08:40:32 <Botje> yeah
08:40:35 <Zao> For great fun, change the system python on a Gentoo system to 3.x
08:40:42 <Zao> Apparently, emerge is written in Python :P
08:40:45 <benmachine> Nafai: python3 is incompatible enough that non-trivial programs won't run on both
08:40:48 <sioraiocht> dcoutts: i did! i did! =)
08:40:54 <sioraiocht> what were the links? I'll check everything again
08:40:58 <dcoutts> sioraiocht: you didn't do the hsc2hs bit
08:41:03 <sioraiocht> dcoutts: ohhhhhh
08:41:08 <Nafai> benmachine: right
08:41:15 <dcoutts> sioraiocht: yesssss ;-)
08:41:22 <ReDAeR> Can anyone explain why ":t head . head" is "[[a]] -> a"?
08:41:26 <ReDAeR> :t head . head
08:41:27 <lambdabot> forall a. [[a]] -> a
08:41:31 <sioraiocht> do you have a link again?
08:41:34 <sioraiocht> <3 -o
08:41:35 <sioraiocht> -p
08:41:38 <sioraiocht> =p
08:42:02 <benmachine> ReDAeR: head takes an element from a list, so taking the head of a head of a list takes an element from an element of the list
08:42:02 <dcoutts> sioraiocht: it's really just the same fix as for the ghc wrapper shell script
08:42:02 <sioraiocht> ReDAeR: because it takes the head of a list
08:42:02 <sioraiocht> and applies head oteh first element
08:42:02 <benmachine> which you can only do if the list is a list of lists
08:42:12 <dcoutts> sioraiocht: but the escape flag to pass things through to the C compiler is different, see hsc2hs --help
08:42:17 <ezyang> > head $ head [[1,2]]
08:42:18 <lambdabot>   1
08:42:29 <ReDAeR> but head element is one so how can you take a head of a head? :o
08:42:39 <benmachine> > head . head $ [[[[[[["hi"]]]]]]] -- this works too
08:42:40 <lambdabot>   [[[[["hi"]]]]]
08:42:56 <benmachine> ReDAeR: if the head element is itself a list
08:42:58 <benmachine> then you're fine
08:43:00 <ezyang> Do note:
08:43:04 <ReDAeR> Ok thank you
08:43:09 <ezyang> >  head . head [1, 2]
08:43:10 <lambdabot>   No instance for (GHC.Show.Show (f a))
08:43:10 <lambdabot>    arising from a use of `M8963464433...
08:43:18 <ezyang> wait, what
08:43:20 <benmachine> heh
08:43:22 <benmachine> :t (.)
08:43:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:43:30 <benmachine> just to confuse you further :)
08:43:30 <ezyang> Oh, oops
08:43:36 <ezyang> > head . head $ [1, 2]
08:43:37 <lambdabot>   No instance for (GHC.Num.Num [a])
08:43:37 <lambdabot>    arising from the literal `1' at <inter...
08:43:53 <ezyang> There we go
08:43:53 <benmachine> yes
08:43:56 <ReDAeR> benmachine: that one was in the book :) (square . f) a , apply f to a and the result is passed to square
08:43:58 <ReDAeR> :o
08:44:21 * benmachine once write an instance for Num [a]
08:44:23 <ReDAeR> But it's clear now
08:44:27 <benmachine> *wrote
08:44:37 <benmachine> althogh half the methods were implemented with error >_>
08:44:41 <ReDAeR> :P
08:44:50 <ReDAeR> It's a feature not a bug ;o
08:45:03 <benmachine> well Num is just a silly class really
08:45:36 <benmachine> there are plenty of things for which + makes sense but abs doesn't
08:46:03 <sioraiocht> dcoutts: just pass the same flags to the C compiler as to GHC?
08:46:18 <ezyang> i,i "typeclass Field"
08:46:20 <dcoutts> sioraiocht: right the -m32 or whatever it is
08:46:25 <sioraiocht> cheers
08:46:48 <dcoutts> sioraiocht: you're not passing them to ghc notice, you're passing them to gcc via ghc
08:46:57 <ReDAeR> benmachine: 4.3.3 The Num Class, coinsedent?
08:47:00 <sioraiocht> dcoutts: aye
08:47:02 <dcoutts> that's the -optc escape for -m32
08:47:17 <benmachine> ReDAeR: so many things are.
08:47:46 <dcoutts> and hsc2hs uses something other than -optc for the same purpose
08:48:33 <quicksilver> Botje: well, just the simplest possible code which runs out of fds is good enough for a bug report.
08:49:48 <benmachine> quicksilver: is this related to the problem that someone was having the other day with taglib?
08:50:29 <benmachine> hmm no never mind
08:50:31 <quicksilver> benmachine: yes.
08:50:35 <benmachine> oh
08:50:40 <quicksilver> although I don't think taglib was actually related to the problem.
08:50:50 <quicksilver> it was just the fact that a naive recursive getDirectoryContents seemed to run out of fds
08:50:53 <quicksilver> which it really shouldn't.
08:51:07 <benmachine> hmm
08:51:38 <leimy> I've run into a bit of a wall
08:51:44 <benmachine> the problem that wehad with copyFile later on turned out to be down to taglib
08:51:48 <leimy> I need to implement a timeout inside a Monad stack
08:51:50 <benmachine> well
08:51:55 <leimy> but timeout only works with IO :-).
08:52:06 <benmachine> not so much taglib as the particular use of taglib
08:52:09 <leimy> however the action I want to timeout on should be of the type of my monad stack
08:52:21 <benmachine> but it reports errors in different ways so we didn't notice we ran out of files until later on
08:52:26 <leimy> I don't know if I can implement timeout based on the IO one ... I don't think it is doable
08:53:01 <benmachine> leimy: sounds pretty strange, what's the monad in question?
08:53:19 <leimy> It's a ReaderT ... StateT .. IO :-)
08:53:42 <leimy> I want to run an action for that whole stack as a timed out action.
08:53:46 <leimy> not just the IO stuff inside
08:53:53 <leimy> that's a bit too fine grained for what I *really* want
08:54:15 <leimy> I looked at the implementation of timeout, but I think it used things I have no access to
08:54:33 <leimy> http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-Timeout.html#timeout
08:54:48 <quicksilver> leimy: well, the ReaderT part isn't a problem.
08:54:51 <quicksilver> leimy: but the StateT is.
08:55:15 <quicksilver> leimy: if you want the timeout handler to have access to the state, then you're going to have to get the "last" result of the state from the main action before it was interrupted.
08:55:17 <leimy> What I really want is Int -> m a -> Maybe (m a)
08:55:27 <quicksilver> in general, of course, that's unsafe.
08:55:37 <leimy> yeah
08:55:41 <quicksilver> but one implementation is to put the state in an MVar
08:55:47 <leimy> but actually in the case of the timeout, I'm killing a thread anyway
08:55:51 <leimy> but I need to do some cleanup first
08:55:51 <quicksilver> which the timeout handler can then see.
08:56:01 <leimy> this Haskell thread has fired off other processes, and it should terminate them first.
08:56:22 * leimy is writing what he'd call a complex concurrent application
08:56:51 <jokerGTA> guys whats difference between "this is a test string"  and "\"this is a test string\""
08:57:02 <leimy> quicksilver: if I could
08:57:06 <leimy> extract
08:57:12 <ezyang> jokerGTA: The latter has quotes inside the string
08:57:34 <jokerGTA> \"
08:57:35 <Botje> jokerGTA: one is a string, the other is a string with embedded quotes
08:57:36 <quicksilver> jokerGTA: what's the difference between "xapplex" and "apple" ? ;)
08:57:39 <leimy> the IO action from my monad stack, and run it... that'd be neat, but unfortunately the IO actions that make up one of MyMonad's actions are threaded throughout, so it seems they're now inseperable.
08:57:55 <benmachine> > "\"foo\"" !! 0
08:57:56 <lambdabot>   '"'
08:58:04 <quicksilver> jokerGTA: the first character of "this is a test string" is 't'. the first character of "\"this is a test string\"" is '"'
08:58:05 <jokerGTA>     you added x to beggining and end
08:58:16 <quicksilver> yes, and you added " to begining and end
08:58:20 <quicksilver> precisely.
08:58:24 <Botje> quicksilver: annoyingly, my test program works fine.
08:58:26 <jokerGTA> why is that needed
08:58:31 <quicksilver> it's not.
08:58:36 <quicksilver> both are valid strings.
08:58:44 <leimy> furthermore I think we should really have a timeout that can work with any monad stack that has IO in it :-)
08:58:51 <quicksilver> but you were writign a parser which expected the first character to be "
08:58:51 <leimy> but I think I don't know how to write the type for that.
08:59:04 <quicksilver> so the suggestion was to make sure the first character is indeed " for a useful test.
08:59:29 <jokerGTA> oh ok
09:00:47 <mreh> can I find the minimum of a list with a fold?
09:01:06 <quicksilver> yes.
09:01:26 <mreh> don't tell me how
09:01:26 <quicksilver> > foldr1 min [5,4,1,3,2]
09:01:27 <lambdabot>   1
09:01:29 <quicksilver> too slow.
09:01:30 <mreh> lol
09:01:30 <quicksilver> :(
09:01:42 <quicksilver> it's not exactly a tricky one though :)
09:01:55 <BONUZ> try reversing a list with a fold :D
09:01:56 <mreh> :t foldrl
09:01:58 <lambdabot> Not in scope: `foldrl'
09:02:00 <mreh> :t foldr1
09:02:01 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:02:10 <BONUZ> after that try implementing group with a foldr and then a foldl with a foldr
09:03:07 <sioraiocht> dcoutts: another fun error!
09:03:16 <sioraiocht> ld: warning: in /Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.4/libgmp.a, file is not of required architecture
09:03:17 <sioraiocht> ld: warning: in dist/build/Codec/Compression/Zlib/Stream_hsc_make.o, file is not of required architecture
09:03:20 <sioraiocht> oops
09:03:23 <sioraiocht> sorry, meant to put that in a pm
09:03:34 <Botje> quicksilver: very weird. I've copied cgizmo's code verbatim and can't get it to error..
09:03:52 <quicksilver> Botje: GHC version?
09:03:53 <jlouis_> sioraiocht: linker bugs are nasty :/
09:03:57 <quicksilver> Botje: (and OS?)
09:03:57 <sioraiocht> lol
09:04:04 <Botje> 6.10.4 on ubuntu karmic
09:04:05 <sioraiocht> I think it's a me bug, not a linker one
09:04:14 <jlouis_> a you bug?
09:04:16 <dcoutts> sioraiocht: you probably need to pass the same flag to the linker
09:04:16 <quicksilver> Botje: thats very odd, I think that's what cgizmo had too.
09:04:22 <sioraiocht> okay
09:04:31 <dcoutts> sioraiocht: your ghc script probably has -optc-m32 -optl-m32 right?
09:04:36 <sioraiocht> yes
09:04:41 <Botje> quicksilver: have to run now
09:04:41 <dcoutts> sioraiocht: if you look at hsch2s --help...
09:04:52 <dcoutts>   -C FLAG          --cflag=FLAG           flag to pass to the C compiler
09:04:52 <sioraiocht> yeah
09:04:52 <dcoutts>   -L FLAG          --lflag=FLAG           flag to pass to the linker
09:04:55 <sioraiocht> np
09:05:15 <sioraiocht> tanks
09:07:09 <mreh> > foldl min [5,4,3,2,1]
09:07:10 <lambdabot>   []->
09:07:11 <lambdabot>    [5,4,3,2,1]
09:07:11 <lambdabot>  [[]]->
09:07:11 <lambdabot>    []
09:07:11 <lambdabot>  [[],[]]->
09:07:12 <lambdabot> [4 @more lines]
09:07:35 <mreh> oh
09:07:38 <mreh> I get it
09:07:56 <mreh> bizzare result there
09:08:02 <benmachine> mreh: lambdabot has a silly Show for functions
09:08:09 <benmachine> :t foldl min [5,4,3,2,1]
09:08:10 <lambdabot> forall t. (Ord t, Num t) => [[t]] -> [t]
09:08:22 <benmachine> ^ you are missing a parameter to foldl
09:08:24 <benmachine> :t foldl
09:08:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:08:28 <mreh> what's that in english
09:08:44 <benmachine> > foldl f z [a, b, c]
09:08:44 <lambdabot>   f (f (f z a) b) c
09:08:47 <mreh> > foldl min 100000000000000000 [5,4,3,2,1]
09:08:48 <lambdabot>   1
09:08:51 <mreh> lol
09:08:54 <benmachine> that's more like it
09:09:06 <benmachine> > foldl min maxBound [5,4,3,2,1]
09:09:07 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:09:07 <lambdabot>    `GHC.Classes.Ord a'
09:09:07 <lambdabot>     ...
09:09:10 <benmachine> bah
09:09:12 <benmachine> > foldl min maxBound [5,4,3,2,1] :: Int
09:09:13 <lambdabot>   1
09:09:24 <benmachine> but that is silly
09:09:25 <MyCatVerbs> > foldl1' min [5,4,3,2,1] :: Int
09:09:26 <lambdabot>   1
09:09:39 <mreh> @src foldl1
09:09:39 <lambdabot> foldl1 f (x:xs) = foldl f x xs
09:09:40 <lambdabot> foldl1 _ []     = undefined
09:09:50 <mreh> simple
09:10:10 <shag> is there something like dons famous darcs-graph for git?
09:10:12 <ezyang> Hmm... I'm running cabal install HaXml, but cabal upgrade keeps claiming that it needs an upgrade
09:10:33 <dcoutts> ezyang: easy solution: don't use upgrade
09:10:34 <ezyang> Is this some kind of major version upgrade?
09:10:45 <ezyang> dcoutts: I use it to tell me which of my packages are out of date
09:11:07 <dcoutts> ezyang: what version have you got and what is it suggesting?
09:11:26 <dcoutts> it's probably that upgrade doesn't pay any attention to the recommended versions
09:11:33 <ezyang> Ah.
09:11:45 <ezyang> 1.13.3 installed, 1.19.7 available
09:12:30 <leimy> OOOh actually nothing in this  modules is specific to anything but GHC, meaning I could re-implement this for my monad stack
09:12:41 <leimy> that'd be a bit more tractable
09:15:13 <dcoutts> ezyang: right, the upgrade is not taking into account that 1.13.x is the recommended version
09:15:48 <ezyang> OK.
09:15:58 <ezyang> Is there a better to way to check out of date packages?
09:28:36 <jmcarthur_work> darcs-graph must not be that famous. i've never heard of it
09:28:57 <jmcarthur_work> oh, i've seen the results though
09:29:08 <jmcarthur_work> i just didn't know the name. nevermind then :)
09:29:38 <jmcarthur_work> shag, github has some similar, but different, graphs
09:30:02 <jmcarthur_work> not available as a library though of course, afaik
09:30:30 <shag> k, thanks
09:39:10 <leimy> hmmm anyone know what options are used to compile Haskell code in GHC with #includes and such?
09:39:11 <leimy> http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-Timeout.html#timeout
09:39:13 <leimy> like that?
09:39:29 <pao> @hpaste
09:39:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:39:36 <jmcarthur_work> leimy, -XCPP?
09:39:44 <leimy> Maybe :-)
09:40:02 <leimy> nope... still bombing on me :-)
09:40:03 <pao> Hi all
09:40:15 <pao> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4532#a4532
09:40:15 <hexpuem> theres a preprocessor that comes with ghc
09:40:17 <hexpuem> forgot the name
09:40:34 <pao> the only way to make it work is to use unsafeInterleaveIO
09:40:36 <pao> right?
09:40:39 <hexpuem> hsc2hs i guess
09:43:05 <leimy> Ugh... can't find Typeable.h :-)
09:43:22 <leimy> I guess I could just expand that macro in my head :-)
09:43:28 <leimy> and flop it in my source
09:44:06 <leimy> ugh...
09:44:20 <leimy> Now it's complaining about that header file that's in base.
09:44:23 <hexpuem> theres an include folder somewhere in the ghc tree
09:44:28 <hexpuem> cant remember where
09:44:32 <Saizan> pao: yeah
09:44:42 <hexpuem> but you need to include it if you want to link against whatever global shit the ghc rt exports
09:44:48 <pao> Saizan: thanks :-)
09:45:12 <leimy> hexpuem: yeah I know where that header is, but it isn't meant for hsc2hs
09:45:17 <leimy> because it won't parse
09:45:17 <jmcarthur_work> pao, alternatively, don't make an infinite list in IO ;)
09:45:40 <pao> jmcarthur_work: yep... that was only a proof of concept ... :-)
09:45:45 <jmcarthur_work> gotcha
09:47:03 <pao> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4532#a4533
09:47:07 <pao> this does the trick
09:48:23 <pao> I need to mimick the behaviour of lazy IO ... if readFile use it (unsafeInterleave) I'll use it too :-)
09:49:12 <Saizan> make sure you understand the risks, especially wrt external resources
09:50:20 <pao> Saizan: can you summarize quickly the key risks?
09:52:13 <Saizan> pao: well, for example with readFile you don't have any guarantees about when the file descriptors will be closed
09:52:35 <pao> I could leak file descriptors
09:53:19 <quicksilver> the key risk is that you take what was a rather nice semantics of IO, and you turn it into a bloody mess which may well cause nasal daemons to fly out of your nose.
09:53:49 <Saizan> and errors will just truncate the content, though one could make it throw a pure exception, which is somewhat better
09:54:09 <Saizan> and that, yeah :)
09:54:12 <copumpkin> whoa, IO and nice semantics in the same sentence? say it ain't so
09:54:29 <copumpkin> :)
09:55:11 <pao> the only other solution would be to use a simplified iteratee... as usual...
09:55:12 <quicksilver> it's all relative, I guess
09:55:29 <quicksilver> "nice semantics" in the sense that the nondeterminism is neated bundled away.
09:55:33 <hackagebot> chp 1.5.0 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
09:55:42 <quicksilver> not really nice in an absolute sense, but nicer than the alternative.
09:55:57 <copumpkin> yeah
09:56:07 <copumpkin> just expressing my knee jerk in text, sorry :)
09:56:14 <Saizan> did someone release a coroutines library recently?
09:56:16 <pao> copumpkin: would elaborate on criticism of the IO semantics?
09:56:33 <copumpkin> Saizan: there was definitely someone talking about it recently
09:56:53 <jmcarthur_work> IO is Haskell's sin bin.
09:57:34 <pao> Saizan: could that (coroutines) be a solution to "my" problem?
09:57:36 <fasta> Saizan, if by recently, you mean a few months ago, then yes.
09:58:09 <Botje> @tell cgizmo If you still have that program that ran out of fds (we discussed it yesterday), can you put the full version somewhere? I'm having difficulty reproducing it.
09:58:10 <lambdabot> Consider it noted.
09:58:37 <pao> the only problems I see with haskell IO are the space/time consequence connected with the fac that is strict... is that correct?
09:58:41 <quicksilver> coroutines can be seen as a special case of iteratee, I think.
09:59:01 <Saizan> pao: i keep thinking that some form of coroutines might be a nicer solution to the problem iteratees are solving, but i've never tried this in practice
09:59:32 <pao> I really find the full blown generic iteratee interface very complex
10:02:07 <Saizan> quicksilver: i was thinking it as routines communicating via session typed channels, which would be the equivalent of iteratee but no longer required to be homogeneous
10:02:26 <Saizan> s/iteratee/iteratee streams/
10:17:43 <quicksilver> Saizan: Yes. I'd be inclined to be cheap and just use Chan for that kind of thing
10:17:43 <quicksilver> Saizan: but what you suggest is much more elegant :)
10:17:53 <quicksilver> Saizan: of course, Reactive is a bit like this in some ways.
10:18:10 <quicksilver> (Events are typed and structures built up using Events are pure)
10:19:20 <copumpkin> I'd very much like to see whatever the problem is with Chan fixed
10:19:24 <copumpkin> but I'm not sure what the problem is yet :)
10:19:27 <copumpkin> I just hear about it a lot
10:19:43 <copumpkin> I'm using Chans in various places and it makes me uneasy
10:19:59 <quicksilver> I didn't think there was a problem with Chan?
10:20:13 <quicksilver> it's only less elegant because the whole point about iteratees is that the iteratee doesn't need to be in IO
10:20:22 <quicksilver> maybe that's not the whole point
10:20:25 <quicksilver> but it's definitely one of the points.
10:20:34 <quicksilver> and that would also be true of Saizan's coroutines
10:20:39 <quicksilver> but with Chan, your'e definitely in IO
10:27:43 <fnord123> how many Chans would be appropriate for a quad core machine?
10:27:55 * mmorrow pimps his "fixed" Chan yet again http://moonpatio.com/repos/vacuum/src/GHC/Vacuum/Q.hs
10:28:03 <quicksilver> as many as you need, fnord123.
10:28:25 <quicksilver> mmorrow: rewritten to have a working non-blocking peek? or?
10:28:57 <mmorrow> quicksilver: it doesn't block on isEmptyChan when there's another thread blocked on a readChan
10:29:05 <quicksilver> right.
10:29:06 <mmorrow> quicksilver: it also has tryTakeChan
10:29:08 <quicksilver> that's roughly what I said
10:29:12 <quicksilver> yeah, I wrote that too :)
10:29:20 <quicksilver> for my Event implementation
10:29:32 <mmorrow> but non-blocking peek it doesn't have currently (although it could be added easily)
10:29:42 <mmorrow> quicksilver: ah nice, in Deus, right?
10:29:42 <quicksilver> Control.Concurrent.Chan "works" as long as you follow its rules
10:30:04 <quicksilver> of course, those rules aren't written down anywhere
10:30:04 <quicksilver> so the fun bit is guessing what they are.
10:30:08 <copumpkin> lol
10:33:38 <mmorrow> quicksilver: the problem is that the read and write MVars point to the *same* MVar when the Chan is empty, so when the reader readChan's it does
10:33:49 <mmorrow> modifyMVar readVar $ \read_end -> do ...
10:33:54 <mmorrow> and isEmptyChan does
10:34:03 <mmorrow> withMVar readVar $ \r -> do
10:34:24 <quicksilver> mmorrow: yes, I found the problem too
10:34:37 <quicksilver> mmorrow: it wasn't my main problem ;) but I found it when I was looking for my problem.
10:34:48 <mmorrow> as far as i can tell, there's no way around that with that implem
10:35:13 <quicksilver> it would be rather nice to demonstrate that problem with a formal proof
10:35:25 <quicksilver> (or a failing proof)
10:36:10 <quicksilver> I've often wondered if you could say interesting things about Chans with separation logic. Some of the early separation logic papers were about critical sections and similar things.
10:36:39 <mmorrow> @google separation logic
10:36:39 <lambdabot> http://en.wikipedia.org/wiki/Separation_logic
10:39:33 <mmorrow> err, so i didn't quite make it to the punchline of that deadlock readChan/isEmptyChan thing actually
10:39:49 <quicksilver> it's ok, I saw it coming
10:39:59 <quicksilver> or is there a sucker punch behind the ppunchline I saw?
10:40:22 <mmorrow> i always get confused when i try to re-remember what exactly's happening, so i want to put it into words
10:41:49 <mmorrow> it's slightly non-obvious, because it's only happening because the two MVars happen to point to the same MVar
10:41:51 <mmorrow> ok
10:42:20 <mmorrow> readChan (Chan readVar _) = do modifyMVar readVar $ \read_end -> do (ChItem val new_read_end) <- *****readMVar read_end****** ..
10:42:23 <mmorrow> and
10:42:53 <mmorrow> isEmptyChan (Chan readVar writeVar) = do withMVar readVar $ \r -> do w <- ****readMVar writeVar***
10:42:55 <mmorrow> but!
10:43:14 <mmorrow> read_end happens to be the *same* as writeVar if the Chan is empty
10:43:34 * mmorrow double checks he's got the ptrs straight
10:43:53 <sproingie> trying to come up with some better wording, wondering if anyone wants to critique: http://www.fishbulb.net/wiki/Haskell_Tutorial/Chapter_02#Just_My_Type
10:44:02 <mmorrow> gah, no
10:44:45 <mmorrow> ok, i'm imagining things again. i did get to the punchline before
10:44:53 <ReDAeR> sproingie: Are you writing your own Haskell tutorial?
10:44:58 <mmorrow> it's simply because they're both taking the readVar
10:45:17 <sproingie> have to tell the reader to use ghci and :t, but i also have to handwave type classes away because i want to focus on polymorphic types first
10:45:26 <mmorrow> iirc there's another problem then where the ptrs aliasing causes problems
10:45:32 <sproingie> ReDAeR: yah, there can never be too many tutorials :p
10:46:29 <ReDAeR> I'm going to read it ;o
10:49:43 <ReDAeR> +1 for the humour
10:50:10 <sproingie> :)
10:51:25 <ReDAeR> sproingie: Haskell does tend to use floats by default.
10:51:30 <ReDAeR> :t 5
10:51:31 <lambdabot> forall t. (Num t) => t
10:51:35 <ReDAeR> Gives me a num :o
10:52:21 <mmorrow> oh, ok i remember now. so the surface problem is that readChan and isEmptyChan both take the read MVar, but the fundamental problem is that the current implem relies on the fact that the read MVar and the write MVar both point to the *same* MVar when the Chan is empty, so checking ptr equality is the only way it can tell
10:52:44 <benmachine> sproingie: saying you can treat an Integer as a Double isn't really true
10:53:01 <mmorrow> the problem with this being that in order to test equality of the MVars at the end of the read and write MVars, you need to take both of them
10:53:21 <benmachine> sproingie: you can treat integer *literals* as doubles but that is only because they have type (Num t) => t
10:53:32 <sproingie> > (1 :: Integer) :: Double
10:53:33 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
10:53:33 <lambdabot>         against inferred ty...
10:53:39 <sproingie> hmmm
10:53:46 <benmachine> :t 1
10:53:47 <sproingie> indeed.  i'll have to fix that
10:53:47 <lambdabot> forall t. (Num t) => t
10:53:49 <ReDAeR> sproingie: Maybe you should add that "1:2:3:[]" = "[1,2,3]" at the List section
10:54:00 <mmorrow> so if someone's already blocked waiting for either the read or write end, you get blocked, and stuck at the end of the queue
10:54:13 <ReDAeR> sproingie: It was just my thought as i just read the chapter about :t in YAHT :P
10:54:29 <sproingie> ReDAeR: i'm planning to do a deep dive into lists in chapter 3
10:55:09 <ReDAeR> Ok :)
10:55:18 <mmorrow> well, actually you can only get blocked for a non-trivial amount of time if you're a reader
10:56:48 <ReDAeR> Tuples collect several values together, but unlike lists, can contain values of any type, and they have a fixed length. - I don't know if newbies will make the connection that [1,"hi"] is invalid then maybe add one example ( you probaly add that one too at chapter 3 :P )
10:57:34 <ezyang> On this subject, I've always wondered why I can't define a list [a] :: Show a => a
10:58:54 <mux> you can, but via type system extensions (existentials)
11:00:25 <sproingie> ReDAeR: yah that's one thing i haven't done is show examples of things that are errors
11:01:05 <sproingie> and the reader will probably mistype or experiment and get one of haskell's scary looking errors :)
11:02:31 <leimy> Today is one of those days where I'm hating the type system
11:02:35 <leimy> big time.
11:04:34 * zygoloid hands leimy an unsafeCoerce and stands well back
11:06:01 <JohnnyL> any of you guys writing websites with Haskell?
11:06:26 <kynky> serverside ?
11:06:41 <benmachine> I wrote a script to generate HTML pages statically
11:06:59 <JohnnyL> kynky yah
11:07:03 <sm> I wrote a web ui for an app
11:07:14 <ezyang> mux: Oh really?
11:07:16 <burp> I'm using happstack
11:07:18 * ezyang goes and tests 
11:07:29 <JohnnyL> what libs are good for it?
11:07:39 <kynky> haxml ?
11:07:39 <burp> JohnnyL: happstack
11:07:45 <sm> I'm using hack on top of happstack
11:08:22 <sm> first with html, then with hsp
11:09:09 <JohnnyL> burp okay
11:14:23 <JohnnyL> looks good!
11:21:24 <burp> and there is #happs for it :)
11:23:49 <mux> ezyang: yeah, it goes something like newtype ShowableList = forall a. Show a => a
11:23:56 <mux> err
11:24:12 <mux> newtype ShowableList = forall a. Show a => [a]
11:24:14 <mux> (I think)
12:04:52 <mightybyte> How do those who subscribe to the haskell-cafe mailing list in digest mode construct replies so they are properly threaded?
12:05:21 <copumpkin> threaded?
12:06:01 <mightybyte> ...so they'll show up at the right point in the tree when viewed in threaded mode in the archives.
12:07:22 <inimino> mightybyte: re-subscribe in real mode?
12:07:30 <inimino> mightybyte: alternately you can do various MUA tricks which are probably a lot more effort
12:08:05 <hamanda> what's the difference between a thread and a spark?
12:08:30 <zygoloid> a spark is a thunk which wants to be evaluated, a thread is a place where evaluation happens
12:09:26 <hamanda> if there are two threads evaluating two sparks, does a third spark only become evaluated when one of the first two ones is done?
12:09:51 <mightybyte> inimino: Hmmm, so it seems there isn't really an easy way to do it?
12:10:10 <dcoutts> hamanda: sparks are evaluated by capabilities when they are otherwise idle
12:10:18 <EddyDean> Is there a faster way to "merge" lists of lists than "foldr1 union xs"? I want a list that is like [[1,2],[3,4]] to become [1,2,3,4]
12:10:28 <dcoutts> hamanda: that's not quite the same as Haskell threads
12:10:29 <hamanda> dcoutts: what's a capability?
12:10:58 <dcoutts> hamanda: essentially you can think of it as a virtual CPU executing Haskell code (a bunch of Haskell threads)
12:11:20 <hamanda> so how are sparks scheduled on capabilities? FIFO?
12:11:21 <kwallmark> EddyDean: try concat
12:11:22 <inimino> mightybyte: not without setting the correct In-Reply-To/References headers in the message you send
12:11:25 <inimino> mightybyte: it's just one of many reasons why digest mode sucks
12:11:34 <mightybyte> Yeah, I see that.
12:11:47 <mightybyte> To bad the haskell mailing lists aren't hosted on Google Groups.
12:12:00 <dcoutts> hamanda: capabilities schedule threads. When a capability is idle it can load balance or steak sparks from other capabilities and make a new thread to evaluate them.
12:12:14 <dcoutts> steak/steal
12:12:54 <hamanda> so '-N 4' means use 4 capabilities?
12:12:59 <EddyDean> kwallmark: Wow. Quite a lot faster... This algoritm used to take half a minute to run, and now runs in less than a second. Thanks
12:13:02 <dcoutts> hamanda: yes, exactly
12:14:06 <hamanda> let's say with -N2 we spark three thunks a `par` b `par` c `par` ... can the evaluation of c be started before a and b are done?
12:15:07 <dcoutts> hamanda: yes since one capability can start on a, the other on b and then c could be done by either after one of a or b finished but before the other one.
12:16:13 <hamanda> ok, I guess I meant to say 'a or b'...
12:16:38 <dcoutts> hamanda: in that case probably not, though I'm not sure there's any such guarantee
12:17:01 <dcoutts> pseq makes sure one thing is done before another
12:17:02 <hamanda> is the scheduling of sparks documented somewhere? isn't this important for writing parallel programs?
12:17:40 <hamanda> how would you use pseq in the example?
12:17:54 <copumpkin> it isn't important, really
12:17:59 <dcoutts> the current implementation uses a per-capability work-stealing queue, so that gives you some info on the order in which things can be chosen
12:17:59 <zygoloid> a `par` b `par` c `pseq` a+b+c
12:18:31 <hgolden> ?tell _Ray_ I'm glad I could help. It takes a while to get your mind around it. Hang in there. The results are worth the effort.
12:18:31 <lambdabot> Consider it noted.
12:18:48 <dcoutts> hamanda: in zygoloid's example, pseq is used to make sure the original 'main' thread is doing something useful
12:18:57 <hamanda> zygoloid: that only says a+b+c must be done after c, no?
12:19:11 <dcoutts> hamanda: yes, exactly
12:19:18 <zygoloid> hamanda: it only says that a and b must be sparked and c must be done before teh sum starts
12:19:41 <zygoloid> does par guarantee that its LHS is sparked before the RHS is evaluated?
12:20:15 <dcoutts> zygoloid: I believe so, (assuming something else didn't force it already)
12:20:43 <hamanda> so what if the same thunk is sparked twice? any risk of doubling work?
12:20:56 <zygoloid> ok, so the example strictly means 'spark a, then spark b, then evaluate c, then compute a+b+c'
12:21:30 <dcoutts> hamanda: I highly recommend you read the paper on this topic
12:21:44 <dcoutts> and probably also the previous one on the SMP runtime
12:22:01 <hamanda> dcoutts: thanks, what are those papers?
12:22:11 <mreh> what's the best monad for random access to a data structure?
12:22:13 <zygoloid> i'm assuming 'par' is right-associative here, admittedly. otherwise we're sparking off (a `par` b)
12:22:31 <mreh> List does random access doesn't it?
12:22:43 <dcoutts> hamanda: http://www.haskell.org/~simonmar/bib/bib.html
12:23:03 <copumpkin> mreh: it does it, but painfully
12:23:04 <dcoutts> zygoloid: infixr 0 par
12:23:21 <copumpkin> mreh: you probably want an array
12:23:23 <dcoutts> zygoloid: same for pseq
12:23:28 <mreh> copumpkin: cool thx
12:24:30 <dcoutts> hamanda: the two most recent papers there
12:24:54 <hamanda> dcoutts: thanks, I will start reading right away
12:25:32 <dcoutts> hamanda: if you're doing both, start with the earlier one
12:30:26 <copumpkin> or simultaneously!
12:30:53 <ReDAeR> You can run Firefox and Irssi simultaneously?! No wai!
12:33:28 <monochrom> Yeah, DOS would not allow it.
12:34:07 <monochrom> But someone wrote a TSR program for DOS in Haskell so you could do it.
12:34:26 <ReDAeR> :O lucky you!
12:37:09 <chaosape> Howdy.  I am looking for advice on how to get this to work the way I would like : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11351#a11351
12:37:57 <ReDAeR> Cowboys :O
12:38:16 <ezyang> chaosape: What does it not do?
12:38:31 <ezyang> ah, in the comments
12:38:46 <chaosape> ezyang: its in the ... yar.
12:40:20 <Baughn> chaosape: If you want a type placeholder, try 'type ObjectFeature = ()', or some such
12:40:31 <ezyang> chaosape: It feels like you want a typeclass. Not sure where, yet
12:41:20 <chaosape> baughn: ack.
12:41:40 <Baughn> chaosape: ..well, I get the impression that you're above my level, though. Anything involving GADTs does that. ;P
12:42:08 <Baughn> (But don't worry, I can go /under/ yours. Low-level code is important too, younglings. ^_^)
12:43:04 <zygoloid> don't worry Baughn, they're not /real/ GADTs ;-)
12:44:00 * cygnus has a feeling whatever is being done here could be done with less abstraction
12:44:28 <ezyang> chaosape: Ok, I think View is constructed incorrectly
12:46:04 <ezyang> I also think the Measurement datatype is incorrect
12:46:43 <chaosape> ezyang: i would love put a type class around view that hide a and b the problem is, in my real code I am using the chart package and I am trying build (Plot a b) from data so I can render it.
12:47:14 <chaosape> ezyang: this is just my toy example to get some ideas
12:47:25 <ReDAeR> Maybe a weird question but in Haskell a string is list of chars, [char] = String, But in Prelude String is seperate Data Type. Why isn't their a + operator for String? Since it's threated like a new data type but still uses ++ as it is a list of chars. ( I know i'm talking a little vague )
12:47:55 <copumpkin> ReDAeR: (+) is a method of Num
12:48:02 <copumpkin> which would mean we'd need to define (*) with it
12:48:12 <copumpkin> and various other unnatural operations on strings
12:48:18 <Lemmih> ReDAeR: It's not a separate type.
12:48:29 <hexpuem> is there any list slicing in the stdlib? like extract 3-5 from [1,2,3,4,5,6]
12:48:34 <ReDAeR> "Char, String, Int, Integer, Float, Double, Rational, IO,
12:48:36 <copumpkin> hexpuem: nope
12:48:40 <cygnus> type String = [Char], i.e., an alias.
12:48:42 <ReDAeR> It's in the list
12:49:21 <ReDAeR> I know it's an alias but look: http://www.zvon.org/other/haskell/Outputprelude/String_d.html
12:49:22 <ezyang> ReDAer: I think you're confusing Haskell with Python, where + is the list concatenation operator
12:49:22 <copumpkin> what about it?
12:49:52 <ReDAeR> On the same website String is in the same list with Ints, chars and other data types
12:49:53 <Lemmih> ReDAeR: That says String is a type synonym.
12:50:01 <ReDAeR> So it looks like they give it a own type
12:50:08 <mauke> ReDAeR: so ask that website then
12:50:14 <ezyang> > drop 3 $ take 2 [1..6]
12:50:15 <lambdabot>   []
12:50:24 <copumpkin> ReDAeR: it's not really a separate type
12:50:26 <ezyang> oops,
12:50:28 <burp> fail =)
12:50:29 <Baughn> hexpuem: Lots
12:50:32 <ReDAeR> So the website is fooling me ;o
12:50:37 <ezyang> > take 2 $ drop 3 [1..6]
12:50:38 <lambdabot>   [4,5]
12:50:39 <cygnus> ReDAeR: it's listed because it's a useful, commonly-used synonym
12:50:45 <Baughn> hexpuem: Well, it depends exactly what you're looking for to extract 3..5
12:51:03 <ezyang> chaosape: I'm not sure I quite understand the type definitions in chart
12:51:10 <Baughn> > filter (\x -> x <= 5 && x >= 3) [1..]
12:51:13 <lambdabot>   mueval-core: Time limit exceeded
12:51:21 <Baughn> ..what, no partial output anymore? ;_;
12:51:24 <ReDAeR> Ok ty. (website fooled me :( )
12:51:47 <mauke> ReDAeR: why? it clearly says:  Definition: type  String  =  [Char]
12:52:02 <ReDAeR> mauke: I know that
12:52:08 <ReDAeR> I know [char] = String
12:52:28 <ReDAeR> But they put it in the same lists as other data types and stuff that i thought it was a seperate data type
12:52:32 <cygnus> ReDAeR: just keep in mind that although it says "type", that declaration creates a synonym, not a "new type."
12:52:47 <ReDAeR> Which maked me wondering why it didn't have it's own uses then like "Hi " + name instead of ++
12:52:57 <ReDAeR> Yes i know that know because of you guys, thank you.
12:53:06 <mauke> ReDAeR: their list of types simply lists types
12:53:07 <hexpuem> baugn: like take (r2 + 1 - r1) $ drop r1 xs
12:53:13 <mauke> FilePath is also a type synonym
12:53:21 <mauke> they don't have to be separate :-)
12:53:39 <cygnus> A synonym for a synonym!
12:53:43 <chaosape> ezyang; hmm ... if could just stack renderables ... http://dockerz.net/software/chart/doc/html/Graphics-Rendering-Chart-Renderable.html#v%3AtoRenderable
12:54:57 <ReDAeR> cygnus: Make up a name and you have made a new word :O
12:55:10 <ReDAeR> Maybe you can get your own Wikipedia page :o Wouldn't that be cool huh :)
12:59:14 <mwc> is there any work on classifying a set of strings using neural networks? I'm having trouble coming up with the right keywords to make a search productive.
12:59:29 <ezyang> What kind of classification?
12:59:44 <ezyang> (We're learning about neural nets right now: I could ask my prof!)
12:59:44 <mwc> ezyang: dictionary key lookup normalization
12:59:52 <copumpkin> neural networks seem overrated :P
12:59:55 <ezyang> mmm
12:59:58 <mahogny> neural networks... huge and messy topic
13:00:13 <mwc> copumpkin: they're ammenable to training, which is what I need
13:00:20 <copumpkin> so are many other models
13:00:30 <copumpkin> that's kind of the point of ML :P
13:01:06 <ReDAeR> :t (\(x :: Int) -> x*x)
13:01:07 <lambdabot> Int -> Int
13:01:08 <mahogny> classification is so huge that we probably dare to say "yes" but the answer "how" won't fit on a line
13:01:19 <mwc> the idea is that I have a bunch of user provided headers which describe data, but I can't guarantee the users name things consistently. So I want to get a bunch of training data and then generate a classifier.
13:01:45 <mwc> one person might call it annual interest rate, another interest per annum, etc.
13:02:14 <mahogny> ask google how they do it :)
13:02:28 <mwc> I can has trade secrets?
13:02:39 <mahogny> just hack their ftp.
13:03:05 <mwc> I think I'll broaden my search to machine learning... when all you have is a hammer, everything looks like a nail
13:03:31 <burp> and n-gram matching is not enough I guess?
13:04:29 <ReDAeR> mwc: So you basicly want that your program can guess what the user means if he describes something?
13:04:30 <mwc> burp: hmm, looks promising. let me see
13:04:40 <mwc> ReDAeR: yeah, so it sounds like a machine learning problem to me
13:04:49 <ReDAeR> It is
13:04:53 <drhodes> mwc: there's a minesweeper project in hackage that uses a neural net (I think) to get better with each generation, fwiw
13:04:56 <burp> basically you just compare the number of same n-grams (typically like 3)
13:05:11 <ReDAeR> drhodes: You mean a computer that plays minesweeper or what?
13:05:29 <ezyang> Neural nets are a bunch of math
13:05:35 <monochrom> When you have a brain, everything looks intuitive.
13:05:47 <mwc> I know that the N strings I get label N different things. I just need to figure out how to map them
13:06:08 <drhodes> ReDAeR: it generates some minefields and then plays them,... haven't looked at the code, so don't know much more about it.
13:06:13 <ReDAeR> mwc: You know about supervised learning?
13:06:38 <mwc> ReDAeR: right
13:06:38 <ReDAeR> drhodes: That's too simple too make really
13:06:39 <ReDAeR> mwc: right in ofcourse or wtf is it? :P
13:06:43 <chaosape> Is there a way to make a sort of map where the values are hetreogenous and the keys are the type signatures of the value so that when I try to get a particular value out of the map it only gives me the values conformant to that type signature? I apologize in advance for that being a confusing sentence.
13:07:00 <mwc> you let your ANN classify it, then backpropagate to fix the errors
13:07:05 <mwc> wash, rinse, repeat
13:07:11 <ReDAeR> Indeed
13:07:23 <ezyang> chaosape: Even if the values are heterogenous they have to share a type/typeclass
13:08:44 <adept> chaosape: what is a possible application for that?
13:08:47 <ezyang> So you want to design a data type that will give you that.
13:08:52 <ReDAeR> What you maybe can do is something like giving the program 5 senteces of what a table is and that the PC stores the words that are similar ( or numbers ) Massive, Big, 4 Legs, etc
13:09:10 <mwc> Actually, I think this ngram approach looks promising, especially with some sort of bayesian inference
13:09:22 <ReDAeR> Try it out then ;)
13:09:50 <mwc> yeah, I'll look into it monday
13:10:20 <chaosape> adept: i want to have a set of measurements that i can plot and compare ... but the measurements are generated from pluggable operators ... and I am trying to avoid using typeable and cast ... since that seems to be what i always do and i have been told its wrong ;^)
13:10:57 <ReDAeR> ANN Can be really tricky
13:12:12 <mwc> it would have been straight forward to get started with an ANN, but for the varying length of input
13:12:48 <drhodes> mwc: this might be interesting http://www.numenta.com/, somewhat open source, they have special licensing.  it's got a python interface though
13:13:21 <drhodes> "Numenta is creating a new type of computing technology modeled on the structure and operation of the neocortex. The technology is called Hierarchical Temporal Memory, yatta yatta"
13:13:34 <burp> kiss ;-)
13:14:16 <mwc> their description makes me instantly skeptical
13:14:26 <copumpkin> wow
13:14:29 <burp> keep it simple :>
13:14:47 <hexpuem> how come no software is modeled on the operation of the stomach
13:15:14 <mwc> where do you think we got the JVM from?
13:15:32 <hexpuem> moar burgar!
13:15:40 <ReDAeR> HI CAN I HAS HAMBURGAZ?
13:15:46 <copumpkin> no can haz
13:15:54 <ReDAeR> O NOES
13:15:56 <ReDAeR> .. lolcode
13:16:09 * mwc begins to suspect the overlap between reddit and #haskell is not entirely a good thing.
13:16:45 <copumpkin> mwc: ceiling cat iz watchin u, no can haz bad thots
13:16:50 <ReDAeR> :P
13:17:38 <ReDAeR> PLZ OPEN FILE "LOLCATS.TXT"?
13:17:50 <ReDAeR> Maybe their is a ceiligcat in it :O
13:17:54 <copumpkin> NOES
13:18:00 <mwc> instance Monad Lolcat where...
13:18:08 <copumpkin> plz2no uze monad
13:18:14 <mwc> hey, somebody made a BASIC monad.
13:18:25 <ReDAeR> Xmonad ;o
13:18:49 <mauke> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
13:19:03 <Badger> I wonder if that window manager actually does have instance Monad X where.
13:19:18 <mwc> Badger: actually, it does
13:19:22 <Badger> :)
13:21:01 <mwc> Badger: http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t%3AX
13:21:13 <mwc> it's basically just IO with some X specific state data
13:21:53 <ReDAeR> http://en.wikipedia.org/wiki/Whitespace_%28programming_language%29 O.O
13:22:50 <mauke> my whitespace tools: http://mauke.ath.cx/stuff/whitespace/
13:24:31 <ReDAeR> :')
13:31:21 <Vanadium> aaah what is the voodoo that gtk2hs uses to generate bindings
13:31:26 <ReDAeR> I'm reading about type-basics now and YAHT is defining a Maybe data-type, they give a example of the head function, that if it gets a empty list it can do nothing so it needs to return 'Nothing' (Which was defined in the Maybe data type it could be Just x or Nothing) (2sec il give you a pastebin)
13:31:37 <dcoutts> Vanadium: c2hs
13:31:41 <ReDAeR> My question why define a maybe data type?
13:31:54 <dcoutts> Vanadium: or do you mean what voodoo is used to generate the .chs files?
13:31:54 <copumpkin> ReDAeR: why not?
13:31:58 <mauke> ReDAeR: what else would you do?
13:32:07 <copumpkin> ReDAeR: how would you announce that you have failed?
13:32:08 <CalJohn> because you can guarantee that a function will not crash the program, ReDAeR
13:32:30 <mwc> ReDAeR: it lets you systematically handle computations that could fail (see the Maybe monad.) If every function had its own failure type, it would be a mess.
13:32:42 <Vanadium> dcoutts: Possibly! I am confused by the .pp ending but I am not familiar with c2hs itself either.
13:32:48 <mwc> think: head :: [a] -> Head a ; data Head a = Head a | EmptyList
13:32:57 <dcoutts> Vanadium: oh, well that's cpp
13:33:01 <Vanadium> Oh.
13:33:02 <dcoutts> Vanadium: cpp followed by c2hs
13:33:08 <Vanadium> Then I shall be reading up on c2hs
13:33:19 <dcoutts> Vanadium: the .chs.pp are partly generated by a custom code gen
13:33:35 <ReDAeR> http://pastebin.com/d4287655
13:33:53 <mauke> ReDAeR: that doesn't compile
13:34:02 <mauke> and you can't "return null or something"
13:34:15 <ReDAeR> That's why it's in the comment :P
13:34:25 <CalJohn> ReDAeR: returning null is a bad idea because functions that call head would not expect to have to have to deal with null
13:34:37 <copumpkin> ReDAeR: the Maybe is effectively allowing you to make a null
13:34:55 <CalJohn> ReDAeR: think of all the times you have had to deal with NullPointerException in java.  it's because people commonly forget that a function could return an Object, or null
13:34:56 <copumpkin> ReDAeR: but unlike other languages, you announce that you might return null, and otherwise are not allowed to return it
13:35:11 <mauke> data Nullable a = Null | New a
13:35:15 <mauke> huhu
13:35:19 <Vanadium> To begin with I was confused because gdk events seem to be connected to using the System.Glib.Signals.on thing and everything else seemed to have its own onFoo/afterFoo functions and I was trying to figure out the reason for that and then I got very confused
13:35:20 <mwc> which is isomorphic to maybe
13:35:22 <copumpkin> lol
13:35:26 <ReDAeR> Ok ty
13:35:59 <ReDAeR> It's the same as Java just a little different.. Here you check if you get returned Nothing while in Java you would check if the list was empty for you even call the function.. but ok, ty:)
13:36:04 <mwc> ReDAeR: there's a systematic way of chaining computations that can fail, using monad and do notation. If one step fails, the whole thing is Nothing
13:36:38 <ReDAeR> The 'sense' is just different, i still get WTF why do that if you also can do this ( it's just because i'm used to doing it that way )
13:36:48 <ReDAeR> mwc: is that a good thing or not?
13:36:57 <CalJohn> ReDAeR: you'd hope you'd check that in java, but there is no requirement to do so.  i'm sure you know that most people don't, and in fact, because exceptions are so amazingly slow, frequently you have little choice in java but to return null
13:37:06 <mwc> ReDAeR: a good thing
13:39:40 <ReDAeR> CalJohn: Indeed most people just say, oh i don't care to check for anything if the list is empty and i get an error it will just throw an exception, while indeed exception are often slow.
13:40:58 <ReDAeR> I think i understand now why people say Haskell makes you a better programmer :p
13:41:17 <CalJohn> even worse, there is no way to tell from a method signature that a method will return null for some inputs
13:41:20 <CalJohn> :)
13:41:21 <chaosape> parametric return types blur the lines in my head between what can be checked statically and what has to be checked at runtime.  Does that make any sense?
13:41:36 <mreh> :t loop
13:41:37 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
13:41:47 <ezyang> yes.
13:41:59 <ezyang> An expressive type system means you can shuffle more and more checks to compile time
13:42:25 <mreh> but it's all done statically
13:42:40 <mreh> there's nothing dynamic about it
13:42:52 <copumpkin> loop is fun
13:43:00 <chaosape> i constantly find my self want to make return types of type class parametric and than end up realizing that the type checker can't figure out what is going on at compile time.
13:43:01 <mreh> i just saw it in some code
13:43:02 <ReDAeR> CalJohn: Indeed that's why you always need to check for null in Java/C#. What i see often in C# is that people convert values and then get an error because the value is empty, etc instead of checking before converting or using 'as' keyword..
13:43:23 <mreh> :t repeat
13:43:24 <lambdabot> forall a. a -> [a]
13:43:27 <sproingie> there's an article out there somewhere about how Haskell detected an infinite loop
13:43:33 <mreh> @src repeat
13:43:33 <lambdabot> repeat x = xs where xs = x : xs
13:43:38 <sproingie> with the type system that is
13:44:04 <mreh> neat definition
13:44:21 <mreh> makes my brane go sideways
13:44:28 <sproingie> @src fix
13:44:29 <lambdabot> fix f = let x = f x in x
13:44:31 <FunctorSalad_> why can you use infix syntax for classes in class declarations and contexts, but not in instance decls?
13:44:55 <FunctorSalad_> class a :+: b   -- ok
13:45:03 <FunctorSalad_> foo :: forall a b. (a :+: b) => a -> b   -- ok
13:45:17 <FunctorSalad_> instance Int :+: Int -- error
13:47:36 <CalJohn> maybe it is related to why you can't use guards in lambdas
13:47:40 <mreh> how can i repeated apply a function?
13:47:48 <mreh> to itself
13:48:06 <mreh> fold on a list?
13:48:29 <hexpuem> @src fix
13:48:29 <lambdabot> fix f = let x = f x in x
13:48:41 <mreh> oh
13:48:50 <mauke> :t iterate
13:48:51 <lambdabot> forall a. (a -> a) -> a -> [a]
13:49:06 <mreh> i can't even get my head round fix
13:49:17 <mreh> i get it
13:49:39 <mreh> iterate ([ ] ++)
13:49:43 <mreh> > iterate ([ ] ++)
13:49:49 <lambdabot>   mueval: ExitFailure 1
13:50:04 <mauke> > iterate (* 2) 1
13:50:07 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
13:50:33 <mreh> > iterate ([ ] ++) [ ]
13:50:36 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
13:50:48 <mauke> > iterate id []
13:50:49 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
13:51:08 <mreh> good thinking
13:51:18 <mreh> there is literally always a better way of doing something in haskell
13:51:26 <mreh> when I think of it, that is
13:51:27 <mauke> > repeat []
13:51:28 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
13:52:33 <JohnnyL> how do you @src from the interpreter?
13:52:42 <mreh> JohnnyL, you cant
13:52:51 <mreh> it's a feature installed in this channel
13:53:14 <mreh> use HackageDB if you want to look at sources
13:53:21 <hackagebot> dbus-core 0.5 - Low-level D-Bus protocol implementation (JohnMillikin)
13:53:54 <mreh> the "sources" are just something someone wrote in a text file
13:54:02 <mreh> so don't rely on them too much
13:54:12 <JohnnyL> ok
13:54:23 <hackagebot> dbus-client 0.1 - D-Bus client libraries (JohnMillikin)
13:54:49 <mreh> what is hackagebot talking about
13:54:54 <mauke> uploads
13:55:13 <sm> @hackage dbus-client
13:55:13 <lambdabot> http://hackage.haskell.org/package/dbus-client
13:55:59 <mauke> sm: is hackagebot's source online?
13:56:05 <mreh> > foldr (\_ _ -> []) [] [1..10]
13:56:06 <lambdabot>   []
13:56:14 <sm> yes indeed.. @hackage rss2irc
13:56:21 <sm> @hackage rss2irc
13:56:21 <lambdabot> http://hackage.haskell.org/package/rss2irc
13:56:34 <mreh> > foldr (\_ a -> [] : a) [] [1..10]
13:56:35 <lambdabot>   [[],[],[],[],[],[],[],[],[],[]]
13:56:37 <mreh> woot
13:56:43 <mauke> I think I'm going to patch it
13:57:30 <sm> great, how so ?
13:57:39 <mauke> make it talk in CTCP ACTIONs
13:57:57 <mauke> it's what GumbyPAN does over in #perl, and it's 100% more awesome
13:58:18 <sm> that's the first bot I've heard of that uses them.. and some folks don't see them at all
13:58:27 <sm> but patch welcome, specially if it's an option
13:58:51 * sm watches #perl
13:58:51 <mreh> > take 5 $ foldr (\_ a -> [] : a) [] [1..]
13:58:51 <mauke> some folks don't see them?!
13:58:52 <lambdabot>   [[],[],[],[],[]]
13:59:05 <sm> yeah, depending on client
13:59:16 <mauke> those clients are plain broken
13:59:20 <gwern> 'When I spoke to him, I happened to mention that I had sworn an oath to find and kill the man who made the Source Safe API. Turns out, he made that part of it himself.'
13:59:25 <mauke> actions are just privmsgs
13:59:33 <mauke> there's no reason not to display them
14:00:00 <mreh> could you program everything with a fold?
14:00:56 <Cale> mreh: Depends on what you mean by 'everything'. In some sense, you can write any recursive program as a fold over a list which constructs a function that you apply more parameters to
14:00:56 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:00:59 <sm> I might be confusing with notices.. some thing that was recommended for bots to use
14:01:01 <Cale> mreh: but, you can get fix from foldr and an appropriately infinite list :)
14:01:03 <mauke> yeah, those are NOTICEs
14:01:06 <mauke> I just want actions :-)
14:01:36 <sm> oh, it's like /me
14:01:47 <mtnviewmark> anyone here recently install Haskell Platform on a Mac?
14:03:32 <mreh> > let mymap f xs = foldr (\y ys -> f y : ys) [] xs in mymap (*2) [1..10]
14:03:34 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:03:39 <mreh> awesome
14:04:28 <nlogax> ? down http://ircbrowse.com/
14:04:40 <nlogax> sorry, wrong channel
14:10:01 <sproingie> just curious, is there any literal syntax to curry subtraction on the right?
14:10:37 <twanvl> ?src subtract
14:10:37 <lambdabot> subtract x y = y - x
14:10:40 <ezyang> so... basically an infix version of flip -?
14:10:42 <ezyang> aha
14:10:49 <sproingie> ohh silly me flip
14:11:10 <ezyang> > 4 `subtract` 2
14:11:11 <lambdabot>   -2
14:11:15 <ezyang> lol
14:11:30 <twanvl> > (subtract 2) 4
14:11:31 <lambdabot>   2
14:11:37 <gwern> > 2 `(-)` 2
14:11:38 <lambdabot>   <no location info>: parse error on input `('
14:11:46 <sproingie> was throwing together examples and i wondered if i was missing some obvious disambiguation
14:11:46 <gwern> still broken, alas
14:11:58 <gwern> > 2 `-` 2
14:11:59 <lambdabot>   <no location info>: parse error on input `-'
14:12:36 <twanvl> gwern: I am glad that doesn't work
14:12:44 <mreh> 4 - 2 = -2?!
14:12:47 <mtnviewmark> ?src add
14:12:48 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:12:56 <mtnviewmark> so much for symtetry
14:14:53 <maltem> The motivation for subtract is that (- x) as a section does not work
14:15:21 <mreh> because it's unary minus?
14:15:22 <maltem> because this is parsed as a unary minus, i.e. negation
14:15:31 <mreh> beat you
14:15:37 <maltem> heh
14:15:52 <mreh> I know what you're going to type next
14:16:08 <mreh> i'll show you, but he'll deny it
14:16:15 <mreh> so there's no point in me doing it anymore
14:16:28 <mreh> kangaroo!
14:16:36 <ReDAeR> Rabbit!
14:16:46 <mreh> i thought I could catch him off guard
14:17:14 <dancor> WHNF == HNF || is-a-function   ?
14:17:40 <ReDAeR> Uuuh wtf?
14:17:57 <mreh> dancor are you typing miranda?
14:18:06 <mreh> || was the single line comment in miranda
14:18:25 <Saizan_> i think that was an "or"
14:18:27 <dancor> is it true that: something is in weak head normal form iff it is in head normal form or it is a function
14:18:54 <mreh> oh, you were expressing your ideas in propositional logic
14:19:15 <mreh> negate your theorem and construct a tableau
14:19:16 <Saizan_> i'd say "it is a lambda abstraction" rather than "is a function"
14:19:54 <Saizan_> "(\x y -> ..) foo" is a function, but it's not in WHNF
14:20:23 <mauke> dammit, someone upload something to hackage
14:20:29 <mauke> I need to test my changes :-)
14:20:55 <mreh> it's like getting a new doorbell
14:20:58 <mreh> order some pizza
14:21:35 <mauke> pay with snakes
14:23:01 <mreh> absolutely insane
14:24:31 <ReDAeR> can i has pizza?
14:24:45 <dancor> Saizan_: so WHNF means HNF or you are a top-level lambda like (\ x -> .. foo)
14:24:52 <dancor> ?
14:25:03 <desp> What would be a good way to generate sound using Haskell on OS X?
14:25:34 <desp> There's a lot of packages on Hackage.
14:25:37 <dancor> desp: like mp3 playback or music?
14:25:41 <dancor> how bad is haskore these days
14:25:48 <mreh> dancor: it's good
14:25:51 <desp> Like, experimenting with synthesis.
14:26:09 <maltem> dancor, correct. the "weak" refers to not normalizing under a lambda
14:26:11 <desp> So low-level.
14:26:14 <mreh> dancor: I generate random music with it to practice my jazz improv.
14:26:16 <dancor> mreh: doesn't it still have to go thru a temp file and use timidty or something
14:26:22 <mreh> the interface is like driving a rocket ship
14:26:37 <mreh> not "random" music
14:27:01 <mreh> dancor: for what? playback?
14:27:32 <mreh> there is a live playback, I've seen it work, never tried it myself
14:27:49 <mreh> it's built on CSound, whatever that is
14:27:59 <mreh> there
14:28:02 <dancor> it's some synth lang
14:28:20 <mreh> there's no midi -> pdf/image yet though
14:28:28 <mreh> you have to write a shell script for that
14:28:37 <dancor> the way i use haskore right now seems to magically leave .mid files lying around
14:28:48 <dancor> i think bc subprocessing still needs some work in haskell
14:28:56 <dancor> using subprocesses
14:29:00 <Saizan_> dancor: that looks more accurate
14:29:06 <dancor> and having them die correctly
14:29:11 <mreh> I don't know what that is
14:29:39 <dancor> mreh: i go thru timidity right now http://github.com/dancor/mull/blob/master/src/Mus.hs
14:29:45 <dancor> and sometimes Bad Things happen
14:30:05 <mreh> I think if they made a good way of engraving the data structures, it might overtake things like authoring tools
14:31:38 <mreh> is there an authoring tool for FRAN?
14:31:48 <mreh> or any rumblings of such a thing?
14:31:52 <dancor> libraries i need: (1) wrapper using mvar to kill subprocesses correctly (2) non-numeric multidimensional data struct with good slicing
14:32:28 <mreh> dancor: what does this thing do?
14:32:46 <dancor> mreh: that link?  it tests me on interval recognition
14:32:54 <mreh> oh nice
14:33:05 <dancor> and using haskore/timidity to play two-note files is too much overhead
14:33:22 <dancor> there's like a 1s delay on top of the actual playing
14:33:37 <dancor> maybe if i set up a timdity daemon that would help
14:33:49 <mreh> that kind of thing already exists, how long has it taken you?
14:34:25 <dancor> mreh: what kind of thing?  mull is a thing i made that i put lots of different kinds of self-tests in
14:34:25 <JohnnyL> does Haskell use combinatory logic in it's engine?
14:34:52 <dancor> later in that file is guitar fret-to-note testing
14:35:09 <Cale> JohnnyL: well, an implementation of it could
14:35:23 <mreh> dancor: you type in the fret number?
14:35:24 <Cale> JohnnyL: But none of the existing implementations do directly as far as I'm aware.
14:35:52 <Cale> JohnnyL: Oh, except possibly for the Reduceron, which is (partly) a hardware implementation
14:36:08 <dancor> idk how much time i've spent on it.  it's sporadic and i'm not very good at haskell yet.  http://github.com/dancor/mull/commits/master
14:36:16 <gio123> Cale: hi
14:36:18 <JohnnyL> Cale oh, interesting! :)
14:36:23 <Cale> hi
14:36:51 <gio123> Cale: pm?
14:40:00 <hamanda> can ghc make 32-bit binaries on a 64-bit linux?
14:40:12 <hamanda> I'm using -fvia-C
14:40:40 <mreh> I need a suitable class to be able to average a collection of objects, so Num seemed like a good choice
14:40:57 <mauke> not really, Num can't divide
14:41:03 <mreh> ah
14:41:46 <mreh> Real then
14:41:58 <mauke> how about Fractional?
14:42:28 <mreh> that's the one
14:43:19 <maltem> Shame again on the numeric type classes!
14:43:48 <mreh> why aren't mathematical operations say defined for tuples of the numeric classes?
14:44:20 <mreh> i suppose tuples aren't generic are they
14:44:23 <dibblego> mreh, such as?
14:44:40 <maltem> mreh, there's no canoncical way to define e.g. multiplication on tuples
14:44:41 <mreh> (1, 1) / (2, 3) = (1/2,1/3)
14:44:48 <twanvl> (Num a, Num b) => Num (a,b)
14:44:57 <dibblego> curry (*)
14:45:01 <dibblego> uncurry (*)
14:45:19 <mauke> mreh: that doesn't look like it's compatible with complex numbers
14:45:35 <gio123> Cale: hi
14:45:38 <mreh> twanvl: that's a generic tuple I suppose
14:45:48 <mreh> mauke: it doesn
14:45:53 <jmcarthur_work> i think elementwise multiplication is acceptable, really
14:46:01 <twanvl> mreh: if that instance were defined then your example would work
14:46:04 <mreh> mauke: it doesn't need to be, I want to do maths with vectors
14:46:10 <jmcarthur_work> we have instance (Monoid a, Monoid b) => Monoid (a, b), after all
14:46:12 <twanvl> it is the only sensible definition
14:46:19 <mreh> and matrices
14:46:23 <mauke> mreh: well, define it then :-)
14:46:48 <mreh> can I define an arbitary length vector class?
14:46:59 <jmcarthur_work> yes
14:47:11 <jmcarthur_work> mreh, with statically known length?
14:47:14 <maltem> jmcarthur, with monoids you don't ask for a 0 element for multiplication
14:47:19 <mreh> yup#
14:47:30 <mreh> jmcarthur_work:
14:47:34 <jmcarthur_work> maltem, a 1 element?
14:47:39 <twanvl> (0,0) = 0 -- for tuples
14:47:55 <maltem> yea. but I think what I said wasn't important :/
14:48:03 <jmcarthur_work> mreh, see the Vec package for one way to do it
14:48:10 <jmcarthur_work> mreh, there are a few
14:48:38 * maltem just heard a talk by Lenstra about finite fields
14:49:20 <tromp_> sounds like a finite talk
14:49:48 <tromp_> which Lenstra was that?
14:49:54 <mreh> jmcarthur_work: Data.Vector?
14:50:21 <maltem> Hendrik
14:51:36 <maltem> wasn't actually as interesting as I had hoped for
14:52:13 <ddarius> maltem: Didn't have enough Galois connections for your tastes?
14:52:16 <dancor> maybe if the fields have been a little larger
14:53:35 <hamanda> what does -cpp do?
14:54:24 <maltem> ddarius, he basically presented one corollary ;)
14:54:57 <maltem> hamanda, C preprocessor?
14:57:21 <ksf> If someone's in need of a project, a smarter sed would be great. that is, something that can mess with a file without parsing the whole stuff, but won't choke easily on nesting, etc, that is, search the whole input for possible parses and then do a replacement or whatever.
14:58:53 <JohnnyL> import os  os.system('grep -r '^*$')
15:11:34 <ksf> let's say it's a sed script with 8 substitution rules that actually does exacty what I want, except if stuff is nested.
15:12:08 <ksf> ...which is no problem as it's a one-off thing anyway, and I can let myself be guided by compile errors fixing the few borked occurences.
15:13:11 <nvoorhies> so you're basically saying a sed that does CFGs instead of just regular expressions
15:13:14 <ksf> or maybe my regex-foo is rusted... still, it'd be nice to have such ad-hoc abilities in some proper parser.
15:14:26 <ksf> well sed is turing-complete.
15:14:26 <ksf> ...at least if you repeatedly hit enter.
15:14:28 <ksf> there's a sokoban written in it.
15:16:09 <Botje> have you looked at perl6s regexes?
15:16:09 <ksf> "CFG"?
15:16:12 <ksf> ah context free grammars.
15:16:13 <ksf> nope I was thinking parser combinators, and they parse everything.
15:16:27 <ksf> can perl express "don't overlap those two matches"?
15:16:38 <mauke> ... maybe?
15:16:39 <ksf> ...without editing the whole ruleset, that is.
15:17:51 <mauke> I don't have a mental model of what you're trying to do, or I could try to cast it into perl
15:18:20 <benmachine> I'd quite like a tool for constructing parsers a bit like parsec
15:18:25 <benmachine> in syntax
15:18:42 <benmachine> I tried to set something up with runhaskell or ghc -e but the amount of setup tends to be too large
15:19:17 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11354#a11354
15:19:39 <ksf> that's tranlating hsc files to chs files for a hacked-up c2hs.
15:20:43 <mauke> ok, what's the problem with that?
15:21:30 <ksf> c <- peekElemOff ({#ptr termios_s.c_cc) p) (#const VTIME#}
15:21:49 <mauke> hello misnesting
15:22:36 <mauke> no matches found
15:23:04 <ksf> erm yes that's already output.
15:28:28 * mauke blames .*, moves on
15:28:31 <lpjhjdh> so why with TH can you only splice expressions?
15:28:54 <ksf> you can also splice declarations
15:29:17 <ksf> or was it reify?
15:29:19 <mmorrow> lpjhjdh: you can splice in types in 6.12
15:29:23 <ksf> I'm constantly confusing both.
15:29:52 <lpjhjdh> ah, types is what I need, looks like an update will help :)
15:29:53 <lpjhjdh> thanks
15:30:14 <mmorrow> i don't recall the details exactly (just remembered this actually), but the places where you can splice is somewhat expanded in 6.12
15:30:26 <mmorrow> lpjhjdh: oh, 6.12 isn't out yet
15:30:42 <mmorrow> lpjhjdh: well, you can get the current GHC HEAD if you want
15:30:52 <mmorrow> err, actually
15:30:59 <mmorrow> is there an RC out or something?
15:30:59 <lpjhjdh> mmorrow: as long as it's not completely broken
15:31:06 <ksf> there's an rc out.
15:31:11 <mmorrow> lpjhjdh: well, you'll have to compile HEAD
15:31:16 <mmorrow> ksf: ah nice
15:31:21 <mmorrow> lpjhjdh: woot
15:31:27 <ksf> ...which compiles, but comes without cabal-install
15:31:43 <mmorrow> cry me a river, sissies!
15:31:46 <mmorrow> :)
15:32:25 <lpjhjdh> is there any work on adding GADT's to TH?
15:32:35 <lpjhjdh> I saw some stuff back during the release of 6.6
15:32:36 <mmorrow> ksf: get your shell-script-horrifying-hackery shoes on!
15:33:30 <mmorrow> lpjhjdh: it would be really nice, but not yet. TH has type/data families, kinds, and UNPACK/INLINE/SPECIALIZE pragmas added in 6.12 though
15:33:53 <ksf> er no. the next step is parsing a lists of #defines I get from gcc -E -fdirectives-only into a map and hacking up c2hs to resolve them.
15:33:54 <mmorrow> lpjhjdh: i think GADTs are the next logical thing that would/should be added though
15:34:20 <ksf> ...which I'm going to leave till tomorrow.
15:34:31 <lpjhjdh> mmorrow: awesome, thanks
15:34:57 <mmorrow> then after GADTs... TH in TH!
15:35:27 <desp> I'm looking for a portable way to push bits out of the speaker, i.e. generate sound.
15:36:13 <mmorrow> desp: if you don't consider writing to /dev/{dsp,audio,whatever} portable, then i think there is no portable way
15:36:15 <desp> I browsed through the packages on Hackage, but they have tons of dependencies and the descriptions are incredibly cryptic.
15:36:35 <dancor> desp: i would try haskore for synth stuff
15:36:43 <dancor>  / music stuff
15:37:08 <gwern> desp: portable? on linux?
15:37:09 <desp> mmorrow: I would consider SDL to be reasonably portable.  I only mostly care about OS X, though.
15:37:09 <ksf> there's openAL and jack, which run on everything.
15:37:14 <gwern> bluck bluck bluck!
15:37:26 <desp> dancor: but haskore seems to be a kitchen-sink-included music notation system.
15:37:41 <Twey> ksf: Jack doesn't work so nicely with OSS :-\
15:37:48 <ksf> who uses oss, anyway?
15:37:56 <ray> cough
15:37:57 <Twey> People who like good-quality sound :þ
15:37:59 <desp> ddarius: are you around?  I noticed you played with Karplus-Strong back in 2007
15:38:01 <dancor> desp: maybe instead of portable you meant lightweight
15:38:03 <ray> people who like sound
15:38:13 <Twey> And… everybody on non-Linux Unices
15:38:15 <ray> as opposed to a glorious silence
15:38:18 <Twey> Heh
15:38:24 <gwern> Twey: such things exist?
15:38:24 <Twey> Oh, I got a nice stuttering noise
15:38:27 <desp> dancor: I did mention simply pushing bits out of the speaker :)
15:38:29 <ReDAeR> I think il buy a Haskell book too read some stuff in bed, etc ( somtimes books > ebooks ) I'm an 'experienced' programmer without functional skills, any recommendations? I thought of Real World Haskell
15:38:33 * ksf lets alsa pipe his output to spdif and completely ignores the rest of the sound card
15:38:38 <ksf> *cough* "sound card"
15:38:43 <ksf> on-board ensoniq.
15:38:50 <ray> yeah, i pipe my sound to xpdf too sometimes
15:38:51 * copumpkin pulls out his sound blaster
15:38:55 <ray> it's not as great as you might think
15:40:54 <Twey> ReDAeR: Yep, sounds like RWH would suit you
15:44:25 <mmorrow> here's my supar leet(tm) music system, using only foreign import "ioctl" to control the pc spkr .. main plays the (probably wrong) parts of `i got rhythm' i could remember  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4534#a4534
15:44:33 <mmorrow> weee!
15:45:49 <mmorrow> it's actually surprisingly addictive/amusing
15:46:02 <desp> That's awesome.  Wish my mac had a pc speaker.
15:46:08 <mtnviewmark> that's both wack and wonderful
15:46:09 <mreh> does anyone know how Reals are compared?
15:46:18 <mreh> is it a bit level comparison?
15:46:19 <mtnviewmark> bit-by-bit?
15:46:22 <mmorrow> desp: aww, no pc spkr really?
15:46:33 <copumpkin> mreh: you mean IEEE floats?
15:46:49 <desp> mmorrow: nope :(
15:46:52 <mreh> copumpkin: the Double type, that's a float isn't it
15:46:56 <copumpkin> yep
15:47:14 <mreh> what is it? 64bit mantissa and exponent?
15:47:18 <desp> mmorrow: the code runs, but does nothing.
15:47:24 <copumpkin> sign, significand, exponent
15:47:30 <copumpkin> maybe not in that order
15:47:33 <copumpkin> mantissa is a deprecated name
15:48:07 <mreh> my computer science professor in high school is deprecated
15:48:23 <mmorrow> desp: sucky. i can't figure out how to get it to make any sound under X, and have to ctrl-alt-F2 to a real tty to get it to work annoyingly
15:49:47 <desp> I remember some early DOS virus using the PC speaker to play back voice samples.
15:49:49 <mreh> > 2,5 == 2.5000000001
15:49:50 <lambdabot>   <no location info>: parse error on input `,'
15:49:57 <mreh> > 2.5 == 2.5000000001
15:49:57 <lambdabot>   False
15:50:03 <mreh> > 2.5 == 2.5000000000000000000000000000000000001
15:50:04 <lambdabot>   True
15:50:23 <mreh> > 2.5 == 2.5000000000000000000000000000000000001 :: Double
15:50:24 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
15:50:24 <lambdabot>         against inferred ty...
15:50:33 <mreh> > 2.5 == (2.5000000000000000000000000000000000001 :: Double)
15:50:34 <lambdabot>   True
15:50:36 <mauke> mmorrow: so you could play http://mauke.ath.cx/stuff/c/zel.c ? :-)
15:50:57 <mmorrow> mauke: haha, probably
15:51:16 <mreh> two floating point numbers may be the same, but have different representations...
15:51:17 <copumpkin> mauke: I love the root of your website
15:51:22 * mmorrow wgets
15:51:29 <mauke> copumpkin: why?
15:51:35 <copumpkin> mauke: it laughs
15:51:46 <mauke> what browser are you using?
15:51:53 <copumpkin> safari
15:52:16 <mauke> hmm
15:52:20 <copumpkin> ?
15:52:25 <mmorrow> mauke: omfg, zelda!
15:53:16 <Twey> Hahahaha
15:53:59 <mauke> copumpkin: and it doesn't redirect you?
15:54:12 <Twey> mauke: What did the blacklisted authors do to offend you?  :þ
15:54:13 <copumpkin> mauke: it did the first time, to wikileaks, but then I tried again and it didn't redirect
15:54:18 <Twey> Doesn't redirect me
15:54:21 <mauke> interesting
15:54:43 <mauke> well, you can look at the page source for some possibly intertaining stuff
15:54:48 <mauke> s/inter/enter/
15:55:05 <copumpkin> mauke: what's with backslashes in your URLs?
15:55:20 <Twey> Heh, I was just about to mention that
15:55:41 <Twey> mauke: A redirect in an iframe doesn't redirect the top page
15:55:50 <mauke> well, it's supposed to load f\f.html but some browsers apparently get f/f.html instead
15:56:04 <mauke> Twey: top.location = s;
15:56:12 <Twey> Hm
15:56:36 <copumpkin> http://mauke.ath.cx/f\f.html
15:56:37 <copumpkin> nice
15:56:53 <Twey> mauke: You should escape it
15:56:59 <Twey> http://mauke.ath.cx/f%5Cf.html
15:57:01 <mauke> why?
15:57:12 <Twey> So that browsers treat it correctly :þ
15:57:28 <mauke> it works just as planned
15:57:32 <Vanadium> mauke: hahahaha
15:57:54 <Twey> Hahaha
15:57:58 <Twey> Ohh.
15:58:01 <Twey> *Those* browsers.
15:58:43 <benmachine> mauke: <3 zel.c
15:58:45 <Twey> http://mauke.ath.cx/stuff/lisp/add.lisp — oh my.
15:58:51 <benmachine> is it a little out of tune though?
15:59:07 <Vanadium> It does not play here at all :<
15:59:12 <mauke> Twey: the (original) perl version is better
16:00:05 <Twey> No, doesn't work here either *sad*
16:00:27 <benmachine> it only worked for me when I ran it in tty2
16:00:41 <Twey> Hum
16:00:43 <mauke> firefox-2.0.0.1? one of you needs to upgrade
16:00:50 <Twey> Heh
16:00:53 <Twey> Not I
16:01:30 <Twey> Haha!
16:01:34 <Twey> benmachine: That works.
16:01:38 <Twey> Awesome. :þ
16:01:53 * benmachine puts it in a while loop
16:05:29 <desp> It seems to me the SDL package available on Hackage is rather incomplete.
16:06:11 * benmachine kills while loop before insanity sets in
16:06:50 <mmorrow> mauke: haskell zelda http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4534#a4535
16:07:30 <Twey> :-D
16:07:37 <copumpkin> haskellda?
16:07:42 <mauke> excellent
16:07:45 <Twey> desp: What's it missing?
16:07:52 <mauke> the C was generated by a perl script, btw
16:08:25 <desp> Twey: I don't see any way to do audio with it :)
16:08:32 <mmorrow> mauke: oh? what was the perl script using as input?
16:08:58 <mauke> some hacked together music notation
16:09:05 <Twey> desp: I can't even find it now :þ
16:09:50 <desp> I found another unmaintained SDL binding on sourceforge.
16:09:52 <Twey> Hm
16:10:26 <desp> Twey: both bindings are listed in http://www.libsdl.org/languages.php
16:11:05 <Twey> desp: You can use SDL-mixer
16:12:51 <desp> Oh, thanks.  Didn't notice that.  I blame my ludicrously slow "3G" internet.
16:27:08 <hamanda> what's the difference between +RTS -RTS and +RTS -N1 -RTS?
16:30:24 <sjanssen> hamanda: nothing in usual circumstances
16:30:32 <Beelsebob> hamanda: the second one specifies to use one OS thread
16:30:41 <Beelsebob> the first one leaves the number of OS threads as it’s default
16:30:56 <hamanda> for me -N1 is much slower
16:30:59 <hamanda> what's the default?
16:31:31 <sjanssen> one is usually the default, I think
16:32:32 <heatsink> I don't see anything about exceptions in the FFI report.
16:32:46 <heatsink> What happens if I call into Haskell from C, and an exception is thrown?
16:50:57 <smorg> heatsink: impossible. :P
16:52:38 <heatsink> smorg, you undestimate my programming skills :p
16:52:57 <heatsink> *underestimate
17:00:25 <FunctorSalad> oO (misunderestimate)
17:05:11 <SubStack> > take 10 $ map (sum . zipWith (*) (iterate (*2) 1) . map (toInteger . fromEnum . (== '1')) . reverse) $ tail $ inits $ concat $ concatMap (flip replicateM $ "01") [1..]
17:05:12 <lambdabot>   [0,1,2,4,8,17,35,70,141,283]
17:05:38 <SubStack> this sequence fascinates me
17:06:44 <heatsink> > zipWith (-) (drop 1 it) (iterate(*2) 1)
17:06:45 <lambdabot>   Not in scope: `it'
17:07:07 <__marius__> in ghci, when i do a :load for one module, it imports all names unqualified. but specifying multiple modules names in the :load causes subsequent modules to be imported qualified. any idea how to turn thi soff?
17:07:49 <heatsink> > zipWith (-) (drop 1 $ take 15 $ map (sum . zipWith (*) (iterate (*2) 1) . map (toInteger . fromEnum . (== '1')) . reverse) $ tail $ inits $ concat $ concatMap (flip replicateM $ "01") [1..]) (iterate (*2) 1)
17:07:50 <lambdabot>   [0,0,0,0,1,3,6,13,27,54,108,216,432,864]
17:09:16 <heatsink> __marius__, you can use :m +Foo to unqualify
17:09:23 <heatsink> like loading a module
17:11:12 <geoaxis> hello people, i am new to haskell, which IDE would you recommend (i speak vim when doing sysadmin stuff and usually use eclipse when doing Java, dont mind learning new things and really would like to do things the haskell way)
17:11:51 <Axman6> geoaxis: a lot of people use vim. no IDE is needed for haskell
17:12:11 <Axman6> a text editor with syntax highlighting is almost always enough
17:12:12 <SubStack> people use IDEs for haskell?
17:12:36 <Twey> Most people use emacs for Haskell, I think
17:13:06 <Twey> Dependence on IDEs to make the language sane instead of just fixing the language itself is a peculiarly Java-ish concept
17:13:47 * benmachine vims
17:14:02 * lantti gedits
17:14:49 <hexpuem> i never understood what was so great about visual studio
17:14:53 <hexpuem> everyone seems to have a hardon for it
17:15:09 <heatsink> Hmm.  gedit is a nifty pun.
17:15:16 <geoaxis> Twey, well there are some small things like instant reference ot libraries
17:15:34 <geoaxis> you can put some time and collect all kinds of stuff into your emacs or vim modes
17:15:43 <Cale> I can't stand big IDEs
17:15:56 <hexpuem> what do they even provide?
17:15:58 <hexpuem> i dont get it haha
17:16:01 <Twey> geoaxis: Such things are available as small editor plugins without requiring a fully-fledged IDE.
17:16:39 <Twey> (or you can just have the reference open in a separate buffer, which works just as well, but takes much less effort to do)
17:17:18 <hexpuem> i guess class member auto complete popups are good for OOP bullshit
17:17:30 <geoaxis> Twey, well it depends how many buffers you really have to open, perhaps in functioanl programming solutions you dont need so much tangled code to begin with
17:18:42 <geoaxis> nexpuem: calling OOP bull shit is xenophobic, OOP, imperative, logical, functional, they are all paradigms which solve problems
17:18:44 <Twey> That's also often true, though I do always find myself looking up Data.Map.
17:18:58 <benmachine> xenophobic but accurate?
17:19:16 <Twey> geoaxis: None of those terms have a solid definition.
17:19:43 <Twey> And OOP may solve some problems, but it introduces a lot more.
17:19:49 <Twey> See http://okmij.org/ftp/Computation/Subtyping/
17:19:58 <geoaxis> Twey, well you need to read the literature then, perhaps from creators of Haskell
17:20:04 <geoaxis> to get the definitions
17:20:15 <Twey> geoaxis: No — they *have* no definitions.
17:20:32 <Twey> There is no solid boundary between an ‘imperative’ language and a ‘functional’ language
17:21:15 <geoaxis> Twey, but is there a difference between the two paradigms atleast
17:21:25 <Twey> Nor between an ‘OOP’ language and a ‘functional’ language (in fact, OOP is not even a whole paradigm in itself, by any way of looking at it: it's just a method of structuring other sorts of code)
17:21:26 <geoaxis> or are they so confusing that you consider them the same
17:21:58 <geoaxis> Twey, do you even know any thing about side effects?
17:22:04 <Twey> geoaxis: There isn't.  ‘Functional programming’ as exemplified in, say, Haskell, is just an extension of concepts already considered good practice in, say, Java.
17:22:21 <geoaxis> concepts? in Java
17:22:29 <hexpuem> we need universal tolerance for inferior technology
17:22:43 <hexpuem> time to break out the ipx network
17:22:47 <ddarius> Twey: I would not say that.  Some things Haskell emphasizes are good practice, other things are bad practice.
17:23:02 <benmachine> ddarius: any examples of the latter?
17:23:04 <Twey> ddarius: Such as?
17:23:07 <p_l> hexpuem: ipx? I raise you a DECnet
17:23:09 <ddarius> Pattern matching.
17:23:22 <Twey> Java considers pattern matching bad practice?  o.@
17:23:30 <Twey> It doesn't even have pattern matching, does it?
17:23:45 <benmachine> does anyone consider pattern matching bad practice?
17:23:46 <ddarius> Nope.  But switches/ifs are bad practice in OOP.
17:24:23 <geoaxis> Twey, do you know what side effects are?
17:24:30 <geoaxis> if you dont mind me asking
17:24:33 <benmachine> doesn't ifs encompass more or less every control flow structure ever
17:24:33 <Twey> ddarius: Eh what?  They're necessary.  The if is the primary control flow structure in Java.
17:24:48 <Twey> And I'd call pattern matching an extension of overloading, too.
17:24:49 <hexpuem> is that where you shave your sideburns so it fades in
17:24:51 <benmachine> (given that while is basically just if and for is basically just while)
17:24:55 <Twey> geoaxis: Er, yes.
17:24:58 <ddarius> Twey: It's not necessary for a OOP language to have if.  Self doesn't have if.
17:25:19 <benmachine> how do you like
17:25:21 <geoaxis> why do you say then there is no sofference between functional and OOP paradigm then
17:25:21 <benmachine> do things
17:25:22 <ddarius> In OO languages, the way decisions are supposed to be made is through dynamic dispatch.
17:25:28 <Twey> ddarius: What does it have instead?
17:25:46 <geoaxis> no difference*
17:25:46 <ddarius> Twey: It uses dynamic dispatch.
17:25:47 <Twey> But… isn't that in *favour* of pattern matching?
17:25:47 <benmachine> oh
17:26:02 <dolio> b ifTrue: [ true-block ] else: [ false-block ]
17:26:12 <Twey> geoaxis: OOP languages need not be side-effectful.  Functional languages need not be pure.
17:26:37 <geoaxis> Twey, yes this is where you start mixing them your self
17:26:38 <Twey> There's an implementation of ‘OO’ in Haskell, which is pure.  F# is an example of an impure ‘functional’ language.
17:26:57 <geoaxis> if you want to compare two paradigms, compare them in their pure form,
17:27:09 <Twey> geoaxis: But there *is* no pure form of either.
17:27:42 <geoaxis> Twey, well thats a matter of perspective
17:27:47 <Twey> ddarius: I would argue that pattern-matching is an extension of dynamic dispatch
17:27:59 <ddarius> Twey: It is not.  Pattern matching is not open, dynamic dispatch is.
17:28:11 <geoaxis> i mean if you have a ideal functioanl paradigm in your head, go write a paper, produce a better paradigm
17:28:16 <ddarius> And indeed, this is exactly why it would be considered bad practice in OO languages.
17:28:17 <arquebus> Twey- objects in OOP are just a place holder for data because it lacks the ability to pass functions as data types, data and code are the same in functional languages
17:28:28 <geoaxis> its like saying that there is no ideal meter or ideal second
17:28:34 <geoaxis> they are all relative
17:28:45 <Twey> geoaxis: ‽
17:29:24 <ddarius> I can, in Self even ignoring it's dynamic typing, make my own "subclass of Boolean" that handled the ifTrue: message differently and pass that in anywhere where any other "Boolean" was expected.
17:29:26 <geoaxis> meter, seconds, kg (measurements in physics(
17:29:26 <Twey> geoaxis: There can be no pure OOP language because OOP is not a programming-language paradigm, for starters.  It's just a method of structuring other programs.
17:29:32 <__marius__> heatsink: it doesn't let you do that if it finds it in your file hierarchy.. :-/
17:29:36 <Twey> I know what they are.  Your analogy just makes no sense.
17:29:45 <__marius__> "module `Foo.Bar' is not loaded"
17:29:48 <Twey> The functional is not a unit of measurement.  :þ
17:29:52 <geoaxis> Twey, what is paradigm then
17:30:09 <Twey> (interesting idea, though: we could say that Haskell is five functionals)
17:30:14 <geoaxis> isn't it a method of thinking and structuring your programs?
17:30:15 <heatsink> __marius__, you have to load it first
17:30:16 <hexpuem> add 4 functionals to your unit in 3 weeks
17:30:29 <benmachine> λλλλλ
17:31:01 <Twey> geoaxis: Sure — but it isn't sufficient to *only* structure a program as OO.  OO requires one to embed some other sort of structure within it to actually do things.
17:31:01 <heatsink> λλλλλ mushroom mushroom
17:31:24 <Twey> For example, Java embeds an ‘imperative’ language inside its objects.
17:31:24 <Axman6> mushroom MMMUUUSSSHHRROOOOOOMMM!
17:31:43 <SubStack> the kingdom of nouns!
17:31:45 <geoaxis> Twey now you are mixing paradigms with languages
17:31:53 <ddarius> Twey: What other "OO" languages are you familiar with?
17:32:18 <Twey> ddarius: Lua, CLOS, C++ (significantly)
17:32:29 <ddarius> Twey: I'd recommend you look at Self.
17:32:33 <Twey> geoaxis: No, I was just giving an example.
17:32:36 <Twey> ddarius: Will doo.
17:32:38 <Twey> do**
17:32:58 <__marius__> heatsink: ooh! there we go. thanks! that did it
17:33:05 <heatsink> np
17:33:25 <geoaxis> well if you really want to look how OOP should be i think you may want to look at small talk
17:33:46 <Twey> geoaxis: It is not possible to implement a Turing-complete language based only on OO.  It's like attempting to use a filing cabinet to store your data.
17:33:58 * ddarius thinks Self is a better Smalltalk than Smalltalk.  Unfortunately, it's not easy to use Self.
17:34:09 <geoaxis> Twey, no one said any thing about Turing complete
17:34:17 <ddarius> Newspeak actually looks like a better Smalltalk than Smalltalk too and is somewhat more "Smalltalky" than Self.
17:34:23 <geoaxis> Twey, we are only talking about paradigms
17:34:24 <Twey> The filing cabinet can be used to *organise* the data, but the data still has to be written on something, in something — paper, disks, English, Latin
17:34:31 <geoaxis> and how they affect thinking and structure
17:34:43 <hexpuem> dont forget klingon
17:34:54 <Twey> geoaxis: But there cannot be a ‘pure OO language’ because it wouldn't do anything useful
17:35:03 <Twey> It wouldn't be a programming language
17:35:13 <Vanadium> I wish people stopped considering papers actual and appropriate documentation, because as far as I can tell 'paper' is code for "not putting in hyperlinks, never updating after '97" :|
17:35:19 <Twey> Vanadium: Haha
17:35:23 <geoaxis> Twey, you keep bringing the word language over and over
17:35:32 <geoaxis> i thought we were discussing paradigms
17:35:40 <ddarius> Vanadium: If nothing ever changes after '97, what do you need updates for?
17:35:41 <Vanadium> pure OO language <-> UML?
17:35:42 <Twey> geoaxis: We were discussing programming-language paradigms.
17:35:46 <geoaxis> no
17:35:48 <Twey> Vanadium: Perhaps, yes :þ
17:35:53 <geoaxis> programming paradigms
17:36:09 <geoaxis> languages just help us implement those, they can mix and match them
17:36:10 <phr> @hoogle [a->Bool]->a->Bool
17:36:11 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
17:36:11 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
17:36:11 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:36:21 <geoaxis> there are many multi paradigm languages these days
17:36:22 <Vanadium> ddarius: Cases were the behaviour described in the paper is plain different from what the code actually does, ten years later? :|
17:36:38 <geoaxis> and thats where things are really headed
17:36:50 <Vanadium> i mean sure there is brief reference documentation in many cases but that does not really cut it
17:36:55 <geoaxis> atleast i am lead to believe
17:37:03 <Axman6> :t sqeuence [undefined :: a -> Bool]
17:37:04 <lambdabot> Not in scope: `sqeuence'
17:37:05 <arquebus> everything about OOP is contrived a canned solution that does not scale, hence patterns for containing a mess. inheritence is a sloppy solution for passing functions and data, encapsulation is overly restricted modulatiry, polymorphism makes up for weak function passing syntax
17:37:10 <Axman6> :t sequence [undefined :: a -> Bool]
17:37:11 <lambdabot> forall a. a -> [Bool]
17:38:35 <Twey> geoaxis: I'm going to go and learn Self.  In turn, I recommend as reading to you http://apocalisp.wordpress.com/2009/04/27/a-critique-of-impure-reason/ and http://apocalisp.wordpress.com/2008/12/04/no-such-thing/ .  Maybe we can have a more meaningful discussion about this afterwards.  :þ
17:38:39 <phr> @pl (let anyp ps x = any [p x | p <- ps])
17:38:39 <lambdabot> (line 1, column 37):
17:38:39 <lambdabot> unexpected ")"
17:38:39 <lambdabot> expecting variable, "(", operator, ";" or "in"
17:38:54 <phr> @pl (let anyp ps x = any [p x | p <- ps] in anyp)
17:38:54 <lambdabot> (any .) . flip flip [] . ((:) .) . flip ((<-) . (| p) . p)
17:39:09 <geoaxis> Twey, yeah sure, i am more interested in learning haskell for now
17:39:55 <geoaxis> cause i know nothing of functional programming, but sit on a ship load of OOP code in production systems
17:40:23 <geoaxis> and my interest in languages is still new, thanks to a course in programming paradigms
17:41:30 <geoaxis> i think that there are two ways of looking at paradigms, one from research point of view, how an ideal paradigm should be, and one from practical view, what works in the data centre (i am biased towards the latter)
17:42:31 <Twey> A programming paradigm is a way to write programs, which means that there must be (a possibility of) actual useful languages that implement it.
17:42:53 <hexpuem> lets make flight control systems in brainfuck
17:43:01 <Twey> It doesn't make sense to study ‘a paradigm’ on its own.  It's like talking about ‘redness’ without having actual red things.
17:43:04 <Twey> hexpuem: Are you Younder?
17:43:20 <hexpuem> whos that?
17:43:22 <hexpuem> lets say yes
17:43:28 <Twey> Thought so
17:43:36 <hexpuem> nah i dont know who that is
17:43:36 <hexpuem> haha
17:43:43 <hexpuem> is he on the ban list
17:43:52 <geoaxis> Twey, i agree, this is why we study  OOP, functional , imperative, logic etc in comparison
17:44:10 <Cale> hexpuem: I don't think he is yet, but he was getting close :)
17:45:24 <Twey> arquebus: (by the way, I don't consider data encapsulation to be overly-restricted modularity, but instead a way of limiting side effects)
17:45:36 <Vanadium> The best thing I can say about OOP is that there is plenty of OOP code with useful documentation
17:45:50 <Cale> (he was being mean to some beginners which is something we don't like here :)
17:46:28 <arquebus> Twey- you have to create objects on a heap just to encapsulate something, everything about OOP is a cheap hack
17:46:48 <Twey> arquebus: (instead of having referential transparency at the function level [a function called with the same arguments always yields the same value] it tries to have it at the object level [an object with a specific set of methods called in a specific order will always leave you with an equivalent object])
17:49:39 <arquebus> Twey- OOP as used by Smalltalk does not need objects, just classes and method passing. Because smalltalk was developed by Alan Kay when he visited MIT's AI lab and saw their work on lisp machines
17:50:56 <Twey> Interesting
17:51:24 <Axman6> arquebus: s/method/message?
17:52:24 <p_l> Axman6: kind of
17:52:34 <geoaxis> do we have a bot in this #
17:52:37 <arquebus> Axman6: yes, Im not up on Smalltalk terminology, but I recommend to anyone to check out Squeak Smalltalk, the implementation of Smalltalk developed by Alan Kay himself while he worked at Apple, there are a lot of free books for it
17:52:40 <Axman6> @bot
17:52:40 <lunabot>  :o
17:52:40 <lambdabot> :)
17:53:21 <geoaxis> ~help
17:53:24 <heatsink> > fromRational (toRational 1 :: Float) :: Double
17:53:25 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
17:53:25 <lambdabot>         against inferred typ...
17:53:33 <heatsink> > fromRational (toRational (1 :: Float)) :: Double
17:53:34 <lambdabot>   1.0
18:00:56 <br1> how do I write an "anonymous existential haskell"? Must I define a type?
18:02:48 <dolio> You mean a type like (exists a. P[a])?
18:02:58 <br1> yeah
18:03:08 <dolio> Yes, in GHC you need to define a type for that, unfortunately.
18:03:27 <br1> ok. thanks!
18:07:10 <br1> dolio: can I declare the type with a smaller scope, say inside the where of a top level function?
18:07:22 <dolio> Nope.
18:08:38 <br1> ok
18:09:09 <FunctorSalad> br1: "cps" encoding
18:09:11 <spink> Hi, I want to use some of the *STUArray functions like thawSTUArray,runSTU etc.. and I cannot find the correct module. I am getting the "Not in scope message" for the ones I use. My header is : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4536#a4536
18:09:41 <FunctorSalad> br1: (forall a. P[a] -> r) -> r
18:09:53 <FunctorSalad> is equivalent to exists a. P[a]
18:10:12 <FunctorSalad> but don't count on type inference once you start with that ;)
18:10:24 <dolio> Needs a forall r.
18:10:33 <FunctorSalad> implicit toplevel forall ;)
18:10:50 <br1> There's no type inference for existentials already, is there?
18:10:57 <FunctorSalad> but yes, if it occurs in a negative position in turn you need "forall r"
18:11:07 <drhodes> area :: Meter -> Meter -> Meter'2; force :: Meter -> Acceleration -> Newton     -- has anyone seen an implementation for SI Units typed like this ?
18:11:32 <dolio> Yeah, but it "((forall a. P[a] -> r) -> r) -> t" is not the same as "(exists a. P[a]) -> t".
18:18:48 <ddarius> > 556.3 * 1024 * 1024
18:18:49 <lambdabot>   5.833228288e8
18:24:41 <nolrai_FG> So any one know how to get GHC to output its STG code to a file?
18:25:39 <nolrai_FG> Is any one here, theres usaly mor conversation.
18:25:52 <dolio> -ddump-something, if it exists, probably.
18:25:58 <skorpan> try #ghc if all else fails
18:26:40 <dolio> -ddump-simpl dumps the core language (I think), which is pretty similar to STG.
18:26:40 <nolrai_FG> dolio: Thanks!
18:26:40 <Cale> --ddump-stg exists
18:26:52 <dolio> Although it has explicit type passing and such, so it's higher level than STG.
18:27:18 <nolrai_FG> Cale: double thanks!
18:27:22 <kmc> hello haskellians
18:27:25 <skorpan> what's STG?
18:27:35 <Cale> Spineless Tagless G-machine
18:27:40 <kmc> the finest of machines
18:27:46 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
18:28:40 <nolrai_FG> hmm, my ghc is saying unrecognised flags: --ddump-stg.
18:28:44 <Cale> hmm
18:28:52 <Cale> Well, I only looked at the man page
18:29:13 <nolrai_FG> I hope it hasn't ben take out or something.
18:29:20 <ddarius> kmc: Actually "Spineless" and "Tagless" isn't very accurate anymore.
18:29:51 <kmc> i'm not too clear on what "spineless" means
18:29:59 <kmc> something about the lack of an explicit stack of activation frames
18:30:02 <kmc> but there is a stack of update frames
18:30:03 <Cale> The Respined Retagged Spineless Tagless G-machine
18:31:56 <Twey> Hahaha
18:34:33 <nolrai_FG> never mind must have missspelled it or something
18:35:27 <nolrai_FG> oh it only takes one "-" wierd.
18:35:48 <dolio> It's the -d flag with argument dump-stg
18:36:06 <dolio> Although GHC violates that convention other places.
18:36:14 <SamB_XP_> like -ffi ?
18:36:24 <dolio> Like -prof
18:36:48 <dolio> And -auto-all
18:36:49 <SamB_XP_> -ffi being an alias for -fffi ;-P
18:37:41 <dolio> Yeah. I'd let that one slide. :)
18:39:02 <nolrai_FG> whats fffi?
18:42:15 <Axman6> it's a -f argument
18:42:26 <Axman6> like -fglasgow-exts
18:43:38 <copumpkin> is -f argument like f-algebra?
18:43:46 <FunctorSalad> ^^
18:45:13 <nolrai_FG> hmm I assume the "*bitmap*"s dont have anything to do with pictures. Any idea what it is?
18:45:18 <kmc> "f*** algebra"
18:45:22 <kmc> the sentiment of many a 9th grader
18:45:44 <kmc> nolrai_FG, bitmap where?
18:45:59 <nolrai_FG> in the stg code.
18:45:59 <kmc> iirc there are bitmaps to indicate which closure fields are heap pointers
18:46:13 <kmc> in the case where it doesn't put all the pointers together for some reason
18:47:02 <nolrai_FG> Ah, so (0, *bitmap*) is some sort of location indacator?
18:47:51 <copumpkin> newToHaskell: you're a haskell expert, right? I have a question for you on zygohistomorphic prepromorphisms
18:48:07 <nolrai_FG> hmm I might not care about them then.
18:48:12 <luite> is there a way to change the default instance for Show Double, for debugging? (I want to decrease the precision to make results more readable)
18:48:25 <copumpkin> luite: don't think so
18:48:29 <copumpkin> luite: newtype?
18:48:45 <aavogt> use printf or showffloat
18:48:54 <aavogt> @hoogle showf
18:48:54 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
18:48:54 <lambdabot> Data.Fixed showFixed :: HasResolution a => Bool -> Fixed a -> String
18:48:54 <lambdabot> Numeric showFloat :: RealFloat a => a -> ShowS
18:49:23 <nolrai_FG> is zygohistomorphic a real word cause I could use some things shaped like embrionic historys.
18:49:45 <luite> aavogt: I have used printf a few times, but it doesn't help much for the 'deriving Show' data types and lists
18:49:59 <copumpkin> nolrai_FG: it's a bit of a haskell/recursion theory recurring "joke"
18:50:42 <nolrai_FG> us programers seem to like "joke"s
18:51:30 <ray> zygohistomorphic is a perfectly valid pile of prefixes
18:54:47 <nolrai_FG> zygo means something in recusion theory doesnt it?
18:55:46 <copumpkin> they all do
18:56:36 <nolrai_FG> whats histo mean?
18:57:58 <copumpkin> gives you access to what you've already done, I think
18:58:21 <Badger> hurrah
18:58:30 <Badger> copumpkin is now 100% more spooky
18:59:30 <dancor> zygomorphic is just a heady way of saying "bilaterally symmetric" right?
19:00:16 <Alpounet> copumpkin, nolrai_FG, histo e.g scan right ?
19:00:19 <Alpounet> @type scan
19:00:19 <lambdabot> Not in scope: `scan'
19:00:20 <dancor> it saves characters in some settings at the expense of readability and reworkability to other scenarios; it's perfect haskell
19:00:22 <Alpounet> @type scanl
19:00:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:00:45 <Alpounet> > scanl (+) 0 [1..10]
19:00:46 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
19:00:53 <Alpounet> yeah.
19:01:06 <Alpounet> s/histo/histo is/
19:01:37 <FunctorSalad> I always forget what that scanl does...
19:01:52 <FunctorSalad> (yes that example is obvious of course ;))
19:02:16 <kmc> @free scanl
19:02:17 <lambdabot> (forall x. f . h x = k (f x) . g) => $map f . scanl h y = scanl k (f y) . $map g
19:02:34 <Alpounet> much less obvious this way though
19:02:37 <aavogt> > map (foldl (+) 0) $ tails [1..10]
19:02:38 <lambdabot>   [55,54,52,49,45,40,34,27,19,10,0]
19:02:46 <aavogt> > map (foldl (+) 0) $ inits [1..10]
19:02:46 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
19:03:39 <aavogt> that's how I remember it, provided that I can tell the difference between inits and tails ;)
19:03:39 <copumpkin> > scanl1 (+) [1,3..]
19:03:39 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:04:54 <Alpounet> thus, scan functions are histomorphisms right ?
19:05:16 <kmc> @src scanl
19:05:17 <lambdabot> scanl f q ls = q : case ls of
19:05:17 <lambdabot>     []   -> []
19:05:17 <lambdabot>     x:xs -> scanl f (f q x) xs
19:05:49 * Axman6 always wondered why scanl used case and not pattern matching definitions
19:06:47 <kmc> laziness? this way it can produce q:_|_ even if ls is _|_
19:06:50 <aavogt> > scanl (+) 1 undefined
19:06:51 <lambdabot>   [1* Exception: Prelude.undefined
19:07:11 <kmc> > case scanl (+) 1 undefined of x:_ -> x
19:07:11 <lambdabot>   1
19:07:51 <Axman6> ah
19:07:55 <kmc> i remember the stream fusion paper said that the laziness of various prelude list ops is quite subtle and it seems that H98 is not clear or introduces unnecessary strictness
19:08:22 <aavogt> > let ascanl f q (l:ls) = q: scanl f (f q l) ls; ascanl f q [] = q in ascanl (+) 1 undefined
19:08:23 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:08:32 <aavogt> ooh
19:08:38 <kmc> a is [a]!
19:08:47 <aavogt> > let ascanl f q (l:ls) = q: scanl f (f q l) ls; ascanl f q [] = [q] in ascanl (+) 1 undefined
19:08:47 <lambdabot>   * Exception: Prelude.undefined
19:09:13 <aavogt> > let ascanl f q ~(l:ls) = q: scanl f (f q l) ls; ascanl f q [] = [q] in ascanl (+) 1 undefined
19:09:14 <lambdabot>   [1,* Exception: Prelude.undefined
19:09:24 <aavogt> just a style thing though
19:10:21 * aavogt never guesses the correct order for lazy (~) and as (@) in patterns
19:10:53 <kmc> is there a reason why @ : Ident -> Pattern -> Pattern rather than Pattern -> Pattern -> Pattern?
19:11:08 <kmc> seems like general pattern intersection could be useful
19:12:03 <aavogt> kmc: for what kind of data could you not put all your matches on the right side of @?
19:12:45 <kmc> we might want to intersect view patterns
19:30:48 <sshc> how do I install a package globally system-wide with cabal?
19:31:43 <Axman6> cabal install --global i think.
19:31:50 <Axman6> cabal install --help :)
19:31:53 <sshc> thanks, Axman6, I'll try that
19:32:22 <sshc> Axman6, yes, that did it.  Thanks
19:34:43 <SmurfOR> i've been fighting with this little bit of code for a while and i can't figure out why i'm getting this error. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4537#a4537 i've traced out and it's recurring properly i think the way i'm chaining applying the functions together is wrong?
19:34:59 <SmurfOR> in the parseOps function that is
19:35:37 <kmc> SmurfOR, what's ≡?
19:35:57 <kmc> i'd rewrite parseOps using more pattern matching and fewer guards
19:35:57 <SmurfOR> kmc, oops yeah that's == my vim has a script on to do that
19:36:34 <kmc> also it looks like a fold
19:39:28 <Cale> SmurfOR: what the heck is 'ops' in permuteWith?
19:40:37 <Cale> Also, after commenting out permuteWith, I don't get that error
19:40:53 <Cale> > parseOps [1,2,3] ["*","-","+"]
19:40:53 <Cale> -1
19:40:54 <lambdabot>   Not in scope: `parseOps'
19:42:42 <SmurfOR> Cale, hmmm k
19:43:13 <SmurfOR> Cale, it's an array holding "*", "/", "-", "+"
19:43:17 <Cale> You mean a list?
19:43:30 <SmurfOR> yeah :D sorry
19:43:41 <SmurfOR> i was doing JS all week
19:45:11 <kmc> javascript?
19:45:50 <SmurfOR> yeah
19:46:54 <SmurfOR> Cale, i still get the error when I comment out permuteWith :/
19:47:07 <upsh9401> is there a standard op for backward application? a `op` f = f a?
19:47:33 <Cale> upsh9401: No, but you can write ($a) f
19:47:59 <Cale> SmurfOR: huh
19:48:13 <Cale> SmurfOR: What's the inferred type of parseOps?
19:48:48 <SmurfOR> parseOps :: (Integral [a]) => [[a]] -> [[Char]] -> [a]
19:48:53 <upsh9401> ehh, I think ill just use =<< instead of >>=, yeah that makes it look much nicer.
19:49:03 <Cale> SmurfOR: Then you can see your problem clearly.
19:49:20 <Cale> SmurfOR: But that's not the inferred type of parseOps here. Are you sure you're loading the same file?
19:50:16 <SmurfOR> Cale, yup, same as what i pasted
19:50:32 <SmurfOR> what infered type do you get?
19:50:48 <SmurfOR> if i throw a [[Int]] at it i still get the same error too :/
19:51:54 <Cale> > :t parseOps
19:51:55 <Cale> parseOps :: (Integral a) => [a] -> [[Char]] -> a
19:51:55 <lambdabot>   <no location info>: parse error on input `:'
19:52:06 <Cale> heh, maybe I should change my ghci prompt :)
19:52:24 * Cale changes it to *>
19:52:32 <kmc> anyone think about a \bot plugin to load files from hpaste?
19:52:34 <SmurfOR> weird, that's the type i want..
19:52:59 <SmurfOR> let me try and reload ghci see if that fixes it :)
19:53:10 <Cale> What's your inferred type of your strange notation for == ?
19:53:15 <Cale> Maybe it's that.
19:53:37 <SmurfOR> Cale, it's written to the file as == though the vim script only changes it when i load it up
19:54:08 <Cale> ah
19:54:17 <SmurfOR> weird... :/
19:55:10 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4537#a4538
19:55:28 <SmurfOR> :|
19:55:36 <SmurfOR> i think i know why
19:55:48 <SmurfOR> i had a pattern i hadn't commented out
19:55:54 <iaefai_> Does haskell (ghc) have any very good IDE or other entry system that is in any way better than notepad++ and a powershell window with ghci?
19:56:14 <Cale> iaefai_: I just use vim and ghci
19:57:09 <Cale> There's leksah though
19:57:12 <SmurfOR> Cale, sorry for wasting your time :/ it was a stray pattern that messed it up that i didn't see
19:57:39 <Cale> http://www.leksah.org/screenshots.html
19:59:44 <Cale> Personally, I find that IDEs mainly just clutter the screen with GUI controls that I don't need, and/or do things which are mainly attempts to make up for language deficiencies. There are some things I can imagine a Haskell IDE could do which would be pretty cool, but there's no program which does them.
20:00:11 <kmc> good editor-REPL integration would be nice
20:00:22 <kmc> emacs will show types for Prelude values but i don't know if it talks to a running GHCi
20:00:37 <Cale> It doesn't.
20:01:05 <Cale> It just has its own index, for a while that was out of date and tantalisingly used the 1.4 prelude definitions :)
20:01:19 <sproingie> you can make it use a local hoogle install
20:01:25 <p_l> Cale: A good Haskell IDE would IMHO look similar to CL's SLIME - that is, zero GUI controls, just things like autocompletion, autodoc (in case of haskell info on types?) maybe automatic typechecking as you type...
20:01:51 <sproingie> tho it still won't do it as a "hover" eldoc style
20:01:55 <kmc> Agda-style holes would be nice
20:03:27 <sproingie> flymake does pretty good
20:05:46 <kmc> is there a proposal for replacing typeclasses with a more general implicit-argument system, like Scala has?
20:07:51 <kmc> it would be nice to manage typeclass instances with the usual machinery for modules and local shadowing
20:11:46 <Twey> kmc: Can you link me to info on that?
20:15:15 <kmc> btw i don't know much about scala
20:15:17 <kmc> http://www.scala-lang.org/node/114
20:15:29 <Twey> Thanks
20:15:54 <kmc> the idea is that a typeclass constraint becomes an implicit argument for a typeclass dictionary, whose value is inferred from the local environment unless explicitly given
20:16:16 <kmc> (including on the typeclass operators themselves)
20:16:19 <Twey> Doesn't that require impurity?
20:16:29 <kmc> and you have a way to mark a binding as a candidate for this inclusion
20:16:33 <kmc> Twey, in the sense of side effects?
20:16:38 <kmc> i don't see why, it's possible i'm missing something
20:18:24 <Twey> Oh, wait — I think I see
20:18:25 <kmc> would be really nice to override instances in "let" or "where" for example
20:18:31 <Twey> Basically they're just scoped instances?
20:18:48 <kmc> i think an implicit parameter system is more general
20:18:57 <kmc> but it would get you scoped instances, at least
20:19:36 <kmc> it should statically resolve to the same code as if you'd been passing dictionaries yourself, with an error for ambiguity
20:19:44 <kmc> which i guess corresponds to overlapping instances, but that's now a local property
20:21:29 <byorgey> kmc: these threads might be relevant: http://lists.seas.upenn.edu/pipermail/types-list/2009/001333.html   and http://lists.seas.upenn.edu/pipermail/types-list/2009/001405.html
20:21:33 <kmc> also would unify e.g. sort and sortBy
20:22:06 <kmc> byorgey, thanks
20:22:09 <byorgey> kmc: I think there's room for some really cool stuff along the lines you propose, but it gets quite tricky to specify so there's no ambiguity
20:24:40 <kmc> hmm
20:30:49 <kmc> re: the second link, i think analyse remains well-typed no matter what, but you'd get an ambiguity error calling (+), just like if you gave two "instance"s in a "where" (which wouldn't itself be an error)
20:31:10 <kmc> the user could explicitly choose which dictionary to use, but that's clunky
20:31:48 <byorgey> yeah
20:31:56 <kmc> you could have a way to pattern-match on the dicts and provide an equality constraint
20:32:22 <kmc> but that's still clunky, and you have to decide what to do in the case where they're not the same, which is still a valid way to call the function
20:32:46 <kmc> the later suggestions about datakinds are interesting, i will have to read more in depth
20:33:33 <kmc> perhaps it is related to the other idea of lifting the choice of which particular instance was used into the type system, so it becomes another type parameter of G
20:33:40 <kmc> and thus can be constrained statically
20:44:43 <sjanssen> this new dbus package looks interesting, but why can't it just use haddock for documentation?
20:48:12 <upsh9401> is there an function that does: f m value = m >> return value ?
20:48:41 <sjanssen> @pl f m value = m >> return value
20:48:41 <lambdabot> f = (. return) . (>>)
20:48:53 <dolio> If it's also declared applicative, value <$ m
20:49:29 <upsh9401> hmm Text.ParserCombinators.Parsec is probly not declared applicative.
20:49:43 <aavogt> @hoogle void
20:49:43 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:49:56 <Cale> Text.ParserCombinators.Parsec is the old path to Parsec, by the way
20:50:02 <Cale> It should just be Text.Parsec
20:50:06 <dolio> Parsec is Applicative in version 3.
20:51:51 <upsh9401> Text.Parsec doesnt seem to be in what I have installed, and I dont have root privaliges so..
20:52:10 <upsh9401> which is annoying.
20:52:20 <dancor> you can define an applicative instance
20:52:39 <dancor> easily from the monad instance
20:53:10 <dolio> <$ might actually be defined just for functors.
20:53:17 <kmc> :t (<$)
20:53:18 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
20:53:22 <kmc> hooray
20:53:31 <upsh9401> hmm
20:53:33 <dolio> Since 'x <$ m' = m <$> const x
20:53:55 <Cale> upsh9401: Note that you'll have to import Control.Applicative of course
20:54:09 <aavogt> dolio: not:   const x <$> m ?
20:54:16 <dolio> Oh, right.
20:56:09 <dmwit> upsh9401: So, install it as user?
20:56:25 <dmwit> upsh9401: (It's really easy, and GHC is pretty smart about preferring user-installed libraries to root-installed ones.)
20:56:38 <upsh9401> How does one do that?
20:57:08 <dmwit> cabal update && cabal install parsec-3.0.1
20:57:17 <dmwit> First install cabal-install if you haven't got that yet. ;-)
20:57:28 <dmwit> http://hackage.haskell.org/package/cabal-install
20:57:46 <dmwit> There's a tar there with an installation script.
20:59:32 <upsh9401> dmwit: thanks!
21:08:56 <kmc> if you have the space, i think it's easy to install all of Haskell Platform locally
21:09:58 <kmc> unless your company uses a 5-year-old linux distro, then shit will break randomly
21:20:23 <upsh9401> I just dont know how to install things localy.
21:20:31 <upsh9401> Like at all.
21:20:50 <kmc> ./configure --local --prefix=/home/me/local
21:21:06 <kmc> or is it --user
21:21:22 <kmc> anyway most unix app configure scripts will accept --prefix
21:22:03 <upsh9401> cool
21:22:13 <upsh9401> seems simple enough
21:23:01 <upsh9401> so for installing with cabal, if it is installed localy will it default to installingling localy?
21:24:07 <kmc> i think so
21:25:39 <upsh9401> the script mentions a config file in .cabal/ but there seems to be no such file.
21:34:09 <kmc> did you run "cabal configure"?
21:34:31 <mmorrow> kmc: you can use implicit params to get the same kind of thing (sort of) as typeclasses http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7512
21:34:34 <kmc> err that's not right...
21:34:42 <mmorrow> "thing" := implicit passing of the dict
21:35:21 <mmorrow> so you can explicitly choose the dictionary to use at any point
21:35:23 <kmc> mmorrow, nice
21:36:35 <kmc> can you capture those into existentials like you can for classes?
21:36:49 <mmorrow> yes
21:39:25 <mtnviewmark> anyone here familiar with Haskell Platform on Mac OS X, specifically Snowleapord
21:39:55 <kmc> mtnviewmark, not me but i'm interested in hearing your question anyway
21:40:05 <Axman6> mtnviewmark: ask away
21:40:56 <mtnviewmark> well, I had GHC 6.10.4 installed before, and it was just fine
21:41:07 <mtnviewmark> strike that 6.10.1
21:41:25 <mtnviewmark> I installed Haskell Platform and now I have an odd, but totally annoying behavior in ghci
21:41:42 <mtnviewmark> when it prints the result, it doesn't first echo the newline!
21:41:53 <mtnviewmark> so the result of an expression is written over the prompt line
21:42:18 <mtnviewmark> this didn't happen before in 6.10.1, and doesn't happen on another machine where I just instlled 6.10.4 directly (not via Haskell Platform)
21:42:21 <mtnviewmark> anyone seen this?
21:42:28 <mtnviewmark> is it some funkyness with Haskeline?
21:42:39 <Cale> I haven't...
21:43:13 <Cale> But, I haven't installed ghci via the Haskell Platform either
21:43:17 <mtnviewmark> also, GTK+ apps run from this Haskell Platfrom install of 6.10.4 ghci don't work - they hang
21:43:34 <Cale> Something must be seriously broken...
21:43:54 <mtnviewmark> everything else seems happy
21:44:14 <mtnviewmark> actually, compiling the same GTK+ program with ghc --make and running it works just fine
21:44:37 <Cale> what if you compile with --threaded?
21:45:14 <luite> that's -threaded
21:45:30 <Cale> er, yeah, sorry, wondered about that after I typed it
21:45:43 <luite> but I'm not sure what the logic behind the single and double dash flags is
21:45:45 <Cale> Stupid idiosyncratic option naming :P
21:46:02 <Twey> Hear hear
21:46:03 <mtnviewmark> ah, because ghci runs threaded?
21:46:20 <Cale> Yeah, I think so.
21:46:49 <gio123> Cale: do u speak portuguis?
21:46:54 <Cale> no
21:47:17 <medfly> hi
21:47:24 <gio123> :)
21:47:51 <mtnviewmark> I'm checking...
21:48:19 <mtnviewmark> heh: "initGUI: Gtk+ is single threaded and so cannot safely be used from
21:48:19 <mtnviewmark> multiple Haskell threads when using GHC's threaded RTS."
21:48:27 <gio123> abybody portuguis speaker?
21:48:46 <mtnviewmark> so that answers that aspect! is there a way to run ghci non-threaded?
21:49:15 <Axman6> ChilliX: are you arounf?
21:49:18 <Axman6> around too
21:50:53 <dmwit> mtnviewmark: There's a way to suppress that warning.
21:50:59 <dmwit> http://www.haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-General-General.html#v%3AunsafeInitGUIForThreadedRTS
21:51:27 <Elly> that is a ludicrous name
21:52:08 <dmwit> unsafeEliminateLudicrousAndReplaceByEllyApprovedPerformIO
21:52:38 <Twey> Hahaha
21:53:22 <Axman6> Elly: insafe things tend to have ludicrous names, to stop you using them
21:53:23 <mtnviewmark> well, that didn't cut it -- running
21:53:43 <mtnviewmark> unsafeInitGUIForThreadedRTS >> main
21:54:06 <mtnviewmark> has the same behavior: the window opens, never redraws, and then ghci hangs
21:54:18 <Elly> Axman6: yeah, really
21:54:18 <mtnviewmark> the same .hs file compiled runs just fine
21:54:23 <kmc> see *that* is why haskell is a great imperative language.  try to write postGUISync in C++
21:54:27 <Axman6> gtk2hs has never liked ghci on OS X mtnviewmark
21:54:40 <mtnviewmark> ah - that is sad, but I suppose I can deal
21:55:40 <mtnviewmark> I guess it might be time to switch to using Leksha
21:55:54 <Axman6> :\
21:56:06 * mtnviewmark <-- wants fast turn around in his programming environment
21:56:18 <mtnviewmark> <-- loves ghci's :reload
21:56:39 * Twey <-- recommends haskell-mode, with GHCi integration
21:56:51 <Twey> <-- points at self
21:57:32 <hexpuem> xmonad + emacs + ghci
21:57:32 <mtnviewmark> <-- swings the other way (vi)
21:57:34 <kmc> speaking of, "cabal install leksah" complains about no version available for glib, gtk, etc
21:57:54 <kmc> this is with 6.10.4 on haskell platform on debian gnu/linux
21:57:56 <iaefai_> Does there exist a structure or method in haskell that would permit the storage of state changes and going backwards and forwards with their side effects being updated? Specifically - storing a chess game, the side effect being the current state of the board.
21:58:00 <mtnviewmark> <-- besides, notes that the point was that Gtk+ and ghci don't play well on Mac OS X anyway
21:58:14 <hexpuem> glfw doesnt work right in ghci either
21:58:24 <kmc> iaefai, you can use any container to store your states
21:58:31 <kmc> like a list or a Seq
21:58:43 <kmc> since you never change them, but only create new ones from the old
21:58:58 <Twey> iaefai_: List of tuples?
21:59:09 <Twey> (Board, Board -> Board)
21:59:22 <kmc> if you use the right datatype for states, they will share most of the structure and only store the differences
21:59:29 <dancor> iaefai_: idk anything, but you might use a zipper for the game tree..
21:59:32 <iaefai_> Twey: useful, but storing every board would be memory intensive
21:59:41 <Twey> iaefai_: I thought that was what you wanted
21:59:51 <mtnviewmark> is cabal install leksah likely to be smaller / better or something than installing by downloading the prebuilt binary ?
22:00:08 <Twey> mtnviewmark: Easier?
22:00:19 <kmc> iaefai_, that's why you use a board structure with sharing, like DiffArray
22:00:24 <iaefai_> I only want to store the moves and be able to get the board that would be at certain moves, without actually storing the different boards. As kmc says, storing differences.
22:00:25 <kmc> i think the Seq you were using will also do it
22:00:25 <Twey> *nod*
22:00:35 <Twey> That's what a DiffArray does, yeah
22:00:38 <Twey> Seq shares?
22:00:39 <kmc> but, this way you logically think of storing whole boards, which is easier
22:00:42 <kmc> i don't know
22:00:45 <kmc> it uses finger trees
22:00:48 <Twey> Hum
22:00:48 <kmc> and trees are good for sharing
22:00:50 <iaefai_> hmm, I best look at this :p
22:00:55 <dancor> iaefai_: i wrote an n-child zipper (that i call a positioned ordered multitree) once that i used for go and chess tree analyses: http://github.com/dancor/pomtree
22:00:55 <kmc> and that's about all i know, without digging into the code
22:00:55 <hexpuem> does hackagedb have any quality control
22:01:06 <dancor> hexpuem: not that i'm aware of
22:01:29 <iaefai_> What is a zipper
22:01:32 <dancor> it's annoying that it accepts and gives out build-failing versions
22:01:32 <hexpuem> wonder if anyone is interesting in setting something up
22:01:34 <kmc> "mtl: inspected by #9"
22:01:35 <hexpuem> interested
22:02:06 <kmc> iaefai_, http://haskell.org/haskellwiki/Zipper
22:02:30 <hexpuem> would be nice if there was some statistics of how many people are using a certain package too
22:03:08 <iaefai_> hexpuem: start writing code :p
22:03:19 <dancor> blame the victim
22:03:22 <iaefai_> I am not going to be using a tree :p
22:03:34 <kmc> iaefai_, you were using Seq right?
22:03:42 <iaefai_> Seq Seq yes
22:03:48 <kmc> those are implemented using trees
22:03:56 <hexpuem> well i have some libraries that i could upload to hackage but its kinda unclear if theres a point or not
22:03:57 <iaefai_> I am starting to think that a single Seq is not a bad idea
22:03:57 <dancor> hah that's a technicality
22:04:08 <kmc> i think a DiffArray might be good
22:04:15 <iaefai_> I am trying to look up the docs now
22:04:24 <kmc> the various flavors of arrays have a common interface, so you can easily swap out implementations and profile space and time usage
22:04:31 <dancor> seq is usually what you want for linear things
22:05:30 <kmc> iaefai_, do your sequences of boards correspond to chess games?
22:05:40 <dancor> multidimensional MultiSeq is interesting to me..
22:05:40 <iaefai_> kmc, most definitely
22:06:19 <kmc> iaefai_, how long might they be?
22:06:20 <iaefai_> It will either be reading in a chess game annotated in a notation or an active in process game.
22:06:33 <kmc> i feel like the longest chess game ever is a few hundred moves?
22:06:36 * kmc doesn't know chess
22:06:44 <iaefai_> kmc, I don't really know how long they would be - maybe 50 moves?
22:07:20 <dancor> 269: http://en.wikipedia.org/wiki/List_of_world_records_in_chess#Longest_game
22:07:22 <iaefai_> "The longest tournament chess game(in terms of moves) ever to be played was Nikolić-Arsović, Belgrade 1989, which lasted for a 269-moves and took 20 hours and 15 minutes to complete a drawn game."
22:07:31 <kmc> so a full un-shared representation would be under 10,000 squares
22:07:47 <kmc> unless you want to store many of these at the same time, i wouldn't worry about space usage
22:08:14 <kmc> in this case i'd say optimize for clean code first, speed second, space third
22:09:23 <iaefai_> So really storing a board by Seq is ok
22:09:30 <kmc> it's ok by me :)
22:11:16 <kmc> if you're storing massive game trees for a chess AI, that's a different story
22:12:12 <iaefai_> external ai :p
22:12:26 <dmwit> iaefai_: What format? PGN?
22:14:36 <iaefai_> dmwit: Undecided, the only format I have heard of so far is 'algebraic'
22:14:47 <iaefai_> I am not a technical chess player at this time.
22:15:40 <iaefai_> PGN looks like it would do what I need, and supply a huge number of games :p
22:16:16 <kmc> iaefai_, you can make an abstract type for your board: a module which exports the type (but no constructors) and functions for manipulating it
22:16:22 <kmc> then you can play with representation easily
22:16:45 <dmwit> It's a shame PGN beat out SGF for chess.
22:16:55 <mtnviewmark> Leksah question: I'm getting "Could not find module 'Test.QuickCheck': it is a member of the hidden package..."
22:17:09 <mtnviewmark> the same file runs with ghci - so I know I have the package installed
22:17:19 <mtnviewmark> any idea which thing in Leksah is generating that
22:17:30 <mtnviewmark> it says "Use -v to see a list of the files searched for"
22:17:40 <mtnviewmark> and it is in the "Preprocessing executables" step
22:17:47 <dmwit> Maybe "beat out" is the wrong phrase, since nobody ever specified what a "move" or "point" would look like for a chess SGF spec.  Seems like it wouldn't be hard, though, and you'd get all the benefits of tree notation...
22:18:05 <iaefai_> dmwit: sgf looks not very great tbh
22:18:30 <mtnviewmark> SGF? Oh boy... I've written parsers for that...
22:18:32 <mtnviewmark> sigh
22:18:44 <mtnviewmark> not in Haskell though, perhaps that woudl be fun
22:18:44 <dmwit> mtnviewmark: I've just finished one up myself.
22:18:57 <dmwit> It's a nasty format to write for, but absolutely a joy to use.
22:19:02 <mtnviewmark> oh - is your aim Chess? Mine would be Go
22:19:06 <dmwit> go here
22:19:11 <dmwit> DGS in particular
22:19:12 <iaefai_> go there
22:19:14 <mtnviewmark> Delightful
22:19:27 <dancor> sgf is most common go format and pgn is most common chess format
22:19:33 <dmwit> yep
22:19:33 <mtnviewmark> check
22:19:36 <mtnviewmark> (heh)
22:19:51 <Axman6> mate!
22:19:53 <mtnviewmark> DGS = Dragon Go Server?
22:19:56 <dmwit> right
22:19:57 <mtnviewmark> Written in Haskell?
22:20:13 <iaefai_> Do you gentlepeople have advise for what would be the easiest multiplatform way to output graphics including text and shapes, and support clickable events (and hit testing)?
22:20:19 <dmwit> iaefai_: Just browsing the Wikipedia page for PGN, it doesn't look like PGN can do variations at all.  That sucks.
22:20:27 <dmwit> iaefai_: gtk2hs
22:20:37 <Twey> iaefai_: SVG + JS?
22:20:39 <dmwit> wxHaskell is good, too, I've heard
22:20:39 <iaefai_> I don't want to touch gtk2hs
22:20:46 <iaefai_> gtk in general
22:20:49 <dmwit> And there's some newish qt bindings, I believe.
22:20:59 <iaefai_> I run a mac and windows, so my immediate thoughts would be opengl
22:21:01 <Twey> Aren't the Qt bindings ancient?
22:21:12 <kmc> isn't opengl a pain on windows
22:21:13 <dmwit> There's certainly hOpenGL.
22:21:19 <iaefai_> kmc, not with glut :p
22:21:28 <dmwit> The short answer is: the simplest thing is the thing you already know.
22:21:33 <kmc> it's also a lower level, won't give you GUI widgets or easy clickable things
22:21:42 <kmc> or even easy sprite rendering
22:21:48 <iaefai_> I have had experience with opengl in the past, but it is a very long time in the past.
22:22:11 <dmwit> So, uh... why do you hate gtk?  (out of curiosity)
22:22:21 <hexpuem> gtk kinds sucks on windows machines
22:22:23 <hexpuem> kinda
22:22:30 <dmwit> Does it?
22:22:33 <iaefai_> dmwit: never had much luck with it on windows or mac.
22:22:39 <dmwit> More than "it just looks out of place"?
22:22:40 <iaefai_> I will not use an X server
22:22:41 <hexpuem> yea if you multiple runtime environments
22:22:45 <hexpuem> sometimes they break each other etc
22:22:49 <kmc> the webapp option is not a bad one
22:22:51 <iaefai_> I don't run linux anymore
22:23:00 <Axman6> iaefai_: hooray
22:23:01 <iaefai_> How can I use a webapp?
22:23:14 <Twey> 05:20:37 < Twey> iaefai_: SVG + JS?
22:23:16 <kmc> your program runs a webserver, people connect with their browser
22:23:18 <hexpuem> btw i think someone uploaded some new qt bindings in the last week or so
22:23:21 <hexpuem> havent looked at them though
22:23:41 <Twey> GTK+ runs fine on at least Windows and X11
22:23:48 <iaefai_> I like in principle of the webserver, it would get around some opengl versioning issues I have.
22:23:51 <jystic> gimp is nice on windows (imo) and that uses gtk
22:23:52 <copumpkin> lol jfredett
22:24:03 <Twey> Haven't experience with it on Mac, but no reason it should be bad
22:24:07 <hexpuem> ive had gimp installs that were totally broken
22:24:10 <Twey> jystic: *nod* Quintessentially
22:24:36 <jystic> hexpuem: i've never had that before
22:24:50 <Twey> Nor I
22:24:57 <iaefai_> Does anyone have any sample code that I could try the webapp idea? I would essentially be after something that does something basic to show me it can do something.
22:24:59 <hexpuem> how many gtk apps do you have installed
22:25:06 <Twey> Maybe if you forgot to install GTK+ first…
22:25:15 <hexpuem> alot of them package their own
22:25:20 <jystic> I put gimp on my gf's mac laptop and it's a bit broken, the buttons in the toolbar don't work
22:25:31 <dancor> have gtk haters tried http://haskell.org/haskellwiki/WxHaskell
22:25:53 <dancor> which, incidentally, is another haskell page that overuses "industrial strength"
22:26:07 <hexpuem> i dont mind gtk
22:26:23 <dancor> wx does better nativeness on mac right?
22:26:24 <iaefai_> I just use photoshop :P Gimp doesn't really cut it
22:26:32 <jystic> but it might be a snow leopard problem, i saw on the inkscape site that they have had problems with snow leopard
22:27:17 <jystic> iaefai_: Photoshop is too much hassle for me, I enjoy being able to do everything I need with free software, it saves fights with IT at work :)
22:27:35 <iaefai_> If it has any snow leopard issue, then I can't use it
22:27:35 <Twey> dancor: There's only one mention of it :þ
22:27:40 <hexpuem> CS4+ or whatever its called is too damn expensive
22:27:42 <Twey> (and that's in the aims section)
22:27:44 <dancor> i'm not good enough to notice a problem with gimp (vs photoshop)
22:27:53 <dancor> Twey: uh huh
22:28:02 <jystic> iaefai_: i'm sure it's only temporary, they'll fix it soon enough
22:28:15 <kmc> i see a couple HTTP server libraries on hackage... any suggestions for a task like this one?
22:28:31 <iaefai_> jystic: I have a month and a half window on this software, it will run on windows, but be written on my imac primarily
22:28:54 <jystic> iaefai_: oh sorry, i meant on photoshop vs gimp
22:29:00 <mtnviewmark> hmmm, any ideas on why Leksah would fail to compile my source with "Could not find module 'Test.QuickCheck'?
22:29:02 <Twey> dancor: That's because there are none.  :þ  I've asked many people, some of them very experienced artists, and many of them have hated on the GIMP and praised Photoshop until they were blue in the face, but none of them could give an actual example of an image-editing feature that Photoshop had and the GIMP didn't (or equivalent)
22:29:30 <dancor> my fancy-designer "friends" just say that the ui is bad
22:29:37 <hexpuem> probably cause theyre too used to the photoshop UI
22:29:39 <hexpuem> yea
22:29:39 <dancor> which is their job, to say things like that
22:29:41 <Twey> The most persistent complaint is ‘the UI doesn't work like Photoshop's’
22:29:41 <Twey> Yeah
22:29:45 <iaefai_> Twey: 32 bit channels at all?
22:29:49 <kmc> they also change the Gimp UI all the time
22:29:54 <kmc> which is good, because it gets better
22:29:57 <dancor> right but they go further to claim that it's bad in a more objective sense
22:29:58 <kmc> but you have to relearn everything
22:29:58 <iaefai_> CMYK
22:30:03 <hexpuem> but if you compare corel painter to photoshop
22:30:07 <hexpuem> its not so much of a problem
22:30:12 <dancor> anyway i wouldn't be surprised if they were full of it
22:30:18 <Twey> iaefai_: Since 2.6
22:30:22 <jystic> it's probably just because they're not productive like they are in photoshop because they know photoshop
22:30:30 <iaefai_> Twey: Import illustrator files?
22:30:39 <hexpuem> gimp gives the impression that its much less polished
22:30:47 <iaefai_> hexpuem: quite true
22:31:11 <iaefai_> The truth of the matter is that I bought the web CS4 stuff at a student price and have used illustrator and photoshop quite a bit
22:31:25 <hexpuem> yea the student price is pretty reasonable on it
22:31:27 <iaefai_> I don't know of any free software on the mac that would work as smoothly
22:31:28 <hexpuem> like 200$ or something
22:31:29 <Twey> iaefai_: Wrong app — the GIMP is for bitmap images.  Inkscape (a vector editor) can open Illustrator files.
22:31:59 <iaefai_> Twey: photoshop can import illustrator and work with it, there are legitimite things to import vectors for
22:32:10 <Twey> (and export a bitmap for the GIMP, if you want)
22:32:25 <kmc> GIMP does have paths though
22:32:31 <jystic> GIMP and Photoshop are both good products, I just find it more worthwhile for me to know GIMP because I know I can download it and use it anywhere without any licensing hassles
22:33:43 <iaefai_> Is HAppS still being developed?
22:33:43 <hexpuem> it seems like adobe has a lot of fluff releases with PS
22:33:50 <hexpuem> that have features that arent really that interesting
22:34:10 <Twey> iaefai_: Google suggests it can, too
22:34:14 <Twey> (the GIMP)
22:34:20 <jystic> iaefai_: I think so, but it's called happstack now
22:34:21 <Twey> I'd still go with Inkscape for vector graphics, though.
22:35:03 <jystic> iaefai_: the original project was orphaned, but it's been taken up by someone else and they renamed it
22:35:16 <jfredett> copumpkin: hm? oh- the editorial? :)
22:35:22 <kmc> it's happstack now
22:35:33 <copumpkin> jfredett: just for including those things I said in HWN
22:35:53 <jfredett> copumpkin: I actually laughed out loud at the "FUNCTORED YOUR MOM" bit...
22:35:58 <copumpkin> :P
22:36:00 <iaefai_> Twey: What I would like is a nice cocoa vector app that is good for tech drawings, but nothing is good that is inexpensive (illustrator is 'good enough')
22:36:08 <copumpkin> I'm glad :)
22:36:12 <kmc> iaefai_, i'm playing with Network.Shed.Httpd, and it's really simple
22:36:22 <iaefai_> kmc, I should look at it
22:36:29 <kmc> let f req = return $ Response 200 [("Content-type", "text/plain")] "Hello, world!" in initServer 8888 f
22:36:29 <p_l> iaefai_: what about X11 apps?
22:36:35 <mtnviewmark> iaefai_ if you are doing diagrams and the like - OmniGraffle
22:36:39 <iaefai_> p_l: I won't use an X server
22:36:47 <jfredett> copumpkin: That quote would make a good t-shirt. methinks.
22:36:50 <p_l> iaefai_: pity, I really recommend xfig
22:37:00 <jfredett> maybe a little diagram behind it...
22:37:03 <Twey> If you're going to lock yourself into a proprietary interface, I'm afraid you're not going to find too many good free apps
22:37:07 <kmc> i think happstack is intended for a full on database-heavy model-view-controller webapp
22:37:15 <iaefai_> mtnviewmark: I think I tried omnigraffle and didn't like its interface
22:37:17 <copumpkin> jfredett: I was really hoping to come up with something more categorically meaningful (beyond just containing the word functor) but I wasn't clever enough
22:37:29 <hexpuem> can you still run photoshop in OSX if youre using Xorg and another window manager?
22:37:44 <p_l> hexpuem: yes, if you are using X11.app under Aqua
22:37:46 <iaefai_> hexpuem: Xorg runs on top of aqua
22:37:55 <copumpkin> but photoshop for mac os isn't an X app
22:37:56 <copumpkin> so no
22:37:56 <hexpuem> nice
22:38:02 <ChilliX> Axman6: hey
22:38:07 <Axman6> o/
22:38:09 <hexpuem> lame
22:38:10 <hexpuem> haha
22:38:13 <Axman6> got a link for you
22:38:16 <upsh9401> When I use cabal to install parsec, it installs 2.1.0.1 what is up? I thought it was on 3 something?
22:38:19 <p_l> iaefai_: afaik Xorg doesn't run on top of Aqua, just Apple's X11 server - X.Org runs directly on IOKit drivers iirc
22:38:26 <iaefai_> copumpkin: when speaking of the mac pick your X usages wisely :p
22:38:29 <Axman6> ChilliX: http://www.macresearch.org/opencl they have lots of other good stuff on there too
22:38:32 <copumpkin> :)
22:38:48 <ChilliX> Axman6: thanks!
22:39:00 <iaefai_> This conversation is certainly diverging
22:39:08 <mtnviewmark> Oy, the problem, methinks is that Leksah uses packages to buid my project, and I've only every done it with "ghc --make"
22:39:13 <ChilliX> Axman6: I have seen that already, actually — still ta for the suggestion
22:39:22 <mtnviewmark> there seems to be something it is passing on the command line that I'm not seeing
22:39:41 <mtnviewmark> wish Leksah would print out the commands it is executing
22:39:45 <dmwit> upsh9401: You have to specifically request the new version.
22:39:52 <Axman6> ChilliX: righto, well, good to know you've seen it then :)
22:40:15 <dmwit> upsh9401: (Probably because it would require you to install other new packages, whereas parsec 2.1.0.1 wouldn't.)
22:40:31 <dmwit> upsh9401: cabal install parsec-3.0.1 or whatever
22:41:13 <ChilliX> Axman6: I have subscribed to their rss feed — macos for scientists seemed kind of fitting ;)
22:41:46 <upsh9401> hmm
22:41:58 <ChilliX> they have some interesting articles
22:42:06 <Axman6> indeed
22:42:24 <Axman6> i keep stumbling onto their stuff and they always have good stuff
22:43:02 <upsh9401> How do you find out what the newist version of a package is with cabal?
22:44:31 <dancor> upsh9401: e.g.: cabal info hsh
22:44:39 <dancor> after a: cabal update
22:45:15 <mtnviewmark> aha - found it - when building via package - you need to spec all the dependent packages or else!
22:45:21 <mtnviewmark> call me "noob"
22:45:50 <Svrog> hi dcoutts, are you around? i have a question regarding Data.Text
22:45:54 <mtnviewmark> but, sigh, running Test.HUnit or Test.QuickCheck output to a Leksah Log window is sort of a fail
22:45:56 <dancor> i thought cabal-install had a specific hack in it where it things parsec means parsec2
22:46:03 <mtnviewmark> the Log window doesn't do even simple cursor control
22:46:15 <dancor> because "parsec3 is slow"
22:46:16 <Svrog> i'm getting horrible performance using the lazy interface
22:46:37 <dancor> (don't worry, parsec3 is still _industrial_strength_)
22:47:02 <jre2> any recommendations on an xml parsing library that supports xpath?
22:47:56 <Twey> I think HXT does
22:48:05 <Twey> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html
22:48:16 <copumpkin> dancor: thank god
22:48:21 <dancor> whew!
22:48:27 <copumpkin> dancor: I'd hate to use a hobbyists parser
22:48:28 <copumpkin> '
22:48:33 <Twey> Hahaha
22:48:35 <dancor> think of the indignity
22:48:42 <dancor> industrity
22:48:54 <Twey> I think people put that in so they can convince their bosses to adopt it.
22:49:05 <dancor> probably, i'm such a hater
22:49:24 <dmwit> Haddock has some awesome powers.
22:49:30 <iaefai_> :t (.)
22:49:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:49:52 <dmwit> That's too specific!  It should work for any Category. ;-)
22:50:20 <iaefai_> @src (.)
22:50:20 <lambdabot> (f . g) x = f (g x)
22:51:04 <kmc> iaefai_, you may be interested in the specialization for functions: (b -> c) -> (a -> b) -> (a -> c)
22:51:07 <kmc> function composition
22:51:59 <kmc> @src ($)
22:51:59 <lambdabot> f $ x = f x
22:52:01 <kmc> @src (.)
22:52:01 <lambdabot> (f . g) x = f (g x)
22:53:02 <kmc> > let f = (+1) . (*3) in f 2
22:53:03 <lambdabot>   7
22:54:30 <dolio> @seen Cale
22:54:31 <lambdabot> Unknown command, try @list
22:54:31 <iaefai_> ok, that looks explicitly like a certain mathematical property that escapes me
22:55:13 <dmwit> Function composition?
22:55:25 <dancor> it just means doing one function and then the other
22:55:38 <idnar> not really a property, more of a definition
22:55:45 <dancor> BUT in backwards order!
22:56:03 <dancor> f OF g
22:56:07 <dancor> of x
22:57:33 <iaefai_> :t (.)
22:57:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:57:48 <kmc> iaefai_, read "f a" as "c -> a"
22:58:09 <upsh9401> okay you can do "let x = case b of .." right?
22:58:20 <iaefai_> kmc, why exactly?
22:58:32 <kmc> iaefai_, well, if you're interested in function composition specifically
22:58:45 <kmc> (.) is more general
22:58:46 <dancor> > let x = case 4 of 4 -> "yes!" in x
22:58:47 <lambdabot>   "yes!"
22:59:02 <iaefai_> yes, I am interested in it, especially to make a clear differentiation in my mind of it vs. $
22:59:13 <upsh9401> hmm parse error of doom
22:59:53 <iaefai_> Q:  (f . g) = f $ g x ?
22:59:55 <kmc> compare: (f . g) x     versus    f $ (g x)
22:59:56 <kmc> yes
23:00:05 <kmc> well, you're missing an x on the left
23:00:25 <iaefai_> yes
23:00:28 <dmwit> ?free (.)
23:00:28 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
23:00:39 <upsh9401> ?
23:00:42 <iaefai_> Does $ have a name?
23:00:43 <dmwit> ?free (.) :: (b -> c) -> (a -> b) -> (a -> c)
23:00:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
23:00:46 <dancor> f . g $ x   is the same as well
23:00:47 <kmc> "f $ g x" associates as "f $ (g x)" which (by the definition of $) is just "f (g x)"
23:00:48 <dmwit> iaefai_: Function application.
23:01:16 <BMeph> ($) :: (b -> c) -> b -> c ; (.) :: (b -> c) -> (a -> b) -> (a -> c)
23:01:27 <upsh9401> its really just a trick to get things to associat differntly.
23:01:30 <dancor> function application is also what happens when you just put things next to each other: f x
23:01:41 <kmc> use ($) when you're already applying and you want to throw on additional functions
23:01:51 <kmc> use (.) when you want to combine several functions but not feed in the argument yet
23:01:58 <Jafet> @type sum . drop
23:01:59 <dancor> .. $ ..   ->   (..) (..)
23:01:59 <lambdabot>     Couldn't match expected type `[a]'
23:02:00 <lambdabot>            against inferred type `[a1] -> [a1]'
23:02:00 <lambdabot>     Probable cause: `drop' is applied to too few arguments
23:02:06 <twb> In a .cabal flag, how would I describe a flag for -threaded?
23:02:09 <BMeph> I.e., if f $ b == c, then f . (\_ -> b) == (\_ -> c)
23:02:14 <Jafet> Hey, ghci didn't give me probable causes!
23:02:16 <jystic> does wxWidgets always look like windows 2000 when running on windows? all the screenshots seem to suggest that :/
23:02:25 <jystic> or are they just old?
23:02:38 <twb> Currently I have "Use the threaded runtime (SMP support).  Not available on some architectures."
23:02:41 <Jafet> @type curry (sum . (uncurry drop))
23:02:42 <lambdabot> forall a. (Num a) => Int -> [a] -> a
23:03:04 <Twey> jystic: It uses MFC, so it'll match your Windows theme.
23:03:20 <iaefai_> Are there any precidence rules when using $?
23:03:33 <iaefai_> Say I have f (g (h x))
23:03:36 <Twey> Most people with taste use 2000-like themes when forced to use Windows.  :þ
23:03:39 <iaefai_> Can I do f $ g $ h x
23:03:43 <dancor> iaefai_: yes
23:03:43 <jystic> Twey: ahh ok cool
23:03:49 <jystic> Twey: haha
23:04:07 <twb> Hm, http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#id458302
23:04:09 <Twey> They tend to prefer ‘austere’ to ‘garish’ :þ
23:04:13 <iaefai_> Twey: While this is true, I have started to use aero in 7 - just set up three computers at my parents place
23:04:23 <Twey> iaefai_: Yes, but it's usually redundant and you probably shouldn't
23:04:31 <Twey> ($)
23:04:33 <jystic> Twey: but it looks like a robot shat bricks and that's what they used to make the UI
23:04:38 <dancor> iaefai_: ($) has the highest precedence an operator can have, only language constructs are higher so you can do like: if test then f $ g x else h $ j x
23:04:39 <Cale> iaefai_: You can, but I prefer f . g . h $ x
23:04:47 <Cale> Or f . g $ h x
23:04:49 <upsh9401> hmm for some reason it doesn't seem to work in a let in a do block that doesnt then use in.
23:04:55 <Twey> jystic: Clearly, you're a latecomer to the GUI market.  ;)
23:04:59 <Cale> Because composition has nicer properties than $
23:05:13 <Twey> http://xwinman.org/screenshots/cde-donner.jpg — CDE
23:05:44 <jystic> Twey: lol, just because CDE is bad doesn't mean windows 2000 is good
23:06:00 <Twey> It's mediocre.
23:06:58 <jystic> I find the childish looking XP more aesthetically pleasing
23:07:07 <mtnviewmark> Leksah w/multiple executables in a package = fail: No way to tell Leksah which one should be run when you choose Run
23:07:10 <Twey> Hate that thing
23:07:16 <Twey> Looks like it's made of cheap plastic
23:07:30 <jystic> Windows *is* made of cheap plastic
23:07:42 <dancor> mtnviewmark: laaaaaame
23:07:47 <iaefai_> kmc: What did you mean by this: "when you're already applying and you want to throw on additional functio"
23:07:51 <Twey> I can't help thinking, ‘you're wasting my resources for *this*?’
23:08:03 <Twey> jystic: It's not so cheap any more once they've burnt Windows onto it.  ;)
23:08:12 <jystic> haha
23:08:26 <Cale> I prefer Ubuntu's default metacity theme to anything I've seen out of the last few iterations of Windows.
23:08:36 <Twey> Aye
23:08:41 <jystic> Cale: agreed
23:08:43 <dancor> i don't have window decorations
23:08:50 <kmc> iaefai_, f $ g $ h x
23:08:56 <Twey> Ubuntu's themes are pretty tasteful, surprisingly, though I'm not really one for browns usually
23:08:59 <kmc> you're already applying h to x
23:09:00 <dancor> my terminals alternate black and dark-grey
23:09:11 <Twey> f . g $ h x
23:09:21 <kmc> same as (f . g . h) x, which is also what Twey said
23:09:30 <Twey> *nod*
23:09:37 <Cale> Yeah, I always try to maximise the number of compositions
23:09:49 <Cale> So f . g . h $ x
23:09:49 <jystic> I really like Ubuntu, switched to it last month after running Windows since 3.1
23:09:52 <iaefai_> I am starting a 'haskell journal' and writing this stuff down :p
23:09:53 <Twey> ‘f (g h) x’ is annoying, though
23:10:04 <Twey> > f $ g h $ x
23:10:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:10:06 <lambdabot>    `SimpleReflect.FromExpr ...
23:10:10 <Twey> > f $ g h $ x :: Expr
23:10:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:10:11 <Cale> Twey: Yeah, it would be nicer if $ associated the other way
23:10:11 <lambdabot>    `GHC.Show.Show a'
23:10:11 <lambdabot>      a...
23:10:13 <Twey> Bah
23:10:20 <Twey> You get the idea, probably :þ
23:10:48 <dancor> i'm still not convinced that f . g . h $ x is kewler than f . g $ h x
23:10:58 <Twey> dancor: Why would it be?
23:11:00 <Cale> dancor: More "subexpressions"
23:11:18 <Twey> That's a bonus?  :þ
23:11:33 <Cale> That is, if it's written as f . g . h $ x you can chop out g . h without having to edit it.
23:11:48 <Cale> (or even if you don't, g . h makes sense on its own)
23:11:57 <Cale> But g $ h is a type error
23:11:57 <dancor> mm
23:12:14 <iaefai_> I think it has become clear to me why . and $ were being mixed in my mind.
23:12:28 <Cale> iaefai_: It's because the associativity of $ muddles things up :)
23:12:38 <dmwit> On the other hand, you can change "f . g $ h x" to "f . g $ h x y", but "f . g . h $ x" isn't as easy to fix when you add another argument.
23:12:44 <iaefai_> I thank you all for the clarification, I have to delve into monads shortly and write it down this time around.
23:12:52 <dolio> Cale: lambdabot isn't in haskell-in-depth anymore.
23:13:05 <Cale> dolio: ah, I'll fix it
23:13:13 <dancor> also i think i spend all my time changing $ to . anyway
23:13:22 <dancor> under any of these schemes
23:13:53 <Cale> lambdabot: @join #haskell-in-depth
23:13:55 <iaefai_> Do you guys know where I can get some often used and free chess piece graphics?
23:14:05 <dancor> iaefai_: xboard?
23:14:58 <iaefai_> What is a 'bm' file?
23:15:25 <dancor> it doesn't sound good
23:16:13 <Jafet> > let fibs = [0, 1] ++ flip map [0..] (sum . (take 2) . (flip drop fibs)) in fibs
23:16:14 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:16:14 <iaefai_> xboard does shogi?
23:16:31 <dancor> iaefai_: probably http://en.wikipedia.org/wiki/X_BitMap ?  xboard uses that for the pieces?
23:16:37 <Cale> If I was going to guess, probably a literal one-bit-per-pixel bitmap.
23:17:01 <dancor> These options control what piece images xboard uses. The XBoard distribution includes one set of pixmap pieces in xpm format, in the directory pixmaps, and one set of bitmap pieces in xbm format, in the directory bitmaps.
23:17:04 <iaefai_> dancor: it is that
23:17:18 <jystic> do any of the haskell gui frameworks have issues with running stuff in other threads?
23:17:40 <kmc> gtk wants you to do all your gui calls in one thread
23:17:49 <Cale> jystic: Not usually as long as that stuff has nothing to do with the gui
23:17:50 <kmc> but provides a way to pass off an IO action to that thread from any other
23:18:34 <Cale> jystic: But I think all of them fall on their face if you try to make gui calls from multiple threads. It's basically because they're stupid C libraries underneath. ;)
23:18:44 <jystic> yeah i think that's pretty normal
23:18:45 <dancor> Seq is so cool
23:19:12 <dancor> i've never seen slicing that fast
23:19:16 <upsh9401> how do you hide operators, its giving me parse errors.
23:19:23 <jystic> as long as they're happy for me to do whatever i want in non ui threads
23:19:27 <dancor> the neural kinetics are way of the charts
23:19:43 <kmc> upsh9401, can you paste your code?
23:19:59 <dancor> i guess map has faster slicing in some situations
23:20:16 <hexpuem> is there a way to do parallel list comprehension with the Monad instance for []
23:20:22 <kmc> import Prelude hiding ((+), (*))
23:20:53 <upsh9401> I have "import Control.Applicative hiding (<|>)" that should work right?
23:21:06 <kmc> ((<|>))
23:21:11 <kmc> it's a parenthesized list of things to hide
23:21:22 <upsh9401> Oh
23:21:25 <kmc> the operator's name itself has parens, when used outside infix
23:21:37 <cloudhead> is there a way I can remove the zlib cabal package from my system?
23:21:45 <upsh9401> Makes sense now.
23:22:11 <dancor> hexpuem: like (mapM (\ xs -> [something x | x <- xs]) xss) ?
23:22:20 <mtnviewmark> oy - I forgot: "operator" is one of my trigger words... from when I did the Perl 6 Periodic Table of the Operators
23:23:06 <dancor> exeses
23:23:12 <mmorrow> cloudhead: ghc-pkg unregister deletes it's entry in the package.conf file, and then if you want to further delete it you have to find a zap the directory, it won't do it for you
23:23:16 <mmorrow> *its
23:23:36 <hexpuem> like do x <- [1,2]; y <- [3,4]; return (x,y) to Zip
23:23:40 <mmorrow> cloudhead: you need sudo if it's the global db, or not if its your home db
23:23:53 <cloudhead> mmorrow: thanks, that's exactly what I was looking for
23:24:21 <kmc> hexpuem, that's what a regular non-parallel list comprehension does
23:24:28 <hexpuem> yea
23:24:31 <kmc> > [ (x,y) | x <- [1,2], y <- [3,4] ]
23:24:32 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
23:24:33 <hexpuem> is there a way to do parallel
23:24:41 <copumpkin> yep
23:24:47 <kmc> oh, do you mean parallel as in Data Parallel?
23:24:52 <hexpuem> nah
23:24:57 <copumpkin> > [ (x, y) | x <- [1, 2] | y <- [3, 4] ]
23:24:57 <hexpuem> i just want to zip with Data.Seq
23:24:57 <lambdabot>   [(1,3),(2,4)]
23:25:02 <hexpuem> using the monad
23:25:12 <copumpkin> oh, not with the monad
23:25:23 <upsh9401> well you would have to use a differnt monad.
23:26:16 <copumpkin> people were just talking on cafe about the difficulties of making ZipList a monad
23:26:39 <upsh9401> :t <$
23:26:40 <lambdabot> parse error on input `<$'
23:26:45 <hexpuem> whys list comprehension limited to cons list anyway
23:26:45 <upsh9401> :t (<$)
23:26:46 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
23:27:18 <upsh9401> copumpkin: ZipList isnt a monad?
23:27:29 <dancor> are there monad comprehensions?
23:27:32 <copumpkin> not easily
23:27:37 <performance> the license for GHC is GPL right?
23:27:37 <copumpkin> there used to be monad comprehensions
23:27:37 <hexpuem> there used to be apparently
23:27:41 <copumpkin> prior to h98
23:27:46 <copumpkin> performance: bsd
23:27:54 <performance> thanks
23:28:03 <copumpkin> performance: there are gotchas though
23:28:30 <performance> copumpkin, like?
23:29:02 <gmaslov> i've been working with these types for generic decision trees, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11356#a11356 , but now i realize that it'd be nice to examine/print the tree after it's built (currently not possible with this opaque function type). However, i don't think it's possible to do something like "Choice (Map attributevalue (DecisionTree ...))". any suggestions?
23:29:10 <Cale> Like that by default it links your program against GMP which is an LGPL library
23:29:20 <copumpkin> performance: that GHC only performs static linkage until the unreleased 6.12
23:29:27 <copumpkin> and as Cale says, links you against GMP
23:29:58 <performance> well i'm making a package for VectorLinux and it requires me to state the license
23:30:07 <mtnviewmark> joy - Copy text from the context menu crashes Leksah on Mac OS X...
23:30:09 <upsh9401> :t mapError
23:30:09 <performance> so i guess BSD is good enough.
23:30:10 <lambdabot> Not in scope: `mapError'
23:30:28 <copumpkin> mtnviewmark: submit a bug?
23:30:36 <mtnviewmark> yeah - I'm just venting
23:30:39 <copumpkin> :)
23:33:21 <copumpkin> mtnviewmark: I bet I can guess where you're from!
23:33:32 <mtnviewmark> Brooklyn!!!!!
23:33:45 <jimmyjazz14> is it possible to extend or modify an instance of a class?
23:33:47 <copumpkin> damn!
23:33:59 <copumpkin> jimmyjazz14: hm, not even sure what you mean
23:34:08 <Cale> jimmyjazz14: Only by modifying the source code of the instance
23:34:11 <mtnviewmark> well, originally, at least -- I bet you can guess my current location, though
23:34:24 <copumpkin> mtnviewmark: sea view!
23:34:43 <Cale> jimmyjazz14: You can write a newtype wrapper around your type along with a completely new instance if you want.
23:35:08 <mmorrow> jimmyjazz14: it's the classes themselves that you extend or modify, rather than particular instances of a given class
23:35:16 <mtnviewmark> Ah yes, outside my window I enjoy the relaxing loll of the waves.....
23:35:26 <dancor> lol
23:35:33 <gmaslov> the loll of the waves... the wind roffling through the trees...
23:35:38 <copumpkin> lol
23:35:41 <upsh9401> Okay I know I just asked this a while a go but what is the opperatot that coresponds to: m `op` v = m >> return v?
23:35:53 <mmorrow> gmaslov: hah
23:36:22 <jimmyjazz14> Cale, that might be what I am looking for
23:37:06 <mmorrow> upsh9401: there isn't one for that in particular, since i wouldn't necessarily say doing that in particular is that common
23:37:38 <mmorrow> upsh9401: since it's a special case of when the result gets passed to v
23:38:44 <mmorrow> @type \f m -> [return . f =<< m, f `fmap` m, f `liftM` m, f <$> m]
23:38:45 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => (a1 -> a) -> m a1 -> [m a]
23:38:45 <_Ray_> Question. I have a function :: Integer -> Integer. I know it ends up cycling at some point, for all input values. I want to get the length of this cycle. Right now I'm using a buffer to keep track of every number it's produced, then searching this buffer on every iteration of the function with `elem`. Is there a less ugly way?
23:38:45 <lambdabot> _Ray_: You have 1 new message. '/msg lambdabot @messages' to read it.
23:39:03 <performance> how can i find the version of glib,gtk and gtksourceview on my machine?
23:39:21 <Cale> _Ray_: Using a Data.Set may be more efficient.
23:39:22 <performance> gtksourceview2
23:39:34 <mmorrow> @type [\f m->return.f=<<m, \f m->f`fmap`m, \f m->f`liftM`m, \f m->f <$> m]
23:39:35 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => [(a1 -> a) -> m a1 -> m a]
23:39:56 <_Ray_> Cale, oh, sorry. Assume fascist constraints (using nothing more complex than elem and length, no higher order functions, no lists by comprehension)
23:40:11 <Cale> _Ray_: Okay, then I don't see a better way.
23:40:18 <_Ray_> :(
23:40:26 <mmorrow> @type [($),id]
23:40:27 <lambdabot> forall a b. [(a -> b) -> a -> b]
23:40:32 <_Ray_> Evil assignment.
23:41:13 <Cale> _Ray_: wait, what do you mean by "cycling" in this case?
23:41:15 <sohum> wait wut
23:41:22 <sohum> oh, they both have the same sig, right
23:41:39 <mmorrow> right, the list is forcing their types to be unified
23:41:49 <upsh9401> mmorrow: ?? v is a value not a function.
23:41:50 <Cale> _Ray_: Do you mean that for any x, there is some number of iterations of f such that f (f (f... (f x)...)) = x ?
23:42:02 <_Ray_> Cale, say f(x) = y. f(y) = z. f(z) = w. f(w) = x. This has a cycle length of 2.
23:42:04 <_Ray_> Yes.
23:42:09 <cssingh> hi i need help in asp
23:42:22 <mmorrow> upsh9401: well, think of it as (f := const v)
23:42:24 <Cale> _Ray_: Oh, that's more tractable.
23:42:44 <_Ray_> Is it? I saw no better way than just accumulate in a buffer. But that seems un-functional and just messy.
23:42:45 <Cale> _Ray_: Just... use recursion directly then.
23:42:57 <kmc> > (0 :+ 0) ^2
23:42:58 <lambdabot>   0.0 :+ 0.0
23:42:58 <Cale> Don't bother with the buffer, just look for the original value.
23:43:00 <kmc> > (0 :+ 0) ** 2
23:43:01 <lambdabot>   NaN :+ NaN
23:43:05 <_Ray_> Hrm. Use a counter and add 1 with every recursion?
23:43:09 <kmc> oh right
23:43:14 <kmc> that 2 is complex
23:43:14 <mmorrow> @type \v m -> v <$ m
23:43:15 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
23:43:16 <upsh9401> mmorrow: its just that I asked earliar and they gave me something from Applicative.
23:43:19 <sohum> :t (:+)
23:43:20 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
23:43:27 <Cale> _Ray_: yeah
23:43:30 <mmorrow> upsh9401: actually i lied, (<$) does that ...
23:43:32 <mmorrow> :)
23:43:33 <_Ray_> But maybe it doesn't loop at the first iteration...I mean, f(x) = k. f(k) = z. f(z) = w. f(w) = k.
23:43:43 <mmorrow> upsh9401: forgot about (<$)
23:43:50 <_Ray_> If I search for x I won't ever find it
23:43:51 <upsh9401> Ah ok.
23:43:53 <mmorrow> well, flip (<$)
23:44:02 <Cale> _Ray_: That's what I asked you about
23:44:08 <_Ray_> (The function is 2*(product of digits))
23:44:13 <Cale> _Ray_: You said that it would make its way back to x :)
23:44:22 <mmorrow> @type flip (<$>) :: Monad m => m a -> b -> m b
23:44:22 <_Ray_> For some x in the sequence :)
23:44:23 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
23:44:23 <lambdabot>     In the expression: flip (<$>) :: (Monad m) => m a -> b -> m b
23:44:25 <mmorrow> @type flip (<$) :: Monad m => m a -> b -> m b
23:44:26 <lambdabot>     Could not deduce (Functor m) from the context (Monad m)
23:44:26 <lambdabot>       arising from a use of `<$' at <interactive>:1:5-8
23:44:26 <lambdabot>     Possible fix:
23:44:26 <_Ray_> (But for all starting values)
23:44:37 <mmorrow> @type flip (<$) :: (Functor m, Monad m) => m a -> b -> m b
23:44:38 <lambdabot> forall (m :: * -> *) a b. (Monad m, Functor m) => m a -> b -> m b
23:44:52 <mmorrow> @type (\m v -> m >> return v) :: (Functor m, Monad m) => m a -> b -> m b
23:44:53 <lambdabot> forall (m :: * -> *) a b. (Monad m, Functor m) => m a -> b -> m b
23:45:06 <_Ray_> For instance...99 -> 162 -> 24 -> 16 -> 12 -> 4 -> 8 -> 16 -> 12 -> ...
23:45:10 <gmaslov> i wonder why ($>) is missing
23:45:12 <mmorrow> @src (<$)
23:45:13 <lambdabot> (<$) = (<$>) . const
23:45:20 <Cale> _Ray_: Well, there's no better way then.
23:45:25 <_Ray_> So neither 99 nor 162 nor 24 will ever be seen again, but the rest will.
23:45:27 <mmorrow> @src (<$>)
23:45:27 <lambdabot> f <$> a = fmap f a
23:45:36 <Cale> _Ray_: at least not without knowing more about the structure of f
23:45:41 <upsh9401> gmaslov: seems like the more natural one.
23:45:50 <_Ray_> f is twice the product of the digits of its input
23:46:08 <Cale> Ah, hmm...
23:46:19 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11357#a11357 <-- f (yes, in spanish, but it's short =p )
23:46:35 <mmorrow> upsh9401, gmaslov: but if it went in that direction, it wouldn't be "Applicative" ;)
23:47:20 <mmorrow> (not that anything would change, just that that direction is less "apply-ish", and it's Applicative)
23:47:28 <mmorrow> *.. would change anything, ..
23:47:36 <sohum> _Ray_: I imagine you could do it with maintaining a list of what you've seen so far and when and a counter value. But yea, that doesn't seem very clean.
23:47:49 <_Ray_> sohum, that's what I'm doing now, but it's ugly...
23:48:10 <sohum> it shouldn't be /that/ ugly..
23:48:31 <_Ray_> It's building a buffer on each recursion...that seems C-ish as opposed to functional.
23:48:40 <Cale> _Ray_: yeah, if you need to know the length of the cycle for different values of f, then memoisation is the way to go
23:48:53 <iaefai_> thank you everyone, bless all
23:49:39 <upsh9401> Thanks all!
23:49:59 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11358#a11358 <-- this is the buffer version (mind you, this is ugly code and could be trimmed by about 30% easily, but still, the core is the buffer part)
23:50:20 <aeron> is there a better way to parse an int from a string than read myString :: Int?
23:50:47 <dmwit> aeron: yes
23:50:51 <aeron> if there is no need for error checking
23:50:57 <dmwit> reads :: String -> [(Int, String)]
23:51:07 <dmwit> If there's no need for error-checking, then read is the way.
23:51:12 <aeron> gotcha, thank you :)
23:51:31 <dmwit> If there's no need for error-checking, but there is a need for speed, then you may be interested in ByteString.
23:51:57 <aeron> dmwit - nope, just need to pull out an int from a guarenteed well-formed input
23:52:37 <Cale> _Ray_: Or: prove that for every integer n, the iterates of f will eventually reach one of [12,36,48]
23:52:58 <Cale> _Ray_: and then just use that theorem in the construction of your program ;)
23:53:22 <_Ray_> O.o it will?
23:53:32 <_Ray_> I proved that it will always cycle, but not to what :p
23:53:34 <Cale> Find me one where it doesn't ;)
23:54:00 <gmaslov> Cale you're a beast
23:54:01 <Cale> oh, I've only been looking at positive integers, is that okay?
23:54:46 <_Ray_> Yeah :)
23:54:59 <Cale> Let's try putting a bound on f n in terms of n
23:55:08 <Cale> For large enough n
23:55:38 <Cale> If we can show that f causes all large-enough values of n to decrease then we only have to search a small finite region.
23:56:38 <_Ray_> I had proven this a few weeks ago xD There was an easy bound. But it's 4am and my math skills are obliterated.
23:56:50 <_Ray_> I'll try to find a good bound in the morning :)
23:56:56 <Cale> I have one :)
23:57:33 <Cale> (I think... one sec
23:57:34 <Cale> )
23:58:30 <Cale> Well, if ceiling(log_10 n) = k, then the product of the digits of n is at most 9^k
23:58:58 <_Ray_> Right, yeah, it was something along those lines.
23:59:05 <Cale> and so f n is at most 2*9^k
23:59:43 <Cale> So we just have to find the smallest value n for which  2 * 9^(ceiling(log_10 n)) < n
