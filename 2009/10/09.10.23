00:01:11 <dmwit> I dunno, I can't really understand it that well. =P
00:02:14 <kyagrd> dancor: on the hackage package list http://hackage.haskell.org/packages/archive/pkg-list.html the package I just uplaoded quickcheck-poly description is ...
00:02:45 <kyagrd> kyagrd: I wrote the synopsis and description in .cabal file can you see what went wrong?
00:05:48 <kyagrd> Oh synopsis should be less than 80 chars
00:06:44 <zs> dmwit, this is confusing to me too
00:11:10 <kyagrd> I hope I am not breaking Hackage ...
00:13:08 <hackagebot> quickcheck-poly 0.1.0.1 - Automating QuickCheck for polymorphic and overlaoded properties (KiYungAhn)
00:39:14 <hackagebot> curry-frontend 0.2.8 - Compile the functional logic language Curry to several intermediate formats (BerndBrassel)
00:41:13 <ivanm> jfredett: I think the various curry releases have overtaken mine in release-spam (they just don't seem to have announcement emails all the time like I did...)
00:41:47 <kyagrd> Wow curry frontend
00:44:18 <pao> hi all :-)
00:44:23 <pao> :t (+1)
00:44:24 <lambdabot> forall a. (Num a) => a -> a
00:44:29 <pao> :t (-1)
00:44:30 <lambdabot> forall a. (Num a) => a
00:44:37 <dmwit> :t (subtract 1)
00:44:38 <lambdabot> forall t. (Num t) => t -> t
00:44:52 <pao> dmwit: thanks!!! no question required ;-)
00:44:56 <dmwit> =)
00:49:53 <Bynbo7> #Haskell: magically answering questions before they're asked
00:49:58 <Bynbo7> oh no!
00:55:11 <Jafet> Is it shift-your-nick day again?
00:55:18 <Jafet> Shifty people.
01:01:21 <hackagebot> quickcheck-poly 0.2.0.0 - Automating QuickCheck for polymorphic and overlaoded properties (KiYungAhn)
01:10:23 <hackagebot> quickcheck-poly 0.2.0.1 - Automating QuickCheck for polymorphic and overlaoded properties (KiYungAhn)
01:12:55 <Gracenotes> I am surprised to see that the phrase "endiest of end users", which I made up two minutes ago, has some Google results. in fact, it has exactly one Google result.
01:14:33 <Axman6> that's a google whack :D
01:19:32 <zs> so i have np [] = []; np (x:xs) = [x] : l : map (x:) l where l = np xs
01:19:32 <zs>  
01:20:17 <zs> i'm getting     Occurs check: cannot construct the infinite type: a = [a]
01:21:02 <fasta> zs: [[]]
01:22:04 <zs> fasta: what do you mean?
01:22:04 <maltem> zs: if l :: [a], then   l : map (x:) l   would have to be both of type [a] and [[a]]
01:22:24 <fasta> zs: I made a wrong suggestion. I will have a better look.
01:23:08 <maltem> zs: because it would be a list the first element of which is l
01:23:51 <maltem> maybe you wanted ++ somewhere
01:24:28 <fasta> zs: np [] = []
01:24:28 <fasta> np (x:xs) = [x] : l ++ map (x:) l
01:24:28 <fasta>   where l = np xs
01:24:49 <fasta> zs: it compiles like this, not sure what you want with it, though.
01:25:58 <fasta> zs: errors like these basically mean that the compiler has proven that a and [a] must be the same type. In some cases that's what you want, just not this one.
01:26:27 <fasta> Oh, and by some I mean in about 3% of the cases ;)
01:27:12 <int-e> And in those cases you can still get (almost) what you want with a newtype.
01:28:10 <int-e> "Almost" because you'll have to pack and unpack the newtype explicitely, which can get tedious.
01:28:40 <fasta> Yes, I can speak from experience that this is tedious.
01:29:12 <fasta> A special function saying "I really want to have infinite types here" would be nice.
01:29:25 <zs> fasta, thanks
01:29:57 <fasta> zs: I think this is btw a scanl.
01:30:22 <zs> oh?
01:30:24 <fasta> zs: or a mapAccumL, they are about the same in some sense.
01:30:59 <fasta> zs: anyway, figure it out for yourself, that will get you more out of it. Also, it's better for trivial questions to specify what you want in natural language first.
01:32:17 <zs> fasta, changing to ++ works, as  np "abc" gets ["a","b","c","bc","ab","ac","abc"]
01:32:34 <zs> which are non empty sequences
01:40:25 <maltem> > init (tails "abc") >>= tail . inits
01:40:26 <lambdabot>   ["a","ab","abc","b","bc","c"]
01:43:54 <Axman6> > sort (init (tails "abc") >>= tail . inits)
01:43:56 <lambdabot>   ["a","ab","abc","b","bc","c"]
01:44:09 <Axman6> > sort (init (tails "abc testing") >>= tail . inits)
01:44:11 <lambdabot>   [" "," t"," te"," tes"," test"," testi"," testin"," testing","a","ab","abc"...
01:44:56 <oteren> @source tails
01:44:57 <lambdabot> tails not available
01:45:12 <Axman6> > tails [1..4]
01:45:13 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
01:45:33 <oteren> aha
01:46:28 <Axman6> i always think the first list there shouldn't be there
01:46:34 <Axman6> since it's not a tail
01:46:52 <Axman6> forall xs. tail xs /= xs
01:47:35 <maltem> tails = iterate tail (until there's no tail anymore)
01:48:18 <Axman6> anyone ever played with unix select?
01:48:23 <Gracenotes> tails and inits-ing often are tail'd and init'd themselves
01:48:37 <c_wraith> Axman6: I have, and I'm sure many others have too.
01:48:56 <c_wraith> Axman6: But any recent time has been with a wrapper like libev.  It's just easier that way.
01:49:02 <Axman6> well, they look like they suck quite a bit. not looking forward to having to use them tomorrow
01:49:22 <Axman6> i'm sure it is. sadly assignments don't let you use such nicities
01:49:46 <Axman6> niceties even
01:50:10 <c_wraith> select isn't horrible, except for the argument that is "an upper bound of the file descriptors you passed in"
01:50:23 <c_wraith> That's such a dumb thing to include as a required argument.
01:51:07 <c_wraith> Because for one, it requires you to stop thinking of file descriptors as opaque handles, and realize they're ints given out sequentially (per process)
01:51:18 <Botje> select() sucks, use epoll() !
01:51:41 <c_wraith> And then it's pretty pointless as an optimization to require that an upper bound be passed in, rather than just look at what's actually in the list.
01:51:51 <Axman6> i'm supposed to be listening for connections on one of either a pipe or a socket
01:51:59 <c_wraith> Also, select does have scaling issues at thousands of file descriptors...
01:52:06 <c_wraith> Mostly because of the linear searches it involves
01:52:16 <c_wraith> Which is where replacements like epoll come into play
01:52:25 <zs> so if tails and init works , why isn't Data.List's nonEmptySequence defined this way?
01:52:45 <c_wraith> and nice libraries like libevent or libev, which abstract out the exact backend mechanism they use.
01:52:48 <zs> nonEmptySubsequences (x:xs)  =  [x] : foldr f [] (nonEmptySubsequences xs)
01:52:49 <zs>   where f ys r = ys : (x : ys) : r
01:52:49 <zs>  
01:53:05 <zs> is it more efficient?
01:53:10 <Axman6> :t nonEmptySubsequences
01:53:12 <lambdabot> Not in scope: `nonEmptySubsequences'
01:53:18 <Axman6> :t Data.List.nonEmptySubsequences
01:53:19 <lambdabot> Not in scope: `Data.List.nonEmptySubsequences'
01:53:22 <Axman6> :\
01:54:04 <Botje> zs: that use of foldr looks an awful lot like concatMap.
01:54:30 <zs> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#permutations
01:54:58 <c_wraith> I rather heavily modified a libev python wrapper for a project I did a while back involving green threads and using non-blocking IO to simulate blocking IO with multiple true threads.  That was a fun diversion.
01:55:53 <c_wraith> (I added proper re-entrant exception handling to the wrapper.  The library supported it, but the wrapper author apparently didn't like the idea.)
01:57:11 <medfly> I have really noob questions to ask, so I'll apologise for the noobness that will follow in advance=)
01:57:43 <maltem> zs: For the recursive definition it's more handy to not have the empty subsequence in there. But the exported function "subsequences" adds [] so it does what its name suggests
01:59:38 <medfly> I'm trying to use Network, I haven't done anything of that sort before, I'm trying to make something listen and output what it receives and have another thing send some stuff to it, to figure this out. I checked netstat and it looks like the handshake isn't complete, what should I do to make it complete?
01:59:38 <medfly> :s
02:00:01 <medfly> it may be really silly and vague, sorry :o
02:00:15 <c_wraith> medfly, are you on a unix?
02:00:18 <zs> medfly: is that better than Axma6's init(tails "abc") >>= tail.inits?
02:00:18 <medfly> yes
02:00:26 <c_wraith> do you know how to use netcat?
02:00:33 <medfly> no, sorry
02:00:43 <c_wraith> It's a really handy tool for helping test things like that.
02:01:18 <medfly> do netcat -l -p (myport) ?
02:02:00 <c_wraith> that's to run a server
02:02:03 <medfly> oh
02:02:13 <c_wraith> to connect to a server, just do netcat host port
02:02:16 <medfly> that explains why it fails
02:02:21 <medfly> okay, thanks
02:02:47 <c_wraith> also, as an example of a *really* dumb use of Network, here's a little joke program I put together:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9809
02:03:42 <medfly> thanks
02:03:52 <medfly> what's `finally`?
02:03:58 <c_wraith> :t finally
02:03:59 <lambdabot> Not in scope: `finally'
02:04:11 <c_wraith> meh.  It's Control.Exception finally
02:04:21 <c_wraith> It runs one action, then it runs another.
02:04:36 <medfly> thanks. I'll try to figure this out :)
02:04:38 <c_wraith> It runs the second action regardless of whether the first one finished successfully or not
02:04:59 <jre2> where successfully means didn't throw an exception
02:05:11 <c_wraith> since that example uses "forever", the only way out of that part is by killing it with a signal or ctrl-c
02:05:23 <c_wraith> both of those cause exceptions to be thrown internally
02:05:35 <c_wraith> So the finally bit cleans up when that happens
02:06:09 <c_wraith> (ok, SIGKILL kills it without any chance to clean up.  but it cleans up after itself on other signals)
02:07:38 <hackagebot> lazysmallcheck 0.4 - A library for demand-driven testing of Haskell programs (MatthewNaylor)
02:13:21 <mmorrow> , let fib n = let phi1=(1+sqrt 5)/2;phi2=(1-sqrt 5)/2;phi3=phi1-phi2 in floor((phi1^n-phi2^n)/phi3) in fmap fib [0..]
02:13:23 <lunabot>  [0,1,1,2,3,5,8,13,21,34,54,89,143,232,377,610,986,1596,2584,4181,6764,109...
02:14:23 <mmorrow> @let fibAt n = let phi1=(1+sqrt 5)/2;phi2=(1-sqrt 5)/2;phi3=phi1-phi2 in floor((phi1^n-phi2^n)/phi3)
02:14:24 <lambdabot>  Defined.
02:14:36 <mmorrow> > fibAt 1000000
02:14:37 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
02:14:55 <Gracenotes> that's the Integer way of saying Infinity, isn't it? :)
02:15:22 <mmorrow> , fix ((0:) . scanl (+) 1) !! 1000000
02:15:24 <lunabot>  Stack space overflow: current size 8388608 bytes.
02:15:24 <lunabot>  Use `+RTS -Ksize' to increase it.
02:15:45 <mmorrow> , (let fib !m !n = m : fib n (m+n) in fib 0 1) !! 1000000
02:15:52 <lunabot>  Killed.
02:15:55 <c_wraith> isn't phi2^n always less than phi3?
02:16:09 <mmorrow> , (let fib !m !n = m : fib n (m+n) in fib 0 1) !! 1000
02:16:10 <lunabot>  4346655768693745643568852767504062580256466051737178040248172908953655541...
02:16:15 <mmorrow> > fibAt 1000
02:16:16 <lambdabot>   434665576869373362581838031072093641655828166009266380758517484743763125194...
02:16:34 <mmorrow> , ((1+sqrt 5)/2)^2
02:16:35 <c_wraith> heh.  fp error
02:16:35 <lunabot>  2.618033988749895
02:16:39 <mmorrow> , ((1-sqrt 5)/2)^2
02:16:40 <lunabot>  0.3819660112501052
02:16:56 <ManateeLazyCat> @seen dcoutts_
02:16:56 <lambdabot> Unknown command, try @list
02:17:12 <mmorrow> @let fibAt' n = let phi1=(1+sqrt 5)/2;phi2=(1-sqrt 5)/2;phi3=phi1-phi2 in (phi1^n-phi2^n)/phi3
02:17:13 <lambdabot>  Defined.
02:17:23 <mmorrow> > fmap fibAt' [0..]
02:17:24 <lambdabot>   [0.0,1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,54.99999999999999,89.0,143.9999...
02:17:35 <mmorrow> should've used round
02:17:45 <mmorrow> @undefine
02:17:53 <c_wraith> nah, look how differet the results for 1000 are
02:18:07 <c_wraith> you've exceeded the resolution you get from fp
02:18:12 <mmorrow> sucky
02:18:20 <medfly> what's fp here?
02:18:23 <mmorrow> well, might as well make it Int then
02:18:25 <c_wraith> floating point
02:18:35 <medfly> thanks
02:18:38 <mmorrow> @let fibAt n = let phi1=(1+sqrt 5)/2;phi2=(1-sqrt 5)/2;phi3=phi1-phi2 in round((phi1^n-phi2^n)/phi3)::Int
02:18:39 <lambdabot>  Defined.
02:18:54 <mmorrow> @undefine
02:18:59 <mmorrow> @let fibAt n = let phi1=(1+sqrt 5)/2;phi2=(1-sqrt 5)/2;phi3=phi1-phi2 in round((phi1^n-phi2^n)/phi3)
02:19:00 <lambdabot>  Defined.
02:19:01 <mmorrow> whatever
02:19:12 <dancor> it ruins my life that:  instance Parsable (Thing, WS) ..  is considered overlapping with  instance (Parsable a) => Parsable (a, WS) ..   when there is no Parsable Thing instance.
02:19:32 <ManateeLazyCat> I have two Object: A and B, I want implement some 'hook' for B, make those hook run in function of B, then A can add some function to those `hook`, and B know nothing about A.
02:19:44 <mmorrow> ooh, i can use MFR
02:19:47 <mmorrow> *MPFR
02:19:48 <c_wraith> dancor: just turn on overlapping instances and try not to think about it too much.
02:19:58 <ManateeLazyCat> Question is i don't know how to create those hook
02:20:16 <ManateeLazyCat> If use unsafePerformIO, i crete global variable, that's not safe.
02:20:50 <dancor> c_wraith: i don't think the OverlappingInstances extension affects this
02:20:57 <dancor> i tried turning it on
02:21:10 <mmorrow> ManateeLazyCat: by "add", do you mean when you create these objects, or dynamically after they've been created?
02:21:16 <c_wraith> IncoherentInstances?  I was sure there was an extension that allowed things like that.
02:21:48 <ManateeLazyCat> mmorrow: `hook` like Gtk+ signal callback.
02:21:56 <mmorrow> ah, ok
02:22:04 <hackagebot> lazysmallcheck 0.5 - A library for demand-driven testing of Haskell programs (MatthewNaylor)
02:22:11 <dancor> UndecidableInstances?  doesn't seem to change anything either
02:22:28 <c_wraith> Hmm.  That does suck, then
02:22:31 <mmorrow> ManateeLazyCat: you could use a Reader monad where the environment is an IORef
02:22:44 <mmorrow> ManateeLazyCat: and use atomicModifyIORef
02:23:14 <mmorrow> newtype M env a = M (IORef env -> a)
02:23:23 <ManateeLazyCat> mmorrow: I want A call hook of B, but B don't which call those hook, then i can fix recursive reference problem between different modules.
02:24:13 <mmorrow> ManateeLazyCat: what's the "identifier" (or whatever) that you're using so that an object A can refer to an object B?
02:24:27 <mmorrow> as in, what's its type?
02:24:33 <mmorrow> (the type of the identifier)
02:24:38 <ManateeLazyCat> mmorrow: Wait, i paste my code.
02:24:50 * ManateeLazyCat pasted "IORefObject.hs" at http://paste2.org/get/481008
02:24:54 <ManateeLazyCat> mmorrow: Above is IORefObject.hs
02:25:04 <ManateeLazyCat> It's center control module of my project.
02:25:15 * ManateeLazyCat pasted "Page.hs" at http://paste2.org/get/481009
02:25:33 <ManateeLazyCat> mmorrow: Above is Page.hs, that reference IORefObject.hs
02:25:47 <mmorrow> what i'm thinking is that the "env" type contains some sort of Map from object identifiers to collections of callbacks that object owns
02:26:03 * mmorrow looks
02:26:12 <ManateeLazyCat> mmorrow: So question is IORefObject reference many other module, like UI.View, UI.ViewNOde, UI.Page, and those module also reference IORefObject.
02:26:49 <ManateeLazyCat> mmorrow: So i will occur recursive reference problem when those module too many.
02:27:35 <ManateeLazyCat> mmorrow: So i want define some callback in Page.hs.
02:28:09 <ManateeLazyCat> mmorrow: Then IORefObject call those callback, and Page don't need know which module (IORefObject) call those callback.
02:28:33 <ManateeLazyCat> mmorrow: Then Page don't need reference IORefObject.hs
02:28:43 * ksf is listening to http://chaosradio.ccc.de/cre130.html (german alert)
02:29:13 <ksf> the point is that gitit should definitely come with an interface to exchange stuff between repositories.
02:29:16 <ManateeLazyCat> mmorrow: But i don't know how to define those callback in Page.hs
02:30:13 <ManateeLazyCat> mmorrow: I only can think is use `unsafePerformIO` define callback of Page.
02:30:28 <dancor> c_wraith: ok nm, rm -rf dist/ and recompile did work
02:31:18 <ManateeLazyCat> mmorrow: If i define `Page callback` in IORefObject, i still need reference IORefObject in Page.hs file.
02:32:32 * dancor unruined
02:33:25 <mmorrow> ManateeLazyCat: ok. so i think the only way to get around this problem is by parameterization of the type IORefObject by the types of ViewList and ViewNodeList
02:33:30 <c_wraith> good, good.  even if still a bit strange
02:34:12 <c_wraith> anyway, really too late for me to be awake.  Even if I didn't actually get around to using what I learned about parsec tonight.
02:34:36 <ManateeLazyCat> mmorrow: parameterization?
02:34:36 <ManateeLazyCat>  
02:34:53 <ManateeLazyCat> mmorrow: You mean split IORefObject?
02:35:02 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4466#a4466
02:35:15 <mmorrow> well, actually there's also another solution
02:35:28 <mmorrow> you have a *single* module containing the type definitions of
02:35:37 * EvilTerran burbles about categories
02:35:37 <mmorrow> IORefObject, ViewNode, ViewNodeList
02:36:02 <mmorrow> then you can avoid needing to parameterize IORefObject by viewlist viewnodelist
02:37:27 <mmorrow> ManateeLazyCat: this is the second option http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4466#a4467
02:37:35 <quicksilver> mmorrow: viewnode and viewnodelist don't need the IORefObject type do they?
02:37:55 <quicksilver> mmorrow: can't you put ViewNode and ViewNodeList (just the types) in "ViewTypes.hs", and have that imported into IORefObject.hs ?
02:38:21 <mmorrow> quicksilver: i believe they do use IORefObject
02:38:33 <mmorrow> which is the root of the problem here
02:38:55 <mmorrow> s/problem/challenge/
02:39:35 <mmorrow> since different components need to communicate with others via writing callback function references into the callback lists of others
02:39:40 <mmorrow> (from my understanding)
02:40:04 <quicksilver> mmorrow: they use it in their types?
02:40:09 * quicksilver ponders
02:40:14 <mmorrow> quicksilver: i'm not sure yet, i haven't seen the def
02:40:38 <mmorrow> quicksilver: yeah, at first i was like "oh, well just simply ... err, crap .."
02:41:56 <ManateeLazyCat> mmorrow: I have send to you source code.
02:42:02 <mmorrow> i think the two options are (1) parameterize IORefObject by viewlist/viewnodelist, or (2) centralize all data declarations (assuming ViewNode and ViewNodeList mention IORefObject in their types)
02:42:30 <ManateeLazyCat> quicksilver: Can you help me review my source code?
02:42:46 <ManateeLazyCat> quicksilver: If you want, i can send you source code of my project..
02:43:30 <ManateeLazyCat> mmorrow: IORefObject for communicate with others component.
02:43:30 <quicksilver> ManateeLazyCat: I think it's too big :)
02:43:36 <ManateeLazyCat> quicksilver: Yes.
02:43:41 <dancor> ManateeLazyCat: also why isn't it already opensource! ;)
02:43:51 <quicksilver> ManateeLazyCat: have you pasted the code which includes the definitions of the types ViewList and ViewListNode?
02:43:55 <dancor> + available on web
02:43:55 <ManateeLazyCat> quicksilver: Total 54 files.
02:44:14 <ManateeLazyCat> dancor: Because not ready.
02:44:27 <ManateeLazyCat> dancor: Now i haven't stable time to manager project.
02:44:40 <ManateeLazyCat> dancor: I will release it when i have stable time.
02:45:23 <ManateeLazyCat> dancor: I will kill myself project if i haven't time manager it.
02:45:30 <ManateeLazyCat> dancor: Now i just have little time to write it.
02:48:24 <ManateeLazyCat> mmorrow: Core.hs Reboot.hs under Root directory is for recompile project and don't need reboot.
02:48:44 <ManateeLazyCat> mmorrow: `Data` subdir is pure Data Structure library.
02:48:57 <ManateeLazyCat> mmorrow: `Event` subdir is for event handle.
02:49:13 <ManateeLazyCat> mmorrow: `Keymap` is for manager local or global keymap.
02:49:41 <ManateeLazyCat> mmorrow: `PageMode` subdir is for load different mode in page, such as, Haskell-Mode, C-Mode, Terminal-Mode. etc.
02:50:21 <ManateeLazyCat> mmorrow: `PageView` is Gtk+ implement different type page, such as, editor, temrinal, file-manger.
02:50:40 <ManateeLazyCat> mmorrow: `State` subdir for keep State through reboot.
02:51:25 <ManateeLazyCat> mmorrow: `UI` subdir for UI graphics, and those module is *bad*, too close with IORefObject.hs
02:51:45 <ManateeLazyCat> mmorrow: `Utils` and `Widget` is some utils functions, you can ignore it.
02:52:25 <ManateeLazyCat> mmorrow: IORefObject.hs is `state reference` that communicate other modules.
02:53:01 <ManateeLazyCat> mmorrow: If you want compile my project, you can download darcs version of gtk2hs.
02:59:21 <xcoder42> okay, just got stuck on a completely newbie problem, i have a function getTYpe (v:vs) = ... which i need to check if contains of v.. if its a '(' i need to do something.. if its '[' i need to do something else. i tried getType (v:vs) = case v of '(' -> x = do_something() .. but this doesnt seem to work
02:59:51 <quicksilver> it looks fine up until "x = "
03:00:02 <quicksilver> the idea of using 'case' to check whether v is a ( is fine.
03:00:14 <quicksilver> (although there may be shorter ways to write that)
03:00:24 <quicksilver> but what are you trying to do with "x = do_something()" ?
03:00:34 <xcoder42> my function is a getTypes :: (Monad m) => Variable -> m Term
03:00:41 <xcoder42> so do:s
03:00:52 <xcoder42> do_something() should return some type of Term
03:00:58 * ManateeLazyCat I hope i can opensource my project quickly, but now i just have time write it. 
03:01:02 <xcoder42> which is passed back to my parser
03:01:18 <quicksilver> xcoder42: it's the "x =" bit that is wrong.
03:01:27 <quicksilver> xcoder42: that's not valid in that context.
03:01:38 <quicksilver> are you trying to do an assignment to a variable? haskell variables are not assignable.
03:02:08 <quicksilver> getType (v:vs) = case v of '(' -> do_something; '[' -> do_something_else;
03:02:13 <quicksilver> for example.
03:02:15 <xcoder42> i know, i'm still  a bit new to FP, so i often try OO metods to solve problems
03:02:57 <xcoder42> okay, but how does the do_something then return to the function that called getTypes?
03:03:09 <quicksilver> it just does.
03:03:13 <quicksilver> that's how it works.
03:03:15 <ManateeLazyCat> Maybe i need paste my source code to haskell-cafe mailing, then have many people help me.
03:03:20 <quicksilver> you are building up an expression.
03:03:31 <quicksilver> getType (v:vs) = case v of '(' -> 0
03:03:39 <xcoder42> oh ok quicksilver, let give that a try
03:03:41 <quicksilver> would mean that getType returns 0, if v is a '('
03:03:44 <quicksilver> similarly
03:03:47 <quicksilver> getType (v:vs) = case v of '(' -> do_something
03:04:03 <quicksilver> means that getType returns whatever do_something returns
03:04:03 <quicksilver> (if v is a '(')
03:04:07 <quicksilver> you will probably need other cases for '[' etc etc
03:04:18 <xcoder42> makes sense, i just need to get a better hand on FB logic :)
03:04:29 <xcoder42> great, i'll try that, thanks
03:14:42 * ManateeLazyCat Have paste my problem and source code to haskell-cafe, hope people can help me improve design.
03:17:35 <ManateeLazyCat> dancor: If you interested, you can download manatee-0.8.8 from haskell-cafe now, just for test and have bug. :)
03:20:34 <mmorrow> ManateeLazyCat: ok. so the actual types alone aren't recursive, which means you can make single "Types" module containing only the definitions of each one
03:21:03 <mmorrow> ManateeLazyCat: i made some notes http://moonpatio.com/manatee_imports/
03:21:13 <Bacta> Do people seriously develop web apps in this horrid horrid language?
03:21:18 <mmorrow> (two of the files are just graph data as [(String,[String])]
03:21:20 <mmorrow> )
03:21:29 <ManateeLazyCat> mmorrow: yes, now not recursive, it's recursive in my new branch.
03:21:41 <Bacta> It's great for Project Euler problems but other stuff?
03:21:44 <mmorrow> ManateeLazyCat: but here's the type dep graph of your types http://moonpatio.com/manatee_imports/TYPES.png
03:21:46 <ManateeLazyCat> mmorrow: Looks how many .hs-boot files in my project.
03:21:53 <mmorrow> which is *not* recursive
03:22:06 <ManateeLazyCat> mmorrow: Yes, i know.
03:22:17 <ManateeLazyCat> mmorrow: I send you old version for compile.
03:22:22 <mmorrow> oh
03:22:26 <ManateeLazyCat> mmorrow: In new version, it recursive.
03:22:32 <mmorrow> ah, ok
03:22:41 <mmorrow> what are the type definitions of those?
03:22:45 <ManateeLazyCat> mmorrow: However, too many .hs-boot file is point bad design.
03:23:25 <mmorrow> i think you just have to move _only the definitions of the types_ to a single *regular* haskell module
03:24:26 <ManateeLazyCat> mmorrow: If i move all definitions to *single* module, it's will too big.
03:24:35 <mmorrow> so e.g., "data IORefObject = ...; ....; data ViewNode = .." would all be in Manatee.Types
03:24:40 <ManateeLazyCat> mmorrow: BTW, http://moonpatio.com/manatee_imports/TYPES.png is cool.
03:24:42 <quicksilver> ManateeLazyCat: only the type definitions.
03:24:54 <mmorrow> ManateeLazyCat: heh, yeah i love those graphs :)
03:25:09 <mmorrow> ManateeLazyCat: yeah, only the type _definitions_
03:25:12 <mmorrow> nothing else
03:25:18 <quicksilver> mmorrow: as a point of style I'd probably use put the view types but *not* IORefObject in one file.
03:25:26 <quicksilver> mmorrow: because it's not related and they don't need it.
03:25:32 <ManateeLazyCat> mmorrow: If GHC team give user graphics, it will better than text info for recrusive reference.
03:25:53 <mmorrow> quicksilver: well, IORefObject references ViewNode and ViewNodeList, and vice-versa, so they at least need to be in the same module
03:26:09 <quicksilver> mmorrow: not in your graph?
03:26:25 <mmorrow> quicksilver: he said in his new version though they're recursive
03:26:33 <ManateeLazyCat> mmorrow: Trust me, if i move all define to *single* module, it will huge, i will add many module in the feature.
03:27:05 <quicksilver> well in fact it doesn't have to be one file although it can be
03:27:09 <mmorrow> ManateeLazyCat: Manatee.Types would literally be only this http://moonpatio.com/manatee_imports/Types.hs
03:27:11 <quicksilver> the point is to separate the types from the functions.
03:27:43 <mmorrow> ManateeLazyCat: err, sorry. i don't mean to say the definitions of all those ones i just stuck at the top need to be in there
03:27:57 <ManateeLazyCat> So key is not move some define to fix recursive, i need some solution to improve design that avoid depend so close.
03:29:51 <ManateeLazyCat> mmorrow: If i don't improve design, i can't fix anything when project bigger and bigger.
03:30:12 <mmorrow> err, actually you'd also need to put those defs in that module too
03:30:32 <mmorrow> since that's the minimum i needed to load that Types.hs in ghci
03:31:54 <ManateeLazyCat> mmorrow: You mean i create Type.hs (like http://moonpatio.com/manatee_imports/Types.hs), then make all define move in Type.hs?
03:32:00 <mmorrow> ManateeLazyCat: i'll look through it/think about possible ways to restructure it a little later, and let you know what i come up with.
03:32:07 <mmorrow> ManateeLazyCat: exactly.
03:32:26 <mmorrow> that would solve the problem completely
03:35:36 <mmorrow> ("that" := move the defines into a Manatee.Types)
03:37:04 <ManateeLazyCat> mmorrow: How about functions reference? Now IORefObject call View.hs functions, and vice-versa.
03:37:30 <mmorrow> right, so now in Manatee.IORefObject you have
03:37:49 <mmorrow> module IORefObject where import Manatee.Types; import ...
03:37:57 <mmorrow> and in  View you have
03:38:12 <mmorrow> module Manatee.View where import Manatee.Types; ...
03:38:33 <mmorrow> err, i meqnt
03:38:35 <mmorrow> *meant
03:38:39 <mmorrow> module IORefObject where import Manatee.Types; import ...
03:38:40 <quicksilver> "IORefObject call View.hs functions" <- this sounds wrong. The IORefObject is a simple structural container. It should probably not call functions from View.hs in my opinion.
03:38:48 <mmorrow> module Manatee.View where import Manatee.Types; import Manatee.IORefObject; ...
03:38:50 <mmorrow> module IORefObject where import Manatee.Types; import ...
03:39:10 <mmorrow> so IORefObject doesn't need to reference or know about Manatee.View
03:39:26 <mmorrow> "IORefObject" in that sentence being the module
03:40:28 <mmorrow> oh, i see
03:41:28 <ManateeLazyCat> mmorrow: If IorefObject don't need import Manatee.View, how do it find View.hs functions?
03:41:55 <mmorrow> ManateeLazyCat: so any functions you have that *really* do need to reference functions in Manatee.IORefObject *and* Manatee.View, you'd also need to put in Manatee.Types (for better or for worse)
03:42:15 <ManateeLazyCat> quicksilver: Now, situation is very complicated, if i don't fix design now, it will be worse.
03:42:29 <mmorrow> ManateeLazyCat: basically the idea here is to use Manatee.Types *like* it's a boot module
03:42:39 <quicksilver> ManateeLazyCat: I understand, which is why I am giving you advice on how to fix the design.
03:43:07 <quicksilver> my instincts tell me that IORefObject.hs - if it needs to exist at all - should contain simple structural functions for manipulating the IORefObject structure.
03:43:16 <quicksilver> it certainly shouldn't need to call functions from View.hs
03:44:05 <ManateeLazyCat> quicksilver: Problem is IORefObject structural contain View.hs structural, anyway you need reference View.hs functions.
03:44:13 <mmorrow> ManateeLazyCat: so questions of design aside, it becomes a purely mechanical process to move all things (defines or functions) that would cause a cycle into Manatee.Types
03:44:32 <ManateeLazyCat> mmorrow: Yeah.
03:45:23 <ManateeLazyCat> quicksilver: Example, ioRefObjectViewList is View List, so anyway you need some View.hs functions to maintains ViewList.
03:45:53 <Saizan> ?bug
03:45:54 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:45:56 <ManateeLazyCat> mmorrow: Just move all things in *single* module is not best way.
03:47:29 <hackagebot> Stream 0.4.1 - A library for manipulating infinite lists. (WouterSwierstra)
03:47:36 <ManateeLazyCat> mmorrow: dcoutts_ give me suggestion yesterday, that create callback in Page.hs and View.hs, then IORefObject just call those callback, and make Page.hs and View.hs don't import IORefObject.
03:47:55 <mmorrow> ManateeLazyCat: right, it's definitely not ideal here. basically, your two options are (1) use .hs-boot files, or (2) move the minimal subset of your code that causes a cycle into Manatee.Types
03:48:01 <ManateeLazyCat> mmorrow: Then Page.hs and View.hs can run those callback and know nothing about IORefObject.
03:48:16 <mmorrow> ManateeLazyCat: if (2) ends up being 50% of the entire thing, then maybe (1) is a better option
03:48:55 <ManateeLazyCat> mmorrow: I worried (2) option can't fix problem when my project bigger and bigger.
03:48:55 <mmorrow> well, if (2) ends up being 50% of the entire code, re-design may be a good way to go too
03:49:06 <mmorrow> right, i'd be worried about that too.
03:49:45 <mmorrow> i don't really think (2) is an option *if* you have to also put functions in Manatee.Types
03:50:06 <ManateeLazyCat> mmorrow: Like current .hs-boot solution for GHC, in fact, it can fix recursive problem, but when project is too big, developer is very hard to find recursive path.
03:50:14 <mmorrow> because then all your abstraction gets destroyed
03:50:33 <ManateeLazyCat> mmorrow: If you change any point in current recursive path, you will got another recursive path, until make you crazy.....
03:50:41 <mmorrow> heh
03:51:03 <ManateeLazyCat> mmorrow: Another perfect solution is patch to GHC. :)
03:51:13 <ManateeLazyCat> mmorrow: Never use .hs-boot file.
03:51:23 <mmorrow> ManateeLazyCat: true, that's another solution :)
03:51:26 <ManateeLazyCat> mmorrow: Now i haven't enough time to hacking GHC.
03:51:58 <ManateeLazyCat> mmorrow: If GHC can help me remove .hs-boot file forever, i can continue even too close reference is bad design.
03:52:12 <ManateeLazyCat> because i don't need it will compile failed by recursive problem.
03:52:22 <mmorrow> ManateeLazyCat: from my understanding of ghc, recursive modules haven't been added yet because it would basically require a complete rewrite of all of the compilation driving logic
03:52:24 <ManateeLazyCat> s/need/need worried
03:52:45 <mmorrow> ManateeLazyCat: which is unfortunate, but true nonetheless
03:53:30 <ManateeLazyCat> mmorrow: And i heard some haskellers said: GHC is not module enough.
03:53:37 <mmorrow> well, maybe not a *complete* rewrite, but definitely very significant changes
03:54:50 <mmorrow> ManateeLazyCat: the real problem/issue here is that haskell's module system is very basic, compared to e.g. *ML
03:54:58 <ManateeLazyCat> mmorrow: Another question, i use `unsafePerformIO` define `hook` in Page.hs and View.hs, then IORefObject call those hook, and make View.hs and Page.hs don't need import IORefObject, but that's including another problem, i create `global variable.
03:56:17 <mmorrow> ManateeLazyCat: ah right. i'll read through it a little later then give you my thoughts, but i've got to go now though :)
03:56:26 <ManateeLazyCat> mmorrow: Like Gtk+ library define callback, define `global variable` hook, then View.hs and Page.hs can run those hook and know nothing about IORefObect.
03:57:06 <mmorrow> the "standard" solution to that problem is usually to create an all-encompassing monad, that pipes everything like that around
03:57:07 <ManateeLazyCat> mmorrow: Okay, leave message here, i have to dinner now, 10 minis back.
03:57:53 <ManateeLazyCat> mmorrow: `global hook` maybe is better solution to fix recursive reference.
03:58:05 <ManateeLazyCat> mmorrow: Even GHC need .hs-boot file now.
03:58:52 <ManateeLazyCat> mmorrow: I'm curious why some many haskellers never occur same problem like me? Maybe them just write PURE code. :)
03:59:21 <ManateeLazyCat> mmorrow: brb, 10 minutes back.
04:00:56 <SamB_XP> ManateeLazyCat: oh, I usually get frustrated with my GUI apps long before where you are, and before that I go to great pains to avoid huge recursive messes
04:01:40 <dnivra> where can i download the past issues of the monad reader in pdf?
04:01:42 <SamB_XP> JHC's base always saddens me greatly with it's huge Strongly Connected Component ...
04:01:45 <Baughn> @hoogle [Bool] -> Bool
04:01:45 <lambdabot> Prelude and :: [Bool] -> Bool
04:01:45 <lambdabot> Prelude or :: [Bool] -> Bool
04:01:45 <lambdabot> Data.List and :: [Bool] -> Bool
04:01:53 <dnivra> i checked http://www.haskell.org/haskellwiki/The_Monad.Reader/Previous_issues but could download only issue 1
04:02:39 <quicksilver> ManateeLazyCat: I avoid recursive code dependencies when I code in C, C++ or perl.
04:02:48 <quicksilver> ManateeLazyCat: I think it's just good style, mostly.
04:03:03 <quicksilver> modularisation and layering in a way which avoids recursive deps.
04:04:06 <SamB_XP> yeah, I like to be able to use one module without using all n other modules in the program ;-)
04:04:32 <SamB_XP> there is a reason they are called modules!
04:04:38 <ManateeLazyCat> mmorrow: Okay, back.
04:05:26 <SamB_XP> dnivra: maybe http://themonadreader.wordpress.com/previous-issues/ helps ?
04:05:34 <fasta> Does anyone know how to call hs_init without it crashing?
04:05:59 <fasta> Just a trivial input, as if it was called from the command line without any arguments, would be OK, for now.
04:06:21 <fasta> The code I used last year doesn't appear to work anymore.
04:06:33 <SamB_XP> fasta: paste ?
04:07:18 <fasta> SamB_XP: http://gamr7.com/blog/?p=65 (and then the commented C code)
04:07:30 <ManateeLazyCat> quicksilver: I can make most modules modularistation, but always need some module communication each other.
04:08:03 <SamB_XP> ManateeLazyCat: it's always nice to come up with ways to allow communication without actually having to have the communicating modules import eachother
04:08:07 <dnivra> SamB_XP: it's the same thing; i cannot get any other as pdf except issue 1 like i said
04:08:38 <SamB_XP> one way is through algebraic datatypes of messages
04:09:31 <ManateeLazyCat> SamB_XP: When i programming Haskell/GUI, recursive problem make me crazy... :-(
04:10:04 <SamB_XP> what made *me* crazy was that GTK doesn't have a "fixed width text" widget :-(
04:10:17 <SamB_XP> is that really too much to ask?
04:10:22 <Botje> can't you simply use a label and set the font to something monospace?
04:10:40 <SamB_XP> I suppose, in theory ...
04:10:48 <SamB_XP> but how do I get one of those?
04:10:48 <fasta> SamB_XP: any idea?
04:10:49 <ManateeLazyCat> quicksilver: Except you code is pure completely, otherwise need recursive, more or less, speical when project is too big.
04:11:05 <Botje> a label? or a font? )
04:11:30 <ManateeLazyCat> SamB_XP: Haven't "fixed width text" widget?
04:11:51 <SamB_XP> well, really I was wanting a "character matrix" widget I guess
04:12:26 <SamB_XP> kind of like a terminal, only with an API instead of escape codes
04:12:36 <ManateeLazyCat> SamB_XP: YOu can use Cairo create you own widget with Haskell.
04:12:51 <ManateeLazyCat> SamB_XP: Then add event that need hangle with new widet.
04:13:01 <SamB_XP> I guesse I'd settle for an easy way to get a nice monospace font
04:13:34 <ManateeLazyCat> SamB_XP: If you want terminal in gtk2hs, you can download darcs version of gtk2hs, i have patch VTE patch to gtk2hs make you can use Haskell create terminal.
04:13:44 <dcoutts> SamB_XP: why should there be a specialised "fixed width text" when you can set a fixed width font on any widget?
04:13:48 <SamB_XP> and to size a text widget to fit a certain number of rows/columns
04:14:13 <SamB_XP> dcoutts: how does one obtain a fixed-width font ?
04:14:23 <dcoutts> SamB_XP: I'm using a TextView with a fixed font "monospace"
04:15:14 <SamB_XP> dcoutts: is that guarenteed to work?
04:15:24 <SamB_XP> or is it just because there is actually a font called monospace ?
04:15:34 <dcoutts> assuming the system can find any font in that class, yes
04:15:51 <SamB_XP> looking back, now I'm wondering what is supposed to happen when an Inform story puts CJK wide characters into the status area ;-)
04:15:56 <ManateeLazyCat> SamB_XP: Just use "fixed-width font" from your system.
04:16:14 <SamB_XP> ManateeLazyCat: I would prefer to write code that would work everywhere
04:16:26 <SamB_XP> preferably, it would use a nice choice of fixed width font, however
04:16:34 <ManateeLazyCat> SamB_XP: CJK? Chinese?
04:16:40 <dcoutts> I think "monospace" is a somewhat magic "pick a monospace font"
04:16:49 <SamB_XP> ManateeLazyCat: Chinese/Japanese/Korean
04:16:57 <ManateeLazyCat> SamB_XP: I know, i'm chinese.
04:17:09 <ManateeLazyCat> SamB_XP: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
04:17:20 <Baughn> dcoutts: Only somewhat magic. If you want the computer not to crash, you must toggle it to more magic.
04:17:26 <dcoutts> :-)
04:17:33 <ManateeLazyCat> SamB_XP: I think you just set "fixed-width font" is okay, Gtk+ support it.
04:17:46 <SamB_XP> Baughn: I still want to know how that switch came to be ...
04:18:16 <Baughn> SamB_XP: I figure a mischevious student
04:18:29 <SamB_XP> dcoutts: well ... it doesn't work here
04:18:45 <SamB_XP> now I've just got to figure out what version of GTK this xchat uses
04:19:13 <dcoutts> SamB_XP: I don't believe it :-)
04:19:22 <ManateeLazyCat> dcoutts: About yesterday my project, you said, i can call callback in IORefObject, and View never need know IORefObject. Problem is how to create those callback. The only way i can think is use `unsafePerformIO` create `global callback` that make IORefObject can reference those callback.
04:19:24 <dcoutts> SamB_XP: it works everywhere I've run my program, including windows
04:19:41 <SamB_XP> dcoutts: well, it might just be that it's a really old GTK version ?
04:19:55 <ManateeLazyCat> SamB_XP: Yes, Gtk+ can works with Linux, Windows, Mac
04:20:01 <dcoutts> SamB_XP: it reports it knows no such font?
04:20:06 <sinelaw> @botsnack
04:20:06 <lunabot>  :o
04:20:06 <lambdabot> :)
04:20:11 <sinelaw> @seen Peaker
04:20:11 <lambdabot> Unknown command, try @list
04:20:16 <SamB_XP> ManateeLazyCat: I'm talking about the use of the font name "monospace"
04:20:17 <sinelaw> arrrrrgg
04:20:27 <ManateeLazyCat> SamB_XP: I know that's font.
04:20:34 <dcoutts> SamB_XP: this is the "font family" not the font name as such
04:20:38 <ManateeLazyCat> SamB_XP: "monospace" can use Linux and Window.
04:20:38 <dcoutts> it's a classification
04:20:47 <SamB_XP> dcoutts: oh
04:20:53 <ManateeLazyCat> SamB_XP: Example, "DejaVu Monospace"
04:20:57 <dcoutts> SamB_XP: like serif or sans serif
04:21:25 <SamB_XP> dcoutts: so, should I be able to just type "monospace" into the Font: field in the x-chat prefs ?
04:21:38 <dcoutts> SamB_XP: no idea, I know the Gtk+ API
04:23:07 <ManateeLazyCat> dcoutts: About yesterday my project, you said, i can call callback in IORefObject, and View never need know IORefObject. Problem is how to create those callback. The only way i can think is use `unsafePerformIO` create `global callback` that make IORefObject can reference those callback.
04:23:45 <ManateeLazyCat> dcoutts: If i define those callback in IORefObject, i still need transform IORefObject to View.hs or Page.hs.
04:23:50 <dcoutts> ManateeLazyCat: you construct them at the time you construct the view, no unsafe required
04:24:07 <SamB_XP> dcoutts: hmm, maybe it just needs a size as well...
04:24:24 <SamB_XP> ah, yeah
04:24:43 <EvilTerran> preflex: seen PeakerWork
04:24:43 <preflex>  PeakerWork was last seen on ##c 3 days, 17 hours, 39 minutes and 35 seconds ago, saying: assuming its iteration of some small char array that happens each time
04:24:44 <SamB_XP> but I don't think this version of GTK is very good at picking a *nice* monospace font
04:24:47 <EvilTerran> preflex: seen Peaker
04:24:47 <preflex>  Peaker was last seen on ##c 9 hours, 2 minutes and 54 seconds ago, saying: I'm sure there might be some nice abuses of that feature :-)
04:24:53 <EvilTerran> sinelaw, ^
04:25:18 <SamB_XP> well, maybe it just picked this one based on my "ANSI" encoding ... which is the MS version of shift JIS, I believe ...
04:25:39 <hackagebot> strptime 0.1.3 - Efficient parsing of LocalTime using a binding to C's strptime (EugeneKirpichov)
04:26:13 <ManateeLazyCat> dcoutts: Now i'm think define some hook, such as `pageAddHook` in Page.hs, `pageAddHook` is List of function, and add "runHook pageAddHook` in last of function `pageAdd`, then i add function to `pageAddHook` in IORefObject. Right?
04:27:00 <xcoder42> if i have a string "this,is,a,test" and i want a helper function that returns [Var "this",Var "is", Var "a", Var "test"], any ideas on how i would begin to build it recursively? i'm abit at a loss
04:27:13 <dcoutts> ManateeLazyCat: I'm afraid I'm not sufficiently familiar with your code to say
04:27:13 <ManateeLazyCat> dcoutts: Or other way?
04:27:49 <SamB_XP> argh, crashed x-chat twice just now
04:28:13 <Saizan> xcoder42: i'd do something with span
04:28:28 <Saizan> > span (==',') "this,is,a,test"
04:28:29 <lambdabot>   ("","this,is,a,test")
04:28:34 <Saizan> > span (/=',') "this,is,a,test"
04:28:36 <lambdabot>   ("this",",is,a,test")
04:29:09 <SamB_XP> xcoder42: I'd do something with a parsing combinator library ;-)
04:29:27 <ivanm> Saizan: with the span to get rid of punctuation?
04:29:50 <Saizan> ivanm: is that a joke on the html tag?:)
04:29:59 <xcoder42> SamB_XP i'm already using the parsec lib for other stuff, but having alot of trouble with it
04:30:01 <ivanm> Saizan: nope
04:30:13 <ivanm> xcoder42: is it always going to be commas?
04:30:13 <SamB_XP> xcoder42: notice that I did *not* say parsec
04:30:18 <ivanm> @src words
04:30:18 <lambdabot> words s = case dropWhile isSpace s of
04:30:18 <lambdabot>     "" -> []
04:30:18 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
04:30:43 * ivanm would suggest either replacing commas with spaces then calling words, or hacking together a function based on words
04:31:07 <Botje> or use Data.List.Split
04:31:20 <xcoder42> ivanm, yes but i kan have a string this commas inside a "()", which i don't want to split on
04:31:23 <Botje> but that has been said before, probably?
04:31:26 <ivanm> Botje: if it's not always a comma, yes
04:31:31 <ManateeLazyCat> dcoutts: Example "new :: ViewAction -> IO View", i define `ViewAction` in View.hs file, but i create `ViewAction` instance in IORefObject when call `new` functoin. Right?
04:31:42 <ivanm> xcoder42: ahhh
04:31:52 <ivanm> xcoder42: then use a parsing library such as parsec, polyparse, etc.
04:32:20 <SamB_XP> ivanm: he said he's already trying to use parsec ...
04:32:23 <SamB_XP> but having trouble with it
04:33:04 <xcoder42> i guess i'll just have to keep crunching till it works
04:33:17 <ivanm> SamB_XP: which is why I also suggested polyparse, as it might be easier to comprehend
04:33:22 <SamB_XP> ah
04:33:54 <SamB_XP> ivanm: maybe you should've said as much in the first place ;-P
04:34:05 <dcoutts> ManateeLazyCat: I usually just define it locally when constructing the view, not storing it anywhere
04:34:19 <ivanm> SamB_XP: "might" == "I've only used polyparse and not parsec" ;-)
04:34:46 <xcoder42> well i've already used parsec for part of my code, so it would a bit ugly to start including more parsing libs me thinks
04:34:51 <SamB_XP> ivanm: the reverse, really
04:34:54 <SamB_XP> for me
04:35:02 <SamB_XP> that is, I've not really used polyparse ;-)
04:35:12 <SamB_XP> but I don't like parsec very much anymore
04:35:46 <quicksilver> xcoder42: sepBy
04:36:03 <quicksilver> xcoder42: listOfVars = sepBy var comma
04:36:05 <quicksilver> or something like that
04:36:16 <quicksilver> parsec has convenient combinators for most of the normal things like this
04:36:54 <xcoder42> alright, i'll give it a try
04:37:13 <ManateeLazyCat> dcoutts: Oh, i see, you just define Action temporary to plugin code in callback and avoid recursive, then drop those Action anyway. Right?
04:37:25 <dcoutts> ManateeLazyCat: right
04:38:13 <ivanm> SamB_XP: AFAICT, polyparse is easier to comprehend in the "wtf? there's a new version but no-one uses it?!?!?!?" sense ;-)
04:38:27 <ivanm> quicksilver: that won't work
04:38:33 <SamB_XP> ivanm: of what ?
04:38:38 <ivanm> quicksilver: since he's already said that he can have bracketed items
04:38:42 <ManateeLazyCat> dcoutts: I try to define it to store somewhere, i never catch your point exactly. Now looks your solution is very well to fix my problem. Thanks. :)
04:39:02 <dcoutts> great
04:39:02 <ivanm> quicksilver: oh, wait, duh, he just has to make sure var takes care of that...
04:39:07 <ivanm> SamB_XP: well, who actually uses parsec-3?
04:39:32 <Botje> i do :)
04:39:53 <SamB_XP> ivanm: I wasn't sure which package's versions you were speaking of ;-)
04:40:01 <ivanm> SamB_XP: heh
04:40:06 <ivanm> SamB_XP: I thought it was obvious ;-)
04:40:09 <ivanm> Botje: :o
04:40:17 <ivanm> Botje: do you release stuff on hackage using it?
04:40:28 <Botje> ivanm: unfortunately, no :(
04:40:32 <SamB_XP> not when I don't know anything about whether polyparse has had a new version and whether nobody uses it ;-)
04:40:55 <Botje> i might be tempted to do that if/when I add a type system to my simplistic ML compiler :)
04:41:41 <ivanm> Botje: so you don't count ;-)
04:42:10 <ivanm> SamB_XP: nah; but IIRC malcolmw has some bug fixes I pointed out to him that he hasn't put into a release yet...
04:42:46 <quicksilver> malcolmw's packages generally have two versons, stable and development
04:44:17 <quicksilver> polyparse doesn't seem to, though
04:44:17 <ivanm> quicksilver: well, 1.3 was released in March; IIRC he found these bugs based on stuff I was asking him in July
04:44:17 <quicksilver> (not a big -devel split like haxml does)
04:46:02 <ivanm> quicksilver: what do you mean? hackage only has one version of haxml
04:46:09 <ivanm> or do you mean 1.13 vs 1.19?
04:46:28 <quicksilver> yes that
04:46:48 <xcoder42> is if i wanted to build the helper function myself i would do something like this: http://pastebin.com/d6509bdad  yes this would not work .. but you get the idea.. so this possible?
04:47:16 <ivanm> quicksilver: you mean we're not meant to use the 1.19 branch? :o
04:47:24 <quicksilver> I'm sure ou could do something like that xcoder42 but I thought you said you were using parsec?
04:47:48 <Botje> xcoder42: don't make up syntax :) did you mean ',' | flag -> ... ?
04:48:08 <ManateeLazyCat> xcoder42: Why not use regular search?
04:48:30 <xcoder42> Botje, i meant ',' and flag
04:48:35 <Botje> yes, so |
04:48:44 * SamB_XP is still mystified that IE can't find about:blank !
04:48:46 <Botje> | can be used to attach additional constraints to a case
04:48:54 <Botje> SamB_XP: it's blocked at the firewall! *runs*
04:49:00 <xcoder42> Ok, still getting use to FB and Haskell syntaks :)
04:49:33 <ivanm> SamB_XP: isn't that a mozilla-ism?
04:49:39 <SamB_XP> ivanm: hmm. maybe.
04:49:39 <ivanm> (the whole about: thing, I mean)
04:49:43 <ManateeLazyCat> xcoder42: Regular expression compare is more [19:49:37]
04:49:46 <ManateeLazyCat> faster.
04:49:53 <SamB_XP> but it's not like I typed "about:jwz" or anything!
04:49:54 <xcoder42> quicksilver, yes i use parsec for some of my code, but i'm having so much trouble can i'm using a couple of helper functions to avoid having to use parsec all the time
04:50:29 <xcoder42> ManateeLazyCat, ok i'll have a look at that
04:50:45 <ManateeLazyCat> xcoder42: Parse when user's stop press?
04:51:15 <ivanm> ManateeLazyCat: *groan* not yet another haskell IDE...
04:51:16 <ManateeLazyCat> ivanm: I'm creating it.....
04:51:37 <ivanm> ManateeLazyCat: I take it leksah and yi aren't good enough for you?
04:51:47 <ManateeLazyCat> ivanm: Yes.
04:51:56 <ManateeLazyCat> ivanm: Leksah is too simple,
04:52:19 <ManateeLazyCat> ivanm: Yi just a editor like Emacs.
04:52:31 <quicksilver> xcoder42: on the one hand I think if you're using parsec you should just use parsec. that's what it's for and it will be easier than what you do by hand.
04:52:32 <sinelaw> ManateeLazyCat so what are you working on?
04:52:38 <ivanm> ManateeLazyCat: well, emacs is not just an editor... ;-)
04:52:41 <ManateeLazyCat> ivanm: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
04:52:59 <quicksilver> xcoder42: but, on the other hand I'm not sure your level of haskell expertise is high enoguh and you might want to work a little on the basic syntax first ;)
04:53:06 <ManateeLazyCat> ivanm: Now, it's have editor, file-manger, temrinal.
04:53:19 <ManateeLazyCat> ivanm: And will including more modules in the feature.
04:53:26 <ivanm> ManateeLazyCat: I've seen the screenshots you linked to in the email to -cafe
04:53:36 <ManateeLazyCat> ivanm: Good.
04:53:41 <ivanm> (hence the *groan*... the dark gtk+ theme didn't help :p )
04:53:44 <ManateeLazyCat> ivanm: Now, i can't release it yet.
04:54:10 <ManateeLazyCat> sinelaw: My self IDE.
04:54:21 <ivanm> ManateeLazyCat: but I've never really understood the point of a file manager when hacking...
04:54:29 <sinelaw> ManateeLazyCat i realized that, but what's special about it?
04:54:37 <xcoder42> quicksilver, point taken, any chance you could mockup an example using sepBy that takes a string and returns an array?
04:54:42 <ivanm> sinelaw: the fact that he's making it ;-)
04:54:44 <ManateeLazyCat> sinelaw: No speical, it's anything.
04:54:53 <ManateeLazyCat> ivanm: Wait.
04:55:00 <ManateeLazyCat> ivanm: http://farm3.static.flickr.com/2539/3843685031_9184ddf049_o.png
04:55:07 <ManateeLazyCat> ivanm: Looks left-bottom.
04:55:13 <ManateeLazyCat> ivanm: It's file-manager.
04:55:17 <ivanm> ManateeLazyCat: that's a little better ;-)
04:55:28 <ivanm> ManateeLazyCat: right... but why?
04:55:41 <ManateeLazyCat> ivanm: Now, my IDE is very basics.
04:56:13 <ivanm> ManateeLazyCat: my original point was kind of more, if you want stuff in leksah why not help out on it
04:56:23 <ivanm> rather than creating a separate IDE and thus wasting resources
04:56:27 <quicksilver> xcoder42: sepBy (many letter) (char ',')
04:56:31 <ManateeLazyCat> ivanm: Now i'm busy on add different module in it for test framework, such as, web-browser, music-player, irc-client.etc.
04:56:38 <quicksilver> xcoder42: is a parser for words separated by commas
04:56:39 <ManateeLazyCat> ivanm: Then i will detail every modules.
04:56:50 <ivanm> ManateeLazyCat: wtf do you want a music player in an IDE for?
04:56:56 <ManateeLazyCat> ivanm: Now.
04:57:01 <ManateeLazyCat> ivanm: Do.
04:57:13 <ManateeLazyCat> ivanm: In fact, it's my fault, it's not IDE, it's anything.
04:57:15 <ivanm> or are you trying to _really_ make an editor that's actually an OS? ;-)
04:57:29 <ManateeLazyCat> ivanm: If you think so, it's OS.
04:57:43 <ivanm> heh
04:57:57 <ManateeLazyCat> ivanm: I said IDE in -cafe, just give people some basis thinking.
04:58:03 <ivanm> right
04:58:08 <ManateeLazyCat> ivanm: Infact, my aim is create Soft-OS.
04:58:15 <ivanm> you're wanting a whole general working/editing environment?
04:58:16 <ivanm> ahh
04:58:16 <quicksilver> :t sepBy
04:58:17 <lambdabot> Not in scope: `sepBy'
04:58:17 <SamB_XP> ivanm: well, if he likes to listen while he hacks ...
04:58:30 <ivanm> SamB_XP: *shrug* I just don't think it should be part of an IDE
04:58:32 <ManateeLazyCat> ivanm: Should living environment..... :)
04:58:37 <ivanm> I have mpd+mpc playing stuff whilst I hack
04:58:41 <SamB_XP> ivanm: tell that to emacs ;-P
04:58:59 <ivanm> SamB_XP: *shrug* emacs isn't trying to be an IDE ;-)
04:59:03 <ManateeLazyCat> ivanm: I use Emacs do anything, but now i want to do more than Emacs.
04:59:05 <SamB_XP> heheheh
04:59:18 <xcoder42> thank quicksilver, is there an easy way to writeout a variable in haskell to see its contains?
04:59:25 <ivanm> SamB_XP: the fact that it's a better IDE than actual IDEs is just fortuitous ;-)
04:59:26 <ManateeLazyCat> SamB_XP: Emacs is anything, but less powerful.
04:59:35 <quicksilver> xcoder42: the normal way is to work at the ghci prompt
04:59:42 <quicksilver> and just type things you want to see the value of.
04:59:45 <ivanm> ManateeLazyCat: less powerful? how? or do you mean something along the lines of "jack of all trades, master of none?"
05:00:04 * ivanm sees emacs something like a generic text manipulation environment..
05:00:11 <ManateeLazyCat> ivanm: Emacs just great for text handle or simple static picture display.
05:00:36 <ManateeLazyCat> ivanm: It haven't completely framework to support complicate layout graphics.
05:00:40 <ivanm> yeah, I wish doc-mode was better (able to zoom, etc.); same for picture mode
05:00:52 <xcoder42> right but      test42 <- sepBy (many letter) (char ','); .. is in the middle of a do in a helper function, so a print-out would be useful, since i cannot access it
05:00:54 <ManateeLazyCat> ivanm: I patch to doc-mode before.
05:00:55 <ivanm> ManateeLazyCat: though ezbl looks cool
05:01:02 <ivanm> ManateeLazyCat: oh? to do what?
05:01:14 <rittyan> Hi all. What is "fps" library/app/dunno and where can I find it? Some packages require it and fps is not on hackage.
05:01:26 <ManateeLazyCat> ivanm: Fix bug, and scroll line.
05:01:37 <ManateeLazyCat> ivanm: In fist version of doc-mode, just can scroll page.
05:02:01 <ivanm> rittyan: which package is this?
05:02:13 <ivanm> rittyan: I _think_ it means fast-packed-strings, which turned into bytestring
05:02:16 <rittyan> ivanm: regex pcre depends on fps
05:02:40 <ManateeLazyCat> ivanm: ezbl is not natural way to fix problem,
05:02:46 <Zao> http://www.haskell.org/pipermail/cvs-hugs/2007-April/003645.html
05:02:56 <ivanm> rittyan: which version? latest version doesn't...
05:02:57 <ManateeLazyCat> ivanm: Yes, you can browser page like doc-mode for pdf.
05:03:05 <rittyan> ivanm: 0.81
05:03:24 <rittyan> ivanm: oh my, gonna try the newest one
05:03:27 <rittyan> thanks :D
05:03:32 <ivanm> Zao: :o I couldn't find fps on hackage...
05:03:51 <ManateeLazyCat> ivanm: Like i said before, emacs can implement anything, but it's implement problem, we should implement those with natural way, not hacking way.
05:03:53 <ivanm> rittyan: maybe go with 0.8.2; IIRC 0.9x is developmental branch
05:04:04 <ivanm> ManateeLazyCat: what do you actually mean by that?
05:04:24 <ivanm> rittyan: pcre-light might be more what you want
05:04:43 <Zao> ivanm: It's supposedly some precursor to bytestring, for platforms that doesn't have them in base already.
05:04:45 <ivanm> rittyan: especially since regex-pcre hasn't had any updates for over 18 months
05:04:46 <Zao> Or suchlike.
05:04:54 <ivanm> Zao: I already said it was the precursor ;-)
05:05:07 <rittyan> ivanm: I need to compile my legacy code right now :)
05:05:17 <rittyan> maybe pcre-light is better, but I won't patch the code atm
05:05:18 <ivanm> Zao: it turned into bytestring (I've asked dons about this before... we had an fps package for gentoo until a few months ago)
05:05:22 <ivanm> rittyan: ahhh
05:05:25 <Zao> ivanm: Right. My head isn't quite screwed on today.
05:05:28 <ivanm> rittyan: well, 0.8.2 doesn't need it
05:06:00 <ManateeLazyCat> ivanm: If we really want Emacs implement anything, we need rebuild a completely framework to support it, thinking about this, you can render JavaScript page in Emacs now?
05:06:11 <ivanm> don't think so...
05:06:22 <ivanm> ManateeLazyCat: so you're saying emacs needs a rewrite to do more than just text mangling?
05:06:51 <ManateeLazyCat> ivanm: Now Emacs community try to use text or embed implement anything, but text can't describe anything, that's key point.
05:07:11 <ivanm> OK I see what you mean
05:07:12 <SamB_XP> ManateeLazyCat: oh, but it can
05:07:15 <SamB_XP> ;-P
05:07:22 <ivanm> but I doubt such a large rewrite is going to happen
05:07:25 <SamB_XP> never heard of base64 ?
05:08:01 <ManateeLazyCat> ivanm: Yes, but IMO, the important resource of Emacs is not itself, is it's huge extensions, if we rewrite Emacs core, we will broke current huge extensions, that's problem.
05:08:35 <ivanm> ManateeLazyCat: exactly, which is why I doubt it's going to happen ;-)
05:08:45 <ManateeLazyCat> SamB_XP: You can use base64 code transform image between. text
05:09:05 <ManateeLazyCat> ivanm: I think those problem long time, one years ago.
05:09:16 <fasta> ManateeLazyCat: I think that problem is not _that_ big. As a first step one could simply implement Emacs Lisp.
05:09:33 <ManateeLazyCat> fasta: elisp is slow!
05:09:35 <fasta> ManateeLazyCat: remember that lots of Emacs modes suck beyond belief.
05:09:42 <ivanm> fasta: well, look how many people want to replace elisp with clisp or something...
05:09:54 <fasta> ivanm: yes, and nobody does it.
05:09:55 <ivanm> ManateeLazyCat: is elisp slow or the interpreter slow? ;-)
05:10:02 <fasta> ivanm: so, probably they don't want it that bad.
05:10:10 <ManateeLazyCat> ivanm: Both
05:10:12 <ivanm> fasta: because 1) not enough people agree which one, 2) IIRC RMS said no
05:10:14 <fasta> They can always collect money to do so.
05:10:22 <ivanm> ManateeLazyCat: a language isn't slow; it's implementation can be
05:10:28 <ManateeLazyCat> ivanm: That's why i decide rewrite a new system.
05:10:31 <fasta> RMS is kind of irrelevant in the matter for e.g Yi.
05:10:33 <ivanm> since an implementation is just a mathematical formalism, etc.
05:10:36 <ManateeLazyCat> ivanm: Yes,
05:10:45 <ivanm> fasta: right, but that's not emacs itself, it's an emacsen
05:11:02 <fasta> ivanm: I don't see your point.
05:11:03 <ManateeLazyCat> ivanm: Anyway, now implement is slow.
05:11:32 <ManateeLazyCat> fasta: I think i have try to do those for fix emacs, but now i drop it.
05:11:33 <ivanm> fasta: people want to replace elisp within another language _in emacs_, not write an emacs-like editor/OS/whatever
05:11:53 <fasta> ivanm: yes, I know that too.
05:12:01 <ManateeLazyCat> ivanm: Exacept me, i want write Haskell-Soft-OS.
05:12:03 <fasta> ivanm: but Yi really is a replacement for Emacs.
05:12:27 <ivanm> fasta: well, once it gets support for other langs except haskell for highlighting, etc. then I might have another look at yi
05:12:41 <ivanm> especially since I've started using gnus for my email
05:13:08 <ManateeLazyCat> ivanm: I can highlight many language with Gtk+, even it just simple.
05:16:09 <ManateeLazyCat> ivanm: So my plain is add Emacs text editor feature in my editor module, use other to render multi-media module. All base on Gtk+
05:16:36 <ivanm> ManateeLazyCat: have you thought of may embedding yi into your app?
05:16:44 <ivanm> or are you going to use emacs itself using xembed?
05:17:06 <ManateeLazyCat> ivanm: If you embedded it, you have less control.
05:17:17 <ManateeLazyCat> ivanm: In fact, i can run Yi in my project.
05:17:24 <ManateeLazyCat> ivanm: Run it in my terminal module.
05:17:31 <ivanm> OK, so you're going to completely re-implement a yi/emacs-like app..
05:17:48 <ManateeLazyCat> ivanm: Yes.
05:17:56 <ManateeLazyCat> ivanm: But not just for Text world.
05:18:17 <ivanm> ManateeLazyCat: I meant in terms of the editor
05:18:23 <ManateeLazyCat> ivanm: I will implement Webkit browser in it when my friend apply Webkit patch to gtk2hs.
05:19:01 <ManateeLazyCat> ivanm: I will study from Emacs, but i won't clone it.
05:19:12 <ManateeLazyCat> ivanm: I will add some code completion feature like Eclipse.
05:19:12 <ivanm> ManateeLazyCat: I would suggest you at least look to see if you can get the yi devs to have yi available as a library, for you to use and thus avoid re-duplication
05:19:47 <ManateeLazyCat> ivanm: Yes, if Yi can split it's syntax library to outside.
05:20:00 <ManateeLazyCat> ivanm: Then i can avoid write some feature agian.
05:20:02 <ivanm> well, you'd have to ask ;-)
05:20:33 <ManateeLazyCat> ivanm: If Yi developers don't want split, i will rewrite it for fully control my project.
05:20:47 <ivanm> ManateeLazyCat: as it's the same situation when I asked you why you were creating yet another IDE: we don't have that many people working on this kind of stuff that we want to fracture/split our resources by writing competing products
05:20:55 <ManateeLazyCat> ivanm: Anyway, i try to run shortest way.
05:20:59 <ManateeLazyCat> :)
05:21:07 <ivanm> heh
05:22:06 <ManateeLazyCat> ivanm: Infact, Emacs's develop speed is slow now, because it's too complicate now. That's why i recreate.
05:22:27 <ManateeLazyCat> ivanm: But point is, i think haven't any exsiting application will do same thing as mine.
05:22:35 <ivanm> *nod*
05:22:38 <ManateeLazyCat> ivanm: Though emacs most like mine.
05:22:55 <quicksilver> emacs development is not slow because it is too complicated.
05:23:09 <quicksilver> emacs development is slow because not enough people are motivated to spend enough time developing it.
05:23:23 <ivanm> might get a boost with the new package.el stuff
05:23:27 <medfly> emacs loses the editor war
05:23:34 <ivanm> in terms of adding stuff to emacs, rather than low-level stuff
05:23:38 <medfly> :))
05:23:38 <ivanm> medfly: why do you say that?
05:23:45 <medfly> I'm just joking.
05:23:49 <medfly> <quicksilver> emacs development is slow because not enough people are motivated to spend enough time developing it.
05:23:55 <ManateeLazyCat> quicksilver: Anyway, emacs still greatest editor in this world.
05:24:20 <ivanm> medfly: slow /= dead
05:25:34 <ManateeLazyCat> quicksilver: If you just developing outter extension, it's really fast, because elisp is really funny for write extension, but when you modified core and don't lost compatiblely, it's slow.
05:25:52 <ManateeLazyCat> s/outter extension/application extension.
05:26:00 <quicksilver> i know what you mean.
05:26:25 <ManateeLazyCat> quicksilver: Compatibly make develop slow.
05:26:25 <quicksilver> to me, the problem with emacs development is I don't believe there is actually anyone interested in taking it in the next interesting direction.
05:26:41 <quicksilver> away from text-only (with some limited graphics support)
05:26:48 <ivanm> well, they're merging cedet into emacs itself atm...
05:26:50 <ManateeLazyCat> quicksilver: Yes.
05:26:56 <quicksilver> and towards some kind of sensible layout model
05:26:59 <ManateeLazyCat> quicksilver: Emacs core developers just like Text.
05:27:12 <ivanm> ManateeLazyCat: or else they don't know what else to do in a backwards-compatible manner?
05:27:15 <quicksilver> which can actually display structured things like module dependency graphs
05:27:26 <quicksilver> their conservatism has a reason.
05:27:30 <ivanm> and don't want to make too many changes too quickly...
05:27:40 <ivanm> quicksilver: doesn't OGRE do something like that?
05:27:42 <quicksilver> org-mode, for example, is great precisely because it's all just a magical way of treating text
05:28:08 * ivanm really should have a serious look at org-mode, planner, etc.
05:28:13 <quicksilver> if the org-mode developer had had access to a structured data representation language would he have developed something huge and ugly which is useless to tools? perhaps.
05:28:34 <quicksilver> there are so many virtues to 'everything is text' that it holds back other interesting developments, though.
05:28:35 <ivanm> quicksilver: so because elisp is at times ugly, something beautiful arose out of the musk? :p
05:28:35 <ManateeLazyCat> quicksilver: Yes, Text can't describe multi-media content, but it's more generic.
05:28:46 <ManateeLazyCat> quicksilver: You can apply all elisp code for text anywhere.
05:28:47 <quicksilver> ivanm: perhaps you coudl say that, yes.
05:28:51 <ManateeLazyCat> quicksilver: It's power of Emacs.
05:29:08 <quicksilver> ManateeLazyCat: and your text files can also be used with grep, find, and other typical command-line tools.
05:29:28 <quicksilver> ManateeLazyCat: so it fits into a large ecosystem of predominantly line-based text constructs.
05:29:37 <ManateeLazyCat> quicksilver: Infact, i wrote org-w3m.el for org-mode :)
05:29:42 <quicksilver> :)
05:30:02 <ManateeLazyCat> quicksilver: Do you use w3m in Emacs?
05:30:02 <Jafet> So is text great because people who wrote data processing tools used to think that text is great?
05:30:09 <ivanm> w3m keeps annoying me
05:30:11 <quicksilver> yes, Jafet.
05:30:16 <quicksilver> self-perpetuating greatness.
05:30:17 <ivanm> it doesn't help that q only hides it rather than quitting it...
05:30:22 <ManateeLazyCat> ivanm: Good to write manual.
05:30:22 <Jafet> I figured as much...
05:30:28 <ManateeLazyCat> ivanm: Bad for watch movie.
05:30:32 <quicksilver> text is great because I have so many brilliant and composable tools which help me process it.
05:30:43 <quicksilver> to move to richer formats, we have to find a way to replace the power of those tools too
05:30:53 <ivanm> especially since I keep hitting q to get back to my main gnus screen, and w3m stuffs that up if I'm viewing a link or something... :s
05:30:57 <Jafet> perl!
05:30:59 <ivanm> ManateeLazyCat: w3m sucks for haddock generated docs
05:31:01 <Jafet> Whoops
05:31:10 <ivanm> @slap Jafet
05:31:10 * lambdabot pokes Jafet in the eye
05:31:20 <ManateeLazyCat> quicksilver: In sometimes, text give emacs all power, every emacs command can handle any buffer with text.
05:31:28 <ManateeLazyCat> ivanm: I use it read gtk2hs docs.
05:31:29 <ManateeLazyCat> :)
05:31:46 <ivanm> ManateeLazyCat: well, I find it annoying due to the +- images, etc. not displaying properly
05:31:58 <ManateeLazyCat> quicksilver: But sometimes, text is not enough, speical for web-browser.
05:32:12 <ManateeLazyCat> ivanm: Because w3m not support iframe
05:32:25 <Jafet> iframes are obsolete
05:32:38 <ManateeLazyCat> no, is layout.
05:32:49 <ManateeLazyCat> w3m not support complicate page layout.
05:33:05 <ManateeLazyCat> ivanm: It just consider picture like higher text line.
05:33:18 <Jafet> Is Manatee literally a troll?
05:33:22 <ivanm> ManateeLazyCat: it has "show/hid" everywhere... it's a PITA!
05:33:26 <ivanm> Jafet: nah
05:33:29 <Jafet> Like, in lore
05:33:32 <ManateeLazyCat> ivanm: In fact, w3m use some base64 technological, like i use in yaoddmuse.el
05:33:34 <ivanm> I just doubt that English is his first language
05:33:38 <ivanm> Jafet: oh... heh ;-)
05:33:48 <Jafet> ugga ugga ugg
05:33:52 <ManateeLazyCat> ivanm: transform picture to text, then decode text with base64.
05:34:26 <ManateeLazyCat> ivanm: No, i'm Chinese.
05:34:30 <ivanm> nope, trying it again... haddock docs are really painful with w3m
05:34:40 <quicksilver> Jafet: iframes are still needed for embedded content from one site in another, until all browsers support object or seamless or similar.
05:34:42 <ManateeLazyCat> ivanm: Just i use English helper in ERC to help me type English word.
05:34:55 <ivanm> ManateeLazyCat: you have a really weird name for someone of Chinese descent...
05:35:02 <ManateeLazyCat> ivanm: I know, that's why i develop web-browser in my project.
05:35:22 <ManateeLazyCat> ivanm: You mean PinYin?
05:35:36 <ivanm> ManateeLazyCat: I mean "Andy Stewart" ;-)
05:35:45 <ManateeLazyCat> ivanm: Just for my friend.
05:35:58 <ManateeLazyCat> ivanm: Infact, PinYin in Chinese will confusion people.
05:36:05 <ivanm> so that _isn't_ your name?
05:36:23 <Jafet> I don't think there is a han character for "manatee"...
05:36:26 <ManateeLazyCat> ivanm: Yes, just English name for communication.
05:36:30 <ivanm> right
05:36:41 <ivanm> Jafet: well, there might be a sequence... ;-)
05:36:43 <ManateeLazyCat> ivanm: Just few people understand Chinese.
05:36:47 <ivanm> isn't manatee a sea creature?
05:36:59 <ivanm> ManateeLazyCat: I would have thought that chinese was the most spoken language on the planet... :p
05:37:01 <Jafet> Who knows. One of those real-life things.
05:37:06 <ManateeLazyCat> ivanm: ManateeLazyCat just nickname.
05:37:08 <ivanm> (but I get what you mean)
05:37:10 <ivanm> Jafet: heh
05:37:18 <en0th> @quote
05:37:19 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
05:37:42 <ManateeLazyCat> ivanm: So i got English name for handy with other people.
05:37:44 <Jafet> Wait, w3m does images? I have to see
05:37:53 <ManateeLazyCat> Jafet: Yes.
05:38:04 <ManateeLazyCat> Jafet: But just static picture.
05:38:13 <ivanm> Jafet: if there's actual images, it doesn't do them too bad
05:38:19 <ManateeLazyCat> Jafet: In new version, picture can download asynchronous.
05:38:20 <Jafet> So does eog...
05:38:50 <Jafet> I suppose this is why there is a libcaca in /usr
05:39:00 <dnivra> > take 10 replicate 5
05:39:01 <lambdabot>   Couldn't match expected type `[a]'
05:39:01 <lambdabot>         against inferred type `GHC.Types...
05:39:04 <ManateeLazyCat> ivanm: I talk many about my system with Emacs, he said, you project is doomed, because it's write in Haskell.
05:39:08 <ManateeLazyCat> :)
05:39:12 <ManateeLazyCat> Haven't no idea.
05:39:39 <ivanm> Jafet: I know that someone tried to convert me to sxemacs because they have better picture support overall...
05:39:43 <ManateeLazyCat> ivanm: Maybe haskell is hard to learn for some people, but i still think it's a great language.
05:40:25 <ivanm> but gtk+ > whatever widget kit [s]xemacs uses...
05:41:15 <ManateeLazyCat> ivanm: If rewrite Emacs base on Gtk+, it's really interested, even TextView library haven't all power of Emacs.
05:41:32 <ivanm> ManateeLazyCat: what do you mean?
05:41:36 <ivanm> emacs already has gtk+ support..
05:41:48 <ivanm> or do you mean use gtk+ widgets for the text area, etc. as well?
05:41:54 <ivanm> won't that remove a lot of emacs' power then?
05:41:56 <ManateeLazyCat> ivanm: I mean use Gtk+ framework and widget build Emacs.
05:42:20 <ivanm> nah, I think the emacs text area has more flexibility, etc. than the gtk+ one
05:42:20 <ManateeLazyCat> ivanm: Yes, you need rebuild all emacs power with Gtk+ widget.
05:42:47 <ManateeLazyCat> ivanm: Yes. TextView and TextIter is poor than Emacs's text handle.
05:43:13 <ManateeLazyCat> ivanm: But i build some code to extension Gtk+ text handle.
05:43:34 * ManateeLazyCat pasted "Gtk.hs" at http://paste2.org/get/481135
05:43:37 <ManateeLazyCat> ivanm: Above.
05:44:00 * ManateeLazyCat pasted "Multiline.hs" at http://paste2.org/get/481136
05:44:02 <ivanm> eh, never touched gtk2hs
05:44:34 <ManateeLazyCat> ivanm: In Multiline.hs, i write many new functions to support some feature emacs haven't support.
05:45:03 <ManateeLazyCat> ivanm: Like `textViewTraLinesBelow`, `textViewTraLinesAbove`.
05:45:31 <ManateeLazyCat> ivanm: We can transposes region up or down like TextMate.
05:45:42 <ManateeLazyCat> ivanm: I think Emacs never support it default.
05:46:05 <ManateeLazyCat> `textViewDupLinesBelow` `textViewDupLinesAbove` is duplciate region up or down
05:46:50 <ManateeLazyCat> ivanm: Of course, now i haven't rewrite all Emacs edit fucntions in Multiline.hs, just some important fucntoins always use.
05:47:32 <ManateeLazyCat> ivanm: Maybe i need split those text handle library in cabal, then leksah use my library do same thing.
05:47:55 <ivanm> *shrug* might be an idea
05:49:15 <ManateeLazyCat> ivanm: I hope some haskeller will have time help me improve design, now i need refactory code now.
05:49:35 <ManateeLazyCat> ivanm: Nice to meet you. I bet i see you before. :)
05:49:49 <ivanm> could be...
05:50:38 <ManateeLazyCat> ivanm: Sometimes, i should study from Linus: release code as quickly as i can.
05:53:53 <ManateeLazyCat> ivanm: If you want quit from w3m, type `Q`, and not `q`. Bye.
05:55:04 <ivanm> eh, I'd already worked that out, just keet forgetting...
05:58:13 <hackagebot> ideas 0.5.8 - Feedback services for intelligent tutoring systems (JohanJeuring)
06:01:06 <ivanm> what's the correct name for the libraries that are shipped with GHC?
06:01:12 <ivanm> core libraries? boot libraries?
06:01:24 <Igloo> boot libraries
06:01:29 <ivanm> thanks Igloo
06:01:53 <ivanm> Igloo: oh, since you're here, which of the boot libraries are safe to upgrade?
06:02:54 <dnivra> :t isInfinite
06:02:55 <lambdabot> forall a. (RealFloat a) => a -> Bool
06:05:49 <quicksilver> ivanm: typically none, since the reason they are boot libraries is that GHC itself uses them.
06:05:49 <ivanm> not even Cabal? :o
06:05:49 <quicksilver> ivanm: in some cases it may work OK for GHC to use one version and your code to use another
06:05:53 <quicksilver> as long as never the twain do meet
06:06:00 <ivanm> heh
06:06:08 <quicksilver> cabal is a bit different
06:06:17 <quicksilver> cabal isn't actually used by the RTS/Prelude
06:06:18 <dcoutts> usually meaning that you do not depend on the ghc package
06:06:31 <ivanm> OK, how about bytestring?
06:06:55 * Igloo wouldn't upgrade any of them without a very good reason
06:07:40 <ivanm> Igloo: I'm asking from a package management perspective, where some packages (e.g. yi) require bytestring 0.9.1.*, which doesn't come with older GHCs
06:08:15 <Igloo> Package management for what?
06:09:15 <ivanm> Gentoo
06:11:10 <rittyan> speaking of package management: doing haskell stuff on ubuntu is royal pain
06:12:46 <Saizan_> i never used packages from the repositories on ubuntu
06:13:32 <rittyan> then ubuntu is doing something wrong, if people don't use package manager :)
06:13:59 <ivanm> rittyan: they still have ghc 6.8.* IIRC
06:14:20 <rittyan> ivanm: karmic has 6.10
06:14:21 <Raevel> i use a separate repo for haskell
06:14:22 <rittyan> checked today
06:14:22 <marcuse> 6.10.3 in fedora
06:14:31 <ivanm> 6.10.4 in gentoo ;-)
06:14:48 <ivanm> we usually have RCs as well, but no-ones bothered to for 6.12 yet
06:14:55 <rittyan> haskell support on gentoo was great, I miss it :)
06:15:07 <ivanm> rittyan: you switched distros I take it?
06:15:14 <rittyan> yup
06:15:23 <ivanm> rittyan: anyway, thanks... there are too many people bitching about our packages
06:15:27 <ivanm> (because we don't keep the tree updated)
06:15:32 <rittyan> my big box is for my mom now, and I'm living away with my eeepc (can't compile a s**t)
06:15:36 <ivanm> (and kolmodin doesn't like unmasking stuff, etc.)
06:15:56 <rittyan> (my whole life was unmasked, if you know what I mean)
06:17:06 <ivanm> Igloo: so old GHCs shouldn't install bytestring 0.9.1.* (and thus can't install packages that require it)?
06:17:15 <ivanm> rittyan: heh
06:17:27 <rittyan> not that I'm proud of it, had no choice :)
06:17:46 <Igloo> ivanm: If I was doing Gentoo packaging, I would package a newer GHC rather than upgrading bootlibs
06:17:53 <ivanm> Igloo: we have a newer GHC
06:18:02 <Igloo> Then I don't see the problem
06:18:04 <ivanm> but not all architectures have support for it yet
06:18:11 <ivanm> and we have to keep supporting them :s
06:18:59 <rittyan> sounds tough
06:19:01 <Igloo> It would be easier to fix the problem, IMO
06:19:33 <ivanm> Igloo: I would prefer not to do it, it's just that dons and dcoutts have said that (for example) bytestring 0.9.1.4 had a corner bug that's fixed in 0.9.1.5... so should all GHC 6.10.* users then be stuck with that potential bug?
06:20:44 <Igloo> If you have a good reason to upgrade it then it might be worth doing
06:21:13 <ivanm> *nod*
06:21:23 <Igloo> Although personally in this case I'd be tempted to merge the fix (or wait for 6.12)
06:21:59 <ivanm> Igloo: I want to scrap our bytestring package entirely, as dep problems with it are a PITA
06:30:13 <`core> i can download an rss feed in one line of code in c#
06:30:18 <`core> now that's a good standard library
06:30:22 <`core> how is haskell's?
06:30:51 <Botje> it's pretty much one line of code using the right library as well.
06:30:52 <Saizan_> you need to get PhD first
06:31:05 <Botje> of course if lines of code is your metric, C# is a losing proposition :)
06:31:22 <ivanm> `core: how big a file do you need to just download one line of code in C#?
06:31:29 <ivanm> as in, a file that does nothing but that
06:31:37 <ivanm> _that_ is a better LOC metric for languages
06:31:53 <`core> i could care less about the size of .net's required dlls
06:31:57 <`core> that's just me tho
06:32:01 <`core> i care about getting things done
06:32:22 <Botje> shrug
06:32:26 * `core shrugs too
06:32:27 <ivanm> no-one mentioned disk space...
06:32:28 <Botje> then it's one line of code in haskell and one import.
06:32:33 <`core> cool
06:32:48 <Botje> if you're allowed to use any library you want, everything is one line :/
06:32:57 <ivanm> Botje: so, 3 lines including the module statement...
06:33:07 <ivanm> beat that C#! ;-)
06:33:10 <`core> heh
06:33:19 <`core> lisp has pretty poor libraries tho, doesnt it
06:33:25 <Botje> not rally
06:33:30 <Botje> common lisp has a _TON_ of libraries.
06:33:32 <ivanm> `core: depends on which lisp and how you define poor
06:33:49 <`core> i really sohuldnt have said that--yeah, i dont really know
06:33:58 <ivanm> `core: and how important being able to download RSS feeds in one line really is
06:34:11 <ivanm> (as in, who really cares...)
06:34:24 <`core> if im building an rss scraper... :)
06:34:28 <Botje> a slightly better benchmark would be a correct implementation of a parallel RSS fetcher
06:34:35 <ivanm> also, does "downloading rss feeds" == wgetting the file?
06:34:53 <`core> no, it means loading into a strongly typed object model
06:34:58 <ivanm> `core: yes, but do lisp devs care about that kind of thing?
06:35:09 <`core> im not trying to compare c# to haskell
06:35:13 <ivanm> `core: OK, so are you referring to just parsing, or downloading and parsing?
06:35:16 <`core> im just wondering about the get-things-done factor
06:35:27 <`core> dowloading an parsing
06:35:41 <`core> eg. RssDocument myDoc = XDocument.Load(url)
06:36:18 <ivanm> `core: yes, but there's different focuses on getting things done
06:36:38 <`core> ive got a small pet project and want to learn haskell and i just want to make sure im not going to spend a zillion hours searching for and downloading libraries
06:36:47 <`core> want to port it to haskell, that is
06:36:51 <ivanm> in some communities, it might be important to be able to download and parse an RSS feed in one statement (as an example)
06:37:04 <`core> that'd be the community im in :)
06:37:09 <`core> def not the academic one
06:37:11 <ivanm> in others, it might not be that big a deal if such a thing takes 2 or 3 statements
06:37:30 <`core> a handful is fine with me
06:37:32 <Botje> `core: there's a feed library on hackage (hackage.haskell.org) which looks fine
06:37:32 <ivanm> (which, of course, you're free to combine into you own single function; but the library devs might not want to)
06:37:41 <ivanm> `core: OK, that's what I was getting at...
06:37:42 <fasta> You can do it in zero statements in Haskell!
06:37:46 <`core> heh
06:37:57 <ivanm> I don't know what the RSS library is like, but in haskell you'd typically split the downloading from the parsing
06:38:01 <`core> hackage is like the haskell code search engine, right
06:38:08 <ivanm> no
06:38:17 <ivanm> hackage == equivalent of CPAN, etc. for haskell
06:38:30 <ivanm> `core: hoogle and hayoo are the code search engines
06:38:46 <`core> ahh okay, like CPAN then
06:38:47 <ivanm> hoogle is more flexible in how you use it (AFAIK); hayoo covers more libraries (all of hackage I think)
06:39:13 <`core> alright, time to go snooping aorund hackage then
06:39:14 <Botje> languages that don't have a centralized module distribution mechanism should be regarded as "cruel and unusual punishment"
06:39:21 <fasta> Hayoo is offline more than 0.1% of thetime.
06:39:23 <`core> heh most definitely
06:39:32 <fasta> Botje: ?
06:39:38 <fasta> Botje: centralized is evil.
06:39:41 <Berengal> I'm using hxt, and downloading a page is as simple as 'readDocument "http://www.someurl.tld"
06:39:42 <ivanm> fasta: :o
06:39:56 <Botje> fasta: having to pluck random code from all over the net even more so
06:39:59 <`core> does haskell have exceptions
06:39:59 <fasta> Central organization with distributed principals is the best.
06:40:08 <jesmon> anyone know of any companies doing embedded haskell development?
06:40:33 <Botje> `core: yes. people tend to use better mechanisms than exceptions to handle errors, though.
06:40:49 <fasta> jesmon: you mean the GHC RTS running on some device?
06:40:52 <`core> like what. just something i cna google is fine
06:40:55 <ivanm> jesmon: blue something or other I think...
06:41:01 <Botje> `core: Either or Maybe. :]
06:41:03 <fasta> jesmon: or using Haskell to generate code to run on the device?
06:41:08 <`core> ah of course
06:41:09 <sm> morning all
06:41:15 <ivanm> Botje: usually either Either or maybe Maybe? :p
06:41:26 <Botje> ivanm: either Maybe, or maybe Either!
06:41:32 <jesmon> fasta: I was under the impression that haskell could compile for embedded systems...
06:41:33 <`core> heh
06:41:36 <ivanm> Botje: even better!
06:41:48 <ivanm> jesmon: they're working on ARM support IIRC...
06:42:00 <fasta> jesmon: the fact that you can, doesn't mean it is a good idea.
06:42:36 <fasta> Running Haskell with 256 bytes of memory is not going to happen.
06:43:03 <jesmon> fasta: this device has 16MB I think...
06:43:19 <tavelram> you could have a look at timber
06:43:36 <saml> hola back
06:43:40 <fasta> jesmon: at first sight, that should be enough, but since not a lot of people do that, there is little change it wouldn't take work to get it going.
06:44:30 <jkff> Hey. Where can I get cabal 1.7? Looks like I need it to install lhc; I've even darcs got it, but there's no tag 1.7 there.
06:45:00 <ivanm> jkff: it exists in head only
06:45:09 <dcoutts> jkff: darcs version
06:45:10 <ivanm> actually, head now has 1.8, so 1.7 doens't exist anymore
06:45:15 <burp>  well compiling haskell is not going to happen with few memory
06:45:19 <burp> but running it? why not
06:45:35 <ivanm> dcoutts: did you split off a 1.7 branch? because when I darcs got cabal, it had 1.8...
06:45:47 <dcoutts> ivanm: no
06:45:48 <jkff> dcoutts: "No such command 'version'"
06:46:05 <jkff> Or what did you mean?
06:46:11 <dcoutts> jkff: as in the darcs version of Cabal is 1.8, not a specific darcs command
06:46:13 <ivanm> jkff: he meant that 1.7 was the version in darcs ;-)
06:46:21 <jkff> Ah. But there's the 1.8 version in HEAD
06:46:25 <dcoutts> that's ok
06:46:40 <ivanm> jkff: edit the .cabal file for lhc to use 1.8
06:46:43 <jkff> But lhc does not build with it
06:46:50 <dcoutts> then fix lhc
06:47:07 <jkff> I've got Setup.hs:26:18: Not in scope: `makefileHook' while building ghc-prim libraries
06:47:09 <Saizan_> it either still work in 1.8, or you've to unpull patches until it does, or you port it to 1.8 :)
06:47:24 <tavelram> check out timber, its a haskell "fork", without lazy evaluation, which migt be a good idea in embedded environments.
06:47:32 <jkff> dcoutts: Well, looks like that's the only thing that remains :)
06:47:47 <ksf> is there a working cabal-install for 6.12, yet?
06:48:10 <tavelram> jesmon
06:48:49 <ivanm> ksf: no
06:49:00 <ivanm> ksf: and the proper question is "is there a working cabal-install for cabal 1.8 yet"
06:50:43 * ksf thinks it's "for 6.12" as I'd be trying out 6.12 and contribute valuable bug reports if I there was a cabal-install for 6.12
06:50:51 <jkff> Heh. It sufficed to remove that .cabal's part about makefiles. lhc does not build still, but now for a different reason
06:51:03 <ivanm> ksf: yes, but it isn't specifically 6.12 that cabal-install needs to be fixed for
06:51:21 <jkff> Now I get "No (or multiple) rts package is registered!!" What could that mean?
06:51:28 <ksf> dunno, it chokes on the ghc-pkg format.
06:51:34 <jkff> Has anyone successfully installed lhc?
06:51:39 <ivanm> ksf: that's why you need support for cabal 1.8
06:51:44 <Lemmih> I have. (:
06:51:49 <ivanm> jkff: I'd hope the devs had ;-)
06:51:53 <ivanm> Lemmih: *phew*
06:51:53 <ManateeLazyCat> mmorrow: Any lucky?
06:52:24 <dnivra> > take 10 (cycle [1])
06:52:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
06:52:57 <dnivra> @hoogle map
06:52:57 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
06:52:57 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
06:52:57 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
06:53:01 <Lemmih> jkff: Wait until GHC-6.12 is out if you don't want to get your hands dirty.
06:53:02 <dnivra> :t map
06:53:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:53:22 <jkff> Lemmih: Is the rts package part of ghc?
06:53:36 <Lemmih> jkff: Yes.
06:53:37 <jkff> Ah, I see it
06:53:38 <Saizan_> ksf: there's a preliminary patch on cabal-devel@ , it's not very smart at finding solutions, but it works
06:53:47 <ivanm> ManateeLazyCat: I'd worked out that 'Q' quit from w3m; I'm just so used to using 'q' to quit sub-parts of gnus
06:53:52 <jkff> Time to install ghc-6.12 :)
06:54:24 <Lemmih> jkff: The rc's for ghc-6.12 won't do.
06:54:25 <ivanm> jkff: it's not out yet...
06:54:31 <ManateeLazyCat> ivanm: w3m is great for emacswiki.org
06:54:43 <ivanm> ManateeLazyCat: oh, they've optimised it for that, have they? :p
06:55:07 <jkff> Lemmih: What if I do want to get my hands dirty? :)
06:55:23 <ManateeLazyCat> ivanm: Yes, Alex do that, but it use firefox manage emacswiki.org.
06:55:35 <ManateeLazyCat> ivanm: It should use yaoddmuse.el manage emacswiki.org.
06:55:49 <ManateeLazyCat> ivanm: Maybe we need query for Emacs topic. :)
06:55:50 <Lemmih> jkff: Then join #lhc-compiler and I'll help you get to it.
06:56:10 <ManateeLazyCat> ivanm: Here is #haskell. :)
06:56:16 <ivanm> heh
07:00:20 <ManateeLazyCat> ivanm: emacswiki.org admin at #emacs now, nickname : kensanata
07:00:46 <ManateeLazyCat> ivanm: Maybe i need rest some time to continue refactory code.
07:09:21 <ziman> twanvl, hello, did you get my e-mail? i sent you a patch fixing IntMultiSet in it
07:09:40 <ziman> (it was a few days ago)
07:15:13 <xcoder42> any idea why isUpper from Char is not in the scope of prelude?
07:16:28 <xcoder42> and how i alternatively could figure out if a char is uppercase?
07:16:51 <Raevel> nope, although i bet there are a lot of functions that people would like to see in the prelude
07:17:18 <Raevel> xcoder42: why not import from Char?
07:18:09 <xcoder42> oh right.. i was trying to load it.. but yes,, ofcoarse i need to import it.. thanks
07:22:14 <quicksilver> xcoder42: import Data.Char would be the new way
07:22:20 <quicksilver> xcoder42: (Char is the old name)
07:22:29 <quicksilver> xcoder42: and as for why? well, it just isn't ;)
07:23:11 <xcoder42> ok :)
07:26:11 <ManateeLazyCat> How many emacser in this channel?
07:26:16 <ManateeLazyCat> @spy
07:26:16 <lambdabot> Maybe you meant: pl src
07:26:57 <Jafet> We're yiffy!
07:27:02 <quicksilver> dunno. A minority but a sizeable one, I guess.
07:27:12 <medfly> yiff in hell
07:27:24 <Berengal> I use yi for haskell, but emacs for just about everything else
07:27:44 <Twey> I thought emacs was the most popular Haskell editor at the moment.
07:27:56 <rittyan> I agree
07:28:09 <quicksilver> it may be the most popular and still a minority
07:28:14 <Twey> That is true
07:28:14 <ManateeLazyCat> quicksilver, Me.
07:28:14 <quicksilver> and, that is what I suspect to be the case.
07:28:32 <ManateeLazyCat> I think have many emacser in this channel.
07:28:48 <lispy> ?quote unsafePerformSex
07:28:48 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
07:28:52 <Raevel> I emacser
07:29:18 <lispy> succ emacs
07:29:36 <rittyan> I want to try textmate
07:29:47 <lispy> (I've decided that's the haskell way of saying foo++)
07:29:50 <Raevel> i tried textmate, then i tried emacs and then i tossed textmate
07:30:01 <ManateeLazyCat> rittyan: textmate is kid toy
07:30:29 <rittyan> hmm :<
07:30:50 <rittyan> well, I will still have aquamacs if I won't like textmate, okay
07:30:55 <medfly> is it wrong to want to turn an IO String into a String?
07:30:58 <ManateeLazyCat> Emacs is best editor, in most feature.
07:31:13 <mauke> medfly: yes
07:31:13 <medfly> most bloated wins!
07:31:15 <ManateeLazyCat> medfly: Yes.
07:31:18 <medfly> damn...
07:31:29 <Raevel> medfly: it's not wrong to want to :-) but doing so is wrong
07:31:31 <mauke> medfly: don't try to pull the String out; push yourself in instead
07:31:36 <ManateeLazyCat> medfly: unsafePerformIO can do that, but don't do that.
07:32:08 <Raevel> rittyan: i use carbon emacs on os x
07:32:36 <rittyan> Raevel: does it work? ttf fonts and everything? I want to switch platforms w/o switching my profession
07:32:46 <Twey> medfly: Depends.  It might be right, but it probably isn't.
07:33:06 <Twey> Are you writing a binding to some external, semantically-pure function?
07:33:13 <Raevel> rittyan: it works very well, the fonts too
07:33:17 <medfly> I have no idea what that means ^^
07:33:29 <mauke> medfly: then you aren't :-)
07:33:36 <Twey> Hehe.  Aye.
07:33:41 <ManateeLazyCat> Today is bla bla bal day.
07:33:50 <ManateeLazyCat> I haven't login IRC long time.
07:33:59 <lispy> Raevel, rittyan: emacs 23 natively supports OS X
07:34:02 <ManateeLazyCat> Need to talk with you guy.
07:34:17 <lispy> So, if you upgrade then you don't have to run carbon/aqua
07:34:24 <Raevel> oh
07:34:25 <rittyan> lispy: wow, then I'm buying that expensive hardware asap
07:34:31 <lispy> IIRC, emacs23 behaves most like aqua
07:34:51 <medfly> I want to make something that makes use of Network and Control.Concurrent.Chan, and I'm editing some code someone has given me a while ago. does that make sense?
07:35:18 <ManateeLazyCat> Have #haskell-blah?
07:35:27 <lispy> (eg., the way meta and ctrl are handled won't be familiar if you prefer carbon emacs)
07:35:30 <medfly> this channel makes me feel awfully noob :-)
07:35:48 <mauke> http://haskell.org/haskellwiki/Real_World#haskell
07:35:49 <ManateeLazyCat> medfly: Me too. :)
07:36:07 <lispy> ManateeLazyCat: was that directed at the emacs discussion.  If so, I'm happy to move it
07:36:08 <quicksilver> lispy: ack what a disaster
07:37:15 <ManateeLazyCat> lispy: Maybe create new channel #emacs-haskell. :)
07:37:45 <lispy> ManateeLazyCat: :)
07:37:47 <ManateeLazyCat> #emacskell
07:38:14 <Twey> medfly: If you're using networking and concurrency, your function probably isn't pure, so it should stay safely wrapped up in IO.
07:38:16 <lispy> Or, more generally, #emacs-ide
07:38:19 <lispy> er
07:38:23 <lispy> #haskell-ide
07:38:29 <ManateeLazyCat> lispy: Why can't see you in #emacs, i'm sure you're old emacser.
07:38:46 <chaosape> "medfly: don't try to pull the String out; push yourself in instead" -- I wish that was the first thing you read about the IO monad.
07:38:56 <lispy> ManateeLazyCat: I don't go to #emacs except when I have a question
07:39:07 <Twey> chaosape: Hehe, aye
07:39:07 <Blasa> I'm making a small dsl for the automatic creation of setter/getter functions (in a variety of languages) from descriptions of binary data. E.g. given the spec of the ntfs file system get the Nth filename. Does the following seem like a good high-level design?
07:39:16 <Twey> Someone should make a note of that somewhere
07:39:28 <ManateeLazyCat> lispy: #emacs is funny channel, i always talk with many old friend in there.
07:39:44 <lispy> ManateeLazyCat: :)
07:39:46 <ManateeLazyCat> lispy: #haskell is hot channel, have many teacher will teach me how to use Haskell.
07:39:52 <Blasa> 1) Parse using parsec 2) Transform to agnostic description of functions 3) Convert to desired function
07:39:55 * lispy goes to read about webDAV
07:40:12 <lispy> ManateeLazyCat: yeah, #haskell is nice.  Full of good people
07:40:18 <medfly> scary people, you mean
07:40:48 <ManateeLazyCat> lispy: Like medfly said, #haskell make me feeling like foolish. :)
07:41:03 * ManateeLazyCat I like #haskell, as #emacs.
07:41:25 <Twey> medfly: We're not scary
07:41:31 <Twey> medfly: We're all about teddy-bears
07:41:34 <mauke> BOO
07:41:36 <Twey> And hugs, and rainbows
07:41:47 <mauke> s/rainbows/ghci/
07:41:51 * Twey laughs.
07:43:41 <ManateeLazyCat> lispy: See http://geekspeak.org/shows/2008/02/02/2008_02_02_9693_350w.jpg  !!!!
07:44:11 <Twey> Haha
07:44:11 <ANONYM> #
07:44:11 <ANONYM> # PROJECT FILE generated by "Pelles C fr Windows, Version 6.00".
07:44:12 <ANONYM> # WARNING! DO NOT EDIT THIS FILE.
07:44:14 <ANONYM> BRRR
07:44:16 <ANONYM> sry
07:44:40 <davidL> ManateeLazyCat: who's the guy on the left?
07:44:57 <ManateeLazyCat> davidL: Boyfriend?
07:45:12 <ManateeLazyCat> http://geekspeak.org/shows/2008/02/02/
07:45:35 <ManateeLazyCat> davidL: Funny?
07:45:55 <ManateeLazyCat> Should be sweet..... ;-)
07:45:57 <Makoryu> @pl \xs -> foldr seq () xs `seq` xs
07:45:57 <lambdabot> (line 1, column 20):
07:45:57 <lambdabot> unexpected " "
07:45:57 <lambdabot> expecting variable, "(", operator or end of input
07:46:26 <Makoryu> @pl \xs -> seq (foldr seq foo xs) xs
07:46:27 <lambdabot> seq =<< foldr seq foo
07:46:37 <mauke> @hoogle rnf
07:46:37 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:46:52 * medfly gets a confidence boost as her sister puts her "programming homework" on the table.
07:47:17 * rittyan has no sister => no confidence
07:47:21 <mauke> .oO( can't afford food? )
07:47:29 <Makoryu> :t rnf `asTypeOf` id
07:47:30 <lambdabot> Done -> Done
07:47:37 <Makoryu> Psh
07:49:29 * ManateeLazyCat Okay, bla bla bla enough. See you. :)
08:18:24 <mmorrow> quicksilver: ping
08:21:36 <quicksilver> mmorrow: ello
08:24:29 <fasta> Did anyone write a version of read which shows the input when it fails and the line number of the source code etc?
08:24:42 <mmorrow> quicksilver: was thinking about ManateeLazy's thing, and think something like this would be interesting (although the practicality would depend on some boilerplate code generation i think) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4468
08:25:21 <ksf> fasta, the polyparse haddocks claim to do that
08:26:12 <mmorrow> the major annoyance is that you can't open records, and that there's no way to communicate type sharing to haskell's type system, so you'd need to unsafeCoerce every function of every substructure of the top-level structure to the types you know that they really are, which is the bit i think would be impractical without being automated
08:26:33 <mmorrow> and you'd need to do that *in every single module(
08:26:48 <fasta> ksf: and what is the name of the function?
08:26:50 <mmorrow> module Foo where
08:27:02 <fasta> ksf: and module
08:27:11 <mmorrow> #include "Coercions.hs"
08:27:14 <mmorrow> ..
08:27:35 <mmorrow> or whatever, which would do e.g.
08:29:24 <ksf> fasta, it's in polyparse, somewhere.
08:29:25 <mmorrow> someThing :: <fill in real type>; someThing = unsafeCoerce (case Top.topStruct of ManateeStruct (.... fooStruct ....) -> case Top.fooStruct of Top.FooStruct (... 100 functions .... Top.someThing ... 50 functions .. .) -> Top.someThing)
08:29:27 <ksf> it's not a big package.
08:29:49 <fasta> If there already exists a Read instance for a type, then we can make a Parser for it, but with only poor error-reporting. The string argument is the expected type or value (for error-reporting only).
08:29:52 <mmorrow> and you can't use record selectors there because ghc will complain, since it's an existential match
08:29:54 <fasta> parseByRead has that
08:30:24 <fasta> So, I don't see polyparse doing anything with source code.
08:31:14 <ksf> ah, _that_ kind of line number.
08:31:17 <ksf> assert can do that.
08:31:23 <ksf> @hoogle assert
08:31:23 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:31:23 <lambdabot> Control.OldException assert :: Bool -> a -> a
08:31:23 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
08:31:29 <mmorrow> quicksilver: and even if the boilerplate was managed, doing this would probably kill all cross-module optimizations ghc might do
08:31:53 <ksf> ...but you have to have assert on the line you want the error to be reported at.
08:31:54 <mmorrow> (i'm pretty sure, but not positive of that)
08:32:04 <ksf> ghc does some magic to implement it.
08:32:10 <hackagebot> HoleyMonoid 0.1 - Monoids with holes. (MartijnVanSteenbergen)
08:32:37 <fasta> ksf: yes, not really, what I was searching for. I will just write it myself.
08:32:58 <mmorrow> quicksilver: so, all of that being said. i think a program that acted as a preprocessor for a group of modules, and generated all of this would be neat. :)
08:33:42 <ksf> dunno if you can do something with the preprocessor and some magic __LINE_NUMBER__ macro or something.
08:33:47 <quicksilver> mmorrow: you're modelling (part of) ML functors aren't you?
08:33:58 <ksf> ...such macros have the advantage of floating upwards.
08:34:03 <mmorrow> quicksilver: right, that's the rough idea
08:34:16 <quicksilver> mmorrow: yes, I'm sure you can do that. I'm surprised you need unsafecoerce actually
08:34:24 <quicksilver> I'd have thought careful use of polymorphism would be enough
08:34:27 <quicksilver> (possibly rank-two)
08:34:32 <mmorrow> quicksilver: the painful part though is that you have to shoehorn that into records with existential types
08:34:38 <mmorrow> which is a pretty poor match
08:34:54 <quicksilver> whilst I consider that an interesting exercsie I'm quite sure it's not necessary.
08:34:58 <quicksilver> :)
08:35:11 <quicksilver> I'm sure MLC's code can be sensibly factors to break most of the recursive loops.
08:35:25 <quicksilver> it's just bad design to have too much mutual interdependency anyway.
08:35:48 <quicksilver> occasionnally you break a particularly tight loop with a specifically polymorphic interface
08:35:50 <mmorrow> quicksilver: i'm not sure, i kind of was thinking of something like this already, so his situation gave me a concrete example where i could make a mock-up. i'm not sure i'd suggest that he actually do this.
08:36:57 <mmorrow> quicksilver: i think the root of his problem is the same as ghc has, in that everything is inherently interconnected with everything else
08:38:13 <mmorrow> but i dunno, there probably is a fairly decent solution where the number of boot modules is reduced to one
08:38:59 <mmorrow> but i really think he can't have both of zero boot modules as well as abstraction
08:39:20 <mmorrow> (..with the current design he has)
08:43:05 <MrBlueSky> Hey guys. I now believe in love at first sight.
08:43:09 <MrBlueSky> <3haskell
08:43:27 <mmorrow> quicksilver: oh. actually, since there'd be no coercions or existential types necessary, since all the types can just go in a single module
08:43:36 <mmorrow> (continuing the exercise)
08:43:38 <ksf> yep, haskell is that kind of girl.
08:43:42 <MrBlueSky> Question though for any lurkers in here. Is it possible to leave comments in haskell code?
08:44:07 <dolio> Heh.
08:44:09 <dolio> No commenting!
08:44:10 <mmorrow> quicksilver: so then the only inconvenience that remains is not being able to "open" a record
08:44:17 <MrBlueSky> Serious?
08:44:18 <mauke> MrBlueSky: o_O
08:44:22 <int-e> > {- perhaps -} 42 -- perhaps not
08:44:24 <lambdabot>   42
08:44:24 <mmorrow> heh
08:44:25 <Jafet> Of course not, all code must be self-commenting
08:44:36 <Jafet> That's why it has a type system!
08:44:43 <mauke> MrBlueSky: {- block comment -},  -- single line comment
08:44:53 <ksf> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
08:45:06 <MrBlueSky> Thankya, google surprisingly failed me entirely here.
08:45:22 <mauke> preflex: ? lyah
08:45:22 <preflex>  http://learnyouahaskell.com/
08:45:24 <mauke> preflex: ? rwh
08:45:24 <preflex>  http://book.realworldhaskell.org/read/
08:45:32 <MrBlueSky> I'm using learnyouahaskell
08:45:42 <mauke> oh, cool
08:45:43 <mmorrow> quicksilver: yeah, think about it a little more.. i think this is just a result of his choice of design, rather than anything that's inherent here.
08:46:54 <benmachine> so guys, how do I load compiled (i.e. optimised) code into ghci?
08:46:55 <netinho> is someone willing to help me with a function?
08:47:23 <ksf> pre-compile it
08:47:28 * benmachine has worked out that ghci Foo.o -package thing will load it but no functions from it seem to eb available
08:48:31 <jkff> netinho: Probably not, because the task is too mysterious and I've forgotten to put on my telepatic helmet
08:49:04 <netinho> jkff: :D
08:49:11 <netinho> I want to make a function called fromTo
08:49:23 <mauke> benmachine: did you export the functions?
08:49:37 <netinho> fromTo 2 4 [0..9] returns [2,3,4]
08:49:47 <netinho> basicly, it's like index selection
08:50:01 <Khaoz> humm.... learnyouahaskell.com is nice... after read realworldhaskell.org i will take a look.
08:50:22 <benmachine> mauke: think so
08:50:43 <netinho> I think I should use drop for the first int
08:50:52 <netinho> but then I don't know what to do
08:50:57 <sproingie> i found both rwh and lyah to be kind of a hodgepodge
08:51:01 <netinho> maybe use a take
08:51:32 <sproingie> between the two plus all the other hard to follow tutorials it works.  i just wish there was a haskell tutorial written by someone with a little knowledge of didactics
08:52:00 <quicksilver> mmorrow: I'd love to help hiim but that code is too large to grok in 90-second chunks :)
08:52:26 <benmachine> netinho: so, the two arguments are list indices?
08:52:28 <benmachine> not values
08:52:32 <netinho> yeah
08:52:59 <benmachine> well, using take sounds like a good idea
08:53:08 <benmachine> you just have to work out how many you want
08:53:50 <mmorrow> quicksilver: (or to grok in 90 minutes)
08:54:18 <netinho> brb, going to class
08:54:28 <netinho> thanks for the help, my hamies
08:54:29 <jkff> netinho: Try developing the function interactively right here with lambdabot, we'll help
08:54:32 <netinho> haskell homies
08:55:01 <Jafet> @pl \a b c -> take (b-a) $ drop a c
08:55:01 <lambdabot> ap (flip . (((.) . take) .) . subtract) drop
08:56:29 <mxc> hi
08:57:33 <Jafet> @pl \a b c -> drop a $ take b c -- prettier
08:57:33 <lambdabot> (. take) . (.) . drop
08:57:33 <mxc> i have a question about the +RTS -NX flag on Mac OS X..  if i set X to be 1, then activity viewer/top report 4 threads, X = 2, then they report 7 threads, etc etc.  shouldn't X be the max number of OS threads that the processwill create?
08:57:38 <mxc> or am i misunderstanding something (entirely likely)
09:00:20 <jkff> mxc: Maybe -NX does not take into account gc threads
09:00:36 <mxc> jkff: sounds possible
09:00:57 <mxc> i flicked on the -B flag and my mac turned itself into a beatbox
09:01:20 <xenoblitz> Hi Haskellers,
09:01:24 <medfly> hi Haskeller
09:01:42 <xenoblitz> I am looking for a way to call Haskell from Java... is there a way to do so?
09:02:09 <mxc> but still, one - three GC threads for each non GC OS thread?  wouldn't that defeat the point of the lightweight haskell threads?
09:02:22 <ksf> I think you need a) a ship to go there b) some idea where haskell is, c) a large megaphone
09:02:43 <mxc> xenoblitz > i looked into that.  afaik, its impossibly
09:02:47 <mxc> impossible
09:03:00 <Jafet> JNI <-> C <-> Haskell
09:03:04 <Jafet> Easy
09:03:09 <ksf> but then, you could just use both language's c ffi's.
09:03:17 <ksf> also, there's the glue than eclipsefp uses.
09:03:23 <fasta> What is ambiguous about this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11094#a11094
09:03:30 <mxc> xenoblitz > my solution was to write some wrappers around a java API that I needed to talk to and then communicate with haskell via JSON over a socket
09:03:33 <ksf> (which might be exactly what you want, they're writing eclipse plugins in haskell)
09:03:43 <fasta> Jafet: do you speak from experience with your qualified "Easy"?
09:03:45 <mxc> jafet > let me rephrse, impossible w/out getting into JNI ...
09:03:46 <xenoblitz> mxc I was in fact thinking of something like JSON
09:04:03 * benmachine still can't work out why ghci reports his file linking correctly but doesn't seem to have any of the relevant symbols available
09:04:04 <Jafet> No, I speak from sarcasm.
09:04:13 <mxc> xenoblitz> i use google gson on the java side and the text.json package from hackage
09:04:16 <fasta> I use the nomonomorphism option.
09:04:22 <Jafet> There is swig, but those guys are shady
09:04:29 <mxc> swig?
09:04:38 <stedolan> C <-> Haskell isn't too bad, JNI <-> C is painful
09:04:42 <fasta> Interface generator, don't expect miracles.
09:05:11 <mxc> on this subect, regarding C++ <-> Haskell..
09:05:22 <stedolan> also, I don't think swig supports haskell yet
09:05:34 <mxc> do you need to write C wrappers around the C++ library and then go c <-> c++ <-> haskell?
09:05:42 <stedolan> I think C++ <-> Haskell is going to be C++ <-> C <-> Haskell
09:05:50 <xenoblitz> mxc: thanks... I was going to try to use the JSON package from RWH :) but anyone would do I think
09:05:58 <quicksilver> mxc: one GC thread per haskell thread
09:06:03 <stedolan> I don't think there's a way to map C++ classes and objects, etc straight to haskell. I'm not sure it would make any sense to do so
09:06:10 <quicksilver> mxc: plus an RTS thread an an IO manage thread, or something
09:06:43 <sproingie> xenoblitz: ironically, the json library from RWH isn't very real-world
09:07:01 <mxc> quicksilver> and those are OS threads correct?  if so, does that mean that the match your # os threads to your # cores isn't really accurate?
09:07:03 <xenoblitz> sproingie: its very basic my guess is
09:07:11 <sproingie> quite
09:07:24 <xenoblitz> sproingie ... which is the most utilized JSON library?
09:07:35 <xenoblitz> I had a look in hackage and found various
09:07:40 <mxc> xenoblitz > as long as you can derive Data and Typeable for your values, the Text.JSON package is fine
09:07:40 <quicksilver> fasta: without knowing the types of the functions and without seeing an error message it is very hard to guess.
09:07:44 <mxc> but
09:07:55 <mxc> you're java classes on the other side will be a little strange
09:08:01 <quicksilver> mxc: well if you run with -N3 then there will be 'most of the time' 3 haskell os threads wanting to run
09:08:12 <quicksilver> mxc: the GC threads only run during GC, and the RTS/IO threads don't run very often
09:08:15 <mxc> like the way I turned data A = A String | B Int | C (String, Int) into a java class
09:08:28 <mxc> quicksilver > got it..  thanks
09:08:59 <mxc> doh
09:09:02 <mxc> %GC time      63.6%
09:10:00 <mxc>   1,033,436,920 bytes allocated in the heap  / 493,541,976 bytes copied during GC /       6,021,068 bytes maximum residency (238 sample(s))
09:10:11 <quicksilver> fasta: OK I worked out the types. I agree at first glance that does not seem ambiguous. What was the error?
09:10:35 <mxc> hehe, just need to get it to be a bit less aggressive with the garbage collection... I grew up in pihlly, i can live wtih some trash lying around..
09:10:43 <fasta> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11095#a11095
09:10:48 <mxc> thanks guys
09:10:48 <fasta> quicksilver: the whole module.
09:11:01 <fasta> quicksilver: a use of rest_string was ambiguous
09:11:25 <quicksilver> fasta: I just added headDef and it compiled fine
09:11:40 <fasta> quicksilver: version?
09:11:51 <quicksilver> fasta: 6.8.3
09:12:08 <Blasa> @type chunk
09:12:09 <lambdabot> forall t a. ([t] -> a) -> ([t] -> [t]) -> [t] -> [a]
09:12:10 <fasta> quicksilver: I use .10.4
09:12:24 <quicksilver> can you paste the exact error message?
09:12:37 <Blasa> > chunk (take 3) (drop 3) [1..60]
09:12:38 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
09:12:54 <MyCatVerbs> @index chunk
09:12:55 <lambdabot> bzzt
09:13:01 <MyCatVerbs> Gadzooks!
09:13:07 <Blasa> chunk is something I've made up.
09:13:14 <quicksilver> fasta: for lack of ambiguity, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11094#a11096
09:13:21 <quicksilver> fasta: this version compiles fine for me.
09:13:24 <Blasa> I wanted to know if I'm reinventing a wheel.
09:13:28 <MyCatVerbs> It'd be neat if \bot spat the @let back in that case.
09:14:12 <Blasa> The src is: chunk s e [] = []
09:14:25 <Blasa> chunk s e xs = (s xs: chunk s e (e xs) )
09:14:49 <fasta> ghci-6.11.20090819 returns another random result.
09:14:54 <fasta> I will try your version now.
09:16:28 <Botje> Blasa: Data.List.Split has some modules for splitting.
09:16:35 <fasta> quicksilver: nope, doesn't work here.
09:16:44 <fasta> The compiler gods must hate me.
09:17:09 <fasta> Anyone running 6.10.4?
09:17:43 <Botje> i have access to a box with 6.10.4, yes
09:17:46 <trzkril> fasta: sure
09:18:03 <fasta> trzkril: can you check whether http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11094#a11096 loads?
09:18:27 <trzkril> fasta: the first paste?
09:18:30 <fasta> trzkril: you can run it as ghci -XNoMonomorphismRestriction
09:19:00 <jmcarthur_work> :t \f g -> map f . iterate g
09:19:01 <lambdabot> forall a b. (a -> b) -> (a -> a) -> a -> [b]
09:19:04 <fasta> trzkril: the second
09:19:13 <fasta> trzkril: the one saying "this works for me".
09:19:13 <jmcarthur_work> :t \f g -> map f . iterate g :: ([t] -> a) -> ([t] -> [t]) -> [t] -> [a]
09:19:14 <lambdabot>     Couldn't match expected type `([t] -> [t]) -> [t] -> [a]'
09:19:14 <lambdabot>            against inferred type `[b]'
09:19:14 <lambdabot>     In the first argument of `(.)', namely `map f'
09:19:27 <jmcarthur_work> oops
09:19:34 <jmcarthur_work> :t (\f g -> map f . iterate g) :: ([t] -> a) -> ([t] -> [t]) -> [t] -> [a]
09:19:34 <Botje> fasta: loads on both 6.10.4 and 6.10.3 here.
09:19:34 <lambdabot> forall t a. ([t] -> a) -> ([t] -> [t]) -> [t] -> [a]
09:19:42 <trzkril> fasta: seems to load fine
09:19:49 <fasta> Oh, great...
09:20:29 <jmcarthur_work> Blasa, dunno if you are reinventing the wheel, but there is a simpler definition for it (i think they are the same, at least) ^^
09:20:39 <trzkril> fasta: even with the monomorphism restriction
09:20:51 * quicksilver thinks fasta must have done something *very* bad in a past life.
09:21:01 <Blasa> jmcarthur, I thought there probably was. Thanks.
09:21:14 <fasta> Is there a way to run ghci without it using any kind of variables from the environment?
09:21:23 <fasta> Like emacs -Q?
09:22:29 <sproingie> env -i ghci
09:23:17 <fasta> Ok, it works here now too. I had some language pragmas still enabled.
09:23:35 <fasta> I don't see yet why they would change the semantics of the program, though.
09:23:37 <quicksilver> fasta: I'm curious, which language pragmas break that code?
09:24:48 <fasta> NoMonoPatBinds :P
09:24:55 <fasta> Obvious in hindsight.
09:25:21 <fasta> Thanks, people.
09:25:59 <quicksilver> NoMonoPatBinds doesn't break it for me.
09:26:09 <quicksilver> but I do recall that exension being tweaked recently.
09:26:42 <quicksilver> ah yes
09:26:52 <quicksilver> I can see
09:27:00 <quicksilver> parsed_result might remain polymorphic
09:27:01 <quicksilver> hmm
09:27:43 <patch-tag> if you cabal install somelib, does it automatically install haddock docu, and if so where?
09:28:48 <copumpkin> patch-tag: only if you enable that in your cabal config
09:30:16 <Blasa> jmcarthur, actually not quite the same. Very similar, your function needs some way of stopping on the empty lists that  drop produces.
09:34:27 <saml> is there nosql database written in haskell?
09:34:34 <jmcarthur_work> Blasa, ah, you're right
09:35:01 <jmcarthur_work> Blasa, so maybe it should actually be an unfoldr instead of an iterate or something
09:35:31 <quicksilver> unfoldr is so clumsy though
09:35:31 <Twey> saml: The ACID monad?
09:35:40 <jmcarthur_work> yeah, that does suck
09:35:41 <saml> Twey, thanks. let me look it up
09:35:52 <jmcarthur_work> :t unfoldr
09:35:53 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:36:08 <quicksilver> there was quiet an interesting explanation as to why it feels clumsy on the cafe recently
09:36:16 <saml> hrm it's from happstack
09:36:21 <jmcarthur_work> how recently?
09:36:26 <quicksilver> today or yesterday
09:37:05 <quicksilver> jmcarthur_work: http://www.mail-archive.com/haskell-cafe@haskell.org/msg66231.html
09:37:14 <quicksilver> jmcarthur_work: (footnote [3] but you kind of need the context I think)
09:37:37 <jmcarthur_work> quicksilver, actually, from a quick skim, i understand what's going on there
09:37:43 <absentia> arrgh!  I was able to pull up this pdf yesterday and earlier today.. but now it seems to require a login.. WTF?  does anyone have a copy of this pdf?  http://portal.acm.org/citation.cfm?id=1238856&dl=GUIDE&coll=GUIDE&CFID=57390487&CFTOKEN=50896203
09:37:52 <jmcarthur_work> quicksilver, i have done the same thing as in [3]
09:38:02 <quicksilver> the point is, we're using Maybe because it happens to be isomorphic to the 'base functor' for []
09:38:06 <jmcarthur_work> quicksilver, implementing anamorphisms, though
09:38:16 <jmcarthur_work> right
09:38:21 <quicksilver> but it feels clumsy because Maybe doesn't feel like []
09:38:28 <quicksilver> mostly because of the notation, to be honest
09:38:33 <hackagebot> curry-base 0.2.7 - Functions for manipulating Curry programs (BerndBrassel)
09:38:35 <hackagebot> curry-frontend 0.2.9 - Compile the functional logic language Curry to several intermediate formats (BerndBrassel)
09:38:41 <quicksilver> big long clumsy Just/Nothing vs short symoblic :/[]
09:39:20 <absentia> found it.. fvck acm login bs  http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
09:39:34 <burp> ah ok, was just trying if I can download it
09:39:48 <lament> C# has some nice syntax for the C# equivalent of Maybe. The type "Maybe Int" would be "int?"
09:40:15 <Beelsebob> I would take that as syntactic sugar for Surprised Int
09:40:17 <Vanadium> Would it?
09:40:24 <jmcarthur_work> quicksilver, http://hackage.haskell.org/packages/archive/fixpoint/0.1.1/doc/html/src/Data-Fixpoint-Instances.html
09:40:42 <stedolan> lament: it's not full Maybe as far as I know. I don't think you can express Maybe (Maybe Int) in C#
09:40:48 <jmcarthur_work> quicksilver, along with http://hackage.haskell.org/packages/archive/fixpoint/0.1.1/doc/html/Data-Fixpoint.html
09:40:53 <lament> stedolan: right, no.
09:41:04 <jmcarthur_work> quicksilver, mine is basically like that
09:42:00 <lament> stedolan: or rather, obviously you can express it with a polymorphic container type, just as you can in Haskell, it's just not done
09:42:27 <stedolan> sorry, of course you can express the full notion of Maybe in C
09:42:31 <lament> and the sugar doesn't cover that case
09:42:36 <stedolan> *c#, just not via the ? syntax
09:42:37 <stedolan> yeah
09:42:41 <lament> stedolan: in C, not really
09:42:50 <lament> no type polymorphism
09:42:52 <stedolan> enter and # are too close together on my keyboard :D
09:43:06 <jmcarthur_work> you can do it in c++. it just makes your coworkers hate you
09:44:46 <Twey> Also your brain
09:45:30 <lament> explode
09:47:41 <hackagebot> KiCS 0.9.1 - A compiler from Curry to Haskell (BerndBrassel)
09:48:33 <medfly> haha
09:48:42 <hackagebot> KiCS-prophecy 0.1.0 - a transformation used by the kics debugger (BerndBrassel)
09:50:34 <copumpkin> why is there no modifyTVar?
09:50:42 <hackagebot> KiCS-debugger 0.1.0 - debug features for kics (BerndBrassel)
09:50:52 <copumpkin> I know it isn't needed for atomicity, but just as a convenience function it would be nice
09:56:31 <mxc> more RTS questions..  I've tried maxing out the -Asize and -H size (512m each) and since the "bytes allocated on the heap" is usually around 3-400m, but i still spend a huge amount of time in GC?
09:56:51 <mxc> with -B i can hear it beeping constantly, and the GC time is always > 40%
09:57:11 <mxc> (with the default settings its aroudn 50% so its a slight improvment, but not sure why i'm still getting so many collections
09:58:56 <copumpkin> mxc: what's your code doing?
10:00:16 <mxc> processing real time data.. so lots of green threads writing to a lot of Chan's and socket IO
10:01:12 <mxc> but if it allocates <400m total (unless i misunderstand the meaning of the "bytes allocated on the heap" number), when I se -H512m and/or -A512m, shouldn't that strongly limit the frequency of GCs?
10:01:31 <mxc> yes, its not really the typical haskell project :)
10:05:20 <john__> I would like to find a set of stamps that satisfies the following constraints:
10:05:20 <john__> No more than 3 stamps at a time.
10:05:20 <john__> Able to create the maximum sum possible for a n values of stamp.
10:05:21 <john__> For example, for 1 stamp value, a 1 cent stamp will get you to 3 cents.
10:05:21 <john__> For 2 stamp values, 1,3 will get you to 7 cents
10:05:21 <john__> For 3 stamp values: 1,4,5 will get you to 15 cents (1,1+1, 1+1+1,4,5,5+1,5+1+1,4+4,5+4,5+5,5+5+1,4+4+4,5+4+4,5+5+4,5+5+5).
10:05:23 <john__> For 4 stamp values: 1,4,7,8 will get you to 24 cents.
10:05:25 <john__> What is the result for 5 or more values of stamps?
10:05:27 <john__> What if you allow 4 stamps at a time?
10:06:21 <zygoloid> john__: are you allowed negative-valued stamps?
10:06:25 <john__> No
10:06:38 <tromp> but you're allowed 0 value stamps:)
10:07:57 <copumpkin> sounds like integer partitions?
10:08:16 <copumpkin> unless I'm misunderstanding what he wants to do
10:08:35 <copumpkin> john__: http://en.wikipedia.org/wiki/Partition_(number_theory)
10:08:43 <en0th> maybe i'm misunderstanding, but don't you get the maximum value by taking 3 stamps of maximum value ??
10:09:35 <Jafet> Since you stated the obvious, the OP will now supply a twist
10:09:36 <john__> You need to be able to get all values up to and including the maximum.
10:09:41 <zygoloid> sounds intimately related to complete integer sequences
10:09:50 <Jafet> And there we go.
10:10:06 <copumpkin> Jafet: too much IRC
10:10:18 <Jafet> Truth!
10:10:24 <Jafet> john, so what is the problem?
10:10:58 <zygoloid> Jafet: find a1, a2, a3 which maximises n such that [1..n] can be formed by a sum of three numbers from {a1, a2, a3}
10:11:02 <copumpkin> john__: what's wrong with just picking n stamps of maximum value?
10:11:07 * mxc understands partitions, but still has no idea what the actual question is or what "n stamp values' means
10:11:09 <zygoloid> s/three/k/
10:11:24 <copumpkin> mxc: yeah, now that I look more closely it doesn't seem to be what he needs
10:11:25 <zygoloid> copumpkin: you need to be able to form the value 1
10:11:28 <john__> Take a look at the third example above.
10:11:44 <tromp> try @oeis
10:11:58 <Jafet> Ah. The converse of this problem is Goulomb's ruler; this problem itself seems to be generating powers of 2, which shouldn't be too hard
10:12:00 <zygoloid> @oeis 3 7 15 24
10:12:01 <lambdabot>  a(n) = solution to the postage stamp problem with n denominations and 3 stam...
10:12:01 <lambdabot>  [3,7,15,24,36,52,70,93,121,154,186,225,271,323,385,450,504]
10:12:05 <copumpkin> lol
10:12:07 <john__> Buy a sheet of 1 cent stamps, 4 cent stamps, 5 cent stamps. Then try to form all values using up to 3 stamps at a time
10:12:16 <burp> postage stamp problem?
10:12:24 <Jafet> But I was going by zygoloid's misinformation
10:12:26 <john__> all values, meaning each value 1,2..,n
10:12:28 <copumpkin> http://en.wikipedia.org/wiki/Postage_stamp_problem
10:12:31 <john__> postage stamps, that's right
10:12:36 <mxc> ok
10:12:40 <mxc> now i get it
10:12:46 <copumpkin> that article made it a lot clearer to me :P
10:12:54 <ystael> @oeis 1 1 4 7 13
10:12:55 <lambdabot>  Tetranacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) +a(n-4).
10:12:55 <lambdabot>  [1,1,1,1,4,7,13,25,49,94,181,349,673,1297,2500,4819,9289,17905,34513,66526,1...
10:12:59 <Jafet> I don't think john gets it, so I don't understand how any of the rest of you can get it either
10:13:18 <zygoloid> @oeis 1 1 3 1 4 5 1 4 7 8
10:13:18 <lambdabot>  Sequence not found.
10:13:18 <copumpkin> Jafet: I searched the intertubes and found the wikipedia article on it
10:13:22 <mxc> wait, no i dont
10:13:24 <ystael> damn.  there needs to be an oeis drinking game.
10:13:47 <Jafet> The postage stamp problem has nothing to do with postage stamps...
10:13:54 <mxc> oh, 3 stamps on a sheet
10:13:56 <ystael> @oeis 1 2 6 18
10:13:57 <lambdabot>  Number of permutations satisfying i-2<=p(i)<=i+3, i=1..n.
10:13:58 <lambdabot>  [1,2,6,18,46,115,301,792,2068,5380,14020,36581,95413,248786,648714,1691686,4...
10:14:00 <mauke> the stamp is a lie
10:14:02 <zygoloid> john__: it sounds eminently brute-forceable for small numbers of stamps
10:14:09 <mxc> so, shouldn't you use powers of 4?
10:14:32 <mxc> since you can use 0..3 stamps of each denomination
10:14:46 <john__> I'm sure you can brute force it, but how to write a simple program?
10:14:47 <zygoloid> mxc: no, you're allowed 3 stamps in total
10:14:59 <mxc> oh ok
10:15:15 <mxc> starting to make more sense
10:15:20 <john__> I didn't realize wikipedia had an entry for it...
10:15:22 <copumpkin> john__: lots of references on http://mathworld.wolfram.com/PostageStampProblem.html
10:15:38 <zygoloid> john__: well clearly if these are integer>0 stamps then you want one stamp which is 1 cent
10:15:52 <john__> Sure, but you can only get up to 3 cents with that
10:16:08 <zygoloid> sure. but we need to start somewhere :)
10:16:17 <john__> I gave that as my first example
10:16:17 <Jafet> Have fun figuring out a problem that doesn't exist.
10:16:20 * Jafet popcorn
10:16:46 <zygoloid> Jafet: i think it is you who doesn't get it :)
10:17:14 <Jafet> What I do get is several people all saying they get it in different ways.
10:17:28 <mxc> before I got spend hours on this, is there a better than brute force solution?
10:17:38 <tromp> dynamic programming
10:17:51 <zygoloid> Jafet: i've not seen that. i slightly mis-summarized it, but i think mxc, myself and john__ are thinking of the same problem now at least
10:17:51 <mauke> demonic programming
10:18:03 <john__> No, dynamic programming doesn't really work
10:18:06 <Jafet> DLL hell!
10:18:11 <tromp> build in array a[1],a[2]... where a[i] is min # stamps needed to make i
10:18:57 <tromp> then a[i] = 1 + min_d a[i-d], where d ranges overe denominations
10:19:02 <mxc> tromp - i dont think so.. i thought you need to build an array of N numbers to maximize S such that S can be made by the sum of up to 3 elements of the array
10:19:16 <mxc> where numbers can be used repeatedly
10:19:16 <john__> The wikipedia article is a little different. It says that the minimum number that cannot be specified is the answer. I'm asking for the set of postage stamps that gives you the maximum possible sum.
10:19:18 <tromp> stop at first a[i] that's over 3
10:19:32 <mxc> tromp: sorry, thught you were explaining the problem. not the answer
10:19:47 <tromp> explaining DP solution
10:20:14 <mxc> not sure that would work
10:20:36 <zygoloid> Jafet: the problem is this. you're given k. you are to produce k integers, a1..ak, to maximize n, such that forall i from [1..n], there exist b_i, c_i and d_i \in {a1..ak,0} with i = b_i + c_i + d_i
10:20:39 <mxc> since any integer can be expressed by the sum of three smaller integers
10:20:40 <tromp> u still need to try all possible combinations of denominations
10:20:41 <mxc> :)
10:20:53 <patch-tag> copumpkin: thanks, I made a blog post based on your comment ;)
10:21:05 <copumpkin> patch-tag: :O
10:21:23 <patch-tag> http://blog.patch-tag.com/2009/10/23/cabal-install-a-package-with-documentation/
10:21:24 <mxc> zygoloid: except that you can do b_i + b_i  + d_i  (can use elements more than once)
10:21:39 <zygoloid> mxc: b_i = c_i is not forbidden by my formulation
10:21:45 <tromp> so this is O(k^k) solution for k denominations
10:21:55 <mxc> zygoloid : fair point :)
10:22:52 <mxc> i wonder if you can do something with eliminating stamp values
10:23:00 <Jafet> zygoloid, that problem cries out in the night, dynamic programming
10:23:10 <john__> I say dynamic programming doesn't work because of example 2 above, which has a solution 1,3. Others use 1,4...
10:23:17 <zygoloid> Jafet: where's the optimal substructure?
10:23:25 <Jafet> n.
10:23:31 <mxc> for instance, with 2 denoms, you can say that the 3 'knocks' out the 2
10:24:00 <Jafet> Of course, I'm still speaking with the off-chance that it isn't actually john's intended problem
10:24:14 <Jafet> So sue bear me
10:24:59 <john__> But if I'm wrong, then because haskell memoizes automatically, can't you just ignore dynamic programming. Also, assuming the wikipedia article is right and this is np-hard, then just generating the first few is good enough...
10:25:19 <zygoloid> Jafet: well, it fits both john__'s description and john__'s answers for small numbers of stamps
10:25:22 <Veinor> everything interesting is np-hard at the easiest, heh
10:25:37 <Jafet> Haskell does not "memoize automatically", for any conceivable value of that
10:25:56 <Zao> The closest you get is CSE, don't you?
10:25:57 <sproingie> haskell doesn't memoize so much as it avoids having to recompute in the first place
10:26:08 <copumpkin> you can memoize automatically with packages, but haskell doesn't do it
10:26:09 <Jafet> At this point I would surmise that john is doing us a disservice by not sharing whatever he's been smoking. Have a good day
10:26:12 <sproingie> but it'll still do redundant computation if you make it
10:26:25 <john__> well, my understanding, correct me if I'm wrong, is that memoization == dynamic programming.
10:26:33 <sproingie> memoizatoion is just caching results
10:26:43 <sproingie> (for some spelling of memoization)
10:26:54 <john__> == meaning isomorphic to
10:27:11 <sproingie> "dynamic programming" is vague
10:27:15 <mxc> haskell memoizes
10:27:25 <mxc> just in a weird, difficult to do way
10:27:26 <zygoloid> john__: right, operationally they mean slightly different things but yes, they're largely equivalent
10:27:48 <mxc> just build a lazy array or map that references itself
10:27:51 <tromp> haskell doesn't auto-memoize
10:28:07 <mxc> no, it doesnt
10:28:34 <mxc> but, doesn't neil mitchel's supero do some of that
10:28:37 <john__> anyway, i thought this would be a relatively simple program to write, especially for you haskell gurus. i'm just trying to learn haskell myself
10:28:42 <mxc> but with profiling and pre-computing values
10:28:54 <mxc> john_ the brute force bit is easy
10:29:17 <john__> can you explain the easy part?
10:29:29 <tromp> you brute-force over all denomination-sets, and then use DP to find max reachable amount
10:29:30 <mxc> but we're trying to find a polynomial solution for whats apparently an NP-hard problem..  even the geniuses here (not including myself) might struggle with that
10:29:40 <john__> the general solution appears to be hard, too hard perhaps
10:29:53 <mxc> as in i'm NOT one of the geniuses here, was complementing others
10:30:06 <conal> laziness is memoization for data structures
10:30:44 <conal> (when you think of data as accessor functions.)
10:30:52 <Cale> You can use the fact that parameters to functions won't be recomputed to sort of hijack sharing and use it for memoisation
10:31:06 <Cale> http://hackage.haskell.org/package/data-memocombinators
10:32:15 <john__> tromp, what you said sounds cool, but i don't understand. all denomination-sets?
10:32:51 <Jafet> Cale, that just sounds evil and twisted
10:33:10 <john__> memocombinators sounds very intimidating.
10:33:53 <dum8d0g> hi, I am following the book "Programming in Haskell: Graham Hutton" and I am trying to implement Caesar cipher from chapter 5.5. Unfortunately, in the book is used the ord:: Char -> Int and chr :: Int -> Char function, but my hugs ver. 200609 shouts: ERROR "ch05.hs":33 - Undefined variable "ord"
10:34:15 <dum8d0g> Does anybody knows, what went wrong?
10:34:18 <Zao> @type Data.Char.ord
10:34:19 <lambdabot> Char -> Int
10:34:19 <skorpan> dum8d0g: import Data.Char
10:34:26 <john__> whether the program runs in any reasonable time for larger values is not my question. I suppose the answer is that it won't. but for smaller values, what are some answers?
10:34:27 <Jafet> Oh oh, I learned some more python yesterday: def f(l = []): l.append(len(l)); return l;
10:35:00 <skorpan> Jafet: weird function
10:35:15 <dum8d0g> ah, import helped.
10:35:17 <dum8d0g> skorpan: thanks
10:35:34 <Jafet> Is why I believe python is designed by retards
10:35:56 <skorpan> Jafet: python is retarded because someone defined a retarded function in it?
10:35:59 <tromp> john__: a denomination set is for instance {1,4,5} which is the best one of size 3
10:36:20 <Jafet> Because it has retarded semantics
10:36:29 <skorpan> what about that is retarded?
10:37:31 <Jafet> for i in range(10): f();
10:37:42 <Jafet> Er, print f();
10:38:33 <sproingie> the semantics of using a reference type as a default are perfectly well-defined in python
10:38:51 <sproingie> it evaluates defaults exactly once, when the 'def' statement is evaluated
10:39:07 <sproingie> a poor craftsman blames his tools
10:39:12 <Jafet> This sort of style inherited from lisp, which I believe to be a mistake
10:39:28 <skorpan> that is pretty weird, yeah
10:39:47 <skorpan> even well-defined semantics can suck ass
10:40:01 <Jafet> Action at an obscure, unexpected, highly abusable and hilariously mysterious distance.
10:40:10 <sproingie> welcome to imperative languages
10:40:24 <skorpan> sproingie: this has nothing to do with imperativity (is that a word?)
10:40:30 <sproingie> python already suffers enough from "let's disallow it because someone could possibly abuse it somewhere"
10:40:46 <john__> It doesn't seem like the postage stamp problem should grow faster than polynomially. You know that one stamp must be 3 cents. Then the next has to be either 2,3,4. Depending on which, the next must be greater, but no more than 13. These kind of numbers sure don't seem exponential in growth.
10:40:49 <sproingie> i'm just glad it isn't completely dominated by that
10:41:35 <skorpan> another classic is: "x, y, z = [] * 3" which makes three references to the same list
10:41:47 <john__> I meant to say "one stamp must be 1 cent"
10:41:48 <sproingie> reference semantics again
10:41:48 <skorpan> not quite as weird, but still another list gotcha ;P
10:42:05 <sproingie> it's not a gotcha to anyone who understands reference types
10:42:22 <skorpan> that's ridiculous
10:42:35 <Jafet> I have never used a language with such obscure reference semantics as python.
10:42:43 <Cale> Well, references are much more confusing in untyped languages.
10:42:44 <zygoloid> another classic is: "x = (1,2); y = x; y += (3,4); print x" versus "x = [1,2]; y = x; y += [3,4]; print x"
10:42:50 <sproingie> right, because making special cases to defined semantics is always the right thing to do
10:42:52 <Wild_Cat> skorpan: actually, that last one raises ValueError
10:43:00 <Wild_Cat> skorpan: because [] * 3 == []
10:43:19 <sproingie> i suspect he meant [[]] * 3
10:43:22 <Cale> If you have that the type of something tells you that it's a reference and it requires you to explicitly read and write it, it's far less likely to blindside you like that.
10:43:24 <skorpan> Wild_Cat: weird, it does.  i was sure that bit me once?
10:43:27 <Wild_Cat> it's [[]] * 3 that returns 3 refs to the same list.
10:43:38 <sproingie> * duplicates refs, always
10:43:47 <sproingie> (on lists that is)
10:43:53 <Wild_Cat> which, again, is consistent with the way references behave.
10:43:58 <sproingie> exactly
10:44:01 <Wild_Cat> (and specified in the language ref)
10:44:04 <Cale> The right thing to do is never mutate anything ;)
10:44:08 <Jafet> So, erm, arrows.
10:44:14 <Jafet> Love'em.
10:44:41 <Wild_Cat> (also, in Python, *everything* is a reference. Always.)
10:44:47 <copumpkin> durn arroz
10:45:04 <skorpan> Wild_Cat: is 3 a reference?
10:45:24 <lament> everything is a reference, yet nothing is a reference
10:45:27 * lament meditatess
10:45:36 <Wild_Cat> skorpan: it's an object. a = 3 creates a reference to 3.
10:45:37 <copumpkin> Every reference is a value of type reference
10:45:38 <zygoloid> skorpan: 3 is an expression
10:45:55 <sproingie> 3 is a reference, it's just to an immutable object
10:45:57 <skorpan> Wild_Cat: is "a" a reference then?
10:46:13 <zygoloid> 3 is an expression referring to a value which may or may not be the same as the value 3 elsewhere
10:46:13 <Wild_Cat> so, for the more pedantic among you, everything on the lhs of a Python = statement is a reference to something on the rhs.
10:46:25 <skorpan> i'm not being pedantic, just curious
10:46:29 <Jafet> > let 2 = 2.5 in 2+2
10:46:30 <lambdabot>   4
10:46:36 <lament> skorpan: "a" is an object
10:46:38 <Jafet> Call the police!
10:46:40 <Wild_Cat> Jafet: .
10:46:43 <lament> skorpan: just as 3 is an object
10:46:51 <zygoloid> > let 2 + 2 = 5 in 4 - 2 + 2
10:46:51 <lambdabot>   -1
10:46:53 <lament> skorpan: variables store references to objects
10:47:32 <Wild_Cat> Haskell lets you redefine numbers? That's... That's... That's horrible!
10:47:32 <Cale> Wild_Cat: It doesn't.
10:47:32 <Jafet> Just like FORTRAN!
10:47:35 <dschoepe> Wild_Cat: that just redefines +
10:47:36 <Cale> Wild_Cat: It *does* let you redefine operators
10:47:38 <dschoepe> for this specific case
10:47:43 <lament> let 10 = 20 in GOTO 10
10:47:50 <dschoepe> > let 2 + 2 = 5 in 2 + 3
10:47:51 <lambdabot>   * Exception: <interactive>:1:157-165: Non-exhaustive patterns in function +
10:48:01 <Wild_Cat> Cale: oh, wait. I didn't read Jafet's example correctly.
10:48:15 <lament> Cale: so it lets you redefine operators, but not numbers. Such horrible inconsistency.
10:48:28 <Wild_Cat> I am, however, extremely surprised that "let 2 = 2.5" doesn't raise an error.
10:48:28 <zygoloid> > let 2 = 3; 1 = 0 in 2 + 1
10:48:29 <lambdabot>   3
10:48:31 <Jafet> Actually, I don't even know how that passes a syntax check
10:48:39 <Cale> Well, you can sort of redefine numbers, but it requires constructing a new datatype :)
10:48:45 <sproingie> > let 2 + _ = 666 in 2 + 10
10:48:45 <lambdabot>   666
10:48:53 <zygoloid> Wild_Cat: it never does the pattern match of 2 against 2.5 since it's lazier than that
10:49:00 <zygoloid> > let !2 = 2.5 in 2 + 2
10:49:02 <lambdabot>   * Exception: <interactive>:1:157-164: Non-exhaustive patterns in pattern bi...
10:49:11 <Wild_Cat> zygoloid: it's still... Ugly.
10:49:12 <Cale> Wild_Cat: That's a pattern match which fails and yet doesn't bind any variables, so there's never a chance for anything to care that it fails.
10:49:20 <Jafet> Bi? What is our haskell up to now
10:49:23 <copumpkin> Wild_Cat: not at all, I'd argue disallowing it would be ugly
10:49:46 <zygoloid> Wild_Cat: arguably, non-binding patterns should either be strict or illegal, since they're meaningless apart from a type-checking impact
10:49:48 <lament> it's ugly either way, whether allowed or disallowed
10:49:53 <Cale> I think the bang-patterns thing is ugly though.
10:49:55 <zygoloid> however i could imagine cases where that impact is useful, so...
10:50:08 <Cale> The fact that bang patterns can turn let into case is disturbing.
10:50:33 <zygoloid> Cale: only a single-way case, and that seems ok since they're ugly anyway :)
10:51:11 <Cale> I think that the original translation for bang patterns was much more appropriate there.
10:51:33 <Cale> Of course, it meant that putting a ! in that particular spot did nothing, but that's what I'd expect.
10:53:02 <luite> does anyone here have (or know) implemented haskell bindings for a linear programming solver? (preferably open source, but I can also use cplex)
10:53:58 <copumpkin> luite: I was planning to, but the Ord/Eq classes pissed me off so I decided against it :P
10:54:28 <zygoloid> luite: last time i used cplex it leaked memory to an enormous extent. i'd recommend coin-or's clp (but be aware that cplex is significantly faster in some cases)
10:54:46 <zygoloid> luite: but i don't know of haskell bindings for either, sorry!
10:55:35 <copumpkin> I wrote lpsolve bindings for ruby a while back
10:56:49 <zygoloid> I have some fairly nice lp_solve and Clp bindings for C++ :)
10:57:52 <luite> zygoloid: yes I know. I started working on a simple binding to clp, because I couldn't find any on hackage. cplex may be faster in most cases, but it doesn't seem to provide .a files for mingw (and converting the .lib files didn't seem to work well)
10:57:54 <copumpkin> yeah, anything with operator overloading would be nice
10:58:12 <copumpkin> but that's what frustrated me about haskell for this task
10:58:27 <copumpkin> I can't get my naturally expressed inequalities to return anything but Bool
10:58:50 <luite> and there are some licensing issues with cplex... not sure if it would run if I don't have a network connection
10:59:02 <copumpkin> ew
10:59:04 <zygoloid> copumpkin: import Prelude hiding ((<=),(>=)) ?
10:59:20 <copumpkin> zygoloid: I guess, but that feels dirty :)
10:59:33 <zygoloid> luite: at least with the linux library, you just point an environment variable at the license file
10:59:47 <copumpkin> luite: lp_solve is LGPL, which isn't idela
10:59:57 <copumpkin> ideal, but it's better than network license checking :P
11:00:07 <luite> zygoloid: oh I was told that it needed to connect to the license server
11:00:47 <luite> not sure if I can get a license file
11:01:08 <zygoloid> copumpkin: my wrapper dlopens it for exactly that reason :)
11:01:39 <copumpkin> zomg
11:01:44 <zygoloid> it would be nice if there existed a decent, BSD-licensed (or similar) LP solver
11:01:53 <luite> copumpkin: clp is CPL, which is probably less ideal than LGPL
11:03:07 <copumpkin> zygoloid: write one, in pure haskell!!!
11:03:08 <copumpkin> zomg
11:03:18 <copumpkin> I'm sure it'd be really simplex
11:03:21 <copumpkin> sorry, lame joke
11:07:30 <zygoloid> copumpkin: i would, but i don't see the interior point
11:08:00 <zygoloid> i don't have a pivotal need
11:08:24 <zygoloid> it would just increase the inequality between haskell and other languages
11:08:27 <zygoloid> ok i'm done
11:08:54 <ystael> zygoloid: but isn't maximizing that inequality precisely the objective? :)
11:09:30 <zygoloid> oh dear
11:09:44 <zygoloid> copumpkin: you've created a monster
11:09:54 <copumpkin> lol
11:10:08 <ystael> reddit has poisoned me for life
11:11:28 <copumpkin> :)
11:13:13 * dancor just got a segfault and lol-gasped
11:13:35 <Warrigal> @docs Random
11:13:35 <lambdabot> Random not available
11:13:54 <Warrigal> @index Random
11:13:54 <lambdabot> System.Random
11:13:55 <MrBlueSky> Are type declarations really all that important?
11:13:59 <Warrigal> @docs System.Random
11:13:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
11:14:06 <MrBlueSky> They seem kinda superfluous.
11:14:18 <Warrigal> MrBlueSky: well, code that's valid with them is usually valid without them.
11:14:43 <Warrigal> But they help to prevent you from writing code without knowing what you want it to do.
11:15:02 <Warrigal> Hmm, lambdabot's link is broken.
11:15:10 <MrBlueSky> ok, then I'll just skip them for juicier stuff for now.
11:15:10 <Cale> MrBlueSky: The nice thing is that you can usually leave them out if you want to.
11:15:33 <Warrigal> I think it wouldn't be a bad idea to write a program by first writing all the type signatures and stuff and then actually implementing it all.
11:15:42 <Cale> MrBlueSky: But whether you write them or not, understanding types is fundamental to understanding how to write Haskell code.
11:16:11 <MrBlueSky> I'm pretty sure I understand types. It's pretty much the same for most languages right?
11:16:24 <Cale> Well...
11:16:32 <sproingie> on some theoretical level perhaps
11:16:32 <copumpkin> Warrigal: yeah, that's quite common (to some degree, at least)
11:16:33 <Warrigal> Haskell's type system is pretty complex, seeing as how there are infinitely many types and all.
11:16:36 <Cale> In a very vague way
11:16:50 <copumpkin> Warrigal: are the natural numbers complex too, seeing as there are infinite naturals?
11:17:10 <Cale> But unless you've programmed in ML, you're unlikely to find Haskell's type system familiar.
11:17:16 <sproingie> mathematicians certainly know how to make the natural numbers complex
11:17:16 <Warrigal> No, but infinity is not a bad indicator of complexity.
11:17:19 <Cale> copumpkin: Very much so.
11:17:21 <Rotaerk> MrBlueSky, if you make a mistake that results in the wrong type being inferred, that will cascade until something no longer makes sense to the compiler
11:17:48 <Warrigal> The English language would definitely be simpler if it had only finitely many sentences.
11:17:48 <Rotaerk> by putting type annotations in reasonable places, you quarantine these cascades
11:17:48 <sproingie> it does
11:17:48 <Cale> copumpkin: There are statements about the naturals which we can't decide if they are true or not!
11:17:56 <MrBlueSky> Alright thankya
11:17:57 <copumpkin> :)
11:18:00 <sproingie> unless you admit sentences of infinite length.  which would take you forever to say.
11:18:07 <copumpkin> Cale: then we should make up our minds, shouldn't we!
11:18:26 <Cale> Even if we make up our minds about one of them, there will be another.
11:18:40 <copumpkin> we need infinite monkeys making up their infinite minds then
11:18:45 <copumpkin> one for each natural
11:18:55 <sproingie> good thing i've got me library of babel card
11:18:56 <copumpkin> oh but damn, then there wouldn't be enough to make up their minds about the reals
11:19:12 <sproingie> "it was the best of times, it was the blurst of times"
11:19:18 <Cale> If the system became complete, it would be inconsistent.
11:19:26 <Warrigal> sproingie: so what do you say about the regular expression /I want a hamburger( and a hamburger)*/?
11:19:36 <sproingie> not english?
11:19:55 <Warrigal> Is "I want a hamburger and a hamburger and a hamburger and a hamburger and a hamburger and a hamburger" a valid sentence?
11:20:02 <copumpkin> Warrigal: that contains infinitely many finite sentences
11:20:05 <copumpkin> (the language)
11:20:08 <sproingie> Warrigal: how about buffallo buffallo buffallo buffallo buffallo buffallo
11:20:22 <sproingie> missed a buffallo i think
11:20:27 <copumpkin> yep
11:20:46 <copumpkin> two of them
11:20:54 <sproingie> no, it's valid with 7
11:20:58 <sproingie> it's just a tautology
11:21:28 <Warrigal> Buffalo buffalo buffalo buffalo Buffalo buffalo buffalo.
11:21:29 <Cale> Well... actually it might be possible to have a complete and consistent system for the natural numbers, but its axioms wouldn't be recursively enumerable.
11:21:41 <Warrigal> Hey, that is a tautology, assuming that Buffalo buffalo buffalo buffalo.
11:21:50 <sproingie> Malkovitch?
11:22:26 <Cale> That is, we couldn't even write a program to list the axioms.
11:23:50 <Cale> So maybe the infinite monkeys would manage :)
11:24:43 <copumpkin> ook
11:25:10 <Warrigal> Well, yeah, just have its set of axioms be the union of the Peano axioms with the set of all axioms that are independent of previous axioms.
11:25:23 <Warrigal> Where "previous" is with respect to an arbitrary well-ordering of all statements.
11:25:39 <Cale> Right, I was about to say, "that's not unique"
11:28:19 <Warrigal> Here, I'll enumerate all the statements of Peano arithmetic!
11:29:10 <Warrigal> Nah. :-P
11:30:28 <sproingie> actually come to think, any length string of "buffalo" is valid
11:30:35 <Cale> sproingie: yeah
11:30:39 <sproingie> tho length 1 is imperative
11:30:51 <sproingie> after that it could be imperative or a statement of fact
11:31:33 <Cale> I wish that GHC had a mode where it could animate the optimisation it's doing to code, like in Roman's talk. :)
11:32:06 <sproingie> that'd be pretty
11:32:41 <MyCatVerbs> If one hacked it to output the GHC Core at every optimization step, I bet you could make a fairly neat animation just by playing through the steps. :D
11:32:54 <sproingie> and educational.  heck i wouldn't mind an animated visualizer for plain old lambda calculus
11:33:10 <sproingie> untyped and simply typed
11:33:17 <ClaudiusMaximus> sproingie: http://www.archive.org/details/ClaudiusMaximus_-_ULCIv1
11:33:19 <Cale> Yeah, what I'd really like to have is a runtime visualisation of the expression graphs.
11:33:58 <ClaudiusMaximus> i have an interactive version, but it's not finished yet, and point and click programming is really slow...
11:34:47 <sproingie> ClaudiusMaximus: pretty nifty still
11:35:30 <ClaudiusMaximus> sproingie: thanks! :)
11:36:12 <sproingie> someone ought to make a lambda calculus version of rocky's boots
11:36:14 <Veinor> I program in austere haskell. I name all my variables a, a', a'', a''', etc
11:36:18 <en0th> there's lambda animator (written in java)
11:37:09 <monochrom> @remember Veinor I program in austere haskell. I name all my variables a, a', a'', a''', etc
11:37:09 <lambdabot> I will never forget.
11:37:36 <Veinor> meaningful variable names are for babies
11:38:14 <sproingie> you name variables?
11:38:19 <copumpkin> MyCatVerbs: I've thought of that, but the default output doesn't give you enough information to show you what's being transformed into what, as far as I can see
11:38:35 <monochrom> I disgaree. Meaningful variable names are for people who attach pretended meaning where there is none.
11:39:27 <monochrom> For example the names "true", "false" in boolean algebra.
11:40:57 <ketil> heh.  I'd argue that if you need long names to keep track of what they refer to, you have too many and should refactor.
11:41:39 <monochrom> Actually it would be nice if operators like & aren't confined to be 2-ary. If an operator can be 0-ary, we can use it as a variable name.
11:41:57 <ketil> I generally stick to convention, though.
11:41:58 <sproingie> isn't a 0-ary operator a value?
11:42:07 <monochrom> Yes.
11:42:27 <MyCatVerbs> copumpkin: It would at least look pretty. :)
11:42:36 <MyCatVerbs> copumpkin: I dunno though, aren't the names involved mostly stable?
11:42:49 <monochrom> do { (&) <- getLine; putStrLn ( (&) ++ " is great!" ) }
11:43:56 <Warrigal> All of my programs consist of "module Main where main = ...", and ... is an expression that doesn't use parentheses for grouping.
11:45:09 <Warrigal> module Main where main = getLine >>= putStrLn . flip (++) " is great!"
11:45:11 <copumpkin> MyCatVerbs: can't remember, but I remember trying to do it and thinking it was harder to figure out what happened between iterations than I expected
11:45:35 <MyCatVerbs> Ah, fair enough.
11:45:44 <Warrigal> I actually wonder if Haskell-without-parentheses-for-grouping is Turing-complete or not. Its grammar is regular.
11:46:08 <MyCatVerbs> Warrigal: easily,
11:46:19 <MyCatVerbs> $ operator and fix. :)
11:46:34 <copumpkin> :t fix ($)
11:46:35 <lambdabot> forall a b. a -> b
11:46:37 <Philippa> there's a turing complete "flat" combinator base, so yes
11:46:37 <copumpkin> :P
11:46:47 <monochrom> (5+6)*7 = let y=5+6 in y*7
11:46:49 <copumpkin> that's a pretty awesome type
11:47:04 <Philippa> d'oh, yes, of course ANF works too
11:47:05 <copumpkin> :t let unsafeCoerce = fix id in unsafeCoerce
11:47:06 <copumpkin> w00t
11:47:06 <lambdabot> forall a. a
11:47:12 <copumpkin> :t let unsafeCoerce = fix ($) in unsafeCoerce
11:47:13 <lambdabot> forall a b. a -> b
11:47:30 <copumpkin> ;)
11:47:36 <Warrigal> Hey, I don't use lets either. Using them would defeat the entire point.
11:48:08 <monochrom> Do you accept "where"? <duck>
11:48:15 <Warrigal> Which is to not name anything.
11:48:25 <Warrigal> Philippa: what is that base?
11:48:30 <Philippa> if you're allowed a handful - or kludging via some specialised fixities - then you can define a flat combinator base (it's only four combinators)
11:48:46 <Philippa> Warrigal: dunno, I forget whose paper had it. Give me a moment to look it up?
11:49:24 <Warrigal> Sure.
11:49:28 <MyCatVerbs> > let { times x y = x * y; dec n = n - 1; fac = fix $ \r n -> if n == 1 then 1 else times n . r . dec $ n } in fac 5
11:49:29 <lambdabot>   120
11:49:34 <MyCatVerbs> Look Ma, no parens! :D
11:50:42 <MyCatVerbs> Actually, this would make a pretty neat esolang.
11:50:43 <Warrigal> > product . enumFromTo 1 $ 5
11:50:44 <lambdabot>   120
11:50:52 <Warrigal> Mine's a little bit shorter.
11:50:57 <MyCatVerbs> Haskell + the characters ( and ) are syntax errors in the lexer. :D
11:51:31 <MyCatVerbs> Warrigal: I know. Point was, you still have recursion and 'if' :)
11:51:44 <benmachine> patterns'd ruin it for you
11:51:50 <benmachine> no other way to say (x:xs)
11:52:02 <MyCatVerbs> benmachine: head, tail.
11:52:14 <Warrigal> > let head $ x:xs = x in head "foo" -- this won't work
11:52:14 <Berengal> benmachine, case xxs of x:xs -> foo
11:52:15 <lambdabot>   Precedence parsing error
11:52:15 <lambdabot>      cannot mix `$' [infixl 9] and `:' [infixr 5] ...
11:52:35 <Warrigal> lambdabot: that would be valid in every other case.
11:52:37 <Philippa> bah, can't find it. Can't remember who derived it now :-(
11:52:38 <MyCatVerbs> Warrigal: head's already in the Prelude, you don't have to define it yourself.
11:52:44 <Berengal> > let head list = case list of x:_ -> x in head [1,2,3]
11:52:46 <lambdabot>   1
11:52:52 <Philippa> it had combinators that 'did the job' of ( and ) though
11:53:13 <benmachine> Berengal: cunning
11:54:09 <dolio> @pl \f x y z w -> f (x y) (z w)
11:54:10 <lambdabot> (((.) .) .) . (.)
11:54:40 <copumpkin> we need a Bimonad for that!
11:54:44 <copumpkin> :P
11:55:08 <dolio> @pl \f x y z -> f (x y z)
11:55:08 <lambdabot> (.) . (.)
11:55:21 <Warrigal> So, I guess the format I like is "module Main where main = ..." where ... is an expression consisting entirely of variables and operators, with parentheses used only to turn operators prefix.
11:55:37 <Warrigal> @unpl ((.) . (.)) . ((.) . (.))
11:55:37 <lambdabot> (\ o b c f i l -> o (b c f i l))
11:55:53 <Warrigal> lambdabot, that is pure obcfil.
11:56:09 <benmachine> @unpl id
11:56:10 <lambdabot> (\ a -> a)
11:56:22 <benmachine> @unpl ($)
11:56:23 <lambdabot> (\ a b -> a b)
11:57:12 <benmachine> @unpl uncurry
11:57:13 <lambdabot> uncurry
11:57:19 <benmachine> fair enough.
11:57:32 <en0th> While i was toying with Data.Array I've written these two functions: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4471 However, i cannot find a name for them. Any suggestions?
11:57:57 <mauke> have some random words: freetling lolia Aleurystic doverbidead shrushship
11:58:14 <en0th> they simply wrap ( // )
11:58:39 <en0th> aleurystic sounds good
11:59:02 <Warrigal> I love words that have "sh" twice in a row.
12:01:11 <mauke> if you need more words, just ask me!
12:07:17 <hackagebot> haskell-src-exts 1.2.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
12:22:22 <hackagebot> KiCS 0.9.2 - A compiler from Curry to Haskell (BerndBrassel)
12:23:23 <hackagebot> KiCS-prophecy 0.1.1 - a transformation used by the kics debugger (BerndBrassel)
12:24:22 <hackagebot> KiCS-debugger 0.1.1 - debug features for kics (BerndBrassel)
12:30:04 <en0th> :t curry
12:30:06 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:31:23 <stoop> :t humus
12:31:24 <lambdabot> Not in scope: `humus'
12:31:55 <vhost-> humus is so good
12:33:06 <mauke> http://en.wikipedia.org/wiki/Humus
12:33:09 <mauke> SO GOOD
12:33:22 <opqdonut> :)
12:33:30 <opqdonut> i guess they meant hummus
12:36:51 <stoop> mauke, haha
12:36:57 <stoop> Yes, I meant hummus.
12:43:20 <fxr> wow ghc-stage2: internal error: evacuate: strange closure type 7
12:44:02 <fxr> this throws me to the top of the mountain everest
12:45:27 <skorpan> ((->)r) is the reader monad... bricks were shat.
12:56:18 <plutonas> having a list with n elements how can one in a functional way split it into sublists of 10 elements each?
12:56:28 <plutonas> like the first 10 the next 10 and so on
12:57:06 <opqdonut> > map (take 5) $ iterate tail [1..10]
12:57:07 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
12:57:10 <opqdonut> :)
12:57:22 <plutonas> thanks opqdonut
12:57:23 <Taejo> skorpan: I made you a present: http://people.cs.uct.ac.za/~rbkmax001/reader-monad.png
12:57:27 <opqdonut> or even
12:57:32 <opqdonut> > map (take 5) $ tails [1..10]
12:57:33 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
12:57:41 <skorpan> Taejo: lol
12:57:59 <stoop> > map (take 5) . tails $ [1 .. 10]
12:58:00 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
12:58:54 <Exteris> doesnt that leave you with a lot of ugly half-filled lists at the end?
12:59:12 <opqdonut> it does
12:59:23 <opqdonut> needs a "take (n-k)"
13:00:10 <opqdonut> > let seqs k xs = take (length xs - k) . map (take k) . tails $ xs in seqs 3 [1..5]
13:00:11 <lambdabot>   [[1,2,3],[2,3,4]]
13:00:36 <opqdonut> > let seqs k xs = take (length xs - k + 1) . map (take k) . tails $ xs in seqs 3 [1..5]
13:00:37 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
13:00:41 <opqdonut> ... off by one :)
13:00:44 <Exteris> lol i was just about to say that
13:00:45 <Twey> plutonas: You may want Data.List.Split.chunk
13:01:12 <plutonas> hm
13:01:13 <Twey> I imagined you wanted something like [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
13:01:19 <Twey> That's what chunk does
13:01:19 <plutonas> Twey: yes thats it
13:01:53 <Twey> There are simpler implementations than Data.List.Split's, but it's worth using it anyway just to standardise on something.
13:04:48 <newsham> is there a definition of [minBound..maxBound] ?
13:04:52 <poe> > let f n = unfoldr (\xs -> if not (null xs) then Just (splitAt n xs) else Nothing) in f 4 [1..20]
13:04:53 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
13:06:26 <newsham> unfoldUntil null (splitAt 4)
13:08:22 <roconnor> > splitEvery 4 [1..20]
13:08:24 <lambdabot>   Not in scope: `splitEvery'
13:08:33 <roconnor> > Data.Split.splitEvery 4 [1..20]
13:08:34 <lambdabot>   Not in scope: `Data.Split.splitEvery'
13:08:43 <roconnor> > Data.List.Split.splitEvery 4 [1..20]
13:08:44 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
13:08:46 <roconnor> :(
13:09:11 <Gracenotes> woot... 5 KB/s... really loving the download speed here
13:09:22 <Gracenotes> (well, from this website)
13:10:25 <burp> @let boundL :: (Enum a, Bounded a ) => [a];  boundL =  [minBound..maxBound]
13:10:26 <lambdabot>  Defined.
13:11:05 <burp> there it is ;-)
13:20:44 <hackagebot> digits 0.1 - Converts integers to lists of digits and back. (HenryBucklow)
13:21:10 <opqdonut> hehe, finally a library
13:29:57 <newsham> > length $ map (+1) boundL
13:29:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
13:29:58 <lambdabot>    `GHC.Enum.Bounded a'
13:29:58 <lambdabot>    ...
13:31:55 <burp> > length (boundL :: [Int8])
13:31:57 <lambdabot>   256
13:33:10 <newsham> > length $ filter isUpper boundL
13:33:11 <lambdabot>   1452
13:33:39 <trzkril>  @type isUpper
13:33:43 <trzkril> @type isUpper
13:33:44 <lambdabot> Char -> Bool
13:35:50 <newsham> ?let pairBoundL :: (Enum a, Bounded a, Enum b, Bounded b) => [(a,b)]; pairBoundedL = [(x,y) | x<-boundL, y<-boundL]
13:35:51 <lambdabot>  <local>:6:0:
13:35:51 <lambdabot>      The type signature for `pairBoundL' lacks an accompanying ...
13:35:51 <fxr> hmm cabal gives "cabal: : openFile: does not exist (No such file or directory)" suddenly.
13:36:01 <fxr> have you ever seen this type of problem?
13:36:07 <newsham> ?let pairBoundL :: (Enum a, Bounded a, Enum b, Bounded b) => [(a,b)]; pairBoundL = [(x,y) | x<-boundL, y<-boundL]
13:36:08 <lambdabot>  Defined.
13:37:01 <newsham> > length (pairBoundL :: [(Word8,Word16)])
13:37:05 <lambdabot>   mueval-core: Time limit exceeded
13:38:00 <burp> > length (pairBoundL :: [(Int8,Int8)])
13:38:01 <lambdabot>   65536
13:49:17 <cods> Hi. I know almost nothing about Haskell. I'm trying to dump the content of a file. How ugly is my attempt: http://tuxee.net/Prog1.txt ? I'm sure this can be reduced to one (or few) lines. How would you write the same thing?
13:49:56 <copumpkin> :t putStrLn <=< readFile
13:49:57 <lambdabot> FilePath -> IO ()
13:50:21 <jmcarthur_work> tada!
13:50:49 <copumpkin> damn, jmcarthur_work stole my punchline!
13:51:07 * copumpkin considers never forgiving
13:51:21 <jmcarthur_work> copumpkin, wtf that's always been my punchline
13:51:25 <copumpkin> :(
13:51:37 <copumpkin> you can't have a punchline if you haven't said anything before it!
13:51:40 <jmcarthur_work> i have a patent and everything
13:51:46 <copumpkin> nuh uh
13:51:51 <jmcarthur_work> uh huh
13:51:53 <cods> that's look chinese to me, but ok. If using only hGetChar, how could I do it? (The loop until I reach eof)
13:52:37 <jmcarthur_work> beginning to sound like homework ;)
13:53:00 <cods> oh no, far from it :) I'm 35, school was a looong time ago :)
13:53:06 <jmcarthur_work> not that we don't help people with homework
13:53:08 <copumpkin> :t forever (putChar =<< hGetChar stdin)
13:53:09 <lambdabot> Not in scope: `hGetChar'
13:53:10 <lambdabot> Not in scope: `stdin'
13:53:23 <copumpkin> :t forever (putChar =<< System.IO.hGetChar Sytem.IO.stdin)
13:53:25 <lambdabot> Couldn't find qualified module.
13:53:26 <copumpkin> meh
13:53:32 <monochrom> Chinese and Haskell are both languages for the next few decades. Make sure you're ready.
13:53:34 <jmcarthur_work> those aren't there even for just type checking?
13:53:36 <jmcarthur_work> crazy
13:53:37 <Cale> hmmm...
13:53:47 <monochrom> I am ready. Are you?
13:53:54 <copumpkin> damn right!
13:53:59 <copumpkin> ni hao ma
13:54:04 * jmcarthur_work is not prepared for chinese domination
13:54:11 <copumpkin> ooh, a chinese dominatrix
13:54:25 <jmcarthur_work> not prepared for that either
13:54:30 <copumpkin> aw
13:54:30 * Cale knows a fair number of Chinese characters, but not how to pronounce them in Chinese.
13:54:36 <copumpkin> same :)
13:54:51 <sproingie> @pl \x -> (x,x)
13:54:51 <lambdabot> join (,)
13:54:56 <sproingie> ok that i don't get
13:54:58 <gwern> for optimal efficiency, I've assigned all of copumpkin's jokes a number
13:55:07 * gwern clears throat
13:55:07 <copumpkin> sproingie: it's using the ((->) a) monad
13:55:09 <gwern> 76
13:55:10 <copumpkin> instance
13:55:18 <copumpkin> gwern: nice!
13:55:23 <copumpkin> gwern: do you have a list somewhere?
13:55:26 <monochrom> hahahaha that's a funny joke!
13:55:37 <sproingie> copumpkin: oh.  tricky.
13:55:41 <Cale> sproingie: Functions from a fixed type form a monad where "running" a computation means applying it to the value to which the whole function has been applied.
13:55:43 <gwern> monochrom: then you'll like - 120!
13:55:58 <copumpkin> hhahahahahahhaa
13:56:00 <copumpkin> that one's awesome
13:56:03 <monochrom> That one is more subtle, but all the better!
13:56:07 <copumpkin> (I laugh at my own jokes, yeah
13:56:20 <copumpkin> (and don't close parentheses
13:56:36 * gwern finishes with a rare flourish: 9
13:56:39 <cods> Thanks for your help all. I'm using Programming in Haskell, but the book doesn't talk that much about files handling.
13:56:46 <monochrom> The emperor's new jokes.
13:57:10 <gwern> and now, good night. you've been a great audience, but I shan't outwear my welcome. as you leave, I ask you to remember 11
13:57:15 <Berengal> is there a nice function taking a string and an infix substring and returning the string starting at the substring?
13:57:46 <copumpkin> nope
13:57:52 <sproingie> not hard to define it
13:58:01 <Cale> Easy to do with tails/find
13:58:03 <Berengal> No, not hard, I was just hoping there was one handy already
13:58:17 <gwern> I wonder if the split lib has that
13:58:24 <copumpkin> or Data.Text
13:58:27 <Cale> > find (isPrefixOf "cad") (tails "abracadabra")
13:58:28 <lambdabot>   Just "cadabra"
13:58:31 <Berengal> dropWhile (not . isPrefix $ sub) . tails
13:58:52 <monochrom> I thought there was an infix search function.
13:59:00 <monochrom> infix search and split, even
13:59:01 <Cale> There's an isInfixOf
13:59:23 <Berengal> Data.Text has some substring searching going on...
13:59:46 <monochrom> I misremembered. There is stripPrefix, the end.
14:00:00 <copumpkin> don't misunderestimate monochrom's misrememberance
14:00:07 <Berengal> stripPrefix is pretty awesome in combination with view patterns
14:00:43 * doublethink_work really likes criterion after playing with it some
14:01:54 <copumpkin> zomg doublethink_work is alive
14:02:13 * copumpkin conspires to get doublethink_work fired from his job
14:02:48 <doublethink_work> :(
14:02:52 <doublethink_work> i like my job! :(
14:02:56 <copumpkin> not allowed
14:02:58 <copumpkin> all jobs must be hated
14:03:09 <doublethink_work> h8 4evr?
14:03:12 <copumpkin> ya
14:04:11 <Berengal> I like food more than I could ever hate a job
14:04:30 <doublethink_work> copumpkin: fwiw, in the next week or two I should (hopefully) have some free time
14:04:36 <copumpkin> zomg yay
14:04:40 <doublethink_work> so if you would like to stab at ghc some more, we could try
14:04:50 <sproingie> stabby stabby
14:04:52 <doublethink_work> it's just I have a paper due monday and I'm behind in my classes a little
14:05:07 <doublethink_work> and it's just that time of the semester when like 9,000 major things are due :/
14:05:12 <gwern> Berengal: hm. I have some torturers here who wouldn't mind making your job testing that; or we could test it by making you hack on ghc
14:05:24 <copumpkin> doublethink_work: I would very much like to stab it :)
14:05:41 <Berengal> gwern, good thing I have alternative sources of food, such as my bank account
14:06:01 <gwern> Berengal: ve have ways of dealink wif dat!
14:06:56 <copumpkin> gwern: by the way, are you actually from wales?
14:07:30 <gwern> copumpkin: I have a dog named Prince Charles of Wales
14:07:39 <gwern> and a ferret named Fera Fawcett
14:07:48 <copumpkin> :)
14:08:22 <mm_freak> it's funny that the factorial function isn't predefined in most functional languages
14:08:44 <doublethink_work> ferrets == win
14:08:48 <gwern> *Prints Charles
14:08:55 <doublethink_work> fearless little animals they are
14:08:55 <sproingie> of course not, then there wouldn't be the joy of defining it yourself
14:09:02 <gwern> (And I forget whether it was 'Wales' or 'Wails')
14:09:03 <mm_freak> indeed
14:09:09 <sproingie> fib is always more interesting tho
14:09:30 <copumpkin> lol
14:09:31 <sproingie> and fib is actually useful for a lot of things
14:09:39 <lament> yes, i used fib all the time
14:09:47 <gwern> you do?
14:10:17 <lament> no, i really don't
14:11:34 <sproingie> last time i used a fib sequence was for a backoff routine in some concurrent hack job.  didn't really calculate it tho, just hardwired the first 10 or so in
14:12:28 <gwern> -_-
14:12:45 <gwern> wouldn't hardwiring the first 10 be even longer than just defininig it?
14:12:46 <copumpkin> were they concurrently breeding wabbitz?
14:12:54 <sproingie> bourne shell tends to not have a lot of functional idioms :)
14:14:05 <cods> By curiosity, how can I get ride of the 'handle' definition in my toy program (inlining openFile along with the forever loop) here: http://tuxee.net/Prog1.txt ? Is that possible? (There is no point doing that, just curious.)
14:14:17 <sproingie> i probably could have used linear or just about anything, i was mostly being cheeky
14:18:01 <Twey> cods: flip catch (const $ return ()) . forever . (putChar =<<) . hGetChar =<< handle
14:18:30 <cods> Twey: woah :)
14:18:34 <copumpkin> lol
14:18:35 <cods> thanks!
14:18:36 <skorpan> frickin' =<<
14:18:39 <copumpkin> don't do that :P
14:18:53 <Twey> That's pretty readable, actually
14:18:56 <Twey> Thanks to =<<
14:18:59 <dolio> @pl (f =<<) . g
14:18:59 <sproingie> surprisingly
14:18:59 <lambdabot> (f =<<) . g
14:19:06 <skorpan> i will never agree with you guys on =<<
14:19:07 <Twey> Yeah, surprisingly
14:19:08 <skorpan> it's just weird
14:19:12 <Twey> Heh
14:19:13 <cods> Even if complicated to offuscate it, that will make a great example to analyze :)
14:19:18 <dolio> @type \f g -> (f =<<) . g
14:19:19 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Monad m, Functor f) => (a -> m b) -> f (m a) -> f (m b)
14:19:26 <Twey> Er, s/handle/openFile "Prog1.hs" ReadMode
14:19:31 <sproingie> =<< is good if the whole thing otherwise goes right-to-left
14:19:37 <Twey> Yeah
14:19:47 <skorpan> yes, people keep claiming that :)
14:19:49 <Twey> It's nice here because you can see it as providing the handle directly to hGetChar, like an argument
14:19:54 <dolio> @type \f g -> f <=< g
14:19:55 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:20:00 <Twey> Anyway, bed  'night
14:20:39 <dolio> > succ . [1..10]
14:20:41 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:20:51 <cods> Actually, I like the expression. That's really what I need to better understand this language.
14:21:02 <copumpkin> I'm still not convinced by (.) = fmap
14:21:20 <trzkril> @type (.)
14:21:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:21:38 <Badger> @type fmap
14:21:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:21:44 <Badger> oh
14:21:59 <Badger> @src (.)
14:21:59 <lambdabot> (f . g) x = f (g x)
14:21:59 <Berengal> I'm writing ugly code now :/
14:22:24 <camio> I thought (.) was morphism for categories :/
14:22:41 <trzkril> @src fmap
14:22:42 <lambdabot> Source not found. You untyped fool!
14:22:51 <trzkril> @src Functor
14:22:52 <lambdabot> class  Functor f  where
14:22:52 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:22:57 <Berengal> camio, it's morphism composition in Control.Category
14:23:07 <jmcarthur_work> wait, we have caleskell again?
14:23:09 <camio> Berengal, ah, that's right.
14:23:20 <Berengal> I use it heavily in my arrow code
14:23:43 <camio> Berengal, I'm curious. What do you use arrows for?
14:23:49 <Berengal> jmcarthur_work, in caleskell, wasn't (.) fmap?
14:23:53 <jmcarthur_work> yes
14:23:57 <copumpkin> to take from the rich and give to the poor
14:24:02 <Berengal> camio, xml/html parsing. Currently trying my hand at some datamining :)
14:24:12 <jmcarthur_work> :t (.)
14:24:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:24:17 <jmcarthur_work> Berengal, ^^
14:24:29 <Berengal> jmcarthur_work, oooo, nifty. It's back
14:24:43 <jmcarthur_work> > (+1) . Just 5
14:24:44 <lambdabot>   Just 6
14:24:55 <jmcarthur_work> it's so wrong
14:24:57 <Berengal> :t (++)
14:24:58 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:25:00 <Berengal> Yay!
14:25:08 <jmcarthur_work> wow it really is back
14:26:01 <copumpkin> > Sum 5 ++ Sum 6
14:26:02 <lambdabot>   Sum {getSum = 11}
14:26:18 <Badger> hah
14:26:19 <Botje> yay for caleskell
14:26:27 <copumpkin> > (++) `on` Sum $ 5
14:26:29 <lambdabot>   Precedence parsing error
14:26:29 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
14:26:37 <copumpkin> > ((++) `on` Sum) 5 7
14:26:39 <lambdabot>   Sum {getSum = 12}
14:26:47 <copumpkin> > ((++) `on` Product) 5 7
14:26:48 <lambdabot>   Product {getProduct = 35}
14:28:19 <Berengal> I wish people didn't use record syntax for these simple newtypes...
14:28:28 <jmcarthur_work> why?
14:28:36 <Berengal> Looks ugly when shown
14:28:37 <jmcarthur_work> because of the Show instance?
14:28:41 <jmcarthur_work> meh
14:29:02 <Berengal> Records are nice when you've got a bajillion fields, but when there's a single one, you're not gaining much
14:29:04 <jmcarthur_work> really i just wish Show instances didn't show record syntax
14:29:20 <Berengal> It can be handy on larger datatypes
14:29:53 <Berengal> For example, I'm working with one with ten fields now. It'd be hell to read without record syntax
14:31:18 <xcoder42> so haskell masters: i've got a tree which i want to create flattened versions of, basically i take a node. remove and place its children in its parent. node is defined as = n([]) ... leaf = l(X) ... my problem is that every time i remove a node.. the [ ] clauses manage to stay behind, if your up for the challenge have a look here: http://pastebin.com/d54a16359 , and tell me what i'm doing wrong.
14:32:30 <Berengal> xcoder42, looks like prolog to me
14:32:35 <monochrom> Looks like Prolog.
14:32:45 <xcoder42> ups.. right... wrong chat
14:32:52 <copumpkin> o.O
14:33:16 <xcoder42> sorry, i'm building a prolog parser in haskell, so i jump around a bit
14:33:26 <copumpkin> :)
14:33:30 <monochrom> haha
14:54:51 <Baughn> "The shoggoths just started a cult worhshipping a LIDAR beam" <-- Which book would this describe?
14:55:06 <gju> hi, i have simple question wich i somehow cannot answer myself... how can i tell interact to read lines?
14:55:28 <gju> i want to read a line, filter it and then print it to stdout.
14:55:42 <monochrom> interact (print . map length . lines)
14:55:44 <Baughn> gju: interact reads the full input. You can pass that to a function that parses it into lines to produce, well, lines.
14:55:55 <Baughn> monochrom: ..bad monochrom. Not educational.
14:56:11 <monochrom> I agree to disagree.
14:56:17 <Baughn> Also, s/print/show/
14:56:25 <monochrom> haha
14:58:20 <monochrom> > lines "hello\na/s/l?\n"
14:58:21 <lambdabot>   ["hello","a/s/l?"]
15:00:00 <gju> that's what i've got:
15:00:02 <gju> main = interact $ unlines . filter isValidToken . lines where isValidToken t = t `elem` validTokens
15:01:05 <gju> ah sek... i think i know whats wrong.
15:01:11 <jmcarthur_work> if that isn't working it could be buffering mode problems
15:01:44 <jmcarthur_work> i never can remember what the default is
15:02:21 <gju> it doesn't work because i try to filter a list of strings, but it expects a list of char.
15:03:09 <jmcarthur_work> ah, type error
15:04:15 <benmachine> how does isValidToken work? is newline a valid token?
15:04:50 <gju> no it's not.
15:04:51 <gju> validTokens = "<>+-.,[]"
15:05:02 <benmachine> oh yeah I missed that
15:05:04 <benmachine> somehow
15:05:36 <aavogt> you probably want  map (filter isValidToken)
15:05:43 <benmachine> you probably do.
15:05:58 <gju> yeah, i probably do. i will try that. :)
15:06:40 <aavogt> though in your case, I don't see the point in splitting your input into lines
15:07:16 <aavogt> main = interact (filter isValidToken) -- could work too
15:07:18 <gju> well, my main idea is to wirte a simple repl
15:07:28 <gju> for brainfuck code
15:07:53 <sereven> hmm, why would cabal install user want to install dependencies network and HTTP (user) in same version as is already installed globally?
15:08:22 <benmachine> aavogt: it'd have problems with line buffering though because the output would have no newlines
15:08:44 <gju> but my brain doesn't work the haskell-way, yet...
15:08:52 <lament> maybe I should combine the popular intro haskell projects and make a Brainfuck compiler that plays Go
15:11:13 <camio> lament, for the sake of humor?
15:11:57 <aavogt> benmachine: wouldn't it have the newlines from the original input?
15:12:19 <aavogt> (you may be right, but I don't understand that justification)
15:18:25 <benmachine> aavogt: they'd be filtered?
15:18:33 <benmachine> not valid tokens
15:20:23 <aavogt> oh, right
15:21:19 <Nafai> Heh.  I just did a search on indeed.com for Haskell jobs in Utah (where I live).  Didn't find any and it gave the helpful suggestion for "basket jobs in Utah"
15:22:03 * sproingie was thinking "hand jobs in utah"
15:24:17 <sproingie> i guess "ask" has more letters in common
15:24:27 <sproingie> "aske" in fact
15:25:11 <permagreen> Is making baskets easier, or harder than programming in Haskell, do you think?
15:25:35 <sproingie> about as easy as making baskets with your toes
15:27:20 <arsenm> hi, does anyone know why when I try to use this I get an overlapping instance? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11101#a11101
15:27:36 <allbery_b> utah's semi-arid, no? hard to make baskets from dry reeds :)
15:27:40 <hackagebot> crockford 0.1 - An implementation of Douglas Crockford's base32 encoding. (HenryBucklow)
15:28:12 <Berengal> arsenm, everything that matches any of the first instances also match the last instance
15:28:17 <permagreen> If I could make baskets with my toes I'd just set up shop at some local farmer's market. I bet people would pay good money for genuine toe-made baskets.
15:29:12 <arsenm> Berengal: it's complaining that (String, Float) matches for (String, Float) and for the GObjectClass one, which seems ridiculous since Float can't possibly be GObjectClass
15:29:46 <Berengal> arsenm, yes, but the typechecker doesn't know that when it tries to match instances. It only checks afterwards
15:29:49 <allbery_b> class constraints are only applied *after* matching
15:30:02 * allbery_b = slow
15:30:15 <arsenm> hmmm
15:30:32 <Berengal> arsenm, you can use -XOverlappingInstances to make it work
15:30:46 <Berengal> But read up on it before you blindly go using it
15:34:45 <gju> mh, now i tried it like that: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11102#a11102
15:34:59 <gju> but it's somehow still not working the way i want.
15:35:32 <gju> it doesnt wait for me to press enter. what am i doing wrong?
15:42:59 <Cale> gju: Perhaps ensure that line buffering is on.
15:43:42 <Cale> gju: Note that the characters which belong to the first line will be available to checkLines before the line is finished, because lines can immediately start producing the first element of its output.
15:44:07 <Cale> gju: and then unlines has no problem passing things through
15:44:29 <Cale> gju: interact is ironically really quite a tricky way to write interactive programs
15:45:03 <Cale> gju: It's better for raw stream processing tasks, like for unix-style utilities.
15:45:04 <gju> i read about in "learn you a haskell...".
15:45:17 <gju> +it
15:45:25 <Cale> You can probably change it to read
15:45:40 <Cale> main = do hSetBuffering stdin LineBuffering
15:45:56 <Cale>           interact $ ...
15:46:16 <Cale> and add   import System.IO   to the top of the file
15:47:31 <gju> mh, i solved it by using getLine and then passing the inpute to a filter call.
15:47:31 <Berengal> I think the right advice is still to not use interact if you want interactive programs
15:47:45 <Berengal> getLine is the way to go
15:47:48 <gju> doesn't look pretty but does the trick... somehow.
15:48:41 <gju> i read this sentence "This pattern of getting some string from the input, transforming it with a function and then outputting that is so common that there exists a function which makes that even easier, called interact."
15:48:59 <Berengal> (interact really is neat for stream processing though. wc, grep, to a degree sed as well)
15:49:09 <gju> so i thought it would be the right choice for that task.
15:49:34 <Berengal> gju, right, but it should've read "... and then outputting WITHOUT DOING ANYTHING ELSE ..."
15:50:33 <Berengal> Think of it as reading the entire stdin in one go
15:52:42 <gju> Berengal: but why does this one work then:
15:52:46 <gju> main = interact $ unlines . filter ((<10) . length) . lines
15:53:33 <Berengal> gju, why shouldn't it? It's reading in a string, transforming it, then outputting the result, and not doing anything else
15:54:08 <Berengal> The reading and outputting is done by interact, the transformation is your function
15:54:33 <gju> mh.
15:55:01 <gju> but i did a transformation, too. didn't i?
15:55:24 <Berengal> Yes, that's the part after the 'interact $' bit
15:55:38 <Berengal> i.e. 'unlines . filter ((<10) . length) . lines'
15:57:13 <Cale> gju: Computing the length of a line can't finish until the whole line is available
15:57:33 <Cale> gju: which is why you see no output in that one until you press enter
15:57:42 <gju> ah ok.
15:58:51 <gju> and the point you mentioned before is exactly the problem i had.
16:00:08 <gju> i e.g. entered . and it immediately printed that character.
16:00:42 <Cale> Right, because it knew as soon as you entered the character that it would be part of the output.
16:01:02 <Cale> @src unlines
16:01:02 <lambdabot> unlines = concatMap (++ "\n")
16:01:07 <Cale> @src lines
16:01:07 <lambdabot> Source not found. My pet ferret can type better than you!
16:01:09 <Cale> ah
16:01:29 <Cale> Well, in any case, lines doesn't need to get to the end of the first line to start producing output.
16:02:34 <gju> could i somehow create that behaviour?
16:04:30 <Berengal> use getLine instead of interact
16:04:34 <Cale> gju: You could do something artificial with the data dependencies, but my suggestion is easier
16:04:55 <Cale> Just use hSetBuffering to ensure that the input is line buffered.
16:05:11 <Cale> Or yeah, write the thing using getLine
16:06:04 <Berengal> Monads were invented so we wouldn't have to write everything using interact
16:06:22 <Cale> pff
16:06:33 <FunctorSalad> interact is way weaker than IO
16:06:34 <Cale> Maybe the IO monad, okay
16:06:40 <Cale> But not "monads"
16:06:52 <FunctorSalad> (you can't interleave input and output right?)
16:07:08 <Berengal> Okay, monads were invented so we could have natural transformations... but still
16:07:17 <Cale> Haskell used to use stream processing over a more general type of IO events.
16:07:29 <Berengal> Is that stream processing still around?
16:07:36 <Cale> no
16:08:07 <Berengal> I'm a bit happy and a bit sad at the same time. It's a horrible way to program, but it would look nice in a museum
16:08:13 <jmcarthur_work> monads were invented as an object of mathematical study
16:08:28 <Cale> Monadic IO was introduced in Haskell 1.3
16:08:45 <Berengal> The real question is if monads were invented or discovered ;)
16:08:46 <gju> ok, thanks for helping me!
16:08:47 <_Jordan_mob> Fun game all! Itls called "Teach me about function names". First round: Is ap (as in Control.Monad) just short for apply?
16:09:05 <Berengal> _Jordan_mob, yes
16:09:17 <jmcarthur_work> they were discovered, i suppose
16:09:33 <jmcarthur_work> the theory around monads was discovered from the invention of category theory?
16:09:39 <sproingie> when it comes to abstract math it's a fuzzy line
16:09:47 * benmachine discovered the invention of monads
16:09:59 * jmcarthur_work invented the discovery of monads
16:10:02 <sproingie> depends on whether you take a platonic view i guess
16:10:08 <Cale> Invention and discovery are the same thing.
16:10:09 <Berengal> jmcarthur_work, ah, but was category invented or discovered? Is any part of mathematics invented or discovered?
16:10:21 <jmcarthur_work> Berengal, category theory was defined axiomatically, i thought
16:10:42 <jmcarthur_work> i think Cale nailed it
16:10:43 <Cale> Monads were defined in order to study adjunctions.
16:10:45 <Berengal> jmcarthur_work, hypothetically, the axioms existed before they were defined on paper
16:10:57 <_Jordan_mob> Round 2: why is guard called that? What is it guarding against?
16:10:57 <Cale> Every adjunction gives rise to a monad.
16:11:00 <jmcarthur_work> Berengal, i don't believe that math "exists"
16:11:10 <sproingie> choose different axioms and you also get a complete system, it just looks completely different
16:11:26 <Cale> _Jordan_mob: against succeeding when the test you give it fails.
16:11:36 <Berengal> _Jordan_mob, it's guarding the rest of the computation, guarding against values that do not satisfy a predicate
16:12:03 <Cale> > do x <- [1..10]; y <- [1..10]; guard (x < y); return (x,y)
16:12:04 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(...
16:12:10 <Cale> > do x <- [1..5]; y <- [1..5]; guard (x < y); return (x,y)
16:12:12 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
16:12:38 <Cale> When the condition that x < y fails, that branch of the computation is cut off.
16:13:26 <_Jordan_mob> Hmm, crazy
16:13:42 <Cale> > do x <- [1..5]; y <- [1..5]; if x < y then [()] else []; return (x,y)
16:13:44 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
16:14:01 <Cale> > do x <- [1..5]; y <- [1..5]; z <- if x < y then [()] else []; return (x,y,z)
16:14:02 <lambdabot>   [(1,2,()),(1,3,()),(1,4,()),(1,5,()),(2,3,()),(2,4,()),(2,5,()),(3,4,()),(3...
16:14:44 <_Jordan_mob> Ahhh
16:14:46 <Cale> There's no choice for z when the condition fails, and exactly one choice when it succeeds
16:15:30 <Cale> It works similarly in the Maybe monad, only with no "backtracking".
16:15:34 <_Jordan_mob> Thanks, the () was confusing me
16:16:31 <Berengal> > ord ''
16:16:32 <lambdabot>   65533
16:16:44 <Berengal> :(
16:16:53 <Berengal> > ''
16:16:54 <lambdabot>   '\65533'
16:16:57 <Cale> What's sad about that?
16:17:18 <benmachine> > maxBound :: Char
16:17:19 <lambdabot>   '\1114111'
16:18:07 <Cale> oh, hmm
16:18:10 <_Jordan_mob> Round 3: isn't pure kinda a weird name for what it does? Lots of Haskell functions are pure
16:18:28 <sproingie> that's maxunicode
16:18:43 <sioraiocht> :t pure
16:18:43 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:18:50 <Cale> _Jordan_mob: it's the embedding of a pure value in whatever applicative functor
16:19:05 <sioraiocht> > pure 1 :: [Int]
16:19:06 <lambdabot>   [1]
16:19:07 <Cale> pure f <*> pure x = pure (f x)
16:19:10 <sioraiocht> ?
16:19:19 <sioraiocht> that's weird
16:19:21 <sioraiocht> > pure 1
16:19:22 <lambdabot>   No instance for (GHC.Show.Show (f t))
16:19:22 <lambdabot>    arising from a use of `M3187952186...
16:19:24 <FunctorSalad> > pure error "foo" "bar"
16:19:25 <lambdabot>   * Exception: bar
16:19:29 <Cale> heh
16:19:46 <sioraiocht> I thought pure returned an infinite list
16:19:50 <Cale> > pure (+10) <*> [1,2,3]
16:19:51 <lambdabot>   [11,12,13]
16:20:00 <Cale> not in the list monad
16:20:08 <Cale> pure is the same thing as return
16:20:10 <Berengal> > pure 1 :: ZipList Int
16:20:11 <lambdabot>   No instance for (GHC.Show.Show
16:20:11 <lambdabot>                     (Control.Applicative.Zip...
16:20:15 <Cale> Only differently polymorphic
16:20:21 <sioraiocht> copumpkin: ah
16:20:22 <Berengal> > fromZipList (pure 1 :: ZipList Int)
16:20:23 <lambdabot>   Not in scope: `fromZipList'
16:20:24 <jmcarthur_work> > getZipList (pure 1 :: ZipList Int)
16:20:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:20:29 <Berengal> There we go
16:20:35 <lament> a list of all primes?
16:20:57 <dpratt71> "pure" makes more sense to me than "return"; why "return"?
16:21:18 <Cale> dpratt71: Because it produces the computation which does nothing but return the given value.
16:21:32 <dpratt71> Cale: ah
16:21:32 <lament> "return"
16:21:33 <jmcarthur_work> because return came before pure
16:21:37 <Berengal> "unit" makes more sense to me
16:21:45 <Cale> It's just a name.
16:21:48 <jmcarthur_work> "point" is my favorite
16:21:51 <Cale> It's a sensible name.
16:21:59 <jmcarthur_work> unit isn't bad
16:22:02 <dpratt71> Berengal: is "unit" used anywhere in Haskell?
16:22:10 * benmachine votes for pure
16:22:12 <Cale> It's also used an awful lot like return is used in imperative languages.
16:22:16 <jmcarthur_work> dpratt71, unit is what () is called
16:22:18 <_Jordan_mob> So I thought "pure" meant "without side effects"
16:22:27 <Cale> Except that it doesn't do all the funky calling the continuation magic.
16:22:36 <dpratt71> Cale: that's partly why I don't like it
16:22:43 <sproingie> insofar as it means "provide the result"
16:22:55 <sproingie> but it gets super confusing when you see it in the list monad
16:22:57 <sioraiocht> dpratt71: it's ()
16:23:00 <Cale> But that's a silly thing for return to do in those imperative languages in the first place.
16:23:01 <sioraiocht> :t ()
16:23:02 <lambdabot> ()
16:23:27 <sioraiocht> :t return ()
16:23:27 <Cale> It makes code harder to analyse.
16:23:27 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
16:23:38 <idnar> "pucre" is shorter too
16:23:40 <idnar> *pure
16:23:44 <Berengal> Cale, on the other hand, the languages that didn't have return just around were painful to program in
16:23:49 <idnar> what does Category call it?
16:23:57 <dpratt71> Cale: I try hard to stick to one method exit point
16:23:59 <jmcarthur_work> id?
16:24:00 <Cale> Berengal: really?
16:24:08 <jmcarthur_work> arr?
16:24:14 <jmcarthur_work> not sure in what sense you intend
16:24:15 <Berengal> Cale, well, painfuller
16:24:18 <sproingie> pirate haskell
16:24:53 <Cale> I would prefer explicit call/cc along with a return that is like Haskell's.
16:25:16 <idnar> jmcarthur_work: I think I meant id, but I think I'm also just confused
16:25:18 <Berengal> call/cc =<< return foo ?
16:25:33 <Cale> That way you don't have yet-another-breaking-out-keyword for every control structure.
16:25:37 <sproingie> maybe "yield" but that has control flow connotations these days too
16:25:47 <Cale> and it's unambiguous how many levels to jump out.
16:26:18 <FunctorSalad> idnar: a category doesn't have 'return'
16:26:32 <idnar> FunctorSalad: yeah, like I say, I think I was confusing stuff
16:26:40 <Cale> Well, return is the identity arrow for the Kleisli category.
16:26:55 <FunctorSalad> yes
16:26:55 <_Jordan_mob> Maybe I'm confusing two uses of the term "pure"... So here it just means "not in a container"?
16:27:03 <jmcarthur_work> so id is probably the best approximation
16:27:18 <Cale> _Jordan_mob: From the container perspective, pure x gives you the container which only contains x
16:27:26 <jmcarthur_work> s/approximation/generalization/
16:27:34 <FunctorSalad> I meant 'return' as in embedding pure stuff, like arrr
16:28:00 <Cale> yaharrrr
16:28:10 <jmcarthur_work> Cale, "only contains" might be misleading, considering functors like ZipList
16:28:23 <Cale> jmcarthur_work: well, sure
16:28:23 <_Jordan_mob> Cale: So it's nothing to do with side effects
16:28:37 <sproingie> twenty doubloons to the first scaliwag to give me a good 'avast' function
16:28:38 <dpratt71> Cale: "return is the identity arrow for the Kleisli category"...I sometimes wonder if statements such as this will ever make intuitive sense to me :)
16:28:39 <Berengal> jmcarthur_work, show me a value that isn't 1 inside a pure 1 ZipList :P
16:28:40 <jmcarthur_work> actually, i get what sense you intended that to mean, now
16:28:42 <Cale> _Jordan_mob: Well, in some sense it gives you those computations which have no side effects.
16:29:08 <Cale> _Jordan_mob: pure x is the computation which produces x as its result without any other effects
16:29:15 <jmcarthur_work> Berengal, yeah, i get that now. i was interpreting it as "there is only one value and it is x," instead of "all values are x"
16:29:18 <Berengal> sproingie, I've been tempted to rename "none" to "avast"
16:29:29 <FunctorSalad> @wn avast
16:29:31 <lambdabot> No match for "avast".
16:29:41 <FunctorSalad> doesn't exist
16:29:42 <_Jordan_mob> Thanks, makes more sense
16:29:46 <jmcarthur_work> dpratt71, Kleisli isn't that weird
16:29:51 <jmcarthur_work> dpratt71, a -> m b
16:30:06 <jmcarthur_work> dpratt71, identity in the kleisli category, then, look like: a -> m a
16:30:11 <FunctorSalad> @all-dicts avast
16:30:12 <lambdabot> *** "Avast" gcide "The Collaborative International Dictionary of English v.0.48"
16:30:12 <lambdabot> Avast \A*vast"\ ([.a]*v[.a]st"), interj. [Corrupted from D. houd
16:30:12 <lambdabot>    vast hold fast. See {Hold}, v. t., and {Fast}, a.] (Naut.)
16:30:12 <lambdabot>    Cease; stop; stay. "Avast heaving." --Totten.
16:30:12 <lambdabot>    [1913 Webster]
16:30:12 <Cale> dpratt71: Do you know what a category is?
16:30:15 <jmcarthur_work> dpratt71, which is a familiar type signature... :)
16:30:24 <dpratt71> jmcarthur_work: it's not the idea, so much as the terminology
16:30:30 <FunctorSalad> ah that's easy
16:30:34 <FunctorSalad> @let avast = fix
16:30:35 <lambdabot>  Defined.
16:30:39 <dpratt71> Cale: to a point
16:31:02 <dpratt71> Cale: as in Category theory?
16:31:03 <FunctorSalad> if kleisli is too easy try category-extras's BiKleisli
16:31:07 <Cale> dpratt71: yes
16:31:20 <Cale> dpratt71: That's where all these ideas come from after all.
16:31:21 <Cale> :)
16:31:30 <dpratt71> Cale: right :)
16:32:10 <Berengal> FunctorSalad, I'm quite happy in my IOStateListTreeIfApplyArrow
16:32:15 <Cale> dpratt71: Okay, so to refresh that, a category C consists of: 1) A collection of objects Ob(C), 2) For each two objects A and B, a collection of arrows C(A,B) (or Hom(A,B))
16:32:22 <FunctorSalad> Berengal: ^^
16:32:23 <ezyang> haha
16:32:29 <dpratt71> a functor with two natural transformations or some such gobbledy-gook
16:32:39 <_Jordan_mob> Thanks all, back to the job where there's nary an applicative functor to be found
16:32:49 <Cale> 3) For each three objects X, Y, Z, an operation called composition . : C(Y,Z) x C(X,Y) -> C(X,Z)
16:33:11 <sproingie> not a lot of info in Heinrich Kleisli out there
16:33:16 <sproingie> er on him
16:33:21 <Cale> That is, if f: Y -> Z, and g: X -> Y, are arrows, then f . g: X -> Z is as well
16:33:28 <sproingie> (there's a category theory joke in there somewhere)
16:34:24 <Cale> 4) Each object X has an identity arrow id_X: X -> X, such that for any suitable f and g, we have f . id_X = f and id_X . g = g
16:34:39 <Cale> 5) For any suitable f, g, h, we have (f . g) . h = f . (g . h)
16:34:41 <dpratt71> cale: I need to step away for 20-30 minutes; sorry
16:34:45 <Cale> okay
16:35:08 <Cale> Well, that's a good point, since I'm finished defining a category :)
16:35:11 <Berengal> Seriously, 15 instances: http://hackage.haskell.org/packages/archive/hxt/8.3.1/doc/html/Control-Arrow-IOStateListArrow.html#t%3AIOSLA
16:35:34 <Berengal> 13 have "Arrow" in their name. One of the others is Category
16:38:15 <FunctorSalad> why not (ArrowState, ArrowIO, ArrowPlus)?
16:41:16 <Berengal> I'm more fond of the ArrowList and ArrowTree instances
16:41:42 <Berengal> When working with trees, it helps to have the recursion factored out
16:43:13 <Berengal> (Really a forest of trees. I'm quite in love I think)
16:45:52 <gOcOOl> is it possible to do a "import qualified Foo as F" in ghci?
16:46:12 <gOcOOl> ":m + Foo as F" isn;t working
16:46:33 <mauke> no
16:46:44 <gOcOOl> ah ok
16:47:07 <Gracenotes> ghci's import is as basic as can be..
16:47:27 <dpratt71> kidz r in bed now :)
16:47:42 <Berengal> Isn't import just mapped to :m+ ?
16:48:32 <Gracenotes> noddeh
16:48:39 <Gracenotes> iirc
16:48:45 <dpratt71> Cale: I believe you were trying to tackle explaining "Kleisli" to me; are you still up to it?
16:50:49 <brad_larsen> In Haskell, we have map, zipWith, zipWith3, etc.
16:50:59 <brad_larsen> >:t map
16:51:03 <Berengal> @type map
16:51:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:51:06 <brad_larsen> right
16:51:18 <brad_larsen> @type zipWith
16:51:19 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:51:26 <Cale> dpratt71: sure
16:51:37 <brad_larsen> in python, their 'map' function sort of subsumes all three of those functions
16:51:48 <brad_larsen> map can take an n-ary function, and n sequences
16:51:52 <dpratt71> cale: so we have Monad; why do we need "Kleisli"?
16:52:11 <Cale> dpratt71: The Kleisli category is just a way of looking at any given monad.
16:52:14 <Gracenotes> python doesn't quite have a strong type system to worry about
16:52:23 <brad_larsen> so haskell's map, zipWith, zipWith3, etc can be seen as instances of some more general thing
16:52:33 <dpratt71> cale: I was afraid of that :)
16:52:33 <brad_larsen> my question:  is there a name for this more general thing?
16:52:50 <brad_larsen> just a terminology question
16:53:35 <Berengal> brad_larsen, I'm not sure there is a more general thing we can define without introducing any inconsistencies
16:53:56 <Cale> dpratt71: So, if we have some monad M on a category C, we can construct a new category C_M whose objects are the same as the objects of C, but the arrows f: X -> Y in C_M are the arrows f: X -> M Y in C.
16:54:09 <inimino> brad_larsen: in scheme it's called map
16:54:13 <brad_larsen> Berengal: with some type class magic you could write the more general thing
16:54:17 <Gracenotes> zipWith f xs ys, is exactly equivalent to map (uncurrry f) $ zip xs ys
16:54:43 <Berengal> brad_larsen, you could, but it wouldn't be typesafe
16:54:46 <brad_larsen> inimino: aha, in scheme too.  I guess other people languages call it 'map'
16:55:24 <Gracenotes> so the generalized function is map, really, just with an n-tuple. in one approach at least
16:55:26 <Cale> Perhaps to keep clear which category we're talking about, I'll write an arrow from X to Y in C_M as X ~> Y, which is an arrow X -> M Y in C.
16:55:49 <dpratt71> Cale: this might be a good time to ask someone to explain in simple terms what is the relationship between Categories and Monads? they are pretty conflated in my understanding atm
16:55:56 <Cale> oh
16:56:09 <inimino> brad_larsen: it's just that in Haskell all those things have different types, so we can't very well call them all 'map', but zipWith could have been called map2, map3,...
16:56:16 <Cale> Okay, so in order to explain what a monad is in category terms, we'll need some additional concepts :)
16:56:16 <gwern> huh. meachem is unemployed
16:56:24 <Cale> First, what a functor is.
16:56:30 <gwern> just goes to show what will happen to those who defy the Cabal!
16:56:31 <brad_larsen> inimino: yeah, i see that
16:56:33 <gwern> bwa ha ha ha
16:56:51 <Cale> actually, let's go to #haskell-in-depth or #haskell-overflow, so that there's less scrolling :)
16:56:54 <dpratt71> a functor takes an object to another object?
16:56:58 <brad_larsen> Berengal: I think with the appropriate amount of typeclass/type family magic, one could define the more general 'map' in haskell
16:57:04 <brad_larsen> Berengal: in a type-safe way
16:57:08 <Gracenotes> I suppose you could write a function that does this, like: instead of zipWithN (\a b c d e -> ...) q r s t u v: map (\[a, b, c, d, e] -> ...) (transpose [a, b, c, d, e]). with some list-processing overhead
16:57:12 <Cale> A functor sends objects to objects and arrows to arrows in a way which preserves composition.
16:57:13 <brad_larsen> Berengal: but maybe I'm just crazy
16:57:16 * ezyang had a conversation with a mathematician, and mentioned Monads, and they were like, "Oh, those aren't interesting because they're too specific" ^_^ 
16:57:33 <heatsink> heh
16:57:38 <Berengal> brad_larsen, type-families might make it possible to regain typesafety. I'd like to see an implementation of that
16:57:42 <Gracenotes> but, again, there is an isomorphism between n-ary functions and n-ary tuples, discounting partial application.
16:58:13 <brad_larsen> I ask not because I'm really wanting to implement the generalized map function in haskell itself, but because I'm coming up with an AST for such a function
16:58:17 <Gracenotes> I'm too uncreative to think of an oleg-esque way to do it >_>
16:58:19 <brad_larsen> for a compiler
16:58:48 <brad_larsen> written in haskell
16:58:58 <brad_larsen> I guess I'll just call it `map'
16:59:09 <brad_larsen> err, Map, rather
16:59:17 <brad_larsen> (the data constructor)
17:00:38 <Gracenotes> this might be an interesting start-place about typeclasses needed to do that, http://okmij.org/ftp/typed-formatting/FPrintScan.html#DSL-In
17:02:26 <Gracenotes> and the papers after it
17:08:59 <heatsink> Can someone explain this error message to me?  It says that the inferred type of "bar" is "Maybe ()" and the expected type is "IO ()", but I think the opposite is true.  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4472
17:09:09 <ezyang> looking
17:09:56 <ezyang> I think I see the problem
17:10:02 <brad_larsen> i think it inferred 'Maybe ()' from bracketFoo
17:10:04 <McManiaC> woot, 0.9 release coming soon
17:10:05 <ezyang> What type do you think m is in the bracketFoo call?
17:10:05 <McManiaC> about time
17:10:40 <heatsink> In bracketFoo, 'foo' has type 'Maybe ()' , so 'm' must have type 'Maybe a'
17:10:53 <heatsink> But for that reason, the expected type of bar should be Maybe a
17:11:48 <heatsink> I don't understand why the expected type is IO ()
17:12:03 <Gracenotes> that comes from 'main'
17:12:27 <ezyang> Hm
17:12:33 <ezyang> Actually, it could go either way
17:12:41 <ezyang> Probably some obscure type resolution rule
17:12:58 <Gracenotes> bracketFoo uses (>>) :: (Monad m) => m a -> m b -> m b. Since the first argument is Maybe (), that becomes: Maybe () -> Maybe b -> Maybe b.
17:14:35 <heatsink> So bracketFoo :: forall b. Maybe b
17:15:47 <Gracenotes> well, :: Maybe a -> Maybe a
17:15:47 <heatsink> Huh.  If I replace the do{} block with (bar >> undefined), then I get the error I was expecting.
17:15:55 <heatsink> oh.  Yeah.
17:16:21 <heatsink> I don't understand why do {bar; undefined} produces a different error message than (bar >> undefined).  Shouldn't they be the same?
17:16:39 <Gracenotes> hm.. now .that. is interesting
17:17:17 <Gracenotes> the type checking should happen after the desugaring, I thought..
17:17:58 <heatsink> Gracenotes, I recall that type checking happens before desugaring so that it can print more accurate source code expressions in error messages.
17:18:29 <Gracenotes> what is this different error message it prints?
17:18:55 <heatsink> couldn't match expected type 'Maybe a' against inferred type 'IO ()' in `bar'
17:19:07 <heatsink> For the 'do' expression, it says
17:19:19 <heatsink> couldn't match expected type 'IO ()' against inferred type 'Maybe ()' in 'bar'
17:21:13 <heatsink> The type of bar is IO () and its context involves a Maybe monad, so the 'do' error message doesn't make sense to me.
17:21:57 * SubStack wants a keep trying monad
17:23:02 <heatsink> :t \m -> forever ((m >> return ()) `catch` const (return ()))
17:23:02 <lambdabot> forall a b. IO a -> IO b
17:23:11 <SubStack> :o
17:24:07 <SubStack> I had let m = do { x <- randomRIO (0,100::Int); ((guard $ x `mod` 5 == 4) >> return x) `mplus` m }
17:24:40 <heatsink> Hmm, yeah
17:24:46 <heatsink> :t msum . repeat
17:24:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a
17:24:52 <SubStack> hmmm
17:26:15 <heatsink> Gracenotes, ezyang: Does that error message seem counterintuitive to you also?
17:26:30 <SubStack> msum, of course
17:26:33 <SubStack> much cleaner now
17:27:05 <Gracenotes> you might want to try submitting some minimal testcases to a ghc users mailing list
17:27:16 <heatsink> Ah, good point.  I'll do that.
17:28:07 <Gracenotes> it doesn't typecheck anything as correct that's incorrect, but I think it has to do with the set of assumptions, and the order in which it it forms them, such that finding a contradiction can go both ways
17:33:12 <heatsink> Yeah, it's finding a real error.  I'll post to ghc-users, I still want to understand why the error message turns out that way.
17:34:32 <Kruppe> Is it possible to have instance declarations of some class, lets say "class Stuff a where { something :: a -> a}" that follow a pattern like this: "instance Stuff (Int, Int) where { something x = x; }"?
17:35:12 <heatsink> Kruppe, sure
17:35:17 <Kruppe> oh
17:35:19 <Kruppe> hmm
17:36:14 <Kruppe> cause i'm getting an error like this: All instance types must be of the form (T a1 ... an) where a1 ... an are distinct type *variables* etc
17:36:27 <Kruppe> then it recommends using a flag -XFlexibleInstances
17:36:32 <heatsink> Oh, you need to turn on that flag
17:36:35 <Kruppe> ah
17:36:42 <Kruppe> what does that do exactly
17:36:52 <opqdonut> allows flexible instance declarations :)
17:36:57 <Kruppe> nice
17:36:59 <opqdonut> like "Stuff (Int, Int)"
17:37:07 <Kruppe> is there a way to use that in ghci as well?
17:37:12 <opqdonut> the haskell 98 standard allows only "Stuff (a, b)"
17:37:17 <heatsink> There are some restrictions to ensure that the compiler can automatically find the right instance.
17:37:31 <heatsink> GHC has more powerful type inference than H98, so it can be more flexible.
17:37:40 <Kruppe> oh i see
17:38:16 <Kruppe> yeah i want an instance where i can have a list of two integer tuples
17:38:25 <Kruppe> thats why i need it
17:38:29 <Kruppe> locations on a map
17:39:18 <opqdonut> (in H98 you'd have had to define "newtype Foo = Foo (Int,Int)" and then "instance Stuff Foo"
17:39:21 <opqdonut> )
17:40:00 <Kruppe> that wouldn't be soooo bad
17:40:06 <Kruppe> I am using ghc though
17:40:07 <opqdonut> (which would basically force you to wrap and unwrap Foos all the time, which is ok but bothersome)
17:40:21 <opqdonut> yeah, FlexibleInstances is a pretty safe extension
17:40:28 <Kruppe> thats good
17:40:48 <opqdonut> exactly for the reason that it doesn't add much, only removes the need for one newtype
17:41:01 <Kruppe> yeah
17:41:37 <Kruppe> so is there any way for ghci to tell whats going on?
17:41:51 <Kruppe> like is there some directive i can put at the beginning of the file to tell it what flags to take into account?
17:42:11 <Kruppe> or can ghci even handle that
17:42:22 <heatsink> Kruppe, there's a GHC pragma {-# LANGUAGE FlexibleInstances, MultiParamTypeClasses, EtCetera #-}
17:42:36 <heatsink> for ghci, you need to pass command line parameters
17:42:44 <heatsink> You can do it interactively with the :set command
17:42:54 <Kruppe> ah
17:42:56 <Kruppe> nice
17:43:35 <Kruppe> im coding in emacs, so C-c C-l is really convienient, would hate to not be able to do that just to have a nicer instance declaration
17:44:43 <heatsink> Kruppe, I use Alt-Tab <up> <enter>
17:46:52 <Kruppe> heatsink: for me, M-Tab is bound to complete-symbol
18:08:36 <PetRat> How do you catch an exception thrown by Prelude.read? What category is it in?
18:09:19 <Raevel> @hoogle reads
18:09:20 <lambdabot> Prelude reads :: Read a => ReadS a
18:09:20 <lambdabot> Text.Read reads :: Read a => ReadS a
18:09:20 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
18:09:59 <PetRat> I tried IOException but that didn't catch it.
18:10:07 <PetRat> I guess it's not really IO per se.
18:11:38 <PetRat> Raevel: did you have an idea? Does that hoogle information give us a clue?
18:14:23 <PetRat> How do you catch an exception thrown by Prelude.read? What category of exception is it in?
18:16:45 <Gracenotes> read itself throws an exception based on what it encounters from functions it, in turn, uses
18:17:14 <Absolute0> Is it necessary to define recursive functions using tail-recursion in haskell?
18:17:39 <Gracenotes> you can use some of these lower functions, like 'reads', directly and avoid the mess. as for exceptions caused by 'error', those can be caught in IO.
18:17:44 <Gracenotes> but best to avoid them to begin with
18:18:01 <heatsink> Absolute0, no.  In fact, the preferred way is to use an existing recursion pattern rather than define your own.
18:18:49 <PetRat> Gracenotes: how does reads help? Is there a function String -> Maybe a (so it doesn't need to throw an exception) , or String -> Either Sring a
18:19:02 <Kruppe> heatsink: are there more recursive patterns than just the folds to play aroudn with?
18:19:05 <Absolute0> heatsink: whats the "existing recursion pattern"? tail-recursion is well known, I didn't invent it.
18:19:18 <ClaudiusMaximus> @hoogle Read a => String -> Maybe a
18:19:19 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
18:19:19 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
18:19:19 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
18:19:41 <Gracenotes> PetRat: reads will return an empty list if it is unsuccessful
18:19:45 <Absolute0> heatsink: are you refering to fold?
18:19:48 <heatsink> Absolute0, a lot of recursive code can be written in terms of one of the existing list functions, for example, 'map', 'fold', 'scan', 'zipWith'
18:19:58 <Absolute0> :)
18:20:25 <heatsink> If your code is not deeply recursvie, then it doesn't matter much whether you use tail recursion.
18:20:31 <heatsink> When deciding whether to use tail recursion, you should be aware of whether your code is being evaluated strictly or lazily.
18:20:42 <Gracenotes> PetRat: some examples (assuming the types have been stated, so there's no ambiguous business): reads "Just 4" -> [(Just 4, "")]. reads "Just " -> []. reads "Just 4 3" -> [(Just 4, " 3")]
18:20:50 <ClaudiusMaximus> i generally use case reads s of ((x,""):_) -> fooMeWithYour x
18:21:07 <Absolute0> maybe fold does use tail recursion? :)
18:21:10 <Gracenotes> yeah, you might want to ensure that there are no dangling bits
18:21:14 <Absolute0> @src fold1
18:21:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:21:18 <Absolute0> @src foldl
18:21:18 <lambdabot> foldl f z []     = z
18:21:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:21:19 <PetRat> Gracenotes: I see. I wasn't familiar with the ReadS type. That made it clear.
18:21:29 <Gracenotes> it is a type synonym, is all
18:21:30 <heatsink> @src foldl'
18:21:30 <lambdabot> foldl' f a []     = a
18:21:30 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:22:05 <Absolute0> what does seq do?
18:22:14 <Kruppe> forces strictness
18:22:36 <Kruppe> causes the evaluation of the left side before the right
18:22:38 <Kruppe> i think
18:22:42 <heatsink> Yes
18:22:55 <heatsink> In this case, you want to force the current evaluation to be evaluated before the next iteration
18:23:03 <Absolute0> Kruppe: opposite of the '$' operator?
18:23:10 <Absolute0> well not exactly..
18:23:11 <Kruppe> not exactly
18:23:14 <Absolute0> :-P
18:23:16 <Kruppe> :P
18:23:31 <Kruppe> it forces it to be EVALUATED as in, no longer staying as a thunk
18:23:40 <Kruppe> so that your stack doesn't explode
18:23:46 <Kruppe> thats the impression i have of it that is
18:23:53 <Kruppe> someone correct me if im wrong please
18:24:05 <heatsink> that's right
18:24:06 <Absolute0> can i do @src in ghci?
18:24:44 <heatsink> i guess not
18:25:06 <Absolute0> strictly #haskell?
18:25:06 <Gracenotes> Absolute0: it gets them from http://code.haskell.org/lambdabot/State/source
18:25:58 <Absolute0> Gracenotes: is that file cached in some sort of hash?
18:26:11 <Absolute0> or it parses it on the fly?
18:26:24 <Absolute0> is the bot even written in haskell? :-P
18:26:43 <Gracenotes> it is. navigate the source tree starting at /lambdabot to read it
18:26:52 <Gracenotes> here is the source-getting source. http://code.haskell.org/lambdabot/Plugin/Source.hs
18:27:42 <Gracenotes> the file seems short enough that it could get away with linear search. it has a Map here apparently, O(lg n) lookup and the like
18:28:44 <Absolute0> Data.Map is O(lg n) lookup
18:28:45 <Absolute0> ?
18:29:23 <Gracenotes> it is a balanced binary tree
18:29:43 <Cale> Absolute0: yes
18:29:55 <Absolute0> Is there an O(N) implementation?
18:29:56 <Cale> Absolute0: and O(log n) immutable update too :)
18:29:57 <Absolute0> for lookup?
18:29:59 <Gracenotes> you can see that it takes 4 short lines to parse it. (there is not much to parse)
18:30:15 <Gracenotes> in  complexity
18:31:09 <Gracenotes> Absolute0: you could use a list and Prelude.lookup
18:32:07 <Gracenotes> but Map is rather better for key/value lookup... more efficient. just requires Ord
18:32:28 <Absolute0> Gracenotes: but then on each insert i'd have to create a new Prelude.lookup?
18:33:08 <Gracenotes> hm? the lookup functions, both for (key, value) lists and for maps, takes two arguments: the key, and the data structure
18:34:05 <Gracenotes> I'm not sure you'd want O(n) when O(lg n) is about as efficient as you can get
18:34:43 <Gracenotes> barring amortized O(1) hashtables, which aren't so bad once set up but have some associated difficulties in Haskell when they need to be mutated constantly
18:35:19 <Gracenotes> Absolute0: I'm confused about what you're confused about
18:36:04 <Absolute0> Gracenotes: I meant O(1) lookup as you just mentioned
18:36:13 <Absolute0> which Java's HashMap implements.
18:36:21 <Absolute0> IIRC
18:37:38 <Gracenotes> ah. hash tables are nice, but if you're dealing just with immutable data structures, maps are more ideal, even though there is a O(lg n) factor
18:37:51 <Absolute0> exactly
18:37:55 <Kruppe> are there any folds where the step function takes the whole list instead of only the head of the list?
18:38:15 <Absolute0> Kruppe: can't you adjust your lambda to do that?
18:38:41 <Gracenotes> this factor has not been too noticeable a problem for me in my coding, although people do occasionally complain about it
18:38:58 <Kruppe> Gracenotes: which factor
18:39:21 <Absolute0> Gracenotes: I wrote a ChessEngine so i dealt with it a lot: http://github.com/ramin32/ChessEngine
18:39:26 <heatsink> Kruppe, if the step function wants the whole tail of the list, you can do that with 'inits'
18:39:29 <Gracenotes> lg n factor, in maps
18:39:58 <Absolute0> I think slow indexing is the only disadvantage of haskell
18:40:02 <Gracenotes> hm. if you need the whole list, maybe your own form of recursion would be better.
18:40:10 <mmorrow> Kruppe: no, but you can make one easy enough (when you add that to a fold, it become general recursion == equivalent to fix)
18:40:12 <ezyang> Absolute0: You probably are using the wrong datatpype
18:41:32 <mmorrow> @let foldC _ z [] = z; foldC f z (x:xs) = f z x xs (\x' -> foldC f x' xs)
18:41:33 <lambdabot>  Defined.
18:41:40 <Absolute0> ezyang: that's a nice assumption. :P
18:41:57 <Absolute0> Any reason to say that?
18:42:23 <mmorrow> Absolute0: what are you trying to do?
18:43:18 <ezyang> Absolute0: Linked lists are very simple datastructures that work well in a functional context, but if you need fast indexing there are other possibilities
18:44:00 <Gracenotes> Absolute0: it seems you set up a Map in the beginning and don't change it much beyond that? in that case, you could possibly make an array-backed read-only hash table. But did the performance really suffer *that* much with Maps, do you think? hm.
18:44:30 <mmorrow> Absolute0: if you want fast mutable arrays and nice array-related optims, use C and a nice compiler.
18:44:53 <ManateeLazyCat> mmorrow: Any lucky with my code?
18:45:14 <Absolute0> mmorrow: right, but haskell is more fun
18:45:15 <Absolute0> :)
18:45:31 <Gracenotes> something that's interesting is that, for complicated keys, calculation of the hash requires examination of the entire object (barring caching). doing an Ord comparison can be lazy; you might not even have to look at any data
18:46:35 <mmorrow> ManateeLazyCat: i looked it through, and i think the only real (real := in the long-run) is to do a global restructuring of how everything interacts
18:46:46 <mmorrow> *..real solution...
18:47:23 <ManateeLazyCat> mmorrow:  complete refactory?
18:48:02 <ManateeLazyCat> mmorrow: Now just IORefObject and UI.* module need adjustment.
18:48:42 <mmorrow> ManateeLazyCat: just at level of module-to-module communication, but i'd need to read through your code some more to suggest a particular strategy
18:48:48 <mmorrow> ManateeLazyCat: ooh, nice.
18:49:27 <ManateeLazyCat> mmorrow: But i think IORefObject.hs is really bad, i need split IORefObject.hs with some Layout that control double reference.
18:49:47 <mmorrow> ManateeLazyCat: that's the other solution, if you can shrink the mutual inter-dependencies down to a reasonable size, a boot module or two may be worth it
18:50:15 <mmorrow> ManateeLazyCat: yeah, the IORefObject i think is the real problem here
18:50:29 <ManateeLazyCat> mmorrow: IORefObject control everything, and it's wrong.
18:51:06 <SamB_XP> ManateeLazyCat: heck, even the name is evil!
18:51:08 <ManateeLazyCat> mmorrow: Root boot module is bad, it break module absolute, we just build a huge .hs-boot file.
18:51:22 <ManateeLazyCat> SamB_XP: :)
18:51:57 <McManiaC> hmmm im trying to use X.U.Loggers to get rid of conky for my status bar currently i got it as a second dynamicLogWithPP (since i got 2 dzen bars), but this updates only when i change workspaces/focus is there a way to update my dzenbar every X seconds?
18:52:05 <mmorrow> ManateeLazyCat: i'm thinking that a good strategy to go about it would be to try to reduce/eliminate how two modules need to know about each others functions
18:52:41 <mmorrow> because that's really where the cycles start becoming unavoidable
18:53:27 <mmorrow> since you can always move a bunch of type definitions to a single central module, but once you have to start moving functions into a central module, abstraction starts breaking down
18:55:02 <ManateeLazyCat> mmorrow: When i create IORefObject.hs, i just want coding is simple, otherwise i need transform many argument to function. But now i think IORefObject.hs is bad idea, worse than transform many argument to function.
18:56:07 <mmorrow> ManateeLazyCat: right, transforming a bunch of arguments to functions is exactly what needs to happen
18:56:08 <ManateeLazyCat> mmorrow: Central module is unnecessary, but i need split layout, and not drop everything in *one* module.
18:56:38 <mmorrow> ManateeLazyCat: i agree
18:58:56 <ManateeLazyCat> mmorrow: In current situation, if we want define centeral module, just keep type define in it, don't write any function that need reference low-level module. Right?
18:59:07 <ManateeLazyCat> define type in it.
18:59:58 <ManateeLazyCat> mmorrow: I think central module is necessary anyway, what do you think?
19:00:34 <mmorrow> right, the functions in the low-level modules would only know how to do things with the type they're associated with, then the next level starts tying groups of lower-level modules together, and the next level does the same and so on
19:01:28 <mmorrow> and finally at the very top, everything joins
19:02:15 <mmorrow> ManateeLazyCat: i usually go with the pattern
19:02:23 <ManateeLazyCat> mmorrow: Yesterday, dcoutts_  give me another solution that will avoid low-level reference IORefObject.
19:02:38 <ManateeLazyCat> mmorrow: I always try to forget pattern design. :)
19:03:08 <mmorrow> s/pattern/way of structuring many-module programs/
19:03:35 <ManateeLazyCat> mmorrow: Example, he told me create "pageFun :: PagePluginAction :: IO -> Page"
19:04:02 <ManateeLazyCat> mmorrow: Then create *temporary* PagePluginAction variable when call fucntion `pageFun`.
19:04:38 <mmorrow> unit := Foo + Foo.Types + Foo.*
19:04:39 <ManateeLazyCat> mmorrow: Example i call `pageFun` in IORefObject, because PagePluginAction define in Page.hs, so Page.hs know nothing about IORefObject.hs
19:05:04 <ManateeLazyCat> mmorrow: Then i just leave *single* reference, and not *double* reference.
19:05:06 <mmorrow> Foo provides the interface other units will interact with anything in Foo.*
19:05:30 <mmorrow> and Foo re-exports Foo.Types and selectively re-exports pieces of the modules under Foo.*
19:05:48 <mmorrow> and no two units at the same level directly interact
19:06:07 <mmorrow> well, there's always one base unit which all the others need
19:06:08 <ManateeLazyCat> mmorrow: That's a good idea.
19:06:35 <PetRat> Just an observation: I come to Haskell from OO compiled and script languages. Still learning Haskell, but my experience has been this: bugs are few. Pretty much if a program compiles, it works. It's a great feeling.
19:06:42 <mmorrow> then the next level of units start tying these lower units together pairwise
19:07:28 <ManateeLazyCat> mmorrow: Like a tree, but any leaves don't know each other?
19:08:16 <mmorrow> they all know the "base" unit, but no two leaves know about each other
19:08:57 <mmorrow> and at the next higher level, each unit knows only about 2/3/N lower-level units
19:09:10 <mmorrow> and then upwards until the top
19:09:30 <ManateeLazyCat> mmorrow: dcoutts_ give me another design, in the tree, *base* unit know every leaves, but any leaves don't know *base* unit.
19:10:21 <mmorrow> ah right, that may be better for a GUI program actually now that i think about it
19:11:01 <mmorrow> hmm, or actually i think they're just matters of preference
19:11:25 <ManateeLazyCat> mmorrow: You both solution will avoid recursive reference.
19:11:31 <mmorrow> right
19:11:51 <mmorrow> ManateeLazyCat: well, what do you/dcoutts mean by "base" unit there?
19:12:07 <ManateeLazyCat> mmorrow: IORefObject.
19:12:15 <mmorrow> as in the module that defines the most basic types of
19:12:17 <mmorrow> oh
19:12:27 <ManateeLazyCat> mmorrow: We think IORefObject is *base* unit you mean.
19:12:47 <ManateeLazyCat> mmorrow: Then make `Page` `View` know nothing about IORefObject.
19:13:20 <ManateeLazyCat> mmorrow: Your solution will build a meticulous tree that have many layout.
19:13:28 <mmorrow> hmm, yeah. for a second there i thought we may have been talking about the same thing, but that way really is the dual/opposite way of doing it.
19:13:45 <ManateeLazyCat> mmorrow: dcoutts_ solution more like situation of current my code.
19:14:41 <ManateeLazyCat> mmorrow: your solution is more complicated, but we will get better structure and framework.
19:15:26 <mmorrow> yeah, i think his is a better way for your prog too. the kind of program i've been using that other way of structuring for has been programs that are essentially translators of things
19:15:29 <ManateeLazyCat> mmorrow: dcoutts_ solution is simple, it just fix recursive problem in my code, but drop everything in *base* unit is really really bad idea.
19:16:00 <mmorrow> so their more of a "pipeline", whereas a GUI app is more of a .. not-a-pipeline
19:16:03 <mmorrow> or something
19:16:09 <mmorrow> *so they're ..
19:16:43 <ManateeLazyCat> mmorrow: Yes, GUI like dcoutts_ solution.
19:17:00 <ManateeLazyCat> mmorrow: It's not perfect pipeline to structure layout.
19:18:16 <ManateeLazyCat> mmorrow: If we use Gtk+ build a tree, in dcoutts_ solution, every leaves generate speical signal, then use *base* unit plugin speical code in those signal.
19:19:37 <ManateeLazyCat> mmorrow: Leaves know nothing about other leaves even them plugin code in it's callback.
19:21:33 <ManateeLazyCat> mmorrow: Of course, your solution looks more elegant.
19:23:43 <ManateeLazyCat> mmorrow: About "unit := Foo + Foo.Types + Foo.*", i remember something.
19:23:50 <ManateeLazyCat> mmorrow: gtk2hs is build like your design.
19:24:42 <ManateeLazyCat> mmorrow: Foo.Types make low-level can communication each other.
19:25:24 <hackagebot> geohash 1.0.1 - Geohash latitudes and longitudes. (MariusEriksen)
19:26:27 <mmorrow> i like that way, because you can build arbitrarily complex (or simple) things underneath Foo.*, and no one else has to know or care, they just care about the top-level that's exposed via Foo
19:27:49 <ManateeLazyCat> mmorrow: If i use current *single* module, i will crazy when my project became huge, because IORefObject do everything in it, hard to understand and maintain.
19:28:10 <mmorrow> ManateeLazyCat: ooh, gotta run. i'll think about it some more/read through your code.    btw, it looks really nice so far :)
19:28:13 <dpratt71> :t (>>=)
19:28:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:28:37 <ManateeLazyCat> mmorrow: Except IORefObject?
19:28:50 <dpratt71> : join
19:28:56 <dpratt71> :t join
19:28:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:29:07 <c_wraith> more amusing is:
19:29:09 <c_wraith> @src join
19:29:09 <lambdabot> join x =  x >>= id
19:29:14 <mmorrow> ManateeLazyCat: heh, i mean the code is nice and clean/clear
19:29:37 <ManateeLazyCat> mmorrow: Yes, i hate dirty code, always. :)
19:29:45 <mmorrow> hehe, me too :)
19:30:17 <ManateeLazyCat> mmorrow: Sometimes, i think my code will perfect if i remove IORefObject everywhere.
19:30:50 <ManateeLazyCat> mmorrow: Now document is simple, haven't time detail document, if you any problem, you can call me, anytime :)
19:31:08 <heatsink> Well, it will be immutable, so you could say your code is eternal.
19:32:09 <ManateeLazyCat> mmorrow: Okay, i will need refactory code by your design "unit := Foo + Foo.Types + Foo.*", it's really natural way to improve my design, thank you very much! :)
19:33:22 <tectum> what does stage1/stage2 compiler mean? is that explained somewhere?
19:34:01 <heatsink> tectum, GHC builds itself twice.
19:34:13 <heatsink> stage1 is built using whatever GHC already exists on your system
19:34:17 <heatsink> stage2 is built using stage1
19:34:30 <tectum> why does it do that?
19:34:51 <heatsink> If your GHC build is broken, you will probably detect it during stage2
19:35:19 <heatsink> It does that because newer versions of GHC usually optimize better than older versions
19:35:27 <heatsink> So building GHC with the newest version of GHC makes it faster
19:35:32 <ezyang> Cute!
19:36:00 <tectum> thanks for explaining that
19:36:03 <heatsink> How's the ia64 port going?
19:36:46 <tectum> I stole the 6.8.2 debian package and am now trying to compile 6.12 with it
19:37:10 <tectum> getting this error: ghc-stage1: could not execute: inplace/lib/ghc-asm
19:37:37 <heatsink> Hmm.  Are you doing an unregisterised build?
19:38:22 <heatsink> Let me look into what ghc-asm is.
19:38:58 <tectum> yes, I was following http://hackage.haskell.org/trac/ghc/wiki/Building/Unregisterised
19:39:03 <heatsink> GHC's backend cannot generate ia64 assembly.  The ia64 compiler uses the via-C path, which uses gcc as the backend,
19:39:16 <heatsink> .
19:39:46 <kmc> can you use via-C with icc?
19:39:55 <heatsink> No, it needs gcc
19:39:59 <tectum> so ghc-asm is the -fasm part of ghc?
19:40:01 <kmc> iirc gcc on ia64 can't hold a candle to intel's compiler
19:40:08 <kmc> 'cause they designed the chip and all
19:40:17 <kmc> and 'cause it has a really complicated ISA
19:40:46 <heatsink> tectum, I don't know.  Just guessing based on the name.
19:41:28 <heatsink> kmc: The ia64 build plays dirty tricks with stack frames.  It works fine with gcc since it's not too clever.
19:42:39 <heatsink> It uses gcc's "asm" feature to emit special strings into the assembly code, then postprocesses it to replace all the function epilogues.
19:42:53 <kmc> evil mangler?
19:42:56 <heatsink> yea
19:44:36 <heatsink> oh, ghc-asm is the mangler script.
19:45:30 <heatsink> tectum, It's a perl script.  Does the file exist, and does it have execute permission?
19:46:09 <tectum> it does does not exist
19:46:27 <tectum> $ find -iname "*ghc-asm*"
19:46:28 <tectum> ./driver/mangler/ghc-asm.lprl
19:46:28 <tectum>  
19:46:34 <zooko> Folks: how can I configure the Haskell Platform configure/install script to use a specific dir instead of /var/lib/ghc-6.10.4/ for its package.conf?
19:46:38 <zooko> http://trac.haskell.org/haskell-platform/ticket/98
19:47:09 <heatsink> tectum, try running 'make' in that directory
19:48:30 <tectum> make[2]: *** No rule to make target `all_driver/mangler'.  Stop.
19:48:30 <tectum>  
19:49:11 <heatsink> Hmm, I don't know what that is.
19:50:48 <zooko> Hm, so in order to hack the haskell platform install script to do what I want, I guess I need to understand this notion of "user" versus "global" installation.
19:51:15 <zooko> It isn't acceptable to me to run the installer with root privs, but neither is it acceptable that only one user will be able to use the resulting installed things.
19:51:39 <zooko> So I need to understand what it means by "user" and "global" so I can hack it to do what I actually want, which is simply to use the db in the directory that I specify.
19:51:55 <tectum> heatsink: should I file a bug report for that?
19:53:03 <heatsink> tectum, it's a bug, but since ia64 isn't being actively maintained, the chance that the bug will be fixed is very low
19:54:46 <heatsink> I would debug the makefile.  Run `make -d' to figure out why it's trying to build the target (it prints lots of output, so save it to a file) and also search for the rule in various makefiles
19:55:01 <heatsink> The more you can narrow down the problem, the more likely it'll be fixed
19:55:34 <tectum> thanks, I'll try that
19:57:44 <zooko> Argh.  If I pass --enable-user-install then "make" fails.
20:01:06 <zooko> Wah, there's something sticky so running ./configure with different options and then make always fails now where before it succeeded.  :-(
20:01:15 <zooko> Cleaning and rebuilding, which I think takes 15 mins on this system.
20:02:49 <zooko> Okay I'm probably giving up on installing haskell platform on this machine for the time being.
20:03:36 <heatsink> sorry about that
20:10:51 <zooko> Aha, it turns out that Cabal has the exact same problem.
20:11:02 <zooko> So I guess my bug report against haskell platform is really a bug report against Cabal.
20:14:52 <Saizan_> what problem?
20:15:38 <Saizan_> --global installations use the global package db, while --user ones use the user one :)
20:16:02 <Saizan_> see "ghc-pkg list" output to tell where they are
20:16:07 <heatsink> Saizan_, it's a problem with re-running ./configure
20:16:24 <Saizan_> you can also pass a flag to point it to a specific db
20:16:48 <Saizan_> --package-db
20:17:47 <Saizan_> heatsink: uhm, the Cabal package doesn't have a configure script, other packages do but Cabal just reruns it at every configure step, afaiu
20:18:37 <zooko> http://hackage.haskell.org/trac/hackage/ticket/601
20:18:55 <zooko> Saizan_: thanks.  Does the above bug report explain what doesn't work for me?
20:19:09 <zooko> I'll try --package-db
20:20:09 <Saizan_> it explains the problem, and that you want --package-db
20:20:53 <zooko> Like this?  ./Setup configure --prefix=/usr/local/stow/Cabal --package-db=/usr/local/stow/Cabal/var/lib/package.conf
20:21:02 <zooko> That yields Setup: ghc-pkg dump failed
20:21:13 <zooko> Maybe I need to mkdir the path for it first?
20:21:27 <Saizan_> probably
20:21:42 <zooko> Still fails in the same way.
20:22:02 <Saizan_> you might need to touch it, or echo '[]' into it
20:22:50 <zooko> Thanks!
20:23:14 <zooko> Yay!  echo [] worked.
20:23:38 <SamB_XP> zooko: I *hate* that
20:23:41 <SamB_XP> I've had to do that
20:23:46 <SamB_XP> I forget when or why
20:24:05 <SamB_XP> oh, actually, I think I was trying to use Cabal with the old LHC
20:24:14 <Saizan_> i wonder if they fixed it, or maybe they didn't bother since now the packagedb is a directory
20:24:47 <zooko> It is?
20:24:58 <Saizan_> in ghc-6.12
20:25:19 <zooko> Ah, cool.
20:29:50 <zooko> Thanks folks!
20:29:57 <zooko> And by "folks" I mean Saizan.
20:31:24 <heatsink> Saizan++
20:32:21 <Saizan_> hehe, np :)
20:41:05 * heatsink throws a goomba at ElSuperDragon
20:42:10 * SamB_XP throws a koopa shell at it
21:05:55 <ivanm> @. elite quote
21:05:55 <lambdabot> DrM4ci\/eR z4Yz: i Dr34d To T|-|INk wha+ cA7e90Ry t|-|EOrY \/\/0u1d loOK |ikE 4f+er T|-|e soph+waRE 3NGiNeerIn9 \/\/or1D HAD Got 7|-|eIr gRUBby p4wz ON i+. eN73rpRI$EvArI4nt phUnC+0rs. cOMmutATIVE
21:05:55 <lambdabot> uM1 dI49R4M$.
21:06:24 <sproingie> epic
21:07:12 <heatsink> epic programming > extreme programing > agile programming > waterfall design
21:08:17 <ivanm> sproingie: you just need to say it in the UT announcer voice... ;-)
21:09:02 <Saizan_> preflex: seen DrMacIver
21:09:02 <preflex>  DrMacIver was last seen on #haskell 22 days, 14 hours, 10 minutes and 21 seconds ago, saying: Not that a basic amount of galois theory is hard to grasp
21:09:38 <sproingie> and then he was never seen again
21:09:41 <sproingie> muahaha
21:10:28 <iaefai> I had to put that elite quote in a translator to understand it partially
21:10:57 <sproingie> i was able to read it like it was english
21:11:04 <iaefai> sproingie: How?
21:11:05 <sproingie> i think this does not say good things about me
21:11:30 <c_wraith> I like the idea of enterprise-variant functors
21:11:35 * SamB_XP wonders what an epic functor is
21:11:46 <iaefai> What does "epic programming > extreme programing > agile programming > waterfall design" mean?
21:11:51 <SamB_XP> or epic morphism
21:11:51 <sproingie> phunktor, booya
21:12:04 <ivanm> iaefai: epic programming is better than extreme programming, etc.
21:12:08 <c_wraith> iaefai:  You get anywhere on that network stuff?
21:12:40 <iaefai> c_wraith: Can you be more specific? I have a couple aspects of this project I am working on.
21:12:57 <iaefai> ivanm: I don't even know what those terms even mean :p
21:13:07 <c_wraith> iaefai:  Oh.  Just wondering if you made sense of anything I told you last night.
21:13:11 <ivanm> iaefai: oh, that... epic programming is made up AFAIK
21:13:19 <ivanm> iaefai: for the rest, look on wikipedia
21:13:45 <SamB_XP> @uncyclopedia epic programming
21:13:45 <lambdabot> Unknown command, try @list
21:13:48 <SamB_XP> awwwwww
21:14:02 <iaefai> c_wraith: I have to look it up, I don't remember any 'network' stuff. I was dealing with data types yesterday.
21:14:22 <c_wraith> iaefai:  I must be remember the wrong name, then.
21:14:27 <c_wraith> damn my memory
21:14:33 <iaefai> tell me about it
21:15:26 <iaefai> I saw astroboy a few hours ago
21:17:10 <heatsink> epic programming > extreme programing > agile programming > waterfall designg996
21:17:19 <heatsink> sorry, wrong window
21:17:40 <ElSuperDragon> what's epic?
21:17:46 <iaefai> me
21:17:48 <c_wraith> better than extreme.
21:17:48 <SamB_XP> were you trying to save that for the next HWN or something ?
21:18:09 <ElSuperDragon> OO programming > epic programming
21:18:19 <sproingie> http://uncyclopedia.wikia.com/wiki/Objectivism-oriented_programming
21:18:43 <SamB_XP> how about objection-oriented programming ?
21:18:48 <sproingie> ooh
21:19:12 <sproingie> there's also an article on Nonfunctional programming
21:19:19 <iaefai> Have you guys seen that instructional video? "Debby Does Ruby on Rails"?
21:19:52 <SamB_XP> iaefai: is that like "Debby Does Crack?
21:20:01 <iaefai> SamB_XP: Probably
21:20:03 <SamB_XP> or "Debby Does Pot"?
21:20:06 <sproingie> more like Debby Does Debby
21:20:18 <ElSuperDragon> what does Debby?
21:20:21 <SamB_XP> "Debby Does Snakes On a Plane?"
21:20:34 <sproingie> win
21:21:13 <iaefai> sproingie: Check out enterprise cobol on that page
21:21:16 <sproingie> >> Nil is the world's first Nihilistic programming language. Essentially, it parses commands of any complexity, and then ignores them.
21:21:39 <SamB_XP> hehehe
21:22:05 <ElSuperDragon> can haskell do Object-Oriented processing?
21:22:19 <ivanm> ElSuperDragon: there's OOHaskell...
21:22:29 <ivanm> ElSuperDragon: but it's basically a different programming paradigm
21:22:30 <SamB_XP> ElSuperDragon: only if you can figure out what that means ?
21:22:40 <ivanm> and most of us are glad that it can't! ;-)
21:22:49 <iaefai> member:identifier:elsuperdragon: realistically - yes, because even C can
21:24:50 <ElSuperDragon> more inheritance and lesser code
21:25:41 <iaefai> "Broadly speaking, there are two major branches of programming: "functional programming" and http://uncyclopedia.wikia.com/wiki/Object_Oriented_Programming, or "non-functional programming." Generally, functional programming is used by software engineers to write short, effective programs for internal use, whereas non-functional programming is used for large projects involving a non-technical
21:25:41 <iaefai> http://uncyclopedia.wikia.com/index.php?title=End_user&action=edit&redlink=1."
21:25:42 <dibblego> those two are in contention
21:25:53 <iaefai> lesser code?
21:26:56 <iaefai> I am also not sure why inhereitance is required
21:56:37 <sshc_> how do I compile a 32-bit binary with GHC on a 64-bit machine?
21:57:11 <ivanm> by using a 32bit bootstrapping GHC and a 32bit gcc? *shrug*
21:57:37 <iaefai> sshc_: Are you running snow leopard by chance?
21:58:08 <sshc_> iaefai, no
22:06:31 <luite> hmm, what does this mean, when starting ghci with an extra object file (with a foreign function)?  Unknown PEi386 section name `/22' (while processing: Lp\lp.o)    Loading object (static) Lp\lp.o ... : panic! (the 'impossible' happened)
22:06:39 <kmc> sshc_, the massive-overkill solution is to use a 32-bit chroot
23:12:53 <performance> is there a way to find out which functions/Types exported by FileManip are actually used in HStringTemplateHelpers?
23:13:23 <Saizan_> no automated way
23:13:41 <Saizan_> it'd be quite useful though
23:14:25 <hackagebot> filestore 0.3.2.1 - Interface for versioning file stores. (JohnMacFarlane)
23:14:56 <performance> yeah, im trying to get happs-tutorial to cabal install on my vista machine, and it fails because of a dependency on unix
23:28:15 <ivanm> heya Axman6
23:29:21 <Axman6> o/
23:29:27 <Axman6> not around for long
23:40:09 <c_wraith> Axman6:  were you the one asking about Network last night?  I remember talking to someone about it, but I can't recall who. >_>
23:42:08 <ivanm> wasn't me...
23:42:48 <c_wraith> No, you seem like you'd already know how to use network
23:43:33 <crash[`]> newb alert :) I'm trying to write a reverse function avoiding builtins as much as possible, (code http://pastebin.com/m530552ef) but I get the following error in GHCi: "Occurs check: cannot construct the infinite type a = [a]. When generalizing the types for `myReverse`
23:43:58 <c_wraith> crash[`]: that usually means you used : when you meant ++, or vice-versa
23:44:09 <crash[`]> gotcha, thank you :)
23:44:16 <c_wraith> crash[`]:  For efficiency, you should be able to do it entirely with :
23:44:29 <Peaker> crash[`], usually its because some expression is type-inferred to mean [a] and a both at the same time, and that's impossible
23:45:37 <crash[`]> alright, thanks :)
23:46:08 <Tordek> hi
23:46:39 <Tordek> can I get rid of this lambda?
23:46:40 <Tordek> read_people :: String -> IO [Person]
23:46:40 <Tordek> read_people file = readFile file >>= \x -> return $ read x
23:48:14 <Saizan_> Tordek: readFile file >>= return . head
23:48:29 <Tordek> head?
23:48:37 <crash[`]> I'm sure you mean read :P
23:48:38 <Saizan_> s/head/read/
23:48:42 <Tordek> :P
23:48:44 <Tordek> thanks
23:48:56 <Saizan_> ?pl readFile file >>= return . head
23:48:56 <lambdabot> head `fmap` readFile file
23:49:18 <Tordek> again with the head ;P
23:49:29 <crash[`]> ?pl readFile file >>= return . read
23:49:29 <lambdabot> read `fmap` readFile file
23:49:32 <crash[`]> ;P
23:49:34 <Tordek> also, "?pl"?
23:49:35 <Saizan_> yeah, i'm lazy like that
23:49:42 <Saizan_> it doesn't matter anyway
23:49:48 <crash[`]> Tordek: pointless! (takes code and outputs a pointfree style variation)
23:50:02 <crash[`]> Avoids explicitly naming parameters when you can just take advantage of currying
23:50:18 <crash[`]> Can give you some pretty cool refactorings, also some pretty wacky ones
23:50:41 <c_wraith> @pl \a b c d e f g -> e f g a b c
23:50:41 <lambdabot> (((const .) . flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip (flip . (flip .))
23:50:43 <Tordek> I know pointfree; I was asking about the comand :P
23:51:00 <crash[`]> Tordek: then in that case, it stands for pointless, a jab at how unimportant pointfree style can be
23:51:01 <Tordek> that's a lot of points for pointfree :P
23:52:17 <Saizan_> m >>= return . f = liftM f m = fmap f m = f <$> m = return f `ap` m = pure f <*> m
23:52:25 <Saizan_> = liftA f m
23:52:55 <Saizan_> assuming there are sufficient instances
23:53:26 <Tordek> I'm doing an experiment... lurning Haskell from http://lisperati.com/haskell/ht3.html, but "properly"
23:53:52 <Tordek> (ie, data instead of type, and using typeclasses and pretty things like that)
23:54:19 <c_wraith> meh.  data instead of type rarely is proper. :
23:54:32 <Tordek> care to expand?
23:54:46 <c_wraith> From the project I'm doing for fun...
23:55:07 <c_wraith> type GameM a = ExceptionalT GameError (RWS GameEnv Log.Logger GameState) a
23:55:15 <c_wraith> You can't do that with a data declaration.
23:55:26 <c_wraith> Well...  You could.  If you wanted to add a TON of instances.
23:55:38 <Saizan_> newtype works, though
23:56:04 <c_wraith> With GeneralizedNewtypeDeriving, anyway
23:56:49 <iaefai> I am getting this error I am not sure of with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11104#a11104 The error is on line 42, the *  are throwing me for a loop too.  `Row' is not applied to enough type arguments   Expected kind `*', but `Row' has kind `* -> *' In the instance declaration for `NiceLook (Row)'
23:57:29 <Saizan_> iaefai: remove the 'a' from the data Row a = .. declaration, perhaps?
23:57:44 <Saizan_> iaefai: or do you have a reason for it?
23:57:51 <iaefai> no reason
23:57:59 <iaefai> I may not even know what it does in that context
23:58:05 <Saizan_> heh
23:58:32 <Saizan_> it's a type parameter, like for e.g. Maybe
23:59:23 <iaefai> That would be Maybe a = Nothing | Just a ?
23:59:27 <Saizan_> right
23:59:54 <iaefai> Another error now appears, it is definitely related to my attempted use of views. I am not sure how this is supposed to be used if it cannot be used like this.    http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11105#a11105
23:59:55 <Saizan_> so you've values of type "Maybe Int" or "Maybe Bool"
