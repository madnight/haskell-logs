00:00:07 <stanv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10993#a10993
00:02:44 <blackh> stanv: You haven't said anywhere what you want 'b' to be so it is just 'b' - and 'b' doesn't match (a,x)
00:05:07 <stanv> blackh: 'b' - is any type
00:05:41 <stanv> doesn't ?
00:05:44 <Berengal> stanv, and (a, x) isn't any type, it's a tuple
00:06:09 <blackh> stanv: No - unless you bind b to something (somehow) it stays as 'b' and won't match anything.
00:06:15 <shambler> juturnas, for example, you can have 2 threads -- the one is for reading data from sockets, and another is for updating server. The second one unlocks every T (=1/4) seconds and updates server state.
00:06:20 <Berengal> stanv, the problem is that not only can 'b' be any type, but you've said that it _has_ to be any type.
00:07:05 <blackh> stanv: You need to say in the class declaration how you want it to decide what b should be.
00:07:11 <juturnas> are the functions necessary for the timing stuff in the Control.Concurrent module?
00:07:15 <shambler> and you can lock second thread with sleep or sleep+semaphore
00:08:19 <juturnas> k, thanks
00:09:17 <stanv> Berengal,blackh : thanks
00:15:05 <stanv> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10995#a10995
00:17:43 <blackh> stanv: I think you want to use a functional dependency or a type family.
00:18:12 <blackh> Do you want foo to always return Int when used on a MyType?
00:20:38 <stanv> I can't understand. What I can in deed return as 'b' ?
00:22:35 <blackh> stanv: Without adding something to the 'class' declaration, you can't return anything as b.
00:22:57 <Saizan> only undefined
00:23:15 <stoop> only error
00:23:56 <stanv> Give me please example :)
00:24:03 <Saizan> stanv: a type signature like "MyType a -> b" means that the caller can choose any type it wants to substitute for 'a' and 'b'
00:24:10 <blackh> stanv: OK .. I'm writing you one...
00:24:43 <Saizan> stanv: so the body of the function doesn't have the freedom to choose, it must work for any type
00:24:50 <stoop> It'll only end up giving you the _|_.
00:25:01 <Saizan> ?type undefined
00:25:02 <lambdabot> forall a. a
00:25:14 <stoop> ?type error
00:25:15 <lambdabot> forall a. [Char] -> a
00:26:26 <stoop> stanv, http://haskell.org/onlinereport/exps.html#basic-errors
00:26:58 <blackh> stanv: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10995#a10996
00:27:03 <Saizan> error is not particulary relevant here, the point is that the signature is wrong fro what stanv wants to do
00:27:17 <stoop> Saizan, you're correct.
00:27:55 <stoop> stanv, you might also want to look at http://haskell.org/onlinereport/decls.html
00:28:48 <stoop> Saizan, I was too lazy to tell him about the role of _|_.
00:42:08 <coolguy4> I'm trying to compile cabal. runhaskell Setup.hs configure worked, but when I try to install I get "Setup.hs: Error: Could not find module: Distribution.Compiler with any suffix:["hi"]"
00:42:48 <c_wraith> coolguy4:  have you tried using the bootstrap.sh script?
00:43:05 <Saizan> that seems like he's trying to build Cabal the library
00:43:15 <c_wraith> oh
00:43:21 <coolguy4> c_wraith: how do I do that?
00:43:51 <Saizan> coolguy4: i think you missed the build step.
00:44:43 <Saizan> the usual is "runghc Setup configure && runghc Setup build && sudo runghc Setup install"
00:45:12 <coolguy4> Saizen: Ahh! so it's runhaskell <file> configure; runhaskell <file> build; runhaskell <file> install.
00:45:42 <Saizan> bootstrap.sh is the one used in the package cabal-install, to ease the installation of the extra dependencies
00:46:05 <c_wraith> yeah, I was trying to solve the wrong problem.
00:46:40 <Saizan> btw, the package with the "cabal" executable is "cabal-install" not "Cabal", though an up to date Cabal library is needed to install an up to date cabal-install
01:02:45 <stanv> 11:22 < blackh> stanv: Without adding something to the 'class' declaration, you can't return anything as b.  I added (Num b => ) but same result: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10997#a10997
01:02:58 <FunctorSalad> am I going crazy or is this a Monad instance for Set? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10998#a10998
01:04:02 <FunctorSalad> (you need Ord to run the whole thing of course)
01:09:23 <FunctorSalad> (but having a Monad instance is nice to be able to use functions requiring it)
01:13:35 <sinelaw> FunctorSalad, trying to understand. your set is parameterized over functions that create Sets?
01:15:09 <FunctorSalad> sinelaw: a (Set a) is encoded as it's hypothetical bind function
01:15:25 <FunctorSalad> which would have exactly that type in Set'
01:15:57 <sinelaw> FunctorSalad what's a bind function?
01:18:12 <FunctorSalad> sinelaw: (>>=)
01:18:19 <sinelaw> h
01:18:21 <sinelaw> ah
01:19:11 <FunctorSalad> cleaned it up a bit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11001#a11001
01:22:50 <Saizan> stanv: again, when you've a type variable like that the body of the function can't decide to use a specific concrete type, it has to return something polymorphic
01:23:10 <mreh> I have such a hard time deciphering Juurgen's English
01:23:12 <mreh> This is a problem with the version of an installed gtk lib. gtk2hs does
01:23:12 <mreh> conditional compilation,
01:23:12 <mreh> and adds some procedures, when a specific version of the lib is present.
01:23:12 <mreh> You have to install gtksourceview2 in a version > 2.4.0.
01:23:19 <Saizan> stanv: in this specific case you could use fromIntegral y
01:23:39 <mreh> does anyone know which GTKlib he is talking about? Or am I completely missing the point
01:23:48 <Saizan> stanv: though maybe you want Test to be a multiparameter typeclass
01:24:23 <Saizan> mreh: the C ones
01:24:33 <mreh> all of them?
01:24:58 <Saizan> "an installed gtk lib", so one of them, specifically gtksourceview2
01:25:20 <mreh> gtksourceview2 is a package inside of gtk2hs
01:25:26 <mreh> and a C lib?
01:25:48 <Saizan> it's referring to the C lib in that sentence, i think
01:26:21 <mreh> curse you god! It's only 2.2.2 with Debian
01:27:11 <Saizan> heh, i've 2.6.2 here
01:27:30 <mreh> how?
01:27:51 <Saizan> i'm on archlinux
01:28:12 <mreh> maybe I can backport
01:34:07 <notsmack> I'm more convinced I've found a bug in the http package now...
01:35:33 <notsmack> Network.TCP.isTCPConnectedTo calls Network.Socket.sIsConnected, which checks if the socket status is "Connected", but I believe it's actually "ConvertedToHandle" any time you have a HandleStream
01:36:18 <notsmack> so isTCPConnectedTo always returns False?
01:40:24 <Saizan> FunctorSalad: well, it's not exactly a monad intance for Set but for Codensity Set, the difference is that since all the >>= get reassociated to the right you never prune out duplicates until the end
01:43:11 <Saizan> so even if you write (makeSet (fromList [1..3]) >> return 1) >>= \x -> return (x+1), the addition is performed 3 times
01:45:14 <FunctorSalad> Saizan: ah right, that was the word :)
01:45:24 <Saizan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11001#a11002
01:48:19 <FunctorSalad> Saizan: I find it hard to think about how it is executing
01:49:57 <FunctorSalad> (I just matched the types ;)))
01:49:57 <Saizan> basically it's using the associativity law of monads to fuse calls to >>=
01:50:36 <Saizan> (m >>= f) >>= g = m >>= (\x -> f x >>= g)
01:50:57 <FunctorSalad> I'm puzzled why I could write (>>=) without any set-specific operations
01:51:30 <FunctorSalad> yes
01:52:20 <FunctorSalad> couldn't this thing still be useful for situation where you want to use some interface requiring (Monad m)?
01:52:26 <FunctorSalad> *situations
01:54:06 <Saizan> it might, it won't differ much from using the [] monad and add a fromList at the end, i think
01:54:17 <Saizan> though you'd avoid that intermediate list
01:54:48 <Saizan> and Codensity [] can be faster than [] in some situations
01:55:56 <FunctorSalad> where can I learn more about Codensities (especially how they made up that name ;))
01:55:58 <FunctorSalad> ?
01:56:18 <Saizan> edwardk's blog should have more
01:56:52 <Saizan> also sigfpe post titled something like "Cont is the mother of all monads"
01:57:35 <FunctorSalad> ah yes, think I've seen the latter
01:58:44 <FunctorSalad> admittedly it makes sense that it doesn't prune intermediate duplicates... the intermediate types may not have Ord after all
01:59:10 <Saizan> yeah
01:59:11 <FunctorSalad> I suppose you could write a function prune :: Ord a => Set' a -> Set' a
01:59:26 <FunctorSalad> (makeSet' . runSet' ?)
01:59:32 <Saizan> right
02:00:23 <FunctorSalad> (though there's probably a faster way than unioning all these singletons :))
02:00:32 <Saizan> this is really similar to the "tagless final interpreters" technique
02:01:34 <Saizan> amd that prune is kind of going into a concrete free structure and then transform it into the polymorphic value again
02:02:55 <Cyneox> hi there!i'm using hugs.. how can i declare a variable in the console?
02:03:01 <Cyneox> Main> x = 3
02:03:01 <Cyneox> ERROR - Syntax error in input (unexpected `=')
02:03:13 <Saizan> you can't
02:03:15 <Cyneox> ahh ok
02:03:27 <Cyneox> so i have to write that into some file ?
02:03:41 <Saizan> you can write e.g. let x = 3 in x
02:03:46 <Saizan> or use a file, yeah
02:04:02 * Axman6 rages at sockets!
02:04:19 <Cyneox> Main> let z = 88 in z
02:04:19 <Cyneox> 88 :: Integer
02:04:19 <Cyneox> {{Gc:986195}}Main> z
02:04:19 <Cyneox> ERROR - Undefined variable "z"
02:04:19 <Cyneox> Main>
02:04:34 <Cyneox> why can't i use the variable z ?
02:04:36 <Axman6> no, let z = 88
02:04:38 <Axman6> no in
02:04:46 <Saizan> Axman6: that doesn't work in hugs, afaik
02:04:49 <Cyneox> i get syntax error
02:04:53 <Cyneox> Saizan: right
02:05:01 <Axman6> "let x = y" is sort of saying "let x = y from now on"
02:05:06 <Saizan> Cyneox: the 'z' is defined only for the scope of that expression
02:05:09 <Axman6> oh, well hugs--
02:05:14 <Axman6> Cyneox: use ghci
02:05:16 <Saizan> Cyneox: you can't use it later
02:05:39 <Cyneox> Saizan: i'M using netbsd/amd64.. there is no port for 64bit architectures..
02:06:15 <Saizan> that was for Axman6 i guess :)
02:06:26 <Axman6> indeed
02:06:37 <Cyneox> oops :D
02:07:27 <Cyneox> thank you anyway..
02:08:20 <Saizan> np
02:16:07 <mlesniak> Anyone know how I can express "instance Queue (Chan c) where ..." in a way that satisfies GHC? (Context: I want to play with different queues and want a type class for them)
02:16:27 <ivanm> mlesniak: what error does it give?
02:16:47 <ivanm> mlesniak: normally the error tells you if there's any applicable extensions you can provide
02:16:57 <ivanm> s/provide/apply/
02:18:43 <mlesniak> ivanm, in this case no :-| I'll use hpaste for a minimal non-working example :D
02:18:56 <Saizan> provide the definition of the class too :)
02:19:03 <mlesniak> :D
02:19:44 <Saizan> it doesn't have to be stripped down, sometimes it's easier to help if you don't hide the high-level goal
02:19:55 <ivanm> Saizan: unless it's 500 lines long ;-)
02:20:19 <mlesniak> Saizan, Well, currently I just define types ;)
02:20:44 <ivanm> mlesniak: what's the actual error you're getting?
02:20:57 <ivanm> the only thing I can think of off the top of my head is that you have to specify a constraint on c
02:22:14 <mlesniak> ivanm, I'll post the error, too.
02:24:13 <mlesniak> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4442#a4442
02:24:46 <mlesniak> I'm pretty sure I have to say sth about b in Queue
02:24:52 <mlesniak> But what?
02:25:04 <ivanm> monomorphism restriction?
02:25:09 <ivanm> mlesniak: oh, yeah
02:25:23 <ivanm> mlesniak: there's no magic/obvious way of specifying what b is by the looks of things
02:25:37 <ivanm> mlesniak: either fundeps, or type families
02:25:57 <mlesniak> ivanm, hmm, don't know either, going to learn about them then!
02:26:00 <ivanm> type families look nicer IMHO; but haddock can't deal with them yet, they're more experimental and might not be as efficient IIRC
02:26:16 <ivanm> mlesniak: either one will need at least 2 extensions IIRC
02:26:17 <mlesniak> In what case efficient?
02:26:49 <mlesniak> ivanm, any other design possiblities for this problem beside having a general Queue-class?
02:26:53 <ivanm> mlesniak: I think I've read something saying that type families might not be as efficient (runtime wise I think) because they're newer and hence haven't had as much work done on them
02:27:08 <Saizan> mlesniak: another approach http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4442#a4443
02:27:09 <ivanm> mlesniak: any reason for having a queue class rather than using functions on Chan directly?
02:27:10 <mlesniak> ivanm, sounds reasonable, ok.
02:27:37 <mlesniak> ivanm, yes, I want to play with different, exchangable queue implementations
02:27:45 <ivanm> mlesniak: yeah, Saizan's way is probably better
02:28:07 * ivanm went for the most difficult solution to start with... >_>
02:28:12 <mlesniak> :D
02:28:36 <Saizan> that Queue class is more restrictive than what you'd get with fundeps or type families, because any instance of Queue must be able to hold elements of any type
02:29:23 <mlesniak> Saizan, Hmmm, could be a problem in the future but should work for now.
02:30:19 <mlesniak> ivanm, Saizan, Thanks!
02:30:38 * Axman6 FFFFFFFFFFFUUUUUUUUUUUUUUU
02:30:50 <Saizan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4442#a4444 <- how fundeps and type families would look
02:31:41 * Axman6 pokes ivanm in the eye friendlily
02:31:57 * mlesniak wonders if poking can be done friendly
02:32:14 <Axman6> especially in the eye
02:32:18 <mlesniak> Saizan, nice, will keep this as a reference for the future
02:33:25 <fasta> Peeking can.
02:33:36 <Axman6> god damn. socket programming is a a load of crap >_<
02:33:54 <fasta> Have you ever looked at the D FFI?
02:34:06 <bauchus> hi! `cabal install ... parsec' installs parsec 2.1.0.1 instead of 3.0.1. Why?
02:34:17 <ksf> because it's the default
02:34:22 <fasta> bauchus: because that has been marked as the "default".
02:34:22 <Saizan> bauchus: because that's the stable version
02:34:37 <ksf> ...presumably because many packages are broken and don't provide an upper bound in their dependency.
02:34:40 <Saizan> bauchus: use cabal install "parsec >= 3" if you want the other
02:34:55 <bauchus> thanks!
02:35:25 <Saizan> parsec3 is generally a drop-in replacement, though it often has worse performance too
02:35:54 <ksf> more imporntantly, it comes with an uncons class.
02:36:01 <ksf> uu-parsinglib too, iirc.
02:36:15 <fasta> parsec2 doesn't have a transformer version, right?
02:36:19 <Raevel> "drop-in replacement"?
02:36:37 <Saizan> fasta: right
02:36:40 <ksf> parsec 3 comes with a parsec 2 compatiblity api
02:36:53 <bauchus> because of the transformer version, it can be used with bytestring, i guess
02:37:17 <Saizan> you can use bytestring because of the Stream class
02:38:13 <fasta> I use parsec3 to parse ridiculously simple stuff. Simply, because it is easy to read. It will get faster over time.
02:38:45 <Saizan> yeah, that's the idea :)
02:40:27 <bauchus> i used parsec2 in the past. should i read something, what is new in parsec 3.0 or should start with my parser an let me guide by the compiler error messages?
02:40:49 <fasta> bauchus: for all the basic stuff it is the same at least.
02:40:58 <shambler> @where SICP
02:40:58 <lambdabot> http://mitpress.mit.edu/sicp/
02:41:12 <fasta> bauchus: I don't know whether any advanced stuff is different, mostly because I don't need it.
02:41:29 <bauchus> ok
02:41:41 <MyCatVerbs> I can think of at least one bug which Parsec 3 now doesn't have, but Parsec 2 did. :)
02:41:47 * ivanm fires a bazooka at Axman6 friendlily
02:44:36 <bauchus> hm, unfortunately HDBC-postgresql uses parsec-2.1.0.1 :-( => " This is highly likely to cause a compile failure". Reinstallation (with cabal) doesn't resolve the problem.
02:45:05 <dcoutts> in this case it's probably not going to cause a compile failure
02:45:50 <ksf> things get ugly if you try to share types between modules, but hdbc shouldn't export any of parsec's.
02:46:13 <bauchus> well then, I'll start with parsec3.
02:46:18 <Saizan> you should also be able to recompile HDBC-postgresql using parsec 3 if you add a --constraint="parsec >= 3"
02:49:04 <fasta> Anyway, regarding the D FFI, it seems to be at about the same level of abstraction as Haskell, almost as if the author has a copy of the Haskell FFI under his pillow.
02:49:48 <bauchus> Saizan: yepp, it works. Thanks
03:22:27 <sinelaw> Hey,
03:22:32 <sinelaw> can someone explain what's the point in this?
03:22:32 <sinelaw> data ListFunctor f a = Nil | Cons a (f a)
03:23:45 <fasta> sinelaw: why would there be a point?
03:24:55 <sinelaw> it's given as an example for higher-kinded types
03:25:29 <sinelaw> fasta, but i don't see what this example is useful for
03:26:05 <Saizan> that can be used together with a typelevel fixpoint to get back the standard list type, and a bunch of recursion combinators defined for free
03:26:29 <fasta> sinelaw: lots of higher-kinded stuff is so abstract that it becomes relatively pointless from a practical point of view.
03:26:58 <fasta> sinelaw: that said, I do use higher-kinded stuff, but mostly to factor out stuff.
03:27:01 <sinelaw> isn't the only fixpoint ListFunctor itself?
03:27:03 <Saizan> a more common example of higher-kinded arguments is monad transformer
03:27:18 <Saizan> no ListFunctor is not recursive
03:27:32 <fasta> sinelaw: it's not that I think one day: oh, let's make this super complicated data type just for no reason.
03:28:11 <Saizan> yeah, arguments are in general to abtract stuff away :)
03:28:17 <Saizan> even function arguments
03:28:30 <fasta> sinelaw: so, in short, just write programs, read how for example xmonad works (it's a good example), and it will all be ok. Reading a few books on Haskell also would help.  Just don't get stuck.
03:28:31 <Saizan> (value level functions, i mean)
03:29:12 <fasta> How much of a nightmare is Haskell on Windows these days/
03:29:13 <fasta> ?
03:29:20 <fasta> Windows Vista to be precise?
03:29:34 <sinelaw> ok, i'm just trying to see why this is "ocassionaly very useful" as this paper says
03:29:47 <sinelaw> fasta, i just installed the haskell platform
03:29:54 <fasta> sinelaw: papers on functional programming are often useless, unless written by implementors.
03:30:03 <Saizan> sinelaw: check out monad transformers then
03:30:22 <sinelaw> fasta, well this one is by Hudak, Hughes, SPJ, and Wadler :)
03:30:29 <fasta> sinelaw: title.
03:30:33 <sinelaw> you probably know it...
03:30:33 <SamB_XP> fasta: you don't ever decide to make a super-complicated datatype for no reason :-(
03:30:34 <fasta> sinelaw: ?
03:30:34 <sinelaw> A History of Haskell:
03:30:34 <sinelaw> Being LazyWith Class
03:30:36 <SamB_XP> it's just me?
03:31:05 <sinelaw> really nice paper
03:31:32 <fasta> I don't think I read the _whole_ paper.
03:31:33 <sinelaw> accompanied by a video lecture that SPJ gave about this at the history of programming languages conference
03:33:04 <sinelaw> http://portal.acm.org/citation.cfm?id=1238856&dl=GUIDE&coll=GUIDE&CFID=57390487&CFTOKEN=50896203
03:39:18 <osfameron> @pl (\(w,a) (_,b) -> (w,a+b))
03:39:19 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (+)) . (.) . (,))
03:39:22 <osfameron> eeeek!
03:39:29 <osfameron> I thought there would be something super-elegant with arrows...
03:39:58 <osfameron> like  const `mumble` (+)
03:40:23 <sinelaw> pl doesn't know arrows, i think
03:40:28 <osfameron> ah
03:40:32 <osfameron> me neither, tbh
03:40:43 <osfameron> I looked at the wiki "tutorial" and it scared me :-)
03:41:23 <sinelaw> try this, it's not exactly about arrows but it gives an intuitive explanation:
03:41:24 <osfameron> but using &&& and such to work with (foo,bar) tuples is handy.  I think I want a practical cookbook rather than something that tries to *explain* them ;-)
03:41:29 <aavogt> @type fmap ($) . uncurry (flip const)
03:41:31 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a1, f (a -> b)) -> f (a -> b)
03:41:36 <sinelaw> http://haskell.cs.yale.edu/yale/papers/haskell-workshop03/yampa-arcade.pdf
03:42:20 <osfameron> thanks - istr I tried to read that a year or so ago and failed... I need to set aside some time to concentrate and read it
03:42:37 <Saizan> ?type fmap . (+) . snd
03:42:38 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Num a) => (a1, a) -> f a -> f a
03:43:04 <Saizan> ?type flip $ fmap . (+) . snd
03:43:05 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num b) => f b -> (a, b) -> f b
03:43:23 <Saizan> that's it :)
03:43:43 <Saizan> s/fmap/second/ if you prefer
03:43:46 <osfameron> doesn't that lose the fst ?
03:44:05 <Saizan> your lambda loses the fst of the second tuple too
03:44:33 <aavogt> @type  (\(w,a) (_,b) -> (w,a+b))
03:44:33 <osfameron> yes, because I know it's the same (having groupBy'd on it previously)
03:44:34 <lambdabot> forall t t1 t2. (Num t1) => (t, t1) -> (t2, t1) -> (t, t1)
03:45:13 <osfameron> (flip $ fmap . (+) . snd) ('a', 1) ('a', 2)
03:45:16 <osfameron> > (flip $ fmap . (+) . snd) ('a', 1) ('a', 2)
03:45:18 <lambdabot>   ('a',3)
03:45:29 <osfameron> ooo
03:45:46 <osfameron> the type looks like it loses the tuple at the end...
03:46:02 <Saizan> the 'f' is "(,) Char" here
03:46:05 <osfameron> actually, I don't understand the type at all
03:47:17 <Saizan> "f b -> (a, b) -> f b" after substituting f = (,) Char becomes "(Char,b) -> (a,b) -> (Char,b)"
03:47:58 <osfameron> how do you know to substitute (,) Char ?
03:48:59 <Saizan> i forgot a passage, you get (,) Char b -> (a,b) -> (,) Char b, which then you prettyprint in what i wrote
03:49:14 <Saizan> the substitution happens automatically, as always
03:49:25 <osfameron> yeah I was fine with the last part... just not why you'd assume it in the first place
03:49:55 <Saizan> assume?
03:50:00 <aavogt> @type (flip $ second . (+) . snd)
03:50:02 <lambdabot> forall d a b. (Num b) => (d, b) -> (a, b) -> (d, b)
03:50:03 <osfameron> I mean, where does (,) Char come from?
03:50:27 <Saizan> well, from your use there
03:50:42 <Saizan> you applied to tuples of type (Char,Integer)
03:51:18 <osfameron> >t second
03:51:23 <osfameron> :t second
03:51:24 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
03:51:40 <sinelaw> > second (+2) (1,1)
03:51:41 <lambdabot>   (1,3)
03:51:53 <Saizan> ?type second . (+) . snd
03:51:54 <lambdabot> forall c d a. (Num c) => (a, c) -> (d, c) -> (d, c)
03:52:17 <Saizan> it gives a less general type :)
03:52:21 <osfameron> ah, that makes (a bit) more sense
03:52:55 <osfameron> thanks!
03:52:57 <sinelaw> > second . (+) . snd (5,5) (1,1)
03:52:58 <lambdabot>   Ambiguous type variable `t' in the constraint:
03:52:58 <lambdabot>    `GHC.Num.Num t' arising f...
03:53:02 <sinelaw> > second . (+) . snd $ (5,5) (1,1)
03:53:03 <lambdabot>   Couldn't match expected type `t -> (a, b)'
03:53:03 <lambdabot>         against inferred type `(...
03:53:09 <Saizan> you should be able to read the former signature too :P
03:53:19 <osfameron> former?
03:53:23 <osfameron> the fmap one?
03:53:26 <Saizan> yes
03:53:33 <osfameron> ah, not at all, tbh
03:53:54 <Saizan> sinelaw: you can't use $ that way
03:53:55 <sinelaw> > (second . (+) . snd ) (5,5) (1,1)
03:53:56 <lambdabot>   (1,6)
03:54:10 <sinelaw> Saizan so how can i avoid the parens?
03:54:37 * osfameron should read up on functors, I think typeclassopedia is my next haskell reading list when I get time to sit down and concentrate..
03:54:38 <Saizan> there's no way currently
03:54:55 * paolino also wants to avoid parents
03:55:24 <sinelaw> Schemers must think we're sissies
03:56:41 <Saizan> > let infixl $ 0; f $ x = f x in second . (+) . snd $ (5,5) $ (1,1)
03:56:42 <lambdabot>   <no location info>: parse error on input `0'
03:56:51 <Saizan> > let infixl 0 $; f $ x = f x in second . (+) . snd $ (5,5) $ (1,1)
03:56:53 <lambdabot>   (1,6)
03:57:47 <sinelaw> what's the default level of $?
03:57:57 <Saizan> infixr 0
03:58:09 <sinelaw> ah.
03:58:19 <sinelaw> why does that make sense
03:58:32 <sinelaw> well i can see why.
04:00:05 <Saizan> f $ g $ x means f (g x) if $ is infixr, and f g x if infixl
04:01:21 <Saizan> the former can be rewritten as f . g $ x, but there's no solution fo the latter, when f, g or x are compound expressions
04:01:48 <sinelaw> yah. maybe we need another one which is infixl
04:02:35 <Saizan> if you can find a symbol that's not taken :)
04:02:48 <Saizan> we should start going unicode, maybe
04:04:02 <osfameron> CompSci textbooks pretend haskell already is...
04:05:04 <Saizan> well, you can use unicode symbols already, noone does because it's not that easy to type them i guess
04:05:20 <fasta> What do you use for scripting on Windows? I only want to bootstrap a Haskell environment completely automatically, basically, if it doesn't take too much time.
04:05:43 <sinelaw> fasta, using the haskell platform installer does that for you, no?
04:06:01 <fasta> sinelaw, well, you still have to go to a webpage with a webbrowser for no reason.
04:06:11 <fasta> sinelaw, you also have to click next, next etc.
04:06:44 <aavogt> maybe the installer has a mode to just go
04:06:47 <stanv> I can't understand polymorphism :(
04:06:56 <aavogt> and if it doesn't then maybe that feature should be added
04:07:08 <osfameron> fasta: I would probably either use native cmd.exe, perl, or vbscript... but I guess if I was playing with windows nowadays I'd try powershell
04:07:35 <sinelaw> i would use python, but it makes more sense for the installer to allow an "auto" mode
04:07:50 <fasta> powershell is not available by default.
04:07:59 <osfameron> really?  still?
04:08:02 <osfameron> that's pretty silly
04:08:21 <fasta> You can download it, but the whole idea is to start from an empty Windows.
04:08:21 <osfameron> powershell is such a good idea I'm amazed that people don't squee about it far more
04:08:34 <osfameron> then again I've not *used* it... maybe the implementation sucks?
04:08:34 <oteren> screw powershall
04:08:39 <oteren> .bat for life yo!
04:08:53 <sinelaw> fasta: got it!
04:08:56 <fasta> Does anyone know how wget is spelt on Windows?
04:08:56 <sinelaw> run the installer with /S
04:09:11 <sinelaw> documented here: http://nsis.sourceforge.net/Docs/Chapter3.html#3.2.1
04:09:15 <fasta> sinelaw, thanks, but still the downloading of the installer has to be done, then.
04:09:36 <sinelaw> fasta, well any solution will involve downloading / distributing stuff to that computer
04:09:37 <osfameron> fasta: http://gnuwin32.sourceforge.net/packages/wget.htm ?
04:09:47 <osfameron> though maybe you already have curl installed?
04:09:48 <Saizan> i doubt there's a wget by default on windows
04:09:58 <fasta> osfameron, the problem is that you still have to install wget then.
04:10:14 <fasta> Some kind of InternetExplorerObject.download(blaat)
04:10:15 <osfameron> windows in useless-out-of-the-box shocker
04:10:57 <osfameron> fasta: well, bundle it yourself ?
04:11:04 <SamB_XP> osfameron: at least it comes with VBScript/JScript scriptability out-of-the box now ...
04:11:23 <osfameron> that's true... that's one of the reasons I used to use vbs back in the day :-)
04:11:25 <oteren> shouldnt vbscript be able to fetch something from an url?
04:11:33 <oteren> (never used it)
04:11:34 <fasta> osfameron, yes, that's one possibility.
04:11:43 <aavogt> well, how do you get the script to the install?
04:11:45 <fasta> osfameron, not one I like, though ;)
04:12:01 <aavogt> to the fresh install
04:12:03 <SamB_XP> oteren: it is indeed possible, though you may well have to use IE
04:12:05 <oteren> aavogt: there are only two issues, fetch file, run install, from this: http://nsis.sourceforge.net/Docs/Chapter4.html#4.12 that can be done via system calls
04:12:08 <SamB_XP> or, at least, part of IE
04:12:23 <oteren> SamB_XP: that sounds like it cant be down silently
04:12:29 <SamB_XP> but then that part of IE is a critical system component anyway since, like, 98 ...
04:12:33 <oteren> even so, its better than next next next next download next next
04:12:33 <oteren> :p
04:12:48 <SamB_XP> oteren: I meant, you'd probably have to use the COM interfaces provided by IE
04:12:53 <oteren> aha
04:12:56 <osfameron> fasta: why do you need to automate the install?  if you're trying to get a sane setup on a windows machine, presumably you'll want some kind of toolchain too (text editor, make, some posix utilities) anyway, so why are you limiting yourself to a vanilla Windows install?
04:13:22 <SamB_XP> or at least by shdocvw
04:13:35 <oteren> one possibility is to make a windows domain package(?)
04:13:44 <SamB_XP> oteren: what's that ?
04:14:11 <fasta> osfameron, just to make the transition to Haskell easy.
04:14:22 <oteren> i'm not sure myself, dont know too much about distributed systems, but i can recall reading somewhere that packaged stuff thats distributed for larger domain setups can be single-installed as well
04:14:36 <oteren> "managed software" i believe its called in windows
04:14:46 <SamB_XP> I believe the newest Windows release includes Powershell
04:15:34 <oteren> http://blogs.msdn.com/powershell/archive/2008/10/28/powershell-will-be-installed-by-default-on-windows-server-08-r2-ws08r2-and-windows-7-w7.aspx
04:15:41 <oteren> i believe your are correct
04:15:43 <SamB_XP> maybe NSIS or Windows Installer would be of help ?
04:15:43 <fasta> Windows 7 was considered too new.
04:15:59 <SamB_XP> yes, I realize that doesn't help *now*(
04:16:19 <oteren> ey
04:16:21 <oteren> windows installer
04:16:30 <oteren> that was what i was trying to describe SamB_XP :P
04:30:32 <Quadrescence> Way to copy Scheme with the topic, people.
04:31:46 <benmachine> To copy topic scheme, with the way people.
04:34:13 <FunctorSalad> ?
04:34:18 <winuser> ?
04:35:10 <Quadrescence> FunctorSalad: I haven't seen you around (not-)math
04:35:20 <shambler> ben is pretty cool guy
04:35:24 <Quadrescence> Where did you go? You were (probably are still) a p. cool guy
04:35:27 <FunctorSalad> Quadrescence: that's accurate
04:35:34 <FunctorSalad> (the first message, lol)
04:35:55 <FunctorSalad> Quadrescence: #haskell-blah
04:36:11 <FunctorSalad> Quadrescence:
04:36:28 <FunctorSalad> sorry wrong key
04:36:42 * benmachine doesn't afraid of anything
04:36:50 <shambler> :-)
04:41:07 <FunctorSalad> Except for mudkips. That's benmachine's only weakness.
04:42:43 <ivanm> Quadrescence: how are we copying scheme with the topic?
04:43:00 <ivanm> benmachine: "doesn't afraid"?
04:43:12 <Quadrescence> ivanm: long story
04:43:31 <ivanm> ... fine, I dont' care then ;-)
04:44:05 <Quadrescence> ivan monad
04:44:38 <aavogt> that would be ivanM
04:47:00 <Quadrescence> aavogt: Sure, if you want to go along with the other shitty names the Haskell prelude gives you
04:52:30 <ivanm> @slap Quadrescence
04:52:30 * lambdabot submits Quadrescence's email address to a dozen spam lists
04:52:33 <ivanm> they're not shitty
04:53:00 <ivanm> aavogt: and that wouldn't be a function on the monadic level (with just ivan being a non-monadic version)
04:53:27 <Quadrescence> ivanm: Are you kidding me?
04:53:33 <ivanm> no, I"m not
04:53:41 <Quadrescence> I know you're not; that was rhetorical.
04:53:55 <opqdonut> :D
04:53:58 <ivanm> then how are they shitty?
04:54:19 <ivanm> there might be haskell-specific conventions involved, but then we don't have to worry about FactoryFactoryFactoryFactory..
04:55:01 <Quadrescence> ivanm: Meh, it's my opinion, so no point in debating it I guess.
04:55:12 <Quadrescence> I think APL did it right.
04:55:17 <Quadrescence> I kid.
04:55:19 <oteren> whats the reason in having an opinion if you don't want to debate it
04:55:27 <ivanm> about to say... I'm not a fan of line noise...
04:55:30 <ivanm> oteren: exactly!
04:55:31 <oteren> the only reason i have for having an opinion is to strongly disagree with everyone!
04:55:36 <Quadrescence> oteren: Because I won't change your mind.
04:55:42 <osfameron> where does `on` live?
04:55:42 <oteren> nitpicking is a way of life
04:55:43 <ivanm> if the opinion is valid, then you should be ready to defend it TO THE DEATH!!!
04:55:45 <oteren> immo
04:55:49 <oteren> -m
04:55:51 <ivanm> > "mw" ++ cycle "ah"
04:55:52 <lambdabot>   "mwahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
04:55:57 <ivanm> osfameron: Function
04:56:02 <ivanm> *Data.Function
04:56:10 <osfameron> ah, thanks
04:56:55 <osfameron> @src on
04:56:56 <lambdabot> (*) `on` f = \x y -> f x * f y
04:59:05 <Baughn> dons: Could you have a look at cvs.haskell.org? I've been unable to access it ever since the disk crash.
04:59:29 <ivanm> Baughn: you still use cvs? :o
04:59:49 <Baughn> ivanm: Not my preference, but haskell-mode does. I've actually been tasked to convert it.. which I can't until it's back up. :P
05:00:11 <ivanm> Baughn: oh, that was you that was volunteered?
05:00:16 <Baughn> Yep
05:00:28 <ivanm> Baughn: conscript quicksilver into helping you; he seems to have a lot of opinions on it ;-)
05:00:31 <paolino> Prelude names are ok for new comers, I suspect you want more abstraction showing in them
05:01:02 <Baughn> ivanm: Roger wilco. elisp isn't really my thing..
05:01:08 <ivanm> not mine either...
05:01:11 <ivanm> I just use emacs ;-)
05:01:34 <Baughn> Well, have you had a look at haskell-indentation.el?
05:01:36 <ivanm> Baughn: methinks we need something like python's pymacs (which IIUC, it lets you write python for emacs code)...
05:01:36 <Baughn> It's *scary*.
05:01:42 <ivanm> Baughn: yeah, definitely agreed
05:01:53 <quicksilver> I have opinions about everything.
05:02:01 <quicksilver> Although they're more axioms than opinions.
05:02:01 <Baughn> ivanm: Er, not really. I prefer elisp to python, at least if I get to use the CL package.
05:02:16 <Baughn> quicksilver: You mean.. unsupported statements that have no truth value?
05:02:28 <quicksilver> I'm pretty sure the author of haskell-indentation will be happy to discuss it's code, kuribas a nice chap.
05:02:30 <ivanm> Baughn: what part of "we need something _like_" did you not understand? ;-)
05:02:32 <quicksilver> s/'//;
05:02:56 <Baughn> ivanm: The part where you expected me to read the whole sentence. Sorry, I'm pretty broken today; lack of sleep. :/
05:03:10 <ivanm> we need to be able to write emacs code in _Haskell_! (shallst we call it "hemacs"? :p )
05:03:12 <ivanm> Baughn: heh, fair enough
05:03:24 <EnglishGent> I agree ivanm!
05:03:26 <EnglishGent> :)
05:03:38 <ivanm> \o/
05:03:44 <ivanm> but what do you actually agree with? ;-)
05:04:13 <EnglishGent> [13:03] <ivanm> we need to be able to write emacs code in _Haskell_! (shallst we call it "hemacs"? :p )
05:04:13 <EnglishGent> :)
05:04:37 <ivanm> but do you agree with the task or the name? ;-)
05:05:32 <EnglishGent> the task
05:05:38 <EnglishGent> names we can worry about later :)
05:05:46 * EnglishGent is fighting elisp as we speak :|
05:05:49 * Baughn wishes for it to be called "hem-macs"
05:06:10 <Jafet> Mmm, ham-macs
05:06:17 <Zao> emachs
05:06:31 <FunctorSalad> monadmacs
05:07:21 <FunctorSalad> puremacs
05:07:31 <Jafet> Eww, monad arrow compose syntax
05:08:40 <opqdonut> it's awesome
05:09:07 <FunctorSalad> monad arrow compose?
05:09:14 <opqdonut> :t (>=>)
05:09:15 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:09:26 <opqdonut> makes for example stating the monad laws that much nicer
05:09:33 <FunctorSalad> ah. thought you meant some hybrid of 'do' and 'proc' syntax
05:09:45 <FunctorSalad> that fish operator is nice yes
05:09:54 <opqdonut> or atleast that's what i think he means :)
05:12:01 <FunctorSalad> .oO (the fragment of haskell consisting only of string literals and the "fail" function)
05:14:41 <dnivra> i have two lists x and y. can i add the corresponding elements using map function?
05:14:57 <dnivra> i tried sum (map $ take 1 x) (map $ take 1 y)
05:14:59 <ivanm> dnivra: zipWith (+)
05:15:08 <dnivra> i know zipwith works
05:15:09 <ivanm> @type zipWith
05:15:10 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:15:13 <dnivra> i did it using zip actually
05:15:19 <dnivra> but i was wondering if it's possible with map
05:15:27 <ivanm> dnivra: map only takes one list...
05:15:36 <Baughn> dnivra: Not without zipping it first
05:15:38 <ivanm> you have to combine two lists into one; that's what zipWith is for!
05:15:41 <FunctorSalad> > (+) <$> [0..10] <*> [23..32]
05:15:42 <lambdabot>   [23,24,25,26,27,28,29,30,31,32,24,25,26,27,28,29,30,31,32,33,25,26,27,28,29...
05:15:48 <FunctorSalad> oops
05:15:57 <ivanm> @type (<$>)
05:15:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:16:02 <FunctorSalad> wrong instance ;)
05:16:04 <dnivra> is it possible to take one element at a time from a list and then add them?
05:16:06 <FunctorSalad> @ty ZipList
05:16:07 <Baughn> @type ZipList
05:16:07 <lambdabot> forall a. [a] -> ZipList a
05:16:08 <lambdabot> forall a. [a] -> ZipList a
05:16:15 <dnivra> like map $ take 1 x
05:16:17 <Baughn> @src ZipList
05:16:17 <lambdabot> Source not found.
05:16:19 <ivanm> @type (<*>)
05:16:19 <dnivra> or something like that?
05:16:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:16:29 <ivanm> dnivra: ummm, what do you expect that to do?
05:16:41 <Baughn> > (+) . ZipList [1..10] <*> ZipList [2..20]
05:16:42 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
05:16:43 <lambdabot>    arising ...
05:16:52 <dnivra> well repeatedly keep taking 1 element of x
05:16:52 <ivanm> dnivra: you need to use zipWith to combine them
05:17:03 <ivanm> dnivra: ummm.... what?
05:17:05 <dnivra> ivanm: that's the only way?
05:17:07 <ivanm> dnivra: what's the type sig you want?
05:17:15 <ivanm> dnivra: why would map work? as I said, it only takes in one list
05:17:40 <ivanm> dnivra: if you wanted to do something with an entire list applied to each element of a second list, then you could use map
05:17:50 <ivanm> but since you want the relative positions used, you need to use zip
05:17:55 <ivanm> dnivra: what's wrong with zipping them?
05:17:57 <Jafet> @pl \f, (x:xs), (y:ys) -> (x+y):(f xs ys)
05:17:57 <lambdabot> (line 1, column 11):
05:17:58 <lambdabot> unexpected ","
05:17:58 <lambdabot> expecting operator, pattern or "->"
05:17:58 <lambdabot> ambiguous use of a non associative operator
05:18:06 <Jafet> Oops
05:18:07 <ivanm> Jafet: no commas...
05:18:16 <Jafet> @pl \f (x:xs) (y:ys) -> (x+y):(f xs ys)
05:18:17 <lambdabot> (`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . flip . (((.) . (:)) .) . (+))
05:18:25 <Jafet> Ha
05:18:25 <dnivra> ivanm: nothing is wrong. i was just trying stuff out and was really trying to do this using a map that's all
05:18:29 <ivanm> Jafet: do you want it to recurse?
05:18:44 <Jafet> ivanm, I assume you could fix that?
05:18:49 <FunctorSalad> dnivra: the abstraction you're looking for is 'Applicative'. it can't be done with Functor
05:18:50 <ivanm> @pl let f (x:xs) (y:ys) = (x+y) : (f xs ys) in f
05:18:51 <lambdabot> fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . flip . (((.) . (:)) .) . (+)))
05:18:56 <ivanm> Jafet: ^^
05:19:11 <Jafet> Fixed!
05:19:23 <ivanm> @pl let f (x:xs) (y:ys) = (x+y) : (f xs ys); f _ _ = [] in f
05:19:23 <lambdabot> ap (flip flip tail . (ap .) . flip flip head . ((.) .) . ((.) =<< flip . (((.) . (:)) .) . (+)) . head) tail
05:19:30 <ivanm> shorter with the base case added!
05:19:40 <dnivra> FunctorSalad: ok
05:19:47 <ivanm> > (ap (flip flip tail . (ap .) . flip flip head . ((.) .) . ((.) =<< flip . (((.) . (:)) .) . (+)) . head) tail) [0..5] [10..20]
05:19:48 <lambdabot>   Occurs check: cannot construct the infinite type:
05:19:48 <lambdabot>    a = a1 -> [a] -> [a2]
05:19:54 <ivanm> bugger...
05:20:01 <ivanm> @type (ap (flip flip tail . (ap .) . flip flip head . ((.) .) . ((.) =<< flip . (((.) . (:)) .) . (+)) . head) tail)
05:20:02 <lambdabot>     Occurs check: cannot construct the infinite type:
05:20:03 <lambdabot>       a = a1 -> [a] -> [a2]
05:20:03 <lambdabot>     Probable cause: `+' is applied to too many arguments
05:20:09 <ivanm> @type let f (x:xs) (y:ys) = (x+y) : (f xs ys); f _ _ = [] in f
05:20:10 <lambdabot> forall t. (Num t) => [t] -> [t] -> [t]
05:20:20 <ivanm> hmmmm, @pl doesn't seem to be working properly then...
05:20:30 <ivanm> mustn't like multi-statement functions...
05:21:22 <zygoloid> > getZipList $ (+) <$> ZipList [1..10] <*> ZipList [23..32]
05:21:23 <lambdabot>   [24,26,28,30,32,34,36,38,40,42]
05:21:29 <ivanm> @type ap (flip flip tail . (ap .) . flip flip head . ((.) .) . ((.) =<< flip . (((.) . (:)) .) . (+)) . head) tail
05:21:30 <lambdabot>     Occurs check: cannot construct the infinite type:
05:21:30 <lambdabot>       a = a1 -> [a] -> [a2]
05:21:30 <lambdabot>     Probable cause: `+' is applied to too many arguments
05:21:50 <ivanm> @hoogle ZipList
05:21:50 <lambdabot> Control.Applicative newtype ZipList a
05:21:50 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
05:21:50 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
05:22:04 <ivanm> ziplists are defined just for the alternate functor/monad definition?
05:22:33 <Baughn> Yes
05:22:42 <FunctorSalad> I don't think they form a monad
05:22:58 <ivanm> oh?
05:22:59 <FunctorSalad> maybe even the Applicative instance is illegal because of possible length mismatches
05:23:09 <ivanm> @instances-importing Control.Applicative Monad
05:23:10 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:23:17 <FunctorSalad> what are the applicative laws again?
05:23:32 <Baughn> If you assume the applicative bit is fine (which it isn't), you can say join=concat and have a monad
05:23:35 <ivanm> FunctorSalad: IIRC, RWH says zip-based monad instance was a possible choice for lists...
05:23:59 <zygoloid> ZipList is not a monad; ZipStream is
05:25:03 <ivanm> @hoogle ZipStream
05:25:03 <lambdabot> No results found
05:25:06 <ivanm> ...
05:25:11 <ivanm> zygoloid: why not?
05:25:56 <zygoloid> ivanm: diag . diag /= diag . map diag
05:26:19 <zygoloid> (where diag = join and map = fmap)
05:26:19 <ivanm> about to ask wtf diag was...
05:26:20 <FunctorSalad> in ZipStream that holds?
05:26:35 <ivanm> which monad law is that?
05:26:51 <FunctorSalad> one of the join-based monad laws
05:27:02 <zygoloid> it follows from associativity of (>=>)
05:27:04 <ivanm> an alternate specification?
05:27:11 <ivanm> @type (>=>)
05:27:11 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:27:24 <FunctorSalad> ivanm: yeah the one common in math
05:27:29 <ivanm> is that (.) for monads?
05:27:36 <ivanm> FunctorSalad: oh, that thing...
05:27:37 <ivanm> :p
05:28:17 <FunctorSalad> ivanm: i.e., the two ways to go from "m (m (m a)))" to "m a" must be equal
05:29:04 <zygoloid> basically the problem is with lists which whose element lists get shorter and longer again; you end up with 'holes' in the diagonal if you go one way but not the other
05:29:08 <EvilTerran> diagrams must commute!
05:29:25 <ivanm> @type join . join
05:29:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
05:29:33 <ivanm> @type join . map join
05:29:34 <lambdabot> forall a. [[[a]]] -> [a]
05:29:38 <zygoloid> @type join . fmap join
05:29:39 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m (m (m a)) -> m a
05:29:41 <EvilTerran> ?type join . liftM join
05:29:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
05:29:47 <ivanm> @type join . liftM join
05:29:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
05:29:56 <ivanm> right, OK
05:30:09 <dnivra> @hoogle sort
05:30:10 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
05:30:10 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
05:30:10 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
05:30:39 <int-e> ivanm: right, it's composition in the Kleisli category of the monad, which has arrows of the form a -> m b.
05:31:55 <ivanm> int-e: *whoosh*
05:31:55 <ivanm> ;-)
05:32:20 * ivanm hopes int-e doesn't mean "arrows" like for Control.Arrow...
05:32:33 * zygoloid crushes ivanm's hopes
05:32:34 <int-e> ivanm: but if you look at Control.Arrow and find the definition of Kleisli there, you'll now know what that is.
05:32:41 <zygoloid> @type Kleisli
05:32:42 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
05:32:47 <int-e> no, I didn't. I meant category theory ;)
05:32:51 <royjord> Hey everyone, is there a way for a polymorphic method to do pattern matching on the incomming type? Like  f:: a -> Bool  f (Char c) = ...
05:33:21 <zygoloid> royjord: that would violate parametricity
05:33:37 <osfameron> why can't I groupBy ((==) `on` fst)   ?
05:33:51 <osfameron> it looks like it should be equivalent to groupBy (\a b -> fst a == fst b)
05:33:54 <royjord> zygoloid: parametricity?
05:33:57 <zygoloid> royjord: however, you can probably get the result you want with an ADT
05:34:00 <osfameron> @pl  (\a b -> fst a == fst b)
05:34:01 <lambdabot> (. fst) . (==) . fst
05:34:03 <osfameron> meh
05:34:24 <zygoloid> royjord: essentially, if your type has a type variable 'a' in it, then you've got to behave the same no matter what 'a' is
05:35:19 <royjord> hmm yeah, I was afraid of that. Is there any other way to check if someting is of for example type Char?  like (a == typeOf(Char)) or something?
05:35:42 <zygoloid> royjord: there's basically two different approaches: an open one and a closed one
05:36:17 <zygoloid> royjord: the 'open' one means that other people can add new types for which 'f' works, and you accomplish that by using a type-class which provides either 'f' or an operation used by 'f'
05:36:28 <osfameron> ah wait, I can... I must have broken something else :-(
05:36:43 <royjord> In that case I probably would like to use the closed one :)
05:37:01 <zygoloid> royjord: the 'closed' one means the set of types for which 'f' works is fixed, and you accomplish that by adding a new type: 'data FInput = Char Char | Bool Bool | Integer Integer | ...'
05:37:12 <zenzike> I fixed a bug in a package I downloaded from cabal, and had to modify quite a few files to do so. Is there any automated tool that can create patches for me so that I can submit them to the maintainer?
05:37:28 <royjord> zygoloid, ah ok, I understand, gonna try if I can incorporate that in my current script
05:38:11 <zygoloid> people who use 'f' then wrap up their value with the appropriate constructor for FInput and 'f' does pattern matching to find which type was used
05:38:48 <zygoloid> another way of doing much the same thing would be to have different names for the different f-like functions at different types
05:39:06 <FunctorSalad> or a family GADT
05:39:09 <dcoutts> zenzike: if the dev version of the package uses darcs then that's the thing to use
05:39:09 <benmachine> zenzike: I think the usual thing to do would be to find the package's source control repository and use darcs or git or whatever
05:39:33 <benmachine> (first checking that your fixes are actually still necessary in the latest version)
05:39:34 <Baughn> zenzike: Lacking that, there's always diff -ru
05:39:42 <FunctorSalad> data FInput a where CharProof :: FInput Char; IntProof :: FInput Int
05:39:46 <zenzike> ah, so there's no clever "darcs patch" command?
05:39:52 <zenzike> I meant "cabal patch"
05:39:59 <dcoutts> nope
05:40:19 <zenzike> okay, cool. I'll make a diff the old fasioned way then :)
05:40:21 <benmachine> patches would only be very useful against the development version anyway
05:40:28 <benmachine> well I guess that's not entirely trie
05:40:29 <benmachine> true
05:40:37 <dcoutts> the developers would not appreciate it anyway, they'd prefer patches against their dev version using the dev tool, darcs/git/whatever
05:40:53 <benmachine> but in some cases e.g. parsec the usual hackage version is well behind the development version
05:41:21 <FunctorSalad> remember to fill the source-repo cabal field... :)
05:43:54 <zenzike> actually, i didn't do my homework properly; I just fixed the source that cabal gave me, and it didn't occur to me to go to the dev version, since the cabal version didn't compile. I'm checking the original sources now -- I just assumed that the package (frag) was abandoned.
05:44:28 <benmachine> oh yeah I had trouble with frag
05:44:40 <benmachine> because the GL bindings changed
05:44:43 <zenzike> well, i've fixed it up
05:44:47 <benmachine> that's pretty cool
05:45:12 <zenzike> i'm suprised how smooth it is
05:45:13 <benmachine> preflex: seen dons
05:45:13 <preflex>  dons was last seen on #xmonad 7 hours, 6 minutes and 3 seconds ago, saying: since that'll be around for a while
05:45:45 <benmachine> darcs get http://code.haskell.org/frag
05:45:53 <benmachine> you could try that
05:45:58 <zenzike> that's what i'm doing :)
05:46:05 <benmachine> oh good
05:46:14 <zenzike> though this machine doesn't have darcs, so i'm compiling that first
05:46:18 <benmachine> fwiw it looks like the version I had trouble with was the darcs version
05:46:22 <zenzike> stupid departmental computers ...
05:46:27 <benmachine> so your patch is probably still relevant
05:46:31 <zenzike> oh cool
05:47:14 <stanv> what is necessary to define to be in class Ord ?
05:47:22 <stanv> what operation :)
05:47:43 <zenzike> minimal is <=
05:47:58 <zenzike> (or compare)
05:48:27 <benmachine> you also need an instance for Eq
05:50:30 <zygoloid> ... but "instance Eq T where a == b = compare a b == EQ" is fine for that
05:51:16 <benmachine> mm
05:51:38 <zygoloid> if you do it that way you should define compare not (<=)
05:51:39 <FunctorSalad> @ty (fmap.fmap) (==EQ) compare
05:51:41 <lambdabot> forall a. (Ord a) => a -> a -> Bool
05:51:54 <FunctorSalad> fmapfmap
05:52:09 <zygoloid> (because the default for 'compare' uses (==) rather than invoking (<=) twice)
05:52:39 <FunctorSalad> usually defining compare is easiest anyway though
05:52:44 <FunctorSalad> using `mappend`
05:53:21 <benmachine> > LT `mappend` GT
05:53:22 <lambdabot>   LT
05:53:27 <benmachine> ic
05:53:46 <benmachine> @type (++)
05:53:47 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:53:54 <FunctorSalad> > EQ `mappend` undefined
05:53:55 <lambdabot>   * Exception: Prelude.undefined
05:54:03 <FunctorSalad> > LT `mappend` undefined
05:54:04 <lambdabot>   LT
05:54:06 <benmachine> good old caleskell.
05:54:11 <benmachine> > LT ++ undefined
05:54:13 <lambdabot>   LT
05:54:19 <FunctorSalad> hehehe
05:54:29 <Liskni_si> @type (++)
05:54:30 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:54:34 <FunctorSalad> ++++
05:54:35 * benmachine agrees with that one much more readily than (.)
05:54:42 <zygoloid> @karma ++
05:54:42 <lambdabot> ++ has a karma of 5
05:54:55 <FunctorSalad> caleskell++
05:55:33 <aleator> Hi! I want to test if a function ever returns true (by simulating ever with 100 random tests). Can I do this with quickcheck?
05:55:34 <zygoloid> @type ((.).(.)) (==mempty) compare
05:55:35 <lambdabot> forall a. (Ord a) => a -> a -> Bool
05:57:02 <ClaudiusMaximus> @check \x -> x < 9000
05:57:04 <lambdabot>   "OK, passed 500 tests."
05:57:38 <burp> hm, (++) generalized to monoids is fine
05:57:43 <aleator> ClaudiusMaximus: Ie. I want to test to be in fashion of "This thing commutes and does return both true and falses"
05:57:44 <burp> :t (.)
05:57:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:57:47 <burp> but this :P
05:58:13 <benmachine> aleator: what's the type of the function?
05:58:18 <EnglishGent> ah - so your function has two inputs aleator?
05:58:25 <aleator> Yup.
05:58:43 <ClaudiusMaximus> aleator: commutativity would be one property, and you could have two properties for always true and always false and check that both "fail"
05:58:48 <benmachine> if they are both instances of Arbitrary and Show I think you can just do
05:58:54 <aleator> As an example: intersects :: Rectangle -> Rectangle -> Bool
05:58:56 <benmachine> quickCheck function
05:59:14 <benmachine> @type quickCheck
05:59:15 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
05:59:21 <FunctorSalad> expectFailure
05:59:38 <EnglishGent> benmachine - I didnt know you could mark quick-check functions as 'this should fail' :)
05:59:46 * EnglishGent is still learning! :)
05:59:48 <benmachine> EnglishGent: err
05:59:50 <benmachine> can you?
05:59:55 <benmachine> I don't know much quickCheck :PO
05:59:57 <benmachine> :P
06:00:01 <FunctorSalad> expectFailure :: (Testable prop) => prop -> Property
06:00:02 <EnglishGent> oh - I though you were implying you could
06:00:08 <aleator> FunctorSalad: expectFailure? Where is that?
06:00:14 <Jafet> Sounds meaningless, EnglishGent, when you'd just negate the test
06:00:14 <benmachine> I think FunctorSalad is
06:00:22 <burp> hm, what is that (++) lambdabot has?
06:00:24 <FunctorSalad> aleator: Test.QuickCheck.Property
06:00:29 <EnglishGent> I read aleator's origional question as 'can we use quick check to ensure there exists a value v such that this function returns True for v'
06:00:30 <benmachine> burp: mappend
06:00:39 <burp> ah ok
06:00:56 <benmachine> burp: it's been argued that mappend is both an inaccurate and excessively verbose name
06:00:57 <EnglishGent> I cant think of a way of expressing that as a check which must be passed for all inputs (not off hand anyway)
06:01:02 <benmachine> which I think is true
06:01:04 <benmachine> on both counts
06:01:10 <FunctorSalad> @check (expectFailure (==True))
06:01:11 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:01:11 <lambdabot>                     Test.QuickChe...
06:01:19 <FunctorSalad> :(
06:01:21 <EnglishGent> commutivity is much easier - just ask if for all x,y it tields the same value no matter which way round the arguments are provided
06:01:31 <EnglishGent> :)
06:01:32 <copumpkin> @check expectFailure . (==True)
06:01:33 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:01:33 <lambdabot>                     (Test.QuickCh...
06:01:41 <benmachine> EnglishGent: there exists v such that f v == True is the same as not (for all v, f v == False)
06:01:50 <FunctorSalad> @check (expectFailure (property (==True)))
06:01:51 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:01:51 <lambdabot>                     Test.QuickChe...
06:02:04 * copumpkin goes back to sleep
06:02:47 <aleator> Thanks!
06:02:48 <EnglishGent> hi copumpkin :)
06:02:59 * copumpkin yawns greetingly at EnglishGent
06:03:13 <benmachine> I'm hungry
06:03:22 <benmachine> I had pasta for breakfast and all I have for lunch is more pasta
06:03:29 <benmachine> this is called being a student I think
06:03:40 * benmachine food
06:04:12 * EnglishGent waves to copumpkin & gets him a coffee
06:04:12 <EnglishGent> :)
06:04:12 <FunctorSalad> indeed, noodles rule when you're hungry
06:04:19 <FunctorSalad> *cofree
06:04:24 <ivanm> benmachine: ummmm, not really...
06:04:26 <copumpkin> noodles roodle when you're hungry
06:04:35 * ivanm has never eaten pizza or the like for breakfast
06:04:58 <ivanm> they're lunch/dinner foods; I refuse to eat them for breakfast
06:05:08 <copumpkin> ivanm: so conservative
06:05:11 <FunctorSalad> ivanm: they're usually the last thing I have left so if I don't like going to the grocery.
06:05:19 <Jafet> So have dinner for breakfast
06:05:19 <FunctorSalad> s/\./.../
06:05:24 <araujo> ivanm, you miss it
06:05:28 <ivanm> FunctorSalad: so you're being lazy? ;-)
06:05:32 <FunctorSalad> no wai
06:05:33 <ivanm> araujo: miss what?
06:05:42 <araujo> nothing better than "last night pizza" for breakfast
06:05:46 <ivanm> bah
06:05:53 <FunctorSalad> "last" night pizza?
06:05:55 <ivanm> I eat "last night pizza" for lunch
06:05:59 <EnglishGent> and I know about the forall benmachine - I just didnt think you could say that - I thought quickcheck was something where you said 'here's a function expecting some arguments - generate arguments and make sure the return value passes test T for all inputs'
06:06:12 <EnglishGent> i.e. that you couldnt preceed it with a not
06:06:15 <araujo> FunctorSalad, well, the "last" can vary
06:06:28 <araujo> but it is the further I get :P
06:06:32 <copumpkin> EnglishGent: no cup of cofree for me, thanks! don't drink it! gonna get back to my teleconference and sleep
06:06:34 <FunctorSalad> EnglishGent: yeah usually it works like that, I think expectFailure is special
06:07:55 <yitz> how about peas porridge in a pot, nine days old?
06:08:20 <ivanm> copumpkin: at the same time? :p
06:08:34 <copumpkin> ivanm: yep ;)
06:08:47 <Poulter> Hello... instance Show Something where
06:09:03 <Poulter> Can be called on a data can it be called on type?
06:09:09 <yitz> copumpkin: don't forget the mute button before you start snoring
06:09:15 <Poulter> Can you make them for types?
06:09:34 <araujo> ivanm, you don't sleep in teleconferences either?!, you are missing the fun of life!
06:09:46 <FunctorSalad> EnglishGent: you're right that you can't in general express a formula with leading "forall" as one wih leading "exists"
06:09:49 <copumpkin> :)
06:09:57 <titto> @pl \a b -> a + b
06:09:57 <lambdabot> (+)
06:10:01 <ivanm> araujo: I don't have any teleconferences ;-)
06:10:04 <FunctorSalad> (if no "not" is allowed outside)
06:10:15 <ivanm> Poulter: not using the type keyword, no
06:10:21 <ivanm> either data Foo or newtype Foo
06:10:25 <araujo> ivanm, don't tell me more please!
06:10:36 <ivanm> why not? jealous? :p
06:10:59 <Poulter> What's to choose between them?
06:11:08 * araujo more kind of scared :P
06:11:27 <FunctorSalad> scared of people who don't teleconfere? :O
06:11:30 <ivanm> Poulter: newtype only allows one type; it's there to act as a wrapper to "specialise" another datatype
06:11:32 <titto> @pl \ a b -> return $ a && b
06:11:32 <lambdabot> (return .) . (&&)
06:11:37 <araujo> FunctorSalad, who doesn't enjoy life!
06:11:56 <ivanm> Poulter: at runtime, there's no difference between `a' and "newtype Foo a = Foo a"
06:12:00 <EnglishGent> :)
06:12:10 <FunctorSalad> araujo: does irc count? :(
06:12:17 <ivanm> Poulter: if you want more than one sub-type or more than one constructor, then you have to use data
06:12:49 <Poulter> Ah okay mine type will always just be a tuple
06:13:24 <Poulter> But to define a show function I should make it a newtype.
06:13:29 <Poulter> (?)
06:13:56 <araujo> FunctorSalad, of course!
06:14:02 <araujo> FunctorSalad, mainly here .. in #haskell
06:14:06 <SMSshock> SMS BOMBER - CHITAJ CUZHIJE SMSKI - > http://tinyurl.com/yl5vfhu
06:14:23 <burp> is it written in haskell? ;)
06:14:24 <ivanm> Poulter: if you want a non-standard show instance, then yes
06:14:38 <ivanm> or, you can use a data with two record-based values...
06:14:44 <Poulter> That's exactly what I want.
06:14:56 <Poulter> Yea
06:14:58 <ivanm> data Tuple a b = Tpl { firstValue :: a; secondValue :: b }
06:15:19 <ivanm> anyone have any idea wtf that spammer was talking about?
06:15:26 <ivanm> something about reading foreign something or other?
06:15:48 <Poulter> Or newtype Cheese = (Int, Int)
06:15:49 <ivanm> Poulter: better idea: don't use show, write your own function and use that
06:15:50 <Poulter> ?
06:16:01 <ivanm> Poulter: newtype Cheese = Cheese (Int, Int)
06:16:16 <ivanm> Poulter: is there any particular reason for using show?
06:16:17 <Poulter> kk
06:16:27 <ivanm> can you just have showCheese :: (Int,Int) -> String ?
06:16:38 <ivanm> Poulter: it's usually considered a bad idea to have a manual instance of Show
06:16:46 <Poulter> Its how I know to put out text in Haskell.
06:16:49 <ivanm> since it's there for printing out a code representation of your data
06:17:01 <ivanm> Poulter: write a custom function
06:17:06 <Poulter> brb
06:17:14 <Poulter> Actually no, housemate is getting it
06:17:26 * FunctorSalad wrote a valid-haskell Show instance for a HOAS type yesterday =)
06:17:36 <ivanm> showCheese (c1,c2) = "Of cheese type " ++ show c1 ++ ", we have " ++ show c2 ++ " in stock."
06:17:38 <ivanm> Poulter: ^^
06:17:41 <ivanm> and then use that
06:17:46 <ivanm> FunctorSalad: HDAS?
06:17:55 <FunctorSalad> (prints it abstractly as a certain function application)
06:18:00 <ivanm> FunctorSalad: any particular reason for not deriving it?
06:18:04 <FunctorSalad> ivanm: higher-order abstract syntax
06:18:09 <ivanm> oh, Data.Map/Set/etc. style?
06:18:17 <Poulter> Okay, sounds simple, I'd still use newtype or simply type?
06:18:22 <FunctorSalad> ivanm: represents binders as functions
06:18:23 <Poulter> to define Cheese
06:18:34 <ivanm> Poulter: type works then
06:18:43 <FunctorSalad> so you need to plug fresh values in for printing
06:19:02 <ivanm> Poulter: if you newtyped it, then you'd have to pattern match on the constructor: cheeseCount (Cheese (_,c)) = c, etc.
06:19:15 <Parkotron> I have two types that I'd like to make instances of Eq. Both will have identical implementations of (==). Can I declare both to be instances with a single instance declaration, or do I need to do them separately.
06:19:38 <ivanm> FunctorSalad: hmmmm...
06:19:38 <ivanm> seperately
06:19:41 <FunctorSalad> ivanm: yeah I ended up printing it Data.Map-style
06:19:53 <FunctorSalad> (as a non-constructor)
06:20:01 <Parkotron> ivanm: Thanks.
06:20:01 <Poulter> But using type, I'd not need to bother, if using showCheese
06:20:52 <ivanm> Poulter: exactly
06:20:58 <ivanm> Parkotron: no worries
06:21:07 <Poulter> Thanks
06:21:36 <ivanm> @src Either fmap
06:21:36 <lambdabot> fmap _ (Left x) = Left x
06:21:36 <lambdabot> fmap f (Right y) = Right (f y)
06:21:36 <ivanm> good-o
06:22:33 <ivanm> @hoogle Either a (Either b c) -> Either d c
06:22:33 <lambdabot> No results found
06:23:08 <ivanm> grrrr..... I want to collapse the two Eithers down, not caring what the Left type is (since if it's Left it's bad anyway)
06:23:08 <copumpkin> ivanm: whence the d?
06:23:23 <ivanm> copumpkin: I was using it to represent either a or b
06:23:26 <ivanm> @hoogle Either a (Either b c) -> Either a c
06:23:26 <lambdabot> No results found
06:23:28 <ivanm> @hoogle Either a (Either b c) -> Either b c
06:23:28 <lambdabot> No results found
06:23:52 <FunctorSalad> @ty (?f ||| (?g ||| ?h))
06:23:53 <lambdabot> forall (a :: * -> * -> *) b d b1 c. (?f::a b d, ?g::a b1 d, ?h::a c d, ArrowChoice a) => a (Either b (Either b1 c)) d
06:23:54 <ivanm> oh, right, the type won't end up working...
06:24:00 <ivanm> @hoogle Either a (Either b c) -> Either (Either a b) c
06:24:01 <lambdabot> No results found
06:24:03 <copumpkin> I think you'll find something like that in category-extras
06:24:10 <copumpkin> (the last one you wrote)
06:24:13 <ivanm> gah, that's ugly...
06:24:19 <FunctorSalad> what? :O
06:24:50 <FunctorSalad> think a = (->) then it's simple
06:24:55 <ivanm> FunctorSalad: what lambdabot spat out for you
06:25:06 <ivanm> all the implicit params (or whatever they're called), etc.
06:25:20 <Asztal> :t join . right (left (const undefined))
06:25:20 <lambdabot> forall a b d. (Error d) => Either d (Either b a) -> Either d a
06:25:24 <FunctorSalad> they come from the question marks ;)
06:25:40 <zygoloid> ivanm: i'd guess that spammer was advertising a text-messaging spam service ;-)
06:25:47 <ivanm> FunctorSalad: oh, right...
06:26:04 <FunctorSalad> @ty (length ||| (length ||| length))
06:26:05 <lambdabot> forall a a1 a2. Either [a] (Either [a1] [a2]) -> Int
06:26:23 <ivanm> zygoloid: pretty sure the "CHITAJ CUZHIJE" means "read foreign/others" though...
06:26:23 <FunctorSalad> @ty (length +++ (length +++ length))
06:26:24 <lambdabot> forall a a1 a2. Either [a] (Either [a1] [a2]) -> Either Int (Either Int Int)
06:26:44 <ivanm> FunctorSalad: I thought ||| joined two xmonad layouts together... :p
06:26:48 <Jafet> zygoloid, I once got a flyer in the mailbox advertising a flyer delivery service
06:26:53 <ivanm> copumpkin: any idea where in c-e it is?
06:26:57 <ivanm> Jafet: heh
06:27:33 <zygoloid> Jafet: i keep getting business cards through the door advertising a service where for a small fee i get to deliver business cards to people asking them for money for business cards which...
06:27:46 <Jafet> Uh, that's a ponzi scheme
06:27:50 <zygoloid> ... anyway, the business card would have contained less text if it'd used 'fix'
06:27:50 <copumpkin> ivanm: looking now, can't remember
06:27:52 <ivanm> zygoloid: heh
06:28:11 * ivanm is wondering if he should write his own function which just returns Maybe c ...
06:28:19 <zygoloid> the Y combinator: a Ponzi scheme in disguise?
06:28:36 <Jafet> Paul Graham sues you.
06:29:20 <ceal> @hoogle zipWith3
06:29:20 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:29:21 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:29:22 <zygoloid> ivanm: Just return :: Maybe (c -> Maybe c) ?
06:29:55 <int-e> zygoloid: more so than you might have intended - Y is all fun until you run out of heap space :)
06:30:22 <ivanm> zygoloid: nah, I've decided to use (Right (Right c)) = Just c; _ = Nothing
06:31:05 <zygoloid> int-e: yeah, i hate when there's a run on the thunks.
06:32:12 <zygoloid> ... when your account hits rock bottom?
06:40:37 <benmachine> @index left
06:40:37 <lambdabot> Control.Arrow
06:40:59 <benmachine> makes sense
06:41:08 * ivanm wishes try automagically defaulted to SomeException if no Exception type was specified
06:42:35 <eflister> @ty (traverse . fmap) id
06:42:36 <lambdabot> Not in scope: `traverse'
06:42:47 <eflister> @ty (Data.Traversable.traverse . fmap) id
06:42:48 <lambdabot> forall (f :: * -> *) (t :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
06:43:06 <eflister> is this well known?  took me DAYS to figure it out.
06:43:35 <benmachine> @type Data.Traversable.Sequence
06:43:36 <lambdabot>     Not in scope: data constructor `Data.Traversable.Sequence'
06:43:36 <benmachine> er
06:44:01 <quicksilver> eflister: fmap id doesn't do anything
06:44:12 <quicksilver> eflister: not sure what you're trying to do there?
06:44:13 <benmachine> @type Data.Traversable.sequenceA
06:44:15 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
06:44:31 <quicksilver> @type Data.Traversable.traverse
06:44:32 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:44:43 <eflister> ha ha, looks like i was trying to sequenceA
06:44:46 <eflister> dang.
06:50:31 <paolino> is there a simple to explain reason why let bindings cannot take apart existentials ?
06:50:51 <dnivra> @hoogle flodl
06:50:51 <lambdabot> No results found
06:50:55 <dnivra> @hoogle foldl
06:50:55 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
06:50:55 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
06:50:55 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
06:51:19 <Axman6> @check \x -> fmap id x == x
06:51:20 <lambdabot>   No instances for (Test.QuickCheck.Arbitrary (f a),
06:51:20 <lambdabot>                    GHC.S...
06:51:29 <Axman6> @check \x -> fmap id x == (x :: [Int])
06:51:48 <lambdabot>   "OK, passed 500 tests."
06:52:42 <quicksilver> paolino: because let binds are recursive and if you do a recursive exponential bind the entire universe collapses to a single point
06:52:50 <quicksilver> s/exponential/existential/
06:52:56 <quicksilver> damn these ential words.
06:53:49 <paolino> ah, that is "My brain explode" from ghc
06:54:12 <benmachine> @ghc
06:54:13 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
06:54:14 <paolino> should be implode then :)
06:57:07 <[pini]> hi folks
06:57:59 <[pini]> is anyone here also enjoying issues with importing Control.Monad.State in Ubuntu Karmic ?
06:58:41 <quicksilver> install libghc-mtl-dev
06:58:45 <quicksilver> or libghc6-mtl-dev
06:58:54 <quicksilver> or whatever slight permutation of that name they call the package :)
06:59:03 <quicksilver> apt-cache search ghc | grep mtl
06:59:22 <dnivra> i have been studying foldl and would like to know what exactly is the use of the command
06:59:41 <dnivra> i implemented a function to find the sum of a list using foldl and lambda
07:00:01 <dnivra> foldl (\x y -> x + y) [1,2,3,4,5]
07:00:14 <[pini]> quicksilver: thx
07:00:19 <dnivra> what exactly is the use of foldl?
07:00:40 * benmachine notes that (\x y -> x + y) is the same as (\x y -> (+) x y) is the same as (+)
07:00:58 <ivanm> dnivra: left folds
07:01:00 <ivanm> ;-)
07:01:02 <ivanm> @type foldl
07:01:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:01:04 <ivanm> @type foldr
07:01:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:01:23 <ivanm> dnivra: do you know what a fold function in general is?
07:02:33 <dnivra> ivanm: not a clear cut idea
07:02:51 <ivanm> dnivra: OK, so in terms of lists, etc. folds are used to collapse a structure down into a single value
07:03:14 <ivanm> note that the "single value" can be another list, etc.
07:03:24 <dnivra> ivanm: and this is done using the first function that is passed to fold?
07:03:26 <ivanm> foldl and foldr differ in the direction they take
07:03:35 <ivanm> dnivra: that's the combining function, yes
07:03:42 <ivanm> > foldr (:) [] [1..5]
07:03:43 <lambdabot>   [1,2,3,4,5]
07:03:45 <ivanm> > foldl (:) [] [1..5]
07:03:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:03:49 <ivanm> bah
07:03:57 <ivanm> > foldl (flip (:)) [] [1..5]
07:03:58 <lambdabot>   [5,4,3,2,1]
07:04:22 <ivanm> dnivra: ^^ notice that using foldl and foldr resulted in different outputs, the the combining function only differing to get the types right
07:04:38 <ivanm> > foldl f a [b,c,d]
07:04:39 <lambdabot>   f (f (f a b) c) d
07:04:41 <ivanm> > foldr f a [b,c,d]
07:04:42 <lambdabot>   f b (f c (f d a))
07:04:43 <dnivra> yes true...
07:04:58 <ivanm> dnivra: even more explicit using symbols to show the chain of application ^^
07:05:22 <Baughn> Remember, haskell evaluates from the outside in, as opposed to the inside out as with most languages
07:05:26 <ivanm> so foldl applies as soon as possible, foldr waits till the end before it starts to apply the function
07:05:34 <ivanm> Baughn: what do you mean by that?
07:05:34 <benmachine> > foldl (const id) [1 ..]
07:05:39 <lambdabot>   mueval-core: Time limit exceeded
07:05:49 <dnivra> yeah Baughn what does that mean?
07:06:00 <benmachine> oh yeah
07:06:04 <benmachine> > foldl (const id) [1 .. 200]
07:06:08 <Baughn> ..seemed like a nice way to describe lazy evaluation, given those outputs
07:06:08 <lambdabot>   []->
07:06:08 <lambdabot>    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
07:06:14 * benmachine blinks
07:06:17 <benmachine> > foldl (const id) 0 [1 .. 200]
07:06:18 <Baughn> > foldr f a [b,c,d]
07:06:19 <lambdabot>   200
07:06:20 <lambdabot>   f b (f c (f d a))
07:06:26 <ivanm> benmachine: heh
07:06:44 <Baughn> Haskell first executes "f b x", and then only evaluates x if it needs to
07:06:47 <ivanm> Baughn: yes, that's foldr vs foldl... how does that make Haskell different from other languages?
07:06:54 <ivanm> Baughn: oh, laziness...
07:07:02 <ivanm> Baughn: I was getting to that!
07:07:02 <dnivra> oh!!
07:07:02 <Baughn> ivanm: Well, in a strict language, foldr would be a guaranteed stack overflow..
07:07:23 <ivanm> dnivra: so, because of how it operates, you'd never want to use foldl on an infinite list
07:07:32 <ivanm> but if the combining function is lazy, foldr works well on infinite lists
07:07:35 <Jafet> In a strict stack language compiled to *nix, that is
07:07:39 <ivanm> e.g. for the and and or functions
07:07:42 <ivanm> @src and
07:07:43 <lambdabot> and   =  foldr (&&) True
07:07:54 <Jafet> Oh, infinilists. Nevermind
07:08:15 <hackagebot> bencode 0.5 - Parser and printer for bencoded data. (DavidHimmelstrup)
07:08:20 <ivanm> dnivra: ^^ because (&&) is lazy (that is, if the first value is False, then the entire thing is False), and will return as soon as a False value is found
07:08:26 <benmachine> > foldl' (const id) 0 [1 .. 10]
07:08:27 <lambdabot>   10
07:08:41 <Baughn> dnivra: foldl is unable to produce any results until it's seen the entire list, but because it's tail-recursive, if the combining function is also strict, it's capable of keeping a running sum
07:08:44 <ivanm> > foldr (&&) True (False : repeat True)
07:08:45 <lambdabot>   False
07:08:49 <ivanm> > foldl (&&) True (False : repeat True)
07:08:51 <Baughn> dnivra: E.g. you'd want to use foldl with functions like +
07:08:56 <lambdabot>   mueval: ExitFailure 1
07:09:00 <benmachine> > foldl' (const id) 0 [undefined, 10]
07:09:12 <lambdabot>   mueval-core: Time limit exceeded
07:09:12 <ivanm> dnivra: ^^ foldl didn't deal well with the infinite list
07:09:31 <Baughn> dnivra: (Er.. because + is strict, not because of the "sum" wording. Accumulator, not sum.)
07:09:43 * benmachine stops playing with things while people are trying to explain stuff
07:10:01 <ivanm> dnivra: the problem with foldl (even for sums, etc.) is that it can chew up a lot of memory as it waits till the end to evaluate the big expression; Data.List has a version called foldl' that forces each sub-function to be evaluated, thus saving memory
07:10:02 * Baughn sometimes feels that laziness/strictness should be encoded in the type system somehow
07:10:11 <ivanm> as such, there's usually no need to use foldl itself
07:10:21 <ivanm> Baughn: hmmm.... interesting notion
07:10:33 <Baughn> However, if you have optimizations turned on, foldl is usually rewritten to foldl' anyhow, so you might not notice
07:10:39 <ivanm> Baughn: problem with that is, you have different values of "strict": WHNF, HNF, RNF, etc.
07:10:51 <Baughn> There are a very few, rare cases where you'd /want/ foldl instead of foldl'. They really should be switched.
07:10:56 <ivanm> Baughn: isn't there some cases where you _want_ foldl and not foldl'?
07:11:02 * ivanm seems to recall someone telling him that once...
07:11:03 <benmachine> > foldl' (const id) 0 [1, undefined, 3]
07:11:06 <lambdabot>   * Exception: Prelude.undefined
07:11:07 <benmachine> > foldl (const id) 0 [1, undefined, 3]
07:11:09 <lambdabot>   3
07:11:17 <ivanm> benmachine: right, stuff like that
07:11:23 <ivanm> which is, of course, contrived
07:11:25 <Baughn> ivanm: Sort of. You pretty much have to artificially construct them; it's about on level with the type-checker being EXPTIME.
07:11:31 <Jafet> Write a metacircular evaluator!
07:11:37 <ivanm> Baughn: anyway, it appears we've scared dnivra off :p
07:11:39 <benmachine> ivanm: yeah, I don't know why you'd ever need to actually do that
07:11:44 <opdolio> ivanm: I don't think I've ever seen a non-contrived example.
07:11:53 <Baughn> ivanm: ..actually, I'm pretty sure the type-checker is NP, not outright EXPTIME
07:11:56 <ivanm> opdolio: *nod*
07:12:03 <dnivra> ivanm: :)
07:12:19 * ivanm -> land of nod
07:12:21 <ivanm> g'night all
07:12:21 <dnivra> you definitely have; no prizes for guessing
07:12:26 <opdolio> ivanm: The closest you can come is 'reverse = foldl (flip (:)) []', but that isn't significantly better.
07:12:53 <opdolio> Just that foldl' doesn't do much work.
07:12:54 <benmachine> @src reverse
07:12:55 <lambdabot> reverse = foldl (flip (:)) []
07:12:59 <Baughn> Anyone know? Is the type-checker NP, EXPTIME, or what?
07:13:17 <dnivra> this is enough information to process for the night for me<i'm just a college student with an average processing speed:-)>
07:13:51 <benmachine> opdolio: how else would one define reverse?
07:13:54 <Baughn> dnivra: http://haskell.org/haskellwiki/Performance/Laziness <-- Have this.
07:15:02 <dnivra> Baughn: thanks
07:15:06 <opdolio> benmachine: You could use foldl' instead. There isn't a significant difference between the two in that case.
07:15:52 <benmachine> opdolio: I suppose one isn't usually likely to reverse a lazy list
07:16:08 <dnivra> oh one more thing i've always wanted to demystify the type classes: which to use where when etc. any good reading suggestions?
07:16:09 <benmachine> but it isn't entirely unthinkable
07:16:17 <Baughn> dnivra: The typeclassopedia! :)
07:17:21 <opdolio> benmachine: The difference is that with foldl, you get back 'flip (:) (flip (:) (flip (:) [] x) y) z', whereas with foldl' you get 'z : y : x : []'.
07:18:11 <yitz> opdolio: why in the wold would you ever want a pile of flip thunks?
07:18:29 <yitz> world
07:19:22 <dnivra> Baughn: this is good thanks<good name; compliments to the person who came up with this>
07:19:26 <opdolio> yitz: You might not, but it isn't really a problem, because evaluating the list to whnf finishes in constant time at each step.
07:19:32 <yitz> anyway, I think with -O2 you get the latter for both foldl and foldl'
07:19:47 <opdolio> So it's just a question of when you pay that constant cost. On destruction, or during the fold.
07:20:39 <opdolio> Inspecting the foldl version finishes after evaluating one flip, giving you 'z' and 'flip (:) (flip (:) [] x) y', for instance.
07:21:04 <Baughn> Is there an actual advantage to that?
07:21:26 <dolio> No. It's just a case where foldl' doesn't have a significant advantage over foldl.
07:21:53 <Baughn> Hm. Actually, wouldn't the big pile o' thunks take up more memory than the foldl' result?
07:22:05 <dolio> Yeah, a little.
07:22:10 <yitz> a little more
07:23:21 <dolio> Baughn: Incidentally, you can write Haskell programs that result in types of doubly-exponential size. How that translates into time/space overhead I'm not really sure.
07:23:21 <Baughn> So, that's a case where foldl' just has a /small/ advantage over foldl. :P
07:23:48 <Baughn> dolio: Oh. Exptime, then.
07:24:48 <Baughn> dolio: Unless there's some clever optimization possibilities that allow subsequent verification to be done in polynomial time.. traversing an expontial structure takes exponential time.
07:25:06 <Baughn> ..wait, doubly-exponential?
07:25:09 <dolio> f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ... produces types of size O(2^(2^n)) in the length of the program.
07:25:17 <Baughn> Oh gods
07:25:45 <Baughn> dolio: There's regularity there that could be exploited, though
07:26:00 <dolio> Yeah. GHC blows up on it pretty easily, though.
07:27:31 <dolio> Although its behavior is pretty weird. For instance, you can make a type synonym such that fn : a -> T (T (... n Ts ... p a))
07:28:10 <dolio> Which won't help it not take double-exponential time.
07:28:51 <dolio> But, if you successfully type check fn, it will show a type for fn . fn in ghci in terms of the Ts without problem.
07:29:16 <dolio> Even if putting "f(n+1) : whatever ; f(n+1) = fn . fn" in the file would blow up.
07:32:24 <dolio> Anyhow, that case could probably be handled if you worked something like hash consing into your algorithm.
07:32:51 <dolio> But there may be ways to break it still.
07:34:20 <paolino> @hoogle (a -> m b) -> (b -> m c) -> a -> m c
07:34:21 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:34:22 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:34:22 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:34:22 <dolio> Also, that example is pretty contrived. :)
07:34:57 <Baughn> To be non-contrived, it should at least be runnable. ^^;
07:38:06 <dolio> Well, you can run it. I just can't imagine a situation where you're thinking, "I really need a double-exponentially-sized, nested pair where all spaces are filled with the same value."
07:42:52 <copumpkin> is it just me or is the writeList2Chan function name in Control.Concurrent.Chan a little strange?
07:43:07 <dolio> That 2 is odd.
07:43:11 <copumpkin> yeah
07:43:19 <jmcarthur> c-like
07:43:34 <copumpkin> reminds me of a 14-yr-ld hu lyks 2 wrt lyk dis
07:43:49 <Jafet> NOT LYK DIS???
07:44:12 <Jafet> I assume that function writes a list to 2chan
07:44:29 <jmcarthur> writeList4Chan
07:44:37 <mmmdonuts> That explains all those strange posts on 2chan.
07:44:42 <mmorrow> my favorite is changeToCurrentWorkingDirectoryToADifferentOne in System.Directory
07:44:51 <jmcarthur> :O
07:45:01 <Jafet> Fortran cringes.
07:45:13 <mmorrow> also there's whatAreTheFilePermissionsOfThisFile
07:45:21 <mmorrow> etc
07:45:24 <mmorrow> :)
07:45:31 <jmcarthur> wtf you're pulling our legs
07:45:47 <mmorrow> they might as well be that, they're long enough
07:45:53 <benmachine> System.Directory.makeRelativeToCurrentDirectory
07:45:56 <benmachine> is the longest
07:46:00 <mmorrow> haha
07:46:09 <mmorrow> so painful
07:46:19 <Jafet> @hoogle file permissions
07:46:20 <lambdabot> No results found
07:46:26 <Jafet> @hoogle FilePermissions
07:46:26 <lambdabot> No results found
07:46:41 <benmachine> @hoogle Permissions
07:46:42 <lambdabot> System.Directory data Permissions
07:46:42 <lambdabot> System.Directory Permissions :: Bool -> Bool -> Bool -> Bool -> Permissions
07:46:42 <lambdabot> System.Directory getPermissions :: FilePath -> IO Permissions
07:47:07 <Jafet> Legpulled
07:47:19 <mmorrow> :)
07:47:34 <benmachine> ghci> getAppUserDataDirectory "exciting"
07:47:34 <benmachine> "/home/ben/.exciting"
07:47:35 <benmachine> neat
07:49:41 <copumpkin> it'd be nice if it provided Mac OS-ey paths for mac os
07:49:52 <copumpkin> all it gives me is "/Users/pumpkin/.moo"
07:49:57 <benmachine> oh
07:50:02 <benmachine> that kind of works
07:50:10 <copumpkin> it does, but it's not very Mac OS-ey
07:50:24 <benmachine> but /Users/pumpkin/Library/Application Support/moo
07:50:29 <benmachine> I think is what you are supposed to use
07:50:47 <copumpkin> yea
07:50:48 <copumpkin> h
07:50:56 <copumpkin> that's what I was hoping for
07:51:43 <copumpkin> so I wrote a sort of bidirectional network chan thingy
07:51:52 <copumpkin> but I'm not sure if it should even be called Chan
07:51:58 <aavogt> 2chan?
07:52:00 <gwern> :t 1e10
07:52:03 <lambdabot> forall t. (Fractional t) => t
07:52:10 <gwern> fractional?
07:52:11 <copumpkin> aavogt: maybe I'll call it 4Chan
07:52:22 <gwern> shouldn't that just be an integral of some sort?
07:52:58 <aavogt> I guess there isn't a special case, and all xek numbers are fractional
07:53:07 <copumpkin> xek :o
07:53:19 <copumpkin> I for one welcome our new exponential overlord
07:53:19 <gwern> I dislike xeks
07:53:47 <aavogt> hmm, but 10000000000 isn't good either
07:58:46 <zygoloid> -- WARNING: do not run this: @@ @djinn @type let f0 x = (x,x); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2 in f3
07:58:49 <zygoloid> :)
07:59:25 <dolio> :)
07:59:34 <mmorrow> here're some renamings for System.Directory that make doing file stuff a little less like writing a novel http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4445#a4445
08:00:14 <mmorrow> > (length.show) (let f0 x = (x,x); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2 in f3 ())
08:00:16 <lambdabot>   1277
08:00:31 <gwern> mmorrow: maybe you should just go use hsh or something :)
08:01:04 <mmorrow> gwern: to find out the contents of the current directory, or the pwd?
08:01:14 <gwern> both
08:02:43 * copumpkin wants a service discovery package
08:04:07 * mmorrow looks for his flamethrower to light some candles, then unleashes his botnet to google for hsh :)
08:04:41 <mmorrow> gwern: but srsly, i haven't tried it, i'll check it out
08:05:16 <gwern> mmorrow: hsh is kind of nice. you write functions like 'pwd -|- ls -|- uniq'
08:05:22 <gwern> last I looked, anyway
08:05:27 <mmorrow> ooh, handay
08:05:30 * copumpkin tries to decide how to merge/duplicate DistChans
08:07:32 <benmachine> let f0 x =  (x,x); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2 in f3
08:07:35 <benmachine> oh whoops
08:10:28 <zygoloid> > let f0 x = (x,x); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2; s = show $ f3 (); count c = length . filter (==c) in (count '(' s, count ',' s, count ')' s)
08:10:30 <lambdabot>   (511,255,511)
08:13:50 <mmorrow> @. pl run text ("\\x -> " ++ show (let f0 x = parens (hsep [text "f",x,x]); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2 in f2 (text"x")))
08:13:51 <lambdabot> (line 2, column 1):
08:13:51 <lambdabot> unexpected end of input
08:13:51 <lambdabot> expecting space, simple term, "`", "!!", ".", operator or ")"
08:14:03 <mmorrow> @. pl run text ("\\x -> " ++ show (let f0 x = parens (hsep [text "f",x,x]); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2 in f1 (text"x")))
08:14:03 <lambdabot> ap (f . join f) (join f)
08:14:15 <mmorrow> > text ("\\x -> " ++ show (let f0 x = parens (hsep [text "f",x,x]); f1 = f0 . f0; f2 = f1 . f1; f3 = f2 . f2 in f1 (text"x")))
08:14:16 <lambdabot>   \x -> (f (f x x) (f x x))
08:14:31 <benmachine> @. pl . djinn type let f0 x = (x, x) in f0 . f0
08:14:32 <lambdabot> f = ap ((,) . join (,)) (join (,))
08:14:46 <benmachine> @. pl . djinn type let f0 x = (x, x); f1 = f0 . f0 in f1 . f1
08:14:47 <benmachine> etc.
08:14:48 <lambdabot> f = ap ((,) . ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,)))) (ap ((,) . ap ((,) . join (,)) (join (,))) (ap ((,) . join (,)) (join (,))))
08:17:25 <mmorrow> , let f = varE (mkName "f"); go x = [|$f $x $x|] in foldr (.) id (replicate 4 go) [|()|]
08:17:27 <lunabot>  AppE (AppE (VarE f) (AppE (AppE (VarE f) (AppE (AppE (VarE f) (AppE (AppE...
08:17:32 <mmorrow> , ppDoc <$> let f = varE (mkName "f"); go x = [|$f $x $x|] in foldr (.) id (replicate 4 go) [|()|]
08:17:34 <lunabot>  f (f (f (f () ()) (f () ())) (f (f () ()) (f () ()))) (f (f (f () ()) (f ...
08:18:13 <en0th> geez.
08:19:31 <burp> yes
08:22:23 <FunctorSalad> anyone know where the category-extras dev repo is?
08:24:54 <copumpkin> http://comonad.com/haskell/category-extras/ probably
08:25:20 <patch-tag> where is the source repo for the base lib? I am trying ot patch Data.Fixed to add a data instance. (required for a Data instance for UTCTime)
08:25:24 <FunctorSalad> copumpkin: thanks
08:25:26 <jmcarthur> it's more up to date than the hackage version it appears, at least
08:25:28 <patch-tag> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Fixed.html
08:25:28 <copumpkin> wtf = costrength . fmap (swap . costrength) . unit . swap
08:25:49 <jmcarthur> ?
08:26:00 <copumpkin> it's in http://comonad.com/haskell/category-extras/Toys.hs
08:26:35 <FunctorSalad> seems to be the dual of 'ftw' ;)
08:28:33 <Parkotron> Is there a standard function that does this "insertSep [1,2,3] 0 == [1,0,2,0,3]"
08:28:50 <patch-tag> intercalate perhaps
08:29:06 <kalven> intersperse
08:29:07 <patch-tag> no, intersperse :)
08:29:48 <FunctorSalad> wtf I just darcs-get'ed the repo and it's a different version than in the browser
08:29:57 <FunctorSalad> (older)
08:30:02 <copumpkin> FunctorSalad: :O
08:30:09 <copumpkin> FunctorSalad: bug edwardk :P
08:30:09 <Parkotron> patch-tag, kalven: Thank you very much.
08:30:33 <FunctorSalad> copumpkin: http is 0.53.6, darcs 0.53.5...
08:30:55 <Twey> :t intercalate
08:30:56 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:30:57 <Twey> :t intersperse
08:30:58 <lambdabot> forall a. a -> [a] -> [a]
08:30:59 <aavogt> patch-tag: that instance seems derivable if you have ghc-6.12
08:31:03 <Twey> I get those confused, too.
08:31:06 <FunctorSalad> (yes darcs is over http here, I mean the toplevel ;))
08:31:19 <copumpkin> FunctorSalad: I asked edwardk about why his repo appeared to be newer than the released version and he said he thought he'd pushed the latest version. I guess that's where the confusion came from
08:31:32 <ricree> if a module defines main, how do I get everything to load into ghci instead of just main?
08:31:54 <Twey> > (intersperse "0" &&& intercalate "0") ["foo", "bar", "baz"]
08:31:55 <lambdabot>   (["foo","0","bar","0","baz"],"foo0bar0baz")
08:32:10 <FunctorSalad> copumpkin: I see... maybe he didn't like the unrecorded changes though?
08:32:13 <mauke> ricree: is there an .o file around?
08:32:19 <Twey> intercalate = concat . intersperse
08:32:26 <copumpkin> FunctorSalad: he may have just forgotten to record them
08:32:27 <ricree> mauke: yes
08:32:41 <Twey> Or (concat .) . intersperse, I guess
08:32:52 <aavogt> patch-tag: I'm not 100% sure if this instance works, but it does compile with earlier ghcs that don't have Data for Fixed http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11009#a11009
08:33:04 <mauke> either remove that file (and reload) or (in newer versions of ghci) :load *file.hs
08:33:13 <mauke> I think. I haven't actually tested the * trick
08:33:26 <ricree> mauke: thank you
08:33:49 <hackagebot> Stream 0.4 - A library for manipulating infinite lists. (WouterSwierstra)
08:35:51 <en0th> is there a way to avoid repeating "where ((_,_),(rows,cols)) = bounds a" in each function which handles a Data.Array ?
08:36:41 <aavogt> en0th: you can write _ instead of (_,_)
08:36:49 <patch-tag> aavogt: Fixed has Data now? what version of ghc?
08:36:58 <en0th> oh, right!
08:37:10 <aavogt> unless you want to make sure you don't have an undefined tuple
08:37:25 <aavogt> rather than a tuple of undefined values
08:38:17 <FunctorSalad> copumpkin: heh I just thought about adding test cases for some of the laws, but he added them as {-# RULES #-} ;)
08:38:30 <copumpkin> yeah, many many rules
08:39:01 <FunctorSalad> hmm I guess one could test with rules disabled
08:39:54 <zygoloid> presumably one could define the rules in a different .hs file from the functions and tests, and import both into some common module for external use?
08:40:12 <mmorrow> en0th: you could also write a "withBounds" function
08:40:28 <aavogt> patch-tag: 6.12 apparently: http://www.haskell.org/ghc/dist/current/docs/html/libraries/base/Data-Fixed.html
08:40:34 <FunctorSalad> zygoloid: -fno-rewrite-rules sounds easier no?
08:40:53 <mmorrow> withBounds a k = let ((_,_),(rows,cols)) = bounds a in k rows cols
08:41:09 <mmorrow> maybe flipped actually
08:41:11 <mmorrow> err or
08:41:34 <mmorrow> withBounds k a = let ((_,_),(rows,cols)) = bounds a in k a rows cols
08:41:35 <zygoloid> FunctorSalad: you forgot -fforce-recomp, and that's kinda the point -- it means building the files multiple times in different ways, which is a pain
08:41:43 <Twey> en0th: where (rows, cols) = snd $ bounds a
08:41:51 <Twey> Maybe?
08:41:52 <mmorrow> withBounds (\a rows cols -> ..... .....)
08:42:07 <aavogt> patch-tag: well, it has Typeable, and it exposes the constructors now
08:42:11 <ricree> if I wanted to get the log of an Integer, what would  be the best way to go about that?
08:42:13 <patch-tag> aavogt: hmm, maybe should just upgrade to that.
08:42:14 <Twey> withBounds, pattern guards, view-patterns and as-patterns
08:42:17 <zygoloid> FunctorSalad: unless you can get away with just compiling the module containing the tests with -fno-rewrite-rules?
08:42:35 <copumpkin> ricree: divide repeatedly
08:42:36 <en0th> mm that's interesting.
08:42:39 <aavogt> it's an rc though
08:42:51 <Twey> mmorrow: ITYM withBounds a (\rows cols -> )?
08:43:00 <en0th> i still find  let .. in rather obscure
08:43:06 <Twey> en0th: Why?
08:43:18 <FunctorSalad> zygoloid: "cabal clean; cabal install --ghc-option=-fno-rewrite-rules"? looks easy enough
08:43:19 <Twey> If anything, monadic lets are more obscure :
08:43:20 <burp> > (map . max) 5 [1..10]
08:43:21 <lambdabot>   [5,5,5,5,5,6,7,8,9,10]
08:43:31 <mmorrow> Twey: i did initially, but changed my mind
08:43:39 <FunctorSalad> (on the original package)
08:43:41 <mmorrow> since that way you don't even have to refer to the array
08:43:44 <zygoloid> FunctorSalad: easy enough, but slow and easy to forget, and if you get it wrong the tests pass whether or not tthey should
08:44:04 <aavogt> patch-tag: so it's proably not 100%, and on top of that you have to add the pain of dealing with the api changes
08:44:05 <Twey> mmorrow: I'm assuming that when working with an array it's generally a good thing to have it available
08:44:07 <en0th> Twey: i think it's mostly due to "in"
08:44:19 <mmorrow> withArray (\arr rows cols -> if rows < cols then arr!42 else arr!(rows-3+7*cols))
08:44:22 <Twey> > do { let x = 5; x }
08:44:23 <lambdabot>   <no location info>: parse error on input `}'
08:44:27 <Twey> I feel this should yield 5
08:44:32 <FunctorSalad> zygoloid: yeah. maybe you could use a cabal flag "noRules" and set a boolean constant according to whether the flag is set
08:44:34 <ricree> copumpkin: There's seriously no way to get something like the log function to accept/convert an int?
08:44:36 <mmorrow> Twey: you have it available, but /inside/ the function
08:44:42 <mauke> > do let {x = 5}; x
08:44:43 <lambdabot>   5
08:44:43 <Twey> mmorrow: But why?  :
08:44:52 <copumpkin> ricree: you can convert the int to a float/double but then you lose precision
08:44:53 <mmorrow> withArray (\arr rows cols -> if rows < cols then arr!42 else arr!(rows-3+7*cols)) :: Array Int a -> a
08:44:54 <Twey> mauke: Oo?
08:45:04 <aavogt> @type do let {x=5}; x
08:45:05 <lambdabot> forall t. (Num t) => t
08:45:09 <Twey> > do { let {x = 5}; x }
08:45:09 <lambdabot>   5
08:45:11 <Twey> Huh.
08:45:13 <FunctorSalad> zygoloid: the thing is, category-extras has 99 modules and I don't feel like duping them all ;)
08:45:15 <Twey> Nice.
08:45:24 <en0th> brain molten.
08:45:26 <Twey> The null monad :
08:45:35 <aavogt> function monad?
08:45:42 <jmcarthur> or you could convert to CReal, but then you sacrifice TONS of performance, at least for log
08:45:42 <mmorrow> do () :: Identity ()
08:45:45 <mmorrow> @type do () :: Identity ()
08:45:46 <lambdabot>     Couldn't match expected type `Identity ()'
08:45:46 <lambdabot>            against inferred type `()'
08:45:46 <lambdabot>     In the expression: () :: Identity ()
08:45:48 <zygoloid> FunctorSalad: ah, i see :) yeah, the separate-module solution doesn't scale too well ;-)
08:45:55 <mmorrow> @type (do ()) :: Identity ()
08:45:55 <Twey> aavogt: It's not a monad, I'm pretty sure.
08:45:56 <lambdabot>     Couldn't match expected type `Identity ()'
08:45:56 <lambdabot>            against inferred type `()'
08:45:56 <lambdabot>     In the expression: ()
08:46:00 <mmorrow> grr
08:46:12 <aavogt> yeah it isn't that one
08:46:17 <zygoloid> @type return () :: Identity ()
08:46:17 <mmorrow> @type (do {let x = ()}; x) :: Identity ()
08:46:19 <Twey> There'd need to be a runIdentity, or a function application, or whatever
08:46:19 <lambdabot> Identity ()
08:46:19 <lambdabot>     The last statement in a 'do' construct must be an expression
08:46:37 <mmorrow> dunno
08:46:39 <mauke> mmorrow: dude, stop trying to make type errors run
08:46:46 <Twey> mmorrow: I don't think you can do that
08:46:47 <Twey> Haha
08:46:53 <Twey> x :: (), not Identity ()
08:46:55 <zygoloid> > do x <- Identity 42; return x :: Identity Int
08:46:56 <lambdabot>   No instance for (GHC.Show.Show
08:46:56 <lambdabot>                     (Control.Monad.Identity....
08:47:11 <mmorrow> mauke: i though maybe the fourth or fifth time'd magically work  .. :)
08:47:13 * Twey . o O ( /:: operator )
08:47:14 <zygoloid> > runIdentity $ do x <- Identity 42; return x :: Identity Int
08:47:15 <lambdabot>   42
08:47:27 <FunctorSalad> > runErrorT (fail "lol" :: Either String (Identity ()))
08:47:28 <lambdabot>   Couldn't match expected type `Control.Monad.Error.ErrorT e m a'
08:47:28 <lambdabot>         aga...
08:47:31 <Twey> It's a null monad.  
08:47:51 <aavogt> > return "lol" :: ()
08:47:53 <lambdabot>   Couldn't match expected type `()'
08:47:53 <lambdabot>         against inferred type `m [GHC.Typ...
08:48:01 <mmorrow> mauke: what is that?
08:48:01 <jmcarthur> could move all the rewrite rules to a separate module
08:48:04 <FunctorSalad> > runErrorT (fail "lol" :: ErrorT String Identity ())
08:48:05 <lambdabot>   No instance for (GHC.Show.Show
08:48:05 <lambdabot>                     (Control.Monad.Identity....
08:48:16 <FunctorSalad> > runIdentity (runErrorT (fail "lol" :: ErrorT String Identity ()))
08:48:16 <Twey> So I suppose this also works
08:48:18 <lambdabot>   Left "lol"
08:48:18 <jmcarthur> then the test cases are only affected if you build in that module
08:48:20 <Twey> > do 5
08:48:21 <lambdabot>   5
08:48:24 <Twey> :t do 5
08:48:25 <lambdabot> forall t. (Num t) => t
08:48:30 <copumpkin> () can't be a monad
08:48:37 <FunctorSalad> (see, you can run errors)
08:48:37 <Twey> \o/
08:48:38 <mmorrow> oh, probably just a parser glitch i guess
08:48:49 <Twey> FunctorSalad: Just not type errors.  ;)
08:48:51 <aavogt> @undo do 5
08:48:53 <lambdabot> 5
08:48:58 <FunctorSalad> Twey: oh :(
08:49:06 <Twey> Maybe with Data.Typeable :
08:54:02 <paolino> is there a difference between instance Functor Data.Tree and instance Traversable Data.Tree ?
08:54:11 <copumpkin> yeah
08:54:41 <copumpkin> Traversable does more things
08:54:47 <copumpkin> :)
08:55:28 <paolino> cannot guess which from src
08:55:39 <paolino> @src Traversable
08:55:39 <lambdabot> class (Functor t, Foldable t) => Traversable t where
08:55:40 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
08:55:40 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
08:55:40 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
08:55:40 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
08:55:50 <copumpkin> those don't look more powerful than fmap to you?
08:55:59 <paolino> yes
08:56:24 <FunctorSalad> hmm why is (~>) a legal type operator but (*) isn't?
08:56:36 <copumpkin> FunctorSalad: special case in the grammar I guess?
08:57:12 <Twey> Ew
08:57:43 <FunctorSalad> and what's nicer for categories/arrows, (~>) or (-->) ?
08:57:58 <copumpkin> Traversable and Foldable sound too concrete, we need something more categorical/obscure sounding
08:58:06 <copumpkin> FunctorSalad: ~>
08:58:11 <copumpkin> it's cute and curly
08:58:16 <copumpkin> like a pig's tail!
08:58:18 <Twey> Hehe
08:58:35 <FunctorSalad> copumpkin: but a bit hard to tell from (->)
08:58:50 <Twey> copumpkin: Catamorphism and
08:58:50 <copumpkin> ~~~~>
08:58:53 <FunctorSalad> and harder to type
08:58:57 <EnglishGent> ->>
08:58:59 <paolino> copumpkin: then  I have a Tree Int and a [Int -> Int] is there a way to zip those with traversable ?
08:58:59 <EnglishGent> ?
08:59:00 <EnglishGent> :)
08:59:15 <Twey> copumpkin: Er, Catamorphable :
08:59:15 <copumpkin> Twey: well Catamorphism is the operation itself. I guess FunctorFixpoint? :P
08:59:48 <Twey> Yes, I was just looking for a suitably Greek equivalent to Traversable :
08:59:54 <EnglishGent> btw... speaking of category theory - why use '|' in data statements? shouldnt it be '+' ? the options are mutually exclusive after all
09:00:06 <Twey> EnglishGent: Because.
09:00:09 <copumpkin> paolino: well, how would you like the list to correspond to your tree elements?
09:00:30 <paolino> ala flatten
09:00:30 <EnglishGent> ditto tuple formation why not (2, "hello") :: Int * String a'la ML?
09:00:41 <snorble> FunctorSalad: doesnt --> start a comment?
09:00:57 <copumpkin> snorble: nope
09:01:00 * EnglishGent does conceed that foo :: Bar -> Quax as foo :: Quax ^ Bar might be a little odd...
09:01:00 <EnglishGent> :)
09:01:10 <Twey> x.x
09:01:16 <copumpkin> lol
09:01:22 <copumpkin> we need more obvious exponentials ,yeah
09:01:52 <copumpkin> Who needs Maybe x when you can just talk about 1 + x, and x -> Bool is just 2^x
09:02:44 <copumpkin> data Cantor = 2^(x. 1 + x)
09:03:27 <copumpkin> or something like that :)
09:04:13 <paolino> copumpkin: if I flatten the tree I can zipWith ($) but I cannot rebuild the tree after, can Traversable do this ?
09:04:53 <copumpkin> paolino: trying to think of something
09:05:26 <copumpkin> paolino: you may need to use a Cont to do it elegantly
09:06:01 <copumpkin> oh wait
09:06:08 <copumpkin> mapAccum might do it
09:07:34 <paolino> thanks I try that
09:08:03 <paolino> this seems just a Functor application
09:08:59 <copumpkin> not quite, as you're maintaining state about which function to apply to each element
09:10:46 <mbuf> where does runghc determine the locations of installation of docs (INSTALL, README etc.) in a cabal source package?
09:11:18 <dcoutts> mbuf: it doesn't
09:11:28 <dcoutts> nor does cabal
09:11:35 <mbuf> dcoutts, sorry, newbie here
09:11:43 <dcoutts> what are you trying to do?
09:12:12 <mbuf> dcoutts, when I try to manually install a cabal source package runghc Setup.hs {configure, build, install}
09:12:13 <mxc> hi
09:12:23 <mxc> does readIORef essentially do a memcpy?
09:12:57 <dcoutts> mbuf: INSTALL, README files do not get installed, if that's what you're asking.
09:12:57 <mbuf> dcoutts, it installs in /usr/local/share/PackageName, /usr/local/share/doc/PackageName/,
09:13:10 <mbuf> dcoutts, and I want to know who sets this PATH
09:13:15 <dcoutts> mxc: it's simpler than that, it's just a memory read
09:13:26 <dcoutts> mbuf: that's the default --docdir
09:13:40 <dcoutts> mbuf: same default as standard ./configure uses
09:13:50 <mbuf> dcoutts, can it be overriden?
09:13:56 <dcoutts> yes, using --docdir
09:14:02 <mbuf> dcoutts, thanks!
09:14:34 <mxc> duncan, i dont understand the distinction, generally, a value can't be assumed to fit into a single register, wouldn't it hae to copy it?
09:14:44 <mxc> also, how does that work iwth laziness
09:14:48 <dcoutts> mxc: but it can, because it's a pointer to a value
09:14:57 <dcoutts> pointer to a heap object
09:15:09 <mxc> yeah, but if that value changes, what happens?
09:15:22 <dcoutts> then it points to a different heap object
09:15:50 <Vanadium> Values tend not to change
09:16:27 <dcoutts> right, I was assuming mxc meant what if the IORef changes
09:16:32 <mxc> so if i do something like (readIORef a >>= \b -> writeIORef a newValue >> purtStr b) i'd get the new value
09:17:02 <dcoutts> mxc: no, b is the value you got from the first read
09:17:04 <patch-tag> > [1,2,3]
09:17:05 <lambdabot>   [1,2,3]
09:17:30 <dcoutts> mxc: values are values are values, they do not magically change.
09:17:38 <mxc> oh, and when you do a writeIORef then the ioref itself points somewhere else
09:17:55 <mxc> or putIORef, whatever its called
09:18:02 <dcoutts> mxc: that's what's going on in the underlying implementation yes
09:18:04 <mxc> dcoutts: thats what I assumed, just wanted to double check
09:18:33 <mxc> especially since i'm going to be going a lot of readIORefs where the IORef contains a fairly large array
09:18:42 <dcoutts> mxc: the main thing is to distinguish between values (immutable) and names of mutable objects, such as IORefs
09:18:58 <dcoutts> mxc: hmm, doesn't sound very functional :-)
09:19:37 <mxc> dcoutts: I'm pretty sure i'm working on the most functionally pure implementation in this space yet :)
09:19:47 <dcoutts> :-)
09:20:15 <mxc> dcoutts: a lot of those readIORefs basically are there to return pure functiosn on snapshots of real time data
09:20:29 <mxc> so, most of my code is pure, but they are there to bridge the real world and the pure world
09:21:13 <mxc>  /who *minsk*
09:21:15 <mxc> oops
09:21:44 <mxc> sorry about that
09:22:32 <en0th> mmorrow: you always come up with two lines of code that put me offline for a couple of days
09:29:25 <paolino> @hoogle unwrapMonad
09:29:25 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
09:29:55 <paolino> @src WrappedMonad
09:29:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
09:30:23 <paolino> @src WrapMonad
09:30:23 <lambdabot> Source not found. Take a stress pill and think things over.
09:32:03 * EnglishGent wonders if lambdabot is going to make a prediction about the failure of the AE35 unit next :)
09:32:37 <zygoloid> @hoogle m a -> WrappedMonad m a
09:32:37 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
09:32:37 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
09:32:37 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
09:33:21 <zygoloid> newtype WrappedMonad m a = WrapMonad { unwrapMonad :: m a }
09:34:09 <copumpkin> that last result is pretty rando
09:35:12 <zygoloid> hoogle has its reasons, i'm sure ;-)
09:37:50 <copumpkin> another weird thing about the writeList2Chan function
09:37:54 <copumpkin> is that it doesn't appear to be atomic
09:38:02 <mmorrow> en0th: :)
09:38:15 <quicksilver> it's designed to consume nasty interleaved lists, I think, copumpkin
09:38:15 <copumpkin> it seems like one reason for having a single function for writing a bunch of items to a chan is that you'd want them to all be contiguous
09:38:23 <quicksilver> so it can't be atomic, it might block forever
09:38:36 <quicksilver> lists with unsage interleaved IO, I mean
09:38:36 <ddarius> copumpkin: I just view it as a convenience function.
09:38:45 <copumpkin> writeList2Chan ch ls = sequence_ (map (writeChan ch) ls)
09:38:49 <quicksilver> the worst thing about it is its appaling name
09:38:59 <copumpkin> yeah, it's terrible :P
09:39:13 <ddarius> Just write mapM_ (writeChan ch) ls explicitly.
09:39:36 <quicksilver> if you want atomicity, use TChans
09:39:37 <quicksilver> (I think)
09:39:48 <quicksilver> that's a better way to do channel things atomically
09:39:55 <quicksilver> (like reading N consecutive elements, etc)
09:40:07 <mmorrow> you could always make your own local Chan, fill it, then glue it onto another Chan (would need to write this function with access to internals)
09:40:13 <copumpkin> I don't actually need that function, am just writing a new Chan-like thing and was trying to decide on an API and behavior
09:40:16 <mmorrow> and that would be atomically
09:40:27 <ddarius> quicksilver: TChans behave like Chans as far as that is concerned, I'm pretty sure.
09:40:27 <mmorrow> *atomic
09:40:35 <ddarius> copumpkin: Look at the cml package.
09:40:49 <quicksilver> ddarius: surely not.
09:41:04 <quicksilver> ddarius: if you have two readTChans within a single STM transaction, they will occur atomically
09:41:15 <quicksilver> ddarius: if you have them in different transactions they won't, of course
09:41:34 <FunctorSalad> is there a good reason why category-extras has *two* triangle identities for monoidal categories or is this a mistake?
09:44:14 <copumpkin> ddarius: you think the CML channels are more elegant than Chan?
09:44:29 <copumpkin> what I'm trying to do is a network Chan
09:44:37 <copumpkin> or what I've done, I guess
09:44:57 <ddarius> copumpkin: I'd highly recommend browsing Reppy's thesis.
09:45:17 <copumpkin> hmm ok
09:45:39 <ddarius> copumpkin: That said, for a networked system, you'd want asynchronous channels (most likely) and the cml package implements synchronous channels, but that's not inherent in the ideas CML is based on.
09:46:01 <copumpkin> I'll check it out anyway
09:46:26 <copumpkin> my current implementation is using Binary. I'd be nice to move to mmorrow's awesome structure-preserving serialization though :P
09:46:55 <noZone> There's nothing worse that convenience functions, except inconvenient functions.
09:49:15 <FunctorSalad> hmm I think the other way to make a diagram from associate/idl/idr is just naturality of associate :)
09:49:41 <copumpkin> mmorrow: there's no easy way of using your closure dumping code as unsafeDump :: a -> ByteString and unsafeLoad :: ByteString -> a, yet, right? :P
09:49:42 <FunctorSalad> so it should be free in haskell...
09:50:51 <lispy> ?vixen How do you feel about the AE35 unit?
09:50:52 <jmcarthur> copumpkin: what structure-preserving serialization?
09:50:53 <lambdabot> maybe. do you?
09:51:50 <copumpkin> jmcarthur: he wrote an evil/awesome serializer that takes an arbitrary (non-function, evaluated) closure and dumps it more or less as it appears in memory
09:52:11 <jmcarthur> :o
09:52:12 <mmorrow> copumpkin: it depends on if you need functions (references) included in there or not. for the data-only case, it's presently do-able for sure
09:52:17 <jmcarthur> that sounds horrible ;)
09:52:24 <copumpkin> yeah, data-only!
09:52:44 <mmorrow> copumpkin: but not in a nice package yet
09:52:52 <copumpkin> ideally I'd write a typeclass saying Dumpable and everything but function types (and types containing them) would be an instance
09:52:55 <jmcarthur> so this is good for saving structures that take advantage of sharing and such, i assume?
09:52:59 <mmorrow> (it := the code to do that)
09:53:11 <copumpkin> mmorrow: is it easily loadble too? because I remember that before you generated assembly code that need linking
09:53:41 <mmorrow> jmcarthur: basically it'd just be writing out the data vacuum sucks up, along with the (pkg,mod,con-name) and other structure-describing info
09:53:43 <stoop> Is there an MMX/SSE-optimized computational library available for Haskell yet?
09:53:50 <copumpkin> stoop: nope
09:54:03 <stoop> copumpkin, why haven't you written one yet?
09:54:03 <jmcarthur> nice/evil!
09:54:17 <stoop> copumpkin, or mmorrow?
09:54:32 * stoop prances into the darkness 
09:54:36 <copumpkin> mmorrow: basically my network chan is using Data.Binary.encode/decode right now, but that's painful for knot-tied structures and is probably less efficient than your dumpage
09:54:41 <mmorrow> copumpkin: i think it can be easy, yeah. possibly by just manufacturing our own infotables like ghci does
09:54:43 <copumpkin> stoop: because I'm busy
09:54:48 <copumpkin> :)
09:55:08 <mmorrow> which would then remove the need to do know the current runtime address of each "official" info table
09:55:27 <copumpkin> hmm
09:55:29 <mmorrow> (but you'd still need to relocate the closure in order to revive it)
09:55:50 <copumpkin> so it would require some pretty nasty hacks to load the dumped data at runtime right now ;)
09:56:01 <mmorrow> i.e., say you store ptrs as offsets from the start of the data, in bytes
09:56:12 <monochrom> send patches.  <duck>
09:56:18 <sproingie> stoop: Numeric.LinearAlgebra.LAPACK perhaps?
09:56:23 <mmorrow> given the addr you're writing that data to, you just run over it, and replace offsets with abs addresses
09:56:31 <mmorrow> then addrToHValue#
09:56:34 <copumpkin> hmm!
09:56:50 <copumpkin> sounds l33t ;)
09:57:03 <copumpkin> mmorrow: where's the code for all that again?
09:57:10 <copumpkin> I mean the dumpage
09:57:40 <mmorrow> copumpkin: actually i do have some code that might be useful/something http://moonpatio.com/repos/revive/
09:57:58 <mmorrow> i keep forgetting that repo's there (just three files, not a pkg)
09:58:01 <copumpkin> :)
09:58:03 <mmorrow> s/file/module/
09:58:39 <mmorrow> oh right, in that one i stole ObjLink, and was using that to get the addresses of the infotables from ghci's linker while in ghci
09:58:48 <copumpkin> hmm
09:59:01 <mmorrow> but i don't want to have to rely on ghci's linker
09:59:45 <mmorrow> copumpkin: you can just ask ghci's linker for the address of, say, ghczHZhzHZ_False_info, and it'll give it to you similar to dlopen()
10:00:03 <copumpkin> I see
10:00:13 <copumpkin> by the way, is there some way you can warn of function closures if you encounter them?
10:00:20 <copumpkin> to give some sort of fail-proofing?
10:00:29 <copumpkin> or do you already do that
10:01:01 <copumpkin> like dump :: a -> Maybe ByteString
10:01:02 <mmorrow> ah yeah, that'd be easy
10:01:11 <copumpkin> ah cool
10:01:44 <copumpkin> and it works on circular structures?
10:01:47 <kyagrd> I've got a QuickCheck automation working for polymorphic/overloaded properties under configurable finite type world assumption !!
10:02:03 <copumpkin> I see in your Revive.hs you have a cycle "abc" but you're just using it in a Map
10:02:44 <mmorrow> copumpkin: this is a nice vacuum e.g. too http://www.haskell.org/pipermail/haskell-cafe/2009-October/067929.html
10:03:00 <sproingie> i dunno i think it sucks
10:03:05 <sproingie> :-)=
10:03:06 <mmorrow> copumpkin: right, circular are ok, but infinite are not
10:03:10 <copumpkin> mmorrow: yeah
10:03:15 <copumpkin> makes sense
10:03:25 <mmorrow> if we could do functions, infinite would be fine too ;)
10:03:29 <copumpkin> yeah :P
10:03:33 <copumpkin> I'll wait for you to add that ;)
10:04:25 <ksf> you see, frp is a series of tubes.
10:04:47 <copumpkin> mmorrow: so your current implementation still spits out asm, so the cycle is: dump to asm, assemble to .o file, use ghci linker to load at runtime and then get an hvalue out of that?
10:05:02 <kyagrd> I tried several things GHC API too complicated, polytypeable kind of works but naming with modules is a mess, so I ended up using hint and regular expression trick to pick up type variables and doing it pretty much all in string manipulation.
10:05:05 <ksf> there can't be any infinite loops no matter how you code it, because water flowing through tubes either stops, rinses, turbulates, but in no way whatsoever stays inside forever.
10:05:35 <ystael> ksf: you know, "a series of tubes" would make a pretty good title for a book about the content of michiexile's course
10:05:39 <mmorrow> copumpkin: right, but the asm is /only/ as a convenient way to do the relocation automatically, and also a convenient way to link to the info tables
10:05:51 <kyagrd> It is very sad that it's just so hard to reify a type (including overloaded type) as a data structure and manipulate them and use it back in the program.
10:05:54 <pao> which is the reson for the 2**29-1 bound in haskell report?
10:06:34 <copumpkin> mmorrow: but you don't have a way of loading that stuff into memory except through the ghci linker right now
10:06:34 <pao> for Int type ... that is
10:06:35 <mmorrow> copumpkin: the two steps that need to be done in order to have dynamic (de)serialization working are
10:06:35 <copumpkin> pao: probably because they wanted 32 bits but wanted to make sure people could use tag bits if necessary
10:06:35 <ksf> you know, currently I'm considering it as the title for my frp implementation, as I provably have no idea about anything frp.
10:06:41 <pao> copumpkin: what are tag bits for?
10:07:21 <pao> copumpkin: ahhh I see... tell the type from the most significant bits
10:07:21 <ystael> poor ted stevens.  he's going to have that on his tombstone.
10:07:22 <copumpkin> pao: tagging values so you can know if they're pointers or values or possibly some primitive types
10:07:42 <pao> copumpkin: do any haskell implementation use tag bits?
10:07:48 <copumpkin> I think hugs might
10:07:49 <copumpkin> not sure
10:08:02 <mmorrow> (1) decide on a wire-format for raw data + reloc info, (2) write some code that does relocation, (3) write some code that manufactures an appropriate info table given a ((pkg,mod,con),nptrs,litwords,etc)
10:08:19 * Jafet read "tits"
10:08:22 <pao> copumpkin: thanks
10:08:26 <mmorrow> ghci does (3), so that shouldn't be a problem
10:08:38 <mmorrow> (2) is pretty straightforward, given (1)
10:08:44 <copumpkin> mmorrow: would any of those parts require the ghc api or changes to the runtime?
10:08:48 <Jafet> Why would a Haskell implementation used tag bits?
10:08:48 <mmorrow> none
10:08:57 <copumpkin> mmorrow: mmm
10:09:07 <mmorrow> copumpkin: so this all hinges on the ability to manufacture correct infotables
10:09:18 <ksf> actually, I first heard the term "series of tubes" on eve online.
10:09:34 <copumpkin> mmorrow: I'm assuming that would involve asking ghc to allocate some memory for us, and then poking bytes into it unsafely?
10:09:35 <mmorrow> copumpkin: so if you assume that, it works perfectly, but if they're incorrect, it's completely broken
10:09:54 <ksf> the "series of tubes" corp is the one amarr-militia corp that actually _can_ afford battleships, but gets raped every time, anyway.
10:10:12 <kyagrd> Jafet: I'm not sure about Haskell but OCaml and other functional languaeg used tag bits to distinguish pointer cells and value (machine integer) cellls
10:10:19 <ksf> ...at least the last time I was online, which is a while back.
10:10:20 <mmorrow> copumpkin: so i'm thinking maybe it'd be a good idea to build the infotables on-demand in the de-serializer, that way you wouldn't need to store them and then worry about if they're the correct word-size, etc
10:10:50 <Jafet> But OCaml is strictly typed!
10:11:10 <Jafet> ...well, there is the Num typeclass, but I'm not sure if that's relevant
10:11:15 <paolino> I need some help here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11011#a11011
10:11:16 <sproingie> ocaml erases nearly everything at runtime
10:11:42 <mauke> OCaml is heavily tagged
10:11:44 <copumpkin> mmorrow: how can you ask GHC to give you some memory on its heap?
10:11:46 <mmorrow> copumpkin: oh right. so you can just malloc any old memory, dump the data to it, relocate its internal refs from UIDs/Offsets/Whatever to abs addresses, and make sure all the infoptrs point to something that wouldn't cause the GC to asplode, then addrToHValue#. the critical part though is that all these closures are
10:12:02 <mauke> all integers are represented as n*2+1
10:12:04 <paolino> I'm not really sure I understood Traversable.mapM also
10:12:12 <copumpkin> mmorrow: "part though is that all these closures are" is the last I saw
10:12:14 <mmorrow> Foo_fib_static
10:12:16 <Vanadium> mauke: hah
10:12:21 <mmorrow> which means the collector never moves them
10:12:24 <ksf> @src mapM
10:12:24 <lambdabot> mapM f as = sequence (map f as)
10:12:31 <ksf> @src sequence
10:12:31 <lambdabot> sequence []     = return []
10:12:31 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:12:31 <lambdabot> --OR
10:12:31 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:12:36 <ksf> (you should know map)
10:12:41 <mmorrow> and they're never mutated with, but they'll get copied if/when needed
10:12:52 <paolino> ksf is Traversable.mapM
10:13:01 <mmorrow> *and they'll never be mutated, ..
10:13:08 <ksf> yep well that's the same.
10:13:13 <ksf> ...just follow the types.
10:13:39 <paolino> I tried but I have a type error in the code I pasted
10:13:42 <mmorrow> (but one interesting thing is that you have both the ptr to a haskell piece of data that you know will never nove)
10:13:52 <mmorrow> so *you* can mutate it if you want
10:13:58 <mmorrow> or pass it to C, etc
10:14:02 <copumpkin> mmorrow: hmm, so we'd ask for memory, turn off the GC, poke at that, turn the GC back on, and carry on as usual?
10:14:10 <benmachine> @type execStateT
10:14:12 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
10:14:12 <benmachine> er
10:14:16 <benmachine> @type runStateT
10:14:17 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
10:14:22 <copumpkin> mmorrow: well, you'd want it to be GCable, right?
10:14:25 <mmorrow> copumpkin: you don't have to turn anything off, just addrToHValue# :: Addr# -> a
10:14:34 <paolino> thanks benmachine
10:14:37 <benmachine> runStateT gets you a tuple
10:14:38 * ksf locks mmorrow and copumpkin into Monad Unsafe
10:14:38 <mmorrow> and that Addr# had better point to memory with a valid closure layout
10:14:43 <copumpkin> mmorrow: but while you're messing with the heap?
10:14:46 <mmorrow> or else the GC'll go down in flames
10:14:53 <mmorrow> it's not the heap
10:14:53 <benmachine> I'm not sure whether you want evalStateT or execStateT but I'm guessing it's one of them
10:14:59 <paolino> sure
10:15:02 <mmorrow> copumpkin: it's *outside* of the heap
10:15:02 <copumpkin> mmorrow: oh, so the Addr# can be anywhere at all?
10:15:09 <mmorrow> *_STATIC_*
10:15:15 <mmorrow> static closures closures
10:15:15 * ystael wonders if ksf is setting up a functional reactive BDSM site
10:15:21 <copumpkin> ah :o
10:15:26 <ksf> __unsafe_perform_haskell
10:15:27 <mmorrow> static closures
10:15:39 <mmorrow> (didn't mean that x2 :)
10:15:56 <copumpkin> mmorrow: but presumably somebody's gotta load it at runtime somewhere :P
10:16:04 <en0th> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4446#a4446
10:16:05 <en0th> What version of target_rows is better?
10:16:53 <mmorrow> void *o = malloc(92734); memcpy(o,buf,...); reloc(o,rinfo); ...
10:16:54 <mmorrow> (but in haskell of course.. :)
10:17:05 <copumpkin> okay, that's what I thought
10:17:27 <copumpkin> I just assumed the runtime didn't like haskell values living outside its playhouse
10:17:35 <mmorrow> but to emphasize that the memory has nothing to do with haskell/ghc *until* you addrToHValue# it
10:18:11 * ksf tries to read copumpkin's and mmorrow's posts as some ingenious kind of code
10:18:31 <copumpkin> ksf: I'm just as clueless
10:18:41 <mmorrow> copumpkin: static closures are what ghc would generate for e.g. "x = [0,1::Int]" at top-level
10:19:16 <mmorrow> copumpkin: so they're essentially the exact same memory image as would exist in the generated asm, had those closures been entirely statically generated by ghc
10:19:27 <copumpkin> I see
10:19:35 <mmorrow> (but of course, ghc wouldn't statically render a 1GB IntMap to a .s ..)
10:19:45 <Tobsan> @yarr
10:19:45 <lambdabot> Ahoy mateys
10:19:56 <copumpkin> @@ @elite @yarr
10:19:57 <lambdabot>  ArR! me z|-|iP B3 t|-|e BIGgezt BRi9 iN +He Por+!
10:19:59 <mmorrow> but /you/ can if you like.. :)
10:20:22 <copumpkin> mmorrow: sounds hardcore :P I really want this so I'll poke around a bit, but I doubt I'll get very far
10:20:32 <copumpkin> I get the basic idea
10:21:11 <mmorrow> copumpkin: just write "module A where\nasdf = ([0,1::Int],())", ghc -O2 -S A.hs, then read the .s
10:21:21 <mmorrow> copumpkin: you'll be like "oh."
10:23:50 <hackagebot> TrieMap 0.5.3 - Automatic type inference of generalized tries. (LouisWasserman)
10:25:01 <copumpkin> mmorrow: ugh, the asm is such a mess :P
10:25:06 <copumpkin> but I think I can see
10:25:57 <copumpkin> so I get a I# static info pointer before each value
10:26:07 <copumpkin> for the Int box
10:26:23 <mmorrow> copumpkin: yeah, it's kind of nasty, but a little "expand -t 2" and touching up by hand slightly, and it's half-readable
10:26:27 <FunctorSalad> I haz a I#, what I do with it?
10:26:30 <mmorrow> right, exactly
10:26:31 <FunctorSalad> ;)
10:26:38 <mmorrow> and a list is literally
10:26:44 <mmorrow> []_static_info
10:26:51 <mmorrow> <ptr_to_head>
10:26:55 <copumpkin> yeah
10:26:57 <mmorrow> <ptr_to_tail>
10:27:05 <copumpkin> preflex: zdec _ghczmprim_GHCziTypes_ZC_static_info
10:27:05 <preflex>  _ghc-prim_GHC.Types_:_static_info
10:27:11 <copumpkin> makes sense
10:27:14 <mmorrow> err, yeah ..
10:27:25 <mmorrow> (s/[]/:/ i meant ;)
10:27:33 <copumpkin> :)
10:27:59 <copumpkin> preflex: zdec _ghczmprim_GHCziTypes_ZMZN_closure
10:28:00 <preflex>  _ghc-prim_GHC.Types_[]_closure
10:28:14 <copumpkin> okay, it all makes sense now
10:28:16 <copumpkin> :P
10:28:35 <copumpkin> so the real issue with serializing it is not hardcoding those closure addresses in
10:28:39 <copumpkin> the static data is static
10:28:47 <copumpkin> -the
10:29:01 <benmachine> @type map
10:29:02 <mmorrow> yeah, when you actually look at it, it all seems totally straightforward
10:29:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:29:16 <mmorrow> copumpkin: exactly
10:29:35 <mmorrow> so one way would be to store them as offsets from zero
10:29:51 <mmorrow> which zero := the address of the root closure
10:29:58 <copumpkin> ah
10:30:08 <copumpkin> is that stable?
10:30:11 <copumpkin> I mean, the offset
10:30:58 <mmorrow> well, you write the next closure at the next available free space in your target bytestring
10:31:05 <mmorrow> so you /make it/ stable
10:31:12 <copumpkin> oh, I meant the references to standard lib closures
10:31:31 <FunctorSalad> can you define a Control.Category "strict haskell"?
10:31:39 <FunctorSalad> or will it always be lazy somewhere
10:31:40 <copumpkin> things like _ghczmprim_GHCziTypes_Izh_static_info
10:31:55 <mmorrow> oh, you get every piece of data's (pkg,mod,conname) from their infotable
10:31:56 <benmachine> @src fix
10:31:57 <lambdabot> fix f = let x = f x in x
10:32:05 <copumpkin> mmorrow: ah, I see
10:32:10 <benmachine> ^ any reason why this is not just fix f = f (fix f)
10:32:13 <mmorrow> so it doesn't matter if they're stable, since you ditch their ptrs and just keep the names
10:32:19 <copumpkin> so you'd store that triple whenever you had one of those
10:32:28 <mmorrow> you can also s/offsets/uids/
10:32:39 <FunctorSalad> benmachine: efficiency... f is static
10:32:43 <mmorrow> which you just hand out starting at 0
10:32:49 <benmachine> @type fix
10:32:50 <lambdabot> forall a. (a -> a) -> a
10:32:57 <mmorrow> copumpkin: right
10:33:08 <copumpkin> hmm
10:33:23 <copumpkin> this seems doable
10:33:42 <kyagrd> Is this function in a library (by some other name)?
10:33:43 <mmorrow> copumpkin: in that GenAsm module, it takes the info vacuum has, and deduces the _static_info label name from that triple, then renders the closure rep from the IntMap to asm
10:33:47 <kyagrd> @let substitutions xs ts = map (zip xs) $ foldr (liftM2 mplus) (return mzero) [liftM return ts | _ <- xs]
10:33:49 <lambdabot>  Defined.
10:33:54 <kyagrd> @type substitutions
10:33:55 <lambdabot> forall a a1. [a] -> [a1] -> [[(a, a1)]]
10:34:21 <kyagrd> > substitutions ["a","b"] [True,False]
10:34:22 <lambdabot>   [[("a",True),("b",True)],[("a",True),("b",False)],[("a",False),("b",True)],...
10:34:32 <kyagrd> > substitutions ["a","b"] [1,2,3]
10:34:34 <lambdabot>   [[("a",1),("b",1)],[("a",1),("b",2)],[("a",1),("b",3)],[("a",2),("b",1)],[(...
10:35:37 <copumpkin> hmm
10:35:54 <kyagrd> or would there be more cleaner way to define this with some more well known convention
10:36:22 <mmorrow> copumpkin: and this is an instance of asm that module spits out http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3554
10:36:43 <kyagrd> Its basically all mappings from xs to ts where xs and ts are both finite
10:37:44 <mmorrow> , (\xs ys -> [(x,y) | x <- xs, y <- ys]) ["a","b"] [True,False] {- this ? -}
10:37:45 <lunabot>  [("a",True),("a",False),("b",True),("b",False)]
10:37:56 <kyagrd> no
10:37:56 <mmorrow> err
10:38:03 <kyagrd> different type
10:38:17 <mmorrow> oh
10:39:27 <mmorrow> > substitutions [0..2] ["a"]
10:39:28 <lambdabot>   [[(0,"a"),(1,"a"),(2,"a")]]
10:39:34 <mmorrow> > substitutions [0..2] ["a","b"]
10:39:36 <lambdabot>   [[(0,"a"),(1,"a"),(2,"a")],[(0,"a"),(1,"a"),(2,"b")],[(0,"a"),(1,"b"),(2,"a...
10:39:42 <mmorrow> > length $ substitutions [0..2] ["a","b"]
10:39:43 <lambdabot>   8
10:39:47 <mmorrow> > fmap length $ substitutions [0..2] ["a","b"]
10:39:49 <lambdabot>   [3,3,3,3,3,3,3,3]
10:39:58 <mmorrow> > fmap length $ substitutions ["a","b"] [0..2]
10:40:00 <lambdabot>   [2,2,2,2,2,2,2,2,2]
10:40:38 <kyagrd> It's a hom-set in a category theory ... Set(X,Y)
10:41:32 <mmorrow> well, it's every possible combination
10:41:46 <FunctorSalad> @let sub xxs ys = go xxs where  { go []  = [[]]; go (x:xs) = [ (x,y) : rest | y <- ys; rest <- go xs ] }
10:41:46 <lambdabot>   Parse error: SemiColon
10:41:51 <mmorrow> err, what's the category?
10:41:52 <copumpkin> mmorrow: so it seems like you'd want something like a zero-based array of Closure values, where a Closure is a list of ClosureElement, which can be LocalRef Int | OutsideRef ClosureInfoTriple | RawData ByteString ?
10:42:11 <FunctorSalad> @let sub xxs ys = let { go []  = [[]]; go (x:xs) = [ (x,y) : rest | y <- ys; rest <- go xs ] } in go xxs
10:42:11 <lambdabot>   Parse error: SemiColon
10:42:20 <kyagrd> mmorrow: category of finite sets
10:42:29 <mmorrow> copumpkin: right, something exactly like that.
10:42:32 <FunctorSalad> @let sub xxs ys = let { go []  = [[]]; go (x:xs) = [ (x,y) : rest | y <- ys, rest <- go xs ] } in go xxs
10:42:34 <lambdabot>  Defined.
10:42:46 <kyagrd> sub ['a','b'] [1]
10:42:50 <FunctorSalad> > sub [0,1] [6,7,8]
10:42:51 <lambdabot>   [[(0,6),(1,6)],[(0,6),(1,7)],[(0,6),(1,8)],[(0,7),(1,6)],[(0,7),(1,7)],[(0,...
10:42:55 <mmorrow> kyagrd: ooh, speaking of this i've got some pullback code with Maps that i particularly like
10:42:59 <kyagrd> > sub ['a','b'] [1]
10:43:01 <lambdabot>   [[('a',1),('b',1)]]
10:43:04 <kyagrd> > sub ['a','b'] [1,2]
10:43:06 <lambdabot>   [[('a',1),('b',1)],[('a',1),('b',2)],[('a',2),('b',1)],[('a',2),('b',2)]]
10:43:09 <kyagrd> > sub ['a','b'] [1,2,3]
10:43:11 <lambdabot>   [[('a',1),('b',1)],[('a',1),('b',2)],[('a',1),('b',3)],[('a',2),('b',1)],[(...
10:43:16 <FunctorSalad> no fancy PL but pretty intuitive imho ;)
10:43:20 <kyagrd> oh this is what it is
10:43:37 <copumpkin> mmorrow: maybe I'll hack that into your output code and throw together a simple Binary instance for it
10:43:55 <copumpkin> mmorrow: is graphToAsm in Maybe to deal with function closures?
10:44:44 <FunctorSalad> @let subb xxs ys = foldr (\x rests -> [ (x,y) : rest | y <- ys, rest <- rests ]) [[]] xxs
10:44:45 <lambdabot>  Defined.
10:44:50 <FunctorSalad> > subb [0,1] [6,7,8]
10:44:51 <lambdabot>   [[(0,6),(1,6)],[(0,6),(1,7)],[(0,6),(1,8)],[(0,7),(1,6)],[(0,7),(1,7)],[(0,...
10:45:11 <kyagrd> > subb [0,1] [a,b]
10:45:12 <lambdabot>   [[(0,a),(1,a)],[(0,a),(1,b)],[(0,b),(1,a)],[(0,b),(1,b)]]
10:45:18 <kyagrd> > subb [0,1] [a,b,c]
10:45:19 <lambdabot>   [[(0,a),(1,a)],[(0,a),(1,b)],[(0,a),(1,c)],[(0,b),(1,a)],[(0,b),(1,b)],[(0,...
10:45:37 <kyagrd> oh that foldr works
10:46:01 <FunctorSalad> you can rewrite the list comprehension as some liftM2 too ;)
10:46:40 <mmorrow> kyagrd: found it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4447
10:47:03 <mmorrow> copumpkin: cool, good luck
10:47:23 <copumpkin> mmorrow: gonna see if I can even get your plain revive working first of all :)
10:47:29 <mmorrow> copumpkin: oh yeah, that's exactly what it's for now that i think of it
10:48:19 <mmorrow> it should work no problem, it's self-contained
10:48:41 <mreh> what is the stereotypical haskell user?
10:48:56 <Arnar> hey guys..
10:48:59 <mreh> I should say "who is"
10:48:59 <Arnar> before I dive into it
10:49:27 <Arnar> does anyone know if there is already a javascript (i.e. ecmascript 3) parser available on hackage or elsewhere?
10:49:28 <copumpkin> mmorrow: it depends on vacuum only, right?
10:49:30 <shambler> mreh, you'll never know
10:49:52 <mreh> we're like ghosts
10:50:03 <copumpkin> we're like wannabe mathematicians
10:50:07 <shambler> hehe
10:50:08 <copumpkin> I am, at least
10:50:09 <mreh> it could be the man next door
10:50:09 <mmorrow> copumpkin: right
10:50:21 <mreh> you know why I dont use emacs? Richard Stallman.
10:50:58 <shambler> is he so bad for you?
10:51:07 <mreh> http://www.softpanorama.org/People/Stallman/Images/saintignucius.jpg
10:51:10 <mreh> yes
10:51:16 <copumpkin> mmorrow: yay, gonna go get some food and start hacking on it when I get back! I want to start work on an easy distributed computation library and it would be nice to be able to send arbitrary data
10:52:20 <mmorrow> copumpkin: ooh yay, sounds sweet
10:52:24 <mreh> I thought he was an Atheist anyway
10:52:32 <copumpkin> mmorrow: one last thing. how about platform-specific types? I guess we'd have to avoid using the types that change size across platforms?
10:52:39 <shambler> at least he's funny
10:52:40 <copumpkin> like Int and Word?
10:52:55 <copumpkin> mmorrow: also, does it deal with arrays and Integers?
10:53:32 <mmorrow> copumpkin: oh right, yeah we'd have to deal with that somehow. well, it'd more just be defining what we do do, then doing it.
10:53:44 <mreh> "Choose tap water rather than bottled water." No Richard, that's how they control your mind!!!
10:54:03 <mmorrow> copumpkin: oh right, the thing with arrays is that ghc doesn't ever make static closures of them
10:54:23 <copumpkin> mmorrow: same issue with Integer then? assuming integer-gmp on the back-end?
10:54:26 <mmorrow> there's a ticket to add that actually (or at least talk, or something)
10:55:11 <mreh> he's made emacs into a moral issue, I have no idea how, or why, he's a trendy leftist with an authoritarian streak
10:55:17 <mmorrow> copumpkin: i'm not sure, you can always just make a new ByteArray, then memcpy the data into it when reviving or something
10:55:21 <copumpkin> ah
10:55:34 <copumpkin> cool :) this package should be called omnom :P
10:55:50 <mmorrow> hah, i second the name :)
10:56:05 <shambler> just imagine that emacs is written by someone else
10:56:09 <copumpkin> okay, bbiab
10:58:18 <mreh> shambler: it's not the real reason why I dont use emacs :)
10:58:27 <shambler> ahha!
10:59:52 <mreh> is there anyway I could be convinced that emacs is at all useful to me? I use IDEs with nice code completion, source code linking, compilation on the fly etc etc
11:01:02 <shambler> and that would be... eclipse? visual studio >_< ??
11:01:09 <mmorrow> mreh: code in a language you just invented?
11:03:19 <mreh> any language I write will be garbage
11:03:28 <sproingie> emacs+flymake is nice with haskell
11:03:57 <medfly> if you don't want to use emacs then don't
11:04:00 <kyagrd> Editors don't support terminal modes (ansi, vt etc) do not have enough expierience points to join the holy editor war
11:05:13 <medfly> no big deal, it's still only personal preference in the end
11:06:38 <mmorrow> no way, emacs suks, vim rulz
11:07:55 <dschoepe> `simpleHTTP $ getRequest "http://google.com/"' (one of the example from Network.HTTP) fails with "'some_character': openFile: does not exist". What could be the cause of this?
11:09:30 <mmorrow> @tell copumpkin here's the smlnj code related to their binfiles. a long and good comment at the start describing the (1)format,(2)considerations,(3)misc-related-things   http://moonpatio.com/repos/LIBS/Language/smlnj/compiler/Execution/binfile/binfile.sml
11:09:30 <lambdabot> Consider it noted.
11:10:45 <monochrom> You could not be convinced.
11:11:39 <mreh> that's just unfalsifiable doctrine <:(
11:12:04 <mreh> i'll try it out, see if it floats my boat
11:12:23 <Berengal> Emacs is a kick-ass editor, but it's not the best at everything
11:12:53 <lament> for example there're better psychiatrists
11:12:59 <p_l> Berengal: it's a quite nice single-user/cooperative multitasking OS, but it could get a better editor ;-)
11:13:09 * trzkril want's a multi-threaded emacs written in a sane language
11:13:24 <sproingie> emacs has a mode for editing text?  huh.
11:13:25 <Berengal> trzkril, like C?
11:13:33 <lament> trzkril: Eclipse?
11:13:45 <FunctorSalad> is there any point to this category? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11015#a11015
11:14:03 <FunctorSalad> or is the strictness negated somehow by haskell's lazyness
11:14:06 <monochrom> You have insisted on code completion. Emacs haskell mode lacks that. You have shut the door. I'm just carrying out known true statements to their logical conclusion.
11:14:20 <Berengal> lament, I found emacs keybindings in eclipse a while ago. It was horrible and painful, and made me install emacs despite being on windows
11:14:37 <FunctorSalad> (will this category have all the nice properties like Void being initial?)
11:14:44 <FunctorSalad> (which it isn't in Hask)
11:15:19 <lament> Berengal: and yet, emacs users keep recommending me to try the vim mode in emacs.
11:15:49 <sproingie> i doubt vi emulators are going to satisfy a vim user
11:15:52 <Berengal> lament, emacs, at least, has a kill-ring, and a more sane extention language than java
11:15:53 <lament> which is similarly horrible and painful, but at least i already have vim installed
11:16:25 <trzkril> Berengal: i did not mean the language the core is written in, but the extension language
11:16:35 <trzkril> lament: and you seem to be joking badly
11:16:54 <sproingie> naturally we should all be using Yi
11:17:03 <sproingie> would be nice if Yi even compiled out of hackage
11:17:38 <lament> Berengal: i'm not sure sanity is a valid, useful, or appropriate metric for extension languages
11:18:03 <Berengal> lament, I am
11:18:22 <Berengal> (Not that elisp is sane, but it's at least san/er/)
11:18:25 <lament> Berengal: i'd go with things like ease of use, popularity, readability
11:19:49 <tuukkah> bos, ping
11:20:31 <trzkril> lament: readability is a must, popularity is nice to have
11:20:50 <trzkril> lament: but i don't see the readability of eclipse plugins
11:21:47 <lament> honestly, with regard to *sanity*, there's something thoroughly insane in creating your own extension language in the first place. Compare xchat (scripted in Perl/Python/Ruby) with mIRC (scripted in mircscript)
11:22:25 <sproingie> plenty readable if you know java, the problem is accessability.  emacs has every function browseable, usually with help, and immediately replaceable
11:22:33 <lament> (and sure, bash is a good counterexample, but not convincing enough in this case)
11:22:36 <trzkril> sproingie: java + xml, afair
11:24:04 <McManiaC> how can i compile cabal without root privileges?
11:24:23 <McManiaC> i need something like runghc Setup.hs install --root-dir=~/...
11:24:27 <sproingie> just do it, it'll install in .cabal
11:24:31 <sproingie> er ~/.cabal
11:24:43 * EnglishGent also want's a multi-threaded emacs written in a sane language
11:24:56 <EnglishGent> hi trzkril :)
11:25:20 <sproingie> i want a pony
11:25:34 * EnglishGent wants a horse
11:25:35 <monochrom> xmonad demonstrates that haskell is a sane readable popular easy extension language.
11:25:40 <EnglishGent> :)
11:25:43 <Twey> http://hackage.haskell.org/package/pony
11:25:59 <sproingie> for a window manager that only a particular subculture considers sane
11:26:04 <McManiaC> sproingie: Setup.hs: /usr/local/share/doc/Cabal-1.6.0.2: createDirectory: permission denied (Permission denied)
11:26:16 <EnglishGent> I'd agree with all of that monochrom - except 'popular'
11:26:16 <EnglishGent> :|
11:26:24 <sproingie> McManiaC: huh, didn't happen when i tried it, dunno
11:26:31 <monochrom> I said it to start a controversy.
11:27:07 <sproingie> i'd like a window manager that isn't quite so dogmatic about tiling vs floating
11:27:22 <sproingie> i know xmonad does some floating stuff but it hardly satisfies
11:27:56 <jmcarthur> i would hardly call xmonad dogmatic about that
11:27:58 <sproingie> i want to take floating windows and glue their edges together so it becomes a splitter
11:28:17 <sproingie> then take the window decorations and apply it to that uber-window instead
11:28:19 <Twey> Nice
11:28:30 <Twey> Good idea
11:28:32 <sproingie> i'll never find such a WM unless i go write it myself
11:28:34 <jmcarthur> i like that
11:28:34 <Twey> Patch xmonad :
11:28:52 <jmcarthur> i have a feeling it would work as an xmonad extension
11:29:00 <Twey> Most likely
11:29:28 <copumpkin> mmorrow: or I guess revive works as a package name too :P doesn't have to be omnom
11:29:29 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
11:29:43 <monochrom> I have figured out why programmers are obsessed with tiling, and why web page designers are obsessed with 2048x1784 layouts. They can afford quad-head 42" monitors.
11:29:53 <copumpkin> only quad?
11:30:02 * copumpkin has 8 2560x1600 monitors
11:30:03 <sproingie> i have a single 27" monitor, it's still big enough
11:30:14 <Baughn> I'm using a 15" monitor. Tiling's fine.
11:30:15 <sproingie> if i had a netbook then i might be more gung ho about tiling
11:30:24 <monochrom> Clearly, I'm outdated as to how rich they are!
11:30:26 <jmcarthur> monochrom: i disagree. i find that tiling window managers are almost a necessity for small screens
11:30:55 <jmcarthur> for myself, of course
11:30:55 <copumpkin> fine, I was kidding
11:30:56 <copumpkin> :(
11:31:09 <Twey> They are indeed
11:31:10 <monochrom> I disagree. I find tiling unusable on low-res screens.
11:31:14 <Twey> Unless you like doing everything full-screen
11:31:22 <lament> I always keep windows maximized
11:31:25 <burp> I find tiling always unusable ;)
11:31:41 <lament> Except for terminal windows
11:31:45 <burp> ok
11:31:50 <burp> except for that
11:32:34 <jmcarthur> the only reason i can think of to look at stacked wms for small screens is for when you would rather overlap a window instead of resizing one.... which is rectified in xmonad with magnifiers anyway
11:33:32 <jmcarthur> and by overlap i mean partially overlap, of course
11:33:42 <Baughn> All my workspaces have the setup of 'single main app - one-three terminals'. Xmonad handles that nicely, and I don't have to manually resize anything.
11:33:44 <jmcarthur> with fully overlapping you might as well just use a full screen layout anyway
11:33:49 <Baughn> It was a real annoyance back on os x
11:33:55 <monochrom> I find the only way tiling works for low-res is the degenerate case of one window spanning the whole screen, i.e., maximize everything, i.e., DOS multitasking.
11:34:11 <jmcarthur> monochrom: then what's the point of a stacking wm anyway?
11:34:13 <lament> right now i have six windows open, five of them are maximized and the sixth is a terminal
11:35:10 <monochrom> I just need to see part of other windows.
11:36:02 * jmcarthur is using a tiled layout with partially overlapping windows right now
11:37:25 <monochrom> Doesn't that degenerate to stacking?
11:37:34 <jmcarthur> i've got it set up so that no matter what layout i'm using, i can grow and shrink the current window as though it was on top
11:38:05 <jmcarthur> not really
11:38:23 <jmcarthur> it doesn't require the mouse at all, and i can still lay everything out with tiling
11:38:50 <monochrom> Stacking doesn't require the mouse either, if we're talking about the same stacking.
11:39:14 <jmcarthur> it's like popping the current window out from the layout to magnify it, but in its original place in the layout
11:39:15 <monochrom> I just press alt-tab to switch between windows.
11:39:39 <jmcarthur> but you have to move them with the mouse
11:40:09 <monochrom> At window creation time I move with mouse once. That is all.
11:40:32 <monochrom> Some programs even spare that.
11:40:59 <tuukkah> has anyone tried to implement compositing in xmonad?
11:41:14 <jmcarthur> tuukkah: not in xmonad itself, but i'm using it with xcompmgr
11:41:44 <tuukkah> jmcarthur, it doesn't enable scaling windows or anything like that, does it?
11:42:06 <jmcarthur> tuukkah: as far as i know xcompmgr doesn't do anything like that
11:42:26 <hackagebot> fsmActions 0.4.0 - Finite state machines and FSM actions (AndyGimblett)
11:42:50 <tuukkah> so i suppose no-one found it worthwhile this far
11:43:31 <jmcarthur> tuukkah: found what worthwhile? some particular effect? doing it in xmonad? doing it in xcompmgr? compiz?
11:43:40 <monochrom> I also don't like changing window size every time it is switched out or switched in. Window sizing changing has some consequence to program-specific layout inside the window. For example xchat and thunderbird. If you resize it very small, you lose your previously laborously set divider positions inside.
11:43:47 <tuukkah> jmcarthur, doing compositing in xmonad
11:44:12 <jmcarthur> monochrom: i was worried about that when i switched, but i have not had a single problem of that nature, which surprises me
11:44:30 <tuukkah> monochrom, window scaling would help there :-)
11:44:42 <jmcarthur> tuukkah: would there be a benefit to doing it in xmonad instead of in a compositing manager?
11:45:00 <jmcarthur> or perhaps it would be necessary, even?
11:45:09 <jmcarthur> i'm not very familiar with how it all works
11:45:37 <maltem> monochrom, moving and resizing windows once at window creation time is the problem that tiling solves for me
11:45:47 <Baughn> Is there reason to prefer monads-tf/fd over transformers?
11:46:12 <maltem> Baughn, those libs are complementary, if I'm not mistaken
11:46:23 <maltem> that is, monads-blah requires transformers
11:46:37 <monochrom> maltem, I almost never resize windows. I move windows at most once at creation, the average is really like 0.5.
11:46:41 <Baughn> So it does. Hm..
11:46:51 <tuukkah> jmcarthur, i'm sure you could do scaling in a compositing manager as well, but the effects are much easier to do when the window manager is fully in control of the rendering
11:46:57 <monochrom> IOW the problem doesn't exist, there is nothing to solve.
11:46:58 <Baughn> maltem: Maybe I should say, is there reason to prefer monads-fd over -tf, or vice versa?
11:47:44 <jmcarthur> tuukkah: where do things like GTK fit into everything then?
11:47:57 <jmcarthur> tuukkah: i was under the impression than xmonad did no rendering at all
11:48:00 <jmcarthur> *that
11:48:01 <maltem> Baughn, GHC is more competent on functional dependencies, but type families are more fun
11:48:32 <maltem> which is to say, no, I don't know of a recommendation of one over the other
11:48:45 <monochrom> I should switch from defensive to offensive, and say what problem tiling creates.
11:48:52 <tuukkah> jmcarthur, the way compositing works in any case is that each application renders its window offscreen, then the manager uses those windows as pixmaps to render the screen
11:48:55 <Baughn> maltem: I'll go with -tf, then. I like fun. :P
11:49:39 <jmcarthur> tuukkah: what do we gain by placing that in the wm instead of a compositor?
11:49:48 <maltem> monochrom, to make this clear, I don't have a problem with your not appreciating tiling
11:50:09 <tuukkah> jmcarthur, at least, we don't need a complex protocol between the wm and the cm
11:50:35 <tuukkah> i could imagine there being some synchronisation issues as well
11:50:38 <jmcarthur> tuukkah: i currently communicate with xcompmgr via normal commands
11:50:44 <jmcarthur> which isn't that difficult
11:51:24 <tuukkah> jmcarthur, umm, what does that let you communicate? whichever window properties xcompmgr takes into account in its rendering?
11:52:12 <jmcarthur> actually i think some of it works by setting window properties
11:52:28 <jmcarthur> but there are some command line tools to manipulate windows, too
11:52:52 <copumpkin> mmorrow: oh, your summarize function already basically does everything
11:53:00 <jmcarthur> like i said, i don't know this stuff very deeply :)
11:53:28 <p_l> AFAIK xcompmgr scans the windows for property that defines their transparency and maybe checks for ARGB windows as well
11:53:50 <jmcarthur> that sounds about right
11:53:56 <tuukkah> the command line tools probably set window properties
11:54:00 <jmcarthur> yeah
11:54:11 <jmcarthur> which xmonad can just set itself anyway i think
11:54:29 <hackagebot> darcs-benchmark 0.1.3 - Comparative benchmark suite for darcs. (PetrRockai)
11:54:50 <tuukkah> so for any effects you want to implement in xmonad, you have to have xcompmgr implement the necessary window properties
11:55:05 <jmcarthur> right
11:55:11 <jmcarthur> which i would expect
11:55:31 <monochrom> With tiling, windows out of focus but still needed to be show will have to be made smaller than ideal. You can scale down, but this is not suitable for some windows. You can resize or let it be overlapped on, but then you have to choose which part of the content is still shown by scrolling, and at different times you may want different parts shown. Scrolling is slow, keyboard or mouse. This is no improvement over conventional
11:55:31 <monochrom>  window management.
11:55:36 <jmcarthur> one would need to do a similar thing to implement the compositing in xmonad itself. it should would skip the step of reading X window properties
11:55:37 <tuukkah> and when there's multiple properties, windows, animation involved, you might imagine getting synchronisation issues
11:56:24 <jmcarthur> monochrom: mod-j, pagedown pagedown, mod-k. just like you would in a stacked wm
11:56:30 <tuukkah> monochrom, xmonad could be taught to do the appropriate thing based on the app whose windows they are
11:56:38 <jmcarthur> monochrom: that was a defensive argument again, not offensive :P
11:56:47 <Paczesiowa> does ghc use Wadler's idea from 1990 for auto-deforestation [Deforestation: transforming programs to eliminate trees] ?
11:56:48 <Baughn> What's the correct way to throw an exception in STM? Just throw?
11:57:04 <jmcarthur> tuukkah: the animation is a compositor issue, afaik
11:57:32 <hackagebot> fsmActions 0.4.1 - Finite state machines and FSM actions (AndyGimblett)
11:57:36 <jmcarthur> tuukkah: xcompmgr lets you set a fade animation for when you change opacity, for example
11:57:53 <tuukkah> jmcarthur, declarative animation - yet another big requirement on the communication interface
11:58:33 <jmcarthur> tuukkah: set opacity, xcompmgr figures out what animation to do
11:59:05 <tuukkah> jmcarthur, that won't work in the general case. as it is, it's just some special cases to give you some eye candy
11:59:27 <jmcarthur> tuukkah: perhaps not, but i can't think of anything that would require more fine grained control from the wm
12:00:01 <jmcarthur> tuukkah: to be clear, i'm not really trying to argue. i only want to understand
12:00:05 <tuukkah> jmcarthur, depening on the effect, you may need to do the fade fast or slow?
12:00:15 <jmcarthur> and counterpoint is how i'm expressing my understanding or lack thereof
12:01:10 <jmcarthur> tuukkah: that can't be a window property?
12:03:27 <tuukkah> jmcarthur, it can be, but it's yet another special case toward general declarative graphics & animation system :-)
12:04:56 <tuukkah> jmcarthur, an example of the synchronisation issue would be if you needed to change two aspects at the same time, and xcompmgr did a render between those properties are set
12:05:27 <jmcarthur> tuukkah: that sounds to me like something the composition manager should worry about, not the wm
12:05:56 <jmcarthur> if it's aware of everything having to do with animations then it's aware of how to handle multiple animations
12:07:16 <tuukkah> jmcarthur, but you can't set multiple window properties atomically, so this system would need to handle all via a single window property
12:07:50 <mreh> ./leksah: symbol lookup error: ./leksah: undefined symbol: gtk_source_language_manager_guess_language
12:08:02 <mreh> I JUST fixed that problem, now it's come back
12:08:27 <tuukkah> anyway, everyone's doing combined compositing window managers instead of separating the roles, as it didn't work out for them :-)
12:08:34 <mreh> this is when I run the binary, not try and install it
12:08:50 <trofi> linker dislikes you
12:09:47 <mreh> trofi: I have installed several versions of this library that fixed this issue with compilation
12:10:13 <mreh> could it be looking in the wrong lib? clearly that's what it is doing, but how?
12:10:14 <mmorrow> copumpkin: yeah, summarize is the goods
12:10:45 <trofi> mreh: what distro do ou use?
12:10:56 <trofi> mreh: ran ldconfig?
12:11:00 <mreh> trofi, debian
12:11:49 <trofi> does 'ltrace -etrace=dlopen ./leksah' show anything interesting?
12:11:52 <mreh> of course! thx
12:11:57 <mreh> it works trofi
12:12:01 <trofi> cool :]
12:16:22 <paolino> anyone has an hint on how to test each node of a subtree of a rosetree match a condition ?
12:17:15 <McManiaC> ehm
12:17:17 <copumpkin> mmorrow: this isn't good: *GHC.Vacuum.GenAsm> omnom (+1)
12:17:17 <copumpkin> Just (Chunk "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ETX\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL" Empty)
12:17:18 <copumpkin> :P
12:17:24 <McManiaC> how can i install packages from hackage without cabal? ^^
12:17:52 <paolino> runhaskell Setup ....
12:18:04 <paolino> configure , build , install
12:18:32 <paolino> Setup is inside the tarball
12:19:05 <monochrom> paolino: write a function to recurse over the whole tree.
12:20:15 <mmorrow> copumpkin: hehe
12:20:26 <paolino> monochrom: I wish for something more hint
12:20:33 <copumpkin> mmorrow: I think your Maybe in graphToAsm doesn't catch functions or something :P
12:21:04 <paolino> monochrom: I need to prune those subtrees
12:21:27 <mmorrow> hmm, checking... (that should be a PAP i believe, which shouldn't have any info in the summary, but maybe i botched the bool check)
12:21:59 <sinelaw> can someone give a simple example for polymorphic recursion?
12:22:07 <sinelaw> i don't understand what that exactly means
12:22:45 <mmorrow> copumpkin: hmm
12:22:46 <mmorrow> ghci> (fmap summary . Data.IntMap.elems . vacuum) (+1)
12:22:47 <mmorrow> [(["","",""],[],[])]
12:23:10 <copumpkin> oh maybe it does work
12:23:19 <copumpkin> I just tried the toAsmAndHsStub function on it
12:23:28 <copumpkin> but I guess that isn't checking the maybe
12:23:38 <hackagebot> TrieMap 0.5.4 - Automatic type inference of generalized tries. (LouisWasserman)
12:24:16 <mmorrow> and
12:24:19 <mmorrow> any (null . fst . snd)
12:24:26 <mmorrow> um
12:24:38 <copumpkin> that's just checking the package name isn't it?
12:24:44 <mmorrow> oh
12:24:50 <copumpkin> oh wait
12:24:50 <mmorrow> type Summary = ([String],([Int],[Word]))
12:24:54 <mmorrow> (Int,Summary)
12:24:54 <copumpkin> no, it's the list of references
12:25:03 <mmorrow> oh right, anything without ptrs
12:25:19 <mmorrow> that's probably a kinda of bad check though
12:25:34 <copumpkin> I wonder why my dump didn't catch the +1 then
12:25:38 <copumpkin> I'm using the same logic
12:25:45 <mmorrow> what do you get in ghci
12:26:00 <mmorrow> (fmap summary . Data.IntMap.elems . vacuum)
12:26:12 <mmorrow> err, what ghc are you using too
12:26:13 <mmorrow> ?
12:26:23 <copumpkin> *GHC.Vacuum.GenAsm GHC.Vacuum Data.IntMap> (fmap summary . Data.IntMap.elems . vacuum) (+1)
12:26:23 <copumpkin> [(["","",""],[],[])]
12:26:25 <copumpkin> you're right
12:26:32 <mmorrow> weird
12:26:33 <copumpkin> 6.10.4
12:26:39 <copumpkin> I must've just messed something up :)
12:28:24 <mmorrow> oh, and before i forget/so i remember. after talking earlier about (Byte)Array/Integers/etc, it'd be nice to add to vacuum the ability to slurp up (Byte)Array#'s when it encounters them
12:28:25 <copumpkin> yeah
12:28:33 <copumpkin> maybe I'll take a look at that if I get this working
12:28:51 <mmorrow> ooh. ok, and i want to mention this too before i forget again.
12:29:29 <mmorrow> what would be really handy is vacuum having a function that takes a *user* function, and does a fold over the heap with it
12:29:33 <mmorrow> someway that makes sense
12:29:37 <copumpkin> :o
12:30:02 <mmorrow> so you could, e.g. compute the total memory size of the heap rooted at some piece of data
12:30:07 <mmorrow> or whatever
12:30:18 <copumpkin> I see
12:30:25 <mmorrow> well, i guess you can do this with the IntMap result, hmm
12:30:59 <eldragon> hi guys, what options should i use for compilation reducing the size of the 6.10.4 binaries from 400 MiB to smaller space?
12:31:04 <copumpkin> bah, this is being really weird
12:31:08 <mmorrow> oh, right. so what you could gain would be the ability to do things with raw HValues as-they're-encountered, and also influence the traversal *itself*
12:31:33 <copumpkin> mmorrow: oh, this is the problem
12:31:35 <mmorrow> copumpkin: oh. it may be some osx asm thing?
12:31:37 <mmorrow> oh?
12:31:44 <copumpkin> (10,(["ghc-prim","GHC.Types","[]"],([],[])))]
12:31:52 <copumpkin> nullary constructors
12:32:01 <mmorrow> heh, oops
12:32:06 <copumpkin> my two test cases were [1..5] and (+1)
12:32:06 <copumpkin> :P
12:32:14 <sinelaw> ok, the haskell report gives an example of polymorphic recursion, if anyone else wants one. section 4.3.1
12:32:28 <mmorrow> copumpkin: oh wait, but it only performs that check on the root
12:32:35 <mmorrow> so [0..5] should work fine
12:32:40 <mmorrow> (but not (+1))
12:33:00 <copumpkin> on the root?
12:33:06 <mmorrow> copumpkin: did you change the asm output to use .long instead of .quad?
12:33:11 <mmorrow> the root of the graph
12:33:12 <copumpkin> I'm not using the asm
12:33:17 <mmorrow> ohhh, ok
12:33:21 <copumpkin> just calling fmap summarize . IM.toList . vacuum
12:33:25 <mmorrow> :o
12:33:36 <mmorrow> oh wait
12:33:44 <mmorrow> that's the output you expected, no?
12:33:44 <copumpkin> and then using your any (null . fst . snd) condition
12:33:48 <mmorrow> ah
12:34:00 <copumpkin> well, any (null . fst . snd) condition matches []
12:34:04 <mmorrow> so that'd only return Nothing if you try to serialize []
12:34:07 <mmorrow> yeah
12:34:08 <copumpkin> yeah
12:34:23 <copumpkin> well, I don't only intend to serialize circular lists :P
12:34:38 <mmorrow> don't remember my rationale for that, but iirc i did that on purpose
12:34:52 <copumpkin> :o
12:35:09 <mmorrow> err, i think we're on two different pages
12:35:33 <mmorrow> so [0] would get serialized, but any nullary cons won't
12:35:34 <copumpkin> hmm
12:35:34 <tectum> Hi! ...to cross-compile ghc for ia64, what version would be good to start with? (the wiki suggests 6.11+)
12:35:41 <copumpkin> mmorrow: well [0] contains []
12:35:49 <copumpkin> and it's an any check
12:35:50 <mmorrow> ah, right. but not at the root
12:36:07 <mmorrow> oh wait, lemme look at that code, maybe i've forgotten something
12:36:33 <mmorrow> yeah, it just checks if the root has zero ptrs
12:36:42 <mmorrow> , vacuum ()
12:36:42 <copumpkin> oh
12:36:44 <lunabot>  [(0,[])]
12:36:53 <mmorrow> , vacuum []
12:36:55 <copumpkin> hmm
12:36:55 <mmorrow> , vacuum [()]
12:36:56 <lunabot>  [(0,[])]
12:36:57 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
12:37:02 <mmorrow> no ptrs
12:37:04 <mmorrow> ptrs
12:37:11 <tectum> @hoogle vacuum
12:37:11 <lambdabot> No results found
12:37:22 <mmorrow> @hackage vacuum
12:37:22 <lambdabot> http://hackage.haskell.org/package/vacuum
12:37:43 <copumpkin> I don't really get it, I see:
12:37:43 <copumpkin> graphToAsm pre g@(r:_)
12:37:44 <copumpkin>   | any (null . fst . snd) g = Nothing
12:37:45 <eldragon> @google STM machine
12:37:47 <lambdabot> http://www.springerlink.com/index/NW11R40536468666.pdf
12:37:47 <lambdabot> Title: SpringerLink Home - Main
12:38:01 <copumpkin> where g is the entire output from fmap summarize etc.
12:38:14 <copumpkin> (flattened)
12:38:31 <mmorrow> tectum: here's an example of using vacuum (the raw package, there are also interactive viewers) http://www.haskell.org/pipermail/haskell-cafe/2009-October/067929.html
12:38:56 <tectum> the pictures in the gallery look impressive
12:39:19 <mmorrow> copumpkin: it checks the first node that vacuum encountered, and checks if it has any ptrs. if it does NOT have any ==> the rest of the list is empty
12:39:31 <copumpkin> hmm
12:39:35 <mmorrow> tectum: yeah, those are neat
12:39:49 <mmorrow> copumpkin: so think of a (forall a. a) as a graph
12:40:11 <mmorrow> vertex:=Closure, edge:=(Closure*)
12:40:22 <Baughn> @djinn (a,b) -> (b,a)
12:40:22 <lambdabot> f (a, b) = (b, a)
12:40:28 <Baughn> @. pl djinn (a,b) -> (b,a)
12:40:29 <lambdabot> f = uncurry (flip (,))
12:41:11 <mmorrow> err, and i'm (root := the point of entry to the heap graph)
12:41:28 <eldragon> who understand the VSIDS heuristic for DPLL?
12:41:58 <tectum> what ghc version would be easiest to cross-compile for IA64?
12:42:33 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11016#a11016 <-- Is it possible to rewrite this in terms of modifyMVar, instead of me having to add the exception-handling machinery manually?
12:42:40 <mmorrow> copumpkin: you should ask in #ghc
12:42:43 <mmorrow> err
12:42:48 <mmorrow> tectum: you should ask in #ghc
12:43:06 <tectum> mmorrow: wasn't aware of its existenc -- thanks
12:43:14 <mmorrow> tectum: np
12:43:30 <copumpkin> mmorrow: oh, I was confused about which field it was checking
12:43:51 <copumpkin> I think
12:44:02 <copumpkin> maybe not
12:45:05 <copumpkin> *GHC.Vacuum.GenAsm GHC.Vacuum Data.IntMap> toAsm "asdf" (+1)
12:45:05 <copumpkin> Just [SECTION Data,GLOBL "asdf0_closure",TYPE "asdf0_closure" Object,LABEL "asdf0_closure",ADDR (AbsA "___static_info"),IDENT "vacuum"]
12:45:23 <Baughn> Hm
12:45:30 <copumpkin> is that correct behavior?
12:45:31 <mmorrow> copumpkin: think about the mapping between the logical rep of the heap (sub)graph that the IntMap vacuum returns and the physical/real heap rep
12:45:47 <Baughn> I guess I'd need "dropIO :: MonadIO m => m a -> IO a".. is that function actually possible?
12:46:01 <mmorrow> copumpkin: prettyprint that, that may be our problem
12:46:22 <mmorrow> copumpkin: (unless you've changed it, iirc it uses .quad for addresses)
12:46:33 <copumpkin> nope, haven't touched the asm stuff
12:46:39 <mmorrow> oh right
12:46:48 <copumpkin> mmorrow: http://snapplr.com/wjr1
12:47:13 <mmorrow> copumpkin: your ghc is 32bit, right?
12:47:15 <copumpkin> yeah
12:47:33 <copumpkin> that shouldn't affect too much though, should it?
12:47:47 <mmorrow> err, i'm confused about, is something going wrong?
12:47:56 <jmcarthur> Baughn: i doubt that is possible
12:48:02 <copumpkin> mmorrow: I just thought it was supposed to return Nothing for (+1)
12:48:02 <mmorrow> if you're not using the asm, it shouldn't
12:48:08 <mmorrow> copumpkin: oh, right
12:48:12 <mmorrow> ok, me checks
12:48:25 <jmcarthur> Baughn: consider the concrete case that m a is r -> IO a
12:48:35 <Paczesiowa> Baughn: how would dropIO work on ListT IO a ?
12:48:46 <Baughn> Paczesiowa: Badly, I suspect
12:49:30 <Baughn> ..I'll just hardcode the IO monad into this type. It's not like I intend to use another.
12:50:22 <Paczesiowa> Baughn: why would extract something?
12:50:33 <Baughn> Sorry?
12:50:44 <mmorrow> copumpkin: gah! ok
12:50:54 <mmorrow> copumpkin: heh, it's checking the wrong field :)
12:50:55 <copumpkin> mmorrow: am I doing something wrong?
12:50:58 <copumpkin> mmorrow: oh okay :P
12:51:02 <copumpkin> it's checking the string field, right?
12:51:04 <mmorrow> right
12:51:06 <Paczesiowa> Baughn: if you have x :: MonadIO m => m a, you can write x >>= liftIO foo
12:51:17 <copumpkin> mmorrow: okay, it's doing what I thought it was doing but kept trying to tell myself it wasn't
12:51:18 <Paczesiowa> Baughn: where foo :: a -> IO b
12:51:28 <copumpkin> mmorrow: it should be null . fst . snd . snd ?
12:51:34 <mmorrow> err
12:51:54 <mmorrow> null . fst . s
12:51:55 <mmorrow> right
12:52:28 <Baughn> Paczesiowa: I don't think that'd help me write a MonadIO-capable version of modifyMVar
12:52:45 <Baughn> Paczesiowa: I can't even use block/unblock directly, since those also assume IO. *sigh*
12:52:51 <copumpkin> mmorrow: then I think we encounter the other problem I thought we had before :P
12:53:00 <mmorrow> ruhruh, what?
12:53:39 <copumpkin> mmorrow: that line appears to be checking all summarized nodes
12:53:53 <Paczesiowa> Baughn: it makes sense, what would you like to write inside of MVar in case of ListT IO ?
12:54:09 <copumpkin> so if any of them (and some undoubtedly will) contains zero pointers, it will return Nothing
12:54:13 <mmorrow> it only calls graphToAsm once for the entire list of heap nodes
12:54:28 <copumpkin> yeah, but graphToAsm looks at the entire list
12:54:31 <mmorrow> so it only checks the first/root node for ptrs
12:54:40 <mmorrow> does it?
12:54:50 <mmorrow> oh shit
12:54:54 <mmorrow> you're right
12:55:04 <mmorrow> oh, but it does `any'
12:55:10 <mmorrow> err, which is wrong
12:55:22 <Baughn> Paczesiowa: The top-level monad is required to be StateT; I write whatever its final state is.
12:55:24 <copumpkin> phew, I'm not going insane
12:55:27 <mmorrow>   | (null . fst . snd . snd) g = Nothing
12:55:32 <mmorrow> :)
12:55:39 <copumpkin> by g you mean r, right?
12:55:44 <mmorrow> right
12:55:59 <copumpkin> cool :)
12:56:04 <mmorrow> better to completely disregard anything i say about this particular boolean test.. ;)
12:56:05 <Baughn> Paczesiowa: To put it another way, except for exceptions, is there any reason my earlier paste won't work?
12:56:20 <Baughn> Paczesiowa: My problem isn't making it work, it's making it work safely
12:56:23 <Paczesiowa> Baughn: then you can write a function that will runStateT, modifyMVar and go back inside your warm fuzzy monad
12:56:40 <copumpkin> mmorrow: lol :) one last problem! ;)
12:56:45 <Paczesiowa> Baughn: haven't seen any paste
12:56:47 <Baughn> Paczesiowa: Ah, but the /initial/ state is the previous value of the MVar
12:56:50 <Baughn> ..oh
12:56:53 <Baughn> Paczesiowa: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11016#a11016
12:56:53 * mmorrow is ready for this one
12:56:59 <copumpkin> mmorrow: but I think I can fix it myself O:-)
12:57:21 <mmorrow> is it a bug or a new hurdle?
12:57:35 <Paczesiowa> Baughn: oh, looks like you have already figured out my idea
12:57:49 <Baughn> Paczesiowa: Yeah, it's just that I can't use that one.
12:57:57 <copumpkin> well, toAsm on (+1) correctly spits out Nothing now, and on fix (0:) it generates some asm. but toAsm on [] or 5 spits out Nothing
12:58:03 <Baughn> If an exception is thrown, it won't put the mvar back to its original state like it should
12:58:05 <copumpkin> both of those have zero points
12:58:09 <copumpkin> pointers even
12:58:27 <Paczesiowa> Baughn: you could require the top monad to be error monad
12:58:39 <Baughn> Paczesiowa: Hm. That could work.
12:58:53 <mmorrow> copumpkin: oh right, i don't even remember why i had it give Nothing for nullary cons
12:58:57 <copumpkin> mmorrow: for the 5, I could uncurry (++) and check that the sum of pointers and data isn't null, but for [] I might have to check the name
12:59:08 <mmorrow> ahh, i see what you're saying
12:59:18 <mmorrow> copumpkin: we should check the closure type
12:59:26 <copumpkin> that might be simplest :)
12:59:34 <Paczesiowa> Baughn: I've written a monad once that was instance of MonadError and MonadIO, but liftIO was catching IO exceptions and putting them inside ErrorT
12:59:35 <copumpkin> I'll adapt summarize to spit that out too then
13:00:11 <Baughn> Paczesiowa: ..I don't think I dare. Those functions don't look entirely async-exception safe.
13:00:20 <mmorrow> ghci> (unsafePerformIO . closureType) (+1)
13:00:20 <mmorrow> PAP
13:00:27 <copumpkin> oh
13:00:32 <copumpkin> cool :)
13:00:44 <mmorrow> (it'd only IO since it has to do some peeks)
13:00:48 <mmorrow> s/it'd/it's/
13:01:00 <copumpkin> [] is apparently CONSTR_NOCAF_STATIC
13:01:06 <mmorrow> right
13:01:07 <Baughn> mmorrow: ..that, and since the value /can change/
13:01:27 <mmorrow> Baughn: well, that's only a philosophical reason.. but yeah, that too
13:01:28 <Baughn> Not in the case of (+1), obviously, but for any evalutable thunk
13:02:05 <zygoloid> hmm. is vacuum being turned into a pickle for arbitrary expressions? :)
13:02:18 <copumpkin> zygoloid: hope so
13:02:24 <copumpkin> zygoloid: minus functions or thunks
13:02:32 <copumpkin> Baughn: good point
13:02:47 <copumpkin> http://snapplr.com/x5hg
13:02:49 <zygoloid> no thunks? aww :)
13:02:53 <mmorrow> zygoloid: hopefully we'll get functions/everything eventually
13:03:01 <copumpkin> that would be beautiful
13:03:03 <zygoloid> that would be Seriously Impressive
13:03:23 <copumpkin> I'd probably approach it through the bytecode path
13:03:30 <mmorrow> zygoloid: it's hard though since we have to work at the machine-code level
13:03:45 <mmorrow> s/hard/hard relative to an interpreted language/
13:04:05 <mmorrow> well, actually the real reason it's hard is that ghc wasn't designed with this in mind
13:04:25 <mmorrow> so everything is an exercise in ninja bitjitsu
13:04:28 <Baughn> At least it isn't moving functions around at runtime
13:04:29 <mmorrow> :)
13:04:29 <copumpkin> I feel it should still be feasible using bytecode?
13:04:35 <copumpkin> lol
13:04:41 <Baughn> (Like CL)
13:04:45 <mmorrow> copumpkin: yeah, but then you need an interp
13:04:58 <mmorrow> (which is reasonable, but not in general)
13:04:59 <copumpkin> mmorrow: yeah, I guess linking to a 25 MB static library isn't to everyone's taste
13:05:20 <mmorrow> and then ghci links in another crapload of .o's
13:05:25 <copumpkin> yeah
13:05:33 <copumpkin> I guess we could rip out the bytecode interpreter from ghci
13:05:33 <Baughn> Let's just wait for 6.12, guys..
13:05:35 <copumpkin> and link only that
13:05:39 <copumpkin> Baughn: how will that help?
13:05:42 <Paczesiowa> Baughn: do you want to liftIO . forkIO ?
13:05:43 <copumpkin> oh you mean dynamic linking?
13:05:46 <Baughn> copumpkin: No static linking.
13:05:47 <copumpkin> it still doesn't work on mac os :)
13:05:48 <mmorrow> copumpkin: that would be cool
13:05:48 <Baughn> Paczesiowa: No
13:06:16 <mmorrow> Baughn: transitioning ghci to use dynlibs though is a whole other thing though
13:06:41 <Baughn> mmorrow: True, but getting it to work /without/ ghci is good enough for now
13:06:45 <copumpkin> anyway, gonna go run off to watch a scott aaronson talk
13:06:49 <copumpkin> I'll be back in a bit :)
13:06:57 <sinelaw> why are GADTs helpful here?
13:06:57 <sinelaw> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11018#a11018
13:07:00 <Baughn> mmorrow: I look forward to the day I can pass --disable-static to cabal
13:07:01 <mmorrow> or maybe (hopefullyyy) i'm wrong and it won't turn into an epic that nobody manages until 6.16
13:07:49 <Paczesiowa> Baughn: then I don't know what's the problem with async exceptions...
13:08:08 <zygoloid> sinelaw: well, for a start, the Pair constructor looks very dodgy
13:08:30 <sinelaw> zygoloid, I think i get it - because "eval" must have type Term Int -> Int
13:08:33 <sinelaw> ?
13:08:34 <Baughn> Paczesiowa: Let's say I the Error class, and catch them before rethrowing so I can put the MVar back
13:08:40 <zygoloid> sinelaw: right, i was getting to that :)
13:08:56 <Baughn> Paczesiowa: What happens if an async exception hits the thread just after it caught the last one, but before it's putMVar'd it back?
13:08:57 <sinelaw> zygoloid and what you said, too. didn't notice that :)
13:09:11 <Taejo> > (\xs -> transpose [map fst xs, map snd xs]) [(1,2),(3,4),(5,6)]
13:09:11 <lambdabot>   [[1,2],[3,4],[5,6]]
13:09:24 <Taejo> > (\xs -> concat . transpose $ [map fst xs, map snd xs]) [(1,2),(3,4),(5,6)]
13:09:25 <lambdabot>   [1,2,3,4,5,6]
13:09:56 <sinelaw> zygoloid so a GADT let's you use the types it was parameterized on, and also use other arbitrary types / type variables?
13:10:09 <sinelaw> lets
13:10:22 <Paczesiowa> Baughn: async exceptions can be caught too, maybe you can inject them into Error
13:10:45 <Baughn> Sure they can. That's not the issue.
13:10:59 <Baughn> Do they get caught when I'm /already inside/ an error handler?
13:11:13 <idnar> bos: hey, it seems like your blog is down (if you're not already aware of the problem)
13:11:14 <Berengal> Baughn, not unless you enable interrupts in the handler
13:11:19 <Baughn> Or does it automatically block async exceptions to avoid that?
13:11:23 <zygoloid> sinelaw: GADTs let you choose whether a constructor should exist based on a pattern-matching of the type's variables
13:11:29 <bos> idnar: should be back up now
13:11:32 <Baughn> Berengal: That's for the Control.Exception one. I see no such documentation for the Error class.
13:11:39 <Taejo> @pl (\xs -> concat . transpose $ [map fst xs, map snd xs])
13:11:39 <lambdabot> join . transpose . ap ((:) . map fst) (return . map snd)
13:11:44 <idnar> bos: "Error establishing a database connection"
13:12:11 <Berengal> Baughn, ah, Error class. That's what I get for jumping in the middle
13:12:24 <bos> idnar: ah, fixed
13:12:33 <zygoloid> sinelaw: in effect this lets you do a restricted, implicit form of pattern matching on types in function definitions
13:12:41 <idnar> bos: great :)
13:12:50 <Baughn> Berengal: The problem started out by block requiring IO instead of MonadIO. Or, perhaps, modifyMVar doing the same.
13:13:01 <Paczesiowa> Baughn: you can write IO handler that catches IO exception and uses that exception to return it inside of Error
13:13:06 <Baughn> Berengal: To recap: I'd like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11016#a11016 to work reliably.
13:14:19 <Baughn> Paczesiowa: I could, but I don't quite see how that helps..?
13:16:03 <Baughn> Berengal: ..block's a primitive, even. I was hoping it was actually a paired block# and unblock#, with a counter or so. :/
13:16:33 <Berengal> Baughn, better just use bracket or something
13:17:10 <sinelaw> zygoloid does it also allow type-class constraints in the definition of constructors?
13:17:18 <Baughn> Berengal: Can I?
13:17:32 <Berengal> Baughn, can't you liftIO the whole thing?
13:17:48 <Baughn> No, that wouldn't match the type
13:17:52 <Baughn> @type liftIO
13:17:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
13:17:58 <Berengal> True, it wouldn't for runStateT
13:18:17 <Baughn> I'd sort of need an m a -> IO a
13:18:37 <Baughn> (Which has already been established as silly)
13:18:44 <Berengal> Indeed
13:18:50 <morganson> hello I have a question about Graphics.UI.Gtk. I installed the library but ghc doesn't recognise this. It prints an error message that it could not find the module Graphics.UI.Gtk. I downloaded Graphics.UI.Gtk from the site http://haskell.org/gtk2hs/. please help... =/
13:19:51 <Paczesiowa> morganson: what platform?
13:19:57 <morganson> linux
13:19:59 <eldragon> @google GADT
13:20:00 <lambdabot> http://en.wikipedia.org/wiki/Generalized_algebraic_data_type
13:20:02 <morganson> I use openbox
13:20:11 <Berengal> Baughn, there seems to be a composability problem here. Is there no way to reliably catch exceptions in MonadIO?
13:20:27 <Paczesiowa> morganson: what distro?
13:20:28 <Baughn> Berengal: Not that I've found.
13:20:36 <morganson> backtrack
13:20:56 <morganson> backtrack 4 pre release
13:21:08 <zygoloid> sinelaw: yes, that too. it also implicitly allows existentials to be defined
13:21:15 <Paczesiowa> morganson: paste output of ghc-pkg list
13:21:20 <morganson> allright
13:21:24 <morganson> one moment
13:21:53 <morganson> wait one second ghc-pkg list? what?
13:22:02 <morganson> the error message?
13:22:09 <morganson> @paste
13:22:09 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:22:15 <Paczesiowa> MonadIO computation can also use many threads
13:22:36 <Paczesiowa> Baughn: do you hve to use IO?
13:23:13 <morganson> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4449#a4449
13:23:15 <Baughn> Paczesiowa: I have to alllow it, yes. The program that'll be using this is a peer-to-peer membership protocol..
13:23:22 <morganson> Paczesiowa: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4449#a4449
13:23:46 <Baughn> morganson: And output of ghc-pkg list?
13:24:08 <morganson> hmm I dont know how to do that.
13:24:40 <Baughn> Just run that on some terminal
13:24:41 <Berengal> ghc-pkg list
13:25:04 <Berengal> ... I just realized that was pretty dumb
13:25:34 <morganson> Baughn and Paczesiowa: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4449#a4450
13:26:00 <Baughn> Right. Off-hand, I'd say the reason it's not finding GTK is that it's not installed.
13:26:04 <Paczesiowa> morganson: how did you install gtk2hs?
13:26:42 <Baughn> morganson: GHC 6.8.2 is pretty old, by the way. It works, but you may want to install 6.10 at some point, otherwise you'll shortly be two major versions behind.
13:26:45 <morganson> 1.      ./configure --with-hcflags=-O0 --disable-split-objs
13:26:55 <morganson> 2. make
13:26:58 <Baughn> morganson: (Speaking only for myself, I no longer write programs to be compatible with 6.8)
13:27:01 <morganson> 3 make install
13:27:27 <Berengal> morganson, which version of gtk2hs by the way?
13:27:34 <Paczesiowa> morganson: perhaps you have to configure it to install to specific directory where you have ghc installed
13:27:36 <Baughn> morganson: And there were no errors, at any stage?
13:27:50 <Baughn> Paczesiowa: No, that shouldn't be needed; it'll use whatever the ghc it finds is using
13:27:55 <morganson> the newest version Baughn
13:28:10 <Taejo> there is some temptation to stay at the distro-packaged version
13:28:28 <Taejo> especially for end users
13:28:38 <morganson> no errors
13:28:54 <morganson> maybe ghc is too old?
13:28:55 <Baughn> Taejo: End users? It's still a research language..
13:29:07 <Baughn> morganson: Shouldn't be
13:29:10 <Berengal> Baughn, not exclusively
13:29:27 <Baughn> morganson: Are you compiling gtk2hs as root?
13:29:33 <Berengal> the site says ghc >= 6.6, which 6.8 fits
13:29:35 <Twey> I think Haskell left its research-language status behind a while back
13:29:35 <Taejo> Baughn: I've written programs in Haskell that have been used by non-Haskellers
13:29:49 <Twey> It's used for Serious Stuff nowadays.  
13:29:53 <Baughn> Taejo: This does not mean it's not a research language.
13:30:01 <Berengal> Twey, it didn't leave it, it just put on more hats at the same time
13:30:02 <Baughn> It'll stop being a research language once changing the Prelude becomes unthinkable
13:30:09 <Twey> Berengal: Hehe
13:30:14 <Taejo> clearly being a research language doesn't mean it doesn't have end users
13:30:24 <Taejo> if haskell is still a research language
13:30:37 <monochrom> It is OK to use slightly older but more convenient versions from distro.
13:30:39 <Baughn> Well, no, but it does kind of imply a greater degree of required knowledge for those end users
13:30:42 <g0rgon_> good evening; I've been trying to create a monad which is a straightforward stack of a Reader on top of a Writer, but I can't seem to get the syntax right
13:30:47 <Twey> Baughn: Does changing including adding to or offering alternatives to?
13:30:50 <Baughn> At least to the point of not being two versions around..
13:30:55 <morganson> hmm Baughn and Paczesiowa. What is your advice for me. what should I do?
13:31:06 <g0rgon_> this is what I have now: newtype Action a = Action { _runAction :: ReaderT ActionParameters (Writer AList String) a } deriving (Monad, MonadReader ActionParameters, MonadWriter AList String)
13:31:17 <Berengal> morganson, is there a distro-provided version you could use instead?
13:31:17 <monochrom> Hell, I don't use the distro version, I'm so lazy I'm still at 6.8.2, distro is about to move on to 6.10.x and ahead of me!
13:31:19 <Taejo> Baughn: what is the required knowledge of the end user to use a program written in Haskell?
13:31:22 <Baughn> Twey: Changing the defaults in ways that'd break old programs, were they to use the newer base
13:31:37 <morganson> via apt-get?
13:31:38 <g0rgon_> to which GHC replies: Expected kind `* -> *', but `Writer AList String' has kind `*'
13:31:38 <seanmcl> is it correct to think of an empty class body as an abbreviation?  E.g.  class (MonadState s m, Show s, Num s) =>  AbbrevClass s m where?
13:31:47 <Berengal> morganson, yes
13:31:47 <Baughn> Twey: A *real* end-user shouldn't have to compile the program. Anyone who needs ghc, per se..
13:31:49 <Twey> Baughn: Isn't that already the case?
13:31:59 <Twey> Why else would we have that crippled Prelude.catch?  :
13:32:05 <Twey> Baughn: That's true.
13:32:07 <monochrom> Yes seanmcl, that's how people do it.
13:32:15 <Twey> (and this is true of darcs)
13:32:16 <g0rgon_> I have no idea what's wrong with my declaration, nor what that error means exactly...
13:32:26 <Baughn> Twey: Well, at the moment. There is some desire to change that for base-5. :P
13:32:40 <morganson> Berengal: I'll check and let you know. one moment
13:32:49 <CosmicRay> anybody know where the hackage versioning policy is?
13:32:51 <Twey> O.O
13:32:51 <Baughn> Twey: You'd get to use base-4, or OldPrelude if you want
13:32:53 <Paczesiowa> morganson: you could try using more popular linux distro
13:33:04 <Twey> Awesome
13:33:12 <morganson> Berengal: Nja I like this one. =)
13:33:13 <Baughn> Twey: See #alt-stdlib, I guess.
13:33:22 <Berengal> morganson, assuming you got your ghc from apt-get, it should work flawlessly. Even if you didn't do that, it might still work
13:33:24 <seanmcl> monochrom: are there ever problems with this?  I've got a program that doesn't compile because it can't figure out that one class is a superclass of another, but adding the strange line "instance C s m => C s m where" fixes it.
13:33:32 <Twey> Baughn: No such channel?
13:33:36 <Baughn> Twey: (So, yeah, that means adding an Applicative dependency to Monad, etc. etc. etc.)
13:33:47 <morganson> allright
13:33:47 <Twey> \o/
13:33:48 <jmcarthur> Twey: it's not registered
13:33:51 <Baughn> Twey: ..no, it's there.
13:34:58 <morganson> Berengal: but what should I search on to find it?
13:35:37 <Berengal> morganson, libghc6-gtk-dev is what it's called on ubuntu
13:36:05 <morganson> found it
13:36:14 <morganson> I am installing it now
13:36:50 <morganson> compiling worked like a charm now. Berengal and Paczesiowa! =)
13:36:58 <Berengal> :)
13:37:05 <morganson> thank you very much
13:38:56 <g0rgon_> nevermind, I found the problem... doh
13:46:59 <morganson> is someone here familiar to openbox? I just wonder how I can browse directories graphically. thank you...
13:47:00 <hackagebot> GPipe 1.0.2 - A functional graphics API for programmable GPUs (TobiasBexelius)
13:47:02 <hackagebot> Vec-Transform 1.0.1 - Extends the Vec package with some 4x4 transform matrices (TobiasBexelius)
13:47:58 <Paczesiowa> use graphical file manager? I think there was one written in haskell
13:48:40 <Twey> morganson: Has nothing to do with your window manager
13:48:54 <Twey> Use a GUI file manager of your choice
13:49:22 <Vanadium> morganson: consider rox
13:52:21 <Paczesiowa> http://www.mickinator.com/wordpress/?p=96
14:02:20 <morganson> Vanadium: ok thank you.
14:04:12 <morganson> Vanadium: so what is rox and where can I get it? Is it a graphical directory browser just like konqueror is for kde?
14:04:46 <morganson> but for openbox?
14:05:00 <Vanadium> It is a graphical directory browser that is independent of whatever else you have, ie it works with openbox or with gnome or whatever
14:05:38 <morganson> can you give me a link please.
14:06:02 <Vanadium> No, sorry, I am afraid of further derailing the channel.
14:06:14 <Berengal> Arrows are weird
14:06:25 <morganson> ok back to haskell =)
14:06:39 <morganson> I'll find it
14:06:48 <Berengal> The syntax makes me cry a little
14:07:14 <Paczesiowa> yeah, reading from left to right is so unnatural!
14:07:14 <lament> clearly the syntax for arrows should be graphical
14:07:31 <Berengal> lament, indeed!
14:07:40 <Berengal> Paczesiowa, well, the syntax goes mostly from right to left
14:07:49 <Berengal> (assuming you're using Control.Category..)
14:07:57 <Berengal> ((or <<<))
14:08:27 <Paczesiowa> Berengal: you usually use (>>>)
14:09:05 <Berengal> Paczesiowa, I find . more readable when using the special syntax
14:09:55 <Berengal> Of course, I'm still a n00b at them. Just found out about -<< and that if-then-else works, but they both make me cry a little
14:10:17 <Berengal> The rewrite rules are horrifying (at least compared to monad do)
14:10:32 <Paczesiowa> Berengal: oh, you mean that arrow-syntax like do
14:11:46 <dolio> Wadler has an arrow notation that looks a lot like lambda terms, which might be better.
14:12:00 <dolio> Although the existing arrow notation can be read a lot like lambda terms if you squint.
14:12:26 <Berengal> dolio, I read it like plumbing, of sorts
14:12:44 <dolio> Or, perhaps more like a recursive let, inside a lambda.
14:13:34 <Berengal> I still don't get ArrowLoops much... or at all
14:13:44 <dolio> proc x -> do y <- f -< x ; z <- g -< y ; returnA -< z ~ \x -> let y = f x ; z = g y in z
14:14:40 <monochrom> ArrowLoops allow proc x -> do y<- f -< z; z <- g -< x; ...
14:15:23 <monochrom> Analogous to MonadFix. From one perspective, that is all it is, forward references.
14:15:52 <Berengal> monochrom, I get forward references and mfix, but I don't get the ArrowLoop hello world...
14:16:48 <dolio> I find it difficult to write anything with loop directly that doesn't look trivial. But I suppose the point isn't to use it directly.
14:17:24 <monochrom> What does the ArrowLoop hello world look like?
14:17:37 <Berengal> monochrom, the incrementer with a reset line or something...
14:18:29 <dolio> I always end up with something like 'loop (\(x,y) -> (y,f x y))'.
14:19:07 <Berengal> dolio, that one, at least, makes sense
14:20:33 <dolio> Thinking that's trivial might be a side effect of thinking in terms of functions, though.
14:21:02 <jmcarthur> @pl \(x,y) -> (y,f x y)
14:21:03 <lambdabot> uncurry (ap (,) . f)
14:21:03 <dolio> An important part of loop is that it's more first-order.
14:21:04 <Berengal> Indeed
14:21:46 <jmcarthur> wow, talk about a vague point free definition
14:21:58 <jmcarthur> looks deceptively simple though
14:22:14 <Berengal> Oh well, hxt is still awesome, even if I don't get much of arrows yet.
14:22:44 <Berengal> At least, the more I don't understand something, the greater the moment of understanding will be
14:23:16 <Berengal> (Monads gave me a high that lasted weeks)
14:32:43 <Taejo> @src repeat
14:32:43 <lambdabot> repeat x = xs where xs = x : xs
14:39:40 <blackh> Berengal: Have a look at my arrow tutorial - http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
14:42:09 <ddarius> repeat = fix . (:)
14:43:26 <rsnake> Hey guys... say I have something defined like this as part of a module: data LambdaTerm = Atom String | Variable Int | Appl LambdaTerm LambdaTerm
14:43:42 <rsnake> Do I have to make each constructor visible in the module, or just LambdaTerm?
14:44:14 <sproingie> take your pick
14:44:20 <rsnake> Because if I include 'Atom' or 'Appl' as part of the module definition, it says the constructors are not in scope
14:44:24 <blackh> rsnake: LambdaTerm(..) will export everything...
14:44:26 <sproingie> if you want LambdaTerm to be opaque, you just expose the type
14:44:30 <sinelaw> > fix (3:)
14:44:31 <lambdabot>   [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
14:44:53 <sproingie> if you want others to construct or pattern match on it, then you export LambdaTerm(..)
14:46:17 <rsnake> LambdaTerm(..) worked perfect... thanks everyone!
14:48:26 <sinelaw> @type (3:)
14:48:28 <lambdabot> forall t. (Num t) => [t] -> [t]
14:48:54 <sinelaw> fix is awesome.
14:49:36 <Cale> > fix error
14:49:37 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:50:04 <dons> :)
14:50:37 <Cale> There's lots of room at the bottom?
14:50:37 <sproingie> > fix fix
14:50:37 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
14:51:12 <Paczesiowa> you could fix that with some newtypes
14:51:14 <sproingie> wouldn't be showable anyway i guess
14:51:39 <sproingie> > fix id
14:51:43 <lambdabot>   mueval-core: Time limit exceeded
14:55:37 <EvilTerran> Mu Endo!
14:56:08 * Axman6 really wishes the phrase "Occurs check:" would be replaced with something that made more sense
14:56:31 <zygoloid> occurs within itself check?
14:57:38 <Axman6> well, something like "Type checking error:" or "Type inferrence error:" would be nice
14:58:32 <zygoloid> it's more "Inferred a type which probably isn't what you wanted error:"
15:00:54 <sproingie> istr hugs having nicer error messages
15:01:17 <rsnake> Who made lambdabot?
15:01:53 <ivanm> rsnake: no-one made her, she evolved from some random haskell code floating around on the interwebs
15:01:55 <sproingie> Oleg got drunk and wrote a type signature down
15:02:00 <sproingie> someone typed it in and we got lambdabot
15:02:23 <rsnake> Cool :)
15:02:48 <SubStack> I thought lambdabot wrote lambdabot
15:03:07 <SubStack> after an accident with a time machine
15:03:23 <Axman6> rsnake: dons did i believe
15:04:01 <lament> @vixen who made you?
15:04:01 <lambdabot> that's a good question, who?
15:04:20 <lament> @vixen was it Church?
15:04:20 <lambdabot> i think you know the answer to that one, silly
15:04:24 <Axman6> @vixen who is your father?
15:04:24 <lambdabot> that's a good question, who?
15:04:37 <sinelaw> @vixen that's a good question, who?
15:04:38 <lambdabot> i think so too
15:04:39 <lament> vixen has some horrible personality disorder :(
15:04:45 <fergie> SubStack could still be right. Dons might be lambdabot
15:04:48 <lament> @vixen asl?
15:04:48 <lambdabot> 19/f/California
15:05:10 <rsnake> Totally passes the Turing test :P
15:05:15 <sinelaw> @type callCC
15:05:17 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:05:33 <rsnake> @vixen do you pass the Turing test?
15:05:35 <lambdabot> yes i do
15:05:38 <rsnake> See?
15:05:55 <ivanm> rsnake: nah, how can anything intelligent come from California? :p
15:06:00 * ivanm ducks, just in case...
15:06:05 <bluestorm> how does Haskell/DB handle NULL values ?
15:06:12 <lament> @vixen are you intelligent or californian?
15:06:12 <lambdabot> i truely am
15:06:17 <sinelaw> @vixen how does Haskell/DB handle NULL values ?
15:06:18 <lambdabot> church is my favourite computer scientist.
15:06:32 <bluestorm> I read the Haskell/DB paper and it's not mentioned, it's not very clear from the documentation ( http://hackage.haskell.org/packages/archive/haskelldb/0.12/doc/html/Database-HaskellDB.html ) either
15:06:59 <Berengal> bluestorm, I can't remember, but if it does it has something to do with Maybe
15:07:10 <sinelaw> the continuation monad has hex-ploded my brain.
15:07:18 <sinelaw> giving up
15:07:24 <bluestorm> Berengal: well I see no mention of Maybe in the documentation
15:07:30 <bluestorm> it goes directly from  Expr a  to IO a
15:07:44 <SubStack> haskelldb looks somewhat abandoned from what I can gather
15:07:51 <SubStack> could use some love
15:11:12 <Taejo_> ivanm: in case nobody else said it while I was disconnected: oy, I'm from californai
15:11:18 <Taejo_> *california
15:11:21 <ivanm> heh
15:13:17 <Berengal> The relational model encoded in haskell with translations to SQL (as far as possible) would be really nifty
15:13:57 <Axman6> indeed, i've proposed someone make a puerly haskell database before, but no one seemed interrested
15:14:25 <Berengal> Axman6, I'm interested, just not interested enough
15:14:33 <Axman6> heh
15:15:31 <SubStack> Axman6: I've looked into it quite a bit with generics
15:15:33 <SubStack> it's really hard
15:19:36 <hackagebot> PastePipe 1.1 - CLI for pasting to hpaste.org (RoganCreswick)
15:20:29 <SubStack> although I suspect the right generics pattern would make it trivial
15:21:44 <bluestorm> Berengal: that's essentially what Haskell/DB was doing, wasn't it ?
15:22:05 <bluestorm> one of the problem with Haskell/DB is it's use of the Trex extension wich is hugs-specific
15:22:23 <bluestorm> (I'd guess that's the number one issue regarding Haskell/DB adoption)
15:22:37 <bluestorm> but other than that it's mostly a "relational model with output to SQL"
15:22:53 <Berengal> bluestorm, sort of, but it didn't get all the way there
15:24:10 <bluestorm> does GHC has some kind of "type-level records" (in the spirit of Trex, or OCaml object types) ?
15:24:19 <bluestorm> s/has/have/
15:24:44 <mmorrow> Berengal: s/SQL/Datalog/
15:24:51 <mmorrow> Berengal: then you could just compile to SQL
15:25:03 <sinelaw> dons, does your graph of text on #haskell include the join/part messages?
15:25:19 <Berengal> mmorrow, true
15:25:31 <mmorrow> and Datalog would be niftier ;)
15:25:41 <dons> sinelaw: no
15:25:42 <rsnake> Say I have a really long line and want to keep my file to 80 columns... is there some way to break this line in haskell?
15:25:51 <Cale> HaskellDB's Expr type apparently represents Null directly
15:26:17 <Cale> rsnake: Usually just continue it on the next line, but indent that following line more.
15:26:21 <Axman6> rsnake: look at the split package, it includes the Data.List.Split module, which has functions that will let you
15:26:26 <bluestorm> Cale: yes but I was wondering if there was some typing support
15:26:27 <Cale> Axman6: ?
15:26:29 <Berengal> mmorrow, well, the language it's outputting to isn't interesting. The output from the database is
15:26:46 <bluestorm> I looked at the sources and apparently there isn't much for the support of optional types
15:26:49 <Axman6> oh, totally misunderstood the question :)
15:26:59 <Cale> bluestorm: Seems not.
15:27:07 <rsnake> Thanks!
15:27:20 <Axman6> > unfoldr \xs -> if null xs then Nothing else Just (splitAt 10 xs)) [1..]
15:27:21 <lambdabot>   <no location info>: parse error on input `\'
15:27:28 <Axman6> > unfoldr (\xs -> if null xs then Nothing else Just (splitAt 10 xs)) [1..]
15:27:30 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,...
15:28:10 <bluestorm> Berengal: in practice, given the vast amount of time and R&D devoted to improving existing SQL databases by the mainstream world, I'm not sure it's really realistic to start a new database language unless the benefits really outweight the huge costs
15:28:48 <bluestorm> (everyone agree that SQL is a suboptimal language, but numerous projects have tried to provide a replacement and failed)
15:28:50 <mmorrow> Berengal: having a (String -> everything) is key, whether that string be SQL or Datalog, or ...
15:29:12 <Berengal> bluestorm, just because you use SQL to query the databases doesn't mean you'll have to give up on the database just because you're giving up on SQL
15:29:34 <mmorrow> blueflute: the DB is separate from the language you might happen to translate/compile into the low-level gear pulling of a particular implem
15:29:40 <kw317> how should one write, explicitly typed or explicitly-typed?
15:29:45 <mmorrow> e.g. sqlite is a bytecode interpreter
15:30:01 <Axman6> kw317: without the - imo
15:30:46 <mmorrow> so half of sqlite is a compiler/optimizer from SQL to sqlite bytecode
15:31:11 <bluestorm> mmorrow: the user will want to use the specificities of the language he's used to (SQL), if your language is too far from the SQL primitives you'll have a hard time providing an efficient translation, or the missing features
15:31:11 <ivanm> Axman6: agreed
15:31:11 <mmorrow> (the other half being the abstract machine implem)
15:31:46 <Axman6> i'm learning about database implementations at the moment at uni, it's actually reallt fascinating
15:31:50 <bluestorm> ("what, there is no LEFT OUTER JOIN in your database query language ? Sucks, I'm going back to my beloved PHP !")
15:31:58 <mmorrow> blueflute: totally, the beauty of the language being indep of the implem, is you can support any language you want by just writing a parser and translator
15:32:06 <Berengal> bluestorm, a relational language is still a relational langauge. It's not a paradigm shift
15:32:45 <bluestorm> SQL is only "mostly relational", but I agree; there might be a reasonable common denominator
15:33:02 <bluestorm> (and iirc LINQ can output to different query languages, SQL being one of them; never used it though)
15:33:16 <ksf> I tend to come to the conclusion that frp should actually be built into a language.
15:33:30 <Berengal> (And if I made the language it wouldn't have left outer joins. Nulls are bad for you)
15:33:37 <rsnake> Guys, why isn't the last part of this 'do' an expression? http://paste.pocoo.org/show/146294/
15:33:55 <sproingie> Berengal: there's theoretically pure databases and there's databases people will actually use
15:33:55 <Axman6> Berengal: i don't think they are, when it comes to databases
15:34:40 <ksf> rsnake, because it's a let.
15:34:40 <sproingie> "NOT NULL" however should have been default
15:34:40 <ksf> ...get rid of that "in"
15:34:40 <Axman6> like, a database that contains howmany babies someone's had. if they're a man, then a NULL value would make sense imo
15:34:50 <Berengal> sproingie, that's okay, I don't care what others write their stuff in
15:34:59 <ksf> granted, it's a degenerate case
15:35:08 <sproingie> Axman6: a 1-many like that would just lack any foreign keys pointing to men
15:35:13 <mmorrow> HaskellDB did the abstraction of the DB backend pretty nicely
15:35:27 <mmorrow> there's a backend implented with Data.Maps..
15:35:31 <heatsink> rsnake, the 'in' is not valid syntax there, so it assumes the do block ends at the 'let'.
15:35:42 <ksf> btw: [ltn] <- read <$> getArgs
15:35:49 <mmorrow> the big missing piece is an SQL parser (which actually now there's one on hackage)
15:35:49 <heatsink> rsnake, It's valid if you add more indentation to the 'in'  line
15:36:01 <heatsink> rsnake, or get rid of the 'in', as ksf said
15:36:30 <ksf> the error message could certainly be clearer
15:36:43 <ksf> ...in cannot start a statement, ever.
15:36:45 <rsnake> ksf, heatsink: I see... thanks!
15:37:41 <mmorrow> http://code.haskell.org/haskelldb/driver-flat/Database/HaskellDB/FlatDB.hs
15:38:08 <mmorrow> granted, it doesn't support concurrency or transactions, but it wouldn't be that much effort to do so
15:38:24 <mmorrow> haskelldb has an SQL join/query optimization module too
15:38:49 <mmorrow> http://code.haskell.org/haskelldb/src/Database/HaskellDB/Optimize.hs
15:39:02 <Berengal> mmorrow, nifty
15:40:32 <mmorrow> err, did i say joins...
15:40:53 <bluestorm> regarding "SQL-like queries on Haskell structures", there is also the "Comprehensive Comprehensions" paper wich extends standard Haskell comprehensions with group by / order by constructs
15:41:01 <mmorrow> not doing joins is a problem though
15:41:13 <mmorrow> (for actual non-trivial querying)
15:41:38 <bluestorm> (and the comprehension syntax looks nicer than the do-notation syntax when it comes to database queries, imho)
15:43:00 <zygoloid> mmorrow: erk! a 7-tuple!
15:43:13 <mmorrow> zygoloid: heh
15:43:28 <mmorrow> , $(fmap lift [0..12::Int])
15:43:30 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
15:43:42 <mmorrow> , $(listE (fmap lift [0..12::Int]))
15:43:43 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12]
15:43:46 <mmorrow> , $(tupE (fmap lift [0..12::Int]))
15:43:47 <mmorrow> gah
15:43:48 <lunabot>  (0,1,2,3,4,5,6,7,8,9,10,11,12)
15:44:14 <ksf> there's nthable for such atrocities
15:44:18 <bluestorm> (what's that lunabot ?)
15:44:22 <mmorrow> , $(tupE (fmap lift [0..62::Int]))
15:44:23 <lunabot>  luna: A 63-tuple is too large for GHC
15:44:37 <zygoloid> , length $ show $(tupE (fmap lift [0..61::Int]))
15:44:39 <lunabot>  luna: No instance for (GHC.Show.Show
15:44:54 <zygoloid> hah
15:44:59 <mmorrow> bluestorm: it's another evalbot, that has some different libs/capabilities than lambdabot
15:45:11 <mmorrow> , ppDoc <$> tupE (fmap lift [0..62::Int])
15:45:12 <lunabot>  (0,
15:45:12 <lunabot>   1,
15:45:12 <lunabot>   2,
15:45:22 <ksf> , filter (=="cool") dict
15:45:26 <lunabot>  ["cool"]
15:45:36 <Berengal> , randM (replicateM 5 crapM)
15:45:36 <mmorrow> heh, almost forgot about dict
15:45:37 <lunabot>  luna: Not in scope: `crapM'
15:45:40 <Berengal> , randM (replicateM 5 crapsM)
15:45:42 <lunabot>  [(,),(,),(,),(,),(,)]
15:45:49 <mmorrow> /usr/share/dict/words is in dict
15:45:54 <mmorrow> , [$ty| dict |]
15:45:57 <lunabot>  [] String
15:46:00 <Axman6> , filter (isInfexOf "lol")
15:46:01 <lunabot>  luna: Not in scope: `isInfexOf'
15:46:07 <mmorrow> , [$pl| \a b -> g (f a b) |]
15:46:07 <Axman6> , filter (isInfixOf "lol") dict
15:46:09 <lunabot>  (g .) . f
15:46:10 <lunabot>  ["acetylsalol","alkylol","allolalia","allolalic","alveololabial","alveolo...
15:46:13 <zygoloid> , filter (((==)`on`sort) "evilterran") dict
15:46:18 <lunabot>  ["irrelevant"]
15:46:22 <mmorrow> hah
15:46:24 <Axman6> :O
15:46:29 * benmachine giggles
15:46:47 <zygoloid> , filter (((==)`on`sort) "benmachine") dict
15:46:52 <lunabot>  []
15:46:54 <benmachine> :(
15:46:57 <zygoloid> unlucky!
15:47:25 <Axman6> , filter ((==)`on` sort) "axman") dict
15:47:26 <lunabot>  luna: parse error on input `)'
15:47:29 <ksf> , filter (((==)`on`sort) "ksf") dict
15:47:34 <lunabot>  []
15:47:34 <Axman6> , filter (((==)`on` sort) "axman") dict
15:47:39 <lunabot>  ["axman"]
15:47:40 <heatsink> ksf: seriously?
15:47:43 <ksf> , filter (((==)`on`sort) "zygoloid") dict
15:47:46 <Axman6> >_>
15:47:48 <lunabot>  []
15:47:55 <ksf> , filter (((==)`on`sort) "lunabot") dict
15:47:59 <lunabot>  ["butanol"]
15:48:03 <zygoloid> lol
15:48:04 <mmorrow> :o
15:48:13 <mmorrow> awesome
15:48:14 <ivanm> @wn butanol
15:48:14 <ksf> , filter (((==)`on`sort) "lambdabot") dict
15:48:15 <lambdabot> *** "butanol" wn "WordNet (r) 2.0"
15:48:15 <lambdabot> butanol
15:48:15 <lambdabot>      n : a flammable alcohol derived from butanes and used for
15:48:15 <lambdabot>          solvents [syn: {butyl alcohol}]
15:48:19 <lunabot>  []
15:48:26 <ksf> , filter (((==)`on`sort) "haskell") dict
15:48:27 <benmachine> ch3ch2ch2coh
15:48:31 <lunabot>  ["shellak"]
15:48:38 <zygoloid> @wn shellak
15:48:38 <sproingie> !
15:48:39 <lambdabot> No match for "shellak".
15:48:41 <ksf> , filter (((==)`on`sort) "lambda") dict
15:48:41 * benmachine did chemistry at school
15:48:44 <heatsink> @wn shellac
15:48:45 <lambdabot> *** "shellac" wn "WordNet (r) 2.0"
15:48:45 <lambdabot> shellac
15:48:45 <lambdabot>      n 1: lac purified by heating and filtering; usually in thin
15:48:45 <lambdabot>           orange or yellow flakes but sometimes bleached white
15:48:45 <lambdabot>      2: a thin varnish made by dissolving lac in ethanol; used to
15:48:46 <lunabot>  ["lambda"]
15:48:47 <lambdabot> [4 @more lines]
15:49:18 <ivanm> benmachine: about to ask wtf your statement meant...
15:49:21 <sproingie> , filter (((==)`on`sort) "sproingie") dict
15:49:25 <lunabot>  ["peignoirs"]
15:49:32 <zygoloid> @wn peignoirs
15:49:33 <lambdabot> No match for "peignoirs".
15:49:35 <sproingie> yay
15:49:38 <heatsink> , length dict
15:49:40 <lunabot>  479830
15:49:46 <Berengal> Impressive
15:49:50 <zygoloid> A peignoir is a long outer garment for women usually sheer and made of chiffon. Peignoirs are usually sold with matching nightgown, negligee or panties but are often worn with no underwear.
15:49:57 <ivanm> Berengal: with a UT voice? :p
15:49:58 <Axman6> , dict
15:50:00 <lunabot>  ["1080","10-point","10th","11-point","12-point","16-point","18-point","1s...
15:50:06 <ksf> yay no underwear
15:50:10 * sproingie is usually worn with no underwear
15:50:10 <zygoloid> dict !! 123456
15:50:14 <mmorrow> it's mmapped as a ByteString, then split on 10, and finally the entire thing unpacked
15:50:17 <zygoloid> , dict !! 123456
15:50:19 <lunabot>  "electroanalytic"
15:50:27 <mmorrow> ... for each expression eval too
15:50:42 <mmorrow> i was amazed at how speedy it seems
15:50:59 <Berengal> mmorrow, indeed, I really am impressed
15:51:37 <zygoloid> , maximumBy (comparing length) . groupBy ((==)`on`fst) $ map (sort &&& id) dict
15:51:38 <lunabot>  luna: Not in scope: `comparing'
15:51:46 <zygoloid> , maximumBy (compare `on` length) . groupBy ((==)`on`fst) $ map (sort &&& id) dict
15:51:47 * ksf likes the fact that each time dict comes up, people spend hours playing with it.
15:51:47 <lunabot>  luna: Not in scope: `&&&'
15:52:02 <zygoloid> , maximumBy (compare `on` length) . groupBy ((==)`on`fst) $ map (\x -> (sort x, x)) dict
15:52:06 <lunabot>  Killed.
15:52:09 <zygoloid> aww
15:52:30 <zygoloid> i think i missed a sort anyway :(
15:52:45 <Berengal> Really, functions alone make for a good query language...
15:52:57 <svendt> whats an easy way to unpack the string from a "IO String" monad holding it hostage?
15:53:06 <ksf> there's none.
15:53:13 <zygoloid> svendt: fmap :)
15:53:17 <ksf> values like the inside of monads, it's warm and fuzzy in there.
15:53:18 <sproingie> there is no escape from IO
15:53:36 <zygoloid> svendt: if you have a function :: a -> b, and an IO a, then fmap can give you an IO b
15:53:45 <Berengal> There is an escape from IO, but IO is warm and fuzzy compared to the horrors that await you on the outside
15:54:03 <ksf> and if you have an IO a and an a -> IO b, you can use >>= to connect them.
15:54:04 <sproingie> you can lift stuff into IO
15:54:19 <zygoloid> , maximumBy (compare `on` length) dict
15:54:21 <lunabot>  Stack space overflow: current size 8388608 bytes.
15:54:21 <lunabot>  Use `+RTS -Ksize' to increase it.
15:54:26 * Berengal just got an idea for a narrative about a value that was u-p-IOd
15:54:42 <zygoloid> Berengal: i think i see where you're going. i like it :)
15:55:00 <svendt> so if i just want the string, there's no recurse? okies.
15:55:11 <Taejo> IO is like a roach motel: the values check in but they never check out
15:55:43 <Berengal> '"Go away! You're not like us!" the other values yelled. "You're impure! Impure! Impure! Impure!" they started chanting.'
15:55:51 <sproingie> unmutual!
15:56:21 <zygoloid> the only way, ultimately, to do something with an IO a is to build an IO () out of it and execute that with the magical incantation "main ="
15:56:29 <heatsink> Taejo: data IO a = IO
15:57:08 <zygoloid> data IO a = forall b. IO b :)
15:57:38 <benmachine> main doesn't have to be IO () I think
15:57:48 <benmachine> (but whatever else it is gets discarded)
15:57:49 <heatsink> zygoloid, good idea.
15:57:53 <sproingie> nowadays it can be IO anything i think
15:58:01 <sproingie> and ghc will show it
15:58:08 <ksf> @remember Berengal '"Go away! You're not like us!" the other values yelled. "You're impure! Impure! Impure! Impure!" they started chanting.'
15:58:08 <lambdabot> Okay.
15:58:11 <Berengal> 'Bobby Boolean felt horrible. What did he ever do to the other values? He was just a simple bit, a simple answer to a simple question! Suddenly he felt his insides churn; he felt an exception coming on! Oh no! What should he do, now that he was outside of IO?'
15:58:12 <sproingie> er runghc that is
15:58:13 <benmachine> no runhaskell will show it
15:58:19 <benmachine> that is a bug I think
15:58:25 <benmachine> it should get eaten
15:58:31 <sproingie> i thought it was a deliberate feature
15:58:36 <sproingie> perhaps a misfeature to be sure
15:58:43 <ksf> @remember Berengal 'Bobby Boolean felt horrible. What did he ever do to the other values? He was just a simple bit, a simple answer to a simple question! Suddenly he felt his insides churn; he felt an exception coming on! Oh no! What should he do, now that he was outside of IO?'
15:58:43 <lambdabot> I will remember.
15:58:54 * ksf eyes Berengal 
15:59:05 <Berengal> ksf, I'm done, I need to go to bed anyway
15:59:14 * Berengal should probably get a blog for these things
15:59:18 <SamB_XP> sproingie: yeah, pretty sure that's delerate
15:59:21 <SamB_XP> er.
15:59:23 <SamB_XP> deliberate
15:59:33 <zygoloid> Berengal: you should write an entire childrens book
15:59:35 <SamB_XP> I don't think things like that happen ccidentally
15:59:43 <benmachine> SamB_XP: I think they do
15:59:52 <benmachine> runghc basically just invokes ghci
16:00:04 <benmachine> and ghci has strange behaviours for printing IO
16:00:13 <sproingie> if you compile it it won't do the same?
16:00:20 <benmachine> pretty sure it won't
16:00:30 <sproingie> now that sounds like a bug
16:00:37 <sproingie> i mean not the not printing it part
16:00:40 <Taejo> sounds like a job for... experimentman
16:00:40 <sproingie> but the inconsistency
16:00:45 <benmachine> yeah
16:00:53 <benmachine> I think runghc only prints it because ghci does
16:00:58 <benmachine> I don't think it's meant to be printed
16:01:01 <zygoloid> "Oh no!" thought Bobby, "This place is cold and isn't fuzzy at all!"
16:01:16 <ksf> well haskell isn't really designed towards supporting a repl, and runghc is just a hack.
16:01:34 <ksf> it would probably be cleaner to compile a binary to /tmp and execute it.
16:01:41 <sproingie> pretty good repl for not supporting one
16:01:52 <Taejo> nope, when | main = return "lol" | is compiled, nothing is output
16:02:02 <ksf> there's always people asking why you can't say foo = bar in ghci
16:02:26 <zygoloid> Berengal: presumably there's a happy ending wherein Bobby meets up with "evaluate" and they live happily ever after together?
16:02:34 <monochrom> Indeed haskell encourages forward references, no repl in mind.
16:03:09 <Taejo> monochrom: scheme seems to cope ok
16:03:44 <ksf> yep lisps could take a forward reference just fine, they aren't supposed to evaluate them statically that much.
16:05:56 <Taejo> ksf: I would argue that a Haskell repl should do the same
16:06:11 <Taejo> i.e., repl declarations should use a dynamic scope of sorts
16:08:34 <ksf> mmmh rewrite systems.
16:08:37 <ksf> and fgl.
16:08:39 <ksf> and frp.
16:08:48 * ksf needs a good night of sleep over that.
16:10:24 <ygd-coder> what haskell ide should I use?
16:10:35 <ksf> vim.
16:10:41 <ksf> ...well, leksah.
16:10:50 <ygd-coder> how's eclipsefp?
16:11:18 <ksf> last time I tried, defunct... but that's a while back.
16:11:27 <ygd-coder> oh okay, thanks
16:11:28 <ksf> leksah is fine.
16:11:45 <ksf> you won't find an ide that supports refactoring and such, anyway.
16:11:56 <ksf> (btw, what happened to hare?)
16:11:56 <Axman6> ygd-coder: you don't need an IDE for haskell
16:12:05 <ygd-coder> then what do I use?
16:12:15 <Axman6> a text editor
16:12:18 <ksf> a proper editor
16:12:23 <ivanm> emacs, vim, etc. all work
16:12:24 <ygd-coder> i use windows, that means notepad?
16:12:26 <FunctorSalad> class Newtype old new where ...
16:12:28 <FunctorSalad> ;)
16:12:29 <ksf> ...cabal, and git/darcs
16:12:36 <Axman6> ygd-coder: something better than notepad
16:12:39 <ygd-coder> okay
16:12:41 <Axman6> like notepad++
16:12:43 <ivanm> Axman6: heh
16:12:50 <ksf> ygd-coder, http://www.vim.org/
16:12:55 <Axman6> @karma notepad
16:12:56 <lambdabot> notepad has a karma of 36
16:13:02 <heatsink> wow
16:13:03 <ygd-coder> @botsnack
16:13:03 <lunabot>  :o
16:13:04 <lambdabot> :)
16:13:15 <ygd-coder> @karma vim
16:13:15 <lambdabot> vim has a karma of 4
16:13:16 <heatsink> @karma emacs
16:13:17 <lambdabot> emacs has a karma of 3
16:13:21 <heatsink> boo
16:13:23 <ygd-coder> @karma notepad++
16:13:23 <lambdabot> notepad++ has a karma of 0
16:13:26 <monochrom> emacs++
16:13:31 <Axman6> in my experience, there's no need for an IDE with haskell
16:13:32 <ygd-coder> @karma gvim
16:13:33 <lambdabot> gvim has a karma of 0
16:13:38 <ygd-coder> @karma leksah
16:13:39 <lambdabot> leksah has a karma of -1
16:13:40 <ivanm> monochrom: \o/
16:13:41 <monochrom> I use both emacs and vim all the time. Why fight.
16:13:49 <Nafai> Language aware features in an editor are always welcome
16:13:53 <monochrom> Can we just all get along?
16:13:55 * Axman6 dislikes them both
16:13:58 <heatsink> @karma yi
16:13:59 <lambdabot> yi has a karma of 2
16:14:05 <Nafai> I think IDE features are disparaged because people think they are crutches
16:14:21 <SamB_XP_> sometimes maybe they are crutches
16:14:28 <SamB_XP_> but some people have broken legs ;-)
16:14:31 <ksf> @karma vi
16:14:31 <lambdabot> vi has a karma of 0
16:14:35 <ygd-coder> @karam gedit
16:14:36 <lambdabot> Maybe you meant: karma karma+ karma-
16:14:36 <SamB_XP_> and perhaps more often they are stilts
16:14:38 <ygd-coder> @karma gedit
16:14:39 <lambdabot> gedit has a karma of 0
16:14:40 <bob0> @karma vim
16:14:41 <lambdabot> vim has a karma of 4
16:14:46 <ygd-coder> @karma kate
16:14:46 <lambdabot> kate has a karma of 0
16:14:50 <bob0> @karma+ vim
16:14:51 <lambdabot> vim's karma raised to 5.
16:14:59 <ygd-coder> @karma vim
16:15:00 <lambdabot> vim has a karma of 5
16:15:00 <SamB_XP_> ... the two are surprisingly similar, are they not ?
16:15:07 <zygoloid> > let vim = "can't we all ju"; emacs = "st get along" in vim++emacs
16:15:08 <lambdabot>   "can't we all just get along"
16:15:12 <zygoloid> @karma vim
16:15:12 <lambdabot> vim has a karma of 5
16:15:14 <monochrom> "some IDE features are crutches" : "IDEs are crutches" :: "some programming languages are crutches" : "programming is crutches"
16:15:16 <zygoloid> aww
16:15:17 <Nafai> I think many features (such as code navigation, completion, documentation viewing in the editor, etc) are productivity enhancers, not crutches
16:15:28 <ygd-coder> > putStrLin "Does this actually work?"
16:15:44 <ygd-coder> > putStrLn "Does it work now?"
16:15:55 <Axman6> @karma
16:15:55 <lambdabot> You have a karma of 6
16:15:55 <Axman6> hoorah
16:15:55 <zygoloid> @karma You
16:15:55 <lambdabot> You has a karma of -1
16:15:55 <Axman6> Axman > Vim
16:15:55 <lambdabot>   Not in scope: `putStrLin'
16:15:55 <lament> no IDE features are crutches.
16:15:55 <lambdabot>   <IO ()>
16:15:56 <benmachine> lambdabot doesn't like IO
16:16:00 <Twey> @karma emacs
16:16:01 <lambdabot> emacs has a karma of 4
16:16:04 <Twey> emacs++
16:16:05 <lament> (a crutch being a tool the use of which is less efficient than walking)
16:16:06 <zygoloid> lament: my IDE has a 'crutch' command in the edit menu
16:16:12 <Twey> zygoloid: Hahahahaha
16:16:31 <fxr> you're all in my emacs
16:16:36 <benmachine> wonder why he needed to quit to do that
16:16:40 <SamB_XP_> lament: well, it depends
16:16:42 <Axman6> ... why on earth did he need to quit to do that?
16:16:46 <SamB_XP_> on how fast your 'net connection is
16:16:50 <fxr> but I don't like emacs
16:16:54 <Twey> Single-process machine?  :
16:17:08 <SamB_XP_> sometimes, it might be faster to walk than use *some* 'net-related IDE features ;-)
16:17:30 <Twey> IDE features are language features that haven't been implemented yet.
16:17:39 <SamB_XP_> Twey: not all of them
16:17:53 <SamB_XP_> say, the "Run in debugger" command
16:17:56 * Axman6 isn't sure refactoring code is a language feature
16:17:57 <SamB_XP_> that's not a language feature!
16:18:05 <SamB_XP_> that too
16:18:07 <Twey> I don't rule out the possibility that some of them have no discovered method of implementation
16:18:33 <Axman6> we are not turning Haskell into a self source modifying language
16:18:48 <FunctorSalad> "rename this identifier" indeed isn't a lang feature
16:19:08 <zygoloid> Axman6: right on. three days later haskell becomes self-aware.
16:19:09 * Twey grins.
16:19:11 <SamB_XP_> the lexical scope you need to *do* that, of course, *is* a language feature
16:19:19 <FunctorSalad> yeah
16:19:33 <zygoloid> FunctorSalad: i disagree; it could be, depending on how exactly the language is represented :)
16:19:39 <SamB_XP_> zygoloid: but three days earlier, oleg himself goes crazy from the twisted types involved
16:19:49 <Twey> Unpossible!
16:21:34 <zygoloid> GHC says: this type is so messed up even Oleg doesn't know what you're doing
16:21:42 <zygoloid> @ghc
16:21:42 <lambdabot> ghc says: primitive string literal must contain only characters <= '\\\\xFF\\'
16:24:10 <Axman6> > "\\\\xFF\\"
16:24:11 <lambdabot>   "\\\\xFF\\"
16:24:23 <Axman6> > text "\\\\xFF\\"
16:24:24 <lambdabot>   \\xFF\
16:29:31 <zygoloid> > let x = "foo\x1ff"# in 42
16:29:32 <lambdabot>   <no location info>:
16:29:32 <lambdabot>      primitive string literal must contain only charact...
16:30:21 <ivanm> zygoloid: that's not a function...
16:30:51 <ivanm> > (\x -> "foo\\" ++ show x ++ "1ff") 42 -- this what you meant?
16:30:52 <ksf> > let foo = "bar" in 23
16:30:52 <lambdabot>   "foo\\421ff"
16:30:52 <lambdabot>   23
16:31:05 <ivanm> oh, right, the # probably didn't help
16:31:08 <zygoloid> ivanm: no, i meant what i typed...
16:39:50 <sinelaw> is there anything being done in Haskell prime to somehow help users avoid space leaks?
16:40:20 <sinelaw> or make performance better in general without resorting to specific performance hacks in the code?
16:40:25 <Pseudonym> Yes, there is a proposal for a large hammer that comes out of the compiler, and a message which says "don't write any space leaks or else".
16:40:33 <copumpkin> nope
16:40:34 <Aero1> Anyone fluent in true basic here?
16:40:37 <Raynes-> They could give every user lots of space patches to patch up the leaks.
16:40:47 <sinelaw> Pseudonym, I already have that as an extension, but doesn't seem to help
16:40:49 <Raynes-> Aero1: Wrong channel, I would venture to guess.
16:41:06 <Aero1> ..programming?
16:41:24 <Aero1> Ah
16:41:26 <SamB_XP_> Haskell is a language ;-P
16:41:26 <Aero1> Nevermind
16:41:32 <Aero1> Yeah just noticed :P
16:41:41 <Pseudonym> sinelaw, space leaks are seen as partly design pattern-type issues (i.e. follow this pattern to avoid writing them) and compiler technology, like memory profiling.
16:41:42 <Twey> You've ventured into #haskell.  Perhaps you wanted to try #truebasic or something, but probably you just want to switch to Haskell.  :
16:41:54 <SamB_XP_> this is not *just* a hang-out for loads of smart people
16:41:56 <Pseudonym> We do have a Basic module.
16:41:57 <Aero1> First language :/
16:42:00 <SamB_XP_> and idiots like me ;-)
16:42:14 <sinelaw> Aero1, learn Haskell isntead.
16:42:15 * Axman6 recommends haskell as a first language
16:42:16 <Twey> Aero1: Bad choice
16:42:21 <Raynes> Oh hell. Basic as a first language. ._.
16:42:24 <Twey> Aye.
16:42:25 <sinelaw> but don't make typos.
16:42:26 <Raynes> My eyes burn and my teeth hurt.
16:42:27 <Pseudonym> SamB: If we get enough of you and I together, we get an effective smart person equivalent.
16:42:29 <Twey> Heh
16:42:31 <Aero1> It's a class, no choice.
16:42:38 <Raynes> Your school sucks.
16:42:39 <Twey> Aero1: Complain.
16:42:41 <Twey> Lots.
16:42:42 <Twey> Please.
16:42:46 <Pseudonym> Aerol: You have our sympathy.
16:42:53 <Axman6> very much so
16:42:53 <Aero1> Lol.
16:42:54 <Twey> Truly.
16:43:00 <sinelaw> Indeed
16:43:03 <Raynes> You'll be in my prayers.
16:43:05 <Pseudonym> Hey, Basic was my first language.
16:43:05 <Raynes> <3
16:43:08 <sinelaw> At least it's not C++
16:43:22 * Twey eyes Pseudonym.
16:43:36 * Pseudonym had an 8-bit micro in the 80s, what?
16:43:38 <sinelaw> Mine too. GW-BASIC
16:43:42 <Aero1> So, in general how does one read where an error would be with something like "2:8:11"?
16:43:44 <Axman6> always knew there was something odd about you Pseudonym
16:43:45 <Axman6> :P
16:43:46 <Aero1> Noob question
16:44:02 <ksf> hey. schneider-basic. with advanced line-numbering commands.
16:44:10 * Twey chuckles.
16:44:18 <sproingie> basic was my first language too.  the craptastic commodore basic at that
16:44:22 <sinelaw> Hindley-Milner Basic
16:44:30 <Twey> Hahaha
16:44:36 <Twey> Someone ought to implement that
16:44:37 * Axman6 notes there is a BASIC package that implements basic in haskell, and compiles it to LLVM
16:44:38 <ksf> you could say "read many lines, and assign them to line numbers n+m, where m is the increment"
16:44:39 <sinelaw> with extensions allowing monomophisms
16:44:39 <Pseudonym> sproingie: Ah, the first eposure to Microsoft!
16:44:41 <sproingie> written by one mr bill gates
16:44:47 <ksf> ...you could move whole blocks of lines.
16:44:56 <ksf> AND AUTOMAGICALLY MOVE THEM GOTOS!
16:44:58 <Pseudonym> My first micro Basic was on an obscure machine that nobody has heard of.
16:45:03 <Twey> Hahaha.
16:45:07 <Pseudonym> COMX-35
16:45:18 <Aero1> Hm, well thanks for the effort. :p
16:45:25 <Twey> Ack.  Midnight.  Sleep.  'bye.
16:45:28 <Pseudonym> It had one distinguish feature which made it kinda cool: It had the same CPU as the Voyager spacecraft.
16:45:39 <Axman6> Aero1: where are you doing this course?
16:45:48 <sinelaw> Aero1 you got us started on nostalgy, good luck getting any relevant information for the next 5 minutes.
16:45:50 <Pseudonym> So I think of it as the only one of the 1980s-era 8-bit micros which was radiation hardened.
16:46:28 <ksf> you know, back in the days, like the original ibm pc... they came with an assembler built into the bios.
16:46:45 <ksf> no need to boot dos from floppy.
16:46:52 <sproingie> hell some of them came with basic at that
16:47:04 <Aero3> Hello.
16:47:22 <Pseudonym> Greetings.
16:47:35 <Axman6> Aero3 == Aero1?
16:47:39 <Aero3> ...
16:47:42 <sproingie> i had an original model pre-xt pc.  was my terminal for ages
16:47:42 <ksf> by ip, yes.
16:47:52 <Axman6> ah yes
16:48:00 <Pseudonym> OK, this is frightening.  The RCA 1802 is still being manufactured.
16:48:06 <Axman6> Aero3: where are you doing this basic course?
16:48:06 <Pseudonym> Why, $DEITY, why?
16:48:07 * ksf has an opened mfm disk hung from his wall.
16:48:16 <sproingie> managed to get a 20MB HDD into it, it would only manage to see 10 megs of it tho
16:48:39 <sproingie> but it was more than i needed to store all my software
16:48:39 <Axman6> sproingie: just fplit it over to get at the other 10MB
16:48:41 <Axman6> >_>
16:48:41 <ksf> heck there has to be _some_ witness of geekness in my appartment, two lcds aren't enough, these days.
16:49:00 <sproingie> had a 896K zuckerboard in there too.  that sucker was a space heater
16:49:08 <ksf> ...well there's the old epson epl 7500 and the ultrasparc 1.
16:49:17 * Axman6 has a Mac Classic II and a Mac Plus as speaker stands
16:49:23 <sinelaw> sproingie that's cool. maybe I should get my XT to run as a terminal?
16:49:24 <sproingie> it could do over a meg but it was missing a bunch of chips
16:49:31 <ksf> 100.000+ printed pages. beat that.
16:49:32 <sinelaw> will that be hard?
16:49:38 <SamB_XP_> sinelaw: there's one problem
16:49:39 <Aero3> I'm currently in highschool.
16:49:45 <SamB_XP_> it only has 24 lines :-(
16:49:54 <SamB_XP_> Aero3: excuses, excuses!
16:49:58 <Axman6> Aero3: also, how did you find this channel?
16:50:01 <sproingie> ran a term program called {COMMO} (the braces being part of the name)
16:50:14 <sinelaw> SamB_XP_ on my XT the video card allows an 80 line mode too
16:50:19 <sinelaw> IIRC
16:50:21 <Axman6> COMMONIST!
16:50:23 <sproingie> it was hot.  it had a scripting language in it that was literate
16:50:26 <SamB_XP_> 80 line?
16:50:27 <Aero3> Did a search on popular programming iirc channels. Thought Haskell was the name of the channel.
16:50:32 <SamB_XP_> 80x80 sounds crazy
16:50:36 <sproingie> it would only execute stuff in curly braces, everything else was comment
16:50:37 <sinelaw> 80x120 i think
16:50:53 <SamB_XP_> Aero3: I guess it #haskell is the name of a popular programming channel
16:50:57 <SamB_XP_> no real idea *why*!
16:51:05 <Axman6> Aero3: well, it's the name of a programming language (a very nice one, and i highly recommed learning it)
16:51:10 <SamB_XP_> I guess we've failed :-(
16:51:55 <Aero3> So how do you find an error by the numbers listed? "2:8:11"
16:52:01 <Aero3> Line, word, letter?
16:52:02 <sinelaw> i really wonder what will it take to connect my XT to ethernet, and get ssh or telnet running on it. I don't think it even has a serial port
16:52:03 <sproingie> open your bible
16:52:06 <lament> chapter, verse
16:52:22 <ksf> xt's come with a serial port.
16:52:28 <sinelaw> sproingie, in the book of Basic?
16:52:44 <ksf> ...well...
16:52:45 <Axman6> Aero3: i've only ever seen x:y errors. seems you're using some kind of 3D programming language o.O
16:52:48 <sproingie> ssh on an XT ahaha
16:52:53 <ksf> at least you should have an isa card for it.
16:53:08 <sinelaw> i'll check next time i vist my parents
16:53:23 <SamB_XP_> sproingie: I was assuming a serial cable woul be used
16:53:28 <sinelaw> that would be so cool. an XT on my desk serving as my textual gateway to cyberspace.
16:53:39 <SamB_XP_> Axman6: or the creators didn't know about the '-' character
16:53:50 <sproingie> SamB_XP_: i suspect the problem is doing ssh with that slow a CPU
16:53:51 <Axman6> hmm, possible
16:53:51 <ksf> usually, it's 2:8-11: line two, character 8 thru 11
16:53:57 <sinelaw> it will also take a hellofalot of space
16:54:12 <sinelaw> well telnet is good enough
16:54:12 <Axman6> hello falot
16:54:14 <SamB_XP_> sproingie: I meant, that was the only thing I would have thought such a terminal good for
16:54:21 <sproingie> even the dinky embedded cpus now are at least 32-bit
16:54:36 <sinelaw> or i can have it as a pty
16:54:40 <SamB_XP_> wouldn't have figured there were any 16-bit x86 SSH clients
16:54:55 <sproingie> mine was to connect to the dialup of the school's server, which had internet
16:55:09 <ksf> software for x86 starts with 386... memory management.
16:55:10 <sproingie> little thingie called a modem
16:55:13 <ksf> linux etc.
16:55:18 <ksf> running nethack.
16:55:24 <monochrom> Is iPod Touch's cpu 32-bit? let's say the latest one.
16:55:35 <sproingie> nethack is in fact what i spent most of my time playing
16:55:37 <sinelaw> i actually learnt Basic, Pascal AND assembly on that machine.
16:56:01 <monochrom> I learned basic on a 4-bit computer!
16:56:10 <sproingie> i must have played a thousand hours of nethack.  i've never ascended once.
16:56:19 <sproingie> not outside of wizard mode that is
16:56:34 <SamB_XP_> monochrom: I doubt any of them have been 16-bit since they could display images!
16:57:17 <monochrom> Anyway, next time someone searches the web for machine code channels, they will find us.
16:57:50 <sproingie> cpu in an ipod touch is an ARM, no?
16:58:02 <Axman6> yes
16:58:02 <monochrom> Yes, I know little about ARM.
16:58:29 <Pseudonym> Man, I just got all nostalgic.
16:58:31 * Axman6 is tech ically the maintainer of the ARM emulator on hackage
16:58:38 <Pseudonym> http://www.computerhistory.org/collections/accession/102651077 <- I did my honours thesis on a Hazeltine Esprit terminal
16:58:53 <ksf> ARM vs CORE. it's still the same, old battle.
16:58:59 <Axman6> CORE?
16:59:00 <copumpkin> CORE?
16:59:02 <Pseudonym> These things were cool and gave you the worst RSI of any terminal ever.
16:59:02 <copumpkin> lol
16:59:04 <Axman6> never even heard of it
16:59:06 <copumpkin> Axman6: HAI FAIV
16:59:21 <Axman6> copumpkin: OH HAI FAIV!
16:59:23 <sproingie> Axman6: it's a joke from Total Annihilation
16:59:29 <ksf> philistines!
16:59:32 <copumpkin> oh, I actually remember that
16:59:34 <Axman6> from what?
16:59:40 <copumpkin> I haven't played that in years
16:59:50 <Pseudonym> CORE WAR!
17:00:01 <ksf> http://en.wikipedia.org/wiki/Total_Annihilation
17:00:12 <sproingie> "this is a battle to the death.  for each side, the only acceptable outcome is the complete elimation of the other"
17:00:17 <copumpkin> that was a fun game
17:00:21 <ksf> ...there's http://springrts.com/ , now.
17:00:27 <sproingie> had the coolest soundtrack, totally bombastic orchestral score
17:00:56 <sinelaw> who wants to play "fix fix"?
17:01:18 <monochrom> @type fix fix
17:01:19 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
17:01:19 <lambdabot>     Probable cause: `fix' is applied to too many arguments
17:01:19 <lambdabot>     In the first argument of `fix', namely `fix'
17:01:21 <Axman6> :t fix . fix
17:01:22 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
17:01:22 <copumpkin> > fix (const fix)
17:01:24 <sproingie> i liked the core mission briefings.  "DESTROY ALL ARM UNITS.  DO SO NOW."
17:01:26 <lambdabot>   mueval-core: Time limit exceeded
17:02:05 <sinelaw> Axman6 now that's cheatin'
17:02:53 <Axman6> @hoogle ((a -> a) -> a -> a)
17:02:54 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
17:02:54 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
17:02:54 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
17:03:11 <Axman6> > fix . fix (until (const False))
17:03:16 <Axman6> > fix . fix $ (until (const False))
17:03:17 <lambdabot>   mueval-core: Time limit exceeded
17:03:17 <lambdabot>  mueval: ExitFailure 1
17:03:20 <SamB_XP_> sproingie: what if I'd rather destry M68K units ?
17:03:23 <lambdabot>   mueval-core: Time limit exceeded
17:03:24 <lambdabot>  mueval: ExitFailure 1
17:03:42 <sproingie> SamB_XP_: drop a few macs off the roof then
17:04:12 <mansour> how do I construct a list of integers ? what is the syntax to do the range ?
17:04:25 <mansour> for example from 1 to 500
17:04:27 <SamB_XP_> I don't have any macs -- much less <=System 6!
17:04:28 <sinelaw> in high school we once found a really old heavy disk drive and threw it from the 3rd floor to see how rugged it is
17:04:32 <blackh> [1..500]
17:05:03 <sinelaw> i was huge and weighed like 3 kilos
17:05:04 <mansour> blackh: thanks, I was using [1...500]. LOOOL
17:05:10 <monochrom> hahaha
17:05:31 <sproingie> that's real syntax in some language i forget what
17:06:00 <sinelaw> then we opened it and inscribed "DIR II" on it and tried to trick a friend that that's what the virus (dir 2) does.
17:06:08 <sproingie> oh yeah perl.  changes the flip-flop behavior somehow
17:06:23 <jvoorhis> mansour: another neat trick is [1,2..500]
17:06:40 <jvoorhis> where the second int controls the step size
17:06:48 <jvoorhis> > [2,4..10]
17:06:50 <lambdabot>   [2,4,6,8,10]
17:07:01 <Cale> GAP seems to represent [1..50] as something which isn't immediately a list...
17:07:18 <Cale> gap> [1..10];
17:07:19 <Cale> [ 1 .. 10 ]
17:07:19 <Cale> gap> Elements([1..10]);
17:07:19 <Cale> [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
17:07:27 <copumpkin> GAP?
17:07:31 <jvoorhis> and then Ruby uses .. for inclusive lists and ... for exclusive lists
17:07:44 <jvoorhis> except where i said lists i meant Ranges
17:07:48 <copumpkin> ruby represents it as a range
17:07:48 <sinelaw> So at about the same time some of you guys were welcoming the Haskell 98 report, I was chucking old disk drives out windows
17:08:08 <sinelaw> more like 1.4 maybe
17:08:10 <mansour> jvoorhis: thank you, I forgot all these neat things. This is another usefull form
17:08:21 <sproingie> 1.4, now with monad comprehensions!
17:08:21 <SamB_XP_> sinelaw: WHO dared welcome the Haskell 98 Report?!?!
17:08:23 <Cale> copumpkin: It's free computational algebra (particularly group theory) software.
17:08:25 <SamB_XP_> WHOOOOOO!
17:08:30 <copumpkin> Cale: oh, interesting
17:09:37 <dolio> Does it have an algebra wizard? Someone may have stolen copumpkin's idea.
17:09:58 <Cale> gap> g := Group((1,2,3)(4,5),(1,2)(3,4,5));
17:09:58 <Cale> Group([ (1,2,3)(4,5), (1,2)(3,4,5) ])
17:09:58 <Cale> gap> Size(g);
17:09:58 <Cale> 120
17:09:58 <Cale> gap> StructureDescription(g);
17:09:59 <Cale> "S5"
17:10:13 <monochrom>  @remember sinelaw i was huge and weighed like 3 kilos  <duck>
17:10:35 <sinelaw> monochrom: you bastard
17:10:39 <SamB_XP_> sinelaw used to be a parade balloon ?
17:11:35 <sinelaw> Actually that remark was correct at the time of my birth
17:11:47 <sinelaw> :)
17:11:53 <jvoorhis> so i've asked here before with no answer, but i'll ask once more  is anyone here an FFI wizard? :)
17:12:09 <blackh> jvoorhis: Yes!
17:12:11 <jvoorhis> pretty soon, i want to push my first hackage package
17:12:19 <sinelaw> congrads!
17:12:24 <jvoorhis> thanks
17:12:35 <sinelaw> may it live long and prosper...what's it about?
17:12:54 <jvoorhis> bindings for a portion of OS X's CoreAudio api
17:13:09 <jvoorhis> so i guess i'm soliciting constructive crit
17:13:09 <Axman6> ooo, nice
17:13:11 <jvoorhis> http://github.com/jvoorhis/hs-coreaudio
17:13:26 <Axman6> i want to make a binding to the Accelerate package
17:13:30 <jvoorhis> it assumes a 32-bit machine  i figure 64 bit mac is moot for the time being
17:13:47 <Axman6> all macs are 64 bit :\
17:14:03 <jvoorhis> ok, it assumes ghc is running in 32-bit mode
17:14:08 <Axman6> yeah
17:14:25 <Axman6> since we haven't managed to get a 64 bit GHC yet, that's a fair enough assumption
17:14:36 <jvoorhis> for the time being, yeah
17:14:42 <copumpkin> mmorrow: so the closure types I can't serialize are the PAP ones?
17:14:59 <jvoorhis> it's primarily an AudioUnit host
17:15:02 <heatsink> jvoorhis, Can you put the haddock somewhere?
17:15:14 <copumpkin> oh nice, some macos-specific stuff
17:15:38 <jvoorhis> heatsink: i have haddock but i haven't yet; i've been developing it on another machine so i can't do that now
17:15:50 <jvoorhis> http://github.com/jvoorhis/hs-coreaudio/tree/master/doc/examples/ for a peek at how it's used
17:16:12 <jvoorhis> and some of the stuff in src/System/Mac might end up in its own package
17:17:06 <sinelaw> monochrom: lambdabot never acknowledged your command, btw :)
17:17:19 <monochrom> I intended to just joke.
17:17:33 <blackh> jvoorhis: "any" could be annoying because there's a function of the same name in Prelude
17:17:41 <sinelaw> ah. well executed
17:18:02 <jvoorhis> blackh: i tend to agree, but i haven't thought of a better name yet
17:18:09 <jvoorhis> it is a minor nuisance for now
17:18:33 <blackh> jvoorhis: How do you make it make sound?
17:18:59 <jvoorhis> blackh: check out http://github.com/jvoorhis/hs-coreaudio/blob/master/doc/examples/PlayMidi.hs
17:19:21 <heatsink> jvoorhis, the bindings look well-constructed in general, but still rather low-level.  A high level interface that doesn't involve memory allocation would be nice.
17:19:55 <heatsink> Rather, doesn't expose memory allocation.
17:20:10 <jvoorhis> heatsink: where does it expose allocation?
17:20:55 <jvoorhis> my goal is to keep the bindings in Sound.* very transparent while abstracting away the Foreign apis
17:21:05 <heatsink> I thought that's what was main = graph <- new .... dispose graph
17:21:15 <jvoorhis> ah
17:21:45 <Axman6> jvoorhis: would anything be a good name for any?
17:21:57 <ivanm> heatsink: two-layered bindings? have a low-level one, and then a high-level one built on top of them for people that don't want to fiddle?
17:22:01 <jvoorhis> Axman6: verbose, but not bad
17:22:11 <jvoorhis> i wouldn't mind having a higher-level wrapper
17:22:19 <heatsink> ivanm, that's what I'm thinking.
17:22:25 <jvoorhis> or just a bracket-style combinator like withAUGraph
17:22:58 <ivanm> I take it "graph" is a term used by CoreAudio?
17:22:59 <jvoorhis> since there's no library code to save/load AUGraph configurations, i'm also toying with the idea of a JSON wrapper for that
17:23:01 * heatsink digs up its example
17:23:15 <SamB_XP_> I assume graph is like the aural equivalent of a scene graph ?
17:23:19 <jvoorhis> ivanm: that's right
17:23:23 <jvoorhis> it's a signal processing graph
17:23:24 <ivanm> heatsink: you're an "it" now? :p
17:23:26 <Axman6> jvoorhis: i think i'd rename the modules to be something like System.Mac.AUComponents
17:23:27 <ivanm> ahhhh
17:23:46 <jvoorhis> Axman6: i'm following Sound.{Framework}.{Header} for my module names so far
17:23:50 <ivanm> Axman6: maybe OSX rather than Mac, in case it changes in OS11 (or whatever they'll call it)?
17:24:03 <ivanm> jvoorhis: I'd hide it away under the OS being used...
17:24:03 <SamB_XP_> EvilTerran: OS Xi!
17:24:14 <Axman6> i'm sure they'll still have CA in OS XI :P
17:24:15 <ivanm> SamB_XP_: do you mean me? :p
17:24:24 <EvilTerran> SamB_XP_, what?
17:24:35 <SamB_XP_> e, i, what's the diff ?
17:24:53 <ivanm> SamB_XP_: the disadvantages of over-zealous nick completion? :p
17:25:01 <ivanm> EvilTerran: he meant me
17:25:07 <EvilTerran> i see
17:26:22 <heatsink> jvoorhis, I used a kind of embedded approach in Omega: there are high-level constructors that build the low-level operations.
17:26:34 <coldpizza72i> hello
17:26:39 <Axman6> 'lo coldpizza72i
17:26:43 <jvoorhis> heatsink: Omega?
17:27:08 <coldpizza72i> a friend reffered me here.....what is haskell?
17:27:21 <Axman6> it's a programming language
17:27:22 <ivanm> a purely functional programming language
17:27:36 <heatsink> jvoorhis, If you feel like checking it out, it's at http://hackage.haskell.org/package/Omega
17:27:42 <jvoorhis> heatsink: i wouldn't be opposed to adding some of that, but to get things started, i wanted to stay close to the underlying api, especially so Apple's docs could still be useful
17:27:44 <heatsink> but hackage doesn't auto-build properly so you can't read the haddock online
17:27:55 <heatsink> jvoorhis, A reasonable way to start
17:28:06 <coldpizza72i> could i post my calculator error here.....im having trouble finding something
17:28:16 <jvoorhis> heatsink, Axman6, ivanm: i appreciate the feedback
17:28:16 <Axman6> coldpizza72i: is it long?
17:28:31 <jvoorhis> also, some of the dicey stuff is in http://github.com/jvoorhis/hs-coreaudio/blob/master/src/System/Mac/Types.hs
17:28:37 <coldpizza72i> not particularly
17:28:38 <jvoorhis> i wondered if anyone would have an ill reaction to it :)
17:28:40 <ivanm> jvoorhis: no worries (even though I don't use anything associated with Apple)
17:28:48 <Axman6> coldpizza72i: well, either paste it here, or use hpaste:
17:28:51 <Axman6> @where hpaste
17:28:52 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
17:28:58 <Axman6> use the second url
17:29:19 <Cale> I wonder if byorgey knows about http://snak.tdiary.net/20091020.html
17:29:21 <jvoorhis> i was surprised that i couldn't find any library for working with Pascal strings
17:29:28 <heatsink> jvoorhis, You'd have to be pretty talented to write code that makes people ill, I think
17:29:32 <nwcmr> I sent him here because #haskell programmers are assumed to be great mathematicians :)
17:29:34 <heatsink> Unless you program medical devices
17:29:38 <ivanm> heatsink: wtf is Presburger arithmetic?
17:29:48 * Beelsebob fries bacon in the channel
17:29:55 <Baconizer> D:
17:29:59 <Baconizer> Beelsebob: stop that
17:30:00 <Axman6> OM!
17:30:05 <coldpizza72i> k i have an 89titanium and i cant remember how i used to find the liner regression model......i have the stats program on it and the data in list1 and list 2........and i am able to graph that data perfectly.......but am getting "domain error" when i do linreg(ax+b) my settings are
17:30:06 <ivanm> nwcmr: isn't that what ##maths is for?
17:30:06 <coldpizza72i> x list = list1...................y list = list 2...............store regean to y1(x).............freq=null.........category list = null..........include categorys={}
17:30:07 <jvoorhis> Beelsebob: just don't microwave any popcorn and we're cool
17:30:15 --- mode: ChanServ set +o monochrom
17:30:25 <SamB_XP_> heatsink: I'm pretty sure he meant code that makes the *reader* ill
17:30:30 <nwcmr> ivanm: he tried it already without success
17:30:36 <nwcmr> there
17:30:43 --- mode: monochrom set +b coldpizza72i@*!*@*
17:30:44 <Axman6> monochrom: um what?
17:30:49 --- mode: monochrom set -o monochrom
17:30:57 <Axman6> what did you do that for?
17:30:59 <SamB_XP_> Cale: did you say that ##math is getting more and more jerky these days ???
17:31:08 <Cale> SamB_XP_: yeah, somewhat.
17:31:10 <Peaker> hmm.. I didn't know freenode had silent kicks
17:31:11 <ivanm> heatsink: and why doesn't Omega support ghci?
17:31:12 <heatsink> ivanm, Presburger arithmetic is a subset of arithmetic.  It uses 'forall', 'exists', addition, subtraction, the >= operator, boolean operators.  It's interesting because every presburger arithmetic formula can be solved.
17:31:17 <Cale> SamB_XP_: Though it might have calmed down
17:31:19 <monochrom> For janitor's job.
17:31:23 <ivanm> heatsink: ahhh
17:31:29 <heatsink> ivanm, It uses a C++ library, which GHCi doesn't support.
17:31:33 <jvoorhis> ivanm: and thanks for looking past your prejudices to help me out :)
17:31:37 <ivanm> heatsink: *nod*
17:31:39 <ivanm> jvoorhis: heh
17:31:56 <ivanm> Cale: #haskell, the last bastion of freedom and politeness on Freenode? :p
17:32:06 <Axman6> monochrom: what did he do to deserve that? he was just asking a question. that was particularly unhelpful
17:32:20 <ivanm> Axman6: his way of asking it could have been better though
17:32:27 <jvoorhis> heatsink: also, thanks for the "well-constructed" remark
17:32:32 <monochrom> You're welcome to help him on his 89titanium haskell question.
17:33:00 <jvoorhis> i feel like i'm progressing from beginner to intermediate, but i was toying with the idea of giving a little presentation of what i learned at our local FP meetup
17:33:01 <Axman6> well, you could have at least directed him somewhere more useful
17:33:28 <ivanm> jvoorhis: where is your local group?
17:33:37 <jvoorhis> ivanm: portland, oregon
17:33:42 <ivanm> ahhh
17:33:54 <Axman6> monochrom: i
17:34:16 <Cale> Yeah, I tend to prefer using operator privileges as a last resort when people are being unreasonable.
17:34:31 <heatsink> Hmm, I didn't know you could use <- in a guard.
17:34:35 <Axman6> i'm just a little shocked to see someone treated like that, who hadn't done anything wrong, and was being polite and was in need of help
17:34:43 <Cale> heatsink: Yeah, that's an extension
17:34:44 <jvoorhis> heatsink: -XPatternGuards turns that on
17:34:46 <ivanm> heatsink: it's an extension, isn't it?
17:34:48 <Cale> PatternGuards
17:34:52 <ivanm> heh
17:34:53 <heatsink> It must be an extension.
17:34:53 <SubStack> I should move to a place with FP meetups
17:34:57 <heatsink> :)
17:35:14 <sinelaw> SubStack or start some at your place! I just though about that today
17:35:18 <sinelaw> *thought
17:35:57 <SubStack> would need the numbers for it
17:36:10 <SubStack> I might do a haskell presentation through something else I'm starting though
17:36:23 <sinelaw> http://functional-programming.meetup.com/
17:36:30 <sinelaw> just googled that
17:37:20 <SubStack> portland isn't even on that map... seems incomplete
17:37:34 <sinelaw> yes, i doubt all the groups actually use that
17:37:56 <sinelaw> try the haskell one: http://haskell.meetup.com/
17:38:17 <jvoorhis> we go by 'pdx-func'
17:38:29 <nwcmr> Axman6: it's ok. It is me to blame for sending him here in the first place: it's just that he seemed quite desperate after having tried at #math and #math-software
17:38:39 <jvoorhis> and you're right, they missed us
17:39:03 <sinelaw> jvoorhis so you might as well add yourself(es)
17:39:09 <Axman6> nwcmr: well i can think of worse places to send someone with maths related questions than #haskell
17:39:18 <jvoorhis> sinelaw: yup, noted
17:40:03 <SubStack> why do regression analysis on a calculator anyways?
17:40:29 <Axman6> because it's easy
17:40:50 <ivanm> SubStack: if you have to do it in class, etc. and don't have access to a computer?
17:41:17 <SubStack> that seems like an unlikely scenario
17:41:40 <ivanm> really? why?
17:42:02 <Axman6> SubStack: well, having had to do it many times, i don't think it's unlikely at all
17:43:06 <sinelaw> happy i never did statistics
17:43:34 <ivanm> sinelaw: agreed ;-)
17:43:35 <SubStack> I like the theory behind it more than the particulars.
17:43:48 <sinelaw> Random processes was very interesting
17:43:50 <dolio> I had a test in a numerical methods class, once, where I only brought a bare-bones scientific calculator, instead of the high-end TIs that everyone else brought.
17:44:00 <Cale> That's interesting, in Japanese fonts, \ becomes  which means that Japanese programmers have the  sign for lambda :)
17:44:14 <dolio> Everyone else had programmed their calculators with the algorithms, and I had to do them by hand for the test.
17:44:22 <ivanm> Cale: isn't that the Yen sign?
17:44:24 <Cale> yes
17:44:29 <ivanm> dolio: and they cleared the calculators?
17:44:42 <Axman6> sinelaw: not when they're taught be a german self professed bastard
17:44:45 <dolio> No, programming the calculators was allowed.
17:44:55 <ivanm> :o
17:45:01 <SubStack> just make it a take-home test and let people use real computers
17:45:02 <Cale> Apparently they're used to using  as the path separator on Windows.
17:45:09 <dolio> I was just an idiot.
17:45:23 <ivanm> dolio: we always had to clear our calculators (OK, at some physics exams at uni they dind't really care, but they gave you formula sheets anyway...)
17:45:24 <dolio> I ended up dropping the class anyway, because it was at 8 A.M.
17:45:31 <ivanm> dolio: heh
17:45:40 <SamB_XP_> Cale: I'm getting kind of used to it myself
17:45:45 <ivanm> that's a perfectly obvious and logical reason to choose which subjects you take...
17:45:46 <sinelaw> yeah the lecturer makes you hate or like the subjects....big problem.
17:45:50 <SamB_XP_> ever since I switched to the Japanese encoding...
17:46:37 <sinelaw> for most of my studies any calculator wouldn't help anyway
17:47:05 <sinelaw> unless it had Coq on it and you were really quick :)
17:48:24 <sinelaw> ok, back to haskell. trying to understand how the IO monad actually works.
17:48:52 <Axman6> @src IO
17:48:52 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:49:02 <sinelaw> i understand that the side effects really happen when the expression is evaluated
17:49:03 <SamB_XP_> Axman6: yeah, right, like that will help!
17:49:08 <Cale> sinelaw: Nope
17:49:15 <Axman6> SamB_XP_: well, it helps me :)
17:49:19 <Cale> sinelaw: No side effects happen as a result of evaluation
17:49:29 <sinelaw> that's good...so how does it work?
17:49:32 <SamB_XP_> in GHC's case, the IO Monad works by tricking the compiler ;-P
17:49:45 <Cale> sinelaw: The execution of IO actions is separate from their evaluation.
17:49:49 <SamB_XP_> Cale: I don't think that's actually true if you get down to the Core level ;-)
17:50:05 <Cale> SamB_XP_: Well, I don't care about how GHC implements it here.
17:50:28 <SamB_XP_> that it has nothing to do with evaluation, I mean, not that the evaluation of IO actions does not result in side-effects
17:51:04 <sinelaw> Cale but how can you delay the effects if there are decisions in the evaluation that depend on results?
17:51:07 <Cale> sinelaw: In a compiled program, the IO action called main is executed, which might demand that it be evaluated enough to decide what to do.
17:51:10 <Axman6> sinelaw: that RealWorld thing there, the compiler treats that as having changed every time it's seen, and it sort of represents the world changing every time it's seen
17:51:43 <Cale> sinelaw: In turn, main will be built up from simpler IO actions and various ways of combining simpler IO actions into more complicated ones.
17:51:58 <sinelaw> so execution drives evaluation
17:52:02 <sinelaw> ok
17:52:10 <Cale> (I hate the RealWorld analogy.)
17:52:38 <blackh> sinelaw: When the RTS executes an IO action, it forces evaluation of it just before executing it, so, e.g. trace "one" $ putStrLn "two"   -- it'll output "one" immediately before it outputs "two"
17:52:39 <sinelaw> btw what are those # signs?
17:52:50 <copumpkin> just parts of names
17:52:58 <Axman6> Cale: works for me
17:52:58 <blackh> sinelaw: Sorry, I meant....   trace "one" () `seq` putStrLn "two"
17:53:19 <Cale> sinelaw: One of the ways of combining simpler IO actions into more complicated ones is called (>>). If x and y are two IO actions, then x >> y is the IO action which when executed will execute x first (discarding its result), and then y (producing its result)
17:53:51 <sinelaw> Cale yeah I got monads in general
17:54:00 <sinelaw> but IO seems a special case
17:54:02 <Cale> sinelaw: Oh, good, then you already know what >>= is about.
17:54:35 <sinelaw> yes. IO is the only one that actually has to do unpure stuff, no?
17:54:42 <Cale> The IO action (x >>= f), when executed, will execute x, capture its result v and then execute f v
17:54:56 <Cale> sinelaw: Well, the execution of IO actions is impure.
17:55:11 <Cale> sinelaw: But >>= and >> and return could theoretically have pure implementations
17:55:13 <sinelaw> what i'm asking is (and i think you already answered) is how the IO actions are modelled in the semantics of haskell
17:55:26 <Cale> Since they only have to combine descriptions of things to be done, not actually do those things.
17:55:37 <sinelaw> sure
17:56:01 <blackh> sinelaw: The "IO x" is a Haskell value that has to be fully evaluated at the point when the RTS wants to execute it.
17:56:05 <sinelaw> you seem to say that it's left to the compiler to actually do something with the structure that an IO x value describes
17:56:26 <SamB_XP_> sinelaw: if only it were a structure that it described!
17:56:43 <SamB_XP_> but sadly, that's practically impossible to do for FFI :-(
17:56:43 <Cale> SamB_XP_: Well, it is...
17:56:47 <sinelaw> SamB_XP_ but isn't it?
17:56:58 <Cale> We could even do FFI like that.
17:57:20 <SamB_XP_> on the bare metal, even ?
17:57:21 <Cale> It might have to be an open datatype, or you might have to represent FFI calls a bit more elaborately.
17:57:48 <Cale> But basically, anything which gets enough information to the executor that it can successfully make the call will work :)
17:58:11 <sinelaw> why is FFI a problem here? i'm missing something
17:58:36 <Cale> sinelaw: Well, there's a bit of a concern in that FFI means that the number of primitive IO actions is unbounded in a sense.
17:59:00 <sinelaw> well we could have the "aribtrary" action :)
17:59:05 <sinelaw> *arbitrary
17:59:16 <SamB_XP_> also, we don't exactly have a formal denotational semantics for C ;-P
17:59:17 <Cale> sinelaw: But you could just add a constructor to the IO datatype for describing how the FFI call was to be made explicitly.
17:59:25 <Cale> Don't need one ;)
17:59:57 <sinelaw> SamB_XP_ nor for haskell, if i understand correctly
18:00:10 <Cale> We used to have one for Haskell.
18:00:16 <sinelaw> (but for haskell it's at least possible ? )
18:00:17 <Cale> It wasn't kept up to date.
18:00:49 <Cale> It's possible, yeah.
18:00:54 <sinelaw> i didn't know there's "open data types"
18:01:09 <SamB_XP_> sinelaw: haskell is a heck of a lot easier than C, I think
18:01:11 <Cale> Haskell doesn't have them
18:01:25 <SamB_XP_> at least, in theory
18:01:32 <sinelaw> so how do you add constructors?
18:01:38 <Cale> But a core language into which Haskell is being compiled might.
18:01:44 <SamB_XP_> in practice it's probably quite painful ...
18:02:08 <Cale> You could also have a closed datatype which is just sufficiently descriptive.
18:02:44 <sinelaw> that's why i suggested the "arbitrary action" primitive - is that how it works?
18:03:48 <ivanm> Cale: the different compilers have different core langs, don't they?
18:03:50 <sinelaw> doesn't seem to make sense - the action must be of the appropriate type depending on its result, no
18:04:01 <Peaker> sinelaw, the way IO works in ghc could be described as "magic". it doesn't really use a "description of side effect" thre
18:04:09 <Cale> sinelaw: How it works in GHC is that GHC cheats and puts effects into the evaluator at a lower level. But it's conceivably possible to separate the IO monad implementation so that it has a completely pure implementation apart from the thing which actually interprets and executes the values of type IO t
18:04:38 <Peaker> IO could probably not be an ADT, but only a GADT.. because of the association of its various constructors with types, I'd suppose
18:04:45 <sinelaw> Cale so why does GHC do that? performance?
18:04:45 <Cale> Peaker: yeah
18:04:54 <sinelaw> ease of implementation?
18:04:59 <Peaker> sinelaw, probably the latter
18:05:03 <Cale> sinelaw: Possibly, though I don't think they've tried the alternative.
18:05:04 <Peaker> sinelaw, and the former :)
18:05:14 <Cale> sinelaw: The features which make this approach sane are also newish.
18:05:32 <Cale> As Peaker mentions, you do sort of need GADTs.
18:05:33 <SamB_XP_> Cale: I think they wished to preserve their sanity
18:05:38 <SamB_XP_> they aren't all oleg ...
18:05:55 <Cale> (and GADTs are pretty new)
18:05:58 <Philippa> Cale: that, and what they do now is just what you get when you fuse the intermediate away
18:06:45 <sinelaw> i'd expect haskell to have some definition of how this works, i suspect that different methods lead to different results (in terms of evaluation order?)
18:07:06 <SamB_XP_> sinelaw: sure ... if you do it wrong!
18:07:35 <sinelaw> SamB_XP_ you mean so long as i only evaluate what the actions need, i'm ok?
18:07:43 <sinelaw> (and in the order they need stuff)
18:07:59 <SamB_XP_> sinelaw: no, I'm not saying that
18:08:35 <SamB_XP_> but if GHC does that, blinded from the truth that RealWorld# values neither exist nor are they used
18:08:47 <Peaker> sinelaw, IO uses a fake arg/result-code passing between its side-effecting functions to force the evaluator to run them in the right order
18:08:49 <SamB_XP_> ... then it oes ;-)
18:09:02 <Cale> sinelaw: If you're talking only about evaluation, any order of evaluation which terminates will produce the same result, and if there's an order which terminates, then lazy evaluation does.
18:09:51 <Cale> sinelaw: The execution of IO actions is different, of course, but what they do in GHC is put in artificial data dependencies to ensure that the evaluator will hit things in the right order5.
18:09:54 <Cale> -5
18:10:17 <Cale> It's kind of hacky, but it works.
18:10:52 <sinelaw> ok....do you think that haskell (haskell prime maybe) should somehow fomalize / organize this issue?
18:11:03 <SamB_XP_> sinelaw: not yet
18:11:21 <Cale> Nah, way too much work, and too constraining for implementations.
18:11:21 <SamB_XP_> that is, I don't think anyone has time/money for it ;-P
18:11:23 <ddarius> try (loop (throw foo)) where loop x = loop x, terminates under eager evaluation but not lazy evaluation.
18:11:50 <Cale> All that really matters is that the mental model of IO actions as values works.
18:12:20 <Cale> (as pure values)
18:12:38 <sinelaw> so again, as an implementor all i have to make sure is that actions are executed in the correct order, forcing evaluation of only what they consume - and then i'm safe?
18:12:46 <Cale> yeah
18:12:51 <sinelaw> ok great
18:13:07 <Cale> The monad operations that the IO actions are built up from specify the *execution* order
18:13:12 <Peaker> ddarius, s/terminates/evaluates-to-non-bottom?
18:13:25 <Cale> You're free to evaluate things in any order you like as long as the effects happen in the order which is described.
18:14:23 <sinelaw> yes i remember there's that church-someone theorem about that
18:14:40 <SamB_XP_> church-rossen?
18:14:41 <Axman6> turing?
18:14:48 <Axman6> maybe not turing
18:14:48 * SamB_XP_ kids
18:14:52 <Cale> Church Rosser
18:15:05 * SamB_XP_ was making a violince-related joke
18:17:48 <inforichland> dons: hey dons, I had a phone interview w/ Galois today; put in a good word for me ;)
18:18:09 <copumpkin> :O
18:18:18 <SamB_XP_> you interviewed to be one of their phones ?
18:18:26 <inforichland> why, yes
18:18:30 <inforichland> I'm quite skilled at that
18:18:30 <SamB_XP_> job market must be awfully deserate!~
18:18:32 <heatsink> No, I think he interviewed one of their phones
18:18:54 <inforichland> yeah the job market sucks for software engineers
18:19:23 <sproingie> i bet the phones at galois pass the turing test
18:19:32 <sinelaw> galois is still alive?
18:19:46 <sproingie> not the mathematician, no
18:19:49 * sinelaw ducks, then goes to sleep :)
18:19:51 <sproingie> died in a duel
18:19:52 <copumpkin> sinelaw: he died in a duel cause he was dumb
18:19:58 <sinelaw> not so dumb
18:20:12 <sinelaw> only one hemisphere was working, maybe, but it was sure working!
18:20:20 <copumpkin> 90% of the things named after him he'd never heard of :P
18:20:22 <SamB_XP_> okay, let's put it own to his having been a fool?
18:20:30 <sproingie> live hard, die young, leave a beautiful proof
18:20:41 <SamB_XP_> copumpkin: maybe he forgot about them!
18:20:42 <sinelaw> copumpkin that's true
18:20:50 <sinelaw> had he lived, though....
18:21:07 <SamB_XP_> sinelaw: he would have ended up as an old phogey!
18:21:24 <sproingie> and he'd still be dead today
18:21:49 <sinelaw> yeah, all the previous people were stupid. proof is that they're all ended up dying, and we didn't (yet)
18:22:22 <sinelaw> ok. that's enough garbage for one day. :)
18:22:58 <heatsink> Parametric types that you can use to build either nonrecursive or recursive data structures are cool.
18:24:56 <Peaker> I really want a C with parameteric-polymorphism and type-classes (and optionally, ADT-like structures rather than enums/unions/structs)
18:25:28 <heatsink> Peaker, have you tried Cyclone?
18:25:51 <Peaker> no, its like the opposite of what I want :)
18:25:59 <heatsink> ...huh?
18:26:26 <heatsink> It's C... with parametric polymorphism... and ADT-like structures...
18:26:35 <Peaker> heatsink, I want a language with the operational semantics of C, but some features from Haskell.. cyclone loses the operational semantics of C (like no arrays bound checking, etc) for more safety
18:26:50 <heatsink> oh, ok
18:27:18 <heatsink> Yeah, it would be nice to have one of those.
18:28:33 <SamB_XP_> C has operational semantics ?
18:28:40 <SamB_XP_> I thought it had this thing ...
18:28:47 <SamB_XP_> ... called "undefined behaviour"
18:30:36 <Peaker> SamB_XP_, that means not all programs have operational semantics, but some can
18:31:53 <sproingie> can someone explain the record syntax for newtype?  e.g. newtype Foo a = Foo { foo :: Maybe a }
18:32:05 <sproingie> is foo basically the reverse of Foo?
18:32:26 <heatsink> sproingie, Foo is a piece of data with one field, called 'foo'
18:32:37 <heatsink> It's the same as 'data'
18:33:30 <Peaker> sproingie, its basically the extractor from the data constructor
18:33:48 <Peaker> sproingie, its customary to define:  inFoo f = Foo . f . unFoo   (where your foo is called unFoo)
18:33:59 <heatsink> It's just that because field access looks like a function call, we'll often give the field a name that looks right fora function call.
18:34:06 <heatsink> @source State
18:34:07 <lambdabot> State not available
18:34:39 <sproingie> oh huh it is the same as data.  i got hung up on the newtype
18:34:45 <heatsink> newtype State s a = State {runState :: s -> (a, s)}
18:39:41 <mmorrow> Peaker: (looking at the logs), yeah, array bounds checking in my opinion defeats the whole reason of using arrays in the first place
18:40:16 <mmorrow> unless the compiler can eliminate them all, which is more than highly doubtful
18:41:00 <Peaker> mmorrow, There's a low hanging fruit here because C++ and D really suck
18:41:12 <Peaker> someone who has some time really could make a C-like language to fill the niche of C
18:41:17 <mmorrow> SamB_XP_: undefined behavior is defined when you know what's going to happen ;)
18:41:54 <SamB_XP_> mmorrow: ... right!
18:42:44 <SamB_XP_> Peaker: except that they wouln't have the same compilershare :-(
18:44:21 <puddingpimp> Peaker, it's called Ada...
18:44:43 * mmorrow has never even seen a line of Ada code in his life
18:45:24 <puddingpimp> hmm, I find programming in Ada at least as easy as C almost always
18:45:41 <Peaker> puddingpimp, Does Ada have parametric polymorphism like Haskell's (or templates)?  Surely it doesn't have type-classes for it even if it did
18:45:59 <Peaker> puddingpimp, I read some Ada tutorial way back then and I hated how it had so many syntactic primitives
18:45:59 <puddingpimp> Peaker, not that I'm aware of
18:46:03 <Peaker> puddingpimp, to do things like synchronization
18:46:25 <allbery_b> I thought Ada had built-in generics functionality that could be used like templates
18:46:32 <Peaker> I don't see why Ada is supposed to be safer when it has Pointers with pretty much the semantics of C pointers
18:46:48 <puddingpimp> well it is about as complex as C++ if you look at Ada '05
18:46:57 <Peaker> Maybe when you're forced to use so much syntactic boilerplate to do anything, you think harder about what you're going to do :-)
18:47:45 <allbery_b> remember, ada targeted cobol programmers. boilerplate is relative :)
18:48:08 <puddingpimp> at any rate it's not meant to be Haskell, it's meant for high reliability programming where cobol or fortran would of been used
18:48:18 <Peaker> puddingpimp, Why is it more reliable?
18:48:39 <copumpkin> puddingpimp: hey man, you got some pudding for cheap? I'm really in the mood
18:48:45 <puddingpimp> Peaker, well for starters, it has bounded data type
18:48:52 <puddingpimp> *types
18:48:58 <Peaker> puddingpimp, You mean it has support for int subtypes, specifically?
18:49:20 <puddingpimp> Peaker, and bounded arrays and strings, all of which C lacks
18:49:24 <Peaker> puddingpimp, how is the bound enforced? What happens when you add these bounded ints?
18:49:48 <tomoj> does taking the length of a filtered lazy list hold the head?
18:50:06 <tomoj> (does "hold the head" make sense in #haskell?)
18:50:08 <puddingpimp> Peaker, worst case it raises an exception which if not handled faults the program
18:50:09 <mmorrow> tomoj: only if you have a reference to the head elsewhere
18:50:11 <jmcarthur> tomoj: what do you mean "hold the head"?
18:50:18 <puddingpimp> that is definitely better than silent data corruption
18:50:34 <jmcarthur> tomoj: you mean will the garbage collector follow behind you?
18:50:36 <Peaker> puddingpimp, ah, runtime-bound ints, boring :)
18:50:39 <tomoj> jmcarthur: right
18:50:48 <mmorrow> , let xs = [0..] if length xs < 0 then sum xs else 4 {- unbounded memory -}
18:50:49 <lunabot>  luna: parse error on input `if'
18:50:55 <mmorrow> , let xs = [0..] in if length xs < 0 then sum xs else 4 {- unbounded memory -}
18:50:59 <lunabot>  Killed.
18:51:01 <jmcarthur> tomoj: if nothing else references it, it is a candidate for garbage collection
18:51:03 <Peaker> puddingpimp, struct bounded_int { int x; int bound; }; /* expose bounded_int operations here */
18:51:08 <mmorrow> , let xs = [0..] in if length xs < 0 then 5 else 4 {- constant memory -}
18:51:15 <lunabot>  Killed.
18:51:41 <Peaker> puddingpimp, or with parameteric polymorphism, for example using templates:  template <int bound> class bounded_int { /* expose operations here */ }
18:51:42 <tomoj> ok. I was thinking maybe length needed to have the entire list in memory to work
18:51:43 <tomoj> thanks
18:52:05 <puddingpimp> Peaker, the ability to write something in C doesn't imply that it will be written, the fact that Ada provides safe behaviour as the easy way is what makes it better than C
18:52:50 <mmorrow> tomoj: it's essentially while(xs){n+=1; xs=xs->tail;}
18:52:57 <Peaker> puddingpimp, I agree C sucks in this regard.  It takes a lot of knowledge/skill to know how to use C in good ways.  However, I do think that if you know these good ways, Ada/C++/etc don't offer much improvement (though I do repeat I'd love the features I mentioned above)
18:53:22 <tomoj> mmorrow: great, that's essentially what I was writing on my own
18:53:30 <Peaker> puddingpimp, I think I'd rather educate my co-workers about the right ways to use C than to switch to a language like Ada :)
18:53:34 <puddingpimp> Peaker, another good feature is that untyped pointers aren't the default in Ada
18:53:59 <Peaker> puddingpimp, in what way are C pointers untyped by default?
18:54:04 <Axman6> puddingpimp: bah, Ada is lovely
18:54:41 <puddingpimp> and the feature I like most, named parameters
18:55:05 <Peaker> puddingpimp, What did you mean by "untyped pointers"?  In C pointers are typed
18:55:31 * Axman6 greatly dislikes casting pointers in C. feels so damn hacky
18:55:45 <Peaker> Axman6, You shouldn't be doing that very often..
18:55:55 <Axman6> indeed
18:56:11 <Axman6> i have an assignment in C at the moment, involving a lot of sockets. it's quite painful
18:56:13 <puddingpimp> Peaker, well in C you can go p++, and p=i (the latter of which is a warning which should be treated as an error)
18:56:51 <Peaker> puddingpimp, if p is a char*, for example, and i is a char*, what's the problem with that?
18:57:13 <Peaker> puddingpimp, Also, always use -Werror :)
18:57:33 <puddingpimp> Peaker, that it doesn't require you to check if p++ doesn't excede the bounds of char *p
18:57:37 <Peaker> "Named parameters" are nice (called keyword args elsewhere) and C could use them, but not a big deal, imo
18:57:56 <Peaker> puddingpimp, Oh, that's more about lack of builtin bounded arrays than about "untyped pointers"
18:58:48 <Peaker> puddingpimp, C++ essentially has all these pretty easily. In C it takes a bit more syntax..  The truth is, in our pretty-huge C product, we have lots of C-related problems, very few of which are bad array accesses or such
18:59:51 <puddingpimp> Peaker, yes I agree C++ is less suck than C, but it still has certain proofreading problems (= and == being the immediate lowhanger)
18:59:52 <vininim> -Werror -ansi -pedantic
18:59:56 <mmorrow> i'd love a portable way to have an arbitrary number of stacks, the ability to use the language's function call mechanism for loops, and (3) a way to associate data with a code ptr, so you can free_tree(\p->map(\x->printf("%p\n",x),p); free(p)); (which would mean something along the lines of sticking  "dataptr; codeptr; closure_entry: load dataptr; jmp to code-ptr" on the stack and handing the address to `closure_entry' out (which is no i
18:59:56 <mmorrow> ndistinguishable from a function ptr
19:00:23 <stoop> Ginger salad, chicken teriyaki, banana leaves rice, yaya crepes
19:00:26 <mmorrow> those 3 changes to s/C/not C/ would be so great
19:01:11 <Peaker> puddingpimp, I hate C++, its pretty terrible, but the Ada abstractions are easily implementable in either C or C++, but indeed you are not nudged in their direciton
19:01:11 <mmorrow> gcc has (2) and (3) kind of
19:01:27 <mmorrow> (also i'd ditch C syntax...)
19:01:40 <sproingie> getcontext/setcontext for (3), no?
19:01:43 <stoop> If C had a better preprocessor, life would be great as well.
19:02:08 <Peaker> If someone wrote a better C as a Haskell DSL that compiled to C you'd get a Haskell preprocessor for free :)
19:02:12 <mmorrow> sproingie: kind of, but there you have to overhead of saving the signal context and a crapload of regs
19:02:30 <sproingie> true, and it's a syscall on top of all of it
19:02:36 <stoop> mmorrow, GCC has support for nested functions.
19:02:44 <stoop> mmorrow, I have not tried them in loop context though.
19:03:04 <mmorrow> stoop: right, yeah i've been meaning to experiment with them with that
19:03:42 <stoop> mmorrow, doesn't really help at all.
19:03:44 <Peaker> mmorrow, just 3-4 regs on x86/64
19:03:56 <stoop> Peaker, on x86, not x86-64.
19:03:56 <Peaker> mmorrow, if you want to write your own switcher, at least
19:04:02 <mmorrow> Peaker: right
19:04:04 <stoop> Peaker, x86-64 has many more registers.
19:04:08 <puddingpimp> sometimes I wonder if the right tradeoff is being made with so much written in systems languages (and I mean Linux, libraries and C) that people are optimising the wrong problems and are missing the big picture
19:04:24 <mmorrow> it's more a "well, technically if you .... don't sneeze!! ... then ..." it'd work
19:04:26 <Peaker> stoop, Yeah, but only 3-4 of them are required to be saved by gcc x86/64's ABI, when calling a function
19:04:32 <stoop> Peaker, and this is if you are ignoring SSE/MMX registers.
19:04:49 <Peaker> stoop, I think its OK for SSE/MMX code to use a more expensive switcher
19:04:54 <stoop> Peaker, each of which is 64-bit and 128-bit, and this is assuming same space is used for FP.
19:05:26 <Peaker> stoop, usually when I want coroutines in C I don't care about SSE/MMX
19:05:37 <stoop> Peaker, eax, ebx, ecx, edx, esi, ebi.
19:05:41 <stoop> Peaker, edi, that is.
19:05:42 <puddingpimp> the thing that springs to mind is GTK and X11, if it was at a higher level of abstraction, it'd be trivial to move the network demarcation upwards to the widget level, which would greatly improve the usability of remote GTK applications
19:05:46 <stoop> Peaker, these woul be required.
19:05:55 <stoop> Peaker, yes, you're right there.
19:06:03 <stoop> Peaker, and I agree, it is still pretty cheap on x86.
19:06:27 <Peaker> stoop, you don't have to preserve eax, for example
19:06:42 <stoop> You do.
19:06:54 <Peaker> stoop, Why? the coroutine_switch is a function call, its allowed to modify eax
19:07:04 <ricree> how do people usually go about debugging in haskell?  I'm used to relying a lot on print statements, but that looks like it would be awkward in haskell
19:07:23 <Peaker> ricree, There's Debug.Trace, and the ghci debugger. The ghci debugger is barely usable
19:07:31 <SamB_XP_> ricree: a bit -- but there is Debug.Trace, as Peaker says
19:07:34 <Peaker> ricree, Fortunately, debugging is rarely necessary
19:07:52 <SamB_XP_> the main thing we use for debugging is plain-old ghci
19:08:06 <SamB_XP_> just evaluating expressions and seeing if we get the expected results
19:08:15 <blackh> ricree: trace works nicely in pure code, once you get the hang of it
19:10:01 <ivanm> SamB_XP_: we need some un-plain ghci! :p
19:10:25 <stoop> Peaker, back.
19:10:34 <stoop> Peaker, because eax is a general purpose register.
19:10:40 <SamB_XP_> ivanm: you want color ?
19:10:43 <SamB_XP_> pretty printing ?
19:10:47 <stoop> Peaker, these need to be pushed on stack.
19:10:55 <Peaker> stoop, when you call f() the ABI allows f to set EAX to something else. In fact, EAX is used for the return value
19:10:56 <ivanm> to quote copumpkin, it needs MOAR AWESOME! :p
19:11:02 <stoop> Peaker, all general purpose registers as well as esp and ebp need to be saved.
19:11:04 <copumpkin> :)
19:11:08 <ivanm> SamB_XP_: nah, I'd be happy with better integration in emacs
19:11:13 <Peaker> stoop, not by the gcc x86 and x86/64 ABI's
19:11:26 <Peaker> stoop, The ABI allows functions to trash some of the registers
19:11:32 <SamB_XP_> ivanm: NEEDZ MOAR AWSUM
19:11:54 <SamB_XP_> i fixed ur speling!
19:11:54 <allbery_b> eax is generally a scratch register (and, as noted, return values) so needs to eb saved by interrupt code but not general code
19:12:04 <stoop> Peaker, so? If a value is in eax, it still needs to be saved. For example, it might be used for some computation before the coroutine switch.
19:12:08 <allbery_b> saving esp is kinda pointless if you think about it
19:12:23 <allbery_b> oh, coroutine switch.  yes
19:12:26 <Peaker> stoop, but the coroutine switch is a function call.  It has a return value, inside EAX
19:12:26 <stoop> Yes.
19:12:26 <ivanm> we're saving Extra Sensory Perception now? :o
19:12:27 <ivanm> ;-)
19:12:28 <sohum> @pl \f -> f x
19:12:29 <lambdabot> ($ x)
19:12:36 <stoop> Peaker, sure.
19:12:42 <Peaker> stoop, so its allowed to trash EAX. so it doesn't need to save it
19:12:54 <stoop> Peaker, these ABI semantics are enforced by the compiler but the compiler might not exactly know how the coroutine switch is implemented and that eax is clobbered.
19:13:07 <Peaker> stoop, http://en.wikipedia.org/wiki/X86_calling_conventions#cdecl <-- same for ECX,EDX
19:13:09 <stoop> Peaker, you still need to at least make it clear eax is being clobbered.
19:13:23 <sohum> @pl \x -> f (map ($ x) c)
19:13:23 <lambdabot> f . flip map c . flip id
19:13:24 <stoop> Peaker, I am very familiar with the IA32 calling conventions.
19:13:24 <Peaker> stoop, You're assuming the coroutine switch is some inline assembly macro?  Think a normal C function
19:13:34 <stoop> Peaker, yes, then things are different.
19:13:42 <Peaker> stoop, yeah, and you need to save less registers
19:13:52 <SamB_XP_> remember, C functions return in EAX ;-)
19:14:09 <stoop> Not necessarily.
19:14:09 <stoop> But generally, yes.
19:14:42 <Peaker> stoop, anyway, a friend of mine implemented coroutine support for x86/64 in a pageful. his asm only saved a few registers, I don't remember how many
19:15:13 <stoop> Peaker, sure.
19:15:27 <stoop> Peaker, again, if you can relay these constraints to the compiler, you can save less registers.
19:15:51 <Peaker> stoop, btw: Implementing it as an ASM macro rather than a function, and simply mentioning all registers as clobbered, can allow the compiler to decide what actually needs to be saved, which could be nice
19:15:55 <stoop> Peaker, regardless, we are in agreement that it is cheap on x86.
19:15:56 <Peaker> stoop, exactly what you said :)
19:16:26 <BMeph> :t return ($ 4)
19:16:29 <lambdabot> forall a b (m :: * -> *). (Num a, Monad m) => m ((a -> b) -> b)
19:16:56 <BMeph> :t liftM ($ 4)
19:16:58 <lambdabot> forall a b (m :: * -> *). (Num a, Monad m) => m (a -> b) -> m b
19:18:10 <Peaker> :t liftM2 ($ 4)
19:18:11 <lambdabot> forall a a2 r (m :: * -> *). (Num a, Monad m) => m (a -> a2 -> r) -> m a2 -> m r
19:19:04 <sohum> @pl \(x,y) -> f x ++ g y
19:19:04 <lambdabot> uncurry ((. g) . (++) . f)
19:19:27 <sohum> :t uncurry (++)
19:19:28 <lambdabot> forall a. (Monoid a) => (a, a) -> a
19:19:47 <sohum> :t curry (++)
19:19:48 <lambdabot> forall a b. (Monoid a, Monoid b) => a -> b -> (a, b) -> (a, b)
19:21:51 <sohum> @pl \(x,y) -> x ++ y
19:21:51 <lambdabot> uncurry (++)
19:21:54 <sohum> right
19:21:55 <Axman6> sohum: uncurry (++) .. (f *** g)
19:21:57 <sohum> that's what I thought
19:22:00 <sohum> ..?
19:22:04 <Axman6> :t uncurry (++) . (f *** g)
19:22:06 <lambdabot> forall a (a1 :: * -> * -> *) b b'. (Monoid a, SimpleReflect.FromExpr (a1 b a), SimpleReflect.FromExpr (a1 b' a), Arrow a1, Functor (a1 (b, b'))) => a1 (b, b') a
19:22:27 <Axman6> :t uncurry (++) . ((f :: a -> b)  *** (g :: c -> d))
19:22:28 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
19:22:29 <lambdabot>       from the context ()
19:22:29 <lambdabot>       arising from a use of `f' at <interactive>:1:17
19:22:37 <sohum> that's it
19:22:37 <Axman6> :t uncurry (++) . ((f :: a -> b)  &&& (g :: c -> d))
19:22:38 <sohum> thanks
19:22:38 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
19:22:38 <lambdabot>       from the context ()
19:22:38 <lambdabot>       arising from a use of `f' at <interactive>:1:17
19:22:41 <Axman6> bah
19:22:45 <Axman6> one of them works
19:22:50 <Axman6> :t (&&&)
19:22:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:23:16 <Axman6> :t uncurry (++) . ((f :: a -> b) . fst  &&& (g :: c -> d) . snd)
19:23:17 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
19:23:17 <lambdabot>       from the context ()
19:23:17 <lambdabot>       arising from a use of `f' at <interactive>:1:17
19:23:23 <Axman6> god damn it lambdabot
19:23:44 <Axman6> :t uncurry (++) . ((f :: a -> [b]) . fst  &&& (g :: c -> [b]) . snd)
19:23:45 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr [b])
19:23:45 <lambdabot>       from the context ()
19:23:45 <lambdabot>       arising from a use of `f' at <interactive>:1:17
19:24:35 <Axman6> :t (?f *** ?g)
19:24:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (?f::a b c, ?g::a b' c', Arrow a) => a (b, b') (c, c')
19:24:41 <ivanm> anyone here familiar with the Glob library on hackage?
19:25:26 <sohum> nah, it's (***)
19:25:38 <sohum> the simplereflect stuff is messing it up
19:26:41 <ivanm> maybe I don't understand globbing properly, but I'm trying to filter out some matches and can't see anything in there that'll do it...
19:26:49 <maurer_> Does anyone know if most of the various utility libraries (network, cabal-install, etc.) build vs 6.12?
19:27:08 <ivanm> maurer_: dcoutts_ has told me that all but about 8 packages build
19:27:15 <ivanm> that's excluding those that rely on gtk2hs and the like
19:27:28 <ivanm> and he's considering changing cabal to make those 8 work
19:27:43 <maurer_> Out of curiosity, if most of them work, what's breaking gtk2hs?
19:27:47 <Axman6> :t uncurry (++) . (?f . fst  *** ?g . snd)
19:27:48 <lambdabot> forall a a1 b a2 b1. (Monoid a, ?f::a1 -> a, ?g::b1 -> a) => ((a1, b), (a2, b1)) -> a
19:27:52 <ivanm> maurer_: basically, if it builds with 6.10 and uses only cabalised non-ghc deps with no custom Setup.hs, it'll work
19:28:04 <Axman6> :t uncurry (++) . (?f *** ?g)
19:28:04 <maurer_> OK
19:28:05 <lambdabot> forall a (a1 :: * -> * -> *) b b'. (Monoid a, ?f::a1 b a, ?g::a1 b' a, Arrow a1, Functor (a1 (b, b'))) => a1 (b, b') a
19:28:09 <ivanm> maurer_: ghc-pkg format has changed; cabal 1.8 takes it into account, gtk2hs' manual build system doesn't
19:28:15 <Axman6> :t (++)
19:28:16 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:28:20 <Axman6> urgh
19:28:37 <Axman6> i do wish Cale or whoever it is would stop messing with that
19:28:54 <ivanm> Axman6: genericalising the @src, etc. in lambdabot?
19:29:12 <Axman6> redefining things like (++)
19:29:26 <ivanm> yeah
19:31:58 <stoop> (Just 4) ++ (Just 3)
19:32:01 <stoop> > (Just 4) ++ (Just 3)
19:32:02 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:32:03 <lambdabot>    `GHC.Num.Num t' arising ...
19:32:11 <stoop> > [1] ++ [2]
19:32:12 <lambdabot>   [1,2]
19:32:34 <ivanm> @seen Deewiant
19:32:34 <lambdabot> Unknown command, try @list
19:32:39 <ivanm> preflex: seen Deewiant
19:32:39 <preflex>  Deewiant was last seen on #haskell 5 days, 5 hours, 8 minutes and 23 seconds ago, saying: > mfix error :: [String]
19:33:46 <ivanm> @ask Deewiant is there any way when using your globbing library to avoid searching certain directories, etc.? e.g. I want to search for all haskell files in a given project, but avoid looking in _darcs/ as well as excluding "boring" files such as Setup.hs
19:33:46 <lambdabot> Consider it noted.
19:37:08 <Axman6> > mfix error :: [String]
19:37:09 <lambdabot>   * Exception: * Exception: * Exception: * Exception: * Exception: * Exceptio...
19:37:38 <c_wraith> @hoogle mfix
19:37:39 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
19:38:29 <c_wraith> well, huh.
19:38:32 <c_wraith> I could use that.
19:44:59 <hackagebot> mecha 0.0.0 - A constructive solid modeling language. (TomHawkins)
19:45:45 <copumpkin> :o
19:46:10 <SamB_XP> for building giant warrior robots, it seems ?
19:47:18 <Axman6> @hackage mecha
19:47:18 <lambdabot> http://hackage.haskell.org/package/mecha
19:48:09 <sproingie> rather an unambitious version number
19:49:05 * ddarius releases network version 127.0.0.1
19:49:19 <sproingie> hey that's just like my version
19:49:54 <copumpkin> lol
19:50:27 <sproingie> time to hack inf-haskell.el to make load-file do a :cd to the damn directory the .hs is in
19:50:40 <sproingie> one would think that would be the sensible default
19:54:16 <ivanm> ddarius: heh
19:54:56 <ivanm> @remember ddarius releases network version 127.0.0.1
19:54:56 <lambdabot> I will remember.
19:54:56 <ivanm> sproingie: nope
19:54:56 <ivanm> it isn't
19:54:58 <ivanm> sproingie: you want it to :cd to the root directory of the project
19:59:15 <hetman__> hi guys, I have a n00b question about exceptions if anyone can offer some help
19:59:44 <Axman6> not if you don't ask your question ;)
19:59:56 <hetman__> lol, sorry first time in the channel
20:00:11 * Axman6 reminds hetman__ of the first rule of IRC: "Don't ask to ask, just ask"
20:00:11 <monochrom> exception is hard. there are exceptions.
20:00:21 <hetman__> is there a general way exceptions are documented in various libraries
20:00:39 <monochrom> probably not.
20:00:44 <hetman__> for example, when connexions made using the Network library fail, how do I know what kind of exceptions to expect
20:00:49 <hetman__> without reading the source code
20:00:50 <sproingie> ivanm: it does try to detect a project, but when there isn't one, it seems to default to nothing at all
20:01:05 <Axman6> hetman__: it seems to me like something that should be documented though
20:01:49 <ivanm> hetman__: so, which group of kozaks are you hetman of? :p
20:01:50 <monochrom> There is no syntax to say "I throw these exceptions but none else". You have to rely on doc author's benevolence to say in prose.
20:03:18 <hetman__> ugh, I can't find the command to point my response at individual users
20:03:58 <hetman__> yes, I would expect the library to document this somehow... but fairly core libraries don't seem to do so
20:04:04 <hetman__> so I assumed maybe I wasn't looking in the right place
20:05:06 <Saizan> sproingie: imo, the best route is to read the module header and :cd accordingly, i.e. if you're loading "module Foo.Bar where .." you should :cd to a directory such that "Foo/Bar.hs" is the relative path of the file
20:05:12 <hetman__> or that there was some kind of assumed standard for what kind of exceptions to expect in given situations, I don't know
20:06:09 <sohum> is there a fn = \x y = intercalate x y ++ x
20:06:20 <sohum> ?
20:06:39 <sohum> @pl \x y -> intercalate x y ++ x
20:06:39 <lambdabot> flip =<< ((++) .) . intercalate
20:06:43 <sohum> ...whoa
20:06:53 <copumpkin> sohum: that seems like an odd thing to do in general
20:06:59 <sohum> @pl \x y -> (intercalate x y) ++ x
20:07:00 <lambdabot> flip =<< ((++) .) . intercalate
20:07:04 <Saizan> hetman__: all the exception affair is starting to get better only recently, imo, with extensible exceptions in base and packages like control-monad-exceptions
20:07:10 <sproingie> it does seem to want to cd to the buffer's directory but only when it does find a project root
20:07:31 <monochrom> hetman__: Network.connectTo is an IO action, so it may throw exceptions listed in System.IO.Error.
20:07:41 <sohum> copumpkin: why? for instance, to add a newline to the end each line of an array of strings...
20:07:42 <sproingie> i'm just going to hack in an unconditional :cd to that dir and then let the project stuff issue another cd
20:07:56 <copumpkin> sohum: I guess
20:08:02 <Saizan> sohum: unlines for that
20:08:07 <ivanm> sohum: *cough* unlines *cough*
20:08:09 <sohum> :t unlines
20:08:10 <lambdabot> [String] -> String
20:08:13 <sohum> sweet
20:08:27 <ivanm> my problem with unlines is that it adds a newline to the end, which I usually don't want
20:08:31 <sohum> > unlines ["a", "foo"]
20:08:32 <lambdabot>   "a\nfoo\n"
20:08:32 <ivanm> so I normally resort to init . unlines
20:08:36 <hetman__> hmmm, ok, thanks for the pointers... I was kind of afraid of that
20:08:42 <hetman__> ivanm: I'm from the Polish hetmans :P
20:08:42 <copumpkin> @src unlines
20:08:43 <lambdabot> unlines = concatMap (++ "\n")
20:08:48 <sohum> ... heh
20:08:50 <ivanm> > text $ unlines ["line 1", "line 2"]
20:08:51 <lambdabot>   line 1
20:08:51 <lambdabot>  line 2
20:08:53 <ivanm> hetman__: bah
20:08:54 <ivanm> ;-)
20:08:59 <Saizan> ivanm: then you could use intercalate "\n"
20:09:04 <ivanm> @slap lambdabot's-failed-pretty-printing
20:09:04 * lambdabot clobbers lambdabot's-failed-pretty-printing with an untyped language
20:09:16 <ivanm> Saizan: isn't the unlines implementation meant to be slightly more efficient?
20:09:19 <ivanm> @src unlines
20:09:19 <lambdabot> unlines = concatMap (++ "\n")
20:09:33 <ivanm> hmmm, maybe not
20:09:39 <ivanm> thought it did '\n' :
20:09:45 <Saizan> ivanm: i doubt init . unlines is more efficient than intercalate "\n"
20:10:10 <copumpkin> or less efficient :)
20:10:53 <Saizan> mh, i got something wrong with the grammar in that sentence..
20:10:55 <ivanm> Saizan: heh, true
20:11:24 <sproingie> oh how ridiculous, it thinks my project dir is ~/.cabal for any random .hs file
20:11:44 <sproingie> the whole of i-h-load-file is just crazy
20:12:03 <sproingie> it sets default-directory as a side effect
20:12:30 <ivanm> sproingie: yeah, it's a bug
20:12:41 <ivanm> there's been a fix for it in cvs for ages
20:12:54 <ivanm> sproingie: easy fix: make an empty foo.cabal file in your root project
20:13:02 * ivanm forgets how to fix haskell-mode itself
20:13:09 <sproingie> sure, but i want it to just work for ad-hoc .hs files
20:13:38 <sproingie> my emacs-fu is pretty strong, i can whip up a fix, but if it's already fixed in cvs, i may as well use that
20:13:46 <sproingie> where is the cvs for haskell mode anyway?
20:14:06 <ivanm> cvs.haskell.org/haskell-mode or something like that
20:14:26 <ivanm> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
20:14:51 <ivanm> sproingie: of course, ideally it would parse the module definition and use that to work out where the project root should be...
20:16:17 <sproingie> cvs login doesn't work, with either 'cvs' for passwd or blank passwd
20:17:28 <ivanm> sproingie: oh, right, cvs is still down
20:17:39 <ivanm> I think Baughn was taking over haskell-mode ...
20:17:44 <sproingie> i'm able to browse it
20:17:56 <sproingie> guess i can grab it that way
20:22:24 <sohum> there is a function such that f [] = True and f _ = False, right?
20:22:49 <Saizan> null
20:22:50 <RichardO> null
20:22:54 <sohum> aaah, yus
20:22:54 <monochrom> > (null [] , null ['1'])
20:22:55 <sohum> thankee
20:22:55 <lambdabot>   (True,False)
20:23:10 <ivanm> @ask dons is there any API changes in bytestring from 0.9.0.* to 0.9.1.*? kolmodin and I have discussed removing bytestring as a stand-alone package from gentoo for maintainability purposes, but it seems some packages like yi specify that they require 0.9.1.* :s
20:23:10 <lambdabot> Consider it noted.
20:23:25 <ivanm> @hoogle [a] -> Bool
20:23:26 <lambdabot> Prelude null :: [a] -> Bool
20:23:26 <lambdabot> Data.List null :: [a] -> Bool
20:23:26 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
20:23:54 <Jedi_Stannis> can someone recommend how to make this expression more readable?
20:23:54 <Jedi_Stannis> Var <$> ((:) <$> letter <*> (many alphaNum))
20:24:31 <ivanm> Jedi_Stannis: not using <$> and <*> ?
20:24:32 <Saizan> Var . (:) <$> letter <*> many alphaNum
20:24:35 <monochrom> Use cobol, write like english.
20:24:41 <ivanm> monochrom: heh
20:25:00 <Saizan> uhm
20:25:04 <Saizan> maybe mine doesn't work
20:25:23 <monochrom> OK, let f be (:), since we're treating (:) as a function anyway.
20:25:49 <Jedi_Stannis> Saizan: yeah, Var needs to be lifted
20:25:57 <monochrom> Var <$> (f <$> letter <*> (many alphaNum))  is better because it now looks like just an infix expression.
20:26:39 <monochrom> The rest relies on educating on the two infix operators <$> and <*>.
20:27:09 <Saizan> s/(many alphaNum)/many alphaNum/
20:27:25 <sproingie> yay new haskell mode works
20:27:28 <Jedi_Stannis> yeah, those parans aren't needed
20:28:05 <Jedi_Stannis> monochrom: ok thanks, just reading about how applicative style is so great, so was trying to see how far I could take it
20:29:59 <monochrom> I read the idiom "f <$> m0 <*> m1 <*> m2 <*> ..." as 'doing' m0, m1, m2... to get their result values, and the result values are passed to f as parameters, and f is supposed to be a pure function that takes that many parameters.
20:30:47 <monochrom> 'doing' cannot be made more precise because it depends on which monad or which applicative. but if it's Parsec then we know.
20:31:07 <Jedi_Stannis> which is what I have, except my f is an infix constructor (:), so it becomes hard to read
20:31:38 <Jedi_Stannis> and that I have another pure function I apply to the result of that one
20:32:19 <Saizan> (\x xs -> Var (x:xs)) <$> letter <*> many alphaNum -- another option
20:32:30 <monochrom> So if letter gives you 'x' and many alphaNum gives you "hello", f <$> letter <*> alphaNum gives you x:"hello", and then you pack it inside Var.
20:32:48 <monochrom> OK I like (\x xs -> Var (x:xs))
20:33:01 <Axman6> @pl (\x xs -> Var (x:xs))
20:33:01 <lambdabot> (Var .) . (:)
20:33:30 <monochrom> I like (Var .) . (:) less because way too few people are educated to read it.
20:33:51 <Jedi_Stannis> yeah, I like (\x xs -> Var (x:xs))
20:34:16 <monochrom> function composition would be more suitable if cons took a tuple.
20:34:40 <Jedi_Stannis> uncurry?
20:35:02 <Saizan> monochrom: it wouldn't work so well with <*> though
20:36:20 <Saizan> with InfixApplicative from hackage you can write  Var <$> letter <^ (:) ^> many alphaNum
20:36:37 <Saizan> which starts to look like ascii art
20:37:15 <jmillikin> For converting between Data.Text.Text and DT.Lazy.Text, is there a better way than (pack . unpack)?
20:37:54 <Jedi_Stannis> Saizan: yeah, too much punctuation in that, I think ill go with the lambda version
20:37:58 <sohum> @hoogle [Maybe a] -> [a]
20:37:58 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:37:58 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:37:58 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:38:01 <Jedi_Stannis> thanks everyone
20:38:24 <sohum> > catMaybes [Just 3, Nothing, Nothing, Just 4, Just 2]
20:38:25 <lambdabot>   [3,4,2]
20:38:27 <sohum> sweet
20:39:03 <ddarius> > foldr ((++) . maybe [] return) [] [Just 3, Nothing, Nothing, Just 4, Just 2]
20:39:04 <lambdabot>   [3,4,2]
20:39:28 <Saizan> jmillikin: fromChunks . (:[])
20:42:26 <ddarius> > let m = foldr (mplus . maybe mzero return) mzero; e = [Just 3, Nothing, Nothing, Just 4, Just 2] in (m e, m e) :: ([Int], Maybe Int)
20:42:27 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
20:42:27 <lambdabot>         again...
20:45:48 <Saizan> > let m x = foldr (mplus . maybe mzero return) mzero x; e = [Just 3, Nothing, Nothing, Just 4, Just 2] in (m e, m e) :: ([Int], Maybe Int)
20:45:49 <lambdabot>   ([3,4,2],Just 3)
20:46:30 <sohum> @pl \x -> [x]
20:46:30 <lambdabot> return
20:46:34 <sohum> oh duh
20:46:55 <kyagrd> @help pl
20:46:56 <lambdabot> pointless <expr>. Play with pointfree code.
20:48:10 <kyagrd> @pl \xs ts -> map (zip xs) $ foldr (liftM2 mplus) (return mzero) [liftM return ts | _ <- xs]
20:48:29 <lambdabot> (line 1, column 62):
20:48:29 <lambdabot> unexpected "["
20:48:29 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
20:48:30 <kyagrd> lambdabot, plz wake up
20:48:50 <kyagrd> @pl \xs ts -> map (zip xs) ( foldr (liftM2 mplus) (return mzero) [liftM return ts | _ <- xs] )
20:48:51 <lambdabot> (line 1, column 62):
20:48:51 <lambdabot> unexpected "["
20:48:51 <lambdabot> expecting variable, "(", operator or ")"
20:50:21 <kyagrd> @pl \ f x y -> f x . f y
20:50:21 <lambdabot> flip =<< (((.) . (.)) .)
20:51:37 <Saizan> ?type \f -> (.) `on` f
20:51:38 <lambdabot> forall a a1. (a1 -> a -> a) -> a1 -> a1 -> a -> a
20:52:06 <Saizan> ?type \ f x y -> f x . f y
20:52:07 <lambdabot> forall t b. (t -> b -> b) -> t -> t -> b -> b
20:52:26 <Saizan> "on (.)" then :)
20:57:36 <ddarius> preflex: seen newsham
20:58:22 <ddarius> preflex_: : seen newsham
20:59:05 <kyagrd> @type on (.) (+) 2 3
20:59:06 <lambdabot> forall a. (Num a) => a -> a
20:59:15 <kyagrd> > on (.) (+) 2 3 5
20:59:17 <lambdabot>   10
20:59:20 <kyagrd> yeah
21:01:12 <vininim> @type on
21:01:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:39:30 <sohum> @pl \x -> f (g x)
21:39:30 <lambdabot> f . g
21:39:38 <sohum> that's what I thought...
21:45:43 <rsnake> > map (\x -> "a") [1..10]
21:45:44 <lambdabot>   ["a","a","a","a","a","a","a","a","a","a"]
21:45:51 <kyagrd> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11026#a11026 here's the result of yesterday's hacking
21:46:55 <kyagrd> lambdabot tell us the title of the URL page plz ... (didn't lambdabot used to repond for urls before??)
21:47:26 <ivanm> kyagrd: it was disabled for being annoying
21:47:38 <ivanm> well, actually I think it was disabled because it did tinyurl which was annoying
21:48:07 <kyagrd> Anyway the paste is about automating quickcheck for polymorphc/overloaded properties
21:52:23 <rsnake> > fix (*0.5) $ 1
21:52:25 <lambdabot>   No instance for (GHC.Real.Fractional (a -> b))
21:52:25 <lambdabot>    arising from the literal ...
21:53:05 <ivanm> > fix (*0.5)
21:53:09 <lambdabot>   mueval-core: Time limit exceeded
21:53:14 <copumpkin> > iterate (*0.5) 1
21:53:15 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
21:53:40 <sw17ch> the FFI doesn't like static inline functions, does it
21:54:35 <sohum> what does "The last statement in a 'do' construct must be an expression" mean? my last statement in question is an if (..) then k :: IO () else k2 :: IO ()
21:55:31 <Axman6> sohum: paste the code?
21:56:00 <ivanm> probably an alignment problem...
21:56:35 <sohum> Axman6, ivanm: http://haskell.pastebin.com/d334959c3
21:57:02 <ivanm> sohum: check indentation of the _ case
21:57:23 <ivanm> sohum: oh, wait, the type of the else case, etc. is dodgy
21:57:29 <ivanm> sohum: you forgot to $
21:57:59 <ivanm> sohum: you can't say something like " succ . pred 2" or "succ . pred . 2"; you need to have a $
21:58:09 <ivanm> (and in that case, I think y'll need parens for if-then-else)
21:58:53 <Axman6> sohum: each let doesn't need to have its ow 'let' keyword
21:59:58 <sohum> ivanm: are you talking about the writeFile outFile . output (compile prog) bit?
22:00:10 <ivanm> yes
22:00:53 <Saizan> sohum: you've to align lines 23,24 and 25 with prog above
22:01:30 <Axman6> sohum: http://haskell.pastebin.com/m75e56c1a
22:02:04 <ivanm> Saizan: bah, I knew there was something wrong with that do block, but couldn't spot it
22:02:20 <Saizan> http://haskell.pastebin.com/m291c4ef
22:09:55 <largos> does anyone know why issuing a http request via with Network.Browser.browse would print to stdout?
22:10:14 <iaefai> How might you represent a chess board as a data type?
22:10:31 <Saizan> largos: what does it print?
22:10:53 <sohum> http://haskell.pastebin.com/d3ea869b1 is a simpler case that still has the error. as far as I can tell, the alignment is all right
22:10:55 <largos> Saizan: all but the last line of this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11025
22:12:06 <Axman6> iaefai: either [[Piece]] or Array (Int, Int) Piece
22:12:28 <c_wraith> I'd consider Maybe Piece, in those
22:12:41 <c_wraith> Unless you want to have a None pieces
22:12:43 <c_wraith> *piece
22:12:47 <largos> Saizan: the source is here: http://code.google.com/p/pastepipe/source/browse/pastepipe.hs
22:12:59 <Axman6> sohum: you need to indent lines 23-25 by one more space
22:13:31 <largos> the method that causes output seems to be post, on line 48
22:14:06 <Saizan> largos: i think this is related http://hackage.haskell.org/packages/archive/HTTP/4000.0.8/doc/html/Network-Browser.html#v%3AsetOutHandler
22:14:10 <sohum> Axman6: ... that worked. why?
22:14:41 <largos> ah... cool
22:14:46 <Axman6> sohum: the alignment in a do block is that of the first statement in it i believe, which is prog <- withContents (return . parse . scan)
22:15:07 <sohum> aaaah, right
22:16:15 <largos> Saizan: thanks! that did it :)
22:16:32 <iaefai> Axman6: How would one define a function to move a piece from one square to another (without regards for rules) in an elegant way for either one of those data types?
22:16:48 <iaefai> functional programming with arrays is not a strong idea with me
22:17:22 <Saizan> you might also use Map (Int,Int) Piece
22:17:43 <iaefai> What is the essential difference?
22:17:57 <Axman6> well, you'd have a function with a type something like: move :: (Int,Int) -> (Int, Int) -> Board -> Maybe Piece... and the rest is left as an exercise to the reader ;)
22:18:13 <Saizan> that with Map updating a cell is O(log n) instead of O(n) like with pure arrays
22:21:34 <iaefai> Is the Map referring to Data.Map?
22:22:12 <Axman6> yes
22:22:37 <Saizan> Seq (Seq Piece)) could be a nice compromise, it has asymptotically fast lookup and insert and it's also list-like (assuming that's a plus, not quite sure)
22:23:39 <Axman6> hmm, how much memory do you reckon it would take in the worst case to make a chess AI that calculated all possible moves three turns ahead?
22:25:04 <Jafet> About b^6, where b is anywhere between 1 and 60ish
22:25:10 <Jafet> And that's if you're stupid
22:25:22 <Jafet> And that's a small number
22:26:08 <vininim> > 60^6
22:26:10 <lambdabot>   46656000000
22:26:25 <vininim> > 60^6/(1024^2)
22:26:26 <lambdabot>   44494.62890625
22:26:50 <iaefai> Seq index: " If the position is out of range, index fails with an error."  How do you deal with this? I would have expected a Maybe
22:27:11 <Jafet> That's an unrealistically high maximum, and alpha-beta will cut it down drastically
22:27:27 <Axman6> > 60^6
22:27:29 <lambdabot>   46656000000
22:27:37 <Axman6> alpha-beta?
22:27:51 <vininim> if you're bruteforcing, neural network might be smarter-faster =P
22:28:09 <vininim> fsvo smart
22:28:22 <Jafet> Neural networks are useless for actual research, since they are write-only
22:28:40 <Jafet> I've never heard of an engine based on them, either
22:28:59 <vininim> I recall some chessbot using it for paws
22:31:48 <iaefai> If I do something like this: data Board = Seq (Seq Piece Colour)   Is it a valid data constructor, tbh I am not entirely certain how to construct this one.
22:31:51 <Jafet> It would be interesting to see, basically machine learning chess (which oddly is rare in typical engines)
22:32:21 <Jafet> So... can you implement bitboards in the type system?
22:32:37 <iaefai> bitboards?
22:32:46 <Saizan> iaefai: uhm, that's unfortunate, though since length is O(1) you can make a wrapper that checks the bound
22:34:16 <iaefai> Is there any example that shows how to use Seq in a data type?
22:35:25 <Saizan> iaefai: e.g. data Board = Board (Seq (Seq (Piece,Color)))
22:36:42 <iaefai> Saizan: My apologies, it is late and I should have seen that.
22:37:20 <Saizan> heh, np
22:38:21 <iaefai> The one thing that is going to be a challenge for me is defining some of these things in a functional way without resorting to imperative constructs
22:38:53 <Jafet> Most articles about chess engines are C-oriented
22:39:58 <iaefai> I am certainly not making a chess AI :p
22:40:26 <Saizan> the whyfp paper has a small AI example that exploits laziness to split generation of cases from pruning them and so getting clearer code
22:40:34 <sproingie> machine learning chess from the standpoint of individual moves is about as likely to work for a machine as well as it would for a human
22:40:48 <sproingie> i.e. not well.  you have to infer broader strategy
22:41:10 <Saizan> @where whyfp
22:41:10 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
22:41:11 <Jafet> iaefai, oh, you had me fooled for a minute
22:41:46 <Jafet> A Haskell board game engine would be excellent grounds to abuse memoization
22:45:22 <iaefai> I would love a nice Go AI, but I have to learn Go first :p
22:45:39 <Jafet> You can be the first to implement one
22:46:24 <Saizan> Jafet: you really mean memoization or just sharing?
22:46:56 <Jafet> In a sense, memoization is sharing
22:47:09 <sproingie> go is really really easy to learn
22:47:12 <Jafet> But you make them sound like peccably vague terms
22:47:39 <sproingie> but writing a go ai is murderously hard
22:47:59 <Jafet> Playing go is murderously hard too
22:48:24 <sproingie> couldn't ever get good at go for the same reason chess eludes me
22:48:35 <sproingie> too much memorization.  chess has openings, go has joseki
22:48:49 <Jafet> For humans it boils down to pattern matching
22:49:04 <Saizan> what it's normally understood as sharing doesn't apply to multiple applications of the same function to the same arguments, only to explicitly binded values
22:49:07 <al-maisan> Good morning
22:49:23 <Saizan> i.e. the difference between call-by-name and call-by-need
22:49:37 <iaefai> Jafet: This is operator graphics for a robot arm to manipulate a chess board and it delegates with a real AI
22:49:37 <iaefai> :t foldr
22:49:37 <iaefai> Is that bot not with us anymore, or has something changed?
22:49:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:50:06 <maurer_> cabal-install is made very sad by Cabal-1.8
22:50:32 <maurer_> It appears to have been depending on using PackageIndex as a container type for things other than InstalledPackageInfo
22:50:37 <maurer_> :(
22:51:05 <Jafet> Saizan, in that case then I meant memoization (eg. Zobrist tables)
22:51:23 <Saizan> maurer_: yeah, you can't use cabal-install with Cabal-1.8 yet, so you can't use it with ghc-6.12
22:52:07 <hackagebot> PastePipe 1.2 - CLI for pasting to hpaste.org (RoganCreswick)
22:52:24 <Saizan> maurer_: it needs someone with the time to update cabal-install code :)
22:53:53 <iaefai> sproingie: What Jafet said :p
22:53:53 <iaefai> al-maisan: Blessed you are, with Haskell
22:54:08 <al-maisan> iaefai: :)
22:54:45 <iaefai> I assure you it is Halal.
22:55:35 <al-maisan> iaefai: aha :)
23:00:18 <iaefai> If I have something like this: pawnSet colour = fromList $ List.map trans pawns8   (fromList is from Sequence) and I get back fromList [(Pawn,Black),(Pawn,Black),(Pawn,Black),(Pawn,Black),(Pawn,Black),(Pawn,Black),(Pawn,Black),(Pawn,Black)]   does it mean that fromList hasn't been applied to my list? I was expecting a Seq back.
23:01:46 <Axman6> iaefai: that's how it represents Show for Seq
23:02:11 <iaefai> that isn't very easy to get automatically :-(
23:02:44 <Axman6> it's probably: instance Show a => Show (Seq a) where show xs = "fromList " ++ show . fromList xs
23:03:29 <Axman6> with a $
23:03:36 <Axman6> and some brackets
23:03:56 <Axman6> :r showPrec
23:03:59 <Axman6> :t showPrec
23:04:01 <lambdabot> Not in scope: `showPrec'
23:04:07 <Axman6> @hoogle show
23:04:07 <lambdabot> Prelude show :: Show a => a -> String
23:04:07 <lambdabot> Text.Show show :: Show a => a -> String
23:04:07 <lambdabot> module Text.Show
23:04:14 <Axman6> @src Show
23:04:14 <lambdabot> class  Show a  where
23:04:14 <lambdabot>     showsPrec :: Int -> a -> ShowS
23:04:14 <lambdabot>     show      :: a   -> String
23:04:14 <lambdabot>     showList  :: [a] -> ShowS
23:04:31 <Axman6> > showsPrec 10 [1..] :: String
23:04:32 <lambdabot>   Couldn't match expected type `GHC.Base.String'
23:04:32 <lambdabot>         against inferred typ...
23:07:40 <iaefai> It was kind of annoying given that I have that as basically my function call :p
23:07:40 <iaefai> merci
23:07:40 <iaefai> Is the $ the right thing to use to avoid another set of brackets?
23:07:40 <iaefai> Also, is there a way to generate an n element list of type a?
23:08:18 <Axman6> :t ShowS
23:08:19 <lambdabot> Not in scope: data constructor `ShowS'
23:11:56 <iaefai> @src showsPrec
23:11:56 <iaefai> > showsPrec "a" [1..10] :: String
23:11:56 <iaefai> Why is this stuff not working for me?
23:11:56 <lambdabot> showsPrec _ x s = show x ++ s
23:11:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:11:57 <lambdabot>         against inferred type ...
23:13:07 <ivanm> @type showsPrec
23:13:07 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
23:13:29 <ivanm> > showsPrec 2 [1,2,3,4,5] "34"
23:13:30 <lambdabot>   "[1,2,3,4,5]34"
23:13:48 <Axman6> wtf's the int supposed to be for?
23:13:59 <ivanm> Axman6: precedence AFAIK
23:14:05 <Axman6> i never got the Show functions, apart from show
23:18:28 <ivanm> @src Show
23:18:29 <lambdabot> class  Show a  where
23:18:29 <lambdabot>     showsPrec :: Int -> a -> ShowS
23:18:29 <lambdabot>     show      :: a   -> String
23:18:29 <lambdabot>     showList  :: [a] -> ShowS
23:18:41 <ivanm> Axman6: you get the point of ShowS in general?
23:18:56 <ivanm> @src Char showsPrec
23:18:56 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:22:09 <maurer_> Is it possible to test in code whether or not cabal flags are set, a la #ifdef in C/C++?
23:22:20 <ivanm> maurer_: yes, CPP macros
23:22:46 <maurer_> ivanm: So if I define a flag in a .cabal file, and then just do #ifdef flagname it will work as expected?
23:23:23 <ivanm> maurer_: not sure how to use it myself
23:23:29 <ivanm> just that it is possible ;-)
23:23:50 <Axman6> i'd check the criterion .cabal file, it uses it with -f-chart
23:24:16 <maurer_> ivanm: OK--I'm trying to make cabal-install work with the new Cabal, but the changes even so far will break compatibility with old versions of ghc/the libs as the interface changed drastically
23:24:42 <maurer_> I was going to try to detect which version of cabal was in use and switch on that, but...
23:25:12 <Saizan> maurer_: i think the idea is to just update it to the new Cabal, it should still work for older ghc's
23:25:27 <maurer_> Oh
23:25:56 <ivanm> maurer_: yeah, cabal is backwards compatible with GHC, cabal-install just needs to use new cabal
23:25:59 <Saizan> it doesn't need to compile with older Cabal's since you can update the Cabal library without updating your ghc
23:26:09 <maurer_> OK
23:28:57 <Saizan> for completeness' sake,  Cabal defines cpp macros to switch on the versions of dependencies in dist/build/autogen/cabal_macros.h
23:36:40 <iaefai> When running ghci with my hs file, I get a syntax error on 'pieces' with backSet = fromList $ List.map trans pieces   and I am not sure why. Both trans and pieces are defined in a where clause on the next line.
23:37:25 <Saizan> it has to be something surrounding that line
23:37:53 <Saizan> @paste
23:37:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
23:38:02 <Saizan> so we can see :)
23:38:09 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11031#a11031
23:38:44 <Saizan> the error is probably on the definition of pieces
23:38:48 <iaefai> chess.hs:26:10: parse error on input `pieces'
23:38:54 <Saizan> it has to be aligned with trans
23:39:01 <iaefai> you are correct by the looks of it, I missed it (again)
23:39:09 <Saizan> are you mixing tabs and spaces, perhaps?
23:39:12 <iaefai> yes
23:40:12 <Saizan> set your editor so that it inserts spaces instead of tabs
23:42:10 <iaefai> There is an nice option called Detab :p
23:42:17 <iaefai> I also told it to expand tabs
23:46:56 <iaefai> ok, I now have a chess board defined in a nice functional way, I think I am going to try to make a nice show function that will show it as a text grid to make debugging easier
23:55:06 <dancor> can SDL give me the pixel value of the upper left corner of an image?  i'm disturbed by this being empty: http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.2/doc/html/Graphics-UI-SDL-Primitives.html
23:56:46 <Saizan> dancor: that module is re-exporting things from the SDL package
