00:01:16 <Cale> I think that anything which says information can travel faster than light has some serious experimental verification to undergo before anyone's going to take it seriously.
00:01:50 <eflister> uh, entanglement?
00:02:02 <Cale> Entanglement doesn't imply that.
00:02:24 <Jafet> Quantum science is like the liberal arts
00:02:33 <Jafet> It's all up to "interpretation"
00:02:40 <c_wraith> I'm all for giving up locality, because I like the idea of FTL communication.
00:02:52 <Cale> It *would* imply it, if quantum mechanical effects were the result of classical probabilistic phenomena.
00:02:57 <eflister> bohmian implies it no more than entanglement does
00:03:03 <Cale> This is something which many science reporters screw up on.
00:03:43 <Cale> This is the usual way of showing that QM isn't the result of hidden variables.
00:04:09 <Cale> Because if it were, then you have to give up on "information can't travel faster than light"
00:04:20 <Cale> which nobody wants to do
00:04:37 <kmc> so, i don't know quantum but wp says that bohm is a non-relativistic hidden variables interpretation
00:05:59 <eflister> copenhagen is nonsense, that can't be preferable to nonlocality
00:06:05 <eflister> mwi, maybe
00:06:34 <eflister> but bohm is the most natural, given no evidence against it
00:06:37 <Cale> Copenhagen is many worlds + garbage collection.
00:06:51 <Cale> and many worlds is sensible
00:07:03 <Cale> (so Copenhagen is too :)
00:07:30 <c_wraith> the universe has a garbage collector?
00:07:32 <Cale> The 'collapsing' isn't an actual physical phenomenon.
00:07:35 <int-e> @quote copenhagen
00:07:35 <lambdabot> No quotes match. I am sorry.
00:07:36 <c_wraith> What implementation does it use?
00:07:52 <int-e> mm, I thought I had seen that there.
00:08:02 <Cale> It's just something that we're allowed to do, because the rest of the terms in the sum can't matter.
00:08:20 <eflister> i read a funny paper that worked out how far away you'd have to go to find an observable universe exactly like ours, arguing from how many ways there are to arrange the protons in a volume the size of the obs.univ.  it was pretty close by.
00:08:55 <eflister> copenhagen doesn't even try to explain anything, it just says "it's illegal to ask that"
00:09:27 <ivanm> Cale: there's GC on the multiverse level? :o
00:09:51 <Cale> ivanm: No, on the "what the experimenter has to record" level.
00:10:11 <ivanm> ahhh
00:10:46 <Cale> While you can carry out calculations to discover things about what's going on in the other terms of the sum (the "other universes"), it doesn't matter, because all observables are linear operators, and split up over the sum.
00:11:04 <Cale> So once you see a particular result, you can junk the rest of the terms
00:11:10 <Cale> That's what the "collapse" is.
00:11:24 <eflister> but what is the 'you'
00:11:32 <Cale> Of course, the operator "I see a deterministic result" is also an observable
00:11:37 <Cale> and splits up over the terms
00:11:47 <Cale> and of course, each of the terms has a deterministic result in it
00:13:21 <Cale> For example, suppose we do some measurement which is 1/sqrt(2) (|up> + |down>)
00:14:06 <Cale> And D is the observable which measures whether we see either up or down, but not some hazy combination of both.
00:14:40 <Cale> So D(|up>) = |yes>, and D(|no>) = |yes>
00:14:58 <Cale> but D has to be linear
00:16:25 <eflister> s/no/down, but the issue is who's D, and why them?
00:17:10 <Warrigal> Oh dear, I think you're talking about quantum mechanics.
00:17:17 <Cale> eflister: Any given experimenter, it doesn't matter who, and we can use more than one, by using separate D's
00:17:29 <Cale> (and yeah, thanks for the correction)
00:17:29 <eflister> what's an experimenter?
00:17:34 <Cale> A human
00:17:38 <Cale> Or a machine
00:17:41 <Cale> It doesn't matter.
00:17:48 <Warrigal> eflister: bohm, you say?
00:17:50 <c_wraith> What about a martian?
00:18:38 <Cale> eflister: I haven't collapsed anything yet, this is still uninterpreted quantum mechanics or many worlds
00:19:08 <Warrigal> Huh, the Bohm interpretation. Strange.
00:21:04 <Cale> So if we apply this observable D to the experiment, then we see D(1/sqrt(2) (|up> + |down>) = 1/sqrt(2) (D |up> + D |down>) = 1/sqrt(2) (|yes> + |yes>) = sqrt(2) |yes> -- all signs point to yes ;)
00:23:29 <Cale> So, QM predicts that we will feel like we observed a deterministic result, even though the result we obtain is different in different parts of that sum
00:23:29 <Cale> (simply because whether we feel like we get a deterministic result is a linear operator, and it answers all the basis vectors with "yes")
00:25:24 <Cale> Well, this isn't the whole story. To really see why we can cut away the other terms of the sum once anyone thinks they see a deterministic result about it, you need to look at tensor products, but basically, that guy's state is entangled with the state of the system that he's measuring, and he will never observe anything which contradicts the deterministic result which he saw.
00:25:51 <ivanm> Cale: if that's not the whole story, I'd hate to see you explain the whole story...
00:25:51 <ivanm> ;-)
00:26:35 <harlekin> Quick math question: Can a class be equal to a set?
00:26:43 <Cale> Of course, outside observers of that guy will get entangled with him and the rest of the system, and so on. Once you run out of outside observers that you care about, you can garbage collect by dropping all the terms that nobody reports seeing.
00:26:48 <Cale> harlekin: yes
00:27:14 <dolio> harlekin: Sets are classes in set theories that talk about classes, as far as I know.
00:27:23 <dolio> But there are some classes that aren't sets.
00:27:24 <Cale> harlekin: Usually in (conservative extensions of) ZFC, classes are effectively predicates on sets.
00:27:43 <Cale> and sometimes there is a set which is exactly the set of all sets which meet that predicate
00:27:50 <harlekin> So I can define the class K := { x | x /= K } which wouldn't be a set?
00:27:52 <Cale> If there isn't, then the class is called a proper class.
00:28:12 <harlekin> Yeah. I have to define a proper class and came up with that idea. But I don't know if it's valid notation.
00:28:47 <Cale> Well, usually the predicates on sets can't directly mention classes.
00:28:59 <Cale> There's an easier class to choose...
00:29:15 <harlekin> I shouldn't use the predicate x = x.
00:29:16 <Cale> K = { x | true }
00:29:19 <Cale> oh
00:29:22 <harlekin> :)
00:29:29 <Cale> K = { x | x is a group } ?
00:29:55 <harlekin> We're pretty much at the beginning of set theory. So I think I cannot use that either.
00:29:56 <Cale> Or...
00:30:20 <harlekin> I think I have to ponder a little more. But thank you very much. :)
00:30:23 <Cale> K = { x | exists y. y in x and forall z. z in x => z = y }
00:30:44 <Cale> That's the class of all singleton sets.
00:31:03 <Warrigal> The class K of all sets that are not K?
00:31:16 <Warrigal> That's definitely the class of all sets.
00:31:28 <Cale> You're not usually allowed to refer to classes when defining the predicates which give classes.
00:31:51 <Warrigal> Bah, "allowed".
00:31:54 <Cale> Well, it's usually not a problem as long as things aren't recursive, because you can always translate away any nonrecursive use of classes.
00:31:59 <Warrigal> Is there a definition of "class", anyway?
00:32:02 <Cale> Yes.
00:32:09 <Cale> A class is a predicate on sets.
00:32:26 <Warrigal> What's a "predicate", then?
00:32:41 <Warrigal> (I promise not to ask you to define one word in each of your definitions.)
00:32:42 <Cale> You have to build up the first order language of set theory.
00:32:50 <Warrigal> Okay, suppose we've done that.
00:32:59 <Saizan_> in D(|up>) = |yes>; D(|down>) = |yes> above, the yes stands for "yes, i've observed a deterministic result"?
00:33:07 <Warrigal> A "predicate" is some predicate in that language, then?
00:33:30 <Cale> But basically it's a formula on sets with one free variable -- plug a set into that variable and you get a statement that you can try to evaluate the truth of.
00:33:36 <Warrigal> In that case, there are only as many classes as there are sets.
00:33:55 <Cale> Warrigal: There are classes which are not the class of elements of any given set.
00:34:04 <Cale> For example, the predicate which is always true.
00:34:11 <Warrigal> I know. That doesn't mean there are more classes than sets.
00:34:12 <Cale> Saizan_: yeah
00:34:32 <Cale> Warrigal: Oh, there aren't. In some sense there are fewer.
00:34:40 * Warrigal nods.
00:34:54 <Cale> Though it's not a very well-defined sense, since you're mixing levels sort of.
00:34:56 <Warrigal> I'm guessing every set is considered a class.
00:35:08 <Warrigal> Which kind of means there aren't fewer. :-P
00:35:09 <Cale> yeah, there's a class which corresponds to each set
00:35:31 <Cale> Yeah, it gets confusing quickly if you try to measure ;)
00:35:53 <Warrigal> Hum, I want a set theory in which there are more classes than sets.
00:35:55 <Cale> If you measure from the metalanguage, you see quickly that there are only countably many classes.
00:36:39 <Cale> But from inside... well, it's not clear that classes are really anything at all, since we usually just define them as syntax sugar.
00:36:41 <Warrigal> How about ZFC + "ZFC, where the domain of discourse is all sets satisfying predicate P" + "there is a set containing precisely those sets satisfying predicate P"?
00:37:25 <Cale> But we could add new axioms which let us talk about classes properly and a bit of a type theory, but most things I've seen don't even go that far
00:37:30 * Warrigal nods.
00:37:43 <Cale> They just define a translation from statements about sets + classes to statements about sets
00:37:59 <harlekin> Cale, could I define the set M := { x | x /= M } and call the class (x /= M) a proper class?
00:38:17 <harlekin> Well... M wouldn't be a set.
00:39:14 <Cale> They can't be recursive, because they can only talk about sets
00:39:36 <Cale> The predicate you define the class with must be a predicate in set theory alone, not set theory + classes.
00:40:15 <Cale> You can use a predicate in set theory + classes, as long as you can still translate it away, which means that circular/recursive definitions are out.
00:40:24 <harlekin> Ok. Thank you very much.
00:40:26 <Warrigal> I had a neat idea for a quickly growing function.
00:40:27 <harlekin> I have to go now. Bye.
00:42:19 <Warrigal> First, let ZFC_n = ZFC + "for all m < n, ZFC_m is consistent". Then, let B(n) = the smallest ordinal number not definable in any ZFC_m for m < n, assuming all such ZFC_m are consistent.
00:43:36 <Cale> For an example of the sort of translation, if we write [x | P(x)] for the class given by the predicate P, then something like a in [x | P(x)] just gets translated to P(a), and [x | P(x)] union [x | Q(x)] gets translated to [x | P(x) or Q(x)], and so on.
00:44:38 <Saizan_> hah, that'd be easy to do with typeclasses and liftMn :)
00:44:52 <Warrigal> Speaking of the Sierpinski space...
00:45:15 <Warrigal> Wait, now I know the answer to the question I was going to ask. :-P
00:46:01 <Warrigal> Let data S = Stop | Defer S. For all x in S, glue x to Defer x.
00:46:35 <Warrigal> And voila: the Sierpinski 0 is Stop or any of its brethren, and 1 is fix Defer.
00:46:47 <Warrigal> Except actually the other way around.
00:47:41 <Cale> yep
00:47:45 <Cale> f Stop = ()
00:47:57 <Cale> f (Defer x) = f x
00:48:38 <Warrigal> And that translates S to ()-with-bottom.
00:49:31 <Warrigal> (I like thinking of the Sierpinski space as being shaped like a captive bead ring.)
00:49:56 <Warrigal> "Captive bead ring" totally ought to be a mathematical term.
00:52:24 <Cale> Warrigal: I take it you've seen http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf ?
00:56:48 <mxc> is hare essentially dead?
01:00:27 <iaefai> What might be a quick way of producing a list of n elements which are exactly the same?
01:01:07 <BONUS> > replicate 3 100
01:01:08 <lambdabot>   [100,100,100]
01:01:56 <eflister> what's up bonus?  i heard yer the author of lyah?
01:02:34 <eflister> you probably get lots of thank yous, but i wanted to give you another one anyway :)
01:03:12 <A1kmm> hmm, it seems that the Data.Time Typeable instances are creating a compatibility rift - with convertible restricting time < 1.3, and other packages like newer versions of HDBC depending on them being present.
01:03:30 <A1kmm> Which makes newer HDBC version incompatible with the newest Convertible package which it depends on.
01:03:31 <iaefai> Gee, I love haskell :P makeColouredRow n c = zip n (replicate 8 c)
01:03:36 <iaefai> Thanks BONUS
01:05:22 <Saizan_> A1kmm: yeah, basically HDBC should have an upper bound on its convertible dep. until the thing gets sorted out at least
01:06:40 <Saizan_> sometimes i'd like a --do-not-trust-maintainers-that-think-they-can-see-the-future
01:07:26 <c_wraith> Isn't the real problem there that convertible added an orphan instance?
01:07:46 <A1kmm> saizan: There almost need to be two 'latest' versions - one targeted at Haskell platform, and one that aims to 'avoid success at all costs'. Then the former convertible should work with the latest time, rather than the Haskell platform one.
01:08:30 <A1kmm> Although I guess some way to pre-process based on the version of installed dependencies would be a better solution.
01:10:31 <Saizan_> ah, yeah, it's easy to check the version of deps with CPP
01:10:39 <Saizan_> Cabal defines the appropriate macros
01:11:42 <c_wraith> Then the author of convertible could make a release that works with both older and newer versions of time.
01:11:59 <Saizan_> (which is the same author of HDBC, btw)
01:13:08 <Cale> "older and newer versions of time"
01:13:23 <c_wraith> time changes!
01:14:11 <Cale> Time is not what it used to be :)
01:14:19 <c_wraith> It rarely is.
01:14:35 <eflister> does cabal have an option for linking dynamically to an installed library rather than building its own, when using FFI?  here's an example: http://hackage.haskell.org/packages/archive/PortMidi/0.1.2/PortMidi.cabal
01:16:09 <Warrigal> Cale: I think I'm aware of the concept, but I don't think I've ever read anything about it.
01:16:46 <Warrigal> Though I vaguely remember that I got the fact that datatypes look like Cantor sets from somewhere.
01:21:38 <Saizan_> eflister: sure, e.g. zlib on unix links to the installed one
01:22:50 <eflister> well i mean can i specify an option to 'cabal install' that says 'don't build that thing you think you're supposed to build, instead use this library i already have'?  or does the .cabal author have to have arranged for that?
01:23:38 <Saizan_> eflister: the latter
01:24:45 <eflister> Saizan_:   it would be nice to have the option (with a ymmv warning)
01:25:32 <eflister> Saizan_: can the author arrange for the user to choose at install time?
01:29:53 <Saizan_> eflister: yes, it can add a flag inside the .cabal file
01:30:12 <Saizan_> s/it/he/
01:33:43 <eflister> Saizan_: i'm looking around in here but don't see it, is this a bad place to look?  http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
01:42:24 <Saizan_> eflister: there isn't anything built-in though you can define your own Flag and then use if to switch on it
01:42:55 <Saizan_> eflister: like in Example 4
01:43:07 <eflister> Saizan_: oh.  could it do something like see if the lib is installed, an if not, then install it?
01:43:55 * eflister looks at example 4
01:44:28 <Saizan_> eflister: there's a ticket about implementing that sort of thing, i.e. take into consideration the existence of C libs when deciding the assignment of flags
01:45:41 <Saizan_> since cabal already search for a working flag assignment, unless the user specifies a value explicitly
02:05:55 <Baughn> http://xkcd.com/654/ <-- All of a sudden... Cthulhu
02:12:05 * Cyneox re
02:12:30 <Baughn> re?
02:12:41 <Raevel> re!
02:12:47 <Baughn> Ni!
02:14:20 <Zao> Nu!
02:14:45 <Baughn> In the beginning was Nu. In the end will be Nu. In between.. are Mu.
02:16:41 <sinelaw> Moo.
02:19:20 <shambler> Zoo.
02:20:04 <kamatsu> shoo
02:20:15 <Saizan_> Baughn: omg, it feels like it's the 90s all over again!
02:20:45 <Baughn> Yes. I was shocked and horrified..
02:20:58 * Baughn shudders at the though of more sites following their example
02:34:36 <Baughn> http://www.normalhumanheroes.com/2009/09/03/nightmare-futures/ <-- This is not your typical #haskell fare, but you may wish to read it anyway.
02:36:52 <fasta> Baughn: that must be a fun guy to go out with ;)
02:37:20 <Baughn> fasta: I think I'd enjoy it. It's disturbingly likely, anyhow.
02:37:57 <fasta> Baughn: it does make certain assumptions.
02:38:21 <fasta> Baughn: I think there are currently only a hand full of people that can make these kinds of machines.
02:38:56 <fasta> Baughn: and those persons are not doing it, because it is now too expensive to do so.
02:39:04 <Baughn> fasta: Even if there were more, there are currently only a handful of computers in the world that could possibly run them
02:39:20 <Baughn> Although a superintelligence would probably find some way to get its way
02:39:39 <Baughn> fasta: No, I'm more worried about what will happen when we get another few orders of magnitude of computing power
02:40:23 <fasta> Yes, it would be nice to know how long (in number of Pentium 4 cycles) it would take for a superintelligence to emerge from just an internet connection as input.
02:40:45 <fasta> and a horrible utility function like optimizing someones backaccount.
02:41:03 <fasta> I think it would take millions of years at least.
02:41:09 <Baughn> fasta: http://lesswrong.com/lw/y3/value_is_fragile/ <-- It's not like finding bad utility functions is /hard/
02:41:09 <endojelly> if at all, yes
02:41:21 <idnar> but, the singularity!
02:41:24 <fasta> You need a lot of bias to get something useful.
02:41:35 <fasta> I don't really buy into the singularity theory.
02:41:43 <Botje> i like the new xkcd look :)
02:42:09 <endojelly> I think the singularity theory is "neat", but I don't really see a good foundation for it
02:42:31 <Baughn> fasta: It seems obvious that, /if/ we could make a human-equivalent AI in a human-usable timespan, then running that AI on computers faster than humans and having it make the next generation would speed things up a fair bit
02:42:41 <endojelly> it's basically assuming that all you need for a sufficiently flexible super AI to emerge is bare computing power
02:43:20 <koala_man> no one knows how much computing power is required for intelligence. basing it on the brain isn't very objective
02:43:32 <fasta> I like to believe that I have human level intelligence, but I am not rewiring my own brain, am I?
02:43:38 <Baughn> True. The brain is incredibly inefficient; it's probably a good deal less
02:44:09 <endojelly> the brain is sloppy. quite possible that you need this sloppiness for intelligence like we have it to emerge
02:44:18 <fasta> Ok, some people are trying to add some very primitive chips, but it's not obvious that human level intelligence implies microsecond self-improvements ;)
02:44:23 <endojelly> so you'd have to somehow add that sloppyness besides the computing power
02:44:29 <Baughn> Perhaps, but we're not trying to make it /emerge/, we're tryin to /make/ it
02:44:35 <endojelly> freely evolving genetic algorithms sound like a possibility.
02:44:40 <Baughn> And if someone /is/ trying to make it emerge, they should be shot
02:44:44 <endojelly> just give it enough time and computing power to evolve into whatever
02:44:52 <fasta> Genetic algorithms is not how it will work.
02:45:09 <endojelly> maybe someday some strange mutations will start to exploit things like little programming bugs
02:45:14 <endojelly> buffer overflows and the like
02:45:18 <endojelly> take over the host system 8)
02:45:49 <Baughn> fasta: Heh. Actually.. imagine a universe with physical laws slightly different from our own.
02:45:54 <koala_man> someone steals a google employee's access card and rolls out skynet on their entire server farm
02:46:05 <fasta> In a few years you can probably take the Internet down for any meaningful value of down with such a system, though.
02:46:06 <endojelly> but, hell, I can't even imagine how much computing power, time, and enough of the right "environmental" parameters you'd need for something like that to really happen
02:46:10 <Baughn> fasta: Computations are much, /much/ cheaper - you can make computers fast enough to simulate an entire universe using 1700s-level technology
02:46:17 <idnar> of course, there's the other question about how you even recognise sentience
02:46:26 <Baughn> fasta: Now add a relatively simple-minded race to do so. And have them try to make AI.
02:46:34 <idnar> maybe we already have sentient machine intelligence
02:46:40 <fasta> Most of the critical internet services have open-source or open-machine code, so it would not be that hard.
02:46:45 <Baughn> fasta: Step one: Simulate a universe, pattern-match for intelligence. Yeah. We're it. ^_^
02:47:05 <fasta> Baughn: recognizing intelligence is very hard, I think.
02:47:26 <endojelly> fasta, if not just for the fact that intelligence is really poorly defined
02:47:43 <fasta> endojelly: I like the definitions in "Super machine intelligence".
02:48:06 <endojelly> don't know that?
02:48:37 <Baughn> fasta: With sufficient computing power.. it might do things like look for planets that diverge a bit from norms
02:48:49 <Baughn> fasta: Eventually, we'd trigger the recognizer
02:49:00 <Baughn> ..if nothing else, when we start taking them apart
02:49:35 <fasta> Baughn: yes, all possible in theory. The hard problem is making it work before you die.
02:50:17 <Baughn> fasta: Mm. Well, I started off by proposing different laws of physics, so why not make them sentient, immortal.. ants?
02:50:36 <Baughn> *sapient, dammit
02:50:45 <fasta> Baughn: I meant that we still die.
02:50:55 <fasta> Baughn: we run those ants for us, right?
02:51:01 <Baughn> fasta: No. Other way around.
02:51:37 <Baughn> Look, you can't simulate a useful universe inside /this/ one. You /can/ simulate this universe, though - inside a much nicer one.
02:52:22 <fasta> Baughn: yes, so, your point being?
02:52:59 <Baughn> fasta: That even evolutionary algorithms will work, if given sufficient power. Though I think I overdid it a bit with that level of power, it's at least existential evidence.
02:53:30 <yitz> @seen dcoutts
02:53:30 <lambdabot> Unknown command, try @list
02:53:37 <Baughn> ,seen dcoutts
02:53:39 <fasta> Baughn: oh, sure, but it is not the most efficient way to do so. For simulating universes there are asymptotically optimal algorithms already.
02:53:40 <lunabot>  luna: Not in scope: `seen'
02:53:41 <yitz> preflex: seen dcoutts
02:53:41 <preflex>  dcoutts was last seen on #ghc 2 days, 19 hours, 52 minutes and 42 seconds ago, saying: ah
02:53:49 <yitz> oh.
02:54:16 <Baughn> fasta: ..what do you mean?
02:55:16 <fasta> Baughn: well, instead of simulating one universe you could just simulate all of them at the same time.
02:56:20 <fasta> Baughn: http://www.idsia.ch/~juergen/computeruniverse.html has some papers on the subject.
02:56:53 <fasta> If you think about it, it's not that odd. E.g. how do you program a waterfall?
02:57:26 <fasta> You don't go off and program all the equations. It would be much easier to just do everything. One of those will be this universe in which everything looks OK.
02:58:36 <Baughn> fasta: Oh. Well, yes, I suppose you could..
02:58:38 <yitz> @ask dcoutts: According to this blog linked from reddit, http://substack.net/posts/ea85c2/Happstack-on-Dreamhost-Notes, some pkgs override extra-lib-dirs and extra-include-dirs even when set in .cabal/config, causing breakage. What should be done?
02:58:38 <lambdabot> Consider it noted.
02:59:10 <Baughn> fasta: Problem is, if you're simulating every possible universe, it would be very hard to do anything useful with the simulation. You have to special-case any recognition/extraction code /anyway/
02:59:37 <SamB_XP> what does it mean for a universe to be possible ?
02:59:43 <idnar> yeah
02:59:53 <fasta> SamB_XP: if it doesn't crash.
02:59:58 <idnar> it's like saying that I can write a program that will generate an image of the face of God
03:00:30 <Baughn> SamB_XP: I don't know about "possible", but computable should at least be a subset of that
03:00:38 <idnar> all I need to do is generate every possible (say) 1024x1024px image ;P
03:00:40 * Baughn makes no bets on whether it's a proper one
03:02:42 <SamB_XP> idnar: well, that assumes the face of god can be represented in 1024x1024x(8-8-8 sRGB)
03:03:11 <fasta> Don't let God hear tell you that he is fat! ;)
03:03:33 <idnar> SamB_XP: well, sure, but you know what I mean :P
03:03:35 <fasta> you tell*
03:03:47 <idnar> the difficulty becomes determining which of the generated images is the desired one
03:04:23 <SamB_XP> now, if you mean the face of Jesus, I'm sure there are many such representations
03:04:29 <Jafet> Actually, all you need to do is generate nine billion words!
03:05:31 <SamB_XP> but since nobody still alive has actually seen him, it would be difficult to pick any of them out
03:05:49 <dancor> finn mccool prob has
03:06:26 <sohum> Jafet: nine billion names of god?
03:06:32 <SamB_XP> (the people who had seen him while they were still alive having died about 1950--2000 years back ;-P)
03:06:45 <SamB_XP> er, wait
03:07:04 <SamB_XP> make that 1920--1970 years
03:07:31 * SamB_XP forgot which end of Jesus' life was the epoch momentarily
03:08:03 <dancor> neither he was born in 4 bc
03:08:11 <idnar> or 7 bc
03:08:17 <idnar> or 15 bc
03:08:20 <fasta> This all assumes that there was a figure named Jesus and there is a God of course... all of which are both probably false.
03:08:29 <dancor> 7-2
03:08:33 <idnar> or just about any date within a few decades of that, depending on who you listen to :P
03:08:42 <SamB_XP> idnar: okay, okay
03:08:51 <SamB_XP> well, somewhere around 1950 years ago, then!
03:08:59 <Jafet> http://www.gdargaud.net/Humor/Pics/CanYouSeeJesus.jpg
03:09:04 <Jafet> Solved
03:09:47 <SamB_XP> fasta: it's pretty well documented that there was a guy named Jesus
03:10:08 <fasta> SamB_XP: like where?
03:10:27 <SamB_XP> it's a little less-well documented whether there is a God, since hardly anyone has actually claimed to see him...
03:10:41 <SamB_XP> fasta: okay, I'm going to admit that I don't read greek at this point
03:10:45 <SamB_XP> or latin
03:10:51 <therp> god? is that imaginary friend still a meme today?
03:11:06 <yitz> preflex: seen bos
03:11:07 <preflex>  bos was last seen on #haskell 4 days, 13 hours, 58 minutes and 42 seconds ago, saying: idnar: ah, fixed
03:11:27 <Jafet> I assure you there are a fair number of people having claimed to see a "God"
03:11:29 <therp> preflex: seen god
03:11:29 <preflex>  god was last seen on ##c++ 22 days, 11 hours, 6 minutes and 28 seconds ago, saying: I don't really know either actually
03:11:49 <SamB_XP> Jafet: yeah, but most of their stories are uncorroborated
03:12:14 <fasta> There are also a lot of people who believe in ghosts.
03:12:31 <SamB_XP> lol@preflex
03:12:37 <Jafet> fasta, now there's a correlation you can't ignore!
03:12:41 <dcoutts> yitz: hia
03:12:41 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:12:48 <SamB_XP> fasta: those stories are also uncorroborated!
03:12:58 <yitz> hi dcoutts
03:13:27 <SamB_XP> the fact that people are arguing about exactly how many BC Jesus was born seems to indicate that there is some evidence that he was ;-P
03:13:37 <fasta> SamB_XP: that's why I said so ;)
03:13:55 <fasta> SamB_XP: yeah, I am sure that makes a really strong case in court.
03:13:59 <dcoutts> yitz: the extra-lib/include-dirs in the ~/.cabal/config are additional to whatever is specified in the .cabal file for each package
03:14:30 <yitz> dcoutts: look at that blog - that led to breakage. anything to be done?
03:14:31 <dcoutts> yitz: is it the order that you are concerned about?
03:14:40 <SamB_XP> fasta: well, I figure you could just go look at the arguments to find the evidence ...
03:14:48 <yitz> dcoutts: could be that's the issue
03:15:10 <fasta> SamB_XP: nah, I would rather not waste my time on things that have a probability of zero of affecting my life.
03:15:19 <fasta> By definition I go to hell only when I die :)
03:15:31 <Jafet> Bayes would have something to say about that...
03:15:48 <SamB_XP> fasta: that's a pretty lousy reason not to consider the possibility!
03:15:49 <idnar> bayesian salvation?
03:15:49 <dcoutts> yitz: I'm afraid there's not enough info there to see what the problem is
03:16:03 <Jafet> Repent and you will conditionally be saved!
03:16:04 <SamB_XP> just because you'll have died won't make it any less lonely
03:16:04 <fasta> SamB_XP: of course I considered the possibility.
03:16:06 <dcoutts> yitz: there are no specifics at all
03:16:19 <fasta> SamB_XP: and then it was like "uhm, no, bad idea". :)
03:16:50 <dcoutts> yitz: now it's true that packages with ./configure scripts will often not respect the extra-lib/include-dirs flags, that is a known problem and could be the cause.
03:16:52 <fasta> I hope to believe that at least 80% thinks like that and only goes to church for social reasons.
03:17:48 <yitz> dcoutts: ah, that could be it. i though maybe it has to do with the virtual server environment.
03:17:55 <dcoutts> yitz: on the other hand, he says he modified the .cabal files to fix it, so it's not clear that it was the annoying ./configure scripts
03:18:10 <yitz> dcoutts: e.g., any hard-coded non-relative paths will point to the wrong place.
03:18:18 <dcoutts> yitz: if you get enough details to be able to file a bug report that'd be great
03:18:25 <yitz> dcoutts: so you need to be able to override the cabal file somehow
03:18:40 <dcoutts> yitz: that's what the extra-lib/include-dirs are for
03:19:04 <yitz> dcoutts: but they did not override, the pkg cabal file took precedence
03:19:19 <dcoutts> yitz: I don't believe that is the current behaviour
03:19:21 <yitz> presumably
03:19:48 <yitz> dcoutts: ok, so maybe it has more to do with pkg config scripts.
03:20:15 <yitz> i'll post a comment to the reddit (comments closed on the blog), hope we'll get more info.
03:20:30 <ivanm> which blog post are we talking about here?
03:20:39 <yitz> http://substack.net/posts/ea85c2/Happstack-on-Dreamhost-Notes
03:20:46 <yitz> linked from reddit
03:21:08 <dcoutts> yitz: the extra-lib/include-dirs flags are used to extend the package description itself, using `mappend`
03:21:33 <yitz> dcoutts: mappend is not commutative
03:21:49 <dcoutts> yitz: indeed, it's equivalent to adding the dirs at the _end_ of each stanza of the .cabal file
03:22:03 <dcoutts> so they get passed to ghc/gcc last
03:22:26 <yitz> dcoutts: so currently there is no way to prepend? perhaps that is what is needed here.
03:22:28 <dcoutts> -I${the-ones-from-the-cabal-file} -I${the-ones-from-the-command-line}
03:22:44 <dcoutts> yitz: maybe, not enough detail to say
03:23:52 <SamB_XP> can you do that within the Monoid laws ?
03:25:01 <yitz> SamB_XP: not really. you could reverse the order that you pass the parameters to mappend, or you could use flip mappend.
03:25:02 <hackagebot> regular 0.2 - Generic programming library for regular datatypes. (JosePedroMagalhaes)
03:25:04 <hackagebot> regular-extras 0.1 - Additional functions for regular: arbitrary,  coarbitrary, and binary get/put. (JosePedroMagalhaes)
03:25:49 <yitz> monoids are not commutative in general. in fact, many of the most interesting examples of monoids are inherently non-commutative.
03:28:06 <fasta> How can I use CPP directives in a c2hs input file?
03:28:28 <fasta> It appears c2hs does a very sensible thing: throwing away my commands...
03:28:31 <fasta> Very useful.
03:29:11 <fasta> It seems to assume that every include file is related to the actual binding process.
03:29:33 <fasta> ChilliX: ping
03:31:10 <dcoutts> fasta: you can include things into the header file that c2hs will process
03:31:20 <dcoutts> using #c .. #endc
03:31:53 <fasta> dcoutts: ok, that was in the manual, yes. I had the impression that was more for "real inline C code".
03:32:00 <fasta> dcoutts: thanks
03:32:11 <dcoutts> fasta: are you trying to process the .chs file itself using cpp?
03:33:02 <ivanm> with yi, I take it the ghcInterpreter option doesn't work yet if it needs an unreleased version of hint?
03:33:06 <fasta> dcoutts: no, I want that the processed file (*.hs) still contains some CPP directives which are then interpreted by CPP.
03:33:23 <fasta> dcoutts: the GHC implementation of CPP.
03:33:24 <dcoutts> fasta: oh, no, that's not possible.
03:33:50 <dcoutts> but is it really necessary? can't you do the cpp beforehand?
03:34:02 <dcoutts> is it essential that it be done after processing with c2hs?
03:34:06 <hackagebot> rewriting 0.2.1 - Generic rewriting library for regular datatypes. (JosePedroMagalhaes)
03:34:08 <hackagebot> regular-extras 0.1.1 - Additional functions for regular: arbitrary,  coarbitrary, and binary get/put. (JosePedroMagalhaes)
03:34:24 <fasta> dcoutts: well, I could, but it would be a "work around".
03:34:59 <dcoutts> fasta: gtk2hs processes .chs.pp files with cpp then c2hs
03:35:14 <dcoutts> but c2hs also uses cpp so that's usually not necessary
03:41:30 <kamatsu> jinjing: hey, does bamboo support comments? seems to be part of the config file, but nothing much shows up on my page
03:42:11 <jinjing>  it does
03:42:20 <kamatsu> what am I missing?
03:43:17 <jinjing> extensions = search, analytics, comment
03:43:20 <jinjing> got this in site.txt?
03:43:31 <jinjing> code is crap though, just a concept
03:44:25 <Butz> hello guys ... anybody got some time to help me out? got a "parse error" and actually no idea what i am doing wrong :)
03:44:32 <kamatsu> jinjing: i have that, except i removed analytics
03:44:39 <Butz> note: i am pretty new to haskell ;)
03:44:52 <fasta> Butz: ask the real question and paste the code somewhere.
03:45:50 <jinjing> kamatsu: how did you get it installed?
03:46:02 <jinjing> via bamboo-launcher?
03:46:24 <jinjing> it works fine for me, need to click in a post to see the comment form
03:48:07 <kamatsu> jinjing: i feel like an idiot now
03:48:14 <kamatsu> i didn't click the post
03:48:25 <kamatsu> right, sorry for bothering you =P
03:48:27 <jinjing> ok, it isn't obvious anyway
03:48:31 <jinjing> np
03:49:54 <Cale> Butz: hpaste.org :)
03:50:40 * SamB_XP wonders how to get Windows to redo the rendering of titlebar buttons ...
03:52:05 <SamB_XP> (at some point it seems to have run out of [V]RAM and stomped all over it's cached renderings of them, so they now look like utter garbage...)
03:53:48 <kamatsu> jinjing: another problem, it doesn't seem to cache, i even put use_cache = y in the site.txt
03:53:56 <kamatsu> either that or i can't find the cache file anywhere
03:54:11 <SamB_XP> strace for great justice ?
03:54:21 <jinjing> kamatsu: it used to cache, i removed the feature
03:54:46 <kamatsu> why is that? doesn't caching improve performance?
03:55:10 <jinjing> kamatsu: i was too lazy to reimplemented why doing the refactoring
03:55:18 <kamatsu> fair enough
03:55:34 <kamatsu> should be fast enough without it anyway
03:55:47 <SamB_XP> huh ... right-clicked on the desktop and picked "Properties", and do you know what it told me?
03:56:05 <SamB_XP> it said something about "Path/to/Mine.theme is not a valid theme"!
03:56:32 <fasta> dcoutts: I did what you suggested with the .chs.pp stuff, integrated it in the build process, but it doesn't appear to work. I get lots of "bla_type_t" (a C struct which I defined in an include file and works just fine without this extra pass) not defined. I use the real cpp platform binary for cpp. This gets converted into a .chs file containing lots of stucts now, because the include file gets expanded. I am not sure whether or not that should happen in the w
03:56:32 <fasta> ay you do it.
03:56:37 <jinjing> kamatsu: besides, it should really be solved at the http level, and app should only give some hints, my original implementation was wrong
03:56:38 <lvh> hi
03:56:46 <kamatsu> indeed
03:56:50 <SamB_XP> but then I picked Mine from the dropdown anyway and clicked okay and my titlebars are un-garbaged again ;-)
03:57:34 <kamatsu> one more thing, i was attracted to bamboo because it is haskell and it's powered by text files. I keep a text file diary which is why it appeals to me, i don't need to be online.
03:57:42 <lvh> Hi! I'm trying to find high performance network servers (or frameworks for writing them) in haskell. Is there anything I should look at besides HAppS?
03:58:23 <SamB_XP> lvh: well, what do you mean by high performance ?
03:58:25 <Axman6> lvh: what sort of server? just http?
03:58:33 <kamatsu> i was thinking i could perhaps use darcs to synchronize between my computer and the bamboo server
03:58:48 <lvh> Axman6: Hopefully not something protocol-specific, but HTTP would be a good start.
03:58:51 <kamatsu> but that might be overkill, perhaps just rsync? your thoughts.
03:59:04 <lvh> SamB_XP: 10k+ concurrent connections, not all of them necesarily busy.
03:59:07 <SamB_XP> lvh: we don't have a framework for servers in general, no
03:59:08 <jinjing> kamatsu: I keep db in a git repo, and just to git push, then merge.
03:59:13 <SamB_XP> hmm
03:59:23 <lvh> SamB_XP: And by 10k+, I mean 50k+.
03:59:25 <SamB_XP> can you have that many fds open in one process ?
03:59:26 <kamatsu> jinjing: what do you do with those .git directories?
03:59:34 <Axman6> lvh: i wouldn't imagine writing such things would be all that difficult really
03:59:44 <kamatsu> does it interfere in any way with bamboo?
03:59:49 <jinjing> kamatsu: what you mean?
03:59:51 * quicksilver doesn't think most TCP stacks support 50k+ connections
03:59:52 <lvh> Axman6: You'd think, but the only paper I've found uses thread-per-conn
03:59:58 <jinjing> kamatsu: no
04:00:00 <quicksilver> aren't port numbers 32 bit?
04:00:05 <kamatsu> jinjing: cool beans =D
04:00:08 <fasta> quicksilver: 16
04:00:11 <SamB_XP> lvh: that's not the part I'd worry about
04:00:13 <quicksilver> that's what I meant, actually :)
04:00:19 <lvh> Axman6: And like pretty much every thread-per-conn bit, it dies at 10k.
04:00:19 <SamB_XP> fasta: is that a real issue ?
04:00:21 <Axman6> lvh: what's wrong with that? haskell threads are very light weight, you can easily have thousands running at once
04:00:24 <lvh> Axman6: Errr, 1k connections.
04:00:35 <jinjing> kamatsu: also http://github.com/jgm/yst  is better suited for static site
04:00:36 <lvh> Axman6: The rest of the OS not being able to feed them, apparently.
04:00:37 <Axman6> have you tried?
04:00:41 <Jafet> If it dies at 10k+1, you've solved c10k!
04:00:41 <lvh> Axman6: Yes.
04:00:45 <Axman6> huh
04:00:52 <kamatsu> jinjing: this isn't static, but thanks
04:00:54 <fasta> SamB_XP: well, perhaps not now, but it will be in a few years.
04:00:58 <lvh> SamB_XP: I don't care what it does.
04:01:06 <lvh> SamB_XP: I want it to sit there and take 50k connections and not die.
04:01:09 <jinjing> kamatsu: np
04:01:16 <lvh> SamB_XP: If it can do that with threadperconn, I'm perfectly happy
04:01:28 <SamB_XP> I mean, can't it have jillions of connections on one port anyway, as long as they aren't from the same source address/port ?
04:01:34 <lvh> SamB_XP: right.
04:01:47 <lvh> the fact that there's only 65k ports is completely irrelevant :-)
04:02:01 <lvh> (no, we don't need one web server per user...)
04:02:13 <Axman6> lvh: do you have examples of applications that do actually do what you're after? sounds not too common
04:02:19 <lvh> quicksilver: Anyway, you can have 65k ports -- how is that relevant?
04:02:21 <lvh> Axman6: Twisted!
04:02:27 <lvh> Axman6: That's Python.
04:02:28 <SamB_XP> but, while the TCP stack can probably do that, I'm not sure about the logistics of having that many sockets open in one process -- how would you wait for the next input ?
04:02:31 <Axman6> @google twisted
04:02:46 <lambdabot> Plugin `search' failed with: thread killed
04:02:48 <lvh> Axman6: I'd love to write Haskell, but I'd like evidence the things that I want actually exist first :-)
04:03:01 <lvh> SamB_XP: Asynchronously!
04:03:06 <lvh> SamB_XP: Using kqueue/epoll.
04:03:15 <lvh> SamB_XP: On windows: You don't.
04:03:27 <Axman6> lvh: i'd say that it's most likely possible (and if not, someone will be able to fix things so it is possible)
04:03:32 <SamB_XP> hmm, I don't think GHC's RTS can use kqueue/epoll yet ?
04:03:48 <SamB_XP> JaffaCake: how hard would this be to get ?
04:03:57 <lvh> SamB_XP: again, if it can do it without kqueue/epoll I'm perfectly happy -- all I care about is it working
04:04:13 <SamB_XP> lvh: well, I'm doubtful if it would work yet :-(
04:04:19 <lvh> Axman6: Has anyone tried that? I'm sure Haskell is awesome, but people have found out the hard way that doing 10k+ connections is... hard
04:04:31 <lvh> SamB_XP: Yeah, that seems to be the conclusion I'm drawing too
04:04:36 <Jafet> You can pop over to #erlang and ask them
04:04:44 <SamB_XP> not that I think it would be fundamentally difficult
04:04:49 <Axman6> lvh: well, i'm no expert. there's _lots_ of people using haskell, and it's possible they have
04:04:51 <Cale> http://hackage.haskell.org/trac/ghc/ticket/635
04:04:52 <lvh> SamB_XP: there's a few async frameworks for Haskell that seem to be up to the task
04:04:59 <SamB_XP> hmm
04:04:59 <zygoloid> does the ghc rts' polling stuff use epoll or select?
04:05:02 <lvh> Axman6: right, that's why I'm here
04:05:13 <lvh> zygoloid: most likely select, but I'm not a ghc expert
04:05:32 <SamB_XP> lvh: you don't have to be much of an expert to be pretty sure it uses select() at the moment ;-)
04:05:37 <lvh> SamB_XP: unfortunately they seem to be mutually incompatible, and none of them have any evidence of doing significantly better than tpc
04:05:44 <lvh> SamB_XP: exactly ;-)
04:05:51 <SamB_XP> what are the system requirements for epoll()?
04:05:58 <lvh> SamB_XP: linxu2.6, basically
04:06:11 <SamB_XP> so you don't need any extra libraries?
04:06:22 * Axman6 has just finished writing an assignment using select
04:06:26 <lvh> SamB_XP: libevent, yes.
04:06:27 <Axman6> frigging C
04:06:34 <SamB_XP> oh :-(
04:06:39 <SamB_XP> that makes it harder
04:06:41 <lvh> SamB_XP: everyone that has 2.6 has that though, I wouldn't worry about it too much.
04:06:46 <SamB_XP> ah
04:06:49 <SamB_XP> okay, not so bad then
04:06:50 <fasta> If you want to know how high-performance it is, you will have to test it yourself, as I don't know of a nice benchmark which shows it.
04:07:03 <SamB_XP> lvh: in that case, it should be relatively easy to add support for epoll to GHC
04:07:03 <lvh> SamB_XP: it's a pretty tiny wrapper around the kernel level interface
04:07:38 <lvh> SamB_XP: yeah, I've been implementing it for other systems, epoll is pretty nice and kqueue isn't an eyesore either
04:07:44 <SamB_XP> you'd just need to add #ifdefs for it to the relevant portions of the RTS
04:07:51 <lvh> SamB_XP: however i was sort of hoping that other people would have done it before
04:08:03 <SamB_XP> the biggest problem would be the part where you have to wait for the next GHC release :-(
04:08:09 <lvh> Jafet: Right, I'm implementing it in Erlang OTP already -- I just wish Haskell had something like that.
04:08:24 <Cale> So... what actually happens when you create a simple network server in Haskell using the Network library and forkIO and try to connect 10k clients to it?
04:08:29 <Axman6> lvh: be that other person. if you ask specific questions, people will be able to help you along
04:08:38 <Cale> Does the program actually die?
04:08:45 <SamB_XP> Cale: I'm thinking select() falls on its face?
04:09:13 <SamB_XP> may not actually die, but it probably won't work too well
04:09:19 <Cale> run out of handles?
04:09:34 <Jafet> Probably grinds to a halt
04:09:35 <SamB_XP> no, just be unable to handle all the fds you throw at it
04:09:48 <lvh> Axman6: I don't understand. More specific than "Has anyone ever had 50k connections open successfully in a Haskell program, with a large number of low-throughput-but-still-not-asleep-connections?"
04:09:58 <lvh> HTTP would be fine.
04:10:09 <lvh> Jafet: Yes, typically those things die at 1000 to 2000 connections.
04:10:16 <SamB_XP> Axman6: well, and managed to read from any/all of them ;-)
04:10:28 <lvh> having 100k connections open is easy
04:10:31 <Axman6> yes, more specific than that. like, including code, actual problems
04:10:34 <lvh> doing anything at all with any of them is hard
04:10:54 <zygoloid> hmm... my system has a hard limit of 1024 file handles per process
04:10:55 <Jafet> I suspect the kernel itself would die at 50k connections
04:11:00 <Jafet> For typical values of kernel
04:11:02 <SamB_XP> Axman6: you can't write code to open that TCP connections and try to use them ?
04:11:03 <lvh> Axman6: Ah. The code in question is Python -- I'm not sure how to write the code in Haskell, because apparently kqueue/epoll selecting in ghc doesn't exist.
04:11:07 <SamB_XP> +many
04:11:14 <Axman6> SamB_XP: huh?
04:11:25 <lvh> Jafet: recent 2.6.xes do surprisingly well assuming you use epoll.
04:11:32 <Axman6> lvh: there's no reason it can't afaik
04:11:50 <SamB_XP> Axman6: read select(2) ;-P
04:11:54 <lvh> Axman6: http://www.haskell.org/~simonmar/papers/web-server.ps.gz
04:11:59 <Axman6> i know how to use select
04:12:04 <lvh> Axman6: Dies around 1k, which is typical for select-based tpc
04:12:08 <SamB_XP> Axman6: read about the limitations
04:12:22 <lvh> Axman6: the reason I'm here is to find out if anything signfiicant has changed since then that would make the conclusions of that paper no longer valid
04:12:33 <SamB_XP> like, isn't there a maximum fd # for any given select() implementation?
04:13:01 <lvh> SamB_XP: Can be worked around reasonably well.
04:13:41 <lvh> Unfortunately doing it is not easy, which is why projects that have been around for a long time that have already fixed all the gotchas and bugs are a good thing ;-)
04:13:46 <yitz> i have vague recollections of seeing JaffaCake discuss this issue on the mailing lists several times. the situation may be better than you think. has anyone actually tried this?
04:14:01 <fasta> dcoutts: there is not a single .pp source file in the gtk2hs source tree containing an #include directive.
04:14:02 <lvh> Axman6: completely different systems that use similar setups die around the same time, even with OS threads
04:14:08 <yitz> i.e., see how many clients can connect to a simple server before it dies?
04:14:17 <mmorrow> Cale: after 1024 fd's are handed out, open() just starts returning -1
04:14:31 <lvh> Axman6: mostly because the problem has absolutely nothing to do with CPU time and everything to do with select not being able to feed that many fds
04:14:40 <Axman6> yeah
04:14:59 <dcoutts> fasta: I think the build system must pass the include files on the cpp command line
04:14:59 <lvh> (well, it does have something to do with CPU time sometimes -- but not in userspace)
04:15:00 <mmorrow> wait, is the limit on account of the kernel or on account of select() ?
04:15:04 <zygoloid> woo EMFILE
04:15:11 <lvh> mmorrow: Both, if you're using select.
04:15:16 <SamB_XP> FD_SETSIZE*8
04:15:28 <lvh> mmorrow: That's why we have epoll/kqueue.
04:15:30 <mmorrow> lvh: right, but suppose that i'm not and i'm using open()
04:15:31 <SamB_XP> you can't select on more than that number of FDs
04:15:45 <Cale> Why do we have epoll/kqueue instead of a non-broken implementation of select?
04:15:47 <fasta> dcoutts: basically I want to include functions which use __FILE__ etc.
04:15:50 <SamB_XP> in fact, you can't select on any FD with a value higher than that -1
04:15:55 <mmorrow> lvh: right, but does epoll() somehow get around the limit to fd's that e.g. open() has?
04:15:55 <zygoloid> Cale: select's interface is broken
04:16:04 <SamB_XP> Cale: 'cause you can't make one
04:16:08 <lvh> Cale: because not breaking select turned out to be impossible to keep compatible with existing things
04:16:14 <mmorrow> lvh: like, are you even dealing in fd's with epoll?
04:16:14 <lvh> mmorrow: yes
04:16:20 <lvh> mmorrow: not internally
04:16:20 <Cale> hmm, okay
04:16:25 <SamB_XP> fd sets are fixed-size, the manpage says
04:16:25 <mmorrow> lvh: ah, ok
04:16:32 <lvh> mmorrow: anyway, the point is
04:16:35 <SamB_XP> you can obviously not change that without breaking stuff
04:16:42 <lvh> haskell is a high enough level language that we shouldn't have to care about this anymore
04:16:52 <SamB_XP> now, why we need *both* kqueue and epoll I'm not sure :-(
04:16:52 <lvh> mmorrow: "make me a connection listening thingy!"
04:16:56 <mmorrow> SamB_XP: they're int[2] iirc
04:17:00 <dcoutts> Cale: the problem with select is that you pass all the fds to the call, changing that means it is a totally different interface
04:17:05 <Jafet> kqueue for BSD and epoll for linux
04:17:10 <lvh> mmorrow: and it picks kqueue or epoll or select or whatever based on what's fastest on your system
04:17:19 <mmorrow> lvh: sure, like libev
04:17:21 <lvh> SamB_XP: because one's for bsds and the other for linux26
04:17:29 <SamB_XP> mmorrow: pretty sure they are a bit bigger than that on things more powerful than MINIX!
04:17:50 <Cale> dcoutts: and you pass them in a data structure which someone designed to be a fixed size?
04:17:51 <mmorrow> SamB_XP: i head they're ONE BIT on MINIX!
04:18:01 <mmorrow> *heard
04:18:31 <dcoutts> Cale: that's part of the problem, but it'd still be no good even if the data structure was more sensible
04:18:35 <mmorrow> SamB_XP: oleg says they're two ints (or maybe that was two longs..)
04:18:36 <Axman6> hmm, seems OS X supports poll and kqueue
04:18:50 <dcoutts> Cale: the problem is that passing in O(n) fds means that it has to check O(n) fds
04:18:55 <lvh> mmorrow: so I should use libev when writing this sort of thing in haskell?
04:19:12 <SamB_XP> dcoutts: oh, another good point
04:19:19 <lvh> Axman6: Snow Leopard has GCD! woo.
04:19:32 <dcoutts> Cale: where as what you want is something proportional to the number of fds that are actually ready
04:19:33 <SamB_XP> yes, it works a lot better if the kernel maintains an opaque thingy
04:19:35 <yitz> here's the ghc ticket for replacing select(): http://substack.net/posts/ea85c2/Happstack-on-Dreamhost-Notes
04:19:37 <yitz> ooops
04:19:37 <Cale> dcoutts: ah, right, because it doesn't give you a way to refer to collections of fds on which there may be events
04:19:41 <ivanm> lvh: yes, and that's the only good thing it has going for it :p
04:19:43 <SamB_XP> which you can add/remove FDs from using syscalls
04:19:44 <Cale> yeah
04:19:47 <Axman6> i've been thinking a blocks based version of select/kqueue/epoll would be awesome
04:19:52 <mmorrow> SamB_XP: the only reason i know that is because i stole his select() code from zfs (at the bottom) http://moonpatio.com/repos/lunabot/haddocks/src/Luna-Bot-Util-Dup.html
04:19:53 <yitz> here's the ghc ticket for replacing select(): http://hackage.haskell.org/trac/ghc/ticket/635
04:19:55 <lvh> ivanm: haha :-)
04:20:01 <SamB_XP> so it can keep the information you need at it's fingertips, so to speak
04:20:20 <Axman6> you could just have arrays of structs which contain a fd and a block to handle events on them
04:20:33 <dcoutts> Cale: right, so all the epoll/kqueue style things essentially make a kernel-side collection and let you add/remove from that collection and then wait on events becoming ready on fds in that collection.
04:20:50 <Cale> dcoutts: Why didn't select have that interface to begin with?
04:20:52 <Axman6> ivanm: you don't think OpenCL is useful?
04:21:02 <mmorrow> lvh: you can use libev (i tried http://moonpatio.com/repos/hsev/ ), but it not being a part of the rts (==> you can't use handles, or hPutStrLn, etc unless it is) is a total pita
04:21:08 <lvh> Cale: because nboody wanted 50k connections back then
04:21:12 <dcoutts> Cale: unix wasn't designed that cleverly :-)
04:21:12 <Cale> I guess.
04:21:16 <ivanm> Axman6: seeing as how I have no idea what it is, or whether it's actually new in SL...
04:21:26 <ivanm> Axman6: but whatever it is, can it compete with ghci not working? :p
04:21:41 <lvh> Cale: also select can be slightly faster than some epoll code for c < 10
04:21:45 <dcoutts> Cale: the unix APIs really focus on single threaded processes using blocking IO
04:21:58 <dcoutts> Cale: so select is a bit of an afterthought
04:22:03 <ivanm> oh, and gtk2hs not being buildable, and thus a lack of fancy charts in criterion
04:22:19 <lvh> the focus should have been on single threaded processes using non-blocking io! :-)
04:22:19 <mmorrow> lvh: so basically you have to write your own scheduler that implements blocking IO if you use libev and want to program in the same style as you would if it was in the rts and hooked to e.g. forkIO
04:22:28 <Axman6> ivanm: ... it's a platform agnostic GPU computation language, supported by all the major players, like nvidia, ATI/AMD, IBM, Intel etc
04:22:32 <lvh> mmorrow: yeah
04:22:36 <ivanm> *sigh* has anyone managed to get yi-0.6.1 to build?
04:22:37 <dcoutts> lvh: using lightweight/green threads
04:22:38 <mmorrow> lvh: which sux
04:22:42 <Axman6> ivanm: also, ghci works just fine for me
04:22:45 <lvh> mmorrow: I dont want to sound like a wimp but that sounds like something I dont want to do at all
04:22:54 <ivanm> Axman6: and it's OSX only?
04:22:57 <ivanm> Axman6: for 6.12?
04:22:58 <Axman6> no
04:23:02 <Axman6> and no
04:23:14 <Axman6> ivanm: you seriously haven't heard of OpenCL?
04:23:28 <ivanm> well, if it's not OSX only, then you can't use it as a feature of SL
04:23:37 <SamB_XP> remember, the internet didn't exist when the Unix file API was created ;-P
04:23:38 <ivanm> Axman6: I thought it was some fancy OSX lib; I had heard of OpenCL before
04:23:45 <Axman6> SL is the only OS that supports it yet
04:23:45 <ivanm> SamB_XP: heh
04:23:49 <ivanm> ahhh
04:23:57 <Axman6> http://en.wikipedia.org/wiki/OpenCL
04:24:12 <Axman6> http://www.khronos.org/opencl/
04:24:23 <kamatsu> jinjing: can't seem to get the highlighting middleware to do anything, yet i use the main function provided in the highlighter readme
04:24:32 <Axman6> it's a standard under the same group OpenGL is
04:24:41 <SamB_XP> actually, the number of FDs is just FD_SETSIZE ...
04:24:43 <SamB_XP> silly me ...
04:24:43 <lvh> wooo, khronos.
04:24:44 <Cale> lvh: Of course, the real answer is probably that we should just have support for it inside GHC.
04:24:53 <ivanm> Axman6: OpenCLRaw == OpenCL implementation for Haskell?
04:24:55 <lvh> Cale: right, agreed
04:24:58 <Jafet> The real question being, who's going to do it
04:25:01 <Cale> lvh: So that you just use forkIO and normal IO stuff and it just works.
04:25:05 <Axman6> ivanm: a binding to it
04:25:14 <lvh> Cale: in the python project i do workfor that does it roughly that way.
04:25:15 <ivanm> bah, Apple has trademark on it
04:25:26 <lvh> Cale: Except it doesn't try to look like it's multithreaded
04:25:46 <Cale> lvh: Let's all add CC's on that trac ticket and maybe someone will notice :)
04:25:51 <SamB_XP> and my /usr/include/linux/posix_types.h #defines __FD_SETSIZE to be 1024
04:25:52 <Axman6> ivanm: i thought someone looking to do a PhD would be far less narrow minded tbh :\
04:25:56 <ivanm> Axman6: well, windows seems to have libs, maybe not complete though
04:25:58 * mmorrow adds a CC
04:25:58 <lvh> Cale: that would be awesome! where do i sign
04:26:05 <ivanm> Axman6: narrow minded? :o
04:26:08 <Axman6> windows has drivers, but no compilers
04:26:11 <lvh> Cale: I always feel like a lame pos when I do things like that
04:26:12 <ivanm> ahhh
04:26:20 <lvh> Cale: "I want this but im not prepared to put any effort in"
04:26:20 <Axman6> "Oh Apple made it, it can't be good"
04:26:25 <Cale> http://hackage.haskell.org/trac/ghc/ticket/635
04:26:38 <ivanm> Axman6: nah, wasn't going like that
04:26:45 <ivanm> I was being obtuse for the sake of it
04:27:04 <Axman6> well quit it ;)
04:27:09 <ivanm> and if Apple made it, then it is most likely not going to be of any use to me, since I don't own or run a Mac
04:27:13 <yitz> how about this: http://hackage.haskell.org/package/epoll
04:27:14 <ivanm> Axman6: awwww.... :(
04:27:18 <ivanm> ;-)
04:27:21 <mmorrow> hopefully TRAC doesn't crash and accidentally all the tickets if we all add CCs at once
04:27:43 <SamB_XP> anyway, someone should report a bug about not having epoll support in the GHC RTS ...
04:27:45 <ivanm> Axman6: so you're saying that for windows and linux, the drivers for the graphics cards have library support for opencl... but nothing can compile it yet? :s
04:27:55 <mmorrow> Cale: hah, adding your email twice i see
04:27:58 <SamB_XP> oh, there's one already ?
04:28:07 <Axman6> something like that. nVidia and ATI are working on it
04:28:24 <Cale> mmorrow: whaat?
04:28:29 <Axman6> both of them already have all the tools for windows, just not released yet
04:28:53 <Cale> mmorrow: Does my email show up twice?
04:29:03 <SamB_XP> Axman6: how can they use that name and be like that ?
04:29:13 <Axman6> what?
04:29:16 <mmorrow> Cale: oh, i think either you or i accidentally duplicated/and/pasted the CC list..
04:29:20 <mmorrow> Cale: "oops"
04:29:48 <EnglishGent> @hoogle expand
04:29:48 <lambdabot> No results found
04:29:50 <mmorrow> oh, i'm an idiot
04:30:00 <mmorrow> changes CC list ....... to ..........
04:30:05 <mmorrow> nothing is in there twice
04:30:08 <SamB_XP> heheheh
04:30:22 <lvh> also, trac, ewww
04:30:26 <SamB_XP> that should probably use ->
04:30:34 <SamB_XP> lvh: yeah, well, what should we use instead?
04:30:36 <lvh> trac is one of those things that's terrible but we use anyway ecause every alternative is worse
04:30:49 <mmorrow> SamB_XP: someone should hax gitit
04:30:55 <SamB_XP> mmorrow: oh, shut up
04:31:05 <mmorrow> and make a blog too while they're at it!
04:31:11 <lvh> SamB_XP: yeah, that's what I mean
04:31:13 <yitz> in my browser, Cale appears twice on the CC list
04:31:35 <mmorrow> yitz: they sneak a "to" in there
04:31:36 <lvh> SamB_XP: Launchpad wouldn't be entirely terrible if you had your own mirror of it, I suppose.
04:31:42 <lvh> SamB_XP: then again: nobody's tried it
04:31:55 <yitz> ah, i see. haha.
04:32:18 <Cale> Oh, is that it?
04:32:20 <SamB_XP> I don't think launchpad would work very well for GHC
04:32:22 <Cale> I wasn't even looking there.
04:32:28 <EnglishGent> @hoogle rename
04:32:28 <lambdabot> Language.Haskell.TH.Lib rename :: Pat -> Q ([(Name, Name)], Pat)
04:32:28 <lambdabot> System.Directory renameDirectory :: FilePath -> FilePath -> IO ()
04:32:28 <lambdabot> System.Directory renameFile :: FilePath -> FilePath -> IO ()
04:32:28 <Cale> I was looking in the yellow box at the top
04:32:41 <SamB_XP> lacks customizable fields etc ...
04:37:03 <mm_freak> i have allocated an array of bytes via allocaBytes and now i'd like to make a ByteString out of a prefix of that array
04:37:27 <mm_freak> is there a way to do this without going through a String?
04:37:43 <Saizan> seen the .Internal module?
04:37:50 <mm_freak> not yet
04:38:18 <mm_freak> but looks promising
04:38:20 <mm_freak> thanks =)
04:40:49 <jinjing> kamatsu: need to give the source a hint
04:43:22 <mm_freak> Saizan: how do i convert an .Internal ByteString to a .Char8 ByteString?
04:43:46 <mm_freak> without copying, that is
04:45:51 <Saizan> they are the same
04:46:18 <Saizan> there's only 2 kinds of ByteStrings, the lazy and the strict ones
04:46:48 <mm_freak> oh, ok
04:47:45 <mm_freak> indeed, thanks
04:52:47 <ivanm> Saizan: well, you do have different encodings imposed upon them...
04:52:57 <ivanm> which I suppose is what confused mm_freak
04:53:10 <mm_freak> ivanm: nope, i just didn't know
04:53:18 <ivanm> heh
04:53:21 <kamatsu> jinjing: yup, got it now
04:53:47 <mm_freak> ivanm: i always wondered why there is no easy way to convert between them
04:53:54 <mm_freak> now i know:  because they are the same =)
04:54:12 <ivanm> heh
05:00:50 <EnglishGent> @hoogle filterM
05:00:50 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
05:00:50 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
05:11:25 <jimi_hendrix> is there a builtin that tests for a value in a list
05:12:21 <dancor> :t lookup
05:12:22 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
05:12:31 <dancor> :t elem
05:12:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:12:55 <dancor> > 'x' `elem` "ajaxify"
05:12:56 <lambdabot>   True
05:13:50 <dancor> > bool "Word." undefined <$> 'x' `elem` "ajaxify"
05:13:51 <lambdabot>   Not in scope: `bool'Precedence parsing error
05:13:52 <lambdabot>      cannot mix `Control.Appli...
05:13:56 * dancor got too greedy
05:14:36 <dancor> :t if'
05:14:37 <lambdabot> Not in scope: `if''
05:17:01 <Twey> if' :: Bool -> a -> a -> a
05:30:00 <jystic> Twey: is if' defined anywhere?
05:30:14 <Twey> Inside lambdabot.  
05:30:22 <jystic> lol
05:30:25 <Twey> It's just if' p y n = if p then y else n
05:30:26 <ivanm> Twey: only inside @pl methiks
05:30:27 <ivanm> @type if'
05:30:29 <lambdabot> Not in scope: `if''
05:30:29 <Twey> Yeah
05:30:35 <jystic> so you just have to define it yourself if you want it
05:30:43 <Twey> Generally you shouldn't
05:30:59 <Twey> It's not particularly useful, as the possibilities go
05:31:16 <jystic> Yeah ok
05:31:41 <Twey> I recommend using chrisdone's HigherOrder package, which includes the ?? operator ((y ?? n) p = if p then y else n) which is much better for currying, as well as some other handy bits and pieces
05:32:20 <jystic> That looks quite nice
05:34:29 <Jafet> Dear me, a postfix operator
05:34:41 <Twey> Where?
05:34:43 * Cale wonders what the chances are that installing the windows version of mono with gtk inside this wine installation will be successful in getting this .NET program to run. We'll see, I guess :)
05:35:14 <Jafet> Well, it basically implements lambda truth but in postfix form
05:35:23 <Botje> if said .net program was not written to use winforms, you have a better than average chance of success
05:35:23 <Twey> Cale: 50% maybe?  :
05:35:31 <Twey> Jafet: It's an infix operator
05:35:49 <Twey> Botje: But they all are.
05:36:34 <Cale> ** ERROR **: implement type compare for 1b! aborting...
05:36:59 <Cale> lovely dialog box :P
05:37:23 <Twey> Heh
05:37:24 <Twey> Argh
05:37:42 <Cale> It's all in a bottle though, so I can blow it all away with no harm :)
05:42:57 <jystic> Twey: Some are WPF, that's even less likely :P
05:43:21 * Twey chuckles.
05:43:24 <ivanm> Cale: isn't bottle crossover terminology rather than wine?
05:43:38 <Twey> Wine bottle?
05:43:44 <jystic> lol
05:43:53 <ivanm> yeah, but I've normally heard it referred to as a wine prefix
05:48:26 <Cale> ivanm: Yeah, it's set using the WINEPREFIX environment variable. I still call it a bottle, I suppose because the page which originally recommended I do it did. I have a script which keeps all my wine bottles in one directory and makes them convenient to use.
05:49:46 * ivanm uses playonlinux for that
05:58:10 <EvilTerran> jystic, another approach i've seen is something to the effect of "True ?= x = Just x; False ?= x = Nothing; Just x ?! _ = x; Nothing ?! y = y"
05:58:51 <Twey> ivanm: Yeah, same 
05:58:55 <Twey> Handles it neatly
05:59:23 <EvilTerran> jystic, which (with the right fixities) lets you write "p ?= t ?! f" as in "p ? t : f" in C-likes, but the operators can also be useful on their owns
05:59:40 <Twey> EvilTerran: I can't se that being particularly useful for currying, though
05:59:50 <Twey> see**
06:00:29 <EvilTerran> Twey, eh, true. i'm just illustrating a bit more of the design space for if-like constructs in haskell :)
06:00:42 <Twey> Aye.  
06:01:26 <Twey> We could, of course, drop Bool entirely and just use Either.  ;)
06:01:43 <Twey> Lambda-calculus style!
06:02:23 <Taejo> EvilTerran: btw, your (?!) is fromMaybe
06:02:42 <jystic> EvilTerran: that's interesting too, i'm finding that as i learn haskell if/then/else seems a bit verbose and out of place
06:03:29 <Taejo> jystic: some people consider Bool a code smell. I wouldn't go so far, but I would say it's less used than in some other languages
06:03:55 <hackagebot> CPL 0.0.6 - An interpreter of Hagino's Categorical Programming Language (CPL). (MasahiroSakai)
06:04:07 <ddarius> I rarely use Bool and usually prefer to avoid it, e.g. by using Maybe instead.
06:04:47 <jystic> Taejo: I'm only a Haskell newbie, but whenever I come across it, it seems awkward compared to everything else.
06:04:55 <Twey> Aye.
06:05:06 <ddarius> When you have predicates you tend to (have to) write code like, if somePredicate x then unsafeOperation x or if somePredicate x then wastefulButSafeOperation x
06:05:10 <PeakerWork> jystic: awkward as in "different" or awkward as in "more effort, longer, uglier"?
06:05:37 <quicksilver> code using Bool isn't very compositional
06:05:37 <jystic> PeakerWork: both
06:05:44 <quicksilver> whereas code using Maybe is
06:05:54 <quicksilver> although this is partly because there are more combinators for Maybe
06:06:01 <quicksilver> (which could, in some cases, be special-cased to Bool too)
06:06:06 <Taejo> ddarius: indeed. unsafeOperation is often better reformulated as maybeOperation
06:06:15 <PeakerWork> jystic: I think typically Haskell code is shorter and prettier. But I don't know if it takes less effort to write.  I still write Haskell a bit more slowly than I write other languages, I think, but I am much more pleased with the results
06:06:23 <quicksilver> having said that, I find bool useful and I use if/then/else occasionally
06:06:38 <Twey> @quote emission
06:06:38 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
06:06:38 <quicksilver> I use the language feature of guards, the MonadPlus method "guard" more often though.
06:06:45 <Saizan_> PeakerWork: he meant that using Bool in haskell feels akward
06:06:48 <PeakerWork> oh
06:07:36 <PeakerWork> "if else" in Haskell is annoying, yeah. I think in other languages its less annoying because the rest of the code is just as ugly :)
06:07:44 <jystic> Saizan_: that's right, I don't find Haskell awkward at all!
06:08:35 <Twey> Yeah, Bools are good in guards
06:08:54 <Twey> I guess it's if/then/else that's clumsy rather than bools in general.
06:09:08 <quicksilver> "guard" in the maybe monad is great for complication partial functions
06:09:13 <quicksilver> like moves in a game (which might not be valid)
06:09:18 <Twey> Aye
06:09:43 <quicksilver> do guard (piece belongs to me); guard (desired sqaure is empty); guard (loop rule not violated); return (new position)
06:10:01 <jystic> Twey: yeah, when I reformulated some of the stuff I had in to a guard it was much shorter and easier to understand
06:10:06 <Saizan_> that's why monad comprehensions would be nice
06:10:59 <quicksilver> probably although I don't find the explicit guard () annoys me
06:11:14 <quicksilver> and it might be a little easier on the eyes for people less familiar with the idiom
06:11:37 <PeakerWork> @src guard
06:11:38 <lambdabot> guard True  =  return ()
06:11:38 <lambdabot> guard False =  mzero
06:11:51 <PeakerWork> you want   guard x True = return x ; guard x False = mzero?
06:12:14 <Saizan_> no, why?
06:12:16 <EvilTerran> PeakerWork, wouldn't that just be "\x p -> guard p >> return x" with the current guard?
06:12:27 <quicksilver> I have occasionally wanted a shorthand for guard p >> return x
06:12:33 <PeakerWork> EvilTerran: yeah, I was trying to understand what quicksilver meant by "explicit guard ()"
06:12:41 <PeakerWork> I thought that meant:   guard () somePred
06:12:42 <quicksilver> PeakerWork: ah, that wasn't a () :: ()
06:12:49 <quicksilver> that was gaurd (long expression)
06:12:52 <PeakerWork> oh
06:13:01 <quicksilver> monad comps would make the word "guard" implicit
06:13:09 <PeakerWork> guard $ ....
06:13:29 <quicksilver> [ newPos | piece belongs to me, desired square is empty, loop rule not violated ]
06:13:47 <quicksilver> I was saying that having the word explicit doesn't bother me and may even aid readability.
06:14:40 <PeakerWork> yeah, when moving from Python to Haskell, I was disturbed about the lack of a word or anything in the guards
06:14:51 <PeakerWork> in Python list comps are:   [x for x in xs if someGuard for y in ys]
06:15:20 <PeakerWork> less appealing to mathematicians, but possibly less learning curve for others
06:15:28 <Twey> Heh, yes  Haskell LC syntax took some time for me to memorise, too
06:15:35 <Saizan_> i'm disturbed by the lack of punctuation in python comps :)
06:15:52 <quicksilver> the haskell syntax is straight from maths though
06:15:53 <ivanm> Saizan_: agreed
06:15:58 <ivanm> it's too verbose
06:16:05 <quicksilver> N = { x | x <- Z, x >= 0 }
06:16:18 * Twey chuckles.
06:16:18 <Saizan_> mainly i can't easily tell how it gets parsed into generators
06:16:18 <Twey> I like the visual effect of the | now I'm used to it.
06:16:29 <ketil> Sorry for the offtopicity: but does anybody know how the /(%  I get clock.h on my Ubuntu system?  It is nowhere to be found.
06:16:49 <Twey> The fact that pattern-matching extraction and boolean condition aren't distinguished is awkward to me, though
06:16:54 <ivanm> ketil: kernel sources?
06:17:02 <Twey> kernel-devel package?
06:17:02 <Saizan_> e.g. when i read "if someGuard for y in ys" it seems a single node to me, not two unrelated ones
06:17:06 <ivanm> that's where I seem to have mine...
06:17:13 <ketil> Okay, /me goes to look.
06:17:17 <ivanm> Twey: oh, right, the stupid -devel split of binary distros...
06:17:23 <Twey> Not all of them
06:17:45 <Twey> But yeah, it's a bit daft
06:18:23 <yitz> how do you use ghc-pkg to register a package manually, without cabal? do you use the package's cabal file? but then how does ghc-pkg know where to find files?
06:18:33 <ivanm> yitz: painfully
06:18:38 * Twey chuckles.
06:18:43 <dcoutts> yitz: it's straightforward
06:18:45 <ivanm> yitz: which is one reason why gtk2hs wont' be available for 6.12 anytime soon
06:18:48 <ivanm> IIRC
06:18:56 * yitz is trying to write a wiki page for remotely installing packages
06:19:09 <yitz> dcoutts: edit the cabal file to indicate the paths?
06:19:22 <dcoutts> yitz: the input to ghc-pkg is not a .cabal file
06:19:33 <dcoutts> yitz: it's the same format as ghc-pkg describe
06:19:38 <yitz> oh, so what is that file format. you have to write the whole thing by hand?
06:19:49 <dcoutts> yitz: you get Cabal to prepare the package registration file and then you register it using ghc-pkg register thefile.conf
06:20:11 <yitz> ah, ok. how do you convince cabal to create that for you?
06:20:34 <dcoutts> yitz: see cabal register --help and/or the Cabal user guide
06:20:38 <yitz> when you do cabal copy, does it spring into existence automatically?
06:21:20 <dcoutts> yitz: it provides two options, it can make a registration script, or it can make the package registration file itself
06:21:52 <yitz> for remote installation on a server, which do you think is better?
06:22:05 <dcoutts> doesn't matter
06:22:14 <yitz> which is default?
06:22:20 <dcoutts> there is no default
06:22:26 <yitz> ok
06:22:40 <dcoutts> yitz: the latter gives somewhat more control
06:22:54 <yitz> ok, I'll recommend that.
06:23:03 <ketil> ivanm, do I seriously need to install N megabytes of kernel source, just to get the (CPU-)time of day?  Really?
06:23:12 <dcoutts> yitz: it makes a difference if ghc-pkg on your $PATH is not the one you want to use
06:23:13 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11169#a11169  splits a lazy ByteString into a list of strict ByteString lines
06:23:24 <mm_freak> is this ok or can it be improved seriously?
06:23:25 <ivanm> ketil: do the kernel-devel package (or whatever it's called) if it exists like Twey recommended
06:23:31 <yitz> dcoutts: which may indeed be the case here
06:23:36 <ivanm> since you'd probably have to compile the source for it to be installed... >_>
06:24:04 <ketil> ivanm, there's something called kernel-headers, but it only contains clock.h deeply into weird directories like kvm and sched...
06:24:21 <dcoutts> yitz: though it had better be the same ghc version as on the builder
06:24:28 <ivanm> ketil: that could be it
06:24:44 <ivanm> ketil: the "weird directories" are probably where it's located ;-)
06:24:47 <yitz> dcoutts: yes, i've already required that for other reasons :)
06:24:54 <ivanm> once built and installed, that is
06:25:04 * Twey laughs.
06:25:11 <ivanm> iin the actual source, it's in the actual architecture directories
06:25:21 <ivanm> Twey: any particular reason?
06:25:28 <dcoutts> yitz: so make sure that the prefix you use is the one for the final destination on the server
06:25:47 <yitz> dcoutts: for cabal configure you mean. yeah.
06:25:50 <dcoutts> yitz: yep
06:28:00 <Twey> ivanm: I've found clock.h, but it's in a weird directory!
06:28:10 <ivanm> ahhh
06:33:23 <medfly> I have a feeling this channel discusses other languages more than it discusses Haskell
06:34:10 <ketil> ivanm, Twey: I got it now - thanks for helping out!  medfly: I'll stop now.  This was just an example to underscore the evils of imperativity.
06:34:20 <ketil> (Although include files might be considered functional?)
06:35:22 <medfly> oh... I'm just pointing out it's funny
06:35:25 <jkff> They're more like dysfunctional
06:36:57 <Twey> medfly: Hehe
06:37:15 <Twey> Yeah, include files are not functional by any stretch of the imagination.  :
06:45:03 <ketil> Twey, sure?  It seems related to reduciton systems.  By expanding terms, we reduce the orignal file towards some kind of normal form.  Or?
06:45:29 <EvilTerran> you *could* have a functional file-include system
06:45:34 <EvilTerran> but it'd be a bit unusual
06:45:37 <ketil> For instance: does the order of expanding #includes make a difference?
06:45:57 <EvilTerran> give files parameters and you'll effectively end up with an ML-like module system
06:46:30 <ketil> Parametric #include - I like it.  Suggest this for the C20xx committee!
06:46:41 <Twey> ketil: But C's include files are not so pure.  They involve essentially copying and pasting the file in question.
06:46:46 <ketil> The battle against C++ isn't lost yet.
06:47:15 <yitz> dcoutts: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package_remotely
06:48:38 <Cale> Let's convince them that integrating the C++ template system into the C preprocessor would be a good idea.
06:49:03 <dcoutts> yitz: I don't get the intro bit about it being easier to get a working ghc than an "entire usable Cabal build system set up"
06:49:24 <Cale> So you can have C++ templates which govern the expansion of macros :)
06:49:36 <dcoutts> yitz: it's not really relevant (and it's not clear it's true)
06:50:10 <Cale> Then, in a few years, they should be ready to switch to anything we put in front of them.
06:50:40 <dcoutts> yitz: the point is avoiding having to install ghc etc on the server and avoid having to compile things on the server (since many shared servers have limited ram)
06:51:24 <Twey> Cale: Hehehe.
06:51:32 <Twey> That's my plan for English.  :
06:52:06 <dcoutts> yitz: hmm, thinking about it, why are we installing libraries on the server? isn't it just to copy over a binary (+ related data files) that we want?
06:52:10 <ketil> Cale: the nice thing is that Haskell an area for trawling ideas for other languages.  We might get away with this.
06:52:26 <yitz> dcoutts: could be. though now we use shared libraries...
06:52:38 <dcoutts> yitz: doesn't matter
06:52:51 <ketil> Cale: is this channel logged?  Oops, I have to &% fs... fa /& h-lp th...cm.ng.
06:54:04 <dcoutts> yitz: so the first parts are still relevant, but it's not clear why users would want to register libs on the server. It's only useful if they want to build things on the server, which is what we were trying to avoid.
06:55:13 <dcoutts> yitz: the only use case I can imagine is a setup where you want to use the ghc api to do dynamic code loading from pre-registered packages.
06:55:15 <yitz> dcoutts: hmm, ok. in the case of the blog post, there wasn't any problem installing ghc itself, it was just difficult to get cabal to work because of the virtual environment.
06:55:32 <hackagebot> eprocess 1.0.0 - *Very* basic erlang-like process support for Haskel (FernandoBenavides)
06:55:34 <hackagebot> IOSpec 0.2.1 - A pure specification of the IO monad. (WouterSwierstra)
06:55:35 <dcoutts> yitz: no there was, he kept getting OOM errors
06:55:35 <yitz> but yeah, i guess we could just describe how to avoid ghc altogether. it's simpler.
06:56:02 <dcoutts> yitz: he was getting OOM errors when running ghc and linking because those things take a lot of ram
06:56:14 <yitz> dcoutts: in the end it worked though. there was also that /usr/bin/strip bug.
06:56:29 <dcoutts> yitz: which was also ghc, not cabal
06:56:32 <yitz> yes
06:56:49 <dcoutts> and we do not yet have a diagnosis for the last one
06:57:04 <yitz> anyway, yeah, it makes more sense to recommend skipping the compiler altogether.
06:57:35 <yitz> dcoutts: in that case, though, we don't need a wiki page.
06:57:53 <dcoutts> yitz: the initial part of the procedure is the same
06:58:04 <dcoutts> yitz: with cabal copy and then tarm upload and untar
06:58:13 <dcoutts> and getting the prefix right
06:58:19 <dcoutts> tarm/tar
06:58:45 <Veinor> dammit I need to set it up so I don't get pinged on Gnosis :|
06:58:49 <yitz> dcoutts: once you've set up your chroot or virtual, why not just compile and upload the exe?
06:59:28 <dcoutts> yitz: yes, that's what I was saying
06:59:33 <merijn> I take it rhe filename of a module should be the same as the module name?
06:59:39 <Liam_> Hello, back again with major headache... I was yesterday here and wrote that we should write a program for binary searchtrees. However I've got no background knowledge. Here is how far I've got: data IntTree1 = Leaf Int | Node (IntTree1, Int, IntTree1) deriving (Eq, Show, Read) -- data type , big1 :: Int -> IntTree1 big1 n = Node (big1 (2*n), n, big1(2*n+1)) -- non-ending recursive function... Now we should write a function prune1
06:59:41 <merijn> s/rhe/the/
06:59:56 <Liam_> And here I'm failing miserably, as I don't get it right how I could match the patterns :-(
06:59:58 <dcoutts> yitz: there's also the data files
07:00:43 <yitz> dcoutts: yeah, but all of that is nothing special about cabal, it's the same as installing any pre-compiled app on the server.
07:00:43 <dcoutts> yitz: doing the copy --destdir=image is the right way to make the deployable image
07:01:29 <dcoutts> yitz: that's true
07:01:51 <dcoutts> (which I guess is why we never had special documentation about it)
07:02:59 <yitz> dcoutts: i was thinking more about installing, let's say, binary, or whatever, to use with your ghc on the server, without having to make cabal jump through hoops in the virtual environment.
07:03:43 <dcoutts> yitz: yes that's one use case, though it's only useful for compiling further things.
07:05:56 <EvilTerran> merijn, yes, that's the convention
07:06:08 <EvilTerran> merijn, although it's only necessary if you want ghc --make, say, to be able to find it
07:06:25 <EvilTerran> (which you usually do, unless the project's only one file)
07:06:56 <merijn> EvilTerran: That's what I figured, but it's never explicitly mentioned in the tutorial I'm reading. Is the naming case sensitive too?
07:07:44 <EvilTerran> as i say, the file-name only matters to such things as ghc --make, as that finds files based on module names - that's probably why the tutorial doesn't mention it, it's not haskell, it's ghc
07:07:56 <EvilTerran> but I believe --make is case-sensitive, yes
07:08:03 <yitz> dcoutts: so should I refactor this to be creating an executable for a server using cabal? that limits it only to packages that create an executable - most things on hackage are libraries.
07:08:43 <merijn> EvilTerran: Ok, no real reason to use a different case for both anyway. Thanks
07:09:06 <yitz> i suppose people could cabalize (cabalise?) just for this purpose, but I think when not intending to publish you usually just ghc --make.
07:09:10 <dcoutts> yitz: I would say so. And yes must things on hackage are libs but those are not interesting to install on servers, only progs that use them.
07:09:41 <EvilTerran> merijn, indeed; i figure --make's convention is nice enough to be worth following even if you're not actually using --make :)
07:09:51 <dcoutts> yitz: if you think it's too trivial to be worth saying then fine
07:10:13 <yitz> dcoutts: is there an advantage to cabalize just to publish to your own server?
07:10:36 <dcoutts> yitz: I cabalise all non-trivial things, makes building reliable, reduces code rot.
07:10:46 * yitz nods
07:10:54 <dcoutts> yitz: what I wonder is why the person writing that post either didn't think of it, or did and had other problems.
07:11:25 <yitz> dcoutts: i think he preferred having ghc on the server. that's nicer if you can pull it off.
07:11:42 <aep> hmm are there any usable ncurses bindings? i can't find any docs for hscurses
07:12:10 <dcoutts> yitz: and in principle it should just work
07:12:25 <dcoutts> yitz: everything else is just bugs for which we need the details
07:14:40 <yitz> dcoutts: well, i'm out of time for today. i'll think about it again tomorrow. probably refactor as you said.
07:15:06 <dcoutts> 'k
07:18:11 <yitz> aep: there's also nanocurses, which is similar. looks like your supposed to use the haddocks together with the ncurses documention
07:18:22 <yitz> s/your/you're/
07:18:56 <jafet> curses is unusable
07:18:57 <Liam_> Anyone an idea how to write the prune1 stuff for the binary tree?!...
07:20:52 <dpratt71> if I want to experiment with some packages on Hackage, Cabal is the way to go, yes?
07:21:16 <sm> dpratt71: yup
07:21:31 <dpratt71> sm: ok, thanks
07:21:56 <dpratt71> anything I should know before trying to get Cabal running on a Windows system?
07:22:08 <sm> you'll want the haskell platform
07:22:25 <Saizan_> Cabal the library comes with ghc, cabal the executable with the haskell platform, yeah
07:22:28 <dcoutts> dpratt71: Cabal itself works fine but not all hackage packages work on windows
07:22:49 <hackagebot> hpage 0.3.1 - A scrapbook for Haskell developers (FernandoBenavides)
07:23:35 * sm guesses.. 90% ? will work
07:24:15 <dpratt71> I have a package "GHC 6.10.4" installed; I'm guessing that's not the platform
07:24:22 <Saizan_> no
07:24:33 <dpratt71> ok
07:24:43 <Saizan_> http://hackage.haskell.org/platform/
07:25:09 <dpratt71> Saizan_:  ah, very good, thanks
07:25:38 <Saizan_> the platform installer includes a ghc 6.10.4, not sure if you can tell it to use the one already installed
07:26:23 <dpratt71> Saizan_: I was thinking it might be wise to uninstall what I have
07:26:39 <Saizan_> that's also true
07:53:35 <fasta> Is there already a nice way to install Cabal on Linux?
07:54:01 <dcoutts> fasta: it comes with ghc so it's hard not to install
07:54:12 <dcoutts> or did you mean the 'cabal' program
07:54:23 <fasta> dcoutts: yes, 'cabal'.
07:54:40 <dschoepe> fasta: There's a difference between cabal-the-library and cabal-the-binary
07:54:40 <dcoutts> the cabal-install package has a bootstrap script
07:54:57 <fasta> dschoepe: I am aware of that.
07:55:02 <dcoutts> and the haskell platform includes cabal-install too
07:55:18 <fasta> dcoutts: there is no Haskell platform for Ubuntu, other than some unstable stuff.
07:55:29 <dcoutts> fasta: there's a generic unix tarball
07:55:40 <fasta> dcoutts: yes, I will use that one. Thanks
07:56:02 <Veinor> download the .tar.gz, run sh bootstrap.sh :D
07:56:07 <Botje> ubuntu karmic has a 6.10.4 ghc
07:59:20 <fasta> I was also missing libgmp3-dev on this particular machine, but it has become easier, which is good.
08:04:04 <hackagebot> hint-server 1.0.0 - A server process that runs hint. (FernandoBenavides)
08:05:48 <Jedai> Hello, is there someone here that can explain how to generate an Event from an IO action in Reactive, I don't really see how to do that (the type of System.Reactive.Internal.TVar.makeEvent don't help me)
08:06:01 <RDex> hello room
08:06:05 <RDex> good morning perhaps
08:06:22 <RDex> i am trying a basic function 'let a = 1' and i keep getting an error
08:06:26 <RDex> "unexpected end of input
08:06:28 <RDex> "
08:06:58 <medfly> odd, how are you doing this?
08:07:03 <Beelsebob> RDex: lets are expressions
08:07:03 <RDex> hi medfly
08:07:11 <sproingie> is there some command line option I can use for ghci to tell it to prefer one package over another?
08:07:17 <sproingie> Could not find module `Control.Monad.State': it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
08:07:22 <Beelsebob> they must include a result
08:07:24 <Beelsebob> let a = 1 in *what*?
08:07:24 <RDex> Hugs> let a = 1
08:07:25 <sproingie> if that's not the most irritating behavior ever...
08:07:26 <Beelsebob> > let a = 1 in a + 5
08:07:27 <lambdabot>   6
08:07:35 <RDex> oh, I need an in to go with it
08:07:36 <Beelsebob> > let a = 1
08:07:37 <lambdabot>   not an expression: `let a = 1'
08:07:42 <Beelsebob> RDex: right
08:08:04 <Beelsebob> RDex: to define values for all eternity, put them in a .hs file, with no let
08:08:12 <RDex> the learnyouahaskel site is not clear
08:08:16 <RDex> "# ghci> let lostNumbers = [4,8,15,16,23,42]  "
08:08:19 <RDex> works for them
08:08:34 <Beelsebob> random
08:08:37 <jystic> let a = 1 seems to work with ghci
08:08:44 <Beelsebob> oh yeh
08:08:52 <Beelsebob> ghci treats its input as one monadic session
08:08:54 <Beelsebob> so you can use let a = 1
08:09:00 <RDex> how do i enable ghci?
08:09:01 <RDex> i dont know what that is
08:09:04 <Beelsebob> and it assumes you mean let a = 1 in all following expressions
08:09:08 <sproingie> RDex: the 'ghci' command
08:09:10 <Beelsebob> RDex: ghci is an alternative to hugs
08:09:11 <Jedai> sproingie: there are three solutions
08:09:18 <jystic> ghci is another interpreter like hugs
08:09:29 <Beelsebob> RDex: you need to download ghc to get it (haskell.org/ghc)
08:09:33 <RDex> i am just using hugs
08:09:37 <RDex> oh
08:09:45 <Beelsebob> RDex: Id personally recommend using ghci instead of hugs
08:09:50 <Beelsebob> it gives much better error messages
08:09:53 <Beelsebob> and is a lot faster
08:09:57 <RDex> tell my teacher that
08:10:01 <RDex> *professor
08:10:04 <Jedai> sproingie: either you use the ImportPackage extension, or you specify the package to use on the command line, or you hide (with ghc-pkg) one of the package that conflict
08:10:08 <Beelsebob> yeh, a lot of unis still seem to use hugs  no idea why
08:10:12 <RDex> Beelsebob: hugs is very unintuitive
08:10:14 <fasta> sproingie: hide-package
08:10:25 <jystic> RDex: especially if you're following a tutorial which is also using ghci
08:10:44 <jystic> RDex: it's always nice when you get the same results as the tutorial :)
08:10:49 <sproingie> Jedai: yah i hid one before.  will hiding still keep it accessible to cabal recipes that specifically ask for it?
08:10:52 <Jedai> sproingie: the third solution had the advantage that you won't need to to do it over and over
08:10:59 <RDex> jystic, yeah. i could use a hugs tutorial then.
08:11:13 <fasta> I don't think a lot of tutorials depend on ghc in this way.
08:11:15 <sproingie> it'd be nice if hugs was still maintained
08:11:17 <Jedai> sproingie: Yes, the cabal package specify which dependency they want exactly
08:11:19 <Beelsebob> RDex: fewer exist, and they arent as good as learn you a haskell
08:11:21 <Saizan_> sproingie: you can use -hide-package
08:11:25 <RDex> sproingie yeah.
08:11:45 <sproingie> Jedai: ah cool
08:11:50 <RDex> how would i define a list with let
08:11:56 <Jedai> sproingie: so they hide everything and show only what they need, your settings won't have any influence on them
08:12:02 <sproingie> guess i should hide monads-fd since mtl is more commonly used
08:12:13 <Jedai> Jedai: let xs = [1, 2, 3]
08:12:21 <RDex> okay
08:12:23 <Beelsebob> RDex: the easiest way to define new things on the fly in hugs is to load an empty haskell file
08:12:36 <Beelsebob> and put your definitions in there, reloading as you go
08:12:47 <Jedai> RDex: or let xs = [1..] for an infinite list... ;)
08:12:48 <RDex> Jedai, i need an 'in' statement apparently in hugs
08:12:48 <RDex> Beelsebob: yeah, i am familiar with that
08:13:01 <RDex> Beelsebob: but right now i just need to know what things cause errors and what doesn't
08:13:09 <sproingie> that's right, i don't think hugs lets you bind new stuff at top level
08:13:20 <Beelsebob> RDex: well, one thing that creates an error is an incomplete expression ;)
08:13:22 <Jedai> RDex: ghci is just better now... Well I guess you don't really have a choice
08:13:41 <RDex> Jedai: I dont really have a choice, just a few hours to familiarize myself with hugs
08:13:43 <RDex> Beelsebob: so the opening and closing a new file then loading just takes too long
08:13:52 <RDex> then i'll take the midterm and then I dont think we'll stillb e on  haskell anymore
08:14:01 <Beelsebob> RDex: open a .hs file
08:14:04 <Beelsebob> leave it open
08:14:05 <sproingie> seriously i would just go with the .hs file
08:14:11 <Beelsebob> each time you edit it
08:14:13 <RDex> ok ok
08:14:14 <Beelsebob> type :r in hugs
08:14:16 <sproingie> even with ghci
08:14:24 <Beelsebob> and itll reload the definitions
08:14:25 <RDex> i'll pass, i need to know what things hugs can do
08:14:31 <Jedai> Hello, is there someone here that can explain how to generate an Event from an IO action in Reactive, I don't really see how to do that (the type of System.Reactive.Internal.TVar.makeEvent don't help me)
08:14:39 <RDex> Beelsebob: if i open it with the edit command in hugs, hugs won't let you interact with hugs until you close the text file
08:14:46 <sproingie> with emacs, i just hit ^C^L and it reloads the buffer in ghci
08:15:00 <sproingie> (now if only i could figure out a way to give the ghci frame focus)
08:15:06 <RDex> Beelsebob: o u mean load it with my own text editor instead of through hugs
08:15:07 <Beelsebob> RDex: right, so dont...
08:15:18 <Beelsebob> vim file.hs & hugs file.hs
08:15:33 <Beelsebob> (well, with spawning an extra window)
08:17:20 <RDex> opened the file manually with notepad
08:17:48 <sproingie> there are probably better editors to be using for haskell source
08:18:01 <sproingie> Notepad++ will at least colorize it
08:18:22 <Botje> sproingie: c-x o
08:18:59 <sproingie> Botje: that's for a window, not a separate frame, and the idea is to keep from having to switch manuallty
08:19:00 <RDextreme> okay i'm back
08:19:00 <RDex> this works
08:19:06 <RDextreme> wow serious lagging out
08:19:21 <Botje> sproingie: oh. i thought windows contained frames instead of the other way round. never mind :)
08:19:34 <RDextreme> how do I put a list "in"
08:19:34 <sproingie> Botje: right now it raises it but doesn't give focus.  maybe i just need to tell it to switch to the buffer.  last time i did it, it still switched the wrong window
08:19:35 <RDextreme> something
08:19:46 <sproingie> Botje: yeah emacs reverses the terminology for some godforsaken reason
08:19:55 <Beelsebob> RDextreme: what would you like to put it in?
08:19:59 <Botje> those parens-loving commie bastards. :)
08:20:27 <RDextreme> RDextreme, I want to put it 'in' something so that hugs doesn't give me an error for only having a 'let'
08:20:38 <sproingie> using ADD mode in compiz helps
08:20:47 <RDextreme> Beelsebob:
08:20:51 <Beelsebob> RDextreme: okay, well, what would you like to evaluate?
08:20:56 <Botje> RDextreme: "myList = [...]" put that in your .hs file
08:20:59 <Beelsebob> > let xs = [1,2,3,4,5] in xs
08:21:00 <lambdabot>   [1,2,3,4,5]
08:21:06 <Beelsebob> > let xs = [1,2,3,4,5] in xs ++ [9,8,7,6]
08:21:07 <lambdabot>   [1,2,3,4,5,9,8,7,6]
08:21:09 <Botje> RDextreme: if you load it with hugs, you can then access it by the name myList
08:21:35 <sproingie> actually what'd be cool is if ghci had an auto-reload mode
08:21:42 <sproingie> where it would reload the file every time it changed
08:21:46 <Beelsebob> it would be
08:21:52 <Beelsebob> unfortunately, only on OS X is that possible
08:22:06 <Beelsebob> neither windows nor linux are capable of reliably notifying when a file changes
08:22:06 <Botje> why?
08:22:13 <Botje> i thought FAM was meant for that?
08:22:15 <sproingie> Beelsebob: totally false
08:22:16 <Saizan_> inotify?
08:22:22 <Beelsebob> you have to poll on them
08:22:22 <Botje> or inotify
08:22:24 <Beelsebob> I guess you could always poll just before evaluating an expression
08:22:25 <sproingie> you do not
08:22:28 <sproingie> not on either OS
08:22:49 <sproingie> linux has dnotify, windows has something built in to the win32 api whose name escapes me
08:23:25 <Zao> Windows has a stellar API for it, which even works over network redirectors.
08:23:40 <RDextreme> unexpected let - error
08:24:04 <sproingie> main thing is *unix* doesn't have a reliable portable change notification mechanism.  every one does it different.  inotify is great ... for linux
08:24:33 <sproingie> anyway even falling back to polling wouldn't be so bad
08:24:48 <Zao> http://msdn.microsoft.com/en-us/library/aa364417(VS.85).aspx <- that one, I believe.
08:24:51 <Beelsebob> especially given that you have predefined times to poll sproingie
08:25:00 <Beelsebob> oh, you want to evaluate something so Ill reload files
08:25:19 <sproingie> yah, in true haskell tradition you could do it lazily
08:25:27 <Beelsebob> uhhuh
08:25:36 <Zao> Erm, http://msdn.microsoft.com/en-us/library/aa365465(VS.85).aspx
08:25:59 <Beelsebob> might be a tad slow but it would save endless problems in lessons with students not reloading their source
08:27:46 <RDxtreme> this wireless sucks
08:28:03 <sshc_> this wired sucks
08:31:09 <RDxtreme> how come hugs doens't like what i put in the notepad file
08:31:52 <falkenh> im trying to install xmonad-contrib with cabal but im getting this error cabal: The pkg-config package xft is required but it could not be found.
08:31:52 <falkenh>  
08:32:02 <Beelsebob> RDxtreme: did you start the line with let?
08:33:35 <EnglishGent> why cant I do this?
08:33:35 <EnglishGent> rassoc y [] = Nothing
08:33:35 <EnglishGent> rassoc y [(x,y):z] = Just x
08:33:35 <EnglishGent> rassoc y [(x,_):z] = rassoc y z
08:33:49 <EnglishGent> I get an error about 'conflicting definitions for y'
08:34:09 <sproingie> the second pattern will always match what the third does
08:34:11 <Berengal> EnglishGent, you can't define the same variable twice. It can't bind two values to a single name
08:34:12 <mux> the two last lines pattern match the same thing
08:34:35 <sproingie> you probably want to use guards instead of a pattern
08:36:40 <EnglishGent> but I thought patterns where tested top to bottom - so it shouldnt matter if the 2nd one matches everything the 3rd one matches
08:36:49 <sproingie> well you have two problems
08:36:56 <sproingie> the second pattern by itself isn't legal
08:37:22 <sproingie> pattern match variables are being bound, they won't substitute a previously defined value
08:37:28 <sproingie> you want a guard to do things like that
08:37:30 <RDex> hi again, in hugs how do I switch to static scoping
08:37:50 <Botje> RDex: *blink* ?
08:37:52 * EnglishGent tries re-writing it with guards :)
08:38:04 <sproingie> haskell is very much statically scoped out of the box
08:38:15 <hackagebot> hpage 0.3.2 - A scrapbook for Haskell developers (FernandoBenavides)
08:38:18 <jystic> what is the preferred way of using sending/receiving UDP packets in haskell?
08:38:24 <jystic> network-data?
08:38:28 <RDex> I have a function that is supposeded to be evaluated differently if dynamic scoping is used vs static scoping
08:38:34 <sproingie> jystic: Real World Haskell has a UDP example i think
08:38:34 <tumult> threadDelay from Control.Concurrent uses far more cpu than usleep from System.Posix.Unistd.. is this normal?
08:38:50 <jystic> sproingie: thanks, i'll take a look :)
08:38:56 <tumult> when sleeping for small times like 100 microseconds
08:38:59 <sproingie> http://book.realworldhaskell.org/read/sockets-and-syslog.html
08:39:03 <sproingie> UDP example in there
08:39:26 <jystic> :) i didn't get to chapter 27 yet
08:40:01 <sproingie> it's not really introducing new concepts at that point
08:40:13 <sproingie> short chapter anyway
08:40:54 <sproingie> tumult: could be threadDelay is implemented as a spinloop?
08:41:10 <sproingie> not sure, just guessing
08:41:10 <tumult> maybe
08:41:18 <jystic> yeah i stopped reading halfway through ch23 (gui)
08:41:29 <tumult> i think if i threadDelay for a long period of time, it doesn't happen
08:41:40 <jystic> i thought i would try and experiment a bit with some things before continuing
08:41:40 <tumult> i think it is doing some kind of context switching stuff
08:41:49 <dcoutts> falkenh: you do not have the devel variant of the xft system package installed
08:42:00 <tumult> if i use yield from Control.Concurrent it will actually idle lower in an loop
08:42:19 <tumult> would usleep be the preferred way to make a runloop/eventloop in haskell on posix?
08:43:58 <dcoutts> tumult: you don't want to sleep, you want to block until the next event is available
08:44:15 <dcoutts> you don't want to be doing polling
08:44:19 <tumult> well i am the one generating the events :) i am outputting to some weird serial hardware
08:44:30 <tumult> there is no feedback from it
08:45:48 <dcoutts> tumult: if the output device requires some minimum wait between sending it events then sure use threadDelay
08:46:02 <tumult> i write packets to it at 40hz, the accuracy needs to be within some 30k microseconds between any two packets
08:46:17 <RDex> hi , with g :: [Float] -> (Float -> Float -> Float) -> Float
08:46:18 <tumult> yeah i was using threadDelay to idle the thread between packets but it chewed up cpu badly
08:46:24 <RDex> g x y  = foldr y 1.0 x
08:46:29 <RDex> how do i call this from the command line
08:46:29 <tumult> 100% on one core and 25% on another
08:46:38 <RDex> do i put in a list of floats
08:46:58 <tumult> with usleep it's just 6% on one core
08:47:08 <tumult> (this is with a forkOS thread)
08:47:23 <dcoutts> tumult: that seems odd, and quite possibly worth a bug report
08:47:33 <RDex> hmmm
08:47:42 <dcoutts> tumult: for the same delay the overhead should be similar
08:47:47 <tumult> yeah it seemed like a lot, like maybe it was doing some extra work
08:47:49 <falkenh> dcoutts: thanks, works now
08:47:54 <tumult> since another core was apparently doing stuff too
08:48:13 <dcoutts> tumult: it could be doing a GC when it thinks it is idle, but in your case it's never really idle
08:48:14 <tumult> the main thread in the program is running the gtk2hs event loop
08:48:50 <dcoutts> tumult: oh then you'll have very little guarantee on the scheduler jitter
08:49:04 <tumult> yeah that is why i did a forkOS
08:49:10 <dcoutts> that will not help
08:49:27 <tumult> gtk2hs' event loop has low granularity so i made my own
08:49:43 <dcoutts> it will not help because when one is running the other is not
08:49:43 <tumult> it doesn't help?
08:50:05 <tumult> they block each other?
08:50:07 <dcoutts> so when the GUI is running stuff then your other thread is not
08:50:15 <tumult> even with -threaded?
08:50:22 <dcoutts> tumult: there is only one running Haskell thread per capability
08:50:39 <dcoutts> you can use multiple capabilities with +RTS -N2
08:50:58 <tumult> great, i don't know what a capability is :)
08:51:08 <dcoutts> it's the capability to run Haskell code
08:51:17 <tumult> i see
08:51:39 <tumult> so even though it's creating more logical threads, it will pause them and only let one run at a time?
08:52:03 <dcoutts> each Haskell capability multiplexes multiple lightweight Haskell threads
08:52:24 <tumult> ah
08:52:33 <dcoutts> which is usually fine, but you need more precise deadlines
08:52:43 <tumult> i thought forkOS was what explicitly made a new one, someone told me that before
08:52:46 <dcoutts> and you'd like to be able to pre-empt the UI etc
08:52:50 <tumult> even though the docs on it didn't say that
08:53:01 <dcoutts> tumult: it makes a new OS thread, not a new capability
08:53:10 <tumult> yeah
08:53:46 <EnglishGent> hmm - I've tried switching to pattern guards as:
08:53:52 <EnglishGent> rassoc k [] = Nothing
08:53:52 <EnglishGent> rassoc k [(x,y):z] | (k == y) = Just x
08:53:52 <EnglishGent> rassoc k [(x,y):z] | (k /= y) = rassoc y z
08:53:55 <dcoutts> tumult: I suggest you post your use case to the ghc users list, describe your deadline/scheduler requirements
08:54:16 <tumult> cool i will do that
08:54:17 <EnglishGent> but now I get some type error about couldnt match expected type (a,a1) against inferred type [(a,a1)]
08:54:19 <dcoutts> tumult: and the fact that you wish to run a GUI in the same process
08:54:28 <dpratt71> it seems to me that Haskell could be a particularly good fit for a web framework; are there any packages out there that someone would recommend for this purpose?
08:54:32 <tumult> i'm porting this over from a c application i wrote some time ago
08:54:41 <dcoutts> tumult: in the mean time, you might find that a dedicated output program works better
08:54:43 <tumult> well rewriting, port is a bad way to say that
08:54:46 * EnglishGent doesnt see why the problem :|
08:54:56 <BONUS> EnglishGent you probably mean reassoc k ((x,y):z)
08:55:04 <dcoutts> tumult: that buffers output and sends it to the physical device with the appropriate timing constraints
08:55:07 <tumult> yeah i was considering running two processes and using inter-process communication
08:55:17 <tumult> since that's how it works in my c version
08:55:23 <dcoutts> tumult: seems like it'd be more reliable
08:55:23 <tumult> c daemon and c++ gui frontend
08:55:34 <ludflu> dpratt71: I was looking at http://happstack.com/
08:55:43 <dcoutts> tumult: right, so start by changing the c++ gui frontend to a Haskell one
08:55:51 <dpratt71> ludflu: I'll give it a gander also, thanks
08:56:08 <dcoutts> tumult: and maybe you can convert the output writer prog to a single-threaded Haskell prog
08:56:11 <tumult> well i was going to redo the protocol as well :)
08:56:15 <Saizan_> EnglishGent: the problem is probably the square brackets
08:56:19 <tumult> i wanted to do a clean break over the old design
08:56:47 <dcoutts> tumult: check if you can make a really simple single threaded output writer in Haskell
08:56:53 <tumult> well, one of them will need to be parallel, or i'll need a third application
08:56:59 <tumult> since it does a lot of number crunching
08:57:14 <tumult> this is for controlling stage lights via dmx
08:57:20 <RD> okay i'm on a better connection now
08:57:25 <tumult> kind of like midi for lights
08:57:25 <RD> say i have an expression inhaskell d:q
08:57:34 <RD> that does d:q represent
08:57:42 <dcoutts> tumult: but the output stage will be single threaded right?
08:58:08 <tumult> yeah i can structure it that way
08:58:27 <tumult> or concurrency constructs can let me
08:58:45 <tumult> the serial devices are the only things that really block when writing
08:58:52 <tumult> the network ones are instant
08:59:03 <RD> Beelsebob: still in/
08:59:04 <dcoutts> tumult: having that stage have no other Haskell threads running should give you lower scheduler jitter
08:59:11 <EnglishGent> ah - that works! thanks! :)
08:59:12 <RD> ?
08:59:21 <tumult> the jitter is actually fine right now
08:59:35 <tumult> dcoutts: though i don't have gtk2hs doing anything yet really
08:59:40 <tumult> so maybe it would get worse
08:59:48 <dcoutts> tumult: right, it'd make me nervous
09:00:12 <tumult> but +RTS -N2 would run with another capability?
09:00:17 <RD> can anybody help me with some haskell basics/
09:00:25 <RD> i am using hugs and these errors are unintuitive
09:00:29 <dcoutts> tumult: yes but you get no control over which Haskell threads run on which capability
09:00:51 <tumult> oh
09:01:02 <tumult> so the runtime will do whatever it feels is convenient then
09:01:19 <tumult> there's no way to explicitly fork some action into a real thread?
09:02:10 <arsenm> tumult: I think there's a forkOS or something like that
09:02:44 <tumult> yeah that's what i'm using, but apparently that still leaves it in control of the scheduler? or not
09:05:02 <copumpkin> tumult: well, you have a thread that's guaranteed to be on a separate OS thread if +RTS -Nx provides enough of them, I think
09:05:10 <quicksilver> forkOS doesn't do what most people think it does
09:05:14 <copumpkin> it's usually only needed to guarantee a thread for some FFI thing that needs it
09:05:32 <quicksilver> people say all kinds of things about forkOS
09:05:32 <copumpkin> but maybe it doesn't do what I think it does either, as quicksilver says :) /me defers
09:05:37 <quicksilver> they're almost all wrong :)
09:05:45 <tumult> well, i need a thread won't be interfered with by the gtk2hs event loop on the main thread
09:05:49 <Botje> forkOS ran over my dog!
09:06:12 <quicksilver> it forks a haskell thread which is "bound" to a fixed OS thread
09:06:22 <quicksilver> it doesn't stop other haskell threads being scheduled on that OS thread
09:06:31 <quicksilver> but it does guarantee that *it* is never run on a different OS thread
09:06:47 * copumpkin claims that is what he meant just now O:-)
09:06:50 <quicksilver> if some other haskell thread is currently "occupying" its OS thread, it will just wait until it's free.
09:06:52 <tumult> ah i see
09:06:57 <RD> copumpkin: you in?
09:06:59 <dcoutts> and in particular it gives no more concurrency of evaluation of Haskell code
09:07:10 <quicksilver> it's intended so you can call a C library which uses thread-local state
09:07:13 <copumpkin> RD: ?
09:07:15 <EnglishGent> beh.. it still doesnt behave as I expect it to rassoc 2 [("hello",3),("goodbye",2)] yields Nothing - whereas I expected it to yield just "goodbye"
09:07:17 <quicksilver> and guarantee it stays in the right place.
09:07:21 <copumpkin> allo allo EnglishGent
09:07:28 <RD> copumpkin:  I am still trying to get the basics of haskell using hugs
09:07:34 <EnglishGent> rassoc 3 rassoc 2 [("hello",3),("goodbye",2)] *does* yield Just "hello"
09:07:37 <RD> copumpkin: can you tell me what the expression d:q does
09:07:40 <EnglishGent> hi copumpkin :)
09:07:41 <copumpkin> RD: why hugs?
09:07:46 <dcoutts> quicksilver: I'm not sure that other Haskell threads to get scheduled on the bound thread's OS thread
09:07:49 <dcoutts> to/do
09:07:51 <RD> copumpkin: because thats what the professor is using
09:07:53 * copumpkin gives RD a big hug and then steals hugs from him and replaces it with ghc
09:07:58 <tumult> well, i don't depend on any thread-local state
09:08:05 <RD> copumpkin: lol i've already had that lecture from your fellows here
09:08:14 <dcoutts> tumult: you almost certainly do not need forkOS
09:08:15 <copumpkin> tumult: that's why most people don't actually need forkOS
09:08:22 <copumpkin> RD: mine is better
09:08:28 <copumpkin> RD: tell your prof to get with the times
09:08:29 <copumpkin> :P
09:08:32 <RD> copumpkin: can you tell me what the expression d:q does?
09:08:33 <mmorrow> the only thing i know that does is OpenGL
09:08:37 <tumult> i just need a thread that won't be interfered with by gtk2hs' event loop
09:08:51 <copumpkin> RD: nope, I've never actually used hugs, because I only started haskell a few months ago
09:08:59 <copumpkin> (and I don't use outdated tools :P)
09:09:06 <dcoutts> tumult: and I don't think we have any way to guarantee that at a fine scheduling granularity.
09:09:10 <RD> copumpkin: i figured most of the expressions are normal haskell
09:09:20 <copumpkin> d:q doesn't look like anything I've seen
09:09:24 <RD> oh
09:09:31 <Saizan_> well, it could be a list
09:09:44 <copumpkin> true that
09:09:46 <Saizan_> > let d = 1; q = [2] in d:q
09:09:47 <lambdabot>   [1,2]
09:09:52 <dcoutts> tumult: the Haskell threads are scheduled pre-emptively but it's limited to the scheduler timeslice
09:10:25 <tumult> so there is no way to break free of the haskell scheduler?
09:10:41 <dcoutts> tumult: yes, by having only one thread
09:10:59 <copumpkin> tumult: you could explicitly bind to libpthread with FFI and tread very lightly, maybe :P
09:11:06 <tumult> well then i need two processes :)
09:11:09 <tumult> haha
09:11:14 <tumult> that sounds like a very bad idea
09:11:26 <dcoutts> tumult: yes, that's what I was suggesting, a separate process for the output stage
09:11:36 <copumpkin> tumult: what's wrong with GHC's scheduler?
09:11:59 <dcoutts> copumpkin: tumult is writing to an output device that needs reasonably precise timings for output
09:12:00 <tumult> copumpkin: apparently gtk2hs can cause problems if i need strict timing?
09:12:06 <copumpkin> oh
09:12:10 <dcoutts> it's not gtk2hs as such
09:12:27 <tumult> if i deviate by more than 30k microseconds i will have problems
09:12:30 <dcoutts> it's any other thread, when you need wakeups that are more precise than the scheduler timeslice
09:12:32 <tumult> i can miss one occasionally
09:12:48 <tumult> but drifting around all the time causes certain types of light fixtures to throw fits
09:12:59 <copumpkin> light fixtures? this sounds interesting :o
09:13:09 <Igloo> Have you checked the GCer won't cause you problems?
09:13:19 <tumult> it might, someone brought it up before
09:13:30 <dcoutts> another reason to use a separate process
09:13:43 <tumult> if i run into that i was just going to have two processes, yeah
09:13:46 <copumpkin> does GHC's scheduler have any concept of thread priority?
09:13:50 <dcoutts> you can set its GC params independently and call performGC at times when you know it's ok
09:13:51 <Igloo> No
09:13:57 <dcoutts> copumpkin: nope
09:14:19 <Igloo> Or possibly keep the other process very simple, and write it in a language designed for RT
09:14:33 <tumult> yeah i have my original version in c
09:14:40 <dcoutts> copumpkin: and it cannot pre-empt Haskell threads with a very high precision since it depends on the active thread getting to a point where it needs to allocate more memory.
09:14:45 <tumult> using the mach kernel stuff for timing
09:14:53 <tumult> (i'm on os x)
09:15:08 <copumpkin> dcoutts: oh, the pre-emptive stuff kicks in on allocation only?
09:15:13 <copumpkin> I guess that makes sense
09:15:15 <tumult> i wrote my first ffi thing in haskell last night to get the mach kernel timing stuff
09:15:32 <copumpkin> mach_absolute_time!
09:15:37 <tumult> yep
09:15:44 <jfhall> anyone have pointers on how to test IO in Haskell?
09:15:45 <dcoutts> tumult: the combination of that and a single threaded process may well be fine
09:16:21 <copumpkin> tumult: you can probably set up your RT process to do almost no allocation whatsoever inside its main loop, to avoid GC
09:16:33 <tumult> is there a library for process creation and communication
09:16:46 <tumult> yeah it would not hardly ever need to create stuff, i think
09:17:34 <tumult> oops i was saying microseconds before, i meant nanoseconds :)
09:17:51 <dcoutts> heh, just an order of magnitude harder :-)
09:17:53 <copumpkin> :P
09:18:07 <dcoutts> an order, or three
09:18:11 <tumult> but it is working fine right now, but i'm not creating/destroying anything while it's running at the moment
09:18:22 <tumult> or doing anything with gtk2hs
09:18:30 <tumult> so it might blow up on me once i do
09:19:22 <dcoutts> tumult: so for IPC, I'd just use stdin in the output stage, and use the System.Process in the main prog to invoke the output writer, and set up the handle to talk to the process
09:19:55 <dcoutts> tumult: and compile the output stage without -threaded
09:20:16 <tumult> i see
09:21:46 <tumult> is there a reason to prefer that over named pipes?
09:24:50 <dcoutts> tumult: normal pipes are simpler and there's already a high level Haskell API
09:25:32 <tumult> cool
09:28:06 <en0th> could anyone explain me the difference between a thunk and a head normal form (in few words) ?
09:28:28 <leimy> Do we need liftIO anymore if we're using MTL?
09:28:36 <leimy> or does lift always suffice?
09:28:42 <quicksilver> liftIO is cleverer than lift
09:28:49 <leimy> that's what I was afraid of :-)
09:28:51 <saml> you can implement thunk as head normal form, i think
09:28:52 <quicksilver> liftIO is for IO operations with any number of levels deep
09:28:56 <quicksilver> lift is just one level
09:29:11 <quicksilver> in fact liftIO is always "lift . lift . lift . lift" for some number of lifts
09:29:16 <leimy> hmmm
09:29:18 <quicksilver> the clever part is, the type checker works out how many
09:29:18 <leimy> ok
09:29:24 <dcoutts> en0th: a thunk is not in weak head normal form, a value in weak head normal form is never a thunk :-)
09:29:35 <copumpkin> we need a smart lift for all monads
09:29:38 <dcoutts> saml: hmm?
09:29:54 <copumpkin> lift (undefined :: Maybe a) x
09:29:56 <leimy> I wonder if it makes sense to roll one's own monad when a stack of monad transformers starts getting out of hand.
09:30:02 <tumult> should have called liftIO hOIst :)
09:30:05 <leimy> sometimes the lifting is a little crazy
09:30:24 <sproingie> hoist would be an awesome function name for pirate-speak haskell
09:30:25 <leimy> and I often forget to do it until the compiler tells me I should have done it :-)
09:30:40 <leimy> Harrrrrskull!
09:30:49 <sproingie> YARR
09:30:57 <leimy> -- Shiver me timbers!
09:31:06 <dcoutts> en0th: more simply, a value in weak head normal form is evaluated, a value that is a thunk is not yet evaluated.
09:31:13 <saml> dcoutts i fail. i thought thunk is a referece to a box. derefernce, and get the value.  and head normal form is you can apply once to get normalized form
09:31:42 <saml> so, you do some thing one step to get the value
09:31:45 <dcoutts> saml: ah yes, boxing vs thunking :-)
09:31:49 <en0th> dcoutts: it's still difficult!
09:32:04 <en0th> heh ;(
09:32:15 <quicksilver> leimy: newtype MyM = VeryT (LongT (StackT (OfT (TransformersT( ....
09:32:18 <dcoutts> en0th: it's really just evaluated / not evaluated
09:32:19 <quicksilver> leimy: is the normal way to do it.
09:32:35 <quicksilver> and then give good names to the compound operations
09:32:36 <quicksilver> like
09:32:44 <quicksilver> myFoo = lift . lift $ foo
09:32:51 <quicksilver> myBar = lift . lift . lift . bar
09:32:52 <quicksilver> etc.
09:32:59 <en0th> dcoutts: so a normal form could be weak (evaluated) or not (a thunk) ?
09:33:02 <dcoutts> en0th: are you looking to try to understand it, or are you trying to write about it / explain it to others?
09:33:04 <quicksilver> then you don't need to use any lifts in normal code.
09:33:28 <en0th> dcoutts: i'm trying to understand the mechanics behind stg machine
09:33:28 <dcoutts> en0th: ah, you're interested in the difference between normal form and weak head normal form?
09:34:20 <dcoutts> en0th: stg typically only deals with evaluating to weak head normal form (WHNF)
09:34:32 <leimy> :t lift . lift
09:34:33 <lambdabot> forall a (t :: (* -> *) -> * -> *) (m :: * -> *) (t1 :: (* -> *) -> * -> *). (MonadTrans t, Monad (t1 m), MonadTrans t1, Monad m) => m a -> t (t1 m) a
09:34:43 <leimy> :t lift . lift . lift . lift
09:34:44 <lambdabot> forall a (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) (t2 :: (* -> *) -> * -> *) (m :: * -> *) (t3 :: (* -> *) -> * -> *). (MonadTrans t, Monad (t1 (t2 (t3 m))), MonadTrans t1, Monad (t2 (t3
09:34:44 <lambdabot> m)), MonadTrans t2, Monad (t3 m), MonadTrans t3, Monad m) => m a -> t (t1 (t2 (t3 m))) a
09:35:24 <leimy> damn...
09:35:35 <leimy> I hope that factors out to mostly type stuff.
09:35:39 <leimy> and not a runtime hit for lifting.
09:35:57 <en0th> in stg paper there's written: the heap contains: 1) head normal forms (function or data values) or 2) unevaluated suspensions (thunks)
09:37:08 <dcoutts> en0th: ok, it means weak head normal forms I think
09:38:56 <en0th> Ok. The question i was asking myself is: if there are only values and functions, then what those thunks really are ?
09:39:15 <copumpkin> thunks are wannabe values
09:39:30 <copumpkin> that have not been graced with the magic touch of life yet
09:39:31 <dcoutts> en0th: it's a function applied to one or more arguments that has not yet been evaluated
09:40:59 <dcoutts> en0th: consider: case (1, 1+1) of (n, _) -> n
09:42:02 <dcoutts> en0th: when we evaluate that, at the point we're doing the case analysis, we have both 1 and 1+1 as heap objects, one is a normal form data value. The other is an unevaluated suspension.
09:42:37 <dcoutts> en0th: or to make it clearer: case (1, length [1..]) of (n, _) -> n
09:43:26 <dcoutts> en0th: the unevaluated suspension is length [1..], the function length applied to the argument [1..] but not evaluated down to a normal form data value
09:43:47 <en0th> dcoutts: ok. and the whole (1,length [1..]) will be another suspension itself?
09:44:50 <dcoutts> en0th: in this case no, because it's already in head normal form (the head is a (,) constructor)
09:45:06 <dcoutts> en0th: but if we were passed in a pair as an argument, then it could be a suspension
09:45:17 <dcoutts> and the code for evaluating the case would have to deal with that
09:45:24 <dcoutts> with that possibility.
09:46:24 <en0th> dcoutts: it's incredibly more clear now..
09:46:38 <dcoutts> en0th: values in weak head normal form can contain other values that are still thunks
09:47:05 <dcoutts> it just means the head of the value is a data constructor or a lambda, and not a thunk
09:48:09 <en0th> dcoutts: do you know some book to get these sort of notions?
09:48:52 <gwern> may I suggest pierce's tapl? :)
09:49:04 <Taejo> :t partition
09:49:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:49:40 <en0th> gwern: Types and programming languages?
09:49:51 <gwern> maybe
09:49:55 <dcoutts> en0th: yes, probably TAPL, or perhaps SPJ's "The Implementation of Functional Programming Languages"
09:50:06 <dcoutts> or some other intro Haskell or FP book
09:50:18 <Saizan_> does tapl cover lazy evaluation?
09:50:43 <gwern> 'Changing Haskell's Read Implementation Such That by Mainpulating Abstract Syntax Trees it Reads Expressions Efficiently' <-- most strained acryonym evar
09:51:06 <copumpkin> lol
09:51:13 <dcoutts> en0th: or maybe "Introduction to Functional Programming" book
09:51:25 <copumpkin> I was seeing Christ Mastree, ??? but then I figured it out and felt stupid
09:52:21 <en0th> dcoutts and gwern: i'm taking a look at them, many many thanks
09:52:33 <dcoutts> you're welcome
09:54:17 <en0th> tapl looks like a black beast..
09:55:49 <copumpkin> there's even ATTaPL
09:55:57 <Saizan> it's about type systems rather than evaluation, btw
09:56:14 <saml> how can i get combinatino of 3 prime numbers less than n? if n is 10, [(2,3,5), (2,3,7), (3,5,7)]
09:56:25 <saml> and how do i get list of all such lists?
09:56:44 <copumpkin> saml: replicateM 3 (primesUnder x)
09:56:52 <fasta> Searching for project euler solutions would be the fastest solution ;)
09:56:55 <gwern> ia! ia! la nub tapl shuggartah of the black woods!
09:57:02 <saml> > replicateM 3 [1..10]
09:57:03 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,1,6],[1,1,7],[1,1,8],[1,1,9],[1...
09:57:09 <copumpkin> or if you really want 3-tuples, you can do it with a liftM3 or something
09:57:23 <saml> > replicateM 3 [2,3,5,7]
09:57:24 <lambdabot>   [[2,2,2],[2,2,3],[2,2,5],[2,2,7],[2,3,2],[2,3,3],[2,3,5],[2,3,7],[2,5,2],[2...
09:57:36 <saml> [2,2,2] isn't valid
09:57:46 <EnglishGent> Ph'nglui mglw'nafh Cthulhu fmap fmap fmap R'lyeh wgah'nagl fhtag
09:57:50 <EnglishGent> :)
09:57:57 <copumpkin> > nub . replicateM 3 $ [2,3,5,7]
09:57:58 <saml> how do i test if a list is a set (no duplicates)
09:57:58 <lambdabot>   [[2,2,2],[2,2,3],[2,2,5],[2,2,7],[2,3,2],[2,3,3],[2,3,5],[2,3,7],[2,5,2],[2...
09:58:01 <copumpkin> lol
09:58:22 <copumpkin> > nubBy (ap (==) nub) . replicateM 3 $ [2,3,5,7]
09:58:23 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
09:58:23 <lambdabot>         against inferred ...
09:58:45 <saml> > Data.Set.nub . replicateM 3 $ [2,3,5,7]
09:58:46 <lambdabot>   Not in scope: `Data.Set.nub'
09:58:47 <EvilTerran> saml: sort, group, then look for duplicates that way?
09:58:50 <burp> some length and nub
09:58:54 <EvilTerran> > group $ sort "abracadabra"
09:58:55 <lambdabot>   ["aaaaa","bb","c","d","rr"]
09:58:56 <copumpkin> > nubBy ((==) `on` ap (==) nub) . replicateM 3 $ [2,3,5,7]
09:58:57 <lambdabot>   [[2,2,2],[2,3,5]]
09:59:00 <copumpkin> damn :)
09:59:06 <copumpkin> that is totally wrong
09:59:32 <burp> > length . nub $ [1,2,3,4,1] == length [1,2,3,4,1]
09:59:33 <lambdabot>   Couldn't match expected type `[t]'
09:59:34 <lambdabot>         against inferred type `GHC.Types...
09:59:38 <harlekin> Cale, thanks for your help with proper classes. With your help I was able to find a solution for my problem.
09:59:41 <monochrom> The best way to solve the project euler problem (no typo) is to guide towards the slowest method possible.
09:59:42 <gwern> it'd be fun to define a 'Cthulude'
09:59:56 <Taejo> @hoogle (a -> b) -> (a, a) -> (b, b)
09:59:56 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:59:57 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:59:57 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
10:00:05 <burp> > (length . nub $ [1,2,3,4,1]) == (length [1,2,3,4,1])
10:00:06 <lambdabot>   False
10:00:43 <gwern> hm. 'ia' could be id, wgah'nagl could be length...
10:01:16 <BONUS> :t join (***)
10:01:17 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
10:01:32 <monochrom> Example. "how do I evaluate 1+2+...+n?"  Solution: for each i from 1 to n, create a list of length i containing all 1's. Sum those lists.
10:01:39 <copumpkin> monochrom: lol
10:02:06 <en0th> or sum the length!
10:02:09 <monochrom> Example. "how do I evaluate 1*2*...*n?"  Solution: first define * in terms of + by induction...
10:03:51 <en0th> i wish there was a fp course at my univ :(
10:04:08 <saml> how can I get list of primes less than n?
10:04:43 <saml> how can i get ordered list of all primes
10:04:46 <gwern> saml: filter (<n) $ primes?
10:04:56 <EvilTerran> use unsafePerformIO to download a list off primegrid.org :P
10:04:56 <gwern> ('primes' is left as an exercise for the reader)
10:04:58 <roconnor> takeWhile (<n) $ primes
10:05:14 <EvilTerran> *.com
10:05:15 <roconnor> saml: http://r6.ca/blog/20081116T213644Z.html
10:05:17 <burp> yup filter won't work good :>
10:05:24 <monochrom> I support filter (<n) $ primes, in the same spirit as what I said. :)
10:05:25 <copumpkin> > takeWhile (< 100) $ nubBy isMultipleOf [2..]
10:05:26 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
10:05:29 <burp> at least not on a infinite list ;)
10:05:30 <gwern> :T filter
10:05:37 <gwern> :t filter
10:05:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:05:42 <saml> copumpkin, you are a genius
10:05:43 <gwern> filter would be fine
10:05:48 <saml> that sounds like list of all primes
10:05:59 <copumpkin> saml: it's wicked slow :D
10:06:04 <burp> > filter (<10) [1..]
10:06:07 * copumpkin follows monochrom's teachings
10:06:08 <lambdabot>   mueval-core: Time limit exceeded
10:06:10 * monochrom snickers at nubBy
10:06:18 <burp> > takeWhile (<10) [1..]
10:06:19 <lambdabot>   [1,2,3,4,5,6,7,8,9]
10:06:20 <saml> copumpkin ? no it's genius. it's wicked fast in my head
10:06:27 <copumpkin> oh, cool
10:06:37 <Igloo> copumpkin: There's no reason you're compiler couldn't optimise it into an efficient algorithm for you!
10:06:42 --- mode: Igloo set -o Igloo
10:06:46 <copumpkin> awesome!
10:06:55 <Igloo> Ack, your
10:07:20 <copumpkin> ooh, we need a special rewrite rule that replaces nubBy (\x y -> x `mod` y == 0) with the best known prime finding algorithm
10:07:36 <oteren> what does that nubBy do? regular sieving?
10:07:46 <copumpkin> oteren: basically, yeah. It's a recursive filter
10:07:54 <burp> just nub with a custom filter function
10:07:54 <oteren> how do you sieve in haskell?
10:07:58 <oteren> since you dont have arrays
10:08:14 <BONUS> does nubBy require an equivalence class like groupBy?
10:08:18 <gwern> how you write sieve? how is primey formed?
10:08:23 <BONUS> i mean equivalence relation
10:08:27 <copumpkin> you need to do way instain BONUS
10:08:28 <EvilTerran> the nubBy works out, once you work the laziness through, as a standard "try to divide each candidate by each smaller prime in turn" algorithm
10:08:34 <saml> @src isMultipleOf
10:08:35 <lambdabot> Source not found. Do you think like you type?
10:08:45 <leimy> :t nubBy
10:08:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
10:08:47 <copumpkin> saml: it's a mystery! :P
10:08:51 <BONUS> hehe
10:08:58 <copumpkin> (@let x `isMultipleOf` y = x `mod` y == 0)
10:09:33 <roconnor> copumpkin: you forgot 91 in your list
10:09:35 <leimy> > nubBy ( (== 0) . (mod 2)) [1..]
10:09:36 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
10:09:36 <lambdabot>         against inferred ...
10:09:41 <leimy> doh!
10:09:59 <EvilTerran> > nubBy ((==0).flip mod) [2..]
10:10:00 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
10:10:00 <lambdabot>         against inferred ...
10:10:11 <EvilTerran> ?type nubBy
10:10:12 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
10:10:13 <copumpkin> roconnor: it isn't prime
10:10:23 <davidL> > nubBy (fmap (==0) . mod) [2..]
10:10:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:10:24 <roconnor> copumpkin: ah, too smart.
10:10:24 <EvilTerran> > nubBy (fmap (==0).flip mod) [2..]
10:10:25 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:10:26 <copumpkin> > 7 * 13
10:10:26 <lambdabot>   91
10:10:27 <copumpkin> lol
10:10:28 <oteren> lol
10:10:37 <EvilTerran> ah, no flip. hm....
10:10:41 <leimy> hah
10:10:52 <oteren> roconnor: nice one :)
10:11:05 <copumpkin> roconnor's mocking me :'(
10:11:49 <roconnor> copumpkin: sorry, I didn't mean it like that.  I wanted to see if I could catch someone if the ol' 91 is prime trick
10:11:54 <copumpkin> lol
10:11:59 <roconnor> but #haskell is too smart for that
10:12:14 <gwern> @seen gwern
10:12:14 <lambdabot> Unknown command, try @list
10:12:21 <gwern> huh
10:12:33 <roconnor> preflex: seen gwern
10:12:33 <preflex>  gwern was last seen on #haskell 12 seconds ago, saying: huh
10:12:56 <roconnor> with the ol'
10:15:40 <RD> hey room
10:15:48 <RD> nvm
10:16:00 <Twey> Hello
10:16:20 <deech> Hi all, when I load a file into GHCI I am getting a "Could Not Find Module ... It is a hidden module in package ...". The package in question is available and exposed according to ghc-pkg. What am I doing wrong?
10:16:47 <Twey> What module are you attempting to load?
10:17:05 <Raevel> deech: if your wd is the package's source you will get that error
10:17:07 <Twey> GHCi is saying that the package contains it, but doesn't want it exposed (i.e. it's internal, not part of the API)
10:17:16 <Raevel> or was that a similar error
10:17:18 <Twey> Raevel: Really?  Why?
10:17:45 <patch-tag> can someone help me with a cabal config? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11175#a11175
10:17:56 <patch-tag> works for me, but would like it to be backwards compatible if that's straightforward.
10:18:38 <Raevel> oh, nope, that error is "module `X' is not loaded"
10:18:41 <Raevel> Twey: no idea why!
10:18:49 <Twey> Huh
10:18:58 <roconnor> wn
10:19:50 <Raevel> Twey: http://pastie.caboo.se/paste/670301
10:21:32 <Twey> Oh, I believe you.
10:21:42 <Twey> Just baffled by it.
10:22:01 <Raevel> yes quite
10:24:09 <dcoutts> patch-tag: you need base >= 3 in one branch and base < 3 in the other
10:24:29 <dcoutts> patch-tag: and to be honest, supporting ghc-6.6 isn't that critical anymore
10:25:01 <dcoutts> patch-tag: and certainly don't trust it without checking it actually builds with 6.6
10:25:28 <dcoutts> patch-tag: more important is checking it works with 6.8 and 6.10
10:25:55 <dcoutts> patch-tag: and presumably you mean base < 4 too
10:26:43 <Saizan> extensible-exceptions work with base == 4.* too
10:30:49 <sproingie> @src on
10:30:49 <lambdabot> (*) `on` f = \x y -> f x * f y
10:31:18 <sproingie> wack.  i guess 'let' was too clear
10:31:44 <Saizan> let?
10:31:52 <sproingie> oh heck it didn't even need a let
10:32:21 <sproingie> g `on` f = \x y -> f x `g` f y
10:32:39 <sproingie> i came up with some wacky thing using let
10:33:00 <quicksilver> on g f x y = g (f x) (f y)
10:33:06 <quicksilver> if you prefer "standard" order
10:33:41 <quicksilver> @pl on g f x y = g (f x) (f y)
10:33:41 <lambdabot> on = join . ((flip . ((.) .)) .) . (.)
10:33:42 * EvilTerran prefers "(g `on` f) x y = g (f x) (f y)"
10:33:57 * quicksilver prefers join . ((flip . ((.) .)) .) . (.)
10:33:57 <sproingie> awesome @pl
10:34:17 <sproingie> @pointy join . ((flip . ((.) .)) .) . (.)
10:34:17 <lambdabot> (\ n -> (\ y b c f -> n (y c) (b f)) >>= \ o -> o)
10:34:19 <EvilTerran> or "g `on` f = gonf where x `gonf` y = f x `g` f y"
10:34:30 <sproingie> @pl \ n -> (\ y b c f -> n (y c) (b f)) >>= \ o -> o
10:34:31 <lambdabot> join . ((flip . ((.) .)) .) . (.)
10:34:53 <sproingie> so it does reverse.  i guess @pointy is defined using @pl
10:35:13 <Twey> @pointy id
10:35:13 <lambdabot> (\ a -> a)
10:35:16 <Twey> Heh
10:35:16 <EvilTerran> (bonus: reading "gonf" as a word when skimming my code later sometimes amuses me)
10:35:25 <sproingie> @pointy \a -> a
10:35:26 <lambdabot> \ a -> a
10:35:30 <sproingie> aw
10:35:41 <Twey> EvilTerran: Hehehe
10:35:47 <Twey> EvilTerran: What did it stand for?  :
10:35:49 <sproingie> @obfuscate id
10:35:49 <lambdabot> Unknown command, try @list
10:35:53 <sproingie> double aw
10:36:17 <Twey> sproingie: Yeah, I was kind of expecting \ a -> (\ b -> b) a :
10:36:23 <EvilTerran> dunno... it just sounds like it should be onomatopoeic for something
10:36:27 <Twey> Hehehe
10:36:32 <EvilTerran> as well as "g-on-f"
10:36:56 <EvilTerran> you could do it the other way round and have "fong"...
10:37:36 <Twey> Ahh, that's what it meant.
10:37:40 <Twey> Hehe.
10:37:46 <Twey> Fong sounds somewhat dirty.
10:38:11 <sproingie> he fonged her points lazily
10:38:36 <sproingie> (i guess "eagerly" would have read better)
10:39:21 <Twey> Hehe
10:41:28 <mwc> sproingie: strictly might also have worked, if you were into BSDM
10:42:05 <one_> do either ghci or hugs allow you to define new types?
10:42:10 <one_> I cannot seem to manage it
10:42:29 <sproingie> don't think so
10:42:35 <mwc> one_: ghci's environment should be understood as taking place in a do block
10:42:38 <quicksilver> one_: only by putting them in a file and loading the file
10:42:59 <one_> is there any haskell implementation that allows me to do this?
10:43:06 <sproingie> not an interpreter no
10:43:12 <one_> I find that it breaks my flow while trying to learn the language
10:43:29 <sproingie> get familiar with :r
10:43:41 <sproingie> flow resumed
10:43:50 <one_> ?
10:44:02 <roconnor> :r in ghc reloads the current file
10:44:05 <sproingie> write it in a .hs file, :load it, then when you change things, :reload it
10:44:05 <mwc> one_: not that I know of. As I said, GHCI isn't quite the same as a python (for instance) top level which you have the entire language available
10:44:10 <mwc> there are technical reasons for this
10:44:18 <one_> ah
10:44:22 <sproingie> :r for now is the single-letter abbreviation for :reload
10:44:31 <sproingie> it'll probably stay that way, but you never know
10:44:40 <mwc> the statements you write at the ghci prompt you should think of as taking place inside an IO action, inside a do block
10:44:57 <roconnor> granted :r throws away all your local definitions ... but in some sense that in inevitable. still ...
10:45:12 <sproingie> that :r throws away local definitions is kind of a feature
10:45:14 <oteren> cant you reload just the single module?
10:45:57 <roconnor> sproingie: ya, but sometime I go through a lot of effort to load data from a file and it is totally independent of the haskell module I am (re)loading.
10:45:58 <sproingie> ocaml's repl doesn't, which makes for massive confusion
10:45:59 <paolino> (there is also http://moonpatio.com:8080/fastcgi/hpaste.fcgi/raw?id=2087) for declaring data
10:46:01 <one_> why do some people prefer Hugs to ghci?
10:46:16 <sproingie> winhugs has a nicer interface
10:46:20 <oteren> indeed
10:46:21 <sproingie> it was around before ghci
10:46:22 <roconnor> ghci used to not exist.
10:46:31 <sproingie> ghci used to be glacially slow
10:46:51 <one_> is there any reason to use Hugs over ghci these days?
10:46:56 <sproingie> not really
10:46:57 <oteren> nicer interface
10:46:58 <oteren> :p
10:46:58 <Twey> It gives nicer errors
10:47:01 <copumpkin> does hugs allow data declarations in the command line?
10:47:04 <Twey> No
10:47:09 <sproingie> gives nicer errors in some places
10:47:32 <EvilTerran> i found i preferred ghci's errors after i got used to them
10:47:32 <mwc> hugs has a reputation as being the "teaching" environment for haskell, while GHC is the industrial environment
10:48:02 <copumpkin> my school uses ghc in the haskell course
10:48:39 <shambler> haskell course? lucky -_-
10:48:58 <en0th> was writing the same thing..
10:49:01 <copumpkin> I wasn't able to take it, sadly
10:49:06 <oteren> we use ghc as well
10:49:35 <sproingie> hugs hasn't seen a release in years, so its future as a teaching tool is pretty dim
10:50:09 <copumpkin> who used to maintain it?
10:50:19 <copumpkin> and/or develop it
10:50:36 <oteren> considering haskell itself hasnt been very revised since 2003 that shouldnt be such a big deal sproingie :p
10:50:46 <copumpkin> Mark P Jones?
10:50:57 <patch-tag> dcoutts: hmm.. I'll probably just keep things simple and not try for backwards compat
10:51:00 <copumpkin> oteren: the GHC extensions are awesome though
10:51:15 <copumpkin> some of them, at least
10:51:23 <sproingie> eh ghc represents the bleeding edge.  it's not so much about haskell being up to date, haskell 98 should be good enough for teaching
10:51:41 <dcoutts> patch-tag: yep, it's only any good if you can actually test it
10:51:53 <dcoutts> patch-tag: I keep several versions of ghc installed for just that purpose
10:59:05 <EvilTerran> sproingie, i find that at least -XFlexibleContexts and -XFlexibleInstances make for a more intuitive language
10:59:52 <benmachine> I find generalisednewtypederiving very useful
10:59:58 <benmachine> and also low-impact
11:00:03 <EvilTerran> indeed
11:00:10 <copumpkin> well Flexible* makes things that feel normal actually normal
11:00:42 <jdkoeck> Hey everyone, I'm using template haskell, can I ask cabal to dump the generated files somewhere ?
11:00:55 <EvilTerran> {-# LANGUAGE -XFlexibleMorals #-} -- needed for unsafeLaunchMissiles
11:01:13 <EvilTerran> (er, s/-X//, of course)
11:01:51 <mwc> isn't the point of a missile that it is unsafe?
11:02:06 <jdkoeck> EvilTerran: I think you just made it to the next haskell weekly news quotes :)
11:02:07 <mwc> what are the operational semantics of launchMissiles? Nerf darts?
11:02:09 <oteren> its only unsafe when it impatcs
11:02:09 <benmachine> the launch bit is supposed to be relatively risk-free
11:03:08 <benmachine> @remember EvilTerran {-# LANGUAGE FlexibleMorals #-} -- needed for unsafeLaunchMissiles
11:03:08 <lambdabot> I will never forget.
11:05:47 <me_max> hey folks, i'm writing on a windows-gtk programm, but i don't want to use the default windows-gtk theme, instead i want to provide another theme (clearlooks or so). what do i need to change the default theme?
11:06:46 <gnuvince> @seen dons
11:06:46 <lambdabot> Unknown command, try @list
11:06:50 <gnuvince> ~seen dons
11:06:54 <gnuvince> !seen dons
11:07:05 <gnuvince> Oh well :-/
11:07:07 <benmachine> preflex: seen dons
11:07:07 <preflex>  dons was last seen on #xmonad 1 minute and 29 seconds ago, saying: until the, cabal install xmonad
11:07:17 <gnuvince> benmachine: thank you
11:07:19 <benmachine> :)
11:07:52 * performance wonders what haskell.org's monthly bandwidth consumption would be
11:10:27 <copumpkin> performance: I'd guess most of it is on hackage.haskell.org, and that's on a different server
11:10:56 <performance> i'd suspect some of it is for ghc too, which i presume is also on a different server
11:11:15 <copumpkin> yeah, and the platform
11:12:00 <performance> oh yeah ~50MB its heavy too :)
11:13:31 <p_l> I think it's still much lighter than JVM...
11:14:53 <p_l> hmmm... wrong window
11:18:08 <dons> kolmodin: is xmonad0.9 in gentoo?
11:19:07 <dcoutts> dons: ask in #gentoo-haskell, people other than kolmodin may know and/or be able to get the package ready
11:19:09 <Vanadium> no
11:25:27 <oteren> satan som spotify lagger rva idag da
11:25:29 <oteren> uhm
11:25:33 <oteren> this is not the right window.
11:25:45 <sproingie> satan oscillate my metallic sonatas
11:25:53 <oteren> hahaha
11:26:06 <aep> hail
11:27:30 <zrbecker> Is there a arccos function in haskell's standard library? I can't seem to find it. Thanks.
11:28:39 <EvilTerran> ?hoogle cos
11:28:39 <lambdabot> Prelude cos :: Floating a => a -> a
11:28:39 <lambdabot> Prelude cosh :: Floating a => a -> a
11:28:39 <lambdabot> Prelude acos :: Floating a => a -> a
11:28:47 <EvilTerran> zrbecker, Prelude.acos, i guess.
11:29:28 <zrbecker> lol thats it, thanks.
11:30:47 <sproingie> hoogle and hayoo search plugins for firefox are nice
11:31:43 <sproingie> wish ghci had hoogle built in :)
11:31:45 <zrbecker> Ill check those out
11:32:57 <tommd> sproingie: You can add an alias in your .ghci to run hoogle.
11:33:53 <oteren> cant you just make a ghci extension?
11:34:04 <oteren> i thought it supported plugins/extensions
11:34:15 <oteren> (i have no idea if this is true, i just imagined i've read this somewhere)
11:35:36 <tommd> oteren, sproingie: See the first example http://haskell.org/haskellwiki/GHC/GHCi
11:36:33 <sproingie> nifty
11:37:05 <tommd> > :hoogle concat
11:37:06 <lambdabot>   <no location info>: parse error on input `:'
11:37:17 <tommd> No, not you lambdabot.
11:37:25 <sproingie> , :hoogle concat
11:37:32 <sproingie> hm
11:37:41 <lunabot>  luna: Not in scope: `hoogle'
11:37:59 <sproingie> curious
11:38:07 <monochrom> ,hoogle concat
11:38:08 <lunabot>  luna: Not in scope: `hoogle'
11:38:11 <tommd> I just mean, after you setup the .ghci file you can perform such a query.
11:38:15 <sproingie> @hoogle works here
11:38:15 <lambdabot> No results found
11:38:25 <sproingie> except for hoogling "works here"
11:39:02 <tommd> Yeah, we forget to add the 'works' function to the standard libraries.  And 'here' was dropped the day they dropped OO from Haskell 1.0
11:39:08 <monochrom> I see what you mean now.
11:41:21 <jogla> Hello and good evening
11:41:32 <shambler> hello
11:41:47 <EnglishGent> hello jogla :)
11:55:58 <cepstrum> Hi. I'm trying to install the hfann library (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hfann). I have install the FANN C library but when I run the "Setup.lhs configure" command for hfann it gives the error: "Missing C libraries: doublefann, doublefann". I have specified the path to the doublefann.h file in "extra-lib-dirs" in the cabal-file, but it still doesn't work. Can anyone help me out here?
12:03:28 <psal> cepstrum: you may need to specify both --extra-include-dirs and --extra-lib-dirs  (include pointing to .h and lib pointing to shared library files)
12:04:14 <fergie> I'm experimenting with macid and I'm getting the following error: "No instance nor default method for class operation Happstack.Data.Serialize.putCopy"
12:05:26 <trez> xq
12:05:48 <copumpkin> cepstrum: do you type lifter instead of filter when you need to get rid of elements in a list?
12:07:12 <sioraiocht> dcoutts: ping?
12:07:21 <mercury^> Can someone please have a quick look if everything seems alright here: http://rohanlean.de/pub/Incompleteness.tar.bz2
12:07:24 <dcoutts> sioraiocht: pong?
12:07:32 <mercury^> I've been trying to formulate the last proof for too long and can't think clearly anymore.
12:07:51 <sioraiocht> dcoutts: jnwhiteh says you know how to fix the bootstrap script for cabal-install for snow leopard
12:07:55 <Raevel> you bzipped your proof?
12:08:24 <dcoutts> sioraiocht: well how to fix ghc and hsc2hs such that everything else works
12:08:34 <mercury^> Raevel: the proof didn't make it. I bzipped the remaining paper and its source.
12:08:39 <sioraiocht> dcoutts: okay? =)
12:08:55 <cepstrum> psal: My cabal file looks like this:   extra-libraries:    doublefann
12:08:55 <cepstrum>   extra-lib-dirs:     /usr/lib/
12:08:55 <cepstrum>   include-dirs:       /usr/include/
12:09:10 <cepstrum> copumpkin: Yes, I do!
12:09:34 <copumpkin> with what quefrency do you accidentally mistype your lifter as filter?
12:09:41 <dcoutts> sioraiocht: see http://hackage.haskell.org/trac/ghc/ticket/2965#comment:24
12:09:50 <sioraiocht> dcoutts: cheers =)
12:10:05 <dcoutts> sioraiocht: and for hsc2hs see http://hackage.haskell.org/trac/ghc/ticket/3400
12:11:12 <dcoutts> cepstrum: you don't need to (and should not) list the standard dirs /usr/lib/ and /usr/include/
12:12:10 <cepstrum> copumpkin: When the rahmonics are good!
12:13:03 <cepstrum> dcoutts: Well, without them, I get the error too
12:13:15 <kolmodin> dons: xmonad 0.9 has been in the overlay since even before it got announced. I just back home from work and intend to put it into portage tonight
12:13:15 <lambdabot> kolmodin: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:14:28 <dcoutts> cepstrum: what error? if your gcc isn't looking in /usr/lib and /usr/include then it is seriously broken.
12:14:42 <skorpan> this is slightly off-topic, but i'm reading a lua tutorial and it says that you can assign functions to variables.  "The ability to do this is because Lua has first class values."  is that really well put?  shouldn't it be something like "because Lua has first class functions" or something along those lines?
12:14:48 <tommd> ... or you're building kernel modules.
12:14:58 * tommd runs off to lunch.
12:15:07 <copumpkin> skorpan: yeah, that seems wrong
12:15:08 <dcoutts> cepstrum: or perhaps you've got a local header that is masking a global one
12:16:04 <cepstrum> dcoutts: It's not gcc that fails, but the "Setup.hs configure" command from the hfann library
12:17:36 <cepstrum> dcoutts: I get the same error as this guy, except I have installed FANN 2.0.0: http://leenissen.dk/fann/forum/viewtopic.php?f=3&t=578
12:18:55 <dcoutts> cepstrum: he's using /usr/local/lib and /usr/local/include, not /usr/lib and /usr/include
12:20:25 <dcoutts> cepstrum: the "Setup.hs configure" uses gcc to compile and link a trivial test prog that links to the libs specified in the .cabal file
12:20:30 <dcoutts> so it is using gcc
12:20:34 <cepstrum> dcoutts: Yeah, well, the error is the same. I know my doublefann.h is in /usr/include
12:20:49 <doladowanie> http://darmowe-doladowanie.org/index.php?c=viral&m=index&id=1ab8c7f36a6ba0e393e2e2af4bfc8211
12:20:50 <mercury^> Raevel: did you have a look?
12:20:51 <doladowanie> http://darmowe-doladowanie.org/index.php?c=viral&m=index&id=1ab8c7f36a6ba0e393e2e2af4bfc8211
12:21:19 * mux wonders if cabal keeps an extensive log files a la config.log & autoconf
12:21:20 <cepstrum> dcoutts: Oh ok
12:21:29 <mux> that would make it trivial to diagnose those tings
12:21:45 <dcoutts> mux: it'll do so to stdout with -v3
12:22:03 <cepstrum> dcoutts: So, it is my GCC that is broken?
12:22:05 <mux> anyways, I've never had problems adding /usr/local/include & /usr/local/lib to cabal dirs to build something on FreeBSD where third party libs are commonly installed
12:22:09 <mux> dcoutts: yes, but that's user dependant
12:22:22 <mux> the nice thing with that config.log is that you have it no matter what :-)
12:22:26 <dcoutts> mux: yes, it could be better, feel free to file a ticket
12:23:24 <FunctorSalad> I thought someone one upped an Ord instance for TypeRep once
12:23:29 <FunctorSalad> anyone remember?
12:23:32 <FunctorSalad> *once
12:23:46 <mux> oh my god I just implied there's a small thing where autoconf is better than cabal
12:24:12 <mux> I'll punish myself :)
12:24:26 <dcoutts> cepstrum: make a simple .c file and compile it using gcc -ldoublefann, that's what cabal is doing, see what gcc says
12:24:37 <dcoutts> mux: heh, there are several in each direction
12:24:54 <mux> I just hate autoconf with a passion
12:24:57 <dcoutts> cabal is far from perfect
12:25:03 <mux> yep
12:25:16 <mux> but it's a great tool already
12:25:43 <mux> it surpasses many other similar language tools for installing packages
12:26:14 <mux> serisouly, compare the cabal framework & cabal CLI tool to the Perl build framework and cpan.Pl
12:26:17 <mux> heh heh heh.
12:26:24 * dcoutts has never used the perl one
12:26:51 <mux> one is clean and consistent...
12:27:09 <dcoutts> cepstrum: it's not the .h file that it cannot find, it's linking with the C lib that fails
12:27:49 <jogla> (Int -> Int) -> Int -> Bool, a function of that type does expect a function that takes and returns an Int, an Int and evaluates to Bool, is that right?
12:28:00 <mux> jogla: yes
12:28:08 <HayashiRazan> yes
12:28:12 <mux> that's one way of seeing it :-)
12:28:13 <HayashiRazan> dont worry little one
12:28:27 <cepstrum> dcoutts: ok, then it says: /usr/local/lib/libdoublefann.so: undefined reference to `floor'
12:28:27 <cepstrum> /usr/local/lib/libdoublefann.so: undefined reference to `log'
12:28:27 <cepstrum> /usr/local/lib/libdoublefann.so: undefined reference to `exp'
12:28:27 <cepstrum> /usr/local/lib/libdoublefann.so: undefined reference to `pow'
12:28:27 <cepstrum> collect2: ld returned 1 exit status
12:28:42 <dcoutts> cepstrum: ok, there you go
12:28:53 <mux> :t \f x -> f x > 0
12:28:54 <lambdabot> forall t a. (Num a, Ord a) => (t -> a) -> t -> Bool
12:28:55 <dcoutts> cepstrum: it's not been compiled/installed correctly
12:29:06 <dcoutts> cepstrum: seems that it is missing a dependency on the C math lib
12:29:08 <mux> :t \f x -> (f::Int->Int) x > 0
12:29:09 <lambdabot> (Int -> Int) -> Int -> Bool
12:29:12 <mux> yay.
12:29:15 <jogla> I'm not sure how i would declare such a function
12:29:17 <mux> I love going from types to code
12:29:22 <dcoutts> cepstrum: ie when it was linked it did not specify -lm
12:29:24 <jogla> Ahh
12:29:40 <HayashiRazan> (Int -> Int) -> Int -> Bool
12:29:49 <cepstrum> dcoutts: Yeah...hmm
12:30:16 <mux> yeah, I guess linux sticks libm in libc or something, explaining why it doesn't happen for others
12:30:28 <mux> they tend to stick things into other things. :-)
12:30:57 <jogla> If i declare that function as "foo x y = \x y == 3", would that be right?
12:31:06 <dcoutts> cepstrum: there's a temporary workaround you can use, but that C lib is definitely not built right. You can add "m" to the extra-libraries field in the hfann.cabal file
12:31:16 <mux> jogla: rather "foo x y = x y == 3"
12:31:26 <mux> but naming a function "x" is not a really good idea
12:31:26 <jogla> Ahh, thank you
12:31:41 <jogla> How do you name them?
12:31:45 <mux> equivalently, "foo = \f x -> f x == 3
12:32:03 <mux> well, I typically use f, g etc if I can't think of anything clearer
12:32:17 <cepstrum> dcoutts: Add m? doublefannm?
12:32:33 <mux> cepstrum: with a space between the two :)
12:32:49 <benmachine> jogla: lambdas need a -> to separate the arguments from the body
12:32:59 <benmachine> so \x y == 3 doesn't parse
12:33:14 <mux> you were trying to mix both forms of definitions
12:33:19 <jogla> Ahh
12:33:27 <jogla> Cool
12:33:39 <jogla> But that still has the same signature, has it?
12:33:43 <mux> jogla: in fact, the "f x y = x + y" is just syntactic sugar for the less readable "f = \x y -> x + y" form
12:33:55 <cepstrum> dcoutts: Hehe, ok. It seems to work. What does the m do?
12:34:13 <dcoutts> cepstrum: that's the name of the C math library, libm.so
12:34:14 <jogla> mux: Thank you!
12:34:15 <mux> cepstrum: it links to libm, the lib containing the math functions you were missing
12:34:23 <zygoloid> mux: but... oh noes! the monomorphism restriction!
12:34:33 * mux cowers in fear
12:34:45 <cepstrum> dcoutts: mux: ah ok, cool
12:34:49 <benmachine> plus f (x:xs) y = x + y isn't the same as f = \(x:xs) y -> x + y
12:34:53 <dcoutts> cepstrum: the libdoublefannm.so should itself link to libm.so, but it doesn't which is why you cannot link to it
12:35:06 <benmachine> (in that the former allows further patterns for f)
12:35:25 <dcoutts> cepstrum: so it's probably worth you reporting that bug upstream
12:35:39 <zygoloid> also, where clauses can scope over x, xs and y in the former but not the latter
12:36:20 <Paczesiowa> how can I view .hi files?
12:36:21 <lambdabot> Paczesiowa: You have 1 new message. '/msg lambdabot @messages' to read it.
12:36:35 <gOcOOl> given a time in a format such as this: [Sat Oct 24 08:14:58 2009], does anyone know how I could use the Data.Time module or somesuch to check if this is within a certain time range?
12:36:54 <copumpkin> Paczesiowa: you can't easily, as far as I know
12:37:14 <cepstrum> dcoutts: Dang! Right into the next error when running build. "dist/build/HFANN/Data_hsc_make: error while loading shared libraries: libdoublefann.so.2: cannot open shared object file: No such file or directory"
12:37:21 <Paczesiowa> copumpkin: it's garbage:-(
12:37:33 <Paczesiowa> gOcOOl: isn't Time instance of Ord?
12:37:49 <cepstrum> dcoutts: It's a problem with the fann-library, right?
12:38:11 <dcoutts> cepstrum: make sure you did it for both bits of the .cabal file where it lists doublefann
12:38:13 <gOcOOl> Paczesiowa: checking ...
12:38:14 <dcoutts> cepstrum: yes
12:38:47 <copumpkin> Paczesiowa: I started writing a viewer using the ghc api but I have the attention span of a
12:39:16 <cepstrum> dcoutts: I did.
12:39:23 <gOcOOl> Paczesiowa: I unable to verify it
12:39:54 <gOcOOl> Paczesiowa: even if it is, how do I go about checking it?
12:40:49 <gOcOOl> it doesn;t necessarily need to be Data.Time module, whatever is generally used for this kind of thing is basically what I'm looking for
12:40:50 <Paczesiowa> gOcOOl: a < x && x < deadline
12:41:42 <gOcOOl> a, x & deadline being what? how do I initialize them?
12:41:48 <copumpkin> time values
12:42:15 <gOcOOl> ok, an example would help
12:42:48 <dcoutts> cepstrum: you can continue to investigate the workaround, or try and get the C lib fixed
12:43:47 <cepstrum> dcoutts: Yeah. I will take a closer look at it. Thanks for your help! :)
12:44:06 <benmachine> gOcOOl: is the input in string form or an actual date type?
12:44:18 <gOcOOl> benmachine: string form
12:44:36 <gOcOOl> specifically "[Sat Oct 24 08:14:58 2009]"
12:44:39 <benmachine> hmm
12:44:55 <mornfall> Hm.
12:45:00 <Paczesiowa> there's a scanf like time parsing function somewhere
12:45:14 <mornfall> hClose: invalid argument ... does that ring a bell? (win32)
12:45:20 <Paczesiowa> slow, but works
12:46:40 <sinelaw> is ghc backwards compatible?
12:46:56 <zygoloid> with chg?
12:47:01 <skorpan> *badom pish*
12:49:11 <copumpkin> sinelaw: static linkage wise? nope
12:49:13 <sinelaw> i'm trying to build some old package, it fails because it uses "-package lang" but no pacakge "lang" exists
12:49:40 <sinelaw> neither in cabal
12:49:55 <dcoutts> sinelaw: wow, that is old
12:50:19 <sinelaw> ok, i found this message in a mailing list, that what 'lang' used to provide is now built in
12:50:29 <sinelaw> dcoutts, yes, it's Yampa-0.91
12:50:33 <dcoutts> sinelaw: that or you'll need ghc-6.4 or older
12:50:44 <copumpkin> lol
12:51:12 <sinelaw> i'm running 6.10
12:51:26 <sinelaw> i'll try removing the -package lang and see if it works
12:51:36 <HayashiRazan> don't be afraid
12:51:54 <dcoutts> sinelaw: any reason you're doing software archaeology rather than using a recent version of yampa from hackage?
12:52:16 <sinelaw> dcoutts, because it's a bundle containing the robot simulator which i want to run
12:52:28 <dcoutts> fair enough
12:52:30 <sinelaw> i'm doing a project on using FRP for robotics
12:52:34 <gOcOOl> FYI, seems like this might have what I need: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsedate
12:52:39 <pshc> I want to pass a type to a function, is (undefined :: t) with ScopedTypeVariables pretty much the only way?
12:53:03 <copumpkin> pshc: or tagged stuff
12:53:06 <kyagrd> pshc: you can use asTypeOf if you have a value of type t
12:53:15 <pshc> asTypeOf eh
12:53:16 <dcoutts> pshc: or asTypeOf
12:53:22 <copumpkin> http://hackage.haskell.org/package/tagged
12:53:25 <Paczesiowa> pshc: do you use t in type head of that function?
12:53:27 <pshc> sometimes I have a value, sometimes not
12:53:41 <pshc> mmm
12:53:42 <dcoutts> pshc: you don't need a value
12:53:53 <dcoutts> asTypeOf is the traditional Haskell98 method
12:53:54 <copumpkin> tagged is nice :)
12:53:55 <pshc> Using existential quantification, so I guess it's not in the type decl
12:54:01 <benmachine> gOcOOl: I found http://hackage.haskell.org/packages/archive/strptime/latest/doc/html/Data-Time-Parse.html
12:54:03 <sinelaw> MoandFix is also some ancient thing - what should i do with that?
12:54:09 <sinelaw> *MonadFix
12:54:11 <copumpkin> it's still around
12:54:14 <Paczesiowa> pshc: could you hpaste type and definition?
12:54:20 <sinelaw> it's a package?
12:54:46 <pshc> hmm, I'll try to extract the relevant bits
12:54:51 <pshc> this tagged package looks promising though
12:56:29 <Paczesiowa> pshc: don't extract anything, just the type and definition of the relevant function, I don't need the rest
12:57:08 <sinelaw> it's Control.Monad.Fix now
12:59:43 <sinelaw> what about "-package data"?
12:59:48 <sinelaw> ghc complains about that too
13:00:15 <copumpkin> Data.Data maybe?
13:00:23 <copumpkin> (in the base library)
13:00:43 <copumpkin> are you sure the robotics stuff won't work with a more recent yampa?
13:00:59 <sinelaw> the yampa website says they won't
13:01:05 <pshc> Paczesiowa: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11177#a11177
13:01:08 <sinelaw> (and the website itself is outdated... )
13:01:16 <sinelaw> copumpkin, never mind i'll fight it through :)
13:02:30 <pshc> The real problems are elsewhere, like when I'm trying to define Enum's toEnum for Var or Vars
13:02:32 <Paczesiowa> pshc: could you add desired type annotation for fac?
13:02:33 <pshc> ho hum
13:02:44 <pshc> fac :: Factor
13:02:59 <pshc> the code works fine, just wondering if there's a nicer way
13:03:47 <Baughn> @remember DavidLeimbach [I was reading the printf implementation.] I tried to figure it out, then the Cenobites came and got me.
13:03:47 <lambdabot> I will never forget.
13:04:15 <Paczesiowa> pshc: why not  A1?
13:04:31 <pshc> yeah, A1 is what I actually have
13:05:12 <Paczesiowa> pshc: or a = A1, and use a
13:05:21 <pshc> yeah
13:06:02 <Paczesiowa> pshc: I thought that you need undefined :: t where t is type variable from type head/context
13:06:15 <Paczesiowa> pshc: but you just use specific type
13:06:28 <pshc> ah I see
13:06:44 <pshc> I might need that elsewhere
13:06:49 <pshc> is there any reason it wouldn't work?
13:07:05 <Paczesiowa> pshc: ScopedTypeVariables turned off
13:07:11 <pshc> hehe yeah
13:07:16 <pshc> varBounds needs it definitely
13:07:22 <Paczesiowa> pshc: ghc doesn't tell you to enable it
13:07:54 <Paczesiowa> varBounds is weird, what's a?
13:07:54 <pshc> actually when I typed in varBounds for the first time, GHC asked for it
13:08:27 <pshc> a is the existential type quantified by Var
13:08:38 <pshc> er may be fudging the terminology there
13:08:38 <pshc> uhh
13:08:45 <pshc> anyway, the "e" in forall e.
13:08:50 <Paczesiowa> pshc: oh, the one from the left hand side
13:08:55 <pshc> ah yeah.
13:09:11 <Paczesiowa> pshc: you could fix it with explicit type signature I think
13:09:31 <pshc> fix what?
13:09:54 <Paczesiowa> need for additional type systemextension
13:10:00 <pshc> oho.
13:10:12 <Paczesiowa> but since there aren't any problems with ScopedTypeVariables (I think), why bother
13:10:21 <pshc> heh yeah
13:10:27 <pshc> but hmm what would varBounds' signature be then
13:10:43 <Paczesiowa> probably the same as the current one
13:11:07 <Paczesiowa> oh, wait
13:11:07 <pshc> I don't write out type signatures much eheh
13:11:13 <pshc> but wouldn't e be hidden
13:11:32 <pshc> varBounds :: Var -> (Var, Var)
13:11:33 <gOcOOl> I cabal installed parsedate and loading the System.Time.Parse module from ghci says it cannot find the module, anyone know what I might be missing?
13:12:05 <Paczesiowa> gOcOOl: restart ghci?
13:12:15 <Paczesiowa> pshc: actually I think it doesn't make any sense
13:12:21 <gOcOOl> i did a couple of times already
13:12:23 <pshc> uh oh.
13:12:26 * benmachine wonders why parsedate is on version 3000
13:12:26 <Paczesiowa> pshc: those two bounds can be of different types
13:12:54 <pshc> haha yeah.
13:12:57 <Paczesiowa> pshc: (Var 1::Int, Var 10::Integer)
13:13:09 <pshc> yeah I have to hella fudge all the instances
13:13:14 <pshc> with fromEnum everywhere
13:13:17 <dcoutts> gOcOOl: the trick to getting a helpful answer is to use hpaste to show exactly what you did and exactly what the error message was, we're not much good at guessing :-)
13:13:19 <pshc> and just compare indices
13:13:38 <pshc> I guess this is where the tagging comes in or something
13:13:42 <Paczesiowa> pshc: so, why not just store Ints?
13:13:44 <Paczesiowa> :t fromEnum
13:13:45 <lambdabot> forall a. (Enum a) => a -> Int
13:14:09 <pshc> because I'm procrastinating by being cute with enums, I guess haha.
13:14:24 <gOcOOl> dcoutts: thanks, I'm not sure how do I use hpaste
13:14:32 <pshc> it's easier to debug though when I can actually see which vars I'm dealing with instead of indices though.
13:14:34 <Paczesiowa> @where hpaste
13:14:34 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
13:14:35 <dcoutts> @where hpaste
13:14:35 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
13:14:53 <sinelaw> where did "unionManySets" go?
13:15:33 <Paczesiowa> sinelaw: foldl union emptySet, <- here
13:15:45 <dcoutts> or unions
13:15:51 <dcoutts> @hoogle unions
13:15:51 <lambdabot> Data.IntMap unions :: [IntMap a] -> IntMap a
13:15:51 <lambdabot> Data.IntSet unions :: [IntSet] -> IntSet
13:15:51 <lambdabot> Data.Map unions :: Ord k => [Map k a] -> Map k a
13:16:06 <sinelaw> ah
13:16:08 <sinelaw> ok )
13:17:14 <gOcOOl> dcoutts: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4484#a4484
13:17:16 <sinelaw> and I supposed unitSet became singleton?
13:17:17 <gOcOOl> hope that helps
13:18:06 <dcoutts> gOcOOl: what you've done is installed parsedate on a per-user basis for the root user only
13:18:08 <dons> kolmodin: do you have a link to the gentoo xmonad 0.9 page?
13:18:15 <Paczesiowa> dcoutts: I'm trying to reimplement Stream module, and it works great (fuses away) when I use it from the same module, but other modules don't work so great with the same usage (I get some Either tags floating around), I have marked everything with INLINE, do you have any advice?
13:18:20 <dcoutts> note that ghc-pkg list parsedate does not list it
13:18:35 <dcoutts> gOcOOl: since you're doing per-user installs, don't use sudo
13:18:55 <gOcOOl> dcoutts: kinda figured i was screwing up in some installation, any ideas how to fix it?
13:19:06 <dcoutts> gOcOOl: as I said, don't sudo
13:19:15 <gOcOOl> ok, trying ...
13:19:24 <Paczesiowa> dons: it's not in main portage tree yet
13:20:45 <Paczesiowa> dons: and my problem from yesterday was solved with -Odph flag (thanks to rl)
13:20:49 <dcoutts> Paczesiowa: check the phasing on your rules
13:20:55 <dons> Paczesiowa: ah
13:21:01 <dons> Paczesiowa: what does -Odph do?
13:21:03 <dcoutts> Paczesiowa: especially wrt the phasing of the inlines
13:21:08 <Paczesiowa> dcoutts: I'm only using streams, no rules atm
13:21:29 <Paczesiowa> dons: no idea:)
13:21:40 <kolmodin> dons: http://packages.gentoo.org/package/x11-wm/xmonad
13:21:42 <dcoutts> Paczesiowa: you said you were reimplementing the Stream module
13:21:53 <kolmodin> dons: that's very simple, we could make something nicer at the wiki
13:22:20 <Paczesiowa> dcoutts: yes, there are only stream functions, no unstream . foo . stream wrappers for lists
13:22:28 <dcoutts> Paczesiowa: ah ok
13:22:36 <dons> kolmodin: but that page doesn't have a 0.9 entry?
13:22:52 <dcoutts> Paczesiowa: and you're compiling everything with -O I presume
13:23:06 <kolmodin> dons: right, it's the official page. I haven't made xmonad public yet. it's only in the overlay
13:23:14 <kolmodin> dons: and that page doesn't know about the overlay
13:23:27 <dons> ok. so should xmonad tweet that we're in the gentoo overlay?
13:23:34 <dcoutts> Paczesiowa: then usually it's time to look at the -ddump-simpl-iterations -ddump-simple-stats | less
13:23:40 <dons> "xmonad 0.9 uploaded to Gentoo Haskell Overlay." ?
13:24:16 <sinelaw> can infix using `f` contain a compound expression? such as `f x` ?
13:24:22 <dcoutts> sinelaw: no
13:24:23 <Paczesiowa> sinelaw: no
13:24:27 <sinelaw> darn
13:24:37 <Paczesiowa> sinelaw: but there's that -: f x :- trick
13:24:51 <Vanadium> It is the worst trick
13:24:53 <kolmodin> dons: sure. I'll put it into portage shortly, as soon as I have cooked and eaten dinner ;)
13:25:19 <sinelaw> i'll just define my expression
13:25:32 <dons> kolmodin: ok. i'll wait
13:27:33 <kolmodin> dons: it'll still be within 24 hours of the announcement. good enough? :)
13:28:27 <jogla> Where can i find the source of the prelude on my standard debian system?
13:28:37 <Paczesiowa> dcoutts: damn, that's a lot of info. even if I read all that, how do I fix the problem? I have marked as INLINE every function and every stepper/fold (defined in where clauses), shouldn't that work just like source exporting?
13:29:06 <Paczesiowa> jogla: you probably don't want to read that source
13:29:15 <Paczesiowa> jogla: plenty of compiler specific stuff
13:29:20 <jogla> I want to see the ipmlementation of zip
13:29:24 <Paczesiowa> @src zip
13:29:24 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
13:29:24 <lambdabot> zip _      _      = []
13:29:39 <dcoutts> Paczesiowa: shouldn't need INLINE on the steppers
13:29:41 <Saizan> you can check the haskell 98 report
13:29:59 <Saizan> @where h98
13:30:00 <lambdabot> http://haskell.org/onlinereport/
13:30:11 <Paczesiowa> dcoutts: I've seen them in stream-fusion package, so I added them
13:30:11 <luite> what's new in xmonad 0.9?
13:30:11 <dcoutts> Paczesiowa: it should not be too much to follow if you've got a small test case
13:30:11 <dcoutts> Paczesiowa: since it's just two functions you'll be composing
13:30:33 <jogla> Paczesiowa: thanks
13:35:14 <jogla> Is it easy to change zip in a manner that 'zip (zip [3,2] ["a","b"]) [4,6]' will give me a list with three-element lists?
13:35:38 <jogla> Not [((3,"a"),4),((2,"b"),6)], but [(3,"a",4),(2,"b",6)]
13:36:17 <flux> @src zip3
13:36:17 <lambdabot> zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
13:36:17 <lambdabot> zip3 _      _      _      = []
13:36:33 <flux> ..so I'm thinking no
13:37:11 <flux> perhaps if (((a), b), c) was a structure that you'd be comfortable with
13:37:52 <Saizan> > getZipList $ (,,) <$> ZipList [3,2] <*> ZipList ["a","b"] <*> ZipList [4,6]
13:37:53 <lambdabot>   [(3,"a",4),(2,"b",6)]
13:39:13 <sinelaw> does PastePipe actually work for anyone?
13:39:28 <Paczesiowa> dcoutts: all-in-one module has 3 phases of post-worker-wrapper, split module version has only one, after that, they start to look different
13:39:33 <Paczesiowa> sinelaw: yes
13:39:57 <sinelaw> Paczesiowa, doesn't work for me.
13:40:07 <sinelaw> which version are you running? me 1.3
13:40:07 <Paczesiowa> sinelaw: what doesn't work?
13:40:14 <jogla> Saizan: Where do i get getZipList?
13:40:17 <sinelaw> Paczesiowa, it runs, but nothing appears on hpsate.org
13:40:17 <Paczesiowa> sinelaw: yesterday's one
13:40:29 <Saizan> jogla: Control.Applicative
13:40:40 <Paczesiowa> sinelaw: do you use -u username?
13:40:46 <sinelaw> mine is from 3 days ago
13:40:57 <sinelaw> nope, but it says there's a default
13:41:22 <Paczesiowa> sinelaw: default from their www is that guys nick, maybe it's hardcoded and needs a pass?
13:41:36 <dcoutts> Paczesiowa: ah, you're using actual Either as constructors for your stepper state types?
13:41:43 <sinelaw> nope the default is my username
13:41:48 <sinelaw> (or yours :)
13:41:59 <jogla> Saizan: Thank you
13:42:00 <Paczesiowa> dcoutts: StrictEither a b = Left !a | Right !b
13:42:06 <Taejo> what happened to foldl.com? it redirects me to http://education.apwg.org/r/en/index.htm
13:42:13 <dcoutts> Paczesiowa: ok, right
13:42:14 <sinelaw> Paczesiowa, i tried with a different one and it works. weird.
13:42:24 <jogla> Its for beyond my comprehension though
13:42:53 <Paczesiowa> dcoutts: the problem is, it works in one module, and the only thing I found on google is INLINE pragma and two flags about inlining size (they don't help me)
13:43:02 <Twey> Someone sniped it apparently, Taejo :-\
13:43:05 <Paczesiowa> dcoutts: regarding cross-module opts
13:43:08 <dcoutts> Paczesiowa: so the key thing is to trace through the transformations
13:43:10 <jogla> @src getZipList
13:43:10 <lambdabot> Source not found. My mind is going. I can feel it.
13:43:24 <Taejo> Twey: doesn't sniping imply that it wasn't in use before?
13:43:27 <Twey> We need to snag fold[lr].net or something
13:43:28 <jogla> @src ZipList
13:43:29 <lambdabot> Source not found. I am sorry.
13:43:35 <Twey> No, just that it expired for a little while
13:43:44 <Saizan> jogla: it's like newtype ZipList a = ZipList { getZipList :: [a] }
13:43:44 <dcoutts> Paczesiowa: to find the point where the stepper isn't right for case-of-case
13:43:48 <copumpkin> Twey, Taejo: actually, I don't think that's what happened
13:44:03 <sinelaw> Paczesiowa, how do you run it?
13:44:09 <sinelaw> it worked once and now stopped
13:44:11 <copumpkin> Twey: I'd guess that the domain never changed ownership, and that the server config changed, forgetting a vhost
13:44:59 <copumpkin> or something along those lines
13:45:01 <Paczesiowa> sinelaw: pastepipe -u Paczesiowa -t "constr spec problem" < streams5.hs (from bash_history)
13:45:30 <sinelaw> Paczesiowa, ok, i tried pasting my stuff manually and it failed too, simply because its too long.
13:45:34 <sinelaw> so i guess that's it
13:45:36 <hackagebot> FileManipCompat 0.1 - Port of Find function of FileManip lib for use on windows systems (ThomasHartman)
13:45:38 <hackagebot> FileManipCompat 0.11 - Port of Find function of FileManip lib for use on windows systems (ThomasHartman)
13:45:46 <Taejo> copumpkin: yeah, seems like that: whois reports they have the same owner
13:46:10 <copumpkin> Taejo: yeah. And the new redirect location isn't advertising-laden, is a .org, and is owned by a university
13:46:40 <sinelaw> PastePipe should report these errors to the console
13:46:49 <Twey> copumpkin: Hum
13:46:53 <Twey> copumpkin: I don't think so
13:47:00 <copumpkin> the ip addresses are different
13:47:05 <sinelaw> Help! Can someone explain why this doesn't build? I'm new to ghc and can't understand what's missing. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11179#a11179
13:47:07 <copumpkin> Twey: what don't you think?
13:47:25 <Twey> copumpkin: The site was marked as unsafe for a while.  Clearly somebody else got their stuff in there.
13:47:33 <copumpkin> unsafe?
13:47:41 <Twey> Quite, quite
13:47:52 <copumpkin> how do you mean "marked as unsafe"?
13:47:56 <Paczesiowa> sinelaw: missing -package (whatever package has sets)
13:48:01 <Twey> http://education.apwg.org/r/en/index.htm
13:48:08 <Twey>  The web page you tried to visit might have been trying to steal your personal information. That page was removed after being identified as a "phishing" web page. 
13:48:19 <sinelaw> ah ok
13:48:27 <copumpkin> Twey: it's a generic warning on that page without regard to where you came from...
13:48:57 <copumpkin> Twey: you think CMU sniped the domain and redirected it to their phishing education page?
13:49:38 <Paczesiowa> dcoutts: how come you people haven't gone crazy after reading so much core?
13:49:56 <dcoutts> Paczesiowa: who says we've not gone crazy? :-)
13:50:09 <dcoutts> Paczesiowa: dons ended up writing a core colouriser
13:50:30 <jogla> well, probably a stupid question, can i tell haskell to do "xs `infix` ys `infix` zs" like "xs `infix` (ys `infix` zs)" instead of "(xs `infix` ys) `infix` zs"?
13:50:31 <copumpkin> there's a nice core output plugin from BSP's work too, but I don't think that's been merged in yet
13:50:42 <copumpkin> (or will it ever?)
13:50:50 <PetRat> Anyone around with experience building stuff on XP? I'm trying to 'cabal install readline'. I already installed GNU readline. The cabal action cannot find my GNU installation, however, and I don't know how to tell it where to look.
13:51:01 <yitz> sinelaw: could this be *very* old code? it looks like it wants the old Data.FiniteMap, which was replaced by Data.Map and disappeared from the face of the earth many years ago.
13:51:21 <yitz> jogla: yes
13:51:34 <sinelaw> yitz, exactly so
13:51:37 <jogla> How would i do that?
13:51:55 <Taejo> joga: use an "infixr" declaration
13:51:58 <copumpkin> yitz: infixr X `infix`
13:52:02 <copumpkin> oh wohops
13:52:08 <copumpkin> that was for jogla
13:52:18 <joga> heh
13:52:20 <Twey> copumpkin: You think that that is the CMU default page?
13:52:22 <yitz> copumpkin: without the backticks, which is a bit confusing here.
13:52:24 <Codex_> Anyone up to a category theory talk, something like Kan Extensions. I can't understand them yet and might want to learn more :)
13:52:38 <hackagebot> FileManipCompat 0.12 - Port of Find function of FileManip lib for use on windows systems (ThomasHartman)
13:52:39 <dcoutts> PetRat: I wouldn't bother trying to install readline on windows tbh
13:52:42 <Twey> Speaking of, where's edwardk lately?
13:52:53 <copumpkin> Twey: not the default, but definitely looks generic, and it appears regardless of where you come from on that url
13:52:58 <copumpkin> Twey: not sure, I think he's hiding
13:52:59 <Paczesiowa> dcoutts: is it possible to write better core viewer? something that would use nicer variable names?
13:53:12 <dcoutts> Paczesiowa: ghc-core does some of that
13:53:15 <PetRat> dcoutts: It's more a learning thing... I want to know how to build modules such as these.
13:53:19 <yitz> preflex: seen edwardk
13:53:19 <preflex>  edwardk was last seen on #haskell 11 days, 33 minutes and 52 seconds ago, saying: * edwardk is afraid the next works out of byorgey will be 'get him!'
13:53:23 <jogla> copumpkin: Thanks, that's cool
13:53:25 <Paczesiowa> dcoutts: not enough, I still want to shoot myself
13:53:26 <dcoutts> PetRat: try something easier
13:53:31 <sinelaw> yitz, hackage still has FiniteMap
13:53:35 <Twey> Oh, he's online, just not on #haskell
13:53:37 <dcoutts> Paczesiowa: you learn to ignore most of it
13:53:42 <Taejo> I'd say it makes more sense to have a nice renamer than try generate nice names
13:53:45 <Twey> Haha, yitz
13:53:53 <Twey> Hiding from byorgey
13:53:55 <yitz> sinelaw: oh yeah? well, did you try installing it?
13:53:58 <PetRat> I was hoping there's a simple answer, like "set env variable XYZ to point to the lib directory"
13:54:13 <yitz> Twey: actually, that sound ominous about what might have happened to him...
13:54:14 <sinelaw> yitz, yes, i was missing the -package FiniteMap
13:54:18 <sinelaw> now it works
13:54:23 <yitz> sinelaw: yay!
13:54:26 <dcoutts> Paczesiowa: especially since the names of the local vars are hardly ever important, it's the named functions from the original source that are key
13:54:35 <Paczesiowa> the worst thing is when you have a type with unboxed fields, that ends up as multiple parameters to a function, and you have no idea which one is which
13:54:41 <Twey> yitz: He's online, and active a day ago
13:54:46 <Saizan> PetRat: --extra-include-dirs --extra-lib-dirs? or maybe the ./configure script has a special flag.
13:54:49 <sinelaw> yitz, hooray, i've built arrow-0.2!
13:54:52 <yitz> Twey: whew
13:54:52 <sinelaw> back to the future
13:54:56 <Twey> I'm sure byorgey hasn't gotten to him yet :
13:55:00 <copumpkin> yitz: he's on twitter too, and tweeted recently
13:55:14 <PetRat> Saizan: thanks I'll try it
13:55:41 <yitz> perhaps he decided to rescue his life from irc addiction
13:55:59 <dcoutts> Paczesiowa: they're in the same order as originally
13:56:16 <magthe> a quick question: is there any way to convert a ThreadId to some basic type (like an Int or a String) and then back again?
13:57:17 <copumpkin> magthe: for what purpose?
13:57:20 <dcoutts> magthe: constructing a ThreadId would be a very unsafe function
13:58:06 <PetRat> Saizan: because I was doing "cabal install readline" I have no idea where the readline source is. I tried "cabal fetch readline" and it says it is already cached. Where can I find the source?
13:58:19 <yitz> magthe: ThreadId has a Show instance
13:58:36 <PetRat> Or maybe download manually from hackage?
13:58:55 <jogla> I don't understand why my code doesn't work
13:58:57 <Saizan> PetRat: you can "cabal unpack readline"
13:59:11 <copumpkin> jogla: neither do we ;)
13:59:18 <copumpkin> (if you don't show it to us)
13:59:20 <Saizan> PetRat: however the above flags work with "cabal install" too
13:59:38 <PetRat> Saizan: thanks
13:59:40 <yitz> magthe: to go back, you need to keep a map of Strings to ThreadId
13:59:45 <magthe> copumpkin: e.g. to pass as an ID for a request, this could then be used to match up callbacks to the thread doing the original call-out...
13:59:53 <jogla> http://nopaste.com/p/ap9DLsA3mb
14:00:03 <jogla> It works without the infix declaration
14:00:05 <copumpkin> magthe: not sure I understood that
14:00:12 <jogla> and it fails in the line after it
14:00:23 <copumpkin> oh you're in hugs :o
14:00:29 <magthe> yitz: yes, but I wanted to avoid having a single list that requires synchronisation to update
14:00:32 <yitz> magthe: ThreadId also has an Ord instance - so you can use it as the key in a map, you don't need to convert it to anything.
14:00:38 <jogla> Ahh
14:00:40 <jogla> I have an idea
14:00:47 <jogla> 4 is smaller than what : does
14:00:53 <Saizan> yeah
14:01:15 <Paczesiowa> dcoutts: ok in one-module solution that go loop is marked with worker tag, can I force that thing somehow?
14:01:21 <stanv> please help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11180#a11180
14:01:57 <magthe> copumpkin: not sure it's a good idea, but say the client calls the server on thread 1, then the server turns around and calls back into the client and it can then tell the client what thread was used to call out... all without the client needing to keep state
14:01:58 <copumpkin> zomg powerset! does that make Set a comonad?
14:02:08 <Elly> @hoogle :~>
14:02:08 <lambdabot> No results found
14:02:19 <dcoutts> Paczesiowa: I don't know much about that
14:02:30 <dcoutts> Paczesiowa: can ask on the ghc users list
14:03:02 <yitz> stanv: you need to say powerSet (SetI [])     = SetI (SetI [])
14:03:32 <Saizan> SetI [SetI []]
14:03:47 <stanv> @type []
14:03:48 <lambdabot> forall a. [a]
14:04:01 <Paczesiowa> dcoutts: don't really have the time, gonna give the talk about stream-fusion tomorrow
14:04:10 <copumpkin> stanv: are you aware of the usual way we make powersets using filterM?
14:04:10 <Saizan> but that shouldn't matter much..
14:04:14 <Paczesiowa> dcoutts: I guess I'd go with one module solution
14:04:31 <PetRat> After I "cabal unpack" how do I run the installation from that location?
14:05:14 <PetRat> Oh, it looks like I just run "cabal install" with no other arguments.
14:05:17 <Saizan> stanv: i think you want "subsets                = powerSet (SetI xs)"
14:05:22 <Saizan> PetRat: yeah
14:05:48 <stanv> [SetI []] - list with one element type for `a` is `Set a`. but empty [] also must match this type
14:06:00 <copumpkin> stanv: if you're confused about the error messages one common remedy is to add type annotations to things whose type you know until the type error gets refined
14:06:03 <Saizan> stanv: yeah
14:06:16 <Saizan> stanv: it's the definition of subsets probably the problem
14:06:42 <Paczesiowa> what the hell is Str: DmdType SS {ahK->C(S)} ?
14:07:39 <Saizan> stanv: what are the types of mapSet and union?
14:07:41 <FunctorSalad> it complains about overlapping instances even though (as the error message agrees) the instances are incoherent
14:08:48 <stanv> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11180#a11182
14:09:00 <stanv> (revision added)
14:10:03 <mornfall> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11183#a11183 -- gives me "hClose: invalid argument" on latest Haskell Platform on Win32... ideas?
14:11:00 <mornfall> (I'm officially asleep though, so pointer to an existing ticket or something would be appreciated so I can make progress tomorrow.)
14:11:26 <sinelaw> err, i've defined something as an instance of Category
14:11:34 <benmachine> mornfall: maybe blame lazy IO?
14:11:37 <sinelaw> but now all the 'id' and '.' in my code become ambiguous
14:11:50 <sinelaw> how can i tell the compiler to assume they're all from Prelude?
14:11:58 <idnar> can't you just hide the prelude versions?
14:12:19 <mornfall> benmachine: *shrug* I don't care. It's a bug in the implementation, that program has to work under any reasonable implementation.
14:12:26 <sinelaw> idnar, that's not what i wany
14:12:40 <sinelaw> *Want
14:12:58 <benmachine> mornfall: it's pretty difficult/impossible to do lazy IO in a way that always makes sense
14:12:58 <idnar> isn't the (->) instance the same as the prelude functions?
14:13:05 <benmachine> I'd advise using System.IO openFile and friends
14:13:11 <idnar> otherwise, I guess do a qualified import on Category
14:13:32 <mornfall> benmachine: Do you suggest that Haskell programs are forbidden to open the same file twice?
14:13:48 <sinelaw> Actually the only reason i'm doing an instance of category is that it says:
14:13:49 <hackagebot> fft 0.1.5 - Bindings to the FFTW library. (JedBrown)
14:13:53 <sinelaw>     No instance for (Control.Category.Category SF)
14:13:53 <sinelaw>       arising from the superclasses of an instance declaration
14:14:03 <benmachine> mornfall: I'm not pretending to be an expert, but if you want to open the same file twice you probably want to do it strictly
14:14:06 <benmachine> that is my guess
14:14:14 <Saizan> stanv: it works like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11180#a11185
14:14:24 <mornfall> Oh, and btw. appendFile has no reason whatsoever to be lazy.
14:14:54 <benmachine> mornfall: yeah I don't think it is, looking at the docs
14:14:59 <benmachine> I suppose I'm just wrong
14:15:12 <Berengal> Heh, HoleyMonoid is pretty clever
14:15:12 <PetRat> The readline configure script has some code that is documented: "Check whether --with-readline-includes was given". This looks like a command-line flag. What command would I give it to?
14:15:38 <copumpkin> Berengal: what is it?
14:15:47 <Berengal> @hackage HoleyMonoid
14:15:47 <lambdabot> http://hackage.haskell.org/package/HoleyMonoid
14:16:22 <Berengal> It's a monoid with holes
14:16:29 <Twey> Hahaha what
14:16:47 <copumpkin> oh that's cute
14:16:50 <Vulpyne> Can it walk on water?
14:17:04 <copumpkin> the monoidness is only in the Category instance
14:17:10 <Berengal> Vulpyne, no, it has holes. It'll sink
14:17:36 <Twey> Nice
14:17:55 <Berengal> copumpkin, Category is still a monoid...
14:18:44 <copumpkin> Berengal: ? I'm saying that the Monoid constraint only appears in the Category instance
14:18:51 <copumpkin> and Category is a monoid?
14:19:07 <copumpkin> it's associative and has an identity, but it isn't "total"
14:19:09 <sinelaw> If I have libHSblabla.a, is it enough to run ghc with -package blabla?
14:19:20 <stanv> Saizan: :) Give me some time to think about your suggestion :)
14:19:20 <sinelaw> (and -i to the correct path where that file is at)
14:19:24 <sinelaw> ?
14:20:21 <Berengal> copumpkin, "total" as in what?
14:20:35 <copumpkin> as in there needn't be an arrow between every pair of objects
14:21:24 <copumpkin> you're talking about composition?
14:21:49 <stanv> Saizan: I can't understand :(
14:22:04 <copumpkin> oh but I guess I'm wrong :)
14:22:11 <Paczesiowa> sinelaw: you can compile with ghc -c all modules, and link them by hand
14:22:21 <copumpkin> composition is associative, has identity
14:23:10 <Berengal> copumpkin, I thought that was enough to be a monoid
14:23:11 <copumpkin> it's a pity that HoleyMonoid can't be a Functor instance because of its argument order
14:23:18 <copumpkin> Berengal: yeah, it is, I'm smoking something bad
14:23:55 <stanv> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11180#a11186
14:24:11 <dschoepe> Berengal: Isn't technically closure also a requirement? (Though also valid in this case)
14:24:11 <Berengal> copumpkin, according to the docs, the arguments are in that order so they can be composed with (.)
14:24:18 <copumpkin> yeah
14:24:24 <Berengal> Yeah, true
14:24:43 <Berengal> But that's true in Category as well
14:24:49 <copumpkin> dschoepe: yeah, that's what I was thinking of, but I was being stupid about it
14:25:15 <Berengal> Can you have non-closure in a statically typed language though?
14:26:14 <copumpkin> I guess not if you consider _|_ to be a valid member of every type and not just an unpleasant troll that inhabits them
14:26:53 <hackagebot> GPipe-TextureLoad 1.0.0 - Load GPipe textures from filesystem (TobiasBexelius)
14:27:29 <Berengal> copumpkin, being a member of every type doesn't destroy closure
14:27:37 <jmcarthur_work> sweet
14:27:39 <copumpkin> Berengal: that's what I mean
14:27:52 <jmcarthur_work> gpipe keeps getting nicer
14:28:03 <copumpkin> by the "I guess not", I mean "I guess you can't have non-closure ..."
14:28:24 <Berengal> copumpkin, ah. I guess I notted your sentance in the wrong place
14:28:27 <monochrom> which closure?
14:28:39 <copumpkin> the jvm scheme wannabe
14:28:42 <copumpkin> oh wait
14:28:50 <Berengal> that's clojure
14:30:07 <user317> anyone know why i cant seem to convince cabal that i have hunit installed
14:30:07 <user317> Setup.hs: At least the following dependencies are missing:
14:30:07 <user317> HUnit >=1.2.0.0
14:30:07 <user317> ghc-pkg list | grep -i HUnit
14:30:07 <user317>     HSFFIG-1.1, HTTP-4000.0.6, HUnit-1.2.0.3, HUnit-1.2.2.0
14:30:34 <Berengal> user317, you using runhaskell Setup.hs or cabal install?
14:30:43 <dcoutts> user317: http://haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages
14:31:12 <dcoutts> Berengal: you can tell it's runhaskell because the error message says "Setup.hs: ..."
14:31:35 <dcoutts> otherwise it'd say "cabal: ..."
14:31:50 <copumpkin> spoken like a true connoisseur of cabal
14:31:51 <stanv> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11187#a11187
14:31:54 <hackagebot> GPipe 1.0.3 - A functional graphics API for programmable GPUs (TobiasBexelius)
14:31:56 <Berengal> dcoutts, that's what I thought, but I haven't memorized all cabal errors yet
14:32:12 <sinelaw> Berengal, get back to work then!
14:32:14 <dcoutts> Berengal: s'ok, not faulting you, just a tip to save time :-)
14:32:18 * sinelaw ducks
14:32:40 <Berengal> sinelaw, they don't happen often enough for me to learn them effectively :(
14:32:50 <sinelaw> excuses, excuses
14:37:18 <monochrom> any newbie?
14:37:28 <medfly> here, here!
14:38:03 <Berengal> Do you ever become a non-newbie?
14:38:09 <Twey> Heh
14:38:10 <copumpkin> not me
14:38:39 <monochrom> would be funny if someone replied with "monochrom: ask your real question"
14:39:05 <Twey> Heh
14:39:09 <Twey> Yes
14:39:53 <stanv> Saizan: I got it :)
14:39:53 <Codex_> I still can't understand this book :(
14:40:08 <monochrom> You understand the 3rd book you read.
14:40:15 <fnord123> hi all. sorry if im a bit ignorant but i
14:40:18 <fnord123> oops
14:40:25 <copumpkin> fnord123: we forgive you
14:40:33 <copumpkin> but you should work hard to overcome it
14:40:38 <copumpkin> ignorance is not acceptable!
14:40:46 <jmcarthur_work> ignorance is strength
14:41:05 <monochrom> dynamic type is slavery
14:41:07 * copumpkin feels an unnatural urge to say "war is peace"
14:41:16 <Berengal> We have always been at war with eurasia
14:41:17 <copumpkin> costrength is strength
14:41:26 <copumpkin> density is codensity
14:41:26 <fnord123> hi all. sorry if im a bit ignorant but i'm trying to figure out a useful data structure in haskell for storing a symbol table. I thought maybe a fingertree but I'm having difficulty implementing the Measure typeclass for strings so it works a bit like a map or hashmap. So maybe finger tree isn't what I want (?)
14:41:32 <edwardk_> copumpkin is pumpkin
14:41:40 <copumpkin> zomg edwardk_ is back!
14:41:41 <Berengal> copumpkin, comonads are monads?
14:41:44 <Cale> fnord123: Is there a problem with using a Data.Map?
14:41:46 <copumpkin> Berengal: indeed!
14:41:51 <edwardk_> Berengal: in an appropriate category, yes.
14:42:01 <copumpkin> edwardk_: we were just wondering where you'd disappeared to
14:42:09 <jmcarthur_work> it's an edwardk_!
14:42:25 <edwardk_> you invoked enough buzzwords to call me forth from the netherworld to wreak category theory once more upon this land.
14:42:27 <Berengal> edwardk_, what about coappropriate categories ;)
14:42:37 <Berengal> (categories of approriateness?)
14:42:39 <copumpkin> edwardk_: do you have a buzzword-sensing bot in here that summons you?
14:42:51 <edwardk_> i plead the fifth
14:42:59 <copumpkin> lol
14:43:09 <Codex_> edwardk_: can you explain us Kan Extensions?
14:43:09 * Berengal chuckled
14:43:17 <fnord123> Cale: no problem that I can see. Just that there's a lot of different map types in hackage
14:43:18 <edwardk> Codex_: sure, what do you want to know about them?
14:43:19 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:43:22 <copumpkin> Kan you explain us can Extensions?
14:43:44 <copumpkin> I Kan haz Extension?
14:43:48 <Codex_> edwardk: hmm, mostly about how they work. I couldnt understand the text in MacLane.
14:43:50 <Cale> fnord123: GHC comes with the library Data.Map, you should use that unless you have a specific reason to need anything else :)
14:44:34 <fnord123> ok. all the blog posts about fingertrees made me think it will solve all my problems and cook me breakfast.
14:44:37 <fnord123> :(
14:44:57 <edwardk> Codex_: have you seen my writeup on them?
14:45:08 <copumpkin> fnord123: oh, they will, but you don't necessarily need all that :P
14:45:08 <Codex_> no
14:45:16 <edwardk> Codex_: one sec. i'll go fish for it
14:45:18 <jmcarthur_work> fingertrees do cook you breakfast
14:45:37 <jmcarthur_work> fingertrees are probably my favorite data structure
14:45:40 <dolio> I've seen it, and I still don't really understand Kan extensions. :)
14:46:19 <edwardk> Codex_: http://comonad.com/reader/2008/kan-extensions/ -- start there, there are 2 more after that
14:46:37 <edwardk> codex: they at least cover the use of kan extensions in haskell.
14:46:43 <monochrom> Data.Map solves all your problems, cooks you breakfast, and sleeps with you the night before.
14:46:51 <edwardk> i have a library monad-ran in hackage that entirely consists of right kan extensions
14:46:55 <fnord123> going back in time!
14:47:02 <edwardk> i have to run though. unexpected meeting. will return shortly
14:47:50 <Codex_> edwardk: thanks.
14:47:59 <sinelaw> what's the syntax for importing a module ignoring some infix function?
14:48:07 <edwardk> codex: i should be back in a couple of hours though, and we could continue then
14:48:21 <Cale> fnord123: You could use fingertrees to construct your own implementation of Data.Map, but there's really no need.
14:48:30 <monochrom> import Prelude hiding ( (+) )
14:48:44 <sinelaw> ok
14:48:48 <fnord123> Cale: thanks for pointing me in the right direction
14:50:00 <harlekin> Does plugins build for ghc 6.10 yet?
14:54:51 <stanv> is it possible to ask expression type under `where` clause ?
15:01:39 <monochrom> No.
15:01:58 <Paczesiowa> would be great if you could ask about foo.bar type
15:02:05 <Paczesiowa> where foo x = ... where bar = ...
15:02:19 <Paczesiowa> (that first where is meta-where)
15:02:55 <stanv> without type qualification under 'where' program compiles and works well. If i supply type compilation fail :(
15:03:25 <Botje> then your type isn't waht you expect it to be :)
15:03:43 <Paczesiowa> stanv: try manual lambda lifting
15:04:17 <Paczesiowa> stanv: move your function to top-level, and add to it arguments that would normally come from its closure
15:04:59 <Baughn> Is it possible to export everything that's defined in a module /except/ one particular binding?
15:05:37 <Paczesiowa> Baughn: I think it's possible through another module
15:05:50 <Baughn> Paczesiowa: Too cumbersome. :/
15:05:51 <Paczesiowa> Baughn: it would have to import with hiding that thing, and reexport
15:06:11 <Paczesiowa> Baughn: macros?
15:06:51 <Baughn> Paczesiowa: It's not a common use-case for me. It'd just be nice to have syntax in ghc for it.
15:07:56 <Paczesiowa> road to hell is paved with "It'd just be nice to have syntax in (..) for it."
15:08:15 <copumpkin> lol
15:08:18 <Paczesiowa> remember perl!
15:09:09 <stanv> :(
15:10:34 <Baughn> Paczesiowa: Well, sure, but having a hiding(..) syntax for module lines is the obvious dual of having it for imports
15:11:42 <Paczesiowa> Baughn: all you need are dependent types:)
15:14:28 <patch-tag> What happs if on a windows box you run :m +System.PosixCompat.Files then getFileStatus somefile
15:14:45 <patch-tag> is this an error, or ok?
15:14:54 <sinelaw> is there a way to find which packages on hackage depend on package X?
15:15:16 <sproingie> there is no System.PosixCompat.Files on windows
15:15:31 <copumpkin> sinelaw: there's a hackage fork sitting somewhere with listings of those
15:16:45 <patch-tag> hm, ok.
15:17:07 <copumpkin> can't remember the URL though
15:17:21 <sinelaw> copumpkin, keywords i can search for?
15:17:55 <patch-tag> trying to figure out a way to port System.FilePath.Find to windows, at least the most interesting parts of it.
15:18:05 <copumpkin> sinelaw: http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html
15:18:23 <sinelaw> copumpkin, cool!
15:18:28 <copumpkin> sinelaw: looks the same, but if you click on each package, it lets you check who depends on it
15:18:57 <sinelaw> yeah, great. thanks,
15:20:35 <patch-tag> sproingie, if there is no System.PosixCompat.Files on windows, what is this? http://code.haskell.org/unix-compat/System/PosixCompat/Files.hsc    ... "On POSIX systems it re-exports operations "
15:20:35 <patch-tag> -- from "System.Posix.Files". On other platforms it emulates this
15:20:37 <patch-tag> -- operations as far as possible.
15:20:52 <sproingie> not something that comes with the platform
15:20:56 <sproingie> is what it is
15:21:55 <sproingie> should have figured it by the "Compat" part
15:22:39 <patch-tag> what I mean is, if you have code that depends on System.PosixCopat, it has a decent chance of running on windows, right?
15:22:56 <sproingie> certainly more than with Posix, sure
15:23:00 <patch-tag> as long as it doesn't use those bits as that are commented out with #if
15:27:09 <patch-tag> could someone on a windows box just tell me what happens when you do
15:27:12 <patch-tag> putStrLn . show . isDirectory =<<  getFileStatus "/home/thartman"
15:27:22 <patch-tag> after ghci, :m +System.PosixCompat.Files ?
15:32:01 <sproingie> *** Exception: getPermissions: does not exist (No such file or directory)
15:33:00 <sproingie> putStrLn . show . isDirectory =<<  getFileStatus "C:/windows"
15:33:01 <patch-tag> that's on an existing directory?
15:33:02 <sproingie> True
15:33:16 <patch-tag> that's good :)
15:38:06 <FunctorSalad> how is it possible that adding a type sig - the same one ghci gave me! - make class resolution fail?
15:38:19 <FunctorSalad> to be fair my class is pretty ridiculous
15:38:43 <lispy> do you need lexically scoped types?
15:39:07 <FunctorSalad> lispy: ScopedTypeVars? go them (but it shouldn't make any diff since I don't have annotations in the value)
15:39:09 <copumpkin> FunctorSalad: show us
15:39:11 <FunctorSalad> *got them
15:39:24 <copumpkin> you clearly have an answer to your question :P
15:39:30 <lispy> Also, if GHC was inferring a class it may not know what the full instance type is, just the class in question
15:39:54 <lispy> So the inferred type listed in a type check error may not be complete
15:40:09 <FunctorSalad> (if I add the right annotation in the value, it works)
15:40:09 <lispy> But if it's the type from -Wall, that is a different story..
15:40:36 <FunctorSalad> lispy: I mean there *was* no error without signature
15:40:54 <lispy> okay.  No error in that whole module?
15:40:59 <lispy> Hmm.
15:42:10 <FunctorSalad> yeah
15:43:06 <lispy> Then you'll have to show us the code; cabal update; cabal install pastepipe; cat FunctorSalad.hs | pastepipe
15:43:16 <FunctorSalad> just a second
15:44:31 <FunctorSalad> lispy: copumpkin : here in "ccAuto" http://code.haskell.org/~daniels/type-settheory/dist/doc/html/type-settheory/src/Data-Category.html
15:45:02 <copumpkin> ugh, what's the encoding on that?
15:45:03 <FunctorSalad> here's the full haddock http://code.haskell.org/~daniels/type-settheory/dist/doc/html/type-settheory/
15:45:07 <copumpkin> utf8 doesn't seem to work
15:45:25 <FunctorSalad> utf8 supposedly
15:45:42 <FunctorSalad> with utf8 at least the  work, but somehow it garbles some other chars
15:45:49 <copumpkin> oh, ok
15:45:50 * lispy runs away in fear
15:46:24 <lispy> Like what is this? ::
15:46:38 <lispy> Gibberish?
15:46:59 <FunctorSalad> I'll try hpaste
15:47:11 <lispy> ?hackage pastepipe
15:47:11 <lambdabot> http://hackage.haskell.org/package/pastepipe
15:47:36 <FunctorSalad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11189#a11189
15:47:42 <FunctorSalad> lispy: or "haste" :)
15:48:09 <FunctorSalad> great, works on hpaste
15:48:50 <FunctorSalad> the error occured in "idAuto" too, as you see I had to add a type sig right next to the "auto"
15:49:05 <FunctorSalad> auto is the method of "Fact"
15:49:11 <Baughn> "SessionKey <$> get <*> get <*> get <*> get" <-- So, I guess this is the sort of code I should be using generics for?
15:49:33 <FunctorSalad> here is Fact: http://code.haskell.org/~daniels/type-settheory/dist/doc/html/type-settheory/Type-Logic.html#t%3AFact
15:50:06 <copumpkin> :t \f -> join (join (liftM4 f))
15:50:07 <lambdabot> forall a3 a4 r (m :: * -> *). (Monad m) => (a3 -> a3 -> a3 -> a4 -> r) -> m a3 -> m a4 -> m r
15:51:10 <FunctorSalad> (look how many facts I have already :D)
15:54:08 <copumpkin> FunctorSalad: that looks cool
15:55:02 <FunctorSalad> copumpkin: yeah maybe I should upload it already and hope people with add lemmas ;) just too much stuff to prove
15:55:21 <hackagebot> FileManipCompat 0.13 - Port of Find function of FileManip lib for use on windows systems (ThomasHartman)
15:55:29 <copumpkin> yep :)
15:59:04 <gmaslov> is there a paper about the ST monad? i'm trying to figure out how it's implemented but the GHC implementation is just a wrapper around some kind of GHC# internal# crud#
15:59:23 <copumpkin> gmaslov: it's almost identical to IO
15:59:35 <jmcarthur_work> it *is* IO, isn't it?
15:59:42 <copumpkin> it only differs in the type
15:59:43 <jmcarthur_work> just a different type?
16:00:07 <Cale> gmaslov: What's more important than how it's implemented is what the computations in it mean. If you can figure that out, all sorts of implementations are obvious.
16:00:18 <gmaslov> i guess i'm looking for a pure implementation. specifically how STRefs are handled
16:00:40 <copumpkin> STRefs aren't pure
16:00:48 <Cale> gmaslov: There's a typing problem with trying to implement it entirely purely. You'll need some unsafe casting.
16:01:23 <Cale> You'd need to pass around a heap of values for variables which are at arbitrary types.
16:01:34 <gmaslov> i see. that's what i was looking for Cale
16:02:20 <Cale> But what's actually done is just allocating memory in the ordinary heap, and mutation is implemented with actual mutation.
16:06:09 <Cale> gmaslov: So, you could write an ST interpreter which used unsafePerformIO and IORefs to defer the typing problems too :)
16:06:25 <hackagebot> hs-ffmpeg 0.3.3 - Bindings to FFMPEG library (VasylPasternak)
16:06:27 <hackagebot> HStringTemplateHelpers 0.0.11 - Convenience functions and instances for HStringTemplate (ThomasHartman)
16:13:03 <dancor> installing ghc 6.10.4: installPackage: dist-install/: openNewBinaryFile: permission denied (Permission denied)
16:13:29 <blackdog> install with sudo?
16:13:36 <dancor> ya
16:13:43 <kolmodin> dons: ok, xmonad 0.9 should hit the gentoo rsync servers within 30 minutes. the commit was a bit hasty, but I hope it works
16:13:55 <dancor> if i don't have sudo i get a different copyFile error
16:14:01 <dancor> which makes sense
16:14:19 <blackdog> what are the permissions on dist-install?
16:14:24 <sm> kolmodin: ohh, I don't like the sounds of that :)
16:14:58 <kolmodin> :D
16:15:05 <kolmodin> well, I want to go to bed!
16:15:56 * Cale implements ST
16:16:11 <copumpkin> Cale: using what?
16:16:14 <blackdog> in soviet russia, ST implements Cale
16:16:20 <kolmodin> haha
16:16:21 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11191#a11191
16:16:26 <Cale> IO + IORef
16:16:31 <copumpkin> ah :)
16:16:32 <Cale> +unsafePerformIO
16:16:52 <Cale> gmaslov: ^^ that might interest you :)
16:17:34 <hackagebot> happs-tutorial 0.9.1 - A Happstack Tutorial that is its own web 2.0-type demo. (ThomasHartman)
16:18:51 <dancor> blackdog: ok chmod-ery fixed it!  not sure how that got wacky
16:19:43 <blackdog> dancor: it happens. my cabal setup is a bit screwy at the moment, i can't even cabal list except as root
16:20:47 <Cale> sudo chmod -R 000 /
16:21:06 <gmaslov> Cale: hah, nice. a different style than i'm used to though, all the work happens in execST rather than in (>>=)
16:21:18 <Cale> gmaslov: yeah
16:22:21 <dancor> can i exclude opengl in my haskell-platform install?
16:23:49 <gmaslov> well i've been working on and off at constructing a _pure_ "erlang-style message passing" monad for some time now, but the typing problem with STRef-a-likes puts a crimp in my plans. how else will i store the continuation from 'recv' for each process?
16:26:40 <Codex_> gmaslov: can you give more details?
16:33:07 <gmaslov> Codex_: hold on, let me throw something into hpaste
16:39:43 * aavogt is confused by the tabs in haddock's source code
16:47:47 <xle> hey all.. Just wondering what the most performance-optimum way would be to strip all leading and tailing whitespace from bytestring.lazy.char8?
16:48:11 <xle> my current idea is to dropWhile, then reverse, dropWhile again, reverse again, which feels awfully ineffective
16:49:18 <ddarius> xle: There is no perfect way.  You can try to process it chunk-wise to avoid extra work, but ultimately it isn't going to be nice.
16:49:55 <Cale> Doing anything to the end of a lazy stream is going to be a little ugly.
16:50:21 <xle> i see. well, actually the fields are going to be relatively short
16:50:49 <xle> in other words, i will be first splitting the input into several fields (like in CSV files), and then stripping those now-smaller fields from leading/trailing whitespace
16:51:09 <copumpkin> if it's a bytestring, it should be possible to be more efficient
16:51:39 <xle> copumpkin: yes it is bytestring.char8... i do also feel that there should be a smarter way
16:51:41 <copumpkin> well I guess if it's lazy, you can't do much
16:52:02 <copumpkin> if it's short fields, why are they lazy?
16:52:13 <xle> so I can read lazily from a very large file
16:52:23 <copumpkin> do the individual fields need to be lazy?
16:52:36 <xle> no, not really. i will be processing one line at a time
16:53:14 <copumpkin> because on a strict one, you can do a "sub-bytestring" with no extra space and in constant time
16:53:18 <xle> would converting to non-lazy bytestring somehow help before stripping?
16:53:23 <copumpkin> you just need to figure out where to start and stop
16:54:15 <xle> I see
16:54:34 <copumpkin> (strict bytestrings are represented as a pointer to a buffer with an offset and a length
16:56:15 <xle> i guess there is no really clean/elegant way to do this
16:56:25 <xle> thanks for the input, i will play around with it for a while :)
17:02:00 <copumpkin> I guess you can do it with lazy bytestrings too, sharing the underlying storage throughout the entire string
17:04:51 <blackdog> could always push the laziness down a layer and use bytestring-mmap:)
17:05:10 <copumpkin> hah
17:05:29 <blackdog> that way, you've got one big bytestring you can create substrings from at will
17:14:16 <mmorrow> Cale: ooh, fun
17:14:28 * mmorrow was scrolled up..
17:14:54 <mmorrow>  @the ST monard
17:15:27 <copumpkin> :o
17:15:34 <copumpkin> monards are awesome
17:15:45 <Cale> Ah, monard, a portmanteau of monoid and canard
17:18:51 <Codex_> cale: so monard has just one object?
17:19:57 <mmorrow> that would be a neat hack to integrate this (cooperative) scheduler with that gadt, and implement (cooperative) forkIO and blocking IO http://moonpatio.com/repos/Scheduler.hs
17:20:56 <mmorrow> where if you call some "blocking" function, and whatever it's doing would "block", the scheduler just sticks you in the wait queue, and jumps to someone else
17:21:27 <Paczesiowa> dcoutts: why all "->unfused" rules are commented out?
17:21:49 <mmorrow> that unsafeCoerce is unnecessary if the Task type is re-done to not have a return value
17:22:11 <Paczesiowa> dcoutts: well, not all, but map, replicate
17:22:30 <mmorrow> (which is what i would've done the first time around had i realized the trouble having them have a polymorphic return value causes)
17:23:59 <mmorrow> , runCont id (do (i,lbl) <- labelCC 7; when i (< 19378) (jump (i+4) lbl); return i)
17:24:01 <lunabot>  luna: Couldn't match expected type `()'
17:24:11 <mmorrow> , runCont id (do (i,lbl) <- labelCC 7; when (i < 19378) (jump (i+4) lbl); return i)
17:24:13 <lunabot>  19379
17:24:55 <gmaslov> mmorrow: you may be interested in a (pure, safe) monad transformer i wrote that does "python-style generators", i.e. 'yield :: y -> m r'; the monad's type depends on what it yields and what it expects to receive. i also wrote a round-robin scheduler as a test case =)
17:25:13 <mmorrow> gmaslov: cool
17:26:26 <mmorrow> gmaslov: the cool thing too is you can have schedulers scheduling schedulers and so on recursively
17:26:42 <gmaslov> mmorrow: ooh... hadn't thought of that...
17:27:54 <mmorrow> iirc being able to have hierarchical schedulers was talked about at one point for GHC, but i guess that either turned out to be too painful, or it got sidelined for some reason
17:28:39 <copumpkin> lack of personnel!
17:28:55 <mmorrow> it'd be neat if you could schedule a pool of forkIO threads or something
17:29:14 <mmorrow> some of which may be other schedulers scheduling their own pools ...
17:29:26 <dpratt71> hey Cale, how goes it? :)
17:29:58 <copumpkin> mmorrow: a scheduling monad!
17:30:24 <ivanm> mmorrow: come on, we have enough arguments about the scheduler for the linux kernel, and you want to be able to have optional schedulers for GHC as well? :p
17:30:25 <mmorrow> monard!
17:30:43 <gmaslov> i wonder if you could hijack (>>=) to make a monard for preemptive multitasking
17:30:46 <mmorrow> ivanm: GHC already has a scheduler, we just can't control it
17:30:56 <ivanm> yeah
17:31:10 <ivanm> hmmm.... what does a monard have/not have compared to a monad?
17:31:17 <gmaslov> an r
17:31:58 <mmorrow> gmaslov: that might be hard, since even haskell forkIO threads are really "cooperative", it's just that the yield() calls get compile in by ghc, since they can only happen at gc safe-points
17:32:00 <ivanm> functionality wise
17:32:23 <mmorrow> so from w/in haskell, they seem preemptive (if you're allocating)
17:32:53 <mmorrow> ivanm: it has an additional method, called yarrrr
17:33:40 <gmaslov> i imagine that every call of (>>=) would become a yield point
17:34:46 <mmorrow> gmaslov: that could be interesting, assuming one thread isn't spinning in some loop, and the other's doing replicateM 100000
17:35:38 <mmorrow> it seems like without some form of cooperative yield, you really do need real preemption
17:36:19 <mmorrow> but using signals would probably be touch with the rts
17:37:40 <ddarius> @google a poor man's concurrency monad
17:37:54 <lambdabot> http://citeseer.ist.psu.edu/45878.html
17:40:07 <copumpkin> ddarius, the human encyclopedia
17:40:14 <copumpkin>  / bibliography
17:41:27 <soduko> how can i use Haskelll to launch an application and send specific keys to it?
17:41:47 <copumpkin> soduko: sounds platform-specific
17:42:07 <stroan> soduko: GUI application?
17:42:20 <soduko> on windows there is a .NET API function to do that
17:42:26 <soduko> http://msdn.microsoft.com/en-us/library/system.windows.forms.sendkeys.aspx
17:42:34 <soduko> yeah im on windows
17:42:43 <copumpkin> @hackage hsdotnet
17:42:43 <lambdabot> http://hackage.haskell.org/package/hsdotnet
17:42:51 <soduko> stroan: yes GUI
17:42:51 <copumpkin> damn, I fail
17:43:02 <soduko> why fail?
17:43:03 <copumpkin> http://hackage.haskell.org/package/hs-dotnet
17:45:59 <soduko> nice
17:50:08 <Paczesiowa> are there binary packages of haskell-platfrom for linux/x86 ?
17:57:43 <copumpkin> preflex: seen edwardk
17:57:43 <preflex>  edwardk was last seen on #haskell 3 hours, 9 minutes and 36 seconds ago, saying: codex: i should be back in a couple of hours though, and we could continue then
18:05:30 <sebaseba> @quote
18:05:30 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
18:07:50 <SamB_XP> lol
18:08:08 <medfly> @quote
18:08:08 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
18:08:18 <medfly> :)
18:08:43 <SamB_XP> but did it *universe-consistancy* check ?
18:09:05 <hackagebot> happs-tutorial 0.9.2 - A Happstack Tutorial that is its own web 2.0-type demo. (ThomasHartman)
18:09:32 <Paczesiowa> where can I browse online ghc sources? (I need Ghc.List)
18:10:15 <SamB_XP> @google "GHC.List"
18:10:16 <lambdabot> No Result Found.
18:10:20 <SamB_XP> @google GHC.List
18:10:20 <lambdabot> No Result Found.
18:10:25 <SamB_XP> ergh ...
18:10:26 <ivanm> Paczesiowa: it's usually available from the online docs
18:10:32 <yitz> @google ghc darcs
18:10:33 <SamB_XP> @docs Ghc.List
18:10:34 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/DarcsRepositories
18:10:34 <lambdabot> Title: DarcsRepositories - GHC - Trac
18:10:34 <lambdabot> Ghc.List not available
18:10:40 <SamB_XP> @docs GHC.List
18:10:40 <lambdabot> GHC.List not available
18:10:44 <SamB_XP> aww :-(
18:11:03 <yitz> Paczesiowa: it's there ^^
18:11:12 <ivanm> Paczesiowa: slightly old version: http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/GHC-List.html
18:11:12 <Paczesiowa> yitz: yeah, thanks
18:12:33 <Paczesiowa> ivanm: thank you too:)
18:12:36 <wrwills> /msg NickServ VERIFY REGISTER wrwills xqfszqcvzyli
18:12:36 <wrwills>  
18:12:54 <SamB_XP> ivanm: can't you s/6.10.2/latest/ to get a newer one ?>
18:13:00 <SamB_XP> not that I expet it's changed any
18:13:18 <ivanm> SamB_XP: ummm, yeah :s
18:13:27 <yitz> wrwills: since this channel is logged, you had better change your password now. sorry.
18:13:46 <Paczesiowa> how can he remeber that?
18:13:48 <ivanm> SamB_XP: I didn't do that because I had tried to drop the /src/ bit as well to get the haddock page and it didn't work, so I didn't think to get the 6.10.4 source version on its own :s
18:14:08 <ivanm> Paczesiowa: most clients have a feature to do verification for you
18:14:15 <ivanm> so he'd probably just tell his client to remember
18:14:38 <wrwills> oops..
18:14:49 <SamB_XP> ivanm: huh, I'd have figured that was a verification cookie!
18:15:00 <SamB_XP> not an actual password
18:15:04 <wrwills> exactly
18:15:19 <wrwills> sorry for the interference
18:24:48 <Codex_> this category-extras module seems pretty nice.
18:28:24 <copumpkin> Codex_: yep :)
18:28:27 * byorgey waves hello to #haskell
18:28:35 <copumpkin> ohai byorgey
18:32:44 * ivanm waves back to byorgey 
18:32:50 <maciej`> hello
18:32:57 <maciej`> anyone with HaXml experience?
18:34:23 <Codex_> copumpkin: do you know if there is a pullback implementation available somewhere in it or somewhere else? (should probably work based on Ran -> limits -> pullbacks )
18:35:27 <copumpkin> Codex_: not that I know of
18:35:35 <copumpkin> but it's huge and I can't say I've explored the entire module
18:35:38 <copumpkin> I mean package
18:36:26 <FunctorSalad> Codex_: there are no pullback types in Haskell, at least not in the sense of a pullback of two value-level functions
18:36:34 <FunctorSalad> (that would be dependent types)
18:36:52 <FunctorSalad> you can take the pullback of two "type-level functions" though ;)
18:40:30 <Codex_> but can't it be done by creating product type, and then taking subset of that. Like AxB->2 which returns true where the diagram commutes.
18:41:24 <FunctorSalad> it'd be a subtype defined in terms of /values/
18:41:36 <FunctorSalad> types never depend on values in haskell
18:46:15 <Codex_> well, you don't need dependent types if you don't provide the actual Ax{C}B, but instead provide AxB and AxB->2 { return f(pi(a,b))==g(pi_2(a,b)); }
18:47:57 <nicholas_> hey everybody!
18:54:49 <Codex_> then all we need is ability to enumerate all elements of a type, and we can represent exactly pullbacks :)
18:57:40 <copumpkin> Codex_: I wrote a module for that! :P
19:01:57 <Crappytoilet> luckytoIlet! welcome back! we must be long lost cousins!
19:02:28 <luckytoiIet> yeah lol
19:02:49 <luckytoiIet> so what are your feelings about haskell?
19:02:53 <copumpkin> @where ops
19:02:53 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:03:07 <mauke> gentlemen.
19:03:13 <copumpkin> both on web IRC
19:03:28 <blackdog> copumpkin: an air of quiet menace there...
19:03:32 <copumpkin> joining within a minute or two of one another :)
19:03:35 <copumpkin> with similar nicks
19:03:39 <copumpkin> commenting on each other's similar nicks
19:03:53 <luckytoiIet> nothing suspicious here...
19:03:54 <copumpkin> let me guess that they find a way to tie their nicks to haskell O:-)
19:04:52 --- mode: ChanServ set +o dibblego
19:05:01 --- kick: luckytoiIet was kicked by dibblego (dibblego)
19:05:04 --- kick: Crappytoilet was kicked by dibblego (dibblego)
19:05:19 <Axman6> uh
19:05:22 <Axman6> what?
19:05:47 * Axman6 is VERY strongly of the mind that people should not be punished unless they have actually done something
19:05:50 * Cale wonders if that was actually necessary...
19:05:52 <Cale> yeah
19:06:03 <dibblego> ah sorry thought it was bots
19:06:04 <medfly> they haven't actually trolled much yet :)
19:06:05 <Axman6> i do not like how this channel has been run lately
19:06:18 <Axman6> they haven't trolled at all imo
19:06:22 <SamB_XP> Axman6: I know what you mean
19:06:23 <pumpkonic> now kick copumpkin for having a similar name
19:06:52 <SamB_XP> pumpkonic: actually, we're going to kick aavogt for being such an ass
19:07:04 <aavogt> heh
19:07:18 <ivanm> well, the two of them didn't have similar IPs, etc.
19:07:24 <ivanm> so they might not have been the same person
19:07:34 <SamB_XP> ivanm: uh, look at the nickmask!
19:07:39 <SamB_XP> whatever
19:07:52 <SamB_XP> The username "aavogt" seems like a pretty good clue ...
19:08:01 <ivanm> SamB_XP: I'm referring to the toilets
19:08:14 <aavogt> SamB_XP: I was framed!
19:08:15 <ivanm> one was connected directly, the other via a web client
19:08:18 * dibblego woopses
19:08:26 <SamB_XP> ivanm: they have talking toilets now ?
19:08:31 --- mode: dibblego set -o dibblego
19:08:32 <mauke> they were both webbed
19:08:43 <ivanm> SamB_XP: the two people dibblego kicked...
19:09:00 <ivanm> copumpkin: don't call in the ops strike force until they're needed!
19:09:13 <luckytoiIet> thanks
19:09:14 <ivanm> mauke: maybe, but different clients then
19:09:28 <copumpkin> ivanm: I generally feel it's good to have someone paying attention in case someone starts spamming, rather than calling them after the fact
19:09:38 <copumpkin> so they can catch it before it gets out of control
19:10:11 <aavogt> SamB_XP: thanks for pointing that out though, so I'll be more careful when trolling
19:10:22 <SamB_XP> lol
19:10:54 <SamB_XP> aavogt: how often do you do that ?
19:11:31 <aavogt> SamB_XP: clearly not often enough, otherwise I wouldn't show nick mask
19:12:03 <SamB_XP> how can you not troll often enough ?
19:12:54 <aavogt> SamB_XP: often enough being often enough to do it right?
19:13:12 <dibblego> luckytoiIet, sorry mate, I thought it was a bot attack
19:14:38 <SamB_XP> dibblego: isn't that when lambdabot won't do this?
19:14:39 <SamB_XP> @bot
19:14:39 <lunabot>  :o
19:14:40 <lambdabot> :)
19:14:48 <I_am_god> so how is the haskelling folks?
19:14:57 <ivanm> SamB_XP: heh
19:15:04 <ivanm> nah, it's when lunabot and lambdabot start fighting
19:15:06 <ivanm> @slap lunabot
19:15:07 * lambdabot smacks lunabot about with a large trout
19:15:09 <ivanm> ^^ like that!
19:17:25 <`core> wait for the jar to break: http://xrl.us/o2em6
19:17:53 --- mode: ChanServ set +o Cale
19:17:53 <copumpkin> wow
19:17:57 <copumpkin> and now we get trolled after all
19:18:01 --- mode: Cale set +b *!*@or-69-68-252-13.dyn.embarqhsd.net
19:18:01 --- kick: `core was kicked by Cale (Cale)
19:18:07 --- mode: Cale set -o Cale
19:18:36 <copumpkin> this all feels fairly suspicious still
19:18:36 <lucytoilet> i am god
19:18:36 <luckeytoilet> no i am god
19:18:44 <copumpkin> heh
19:18:45 <ivanm> *groan*
19:18:58 <ivanm> copumpkin: right, now we are having a toilet attack
19:19:07 <copumpkin> Axman6: may we kick them now?
19:19:14 <ivanm> please!
19:19:29 <copumpkin> Axman6: or must we wait for them to start spamming more intensely?
19:19:30 <lucytoilet> we love being kicked! =D
19:19:30 <luckeytoilet> cmon kick us please!
19:20:30 <Axman6> -_-
19:20:59 <luckytoiIet> hmm they should introduce toilets into haskell, they're a new type of list where the contents get screwed up and mixed around randomly like a toilet
19:21:25 <aavogt> @hackage acme-now
19:21:25 <lambdabot> http://hackage.haskell.org/package/acme-now
19:21:29 <copumpkin> (Axman6: for what it's worth, I've been an IRC op for a couple of years on another network and have quite a bit of experience telling when things like this are about to happen)
19:22:03 <ivanm> Axman6: the fact that he's a seppo probably helps him pick up on toilet spam... :p
19:22:10 <copumpkin> indeed!
19:22:18 <ivanm> thunderboxes and all!
19:22:21 <Axman6> copumpkin: me too, but i still prefer to wait until someone does something wrong before reacting.
19:22:23 <jre2> seppo?
19:22:32 <prof_nimnul> let's talk about something functional instead ;) is there any reason for a total language to use call by need reduction order?
19:22:41 <SamB_XP> jre2: septic tank
19:22:42 <SamB_XP> evidently
19:22:52 <copumpkin> prof_nimnul: behavior won't change, but speed might
19:22:53 <luckytoiIet> lol
19:22:59 <ivanm> which rhymes with yank
19:23:28 <SamB_XP> ivanm: what is this, some kind of meme ?
19:23:44 <luckytoiIet> http://hackage.haskell.org/package/toilet
19:23:54 <luckytoiIet> it actually exists wow lol
19:24:15 <copumpkin> we have a sense of humor :)
19:24:29 <ivanm> SamB_XP: australian rhyming slang
19:25:02 <jre2> somehow a toliet package doesn't faze me after finding out about the loli package the other night..
19:25:13 <ivanm> jre2: read why there's a toilet package
19:25:24 <ivanm> and then you'll realise it's an absolutely useless package to have
19:26:17 <prof_nimnul> copumpkin: are there any works on optimizers changing evaluation order from normal to applicative and back? I have only seen works about strictness analysis, but in total language there are no such thing as strictness
19:26:36 <copumpkin> not sure :) I'm a newbie still
19:26:37 <luckytoiIet> pupils from the same country may exchange information [in the toilet] wtf?
19:26:46 <I_am_god> will haskell ever be an os for mad64?
19:26:49 <I_am_god> amd64
19:26:57 <prof_nimnul> it is already
19:26:57 <ivanm> no
19:27:02 <copumpkin> an OS?
19:27:05 <copumpkin> haskell isn't an OS
19:27:05 <ivanm> because Haskell is a programming language, not an OS
19:27:10 <SamB_XP> ivanm: it seems like it was useful to the IMO toilet organizers!
19:27:12 <copumpkin> although parts of the RTS may behave like parts of an OS
19:27:14 <jre2> you mean House?
19:27:30 <ivanm> SamB_XP: right, but useful enough to put it up on hackage? :s
19:27:49 <SamB_XP> well, why not ?
19:28:00 <SamB_XP> what is this, wikipedia ?
19:28:00 <infinite-toilet> everything on hackage is shit anyways
19:28:14 * copumpkin sighs
19:28:15 <luckytoiIet> haha toilet shit...
19:28:16 <ivanm> dibblego: OK, we keep getting toilet links, maybe you should get rid of them
19:28:27 <copumpkin> dibblego: don't forget to take back your apology
19:28:28 <medfly> are we letting toilet guy troll to justify his previous kick :)
19:28:28 <SamB_XP> only because there aren't any dependant types ...
19:28:46 <dibblego> I'm having no part of it, someone else cna deal with it :)
19:28:47 <infinite-toilet> they belong in toilets!
19:28:55 <copumpkin> @where ops
19:28:56 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:28:57 <dibblego> *dependent
19:28:58 <copumpkin> :P
19:28:59 <SamB_XP> medfly: the theory was that we didn't know they were up to no good, yet
19:29:03 <luckytoiIet> i already have the toilet package
19:29:15 <copumpkin> I guess these trolls aren't terribly disruptive
19:29:20 <infinite-toilet> imma make a toilet monad!
19:29:38 <copumpkin> infinite-toilet: I get how return works, but how about join/bind?
19:29:41 <medfly> they're probably Haskellers anyway :)
19:29:49 <SamB_XP> yeah, they aren't up to much bad ...
19:29:53 <medfly> infinite-toilet, mibbit isn't anonymous
19:30:05 <ivanm> I thought mibbit was banned from freenode...
19:30:11 <SamB_XP> ivanm: it IS :-(((
19:30:11 <ivanm> for precisely this reason...
19:30:12 <copumpkin> but he's still going through a vps
19:30:17 <ivanm> ahhh
19:30:18 <medfly> okay
19:30:21 <medfly> webchat isn't
19:30:23 <medfly> whatever it is :)
19:30:25 <ivanm> SamB_XP: eh, mibbit's ads pissed me off anyway
19:30:30 <copumpkin> we had another random troll last night too
19:30:35 <SamB_XP> well, I liked the options thing
19:30:44 <copumpkin> came in here and just said that GHC sucked **** and said the same in #ghc
19:30:59 <medfly> what is ****?
19:31:06 <ivanm> sjanssen_: if you're here, can you use your almight ops powers to ban the toilets?
19:31:06 <medfly> I'm trying to guess
19:31:06 <infinite-toilet> but GHC is a compiler and it has no mouth :(
19:31:08 <copumpkin> medfly: up to your imagination :)
19:31:10 <SamB_XP> I'm guessing "dick"
19:31:14 <medfly> ooh, okay
19:31:20 <copumpkin> infinite-toilet: that's what I told him! are you he?
19:31:21 <ivanm> copumpkin: I remember him saying the first I think
19:31:22 <SamB_XP> because "ass" is a three letter word
19:31:29 <medfly> I should remind myself about the rule that if I don't get a joke, it's probably about sex
19:31:47 <aavogt> copumpkin: you break the inner one up, and flush it down the outer (sort of like Maybe)?
19:31:51 <medfly> or anything of that sort :-)
19:31:57 <Axman6> infinite-toilet: please troll better, no one's paying attention
19:32:03 <copumpkin> aavogt: smart!
19:32:34 <infinite-toilet> axman6: i'll try :)
19:32:46 <Axman6> thank you
19:32:50 <SamB_XP> GHC has no mouth?
19:32:57 <SamB_XP> well, TeX can lend it one, maybe ?
19:33:00 <copumpkin> SamB_XP: that was my response to yesterday's troll
19:33:10 <ivanm> TeX has a mouth?
19:33:11 <oozeperson> well you can feed it dick instead of haskell code :)
19:33:25 <allbery_b> and it must scream?
19:33:43 <SamB_XP> ivanm: I seem to remember having seen it mentioned in TeX the Program, yes ...
19:33:43 <infinite-toilet> no it will happily suck on it :)
19:33:43 <infinite-toilet> therefore it sucks dick
19:34:25 <Axman6> copumpkin: btw, well done with that troll in #ghc the other day whinging that GHC didn't run on ARM
19:34:32 <Axman6> or, compile for arm
19:34:35 <Axman6> or whatevs
19:34:50 <SamB_XP> Axman6: that's a wierd thing to claim ...
19:34:58 <aavogt> are there other interesting operators in haskell that aren't mentioned here: http://haskell.org/haskellwiki/Pointfree#Combinator_discoveries
19:35:09 <SamB_XP> (or does it really not support ARM ?)
19:35:09 <copumpkin> Axman6: yeah, that's the one I'm talking about! who said GHC sucked **** :)
19:35:21 <copumpkin> SamB_XP: only unregistered, but he didn't seem to appreciate me telling him that
19:35:22 --- mode: ChanServ set +o sjanssen
19:35:26 <copumpkin> his response was "GHC sucks ****"
19:35:30 <ivanm> Axman6: yeah, that sounds right
19:35:45 <SamB_XP> copumpkin: yeah, the registered version has less features -- it's unshareware!
19:35:56 <ivanm> Axman6: I'm still trying to work out why he wanted to write Haskell on a PDA that was over 3 years old anyway...
19:36:03 <luckytoiIet> how about GHC on Z80?
19:36:31 <SamB_XP> ivanm: evidently, you don't need to upgrade ARM machines more than once per decade?
19:36:31 <infinite-toilet> yea then we can program haskell secretly in class!
19:36:39 <Axman6> ivanm: eh?
19:36:49 <SamB_XP> at least, that's what I saw on this pro RISC-OS page earlier today
19:36:56 <ivanm> Axman6: the ARM chip he was talking about was made in 1996 for PDAs
19:36:57 <copumpkin> ivanm: ARM is the iPhone's CPU, as well as most other modern smartphones
19:36:59 <sjanssen> so what's going on here?
19:37:13 <copumpkin> sjanssen: we have some undecided trolls trying to decide how to troll
19:37:20 <copumpkin> but generally just being silly for now
19:37:22 <ivanm> Axman6: it wasn't even a standard ARM chip (precursor to XScale, wasn't fully compatible with ARM proper)
19:37:24 <prof_nimnul> Z80 is a powerful beast.. What about PIC and MCS-51? ;-)
19:37:35 <Axman6> sjanssen: poor attempts at trolling. nothing to worry about
19:38:06 <blackdog> PIC would be interesting. i sort of thought about trying to write a little compiler while i was in Doha
19:38:06 <SamB_XP> sjanssen: yeah, too boring to actually count as a troll
19:38:18 <ivanm> blackdog: where's Doha?
19:38:24 <copumpkin> qatar
19:38:25 <ivanm> SamB_XP: just irritating :s
19:38:29 <ivanm> copumpkin: ahhh
19:38:40 <blackdog> mostly because the PicBasic compiler silently crapped out on moderately complicated arithmetic expressions
19:38:48 <copumpkin> @where+ Doha Qatar
19:38:49 <lambdabot> I will never forget.
19:39:10 <blackdog> copumpkin: I'm impressed, btw. I usually just say "a little country next to Saudi Arabia"
19:39:16 <copumpkin> :)
19:39:21 <blackdog> were you using the Power of the Interwubs?
19:39:24 * copumpkin is fairly "international"
19:39:25 <copumpkin> nope
19:39:37 <copumpkin> I have a friend there
19:39:47 <blackdog> hm. oil company or teacher?
19:39:54 * blackdog generalises grossly
19:39:56 <copumpkin> neither, a student
19:40:02 <copumpkin> surprisingly, two major american universities have campuses there
19:40:12 <Axman6> which are?
19:40:15 <copumpkin> my friend actually grew up in kuwait
19:40:19 <copumpkin> cornell and cm
19:40:20 <copumpkin> CMU
19:40:20 <blackdog> yeah, I stayed with a professor there for a while after the asian games ended
19:40:52 <Axman6> blackdog: did i ever tell you about dealextreme.com?
19:40:52 <blackdog> copumpkin: georgetown is there too.
19:40:53 <allbery_b> Doha is home to Qatar's "university center", there's more than just MIT and CMU there last I heard
19:41:02 <copumpkin> ah
19:41:06 <blackdog> Axman6: don't believe so
19:41:10 <copumpkin> here comes another toilet, *sigh*
19:41:21 <allbery_b> big dedicated area with, for example, slightly relaxed clothing rules to accommodate foreigners
19:41:23 <SamB_XP> he's REALLY going to complain about ARM now ;-P
19:41:29 --- mode: ChanServ set +o dibblego
19:41:37 <armtoilet> sure
19:41:42 <fxr> how can I give two maybes to an IO computation as arguments iff they all have Just a?
19:41:42 --- kick: armtoilet was kicked by dibblego (dibblego)
19:41:44 <Axman6> blackdog: well, check it out, and if you can find $50US (i think, possible australia) worth of stuff to buy there, and use paypal, paypal will give you $20 back
19:41:46 * SamB_XP makes jokes about Zelda
19:41:57 <copumpkin> fxr: sounds like you want a transformer, maybe
19:42:02 <dibblego> fxr, how can you be sure they have Just values?
19:42:07 <Axman6> possibly*
19:42:07 <SamB_XP> (Remember the toilet in the Stockpot Inn?)
19:42:09 <ivanm> Axman6: ooohhh.... except I don't use paypal ;-)
19:42:15 --- mode: dibblego set +b *!n=armtoile@76.73.16.*
19:42:17 <Axman6> spews for you :)
19:42:18 <fxr> I don't want to write nested cases
19:42:21 <blackdog> Axman6: First thing is that this is DEFINITELY not pyramid selling
19:42:35 <infinite-toilet> Buy a toilet today! They're very cheap!
19:42:39 <Axman6> blackdog: ?
19:42:41 <dibblego> fxr, how are you sure you have Just values?
19:42:44 --- mode: dibblego set +b *!i=40834e47@*gateway/web/freenode/x-xblynpoibvqegjje
19:42:45 <copumpkin> infinite-toilet: you can do better than that
19:42:52 <Axman6> http://www.paypal-offers.com.au/shopoverseas/ for more details
19:43:12 * ManateeLazyCat pasted "Apply maybe functions" at http://paste2.org/get/485827
19:43:12 <SamB_XP> Axman6: that doesn't look good
19:43:16 <SamB_XP> it's not paypal.com
19:43:16 <copumpkin> armtoilet: for future reference, the best trolls are those who sound legitimate and can come up with semicoherent arguments that just piss a lot of people off
19:43:17 <blackdog> Axman6: a quote from PeepShow
19:43:20 <ManateeLazyCat> fxr: How about above http://paste2.org/get/485827 ?
19:43:39 <fxr> dibblego: I'm not sure, if one of them Nothing I want Nothing.
19:43:55 <ManateeLazyCat> fxr: I use http://paste2.org/get/485827 functions to handle maybe, but don't create Nothing branch.
19:44:12 <dibblego> fxr, then perhaps you want sequence? where does IO come into it?
19:44:16 * Axman6 is struggling to find $50 worth of stuff he wants :*
19:44:21 <Axman6> :(*
19:44:21 <allbery_b> hm, MaybeT is on Hackage, use MaybeT IO?
19:44:41 <allbery_b> with a lift for the IO action at the end?
19:44:44 <fxr> well it is such a call "put db k v" which returns IO Bool
19:44:48 <blackdog> Axman6: sorry mate, can't browse now. too busy wrestling with Ruby's deeply confused object system
19:44:55 <sa1100toilet> testing
19:44:59 <fxr> I'm getting k and v via a Trie.lookup
19:44:59 <ManateeLazyCat> fxr: If you just want save typing for Maybe, see code in http://paste2.org/get/485827
19:45:03 <blackdog> the inheritance diagram is cyclic :/
19:45:14 --- mode: dibblego set +b *!n=sa1100to@76.73.16.*
19:45:55 <fxr> ManateeLazyCat: I'm looking at it. I just wanna know if it is possible for an  applicative style
19:46:46 <newdog273> hey not nice
19:46:49 <ivanm> Axman6: so you're boosting foreign economies?
19:46:52 <ManateeLazyCat> fxr: I use Monad implement those functions, never try to use applicative style.
19:47:17 <Axman6> ivanm: paypal's boosting mine
19:47:41 <ManateeLazyCat> fxr: I found in some functions, i need write nested Maybe, but Nothing branch i never use, so i wrote those functions applyMaybe* for save finger.
19:47:42 <ivanm> heh
19:47:51 <copumpkin> newdog273 is another one
19:47:53 <copumpkin> *sigh*
19:48:09 <copumpkin> I think they're slowly piling up and not being obnoxious so that we don't kick them and they can blast us later
19:48:17 <ivanm> newdog273: why don't you understand that we're not really appreciating your garbage...
19:48:20 <copumpkin> most of them even connect from the same IP
19:48:23 <newdog273> be nice...i'm on an ARM gees
19:48:31 --- mode: dibblego set -b *!n=sa1100to@76.73.16.*
19:48:36 <ManateeLazyCat> fxr: Just apply `Just` branch of Maybe, and return same type in `Nothing` branch.
19:48:44 --- mode: dibblego set -b *!i=40834e47@*gateway/web/freenode/x-xblynpoibvqegjje
19:48:44 --- mode: sjanssen set +b *!*=newdog27@76.73.16.*
19:48:44 --- kick: newdog273 was kicked by sjanssen (sjanssen)
19:48:54 --- mode: dibblego set -b *!n=armtoile@76.73.16.*
19:49:17 <fxr> yeah got it
19:49:23 <fxr> thanks
19:49:33 <ManateeLazyCat> fxr: Of course, i think you can implement those functions with applicative code.
19:50:27 <ManateeLazyCat> fxr: NP :)
19:54:41 <aavogt> ManateeLazyCat: what is the type of this applyMaybe*
19:54:45 <fxr> oh hpaste broken?
19:54:57 <ManateeLazyCat> aavogt: http://paste2.org/get/485827
19:55:32 <fxr> http://paste2.org/p/485836 here is my case
19:56:10 <aavogt> ManateeLazyCat: many of those are standard library functions. applyMaybeM is traverse
19:56:16 <BMeph> Is Maybe2 defined/used in any package, or is it just in the GHC UG as an example? :)
19:56:39 <aavogt> applyMaybeT == (=<<)
19:57:55 <ManateeLazyCat> aavogt: Just want same style name for those functions. :)
19:58:43 <fxr> I think I used pattern matching to select if all are Just values
19:58:55 <Cale> fxr: Perhaps you're looking for liftM3 or mapM in Maybe?
19:59:05 <Cale> > liftM3 (,,) (Just "a") (Just "b") (Just "c")
19:59:06 <lambdabot>   Just ("a","b","c")
19:59:24 <Cale> (you can replace (,,) there with another function)
19:59:28 <aavogt> @type Data.Traversable.traverse (undefined :: (a -> m (Maybe b)))
19:59:29 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t a -> f (t (Maybe b))
19:59:51 <aavogt> hmm, needs a fmap join in there
20:00:15 <fxr> Cale: exactly :)
20:19:26 --- mode: irc.freenode.net set +o sjanssen
20:19:26 --- mode: irc.freenode.net set +o dibblego
20:22:58 <fxr> oh yeah what a nested world
20:23:51 <fxr> it's time to test
20:41:38 <hexpuem> is there any way to avoid having a type parameter make every encapsulating type have to have the same parameter
20:41:41 <hexpuem> without existentials
20:42:26 <ivanm> hexpuem: what do you mean?
20:42:38 <hexpuem> like if type A has a parameter and type B has type A as a member
20:42:43 <hexpuem> B now has to have the parameter
20:43:18 <ivanm> still not following
20:43:23 <ivanm> can you provide a code example?
20:43:28 <hexpuem> yea sec
20:44:22 <aavogt> data A a = A x y z a -- is allowed to have (B w) as the variable a
20:45:00 <aavogt> or are the 'w' types not supposed to affect the type of A
20:45:14 <hexpuem> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11196#a11196
20:45:37 <hexpuem> because Chromosome has a parameter everything else has to have one
20:45:47 <ivanm> hexpuem: ahhh
20:45:52 <ivanm> nah, can't get around that AFAIK
20:45:54 <hexpuem> even when they dont really care about the type inside
20:46:00 <hexpuem> just that its part of a Seq
20:46:06 <ivanm> hexpuem: they do; they care about the type of Chromosome
20:46:23 <ivanm> hexpuem: if you want it to have a generic chromosome, your only other option is a forall
20:46:42 <ivanm> hexpuem: however, if you decide that for Generation you only care about "Chromosome Int", then you can specify that and not have the type parameter
20:47:04 <hexpuem> with forall the problem is when i crossover two chromosomes
20:47:24 <hexpuem> crossover in this case just takes first half of the first list and glues it to the second
20:47:27 <hexpuem> so the type inside doesnt really matter
20:47:38 <hexpuem> but it complains because they could be two different kinds of chromosomes
20:47:54 <aavogt> well are there going to be two different types of chromosomes?
20:48:03 <hexpuem> not at the same time
20:48:11 <aavogt> then what you're doing is right
20:48:34 <hexpuem> but i dont want to type the damn type parameter everywhere haha
20:48:51 <aavogt> then don't define so many 'type'
20:49:33 <hexpuem> is there anything interesting i can do with type families or something
20:49:57 <aavogt> data Genome a = Genome { rating :: Double, chromosome :: Seq a } -- there, one less time you have to write 'a'
20:50:22 <aavogt> actually two times
20:50:24 <hexpuem> yea but the code elsewhere has Chromosomes as parameters
20:50:28 <hexpuem> which is clearer than Seq a
20:50:38 <hexpuem> and Genomes etc
20:52:13 <aavogt> hexpuem: leave the type signatures out?
20:52:24 <aavogt> if they are that much trouble to write
20:53:16 <hexpuem> its not really a big deal, was just wondering if there was a way around it
21:00:35 <hgolden> I hope dcoutts__ is a bot!
21:00:55 <ivanm> probably remote connections trying to stay connected
21:31:31 <jimmyjazz14> Anyone have any info on creating derivable type classes?
21:31:57 <jimmyjazz14> or possibly an alternative
21:32:10 <jmcarthur> template haskell
21:32:19 <jmcarthur> (is an alternative)
21:32:59 <jimmyjazz14> jmcarthur: yeah I was thinking about, know of any good guides on using template haskell?
21:33:12 <jmcarthur> nope. never written TH functions myself, only used them
21:33:14 <jimmyjazz14> it been a bit difficult to find good documentation on it
21:34:31 <c_wraith> It is, but it's pretty easy when you get the hang of it.
21:37:28 <c_wraith> Here's the bit of TH code my app is currently using:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11197#a11197
21:45:17 <travisbrady> how do I sort a list of lists by multiple attributes?
21:47:25 <prof_nimnul> travisbrady: Data.List.sortBy
21:48:18 <travisbrady> prof_nimnul: that part i know, but constructing the comparator is the hard part
21:48:39 <travisbrady> i'd like to have this be dynamic, so at runtime I can pass a list of column indices to pass
21:49:12 <travisbrady> nix the last 'to pass'
21:49:46 <c_wraith> travisbrady:  What's the type you'd like?  Ord a => [Int] -> [a] -> [a] -> Ordering    ?
21:50:04 <tommd> @hackage gps
21:50:04 <lambdabot> http://hackage.haskell.org/package/gps
21:51:39 <ivanm> @hackage non-existant-package
21:51:40 <lambdabot> http://hackage.haskell.org/package/non-existant-package
21:51:52 <ivanm> ;-)
21:51:57 <ivanm> oh, gps is real :s
21:52:07 <ddarius> ivanm: I haven't announced non-existant-package yet.
21:52:17 <sjanssen> :t sortBy . mconcat . map (comparing . flip (!!))
21:52:18 <lambdabot> forall a. (Ord a) => [Int] -> [[a]] -> [[a]]
21:52:19 <ivanm> ddarius: shhh!
21:52:26 --- mode: ChanServ set -o sjanssen
21:53:01 <sjanssen> Haskell is fun :)
21:53:05 <hackagebot> gps 0.3.0 - For manipulating GPS coordinates and trails. (ThomasDuBuisson)
21:53:21 <c_wraith> :t mconcat . map (comparing . flip (!!))
21:53:22 <lambdabot> forall a. (Ord a) => [Int] -> [a] -> [a] -> Ordering
21:54:51 <Elly> @botsnack
21:54:51 <lambdabot> :)
21:54:52 <lunabot>  :o
21:54:55 <ivanm> tommd: it's cheating to use @hackage to search for your own package before hackagebot finds it! ;-)
22:13:07 <tommd> ivanm: I know, but there was something odd and hackage wasn't listing my gps package at all, so I was a bit concerned and wanted to see the entry.
22:15:41 <ivanm> hmmm.... is there a "/dev/null" handle equivalent? i.e. it will accept anything but not actually store it
22:16:14 <ivanm> (or, how do I write such a thing)
22:16:43 <Cale> ivanm: You could openFile on /dev/null
22:16:53 <ivanm> if I need Handle -> IO (), is const (return ()) good enough?
22:17:15 <ivanm> Cale: yeah, but that then isn't really cross-platform (not that I know how cross-platform the rest of my code is...)
22:17:20 <Cale> It's the right type, but who knows if it's really what you want? :)
22:17:24 <ivanm> heh
22:17:47 <ivanm> Cale: I'm expecting zero output anyway, so *shrug*
22:17:59 <Cale> hmm
22:18:15 <Cale> With the new IO system in 6.12, you'd be able to create a handle like that.
22:19:01 <Cale> (as well as many other sorts of cool things :)
22:19:23 <ivanm> hgolden: ^^ see? cool things! that's why we can't be worried about backwards compatability all the time! :p
22:19:47 <Cale> pff, who cares about backwards compatibility?
22:20:02 <dilinger> that's for write-once code :)
22:20:07 <lispy|web> Cale: are you saying I'm fat?
22:20:12 <ivanm> Cale: apparently enterprise does
22:20:17 <ivanm> (whatever that means...)
22:20:20 <ivanm> lispy|web: yes, yes he is
22:20:21 <ivanm> ;-)
22:20:25 * lispy|web cries
22:20:28 <Cale> ivanm: Yeah, the enterprisey guys and people who want the language to be overly successful.
22:20:52 <lispy|web> overly successful or overly stressful?
22:21:04 <Cale> Success is not the true success.
22:21:16 <dilinger> very zen
22:22:45 <Elly> The monad that can be named is not the true monad.
22:22:58 <lispy|web> anonymous monads?
22:24:24 <ivanm> Cale: hmmm... seems to work... (using const (return ()) for the handle function)
22:24:59 <luite> if I compile my program (which uses some ffi) with: ghc --make -lstdc++ -lCoinUtils -lClp Test.hs Lp/lp.o   , how should I load Test.hs in ghci
22:27:07 <luite> using: ghci -lstdc++ -lCoinUtils -lClp Test.hs Lp/lp.o   results in: : Unknown PEi386 section name `/22' (while processing: Lp\lp.o)
22:27:21 <luite> (this is on win32)
22:33:57 <c_wraith> :t Success
22:33:58 <lambdabot> [(String, Int)] -> Result
22:34:09 <c_wraith> Well, now we know what Success is.
22:34:14 <lispy|web> luite: I'm not sure you should be linking in the stdc++ lib manually.  What about using cabal instead?
22:34:28 <lispy|web> c_wraith: haha
22:35:06 <lispy|web> c_wraith: sort of an odd thing to avoid, don't you think?
22:35:33 <luite> lispy|web: yes I should move the bindings to Clp (linear programming solver) to a cabal package eventually, but I'd like to ghci for some tests while I'm still hacking on it
22:35:34 <c_wraith> lispy|web: Depends on how much you hate getting Result s
22:35:56 <kmc> > Success []
22:35:57 <lambdabot>   Not in scope: data constructor `Success'
22:36:24 <lispy|web> luite: Well, if you can make it work with a .cabal file then you could build it with -v to see what commands are being run.  Then you should be able to make it work in ghci :)
22:37:25 <mmmdonuts_> Does (liftM . liftM) have a name?
22:37:45 <luite> lispy|web: are you sure? I can build the file with ghc already
22:37:57 <luite> but 'converting' the ghc command line to ghci doesn't work
22:38:08 <lispy|web> luite: I see.  so your problem is ghci specific?
22:38:18 <luite> lispy|web: apparently :)
22:38:55 <lispy|web> luite: is there a command to pass to ghc so you can see what --make is doing?  I think there is, but I don't recall it.
22:40:44 <mmmdonuts_> lispy|web: -M will generate dependencies suitable for a makefile, which should give you some idea
22:41:18 <lispy|web> mmmdonuts_: I suspect we need to see what the linker is doing
22:41:52 <luite> those linker command lines (ghc --make -v) look rather scary :p
22:42:18 <lispy|web> luite: so compare to ghci -v :)
22:43:55 <luite> ghci -v doesn't show much, it loads packages ghc-prim, integer, base and then complains about the unknown PEi386 section name in my .o
22:44:29 <lispy|web> luite: at this point I say ask in #ghc or post to haskell
22:44:30 <lispy|web> er
22:44:33 <lispy|web> haskell-cafe
22:45:54 <luite> oh that's not #haskell-cafe :p
22:46:27 <lispy|web> luite: oh, sorry. haskell-cafe is a mailing list :)
22:48:12 <luite> yes I know, it's quite late here, and I have worked on this for a few hours, so it took me a while to realize (after I joined that channel...)
23:08:11 <shellsage> I'm trying to write a function of the form: whichHelper f1 f2 = map f2 (filter f1 records)
23:08:19 <shellsage> but I want it to return the function that takes the parameter records
23:08:31 <shellsage> so that I can say whichHelper records and have it do whatever to records
23:08:36 <shellsage> can someone help me achieve this?
23:11:22 <dibblego> whichHelper f1 f2 records = map f2 (filter f1 records)
23:14:28 <ivanm> or map f2 . filter f1 ;-)
23:14:34 <hackagebot> GPipe 1.0.4 - A functional graphics API for programmable GPUs (TobiasBexelius)
23:15:28 <iaefai> Does ghc 6.12 have any functionality that would be like loadable plugins?
23:18:49 <blackdog> iaefai: i was just about to ask the same thing :)
23:19:02 <iaefai> great fanboys think alike? :P
23:19:06 <blackdog> iaefai: it does have support for dynamic libraries
23:19:19 <blackdog> i'm currently using it in Hubris from C
23:19:25 <iaefai> sounds like it would be very useful
23:19:26 <iaefai> hubris?
23:19:32 <blackdog> Ruby-Haskell bridge
23:19:50 <blackdog> i'm on my first rewrite:) trying to make it a bit more principled
23:20:00 <blackdog> at the moment, you need the compiler installed to use it at all, which is a bit crap
23:20:29 <blackdog> and there's hs-plugins, but it's failing tests on hackage atm, and i don't know if don is still actively maintaining it
23:20:48 <iaefai> hmm, right now I am defining what a chess board is and how to output it nicely :p
23:20:53 <blackdog> the other thing i need is to be able to pull in new whole packages at runtime, which could be tricky
23:21:06 <blackdog> why do you need plugins for that?
23:21:07 <shellsage> dibblego, ivanm, but I don't have the records parameter yet
23:21:19 <shellsage> can I just pass that in later?
23:21:20 <shellsage> oh right
23:21:21 <shellsage> yeah
23:21:42 <iaefai> blackdog: I don't
23:21:49 <iaefai> Two independent questions :p
23:23:33 <blackdog> oh, righto.
23:24:19 <iaefai> ahah! there is always a solution: List.foldr1  (++) (replicate 8 "----+")
23:24:21 <blackdog> iaefai: anyway, duncan coutts has a post on it at http://blog.well-typed.com/2009/05/buildings-plugins-as-haskell-shared-libs/
23:24:48 <iaefai> May I assume it is experimental?
23:25:10 <blackdog> sorta. it was in 6.8, died in 6.10, was resurrected for 6.12
23:25:18 <blackdog> but it does work
23:25:38 <iaefai> I would hope that something like this would be 'rock solid'
23:25:50 <blackdog> with a few patches it works on Mac too, but I don't know if they got into the mainline, i haven't talked to blackh for a bit
23:26:10 <aconbere> Cale: you mentioned the Boid simulation to me the other day. I'm wondering if you've tried running it (it uses CHP)
23:26:18 <blackh> blackdog: I haven't been following it either.
23:26:18 <blackdog> when it works it's rock solid :) which is to say, if it compiles, you're golden
23:26:48 <blackh> blackdog: So I'd assume that it hasn't gone in unless pressure has been applied to get it integrated.
23:26:50 <iaefai> Mac is certainly the most important platform for me :p
23:26:51 <iaefai> Win7 is too
23:27:06 <blackdog> oh, g'day mate. didn't see you there. might be worth poking igloo if you get some time, he's probably pretty slammed with the release
23:27:32 <shellsage> which :: (a -> Bool) -> (a -> a) -> [a] -> [a]
23:27:34 <shellsage> which _ _ [] = []
23:27:35 <blackdog> iaefai: Hm, dunno about Windows. want a fun project? :)
23:27:36 <shellsage> which f1 f2 records = map f2 . filter f1 records
23:27:40 <shellsage> it's telling me Couldn't match expected type `a1 -> [a]'
23:27:42 <shellsage>            against inferred type `[a]'
23:27:57 <iaefai> blackdog: not really, a little busy - but would love to hear it anyways :p
23:28:08 <blackdog> no, that's what i meant - dylibs on windows :)
23:28:13 <blackh> blackdog: So you think the patch is working well enough to be worth integrating?
23:28:58 <blackdog> blackh: it's pretty close. i got distracted and haven't been able to chase down that looping bu
23:29:01 <blackdog> g
23:29:06 <blackdog> but with a better test suite i'd say we're golden
23:29:31 <blackh> blackdog: Perhaps it's justifiable just from the point of view that it's far better than not having it.
23:30:05 <blackdog> blackh: true, so long as it doesn't affect Linux users
23:30:29 <blackdog> but i doubt Igloo will be terribly sympathetic to claims that "it's pretty much ok":)
23:31:05 <blackh> blackdog: Hm.  Well, I did build it on Linux with the patch and it passed the sanity test.,
23:31:45 <blackdog> blackh: oh, i very much doubt it'd break Linux. I meant we don't wanna half-arse the patch for Mac either
23:32:17 <blackdog> give me a day and i'll have a go at that bug, get back to you tomorrow
23:32:27 <blackh> blackdog: Well, I'm not really using it and I'm not much of a Mac user, so we really need some more Mac people to evaluate it.
23:32:33 <blackdog> it's entirely possible it's just my problem
23:32:33 <blackh> blackdog: OK
23:32:51 <blackh> blackdog: Sorry I never looked at it.
23:32:56 <blackdog> hm, yeah, true. At least get it into the HEAD for 6.13
23:33:05 <blackdog> yeah, is ok. it's a bear to install anyway
23:33:42 <blackdog> you were trying to get it to work for the iPhone, right?
23:34:28 <iaefai> I take it that ghc 6.12 is 'any day now'?
23:34:34 <ivanm> yes
23:34:43 <blackh> blackdog: My motivation was mostly just to "be helpful" - I don't really need it for my own purposes
23:34:45 <BlackM> shellsage: which f1 f2 records = map f2 . filter f1 $ records
23:34:52 <blackdog> blackh: you're a beautiful human being:)
23:35:01 <ivanm> maybe they're planning on making 6.12 a Christmas present to the haskell community? :p
23:35:11 <blackh> blackdog: I'm mostly beautiful. :)
23:35:13 <iaefai> If it is released, can we put it into a platform install?
23:35:15 <copumpkin> well, not quite
23:35:23 <ivanm> iaefai: not for at least 4 months
23:35:25 <copumpkin> the next platform is expected in march 2010 I thought
23:35:33 <iaefai> ok, great
23:35:38 <ivanm> iaefai: since we need time to stabilise and update libs
23:35:39 <copumpkin> and before then, 6.12 is pretty much useless
23:35:47 <ivanm> copumpkin: no, there's one more this year for 6.10 I think
23:35:49 <iaefai> all true
23:35:53 <ivanm> copumpkin: 6.12 won't be useless!
23:35:56 <ivanm> lies! all lies!
23:36:14 <ivanm> of course, a lot of cool things will be useless until gtk2hs is fixed to work with 6.12...
23:36:14 <copumpkin> there isn't even a cabal-install on the current 6.12 RC
23:36:23 <ivanm> copumpkin: someone's working on it IIRC
23:36:28 <copumpkin> yeah
23:37:00 <iaefai> I have an interest in opengl
23:37:22 <iaefai> My netbook only has opengl 1.4 or something on it because intel didn't upgrade the opengl until vista/7
23:37:42 <ivanm> copumpkin: especially threadscope... I mean, we have an app to parse 6.12 parallel profiling output, but we need 6.10 to build it! :@
23:40:03 <c_wraith> maybe the next version of platform will eliminate the useless libedit dependency
23:42:16 <iaefai> c_wraith: What is wrong with libedit?
23:42:26 <iaefai> Is it the thing responsible for tab completion in ghci?
23:42:35 <c_wraith> iaefai:  Not anymore.  Haskeline does that now
23:42:48 <iaefai> ok, good good
23:43:01 <c_wraith> iaefai: Basically, it's not really needed anymore, but platform still depends on it, for some reason.
23:43:16 <iaefai> Isn't libedit the readline replacement because of gpl issues?
23:43:28 <ivanm> iaefai: yeah, but it wasn't good enough
23:43:34 <dolio> Yeah, but it got re-replaced after about one version.
23:43:41 <iaefai> heh
23:43:43 <ivanm> dolio: 3, wasn't it?
23:43:57 <ivanm> dolio: I thought 6.10.{1,2,3} used editline, then they switched to haskeline for 6.10.4
23:44:07 <dolio> Was it that many?
23:44:19 <iaefai> Q: Would music make a good example of something that would work with monads, or be a monad in a way?
23:44:25 <ivanm> pretty sure it was
23:44:31 <ivanm> iaefai: not really...
23:44:37 <ivanm> monads "contain" an arbitrary value
23:44:52 <ivanm> the type of that value should be independent of what the monad is
23:45:02 <iaefai> It just seems to me that music is strung together in a sequential way and have a side effect of sound
23:45:19 <copumpkin> a restricted monad!
23:45:51 <det> In the following URL, it says something about using a "fake" parameter for sizeof, why cant it just say "sizeof = 2" ?
23:45:53 <det> http://www.haskell.org/haskellwiki/OOP_vs_type_classes#Type_can_appear_at_any_place_in_function_signature
23:46:02 <iaefai> Now can somebody implement a way to have a series of functions called inside a 'do' and have it loop?
23:46:08 <copumpkin> det: it has no way of knowing what type you're using
23:46:20 <copumpkin> iaefai: MonadFix?
23:46:24 <copumpkin> :t mfix
23:46:25 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:46:56 <c_wraith> there's also forever
23:47:00 <c_wraith> :t forever
23:47:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
23:47:30 <copumpkin> :t forever id
23:47:31 <lambdabot> forall a b. a -> b
23:47:34 <iaefai> hmm, the types don't really tell you much to me anyways
23:47:51 <c_wraith> forever does what you'd expect.
23:48:09 <iaefai> never returns?
23:48:17 <Cale> aconbere: I haven't, I just noticed the articles.
23:48:28 <gio123> Cale: hi
23:48:31 <Cale> aconbere: Are you having trouble running it?
23:48:35 <Cale> gio123: hello
23:49:48 <c_wraith> That's correct, iaefai
23:49:53 <iaefai> holy crap a 4gb sodimm is expensive
23:52:12 <iaefai> Any guesses as to when 4gb will be less than $100? :P
