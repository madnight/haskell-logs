00:00:01 <Saizan_> not just "Maybe"
00:00:03 <iaefai> ok, that makes nice sense
00:00:19 <Saizan_> since Maybe is like a function from types to types
00:00:58 <iaefai> I understand my new problem from a type perspective, just not from how these are meant to be used - do I have to convert the sequence back to a view every recursion?
00:01:36 <Saizan_> yes
00:01:46 <Saizan_> the view contains a Seq
00:04:19 <Saizan> i'd probably write that function with foldMap, btw
00:07:01 <iaefai> Now I need to make sure that Row contains exactly 8 Squares, what would be the best way to do that? Right now I provide a constructor, but it can't enforce that afaik
00:07:30 <iaefai> Never heard of foldmap
00:07:43 <crash[`]> ?pl isPal xs = xs == (reverse xs)
00:07:43 <lambdabot> isPal = ap (==) reverse
00:07:56 <iaefai> I am not sure what a monoid properly is
00:08:00 <crash[`]> Where is `ap` defined?
00:08:54 <Saizan> crash[`]: Control.Monad
00:09:29 <crash[`]> Curious - why isn't it just in prelude?
00:10:03 <Saizan> iaefai: a Monoid is something very simple, it's a type with an binary operation mappend, and a value mempty
00:10:25 <Saizan> iaefai: and you know that m `mappend` mempty = m = mempty `mappend` m
00:10:31 <Saizan> and that mappend is associative
00:11:00 <Saizan> so a `mappend` b `mappend` c has the same meaning regardless of how you put parentheses
00:11:09 <iaefai> Is that like x * 1 = x = 1 * x?
00:11:13 <Saizan> yeah
00:11:23 <Saizan> in fact the integers with * and 1 form a monoid
00:11:32 <crash[`]> iaefai: specifically, (x * y) * z = x * (y * z) is the common example :)
00:11:44 <Saizan> crash[`]: that's an example of the second law
00:12:05 <Saizan> iaefai: however a common monoid is [a]
00:12:22 <Saizan> > "" `mappend` "foo"
00:12:24 <lambdabot>   "foo"
00:12:29 <Saizan> > "foo" `mappend` ""
00:12:30 <lambdabot>   "foo"
00:12:41 <Saizan> > "foo" `mappend` "bar" `mappend` "baz"
00:12:42 <lambdabot>   "foobarbaz"
00:12:53 <crash[`]> > let pal = ap (==) reverse
00:12:54 <lambdabot>   not an expression: `let pal = ap (==) reverse'
00:13:09 <crash[`]> > let ap (==) reverse [1,2,3,2,1]
00:13:10 <Saizan> crash[`]: lambdabot /= ghci
00:13:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:13:15 <crash[`]> yeah yea :P
00:13:21 <crash[`]> first time using
00:15:22 <crash[`]> > ap (==) reverse [1,2,3,2,1]
00:15:23 <lambdabot>   True
00:15:57 <iaefai> so mappend is similar in operational dynamics to multiply?
00:16:19 <Saizan> mappend is defined differently for any type
00:16:40 <Saizan> what it has in common with multiplication are those two properties
00:16:40 <crash[`]> GHCi gives me "No instance for (Monad ((->) [a]) arising from the use of `ap` at..."
00:16:52 <Saizan> crash[`]: import Control.Monad.Instances
00:17:10 <Saizan> iaefai: for lists mappend is (++)
00:17:19 <crash[`]> Saizan, thanks
00:17:42 <Saizan> Data.Monoid has many examples of monoids
00:18:52 <Saizan> however if we specialize foldMap type for your use case, we get (Square -> [Char]) -> Seq Square -> [Char]
00:19:39 <Saizan> so that it does the concatenation of the various pieces for you
00:20:07 <Saizan> you just have to say how to represent a Square
00:20:12 <iaefai> hmm
00:20:12 <iaefai> I think I lagged a little bit
00:20:12 <iaefai> So in a general way, how does this help me or apply to my situation?
00:21:39 <Saizan> i've explained that in my last three messages, so i guess we are indeed lagged :)
00:21:43 <iaefai> which I already have a cout function for
00:22:24 <Saizan> well, \x -> " " ++ (cout x) ++ " |"
00:22:32 <Saizan> if you want to get the same output
00:23:23 <Saizan> so "cout (Row s) = "|" ++ foldMap (\x -> " " ++ cout x ++ " |") s"
00:26:12 <iaefai> Is that realworld haskell book worth getting? The only other haskell book I have is 'programming in haskell' (hutton) and the table of contents for RWH is at least impressive
00:27:01 <Saizan> well, it's freely available on their website, so you might try reading some of it and then decide
00:27:57 <iaefai> quite awesome
00:28:01 <iaefai> merci
00:28:20 <ivanm> iaefai: the actual book has a bit more content and generally more polish than the online version
00:28:33 * ivanm wishes o'reilly would distribute a darcs patch for the RWH errata though... ;-)
00:28:40 <iaefai> how much more content?
00:29:08 <ivanm> iaefai: well, better explained content a bit
00:29:27 <Saizan> last time i've seen a copy it was a photo of code being cutted out of the page
00:29:30 <ivanm> iaefai: they couldn't sync the changes from the final version of the book back to the website
00:29:43 <ivanm> Saizan: a copy of RWH?
00:30:10 <ivanm> I know that it's a bit weird/embarrasing to have a chunk of code they're discussing actually emit errors because someone forgot an import in the script they ran...
00:30:11 <Saizan> ivanm: yeah, like a print error so that half of the code wasn't there
00:33:55 <iaefai> Saizan: I thank you. I am curious though - isn't this like a regular fold?
00:34:29 <Saizan> iaefai: it's a bit more than that
00:35:48 <Saizan> iaefai: using foldr you can define "foldMap f s = foldr (\el rest -> f el `mappend` rest) mempty s"
00:39:50 <Tordek> main.hs:47:2: `read' is not a (visible) method of class `Read'
00:39:56 <Tordek> I can't implement my own read?
00:40:19 <ivanm> @src Read
00:40:20 <lambdabot> class Read a where
00:40:20 <lambdabot>   readsPrec    :: Int -> ReadS a
00:40:20 <lambdabot>   readList     :: ReadS [a]
00:40:20 <lambdabot>   readPrec     :: ReadPrec a
00:40:20 <lambdabot>   readListPrec :: ReadPrec [a]
00:40:29 <ivanm> Tordek: you don't implement read, you implement readsPrec
00:40:39 <Tordek> a
00:40:46 <Tordek> *ah
00:40:52 <ivanm> Tordek: usually, you don't want a custom instance of Show and Read: they're used for code equivalents of your data structure
00:41:08 <ivanm> use a custom showFoo function, and parsing for your data structure
00:41:31 <ivanm> (for an example of why, see xmobar: they're now migrating to parsing the config file because read keeps failing)
00:43:13 <iaefai> Is there some functional language that uses 'match' for pattern matching an expression? I swear I keep typing/thinking that, when I should be using case :p
00:43:28 <ivanm> *shrug* could be
00:43:43 <Tordek> OCaml, I think...
00:43:49 <dibblego> iaefai, Scala/ML
00:43:52 <iaefai> ocaml would do it, I tried it before
00:44:05 <iaefai> years ago, couldn't stand it after trying haskell ....
00:54:10 <Tordek> @src concatMap
00:54:11 <lambdabot> concatMap f = foldr ((++) . f) []
00:57:07 <Peaker> alternatively: concatMap = (result . result) concat map
00:57:14 <Peaker> result = (.)
00:57:54 <Peaker> (apply concat on the result of the reuslt of map.  Or, two traversals to the right on (->) in map's type:   ((a->b)  ->  ([a]   ->  [b]))  (apply concat on the [b])
00:59:57 <ivanm> @type (.) . (.)
00:59:58 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:00:06 <ivanm> grrr.......
01:00:17 <ivanm> @type (Prelude..) Prelude.. (Prelude..)
01:00:18 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:00:24 <ivanm> that's better
01:01:42 <Peaker> @let (.) = Prelude..
01:01:42 <lambdabot>   Parse error: QVarSym ("Prelude",".")
01:01:55 <ivanm> @let (.) = (Prelude..)
01:01:56 <lambdabot>  <local>:9:0:
01:01:56 <lambdabot>      Multiple declarations of `L..'
01:01:56 <lambdabot>      Declared at: .L.hs:79:...
01:01:59 <ivanm> grrr...
01:02:04 <ivanm> @forget
01:02:04 <lambdabot> Incorrect arguments to quote
01:02:07 <ivanm> gah
01:02:14 <ivanm> how do you clear @let definitions?
01:15:05 <Saizan> @undefine
01:15:36 <ivanm> @type (.)
01:15:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:15:45 <ivanm> thanks Saizan
01:15:49 <ivanm> @let (.) = (Prelude..)
01:15:49 <lambdabot>  <local>:1:0:
01:15:50 <lambdabot>      Multiple declarations of `L..'
01:15:50 <lambdabot>      Declared at: .L.hs:79:...
01:15:54 <ivanm> grrr...
01:16:13 <Saizan> heh, you can't define it twice in the same module :)
01:16:25 <en0th> is there an overview of different array implementations, and maybe some suggestion about what one to choose for a particular problem?
01:16:44 <ivanm> Saizan: oh, so Cale has hard coded that in to the Let module?
01:16:53 <ivanm> en0th: might be one on the wikipage
01:16:59 <ivanm> en0th: what kind of problem do you have?
01:17:20 <Botje> en0th: http://www.haskell.org/haskellwiki/Modern_array_libraries
01:17:29 <Botje> section one is a quick reference
01:17:40 <Saizan> ivanm: yeah, in the Pristine.hs evidently, which is what is copied to L.hs by @undefine
01:17:54 <ivanm> @slap Cale
01:17:54 * lambdabot puts on her slapping gloves, and slaps Cale
01:18:23 <en0th> thanks! i'm toying with matrices, so i need an array with efficient update in that terms
01:18:33 <Saizan> it's not like there's another good place.. except building a CalePrelude and importing that :)
01:19:04 <ivanm> Saizan: well, it's annoying having these common functions suddenly have different types in lambdabot than elsewhere...
01:19:08 <ivanm> en0th: hmatrix?
01:19:17 <ivanm> en0th: it has various matrix functions available
01:21:56 <en0th> ivanm: hmatrix seems the way to go.
01:24:24 <en0th> Does Data.Packed.Matrix use one of the Data.Array as underlying implementation?
01:24:30 <vininim> nice, python readlines is not lazy. haskell spoiled me :/
01:27:49 <Peaker> vininim, you shouldn't use "readlines" in Python
01:27:56 <Peaker> vininim, for line in fileobj: ...   is lazy in Python
01:28:02 <ivanm> en0th: no
01:28:06 <ivanm> en0th: it uses a custom type IIRC
01:28:17 <ivanm> en0th: direct memory pinned in the RTS or something
01:28:49 <ksf> we don't have a graph rewriting library, do we?
01:28:49 <ivanm> Peaker: I've had to use readlines in python, when I couldn't guarantee line endings :s
01:28:49 <ivanm> ksf: what do you mean?
01:28:49 <ksf> ...and I don't mean haskell itself, I mean rewriting e.g. an fgl graph
01:28:58 <en0th> ivanm: many thanks
01:29:18 <ivanm> ksf: define "rewriting"
01:29:19 <ksf> mhhh I could have missed a concatMap equivalent in fgl's interface
01:29:20 <Peaker> hehe @ http://hackage.haskell.org/packages/archive/haskelldb/0.12/doc/html/Database-HaskellDB-BoundedList.html#t%3AN255
01:29:39 <Peaker> ivanm, what do you mean?  why not a lazy forloop on the lines?
01:29:44 <ksf> ivanm, http://en.wikipedia.org/wiki/Graph_rewriting
01:29:54 <ivanm> Peaker: can't recall at the time, but I had to get something done for students to use in a project
01:30:17 <ivanm> ksf: nah, nothing like that I think
01:30:18 <Peaker> I prefer Python's lazy I/O over Haskell's unsafeInterleaveIO
01:30:24 <ivanm> closest would be hgal, but it's bad
01:31:03 <ivanm> Peaker: main problem was, the data files the students were using were all with mac encodings, but students were probably using windows at home (and possibly *nix) and the labs had a mixture of windows and macs
01:31:08 <ksf> there's gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
01:31:21 <ksf> ...but I don't see anything where you return [Context c d]
01:31:27 <ivanm> so IIRC, someone suggested readlines as it allowed you to specify what to split on
01:31:40 <ivanm> ksf: be very careful with gmap
01:31:59 <ivanm> each context only has references to the contexts after it
01:32:08 <ivanm> so it's usually only useful for making fancier maps over labels
01:32:43 <Peaker> ivanm, The lazy line traversal does too
01:33:23 <ivanm> *shrug* I just wanted to get something done
01:33:28 <ivanm> and readlines worked
01:35:17 <vininim> (okay, reading everything from 5 minutes ago due to swapness)
01:35:58 <ivanm> heh
01:38:13 <ksf> "library for computation automorphism group and canonical labelling of a graph" zomg am I supposed to understand that sentence?
01:40:17 <ivanm> ksf: it's a haskell implementation of the nauty program/library
01:40:33 <ivanm> which finds graph automorphisms (and isomorphisms)
01:40:58 <ivanm> ksf: problems with HGAL: 1) only for Data.Graph; 2) not fully implemented; 3) slow, 4) jyp has said that he doesn't care about it any more
01:41:09 * ivanm has started on a replacement, but it's nowhere near ready yet
01:42:25 <Peaker> PastePipe = haste?
01:42:37 <vininim> Peaker: thanks for the tip
01:42:39 <PetRat> What am I doing wrong here? the exception propagates past the try: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11106#a11106
01:43:15 <ksf> there's different kinds of exceptions.
01:43:51 <ksf> iirc the System.IO exeption handling only catches IO ones, not undefined and error.
01:43:56 <ksf> (which is good)
01:44:08 <vininim> from swapness to a 30 seconds run, lazyness ftw :)
01:44:19 <PetRat> I thought SomeException would catch all of them; and also I have tried catching ArithException specifically. Note that I'm using Control.Exception.
01:45:06 <mauke> what exception?
01:45:26 <ksf> read, /me thinks
01:45:46 <mauke> well, that doesn't happen inside 'try' so it doesn't propagate past it
01:45:47 <PetRat> mauke: depending on whether I type something valid for read, either that or a stack overflow
01:45:59 <mauke> the exception is thrown in print
01:46:25 <PetRat> oh... it's the thunk thing. That's why I'm supposed to use evaluate, not return.
01:46:40 <ksf> :t readS
01:46:40 <lambdabot> Not in scope: `readS'
01:46:43 <ksf> :t reads
01:46:44 <lambdabot> forall a. (Read a) => String -> [(a, String)]
01:46:51 <ksf> nope that's what you're supposed to use
01:46:56 <ksf> @src read
01:46:56 <lambdabot> read s = either error id (readEither s)
01:47:05 <ksf> :t readEither
01:47:06 <lambdabot> Not in scope: `readEither'
01:47:13 <ksf> or that, actually.
01:47:43 <ksf> @hoogle readEither
01:47:43 <lambdabot> No results found
01:48:27 <PetRat> Okay it's fixed. One needs to use "evaluate" not "return" at the end of any do-block that may throw exceptions. I read about this but slipped my mind.
01:48:48 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11106#a11106
01:49:02 <ksf> @hoogle evaluate
01:49:02 <lambdabot> Control.Exception evaluate :: a -> IO a
01:49:03 <lambdabot> Control.OldException evaluate :: a -> IO a
01:49:03 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
01:49:33 <Saizan> PetRat: well, one should avoid pure exceptions alltogether
01:49:46 <Saizan> PetRat: and evaluate could be used inside main
01:50:02 <Saizan> PetRat: try (inner >>= evaluate)
01:50:54 <Saizan> PetRat: for the specific case of read you should use readMaybe s = case reads s of [(x,rest)] | all isSpace rest -> Just x; _ -> Nothing, and then pattern match on that.
01:51:02 <ksf> er readEither is in GHC.Read, and possibly somewhere else. didn't mean to repaste the hpaste link...
01:51:31 * ksf would use read <$> many1 digit 
01:51:56 <PetRat> Saizan: is there an advantage to putting the evaluate in main, not inner? Note that my only reason for read here is a testbed to throw a different kind of exception than ArithException.
01:51:57 <Saizan> and, foldr (+) 0 [1..] :: Int won't terminate
01:52:30 <PetRat> .. yeah that was to deliberately raise a stack overflow.
01:53:07 <PetRat> This is a test bed to see if I know how to throw and catch exceptions of different types.
01:53:27 <Saizan> PetRat: not a specific advantage here, it's just to node that you don't need to go rewriting your functions to use evaluate, you can just use evaluate where you're trying to catch exceptions
01:53:56 <PetRat> Saizan: that may be a smoother way to organize things.
01:54:09 <Saizan> well, ok, though you should avoid throwing pure exceptions as much as you can
01:54:36 <Saizan> for this exact reason, that you've to care about evaluation to catch them
01:54:48 <PetRat> Because my "inner" function is in the IO monad, what do mean here by "pure"?
01:55:30 <Saizan> that the exception is hidden inside the returned value, it's not thrown by the action
01:55:40 <ksf> ...even ArithExceptions. with a sufficiently powerful type system they wouldn't exist, anyway, and while you can't properly do that in haskell, your program should be typed like if the types were inforced.
01:55:45 <PetRat> By pure do you mean non-IO related?
01:55:52 <Saizan> yeah
01:56:00 <Saizan> basically, use throwIO, not throw
01:56:27 <ksf> in other words, pure functions should be total.
01:56:37 <ksf> ...which read isn't.
01:56:47 <PetRat> Okay, so you are saying if the exception is hidden in act of evaluating the returned thunk, that would be a pure exception?
01:57:23 <Saizan> yeah, those are generally called "pure exceptions" as short for "exceptions in pure code"
01:57:36 <Saizan> in fact they are nastier than the other ones :)
01:58:46 <PetRat> By the way, I don't plan on writing code that throws exceptions, but I am digging into some computer music library code, and it interfaces with MIDI and the sound card and handles exceptions, so I want to get a foundational understanding.
01:59:35 <Saizan> ok
01:59:37 <ksf> generally it's considered fine to throw exceptions if e.g. your sound card starts to burn, but not otherwise.
02:00:04 <Saizan> well, messing with the soundcard should be in IO, i'd think
02:00:10 <ksf> that is, everything in control of the program should not error out in a way that isn't reflected in the types of the functions.
02:00:45 <PetRat> ksf: but don't exceptions provide a simpler interface in some cases?
02:00:56 <PetRat> ... I am talking IO  here ...
02:02:12 <ksf> sure they do. but there's a fundamental difference between throwing an exception on a broken pipe or failing to parse user input.
02:02:37 <ksf> ...the latter is an error that's to be expected, the other one is beyond the program's control.
02:02:49 <PetRat> I see. "in control of the program."
02:05:36 * ksf loves the way linux reports printer errors: "lp0 on fire".
02:05:49 <ksf> ...there's no clearer way to state that you just have no idea what's going on.
02:06:24 <medfly> :)
02:10:25 <lvillani> does GHC 6.12 supports (and can be built with) shared libraries on linux x86_64?
02:10:48 <ksf> the ghc devs claim so.
02:11:32 <lvillani> yesterday I tried to build ghc but it still produces .a archives and an hello world is still an astonishing 6.2 (unstripped) executable :)
02:11:34 <ksf> that is, unlike on windoze, it also supports compiling packages as .sos
02:11:52 <lvillani> *6.2 Mb
02:12:11 <ksf> I think there's some flags you need to enable
02:12:43 <lvillani> to produce a non-static runtime?
02:13:24 <ksf> dunno, I'm refusing to try out 6.12 until there's a cabal-install for it.
02:14:12 <lvillani> I gave a look at mk/build.mk and there's a ifeq "$(PlatformSupportsSharedLibs)" "YES" GhcLibWays += dyn endif
02:14:33 <ivanm> ksf: well, you should be able to build cabal-install now with 6.10, then keep using it after you upgrade to 6.12...
02:14:39 <ivanm> yay for static binaries! \o/
02:14:44 <lvillani> in the 'perf' profile. It *should* spit .so instead of .a files
02:14:48 <lvillani> but it doesn't
02:15:00 <Saizan> ivanm: no
02:15:14 <ivanm> Saizan: that won't work? why not?
02:15:16 <Saizan> ivanm: you need Cabal-1.8 for ghc-6.12
02:15:19 <lvillani> so the runtime is statically linked in executables
02:15:21 <ivanm> oh, wait, duh, wont' be able to install, etc.
02:15:29 <ksf> the latest cabal-install has a cabal <1.7 constraint
02:15:32 <ivanm> Saizan: because it needs to manipulate ghc-pkg
02:15:35 <paulvisschers> Anybody know what is up with this: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11109#a11109
02:15:37 <paulvisschers> ?
02:15:38 <ivanm> right?
02:15:40 <Saizan> ivanm: right
02:16:04 <ivanm> paulvisschers: maybe you're doing it wrong? ;-)
02:16:08 <ivanm> @hoogle parseURI
02:16:09 <lambdabot> Network.URI parseURI :: String -> Maybe URI
02:16:09 <lambdabot> Network.HTTP.Base parseURIAuthority :: String -> Maybe URIAuthority
02:16:09 <lambdabot> Network.URI parseURIReference :: String -> Maybe URI
02:17:06 <paulvisschers> ivanm: This worked until I update the network package
02:17:17 <ivanm> paulvisschers: check the docs?
02:17:18 <Saizan> ksf: if you are interested: http://markmail.org/message/tcfr2soc7rf5sfej
02:17:58 <paulvisschers> ivanm: The haddock says that it changed behaviour, and I should parseURIReference, but that gives the same error
02:18:12 <ivanm> *shrug*
02:18:31 <paulvisschers> Also it sometimes gives a segmentation fault
02:19:00 <paulvisschers> It also happens when I try to use URLs I've encoded before
02:20:39 <en0th> .. in hackage documentation for hmatrix there's written Matrix is instance of Show. However, it seems it's not true.
02:21:10 <Saizan> paulvisschers: network-2.2.1.5 ? it works fine here
02:21:15 <en0th> i'm wondering if doc and sources could be not in sync
02:21:43 <paulvisschers> I have network-2.2.1.3, network-2.2.1.4 it seems
02:21:45 <Saizan> the Instances section is automatically generated
02:21:49 <vininim> en0th: iirc you can show matrices
02:21:55 <paulvisschers> I'll update and see what happens
02:22:09 <Saizan> paulvisschers: try upgrading to 2.2.1.5 then, maybe they fixed it
02:22:28 <en0th> vininim: those in Data.Packed.Matrix ?
02:25:18 <paulvisschers> Saizan: Now I get http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11109#a11111
02:25:32 <paulvisschers> Saizan: When I load the file into ghci
02:25:53 <Saizan> paulvisschers: you've to rebuild HTTP against this new network
02:26:55 <paulvisschers> Saizan: Right, that helped
02:27:32 <paulvisschers> Saizan: Ok this seems to work properly, thanks a lot
02:27:55 <Saizan> np
02:32:51 <Saizan> en0th: what error are you getting when trying to show one?
02:34:37 <vininim> en0th: importing numeric.LinearAlgebra makes it work
02:34:49 <vininim> *Numeric.LinearAlgebra
02:35:19 <vininim> anyway, have to go
02:35:26 <oboron> Hey all, I am a beginner and having a hard time with the distinction between the numeric types.  Specifically, I don't understnad the error I get from this function:    utonality n = normalizeScale $ Scale $ map (\step -> (n / step)) [(ceiling $ n / 2)..n]
02:35:37 <oboron> It says:      No instance for (Integral Double)
02:35:37 <oboron>       arising from use of `ceiling' at scale.hs:9:67-73
02:35:37 <oboron>     Possible fix: add an instance declaration for (Integral Double)
02:35:40 <en0th> many thanks, that was the problem http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4473#a4473
02:35:54 <ivanm> oboron: you're treating integers as floating point numbers
02:36:00 <ivanm> specifically, ceiling returns an integer
02:36:20 <ivanm> whereas division requires floating point
02:36:34 <Saizan> you can add fromIntegral to get back a floating
02:36:36 <ivanm> oboron: try this: [( fromIntegral . ceiling $ n / 2) ...
02:37:22 <oboron> Ah yes, that was it.  Thank you all very much!
02:42:10 <ivanm> hmmm, doesn't yi use vty anymore?
02:42:47 <ivanm> oh, wait, hackage doesn't list it because it's optional
02:58:57 <hackagebot> llvm 0.7.0.0 - Bindings to the LLVM compiler toolkit. (LennartAugustsson)
03:00:54 <paolino> I'd like to have an opinion on the correctness of this code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4474#a4474
03:01:34 <ivanm> paolino: well, who's stopping you from having an opinion? :p
03:01:39 <paolino> if I can trust it is working as by STM contract or if it is just working for the actual implementation
03:01:53 <paolino> ivanm :) from you
03:02:09 <ivanm> eh, I only used STM once a few years ago
03:02:30 <ivanm> paolino: the indentation of the do-block inside the forkIO looks bad...
03:02:45 <ivanm> paolino: also, the fork'd bit only happens once...
03:02:52 <ivanm> which kind of defeats the purpose of STM
03:02:58 <dibblego> paolino, "case r0 of True -> return (); case False -> readTChan c" can be come "unless r0 $ readTChan c"
03:03:07 <ivanm> paolino: actually, you probably want retry instead of return ()
03:03:20 <ivanm> dibblego: I don't think he'd want to do that
03:03:31 <paolino> the code is doing right
03:03:34 <ivanm> oh...
03:03:38 <ivanm> forget what I said then ;-)
03:03:48 <paolino> my problem is if it will always do
03:04:13 <paolino> ivanm, it is stopping on readTChan
03:04:23 <ivanm> *shrug* dunnno
03:04:32 <paolino> and then transacting on readTVar
03:04:59 <MyCatVerbs> > 2147483648 :: Int32
03:05:00 <lambdabot>   -2147483648
03:05:07 <MyCatVerbs> > abs 2147483648 :: Int32
03:05:08 <lambdabot>   -2147483648
03:05:21 <medfly> :)
03:05:23 <ivanm> > abs minBound :: Int
03:05:24 <lambdabot>   -9223372036854775808
03:05:29 <ivanm> ;-)
03:05:37 <ivanm> > negate maxBound :: Int
03:05:38 <lambdabot>   -9223372036854775807
03:10:13 <maltem> :t curry
03:10:14 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
03:10:43 <maltem> A recent homework task of mine was to show that curry is an isomorphism if a,b,c are vector spaces. Does this somehow generalize to something fancier than vector spaces?
03:11:55 <Saizan> to all the CCC, Cartesian Closed Categories
03:12:05 <Saizan> the wikipedia article should have some examples
03:12:20 <maltem> hah, guessed it has something to do with categories :P
03:12:31 <maltem> thanks I'll have a look
03:14:01 <Saizan> well Curry stated it about propositional logic / lambda calculus, but lambda calculus happens to be the internal language of CCCs so it works for all of them :)
03:21:10 <maltem> I suppose this is a nice introductory example to CT, since it makes it (apparently?) possible to say "this is an isomorphism of any theory satisfying ...", which is more difficult a statement then what I have encountered in maths so far.
03:23:18 <ksf> hrmpf broken link redirectors which point to... a 404
03:32:38 <Guest47901> hi there
03:34:09 <Raevel> hi there bmf
03:34:50 <bmf> hi - I'm after some help installing unix pkg on cygwin - getting a missing header file error even though it's actually in the pkg itself
03:35:15 <Twey> SEP…
03:35:34 <bmf> anyone successfully installed the haskell unix pkg on cygwin?
03:35:34 <bmf> * Missing header file: HsUnix.h
03:36:04 <Twey> Try #cygwin
03:36:21 <Twey> I think they package their own tarballs
03:36:33 <bmf> it's not a cygwin pkg. it's haskell
03:36:41 <bmf> from hackageDB
03:36:55 <Twey> You're installing GHC from source?
03:36:56 <bmf> run as: $ runhaskell Setup.hs configure --user
03:37:16 <ksf> http://hackage.haskell.org/package/unix-2.3.2.0  says it should work under cygwin
03:37:46 <bmf> sure - but it's not ;-)
03:38:09 <Twey> Oh!
03:38:11 <Twey> That package!
03:38:20 <Twey> Sorry.  Misunderstood you.  ☺
03:38:25 <bmf> np
03:38:34 <Twey> Does cabal-install have the same problem?
03:39:02 <bmf> not tried that. new to haskell - wanted to try xmonad (and learn the pkging in general). let me try
03:39:20 <ksf> you can also pass -v and get a lot more info
03:39:29 <Twey> *nod*
03:39:39 <ksf> ...most likely including where cabal expects HsUnix.h to be.
03:40:46 <ksf> xmonad runs under windoze?
03:40:47 <bmf> well HsUnix.h is in the include dir of the pkg I'm trying to install, ie unix-<version>/include/
03:41:05 <bmf> ksf - I have no idea. going to try it under x under cygwin
03:41:43 <ksf> yep it says so in the .cabal... and "include" is listed under "include-dirs"
03:42:02 <ksf> so at least ghc should find it.
03:43:00 <ksf> and c-sources means that gcc is invoked on the cbits by cabal, too, it _should_ take care of passing all the right flags.
03:44:51 <bmf> ok - thanks for making me aware of cabal-install. let me get that installed then I'll try the unix pkg with that.
04:16:15 <Eduard_Munteanu> Hi.
04:17:45 <McManiaC> hey, i wanna use X.U.Loggers with dzen as a second status bar
04:18:07 <McManiaC> but dynamicLogWithPP updates only if i change focus/window title etc
04:18:20 <McManiaC> is there a way to update that "pipe" every X seconds?
04:19:42 <Eduard_Munteanu> McManiaC, mm, good question, I'm also interested in the answer.
04:20:11 <McManiaC> uh, i am in the haskell chan :) sorry, was supposed to go to the xmonad channel
05:24:49 <benmachine> if I do rnf [1 ..], what will happen to my memory usage?
05:26:02 <ivanm> good-bye memory...
05:26:14 <benmachine> why isn't it immediately GC'd?
05:26:41 <benmachine> hmm, looks like it is
05:28:34 <ivanm> benmachine: *shrug* I don't know enough about how rnf, etc. works
05:28:38 <ivanm> > rnf [1..]
05:28:41 <lambdabot>   mueval-core: Time limit exceeded
05:28:46 <ivanm> > [1..]
05:28:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:29:03 <ivanm> > let xs = [1..] in xs `seq` xs
05:29:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:30:29 <benmachine> my real question is why is this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11113#a11113 not running in more-or-less constant memory
05:31:06 <benmachine> it looks to me like it should be lazy enough to only need a few numbers and a few thunks at any given moment
05:35:10 <maltem> yeah funny to see that rnf [1..] runs in constant memory
05:35:52 <benmachine> it makes sense; it evaluates each term and then discards it
05:36:19 <benmachine> I am wondering why rnf'ing my prime algorithm isn't doing the same even though I don't keep a reference to prior primes
05:36:31 <benmachine> (and hence am crazy slow, but time is cheaper than memory sometimes)
05:37:59 <maltem> ok it makes sense indeed
05:38:58 <benmachine> am was the wrong verb to use there it sounds like I am crazy slow that is not what I meant
05:39:01 <benmachine> *is crazy slow
05:54:34 <Peaker> not #haskell's timezone is it?
05:56:28 <ivanm> @. elite quote
05:56:29 <lambdabot> rIxxNICk31L 54ys: D03z iN Le4Rn??
05:56:31 <ivanm> happy now Peaker?
05:57:22 <SamB_XP> @localtime #haskell
05:57:36 <Botje> heh :P
05:57:36 <SamB_XP> hmm, oh, right, lambdabot can't do that ;-P
05:57:41 <Botje> does it take an average? :)
05:57:49 <SamB_XP> I mean, it doesn't know what to do when it gets answers ;-)
05:58:09 <SamB_XP> @localtime xci
05:58:11 <lambdabot> Local time for xci is Sat Oct 24 15:58:10 2009
05:58:32 <SamB_XP> @localtime ziman
05:58:34 <lambdabot> Local time for ziman is Sat Oct 24 14:58:33 2009
05:58:43 <SamB_XP> @localtime yahooooo
05:59:09 <SamB_XP> @localtime aavogt
05:59:30 <Zao> @localspam
05:59:30 <lambdabot> Unknown command, try @list
06:03:06 <SamB_XP> Zao: do you have a better way to discover haskell's timezone ?
06:03:37 <skorpan> haskell has its own timezone?
06:04:04 <SamB_XP> er.
06:04:06 <SamB_XP> forgot the #
06:04:07 <en0th> CEST?
06:04:11 <SamB_XP> #haskell's timezone
06:05:33 <Peaker> The lambda timezone
06:05:41 <ivanm> @time lambdabot
06:05:42 <lambdabot> I live on the internet, do you expect me to have a local time?
06:06:12 <ivanm> yes, yes I do
06:07:33 <burp> lol
06:07:41 <SamB_XP> lambdabot: your execution takes place on a CPU, does it not?
06:08:09 <SamB_XP> does this CPU not reside in a computer, and does this computer not reside at some location on the planet known as Earth?
06:08:30 <SamB_XP> and is this location not in some timezone or other ?
06:08:46 <benmachine> maybe it is in the centre of the planet
06:08:52 <luite> or at one of the poles
06:09:01 <en0th> omg singularity
06:09:01 <luite> or anywhere on that line :p
06:09:11 <nlogax> maybe she's like HAL 9000, after the jupiter incident
06:09:12 <SamB_XP> benmachine: too expensive to get internet down there
06:09:14 <burp> or it's distributed
06:09:48 <benmachine> the poles do have a timezone anyway don't they
06:09:58 <SamB_XP> also, don't they have some timezone at the south pole just so they know when to go to bed/get up ?
06:10:06 <benmachine> I think it is GMT
06:10:32 <Eduard_Munteanu> Timezones should be closer at the poles AFAICT
06:11:39 <SamB_XP> I don't think the north pole has a timezone, since nobody lives there to use it ;-)
06:17:03 <ziman> poles do have a timezone, as poland is UTC+1 ;)
06:18:17 <ivanm> heh
06:18:22 <ivanm> south pole is at NZ time...
06:18:28 <ivanm> SamB_XP: ^^
06:18:39 <SamB_XP> yeah
06:18:41 <ivanm> because the US station there has supplies, etc. sourced from NZ
06:18:49 <SamB_XP> makes sense I guess
06:21:40 <zygoloid> @@ @elite @ghc
06:21:41 <lambdabot>  GH( $AyS: cy(l3 In (1az5 dE(|aRatiONS (vIA $UpERcLa$5E5)
06:22:46 <zygoloid> @ghc Urk
06:22:46 <lambdabot> ghc says: Urk infer
06:23:17 <Botje> what now?
06:24:46 <zygoloid> @ghc PhD
06:24:46 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
06:25:20 <ivanm> the One True Meaning? or just any old True Meaning?
06:25:43 <Botje> what can you get for the False Meaning?
06:25:48 <Botje> or the _|_ Meaning?
06:26:04 <SamB_XP> Botje: you can prove anything from it?
06:26:12 <Botje> :)
06:26:36 <SamB_XP> (I guess that was in the source, not an error message?)
06:26:38 <SamB_XP> @ghc
06:26:39 <lambdabot> ghc says: NEVER use commas within those string literals, cpp will ruin your day
06:26:52 <SamB_XP> huh ...
06:26:58 <SamB_XP> I don't get that one :-(
06:27:02 <SamB_XP> @ghc
06:27:03 <lambdabot> ghc says: Malformed predicate
06:27:11 <SamB_XP> ?
06:27:24 <SamB_XP> @ghc
06:27:25 <lambdabot> ghc says: Can't happen
06:27:33 <SamB_XP> yeah right!
06:27:35 <SamB_XP> @ghc
06:27:36 <lambdabot> ghc says: Malformed constructor signature
06:27:37 <fxr> ghc also says "internal error: evacuate: strange closure type 7"
06:27:46 <SamB_XP> fxr: I hate when that happens
06:28:11 <SamB_XP> that generally means you have a buffer overflow/underflow on teh heap :-(
06:28:53 <en0th> it seems a message from one of the LOST series
06:29:35 <fxr> I'm getting it when I compile haskell-src-exts with ghc 6.12
06:30:03 <SamB_XP> fxr: during compilation ???
06:30:13 <SamB_XP> or execution ?
06:30:21 <fxr> SamB_XP: yeah, I sent a bug report to glasgow-haskell-bugs
06:30:27 <fxr> compilation
06:30:30 <SamB_XP> eeeeeek
06:31:03 <SamB_XP> that means *GHC* has teh buffer overflow!
06:31:33 * SamB_XP is considering removing xchat's the s/\bteh\b/the/ "feature"
06:33:52 * medfly removes teh feature
06:34:08 * Exteris doesnt have teh feature
06:34:10 <Exteris> afaik
06:34:13 <medfly> I think it's just there to show you can do that with anything
06:35:00 <jystic> is there something available that will run all the quick check prop's in a .hs file?
06:38:51 <SamB_XP> jystic: there is a runhaskell/runghc/runhugs script floating around that will do it if you name them a certain way
06:39:06 <SamB_XP> @google "quickcheck.hs"
06:39:07 <lambdabot> No Result Found.
06:39:46 <jystic> yeah I saw simon peyton jones using it on a video lecture I watched, but I haven't been able to find it
06:40:25 <SamB_XP> I found it on hackage
06:40:30 <SamB_XP> http://hackage.haskell.org/package/quickcheck-script
06:41:08 <jystic> thanks, just installing it now :)
06:41:15 <SamB_XP> you are quite welcome
06:41:27 <zygoloid> ghc  says: Oops!  Entered absent arg w_s3Fm{v} [lid] ghc-6.10.3:CgMonad.CgInfoDownwards{tc raF}
06:44:29 <BONUS> heeeeeyo!! how is everyone!
06:45:11 <medfly> hey
06:46:50 <zygoloid> BONUS: welcome! we're playing "GHC says the funniest things"
06:47:08 <BONUS> my brain just exploded
06:48:33 <BONUS> @seen EvilTerran
06:48:34 <lambdabot> Unknown command, try @list
06:48:59 <BONUS> uhh didn't that used to work?
06:49:14 <zygoloid> used to
06:49:17 <dewilman> hi
06:49:26 <zygoloid> preflex: seen EvilTerran
06:49:26 <preflex>  EvilTerran was last seen on #haskell 1 day, 2 hours, 24 minutes and 33 seconds ago, saying: sinelaw, ^
06:49:41 <dewilman> heyy
06:50:27 <zygoloid> hello mr dewilman
06:50:35 <dewilman> hi
06:50:45 <dewilman> zygoloid
07:08:30 <SamB_XP> jystic: I just googled for "quickcheck script" (sans quotes)
07:09:36 <jystic> SamB_XP: yeah i probably would have tried that eventually, i was searching for quickcheck runner, etc
07:09:47 <SamB_XP> vb
07:09:48 <SamB_XP> er.
07:10:00 <SamB_XP> before that, I tried "quickcheck.hs"
07:10:18 <SamB_XP> but mostly just got stuff about QuickCheck.hs and quickcheck.us
07:10:51 <jystic> yeah quickcheck.hs seemed to turn up stuff about quickcheck itself
07:11:06 <SamB_XP> it's cause google ain't case sensitive ;-)
07:11:34 <jystic> yeah
07:11:35 <SamB_XP> would be nice if it were at least sensitive to camel caps :-(
07:12:09 <jystic> I wonder if they would have to re-index for that :P
07:12:20 <Saizan_> or if you could turn on case sensitivity
07:13:07 <stroan> Would there be much by way of demand for a Haskell version of Expect? I've written a subset of the functionality for one of my own projects here, but I could polish it up
07:13:55 <Saizan_> Expect what that thing to handle text UI programmatically?
07:14:03 <stroan> yeah
07:14:04 <Saizan_> s/what/was/
07:14:14 <stroan> handy for sys adminny thing
07:14:14 <stroan> s
07:15:03 <stroan> it's a relatively thin layer on top of System.Process
07:15:35 <Saizan_> there's always a request for stronger system scripting support in haskell
07:17:03 <stroan> kk, I'll try to get the rest of the functionallity implemented
07:17:17 <stroan> shouldn't be too much work tbh
07:17:34 <eflister> @djinn (a -> b) -> (a,a) -> (b,b)
07:17:36 <lambdabot> f a (b, _) = (a b, a b)
07:17:51 <eflister> is there anything like map for tuples?
07:17:58 <Twey> No
07:18:04 <Twey> Doesn't make sense
07:18:04 <zygoloid> there's first and second for 2-tuples
07:18:05 <Saizan_> ?type join (***)
07:18:06 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:18:20 <Baughn> eflister: What would such a function do?
07:18:20 <Twey> ‘Tuple’ is not a type
07:18:20 <Saizan_> > join (***) (+1) (3,4)
07:18:20 <lambdabot>   (4,5)
07:18:33 <eflister> that's what i want, thx
07:18:43 <Baughn> @type (***)
07:18:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:18:46 <eflister> i was thinking (first >>> second)
07:18:52 <Twey> Tuples are a category of types including things like (Int, Bool) and (String, Char)
07:19:25 <Twey> You can define a map for one of those types (or even generalise it, to define it for (a, a)) but not all of them, because they're essentially unrelated
07:20:12 <Saizan_> you can easily define a map for all of them
07:20:18 <Saizan_> just make it polymorphic
07:20:23 <Saizan_> like the list map is, afterall
07:20:45 <Saizan_> [] is not a type either
07:21:01 <eflister> :t join
07:21:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:21:27 <Twey> Saizan_: But [] is a type constructor — ‘tuple’ isn't even that
07:22:31 <Saizan_> i guess you can't write a map for all the tuple sizes (without using a typeclass), though you can for (,)
07:22:49 <ray> i think you mean "pairs" there
07:22:49 <Twey> Aye — like I said
07:22:52 <ray> emmeant
07:22:55 <ray> sgjalgj
07:23:34 <eflister> yeah i should have said pairs.  where is the monad here?  is (,) a monad?
07:24:02 <ray> join (***)?
07:24:19 <ray> function monad for that join
07:24:19 <Saizan_> no, (,) can't be a monad
07:24:56 <eflister> join is for monads right?
07:25:14 <SamB_XP_> @info Monad
07:25:15 <lambdabot> Monad
07:25:17 <SamB_XP_> @src Monad
07:25:18 <lambdabot> class  Monad m  where
07:25:18 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
07:25:18 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
07:25:18 <lambdabot>     return      :: a -> m a
07:25:18 <lambdabot>     fail        :: String -> m a
07:25:27 <SamB_XP_> @kind Monad
07:25:28 <lambdabot> Class `Monad' used as a type
07:25:54 <ray> join is a useful function
07:26:25 <eflister> ah, -> is the monad
07:26:28 <eflister> eh?
07:29:10 <Saizan_> eflister: "(->) e" was the monad there
07:29:24 <Saizan_> > (\f -> f *** f) (+1) (1,2)
07:29:25 <lambdabot>   (2,3)
07:29:35 <Saizan_> that's equivalent code
07:29:56 <eflister> i don't quite get how it's duplicating f
07:30:23 <eflister> or why (first >>> second) doesn't work
07:30:58 <Saizan_> first and second take an argument
07:31:00 <Saizan_> > (\f -> first f >>> second f) (+1) (1,2)
07:31:00 <lambdabot>   (2,3)
07:31:31 <eflister> hmm ok
07:31:57 <Saizan_> and the duplication happens because join :: (r -> r -> a) -> (r -> a) for that monad, which has a single meaningful implementation
07:32:40 <Baughn> ..and two legal ones. Would be fun if the compiler could check to make sure we've got the right one.
07:33:03 <Baughn> Well, actually four legal ones
07:33:08 <mauke> huh?
07:33:21 <Baughn> Passing undefined for one or the other parameter. Or both.
07:33:35 <mauke> join = undefined
07:33:41 <Baughn> Okay. Five.
07:33:46 <mauke> join = const undefined
07:33:50 <Baughn> ..six?
07:33:52 <eflister> :t (***) (+1)
07:33:53 <lambdabot> forall b b' c'. (Num b) => (b' -> c') -> (b, b') -> (b, c')
07:33:55 <mauke> join = const (const undefined)
07:33:58 <Baughn> Oy.
07:34:16 <FunctorSalad> did you know: you can express type functions as types :D
07:34:43 <FunctorSalad> (not as classes)
07:34:58 <FunctorSalad> (types are more flexible)
07:36:44 <Saizan_> you mean type synonyms?
07:38:41 <FunctorSalad> Saizan_: as functional relations http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11115#a11115
07:39:50 <FunctorSalad> err the 'r' variable in 'total'  is bogus
07:41:15 <FunctorSalad> the class 'SetLemma' is unimportant, it just collects lemmas so I don't need a name for each
07:43:01 <Saizan_> FunctorSalad: can you give an example of a function encoded in that way?
07:44:24 <FunctorSalad> Saizan_: the identity function on 'dom' would be "data Id dom a b where Id :: dom a -> Id dom a a"
07:44:49 <FunctorSalad> (types as propositions, functions as functional relations)
07:45:15 <FunctorSalad> so "p :: MyFun a b" is a proof that MyFun a = b semantically
07:46:40 <FunctorSalad> (I have sets of types as unary predicates)
07:47:17 <Saizan_> uhm, though you've to give that proof "manually" instead of getting it computed from the argument?
07:48:35 <Saizan_> but i guess this is more about using haskell as a metalanguage, rather than using this functions for haskell programming?
07:49:05 <FunctorSalad> the proofs are manual, though you can use typeclasse to get some basic automation
07:49:41 <FunctorSalad> the functions could be used to ultimately convince the typechecker that certain types are equal
07:50:04 <FunctorSalad> or maybe for advanced static safety
07:51:02 <Saizan_> yeah though only in the closed scope where you pattern match on the proofs, right?
07:51:43 <FunctorSalad> yes, this whole thing seems to be based on reflecting GHC's type coercions, by means of the :=: type
07:52:11 <FunctorSalad> which makes the type-level surprisingly expressive... I have expressed equalisers in that paste
07:52:48 <FunctorSalad> (or actually it's not just the (:=:) type, all GADTs work with these coercions)
07:54:37 <FunctorSalad> maybe one application is real functors (which are arbitrary functions on types, not just type constructors)
07:55:18 <gwern> @quote PRNG
07:55:19 <lambdabot> Baughn says: Blum Blum Shub, a PRNG derived from poking around R'Lyeh.
07:55:20 <Saizan_> an Equaliser is a proof that two function agree on some argument?
07:55:25 <Saizan_> *functions
07:55:28 <gwern> @quote base
07:55:29 <lambdabot> gwern says: code-base the size of a planet, and no one will use it
07:55:33 <gwern> @quote base
07:55:33 <lambdabot> dylan says: I avoid buzz-buzz whenever possible. I prefer math-based or completely insane terminology
07:55:43 <Saizan_> gwern: can you do that in private, please?
07:55:47 <gwern> Saizan_: no
07:55:53 <Saizan_> gwern: why?
07:55:56 <FunctorSalad> Saizan_: the equaliser of f1 and f2 is the set where they agree yeah
07:55:57 <gwern> @quote hacking.*all
07:55:57 <lambdabot> robreim says: I'm in your base hacking all your lambdas
07:56:06 <gwern> hm. did this HWN repeat all the quotes?
07:56:13 <FunctorSalad> { x : f1 x = f2 x }
07:56:50 <gwern> @quote ramdisk
07:56:50 <lambdabot> idnar says:  <stepcut> gwern: RAM is overrated, swap is where it's at ;) <idnar> swap to a ramdisk! ;P
07:56:58 <gwern> bleh. I guess all the quotes did repeat
07:57:00 <gwern> very sloppy
08:09:41 <ziman> all your base-4.1.0.0 are belong to us
08:21:25 <tuukkah> if i want a statically linked binary from ghc, i should use --ghc-option "-optl-static", right? i found a discussion where they needed to add "-optl-lpthread" before ghc 6.8.3. now i'm trying with ghc 6.10.4 and again, pthread is missing...
08:23:53 <Baughn> tuukkah: Well, do you have a statically linkable pthread on your system?
08:25:13 <tuukkah> Baughn, dunno, but at least the error message is not "can't find pthread", it's "undefined reference to `pthread_mutex_lock'" and same for the other pthread functions
08:26:25 <tuukkah> now i'm trying to figure out what's the correct way to give multiple options. --ghc-option "-optl-static -optl-lpthread" results in gcc: unrecognized option '-static -optl-lpthread'
08:26:42 <tuukkah> and --ghc-option "-optl-static" --ghc-option "-optl-lpthread" results in a dynamically linked binary
08:50:05 <salty-horse> hi. question about the list monad (reading RWH). I don't understand in "do { x <- [1..10]; return x }" the binding causes several evaluations for each value in the list. the de-sugaring of <- didn't help me understand it either
08:53:49 <tuukkah> salty-horse, have you looked at the source code of the list monad?
08:56:55 <Botje> salty-horse: intuitively, "<-" in the list monad means "let x be an element of this list"
08:58:31 <Twey> [1 .. 10] >>= return
08:58:42 <salty-horse> tuukkah, I have looked at RWH's explanation of it.
08:58:52 <salty-horse> reading this now: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AMonad -- brb
08:58:59 <Twey> (>>=) :: [Int] -> (Int -> [Int]) -> [Int]
08:59:12 <salty-horse> err. wrong link
08:59:47 <salty-horse> Twey, yes, I read that part in RWH. I'm at a loss as to the "why"
09:00:04 <Twey> Well it lets you do cool stuff like:
09:00:13 <tuukkah> salty-horse, you should understand what concatMap does. and perhaps read this: http://www.haskell.org/all_about_monads/html/listmonad.html
09:00:34 <Twey> > do { x <- [1 .. 20]; y <- [1 .. 20]; guard (x + y == 20); return (x, y) }
09:00:35 <lambdabot>   [(1,19),(2,18),(3,17),(4,16),(5,15),(6,14),(7,13),(8,12),(9,11),(10,10),(11...
09:00:44 <medfly> more silly questions; is it wrong to want to turn something of type Handle to something of type [Char] ?
09:00:48 <Peaker> salty-horse, basically, when you want to sequence together multiple computations that can convert a result to multiple possible results, you get a "tree" of all possible results
09:00:53 <Twey> medfly: hGetContents does that
09:00:58 <medfly> yesss!
09:01:00 <salty-horse> where is the explicit code to Monad []? the prelude docs mention that instance, but I can't find it in the source code
09:01:04 <Peaker> salty-horse, the list monad flattens that tree and gives you all possible results of trying various computations that have multiple possible results
09:01:08 <Twey> medfly: It may or may not be wrong, depending on how you intend to use it
09:01:09 <Paczesiowa> @seen augustss
09:01:10 <lambdabot> Unknown command, try @list
09:01:17 <Paczesiowa> ,seen augustss
09:01:19 <lunabot>  luna: Not in scope: `seen'
09:01:24 <gio123> anybody from portugal?
09:01:37 <Peaker> salty-horse, instance Monad [] where return x = [x] ; x >>= f = concat (map f x)
09:01:37 <Paczesiowa> preflex: @help
09:01:42 <medfly> Twey, I don't think I have a clue what I'm doing any more
09:01:46 <Paczesiowa> preflex: help
09:01:46 <preflex>  try 'help help' or see 'list' for available commands
09:01:47 <salty-horse> Peaker, but how does the desugaring cause that tree to appear? :) I understand the "all possible results" idea from list comprehensions
09:01:53 <Twey> medfly: hGetContents is lazy IO, which has some disadvantages: IO happens magically behind the scenes as you evaluate the list, so you can't handle errors if they arise
09:02:17 <Peaker> salty-horse, do { x <- xs ; y <- ys; return (x, y) }   converts to:  xs >>= (... rest of do here ...)
09:02:26 <Twey> In simple cases it's easy and clean, but in complex programs it can get complicated.
09:02:40 <Peaker> in full: xs >>= (\x -> ys >>= \y -> return (x, y))
09:02:46 <Twey> preflex: help help help!
09:02:46 <preflex>  help COMMAND - show help for a command
09:02:55 <salty-horse> tuukkah, I'm reading the chapter you linked, and I'll return if I don't undestand it
09:03:09 <salty-horse> Twey, so it's sort of like a map over all values which is then concatenated?
09:03:09 <Peaker> salty-horse, so in a "do" block, each position till the end is actually embedded in a lambda under the line above it
09:03:15 <Twey> salty-horse: Yep.  That's exactly it.
09:03:37 <Peaker> salty-horse, so   do: { a ; b ; c } in the list monad means: for each a, try all { b; c }   and then each b; c   means for each b try all c's
09:03:37 <medfly> Twey, this is supposed to be simple. I just suck at it.
09:03:59 <salty-horse> then I think I'll understand it better if I deconstruct the monad first. (like the previous chapters of RWH did)
09:03:59 <Twey> > [1 .. 10] >>= \n -> [n, n * n]
09:04:00 <lambdabot>   [1,1,2,4,3,9,4,16,5,25,6,36,7,49,8,64,9,81,10,100]
09:04:06 <Twey> Intersperse squares, for example
09:04:26 <Twey> salty-horse: The list monad is particularly easy to deconstruct.
09:04:33 <Twey> :t concatMap
09:04:33 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
09:04:37 <Peaker> > filterM (const [True, False]) [1..3]  -- powerset, as another example :-)
09:04:39 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:04:47 <Twey> return = (: []); (>>=) = flip concatMap
09:05:27 <mercury^> Who else thinks it would be nice if [a, b | c <- d] was sugar for concat [[a, b] | c <- d]?
09:05:28 <Twey> Or, pointedly: return x = [x]; xs >>= f = concatMap f xs
09:05:30 <salty-horse> ok, I think you can pause the explanations now :) thanks
09:05:35 <salty-horse> I've got some reading :)
09:05:45 <Twey> mercury^: Why?
09:06:04 <Twey> I suppose so
09:06:05 <mercury^> Twey: because it's intuitive, unambiguous and saves typing.
09:06:07 <Twey> Conceptually
09:06:10 <Twey> But it's not that useful
09:06:17 <fxr> @pl map ((flip mod) 10) [1..]
09:06:17 <lambdabot> map (flip mod 10) [1..]
09:06:29 <salty-horse> mercury^, I read "a,b" more like "(a,b)"
09:06:33 <Twey> fxr: It's already point-free…
09:06:42 <Twey> salty-horse: You shouldn't
09:06:44 <fxr> Twey: yeah
09:06:46 <Peaker> mercury^, why isn't it (a, b), why [a,b]?
09:07:04 <Peaker> mercury^, also, you're stealing syntax space from future extensions for something that's trivial to do already
09:07:15 * salty-horse is away
09:07:21 <medfly> stealing syntax space! a serious crime :)
09:07:40 <Twey> > [(x, y) | x <- [1 .. 20], y <- [1 .. 20], x + y == 20] -- the comprehension for the monad computation I showed you earlier
09:07:41 <lambdabot>   [(1,19),(2,18),(3,17),(4,16),(5,15),(6,14),(7,13),(8,12),(9,11),(10,10),(11...
09:07:44 <mercury^> Peaker: it's not (a,b) because it's in a list, not a tuple. And no sane extension would use it for anything else.
09:07:53 <Twey> Peaker: That's my main objection.
09:07:56 <mercury^> If you think an extension should use it, the only extension is the one I proposed.
09:08:06 <Peaker> mercury^, Disagreed
09:08:23 <Peaker> mercury^, why is it preferable to the [a,b] version?
09:08:42 <mercury^> because it is far shorter
09:08:55 <Peaker> mercury^, simplifying code is great, saving "characters" while bloating syntax is usually a bad idea
09:08:55 <Peaker> mercury^, its 2 characters shorter
09:09:01 <Twey> Eight
09:09:08 <Twey> Don't forget the ‘concat’
09:09:08 <medfly> eight?
09:09:13 <Twey> Oh, and a space
09:09:18 <Twey> So nine
09:09:26 <Peaker> mercury^, 3 tokens shorter, that is
09:09:38 <Twey> Aye.
09:09:59 <Peaker> Maybe we should name hGetContents   hgc to save 9 characters?
09:10:11 <mercury^> It's also clearer.
09:10:17 <Twey> Not quite the same thing, since hgc is semantic-fre
09:10:18 <Twey> e
09:10:52 <Twey> It is clearer, it is a good thing, but it's just not useful enough to go to all the trouble of adding extra syntax for it
09:11:01 <Twey> It's more overhead for compilers, for a start
09:11:11 <Peaker> I find it less clear... More syntax to learn in order to understand it
09:11:18 <Twey> That too
09:11:44 <mercury^> That's like saying list comprehensions are bad because you have more to learn.
09:11:58 <Twey> They kind of are
09:12:00 <Peaker> I think extending the syntax should be reserved only for very important things.. I am not sure I see why lc's are a good idea rather than do syntax
09:12:06 <chaosape> i feel dirty using typeable and cast.
09:12:09 <mercury^> It has a completely obvious meaning. You don't need to learn anything. The first time you see it, you know what it does.
09:12:25 <Peaker> mercury^, I wouldn't guess that it does what you said
09:12:38 <mercury^> Peaker: what would you think it does?
09:12:42 <Peaker> mercury^, tuples
09:13:14 <mercury^> Why do you think there are tuples coming out of nowhere?
09:13:19 <Saizan> chaosape: you should!
09:13:26 <Peaker> mercury^, out of (,) :)
09:13:34 <Peaker> > (,) 1 2
09:13:35 <lambdabot>   (1,2)
09:13:45 <mercury^> Peaker: well, there is no tuple notation in what I proposed.
09:13:49 <Jafet> Overloading syntax is retarded
09:13:52 <Peaker> (1,) sections are added too. I'd actually like 1,2  to mean a tuple in general
09:14:04 <Peaker> :t ,
09:14:05 <lambdabot> parse error on input `,'
09:14:11 <Peaker> :t (,)
09:14:12 <lambdabot> forall a b. a -> b -> (a, b)
09:14:16 <Jafet> If it means something here, it should mean the same thing everywhere
09:14:24 <Jafet> cf. C++
09:14:32 <Peaker> > 5, 6  -- you'd expect this to apply the infix , operator
09:14:33 <lambdabot>   <no location info>: parse error on input `,'
09:14:49 <Peaker> because (,) is an operator in sections (as of recently in ghc) and in parens
09:15:07 <Jafet> Well, given Haskell's other uses of , that might be too late to apply
09:15:08 <mercury^> Peaker: that's a bad idea because (a, (b, c)) /= (a, b, c)
09:15:13 <mercury^> Unless you want to change that too.
09:15:21 <Peaker> mercury^, I sure do
09:15:27 <Peaker> mercury^, I think its horrible that we have N-tuples
09:15:38 <Peaker> mercury^, :info Show  in ghci for one of the reasons
09:16:14 <Peaker> Also general lack of composability (need an infinite variety of primitives to access the tuple elements)
09:16:18 <mercury^> Peaker: so what does (a,b) = (e,f,g) do?
09:16:40 <Peaker> mercury^, I'd guess just like we have:  a -> b -> c  mean a -> (b -> c)   (e, f, g) could mean (e, (f, g))
09:16:47 <Peaker> so a = e  and  b = (f,g)
09:17:00 <chaosape> saizon: okay, well at least I know all of this guilt is justified.
09:17:02 <Jafet> We'll be using Kuratowski notation for tuples in no time, just wait
09:17:15 <Peaker> Jafet, what's that?
09:17:17 <kw317> what's that?
09:17:18 <Paczesiowa> > let \e f g -> let (a,b) = (e,f,g) in (a,b)
09:17:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:17:24 <mercury^> Peaker: well, that's completely unobvious.
09:17:30 <Paczesiowa> :t \e f g -> let (a,b) = (e,f,g) in (a,b)
09:17:32 <lambdabot>     Couldn't match expected type `(t, t1)'
09:17:32 <lambdabot>            against inferred type `(t2, t3, t4)'
09:17:32 <lambdabot>     In the expression: (e, f, g)
09:17:40 <Peaker> mercury^, So are single-param funcs
09:17:47 <Peaker> mercury^, Haskell still has only single-parameter functions
09:17:49 <mercury^> Peaker: both choices would make sense, and if (a,b,c) = (a,(b,c)), it should _also_ be ((a,b),c)
09:18:02 <Jafet> (a, b) := {{a}, {a, b}}
09:18:04 <Peaker> mercury^, Why?  (,) can be right-associative
09:18:10 <Peaker> mercury^, Just like (->) is
09:18:19 <Peaker> mercury^, why is   a -> b -> c    a -> (b -> c)   and not (a -> b) -> c ?
09:18:23 <Jafet> Peaker, so you're reinventing cons?
09:18:30 <Peaker> Jafet, HList cons though
09:18:42 <kw317> Peaker: it's jsut convenient - minimizes the number of brackets
09:18:42 <Jafet> @hoogle HList
09:18:43 <lambdabot> No results found
09:18:50 <Peaker> Jafet, Except HList is a pretty huge beast to pull into code
09:19:14 <Peaker> kw317, Yeah,  (a,b,c) -> (a, (b,c)) could also do that
09:19:18 <Jafet> Peaker, so you prefer to put it in the core language
09:19:26 <Paczesiowa> Peaker: not to mention it's not practical, ghc probably won't optimise it
09:19:28 <Peaker> Jafet, Tuples already are in the core language and they're done wrong
09:19:51 <Peaker> Paczesiowa, well, I also want unlifted product types.. :-)
09:19:58 <mercury^> The only thing wrong is that compilers don't handle n-tuples automatically but define a fixed number of them.
09:20:11 <Peaker> mercury^, There's much more wrong
09:20:17 <Peaker> mercury^, N-tuples don't compose like 2-tuples
09:20:22 <Paczesiowa> Peaker: (#,#) ?
09:20:26 <Jafet> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20)
09:20:26 <lambdabot>   No instance for (GHC.Show.Show
09:20:27 <lambdabot>                     (t,
09:20:27 <lambdabot>                     ...
09:20:33 <Peaker> Paczesiowa, is that unboxed as well as unlifted?
09:20:41 <Peaker> mercury^, You can't compose arrows with N-tuples, you can't compose SECs with N-tuples, etc
09:20:52 <Jafet> Dependent types!
09:21:02 <Paczesiowa> Peaker: unlifted means no _|_ ?
09:21:05 <Peaker> mercury^, If N-tuples were compositions of 2-tuples, one Show instance would be good
09:21:12 <Peaker> Paczesiowa, no new _|_
09:21:14 <Peaker> Paczesiowa, Yeah
09:21:37 <Paczesiowa> Peaker: you can't write Show instance for nested 2-tuples
09:21:40 <Paczesiowa> Peaker: in h98
09:21:49 <Peaker> Paczesiowa, and pattern-matching doesn't catch the bottom, too, like newtype, but also with products
09:21:52 <Paczesiowa> Peaker: you have to import Oleg
09:22:14 <Peaker> Paczesiowa, Well, 2-tuples should compose N-tuples with whatever extra machinary is necessary, IMO. What is missing for the Show instance?
09:22:21 <mercury^> Peaker: your proposal is pretty unefficient also, because tuples are lifted.
09:22:22 <tuukkah> so [a, b | ... ] would get the automatic concat, but [[a, b] | ... ] could not because of backward compatibility. ugly
09:22:33 <Paczesiowa> Peaker: base instance for (a,b) where b isn't a tuple
09:22:44 <Peaker> mercury^, Yeah, I suppose this is the reason for the less composable choice Haskell made. If type products were unlifted, that would not be a problem
09:22:46 <mercury^> tuukkah: it should not get a concat.
09:22:54 <mercury^> It's a list of lists.
09:23:00 <Peaker> Paczesiowa, Well, you could have an empty-tuple type too for that
09:23:13 <Peaker> Paczesiowa, and have (a,b) be (a,(b,()))
09:23:32 <maltem> having , as an operator does make sense, principally. While we're at it, the type constructor (,) should really be called ⨯ (or something). On the other hand, sometimes you actually want multi-argument functions baked into the language (at least I think I remember a Haskell-related paper talking about that)
09:23:36 <reklama> http://action.metaffiliation.com/suivi.php?mclic=S42665516A5D131
09:23:38 <Peaker> btw: How much is a list comprehension shorter than the equivalent do{} syntax?
09:23:51 <Paczesiowa> Peaker: makes sense
09:24:09 <Peaker> Paczesiowa, I think the main object people have is to unlifted product types
09:24:22 <mercury^> Peaker: do notation is ugly if kept in a single line.
09:24:32 <tuukkah> mercury^, so "a, b" in [a , b | ... ] wouldn't be a list after all?
09:25:20 <Peaker> Paczesiowa, basically, augustuss explained to me that there's a compilation problem with this example:   let p = p ; (x,y) = p in x  -- p is unlifted, so pattern-matching it doesn't create new thunks, so creating thunks for x and y here is a bit more difficult for the compiler (iiuc)
09:25:25 <Paczesiowa> Peaker: (# #) are unlifted, _|_ has different kind than those tuples
09:25:39 <Peaker> mercury^, Because of {} instead of [] ?
09:25:43 <Peaker> mercury^, and the extra "return"?
09:25:53 <mercury^> Peaker: yes.
09:25:57 <Paczesiowa> Peaker: speaking of augustss, what happened to him?
09:26:14 <Peaker> mercury^, I am a minimalist, I don't mind {} and an extra return. I rarely use LC's anyway
09:26:25 <Peaker> Paczesiowa, I don't know, something happened to him?
09:26:39 <Paczesiowa> Peaker: missing from #haskell for almost 2 months
09:26:46 <Peaker> oh, I hope he's alright
09:27:04 <tuukkah> Peaker, plus, you can even use [] instead of the return
09:27:32 <Paczesiowa> :t let p = p; (# x,y #) = p in x
09:27:32 <lambdabot>     Couldn't match kind `*' against `(#)'
09:27:32 <lambdabot>     When matching the kinds of `t :: *' and `(# t1, t2 #) :: (#)'
09:27:32 <lambdabot>       Expected type: (# t3, t4 #)
09:28:06 <jystic> am I missing something simpler if I'm trying to do "foldr ($)"?
09:28:33 <Peaker> tuukkah, ah, right :)
09:28:37 <tuukkah> > do x <- [1,2,3]; [-x, x]
09:28:38 <lambdabot>   [-1,1,-2,2,-3,3]
09:28:40 <Peaker> tuukkah, even better for error messages
09:29:01 <Peaker> > [[-x, x] | x <- [1,2,3]]
09:29:02 <lambdabot>   [[-1,1],[-2,2],[-3,3]]
09:29:20 <Peaker> what do you know, exactly same length :)
09:29:30 <Peaker> I guess when you add "guard" it gets longer
09:29:31 <mercury^> [-x, x | x <- [1..3]]
09:30:05 <Peaker> but I think "guard" is more readable. First thing that bothered me about LC's in Haskell is that a long expression has a completely different meaning if there's <- somewhere in there or if not
09:30:26 <Peaker> > do x <- [1,2,3]; guard (odd x); [-x, x]
09:30:27 <lambdabot>   [-1,1,-3,3]
09:30:57 <mercury^> Peaker: you can consider the x <- [1..3] as a guard too.
09:31:17 <Peaker> mercury^, guard multiplies by 1 or 0, that multiplies the result count by 3
09:31:48 <patch-tag> how can I import the prelude minus a function? I want to cause compile failures when use unsafe functions like last, head, tail.
09:32:09 <patch-tag> tried NoImportImplicitPrelude, import Prelude hiding (last) but that doesn't work
09:32:13 <mercury^> Peaker: well, I rarely find it necessary to estimate the list length by looking at the comprehension.
09:32:29 <Peaker> mercury^, Well, multiplying by zero has a very special meaning though
09:32:59 <tuukkah> > [[-x, x] | x <- [1,2,3], True <- [odd x]]
09:33:00 <lambdabot>   [[-1,1],[-3,3]]
09:33:32 <Peaker> tuukkah, eww use of "fail" :)
09:33:39 <tuukkah> pattern guards ftw =)
09:33:41 <Peaker> mercury^, I don't see statements in the do block that may just don't change the result or completely annahilate it as the same as ones that usually add more possible results
09:34:13 <mercury^> x <- [1..3] removes results too.
09:34:19 <tuukkah> @src guard
09:34:19 <lambdabot> guard True  =  return ()
09:34:20 <lambdabot> guard False =  mzero
09:34:36 <Peaker> mercury^, how? it only multiplies all existing results by 3
09:34:43 <mercury^> You start with a list containing everything and then remove every x not satisfying x \in [1..3].
09:34:45 <tuukkah> @src when
09:34:45 <lambdabot> when p s = if p then s else return ()
09:35:13 <Peaker> @type (guard, \x -> when (not x) mzero)
09:35:13 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (MonadPlus m, MonadPlus m1) => (Bool -> m (), Bool -> m1 ())
09:35:40 <Peaker> mercury^, a list containing everything? :-)
09:35:49 <Peaker> mercury^, Its not a set, its a list with potential repetitions
09:38:31 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.2645
09:39:53 <mercury^> Peaker: yeah, I think it is rarely a good idea to use comprehensions if you don't treat the list as an enumeration of a set.
09:41:51 <mercury^> Speaking of that: ++ or + should cover both concatenation and merging, so that you can get an enumeration of an infinite set from two such.
09:42:29 <mercury^> "++ and +"
09:43:04 <Twey> tuukkah: Eww.  :þ  [[-x, x] | x <- [1 .. 3], odd x]
09:43:34 <mercury^> Twey: he was proving a point (that <- can remove elements).
09:43:39 <Twey> Aha
09:44:51 <ddarius> > [x | x@1 <- [0..10]]
09:44:51 <lambdabot>   [1]
09:44:52 <patch-tag> re what I said before, if you do as I said it will load in ghci without error, but there will be error with cabal install which I guess is most important thing.
09:45:08 <patch-tag> maybe ghci doesn't understand NoImplicitPrelude.
09:45:58 <mercury^> The list monad is very unfriendly towards enumerations of infinite sets at the moment. concatMap should be a mergeMap imo.
09:46:10 <Twey> ddarius: Ooo…
09:46:49 <ddarius> The list monad isn't for enumerations of finite or infinite sets
09:47:03 <Twey> > [x | x@(odd -> True) <- [0 .. 10]] -- Can we do this?
09:47:05 <lambdabot>   Illegal view pattern:  (odd -> True)
09:47:05 <lambdabot>  Use -XViewPatterns to enable view pat...
09:47:10 <Twey> Aw
09:47:18 <ddarius> @hackage control-monad-omega
09:47:18 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
09:47:37 <mercury^> ddarius: why do you want it to work well with finite lists only if you can make it work well with infinite ones?
09:47:38 <Twey> Will that give me [1, 3 .. 10] or [True, True, True, True, True]?
09:48:16 <Twey> Ooh, it works
09:48:53 <ddarius> mercury^: That question doesn't parse to me, and to the extent it does, doesn't seem to be related to my statement.
09:49:19 <mercury^> ddarius: what part of it does not parse?
09:50:29 <ddarius> mercury^: Well, more to the point, I never said I wanted anything, and I didn't say anything about finite or infinite lists.
09:50:55 <Trollinator> Is there a simpler way to express flip (-) x
09:51:04 <ddarius> subtract
09:51:17 <Trollinator> ah, i see.
09:52:08 <Trollinator> thanks.
09:52:48 <mercury^> ddarius: Ok. I thought you found (>>=) = flip mergeMap a bad idea by saying the list monad was not meant for my use case.
09:53:40 <ddarius> mercury^: It's fine, but it's not the list monad.
09:53:55 <mercury^> ddarius: not the current one, yes.
09:53:58 <Twey> > flip (-) 3 $ 2
09:53:59 <lambdabot>   -1
09:54:02 <burp> > [ x | x <- [0..10], odd x ]
09:54:02 <lambdabot>   [1,3,5,7,9]
09:54:04 <Twey> > subtract 3 $ 2
09:54:05 <lambdabot>   -1
09:54:11 <Twey> Huh
09:54:29 <ddarius> mercury^: It's not what the list monad should be.  The Omega monad I referenced is presumably closer to what you want.
09:56:06 <mercury^> ddarius: Why should the list monad be as it is?
09:56:23 <mercury^> (Apart from being what people are used to)
09:57:40 <ddarius> mercury^: It has an extremely natural interpretation and ordering of the elements is inherent in the lists.
10:00:25 <ddarius> I usually want the ordering provided by the list monad as opposed to a diagnolizing merging.  If I want a searching interpretation, I'll use an arbitrary non-determinism monad as there are rather better ones than the list monad, though that one also corresponds directly to Prolog's SLD resolution which I could want.
10:00:42 <dons> little announcement: galois is 10 years old today. thanks to the haskell community for raising and supporting us over the years
10:00:42 <mmorrow> , [x | x@(odd -> True) <- [0 .. 10]]
10:00:44 <lunabot>  [1,3,5,7,9]
10:01:03 <mercury^> dons: happy birthday!
10:01:15 <Twey> Happy anniversary!
10:01:41 <dons> btw, we're still hiring.
10:02:03 <mercury^> How many people are working at Galois at the moment?
10:02:19 <ddarius> , [x | (odd -> x@True) <- [0..10]]
10:02:20 <lunabot>  [True,True,True,True,True]
10:02:30 <burp> > [ True | x <- [0..10], odd x ]
10:02:31 <lambdabot>   [True,True,True,True,True]
10:02:42 <dons> ~40 or so
10:03:42 <ddarius> dons: From your various (indirect) statistics, how large would you estimate the size of the Haskell user-base is?
10:04:11 <dons> yikes
10:04:27 <dons> 100k?
10:06:13 <sproingie> developer base i would suggest is way below that
10:06:40 <dons> certainly
10:06:48 <dons> we've had ~500 unique devs upload to hackage
10:07:38 <ddarius> dons: Which means not even everyone here on #haskell has uploaded.
10:07:44 * ddarius eyes lambdabot.
10:07:47 <`core> awww! http://www.abc.net.au/reslib/200902/r335903_1522158.jpg
10:08:24 <jystic> someone found karmic?
10:08:32 <maltem> > [ x | x@(odd -> True) <- [0..10] ]
10:08:33 <lambdabot>   Illegal view pattern:  (odd -> True)
10:08:34 <lambdabot>  Use -XViewPatterns to enable view pat...
10:08:46 <maltem> , [ x | x@(odd -> True) <- [0..10] ]
10:08:47 <lunabot>  [1,3,5,7,9]
10:08:54 <Guest29909> hi there - asked earlier but didn't have time to chat for long - I'm having problems compiling the haskell unix pkg for cygwin - HsUnix.h not found even though it's in ./include of pkg root dir
10:09:40 <bmf> someone suggested using cabal install but this seems to be just a wrapper to download the source and compile it, and so hits the same problem
10:11:36 <Saizan_> you can use --extra-include-dirs= to add that dir
10:11:37 <dons> check the cygwin faq, http://hackage.haskell.org/trac/ghc/wiki/Building/Windows/Cygwin
10:12:39 <chaosape> if i do something like "data T = forall a. T a"  is it correct to call it sealed?
10:13:19 <dons> yeah
10:14:38 <ddarius> I would say "sealed" doesn't have a commonly used meaning in the Haskell community.
10:14:54 <Saizan_> "Exists", maybe?
10:15:52 <Confusius> help
10:16:12 <salty-horse> Confusius, just ask :)
10:16:41 <Paczesiowa> does anyone have email address for Lennart  Augustsson? the one from his website is being "phased out"
10:17:23 <Confusius> Sorry guys, I was trying to get help on the tool, not from the room...
10:17:28 <ddarius> Paczesiowa: Check the mailing list.
10:18:48 <Paczesiowa> ddarius: thanks
10:19:08 <jystic> what is the state of jobs for Haskell devs in industry?
10:20:58 <`core> not good
10:21:16 <jystic> i figured as much
10:21:20 <`core> but if you can program haskell, you've probably got other good marketable skills
10:21:29 <`core> cause youre a good dev
10:21:39 <kmc> if you can program haskell you won't want to use any other language :/
10:21:51 <jystic> kmc: that's what i'm finding :)
10:21:57 <`core> about 0.5% of jobs in the software section on craigslist mention haskell
10:21:58 <kmc> jystic, you've seen http://www.haskell.org/haskellwiki/Haskell_in_industry ?
10:22:04 <kmc> the list is growing pretty quickly
10:22:18 <medfly> it can't get smaller, can it?
10:22:31 <kmc> there definitely are companies that are willing to put up with you if you show up and say "we should do foo in Haskell"
10:22:49 <`core> "as long as you do bar in Java, son."
10:22:57 <`core> ;)
10:23:03 <kmc> `core, sounds like a good way to ensure you get one of the top 0.5% of dev jobs ;)
10:23:18 <jystic> the more haskell i learn at night, the more i'm getting fed up with writing C# during the day :(
10:23:21 <`core> wonder what indeed.com says about salaries for haskell devs...
10:23:43 <`core> http://www.indeed.com/salary?q1=seattle&l1=haskell&tm=1
10:24:06 * ddarius doesn't mind C#.
10:24:14 * `core does C# for a living
10:24:21 <`core> it's alright.
10:24:24 <jystic> yeah it's ok
10:24:40 <`core> v3.0+ gets more functional
10:24:42 <`core> lambdas
10:24:48 <kmc> what: seattle, where: haskell
10:24:48 <jystic> yeah we're on that
10:24:49 <`core> first-class functions
10:24:57 <jystic> i work with idiots though, maybe that's the real problem haha
10:25:02 <`core> lol
10:25:28 <kmc> better than doing C++ with idiots
10:25:45 <jystic> that's true, that's what we used to do, C++ COM
10:25:52 * `core shudders
10:26:17 <`core> i prefer getting shit done over optimizing alogirthms  and workiing with interoperability
10:26:31 <`core> optimizing memory management and shit, rather
10:26:39 <medfly> is it just me or that indeed website is fake?
10:26:39 <`core> sad but true.
10:26:51 <`core> indeed's just a job board
10:27:05 <`core> i owuldnt take it as 100% spot-on
10:27:29 <Twey> http://www.indeed.com/salary?q1=haskell&l1=seattle&tm=1
10:27:48 <`core> haha whoops
10:27:51 * jystic wishes they would get rid of null from C#
10:28:25 <`core> if (arg == null) throw new ArgumentNullException() is the bain of my existence
10:28:47 <jystic> lol tell me about it
10:28:53 <Twey> Heh
10:29:17 <jystic> at least i have arg.NotNull("arg") now, but it still feels like 50% of the code is checking for null
10:29:19 <ddarius> jystic: That will probably never happen, but the next main Microsoft language may well not include null in every reference type.
10:29:40 <Twey> I don't think F# does, does it?
10:29:42 <`core> it's a daily battle, jystic :)
10:29:52 <bmf> dons:  yeah - adding extra-includes-dirs doesn't seem to cut it. also I have to add it as the windows path ie c:\haskell\unix-2.2.0\include which is a little odd. even with this added and included in output from -v it does not find the file.
10:29:52 <bmf> also thanks for the haskell on cygwin link. already have all the suggested pkgs installed
10:29:55 <ddarius> Twey: It doesn't.
10:29:58 <jystic> Twey: yeah i think F# doesn't
10:30:08 <ddarius> Twey: But F# certainly isn't Microsofts main language.
10:30:17 <Twey> F# could be considered ‘the next main Microsoft language’
10:30:21 <Twey> It's certainly up-and-coming
10:30:38 <Twey> What was the ‘main Microsoft language’ before C#, then?
10:30:40 <`core> 1.2% of craiglist ads reference F#
10:30:48 <`core> VB?
10:30:49 <Vanadium> Twey: C++
10:30:58 <burp> pah, F# ist unpure foo ;)
10:31:05 <Twey> But C++ isn't Microsoft-owned
10:31:08 <Twey> burp: Aye :þ
10:31:26 <Vanadium> Twey: Practically is
10:31:34 <Twey> Heh
10:31:42 <Vanadium> MSVC++ is the dominant IDE and plenty of people only do "Visual C++"
10:31:47 <ddarius> Twey: If F# succeeds like crazy the I'll agree, but I don't think Microsoft is planning on F# becoming bigger than C# or so.
10:31:58 <`core> i dont think so either
10:32:06 <`core> it's a Microsoft Research language
10:32:14 * Twey has no idea why it's called Visual C++.  What's visual about it?
10:32:16 <`core> MSVC++ is not an ide, it's a language
10:32:17 <jystic> it's in vs2010 out of the box though
10:32:40 <Vanadium> Twey: The IDE? It has a GUI GUI editor.
10:32:51 <`core> Visual Studio is the IDE
10:33:02 <`core> :)
10:33:09 <Vanadium> Visual C++ is the part of the IDE that concerns itself with C++ :I
10:33:22 <Vanadium> You can install it separately from all the other flavours, no?
10:33:26 <salty-horse> Vanadium, it's split off for marketing purposes :)
10:33:26 <`core> Visual C++ is MS's version of C++
10:33:30 <`core> a language
10:33:46 <salty-horse> the command line compiler is also "visual c++" :)
10:34:10 <aep> hi!
10:34:19 <`core> hey!
10:34:31 <jystic> i've sown some f# seeds at work, would be nice to work with that instead of c#, but it's still ugly when compared with haskell
10:34:52 <aep> anyone got an e-book or something as a quick guide to haskel for people used to C like language?
10:35:06 <Vanadium> Wikipedia says Microsoft Visual C++ is the IDE :x
10:35:17 <`core> well it's wrong. Visual Studio is the IDE
10:35:29 <aep> all i know about functional programming is what C++ offers, so propably the doc should cover a little bit of that too
10:35:30 <Saizan_> aep: there's the "haskell for C programmers" tutorial, but i've never read that
10:35:39 <aep> aye
10:35:46 <viator_sg> aep: http://www.learnyouahaskell.com/ ??
10:35:56 <aep> most docs i've seen are quite boringly explaining basics of programming
10:36:09 <ddarius> I don't believe there's any such thing as a "quick" guide to Haskell for people used to (only) C-like languages.
10:36:17 <jystic> i enjoyed reading the real world haskell book
10:36:20 <aep> well i know scheme :P
10:36:35 <aep> but i guess thats quite limited compared to haskel
10:36:50 <ddarius> aep: Then I'd recommend starting from something that starts from a Scheme perspective.
10:36:59 <ddarius> aep: Scheme and Haskell are just different languages.
10:37:05 <aep> viator_sg: hey that looks good thanks
10:37:20 <jystic> aep: http://book.realworldhaskell.org/read/
10:37:53 <`core> I like: http://learnyouahaskell.com/
10:37:55 <FunctorSalad> C and Haskell aren't?
10:38:09 <`core> oh that's been said vy viator_sg
10:38:12 <`core> by
10:38:17 <aep> well as far as i understand the mindset around scheme and haskel are similar
10:38:59 <aep> ah real world haskel covers ghc. thats nice :)
10:39:14 <aep> oh the other too.  are there even other compilers?
10:39:46 <burp> no usable ones :D
10:39:53 <ddarius> aep: There are several.
10:40:18 <ddarius> aep: However, GHC is undoubtedly the most "industrial" one out there currently.
10:40:33 <viator_sg> well, hugs is "usable" :P
10:40:34 <chaosape> aep: somebody said the other day "don't try to get things out of the IO monad; put yourself in it" ... I wish someone had told me that when I was converting from c.
10:40:39 <burp> hugs is no compiler :P
10:40:44 <viator_sg> y
10:40:44 <viator_sg> xD
10:40:54 <kmc> aep, if you're writing standard Haskell 98 you don't need to worry much about what compiler you use
10:40:58 <sproingie> yah there's no escape from the IO monad
10:41:13 <kmc> unlike some other popular languages, there is actually a standard apart from the dominant implementation
10:41:32 <kmc> but there is also a lot of cool stuff you can only do with various extensions, which GHC tends to support better than any other implementation
10:41:42 <aep> chaosape: i'll try to remember that when i have a clue what that Is :P
10:41:52 <zygoloid> does anyone seriously work in plain haskell'98?
10:41:53 <Vanadium> Does 98 have hiearchical modules yet?
10:41:59 <sproingie> speaking of the standard, is haskell 2010 still on track?
10:42:11 <chaosape> sproingie: that should be the first things C programmers read because us(at least me) c programs are obsessed with io.
10:42:16 <sproingie> 98 did not have hierarchical modules
10:42:17 <ddarius> Vanadium: Hierarchical modules are an unratified addendum to Haskell 98.
10:42:31 <ddarius> Vanadium: However, every implementation I'm aware of supports them.
10:42:47 <ddarius> All the addendum does is allow . in variable names.
10:42:50 <kmc> don't learn IO too early!
10:42:52 <kmc> please
10:42:57 <kmc> and don't learn monads by learning IO
10:43:29 <applicative> and dont learn fuctors and typeclasses by learning monads...
10:43:37 <chaosape> kmc: if you are trying to learn how to program haskell from c one of the first things you might do is start playing with random numbers ...
10:43:45 <sproingie> Maybe and the list monad are the best to learn first
10:44:05 <pikhq> Maybe and the list monad have monad instances that you can understand.
10:44:06 <sproingie> the list monad gets a little mind-bendy sometimes
10:44:12 <kmc> chaosape, yes, i'm saying that's a bad idea
10:44:26 * jystic watches aep's brain explode from information overload :P
10:44:35 <kmc> just like if i were going from Ruby to C i might try to write a webapp but that would also be a bad idea
10:44:47 <aep> i was about to say that.  you are aware that i have no clue what you are talking about anyway :P
10:45:03 <applicative> take things in the order of the typeclassopedia and learnyouahaskell
10:45:14 <kmc> LYAH ends early doesn't it?
10:45:16 <kmc> also has a dumb name
10:45:16 <aep> yeah reading that. it looks cute :)
10:45:18 <applicative> it does
10:45:21 <applicative> great name!
10:45:24 <skorpan> aep: haskell 98 is just a haskell standard that GHC tries to follow (and extend)
10:45:30 <mercury^> kmc: it's not so bad. You already know the problem domain very well and can focus on the language (which you will spend some time fighting).
10:45:32 <chaosape> kmc: thats probably right. i geuss since i did not have a great math background and to me side-effects were just part of programming, monads come slowly.
10:45:43 <kmc> monads aren't even about side effects
10:45:50 <kmc> that's the problem, people learn IO and think that
10:46:37 <aep> the side effect free promise actually brought me here ;) i hope it is what i imagine it is
10:46:54 <jystic> i think i was lucky having monads under my belt (due to c# linq) before even looking at haskell
10:47:17 <kmc> aep, what do you imagine it is?
10:47:22 <pikhq> jystic: So you just got "Oh, they can do more? Damn..."
10:47:24 <ddarius> jystic: Ever make a CPS monad in LINQ?
10:47:39 <jystic> yeah i'm actually using a CPS monad at work
10:47:52 <kmc> F# has monads, but they gave them another name so as to not be associated with Haskell ;P
10:48:03 <chaosape> kmc: it certainly is my problem ;^) ... i still don't really understand monads ...
10:48:16 <skorpan> kmc: why would they not want to be associated with haskell? microsoft research do haskell
10:48:23 <kmc> don't ask me
10:48:25 <jystic> pikhq: actually i read some good blog articles about other monads and that's how i got on to haskell
10:48:33 <aep> kmc: well a function promises to calculate a specific result and it will do that the same way, no matter at which time you call it.  rather then exploding randomly because some other part of the program changed some state
10:48:43 <FunctorSalad> skorpan: because they're notorious?
10:48:47 <ddarius> jystic: Channel 9 blogs?
10:48:47 <FunctorSalad> monads
10:48:48 <kmc> just like Apple added lambda to C, ObjC, C++ but they call it "blocks" because everyone knows that lambda useless academic wankery
10:48:56 <Vanadium> The typeclassopedia could do with having a web page
10:49:04 <jystic> wes dyer I think
10:49:30 <ddarius> jystic: Yeah, that one.  Hold on a sec.
10:49:31 <jystic> http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
10:49:56 <pikhq> jystic: Ah. :)
10:50:17 <jystic> ddarius: i'm happy i'll be able to rip out my continuation monad when .net 4 comes out (IObservable)
10:50:24 <pikhq> kmc: To be fair, blocks function a bit differently from typical lamda (mostly for the sake of interacting well with C).
10:50:24 <ddarius> jystic: This one: http://blogs.msdn.com/wesdyer/archive/2007/12/22/continuation-passing-style.aspx
10:50:25 <sproingie> blocks comes from smalltalk, as does the syntax for them somewhat
10:50:32 <pikhq> Lambda, even.
10:50:34 <kmc> aep, right.  the important thing is that the same argument gives the same result always
10:50:45 <pikhq> And yeah, it's a Smalltalk thing.
10:51:33 <kmc> aep, that's true of all functions, period.  even the supposed "impure functions" in haskell are actually pure functions where the *result* is a recipe for performing side effects
10:51:34 <ddarius> kmc: C# calls lambdas lambda expressions (as of C# 3.0+, before they were "delegates")
10:52:30 <pikhq> Monads merely happen to be a nice way of composing the different recipes for side effects.
10:52:30 <kmc> admittedly "lambda" is a very arbitrary name.  but it's also older than computers and most programmers ;)
10:52:49 <Twey> kmc: Unless they use unsafePerformIO ☺
10:52:50 <viator_sg> How can I check null with a foreignPrt?
10:52:53 <jystic> ddarius: yeah, that one and the one i posted were very good at explaining continuous and monads for me (at that stage imperative languages were all i knew)
10:53:10 <jystic> s/continuous/continuations/
10:53:19 <sproingie> monads are convenient for side effects but aren't necessarily about them
10:53:19 <chaosape> nullPtr?
10:53:24 <kmc> yes
10:53:24 <sproingie> lists and Maybe don't have side effects
10:53:41 <pikhq> sproingie: My point.
10:53:56 <kmc> monads are a systematic way of structuring computation; one application of that system is to model side effects
10:54:04 <sproingie> there's probably no useful practical description that encompasses all monads.  most of them capture some notion of pipelining.
10:54:10 <sproingie> or sequencing
10:54:14 <viator_sg> chaosape: works with Ptr, i have to use unsafeForeignPtrToPtr then
10:54:18 <c_wraith> The most impressive bit about monads is the way they can be composed.
10:54:53 <kmc> sproingie, it seems they would have to have some notion of sequencing, to implement (>>=)
10:54:53 <kmc> c_wraith, how so?
10:54:56 <c_wraith> When I started learning Parsec, it took about 15 minutes to figure out the structure of the entire system
10:55:07 <ddarius> jystic: Yeah, I enjoyed those articles.
10:55:30 <c_wraith> Because it composed parser pieces the same way STM composes.  And the same way IO composes.
10:56:23 <chaosape> viator_sq: doh! sorry!
10:56:28 <jystic> ddarius: we're using what is essentially that cps monad with an error continuation in quite a lot of situations at work
10:56:34 <c_wraith> It's a very convenient pattern, that's general enough to apply to many uses, and powerful enough to do many things.
10:56:54 <ddarius> jystic: Do you just use it locally or are you using a C# implementation that does tail call optimization?
10:57:53 <lvillani> is there a way to get a cabal-install for ghc 6.12?
10:58:05 <kmc> not last i tried :/
10:58:19 <sproingie> isn't cabal broken for 6.12's package database format?
10:58:26 <jystic> ddarius: we're not using a special c# implementation, although there is protection against stack overflow in the cps library
10:58:36 <ddarius> jystic: How do you do that?
10:58:42 <_Fury> Hello :)
10:58:57 <bockmabe> sup _Fury
10:59:09 <ddarius> jystic: I hear the 64-bit C# implementation optimizes (some?) tail calls.
10:59:21 <_Fury> W[Fals | x <- [2..n-1], n `mod` x == 0
10:59:29 <jystic> ddarius: a thread local variable that counts how many times we've "continued"
10:59:48 <ddarius> jystic: And what does it do when that is "too big"?
10:59:50 <_Fury> Why is sth. like this possible. Why can i write 42 instead of x ? [42 | x <- [2..n-1], n `mod` x == 0
11:00:06 <lvillani> sproingie: yep, but I hoped that recompiling cabal-install from darcs with Cabal 1.8 would fix the issue
11:00:13 <Twey> _Fury: Because if you don't get 42, the match will fail, and that value won't be included
11:00:23 <Twey> The ‘x’ is a pattern
11:00:25 <lvillani> but it complains it cannot find base < 2.2 (duh!)
11:00:26 <sproingie> lvillani: i think there's some bugs still open
11:00:26 <chaosape> viator_sq: withForeignPtr?
11:00:38 <sproingie> least i hope someone's filed a bug
11:00:38 <jystic> ddarius: return until we're back up to the top of the stack, and then continue again
11:00:45 <Botje> _Fury: do you mean before or after the | ?
11:00:48 <kmc> _Fury, it produces the expression on the left for every value of x generated on the right
11:00:53 <kmc> if you don't use x on the left, same rule applies
11:01:02 <kmc> > [42 | x <- [1..10]]
11:01:03 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:01:31 <Twey> Oh, I lied
11:01:33 <Twey> Yeah
11:01:34 <skorpan> > [42 | _ <- [1..10]]
11:01:35 <Twey> D'oh :þ
11:01:35 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:01:41 <kmc> > replicate 10 42 -- a better way
11:01:41 <_Fury> hum
11:01:42 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:01:44 <Twey> I was thinking of:
11:01:49 <burp> o rly? :D
11:01:54 <skorpan> @src replicate
11:01:55 <lambdabot> replicate n x = take n (repeat x)
11:01:57 <_Fury> but it seams to be the same!
11:01:57 <Twey> > [x | 42 <- [2 .. 43]]
11:01:58 <lambdabot>   [x]
11:02:07 <mathijs> Hi all, I'm a bit puzzled by exceptions. I'm porting a java program which can be made pure for the most parts. several functions check their input arguments and throw exceptions if they are not ok. Since the program itself acts as a server (rpc), the main loop catches exceptions and echoes them back to the client since all exceptions are because of user-error....
11:02:29 <kmc> [x | x <- [1..50], let 42 = x]
11:02:32 <mathijs> now, I have 2 choices... start using Maybe / Either everywhere, or throw exceptions too. which is better?
11:02:32 <skorpan> solution: no user input!
11:02:32 <kmc> > [x | x <- [1..50], let 42 = x]
11:02:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:02:41 <ddarius> mathijs: For that purpose you can probably use asychronous exceptions and catch them in IO.
11:02:54 <kmc> > [x | x <- [1..50], let ~42 = x]
11:02:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:03:03 <_Fury> yes but ist is noch 42, 42, 42 ,42
11:03:07 <_Fury> not
11:03:10 <ddarius> mathijs: For that particular purpose, I'd probably recommend throwing exceptions.
11:03:39 <mathijs> ddarius: thought so too.  what about the async stuff you mentioned?
11:03:52 <ddarius> :t Control.Exception.throw
11:03:53 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
11:04:03 <jystic> ddarius: actually just looking at the implementation, we don't even bother with waiting for the stack to get too large anymore
11:04:06 <mathijs> what's async about them?
11:04:17 <kmc> _Fury, did we answer your question?
11:04:30 <_Fury> yes thanks :)) but im very confused
11:04:34 <_Fury> thanks to all!
11:04:50 <kmc> we can try to help you become less confused
11:04:57 <_Fury> putStrLn (show [42 | x <-[1..10]]) is really [42, 42 ,42 ,42 ....]
11:04:58 <jystic> ddarius: if a continuation gets invoked and we're already in running a continuation it just gets scheduled for when the current continuation returns
11:05:04 <ddarius> mathijs: Using throw is what I mean.  They're called asychronous because they can effectively happen at "any" time and also actual asychronous exceptions are also covered by that type.
11:05:08 <_Fury> this is obvious...
11:05:29 <_Fury> but in the case i postet first it works with 42, too
11:05:31 <kmc> _Fury, why are you using putStrLn? For this kind of exploration it's much better to use an interactive environ like ghci
11:05:42 <kmc> or lambdabot :)
11:05:49 <_Fury> i use haskell for the first time
11:05:53 <mathijs> ddarius: ah cool, get it now, thanks
11:06:14 <kmc> > [42 | x <- [1..10]]
11:06:15 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:06:34 <kmc> > [42 | x <- [2..n-1], n `mod` x == 0]
11:06:35 <lambdabot>   * Exception: not a number
11:06:47 <ddarius> mathijs: The only thing you need to watch out for is to make sure the relevant values are evaluated enough to actually throw the exception within you catch block.
11:06:48 <kmc> > let n = 100 in [42 | x <- [2..n-1], n `mod` x == 0]
11:06:49 <lambdabot>   [42,42,42,42,42,42,42]
11:07:07 <kmc> > let n = 100 in [x | x <- [2..n-1], n `mod` x == 0]
11:07:08 <lambdabot>   [2,4,5,10,20,25,50]
11:07:12 <_Fury> isPrime n = [42 | x <- [2..n-1], n `mod` x == 0 ] == []
11:07:27 <_Fury> isPrime 37
11:07:31 <kmc> _Fury, so all you're doing is test if the list is empty
11:07:35 <kmc> so it doesn't matter what the elements are
11:07:43 <mathijs> ddarius: it's mostly stuff like checking if an email address is valid (a@b.c)
11:07:46 <_Fury> AHHH
11:07:48 <_Fury> thanks!!!!
11:07:52 <_Fury> now i get it :))))))))))))))
11:07:57 <kmc> :)
11:07:57 <_Fury> thanks
11:08:00 <kmc> no problem
11:08:04 <kmc> enjoy the haskell :)
11:08:15 <mathijs> ddarius: so I think the regexp matching will evaluate the string
11:08:39 <_Fury> yes i like haskell very much^^ but is really confusing at the beginning..
11:08:43 <kmc> yup
11:08:55 <_Fury> I was only using c++ and java before
11:09:23 <sproingie> think of haskell as having a few simple rules that combine in very tricky ways
11:09:33 <sproingie> it's more like go than chess
11:11:51 <sproingie> i find figuring out what stuff does from type signatures alone is a big help in understanding
11:12:21 <sproingie> like   foo :: a -> (a -> b) -> b
11:12:31 <ddarius> mathijs: If your pure code is small enough and independently useful, it may be better to make it return Maybe or Either or some such.
11:12:34 <jystic> sproingie: i love that about haskell
11:12:51 <ddarius> @djinn foo :: a -> (a -> b) -> b
11:12:51 <lambdabot> Cannot parse command
11:12:55 <sproingie> pretty much the only thing foo can do is apply the function in the second arg to the value in the first
11:12:57 <ddarius> @djinn a -> (a -> b) -> b
11:12:58 <lambdabot> f a b = b a
11:13:08 <_Fury> :))
11:13:25 <sproingie> and not even pretty much
11:14:06 <sproingie> (well there's error, but that breaks the rules)
11:14:23 <_Fury> but you can write foo:: integer->integer->integer foo 1 2 = 5
11:14:48 <ddarius> sproingie: There are a few more possibilities even without (directly) involving bottom.
11:14:57 <_Fury> does that mean foo 1 returns a funktion?
11:15:04 <sproingie> _Fury: it sure does
11:15:10 <_Fury> ah :)) cool
11:15:14 <sproingie> ddarius: what are those?
11:15:23 <_Fury> but what a funktion?
11:15:24 <ddarius> sproingie: \x f -> f $! x
11:15:33 <_Fury> i will try :))
11:15:57 <ddarius> seq is more damaging than bottom in many ways
11:16:00 <sproingie> every function only takes one arg
11:16:09 <sproingie> seq hurts my brane sometimes
11:16:27 <_Fury> but foo 1 does not work :(
11:16:38 <sproingie> it does, it just doesn't know how to show functions
11:17:02 <ddarius> > id
11:17:03 <lambdabot>   {()->()}
11:17:39 <sproingie> > let foo x y = x + y in let bar = foo 1 in bar 2
11:17:41 <lambdabot>   3
11:18:08 <sproingie> but like i said, it just doesn't know how to print a function
11:18:08 <FunctorSalad> oO ( poor-man's kind polymorphism through a code-duplicating preprocessor: good idea? )
11:18:08 <sproingie> > let foo x y = x + y in foo
11:18:08 <lambdabot>   -3->
11:18:08 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
11:18:08 <lambdabot>  -2->
11:18:08 <lambdabot>    {-3->-5;-2->...
11:18:08 <maltem> > (id .) . id
11:18:09 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
11:18:10 <lambdabot>                    GHC.Show...
11:18:20 <sproingie> the hell?
11:18:31 <maltem> wow
11:18:54 <sproingie> lambdabot is a little bit weird
11:18:59 <c_wraith> > (+)
11:19:01 <lambdabot>   -3->
11:19:01 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
11:19:01 <lambdabot>  -2->
11:19:01 <lambdabot>    {-3->-5;-2->...
11:19:20 <FunctorSalad> smallcheck has a class for enumerable types
11:19:23 <jystic> lambdabot's been drinking arrows again
11:19:26 <c_wraith> lambdabot is using the Smallcheck instance for Showing functions
11:19:26 <FunctorSalad> (that's Serial)
11:19:46 <sproingie> ok so lambdabot thinks it knows how to print a function
11:19:47 <_Fury> I love it :))
11:19:50 <sproingie> ghci assuredly does not
11:20:05 <c_wraith> if you import the right modules, ghci will
11:20:06 <_Fury> thank you :))
11:20:13 <ddarius> sproingie: You could easily load a Show instance for function into GHCi.  The one lambdabot is currently using no less.
11:20:25 <_Fury> This really is the friendliest irc channel :)
11:20:28 <sproingie> hopefully it's a little more compact
11:20:51 <ddarius> , vacuum id
11:20:54 <lunabot>  [(0,[])]
11:20:55 <jystic> what is the meaning of Smallcheck's output for (+)?
11:20:57 <FunctorSalad> (maybe every type is enumerable?)
11:21:13 <c_wraith> jystic: maybe this will make it a bit clearer:
11:21:14 <FunctorSalad> jystic: it prints the value table
11:21:17 <c_wraith> > (+ 4)
11:21:19 <lambdabot>   {-3->1;-2->2;-1->3;0->4;1->5;2->6;3->7}
11:21:23 <FunctorSalad> but kinda fails at readability
11:21:28 <jystic> ahh!
11:21:49 <c_wraith> when there are multiple inputs, the table size grows
11:21:50 <FunctorSalad> can has ↦ ?
11:22:11 <ddarius> , show id
11:22:13 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
11:22:21 <ddarius> > text "3"
11:22:22 <lambdabot>   3
11:23:37 <gwern> All power to the lambdas!
11:24:29 <ddarius> > text (f $ show (4+)) where f ('-':cs) = g cs; f (c:cs) = c:f cs; f [] = []; g ('>':cs) = '↦':cs; g cs = f cs
11:24:30 <lambdabot>   <no location info>: parse error on input `where'
11:24:51 <ddarius> > let f ('-':cs) = g cs; f (c:cs) = c:f cs; f [] = []; g ('>':cs) = '↦':cs; g cs = f cs in text (f $ show (4+))
11:24:52 <lambdabot>   {3↦1;-2->2;-1->3;0->4;1->5;2->6;3->7}
11:25:09 <ddarius> > let f ('-':cs) = g cs; f (c:cs) = c:f cs; f [] = []; g ('>':cs) = '↦':f cs; g cs = f cs in text (f $ show (4+))
11:25:10 <lambdabot>   {3↦1;2↦2;1↦3;0↦4;1↦5;2↦6;3↦7}
11:25:15 <sproingie> the rendering for that is less than ideal in my font
11:25:26 <sproingie> the arrow actually butts into the next glyph
11:25:26 <jystic> sproingie: agreed
11:27:02 <ddarius> > let f ('-':cs) = g cs; f (c:cs) = c:f cs; f [] = []; g ('>':cs) = '↦':f cs; g cs = '-':f cs in text (f $ show (4+))
11:27:03 <lambdabot>   {-3↦1;-2↦2;-1↦3;0↦4;1↦5;2↦6;3↦7}
11:28:39 <medfly> c_wraith, thanks again for that thing yesterday :) I've sort of got something figured out
11:29:05 <mathijs> ddarius: one other thing about exceptions: in java, you can mark a function with the 'throws ...Exception'. The compiler will complain if any calling code does not catch them (or are marked to throw them as well). I think this is very nice since it will make sure you handle any exceptions you throw. Do you know if such a feature is available in haskell as well?
11:29:25 <c_wraith> medfly: Wait.  Which thing was I talking about with you? (I'm having issues trying to remember things. :)
11:29:27 <ddarius> mathijs: That's exactly what happens if you use an exception monad of some type.
11:29:49 <c_wraith> mathijs:  I'd use the explicit-exception package for that.
11:30:04 <medfly> c_wraith, I was trying to figure out how to use Network
11:30:17 <c_wraith> medfly: Oh, that was *you*.  I was trying to remember who that was. :)
11:30:26 <medfly> c_wraith, your code which uses Network in a silly manner was very handy.
11:30:35 <_Fury> Ok im off now. Thanks again. see you
11:30:37 <c_wraith> Glad it was of use to someone. :)
11:31:19 <c_wraith> It was mostly a joke because a friend of mine kept typoing wtfd instead of wtf, so I figured I should write a wtf server for him. :)
11:33:31 <mercury^> medfly: what are you up to these days btw?
11:37:10 <mercury^> medfly: what are you up to these days btw?
11:38:39 <medfly> I'm trying to write things in Haskell to improve my skills.
11:38:56 <mercury^> Studying CS then or just liking Haskell?
11:39:40 <medfly> oh, I'm not studying CS... Haskell is nice. I'm a noob. I don't know anything besides Haskell.
11:40:12 <mercury^> Because IIRC you were unsure what to study but decided against math at some point.
11:41:23 <medfly> :-)
11:41:31 <medfly> you remember correctly.
11:42:03 <mercury^> So the question is: what are you studying?
11:42:38 <medfly> I am not studying anything at the moment. I had to do some exams before I could sign up, but by the time I could do them it was too late to sign up. so, I'll study next year.
11:43:25 <mercury^> And what do you plan on doing then?
11:43:50 <medfly> I hope to study mechanical engineering.
11:48:33 <medfly> I don't remember you all too well, sorry.
11:51:09 <mercury^> No problem, my irc notability must be rather small due to my very sporadic activity.
12:12:42 <lispy|web> hello
12:13:06 <sinelaw> hi
12:18:53 <skorpan> i found some haskell bindings to gstreamer (i think).  do they actually work?
12:20:03 <Gracenotes> if a datatype's fields all have strictness !flags, and those fields in turn are either primitives or are datatypes with all strictness flags, the rnf for that datatype can just be rnf _ = (), right?
12:20:37 <Gracenotes> since everything /should/ be evaluated fully, or else the (!) isn't doing its job
12:21:23 <sinelaw> skorpan, maybe ask in #gstreamer? (I just did, btw)
12:22:27 <skorpan> is it possible to install gtk2hs using only cabal-install?
12:22:56 <sinelaw> skorpan, where did you find them?
12:23:02 <skorpan> sinelaw: http://darcs.haskell.org/gtk2hs/demo/gstreamer/VorbisPlay.hs
12:23:10 <skorpan> "import qualified Media.Streaming.GStreamer as Gst"
12:23:17 <sinelaw> hm
12:23:54 <chaosape> skorpan: That package is built with the regular unix conf ... it comes like that out of darcs ... so I would guess no ...
12:29:34 <mmorrow> Gracenotes: rnf a = a `seq` ()
12:29:54 <mmorrow> because your reference to it could still be a thunk
12:29:59 <Gracenotes> ah... right
12:30:27 <ddarius> Which is the default definition of rnf.
12:30:31 <ddarius> @src NFData
12:30:32 <lambdabot> Source not found. :(
12:30:59 <Gracenotes> I was wondering why it returned instantaneously
12:31:27 <Gracenotes> instead of processing 250000 pixels like I told it to
12:32:23 <Gracenotes> okay, that took (50.21 secs, 5224447240 bytes). I am going to have to compile it first, for sure
12:33:30 <zygoloid> Gracenotes: i'd think in the case you describe, rnf !_ = () should work (i'm assuming !_ is legal..)
12:33:38 <zygoloid> > let !_ = 42 in 123
12:33:39 <lambdabot>   123
12:33:58 <zygoloid> > let !_ = undefined in 123
12:33:59 <lambdabot>   * Exception: Prelude.undefined
12:35:07 <mmorrow> <jystic> ddarius: return until we're back up to the top of the stack, and then continue again
12:35:41 <mmorrow> jystic: wow, couldn't you use the exception mechanism or something to unwind a little faster/more efficiently?
12:36:31 <mmorrow> O(1) (one would hope) vs. O(n)
12:41:35 <maltem> wait, a `seq` ()   would be rwhnf
12:42:19 <Elly> @src seq
12:42:19 <lambdabot> Source not found. You type like i drive.
12:42:23 <Elly> aw :(
12:43:08 <monochrom> seq can't have source code apart from source code of compiler
12:44:27 <sinelaw> well, it could be: seq ~x y = y
12:44:36 <sinelaw> (or whatever the syntax is for stric args)
12:44:47 <mmorrow> !
12:44:54 <mmorrow> s/~/!/
12:44:54 <monochrom> Or if you feel bad about lambdabot's insults, I actually like the insults, I like getting them. :)
12:44:55 <Twey> ~ are lazy
12:44:57 <Twey> Yeoah
12:44:59 <Twey> Yeah**
12:45:14 <sinelaw> ok...that's what i meant
12:45:43 <skorpan> what do you do when you've built gtk2hs for 15 minutes and then you get something like "Not in scope: type constructor or class `Visual'"?
12:45:45 <sinelaw> "honey, ~(i'll take the garbage down)"
12:46:04 <sinelaw> skorpan, weep
12:46:19 <monochrom> "but I mean !now"
12:46:28 <sinelaw> "ok, right ~now"
12:47:18 <mmorrow> callCC (\k -> "here i go.." `seq` k ";)")
12:47:34 <skorpan> you guys are such nerds
12:47:46 <mmorrow> heh
12:48:11 <skorpan> screenGetSystemVisual :: Screen -> IO Visual
12:48:19 <sproingie> :t seq
12:48:20 <lambdabot> forall a t. a -> t -> t
12:48:22 <skorpan> Visual is not in scope, how do i debug stuff like that?
12:48:41 <sinelaw> skorpan, sounds like a missing package? assuming gtk2hs works
12:49:03 <skorpan> sinelaw: that's from the gtk2hs sources
12:49:04 <monochrom> missing package would cause an import error instead
12:49:21 <skorpan> i'm grepping for "data Visual" now, assuming it's not a "type" or "newtype"
12:49:23 <sinelaw> right
12:49:45 <skorpan> found no such declaration...
12:49:47 <monochrom> This is compile-time error. I would try a different snapshot or release.
12:50:05 <monochrom> (It is not like I could write missing code!)
12:54:09 <aconbere> does anyone know of a good... simulation example for haskell (like the ant concurrency demo for clojure)
12:55:45 <Cale> aconbere: Well, depends on which concurrency library you want to focus on.
12:56:07 <Cale> aconbere: There were some cool demos by the Communicating Haskell Processes guy
12:57:01 <aconbere> Cale: That's really part of what I'm trying to figure out
12:57:09 <BMeph> aconbere: Have you seen Neil Brown's Boids simulation stuff?
12:57:16 <Cale> http://chplib.wordpress.com/2009/09/16/boids-simulation-part-5/
12:57:20 <aconbere> BMeph: I don't think so
12:57:26 <Cale> That's what I was talking about ;)
12:57:45 <aconbere> hot :)
12:57:53 <BMeph> (FYI: Neil Brown is also known as "the Communicating Haskell Processes guy", apparently. :)
12:58:01 <Cale> hehe
12:58:06 <Cale> I didn't know his name
12:58:28 <Cale> it uses http://hackage.haskell.org/package/chp
12:58:42 <Cale> which is a rather extensive alternate concurrency library
12:58:47 * aconbere nods
12:58:54 <aconbere> this looks at least like an interesting place to start
12:58:56 <Cale> If you want to stick to MVars or STM, there are other things
12:59:16 <Cale> MVar/Chan/etc. are actually really very nice on their own for many things
12:59:38 <BMeph> Ooh, interesting latest blarticle: "Benchmarking STM with Criterion"
13:00:06 <aconbere> There's a nice little tutorial on writing a chat server using threads and chans that seems like a reasonable entry point to the way haskell handles that.
13:00:14 <mercury^> Criterion as in film?
13:00:45 <BMeph> mercury^: Criterion as in bos' new benchmarking system. :)
13:00:55 <travisbrady> is it possible to write good Haskell code w/o knowing how to what Monad Transformers and other such fanciness is?
13:01:06 <opqdonut> yes
13:01:30 <skorpan> n
13:01:30 <skorpan> o
13:01:46 <monochrom> csp is now mathematically understood. (the highest level of understanding you can ever ask for.) its exact relation with ccs is completely worked out by hoare et al. finally. something with retract and monad.
13:02:33 <maltem> travisbrady, there's code that "needs" monad transformers, and code that doesn't
13:02:33 <sproingie> csp i know, what's ccs?
13:02:38 <aconbere> travisbrady: at the very least you can write, performant, and correct haskell code without knowing that :)
13:02:41 <opqdonut> what's scp?
13:02:52 <earthy> csp == communitcating sequential processes
13:02:53 <opqdonut> *csp
13:03:15 <opqdonut> ah
13:03:15 <earthy> -t
13:03:15 <opqdonut> related to pi-calculus?
13:03:25 <earthy> I'm not familiar enough with pi-calculus to answer that
13:03:35 <opqdonut> ok
13:03:36 <skorpan> i read csp as cps (continuation passing style)...
13:03:39 <travisbrady> maltem, aconbere: ok, i often wish there were a list of things you ought to know to be able to say you know Haskell
13:03:42 <dmead> > let stringlist = foldr ((++) . (show)) ""  in stringlist [1,2,3]
13:03:43 <lambdabot>   "123"
13:03:48 <dmead> eeeexcellent
13:04:44 <sproingie> pi calculus is essentially a notation for csp
13:04:45 <maltem> travisbrady, when that list is concluded, Haskell will die
13:04:52 <mercury^> > let stringlist = (>>= show) in stringlist [1,2,3]
13:04:54 <lambdabot>   "123"
13:04:58 <travisbrady> haha
13:05:09 <earthy> sproingie: ah, in that case... :)
13:05:20 <dmead> i prefer composition
13:05:25 <sproingie> ccs is something related but i never learned what it stood for
13:05:33 <Cale> travisbrady: It's specifically possible to write very *bad* Haskell code by overusing monad transformers :)
13:05:58 <sproingie> Cale: what would you consider overuse vs a good use?
13:06:04 <chaosape> I am looking for an alternative way to do this such that I don't need to use typeable and cast (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11118#a11118)
13:06:09 <dmead> if your code looks like perl
13:06:13 <dmead> you've written bad haskell
13:06:15 <earthy> calculus of communicating systems according to wikipedia
13:06:31 <mercury^> Cale: like this? http://rohanlean.de/pub/ghc_optimization/189_2.hs
13:06:57 <travisbrady> Cale: but other than MTs I'd include other fancy things in the list, Arrows, CoMonads, other things with names from the academy
13:07:04 <mmorrow> ddarius: it funny that this paper (on dominators/nested-loops in control-flow graphs) is basically about covering spaces but that connection either was omitted or unknown http://pages.cs.wisc.edu/~ramali/Papers/pldi00.ps
13:07:05 <sproingie> wikipedia sez predecessor to pi calculus
13:07:13 <mmorrow> Cale: you might find that interesting too
13:07:14 <Cale> mercury^: StateT over list is okay :)
13:07:35 <Cale> mercury^: I just find it ugly to see people StateT transforming IO and such.
13:08:05 <Cale> travisbrady: As always, the more abstractions and libraries you know, the more options you have to solve problems.
13:08:26 <mercury^> StateT for some reason is rather slow at least.
13:08:34 <mercury^> Or was when I compared the programs from that directory.
13:08:45 <Cale> travisbrady: But a very plain style is often overlooked. Plain old functional programming works very well :)
13:09:02 <sinelaw> Cale, performance-wise too?
13:09:10 <Cale> sinelaw: sure
13:09:11 <mercury^> Especially performance wise.
13:09:21 <maltem> What's the problem with StateT over IO?
13:09:35 <Cale> maltem: IO already has unbounded amounts of state.
13:09:41 <yitz> Cale: sometimes, StateT s IO is exactly the right abstraction. Problem is, transformers over IO have limited practical usefulness because of certain limitation in GHC.
13:09:43 <Cale> See IORef ;)
13:09:50 <yitz> limitations
13:09:57 <maltem> Cale: only be means of refs, which you have to pass around
13:10:04 * Cale argues that StateT s IO is always excessive
13:10:30 <sinelaw> doesn't lazy evaluation hinder performance of naive FP
13:10:38 <yitz> Cale: it sure beats IORefs
13:10:38 <Cale> At the very least you could use ReaderT over IO then.
13:10:43 <sinelaw> ?
13:10:46 <travisbrady> Cale: i'd agree with that. with proggit and other things it's easy to get obsessed w/ shiny objects and higher levels of expressiveness at the expense of just writing solid "plain old code"
13:10:50 <Cale> sinelaw: huh?
13:10:52 <Cale> sinelaw: no.
13:11:06 <sinelaw> in terms of space
13:11:27 <Cale> sinelaw: monad transformers don't help with that at all.
13:11:28 <mercury^> sinelaw: non-strict semantics in a non-total programming language preclude many nice optimisations. That does not go away when you use abstractions however.
13:11:47 <Cale> sinelaw: But it's not as simple as "lazy evaluation makes space usage worse"
13:12:00 <Cale> Strict evaluation can also harm performance badly.
13:12:03 <maltem> Cale, a ReaderT IORef? Why use IO features where they are not necessary?
13:12:17 <mmorrow> does anyone know off-hand the computational complexity of computing the fundamental group of a graph?
13:12:23 <Cale> maltem: Well, to be honest, I wouldn't transform it at all.
13:12:32 <Cale> maltem: I would pass an IORef
13:12:48 <Cale> maltem: Or not an IORef, and pass parameters explicitly.
13:13:00 <Cale> At least, usually.
13:13:04 <mmorrow> omg score http://www.maths.qmul.ac.uk/~leonard/fundamental/
13:13:08 <benmachine> on a vaguely related note: which is preferable of RWS r w () a, ReaderT r (Writer w) a, WriterT w (Reader r) a?
13:13:11 <Cale> There *are* cases where it's appropriate, but they are rarte.
13:13:12 <Cale> rare*
13:13:46 <Cale> benmachine: Not being able to tell between them because you've newtyped it ;)
13:13:57 <benmachine> hmmm
13:14:11 <maltem> Cale: passing parameters explicitly is a valid alternative independent of IO. I just mean, State is a dead-simple pure abstraction, and IORefs are very specific to IO
13:14:26 <mmorrow> http://www.maths.qmul.ac.uk/~leonard/fundamental/fundamental.g
13:14:53 <Cale> maltem: sure -- and I have no beef with plain State
13:15:16 <Cale> StateT/IO is where it starts to become questionable
13:15:48 <mmorrow> Cale: have you used GAP before?
13:15:55 <Cale> mmorrow: yes, lots
13:15:57 <maltem> It would depend on actual code to be able to detail our arguments, I guess.
13:16:11 <Cale> In fact, often I will do more than just construct an IORef and pass that around. I will pass around partially applied versions of readIORef and writeIORef
13:16:18 <yitz> If you agree with State, then StateT IO is for exactly the same reasons when you are in the IO monad. (Except, as I said, GHC has certain problems with that.)
13:16:49 <Cale> yitz: The trouble is, the IO monad already has sufficient facilities that you shouldn't have to StateT it.
13:16:54 <mercury^> To what degree does GHC do destructive updates anyway?
13:16:55 <mmorrow> Cale: nice, that fundamental.g appears to be written in it
13:17:10 <mmorrow> Cale: (i didn't even know what GAP was until just now)
13:17:20 <yitz> Cale: the State monad already has sufficient facilities that shouldn't have to resort to an IORef.
13:17:24 <yitz> you
13:17:32 <Cale> mmorrow: Yeah, the language sucks, but the library is awesome.
13:17:34 <maltem> Cale: likewise StateT already has sufficient facilities that you shouldn't need IORefs. :P
13:17:42 <Cale> yitz: huh?
13:17:44 * mmorrow starts transcribing his algo into haskell
13:18:09 <Cale> maltem: But you're not StateT'ing some other monad here. You're StateT'ing IO specifically.
13:18:23 <mmorrow> Cale: i'm hoping that he's not using any algos from some library that would be epic to implement
13:18:54 <mercury^> mmorrow: I'm hoping he does, so that we have a good group package soon.
13:19:20 <Cale> mmorrow: Well, GAP's standard library has lots of operations for manipulating representations of groups.
13:19:38 <maltem> Cale: That's not a contradiction per se
13:19:46 <mmorrow> mercury^: heh
13:19:56 <yitz> Cale: variables whose value can be modified are bad. just because the IO monad can do that doesn't mean that you should. better to keep it under control of the type system.
13:20:44 <Cale> yitz: You can think of an IORef as a reference to a pure representation of state which the IO monad operations are threading along if it makes you feel any better.
13:21:10 <dmead> > let stringlist = foldr ((++) . (show)) ""  in stringlist [1,2,3] ++ (show 1.0)
13:21:11 <lambdabot>   "1231.0"
13:21:23 <maltem> Cale: Also it means that as soon as you do something in IO, you're structuring things differently
13:21:47 <yitz> Cale: so in other words, the dynamic variables that will crash my program are internally implemented in some functional way? no, that doesn't make me feel any better.
13:21:47 <Cale> Not using the monad transformer has the advantage that you're not constantly applying lift to things
13:21:54 <aep> any idea what i did wrong here (newbie)  http://codepad.org/2MLAvXyc   ?
13:21:57 <Cale> yitz: what?
13:22:03 <Cale> yitz: crash your program?
13:22:28 <Cale> aep: uhh...
13:22:42 <Cale> aep: First of all, the error mentions a function which isn't listed there
13:22:44 <yitz> Cale: well ok, cause bugs. which could indirectly crash my program.
13:22:57 <maltem> Getting rid of lifts is one valid point :)
13:22:59 <aep> Cale: err typo. the error ocures in line 2
13:23:12 <aep> Cale: and scratch the _
13:23:38 <Cale> yitz: Using IORef s in IO is not any more or less dangerous than using get and put in StateT s IO
13:23:49 <aep> i tried different names, in case this is a name conflict
13:23:55 <mercury^> What sort of highlighting is that?
13:24:33 <Cale> aep: does your file really have numbers like that?
13:24:43 <Cale> aep: could you paste the *actual* code and error?
13:25:07 <Cale> (because there's no way that code will cause that error)
13:25:07 <aep> oops. that was copied from terminal with emacs line numbers. didnt realise, sorry
13:26:26 <Cale> aep: I have a feeling that either you're loading the wrong file, or there's more code in your file than that.
13:26:41 <aep> yes there is more code, but the error is in that line
13:27:00 <skorpan> the error is about "qsort_" which you have *not* pasted
13:27:03 <mercury^> Just post the whole file.
13:27:08 <gwern> > 166 / 11
13:27:09 <lambdabot>   15.090909090909092
13:27:25 <aep> i know i know.  about to paste the correct version. just having problems with emacs line numbers :P
13:27:40 <skorpan> now don't blame emacs :P
13:28:02 <mauke> here's a program that can do the pasting for you: http://mauke.ath.cx/stuff/perl/pastebin
13:28:39 <paolino> One good thing about using IORef s today , is that you will not have StateT s STM tomorrow,
13:28:40 <aep> ok well the pastebin shows an error in line 4. which makes much more sense then what ghc said:  http://codepad.org/6N1FRZwU
13:28:58 <skorpan> you want (h:t)
13:29:01 <skorpan> not [h:t]
13:29:03 <mauke> [h:t] is wrong
13:29:05 <aep> why would ghc whine about line 2 while in  it's perfectly correct?
13:29:13 <aep> yeah from the pastebin error i see my problem
13:30:10 <mercury^> aep: the second case is superfluous.
13:30:19 <mauke> because line 2 is where the definition of quicksort begins
13:30:33 <mauke> the error is for the entire function, not some part of it
13:30:55 <aep> oh well. pointing me at line 4 would have helped *shrug*
13:31:02 <mercury^> Is that hugs giving the better error message?
13:31:08 <mauke> it didn't know which line to believe
13:31:19 <mauke> maybe line 4 was right and line 3 was wrong
13:31:34 <mercury^> mauke: the line contradicting the type annotation should be wrong.
13:31:43 <mauke> true
13:32:14 <aep> was that a suggestion to use a different compiler? :)
13:32:14 <mauke> well, this round goes to hugs
13:32:33 <aep> ah i see, so its not generaly better
13:33:00 <mercury^> I haven't used it, but I suppose it has better messages.
13:33:08 <mercury^> GHC is nice because it can compile.
13:33:11 <mauke> I disagree
13:33:20 <dmead> :t concatmap
13:33:20 <lambdabot> Not in scope: `concatmap'
13:33:24 <mauke> I generally found ghc's error messages better
13:33:25 <dmead> @hoogle concatmap
13:33:25 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
13:33:26 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
13:33:26 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
13:33:38 <dmead> rite
13:33:46 <aep> mercury^: would you mind explaining why?  if i dont add that condition it will pointlessly evaluate [8] with the longer function even though the result is known. is it better to have more calc and less cases?
13:34:31 <aep> ie rather run a long function multiple times rather then catch corner cases that can be cut short ?
13:34:34 <mercury^> It's not more calculation in general. You save one comparison for every iteration.
13:34:39 <mercury^> It is also clearer.
13:34:52 <mercury^> So it performs better on large data and is clearer = win.
13:35:19 <aep> hm not sure why it would perform better on large data.  you have to evalute [x]  for every element in the list
13:35:46 <mercury^> Huh?
13:35:48 <aep> although i know nothing about how "bad" pattern matching performance is. i assumed its just a switch
13:36:30 <aep> oh wait... no you don't that only happens twice..
13:36:44 <aep> never mind. thanks for the hint :)
13:38:15 <dmead> > (++) "1" "2"
13:38:17 <lambdabot>   "12"
13:43:25 <Paczesiowa> @unmtl State s a
13:43:26 <dmead> > let stringlist = foldr ((++) . (show)) ""  in stringlist [1,2,3] ++ show [1,2]
13:43:26 <lambdabot> s -> (a, s)
13:43:27 <lambdabot>   "123[1,2]"
13:43:47 <Paczesiowa> @unmtl State (Maybe s) a
13:43:48 <lambdabot> Maybe s -> (a, Maybe s)
13:43:52 <dmead> > let stringlist a = foldr ((++) . (show))  a ""  in stringlist [1,2,3] ++ show [1,2]
13:43:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
13:43:53 <lambdabot>    arising from the literal `1...
13:44:11 <dmead> > let stringlist a = foldr ((++) . (show))  ""  a in stringlist [1,2,3] ++ show [1,2]
13:44:12 <lambdabot>   "123[1,2]"
13:44:15 <dmead> yea
13:44:29 <dmead> paramterization is way better than partial functions
13:44:39 <dmead> (spelling)
13:45:02 <Paczesiowa> @unmtl State (Maybe (a,s)) a
13:45:02 <lambdabot> Maybe (a, s) -> (a, Maybe (a, s))
13:45:43 <c_wraith> @src State
13:45:44 <lambdabot> Source not found. stty: unknown mode: doofus
13:46:19 <Paczesiowa> @mtl
13:46:20 <lambdabot> Maybe you meant: ft map msg pl unmtl url
13:47:00 <Paczesiowa> @mtl forall s (s -> Maybe (a,s), s)
13:47:01 <lambdabot> Maybe you meant: ft map msg pl unmtl url
13:47:33 <Paczesiowa> anyone else smells some monad from streams?
13:49:51 * ddarius smells comonads.
13:50:09 <Paczesiowa> @uncomtl
13:50:10 <lambdabot> err: Parse error
13:50:14 <ddarius> One could actually implement State s a as forall st. ReaderT (STRef st s) (ST st) a
13:51:40 <dmead> @hoogle intersperse
13:51:40 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
13:51:40 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:51:40 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
13:52:08 <dmead> > intersperse " "  (show [1..100
13:52:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:52:11 <dmead> err
13:52:16 <dmead> > intersperse " "  (show [1..100])
13:52:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:52:17 <lambdabot>         against inferred ty...
13:52:25 <dmead> (show [1..10])
13:52:30 <dmead> > (show [1..10])
13:52:31 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10]"
13:52:33 <sinelaw> > intersperse " " "hi there"
13:52:34 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:52:34 <lambdabot>         against inferred ty...
13:52:37 <sinelaw> > intersperse ' ' "hi there"
13:52:38 <lambdabot>   "h i   t h e r e"
13:52:40 <sinelaw> there.
13:52:41 <dmead> ah
13:52:42 <dmead> tks
13:53:00 <sinelaw> a -> [a] -> [a]
13:54:38 <aconbere> One thing I'm still not entirely sure about is type casting in haskell
13:54:53 <Paczesiowa> which one?
13:54:58 <Twey> aconbere: You don't do it.  :þ
13:55:01 <aconbere> in particular I run into it when using openGL and trying to cast to GLfloat values
13:55:01 <Paczesiowa> unsafeCoerce# ot TypeCast ?
13:55:08 <aconbere> oh, I'm not even sure
13:55:15 <aconbere> I'm sure this will be enlightening
13:55:17 <ddarius> Voltage graphs sound interesting.
13:55:20 <Paczesiowa> unsafeCoerce# one:)
13:55:20 <mauke> there are no casts
13:55:23 <aconbere> I have code like this ((fromRational . toRational) pi)::GLfloat
13:55:23 <Twey> Casting is not a normal part of Haskell programming.
13:55:36 <mauke> aconbere: that looks pointless
13:55:37 <Twey> fromRational . toRational \equiv id
13:55:45 <mauke> Twey: no
13:55:51 <benmachine> :t fromRational . toRational
13:55:52 <Paczesiowa> :t fromRational. toRational
13:55:52 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
13:55:54 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
13:55:57 <ddarius> @src realToFrac
13:55:57 <lambdabot> realToFrac = fromRational . toRational
13:56:01 <benmachine> heehee I was first
13:56:06 * Twey scratches his head.
13:56:24 <Twey> I see
13:56:28 <ddarius> aconbere: Use realToFrac to convert between floating point types.
13:56:31 <benmachine> it's like fromIntegral = fromInteger . toInteger
13:56:31 <Twey> That seems a little unintuitive to me
13:56:37 <mauke> :t pi
13:56:37 <Twey> I guess
13:56:38 <lambdabot> forall a. (Floating a) => a
13:56:51 <aconbere> so yeah
13:57:01 <aconbere> that all get's confusing to me :)
13:57:06 <mauke> s/'//
13:57:15 <aconbere> in particular if ou do what I put up there it works
13:57:21 <ddarius> Twey: It would be id (or a partial identity function) in the case that you were using the same instance of Num/Integral/Fractional/Real for each component function.
13:57:22 <aconbere> and if I use realToFrac it works
13:57:26 <aconbere> but if I do
13:57:45 <aconbere> let realToFrac = fromRational . toRational
13:57:53 <aconbere> and use that, I get type warnings about doubles
13:57:55 <ddarius> You should just be able to write: pi :: GLfloat
13:58:03 <ddarius> :t pi
13:58:04 <lambdabot> forall a. (Floating a) => a
13:58:08 <aeron> Can someone contrast the time/space complexity of foldl versus foldr? :)
13:58:09 <c_wraith> :t fromRational . toRational
13:58:10 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
13:58:22 <mauke> c_wraith: why was that necessary?
13:58:41 <Paczesiowa> dons: I understand that adding Skip constructor made filter-like functions possible to optimize with stream-fusion (compared to unfoldr/destroy), but was lack of Skips the thing that stopped unfoldr/destroy from allowing concatMaps ?
13:58:45 <c_wraith> mauke: I wanted to see what the type was.  It was for my own knowledge.
13:59:02 <mauke> c_wraith: see above. it's just been done two times
13:59:12 <c_wraith> Oh.  sorry.  my mistake :(
13:59:32 <dons> Paczesiowa: not to my knowledge
14:00:30 <kmc> i'm using Data.DateTime.  "toGregorian <$> getCurrentTime" gives me a date exactly 4 hours in the future
14:00:52 <benmachine> @localtime kmc
14:00:53 <yitz> c_wraith: don't worry about it, we all miss stuff that scrolls by sometimes. btw, if it really is only for your own use, another option is to send a private msg to lambdabot.
14:00:53 * mauke blames time zones
14:00:54 <lambdabot> Local time for kmc is Sat Oct 24 16:59:10
14:00:55 <kmc> whereas the UNIX "date" command is correct, so the system timezone is also correct
14:01:08 <benmachine> you are GMT-5?
14:01:42 <kmc> US eastern time
14:01:46 <kmc> that's GMT-4 i think?
14:01:54 <sinelaw> kmc, in four hours time, it will be ok
14:02:02 <kmc> ah, so it's giving me GMT
14:02:08 <Paczesiowa> dons: because if we lose Skips, stream,unstream looks just like listpsi/unfoldr. though that one forall from stream-fusion is easier to understand than unfold/destroy one (are they equivalent?)
14:02:10 <benmachine> well
14:02:16 <benmachine> I am in britain and it is 10pm
14:02:34 * benmachine runs ntpd jsut to check
14:03:11 <sinelaw> @localtime lambdabot
14:03:12 <lambdabot> I live on the internet, do you expect me to have a local time?
14:04:17 <sinelaw> @localtime lunabot
14:05:17 <mauke> @localtime
14:05:19 <yitz> sinelaw: lunabot also lives on the internet, but it's not a smart alec
14:05:20 <lambdabot> Local time for mauke is an illusion
14:05:30 <Twey> Heh
14:05:38 <Botje> mauke is awake 24/7
14:05:40 <hackagebot> dyre 0.8.2 - Dynamic reconfiguration in Haskell (WillDonnelly)
14:05:58 <Twey> Ooh, new Dyre.
14:06:16 <mauke> @localtime
14:06:19 <lambdabot> Local time for mauke is approximately 23:06
14:06:20 <sinelaw> @localtime hackagebot
14:06:41 <sinelaw> @localtime ChanServ
14:07:32 <burp> @localtime
14:07:33 <lambdabot> Local time for burp is Sat Oct 24 23:07:33
14:07:38 <mathijs> ewwww... typesystem puzzles me again :)   I want to have a class that people can implement. I have a default implementation (instance). one of the functions a class needs to implement returns "Map String Doc". now I want other implementations to swap Doc for something else. I figured I need a class DocClass which Doc implements, but now how do I continue?
14:07:39 <burp> correct :>
14:07:51 <yitz> mauke: are you in charge of \bot these days?
14:08:00 <mauke> yitz: no
14:08:30 <sinelaw> mathijs, (DocClass d) => Map String d
14:08:44 <chaosape> anybody have an idea on how i can get this pattern to work without typeable and cast(repeat)? - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11118#a11118
14:08:59 <mathijs> sinelaw: I need to put that in the class definition?
14:09:08 <yitz> sinelaw: that's if all implementations must implement it for all instances of DocClass
14:10:06 <mathijs> yitz: yup, found that too... I couldn't tell the typesystem that my default implementation uses Doc.
14:11:10 <mathijs> yitz: So I figured I need to somehow move stuff 'up' a bit and put the DocOpClass instance type in the class definition.
14:11:17 <yitz> mathijs: one way is to have two versions of the class, one for Doc and the other for the other thing
14:11:47 <yitz> but obviously that doesn't scale if you'll have a lot of Doc-like types
14:12:17 <yitz> in that case, you may need to use an extension, like associated types or multiparameter classes.
14:12:25 <mathijs> yitz: I succeeded by turning on MultiParamTypeClasses, so now I have 'class DocClass doc => MyClass m doc where ....'
14:12:38 <mathijs> yitz: cool... so I did the right thing :)
14:12:51 <yitz> mathijs: you'll probably need a functional dependency
14:13:12 <yitz> class DocClass doc => MyClass m doc | m -> doc where ...
14:13:43 <mathijs> yitz: but I would like to do this without any extensions. No reason :)   but in the past I could work around all extensions by clever use of newtype. Dunno if that's possible now
14:14:50 <yitz> that says that each MyClass works for one specific DocClass type. it might be necessary to allow you to actually use the functions in MyClass without upsetting the type checker.
14:15:32 <yitz> mathijs: yes. unless you really need that generality, better to do without MPTC.
14:17:29 <mathijs> yitz: well, I need this generality because I want to learn the typesystem better :)   just wondering if there is a way to do this without extensions
14:18:03 <samir_> +i
14:18:18 <eflister> is it possible to gchat lambdabot?
14:18:25 <yitz> mathijs: it might be possible, but it depends on the specifics of your classes.
14:19:02 <yitz> eflister: gchat?
14:19:16 <eflister> google chat -- or any IM i guess
14:19:28 <mauke> mwahahaha
14:19:42 <mauke> my @localtime is completely pimped out
14:19:45 <c_wraith> eflister:  you can use private messages on IRC with her.
14:19:48 <yitz> eflister: well, you can private message lambdabot here on IRC
14:19:56 <eflister> yeah but gchat would be way cooler
14:20:06 <sinelaw> c_wraith, it?
14:20:15 <c_wraith> sinelaw:  her.  Officially.  :)
14:20:19 <mauke> @vixen are you a her?
14:20:19 <lambdabot> yes, i am
14:20:31 <sinelaw> @vixen are you an it?
14:20:31 <lambdabot> yes, i am
14:20:36 <sinelaw> bisexual.
14:20:40 <yitz> @vixen what is your gender?
14:20:40 <lambdabot> i dunno...
14:21:23 <eflister> @vixen can i gchat you?
14:21:23 <lambdabot> of course you can
14:21:33 <eflister> @vixen tell me how baby
14:21:33 <lambdabot> Yeah
14:21:56 <mmorrow> Cale: gah, is it common practice to not indent the bodies of functions in GAP programs? the GRAPE library is a 4000-line, tab littered, all-code-beginning-in-column-1 horror-show :)
14:22:07 <mauke> any suggestions for custom @localtime replies?
14:22:18 <eflister> time to get ill
14:22:25 <eflister> obviously
14:22:51 <mauke> well, it has to start with "local time for mauke is ..."
14:22:52 <mmorrow> mauke: 25:12
14:22:57 <mauke> heh
14:25:11 <eflister> anyone have any ideas on this surprisingly subtle problem:  i'm using Data.Heap as a priority queue for scheduling midi messages
14:25:42 <eflister> midi is a serial protocol, where each item has a 'velocity', 'channel', and 'note number' associated with it
14:26:13 <eflister> a velocity of zero turns off a note, any positive velocity turns it on
14:26:29 <yitz> eflister: last i heard, Data.Heap was not recommended
14:27:19 <eflister> i want to make sure that subsequent entries of notes do not turn off previously entered notes by sticking note ends in the middle of them
14:27:42 <eflister> i've had great luck with Data.Heap -- what are the rumors?  igel (the author) was talking to me awhile ago and seemed like a great guy
14:29:19 <eflister> my only complaint is that i can't use a predefined priority policy on a custom item type, i have to make a dummy policy cuz the predefined ones are totally defined for all a
14:30:04 <eflister> anyway, my alg for figuring out whether i have to omit the note end for a new note is awfuly tricky (and currently wrong)
14:31:06 <BMeph> eflister: Have you considered using the Edison package's PQueue (priority queue) data structure instead? :)
14:31:13 <monochrom> I am not sure why priority queue instead of fifo queue.
14:31:32 <mauke> mmorrow: done
14:31:44 <mauke> now I just need people to @localtime me :-/
14:31:47 <yitz> eflister: hinze's PSQueue is also good
14:32:11 <monochrom> @localtime mauke
14:32:11 <eflister> monochrom: i want to be able to add notes in any order.  the heap is in an MVar and another thread is handling them at their scheduled times
14:32:12 <yitz> isn't Data.Heap that old implementation that was used by ghc?
14:32:13 <lambdabot> Local time for mauke is approximately 23:32
14:32:34 <sinelaw> is there a known language that was designed by first defining the denotational semantics?
14:32:55 <sinelaw> precisely
14:33:02 <eflister> BMeph and yitz: i'm new to haskell and don't know those packages, are there advantages?
14:33:40 <yitz> eflister: where did you get Data.Heap? maybe what you're using is not what i'm thinking of.
14:33:40 <mmorrow> mauke: haha
14:33:46 <eflister> it's on hackage
14:33:51 <eflister> yitz ^
14:33:54 <mmorrow> @localtime mauke
14:33:56 <lambdabot> Local time for mauke is Boomtime, the 5th of The Aftermath in the YOLD 3175. Celebrate Maladay!
14:34:00 <yitz> what package?
14:34:02 <mmorrow> hehe
14:34:17 <eflister> @hoogle Data.Heap
14:34:17 <lambdabot> module Data.Graph.Inductive.Internal.Heap
14:34:17 <mmorrow> preflex: localtime mauke
14:34:18 <lambdabot> Data.Graph.Inductive.Internal.Heap data Ord a => Heap a b
14:34:18 <lambdabot> Data.Graph.Inductive.Internal.Heap heapsort :: Ord a => [a] -> [a]
14:34:34 <sinelaw> @localtime preflex
14:34:34 <eflister> @hayoo Data.Heap
14:34:35 <lambdabot> Local time for preflex is 2009-10-24 21:34WHERE IS SARAH CONNOR?
14:34:35 <lambdabot> Unknown command, try @list
14:34:40 <Cale> mmorrow: Yeah, not only does the programming language suck, most of the programmers who program in it are not particularly good at programming specifically, unfortunately.
14:35:00 <eflister> yitz: http://hackage.haskell.org/package/heap
14:35:31 <Cale> mmorrow: (they tend to be more concerned with the mathematics they're trying to implement)
14:35:41 <mmorrow> Cale: it's always amusing seeing non-"programmer" mathematicians or physicists code
14:35:52 <yitz> eflister: oh, ok, i was thinking of something else.
14:36:08 <Cale> mmorrow: Weird gap thing: [1,,2,,,,3,4,,,5] is valid syntax
14:36:12 <mmorrow> you have to make a conscious attempt to not go "gah!!@", especially if they're standing next to you :)
14:36:28 <Twey> > [1,,2]
14:36:29 <lambdabot>   <no location info>: parse error on input `,'
14:36:30 <monochrom> A note translates to two midi messages (start message and end message). And conversely. If I were taking midi message stream as input, and I were to do things correctly, the first thing I would do would be hunting down and translating a pair of start,stop to a single note representation. My single note representation talks about time interval, in addition to start velocity, channel, note number.
14:36:43 <Cale> gap> [1,,2,,,,3,4,,,5];
14:36:43 <Cale> [ 1,, 2,,,, 3, 4,,, 5 ]
14:36:55 <mauke> Cale: it's also valid perl and javascript
14:36:57 <Twey> That's valid in JS
14:36:59 <Twey> Yeah
14:37:07 <Cale> gap> Length([1,,2,,,,3,4,,,5]);
14:37:07 <Cale> 11
14:37:07 <Cale> gap> Elements([1,,2,,,,3,4,,,5]);
14:37:07 <Cale> [ 1, 2, 3, 4, 5 ]
14:37:11 <yitz> monochrom: i think that's exactly what eflister is trying to do
14:37:11 <monochrom> With my representation, there is no risk in "inserting stop messages at the wrong point". There is no stop message.
14:37:41 <ddarius> mmorrow: You do?
14:38:22 <eflister> here's my alg (i'd love any suggestions on either style or substance): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11121
14:38:22 <yitz> Cale: that's awful!
14:38:40 <monochrom> After I translate the input stream to a bunch of my note representations, I could sort them by start time or whatever. I could use priority queue keyed by start time. I could edit by inserting a new note, again keyed by start time.
14:38:43 <FunctorSalad> any way to stop TH from mangling infix type operators to prefix form? :(
14:38:48 <Cale> Also, everything is mutable, and most of the list operations mutate, annoyingly.
14:39:02 <Cale> With stupid aliasing issues.
14:40:27 <ddarius> http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP98
14:40:29 <Twey> mauke: How'd you tweak your time representation in irssi?
14:40:36 <Cale> Which is sad, because if you cut out the imperative features and you're careful about how you use the library, it has decent support for functional programming.
14:40:43 * Twey scrolls up to try to find the info on this language Cale is discussing.
14:40:52 <Cale> Twey: I'm talking about GAP
14:40:57 <mauke> Twey: with a script
14:41:08 <sinelaw> equational reasoning is limited only by IO stuff, right?
14:41:12 <Twey> Oh, right
14:41:31 <mmorrow> ddarius: heh, true. i usually go "gah!!@" anyways ;)
14:41:36 <Cale> sinelaw: You can even reason equationally about how you construct IO actions
14:41:41 <Twey> Cale: Ah, found it.  Weird.
14:41:51 <eflister> monochrom: but we're dequeuing in real time.  we don't want to demand that someone knows when they are going to end their note at the time that they start it.
14:41:54 <sinelaw> Cale, but not about the value resulting from such actions
14:42:00 <Cale> sinelaw: right.
14:42:18 <Cale> sinelaw: You need something else to describe what actually happens when you run one.
14:42:50 <sinelaw> Cale, wait, also what you said before doesn't make sense to me - how can you reason about "how you construct" without knowing the details of each action?
14:43:08 <Cale> sinelaw: There are things like the monad laws
14:43:20 <sinelaw> well, except for those
14:43:39 <aeron> What's the function equivilient of >>=? something with concat and fmap?
14:43:54 <monochrom> I'll just declare I don't understand the question.
14:43:55 <mauke> aeron: huh?
14:43:58 <Cale> aeron: "function equivalent"?
14:44:01 <Twey> aeron: concatMap
14:44:02 <yitz> aeron: >>= is a function
14:44:03 <sinelaw> reader monad
14:44:07 <Twey> (>>=) = flip concatMap
14:44:13 <Twey> (for lists)
14:44:25 <BMeph> ddarius: Love that ingenious declaration of "build", which will make any Haskell-fusion-interested programmer recoil in horror. ;)
14:44:31 <aeron> Twey, thanks, that's what I meant
14:44:45 <yitz> aeron: well, a method - ie, a different function for each instance of the Monad class
14:44:50 <Cale> BMeph: is it different from the standard definition of build?
14:44:58 <mauke> in general, a >>= b = join (fmap b a)
14:44:59 <aeron> yitz: alright, thanks
14:45:21 <eflister> monochrom: my question?  i think you do...
14:45:40 <BMeph> Cale: It seems completely unaware that "build" might have a different meaning to anyone else. :\
14:45:56 <Giarome> Hi guys, i have a question, when i define a function regularPolygon :: Int -> Side -> Shape such that regularPolygon n s is a regular polygon with n sides, each of length s, why is it that n is the side (Side) and s the length (Int), when in the function the order is different??
14:46:01 <Cale> BMeph: What build?
14:46:05 <monochrom> I fail to see why my method doesn't work for "real time" "no look ahead". But since you succeed to see, I'll just give up.
14:46:06 <sinelaw> @src build
14:46:06 <lambdabot> build g = g (:) []
14:46:11 <Cale> that one?
14:46:14 <Cale> That's the normal one
14:46:25 <Twey> mauke: It's just sad that we can't implement >>= in terms of join.
14:46:30 <BMeph> Cale: That is, what he calls "build" is more usually known as "fromList". :)
14:46:46 <Cale> hmm
14:47:07 <BMeph> Cale: (Imagine the cognitive dissonance from that!) ;)
14:47:13 <mauke> Giarome: what
14:47:15 <Twey> :t build
14:47:16 <lambdabot> Not in scope: `build'
14:47:24 <Twey> :-\
14:47:31 <sinelaw> Giarome, it doesn't change the order if you just change the variables in the definition
14:47:44 <sinelaw> if you have a manual type definition, that is
14:48:06 <sinelaw> but i'm not sure i understood your question
14:48:07 <Twey> > build (\f xs -> f 3 xs)
14:48:08 <lambdabot>   Not in scope: `build'
14:48:19 <Twey> Ghost function
14:48:26 <eflister> monochrom: well maybe i'm the one missing something -- but it sounded like you meant that we could never have noteOns without their corresponding noteOffs, and that means that we can't delay determining when the noteOff will be until sometime long after the noteOn
14:48:37 <Giarome> sinelaw, it is defined Int -> Side -> Shape, therefore i dont understand, why i have to call the function with regularPolygon n s
14:48:56 <monochrom> That is the problem with meaningful words. Every meaningful word has so many meanings to choose from. We put more meanings into your meaningful words so you can have more meanings when you look for meanings.
14:49:14 <Twey> ‘To have more than one meaning is to have no meaning.’
14:49:24 <sinelaw> Giarome, i still don't understand. do you have a code example? you can use hpaste.org
14:49:31 <yitz> Giarome: that type signature means use that order when calling the function.
14:50:11 <Giarome> ok, that means n -> Side, s -> Int
14:50:26 <mauke> what
14:50:31 <sinelaw> Giarome, it means that it first takes an Int, then it takes a Side
14:50:35 <Giarome> is the function parameter association right associative, or what?
14:50:40 <mauke> WHAT
14:50:50 <sinelaw> so if you write: regularPolygon a b, then a :: Int, b :: Side
14:50:51 <Twey> Left-
14:51:01 <sinelaw> if you write regularPolygon b a , then the opposite
14:51:52 <yitz> > unwords . intersperse "meaningful" . words $ "That is the problem with words. Every word has so many to choose from. We put more into your words so you can have meanings when you look for ."
14:51:53 <lambdabot>   "That meaningful is meaningful the meaningful problem meaningful with meani...
14:51:53 <Twey> regularPolygon :: Int -> Side -> Shape; regularPolygon n :: Side -> Shape; regularPolygon n s :: Shape
14:52:11 <yitz> > text . unwords . intersperse "meaningful" . words $ "That is the problem with words. Every word has so many to choose from. We put more into your words so you can have meanings when you look for ."
14:52:12 <lambdabot>   That meaningful is meaningful the meaningful problem meaningful with meanin...
14:52:13 <aavogt> but in the type, the -> is right associative, correct?
14:52:13 <sinelaw> :)
14:52:24 <ddarius> eflister: So you can have the same not playing simultaneously?
14:52:26 <mauke> aavogt: yes
14:52:28 <Twey> Oh, yeah
14:52:38 <yitz> > text . unwords . intersperse "meaningful" . words $ "That is the problem with words. Every word has so many to choose from. We put more into your words so you can have when you look for ."
14:52:39 <lambdabot>   That meaningful is meaningful the meaningful problem meaningful with meanin...
14:53:20 <sinelaw> > text . unwords . intersperase "means" . words $ "that type signature means use that order when calling the function"
14:53:21 <lambdabot>   Not in scope: `intersperase'
14:53:23 <eflister> ddarius: well that's the thing about midi -- you can send multiple noteOns without any noteOffs, and they will update that single note's velocity.  no matter how many noteOns occur, a single noteOff will turn off that note completely
14:53:26 <sinelaw> > text . unwords . intersperse "means" . words $ "that type signature means use that order when calling the function"
14:53:28 <lambdabot>   that means type means signature means means means use means that means orde...
14:53:34 <Giarome> ok, i will try to define a regularRectangel with regularPolygon and past the code here
14:53:51 <ddarius> eflister: Isn't that what you want to happen if you are interpreting midi?
14:53:57 <yitz> Giarome: not here, paste it on hpaste
14:53:59 <sinelaw> Giarome, you might want to try some online book/tutorial, such as: learnyouahaskell
14:54:01 <yitz> @hpaste
14:54:01 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:54:03 <sinelaw> @where learn you a haskell
14:54:03 <lambdabot> I know nothing about learn.
14:54:07 <sinelaw> @where learnyouahaskell
14:54:07 <lambdabot> I know nothing about learnyouahaskell.
14:54:08 <Giarome> yitz: ok
14:54:28 <Giarome> sinelaw: i use http://book.realworldhaskell.org
14:54:34 <yitz> @where lyah
14:54:34 <lambdabot> www.learnyouahaskell.com
14:54:42 <ddarius> eflister: The other behavior just sounds like you need to keep a counter (per note) of noteOns and noteOffs and turn the note off whenever that counter is 0.
14:54:45 <sinelaw> Giarome, ah, that should be good (didn't read it either)
14:54:47 <eflister> ddarius: well my queue may know that a noteoff is scheduled in the future, so a new note should not clobber it
14:54:55 <Giarome> and Paul Hudaks book "The Haskell School of ExpressioN"
14:55:22 <mmorrow> Cale: interestingly (fsvo), the GRAPE package makes use of an external C library called "nauty" for its (sub)graph isomorphism needs, and nauty is written by the same person wrote wrote the paper (1981) that the hgal package on hackage implements part of
14:55:41 <Cale> mmorrow: I know, yes :)
14:55:53 <ddarius> mmorrow: How many computational graph theorists are out there?
14:55:59 <eflister> ddarius: yeah i don't want to do it statefully -- the queue has all the necessary state
14:56:03 <mmorrow> ddarius: heh, i guess one
14:56:04 <ddarius> s/graph/group
14:56:10 <aeron> ddarius: i know twwwwwwwwo!
14:56:12 <mmorrow> oh, maybe 2
14:56:31 <sinelaw> you mean twwwwwwwwwwo
14:56:33 <Cale> I took a course where the nauty tools were very useful.
14:56:39 <Cale> I hadn't discovered GRAPE yet.
14:56:40 <aeron> i've got a nauty tool for you?
14:56:41 <Twey> 22:54:48 < Giarome> ok, i will try to define a regularRectangel with regularPolygon and past the code here
14:56:49 <Twey> Giarome: Rectangles are not regular polygons.
14:56:53 <Twey> aeron: Heh.
14:57:02 <Giarome> sorry, twey  ;)
14:57:07 <sinelaw> Maybe you want squares
14:57:16 * mmorrow has nauty*.c, that paper, hgal, and an empty haskell file open on workspace 4
14:57:16 <aeron> sinelaw: square = rectangle
14:57:16 <Giarome> got it
14:57:18 <ddarius> eflister: If by "statefully" you mean monadically somehow, then that's not required.
14:57:27 <aeron> it's just a redundant subclass? :P
14:57:43 <ddarius> mmorrow: Just put an empty file on Hackage and say "patches welcome"
14:57:45 <sinelaw> aeron, really? i'm that stupid
14:57:51 <yitz> Twey: not always true, some rectangles are regular polygons.
14:57:58 <mmorrow> ddarius: you forgot the "!!"
14:58:48 <aeron> -_-
14:59:00 <Twey> yitz: *nod* Fair enough.
14:59:20 <sinelaw> aeron, isn't a square an equilateral rectangle?
14:59:30 <eflister> ddarius: yeah i don't mean monadically.  what's not required?  i just mean "if the queue knows that the next thing after a noteOff you are trying to add is a noteOff, then do not add the new noteOff" and "if the queue knows that there is a noteOff scheduled between a noteOn and noteOff you are trying to add, remove the old noteOff"
14:59:46 <sinelaw> @wiki square
14:59:47 <lambdabot> http://www.haskell.org/haskellwiki/square
14:59:54 <sinelaw> ah, not that one :)
14:59:55 <yitz> Twey: so it just means Giarome's regularRectangle will not be total.
14:59:58 <sinelaw> http://en.wikipedia.org/wiki/Square_%28geometry%29
15:00:39 <ddarius> eflister: Are you receiving note commands in (temporal) sequence or are you just receiving notes that may be added anywhere in the performance?
15:00:53 <yitz> eflister: it really sounds like this queue is not what you need
15:01:27 <yitz> @google square
15:01:28 <lambdabot> http://en.wikipedia.org/wiki/Square_(geometry)
15:01:28 <lambdabot> Title: Square (geometry) - Wikipedia, the free encyclopedia
15:02:25 <sinelaw> @dict Square
15:02:26 <lambdabot> Supported dictionary-lookup commands:
15:02:26 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
15:02:26 <lambdabot> Use "dict-help [cmd...]" for more.
15:03:01 <eflister> yitz: please elaborate
15:03:07 <yitz> eflister: given a note-off, how do you decide whether it corresponds to any particular note-on?
15:03:12 <eflister> ddarius: anywhere in the performance
15:03:38 <yitz> same note value? also needs to be same velocity?
15:03:45 <eflister> yitz: that decision is not necessary afaict
15:03:46 <yitz> same instrument?
15:03:54 <eflister> yitz: oh
15:04:01 <eflister> yitz: same notenum, same channel
15:04:11 <yitz> oh, channel, ok.
15:04:19 <eflister> yitz: a zero velocity will turn it off, any positive velocity will update the velocity to that new value
15:04:57 <hslash> every programmer tests their software ofcourse, but usually in a software engineering approach, what is the output of the testing phase/
15:05:19 <ddarius> eflister: How do you differentiate between: |---| |---| and |---===---| unless you are given notes in noteOn/Off pairs?  If you are, I don't understand your issue with monochrom's suggestion.
15:05:26 <hslash> What documents are produced and what would they contain?
15:05:30 <mmorrow> hslash: Segmentation fault?
15:05:48 <yitz> eflister: given two note-offs for the same note, how do you decide which is valid and which should be discarded? by their order in time, or by their order in the input stream?
15:06:37 <mmorrow> hslash: i like the standard C test method myself
15:06:44 <stoop> heh
15:06:44 <mmorrow> hslash: (1) run program, (2) check output, (3) if output != "Segmentation fault" then "PASS"
15:06:46 <sinelaw> hslash, for one, coverage
15:06:47 <ddarius> (|---|  |---| and |===---===| rather
15:06:49 <ddarius> R)
15:06:53 <hslash> mmorrow: well, I am developing a dynamic website. I will test "units" of software pertaining to each functional req.
15:07:07 <hslash> mmorrow: Now, I don't know exactly what documents will be produced from this
15:07:08 * stoop just finished around 2000 lines of regressions for a C library
15:07:27 <eflister> yitz: this is a priority queue, so their order in time is the order in the stream.  there is no notion of "note" that pairs an on and an off (well in my hpaste there is, but i want to remove that).  if you know that a noteOff is in the future, and there is no intervening noteOn, you know you should not preempt that future noteOff with a previous one.
15:07:28 <ddarius> hslash: Will be or should be?
15:07:47 <hslash> ddarius: should be*
15:07:51 <mmorrow> hslash: is pass/fail a binary value?
15:08:18 <eflister> ddarius: there is no =, only -
15:08:23 <monochrom> My representation does not capture a note that is on, then changes velocity a couple of times. That is a problem and can be fixed by changing the representation of a single note. This has nothing to do with the "no look ahead" requirement. There is some clever use of laziness that satisfies the "no look ahead" requirement.
15:08:28 <hslash> mmorrow: I don't see how that's relevant to my question
15:09:07 <mmorrow> hslash: because if so, then there's not much else to put into a document describing that result of the tests other that to enumerate each functional unit and whether is passed or failed
15:09:23 <hslash> mmorrow: Oh I see
15:09:49 <yitz> eflister: but i thought you said notes can come in any order, occurring anywhere in the performance at any point in your input.
15:09:58 <mmorrow> hslash: so i guess it's maybe a matter of making the "result" type richer than pass/fail
15:10:52 <hslash> mmorrow: Yes, but should there be any specific outputs during the testing phase?
15:11:09 <eflister> yitz: by stream did you mean the input to me?  i thought you meant my output.  noteOns and noteOffs can be put into the queue for some scheduled future time, and i may find out about them at any time.
15:11:31 <hslash> mmorrow: For example, a requirements specification is required before implementation. I wonder if there should be something specific after implementation
15:11:32 <yitz> hslash: you need an STP that relates tests to functional requirements. that is static. then each test run produces a document that says which tests passed and failed
15:11:53 <mmorrow> hslash: you might find it interesting browsing the haddock docs for QuickCheck and seeing their types and the organization of that lib
15:12:14 <yitz> eflister: yes, i meant the input to you
15:12:24 <eflister> yitz: i may have to add a noteOn without knowing when or if its corresponding noteOff will be scheuled
15:12:30 <hslash> yitz: Those are the automated test tools right? Like a test harness?
15:12:31 <mmorrow> hslash: e.g. this module in particular http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.2/doc/html/Test-QuickCheck-Test.html
15:12:49 <yitz> hslash: no, documents
15:12:57 <mmorrow> hslash: (http://hackage.haskell.org/package/QuickCheck)
15:13:30 <aeron> ?pl repli (x:xs) n = [x | _ <- [1..n]] ++ repli xs n
15:13:30 <lambdabot> (line 1, column 16):
15:13:30 <lambdabot> unexpected "="
15:13:30 <lambdabot> expecting variable, "(", operator or end of input
15:14:00 <yitz> eflister: this has to work in real time?
15:14:08 <aeron> Why is that an error?
15:14:09 <hslash> yitz: So I run the STP on my code for it to produce output documents showing test results
15:14:32 <hslash> mmorrow: I am beginning to understand
15:14:40 <reklama> http://action.metaffiliation.com/suivi.php?mclic=S42665516A5D131
15:15:12 <yitz> hslash: STP is a document. it describes (to humans) which tests verify which items in your functional requirements document.
15:15:44 <hslash> yitz: Ohhhh, I misunderstood entirely
15:15:56 <eflister> let's say the queue has    ...  ---|     |------|   |--------   ... in the future.  this fully determines what i should do with any new noteOn or noteOff for any future time.  a noteOn during ---- just updates velocity.   during (blank space) it makes  |----- ....    a noteOff during -----|  should be a noop, during ----...  should make a -----| , and during (blank space) should not occur.  yeah, realtime is the idea...
15:16:15 <yitz> hslash: but you can write your STP in literate Haskell if you want. Then running the STP will also actually perform the tests. :)
15:16:38 <hslash> yitz: Excellent. Thankyou
15:16:49 <hslash> mmorrow: Thankyou too.
15:18:06 <aeron> Anyone know why I got that error like 15 lines up?
15:19:26 <monochrom> The output of a testing phase is a paper slip with 20 lines of "PASSED" on it. I got one when I bought an APC UPS.
15:20:10 <mauke> aeron: @pl doesn't do patterns or list comprehensions
15:21:19 <aeron> mauke: thanks
15:22:09 <aeron> parsing difficulties or just impossible to make code using those two things point free?
15:22:29 <Paczesiowa> @unmtl MaybeT
15:22:30 <lambdabot> err: `MaybeT' is not applied to enough arguments, giving `/\A B. A (Maybe B)'
15:22:36 <mauke> patterns in general are impossible; list comprehensions are just not implemented
15:22:43 <Paczesiowa> @unmtl MaybeT Id
15:22:44 <lambdabot> err: `MaybeT Id' is not applied to enough arguments, giving `/\A. Id (Maybe A)'
15:22:46 <Paczesiowa> @unmtl MaybeT Id a
15:22:47 <lambdabot> Id (Maybe a)
15:22:52 <yitz> monochrom: not always. sometimes there are other fields, like how long the test took, how much smoke came out of the cpu during the test, etc.
15:23:05 <Paczesiowa> @unmtl StateT MaybeT Id a
15:23:06 <lambdabot> err: `MaybeT' is not applied to enough arguments, giving `/\A B. A (Maybe B)'
15:23:12 <aeron> mauke: alright thanks
15:23:15 <Paczesiowa> @unmtl StateT (MaybeT Id) a
15:23:16 <lambdabot> err: `StateT (MaybeT Id) a' is not applied to enough arguments.
15:23:21 <Paczesiowa> @unmtl StateT s (MaybeT Id) a
15:23:22 <lambdabot> s -> Id (Maybe (a, s))
15:23:34 <monochrom> yitz: I said it to add laughs. :)
15:23:39 <Paczesiowa> @unmtl StateT s Maybe a
15:23:39 <lambdabot> s -> Maybe (a, s)
15:23:46 <yitz> monochrom: i know :)
15:23:58 <yitz> you succeeded here.
15:24:00 <mauke> @undo \xs n -> [head xs | _ <- [1..n]] ++ repli (tail xs) n
15:24:00 <lambdabot> \ xs n -> concatMap (\ _ -> [head xs]) [1 .. n] ++ repli (tail xs) n
15:24:05 <mauke> @. pl undo \xs n -> [head xs | _ <- [1..n]] ++ repli (tail xs) n
15:24:06 <lambdabot> ap (ap . ((++) .) . (. enumFromTo 1) . (=<<) . const . return . head) (repli . tail)
15:24:35 <mauke> @. pl undo repli xs n = [head xs | _ <- [1..n]] ++ repli (tail xs) n
15:24:35 <lambdabot> repli = fix (ap (ap . ((++) .) . (. enumFromTo 1) . (=<<) . const . return . head) . (. tail))
15:25:11 <BMeph> monochrom: NEED MOAR FUNNEH PLZ, KTHXBAI ;p
15:25:31 <sinelaw> :)
15:26:22 <monochrom> Oh oops, I didn't read yitz statement completely. I now see "how much smoke", hahaha
15:27:20 <yitz> monochrom: they cut off that part of the paper slip before they ship it with your ups though.
15:28:28 <lvillani> I'm trying to get file mtimes by applying map getModificationTime to a FilePath array but I'm having some problems with the IO Monad which I find somewhat difficult to understand ^^
15:28:37 <mauke> mapM
15:28:54 <mauke> map will just give you a list of IO actions
15:29:12 <mauke> mapM will do the same, but then it combines them all into one big IO action that gives you the results in a list
15:29:35 <Paczesiowa> is (e,) a monad? or anything else interesting?
15:29:55 <lvillani> mauke: thanks
15:30:07 <mauke> Paczesiowa: it's a Functor
15:30:18 <mauke> can't be a monad because it can't return
15:30:19 <yitz> > (1,2) >>= snd
15:30:20 <lambdabot>   No instance for (GHC.Base.Monad ((,) t))
15:30:20 <lambdabot>    arising from a use of `GHC.Base...
15:30:25 <Paczesiowa> mauke: no, that's too trivial
15:30:40 <Paczesiowa> mauke: what can you tell me about monad inside a functor?
15:30:49 <mauke> huh?
15:30:54 <lvillani> (by the way, I ordered "Programming in Haskell" at my local bookstore, I should stop making silly questions as soon as it arrives :-) )
15:31:06 <mauke> preflex: ? rwh
15:31:07 <preflex>  http://book.realworldhaskell.org/read/
15:31:09 <Paczesiowa> mauke: like (e, m a)
15:31:34 <mauke> Paczesiowa: well, it's a monad
15:31:44 <Giarome> hey guys, here is my code, please help! it is self-documentig
15:31:45 <Giarome> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11122#a11122
15:31:46 <mmorrow> Paczesiowa: i think you meant so say "the image of a monad under a functor"
15:31:53 <mmorrow> or something
15:31:54 <monochrom> Making silly questions is fine. Don't forget to put them on twitter.
15:32:01 <yitz> > (2,(*3)) <*> (4,5)
15:32:02 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:32:02 <lambdabot>    `Data.Monoid.Monoid t'
15:32:02 <lambdabot>  ...
15:32:15 <carlocci> is learnyouahaskell a good start or should I just read rwh
15:32:18 <Paczesiowa> mmorrow: maybe, anything interesting about that?
15:32:21 <lvillani> :)
15:32:25 <yitz> > (2,(*3)) <*> (4,5) :: (Int,Int)
15:32:26 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
15:32:26 <lambdabot>    arising from a use of...
15:32:30 <mauke> carlocci: it is good
15:32:33 * monochrom goes write academic paper "twitter as version control"
15:32:41 <mmorrow> Paczesiowa: i'm not sure :), haven't ever thought about that particular situation in particular before.
15:33:11 <Paczesiowa> mmorrow: Stream a s = (StateT s Maybe a, s)
15:33:16 <carlocci> mauke, well, it has pictures :)
15:33:16 <Giarome> carlocci: i read rwh and i am quite on the right track, i think, but learn you a haskell is quite good too, i think
15:33:16 <mauke> carlocci: yes!
15:33:16 <lvillani> is there a complete printable version of that online book? (learnyouahashell)
15:33:19 <SamB_XP_> monochrom: in all honesty, I think I'd prefer to use eMule ...
15:33:48 <yitz> lvillani: last i heard, BONUS (the author) was working on that
15:34:01 <carlocci> Giarome, well I think I'll keep on reading it then. It might help since I don't really have any experience with functional programming
15:34:06 <SamB_XP_> what's the problem? does it contain too many swear words?
15:34:25 <carlocci> thanks all
15:34:47 <Paczesiowa> SamB_XP_: swear words? there are pictures for little kids...
15:35:07 <mauke> Giarome: I'd consider a unit circle, divide it into n equal segments, then compute cartesian coordinates for the points on the circle
15:35:11 <SamB_XP_> Paczesiowa: talking about learnyouahaskell
15:35:23 <Paczesiowa> SamB_XP_: I know:)
15:35:29 <Giarome> mauke: yeah i just thought of that! thanks!
15:35:30 <SamB_XP_> I'm making jokes about the meaning of "printable"
15:35:36 <monochrom> making a regular polygon that way requires acing some previous math course that everyone flunks.
15:35:48 <Paczesiowa> :info MonadError
15:36:07 <SamB_XP_> monochrom: making one how ?
15:36:25 <SamB_XP_> does this have something to do with a polar plot of your grades ?
15:36:26 <yitz> oh, print*able*. BONUS is working on actually printing it.
15:41:09 <Paczesiowa> ok, streams arent MonadError:/
15:46:07 <ddarius> > 1 ** (1/5)
15:46:07 <lambdabot>   1.0
15:46:22 <ddarius> > (1 :+ 0) ** (1/5)
15:46:23 <lambdabot>   1.0 :+ 0.0
15:46:42 <sinelaw> > let n = 5 in (liftM2 (,) realPart imagPart) . map (\k -> exp (0:+(2*pi*k/n))) [1..n]
15:46:43 <lambdabot>   [(0.30901699437494745,0.9510565162951535),(-0.8090169943749473,0.5877852522...
15:46:49 <ddarius> > cis (2*pi/5)
15:46:50 <lambdabot>   0.30901699437494745 :+ 0.9510565162951535
15:46:52 <sinelaw> for a square,
15:46:54 <sinelaw> > let n = 4 in (liftM2 (,) realPart imagPart) . map (\k -> exp (0:+(2*pi*k/n))) [1..n]
15:46:55 <lambdabot>   [(6.123233995736766e-17,1.0),(-1.0,1.2246467991473532e-16),(-1.836970198721...
15:47:40 <sinelaw> errr, nope.
15:47:56 <ddarius> "If a feature is a bad idea, then features built on top of it are even worse ideas."
15:49:06 <sinelaw> actually that was right
15:49:21 <Giarome> can anyone write me the code for the regularPolygon ?? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11122#a11122
15:49:38 <sinelaw> > let n = 4 in (liftM2 (,) (round.realPart) (round.imagPart)) . map (\k -> exp (0:+(2*pi*k/n))) [1..n]
15:49:39 <lambdabot>   [(0,1),(-1,0),(0,-1),(1,0)]
15:49:47 <sinelaw> Giarome, there you go
15:49:56 <sinelaw> (except you don't need the 'round')
15:51:13 <sinelaw> that's one way to calculate the positions of each of the vertices
15:52:50 <Giarome> do you know another?
15:53:04 <sinelaw> equivalently you can use cos, sin
15:53:18 <sinelaw> actually i complicated it unnecesarily
15:53:37 <Giarome> i am looking for the right formula to do this
15:54:03 <sinelaw> > let n = 4 in map ((liftM2 (,) cos sin) . (\k -> 2*pi*k/n)) [1..n]
15:54:04 <lambdabot>   [(6.123233995736766e-17,1.0),(-1.0,1.2246467991473532e-16),(-1.836970198721...
15:54:11 <sinelaw> same result, shorter code
15:54:23 <monochrom> sinelaw: This particular question is particularly demanding because, instead of inputting the radius, the input is the desired side length, so first you have to reverse-engineer the right radius before you can use the circle.
15:54:27 <SamB_XP_> > map ((0:+1)^) [1..]
15:54:29 <lambdabot>   [0.0 :+ 1.0,(-1.0) :+ 0.0,(-0.0) :+ (-1.0),1.0 :+ (-0.0),0.0 :+ 1.0,(-1.0) ...
15:55:14 <sinelaw> monochrom, ah
15:55:17 <SamB_XP_> > map ((realPart &&& imagPart) . ((0:+1)^)) [1..]
15:55:18 <lambdabot>   [(0.0,1.0),(-1.0,0.0),(-0.0,-1.0),(1.0,-0.0),(0.0,1.0),(-1.0,0.0),(-0.0,-1....
15:55:27 <Giarome> monochrom: start with a unitcircle, just as mauke said and then "stretch" it
15:55:34 <ddarius> That hardly makes it harder.
15:55:53 <sinelaw> you can calculate the radius from the side length
15:56:25 <monochrom> I aced the math course. I know it's easy for those who aced the math course.
15:56:36 <sinelaw> i didn't ace any course
15:56:46 <sinelaw> high school math
15:56:58 <dmead> hey channel
15:56:59 <Giarome> yeah, thats higher mathematics
15:57:32 <dmead> is there any way to test if a parameter has a specific constructor of it's type?
15:57:45 <SamB_XP_> > map ((realPart &&& imagPart) . ((0:+1)^)) [1..] :: [(Int, Int)]
15:57:46 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
15:57:46 <lambdabot>    arising from a use o...
15:57:53 <ddarius> dmead: I don't understand your question.
15:57:55 <monochrom> Use pattern matching. Write a function that uses pattern matching.
15:57:58 <yitz> radius = (side / 2) / sin (pi / n)
15:58:03 <SamB_XP_> > map ((realPart &&& imagPart) . ((0:+1)^^)) [1..] :: [(Int, Int)]
15:58:05 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
15:58:05 <lambdabot>    arising from a use o...
15:58:14 <monochrom> Example: null
15:58:16 <Giarome> yitz, where do you know that from?
15:58:17 <monochrom> @src null
15:58:17 <dmead> monochrom, sure, but can you use just one pattern?
15:58:18 <lambdabot> null []     = True
15:58:18 <lambdabot> null (_:_)  = False
15:58:25 <SamB_XP_> @instances-importing Data.Complex Num
15:58:26 <lambdabot> Complex a, Double, Float, Int, Integer
15:58:36 <SamB_XP_> @type (:+)
15:58:37 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
15:58:48 <SamB_XP_> ... why does that need RealFloat ???
15:59:04 <monochrom> @src isNothing
15:59:05 <lambdabot> isNothing Nothing = True
15:59:05 <lambdabot> isNothing _       = False
15:59:33 <dmead> hmm
15:59:35 <monochrom> This example is better. It shows you can use _ if you want to. It scales to more constructors, _ catches them all.
15:59:39 <dmead> yea i guess thats the only way
16:00:09 <hackagebot> pointful 1.0 - Pointful refactoring tool (MikhailGlushenkov)
16:00:25 <monochrom> There is an even better way. Re-architect your program so you no longer think in terms of dichotomies.
16:00:33 <yitz> Giarome: draw a radius from the center to one of the vertices. draw a line segment from the center to the midpoint of a side touching that vertex. you get a right triangle.
16:01:24 <dmead> monochrom, the problem dictates that i do
16:01:24 <dmead> i'm writting a missionary and cannibals engine
16:01:39 <Giarome> yitz, it does depend on the number of sides though, doesn
16:01:43 <Giarome> t it
16:01:45 <sinelaw> > let sideToRadius s n = s/(2*sin(pi/n)) in sideToRadius (sqrt 2) 4
16:01:46 <lambdabot>   1.0000000000000002
16:01:48 <yitz> Giarome: yes
16:02:13 <Giarome> ok thanks, i ll think about that
16:03:31 <Giarome> sinelaw, thank you too
16:04:17 <sinelaw> no problem. that last line was an answer you can decipher if you give up.
16:04:32 * SamB_XP_ wonders how he has two shortcuts with apparently the same caption on the desktop ...
16:05:14 <gaze> i'm a little confused about how the monad transformer stack is usually done... what the conventions are... Say i'm writing a game that holds some state about score, etc... that state could be captured in a monad... but if i'm writing a library that provides an abstraction over the graphics hardware plus sprites and a scene graph what not, that state would also be captured by a monad...
16:05:16 <yitz> SamB_XP_: is the caption "Internet Explorer"?
16:05:21 <gaze> who provides the monad and who provides the transformer?
16:05:22 <SamB_XP_> yitz: no
16:05:25 <SamB_XP_> that's not a shortcut
16:05:26 <yitz> good
16:05:26 <SamB_XP_> duh
16:05:29 <SamB_XP_> it has no icon
16:05:57 <SamB_XP_> plus, I know what to do about that -- either use TweakUI or one of those sysinternals tools ...
16:07:11 <hackagebot> pointful 1.0.1 - Pointful refactoring tool (MikhailGlushenkov)
16:08:10 <Giarome> http://en.wikipedia.org/wiki/65537-gon
16:08:24 <Giarome> for those interested in polygons ;)
16:08:53 <gaze> does nobody seriously have an answer to this?
16:09:09 <yitz> gaze: either way is fine. define lift functions with meaningful names: liftGameState and liftGraphicsState or whatever.
16:09:11 * sinelaw is reading "Can programming be liberated from the von Neumann style?", finally
16:09:35 <gaze> it's fine but... isn't there some sort of convention?
16:09:42 <FunctorSalad> is there a flag for polymorphic where clauses?
16:09:45 <yitz> gaze: you may later find it more convenient one way or the other - it is then easy to switch.
16:09:52 <FunctorSalad> -XNoMonoPatBinds doesn't seem to cut it
16:10:08 <SamB_XP_> huh
16:11:01 <ddarius> sinelaw: Backus' notion of FP is somewhat different from the "modern" notion of FP.
16:11:08 <yitz> FunctorSalad: oh yeah? what problem did you find with it?
16:11:09 <FunctorSalad> hmm I had a mistake there
16:11:14 <FunctorSalad> works now :)
16:11:33 <sinelaw> ddarius, i have that feeling. but in your opinion - in what way?
16:11:46 <ddarius> sinelaw: Read it and it should be obvious.
16:12:37 <sinelaw> so far, the only major thing is his insistence on no variables
16:12:54 <sinelaw> ah wait...and this part about state
16:12:56 <ddarius> "The fact that a language like Oberon lets you program entire systems from scratch without use of loopholes (except in the storage manager and device drivers) marks the most significant progress in language design in over 40 years." - Niklaus Wirth, 2005
16:15:18 <monochrom> FunctorSalad: Yeah, "where" has as much and as little monomorphic restriction as toplevel. :)
16:16:29 <anonym> ddarius: yeah and pascal is a superb language to learn programming, oh wait...
16:16:31 <ddarius> monochrom: Not if SPJ has his way.
16:16:31 <FunctorSalad> monochrom: what does the flag mean by 'pattern' in that case?
16:16:59 <kniu> Is Simon Peyton Jones ever in this channel?
16:17:00 <FunctorSalad> (but I agree now this flag was irrelevant for my problem ;))
16:17:18 <Twey> kniu: I haven't seen him here.
16:17:21 <Zao> kniu: No, I do not believe so.
16:17:28 <kniu> hm.
16:17:30 <SamB_XP_> I might have seen him, once
16:17:31 <Zao> The other Simon is around occasionally, I think.
16:17:35 <SamB_XP_> or it might have been in #ghc
16:17:42 <SamB_XP_> the other one goes by JaffaCake
16:17:52 <SamB_XP_> and is supposedly here
16:17:55 <mauke> preflex: seen JaffaCake
16:17:55 <preflex>  JaffaCake was last seen on #ghc 2 days, 11 hours, 58 minutes and 57 seconds ago, saying: Wolfgang Thaller, I guess
16:17:57 <SamB_XP_> but don't believe it ;-P
16:18:05 <kniu> Philip Wadler?
16:18:20 <sinelaw> that might explain why he's so productive
16:18:25 <sinelaw> :P
16:18:49 <monochrom> I don't know NoMonoPatBinds.
16:19:55 <monochrom> Perhaps: "f x = ...", there is a monomorphism issue on f, but there is also a monomorphism issue on x. Perhaps NoMonoPatBinds is about the latter, x is a pattern and you're binding things to x.
16:20:26 <ddarius> JaffaCake is Simon Marlow.
16:20:40 <ddarius> Simon Peyton Jones goes by simonpj.
16:21:09 <monochrom> Pascal was a superb language for learning programming. I am not sure about "is". But definitely was, when I was learning back then.
16:21:13 <ddarius> kniu: I don't believe Philip Wadler has ever been here the entire time I've been here.
16:21:31 <monochrom> Today I may recommend scheme. Not sure.
16:21:46 <kniu> Paul Hudak?
16:23:40 <monochrom> I now think I'm wrong about NoMonoPatBinds.
16:25:21 <yitz> monochrom: MIT used scheme for years. now they've switched to Python.
16:25:36 <Twey> Unfortunately.
16:26:07 <yitz> an article recently linked on reddit advocates Haskell. :)
16:26:42 * ddarius would not use Haskell.
16:26:44 <Twey> There's no language better-suited to teaching modern programming than Scheme.  Its simplicity and power mean that it's ideal for pædagogical purposes.
16:26:57 <Twey> I wouldn't use Haskell.  Too heavy-weight.
16:27:14 <Cale> I would use Haskell. I think types are important.
16:27:18 <ddarius> Twey: That's not at all the reason I wouldn't use Haskell.
16:27:25 <ddarius> Twey: I wouldn't use it because it lacks mutation.
16:27:39 <Twey> dibblego argues that teaching strict languages makes it difficult for programmers to learn lazy ones later, and that Haskell gives the benefit of teaching types
16:27:46 <Cale> I would teach about mutation via IORefs and MVars :)
16:27:56 <Cale> (which is sort of what I'm doing with medfly :)
16:28:01 <Twey> Which I agree with, but I think it's nice to be able to teach the very basics before any such things.
16:28:01 <Tordek> ?pf signum . (-)
16:28:01 <lambdabot> Maybe you meant: bf pl
16:28:08 <Tordek> ?pl signum . (-)
16:28:09 <lambdabot> signum . (-)
16:28:10 <ddarius> I think Scheme may well be the best language currently available for teaching, but I don't believe it's the best possible.
16:28:14 <Tordek> er
16:28:26 <Twey> ddarius: Agreed
16:28:28 <Tordek> ?pl \x -> signum . (x-)
16:28:29 <lambdabot> (signum .) . (-)
16:28:50 <Twey> Haskell has the same class of limitations as Java, as a teaching language: it requires that the student master a whole bunch of concepts before they can actually get to programming.
16:28:58 <Cale> I think Haskell has the advantage of carrying over a certain way of thinking from elementary mathematics
16:29:05 <ddarius> Cale: I feel programmers should have experience working in languages with pervasive mutation as that is likely what they will have to use in the future.  I do think they should start from a pure subset and be led toward programming primarily in a pure style when possibel.
16:29:06 <Twey> They're good concepts, and useful, and great to learn later on, but they do hinder initial understanding.
16:29:29 <Cale> ddarius: Well, you assume that they're going to have to use languages with pervasive mutation in the future ;)
16:29:40 <ddarius> Explicitly so.
16:29:43 <Twey> Cale: Well, statistically speaking…
16:29:44 * Cale creates spoiled brats who will refuse to do so ;)
16:29:48 <Twey> Heheh.
16:29:56 <Twey> But they'll all starve and die.  :þ
16:30:09 <SamB_XP_> Twey: or innovate!
16:30:19 <Twey> Heh
16:30:23 <Twey> Intellectual Darwinism
16:30:28 <SamB_XP_> they'll probably not entirely refuse
16:31:04 <Cale> But I still think that understanding programs with mutation in terms of programs which don't is a good viewpoint.
16:31:12 <ddarius> I strongly feel that experience with some general purpose assembler (x86 nowadays for the most part) is highly beneficial.
16:31:12 <Twey> I agree.
16:31:19 <Twey> (with Cale)
16:31:44 <Twey> Assembly is useful for some types of programming, but not most.
16:31:59 <Twey> On the whole, an understanding of big-O is as far as one really needs to go.
16:32:02 <ddarius> I never use assembly, but I still think it is useful to have experience with it.
16:32:05 <Cale> So even if you're stuck writing in a language where people mutate things all the time, having a pure foundation will mean that you'll probably write more maintainable programs -- at least if you stick to that way of thinking and don't lose control ;)
16:32:20 <opqdonut> Twey: it certainly is not
16:32:24 <opqdonut> constant factors matter
16:32:27 <`core> http://i.imgur.com/g4Yax.gif
16:32:28 <Twey> Cale: Well, in Scheme, for example, the pure way is preferred
16:32:31 <opqdonut> practicality matters
16:32:33 <Cale> yeah
16:32:51 <Cale> `core: yeah, saw it on reddit.
16:32:53 <Twey> opqdonut: But if you're talking constant factors of only a few machine instructions, they generally don't.
16:33:00 <mauke> warning: `core's link is very NSFW
16:33:01 <ddarius> Cale: As I said, I feel purity should be what is emphasized, but you need experience dealing with highly mutable code basis so that you can handle working with such code.
16:33:11 <`core> ah. reddit. saw in another channel.
16:33:12 <opqdonut> in a combinatoria search, for example, the constant factors can be factorials etc
16:33:14 <Twey> (and if you're not, they're probably made up of more big-O–analysable forms)
16:33:36 <opqdonut> also, fancy complexitytheoretic algorithms tend to have really big constant factors
16:33:51 <opqdonut> see for example matrix multiplication, linear optimization
16:33:54 <Twey> The key word is ‘fancy’
16:34:10 <Twey> It's a minority of programming tasks where this is the case
16:34:13 <Twey> Sadly, perhaps
16:34:46 <ddarius> A few instructions in a tight loop can make a big difference, but I never brought up optimization as the reason to learn assembly.
16:34:55 <opqdonut> mhmm
16:36:23 <kpreid> @hoogle (a->a -> Bool) -> (b -> b -> Bool) -> (a,b) -> (a,b) -> Bool
16:36:24 <lambdabot> No results found
16:36:50 <Twey> ddarius: Then…?
16:37:07 <kpreid> @hoogle (a->a -> c) -> (b -> b -> d) -> (a,b) -> (a,b) -> (c,d)
16:37:08 <lambdabot> No results found
16:37:16 <burp> @djinn (a->a -> Bool) -> (b -> b -> Bool) -> (a,b) -> (a,b) -> Bool
16:37:17 <lambdabot> f a b (c, d) =
16:37:17 <kpreid> @djinn (a->a -> c) -> (b -> b -> d) -> (a,b) -> (a,b) -> (c,d)
16:37:17 <lambdabot>     \ _ ->
16:37:17 <lambdabot>     case a c c of
16:37:17 <lambdabot>     False -> False
16:37:17 <lambdabot>     True -> b d d
16:37:19 <lambdabot> f a b (c, d) (e, f) = (a c e, b d f)
16:37:53 <kpreid> @pl \a b (c,d) (e,f) -> (a c e, b d f)
16:37:54 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
16:38:00 <kpreid> eek
16:38:02 <Twey> Argh
16:38:13 <kpreid> @pl \a b (c,d) (e,f) -> (a c e && b d f)
16:38:14 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (&&)) .)) .)
16:38:46 <yitz> ddarius: the most common need for assembler nowadays is just to be able to use special vector instructions from C. you don't need much knowledge of assembler for that.
16:38:55 <aavogt> @type flip flip snd
16:38:57 <lambdabot> forall a c a1 b. (a -> ((a1, b) -> b) -> c) -> a -> c
16:39:10 <kpreid> (I'm actually doing math homework, not Haskell, but I wanted to see if there was some notation for this 'combine two predicates on pairs of their arguments' concept)
16:39:11 <sinelaw> yitz, or to write hardware-related stuff
16:39:17 <ddarius> yitz: I never said anything about needing to use assembly.
16:39:36 <ddarius> Twey: To understand what actually is available on the machine, how those things in high level languages actually work, and what operating systems are doing for you.  It's also not uncommon that you can reasonably encode some things in assembly which just aren't able to be done reasonably in higher-level languages.  The first time I heard about call-by-need and call-by-name was in assembly.
16:39:42 <yitz> sinelaw: most people who write hardware stuff use other languages now. mostly C.
16:39:50 <sinelaw> yes
16:40:18 <Twey> ddarius: Which is all good stuff to know, but not really useful in most situations
16:41:27 <ddarius> Twey: Learning about Y combinators is not really useful in most situations either.
16:41:43 <Twey> ddarius: Indeed.
16:42:23 <SamB_XP_> yes, it is important to know assembly -- and know better than to write any most of the time ;-)
16:42:34 <ddarius> SamB_XP_: Agreed.
16:42:38 <Twey> Understanding the programming language you're using is crucial.  Understanding how its primitives are implemented is not, except in performance-critical situations (and even then, it's usually easier just to remember ‘this is slower than that’).
16:43:04 <SamB_XP_> it's not even particularly important that you know a *recent* assembly language
16:43:14 <SamB_XP_> I mean, 6502 should be fine ;-)
16:43:23 <heatsink> Is there a simple rule for knowing when a type signature is required for code using type families to typecheck?
16:43:32 <ddarius> SamB_XP_: I agree.  Practically, it would make sense for most to learn x86.
16:43:40 <heatsink> Well, simpler than the full type checking process
16:43:52 <Twey> Unless they learnt Reduceron assembly?  ;)
16:44:28 <SamB_XP_> Twey: that's not going to help them any
16:48:38 <ddarius> :t liftM2 (liftM2 (&&))
16:48:39 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 (m Bool) -> m1 (m Bool) -> m1 (m Bool)
16:49:29 <heatsink> So I gather that RankNTypes and TypeFamilies are two situations where missing type signatures cause type errors, but the compiler can't detect that you need a signature.
16:52:23 <benmachine> is there an easy way of turning (m a, m b) into m (a, b)?
16:52:39 <heatsink> @instances Traversable
16:52:39 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
16:52:46 <BONUS> :t uncurry (liftM2 (,))
16:52:47 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
16:52:57 <benmachine> BONUS: nice, thanks
16:53:51 <benmachine> wow this is weird, I might actually have a use for Kleisli
16:54:10 <Twey> Surely not!
16:54:18 <benmachine> :P
16:55:04 <BONUS> there's this http://blog.snoyman.com/2009/10/19/monadic-pairs-and-kleisli-arrows/
16:56:58 <benmachine> the Kleislis everywhere are a little verbose
16:57:59 <Botje> no problem. GHC 6.14 will accept ☃ as a synonym for kleisli
16:58:11 <benmachine> excellent
16:58:14 <Twey> Haha
16:58:30 <Twey> We should seriously do that :þ
16:58:34 <heatsink> Unacceptable.  To read that, I'll have to use a bigger font.
16:58:48 <Twey> heatsink: It's a sno[yw]man!
16:59:17 <Botje> heatsink: maybe it should be animated for better visibility.
16:59:38 <heatsink> Yes.  We need more animated source code.
16:59:46 * Twey laughs.
17:01:14 <yitz> @type uncurry . liftM2 . curry $ id
17:01:15 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
17:06:58 <sinelaw> > 3/0
17:06:59 <lambdabot>   Infinity
17:07:20 <sinelaw> cool! i was expecting "NaN" or something illogical like that
17:07:25 <sinelaw> > 3/0.0
17:07:26 <lambdabot>   Infinity
17:07:31 <aavogt> > 0/0
17:07:33 <lambdabot>   NaN
17:07:37 <sinelaw> > 3/0.0000000000000000000000000000000000000000000000000000000000000000000000000000000001
17:07:37 <lambdabot>   3.0000000000000002e82
17:07:47 <sinelaw> aavogt, that one makes sense
17:07:53 <Twey> > negate 1 / 0
17:07:54 <lambdabot>   -Infinity
17:07:56 <sinelaw> > 3/1e-90000
17:07:57 <lambdabot>   Infinity
17:08:02 <sinelaw> :)
17:08:27 <aavogt> sinelaw: who doesn't distinguish between Inf and NaN?
17:08:44 <yitz> > 1 % 0
17:08:45 <lambdabot>   * Exception: Ratio.%: zero denominator
17:08:53 <sinelaw> Python
17:08:56 <yitz> > 0 % 0
17:08:57 <lambdabot>   * Exception: Ratio.%: zero denominator
17:09:18 <sinelaw> >>> 2/0
17:09:18 <sinelaw> ZeroDivisionError: integer division or modulo by zero
17:09:25 <yitz> sinelaw: no, any ieee implementation distinguishes.
17:09:54 <sinelaw> so why does Python give ZeroDivisionError?
17:10:15 <Twey> 1/0 and 0/0 both give ZeroDivisionError's in Python
17:10:24 <Twey> They're indistinguishable, AFAIK
17:10:32 <monochrom> cross purpose
17:10:50 <aavogt> so python doesn't do IEEE floats?
17:11:01 <aavogt> I guess haskell doesn't either since you can't set rounding modes
17:11:13 <skorpan> i always think of xena when i see "IEEE", looks just like her war cry
17:11:23 <Twey> Heheh
17:11:47 <benmachine> sinelaw: *integer* division or...
17:12:03 <benmachine> actually
17:12:07 <benmachine> I say that but
17:12:11 <benmachine> >>> 1 / 0.0
17:12:14 <benmachine> ZeroDivisionError: float division
17:12:18 * benmachine shrugs
17:12:35 <skorpan> http://www.youtube.com/watch?v=gncqw7X6gMU <- IEEE
17:13:07 <benmachine> (holy shit, I used Control.Category and a non-(->) arrow in a file because they were genuinely useful)
17:13:20 * benmachine feels weird
17:13:23 <zygoloid> benmachine: a Kleisli arrow?
17:13:28 <benmachine> zygoloid: yeah
17:13:54 * benmachine tries to work out how to shift the fmaps and so forth around so that it makes sense to read
17:14:03 <zygoloid> yeah, them combinators can be handy
17:14:15 <benmachine> is there a shorthand for join (***) f?
17:14:21 <sinelaw> Python's way seems weird, 1/1e-9000 should be "infinity", not raise a "ZeroDivisionError"
17:14:26 <benmachine> i.e. apply a function to both sides of a pair
17:14:42 <benmachine> sinelaw:
17:14:43 <benmachine> >>> 1e-9000 == 0
17:14:43 <benmachine> True
17:14:46 <benmachine> :)
17:15:28 <zygoloid> benmachine: first f >>> second f, or second f >>> first f, depending on how you want to sequence the computations, but not sure that's a shorthand :)
17:15:38 <benmachine> mm
17:15:42 <sinelaw> ok then,
17:15:56 <zygoloid> > 1e-9000 == 0
17:15:57 <lambdabot>   True
17:16:05 <sinelaw> >>> 3e+300/1e-300
17:16:06 <sinelaw> inf
17:16:06 <sinelaw> >>> 3e+300/0
17:16:06 <sinelaw> ZeroDivisionError: float division
17:16:13 <aavogt> > 1e-9000 == (0::CReal)
17:16:15 <lambdabot>   True
17:16:25 <sinelaw> that example i gave doesn't make sense
17:16:36 <Cale> The Eq instance for CReal uses an arbitrary approximation
17:16:56 <zygoloid> > showCReal 10000 (1e-9000) == showCReal 10000 0
17:16:57 <lambdabot>   False
17:17:00 <Cale> (because otherwise, it would never produce True)
17:17:06 <sinelaw> > 1e-9000 * 1e+9000
17:17:07 <lambdabot>   NaN
17:17:19 <sinelaw> damn!
17:17:24 <zygoloid> > 1e-9000 * 1e+9000 :: CReal
17:17:26 <lambdabot>   1.0
17:17:38 <sinelaw> better
17:17:57 <benmachine> sinelaw: it does, 3e+300/1e-300 is a valid computation that produces a result too large to be represented
17:18:04 <Cale> CReal is good, but it tends to be really super impractical for anything but the simplest of computations
17:18:16 <benmachine> whereas 3e+300/0 is just a wrong thing to do
17:18:27 <Cale> I wish we had a computable real implementation which was really practical as well.
17:18:44 <Gracenotes> I don't get it.. Graphics.UI.SDL isn't doing what I tell it to do, but my mostly equivalent (function-call-wise) C version seems fine
17:18:57 <zygoloid> > showCReal 100 $ 2 * asin 1.0
17:18:58 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:19:10 <sinelaw> benmachine, problem is that in one place, the approximation yeilds inf, whereas when i enter something like 1e-9000 it yields something else
17:19:15 <Cale> > showCReal 100 (exp (pi * sqrt 163))
17:19:16 <lambdabot>   "262537412640768743.9999999999992500725971981856888793538563373369908627075...
17:19:24 <Gracenotes> isn't updateRect supposed to work? :)
17:20:23 <zygoloid> > 6 * asin 0.5 == pi
17:20:24 <lambdabot>   False
17:20:31 <zygoloid> > 6 * asin 0.5 == (pi :: CReal)
17:20:32 <lambdabot>   True
17:21:12 <Gracenotes> sometimes having shoot-yourself-in-the-foot type of memory access can be very useful
17:21:12 <benmachine> oh damn it
17:21:45 <benmachine> Gracenotes: the thing that I always forgot when using SDL was calling SDL.flip
17:22:02 <benmachine> for more than that I'd probably need to see code
17:22:36 <Gracenotes> ah. in this case, I'm just trying render a static matrix of pixels to the screen by accessing the Surface obj directly
17:22:56 <benmachine> anyway the reason I said oh damn it is because I've jsut reaslised I can't use all these lovely category compositions and kleisli arrows because these maybes need to be able to fail independently :(
17:24:55 <sinelaw> > const 1 undefined
17:24:56 <lambdabot>   1
17:26:09 <Gracenotes> but, yeah, it is somewhat hard to translate Uint8 *p = (Uint8*)screen->pixels + y * screen->pitch + x * 4; *(Uint32 *)p = SDL_MapRGB(screen->format, 255*red, 255*green, 255*blue); <- into Haskell :) sans Foreign.C magic, and knowing the exact byte alignments in the surface struct
17:28:46 <Gracenotes> fillRect should work such that updateRect shows it, but this isn't the case
17:30:19 <sinelaw> So Backus had no formal education?
17:31:34 <skorpan> neither backus nor naur...
17:31:40 <skorpan> (that's almost a pun)
17:32:42 <sinelaw> so maybe i should quit, before i get my degree
17:33:30 <skorpan> "After entering the University of Virginia to study chemistry, he quit and was conscripted into the U.S. Army."
17:34:05 <skorpan> apparently naur has a PhD
17:34:45 <gaze> alright... now I'm a little confused... is most real world haskell code really just mostly just done using IORefs rather than creating monads and monad transformers for everything?
17:35:05 <crash[`]> Hopefully this makes sense, but I'm trying to, using a list comprehension pull out all the items in a list up to n (like take), but I can't figure out just how to make the syntax work: (given xs and n) [x | x <- xs !! [1..n]]
17:35:48 <benmachine> crash[`]: sufficiently like take for you to, um, use take?
17:36:59 <crash[`]> benmachine: i'm trying to replicate take for just that sake - so i think using take would be silly if my whole purpose is trying to write it myself :)
17:37:12 <benmachine> oh
17:37:24 <aavogt> > let sillyTake n xs = [ xs !! i | i <- [1..n]] in sillyTake "hello" 3
17:37:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:37:25 <lambdabot>         against inferred type ...
17:37:26 <benmachine> I don't think a list comprehension is the best way to do it, then
17:37:34 <aavogt> > let sillyTake n xs = [ xs !! i | i <- [1..n]] in sillyTake 3 "hello"
17:37:34 <lambdabot>   "ell"
17:37:39 <aavogt> > let sillyTake n xs = [ xs !! i | i <- [0..n]] in sillyTake 3 "hello"
17:37:41 <lambdabot>   "hell"
17:37:47 <benmachine> heheheh
17:37:52 <crash[`]> aavogt, thanks
17:37:55 <ddarius> take = take
17:37:58 <Twey> Eww, O(n) take :þ
17:38:08 <benmachine> yeah, sillyTake deserves the name :P
17:38:17 <aavogt> Twey: isn't take already O(n)?
17:38:26 <Twey> Yep
17:38:29 <c_wraith> aavogt: it's O(k)
17:38:29 <crash[`]> aavogt: i guess not with finger trees but
17:38:33 <aavogt> this one being O(n^2)  or something like that
17:38:36 <Twey> What's that, O(n^2)?
17:38:38 <Twey> *nod*
17:38:46 <ddarius> take k l is O(min(k,length l))
17:39:12 <c_wraith> That one's O(k^2)
17:39:34 <aavogt> and it fails for taking more than the list has
17:40:19 <Cale> Or, take k xs is O(min(k,l)) where l is the number of elements of xs which are eventually inspected.
17:41:15 <Cale> er, of take k xs which are eventually inspected ;)
17:41:41 <benmachine> > fix (\take n ~(x:xs) -> if (n <= 0) then [] else x : take (n - 1) xs) 3 [1 .. 10]
17:41:42 <lambdabot>   [1,2,3]
17:42:28 <benmachine> ooh
17:42:34 <ddarius> Cale: I could inspect 0 of the elements and it will take more than constant time.
17:42:43 <benmachine> > fix (\take n ~(x:xs) -> guard (n > 0) >> x : take (n - 1) xs) 3 [1 .. 10]
17:42:44 <lambdabot>   [1,2,3]
17:42:51 <benmachine> yesss
17:42:58 <benmachine> admittedly
17:43:02 <benmachine> > fix (\take n ~(x:xs) -> guard (n > 0) >> x : take (n - 1) xs) 3 []
17:43:03 <lambdabot>   [* Exception: <interactive>:1:150-204: Irrefutable pattern failed for patte...
17:43:12 <benmachine> :(
17:43:16 <Paczesiowa> does Roman Leshchinskiy hang out here?
17:43:32 <Vanadium> @src unlines
17:43:33 <lambdabot> unlines = concatMap (++ "\n")
17:43:33 <benmachine> > fix (\take n l@(~(x:xs)) -> guard (n > 0 && not (null l)) >> x : take (n - 1) xs) 3 []
17:43:34 <lambdabot>   []
17:43:38 <benmachine> \o/
17:43:57 <Cale> ddarius: hm?
17:43:58 <Vanadium> benmachine: For a second I mistook your line of code for lambdabot's respones to my query and was rather confused
17:44:08 <Twey> Heheh.
17:44:13 <benmachine> Vanadium: please excuse my silliness
17:44:14 <ddarius> length (take k xs) evaluates non of the elements of xs.
17:44:29 <Cale> Ah, what I actually mean is the conses
18:05:08 <skorpan> > 46.62 + 0.73
18:05:09 <lambdabot>   47.349999999999994
18:05:15 <skorpan> ...that's seriously weak...
18:05:23 <benmachine> welcome to floating-point?
18:05:49 <benmachine> > 46.62 + 0.73 :: CReal
18:05:50 <lambdabot>   47.35
18:06:45 <FunctorSalad_> > 0.1 :: Double
18:06:46 <lambdabot>   0.1
18:06:54 <FunctorSalad_> hmm it's cheating
18:06:57 <skorpan> :t 46.62 + 0.73
18:06:58 <lambdabot> forall t. (Fractional t) => t
18:07:03 <skorpan> > 46.62 + 0.73 :: Double
18:07:04 <lambdabot>   47.349999999999994
18:07:09 <FunctorSalad_> skorpan: 0.1 isn't a Double either
18:07:22 <skorpan> :t (0.1 :: Double)
18:07:23 <lambdabot> Double
18:08:28 <skorpan> it really amazes me that haskell has gotten away with weird (albeit "IEEE-correct", i suppose) floating-point arithmetic for this long
18:09:16 <tommd> Bah, there
18:09:27 <FunctorSalad_> well all the languages do, don't they
18:09:55 <skorpan> what the heck, python does the same
18:10:01 <skorpan> this is news to me!
18:10:19 <skorpan> ruby manages...
18:10:22 <benmachine> skorpan: if you want to come up with an accurate way of representing arbitrary reals
18:10:49 <benmachine> we would all much appreciate it
18:10:55 <benmachine> ruby doesn't manage it pretends to manage
18:11:08 <skorpan> that's why i said "manages"
18:11:24 <skorpan> okay, that came out weird
18:11:32 <skorpan> never mind, good night
18:15:42 <Cale> One trouble which anything else is going to face is that it won't have processor support, but even if we had something as practical as Integer is, it would make me happy :)
18:21:22 <monochrom> Oh well skorpan is gone. I want to say I find the whole "debate" pointless. I hinted at it when I said "cross purpose" quite a while ago. Everyone is talking at cross purpose when it comes to number systems.
18:23:04 <monochrom> The fact is, those who want 1/0=inf has a different application in mind than those who want 1/0=nan or exception. The two groups can never be reconciled. Provably.
18:23:57 <monochrom> This is why math is invented not discovered.
18:28:05 <luite> why is g++.exe not included with the haskell platform? it does have c++ headers and the libstd++ libraries.
18:28:35 <sproingie> ghc doesn't define a C++ FFI
18:29:16 <luite> sproingie: it's still useful to have, to compile libraries that are (partially) written in c++
18:29:53 <luite> but perhaps I misundersthand the point of having gcc included in the distribution :)
18:30:51 <sproingie> ghc compiles to C
18:33:58 <luite> what is then the recommended way to compile and install extra libraries for the platform?
18:35:13 <sproingie> install the compiler separately.  on windows, i think you want mingw
18:37:25 <eflister> is there something that undoes (***)?  i have (Bool,Bool) and i want to or them into a Bool
18:38:14 <lorne> @pl \f (a, b) -> a `f` b
18:38:14 <lambdabot> (`ap` snd) . (. fst)
18:38:40 <eflister> is there an arrow?  i guess it's not undoing (***)
18:38:43 <luite> is there a 'local' installation directory for the libraries? (so that I don't have to copy the .a files to platform/2009.2.0.2/gcc-lib, so that ghc --make can still find them, without specifying the location explicitly?
18:42:00 <eflister> :t arr (\(a,b) -> a || b)
18:42:01 <lambdabot> forall (a :: * -> * -> *). (Arrow a) => a (Bool, Bool) Bool
18:51:03 <BMeph> eflister: Not sure why it's so quiet, but most folks would just use 'curry' for that....
18:51:07 <BMeph> :t curry
18:51:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:51:31 <eflister> oh i always forget about curry
18:51:33 <eflister> thx
18:51:33 <BMeph> eflister: Rather, 'uncurry'. :)
18:51:40 <BMeph> :t uncurry
18:51:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:51:43 <eflister> right
18:52:04 <eflister> :pl (\e -> (fromMaybe False . fmap (not . isNoteOff) . maybeLast $ e))
18:52:05 <BMeph> eflister: There ya go - 'uncurry' is the right one.
18:52:15 <eflister> @pl (\e -> (fromMaybe False . fmap (not . isNoteOff) . maybeLast $ e))
18:52:15 <lambdabot> fromMaybe False . fmap (not . isNoteOff) . maybeLast
18:52:17 <BMeph> :t uncurry (||)
18:52:18 <lambdabot> (Bool, Bool) -> Bool
18:53:05 <eflister> @pl (\e -> (or . catMaybes $ (([fmap] <*> [isNoteOff,(endT ==) . timestamp]) <*>) [maybeHead $ e]))
18:53:05 <lambdabot> or . catMaybes . (([fmap] <*> [isNoteOff, (endT ==) . timestamp]) <*>) . return . maybeHead
18:58:34 <eflister> hee hee, it works.  this is the ugliest thing i've written in haskell, but i feel like i'm following all the style rules i know.
18:58:47 <eflister> can anyone take a look and provide some cleanup tips?
18:58:48 <eflister> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11121#a11125
19:01:13 <eflister> a view counter on each hpaste revision would be sweet
19:02:29 <gwern> what the *deuce*?
19:02:57 <gwern> why do you have 30 lines of let bindings
19:03:06 <Axman6> oh god, i'f almost forgotten i knew haskell. frigging C! >_<
19:03:20 <Axman6> eflister: make smaller functions!
19:03:39 <gwern> and what is all that unInt junk?
19:03:52 <gwern> and are you using arrows *and* applicative?
19:03:52 <colton_> What's the best place for a noob like me(who's already familiar with c and its variants) to get started learning haskell?
19:03:58 <eflister> alot of the let bindings are local functions i don't need anywhere else
19:04:03 <gwern> pick one esoteric set of functions and stick with it!
19:04:14 <roconnor> colton_: first, try to forget c and it's variants :)
19:04:24 <roconnor> @where lyah
19:04:25 <lambdabot> www.learnyouahaskell.com
19:04:25 <Axman6> @where lyah
19:04:25 <lambdabot> www.learnyouahaskell.com
19:04:28 <Axman6> heh
19:04:32 <Axman6> colton_: ^^^^^^^^^^^^^^^
19:04:41 <eflister> the unint deals with the fact that i am dealing with an aliased CLong
19:05:05 <colton_> Hehe
19:05:19 <eflister> colton_: lyah got me hooked, esp on functional style
19:05:49 <eflister> colton_: but it misses huge important things, like all of monads.  for that go for rwh.
19:06:01 <Axman6> colton_: after lyah, you can try out real world haskell. it covers more indepth topics, but isn;t as good as an introduction to haskell
19:06:01 <colton_> rwh?
19:06:17 <Axman6> colton_: but my far, the best resource for learning is here: #haskell
19:06:17 <eflister> @where rwh
19:06:18 <lambdabot> is http://www.realworldhaskell.org/blog/
19:06:34 <gwern> I've always been a little bothered by the abbreviation lyah
19:07:28 <eflister> would anyone read it if i put a FR for revision view counters here: http://github.com/glguy/hpaste/issues
19:07:33 <colton_> I want to do something useful with haskell, like write an application, is that possible?
19:07:39 <Axman6> colton_: so, start reading lyah, and make sure you ask questions here when you have issues. you'll almost always find someone who's willing to walk you through any topic you're having trouble with
19:07:55 <Axman6> colton_: yep, but you need to know haskell first.
19:08:15 <eflister> colton_: rwh is free online http://book.realworldhaskell.org/read
19:08:49 <eflister> i have a succinct discussion of my favorite haskell tibits here http://code.google.com/p/h1ccup/wiki/learning
19:09:09 <Axman6> google code needs darcs support
19:09:22 <colton_> Ok, so I need to know the language first, but i'd like to write a gui application (qt specifically) can I call haskell from c++, or the other way around?
19:09:42 <Axman6> you can, but haskell already has QT bindings
19:10:06 <luite> hmm, found a location, if haskell platform is installed in c:\haskell\platform\version, mingw looks for includes in c:\haskell\platform\mingw32\include, libraries c:\haskell\platform\mingw32\lib etc
19:10:08 <Axman6> haskell has a rather nice foreign function interface
19:10:26 <luite> guess I'll put the extra libraries there
19:11:10 <eflister> Axman6: do you see any functions i should decompose?
19:11:39 <eflister> also, something i'd really like to understand is how one would prove this code correct (ala curry howard)
19:12:00 <eflister> QuickCheck wouldn't get to all the corner cases
19:12:38 <colton_> Has anyone here used the Qt bindings?
19:14:27 <eflister> colton_: lots of people use gtk2hs: http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
19:14:38 <eflister> colton: check out leksah, it's really great
19:15:53 <eflister> has yi or anyone else integrated the debugger yet?  leksah has and it's awesome
19:17:56 <colton_> leksah?
19:18:15 <colton_> oh my, the acronynms of death!
19:18:32 <colton_> Can you write device drivers with haskelL?
19:19:04 <Axman6> colton_: indeed you can, i'll try and find the link
19:19:16 <Axman6> http://tommd.wordpress.com/2009/09/13/kernel-modules-in-haskell/
19:19:28 <Axman6> tommd hangs around here too
19:19:33 <tommd> yes, I do.
19:19:45 <Axman6> o/
19:20:03 <Axman6> tommd: done any more work on kernel modules since that post?
19:20:32 <eflister> @google leksah
19:20:33 <lambdabot> http://leksah.org/
19:20:34 <lambdabot> Title: Leksah - Haskell IDE in Haskell
19:20:37 <tommd> Nothing of note.  I presented the work at Galois (video should be online eventually - thats not in my hands).
19:20:42 <eflister> colton_: ^
19:21:43 <tommd> Also made some effort porting ricoh_mmc (a SD/MMC reader) to Haskell as a test case, but I only have one ricoh reader (on my main machine) so am unwilling to crash it enough to figure out whats wrong with my probe routine. On of the FFI imports probably needs to be marked 'safe'.
19:22:37 <tommd> Other than that, I'd like to work out concurrency but am hesitant to put more effort into the House/GHC-6.8.2 rts when the effort really should go into merging the code with GHC head.
19:23:17 <tommd> The comment on concurrency: You don't want to do something like 'threadDelay' with the current Kernel module work because that just busy-waits till the delay is over.  Perhaps forkIO and MVars would be OK.
19:24:03 <tommd> threadDelay would even be ok if you _knew_ other Haskell threads would be runnable till the delay timed out.
19:24:17 <tommd> But that isn't realistic, so probably best not to think about.
19:26:38 <colton_> How do you get leksah for linux?
19:26:44 <colton_> debian
19:27:43 <eflister> speaking of threadDelay, i have been noticing that it doesn't wake up very fast.  i call it with 1000us, and it doesn't wake up til about 10x that.
19:29:14 <eflister> coloton_: i guess there's no binary, use darcs
19:30:02 <eflister> colton_: yer package manager probably has darcs and ghc etc in it, that's all you need to build.
19:30:09 <Gracenotes> hm, overhead's that much
19:30:51 <eflister> does cabal install leksah work?
19:31:01 <Gracenotes> in any sort of concurrency model, perhaps STM to a lesser extent, there is a bit of overhead.. didn't think it'd be 10x though o＿o
19:31:04 <byorgey> eflister: yes, it should.
19:31:09 <seanmcl> is there a class for IO, corresponding to MonadState, MonadReader, etc?
19:31:11 <byorgey> leksah is on Hackage.
19:31:22 <byorgey> seanmcl: yes, MonadIO
19:31:26 <eflister> colton_: ^
19:31:34 <seanmcl> byorgey: thanks!
19:32:28 <Gracenotes> seanmcl: MonadIO also plays nice with newtype deriving
19:32:55 <seanmcl> Gracenotes: sorry, I'm not sure what that means
19:33:07 <eflister> comeon, some curry-howard jock out there wants to show me how to deduce something about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11121#a11125
19:34:29 <Gracenotes> e.g. you can easily define newtype MyReader a = MyReader (ReaderT MyEnv IO a) deriving (MonadIO), with GeneralizedNewtypeDeriving
19:34:51 <seanmcl> Gracenotes: oh, that's nice
19:34:53 <dejones> dons: You here?  I had a question about your Judy arrays library.
19:34:54 <Gracenotes> useful if you're making a monad transformer stack, and you want to make IO available to anyone
19:35:04 <seanmcl> yeah, that's exactly what I want to do
19:35:13 <Gracenotes> and of course, deriving Monad itself can be useful :)
19:36:40 <seanmcl> so the idea is then you don't have to use Trans.lift all the time?
19:36:41 <ddarius> Gracenotes: I doubt that's due to "overhead"
19:36:44 <seanmcl> to do IO actions?
19:37:16 <Gracenotes> well, you'd do liftIO for IO actions. but they're available, at least
19:37:39 <Gracenotes> ddarius: hm. maybe the threadDelay call was off by an order of magnitude, then
19:37:40 <ddarius> seanmcl: Just (pre-)wrap and name the IO actions you care most about.
19:37:47 <eflister> gwern: i like arrows, today is when i finally got them!  :)  but i love applicative, cuz i am forever wanting to apply a list of functions to something.  is there a way to do that with arrows?
19:39:08 <Gracenotes> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
19:39:49 <eflister> ddarius + Gracenotes: what other explanation?  i verified the call is what i think it is...
19:44:17 <ddarius> eflister: To start with, assuming you are using it correctly and timing it accurately, threadDelay only promises to -not- wake your thread up before a certain time.  Also, there is the granularity of the clock that threadDelay is using.  I don't think these latter two are the issue.
19:45:30 <luite> hmm, how do I change the PATH variable with a shell script?
19:45:43 <ddarius> luite: It depends on the shell.
19:45:44 <Gwern-away> luite: PATH=$PATH:foo ?
19:46:01 <luite> bash on windows, I have a script with PATH=.... \n export PATH
19:46:09 <luite> but I guess it exports only to process run within that script
19:46:12 <Gwern-away> hm. I just noticed that unix uses : as a separator in lists
19:46:18 <Gwern-away> I wonder if that's where haskell got it from
19:46:31 <ddarius> Gwern-away: ML uses ::
19:46:33 <Gracenotes> there is a way to alter the system PATH in the control panel
19:46:51 <mauke> luite: yes, that's how environment variables work
19:46:51 <Gwern-away> ddarius: so haskell didn't get : from ML then
19:47:07 <Gracenotes> for windows... not sure where to do it elsewhere. maybe a boot file? *shrug*
19:47:09 <luite> Gracenotes: yes I just want to run a commando to set a different path for my haskell build environment
19:47:23 <Gwern-away> luite: first thing you do, is uninstall windows...
19:47:50 <ddarius> Gwern-away: I imagine it did.  Haskell uses :: for ML's : and : for ML's ::.  The Haskell designers probably felt that was a better use.
19:47:56 <eflister> ddarius: i know i'm not guaranteed to get woken up, i was just surprised granularity was as big as 10ms.  i just tried increasing my request by 5x (to 5ms), and got the same results, so i am below the resolution.  it would be hard to suck it out to a minimal example, but if you care to take a look i can put the file in a pastebin -- but to run you have to install Data.Heap and Sound.PortMidi.
19:48:10 <luite> Gwern-away: I already have everything running on linux, this is just to make sure the programs run on windows
19:48:22 <Gwern-away> luite: oh, in that case you're just wasting your time
19:48:33 <eflister> ddarius: the way i measure is by Writer'ing '.' s every time i wake up, then counting them when i print the log at the end
19:48:37 <ddarius> eflister: Yes, the source would be helpful.
19:48:48 <eflister> ddarius: cool!  just a sec
19:49:16 <ddarius> eflister: How high are those counts usually?
19:49:20 <luite> Gwern-away: part of the problem is that I need to show the executables to people who only run windows, pretty sure this is less work than convincing them to install and teaching them to use linux
19:49:35 <Gwern-away> luite: but think of the long-term payouts!
19:50:09 <luite> Gwern-away: like being the long-term support person for their linux problem? :p
19:50:13 <luite> +s
19:50:33 <Gwern-away> luite: better than being the long-term support person for their windows problems
19:50:49 <eflister> ddarius: here you go.  i use a Writer [String], so i know that's bad (++).  but the delays don't decrease as the log grows -- it's 10 dots in 100ms.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11127#a11127
19:51:33 <luite> Gwern-away: bah I can just pretend I know nothing about windows, and I wasn't the one telling them to use it :)
19:52:31 <eflister> ddarius: myLatMS at the top is how you set the time i send to threadDelay (currently set to 5, and then it is multiplied by 1000)
19:52:50 <ddarius> If by "[you get] the same results", you mean there is a factor of ten difference, then you know the problem isn't "overhead" as that would be constant and also that it isn't clock granularity.  If you get the same number of '.'s, then it probably is granularity but still isn't overhead.
19:53:00 <luite> mauke: thanks, I'll setup things a bit differently then.
19:53:59 <eflister> ddarius: i don't follow the first option -- what i mean is that i get the same number of '.'s.  you think clock granularity?
19:55:20 <eflister> ddarius: the drain function (line 195) is the thing logging the '.'s and calling threadDelay
19:55:41 <Jedi_Stannis> @pl (\x -> [x])
19:55:41 <lambdabot> return
19:56:17 <stoop> heh
19:56:38 <Raevel> \o/
19:57:29 <ezyang> good evening
19:57:42 <mwc> I can't really find anyone else that would be as wowed by this as I am, but I met Adi Shamir tonight
19:57:42 <mwc> greatest graduation ever.
19:58:02 <mwc> (I'm afraid I acted like a total star struck knob)
19:58:03 <ezyang> That's pretty cool :-)
19:58:10 <Gwern-away> mwc: who?
19:58:18 <mwc> Gwern-away: the S in RSA encryption
19:58:19 <ezyang> RSA
19:58:22 <Gwern-away> ah
19:58:37 <mwc> We gave him an honorary doctorage this afternoon
19:58:41 <ezyang> I wonder if Galois does internships
19:59:07 <mwc> also invented differential cryptanalysis in the civilian sphere
19:59:10 <Gwern-away> ezyang: yes, it's called 'slave away on dons' latest interest' :)
19:59:12 <mwc> apparently the NSA already knew about it
19:59:42 <ezyang> Gwern-away: haha
20:02:58 <eflister> byorgey and gracenotes: would that help me get rid of all my liftIO's in main' (at the bottom of  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11127)?
20:03:24 <eflister> byorgey and gracenotes: could you explain how to do it?  i cannot seem to understand liftIO.  :(
20:03:29 <ezyang> Gwern-away: I would totally dig that :-P
20:07:36 <ezyang> eflister: I get the feeling that liftIO is not necessary
20:07:39 <ezyang> let me check
20:10:13 <eflister> ezyang: removing any of them gives compiler errors
20:21:28 <c_wraith> eflister:  liftIO just is a shortcut from IO to the current transformed monad, regardless of how many transformer layers there are.
20:21:55 <c_wraith> eflister:  You can always do the same with with the correct number of applications of lift
20:23:07 <eflister> c_wraith: i hate having lifts everywhere :(  it seems like expressions could work out what part of the stack they belong to for themselves.
20:23:12 <ezyang> If you used a MonadPrompt, you could get rid of the lifts entirely.
20:23:21 <ezyang> eflister: That's usually true, /except/ for IO
20:23:36 <eflister> ezyang: oo what's that?
20:23:56 <ezyang> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/Control-Monad-Prompt.html
20:24:13 <ezyang> It lets you do IO actions, but limit which ones are allowed
20:24:47 <ezyang> I personally dislike putting an transformers on IO
20:24:51 <colton_> I have the following function defined: evens n = [x*2 | x<-[1,2..], x<= ]. It's not quite working correctly, that is, it's like the list doesn't properly terminate. What's wrong?
20:26:16 <mmorrow> interesting, i thought graph isomorphism was NP-complete, but the complexity is actually still unsolved
20:26:48 <ezyang> Assuming you meant evens n = [x*2 | x<-[1,2..], x<= n]
20:27:06 <ezyang> Haskell has no way of telling that the list you passed to feed to x won't become <= n ever again
20:27:07 <mmorrow> i remember "Primes in P"..
20:27:36 <ddarius> eflister: Your code doesn't look like it should compile.  s looks like it is constant every time through.  I suspect that this may lead to the if expression always being true and thus you go around the loop as many times as there are items put in the queue.
20:27:57 <mmorrow> colton_: [x*2 | x <- takeWhile (x <= n) [1..]]
20:28:41 <ezyang> colton_: What you want is take n $ map (*2) [1,2..]
20:28:49 <ezyang> and you relaly shouldn't be afraid of infinite lists either
20:28:53 <ezyang> *really
20:28:55 <colton_> I see what I did wrong. I think that this works too: evens n = [ x*2 | [1..n] ]
20:28:56 <mmorrow> mwc: the NSA already knows everything
20:29:11 <ezyang> That works too, yup
20:29:26 <ddarius> mmorrow: But they only release such facts after they become publically known.
20:29:27 <colton_> That's pretty cool that I can just stick that n anywhere.
20:30:02 <colton_> What does the $ sign mean?
20:30:09 <ddarius> @src ($)
20:30:10 <lambdabot> f $ x = f x
20:30:12 <ezyang> "That's usually true, /except/ for IO." Actually, I'm only 90% certain that's true. Am I spouting nonsense?
20:30:20 <eflister> ddarius: it compiles (and runs as expected), which part looks bad?  :)  which function are you looking at, drain?  then s is constant, it is the output midi stream, where i am dumping the events that are in the queue.  and yes, the idea is to do this until the queue is empty and then quit.  (each event has a timestamp and isn't put on the queue til it is time -- the smallest ones are 100ms apart).
20:30:25 <Cale> colton_: It's low-precedence function application.
20:30:26 <ezyang> It's function application with low precedence
20:30:40 <ezyang> f (g x) == f $ g x
20:31:01 <Cale> A common usage is to compose a bunch of functions with (.) and then apply the resulting function with ($)
20:31:05 <Cale> f . g . h $ x
20:31:13 <colton_> Oh, that's useful.
20:31:53 <Cale> yeah, helps reduce the number of brackets you need to match up :)
20:32:01 <mmorrow> ddarius: which usually takes about 10 years or so after they've figured it out..
20:33:40 <Cale> as well as take advantage of the nice properties that function composition has, particularly that (f . g) . h = f . (g . h), and so you can snip any subchain of a composition out and define it as a new function without having to edit it.
20:34:45 <eflister> ddarius: which if expression?  the one on line 210?  it does not just check for stream errors, it is what checks the timestamp and spends most of its time failing cuz it's not time for the next event yet.  that's the case where it tries to threadDelay for 1ms and log a '.'
20:36:00 <eflister> any EDSL peeps out there?  i have the following, which works:
20:36:02 <eflister> data DurBase = Whole | Half | Quarter | Eighth | Sixteenth | ThirtySecond deriving (Enum, Bounded, Show, Eq)
20:36:02 <eflister> data NoteDur = NoteDur DurBase | Dotted NoteDur | Triplet NoteDur
20:36:33 <eflister> but i have to write things like 'Dotted $ Triplet $ NoteDur Eighth' instead of what i want, which is the natural 'Dotted Eighth Triplet'
20:36:42 <eflister> any way to fix that?
20:37:41 * ezyang vaguely recalls someone else doing this on haskell-cafe 
20:37:58 <eflister> 'Dotted Triplet Eigth' would also be fine.  but i'd like to only allow one instance of Dotted and Triplet each, and only in that order.
20:38:16 <ivanm> eflister: not sure you can...
20:38:42 <ivanm> "Dotted Eighth Triplet" implies that Dotted takes two params
20:38:56 <ezyang> (it was actually dealing with pitch intervals, not durations)
20:41:02 <eflister> no luck with this http://search.gmane.org/?query=triplet+eigth+data
20:42:00 <eflister> ivanm: yeah, i'd be fine not allowing that order
20:42:28 <ezyang> eflister: "hint" eigth is spelled wrong
20:42:50 <eflister> ha
20:43:08 <eflister> now that is a weird looking word when you think about it
20:43:45 <ezyang> "it's eighth"
20:44:31 <eflister> yeah it's write (sic) in the code :b.  that brought up results on haskell-cafe, but doesn't look like anyone's addressed this issue
21:28:59 <colton_> How could I build a list that looks like this : [1, 4, 2, 4, 1] OR [1, 4, 2, 4, 2, 4, 1], I.E., a list with ones on each end and which switches between 4 and 2 in the middle?
21:29:38 <Rotaerk_> colton_, you just did
21:30:16 <c_wraith> always with one more 4 than 2?
21:31:03 <ezyang> colton_: an infinite list?
21:31:12 <ezyang> in which case: 1 : cycle [4, 2]
21:31:27 <ezyang> (since you'll never get to the end :-)
21:32:35 <c_wraith> :t replicate
21:32:36 <lambdabot> forall a. Int -> a -> [a]
21:33:05 <Rotaerk_> he may want 1 followed by some specified number N of alternating 4's and 2's
21:33:17 <Rotaerk_> but he's not been clear about that
21:33:30 <ddarius> > map ((1:) . fst) $ iterate (\(_,xs) -> (4:2:xs, 4:2:xs)) ([1],[4,1])
21:33:31 <lambdabot>   [[1,1],[1,4,2,4,1],[1,4,2,4,2,4,1],[1,4,2,4,2,4,2,4,1],[1,4,2,4,2,4,2,4,2,4...
21:34:19 <c_wraith> that left out [1, 4, 1]
21:34:35 <ddarius> > map ((1:) . fst) $ iterate (\(_,xs) -> (xs, 4:2:xs)) ([1],[4,1])
21:34:36 <lambdabot>   [[1,1],[1,4,1],[1,4,2,4,1],[1,4,2,4,2,4,1],[1,4,2,4,2,4,2,4,1],[1,4,2,4,2,4...
21:35:17 <colton_> Here's a solution: (1:4:(take n (cycle [2, 4])))++[1]
21:36:00 <ddarius> > map fst $ iterate (\(_,xs) -> (1:xs, 4:2:xs)) ([1],[4,1])
21:36:01 <lambdabot>   [[1],[1,4,1],[1,4,2,4,1],[1,4,2,4,2,4,1],[1,4,2,4,2,4,2,4,1],[1,4,2,4,2,4,2...
21:36:09 <c_wraith> you might want take (2 * n) in there
21:36:12 <ddarius> Das ist stimmt.
21:36:48 <colton_> Oh, yeah.
21:37:37 <colton_> Is there a way that I could have it throw an exception if I pass through a non even value?
21:38:07 <c_wraith> ...  yes, but exceptions are often not really what you want in haskell
21:38:43 <colton_> What would a good solution be then?
21:38:52 <ezyang> newtype TimesTwo = Int
21:38:54 <ddarius> Using 2 * n
21:39:55 <ddarius> Ideally you want to define your functions such that all input is well-defined and only sensible input is allowed.
21:40:34 <ddarius> The former aspect meaning make your functions total, the latter aspect meaning don't make it total by producing arbitrary nonsense output.
21:41:32 <ddarius> (e.g. drop 1 is total, but, as a tail replacement, produces nonsense output.  safeTail :: [a] -> Maybe [a] would be more sensible.)
21:42:14 <aeron> ddarius: how costly is using maybe?
21:42:21 <c_wraith> tail's just not total, right?
21:42:26 <colton_> It's interesting how you can solve problems in haskell. Ghci is particularly useful for the novice because it helps you play around and try solutions out in a way that's very difficult with compiled/imperative languages.
21:42:49 <ezyang> aeron: Not very
21:43:14 <ivanm> aeron: very; there's a patent on the Maybe data type with a rather steep licensing fee
21:43:15 <ivanm> ;-)
21:43:18 <luite> colton_: not only for the novice, it's always good (and fun) to experiment :)
21:43:30 <aeron> ivanm: :O oh noes!
21:43:53 <ddarius> aeron: How costly is it compared to what?
21:44:02 <luite> (still being somewhat a novice myself)
21:44:18 <aavogt> as compared to exceptions?
21:44:19 <ivanm> luite: aren't we all?
21:44:36 <ivanm> (especially with people like oleg and conal continually insisting on hurting our brains?)
21:44:42 <ivanm> s/?/.../
21:46:13 <aeron> aavogt: i guess
21:46:27 <aavogt> ddarius: using asynchronous exceptions is technically more efficient than Either?
21:46:50 <luite> oh cool, my (very limited) Clp binding seems to work, I solved a linear programming problem with 2 variables, yay :)
21:47:49 <ddarius> aavogt: Asynchronous exceptions aren't a replacement for using Either.  If tail [] is something you are considering a programming error that "should never happen," exceptions are faster, otherwise exceptions aren't really a solution.
21:48:15 <aeron> ddarius: what semantically fits to replace assert?
21:48:27 <luite> has anyone here worked with linear programming in haskell here? what would be a good way to describe the objectives and constraints?
21:49:03 <ddarius> aeron: As I said, for thing that are considered programming errors, exceptions are fine.
21:49:50 <luite> I currently have lists for everything, which is quite low level (the data that gets converted into vectors and a sparse matrix and then pushed through ffi to the solver)
21:55:06 <ddarius> Rule: Use some kind of exception/partiality monad for errors you'd like to handle and recover from such as user input, for things that are program errors that there is no reasonable recovery from use asynchronous exceptions.
21:56:57 <c_wraith> ddarius:  I agree with that fully.
22:04:52 <eflister> colton_: we forgot to mention byorgey's typeclassopedia.  read it once after lyah and before rwh.  after that, typeclassopedia is all you'll ever need.
22:05:03 <eflister> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
22:06:59 <eflister> lots of things are (almost) synonyms (ie, liftM and fmap), and without typeclassopedia this is a major source of confusion
22:07:20 <colton_> thx
22:11:19 <eflister> alright i'm heading out.  one last thing to check out, keep this in mind and have fun!  http://koweycode.blogspot.com/2007/01/think-of-monad.html
22:20:32 <ddarius> "Instead, one buys a parser generator and feeds it the desired syntax."
22:32:07 <ddarius> http://lambda-the-ultimate.org/node/1773  Have fun
22:35:45 <ezyang> haha
22:39:28 <hgolden> Hi. Is parsec-3.0.x upward compatible from parsec-2.1.0.1? Some packages want parsec < 3 while others want >= 3. I'm getting parsec version clashes trying to compile (for example) citeproc-hs-0.2. I'd appreciate advice about how to proceed. Thanks.
22:39:51 <Tordek> :pl (\x -> x ++ reverse x)
22:40:00 <Tordek> &pl (\x -> x ++ reverse x)
22:40:07 <Tordek> ?pl (\x -> x ++ reverse x)
22:40:07 <lambdabot> ap (++) reverse
22:40:16 <Tordek> thir time's the charmed
22:40:32 <ezyang> hgolden: unfortunately, no
22:41:06 <ezyang> hgolden: I believe I've seen hiding 3.0.0 with ghc-pkg as a suggestion. I don't know how well it works though
22:41:35 <hgolden> ezyang: No means versions aren't upward compatible? Just want to understand "no".
22:43:34 <ezyang> Most software... is not upwards compatible
22:48:17 <hgolden> ezyang: I'm a Haskell novice. My experience in other languages is that developers attempt to retain upward compatibility. This seems to me to be a worthy goal for Haskell too. Am I missing something?
22:49:32 <ivanm> hgolden: parsec-3 isn't fully compatible with parsec-2
22:49:37 <ivanm> this is indicated by the version number
22:49:44 <ivanm> @google Haskell Package Versioning Policy
22:49:46 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
22:49:47 <lambdabot> Title: Package versioning policy - HaskellWiki
22:49:51 <ivanm> hgolden: ^^
22:50:11 <ivanm> also, parsec is apparently slower (but I'm waiting for someone to do a criterion benchmark to prove this)
22:50:20 <hgolden> ivanm: Thanks. I will read it.
22:53:42 <ezyang> hgolden: Maybe I'm misunderstanding upwards compatibility
22:55:26 <ivanm> ezyang: I think he means the API doesn't change
22:55:54 <ivanm> which the PVP says is indicated by the first 2 digits remaining unchanged
22:55:55 <ezyang> ivanm: Ah, ok. That's what I refer to when I say "backwards compatible"
22:56:06 <ezyang> (for libraries)
22:56:19 <ivanm> ezyang: yeah, except I think hgolden means it from the opposite perspective
23:01:53 <hgolden> ezyang, ivanm: Specifically I would like to compile hxt-8.3.1 with parsec-3.0.x, but the cabal file says < 3.
23:02:06 <ivanm> hgolden: then you can't
23:03:11 <oboron> So, I am trying to make a Scale data type that can have a list of either Double or Ratio, what is the best way to go about this?  Should I do two data declarations, one for each?  Or something like > data Scale = Scale [a]?  But I don't want it to be any type, just Double or Ratio (or some numeric type that encompasses them both).  Comfused...
23:03:49 <hgolden> ivanm: Here's my frustration: some libraries use version dependent preprocessing to allow upward compatibility. It seems to me that that should be a design goal, at least for the Haskell Platform packages.
23:04:18 <ivanm> oboron: algebraic type? data DR = D Double | R Rational; newtype Scale = Scale [DR]
23:04:31 <ivanm> hgolden: uhhhh, what?
23:05:00 <ivanm> hgolden: some big libraries are stuck 20 years ago because they want to maintain backwards compatibility... *cough* windows *cough*
23:05:22 <hgolden> ivanm: I'm trying to avoid diamond-dependencies. That's the other side of the coin.
23:05:46 <ivanm> hgolden: why do you want/need parsec 3 support for hxt?
23:06:13 <ivanm> hgolden: note that diamond-dep is only a problem if hxt exports items from parsec-2 that you use whilst also using parsec 3
23:07:09 <ddarius> There should be very few parsec2 programs that don't compile against parsec3.
23:07:49 <oboron> ivanm:  So then each time I refer to them, I check for the type?  Most of the operations can be performed on either Double or Rational (+, *) so I don't need to check the type every time, which I would have to do with an algebraic type right?  Is there a numeric type that stands for them both?  Sorry I am a beginner and I appreciate the help.
23:08:08 <ivanm> oboron: why not just use Rational?
23:08:14 <hgolden> ddarius: Other than slower performance, is there any reason to not try to compile with parsec-3?
23:08:16 <ivanm> or Double
23:08:20 <ivanm> pick one and stick to it?
23:08:26 <ddarius> hgolden: Not really.
23:08:32 <ivanm> hgolden: some instances are overlapping or something IIRC
23:08:52 <ivanm> and there's _supposed_ performance problems; I haven't seen any definite figures
23:09:01 <ivanm> just a lot of people saying it's slower
23:09:18 <ddarius> If there have been Applicative instances added in the HXT source, then they will clash with the Applicative instances in parsec3.
23:09:18 <hgolden> ivanm: I'm just repeating the hearsay, not confirming it.
23:09:33 <oboron> ivanm:  Well, scales can be made of pure ratios, like just intonation, and others are based on irrational numbers, like 12-tone equal temperament is all powers of the 12th root of 2
23:09:45 <oboron> I suppose I could represent the irrational ones as ratios
23:10:15 <oboron> But I was also trying to optimize scales to satisfy various constraints, and floating point math seemed more natural for minute adjustments
23:11:20 <hgolden> ddarius: I will try it and find out. If there's any clash, I'll see if I can work out a preprocessing version-dependent solution.
23:11:27 <oboron> Possibly these are different enough to warrant separate types
23:13:03 <ddarius> hgolden: Parsec3 has a compatibility layer specifically meant to designed to make it work with parsec2 code.  The only issue that I'm aware of that would break compilation (other that bad practices) is the monomorphism restriction strikes a bit more often on parsec3 code.
23:13:42 <ddarius> hgolden: There are some slight semantic changes that I'm aware of (bug fixes) and possibly some more significant ones that I'm not aware of.
23:14:15 <hgolden> ddarius: Thanks. This gives me some reason for optimism.
23:14:42 <ddarius> There are only three times when it is completely safe to add an instance declaration: 1) in the module defining the class, 2) in the module defining the type, 3) in application code that you control.
23:23:02 <hgolden> ivanm: Here is an article about API design principles by a Java guru. I believe the points make sense for Haskell also: http://www.artima.com/weblogs/viewpost.jsp?thread=142428
23:23:23 <ddarius> I guess the proper solution to adding a type you don't control to a class you don't control in library code (and application code) is to newtype wrap the type and add the newtype to the instance.  This has other maintenance benefits but has a tedious upfront cost.
23:27:49 <ivanm> hgolden: I disagree
23:29:15 <ivanm> hgolden: that makes it hard to improve your library
23:29:31 <ivanm> especially since Haskell libraries are typically smaller, etc. than Java libraries
23:31:37 <ddarius> ivanm: I really like the stuff in the Miscellaneous section.
23:31:45 <ddarius> "Other random tips"
23:32:39 <ivanm> eh, some of it is OK
23:37:17 <ddarius> hgolden: The points make sense technically for Haskell, but they are not as compelling culturally in the current Haskell culture.
23:38:53 <ivanm> ddarius: maybe once the libs, etc. mature a bit
23:39:04 <ivanm> but for the most part, we're still working out good libs, etc.
23:47:21 <hgolden> ivanm, ddarius: This article is food for thought. The Java culture is oriented toward enterprise developers. To me, this is a valuable goal for Haskell also. I'm not suggesting prematurely locking down APIs. However, this parsec version situation would drive enterprise developers nuts.
23:48:04 * Nafai sighs
23:48:11 <Nafai> "enterprise" is such a meaningless term
23:48:47 <ivanm> agreed
23:49:51 * drhodes readies proton doritoes
23:50:37 <ivanm> sounds painfully delicious! ;-)
23:50:47 <Nafai> And, unfortunately, only a very small subsection of the Java developers I have worked with would I qualify as being excellent developers having high standards about code and libraries and practices
23:53:46 <hgolden> Nafai: I'm not claiming Java culture is better than Haskell. However, there are always ideas from other languages worth considering.
23:54:23 <ddarius> hgolden: It's not a matter of better or worse, it's just differences.  Mainly differences in priorities.
23:55:35 <ddarius> I guess there is one solution that I personally could implement which is republishing parsec-3.0.1+ as parsec3 (and also potentially, and more dramatically, republishing parsec2 as parsec-4.0 (or some other version number >3))
23:56:18 <Nafai> hgolden: Oh, I agree.  After working primarily in Java for 3 years, I took a few valuable things from the experience -- though I admit that much of it happened to be the great engineers I was working with and I might have learned them no matter the language.
23:56:42 <Nafai> hgolden: For example, versioning of software and libraries and dependency management.  Luckily Haskell has cabal and can fulfill that role
23:57:04 <ddarius> Alternatively, alternatively, I could simple -stick- parsec2 into parsec3 as the "compatibility" layer and then there would be little reason for all libraries not to upgrade to parsec-3.
23:57:22 <Nafai> hgolden: continuous integration, testing, language aware tools (IDE is such a hotly debated term and idea these days, so I call them "language-aware tools" and I'm meaning more than just syntax highlighting)
23:59:46 <hgolden> ddarius: I'm not telling you which is better. I don't know enough. However, I would be happy to try whatever you decide to do.
