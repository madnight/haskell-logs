00:01:37 <ddarius> hgolden: Neither of those approaches, particularly the latter one, would require "trying."
00:02:34 <ivanm> is one of the haskell machines called "notty"?
00:03:43 <ddarius> Possibly a Yale machine that might host some Haskell stuff is called that.
00:04:37 <ddarius> http://haskell.org/haskellwiki/Haskell.org_domain
00:05:38 <ivanm> because I had an ssh session pushing a lot of stuff to a machine called notty, and it wasn't till after I pkill'd ssh that I thought it might have been that...
00:11:04 <dejones> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11131#a11131
00:11:12 <hgolden> ddarius: are you the parsec maintainer?
00:11:22 <dejones> I've got a "parse error in pattern" for an if-within-do block... not sure why.  :(
00:12:54 <Gracenotes> dejones: ..that looks fine, as far as I know
00:13:04 <dejones> Gracenotes: hmm.  :/  yea, that's why I'm confused...
00:13:05 <ijnek> ld takes up more than 100mb of ram when ghc links my program. is there anything wrong going on?
00:13:15 <earthy> nope.
00:13:26 <earthy> there's just Many Many linker objects
00:13:28 <Gracenotes> you might want to do return $ Just b, but that's type-checking, not parsing
00:14:13 <Gracenotes> dejones: oh, you forgot the 'do' after else
00:14:16 <ijnek> earthy: I see. thanks
00:15:18 <Gracenotes> although you could also say "liftM Just get" and avoid a do block altogether
00:15:41 <dejones> Gracenotes: ah ha!  Yea, I was really confused that GHC was telling me the parse error in patten on the "if-statement" but that makes sense.
00:16:19 <ddarius> hgolden: Yes.
00:16:57 <dejones> Gracenotes: thanks!
00:17:19 <Gracenotes> \o/
00:18:23 <reklama> http://action.metaffiliation.com/suivi.php?mclic=S42665516A5D131
00:20:05 <ddarius> The pattern calculus is so pretty.
00:41:40 <hgolden> ddarius: Then I guess I came to the right place. Thanks for your consideration of my concerns. Time for bed. I'll get back to you after trying hxt with parsec-3.
00:49:44 <performance> why did GHC not move to git?
00:50:05 <performance> http://hackage.haskell.org/trac/ghc/wiki/DarcsEvaluation#Externalreferences  seems to imply otherwise
00:50:07 <dixie> or darcs :)
00:50:42 <performance> http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources  says i need darcs to get the sources :)
00:55:59 <allbery_b> IIRC ghc is in a halfway condition at the moment
00:56:33 <allbery_b> the problem being that ghc depends on a number of external libraries that are not moving to git with it
00:57:23 <performance> is their fundamental problem with > 16Kpatches causing darcs to be unusable solved though?
00:58:01 <sjanssen> performance: it's gotten better, but not entirely
00:59:04 <sjanssen> and the darcs project has become healthier since that was written
00:59:06 <performance> sjanssen: i assume its not possible to break that into three or four subsets and checkpoint those and avoid any complexity due to high number of patches?
01:01:46 <sjanssen> performance: I'm not sure that number of patches is the real issue
01:02:32 <ivanm> IIRC, they mentioned at the implementors workshop that in the end, darcs was working good enough and they couldn't be bothered finishing the move
01:02:59 <sjanssen> yes, this is what I've heard of the current state
01:41:57 <A1kmm> Has anyone else seen link problems using Happstack with happstack-contrib? I get /usr/local/lib/happstack-contrib-0.2.1/ghc-6.10.3/libHShappstack-contrib-0.2.1.a(Facebook.o): In function `s1IDm_info':
01:41:59 <A1kmm> (.text+0x3adce): undefined reference to `happstackzmserverzm0zi2zi1_HappstackziServerziXSLT_constrZMaxU9ZN_closure'
01:42:29 <A1kmm> This is when building with ghc --make. The symbol does seem to be there though:
01:42:49 <A1kmm> nm /usr/local/lib/happstack-server-0.2.1/ghc-6.10.3/libHShappstack-server-0.2.1.a  |grep happstackzmserverzm0zi2zi1_HappstackziServerziXSLT_constrZMaxU9ZN_closure
01:42:50 <A1kmm> 0000000000000cb8 D happstackzmserverzm0zi2zi1_HappstackziServerziXSLT_constrZMaxU9ZN_closure
01:57:08 <dons> performance: darcs 2.x worked
01:57:14 <sinelaw> hey Peaker
02:00:45 <performance> dons: as in the performance problems alluded to with a high number of patches are not aconern any more?
02:00:59 <tumult> i'm writing my first real app in haskell. i need to write to write some data to a posix handle at 40hz. got my writing stuff working, can someone point me in the right direction for doing some kind of rapid scheduling like that in gtk2hs?
02:01:14 <tumult> oops, too many write tos in that second sentence :)
02:03:00 <Cale> I suppose the first thing you'll want to know about is threadDelay.
02:03:30 <tumult> taking a look now
02:03:48 <Cale> It's in Control.Concurrent
02:03:49 <A1kmm> hmm, I think gcc with GNU ld needs static library dependencies to appear before the depending static library; but it looks like ghc doesn't do this for all dependencies on a library when there is more than one.
02:04:08 <Cale> You pass it a number of microseconds and it does its best to wait that long
02:04:33 <tumult> ah ok
02:04:55 <A1kmm> I wonder if that is a known issue.
02:05:04 <tumult> i saw gtk2hs had clock stuff for media. better to use threadDelay? i need more accuracy than posix/unix sleep
02:05:31 <tumult> when i implemented this in c, i had my own runloop which used kernel time (in nanoseconds) and sleep(0) for accuracy
02:05:38 <Cale> Well, I don't know what gtk2hs has
02:06:23 <tumult> yeah i think threadDelay uses sleep() or equivalent
02:06:31 <tumult> so it would just bow to the os' scheduler
02:06:33 <Jafet> I don't suppose threadDelay is just a wrapper for POSIX...
02:06:42 <Jafet> busyLoop?
02:07:03 <tumult> where is that?
02:07:11 <ddarius> gtk2hs should have some timer object
02:07:32 <tumult> yeah i was looking at http://www.haskell.org/gtk2hs/docs/devel/Media-Streaming-GStreamer-Core-Clock.html
02:07:33 <Jafet> In my imagination
02:07:54 <tumult> i'm not sure how to use it, though
02:09:04 <ddarius> http://www.haskell.org/gtk2hs/docs/devel/Media-Streaming-GStreamer-Core-Clock.html#v%3AclockTimeout
02:09:54 <tumult> it looks like i should fork a thread and loop while calling clockIDWait with a clock i've set up for the intervals i need?
02:11:18 <tumult> i'll give it a try :)
02:14:38 <tumult> oh, i don't have that part of gtk2hs, heh
02:16:26 <ddarius> There should be a timer object in the gtk2hs GUI modules.
02:18:26 <ddarius> http://www.haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-General-General.html#v%3AtimeoutAdd
02:19:18 <tumult> how precise is it? i need to within a few microseconds :/
02:19:52 <tumult> which is why i had my own runloop when i did it in c
02:19:56 <ddarius> The GStreamer library is probably quite a bit better for precision.  This function is not guaranteed to be precies.
02:20:35 <tumult> i'm on mach (os x) and there's mach_absolute_time which returns a very accurate (but architecture-dependent) timing struct
02:20:59 <tumult> you do a little division on it and get a time that's accurate to within some nanoseconds
02:21:59 <ddarius> tumult: You could FFI that pretty easily.
02:22:16 <tumult> the other GUI timing stuff in gtk2hs looks to be in Graphics.UI.Gtk.Gdk.EventM and is 32-bit
02:22:34 <tumult> hm ok, i haven't done FFI yet but i'm up for the challenge
02:22:46 <ddarius> tumult: FFI is pretty easy in Haskell.
02:22:54 <tumult> yeah i've heard
02:23:08 <tumult> i figured i would do it while working on this at some point anyway :)
02:23:21 <ddarius> tumult: You'll probably have issues with garbage collection as far as timing though.
02:23:42 <tumult> i probably won't be creating/destroying anything in that thread
02:23:59 <ddarius> tumult: Garbage collections stop all threads.
02:24:03 <tumult> ah
02:24:14 <tumult> well i can miss some sometimes and nothing bad will happen
02:24:35 <tumult> and 40hz isn't THAT fast, really
02:24:35 <ivanm> for people using haskell-mode in emacs, does mod-q wrap haddock-style quotes for you properly?
02:24:53 <ksf> 40hz is dead slow.
02:25:00 <ivanm> s/quotes/comments/
02:25:05 <ddarius> tumult: 40hz is really slow, but being within microseconds of 40hz increments is not nearly as easy.
02:25:09 <ivanm> -- | and -- ^ comments don't auto-wrap and stay on the same line; plain -- comments do wrap :s
02:25:11 <tumult> right :)
02:25:45 <tumult> so i'm guessing i would to try to have collection be right after a write? no clue how GC actually works in haskell, heh
02:25:57 <tumult> and that's pretty low on my priority list right now, i'm just getting started
02:26:37 <ksf> if you're doing media, you should have a look at jack, it's going to solve all your timing issues.
02:26:51 <tumult> actually i'm controlling stage lighting
02:27:02 <tumult> DMX protocol, which is like MIDI
02:27:11 <ddarius> ksf: 40hz precludes most forms of media
02:27:14 <tumult> though light fixtures tend to throw a fit if your timing deviates
02:27:34 <ksf> with a bit of luck, you can send those via jack. it learned midi some time ago.
02:27:44 <tumult> well it's not MIDI exactly, just similar
02:28:12 <tumult> and the hardware interfaces are all bad/different, there's no standard like midi except for the network DMX devices, but those aren't very accurate
02:29:20 <tumult> this is just a serial<->usb thing i'm using here, shows up as a handle in /dev and you write bytes to it to construct DMX packets
02:31:04 <ksf> well you could just pipe your commands to /dev/blinkenlights in your jack callback. you get sample accuracy, then
02:31:18 <tumult> ohh
02:31:21 <tumult> that sounds good
02:31:22 <ksf> (iirc jack doesnt' do any pre-computation/caching)
02:31:44 <tumult> thanks for that idea :)
02:38:51 <tumult> Searching for st.h...setup: user error (ERROR: st.h not found)
02:38:59 <tumult> on cabal install jack
02:39:09 <tumult> i have jack installed (os x pkged version)
02:40:19 <skorpan> has anyone here successfully built gtk2hs from darcs?  i get "Visual not in scope", where Visual is some datatype.  same for some function named "mkVisual"
02:43:19 <Saizan> tumult: maybe you've to use --extra-include-dirs= to point cabal to the right dir?
02:43:42 <tumult> well it says it found JACK
02:43:46 <tumult> i don't know what st.h is part of
02:43:56 <tumult> i'm downloading the darcs repo of the jack library right now
02:44:22 <skorpan> <tumult> well it says it found JACK
02:44:24 <skorpan> hehe
02:44:31 <skorpan> am i the only one who misunderstood?
02:44:32 <tumult> haha
02:44:39 <tumult> i just realized
02:46:39 <skorpan> does anyone know how to build gtk2hs with everything disabled except for gstreamer?
02:48:06 <Saizan> skorpan: ./configure should have flags for that
02:48:23 <skorpan> Saizan: according to the README, it has flags for only a subset of the functionality
02:48:40 <skorpan> e.g. you can't disable glib (but i don't know, maybe gstreamer needs that)
02:50:58 <ivanm> skorpan: with haskell-mode in emacs, do haddock-style comments wrap with M-q?
02:51:10 <ivanm> they don't for me, but normal -- style comments do :s
02:51:33 <skorpan> yes, haddock-style comments wrap at least for me
02:51:49 <ivanm> hmmmm.... any funky config settings or something you have set?
02:52:00 <ivanm> oh, and what version of haskell-mode do you have?
02:52:01 <skorpan> no, i'm basically running vanilla
02:52:15 <skorpan> ;; Version: v2_4
02:53:31 <ivanm> skorpan: does it auto-wrap when you're writing it and hit enter, etc.?
02:53:40 <tumult> heh, darcs won't install from cabal on os x for me
02:53:52 <skorpan> ivanm: no, it normally doesn't do that in emacs
02:54:51 <ivanm> skorpan: OK, I'm guessing the function I've taken from http://www.emacswiki.org/emacs/AutoFillMode is then identifying haddock comments as code or something...
02:55:03 <ivanm> or, it would too, since it isn't using font-lock-comment-face
02:55:52 <skorpan> try adding font-lock-doc-face to that check somehow
02:55:54 <ivanm> dammit, my elisp-fu is too weak to work out how to edit and fix that :s
02:56:03 <ivanm> skorpan: yeah, just not sure how...
02:56:10 <skorpan> i can try if you give me a sec
02:56:25 <ivanm> skorpan: yay, that will save me from testing the troubled waters of #emacs! \o/
02:56:46 <FunctorSalad> :o
02:57:04 <medfly> Haskell is awesome!
02:57:15 <ivanm> medfly: that's a given
02:57:31 <skorpan> ivanm: ugly, but should hopefully do the trick http://pastebin.com/d310e8809
02:57:33 <ivanm> medfly: well, actually, awesome is a tiling window manager written in C (IIRC) using Lua for configuration... ;-)
02:57:48 <ivanm> thanks skorpan...
02:57:57 <tuukkah> Haskell is xmonad!
02:58:02 <ivanm> tuukkah: heh
02:58:04 <medfly> xmonad is Haskell!
02:58:16 <ivanm> I'd guess you'd ideally want to get the value of get-text-... into a variable and test that...
03:01:48 <ivanm> skorpan: well, it half-works... it doesn't leave space for the | when wrapped :(
03:02:41 <ddarius> :t Data.Set.difference
03:02:42 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
03:03:10 <ivanm> thanks anyway though
03:03:26 <FunctorSalad> uhm http://hackage.haskell.org/packages/archive/haskell-src-exts/1.2.0/doc/html/Language-Haskell-Exts-Comments.html
03:03:32 <FunctorSalad> but there are no comments in the AST
03:03:46 <FunctorSalad> (or I can't find them)
03:05:05 <FunctorSalad> hmm there's parseFileWithComments but that just gives you a list of comments...
03:06:01 <FunctorSalad> (I wanted to use src-exts as a preprocessor)
03:06:56 <Saizan> FunctorSalad: i think you need to use the .Annotated modules
03:07:31 <ivanm> yeah
03:07:41 <ivanm> with 1.2.0, they're officially supported IIRC
03:07:44 <FunctorSalad> Saizan: "C-f comments" here gives no results http://hackage.haskell.org/packages/archive/haskell-src-exts/1.2.0/doc/html/Language-Haskell-Exts-Annotated-Syntax.html
03:08:05 * ivanm was quite pleased that he didn't have to change a thing to make his code work with 1.2.0 (not using any Annotated modules though)
03:08:23 <Saizan> yeah, but the SrcSpanInfo let you tell where a comment is
03:09:40 <FunctorSalad> maybe preprocessor-tools is the way to go for substing stuff for comments?
03:09:40 <Saizan> and exactP to print them back correctly
03:10:14 <ddarius> :t Data.Set.union
03:10:15 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
03:10:18 <ddarius> :t Data.Set.unions
03:10:19 <lambdabot> forall a. (Ord a) => [S.Set a] -> S.Set a
03:10:58 <jkff> Hi. Is there a GUI for viewing darcs history?
03:11:48 * Saizan uses darcs changes | less
03:12:23 <jkff> Heh. But that does not show patch dependencies. I remember seeing a video about darcs that showed kind of a graph of them, but I can't find the video or the tool.
03:13:14 <reklama> http://action.metaffiliation.com/suivi.php?mclic=S42665516A5D131
03:13:16 <reklama> http://action.metaffiliation.com/suivi.php?mclic=S42665516A5D131
03:13:17 <Saizan> http://projects.haskell.org/camp/unique <- this one?
03:13:18 <reklama> http://action.metaffiliation.com/suivi.php?mclic=S42665516A5D131
03:13:19 --- mode: ChanServ set +o Saizan
03:14:18 --- mode: Saizan set +b *!n=s_e-b-e_@77.253.183.172
03:14:29 --- mode: Saizan set -o Saizan
03:14:41 <jkff> Yes, that one! Thanks!
03:15:22 <Saizan> that's not exactly about darcs though
03:15:32 <jkff> Yeah, I noticed, however there's a tool for converting
03:17:27 <ivanm> in case anyone wasn't aware, "reklama" means "advertisement" in slavic languages
03:17:34 <tumult> haha
03:17:38 <ivanm> so even that spammers nick was a giveaway ;-)
03:17:48 <tumult> hm does anyone currently use the jack haskell library?
03:18:56 <aep> any idea why it expects a->b here although acording to precedence it should expect [[a]] ?  http://codepad.org/kmJoeS9p
03:19:11 <ksf> last time I tried, the bindings were defunct.
03:19:41 <tumult> yeah it does not seem to work
03:19:48 <tumult> or build, rather
03:20:39 <tumult> i think i will just try FFI wrapper for mach's kernel time stuff
03:21:15 <aep> actually paranthesis don't help either. if i interpret the error message correct, it tries to call the lambda on the second argument, although those should be two arguments
03:23:04 <ksf> what do you want to do with the result?
03:23:24 <aep> well print. doesn't matter for the problem
03:23:42 <ksf> ...well it does, as you have to have IO actions inside the do block.
03:23:57 <koala_man> aep: it's interpretted as  (etc) . (lines i)
03:23:58 <ksf> ...which could result in that cryptic message
03:24:02 <aep> my confusion is that  filter (\line -> length line < 10)  is clearly [[a]]->[[a]]  but it whines about getting a [string]
03:24:14 <mle> aep: add putStrLn $, and change all your .'s to $'s.
03:24:29 <aep> mle: yes that works, but i wonder why
03:24:50 <aep> koala_man: yes, but how is that wrong? :/
03:24:51 <ksf> ...or keep the .'s and add a $ before the i
03:24:59 <mle> aep: or, add putStrLn ., and put parens around everything except the i
03:24:59 <en0th> :t (//)
03:25:00 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
03:25:01 <koala_man> aep: . composes functions. (lines i) is a [String]
03:25:02 <aep> lines i  returns [[Char]]
03:25:27 <mle> . doesn't have the precedence you want
03:25:35 <koala_man> aep: if you had  etc . lines $ i  , it would work
03:25:40 <aep> koala_man: yes, and filter (lambda)  takes a [[a]] as second argument
03:25:51 <koala_man> aep: if you want it as an argument, you use $
03:26:06 <aep> now i'm even more confused then before
03:26:13 <mle> :t $
03:26:14 <lambdabot> parse error on input `$'
03:26:20 <mle> :t ($)
03:26:21 <lambdabot> forall a b. (a -> b) -> a -> b
03:26:28 <mle> :t (.)
03:26:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:26:33 * ksf recommends let foo = unlines .  filter (\line -> length line < 10)   . lines \n printLn . foo $ i
03:27:04 <aep> ksf: ah now it makes sense
03:27:05 <mle> Ah, that's a good approach
03:27:30 <jkff> I'd better do unlines . filter ((<10).length) . lines
03:27:39 <ksf> that, too.
03:28:02 <aep> right precedence can be left or right aligned. very confusing.  thanks guys!
03:28:12 <mle> and then use interact, heh
03:28:29 <ksf> or even let unlined f = unlines . f . lines in unlined (filter ((<10.length))
03:29:29 <en0th> got a doubt. I want to write some helper function to (//) (from Data.Array.IArray). What i want to achieve is to avoid list comprehension as second argument.
03:30:05 <ksf> @index (//)
03:30:05 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff, Data.Array
03:30:26 <mle> aep: main = interact $ unlines . filter ((<10) . length) . lines
03:31:19 <en0th> is it better to wrap (//) itself or to simply write a 'packer' to build the second argument of (//)
03:31:22 <ksf> en0th, // isn't forcing you to use comprehensions...
03:31:57 <ddarius> length is overly strict...
03:32:11 <en0th> yes, but how to avoid them? you'll came up with a lot of lambdas
03:32:13 <ksf> it has to be, if you don't use peanos.
03:32:38 <ksf> arr // [(1,5)(4,4)]
03:32:41 <ddarius> Or one could just not use length (or not use length by itself)
03:32:47 <ksf> ...add a comma between the )(
03:33:22 <ddarius> (<10) . length . take 10
03:33:53 <en0th> for example, i'll need to have a function sum two rows of a 2d matrix.
03:34:56 <en0th> i thought it was easier to have a function with type like this (IArray a e, Ix i) => (i -> e) -> [i] -> (a i e -> a i e)
03:35:06 <ray> aieeeeeeee
03:35:13 <en0th> hehe
03:35:52 <ksf> ...there should be foldable instances for array, somewhere...
03:36:25 <ksf> then I'd transpose the array so that I can easily extract the elements I want to sum, and fold (+) over them.
03:36:39 <ksf> er wait.
03:37:02 <ksf> all that indexing stuff haskell does utterly destroys my array-foo.
03:38:13 <ksf> (in fact, the only time I needed to work with arrays in haskell I happened to use Ptr's.
03:41:14 <en0th> my real trouble is how to merge some // applications once i know they won't interfer (i.e. each one will target a different row)
03:41:43 <en0th> i was reading about arrows, and found them somewhat suited to this
03:42:12 <ksf> arr // [(1,5),(3,6)]++[(4,4)]
03:46:23 <en0th> so i won't check for overlapping
03:46:52 <ksf> :t nubBy
03:46:53 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
03:48:17 <ksf> > nubBy (\a b -> fst a == fst b) ([(1,5),(3,6)]++[(4,4)] ++ [(3,5)]
03:48:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:48:21 <ksf> > nubBy (\a b -> fst a == fst b) ([(1,5),(3,6)]++[(4,4)] ++ [(3,5)])
03:48:22 <lambdabot>   [(1,5),(3,6),(4,4)]
03:49:49 <en0th> ok, so the point is to decide when to accumulate and when to update
03:50:27 <ksf> yep. accumulating the modifications could be a good idea performance-wise, but don't trust me more than your profiler.
03:50:50 <en0th> hehe, ok i'll do
03:51:39 <en0th> this problem i'm solving is ineherently parallel, so a good approach would lead to many optimizations
03:52:27 <ksf> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
03:54:20 <ski> > ((< (10 :: Natural)) . genericLength) [0..]
03:54:22 <lambdabot>   False
03:54:30 <en0th> that's very cool
03:55:55 <en0th> the transformation involved in this algorithm is (given a matrix):  1) scale a row 2) sum it to every other row 3) do some analysis 4) repeat
03:57:12 <en0th> anyway.. is there a better way to write:  zip is (map f is)
03:58:15 <ksf> not really. you could do zipWith (\x -> (x, f x)) is
03:58:21 <ziman> ap zip (map f), i suppose
03:58:33 <en0th> i cannot use ( . ) , right?
03:58:43 <ksf> > zip`ap`tail [0..]
03:58:44 <lambdabot>   Couldn't match expected type `[a] -> [b]'
03:58:44 <lambdabot>         against inferred type `[t]'
03:58:53 <ksf> > (zip`ap`tail) [0..]
03:58:54 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
03:59:11 <en0th> :t ap
03:59:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:59:38 * ksf considers ap/<*> evil as long as there's no <$> in front
03:59:55 <ziman> :t ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
03:59:56 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
04:00:53 <ski> > let f = (^2); is = [0..] in graph f `map` is
04:00:55 <lambdabot>   [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)...
04:01:15 <en0th> we even could use second from arrow, right?
04:01:18 <ski> ksf : why ?
04:01:35 <ksf> because I don't usually indulge in obfuscation
04:02:11 <ksf> I rather parse three symbols more and think three hours less.
04:02:20 <ski> sure, using the `(r ->)' applicative often results in obfuscation
04:03:16 <ski> however, one could still use "ap/<*>" without "<$> in front" for other applicative functors
04:03:56 <ksf> like lists, yes.
04:04:04 <ksf> it also works for parsers
04:04:05 <ski> (e.g. parsing .. maybe you parse some text, returning a function, then parse more, returning an argument, and want to apply the function to the argument)
04:04:31 <ksf> but it's not like grokking applicative would help grokking how it's applied to a specific domain
04:05:12 <ksf> ...lists being a great example, as there are two applicative interpretations for them
04:05:29 <ksf> ...multiplicative and zippy.
04:05:35 <en0th> > map (id &&& (\x -> x + 1)) [1..10]
04:05:36 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
04:05:41 <en0th> w00t!
04:05:48 <ski> (en0th : btw, if you didn't notice, that `graph' example was meant as an example for you)
04:05:59 <ski> <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph = (arr id &&&)
04:06:03 <ski> there you go :)
04:06:07 <en0th> oh.
04:06:22 <en0th> sorry.. why is it called graph?
04:06:31 <Exteris> :t (&&&)
04:06:32 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:06:36 <Exteris> :?
04:07:04 <ski> because it gives the graph of the arrow, represented as a subobject
04:07:37 <ski> (the graph of a binary relation being a subset of the cartesian product of the domain and the codomain)
04:08:34 <ski> Exteris : `(&&&) :: Arrow (~>) => (a ~> b0) -> (a ~> b1) -> (a ~> (b0,b1))' might be more readable naming
04:08:46 <en0th> that's clever, ski.
04:08:52 <ski> en0th : there's also a dual `cograph' to go with it
04:08:59 <ski> <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph = (||| arr id)
04:10:03 <ski> (the cograph of a function being a quotient set over the disjoint union of the domain and the codomain)
04:11:25 <ski> > cograph show `map` [Left 1,Right "2",Left 3,Right "4"]
04:11:27 <lambdabot>   ["1","2","3","4"]
04:12:07 <en0th> mm
04:12:57 <en0th> i cannot see a use in wider terms, but i assume it's useful for some problems
04:13:34 <en0th> guys, you really rock.
04:13:54 <ski> (i'm not sure how useful `cograph' is in practice .. i'm just introducing it to remember looking for problems where it might be nice)
04:14:14 <EvilMachine> hey, if ‚Äúdata TMyType = MyType { fA :: Int; fB = String }‚Äù, then how would you do something like ‚Äúlet h = MyType 2 "bla"; f = fA in f $ h { f = 0.4+(f h) }‚Äù?
04:14:52 <EvilMachine> (The key point being the f = inside the {} at the end.)
04:15:27 <EvilMachine> en0th: yep, they do. ^^
04:16:40 <Saizan> EvilMachine: you can't
04:17:02 <EvilMachine> Saizan: that‚Äôs bad. :/
04:17:05 <Saizan> EvilMachine: but see data-accessor for workaround
04:17:23 <EvilMachine> Saizan: apparently I also can‚Äôt pattern-match against functions.
04:17:26 <en0th> @index graph
04:17:27 <lambdabot> bzzt
04:17:50 <Saizan> the idea is that you can define upd_fA f x = x { fA = f (fA x) }
04:18:08 <en0th> ski: what needs to be imported to access graph?
04:18:18 <ski> no
04:18:31 <ski> afaik, it's not defined in any package
04:18:31 <Saizan> EvilMachine: yeah, you'd basically need an inverse for each function if you wanted to pattern match on it
04:18:45 <ski> i defined it (privately) for lambdabot, the definition is above
04:19:04 <Saizan> EvilMachine: you can only pattern match on constructors, though ViewPatterns might fit your needs
04:19:21 <EvilMachine> Saizan: so i have to define an update function fo every field? sounds like pointless repititive and easily automatable work. i can‚Äôs believe that it‚Äôs not build-in. :/
04:19:25 <ski> if it were to be deemed useful enough to be included in a library, it would probably be in module `Control.Arrow'
04:19:25 <ksf> @vixen, do you like it if we do private definitions?
04:19:26 <lambdabot> yah, i like
04:19:36 <Saizan> EvilMachine: there are TH macros for it
04:19:42 <en0th> ski:  okk
04:19:54 <ksf> @vixen and how do you feel about public definitions?
04:19:54 <lambdabot> yes i do
04:19:58 <ski> so if you think it's nice, you have to defined it yourself, atm
04:20:12 <ski> (and maybe prod maintainers, if you think it should be included)
04:20:21 <Saizan> EvilMachine: looks for accessor or functional reference in the haskell community :)
04:20:24 <ksf> girls. the art of replying without answering.
04:21:01 <EvilMachine> Saizan: ah, ok. so TH, ViewPatterns or data-accessor(s), to summarize. one of them should do it, I guess. :) thank you :)
04:21:47 <Saizan> EvilMachine: the record system is known to be limited, there has been various proposal to extend it, but none that got a strong enough support to get it implemented
04:22:20 * ksf thinks they're all to conservative.
04:22:26 * Saizan too
04:22:48 <ksf> if we get new records, I want full-fledged smalltalk objects.
04:22:55 <en0th> ski: last question: why did you write `arr id &&&` instead of `id &&&` ?
04:22:58 <ksf> ...statically typed.
04:23:09 <EvilMachine> Saizan: well, the ability to use what i asked at the very beginning, would be very natural. but perhaps that‚Äôs only the case for me. :)
04:23:12 <ski> @type (id &&&)
04:23:14 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
04:23:15 <sinelaw> arr id lifts id into an arrow
04:23:20 <ski> en0th : question answered ?
04:23:46 <Saizan> with ViewPatterns you can translate things like  "foo x = case bar x of p1 -> e1; p2 -> e2; .."  into  "foo (bar -> p1) = e1; foo (bar -> p2) = e2"
04:24:05 <en0th> :t (arr id &&&)
04:24:06 <lambdabot> forall b (a :: * -> * -> *) c'. (Arrow a) => a b c' -> a b (b, c')
04:25:02 <ski> (if i'm using arrow operations, i don't see a reason to restrict only to the `(->)' arrow, when others might be useful as well)
04:25:39 <en0th> aw, ok. Arrows are not only functions, that's right
04:26:40 <EvilMachine> ksf: hmm, i would prefer that we don‚Äôt destroy the freedom that type classes offer over types. especially that class (in OO speak) hierarchies are by definition unnatural and stupid. fully fledged class (OO) graphs make more sense. i come from OO programming, and i always hated the rigid enforcement of it being a simple tree. no solution is as free, as the one of haskell: to simply define interfaces to the data of an ‚Äúobjec
04:27:49 <ski> Saizan : will that make only one call to `bar' ?
04:27:54 <Saizan> EvilMachine: i think data-accessor + data-accessor-template will work well for you then, though you don't get the nice syntax
04:28:13 <Saizan> ski: the manual says it should
04:28:33 <ski> (even if `bar' is a complex expression ?)
04:29:07 <Saizan> ski: they coalesce such calls as part of the optimization of patterns, not sure how reliable it is
04:29:08 <ski> (where "complex" means "not a variable")
04:30:54 <ski> EvilMachine : cut off at "... to simply define interfaces to the data of an ‚@\objec"
04:31:27 <ray> an hobject
04:31:52 <EvilMachine> ski: oh, sorry. seems your client can‚Äôt do UTF-8. i‚Äôll post it again without the special chars
04:32:25 <ray> no, he just wants the end if there was more :)
04:32:43 <ski> EvilMachine : (yes, i've not configured UTF-8). the main problem was that your line was too long, so the end was cut off arbitrarily by the server
04:33:04 <EvilMachine> ok, the end was: [‚Ä¶] of an "object", and allow later definiton of new interfaces by others.
04:33:14 <EvilMachine> ah, ok
04:33:18 <EvilMachine> ^^
04:34:06 <ski> (afaiu, this is a bug in the IRC protocol)
04:34:07 <ray> typeclasses have so many glaring flaws, but i think it's because they're pushing the boundaries in a way
04:34:28 * EvilMachine would prefer if there were a minimum length requirement for messages on IRC. ^^
04:34:56 <EvilMachine> ray: which flaws specifically?
04:35:50 <ski> EvilMachine : so you'd rather people didn't say short things like "no", then ? ;)
04:37:52 <EvilMachine> aw man, so to define a function which can modify an arbitrary field in a type, depending on which field you choose, you have to do something like "myfunc :: (MyType -> a) -> (a -> MyType) -> (a -> a -> a) -> MyType -> MyType)"? That looks *horrible*. :(
04:38:19 <ski> where does that type signature come from ?
04:38:43 <Saizan> no, that wouldn't work :)
04:38:46 <EvilMachine> ski: no. a *minimum* length. where you can‚Äôt write anything shorter than that.
04:38:49 <ray> i can't think of anything specific, just that there's plenty of annoyances that come up while programming
04:38:57 <EvilMachine> ski: just made up on the spot. ^^
04:39:03 <ray> if i had written any haskell in the past month...
04:39:26 <EvilMachine> Saizan: why would that not work??
04:39:30 <ski> EvilMachine : .. yes, so assuming 2 is less than that minimum length, a "no" message would not be allowed
04:39:32 <ray> the flaws of irc are always close to my mind though
04:39:39 <Saizan> you nee "(MyType -> a) -> (a -> MyType -> MyType) -> (a -> a -> a) -> MyType -> MyType"
04:39:54 <ray> ski: just write "no padding padding padding padding padding"
04:40:11 <Saizan> well, actually s/a -> a -> a/a -> a/ seems more appropriate to me
04:40:30 * ski was wondering about a rationale for a minimum length requirement (greater than zero)
04:40:42 <EvilMachine> ray: Ok, agreed on the annoyances. One could say that many things that you take as a matter of course, require big things in Haskell. Like loading a entire language extension library and switching on GHC extensions.
04:40:52 <ski> (or actually, i was joking about what i thought was a thinko of EvilMachine)
04:41:20 <ray> well the everyday annoyances with haskell are things you only wish could be your everyday annoyances in other languages, so i think we're ahead for now
04:41:30 <EvilMachine> ski: exactly. a "no" would not be allowed. the ", because ..." would be missing there anyway. which was my point. ^^
04:41:36 <Saizan> however (a -> MyType) can't work to update a field, it could only construct a value of MyType given only that field, though i guess it could be a partial application of (a -> MyType -> MyType) to the original value you pass to myFunc
04:42:26 <ray> just as a random example, there's no "or" in typeclass constraints
04:42:47 <ski> that would require backtracking, no ?
04:42:54 <ray> yes, i think so
04:43:21 <Saizan> typeclasses are limited like this to permit separate compilation, not sure if we want to give up that
04:43:24 <ski> so one would need to check that there is not more than one solution, to make it sane
04:43:25 <ray> that's what i mean about the annoyances being because it's cutting-edge
04:43:46 <ray> seperate compilation has been around forever, for example
04:44:04 <Saizan> and?
04:44:40 <EvilMachine> Saizan: about my example not working: ah, ok, yes. because the re-packing function would need the original MyType too
04:44:53 <ski> (EvilMachine : sorry, i've become confused about why you're talking about minimum length)
04:45:28 <EvilMachine> ray: padding padding padding would restult in triggering the "lameness filter" ^^
04:45:30 <ski> EvilMachine : i like the lens primitive `a -> (b,b -> a)'
04:45:32 <ray> but you can write seperate instances anyway, it's just a minor annoyance like most things
04:46:00 <Saizan> EvilMachine: btw (MyType -> a) -> (a -> MyType -> MyType) is what an Accessor is, and that's why it works :)
04:46:28 <Saizan> EvilMachine: data-accessor-template automates the building of Accessor values for your fields
04:47:12 <Saizan> ski: why do you prefer that over the other formulation?
04:47:53 <Saizan> EvilMachine: ops, i meant (MyType -> a, a -> MyType -> MyType) there
04:49:03 <EvilMachine> sky: forget about the minimum lenght topic. ^^ i just came up with it, because a wise person once said, that the intelligence of a person is proportional to the lenght of its questions. :)
04:49:11 <ski> Saizan : often one is interested in replacing a part of a structure with something that depends on the old part. that formulation allows traversing down to the part once, instead of twice
04:49:37 * ski replaces the sky with himself
04:50:01 <EvilMachine> sky: no idea what the lens primitive would be good for.
04:50:17 <EvilMachine> Saizan: ah, ok.
04:50:18 <ski> (.. and recovering `get' and `set' from the lens is trivial)
04:51:10 <nlogax> hmmz, cabal install yi fails with this message: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11135#a11135
04:51:16 <nlogax> known problem? :)
04:52:02 <Saizan> nlogax: yeah, you need to --constraint= it to use an older version of data-accessor
04:52:23 <Saizan> ski: ah, i see, i was only thinking about flat products
04:52:38 <ski> EvilMachine : `(^:)' requires traversing twice, using `getVal' and `setVal' .. the corresponding operation based on the `a -> (b,b -> a)' primitive (for `Lens a b') would only traverse once
04:53:24 <EvilMachine> ski: i'm not interested in traversing anything of relevant depth anyway. :)
04:54:27 <ski> EvilMachine : assume you have `a -> Maybe (b,b -> a)' or `a -> [(b,b -> a)]' instead and are traversing some kind of trees .. :)
04:56:40 <EvilMachine> sky: I stil don't see, what a function of the type "a -> Maybe (b,b -> a) would actually do...
04:57:05 <EvilMachine> sky: or of the type "a -> (b,b -> a) would actually do...
04:57:19 <ski> it would attempt to traverse to a place in a structure, and report whether the place actually existed or not
04:57:28 <ski> well, consider
04:57:40 <EvilMachine> sky: by returning a function? ^^
04:57:50 <Saizan> e.g. \x -> (fA x, \f -> x { fA = f (fA x) })
04:57:58 <ski>   newtype Lens whole part = MkLens {runLens :: whole -> (part,part -> whole)}
04:58:13 <ski> then one can do an operation
04:58:33 * EvilMachine goes blind for a second, upon seeing "\\x -> (fA x, \\f -> x { fA = f (fA x) }"
04:58:45 <EvilMachine> meaningful identifiers, please! ^^
04:58:50 <Twey> What's scary about that?  :√æ
04:59:03 <Saizan> EvilMachine: fA was you field from above
04:59:03 <EvilMachine> Twey: meaningful identifiers, please! ^^
04:59:11 <ski>   nth :: Integral i => i -> Lens [a] a
04:59:19 <Saizan> EvilMachine: 'f' is standard for function, 'x' is standard for "some value"
04:59:56 <ski>   nth 0 = MkLens {runLens = \(a:as) -> (a,\a -> a:as)}
05:00:02 <Twey> \someArgument -> (oneFunction someArgument, \otherFunction -> someArgument { oneFunction = otherFunction (oneFunction someArgument) }
05:00:05 <Twey> ;)
05:00:10 <EvilMachine> bah. maththink. *shudders*. ^^
05:00:13 <Twey> )
05:01:00 <EvilMachine> let's say it's not exactly friendly to read‚Ä¶
05:01:22 <EvilMachine> whatever
05:01:23 <ski>   nth n = MkLens {runLens = \(a0:as) -> let (a,f) = runLens (n-1) as in (a,\a -> a0:f a)}
05:01:26 <EvilMachine> Twey: lol.
05:01:43 <Saizan> EvilMachine: you'll get used to it
05:01:48 <Twey> *nod*
05:02:00 <Twey> Often code is so general that there aren't really any meaningful identifiers to be had.
05:02:08 <ski> EvilMachine : so `nth n' returns a lens / accessor / functional reference that selects the `n'th element of any list
05:02:10 <Twey> Types are more informative than identifiers, in Haskell.
05:02:30 <EvilMachine> Saizan: that's like saying "you'll get used to the pain of that chainsaw in your leg" ^^
05:02:52 <Twey> EvilMachine: It's really not bad.
05:02:52 <ski> EvilMachine : however, any given list might not have an `n'th element, for any given `n' .. and we might want to capture that situation (at run-time)
05:03:00 <ski> so, one can generalize to
05:03:03 <Twey> Look at the types, not the identifiers.
05:03:10 <ski>   newtype Lens m whole part = MkLens {runLens :: whole -> m (part,part -> whole)}
05:03:18 <sinelaw> started reading Backus' paper (can programming languages be freed etc...) - is it important to go through all the details of his algebra?
05:03:23 <Twey> Haskell types tend to be a lot more informative than types in other languages.
05:03:23 <ski>   nth :: Integral i => i -> Lens Maybe [a] a
05:03:46 <ski>   nth 0 = MkLens {runLens = \as0 -> case as0 of [] -> Nothing ; (a:as) -> Just (a,\a -> a:as)}
05:03:50 <EvilMachine> ski: sorry, i can't keep up anymore. too much new stuff...
05:03:58 <sinelaw> and all the various systems he describes? (FP, FFP, AST, etc...)
05:04:26 <ski>   nth n = MkLens {runLens = \as0 -> case as0 of [] -> Nothing; (a0:as) -> do (a,f) <- runLens (n-1); Just (a,\a -> a0:f a)}
05:04:48 <ski> EvilMachine : you don't need to understand the details of the `nth' example to understand the point
05:05:52 <EvilMachine> sky: i stopped understanding anything at 12:57:58 ^^
05:05:54 <ski> EvilMachine : the idea is that we might want to represent the notion of the `n'th element of a list, but for any given list, that element might not exist. so we would like to be able to handle that case, instead of the program erroring out
05:06:04 <EvilMachine> ski: (local time i guess)
05:06:22 <ski> another example is the `last' element of a list
05:06:41 <EvilMachine> let's give up for now. ^^
05:06:50 <ski> ok, np
05:06:52 <EvilMachine> but thank you all anyway. :)
05:07:24 <Saizan> EvilMachine: it's actually very useful, haskell functions tend to be short, so they can fit in you brain "L1 cache" if the identifiers are short too, improving readability, this obviously applies only to local identifiers, not exported ones
05:07:33 <Twey> *nod*
05:08:56 <EvilMachine> Saizan: sorry but that is not how your brain works. a identifier takes one field, independent of its length. so short identifiers make for more dense code. which in itself is not bad. but when you don't know what the identifier is good for, you're lost. :)
05:09:36 <EvilMachine> Saizan: i bet, if you were here, i could prove that with a simple test.
05:09:54 <EvilMachine> or if i hat the will to think up such a test for irc. ^^
05:09:57 <EvilMachine> t=d
05:10:14 <Saizan> EvilMachine: how can the length not matter? you've to parse it
05:10:32 <FunctorSalad> EvilMachine: I doubt it's totally independent of length
05:10:35 <ski> if the only thing knowable about the identifier is that it is a function taking an argument of unknown type `a' and returning a value of unknown type `b', then `f',`function',`a_b' are equally good names, imo
05:10:37 <Saizan> i know that humans don't parse in the same way
05:10:58 <Saizan> but you still have more things to check if there are more characters
05:11:31 <EvilMachine> Saizan: ah, i know: try someone reading you a list of words. and you repeating them after he is finished. then he makes a list of new words, one word longer. until you aren't able to remember them all anymore.
05:11:58 <EvilMachine> Saizan: then try the same thing with single-digit numbers that do not form patterns.
05:12:06 <EvilMachine> Saizan: you will get the same results
05:12:19 <FunctorSalad> EvilMachine: the issue is not just remembering - shorter identifiers make the structure of the term stand out more
05:12:31 <EvilMachine> Saizan: same with images, sounds, etc. lenght really does not matter. we assign identifiers in our brain.
05:12:48 <Saizan> EvilMachine: that's different, you're not trying to recognize where a second occurrence of the same symbol came from, there
05:13:07 <ski> (the length of the typical identifiers might be negligible in this context)
05:13:23 <EvilMachine> ski: you are kinda right. still feels bad though. :)
05:14:04 <FunctorSalad> it's more about visual pattern matching I think
05:14:13 <FunctorSalad> which is easier with shorter ids
05:14:33 <Twey> EvilMachine: It's just instinct from other languages telling you it's bad.
05:14:37 <FunctorSalad> (we are talking about local ids, not exported)
05:14:40 <Saizan> it's one of the reasons pointfree style can be clearer
05:14:47 <Twey> In Haskell, it's fine, and you'll overcome those in time.  ‚ò∫
05:15:06 <Saizan> you care about the transformations, the identifiers are only there to express the route
05:15:18 <Saizan> if they don't get in the way it's better :)
05:15:28 <Twey> *nod*
05:15:47 <xenoblitz> hi people I am trying to make use of EclipseFP... but I can't obtain version 1.108 of it... any instructions from anyone who tried it here?
05:16:07 <ray> imagine if id were written as id parameterOfAnyTypeToBeReturned = parameterOfAnyTypeToBeReturned
05:16:48 <EvilMachine> we don't store the word or song or book in out "L1" cache. we store "thing with feeling X". kina a weak feeling. not how it‚Äôs spelled, not how it looks. that‚Äôs why "chocolate chip cookie ice cream" just is one storage field in our "L1". what we remember is e.g. that feeling of eating it.
05:17:48 <EvilMachine> Saizan: pointfree? clear? if you twist your mind like you twist the parameter "pipes" between the functions, then sure. ^^
05:18:13 <Saizan> EvilMachine: you should try it more seriously :)
05:18:14 <Twey> EvilMachine: Spoken like a true non-functional programmer :√æ
05:18:28 <Twey> Trust us ‚Äî you'll come to appreciate it
05:18:36 <Saizan> EvilMachine: and think more about functions than values
05:18:52 <Twey> (also, note the ‚Äòcan be‚Äô ‚Äî I don't think anybody would claim that it's *always* clearer)
05:19:49 <Saizan> it's a matter of tradeoffs
05:20:06 <EvilMachine> Twey: so. it's the same thing as with math actually. i hate it when i get some formula thrown in the face, without any explanation of the whys, hows, etc. ^^ math people love to do that. of course they know how people came up with that formula, and its history, usages, etc. but you don't. yet they expect you to know how to use it, and what it stands for. which is impossible without that prior knowledge that they have, but you d
05:20:20 <EvilMachine> oh oh. i think that is another cut line. right? ^^
05:20:26 <Saizan> right
05:20:28 <Twey> At ‚Äòbut you d‚Ä¶‚Äô
05:20:46 <Saizan> however the explanation of the formula doesn't have to be inside the identifiers
05:20:54 <EvilMachine> ray: mentioning the other, just as bad, extreme, does not make the first extreme better. ^^
05:20:54 <Twey> I recommend irssi's ‚Äòsplitlong‚Äô
05:20:56 <Saizan> that's quite different
05:23:09 <FunctorSalad> EvilMachine: I think the reason mathematicians don't write "Integral(multiply(independentVariable,independentVariable),independentVariable)" is not just habit or elitism.
05:23:16 * Twey chuckles.
05:23:18 <EvilMachine> Twey: well, i hope you were not trying to insult me with that "like a true functional programmer". because i am happy for you, if you began your career with functional languages. but us who had to make money in your average coding shop, weren't exactly that lucky. you should not insult the injured and crippled. ^^
05:23:39 <Twey> Not an insult ‚Äî just a statement
05:24:01 <Saizan> "should this code be easier to read for those who know nothing about the field, at the cost of being tedious and complex for those who have familiarity with it?" you can answer differently in different situations, though the familiarity can be acquired by reading comments or dev. commentaries etc..
05:24:08 <Twey> You might find it ugly now, but you'll get used to how we program in functional languages, and then you'll understand it
05:24:16 <Twey> And yes, my first language was Java.  :√æ
05:24:19 <EvilMachine> (rest of the line above:) ....but you don't. yet they expect you to know how to use it, and what it stands for. which is impossible without that prior knowledge that they have, but you don't
05:24:35 <FunctorSalad> that's a different story from identifiers
05:24:59 <Twey> Saizan: Well, the answer of ‚Äòyes‚Äô leads to COBOL, so‚Ä¶ :√æ
05:25:13 <aep> hm learnyouahaskel was pretty good, but it doesn't cover monads. any successing document i should read?
05:25:14 <FunctorSalad> btw often no matter of good explanation cuts it in math, it's more a matter of being used to the topic
05:25:24 <Twey> @where rwh
05:25:25 <lambdabot> is http://www.realworldhaskell.org/blog/
05:25:25 <FunctorSalad> s/matter/amount/
05:25:34 <Twey> aep: ^
05:25:37 <aep> thanks
05:25:50 <EvilMachine> Saizan: depends on who you speak to when you mention the function. ^^
05:25:52 <Saizan> Twey: i thought more about the fact that you can write differently in blogs/tutorials then what you do elsewhere, the audience matters
05:25:58 <Twey> (not technically a follow-up)
05:26:01 <Twey> Saizan: *nod*
05:26:17 <FunctorSalad> (you need the explanation *too* of course)
05:26:19 <Twey> So long as it's noted that that is the special case, not the other way around.
05:26:22 <dancor> FunctorSalad: mathematics is an inconsistent notational nightmare
05:26:34 <EvilMachine> Ferdirand: agreed about the different story. i guess it's not identifier length alone or per se.
05:26:38 <tumult> ok the FFI is easy, i got my mach kernel timing stuff working in less than an hour on my first try :)
05:27:04 <Saizan> EvilMachine: i concur, though normally code should be written for those which have the "sufficient" background, because they are those who will work more with it
05:27:09 <dancor> FunctorSalad: re: "Integral(..) .. habit or elitism."
05:27:19 <EvilMachine> aep: real world haskell is also available via the not so official channels, in case of money shortages. ^^
05:27:26 <Twey> ?
05:27:32 <Twey> RWH is available for free, online.
05:27:43 <Twey> Officially.
05:27:49 <dancor> it's more fun if you think you're pirating it
05:27:52 <Twey> Haha
05:27:56 <FunctorSalad> dancor: as I said, the advantage of ‚à´ x¬≤ dx is visual plasticity
05:27:59 <EvilMachine> Saizan: yes. the audience matters. that's what i wanted to say
05:28:03 <FunctorSalad> easier to manipulate etc
05:28:22 <skorpan> > () :: Double
05:28:23 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
05:28:23 <lambdabot>         against inferred ty...
05:28:27 <skorpan> > () :: Maybe Bool
05:28:28 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Bool.Bool'
05:28:28 <lambdabot>         again...
05:28:32 <FunctorSalad> you don't notice the structure with huge names
05:28:33 <EvilMachine> dancor: yeah. it's fun on the high seas. YARR. but why capturing ships, when you can simply copy it. :P
05:28:39 <aep> EvilMachine: aye, thanks
05:28:40 <dancor> FunctorSalad: ya but the implication languages-should-be-like-math should be aware of how awful math notation is compared to most compy notation in terms of consistency etc
05:29:10 <dancor> math has a long way to go there imho
05:29:44 <dancor> and i think a lot of the reason that math papers are such a mixed mess is elitist
05:29:47 <EvilMachine> FunctorSalad: good point about the structure. but nobody spoke of huge names. just about an *appropriate* size. and as we found out, that depends on the audience. :)
05:30:15 <ski> something like <http://www.funmath.be/> seems to have the basic right idea, anyway
05:30:27 <ManateeLazyCat> mmorrow: Recently, i try to refactory my code, i found it's really hard to refactory. Too close some modules.
05:30:30 <Saizan> EvilMachine: and saying that i mean that one should try to get the needed background so that we can all understand the more efficient notation, hopefully with help and resources from those in the field
05:30:44 <Twey> EvilMachine: It also depends on the values.
05:30:57 <ski> (i'm not sure whether the details of their notation is always that good)
05:31:01 <ski> ("Funmath is designed to make the idea of letting the symbols do the work feasible and convenient in everyday mathematical practice.")
05:31:04 <Twey> Rewriting ‚Äòx‚Äô as ‚ÄòsomeValue‚Äô and ‚Äòf‚Äô as ‚ÄòsomeFunction‚Äô doesn't make anything clearer, for anyone.
05:32:30 <ksf> rewriting "someValue" as "x" and "someFunction" as "f" doesn't make notation more or less mathy, too.
05:32:36 <FunctorSalad> a typical sunday morning on #haskell indeed =)
05:32:46 <ManateeLazyCat> mmorrow: If i don't use IORefObject, i got another problem, when occur "nested function", if just inner function need some `argument` and outer functions don't need that argument, i still need transform that argument to every functions.
05:33:41 <ksf> "more efficient notation" is utterly underspecified. more efficient to read, to write, on paper, or on a keyboard?
05:33:44 <EvilMachine> Saizan: yes. aquiring the needed background is obviously a good idea. but compare it to VI. it may be a nice editor, if you're fit in it. but who actually uses it so much for it to be actually worth the time of learning all those functions? the opposite is MS word.
05:33:48 * ski idly wonders what ManateeLazyCat is commenting on
05:34:09 <EvilMachine> Saizan: they both have the fundamental flaw of not offering any gradient that allows it to adapt to your preferred level of getting involved in it.
05:34:13 <ksf> typesetting a formula in tex hasn't a particularily fast edit-compile cycle.
05:34:38 <ksf> word is highly arcane, too.
05:34:49 <EvilMachine> FunctorSalad: lol
05:35:06 <EvilMachine> FunctorSalad: it's 13:35 here
05:35:09 * FunctorSalad throws in a discussion about `mappend` for good measure
05:35:19 <FunctorSalad> EvilMachine: uh artistic freedom
05:35:25 <FunctorSalad> (here too)
05:36:04 <EvilMachine> lol.
05:36:04 <ksf> there's a point to be made in favour of more symbols, but I'm not going to have positional syntax in my programs.
05:36:32 <ski> ksf : what do you mean by "positional syntax" ?
05:36:40 <ManateeLazyCat> mmorrow: I like your `unit := Foo + Foo.Types + Foo.*', in my understand, Foo.Types will contains all Type define and constructors of Foo.*, and `Foo` will contain all functions that need interactive, Foo.* just keep functions for current module, but this module is not handy when have many interactive function in unit, break module abstraction.
05:36:43 <FunctorSalad> why does that funmath.be page copy the character salad from the html version of "Practical Foundations of Mathematics"?
05:36:48 <ksf> ...I'd rather be editing 3d syntax graphs.
05:36:57 <FunctorSalad> (seems to be a bad start for good notation ;))
05:37:04 <ksf> something like having the range under a sigma.
05:37:21 <ksf> all that 2d-layout.
05:37:24 <FunctorSalad> (I mean actual encoding failure, not "bad notation")
05:37:34 <ManateeLazyCat> mmorrow: Are you there?
05:38:46 <EvilMachine> we should, just for fun, create a module ArtisticFreedom in haskell, that allows you to write "stuff" by letting you go with your "flow". you could write things like "main = uum, stuff. n' like, colors. yeah, blue! and add a "5" plus a box of scews to that." and the module would figure out what you could have meant. (of course usually coming up with something very absurd = artsy.) ^^
05:38:52 <ManateeLazyCat> ski: I'm talking about design for my project.
05:39:21 <EvilMachine> (oh. end, in case it got cut off again:)  and the module would figure out what you could have meant. (of course usually coming up with something very absurd = artsy.) ^^
05:40:46 <ski> preflex: seen mmorrow
05:40:46 <preflex>  mmorrow was last seen on #haskell 9 hours, 8 minutes and 45 seconds ago, saying: ddarius: which usually takes about 10 years or so after they've figured it out..
05:42:16 <ski> ManateeLazyCat : might i take a glance at an example of such nested functions exhibiting the problem ?
05:43:05 <ski> (ideally compared with using "IORefObject")
05:43:11 <ManateeLazyCat> ski: If you like, i will send you source code of my project (6000 lines), but my problem have a little complicate. :)
05:44:03 <ManateeLazyCat> ski: I use IORefObject (central control module) transform most modules in my project, and IORefObject with those module reference each other.
05:44:18 * ski was assuming there was an example of what ManateeLazyCat meant that was not much longer than 60 lines
05:44:29 <ManateeLazyCat> ski: I will occur "recursive reference problem (.hs-boot file)" problem when my project is bigger.
05:44:32 <en0th> ksf: i've come up with this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4475#a4475 (regarding arrays)
05:44:46 <ski> oh, mutually recursive modules
05:45:07 <ManateeLazyCat> ski:  6000 lines, not 60 lines.
05:45:16 <Twey> module Me where import Me
05:46:46 <ski> ManateeLazyCat : yes. hence "example" instead of "all of the code"
05:47:43 <ski> Twey : `module Me (module Me) where import Me' ?
05:47:50 <Twey> Heh
05:47:57 <Twey> That might actually be valid.
05:48:05 <Twey> Me.Me.Me.Me.Me.Me‚Ä¶
05:48:16 <ski> how do we determine which identifiers are exported ?
05:48:54 * ManateeLazyCat pasted "IORefObject.hs" at http://paste2.org/get/483742
05:48:55 <ManateeLazyCat> ski: Above.
05:48:55 <ManateeLazyCat> ski: I know which my problem, and i'm thinking a better solution to fix my problem.
05:49:17 <ManateeLazyCat> ski: Looks module that have '{-# source #-}', those modules with IORefObject reference each other.
05:49:33 <ski> (that would export from the defined module (`Me') all the identifiers exported from the imported module (`Me'), and not just make the identifiers from that imported module in scope in the body of the current module)
05:50:53 <ksf> en0th, looks... specialized.
05:51:04 <ski> ManateeLazyCat : it sounded like you had some problems with nested functions. where in the pasted code should i look for those ?
05:51:30 <ksf> did you have a look at dph? it uses a more list-like programming model, and you get parallel speedups for free
05:51:58 <ManateeLazyCat> ski: Forgot it, my problem is really complicated than you can fix, i think about myself. Thanks! :)
05:52:03 <en0th> ksf: let me look at it!
05:52:22 <ksf> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
05:53:03 <ksf> there's also a spj presentation: http://www.londonhug.net/2007/09/25/nested-data-parallelism-video-returns/
05:54:04 <en0th> so i would put data parallelism in normalizeEl, for example
05:54:20 <en0th> ehm sorry, maybe in gMap
05:59:43 <ksf> the obvious solution to any recursive dependency problem is to put everything into one module.
06:00:48 <Twey> Oh, of course.
06:00:51 <Twey> :√æ
06:01:54 <FunctorSalad> screw trying to get the haskell parsers to accept unicode-containing haskell. I'm implementing kind polymorphism with Text.Regex now :>
06:03:29 <ksf> can we have NFunctors over type classes, so that I can just apply liftAN to all of those functions in one line?
06:03:49 <ManateeLazyCat> ksf: That solution just for little project, if in big project, you will break module abstract, and hard to maintain.
06:04:12 <ksf> ...well the point was that you _can_ do it.
06:04:28 <ksf> ...you most certainly won't have to collapse all modules into one to fix stuff
06:04:47 <en0th> @quote
06:04:48 <lambdabot> cowardlydragon says: [from a reddit comment thread] Don't get me started on monad. What is that, a man with a single testicle?
06:04:53 <ksf> ...and after merging three or four, maybe a non-recursive module hierarchy surfaces.
06:04:59 <ManateeLazyCat> ksf: If you project will have 100000 lines code?
06:05:27 <ski> FunctorSalad : implementing kind polymorphism as a haskell extension ?
06:05:31 <ksf> don't tell me you've got a recursive dependency that connects _all_ of them
06:05:54 <FunctorSalad> ski: I was being a bit tongue-in-cheek... "polymorphism" as in duplicate the code at higher kinds ;)
06:05:58 <FunctorSalad> but at least automatically
06:06:17 <ski> example ?
06:06:24 <ManateeLazyCat> ksf: I think i have bad design on some part when i start build project.
06:07:00 <FunctorSalad> ski: "data Foo (a :: (* -> *)) where blah" ----> "data Foo2 (a :: ((* -> *) -> *)) where blah"
06:07:02 <ManateeLazyCat> ksf: Now, not all module, but have some modules are so close, and recursive each other.
06:07:11 <ksf> factoring out chunks of modules into speratate packages might help, too.
06:07:30 <ski> FunctorSalad : where `blah' is ? :)
06:07:52 <FunctorSalad> ski: anything; the kind should propagate from the kind sig in the head
06:08:01 <ManateeLazyCat> ksf: Problem is i use central module transform those split modules, and those split module reference central module.
06:08:17 <ManateeLazyCat> ski: It's point my got a bad design.
06:08:23 <ManateeLazyCat> ski: Sorry, is ksf
06:08:42 <FunctorSalad> ski: one example would be functors vs. higher order functors
06:08:50 <ski> FunctorSalad : if you want things like `newtype Flip (f :: k0 -> k1 -> *) (a1 :: k1) (a0 :: k0) = MkFlip {unFlip :: f a0 a1}', then that's kind polymorphism ;)
06:09:18 <FunctorSalad> ski: yes exactly
06:09:30 <ManateeLazyCat> ksf: I think add some `unit := Foo.Manager + Foo.Types + Foo.*` layout to avoid recursive problem.
06:09:35 <FunctorSalad> I'm "implementing" it by search-and-replacing the k0/k1 ;)
06:09:50 <FunctorSalad> and making duplicate modules
06:09:56 <ksf> Foo.Types is always a good idea.
06:10:13 <ski> (FunctorSalad : or maybe even `newtype k (Flip (f :: k0 -> k1 -> k2) (a1 :: k1) (a0 :: k0) :: k2) = MkFlip {unFlip :: k (f a0 a1)}' .. ;)
06:10:26 <FunctorSalad> ski: was going to use haskell-src-exts but it chokes on unicode (which happens to be in my file)
06:10:51 * ksf wants adt morphisms.
06:11:00 <ManateeLazyCat> ksf: Foo.Manager control interactive functions, Foo.Types control Type define and constructors, Foo.* is standlone module that don't know each other.
06:11:06 <FunctorSalad> (so times for regexes ;))
06:11:09 <FunctorSalad> *time
06:11:09 <ksf> ...call it subtyping, if you want, I dont' care.
06:11:31 <ManateeLazyCat> ksf: So every Foo.* module just can communication through Foo.Manager.
06:11:44 <ski> (that would give you `MkFlip :: foralk_kind k0 k1 k2. forall (k :: k2 -> *) (f :: k0 -> k1 -> k2) (a0 :: k0) (a1 :: k1). k (f a0 a1) -> k (Flip f a1 a0)' e.g.)
06:11:54 <ski> (s/foralk/forall/)
06:12:04 <ManateeLazyCat> ksf: `unit := Foo.Manager + Foo.Types + Foo.*` model avoid recursive problem completely.
06:12:31 <ivanm> is there a nice way of having the haddock docs of one module link to something in another module that isn't used in the first module without having GHC complain about a useless import?
06:13:12 <ManateeLazyCat> ivanm: Maybe you can see gtk2hs how to do that. :)
06:13:19 <ksf> you don't have to import to do links in comments.
06:13:20 <FunctorSalad> "<ski> (FunctorSalad : or maybe even `newtype k " <-- what is the 'k' doing there?
06:13:26 <ksf> ...at least afair.
06:13:31 <ivanm> ManateeLazyCat: wtf does gtk2hs have to do with it?
06:13:46 <ksf> if in doubt, use import Foo.Bar()
06:13:47 <ivanm> ksf: ummm, if I don't import a constructor at least, I can't link to it
06:13:56 <ski> FunctorSalad : that's to get kind `k0 -> k1 -> k2' for `f', instead of only `k0 -> k1 -> *'
06:13:58 <ivanm> I tried that, no link if it isn't imported :s
06:14:11 <ManateeLazyCat> ivanm: gtk2hs use haddock generate docs, and it's have many module, so it maybe have answer for your problem.
06:14:16 <FunctorSalad> ski: ah right, thought it was a kindvar too
06:14:20 <ivanm> .... right ...
06:15:26 <Saizan> ivanm: that sounds like a bug in haddock
06:15:36 <ski> FunctorSalad : so (eliding the kind ascriptions), we have `newtype k (Flip f a1 a0) = MkFlip (k (f a0 a1))'
06:15:41 <ivanm> Saizan: *nod*
06:15:56 <ski> the kind of the argument (as well as result) type of `MkFlip' must be `*', but this way that doesn't constrain the `f' argument
06:16:01 <ivanm> Saizan: possibly because of using ghc for parsing?
06:16:18 <ski> this seems to entail interesting operational semantics
06:16:27 <Saizan> ivanm: no, the comments are still parsed by haddock code
06:16:39 <ksf> ...you guys are reminding me of a thing I wanted to start for a long time, now.
06:16:52 <Saizan> ivanm: though without an import it's not always clear where a symbol should come from.
06:17:06 <ksf> ...eclipse comes with a wonderful documentation system, it spawns a local http server.
06:17:27 <ivanm> Saizan: *nod*
06:17:49 <ivanm> Saizan: so is it really a bug, or an unfortunate necessity/requirement?
06:17:51 * ksf cabal install happstack
06:18:02 <ManateeLazyCat> ksf: Have you know any better solution than `unit := Foo.Manager + Foo.Types + Foo.*` when current GHC can't fix .hs-boot file problem.
06:18:02 <ManateeLazyCat> ivanm: Sorry, emacs crash.
06:18:03 <ManateeLazyCat> ivanm: I missing something?
06:18:14 <ivanm> ManateeLazyCat: not really
06:18:31 <ksf> ...at least not without having a close look at the code, no.
06:18:57 <ManateeLazyCat> ksf: Do you have time review my code?
06:19:12 <ksf> but my backup plan for such situations looks like this: shove everything into one module, work on it, sleep over it and wait for inspiration.
06:19:16 <ski> e.g. `case MkFlip [(2,3)] of [foo] -> maybe (error "foo") (uncurry (*)) (unFlip (Just foo))' will return `6'
06:19:20 <ski> FunctorSalad : ^
06:19:52 <Saizan> ivanm: well, if you can come up with a strategy for resolving names in comments without adding imports.. :),  you should ask that to the devels i guess
06:19:57 <ManateeLazyCat> ksf: Wait for inspiration? :)
06:20:00 <FunctorSalad> ski: atm I'm just doing a simple search & replace :)
06:20:37 <ksf> yes. aka nown as "pray to eris and hope she doesn't happen to have bad hair day"
06:20:58 <ManateeLazyCat> ksf: Can you give me your email address? I send you source code.
06:21:00 <ivanm> Saizan: see, you probably couldn't even reliably do it even for unknown symbols from other modules in the given project/codebase, since you might have two modules with the same entities (e.g. Win32 and Unix FilePath modules)
06:21:03 <nlogax> Saizan: thanks, got yi working :)
06:21:05 <tumult> uh oh, i think i have run into my first incomprehension of laziness
06:21:07 <ivanm> so I'm not sure if it is possible to fix it...
06:21:17 <ksf> sometimes, doing something entirely different is the best way to solve a problem.
06:21:28 <tumult> i'm doing forkIO to write to a serial device and it doesn't actually do anything until some unspecified time later
06:21:46 <ManateeLazyCat> ksf: Not always have perfect way to fix problem.
06:21:50 <ksf> ManateeLazyCat, I don't think I'm going to be able to come up with a much better solution
06:22:47 <ksf> make it work, then make it beatiful.
06:22:56 <ManateeLazyCat> ksf: If GHC don't need .hs-boot file, i can continue even some module reference each other, but with current situation, i must rewrite some module with `unit := Foo.Manager + Foo.types + Foo.*` model.
06:23:10 <ManateeLazyCat> ksf: Now it works fine, just design is beautiful somewhere.
06:23:30 <FunctorSalad> ski: luckily ghc has a flag for running preprocessors so at least one won't have to manage the duplicates manually....
06:23:37 <Saizan> ivanm: one could add an import statement for haddock
06:23:42 <ManateeLazyCat> ksf: Is not beautiful somewhere
06:23:45 <Saizan> ivanm: i.e. that works only for comments
06:24:29 <FunctorSalad> a "clone" module could look like: {-# OPTIONS -pgmF kindpoly #-} clone MyModule with k0=* -> *
06:24:36 <ivanm> Saizan: hmmm... there are haddock-style {-# #-} statements...
06:24:52 <FunctorSalad> MyModule would be a haskell module containing comments like {-k0-}
06:25:22 <FunctorSalad> (where the kindvars should go)
06:25:34 <ski> FunctorSalad : oh, so you let whole modules be parametric in a kind ?
06:25:51 <ManateeLazyCat> Saizan: Can you help review my code? Maybe you give me better suggestions about my design, i will refactory my code make design more beautiful, but i want listen people suggestions before i do it. I don't want redesign again.
06:25:53 <FunctorSalad> ski: seems simplest that way
06:26:52 <kamatsu> i want to write a gadget for google wave, and because it's all web-based the whole thing has to be in JS.
06:27:13 <skorpan> i think there's a javascript backend for some haskell compiler
06:27:18 <Twey> Yhc has one
06:27:23 <tumult> it's very slow i believe
06:27:23 <kamatsu> yeah
06:27:24 <ksf> yhc
06:27:25 <skorpan> http://www.haskell.org/haskellwiki/Yhc/Javascript
06:27:29 <kamatsu> but i can't get yhc to compile
06:27:34 <kamatsu> let alone ycr2js
06:27:40 <kamatsu> and it's not been maintained in a few years
06:28:00 <tumult> kamatsu: i know about just every thing->javascript compiler/interpreter since i have to write javascript frequently and hate it
06:28:23 <tumult> if you don't mind scheme, scheme2js works well and lets you write mostly-functional code
06:28:27 <skorpan> javascript isn't that bad :o
06:28:35 <skorpan> javascript is functional
06:28:36 <kamatsu> hmm, mostly i want strong typing, though
06:28:46 <tumult> kamatsu: then try ocamljs, my second choice
06:28:49 <ksf> javascript isn't that bad by itself.
06:29:01 <tumult> it gets very difficult to manage large programs due to type coercion
06:29:09 <tumult> also you cannot program functionally due to the brutal slowness
06:29:23 <kamatsu> yeah, plus having to type out function () { } can get tedious
06:29:38 <tumult> no tail optimization and also out-of-scope variable references have performance hits
06:29:52 <tumult> out-of-scope meaning in parent scope of current function
06:30:05 <tumult> though v8 and the other new tracing engines mitigate it somewhat
06:30:11 <Jafet> Which implementation are you talking about?
06:30:20 <skorpan> kamatsu: "function (x) x * 2" is valid js 1.8
06:30:33 <tumult> js 1.8 doesn't exist outside of firefox
06:30:43 <Jafet> Oh god, that's worse than python
06:30:56 <skorpan> ...
06:30:59 <skorpan> i'm leaving
06:31:40 <kamatsu> ocaml appears to have substantially more limited types than haskell though =(
06:31:45 <kamatsu> also it looks a bit uglier
06:31:52 <tumult> ocamljs works well if you don't mind an overhead on function application when the number of arguments can't be determined during compilation
06:31:56 <kamatsu> i don't know ocaml though, so others are welcome to correct me.
06:32:11 <tumult> i think most of the time you just use the normal ML stuff in ocaml
06:32:21 <tumult> in my limited experience i don't see the OO stuff get used much
06:32:37 <kamatsu> right, but it doesn't have things like type classes, from what i've heard
06:32:47 <tumult> i would say it's not as good as haskell, yes
06:32:55 <tumult> but it's better than writing plain javascript :)
06:33:12 <tumult> you will want something that lets you mutate easily though
06:33:26 <kamatsu> YHC just had a JS monad
06:33:26 <Jafet> Actually, there is a lisp to javascript compiler...
06:33:30 <kamatsu> that worked like the IO monad
06:33:31 <tumult> since JS without mutating frequently is very slow, there's no lightweight consing and stuff
06:33:33 <kamatsu> Jafet: yeah, no typing.
06:33:34 <tumult> yeah there is parenscript
06:33:59 <tumult> there are a couple of other monadic writers and stuff for JS i've seen in haskell
06:34:03 <tumult> one has some limited typing actually
06:34:09 <tumult> it was put up just a few days ago
06:34:27 <tumult> if you want typeclasses and inference in javascript, you could also try haXe but it has c-like syntax
06:35:53 <Jafet> So from what I gather, no one wants to actually write javascript, but they love producing it
06:36:02 <tumult> well, if you want to run code in a browser
06:36:08 <tumult> you don't have much of a choice :)
06:36:21 <Jafet> Warhol would be ecstatic!
06:38:12 <Twey> I quite like writing JS.
06:38:19 <Twey> Beats some languages I could name.
06:38:26 <Twey> I'd replace it with Lua if I could, though.
06:38:33 <tumult> kamatsu: http://hackage.haskell.org/package/jmacro
06:38:36 <tumult> there it is
06:39:14 <kamatsu> hm
06:39:15 <tumult> javascript is ok until you get above a certain complexity level
06:39:16 <kamatsu> what is it?
06:39:37 <tumult> you write haskell code that generates chunks of javascript
06:39:47 <tumult> you can enable some limited typechecking
06:39:50 <snhmib> does haskell (or ghc) have something like weak references?
06:39:50 <kamatsu> hmm
06:40:13 <tumult> i would still recommend ocamljs, scheme2js, or haXe if you want something more mature
06:40:28 <tumult> there's also biwascheme if you want it to interpret in the browser itself
06:41:00 <kamatsu> haxe looks okay
06:41:09 <Jafet> "It's all fun and games until IE6"
06:41:17 <dancor> google chrome frame
06:41:19 <tumult> those all work in IE6 :)
06:41:37 <kamatsu> it doesn't matter, i don't need IE6
06:41:47 <kamatsu> i'm writing for Wave which requires chrome frame anyway for ie users
06:42:08 * dancor wins the moot suggestion war
06:42:11 <tumult> ah yeah
06:42:20 <Jafet> IE6 will probably run out of stack or something if you put that on a real site, prompting another useless secunia advisory
06:42:27 <snhmib> oh they call it a weak pointer, cool nvm
06:42:47 <tumult> scheme2js does trampolining and other tail-call-elimination stuff
06:42:55 <kamatsu> that is nice
06:42:56 <tumult> so do haXe and ocamljs i believe
06:43:19 <kamatsu> hmm, seeing as I want typing, i guess my options are haXe and ocamljs
06:44:35 <kamatsu> still, anyone that maintains a js backend for ghc would have my eternal gratitude ^^
06:44:45 <tumult> there is one, but it's not maintained
06:44:55 <Jafet> Heh
06:44:56 <tumult> http://vir.mskhug.ru/
06:45:01 <kamatsu> yeah, i saw that
06:45:07 <kamatsu> couldn't even figure out how to check it out
06:45:22 <kamatsu> i can browse the code but how do i even download it?
06:45:27 <kamatsu> grr
06:45:28 <tumult> no clue
06:45:37 <tumult> i think it's brutally slow, like the yhc javascript backend
06:46:03 <kamatsu> i guess i'll learn ocaml, and if it drives me insane I'll use haXe
06:46:15 <tumult> if you know haskell ML should be very easy i think
06:46:22 <tumult> though i'm not so good at haskell yet :)
06:46:38 <kamatsu> it looks like a more haphazard version of haskell
06:46:44 <kamatsu> without a bunch of cool features
06:47:11 <Jafet> ML is hard, because half the time you'll be fuming over why it does not have X
06:47:26 <kamatsu> the lack of type classes mean it has separate operators for all the different numeric types
06:47:29 <kamatsu> eewwww
06:47:34 <burp> wtf?
06:47:41 <kamatsu> (or so i hear)
06:48:09 <Saizan> don't they have some magic for that instead?
06:48:15 * Saizan doesn't know
06:48:26 <tumult> modules
06:48:47 <kamatsu> + - * are for ints, +. -. *. are for floats
06:48:47 <Taejo> ISTR + vs .+
06:48:47 <kamatsu> oh, .+ not +.
06:48:47 <tumult> not exactly the same i think, but i'm not very experience there
06:48:47 <kamatsu> oops
06:48:48 <Taejo> they have magic for equality, though, AFAIR
06:48:58 <Taejo> kamatsu: I wouldn't remember
06:49:11 <kamatsu> i don't know either
06:49:23 <kamatsu> it just seems like it would be an infuriating experience to go from haskell to ocaml
06:49:34 <kamatsu> perhaps even more infuriating than just ditching the type system altogether and going to straight js
06:49:58 <tumult> you will claw your eyes out if you think haskell->ocaml is painful :)
06:50:09 <tumult> due to JS' insidious type coercion
06:50:37 <Jafet> ===!
06:50:38 <Saizan> kamatsu: just don't come back and write modules like this http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.2/doc/html/Algebra-Vector.html , please
06:50:42 <Jafet> Wait, that's PHP
06:50:43 <tumult> http://emgio.com/wow.png
06:50:46 <tumult> my favorite
06:51:04 <tumult> no JS has === too
06:51:22 <tumult> but it means different things depending on what the types end up being on either side
06:51:38 <fxr> @pl fst $ partition (\x -> 0 == (mod x n)) [1..]
06:51:39 <lambdabot> fst (partition ((0 ==) . flip mod n) [1..])
06:52:25 <kamatsu> Saizan: hah
06:53:11 <Jafet> Ah yes, it's non-commutative. One of those delightful things
06:54:23 <fxr> anyone using a KV store?
06:55:13 <tumult> i'm also a fan of "typeof(null)" -> "object"
06:55:20 <kamatsu> well
06:55:22 <kamatsu> that's not so bad
06:55:30 <kamatsu> object refers to a reference type, like a void*
06:56:11 <kamatsu> seeing as all reference types are implicitly maybe types, then typeof(null) should be Maybe a or object in js terms
06:56:44 <kamatsu> (a fresh)
06:57:33 <tumult> the problem is that most things return "undefined"
06:57:43 <tumult> and "typeof(undefined)" -> "undefined"
06:58:02 <kamatsu> okay, so it's confusing, but it's not semantically ambiguous
06:58:15 <kamatsu> undefined is something that hasn't been defined yet, null is specifically a null pointer.
06:58:19 <tumult> "null + 1" -> "1" :P
06:58:22 <kamatsu> the need to have both is sort of questionable though
06:58:25 <tumult> yes it is ambiguous
06:58:47 <tumult> it's a mistake in the specification
06:58:56 <tumult> it was put in my accident i think
06:59:00 <tumult> er by accident
06:59:07 <kamatsu> null vs undefined, you mean?
06:59:08 <Jafet> .oO( Which specification? )
06:59:13 <tumult> null being an object
06:59:19 <kamatsu> null is an object
06:59:24 <tumult> Jafet: good question :)
06:59:40 <kamatsu> that makes perfect sense according to most type semantics you'd see about js
06:59:44 <Jafet> Another question being, what specification
07:00:18 <Twey> 13:51:58 < tumult> http://emgio.com/wow.png
07:00:33 <Twey> tumult: Objects are string-indexed; "{}" === "{}"
07:00:38 <tumult> yep
07:00:46 <tumult> implicit coercion, silent
07:00:49 <Twey> Yeah
07:00:53 <Twey> One more thing Lua does better
07:00:54 <mattwynne> I have a pretty basic question I think. Can anyone take a look at this and tell me what's going on? http://gist.github.com/218070
07:01:00 <tumult> yes lua is better in every way
07:01:07 <Twey> *nod*
07:01:08 <mattwynne> "Ambiguous type variable `a' in the constraints"
07:02:07 <kamatsu> looking now
07:02:25 <Twey> mattwynne: What's the type of ‚Äòaffinities‚Äô?
07:02:27 <kamatsu> what is the type of affinities?
07:02:29 <kamatsu> yeah
07:02:41 <mattwynne> affinities aha. I haven't defined it yet
07:02:44 <mattwynne> that's the problem, eh?
07:02:47 <Twey> That would be it
07:02:48 <kamatsu> affinities = undefined
07:02:55 <kamatsu> should do the trick
07:02:55 <Twey> Give affinities a type
07:03:02 <Twey> No, he's done that
07:03:08 <kamatsu> oh, then provide a type sig
07:03:11 <Twey> You need to add a type signature for affinities
07:03:13 <Twey> *nod*
07:03:18 <EvilTerran> kamatsu, that alone would bring down the wrath of the dreaded monomorphism restriction
07:03:28 <kamatsu> EvilTerran: ah crap, not again
07:03:32 <Twey> Heh
07:03:37 <EvilTerran> hence the need for the type sig =/
07:03:38 <stalker> hi, is anybody familiar with opengl binding for haskell?
07:03:46 <kamatsu> stalker: vaguely, what's up?
07:03:56 <stalker> i am trying to compile Monadius but I get strange errors
07:04:09 <kamatsu> wouldn't know
07:04:14 <stalker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11136#a11136
07:04:23 <mattwynne> thanks guys, sorted! :)
07:04:29 <kamatsu> mattwynne: no worries =D
07:05:09 <tumult> ok so i am trying to forkIO a thread that writes to a posix handle
07:05:21 <tumult> but i don't really comprehend laziness i think, since it doesn't actually do stuff when i think it will
07:05:27 <stalker> ghc is complaining about Double not being instance of VertexComponent etc classes
07:05:44 <stalker> but documentation says Double should be instance ...
07:05:52 <Twey> tumult: More likely in this instance, you don't really comprehend GHC threads.
07:06:01 <kamatsu> indeed!
07:06:05 <tumult> i see
07:06:46 <Twey> tumult: Probably, both threads are running in the same OS thread, and one of them isn't yielding.
07:06:51 <tumult> well, i would like some kind of parallel process to run after a user takes an action. during its normal computation (it should work until told to stop) it doesn't return any results to the main thread
07:06:55 <tumult> ah
07:07:08 <kamatsu> enlightenment dawns?
07:07:11 <ksf> I can't pass -package options in a OPTIONS pragma?
07:07:29 <tumult> i am using gtk2hs which has its own runloop
07:07:42 <tumult> which probably doesn't have a yield in it for the forkIO threads?
07:07:52 <kamatsu> that sounds right
07:09:56 <stalker> on the other hand if I import the package in ghci a runs :info on VertexComponent I get: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11138#a11138
07:10:04 <stalker> there are instances for some strange types
07:10:21 <stalker> GLint, GLshort etc ...
07:10:34 <tumult> i guess i need a different kind of thread then?
07:11:31 <tumult> i don't think i ever want this process to run in the same OS thread as the GUi anyway
07:11:46 <tumult> er, GUI. due to the strict timing requirements it has.
07:13:44 <Twey> Maybe forkOS would be appropriate.
07:14:08 <tumult> does that fork a literal OS thread?
07:14:14 <tumult> that wasn't clear to me in the documentation
07:14:28 <Twey> Yes
07:15:22 <tumult> radical :)
07:20:18 <tumult> cool that works (after switching to -threaded and changing how gtk2hs is initialized)
07:21:09 <tumult> though apparently now i can crash it if i ever make a gtk call from another thread
07:23:26 <Saizan> stalker: since the last release the OpenGL package has decided to use newtypes of Double etc.. for its own types, to get more type safety
07:25:34 <Twey> tumult: Yeah ‚Äî don't do that.
07:25:46 <Twey> IIRC, GTK isn't thread-safe.
07:25:50 <tumult> yeah, it's not
07:26:02 <tumult> is there a way to do something with the type system to make sure i can't do that
07:26:14 <Twey> No
07:26:17 <kamatsu> hey, what do people think about CAL?
07:26:18 <tumult> since the gtk stuff is in the IO monad but so is my posix writing stuff
07:26:25 <tumult> hm damn
07:26:41 <Twey> Just don't pass any channels between your threads, or throw any asynchronous exceptions
07:26:51 <stalker> Saizan: so Double is no longer instance of MatrixComponent,VertexComponent etc??
07:30:13 <Saizan> stalker: yeah
07:30:55 <mattwynne> is there a function that will return the unique set of pairs in a list?
07:31:13 <stalker> Saizan: thanks for the right direction, for the latest opengl the docs match :info input ...
07:31:14 <mattwynne> e.g. [1,2,3] -> [(1,2), (1,3), (2,3)]
07:31:38 <Axman6> nub . join (liftM2 (,))?
07:31:46 <Axman6> not quite
07:31:53 <stalker> but my packaging system claims i have opengl-2.2.1.1 ...
07:32:21 <Saizan> > let xs = [1,2,3] in [(a,b) | (a,bs) <- tails xs, b <- bs ]
07:32:22 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(a, b)'
07:32:22 <stalker> is there a way to find which version of package is used?
07:32:22 <Axman6> > nubBy (\(x,y) -> x == y) . nub . join (liftM2 (,)) $ [1,2,3]
07:32:23 <lambdabot>   Couldn't match expected type `(t, t) -> GHC.Bool.Bool'
07:32:23 <lambdabot>         against infe...
07:32:28 <Saizan> > let xs = [1,2,3] in [(a,b) | (a:bs) <- tails xs, b <- bs ]
07:32:29 <lambdabot>   [(1,2),(1,3),(2,3)]
07:33:57 <Saizan> stalker: you mean "ghc-pkg list" ?
07:34:59 <sohum> > tails [1,2,3]
07:35:00 <lambdabot>   [[1,2,3],[2,3],[3],[]]
07:35:48 <EvilTerran> > [(x,xs) | x:xs <- tails [1,2,3]] -- note the magic of pattern-matching in comprehensions
07:35:49 <lambdabot>   [(1,[2,3]),(2,[3]),(3,[])]
07:35:56 <kohwj> just curious- is the haskell type system turing complete?
07:36:07 <EvilTerran> kohwj, not the haskell98 type system
07:36:17 <EvilTerran> kohwj, but it becomes so with -XUndecidableInstances
07:36:28 <BONUS> hey EvilTerran did you get the message?
07:36:35 <EvilTerran> huh?
07:36:55 <EvilTerran> oh hey, PMs
07:36:55 <BONUS> ya :D
07:37:29 <sohum> EvilTerran: it becomes turing-complete with undecidables?
07:37:43 <kohwj> mmm thanks
07:37:44 <EvilTerran> sohum, i believe so, yes
07:38:51 <stalker> Saizan: thanks that is it - seems that cabal installed opengl 2.4.0.1 hid portage installed opengl 2.2.1.1 ...
07:38:52 <sohum> EvilTerran: huh. would the haskell type system work better if you imported instances like you import functions?
07:39:23 <sohum> EvilTerran: for a definition of "work better" that incorporates both some sort of notional elegance and power
07:40:04 <EvilTerran> sohum, the semantics of instances could get incredibly muddy
07:40:27 <sohum> EvilTerran: because then you would be able to push the responsibility for lack of undecidability onto the module writer
07:40:29 <Saizan> stalker: you can use -package opengl-2.2.1.1 in ghci to pick that version, or use "ghc-pkg hide"
07:41:15 <EvilTerran> sohum, if you call a function where one instance of a class is in scope from a function where another instance is in scope, which instance do you use?
07:41:21 <mattwynne> > foo
07:41:22 <lambdabot>   Not in scope: `foo'
07:41:33 <mattwynne> lambdabot you are cool
07:42:47 <Axman6> sohum: http://www.haskell.org/pipermail/haskell/2006-September/018486.html
07:42:49 <sohum> EvilTerran: I guess you'd resolve those at compile time. so, assuming the former fn is in a separate module, compiled separately, it would use the defn in its scope
07:44:43 <EvilTerran> sohum, that sounds semantically weird in a similar way to -XIncoherentInstances
07:44:58 <sohum> EvilTerran: what's interesting is it means you could call foo typeclassFn, where foo is compiled in the scope of a separate instance of typeclassFn, and foo would then have access to both instances
07:45:06 <mmorrow> type classes are passed dynamically though (when they aren't statically resolved due to non-polymorphism)
07:45:15 <Axman6> also, sohum, why aren't you asleep?
07:45:22 <sohum> Axman6: why aren't you?
07:45:25 <sohum> :P
07:45:33 <sohum> Axman6: and that link is awesome; thanks
07:45:33 <Axman6> had a mother a few hours ago >_<
07:45:38 <mmorrow> *type class _functions_ that is
07:45:42 <Axman6> no worries
07:46:38 <PeakerWork> mmorrow: what do you mean by "non-polymorphism"?
07:47:01 <sohum> mmorrow: is that an efficiency thing on the part of the compiler?
07:47:31 <Axman6> sohum: welcome to the crazy world of Oleg btw. he does some crazy shit that most people don't understand, but still find amazing
07:47:59 <sohum> Axman6: hehehehe
07:48:37 <Axman6> sohum: he's the one behind HList, which is a heterogeneous list type
07:48:42 <mmorrow> PeakerWork: the only time a dictionary isn't passed is when you have e.g.
07:48:51 <mmorrow> foo :: Int -> Int; foo n = n + 1
07:49:02 <mmorrow> foo :: (Num a) => a -> a; ... becomes
07:49:17 <PeakerWork> mmorrow: you mean if a function is used only in one way?
07:49:24 <mmorrow> foo (DNum (+) ......) n = n + 1
07:49:34 <mmorrow> PeakerWork: if the type isn't polymorphic
07:49:44 <mmorrow> otherwise it needs to get the dictionary passed to it
07:49:47 <sohum> Axman6: by hetereogenous list you mean something like Typeable a => [a]?
07:49:55 <PeakerWork> mmorrow: or code to be duplicated (ala C++ templates)
07:50:01 <Axman6> i think so, i've never looked into them
07:50:20 <mmorrow> PeakerWork: right, if it's a smallish function it'll get inline and specialized that way
07:50:20 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
07:52:58 <sohum> Axman6: oh, apparently not. the paper abstract says it's strongly typed...
07:53:00 <Baughn> I'm happy to announce version 2.5 of haskell-mode for emacs, now downloadable from http://projects.haskell.org/haskellmode-emacs/. It's been a while, eh?
07:53:03 * sohum reads
07:53:18 * sohum correction: reads later; sleeps now
07:53:27 <Nafai> Baughn: Yay!
07:53:27 <Axman6> good plan
07:53:42 <sohum> Baughn: awesome! now how long til it gets into debian? ;)
07:54:08 <Baughn> sohum: Eheh. Well, I suppose I'll have to inform the various distributions of a change of upstream maintainer first, etc.
07:54:36 <sohum> oh, you're not the original maintainer?
07:54:44 <Baughn> Nope
07:54:47 <sohum> thanks for picking it up, then.
07:54:47 <Nafai> Baughn: Awesome to have someone actively working on it now
07:54:55 <sohum> ^Nafai
07:55:01 <Twey> Nice, Baughn!
07:56:02 <Baughn> Oh, and it's in darcs now. You won't be able to update it from your old cvs clone.
07:56:24 * Nafai just did a darcs get :)
08:06:17 <fxr> hmm what does not exists is a haskell object store
08:07:25 <Baughn> fxr: Binary comes pretty close, but I imagine you mean something you can query, SQL-style
08:07:26 <fxr> which should have optimized operations on objects which stored on slow media.
08:08:09 <hackagebot> hashed-storage 0.4.1 - Hashed file storage support code. (PetrRockai)
08:10:43 <mattwynne> one more for you peeps if you have the patience: how do I count the number of times an element is found in a list?
08:10:47 <fxr> this shouldn't be implemented as a database, one can write a standardizable specification draft that explains how to achieve such a goal for a web application
08:11:07 <Botje> mattwynne: with a plain recursive function
08:11:11 <aavogt> mattwynne: use filter and then length
08:11:14 <Botje> or you could use a fold
08:11:16 <mattwynne> e.g. foo (1, [1,2,3,4,1]) -> 2
08:11:26 <fxr> mattwynne: give each letter a prime number
08:11:36 <GetRidOfHer> foo (1, [1,2,3,4,1]) -> 2
08:11:45 <mattwynne> so filter to extract the elements that match, then the length of the filtered list
08:11:54 <mattwynne> right?
08:12:09 <aavogt> exactly
08:12:27 <fxr> mattwynne: you'll find p1^n * p2^n .. where solution is max n
08:13:09 <mattwynne> fxr I have no idea what you are talking about :)
08:13:12 <fxr> otherwise fold
08:13:51 <fxr> mattwynne: I'm trying to be fast
08:14:20 <mattwynne> fxr I'm a total haskell noob - I'd prefer comprehensible over performant right now!
08:14:34 <fxr> mattwynne: okay
08:15:01 <GetRidOfHer> can someone do smth with a list comprehension..what could I use it for
08:15:02 <fxr> mattwynne: so why haskell?3
08:15:26 <mattwynne> fxr it's fun
08:15:33 <mattwynne> fxr never learned a functional language before
08:15:35 <fxr> mattwynne: yes it is :)
08:15:43 <mattwynne> fxr it's my favourite that I've come across
08:18:29 <shepheb> GetRidOfHer: [(x,y,z) | z <- [5..], y <- [1..z], x <- [1..y], z^2 == x^2 + y^2 ]
08:20:54 <br1> why do (>>>) and (>>=) associate differently?
08:23:25 <sticazzi> hello! I'm struggling a bit with IO types... I'm returning an "IO Int" and I can't "show" it: No instance for (Show (IO Int))
08:23:34 <sticazzi> How can I fix this?
08:23:52 <Baughn> sticazzi: An IO Int isn't an integer; it's a program that, when executed, somehow produces an integer
08:24:22 <Baughn> sticazzi: You need to execute it. Typically, you'd use syntax such as "do foo <- thingThatReturnsIOInt; return (show foo)" or so
08:24:36 <Axman6> sticazzi: main = do {int <- myIntFunction; print int }
08:24:41 <Baughn> (Which could be conveniently contracted to "show <$> thingThatReturnsIOInt", but that's a story for another day)
08:24:43 <sticazzi> ahh! no.. gotcha
08:26:07 <sticazzi> haskell is easy to learn so long as you stick to the purely functional bits.. get's harder when you try to do anything procedural.. and I don't want to go down that route till I get the basics solid first.
08:26:10 <sticazzi> thanks for the tip
08:26:41 <Badger> @src (<$>)
08:26:42 <lambdabot> f <$> a = fmap f a
08:27:09 <Badger> :t (<$>)
08:27:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:27:48 <Badger> Baughn: wouldn't that make show . iointfunc valid
08:27:58 <Baughn> Badger: No, . is not fmap
08:28:04 <Baughn> ..well, except in here
08:28:08 <Badger> oh, right
08:28:12 <Badger> damn you lambdabot!
08:28:28 <Baughn> > show . (readLine :: IO Int)
08:28:29 <lambdabot>   Not in scope: `readLine'
08:28:37 <Baughn> > show . (readLn :: IO Int)
08:28:38 <lambdabot>   <IO [Char]>
08:32:49 <fxr> thank you hackagebot
08:35:13 <dancor> hackagebot: help
08:42:51 <mattwynne> thanks for your help folks. I was working on a kata which I've now finished: http://github.com/mattwynne/kata-haskell-cities/tree/master/src/
08:43:01 <mattwynne> I'd love to hear any comments!
08:49:13 * ski thought `kata' was the name of edwardk's language
08:53:24 <ski> mattwynne : is there a reason `user' is not used in `cityPairs' ?
08:54:45 <ski> also, you do know that `String' is the same as `[Char]', right ?
08:58:23 <ski> why does `frequencyOf' always return a singleton list ?
09:00:19 <Philippa> ski: I believe 'code kata' came first, though
09:01:04 <ski> it might well. (i have not heard of that before, though)
09:01:40 <mattwynne> ski re 'user' in cityPairs - it's not needed for the function, I guess the convention would be to call the parameter '_' instead, right?
09:02:07 <ski> or possibly even to not pass the parameter at all
09:02:15 <mattwynne> yeah right
09:02:47 <mattwynne> user is actually just a bit of a distraction, really
09:03:05 <mattwynne> re String and [Char] didn't realise! but it makes sense.
09:03:29 <Axman6> @src String
09:03:29 <lambdabot> type String = [Char]
09:03:59 <mattwynne> ski re frequencyOf - I actually have no idea how that is working!
09:04:12 <mattwynne> programming by coincidence, as they say
09:04:21 <mattwynne> but the tests pass so I think it must be working
09:04:29 <ski> it returns `[length (..blah..)]' which is always a list with a single element
09:05:20 <anonee> hello
09:05:45 <ski> if you just want to return a single frequency, i think it makes more sense (and would be simpler) to just return that, instead of putting it as the single element of a list that is returned
09:05:59 <aep> hey, can somone help me with this example code?  i can't figure out where the second argument is from, since in the type declaration there is only one: http://codepad.org/5nitbMHy
09:06:10 <ski> btw, did you mean to use `AffinityScore' instead of `Int' in the return type, there ?
09:06:51 <tommd> I don't understand the join-'hello'-leave process some people go though.
09:07:00 <tommd> But I suppose that's OT.
09:07:06 <anonee> got booted
09:07:29 <anonee> anyone know if that blackberry widget sdk can interact with blackberry messenger?
09:07:41 <tommd> Well welcome and feel free to discuss Haskell.  OT comments, like mine, generally belong in #haskell-blah.
09:07:52 <mattwynne> ski I did indeed mean to use AffinityScore, yes
09:08:06 <mattwynne> surprised the compiler didn't comlain about that
09:08:40 <jkff> Hi. Does anyone know in which version of ghc did GADTs appear?
09:08:42 <tommd> Perhaps 6.4?
09:08:44 <tommd> Not sure
09:09:09 <ski> mattwynne : the compiler knows that `FrequencyScore' and `Int' is the same type, so it doesn't complain
09:09:10 <mattwynne> ski re frequencyOf, the list comprehension at the top seemed to complain when I didn't return a list
09:09:16 <jkff> tommd: Thanks, will check
09:09:27 <jkff> tommd: You were right, thanks!
09:09:34 <tommd> np
09:09:52 <ski> mattwynne : if you want it to complain, use `newtype' (or maybe `data' in some cases). then it will complain everywhere you try to "convert" without using constructor or deconstructor
09:10:23 <ski> mattwynne : yes, so use `let score = frequencyOf (pair, allPairs)' instead of `score <- frequencyOf (pair, allPairs)', there
09:11:00 <mattwynne> ski so is the former like defining a function inline?
09:11:06 <mattwynne> (let)
09:11:14 <tommd> Anyone working on a PNG parser?  I could use a decent speed PNG parser and have no desire to cook my own.  Also, pngload confuses me.  How is it each coordinate in the Image is represented by a Word8?
09:11:32 <Twey> Almost as fun as copying 44G over 3G
09:11:51 <Twey> tommd: stb-image?
09:11:59 <ski> aep : `bind' is a function that takes one argument (a function, here), and returns a result that in this case is actually a function, when that function is applied, it will recieve the next argument (`(gx,gs)'), and return what is after the `='
09:13:03 <aep> not that i have any idea what that means, but thanks
09:13:04 <tommd> Twey: Yeah, I saw that and guess it's my best bet.  I was just hopeful for a higher level construct than Ptr.
09:13:20 <ski> mattwynne : in a list comprehension, `foo <- bar' is for selecting each element in `bar' as `foo'; while `let foo = bar' is for naming `bar' with the name (or pattern) `foo' .. in this case `bar' can be anything, it need not be a list
09:13:31 <aep> ski: means the left hand side of = isnt arguments at all?
09:13:45 <ski> aep : in types `X -> Y -> Z' is the same as `X -> (Y -> Z)'
09:14:04 <ski> aep : in expressions, `foo bar baz' is the same as `(foo bar) baz'
09:14:10 <ski> so if you write
09:14:17 <ski>   bind myF myPair
09:14:22 <ski> that is the same as
09:14:27 <ski>   (bind myF) myPair
09:14:34 <ski> so, since
09:14:41 <aep> yes, but those are clearly two outer paranteses in the type definition. so i cant see why it would expand to 3, no matter how you define it
09:14:49 <ski>   bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
09:15:20 <ski> which "are clearly two outer paranteses in the type definition" ?
09:15:43 <aep> argument:  (Float -> (Float,String))      return:  ((Float,String) -> (Float,String))
09:16:02 <Jafet> aep, yeah, that's correct
09:16:02 <aep> i cant see 2 arguments here, no matter how hard i try
09:16:19 <Jafet> Haskell functions take zero or one argument.
09:16:26 <ski> mattwynne : it may help to note that in a list comprehension, `foo <- [bar]' has the same effect as `let foo = bar'
09:16:30 <aep> no matter what the type declaration sais?
09:16:51 <Twey> When they take zero, we call them ‚Äòvalues‚Äô ‚ò∫
09:16:54 <ski> (to be pedantic, Haskell functions always take exactly one argument)
09:17:01 <aep> so basicly the type declaration can be arbitary expanded? oO
09:17:08 <Jafet> aep, see currying
09:17:10 <aep> thats horrible.
09:17:39 <ski> aep : so `bind' is a function that takes an argument of type `Float -> (Float,String)' and returns a result of type `(Float,String) -> (Float,String)'
09:17:39 <aep> i know currying.  (so i think), but that doesnt define you can arbitary add arguments despite you defined the type completely different
09:17:42 <ski> so
09:17:48 <ski>   bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
09:17:50 <ski> now, assuming
09:17:51 <phaul> hi all, I have a problem with quickCheck: http://haskell.pastebin.com/d60b00627
09:17:56 <ski>   myF :: Float -> (Float,String)
09:17:58 <ski> we have
09:18:05 <ski>   bind myF :: (Float,String) -> (Float,String)
09:18:09 <aep> ski: but the second line of my post showed two arguments
09:18:12 <ski> aep : ok with that ?
09:18:16 <ski> (so far)
09:18:17 <phaul> seemingly it fails on True, don't really get why
09:18:35 <aep> ski: no. just more confused
09:18:50 <ski> let's take a step back
09:18:52 <Twey> aep: a -> (b -> c) is the same as a -> b -> c.
09:18:56 <ski> assume
09:19:04 <ski>   f :: X -> Y
09:19:07 <ski>   x :: X
09:19:13 <ski> what type does
09:19:14 <ski>   f x
09:19:16 <ski> have ?
09:19:32 <aep> err, no idea. i didnt know  f.x  and f x are the same thing
09:19:40 <Twey> A function of type a -> b -> c takes one argument of type a, and yields a function that takes one argument of type b, and yields a c
09:19:40 <ski> (they are not)
09:19:47 <aep> i thought f x would stick  x into f as argument
09:19:50 <ski> yes
09:19:54 <aep> so the type doesnt change at all
09:20:08 <Jafet> What is the type of the expression (f x)?
09:20:18 <aep> propably Y
09:20:20 <ski> yes
09:20:25 <ski> e.g.
09:20:27 <ski> @type ord
09:20:29 <lambdabot> Char -> Int
09:20:34 <ski> @type 'c'
09:20:36 <lambdabot> Char
09:20:40 <ski> @type ord 'c'
09:20:42 <lambdabot> Int
09:20:48 <aep> yeah that makes perfect sense
09:20:49 <ski> so, in your case
09:20:54 <ski>   bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
09:20:55 <Jafet> I hope this is not what cat theorists mean when they say arrow chasing
09:20:59 <ski>   myF :: Float -> (Float,String)
09:21:21 <ski> Jafet : no, this is just type-inference-in-head (or on irc, as the case may be)
09:21:23 <aep> then bind myF  should be ((Float,String) -> (Float,String))
09:21:28 <ski> yes
09:21:33 <aep> but it isnt
09:21:37 <ski> yes it is
09:21:38 <Twey> It is
09:21:51 <aep> ok great, so how does that example add two arguments then? :D
09:21:53 <ski> now, assume
09:21:57 <ski> actually
09:21:59 <fxr> oh in hashed-storage, Pack format not implemented yet
09:22:04 <Jafet> ((Float, String) -> (Float, String)) is a function.
09:22:14 <fxr> hmm
09:22:16 <Jafet> bind takes a function and returns a function.
09:22:21 <ski> first, the outer brackets in `((Float,String) -> (Float,String))' is superfluous, so let's skip them
09:22:25 <ski> so
09:22:30 <ski>   bind myF :: (Float,String) -> (Float,String)
09:22:42 <ski> so, assume now
09:22:43 <aep> yes i agree
09:22:48 <ski>   myPair :: (Float,String)
09:22:51 <ski> what is the type of
09:22:57 <ski>   (bind myF) myPair
09:22:58 <ski> ?
09:23:07 <aep>  (Float,String)
09:23:10 <ski> yes
09:23:19 <ski>   (bind myF) myPair :: (Float,String)
09:23:39 <aep> ok. i could follow so far
09:23:45 <ski> and the brackets in the expression there are also superfluous, since function application (the " ") is left-associative
09:23:48 <ski> so that is simply
09:23:52 <ski>   bind myF myPair :: (Float,String)
09:23:56 <ski> so what
09:24:04 <ski>   bind myF myPair = ..myF..myPair..
09:24:29 <aep> err are you saying the second argument is the argument to the combined function?
09:24:42 <mattwynne> ski thanks a lot for the feedback - still sinking in! :)
09:24:43 <ski> is doing is to say what we would return if `bind' is first applied on one argument, and then the resulting function from that is applied (directly or later) to another argument
09:25:22 <ski> so, you could in your code say `let myFunction = bind myF in ...'
09:25:58 <ski> then, some time later in `...' you could decide to say `myFunction myPair', and that would then evaluate the body of `bind' which was after the `='
09:26:24 <aep> oof. my brain explodes at that point
09:26:32 <aep> i'll go get reading a bit more i guess
09:26:36 <Twey> (+) :: Int -> Int -> Int; (+) :: Int -> (Int -> Int); (+) :: (Int -> (Int -> Int))
09:26:53 <phaul> guys, it's only a 4 liner and I'm sure the answer is obvious, could someone take a quick look? http://haskell.pastebin.com/d60b00627
09:26:56 <ski> .. that's sometimes useful. but often you just call `bind myF myPair' directly
09:27:27 <aep> yes thats all  fairly ok. i just can't figure out how to read the left hand side of an equpition, if it isn't the same as the actual type
09:28:09 <ski> aep : so, technically, when you write `bind myF myPair', first `bind' is called with `myF', and that immediately returns a new function that is waiting for the next argument, and that function is immediately applied to `myPair', and then the body of the function is returned
09:28:25 <Axman6> phaul: why do you need the from integral?
09:28:36 <phaul> overflow
09:28:55 <phaul> wwithout it #
09:28:55 <phaul> #
09:28:55 <ski> aep : though, usually we abbreviate that as : `bind' takes two arguments (curriedly)
09:28:58 <aep> ski: yes, of course. but thats a function definition, and there arent concete types
09:29:06 <Botje> eval: (2^31)::Int
09:29:17 <ski> aep : what's a function definition ?
09:29:23 <Botje> > (2^31)::Int
09:29:24 <lambdabot>   2147483648
09:29:39 <aep> ski: oh sorry. comming from the C world... i mean the type .
09:30:03 <phaul> ghci says this is False (2 ^ 31 `mod` 3) == modPow 2 31 3
09:30:27 <aep> ski: and whatever you call it when you say  "a x =  3*x" doesn't match the type of a in what i posted
09:30:50 <ski> aep : i don't see any variable `a' in what you posted
09:31:08 <aep> ski: of course i understand that _calling_ the function  like "a 2 3" makes sense (if a would return a function), but my problem is the definition
09:31:17 <aep> ski: that was another example, sorry.
09:31:40 <aep> let me try to express my problem in code..
09:31:45 <opqdonut> aep: you just define "let a x y = 3*x+y" or whatever
09:31:50 <kippetje> I am trying to give a lambda function type information, but it keeps rejecting it, how should I do this. Here is a simple example map (\y::Int -> y) [1,2,3,4]
09:31:58 <ski> if it helps, this is another (equivalent) way of defining your `bind'
09:31:59 <opqdonut> if it‰s the syntax you're worrying about
09:31:59 <ski>   bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
09:32:13 <ski>   bind f' = \(gx,gs) -> let (fx,fs) = f' gx in (fx,gs++fs)
09:32:58 <ski> aep : here you see that `bind' accepts one argument, and returns a function (`\(gx,gs) -> ...')
09:33:14 <opqdonut> kippetje: that needed a ghc extension, can't recall the name
09:33:26 <opqdonut> LocalTypeDecls or something
09:33:32 <aep> ski: http://codepad.org/NMEs0pBm
09:33:43 <kippetje> let me google that
09:33:44 <ski> @type \n -> "abc" ++ replicate n 'x' ++ "def"
09:33:46 <lambdabot> Int -> [Char]
09:33:50 <ski> that's a function
09:33:58 <ski> > (\n -> "abc" ++ replicate n 'x' ++ "def") 3
09:33:59 <lambdabot>   "abcxxxdef"
09:34:00 <aep> ski: yeah your example makes more sense to me
09:34:08 <ski> > let f = \n -> "abc" ++ replicate n 'x' ++ "def"  in  f 3
09:34:10 <lambdabot>   "abcxxxdef"
09:34:18 <ski> > let f n = "abc" ++ replicate n 'x' ++ "def"  in  f 3
09:34:19 <Codex_> aep: your line 10 is wrong.
09:34:20 <lambdabot>   "abcxxxdef"
09:34:40 <aep> Codex_: i know!  i have no idea what that extra argument does.
09:34:51 <ski> aep : fwiw, here's yet another definition of `bind'
09:34:52 <aep> but the extra argument is used in the code i posted previously
09:34:55 <ski>   bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
09:35:04 <ski>   bind = \f' -> \(gx,gs) -> let (fx,fs) = f' gx in (fx,gs++fs)
09:35:39 <ski> line 5 is also wrong
09:35:47 <aep> oh is it?
09:35:56 <ski> (maybe you meant the expression `a (a 3)' ?)
09:36:05 <aep> yes.  thats not the same?
09:36:08 <ski> no
09:36:13 <aep> outch
09:36:16 <ski> `a a 3' is the same as `(a a) 3'
09:36:37 <aep> oh so that is left aligned..  man this is so confusing
09:36:47 <ski> (it's still wrong to put an expression on the "top-level", though .. you have to give it a name, at least)
09:37:11 <aep> yeah didnt know how t make a minimal example otherwise
09:37:32 <ski> that `a a 3' is the same as `(a a) 3' is really the same point as that
09:37:38 <ski>   bind myF myPair
09:37:41 <ski> is the same as
09:37:47 <ski>   (bind myF) myPair
09:38:07 <ski> or that
09:38:15 <ski>   bind f' (gx,gs) = ...
09:38:18 <ski> is the same as
09:38:21 <ski>   (bind f') (gx,gs) = ...
09:38:31 <aep> crazy
09:38:51 <ski> in all these cases do the space there signify function application
09:39:03 <aep> so since you apparantly can add arbitary arguments on both sides, why is my line 10 wrong?
09:39:08 <ski> and function application is an ("invisible") operator that associates to the lefty
09:39:15 <ski> s/y//
09:39:26 <aep> "lefty" sounded cute :P
09:39:36 <FunctorSalad> can type operators start with any other char than the colon?
09:39:39 <Codex_> aep: it should be b :: Int -> Int -> Int
09:39:55 <ski> aep : because `b x y  =  ...' says that the type of `b' must be of the form `X -> Y -> Z'
09:39:57 <aep> Codex_: yes, but thats exactly my point
09:40:10 <ski> (colloquially : "it must take two arguments")
09:40:13 <Jafet> aep, so you posted invalid code
09:40:24 * aep pulls hair
09:41:04 <aep> http://codepad.org/VzceCYXm
09:41:29 <Jafet> Because Int cannot be applied as a function.
09:41:41 <aep> aaaah
09:41:49 <ski> the `bind' case is ok, since the type is like `(...) -> ((...) -> (...))'
09:41:49 <Jafet> b x is declared to be an Int, so b x y is invalid.
09:42:01 <Jafet> bind f' produces a function, so it can be curried.
09:42:06 <aep> now it makes a LOT more sense
09:43:00 <aep> so this would be valid? http://codepad.org/97FcqiAH
09:43:11 <aep> (although i hve no clue what it does)
09:43:28 <ski> yes, that's ok
09:43:33 <aep> crazy
09:43:38 <aep> and what does it do?
09:43:51 <ski> @let aep_b :: Int -> (Int -> Int); aep_b x y  =  3 * x * y
09:43:51 <aep> its supposed to return a function, but it wont
09:43:53 <lambdabot>  Defined.
09:44:02 <ski> @type aep_b 5
09:44:03 <lambdabot> Int -> Int
09:44:13 <ski> @type (aep_b 5) 4
09:44:15 <lambdabot> Int
09:44:17 <ski> > (aep_b 5) 4
09:44:18 <lambdabot>   60
09:44:23 <ski> > aep_b 5 4
09:44:24 <lambdabot>   60
09:44:52 <aep> wait, i have an enlightment.   i can remove the paranteses and its a function with two arguments
09:45:08 * aep facedesks
09:45:11 <ski> so `aep_b' is a function, `aep_b 5' is still a function, but `(aep_b 5) 4' (which is the same as `aep_b 5 4') is an `Int'
09:45:41 <Jafet> > aep_b $ 5 $ 4
09:45:41 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Types.Int))
09:45:42 <lambdabot>    arising from the lite...
09:45:51 <Jafet> Huh, wrong associativity
09:45:54 <aep> wow this was hard. now i'm going to try reading that bind example again oO
09:46:00 <aep> thanks ALOT ski
09:47:12 <ski> aep : in C, this could be written as `(aep_b(5))(4)' (except that you can't define first-class functions which capture variables in local scopes in C)
09:48:04 * ski refrains from attempting to write the prototype of `aep_b' in C
09:48:35 <aep> yes, i know. i think i just need to reread about currying
09:48:44 <mattwynne> ski thanks a lot for the feedback - still sinking in! :)
09:48:52 <mattwynne> argh wrong window
09:48:54 <mattwynne> !
09:48:58 <aep> it was not imidiatly obvious to me that you can expand the argument by using its return
09:49:07 <mattwynne> actually I have a question
09:49:15 <ski> mattwynne : maybe you meant to say that you want more elaboration or scrutination ?
09:49:30 <mattwynne> why does this function give me the non-exhaustive patterns error:
09:49:33 <mattwynne> parse :: [(User, [City])] -> [[City]]
09:49:33 <mattwynne> parse [inputRow] = [snd inputRow]
09:49:50 <tommd> try: parse []
09:50:10 <ski> aep : a function is curried if, when given an argument, it returns another function (which might be curried as well)
09:50:42 <aep> ski: yeah :)
09:50:58 <`core> i dont think  "scrutination" is a word
09:51:14 <tommd> @google define scrutination
09:51:14 <ski> so mattwynne's `cityPairs :: (User, [City]) -> [CityPair]' is not curried, but if it had been `cityPairs :: User -> [City] -> [CityPair]' instead, then it would have been curried
09:51:15 <lambdabot> http://www.thefreedictionary.com/scrutinization
09:51:15 <lambdabot> Title: scrutinization - definition of scrutinization by the Free Online Dictionary, The ...
09:51:32 <ski> `core : ty
09:51:53 <`core> :)
09:52:37 <mattwynne> tomd parse[] doesn't fix it. any other suggestions?
09:53:14 <ski> mattwynne : if that is the only defining equation for `parse', then it is because you're not handling the empty list case, as well as the case with a list with more than one element
09:53:14 <mattwynne> tommd parse[] doesn't fix it. any other suggestions?
09:53:21 <tommd> mattwynne: No, that was your problem.  What do you want your function to do when someone feeds it a null?
09:53:42 <ski> s/null/empty list/
09:53:44 <benmachine> it's basically just giving a name to an expression
09:53:48 <tommd> mattwynne: perhaps you want: parse = map snd   ??
09:53:51 <benmachine> oh hey
09:53:55 <benmachine> I was scrolled up by half an hour
09:53:55 <mattwynne> I still get the same warning with this:
09:53:56 <benmachine> ignore me
09:53:57 <mattwynne> parse :: [(User, [City])] -> [[City]]
09:53:58 <mattwynne> parse [] = []
09:53:59 <mattwynne> parse [inputRow] = [snd inputRow]
09:54:17 <mattwynne> tommd that's exactly what I want :D thanks
09:54:19 <ski> mattwynne : because you still don't handle thw two-element case, the three-element case, et.c
09:54:22 <tommd> mattwynne: And what about when you have more than 1 element?
09:54:57 * ski idly wonders why this is called `parse'
09:55:11 <tommd> mattwynne:
09:55:11 <tommd> parse [] = []
09:55:11 <tommd> parse (i:is) = [snd i]   -- do you want this?
09:55:11 <tommd> or
09:55:11 <tommd> parse (inputRow:_ = [snd inputRow]  -- or this perhaps?
09:55:38 <tommd> ok, cool - I didn't see that response before typing all the above out.
09:56:19 <mattwynne> thanks guys - the lightbulb above my head is glimmering...
09:56:27 <mattwynne> not exactly on yet, but getting there
09:56:59 <phaul> still don't understand, how could quickCheck fail on something like prop_ <vars> = <precond> ==> True
09:57:27 <Jafet> ski, typedef int(*fnp)(int); int mul(int n) { static int s = 0; int t = s; s = n; return t * s; } fnp aep_b(int n) { mul(n); return &mul; }
09:57:32 <tommd> phaul: You have an example?
09:57:35 * Jafet runs away
09:57:53 <tommd> phaul: It can fail to generate enough examples that meet the precondition.
09:58:01 <phaul> tommd: url again : http://haskell.pastebin.com/d60b00627
09:58:10 <ski> Jafet : ty (i could probably have figured it out if i tried .. but i wanted to avoid that ! :)
09:58:33 <tommd> hummm... slow site
09:58:44 <_Ray_> Question. If I'm being passed a 'ts' which is of type [(a, b)], when I pattern match ((x,y):(ts)), x is an a, and y is a b, right?
09:59:10 <roconnor> _Ray_: yes
09:59:19 <_Ray_> thanks
09:59:24 <kmc> typically we'd omit the parens in (ts)
09:59:51 <sticazzi> what's a good guide for _using_ IO monads?
09:59:56 <kmc> > let ((x,y):ts) = [('a', 3), ('b', 4)] in (x,y,ts)
09:59:57 <lambdabot>   ('a',3,[('b',4)])
10:00:00 <roconnor> @src: lookup
10:00:01 <lambdabot> lookup _key []          =  Nothing
10:00:01 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
10:00:01 <lambdabot>                         | otherwise = lookup key xys
10:00:21 <kmc> sticazzi, the System.IO documentation
10:01:59 <kmc> sticazzi, what are you trying to do?
10:02:36 <sticazzi> gahh.. laptop battery about to die
10:02:41 <sticazzi> ..thanks anyways
10:04:01 <chaosape> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11141#a11141 - I don't understand why it needs to deduce Num or Fractional.  I am not using methods from those type classes.
10:04:12 <ski> Jafet : "#include <stdio.h>\n\nint main(void) {\n  fnp f = aep_b(3);\n  fnp g = aep_b(30);\n  printf(\"3 * 4 = %d\\\n\",(*f)(4));\n  printf(\"30 * 40 = %d\\\n\",(*g)(40));\n  return 0;\n}\n"
10:04:46 <kmc> chaosape, the literals?
10:04:49 <kmc> :t 1.0
10:04:51 <lambdabot> forall t. (Fractional t) => t
10:05:59 <chaosape> kmc: hmm ... i was under the impression that type class constraints were only checked when one was trying to use a method from the type class.
10:06:16 <kmc> where does it want a constraint?
10:07:01 <chaosape> kmc: i am possibly very confused ... ;^)
10:07:06 * Jafet claps
10:07:12 <kmc> what's the error message
10:08:13 <_Ray_> Hrmph. I'm getting an indentation error, but everything seems right. Are there any usual suspects for this? Anything else that's triggering the error
10:08:13 <chaosape> kmc: ghc wants to see Num and Fractional in the Something field contexts.
10:08:16 <_Ray_> *?
10:08:28 <kmc> _Ray_, hpaste your code
10:08:41 <_Ray_> It's going to be in Spanish :s
10:08:54 <kmc> that's okay
10:09:34 * ski bows
10:09:40 <kmc> chaosape, are you trying to make an existential type?
10:10:32 <_Ray_> Well, I'll paste the function where the error is in - the code is pretty large otherwise (I mean, this function uses types defined elsewhere, but I doubt that's the cause of the error, since the other files compile well). Code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11142
10:11:45 <kmc> chaosape, constraints on data constructors in H98 are weird.  you may have better luck with a GADT declaration for Something
10:12:18 <kmc> see GHC manual 7.4.5
10:12:46 <_Ray_> Ohh...I put a == instead of a =
10:12:50 * _Ray_ hides head in shame.
10:12:55 <chaosape> kmc: oh okay! so you are saying that even though I am not using anything from the Num or Fractional type class ... the data constructor for those values are pushing the constraint?
10:13:00 <_Ray_> Sorry!
10:13:19 <kmc> i'm not really sure
10:14:24 <lantti> Hmm... Suppose yoi should be able to put operators both infix and postfiy at the same time for Real Spanish Haskell :)
10:14:39 <lantti> -typos
10:15:47 <HairyDude> is it possible to tell ghc to do most of the -O optimizations but not inlining? (does this even make sense?)
10:16:06 <kmc> HairyDude, there are pragmas for controlling inlining on a per-binding basis
10:16:17 <kmc> be advised that inlining is really essential for good performance of haskell programs
10:16:26 <tommd> {-# NOINLINE hairyDude #-}
10:16:43 <kmc> and that the main point of inlining is not to save the cost of the call itself but to enable further optimization
10:16:56 <HairyDude> ah, right
10:17:26 <kmc> chaosape, simplified with the same error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11143#a11143
10:17:41 <kmc> Something is definitely an existential type
10:17:55 <kmc> let's try to write it as a GADT
10:18:21 <tuukkah> damn, is anyone able to compile with ghc to static binaries?
10:18:29 <HairyDude> inlining makes profiling difficult, but turning it off makes the program ++slow
10:18:38 <kmc> data Something t where Something :: forall a b. (Show a, Show b) => a -> b -> Something t
10:19:28 <chaosape> kmc: thanks! i will give that a whirl.
10:20:01 <kmc> chaosape, are you familiar with existential types?
10:20:05 <HairyDude> I have a function that profiling says accounts for 88% of allocation, even without -O, but all it does is call another function
10:20:35 <kmc> thus allocating a thunk for that call?
10:22:16 <HairyDude> hm
10:22:56 <kmc> i am not a performance expert so i will give the only advice i have which is "add more strictness"
10:23:13 <ski> kmc : using `data Something t = forall a b. (Reportable (Something t) a b,Show a,Show b) => Something { getA :: a, getB :: b }', it doesn't appear i can recover that `a' and `b' are `Int' when `t' is `TA', when matching on a value of type `Something TA'
10:23:36 <ski> (even though we have the FD `Reportable a b c | a -> b c')
10:24:00 <ski> (and the relevant instances are visible)
10:24:15 <HairyDude> I have been adding bangs in a rather undirected fashion, mostly it has no observable effect
10:24:51 <chaosape> kmc: enough to use them and sometimes be successful
10:25:19 <Twey> 17:17:32 < kmc> be advised that inlining is really essential for good performance of haskell programs
10:25:28 <Twey> s/really/rarely/, I hope you meant :√æ
10:39:23 <ben_m> I wish |> was in Prelude (stolen from F# ... |> = flip ($))
10:39:55 <tuukkah> whew, finally figured it out. -optl-lpthread puts the option in the wrong place on the linker command line, so need to use -optl-pthread instead! small but important difference, it seems
10:40:28 <Twey> ben_m: Eww
10:40:31 <Twey> :√æ
10:43:10 <Vanadium> ben_m: Call it ‚Ç¨
10:43:10 <Vanadium> :]
10:44:03 <Axman6> zomg! cylon fighter!
10:44:07 <Axman6> >_>
10:44:15 <Jafet> > 1 ‚Ç¨ (+1)
10:44:15 <lambdabot>   Not in scope: `‚Ç¨'
10:44:20 <Jafet> Darn
10:44:24 <Vanadium> Aww, I @let'd it earlier
10:44:30 <Jafet> How long do @lets last?
10:44:37 <Vanadium> No idea
10:44:41 <ski> until someone does `@undefine'
10:44:49 <Jafet> That would explain it
10:44:50 <ski> (or the bot restarts)
10:45:07 <Vanadium> ben_m: What were you going to do with |>?
10:45:24 <ben_m> Vanadium: Use it instead of regular function composition, probably
10:45:31 <phaul> this quickCheck thing drives me mad, I've been trying to figure out what's going wrong for the last 2 days now.. Altough I'm sure it's gonna be something stupid and obvious...
10:45:38 <ben_m> Or function application
10:45:38 <Vanadium> @let (‚Ç¨) = flip ($)
10:45:40 <lambdabot>  Defined.
10:45:43 <Vanadium> @let infixr 0 ‚Ç¨
10:45:45 <lambdabot>  Defined.
10:45:52 <Vanadium> > ("foo", "bar") ‚Ç¨ do f <- fst ; s <- snd ; const $ f ++ s
10:45:53 <lambdabot>   "foobar"
10:47:02 <ski> liftM2 (++) fst snd
10:47:09 <phaul> now it bailed out on 5 14 5 whereas quickCheck (True ==> fromIntegral ( 5 ^ 14 `mod` 5) == modPow 5 14 5) passes 100 times
10:47:40 <ski> `True ==> ...' seems pretty useless
10:48:07 <_Ray_> Question. I have a list of tuples, [(a, b)], where a and b both implement show. How can I walk the list of tuples showing first a, and then b? I tried doing a map, but I realized I don't know how to say "show (fst tuple); show (snd tuple)" in functional style...
10:48:56 <Botje> there's already a Show instance for tuples
10:48:58 <ski> what result do you want ?
10:49:30 <_Ray_> I want the concatenation of the strings resulting from (show (fst tuple)) and (show (snd tuple))
10:49:43 <ski> if the list is `[(0,False),(1,True)]' do you want `"01FalseTrue"' ?
10:49:55 <Heffalump> show (map fst tuple) ++ show (map snd tuple) ?
10:50:01 <_Ray_> Ohhhh
10:50:10 <_Ray_> Wait, no.
10:50:19 <_Ray_> That'd give me all the fsts first, and all the snds second
10:50:21 <ski> > let list = [(0,False),(1,True)] in show (map fst tuple) ++ show (map snd tuple)
10:50:23 <Heffalump> tell us what you want for ski's list and we'll tell you how to do it :-)
10:50:23 <lambdabot>   Not in scope: `tuple'Not in scope: `tuple'
10:50:27 <kmc> :t (True ==>)
10:50:27 <lambdabot> forall prop. (Testable prop) => prop -> Property
10:50:37 <kmc> :t (==>)
10:50:38 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
10:50:40 <ski> > let list = [(0,False),(1,True)] in show (map fst list) ++ show (map snd list)
10:50:42 <lambdabot>   "[0,1][False,True]"
10:50:53 <_Ray_> For ski's list I'd want (show 0)\n(show False)\n\n(show 1)\n(show True), ideally
10:51:52 <Axman6> :t do {x <- fst; return x}
10:51:53 <lambdabot> forall a b. (a, b) -> a
10:51:56 <Axman6> bah
10:52:00 <Axman6> :t do {?x <- fst; return x}
10:52:01 <lambdabot> Parse error in pattern
10:52:10 <HairyDude> let (as, bs) = unzip tuple in show as ++ show bs
10:52:11 <HairyDude> ?
10:52:19 <EnglishGent> hello :)
10:52:27 <ski> > let list = [(0,False),(1,True)] in unlines (concatMap (\(a,b) -> [show a,show b]) list)  -- not quite ?
10:52:29 <lambdabot>   "0\nFalse\n1\nTrue\n"
10:52:40 <_Ray_> :D
10:52:48 <_Ray_> Good enough.
10:52:54 <_Ray_> Thanks ^^
10:53:14 <ski> > let list = [(0,False),(1,True)] in concatMap (\(a,b) -> concat [show a,"\n",show b,"\n"]) list  -- another variant
10:53:15 <lambdabot>   "0\nFalse\n1\nTrue\n"
10:55:40 <ski> > do (a,b) <- [(0,False),(1,True)]; show a `mplus` "\n" `mplus` show b `mplus` "\n"  -- yet another variant
10:55:42 <lambdabot>   "0\nFalse\n1\nTrue\n"
10:59:46 * ski can never remember the exact handling of trailing `\n' with `lines' and `unlines'
11:00:27 <c_wraith> > unlines ["a", "b", "c"]
11:00:28 <lambdabot>   "a\nb\nc\n"
11:00:39 <medfly> c_wraith, :) I got it working! everything! :-)
11:00:47 <c_wraith> medfly: congrats. :)
11:00:56 <ski> > lines "a\nb\nc\n"
11:00:57 <ski> > lines "a\nb\nc"
11:00:57 <lambdabot>   ["a","b","c"]
11:00:59 <lambdabot>   ["a","b","c"]
11:01:18 <medfly> > lines "a\nbc"
11:01:19 <lambdabot>   ["a","bc"]
11:02:13 <ski> ideally, i'd like `lines' and `unlines' to be inverses (on total strings)
11:02:28 <ski> but i'm not even sure we have a retract situation
11:02:34 <c_wraith> that's very difficult, given that lines is lossy
11:02:57 <c_wraith> And making it non-lossy would be strange
11:03:00 <jmcarthur> i wrote a nonlossy withLines once
11:03:03 <jmcarthur> lemme see if i can find it
11:03:13 <ski> @check \x -> (unlines . lines) x == x
11:03:14 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\792697\\1010883\"\n"
11:03:36 <Axman6> > text "\\792697\\1010883\"
11:03:37 <lambdabot>   <no location info>:
11:03:37 <lambdabot>      lexical error in string/character literal at end o...
11:03:53 <Axman6> > text "\792697\1010883"
11:03:54 <lambdabot>   ÛÅ°πÛ∂≥É
11:04:06 <Axman6> > lines "\792697\1010883"
11:04:07 <lambdabot>   ["\792697\1010883"]
11:04:21 <c_wraith> the only obvious way I can see to make lines non-lossy is to have lines "a" -> ["a"] and lines "a\n" -> ["a", ""]
11:04:57 <jmcarthur> or perhaps it was withWords
11:05:12 <c_wraith> and then unlines = intercalate "\n"
11:06:02 <ski> > graph (graph unlines . lines) "ab"
11:06:04 <lambdabot>   ("ab",(["ab"],"ab\n"))
11:06:52 <c_wraith> But I really don't like the idea of lines returning a list of length 2 from what I see as a one-line input file.
11:06:54 <HairyDude> weird. I eliminated some ephemeral lists and it actually made the program slower
11:07:07 <jmcarthur> c_wraith: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=9274
11:07:19 <jmcarthur> withSplitter is what i actually did
11:07:30 <jmcarthur> and the example below it is essentially withWords
11:07:37 <jmcarthur> but could be used for withLines too
11:07:40 <HairyDude> at least 5 tiems slower
11:08:06 <jmcarthur> ski: ^^
11:08:32 <c_wraith> HairyDude:  Were the ephemeral lists being fused away, but now that optimization isn't possible?
11:08:43 <chaosape> kmc: i think i have it ... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11144#a11144 ... is there a way i could remove the mkSomethingX signatures?
11:10:01 <kmc> do you want to?
11:10:18 <kmc> they ensure that the numerical literals get the right types
11:10:20 <HairyDude> c_wraith: it's something like foo high low where high = maximum l; low = minimum l; l = [x,y] ++ if bar then [] else [baz]
11:10:25 <jmcarthur> to be actual inverse operations i think c_wraith is right though. "a\n" would have to split to ["a", ""]
11:10:26 <kmc> otherwise there is a defaulting mechanism which is rather arbitrary
11:10:28 <HairyDude> don't see how that can give rise to any fusion
11:10:49 <HairyDude> also, optimizations are off
11:11:47 <c_wraith> HairyDude:  Hmm.  that would suggest you accidently introduced an O(n^2) algorithm, or the like, then.
11:11:51 <HairyDude> oh, wait, the code with lists eliminated were wrong :)
11:11:58 <c_wraith> oh, or that. :)
11:11:59 <HairyDude> s/were/was/
11:12:58 <chaosape> kmc: no i guess it really isnt necessary ... although I do have one follow on question ...
11:13:56 <ski> jmcarthur> @src SplitList
11:14:06 <chaosape> kmc: where should i look if i want to store a collection of (Something a b)'s
11:14:43 * HairyDude fixes it and tries again
11:14:55 <jmcarthur> ski: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/src/Data-List-Split-Internals.html#SplitList
11:15:59 <ski> chaosape : with same `a' and `b' for all elements ? or possibly differing ?
11:16:04 <HairyDude> right, so that doesn't seem to eliminate any allocation at all.
11:17:28 <kmc> chaosape, what kind of collection? ordered? unique? associative?
11:17:54 <kmc> okay so you got rid of the type tags and made a and b non-existential
11:18:09 <chaosape> ski: possibly differing
11:18:16 <kmc> then you will need an existential wrapper
11:18:25 <ski> jmcarthur : nice :)
11:18:52 <kmc> consider the simple case of a list: [Something a b] is a list of values of type "Something a b" for some specific a and b, not for varying a and b
11:19:17 <ski>   [exists a b. Something a b]
11:19:32 <ski> would be for varying (for each element) `a' and `b'
11:19:33 <merijn> Is there a way to "expand" the function parsing in GHCi? Or is it a matter of finding a quiet room and pen and paper doing it by hand? I'm reading Yet Another Haskell Tutorial which has this (http://paste.lisp.org/display/89254) example and I'm having a very hard time telling what's actually going on...
11:19:51 <ski> (if haskell supported existentials directly, i.e.)
11:20:19 <ddarius> merijn: Do you mean display the reduction sequence?
11:20:46 <aep> *sigh*. now i got through the monad tutorial, but again it didnt even explain monads. it imidiatly jumps to do syntax. thats the 5th i've read. anyone got any doc that explains _what_ they actually are?
11:20:49 <merijn> ddarius: Like I said I have a hard time telling what's getting called with which arguments in what order
11:21:06 <kmc> chaosape, you probably want a type like "data ReportThing = forall a. (Reportable a b c) => ReportThing a
11:21:07 <drhodes> I had to alter a .cabal file, is there a way to $ cabal install some-package.cabal ?, or maybe another better approach..
11:21:17 <ddarius> merijn: Do it by hand.  It's good exercise.
11:21:22 <kmc> then your Somethings can be stored in a [ReportThing] because they are Reportable
11:21:23 <BONUS> aep: basically you can explain *what* they are in one line of text, but the main thing about them is what they enable you to do
11:21:25 <stroan> aep: what I've found with regards to learning monads is that there isn't much to them except for the syntax
11:21:29 <chaosape> kmc: if i existentially wrap them that means i either need to have a type class to get the data out or i need to use typeable and cast right?
11:21:30 <stroan> they're simple things
11:21:36 <drhodes> aep: have you tried this one -> http://ertes.de/articles/monads.html ?
11:21:38 <stroan> the trick is the many ways they can be used
11:21:44 <kmc> and when you pattern-match on that list, you will get the ability to use Reportable
11:21:57 <aep> drhodes: nope. not yet :)
11:22:07 * HairyDude gives up for today
11:22:12 <merijn> ddarius: Time to kick people to turn down the noise and grab some paper then.
11:22:15 <aep> stroan, BONUS : so you're saying i dont need to know them at all?
11:22:33 <kmc> chaosape, typeable and cast is really an entirely different thing
11:22:37 <kmc> chaosape, there are examples of useful existentials without typeclasses
11:22:37 <stroan> no, you already know them if you know the syntax. what you have to learn is how to use them
11:22:47 <stroan> which is non obvious
11:23:07 <kmc> data Foo = forall a. Foo a (a -> String)
11:23:09 <stroan> and I've found only practice is helping with gaining understanding
11:23:09 <BONUS> yeha. a monad is basically a type constructor that obeys the monadic laws, but i recon that doesn't really help you much. at its core, that's what a monad is
11:23:11 <kmc> this is somewhat similar to
11:23:15 <aep> i don't know the syntax at all, thats the problem.  all tutorials imidiatly tell you that "you can rewrite that in do syntax" assuming you already know what >>= even means
11:23:17 <kmc> data Foo = forall a. (Show a) => Foo a
11:23:47 <stroan> >>= is just a function on monads that obeys the laws
11:23:48 <aep> there are a lot of operators i don't know yet, and no book seems to cover them completely
11:23:53 <chaosape> kmc: oh! I never thought about doing that.  Thanks a bunch for all your help.
11:23:59 <kmc> no problem
11:24:01 <stroan> it means different things depending on the context
11:24:20 <BONUS> aep: do you know about applicative functors?
11:24:33 <aep> kindof. i read alot but not sure if i grasped it
11:24:33 <BONUS> and what they are, and how to use some of them?
11:24:47 <aep> well i've seen how to use fmap
11:24:49 <kmc> chaosape, also, you might consider using associated types instead of fundeps for Reportable
11:24:52 <kmc> could be nicer code
11:25:03 <BONUS> usually it's better if you understand applicative functors and some of their instances. once you know them, monads are just one step away
11:25:10 <kmc> maybe associated synonyms as well
11:25:12 <BONUS> and applicative functors are pretty easy to grasp
11:25:38 <aep> hmh.  i'll try reading on that again. thanks
11:26:06 <kmc> class Reportable a where { type Report a; getline :: a -> Report a }
11:27:08 * ski is not sure appplicative functors is preferable to know before monads
11:27:37 <BONUS> really? i kind of feel functor -> applicative -> monad is a nice progression of learning
11:27:38 <chaosape> kmc: are fundeps frowned upon?
11:27:46 <BONUS> because you're always just adding like one or two concepts
11:27:53 <BONUS> and you see how values in contexts behave
11:28:09 <stroan> BONUS: aye, but don't you think that barrier to understanding is pretty much the same in both cases?
11:28:14 <sinelaw> BONUS i agree, that progression is natural - if you explain what the next thing adds
11:28:23 <ski> (it's nice to know them, but if one doesn't, i'm not sure it will be easier to learn them first before monads, instead of learning monads directly (and applicative functors later))
11:28:24 <sinelaw> (and as a BONUS you can add monad -> Arrow )
11:28:50 <aavogt> sinelaw: wouldn't that be applicative -> arrow?
11:29:15 <sinelaw> aavogt maybe, i didn't really figure that out yet
11:29:47 <aavogt> Monads are Arrow in general, but not the other way around
11:30:24 <aavogt> then again, Arrow isn't used much
11:30:45 <ski> BONUS : well, a group is just a moufang loop with certain things added, but i'm not sure it's better to learn moufang loops before groups
11:31:24 <kmc> chaosape, not entirely.  asstypes are newer than fundeps so some things which were done with fundeps could be re-done with asstypes
11:31:47 <ski> sinelaw,aavogt : the kind of an instance of `Monad' is different from the kind of an instance of `Arrow'
11:32:33 <kmc> a (n-param) typeclass is an n-ary relation on types. a fundep is a slightly awkward way to claim that this relation is a function.  type families give type-level functions in a more direct way: for each "input type" you give an output type
11:32:36 <c_wraith> @kind (->)
11:32:36 <lambdabot> ?? -> ? -> *
11:32:57 <aavogt> ski: well, there's the Kleisli newtype to work around that
11:33:08 <c_wraith> ok, I've completely forgotten what ?? and ? mean.
11:34:00 <aavogt> @quote kind
11:34:00 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
11:34:39 <ski> c_wraith : `??' is the lub of `*' and `#'. `?' is the lub of `??' and `(#)'
11:34:46 <kmc> @quote kind
11:34:46 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
11:34:47 <lambdabot> a really bad one
11:35:30 <kmc> ski, # is unboxed values and (#) is unboxed tuples?
11:35:45 <kmc> @quote kind
11:35:46 <lambdabot> z0MB13 says: who can say hello to me as a md5 or decipher what kind of technique can be used to remove the password
11:35:54 <ski> kmc : yes
11:36:03 <ski> (and the latter isn't included in the former)
11:36:19 <ski> @quote infinite.kind
11:36:20 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
11:36:20 <ski> :)
11:36:43 <kmc> unboxed tuples are separate because they cannot be stored in registers?
11:36:56 <ski> right, they are stored in several registers
11:37:26 <ski> @kind (# Int , GHC.Base.Int# #)
11:37:27 <lambdabot> (#)
11:37:39 <ski> @kind (# Int , GHC.Base.Int# #) -> ()
11:37:41 <lambdabot>     Kind mis-match
11:37:41 <lambdabot>     Expected kind `??', but `(# Int, GHC.Prim.Int# #)' has kind `(#)'
11:37:43 <kmc> so the kind of (->) says that a function can return an unboxed tuple but not take one
11:37:51 <ski> yes
11:38:22 <ski> (i'm not sure of the rationale for it not being able to take an unboxed tuple as an argument, but that's what it says)
11:38:26 <c_wraith> Then...  the only thing you can do with an unboxed tuple is unpack it?
11:38:30 <aavogt> so who produces these unboxed tuples?
11:38:53 <kmc> we do!
11:38:56 <kmc> > (# 2, 3 #)
11:38:58 <lambdabot>   Illegal binding of unboxed tuple e_123 :: (# t_a2HX, t_a2HZ #)
11:39:04 <kmc> :D
11:39:14 <chaosape> kmc: thanks a ton! Here is the final version (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11144#a11145). Now I can parameterize my somethings with a phantom type and your associated type suggestions saves me from writing lots of instances!
11:39:14 <c_wraith> you just tried to pass an unboxed tuple to show. :)
11:39:21 <kmc> yup
11:39:28 <kmc> aavogt, it's basically a mechanism for functions to return multiple values
11:39:38 <kmc> without boxing overhead
11:39:58 <kmc> > let (# a, b #) = (# 2, 3 #) in a
11:39:59 <lambdabot>   2
11:40:34 <bauchus> hi! does anybody use haskell-src to generate code? I'd like to know the difference between HsIdent and HsSymbol (data HsName)
11:40:39 <kmc> > let f x = (# x, x + 1 #); (# a, b #) = f 3 in (a,b)
11:40:40 <lambdabot>   (3,4)
11:41:23 <aavogt> bauchus: have you seen template haskell?
11:41:35 <Vanadium> @t (# 1, 2, 3 #)
11:41:36 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:41:40 <Vanadium> :t (# 1, 2, 3 #)
11:41:42 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => (# t, t1, t2 #)
11:41:52 <bauchus> aavogt: not really
11:42:08 <c_wraith> template-haskell is pretty easy to get a handle on.  And very slick.
11:42:23 <c_wraith> Pity about what it does to compile times. :)
11:42:53 <aavogt> that and it requires top-level splices to come from different modules
11:43:00 <ddarius> It does arbitrary computation at compile-time including arbitrary IO and then feeds the compiler generated code...
11:43:00 <kmc> afaik unboxed tuples are not used much in 'user-level' code but are in the core libraries
11:43:22 <kmc> i thought any splice had to come from another module
11:43:22 <ddarius> Nowadays, you should pretty much never explicitly use unboxed code.
11:43:24 <c_wraith> yeah, the top-level splice restriction is annoying.
11:43:48 <bauchus> hm.
11:44:02 <bauchus> maybe I should use template haskell.
11:44:26 <aavogt> what does your generated code do?
11:44:43 <bauchus> I try to convert some simple SQL statements to Haskell code (using the HDBC backend)
11:47:45 <ski> merijn : btw, i'm not sure that `cfold' example explains CPS that well
11:50:06 <c_wraith> Is this as common for an instance of Lift as I think it is?  instance Lift Character where lift = return . ConE . mkName . show
11:50:06 <ski> (since the source of the transform was tail-recursive, it's valid to transform it into a version that doesn't itself pass around a current continuation. but then it doesn't exemplify the general transformation that well)
11:50:10 <ddarius> Well, if nothing else, the cfold wrapper completely defeats the point of the cfold' function.
11:51:15 <ski> oh, right, `\x t g -> f x (g t)' isn't proper CPS
11:51:54 <c_wraith> I guess that implementation only works for enumeration types.
11:54:26 * ski notes only now that merijn has left ..
12:11:53 <_Ray_> Hey, say I have ["abc", "def", "ghi"] (I actually have objects with show methods, but no difference I think). I want to return the string "abc, def, ghi". How could I do this? I tried concat, but it doesn't seem to want an "interpolation" character.
12:12:29 <dolio> intercalate
12:13:03 <_Ray_> Ah, I need a module
12:13:11 <ddarius> @src intercalate
12:13:11 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
12:13:29 <ddarius> _Ray_: The Haskell-way is to make small functions and combine them together.
12:13:32 <Jedai> _Ray_: It's in Data.List
12:13:44 <_Ray_> Yeah, I'll try it. Thanks! :)
12:14:18 <Jedai> @hoogle vcat
12:14:19 <lambdabot> Text.PrettyPrint.HughesPJ vcat :: [Doc] -> Doc
12:14:19 <lambdabot> Language.Haskell.TH.PprLib vcat :: [Doc] -> Doc
12:15:00 <tommd> > hcat (map render ["hello", "how are you"]
12:15:02 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:15:03 <tommd> > hcat (map render ["hello", "how are you"])
12:15:04 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
12:15:04 <lambdabot>         agains...
12:15:09 <tommd> damn you
12:15:25 <ddarius> :t Text.PrettyPrint.HughesPJ.text
12:15:26 <lambdabot> String -> Doc
12:15:26 <Jedai> _Ray_: Otherwise if you have sophisticated text formatting, you can use Text.PrettyPrint.HughesPJ
12:15:33 <tommd> @type rander
12:15:35 <lambdabot> Not in scope: `rander'
12:15:36 <tommd> @type render
12:15:37 <lambdabot> Doc -> String
12:15:43 <tommd> oops, thats my confusion.
12:16:01 <tommd> > hcat (map text ["hello", "how are you"])
12:16:02 <lambdabot>   hellohow are you
12:16:29 <GetRidOfHer> hcat (map text ["hello", "how r u"])
12:17:07 <evanbd> Hmm.  My modPow function (exponentiation by squaring) is slow.  Any suggestions?  Current version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11148
12:17:16 <Jedai> GetRidOfHer: You need to put a "> " at the beginning of the line to get lambdabot to evaluate it
12:17:19 <ddarius> evanbd: Use ^
12:17:28 <evanbd> ddarius: You're kidding, right?
12:17:53 <GetRidOfHer> something is wrong here...iam trying to be as good as evanbd
12:18:23 <ddarius> evanbd: Somewhat, I'm assuming you are doing this for exercise, but if not, then, no, I'm not kidding.
12:19:11 <evanbd> ddarius: ^ doesn't work very well when you try taking ((6 digit number) ^ (6 digit number)) `mod` (6 digit number)
12:19:13 <Jedai> ddarius: It's a modular exponentiation, depending on its needs, (^) is most assuredly not what he want
12:19:35 <ddarius> Jedai, evanbd: If you make a Mod Numeric type, then it will be exactly what you want.
12:20:05 <Jedai> @src (^)
12:20:06 <lambdabot> x ^ 0            =  1
12:20:06 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:20:06 <lambdabot>   where f _ 0 y = y
12:20:06 <lambdabot>         f x n y = g x n
12:20:06 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
12:20:08 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:20:10 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:20:16 <tromp> it will loop forever on b==0
12:20:26 <Jedai> ddarius: Good point :)
12:21:57 <evanbd> ddarius: Well, that source looks a lot like the modPow I wrote, except more generic and harder to read.  Which makes me doubt it will be faster.
12:22:47 <Jedai> evanbd: The point is that you don't need to rewrite it, you can just write a modular Num and get your modPow for free
12:23:03 <Jedai> evanbd: and other modular algorithms
12:23:11 <evanbd> Jedai: OK, point taken.  Now, how do I write a faster ^?
12:23:40 <Jedai> evanbd: Do you really need a faster (^) or just a modular (^)
12:23:42 <Jedai> ??
12:24:04 <evanbd> Jedai: Just a faster modular ^.  That's why my original question was about modPow, not ^ :)
12:24:24 <mauke> ^ is modPow
12:24:55 <Cale> (only if you have a type for numbers modulo the specific integer that you need
12:24:56 <Cale> )
12:25:14 <mauke> oleg had something like that in his paper about implicit configurations
12:25:18 <Cale> Though you can stuff them all into the same type if you want.
12:25:31 <evanbd> For reference, sum [modpow x x 1000003 | x <- [1..2000000]] takes 24 seconds here (ghc -O).  The equivalent Java code runs in 7s.
12:25:36 <mercury^> gmp has a good powmod, but I'm not sure if you can easily use it on Integer.
12:25:39 <Cale> and just assume that when you do any computations with both that the moduli match
12:26:37 <Cale> evanbd: how did you compile it?
12:27:21 <evanbd> Cale: ghc -O -o benchmark modular.hs benchmark.hs
12:27:33 <benmachine> not -O2?
12:27:54 <evanbd> benmachine: I think I tried that and it didn't matter.  Let me check.
12:28:59 <evanbd> benmachine: 23.9s vs 24.1 (aka within noise)
12:29:04 <ToRA> anyone who'se used the haskell ftgl package about? I'm getting linker errors atm :(
12:29:16 <mauke> ToRA: what's the first error?
12:29:47 <ToRA> /home/tora/.cabal/lib/FTGL-1.333/ghc-6.10.3/libHSFTGL-1.333.a(FTGL.o): In function `s2Pa_info':
12:29:50 <ToRA> (.text+0x61): undefined reference to `ftglSetLayoutAlignment'
12:30:04 <ToRA> just using ghc --make Main.hs
12:30:10 <ToRA> adding -lftgl doesn't seem to help
12:30:55 <Cale> evanbd: Switching to use quot and rem is a little faster (since it looks like we're only dealing with positive numbers anyway here).
12:31:24 <mercury^> evanbd: figure out how to call gmp functions on Integer, use mpz_powm or mpz_powm_ui, kick some Java ass.
12:31:46 <Cale> evanbd: But I suspect that to get the performance you're after, you'll have to do a bit of low-level hackery.
12:32:38 <evanbd> Cale: Yeah, positives only.  I'll try switching.
12:33:15 <evanbd> Cale: For now I'd rather avoid the low level stuff...  I'll probably stick with the slow version.
12:34:07 <Cale> Switching to quot and rem is only slightly faster. They're the ones which have hardware support, though the way they deal with negative values is silly.
12:34:27 <mercury^> evanbd: http://hackage.haskell.org/trac/ghc/ticket/3489
12:34:37 <evanbd> Well, 21s instead of 24s is handy, but still a bit slow.
12:34:39 <mercury^> Someone already did the work.
12:35:18 <c_wraith> > -5 `rem` 3
12:35:18 <lambdabot>   -2
12:35:28 <c_wraith> Ah, yes, that's the result I prefer less
12:35:29 <benmachine> > (-5) `rem` 3
12:35:31 <lambdabot>   -2
12:35:45 * benmachine just checking
12:36:34 <c_wraith> (-1 would be the result I prefer least.  negative *and* wrong)
12:36:55 <Cale> Yeah, -5 `rem` 3 = -(5 `rem` 3), so it was a good idea to check.
12:37:09 <Cale> (multiplicative before additive)
12:37:33 <mercury^> Cale: I wrote some more on that Incomputability paper today. Not so sure that using Haskell was a good idea.
12:37:33 <Paczesiowa> @src enumFromTo
12:37:36 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:37:53 <mercury^> If you want to have another look: http://rohanlean.de/pub/Incompleteness.pdf
12:38:30 <Jedai> @src Boolean enumFromTo
12:38:31 <lambdabot> Source not found. That's something I cannot allow to happen.
12:38:37 <Jedai> @src Int enumFromTo
12:38:38 <lambdabot> Source not found. :(
12:38:54 <Jedai> @src Enum enumFromTo
12:38:54 <lambdabot> Source not found.
12:39:56 <Cale> mercury^: Wasn't that the purpose of it though?
12:40:43 <mercury^> Cale: I just wanted to prove all the theorems in little space and an easy to understand way.
12:40:53 <ddarius> evanbd: Are you giving a type annotation to modpow?
12:41:09 <Cale> Oh, then using a programming language is probably not the best way ;)
12:42:09 <evanbd> ddarius: Yes; does that matter?  (It's "modPow :: (Integral a) => a -> a -> a -> a")
12:42:15 <mercury^> Well, was a nice experience (and I'm still in for it, because implementing the conversion of lambda terms to diophantine equations will be quite a pain).
12:42:28 <mauke> evanbd: hmm, using ^ instead of your modpow dropped it from 23s to 17s
12:42:31 <ddarius> evanbd: That's defaulting to Integer.  Is your Java code using BigInt (or whatever it's called)
12:43:00 <c_wraith> Java doesn't have a modpow on anything else
12:43:15 <evanbd> ddarius: Yeah, the Java version used BigInt, since that's the only standard modPow.
12:43:45 <evanbd> And I wanted to avoid *also* trying to write fast Java code when someone else had already probably done it :)
12:43:54 <ddarius> mauke: Using a modular type or just doing the mod at the end?
12:43:59 <mauke> ddarius: modular type
12:45:33 * ski . o O ( A Modular Module System )
12:47:12 <a_guest> how do I convert a string to Int? I am using parsec, so I try to read a number as "nStr <- many digit". nStr shall be converted to number.
12:47:20 <mauke> read
12:47:23 <ski> > read "123" :: Int
12:47:24 <lambdabot>   123
12:47:27 <mauke> and you want many1
12:47:29 <evanbd> mauke: Hmm.  I suppose I should do that, then.  And now I need to figure out why the ^ code is faster than mine...
12:47:43 <ddarius> Or you could just use 'natural'
12:47:48 <Cale> evanbd: It's faster because it uses unboxed Ints
12:47:51 <benmachine> read is not error-thing
12:47:56 <mercury^> > read "ffa" :: Int
12:47:56 <benmachine> resilient
12:47:57 <lambdabot>   * Exception: Prelude.read: no parse
12:48:01 * benmachine can't remember the word
12:48:13 <Cale> The code in @src is not the real code
12:48:13 <benmachine> reads is better if you want to recover
12:48:14 <ski> "total" ?
12:48:50 <Cale> er, maybe I'm misremembering
12:49:02 <Cale> Oh, there's a SPECIALISE pragma... is that all?
12:49:26 <Cale> Well, this also looks different anyway.
12:49:30 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html#^
12:49:53 <ski> @let readMaybe :: Read a => String -> Maybe a; readMaybe s = case reads s of [(a,"")] -> Just a; _ -> Nothing
12:49:54 <lambdabot>  Defined.
12:50:17 <Jedai> benmachine: I think it's a string that comes from a "many1 digit" in Parsec, so it's already correct by construction, no need for error handling at this level
12:50:31 <kmc> what is this (outfix?) type constructor [::] ?
12:51:44 <benmachine> Jedai: true, I suppose
12:51:44 <ski> kmc : nested data parallel array, iirc
12:51:51 <Cale> Oh, this is already giving me good ideas for what we ought to do to make this a bit faster
12:52:09 <mauke> wtf, why am I getting different results now
12:53:36 * FunctorSalad just noticed it makes a difference whether you have duplicate type vars in an instance head, or have equivalent equality constraints in the context
12:54:20 <FunctorSalad> in the first style the resolver refuses to work for me, in the second style it matches and commits to showing that the relevant vars are equal
12:54:54 <Cale> Passing around the modulus during the recursion is probably hurting at least a bit
12:56:01 <kmc> @pl \xs -> sum <$> sequence xs
12:56:01 <lambdabot> (sum <$>) . sequence
12:56:33 <evanbd> Cale: Actually, I have a suspicion that that third parameter being passed around matters...
12:59:14 <ski> kmc : `sequenceA' or `liftM' ?
13:02:37 <Cale> In fact, you don't have to pass around the base either, which might make it another tiny bit faster... it's nowhere near the majority of the cost though.
13:13:00 <evanbd> OK, now I'm *really* confused.  I tried copy-pasting the code for ^, changing it from "(^) x0 y0" to "modPow x0 y0 n", and sprinkling "`mod` n" appropriately.  And now it's *really* slow.
13:14:30 <roconnor> @src (^)
13:14:31 <lambdabot> x ^ 0            =  1
13:14:31 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
13:14:31 <lambdabot>   where f _ 0 y = y
13:14:31 <lambdabot>         f x n y = g x n
13:14:31 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
13:14:33 <lambdabot>                       | otherwise = f x (n-1) (x*y)
13:14:35 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
13:15:11 <evanbd> roconnor: I actually used the source on haskell.org, which is slightly different but the same idea
13:17:45 <evanbd> Anyway, enough of this for now.
13:17:51 <evanbd> Thanks everyone for the help.
13:18:06 <evanbd> I'm now more confused than I started, but at least have things to investigate.
13:19:01 <hackagebot> HaskellForMaths 0.1.9 - Combinatorics, group theory, commutative algebra, non-commutative algebra (DavidAmos)
13:38:45 <Paczesiowa> what was the command for ghci to print types with explicit foralls?
13:38:45 <lambdabot> Paczesiowa: You have 1 new message. '/msg lambdabot @messages' to read it.
13:40:15 <Paczesiowa> @seen ivanm
13:40:16 <lambdabot> Unknown command, try @list
13:40:22 <Paczesiowa> ,seen ivanm
13:40:31 <lunabot>  luna: Not in scope: `seen'
13:40:35 <Paczesiowa> .seen ivanm
13:41:15 <preflex> Paczesiowa: ask me!
13:41:30 <Paczesiowa> preflex: seen ivanm
13:41:30 <preflex>  ivanm was last seen on #haskell 7 hours, 16 minutes and 53 seconds ago, saying: Saizan: hmmm... there are haddock-style {-# #-} statements...
13:41:59 <Paczesiowa> there should be class for all the bots... seen :: Bot a => String -> a String
13:43:45 <PeakerWork> Paczesiowa: Who uses "a" for higher-kinded types? :)
13:45:44 <Paczesiowa> @tell ivanm I have trouble with keeping my attention and I figured that updater needs rewrite with a nice monad at the core, but didn't think you'd go for it, so I kind of lost my interest. let me know ir you're up for that rewrite
13:45:44 <lambdabot> Consider it noted.
13:46:23 <Paczesiowa> PeakerWork: that was just a bad joke, so it doesn't really matter
13:46:36 <RDex> Hello room
13:46:50 <RDex> I'm having an issue getting the general concept behind haskell
13:47:02 <RDex> I dont understand how functions are written
13:47:10 <lament> With a text editor
13:47:12 <mauke> why not?
13:47:12 <RDex> and how you keep them "together" per say
13:47:24 <mauke> do you know any other programming languages?
13:47:28 <lament> RDex: Do you get the general concept behind other programming languages?
13:47:33 <RDex> also, I saw somoene use the DoLPF function and I can't find that function in any lists
13:47:46 <RDex> lament, mauke, C++, C, Java mainly
13:47:47 <mauke> DoLPF can't be a function
13:47:53 <mauke> it starts with an uppercase letter
13:47:55 <RDex> mauke, i couldn't find any reference to it
13:48:03 <lament> @hoogle DoLPF
13:48:03 <lambdabot> No results found
13:48:06 <tommd> RDex: It can not exist is what mauke is saying.
13:48:16 <Botje> RDex: perhaps you read "do lpf ..." ?
13:48:21 <lament> @hoogle lpf
13:48:21 <aeron> lol
13:48:22 <lambdabot> No results found
13:48:28 <kmc> RDex, have you tried writing some Haskell code?
13:48:33 <RDex> Botje, perhaps it was a funmction i was supposed to make
13:48:34 <mauke> RDex: where did you see it?
13:48:38 <RDex> kmc, everyone
13:48:51 <RDex> I have tried writing some haskell code and I get tons of errors
13:48:55 <hgolden> RDex: Please elaborate on your original "I don't know..."
13:48:58 <RDex> using WinHugs
13:49:05 <tommd> > let func a b = a * a / b * 3 in func 3 2
13:49:06 <lambdabot>   13.5
13:49:08 <kmc> RDex, can you upload some code to hpaste.org ?
13:49:11 <kmc> we'll help you find the errors
13:49:15 <RDex> kmc I dont have any available
13:49:18 <RDex> on this machine
13:49:22 <RDex> hold on
13:49:30 <Botje> do you at least know what you're supposed to do? :
13:50:21 <RDex> I'm trying to learn how to read it in different ways, right now.. say i had a declaration of an object g of type 'w'
13:50:35 <RDex> g = [(This 3.2, 5, true), (That 9.1, 4, false)]
13:50:38 <tommd> RDex: Haskell isn't object oriented.
13:50:45 <RDex> how would i know what its type definition was
13:50:48 <kmc> RDex, we'd say "value" rather than "object"
13:50:49 <mauke> tommd: "object" isn't necessarily OO
13:51:02 <RDex> okay, value then
13:51:09 <kmc> and keep in mind that functions are values too
13:51:12 <tommd> > let g = [3.2, 5, True), (91., 4::Int, False)]
13:51:13 <lambdabot>   <no location info>: parse error on input `)'
13:51:28 <mauke> RDex: well, you could load the definition in an interactive interpreter like hugs and use :t g
13:51:31 <tommd> > let g = [(3.2, 5, True), (91., 4::Int, False)]
13:51:31 <lambdabot>   not an expression: `let g = [(3.2, 5, True), (91., 4::Int, False)]'
13:51:42 <tommd> :t [(3.2, 5, True), (91., 4::Int, False)]
13:51:43 <lambdabot>     A section must be enclosed in parentheses thus: (91 .)
13:51:54 <mauke> multifail :-[
13:52:04 <tommd> Yeah, I'm sucking with lb.
13:52:12 <RDex> lemme download winhugs on this comp
13:52:24 <tommd> :t [(3.2, 5, True), (9.1, 4::Int, False)]
13:52:25 <lambdabot> forall t. (Fractional t) => [(t, Int, Bool)]
13:52:44 <hgolden> RDex: What text / tutorial are you studying?
13:53:14 <Paczesiowa> don't you all think that haskell is worse language to learn basic functional programming than helium?
13:53:15 <tommd> RDex: So you wanted to know the type of the expression 'g'.  You can see above that the type is inferred (I added an Int constraint) to be a list of tuples (Some Fractional, Int, Bool)
13:53:37 <RDex> hgolden, thats the problem, I am in an "ML" class but am given haskell code with no reference to haskell
13:53:43 <RDex> so i'm hoping the internet can help me where the book can't
13:54:02 <mauke> preflex: ? lyah
13:54:02 <preflex>  http://learnyouahaskell.com/
13:54:03 <RDex> i'm in the dark here
13:54:07 <mauke> preflex: ? rwh
13:54:07 <preflex>  http://book.realworldhaskell.org/read/
13:54:11 <tommd> @where yaht
13:54:11 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:54:13 <RDex> preflexyeh thats where i found the irc chat
13:54:21 <RDex> good references
13:54:24 <hgolden> RDex: Do you understand ML syntax / programming techniques or are you learning that too?
13:54:47 <RDex> hgolden: sort of, its hard to say, i figure if i get haskell then i'll get that other stuff too
13:55:11 <hgolden> RDex: It takes a while to grok it!
13:55:17 <RDex> grok?
13:55:37 <hgolden> RDex: Sorry. An old term. See Heinlein.
13:55:45 <mauke> RDex: http://www.catb.org/~esr/jargon/html/G/grok.html
13:56:42 * RDex is installing hugs
13:57:20 <copumpkin> noooo
13:57:42 * mauke hugs copumpkin 
13:57:48 <hgolden> RDex: If you are just getting started, I suggest picking one of the texts already suggested. They're all good.
13:57:53 <copumpkin> :)
13:57:54 <RDex> i know one thing, i dont understand the the foldr function
13:58:06 <copumpkin> RDex: do you understand the structure of a list?
13:58:10 <PeakerWork> RDex: do you understand how lists and pattern-matching work?
13:58:15 <copumpkin> lol
13:58:17 <RDex> uhmmm
13:58:19 <mauke> > foldr f z [a, b, c, d]
13:58:20 <lambdabot>   Ambiguous occurrence `f'
13:58:20 <lambdabot>  It could refer to either `L.f', defined at <local...
13:58:23 <mauke> @undefine
13:58:25 <PeakerWork> copumpkin: great minds think alike
13:58:25 <mauke> > foldr f z [a, b, c, d]
13:58:26 <lambdabot>   f a (f b (f c (f d z)))
13:58:29 <copumpkin> RDex: like [1,2,3] is 1 : 2 : 3 : []
13:58:46 <copumpkin> PeakerWork: yay
13:58:48 <RDex> copumpkin ok i follow
13:58:57 <RDex> mauke, lambdabot, what?
13:59:16 <copumpkin> RDex: foldr f z xs "replaces" each : in xs with f, and the [] at the end with z
13:59:18 <mauke> RDex: talking to bots doesn't get you anywhere
13:59:33 <ezyang> I wonder if people would find a library implementing Git bindings in Haskell useful
13:59:44 <hgolden> RDex: lambdabot is an online interpreter bot.
13:59:44 <copumpkin> ezyang: we should already have that for gitit?
13:59:58 <ezyang> ah, true
14:00:04 <copumpkin> ezyang: but maybe it isn't separated out into a nice library? not sure
14:00:08 <kmc> > 1 + 2
14:00:09 <lambdabot>   3
14:00:21 <RDex> > 1/0
14:00:22 <mauke> RDex: I provided a foldr example, lambdabot showed the result
14:00:23 <lambdabot>   Infinity
14:00:31 <RDex> lol, thought i could get it.
14:00:31 <ezyang> copumkin: I can't find their haddock pages, so tough to say
14:00:42 <mauke> > 1 `div` 0
14:00:43 <lambdabot>   * Exception: divide by zero
14:00:45 <copumpkin> need to go fishing for haddock
14:00:56 <ezyang> :-)
14:03:13 <hackagebot> attempt 0.0.0 - Error handling using extensible exceptions outside the IO monad. (MichaelSnoyman)
14:03:15 <hackagebot> http-wget 0.2.0 - Provide a simple HTTP client interface by wrapping the wget  command line tool. (MichaelSnoyman)
14:03:17 <hackagebot> authenticate 0.2.0 - Authentication methods for Haskell web applications. (MichaelSnoyman)
14:03:28 <ezyang> copumpkin: Doesn't look like it. That's kind of odd. Maybe I'll bounce some mail off of their list.
14:04:01 <copumpkin> ezyang: yeah, it could be quite cool if you represent the git repo as some sort of pure persistent datastructure
14:04:08 <copumpkin> since it retains its previous states
14:04:24 <copumpkin> haven't really thought through that though :)
14:04:37 <PeakerWork> if you exclude the working tree, git uses a persistent data structure so it can share history with hard links
14:04:43 <c_wraith> does it?  I thought merging with a different timeline changed the history state somewhat.
14:04:54 <PeakerWork> (when you git clone, you get shared history files/hardlinks)
14:05:25 <hgolden> RDex: Have we been helpful? Is there anything else you would like to get started?
14:05:32 <ezyang> c_wraith: You'll never be able to change what some hash represents
14:05:54 <ezyang> So while history is mutable in that you can change what your branch might point to, the history tree itself is immutable
14:05:59 <ezyang> This is kind of nice :-)
14:06:10 <c_wraith> Hmm, right.  the dependency signatures can't be altered.
14:06:30 <PeakerWork> ezyang: branches are mutable pointers into history, the history itself (the set of commits) grows, but every existing commit in it is immutable and doesn't change
14:07:00 <ezyang> yup
14:08:14 <RDex> hey, copumpkin, how does haskell know when a clause is over
14:08:26 <mauke> define "clause"
14:08:36 <RDex> =\
14:08:46 <RDex> mauke i dont know
14:08:49 <RDex> here is an example
14:08:52 <mauke> then what are you asking?
14:09:03 * RDex hopes he isn't breaking some channel rules
14:09:20 <RDex> w (x, d, q) =
14:09:20 <RDex> 	if x == 1 then d : q
14:09:20 <RDex> 	else if x == 2 then q ++ [d]
14:09:20 <RDex> 	else q
14:09:25 <mauke> :-(
14:09:26 <copumpkin> @hpaste :)
14:09:27 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:09:27 <RDex> this is supposed to be one clause
14:09:47 <mauke> RDex: layout of the code
14:09:53 <copumpkin> RDex: by the way, that code looks very unidiomatic in haskell :)
14:09:53 <mauke> next definition will start in column 1
14:10:35 <RDex> copumpkin, i dont know , it works though
14:10:39 <RDex> so thats a start for me
14:10:56 <copumpkin> RDex: yeah, but it's best to use haskell's features to their fullest from the start, rather than emulating what you're used to
14:10:57 <burp> , randomRIO (1,12)
14:10:58 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO t))
14:10:58 <RDex> mauke, oh haskell cares
14:11:06 <burp> , randomRIO (1,12) :: IO Int
14:11:07 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO GHC.Types.Int))
14:11:19 <copumpkin> burp: lambdabot can't do IO anyway
14:11:19 <ezyang> Um. http://hackage.haskell.org/package/pony
14:11:25 <burp> copumpkin: oh, ok
14:11:26 <mauke> RDex: it's actually optional, i.e. you can write everything with { } ;
14:11:34 <RDex> copumpkin, i agree. I am going over these study materials for a midterm tomorrow
14:11:39 <RDex> and that function was on it
14:11:42 <copumpkin> ah
14:11:52 <copumpkin> so you didn't write that? :o
14:11:54 <RDex> yeah, and i am using the terms and vocabulary this sheet uses
14:12:13 <RDex> copumpkin, i did, the sheet said know how to rewrite these haskell function in a single 'clause'
14:12:21 <RDex> how do you hpaste
14:12:22 <copumpkin> ah
14:12:29 <RDex> @hpaste
14:12:29 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
14:12:32 <RDex> oh
14:12:34 <kmc> in git there are several ways to combine branches of development, some of them "rewrite history" but only in that they construct new commits as altered versions of old ones... the objects in the database of all files/commits/etc never change, and they can't because they're indexed by their own hash
14:12:35 <copumpkin> you go to that site and paste something into it, then give us the url
14:12:45 <copumpkin> unsafeRebase
14:13:04 <Paczesiowa> are there any guidelines to ghc optimiser regarding modules? I have a library and a test that works great when in one module, but no optimisations are done when library is in different module
14:13:25 <RDex> copumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4477#a4477
14:13:38 <RDex> thats the code on my review sheet that i rewrote into a single 'clause'
14:13:39 <copumpkin> oh, they wanted you to convert that?
14:13:50 <RDex> yes
14:13:53 <RDex> at least know how to
14:14:02 <copumpkin> you can do it more simply with a case, but I see
14:14:06 <mauke> ah, we call those clauses "equations"
14:14:11 <RDex> ok
14:18:43 <RDex> what is dynamic scoping
14:19:04 <RDex> also, what search strings should i by typing in to get information on haskell programming
14:19:06 <PeakerWork> RDex: it means you get to access variables of callers
14:19:07 <RDex> like individual topics
14:19:26 <PeakerWork> RDex: rather than variables of enclosing lexical scopes (as in, scopes that are literally around the code)
14:19:29 <RDex> peakerwork, like in java or C+_
14:19:33 <RDex> c++
14:19:41 <PeakerWork> RDex: no, Java/C++ don't have dynamic nor lexical scoping
14:19:43 <mauke> java or c++ don't let you access your caller
14:19:45 <RDex> oh
14:19:48 <mauke> what
14:19:56 <mauke> java/c++ are pretty much all lexical
14:20:11 <mauke> with the exception of scope tunneling in C++ methods
14:20:13 <RDex> what is... lexical scoping then..
14:20:18 <PeakerWork> mauke: well, no lexical closures in C++
14:20:22 <mauke> PeakerWork: so?
14:20:44 <lament> java certainly doesn't have closures, and certainly has lexical scope
14:20:44 <mauke> RDex: you can access variables that are physically in the same block as you
14:20:47 <RDex> you guys are knowledgeable, I feel sorry for everyone else, IRC is blocked on campus
14:20:53 <RDex> i told helpdesk about it and they wanted to brand me as a hacker
14:21:02 <RDex> for even knowing about IRC
14:21:04 <mauke> lol wut
14:21:07 <PeakerWork> mauke: usually by lexical scoping people mean closure support as well
14:21:09 <copumpkin> what the hell?
14:21:11 <medfly> wtf?
14:21:12 <copumpkin> RDex: where are you?
14:21:15 <mauke> PeakerWork: people are wrong
14:21:17 <medfly> RDex, maybe use some online chat?
14:21:20 <medfly> like... web thing
14:21:24 <RDex> medfly, its blocked.
14:21:35 <RDex> ssh, everything
14:21:38 <copumpkin> damn
14:21:42 <medfly> RDex, what are you studying?
14:21:48 <RDex> comp sci
14:21:54 <copumpkin> I hate dumb sysadmins
14:21:54 <kmc> what kind of petty-fascist school is this?
14:21:56 <mauke> even http://webchat.freenode.net/ ?
14:22:04 <sinelaw> blocking tools for learning is ginormously stupid
14:22:12 <sinelaw> just because they can be misused
14:22:13 <copumpkin> sinelaw: TOOLS FOR CHEATING YOU MEAN!
14:22:14 <kmc> here, study CS, but don't go online to talk to the people who invented the stuff you're using!
14:22:18 <RDex> kmc... yeh
14:22:18 <medfly> what kind of school doesn't expect its CS students to be massive nerds? :)
14:22:21 <copumpkin> sinelaw: ZOMGZOMG etc.
14:22:33 <copumpkin> IRC is for hax0rz
14:22:34 <RDex> mauke, i dont know... OH that MIT client worked
14:22:36 <sinelaw> copumpkin the whole web is a tool for cheating, if you're looking for that
14:22:37 <RDex> mibbit?
14:22:43 <copumpkin> sinelaw: it should be banned!!
14:22:48 <medfly> mibbit, yeah... but I dunno if it connects here
14:22:54 <sinelaw> :)
14:22:57 <copumpkin> I think freenode blocked mibbit
14:23:02 <RDex> medfly, mibbit has been banned a lot of places
14:23:04 <medfly> I'd contemplate studying elsewhere, it sounds like a really bad school ;)
14:23:05 <c_wraith> I'm pretty sure freenode blocked mibbit over privacy concerns
14:23:19 <RDex> medfly, i transferred there to move back in with my parents.
14:23:31 <Vanadium> c_wraith: I am pretty sure it banned mibbit because it cannot ban individual mibbit users
14:24:17 <medfly> right, it did
14:25:36 <hgolden> RDex: If it makes you feel better, most companies ban IRC, too. So your college is preparing you for the "real" world.  ;-)
14:25:38 <c_wraith> oh.  that's a really good reason
14:26:39 <RDex> hgolden, lol. ok
14:26:50 <kmc> hgolden, citation needed
14:26:56 <kmc> my company sure doesn't ban IRC
14:26:56 <RDex> haha true
14:27:25 <PeakerWork> my company doesn't either
14:27:27 <Adamant> tech companies rarely ban IRC
14:27:29 <RDex> i worked helpdesk for an economic consulting firm
14:27:40 <RDex> for two years, they didn't have anything blocked
14:27:45 <Adamant> some even have internal IRC or Jabber channels
14:27:49 <hgolden> kmc: I've worked at 2 large aerospace / defense firms. Also I've read that many financial service companies ban it due to "insider trading" concerns.
14:27:58 <copumpkin> my school's network is (almost) completely unrestricted, we even get public IP addresses
14:28:00 <Adamant> finance has their own set of issues
14:28:02 <kmc> it could make sense to have internal chat but block external
14:28:09 <dejones> No instance for (Show (IO Int)) -- How can I get this out of the IO Monad without a do-block?
14:28:12 <RDex> copumpkin, university of wisconsin - madison is like that
14:28:12 <Adamant> they have to log everything said electronically
14:28:13 <copumpkin> RDex: petition to get them to open up educational stuff
14:28:23 <kmc> hgolden, i imagine defense is much more paranoid than typical
14:28:26 <Adamant> due to SEC concerns
14:28:29 <blackdog> dejones: you can't
14:28:37 <RDex> copumpkin, I am going to send them parts of this conversation
14:28:38 <hgolden> kmc: I agree internal OK, external blocked.
14:28:41 <kmc> dejones, "do" is just syntactic sugar for the operator (>>=)
14:28:44 <blackdog> you're trying to show something that can only be run
14:28:47 <dejones> blackdog: oh?  I thought I could use a lift somehow?
14:28:59 <kmc> :t liftM show
14:28:59 <lambdabot> forall a1 (m :: * -> *). (Show a1, Monad m) => m a1 -> m String
14:29:04 <copumpkin> RDex: sounds good :) I'm sure you can build a fairly large list of colleges that are fully open with their networks, and definitely loads of them that allow IRC and other such services
14:29:11 <hgolden> kmc: aerospace / defense SELLS paranoia!
14:29:17 <kmc> so in this case "liftM show" specialize to type IO Int -> IO String
14:29:20 <kmc> but note that the result is still IO
14:29:22 <blackdog> dejones: it's entirely possible, but that still won't give you an instance for Show (IO Int)
14:29:55 <roconnor> @quote haiku
14:29:56 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
14:30:03 <roconnor> @quote haiku
14:30:03 <lambdabot> FMota says: Haskell's cryptic form \ is natural to some folks \ and so is Haiku's
14:30:04 <kmc> no seasonal line
14:30:07 <roconnor> :/
14:30:19 <dejones> blackdog, kmc: basically, I'm trying to just print the value of something that's coming from the IO Int monad.  :/
14:30:20 <roconnor> @quote lilac
14:30:21 <blackdog> is natural to sumr folks?
14:30:21 <lambdabot> lilac says: <bohdan> how do I see the number of reductions required to calculate somethig? <lilac> bohdan: the usual method is to ask Cale to reduce it by hand :)
14:30:28 <kmc> dejones, print to output?
14:30:30 <kmc> :t print
14:30:31 <lambdabot> forall a. (Show a) => a -> IO ()
14:30:38 <dejones> blackdog, kmc: Yes, I'm using traceShow
14:30:39 <tuukkah> RDex, freenode now has official web client at www.freenode.net
14:31:03 <blackdog> dejones: is generally easier if you chuck a pastie up with an explanation of the problem
14:31:14 <RDex> tuukkah, thanks for the heads up
14:31:29 <kmc> :t let myIOComputation = return 3 in myIOComputation >>= print
14:31:30 <lambdabot> IO ()
14:31:41 <dejones> blackdog, kmc: this is the line of code "(traceShow (Judy.size block_store) bkey)"
14:31:47 <hgolden> tuukkah: I'm sure RDex's college will block that too.  :-(
14:31:51 <tuukkah> more precisely, http://webchat.freenode.net/
14:32:17 <dejones> blackdog, kmc: size :: JudyL a -> IO Int
14:32:24 <roconnor> @remember lilac class Monad m where / return and Kleisli compose / must form a monoid
14:32:25 <lambdabot> Okay.
14:33:19 <tuukkah> hgolden, yeah :-( going to a place like that, better have a data plan on your cell phone
14:33:31 <blackdog> dejones: full context would be more helpful
14:33:31 <RDex> I have an activity for you all, here is the problem: 'write a function diff x of type a -> Integer, that always returns 3 if dynamic scoping is used to evaluate it, and always returns 6 if static scoping is used to evaluate it
14:33:38 <RDex> I dont know the differente enough to even start on this
14:33:42 <hgolden> tuukkah: They probably jam cellphones too!
14:33:55 <blackdog> dejones: it's possible to cheat and use unsafePerformIO, but it's generally a bad idea
14:33:55 <tuukkah> hgolden =-D
14:33:58 <copumpkin> RDex: o.O
14:34:00 <dejones> blackdog, kmc: that really is the complete context.  I just want the size of the Judy array without using a do-block.
14:34:00 <RDex> where in the fuction would the condition go
14:34:12 <RDex> i mean how would it know to be evaluated dynamically
14:34:12 <RDex> \
14:34:12 <blackdog> ok. so why don't you want to use a do-block?
14:34:13 <mauke> RDex: you wouldn't use a condition
14:34:27 <RDex> ok
14:34:38 <dejones> blackdog: correct.  I want to get the value of size without a do-block.
14:34:45 <PeakerWork> RDex: that question is either a trick question (diff x = 6)  or indicates a serious misunderstanding of the question's author
14:34:48 <copumpkin> RDex: you'd just define it in two separate places I guess?
14:34:52 <blackdog> dejones: ... i asked why :)
14:35:10 <RDex> PeakerWork, I am getting that impression
14:35:11 <copumpkin> diff x = 6; main = ... where diff x = 3
14:35:17 <copumpkin> RDex: me too :)
14:35:18 <mauke> diff x = let v = 6 in let f () = v in let v = 3 in f ()
14:35:23 <blackdog> putStrLn $ unsafePerformIO $ Judy.size foo
14:35:29 <dejones> blackdog: because I am using traceShow for debugging, and i don't think I can inline a do-block as the second argument to traceShow
14:36:31 <PeakerWork> @pl diff x = let v = 6 in let f () = v in let v = 3 in f ()
14:36:31 <lambdabot> (line 1, column 8):
14:36:31 <lambdabot> unexpected "="
14:36:31 <lambdabot> expecting variable, "(", operator or end of input
14:36:35 <kmc> dejones, a do block can appear anywhere a value of type "m a" for some monad m can
14:36:37 <blackdog> dejones: ok. it's nothing to do with the do block. it's just that the type won't fit, for the simple reason that it's trying to stop you doing things that it can't guarantee the result of
14:36:41 <kmc> a do block is an expression like anything else
14:37:12 <blackdog> if you just want to hack it, use the unsafePerformIO trick. if you want to understand it, post more of your program and you'll get more help.
14:37:18 <dejones> blackdog: yes, you are right.  I need to get the size out of the IO Int monad for traceShow.  Not sure how to do that..
14:37:26 <Athas> I wonder if it's possible to construct a cut-down Prelude without typeclasses (and perhaps other complications?) that can be used for teaching new programmers.
14:37:27 <RDex> PeakerWork, copumpkin, the function uses a let and in command
14:37:28 <kmc> what is the type of traceShow?
14:37:30 <RDex> or whatever you call it
14:37:36 <dejones> blackdog: maybe I can use a lambda function?
14:37:38 <kmc> Athas, isn't that what Helium does?
14:37:51 <nomeata> dons: hi. sorry to bug you about it, but did you review my patches against X11 yet? I‚Äôd like to upload arbtt to debian soon, but it should have the unicode functionality, thus I have wait for a released X11 with the patches if I don‚Äôt want to patch the Debian package (which I don‚Äôt).
14:38:00 <dejones> kmc: traceShow :: Show a => a -> b -> b
14:38:14 <Athas> kmc: perhaps, I don't know what that is.  I will look at it.
14:38:21 <kmc> dejones, that's already using unsafePerformIO isn't it?
14:38:32 <Athas> nomeata: I know of a few bugs in X11, what does your patches fix?
14:38:37 <dejones> kmc: I don't think so.  http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Debug-Trace.html
14:38:40 <blackdog> dejones: you are not listening to me. the type system has been set up to stop you doing it. if you want to do it, you _have_ to use a backdoor.
14:38:43 <kmc> yeah it is
14:38:49 <dejones> oh?
14:38:54 <dejones> blackdog: hmm...
14:38:56 <kmc> blackdog, he's already using the backdoor
14:39:01 <nomeata> Athas: the X11 bindings, that is. Reading window titles with unicode characters. See http://darcswatch.nomeata.de/repo_http:__darcs.haskell.org_X11.html for the patches
14:39:03 <Liam> It isn't possible to merge two datatypes like this, is it? data D = D1 | D2
14:39:03 <kmc> and doesn't know it
14:39:08 <benmachine> @src trace
14:39:08 <lambdabot> trace string expr = unsafePerformIO $ do
14:39:09 <lambdabot>     hPutStrLn stderr string
14:39:09 <lambdabot>     return expr
14:39:21 <blackdog> kmc: yes. trace needs it anyway, but he'd need to use it again if he also wants to run Judy.size
14:39:36 <kmc> dejones, traceShow does IO without using the IO monad.  that's generally a bad thing to do, as your IO might never happen, might happen more than once, or might happen at an unexpected time
14:39:40 <benmachine> or you could use it directly without involving trace
14:39:41 <Athas> nomeata: oh, hm.
14:40:03 <kmc> but, since you already incur this risk, just use unsafePerformIO on your judy function
14:40:03 <hgolden> RDex: Are you using a particular text in class or are there online notes. The question doesn't make much sense to me in isolation.
14:40:14 <dejones> kmc: alright, will try that
14:40:25 <kmc> imo it's okay to do this sort of thing for debugging
14:40:35 <RDex> hgolden, the problem is that its an ML class, we have a book on ML. The teacher is having us use haskell right now but not giving us any reference material
14:40:43 <kmc> but beware that the print will happen when the expression is *evaluated*, not when it's constructed, due to laziness
14:40:57 <kmc> RDex, have you looked at some of the online Haskell tutorials?
14:41:00 <RDex> hgolden, its not very intuitive at all.
14:41:00 <hgolden> RDex: Your teacher is a sadist!
14:41:17 <dejones> kmc: ok, thanks.  :)
14:41:22 <dejones> thanks blackdog too.
14:41:26 <RDex> lol, hgolden, its a bit tough
14:41:38 <benmachine> Liam: you can't re-use constructors but you could do e.g. data D = Thing D1 | OtherThing D2
14:42:00 <benmachine> that pretty much makes D similar to Either D1 D2
14:42:07 <hgolden> RDex: I have Paulson's ML book. Are you using that one?
14:43:05 <RDex> hgolden, no, Modern Progrtamming Languages by Adam Brooks Webber
14:43:15 <Liam> benmachine, thanks... I'm having kind a problem like RDex. A teacher that directly starts in Haskell by doing binary searchtrees without giving even an introduction to Haskell... -.-  And yes, he must be a sadist.
14:43:22 <yitz> jims: hi. are you the person doing the snap framework?
14:43:53 <hgolden> RDex: I don't have that one. I'll google it.
14:44:23 <kmc> Liam, correct.  Haskell has no union types in the C sense, because it'd be unsafe.  what if you put in a T1 then ask for a T2 back out?  it only supports the *tagged* unions where values are differentiated by adding on a constructor
14:45:12 <Liam> Ah... So that means that I'm always forced to use constructors to create a new data type, right?....
14:45:17 <kmc> yes
14:45:20 <kmc> but there is also "type"
14:45:28 <kmc> which does not create a new type at all, but only a new name for an existing type
14:45:32 <kmc> and does not introduce new constructors
14:45:39 <kmc> "data" and "newtype" both do.
14:45:43 <yitz> hi Liam. where are you taking this course?
14:46:19 <yitz> Liam: I'm asking because I know a place where the teacher of the programming languages course is actually named Liam :)
14:46:23 <kmc> (in general, you can do typesafe untagged unions by allowing only the intersection of valid operations on those types... in haskell this could be accomplished with a typeclass and an existential)
14:46:50 <Liam> yitz, I'm from Germany...^^ No... But kinda funny.^^
14:47:12 <yitz> ok :)
14:47:59 <hgolden> RDex: So is this a programming languages survey course or an ML course?
14:48:29 <tuukkah> http://darcswatch.nomeata.de/ is interesting
14:48:45 <copumpkin> nomeata is here!
14:48:50 <nomeata> tuukkah: I‚Äôm happy to answer questions :-)
14:48:52 <RDex> hgolden: uhmmmm  i think we r going to go ver haskell and some techniques in java
14:49:08 <nomeata> copumpkin: are you trying to warn him before he says something that I should not hear? :-)
14:49:14 <copumpkin> lol not at all
14:49:17 <copumpkin> just saying "ask him questions!"
14:49:25 <copumpkin> :)
14:49:40 <tuukkah> =) i learned about this from the link nomeata pasted
14:50:23 <nomeata> tuukkah: note that to use it, just CC your patches to darcswatch@nomeata.de and tell me about any missing repositories you care about.
14:51:39 <tuukkah> nomeata, what i'd like to see one day is tracking of the various locations of a project repository. "this repo here has five additional patches compared to the official repo there"
14:52:31 <nomeata> tuukkah: this sounds more like patch-tag.com, which is github for darcs
14:52:51 <nomeata> tuukkah: although I could add comparison between repositories to darcswatch, there just was no use for it yet.
14:53:13 <tuukkah> nomeata, well, patch-tag.com and the likes are not distributed
14:53:49 <nomeata> tuukkah: right, that fits my thoughts on http://www.joachim-breitner.de/blog/archives/344-About-the-Freedoms-of-Web-Services.html that I just put down this evening.
14:56:48 <hgolden> RDex: I'm stumped about the kind of questions you posed. Sorry.  :-(
14:57:01 <RDex> hgolden: okay
14:57:29 <RDex> this japanese ISP kddi has 50/10 aDSL for $20 a month
14:58:06 <RDex> I need someone to hook me up with a VPN over there
15:00:58 <RDex> hgolden: this is the answer i have,  but unfortunately I dont understand it
15:01:11 <tuukkah> nomeata, that's a good writeup. i'm coming to this from the linked data point of view: foaf for decentralised social networks, sioc for decentralised microblogging and irc logging... it provides a basis on the access, data format, api and federation aspects
15:01:29 <RDex> like if I saw it i would be able to tell you that this gives a different answer if scoped dynamically or if it was evaluated using static scoping
15:01:45 <RDex> @hpaste
15:01:46 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:03:01 <RDex> hgolden, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4478#a4478
15:05:17 <mauke> RDex: well, 'd2' uses 'a' in its body. the question is: which 'a'?
15:05:46 <mauke> from looking at the code we can see that the 'a = 6' definition is in scope when d2 is defined
15:05:53 <mauke> that's lexical scope
15:06:41 <mauke> at runtime there's another definition active: 'a = 3' (in d1, before the call to d2)
15:07:05 <mauke> with dynamic scoping d2 would look for variables in its caller's scope
15:13:22 <nomeata> tuukkah: I‚Äôm going offline. If you have comments regarding darcswatch, better send me a mail, I‚Äôm not often on IRC.
15:15:40 <tuukkah> nomeata, sure. or comment on your blog :-)
15:16:02 <Paczesiowa> dons: what's the status of ghc's constructor specialisation? I  don't think it's working with 6.10. is 6.12 required to fully utilise stream-fusion?
15:16:22 <dons> Paczesiowa: it is fully working in 6.8.x
15:16:36 <dons> since late 2007.
15:17:08 <Paczesiowa> S.sum $ S.map square $ S.filter even $ S.enumFromToInt 1 n `S.append` S.enumFromToInt 1 n
15:17:22 <Paczesiowa> dons: I still get one loop with Left/Right tags for both streams
15:18:10 <Paczesiowa> dons: concatMap looks terrible
15:20:24 <dons> concatMap requires the static argument transformation, you have to turn that on explicitly, iirc.
15:20:40 <dons> you shouldn't see any tags.
15:21:22 <dons> play around with some of the extra inlining flags. and talk to rl, he's actively working on fusion stuff at the moment, so will have more info.
15:21:38 <chaosape> kmc: thanks a ton! Here is the final version (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11144#a11145). Now I can parameterize my somethings with a phantom type and your associated type suggestions saves me from writing lots of instances!
15:21:47 * ddarius doesn't remember variadic templates from his C++ days.
15:21:49 <chaosape> do ... sorry
15:21:53 <chaosape> wrong window
15:22:07 <hgolden> RDex, mauke: Is the question that is being asked: "Which one is the way Haskell works?" ? If not, is this just a pathological trick?
15:23:09 <Paczesiowa> dons: does he hang out here?
15:24:19 <dons> nope.
15:25:02 <Paczesiowa> dons: ok, I'll email him. thank you
15:46:10 <shellsage> is there a function in the standard prelude to yield the given value?  e.g. somefunction 4 => 4
15:46:24 <SimonRC> id
15:46:26 * SimonRC goes away
15:46:36 <shellsage> ty
15:49:50 <benmachine> unsafePerformIO . return
15:52:19 <copumpkin> that looks useful
15:53:53 <Saizan> i'm not even sure that's id!
15:54:01 <benmachine> nor am I
15:54:10 <benmachine> interesting to find out though
15:54:23 <benmachine> my guess is you wouldn't be able to tell the difference usually
15:54:32 <benmachine> but it might get treated differently by optimisation
15:54:35 <benmachine> or
15:54:37 <benmachine> something
15:54:49 * benmachine is trying to sound authoritative about things he doesn't know anything about
15:54:51 <Saizan> it might mess with exceptions
15:54:53 <benmachine> (again)
15:58:58 <copumpkin> I think it's indistinguishable from id
16:02:34 <mercury^> What about (unsafeCoerce :: IO a -> a) . return?
16:02:41 <existed> heyy
16:05:29 <crutex> anyone here good with linear algebra
16:05:35 <Saizan> mercury^: that probably segfaults
16:06:12 <ezyang> crutex: Ask your question.
16:06:24 <crutex> i'm solving Ax=b for x
16:06:25 <crutex> given A and b
16:06:34 <crutex> and am supposed ot provide a 3d surface plot of the solution
16:06:41 <crutex> but x is just a vector isn't it?
16:06:42 <ezyang> sure.
16:06:54 <crutex> :S so how do i get a 3d plot from it
16:06:55 <ezyang> You're being asked to plot the nullspace
16:07:12 <crutex> also, its all values 1 and 0 in the answer i am getting
16:07:41 <ezyang> clarify?
16:07:51 <crutex> the values of x are all 0 or 1
16:07:55 <ezyang> Also, do you happen to know what the rank of (A) and (A|b) are?
16:08:02 <ezyang> hm
16:08:24 <ezyang> So, you won't be able to do this generally in 3d space
16:09:14 <jimi_hendrix> anyone have a good example implementation of how to solve the subset sum problem?
16:09:17 <ezyang> Since for Ax = b, the number of free parameters are n - rk(A) (assuming that it has a solution)
16:09:17 <copumpkin> crutex: #math may be a more appropriate venue for this
16:09:23 <crutex> #math are all arseholes
16:09:49 <copumpkin> :t any ((==0) . sum) . filterM (const [False, True])
16:09:51 <lambdabot> forall a. (Num a) => [a] -> Bool
16:09:56 <copumpkin> jimi_hendrix: there you go :)
16:10:03 <copumpkin> ;)
16:11:16 <jimi_hendrix> xD
16:11:34 <jimi_hendrix> what does the forall thingie mean again
16:11:54 <copumpkin> it isn't even necessary, and is often implicit in a type signature
16:11:56 <Twey> Nothing important
16:12:00 <Twey> (here)
16:12:03 <copumpkin> that type signature is equivalent to (Num a) => [a] -> Bool
16:12:23 <crutex> ezyang n=25, A is an n^2 x n^2 matrix, and b is n^2 x 1 vector
16:12:46 <copumpkin> the forall just makes it explicit that the `a` type variable must work for all types that are instances of Num
16:13:00 <jimi_hendrix> copumpkin, do i need to import anything to use that?
16:13:10 <copumpkin> jimi_hendrix: Control.Monad
16:13:29 <copumpkin> jimi_hendrix: it's a brute force solution, which is pretty much the best you can do (within constant factors, at least)
16:13:41 <roconnor> Who was the persion here making the Enumerable class?
16:13:46 <copumpkin> roconnor: me :)
16:13:47 <roconnor> a couple of months ago
16:14:01 <jimi_hendrix> ok
16:14:03 <Philonous> When loading a file in ghci, can I tell ghc which package to import a module from?
16:14:07 <copumpkin> roconnor: is it broken?
16:14:07 <roconnor> copumpkin: did you see the Mathematics and Computation post on Oct. 12?
16:14:11 <copumpkin> nope
16:14:25 <roconnor> where Andrej enumarates (Nat -> Bool) -> Bool
16:14:37 <roconnor> http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
16:14:37 <copumpkin> oh, nope
16:14:44 <copumpkin> I'll check it out, thanks :)
16:14:46 <jimi_hendrix> then how do i use that oneliner on an array?
16:14:59 <copumpkin> jimi_hendrix: convert it to a list first :P
16:15:17 <jimi_hendrix> ...
16:15:20 <jimi_hendrix> curse you C!
16:15:22 <copumpkin> lol
16:15:29 <jimi_hendrix> ok, how do i use that one liner on a list
16:15:38 <copumpkin> it's a function
16:15:42 <copumpkin> call it on the list :P
16:15:53 <roconnor> > denum (unfn (\alpha -> alpha 0 && (alpha 7 || not (alpha 13))))
16:15:53 <jimi_hendrix> putting the list at the end of the line?
16:15:54 <lambdabot>   Not in scope: `denum'Not in scope: `unfn'
16:15:54 <roconnor> 87817326431460771517190893150548229499215350322029536332330582392
16:15:56 <roconnor> (... plus 20 more lines or so)
16:15:59 <copumpkin> > any ((==0) . sum) . filterM (const [False, True]) $ [1..5]
16:16:00 <lambdabot>   True
16:16:07 <copumpkin> hmm, whoops :)
16:16:12 <copumpkin> one minor bug there
16:16:26 <copumpkin> > any ((==0) . sum) . filter (not . null) . filterM (const [False, True]) $ [1..5]
16:16:28 <lambdabot>   False
16:16:39 <copumpkin> > any ((==0) . sum) . filter (not . null) . filterM (const [False, True]) $ [-2..4]
16:16:40 <lambdabot>   True
16:17:16 <jimi_hendrix> xD
16:17:25 <copumpkin> roconnor: he needs TeX support in his blog :)
16:18:30 <jimi_hendrix> so correct version copumpkin would be
16:18:39 <roconnor> copumpkin: TeX isn't so great at reflowing to fit the window size
16:19:16 <copumpkin> roconnor: I mean just for particular equations. The 22N is rather ugly, even though I know it's meant to be superscripted
16:19:59 <roconnor> copumpkin: huh?  What is your user agent?
16:20:01 <copumpkin> oh, he's even got LaTeX in his html source
16:20:03 <copumpkin> safari
16:20:11 <copumpkin> does he use jsmath or something?
16:20:16 <copumpkin> and it just isn't loading for me?
16:20:31 <roconnor> oh, I think he uses mathml or something
16:20:54 <roconnor> there is a mathml link in the top right corner
16:20:55 <copumpkin> does it show up reasonably on your browser? http://snapplr.com/ag7f is what it looks like to me
16:20:57 <copumpkin> ah
16:21:20 <copumpkin> he should use jsmath :P
16:22:32 <roconnor> heh
16:22:46 <roconnor> I will show you how I see it, but I need to download a screen capture program
16:23:13 <copumpkin> I'll see if I can get me some mathml support in safari
16:23:28 <jimi_hendrix> copumpkin, so how do i fix that bug in there
16:23:40 <copumpkin> jimi_hendrix: I fixed it
16:23:51 <copumpkin> ny ((==0) . sum) . filter (not . null) . filterM (const [False, True])
16:24:03 <copumpkin> not as pretty, but we'll live
16:24:04 <copumpkin> the other option is
16:25:11 <copumpkin> meh, having the sum of [] be 0 is ugly
16:25:15 <copumpkin> although nice in other contexts
16:25:35 <ezyang> Why?
16:25:46 <Twey> It's useful
16:25:48 <copumpkin> it is
16:25:53 <Twey> And, well
16:25:56 <Twey> Mathematically correct
16:25:57 <BMeph> > filterM (const [False, True]) [1..3]
16:25:57 <copumpkin> it just means I need to add an additional filter to that :P
16:25:58 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
16:26:06 <copumpkin> or a tail I guess
16:26:07 <jimi_hendrix> copumpkin, so it is designed to be true if the elements add up to >= 0?
16:26:21 <copumpkin> jimi_hendrix: you can read it like a sentence (backwards)
16:26:24 <Twey> If you take all the terms away from one side of an equation, you're left with a total of 0
16:26:26 <crutex> ezyang i figured it out ;P and its plotting into an extruded plus sign
16:26:36 <ezyang> ok
16:26:49 <Twey> If you want it to die, write foldr1 (+) instead
16:26:55 <copumpkin> Twey: then it will always die
16:27:16 <BMeph> Only on the nil. ;)
16:27:17 <Twey> Hmm?
16:27:18 <Twey> Yes
16:27:24 <copumpkin> jimi_hendrix: filterM (const [False, True]) generates all subsets (lists) of a given list, filter (not . null) gets rid of the trivial subset, and any ((==0) . sum) asks if any of these subsets has a sum of 0
16:27:41 <jimi_hendrix> what do folds do again (memory leak)
16:27:46 <roconnor> copumpkin: what I see: http://imgur.com/WJtti.png
16:27:54 * BMeph uses 'zP' for '(==0)'
16:27:57 <copumpkin> roconnor: oh pretty
16:28:00 <Twey> jimi_hendrix: foldr.com foldl.com
16:28:14 <jimi_hendrix> ?
16:28:26 <copumpkin> jimi_hendrix: visit those on your web browser
16:29:10 <Twey> ‚Ç•e uses (== 0) for (== 0).
16:29:15 <Twey> Er, /me
16:29:19 <jimi_hendrix> foldl.com redirects
16:29:22 <copumpkin> damn, did someone steal foldl.com?
16:29:36 <Twey> WTF
16:29:38 <Zao> @type com
16:29:39 <lambdabot> Not in scope: `com'
16:29:48 <Zao> Aaw, composing imaginary functions.
16:29:50 <Twey> foldl.com got marked as a phishing site‚ÄΩ
16:30:09 <Twey> Haha
16:30:10 <copumpkin> Twey: someone sniped the domain I think
16:30:15 <Twey> Huh.  ‚òπ
16:30:48 <BMeph> I wonder why Andrej didn't use "type Nat = Word" - does he not like it, does he need to use functions that explicitly want an Int, does he not know about it,...
16:30:50 <Ferdirand> google has it in cache
16:31:15 <roconnor> BMeph: did you see that big Nat in the post?
16:31:15 <Twey> > negate 1 :: Word
16:31:16 <lambdabot>   18446744073709551615
16:31:36 <Twey> Oh, of course
16:31:44 <roconnor> BMeph: 1798 digits
16:32:01 <roconnor> > abs (minBound)
16:32:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:32:02 <lambdabot>    `GHC.Enum.Bounded a'
16:32:02 <lambdabot>    ...
16:32:12 <roconnor> > abs minBound :: Int
16:32:13 <lambdabot>   -9223372036854775808
16:32:52 <roconnor> BMeph: ignore me
16:33:15 <copumpkin> that seems like a bug
16:33:21 <copumpkin> but I can see why it happens
16:33:23 <benmachine> Int seems like a bug :P
16:33:37 <copumpkin> if you mean its ubiquity, I agree
16:33:42 <BMeph> roconnor: Gee, thanks, after looking hard for where he used a Nat instead of a Natural, NOW you tell me to ignore you... ;)
16:41:35 <ARMuser> is there a ghc room?
16:41:42 <copumpkin> #ghc
16:41:50 <copumpkin> (somewhat unsurprisingly :P)
16:43:54 <ARMuser> ghc SUCKS DICK
16:44:13 <copumpkin> ARMuser: it is a compiler and has no mouth
16:44:22 --- mode: ChanServ set +o Igloo
16:44:39 --- mode: Igloo set +b *!*@kansas.shawnetworks.com
16:44:46 --- kick: ARMuser was kicked by Igloo (Igloo)
16:47:24 <Liam> Hm, I'm again unsure about something, hope you'll can help me again. We had a task where we had : -- big	:: Int -> IntTree -- big n = Node (big (2*n)) n (big (2*n+1)) ... This is an non-ending recursion, is it?!? We need to rewrite it to another type... However I'll just want to be sure that till now I've got it right that it is an non-ending function
16:48:37 <blackdog> Liam: looks like a lazy infinite tree
16:49:15 <Liam> Okay... Then I'm happy again and try to understand the rest...
16:49:20 <Liam> Thanks!
16:58:48 <eu-prleu-peupeu1> hi
16:58:55 <eu-prleu-peupeu1> any hungarians around here?
16:59:39 <ivanm> I'm a trifle hungry; close enough? :p
17:00:05 <fnord123> how would one implement mappend for lists?
17:00:10 <fnord123> append?
17:00:19 <SmurfOR> anyone know why this example from RWH i copied out of the book is giving me this error? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4479#a4479
17:01:06 <copumpkin> eu-prleu-peupeu1: #haskell.hu
17:01:11 <ivanm> SmurfOR: check your indentation
17:01:20 <ivanm> SmurfOR: possibly a tabs vs spaces thing
17:01:43 <blackdog> SmurfOR: there's pristine source available for the book, too.
17:02:20 <ivanm> SmurfOR: especially since the if statement in mainloop is indented way too much
17:04:29 <Cale> SmurfOR: Yeah, make sure to configure your editor not to put tabs in source files, it's really bad.
17:05:22 <Cale> (there are multiple indentation problems in the source caused by tabs, as you can see when the tabs are expanded to align to 8 space boundaries like they are by the compiler)
17:09:35 <SmurfOR> Cale, i have vim setup to use soft tabs but not correctly, thanks :)
17:13:13 <ACSpike[Home]> what is a *.hi file?
17:13:58 <ivanm> haskell interface file
17:14:01 <aeron> ACSpike: "hello internet" file
17:14:05 <ivanm> lets the compiler knkow what's in that module
17:14:06 <ivanm> aeron: heh
17:14:20 <aeron> it literally prints "hello world" to every IRC server
17:14:22 <aeron> regardless of the contents
17:14:51 <ivanm> aeron: it is possible to take a joke too far...
17:16:26 <nsfx> i'm interested in hearing people's opinions of functional programming languages with regard to likelihood of 'survival' and practicality.. i know there will be a haskell bias here but i couldn't  find a general fp channel ;x
17:16:58 <ivanm> they'll survive, grow and eventually conquer
17:17:00 <jimi_hendrix> is there a collect type function that iters over an array, calling a function on each element, and putting all of the values returned from the calls in an array, which is returned
17:17:09 <ivanm> nsfx: look at how much FP stuff has been stolen and put into non-FP langs
17:17:19 <nsfx> ivanm: i hold the same prediction
17:17:22 <ivanm> jimi_hendrix: you mean a map or a fold?
17:17:40 * jimi_hendrix face palms
17:17:43 <jimi_hendrix> ya map would work
17:17:43 <medfly> they're still non-FP languages, right?
17:17:46 <nsfx> esp sine cpus aren't really getting faster.. just more cores
17:18:02 <nsfx> need for more parallelization
17:18:04 <timemage> nsfx, given the fact that a lot of the current function programming languages in use are as old and in mare cases older than current procedural languages in use, and that the procedural languages of late seem to be adopting more functional features, i'd say survival is pretty much guaranteed.
17:18:13 <ACSpike[Home]> ivanm: where can I go if I want to read what is in that module (the haskell source)
17:18:18 <Axman6> nsfx: haskell's been growing for 20 yeard, i don't think i'll stop doing that now that it's actually becomming somewhat popular
17:18:29 <ivanm> ACSpike[Home]: the equivalent .hs or .lhs file
17:18:50 <ivanm> jimi_hendrix: there's a map for arrays, don't recall the actual function name
17:19:00 <gwern> Axman6: on such a small base, growing for 20 years isn't much of an accomplishment!
17:19:01 <ivanm> hey Axman6
17:19:01 <nsfx> and what of practicality? i've read a few articles
17:19:04 <medfly> I somehow think that it's best some languages are not popular, I've been to ##php and I have to say it ain't the nicest thing
17:19:08 <jimi_hendrix> i keep saying array when i mean list...
17:19:18 <nsfx> about impractical haskell vs ocaml being better blah blha
17:19:32 <nsfx> i know there will always be religious wars
17:19:55 <nsfx> i guess what i want is not reasonable: someone to grab me and say LEARN THIS ONE ;]
17:20:10 <medfly> if you're that indecisive learn both
17:20:41 <aconbere> when wanting to run an application with profile enabled, that requires that the apps that it depends on be compiled with profiling as well. Is there a good way to tell cabal to rebuild a set of packages with profiling enabled.
17:20:45 <aconbere> ?
17:21:14 <nsfx> do you believe all stateful apps have a functional equivalent?
17:21:30 <ivanm> aconbere: dunno, but you can enable profiling in ~/.cabal/config as a default...
17:21:34 <dibblego> the pure lambda calculus is turing complete, ergo yes
17:21:38 <aconbere> ivanm: interesting
17:21:59 <blackdog> nfsx: and there's nothing wrong with state. haskell is just more precise about where and when it's allowed to be updated.
17:22:07 <aconbere> ivanm: is there just a way to pass that option through the command line (I can edit .cabal file by hand but would rather not)
17:22:17 <repnop> computers are useless without a state in many aspects :P
17:22:21 <ivanm> aconbere: yes, but I don't know the exact incantation ;-)
17:22:28 <nsfx> blackdog: via do blocks from what i've read? is that correct?
17:22:29 <blackdog> --enable-library-profiling, i believe
17:22:47 * aconbere goes to look again
17:22:57 <blackdog> nsfx: erm. that's sort of an 70% true lie, if that makes sense
17:23:06 <ACSpike[Home]> ivanm: thanks. I had to get the source package. duh! :-)
17:23:11 <aconbere> blackdog: that looks right :)
17:23:12 <ivanm> heh
17:23:15 <aconbere> ivanm: thanks :)
17:23:50 <blackdog> nsfx: to expand a bit: "do" blocks are a syntactic shortcut for dealing with monads, which are defined in terms of ">>=" and "return"
17:24:07 <nsfx> monads! it haunts me
17:24:08 <blackdog> one of the things monads are good for is handling IO, but it's not the only thing
17:24:18 <nsfx> a guy tried to explain that to me for an hour.. i just don't understand it
17:24:23 <blackdog> they're not complex. they really aren't. people build them up.
17:24:33 <nsfx> he kept making hand gestures
17:24:37 <blackdog> and you think you don't understand them because you think there must be more to get
17:24:48 <nsfx> left hand, right hand, interlock
17:24:51 <nsfx> heh
17:25:30 <lament> monads are not complex. Not at all. They really aren't. The complexity is all in your head. You just need to look at them the right way and then you'll see how simple they are. Nothing can be simpler than monads.
17:25:41 <lament> Very, very simple.
17:25:45 <nsfx> alright :)
17:25:50 <nsfx> that's a nice thought :)
17:26:10 <lament> Just keep repeating that every night as you go to sleep, and eventually you will become enlightened. This might take year
17:26:13 <lament> s
17:26:20 <nsfx> haha
17:26:44 <blackdog> the real problem is that people try to use analogies to explain them
17:26:51 <stroan> Yeah, the thing about getting monads is there isn't anything to get
17:26:58 <stroan> took me a long to to get that :P
17:26:58 <blackdog> but the analogies are already more complex than the thing itself
17:27:08 <nsfx> ahaha yes
17:27:10 <medfly> ....
17:27:11 <blackdog> stroan: it's a wise man who knows how ignorant he is
17:27:11 <ddarius> Indeed, what is complicated about a functor and two natural transformations satisfying some straightforward laws.
17:27:13 <nsfx> all the sound effects and hand gestures
17:27:18 <medfly> took you a long time to get that you don't need to get anything...
17:27:33 <nsfx> and using the word 'monadic' in defining the term 'monad'
17:27:34 <nsfx> that really bothered me
17:27:55 <stroan> blackdog: not sure what you mean there :) taking it as a compliment ;)
17:28:09 <Warrigal> I once understood monads; later, I understood them. I have no idea why.
17:28:21 <Warrigal> That was around the time I learned what a Cartesian product is.
17:29:11 <lament> A monad that's like a monad is not a monad. To achieve understanding, you must empty your mind.
17:29:23 <Warrigal> Anyway, I have a module that begins with this: module Hmm (,Database,mmParseFromFile,...
17:29:38 <ivanm> it starts with (, for the export list?
17:29:44 <ivanm> it exports the non-existing item? :p
17:29:52 <Warrigal> Hugs complains of a syntax error, saying that the symbol "Database" was unexpected.
17:29:59 <Warrigal> (What was it expecting?)
17:30:05 <nsfx> http://tinyurl.com/yf5wz4p this is interesting
17:30:21 <ivanm> nsfx: get rid of that first extraneous comma
17:30:29 <Warrigal> Perhaps I should just get rid of that first extraneous comma.
17:30:38 <ivanm> s/nsfx/Warrigal/
17:30:48 <Warrigal> ivanm, thank you for inspiring me to come up with this idea. I'll give you half of the credit.
17:31:01 <zhou> a newbie question,
17:31:07 <ivanm> heh
17:31:12 <ivanm> (not you, zhou)
17:31:15 <Warrigal> I expect to get a much more exciting error now.
17:31:26 <Warrigal> zhou: ello!
17:31:28 <zhou> is there a way to specify a bit pattern such as what erlang can do in haskell Mem = <<Red:5, Green:6, Blue:5>>.
17:31:46 <Warrigal> Well, what does that bit of code do?
17:31:49 <zhou> where Mem being a 16bit word, and have the first 5 bits for Red color,
17:32:00 <ivanm> zhou: there are IIRC, but not as conveniently as in erlang
17:32:03 <Warrigal> Hmm, I think I see.
17:32:07 <ivanm> because Haskell doesn't really do much of that kind of thing
17:32:11 <ddarius> zhou: No, but you could implement something like that using view patterns.
17:32:36 <zhou> hmm, ddarius, can you explain?
17:32:42 <Warrigal> Hey, the module loaded. I didn't expect that.
17:33:58 <ivanm> @remember Warrigal Hey, the module loaded. I didn't expect that.
17:33:58 <lambdabot> I will never forget.
17:34:24 <zhou> also this pattern <<R1:5, G1:6, B1:5>> = Mem
17:35:53 <ddarius> zhou: You could make something that looked like: f (bitsyntax -> (Bit B5 r, Bit B6 g, Bit B5 b)) = ... uses r, g, b ...
17:36:24 <jimi_hendrix> if i have a function func that takes an arg thats of type [Integer] and a function someOtherFunc that returns [a] and takes [a] can i do: func (someOtherFunc someIntegerList)
17:36:43 <adu> yes
17:37:28 <adu> only if 'a' is Integer
17:38:41 <Axman6> ivanm: o/
17:38:42 <zhou> ddarius: Bit B5 is a constructor of a new type i assume? is bitsyntax also a type?
17:39:24 * Warrigal runs HmmTest.hs, and wonders whether it's *supposed* to work.
17:42:50 <ddarius> bitsyntax would, most conveniently, be a class method.  Bit would be a data constructor of a type like, data Bit b a = Bit b a.  B1,...,B32 would be constructors of the form data B1 = B1.  The class would look something like: class BitSyntax d r where bitsyntax :: d -> r.  You'd have a variety of instances like instance BitSyntax Word32 (Bit B5 Word32) where bitsyntax w = Bit B5 (w .&. 31)
17:42:59 <ddarius> It would be very magical.
17:43:38 <ddarius> Essentially the instance selection would be based on the form of the return type which would be specified by marker constructors in the pattern when you pattern match against the result of bitsyntax.
17:44:32 <ddarius> Unless you need to do a whole variety of different bit manipulation things like this, or you want to do something interesting, I would just write some helper functions to do the bit manipulations you needed.
17:45:57 * Warrigal decides that the test is supposed to fail.
18:03:36 <ben_m> Alright, I'm stuck at an Exercise :/
18:03:46 <ben_m> I'm reading "Understanding arrows" on wikibooks
18:04:10 <ben_m> And it wants me to implement second using arr, (>>>), first and a function I wrote to swap the values of a tuple
18:04:25 <ben_m> my try is second' = arr swap >>> first >>> arr swap
18:05:18 <ben_m> swap = uncurry $ flip (,)
18:05:56 <jimi_hendrix> what does filterM do?
18:05:59 <jimi_hendrix> vs filter
18:07:04 <c_wraith> jimi_hendrix:  It works with functions that return Monad m => m Bool, rather than Bool
18:07:25 <c_wraith> :t filterM
18:07:26 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
18:07:52 <opdolio> @type let eta f a = f <*> pure a in eta
18:07:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
18:09:03 <jimi_hendrix> also, where do i go when i finish learn you a haskell for great good?
18:09:21 <BMeph> Likewise, flip = curry (. swap) -- Did I get that right? :)
18:09:30 <blackdog> real world haskell. even better, find a project and use RWH to help you with it...
18:09:53 * jimi_hendrix is working a project
18:10:01 * jimi_hendrix is making a scopa game
18:10:30 * aeron is solving world hunger
18:10:34 <defun> I heard that ghc is developing dynamic linking. What's the point? That will only make upgrading
18:10:49 <defun> slightly more annoying.
18:10:58 <defun> what are the benefits of dynamic vs. static
18:11:02 <Absolute0> what's dynamic linking?
18:11:18 <defun> for example:
18:11:43 <defun> the compiler doesn't output a binary with all of the fucntions built in...
18:11:45 <defun> but rather
18:12:07 <defun> with references to functions in other .so files (shared objects aka dynamic libraries)
18:12:15 <Vanadium> Smaller binaries~
18:12:29 <c_wraith> Lower memory use when using several binaries at once
18:12:39 <Absolute0> thats what windows does with dll's right?
18:12:44 <defun> yes
18:12:48 <Absolute0> gotcha thanks
18:13:03 <twanvl> the ability to use LGPL libraries in non (L)GPL programs
18:13:12 <Absolute0> so only the user code gets outputed?
18:13:20 <Absolute0> everything else is linked at runtime?
18:13:22 <defun> ah yes. smaller binaries == faster load time
18:13:32 <defun> Absolute0: yes
18:13:41 <Absolute0> so why is that a bad thing?
18:13:42 <Absolute0> :)
18:13:45 <defun> linking is generally handeled by the OS
18:13:56 <c_wraith> I still don't read the LGPL as requiring dynamic linking.
18:13:56 <defun> it's not, it just seems kind of pointless to me.
18:14:13 <defun> c_wraith: I'm sure it doesnt
18:14:25 <c_wraith> Yet apparently that was one of the main reasons for the push
18:14:35 <c_wraith> So someone read it that way
18:14:43 <defun> dynamic linking is used by the linux kernel to enable the use of proprietary libraries/drivers like nvidia
18:15:03 <RDex> ahhhhhhhaskjfaskj, girlfriend trouble.
18:15:23 <defun> so dynamic linking is good if you want to keep your code closed, but use gpl libs, or something to that extent
18:15:27 <Absolute0> Is systems programming possible with haskell?
18:15:29 <ivanm> c_wraith: with LGPL, you have to be able to replace it at runtime or something
18:15:32 <twanvl> as I understand it, to comply with the LGPL you either need to use dynamic linking, or distribute the object files (or the source code of course)
18:15:50 <c_wraith> Those sound like descriptions of the GPL, not LGPL
18:15:51 <defun> Absolute0, yes, but it is still a research matter
18:16:06 <Absolute0> defun: since you need low-level access such that C provides
18:16:09 <ivanm> that was the whole deal with GHC linking to GMP for Integer
18:16:16 <defun> people have made OSs, filesystems, etc
18:16:27 <defun> yes, but they do bindings to C via FFI
18:16:29 <Absolute0> well i use xmonad window manager
18:16:36 <Absolute0> but thats not really systems programming
18:16:57 <defun> agreed
18:17:14 * Absolute0 wishes he found a haskell job
18:17:22 <c_wraith> I read the LGPL as only caring about changes you make the the library being distributed, regardless of linking.
18:17:24 <jimi_hendrix> how many people use haskell in work?
18:17:26 <Absolute0> i have an interview on tuesday for a c++ gig
18:17:32 <Absolute0> the code is just so messy
18:17:43 <BMeph> Sorry, it's flip = curry .(. swap) -- Did I get that right? :)
18:17:54 <jimi_hendrix> Absolute0, i am sorry
18:18:03 <defun> C is quite elegant for hardware bit twiddling, and haskell greate for high order concepts. Thus, FFIing between the two is magical.
18:18:05 <BMeph> Sorry, it's flip = curry .(. swap) -- I did get that right that time. :)
18:18:11 <Absolute0> plus c++ gives you a lot of choices
18:18:25 <Absolute0> which allows bad choices
18:18:26 <defun> Also, a virtual machine monitor has been written in haskell + FFI->C
18:18:31 <jimi_hendrix> C++ is nice until you combine its features
18:18:50 <repnop> C++ is nice when you want a stable pay check? ;)
18:19:05 <Cale> jimi_hendrix: http://yosefk.com/c++fqa/defective.html  :)
18:19:09 <defun> C++ is nice as long as you restrict yourself to a safe subset
18:19:10 <Absolute0> repnop: agreed
18:19:37 <Vanadium> defun: Is the safe subset you are thinking of C?
18:19:38 <Cale> A wonderful exposition of how all the misfeatures of C++ combine to form a clusterfuck larger than the sum of its parts ;)
18:19:39 <Absolute0> repnop: most ruby/python jobs are not real career opportunity
18:19:47 <defun> yes
18:20:00 <repnop> well i know people who been doing ruby as a career successfully.
18:20:06 <repnop> who have been*
18:20:11 <ben_m> I don't get the point of the arr function
18:20:18 <ben_m> If functions are already arrows, why do I need arr?
18:20:22 <defun> its like return or pure
18:20:31 <Absolute0> it really depends more on the corporation than the language
18:20:34 <repnop> depends on how badly you want it :)
18:20:40 <Absolute0> c++ corporations are usually bigger and pay more
18:20:45 <Absolute0> ruby is mostly startups
18:20:55 <defun> ben_m they are not arrows
18:21:08 <defun> they can be represented or abstracted via arrows
18:21:19 <defun> arrows allows for sexy data-flow programming
18:21:22 <ben_m> but f >>> some_arrow works just fine?
18:21:22 <BMeph> Cale: Would that be dissynergy? ;)
18:21:29 <ben_m> With f being a function
18:21:42 <defun> so does f >>= someMonad
18:21:54 <defun> :t (>>)
18:21:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
18:22:01 <defun> :t (>>=)
18:22:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:22:23 <defun> :t (>>>)
18:22:24 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
18:23:44 <ben_m> Apparently I don't understand anything :(
18:23:51 <ben_m> Just when I thought it finally clicked
18:24:01 <jimi_hendrix> how would i find the smallest list in a list of list
18:24:40 <ivanm> jimi_hendrix: fst . head . sortBy (compare `on` snd) . map (\xs -> (xs, length xs))
18:24:47 <ivanm> @type fst . head . sortBy (compare `on` snd) . map (\xs -> (xs, length xs))
18:24:48 <lambdabot> forall a. [[a]] -> [a]
18:24:56 <ivanm> jimi_hendrix: note that this fails for empty lists due to the head
18:25:08 <ben_m> What about minimumBy?
18:25:29 <jimi_hendrix> when do i just have this stuff come to me like magic
18:25:38 <BMeph> @type head . sortBy (comparing langth)
18:25:39 <lambdabot> Not in scope: `langth'
18:25:46 <BMeph> @type head . sortBy (comparing length)
18:25:47 <lambdabot> forall a. [[a]] -> [a]
18:25:54 <ivanm> ben_m: or thta ;-)
18:26:04 <ivanm> jimi_hendrix: when you've written a lot of code
18:26:15 <jimi_hendrix> do i need to import stuff?
18:26:16 <ivanm> BMeph: that will re-calculate length multiple times
18:26:23 <jimi_hendrix> haskell code i assume you mean
18:26:24 <ivanm> schwarzian transform ftw! ;-)
18:26:27 <ben_m> @type minimumBy (comparing length)
18:26:28 <lambdabot> forall a. [[a]] -> [a]
18:26:31 <ivanm> jimi_hendrix: Data.List(sortBy)
18:26:36 <ivanm> or, minimumBy
18:26:41 <ben_m> Data.Ord (comparing)
18:26:43 <ben_m> That too
18:26:48 <ivanm> @type fst . minimumBy (compare `on` snd) . map (\xs -> (xs, length xs))
18:26:49 <lambdabot> forall a. [[a]] -> [a]
18:26:59 <ivanm> ben_m: nah, that's bad
18:27:04 <ben_m> Oh :(
18:27:19 <ben_m> I had to import Data.Ord for comparing though
18:27:32 <jimi_hendrix> ivanm, `on` is not in scope
18:27:33 <twanvl> minimumWith and sortWith should be in the base library
18:28:11 <ivanm> jimi_hendrix: oh, Data.Function(on)
18:28:15 <BMeph> Data.Function (on)
18:28:32 <ivanm> ben_m: that will calculate the length multiple times
18:28:43 <ivanm> jimi_hendrix, ben_m:
18:28:50 <ivanm> http://en.wikipedia.org/wiki/Schwarzian_transform
18:29:19 <ben_m> I'm using that with Perl a lot
18:29:49 <ben_m> I'm not going to optimize Haskell code until I understand Haskell though :)
18:30:02 <BMeph> ben_m: Check the article, it cites the Perl programmer that discovered/encourages its use. :)
18:30:48 <jimi_hendrix> remind me card games are harder than one thinks they are to make
18:31:39 <defun> ben_m, I find that the best way to understand haskell start changing/improving other people's code (that, and read RWH and Functional Data Structures by Osaki (or some other japanese name))
18:31:50 <blackdog> okasaki
18:32:06 <defun> ben_m, also, start a serious (>4000 loc) project
18:32:16 <defun> blackdog: thanks
18:32:30 <RDex> @Hpaste
18:32:30 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:33:04 <RDex> hey room, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4480#a4480
18:33:09 <RDex> how do I call this function in haskell
18:33:17 <RDex> what do i type at the command prompt, winhugs.
18:33:45 <jimi_hendrix> defun, Osaki is a city i think
18:33:58 <RDex> jimi_hendrix Osaka
18:34:03 <jimi_hendrix> xD
18:34:11 <c_wraith> RDex:  That is a function with one argument, a three-tuple.
18:34:30 <RDex> c_wraith, what would I type so that hugs wont give me an error
18:34:32 <c_wraith> RDex:  you call it by passing it a single three-tuple
18:34:42 <defun> jimi_hendrix: 2 cities and a neighborhood in tokyo: http://en.wikipedia.org/wiki/Osaki
18:34:54 <RDex> c_wraith: what sort of values do three tuples take?
18:34:56 <ben_m> defun: That won't help me understand Arrows/Applicative Functors though, will it?
18:35:16 <defun> ben_m: lookup the typeclassopedia
18:35:23 <c_wraith> RDex: the generic type of a 3-tuple is (a, b, c).  the type variables can be anything.
18:35:27 <ben_m> Will read that Osaki book
18:35:31 <defun> they do a pretty good explanation
18:35:33 <ManateeLazyCat> @seen mmorrow
18:35:33 <lambdabot> Unknown command, try @list
18:35:37 <ManateeLazyCat> @seen mmorrow
18:35:37 <lambdabot> Unknown command, try @list
18:35:40 <ManateeLazyCat> @seen
18:35:41 <lambdabot> Unknown command, try @list
18:35:41 <c_wraith> RDex:  You'll have to look at the function to see what it expects for each type
18:35:47 <ManateeLazyCat> @list
18:35:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:35:50 <defun> ben_m: Okasaki doesn't cover arrows applicative etc
18:35:50 <ManateeLazyCat> @help
18:35:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:35:58 <ben_m> Yeah but it's still interesting :)
18:36:02 <defun> Yes.
18:36:09 <defun> It's very good.
18:36:19 <RDex> Main> w(a, b, c)
18:36:19 <RDex> ERROR - Undefined variable "c"
18:36:29 <RDex> c_wraith, what should I type instead
18:36:55 <defun> ben_m: http://www.haskell.org/haskellwiki/Typeclassopedia
18:37:02 <ManateeLazyCat> help <seen>
18:37:15 <ManateeLazyCat> > help seen
18:37:16 <ben_m> defun: Found it already, thanks
18:37:16 <lambdabot>   Not in scope: `help'Not in scope: `seen'
18:37:20 <c_wraith> RDex:  If you haven't named a value c, why do you think that would work?
18:37:26 <ManateeLazyCat> > @seen mmorrow
18:37:27 <lambdabot>   <no location info>: parse error on input `@'
18:37:39 <RDex> c_wraith, you said the variables could be anything, maybe elaborate
18:37:39 <ivanm> ManateeLazyCat: seen is gone from lambdabot
18:37:41 <ivanm> use preflex
18:37:42 <ManateeLazyCat> How to user bot seen someone?
18:37:44 <ivanm> preflex: seen mm_freak
18:37:44 <preflex>  mm_freak was last seen on #haskell 2 days, 4 hours, 28 minutes and 41 seconds ago, saying: indeed
18:37:57 <ivanm> ManateeLazyCat: the @seen plugin had memory leaks, etc. so it was removed
18:37:58 <ivanm> @uptime
18:37:58 <lambdabot> uptime: 22d 16h 16m 2s, longest uptime: 1m 10d 23h 44m 29s
18:38:11 <ManateeLazyCat> ivanm: Yesterday remove?
18:38:12 <ivanm> ManateeLazyCat: ^^ highest lambdabot has been up in a couple of years IIRC
18:38:17 <c_wraith> RDex: I said that in the generic case, a three-tuple can have any type for its arguments.  But the function puts some restrictions on them, by the operations it performs on them.
18:38:19 <ivanm> ManateeLazyCat: removed a couple of months ago I think ;-)
18:38:34 <ManateeLazyCat> preflex: see mmorrow
18:38:40 <c_wraith> RDex: It uses the expression "x == 1" inside it, so x must be some sort of number.
18:39:15 <ivanm> ManateeLazyCat: seen, not see
18:39:23 <c_wraith> RDex: It uses the expression "d : q" inside it, so q must be a list of something, and d is the same type as the elements of that list.
18:40:21 <c_wraith> RDex:  That suggests that the type of the function is (Num t) => (t, a, [a]) -> [a]
18:41:13 <c_wraith> RDex: So call it with a tuple containing a number, something, and a list of that something
18:44:19 <jimi_hendrix> whats a good beginner project for me to attempt in haskell...a card game is starting to seem a tad too over my head b/c i am not used to the functional magic
18:45:42 <hackagebot> xmonad 0.9 - A tiling window manager (SpencerJanssen)
18:45:44 <hackagebot> xmonad-contrib 0.9 - Third party extensions for xmonad (SpencerJanssen)
18:45:46 <hackagebot> GlomeVec 0.1 - Simple 3D vector library (JimSnow)
18:46:03 <Cale> jimi_hendrix: I suppose it depends on what you already know and what sorts of things you like to work on...
18:46:24 <Cale> jimi_hendrix: What problems are you having with your card game?
18:46:26 <jimi_hendrix> let bindings are local to do blocks right?
18:46:57 <Cale> Yeah, if you have a let inside a do, then it scopes over the rest of the do-block, including itself.
18:46:59 <c_wraith> @undo do { let x = 1 ; return x }
18:46:59 <lambdabot>  Parse error at "}" (column 27)
18:47:03 <jimi_hendrix> Cale, just general design issues, i might be able to fight through this though
18:47:19 <c_wraith> ...  Why did that have a parse error?
18:47:20 <c_wraith> oh
18:47:27 <c_wraith> @undo do { let {x = 1} ; return x }
18:47:27 <lambdabot> let { x = 1} in return x
18:48:16 <jimi_hendrix> and i have plenty of experience imperitive experience
18:48:21 <Cale> jimi_hendrix: You probably want to start out by defining functions for manipulating cards and collections of cards, and later positions or game states.
18:48:38 <jimi_hendrix> good point
18:48:59 <c_wraith> RDex:  How's it going with that?
18:49:01 <jimi_hendrix> like make a card library module
18:49:09 <jimi_hendrix> then implement the game around that
18:49:19 <Cale> So that you should be able to play a game at the ghci prompt without any sort of gui.
18:49:29 <c_wraith> jimi_hendrix:  Want my poker card module?  (I'm working on a card game very slowly, myself)
18:49:29 <Cale> (sort of)
18:49:51 <jimi_hendrix> c_wraith, i would be happy to take a look
18:50:16 <c_wraith> http://patch-tag.com/r/c_wraith/yomid/snapshot/current/content/pretty/src/Poker/Cards.hs
18:50:41 <jimi_hendrix> Cale, well i got past deck creation/shuffling and displaying the hand and cards in play
18:50:41 <c_wraith> You can see the rest of the project, as it stands, there too.  One of these days, I might even make it resemble playable. :)
18:51:30 <jimi_hendrix> its really the check if the played card has matches, and if it does, then what part
18:51:31 <Cale> jimi_hendrix: Yeah, the randomness thing can be a bit of a challenge if you're not used to passing around generator states.
18:51:48 <jimi_hendrix> i figured that out a while ago, but it was a pain
18:51:54 <Associat0r> defun you gotta be kidding me, calling C the safe subset of C++
18:52:11 <Cale> Associat0r: heh, it's practically true.
18:52:12 <jimi_hendrix> hey c_wraith just curious, why darcs?
18:52:19 <Associat0r> it's anything but safe
18:52:27 <Cale> Associat0r: Well, comparatively ;)
18:52:44 <Associat0r> Cale it's not
18:52:49 <defun> It's true. Especially if you use it with a C++ compiler.
18:53:04 <defun> due to stronger typing
18:53:06 <c_wraith> jimi_hendrix:  Because my company uses it at work, so I'm heavily familiar with it.  And I like the basic command-line interface, especially cherry-picking changes for each patch.
18:53:31 <defun> If you use a vanilla C compiler, it is less safe.
18:53:33 <happygu7262> GHC is a PIECE OF SHIT
18:53:35 <ddarius> I'm with Associat0r completely here.
18:53:40 <jimi_hendrix> i only have fundamental experience with git and bzr
18:53:40 <Cale> happygu7262: Why?
18:53:40 <happygu7262> not everyone is as rich as you COCKSUCKING DUMB BITCHES who have SHITLOADS of $$$ to buy expensive cpus with hardware floating point
18:53:50 <jimi_hendrix> how would you say darcs compares to those c_wraith
18:53:51 <RDex> c_wraith, I dont get it
18:53:58 <Cale> happygu7262: Is there a bug you need help with?
18:54:12 <RDex> c_wraith, should I be putting in integers or floats or spaces or what
18:54:17 <Cale> happygu7262: It would be more productive to use less inflammatory language.
18:54:20 <happygu7262> yeah sry how do you get software fp to work?
18:54:32 <RDex> c_wraith, nothing is jumping out at me as the right answer, i'm just getting errors that i don tfind intuitive at all
18:55:01 <c_wraith> jimi_hendrix:  I haven't used either sufficiently to make a strong statement.  I just am using what I'm familiar with.  As I understand it, they all have similar feature sets.  And aren't svn.  :)
18:55:19 <Cale> happygu7262: What error messages are you seeing? I've personally only used GHC on pretty well-supported platforms, so I'm not sure what you mean about floating point here.
18:55:55 <c_wraith> RDex: The function is polymorphic, so you can call it with...  Well, an unbounded number of types.  They just need to match up with the rules the compiler infers from the function body.
18:55:55 <jimi_hendrix> c_wraith, i never used svn for anything other than svn co <some_repo>
18:56:25 <RDex> c_wraith, what would you type? maybe that'll make everything click
18:56:45 <c_wraith> RDex:  Try calling it with (1, "x", ["y", "z"])  --  an Int, a String, and a [String]
18:56:56 <Cale> (The last time I used a machine with no hardware floating point was back in 1993 or something...)
18:57:18 * ivanm notes that happygu7262's nick seems wrong...
18:57:26 <RDex> c_wraith, what does d:q do, in my function
18:57:38 <happygu7262> cale: wait a min i'll get the eror
18:57:45 <defun> Associat0r: If you use a diverse set of features within C++, you will get messier and unsafer code. But if you keep to a small, well understood subset, your code will be more predictable (I personally prefer C as a subset)
18:57:52 <Cale> happygu7262: If the Double and Float types don't work and it doesn't just fail to compile programs altogether, you could always try sticking to fixed point arithmetic.
18:57:59 <alatter> RDex: d:q prefixes 'd' to the list 'q', forming a new list
18:59:00 <Cale> (I doubt that GHC would be using floating point arithmetic as any part of compiling programs itself, though I wouldn't make any promises about that.)
18:59:11 <Axman6> > let xs = [1,2,3] in 9:xs
18:59:12 <lambdabot>   [9,1,2,3]
18:59:18 <Cale> happygu7262: What platform are you on?
18:59:19 <Axman6> RDex: ^^^^^
18:59:37 <ddarius> The only, not obviously bad, feature I would avoid in C++ is exceptions.
18:59:42 <happygu7262> i'm on ARM SA1100
18:59:59 <ivanm> happygu7262: ummm... GHC isn't ready for ARM yet
19:00:09 <happygu7262> i tried compiling a program with main = putStrLn "Hello World"
19:00:13 <ivanm> you're seriously trying to tell me that you have a desktop computer based on an ARM processor? :o
19:00:20 <RDex> hahaha
19:00:22 <RDex> waaaat
19:00:43 <Adamant> it happens
19:00:51 <Adamant> some netbooks are ARM-based.
19:01:00 <ivanm> hmmm...
19:01:02 <RDex> running windows CE?
19:01:07 <Associat0r> defun you can write whole programs using the  the stl and standard libs without even touching a bare pointer while using C++
19:01:11 <ivanm> but netbooks aren't really designed/good for programming IMHO
19:01:11 <Cale> happygu7262: There is *some* support for GHC on ARM, but I would be surprised to get anything to work, myself.
19:01:12 <RDex> what is this, a modded dreamcast?
19:01:24 <c_wraith> ivanm:  I'm programming on a netbook!  at this very moment!
19:01:40 <ivanm> well, if GHC doesn't work on the ARM, I doubt it would work on happygu7262's CPU, since wikipedia says it's not fully compatible with ARM proper...
19:01:40 <c_wraith> ivanm:  It is an atom processor, though. :)
19:01:43 <ivanm> http://en.wikipedia.org/wiki/SA-1100
19:01:55 <ivanm> c_wraith: well, you'd have at least _some_ compatability ;-)
19:02:04 <happygu7262> i'm using a weird version of linux with kernel 2.4.35-3-j720
19:02:09 <ivanm> but with the small screen, keyboard and flash drive, I wouldn't really consider them development machines
19:02:14 <ivanm> happygu7262: ummm.... yeah
19:02:16 <ivanm> thanks for trying :p
19:02:25 <happygu7262> gcc works fine though
19:02:41 <ivanm> happygu7262: if gcc didn't work, then the kernel wouldn't exist...
19:02:58 <c_wraith> ivanm:  Nah, the netbook category is larger now than it used to be.  it now includes basically anything less than 11" diagonals.  And this is 10.6
19:03:00 <ivanm> C is much easier to port to a new architecture (and much more required for new architectures) than Haskell
19:03:17 * ivanm finds his 12" uncomfortable to code on for extended periods of time
19:03:18 <aavogt> happygu7262: you could use hugs?
19:03:20 <c_wraith> ivanm:  With a 250 GB drive.
19:03:22 <Associat0r> ddarius exceptions make C++ code safer
19:03:45 <ivanm> well, the AS-110 came out in 1996... that's one old netbook...
19:03:49 * ivanm guesses a PDA
19:03:51 <BMeph> preflex: seen JaffaCake
19:03:51 <preflex>  JaffaCake was last seen on #ghc 3 days, 14 hours, 44 minutes and 53 seconds ago, saying: Wolfgang Thaller, I guess
19:04:00 <happygu7262> hugs works, although it's missing some key features like forever in Control.Monda
19:04:10 <happygu7262> *Monad
19:04:19 <Associat0r> ivanm easier to port yes
19:04:19 <ddarius> Associat0r: I don't much like exceptions period and writing correct code in the face of exceptions in C++, at least with typical C++ style, is a major pain.
19:04:22 <ivanm> happygu7262: get a real computer ;-)
19:04:28 <Associat0r> ivanm but we were talking about safety
19:04:40 <ivanm> Associat0r: I was responding to happygu7262, not you ;-)
19:04:42 <ddarius> forever is hardly a key featuer.
19:04:50 <Cale> Apparently someone has gotten GHC working on ARM/Linux with no register support, no GHCi, and using the old code generator
19:04:57 <ivanm> hmmm...
19:05:00 <RDex> half of you guys were programming before the pentiums, stop your whining
19:05:04 <Cale> But... that probably even took a lot of effort.
19:05:06 <ivanm> Cale: wasn't the iphone port meant to be targetting ARM?
19:05:15 <ivanm> RDex: I wasn't
19:05:41 <ivanm> I would have touched a couple of old Apples at primary school maybe, that's about it
19:06:34 <c_wraith> Wow, the 8086 and 8088 are older than I thought.
19:06:36 <alatter> Associat0r: http://yosefk.com/c++fqa/exceptions.html
19:06:53 <Cale> happygu7262: If you're serious about it, kaol@debian.org (Kari Pahula) was apparently the person who got it running on ARM.
19:07:09 <c_wraith> I was programming before the 486, though!
19:07:37 <c_wraith> Man, those intel processors are significantly older than I thought.
19:07:43 <happygu7262> hmm sure i'll try
19:07:49 <BMeph> c_wraith: How old did you think they were? :)
19:08:07 <c_wraith> I thought the 8088 was 84ish
19:08:12 <c_wraith> I was off by 5 years
19:08:18 <Cale> happygu7262: But it's a big undertaking to bootstrap GHC on a different platform and get it to generate code there.
19:08:38 <happygu7262> i tried the debian etch ghc arm binaries, but they scream about floating-point too
19:08:43 <Cale> happygu7262: Especially so when there are so few users.
19:08:47 * BMeph learned programming on a Z80
19:09:57 <BMeph> c_wraith: IIRC, '84 was when the 80286 came out.
19:10:09 <Cale> happygu7262: I take it you're trying to compile via C?
19:10:16 <tommd> debian has ARM binaries?
19:10:18 <c_wraith> BMeph: wikipedia says it was before that.
19:10:19 <tommd> wow
19:10:36 <happygu7262> yeah debian has saved me a ton of time compiling
19:10:43 <Cale> happygu7262: If so, are there flags that the C compiler needs in order to avoid generating floating point instructions?
19:11:41 <happygu7262> GCC on sa1100 (some arms support fp) compiles floats to _addf3, _subf3, etc. calls instead of hardware instructions
19:11:47 <kmc> gcc has -msoft-float
19:12:40 <Cale> happygu7262: Maybe try -fvia-C -optc -msoft-float
19:15:58 <Fragsworth> You know for how small the haskell community is, this channel is awfully large
19:16:42 <Cale> Well, it's a good channel, by and large :)
19:17:30 <happygu7262> wow the ghc trac database is locked
19:17:54 <Cale> Login as guest/guest
19:18:41 <Cale> unless that's not what you're talking about...
19:19:00 <happygu7262> it's ok now
19:19:06 <happygu7262> i think...
19:22:20 <RDex> in MIRC what command do i use to connect to a different server wihout disconnecitng from freenode
19:22:31 <fryguy> RDex: use /connect
19:22:55 <RDex> fryguy that command is for network staff only
19:23:04 <RDex> i was going to use /server but there is a flag that opens another window, i forgot it
19:23:35 <RDex> that wasn't it
19:29:09 <_Ray_> Hey, question. How can I output colored text in GHCI, using ANSI color codes?
19:30:09 <ivanm> _Ray_: there was at one stage partial support for piping ghci through hscolour I belive
19:30:15 <ivanm> but I found it rathre slow and laggy
19:30:36 <Cale> _Ray_: if your terminal supports them, just emitting the appropriate codes should work, I think.
19:30:51 <Cale> _Ray_: you can use \ESC
19:31:11 <ivanm> oh, I thought _Ray_ meant the actual prompt, etc.
19:31:25 <ivanm> though if you use ghci via emacs, I think they all get stripped out...
19:32:00 <Cale> putStrLn "\ESC[31mHello"
19:32:01 <_Ray_> Cale, but how? I'm using monads to printStrLn. Could you give an example?
19:32:04 <_Ray_> Ah
19:32:10 <_Ray_> Thanks :)
19:32:14 <Cale> no problem :)
19:32:42 <alatter> _Ray_: http://hackage.haskell.org/package/ansi-terminal might be useful
19:33:14 <_Ray_> I'm just doing some simple unit testing and wanted to output "Pass" and "Fail" in clear colors, but thanks :)
19:33:19 <ivanm> and there's a pretty-print version of that package as well IIRC
19:39:29 <fryguy> blah, haskell isn't clicking for me ;(
19:42:44 <Cale> fryguy: anything we can help with?
19:43:21 <fryguy> not yet
19:44:05 <fryguy> just need to do some more reading and coding
19:44:33 <Cale> fryguy: Yeah, it took a good couple months of sporadic experimentation and writing small programs before I really felt like I could use Haskell to get things done, and about a year before I was really 100% comfortable.
19:44:46 <Cale> (but this was back when there were not as many good tutorials ;)
19:45:03 <Cale> Don't be afraid to let us know if you have any questions.
19:45:22 <Cale> (it's generally rather beginner-friendly here)
19:45:27 <fryguy> the syntax is really killing me, even with some experience messing with xmonad configurations
19:45:56 <Cale> If you haven't already done so, make sure to configure your editor to expand tabs into spaces.
19:46:02 <PetRat> To install the readline module on Windows XP, I already downloaded and install GNU readline... how do I tell the cabal process where to find readline? And what does it need to find? the dlls? the libs?
19:46:19 <fryguy> even having a fair amount of experience with other functional languages and understanding a lot of things conceptually, the syntax is just tough
19:46:47 <fryguy> Cale: for editor, are most people in here using vim? or is haskell close enough to things like lisp that emacs becomes predominant here?
19:47:11 <Cale> fryguy: There's a good mix of vim and emacs people
19:47:14 <PetRat> I used the haskell-mode on emacs.
19:47:25 <PetRat> actually "use" (present tense)
19:47:40 <alatter> fryguy: I don't know that haskell is close to lisp, but the emacs haskell-mode is pretty good
19:48:29 <PetRat> automatic tabbing algorithms are kinda tricky, but no doubt that syntax-highlighting is useful
19:48:38 <Cale> fryguy: One general point to remember is that if something is inside something else, then it should be indented more, and if two things are siblings, then they should line up vertically.
19:48:59 <Cale> (that is, start in exactly the same column)
19:49:50 <Cale> Is this the sort of thing you mean about syntax? There's a good tour of the syntax around...
19:50:05 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
19:51:53 <fryguy> Cale: more the ordering of functions, infix versus prefix, what symbols make up a list comprehension, etc.  Everything just seems in counterintuitive places.
19:52:30 <dons> xmonad 0.9 is is released! http://xmonad.wordpress.com/2009/10/26/xmonad-0-9-available-now/
19:53:47 <ivanm> how are we claiming it's reliable?
19:53:56 <ivanm> also, wtf is with that new theme on the blog?
19:54:38 <aavogt> you have to claim something?
19:55:10 <ivanm> aavogt: no, just saying that it's easy to claim that something is reliable, but how do you prove it?
19:55:24 <ivanm> if we extended QC to cover more of the core, then that would probably be a good start
19:56:45 <PetRat> To install the readline module on Windows XP, I already downloaded and install GNU readline... how do I tell the cabal process where to find readline? And what does it need to find? the dlls? the libs?
19:56:50 <dons> we do more in testing and static assurance than any other wm
19:57:04 <ivanm> dons: so "more reliable" ;-)
19:57:09 <dons> that's the point, yes.
19:57:33 <ivanm> and I just realised I typed that question into the wrong channel... :s
19:57:41 <alatter> PetRat: I've had enough trouble with readline on my mac that I usually just rip it out of whatever I'm trying to use that relies on it, and plug in haskeline if neccessary
19:57:48 <dons> well, those are tiles on the blog, in case you noticed.
19:57:55 <alatter> PetRat: that may not be the answer you're looking for, though :-)
19:57:59 <dons> nice ceramic tiles
19:58:22 <Cale> fryguy: The order in which you define functions doesn't matter, but the pattern matches in the definition of a single function happen in order.
19:58:49 <fryguy> Cale: i'm talking more about the fact that symbolic operators are infix by default, while everything else is prefix, that sort of thing
19:58:50 <PetRat> alatter: well, yes, not quite the answer--- I actually had readline running before I upgraded to version GHC 6.10---I just can't remember how I built it. I just messed around with setting the PATH to everything I can think of, but no go.
19:59:22 <Cale> fryguy: Functions whose names are made up entirely of symbol characters are written infix, and can be switched to prefix by putting them in parens. Functions whose names are alphanumeric are written prefix, and can be written infix using backticks.
19:59:39 <fryguy> Cale: i know, just taking a while to get used to that sort of stuff
19:59:43 <Cale> okay :)
20:00:08 <Cale> It's somewhat natural considering that + and * and so on are infix.
20:00:18 <aavogt> fryguy: you can get away without knowing list comprehensions (unless to read other's code)
20:00:21 <Cale> (and normally are from mathematics)
20:00:40 <Cale> List comprehensions are possible to do without, but they're sometimes really handy.
20:05:48 <BMeph> dons: Was that a transposed Dr. Horrible ref? ;)
20:06:23 <BMeph> dons: Re: "nice ceramic tiles"
20:07:05 <Warrigal> Can someone with a Haskell wiki account modify the link at http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics to Hmm to point to home.solcon.nl instead of www.solcon.nl?
20:07:38 <Cale> Warrigal: sure thing
20:07:48 <Warrigal> Neato.
20:09:13 <Cale> done :)
20:09:21 <Warrigal> Hmm. If I want to have a module inside a directory, does the directory have to start with an uppercase letter in order for it to be importable?
20:14:00 <ivanm> hmmm.... looks like bonch's liver has gotten the better of him...
20:15:12 <copumpkin> ivanm: how so?
20:15:50 <ivanm> copumpkin: you know who I"m talking about, don't you?
20:15:54 <copumpkin> yep
20:16:03 <ivanm> http://www.reddit.com/r/programming/comments/9xp1h/manuel_chakravarty_we_argue_that_teaching_purely/c0exok2
20:16:15 <copumpkin> ah
20:16:39 <copumpkin> I really think shit like that does merit banning from proggit
20:16:45 <ivanm> agreed
20:16:46 <copumpkin> he contributes literally nothing to any discussion at all
20:17:03 <ivanm> the drink one was almost humorous (for a while anyway); something that big is just spamming
20:17:07 <copumpkin> I mean, not because he hates haskell :) but he's just never said anything useful (that I agreed with or disagreed with)
20:17:08 <dolio> Is that Yoda?
20:17:12 <copumpkin> yeah
20:17:14 <ivanm> dolio: I think so
20:17:23 <copumpkin> ivanm: he also had a giant ascii art text thing the other day
20:17:29 <ivanm> at least with the drinking one, someone suggested they could find interesting articles by looking for what caused bonch to drink... ;-)
20:17:50 <copumpkin> I got downvoted to hell once for leaving some laxative-laced alcohol on one of the threads for bonch
20:17:54 <copumpkin> before he got there
20:18:16 <ivanm> heh
20:18:20 * _Ray_ is just not getting monads. What's wrong with this 4-line snippet? I want to print a string, and return a number, where a TestCase is (String, Bool). http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11157
20:18:33 <copumpkin> _Ray_: don't start with trying to "get monads"
20:18:42 <copumpkin> _Ray_: Integer is not a Monad
20:18:54 <_Ray_> Right, I likely just don't get it
20:19:09 <_Ray_> Don't I need a monad to print something, and return something else?
20:19:12 <copumpkin> IO Integer would probably work, assuming TestCase is a type synonym
20:19:14 <Axman6> ivanm: http://accom.anu.edu.au/UAS/43.html
20:19:16 <ivanm> _Ray_: just use IO
20:19:28 <copumpkin> _Ray_: to print something you need IO, but forget it's a monad and pretend you need do notation to use IO
20:19:30 <Axman6> fancy some shipping container accomodation?
20:19:31 <_Ray_> type TestCase = (String, Bool)
20:19:35 <ivanm> Axman6: seen it... looks like the best option if I'm forced to live on campus :s
20:19:49 <copumpkin> _Ray_: and think of IO like an imperative sublanguage, ignoring completely the Monad stuff
20:19:49 <ivanm> Axman6: now, if only they gave you decent photos of inside them... :@
20:19:52 <Axman6> they've put the whole building up in about a month
20:20:00 <Axman6> well, they're still being built
20:20:06 <dolio> Whose face is the logo for the dependent types reddit?
20:20:25 <copumpkin> _Ray_: you can do almost anything an imperative language would do in this "do" sublanguage, except for returning early out of a function
20:20:33 <_Ray_> copumpkin, so I should return a "IO Integer"? And how would the function change? = do\n putStrLn ...\n return (if..then..)?
20:20:34 <ivanm> Axman6: IIRC, they had a demo one for a while... they have 1 photo from inside a container, that's it :s
20:20:47 <copumpkin> _Ray_: changing the type to IO Integer might just make it work
20:21:11 <_Ray_> Ah, *goes to check and fixes newly-created type errors then*
20:21:13 <_Ray_> Thanks :)
20:21:37 <copumpkin> np
20:21:45 <Axman6> ivanm: have you got in touch with ANU's uni accomodation people?
20:21:53 <ivanm> Axman6: nope
20:21:59 <Axman6> you probably should
20:22:03 <_Ray_> And how would I extract the integer out of this "IO Integer"? (Say I wanted to add it to something)
20:22:09 <hackagebot> GlomeVec 0.1.1 - Simple 3D vector library (JimSnow)
20:22:24 <copumpkin> _Ray_: you can never really extract from it, but luckily main is also in IO, so you can work from within
20:22:31 <ivanm> Axman6: eh, I think we will end up buying _somethign_, question is where and how big
20:22:36 <ivanm> copumpkin: *phew* ;-)
20:22:37 <_Ray_> Wha? O.o
20:22:51 <ivanm> _Ray_: you can never escape the IO monad
20:22:56 <_Ray_> =(
20:23:01 <_Ray_> Evil.
20:23:05 <copumpkin> _Ray_: IO is basically saying "this function is impure, and may do something different every time you call it"
20:23:06 <ivanm> you can (and do) however split up your main function into smaller helpful functions
20:23:10 <alatter> _Ray_: you can't pull anything out of the IO type, but you can put other things into it. Just like you put your "if ..." expression into IO before.
20:23:17 <mwc> well, there's unsafePerformIO. But *that's* evil.
20:23:20 <copumpkin> _Ray_: if you were able to escape it, you could do some really bad things
20:23:24 <Axman6> _Ray_: without IO, how can your program do anything useful?
20:24:02 <_Ray_> But say I have a t :: IO Integer. Can I add another t' to it (of the same species), or a plain Integer? And I can just putStrLn(t), right?
20:24:18 <Axman6> no
20:24:22 <mwc> _Ray_: no, you need to compose the actions
20:24:31 <ivanm> @type liftM2 (+)
20:24:32 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m a1 -> m a1
20:24:35 <copumpkin> _Ray_: composing things that behave predictably will always produce something that behaves predicably, but composing unpredictable things will never produce something predictable (unless you can do some very intense reasoning about it in some cases, which is rare)
20:24:42 * ivanm wonders why a1 ...
20:24:42 <mwc> do { tv <- t; tv' <- t'; return (tv + tv') }
20:25:02 <Axman6> _Ray_: try this: http://random.axman6.com/blog/?page_id=70
20:25:08 <_Ray_> Oh...so once a Monad has touched my code, everything else will be 'do' from now on?
20:25:19 <mwc> _Ray_: depends. if it's IO, then yes.
20:25:22 <copumpkin> _Ray_: not all Monads, but IO yes
20:25:34 <mwc> _Ray_: other monads, like Maybe, [], etc, all have "escape hatches"
20:25:44 <copumpkin> _Ray_: as I said, it's best to forget the word Monad for a while until you get comfortable with the basics first
20:25:56 * _Ray_ goes to Axman's tutorial :)
20:26:02 <ivanm> _Ray_: everything that uses that code
20:26:18 <ivanm> Axman6: I note that even if I just go to axman6.com, it still claims to be random...
20:26:21 <Axman6> _Ray_: i aimed at people who just want to use IO, without having to learn what's really going on
20:27:07 <ivanm> Axman6: well, IO works differently from other monads anyway, so *shrug*
20:27:19 <Axman6> man, i need to change that tutorial, it's rather lame in many parts
20:27:25 <Cale> _Ray_: Also, that's a bit wrong to say -- you can still call pure code from IO code.
20:27:25 <BMeph> Axman6: FVMO "really," surely? ;)
20:27:35 <_Ray_> Right, but not viceversa
20:27:38 <Axman6> BMeph: huh?
20:27:39 <blackdog> Axman6: that's a nice traffic light colour scheme you've got there
20:28:02 <Cale> _Ray_: But that doesn't tend to matter because you can do all the input you need and pass those things as parameters to whatever pure function needs it.
20:28:02 <ygd-coder> @botsnack
20:28:02 <lambdabot> :)
20:28:02 <lunabot>  :o
20:28:03 <Axman6> yeah, i'm not a huge fan of it
20:28:33 <Cale> _Ray_: and lazily get back a stream of stuff to be output too.
20:28:48 <copumpkin> _Ray_: you can "lift" a pure function into impure land :)
20:28:51 <Cale> (so you don't tend to need to interleave computation and output stuff)
20:29:05 <BMeph> Axman6: "without having to learn what's really going on" <-- That "really" :)
20:29:07 <_Ray_> I'd say impure land seems more like hell than heaven...
20:29:09 <Axman6> _Ray_: when you're done, let me know of there's anything you don't like about it
20:29:19 * blackdog 's tests are broken, as is the code, as is his basic mental model of it. time to take a break.
20:29:36 <copumpkin> _Ray_: that's why we try to stay out as much as possible :) we make most things pure and then restrict the impure stuff to the UI and whatever else is strictly necessary. A bit like MVC :P
20:31:11 <kmc> so, Haskell is a good imperative programming language
20:31:23 <ivanm> @quote imperative
20:31:24 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
20:31:26 <ivanm> @quote imperative
20:31:26 <lambdabot> SamB says: Haskell is the only language I know with first-class support for imperative programming
20:31:28 <ivanm> @quote imperative
20:31:29 <lambdabot> lennart says: I think people who come from imperative programming come with a mind set that you understand your code by stepping through it in the debugger.  But I find this paradigm much less
20:31:29 <lambdabot> useful for functional code
20:31:30 <mwc> I find there's sort of a three-layer cake approach to writing a haskell program. The top layer is the IO that interacts with the world, then pure functional code under that handles most of the logic. If needed, some impure stuff in the ST monad can be wrapped into purely functional blocks and used in the pure code
20:31:34 <ivanm> gah, can't find the quote I want
20:31:38 <ivanm> @quote dons imperative
20:31:39 <lambdabot> No quotes match. I am sorry.
20:33:16 <gwern> @quote dons.*imperative
20:33:16 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:33:43 <_Ray_> Hrmph. And how could I "lift" a 0 to IO Integer? (I'm calling my func with 0, but expecting an IO Integer since I'll need to add stuff to this guy, which will come from IO-impure functions)
20:33:46 <gwern> ivanm: fwiw, wasn't the
20:33:59 <gwern> haskell is the best imperative language quote frmo the guy who did the BASIC dsl?
20:34:12 <ivanm> was it? I thought it was dons...
20:34:41 <dolio> @quote augustss imperative
20:34:42 <Gracenotes> hm. I'm guessing the reason most people don't do major, global, structural code flow optimizations is that 1) it's too expensive or 2) the results aren't provably correct
20:34:49 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:35:01 <dolio> @quote augustss
20:35:02 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
20:35:25 <Gracenotes> it certainly seems possible, analyzing a series of imperative statements as a DAG and manipulating it directly. .. might be performance-intensive though, particularly for large methods... although people *do* liveness analysis...
20:35:53 <gwern> dolio: no no, @quote only takes on argument, a regexp
20:36:09 <gwern> you need something like
20:36:11 <gwern> @quote august.*imperative
20:36:12 <lambdabot> No quotes match. There are some things that I just don't know.
20:36:19 <dolio> No, there are multiple forms.
20:36:26 <dolio> @quote augustss IOCC
20:36:27 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
20:37:04 <dolio> It's either @quote <name> <regexp> I think, or @quote <regexp> assuming the regexp doesn't coincide with a name.
20:37:25 <mmorrow> @google IOCC augustsstson
20:37:26 <lambdabot> No Result Found.
20:37:31 <mmorrow> @google IOCC augustsson
20:37:32 <lambdabot> No Result Found.
20:37:35 <kmc> _Ray_, if you call f from the IO monad, the arguments to f do not have IO types
20:37:43 <kmc> the basic building block of any monad is this:
20:37:44 <mmorrow> @google IOCC augusstson
20:37:45 <kmc> :t (>>=)
20:37:45 <SamB_XP> dolio: yeah, and I think it only considers a thing a name if it actually has any quotes for that name ;-)
20:37:45 <lambdabot> No Result Found.
20:37:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:37:47 <mmorrow> grr
20:37:52 <dolio> Right.
20:38:04 <kmc> note that the monadic value (m a) is passed as a non-monadic value to the function of type (a -> m b)
20:38:07 <kmc> here, m is IO
20:38:28 <gwern> @quote Baghdad
20:38:29 <lambdabot> NathanielSBorenstein says:  It should be noted that no ethically-trained software engineer would ever consent to write a DestroyBaghdad procedure. Basic professional ethics would instead require him
20:38:29 <lambdabot> to write a DestroyCity procedure, to which Baghdad could be given as a parameter.
20:38:33 <kmc> as to your original question, a value of type IO Int where the value "inside" is 0 is produced by "return 0"
20:39:09 <blackdog> gwern what if you wanted to destroy a spaceship, though? Clearly the function is still insufficiently abstract
20:39:25 <_Ray_> kmc, but then...here's my issue. I have a test suite. The test suite keeps a counter of total/passed tests. To "do" a test, I calculate if it passed or failed, and print a value (here is the monad). Since I have to use a monad, the counter has to return an IO Integer. I then print this integer at the end of my function. However, I have to first call the function (it's recursive) with (0, 0) (0 tests total, 0 tests failed). But it whines tha
20:39:25 <_Ray_> t (0, 0), the literals, aren't IO Integers :( How can I start the counter which will later be touched by monads?
20:39:28 <BMeph> Hurrah for SWE Ethics training! ;p
20:39:54 <ivanm> BMeph: you consider software to be made up of two words?
20:40:10 <gwern> blackdog: a spaceship would require an entirely different set of physics; that's specialized to spherical newtonian dynamics
20:40:21 <blackdog> gwern: sure, but the interface could be the same
20:40:23 <ivanm> gwern: would it need different physics?
20:40:42 <ivanm> different targeting parameters, some tracking code, possibly a different warheard...
20:40:48 <gwern> blackdog: no way; for starters, you might need to address it entirely different; what if you're in different inertial frames?
20:41:01 <ivanm> destroyFoo :: Target -> TrackingParams -> Warhead -> IO (Maybe Explosion)
20:41:02 <gwern> you might need to supply both your and the target's 4d coordinates!
20:41:07 <ivanm> heh
20:41:09 <BMeph> ivanm: I consider SWE to be the industry abbreviation for Software Engineer, since it makes the whiny Systems Engineers shut up. ;)
20:41:15 <ivanm> ahhh
20:41:19 <ivanm> only really seen it as SE
20:41:25 <ivanm> never heard of Systems Engineers before
20:42:06 <kmc> _Ray_: can you hpaste some code?
20:42:17 <BMeph> ivanm: You've never heard of the Systems and Industrial Engineer society, then? :)
20:42:23 <ivanm> hpaste some code, any code! :p
20:42:24 <blackdog> gwern: in that case, destroying a city is just a special case of the more general problem
20:42:28 <ivanm> BMeph: nope
20:42:36 <SamB_XP> anyway, we're always abbreviating software as SW, so SWE is a sensible abbreviation ...
20:42:36 <ivanm> blackdog: exactly!
20:42:38 <_Ray_> kmc, sure.
20:42:56 <ivanm> blackdog: then we need to consider if you want to destroy something in a different reality in the multiverse...
20:42:58 <blackdog> clearly, what we need is a system whereby objects can be verbed
20:42:58 <ivanm> ;-)
20:43:10 <ivanm> SamB_XP: we do? don't think I ever have...
20:43:14 <ivanm> SW == South West :p
20:43:16 <blackdog> perhaps we could call it a programming languace...
20:43:27 <gwern> blackdog: sure, but you still specialize functions. nobody writes a library which jsut provides a lambda and expects the user to write anything he needs as a series of lambdas because anything more useful would not be as general as possible!
20:43:42 <blackdog> gah. the problem with dvorak is that none of your typos are understandable
20:43:49 <BMeph> ivanm: ...and SE == South East. What'd your point? ;)
20:43:52 <blackdog> gwern: well, yes. :)
20:44:06 <kmc> gwern, people write those, they're called functional programming languages :)
20:44:07 <_Ray_> kmc, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11159 . Beware: Beginner's Haskell.
20:44:08 <blackdog> i'm just having fun with the idea
20:44:08 <SamB_XP> gwern: well, for starters you don't often see that because it's generally not doable as a library ;-P
20:44:27 <kmc> so, the second arg to printTestSuite should be of type (Integer, Integer)
20:44:32 <kmc> almost certainly
20:44:54 <kmc> and you should rejigger the code in runTests to make that work
20:45:05 <seanmcl> does anyone know how to examine the CPP path (for a LANGUAGE CPP pragma?)  GHC can't find my header file.
20:45:16 <mmorrow> http://www.ioccc.org/1996/august.hint
20:46:35 <BMeph> Besides, isn't the whole "Haskell is the ultimate imperative PL" an SPJ quote? :)
20:46:49 <ivanm> oh, is that SPJ?
20:46:52 <lament> spj is sooo unbiased in everything he says
20:46:57 <_Ray_> kmc, then I get errors about the "+1" on line 7. Should I convert anything else from IO Integer to Integer?
20:46:57 <ivanm> BMeph: lambdabot seems to have forgotten it... :(
20:46:58 <kmc> _Ray_, same in printTestList
20:47:14 <kmc> _Ray_, passing an IO Integer as an arg is not anything like passing an Integer as an arg
20:47:17 <SamB_XP> ivanm: he never said it here!
20:47:25 <sproingie> oleg showed it's the ultimate OO language
20:49:33 <kmc> whereas returning an IO Integer is more analogous to returning an Integer
20:49:33 <ivanm> mmorrow: what is the actual program?
20:49:33 <SamB_XP> sproingie: showed *who*?
20:49:33 <ivanm> SamB_XP: pretty sure it used to be a lambdabot quote though...
20:49:33 <gwern> I'm pretty sure august did the best imperative quote while writing a C dsl, not spj
20:49:33 <mmorrow> http://www.ioccc.org/1996/august.orig.c
20:49:33 <sproingie> SamB_XP: the co-author of the paper i suppose
20:49:33 <SamB_XP> when he "shows" something, I generally just end up with a headache ;-P
20:49:33 <_Ray_> kmc, but I'm saying "passed + (printTest t)", so passed is adding an IO Integer, since printTest returns an IO Integer
20:49:33 <gwern> 'lambda is the ultimate imperative' is the scheme people
20:49:33 <kmc> you can't add IO Integers
20:49:33 <ivanm> mmorrow: wtf? is it meant to be random ASCII characters?
20:49:33 <kmc> not directly
20:49:33 <sproingie> "lambda: the ultimate imperative.  very accessible paper
20:49:33 <ivanm> mmorrow: and what is it meant to actually _do_?
20:49:33 <_Ray_> Then how could I print the result of the test, and return an integer, later to add to it?
20:49:33 <kmc> do { n <- printTest t; printTestList ts (total+1, passed+n) }
20:49:33 <sproingie> meant to show off scheme to algol folks basically
20:49:33 <mmorrow> ivanm: did you read the hint!
20:49:33 <ivanm> mmorrow: oh, recursive compilation?
20:49:44 <ivanm> oh, wait, found the bit with the description
20:49:57 <ivanm> what kind of bytecode does it interpret?
20:49:59 <BMeph> SamB_XP: The paper he and Ralf Laemmel wrote is here: http://homepages.cwi.nl/~ralf/OOHaskell/
20:50:26 <SamB_XP> isn't OOHaskell some bitrotted ancient dumb thing ?
20:50:31 <kmc> _Ray_, i use braces and semicolons here for a single line; you can use the whitespace-formatted do notation you're used to
20:50:38 <ivanm> SamB_XP: I think Timber replaced it or something...
20:50:42 <sproingie> SamB_XP: that's O'Haskell
20:50:47 <mmorrow> ivanm: it's a compiler for a stripped-down C-like language, as well as an interpreter for that language, so it then compiles the interpreter and you can interpret the interpreter with the compiled interpreter, etc
20:50:50 <sproingie> OOHaskell comes out of HList
20:50:55 <BMeph> SamB_XP: ^^ (Concerning who, or rather how, Oleg "showed" it.)
20:50:55 <SamB_XP> oh
20:51:06 <_Ray_> kmc, but when I say that it's trying to return an IO Integer. Adding a "return" to the printTestList statement doesn't fix it
20:51:10 <ivanm> mmorrow: *ow* ;-)
20:51:16 <SamB_XP> BMeph: well, I was asking *who* he showed
20:51:25 <_Ray_> Oh, *changes types*
20:51:27 <SamB_XP> i.e. does anyone actually *understand* that stuff ?
20:51:31 <ivanm> SamB_XP: anyone that read the paper ;-)
20:51:38 <kmc> yeah, your arguments should not be IO types anymore
20:52:49 <SamB_XP> yeah, values of IO types are very unconvincing arguments ;-P
20:52:49 <_Ray_> Hrmph. It still whines that it expected an IO Integer and inferred an (Integer, Integer)
20:52:49 <kmc> did you make similar changes elsewhere?
20:52:56 <kmc> i think you can get rid of all of the "IO" on the left side of any "->" in this program
20:53:09 <_Ray_> in printTestSuite, the main one
20:53:09 <BMeph> SamB_XP: Maybe you should talk to Laemmel. ;)
20:53:26 <sproingie> OOHaskell looks totally readable to me, and i usually run away the moment i see a greek letter that isn't lambda
20:53:28 <SamB_XP> oooookay ... what the heck is with this line noise at the top of this IOCCC entry ?
20:53:50 <_Ray_> kmc, should I hpaste what I have now?
20:53:53 <kmc> _Ray_, sure
20:53:58 <BMeph> SamB_XP: ...the top of the IOCCC entry? ;)
20:54:03 <mmorrow> ivanm: err. so the junk at the start is the pre-made bytecode for the /compiler/, and the C code code is an interpreter for that bytecode, which then interprets the compiler bytecode, so you can then use the compiler on the compiler's original source to compiler it
20:54:24 <sproingie> ow my brane
20:54:30 <_Ray_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11159#a11160
20:54:36 <_Ray_> ^-- @kmc
20:55:03 <_Ray_> It whines at line 8, it expects Integer, inferres "m a"
20:55:14 <_Ray_> ..infers, not inferres. wtf.
20:55:14 * BMeph Topo-Zombies out...BRANES! ;p
20:55:39 <mmorrow> i'm not exactly clear on where the interpreter the compiler can compile comes from, but it appears that somehow preprocessing the original C
20:55:40 <mmorrow> oh
20:55:57 <mmorrow> the C interpreter is written in that restricted C subset too
20:56:01 <hgolden> mmorrow: FYI, after upgrading to haskell-src-exts-1.2.0 (from 1.1.4), haskell-src-meta-0.0.5 compile fails in Parse.hs due to src-exts API change. Do you know this already? I have a patch (for 1.2.0 only). Do you want this?
20:56:05 <mmorrow> so the compiler can compile it
20:56:21 <mmorrow> hgolden: sure, thanks
20:56:29 <kmc> _Ray_, printTestList is still doing IO, its return type should be IO (Integer, Integer)
20:56:34 <mmorrow> (i did not know this)
20:56:39 <kmc> and you shouldn't "return" it
20:56:46 <kmc> return is not really anything like the "return" keyword in C
20:56:59 <kmc> return is used to add a layer of monadic wrapping on something that doesn't have it
20:57:16 <Warrigal> _Ray_: likewise, printTest should return IO Integer.
20:57:18 <kmc> in this case printTestList already returns a monadic value
20:57:39 <Warrigal> Interesting mix of English and Spanish, by the way.
20:57:43 <_Ray_> Then printTestList should also take an IO (Integer, Integer), right?
20:58:06 <kmc> No
20:58:18 <hgolden> mmorrow: BTW I mentioned this to ivanm and he said I should send it upstream. Since I saw you here I pinged you. Hope you don't mind.
20:58:22 <kmc> The rule for beginners would be: Return values in the IO monad; never take args in the IO monad
20:58:40 <mmorrow> hgolden: not at all :) i appreciate the heads-up
20:58:42 <kmc> instead, you use the "do" notation
20:59:05 <Warrigal> The purpose of (>>=) is to make a function not have to take a monadic value.
20:59:22 <kmc> _Ray_, do you understand this type:   IO a -> (a -> IO b) -> IO b
20:59:24 <_Ray_> kmc, then the base case in printTestList whines, "printTestList [] (total, pass) = (total, pass)". It's taking an (Integer, Integer) and returning an IO (Integer, Integer)
20:59:37 <kmc> _Ray_, you'd use "return" in that base case
20:59:40 <_Ray_> ohh
20:59:44 <kmc> return means "don't do IO, only produces this value"
20:59:49 <kmc> (in the IO monad case)
20:59:50 <Warrigal> (Cute how formatearResultado is the same thing as its English translation except with stuff added.)
21:00:24 <_Ray_> Warrigal, my brain conflicts between "your text output will be in Spanish" and "you like coding in English"
21:00:31 <mmorrow> hgolden: (do you need my email?)
21:01:00 <Warrigal> What's the Spanish word for "integer", anyway?
21:01:10 <_Ray_> Entero
21:01:14 <hgolden> mmorrow: No. I have it from Hackage.
21:01:22 <mmorrow> hgolden: cool
21:01:23 <_Ray_> (Which is the same word we use for "whole")
21:01:45 <Warrigal> So "the whole integer" would be something fun to say.
21:02:09 <Warrigal> And "enterar" is a verb, too, isn't it.
21:02:23 <_Ray_> kmc, then the only thing left whining is printTestSuite, since it expects (Integer, Integer) and infers IO (Integer, Integer). But I should be able to solve this one by myself, so I'll try that :)
21:02:28 <_Ray_> Warrigal, indeed, it's to find out
21:02:28 <kmc> :)
21:02:38 <Warrigal> "I find out the entire integer" = "Me entero el entero entero"?
21:02:55 <ivanm> Warrigal: heh
21:03:15 <_Ray_> Me entero del entero entero :s
21:03:15 <_Ray_> (I find out /about/ the entire integer)
21:03:15 * Warrigal nods.
21:03:30 <_Ray_> Buffalo buffalo buffalo buffalo buffalo.
21:03:32 <ivanm> http://translate.google.com/translate_t#es|en|Me%20entero%20el%20entero%20entero
21:03:38 <ivanm> "I find the whole entire"
21:03:45 <ivanm> according to google anyway
21:03:49 <Warrigal> What's "the whole entire integer"? :-P
21:03:54 <_Ray_> Clearly there's no natural isomorphism
21:04:07 <_Ray_> The whole entire would be redundant...el entero entero entero?
21:04:22 <Warrigal> "Whole entire" is indeed redundant, but nonetheless it's used for emphasis.
21:04:59 <_Ray_> The order here would be "integer whole entire"
21:06:43 <Warrigal> "Entre entrar el entero entero y enterar de enteros enterrados, prefiero entrarlos." If "entrar" can be used that way.
21:07:55 <_Ray_> :s Yes, it can. It makes syntactic sense, but not semantic (one doesn't enter an integer), and you'd say "enterarme de enteros enterrados", meaning "/I/ find out about burried integers"
21:08:13 <aeron> 240
21:08:53 <Warrigal> Whoops, can't forget that -me.
21:10:14 <Warrigal> You can use "introducir" to enter an integer, I think, but that doesn't sound like "entero".
21:12:00 <_Ray_> You can - introducir would mean to "insert" (not introducing)
21:12:16 * Warrigal nods.
21:12:21 <Warrigal> People seem to use it to mean "type".
21:12:56 <_Ray_> Yeah, when talking about places where you can input things. "Introducir text en la caja", "insert text in the box"
21:13:10 <Warrigal> At least, I think I knew of a Spanish-speaker once who used "introduce" in English to mean that.
21:13:42 <_Ray_> Yeah, it'd be a common mistake. Similar to how library isn't librer√≠a - it's biblioteca. Librer√≠a would be bookstore.
21:13:59 <Warrigal> Clearly, we're using the word "library" wrong. :-P
21:14:09 <_Ray_> Also common (at least for me) is to think about "embarassment", and try to translate to Spanish (when my brain is switched to "English"), and translate it poorly to "embarazado". Which would mean pregnant.
21:14:23 <SamB_XP> how embarrasing!
21:14:41 <_Ray_> :p
21:15:13 <Warrigal> Empregnado! :-P
21:15:37 <Warrigal> Which is pretty close to "empregado".
21:15:55 <_Ray_> No idea what empregado would mean...employee in Portuguese?
21:16:19 <Warrigal> Yeah, it is. Darn Wiktionary not saying "THIS IS PORTUGUESE, NOT SPANISH" in large flashing letters.
21:16:21 * _Ray_ is still battling the use of fst in an IO (Integer, Integer) xP
23:14:37 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
23:14:37 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
23:14:47 <Cale> Well, I will probably run out of 5-digit subsequences, that's a good point
23:15:01 <ivanm> > 10^5
23:15:02 <lambdabot>   100000
23:15:10 <ivanm> duh
23:15:15 <ivanm> Cale: what, after 10000 releases?
23:15:21 <Cale> after releasing sufficiently many versions
23:15:34 <ivanm> that's bad even for haskell packages on hackage...
23:15:55 <mmorrow> Cale: better make it 6 to be safe
23:16:07 <mmorrow> an maybe use e instead
23:16:19 <Cale> Maybe I can start by using single digits, until I have to reuse one, at which point I switch to two, and so on.
23:16:27 <ivanm> mmorrow: OK, that went right over me... is e meant to give you more subsequences than pi?
23:16:40 <ivanm> Cale: so 01 /= 1 ?
23:16:46 <mmorrow> ivanm: exactly!
23:16:54 <ivanm> >_>
23:16:55 <ivanm> <_<
23:17:02 <Cale> 3,1,4,15,9,2,6,5,35,8,97,...
23:17:06 * ivanm is lost
23:17:34 <ivanm> Cale: right, that will make determining relative ages of versions _easy_ :s
23:17:39 <Cale> yeah
23:18:12 <copumpkin> or you can just add successive digits on
23:18:14 <copumpkin> like TeX does
23:18:19 <copumpkin> (annoying as hell, btw)
23:18:34 <Cale> Too easy since it's still monotonically increasing
23:18:42 <copumpkin> oh, true that
23:18:46 <copumpkin> I think we need a generalization of digits
23:18:46 <ivanm> copumpkin: compare = compare `on` length ;-)
23:19:05 <copumpkin> which allows negative (but still integral abs < 10) digits
23:19:43 <copumpkin> just to make things more interesting
23:20:44 <Cale> @let piDigits = g (1,0,1,1,3,3) where g(q,r,t,k,n,l) = if 4*q+r-t<n*t then n : g(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n,l) else g(q*k,(2*q+r)*l,t*l,k+1,div(q*(7*k+2)+r*l)(t*l),l+2)
23:20:45 <lambdabot>  Defined.
23:20:50 <Cale> > piDigits
23:20:51 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
23:20:52 <copumpkin> :o
23:21:04 <copumpkin> quick, shootout entry!
23:21:17 <copumpkin> it'll win on code length alone
23:21:30 <ivanm> copumpkin: is this you? :p http://i.imgur.com/5RCFm.jpg
23:21:38 <copumpkin> I guess that shootout problem is annoying in its output format
23:21:47 <copumpkin> ivanm: that's my cousin joe
23:21:51 <ivanm> wtf is that g function?
23:21:53 <ivanm> copumpkin: heh
23:21:59 <hgolden> Cale: piDigits reminds me of APL one-liners of old.
23:22:08 <Cale> http://www.comlab.ox.ac.uk/people/jeremy.gibbons/publications/spigot.pdf
23:22:12 <Cale> It's from that paper
23:22:18 <Cale> which provides an explanation :)
23:23:12 <ivanm> Cale: how long is it valid for?
23:23:15 <Cale> forever
23:23:26 <ivanm> :o
23:23:33 <ivanm> I thought the digits of pi were random...
23:23:39 <Cale> They're not *random*
23:23:41 <ivanm> or does that derive the actual value of pi?
23:23:43 <Cale> Because they're pi :)
23:23:46 <ivanm> Cale: heh
23:24:01 <Cale> They just look kind of random
23:24:11 <copumpkin> the kolmogorov complexity of pi is low :P
23:24:25 * copumpkin (has computed it)
23:24:43 <Cale> This formula is somehow based on the formula that pi = sum over i >= 0 of (i!)^2 * 2^(i+1) / (2i+1)!
23:25:02 <Cale> er, no, that's different
23:25:27 <ivanm> http://en.wikipedia.org/wiki/Pi#Open_questions
23:25:48 <ivanm> wikipedia says that it's not yet determined if the digits of pi have the same frequency as if they were random
23:25:58 <copumpkin> that's not the same thing as saying the sequence is random
23:26:01 <hgolden> Cale: I like that paper a lot. Hooray for Literate Haskell!
23:26:12 <Cale> ivanm: right
23:26:37 <Cale> ivanm: For all we know, there's a point beyond which the only digits base 10 are 3's and 7's
23:27:04 <ivanm> true
23:27:05 <Cale> (but that would be surprising)
23:27:10 <Gracenotes> despite the oft-quoted argument that pi contains every copyrighted work, etc.
23:27:27 <Gracenotes> a random stream of digits would, though :)
23:27:27 <ivanm> Cale: well, they'd have to be random-ish ordering of 3s and 7s, since we know it's transcendental
23:27:39 <ivanm> and if there's a pattern formed by 3 and 7, then it's a fraction
23:27:44 <Cale> ivanm: Just non-repeating
23:27:55 <Cale> It could have an obvious pattern
23:28:03 <ivanm> Cale: yeah, that's what I meant... a non-repeating pattern
23:28:16 <Cale> Like, 3773777377777377777773...
23:28:18 <Gracenotes> @pl \b -> (++) (printf "<%s> %s" b b) (maybe "" ('\n':) (Map.lookup stmt b))
23:28:18 <lambdabot> ap ((++) . join (printf "<%s> %s")) (maybe [] ('\n' :) . Map.lookup stmt)
23:28:19 <ivanm> I didn't mean something like "37337733377733337777....", though what I actually said could mean that
23:29:08 <c_wraith> Wait, I thought it was known that for any base, any finite sequence of digits in that base occurs in pi.
23:29:25 <c_wraith> If that's true, it means that pi can never become some mix of 3s and 7s in base 10
23:29:27 <ivanm> c_wraith: of any length?
23:29:39 <Cale> c_wraith: It's not known.
23:29:44 <Cale> c_wraith: Only suspected.
23:29:47 <ivanm> c_wraith: that can't be true, or else you're saying that e appears in pi
23:29:54 <ivanm> oh, wait, finite sequence
23:29:55 <Cale> ivanm: hm?
23:29:56 <ivanm> forget that
23:30:15 <copumpkin> it'd be funny if pi's digits turned into e's past a certain point
23:30:34 <ivanm> copumpkin: and vice-versa!
23:30:40 <ivanm> co-recursively containing each other!
23:30:40 <ivanm> :p
23:30:41 <copumpkin> lol, that'd be silly!
23:30:42 <Cale> That would imply normality in every base, which is very strong. Even though almost all real numbers satisfy it, the only examples of numbers which we know are normal are highly contrived.
23:30:42 <copumpkin> :P
23:31:16 <copumpkin> pi = k + e / (10^^^^5)
23:31:27 <copumpkin> O:-)
23:31:52 <copumpkin> (and yes, I'm privileging 10 there)
23:32:23 <ivanm> "privileging"? is that really a mathematical term?
23:32:36 <Cale> It's an English word.
23:32:57 <copumpkin> never question the psuedo-italian/yank's english!
23:33:10 <copumpkin> except wen its qwestionabul
23:33:18 <Cale> OED can has it.
23:34:42 <ivanm> Cale: I know it's a real word; just questioning wtf copumpkin means by having it there
23:34:42 <Cale>     2. The action of according high status, validity, or importance to a concept, viewpoint, etc., in comparison to others; an instance of this. Cf. PRIVILEGE v. 4.
23:34:58 <copumpkin> ivanm: by including the 10 in my formula, I am giving it a special status
23:35:02 <Cale> ivanm: I guess, the arbitrary use of the 10
23:35:50 <copumpkin> but the Mighty Lord and His 10 fingers, when He designed our wonderful universe, included a signature to let us know He has ten fingers like us, so I'm not wrong.
23:36:14 <Cale> haha
23:36:19 <ivanm> yay for begging the question!
23:36:33 <copumpkin> nuh uh, and you're wrong cause your name is ivan
23:36:40 <ivanm> well, I suppose it's not technically begging the question...
23:36:54 * ivanm can't be bothered looking up the un-proofs page to work out the technical term
23:37:05 <copumpkin> :P
23:42:06 * copumpkin goes to sleep
23:47:05 <kmc> almost all real numbers are highly contrived
23:47:23 <c_wraith> By which you mean "cannot be represented in finite space"?
23:47:27 <kmc> yeah
23:48:47 <Jafet> Real numbers are imaginary.
23:48:57 <c_wraith> For the most part.
23:49:11 <Cale> heh
23:49:20 <Cale> Almost all real numbers are not definable, but that shouldn't stop us from using them :)
23:49:23 <kmc> almost every real number has continued fraction denominators with geometric mean 2.6854520010...
23:49:34 <kmc> (Khinchin's constant)
23:50:08 <Jafet> ...that raises the obvious question
23:50:15 <Cale> Yeah, that's a surprising result :)
23:50:59 <kmc> it's weird when people use some strong-ish version of the church-turing thesis to talk about a universe with continuous physics
23:51:26 <c_wraith> I see no reason to believe physics are continuous.
23:52:31 <c_wraith> In fact, I see no compelling evidence that our universe isn't a simulation running on a finite grid. :)
23:52:35 <Jafet> Blum devised a real number computer, I think
23:52:41 <kmc> a matrix, if you will
23:52:55 * Jafet stabs kmc with a spoon
23:53:48 <kmc> c_wraith, i think that's a statement about implementation, not semantics
23:54:19 <Jafet> Well, I don't think there are multiple implementations of the universe
23:54:32 <Cale> I don't think that there's an objective answer.
23:55:08 <Jafet> We're sitting around discussing metaphysics and you had to go all ooh, intellectual
23:55:10 <Cale> Any model which works well enough works well enough. :)
23:56:25 * Cale asks Wolfram Alpha if Steven Wolfram is the greatest scientist of the 21st century.
23:56:42 <c_wraith> I do have to wonder about Bell's Theorem.  I'm told there's a solution that involves reworking physics using infinite random matrices.  I support that.
23:56:43 <ivanm> Cale: now, of _course_ alpha is going to give an objective answer...
23:57:39 <eflister> who was looking for the spj imperative quote?  i was just looking at the awkward squad paper and the intro ends with this sentence "In short, Haskell is the world‚Äôs finest imperative programming language."
23:57:40 <kmc> i asked it "wolfram vs. jesus".  it has a useful timeline.
23:58:10 <ivanm> eflister: oh, it was SPJ?
23:58:16 <ivanm> I always thought it was dons...
23:58:18 <eflister> yep
23:58:22 <eflister> well maybe he stole it
23:58:44 <ivanm> probably
23:59:07 <ivanm> kmc: hmmm, I don'tt hink I've ever seen anyone claim to give a full name to Jesus before...
23:59:34 <kmc> "of Nazareth"
23:59:46 <eflister> are we really talking about bell's theorem?  i am completely cool with giving up on locality, i don't see why this bothers everyone.  the bohmian interpretation makes total sense, but it is the least accepted.
