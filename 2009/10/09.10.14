00:01:14 <Twey> Is there any common pattern for filter -> handler tables?  [(Filter, Handler)] I guess?
00:03:29 <FunctorSalad_> Twey: philosophical? they're just a black box in compiled code too, no?
00:03:40 <Twey> Aye.
00:03:48 <Twey> Identity comparison, I guess.
00:03:52 <Twey> Does this make me a bad person?
00:03:54 <FunctorSalad_> (barring stuff that wouldn't be referentially transparent)
00:04:11 <Twey> Well… it might be possible to compare the compiled code, byte for byte
00:04:16 <FunctorSalad_> maybe you want "data FunctionWithId a b = F Int (a -> b)"
00:04:33 <Twey> Maybe.  *nods*
00:05:29 <Twey> Actually, I think I'll abstract the common filter stuff out into a data-type and let the callback decide whether it's been handled or not.
00:05:41 <Twey> Looks like it might end up more convenient.
00:56:29 <hackagebot> uu-parsinglib 2.3.0 - New version of the Utrecht University parser combinator library (DoaitseSwierstra)
01:01:34 <Peaker> I wrote a Haskell presentation that I'm going to present to people who mainly know C, Python and some C++.  The main idea is to get the motivated to learn on their own (sometimes sacrificing some accuracy for space and a few overstatements :-).  Anyone wanna take a look and proof-read it for me?
01:02:25 <SmurfOR> Peaker, love to
01:02:48 <Peaker> SmurfOR, any idea how to upload a pdf anywhere? :)
01:03:06 <Peaker> SmurfOR, willing to privately share your email?
01:03:10 <SmurfOR> Peaker, if you use github you can throw it up there
01:03:14 <SmurfOR> Peaker, sure
01:04:19 <SmurfOR> i should have said "i'll take a peek" :/ looking back i regret that i didn't
01:05:22 <Peaker> SmurfOR, heh, you don't have to really proof-read/etc. a peek is great :)
01:07:59 <^Einstein> Peaker: I don't know enough about Haskell to be of any assistance proofing it, but I'd be very interested in reading it for my own benefit. Ping me when you've published it, aye?
01:09:09 <Peaker> ^Einstein, Sure. I don't know if I'm actually improving on the vast available materials, I've merely attempted to make it interesting, rather than trying to teach (Most tutorials start with "boring" basics)
01:09:50 <^Einstein> I could certainly use both methods, and I look forward to your presentation, Peaker. :)
01:16:36 <pozic> Is there a way to load c2hs modules into ghci?
01:17:27 <ertai> Hi there, I'm wondering if one can simplify «uncurry (liftA2 (,)) · (pure *** traverse f)»
01:17:43 <Axman6> pointfree --
01:18:15 * Axman6 does not equate pointfree style with simplification at all
01:19:07 <Zao> s/simplify/obfuscate/
01:19:08 <pozic> Obfuscation is the word.
01:19:11 <pozic> Heh
01:19:17 <Axman6> there we go
01:19:31 <Axman6> :t listA2 (,)
01:19:32 <lambdabot> Not in scope: `listA2'
01:19:36 <Axman6> :t liftA2 (,)
01:19:37 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
01:20:06 <Axman6> :t (\x y -> (,) <$> x <*> y)
01:20:07 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
01:20:16 <Axman6> @pl (\x y -> (,) <$> x <*> y)
01:20:16 <lambdabot> (((,) <$>) .) . (<*>)
01:20:22 <Axman6> much clearer!
01:20:23 <Axman6> >_>
01:20:31 <int-e> looks fishy
01:20:34 <Zao> Larry Wall would be proud.
01:20:36 <Peaker> I prefer  liftA2 (,)   to the point-ful style
01:20:40 <int-e> needs more tail fins though
01:20:49 <Peaker> @type uncurry (liftA2 (,))
01:20:49 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
01:21:04 <Peaker> @type traverse
01:21:04 <int-e> I propose to rename <$> and <*> to <$>< and ><*>, respectively.
01:21:05 <lambdabot> Not in scope: `traverse'
01:21:20 <Axman6> int-e: i'll second that
01:21:20 <Peaker> int-e, that's what infix-applicative does
01:22:59 <Peaker> @type \x y -> x <^(,)^> y
01:23:00 <lambdabot> Not in scope: `<^'
01:23:00 <lambdabot> Not in scope: `^>'
01:23:17 <Peaker> @let (<^) = (Control.Applicative.Infix.<^)
01:23:17 <lambdabot>  <local>:5:7: Not in scope: `Control.Applicative.Infix.<^'
01:23:27 <Peaker> well, you get the idea :)
01:24:07 <Peaker> the problem is that <^(,)^>  seems like its holding its ears and sticking its tongue out at you
01:24:13 <ertai> hum there is no instance for Traversable ((,) b)
01:24:31 <Gracenotes> int-e: like, (concat <$>< stateList) ? -_-
01:25:00 <Gracenotes> or (,,) <$>< [1..3] ><*> [1..3] ><*> [1..3]?
01:25:12 * Gracenotes looks at the code suspiciously
01:25:29 <int-e> Gracenotes: yes. learn Applicative with Dr. Seuss, one fish, two fish, red fish, blue fish!
01:26:55 <int-e> That would sound even better if we had kept the name 'Idiom'. :)
01:27:01 <pozic> Where is the documentation for C2HS installed when you cabal install it?
01:27:24 <dcoutts> pozic: I don't think there is any. The user guide does not get installed.
01:27:42 <pozic> dcoutts: ok, great :(
01:27:58 <pozic> dcoutts: The C2HS module source code is easy to read, though.
01:28:08 <pozic> dcoutts: what is the stability of C2HS?
01:28:25 <pozic> dcoutts: I have the impression that it is the only tool currently available that works.
01:28:41 <dcoutts> pozic: oh, you mean just the C2HS.hs module?
01:28:50 <dcoutts> pozic: or the c2hs tool
01:28:58 <pozic> dcoutts: For the tool there is the website.
01:29:07 <pozic> dcoutts: I was referring to the module.
01:29:35 <dcoutts> pozic: the module is just there as lib code for some of the marshaling functions that c2hs generates
01:29:50 <dcoutts> pozic: you shoudn't need to use any of it directly
01:30:00 <dcoutts> hence it doesn't need any documentation
01:30:06 <pozic> dcoutts: oh, I thought the tool said I had to import it.
01:30:12 <dcoutts> pozic: yes
01:30:13 <pozic> dcoutts: err documentation
01:30:34 <pozic> It seems kind of silly that one has to import it, if it is always needed.
01:30:52 <dcoutts> it's not always needed, I think some marshalers for the {# fun #} hook use it
01:31:00 <pozic> Ok.
01:31:08 <dcoutts> pozic: eg gtk2hs doesn't use the C2HS module
01:31:20 <dcoutts> it uses the older {# call hook #}
01:31:35 <dcoutts> pozic: if I had more time I'd phase out the C2HS module completely
01:31:46 <pozic> dcoutts: the documentation also said something about enums not being supported. What's the work around?
01:32:29 <pozic> I mean there are different ways to work around it, but I think it's just a matter of enum_1 = 1, etc.
01:33:02 <dcoutts> pozic: C enums are supported, CPP ones are not
01:34:19 <pozic> What are CPP enumerations then?
01:34:35 <pozic> I assume that by CPP you mean the preprocessor.
01:39:39 <Athas> Where can I find the documentation for Cabal?
01:39:46 <dcoutts> @where Cabal
01:39:47 <lambdabot> http://www.haskell.org/cabal
01:40:23 <Athas> Ah, thanks.
01:41:06 <bsdemon> Hi, why I getting
01:41:10 <bsdemon> Prelude> :m +Hass
01:41:12 <bsdemon> module `Hass' is not loaded
01:41:16 <Athas> Is .cabal/config documented anywhere?
01:41:31 <Axman6> bsdemon: what's Hass?
01:41:32 <bsdemon> when trying to import my newly created package registered with --inplace?
01:41:38 <dcoutts> Athas: only in .cabal/config
01:41:44 <bsdemon> it is my package
01:42:24 <dcoutts> Athas: if yours is lacking the list of allowed fields and default values then you've got one generated by an older version. You can back it up, let it be re-created and merge back your changes.
01:42:44 <Athas> dcoutts: alright.
01:51:35 <quetal> is the reason that the code: a = unsafePerformIO (putStr "hello") b = unsafePerformIO (putStr "hello")  is unsafe because of lazy evaluation, it might output "hello" once, twice, or never because the expressions a and b may not be evaluated?
01:52:19 <Peaker> quetal, unsafePerformIO is unsafe because it may break referential transparency, and in this case it indeed does
01:52:27 <Axman6> to me, it's unsafe because it's not pure
01:52:28 <Peaker> quetal, its only to be used on IO actions which are in fact pure
01:53:07 <quetal> pure = no side effects?
01:53:27 <quetal> what's the harm in outputting a string to console?
01:53:45 <Cale> quetal: The harm is that you have no idea when or how many times it will happen.
01:54:06 <Peaker> quetal, pure = no visible side effects + no visible dependency on outside world
01:54:19 <quetal> oh, I see
01:54:25 <quetal> thanks for the help
01:54:28 <Peaker> quetal, do you know "referential transparency"?
01:54:30 <Cale> quetal: Haskell isn't just lazily evaluated -- that's actually a bit of a lie. The truth is that its evaluation order is not specified beyond the fact that it has non-strict semantics.
01:54:34 <Axman6> quetal: unsafePerformIO is basically there purely so that if you're using the FFI with a C function you know is pure, you can make it a pure function on the haskell side too
01:55:08 <Cale> quetal: So, a compiler is allowed to rearrange the computation as much as it wants so long as it doesn't affect the termination behaviour.
01:55:16 <Peaker> Axman6, not only that.. also if you use IO to fork threads for whatever reason, and those don't have any visible effects, e.g: unamb
01:56:50 <quetal> referentially transparent means that it can be replaced by some other value and everything will be the same, right?
01:56:50 <quetal> not sure why this would apply here though
01:56:50 <Axman6> Peaker: well, that's not what it was put in there for is it? it is technically an abuse of its use imo
01:56:50 <Cale> quetal: It means that if f x = g x for all x, then you can replace f with g anywhere that it occurs
01:56:50 <Peaker> Axman6, why abuse?  unsafePerformIO is for actions that don't have *visible* effects
01:56:50 <Cale> quetal: That is, functions are completely determined by the values they produce.
01:56:50 <quetal> oh
01:57:12 <Axman6> quetal: you can anything that appears on the left hand side of the equals sign with exactly what appears on the right
01:57:25 <Cale> (Where by 'can replace', I mean without changing how the program behaves, except possibly for its performance in time or memory)
01:58:16 <quetal> and the only reason one would even consider replacing the values on the right side of an unsafePerformIO operation is because it asserts that it is indeed pure, when it's not?
01:58:18 <Axman6> so, if you have let f x = g x y z x in f x + f (2*x), that can be written as g x y z x + g (2*x) y z (2*x), and the result will _always_ be _exactly_ the same
01:58:49 <quetal> Axman6: thanks, I see now
01:59:43 <quicksilver> quetal: in particular it must not matter to you at all if the IO action gets performed never, once, or many times, and it must not matter to you *when* it gets performed.
01:59:58 <quicksilver> quetal: where by "not matter to you" I mean that you shouldn't be able to tell.
02:00:15 <quetal> oh right, that makes sense
02:01:00 <Axman6> Cale: are you responsible for lambdabot?
02:01:24 <Cale> Axman6: In a sense. I make sure it keeps running on a machine that lispy hosts.
02:01:42 <Axman6> can you get it to join #macosxdev?
02:02:14 <bsdemon> where I can find good intro to Parsec?
02:02:16 <Cale> Permanent or temporary? We lost the old machine that it was hosted on, so the join list was set back a bit.
02:02:27 <Axman6> permanently
02:02:31 <Cale> okay :)
02:02:36 <Axman6> thanks :)
02:03:32 <Cale> bsdemon: Well, the original one isn't so bad, if a little out of date.
02:03:39 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
02:03:51 <bsdemon> Cale: thanks
02:04:12 <Axman6> cheers Cale :)
02:04:22 <pozic> Why does c2hs tell me there are errors in my include file, while the C compiler accepts it when compiled with the c99 standard option?
02:04:22 <Cale> Axman6: no problem
02:04:32 <pozic>   Syntax error !
02:04:32 <pozic>   The symbol `wchar_t' does not fit here.
02:04:41 <pozic> What does that even mean?
02:04:54 <Cale> bsdemon: The module names have changed, and Parsec is a monad transformer and can operate on more general stream types now. But mostly it's the same :)
02:05:04 <pozic> Does it mean the c2hs parser is broken?
02:05:37 <Cale> What parser does c2hs use?
02:05:45 <Cale> It might just be parsing an older version of C.
02:06:20 <Gracenotes> @where applicativeparsec
02:06:20 <lambdabot> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ and http://book.realworldhaskell.org/read/using-parsec.html#id652399
02:07:17 <Peaker> the applicative parsec, I hope, converts your parser to a nice automaton?
02:07:17 * Cale wonders if ChilliX is alive to answer pozic's question :)
02:08:14 <pozic> Is ChilliX the author?
02:08:17 <int-e> c2hs uses language-c, unless it's the gtk2hs one.
02:08:22 <Cale> pozic: yeah
02:08:38 <Gracenotes> Peaker: with tape as an added bonus
02:08:58 <Peaker> Gracenotes, what?
02:09:01 <Cale> Yeah, it appears to use language-c which claims to be a complete C99 parser with GNU extensions...
02:09:08 <int-e> (language-c in turn is based on an earlier version of c2hs, with lots of module restructuring, cleanup, and new analysis code)
02:09:11 <Peaker> language-c is hard to use :-(
02:09:19 <Peaker> at least, lacking some examples
02:09:28 <pozic> I do use an #ifndef in the header file.
02:09:31 <Peaker> I want to use it to build a nice C indexer, but it doesn't even have Show instances for its types
02:09:41 <Gracenotes> parsec can be turing-complete
02:09:43 <Peaker> it really should define Show on everything
02:09:54 <int-e> Peaker: does Language.C.Pretty help?
02:09:54 <Peaker> Gracenotes, oh, I want it to be non-complete so it can be fast
02:10:53 <Gracenotes> ah. yes, applicative style is essentially context free, although maybe some lower-level combinators are > context-free
02:11:36 <Peaker> Gracenotes, I think its even regular if you don't have a combinator to allow some form of recursive definitions
02:11:40 <Gracenotes> it's how controlled the effects and ordering are
02:11:43 <Peaker> @hoogle ApplicativeFix
02:11:44 <lambdabot> No results found
02:12:03 <pozic> {#enum a_b as AB #} also doesn't work.
02:12:30 <pozic> Syntax error! The phrase `#}' is not allowed here.
02:13:23 <int-e> Peaker: well, probably not, because the purpose of that module is to generate C code. So everything not related to that purpose won't have Pretty instances.
02:13:37 <Gracenotes> recursive definitions are okay, as long as it's either left- or right- linear...
02:13:42 <Gracenotes> i think
02:16:16 <Peaker> int-e, at least "deriving Show" on everything so ghci is usable with it
02:16:53 <Peaker> int-e, I have a locally modified language-c with deriving Show on stuff, its much easier to figure out how to traverse the ADT that way.  Using Analysis seems to be too limited for my purpose (of writing a C indexer, that sees all type definitions, all member definitions, etc)
02:17:00 <pozic> The latter thing is a feature, I am not sure about the former one, though.
02:17:35 <Peaker> also, I haven't found any examples of use of the Trav monad, and its pretty hard to figure it out frmo haddock as a reference
02:18:09 <Axman6> anyone know of any attempts to make a C compiler in haskell?
02:18:12 <dcoutts> Peaker: send in a patch
02:18:24 <Axman6> i think it'd be interesting
02:18:49 <pozic> Axman6: yes, someone is doing that.
02:18:55 <pozic> Axman6: I don't remember who.
02:19:02 <Axman6> oh really? interesting
02:19:16 <pozic> Axman6: experimental, not production, AFAIK.
02:19:25 <Axman6> well yeah
02:19:34 <Axman6> experiments come before production :P
02:20:16 <quetal> if you create your own data type, like data newtype = newtype int int | deriving Eq
02:20:27 <quetal> does the deriving Eq mean you can use the comparator operator
02:20:44 <quetal> and if so, don't you have to define it yourself?
02:21:37 <Axman6> it means you can use ++ and /+
02:21:40 <Axman6> ==
02:21:42 <Axman6> -_-
02:22:09 <quetal> how does the compiler know what == does in this situation/
02:22:54 <Peaker> dcoutts, sure.. will try to find a repo for language-c
02:23:08 <dcoutts> Peaker: it's on code.h.o
02:23:19 <Peaker> thanks
02:28:11 <pozic> If I refer to wchar_t in a header file without including it, is the compiler wrong for accepting it?
02:28:38 <pozic> After adding the import c2hs did not error out at least. I still have to check the output.
02:33:37 <Cale> quetal: It derives a standard definition which compares the values structurally. Two values are only equal if they have the same constructor, and then each of the components of that constructor are equal
02:34:38 <Cale> quetal: By writing your own instance of Eq, you can do fancier sorts of comparison, but the one given by deriving is by far the most common choice.
02:43:07 <quetal> oh I see
02:43:10 <quetal> thanks Cale
02:50:13 <quetal> Cale do you know, what happens when someone adds "deriving Ord" to a custom type, how it compares the values?
02:50:35 <quicksilver> lexicographicall
02:50:45 <quicksilver> and in constructor order
02:50:54 <quetal> that's....horrible right
02:51:06 <quicksilver> that is, product types are lexicographic and sum types are in constructor order
02:51:08 <quetal> well I suppose nobody would do that in... real life
02:51:10 <quicksilver> seems perfectly sensible to me
02:51:19 <quicksilver> quetal: what about someone writing a dictionary? ;)
02:51:31 <quetal> haha, true
02:51:41 <quetal> I keep thinking of mix-and-match types
02:51:58 <quicksilver> obviously you don't use the 'deriving' instance if that's not what you want.
02:51:58 <c_wraith> If you just want *an* ordering, it works fine.
02:52:09 <quicksilver> the main reason to derive Ord is just so you can use Data.Map
02:52:11 <mmorrow> quetal: most times you don't care so much *what* the ordering is so much as there's *some* ordering
02:52:13 <quicksilver> (and other binary tree like things)
02:54:03 <Peaker> quicksilver, can you explain why having:  \x -> (x, x) :: forall b c. foreach [b,c] a. a -> (b, c)    would destroy type inference? Or other properties? I think it can be inferred, and just means "unify the type of caller's a with both b and c"
02:55:54 <zygoilid> Peaker: in what case is that not the same as :: forall a. a -> (a, a) ?
03:01:31 <quetal> if I havea new datatype like, datatype newnum = newnum Int Int, and I want to overload the comparison operator, like instance Ord newnum where (<=) (newnum a b) (newnum c d) = not (d > b) does that make sense?
03:02:00 <quetal> I mean, not the comparison logic itself
03:02:05 <quetal> but the way I wrote it
03:02:53 <quetal> also can I use like == in my own overloading, like this: instance Ord newnum where (<=) (newnum a b) (newnum c d) = not (d == b) would that work?
03:04:47 <ivanm> quetal: instance Ord NewNum where ...
03:04:57 <c_wraith> @src Ord
03:04:57 <lambdabot> class  (Eq a) => Ord a  where
03:04:57 <lambdabot>     compare      :: a -> a -> Ordering
03:04:57 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:04:57 <lambdabot>     max, min         :: a -> a -> a
03:05:16 <c_wraith> See the Eq constraint?  Everything that's an instance of Ord is also an instance of Eq.
03:05:19 <c_wraith> So you can use ==
03:05:31 <quetal> oh cool
03:05:31 <ivanm> quetal: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Prelude.html#t%3AOrd
03:05:39 <quetal> and if I only specify the <= operator for example
03:05:49 <ivanm> quetal: yes, you can (as that link says)
03:05:53 <quetal> it will infer from that what  >=, <, and > mean?
03:05:54 <ivanm> but you'd be better off defining compare
03:05:58 <ivanm> (as it is more efficient)
03:06:26 <quetal> oh I see
03:06:28 <quetal> thanks for the help
03:06:49 <ivanm> quetal: if you only define (<=), then (<) is "(<=) and not ==", (>=) is "not (<=) or (>)", etc.
03:07:38 <quetal> that's cool
03:08:05 <ivanm> so the automatic definitions are then rather inefficient
03:08:15 <Axman6> @src (<)
03:08:15 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
03:08:20 <Axman6> @src (<=)
03:08:20 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
03:08:33 <ivanm> @src compare
03:08:33 <lambdabot> compare x y | x == y    = EQ
03:08:33 <lambdabot>             | x <= y    = LT
03:08:33 <lambdabot>             | otherwise = GT
03:10:15 <Baughn> ivanm: Which is why my preference is to define compare
03:10:47 <Axman6> @src Ord
03:10:48 <lambdabot> class  (Eq a) => Ord a  where
03:10:48 <lambdabot>     compare      :: a -> a -> Ordering
03:10:48 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:10:48 <lambdabot>     max, min         :: a -> a -> a
03:11:01 <ivanm> Baughn: as is the preferred option listed on the docs
03:11:12 <ivanm> Baughn: my preference is to derive Ord :p
03:11:27 <ivanm> Axman6: that really cheap-looking place I found: turns out you can't live in it :s
03:11:43 <Axman6> oh? how come?
03:11:48 * mmorrow prefers manually writing Ord instances that break the rules then complaining
03:11:55 <Baughn> ivanm: Heh. Problem is, my Ord instances involve unsafePerformIO. :P
03:11:58 * mmorrow is feeling feisty currently
03:12:12 <ivanm> hmmmm, GHC has a different definition of compare than above
03:12:26 <ivanm> namely, it uses nested if-else... would that be slightly more efficient than guards?
03:12:48 <ivanm> Axman6: it's only for investment purposes and then rented out as part of the hotel
03:12:54 <ivanm> Axman6: found a better one though: http://www.waldorf-apartments.com.au/listingview.php?listingID=36
03:12:58 <ivanm> also cheaper! \o/
03:13:03 <ivanm> Baughn: heh
03:13:06 <Axman6> ivanm: buy it... and then rent it yourself :P
03:13:25 <ivanm> Axman6: nah, has to be vacationers, etc., not live in
03:13:28 <Axman6> i know where the waldorf is
03:13:32 <ivanm> yeah
03:13:40 <Axman6> doesn't look too bad
03:13:47 <ivanm> it's closer, fully furnished, cheaper, and appears to have net and foxtel included :D
03:13:55 <ivanm> so I have even more TV I'm not going to watch! :p
03:13:57 <Axman6> heh, awesome
03:14:10 <ivanm> + free holidays in other aussie waldorfs... >_>
03:14:14 <Axman6> yeah, i always find there's even less to watch on foxtel than free to air
03:14:39 * ivanm pats his external HDD that has video files magically appear on it
03:16:00 <ivanm> :o apparently compare is often more expensive than (<=)... I assume this is when people just define (<=) rather than compare...
03:18:27 <quetal> if I say mycomparator x1 x2 = let | sx1 = length x1 | sx2 = length x2  | in compare sx1 sx2, is the type of mycomparator just mycomparator :: (x1 x2) -> Bool ?
03:19:20 <quetal> well the compare function is: compare :: (Ord a) -> a -> a -> Ordering
03:19:23 <ivanm> I don't think that makes sense or is valid
03:19:33 <ivanm> since the guards don't seem to do anything...
03:19:42 <quetal> sorry the | means new line
03:19:46 <ivanm> ahhh
03:19:49 <ivanm> quetal: there are more efficient ways of determining which is the longer list
03:19:52 <Baughn> Sounds like he means 'myComparator = compare `on` length' or some-such
03:19:58 <ivanm> Baughn: yeah
03:20:10 <ivanm> @hoogle [a] -> [a] -> Bool
03:20:11 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
03:20:11 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
03:20:11 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
03:20:22 <ivanm> must be in a seperate package...
03:20:48 <quetal> o
03:20:49 <ivanm> isLonger [] _ = True; isLonger _ [] = False; isLonger (_:as) (_:bs) = isLonger as bs
03:20:58 <ivanm> quetal: ^^ use something like this
03:21:00 <quetal> if I know that compare instead returns some type called Ordering
03:21:02 <ivanm> especially if the lists are long
03:21:18 <mjrosenb> blast
03:21:24 <quetal> then would the type be mycomparator :: (x1 x2) -> Ordering ?
03:21:30 <mjrosenb> i am far too tired to solve this problem :(
03:21:30 <quetal> oh yes, that is much easier
03:21:35 <ivanm> (though in that case, you sould really have a custom data type that knows how long the lists are...)
03:21:42 <ivanm> mjrosenb: which problem?
03:23:34 <mjrosenb> given an n :: (Ord a) => a and  l :: (Ord a) => [a], return l with x removed, where x is the largest element such that x < n
03:23:52 <Baughn> ivanm: Of course, that's left-biased. You really /should/ return an Ordering..
03:23:53 <quetal> actually that type mycomparator :: (x1 x2) -> Ordering doesn't make sense because x1 and x2 are lists of some arbitrary type right, so would it instead by mycomparator :: ([a] [a]) -> Ordering  ?
03:24:09 <Baughn> [a] -> [b] -> Ordering, actually
03:24:33 <ivanm> Baughn: that's just for the actual length comparison
03:24:33 <quetal> why [b]?
03:24:42 <ivanm> but yes, if you want a compare function then it should return Ordering
03:24:45 <ivanm> @type compare
03:24:46 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:24:51 <Baughn> quetal: Because they don't have to be the same type
03:24:58 <ivanm> Baughn: can't use it for compare though then...
03:25:15 <Baughn> ivanm: Sure you can. It unifies with compare's signature just fine.
03:25:25 <Baughn> That limits its applicability, but it isn't a problem in itself
03:27:46 <ivanm> Baughn: you can't use it _as_ compare (but yes, you can have a seperate function with that type sig)
03:27:47 <quetal> but why do you say [a] -> [b] -> Ordering instead of ([a], [b]) -> Ordering
03:27:47 <quetal> it takes a tuple (pair) of two lists right
03:27:47 <quetal> whoops ([a] [b]) -> Ordering
03:27:47 <Baughn> :t compare
03:27:47 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:27:47 <Axman6> quetal: you had it right the first time
03:27:47 <Baughn> quetal: Because it's curried, as most functions are. It doesn't take a tuple.
03:27:47 <Axman6> mycompare :: ([a], [b]) -> Ordering
03:27:47 <Axman6> which should probably be mycompare :: [a] -> [b] -> Ordering
03:27:47 <quetal> oh
03:27:48 <quetal> is it wrong to write it the other way
03:28:03 <Axman6> no, but it's a little less useful/harder to use
03:28:03 <int-e> not wrong, but unusual
03:28:23 <int-e> we like partial applications :)
03:28:41 <ivanm> quetal: it's cleaner to get a pair and use it on a non-pair function than the other way round
03:28:53 <ivanm> due to partial application like int-e says
03:29:09 <int-e> like  mycompare [], which you'd have to write as  \bs -> mycompare ([], bs)  otherwise. Or, mycompare . (,) [] (which is unreadable)
03:29:15 <Axman6> quetal: with your one, you can't say: map (mycompare [1,2,3]) xs
03:29:20 <ivanm> generally, the only time I take a pair as an argument is if that function is directly only used on the results of another that returns a pair
03:29:25 <ivanm> (e.g. for unfoldr, etc.)
03:29:36 <Axman6> you'd need map (\x -> mycompare ([1,2,3],x)) xs
03:30:20 <quetal> oh ok
03:30:21 <mjrosenb> ivanm: it is also harder to have both of the inputs of one function to be the result of a computation when the function is curried
03:31:15 <Baughn> That's what curry/uncurry are for. :P
03:31:42 <Baughn> @hoogle (a -> b -> c) -> a -> b -> c
03:31:42 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
03:31:43 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
03:31:43 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
03:31:57 <Baughn> @hoogle uncurry
03:31:57 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
03:31:58 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
03:32:04 <Axman6> :t curry . uncurry
03:32:05 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
03:32:06 <Baughn> Hm. Shouldn't there be a..?
03:32:22 <int-e> @type flip . flip
03:32:23 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
03:32:24 * Baughn misses uncurry3
03:32:51 <Peaker> zygoilid, was away, sorry
03:32:52 <Axman6> @check flip . flip == curry . uncurry
03:32:53 <lambdabot>   No instance for (GHC.Classes.Eq ((a -> b -> c) -> a -> b -> c))
03:32:53 <lambdabot>    arising ...
03:32:56 <Axman6> >_>
03:33:00 <Peaker> zygoilid, mainly monomorphic values
03:33:02 <int-e> @pl \(a,b,c) -> a b c
03:33:03 <lambdabot> (line 1, column 6):
03:33:03 <lambdabot> unexpected ","
03:33:03 <lambdabot> expecting letter or digit, operator or ")"
03:33:03 <lambdabot> ambiguous use of a non associative operator
03:33:06 <Peaker> @type (show, show)
03:33:07 <lambdabot> forall a a1. (Show a, Show a1) => (a -> String, a1 -> String)
03:33:13 <Peaker> @type \x -> (x, x) $ show
03:33:14 <lambdabot>     Couldn't match expected type `a -> b'
03:33:14 <lambdabot>            against inferred type `(t, t)'
03:33:14 <lambdabot>     In the first argument of `($)', namely `(x, x)'
03:33:18 <Peaker> @type (\x -> (x, x)) $ show
03:33:19 <lambdabot> forall a. (Show a) => (a -> String, a -> String)
03:33:54 <Peaker> away again
03:33:59 <int-e> @type let the = (,) in join the show
03:34:00 <lambdabot> forall a. (Show a) => (a -> String, a -> String)
03:34:22 <quetal> @hoogle r1 = compare "String1" "String 2"
03:34:23 <lambdabot> Parse error:
03:34:23 <lambdabot>   --count=20 "r1 = compare "String1" "String 2""
03:34:23 <lambdabot>                 ^
03:34:45 <mmorrow> @type ((\x -> (x,x) :: (forall a. Show a => a -> String) -> (forall a. Show a => a -> String, forall a. Show a => a -> String)) show
03:34:46 <lambdabot> parse error (possibly incorrect indentation)
03:34:59 <mmorrow> @type ((\x -> (x,x)) :: (forall a. Show a => a -> String) -> (forall a. Show a => a -> String, forall a. Show a => a -> String)) show
03:35:00 <lambdabot> (forall a. (Show a) => a -> String, forall a. (Show a) => a -> String)
03:35:24 <quetal> why doesn't it like my code
03:35:25 <Baughn> @pl \a b c -> (a,b,c)
03:35:26 <lambdabot> (,,)
03:35:34 <mmorrow> > let (f,g) = (((\x -> (x,x)) :: (forall a. Show a => a -> String) -> (forall a. Show a => a -> String, forall a. Show a => a -> String)) show) in (f 42, g 'a')
03:35:35 <lambdabot>   Cannot match a monotype with `forall a.
03:35:35 <lambdabot>                                (GHC...
03:35:41 <mmorrow> bah
03:35:42 <Baughn> @pl \f (a,b,c) -> f a b c
03:35:43 <lambdabot> (line 1, column 8):
03:35:43 <lambdabot> unexpected ","
03:35:43 <lambdabot> expecting letter or digit, operator or ")"
03:35:43 <lambdabot> ambiguous use of a non associative operator
03:35:50 <Baughn> @pl \f a b c -> f (a,b,c)
03:35:51 <lambdabot> (. (,,)) . (.) . (.)
03:36:06 <Axman6> quetal: what's @hoogle r1 = compare "String1" "String 2" supposed to do?
03:36:24 <quetal> i thought @hoogle invokes the lambdabot or something
03:36:41 <quetal> I just want to see it assign some value of type of Ordering to r1
03:36:56 <Axman6> > compare "String1" "String 2"
03:36:57 <lambdabot>   GT
03:37:03 <yitz> Baughn: what was wrong with \f (a,b,c)?
03:37:06 <Axman6> quetal: what do mean by assign?
03:37:20 <quetal> oh shit
03:37:30 <Baughn> yitz: Incomplete \bot
03:37:41 <SamB_XP> oh, what would be my best bet if I want to read in some C++ header files and process the declarations thus obtained ?
03:37:49 <yitz> @pl \f(a,b)->f a b
03:37:49 <lambdabot> (`ap` snd) . (. fst)
03:37:53 <Peaker> mmorrow, that requires the function to be even more polymorphic than it really has to be. You don't need an a. that can be unified with any Showable type. You need one that can be unified just with the two tuple element types
03:38:02 <quetal> this reminds me of when someone says something racist like, "you people" and then everyone says "what do you mean, 'you people'"
03:38:10 <Baughn> yitz: ..what
03:38:15 <Baughn> @pl \f(a,b,c)->f a b c
03:38:16 <lambdabot> (line 1, column 7):
03:38:16 <lambdabot> unexpected ","
03:38:16 <lambdabot> expecting letter or digit, operator or ")"
03:38:16 <lambdabot> ambiguous use of a non associative operator
03:38:19 <Baughn> ...
03:38:24 <Axman6> quetal: heh, what?
03:38:26 <Baughn> It hates me.
03:38:27 <mmorrow> Peaker: ?
03:38:28 <Peaker> a foreach [types] type. extension could allow more fine-grained control of unification/polymorphism
03:38:28 <yitz> Baughn: oh, I see, it doesn't have deconstructors for n-tuples with n>2
03:38:34 * Axman6 is so confused now
03:38:35 <quetal> I was thinking in procedural style
03:38:39 <Baughn> yitz: No. Clearly, it hates me.
03:38:46 <quetal> that's why I said assign
03:38:50 <yitz> @vixen do you hate Baughn?
03:38:51 <lambdabot> no, i never hate
03:38:59 <pozic> If someone is looking for an idea for a program: please write something which uses inotify on Linux with a hook to call a program when a certain file changes.
03:39:01 <Axman6> @vixen but you do
03:39:02 <lambdabot> what's the matter?
03:39:02 <mmorrow> Peaker: you need a (forall a. Show a => a -> String) in order to duplicate it, and later instantiate that `a' at two different types
03:39:06 <Peaker> mmorrow, I am suggesting this type for \x -> (x, x):  forall a b. foreach [a,b] c. c -> (a, b)  Note I don't need c to be fully polymorphic by the caller
03:39:07 <int-e> is there any proposal to add new functions to Data.Tuple?
03:39:12 <Axman6> @vixen you hate Baughn!
03:39:12 <lambdabot> what makes you think i hate?
03:39:29 <quetal> wtf
03:39:32 <quetal> is that bot still a bot
03:39:38 <Peaker> mmorrow, rather than (forall a b. (forall c. c) -> (a, b))
03:39:39 <quetal> or did someone take over
03:39:45 <int-e> @vixen do you like haskell?
03:39:45 <lambdabot> church is my favourite computer scientist.
03:39:49 <Peaker> mmorrow, would work for any type-class, too
03:40:06 <yitz> @vixen are you still a bot, or did someone take over?
03:40:06 <lambdabot> why does everyone ask i'f on a bot?
03:40:11 <int-e> @vixen do you go to church?
03:40:11 <lambdabot> i do occassionally, i guess
03:40:43 <mmorrow> Peaker: (forall a. Num a => a) -> (Int,Double)  ?
03:40:57 <quetal> @vixen respond quickly so I know you're a bot
03:40:58 <lambdabot> no, how dare you ask if i'm a bot!
03:41:00 <Axman6> @vixen which religion do you follow?
03:41:00 <lambdabot> yes i do
03:41:04 <quetal> shit
03:41:06 <Peaker> mmorrow, what about it?  It requires the caller to give a fully polymorphic Num
03:41:09 <blackdog> quetal: that's just unkind
03:41:10 <mmorrow> Peaker: (i'm not really following what your notation means)
03:41:10 <Axman6> lol
03:41:23 <Peaker> mmorrow, it means that the type "c" is compatible (unifiable) with types a and b
03:41:24 <Axman6> @vixen what's your religion?
03:41:24 <lambdabot> let's don't talk about that
03:41:26 <blackdog> but a delay is a good idea...
03:41:36 <int-e> and typos!
03:41:39 <Peaker> mmorrow, notice no mention of type-classes there
03:41:46 <mmorrow> Peaker: what other than (forall a. Num a => a) is unifiable with Int and Double?
03:41:47 <blackdog> there are a heap of typos in there already:)
03:42:04 <Peaker> mmorrow, many other type-classes could be
03:42:05 <yitz> blackdog: when \bot is ported to google talk, we need it so say "typing..."
03:42:13 <shaleny> pozic, isn't it something you need http://linux.die.net/man/8/incrond ?
03:42:18 <mmorrow> Peaker: ok, then s/Num/those/
03:42:28 <int-e> @vixen do you know what a tpyo is?
03:42:28 <blackdog> Axman6: jeez, mate, do you ask your dates how much they weigh too?
03:42:30 <lambdabot> i think i know
03:42:35 <Peaker> mmorrow, perhaps   (forall a. Bound a => a)  (not sure if Double is Bound)
03:42:40 <Axman6> blackdog: on;y if they're fat
03:42:42 <Axman6> XD
03:42:45 <Peaker> mmorrow, but can you make a type that covers all of them?
03:42:45 <int-e> > minBound :: Double
03:42:46 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
03:42:46 <lambdabot>    arising from a use o...
03:42:48 <Peaker> mmorrow, can you write a \x -> (x, x)   that works for show, for Nums, for Bound, etc?
03:42:50 <SamB_XP> okay, I didn't see any answers yet ... does anyone have any suggestions for how to get at C++ declarations?
03:43:00 <blackdog> yitz: axman6 got me a google invite, maybe it'll happen (at least for vixen)
03:43:00 <Peaker> mmorrow, with the "foreach" type, I think it should work
03:43:03 <Axman6> heh, i've had a girlfriend for almost 2 years man, i don't have dates :P
03:43:07 <blackdog> Axman6: so all of them :P
03:43:17 <Axman6> oh snap
03:43:20 <mmorrow> Peaker: hmm, not sure
03:43:30 <Axman6> Sarah will be very upset by your comments
03:43:35 <Axman6> you're a jerk
03:43:37 <Axman6> :P
03:43:53 <blackdog> it's best that she learns my true nature straight up
03:43:53 <quetal> haha
03:43:56 <zygoilid> Peaker: ah, i see :) you want \x -> (x, x) :: forall a b c. (a ~ b, a ~ c) => a -> (b, c) or something
03:44:24 <yitz> SamB_XP:  get at them?
03:44:32 <Peaker> zygoilid, yeah, but ~ is type-equality,  maybe that's too harsh
03:44:40 <Peaker> zygoilid, or does it just mean they're unifiable?
03:44:41 <zygoilid> Peaker: right, something like, but looser than, ~
03:44:58 <SamB_XP> yitz: well, get them somehow parsed and converted to Haskell-friendly form ...
03:45:34 <zygoilid> Peaker: well, the trouble really is that the unification algorithm doesn't like the variables in which things are polymorphic themselves being polymorphic i think
03:46:11 <Peaker> zygoilid, I don't know much type theory or how the type inference works, esp. not with type-classes, but to my ignorant eye, my extension seems plausible :)  Your syntax is nicer though
03:46:58 <zygoilid> Peaker: i wonder whether this is subtyping in disguise
03:48:33 <SamB_XP> zygoilid: hmm?
03:48:33 <SamB_XP> it doesn't like type variables to be polymorphic ???
03:48:33 <SamB_XP> didn't know it cared!
03:48:33 <SamB_XP> I thought it was just that the kind system was too lame to support polymorphism :-(
03:48:39 <zygoilid> Peaker: \x -> (x, x) :: forall a b c. (c < a, b < c) => a -> (b, c)
03:48:39 <zygoilid> ... where we think of Int -> String as being a subtype of Show a => a -> String
03:48:52 <Peaker> zygoilid, <= I'd use
03:49:12 <Axman6> ivanm: so when are you moving down?
03:49:12 <Peaker> zygoilid, I think that notation is typically used for definedness, no?
03:49:29 <quetal> how do I get the bot to tell me what implementation of 'compare' it's using for this: compare "String1" "string2"
03:49:36 <quetal> > compare "String1" "String2"
03:49:38 <lambdabot>   LT
03:49:42 <quetal> bah
03:49:44 <quetal> tell me!!
03:49:53 <Axman6> quetal: what do you want to know?
03:49:54 <quetal> @hoogle compare "String1" "String2"
03:49:54 <lambdabot> Parse error:
03:49:54 <lambdabot>   --count=20 "compare "String1" "String2""
03:49:54 <lambdabot>                      ^
03:50:06 <quetal> which compare implmentation it uses
03:50:07 <Axman6> quetal: it's telling you all it can...
03:50:10 <Axman6> oh
03:50:17 <zygoilid> Peaker: definedness is an ordering on values not on types so i think there's not really an ambiguity of that sort there
03:50:21 <Axman6> well... > executes the haskell after it
03:50:21 <burp> which implementation? the one for strings?
03:50:25 <quetal> like from here: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Prelude.html#t%3AOrd
03:50:57 <mmorrow> quetal: notice the "source code" link at the top
03:50:59 <Peaker> zygoilid, < between values has a completely different meaning though :)
03:51:14 <mmorrow> quetal: if it's being derived, you'll need to look at the deriving code in ghc
03:51:24 <zygoilid> Peaker: well, < on values in terms of definedness is not computable ;-)
03:51:24 <quetal> o
03:51:31 <quetal> nevermind then
03:51:44 <Axman6> @src [] compare
03:51:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:51:47 <Axman6> :(
03:51:55 <quicksilver> Peaker: I appreciate other people have given you partial answers but I don't have a simple answer for you
03:52:14 <quicksilver> Peaker: it boils down to the basics of the unification algorithm, and why HM only ever infers rank-1 types.
03:52:37 <Peaker> quicksilver, inferring rank-N types would be undecidable or what?
03:52:53 <yitz> @src compare
03:52:54 <lambdabot> compare x y | x == y    = EQ
03:52:54 <lambdabot>             | x <= y    = LT
03:52:54 <lambdabot>             | otherwise = GT
03:53:28 <quicksilver> Peaker: yes, it is.
03:53:35 <Peaker> zygoilid, I don't think sub-typing is right here, though.. Usually its used in the context of some sub-ADT, I think, and not in the context of less/more-specificness of classes.. I think the ~ notation is nicer
03:53:39 <mmorrow> Peaker: essentially you're wanting a ((a -> b) -> (a -> c) -> (a -> (b,c)), where the compiler figures out what (a -> b) and (a -> c) you intend, then adds them as args to the code it generates
03:54:03 <Peaker> quicksilver, I think if you had to manually specify the ~ notation in a signature when you wanted it, like the MR would be an OK extension too, no?
03:54:10 <Athas> Does a Haskell-SML(/NJ) FFI exist?
03:54:18 <Peaker> mmorrow, That's one way to have it, yeah
03:54:19 <Athas> That's much more important than that C stuff, you know.
03:55:21 <zygoilid> Peaker: it certainly feels like there's a variance issue; depending on whether the type is used in positive or negative position i'd expect functions would need either 'this or something bigger' or 'this or something smaller' as their types
03:55:34 <Peaker> mmorrow, it would allow more composability, like having:  \binop x y -> fromIntegral x `binop` fromIntegral y == (`on` fromIntegral)
03:56:11 <Peaker> @type (*) `on` fromIntegral
03:56:12 <lambdabot> forall b a. (Num b, Integral a) => a -> a -> b
03:56:20 <Peaker> @type \x y -> fromIntegral x * fromIntegral y
03:56:21 <lambdabot> forall a b a1. (Integral a, Num b, Integral a1) => a -> a1 -> b
03:56:30 <Peaker> that's not nice :-(
03:56:40 <quicksilver> there are quite a few papers on higher rank type inference, Peaker
03:56:51 <quicksilver> there are quite a few fragments which are larger than rank-1
03:57:03 <Peaker> quicksilver, but higher-ranks types are not enough here
03:57:04 <quicksilver> (GHC itself infers a slightly larger fragment than rank-1)
03:57:14 <Peaker> (for this example, they are)
03:57:22 <Peaker> but not for the   \x -> (x, x)  example
03:57:35 <mmorrow> Peaker: what are you after? not having to provide an explicit type-sig?
03:57:51 <zygoilid> Peaker: for instance, we might have \f -> (f 1 :: String, f True :: String) :: forall f. (f ~ Int -> String, f ~ Bool -> String) => f -> (String, String)
03:59:19 <fasta> When is 6.12.1 going to be released? And what shared library support is actually working in 6.10 and 6.12? The ticket for shared libraries says that "it" works on 6.12.1, but what works?
03:59:19 <Peaker> mmorrow, getting rid of a difference that feels artificial to me, between  (\x -> (x,x)) y   and (y, y)    I think it would be more elegant if the two were truly equivalent
03:59:19 <Axman6> fasta: RC1 was only released this week
03:59:19 <Peaker> zygoilid, :-)
03:59:19 <zygoilid> Peaker: but we could accept a more general (forall a. Show a => a -> String) as an argument, whereas in the \x -> (x, x) case we wanted a more specific type
03:59:19 <zygoilid> it's quite likely i'm confusing myself here :)
03:59:48 <Peaker> zygoilid, why demand a more general type?
04:00:08 <Peaker> zygoilid, what if they can only get the string you want on Ints and Bools
04:00:52 <zygoilid> Peaker: i was trying to show that ~ is not commutative but i think i failed ;-)
04:01:06 <zygoilid> (at least with the extra semantics we're trying to assign to it)
04:01:44 * Peaker will bbl
04:13:31 <FunctorSalad> pointlessery can cut either way simplicity-wise
04:13:50 <FunctorSalad> oh nvm that discussion was from 3 hours ago
04:13:58 <FunctorSalad> I had just left IRC ;)
04:15:00 <Wup> anyone interested in helping out with a gtk2hs/state problem?
04:16:09 <Wup> I want to move a box around using buttons but I can not figure out how to manage the state
04:18:39 <hackagebot> darcs-benchmark 0.1.2 - Comparative benchmark suite for darcs. (PetrRockai)
04:18:44 <Wup> in okther words, how do you do something like : onClicked button moveStuff ?
04:19:41 <Axman6> @where+ syntax-tour http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
04:19:41 <lambdabot> Good to know.
04:19:48 <Axman6> @where syntax-tour
04:19:48 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
04:22:48 <FunctorSalad> Wup: onClicked button (moveStuff myIORefs)
04:23:35 <FunctorSalad> maybe there's some pure way, I don't know gtk2hs well enough
04:25:15 <Philippa> I built and installed my own lib via cabal and now it's not working. I'm not aware of having done anything that should mess with it in the meantime, but GHCi gives me link/loading errors: "Loading package pprint-0.1 ... linking ... <interactive>: C:\Program Files\Haskell\pprint-0.1\ghc-6.10.4\HSpprint-0.1.o: unknown symbol `___stginit_pprintzm0zi1_PrettyPrinterziHTML_' "
04:25:35 <Philippa> it was working fine for a while, I'd just come back to my coding to get that
04:26:18 <int-e> Philippa: is that your package? It looks like you forgot to list PrettyPrinter.HTML as an Other-Module.
04:27:31 <Wup> FunctorSalad: what does myIORefs stand for in your example ?
04:27:54 <FunctorSalad> Wup: a record containing IORefs containing your global state
04:28:12 <Philippa> int-e: ah. I didn't have an other-module line at all
04:28:25 <int-e> Philippa: it's sad that this is only noticed when the offending package gets linked elsewhere. (it's other-modules)
04:29:10 <int-e> but this is related to Cabal not checking module dependencies itself, relying on ghc --make to work them out.
04:29:30 <Philippa> yeah. Thanks
04:29:54 <Wup> FunctorSalad: ok, I don't know monads ands IORefs good enough I think but I'll check it out, thanks
04:30:00 <Philippa> I was sorta hoping that said dependencies'd get carried automatically, my bad. Dunno why the hell it was working for me for a while though
04:30:45 <int-e> inlining, perhaps?
04:31:49 <FunctorSalad> Wup: mind you, IORefs are a bit of a last resort, but maybe there's no other way in gtk2hs to get state to the callbacks
04:32:27 <Wup> ok
04:39:30 <guerrilla> Why does "evens n = [ x   | x <- [1..], even x]" print an infinite list of even numbers, but "evens n = [ x   | x <- [1..], even x, x < n]" just stall forever?
04:39:50 <guerrilla> for like "even 10"
04:39:58 <dcoutts> Wup: recently I've decided I like an approach using threads and message queues, rather than IORefs
04:41:16 <quicksilver> guerrilla: because it is look for any very large numbers which might be less than 10.
04:41:24 <dcoutts> Wup: the technique is when events happen, to send messages to a message queue that another thread is reading from and handling them.
04:41:25 <quicksilver> guerrilla: you never know :)
04:41:29 <Axman6> > let evens n = [x | x <- [1..], even x, x < n] in evens 10
04:41:33 <lambdabot>   mueval-core: Time limit exceeded
04:41:35 <dcoutts> Wup: the point is, that other thread holds the application state
04:41:37 <Axman6> huh
04:41:58 <Lemmih> > let evens n = [x | x <- [1..n], even x] in evens 10
04:41:58 <Wup> ok, sounds interesting
04:41:58 <lambdabot>   [2,4,6,8,10]
04:42:26 <Axman6> so... are list comprehensions not lazy? or...
04:42:39 <Wup> I'll have a look at that too
04:42:42 <Lemmih> Axman6: It's like: filter (< 10) [2,4 ..]
04:42:47 <FunctorSalad> dcoutts: but chans are just locked IORefs too no?
04:42:56 <FunctorSalad> (or rather MVars are
04:42:57 <FunctorSalad> )
04:43:03 <dcoutts> FunctorSalad: sure
04:43:04 <EnglishGent> hello :)
04:43:08 <Axman6> Lemmih: and that's not lazy either?
04:43:19 <Axman6> > filter (< 10) [2,4..]
04:43:23 <lambdabot>   mueval-core: Time limit exceeded
04:43:36 <Axman6> > take 3 . filter (< 10) $ [2,4..]
04:43:37 <lambdabot>   [2,4,6]
04:43:42 <Lemmih> Axman6: It'll keep looking for numbers smaller than 10 even though it will never find them.
04:44:06 <Axman6> oh bleh, of course, \bot can't print it until it's either all evaluated, or it can show enough
04:44:10 <Axman6> > take 3 . filter (< 1000) $ [2,4..]
04:44:11 <lambdabot>   [2,4,6]
04:44:14 <Axman6> > filter (< 1000) $ [2,4..]
04:44:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
04:44:30 <guerrilla> thanks so much :)
04:46:01 <quicksilver> ghci in the other hand, consumes the show result char by char
04:46:08 <quicksilver> so in ghci you do see the partial result before it hangs
04:46:32 <ivanm> Axman6: probably feb
04:46:41 <Axman6> cool
04:46:43 <ivanm> since I just might possibly be going to PEPM in Spain in Jan
04:46:52 * ivanm doubts it, but it _could_ happen... >_>
04:46:52 <Axman6> remind me t take you to my favourite pub when you get here
04:47:04 <Axman6> PEPM?
04:47:16 <ivanm> Partial Evaluation and Program Manipulation
04:47:24 <ivanm> Axman6: the HCAR editor is one of the organisers
04:47:34 <Axman6> HCAR?
04:47:39 <ivanm> he asked me to submit sourcegraph to it, hence the sudden work with multiple releases ;-)
04:47:47 <ivanm> Axman6: Haskell Community and Activities Report
04:47:55 <Axman6> ah
04:47:56 <ivanm> you don't know what it is? :o
04:48:06 <Axman6> nope
04:48:10 <ivanm> :o
04:48:13 <Axman6> didn't kow sourcegraph was yours either
04:48:19 <ivanm> how long have you been using Haskell for?
04:48:31 * ivanm is suddenly suspicious of Axman6, suspecting him of being a Java spy...
04:50:40 <Axman6> <_<
04:50:53 <ivanm> >_>
04:51:11 <ivanm> Axman6: anyway.... I don't drink :s
04:51:17 <ivanm> I'll still go to the pub though ;-)
04:51:19 <Axman6> :o
04:51:21 * ivanm likes pub food
04:51:26 <Axman6> i thought you were australian? :O
04:51:26 <ivanm> (usually, anyway)
04:51:28 <Axman6> :P
04:51:29 <ivanm> heh
04:51:38 <Axman6> yeah, this place has not too bad food
04:51:57 <ivanm> Axman6: I'm three quarters Ukrainian and one quarter Serbian; the Ukrainian heritage will drink to anything whilst the Serb bit will drink anything
04:51:59 <Axman6> their burgers are insane. the patty is about the size of a medium to large potato
04:52:08 <ivanm> as such, I feel I have enough ancestral alcohol consumption ;-)
04:52:11 <ivanm> Axman6: :o
04:52:14 <ivanm> nom nom nom
04:56:31 <bastl> hi. How can i force System.IO.readFile and Co.  to read eagerly ??
04:56:55 <ivanm> bastl: what do you mean by "eagerly"?
04:58:00 <bastl> i read that it evaluates lazy as usual, and that that can cause troubles which i have: the string i get from the file seems to be empty ...
04:58:05 <bastl> (but the file isnt)
04:58:51 <Raevel> i'm guessing that Data.ByteString.readFile is eager
04:58:52 <ivanm> so you want strict read (i.e. read everything in straight away)?
04:59:09 <ivanm> AFAIK eager means it is semi-lazy in that it reads a few more lines ahead than what you actually want
04:59:19 <ivanm> (IIRC, that's what eager haskell does...)
04:59:29 <ivanm> but yes, strict bytestring is probably what you want then
05:00:07 <bastl> hmm, perhaps its not that problem ...
05:00:10 <Raevel> which you can Data.ByteString.Char8.unpack if you want a String
05:01:34 <bastl> heres my code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4367#a4367 I only get an empty string :-/ (but the file is ok)
05:10:02 <quicksilver> I think withFile is incompatible with hGetContents ?
05:10:53 <quicksilver> because withFile closes the file
05:11:03 <quicksilver> and you don't want to do that with hGetContents
05:15:17 <ivanm> Axman6: this is an interesting "neighbouring city" of canberra: http://canberra.locanto.com.au/flats-for-sale/355/
05:19:32 <Axman6> ivanm: eh?
05:19:45 <Axman6> oh ha
05:19:47 <ivanm> I was googling for apartments in canberra and that one came up...
05:19:50 <ivanm> ;-)
05:21:18 <bastl> How does the "pointless" thing work with the bots here? I want to compactify an expression ...
05:21:24 <bastl> help h = (return . BS.unpack) =<< BS.hGetContents h
05:21:38 <trzkril> @pl \h -> (return . BS.unpack) =<< BS.hGetContents h
05:21:38 <lambdabot> (BS.unpack `fmap`) . BS.hGetContents
05:21:51 <bastl> wow
05:22:48 <bastl> damn now i want to understand :-)
05:22:54 <bastl> what instance of fmap is that ?
05:23:24 <trzkril> the right one, of course
05:23:56 <sinelaw> quick poll: what's a "reactive system"?
05:23:57 <quicksilver> the IO one
05:24:13 <quicksilver> BS.hGetContents is (Handle -> IO ByteString)
05:24:28 <quicksilver> BS.unpack is (ByteString -> [Word8])
05:24:32 <ivanm> sinelaw: a system that reacts
05:24:34 <ivanm> duh ;-)
05:24:41 <quicksilver> so (fmap BS.unpack) is (IO ByteString -> IO [Word8])
05:24:49 <quicksilver> and the two can be composed with .
05:24:55 <bastl> i see
05:25:14 <sinelaw> ivanm, i was looking for a slightly more detailed definition
05:25:24 <trzkril> @type (BS.unpack `fmap`)
05:25:25 <lambdabot> forall (f :: * -> *). (Functor f) => f BSC.ByteString -> f [Word8]
05:25:30 <ivanm> sinelaw: oh....
05:25:31 <ivanm> ;-)
05:25:32 <trzkril> @type fmap BS.unpack
05:25:33 <lambdabot> forall (f :: * -> *). (Functor f) => f BSC.ByteString -> f [Word8]
05:25:41 <sinelaw> :)
05:25:43 <zygoilid> help h = BS.unpack <$> BS.hGetContents h
05:25:50 <trzkril> why does @pl prefer the section in that case?
05:26:04 <quicksilver> special case hack for fmap, maybe
05:26:11 <quicksilver> @pl fmap f
05:26:11 <lambdabot> fmap f
05:26:16 <quicksilver> @pl fmap BS.unpack
05:26:16 <lambdabot> fmap BS.unpack
05:26:20 <quicksilver> no idea :)
05:26:44 <zygoilid> @pl (return . Foo) =<< bar
05:26:45 <lambdabot> Foo `fmap` bar
05:27:11 <zygoilid> @pl bar >>= return . Foo
05:27:11 <lambdabot> Foo `fmap` bar
05:28:01 <bastl> is fmap in infix together with composition a common idiom ?
05:28:30 <Axman6> @src Monad
05:28:30 <lambdabot> class  Monad m  where
05:28:31 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:28:31 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:28:31 <lambdabot>     return      :: a -> m a
05:28:31 <lambdabot>     fail        :: String -> m a
05:28:51 <Axman6> hmm, so there's no actual constraint that monads have to be functors?
05:29:04 <benmachine> no actual constraint no
05:29:13 <benmachine> hence liftM
05:29:29 <benmachine> but if you don't make your monad a functor people glare at you
05:29:30 <Axman6> (i'm assuming that there is a instance Functor a => Monad a where fmap f x = x >>= return . f)
05:30:04 <benmachine> well no because the syntax doesn't like that sort of thing
05:30:11 <benmachine> it overlaps
05:30:41 <benmachine> but for every specific type that has a Monad instance, it is possible and highly recommended to define a Functor instance
05:30:42 <RayNbow> take n $ [a | a <- as, p a] ++ [b | b <- bs, p b]   -- is there a nice way to express this using mathematical set notation?
05:30:53 <ivanm> Axman6: return . f == liftM
05:30:59 <ivanm> * liftM f
05:31:22 <RayNbow> (where I don't really care which elements are taken from sets A and B, as long as elements from A are preferred and the resulting set has cardinality n)
05:31:26 <Botje> RayNbow: given that as and bs are the same type ( I presume) you can just do take n $ filter p (as ++ bs)
05:32:03 <Botje> (or you can use [x | x <- (as ++ bs), p x] if you want to stick to list comprehensions)
05:32:18 <RayNbow> Botje: the thing is, I'm not looking for a Haskell expression :p
05:32:31 <Botje> oh.
05:32:39 <RayNbow> but I'm going the other way around... from Haskell to math :p
05:33:40 <Botje> you can say A ∪ B
05:33:46 <Botje> that's one part of the solution.
05:34:06 <Axman6> RayNbow: {x | x E as /\ x E bs, p x}?
05:34:12 <benmachine> and you turn <- into little e thing
05:34:17 <Botje> of course then you lose the preference.
05:34:18 <Axman6> where E = elem
05:34:36 <RayNbow> Axman6: see Botje's remark
05:35:08 <RayNbow> I need to express the preference of selecting elements from the first set
05:35:13 <Axman6> A ∪ B works too
05:35:34 <Axman6> RayNbow: eh?
05:35:37 <Botje> RayNbow: you could case on the cardinality of the select from A.
05:36:10 <RayNbow> Botje: ah, that's a nice trick
05:36:39 <Botje> "let set C be the set of elements from A that satisfy condition p. If #C < N, let C' be the union of C and the set of elements from B that satisfy B.
05:36:40 <RayNbow> then I'd only have to figure out how to write "select n-k elements from set B" in math notation
05:37:02 <Botje> of course , a set is not ordered.
05:37:46 <Botje> so you'll have to talk about a subset with a certain cardinality
05:38:04 <Botje> and probably argue that _which_ subset doesn't matter
05:38:27 <bastl> hayoo queries are quite slow in contrast to hoogle ...
05:38:45 <quicksilver> "take a subset of p A of size n, unless |p A| < n in which case, all of p A \union a subset of p B of size (n - |p A|)
05:38:57 <quicksilver> which gives you a non-deterministic choice
05:39:04 <quicksilver> it's up to you to prove that doesn't matter.
05:40:48 <RayNbow> well, it might matter which subset is taken, but that is left as a refinements detail
05:40:52 <FunctorSalad> bastl: hayoo has been slow lately, iirc it hasn't always been that way
05:40:56 <FunctorSalad> probably just their server
05:41:15 <fasta> Has anyone installed 6.12 RC already successfully?
05:41:17 <RayNbow> anyway, thx for the help :)
05:41:48 <fasta> And more importantly, does it break libraries?
05:42:29 <FunctorSalad> breaks cabal-install afaik :-(
05:42:44 <FunctorSalad> well, head branch did that to me but I think the RC does too
05:44:26 <Raevel> Just (maybe Nothing) -- agnostic nihilist programs haskell
05:44:32 <ivanm> FunctorSalad: yeah, because ghc-pkg has a new format
05:44:45 <ivanm> cabal 1.8 understands the new format, but dcoutts hasn't ported cabal-install to it yet
05:45:18 <fasta> FunctorSalad: that's quite important.
05:45:34 <FunctorSalad> @type Just (maybe Nothing)
05:45:35 <lambdabot> forall a a1. Maybe ((a1 -> Maybe a) -> Maybe a1 -> Maybe a)
05:46:04 <ivanm> fasta: libraries which have upper bounds on containers, arrays, etc. will probably break
05:46:14 <ivanm> a couple of other small things
05:46:17 <FunctorSalad> @djinn Maybe ((a1 -> Maybe a) -> Maybe a1 -> Maybe a)
05:46:17 <hackagebot> GenI 0.20.1 - A natural language generator (specifically, an FB-LTAG surface realiser) (EricKow)
05:46:18 <lambdabot> f = Nothing
05:46:23 <ivanm> IIRC, the only real major change is Cabal
05:46:35 <ivanm> most other changes are mainly cosmetic, etc.
05:46:43 <Raevel> thank you djinn for deciding our fate
05:46:45 <ivanm> (though they're really trying to get people to migrate to base-4)
05:46:51 <ivanm> Raevel: heh
05:47:17 <hackagebot> prelude-plus 0.0.0.6 - Prelude for rest of us (YusakuHashimoto)
05:47:45 <fasta> ivanm: upper bounds?
05:48:06 <ivanm> fasta: e.g. containers >=0.1 && <=0.2
05:48:11 <Raevel> @hoogle bbytestring
05:48:12 <lambdabot> No results found
05:48:15 <ivanm> well, that should be <0.3
05:48:19 <FunctorSalad> what's the point of excessive upper bounds?
05:48:30 <ivanm> FunctorSalad: well, dcoutts recommends them for the most part
05:48:42 <ivanm> as you don't lie about what your library/app requires for building purposes
05:49:00 <FunctorSalad> but you don't know whether it will work
05:49:04 <ivanm> generally, if the major version is bumped, you'll need to update your code
05:49:12 <benmachine> @pl maybe Nothing
05:49:12 <lambdabot> maybe Nothing
05:49:17 <ivanm> FunctorSalad: right; in this case, it would be nice if the .cabal files could be edited
05:49:20 <dcoutts> FunctorSalad: it's a question of being pessimistic vs optimistic
05:49:28 <ivanm> rather than requiring a version bump
05:50:00 <dcoutts> FunctorSalad: it's much clearer to users when it fails with a version error than failing in a random way
05:50:06 <RayNbow> btw quicksilver, is it common in math notation to overload a predicate p :: a -> Bool with the meaning p' :: Set a -> Set a with p' = filter p?
05:50:40 <FunctorSalad> dcoutts: yes but OTOH it's clearer to the user if it succeeds than if it refuses to build ;)
05:51:06 <FunctorSalad> I've had to edit quite a few .cabals due to bounds
05:51:24 <dcoutts> FunctorSalad: nobody complains to me when it works, they only complain when it fails with weird reasons and ask why cabal didn't protect them.
05:51:41 <FunctorSalad> :)
05:52:04 <ivanm> FunctorSalad: e.g. I've had people complain about my old version of sourcegraph (before I updated it) about it not working with new graphviz
05:52:04 <fasta> Maybe Hackage could also already build with 6.12 RC?
05:52:55 <fasta> And then some field where you can upload a package, such that as output you get a list of packages which are broken with 6.12.
05:54:03 <burp> in a list of lists/or tuples, with each 3 numbers, let's say [[1,2,3],[4,5,6],..] or [(1,2,3), (4,5,6)] I want to find the list/or tuple where the numbers are most equal to each other. how would you do this?
05:54:27 <benmachine> most equal?
05:54:32 <benmachine> what does that mean?
05:54:56 <burp> thats basically what I need, a good definition ;)
05:55:03 <burp> 1,1,1 is best, because all are equal
05:55:12 <burp> 1,1,1.001 is good, 1,1,3 bad
05:55:22 <burp> with two numbers I could check the difference
05:55:31 <benmachine> so you're looking for something like standard deviation?
05:55:37 <burp> with 3 I could check differences between each pair
05:55:39 <benmachine> or mean deviation or any of those things
05:55:46 <quicksilver> RayNbow: I don't think so, no.
05:55:48 <burp> benmachine: hm, good idea
05:56:06 <quicksilver> RayNbow: perhaps A|p (with the p shown in subscript)
05:56:10 <quicksilver> RayNbow: or A/p even
05:56:15 <Baughn> burp: root-mean-square.. is a pretty good description of the algorithm you need.
05:56:16 <burp> benmachine: of course, thanks ;)
05:56:24 <Baughn> Obviously, you can skip the "root" bit
05:56:25 <quicksilver> RayNbow: I was being lazy and hoping you'd guess my meaning ;)
05:56:52 <RayNbow> quicksilver: nevertheless, it was a nice notation and inspired me to copy it ;)
05:57:26 <Raevel> i wrote a patch for the torrent package, but now i noticed that on one of my ubuntu installations the package fails to compile because of some bytestring issues, both machines have the same version of bytestring. the error i get on the one is "Expected Data.Lazy.Internal.ByteString but got ByteString", any ideas?
05:57:27 <RayNbow> (because too many set comprehensions would make pdf less readable :p)
05:57:45 <burp> Baughn: I think standard deviation fits better, because smaller = better
05:58:10 <seanmcl> is there a way to do sections with commas?
05:58:16 <seanmcl> (, 5) for instance
05:58:22 <Baughn> burp: That's the case for RMS too. You start by calculating the mean of the whole thing, and subtract that mean from each value before squaring.
05:58:23 <Raevel> i didn't  manage to get it to compile here even though i converted from bytestring to lazy or vice versa
05:58:24 <benmachine> seanmcl: there is an extension I think
05:58:29 <FunctorSalad> yeah in 6.12 seanmcl
05:58:29 <benmachine> -XTupleSections or something
05:58:38 <seanmcl> benmaching: ooh, great.  Thanks
05:58:51 <Baughn> burp: Of course, that's just /one/ measure, though. There are lots of other ways to calculate variance, and they don't even give the same orderings.. stddev, say... it all depends on exactly what the purpose of this is
05:58:52 <benmachine> err
05:59:03 <benmachine> FunctorSalad might be right
05:59:03 <benmachine> it might not be in 6.10
05:59:19 <seanmcl> wait, is 6.12 out?
05:59:22 <quicksilver> RayNbow: p^{-1}(True) is a fairly standard notation
05:59:25 <quicksilver> RayNbow: but a bit clunkier
05:59:45 <quicksilver> seanmcl: no :)
05:59:49 <quicksilver> seanmcl: there is a release candidate though
05:59:50 <Baughn> burp: Um. Actually. That /is/ standard deviation. RMS would be if you don't do that. Oops?
06:00:00 <Baughn> burp: Oh. Also, there's a hs-stats package on hackage you can use
06:00:07 <seanmcl> benmachine: ok, I'll just have to wait.  thanks
06:00:11 <Baughn> *hstats
06:00:15 <burp> Baughn: yes, that's why I got confused ;)
06:00:50 <quicksilver> Baughn: well, technically the thing you get when you take the average of the square difference from the mean is an *estimate* of std-dev, not std-dev itself.
06:01:06 <quicksilver> Baughn: it's also not an unbiased estimate - you divide by n-1 or n+1 or something to get that.
06:01:08 <burp> ok.. but I don't need the std-dev exactly ;)
06:01:16 <burp> I just need to do the task I described
06:02:27 <kowey> anybody experienced this trying to install the Haskell Platform on Ubuntu? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10713#a10713
06:02:56 <Raevel> hmm, perhaps
06:02:59 <kowey> I've done this on 4 separate machines successfully, and now I've got a user with the same configuration complaining of the problem above...
06:03:24 <burp> just variance will be ok too,
06:03:52 <zygoilid> kowey: maybe install the happy in the ubuntu repos instead? probably won't matter
06:04:16 <Raevel> kowey: i might have had that problem, and i might have solved it by first uninstalling everything ghc-related... maybe :-)
06:04:30 <kowey> zygoilid : hmm, thanks! but the procedure should have worked with the binary from the GHC site
06:04:40 <zygoilid> yeah, it should have. and yet...
06:04:46 <kowey> at least, it did the first four times I tried it, (albeit with a small patch from hackage)
06:06:22 <kowey> ah, the patch in question was http://trac.haskell.org/haskell-platform/ticket/84 which seems unrelatd
06:07:48 <kowey> (and my user claims this is pretty much a fresh Ubuntu install with nothing on it... how odd!)
06:10:18 <Raevel> kowey: have you read http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html ?
06:12:14 <kowey> Raevel : yeah, I've seen it... sigh, I guess I should point my user to that
06:12:40 <kowey> I just did want to have to make the go through the strange step of adding some random PPA to their /etc/apt/sources.list
06:13:38 <OCastro> hey guys
06:13:45 <Raevel> hey OCastro
06:13:47 <kowey> and they really do have GHC 6.10.4 (sorry, I'm not resisting your attempt to help, just being puzzled)
06:14:05 <OCastro> I have an issue with a simple function. I'm just starting with Haskell.
06:14:13 <OCastro> I'm making a replace function.
06:14:17 <Raevel> :-s
06:14:23 <OCastro> http://pastebin.com/d68d7a4bd
06:14:50 <OCastro> LOL
06:14:57 <OCastro> I forgot to put the argumens
06:15:00 <OCastro> :P
06:15:09 <benmachine> whoops
06:15:18 <Raevel> tadaa
06:16:00 <OCastro> there http://pastebin.com/d6e04e2a0
06:16:14 <OCastro> is it okay in your experience?
06:16:25 <OCastro> or it could be improved?
06:16:27 <Baughn> OCastro: Rewrite in terms of a map. ;)
06:16:44 <Raevel> it's okay
06:16:57 <OCastro> map is the function that aplies a function to whatever, right?
06:17:00 <Botje> yeh. i'd write that as a map, but it's fine.
06:17:07 <Baughn> That applies a function to all elements of a list
06:17:12 <quicksilver> OCastro: you can factor "if x == z then (y:substitui x y zs) else (z:substitui x y zs)"
06:17:13 <Baughn> fmap would be the one that applies it to "whatever". :P
06:17:20 <zygoilid> OCastro: you don't need parentheses around the 'then' and 'else' clauses of an 'if.
06:17:21 <benmachine> > map succ [1, 2, 3]
06:17:22 <lambdabot>   [2,3,4]
06:17:34 <quicksilver> OCastro: note that both branches have the common subexpressions (:substitui x y zs)
06:17:35 <Baughn> > succ . [1,2,3]
06:17:36 <lambdabot>   [2,3,4]
06:17:40 <quicksilver> OCastro: so you can write instead
06:17:57 <quicksilver> (if x == z then y else z) : substitui x y zs
06:18:00 <zygoilid> ^^ this will also be lazier
06:18:17 <benmachine> uhh will it
06:18:18 <quicksilver> (and this makes it arguably more obvious that it could be rewritten using map)
06:18:39 <zygoilid> benmachine: yeah. it doesn't need to force the value of the head of the input list to determine the tail of the output list
06:18:43 <OCastro> holy paris hilton
06:18:53 <OCastro> you guys are like super smart
06:18:54 <burp> > minimum >>= elemIndex $ [3,4,2,1,5]
06:18:55 <lambdabot>   Just 3
06:18:57 <burp> anything predefined for that?
06:19:14 <zygoilid> benmachine: consider 'substitui 1 2 [undefined, 1, 3] !! 1'
06:19:17 <quicksilver> I cheerfully claim to be at least as smart as paris hilton is holy :P
06:19:32 <bastl> can haskell-src-extras parse Pragmas ?
06:19:32 <zygoilid> type error!
06:19:39 <benmachine> zygoilid: why's it need to force the value of the list?
06:19:55 <zygoilid> benmachine: in order to determine whether it's in the 'then' or 'else' branch
06:20:08 <benmachine> oh, good point
06:20:12 <FunctorSalad> quicksilver: she isn't?:o
06:20:28 <FunctorSalad> so what I've been told was wrong
06:21:01 <burp> fromJust $ minimum >>= elemIndex, I think this can't make problems
06:21:34 <quicksilver> zygoilid: a good example of how _|_ destroys naive equational reasoning
06:21:54 <quicksilver> maybe 'destroys' is too strong
06:21:55 <Baughn> > (\x y l -> (\z -> if (z == x) then y else z) . l) 1 2 [4,3,2,1]
06:21:56 <lambdabot>   [4,3,2,2]
06:22:02 <quicksilver> it's still valid up to definedness concerns.
06:22:04 <quicksilver> "impairs"
06:22:24 <PeakerWork> f x = 1 + f x   -- 0 = 1
06:22:31 <PeakerWork> (equational reasoning)
06:22:37 <Baughn> Cale: I don't care what you say, (.) = fmap just doesn't look right. :/
06:22:56 <zygoilid> PeakerWork: you assume 0 is in the range of f :)
06:23:42 <FunctorSalad> > map (+1) [undefined,2,3] !! 1
06:23:43 <lambdabot>   3
06:24:06 <FunctorSalad> how is the other thing lazier?
06:24:16 <zygoilid> FunctorSalad: that's the lazier one
06:25:00 <FunctorSalad> zygoilid: than this? "<quicksilver> (if x == z then y else z) : substitui x y zs"
06:25:14 <FunctorSalad> (can't be :o)
06:25:14 <zygoilid> FunctorSalad: no, OCastro's paste
06:25:18 <FunctorSalad> ahhh
06:25:53 <voker57_> @hoogle Map a b -> [a]
06:25:53 <lambdabot> Data.Map keys :: Map k a -> [k]
06:25:53 <lambdabot> Data.Graph.Inductive.Query.DFS topsort' :: Graph gr => gr a b -> [a]
06:25:53 <lambdabot> Data.Map elems :: Map k a -> [a]
06:26:23 <zygoilid> > let go [] = []; go (x:xs) = if x <= 0 then 0:go xs else x-1:go xs  in  go [error "Too strict!",1,2,3] !! 1
06:26:24 <lambdabot>   * Exception: Too strict!
06:26:36 <zygoilid> > let go [] = []; go (x:xs) = (if x <= 0 then 0 else x-1):go xs  in  go [error "Too strict!",1,2,3] !! 1
06:26:37 <lambdabot>   0
06:28:33 <benmachine> compiling ghc warms my hands.
06:29:43 <zygoilid> you compile ghc over an open fire?
06:31:23 <FunctorSalad> laptop
06:31:50 <Baughn> So, /on/ an open fire
06:32:33 <kowey> Raeval: phew! I think my user just failed to apply the #84 patch -- I told him to just delete his haskell-platform src dir, untar and start over
06:32:47 <kowey> mystery left unsolved, but who cares!
06:37:57 <yakov> hey
06:39:42 <yakov> I need to read XML from the socket network connection, do you know if there's anything that can help? I've took a look at various existing parsers on hackage and could not image how to combine them out of the box to read only needed portion of (IO, in fact) input
06:40:18 <yakov> e.g., erlsom for Erlang has parse_sax which takes continuation function to get more input if needed
06:41:15 <yakov> do we have something simillar? I know that it is not hard to handle common case, but I do not want to reinvent the wheel
06:45:14 <Baughn> yakov: What's the exact scenario you want to support?
06:46:27 <quicksilver> I don't think there is a good library for robust partial parsing
06:46:36 <quicksilver> at least not the 'robust' part.
06:46:47 <Baughn> Well, that's what laziness (should be) for..
06:46:50 <yakov> open socket connection, read XML till this XML is well-formed, then return resulting xml to be analysed by HXT etc.
06:46:52 <quicksilver> I think the development versions of haxml have experiment lazy XML parsing.
06:47:08 <quicksilver> yakov: I don't believe that exists.
06:47:14 <Baughn> yakov: Ah. I assume you don't control both sides of the connection?
06:47:19 <yakov> i'm using quickly hacked XML reader at the moment..
06:47:19 <quicksilver> Baughn: laziness is a terrible solution if you need to handle errors.
06:47:35 <quicksilver> Baughn: it's OK if you have an inviolable promise of well-formedness
06:47:46 <quicksilver> (like for example, having a grammar which accepts everything)
06:47:48 <yakov> Baughn, no, i don't have control, but exception would be sufficient to handle errors
06:47:48 <Baughn> quicksilver: Or if the only way to "handle" errors is to discard the whole message
06:48:07 <yakov> yup, i don't have such promise :-(
06:48:24 <Baughn> yakov: So, what /would/ you do if you encounter an error?
06:48:24 <yakov> and there is not only well-formed XMLs in my input stream
06:48:42 <yakov> simply catch and drop/reconnect will be ok
06:48:57 <yakov> but this is just for the starters..
06:49:08 <Baughn> Problem. If your XML is not guaranteed to be well-formed, and there may be multiple XML messages in your stream..
06:49:13 <yakov> it's not suitable for real world situations which i must handle
06:49:18 <Baughn> There's a risk one of the messages will not be terminated
06:49:38 <Baughn> yakov: With that level of possible brokenness, it may be that tagsoup is your friend
06:49:41 <yakov> Baughn, xml messages are serialized
06:49:56 <yakov> Baughn, yeah, I though about tagsoup.. but..
06:50:31 <Baughn> yakov: Oh, so the boundaries between the xml messages are reliable?
06:51:08 <yakov> well, it might be so, but it also might be that we have broken chunks followed by well-formed XMLs (after other side did resend)
06:51:15 <yakov> so there are troubles
06:52:04 <yakov> I do can ask to resend XML to me though
06:52:05 <Baughn> I would very much prefer to write the transport layer so broken messages can't happen, short of broken software. Oh well..
06:52:28 <yakov> yeah, I agree such level of abstraction is definitely needed.
06:52:53 <Esmil> Hi. I have a string "a,b,c" and I'd like to split it into ["a","b","c"]. I imagine there is a standard function Eq a => a -> [a] -> [[a]] for that, I just can't find it..
06:52:59 <Baughn> Of course, it can never be /guaranteed/, but if you get it to the point where you can drop a connection entirely if you see an error, that helps.
06:53:05 <quicksilver> Baughn: you still have to worry about hacked clients, clients written by someone else, broken routing hardware
06:53:15 <quicksilver> Baughn: deliberate man-in-the-middle attacks
06:53:17 <quicksilver> and so on.
06:53:32 <quicksilver> generally you should assume that a network socket might have *anything* on it.
06:53:48 <Baughn> quicksilver: Sure
06:53:54 <yakov> yeah, the ideal solution would be error-recovering parser
06:54:22 <Baughn> Ideal solution would be error-passing parser that just causes the entire connection to fail if it sees one. That requires errors to be sufficiently rare.
06:54:27 <yakov> which uses some fun to get exactly needed amount of input to continue
06:54:30 <Baughn> Oh, and..
06:54:33 <yakov> to leave stream in well-defined state
06:54:38 <Baughn> yakov: How large are the individual messages?
06:54:41 <yakov> after each operation of "parse"
06:54:51 <yakov> Baughn, small ~100..500 bytes
06:55:14 <yakov> i would not consider XML to work with large binary data ;-)
06:55:25 <Baughn> yakov: So, a strict parser would be fine. To separate the messages from each other, you don't need a full XML parser; simple tag-counting will do.
06:55:46 <yakov> Baughn, droping connection is not quite good, it's better to RE-issue the request
06:56:14 <Baughn> yakov: It's simpler, which is good. It reduces reliability, which is bad; however, a complex parser also reduces reliability.
06:56:30 <Baughn> yakov: By and large, it's easier to make the connection reliable enough that you don't need to deal with broken messages in the common case.
06:57:00 <quicksilver> Baughn: (don't forget to handle CDATA :P)
06:57:40 <Baughn> quicksilver: ..lazy implementation FTW. ;_;
06:57:51 <yakov> :-)
07:00:15 <Baughn> yakov: What's the actual protocol you're implementing?
07:00:51 <trzkril> @pl \(a, b) x -> if x == a then b else if x == b then a else x
07:00:52 <lambdabot> uncurry (ap (ap . (ap .) . flip . (if' .) . (==)) (flip flip id . (ap .) . flip (flip . (if' .) . (==))))
07:04:40 <trzkril> is there no easy way to create a permutation on a type a using a list of pairs?
07:09:19 <zygoilid> trzkril: what do you mean?
07:09:28 <jfoutz> should i try to crash dons talk today? i've never seen him speak.
07:10:12 <byorgey> jfoutz: yes, you should.
07:10:47 <jfoutz> hrm. what's the worst that could happen?
07:10:56 <jfoutz> hmm. ok. i'll go for it.
07:11:01 <Baughn> Hum. skynet went from 16.2MB to 320kB on 6.12...
07:12:43 <trzkril> zygoilid: something like "foldr (\(a,b) f x -> if a == x then b else if b == x then a else f x) id"
07:12:56 <trzkril> @type foldr (\(a,b) f x -> if a == x then b else if b == x then a else f x) id
07:12:57 <lambdabot> forall t. (Eq t) => [(t, t)] -> t -> t
07:13:04 <yakov> Baughn, request-answer protocol of simple xml queries
07:13:15 <yakov> our in-house protocol
07:13:34 <_Ray_> This may just be stupid - I'm trying to compare an integer x against the length of a list, however length returns an Int and x is an Integer. Without changing my type signatures (which want Integers), how could I do this comparison? fromInteger?
07:14:02 <Baughn> yakov: To be honest, it seems /very/ odd that you can sometimes get partial messages without the tcp connection breaking. Are you sure that actually happens?
07:14:33 <trzkril> @type toInteger . length
07:14:34 <lambdabot> forall a. [a] -> Integer
07:14:48 <trzkril> @type genericLength
07:14:49 <lambdabot> forall b i. (Num i) => [b] -> i
07:14:54 <yakov> yeah, this case tells that other side has a bug in software ;-)
07:15:27 <trzkril> @pl foldr (\(a,b) f x -> if a == x then b else if b == x then a else f x) id
07:15:27 <lambdabot> foldr (uncurry (ap (ap . (((.) . ap) .) . flip . (if' .) . (==)) ((ap .) . flip (flip . (if' .) . (==))))) id
07:15:36 <yakov> it's a piece of old software with many "hacks" so there are potentially lots of places where something can go seriously wrong. not Haskell. C++
07:15:46 <Baughn> yakov: Oh dear.
07:15:48 <_Ray_> Thanks :)
07:15:59 <yakov> anyway it does have places which "reset" it's internal state :-(
07:16:10 <Baughn> yakov: For comparison, I'm using Data.Binary, with derived instances. Nothing going to go wrong /there/, nope. :3
07:16:29 <Baughn> yakov: ..well, have "fun".
07:16:33 <yakov> :-)
07:16:50 <Baughn> yakov: ..and pray that the top-level message element can't also occur in a nested context.
07:17:32 <Baughn> @let dup x = (x,x)
07:17:33 <lambdabot>  Defined.
07:17:43 <Baughn> > dup . dup . dup . dup . dup . dup . dup . dup . dup
07:17:45 <lambdabot>   ()->
07:17:45 <lambdabot>    ((((((((((),()),((),())),(((),()),((),()))),((((),()),((),())),((()...
07:17:50 <yakov> but working with such systems has positive side. it's rather intersting task to build such a reliable parser ;-) in haskell :-)
07:20:20 <Baughn> yakov: You're right. Still, I'd rather write useful code..
07:20:24 <quicksilver> Baughn: a nice system with the general utility of deriving Binary but including automatic versioning and sensible error messages would be nice.
07:20:33 <Axman6> :t dup
07:20:34 <lambdabot> forall t. t -> (t, t)
07:20:53 <Baughn> yakov: Are you (the company) planning to eventually retire the C++ programs?
07:20:55 <Axman6> > dup . dup . dup . dup . dup . dup . dup . dup . dup $ 1
07:20:56 <lambdabot>   (((((((((1,1),(1,1)),((1,1),(1,1))),(((1,1),(1,1)),((1,1),(1,1)))),((((1,1)...
07:21:58 <yakov> Baughn, yeah, i'm gradually moving toward complete removal of c++ code in favour of C+haskell
07:22:14 <Baughn> @type dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup . dup
07:22:17 <yakov> with recent progress of GHC runtime for linux kernel seems like I will be able to even code out drivers in haskell ;-)
07:22:28 <Baughn> yakov: Aheh. I wouldn't want to try that.
07:22:30 <lambdabot> thread killed
07:22:32 <yakov> this will be really cool because we have sofisticated driver at the moment :-)
07:22:57 <Baughn> yakov: It sounds good in theory, but GC pauses are an issue, and house only works with a rather old version of GHC, too
07:23:02 <Baughn> ..mostly, the GC pauses are an issue
07:23:22 <Baughn> yakov: If you can add an incremental GC to GHC, everyone would applaud. :)
07:23:35 <yakov> yeah, I hope to see region inference or some other technique
07:24:02 <yakov> GHC already has incremental GC, does not it?!
07:24:39 <Baughn> No
07:25:26 <quicksilver> drivers should probably use bounded memory anyway
07:25:29 <Baughn> However, there's one nursery per CPU core (..well, numCapabilities), and the GC can run independently of other threads
07:25:53 <Baughn> In theory, I suppose any haskell threads running on that capability could also migrate to another one while the GC is running
07:25:53 <quicksilver> the current GC cannot run independently as far as I know, Baughn
07:25:57 <gwern> yakov: are you sure you want region inference? from the retrospective I saw regions+gc was worse than either
07:26:27 <Baughn> quicksilver: Oh? I'm pretty sure I heard that was one of the reasons they were independent in the first place
07:26:28 <yakov> personally, i believe in generation of C code from Haskell to be run on such a trimmed environment..
07:26:46 <yakov> gwern, GC is not affordable in DSP environment ;-)
07:27:27 <yakov> (at best)
07:27:55 <gwern> yakov: but then you'd want just regions
07:28:44 <yakov> yes. i meant that, actually
07:31:27 <yakov> nonetheless DSP systems tends to become more complex and so it's allowed to use more hardware which in turn gives hope to even run GC-ed languages
07:31:32 <yakov> IMO
07:31:45 <yakov> e.g. cheap SMP arrays of Analog Digital DSP processors
07:33:18 <yakov> it's hard to program such system but time-to-market factor can somehow permit to use more high-level technique to solve the problem.
07:39:17 <zygoilid> trzkril: i think you want something like 'lookup'
07:39:25 <trzkril> zygoilid: yes
07:39:39 <FunctorSalad> what is a region?
07:40:07 <trzkril> zygoilid: currently working on that, the reflixivity can be done by preprocessing the list
07:40:30 <zygoilid> @type \xs -> map (\x -> fromMaybe x $ lookup x (xs ++ map (\(a,b)->(b,a)) xs))
07:40:31 <lambdabot> forall a. (Eq a) => [(a, a)] -> [a] -> [a]
07:40:59 <zygoilid> @type snd &&& fst <$> ?xs
07:41:00 <lambdabot> forall a c a1 b. (?xs::(a, c) -> (a1, b)) => (a, c) -> (c, a1)
07:41:09 <zygoilid> @type (snd &&& fst) <$> ?xs
07:41:10 <lambdabot> forall a b (f :: * -> *). (?xs::f (a, b), Functor f) => f (b, a)
07:41:42 <zygoilid> trzkril: if there are duplicates in the list, that's not quite the same, though
07:42:22 <FunctorSalad> @typ runKleisli (Kleisli snd &&& Kleisli fst)
07:42:23 <lambdabot> forall (m :: * -> *) c c'. (Monad m) => (m c', m c) -> m (c, c')
07:43:12 <zygoilid> turns out einstein was wrong. (mc)^2 == m(c^2)
07:43:23 <FunctorSalad> heh
07:43:35 <FunctorSalad> well (<=)
08:38:19 <Esmil> Hi. I have a string "a,b,c" and I'd like to split it into ["a","b","c"]. I imagine there is a standard function Eq a => a -> [a] -> [[a]] for that, I just can't find it.. Do anyone have a clever way of doing that?
08:38:54 <NEEDMOAR> @hoogle a -> [a] -> [[a]]
08:38:55 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
08:38:55 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
08:38:55 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
08:39:07 <quicksilver> Esmil: there isn't.
08:39:29 <Esmil> Aw.. hoogle is clever though.
08:39:37 <quicksilver> although, see http://hackage.haskell.org/package/split-0.1.1
08:42:56 <burp> @hoogle ([a], [b]) -> [(a,b)]
08:42:57 <lambdabot> No results found
08:43:02 <burp> :(
08:43:20 <trzkril> @type zip
08:43:21 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
08:43:28 <burp> oh yes ;)
08:43:37 <trzkril> @type uncurry zip
08:43:38 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
08:43:41 <burp> :D
08:54:44 <xle> Hey all, I'm having some trouble using Network.Pcap on OS X. It is giving me an error: ghc: unable to load package `pcap-0.4.3'. I am guessing that it has to do with ghc not finding the underlying libpcap library. libpcacp is installed via port, however... Any ideas?
08:55:34 <jmcarthur_work> woah i didn't even realize we had a pcap binding
08:55:47 <jmcarthur_work> i was thinking it would be nice to make one, but i guess i don't have to!
08:56:03 <jmcarthur_work> been around for a while even, it seems
08:56:06 <jmcarthur_work> i must just be blind
08:56:10 <jfoutz>                         guess i don't have to!
08:56:17 <xle> yeah! i was pleasantly surprised too!
08:56:21 <jfoutz> grr. mispaste. sorry.
08:56:33 <jmcarthur_work> heh
08:57:16 <zygoilid> Esmil: you might be interested in the Data.List.Split module in the split package on hackage.
08:57:28 * zygoilid notes quicksilver has already mentioned that
08:59:46 <xle> so any ideas how I can get ghc to see the right libpcap library?
08:59:58 <xle> i havent worked much with FFIs up to this point, to be honest
09:02:58 <dottedmag> xle: my first idea would be to run ghc under strace (or analog for OS X) and see where does it look at libraries.
09:02:58 <dottedmag> *for libraries
09:03:39 <Twey> jfoutz: You have a tiny terminal.  :þ
09:04:03 <xle> dottedmag: thanks I'll take a look at that
09:04:37 <dottedmag> xle: ktrace or DTrace on OS X, as Wikipedia suggests
09:05:00 <jfoutz> Twey: no, i have a dumb mac terminal, i dragged my fingers on the trackpad it interpreted that as a copy this line, i took my fingers off the pad, which it interpreted as a drop.
09:05:05 * jfoutz sighs
09:05:15 <Twey> Heh.
09:05:40 <jfoutz> xle: export LD_LIBRARY_PATH=/opt/whatever maybe?
09:05:42 <Esmil> zygoilid: Thanks though. Actually I should be able to write that function myself. What annoys me a bit is that I have absolutely no idea what would be an efficient way to do it in haskell. Do you get that once you're a more experience haskell hacker?
09:06:23 <Twey> Yes.  It's not that complicated.
09:06:40 <Twey> You can do it with a fold.
09:06:59 <Twey> Data.List.Split shows off and does all sorts of clever stuff, though.  ☺
09:08:21 <zygoilid> Esmil: my first approach is usually to use pre-existing combinators before i consider writing a fold, and to consider folding before i consider recursion
09:08:34 <jfoutz> Twey: i'm always surprised that Data.List has words and lines, but not wordsBy or something like that.
09:08:37 <zygoilid> Esmil: this sometimes results in slightly silly ideas, such as:
09:08:39 <Twey> Indeed.
09:08:57 <Twey> Data.List.Split should be in the standard libraries, if you ask me.
09:09:35 <zygoilid> > let swap ',' = ' '; swap ' ' = ','; swap a = a  in  (map.map) swap . words . map swap $ "hello world,foo bar,1,2,3"
09:09:36 <lambdabot>   ["hello world","foo bar","1","2","3"]
09:10:34 <Twey> Heh.
09:10:47 <Esmil> zygoilid: Heh, yeah. I know there is lots of ways to do stuff like that. What I'm getting at is that I have no intuition as to which approach is more efficient
09:10:50 <Twey> Interesting approach, but hardly performant.  :þ
09:11:23 <zygoilid> Twey: if the maps and words get inlined, i'm not sure it's terrible ;-)
09:11:40 <Twey> Well, true that.
09:12:25 <NEEDMOAR> @src words
09:12:25 <lambdabot> words s = case dropWhile isSpace s of
09:12:25 <lambdabot>     "" -> []
09:12:25 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:12:48 <Twey> NEEDMOAR: That only works for single characters, though.
09:12:53 <Twey> zygoilid, yours too.
09:13:08 <Twey> It gets more complicated when you consider multiple-character separators as Data.List.Split does.
09:13:10 <zygoilid> Twey: that's true, of course, but it's also all that Esmil asked for ;-)
09:13:39 <Twey> Oh, truly.  ☺
09:13:46 <Esmil> NEEDMOAR: Ahh yes. Looking at the source of the standard libraries is of course a good guide, thanks
09:13:50 <zygoilid> once you get to multiple characters, you enter the more-interesting-than-you-might-have-expected world of substring searching
09:13:58 <Twey> Heh.
09:15:23 <zygoilid> do you have a special-case algorithm if the separator's characters are all distinct? do you use Boyer-Moore? Rabin-Karp? it's all good fun :)
09:15:53 <Twey> I was just going to fold through it prepending to a list of strings.
09:15:59 <Twey> But if you want to get *fancy*, sure.  :þ
09:17:07 <zygoilid> > foldr (\x (xs:xss) -> if x == ',' then []:xs:xss else (x:xs):xss) [[]] "hello world,foo bar,1,2,3"
09:17:08 <lambdabot>   ["hello world","foo bar","1","2","3"]
09:17:32 <zygoilid> Twey: ^^ i guess that's simple enough
09:17:54 <Twey> I thought we were doing multi-char.
09:18:15 <zygoilid> that /almost/ works for multi-char ;-)
09:18:38 <hackagebot> hunit-gui 0.1.2 - A GUI testrunner for HUnit (KimWallmark)
09:18:43 <Twey> But reversal is crucial for performance
09:18:55 <Twey> Back in a bit
09:19:42 <zygoilid> > foldr (\x (xs:xss) -> if "%," `isPrefixOf` (x:xs) then []:tail xs:xss else (x:xs):xss) [[]] "hello world%,f%oo, b%ar%,1%,%,2%,3"
09:19:43 <lambdabot>   ["hello world","f%oo, b%ar","1","","2","3"]
09:27:33 <Taejo> @pl sliding_window x ys = map (take x) (tails ys)
09:27:34 <lambdabot> sliding_window = (. tails) . map . take
09:42:28 <sw17ch> hi all. I made something to fake newtype'ing in C. I'm hoping for some comments on it. Any one have any? Link --> http://gist.github.com/209588
09:48:47 <jmcarthur_work> sw17ch, that looks pretty close to how i do it
09:49:15 <sw17ch> jmcarthur_work, i was thinking some one else had to be doing something similar :)
09:49:33 <jmcarthur_work> yeah, typedefs just don't cut it for me
09:50:07 <sw17ch> that's what i was thinking
09:51:09 <jmcarthur_work> i've been thinking about trying a similar pattern for ADTs
09:51:29 <jmcarthur_work> i've done tagged unions manually a few times
09:51:35 <jmcarthur_work> never made any macros
09:52:42 <jmcarthur_work> it would be tougher
09:58:43 <patch-tag> why does replicateM (10^6) $ return 0 produce output in the IO monad, but stack overflow in Maybe?
09:58:52 <patch-tag> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10718#a10718
10:03:07 <jfoutz> well, my guess would be the evaluation order is different.
10:04:25 <jfoutz> io is probably introducing some strictness that maybe isn't, so you've built up a huge list of thunks.
10:04:39 <sinelaw> can/does ghc do automatic parallelization of independent parts of program?
10:07:01 <jfoutz> not like you mean.
10:07:26 <jfoutz> it'll run rts overhead in a separate thread (i think) but not your program
10:07:42 <jmcarthur_work> sinelaw, you must give it annotations and such
10:08:00 <jmcarthur_work> sinelaw, it's easier than in most languages, but it is not beneficial to do it everywhere due to overhead
10:08:47 <jmcarthur_work> sinelaw, and it's harder to automagically determine where it is beneficial to parallelize even pure code than people used to think simply because it's possible to do it too fine-grained
10:09:15 <jmcarthur_work> s/ simply because it's possible to do it too fine-grained//
10:09:40 <Jafet> JIT!
10:09:52 <jmcarthur_work> yeah JIT would be a nice way to do it
10:09:56 <jmcarthur_work> but GHC doesn't JIT
10:10:07 <sinelaw> why will JITting help?
10:10:12 <jmcarthur_work> runtime profiling
10:10:18 <Jafet> JIT would be quite nice for Haskell, because everything is pure
10:10:23 <jmcarthur_work> help determine good points to parallelize
10:11:23 <sinelaw> like finding a "median point" in the graph?
10:11:29 <sinelaw> in terms of computational load
10:11:43 <Berengal> Jafet, because everything's pure, you could just as well optimize at compile-time. If you want to base optimizations on profiling, you could do that by inserting pragmas based on a real profile
10:11:50 <jmcarthur_work> something like that
10:12:16 <Jafet> Berengal, that's very nice, except as jmcarthur said, automatically optimizing at compile-time is a shot business
10:12:31 <Jafet> You can't.
10:12:36 <jmcarthur_work> Berengal, yeah. iirc gcc has the ability to optimize based on data from a profiling test run
10:12:46 <jmcarthur_work> Jafet, no it's not
10:12:50 <Berengal> Jafet, if you've got the same information, you can do the same optimizations
10:13:01 <Jafet> You don't get the same information.
10:13:07 <Berengal> The only trouble is, you don't have that information at compile-time most of the time
10:13:18 <jmcarthur_work> the fact that haskell is pure means we can even do the profiling step during compilation (for synthetic workloads, though)
10:13:20 <Berengal> If you could plug in a profiling result, you would
10:13:23 <Jafet> There is optimizing a compiled program, and optimizing a running program, and they are different things
10:13:42 <jmcarthur_work> Jafet, and optimizing a previously run program
10:13:56 <Jafet> Well, a profile run may not be representative
10:14:01 <benmachine> if you were doing JIT would you be able to recalibrate the optimisation to account for changes in circumstance?
10:14:05 <benmachine> that might be useful
10:14:17 <jmcarthur_work> benmachine, yes, that is a benefit
10:14:25 <jmcarthur_work> one which static optimizations can't compete with
10:15:03 <Berengal> Unless you give it a bunch of profiles, and it optimizes for each of them, and they cover the range of possible executions... Highly unlikely
10:15:39 <benmachine> depends on how predictable things are
10:15:53 <benmachine> if everything your program does is always the same, optimisations are going to be obvious
10:16:05 <Berengal> True, and in my experience, most things are highly predictable...
10:22:46 <sinelaw> Berengal, the programmer can predict them, because he knows what sort of inputs are gonna be
10:23:01 <sinelaw> but the compiler can't really do that automatically, i guess
10:23:48 <jfoutz> how does the programmer know that?
10:23:54 <benmachine> unless it has access to a profile
10:24:03 <Jafet> Because he's translating a program from COBOL.
10:24:05 <jfoutz> and couldn't the programmer write that down in a way a compiler could understand?
10:24:07 <Berengal> sinelaw, that's where static typing kicks in. Makes it much easier for the programmer to tell the compiler what the data is and the invariants
10:24:30 <benmachine> jfoutz: yeah we can already do annotations
10:24:45 <benmachine> but we're thinking about ways the compiler could work it out
10:26:28 <jfoutz> i guess the point i'm trying to make is, the programmer has some information he's keeping secret from the compiler. the compiler would need whatever the programmer has... since the programmer dosn't want to tell, you have to figure out how the programmer got that information.
10:26:36 <jfoutz> and that's really your only option.
10:27:08 <hackagebot> ChristmasTree 0.1.1 - Changing Haskell's Read Implementation Such That by Mainpulating Abstract Syntax Trees it Reads Expressions Efficiently (MarcosViera)
10:27:29 <mauke> haha
10:28:03 <jmcarthur_work> ha
10:28:04 <Jafet> Sometimes the programmer doesn't have the information
10:29:48 <jfoutz> right... but there are ways of figuring that out. going and looking at real world usage, adding instrumentation yadda yadda yadda.
10:31:21 <jfoutz> if the programmer knew X he would do optX(program), not very different form the compiler knowing X so optX(program)
10:31:22 <jmcarthur_work> which is a need that a JIT can largely alleviate
10:31:24 * jfoutz sighs
10:32:57 <Jafet> If you were a really clever compiler, you could compile in JIT-like code
10:33:36 <jmcarthur_work> in the sense that the code is self-optimizing?
10:33:55 <Jafet> Adaptive caching, strange stuff that won't run on a Harvard architecture, etc etc
10:34:05 <jmcarthur_work> ah
10:34:11 <Jafet> Well, yes
10:34:38 <Jafet> And of course, adaptive multithreading
10:36:18 * Berengal ponders writing a compiler to self-modifying machine code. I mean, how hard could it be?
10:36:29 <Nolrai_ForestGro> I have a queston: Do oppertors have to take arguments?
10:36:43 <Nolrai_ForestGro> at berengal: lol
10:36:59 <Berengal> > let (+) = 5 in (+)
10:37:00 <lambdabot>   5
10:37:02 <Jafet> You could use thunks, and store all the self-modifying parameters in the data segment, or however it goes
10:37:19 <Nolrai_ForestGro> Cool, thanks!
10:37:51 <Berengal> Nolrai_ForestGro, I don't think you can use then infix though. You'll have to put them in parenthesis, which turns them into regular names
10:37:58 <Berengal> (i.e. functions or values)
10:38:13 <Jafet> > let (+) = 5 in +
10:38:14 <lambdabot>   <no location info>: parse error on input `+'
10:38:35 <Berengal> > let (+) = 5 in negate +
10:38:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:38:42 <Jafet> Looks like syntax error
10:38:52 <jfoutz> > let (:) a b c = a + b + c in 1 : 2 3
10:38:53 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 3
10:38:58 <Berengal> Infix operators are always assumed to take two arguments
10:39:27 <Berengal> Anything else is a syntax error...
10:39:29 <monochrom> Yeah, such as:
10:39:38 <monochrom> > (.) id id 5
10:39:39 <lambdabot>   5
10:40:03 <Berengal> It's quite legal to write an operator that returns a function taking more arguments though
10:40:10 <monochrom> hehe
10:40:47 <Nolrai_ForestGro> Berengal: thats fine, I just want to be able to define say (==>) as a parser that parsers "==>", makes the code easer to read.
10:41:08 <Jafet> > let (+) = \w x y z -> 42 in (+) 1 2 3 4
10:41:09 <lambdabot>   42
10:41:10 * monochrom giggles
10:41:10 <jfoutz> > let (:) a b c = a + (\ b c -> b + c) in 1 : 2 3
10:41:12 <lambdabot>   Constructor `:' should have 2 arguments, but has been given 3
10:41:15 <Jafet> Sneaky
10:41:44 <benmachine> : is syntax I think
10:41:49 <jfoutz> ah.
10:41:50 <benmachine> rather than a function
10:41:51 <Berengal> : is an operator
10:41:54 <Berengal> Not syntax
10:42:01 <Berengal> But : is also a constructor
10:42:03 <burp> @let (+) = const
10:42:03 <lambdabot>  Defined.
10:42:12 <benmachine> > 4 + 8
10:42:13 <lambdabot>   Ambiguous occurrence `+'
10:42:13 <lambdabot>  It could refer to either `L.+', defined at <local...
10:42:14 <mauke> @define
10:42:17 <burp> damn ;)
10:42:18 <Berengal> You can't give functions constructor names
10:42:19 <benmachine> aww
10:42:21 <jfoutz> > let (*) a b c = a + (\ b c -> b + c) in 1 * 2 3
10:42:22 <lambdabot>   No instance for (GHC.Num.Num (t1 -> t))
10:42:22 <lambdabot>    arising from the literal `2' at ...
10:42:31 <jfoutz> ah, much better.
10:42:38 <mauke> > let (*) a b c = a + (\ b c -> b + c) in (1 * 2) 3
10:42:39 <lambdabot>   No instance for (GHC.Num.Num (a -> a -> a))
10:42:40 <lambdabot>    arising from a use of `*' at...
10:42:48 <mauke> oh yes, of course
10:43:08 <mauke> > let (*) a b c = a + b + c in (1 * 2) 3
10:43:09 <burp> > let (+) = (const) in 1 + 2
10:43:09 <lambdabot>   6
10:43:10 <lambdabot>   1
10:43:17 <monochrom> > 5 * negate 6
10:43:18 <lambdabot>   -30
10:43:50 <monochrom> > let {a=5; b=negate; c=6} in a * b c
10:43:50 <lambdabot>   -30
10:44:16 <Jafet> Names, names.
10:44:41 <Berengal> Names are important. They're what gives us power
10:45:20 <Jafet> I gain power through breakfast cereals
10:45:24 <Rotaerk_> only if you know someone's True Name
10:45:27 <Berengal> And lambdas lets us name things. Long live LC!
10:45:57 <Berengal> LC is actually a quite nice programming language...
10:46:28 <zygoilid> > (\(+) -> 1 + 2) const
10:46:29 <lambdabot>   1
10:46:31 <zygoilid> huh
10:46:42 <zygoilid> i did not know you could do that :)
10:46:45 <Jafet> That depends on which lambda calculus is being discussed
10:46:51 <Berengal> Short definition, infinite power, and given simple text macros, easy to program in even
10:46:59 <monochrom> It's the same as (\f -> f 1 2) const
10:47:41 <Berengal> The value-level term language part of haskell is basically LC with ADTs
10:47:44 <zygoilid> in retrospect it's obvious it's legal; you can do the same sort of thing in pattern bindings, so...
10:47:51 <monochrom> Shorter names represent more power. Infinite power when name has length 0.
10:48:16 <Berengal> monochrom, main = wu?
10:48:28 <Jafet> Does that mean Arc will be based on combinators?
10:48:38 <monochrom> "main" has length 4, "wu" has length 2.
10:48:51 <monochrom> Infinite power when you just write nothing.
10:49:44 <Berengal> ⁠
10:49:57 <Rotaerk_> that's... over 9000!
10:50:40 <Zao> Rotaerk_: I see you're damaged by sustained IRC usage.
10:51:01 <Rotaerk_> it's true :(
10:51:17 <hackagebot> ChristmasTree 0.1.2 - Changing Haskell's Read Implementation Such That by Mainpulating Abstract Syntax Trees it Reads Expressions Efficiently (MarcosViera)
10:51:50 <Berengal> Ooo, unicode has a "FUNCTION APPLICATION" symbol
10:52:34 <monochrom> Heh, I like it.
10:52:46 * sw17ch wants a unicode keyboard
10:53:02 <Berengal> > ord '⁡'
10:53:03 <lambdabot>   <no location info>:
10:53:03 <lambdabot>      lexical error in string/character literal at chara...
10:53:20 <Berengal> :/
10:53:26 <mauke> ⁡
10:53:29 <mauke> U+2061 (e2 81 a1): FUNCTION APPLICATION [⁡]
10:53:37 <Berengal> > text [chr 0x2061]
10:53:38 <lambdabot>   ⁡
10:53:57 <monochrom> multi-touch, with-lcd-screen "keyboards" are now being worked out. it means the "keys" are programmable unlimitedly
10:54:23 <Berengal> Not looking forward to programming them... but I'll definitely get one
10:54:45 <benmachine> but they've got to click
10:54:49 <benmachine> press down
10:54:54 <Berengal> Yes, they need buttons
10:54:56 <benmachine> otherwise you don't get feedback
10:55:00 <monochrom> that's the hard part.
10:55:00 <jfoutz> like an optimus keyboard?
10:55:08 <monochrom> I personally couldn't care less.
10:55:09 <Jafet> They can glow eerily
10:55:14 <sproingie> the function application character seems to treated as composing for me
10:55:17 <benmachine> I was actually thinking like a normal keyboard
10:55:17 <Jafet> 21st century feedback
10:55:39 <Jafet> Or make a clicking noise using built-in speakers
10:55:41 <sproingie> it's drawing a box around the previous char
10:56:04 <monochrom> glow as feedback may be not very useful if people don't look when typing. I suggest electrical shock instead.
10:56:12 <Berengal> Still haven't found a better keyboard than the model-M and friends
10:56:47 <zygoilid> > text [chr 70, chr 0x2061, chr 88]
10:56:48 <lambdabot>   F⁡X
10:56:48 <monochrom> Yes, this discourages peoeple from typing, therefore discourages people from writing pointless blogs, stupid youtube comments, and clueless reddit posts!
10:57:40 <Berengal> monochrom, and we developers can demand higher wages for putting up with it, I suppose
10:58:03 <benmachine> I suggest a material which can deform with high precision in controllable ways
10:58:12 <monochrom> I thought developers would buy the more expensive tactile keyboards.
10:58:14 <lament> the best keyboard i've found so far is microsoft comfort curve
10:58:18 <zygoilid> you'll be able to identify the engineers from quite a way away -- they'll be the ones wearing rubber gloves
10:58:19 <Berengal> I'm still holding out for a brain-interface...
10:58:33 <benmachine> (probably not as hard as it sounds)
10:58:41 <Nafai> 11:54 < benmachine> otherwise you don't get feedback
10:58:51 <Berengal> My fingers aren't cutting it as an interface anymore
10:59:00 <zygoilid> benmachine: you want viruses to be able to warp your keyboard into the shape of Rick Astley?
10:59:26 <lament> monochrom: programmable keys with an LCD display kind of miss the whole point of the keyboard as something you don't look at
10:59:31 <benmachine> zygoilid: wouldn't that be really cool?
10:59:31 <monochrom> Oh, actually, electric shock to programmers is good! Remember Dijkstra's advice: it should be lines of code saved, not lines of code spent! Yes, punish programmers for being inefficient programmers.
10:59:39 <Berengal> zygoilid, more likely it'll just be a dick with "want to be as big as me? Buy viagra!" on
11:00:02 <Berengal> monochrom, one zap for each copypasted character!
11:00:28 <monochrom> 10000 zaps for using boilerplate languages such as Java.
11:00:38 <Berengal> monochrom, that's built into the language ;)
11:01:18 <Berengal> Yesterday I demonstrated that the sum of a list is shorter in lambda calculus than Java...
11:01:27 <sproingie> microsoft comfort curve sounds like a tampon
11:01:31 <monochrom> Believe me, when this all ends, dons will be the only one left posting on reddit, and the posts will be all useful code!
11:01:31 <medfly> I didn't realise using less lines means being more efficient, I should stop making readable functions.
11:01:53 <monochrom> hahahaha sproingie
11:02:15 <benmachine> I once modified a C program so that wc reported it as having 0 lines
11:02:32 <CalJohn> i think it's more important to save programmer time by introducing clever concepts (like folds) rather than any direct correlation to being "physically" shorter
11:02:36 <sproingie> now try for negative lines
11:03:02 <mauke> I once submitted a C program to an online programming contest where its size was displayed as 2 bytes
11:03:09 <CalJohn> a simple fold replaces about 80% of all for loops, and has many benefits besides
11:03:21 <drhodes> benmachine: was is it a one-liner starting with \n ?
11:03:23 <sproingie> damn that's smaller than the ELF magic number
11:03:36 <benmachine> drhodes: it was a one-liner with no EOL at the end
11:03:39 <Samy> benmachine, how is that possible?
11:03:40 <Berengal> CalJohn, a more advanced fold replaces 120% of all for loops...
11:03:44 <Samy> benmachine, it sounds like a buddy wc to me.
11:03:45 <benmachine> Samy: wc counts newlines
11:03:48 <mauke> then I rewrote it as a shell script. size: 0 bytes
11:03:55 <Samy> benmachine, * buggy
11:04:01 <Samy> benmachine, over here, it counts as 1 line.
11:04:09 <benmachine> hmm
11:04:11 * benmachine has a look
11:04:11 <erikc> http://www.elitekeyboards.com/products.php?sub=filco_keyboards,majestouch_87key&pid=fkbn87meb
11:04:26 <benmachine> Samy: what does wc -l < /dev/null say?
11:04:50 <Samy> benmachine, read(2) from /dev/null, what is the result?
11:05:04 <benmachine> it's EOF isn't it?
11:05:06 <Samy> benmachine, if the file is empty, you have 0 lines. If there is content, it should display at least 1 line.
11:05:16 <benmachine> oh
11:05:19 <mauke> echo -n X | wc -l
11:05:34 <benmachine> depends on what you think is a line
11:05:34 <benmachine> hmm maybe I was wrong
11:05:35 <CalJohn> Berengal: many traversals in "common" code are either summings, mappings or filterings
11:05:44 <benmachine> no
11:05:46 <benmachine> echo -n foo | wc -l
11:06:02 <CalJohn> in java, such a thing takes four lines minimum
11:06:02 <Samy> Hrm. Ok.
11:06:09 <Samy> Maybe it's my text editor fooling me then.
11:06:34 <Berengal> CalJohn, not to mention things like trees, which you can't loop over easily. However, they're all instances of Foldable or even Traversable...
11:06:49 <benmachine> I know vim tends to put an eol on the end of things without telling you
11:07:01 <Samy> It is.
11:07:10 <Samy> (my text editor)
11:07:16 <mauke> benmachine: as it's supposed to
11:07:33 <benmachine> mauke: not complaining!
11:07:36 <mauke> also, here's a better wc -l
11:07:37 <benmachine> just sayin'
11:07:38 <CalJohn> exactly, tree use is needless made hard (and thus rare) in imperative languages by their crap support for looping
11:07:43 <mauke> perl '-ple}{$_=$.'
11:07:59 <CalJohn> s/looping/iteration, because let's use proper words
11:08:02 <Samy> mauke, better why?
11:08:15 <benmachine> because no-one except him can understand it :x
11:08:18 <mauke> doesn't count text as 0 lines
11:08:30 <Samy> ah
11:08:41 <benmachine> as I said it depends what you think a line is
11:08:52 <monochrom> medfly:  http://groups.google.com/group/comp.lang.functional/msg/2eb8df3cb49c789b and my reply http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351 will probably cure your sarcasm and debunk the myth that verbose code is readable.
11:08:56 <benmachine> it's reasonable in my opinion to say a line is a thing with an end-of-line at the end
11:09:03 <jmcarthur_work> > length . lines $ "foo"
11:09:04 <lambdabot>   1
11:09:09 <jmcarthur_work> > length . lines $ ""
11:09:10 <lambdabot>   0
11:09:19 <benmachine> > length . filter (=='\n') $ "foo"
11:09:21 <lambdabot>   0
11:09:22 <Berengal> verbose code is tl;dr
11:09:39 <mauke> if you want to see what it does, try perl -MO=Deparse '-ple}{$_=$.'
11:09:47 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10718#a10718
11:09:49 <benmachine> oops
11:09:53 <benmachine> mispaste
11:09:56 <benmachine> I don't even know what that is
11:10:54 <benmachine> mauke: how does that work? what is the continue block attached to?
11:11:03 <mauke> to the { $_ = $.; } block
11:11:17 <benmachine> but that isn't a loop?
11:11:20 <mauke> yes, it is
11:11:29 <mauke> blocks are loops in perl
11:11:52 <benmachine> oh
11:12:19 <mauke> shortest non-cheating infinite loop in perl:  {redo}
11:12:34 <benmachine> so if you next inside one, do you go back to the beginning or what?
11:12:48 <mauke> you go to the next iteration, but bare blocks only loop once
11:12:54 <mauke> so it's the same as 'last'
11:12:57 <benmachine> oh
11:15:14 <Berengal> mauke, by "loop once", do you mean happens twice or happens once?
11:15:26 <mauke> happens once
11:15:36 <mauke> perl isn't that insane :-)
11:15:53 <Berengal> I was hoping not
11:16:25 * notsmack wonders if there's any sort of xpath-style functions for traversing hexpat nodes
11:18:34 <Berengal> notsmack, They seem similar enough to the HXT nodes...
11:21:19 <notsmack> Berengal, hmm, not too far off...
11:22:09 <sayyestolife> hmm, what does the iso in isomorphism mean?
11:22:26 <aavogt> same
11:22:28 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10722#a10722
11:22:41 <byorgey> sayyestolife: it is greek for 'equal' or 'same'.
11:22:51 <sayyestolife> ah.. awesome, thanks
11:23:16 <aavogt> is there some simple way to do the above, but only rename the variables defined in that module?
11:23:26 <byorgey> sayyestolife: so an isomorphism is a mapping between two structures that shows they are (in some sense) the same.
11:24:22 <sayyestolife> then; isomorphic graphs makes a whole lot of sense
11:24:28 <byorgey> right =)
11:24:31 <monochrom> isotherms
11:24:56 <aavogt> isobars
11:25:12 <trzkril> isolator
11:26:07 <Berengal> isotope
11:26:24 <monochrom> isolatin1
11:26:38 <burp> isochore
11:26:53 <aavogt> i so need help with my problem
11:27:15 <mauke> ISO 8859-1
11:29:10 <ksf> isoverated
11:30:31 <mauke> @quote bots.*simple
11:30:31 <lambdabot> xerox says: <dons> then again, bots themselves are simple  <xerox> "...they are just a morphism in the category of IRC channels together with an endomapping ..."
11:34:49 <sinelaw> although i understand how monads allow clean separation of actions and pure code, is this their only benefit compared to traditional built-in imperativeness?
11:35:03 <sinelaw> i mean, in terms of side effects and safety
11:35:24 <lament> this is not really a benefit of monads
11:35:56 <sinelaw> lament, they make it easy to sequence actions interlaced with pure code
11:36:20 <lament> right, that's the benefit :)
11:36:46 <sinelaw> ok, that's what i meant before too
11:37:16 <lament> but it's not even a benefit of monads - it's a benefit of the IO monad
11:37:44 <sinelaw> lament, well, many other monads can be considered action-sequencers, even if the actions are not exactly IO
11:38:13 <paper_cc> (someone should have mentioned STM ...)
11:38:17 <sinelaw> but that's not what i'm asking, anyway
11:38:31 <lament> right, so the benefit of monads is in abstracting the notion of "action sequencing" and making it reasonably easy to interlace these "actions" with pure code
11:39:00 <sinelaw> i'm trying to understand why building a pure structure (the monad) that represents the sequenced actions at runtime and then running it, is better than just running the actions "from the codE" like e.g C does
11:39:29 <lament> the pure structure is called an action
11:39:30 <burp> it's pure =9
11:39:33 <sinelaw> besides the separation of pure and non-pure
11:39:45 <kyagrd> it's pure !! +1
11:39:47 <mauke> it's awesomer
11:40:09 <mauke> it lets you use Haskell as a powerful meta-language for a normal imperative language
11:40:17 <jmcarthur_work> purity has more consequences than simply "turtles all the way down"
11:40:17 <sinelaw> mauke, that's one
11:40:25 <mauke> e.g. you can write custom control structures in Haskell
11:40:42 <sinelaw> mauke, in other words, the world's best imperative language
11:40:59 <sinelaw> T.M
11:41:04 <sinelaw>    .
11:41:07 <mauke> ™
11:41:14 <lament> sinelaw: so is your question "what's the benefit of having the IO monad" or "what's the benefit of having clean separation between pure functions and IO actions"
11:41:35 <lament> it's certainly possible to have the latter without the former, it's just more cumbersome
11:41:39 <Taejo> I just installed lambdabot. When I run it, it says "Initialising plugins .....................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]} ................ done. lambdabot> "
11:41:40 <lambdabot> Taejo: You have 1 new message. '/msg lambdabot @messages' to read it.
11:41:41 <sinelaw> lament, the second is not a question for me, i understand the benefit (i think)
11:42:08 <Taejo> then I type ":t id" and it responds " fd:7: hClose: resource vanished (Broken pipe)"
11:42:13 <Taejo> what am I doing wrong?
11:42:22 <lament> sinelaw: right, in that case, the monad just happens to be a reasonably convenient way of getting this clean separation in practice
11:43:02 <sinelaw> I intuitively understand it all, but i'm gonna need to defend my decision to use FRP (and Haskell) to some professors
11:43:04 <ksf> wut ~ is not a valid operator
11:43:23 <mauke> ~ is lazy binding
11:43:33 <ksf> but that's its only use, isn't it?
11:43:44 <aavogt> > let list@ ~(x:xs) = [] in length list
11:43:45 <lambdabot>   0
11:43:46 <ksf> I wouldn't mind defining it prefix
11:43:46 <kyagrd> There is a quote about misuse of XML in Java: Configuration is done with data, scripting is done with code. Confusing these leads to scripting with XML which you often see in Java.
11:44:09 <lament> sinelaw: you probably don't need the IO monad for that, only the fact that haskell does have pure functions, the purity of which is proven by the type system of the language itself
11:44:20 <kyagrd> In Haskell such level of scripting can just be done composing monads
11:44:42 <lament> sinelaw: that's the killer feature, the IO monad is just some plumbing that allows that
11:44:43 <ksf> > let (~) f g x = g (f x) in (toUpper ~ isAlpha) 'b'
11:44:44 <lambdabot>   <no location info>: parse error on input `)'
11:45:03 <ksf> ...I like it because it reminds me of an arrow somewhat.
11:45:16 <ksf> I'd call it squikell.
11:45:47 <Berengal> kyagrd, indeed. Haskell doesn't need a separate data-language... (On the other hand, lispers have been coding in XML for decades)
11:45:54 <akuhn> \wc
11:46:15 <lament> Berengal: i dare you say that in #lisp
11:46:53 <ksf> xml is typed
11:46:54 <Berengal> lament, it was more of a kick at XML than at lisp.
11:47:34 <ksf> a lisp expression doesn't come with a dtd except the code that's going to fail interpreting it.
11:47:50 <lament> speaking of typed, C# now has a type called "dynamic" which disables all compile-time checking :(
11:48:05 <Berengal> ksf, it's just as easy to type-check lisp to the same level as you get type-checking in xml
11:48:09 <lament> probably a sign that some new language is about to become dominant...
11:48:21 <ksf> haskell has Dynamic, too.
11:48:26 <Lemmih> lament: It is like Data.Dynamic?
11:48:57 <lament> no
11:49:14 <lament> it allows you to run methods for which there isn't any signature anywhere
11:49:18 <monochrom> Data.Dynamic bypasses compile-time checking to.
11:49:19 <ksf> well yes, if there'd be some standard form of dtd for sexprs expressing stuff like what atoms are allowed where.
11:49:27 <monochrom> So it is like.
11:49:27 <lament> you just write foo.rgclcqgkx() and it compiles
11:49:34 <lament> oh, Data.Dynamic allows that?
11:49:46 <Berengal> ksf, or you could write your own dtd for every function/macro you write...
11:49:58 <monochrom> runtime check and runtime error
11:50:16 <lament> nasty
11:50:41 <ksf> I'm not claiming at all that sexprs don't allow you to say (define (Int Int Int) (+ a b) (#primPlus))
11:50:45 <Berengal> Does this mean C# will have all the safety of a dynamically typed language with all the convenience of a manifestly typed one?
11:50:53 <lament> Berengal: that's my fear
11:51:25 <lament> Berengal: although C# is getting more convenient - using type inference is now standard practice
11:51:32 <monochrom> @type fromDynamic
11:51:33 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
11:51:34 <Berengal> lament, sounds like a step in the right direction then. We need crappier imperative languages so I can start coding in a function one at work
11:51:45 <Berengal> functional*
11:52:08 <lament> Berengal: C# is pretty clearly influenced by Microsoft Research stuff a lot. Microsoft doesn't just keep SPJ for fun.
11:52:20 <monochrom> Your only consolation is the answer is Maybe. But you only know it's Nothing during runtime.
11:52:40 <Berengal> lament, I've noticed. It certainly looks better than Java
11:52:44 <ksf> well dynamic lets you fail as badly if you combine it with fromJust and/or unsafeCoerce.
11:52:48 <lament> Berengal: it's getting more and more functional with every release. Except for this dynamic crap.
11:53:13 <Berengal> lament, I dare you say that in #lisp ;)
11:53:14 <ksf> but then it's quite easy to mess up with fromJust and unsafeCoerce without using Dynamic, at all
11:53:52 <Berengal> ksf, Maybe is safe enough for me. The type's there, shouting in your face, so you've got no excuse to not deal with the Nothing case
11:54:06 <ksf> monochrom, you also have to have a type somewhere that you can put in Maybe's a.
11:54:14 <ksf> afaiu c# doesn't need that.
11:54:16 <RayNbow> preflex: seen quicksilver
11:54:16 <preflex>  quicksilver was last seen on #haskell 3 hours, 14 minutes and 39 seconds ago, saying: although, see http://hackage.haskell.org/package/split-0.1.1
11:54:27 <lament> Berengal: :) let's just stay here, content with our knowledge that Haskell is infinitely better. We don't need to convert heathens - when they're ready, they'll convert themselves.
11:54:38 <monochrom> I like to stretch "like" as far as I can.
11:55:03 <monochrom> Here is the like: the compiler and typechecker does not stop you.
11:55:16 <Berengal> lament, I'm still waiting for that one mountain to come to me, but I'll join you in waiting for the heathens once it does
11:55:27 <lament> Berengal: for verily, preaching to Lispers would be like casting pearls before swine
11:55:34 <ksf> yep. unsafeCoerce as a keyword.
11:55:46 <Berengal> lament, yeah, silly XML-coders...
11:56:04 * Berengal is a bit sad that he actually codes in XML at work... in more ways than one :(
11:56:19 <lament> you must be jealous of lisp then :)
11:56:23 <ksf> hey xslt is functional.
11:56:35 <Berengal> Not really. I wrote a sexpr->xml converter a while back
11:56:45 <ksf> if you write yourself a proper syntax for it, it might even be useable.
11:57:37 <ksf> is there an xslt interpreter written in xslt, yet?
11:59:54 <sinelaw> preflex, seen Peaker
11:59:54 <preflex>  Peaker was last seen on #haskell 7 hours, 58 minutes and 10 seconds ago, saying: * Peaker will bbl
11:59:56 <sinelaw> preflex, seen PeakerWork
11:59:56 <preflex>  PeakerWork was last seen on #haskell 5 hours, 37 minutes and 25 seconds ago, saying: (equational reasoning)
12:00:09 <sinelaw> hah, equational reasoning.
12:00:41 <monochrom> I code html at work.
12:01:00 <sinelaw> Oy vey
12:01:10 <sinelaw> my last project was........
12:01:14 <sinelaw> ...ActiveX
12:01:18 <monochrom> Actually, I mean: I coded html at work.
12:01:21 <sinelaw> :( :( :_(
12:01:37 <sinelaw> nothing in the world worse than ActiveX
12:01:49 <monochrom> Last school term and last year, I taught courses as work. So I made course webpages. So I coded html at work.
12:02:00 <Berengal> ... XML does actually make my job easier. I daren't even think about what it would look like if I had to write it all in Java
12:02:22 <monochrom> I write my blogs in xml.
12:02:27 <jmcarthur_work> Algorithm question if anybody is interested...
12:02:40 <jmcarthur_work> One can generate mth permutation of order n if 0 <= m < n!, but the algorithm works in something like O(n^2) time and O(n) space, if i understand it correctly.
12:02:50 <jmcarthur_work> Say I needed a function permutLookup :: Integer -> Int -> Int such that permutLookup n x is the mapping from x in the nth permutation. Does anybody know if this possible with better complexity than generating the entire permutation? I am unsure, and Google isn't helping me at all.
12:02:58 <sinelaw> monochrom, i just need make a website, and i'm using Sphinx to build it automatically from restructured text (wiki-style) so i don't code anything at all
12:03:25 <Berengal> jmcarthur_work, yes, there is. Let me see if I can remember it at the top of my head...
12:03:30 <monochrom> See for example http://www.vex.net/~trebla/weblog/src  is how I write them these days, then run a haskell program to give html or xhtml
12:03:52 <monochrom> wiki-style is insufficient for me
12:04:07 <jaspervdj> jmcarthur_work: http://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations
12:04:16 <sinelaw> monochrom, lots of overhead to that
12:04:21 <jmcarthur_work> jaspervdj, those all generate the entire permutation
12:04:27 <jmcarthur_work> i don't actually need that
12:04:47 <stefansf> Hello all. I'm new to Haskell and GHC. How can I see the type of e.g. function "length x". The type should be [a] -> Int. But how can I see what GHC inferred? Is this possible during compilation?
12:04:52 <jmcarthur_work> and it takes much longer than is practical for my application
12:05:18 <mauke> stefansf: you can load the file in ghci and type :t length
12:05:31 <jmcarthur_work> stefansf, for compilation you can enable -Wall. this will warn you about any type signatures you left off and give you what ghc inferred
12:05:42 <jmcarthur_work> it will also warn you about some other things, which is nice
12:05:52 <Berengal> jmcarthur_work, if there are n! permutations, there will be (n-1)! permutations each time the first item changes, so divide your x by (n-1)!, take quotienth element of the input list and put it first, and recurse on the remaining with the remainder as x
12:06:36 <jmcarthur_work> Berengal, aw i was hoping it wouldn't involve actually computing anything near n! :( but thanks!
12:06:43 <kw317_> what is the best way to include haskell code fragments in a latex document?
12:06:52 <jmcarthur_work> Berengal, this is for a rather large n
12:07:05 <Berengal> jmcarthur_work, well, shucks then :)
12:07:13 <stefansf> jmcarthur, a perfect, -Wall works great, thanks
12:07:20 <Berengal> I guess you'll be wikipediaing factorial algorithms
12:07:21 <jmcarthur_work> stefansf, np
12:07:46 <stefansf> mauke, ghci does not work for me: segmentation fault  ghci, maybe I should open a bugzilla entry
12:08:21 <stefansf> mauke, but thanks for the tip nevertheless, I will ghci on another machine
12:08:50 <jmcarthur_work> Berengal, oh, the algorithm you gave me also keeps an input list, which is also not what i'm going for. i really just need an Int -> Int mapping
12:09:08 <jmcarthur_work> perhaps there are optimizations possible due to that property
12:09:47 <Berengal> jmcarthur_work, ehm, now I don't understand what you want anymore...
12:09:48 <monochrom> My philosophy is a bit twisted. Ideally, I no longer believe in markup notations. All markup notations entail escape sequences, I reject them. So I am not inventing a markup notation sufficient for me, and no markup notation out there is sufficient for me. Ideally, I believe in GUI frontends. But no GUI frontend is sufficient for me either. In this absence, I use xml directly in practice.
12:09:56 <hackagebot> TrieMap 0.5.2 - Automatic type inference of generalized tries. (LouisWasserman)
12:10:19 <jmcarthur_work> Berengal, we can assume that the "input list" is [0..n]
12:10:39 <jmcarthur_work> Berengal, and i want the output of the function to be something like outputList !! x
12:10:45 <jmcarthur_work> Berengal, but without generating the list
12:11:00 <jmcarthur_work> not sure if it's reasonable
12:11:09 <Berengal> jmcarthur_work, you mean (permutations [0..n]) !! x?
12:11:15 <jmcarthur_work> no
12:11:27 <jmcarthur_work> i don't want the permutation, just a lookup from the particular permutation we generate
12:11:34 <Berengal> Because [0..n] !! x = 1-x
12:11:44 <Berengal> sorry, x-1
12:12:00 <jmcarthur_work> outputList /= inputList ;)
12:12:23 <Berengal> .... and what is the outputList?
12:12:31 <jmcarthur_work> Berengal, in other words... permutation i [0..n] !! x
12:12:47 <jmcarthur_work> Berengal, looking up x in the ith permutation
12:12:52 <Berengal> Ah, there's an i here as well
12:12:56 <jmcarthur_work> yes
12:13:03 <Berengal> I see, I see...
12:13:28 <jmcarthur_work> i'm hoping that these known properties lead to an algorithm with simpler complexity
12:13:44 <Berengal> I think it should be possible in O(x*something), but I don't know how yet.
12:14:19 <jmcarthur_work> and as i said, google is not helping me at all :(
12:15:13 <Berengal> At the very least, my algorithm gives a decent implementation of permutation i [0..n]
12:15:39 <jmcarthur_work> Berengal, yes. that's basically the algorithm that google gives me
12:15:53 <Berengal> Which can probably be even further optimized
12:15:56 <jmcarthur_work> i only didn't see it that way when i first read it
12:16:38 <Berengal> I'm going to have to go for a bit of meditation, then probably give up. I'll tell you if I come up with anything
12:16:49 <jmcarthur_work> Berengal, you rock. thanks!
12:17:24 <tommd1> Anyone here use hOpenGL or OGL?  I'm wondering how it works - does the GL library allocate the objects and Haskell tracks them to pointers?  Does Haskell allocate them and track it will ForeignPtr?
12:20:08 <aavogt> > permutations [1..3]
12:20:09 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
12:20:58 <jmcarthur_work> :t \i n x -> permutations [0..(n-1)] !! i !! x
12:20:59 <lambdabot> forall a. (Num a, Enum a) => Int -> a -> Int -> a
12:21:27 <jmcarthur_work> i think that's pretty much what i'm after
12:22:49 <jmcarthur_work> > let foo i n x = permutations [0..(n-1)] !! i !! x in foo 5000000 36000 10000
12:22:51 <lambdabot>   10000
12:23:17 <jmcarthur_work> > let foo i n x = permutations [0..(n-1)] !! i !! x in foo maxBound 36000 10000
12:23:21 <lambdabot>   mueval-core: Time limit exceeded
12:23:32 <dons> tommd1: do you know if Linus still lives in Portland?
12:23:36 <jmcarthur_work> i'm surprised that first one was so fast
12:23:38 <dons> --- is he coming to your tech talk....
12:24:09 <jmcarthur_work> woah that would be a flame waiting to happen ;)
12:24:40 <monochrom> Hi penguin, meet lambda. Hi lambda, meet penguin.
12:25:35 * monochrom expects Linus to go home and write "after seeing haskell today, I am more reinforced in my belief that C and git are the most suitable for kernels."
12:25:58 <aavogt> > zip (inits "lambdas") (tails "penguin")
12:25:59 <lambdabot>   [("","penguin"),("l","enguin"),("la","nguin"),("lam","guin"),("lamb","uin")...
12:26:02 <monochrom> "oh, and ext2 ftw"
12:26:13 <aavogt> > zipWith (++) (inits "lambdas") (tails "penguin")
12:26:14 <lambdabot>   ["penguin","lenguin","languin","lamguin","lambuin","lambdin","lambdan","lam...
12:27:40 <sinelaw> this is what's going on with BitC: http://www.coyotos.org/pipermail/bitc-dev/2009-May/thread.html
12:28:25 <monochrom> Hahaha
12:28:37 <monochrom> (What is BitC?)
12:28:47 <sinelaw> http://www.bitc-lang.org/
12:28:57 <dons> bitc finished up a while ago, iirc.
12:29:06 <jmcarthur_work> i wish bitc and cyclone were both still kicking
12:29:10 <jmcarthur_work> makes me sad
12:29:16 <dons> one of those languages that survive while there's funding, but don't establish a user base.
12:29:25 <monochrom> When you're old, you won't be sad any more.
12:29:47 <sinelaw> yes
12:30:01 <sinelaw> it looked hopefull
12:30:30 <skorpan> i heard C# is on the uprise
12:30:37 <sinelaw> apparently Shapiro has been hired by Microsoft and joined the Midori project
12:30:47 <mpiechotka> Hello. My friend ask me to help him to debug a function. It seems that in ghci it works but on hugs it produces some very strange results - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10726#a10726. Function modPow is pure. Unfortunately hugs is the official compiler/interpreter (so even version cannot be changed). Does anyone have any idea what's wrong?
12:31:02 <burp> the official?
12:31:43 <mpiechotka> burp: On the university
12:31:46 <burp> ok
12:31:50 <mpiechotka> They check everything on hugs
12:32:02 <mauke> mpiechotka: what does :t modPow say?
12:32:02 <skorpan> so did we back in 2004
12:32:20 <mpiechotka> mauke: modPow :: Int -> Int -> Int -> Int
12:32:53 <mauke> hmm
12:33:11 <mauke> yes, that explains it
12:33:37 <mauke> > 1728 ^ 3 `mod` 1729 :: Int
12:33:38 <lambdabot>   1728
12:33:40 <dons> hugs. sigh
12:33:41 <mauke> or not
12:34:09 <mauke> > 1728 ^ 3 `mod` 1729 :: Int32
12:34:10 <lambdabot>   107
12:34:14 <mpiechotka> mauke: See the code. Depending on context evaluation differs
12:34:16 <mauke> success
12:34:20 <mauke> depending on types
12:34:32 <Berengal> Yay, defaulting!
12:34:51 <mpiechotka> mauke: I see. Thanks
12:36:13 <sinelaw> damn, microsoft research seem to have sucked-up all the big shots
12:36:45 <sinelaw> now i need to compete with them, and have no chance of working with any of them
12:37:06 <monochrom> hugs is chosen because smaller, easier to install, easier to remove, easier to read error messages (they say).
12:37:26 <mauke> the error messages thing is wrong
12:37:39 <mauke> the rest is probably true
12:38:24 <monochrom> also it is not like first-year courses get into overlapping undecidable multiple-parameter typeclass bang patterns in scoped type variables.
12:38:36 <Berengal> Error messages should consist only of a line number, and possibly a hexadecimal error value if the compiler developers felt generous
12:38:56 <mauke> ?
12:39:13 <Berengal> mauke, they don't need ghc and its extentions
12:39:54 <Berengal> (Also, bang patterns in type variables made me giggle)
12:39:55 <jfoutz> and the line number should be an approximation.
12:40:09 <monochrom> hehe
12:40:18 <Berengal> jfoutz, to keep modules short and sweet, verily!
12:41:51 <monochrom> another theory: hugs is chosen because the teacher grew up with hugs or gopher.
12:42:10 <monochrom> err gofer.
12:42:27 <Berengal> gofer does have a nice name...
12:42:45 <sinelaw> reminds me of the muppets
12:43:01 <monochrom> <3 kermit
12:44:28 <aavogt> > (<3) kermit
12:44:29 <lambdabot>   True
12:44:52 <monochrom> hahah
12:45:06 <jfoutz> > (<3) wais
12:45:06 <lambdabot>   Not in scope: `wais'
12:45:15 <jfoutz> everybody forgets wais.
12:45:20 <bsdemon_> Hi, can I do branching with parsing? I mean if <something not matches> then return <something> else ...
12:45:35 <monochrom> <|>
12:46:01 <Berengal> Depending on the parser, you might need to "try" the first parser...
12:46:37 <bsdemon_> thanks
12:46:59 <bsdemon_> do you know examples of parsing python-like languages with parsec?
12:47:16 <bsdemon_> something with indentations
12:47:36 <Berengal> indentation-based parsing is painful...
12:47:56 <Berengal> But python is nice in that you can tokenize INDENT and DEDENT without worrying about the depth
12:48:22 <Peaker> Berengal, you can probably do it for Haskell too that way, no?
12:48:24 <jfoutz> oh, that's very clever.
12:48:38 <mux> would you recommend a template library to write html templates? I'm thinking of moving away from xhtml, because things get annoying when you have a lot of html, and it doesn't support bytestrings
12:48:48 <bsdemon_> yes, first I am trying to parse it with char parser - Parser, but it seems I need tokenize before
12:48:58 <burp> mux: sure, for example hstringtemplate
12:49:02 <Berengal> Peaker, nope. "let foo\n    bar" needs to be parsed differently than "let\n  foo\n  bar"
12:49:13 <Berengal> Peaker, or at least, the tokenizer needs to worry about that
12:49:46 <Berengal> Or perhaps it doesn't...
12:49:53 * Berengal hasn't thought this through
12:50:01 <bsdemon_> how I can represent DEDENT with Parser?
12:50:28 <mux> burp: are you recommending hStringTemplate over other libs or are you just giving me one such library? your "for example" got me worried :-)
12:50:33 <monochrom> tokenizer has to respect spaces.
12:51:00 <Berengal> bsdemon_, you want your own datastructure representing the different tokens, and a lexer function of type String -> [Token]
12:51:12 <burp> mux: well, I use hstringtemplate, I don't know of any other
12:51:29 <Berengal> That way you can parse a [Token] instead of a String, and not worry about the layout
12:51:39 <bsdemon_> Berengal: ok, thanks
12:51:40 <monochrom> This is advanced. would take me several years to write a tutorial.
12:51:50 <Berengal> Of course, you might want to use a parser for lexing as well, but then at least you won't have to worry about ASTs and stuff
12:52:11 <cocon> is there somewher a list of options -O is equivalent to ?
12:52:29 <Berengal> cocon, I'd look at the ghc manual
12:53:12 <bsdemon_> are there good lexers for haskell that works like parsec (EDSL)
12:53:15 <monochrom> probably changes once in a while, too.
12:54:04 <cocon> Berengal: I did
12:54:46 <monochrom> probably undocumented precisely because it changes.
13:00:26 <cocon> monochrom: how could this be found out? is it somewhere appearant in the source?
13:01:07 <monochrom> I think the source is the only place.
13:04:07 <EvilTerran> bsdemon_, if i'm parsing with parsec, i tend to lex with it too
13:05:32 <EvilTerran> one parser String -> [Token], then one [Token] -> parse tree
13:06:02 <augur> man
13:06:14 <augur> so i made this type calculating algorithm thingybop, right
13:06:24 <EvilTerran> a type inferrer?
13:06:27 <augur> and its kinda working
13:06:32 <augur> well, its sort of an inferer
13:06:44 <monochrom> haha, "kind of" doesn't bode well :)
13:07:33 <cocon> what's the difference between a static and a dynamic flag?
13:07:47 <augur> i guess you could say its a type inferrer
13:07:49 <monochrom> you can change dynamic flags in ghci
13:08:13 <augur> given a bracketting of some strings, and an arbitrary assignment of types to nodes in that bracketting
13:08:26 <augur> it will calculate the possible type assignments on that whole bracketting
13:08:36 <bsdemon_> EvilTerran: ok, will try to do it this way, thanks
13:08:45 <augur> its buggy tho :(
13:09:00 <augur> i know of certain possible solutions that it seems to be rejecting
13:09:12 <augur> and i dont know why its rejecting them
13:11:32 <jkramer> Ahoy
13:11:48 <jkramer> Does anyone know if HaskellDB is continued?
13:12:34 <jkramer> Looks like the last news is from sep 09, when they updated their website :)
13:30:47 <roconnor> lonely
13:32:16 <FunctorSalad> me too
13:35:54 --- mode: irc.freenode.net set +o ChanServ
13:36:03 <lament> because they're warm and fuzzy...
13:36:04 <benmachine> *632, apparently
13:36:04 <benmachine> 633.
13:36:04 <Tai> ehhh what exatly happend just now
13:36:05 <Tai> O.O
13:36:05 <mthncmr> netsplit
13:36:06 <Tai> i love cats but how can 500 ppls discuss about cats ?
13:36:06 <_zenon_> netsplit?
13:36:06 <Lemmih> They heard the talk about kittens and came running.
13:36:07 <medfly> haha
13:36:07 <inimino> lament: so that's what we should call it...
13:36:09 <Tai> uhm i googled c++ irc chats
13:36:14 <Tai> and puff here i am
13:36:15 <Tai> -.-,
13:36:19 <medfly> ##C++ should be okay
13:36:20 <inimino> Tai: you fail at Google
13:36:25 <notsmack> Tai, haha, you're in the wrong place  :-)
13:36:29 <benmachine> medfly: it should be, but is it?
13:36:32 <mthncmr> _zenon_: http://en.wikipedia.org/wiki/Netsplit
13:36:40 <medfly> who knows :)
13:36:44 * FunctorSalad didn't notice any cats :-(
13:36:47 <abbe> [humor] http://www.awpi.com/Combs/Shaggy/A917.html
13:36:50 <notsmack> @google c++ irc chats
13:36:51 <lambdabot> No Result Found.
13:36:55 <medfly> you must have real talent to find Haskell by googling C++
13:37:12 <lament> Tai: anyway, if you only started learning C++ two days ago, it's not too late to forget about it and switch to Haskell!
13:37:14 <Tai> -.-, yeah i fail at google but how the ***** was i suposed to know a chat called #haskell was about cats
13:37:39 <lament> FunctorSalad: http://arcanux.org/lambdacats/foldl.jpg
13:37:42 <Tai> never heard about that language
13:37:44 <medfly> Tai, this isn't really a chat channel for discussion of cats
13:37:55 <Tai> i thougt so
13:37:56 <mahogny> Tai, it's because it's for the elite, not the masses
13:38:01 <inimino> Tai: it's always good to read the topic when joining a new channel
13:38:03 <medfly> haha
13:38:26 <Tai> i never uses irc and i got direct into this room from google
13:38:32 <Tai> so ...
13:38:48 <FunctorSalad> @quote cat
13:38:48 <lambdabot> heatsink says: Behold the great monad called List / that yields results with a twist: / For inspection conclusive / of choices exclusive / concat them, if you get my gist.
13:38:53 <medfly> oh, so you can't switch channels with PJIRC? if you used some other web app for chatting it'd be better
13:38:54 <Zao> Catamorphism?
13:39:08 <lament> @quote kitten
13:39:08 <inimino> Tai: try '/topic', and if that doesn't work get a real IRC client
13:39:08 <lambdabot> No quotes match. I am sorry.
13:39:16 <FunctorSalad> Zao: same etymology as catastrophe, actually
13:39:24 <lament> FunctorSalad: what was your quote about kittens?
13:39:26 <FunctorSalad> ("downwards")
13:39:29 <medfly> Tai, try to use http://java.freenode.net/ it's a chat client for freenode, and join the channel of ##C++
13:39:33 <burp> foldl? shouldn't it be map?
13:39:36 <burp> hm..
13:39:36 <FunctorSalad> lament: apparently tehre aren't any kitten quotes stored
13:39:52 <Zao> Cataclysmic catamorphic catastrophes.
13:40:00 <Tai> kk i guess this one is called gogloom
13:40:02 <notsmack> Tai:  here's what we talk about here:  http://en.wikipedia.org/wiki/Haskell_(programming_language)
13:40:04 <FunctorSalad> we had a kitten_supply @let once
13:40:05 <lament> oh, you didn't have a quote
13:40:07 <lament> yeah
13:40:12 <lament> > replicate 100 "kitten"
13:40:13 <lambdabot>   ["kitten","kitten","kitten","kitten","kitten","kitten","kitten","kitten","k...
13:40:32 <mthncmr> lambdabot: help
13:40:44 <FunctorSalad> @halp
13:40:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:40:58 <lament> @halp hlap
13:40:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:40:58 <Tai> could i have the link again ?
13:41:02 <mthncmr> lambdabot: list
13:41:03 <notsmack> http://en.wikipedia.org/wiki/Haskell_(programming_language)
13:41:10 <notsmack> unless he meant the irc link
13:41:15 <medfly> Tai, http://java.freenode.net/  if you meant that
13:41:17 <medfly> hehe
13:41:27 <lament> Tai: try typing /j ##C++
13:41:30 <mthncmr> lambdabot: help list
13:41:40 <medfly> he seems to be using PJIRC, I think it's awfully limited
13:41:55 <Tai> ty but i just wanna know what haskell is before leaving :P
13:42:02 <mthncmr> lambdabot: help 'list'
13:42:06 <lament> Tai: it's a programming language much superior to C++ :)
13:42:25 <lament> Tai: so, in a way, you have found the right place...
13:42:26 <medfly> s/superior/that this channel views as superior/
13:42:35 <mthncmr> lambdabot: 'list'
13:42:45 <mthncmr> lambdabot: I give up
13:42:49 <lament> @list
13:42:49 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:43:30 <Tai> it sure does look alot like c++
13:43:34 <Tai> main = do putStrLn "What's your name?"
13:43:38 <OCastro> sup guys
13:43:38 <Asztal> lament: it bothers me that the foldl.jpg should be using foldl1 instead :(
13:43:52 <OCastro> Tai: my name is Castro
13:43:55 <OCastro> ;)
13:44:16 <FunctorSalad> *O*Castro
13:44:21 <Tai> hello castro
13:44:24 <FunctorSalad> from OCaml?
13:44:30 <burp> Asztal: oh, right
13:45:16 <jkramer> What SQL lib are you using for database stuff?
13:45:28 <jkramer> I'm not sure which one to use, they all seem to be a bit outdated
13:45:46 <burp> jkramer: takusen
13:45:50 <Tai> putStr ("Hello, " ++ name ++ "!\n")  in c++ thats cout << "hello," ++ name ++ "\n";
13:46:06 <Zao> Tai: Or not.
13:46:16 <Peaker> s/++/<<
13:46:19 <Tai> yeah there is a code before i know i know
13:46:30 <Zao> operator + is the way to concatenate std::string-s
13:46:34 <Tai> but i just ripped a part of a code of
13:47:04 <Tai> i know
13:47:28 <Tai> you can also just drop the + and just type name
13:47:49 <Tai> if you made the string name; cin >> name; before ofc
13:48:21 <Tai> tell me if im wrong oO
13:48:44 <FunctorSalad> oO ( idea for obfuscated haskell: combine (<<) and (>>) in the same expression )
13:49:06 <Zao> How do they associate?
13:49:17 <FunctorSalad> probably same so you'd need parens
13:49:18 <EvilMachine> hey, I’m stuck with monads again. :/ what was that paste site where you could paste snippets?
13:49:35 <jkramer> pastie.org?
13:49:43 <EvilMachine> ok
13:49:45 <FunctorSalad> infixl 1 >>
13:49:47 <burp> @hpaste
13:49:47 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:49:51 <FunctorSalad> (<<) doesn't exist :(
13:50:30 <aavogt> @hoogle (<<)
13:50:30 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
13:50:30 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
13:50:30 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
13:50:33 <jmcarthur_work> FunctorSalad, if << was defined you could also mix it with <* for extra confusion
13:50:43 <jmcarthur_work> << >> <* *>
13:50:56 <FunctorSalad> :)
13:50:58 <Tai> i was talking about a c++ code
13:51:03 <Tai> not a haskel code
13:51:16 <FunctorSalad> yes I was just going off a tangent though
13:51:19 <FunctorSalad> *thought
13:52:15 <Tai> its just a hell when you mix it in c++ and write like cout >> instead of cout <<
13:54:01 <Tai> but why chose haskell instead of c++ ?
13:54:12 <jmcarthur_work> less hell
13:54:25 <Elly> Datatypes. Strong typing. Higher-order functions. Monads. A sane module system. Safety. Garbage collection.
13:54:39 <burp> lazyness, pureness
13:54:43 <mahogny> Tai, by far less syntax. language support for things that takes literally thousands of lines of C++ to do the same
13:55:01 <pikhq> Tai: C++ is hell.
13:55:03 <jmcarthur_work> i would not say monads are a reason to use haskell. monads are a byproduct of some reasons to use haskell :)
13:55:24 <jmcarthur_work> purity is the important one, in my book
13:55:26 <pikhq> Haskell is better than C++ in pretty much every way.
13:56:29 <OCastro> FunctorSalad: late - My name means "The Castro", in Portuguese
13:56:34 <EvilMachine> I don’t understand how to use the Get monad. I want to read a PCM file (yes, in ieee754 float32). How do I create the inverse of this simple code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4371#a4372
13:56:45 <FunctorSalad> OCastro: I see :)
13:58:16 * OCastro is wondering if someone would mind to optimize a function that I'm making
13:58:23 <OCastro> *he's
13:58:27 <OCastro> >.< fail
13:58:42 <EvilMachine> pikhq: the only thing we have to work on, is make it the number one language for games. ^^ (Would require a big speedup and the ability to seamlessly integrate assembler and C/C++ libraries)
13:58:43 <Lemmih> EvilMachine: Use getFloat32le?
13:58:49 <blackh1> Tai: Once you learn Haskell, you will find that you can write code about 10 times as fast.
13:59:33 <pikhq> EvilMachine: Well, it's got rather nice OpenGL support, and you can rather easily link in C. Perhaps not as easy as, say, just writing a C function though.
13:59:37 <jmcarthur_work> EvilMachine, i don't think we have such a severe performance penalty that we can't make competitive games in haskell
14:00:02 <jmcarthur_work> EvilMachine, and the FFI for using C is the best i have ever used
14:00:05 <Peaker> jmcarthur_work, monads are a great reason to use Haskell.. powerset = filterM (const [True,False]) is an awesome feature arising from the existence of monads :-)   user-defined control structures, etc
14:00:12 <blackh> EvilMachine: I am writing a commercial game in Haskell on the iPhone.  I know all about performance in games.
14:00:15 <aavogt> blackh: that is considering that the haskell is half as long?
14:00:22 <EvilMachine> Lemmih: yes. I figured that. ^^ but I have no idea how to read the whole file. i mean, using “decodeFloat32le = getFloat32le : decodeFloat32le” does make no sense, does it?
14:00:27 <FunctorSalad> "10 times" is a bit of a hyperbole no?
14:00:35 <jmcarthur_work> Peaker, right, but monads are synthesized within haskell and are, thus, only a byproduct of the other good things
14:00:52 <pikhq> FunctorSalad: Compared with C++.
14:00:54 <blackh> FunctorSalad: You obviously haven't used C++ for a while.
14:01:02 <Lemmih> EvilMachine: Take the size of the file, divide by four?
14:01:11 <EvilMachine> blackh: ooh, nice!! How do you compile the haskell stuff for the phone? because I need to do something exactly like that. but for every phone except the iphone.
14:01:18 <jmcarthur_work> i also have made a few toy games in haskell, had no problems, and am making a game that might one day be commercial
14:01:22 <pikhq> Just a lack of manual memory allocation nets you a near double increase in coding speed. ;)
14:01:39 <FunctorSalad> hmm
14:02:10 <FunctorSalad> ok could be compare to C++, I don't have any real data
14:02:14 <FunctorSalad> +d
14:02:36 <blackh> FunctorSalad: I'm basing it on day-to-day experience.
14:02:52 <EvilMachine> jmcarthur_work: ok, i can’t speak about the FFI, but very nice to know. :) on the performance: unfortunately for full scale games, even taking 1.2 instead of 1 second for something, is meaning that you lose many things you could cram in there.
14:03:01 <Peaker> jmcarthur_work, my game is a little slow (I suspect SDL though)
14:03:14 <blackh> EvilMachine: http://projects.haskell.org/ghc-iphone/
14:03:45 <jmcarthur_work> EvilMachine, it depends on the game
14:04:17 <jmcarthur_work> i'm not a big fan of the "cram in everything you can" approach to making games
14:04:25 <EvilMachine> Lemmih: but where do i put the parameter for how much to read? do I rust wrap the runGet into a “take (size/4)”?
14:04:28 <jmcarthur_work> i prefer, well, fun games
14:04:43 <FunctorSalad> gnujump
14:04:52 <Lemmih> EvilMachine: See 'replicateM'.
14:05:27 <jmcarthur_work> EvilMachine, 1/1.2 speed is not a significant hindrance for a game
14:05:36 <jmcarthur_work> EvilMachine, your game will vary far more than that from machine to machine
14:06:16 <jmcarthur_work> Peaker, have you profiled it?
14:06:26 <Peaker> jmcarthur_work, nope.
14:07:19 <EvilMachine> jmcarthur_work: well, if you can squeeze out another 20%, you can put  whole new feature in there. what do you think how pretty much all games for the PS2 or other consoles are made? if the hardware does not change, your efficiency has. and I think better efficency while still having clean well-structured code, is what’s the art of coding, isn’t it? ^^
14:07:24 <jmcarthur_work> Peaker, if it does turn out somehow to be haskell's fault, do let me know what the issue is. i am trying to take my current game project fairly seriously
14:07:35 <EvilMachine> Lemmih: ok, I will
14:07:52 <EvilMachine> Lemmih: still a bit shaky on the whole monad thing. but at least i now understand the basics of them.
14:08:10 <Peaker> jmcarthur_work, you can "cabal install breakout" and check it out
14:08:14 <jmcarthur_work> EvilMachine, a whole new feature like what? prettier reflections? things like that don't really make or break a game
14:08:21 <jmcarthur_work> oh the breakout game
14:08:28 * jmcarthur_work will try it tonight
14:09:15 <EvilMachine> jmcarthur_work: no, that’s what the GPU is for. ^^ i mean things like more objects at the same time. like the amount of people and cars GTA can simulate at the same time. :)
14:09:37 <jmcarthur_work> EvilMachine, such things are easy to parallelize. that's the "magic bullet" ;)
14:11:17 <sproingie> simulations are actually pretty hard to vectorize
14:11:33 <sproingie> people and cars interact.  gpu can't branch.
14:11:36 <EvilMachine> jmcarthur_work: but what i meant with “a whole new feature” was more like being able to add a gameplay element that you originally planned, but did seem possible with the current architecture. think how they did put “3d” in wolfenstein. would not be possible with a slower language back then. ^^
14:12:14 <jmcarthur_work> EvilMachine, i'm gonna have to pull out the varying machine speeds argument for that one again
14:12:19 <EvilMachine> jmcarthur_work: lol. i don’t believe in magic bullets. i use every  possibility i get, and the sum is the “magic bullet” ^^
14:12:25 <jmcarthur_work> EvilMachine, if a 20% factor is enough to kill it, you won't run on enough machines anyway
14:12:53 <jmcarthur_work> EvilMachine, the magic bullet reference was tongue in cheek
14:14:00 <EvilMachine> jmcarthur_work: lol  agreed. but i never said it wouldn’t run. just that it could be a better game, with more resources. (if those are used to make the game better, which is my assumption, as I’m not working for EA ^^) what’s so hard about that?
14:14:41 <OCastro> how do I repeat a condition on several predicates, in a list comprehension?
14:14:58 <Peaker> OCastro, What do you mean?
14:15:21 <OCastro> like, the numbers have to be divisible by 2 or 3 or 5
14:15:38 <OCastro> I have an auxiliar function called divides that tests this
14:15:41 <jmcarthur_work> EvilMachine, have you seen any of time sweeny's presentations on the future of game development?
14:15:52 <FunctorSalad> @let dby n x = x `mod` n == 0
14:15:52 <OCastro> but it's quite verbose
14:15:53 <lambdabot>  Defined.
14:16:01 <jmcarthur_work> *sweeney
14:16:04 <OCastro> that's what I did
14:16:05 <Zao> > [x | x <- [0..15], x `mod` 2 == 0, x `mod` 3 == 0]
14:16:06 <lambdabot>   [0,6,12]
14:16:12 <aavogt> OCastro: then add a variable <- [2,3,5]
14:16:25 <OCastro> oh shit
14:16:28 <OCastro> I can do that?
14:16:46 <aavogt> > [x | n <- [2,3,5], x <- [0..20], x `mod` n == 0]
14:16:47 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,0,3,6,9,12,15,18,0,5,10,15,20]
14:16:52 <Zao> You can have any amount of boolean expressions in a list comprehension.
14:17:00 <OCastro> holy crap
14:17:04 <jmcarthur_work> EvilMachine, http://graphics.cs.williams.edu/archive/SweeneyHPG2009/TimHPG2009.pdf
14:17:07 <Zao> They're mighty nice.
14:17:07 <medfly> :-D
14:17:10 <medfly> Haskell is awesome!
14:17:21 <OCastro> that's so f ing elegant
14:17:22 <OCastro> dude
14:17:29 <jmcarthur_work> EvilMachine, lots of things mentioned in there that is ideal in a purely functional language
14:17:32 <aavogt> > [x | x <- [1..20], n <- [2,3,5], x `mod` n == 0] -- possibly a more sane order
14:17:33 <lambdabot>   [2,3,4,5,6,6,8,9,10,10,12,12,14,15,15,16,18,18,20,20]
14:17:51 <EvilMachine> Lemmih: hmm, i have a bad feeling about first having to find the size, and then using replicateM to read all the data. what would i do if i could not know the size? like with a stream? i would prefer something that gives me a Maybe would be nice, I guess…
14:18:12 <blackh> medfly: I know!! Haskell is really really awesome!
14:18:12 <EvilMachine> jmcarthur_work: no, do you have a link to those presentations? :)
14:18:15 <aavogt> > [x | x <- [1..20], any (\n -> x `mod` n == 0) [2,3,5]] -- no dupes
14:18:16 <lambdabot>   [2,3,4,5,6,8,9,10,12,14,15,16,18,20]
14:18:24 <EvilMachine> jmcarthur_work: ah ok
14:18:38 <OCastro> aavogt: 0_o
14:18:39 <jmcarthur_work> EvilMachine, also this one http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
14:18:55 <OCastro> what is any?
14:18:59 <aavogt> @type any
14:19:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:19:04 <OCastro> OH
14:19:35 <Zao> Haskell has lots of nice composable primitives.
14:19:35 <blackh> jmcarthur_work: Thanks for furthering my education there.  I'm doing game development, but I've hardly ever played a game before, so I have a constant need to up-skill. :)
14:19:39 <Cale> OCastro: any p xs is True if and only if there is some x in xs for which p x is True
14:20:01 <OCastro> like an logical or?
14:20:15 <jmcarthur_work> blackh, admittedly, this is *future* game development technologies, not really current
14:20:18 <EvilMachine> jmcarthur_work: I never ever said that the *language* would be bad/wrong for game programming. Please don’t assume that. I chose Haskell *specifically* because I think as a language, it’s the greatest thing I’ve ever heard of. (For any high-level development.) That includes game design. But the *compiler* could throw out faster code. :)
14:20:18 <aavogt> Zao: too bad the Prelude ones are restricted to lists though
14:20:22 <Zao> @type or
14:20:23 <lambdabot> [Bool] -> Bool
14:20:40 <Cale> OCastro: yeah
14:20:48 <Cale> @src any
14:20:48 <lambdabot> any p =  or . map p
14:20:58 <jmcarthur_work> blackh, but i stand by my statements about 20% performance penalties as it pertains to games
14:20:59 <Zao> OCastro: Like a generic or, but runs a predicate against a list of stuff.
14:21:13 <Cale> It's the composition of or and map :)
14:21:17 <OCastro> this is awesome
14:21:27 <jmcarthur_work> EvilMachine, certainly the compiler could be better. i just don't think it is as big a deal as you do
14:21:33 <OCastro> it's like not reinventing the wheel
14:21:40 <Zao> Just wait until you sit with undecipherable type clashes :)
14:21:58 <jmcarthur_work> OCastro, haskell is *all* about not reinventing the wheel
14:21:59 <EvilMachine> blackh: i have the same problem: i play games too rarely. but if you want to go pro: have you read “The Art of Game Design” by Jesse Schell? I have it here, and I think it’s a must-have. It’s even independent of computers. The book would help you, even if you would have to design a rollercoaster! :)
14:22:11 <jmcarthur_work> OCastro, even things like recursion are meant to be abstracted away :)
14:22:15 <blackh> jmcarthur_work: In our project (iPwn Studios) we're using the (slow) ARM processor on iPhone but we don't have a native codegen yet (about 50% performance penalty), so performance is a very big issue.
14:22:33 <jmcarthur_work> blackh, yeah, that would be a big deal
14:22:49 <EvilMachine> jmcarthur_work: if you would have tried doing 3d audio calculations on a phone, you’d maybe think otherwise. :P
14:23:06 <blackh> EvilMachine: Thanks for that recommendation.  I might just get that.
14:23:10 <EvilMachine> jmcarthur_work: oh: live streams of course.
14:23:36 <jmcarthur_work> EvilMachine, that doesn't sound so bad (if we were to assume native code gen), but i haven't done anything with 3d audio
14:25:11 <EvilMachine> blackh: hey, i would be very interested in seeing the results when you have a game running. (I just unfortunately have no iPhone, and never will, because I’m no friend of lock-in. I’m going for the Nokia N900 instead. :)
14:25:28 <OCastro> why is people so interested in the iPhone?
14:25:36 * jmcarthur_work is targeting higher spec platforms than phones
14:25:37 <EvilMachine> OCastro: hype
14:25:44 <jmcarthur_work> OCastro, it's a gold rush
14:25:52 <Cale> I have no idea why people like phones so damn much.
14:25:56 <EvilMachine> jmcarthur_work: *gg* lucky you
14:26:00 <jmcarthur_work> Cale, i hate mine
14:26:21 <Cale> I hate my landline phone enough. I can't imagine actually carrying one with me when I leave the house.
14:26:32 <blackh> EvilMachine: I am no friend of lock-in either, but I'm hypocritical enough to be happy enough to get paid by people who are.  I can get that book in New Zealand - yay.
14:26:36 <Cale> "Great! Now people can irritate me from anywhere!"
14:26:46 <EvilMachine> Cale: actually, it’s a few loud people with a strong reality, and many cattle. as with every fashion. the trick is to be one of the loud ones. ^^
14:26:48 <jmcarthur_work> Cale, i have no landline and carry a cell phone, but i end up "forgetting" it a lot
14:26:54 <blackh> EvilMachine: We are going to port the game to lots of hand-held platforms.
14:26:55 <Tai> Meh i dont like the c++ chat
14:27:16 <lament> people with a strong reality?
14:27:18 <Berengal> I have a cell phone. I only use it to wake me up in the morning
14:27:23 <OCastro> Cale: a small phone is good enough for me. I have a nokia S40
14:27:25 <Tai> they totaly ignore me -.-,
14:27:38 <EvilMachine> blackh: lol. ok, I agree that it’s a good idea to get money from people who easily pay for shiny but limitey things. ^^
14:27:51 <Cale> Tai: Another good reason to program in Haskell :)
14:27:55 <EvilMachine> blackh: microsoft did a ton of money in that target group too
14:27:55 <Berengal> I'm thinking about getting an N900 though, and possibly try to get ghc on it
14:28:18 <EvilMachine> blackh: i wish i could work with you. :D
14:28:36 <blackh> EvilMachine: You probably can if you don't mind getting paid in promises of future profit.
14:28:38 <Tai> yeah but ill need to learn c++ atleast the basic of it
14:28:42 <jmcarthur_work> i love the slide on page 29 in the first presentation i linked to
14:28:55 <monochrom> don't expect to learn from chatting.
14:29:20 <lament> Tai: if you need to learn it, look for a tutorial, not a chat room
14:29:27 <blackh> EvilMachine: When the company has made some money they'll be able to afford to pay people.
14:29:34 <lament> Tai: the best way to use IRC is to ask very specific questions as you get them
14:29:38 <EvilMachine> lament: that’s a bit hard to explain. people who know exactly how things are, what is good, what is bad, etc. people who are very self-confident. (but because they are righ. or else it would be a delusional reality.)
14:29:41 <jmcarthur_work> 60 MHz Pentium could execute 16 operations per pixel at 320x200, 30 Hz... a 4 teraflop processor will execute 16000 operations per pixel at 1920x1200, 60 Hz
14:29:41 <Tai> i know
14:29:49 <Tai> and my question is specific
14:29:54 <jmcarthur_work> err
14:29:56 <monochrom> (exception: I am paid to do the teaching 20 hours a day.)
14:30:00 <jmcarthur_work> 1920x1080, not 1920x1200
14:30:11 <jmcarthur_work> that's assuming 50% graphics 50% gameplay
14:30:19 <EvilMachine> blackh: actually, that’s what I’m working on right now.
14:30:21 <lament> EvilMachine: i suspect it's not even necessary to be right :)
14:30:25 <monochrom> (I guess Cale is another exception)
14:30:33 <Tai> i just want to  know why my programs work if i compile with dev-c but everything else just fail compiling it
14:30:39 <Tai> even microsoft c++
14:30:55 <aavogt> monochrom: paid in promises of future profit?
14:31:03 <blackh> EvilMachine: someone said to me "soon we Haskell programmers will be out of the ghetto"!
14:31:15 <monochrom> I want payment as money here and now.
14:31:16 <Cale> Tai: Normally the compiler will tell you exactly which part of your program it didn't like.
14:31:32 <Tai> yeah but the lame is
14:31:43 <Tai> i acutally tryed to write the same scribt 2
14:31:44 <EvilMachine> jmcarthur_work: that’s a bit simple with todays GPUs, who can do much much more than the CPUs, if it’t the right code (if it’s massively parallelizable)
14:31:45 <Cale> Tai: Not all C++ compilers support the exact same features, and not all systems have the same set of libraries.
14:31:47 <Peaker> where "part" may be a whole large function that has some "infinite type"
14:31:52 <FunctorSalad> blackh: awesome
14:31:53 <Tai> looking exatly like ea other
14:32:04 <Tai> one of it did work and the other didnt
14:32:32 <Tai> int it was getting on my nerves big time
14:32:39 <EvilMachine> lament: well, actually, if you are not right, but expect to be right, you will try to live up to your expectations, and soon actually *be* right. :)
14:32:44 <jmcarthur_work> EvilMachine, GPUs are not so flexible
14:33:05 <jmcarthur_work> EvilMachine, the presentation advocates 100% software rendering as the future of real time graphics
14:33:17 <lament> EvilMachine: "We are what we pretend to be" - Kurt Vonnegut
14:33:31 <Peaker> jmcarthur_work, whose presentations? Why not defer inflexible work to GPUs?
14:33:45 <jmcarthur_work> Peaker, because it's inflexible ;)
14:34:00 <jmcarthur_work> Peaker, and GPUs and CPUs are getting very close to each other soon
14:34:12 <EvilMachine> blackh: we’re not the ghetto! we’re the scientists who care more about science than about money. to me that’s a big ideal. with science you can change things that will be remembered for many generations and change big things. with money, after 3 generations, people will not even know you existed, even if you changed things.
14:34:39 <jmcarthur_work> Peaker, tim sweeney, btw
14:34:44 <medfly> science?
14:34:48 <jokerGTA> guys can someone help me undesratdn something
14:34:50 <jmcarthur_work> forgot to answer the first question there
14:34:57 <EvilMachine> jmcarthur_work: i know. but the graphics code does not need big flexibility either. :)
14:34:58 <aavogt> @quote SCIENCE
14:34:58 <lambdabot> jmelesky says: I've figured out the problem. qwe1234 has different definitions of "functional programming", "compiler", "complexity theory", "math", and "optimization" than everybody else who deals
14:34:58 <lambdabot> with computers or computer science.
14:35:17 <jmcarthur_work> EvilMachine, just check out the slides
14:35:19 <blackh> EvilMachine: This is true - I need to focus more on the big picture.  The trouble is that at this point in history in particular, money is a bit of an issue.
14:35:27 <medfly> EvilMachine, or you can just fly an aeroplane into a building
14:35:46 <medfly> :))
14:35:50 <EvilMachine> lol @aavogt
14:35:56 <jmcarthur_work> Peaker, http://graphics.cs.williams.edu/archive/SweeneyHPG2009/TimHPG2009.pdf
14:35:57 <monochrom> please don't fly into a building
14:36:00 <EvilMachine> jmcarthur_work: i will
14:36:41 <jmelesky> huh. i didn't know i was in the quote memory
14:36:51 <jokerGTA> i have problem with lists of functions
14:37:10 <monochrom> The question slowly unfolds itself \o/
14:37:10 <jmcarthur_work> jokerGTA, yes?
14:37:28 <EvilMachine> blackh: depends on how much you use their money. the worth of that money if falling. not that of rest. if you’d have gold in your community instead, yo would not even notice any financial problems. :)
14:37:33 <Peaker> jmcarthur_work, ooh I haven't seen this one
14:37:47 <jokerGTA> for example if I have lists of function like this [moveMeLeft,MoveMeRight,MoveMeUp]
14:37:51 <EvilMachine> medfly: well, i want to be remembered positively. ^^
14:38:05 <jokerGTA> now based on conditions i can choose which function to run
14:38:18 <jokerGTA> but how to i get that function from list
14:38:18 <dmead> hey channel
14:38:22 <dmead> i have foo.hs
14:38:25 <Elly> jokerGTA: pattern-matching?
14:38:25 <FunctorSalad> when the heat death of the universe comes nobody will remember anyway
14:38:26 * EvilMachine guesses in Soviet Russia, buildings flew into YOU
14:38:28 <dmead> can ghc still produce .hi files?
14:38:29 <sproingie> jokerGTA: write another function
14:38:30 <Berengal> jokerGTA, list !! index
14:38:33 <Elly> the same way you usually get stuff out of a list :P
14:38:42 <dmead> can i compile foo.hs to foo.hi still?
14:38:42 <blackh> EvilMachine: Agreed.
14:38:44 <monochrom> [moveMeLeft,MoveMeRight,MoveMeUp] !! 2  will get you MoveMeUp from the list.
14:38:45 <dmead> or is that gone
14:38:47 <jokerGTA> exactly so i do have to know what position in the list my fuinction is right?
14:38:58 <benmachine> dmead: why would it be gone
14:39:01 * Cale couldn't name even one of the people on the airplanes in the 9/11 attacks.
14:39:06 <Berengal> dmead, it still compiles .hi files
14:39:07 <sproingie> jokerGTA: which is why it's usually not a good idea to use lists for that sort of thing.  use a record.
14:39:10 <jokerGTA> lets say if my thing has to move right i have to know exactly where function for that is in the list
14:39:18 <dmead> how would i get a .hi file?
14:39:19 <EvilMachine> FunctorSalad: how old are you planning to become? ^^
14:39:28 <sproingie> dmead: ghc -c foo.hs
14:39:33 <dmead> ah
14:39:47 <FunctorSalad> EvilMachine: weren't we talking about being remembered after one's death anyway?
14:40:01 <Berengal> jokerGTA, I'd put the functions in a record, or just write them as a top-level declaration, depending on your needs
14:40:21 <dmead> but you still have to define a main function?
14:40:21 <monochrom> But I don't understand the design. I mean I disagree with the design. Why use a list for this. Use a record of functions, you know exactly which field gives you what, totally under your control.
14:40:27 <Berengal> jokerGTA, if you want equality on functions.... well, you can't have it
14:40:58 <EvilMachine> FunctorSalad: just because, if in our lifetime we can transform brains into digital data, and send those through the universe, from data node on one planet full of controllable robots to the next one, because of the times it takes to travel, one could actually live until the end of the universe!
14:41:05 <jokerGTA> i know....i was confused because i figured the only way i can use  that function is thatr i must know where the function is in the list
14:41:17 <aavogt> instance (Bounded a, Enum a, Eq b) => Eq (a -> b) where ...
14:41:21 <lament> EvilMachine: sounds boring :(
14:41:24 <hiredman> EvilMachine: if you call that living
14:41:47 <FunctorSalad> lament: don't worry you'll be able to run a program equivalent to drugs :D
14:41:49 * benmachine blinks
14:42:02 <FunctorSalad> EvilMachine: yes but I'm not counting on it
14:42:06 <benmachine> why did I just join?
14:42:18 <Elly> you netsplit
14:42:19 <Berengal> jokerGTA, right, so either you'll have to remember the positions of all functions, or use a record so you get to name them (and have differently typed functions as well)
14:42:21 <benmachine> I was watching people talk and suddenly it was all HI USERLIST
14:42:22 <blackh> EvilMachine: I'd prefer to sit in my wheelchair with my huge brain in a jar commanding my minions of doom.
14:42:34 <hiredman> live hard, die young, leave a easily recovered neural pattern
14:42:38 <benmachine> Elly: if that's the case you should all be joining
14:42:39 <Elly> benmachine: your IRC server got disconnected from the network and pretended we had all quit :P
14:42:48 <jokerGTA> ok Berengal....the other thing is can you change return type of main function?
14:42:57 <Elly> benmachine: are you still on the same server you were on before?
14:43:06 <Elly> benmachine: if not, your server may have actually died and you reconnected somewhere else
14:43:15 <benmachine> it does look like I changed servers
14:43:23 <Berengal> jokerGTA, main is IO a, or any more restricted type
14:43:42 <jokerGTA> oh so i cant change the type...i tried but it didnt work....
14:43:49 <lament> FunctorSalad: i would guess that you would go insane quite quickly
14:43:52 <Berengal> Which means, yes, it doesn't have to be IO (), but it can be anything else, as long as it's IO something
14:43:55 <FunctorSalad> (lament: that's what I'd hope to get out of the whole brain upload thing in the first place...)
14:43:57 <FunctorSalad> j/k
14:44:08 <benmachine> oh yeah, looks like kubrick died or something
14:44:20 <jokerGTA> i want to have return type "MyType"
14:44:22 <EvilMachine> lament,  hiredman: well, use your imagination. you "go" to the planet Crazyfarplanet X3, a second later it’s 100 million years later, and you can choose which city and into what system you want to transfer your mind. you can choose between cyborgs, machines, biological bodies, and even custom built things like a swarm of bionic bees. you call that boring? :D
14:44:26 <Berengal> jokerGTA, why would you want a differently typed main anyway?
14:44:49 <jokerGTA> well i am just trying to have like main do something .....
14:44:58 <aavogt> so `main = return "hello world"' actually prints the string
14:45:03 <lament> EvilMachine: Terminally boring. Would I be able to get married and have kids?
14:45:12 <EvilMachine> blackh: oh, that’s… uum… nice. is your name perhaps “brain” :D
14:45:25 <Berengal> aavogt, no, main discards the return, always. Even with Int...
14:45:36 <sproingie> a mechanism that involved transfer of consciousness would probably allow so much interchange between minds that the notion of a continuous "self" would be obsolete
14:45:43 <aavogt> Berengal: I have evidence though!
14:45:52 <Berengal> aavogt, really?
14:45:53 <sproingie> unless perhaps willed into existence by a bored overmind
14:46:00 <sproingie> even then that's a new self
14:46:02 <EvilMachine> lament: of course. why wouldn’t you?
14:46:09 <Cale> aavogt: Is your evidence running the thing in GHCi?
14:46:11 <lament> sproingie: you mean discrete self?
14:46:13 <monochrom> Don't rely on main's return type and return value too much.
14:46:17 <aavogt> Cale: with runghc
14:46:23 <lament> EvilMachine: because that's hard to do without a body
14:46:25 <Berengal> monochrom, s/too much/at all/
14:46:36 <aavogt> yeah, it only works when interpreted
14:46:36 <Cale> aavogt: oh, that's interesting
14:46:45 <Cale> aavogt: and it prints its return value?
14:46:45 <Berengal> Alternatively, rely on it being completely meaningless for the interpretation of your program (when compiled)
14:46:53 <sproingie> lament: yeah discrete.  continuity of experience is also a part of it tho
14:46:55 <aavogt> Cale: yes
14:47:04 <Berengal> aavogt, in ghci, main is just another IO action
14:47:05 <monochrom> I weaken the statement because some people insist on using it for "debugging". Fine.
14:47:05 <jokerGTA> ok
14:47:17 <EvilMachine> sproingie: that’s not a black-white thing i thing that would be a “how much“ choice you could make. just like going outside nowadays. :D
14:47:24 <sproingie> losing the concept of time tends to remove the concept of self
14:47:27 <Cale> aavogt: weird.
14:47:45 <Cale> aavogt: I can see that it does as well. That probably isn't supposed to happen.
14:48:13 <benmachine> runghc basically just invokes ghci anyway doesn't it?
14:48:17 <monochrom> ghci tries to be a smartass on the types of the expressions you enter.
14:48:20 <EvilMachine> lament: but i said that you could choose whatever body you’d like. a human one. another biological lifeform. a cyborg. anything in between. a custom one. anything.
14:48:26 <Berengal> Cale, you seem to be confused about ghci's interpretation of IO values
14:48:43 * EvilMachine now likes to go back on topic ^^
14:48:52 <Berengal> Cale, pure values -> print; IO () -> perform; IO foo -> perform >>= print
14:48:52 <monochrom> If the type is instance of Show, ghci will print. If the type is IO (instance of Show), ghci will still print it.
14:49:08 <Cale> Berengal: Well, yes, that's the new behaviour in ghci
14:49:17 <sproingie> class Consciousness where ...
14:49:18 <Cale> Berengal: But it shouldn't be that way with runghc
14:49:22 <aavogt> runhugs doesn't print the result of main
14:49:39 <EvilMachine> ok, is there any way in haskell, to read a bytestring, and get out something like a Maybe, where you can read in a loop, until the end of the string, even if you have no idea how many bytes will come down the pipe?
14:49:41 <monochrom> I think it is most damaging. Once you leave interpreter and switch to compiler, the printing disappears, you now have a nice little cognitive dissonance.
14:49:44 <Cale> I actually hate that behaviour in ghci
14:49:52 <Cale> The old behaviour was correct.
14:49:57 <Berengal> Cale, oh, right... that is weird
14:50:52 <blackh> EvilMachine: Data.ByteString.Lazy.unpack then treat it as a list of word8 - this would be the usual Haskell way to do it.
14:50:53 <benmachine> what was the old behaviour?
14:53:42 <EvilMachine> blackh: ah, ok, like an infinite list. then i only have to find, how to wrap a getFloat32le around it. that thing only accepts the Get monad. :i
14:53:44 <EvilMachine> :/
14:54:49 <blackh> EvilMachine: If you want to process large chunks, use Bytestring.Lazy.take and drop for speed.  I'm not intimately familiar with Get but remember that it's very little overhead in Haskell to run a monad, since it's mostly just type stuff.
14:56:01 <EvilMachine> blackh: that would mean specifying a lenght again. something i would not always have.
14:56:12 <OCastro> isPrime m = factors m == [1,m] where factors n = [x | x <- [1..n], rem n x == 0]
14:56:16 <OCastro> am I doing it okay?
14:56:35 <blackh> EvilMachine: /blackh looks at haddocks...
14:56:56 <EvilMachine> blackh: i do the same already :)
14:57:13 <EvilMachine> blackh: the problem is that i don’t understand the Get monad.
14:57:21 <FunctorSalad> EvilMachine: look at the sauce of getFloat32le?
14:57:47 <EvilMachine> mmmhhh… FunctorSalad with getFloat32le sauce! :D
14:57:54 <FunctorSalad> hehe
14:58:18 <Cale> OCastro: That will work, but is rather slow as far as implementations of isPrime go.
14:58:43 <blackh> EvilMachine: OK - well, essentially "runGet getWord32le bs' gives a type Word32 - I can't see your getFloat32le.
14:58:48 <Cale> I suppose it at least stops at the first composite number due to laziness, which is good
14:58:53 <monochrom> slow is ok for now
14:59:19 <EvilMachine> blackh: that’s the separate package for IEEE754 values
14:59:31 <EvilMachine> blackh: but it’s meant to be used in the same way
14:59:52 <blackh> EvilMachine: Oh, OK.  Same basic procedure.  So if you want to get one thing, just say runGet getFloat32le bs...
14:59:59 <mightybyte> Is there any general consensus about which of the Haskell XML libraries is the "best" one for general use?
15:00:15 <monochrom> My consensus is that HXT is best.
15:00:26 <FunctorSalad> ^^
15:00:27 <blackh> EvilMachine: And if you want to get two things, then flip runGet bs $ do ; one <- getWord32le ; two <- getWord32le ; return (one,two)
15:00:41 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/322c2d080a6058d1 says why.
15:00:50 <EvilMachine> blackh: ok, so runGet getSomething bs gives me one Something. the actual question now, that i do not understand is: what does runGet do, if bs is at its end.
15:01:04 <OCastro> Cale: I don't know other fancy algorithms
15:01:09 <OCastro> :P
15:01:14 <mightybyte> monochrom: Excellent.  Thanks.
15:01:17 <EvilMachine> blackh: if bs can not deliver any further value. what then?
15:01:17 <monochrom> How much I love my own great writings. :)
15:02:35 <EvilMachine> monochrom: you should buy an evil lair too, just like blackh and me. this month they have a thousand minions for free!
15:02:42 <blackh> EvilMachine: I looked at the source code, and it does 'fail'... which is defined as...
15:02:57 <EvilMachine> blackh: ok, i should have looked at the source too
15:03:02 <monochrom> hrm, what is evil lair, does google know?
15:03:29 <EvilMachine> monochrom: something, an evil overlord lives in, and that a special agent tries to invade.
15:03:46 <FunctorSalad> getFloat32le = fail "lol" -- ?
15:03:48 <blackh> EvilMachine: Err.. it does an error, which is bad design.
15:04:15 <EvilMachine> blackh: should i post that on failblog? :P
15:04:17 <Cale> OCastro: Well, one thing you can do is to only test if primes divide the number, and if p is the smallest prime which divides a composite number n, then p*p <= n. So you can cut off your list of primes by that property.
15:04:17 <blackh> EvilMachine: You would need to check that you had enough bytes to begin with.
15:04:30 <EvilMachine> blackh: definitely
15:05:11 <blackh> EvilMachine: So, if you could say "ensure that the bytestring is at least X bytes long" without making the whole thing strict, would that work?
15:05:18 <redalastor> I have gigabytes of a pattern that looks like (0, 0, 'some text') in a file and I'd like to capture the 3 values to transform them. Can someone give me a pointer about how it's done in Haskell? To complicate matters a bit, sometime there's an escaped apostrophe in the string (\').
15:05:37 <EvilMachine> ok, so i always have to do something like “if (not EOF) then readStuff”. or even better: “readStuff bytesReadyToRead bs”
15:05:43 <blackh> EvilMachine: It's not necessarily bad design - it's just the design decision they made. I would have done it differently. :)
15:06:23 <Cale> OCastro: That is, isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)
15:06:31 <Cale> OCastro: But then, how do we get a list of primes?
15:06:55 <Cale> OCastro: Well, we'll start things off by saying that 2 is prime
15:07:13 <Cale> OCastro: and then filter the list of odd numbers to pick out the prime ones using isPrime :)
15:07:14 <EvilMachine> redalastor: either carefully written regular expressions, or you write a little interpreter for your “language” (which would be cleaner, but more work)
15:07:32 <Cale> OCastro: So  primes = 2 : filter isPrime [3,5..]
15:07:40 <blackh> EvilMachine: If you want to parse 4 numbers, then ByteString.Lazy.take 16 bytes and pass those to Get.  It's all just pointers being moved around, not data being copied.
15:08:15 <redalastor> EvilMachine: It's a one-shot conversion so I'd go for the regex.
15:08:38 <FunctorSalad> does it matter how you write your RE with an automaton implementation?
15:08:46 <Cale> OCastro: is that cool? :)
15:08:48 <FunctorSalad> thought it makes the minimal automaton
15:08:57 <OCastro> Cale: a minute in haskell irc is more profitable than 12 years of math in school
15:08:59 <EvilMachine> blackh: yeah, it’s pretty easy to me now. i guess it should be at least always possible to know how many bytes are in the buffer, ready to read.
15:09:02 <OCastro> 0_o
15:09:04 <Cale> > let isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes); primes = 2 : filter isPrime [3,5..] in primes
15:09:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:09:10 <EvilMachine> blackh: thank you! :DD
15:09:48 <redalastor> Do Haskell have built-in regexes?
15:09:54 <blackh> EvilMachine: No problem - Mwahahahahaahahah the universe shall be mine!!
15:09:57 <Zao> Text.Regex, isn't there?
15:10:10 <EvilMachine> blackh: There can only be ONE!
15:10:20 <blackh> EvilMachine: And he does not share power!
15:10:38 <Asztal> > "aabcbcbd" =~ "[bc]+" :: String
15:10:39 <lambdabot>   "bcbcb"
15:10:57 <Cale> redalastor: No, but there are a bunch of regex implementations. Personally I wouldn't use them, but I've had to explain them to people on IRC often enough that I can help explain them ;)
15:11:41 <Cale> (Personally, I think anything worth parsing is worth parsing with a proper parser combinator library such as Parsec or ReadP.)
15:11:42 <redalastor> Cale: Why wouldn't you use them?
15:12:01 <FunctorSalad> compiled REs should be way faster
15:12:11 <FunctorSalad> (he's reading gigabytes)
15:12:35 <redalastor> Yeah, piping gybabites from STDIN to STDOUT.
15:12:51 <Cale> Yeah, there are languages where good regular expression libraries will do better. Of course, if you want perlish regexes, then you're out of luck, but those aren't really regexes at all :)
15:13:18 <redalastor> My pattern is really simple so I don't need perl's power there.
15:13:23 <redalastor> Which library should I use?
15:13:50 <benmachine> haskell-cafe rejects my postings
15:14:04 <benmachine> have I made some mistake in the signup process or is something mysterious afoot
15:14:18 <Cale> Install regex-base, and then one of the other regex-* libraries on hackage.
15:14:35 <benmachine> "You are not allowed to post to this mailing list" is how the message begins
15:14:36 <Cale> Probably regex-dfa will get decent performance?
15:14:43 <EvilMachine> blackh: but can you do THIS: ☠
15:14:46 <Cale> Or maybe regex-tdfa
15:15:13 <blackh> EvilMachine: Whoa!
15:16:32 <Cale> regex-dfa has an implementation which works on lazy bytestrings which will be handy for stream processing of gigabytes of data
15:17:09 <redalastor> Yes, that'd be perfect.
15:17:41 <kw317> I need to write a parser for assembly language, and I'm wondering what would be the best way to tackle this
15:18:22 <Cale> You should be able to  import Text.Regex.DFA.ByteString.Lazy  and then just use the =~ operator.
15:18:23 <m3ga> kw317: when talking about parsing in haskell, parsec is almost always a really good answer.
15:18:28 <kw317> the parser itself is not such a big deal, I'll use Happy, but I'm wondering what datatype should I use to represent the AST
15:18:47 <kw317> m3ga: what's wrong with Happy?
15:20:01 <m3ga> nothing wrong with happy. i haven't used it but have used bison, ocaml-yacc and other compiler compilers. however parsec is far easier to use and better than yacc/bisin style parsers (and happy is in that group).
15:20:41 <kw317> hmm.. the problem I've got with parsec and other parser combinators is that I'm never sure how to handle lexing nicely
15:20:55 <Cale> kw317: There are a few options you can take. Encoding every possible instruction as a constructors of a single datatype is not one that I'd usually recommend (if it's intel assembly or something, that gets insane quickly), though it is certainly possible to do it.
15:21:23 <EvilMachine> blackh: how are you going to compile for non-iPhone platforms? will you modify GHC-iPhone?
15:21:28 <FunctorSalad> kw317: you can use alex for lexing
15:21:28 <Cale> kw317: It's possible to write a lexer with Parsec, and then a separate parser which parses a stream of tokens generated by the lexer.
15:21:29 <m3ga> there are things that are very difficult in yacc/bison/happy style parsers which are doable in parsec.
15:21:45 <EvilMachine> blackh: I meant non-iPhone ARM platforms (like phones)
15:22:04 <kw317> Cale: yeah, ideally I'd like to have the AST instruction set independent
15:22:05 <blackh> EvilMachine: We'll make more GHC-*'s
15:22:11 <kw317> not sure if that's doable tho
15:22:12 <m3ga> parsec can parse either strings (Char parser) or tokens.
15:22:18 <Cale> kw317: Yeah, probably is.
15:22:44 <Cale> kw317: The only downside to that approach is that you end up doing your own dynamic typechecking to some extent.
15:22:48 <EvilMachine> blackh: wow, I have a long way to go to know haskell well enough to modify the *compiler* ^^
15:22:59 <kw317> Cale: for example, MIPS it's damn easy to handle, because you've got only 3 types of instructions
15:23:02 <kw317> Cale: how so?
15:23:04 <jmcarthur_work> blackh, is GHC-iPhone public?
15:23:17 <Cale> kw317: Oh, well, checking arity and types of arguments to instructions.
15:23:23 <m3ga> EvilMachine: fun compiler to hack on is here : http://www.haskell.org/haskellwiki/DDC
15:23:32 <EvilMachine> jmcarthur_work: the source is available
15:23:32 <blackh> jmcarthur_work: Yes, totally public - same license as GHC.
15:23:41 * jmcarthur_work googles
15:23:52 <blackh> Argh. Now I'm doing it ... same *licence* as GHC
15:23:53 <jmcarthur_work> ah, and here it is!
15:24:12 <jmcarthur_work> licence fails my spell check. license doesn't
15:24:16 <Cale> kw317: But, yeah, if you only have a few instruction formats, it's possible to go halfway.
15:24:24 <EvilMachine> m3ga: lol. the Dicsiplined Disciple Compiler? that sounds like a joke. ^^
15:24:33 <allbery_b> jmcarthur: switch to British/Commonwealth
15:24:34 <allbery_b> :P
15:24:35 <jmcarthur_work> blackh, oh i remember seeing this now
15:24:42 <m3ga> not a joke. very interesting compiler.
15:25:00 <m3ga> althought still alpha quality.
15:25:01 <blackh> jmcarthur_work: licence = noun, license = verb (British spelling)
15:25:10 <sproingie> that makes a lot of sence
15:25:11 <EvilMachine> m3ga: :)
15:25:11 <jmcarthur_work> ah
15:25:37 <jmcarthur_work> http://projects.haskell.org/ghc-iphone/patches/LICENSE   <-- licenSe ;)
15:26:47 <blackh> jmcarthur_work: I bow to computer industry standard spellings sometimes.
15:26:52 <EvilMachine> the word for licen[sc]es should be “liesense”, because half of it is a lie, and the other half makes no sense. ^^
15:31:11 <EvilMachine> yeah, leksah is cool! now when there is a “fail” in my code, it shows a skull and crossbones. :D
15:32:14 <jmcarthur_work> awesome
15:39:28 <cadabra> The following parses fine: do putStrLn "a"; putStrLn "b"; --- and so does this: do\n  let x = 3\n  putStrLn "a" --- but the this doesn't: do let x = 3; putStrLn "a"; --- How can I get ghc to parse that let statement without newlines?
15:41:17 <Asztal> try putting braces around the let's binding group.
15:41:33 <Asztal> do let { x = 3 }; putStrLn "a"
15:42:54 <benmachine> that shouldn't be necessary
15:43:07 <cadabra> Ah, there we go. Thanks Asztal. I tried different combinations of braces, but not that one.
15:43:13 <benmachine> oh
15:43:15 <benmachine> yes it should
15:43:26 <benmachine> *or* let x = 3 in do putStrLn "a" :P
15:44:34 <[CCCP]KuKu> Get totally FREE access to the most complete MP3 library ever (millions of files, every single song on Earth!  All you have to do is register) http://vk.com/reg11541679
15:46:23 <ivanm> *sigh* yet another spammer...
15:47:30 <shepheb> and one with communist leanings, apparently.
15:48:14 <wdonnelly> anyone here know about mapping over arrays (as in Data.Array) in parallel? I'm having a hard time making it work
15:49:07 <ivanm> shepheb: heh, missed that
15:49:41 <twanvl> wdonnelly: do you really need to map in parallel, or just evaluate the values in parallel?
15:50:53 <wdonnelly> twanvl: the second, I suppose. I'm coding a basic cellular automata thingy, and i want to apply the 'step' operation across all my CPUs so it goes faster
15:52:05 <wdonnelly> (the current version is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10743 if anyone's interested)
15:52:08 <jfoutz> wdonnelly: have you read about hashlife? it's a neat way to speed up that sort of thing... depends on how many state transitions you have.
15:53:19 <blackh> wdonnelly: I like the name.  You will want a larger granularity than one cell, otherwise the parallelizing won't be very efficient.
15:53:26 <wdonnelly> jfoutz: i have in fact, but that wouldn't really solve my current task
15:53:41 * jfoutz nods (sorry)
15:53:59 <wdonnelly> i'm doing this because of a recent blog posting (http://blog.bestinclass.dk/index.php/2009/10/brians-functional-brain/) which implemented the same CA in clojure
15:54:10 <wdonnelly> and i was interested in seeing how well Haskell does the same thing
15:54:50 <jfoutz> neat.
15:54:55 <blackh> wdonnelly: I'll be interested to see what your results are.
15:56:41 <wdonnelly> blackh: thanks, i'm planning on writing this all up as soon as i can figure out how to parallelize it properly (because otherwise it wouldn't really be on par with the original code)
15:57:05 <EvilMachine> jmcarthur_work: the whole presentation of Tim Sweeny relies on the assumption that somehow new CPUs soon will have a crazy boost in power, which then can be used to render things in the same quality as right now in software. which would mean throwing away the old pipeline and paying with it with a massively bigger use of electricity and CPU power. i must say I rather prefer specialized hardware for its performance. I would rath
15:57:05 <EvilMachine> e in the box, so your could stick in in a slot in your computer. would solve the “problem” of copying softwar for free too. ^^
15:57:57 <jmcarthur_work> EvilMachine, or it relies on specialized cores
15:58:08 <EvilMachine> jmcarthur_work: wasn’t tim sweeny the guy who mentioned, that Far Cry would look like plastic. to which someone in the comments answered that he looks like plastic. or was that that a half-life guy? ^^
15:58:18 <jmcarthur_work> i don't think he said anything about all cores having to be as general as they are today
15:58:23 <EvilMachine> jmcarthur_work: vector cores to be exact, right?
15:58:24 <jmcarthur_work> just more general than GPU units
15:58:40 <jmcarthur_work> i don't know about about the far cry pastic thing
15:58:42 <jmcarthur_work> *plastic
15:58:48 <EvilMachine> jmcarthur_work: ok, so something that fits the requirements a bit better. ^^
15:59:50 <jmcarthur_work> EvilMachine, i don't think he advocates the annihilation of specialized hardware
16:00:14 <EvilMachine> jmcarthur_work: we’ll see if it’s worth pulling all the extra power. software rendering would definitely be cool though! but it’d go with volumetric tetraeders and do the physics with them too instead. :)
16:00:39 <jmcarthur_work> notice that he puts quotes around "software rendering," which implies to me that he is probably not talking about the same thing as what we had before GPUs
16:00:51 <EvilMachine> jmcarthur_work: *evil overlord mode* I advocate annihilation in general! MUHHAHAAA
16:01:09 <monochrom> exterminate
16:01:37 <monochrom> don't ask to ask. just exterminate.
16:01:54 <ivanm> does anyone else find it weird that softpedia seems to categorize most haskell software as being for macs? :s http://mac.softpedia.com/dyn-search.php?search_term=haskell
16:02:07 <monochrom> haha interesting
16:02:10 <EvilMachine> jmcarthur_work: well, I did not see the quotes. but I’d guess he means the same thing as is going on with the PS3 and its vector cores.and I agree that that stuff is very hard to program for in non-Haskell languages. ^^
16:02:18 <ivanm> windows has 3, linux has 25, mac has _179_
16:02:35 <monochrom> softpedia probably heard my prophecy that by 2015 dons will switch to mac. :)
16:02:37 <jmcarthur_work> i think Cell was vastly overhyped
16:02:51 <ivanm> (and one of the Haskell downloads is a syntax highlighter for websites which happens to support haskell...)
16:02:53 <ivanm> monochrom: heh
16:02:57 <EvilMachine> monochrom: exactly. fist exterminate. THEN explain your great plan, and how they will die. NOT the other way around. :P
16:03:39 <ivanm> EvilMachine: except... who is going to be there to listen to your great plan????
16:03:40 <EvilMachine> monochrom: dons? as in mafia?
16:03:55 <monochrom> don dons!
16:04:07 <EvilMachine> jmcarthur_work: of course it was. but I stil think it was a nice start.
16:04:07 <ivanm> dons is the Haskell mafia don! ;-)
16:04:16 <erikc> jmcarthur_work: the cell is a pain in my neck
16:04:40 <EvilMachine> ivanm: nobody. because they will all already be exterminated. didn’t you read what i wrote? :D
16:04:56 <ivanm> yes, but then what's the point of explaining your great plan?
16:05:07 <monochrom> The idea is you speak to yourself for self-gratification. I do that all the time.
16:05:34 <EvilMachine> erikc: not only in yours. but hey, if i were a GHC developer, I’t make haskell into a magic bullet for it. ^^
16:05:58 <ivanm> monochrom: well, you know what they say about speaking to yourself...
16:06:14 <monochrom> after they're exterminated?
16:06:33 <ivanm> heh
16:06:37 <EvilMachine> ivanm: mental masturbation of course! a basic trait of every evil overlord. :D
16:06:43 <monochrom> (hehehehe <duck>) anyone want my haskell knowledge?
16:06:47 <ivanm> oh, right, silly me...
16:06:50 <ivanm> @slap monochrom
16:06:51 <lambdabot> stop telling me what to do
16:06:56 <ivanm> grrr....
16:07:23 <EvilMachine> monochrom: can i have a truckload of it? what’s the price?
16:07:38 <monochrom> It's a usb-stick-load
16:07:41 <erikc> EvilMachine: i dont see anything about Haskell that'd make cell programming easier
16:07:48 <erikc> and ive searched :)
16:08:00 <jfoutz> wdonnelly: parArray $ Strategy (fmap (stepCell.getPeers w) (indexArray worldX worldY))  at 23 seems about right...
16:08:12 <EvilMachine> erikc: the fact that you can parallelize things much easier for example?
16:08:13 <monochrom> Supposedly you can compile Control.Concurrent.* to cell.
16:09:24 <EvilMachine> erikc: of course I’d prefer if GHC would automatically analyze my code and make everything parallelizable if it is possible. and dynamically add caches between function calls / interfaces if it would make sense. :D
16:09:28 <erikc> EvilMachine: that's not what's hard about the cell though :)
16:10:12 <jfoutz> i thought the cell guys made a dsl, so you'd always hint the right way for branch prediction.
16:10:33 <erikc> the cell is distributed computing with a high bandwidth network and low memory processors
16:10:48 <EvilMachine> erikc: I’m no cell programmer, so I don’t know. I only read some stuff about it, and that’s what I assumed: the chaos of multi-everything coordination and having to constantly fill all the pipelines to use its performance.
16:10:49 <erikc> and the pain points come out of sandwiching your problem/solution into that
16:11:01 <wdonnelly> jfoutz: ah, i was busy messing around with 'seqArr' instead, i'll have to try out 'parArr' now
16:11:04 <EvilMachine> erikc: yes. close enough. ^^
16:11:39 <EvilMachine> erikc: so the low memory is a big problem? (i guessed so)
16:12:05 <erikc> yea
16:13:55 <EvilMachine> would you rather program for a mobile phone? :P
16:13:57 <erikc> the low memory is a barrier to any significant 'runtime' to support a language other than c/asm, forth would work
16:14:12 <EvilMachine> ouch
16:14:34 <erikc> because the more memory you use on your runtime, the less you have for actual data to process/stream
16:14:38 <MyCatVerbs> People run little JVMs on phones, though.
16:14:45 <erikc> since you want to triple buffer that data ideally
16:15:33 <EvilMachine> i think monolithic runtimes are a bit stupid anyway. properly, for such a CPU, one would just compile the dependencies that are actually needed into the binary. and not the whole giant runtime.
16:16:09 <defun> If I have a tuple ([a],[a]) and a constructor Cons [a] [a], will operating on the lists in the tuple be slower, faster, or equivalent than operating on lists in the constructor?
16:17:12 <erikc> a haskell DSL for spu makes sense (and has been done), but it's a stretch to call that haskell hehe
16:17:13 <wdonnelly> jfoutz: thank you! it looks like 'parArr' was the way to go
16:18:10 <jfoutz> sweet! glad i could help.
16:18:16 <Botje> defun: equally fast. to haskell (,) is just another binary constructor
16:18:30 <erikc> MyCatVerbs: phones have more than 256k ram :), i dont remember the exact microjit numbers from my ibm days, but i seem to recall 100k-200k range for the smallest jvm/jit, which doesnt even include your code yet
16:18:30 <EvilMachine> erikc: DSL? i only think of my internet connection when i hear that right now.  it’s late here I guess. what was it that you meant?
16:18:49 <erikc> domain specific language built in haskell
16:18:53 <dancor> Botje: are there any other constuctors besides the tuples that don't start with :?
16:18:59 <EvilMachine> erikc: ah, ok
16:19:02 <Botje> eugh. 1:18 again. better go to sleep
16:19:05 <defun> I see. Thanks. What about ([a],[a],[a]) vs. Cons [a] [a] [a]
16:19:09 <erikc> with a compiler in haskell to go from the dsl to spu assembly
16:19:31 <EvilMachine> erikc: i figured so. :)
16:19:31 <defun> Cons right?
16:19:38 <Botje> dancor: what now? i wouldn't know
16:19:49 <Botje> defun: again, they're both simple trinary constructors.
16:19:51 <dancor> defun: (,,) is just as much a constructor as (,)
16:19:55 <Botje> they should be the same.
16:20:00 <jmcarthur_work> defun, same
16:20:05 <defun> I see.
16:20:14 <defun> Thanks.
16:20:37 <jmcarthur_work> defun, and Cons ![a] ![a] ![a] would be *different*, but better or worse would depend on circumstance, most likely
16:20:52 <defun> ok
16:21:03 <Copter> medfly ftw right?
16:21:04 <Copter> right
16:21:05 <Copter> castingo !
16:21:18 <dancor> > case ("a","b","c") of ('a':[],_,_) -> "ok"
16:21:19 <lambdabot>   "ok"
16:21:29 <dancor> > case ("a","b","c") of ((,,) 'a':[] _ _) -> "ok"
16:21:30 <lambdabot>   Couldn't match expected type `([GHC.Types.Char],
16:21:30 <lambdabot>                           ...
16:21:37 <dancor> > case ("a","b","c") of ((,,) ('a':[]) _ _) -> "ok"
16:21:37 <lambdabot>   "ok"
16:21:40 <jmcarthur_work> dancor, (,,) is special syntax :(
16:21:48 <dancor> yep, it's definitely a constructor
16:21:49 <MyCatVerbs> erikc: I thought the JVMs on phones didn't bother doing JIT?
16:22:01 <jmcarthur_work> oh, i mixed that up with sections
16:22:11 <MyCatVerbs> erikc: better to save the memory and just pay the interpreter overhead on those tiny CPUs than to actually spend RAM on code, I mean.
16:22:21 <jmcarthur_work> something like ("a",) would be broken :(
16:22:29 <CalJohn> i think it's less a case of "don't bother" and more a case of "don't want to"
16:23:44 <EvilMachine> blackh: could you recommend some kind of central site/source / starting point of information for your kind of multi-mobile-platform game development? I can’t find anything serious that looks like that main meeting point on the net…
16:24:58 <blackh> EvilMachine: I don't really know of anything of that kind.
16:25:25 <EvilMachine> hmm… i thought because you were programming that stuff
16:25:57 <erikc> MyCatVerbs: ibm's jvm does jitting
16:26:00 <erikc> very limited
16:27:24 <CalJohn> erikc: what phone is that on?
16:28:25 <Orclev> ok, I'm looking for a class that has a concept of a zero value, a little like mzero, but for non-monad types as well... ideally I should be able to do something like > zero :: Integer, and have it return 0, or > zero :: Char, and maybe have it return 'a', or possibly '\NUL'
16:28:53 <erikc> CalJohn: dont remember, i want to say the treo's
16:29:04 <Orclev> for right now I'm using Enum, which works ok, but isn't really ideal
16:29:12 <MyCatVerbs> Orclev: You could make on. Monoid has mempty.
16:29:15 <MyCatVerbs> *one
16:29:15 <sproingie> Ord?
16:29:33 <Orclev> hmm, I'll take a look at monoid, that sounds like what I want
16:29:50 <MyCatVerbs> Orclev: there's also (Bounded a), which gives you (maxBound :: a) and (minBound :: a)
16:30:17 <Orclev> MyCatVerbs: looked at that, but that dosn't give a zero value... for instance Int returns some hug negative value
16:30:29 <Orclev> MyCatVerbs: what module is monoid in?
16:30:34 <MyCatVerbs> (Monoid m) gives you (mempty :: m) and (mappend :: m -> m -> m), such that (x `mappend` mempty) == (mempty `mappend` x) == (x).
16:30:49 <MyCatVerbs> And also such that mappend is associative (but not necessarily commutative)
16:30:58 <MyCatVerbs> Monoid's actually in Prelude.
16:31:19 <MyCatVerbs> That's because Int is a signed integer. minBound gives you the lowest possible value for a given bounded type.
16:31:46 <Orclev> hmm... trying to find info on monoid in ghci and not finding it... you're sure it's in prelude?
16:31:47 <erikc> CalJohn: part of the problem is i only know them by the codenames so im not sure what crazy name they got branded with :)
16:31:48 <MyCatVerbs> > minBound :: Word32 -- however, the Word types correspond to unsigned integers.
16:31:49 <lambdabot>   0
16:32:38 <Orclev> ah, Data.Monoid
16:33:13 <CalJohn> erikc: it's cool, i'm just curious because deciding to jit on a phone is an interesting design choice.  dalvik, which is on androids, does not jit, and i was under the impression that jit'ing was basically a luxury that a lot of them cut
16:33:32 <CalJohn> (for short running phone programs)
16:33:41 <sproingie> JIT takes a lot of cpu and memory
16:33:53 <CalJohn> yes
16:34:16 <Cale> MyCatVerbs: Monoid is not in Prelude, though it probably should be. I vote for (++) = mappend too :)
16:34:27 <CalJohn> but it can pay off occasionally
16:34:36 <CalJohn> well, it can pay off period
16:34:42 <MyCatVerbs> Cale: oh, isn't it? My bad, sorry.
16:34:58 <MyCatVerbs> (I just think of it as so... close to fundamental that I don't understand why it wouldn't be in Prelude.)
16:35:41 <Cale> :t (++)
16:35:42 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:35:44 <Cale> whee
16:36:12 <Cale> > sortBy (comparing length ++ comparing) (words "here is a list of words to sort by length and then alphabetically")
16:36:13 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> a1'
16:36:21 <Cale> > sortBy (comparing length ++ compare) (words "here is a list of words to sort by length and then alphabetically")
16:36:22 <lambdabot>   ["a","by","is","of","to","and","here","list","sort","then","words","length"...
16:37:13 <Orclev> ok, what am I doing wrong here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10745#a10745
16:37:59 <Orclev> hmm... do I need to do fromInteger 0 for mempty maybe?
16:38:40 <aavogt> Orclev: don't you need some ghc extensions for that instance to be accepted?
16:38:58 <Firestalk> HELP ME to WIN iPod!!  Please register  http://vk.com/reg6453465    Thnx
16:39:17 <Orclev> yeah, I added {-# LANGUAGE FlexibleContexts #-} because of the error message I was getting
16:39:32 <Orclev> ooooh, wait, I need FlexibleInstances as well
16:39:49 <aavogt> maybe UndecidableInstances too
16:39:51 <medfly> HELP ME to BAN Firestalk!!
16:39:52 <medfly> o.O
16:39:53 <Orclev> aavogt: yep
16:41:13 <jfoutz> oh, i see you're not giving it a datatype to hang on too.
16:41:56 <jfoutz> you could also just instance each of the num instances, and skip the scary LANGUAGE options
16:42:24 * SubStack decides those instances
16:42:27 * SubStack is a decider
16:43:07 <jfoutz> but then no (*) instance. i guess you're giving that up anyway.
16:43:31 <jfoutz> @info Num
16:43:32 <lambdabot> Num
16:43:40 <jfoutz> hehehe
16:43:58 --- mode: ChanServ set +o monochrom
16:44:45 <Person_> fantastic
16:47:29 <Orclev> hmm... why does ghci think that "instance (Num a) => Monoid a" is an instance of "Monoid [Char]"??? Char isn't a Num (so far as I know anyway)... wtf?
16:48:27 <jfoutz> what modules do you have loaded?
16:48:45 <monochrom> I don't understand your question. "Monoid [Char]" can be right using mempty=[], mappen=(++), without Num or whatever.
16:49:04 <Orclev> jfoutz: Control.Applicative Control.Monad.Identity Control.Monad.Reader Data.Monoid Prelude
16:49:25 <ivanm> http://mac.softpedia.com/dyn-search.php?search_term=haskell
16:49:30 <ivanm> whoops, wrong paste...
16:49:39 <Orclev> I'm trying to do mempty :: String... and it's complaining about overlapping instances
16:49:44 <ivanm> Orclev: what makes you think that it's that instance that is the problem?
16:49:53 <jfoutz> oh, heh.
16:49:55 <ivanm> Orclev: overlapping because of [Char] rather than [a]
16:50:14 <ivanm> Orclev: you can't specialise (in Haskell98) an instnace like that
16:50:15 <monochrom> Oh oops.
16:50:28 <ivanm> you'd need the extension if you want it String only
16:50:34 <ivanm> monochrom: well, which is pretty much as you said...
16:50:38 <ivanm> s/as/what/
16:50:42 <monochrom> "Monoid [a]" is best.
16:50:51 <Orclev> hmm... actually doing mempty :: [Int] gives the same error
16:51:00 <ivanm> Orclev: for the same reason
16:51:13 <monochrom> Forget [Concrete type here] altogether.
16:51:13 <ivanm> if you are having some weird monoid where you _have_ to have it only for String, then use the overlapping instnaces extension
16:51:28 <ivanm> or else newtype it
16:52:16 <Orclev> no, I don't really care about that... I've defined (Num a) => Monoid a... and now I'm getting overlapping instances for just about everything
16:53:39 <monochrom> because (Num a) is ignored in most stages of typechecking.
16:53:50 <Orclev> hmm
16:54:07 <Orclev> is there a language extension that can't... uhm... fix that?
16:54:15 <Orclev> s/can't/can/
16:54:24 <monochrom> Imagine you wrote "instance Monoid a where". Not what you wrote, but is what most stages of typechecker sees. Now it conflicts with everyone else.
16:54:35 <jfoutz> just use the Monoid (Sum a) from Data.Monoid
16:54:46 <ivanm> or Mult, etc.
16:56:25 <Orclev> well, I commented out my Monoid instance and tried to do mempty :: Int, and now it errors off
16:56:43 <Orclev> how do I make it use Monoid (Sum a) for instances of Num?
16:56:48 <jfoutz> it's all of your crazy extensions.
16:57:28 <jfoutz> uh... 1 `mappend` 1 :: Sum Int?
16:57:35 <jfoutz> > 1 `mappend` 1 :: Sum Int?
16:57:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:57:39 <jfoutz> > 1 `mappend` 1 :: Sum Int
16:57:40 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
16:57:40 <lambdabot>    arising fr...
16:57:45 <MyCatVerbs> getSum (mempty) :: Int
16:57:50 <MyCatVerbs> > getSum mempty :: Int
16:57:51 <lambdabot>   0
16:58:00 <MyCatVerbs> > getProduct mempty :: Int
16:58:01 <lambdabot>   1
16:58:26 <jfoutz> > getSum 1 `mappend` getSum 2
16:58:27 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum a))
16:58:27 <lambdabot>    arising from the liter...
16:58:29 <monochrom> > getSum (Sum 3 `mappend` Sum 4) :: Int
16:58:30 <lambdabot>   7
16:58:36 <MyCatVerbs> So the identity for addition (Sum and getSum) is 0, and the identity for multiplication (Product and getProduct) is 1. :)
16:58:52 <MyCatVerbs> > (Sum 1) `mappend` (Sum 2)
16:58:53 <lambdabot>   Sum {getSum = 3}
16:59:11 <monochrom> obey, use, don't improvise
16:59:13 <Orclev> ok... so it looks like haskell can't do what I want because the type checker drops the constraints during most of the process
16:59:37 <MyCatVerbs> Orclev: What? What do you actually need and what constraints do you think are getting dropped?
16:59:54 <monochrom> "instance (Num a) => Monoid a"
17:00:15 <Orclev> MyCatVerbs: I want a class that has a concept of some zero value, and that I can declare instances for Num, Char, String, or whatever
17:00:57 <Orclev> MyCatVerbs: the goal is to be able to put a constraint on a function type based on that class, then call mzero or whatever to get some sane default value that's of the proper type
17:01:52 <ubuntu-nathan> Hi for all here!
17:02:46 <MyCatVerbs> You could just define a typeclass. class (Zero z) where { zero :: z }; instance (Num a) => Zero a where { zero = 0; }; instance Zero [a] where { zero = []; }; -- and so on.
17:02:52 <ubuntu-nathan> I'm learning Haskell and i want to know if someone can help me with this: http://stackoverflow.com/questions/1569485/parse-error-in-pattern
17:03:05 <MyCatVerbs> But that's a really, really tiny typeclass. Does it actually solve any real problems for you?
17:03:18 <MyCatVerbs> Sure, let's have a look.
17:04:00 <CalJohn> ubuntu-nathan: your issue is indentation, sadly
17:04:13 <MyCatVerbs> Ah. Are you using tabs? Switch to spaces.
17:04:19 <Orclev> MyCatVerbs: yes, and that's more or less exactly what I need, I was just hoping there was already some class defined that does exactly that and had default instances for most types already... Bounded was pretty close to what I wanted, but not quite
17:04:23 <ubuntu-nathan> :D
17:04:26 <ubuntu-nathan> thanks very much!
17:04:28 <EvilMachine> ubuntu-nathan: softtabs are a good solution
17:04:35 <MyCatVerbs> Copying and pasting from the code block that you put there works just fine, ubuntu-nathan. :)
17:05:01 <noZone> Anyone here know of a binary search function on ordered sequences or arrays (not trees) in hackage?
17:05:02 <MyCatVerbs> It's probably just that the indentation doesn't work out because you have mixed tabs and spaces.
17:05:18 <ubuntu-nathan> ;)
17:05:20 <CalJohn> ubuntu-nathan: the contents of a do block must be level with the "do" of the do block, i'm sure someone here can explain it better
17:05:24 <MyCatVerbs> noZone: there's a binary search on arbitrary monotonic functions, though I can't remember what it was called.
17:05:52 <CalJohn> ubuntu-nathan: wait, no, i'm wrong, ignore me
17:06:05 <ubuntu-nathan> ok
17:06:10 <noZone> I've been hunting... I'll have to look up the monotonic thing.
17:06:27 <MyCatVerbs> noZone: http://hackage.haskell.org/package/binary-search :)
17:06:42 <noZone> Wheeee! Tx MyCatVerbs.
17:06:45 <monochrom> I would write binary search on array myself.
17:06:59 <MyCatVerbs> noZone: Numeric.Search.Bounded might even do the right thing in your particular case.
17:07:09 <MyCatVerbs> Yeah, probably, monochrom.
17:07:33 <monochrom> Where do all these little packages doing little common CS homework algorithms come from?
17:07:48 <noZone> I considered rolling my own, but then someone would complain that it already exists.
17:07:51 <monochrom> Did previous students just uploaded their homework to hackage? :)
17:07:53 <MyCatVerbs> ...people writing little common CS homework algorithms for fun in their spare time, probably. :)
17:08:24 <MyCatVerbs> noZone: the Haskell community is pretty laissez-faire about that kind of thing, I think. :)
17:09:00 <EvilMachine> exactly. we’re no rule nazis. but we have one rule: ALL HAIL THE MONOID!
17:09:09 <EvilMachine> :P
17:09:16 <MyCatVerbs> There are at least three or four implementations of most of the really big things to get widely used in Haskell. There's a tradition of having several implementations in order to have a good go at exploring the design space for any given chunk of technology. :)
17:09:21 <noZone> Familiarity with existing libs is something I'm working on. I'm trying not to reinvent that wheel thing.
17:09:42 <monochrom> The wheel keeps growing everyday.
17:10:02 <EvilMachine> noZone: you will notice, that libraries are often much more generic than in other languages, because Haskell allows it.
17:10:38 <ubuntu-nathan> Today this community is small?
17:10:40 <Saizan> (EvilMachi =?= EvilTerran ?)
17:10:54 <monochrom> They already have a few SAT solvers on hackage. Next year they will have a CAS. The year after next you run out of programs to write.
17:11:12 <Saizan> we have to invent new ones
17:11:18 <noZone> The first time I wrote a binary search was in C back in the mid 80s... I'm trying not to repeat myself too many times.
17:11:48 <MyCatVerbs> monochrom: CAS? You mean compare-and-swap or something else?
17:11:50 <EvilMachine> Saizan: Unfortunately, I don’t know what you’re referring to. I guess I’m from earth, yes. Haven’t tried to touch kryponite though. ^^
17:11:56 <Orclev> MyCatVerbs: I just tried using the Zero class example you gave and I get this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10747#a10747
17:12:06 <monochrom> like maple and mathematica. maybe more modest. like maxima.
17:12:34 <MyCatVerbs> Orclev: oh, I fail typeclasses forever. :)
17:12:35 <Orclev> MyCatVerbs: seems like no matter what I run into the same problem
17:12:54 <MyCatVerbs> Yeah, it needs a newtype to stop that from happening.
17:13:30 <MyCatVerbs> It's because in the ((Num a) => Zero a) instance, the right hand side matches absolutely every possibly type. I'm sorry, that was my mistake.
17:13:53 <monochrom> infinite loop
17:14:00 <Warrigal> @docs Dynamis
17:14:01 <lambdabot> Dynamis not available
17:14:02 <Warrigal> @docs Dynamic
17:14:02 <lambdabot> Dynamic not available
17:14:03 <Orclev> so how do I get something that's equivalent to that, but actually type checks properly?
17:14:06 <Warrigal> @docs
17:14:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:15:26 <MyCatVerbs> Orclev: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10747#a10748
17:16:52 <Orclev> MyCatVerbs: yeah, but now I run into the same problem... I can't just call zero on anything that's got an instance of the Zero class
17:18:16 <Orclev> I want to be able to do something like show zero, and have that work for anything that I've defined a zero instance for
17:19:43 <MyCatVerbs> Orclev: If you write (show zero), and there's more than 'z' such that (Zero z, Show z), then how is the compiler supposed to pick which one to use?
17:20:11 <MyCatVerbs> You appear to be asking for GHC to read your mind. :)
17:20:47 <Orclev> MyCatVerbs: well, I want something more like show (zero :: Int), but I'm not sure if that's the right syntax for that...
17:20:52 <EvilMachine> MyCatVerbs: Isn’t that planned for version 10.0? :P
17:21:07 <MyCatVerbs> EvilMachine: no, twelve.
17:21:34 <EvilMachine> oh man, can’t wait that long. going to hibernation again.
17:21:53 <monochrom> ghc 12 will write your code for you.
17:22:28 <MyCatVerbs> Orclev: The problem is that making instances like ((Num a) => Zero a) play nicely with _other_ instances is actually really, really hard to implement in a way that isn't going to cause the compiler to go into infinite loops trying to resolve all the types in some programs.
17:23:18 <MyCatVerbs> Even if you did implement it without infinite loops, it would quite likely be really, really easy to write programs that had exponential compile times that way - purely by mistake.
17:23:54 <Orclev> MyCatVerbs: I guess the workaround is to do something like instance Zero Int, instance Zero Integer, instance Zero Float, etc...
17:24:09 <Orclev> MyCatVerbs: and then just cut and paste the body of all of them... even though that's nasty
17:24:18 <MyCatVerbs> Ewwww. The best workaround is with the newtype. :)
17:24:25 <aavogt> Orclev: template haskell!
17:24:34 <MyCatVerbs> Or, yeah, that.
17:24:52 <Orclev> aavogt: I looked at that a while back, but I don't remember much about it now... guess it's time to go find it again
17:25:32 <EvilMachine> template haskell == automated copypasta?
17:26:11 <SubStack> if only
17:26:35 <aavogt> EvilMachine: yes, but you'll still have to write something like:   $(mapM makeBoringInstance [''Int,''Integer,''BlahTypes .... ] )
17:26:35 <EvilMachine> what’s worse than automated copypasta??
17:26:54 <EvilMachine> aavogt: bah, that's easy to automate too. ^^
17:27:17 <aavogt> EvilMachine: I don't see how....
17:27:34 <aavogt> please explain
17:27:54 <EvilMachine> aavogt: wait for someone to generate haskell code with running a template trough a bash-script and then compiling it with template haskell. :P
17:28:20 <idnar> don't forget to add a perl postprocessing step
17:28:46 <aavogt> well, the point is that at some point you still have to name the types for which you want those instances ... right?
17:28:47 <harrison> that reminds me: i sometimes find myself using macros to write templates in order to make c++ bearable.
17:28:47 <EvilMachine> (i am not responsible for lost hairs and sleepless nights, caused by trying to think about that!) ^^
17:29:22 <EvilMachine> harrison: plain c++? bearable? nope. must be an illusion. :P
17:30:24 <harrison> EvilMachine: well, more bearable than c++ without macros and templates. and more bearable than java.
17:30:41 <EvilMachine> harrison: if you want to hurt yourself, do it the right way, and try malbolge: http://99-bottles-of-beer.net/language-malbolge-995.html
17:32:57 <harrison> i think i'll pass. but yeah, c++ is something i use when i have to, rather than by choice.
17:33:51 <EvilMachine> harrison: it’s really sad that you can’t be in the game development industry without it.
17:34:02 <dancor> start a new company
17:34:28 <djahandarie> Haskell-driven game development!
17:34:32 <EvilMachine> yeah. i did that. but where does the money come from? you work 2-5 years on a new game.
17:34:41 <Orclev> EvilMachine: if you could do game development without C++ I'd already be doing it... not that you can't make a game without using C++, just really really hard to find someone who will pay you to do so
17:34:52 <dancor> vc
17:34:52 <EvilMachine> exactly
17:35:22 <djahandarie> Bah, money, who needs it anyways?
17:35:31 * Orclev raises his hand
17:35:32 <EvilMachine> the only thing bearable was java on phones.
17:35:36 <EvilMachine> lol
17:35:58 <dancor> i think i would personally be able to make a perf-acceptable game in c++ faster than i could in hs :(
17:36:00 <monochrom> give me all your money now
17:36:06 <harrison> java is bearable on phones? as in, it's not as bad as java on other things?
17:36:56 <Orclev> the key to making java bearable is having the right tools that do all the boilerplate for you... auto-complete is a must have
17:37:13 <monochrom> <3 Java, best language ever
17:37:58 <EvilMachine> well, if you have a really great game project, and you ask EA, they will put 10-15 million euro on the table, and tell you to start right now. i have contacts and got offered something like that, if i would make a really great, compelling presentation. problem is: you lose all the rights. you are lucky if you don’t have to buy the game in a store yourself, to rightfully have it!
17:38:06 <EvilMachine> monochrom: lol. rather not.
17:38:28 <EvilMachine> monochrom: Java. The FactoryFactoryFactoryFactoryFactoryFactoryFactoryBuilderBuilder.
17:39:09 <EvilMachine> and the best thing was: the guys who had worked for EA were alcoholics because of what happened in that time! that’s how bad it’s to work for them.
17:39:14 <harrison> java is about 90% boilerplate, so that autocomplete has its work cut out for it, i guess.
17:39:40 <Orclev> EvilMachine: lol, I've been waying up whether or not I'd accept a job at EA working on some Tiger Woods game... I'd really rather not because you know, it's EA... but on the other hand it's a paying job
17:39:45 <EvilMachine> you could use haskell or whatever you like if you get those 10 millions. but  I’d rather die than work for them!
17:40:16 <EvilMachine> do you know Bullfrog? those who did Magic Carpet and Syndicate?
17:40:57 <Orclev> EvilMachine: no, never heard of them... although that's not surprising, there's a ton of really talented game companies out there that I've never heard of
17:41:19 <EvilMachine> Bullfrog were really great. I recommend knowing them. :D anyway…
17:41:24 <EvilMachine> they got bought by EA, and right after that, they ALL left the company. because it was so bad to work at EA.
17:41:35 <EvilMachine> they founded a new company, and that one got bought too. again 60% left on the spot.
17:42:20 <aavogt> > sum (take 1000 $ iterate (0.6*) 1)
17:42:21 <lambdabot>   2.5000000000000004
17:42:26 <Orclev> yeah, I really don't like EA, I've never heard anything good about them
17:43:08 <EvilMachine> the wives of the EA developers sued EA, because their men did not come home anymore. because the rule was, to work on weekends, and every day to 8 pm. with no holidays. if you asked to leave for a day, they told you you did’t need to come back.
17:43:55 <idnar> after doing that for a few months, surely your productivity is basically zero anyway?
17:44:10 <Orclev> EvilMachine: I remember the lawsuits and such from that... that was I think about 2 or 3 years ago that happened... of course there's also a bunch of different divisions with EA so results will vary
17:44:16 <EvilMachine> if you want to *start* doing games, there’s no better thing right now, than to go for mobile devices. it’s not that demanding *yet*.
17:44:35 <Orclev> idnar: they were basically taking advantage of fresh college graduates... higher them for low pay, run them till they drop, then fire them and get a new batch
17:44:42 <EvilMachine> Orclev: yes. here in germany, they only do translations anyway. ^^
17:44:52 <idnar> Orclev: oh, so replace them every few months? :P
17:44:58 <Orclev> idnar: yeah
17:45:00 <EvilMachine> idnar: i guess so
17:45:05 <EvilMachine> lol
17:45:09 <idnar> I guess that "works"
17:45:17 <idnar> continuity must be a bitch, though
17:45:19 <EvilMachine> well, they weren’t called “code monkeys” for nothing
17:45:20 <blackh> Orclev: "Constructive dismissal" that's called
17:46:13 <idnar> haha
17:46:24 <EvilMachine> do you know how Gulags worked? humans were a resource to them, that got used up, and then thrown away, and replaced by fresh resources. sounds familiar?
17:47:16 <Orclev> from what I understand of the game programming industry, code re-use is pretty much non-existant with the exception of game engines, so it doesn't matter if it's the most horendous code you've ever seen so long as it meets the requirements and the bugs are minimal enough to ship it
17:47:42 <EvilMachine> well, we’ll start a new generation of Haskell-based game studios… right?… right? *hopes*
17:47:56 <Orclev> that would be cool... but highly unlikely
17:48:30 <monochrom> One Shakespears cannot compete with 40 monkeys.
17:48:33 <EvilMachine> Orclev: throwaway code? ho hell yeah! the craziest things you have ever seen!
17:48:48 <EvilMachine> monochrom: only 50?
17:48:52 <EvilMachine> monochrom: only 40?
17:48:57 <monochrom> Yeah.
17:49:07 <harrison> i'll probably make some games in haskell. need to get to know the language better, though.
17:49:17 <blackdog> monochrom: that can't be the tradeoff in terms of cost.
17:49:21 <EvilMachine> Orclev: i don’t think so. at least if GHC can compile for ARM. ^^
17:49:34 <ubuntu-nathan> some admin of the haskell wiki is online?
17:49:36 <blackdog> even a top programmer won't earn more than 4 or 5 times the minimum programmer wage, surely?
17:50:15 <hackagebot> bindings-common 1.3.1 - Preprocessor combinator library for low level FFI. (MauricioAntunes)
17:50:20 <Orclev> EvilMachine: thinking about games for iPhones/Android/<Generic Mobile Phone>?
17:50:22 <monochrom> Here is one way. One Shakespears alone has horrendous "time to market".
17:50:25 <EvilMachine> blackdog: with his own company, everything is possible. (including bankrupcy ^^)
17:50:59 <EvilMachine> Orclev: on Symbian primarly. never iPhone or other locked-in phones. ^^
17:51:21 <EvilMachine> but i noticed that many game developers have a secret love for Haskell.
17:52:03 <Orclev> EvilMachine: iPhone is only partially locked in... if you jailbreak it you can do development using open tools, and the API is open source even if it's not exactly "free"
17:52:29 <EvilMachine> Orclev: i tried a bit of Java on phones (J2ME 2.x). but it’s way too slow for what I want to do. even with the hardware-accelerated parts.
17:52:51 <EvilMachine> Orclev: yeah, but who is going to play those games that only run on jailbroken phones? ^^
17:52:56 <harrison> EvilMachine:  perhaps it's because they deal with silly things like mutable state so often.
17:52:56 <blackdog> EvilMachine: sure, your own company is a different issue. but then you're not just a programmer, you're a businessman too.
17:53:09 <EvilMachine> harrison: who?
17:53:15 <hackagebot> bindings-gsl 0.0.1 - Low level bindings to GNU GSL. (MauricioAntunes)
17:53:42 <Orclev> EvilMachine: well, to start with, people that have jailbroken their phone... but the real answer is that once you get done developing it, you fork over the $100 to Apple and put the game on the real app store
17:54:07 <harrison> EvilMachine: game developers. the ones with a secret love for haskell get tired of all those darn statements in their usual languages.
17:54:33 <dancor> @hoogle everywhereM
17:54:33 <lambdabot> Data.Generics.Schemes everywhereM :: Monad m => GenericM m -> GenericM m
17:54:34 <EvilMachine> blackdog: i did “outsource” the business part. i know, a unusual way, but it can work. unfortunately it does not work if you 3 “business partners” 1. run away on a strange island, 2. go broke, and 3. go to jail for massive tax evasion! :(((
17:54:43 <dancor> where does that live in base >= 4?
17:54:54 <EvilMachine> harrison: yup. :D
17:55:23 <Orclev> speaking of game developers, why is it that everybody and their brother is suddenly trying to use Lua for scripting? I know WoW uses it... but really, Lua isn't a particularly nice language so I'm not seeing the attraction
17:55:28 <blackdog> EvilMachine: well, exactly. if a process can't be reliably outsourced, it would seem to be part of your core business...
17:55:43 <blackdog> Orclev: really easy C integration, i imagine
17:55:43 <EvilMachine> Orclev: monkey see, monkey do?
17:56:01 <blackdog> am just taking over a Lua codebase atm. not horrible, but nothing terribly innovative either.
17:56:10 <monochrom> I think it's because WoW uses it.
17:56:10 <Orclev> blackdog: everything can be outsourced, it's more a question of if you can do it cost effectively
17:56:10 <EvilMachine> Orclev: for scripting, i find Python rather nice. especially since it takes parts from Haskell.  :D
17:56:42 <EvilMachine> blackdog: so i find a reliable person.
17:56:49 <blackdog> Orclev: no, i disagree. and it's not about cost.
17:57:08 <blackdog> anything that starts with "outsource to a reliable person" is doomed to failure
17:57:38 <monochrom> C started out exactly the same way. When fortran and cobol ruled the planet, programmers whispered to each other, "unix is written in C!" Then C won.
17:57:44 <EvilMachine> blackdog: lol. well, *everything* is rather broad. let’s use “very unlikely”.
17:58:06 <EvilMachine> monochrom: so we need a killer app in Haskell!
17:58:08 <blackdog> EvilMachine: i'm trying to draw a distinction here between outsourcing and bringing in a new person
17:58:17 <monochrom> No, I'm saying it is all hopeless.
17:58:20 <EvilMachine> monochrom: a big commercial game engine would be such a kille rapp
17:58:44 <monochrom> Adoption is caused by social interaction, not technical merit.
17:58:58 <Orclev> things I've been impressed with in Haskell so far (being a huge haskell newb): XMonad, GPipe
17:59:06 <blackdog> things that can be assessed easily after the fact are good candidates for outsourcing. things like business direction, marketing, customer discovery are core for just about every business
17:59:09 * EvilTerran was beeped <.<
17:59:14 * EvilTerran is not EvilMachine >.>
17:59:40 <blackdog> time for an Evil-Off
17:59:54 <blackdog> there can be only (Succ Zero)
18:00:05 <Orclev> blackdog: I've seen marketing outsourced fairly regularly... kind of the idea behind all those marketing firms
18:00:50 <EvilMachine> blackdog: ah, ok. well, i don’t draw a distinction there, because what I do is neither. it’s a bit of a different model., imagine one company, but everyone has his own budget, can hire people for projects, and have as many “bosses” as he likes. so more freedom. but still the ability to create more stable ties. like contractors in one company, but better. with a managing software and no ”managers” per se, other than 
18:01:12 <blackdog> Orclev: you have to decide your marketing direction, though. the marketing firms can help you out once you have that
18:01:15 <idnar> Orclev: Lua is really easy to embed
18:01:27 <idnar> and it has a pretty small footprint
18:01:43 <idnar> the downside is that the community is entirely fractured; basically everyone runs around with their own modified version of Lua
18:01:46 <EvilMachine> yeah, XMonad is pretty cool. but how many people are actually interested in tiling X window managers? :(
18:01:48 <idnar> and doesn't contribute stuff back much
18:01:50 <SamB_XP> idnar: isn't that it's raisen de etre ?
18:01:59 <Orclev> also, I think business direction is too nebulous a concept to be something outsourced or "core"... it's not a distinct item in and of itself but more of a gestalt of the entire operation of the business
18:02:05 <SamB_XP> note that I spell french even better than I spell english!
18:02:25 <idnar> raisin de eater!
18:02:37 <SamB_XP> hehe
18:02:48 <SamB_XP> raisin no eater!
18:02:52 <Orclev> EvilMachine: however many people use XMonad + Ion + the other 4 or 5 tiling window managers I can't recall right now
18:03:03 <EvilMachine> SamB_XP: the raisins de ether? ^^
18:03:59 <SamB_XP> (that, if I'm not mistaken, is japanese for "eater of raisin(s)")
18:04:02 <Orclev> etherial raisins?
18:04:30 <Orclev> would that maybe be a grape poultergeist?
18:04:41 <EvilMachine> Orclev: well, I meant the level that makes joe sixpack want that Haskell app. so that it becomes a big market. we need something that is simply not doable in other languages, without massive hacks.
18:04:41 <blackdog> EvilMachine: ah, fair enough. yeah, my idea of outsourcing is more hands-off. something in between that and stable co-workers could be workable
18:04:58 <EvilMachine> massive parallel programming is a big chance for haskell.
18:05:11 <blackdog> EvilMachine: what're we gonna use all that speed for?
18:05:16 <Orclev> EvilMachine: yeah, I wasn't saying those are killer apps, but rather the things I've seen in haskell as a "end user" that I was most impressed with so far
18:05:23 <blackdog> scientific computation, sure
18:05:28 <blackdog> but what needs to be that fast?
18:05:42 <Orclev> EvilMachine: massive parallel programmings is too much of a niche market
18:05:53 <blackdog> (not an idle question - i've been looking for a similar killer app for Hubris, and haven't come up with anything that would be really helpful on a web app)
18:06:19 <SamB_XP> Raison d'être
18:06:36 <SamB_XP> @all-dict "Raison d'être"
18:06:38 <lambdabot> No match for ""Raison d'être"".
18:06:43 <SamB_XP> @all-dict Raison d'être
18:06:44 <lambdabot> No match for "Raison".
18:06:44 <lambdabot> No match for "d'être".
18:06:48 <SamB_XP> aww
18:07:22 <EvilMachine> blackdog: that’s what people always say: what do we need gigabytes of ram, and a million teraherz-cpus for? well, the answer is always: we will find something. we always do! :D and if there’s nothing left, we can always simulate a small universe, just to play a game in it!  :P
18:07:43 <SamB_XP> http://en.wiktionary.org/wiki/raison_d%27%AAtre
18:07:49 <SamB_XP> oops ...
18:08:00 <EvilMachine> http://en.wikipedia.org/wiki/Raison_d%27%C3%AAtre
18:08:04 <aavogt> preflex: seen lambdabot
18:08:05 <preflex>  lambdabot was last seen on #haskell 1 minute and 20 seconds ago, saying: No match for "d'être".
18:08:37 <blackdog> EvilMachine: sure. but don't misunderstand my question: I'm not saying 640k is enough for everyone
18:08:52 <blackdog> i'm trying to explore what we can throw all this speed at
18:08:58 <EvilMachine> ah, ok
18:09:00 <SamB_XP> http://en.wiktionary.org/wiki/raison_d'être
18:09:20 <blackdog> it's really easy as a hacker to get fixated on speed
18:09:35 <EvilMachine> blackdog: games still have a big bunch of physics and artificial intelligence that could be much better.
18:09:37 <Orclev> ... Boolean-0.0.0?... shouldn't there at least be a 1 in there somewhere?
18:09:38 <blackdog> but sometimes you've gotta pull back and work out what you're actually aiming it at
18:10:06 <blackdog> EvilMachine: depends how much of a selling point it is, really.
18:10:17 <EvilMachine> Orclev: 0 is the programmer’s 1, isn’t it?
18:10:31 <EvilMachine> blackdog: agreed
18:10:46 <harrison> i'm really looking forward to all this data-parallel stuff. like opencl on gpus and larrabee. what springs to mind for me is ray tracing and fluid simulations.
18:10:47 <SamB_XP> EvilMachine: it is traditional to use a "1" in the last component of the version number
18:10:56 <SamB_XP> for the first version
18:10:58 <blackdog> the successful games seem to be either franchises like Madden or Halo, where the brand is more important than anything, or quirky games like Portal or Braid or Katamari where the real selling point is game design creativity, not hacking smarts.
18:11:06 <SamB_XP> or possibly the second-to-last component
18:11:19 <Orclev> blackdog: in the general sense, if you can get enough speed you can sometimes make up for shortcomings elsewhere, you just optimize for space rather than time
18:12:22 <EvilMachine> SamB_XP: it’s also traditional, to make space shuttle booster rockets in a size that fits trough railway tunnels, which have that size because the rail tracks were made by the builders of horse carriages. and the size was chosen because it fits around two asses of horses or oxen. but that does not mean it’s any great. ^^
18:12:32 <Orclev> blackdog: there's also a good market for games that redo a mechanic from a previous game that hasn't been used in a while... E.G. the recent Shadow Complex game on XBox Arcade that was very much a clone of the Super Metroid
18:13:07 <SamB_XP> EvilMachine: hehehe
18:15:08 <Orclev> EvilMachine: that whole thing reminds me of the Windows
18:15:39 <EvilMachine> blackdog: most people are rather simple, live very passive, run after fads and what others say is great. i don’t want to judge it. i think it can be good or bad for you. because you can also be the one that they listen to. so whatever you do, like for example a haskell game… get the masses behind it. the keywords are: psychology and leadership. i’m not planning on reading books about leadership, interrogation  and rethori
18:15:40 <Orclev> gah, I keep putting extra the's in for no good reason...
18:17:28 * EvilMachine confesses, that he’d like to be an evil overlord. but even more, to be a good overlord. :P
18:18:23 <Orclev> I'm pretty sure that overlord and good are incompatible concepts
18:18:36 <ivanm> EvilMachine: it'd be easier just to replace "Machine" with "Overlord" than to do a complete replacement of your nick
18:18:37 <ivanm> ;-)
18:18:51 <ivanm> Orclev: not really
18:19:03 <ivanm> "Overlord" is the lord that's in charge of all the other lords...
18:19:11 <EvilMachine> Orclev: nah. why would they? a leader that people *want* to be their leader, still is a leader. :)
18:19:14 <raz1146> If Someone using OVI Suite And Content Copier PLEASE PME ! Thanks alot .
18:20:27 <EvilMachine> ivanm: well, i would have to add some special unicode chars like this one: ☢
18:20:39 <EvilMachine> ivanm: but the server does not like that char
18:20:57 <ivanm> heh
18:21:53 <dancor> @eois 1 2 4 8 7
18:21:54 <lambdabot> Maybe you meant: docs join oeis
18:21:58 <dancor> @oeis 1 2 4 8 7
18:21:58 <lambdabot>  Pitoun's sequence: a(n+1) is digital root of a(0)+...+a(n).
18:21:58 <lambdabot>  [1,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1...
18:22:39 <ivanm> "digital root"?
18:22:56 <EvilMachine> what? lambdabot can be persuaded with being stubborn? lol!
18:23:20 <ivanm> EvilMachine: ummmm, dancor used the right plugin the second time...
18:23:29 <ivanm> eois vs oeis
18:23:43 <EvilMachine> ah, ok, i did not see the swap of characters
18:23:46 <EvilMachine> :(
18:23:58 <dancor> a Machine would have!
18:24:09 * EvilMachine is disillusioned
18:24:30 <Cale> ivanm: I believe digital root = congruence class modulo 9
18:24:52 <ivanm> dancor: yeah, what kind of machine is EvilMachine....
18:25:01 <ivanm> Cale: right, of _course_ that makes sense :s
18:25:07 <EvilMachine> an evil one, of course
18:25:12 <Cale> (because it's what you get when you add the digits of the number repeatedly until arriving at a number which is less than 10)
18:25:13 <ivanm> I can see where you'd get that from; it's the name that's weird
18:25:27 <ivanm> oh, right, traditional meaning of digits, etc. rather than computer meaning
18:25:38 * EvilMachine = the type of machine, Cthulhu would use. :P
18:25:55 <Orclev> so I'm looking at the GPipe package, and I'm trying to figure out the advantage to using Vec for more or less everything... is passing in (100:.100:.()) instead of (100,100) for a windows dimensions really advantageous in some way? What am I missing?
18:26:00 <Cale> http://www.youtube.com/watch?v=Otbe5c2OIxI -- offtopic, music :)
18:26:32 <Orclev> nah, Cthulhu would use a non-euclidean machine
18:26:45 <EvilMachine> Orclev: I AM non-euclidean! :P
18:26:46 <dancor> well the binary digital sum is mod 2, wonder what that one looks like
18:26:47 <ivanm> Cale: http://www.youtube.com/watch?v=jYyBZE0kBtE
18:27:12 <SamB_XP> EvilMachine: what type of geometry are you?
18:27:18 <dancor> base-10 number theory is a strange hobby
18:27:45 <dancor> err or is it mod 1?
18:27:52 <EvilMachine> SamB_XP: one that lets the universe throw exceptions, even when it’s written in Haskell.
18:28:36 * EvilMachine tries to stay on topic by any means possible. ;)
18:29:47 <Orclev> EvilMachine: oblig xkcd: http://xkcd.com/224/
18:30:19 <EvilMachine> /me’s head explodes: ♨ = HOT SPRINGS (0x2668)
18:30:24 * EvilMachine ’s head explodes: ♨ = HOT SPRINGS (0x2668)
18:30:30 <EvilMachine> damnit
18:30:58 <EvilMachine> :D
18:30:59 <ivanm> heh
18:31:11 <ivanm> EvilMachine: I'm amazed your client let that go through though...
18:31:18 <dancor> ghci's history clears at the drop of a hat..
18:31:22 <ivanm> xchat complains if it's a /foo command that it doesn't recognise
18:31:30 <ivanm> dancor: does it? I thought it recorded it...
18:31:46 <ivanm> in .ghc/ghci_history
18:32:02 <ivanm> admittedly, I mainly use it from within emacs, so there's no realy history to worry about... >_>
18:32:09 * EvilMachine fears to get beaten up, if he mentions his IRC client. :P
18:32:24 <SamB_XP> EvilMachine: you use mIRC?
18:32:41 <Orclev> I've found the ghci history to be very robust... I've even had ghci seg-fault before and when I restarted it it still had the complete history
18:32:47 <EvilMachine> SamB_XP: no.uum…*whispers*… Kopete. ^^
18:33:08 <dancor> i haven't isolated the cause of my random history clears
18:33:12 <SamB_XP> EvilMachine: why would you get beaten up for using an IRC client that is not only not infamous, but practically unheard of?
18:33:54 <lispy> hi
18:34:05 <dancor> > let s = 1:[sum (take n s) `mod` 9|n <- [1..]] in take 40 s
18:34:06 <lambdabot>   [1,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,...
18:34:08 <EvilMachine> SamB_XP: because it’s actuall an instant messenger (KDE default one)
18:34:14 <EvilMachine> +y
18:34:16 <dancor> > let s = 1:[sum (take n s) `mod` 2|n <- [1..]] in take 40 s
18:34:17 <lambdabot>   [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:35:48 <byorgey> hi lispy!
18:36:02 <Orclev> I never did get a response... does anyone know why GPipe uses Vec for everything?
18:36:28 <dancor> @hoogle powMod
18:36:28 <lambdabot> No results found
18:36:42 <lispy> byorgey: I saw your call for content!
18:36:43 <byorgey> Orclev: probably because no one knows.  who wrote it?
18:36:51 <byorgey> lispy: excellent! =)
18:36:59 <dancor> is there an existing fast a^b mod c for large numbers?
18:37:05 <byorgey> lispy: so, are you going to write some? ;-)
18:37:32 <Orclev> byorgey: author is listed as Tobias Bexelius... I was just wondering if there's some advantage to using Vec over Tuple I wasn't aware of
18:37:38 <lispy> byorgey: are you planning a GSoC issue?
18:37:55 <byorgey> lispy: Wouter was planning to do a GSoC issue, but only got one submission =(
18:38:02 <dancor> > take 40 $ map (\ n -> 2^n `mod` 9) [0..]
18:38:03 <lambdabot>   [1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,2,4,8,7,5,1,...
18:38:11 <byorgey> lispy: so that submission will be in the January issue
18:38:44 <lispy> byorgey: on a new keyboard and its hard to type, so expect delays :)
18:39:00 <lispy> byorgey: oh...
18:39:09 <byorgey> lispy: hehe, is it shaped all weird and ergonomic-like?
18:39:15 <lispy> byorgey: Nothing from Petr?
18:39:35 <lispy> byorgey: yes kinesis
18:39:35 <byorgey> lispy: nope, the one submission was from Gergely Patai about his profiling tools
18:39:41 <byorgey> ooooooo kinesis
18:39:44 <lispy> byorgey: oh
18:39:52 <lispy> byorgey: hp2any?
18:40:29 <byorgey> is that what it was called, I don't remember.
18:40:43 <EvilMachine> lispy: oh, nice! :D I wish I could get a set of “DataHand Pro II”s thought :)
18:40:48 <lispy> it's actually dons keyboard, so shhh ;)
18:40:49 <Orclev> lispy: if it's like the ones shown on their website, that's a seriously wierd keyboard
18:40:50 <EvilMachine> -t
18:40:57 <Veinor> I want to define the △ and ▼ operators
18:41:05 <byorgey> hahaha
18:41:18 <EvilMachine> Veinor: what stops you?
18:41:18 <Veinor> But what would they do
18:41:19 <byorgey> lispy: ah, yes, hp2any
18:41:26 <Veinor> THe lack of a workable definition.
18:41:37 <lispy> (he said I could borrow it though)
18:41:51 <EvilMachine> Veinor: lol, ▼ could be a decrement.
18:42:05 <lispy> byorgey: cool.  I tried hp2any and it failed to start
18:42:19 <lispy> byorgey: so i'd like to learn more
18:42:19 <Veinor> Haha
18:42:28 <Veinor> can you define postfixes?
18:42:31 <EvilMachine> Veinor: you could redefine fail as a skull with crossbones instead. :D
18:42:39 <Veinor> :D
18:42:47 <EvilMachine> Veinor: i did
18:42:58 <lispy> EvilMachine: hehe
18:43:05 <Veinor> ▧
18:44:06 <EvilMachine>  Hmm… can you define postfixes?
18:44:13 <lispy> byorgey: i'll pester petr
18:44:15 <EvilMachine> don’t think so
18:44:32 <aavogt> @hoogle String -> Html
18:44:32 <lambdabot> Text.Html afile :: String -> Html
18:44:32 <lambdabot> Text.Html clickmap :: String -> Html
18:44:32 <lambdabot> Text.Html itag :: String -> Html
18:44:37 <Saizan> > let (!) n = product [1..n] in (5!)
18:44:37 <lambdabot>   120
18:44:45 <Veinor> Heh.
18:44:52 <Saizan> they work only as sections
18:44:53 <EvilMachine> oh, yeah
18:45:04 <Veinor> let (▼) n = n - 1 in (5▼)
18:45:08 <lispy> byorgey: i'd like to see more darcs related articles and Petr's work only seems natural
18:45:09 <Veinor> whoops
18:45:11 <Veinor> > let (▼) n = n - 1 in (5▼)
18:45:12 <lambdabot>   4
18:45:14 <Veinor> :D
18:45:23 <byorgey> lispy: indeed.  pestering appreciated.
18:45:36 <byorgey> I might pester some of the GSoC participants as well.
18:47:36 <EvilMachine> aah, i love it! my pure haskell synth threw out its first melody! in sawtooth and sine C cords! next i’ll create modulation filters.
18:47:38 <lispy> byorgey: should I CC you on your gmail or upenn address?
18:47:45 <ivanm> byorgey: if it's not accepted by PEPM, would you want an (edited) version of my paper on SOurceGraph, so that I didn't completely waste my time?
18:48:34 <lispy> ivanm: oh!  I want!
18:48:43 <Veinor> > let (▼) n = "biological rights" in (5▼)
18:48:44 <lambdabot>   "biological rights"
18:48:47 <Veinor> tee hee
18:48:55 <ivanm> lispy: the draft is up if you want it... code.haskell.org/~ivanm/
18:49:17 <lispy> ivanm: tankss
18:49:36 <SmurfOR> Anyone know if what i'm trying to do here (http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4374#a4374) is legal?  GHCI throws a parse error on the second { in that datatype.
18:49:40 * ivanm still hasn't looked at why darcs source didn't work though
18:49:54 <ivanm> lispy: I forget, when running it on darcs did the report get generated or not?
18:50:01 <Cale> SmurfOR: You forgot to write a data constructor.
18:50:27 <SmurfOR> Cale, so what you're saying is i need to repeat JValue for each one of those then?
18:50:36 <lispy> ivanm: no sir, too many bugs in dot
18:50:39 <Cale> SmurfOR: It can't be JValue for the second one, since you already used that
18:50:56 <byorgey> ivanm: I would be honored.
18:50:58 <ivanm> lispy: yeah
18:51:03 <ivanm> byorgey: heh, not sure if it's _that_ good
18:51:11 <byorgey> ivanm: but I do hope it's accepted by PEPM!
18:51:14 <Cale> SmurfOR: Each of the cases has to use a different data constructor (it's what distinguishes them!) and it can't be the name of a value which is already in scope.
18:51:17 <ivanm> anyway, I'll find out if it's accepted by the 26th apaprently
18:51:23 <ivanm> byorgey: so do I... free trip to spain! :p
18:51:29 <byorgey> =D
18:51:36 <SmurfOR> Cale, thanks :)
18:52:47 <EvilMachine> hmm, leksah lacks a way to get the type of a selection in yout code…
18:53:44 <byorgey> lispy: as for which address to use... I don't know, the gmail one I guess.
18:53:58 <lispy> byorgey: k
18:54:19 <byorgey> lispy: I use the upenn address for school/academic stuff and gmail for other stuff, but this is sort of borderline.
18:54:49 <EvilMachine> > let m = (let l = m in l) in m
18:54:53 <lambdabot>   mueval-core: Time limit exceeded
18:55:00 <EvilMachine> :(
18:55:09 <byorgey> is my participation in the Haskell community academic, or a hobby?  well... both. =)
18:55:42 <medfly> are you asking yourself questions and answering them?
18:55:52 * medfly looks up
18:55:54 <lispy> byorgey: ah
18:55:59 <monochrom> Am I asking? Yes I am.
18:56:17 <byorgey> medfly: Am I?  I guess so.
18:56:22 <medfly> :))
18:57:09 * EvilMachine is not referring to EvilMachine in the first person :P
18:57:19 <Cale> I'm not.
18:57:35 <monochrom> monochrom: are you monochrom?
18:57:52 <SamB_XP> monochrom: figure it out yourself!
18:57:57 <SamB_XP> (idoit!)
18:58:08 <EvilMachine> Help! I’m stuck in a dark box, with a strange translucent cat! I am and I’m not!
18:58:35 <EvilMachine> monochrom: if yo take drugs, do you become colored?
18:58:44 * byorgey runs unsafeOpenBox on EvilMachine 
18:59:03 <byorgey> the cat dies, twice.
18:59:08 * EvilMachine blasts out in a gamma ray burst, wiping half the solar system!
18:59:38 <monochrom> (in half of the timelines)
18:59:39 <EvilMachine> that was very unsafe to open that box. ^^
19:02:51 <Orclev> remember, if you find a closed back that's impervious to any form of em radiation don't open it... wait long enough and it eventually collapses to a stable state anyway
19:02:58 <Orclev> s/back/box/
19:05:45 <EvilMachine> uum, why does GHC complain in "runGet (getFloat32le) (B.readFile ("data/"++name++".pcm"))", that "Float" does not match "m a"? the types are fitting as far as I can see…
19:05:47 <Jagwire> So I have a question about using datatypes, specifically lists...
19:06:10 <Cale> Jagwire: It will never be answered if you don't ask it ;)
19:06:17 <Jagwire> say you have x =["a", "b", "c"]
19:06:52 <Jagwire> is it legal to then use x "a"?
19:07:04 <Jagwire> or say inside of a list [x "a"]
19:07:12 <EvilMachine> what would x "a" do?
19:07:12 <SamB_XP> .... noooooo
19:07:27 <byorgey> Jagwire: what are you trying to accomplish?
19:07:30 <aavogt> > let x =["a", "b", "c"] in "d" : x
19:07:31 <lambdabot>   ["d","a","b","c"]
19:07:39 <EvilMachine> maybe you mean x!!!"a" or what was the operator for that?
19:07:53 <aavogt> > let x =["a", "b", "c"] in x!!2
19:07:54 <lambdabot>   "c"
19:08:14 <byorgey> EvilMachine: I don't know what you mean.
19:08:15 <Cale> EvilMachine: you mean findIndex or something?
19:08:16 <EvilMachine>  > let x =["a", "b", "c"] in x!!!"b"
19:08:29 <Cale> > let x = ["a", "b", "c"] in x !! 2
19:08:30 <lambdabot>   "c"
19:08:31 <aavogt> > let x =["a", "b", "c"] in [x, ["a"]]
19:08:32 <lambdabot>   [["a","b","c"],["a"]]
19:08:36 <Cale> > let x = ["a", "b", "c"] in findIndex "c"
19:08:37 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:08:37 <lambdabot>         against inferred ...
19:08:39 <Cale> > let x = ["a", "b", "c"] in findIndex x "c"
19:08:39 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:08:40 <lambdabot>         against inferred ...
19:08:40 <byorgey> EvilMachine: less space before >
19:08:42 <Cale> > let x = ["a", "b", "c"] in findIndex "c" x
19:08:43 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:08:43 <lambdabot>         against inferred ...
19:08:44 <Cale> hmm
19:08:46 <Cale> oh, right
19:08:49 <Cale> elemIndex :)
19:08:51 <ddarius> It expects a predicate.
19:08:54 * Jagwire scratches head
19:08:57 <Cale> :t elemIndex
19:08:58 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
19:08:59 <EvilMachine> i thought missingH had an operator to search in lists. somethingl like !!!
19:09:03 <Cale> > let x = ["a", "b", "c"] in elemIndex "c" x
19:09:04 <lambdabot>   Just 2
19:09:14 <Cale> > let x = ["a", "b", "c"] in elemIndex "b" x
19:09:15 <lambdabot>   Just 1
19:09:18 <Cale> > let x = ["a", "b", "c"] in elemIndex "z" x
19:09:19 <lambdabot>   Nothing
19:09:23 <byorgey> Jagwire: sorry if we're confusing you. =)  what are you trying to do?
19:09:28 <Jagwire> okay, perhaps let's ask a different question first
19:09:30 <EvilMachine> > let x = ["a", "b", "c"] in elem "a" x
19:09:31 <lambdabot>   True
19:09:33 <Jagwire> byorgey, homework :)
19:09:45 <Jagwire> :-->
19:09:46 <byorgey> Jagwire: =)
19:09:52 <Jagwire> That's an operator not a face :)
19:09:55 <Jagwire> :-->
19:10:08 <Jagwire> what is the meaning of ^^^
19:10:20 <byorgey> Jagwire: that's not in the standard libraries.
19:10:24 <EvilMachine> > let (!!!) = elem; x = ["a", "b", "c"] in "a" !!! x
19:10:25 <lambdabot>   True
19:10:26 <byorgey> looks like an infix data constructor.
19:10:27 <aavogt> @type extQ
19:10:28 <lambdabot> forall a q b. (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q
19:10:30 <Jagwire> hmph
19:10:44 <Jagwire> okay so riddle me this then
19:10:48 <byorgey> Jagwire: like there is some definition  data Foo a b = a :--> b  or something like that
19:10:49 <Jagwire> -- is a line comment right?
19:10:49 <EvilMachine> > let (!!!) l e = elem e l; x = ["a", "b", "c"] in x !!! "a"
19:10:50 <lambdabot>   True
19:11:18 <byorgey> Jagwire: yes, but not when immediately preceded by an operator character =)
19:11:42 <Jagwire> so -- is a comment but --> is not
19:11:42 <ddarius> or succeeded
19:11:53 <aavogt> @type extQ :: (Typeable a, Typeable b) => (a -> a) -> (b -> a) -> a -> a -- is this a sane use of extQ to use 'everywhere', when I want to generate lists from individual elements?
19:11:54 <lambdabot> forall a b. (Typeable b, Typeable a) => (a -> a) -> (b -> a) -> a -> a
19:11:55 <byorgey> right, or :--
19:12:14 <byorgey> > let a --> b = a + b in 4 --> 5
19:12:14 <lambdabot>   9
19:12:36 <Jagwire> mk
19:12:41 <aavogt> in effect I want to run concat at some level within my data
19:12:43 <Jagwire> so difference between --> and -> ?
19:12:55 <aavogt> a big difference
19:12:56 <Jagwire> I want to say I normally use -> in function type declarations
19:12:58 <byorgey> Jagwire: -> is built in syntax, it indicates a function type.
19:13:09 <byorgey> Jagwire: --> is not built in, you can define it to be whatever you like.
19:13:10 <Jagwire> gotcha.
19:13:12 <aavogt> > let a -> b = a + b in 1 -> 3
19:13:13 <lambdabot>   <no location info>: parse error on input `->'
19:14:10 <Jagwire> okay, so lets say:
19:14:16 <Orclev> > let (-->) = (+) in 1 --> 3
19:14:17 <lambdabot>   4
19:14:23 <Jagwire> data s = n String | t String
19:14:33 <Jagwire> data p = String :--> [s]
19:14:39 <EvilMachine> can anyone help me with this one? runGet (getFloat32le) (B.readFile "somefile") -- getFloat32le ::  Get Float; runGet :: Get a -> ByteString -> a; readFile :: FilePath -> IO ByteString -- yet it does not compile because Float is not "m a". i don’t understand what is what. what is supposed to be froat, and what is supposed to be "m a"?
19:14:42 <aavogt> you must capitalize s,n,t
19:14:43 <monochrom> use capital letters
19:15:03 <Jagwire> okay so: data S = N String | T String
19:15:06 <EvilMachine> s/froat/Float/
19:15:09 <Jagwire> data P String :--> [S]
19:15:31 <Saizan> the latter is not valid
19:15:33 <Jagwire> data P = String :--> [S]
19:15:36 <Jagwire> sorry :(
19:15:40 <Saizan> that's ok :)
19:15:52 <blackh> EvilMachine: You have to say ... bs <- B.readFile "somefile" ; let x = runGet (getFloat32le) bs
19:15:58 <Saizan> so :--> is defined there as the constructor for the P type
19:16:06 <byorgey> Jagwire: yup, that looks good
19:16:19 <monochrom> :->
19:16:23 <Jagwire> Saizan, can you explain :--> a little more ?
19:16:39 <EvilMachine> blackh:  ah, ok, THAT’s it! I had used runGet as if it were a monad
19:16:44 <Jagwire> to me it says, the production type is a string which is a list of symbols?
19:16:51 <byorgey> :--> is just like N or T, except it is infix
19:17:07 <byorgey> it is a 'constructor' for the P type
19:17:32 <monochrom> You could write "data P = Blah String [S]" but it is not cool.
19:17:40 <Jagwire> okay, what if it wasn't infix
19:17:43 <Jagwire> what would it look like
19:17:49 <Saizan> what monochrom said
19:17:59 <Orclev> data P = (:-->) String [S]
19:18:03 <lispy> > let (|->) n = 3 in (|->) 1
19:18:04 <lambdabot>   3
19:18:05 <Jagwire> huh.
19:18:42 <Saizan> so your P type is basically a pair
19:18:53 <Jagwire> okay
19:19:24 <Jagwire> like (String, [S]) ?
19:19:31 <Jagwire> just curried..
19:19:41 <Saizan> well, it's isomorphic to that
19:19:53 <Jagwire> isomorphic?
19:19:57 <Saizan> but you've to use the ":-->" constructor to build and take apart the values
19:20:16 <Saizan> isomorphic means that they contain the same information, basically
19:20:34 <lispy> same structure
19:20:37 <Saizan> (more precisely that there's a bijective function from one to the other)
19:20:43 <Jagwire> lol
19:21:06 <Jagwire> i think i'm going to become rich and famous when I write a book called "Haskell for those who speak english"
19:21:13 <Saizan> so, you can build a P like this: "Foo" :--> [T "bar",N "baz"]
19:21:33 <Orclev> I think, you'd need to do something like "first a :--> _ = a" to get the String out
19:21:46 <Saizan> first (a :--> _) = a
19:21:47 <aavogt> Jagwire: see learn you a haskell
19:21:54 <aavogt> @where lyah
19:21:55 <lambdabot> www.learnyouahaskell.com
19:21:59 <Orclev> oh yeah, I always forget the stupid parens
19:22:55 <lispy> with a ghc extension you can even have your (:-->) at the type level
19:23:23 <Orclev> second :: P -> [S]; second (_ :--> b) = b
19:23:23 <monochrom> It will only degenerate to "haskell for those who speak like english"
19:23:31 <lispy> (this would probably make arrows nicer)
19:23:59 <Jagwire> perhaps this is why they named the interpreter "hugs"
19:24:07 <Jagwire> I feel like I need one after doing this homework
19:24:24 <Orclev> Jagwire: I believe hugs is somewhat dated, ghc is preferred
19:24:34 <lispy> someone should make a decompiler named kisses
19:24:37 <Jagwire> hugs was recommended to us :(
19:24:39 <Jagwire> lol @ kisses
19:24:49 <Orclev> Jagwire: well, in that case go with it
19:24:54 <monochrom> Instructor grew up with hugs or gofer.
19:25:06 <Jagwire> sure?
19:25:07 <Orclev> gofer?
19:25:26 <monochrom> Part of Haskell came from gofer.
19:25:29 <Orclev> Jagwire: I'm a haskell beginner myself, so take anything I say with a grain of salt
19:25:35 <lispy> gofer was before haskell in a sense
19:26:05 <Saizan> wasn't gofer a spinoff to try out constructor classes?
19:26:13 <Jagwire> lol
19:26:42 <Jagwire> so to summarize everything about, would it be equivelant to saying something like: data P = :--> String [S] ?
19:26:55 <Saizan> no
19:27:13 <Saizan> but only because ":-->" is composed of symbols, so it must go infix
19:27:26 <Jagwire> ah, important safety tip
19:27:40 <Orclev> Jagwire: it would be equivalent if you could use :--> as a prefix
19:27:43 <Saizan> if you use something like "Production" instead than it's fine to make it prefix
19:27:52 <Jagwire> so likewise, if you wanted, you could never say: data P = + String [S]
19:28:00 <Saizan> yeah
19:28:05 <Jagwire> it would have to be: data P = String + [S]
19:28:12 <Saizan> and infix constructors must start with ":"
19:28:23 <Saizan> so it would be data P = String :+ [S]
19:28:25 <monochrom> data P = (:-->) String [S]
19:28:25 <Orclev> Jagwire: with the caveat that + is already used
19:28:33 <Jagwire> right, Orclev :)
19:29:02 <Jagwire> so the constructor is actually '-->' and not ':-->' ?
19:29:08 <Saizan> it is :-->
19:29:18 <Jagwire> but + is + and not :+
19:29:23 <Orclev> Jagwire: the point is, in order to use it as a constructor, it must start with :
19:29:42 <Jagwire> because it's infix.
19:29:47 <Saizan> in the "data P = String :+ [S]" you'd then use :+ in the other code when you refer to that constructor
19:29:54 <Orclev> if you tried to do "data P = String --> [S]" you'd get an error
19:29:59 <Saizan> "+" alone can only be used to define functions
19:30:00 <monochrom> constructor must start with either capital letter or :
19:30:21 <Jagwire> Got it.
19:30:21 <Saizan> just like prefix functions must start with a lowercase letter
19:30:22 <EvilMachine> oh great. the length function for ByteStrings returns an Int64. and replicateM only accepts Ints! Now if I downcast, it can’t read files above 2 GB, right?
19:31:04 <Saizan> EvilMachine: i wouldn't replicateM that much anyway!
19:31:05 <lispy> :t replicateM
19:31:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
19:31:15 <lispy> ?src replicateM
19:31:15 <lambdabot> replicateM n x = sequence (replicate n x)
19:31:23 <Saizan> EvilMachine: what's the monad here?
19:31:34 <lispy> EvilMachine: well, you could write replicateM so that it uses Integer
19:31:35 <Orclev> :t replicate
19:31:36 <lambdabot> forall a. Int -> a -> [a]
19:31:43 <lispy> ?src replicate
19:31:43 <lambdabot> replicate n x = take n (repeat x)
19:31:50 <lispy> :t take
19:31:51 <lambdabot> forall a. Int -> [a] -> [a]
19:31:55 <lispy> ?hoogle genericTake
19:31:55 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
19:32:20 <EvilMachine> Saizan: it’s in this snippet: runGet (replicateM (B.length bs) getFloat32le) (B.readFile "somefile")
19:32:35 <aeron> this is a dumb question about functional programming in general.. but how can i write a function to append an item to the end of a list, given only functions cons, head, and tail?
19:32:36 <EvilMachine> (which does not work)
19:32:39 <lispy> :t \n x -> sequence (genericTake n (repeat x))
19:32:40 <lambdabot> forall i (m :: * -> *) a. (Integral i, Monad m) => i -> m a -> m [a]
19:33:07 <lispy> EvilMachine: ^^
19:33:14 <EvilMachine> aeron: you can flip the list, witch is not a loss of performance because of how haskell does it.
19:33:57 <aeron> how would I do that just using head, tail, and cons?
19:33:57 <Saizan> aeron: you also need null
19:34:02 <Orclev> EvilMachine: that would be a function other than cons, head, and tail though... this sounds like a homework problem
19:34:03 <EvilMachine> lispy: i don’t understand what that does. ^^ should x be the getFloat32le and n the length here?
19:34:23 <aeron> Orclev: sort of - I've got a unit on FP coming up in the future and i'm looking ahead
19:34:28 <lispy> EvilMachine: it's just like replicateM except more generic
19:34:37 <lispy> EvilMachine: so, call it genericReplicateM
19:34:42 <EvilMachine> lispy: ah, nice. thx. :D
19:34:47 <Jagwire> hm, my HW makes 10x more sense now
19:34:58 <Saizan> EvilMachine: that's a quite inefficient way to parse that file btw.
19:35:01 <Jagwire> why the f didn't he tell explain to us :--> was a constructor :(
19:35:45 <EvilMachine> > head $ reverse [1,2,3]
19:35:46 <lambdabot>   3
19:35:55 <EvilMachine> aeron: :)
19:36:16 <monochrom> because he spoke Chinese and we speak English. Chinese is the language of the future.
19:36:41 <EvilMachine> Saizan: i know, what would you recommend? :)
19:37:03 <EvilMachine> Saizan: you know what they say: first get it running, then you can optimize.
19:37:16 <Saizan> just warned you :)
19:37:32 <Saizan> not sure what i'd actually recommend though
19:38:02 <Saizan> it depends on how large your files are, too
19:38:41 <EvilMachine> Saizan: well, they are Float32le PCM files.
19:38:47 <EvilMachine> raw pcm
19:39:28 <aeron> EvilMachine, I'm trying to figure out how to write a function which adds to the end of a list using just head, tail, and cons
19:39:59 <lispy> aeron: let's start with the type
19:40:17 <lispy> snoc :: ??
19:40:20 <Saizan> EvilMachine: don't they have some headers with the sizes?
19:40:34 <aeron> lispy: a -> [a] -> [a]?
19:40:48 <lispy> aeron: looks good
19:41:27 <EvilMachine> Saizan: no. raw pcm is just the raw stream of data.
19:41:49 <aeron> so, base case, passing in an item and an empty list is pretty obvious
19:41:49 <lispy> aeron: so, if I gave you an empty list how would it work?
19:41:53 <EvilMachine> Saizan: but later i will switch to a better format anyway
19:42:04 <aeron> snoc x [] = [x]
19:42:09 <lispy> good
19:42:30 <lispy> and with a singleton list?
19:42:39 <Orclev> aeron: one second, I got it done, let me hpaste it
19:43:06 <lispy> snoc x [y] = ?
19:43:08 <Saizan> EvilMachine: heh, don't worry unless it bites you then :)
19:43:12 <EvilMachine> aeron: just those functions? well, i don't think that is possible without taking the whole list apart in a recursive loop, and then re-starting to build the list, starting with your new element.
19:43:36 <Orclev> aeron: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10749#a10749
19:43:46 <Saizan> you don't need to get to the end to start rebuilding the list, laziness ftw
19:43:49 <Orclev> it's probably not pretty, nor is it efficient, but it works
19:44:23 <Saizan> why the helper function?
19:44:31 <Saizan> you could just have recursed with append
19:44:37 <lispy> Orclev: why isn't it efficient?
19:44:41 <EvilMachine> Saizan: well, my program already is exceptionally slow. perhaps because i create the wave forms out of their harmonics in a formula with 25 iterations per sample point.
19:44:56 <EvilMachine> Saizan: no caching yet. ^^
19:45:19 <Orclev> Saizan: yeah, I realized that and re-wrote it without the helper function
19:45:56 <Saizan> also, pattern matching against [] still counts as using only head, tail and cons?
19:46:02 <aeron> snoc x y = head y : l : []?
19:46:06 <aeron> er
19:46:09 <aeron> snoc x y = head y : x : []?
19:46:19 <jmcarthur> yeah, technically you could get away with not using head and tail if you are pattern matching
19:46:29 <jmcarthur> and of course cons is :
19:46:30 <zong_sharo> halp!
19:46:31 <Orclev> Saizan: I guess... if you can't pattern match against [] I don't see how you would do it
19:46:32 <Saizan> aeron: that's correct
19:46:42 <zong_sharo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10750#a10750 <- why this transformers fails to typecheck
19:46:42 <Saizan> Orclev: same here
19:47:06 <Saizan> aeron: though you don't know if y is a singleton list here
19:47:09 <Saizan> *there
19:47:27 <Saizan> and it's better to handle the case where it's a generic non-empty list anyway
19:47:30 <aeron> so wrapping its parameter in [] implies a singleton?
19:48:16 <jmcarthur> aeron: what is this for? just an exercise?
19:48:21 <Saizan> ?type runState
19:48:22 <lambdabot> forall s a. State s a -> s -> (a, s)
19:48:24 <lispy> aeron: I'd recommend writting out the equations for lists of length 0 to 4 and then trying to generalize it
19:48:27 <Saizan> aeron: yes
19:48:32 <aeron> lispy, alright thanks
19:48:43 <aeron> jmcarthur: yeah, i've got a functional unit in a class coming up soon and was looking ahead
19:49:03 <Saizan> zong_sharo: what's the error?
19:49:09 <lispy> aeron: recursion in this case is a lot like induction but in reverse
19:49:12 <jmcarthur> aeron: ah. i hope you are enticed to the world of functional programming :D
19:49:30 * lispy has to leave now 
19:49:31 <Saizan> lispy: in reverse?
19:49:34 <zong_sharo> Saizan: Couldn't match expected type `Bool' against inferred type `()' \n Expected type: ContT Bool (State Bool) a \n Inferred type: T ()
19:49:36 <lispy> good luck!
19:49:37 <aeron> jmcarthur: especially with this sort of attention when I ask for help, of course :)
19:49:46 <lispy> Saizan: yeah
19:49:53 <aeron> Orclev, thanks for your help as well :)
19:49:55 <jmcarthur> aeron: #haskell is the best irc channel ever :)
19:50:00 <Saizan> it seems in the same direction to me
19:50:17 <lispy> Saizan: at least kinda.  Because in the recursion you tear it apart
19:50:22 <Jagwire> lol
19:50:34 <Saizan> you get the case for k for free and you've to build the one for k+1
19:50:38 <Jagwire> can you use == for string comparison?
19:50:50 <Jagwire> "String" == "string"
19:50:51 <Saizan> lispy: you're tearing apart the input list here
19:50:56 <lispy> Saizan: but you think of induction as building the input (or I should say, I think that way)
19:51:07 <monochrom> zong_sharo: I don't understand why you write return () :: T ().  Just have baz = return () >> return False
19:51:10 <Saizan> lispy: ah, i never do :)
19:51:18 <lispy> anyway, I gotta run!
19:51:27 <zong_sharo> monochrom: i simplifed a real problem
19:51:27 <Orclev> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10749#a10752
19:51:48 <Orclev> sort of cheated... removed the pattern match and replaced it with a case... surely case is allowed as part of the language
19:51:58 <byorgey> Jagwire: yes.
19:52:03 <byorgey> > "String" == "String"
19:52:04 <lambdabot>   True
19:52:05 <Saizan> i'd avoid head and tail at that point
19:52:10 <byorgey> > "String" == "string"
19:52:11 <lambdabot>   False
19:52:14 <zong_sharo> monochrom: same error happens with some more compilcated stuff
19:52:28 <Jagwire> > "Meh" == "MeH"
19:52:28 <lambdabot>   False
19:52:32 <Jagwire> nice
19:53:16 <zong_sharo> monochrom: i don't get why type of (return () :: T ()) expected to be 'ContT Bool (State Bool) a' in (return () :: T ()) >> return 'c' expr
19:53:22 <zong_sharo> oups
19:53:28 <byorgey> Jagwire: any type that is an instance of the Eq type class can be compared with == .
19:53:29 <zong_sharo> return False, but does not matter
19:54:03 <byorgey> > 3 == 3
19:54:04 <lambdabot>   True
19:54:08 <byorgey> > () = ()
19:54:09 <lambdabot>   <no location info>: parse error on input `='
19:54:12 <Saizan> zong_sharo: your problem is the definition of T
19:54:25 <monochrom> zong_sharo: Then my next complaint is "ContT a (State Bool) a" removes yourself a lot of flexibility and may have a hand in your problem.  "type T r a = ContT r (State Bool) a" is more orthodox and less problematic.
19:54:29 <byorgey> > ("foo", [2,6]) == ("foo", [2,6])
19:54:30 <lambdabot>   True
19:56:11 <Saizan> the 'r' must be the same for connected actions, and it can't be both Bool and () at the same time, so you've to let it differ from 'a'
19:56:21 <monochrom> Indeed, "return False" is ContT Bool (State Bool) Bool.  You cannot mix it with ContT () (State Bool) ().
19:57:01 <aeron> another question, unrelated: any Windows IDEs with Haskell support? :)
19:57:24 <Orclev> aeron: I'm pretty sure leksah runs in Windows
19:57:25 <Saizan> there's been work on eclipse this summer
19:57:31 <aeron> alright, thanks
19:57:33 <monochrom> there is haskell plugin for a version of visual studio, probably old
19:58:08 <Saizan> then yi or emacs, fsvo IDE
19:58:56 <veganman> hello
19:58:57 <Orclev> does yi really count as an IDE though? It's more of a general purpose editor to me
19:59:36 <zong_sharo> monochrom: i wanna know why, not how to fix
19:59:45 <veganman> I'm very new to haskell, use hugs (& runhugs) and I'm confused as of this: ERROR "setup.lhs" - Can't find imported module "Distribution.Simple"
20:00:04 <jmcarthur> > let snoc = flip $ foldr (:) . pure in snoc "fooba" 'r'
20:00:05 <lambdabot>   "foobar"
20:00:10 <monochrom> I have said why, too.
20:00:34 <veganman> While distribution.simple seems to be in my cabal
20:00:45 <aeron> jmcarthur: :)
20:01:24 <zong_sharo> i don't understand, why how it's happens. can you explain me?
20:01:25 <jmcarthur> maybe not the clearest definition
20:01:44 <monochrom> Must I repeat myself so?
20:01:50 <monochrom> Indeed, "return False" is ContT Bool (State Bool) Bool.  You cannot mix it with ContT () (State Bool) ().
20:02:01 <monochrom> What do you not understand in that sentence?
20:02:22 <monochrom> Expand yourself "T ()" and "T Bool" to see.  Don't hide behind a type synonym.
20:02:29 <aavogt> @type return False :: ContT Bool (State Bool) Bool
20:02:30 <lambdabot> ContT Bool (State Bool) Bool
20:02:58 <aavogt> @type return False :: ContT () (State Bool) Bool
20:02:58 <jmcarthur> @unmtl ContT Bool (State Bool) Bool
20:02:59 <lambdabot> ContT () (State Bool) Bool
20:02:59 <lambdabot> (Bool -> Bool -> (Bool, Bool)) -> Bool -> (Bool, Bool)
20:03:20 <jmcarthur> @unmtl ContT () (State Bool) Bool
20:03:20 <lambdabot> (Bool -> Bool -> ((), Bool)) -> Bool -> ((), Bool)
20:04:01 <aeron> one more time, thanks for the help guys :) i'm trying to write things out in haskell, common lisp, and F# for each problem
20:04:19 <aeron> definitely makes haskell/ocaml/f# pattern matching look good lol
20:04:22 <blackh> veganman: Most of us use GHC - I've never even used Hugs - so I can't help much
20:04:38 <veganman> blackh: any clues perhaps?
20:04:51 <jmcarthur> aeron: pattern matching is awesome, but some of the real power of haskell comes in when you eliminate the need for it :)
20:05:05 <aeron> jmcarthur: noted
20:05:08 <jmcarthur> aeron: such as the use of foldr i showed earlier
20:05:12 <jmcarthur> :t foldr
20:05:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:05:23 <jmcarthur> aeron: it does the recursion and pattern matching for you!
20:05:23 <Orclev> veganman: (ghc user here) looks like it can't find the module for whatever reason... no idea what the hugs equivalent of ghc-pkg is, but I'd use that to check to make sure hugs can find it
20:05:36 <aeron> jmcarthur: yeah i'm familiar with it - just trying to start from the very beginning with several functional languages and work up :)
20:05:51 <aeron> i've observed a lot with fp, just not written anything
20:06:05 <jmcarthur> aeron: ah, a long time lurker ;)
20:07:52 <Orclev> the challenge I have as a haskell newbie is, I want to do something with the language, but I don't know enough to do anything useful, and I don't think I'm getting much out of doing trivial things... I guess I'm still looking for the right itch to scratch that's within my capabilities with the language
20:08:35 <monochrom> My solution was to not do anything useful for a year.
20:09:14 <xle> Anybody know how I can specify a different C FFI library path to ghc --make?
20:09:14 <Orclev> monochrom: well, trying to help other newbies in here has actually proved to be one of the most educational things so far
20:09:45 <xle> I am having trouble with Network.Pcap... just can't get it to compile (it depends on the underlying libpcap library).. I'm on OS X
20:10:09 <aeron> Orclev: that's how I feel like I got good with postgresql :)
20:10:33 <xle> monochrom: I'm a newbie as well, but reading learnyouahaskell and Real World Haskell helped a lot
20:11:01 <xle> Orclev, rather :)
20:11:20 <Orclev> xle: yeah, I read learnyouahaskell, and skimmed real world haskell, among many many others
20:11:40 <xle> yeah, but skimming doesn't really work with haskell :)
20:12:19 <monochrom> In this special instance I am entitled to say I had to go uphill both ways. When I learned, the only tutorial was the gentle introduction.
20:12:29 <aeron> yeah, that's the problem i had - I let the material wash over me, but I really needed to start writing some stuff to feel better about it
20:12:29 <Orclev> xle: what tends to trip me up the most currently is a combination of trying to get my head around some of the wierd theory stuff (like Arrows), and trying to track down where certain functions/ops are defined (like ||| or <++>)
20:13:15 <xle> Orclev: yeah I know what you mean with the theoretical stuff. they are why I took a liking in haskell though. Very entertaining indeed...
20:14:02 <monochrom> Arrow is advanced and seldom used. Don't worry about it. Apart from the special instance where you have mere functions b->c.
20:14:08 <Orclev> xle: theory has always annoyed me, I can't really understand something until I see it used, so a lot of the theory is really hard for me to understand at first
20:14:14 <xle> Sorry to repeat the same question everyone, but does anybody know how I can point ghc towards a C library at compile time? I think I need to tell it where the libpcap library is...
20:14:41 <Cale> xle: hmm
20:14:46 <xle> Orclev: Oh yeah that is true, which is why examples are definitely necessary..
20:14:55 <Cale> xle: Is it not in the LD_LIBRARY_PATH or whatever
20:14:56 <Cale> ?
20:15:12 <xle> Cale: ENV variable, right?
20:15:15 <Cale> yeah
20:15:49 <Cale> well, that's actually normally empty
20:15:59 <xle> yeah it is
20:16:03 <xle> and it doesn't help to set it
20:16:04 <Cale> but there's a default set of paths where the linker will look on your system
20:16:22 <xle> How do I make sure it looks in the macports folder?
20:16:37 <xle> It just can't seem to find any of the necessary C functions..
20:16:49 <Jagwire> skimming must be a lambda function...
20:16:52 <Cale> Ah, -L/path/to/it
20:16:54 <Orclev> xle: I think ghc also passes on un-recognized variables to gcc although I wouldnt swear to it, so maybe something like -B would work?
20:17:21 <byorgey> Jagwire: ?
20:17:36 <Jagwire> mmm, yeah i got nothing...
20:17:51 <byorgey> hehe =)
20:19:17 <Esmil> Hi. I wrote the same function 3 times, but I have no clue which of them is more efficient, so if some of you have some input it'd be great: http://codepad.org/snFh3aaN
20:21:34 <Orclev> Esmil: why not build with profiling and see which runs fastest and/or uses the least memory?
20:22:13 <Jagwire> can you use guards in lambda functions?
20:22:23 <Saizan> Jagwire: no
20:22:27 <Esmil> Orclev: Thats a great idea. Could you give me some hints/links how to?
20:22:39 <byorgey> Esmil: they look about the same to me efficiency-wise.  I wouldn't worry about it too much.
20:22:49 <Jagwire> would you ever want to, Saizan?
20:22:58 <Orclev> Esmil: http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
20:23:14 <byorgey> unless you really want to. =)
20:23:15 <aavogt> Jagwire: use the boilerplate like this:   (\x -> case x of blah | hah -> result; otherpatteeenrs)
20:23:35 <aavogt> well, it isn't pretty because it consumes a name
20:23:38 <Jagwire> so let's say
20:23:40 <aavogt> x in this case
20:23:45 <byorgey> what are patteeenrs?
20:23:57 <Esmil> byorgey: Yeah, I know I shouldn't. Its still the one thing that bothers me about haskell. I have absolutely no intution about efficiency of the code I write..
20:24:01 <Saizan> Esmil: the one with foldr uses O(n) stack because helper is strict on its second argument
20:24:02 <Orclev> Esmil: make sure to annotate what you're interested in with the proper cost centers or else you won't find anything interesting from that
20:24:30 <Jagwire> \find s (x:xs) -> if s == x then true else find s xs | find _ [] = [] ?
20:24:36 <Jagwire> would that work?
20:24:40 <Jagwire> > \find s (x:xs) -> if s == x then true else find s xs | find _ [] = [] ?
20:24:41 <lambdabot>   <no location info>: parse error on input `|'
20:24:45 <byorgey> Esmil: heh, fair enough.  I often don't have good intuition about efficiency either.
20:24:46 <Jagwire> guess not
20:25:02 <aavogt> > nub (sort "otherpatterns") == nub (sort "otherpatteeenrs")
20:25:03 <lambdabot>   True
20:25:03 <byorgey> Esmil: but it's never been much of an issue for me.
20:25:15 <monochrom> profiling is advanced. need tutorial. not just haskell-specific.
20:25:50 <aavogt> @faq can haskell make you write complete sensical sentence?
20:25:50 <lambdabot> The answer is: Yes! Haskell can do that.
20:27:12 <Jagwire> > \find s (x:xs) -> | _ [] -> false | if s == x then true else find s xs
20:27:13 <lambdabot>   <no location info>: parse error on input `|'
20:27:16 <Jagwire> hmph.
20:27:29 <Orclev> @faq can haskell foo bar baz?
20:27:30 <SamB_XP> @faq can haskell make *monochrom* write a complete sensical sentence?
20:27:30 <lambdabot> The answer is: Yes! Haskell can do that.
20:27:30 <lambdabot> The answer is: Yes! Haskell can do that.
20:27:49 <Orclev> shenanigans!
20:27:54 <SamB_XP> ... but ... which answer goes with which question?
20:27:58 <Esmil> Orclev, byorgey, Saizan: Thank you btw :)
20:28:41 <monochrom> Profiling is advanced. Do you know why? And it is not just because profiling Haskell is advanced.
20:29:56 <aavogt> monochrom: do say why it is advanced
20:30:00 <Orclev> monochrom: because before you worry about if it works well, you need to know how to make it work?
20:30:04 <Cale> hmm
20:30:26 <Cale> > let splitOnAll c = foldr helper [[]] where helper x (xs:xss) = if x == c then []:xs:xss else (x:xs):xss in splitOnAll 'X' "1X2X3"
20:30:27 <lambdabot>   ["1","2","3"]
20:30:45 <monochrom> If you have a function that runs for 2 seconds --- yes, one single function, one single call --- that's easy. But you rarely do that.
20:31:14 <Cale> ah, yeah :)
20:31:24 <monochrom> More often you have a function that runs for 2 microseconds or even shorter.
20:31:31 <Cale> None of these seem like they should be particularly bad. I'd expect them to all be pretty close in performance.
20:31:49 <Cale> I'm going to try out criterion on them though :)
20:31:50 <impl> most profilers will let you look at things like number of calls to particular code segments too
20:32:43 <Cale> 'if xss == []' is a bit painful. I would use case xss of ...
20:32:53 <monochrom> In the face of OS overhead and other sources of noise, you have to take precautions to make sure the statistics you get is worth anything.
20:33:02 <Cale> (and then you won't need the tail)
20:33:10 * Cale compiles criterion
20:33:11 <monochrom> "Run the function a million times" is only the beginning of it.
20:34:21 <monochrom> criterion is a right direction. but we still need a tutorial for people to use it.
20:34:23 <Saizan> let splitOnAll c = foldr helper [[]] where helper x (xs:xss) = if x == c then []:xs:xss else (x:xs):xss in splitOnAll 'X' (cycle "1X2X3")
20:34:26 <Saizan> > let splitOnAll c = foldr helper [[]] where helper x (xs:xss) = if x == c then []:xs:xss else (x:xs):xss in splitOnAll 'X' (cycle "1X2X3")
20:34:28 <lambdabot>   * Exception: stack overflow
20:35:58 <monochrom> If you talk about annotating cost centres and interpreting ghc profiler's graphs, that needs a tutorial too.
20:36:48 <Orclev> monochrom: actually I think the docs on how to annotate the cost centers explain things pretty well already
20:43:28 <Cale> Whoa, the last one is much much slower than the other two
20:44:14 <Cale> But the other two are roughly equivalent on the strings I tested
20:45:14 <monochrom> criterion is the best thing since stop watch
20:46:34 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10754#a10755
20:48:45 <Cale> hmm, I wonder if I'm abusing the integer parameter there
20:49:07 * Cale tries setting it to a constant to see what happens
20:50:28 <Cale> aha
20:50:33 <Cale> yeah, I was
20:50:46 <Cale> It turns out that they're all roughly equivalent as I initially suspected
20:51:41 <monochrom> That makes me feel better. The foldr version looks very innocent.
20:51:41 <ivanm> Cale: you mean you're turning into oleg? :o
20:51:47 <ivanm> (in that you're abusing numbers...)
20:51:50 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10758#a10759
20:51:54 <Cale> yeah
20:52:05 <Cale> It was very nonintuitive for it to be 100 times slower.
20:52:44 <Cale> Esmil: take a look at this most recent paste
20:53:13 <Esmil> Cale: Awesome. Thanks
20:54:22 <monochrom> What does bench pass to n?
20:55:05 <Esmil> I would have thought ghc was clever enough to optimise 1 and 2 to the same though
20:56:37 <Saizan> monochrom: it's the only one that overflows on infinite lists though :)
20:57:04 <jmcarthur> Peaker: just installed breakout. i can't even get the ball to come off my paddle
20:57:14 <c_wraith> monochrom: it passes a different value each time.  that's all you need to know.
20:57:28 <c_wraith> monochrom: the main purpose is to prevent ghc from optimizing repeated calls
20:58:09 <c_wraith> Of course, that means people working on optimizing ghc have the goal of breaking criterion. :)
20:58:19 <monochrom> So unluckily split/3 received a huge n in the accidentally-abused version.
20:58:58 <Cale> monochrom: yeah
20:59:11 <Cale> monochrom: I was hoping it would give a different n for each iteration
20:59:27 <Cale> er, or maybe it does, and it just gave a ridiculously large n once?
20:59:37 <Saizan> you should use n somehow though
20:59:44 <Saizan> otherwise ghc will optimise it away
20:59:53 <monochrom> 1000+n-n
20:59:56 <Jagwire> > \find s (x:xs) ->  _ [] = false -> true
20:59:57 <lambdabot>   <no location info>: parse error on input `='
20:59:58 <Cale> no, that can't be it, it must have been using the same number for all the tests
21:00:01 <jmcarthur> yeah that is how i usually use n
21:00:08 <jmcarthur> +n-n
21:00:20 <monochrom> I learned it from the criterion blog :)
21:01:01 <mmorrow> here's my criterion template that i've been copying from an rejigging when i've been using it http://moonpatio.com/repos/hsfft_vec/fft64_bench.hs
21:01:01 <Jagwire> hmph again
21:01:06 <Cale> Ah, okay. I haven't read that blog, only glanced at the haddock documentation.
21:01:23 <Cale> Let's try that :)
21:02:27 <Cale> actually, I want GHC to cache the string which I'm splitting
21:02:35 <Cale> But we'll try it anyway
21:02:48 <mmorrow> heh, yeah you've gotta make the value of the test function have a data-dep on at least one of its args
21:03:08 <mmorrow> or else you're like omg sofast
21:03:11 <Cale> The actual function being tested is splitOnAlln
21:03:18 <Cale> Not demoString ;)
21:03:33 <Saizan> maybe something like if n-n == 0 then demoString else "foo"
21:03:37 <Cale> Though I suppose it's possible that GHC could lift even that out
21:03:44 <jmcarthur> omg look ghc optimized my n! algorithm to constant time awsum!
21:04:08 <monochrom> haha
21:04:45 <Cale> ah, okay, now we're seeing 1.31 us, 1.25 us, 1.70 us
21:05:06 <Saizan> that looks more sensible
21:05:23 <Saizan> i wonder how it scales though
21:05:30 <Cale> That'd be recomputing the concat each time though.
21:06:04 <Cale> Lemme do this nonstupidly
21:06:09 <Saizan> (i guess there's no need to add rnf?)
21:06:29 <Esmil> Cale: Could you do this variant of 1, as well please: http://codepad.org/xhHvWNlW
21:06:39 <Cale> dep n x = if n - n == 0 then x else undefined
21:06:52 <Cale> Suppose that will work? ;)
21:07:02 <Cale> er, probably want dep x n
21:08:32 <EvilMachine> :t (Data.String.UTF8.fromString "betty ¼")
21:08:33 <lambdabot> forall index string. (Codec.Binary.UTF8.Generic.UTF8Bytes string index) => Data.String.UTF8.UTF8 string
21:08:33 <Saizan> add a NOINLINE :)
21:08:53 <mmorrow> heh, i was about to suggest adding an INLINE
21:08:57 <EvilMachine> does that make sense? how do i actually use that?
21:09:09 <mmorrow> i wonder if it'll "constant" fold that
21:09:28 <mmorrow> it doesn't appear to fold (0+i-i)
21:10:26 <EvilMachine> hey, it :t works, does this work too?…
21:10:28 <Saizan> EvilMachine: i guess the string parameter is how the bytes are actually stored
21:10:28 <Cale> After factoring out the computation of the string, we're down to the third of a nanosecond range for each of them
21:10:32 <EvilMachine> :e "/etc/passwd"
21:10:35 <EvilMachine> ^^
21:10:40 <Cale> again with 2 being the winner
21:10:42 <mmorrow> i guess `i' could be undefined, but not folding (i-i) just to handle the error case seems retarded to me
21:10:47 <Cale> I'll try adding the new version :)
21:11:23 <Saizan> EvilMachine: so you look at the instances of the UTF8Bytes typeclass to see what your options are
21:11:36 <mmorrow> Cale: heh, i had a 20 nanosecond computation last week too and was so psyched... until i learned that something was borked
21:11:40 <jmcarthur> it sucks that we have to trick the compiler in order to make it do suboptimal things, and it's maybe bad that we *can*
21:11:58 <mmorrow> 20 nanoseconds is like 10, maybe 20 instrs
21:11:58 <Saizan> Cale: try longer strings too!
21:12:07 <EvilMachine> Saizan: correct. So I tried :t (Data.String.UTF8.fromString "betty ¼" :: Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString)
21:12:12 <EvilMachine> :t (Data.String.UTF8.fromString "betty ¼" :: Data.String.UTF8.UTF8 Data.ByteString.Lazy.Internal.ByteString)
21:12:13 <lambdabot> Data.String.UTF8.UTF8 BSLC.ByteString
21:12:39 <Saizan> and?
21:12:50 <ddarius> jmcarthur: You will always be able to "trick" compilers in such ways.
21:12:58 <monochrom> I think if you specialize "string", the "index" part is inferred for you, so don't worry.
21:13:06 <EvilMachine> Saizan:  don't get it. then again, it’s 6:13 am here. ^^
21:13:10 <monochrom> (fundep and all that, if you will)
21:13:25 <EvilMachine> Saizan: there is for example UTF8Bytes ByteString Int
21:14:02 <Saizan> EvilMachine: the UTF8Bytes typeclass has two parameters but the UTF8 type constructor only one
21:14:04 <EvilMachine> Saizan:  but how do I say that I want to use that? i don’t know how I would actually write that. ^^
21:14:12 <EvilMachine> Saizan: exactly
21:14:18 <EvilMachine> Saizan: that’s what I don’t get
21:14:31 <Saizan> Int is inferred automatically because of a functional dependency, i guess
21:14:44 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10760#a10761
21:15:07 <EvilMachine> Saizan: Ah, but since I have just tried it is ghci, there is nothing to infer, right?
21:15:14 <mmorrow> jmcarthur: otoh, gcc turns "acc = 0; for(i=0; i<1000; i++) acc += 1;" into "movl $499500, %esi" ..
21:15:21 <Cale> aww, the ' in the name of my test killed the syntax highlighter ;0
21:15:30 <EvilMachine> :t (fromString "betty ¼" :: UTF8 ByteString)
21:15:31 <lambdabot> Not in scope: `fromString'
21:15:31 <lambdabot> Not in scope: type constructor or class `UTF8'
21:15:31 <lambdabot>     Not in scope: type constructor or class `ByteString'
21:15:34 <Cale> er, :)
21:15:39 <EvilMachine> No instance for (UTF8Bytes ByteString index)
21:16:26 <Saizan> EvilMachine: uhm, it should be able to infer it if it's how i think it is, can you link me the docs?
21:16:55 <EvilMachine> wait, i will try to read from the bytestring. then i should be able to infer it i guess
21:17:22 <jmcarthur> mmorrow: no reason we couldn't do that too :P
21:17:34 <mmorrow> jmcarthur: totally
21:17:48 <ddarius> jmcarthur: Just enable foldr fusion over conses.
21:17:48 <Saizan> EvilMachine: which package is this?
21:18:03 <SmurfOR> I'm trying to use a function over a list and it works when I select only a single index of that list but not when I try to use map.  Pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4377#a4377
21:18:25 <EvilMachine> Saizan: than one: http://hackage.haskell.org/packages/archive/utf8-string/0.3.5/doc/html/Data-String-UTF8.html#t%3AUTF8Bytes
21:18:40 <Cale> SmurfOR: Well, the result of your function now has a different type than it did before.
21:19:05 <Cale> SmurfOR: You changed it from a single element to a list
21:20:53 <Esmil> Cale: So that means 1' wins, but 1 and 2 are almost the same. Only 3 is a bit slower. Right?
21:21:10 <SmurfOR> Cale, thanks :) haha i feel so dumb :)
21:21:22 <Saizan> EvilMachine: ah, yeah, the "| b -> s" part means that for each 'b' there can only be an 's' such that UTF8Bytes b s, so the typechecker can compute s from b, i guess the error in ghci means that you didn't import the module exporting the instances
21:21:25 <Cale> Esmil: yeah, but the differences are very small
21:21:28 <Orclev> SmurfOR: "concat $ map renderPair obj" maybe?
21:21:44 <Esmil> Cale: Yeah. Thanks again
21:22:06 <Cale> Esmil: I'm going to try with a list that's 10 times longer and see if it makes any difference. I don't think it will.
21:22:23 <EvilMachine> Saizan: uuum, I can't even decode “the "| b -> s" part means that for each 'b' there can only be an 's' such that UTF8Bytes b s” as an actual sentence. :/ could you say that in non-mathspeak? ^^
21:22:47 <EvilMachine> Saizan: i have big trouble with math speak. sorry. :/
21:23:03 <Cale> oh, hmm
21:23:09 <Cale> I just realised something
21:23:26 <monochrom> Beware of huge stddev's.
21:23:28 <aavogt> EvilMachine: try writing some instances to get a feel for which instances are made illegal by that fundep?
21:23:33 <Saizan> EvilMachine: it's called functional dependency in RDBMS speak, does that help?:)
21:23:49 <Orclev> Cale: split3 seems to be the most efficient in terms of memory
21:23:53 <Esmil> Cale: btw. do you compile with -O2?
21:23:56 <EvilMachine> Saizan: nah, I’m no RDBMS guy. :)
21:24:12 <Cale> lol, I wasn't rnfing the result of the splits
21:24:25 <ddarius> b determines s (uniquely)
21:24:28 <EvilMachine> Saizan: what about layman at 6 in the morning speak? ^^
21:24:30 <Cale> So we were measuring the time to get the first element of the result
21:24:42 <Cale> Which is useful, but not all that meaningful.
21:24:44 <Saizan> EvilMachine: if i have class C a b | a -> b where, and i make an instance C Foo Bar, then it's illegal to make an instance C Foo Baz
21:25:23 <Cale> (I realised this after making the list 10 times longer and noticing that the time wasn't changing :)
21:25:35 <Esmil> heh
21:25:38 <EvilMachine> Saizan: so it means there can only be one N in C X N for every X?
21:25:42 <Cale> oh, this is interesting
21:25:48 <Saizan> EvilMachine: yeah
21:26:08 <bd_> EvilMachine: you can also say that C becomes a function from X to N :)
21:26:09 <EvilMachine> Saizan: aaah, ok, now i’m getting somewhere. :) thank you
21:26:11 <Saizan> EvilMachine: that's not much different to how i phrased it!
21:26:20 <Saizan> yeah
21:26:50 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10762#a10763
21:27:00 <ddarius> EvilMachine: So what happens if you have C x n | x -> n, n -> x ?
21:27:14 <EvilMachine> bd_: so C X N would be like a function c x = n x
21:27:30 <Cale> This is for concat . intersperse "X" . map show $ [1..10000]
21:27:43 <EvilMachine> ddarius: nothing? dunno
21:27:50 <Cale> well, you can see that ;)
21:27:50 <bd_> EvilMachine: no, it's a function, operating on types, that takes X as an argument, and produces N as its result. That is, C X N => ... would force N to be the result of applying X to C
21:28:03 <Cale> Putting the rnfs in changes things rather dramatically
21:28:10 <bd_> ddarius: If it's legal, then there can be only one instance of C
21:28:25 <Cale> (rnf stands for reduce to normal form, and basically recursively evaluates an entire datastructure)
21:28:26 <bd_> (or zero)
21:28:27 <amckinley> hey, could someone help me change my parsec parser from using String to using ByteString?
21:28:40 <ddarius> bd_: Not true.
21:28:52 <EvilMachine> bd_: yes, i know that it operates on types. i just drew an analogy to functions to understand it. because i can’t wrap my head aroud type functions yet
21:29:07 <EvilMachine> bd_: or however you call those things
21:29:12 <aavogt> bd_: for each pair of types though
21:29:21 <bd_> ddarius: ah, wait, I see what you mean. It creates a bijection :)
21:29:37 <aavogt> you could write an instances for  C Char Int,  C Double Integer
21:29:51 <bd_> aavogt: yeah, I see that now.
21:30:14 <ddarius> bd_: It is legal, by the way.  Here's another example that's also legal though seems even less so: C x | -> x      What does that one do?
21:30:15 <Esmil> Cale: Ahh, cool. Now 3 is almost twice as slow. Still I think ghc ought to compile at least 1' and 2 to the same.
21:30:40 <bd_> ddarius: at a guess, this one really does restrict it to at most one instance?
21:30:46 <aavogt> ddarius: that's actually allowed?
21:30:51 <ddarius> bd_: Yep.
21:30:53 <ddarius> aavogt: Yep.
21:31:04 <EvilMachine> bd_: ok, so if you apply X to C, you get the type N. which would mean that UTF8ytes Bytestring would result in an Int. which makes no sense, since there also is an Int64 instance, which ,when I understand it correctly, should not be allowed to exist… aaahhh *head explodes*
21:31:06 * aavogt has never seen fundeps used like that
21:31:25 <bd_> EvilMachine: huh? I didn't see the original example :)
21:31:42 <EvilMachine> bd_: see here: http://hackage.haskell.org/packages/archive/utf8-string/0.3.5/doc/html/Data-String-UTF8.html#t%3AUTF8Bytes
21:32:02 <Saizan> EvilMachine: that's for the other ByteString type
21:32:14 <EvilMachine> which other
21:32:16 <bd_> They're in different modules, different types
21:32:18 <Saizan> EvilMachine: there's two distinct ByteString types defined in different modules
21:32:27 <bd_> lazy and non-lazy :)
21:32:51 <EvilMachine> lol. sorry if i sound really stupid right now. :( i seem to miss some basic knowledge about the working logic behind it…
21:32:57 <ddarius> > let in 3
21:32:58 <lambdabot>   3
21:33:10 <EvilMachine> bd_: ah. lazy and non-lazy .ok
21:33:25 <Saizan> well, that's just not knowing the libraries :) and maybe how modules provide distinct namespaces
21:33:27 <bd_> EvilMachine: the documentation isn't showing you the entire type names. There's really a UTF8Bytes Data.Bytestring.Lazy.Internal.Bytestring Int64 and Data.Bytestring.Internal.Bytestring Int
21:33:50 <Saizan> and haddock could do better at disambiguating
21:34:16 <EvilMachine> let in the light
21:34:20 <EvilMachine> > let in the light
21:34:20 <lambdabot>   Not in scope: `the'Not in scope: `light'
21:34:38 <EvilMachine> of course not, lambdabot. it’s night here. :D
21:35:38 <EvilMachine> Saizan: to be honest, I had never seen something like the | in class (Num s, Ord s) => UTF8Bytes b s | b -> s
21:35:52 <EvilMachine> is it standard haskell98?
21:35:59 <Saizan> no, a ghc extension
21:36:12 <EvilMachine> I KNEW IT!
21:36:24 <EvilMachine> I *HATE* when that happens. ^^
21:36:39 <EvilMachine> some strange syntax you have never seen and can’t find in any of your haskell documentation…
21:36:42 <ddarius> It's actually a relatively common extension.
21:36:52 <EvilMachine> it’s the worst thing that can happen to beginners
21:37:02 <Saizan> the ghc manual is always there :)
21:37:15 <Cale> > let in let in'let = "let" in let in let in_let = " in" in let in in'let ++ in_let
21:37:16 <lambdabot>   "let in"
21:37:27 <Saizan> though i quess it's hard to search for "->"
21:37:37 <EvilMachine> those extensions often go way over my head, as i’m still only barely able to read the haskell 98 report
21:37:43 * Orclev grumbles about man ghc failing.
21:37:48 <ddarius> You'd search for extensions to classes.
21:38:12 <EvilMachine> Cale: LOL
21:38:29 <Orclev> Cale: O.o
21:38:42 <EvilMachine> Orclev: man ghc? how big would that man page be? 500 pages? ^^
21:38:47 <aavogt> @type in'
21:38:48 <lambdabot> Not in scope: `in''
21:39:09 <EvilMachine> Saizan: exactly. try to search for  “s | b -> s”
21:39:27 <Orclev> EvilMachine: works for me... could always break it into multiple sub-manuals as well ala perl
21:40:18 <EvilMachine> Orclev: ok, or use the info system, or just go straight to nicely formatted html, (also viewable in (e)links(2)/lynx)… which is what the ghc guys did. ^^
21:40:38 <Cale> > let in let in'let = "let" in let in let in_let = " in" in let in in'let ++ let in in_let
21:40:39 <lambdabot>   "let in"
21:40:47 <Cale> Needed one more ;)
21:40:55 <Orclev> EvilMachine: yeah, I'm just used to type man <blah> whenever I'm looking for command line args
21:41:21 <EvilMachine> Cale: if you like obfuscation, try malbolge. but i’m not responsible for exploded heads. :P
21:41:32 <EvilMachine> Orclev: me too :)
21:41:54 * Orclev tries to come up with a head explody emoticon
21:42:01 <ddarius> EvilMachine: Lennart Augustsson, the implementor of hbc, is a multi-time IOCCC winner.
21:42:10 <EvilMachine> Orclev: don’t they enforce a package to have man pages on BSD or debian?
21:42:22 <blackdog> Surely unlambda is the obfuscator of choice round these parts
21:42:23 <EvilMachine> Orclev: i bet there is one in unicode
21:42:34 <Orclev> EvilMachine: I don't know, I'm using gentoo currently
21:42:40 <Axman6> ( * )
21:42:58 <Cale> EvilMachine: malbolge is good, yeah
21:43:27 <EvilMachine> Orclev: close enough?: ☢☠☢
21:44:03 <Saizan> Cale: hah, the foldr one is the fastest if you use a lazy pattern match
21:44:13 <EvilMachine> hbc? Hudson's Bay Company? :P
21:44:14 <Cale> Saizan: oh, cute :)
21:44:16 <Orclev> EvilMachine: maybe it's the font I'm using, but I can't really tell what that is... looks like maybe a half of a a sandwiched between a pair of radiation symbols
21:44:48 <EvilMachine> Orclev: dito
21:44:57 <EvilMachine> (about Gentoo)
21:46:47 <EvilMachine> Orclev: it’s a skull and crossbones between two radioactive singns.
21:46:59 <EvilMachine> -n
21:48:53 <blahed> sup people, can i get some monad luv?
21:49:28 <copumpkin> depends
21:50:07 <EvilMachine> blahed: wait for it! in some decades, the charts will be full of haskell rap. :P
21:50:16 <Axman6> > "blahed" >>= show . toUpper
21:50:17 <lambdabot>   "'B''L''A''H''E''D'"
21:50:25 <Axman6> YEEEAHHHHHHH!!!!
21:50:43 <blackdog> Axman6: ease off the cold medicine, buddy
21:50:45 <Orclev> > pure "luv" :: Identity String
21:50:46 <lambdabot>   No instance for (Control.Applicative.Applicative
21:50:46 <lambdabot>                     Contro...
21:50:52 <blahed> awesome, best channel on freenode
21:50:59 <Axman6> blackdog: dude, i need it, i'm so fucked right now :(
21:51:33 * blackh is high on workahol
21:51:49 <blackdog> blackh: i see you're drinking and deriving
21:51:51 <Cale> > zip [1..] "yeah!" >>= \(k,c) -> replicate k . toUpper $ c
21:51:52 <lambdabot>   "YEEAAAHHHH!!!!!"
21:51:56 <blackh> Ha!
21:51:57 <EvilMachine> blackh: too much php, or what? :P
21:51:58 * blackdog will be here all week, try the veal
21:52:23 <ddarius> @pl zip [1..] "yeah!" >>= \(k,c) -> replicate k . toUpper $ c
21:52:23 <lambdabot> uncurry ((. toUpper) . replicate) =<< zip [1..] "yeah!"
21:52:35 * blahed walks away in a single straight line
21:52:49 <blackdog> blackh: was my entirely-too-large test case any use at all? i half suspect it's a ruby problem, tbh.
21:53:15 <blackh> blackdog: Oh dear - it's on my very long to-do list.
21:53:15 <jimmyjazz14> ha
21:53:40 <blackdog> blackh: *grin* no worries. i got a short job hacking C & lua, so i have my hands full for a bit anyway.
21:54:07 <Orclev> > runIdentity $ return "luv"
21:54:07 <aeron> Cale, can you explain what >>= does specifically in that example?
21:54:08 <lambdabot>   "luv"
21:54:11 <blackh> blackdog: I will get to it.
21:54:13 <ddarius> @pl m >>= x
21:54:13 <lambdabot> x =<< m
21:54:29 <Cale> aeron: xs >>= f  =  concat (map f xs)
21:54:35 <aeron> thanks :)
21:54:35 <Cale> aeron: it's the list monad
21:54:41 <blackdog> blackh: righto. i'll ping you if i manage to get it any more manageabl.
21:56:30 <Orclev> :t (>>=)
21:56:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:56:39 <blackdog> Axman6: what's wrong? don't tell me the unutterable tedium of Canberra has finally broken you.
21:56:52 * blackdog is happily unacquainted with shame
21:57:00 <Axman6> i've got a cold, been coughing my lugs out for the last week
21:58:36 * ivanm gives Axman6 some Vicks
21:58:49 <Axman6> yeah, i need some vicks :(
21:59:10 <Orclev> > (+) <$> pure 2 <*> pure 3 :: [] Int
21:59:11 <lambdabot>   [5]
21:59:45 <Axman6> :: [] Int, seriously?
21:59:54 <ivanm> it's valid
22:00:06 <ddarius> :t id :: (->) Int Int
22:00:07 <lambdabot> Int -> Int
22:00:11 <ivanm> not as common as [Int] though
22:00:18 <Axman6> yeah, but ugly :P
22:00:23 <Orclev> > (+) <$> pure 2 <*> pure 3 :: Maybe Int
22:00:24 <lambdabot>   Just 5
22:00:37 <Orclev> just makes it more explicit that [] is in fact a monad
22:00:52 <ddarius> :t map :: (->) ((->) a b) ((->) ([] a) ([] b))
22:00:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:01:08 <Axman6> you're a bad man ddarius
22:01:47 <aeron> where is toUpper defined?
22:01:55 <ivanm> aeron: Data.Char
22:01:58 <aeron> thanks
22:02:01 <ddarius> In theory, if you were a lisper, you would find what I wrote clearer than the result.
22:02:05 <ivanm> Axman6: took you long enough to realise it... >_>
22:03:13 <aavogt> so, I want a Typeable instance for Data.Time.LocalTime.LocalTime
22:03:30 <aavogt> but it uses Data.Fixed.Pico, which has hidden constructors
22:03:36 <aavogt> so I can't standalone derive that stuff
22:03:54 <Orclev> besides, [Int] is really just syntactic sugar for [] Int anyway, so what difference does it make if it's written de-sugared?
22:04:28 <aavogt> Orclev: you need sugar to live
22:04:35 <aavogt> that's some kind of biological fact
22:04:43 <aeron> aavogt speaks the truth :)
22:04:44 <Orclev> no worse really than doing do blocks as nested >>= and lambdas
22:04:46 <Axman6> because no one uses like that. convention is very helpful for speeding up the time it takes to understand things
22:05:20 <Orclev> Axman6: in this case though, the convention makes it more difficult to understand something being demonstrated
22:05:40 <blackdog> [] Int is certainly more regular
22:06:22 * Axman6 finds it somewhat confusing, since it's unconventional
22:06:53 <aavogt> blackdog: but it is consistent that [] is both a value and a tycon?
22:07:02 <Orclev> Axman6: it makes more sense when presented along with the other examples like Maybe Int, Indentity Int, and Reader Int
22:07:11 <aavogt> so in one sense it is a function, but otherwise its a constant
22:08:07 <aavogt> clearly haskell would be more regular if [] for types was just called List
22:08:11 <Orclev> well... Reader a Int anyway
22:08:23 <ivanm> aavogt: so you don't like syntactic sugar?
22:08:52 <Orclev> :t map
22:08:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:09:13 <Orclev> map :: (a -> b) -> List a -> List b
22:09:14 <blackdog> aavogt: that's certainly true, too, although it's nice to have the shorthand syntax for values.
22:09:21 <aavogt> ivanm: I'm (trying) to point out that ([] a) is also inconsistent
22:09:49 <blackdog> aavogt: you do get a confusion between the type level and the value level, that's true. but that's there with the [Int] syntax as well, i think
22:10:09 <Axman6> aavogt: i think that would add another level of confusion for new users, since then you've got List a, (a:b:c:[]) and [a,b,c] all being different (parts of) syntax for lists
22:10:29 <aavogt> blackdog: true
22:10:40 <blackdog> Axman6: that's how they do it in Ocaml, for instance.
22:11:08 <Axman6> that's another thing to add to my list of things i don't like about ocaml without having ever used it ;)
22:11:27 <Axman6> @@ wtf? who thought that would make a good concatenation symbol?
22:11:28 <lambdabot> Plugin `compose' failed with: Unknown command: ""
22:11:46 <FunctorSalad> Axman6: @ppend
22:11:58 <Axman6> atppend?
22:14:22 <Axman6> FunctorSalad: well, using @ would have made sense. @@ is silly
22:14:40 <aavogt> but @ is already the prefix for commands
22:14:45 <aavogt> ?@ ab cd
22:14:45 <lambdabot>  ab cd
22:17:25 <Orclev> :t (@)
22:17:26 <lambdabot> parse error on input `@'
22:18:04 <ivanm> Orclev: @ is syntax, not a function
22:19:04 <Orclev> ivanm: actually @? appears to be a function in the HUnit module
22:19:37 <aavogt> ixset uses @=
22:19:47 <ivanm> Orclev: @? /= @
22:21:28 <Orclev> hmm... is it possible to use a single special character as a op, or is that against the rules (things such as (+) obviously exempted)?
22:21:37 <Orclev> or maybe just bad style?
22:22:07 <ivanm> you can
22:22:10 <ivanm> if it isn't already used
22:22:22 <ivanm> generally, however, people use a combination because the single chars are pretty much taken
22:28:59 <lgas> If I have a function "load_surface :: Int -> IO Surface" I can do "x <- load_surface 5"... is there a way to do something like "xs <- map load_surface [1..10]"?  Or should I be thinking about it differently?
22:30:09 <Cale> lgas: mapM is what you're looking for
22:30:20 <Cale> :t mapM
22:30:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:30:27 <Axman6> can anyone see why haddock would have a problem with this declaration? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10767#a10767
22:30:47 <Axman6> it's causing my TernaryTrees package to fail to build haddock docs
22:30:48 <lgas> excellent, thanks Cale.
22:30:57 <Axman6> so, hackage has no docs
22:31:14 <Axman6> error is: Data/Set/StringSet/Internal.hs:9:15: parse error on input `deriving'
22:32:45 <Cale> Axman6: you want -- ^  for each of the constructors
22:32:59 <Axman6> ah, ok
22:33:00 <Cale> Axman6: because you're documenting the previous constructor, not the next one
22:33:07 <Axman6> hmm
22:33:33 <Cale> So it's complaining that there's not another constructor after the -- | a branch ...
22:34:26 <Cale> You can use -- | if you put each comment on the line before the constructor that it documents
22:34:36 <Cale> data T a b
22:34:37 <Cale>   -- | This is the documentation for the 'C1' constructor
22:34:37 <Cale>   = C1 a b
22:34:37 <Cale>   -- | This is the documentation for the 'C2' constructor
22:34:37 <Cale>   | C2 a b
22:34:39 <Axman6> ah. i might do that
22:34:48 <Cale> data T a b
22:34:48 <Cale>   = C1 a b  -- ^ This is the documentation for the 'C1' constructor
22:34:48 <Cale>   | C2 a b  -- ^ This is the documentation for the 'C2' constructor
22:35:14 <iaefai> Can anyone recommend a nice library, thinking of opengl related, that would allow me to create an interface of sorts that would allow for clicking and pictures and text? I was considering using glut with opengl, but wanted to find out if anyone knew of a decent thing on top of that. Target is ultimately windows.
22:35:22 <Orclev> ok, I'm looking at writing a program in haskell, but I'd like to be able to create plugins, or extensions for the program, most likely also written in haskell... is there a easy way to do something like that?
22:35:31 <Cale> Orclev: hint
22:35:38 <Cale> Orclev: It's a wrapper for the GHC API
22:35:50 <Orclev> Cale: ok, I'll take a look at that
22:35:56 <Axman6> thanks for the help Cale
22:36:40 <Orclev> Cale: cool, that looks more or less like exactly what I want
22:36:53 <_Ray_> Is it a common pattern to have a function that you want to do a loop, but you need a starting value, so you say foo :: bar -> baz\nfoo n = foo' n 0\n where\n foo' :: bar -> int -> baz\n foo' n 0 ...etc?
22:37:24 <Cale> Orclev: You can even compile the plugins. If there are .o files alongside the .hs files being loaded, it will use the precompiled code
22:37:41 <ski> _Ray_ : yes
22:37:52 <_Ray_> Thanks :)
22:38:29 <Cale> _Ray_: if it's not of more general use, it's common to move that helper into a where clause once you're finished writing it.
22:38:33 <ski> sometimes i flip the arguments of the inner function, though, so that i can say `foo = loop 0' (`loop' being the auxilary helper / worker)
22:38:53 <absentia> programming in haskell, page 21... right above section 3.6 -- paragraph says:  Note that there is no restriction that functions must be total on their arguments type, in the sense ....
22:38:55 <absentia> WTF does that mean ?
22:39:00 <ski> (Cale : well, _Ray_ did use `where' .. :)
22:39:13 <Cale> absentia: I get the feeling that it's about to explain what it means
22:39:35 <absentia> no
22:40:11 <_Ray_> So it's not criminal to have 5 nested 'where's, since I wanted to restrict the functions' scope as much as possible?
22:40:14 <Cale> absentia: But it means that the compiler does nothing to guarantee that a function is defined for every possible value
22:40:26 <absentia> cale: ?
22:40:36 <Cale> absentia: Because this amounts to termination checking.
22:40:43 <absentia> ok.  I don't get it.
22:40:47 <Cale> okay...
22:41:01 <_Ray_> absentia, you may be using pattern matching to define which values a function may care about.
22:41:11 <_Ray_> These pattern matchings needn't cover every single possible case.
22:41:30 <bd_> absentia: f :: Integer -> Integer; f a = a + 1 <-- this is total, because if you give any integer, it will always give back an integer
22:41:32 <Cale> f x | odd x = f x
22:41:38 <Cale>     | otherwise = x
22:41:44 <_Ray_> For instance, you could say that foo :: [Integer] -> Bool f [] = False, and not define it elsewhere.
22:41:45 <bd_> absentia: f :: Integer -> Integer; f a = 1 `div` a <-- this is not, because f 0 is undefined
22:42:07 <Cale> This f will loop forever when passed an odd number, and terminates when given an even number.
22:42:23 <ski> _Ray_ : if you need 5 nested `where's, go ahead :)
22:42:32 <_Ray_> Heh, thanks :)
22:42:34 <Cale> The compiler doesn't do anything to ensure that functions you define are actually defined for all the values in their domain, like proper mathematical functions are supposed to be.
22:42:56 <absentia> total means will terminate?
22:42:58 <ski> (_Ray_ : though, i'm a bit curious what code would suggest this nesting ..)
22:43:04 <bd_> > let x = x in fx
22:43:04 <lambdabot>   Not in scope: `fx'
22:43:06 <bd_> > let x = x in x
22:43:08 <Cale> absentia: yeah, or 'is defined'
22:43:10 <lambdabot>   mueval-core: Time limit exceeded
22:43:14 <bd_> hm, no loop detection here
22:43:14 <absentia> ok, thanks.
22:43:28 <Cale> Our solution to this is to treat every type as having (at least) one extra element, called _|_ or "bottom" or "undefined"
22:43:51 <absentia> ah, ok
22:43:55 <ivanm> Cale: hmmmm.... so how does _|_ differ from void in Java, etc.?
22:44:02 <Cale> So that when we analyse the behaviour of functions we have a name for nontermination/erroring out/etc.
22:44:15 <bd_> ivanm: Totally different. Void is a type (analogous to haskell's () ), _|_ is a value.
22:44:15 <Cale> You mean Null?
22:44:19 <ski> ivanm : `void' in Java corresponds to the `()' type in Haskell
22:44:19 <ivanm> ummm, yes
22:44:29 <ivanm> I made a mistake, get over it! :p
22:44:31 <_Ray_> ski, I'll pastebin it, but it's in spanish xD The goal is, given "foo" "foobarfoo", return "bar". Basically, remove every occurrance of the first [Char] in the second [Char].
22:44:37 <bd_> ivanm: note that () contains at least two elements, () and _|_
22:44:38 <Cale> Well, _|_ also includes things like looping forever.
22:44:42 <ivanm> in the sense that a large problem with Java is that you can have null everywhere...
22:44:49 <Samy> _|_ to you too
22:45:00 <Cale> While null is what we'd consider a defined value of each object type in Java.
22:45:09 <ski> `null' in Java is a value that represents "object (observably) missing"
22:45:10 <_Ray_> Being careful with things like "bc" "bbcc", since if I only remove the middle one, the result is again "bc" and it's wrong.
22:45:15 <bd_> ivanm: The main difference there is you can't test for _|_ like you can with null, because _|_ might manifest as a function simply never completing.
22:45:20 <ivanm> true
22:45:31 <bd_> A better analogy would be using Maybe and fromJust everywhere :)
22:45:40 <ski> while `_|_' in Haskell is just a way to think of "not returning computation" as a value .. it is not observable
22:46:06 <_Ray_> ski, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10768 <-- I'm pretty new at Haskell (and functional programming, really) so there are very likely much better ways of doing this :)
22:46:32 <Cale> absentia: An important thing to note is that even if a value is undefined, it's possible for a function which takes it as a parameter to produce a defined result
22:46:46 <_Ray_> I had to implement some backtracking code (the buffer part) since if I want to remove "fooo" and I see "foobar", I'll start to match, but then I want to bail out.
22:46:47 <Cale> absentia: A simple example of this is something like   const 5 undefined = 5
22:47:23 <Cale> absentia: const doesn't pay any attention to its second parameter, so it doesn't matter if that's an infinite loop, or something which if you look at it will crash the machine, or what have you.
22:47:30 <hackagebot> TernaryTrees 0.1.3.4 - Efficient pure ternary tree Sets and Maps (AlexMason)
22:47:50 <Axman6> hoorah
22:48:04 <Cale> absentia: and structured types like lists have partially-defined values in them, such as...
22:48:09 <ski> _Ray_ : hm .. maybe you should read on KMP matching ?
22:48:09 <Cale> > 1 : 2 : 3 : undefined
22:48:09 <absentia> ok
22:48:10 <lambdabot>   [1,2,3* Exception: Prelude.undefined
22:48:20 <Cale> > take 3 (1 : 2 : 3 : undefined)
22:48:20 <_Ray_> ski, the what now?
22:48:21 <lambdabot>   [1,2,3]
22:48:28 <ski> (or maybe Boyer-Moore ?)
22:48:42 <Cale> and even though the list is only partially-defined, we can still apply functions like take 3 to it
22:48:44 <Axman6> anyone know how long roughly it'll be before hackage makes the haddock docs for that package?
22:49:02 <Cale> (and get a completely defined result)
22:49:05 <_Ray_> ski, I'm in an algorithms & data structures course, maybe we'll see that...but in case we don't, got a link?
22:49:06 <absentia> take 4?
22:49:08 <blackh> Axman6: Last time I tried it was about 6 hours.
22:49:14 <ski> Knuth-Morris-Pratt algorithm <http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm>
22:49:16 <Axman6> ok, sounds good
22:49:20 <Cale> take 4 will give a result identical to the original partially-defined list
22:49:27 <absentia> ok
22:49:28 <Cale> (another partially defined list)
22:49:36 <ski> _Ray_ : i was just thinking that might be relevant to what you're doing .. will look at the code now
22:49:44 <Cale> (well, the same one, actually ;)
22:49:55 <_Ray_> heh, k. Sorry for the language barrier xD
22:49:57 <Cale> > take 4 (1 : 2 : 3 : undefined)
22:49:57 <lambdabot>   [1,2,3* Exception: Prelude.undefined
22:50:17 <Cale> > length [undefined, undefined, undefined]
22:50:18 <lambdabot>   3
22:50:29 <Cale> > length . map (+1) $ [undefined, undefined, undefined]
22:50:30 <lambdabot>   3
22:50:47 <Cale> You can use undefined as a way to tell if the Haskell evaluator is going to evaluate something :)
22:51:31 <Cale> Clearly, it didn't look at any of the elements of that list of 3 elements, because if it had, we would have seen an exception.
22:51:42 <Cale> > sum [undefined, undefined, undefined]
22:51:43 <lambdabot>   * Exception: Prelude.undefined
22:51:51 <Gracenotes> ghci gets an electric shock every time you use undefined
22:52:08 <Axman6> > repeat 100 undefined
22:52:09 <lambdabot>   Couldn't match expected type `a -> t' against inferred type `[t1]'
22:52:09 <ski> _Ray_ : stylistically, i think i would elide the `where's directly following the two `resto' equations
22:52:16 <Axman6> > replicate 100 undefined
22:52:17 <lambdabot>   [* Exception: Prelude.undefined
22:52:22 <_Ray_> elide => remove?
22:52:33 <Cale> > map (const 1) (replicate 100 undefined)
22:52:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:52:38 <ski> yes
22:52:39 <Axman6> :o
22:52:58 <absentia> heheh
22:53:02 <ski> (and of course reindent the subsequent definitions to the same level as the preceding `resto' one)
22:53:55 <_Ray_> Right
22:54:11 <_Ray_> I was just using 'where' as a general way of saying "if nobody else needs this, I'll encapsulate it into a 'where'"
22:54:44 <ski> _Ray_ : because e.g. `recortarComienzo' is not necessarily a local detail to how to compute `resto' (it might be, but i suspect not)
22:55:16 <_Ray_> hrm...you're right, it's pretty generic
22:55:30 <ski> i.e. `recortarComienzo' is part of the internal algorithm, and `resto' is more or less just an afterthought, to start off the internals
22:56:19 <ski> if you didn't need to use `resto' more than once, you could easily unfold its definition into the use site, with more or less the same clarity of expression
22:57:58 <ski> some needless brackets
22:57:59 <ski> s/((length chica) > (length (l:larga))) = (l:larga)/length chica > length (l:larga) = l:larga/
22:58:19 <ski> s/(resto == (l:larga)) = [l] ++ (sacarTodos' chica larga)/resto == (l:larga) = [l] ++ sacarTodos' chica larga/
23:02:05 <ski> you don't really need to pass  chika  as an argument to  sacarTodos'
23:02:36 <_Ray_> hrm
23:02:49 <_Ray_> I fear the auto-passing through levels
23:03:16 <ski> it's no problem
23:04:05 <ski> also, is there a reason why  sacarTodos'  is monomorphic, while  recortarComienzo  and  recortarComienzo  is polymorphic ?
23:04:29 <_Ray_> none, I just thought it was reusable enough to be useful if I later wanted to use it in another program
23:04:32 <ski> (s/  is poly/'  is poly/)
23:04:56 <ski> then you could just as well lift it out of the `where's
23:05:19 <_Ray_> yeah...makes sense. I either want to reuse it or I don't
23:06:46 <ski> what should happen if  recortarComienzo'  is applied to an empty list in first or second argument ?
23:06:53 <c_wraith> hah!  I finally found..  monads-fd also contains an RWS monad.  And it depends on transformers, which means I can use explicit-exception.  yay!
23:07:28 * _Ray_ checks
23:07:35 * ski . o O ( `explicit-exception' ? )
23:07:42 <c_wraith> it's a package, ski
23:07:47 <_Ray_> well, in this case it can never happen
23:08:12 <ski> if you lift out `recortarComienzo', it can certainly happen
23:08:21 <_Ray_> oh yes, yes.
23:08:24 <ski> (maybe not in your specific use)
23:08:58 <ski> it is bad to repeatedly append to `buffer'
23:09:29 <Twey> explicit-exception seems neat
23:09:46 <ski> you should either rewrite to direct style (if possible), otherwise prepend, and reverse at the end
23:09:58 <_Ray_> direct style?
23:10:11 <c_wraith> Or use DList, which is flat awesome for appending to strings.
23:10:32 <c_wraith> Well.  For constructing things from the head to the tail, anyway.
23:10:32 <ski> _Ray_ : yes. not accumulator-passing style, which you use atm
23:10:43 <_Ray_> This is an intro to functional programming, we can't really use any builtin haskell functions (other than, like, length and stuff)
23:11:18 <_Ray_> ski, I'm not familiar with "direct style" - since I come from the imperative world, starting iterations with a counter and accumulating with a buffer is what I use to relate to it xP
23:11:22 <_Ray_> (that's probably bad)
23:11:34 <absentia> what is the purpose of n+k patterns?
23:12:09 <jmcarthur> absentia: to complicate things ;)
23:12:12 <ski> absentia : `factorial 0 = 1; factorial (n+1) = (n+1) * factorial n'
23:13:00 <ski> _Ray_ : it appears you match the initial elements of the two lists, if they match, you produce the matching element as output, and continue matching to produce the suffix after this
23:13:01 <absentia> why?  why not n * fact (n-1)
23:13:15 <_Ray_> right
23:13:26 <ski> at mismatch, you set the last suffix to the list which you match on
23:13:41 <_Ray_> I basically see if "foo" matches in "foobar"
23:13:45 <ski> so, this is a simple recursion, there is no need for an accumulator
23:14:03 <_Ray_> if I get to the end of "foo" safely, then it matched entirely, and I want everything in the other string (in this case, "bar")
23:14:27 <ski> you should be able to define it in the usual form
23:14:38 <ski>   recortarComienzo (x:xs) (y:ys)
23:14:40 <_Ray_> if it stopped matching, as in the case "fooo" "foobar", by the time I realize it, I'm at "o" "bar", without a buffer I'd have lost the old "foo"
23:15:03 <ski>     | x == y    = ..(recortarComienzo xs ys)..
23:15:12 <ski>     | otherwise = ...
23:15:37 <_Ray_> But where do I keep track of the part that I'm "discarding" in each iteration, which may be important?
23:15:53 <ski> which part ?
23:16:10 <_Ray_> If I say "fooo" "foobar", then recuse into "ooo" "oobar", then into "oo" "obar", then "o", "bar", and HERE I realize I don't match, I've thrown away my old 'foo'
23:16:22 <_Ray_> because if I DO match, I don't want to use 'foo', I just want to return "bar"
23:16:46 <ski> oh
23:16:53 <_Ray_> I can't concatenate the part I'm deleting into my answer, because sometimes I just won't want it
23:17:06 <ski> that's not what your current code is doing, though
23:17:17 <_Ray_> it's storing "foo" as it goes in buffer
23:17:32 <_Ray_> if I don't match, I just return buffer ++ whatever's left
23:17:36 <ski> you accumulate elements into `buffer', and then unconditionally return `buffer' at the end (plus some more elements)
23:17:38 <_Ray_> if I do match, I return whatever's left
23:18:12 * _Ray_ rereads his own code
23:18:12 <ski> let's walk though an example
23:18:21 <ski>      recortarComienzo "fooo" "foobar"
23:18:28 <ski>   =  recortarComienzo' "fooo" "foobar" []
23:18:58 <ski>     -- 'f' == 'f' = True
23:19:23 <ski>   =  recortarComienzo' "ooo" "oobar" ([] ++ "f")
23:19:32 <ski>      -- 'o' == 'o' = True
23:19:46 <ski>   =  recortarComienzo' "oo" "obar" (([] ++ "f") ++ "o")
23:19:49 <ski>      -- 'o' == 'o' = True
23:20:00 <ski>   =  recortarComienzo' "o" "bar" ((([] ++ "f") ++ "o") ++ "o")
23:20:11 <ski>      -- 'o' == 'b' = False
23:20:48 <ski>   =  ((([] ++ "f") ++ "o") ++ "o") ++ ('b' : "ar")
23:20:52 <_Ray_> hrmph...
23:20:57 <_Ray_> I'm an idiot. I forgot to paste one line.
23:20:59 <ski> (et.c.)
23:21:00 * _Ray_ ducks.
23:21:03 <_Ray_>                     recortarComienzo' _ y _ = y
23:21:09 <_Ray_> At the end
23:21:24 * _Ray_ apologises for wasted time XP
23:21:41 <_Ray_> If it fell through to that case, it means either (x:xs) or (y:ys) didn't match
23:21:54 <ski> that takes care of the partiality i mentioned before, but still, you would return `"foobar"' in the present example
23:22:05 <_Ray_> Right, since "fooo" didn't match
23:22:23 <_Ray_> but if I had chosen "foo" as a match, at a certain iteration, "foo" would be []
23:22:28 <ski> but what do you want to do, in this case ?
23:22:39 <_Ray_> "foo" "foobar" => "bar"
23:22:44 <_Ray_> "fooo" "foobar" => "foobar"
23:22:52 <_Ray_> If match, remove. Else, don't touch
23:22:53 <ski> .. right
23:23:31 <ski> it might be nicer if you returned either `Just suffix' or `Nothing' (in the case of mismatch), though
23:23:49 <_Ray_> yeah, I could rework the algorithm to do that
23:24:10 <ski> then you would not need the expensive `resto == (l:larga)' test
23:24:28 <ski> (expensive to redo over and over)
23:24:34 <_Ray_> right, that just checks for "was it unchanged?"
23:25:49 <ski> hm .. ok, so you can't use direct style in  recortarComienzo'  .. at least not directly
23:26:51 <ski> you could either use monadic style (`Maybe' monad)
23:26:59 <ski> or you could `case' on the result of the recursive call
23:27:37 * ski thinks this might be nicer to write in CPS, though
23:28:02 <_Ray_> :s we can't use monads either
23:28:13 <notsmack> hey guys, i suspect i've got a bug in Network.TCP...
23:28:24 <ski> _Ray_ : an explicit `case' would work just as well
23:28:46 <_Ray_> haven't learned that yet, but I think I saw it in "learning haskell for great...something"
23:28:49 <notsmack> Prelude Network.TCP> x <- openStream "illogicinc.com" 8080 :: IO (HandleStream String)
23:28:49 <notsmack> Prelude Network.TCP> isTCPConnectedTo x "illogicinc.com"                        False
23:29:07 <ski> .. but i'm pondering how to make you see what change i essentially suggest
23:29:39 <ski> note that `buffer' in the example above was constructed in the left-nested form `(([] ++ "f") ++ "o") ++ "o"'
23:30:12 <ski> this is what we want to avoid, since that has quadratic complexity, where linear would be expected
23:31:00 <notsmack> that should return True, right?  it always seems false for me...
23:31:18 * ski hms
23:31:37 <ski> no, i'm wrong
23:32:43 <ski> if you don't return the matched-on list, in the case where there was a mismatch, then there is no need to return these characters, no need to append at all
23:33:16 <ski> you only either need to return `Nothing', or `Just suffix', where `suffix' is the tail after the initial matching part
23:34:03 <absentia> just undefined
23:34:46 <ski> _Ray_ : so. you don't need an accumulator, and you don't need monadic style, nor `case' (nor CPS), in `recortarComienzo'
23:35:38 <_Ray_> right, I'll try to rework the algo to fit that :)
23:35:40 <_Ray_> thanks! :)
23:36:24 <ski> the test `length chica > length (l:larga)' is also expensive, of course
23:36:39 <ski> i would possibly just aboid that shortcut
23:36:48 <ski> s/aboid/avoid/
23:37:14 <ski> if you feel you want to do it, at least compute the lengths only once, instead of repeatedly
23:37:46 <c_wraith> ooh.  yeah, repeated length computations tend to be bad.
23:37:50 <ski> btw, instead of
23:38:08 <ski>   sacarTodos' chica (l:larga) = ..chica..l..larga..(l:larga)..
23:38:10 <ski> use
23:38:22 <ski>   sacarTodos' chica l_larga@(l:larga) = ..chica..l..larga..l_larga..
23:38:31 <ski> (possibly renaming `l_larga' to something better)
23:38:59 <_Ray_> yeah, I'd seen that syntax, but I'm afraid if I use it I'll get...well, not marked down, but marked as snobby =p
23:39:44 <Twey> ‽
23:39:57 <ski> that syntax is there to be used, when appropriate
23:40:23 <c_wraith> Is it it an efficiency win to use that?  Or does GHC recognize that you're using the same constructor you pattern-matched on, and optimize that?
23:40:53 <c_wraith> I guess I could test.  I have code around using that construct that's already using criterion. >_>
23:40:56 <ski> it might (i'm not sure). i think it often clarifies intent, though
23:41:05 <Twey> IIRC, it optimises… but it's nice to not rely on it.
23:43:27 <ski> _Ray_ : btw, the `resto == larga' check could probably be elided, too, i hope
23:43:36 <_Ray_> right, when I change the algorithm
23:44:07 * _Ray_ has to sleep now, however. 3:44am xP thanks for the help :)
23:44:21 <ski> yw
23:44:27 <ski> nice dreaming
