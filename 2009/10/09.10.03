07:56:09 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
07:56:09 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
07:56:09 --- names: list (clog Asztal Keiya_ Wild_Cat QplQyer abbe Zeiris medfly ErhardtMundt viator_sg THC4k Nshag rdeshpande Jafet kayess_ Azstal en0th Keiya Pthing stulli weihsiu Bleadof Peaker Kamujin arsenm byorgey_ nwn Cthulhon lpsmith jaspervdj Tomas takuan paolino der_eq adlan bgs100 trie andrewz rgr pemryan wywen Stefa1 kamatsu BfrOv3rfl0w Absolute0 burkelibbey carlocci Woof brweber2 maurer_ ibid Philippa paper_cc dort komar___ Saizan HugoDaniel1 jfredett)
07:56:09 --- names: list (tomh- MrFahrenheit FunctorSalad_ dolio snhmib Athas m00nblade Alpounet djinni eagletmt kowey flux ksf QtPlaty[HireMe] LouisJB BCoppens hrehf thingwath astrolabe plcs Spockz|lap _zenon_ comak vy mattrepl portnov romfert whoppix Petrosian hiratar_away sioraiocht karrde_ authentic leoncamel [o_O] blastbeat int-e spaceodyssey chris2 dschoepe saint_cypher lambdabot liff kynky igel jrib bryno jahgru ksandstr dionoea ulfdoz drbean MacCoaster)
07:56:09 --- names: list (Jag_ osfameron intrados roconnor tuukkah Kambus coyo rfh Itkovian Phyx- shintah Trafalgards Schalken Dessous hackagebot twanvl frederik dogmaT onodrim Ytinasni Schmallon novas0x2a yahooooo crem_ HaudRex flippo woggle jvoorhis jbauman jones- dibblego ve Caseus allbery_b JoePeck gOcOOl gbacon Milo- malcolmw Nafai alip sshc _Jordan_ pikhq jfoutz p8m ahf Goten_ silverjam caligula_ Taggnostr oubiwann otto_s Philonous AnMaster hender marmolak)
07:56:09 --- names: list (Eelis erg ddarius opqdonut knight__ DuClare LeCamarade|Away timchen1` fnordus Alucard_Not_Orca JaffaCake kadoban dreixel StoneToad_ jeffersonheard aik_ glguy EnglishGent inimino r0bby sevvie thomastc skaar LeoD teneighty __marius__ wornof dons Lemmih rey_ Deewiant Jiten lanaer nlogax gnuvince Liskni_si S1su kalven_ quicksil1er hyko jlouis_ Veinor aarong_ Aisling fooman_ sagelywi1ard DrSyzygy shortcircuit Ornedan_ rapacity jcapper m-i-l-a-n)
07:56:09 --- names: list (mauke sgf_ lordlicorice v0|d igorgue koninkje_away Gracenotes texodus Axman6 hamishmack ^Einstein jorizma sbahra Lycurgus encryptio tamiko lefant ray ps-auxw arjanoosting dqd Ferdirand maskd shapr aluink gbeshers dvgb newsham rdd dejones Beelsebob Chile lsthemes tromp OnionKnight sutats_ dmwit_ dcoutts_ doublethink_work dancor glith wagle_home eevar ToRA ahihi ggreg_ Twigathy Blub\0 luite hachiya integral tinLoaf mikem zsol ricky26_ M4Sh_)
07:56:09 --- names: list (Paradox924X PHO__ elliottt luis Optimo PeakerWork poe lunabot dumael xian malouin mokus Blaketh koeien tessier dfranke_ ville Annie|Ho1e b0ef webframp burp SamB_XP_ snorble benmachine joed Vanadium mdordal2 yango jml SeaPrior karld loop spoop SamB_irssi mahogny kniu davidL XGas_ battleaxe clay_ vili Gilly Stephan202 trez kaol Jaak_ jtra_ dr4wd3_ ski Berengal sjanssen andrewsw-afk McManiaC mexisme ChilliX _Jedai_ jan__ xSaterus DekuNut)
07:56:09 --- names: list (Colours BurgessShale avigesaa nothingmuch Heffalump icee jql boyscared matthew-1 tarbo mfp Arnar_ mlh_ alexsuraci angelixd nimred_ djahandarie thetallguy1 Tobsan fxr dcoutts banisterfiend Badger smorg det pragma_ trofi Boxo peddie dino- profmakx sclv_ Kagami`` koala_man bolrod ddvlad sereven stepcut dfdf shepheb galdor helgim_ eikke kfish kw317 purplepenguins dfeuer co^GudMorNink^ Igloo greap jvogel AndyP Megant_ ertai_ bran_ Nereid tkr)
07:56:09 --- names: list (neurocyte nwf preflex birkenfeld astrocub mornfall kapil eno dbelange gogonkt jimmyjazz14 dilinger mmorrow jayne codm jnwhiteh Crito saccade_ absentia mm_freak resistor frosch03 netcat TML Raku^ Khisanth solrize Cale jonafan mjrosenb kakeman sully stroan Nanar sbok endojelly mml` dcolish ziman xinming defn _br_ Zao mapreduce aempirei anji nathanic Xichekolas tavelram ehamberg felipe_ pcc1 deiga b52 And[y] canvon earthy nornagon ido arvidj_)
07:56:09 --- names: list (marcuse camio bob2 m0nkfish tew88 mun_ danly EvilTerran taruti desu ijnek porpoise ponzao___ Vq anders^^ sebas_ loupgaroublond BrianHV bob0 Exteris olsner xd trzkril joga daed_ glitch fpletz noj mmmdonuts wuncidunci Dunearhp_ Poeir aavogt reqamst mfoemmel jims dv- stalker sproingie c9s Botje mercury^ BMeph regulate tltstc electrogeek Jacolyte poucet DRMacIver orbitz equanimity daf suiside Baughn wdonnelly blackdog thorkilnaur_ mreggen)
07:56:09 --- names: list (scott_ etpace guerby liyang epmf ath gwern Boney Twey Gabbie thedward M| eyck sebbe1991 te flori eelco looooop sunnavy laz0r saiam dixie wolverian rdrake p}q ingy hiredman kar-1 kosmikus harlekin thoughtpolice periodic SubStack agemo_ wormwood inhortte Raevel Counter-Strike otulp ClaudiusMaximus Vulpyne t shachaf jrockway mrd mattam Schmidt Laney nablaa Elly bd_ ibt smg zbrown zygen pettter cjay mux idnar sohum qebab ilid MyCatVerbs sgwizdak)
07:56:09 --- names: list (@ChanServ)
07:57:23 <ski> > ()
07:57:24 <lambdabot>   ()
07:57:44 <ski> hm, log appears to have got that
07:59:35 <ski> (fyi, i spoke with one of the persons who run the machine clog sits on. the person tried stopping and starting clog .. the runner of clog probably doesn't know about it yet. the problem might resurface)
07:59:35 <Fare> is clog working better now?
08:00:13 <ski> it appears so, yes
08:00:26 <lpsmith> w00t,  clog is back
08:01:05 <SamB_XP_> hmm, it looks like clog is identified *now* ...
08:01:25 <lpsmith> was clog not identified before?
08:01:34 <SamB_XP_> that was the theory ;-P
08:01:38 <lpsmith> ahh
08:01:43 <ski> SamB_XP_ : really ?
08:01:51 <SamB_XP_> ski: really what?
08:01:56 <Fare> how is clog not identified?
08:02:03 <SamB_XP_> Fare: it is
08:02:04 <Fare> ski: how well do you combine?
08:02:23 <ski> it doesn't appear identified to my feeble `/whois clog clog' query
08:03:08 <ski> (but maybe i'm just bad at interpreting the answer .. i don't get a ": is identified to services" line back, though)
08:03:19 <SamB_XP_> ski: huh
08:03:24 <SamB_XP_> that's true
08:03:27 <SamB_XP_> and I get one for me
08:03:49 <ski> (and if identification was an issue, i don't see why that would stop it joining #haskell)
08:03:55 <Fare> how do I get it identified without stopping it and logging as clog?
08:04:12 <Fare> (oh, then I'd have to modify the script, anyway)
08:04:23 <Fare> you'll have to contact the author about that.
08:04:32 <ski> to identify, you have to send the `/msg NickServ identify <password>' command
08:04:43 <SamB_XP_> anyway ... I though that the "n=" was supposed to indicate something about identified-ness
08:04:53 <ski> (.. but NickServ tells me `clog' is not ever registered with freenode)
08:05:34 <Jafet> Registrations can expire
08:05:42 <ski> point
08:06:29 <idnar> lpsmith: hey, I read logs here quite a lot :P
08:06:43 <idnar> (although I do that in my IRC client joined to the channel, not by reading them on the web or something)
08:06:58 <idnar> there are often interesting conversations that happen when i'm not around
08:07:03 <lpsmith> heh
08:07:28 <lpsmith> idnar: Just seems like a lot of text to wade through every day
08:07:35 <lpsmith> those are not short logs!
08:08:16 <ski> lpsmith : #haskell is too heavy nowadays for that to work for me, yes .. i do it with some other channels, though
08:08:36 <Fare> can we get an ircop to register clog?
08:08:41 <idnar> lpsmith: well, I don't read everything, that's for sure
08:08:41 <lpsmith> Oh yeah, I could see reading IRC logs for some of the low-volume channels that particularly interest you
08:08:46 <lpsmith> heh
08:09:00 <idnar> I'm in like over 40 IRC channels anyway
08:10:42 <Fare> is it worth taking clog down to register it?
08:10:58 <_zenon_> idnar: 40+ channels?
08:11:34 <ski> Fare : if the runner of clog could be contacted, i suppose that would be simpler
08:12:00 <ski> idnar : you have special permission for that many ? :)
08:12:04 * ski is envious
08:12:05 <Fare> ski: that's an "if". Send mail to nef@tunes.org
08:13:47 <Fare> Cc: root@tunes.org
08:13:49 <SamB_XP_> oh, it does make sense that nef would be the one to contact, doesn't it ;-)
08:14:38 <Fare> SamB_XP_, you mean because of the ~nef URL ?
08:14:46 <SamB_XP_> Fare: yeah
08:14:55 <idnar> ski: it's across 4 different IRC networks
08:15:19 <idnar> I'm only in 15 on freenode
08:15:54 <idnar> _zenon_: mostly IRC channels of software projects I'm involved in or interested in
08:16:03 <SamB_XP_> lpsmith: it's just that #haskell hasn't been "low volume" for a while now ;-P
08:17:13 <Fare> anyway, if nef isn't responsive, root could do something -- but we'd rather not.
08:18:21 <ski> mhm
08:20:28 * ski would probably mail, if ski's account worked atm ..
08:21:09 <lpsmith> ski++
08:21:12 <lpsmith> Fare++
08:21:17 <lpsmith> @karma ski
08:21:18 <lambdabot> ski has a karma of 4
08:21:34 <Fare> gni?
08:21:40 <Fare> @karma Fare
08:21:41 <lambdabot> You have a karma of 1
08:21:44 <Fare> Fare++
08:21:47 <Fare> @karma Fare
08:21:47 <lambdabot> You have a karma of 1
08:21:50 <lpsmith> Fare++
08:21:51 <Fare> dammit
08:21:54 <lpsmith> @karma Fare
08:21:55 <lambdabot> Fare has a karma of 2
08:21:59 <lpsmith> Fare--
08:22:00 <lpsmith> @karma Fare
08:22:00 <SamB_XP_> C++
08:22:00 <lambdabot> Fare has a karma of 1
08:22:03 <SamB_XP_> @karma C
08:22:04 <Fare> :(
08:22:04 <lambdabot> C has a karma of 0
08:22:06 * ski raises eyebrow questingly
08:22:12 <Fare> what about (incf Fare)
08:22:15 <SamB_XP_> huh ... I thought C was stuck at 1?
08:22:16 <ski> (er. spelling ?)
08:22:21 <lpsmith> @karma c
08:22:22 <lambdabot> c has a karma of 0
08:22:23 <lpsmith> @karma C
08:22:24 <lambdabot> C has a karma of 0
08:22:32 <medfly> hehe
08:22:33 <Fare> (incf Fare)
08:22:35 <ski> Fare : that would be if lambdabot was a CL bot :)
08:22:38 <SamB_XP_> ski: oooh -- a quest ?
08:22:47 <ski> (but i suppose the `++' is pretty random, too)
08:23:00 <lpsmith> yeah, that's not exactly a haskell thing
08:23:23 <SamB_XP_> I think I stole it from #perl6
08:23:25 <lpsmith> although GHC does support a postfix operator extension
08:23:39 <Berengal> update $ (+1) . nick ?
08:23:45 <lpsmith> Never played with it though
08:23:46 <ski> SamB_XP_ : yes ! er .. well, not quite
08:24:07 <Fare> http://www.dcs.gla.ac.uk/~partain/haskerl/partain-1.html
08:25:36 * ski initially read "polymorphism" there as "polyamorism"
08:25:44 <lpsmith> @karma lpsmith
08:25:45 <lambdabot> You have a karma of 0
08:26:13 <Fare> lpsmith, does my good karma mean my soul will be saved after I die?
08:26:19 <lpsmith> lol
08:26:35 <lpsmith> The metaphysical interpretation is left up to the karma holder?
08:26:41 <Jafet> Programmers have no souls
08:26:41 <SamB_XP_> Fare: with lambdabot tracking it, I'm afraid you'd be lost if that was how it worked ;-P
08:26:56 <lpsmith> Yeah,  it seems that karma was reset sometime in the recent-ish past
08:27:01 <SamB_XP_> Jafet: I thought that was *lawyers*
08:27:07 <lpsmith> I used to have a karma of 1 or 2,  IIRC
08:27:19 <lpsmith> I know C had a karma of 1 within the last few weeks
08:27:30 <ski> Fare : it might mean that when you get garbage collected, a finalizer will execute your final will
08:27:31 <Jafet> A lawyer has a soul, it's with the devil
08:27:39 <SamB_XP_> lpsmith: the mystery is how it *had* that karma
08:27:40 <Heffalump> ski: at some indefinite point afterwards
08:27:46 <ski> Heffalump : of course
08:27:46 <Twey> @karma Twey
08:27:47 <lambdabot> You have a karma of 2
08:27:48 <Fare> ski: what if that final will makes me undead?
08:27:50 <Twey> @karma C
08:27:51 <lambdabot> C has a karma of 0
08:27:57 <Twey> Phew
08:28:04 <SamB_XP_> Fare: that's only allowed in Java, I think
08:28:06 <lpsmith> c++
08:28:10 <lpsmith> @karma c
08:28:10 <Twey> I was worried that C > me for a moment there :þ
08:28:11 <lambdabot> c has a karma of 0
08:28:50 <SamB_XP_> see, I told you it was a mystery
08:28:51 <Heffalump> @karma Heffalump
08:28:52 <lambdabot> You have a karma of 0
08:28:56 <Heffalump> uhoh
08:28:56 <SamB_XP_> C--
08:28:59 <SamB_XP_> @karma C
08:28:59 <lambdabot> C has a karma of 0
08:29:01 <ski> @karma Java
08:29:01 <lambdabot> Java has a karma of -5
08:29:07 <Heffalump> I'm about to be overtaken by C :-(
08:29:19 <Jafet> C seems to be on the blacklist now
08:29:25 <aavogt> @karma Haskell
08:29:25 <lambdabot> Haskell has a karma of 51
08:29:31 <SamB_XP_> Jafet: has been blacklisted for a long time
08:29:39 <SamB_XP_> that's why I found it puzzling when C had a karma of 1
08:29:57 <aavogt> @karma i
08:29:57 <lambdabot> i has a karma of 8
08:30:05 <Twey> Haha
08:30:10 <SamB_XP_> hehehehe
08:30:14 <ski> @karma C--
08:30:14 <lambdabot> C-- has a karma of 3
08:30:27 <Badger> @karma Twey
08:30:27 <lambdabot> Twey has a karma of 2
08:30:35 <Jafet> @karma g
08:30:35 <lambdabot> g has a karma of 74
08:30:46 <SamB_XP_> heh
08:31:02 <SamB_XP_> I guess people got a lot of C++ compiler errors?
08:31:07 <trofi> @karma ++
08:31:08 <lambdabot> ++ has a karma of 4
08:31:12 <Badger> i++
08:31:34 <lpsmith> I know,  I'll just sign into the channel with a nick of lpsmith++ :-P
08:32:05 <trofi> or flood lambdabot privately
08:32:26 <lpsmith> you can't modify your own karma :-P
08:32:36 <lpsmith> I suppose you could use a sockpuppet
08:32:41 <SamB_XP_> yeah
08:32:45 * ski waits for the channel to degenerate to `@pl' (ab)use
08:32:45 <Heffalump> or do a deal with someone
08:33:10 <SamB_XP_> ski: I really don't think you can use @pl to increase your karma ...
08:33:22 <lpsmith> Fare++ would this work to modify karma?
08:33:28 <lpsmith> @karma Fare
08:33:29 <lambdabot> Fare has a karma of 2
08:33:55 <lpsmith> see,  just sign in as lpsmith++,  and get people to give you karma everytime they single you out
08:34:02 <Twey> :-D
08:34:05 <ski> SamB_XP_ : well, probably not .. i was thinking of for the good cause
08:34:11 <Twey> @karma lpsmith
08:34:11 <lambdabot> lpsmith has a karma of 0
08:34:18 <Twey> lpsmith++: This doesn't work, I think
08:34:21 <Twey> @karma lpsmith
08:34:21 <lambdabot> lpsmith has a karma of 0
08:34:24 <lpsmith> Fare deserves two karma points for getting clog working, I guess
08:34:36 <ski> lpsmith++ : but this probably does
08:34:43 <Twey> @karma lpsmith
08:34:43 <lpsmith> heh
08:34:44 <lambdabot> lpsmith has a karma of 1
08:34:46 <Twey> Yep
08:34:49 <lpsmith> point taken
08:35:06 <Badger> lpsmith-- << point taken
08:35:17 <SamB> you can't use ++ in a nick anyway, it seems
08:35:47 * ski compulsory adds a space before the `:' on each attribution, in want of figuring out how to fix $CLIENT
08:36:03 <SamB_XP> ski: which client ?
08:36:17 <ski> /ctcp ski version
08:36:21 <SamB_XP> and what does it DO
08:36:53 <ski> (it gives me `SamB_XP: ' on tab-completion)
08:37:05 <gio123> ski: hi
08:37:10 <Twey> What's wrong with that?  :þ
08:37:10 <SamB_XP> ski: is that a problem?
08:37:29 <SamB_XP> heck, I don't care if it gives you "SamB_irssi: "
08:37:42 <SamB_XP> it still highlights for me ;-)
08:37:52 <SamB_XP> I mean, even for this one of me
08:37:53 <ski> SamB_XP : only in my (probably bad) aestethics, i think
08:38:13 <Twey> ski: /set completion_char  :
08:38:45 <Twey> (if you add a space before the colon then you should also add an extra space after the colon, as was the wont when such was grammatically fashionable)
08:39:38 <ski> (Twey : i do .. and ty)
08:39:51 <ski> (or maybe you mean "Twey :  foo !" ?)
08:39:58 <Twey> Indeed
08:40:16 <aavogt> ski       :               why not like this?
08:40:30 <Twey> aavogt: Because it invites violence.
08:40:34 <Twey> ☺
08:40:49 <SamB_XP> Twey: hmm ... that's the wrong smiley
08:40:54 <SamB_XP> and you need it WHITE ON BLUE
08:40:58 <ski> aavogt : i suppose you could do that, but it seems needless, if you don't want to align to something
08:41:11 <Twey> SamB_XP: Wrong how?
08:41:15 <Twey> Yes, the Unicode name annoys me
08:41:23 <Twey> Seeing as for me it's more like GREY ON TEAL
08:41:40 * aavogt sees a ?
08:41:45 <SamB_XP> well, I think you want #CHAR 3 WHITE ON BLUE
08:41:51 * SamB_XP is making ZZT jokes
08:42:05 <Twey> *whoosh*
08:42:05 <SamB_XP> aarong_: it was the smiley-outline character
08:42:15 <SamB_XP> rather than the filled smiley
08:42:22 <SamB_XP> of ZZT fame
08:42:41 <aavogt> I see
08:42:41 <SamB_XP> that was, like, Epic Megagames' first game
08:43:13 <SamB_XP> it was a third-person puzzle shooter in text mode
08:43:48 <SamB_XP> now available for free download ;-)
08:44:37 <SamB_XP> with implications that the code may be used in whatever manner is desired, and that the source would be provided as well if it hadn't been lost to a hard drive failure :-(
08:49:01 <en0th> why a " read 'PATH' :: String " gives an exception:no parse?
08:49:24 <en0th> (the file is a simple text file)
08:50:03 <ski> `read' reads a datum from a string, it doesn't open a file from a file path
08:50:13 <aavogt> > read "\"string\"" :: String
08:50:14 <lambdabot>   "string"
08:50:24 <ski> also  'PATH'  is invalid syntax for a string
08:50:48 <gwern> en0th: are you tryin to get $PATH?
08:50:49 <ski> > ['P','A','T','H']
08:50:50 <lambdabot>   "PATH"
08:50:54 <en0th> nono
08:51:08 <en0th> was a shortcut to not include my full filepath
08:51:15 <aavogt> readFile is what you want?
08:51:16 <en0th> here in irc i mean
08:51:24 <en0th> :t readFile
08:51:25 <lambdabot> FilePath -> IO String
08:52:12 <en0th> i should smell something was wrong.. read has not that type!
08:52:17 <ski>   type FilePath = String  -- just an alias
08:52:17 <Cale> :t read
08:52:18 <lambdabot> forall a. (Read a) => String -> a
08:52:26 <Cale> > read "567" :: Integer
08:52:27 <lambdabot>   567
08:52:35 <SamB_XP> ski: I expect he actually had "path"
08:52:40 <Cale> > read "[1,2,3,4,5]" :: [Integer]
08:52:41 <lambdabot>   [1,2,3,4,5]
08:52:59 <SamB_XP> ski: but just wanted to use different quotation marks from "" because he'd already used that
08:53:21 <en0th> yes..
08:53:25 <SamB_XP> and didn't realize this isn't like Python where the two types are almost identical -- with the exception of which is allowed unescaped inside
08:53:57 <ski> SamB_XP : i see
08:53:58 * Twey thinks ‘’ and “” should be accepted by Unicode-capable Haskell implementations.
08:54:14 <SamB_XP> Twey: nestable, too?
08:54:19 <Twey> Aye.
08:54:26 <gwern> > read "1 : 2 : 3 : 4 : 5 : []" :: [Integer]
08:54:27 <lambdabot>   * Exception: Prelude.read: no parse
08:54:32 <SamB_XP> that might make parsing a bit more complicated, but I guess it's not unreasonable to want
08:54:32 <gwern> oh come on
08:54:46 <en0th> anyways, i've written down something from "implementing functional languages". nothing seems to work :D
08:55:02 <gwern> Twey: and real lambdas! and actually, all the unicode transforms listed in Yi.Unicode :)
08:55:07 <SamB_XP> on the other hand, unlike comments, strings actually have to be interpreted
08:55:31 <aavogt> en0th: doesn't that book use Miranda?
08:55:32 <SamB_XP> so ... it would still be a pain to use unbalanced nested “” ...
08:55:51 <en0th> yes, i translated in haskell
08:56:09 <SamB_XP> en0th: maybe you didn't do it right ;-)
08:56:32 <SamB_XP> not that we'll think any less of you for that -- I haven't even gotten around to *attempting* such a feat
08:57:04 <en0th> the fun part is: i use haskell since a week ago, never used miranda, and i don't know anything about fl.
08:57:09 <SamB_XP> anyway, why not hpaste or codepad it?
08:57:17 * ddarius translated all of Burstall's "Computational Category Theory" from ML to Haskell but lost the source code a while back.
08:57:19 <aavogt> SamB_XP: at least superficially, the languages are very similar
08:57:20 <FunctorSalad_> shouldn't gwern's read succeed?
08:57:24 <SamB_XP> @where hpaste
08:57:25 <lambdabot> http://hpaste.org/
08:57:28 <SamB_XP> @where codepad
08:57:28 <lambdabot> codepad.org
08:57:50 <aavogt> > read "1:[]" :: [Integer]
08:57:51 <lambdabot>   * Exception: Prelude.read: no parse
08:57:55 <SamB_XP> hmm ... mmorrow, shouldn't there be two urls for hpaste ?
08:58:16 <aavogt> @hpaste
08:58:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:58:22 <en0th> i've just spotted another attempt!
08:58:35 <en0th> http://paste.lisp.org/display/32661#1
08:58:36 <SamB_XP> @where+ hpaste http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
08:58:36 <lambdabot> It is forever etched in my memory.
08:59:10 <FunctorSalad_> > read "1 : []" :: [Integer]
08:59:11 <lambdabot>   * Exception: Prelude.read: no parse
08:59:31 <FunctorSalad_> oh right, it's not an arbitrary haskell parser ;)
08:59:36 <aavogt> > read "(,) 1 2" :: (Integer,Integer)
08:59:37 <lambdabot>   * Exception: Prelude.read: no parse
08:59:42 <FunctorSalad_> > read "[1,2]" :: [Integer]
08:59:43 <lambdabot>   [1,2]
09:00:14 <burp> > read . show $ [1,2] :: [Integer]
09:00:15 <lambdabot>   [1,2]
09:01:03 <en0th> SamB_XP: my goal is only to understand the graph reduction from a practical point of view, while following that book you're forced to worry about parsing etc..
09:01:20 <HugoDaniel1> is it okey if i write a huge entry on haskell cafe ?
09:01:33 <HugoDaniel1> i need some opinions on something ive been trying to work on
09:01:58 <HugoDaniel1> maybe ill create a blog, write a post and paste there
09:02:13 <SamB_XP> en0th: you could skip that and just enter the syntax trees as expressions or strings for Read ...
09:02:40 <SamB_XP> technically, the latter doesn't quite count as skipping, but since Read is derivable ...
09:03:42 <gwern> HugoDaniel1: or just write an article on the wiki
09:03:44 <gwern> even faster
09:04:07 <en0th> SamB_XP: yes, that's what i'll do since now.
09:05:03 <en0th> Anyway, has been a bruteforce introduction to FL. One week ago i didn't know anything about that
09:08:42 <HugoDaniel1> gwern: isn't that a bit too "official" ?
09:08:47 <gwern> no
09:08:52 <gwern> you ever look through the wiki?
09:10:46 <HugoDaniel1> gwern no :/
09:11:02 <HugoDaniel1> i usually only read the hackage package description
09:11:12 <HugoDaniel1> and one or two blogs...
09:12:04 <HugoDaniel1> also, and unrelated
09:12:35 <HugoDaniel1> im planing on ditching the standard record field access methods
09:12:55 <HugoDaniel1> what do you recomend? data-accessor, lenses, editors ? (are these complimentary?)
09:14:04 <Heffalump> is editors Conal's one?
09:15:11 <HugoDaniel1> yes heffalump
09:15:23 <HugoDaniel1> "semantic editor combinators" is just a huge name
09:15:30 <Heffalump> generally speaking I'd recommend his stuff because it's always really elegant
09:15:37 <HugoDaniel1> seems like one of those marketing puffs :)
09:15:46 <Heffalump> but I don't fully understand if it's equivalent to the first class record stuff
09:15:57 <Heffalump> there's lenses, data-accessor and fclabels
09:16:59 <Heffalump> the hackage package is DeepArrow, right?
09:17:08 <Heffalump> I don't think it has any TH to generate things automatically
09:17:50 <HugoDaniel1> yes, deeparrow
09:19:14 <HugoDaniel1> Heffalump: so, no TH = better ?
09:20:04 <EvilTerran> HugoDaniel1, well, that's a matter of opinion
09:20:16 <EvilTerran> HugoDaniel1, but using TH means using GHC, iirc
09:21:13 <aavogt> you can get ghc to dump the results of the TH, so that it can be included in haskell implementations that aren't ghc
09:22:24 <aavogt> that may be inconvenient, but writing all the boilerplate setters and getters manually is worse (but maybe conal's solution isn't so painful?)
09:22:27 <HugoDaniel1> well, i like ghc, so its no problem for me :)
09:22:43 <HugoDaniel1> ghc is implement for lots of platforms, right ?
09:22:51 <HugoDaniel1> s/implement/implemented
09:23:16 <Jafet> If by "lots of platforms" you mean "the platforms ghc has been ported to", yes
09:23:51 <HugoDaniel1> yes, that
09:23:52 <HugoDaniel1> ok
09:24:22 <Jafet> If you're interested, they cover most of the common platforms by mass and volume
09:24:54 <nomeata> Hi. I’m looking for a way to efficiently serialize a large number of values of the following kind:
09:24:57 <nomeata> TimeLogEntry {tlTime = 2009-10-03 16:22:44.780558 UTC, tlRate = 60000, tlData = CaptureData {cWindows = [(False,"d-devel (245 ungelesen, 1110 insgesamt) - Evolution","evolution"),(False,"Data.ByteString.Char8","galeon"),(False,"jojo@kirk: /home/jojo","gnome-terminal"),(False,"TimeLog.hs (~/projekte/programming/arbtt/src) - GVIM2","gvim"),(False,"Categorize.hs (~/projekte/programming/arbtt/src) - GVIM","gvim"),(False,"jojo@kirk: /home/jojo/projekte/programmi
09:24:58 <nomeata> ng/arbtt","gnome-terminal"),(False,"jojo@kirk: /tmp","gnome-terminal"),(True,"jojo@kirk: /tmp","gnome-terminal"),(False,"jojo@kirk: /home/jojo","gnome-terminal")], cLastActivity = 54286}}
09:25:16 <Axman6> nomeata: Data.Binary
09:25:39 <nomeata> I need fast append to the store, and I want to parse >10000 of these
09:26:00 <nomeata> Axman6: hmm. I’m reluctant to use something binary, to make it easier to extend it later.
09:26:05 <Axman6> 'fast append to the store'?
09:26:20 <Axman6> nomeata: ckeck out Data.Binary. it
09:26:34 <nomeata> Axman6: currently, I just write them via show line-by-line to a text file, where I can easily append an entry
09:26:35 <Axman6> it's really nice to use, and fairly easy to extend
09:27:11 <Axman6> @hoogle ByteString -> ByteString -> ByteString
09:27:12 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
09:27:12 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
09:27:12 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
09:27:40 <ski> (Heffalump : the kackage packege for what is `DeepArrow' ?)
09:27:41 <FunctorSalad_> hmm, if you don't want binary, what kind of format that is better than Show are you hoping for? :)
09:27:54 <Axman6> yeah, using append, you can easily apped new elements
09:27:54 <Axman6> append*
09:28:02 <Jafet> nomeata, human-readable serialization usually tends to be a tad slower
09:28:08 <nomeata> FunctorSalad_: dunno, that’s why I’m asking
09:29:44 <Axman6> seriously, Data.Binary is really easy to use, it should do just what you want
09:29:45 <ksf> thinks like serialising to ebml and having a gui should be faster
09:29:48 <Axman6> hopefully
09:30:01 <Axman6> ebml?
09:30:25 <ksf> http://www.matroska.org/technical/specs/rfc/index.html
09:30:33 <FunctorSalad_> Axman6: he has a different reason for not using binary than ease of use..
09:30:50 <ksf> ...which reminds me, there's a half-baked ebml library around that I should complete
09:30:54 <nomeata> Axman6: I guess. But then I need to think careful when designing my Binary instance so that I can later add more fields.
09:31:12 <Axman6> hmm, true
09:31:30 <Axman6> well, then i'd go with Show/Read
09:35:08 <nomeata> hmm. but the speed is just too slow. I guess Data.Binary is the way to go.
09:35:34 <phantomm> Hello.. I'm learning haskell and struggling with cabal. "cabal install Text.CSV" says: "cabal: Failed to parse package dependency: "Text.CSV"".. what am I doing wrong?
09:36:23 <Axman6> phantomm: you need the name of the package, not the name of the module
09:36:24 <wdonnelly> phantomm: Text.CSV is a module, you want the package that exports Text.CSV
09:36:41 <viator_sg> phantomm: try cabal install cvs
09:36:43 <Axman6> nomeata: even with Show/Read, you'll still have trouble when adding new fields
09:36:55 <viator_sg> ĉsv
09:36:59 <viator_sg> *csv :P
09:37:32 <nomeata> Axman6: I know, but I have the feeling that it will be easier to fix. But I might be wrong, and it’s all just based on a general reluctance to use binary data.
09:38:29 <Axman6> nomeata: Data.Binary really is lovely. you should really check it out. if you think about things, you can do some really cleaver stuff too. but you can also be naive about it, and get good results
09:39:27 <en0th> :t pure
09:39:28 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:39:41 <FunctorSalad_> it has inefficient doubles though
09:40:03 <Axman6> FunctorSalad_: huh?
09:40:12 * phantomm is quite confused... cabal install csv works.. but for future reference how can I find out which package a module is in?
09:40:17 <nomeata> One advantage with appending lines to the textfile is that if the write gets b0rked and is incomplete, one line might not be parsable, but I can ignore that and read the next line. When designing a binary interface this is a bit harder.
09:40:35 <phantomm> (I'm looking at hackage.haskell.org)
09:40:52 <FunctorSalad_> > encode 0.0 -- Axman6
09:40:53 <lambdabot>   Not in scope: `encode'
09:40:58 <FunctorSalad_> > Data.Binary.encode 0.0 -- Axman6
09:40:59 <lambdabot>   Not in scope: `Data.Binary.encode'
09:41:15 <FunctorSalad_> Axman6: anyway, result is Chunk "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL" Empty
09:41:58 <Axman6> encode 1.0 is better
09:41:59 <phantomm> ok, found.. It's in the "Contents" tab... Thanks!
09:43:28 <FunctorSalad_> Axman6: ?better
09:43:38 <Axman6> more strange :)
09:43:57 <Axman6> it should really use the IEEE format, but oh well
09:44:19 <FunctorSalad_> it's machine-format-agnostic afaik
09:44:43 <jfredett> Has anyone got the HWN yet??
09:45:27 <ddarius> jfredett: Nope.
09:45:37 <en0th> > pure 1 :: (String, Int)
09:45:38 <lambdabot>   ("",1)
09:45:51 <jfredett> hmm.
09:45:54 <en0th> black magic
09:46:06 <FunctorSalad_> jfredett: me neither
09:46:56 <jfredett> Hopefully this won't triple-send it again.
09:47:15 <jfredett> I just tried it again. sendmail is pretty fickle.
09:48:24 <jfredett> there we go, it shows up (once) in pipermail.
09:48:37 <jfredett> apparently sendmail doesn't respect the FROM: field...
09:48:53 <FunctorSalad_> jfredett: success
09:48:57 <Axman6> @instances Applicative
09:48:58 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:49:06 <FunctorSalad_> ARRRplicative
09:49:40 <en0th> @instances Control.Applicative
09:49:41 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
09:49:56 <jfredett> @instances Int
09:49:56 <lambdabot> Couldn't find class `Int'. Try @instances-importing
09:50:02 <FunctorSalad_> ,, src (,)
09:50:03 <lunabot>  luna: parse error on input `src'
09:50:11 <FunctorSalad_> ,halp
09:50:16 <lunabot>  luna: Not in scope: `halp'
09:50:17 <FunctorSalad_> ,help
09:50:21 <lunabot>  type of an expression:      , [$ty| \x -> x |]
09:50:21 <lunabot>  get info for a type/class:  , src ''Monad
09:50:21 <lunabot>  get info for a var/con:     , src 'fix
09:50:26 <jfredett> hmm, I thought it only worked on types fo some reason... :/
09:50:40 <gwern> @quote ByteString
09:50:41 <lambdabot> ozone says: when will bytestring be O(1) for all operations?
09:50:43 <gwern> @quote ByteString
09:50:43 <lambdabot> ozone says: when will bytestring be O(1) for all operations?
09:50:45 <gwern> @quote ByteString
09:50:46 <lambdabot> ozone says: when will bytestring be O(1) for all operations?
09:50:55 <gwern> @remember pozic I think if you want to contact dons, you have to say that you found a bug in ByteString.
09:50:56 <FunctorSalad_> , src ''Applicative
09:50:56 <lambdabot> I will remember.
09:50:59 <lunabot>  class (Functor f) => Applicative f where
09:50:59 <lunabot>          pure :: forall a . a -> f a
09:50:59 <lunabot>          (<*>) :: forall b a . f (a -> b) -> f a -> f b
09:51:03 <gwern> @quote crouching
09:51:03 <lambdabot> No quotes match. Just what do you think you're doing Dave?
09:51:12 <gwern> @remember Veinor [about dibblego kicking a whole bunch of spammers] crouching dibblego, hidden op
09:51:13 <lambdabot> Good to know.
09:51:22 <FunctorSalad_> hmm thought it would dump the instances too, like :info does
09:51:23 <gwern> @quote wizard
09:51:24 <lambdabot> No quotes match. You untyped fool!
09:51:31 <FunctorSalad_> since apparently it uses reify
09:51:35 <gwern> @remember allbery_b [on UndecidableInstances] 'this exceeds my easy threshold, turn on wizard mode' (at which point it becomes a lot smarter but may start contemplating its navel without warning)
09:51:36 <lambdabot> Done.
09:51:40 <gwern> @quote subway
09:51:41 <lambdabot> No quotes match. You type like i drive.
09:51:54 <gwern> @remember byorgey a bus error? try recompiling with -fsubway, perhaps
09:51:55 <lambdabot> Good to know.
09:52:03 <gwern> @quote zygomorphism
09:52:03 <lambdabot> jafet says: "Zygomorphism" sounds like a reproductive disorder
09:52:07 <gwern> @flush
09:52:56 <FunctorSalad_> "Hey there! lunabot is using Twitter."
09:53:38 <ksf> so what did she have for breakfast?
09:53:50 <FunctorSalad_> functional programmers :o
09:55:59 <ksf> scala is insanely polymorphic.
09:56:08 <Gracenotes> Wheat Lambdas
09:56:26 <Optimo> doublestuff lambda
09:56:47 <nlogax> fmap crackle & pop
09:56:53 <ksf> translated to haskell, if you have 'if foo then "bar" else 1', scala infers that to be Show a => a
09:57:14 <Optimo> handy that
09:57:29 <ksf> ..."Show a" being called "Any", the inheritance root, as any jvm-object has a toString, anyways.
09:57:48 * ksf thinks its a source of bugs
09:58:18 <Berengal> ksf, not too hard to spot though
09:58:42 <ksf> there's nothing wrong with _allowing_ that to be Show a => a, but inferring that type goes a bit too far.
09:58:47 <Berengal> Kind of like when you write a function that's 'a -> b', or have a value that's 'a', you know there's a bottom hiding somewhere
09:58:51 <FunctorSalad_> conversions to string are implicit?
09:59:04 <ksf> well depends.
09:59:31 <ksf> toString on a String is id, so I guess everthing println-alike calls toString on its argument, no matter what.
09:59:34 <FunctorSalad_> assuming that if-statement doesn't have a dependent type D:
10:00:05 <ddarius> It's just subsumption from subtyping.
10:00:26 * nomeata is confused by DiffTime and NominalDifftime
10:01:05 <ksf> I would prefer inference to be limited to explicit subtypes of each another. if you want to return two sibling types, annotate a supertype.
10:01:08 <Berengal> I want subtyping in haskell... Something like 'foo :: (a <: bar*String) => a -> String; foo a = bar a'
10:01:11 <nomeata> It says "If you don't care about leap seconds, use UTCTime and NominalDiffTime for your clock calculations, and you'll be fine.", but what would I use instead of utctDayTime then?
10:01:21 <ddarius> Berengal: See O'Haskell.
10:02:20 <ksf> scala does the functional/opp mix really good, though.
10:02:41 <FunctorSalad_> "a <: bar*String"??
10:03:07 <Berengal> FunctorSalad_, a type that's a subtype of the record {bar :: String}
10:03:18 <FunctorSalad_> the star is confusing
10:03:22 <FunctorSalad_> I read that as product
10:03:28 <ksf> kleene.
10:03:30 <ksf> as in *char
10:03:47 <Berengal> The star is arbitrary
10:03:59 <ksf> yep, it'd be String *bar
10:04:34 <FunctorSalad_> can't you just use a class?
10:04:56 <FunctorSalad_> HasBar a where bar :: a -> String
10:04:56 <ksf> well, let's all learn scala and get ourselves some loot for haskell.
10:05:31 <ksf> ...you don't want to type such stuff.
10:05:40 <Berengal> FunctorSalad_, you'd also need a setBar function
10:06:09 <FunctorSalad_> well, I wouldn't like to add new foundational primitives just to save some typing
10:06:15 <FunctorSalad_> that's what preprocessors are for
10:06:39 <FunctorSalad_> $(makeGetSetClass "bar")
10:06:58 <ksf> yep.
10:07:21 <ksf> ...and as soon as everything, taken together, makes an aweful lot of sense, demand a compiler extension.
10:07:39 <Berengal> Probably the way to go
10:07:55 <ksf> I've got little doubt that beyond-the-state-of-the-art oop stuff can be formulated in the existing type system.
10:08:12 <ksf> ...see oohaskell.
10:08:25 <ksf> and oleg didn't even have type families, then.
10:08:54 <ski> (O'Haskell ?)
10:09:07 <Berengal> What about 'instance (a <: b, b <: c) => a <: c' ?
10:09:15 <ksf> nope that's a different beast
10:09:18 <ksf> http://homepages.cwi.nl/~ralf/OOHaskell/
10:09:23 <sproingie> O'Haskell is long gone, replaced by timber
10:09:35 <Berengal> oop is broken... Subclassing isn't subtyping
10:09:39 <sproingie> last i looked at timber it looked very like a vanilla OO language.  wonder if it compiles to haskell
10:10:04 <ddarius> sproingie: Timber is the successor to O'Haskell, but it includes quite a few differences.
10:10:15 <ksf> dunno how well it works right now, though, as it was released it had problems with larger objects or something, grinding ghc's type system to a halt.
10:10:37 <ksf> (with "larger" being say 5 methods or an 6-element inheritance chain or something)
10:10:37 <ddarius> Berengal: OOP doesn't mean conflating subtyping and subclassing (though that is what most mainstream OOP languages do)
10:10:56 <ksf> timber compiles to c
10:11:12 <Berengal> ddarius, true, but I still think subclassing breaks things
10:11:31 <idnar> OOP doesn't mean subclassing, either
10:11:32 <ksf> we're doing mixins all the time.
10:11:52 <Berengal> idnar, it usually does
10:12:13 <ksf> we even share implementation, using deriving clauses and such
10:12:28 <Gracenotes> the only true OOP is prototypical inheritance. nay, true OOP involves C and passing pointers to structs!
10:12:33 <FunctorSalad_> I think I just have an irrational dislike of OO ;)
10:12:50 <idnar> Berengal: well, sure, but that seems like an irrelevant generalisation :P
10:13:00 <orbitz> why is it called 'lifting a function'?  I would think of it the other way, we are lifting a value out of something to apply a function to it, then putting the result back in its box
10:13:11 <SamB_XP> Gracenotes: true OOP just means having "object" interfaces that can have multiple implementations
10:13:15 <idnar> it's like taking all of the problems with C, and concluding that static typing is broken
10:13:33 <ksf> Gracenotes, yep. if you want a crisp object type say type Foo = HasMethod Foo :# HasField Bar or something.
10:13:47 <orbitz> what is the different becween subtyping and subclasses?
10:13:49 <idnar> orbitz: but you can't lift the value, you can only lift functions that operate on the value
10:13:52 <mauke> orbitz: the "box" is special powers
10:13:57 <SamB_XP> idnar: even though at least 50% of C's problems are unrelated to the typesystem ;-P
10:14:07 <idnar> SamB_XP: exactly
10:14:12 <mauke> orbitz: by lifting the function you give it the ability to work on values with special powers
10:14:14 <Gracenotes> I like Kay's opinion that the important part of OOP is the interactions between the objects, not the objects themselves
10:14:28 <SamB_XP> Gracenotes: that's quite true
10:14:52 <SamB_XP> the main problem with COM, I think, is IUnknown ...
10:15:11 <mauke> orbitz: e.g. []'s special powers is multiple values at once
10:15:12 <sproingie> IUnknown itself is a workaround for C++'s problems with MI
10:15:31 <SamB_XP> see, COM should never have been based on C++
10:15:31 <mauke> lifting a function to [] (with map) lets it work on multiple values at the same time
10:15:33 <sproingie> since you can't count on differently-derived base class pointers to be equal
10:15:34 <orbitz> but, for example, in liftA2, the function doesn't knwo about []
10:15:42 <ksf> ha! scala has null just for java compability. You're supposed to use None and Some, subclasses of Option
10:15:54 <orbitz> ksf: it also as AnyRef
10:15:56 <orbitz> blech!
10:16:02 <sproingie> COM did all right.  OSKit is based on it too.
10:16:04 <SamB_XP> ksf: why is that a "ha!" thing
10:16:09 <SamB_XP> that would be more of a :-(
10:16:20 <idnar> orbitz: the lifted function does
10:16:21 <SamB_XP> sproingie: didn't mean to imply that COM was anywhere near unusable because of it ...
10:16:30 <ksf> maybe I should've ephazised that "just" more.
10:16:32 <SamB_XP> just that that seems to be the most painful aspect
10:16:38 <ksf> java's the culprit, not scala.
10:16:39 <sproingie> C++ was perhaps not the wisest choice to base an ABI on
10:16:44 <idnar> orbitz: you give liftA2 a function without special powers, and get a function back that has them
10:16:51 <sproingie> considering it's historically not had a stable one
10:16:55 <SamB_XP> ksf: I still don't get your point
10:17:00 <orbitz> ksf: well, Scala impl could have just wraped all java functions to use Some/None if it wanted
10:17:16 <ksf> ...ALL, yes.
10:17:18 <ski> @where object-oriented
10:17:18 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
10:17:24 <orbitz> whatever the reason, IMO it's a big redmark against Scala tha tit has Null
10:17:32 <ksf> unsafePerformJava
10:18:23 <sproingie> i'd call it a mark against java.  scala can't completely break away and still interoperate easily
10:18:24 <Gracenotes> instance Applicative IO where pure = return; a <*> b = launchMissiles >> liftM2 ($) a b
10:18:25 <ksf> well haskell has pointer-arithmetik. that is'nt cleaner, either.
10:18:41 <SamB_XP> orbitz: Isn't ~ as evil as _|_ ?
10:18:46 <Jafet> Why does Scala need null, anyway?
10:18:53 <ksf> because of java
10:19:06 <orbitz> SamB_XP: ~?
10:19:07 <ksf> ...there's a load of libs that return null references.
10:19:07 <SamB_XP> some libraries may have dumb interfaces that use null, I guess
10:19:09 <Jafet> But scala isn't java, it just happens to use the same implementation of it
10:19:10 <Gracenotes> often used as a flag of sorts in java standard library
10:19:13 <SamB_XP> orbitz: approximately
10:19:16 <sproingie> scala makes a lot of compromises
10:19:23 <SamB_XP> Jafet: libraries!
10:19:25 <orbitz> SamB_XP: it might be
10:19:35 <sproingie> i think scala gets us halfway there
10:19:47 <orbitz> Jafet: it's trying to work with Java though, so you can call java code
10:19:48 <sproingie> clojure is also making FP cool
10:19:52 <SamB_XP> but, compromises aren't exactly dumb
10:20:14 <SamB_XP> some of those Java libraries are pretty dang useful ...
10:20:31 <nomeata> Is there a nicely named function for "foldr (.) id" in the standard libs? I can’t find one.
10:20:39 <kynky> like swing ?
10:20:43 <Gracenotes> imperative languages with sophisticated type features, would be interesting. Scala seems to get part of it
10:20:50 <ski> it should be named something like `compose', imo
10:21:09 <Gracenotes> @hoogle [(a -> a)] -> a -> a
10:21:09 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
10:21:10 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
10:21:10 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
10:21:18 <SamB_XP> nomeata: I think you need to use (mconcat . map Endo)
10:21:24 <mauke> nomeata: no
10:21:29 <SamB_XP> @hoogle Endo a -> a -> a
10:21:29 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
10:21:29 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:21:29 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:21:44 <Jafet> @hoogle (a -> a) -> (a -> a) -> a -> a
10:21:44 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
10:21:45 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
10:21:45 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
10:21:45 <SamB_XP> :t appEndo . mconcat . map Endo
10:21:46 <lambdabot> forall a. [a -> a] -> a -> a
10:22:21 <SamB_XP> Jafet: that's just (.), isn't it ?
10:22:26 <Berengal> appEndo sounds like some cheesy list-combinator library...
10:22:28 <nomeata> SamB_XP: hmm, hardly better or easier to remember than "foldr (.) id"
10:22:30 <Jafet> (.)(.)
10:22:59 <Gracenotes> You take your functions, you transform them map Endo / you mconcat them all, and then you appEndo.
10:23:00 <ddarius> nomeata: I would stick to the explicit foldr
10:23:04 <Gracenotes> Thank you, thank you, the first couplet's free
10:23:12 <SamB_XP> nomeata: indeed
10:23:51 <ddarius> mconcat on function types used to be foldr (.) id, but then they changed it.  It confusingly broke my Prolog pretty-printer.
10:25:50 <orbitz> SamB_XP: i dn't know much about _|_, it may be as dangerous as null, but my impression is it doesn't show up as such a staple as it does in Java.  For example [] is an empty list in Haskell, in Java many programmers use null, to avoid constructing a new empty object
10:26:12 <SamB_XP> eww
10:26:15 <ddarius> orbitz: Java has _|_ too.
10:26:47 <orbitz> what is _|_?
10:26:48 <SamB_XP> ddarius: but can you bind it to a variable?
10:26:54 <orbitz> in java
10:27:05 <lpsmith> yup, every turing-complete programming language has _|_
10:27:17 <ddarius> SamB_XP: No, variables are unlifted.
10:27:19 <Berengal> SamB_XP, int foo = infiniteLoop();
10:27:31 <lpsmith> http://www.deanberris.com/mental-blabberings/2009/10/3/adjunct-to-c-in-haskell.html
10:27:40 <SamB_XP> Berengal: they have a method for that on Object ?
10:27:48 <lpsmith> ^^^ Looks like a candidate for a round of code golf
10:28:12 <SamB_XP> you are cruel, lpsmith !
10:28:36 <lpsmith> :o
10:28:48 <lpsmith> Why am I cruel?  :)
10:28:57 <Berengal> SamB_XP, _|_ is a subtype of all types, so you can call any method on it. Of course, since there's no syntax for the _|_ type in java, and everything is manifest, you have to declare it as a supertype
10:29:24 <Berengal> And then because Java is strict, you won't ever get to the point where the runtime tries to call the method
10:29:26 <orbitz> where is _|_ covere din RWH?
10:29:31 <SamB_XP> lpsmith: subjecting random blog posts to golfing!
10:30:54 <Alpounet> orbitz, IIRC, it isn't.
10:31:20 <orbitz> hrm, i swore it showed up at some point
10:31:42 <SamB_XP> Alpounet: surely it must appear in some guise or other!
10:32:53 <Eiler> cant you read real world haskell online anymore?
10:33:00 <mauke> preflex: ? rwh
10:33:00 <preflex>  http://book.realworldhaskell.org/read/
10:33:21 <Eiler> that dont work for me
10:33:25 <lpsmith> SamB_XP:   I mean, it's a nice post, but it doesn't strike me as particularly idiomatic Haskell
10:33:28 <Gracenotes> Real World Haskell? I'm not aware of any Real World Haskell existing, especially on the internet :o
10:33:31 <mauke> yeah, server isn't responding
10:33:44 <Eiler> obviously you havent heard of the book then
10:34:01 <SamB_XP> dons: what's up?
10:34:10 <Gracenotes> Eiler: hm, what chapter do you need? I have 1-7 saved on my computer
10:34:14 <orbitz> Gracenotes: the original name was "Imaginary World Haskell", it didn't pan out for some reason
10:34:38 <Gracenotes> without the interactive comments, of course..
10:34:39 <SamB_XP> orbitz: it turned out not to be closed over multiplication
10:34:47 <lpsmith> SamB_XP:  So maybe going the round of golf would be a little extreme :)
10:34:50 <Eiler> Gracenotes: all but i want to know if it is still supposed to be available or not
10:35:20 <Gracenotes> seems so. after all if there's a second edition they need more comments :)
10:35:30 <SamB_XP> Eiler: haven't heard anything to the contrary!
10:35:46 <SamB_XP> certainly it was still up for quite some time after the 1st edition ...
10:36:10 <Eiler> SamB_XP: ye, but it was a couple of months since i last checked it out
10:37:01 <SamB_XP> I'd assume it's just a server outage
10:37:12 <mesache> q
10:37:21 <SamB_XP> mesache: yeah?
10:37:35 <Eiler> dons: the real world haskell read online site is down
10:37:44 <mesache> sorry, just beginner here
10:37:46 <monochrom> /quit
10:38:25 <Gracenotes> or perhaps he wanted to talk about kumquats
10:38:39 <kynky> gcache rwh
10:39:23 <Gracenotes> internet archive too
10:40:44 * SamB_XP gets a strange sense of deja vu from what Gracenotes just said
10:40:52 * SamB_XP looks for agents
10:46:07 <gwern> @quote kumquat
10:46:07 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
10:47:41 <sproingie> quite an obsession with produce here
10:50:38 <gwern> sproingie: we're all about programmer productivity
10:54:38 <hackagebot> arbtt 0.2.0 - Automatic Rule-Based Time Tracker (JoachimBreitner)
10:55:37 <SamB_XP> gwern: I think he meant fruits and veggies
10:56:12 <gwern> SamB_XP: I know we're very tolerant of deviant, non-mainstream tastes and practices here, but - veggies? that's a new one on me
10:56:26 <SamB_XP> gwern: for instance, the rutabega
10:56:41 <SamB_XP> or the kumquats
10:56:42 * gwern slaps SamB_XP. how dare you!
10:56:46 <Jafet> We don't need quiche, and we don't need veggies!
10:56:52 * Jafet passes twinkies
10:56:58 <SamB_XP> I like quiche, actually ;-P
10:57:26 <SamB_XP> and now I'm confused about whether it's supposed to be high-brow or low-brow
10:58:04 <gwern> it's highbrow unless it's stuffed with bacon; then it's low-brow technoproletariat
10:58:57 <SamB_XP> I actually prefer mine without eyebrows
10:59:13 <Jafet> Bacon eyebrows
10:59:23 <Jafet> Sounds like something you'd get in China
11:01:12 <dons> Eiler: ok.
11:01:12 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
11:09:03 <Berengal> Is there some untilM function somewhere?
11:09:33 <EvilTerran> Berengal, sadly not
11:09:49 * Berengal writes one
11:11:14 <ddarius> @hoogle untilM
11:11:14 <lambdabot> No results found
11:15:54 <aavogt> any haddock experts know how to align an included image?  I have -- <<http://xyz.domain/img.png>>
11:16:08 <dons> i didn't know you could include images
11:16:11 <dons> i should do that.
11:16:12 <aavogt> but it is left-aligned when it would be nice to have it centred in the generated html
11:16:30 <monochrom> No way yet.
11:17:30 <dons> if haddock started parsing markdown in comments, would it be the end of the world.
11:17:51 <dons> ?
11:18:06 <earthy> not if that were a configurable option
11:18:15 <Eiler> dons: the real world haskell read online pages/server, is it something you can bring up?
11:18:27 <dons> bos has to reset the server.
11:18:32 <Eiler> okay
11:18:32 <dons> so let's keep an eye out for him.
11:19:36 <monochrom> Very few things done by software can end the world. :)
11:20:16 <monochrom> What is markdown? Is it not markup?
11:20:34 <monochrom> Oh, markdown is a specific markup language.
11:20:37 <Twey> Markdown is a simple human-readable formatting system.
11:20:48 <dons> using pandoc, in particular
11:20:55 <dons> so we can generate .pdf and other nice formats.
11:21:11 <dons> then i stich together hackage.pdf and we have a 10,000 page api book
11:23:28 <dons> we'd probably have used markdown if we designed haddock now, i think.
11:23:37 <dons> at least start with it, instead of inventing our own markup format
11:23:44 * Twey uses Markdown for all sorts of comment systems.
11:23:54 <dons> yeah
11:24:08 <Twey> It even has a safe mode
11:24:13 <dons> i use markdown for all note taking, with the happy benefit of pandoc to convert it to html et al.
11:24:26 <dons> though trac and mediawiki inconsistencies still annoy me
11:24:41 <Twey> You have to be a bit careful with headings if you're going to embed it, though
11:25:06 <Twey> There's no option to downscale headings by default, and you don't want users adding a <h1> when you use it for the title of the page :þ
11:25:16 <Twey> I suspect that's not Trac's fault
11:25:24 <Twey> Some of the older Python implementations are a bit crap
11:26:20 <gwern> dons: hm, but we'd have to extend markdown anyway. Even if you repurposed links so [Control.Monad.Reader]() worked right, you'd still need something for functions and other stuff
11:26:26 <Twey> I'm using markdown2 nowadays
11:26:39 <EnglishGent> hello
11:26:41 <EnglishGent> :)
11:26:43 <Twey> Hi there
11:26:49 <EnglishGent> hi Twey :)
11:31:09 <aavogt> monochrom: and there is still no way to attach documentation to specific class instances either, right?
11:32:41 <monochrom> That one I don't remember.
11:32:59 <dolio> I don't think there is.
11:33:50 <gwern> what the heck. yi's template haskell errors out on libgdk-pixbuf2, which I have installed; the usual solution is to install -dev, but there *is* no libgdk-pixbuf2-dev
11:33:52 <dolio> Considering that instances only show up as lists underneath the class and the datatypes.
11:35:03 <gwern> guess I'll reinstall gtk2hs and hope that makes the error go away...
11:40:24 <gwern> nope, same error
11:42:24 <monochrom> gwern: There is some chance it is called libgdk-pixbuf-dev instead.
11:43:14 <monochrom> In fact both libgdk-pixbuf-dev and libgdk-pixbuf2 are built from the same source package gdk-pixbuf
11:44:14 <monochrom> This is the same phenomenon as libgmp3c2 and libgmp3-dev
11:44:47 <cdsmithus> Is there a nicer way to write this view pattern?  foo x@(f&&&g -> (a,b)) = ...
11:45:03 <cdsmithus> (whre &&& is as in Control.Arrow)
11:45:07 <SamB_XP> yeah, they don't change the -dev package name as often since substantial API changes happen a good deal less often than ABI changes
11:46:02 <gwern> monochrom: no, I installed that
11:46:07 <dolio> Xah Lee likes the new Haskell logo, apparently.
11:46:15 <gwern> I installed everything apt-cache search shows up for 'pixbuf', actually
11:46:34 <SamB_XP> dolio: the Emacs person ?
11:46:50 <gwern> SamB_XP: and famed nut
11:46:52 <dolio> If that's how you think of him.
11:47:03 <dolio> I think he's best known for being completely insane.
11:47:04 <gwern> not up to the guy who just died though
11:47:11 <SamB_XP> dolio: oh, is he?
11:47:17 <gwern> now there was a lisp nut par excellence
11:47:26 <SamB_XP> so does that mean I shouldn't read his advice about emacs?
11:47:33 <SamB_XP> "was"?
11:47:56 <gwern> the other fellow.... e...
11:48:01 <gwern> ah erik naggum
11:48:01 <dolio> I don't know. Maybe he's on target with emacs.
11:48:15 * gwern finally remembered. naggum was such a good ranter
11:48:28 <azbooka> э
11:48:39 <SamB_XP> Axman6: say what ?
11:49:03 <SamB_XP> I mean, I see a valid glyph, but have no clue what it means ...
11:49:43 <monochrom> azbooka != Axman6
11:50:12 <dolio> Backward varepsilon?
11:50:39 <mauke> U+044D (d1 8d): CYRILLIC SMALL LETTER E [э]
11:50:43 <Twey> Nah
11:50:44 <dolio> Ah.
11:52:50 <Twey> dolio: The \varepsilon is the one that looks like ɛ
11:53:02 <Twey> ϵ is the ‘normal’ \epsilon
11:53:23 <dolio> Oh yeah?
11:53:37 <Gracenotes> si senor
11:53:41 <dolio> The Agda emacs mode has it backwards, then.
11:54:01 <dolio> It has the humped one as \epsilon, and the non-humped one has no input code.
11:54:18 <SamB_XP> dolio: is it agda that has it backwards, or is it something that came with emacs ?
11:54:28 <dolio> I guess that's probably an artifact of the underlying quail mode or whatever, though.
11:54:48 <dolio> Yeah, I don't think they redefined epsilon.
11:57:02 <dolio> It has \varfoo for a lot of other foos, though.
11:57:05 <monochrom> From mathematician's point of view, ϵ is canonical. But this is in complete disregard of what the Greeks say.
11:57:06 <Cale> ε is the 'normal' epsilon
11:57:23 <dolio> kappa, phi, pi, rho, sigma, theta
11:57:26 <dolio> No epsilon, though.
11:57:46 <Twey> I quoted ‘normal’ because they both are/were used
11:58:26 <SamB_XP> Cale: that's the only one that renders in this x-chat, too ;-)
11:58:46 <Twey> But the Latin epsilon ‘ɛ’ is \varepsilon and the lunate epsilon ‘ϵ’ \epsilon in LaTeX
11:58:54 <Twey> (also OpenOffice)
11:59:08 <SamB_XP> Twey: I expect MS Word agrees with you ;-)
12:00:01 <Cale> SamB_XP: The other one rendered, but it looks more like ∈/∊ is supposed to look than an epsilon. (They both look like hell in the font I'm using.)
12:00:29 <monochrom> Hellenic letters look like hell.
12:00:33 <SamB_XP> in this x-chat, the "greek small letter epsilon" rendered like \in
12:01:08 <SamB_XP> in my Putty, though, it rendered the same as "latin small letter open E"
12:01:08 <monochrom> math lunatic epsilon
12:01:12 <Twey> Cale: That's correct.
12:01:39 <SamB_XP> what the hell is with SMALL ELEMENT OF
12:01:58 <monochrom> Because the normal "element of" is big.
12:02:09 <Twey> Cale: http://www.w3.org/TR/xml-entity-names/glyphs/003/U003F5.png
12:02:17 <SamB_XP> it's so dang tiny!
12:02:27 <SamB_XP> what is it for?
12:02:29 <en0th> :t =<<
12:02:30 <lambdabot> parse error on input `=<<'
12:02:35 <en0th> :t (=<<)
12:02:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:02:47 <monochrom> ∈ is big, ∊ is small.
12:02:51 <Cale> Twey: Yeah, the middle - part doesn't stick out as far as the top and bottom
12:03:02 <SamB_XP> well, in particular, it seems awful low in the character cell ...
12:03:05 <Twey> Ah, true.
12:03:34 <monochrom> Depending on your font choice.
12:03:41 <SamB_XP> monochrom: this is unifont
12:04:09 <Cale> though, when examined closely (at least in my fonts), ϵ is rounded at the top and bottom right, which an element-of symbol isn't.
12:04:10 <monochrom> And is there anything special about unifont?
12:04:32 <Twey> *nod* Same
12:05:04 <monochrom> Anyway some people want the big one, some people want the small one.
12:05:05 <SamB_XP> monochrom: it has almost the entire BMP in it ?
12:05:23 <monochrom> I mean special social status such as "blessed by the committee"
12:07:02 <monochrom> If not blessed, you risk confusing a poor font designer with a poor standard glyph.
12:08:41 <SamB_XP> no, it's not blessed a bit
12:10:03 <SamB_XP> also, unifont only works at what windows considers to be size 12 ;-)
12:11:24 <SamB_XP> otherwise it looks either jaggedy or blurred to hell, depending on how exactly it's rendered ...
12:11:42 <SamB_XP> (Well, sizes 24, 36, etc. would also work ...)
12:12:25 <monochrom> In fact the small \in is not too low in the character cell in the font I use. It's centred nicely.
12:12:46 <SamB_XP> could be a bug in this version of unifont, then
12:13:08 <monochrom> So much for using one implementation to jump to conclusions.
12:13:47 <SamB_XP> I'd fix it, but I have nowhere near the RAM needed to recompile unifont with the current bitmap -> fontforge script
12:14:04 <en0th> :t (<|>)
12:14:05 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
12:15:19 <SamB_XP> and I can't find any good algorithms for converting a low-res bitmap to a set of outlines that are just supposed to produce the exact same configuration of squares
12:15:32 <SamB_XP> that is, I can't figure out search terms
12:15:55 <dolio> ⋾
12:16:28 <SamB_XP> strange ...
12:16:38 <SamB_XP> that's not displaying even though I switched x-chat over to unifont ...
12:19:30 <SamB_XP> oh, I guess that this version of unifont is missing that ...
12:20:02 <dolio> I'm not even sure what that's called. I can't find SMALL CONTAINS AS ELEMENT WITH OVER BAR or something similar.
12:20:28 <SamB_XP> U+22FE SMALL CONTAINS WITH OVERBAR
12:20:45 <dolio> Ah. Dropping words.
12:20:46 <SamB_XP> you don't have unicode(1) ?
12:21:06 <dolio> Apparently not.
12:21:23 <SamB_XP> 'tis a most handy tool
12:21:50 <monochrom> "{1,2} contains 1" is a perfectly correct way to say it. No need for "as element".
12:22:05 <SamB_XP> you run e.g. 'unicode ∊' and it looks the thing up
12:22:16 <dolio> Yeah, but the large one is called CONTAINS AS MEMBER.
12:22:26 <monochrom> Haha OK.
12:22:35 <SamB_XP> monochrom: well, and people don't write "GREEK SMALL LETTER EPSILON"
12:22:56 <monochrom> They write "it's all Greek to me"
12:23:44 <dolio> There's also CONTAINS AS NORMAL SUBGROUP.
12:24:25 <Taejo> I CONTAIN UNICODE AS A NORMAL SUBGROUP: IT'S AN EXCUSE TO SHOUT IN IRC
12:24:54 <SamB_XP> wth ...
12:24:54 <SamB_XP> ∈
12:24:54 <SamB_XP>  ?
12:25:05 <SamB_XP> it's showing up sideways in x-chat ...
12:25:25 <dolio> , text ['\x4dc0'..]
12:26:30 <SamB_XP> oh ... maybe that was related to using the name with "@" in it ...
12:26:33 <dolio> , text ['\x4dc0'..'\x4dff']
12:26:50 <SamB_XP> I still don't get what that is supposed to mean in Windows ...
12:27:02 <_zenon_> Taejo: Do you honestly read out UPPERCASE TEXT as someone SHOUTING? Hehe.
12:27:05 <dolio> > text ['\x4dc0'..'\x4dff']
12:27:06 <lambdabot>   ䷀䷁䷂䷃䷄䷅䷆䷇䷈䷉䷊䷋䷌䷍䷎䷏䷐䷑䷒䷓䷔䷕䷖䷗䷘...
12:27:12 <SamB_XP> I tried to look it up in MSDN, but typical bing/google fail wrt punctuation prevented me
12:27:52 <Taejo> _zenon_: not really, but if a bunch of all-caps text scrolls past, I definitely notice it
12:27:54 <monochrom> Hehe ancient Chinese binary numbers (except they didn't realize it).
12:28:00 <SamB_XP> _zenon_: in the midst of an otherwise lower- or conventional-case sentence, yes ;-)
12:28:44 <Taejo> and like DEC, they didn't realise there should be eight bits in a byte
12:29:05 <SamB_XP> Taejo: hmm???
12:29:07 <hackagebot> network-dbus 0.0 - D-Bus (DafyddHarries)
12:29:31 <SamB_XP> noooooooo!
12:30:01 * SamB_XP seeks a japanese cleric for some of those bookmarks for the warding-off of evil
12:30:02 <Taejo> SamB_XP: the PDP-8 used 12 bit words, AFAIR
12:30:17 <SamB_XP> Taejo: true, but how does that relate to anything else ?
12:30:26 <SamB_XP> or it might have been 18-bit words
12:30:37 <SamB_XP> but that still leaves you with 6-bit bytes
12:30:40 <Taejo> in response to monochrom
12:32:19 <data_jepp> How do I print stuff? Need to print '('. Making a parser.
12:32:26 <monochrom> Office people think of uppercase as either emphasis (document titles, \emph thingies) or special terminology ("we use ALGEBRA to solve problems"). They don't think of it as shouting.
12:32:56 <mauke> putChar '('
12:32:58 <SamB_XP> how do they emphasize then ?
12:33:05 <Berengal> data_jepp, parsers print characters now? ;)
12:33:05 <SamB_XP> when they talk
12:33:13 <monochrom> accent
12:33:21 <Taejo> monochrom: there is one guy in the maths department in my uni who does that. We used to make jokes about how CONTINUED FRACTIONS really enraged him
12:33:31 <SamB_XP> you mean like they start talking like they're from new york ?
12:33:38 <SamB_XP> ... or like they aren't from new york?
12:33:42 <sproingie> anyone use leksah and managed to get it to actually browse source?
12:33:43 <data_jepp> It prints an abstract syntax tree of some tiny language defined in the task.
12:33:55 <monochrom> "You mûst finish this now"
12:34:02 <SamB_XP> hehehe
12:34:11 <SamB_XP> try umlauts
12:34:20 <Berengal> data_jepp, might I suggest it instead returns an abstract syntax tree, and then you let something else print it?
12:34:27 <SamB_XP> like Show ;-P
12:34:28 <monochrom> múst
12:34:31 <SamB_XP> Show is good at that
12:34:46 <SamB_XP> monochrom: okay, what was that, grave and acute so far ?
12:34:51 <Berengal> Show sucks at syntax trees... They're nigh unreadable except for small expressions
12:34:57 <sproingie> heavy metal ümläut
12:34:58 <SamB_XP> Berengal: okay, true
12:35:07 <SamB_XP> but he probably wasn't told to make it readable!
12:35:20 <Berengal> Heh, possibly
12:35:22 <SamB_XP> that would require ... you know ... a whole nother combinator library
12:35:49 <data_jepp> Hmm. My datatype for expressions derives (Ex,Show) is that good for something :p?
12:35:56 <data_jepp> *Eq
12:35:56 <monochrom> I can never remember the names grave, acute, umlaut, ...
12:36:06 <Berengal> @type show
12:36:06 <lambdabot> forall a. (Show a) => a -> String
12:36:08 <Berengal> @type (==)
12:36:09 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:36:13 <SamB_XP> data_jepp: you could use that until you get an asignment to print it out nicely indented, yeah
12:36:18 <Berengal> data_jepp, gives you access to those ^^
12:36:21 <mauke> data_jepp: Eq lets you use == (equality test), Show lets you use show (convert to string)
12:36:46 <data_jepp> So I can call show with an Expression as argument?
12:36:59 <Berengal> Yep
12:37:00 <SamB_XP> data_jepp: if you've derived Show in enough places, sure!
12:37:13 <SamB_XP> presumably if it doesn't have any parameters, you haver
12:37:17 <Gracenotes> showing is mainly useful for printing something to the terminal...
12:37:17 <SamB_XP> s/haver/have/
12:37:36 <Gracenotes> not too much else. although there is the show/read identity
12:37:37 <SamB_XP> Gracenotes: that seems to be his goal
12:37:52 <Berengal> I use show for ghci-exploration and/or serialization. Not to produce readable text
12:37:58 <Gracenotes> there is also a method in Data.Tree called showTree that makes a 2D layout. if your expression has a tree structure.
12:37:58 <SamB_XP> just so he can demonstrate correct parsing of the input
12:38:07 <data_jepp> The ting is, it's suppose to be a recursive function calling it self. :s were can i Print before it calls itself again?
12:38:20 <data_jepp> Gracenotes: NICE
12:38:27 <Berengal> data_jepp, you don't need to
12:38:36 <SamB_XP> data_jepp: that's in the assignment ?
12:39:11 <data_jepp> It's open how I implemented, its just a tips.
12:39:18 <SamB_XP> ah.
12:39:46 <SamB_XP> well, if you want to make it pretty, you could take a look at Text.Pretty
12:40:53 <Berengal> If your parser is lazy, it will start returning values before it's done parsing... -ish
12:41:26 <data_jepp> Look here, this is an example. It takes the "program" as as string and returns a "tree".
12:41:29 <data_jepp> http://pastebin.com/m2cfd7d97
12:42:37 <SamB_XP> data_jepp: is there something you wanted to change about that picture ?
12:43:17 <data_jepp> No, I just don't know where to start. :p
12:43:29 <SamB_XP> oh, that's what you want to accomplish ?
12:43:42 <data_jepp> Ouì
12:43:53 <SamB_XP> it looks like it parses string, prints the Expression, and then evaluates it
12:44:06 <monochrom> It is perfect.
12:44:09 <SamB_XP> and prints the result of evaluation, which is for some reason a Maybe Integer or somesuch
12:44:32 <Berengal> This looks very much like one of the assignments I got in uni a couple of years back...
12:44:46 <Berengal> The language looks identical as far as I can see...
12:44:57 <SamB_XP> so did you go to the same school?
12:45:01 <Berengal> Is there extra credit for implementing functions as well?
12:45:14 <SamB_XP> anyway, you're not going to give him your code ;-P
12:45:29 <data_jepp> Function extension is also a part yes.
12:45:44 <Berengal> My code sucked anyway. I'd only just begun doing haskell. My parser consisted entirely of pattern matching lists :P
12:45:57 <monochrom> haha
12:46:15 <Twey> Hehe
12:46:18 <SamB_XP> data_jepp: anyway, just start by writing a function from String -> Expression or something like that
12:46:21 <Berengal> data_jepp, which school do you attend?
12:46:23 <SamB_XP> and test it in GHCi
12:47:21 <data_jepp> UiB Norway
12:47:26 <data_jepp> Subject: INF121
12:47:29 <Berengal> \o/
12:47:33 <Berengal> It is the same!
12:47:43 <data_jepp> Nice, hand over the code? \o/
12:47:44 <SamB_XP> teacher's name ?
12:47:51 <SamB_XP> data_jepp: he just told you it was awful
12:47:59 <SamB_XP> anyway, we have a strict no-cheating policy here in #haskell
12:48:11 <SamB_XP> if we find out he helped you cheat, we will ban him for ...
12:48:16 <SamB_XP> ... I dunno how long ;-P
12:48:18 <data_jepp> :p lol
12:48:28 <data_jepp> New teacher, and new books ;)
12:48:34 <Berengal> SamB_XP, I got good remarks on it though. "Much nicer than the usual SML solutions" (SML being the language we were supposed to use back then)
12:48:44 <SamB_XP> Berengal: oh
12:48:48 <Berengal> Actually, this was just last year...
12:48:53 <SamB_XP> hehe
12:48:56 <data_jepp> Yey, I know. Now we have haskell and prolog.
12:49:07 <SamB_XP> maybe that's why they switched to Haskell this year
12:49:22 <SamB_XP> and in that case, taking your code would be really really really dumb
12:49:27 <Berengal> SamB_XP, I'd like to think so :P
12:49:28 <data_jepp> :p
12:49:47 <data_jepp> I can do this, I have another week. And a few students have done it already.
12:49:53 <SamB_XP> because they'd be sure to recognize code so recent and written in a different language from usual at the time
12:50:16 <Berengal> data_jepp, take a look at polyparse or parsec. They will make parsing so much easier and fun
12:50:25 <data_jepp> Noted.
12:50:41 <Berengal> SamB_XP, I did rewrite it half a year later, just to see if my skills had improved (they had, immensely)
12:50:48 <data_jepp> But we are only allowed to use prelude functions ?
12:50:55 <SamB_XP> data_jepp: oh :-(
12:51:07 <SamB_XP> not even Data.List ?
12:51:11 <Berengal> data_jepp, in that case, write your own parser monad
12:51:19 <data_jepp> Hmm monad?
12:51:24 <data_jepp> Checking the book for monad :P
12:51:28 <Berengal> You're in for so much fun :P
12:51:35 <data_jepp> Grrr :p
12:51:35 <SamB_XP> data_jepp: that part isn't particularly interesting
12:52:02 <data_jepp> I would like to do it elegant, other people just puke out code. If it works it works.
12:52:05 <SamB_XP> I mean, it just means "thing with sequenced computations"
12:52:16 <data_jepp> ^^
12:52:18 <Berengal> @type return
12:52:18 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:52:21 <Berengal> @type (>>=)
12:52:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:52:24 <SamB_XP> category theorists are no good at naming
12:52:46 <Berengal> Meditate on those type signatures
12:52:52 <mauke> hah
12:52:59 <SamB_XP> wait, what about the laws ?
12:53:05 <Berengal> (It's what I did (and wrote a parser monad))
12:53:25 <mauke> how do I replaced failure by a list of successes?
12:53:25 <Berengal> The laws aren't that important... Well, they are, but they come naturally
12:53:38 <SamB_XP> mauke: you know that already
12:53:51 <SamB_XP> but now, you must make a lambdacat on the subject!
12:53:54 <SamB_XP> or face bannage
12:54:03 <mauke> you mean a spiderman
12:54:04 <SamB_XP> Berengal: true
12:54:09 <SamB_XP> mauke: a what ?
12:54:22 <SamB_XP> well, you post it to your blog and I'll tell you whether you've qualified
12:54:28 <mauke> SamB_XP: http://en.wikipedia.org/wiki/Spider-Man
12:54:53 <SamB_XP> mauke: I'm familiar with the man in the red and blue costume, yes
12:55:21 <mauke> well, and http://mauke.ath.cx/stuff/img/lol,internet/how-do-i-shot-web.jpg is the most famous incarnation of the "shot web" meme
12:55:22 <data_jepp> If you are curoius about the task: http://rasmus.uib.no/~sto021/task.pdf
12:55:37 <SamB_XP> mauke: but I'm not seeing one of those on the subject of replaced failure with a list of successes
12:56:10 <data_jepp> Gotta grab some dinner, before start to program a freakin parser in a language i've known for a month or so. Yey. :p
12:56:22 <SamB_XP> hehehehe
12:56:26 <medfly> woo
12:56:37 <Berengal> type Parser a = String -> [(a, String)]
12:56:42 <Berengal> There's your parser
12:57:16 <data_jepp> My datatype is data Expr ... a lot of crap. And the function is parseProg :: String -> Expr
12:57:21 <SamB_XP> Berengal: that's not monadicable
12:57:25 <SamB_XP> but it's true
12:57:44 <data_jepp> parseExpr :: String -> (Expr, String)
12:57:45 <SamB_XP> A parsers a function from strings to lists of strings and things
12:57:57 <byorgey> "A Parser for Things is a Function from Strings to Lists of Pairs of Things and Strings!"
12:58:06 <data_jepp> And then parseExpr calls it self. Wopi
12:58:07 <SamB_XP> does anyone have the image ?
12:58:18 <byorgey> it's on the wiki.
12:58:26 <Taejo> http://www.willamette.edu/~fruehr/haskell/seuss.html
12:58:26 <SamB_XP> I thought it was on hawikie
12:58:30 <mauke> data_jepp: this is pretty sane except you've got no way to indicate parse errors
12:59:07 <Berengal> SamB_XP, no? return is simple enough. bind is just run first parser, concatMap secondParserF on the result, no?
12:59:28 <data_jepp> I can use pattern matching, and if an Expr is not a valid Expr datatype which I have defined I print out and error message.
12:59:36 <data_jepp> Or? :p
12:59:38 <mauke> huh?
12:59:49 <mauke> how can Expr be not a valid Expr?
13:00:03 <data_jepp> data Expr =  Var Char | Tall Int | Sum Expr Expr | Mult Expr Expr | Neg Expr | Let Expr Expr Expr
13:00:12 <mauke> ok
13:00:18 <mauke> wait, only single char variables?
13:00:19 <data_jepp> Something like that. :p
13:00:21 <data_jepp> Jepp
13:00:23 <data_jepp> haha
13:00:27 <data_jepp> And one-digit numbers. :p
13:00:30 <mauke> Let Char Expr Expr
13:00:41 <Berengal> And no whitespace
13:00:54 <data_jepp> Mhm, remove that with the filter function.
13:00:54 <mauke> data_jepp: so what are you going to do with malformed input?
13:01:02 <Berengal> letx=5inlety=8in+(x,y) is a valid program
13:01:35 <data_jepp> It says in the task to assume that the input is correctly formatted. :p
13:01:43 <mauke> ok, then that's ok
13:02:57 <data_jepp> The parser I maybe could create with some help from here and other students. Functions Extensions and Evaluating.... *chills*
13:03:18 <mrsolo> mauke!
13:03:20 <SamB_XP> data_jepp: evaluating should be pretty dang easy
13:03:22 <bitstream0101> data_jepp: tell yourself it's easier than it seems ;P
13:03:33 <SamB_XP> haskell really is your language for this
13:03:42 <mauke> wait, where are your lambdas? :-)
13:03:46 <data_jepp> Haha, guess what. A student spent like 30 lines to remove spaces from the string. :p
13:03:56 <SamB_XP> data_jepp: hah
13:03:57 <data_jepp> bitstream0101: Like removing spaces. ^^
13:04:06 <byorgey> hehe, oops =)
13:04:21 <data_jepp> And it didnt even work :p lol
13:04:23 <byorgey> > filter (/=' ')  "let's remove    spaces! ! ! !"
13:04:23 <lambdabot>   "let'sremovespaces!!!!"
13:04:47 <SamB_XP> anyway, I have to help my dad unload the car ...
13:04:47 <mauke> tr[ ][]d;
13:05:11 <byorgey> mapM_ unload (contents car)
13:05:28 <data_jepp> Dinner, later. Happy unloading.
13:05:44 <Berengal> Getting functions right made me fully grok them...
13:05:54 <byorgey> exercise: parallelize the car-unloading algorithm using STM
13:06:02 <SamB_XP> Berengal: you mean, understand what functions are?
13:06:52 <Berengal> SamB_XP, no, removing the barrier of understanding between functions and objects
13:07:18 <Berengal> I was still a haskell noob, and only had oop experience from before
13:09:13 <mrsolo> so why is sum lazy?
13:09:25 <Berengal> mrsolo, it's a foldl...
13:09:39 <Berengal> (And since haskell is lazy by default, the prelude functions are too)
13:09:45 <mrsolo>  is there a reason that it is foldl instead of foldl'?
13:10:05 <mrsolo>  i mean what do one gain form it?
13:10:19 <burp> lazyness
13:10:20 <Berengal> Consistency... but nothing else
13:10:44 <Berengal> (Except in the case of peano numbers, unless I'm mistaken)
13:11:26 <Peaker> damn, language-c is difficult to use :-(
13:11:34 <Twey> s/language-//
13:11:35 <mrsolo>  hmm really need to think about laziness when writing haskell code then
13:11:46 <mrsolo>  i was suprised that sum blows up on my face :-)
13:12:07 <mauke> mrsolo: using ghci or ghc?
13:12:18 <Peaker> Twey, heh, I like coding in C when I feel masochistic
13:12:28 <roconnor> mrsolo: I tend to think it is an effect from using integers, which are stricter than most algebraic data types.
13:12:29 <mrsolo> mauke: ghci
13:12:36 <Twey> Precisely :þ
13:12:50 <Twey> :t sum
13:12:52 <lambdabot> forall a. (Num a) => [a] -> a
13:12:58 <mrsolo> mauke: learning apis and ething
13:12:58 <Berengal> mrsolo, it doesn't bite that often, and GHC is pretty good at optimizing away unneeded lazyness when compiling
13:13:01 <mauke> mrsolo: yeah, it will probably work in compiled code
13:13:10 <mrsolo> ah
13:13:12 <mrsolo> nice
13:13:12 <Twey> mrsolo: Not all Num instances will be strict.
13:13:30 <mauke> meh, lazy Num instances can define their own sum
13:13:34 <mauke> the default sum should be strict
13:13:47 <Twey> Don't see why
13:13:48 <mrsolo> twey: right lazy Num has that hmm Foldable?
13:14:00 <mrsolo> just declare foldable instance, got a sum in there
13:14:00 <Twey> You should be able to do clever things with lazy numbers
13:14:12 <mauke> Twey: because all standard Num types are strict anyway
13:14:21 <Twey> But there are useful non-strict Num types.
13:14:28 <Twey> (potentially, at least)
13:14:32 <mauke> yeah, no
13:14:44 <mauke> that case is simply not common enough
13:15:09 <Berengal> > foldl (flip (+)) 0 [1..1000000] -- should blow stack
13:15:11 <lambdabot>   * Exception: stack overflow
13:15:13 <Twey> For example, (bigNumber + bigNumber) `mod` 2 can be checked by comparing just the last two bits of each number, instead of having to add them together
13:15:13 <Peaker> perhaps sum should be called sum' ?
13:15:20 <Berengal> > (5::Natural) < foldl (flip (+)) 0 [1..1000000]
13:15:21 <lambdabot>   True
13:15:28 <Twey> I'd vote for having a strict sum be sum', yeah
13:15:44 <mauke> then I'd vote for renaming all Num members
13:15:49 <dons> yikes
13:15:52 <Twey> o.@
13:15:58 <mauke> + -> +', negate -> negate'
13:16:07 <Twey> Why?
13:16:12 <Twey> + and negate are not necessarily strict
13:16:21 <mauke> because they're strict in practice
13:16:31 <Twey> Only for the prelude numbers
13:16:37 <Twey> There's nothing stopping one from defining a lazy +
13:16:44 <Igloo> Only in the sense that sum is strict in practice
13:16:48 <Twey> Right
13:16:53 <Berengal> Natural's + is lazy in its second argument
13:16:56 <Peaker> mauke, But (+) isn't recursive.. the strictness really matters only when it potentially builds a huge chunk
13:17:23 <Peaker> thunk, that was
13:18:30 <mauke> argh, compile faster, ghc!
13:19:43 * dons boings!
13:20:41 <mrsolo> ok this this interesting
13:20:57 <mrsolo> default sum with default option still blow up
13:21:03 <mrsolo> but doesn't with -O2
13:21:45 <Twey> -O2 does strictness analysis
13:22:01 <mrsolo> very nice
13:32:08 * dancor heard -O2 is "almost never" better than -O but questioning that now
13:32:31 <burp> o0
13:35:24 <byorgey> hehe, oops, I typed 'scanForMules' instead of 'scanForModules' =)
13:35:59 * ddarius thinks that code should be written to run reasonably without strictness analysis.
13:38:43 <dons> ddarius: 100% agreed. sum failing in ghci is a poke in the eye
13:38:44 <bitstream0101> I have some legacy code (compiled under 6.8.x) that I'm attempting to build under 6.10.4, and it looks like some stuff has moved to Control.OldException.  I need to introduce conditional compilation, unfortunately, but don't know the history of this move, can someone fill me in?
13:39:01 <bitstream0101> e.g., is it a base 3 or a base 4 thing?
13:39:03 <dons> bitstream0101: its a documented change in the 6.10 vs 6.8 base library
13:39:07 <mauke> base 4
13:39:08 <dons> so you can depend on base < 4
13:39:18 <dons> and use cabal to resolve
13:39:24 <bitstream0101> dons: i could if this project had been cabalized :)
13:39:25 <dons> which it is good at doing.
13:39:39 <dons> ah, better cabalize, so you have the right tools to keep it all building
13:39:44 <bitstream0101> dons: my goal is to get it working with both ghc's first, and then cabalize the whole thing
13:39:49 <dons> k.
13:39:53 <dons> i'd start with the cabal file :)
13:39:57 <SamB_XP> that's a bit backwards, yes
13:40:03 <SamB_XP> get it cabalized with the old GHC first
13:40:12 <SamB_XP> then try to port it and keep it building with the old one
13:40:47 <bitstream0101> well, actually, i'd rather ensure there are no other problems with 6.10 before i do the (sigificant) work to cabalize it
13:40:58 <bitstream0101> but i see what you're saying
13:41:08 <SamB_XP> bitstream0101: how complicated is this thing ?
13:41:23 <dons> well, cabal files are easy if you copy one from a project that's similar.
13:41:31 <dons> then you can test with different compilers easily
13:41:37 <dons> --with-ghc=foo-10.2.2.1
13:41:37 <bitstream0101> SamB_XP: makefiles, some recursive, spread over a number of directories, with hacked-together stuff in various places for 3-4 various platforms
13:41:40 <dons> ah
13:41:45 <dons> ok. so it might be harder.
13:41:50 <bitstream0101> that's the only reason i've held off on the cabalization :)
13:42:01 <SamB_XP> bitstream0101: an assload of conditionals, I gather?
13:42:08 <bitstream0101> SamB_XP: You got it
13:42:22 <bitstream0101> plus a lot of gunk in gnu make macros
13:42:37 <SamB_XP> what for ?
13:42:46 <bitstream0101> doing thigns that cabal does right ;P
13:43:04 <SamB_XP> anyway, what platforms does it conditionalize for ?
13:43:31 <bitstream0101> windows nt, unix, mac os x, and a flavor of ubuntu (for some reason, i have no idea why)
13:43:55 <bitstream0101> windows nt stuff looks like readline exclusion, macosx vs unix distinction has to do with static linkage and use of threaded runtime
13:44:22 <bitstream0101> mostly minor, but there's enough of this kind of stuff to make me want to sanity check a 6.10 build before i commit to cabalizing
13:45:02 <SamB_XP> well, cabalizing might be easier than you think ...
13:45:36 <bitstream0101> hmm, maybe i'll give it a shot first.
13:46:28 <SamB_XP> that other stuff might just be stuff you can take care of later ...
14:06:50 <data_jepp> How to call show and return from the same function?
14:07:18 <byorgey> data_jepp: can you be more specific?  I'm not sure what you're asking.
14:07:19 <bitstream0101> data_jepp: what do you mean?
14:07:40 <SamB_XP> data_jepp: you just don't do it at the same time
14:07:46 <SamB_XP> oh, did we not show you "do" yet?
14:08:06 <data_jepp> Its the parser, I need to print (show) something, and then send the rest with a recursive call to the same function
14:08:09 <data_jepp> "do"?
14:08:36 <bitstream0101> data_jepp: are you just printing this for debugging, or are you expecting output as a side-effect of the parser execution?
14:09:03 <data_jepp> The parser is suppose to print this as its output.
14:09:20 <SamB_XP> data_jepp: parsers generally don't produce output except when debugging
14:09:32 <SamB_XP> (or maybe they produce warning messages, sometimes, but ...)
14:09:49 <byorgey> data_jepp: are you sure?  it's probably better if the parser just computes a result.  then you can decide to print the output, or do whatever else you want with it.
14:09:49 <SamB_XP> (... not usually the way you are probably thinking!)
14:09:53 <data_jepp> I know, but I'm student. And students generally get to do stuff we normally wouldnt do :p
14:10:13 <SamB_XP> data_jepp: I'm pretty sure you're not supposed to do that
14:10:26 <SamB_XP> I mean, you could ... if masochism is your style
14:10:33 <bitstream0101> data_jepp: well, it's odd that it's phrased as "output", that's all. you could collect output as you go and display it at the end (monadically, or otherwise), but it's an odd request.
14:10:34 <SamB_XP> and/or missing-the-point
14:11:10 <Peaker> data_jepp, Its nicer to have code that does 1 thing. So Parser only parses.. the printer only prints, and so forth. That way you can later reuse your parser in another project that doesn't want to print its result
14:11:14 <data_jepp> I have to print a part of the abstract syntax tree for a part of the expression before parsing the rest of the expression.
14:11:27 <Berengal> Why?
14:11:27 <SamB_XP> data_jepp: why do you think you need to do that?
14:11:42 <data_jepp> :( ?
14:11:43 <data_jepp> :p
14:12:03 <data_jepp> I can't store it in a variable and print it in the end?
14:12:07 <bitstream0101> in other words, is this explicitly requested in the problem statement or something?
14:12:13 <SamB_XP> data_jepp: it will be in the AST?
14:12:25 <SamB_XP> er. why did I just use a "?" ?
14:13:04 <data_jepp> I don't know, the task doesnt say how to implement the code.
14:13:12 <Peaker> data_jepp, your parser can result in  (a, b)  where a is the first part, and b is the latter. is that what you're looking for?
14:13:24 <newsham> > zipWith ($) (iterate (succ.) succ) "gcv\FS\RSbZkb[a`"
14:13:25 <lambdabot>   "hey #haskell"
14:14:25 <data_jepp> Yes, because one call to parseExpr only parses a part of the program string.
14:14:45 <SamB_XP> data_jepp: but the outermost call will parse the entire string, will it not ?
14:16:29 <data_jepp> Hmm let me quote. "To do the actual parsing, you can write a function parseExpr :: String -> (Expr, String) taking a string as its input and returning an AST fragment togheter with whatever portion of the string remains to be parsed. To parse subexpressions, just call parseExpr recursively. "
14:16:51 <Berengal> data_jepp, that sounds straightforward, does it not?
14:17:00 <Berengal> It doesn't say anything about printing
14:17:32 <data_jepp> Hmm, but what is what in the return? Is string the rest to be parsed or is it the expr?
14:17:48 <Berengal> It's the rest of the unparsed string
14:18:03 <data_jepp> And the expr is what i just parsed?
14:18:28 <Berengal> Yep
14:18:49 <Berengal> However, note that the initial call to parseExpr should return (someAst, "")
14:19:04 <data_jepp> Oh
14:19:20 <Berengal> Because it should parse the entire string (assuming it's well formed)
14:20:27 <data_jepp> What happens when the string is empty? I mean, everything has been parsed.
14:20:58 <Berengal> Nothing special happens. When the string is empty you're already done
14:21:11 <data_jepp> Then I can print? :p
14:21:21 <Berengal> That's when you get the returned value at least
14:22:14 <data_jepp> Would it be smart to use garded equations for the parseExpr function? I need on line for every valid data Expr expression.
14:23:39 <Berengal> A better solution would perhaps be to use Maybe in the sub-parsers
14:24:11 <Berengal> That way it's easier to try different parsers
14:24:26 <Berengal> So let your sub-parsers have type String -> Maybe (Expr, String)
14:24:40 <data_jepp> Maybe is a function? :p
14:24:48 <Berengal> Maybe is a type
14:25:01 <Berengal> Well, a type constructor
14:25:09 <data_jepp> Omg im so fucked ^^
14:25:16 <Berengal> It's sort of like a list, but one that can only be empty or have one element
14:25:32 <Berengal> @type Nothing
14:25:34 <lambdabot> forall a. Maybe a
14:25:36 <data_jepp> Is Just related to Maybe?
14:25:37 <Berengal> @type Just "Hello"
14:25:38 <lambdabot> Maybe [Char]
14:25:46 <hackagebot> ieee 0.6 - Approximate comparisons for IEEE floating point numbers (PatrickPerry)
14:26:15 <Twey> data_jepp: Just is one of Maybe's data constructors.
14:26:21 <Berengal> @src Maybe
14:26:21 <lambdabot> data Maybe a = Nothing | Just a
14:26:33 <data_jepp> Oh
14:27:29 <newsham> you know in some languages where they return a pointer to a value or return NULL?
14:27:49 <newsham> or some other distinguished value as a non-value
14:27:59 <data_jepp> Nothing == null in java?
14:28:02 <newsham> like -1 for index into a list.
14:28:16 <newsham> Maybe is a more correct way of doing that, and Nothing is the non-value
14:28:33 <newsham> so in some ways its like null in java
14:28:56 <data_jepp> Do you all have phd's in haskell or is it a hobby :p?
14:29:02 <Berengal> > let parseChar c input = case input of {[] -> Nothing; (x:xs) | x == c -> Just (c, input) | otherwise -> Nothing} in parseChar 'a' "foo"
14:29:03 <lambdabot>   Nothing
14:29:05 <Berengal> > let parseChar c input = case input of {[] -> Nothing; (x:xs) | x == c -> Just (c, input) | otherwise -> Nothing} in parseChar 'a' "afoo"
14:29:06 <lambdabot>   Just ('a',"afoo")
14:29:10 <newsham> except all java refs can be null, even when you dont want that possibility
14:29:19 <newsham> in haskell you can be more precise
14:29:23 <Berengal> And you can't nest nulls in java...
14:29:37 <newsham> jepp: no phd here
14:29:47 <dibblego> Java 7 has a monad on null as well as fromMaybe
14:29:59 <Berengal> dibblego, it does?
14:30:04 <newsham> dibble: huh.  got an url to list of java 7 features like that?
14:30:10 <dibblego> yes, new syntax of course
14:30:24 <FunctorSalad_> java 7 has monads?
14:30:26 <Berengal> Obviously, and it isn't called a monad either, I suspect?
14:30:40 <newsham> who would call anything a monad?  thats a sure way to make peopel afraid of it :)
14:30:43 <dibblego> @google java elvis operator
14:30:45 <lambdabot> http://blogs.infosupport.com/blogs/peterhe/archive/2009/03/02/Java-7-and-the-Elvis-operator.aspx
14:30:50 <Peaker> Why does Criterion use "+n-n" in its canonical example?
14:31:03 <Berengal> Haha, elvis operator
14:31:32 <FunctorSalad_> "Most of the big changes are either scrapped (like support for closures" ??
14:31:39 <Peaker> Berengal, btw, maybe using a list of results instead of Maybe is simpler? Its more like reads anyway
14:33:06 <Berengal> Peaker, it's not often you need the lists for parsing, and I found Maybe easier to reason about when I started out parsing
14:36:18 <Berengal> dibblego, neat. Now I won't have to use do{}while(false); as much anymore
14:36:25 <dibblego> heh
14:37:26 <SamB_XP> they added a nop ?
14:37:30 <Berengal> That monadic pattern had a really crappy syntax for bind: "if (_something_ == null) break;"
14:38:35 <Twey> Explain ‘do{}while(false)’?
14:39:25 <Berengal> Twey, "boolean error = true; do {stuff with nulls that can break; error = false;}while(false); if (error) (return default;))"
14:40:03 <Twey> Oh, I see.
14:40:04 <Twey> Heh.
14:41:53 <orbitz> any suggestions if i want to just drop a snippet of haskell code in a latex document (preferabbly syntax highlighted) and I'm not doing literate haskell?
14:42:00 <Veinor> Berengal: THat makes me cry.
14:42:15 <Alpounet> dibblego, thanks for the info.
14:42:30 <Berengal> Veinor, I guess you could just use a simple scope.. I think you can break out of that as well
14:42:50 <Berengal> But otherwise it's pretty much the cleanest null-safe pattern
14:43:19 <Peaker> Does \() -> ...   force a computation to not be memoized or will ghc optimize it into ... and memoize the result?
14:43:39 <mauke> ghc doesn't memoize
14:43:40 <Peaker> Berengal, In your specific example, you could just return
14:43:47 <Peaker> Berengal, if you can't, split into a function rather than a do/while
14:44:03 <Peaker> mauke, Right, I meant share the result rather than recompute it
14:44:03 <byorgey> orbitz: the listings package supports Haskell, IIRC.
14:44:14 <orbitz> byorgey: oh wonderufl thanks
14:44:14 <mauke> oh, hmm
14:44:15 <Berengal> Peaker, my specific example doesn't even compile
14:45:29 <Twey> Peaker: Unfortunately (or maybe not), you can't break from a calling block in a function
14:45:56 <Twey> So you end up with if (action1()) if (action2()) if(action3()) action4()
14:50:41 <Twey> Which is, I think, what Berengal was attempting to avoid
14:50:41 <Twey> (before even considering legitimate return values, of course)
14:50:41 <Heffalump> Peaker: I doubt there are any guarantees, but I suspect in practice that'll block sharing.
14:50:41 <Berengal> Twey, that, and catching NullPointerExceptions that are thrown from within function I'm calling
14:50:41 <Twey> Difference between memoisation and sharing?
14:50:41 <Berengal> (Is what I'm trying to avoid)
14:50:41 <Heffalump> Twey: sharing of computed lazy values is really a special case of memoisation
14:50:41 <Twey> Berengal: Yeah, I usually just catch (drink?) the NPEs.  ☺
14:50:41 <Twey> Heffalump: So GHC *does* do memoisation.  Selectively.
14:50:41 <Berengal> Twey, i've encountered one bug too many where a simple NPE turned into a really hard bug because of people catching NPEs they didn't own
14:50:41 <Heffalump> if you like
14:50:41 <Twey> True enough.
14:50:41 <Berengal> It's become so bad, the simple dot-operator fires of the same neurons calling 'head' in haskell does...
14:50:41 <calsaverini> Hi there
14:50:41 <Berengal> Hello
14:50:41 <calsaverini> I am *trying* to learn haskell and just read about algebraic data types
14:50:50 <calsaverini> and something ocurred to me that I was not sure enough how to try in the compiler
14:51:12 <Berengal> What's that?
14:51:28 <calsaverini> hang on, let me formulate it in a comprehensible way
14:51:33 <calsaverini> hehehe
14:51:38 <calsaverini> I'm not very good with it
14:52:09 <calsaverini> Ok, since functions are 1st class objects and they have their own data type
14:52:09 <Twey> Berengal: Yeah.  I encountered a guy who caught NPEs in *every function* he called.
14:52:42 <calsaverini> can one of the members of an algebraic data type be a function?
14:52:51 <ddarius> Yes
14:52:51 <mauke> calsaverini: sure
14:52:51 <byorgey> calsaverini: most definitely!
14:53:02 <calsaverini> Oh!! That's terrific
14:53:06 <Berengal> @type Just id
14:53:07 <lambdabot> forall a. Maybe (a -> a)
14:53:07 <byorgey> yes, it is =)
14:53:27 <calsaverini> nice!
14:54:04 <calsaverini> I work with Agent Based Simulation and OO was the only way I knew how to do it
14:54:35 <calsaverini> but now this is just what I needed to translate my way of thinking about an agent to haskell
14:55:17 <calsaverini> and it's cleaner
14:55:24 <calsaverini> thanks all
14:55:33 <calsaverini> this channel is always very receptive
14:55:35 <Berengal> This is how oo-ish things are usually done
14:55:54 <ddarius> newtype HFun a b = HFun (HFun b a -> b)
14:56:03 <Berengal> Well, that, or type classes
14:56:19 <ddarius> COP
14:56:45 <calsaverini> I see I have a lot to learn. 'll come back ,ta
14:57:01 <calsaverini> later as I have more doubts
14:57:02 <calsaverini> thanks
14:57:38 <byorgey> ddarius: what on earth is that useful for?
15:01:21 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.4961
15:07:09 <fergie> Anyone here know much about Gitit?
15:07:54 <fergie> I'm wondering if it is possible to use plugins when you are using the Network.Gitit module rather than the normal program
15:08:56 <Peaker> Heffalump, I am asking about blocking sharing because of the ugly \n -> fib (10+n-n)  examples in Criterion's example page
15:09:18 <Heffalump> ah
15:09:29 <Twey> Isn't that just const (fib 10)?
15:09:52 <Heffalump> Twey: presumably it's written that way so you can actually benchmark the execution repeatedly
15:10:01 <Heffalump> rather than benchmarking the thunk inspection
15:10:13 * Twey scratches his head.
15:10:21 <Twey> And this makes a good example why?
15:13:48 <byorgey> ddarius: thanks!
15:14:11 <dilinger> yeah, i was also confused by the fib (10+n-n) example
15:14:23 <Heffalump> Twey: what do you mean?
15:15:43 <Peaker> Is there no better way to block sharing?
15:15:52 <Peaker> perhaps a pragma could be used?
15:37:57 <SimonAdameit> Hi
15:38:50 <Peaker> hello
15:38:57 <SimonAdameit> How can I dynamically update a module in haskell?
15:39:11 <Baughn> SimonAdameit: You mean, at runtime?
15:39:15 <SimonAdameit> yes
15:39:38 <Baughn> SimonAdameit: http://hackage.haskell.org/package/plugins
15:39:59 <Rotaerk> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types  this article seems wrong
15:40:42 <MyCatVerbs> Wrong and evil.
15:40:45 <Rotaerk> "forall a. [a] is the type of the list whose elements have some (the same) type a, which can be assumed to be any type at all by a callee (and therefore this too is a list of bottoms)."
15:40:45 <SimonAdameit> Baughn: great, I will look into this, thanks :)
15:41:08 <Rotaerk> and then later, it says that "forall a. MkT a" can accept any value from any type
15:41:48 <MyCatVerbs> Rotaerk: Different things.
15:42:00 <Rotaerk> MkT and [ ] are both type constructors
15:42:01 <Perceptron> Hey guys, quick question i have a type Matrix = [[Double]]  and im just trying to check to make sure every column has the same length i have [(length x)|x <- [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]] but how do  i checkto make sure they are all in this case 3
15:42:05 <Rotaerk> so how are they different
15:42:15 <MyCatVerbs> Rotaerk: (the article is correct, though it is still evil. ^~) MkT is a constructor, not a type constructor.
15:42:24 <Rotaerk> err yea constructor
15:42:28 <Rotaerk> but both are constructors
15:42:31 <MyCatVerbs> Rotaerk: the [] in (forall a. [a]) is being used as a type constructor.
15:42:39 <Rotaerk> hmm
15:42:49 <MyCatVerbs> No. Type constructors are entirely seperate things from data constructors.
15:43:34 <MyCatVerbs> They're even in separate namespaces, which is why you can have type constructors with identical names to data constructors.
15:43:38 <Makoryu> Rotaerk: Data constructors live in the data namespace, and type constructors live in the type namespace. Data constructors are legal values, but type constructors are not legal types.
15:45:26 <Peaker> Rotaerk, forall a. MkT a   is not a type
15:45:34 <Rotaerk> k, I understand
15:45:58 <Peaker> Rotaerk, The type   forall a. T a    is indeed like  forall a. [a]   (I think both are inhabitable only by bottoms)
15:46:32 <Peaker> but forall a. a -> T    or:  forall a. a -> [a]    are inhabitable..
15:47:14 <Rotaerk> doesn't that say "a function that takes a value that inhabits all types a (bottoms only) and produces a T"
15:48:08 <Peaker> Rotaerk, I think that's distinct from:  (forall a. a) -> T  which would be what you said
15:48:30 <Peaker> Rotaerk, for any possible "a", I can give you   a -> T,  vs:   for a bottom, I can give you T
15:51:45 <Perceptron> Hey guys for somethin glike ([if((length x) ==(length (head [[1,2,3]]))) then True else False|x <- [[1,2,3],[2,3,4],[3,4,5],[4,5,6,5]]]) i get [True,True,True,False] but what i want is either jsut one True if they are all the same length or one False they are not all the same how can i change it to do that (the actual lists are going to be an input this is jsut a test
15:51:51 <Rotaerk> if x has type "forall a. a", that means "for all types a, x inhabits a"
15:52:52 <Makoryu> :t all
15:52:53 <Rotaerk> thus if f is of type "forall a. (a -> T)", that's saying "for all types a, f inhabits (a -> T)"
15:52:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:53:26 <Makoryu> Perceptron: foo xs yss = all (\ys -> length ys == length xs) yss
15:53:27 <mauke> foo xs = all ((n ==) . length) xs where n = length (head xs)
15:53:31 <Rotaerk> i.e. f is in the type (Int -> T), (String -> T), etc
15:53:33 * calsaverini likes <lambdabot> a lot
15:53:34 <Rotaerk> guess that makes sense
15:53:46 <Makoryu> Yeah, use mauke's version. Better sharing.
15:54:13 <FunctorSalad_> hmm I can't compile esotericbot "libtool: link: only absolute run-paths are allowed"
15:55:17 <Perceptron> Makoryu: manuke: im a bit confused , (im jsut starting haske;ll), what im trying to do exactly is i have a Matrix = [[Double]] and am trying to create a isMatrix function
15:55:31 <Perceptron> which basically checks to make sure all the columns have the same length
15:56:16 <Baughn> Perceptron: Well, the first thing to do would be 'map length'
15:56:24 <Peaker> Perceptron, no use to "if x then True else False". that's just "x"
15:56:37 <Makoryu> :t map length
15:56:39 <lambdabot> forall a. [[a]] -> [Int]
15:56:55 <Baughn> :t foldl1' (==)
15:56:55 <lambdabot> [Bool] -> Bool
15:57:07 <Baughn> ..no good.
15:57:16 <Makoryu> :t foldr (==)
15:57:17 <lambdabot> Bool -> [Bool] -> Bool
15:57:23 <Makoryu> Dang
15:57:32 <Makoryu> :t foldl (==)
15:57:34 <lambdabot> Bool -> [Bool] -> Bool
15:57:37 <Makoryu> Oh
15:57:38 <Makoryu> Duh
15:57:40 <Peaker> Rotaerk, someone here once said he thinks of forall's as a function, i.e:  forall a. ....  is basically \a -> ...  (given a, return this).  This helps me understand them more easily
15:57:41 <Baughn> :t all (== 1)
15:57:42 <lambdabot> forall a. (Num a) => [a] -> Bool
15:58:01 <Baughn> @pl \x -> all (== (head x)) (tail x)
15:58:01 <lambdabot> ap (all . (==) . head) tail
15:58:25 <Baughn> Darn it, there should be some quick way of checking if all the elements of a list are equal
15:58:42 <Baughn> > group [2,2,2,3,2]
15:58:43 <lambdabot>   [[2,2,2],[3],[2]]
15:59:17 <Baughn> ..but that's not it.
15:59:19 <Makoryu> :t null . drop 1 . group
15:59:20 <lambdabot> forall a. (Eq a) => [a] -> Bool
15:59:26 <Gracenotes> group basically does the all trick, but with more record-keep-tracking
15:59:27 <Baughn> It does too much work. Hm..
15:59:59 <Baughn> @pl \x -> all (== (head x)) x
15:59:59 <lambdabot> all =<< (==) . head
16:00:05 <Makoryu> (I used "drop 1" as a "safe" tail)
16:00:13 <Baughn> ..oh wow, \bot
16:00:13 <Gracenotes> > group []
16:00:14 <lambdabot>   []
16:00:34 <Peaker> Baughn, that seems wrong
16:00:51 <Peaker> or not, oops :)
16:00:53 <bitstream0101> :t null . drop 1 . nub
16:00:54 <lambdabot> forall a. (Eq a) => [a] -> Bool
16:01:23 <Baughn> Peaker: The only wrong thing there is \bot's casual use of the reader monad. :PO
16:01:35 <Peaker> heh
16:01:45 <Perceptron> Thanks guy i think i understnad it :)
16:02:15 <Gracenotes> the only reason I'd not do nub is because it has O(n^2) time. How much of that would be carried out to find if there is >1 element is uncertain, though
16:02:43 <Makoryu> :t (null ||) $ all =<< (==) . head
16:02:45 <lambdabot>     Couldn't match expected type `Bool'
16:02:45 <lambdabot>            against inferred type `[a] -> Bool'
16:02:45 <lambdabot>     In the first argument of `(||)', namely `null'
16:03:06 <Peaker> @let allEqual = all =<< (==) . head
16:03:08 <lambdabot>  Defined.
16:03:12 <Peaker> > allEqual []
16:03:14 <lambdabot>   True
16:03:15 <Peaker> > allEqual [1,2,3]
16:03:17 <lambdabot>   False
16:03:28 <Makoryu> @pl \xs -> null xs || all (== (head xs)) xs
16:03:29 <lambdabot> liftM2 (||) null (all =<< (==) . head)
16:03:30 <Baughn> Wait a..
16:03:32 <jmcarthur> should allEqual [] even work?
16:03:38 <Baughn> It should, but..
16:03:44 <jmcarthur> i guess it should
16:03:47 <Peaker> @check \x -> allEqual (replicate x x)
16:03:48 <lambdabot>   Not in scope: `allEqual'
16:03:55 <Baughn> > (\x-> all (== (head x)) x) []
16:03:56 <lambdabot>   True
16:03:58 <Gracenotes> it makes more sense for it to be True than False
16:04:02 <Peaker> @check let allEqual = all =<< (==) . head in \x -> allEqual (replicate x x)
16:04:04 <lambdabot>   "OK, passed 500 tests."
16:04:14 <Baughn> I guess all checks for an empty list before dethunking its parameter. :P
16:04:19 <jmcarthur> well, it's either True or undefined, but i think i just convinced myself it should be True
16:04:21 <Makoryu> I guess a 0x0 matrix is still a matrix
16:04:27 <Peaker> @src all
16:04:28 <lambdabot> all p =  and . map p
16:04:32 <Peaker> @src and
16:04:33 <lambdabot> and   =  foldr (&&) True
16:04:52 <Baughn> Makoryu: Oh, but FWIW, I'd probably want a 2D array instead of a nested list.
16:05:00 <Makoryu> Baughn: So would I
16:05:02 <Peaker> Baughn, as you'd expect a lazy one to do :-)
16:05:14 <Baughn> Peaker: Admittedly.
16:05:20 <Makoryu> Baughn: Or at least a (shape, contents) pair
16:11:26 <aavogt> > all undefined []
16:11:27 <lambdabot>   True
16:11:51 <Peaker> > all $! undefined $ []
16:11:53 <lambdabot>   * Exception: Prelude.undefined
16:21:04 <Gracenotes> Peaker: except.. that's evaluating "undefined []" :o
16:21:57 <Peaker> well, I wanted an all that's strict in its first arg
16:22:08 <Peaker> and to apply it the same way as aavogt did
16:24:07 <Gracenotes> mm, seq is the only way to make it strict in the first argument always
16:25:07 <Peaker> Isn't   x `seq` y   the same as: const $! x $ y?
16:25:08 <dolio> That's why infixr ($!)/($) sucks.
16:25:21 <Peaker> oh
16:25:24 <Peaker> I see
16:25:32 <Peaker> Gracenotes, I misunderstood what you said before
16:25:47 <Peaker> > (all $! undefined) []
16:25:49 <lambdabot>   * Exception: Prelude.undefined
16:26:19 <Gracenotes> $! being isomorphic to seq, sorta
16:26:29 <sbahra> Gracenotes, why sorta?
16:27:06 <SamB_XP> dolio: that's what I always say!
16:27:11 <Gracenotes> they can be defined in terms of each other. you need extra functions though
16:27:24 <sbahra> I see.
16:27:29 <dolio> SamB_XP: Agda got infected, too, I think. :(
16:27:29 <Gracenotes> really complicated ones like 'const'
16:27:35 <sbahra> :t ($!)
16:27:36 <lambdabot> forall a b. (a -> b) -> a -> b
16:27:38 <sbahra> Gracenotes, heh
16:27:49 <SamB_XP> ouch!
16:28:32 * sbahra high fives shapr 
16:28:52 <shapr> y0 sbahra
16:30:15 <Peaker> sbahra, did you get my response about RTL?
16:30:32 <dolio> SamB_XP: Although there might be legitimate differences when you have dependent types.
16:30:34 <sbahra> Peaker, nope, my buffer wasn't large enough.
16:30:54 <dolio> ($) can have the same dependent type as normal application. I forget if composition can.
16:31:16 <SamB_XP> dolio: I thought you meant the fixity of $ ...
16:31:36 <dolio> Yes, I think it's infixr in the Agda std-lib, too.
16:31:54 <Peaker> sbahra, basically I think it might be useful for kids, but even there I think its probably better to learn basic English to not shun yourself away from the vast world of libraries/etc
16:32:03 <dolio> I'm saying that f . g . h $ x may not be the same as infixr f $ g $ h $ x, so there may be more legitimate arguments.
16:32:03 <ddarius> Hmm, either I'm missing a subtlety or Thorsten is missing something obvious.
16:33:49 <burp> http://hackage.haskell.org/packages/archive/Takusen/0.8.5/doc/html/Database-Enumerator.html#4
16:33:57 <burp> "Rank-2 types, ($), and the monomorphism restriction"
16:34:17 <burp> that's confusing :>
16:34:35 <sbahra> Peaker, I agree.
16:35:42 <Gracenotes> dolio: hm, which cases are those?
16:36:52 <SamB_XP> Gracenotes: he isn't sure if they must be the same or not
16:36:59 <SamB_XP> when typed dependantly
16:37:21 <Gracenotes> oh, in Haskell. never mind.
16:37:24 <SamB_XP> how would you dependantly-type (.) anyway ?
16:37:25 <dolio> Gracenotes: $ has type {A : Set} {P : A -> Set} (f : (y : A) -> P y) -> (x : A) -> P x
16:37:44 <SamB_XP> Gracenotes: in Agda is what he's thinking about
16:38:00 <dolio> Let's see...
16:38:00 <Gracenotes> yes, gathered
16:39:27 <Gracenotes> it would be interesting to have both left and right associative application operators
16:39:52 <Baughn> @src (->) (>>=)
16:39:52 <lambdabot> f >>= k = \ r -> k (f r) r
16:40:25 <Baughn> > ((,) =<< succ) 3
16:40:26 <lambdabot>   (4,3)
16:40:38 <dolio> ∘ has type: {A : Set} {B : A → Set} {C : {x : A} → B x → Set} → (∀ {x} (y : B x) → C y) → (g : (x : A) → B x) → ((x : A) → C (g x))
16:40:50 <ddarius> > ap (,) succ 3
16:40:50 <lambdabot>   (3,4)
16:41:58 <Gracenotes> how intelligible is this: map $$ filter even $ tail $ groupBy $$ (==) $ xs
16:43:04 <bitstream0101> Can someone explain why I might get some -Wall warnings emitted from ghc but not via ghci for the same module (even though -Wall is in my .ghci)?
16:43:15 <sproingie> @src $$
16:43:16 <lambdabot> Source not found. It can only be attributed to human error.
16:43:27 <Berengal> Gracenotes, I can't even tell what it's supposed to do
16:43:30 <Berengal> map what?
16:43:40 <Gracenotes> $$ being a left-associative $
16:44:02 <Gracenotes> precedence would be the most confusing part... and GHC doesn't really like mixing left and right operators of the same precedence. that would be a deal breaker.
16:44:25 <shachaf> Gracenotes: Why is a right-associative ($) necessary?
16:44:32 <sproingie> yeah i'm not following it
16:44:57 <Gracenotes> based on what I said 20 lines up
16:45:26 <Berengal> Gracenotes, it just doesn't typecheck to me...
16:45:41 <shachaf> Oh, there's *context*.
16:45:42 <calsaverini> @src map
16:45:42 <lambdabot> map _ []     = []
16:45:42 <lambdabot> map f (x:xs) = f x : map f xs
16:45:48 <Gracenotes> because the precedences are different
16:45:51 <Makoryu> Gracenotes: I can't mentally parse stuff of the same level of precedence either. Can't blame GHC :p
16:45:58 <Berengal> (map (filter even . tail . groupBy)) (==) xs?
16:46:02 <Makoryu> Gracenotes: Does ($$) bind tighter than ($)?
16:46:08 <Makoryu> Or looser?
16:46:20 <Gracenotes> supposed to be, map (filter even) . tail . groupBy (==)
16:46:55 <Berengal> I think I prefer the parens and dot version...
16:47:09 <Gracenotes> the basic was that of a theoretical mix
16:47:17 <Makoryu> Yeah. For this example, at least, it's really really not necessary
16:47:29 <Gracenotes> basis
16:48:00 <Berengal> I'm actually not a big fan of $ at all. Sometimes I even do (foo . bar . baz) xs
16:48:54 <Peaker> Gracenotes just gave me an idea.. You could have $, $$, $$$, and so on, that are identical but have decreasing precedence
16:48:59 <Peaker> so   a $ b $$ c $ d   is ((a) (b)) ((c) (d))
16:49:06 <burp> horrible :D
16:49:09 <sproingie> $ is nice when not overused
16:49:18 <sproingie> very nice for runFoo
16:49:57 <Gracenotes> Peaker: niiice. Only problem is, whenever you wanted more arguments for a part of the $ chain, you'd have to bump down the $ to $$, $$ to $$$, etc.
16:50:13 <Gracenotes> or vice versa.
16:50:20 <Makoryu> If we could write `(foo) instead of `foo`, I'm not sure I'd use a whole lot of $...
16:50:24 <sproingie> i say double it
16:50:29 <sproingie> $, $$, $$$$, $$$$$$$$
16:51:24 <sproingie> class Bling where ($$$$) ...
16:51:31 <Gracenotes> nay, factorialize it
16:52:02 <Gracenotes> $, $$, $$$$$$, $$$$$$$$$$$$$$$$$$$$$$$$, $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
16:52:49 <Makoryu> Gracenotes: New rule. The $ operator is called "desu," and $$, $$$, etc. are called "desu desu," "desu desu desu"....
16:53:05 <sproingie> malkovitch
16:53:46 <Gracenotes> can (.) be wa? And let's say fmap is ni.
16:54:18 <Gracenotes> filter even ni wa tail wa groupBy (==) xs desu
16:56:55 <olsner> you can go a few steps further and make a RomajiPrelude, then it would be something like... firuteru iiben ni wa teiru wa guruupuBai (==) xs desu
16:59:02 * Baughn sneaks up on olsner with an unsafePerformIO tucked behind his back
17:01:12 <olsner> oh noes, my purity is in jeopardy
17:29:31 <calsaverini> hi
17:32:29 <calsaverini> I don't know a great deal of Haskell and early to day I was needing to translate some objects from python to learn
17:32:39 <calsaverini> but I runned into a problem
17:33:13 <SamB_XP> quick, a lambdacat I commision!
17:33:29 <SamB_XP> whoever does the best one can have, uh, some earwax I guess ;-)
17:33:58 <calsaverini> I was trying to do an algebraic data type this way
17:34:39 <calsaverini> data Agent = Agent {position :: Int, move :: Int->Int}
17:35:02 <calsaverini> just to try out
17:35:36 <calsaverini> but then I realized that I would never have my ''agent'' to move!
17:36:04 <calsaverini> because the variables never change, that's right?
17:36:08 <olsner> yeah, you'd have to do something like: move :: Agent -> Int -> Agent
17:36:15 <Alpounet> I'd rather see an external move function : move :: Agent -> Int -> Agent
17:36:42 <Alpounet> it wouldn't modify your Agent, but it'd return a new one, with the new position
17:36:52 <calsaverini> hummm
17:37:06 <olsner> or you could remove the "position" as something intrinsic to the Agent (e.g. your "world" could be a mapping from positions to agents rather than a list of agents having positions)
17:37:36 <calsaverini> that sound's nicer
17:37:39 <calsaverini> sounds
17:38:39 <calsaverini> Is there a way to do something like that with monads? I really don't know monads yet, but this would be a good motivation
17:39:16 <Rotaerk_> hmm do you guys use this design pattern any? http://homepages.cwi.nl/~ralf/syb1/
17:39:44 <Rotaerk_> seems like it aids in boilerplate reduction at the cost of performance
17:39:54 <jmcarthur> Rotaerk_: http://hackage.haskell.org/package/syb
17:40:04 <jmcarthur> there are a few who use it
17:40:05 <Peaker> please sort your args so it forms:  Int -> Agent -> Agent        a->a functions are useful
17:40:15 <Rotaerk_> k
17:40:24 <codm> syb shouldn't need to affect performance
17:40:36 <codm> for instance you can use it to generate static marshalling code
17:41:00 <Alpounet> Peaker, moving a given/fixed agent could be useful too
17:41:08 <olsner> calsaverini: I'm assuming you're building some kind of simulation here? one application of monads would be to put the world state in a State monad (which is essentially just convenience for composing functions that produce new worlds from old worlds)
17:41:23 <burp> t1 <- getCurrentTime; mapM_ (hPutStr h) (replicate 100 "foobar"); t2 <- getCurrentTime
17:41:25 <Peaker> Alpounet, what do you mean?  Int -> Agent -> Agent  moves a given agent
17:41:32 <Rotaerk_> codm, well the strategy presented in the paper I linked results in traversing the entire state, rather than just what is necessary to access the parts that need to be transformed/queried
17:41:34 <Peaker> Alpounet, oh, I see what you mean
17:41:41 <burp> can I be sure that the difference between t1 and t2 is the time it took to send the data?
17:41:54 <Rotaerk_> which is how you make it generic, but has a little overhead due to the extra traversal
17:41:59 <Alpounet> Peaker, I mean : foo = move some_agent then foo 4 then foo 5
17:42:00 <Alpounet> etc
17:42:09 <Peaker> Alpounet, well, I guess its hard to judge whether its more likely that   move 5   will be more useful than  move someAgent   but (a -> a) is a bit less arbitrary and directly usable in more functions
17:42:18 <Alpounet> Anyway, it's just a "flip" matter to have it in your case
17:42:19 <SamB_XP> Rotaerk_: true
17:42:20 <Peaker> (e.g iterate)
17:42:34 <jmcarthur> i usually err on the side of a -> a
17:42:34 <Peaker> Alpounet, so I like it as a convention to have one less arbitrary choice to make in code :)
17:42:40 <Alpounet> ok
17:43:39 <olsner> (but monads are so common in haskell and very generic, so I think it's kind of like asking "is there some way to do this with a class?" in Java)
17:44:06 <Rotaerk_> but oh well, one should expect some overhead when dealing with immutables
17:44:16 <SamB_XP> olsner: not *quite* as silly
17:44:30 <codm> Rotaerk_: Have a look at derive:
17:44:30 <codm> http://hackage.haskell.org/package/derive
17:44:43 <SamB_XP> there is no way to write Java without classes, afaik
17:44:44 <codm> I haven't really used it, but looks like it can generate the code you need.
17:44:46 <Rotaerk_> if you had mutables, you wouldn't have to traverse so much, since you could reliably look at the same "object"
17:44:55 <SamB_XP> but you can write Haskell that uses other structures
17:45:00 <olsner> SamB_XP: no, not *quite* ... was searching for a closer metaphor
17:45:04 <jmcarthur> burp: you can't be sure exactly. there is no telling how long the duration between actions is
17:45:13 <jmcarthur> burp: it's a pretty close measurement though, usually
17:45:17 <Rotaerk_> codm, thanks, could come in handy
17:45:46 <Perceptron> Hey guys another newbie question i have a function multSM, which is multiplying a double with a Matrix which is defined as [[double]], i have a function  defined as multSM a b = [[a * x| d <- b, x<- d]] but i keep getting something like [[3.0,6.0,9.0,3.0,6.0,9.0,3.0,6.0,9.0]] rather than [[3.0,6.0,9.0],[3.0,6.0,9.0],[3.0,6.0,9.0]] can someone give me a hint at what im doing wrong or hwat im...
17:45:47 <Perceptron> ...missing
17:46:41 <olsner> I think you're just nesting those []'s wrong
17:46:44 <Peaker> Perceptron, You want something like:  [[a*x|d<b]|x<-d]
17:47:18 <Peaker> Perceptron, or if using SECs:  mulSM a b = (map . map) (*a) b
17:47:45 * FunctorSalad_ just noticed ghc-core (using haskell-colorize) throws away some highlighting information...
17:47:55 <FunctorSalad_> you can edit haskell-colorize and get moar colors :)
17:48:20 <jmcarthur> rainbowcore!
17:48:21 <Peaker> I love SECs :)
17:48:36 <FunctorSalad_> especially distinguishing constructors and vars is useful
17:48:36 <Perceptron> k Peaker let me give that a try thank you
17:48:46 <burp> jmcarthur: hmm, that not useful for me anyway, I didn't about os-buffering
17:48:56 <burp> so it's not good to measure send-speed for small data amounts
17:49:10 <burp> ~think about
17:49:53 <Peaker> I don't tend to use list comps much
17:49:56 <olsner> Peaker: SEC?
17:50:44 <Peaker> @where SEC
17:50:45 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
17:51:58 <calsaverini> Peaker, olsner, Alpounet, thanks. I was carefully reading what you wrote. I think I get it.
17:52:01 <Peaker> olsner, Composing "semantic editors".  You have some big composite type, say:  (a, b -> [[c]])   and you want to apply a function to the c, for example, you have (c -> d) and you want: (a, b -> [[d]]).  You can apply something like (second . result . map . map) cToD
17:52:08 <iammisc> is there any haskell library which will help me convert an nfa to a dfa?
17:52:22 <olsner> Peaker: ah, looks neat
17:52:31 <olsner> reminds me a bit of lenses
17:53:12 <Peaker> olsner, Yeah, they are like lenses, but lenses have to apply (a -> a) functions, and SECs can apply (a -> b) functions. Lenses can compose getters with the setters, SECs cannot.  I personally feel lenses with SEC power are lacking here :)
17:53:27 <calsaverini> olsner, yes my ambition is to do Agent Based Simulation with Haskell, but I'm still struggling to learn the basics
17:54:12 <SamB_XP> so, you want semantics lenses ?
17:54:17 <SamB_XP> er.
17:54:20 <SamB_XP> semantic lenses?
17:54:55 <Peaker> iammisc, Maybe http://vorlon.case.edu/~lps/software/automata/index.html and http://www.haskell.org/haskellwiki/Tying_the_Knot
17:55:11 <calsaverini> I like to learn a new language by solving some real problem with it and I still haven't found a real problem that I'm capable of solving with Haskell at my current state of knowledge
17:55:54 <SamB_XP> calsaverini: maybe you should write silly compiler ;-)
17:56:07 <SamB_XP> +a
17:56:09 <Perceptron> Hey Peaker im jsut learning haskell is there osmething or a site u can recommend im jsut doing a bunch of Matrix  funcitons which involve me traversing each node
17:56:15 <SamB_XP> there was supposed to be an "a" in there
17:56:30 <Peaker> Perceptron, learn you a haskell, RWH? The standard learning materials
17:57:14 <Perceptron> i know the standard learning material im wondering if theres  asite or something u would recommend over others
17:57:17 * SamB_XP jokingly suggests the gentle introduction ;-P
17:58:56 * ddarius liked the Gentle Introduction.
17:59:16 <dbelange> Is Haskell the language with the crazy guy who has a really long fake name?
17:59:16 <SamB_XP> well, I may have too
17:59:17 <SamB_XP> I forget
17:59:30 <Peaker> Perceptron, I don't have any specific recommendations
17:59:36 <SamB_XP> but I did eventually discover that that was what I used ;-)
17:59:39 <Peaker> Perceptron, Conal's blog is great, but its a little advanced for a beginner
18:00:00 <Perceptron> i have programming background but not with functiona launguages
18:00:15 <Peaker> Perceptron, I meant Haskell beginner
18:00:23 <Perceptron> o ok
18:00:34 <Peaker> Perceptron, I think the best way to learn is to try to write stuff and then get feedback on how to improve it
18:00:42 <Peaker> Perceptron, (And understand that feedback, of course)
18:01:09 <codm> For me learning Haskell, I think the big breakthrough was when I read the "Awkward Squad" paper:
18:01:09 <codm> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
18:01:09 <codm> I'd already worked through the gentle introduction, but didn't really "get it" until I read that paper.
18:01:13 <Perceptron> of course :) thats what ive been doing but i feel bad i keep asking stuff here
18:01:38 <codm> Not sure that paper is helpful if you are doing matrix operations, though.
18:03:00 <Perceptron> ill take a look thank yiou
18:03:39 <codm> Perceptron: You can safely skip the subsections on semantics.
18:04:00 <Perceptron> kk
18:04:16 <Peaker> Perceptron, Don't feel bad asking here :)
18:04:19 <sproingie> get emacs set up to do flymake with haskell and you get instant feedback
18:04:29 <sproingie> fast machine recommended :)
18:04:54 <Perceptron> im using Hugs atm
18:05:02 <rgrinberg> sproingie: what would you consider fast? if you don't mind me asking
18:05:11 <Peaker> sproingie, hlint in flymake could be nice
18:05:18 <SamB_XP> codm: you know, there's a part of that paper I don't really get myself ...
18:05:21 <sproingie> rgrinberg: quad core i7 920?
18:05:46 <sproingie> hlint might be nice to stick in there
18:06:06 <SamB_XP> does flymake annotate your code like SLIME does?
18:06:12 <sproingie> right now i just have ghc with -Wall
18:06:13 <SamB_XP> only of course slime doesn't do it unbidden ...
18:06:23 <sproingie> sort of
18:06:28 <sproingie> it hilights
18:06:37 <sproingie> nothing's quite as fancy as slime
18:06:43 <SamB_XP> aww
18:06:47 <SamB_XP> no underlining?
18:06:49 <codm> SamB_XP: Yeah, the semantics and such are not that easy to read, but the pictures with putChar and getChar made me finally understand monads.
18:06:54 <sproingie> it hilights the line
18:07:16 <SamB_XP> codm: no, actually, the part I have trouble with is the title joke
18:07:47 <codm> SamB_XP:  Huh?  Is it a reference to something?
18:07:59 <SamB_XP> codm: I assume
18:08:07 <sproingie> there's a page on the emacs wiki to get the curent error from the current line.  flymake isn
18:08:17 <sproingie> flymake out of the box isn't so good at that
18:09:02 <codm> So do you emacs users just use regular haskell-mode for indentation?
18:09:13 <codm> I use it, but find it forces all of my code to the right hand margin.
18:09:47 <codm> Challenging to keep all my lines under 80 characters.
18:09:48 <SamB_XP> codm: you must be writing overly complicated code ;-P
18:10:05 <SamB_XP> at least, that's what Linus would say
18:10:17 <sproingie> i never cared about 80 column limits
18:10:22 <codm> Or using very descriptive variable and function names
18:10:29 <Perceptron> hey Peaker:  quick question in the last one why did you use (map.map)? I see what map can do but i cant understand (map.map)
18:10:52 <Beelsebob> Perceptron: (map.map) lets you dig within a second layer of lists
18:11:01 <Beelsebob> you can read it in the same direction as the type
18:11:06 <aavogt> well, how wide is the actual text?
18:11:15 <dibblego> \f -> map (map f)
18:11:24 <codm> I mean if in a where clause you define a function that takes an argument with a constructor, and the function is a do block, you have basically already used up the first 40 columns for the entire rest of your function.
18:11:24 <Perceptron> Oo ok gotcha
18:11:31 <dibblego> \f x -> map (\y -> map f y) x
18:11:31 <ddarius> SamB_XP: Write some type heavy C#.  You'll easily surpass 80 characters and will quickly come to appreciate type inference.
18:11:44 <ddarius> :t map . map
18:11:45 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
18:11:45 <sproingie> i thought C# had type inference
18:11:51 <Beelsebob> so if we have something of type a -> [Maybe [(b,c)]], then (fmap . fmap . fmap . fmap . first) will work on the value of type b in there Perceptron
18:12:02 <dibblego> it does, I use it regularly
18:12:13 <sproingie> fap . fap . fap . fap
18:12:14 <ddarius> sproingie, dibblego: Very little.
18:12:28 <Perceptron> Beelsebob: o ok thank you
18:13:08 <Perceptron> dibblego: take a look at Dynamic coming in 4.0
18:13:48 <Peaker> Perceptron, map . map is a "Semantic Editor Combinator". It takes a function and applies it in values buried inside 2 lists
18:15:05 <aavogt> codm: you can put the body of the function mostly to the left of the = on the previous line, as long as it is indented more than the first character of the function's name. I'm not sure if emacs' haskell-mode does that though
18:15:27 <aavogt> or whether it can be configured to do that
18:15:58 <sproingie> haskell mode mostly cycles between different suggested indents when you hit tb
18:15:59 <sproingie> tab
18:17:10 <codm> Right, my point is that emacs haskell-mode is not very parsimonious with indentation.
18:18:14 <codm> I can write the code I want, but emacs tries to indent it differently.
18:21:49 <FunctorSalad_> it's also really annoying that it won't offer zero indentation for imports in a new file
18:22:06 <FunctorSalad_> (after you write "module Gazonk where\n")
18:23:59 <m4ik3ru> Howdy.
18:24:43 <Perceptron> hey peaker sorry to bug u again for MatrixAddition  what is the way to go about it  im trying to figure something out but cant the defenition is addM :: Matrix  -> Matrix -> Matrix
18:24:51 <m4ik3ru> I'm sure I could (probably) find this by Google-ing, but asking is faster.
18:25:00 <codm> But the worst thing is if statements in a do block, because there emacs actually introduces bugs in your code.
18:25:01 <m4ik3ru> Plus, I don't have GHC on this comp.
18:25:02 <m4ik3ru> ...
18:25:03 <m4ik3ru> wait...
18:25:26 <m4ik3ru> > toInt "123"
18:25:27 <lambdabot>   Not in scope: `toInt'
18:25:38 <Peaker> Perceptron, what's the Matrix type?
18:25:40 <codm> > read "123" :: Int
18:25:41 <lambdabot>   123
18:25:45 <Perceptron> [[Double]]
18:25:51 <Perceptron> type Matrix = [[Double]]
18:25:54 <m4ik3ru> codm: Thanks :)
18:26:03 <Peaker> Perceptron, well, first, you'd want to zip an operation on the two lists, right?
18:26:20 <m4ik3ru> asking by trying it by myself and failing doesn't seem NEAR as n00bish :)
18:26:38 <Perceptron> peaker right
18:26:44 <aavogt> @type zipWith (+) -- Perceptron
18:26:45 <Perceptron> i think thats where my problem is though
18:26:45 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
18:27:04 <Peaker> Perceptron, so lets start with:  addM xss yss = zipWith addZipLists xss yss    right?
18:27:40 <Perceptron> i havnt seen AddZipList before
18:28:33 <aavogt> that's because you're supposed to define it
18:28:44 <Peaker> Perceptron, how would you define addZipLists?
18:30:00 <Perceptron> wouldnt it be [double]->[double]->[double]
18:30:06 <Peaker> Perceptron, Yep!
18:30:11 <Peaker> Perceptron, How do you define it?
18:30:42 <Perceptron> addZip :: [Double] -> [Double] -> [Double]
18:32:05 <Perceptron> I wanna say i end up using map inside the function no?
18:32:07 <m4ik3ru> can i define my own datatypes to lambdabot?
18:32:24 <m4ik3ru> like data something = whatever and then use that?
18:34:00 <Peaker> Perceptron, A map cannot combine two lists, it can only manipulate the values inside a list
18:34:01 <aavogt> @let type Probably = Bool
18:34:02 <lambdabot>  Invalid declaration
18:34:12 <Peaker> Perceptron, Whenever you want to "walk" 2 lists in parallel, you really want some kind of "zip"
18:34:20 <dibblego> ddarius, worse is that the mono compiler crashes in some cases if it cannot infer a type variable
18:34:52 <ddarius> dibblego: I've never used mono.
18:35:40 <Perceptron> Peaker ok then what do i do in addZipLists? im really confused about that part
18:36:17 <Peaker> Perceptron, hint: its similar to how we defined addM
18:37:37 <m4ik3ru> > scanl1 (+) [1,3..100]
18:37:38 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:38:19 <Perceptron> k so im gussing addZipLists xss yss = zipWith addZip xss yss
18:38:32 <Perceptron> then addZip :: Double -> Double -> Double
18:38:35 <Perceptron> is that correct
18:39:09 <Perceptron> and then the definition of addZip a b  = a  + b
18:40:15 <Peaker> Perceptron, Heh, yeah, can you think of a more concise way to define addZip?
18:41:42 <Perceptron> uhm u mean the actual definition of it?
18:41:57 <Perceptron> i cant say i do
18:42:07 <SamB_XP> @pl  addZip a b  = a  + b
18:42:08 <lambdabot> addZip = (+)
18:42:17 <SamB_XP> lambdabot can for once ;-)
18:43:00 <Peaker> Perceptron, so, addZip = (+)
18:43:09 <Perceptron> hmm i actually didnt know that owuld work
18:43:13 <Peaker> Perceptron, so its just add, not addZip. How can you redefine addZipLists ?
18:44:29 <Perceptron> addZipList = zipWith add ?
18:44:57 <cocon> what does the '-A' RTS option do? (what is the 'allocation area'?)
18:45:30 <Peaker> Perceptron, well, add is called (+) really, not add
18:45:44 <Peaker> Perceptron, I was just commenting that addZip = (+) is a really bad name, because there's no zipping going on, just a normal add
18:45:55 <Perceptron> i undestand that
18:46:02 <Peaker> Perceptron, but its good that you have eliminated the xss and yss arguments :)
18:46:12 <Peaker> Perceptron, addZipLists = zipWith (+)  indeed
18:46:22 <Peaker> Perceptron, so how can you now re-define addM?
18:46:55 <sbahra> :t addM
18:46:56 <lambdabot> Not in scope: `addM'
18:46:59 <sbahra> what is addM
18:47:01 <Perceptron> Peaker: addM = zipWith addZipLists
18:47:06 <aavogt> Peaker: how to address monomorphism restriction?
18:48:27 <SamB_XP> cocon: GHC uses a small region to allocate objects into, which it then copies into the first generation after the region gets full
18:48:57 <cocon> SamB_XP: why does it do that?
18:49:17 <SamB_XP> cocon: ask JaffaCake
18:49:36 <cocon> JaffaCake: why does it do that? :)
18:49:44 <Perceptron> thanks peaker :D
18:49:48 <sbahra> @faq Why does it do that?
18:49:48 <lambdabot> The answer is: Yes! Haskell can do that.
18:50:02 <Peaker> Perceptron, inline addZipLists in there :)
18:50:06 <Peaker> Perceptron, we're not done! heh
18:50:15 * sbahra dives back to work
18:50:26 <Perceptron> what do you mean inline?
18:51:21 <Peaker> Perceptron, Replace "addZipLists" in addM with its definition
18:51:37 <Peaker> aavogt, Use a type signature
18:51:41 <Peaker> aavogt, or turn it off
18:52:16 <wdonnelly> cocon: a lot of memory is only needed for a very short time, so by putting the newest allocated memory regions in a "nursery" area, the GC can avoid checking all used memory on every pass, in favor of just examining the nursery objects
18:52:53 <Perceptron> Peaker: addM xss yss = zipWith (zipWith (+)) xss yss is what i got
18:52:59 <cocon> so -A lets me pick the size of that nursery?
18:53:01 <Peaker> Perceptron, you can eliminate the arguments
18:53:05 <Perceptron> oo ok
18:53:14 <Perceptron> addM = zipWith (zipWith (+))
18:53:25 <Peaker> Perceptron, and now, if you use (.) form:
18:53:31 <Peaker> addM = (zipWith . zipWith) (+)
18:53:46 <Peaker> Perceptron, which looks really similar to (map . map) (*a)
18:53:55 <Perceptron> ya it does
18:54:00 <Perceptron> addM = (zipWith . zipWith) (+)
18:54:07 <Peaker> Perceptron, and if you ever add another dimension, you throw in another zipWith in there
18:54:10 <Perceptron> wow thats alot simplar than what i had originally
18:55:00 <m4ik3ru> > length "123"
18:55:01 <lambdabot>   3
18:55:07 <Peaker> Perceptron, That's generally what happens with Haskell.. :)
18:55:36 <Perceptron> this is pretty ineresting im leaning haskell and scheme right now and they ar esomewhat similar
18:55:51 <Peaker> Perceptron, The building blocks are different from other languages. At first they seem cumbersome and inconvenient, and slowly you learn how to build up more convenient things, until other languages are completely left behind :)
18:56:14 <Perceptron> lol im coming form a c/C++ background so its verryyy different
18:56:25 <Peaker> (But I think people who come from other languages might give up before they see this)
18:56:52 <m4ik3ru> Perceptron: So am I, and so far, thanks in a big way to this channel, I LOVE Haskell :)
18:57:13 <Perceptron> haha im hoping i can get there :) this is my frist week
18:58:04 <Perceptron> kk time to try and do the rest of these funtions i will defenitley be asking alot more questions
19:08:52 <cocon> what are typical allocation rates?
19:09:35 <bitstream0101> i'm attempting to convert a (huge) recursive Make hierarchy to cabal, which i've not used for anything but trivial packages. If I need to invoke things like happy & alex as a part of the build process, I assume that something like the preBuild hook might be what I'm looking for?
19:09:56 <mgorbach> A noob question: I've a type: data Tree a = Leaf a | Node a (Tree a) (Tree a). How do I wrote a function that will access its individual components?
19:10:08 <wdonnelly> cocon: it depends on your program, but i think GHC's profiling fanciness will tell you that kind of thing
19:11:04 <codm> mgorbach:
19:11:04 <codm> f (Leaf a) = ...
19:11:04 <codm> f (Note a t1 t2) = ...
19:13:01 <Perceptron> hey Peaker one more question :S
19:13:46 <Perceptron> how can i do something like this : for the height of the matrix get 0..n-1 node and make it a column (matrix transpose)
19:14:55 <mgorbach> codm: Thanks.
19:15:01 <mgorbach> treeReverse :: Tree t -> Tree t
19:15:01 <mgorbach> treeReverse (Leaf l) = Leaf l
19:15:01 <mgorbach> treeReverse (Node a t1 t2) = (Node a t2 t1)
19:15:13 <mgorbach> I'm a bit confused ... is l a type variable?
19:15:56 <Peaker> @type transpose
19:15:57 <lambdabot> forall a. [[a]] -> [[a]]
19:16:04 <Peaker> Perceptron, this function?
19:16:10 <aavogt> @src transpose
19:16:10 <lambdabot> transpose []             = []
19:16:10 <lambdabot> transpose ([]   : xss)   = transpose xss
19:16:10 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:16:49 <Saizan> mgorbach: no, l there is the value contained in the Leaf constructor
19:17:56 <wdonnelly> cocon: following up on the above comment, passing the -S option to the GHC RTS will cause it to output some fairly detailed allocation information to stderr
19:18:12 <mgorbach> What about in the definition of the Tree type?
19:18:20 <dbelange> There's an RTS based on GHC?!?!?!
19:18:25 <bitstream0101> :i UserHooks
19:18:30 <bitstream0101> whups, wrong window :)
19:18:32 <Perceptron> Peaker sort of except that one jsut does the first column
19:18:34 <dbelange> Is there an FFS?
19:18:43 <dbelange> *FPS
19:18:52 <Perceptron> transp [[1,2,3],[1,2,3],[1,2,3]] outputs [[1.0,1.0,1.0]]
19:19:08 <dbelange> in which you lazily evaluate lambdas
19:19:10 <Saizan> mgorbach: there 'a' is a type variable, it's used to tell which type should have the value in that position
19:19:37 <Peaker> > transpose (replicate 3 [1,2,3])
19:19:38 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
19:19:45 <Saizan> mgorbach: e.g. given that definition the Leaf constructor has type "t -> Tree t"
19:20:00 <Badger> @src transpose
19:20:00 <lambdabot> transpose []             = []
19:20:00 <lambdabot> transpose ([]   : xss)   = transpose xss
19:20:00 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
19:20:08 <Saizan> mgorbach: and Node instead has type "t -> Tree t -> Tree t -> Tree t"
19:22:44 <Saizan> @let getCol n xs = [map (!! n) xs]
19:22:45 <lambdabot>  Defined.
19:22:55 <Saizan> > getCol 0 [[1,2,3],[1,2,3],[1,2,3]]
19:22:56 <lambdabot>   [[1,1,1]]
19:23:01 <Saizan> > getCol 1 [[1,2,3],[1,2,3],[1,2,3]]
19:23:02 <lambdabot>   [[2,2,2]]
19:23:06 <Saizan> > getCol 4 [[1,2,3],[1,2,3],[1,2,3]]
19:23:07 <lambdabot>   [[* Exception: Prelude.(!!): index too large
19:23:21 <Saizan> Perceptron: something like that? ^^
19:23:55 <Perceptron> ya
19:24:12 <Perceptron> the source that transpose had does it im just trying to understand it
19:24:14 <jaredj> @pl \n xs -> [map (!! n) xs]
19:24:15 <lambdabot> flip flip [] . ((:) .) . map . flip (!!)
19:24:41 <mmorrow> @pl \n -> (!! n) . transpose
19:24:41 <lambdabot> (. transpose) . flip (!!)
19:26:07 <mmorrow> @undo \g f xs -> [g y | x <- xs, y <- f x]
19:26:07 <lambdabot> \ g f xs -> concatMap (\ x -> concatMap (\ y -> [g y]) f x) xs
19:26:09 <Peaker> why doesn't it say:  flip (!!) . (. transpose) ?
19:27:31 <mmorrow> @undo \g f xs -> [[z*z | z <- g y] | x <- xs, y <- f x]
19:27:31 <lambdabot> \ g f xs -> concatMap (\ x -> concatMap (\ y -> [concatMap (\ z -> [z * z]) g y]) f x) xs
19:28:48 <mmorrow> @undo \f m n -> sum [f i | i <- [m..n]]
19:28:49 <lambdabot> \ f m n -> sum concatMap (\ i -> [f i]) [m .. n]
19:29:01 <Saizan> Peaker: that'll get you \n -> flip (!!) (n . transpose), no?
19:29:01 <mmorrow> um
19:29:10 <mmorrow> @type \ f m n -> sum concatMap (\ i -> [f i]) [m .. n]
19:29:11 <lambdabot>     Couldn't match expected type `[a]'
19:29:11 <lambdabot>            against inferred type `(a1 -> [b]) -> [a1] -> [b]'
19:29:11 <lambdabot>     In the first argument of `sum', namely `concatMap'
19:29:18 <mmorrow> undo fail
19:29:18 <Peaker> @unpl (. transpose) . flip (!!)
19:29:19 <lambdabot> (\ g j -> (transpose j) !! g)
19:29:28 <Peaker> @unpl flip (!!) . (. transpose)
19:29:29 <lambdabot> (\ g c -> c !! \ j -> g (transpose j))
19:29:54 <Peaker> Saizan, ah whoops. I've trained myself to treat those as equivalent. oops :)
19:32:00 <Gracenotes> yes, I'd love to find the \j -> g (transpose j)th index of the list
19:32:27 <Peaker> @let result=(.);arg=flip (.)
19:32:29 <lambdabot>  Defined.
19:32:40 <Peaker> @type \f g -> result f . arg g
19:32:42 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
19:32:48 <Peaker> @type \f g -> arg g . result f
19:32:50 <lambdabot> forall a b b1 c. (b1 -> c) -> (a -> b) -> (b -> b1) -> a -> c
19:33:00 <SamB_XP> @unpl (.)(.)
19:33:01 <lambdabot> (\ b c e f -> b c (e f))
19:33:02 <Peaker> this is what I was thinking
19:33:04 <SamB_XP> @unpl (.).(.)
19:33:05 <lambdabot> (\ i b c f -> i (b c f))
19:33:17 <SamB_XP> @unpl (.).(.).(.)
19:33:17 <lambdabot> (\ l b c f i -> l (b c f i))
19:33:37 <mmorrow> @unpl \a b c d -> g (f a b c d)
19:33:37 <lambdabot> \ a b c d -> g (f a b c d)
19:33:37 <SamB_XP> @unpl (.).(.).(.).(.)
19:33:38 <lambdabot> (\ o b c f i l -> o (b c f i l))
19:33:40 <bitstream0101> anyone have a .cabal file around that demonstrates use of happy or alex running on files prior to them being built by cabal/ghc?
19:33:45 <mmorrow> @pl \a b c d -> g (f a b c d)
19:33:45 <lambdabot> (((g .) .) .) . f
19:33:59 <SamB_XP> @pl (\ o b c f i l -> o (b c f i l))
19:33:59 <lambdabot> (.) . (.) . (.) . (.)
19:34:47 <mmorrow> , ppDoc <$> fmaps 4
19:34:49 <lunabot>  PRIVMSG #haskell : PRIVMSG #haskell : fmap . (fmap . (fmap . fmap))
19:34:53 <mmorrow> :o
19:34:56 <Veinor> oh dear.
19:35:01 <Peaker> , 1
19:35:01 <Saizan> bitstream0101: see the happy package itself
19:35:02 <mmorrow> , ppDoc <$> fmaps 4
19:35:03 <lunabot>  1
19:35:04 <lunabot>  fmap . (fmap . (fmap . fmap))
19:35:08 <mmorrow> :o !
19:35:12 <bitstream0101> Saizan: Thanks.
19:35:12 <Veinor> :o !
19:35:20 <Veinor> , ppDoc <$> fmaps 4
19:35:22 <lunabot>  fmap . (fmap . (fmap . fmap))
19:35:23 <dancor> :x
19:35:38 <mmorrow> i wonder wut sequence of random events caused that
19:35:47 <Saizan> bitstream0101: the only thing you've to do is to use the appropriate .ly or .y extension and list the modules in exposed-modules or other-modules, depending on where they belong
19:37:27 <bitstream0101> Saizan: That's what I would have thought, but when I supply that extension for other-modules (for an executable target), I just get a parse error from cabal.
19:38:04 <bitstream0101> other-modules wants to parse an actual package name, not a source file name it looks like
19:38:42 <bitstream0101> and that's consistent with happy's cabal file as well -- only package names in other-modules.
19:41:44 <Saizan> bitstream0101: yeah, only the module name goes in the .cabal file
19:41:57 <Saizan> bitstream0101: but you've to use the correct extension for your file
19:42:10 <m4ik3ru> Assuming Pos and Token are two data types that I had previously defined, why does this code give an Invalid Type Signature error?
19:42:11 <codm> Why do the default libraries not include anything like a condition variable with a broadcast operation?
19:42:12 <m4ik3ru> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10221#a10221
19:42:57 <Saizan> m4ik3ru: functions have to start lowercase
19:43:09 <Saizan> m4ik3ru: only constructors are capitalized
19:43:25 <bitstream0101> Saizan: There's a file called, e.g. MyModule.x somehwere in the hs-source-dirs hierarchy; just saying MyModule on the other-modules line does nothing.
19:43:59 <bitstream0101> Saizan: Nevermind =D
19:44:03 <bitstream0101> Saizan: thanks.
19:44:11 <m4ik3ru> Saizan: so all i have to do is change TokPos to tokPos?
19:44:43 <Saizan> m4ik3ru: yes
19:44:46 * m4ik3ru is an idiot
19:45:12 <Saizan> assuming both Token and Pos have kind *
19:45:20 <m4ik3ru> kind?
19:45:29 <Saizan> i.e. they don't take type parameters
19:45:36 <m4ik3ru> they don't
19:45:43 <m4ik3ru> well...
19:46:01 <m4ik3ru> no, they don't
19:46:10 <Saizan> a kind is the type of a type, it tells you which type parameters it gets
19:46:12 <Saizan> ?kind Int
19:46:13 <lambdabot> *
19:46:16 <Saizan> ?kind Maybe
19:46:17 <lambdabot> * -> *
19:46:22 <Saizan> ?kind RWS
19:46:23 <lambdabot> * -> * -> * -> * -> *
19:46:32 <Saizan> ?kind StateT
19:46:33 <lambdabot> * -> (* -> *) -> * -> *
19:47:03 <Saizan> * is the kind of the types of values
19:47:48 <ivanm> preflex: seen jfredett
19:47:48 <preflex>  jfredett was last seen on #haskell 9 hours, 57 minutes and 22 seconds ago, saying: hmm, I thought it only worked on types fo some reason... :/
19:48:03 <ivanm> @tell jfredett I like your description of my upload attempts...
19:48:04 <lambdabot> Consider it noted.
19:48:30 <m4ik3ru> Saizan: Fixed that error, now I have another :)
19:48:53 <m4ik3ru> As soon as I can get it to compile I'll :t it in ghci
20:01:22 <m4ik3ru> what is the type of x in x:xs?  string or char?  a string is just a list of chars, right?  is [x,y] a valid definition of a string?
20:01:49 <Saizan> m4ik3ru: it is if x and y are Char
20:02:03 <m4ik3ru> x and y are from x:y:xs
20:02:36 <Saizan> if (x:y:xs) is a String then they are indeed Char's, since String = [Char]
20:02:50 <Saizan> and
20:02:53 <Saizan> ?type (:)
20:02:53 <lambdabot> forall a. a -> [a] -> [a]
20:03:11 <m4ik3ru> i'm getting another set of errors i don't understand, then...
20:03:16 <m4ik3ru> let me take another look
20:03:19 <m4ik3ru> i'll be right back'
20:03:44 <Saizan> you can try adding type signatures to your toplevel definition
20:03:58 <Saizan> or you can paste the code if you're stuck :)
20:05:03 <m4ik3ru> i'll paste it in a sec :)
20:12:21 <Perceptron> hey Peaker you still there?
20:17:11 <Perceptron> has anyone done any matrix multipication or matrix determinant calculation in haskell?
20:17:28 <aavogt> yes
20:17:58 <Perceptron> Do you mind helping me out im somehwat lost trying to write these two functions
20:19:48 <cdsmithus> Perceptron: Yes.  But how are you representing matrices?  And what size matrices are you dealing with?  Is performance a concern?
20:20:13 <ivanm> there's also hmatrix if this isn't a homework problem...
20:20:15 <Perceptron> type Matrix = [[Double]]
20:20:43 <Perceptron> this is jsut a practice thing im doing to get familiar with Haskell so performance is not that big of a concern and size nothing too big
20:21:21 <ivanm> Perceptron: for matrix multiplication, why don't you try transposing the second matrix and then doing things on a "row" bases (assuming each list in your lists of lists is a row)
20:21:27 <ivanm> s/bases/basis/
20:21:27 <cdsmithus> Perceptron: Okay, matrix multiplication is really probably just a matter of writing down the definition as a list comprehension.  It's a one-or-two line thing.  Determinants are more interesting.
20:21:52 <m4ik3ru> :t isSpace
20:21:53 <lambdabot> Char -> Bool
20:21:53 <ivanm> cdsmithus: well, nested comprehensions maybe
20:21:57 <m4ik3ru> huh
20:22:05 <ivanm> > isSpace '\t'
20:22:06 <lambdabot>   True
20:22:08 <ivanm> > isSpace '\n'
20:22:09 <cdsmithus> ivanm: yes, they'd be nested.  You're right
20:22:10 <lambdabot>   True
20:22:23 <m4ik3ru> so if x in x:xs is a char, [x] should be a string.
20:22:35 <ivanm> yes
20:22:43 <ivanm> since [x] == x:[]
20:22:48 <m4ik3ru> ...huh.
20:22:50 <m4ik3ru> brb
20:23:20 <cdsmithus> Perceptron: Determinants can be calculated via three ways: signed elementary products, cofactors, or elimination.  That in order from easiest/slowest to hardest/fastest.
20:24:00 <Perceptron> k so i think im probably gonna do signed elementary products cause i want to learn first
20:24:05 <Perceptron> then maybe try and do elimination
20:24:08 <cdsmithus> Actually, maybe cofactors are easier
20:25:43 <aavogt> an excellent opportunity for laziness in the algorithm
20:26:02 <Cale> Elimination can be done recursively with not too much trouble
20:28:35 <Perceptron> hmmm
20:28:57 <Perceptron> how is cofactors good opportunity for laziness in the algorithm
20:29:32 <aavogt> > cycle [1,-1]
20:29:33 <lambdabot>   [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1...
20:29:47 <aavogt> > tails $ cycle [1,-1]
20:29:48 <lambdabot>   [[1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-...
20:30:00 <Cale> > let dot xs ys = sum (zipWith (*) xs ys); mult u v = [[dot r c | c <- transpose v], r <- u]; rot t = [[cos t, -sin t],[sin t, cos t]] in rot (pi/4) `mult` [[1],[0]]
20:30:01 <lambdabot>   <no location info>: parse error on input `<-'
20:30:14 <aavogt> > map (take 3) $ tails $ cycle [1,-1]
20:30:14 <lambdabot>   [[1,-1,1],[-1,1,-1],[1,-1,1],[-1,1,-1],[1,-1,1],[-1,1,-1],[1,-1,1],[-1,1,-1...
20:30:23 <ivanm> Cale making a Haskell mistake? that unpossible! :o
20:30:48 <ddarius> He wanted a bar not a comma.
20:30:51 <Cale> > let dot xs ys = sum (zipWith (*) xs ys); mult u v = [[dot r c | c <- transpose v] | r <- u]; rot t = [[cos t, -sin t],[sin t, cos t]] in rot (pi/4) `mult` [[1],[0]]
20:30:52 <lambdabot>   [[0.7071067811865476],[0.7071067811865475]]
20:31:06 <Cale> s/,/|/  :)
20:31:10 <cdsmithus> Perceptron: if you wanted to look at code, then the Math.Matrix module at http://patch-tag.com/r/cdsmith/flowequiv/snapshot/current/content/pretty/src/ has code for multiplication, and for cofactor expansion.  I posted some code on my blog recently for elimination; but it's maybe overly complex because I was trying to do typeclass tricks.
20:31:19 <mun> hi
20:31:19 <lambdabot> mun: You have 1 new message. '/msg lambdabot @messages' to read it.
20:31:27 <mmorrow> the dynamic paren/brace/etc matching highlighting code on paste.lisp.org is sweet
20:31:30 <ddarius> > exp (0:+ (pi/4))
20:31:31 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
20:31:51 <Perceptron> thanaks cdsmithus i will take a look at that
20:32:11 <ivanm> Cale: excuses, excuses!
20:32:28 <Alpounet>  "+-*/<>=   <= there other chars used for operators in Haskell ?
20:32:33 <mun> does anyone know how to use cabal to install a package from hackage? what command should i use?
20:32:36 <Alpounet> +are
20:32:39 <Cale> Alpounet: a bunch more
20:32:41 <ray> cabal install packagename
20:32:53 <cdsmithus> So people suggested I look at the fclabel and data-accessor packages.  They both seem to do the same thing.  Which is more popular?
20:33:03 <Alpounet> Cale, that is ?
20:33:18 <Cale> ascSymbol -> ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @ | \ | ^ | | | - | ~
20:33:23 <Alpounet> thanks
20:33:23 <ivanm> @where cabal-install
20:33:24 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
20:33:25 <ivanm> mun: ^^
20:33:31 <aavogt> > filter isPunctuation toEnum [1..]
20:33:31 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:33:32 <lambdabot>         against inferred ty...
20:33:36 <Cale> Alpounet: also, any unicode symbol or punctuation
20:33:37 <aavogt> > filter isPunctuation $ map toEnum [1..]
20:33:38 <lambdabot>   "!\"#%&'()*,-./:;?@[\\]_{}\161\171\183\187\191\894\903\1370\1371\1372\1373\...
20:33:53 <aavogt> , filter isPunctuation $ map toEnum [1..]
20:33:54 <Cale> Alpounet: but not _ : " or '
20:33:54 <lunabot>  "!\"#%&'()*,-./:;?@[\\]_{}\161\171\183\187\191\894\903\1370\1371\1372\137...
20:34:06 <m4ik3ru> ok, this code it EXTREMELY pared down:
20:34:07 <m4ik3ru> v
20:34:10 <m4ik3ru> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10222#a10222
20:34:23 <ddarius> Cale: By themselves
20:34:26 <m4ik3ru> i don't understand the errors if string is [char]
20:34:32 <m4ik3ru> :t String
20:34:33 <lambdabot> Not in scope: data constructor `String'
20:34:47 <ray> > let (@^@&???) = id in negate @^@&??? 45
20:34:48 <lambdabot>   -45
20:34:52 <Veinor> http://forums.somethingawful.com/attachment.php?postid=366504461
20:35:38 <Cale> m4ik3ru: elem x [words ...] is checking if x is an element of a one-element list
20:35:45 <cdsmithus> @type [words "= < > + - * % / ! [ ]"]
20:35:46 <lambdabot> [[String]]
20:35:52 <Cale> m4ik3ru: whose only element is a list of strings
20:36:01 <m4ik3ru> ...
20:36:05 <Cale> m4ik3ru: therefore, x should have to be a list of strings
20:36:06 <m4ik3ru> i need to process that...
20:36:24 <Cale> m4ik3ru: Basically, you don't want the square brackets
20:36:31 <cdsmithus> > [words "= < > + - * % / ! [ ]"]
20:36:32 <lambdabot>   [["=","<",">","+","-","*","%","/","!","[","]"]]
20:36:46 <m4ik3ru> on elem x [words]
20:36:57 <m4ik3ru> so it would be elem x words
20:37:03 <Cale> elem x (words "...")
20:37:05 <cdsmithus> Yes
20:37:33 <m4ik3ru> i don't know if i would have thought to check the type of words
20:37:40 <m4ik3ru> you guys are indispensable
20:37:43 <m4ik3ru> and gals :)
20:38:00 <monochrom> check the type of everything. type-driven programming.
20:38:18 <ddarius> @google Typeful Programming Cardelli
20:38:19 <lambdabot> http://citeseer.ist.psu.edu/320636.html
20:38:31 <m4ik3ru> monochrom: i learn more about that every day
20:38:34 <m4ik3ru> :)
20:38:49 <mmorrow> @let convolve (<>) fltr = let go r (xs:xss) = takeWhile (not . null) . dropWhile null . snd . foldl (\(n,xs) ys -> let n' = n+r in (n', zipWith (++) xs (replicate n' [] ++ fmap (:[]) ys ++ repeat []))) (r, replicate r [] ++ fmap (:[]) xs ++ repeat []) $ xss in go (length fltr `div` 2) . fmap (\y -> fmap (\x -> x <> y) fltr)
20:38:49 <lambdabot>  Defined.
20:39:14 * mmorrow had to google for that in old irc logs
20:39:34 <mmorrow> > convolve (*) [0.25,0.5,0.25] [1,3,1]
20:39:34 <lambdabot>   [[0.25],[0.5,0.75],[0.25,1.5,0.25],[0.75,0.5],[0.25]]
20:40:19 <mmorrow> @let blur t = fmap sum . init . tail . convolve (*) [t/2,1-t,t/2]
20:40:20 <lambdabot>  Defined.
20:40:32 <mmorrow> > blur 0.2 [0,1,0,1,0,1,0]
20:40:33 <lambdabot>   [0.1,0.8,0.2,0.8,0.2,0.8,0.1]
20:40:39 <ddarius> @pl fmap (\y -> fmap (\x -> x <> y))
20:40:39 <lambdabot> fmap (fmap . flip (<>))
20:40:47 <m4ik3ru> new errors: all i did was remove the brackets and i got "could not match expected type [String] against inferred type String -> [String]"
20:40:55 <m4ik3ru> does it have to do with my return type?
20:41:33 <cdsmithus> m4ik3ru: I'm guessing you didn't put in the parentheses you need
20:41:46 <m4ik3ru> heh
20:41:50 <m4ik3ru> let me check that :)
20:42:00 <m4ik3ru> i think i know what you mean
20:42:04 <mmorrow> @pl \xs -> fmap (\y -> fmap (\x -> x <> y) xs)
20:42:04 <lambdabot> fmap . flip (fmap . flip (<>))
20:42:10 <monochrom> <Cale> elem x (words "...")
20:43:08 <m4ik3ru> yeah, that was it :)
20:43:18 <m4ik3ru> i'm getting better at this
20:43:20 <m4ik3ru> :)
20:44:01 <cocon> Does (a `par` a `par` b) double work?
20:44:06 <cdsmithus> No opinions on whether data-accessor or fclabels is more popular?  Doesn't dons have stats on hackage popularity somewhere?
20:44:13 <ddarius> cocon: Not usually.
20:44:24 <cocon> ddarius: and unusually?
20:44:36 <ddarius> cocon: It definitely can do duplicate work.
20:45:14 <cdsmithus> Never mind... I was thinking out loud, and Google found the stats
20:45:23 <SamB_XP> actually, if you do it like that with a and a right in a row, it could easily do it, IMO ...
20:45:59 <cocon> ddarius: so what does it depend on?
20:46:16 <SamB_XP> ... depending, perhaps, on how many worker threads GHC is using
20:46:57 <cocon> hmmm, this doesn't seem to be clear
20:47:01 <ddarius> cocon: Nothing you can control.
20:47:31 <SamB_XP> but, it will STOP any double work right quick once it finishes the first instance ...
20:47:46 <SamB_XP> and it will avoid starting it pretty soon after starting
20:47:53 * mmorrow can't seem to find the fft compressed/mangled-to-an-irc-msg-sized-one-liner unfortunately
20:48:30 <SamB_XP> @google fft golf
20:48:30 <lambdabot> No Result Found.
20:50:29 <m4ik3ru> One error at a time :)
20:55:42 * ddarius needs to recreate his full-text paper database.
20:55:58 <m4ik3ru> BOOM!  got it :)
20:56:00 <m4ik3ru> now...
20:56:07 <m4ik3ru> to test for correctness....
20:56:28 <m4ik3ru> i mean, given enough time, a monkey could write a program that compiles.
20:57:03 <ddarius> m4ik3ru: If you make the types detailed enough, when the program compiles, it will be correct.
20:57:07 <Raynes> m4ik3ru: I read a story a while back about a group of some sort of Ape that managed to learn to write trivial code in VB.
20:57:37 <aavogt> @djinn (a -> b) -> (b -> c) -> (a -> c)
20:57:37 <lambdabot> f a b c = b (a c)
20:58:17 <m4ik3ru> Raynes: like what? awesome :)
20:59:04 <Raynes> m4ik3ru: I'm not sure, I'll see if I can't find the link.
20:59:59 <erikc> anyone know what the deal is with cabal/haskell platform on win7 with respect to directory permissions
21:00:06 <m4ik3ru> Raynes: I'll check the all-knowing Google :)
21:00:30 <Raynes> m4ik3ru: If you find it, let me know, I'll be looking for the link otherwise.
21:02:03 <flippo> Raynes, http://www.newtechusa.com/ppi/pressroom.asp#higher
21:02:35 <dolio> Hah. Nice.
21:05:56 <erikc> (fix is to make cabal.exe always run as administrator)
21:06:12 <Perceptron> Hey guyss jsut wanted to sy thanks for the help today very much appreciated
21:06:49 <bos> damn frickin frackin software bugs.
21:07:02 <SamB_XP> Perceptron: what? nobody helped you today!
21:07:07 <edwardk> bos does not appear to be having a good day.
21:07:09 <blackdog> bos: you tell 'em.
21:07:25 <SamB_XP> bos: is that why the RWH site is down?
21:07:48 <bos> SamB_XP: naw, flaky host.
21:07:49 <m4ik3ru> Raynes: That's awesome :)
21:08:29 <m4ik3ru> I'm gonna have to test for correctness later...
21:08:55 <m4ik3ru> Too...tired...must sleep...pt test in the morning...
21:09:55 <SamB_XP> Raynes: are they by any chance known as Code Monkeys?
21:10:12 <m4ik3ru> SamB_XP: HAHAHAHAHAHAHAHA!
21:10:19 <Raynes> SamB_XP: Lab monkeys would be more appropriate.
21:14:22 <mmorrow> "None of the baboons, regardless of rank, could perform an error-free compile or handle Windows registry tasks."
21:15:03 <SamB_XP> lol
21:24:12 * Saizan_ wonders how serious is this
21:30:47 <dolio> Well, it's a website for a company that will help you switch out your staff for teams of apes.
21:30:53 <dolio> I suspect it isn't that serious.
21:32:10 <SamB_XP> dolio: yeah
21:32:11 <Svrog> would someone be able to explain why the commented out definitions in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4250#a4250 don't work?
21:32:16 <Svrog> i'm confused
21:32:22 <dolio> It's also not the main website.
21:32:24 <SamB_XP> I think there are probably laws against that
21:32:45 <ddarius> SamB_XP: Why?
21:33:00 <FunctorSalad_> does anyone understand in which way the "html-minimalist" pkg is supposed to be more minimalist than "html"?
21:33:11 <ivanm> Svrog: it probably doesn't realise that the a in the where function is the same a in the test function...
21:33:17 <ivanm> (unless they don't have to be?)
21:33:22 <FunctorSalad_> seems to be exactly the same design
21:33:23 <SamB_XP> ddarius: well, at least, laws limiting the number of hours they can be made to work ...
21:34:05 <Svrog> i thought scoped type variables should take care of that
21:34:05 <flippo> Putting apes in cubicles might be considered animal cruelty.
21:34:09 <ivanm> Svrog: oh, wait, the type of the f function seems to be wrong
21:34:23 <Svrog> how?
21:34:29 <ivanm> Svrog: with State, the return value is of type b
21:34:34 <ivanm> but f returns an a
21:34:38 <ivanm> @src State
21:34:39 <lambdabot> Source not found. I am sorry.
21:34:39 <ddarius> SamB_XP: Are there laws limiting the number of hours a horse works?
21:34:41 <ivanm> @src St
21:34:41 <lambdabot> Source not found.
21:34:43 <ivanm> gah
21:35:01 <Svrog> no that's not it - the return value is cast back to a using unsafeCoerce
21:35:04 <SamB_XP> ddarius: but ... primates are special
21:35:10 <ivanm> Svrog: return x = State (\ _ -> (_,x)) -- something like this
21:35:13 <SamB_XP> especially non-human ones ...
21:35:30 <Svrog> the uncommented functions work, everything compiles and works as expected - the commented out functions fail with the error mentioned in the comment
21:35:31 <ivanm> Svrog: *shrug* then I don't know
21:35:39 <Svrog> and the only difference is passing f explicitly to h
21:37:01 <ivanm> *shrug* any particular reason you're doing coercion anyway?
21:37:09 <Svrog> generics
21:37:28 <Svrog> when you cast one value to another, you have to cast it back in the end
21:37:41 <Svrog> by that point you know the value is of the correct type so it's safe to use unsafeCoerce
21:37:47 <FunctorSalad_> generics? like syb?
21:37:52 <Svrog> yes
21:39:38 <Svrog> i'm confused about whether i misunderstood how scoped type variables are supposed to work or whether i perhaps found a bug in ghc, a bit reluctant to jump to that conclusion but after looking at this for over an hour i can't think of anything else, scoped type vars seem pretty straight forward
21:39:58 <ClaudiusMaximus> i thought ScopedTypeVariables required explicit forall (if i add forall a in test's type i get a new error)
21:40:22 <Svrog> hmm
21:40:24 <ClaudiusMaximus> and a suggestion to use FlexibleContexts
21:40:36 <ddarius> ClaudiusMaximus: They do require an explicit forall.
21:40:37 <Svrog> the type for test is fine though
21:40:38 <Svrog> as it is
21:40:45 <Svrog> it's the type of h that's the problem
21:41:26 <Saizan_> Svrog: if you don't add forall a. to test's type signature you're not really using scoped type vars, afaik
21:41:35 <Svrog> oh
21:41:37 <Saizan_> so the two 'a's are different
21:42:13 <Svrog> so i did misunderstand how scoped type vars work then
21:42:29 <Svrog> gonna try adding forall
21:43:29 <SamB_XP> mauke: what's with the inverted pentagram and those little heart symbols ?
21:44:20 <Svrog> yay, it works
21:44:20 <FunctorSalad_> ♥
21:44:22 <Svrog> thanks :)
21:46:53 <FunctorSalad_> ⬠
21:47:00 <FunctorSalad_> (not quite, but...)
23:17:25 <ivanm> is it just me, or are SPJ's papers currently unavailable?
23:25:24 <Alpounet> ivanm, they are, here
23:25:28 <Alpounet> (avaiable)
23:25:35 <Alpounet> available*
23:26:16 <ivanm> well, I'm after this one: http://research.microsoft.com/~simonpj/papers/giving-a-talk/giving-a-talk.htm
23:27:03 <ivanm> both firefox and opera just "hang" (they don't freeze, but that tab doens't do anything) on it :s
23:27:47 <Twey> WFM.
23:29:57 <ivanm> weird :s
23:29:58 <Alpounet> ivanm, you can't see this HTML page ? It works here too.
23:31:07 <ivanm> hmmm, wget can get it...
23:31:17 <ivanm> firefox and opera, however, refuse to :s
23:31:57 <Alpounet> I had the same problem... then I moved in a new flat, and don't have it anymore.
23:31:58 <Twey> I used Firefox
23:32:00 <Twey> It was fine
23:32:35 <Alpounet> -- I didn't move in a new flat to have SPJ's papers, of course...
23:34:02 <ivanm> heh
23:35:53 <sereven> ivanm: this sounds familiar from a year or so ago, iirc it was actually some plugin misconfiguration here.
23:35:59 <sereven> flash maybe?
23:36:03 <ivanm> could be
23:36:35 <sereven> "this site best view with w3m" ?
23:36:40 <ivanm> heh
23:40:06 <codm> Is there any way to have a type synonym for a polymorphic function without rank2types?
23:40:28 <codm> I want to say something like:
23:40:28 <codm> type Foo = Int -> a -> [a]
23:40:28 <codm> foo :: Foo
23:40:53 <ivanm> type Foo a = Int -> a -> [a]
23:40:55 <ivanm> foo :: Foo a
23:41:09 <ivanm> AFAIK, that's the only way to do it
23:41:17 <ivanm> unless you use a forall, but not sure if type likes that
23:41:44 <codm> bummer, because I didn't want to have to specify the a.
23:45:47 <codm> Hmm... wonder how Control.Exception does it
23:50:45 <Alpounet> @index <$>
23:50:45 <lambdabot> bzzt
23:50:48 <Alpounet> @index (<$>)
23:50:48 <lambdabot> bzzt
23:50:54 <ivanm> @hoogle (<$>)
23:50:54 <Alpounet> @hoogle <$>
23:50:54 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:50:55 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:50:57 <ivanm> heh
23:51:03 <ivanm> Alpounet: hoogle works better than index usually
23:51:11 <Alpounet> heh, okay :-)
23:53:27 <data_jepp> How do I check what a string starts with?
23:53:39 <dibblego> @type isPrefixOf
23:53:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
23:53:44 <ivanm> data_jepp: in what way?
23:54:20 <data_jepp> Im writing a parser that takes in a string, and the first element decides what type of expression it is.
23:54:57 <ivanm> data_jepp: you're using parsec or something?
23:54:59 <data_jepp> *,-'+ and so on
23:55:04 <data_jepp> No, not allowed. :p
23:55:13 <ivanm> @type head
23:55:15 <lambdabot> forall a. [a] -> a
23:55:17 <ivanm> or pattern match
23:56:29 <data_jepp> An example goes like this: parseExpr('l','e','t',:x:,'b','e'::s) but I can't get that to work.
23:57:14 <ivanm> maybe because that doesn't make sense?
23:57:19 <ivanm> e.g. what does :x: mean?
23:57:37 <data_jepp> Don't know, its a suggestion in the text for the task :p
23:57:46 <ivanm> parseExp ('*':exp) = ...; parseExp ('+':exp) ...; etc.
23:58:28 <Gracenotes> not so suitable for non-regular grammars
23:58:32 <data_jepp> But I also need to extract the value from the x.
23:58:58 <data_jepp> Or X itslef, X is Variable named with one char. :p
