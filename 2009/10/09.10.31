00:01:17 <sohum> ...ok, I missed a lot
00:01:54 <sohum> _Ray_: I coded up a quick'n'dirty implementation of calculating cycle lengths here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11359#a11359
00:02:09 <jre2> anyone know if there are known issues with recent versions of ghci and gnome-terminal?
00:02:16 <upsh9401> Hey if you want to apply a function to the left side of an Either, is there a function to do that?
00:02:30 <sohum> upsh9401: only to the left?
00:02:41 * _Ray_ still needs a lot of training to be able to read that xD
00:02:42 <upsh9401> sohum: yes
00:02:51 <dmwit> :t left
00:02:52 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
00:03:20 <dmwit> > map (left succ) [Left 42, Right "hey"]
00:03:21 <lambdabot>   [Left 43,Right "hey"]
00:03:29 <Jafet> Bob Floyd feels sad.
00:03:59 <sohum> _Ray_: why? I'm not using anything especially complicated.
00:04:03 <_Ray_> sohum, I think I see what it does. It goes building the list and searching in it (passing it along as a buffer?)
00:04:07 <Cale> oh, hmm
00:04:10 <Cale> that's not good...
00:04:25 <sohum> pretty much. It's a tad hackish in that is assumes the top of the list is always the recent value, but yeah.
00:04:26 <dmwit> How can I ask haddock not to build documentation for modules that aren't being exported?
00:04:28 <_Ray_> sohum, we haven't seen anything like cases, Maybes or lookup. But I get the idea, I think.
00:04:40 <Cale> It's not obvious that there is such a point, we need a better bound :P
00:05:23 <Cale> ah, hmm
00:05:26 <mtnviewmark> a problem with such algorithms is that if the function has a long "head" before it cycles, this can consume memory and lookup time
00:05:38 <mtnviewmark> there is a fix for this if you are willing to
00:05:45 <mtnviewmark> compute more:
00:05:48 <sohum> yus. but I'm not sure how you can fix that without knowing more about f.
00:05:53 <sohum> oh, right
00:05:55 <Jafet> Ahem
00:05:55 <mtnviewmark> after every two steps, delete the oldest
00:05:56 <_Ray_> Fix as in the function fix?
00:05:58 <sohum> trading space for time and vice versa
00:06:02 <Jafet> I *said*, Bob Floyd feels sad.
00:06:21 <mtnviewmark> always works - because once it cycles, you can compute the cycle lenght from ANYWHERE in the cycle
00:07:01 * ivanm just remembered HCAR is due soon...
00:07:04 <ivanm> anyone know when?
00:07:26 <mtnviewmark> you can even reduce the required memory to never more than the cycle length
00:08:07 <sohum> makes sense, mtnviewmark
00:08:19 <kmc> @pl \(x,y) -> (y,x)
00:08:20 <lambdabot> uncurry (flip (,))
00:08:33 <sohum> ahahah
00:08:37 <sohum> that's awesome
00:09:08 <sohum> /declarative/! you're flipping tupled elements, so it makes sense that flip should be in the expression
00:09:31 <mtnviewmark> if you only need to know a multiple of the cycle length -- you can reduce it down to only ever needing to keep two values!
00:09:54 <sohum> mtnviewmark: ok, /now/ you're insane ;)
00:10:17 <ivanm> @ask Axman6 I'm guessing you're happy about ChilliX's latest news? ;-)
00:10:17 <lambdabot> Consider it noted.
00:10:42 <mtnviewmark> ;-O
00:10:55 <mtnviewmark> sometimes you just need to konw if the cycle is prime...
00:11:15 <mtnviewmark> okay - I made that up - I have no idea when you'd need to know just that....
00:11:22 * sohum snerk
00:12:09 <sohum> but wait a sec. if all you know is a multiple of the cycle length, how does that tell you if the cycle length is prime?
00:12:39 <Axman6> ivanm: which is?
00:12:39 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
00:12:58 <mtnviewmark> d'oh
00:12:59 <mtnviewmark> right
00:13:04 <mtnviewmark> never mind - I said I made that up
00:13:08 <Axman6> ivanm!
00:13:09 <Axman6> :P
00:13:11 * sohum grin
00:13:11 <Cale> [(0,5),(2,4),(3,2),(4,3),(5,7),(6,1),(10,6),(12,0),(39,8),(267,9),(678,10),(688,11),(29999,12)...
00:13:47 <Cale> Those are the number of iterations taken to reach 12, 36, or 48 along with the smallest values which took that number of iterations
00:14:05 <Cale> So 29999 is the smallest values which took 12 iterations to reach its cycle
00:14:09 <Cale> value*
00:14:37 <Cale> (and, incidentally, it landed on 12)
00:15:43 <dmwit> The documentation for "cabal haddock" claims that it only builds documentation for exposed modules, but that doesn't seem true... =(
00:19:41 <kmc> @hoogle FileHandle -> Word8 -> IO ()
00:19:41 <lambdabot> Did you mean: Handle -> Word8 -> IO () /count=20
00:19:41 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
00:19:41 <lambdabot> Foreign.Storable pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
00:19:47 <Twey> :t curry
00:19:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
00:19:49 <kmc> @hoogle Handle -> Word8 -> IO ()
00:19:49 <lambdabot> System.IO hPrint :: Show a => Handle -> a -> IO ()
00:19:50 <lambdabot> Network.BufferType buf_hPut :: BufferOp a -> Handle -> a -> IO ()
00:19:50 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
00:21:30 <ivanm> Axman6: he's found the ghci bug on SL
00:21:43 <Axman6> yeah, just saw it
00:23:24 <jre2> anyone know if ubuntu's ghc binary doesnt have proper libedit support?
00:23:35 <Cale> Hmm, is there a value larger than 999999 for which f n > n?
00:23:54 <twb> Hmm, does ghc6 require twice as much memory to compile on amd64 (vs. arm)?
00:24:00 <Elly> Cale: for certain values of f
00:24:13 <Cale> Elly: f is twice the product of the digits
00:24:16 <twb> My arm box has 512MB, and it compiles fine, but when I lower my amd64 VM's RAM cap to 512MB, I get complaints:
00:24:21 <Elly> oh, I see
00:24:22 <twb> Linking /var/tmp/darcs-23848/setup/setup ...  /usr/lib/ghc-6.10.4/Cabal-1.6.0.3/libHSCabal-1.6.0.3.a: could not read symbols: Memory exhausted
00:25:23 <Elly> Cale: I don't think so...
00:25:52 <Elly> Cale: the largest 7-digit product posssible is 4782969, which does not rule it out, I guess
00:25:52 <Cale> Yeah, neither do I
00:26:58 <Elly> there are certainly no numbers of 22 or more digits for which it is true
00:28:05 <tommd> twb: Your playing with GHC on arm?
00:28:24 <tommd> twb: Is there anywhere for me to follow your progress (a blog or some such)?
00:28:29 <Elly> Cale: I can't find a value for 7 digits
00:28:40 <twb> tommd: not so much playing as having it working normally
00:28:41 <Elly> admittedly I have not done a brute-force search
00:28:52 <twb> tommd: I just installed Debian as normal, and apt-get installed ghc6.
00:28:54 <tommd> twb: How did you get it to "work normally"
00:28:55 <Elly> it seems relatively obvious that the 'optimal cases' are n99999...
00:29:14 <tommd> Oh, the debian port - it doesn't have TCO, right?  Just an unregistered build?
00:29:37 <twb> I'm told ghc is unregistered on arm.
00:30:00 <tommd> Yeah, thats the only version I've seen.  There is no official ARM port from the GHC team that I've heard of.
00:30:15 <twb> tommd: the reason I'm investigating arm is because it doesn't support -threaded, so I must extend the Darcs project to support cabal configure -f-threaded
00:30:47 <Elly> you are solving, basically, for a * b * c * d * e * f * g * 2 >= (a * 10^6) + (b * 10^5) + (c * 10^4) + (d * 10^3) + (e * 10^2) + (f * 10^1) + g
00:31:02 <Elly> which, well, 0330 is too late to solve equations in 7 variables :P
00:31:12 <tommd> No threaded rts on ARM?  It makes sense, but I thought the single threaded RTS was going away some day.
00:31:27 <tommd> err 'single thread' as in, non-threaded.
00:31:53 <Cale> Elly: Really, I just want to get a reasonable bound on the values on which f increases so as to prove that iterates of f eventually land on 12, 36, or 48 :)
00:32:13 <Elly> ah
00:32:14 <Cale> Elly: This was because of a problem that _Ray_ had involving this function and determining cycles :)
00:32:33 * tommd sleeps
00:32:36 <Cale> It certainly seems true.
00:32:39 <Jafet> You could check only k-digit numbers with over k prime factors.
00:32:45 <Jafet> s/over/at least/
00:32:51 <Jafet> Wait, no
00:33:50 <Cale> Elly: How'd you get the bound of 22? I can see a bound of 28 digits...
00:34:20 <Elly> oh, wait, I am a noob
00:34:27 <Elly> I did not multiply the 2 into that test
00:34:44 <Elly> yeah, it is 28
00:34:54 <Cale> Okay, good :)
00:34:59 <Elly> that's not a very reasonable reasonable bound though
00:35:03 <Cale> yes
00:36:00 <Elly> are you trying to show that iterated applications of f always reach a cycle containing 12, 36, or 48?
00:36:12 <Cale> Elly: yep
00:36:23 <Elly> hm...
00:37:03 <Elly> okay, I see the cycles
00:37:45 <Elly> well, there is also the cycle at 0
00:37:59 <Cale> right
00:39:08 <Elly> well, you know what they say
00:39:15 <Elly> when stuck, attempt proof by contradiction
00:39:52 <Cale> I wonder how long testing every value up to 10^29 - 1 will take.
00:40:15 <Elly> if you never reach 12, 36, or 48, then you never reached any set of digits multiplying to 6, 18, or 24, which means you never reached any set multiplying to 3, 9, or 12
00:40:42 <Elly> unfortunately many of those are notoriously not divisible by 2, so
00:41:52 <Elly> it seems that it reduces to "the product of your digits is never divisible by 3"
00:41:59 <Elly> right? oO
00:42:16 <Cale> hmm
00:42:53 * Elly is out of computrons and must sleep
00:42:54 <Cale> yeah
00:42:59 <Cale> something like this :)
00:43:03 <Elly> waking up in 4.5 hours to catch a plane -_-
00:56:00 <upsh9401> is there a function that aplies a function to the left value of an Either?
00:56:41 <Beelsebob> @hoogle (a -> c) -> Either a b -> Either c b
00:56:41 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
00:56:41 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
00:56:41 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
00:56:44 <Twey> There's a fmap, isn't there?
00:56:51 <c_wraith> fmap is for Right
00:56:52 <ivanm> Twey: fmap is on Right
00:56:55 <ivanm> heh
00:56:57 <Twey> Oh, right, on the Left
00:56:59 <dmwit> :t left
00:57:00 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
00:57:09 <dmwit> (I answered this way last time he asked, too.)
00:57:13 <Twey> There we are
00:57:14 <Twey> Heh
00:57:20 <aeron> is Data.Map constant time insertion/lookups?
00:57:28 <aeron> or linear?
00:57:32 <dmwit> log
00:57:32 <idnar> :t left (+5)
00:57:33 <lambdabot> forall b d. (Num b) => Either b d -> Either b d
00:57:36 <Twey> Noblest of what?  :þ
00:57:40 <Beelsebob> aeron: no
00:57:42 <Beelsebob> O(log(n))
00:57:46 <idnar> :t left (?f :: a -> b)
00:57:47 <lambdabot>     Could not deduce (?f::a -> b) from the context ()
00:57:47 <lambdabot>       arising from a use of implicit parameter `?f'
00:57:47 <lambdabot>                    at <interactive>:1:6-7
00:57:55 <aeron> Anyway way to get a constant time loopup like a hash table?
00:58:07 <idnar> :t left (?f `asTypeOf` (undefined :: a -> b))
00:58:07 <Beelsebob> note that it doesn’t know how many elements you want to put in – that makes constant time impossible
00:58:08 <lambdabot> forall a b d. (?f::a -> b) => Either a d -> Either b d
00:58:08 <dmwit> Array, STArray
00:58:13 <Beelsebob> no, it’s sublinear
00:58:16 <Beelsebob> it’s O(log(n))
00:58:25 <Twey> Faster than linear
00:58:26 <dmwit> Otherwise, gotta go into IO, and HashTable hasn't had any love in years.
00:58:29 <aeron> no i mean, are there alternative structures that are built in
00:58:34 <aeron> dmwit: ah, thanks
00:58:55 <idnar> O(1) is a lie anyway
00:59:02 <dmwit> O(1) is a small lie
00:59:15 <aeron> well sure
00:59:16 <c_wraith> everything's O(heat death of the universe)
00:59:18 <aeron> amortized constant time
00:59:25 <Twey> I just can't stand the constant lies!
00:59:32 <jystic> haha
00:59:52 <aeron> and yeah I understand that, practically speaking, log n will be < 100 for even absurdly large data sets
00:59:55 <dmwit> I think idnar is going for the "address lookup is O(log n) time in n the size of the address" argument.  Which is a pretty small lie, indeed, in my opinion.
01:00:12 <aeron> ah gotcha
01:00:13 <idnar> Twey: haha
01:00:26 <idnar> yeah, that's basically what I was referencing
01:00:31 <Jafet> Big O isn't a lie, it's a statistic.
01:00:45 <Twey> A damn one?
01:00:46 <dmwit> ?remember Twey <idnar> O(1) is a lie anyway <Twey> I just can't stand the constant lies!
01:00:46 <lambdabot> Done.
01:00:48 <aeron> not a statistic lol
01:00:49 <aeron> :P
01:00:53 <shambler> Twey, heh
01:01:15 <Twey> dmwit: Oh no
01:01:27 <Twey> I've been remember'd for a really crappy pun :þ
01:01:56 <dmwit> It could be worse.  You could've said something trite about stereo...
01:02:01 <dmwit> ;-)
01:02:13 <jystic> every time I do ":make" in vim on a .hs file that uses Gtk it locks up for 10-20 seconds, has anyone else seen this / have a solution?
01:02:33 <Twey> dmwit: Hahaha
01:02:38 <dmwit> jystic: :set makeprg?
01:03:03 <jystic> makeprg=ghc -e :q %
01:03:12 <Twey> :wq\nemacs -nw
01:03:13 * Twey hides.
01:03:55 <dmwit> Wait, really?
01:03:58 <dmwit> That's a really strange makeprg.
01:04:02 * dmwit checks the GHC documentation
01:04:39 <jystic> Twey: emacs: command not found :)
01:05:52 <jystic> dmwit: what should it be instead?
01:06:07 <dmwit> jystic: I don't know, it's just odd.
01:06:11 <jystic> dmwit: or perhaps a better question, what is not a strange makeprg
01:06:30 <dmwit> That will try to execute ":q" as a Haskell expression with the current file imported.
01:06:39 <dmwit> I have a hard time believing that does what you want. =P
01:06:45 <dmwit> perhaps
01:06:49 <jystic> i'm using the haskellmode for vim stuff
01:06:50 <dmwit> makeprg=ghc --make %
01:06:51 <dmwit> ?
01:08:12 <dmwit> Oh, I get it.
01:08:27 <dmwit> It's not evaluated as a Haskell expression, it's run through the ghci-expression-mode.
01:08:59 <dmwit> So, okay, "ghc -e :q %" is actually somewhat sane; it just makes sure that the current file compiles without actually leaving behind the compiled object file. =P
01:09:17 <dmwit> The lockup, then, is most likely due to recompiling your entire project each time.
01:09:42 <jystic> hmm, it happens even on very small files though
01:09:46 <dmwit> So, yeah, something a little smarter (like "ghc -c %" or so) seems like a good idea.
01:09:55 <jystic> ok will try
01:10:04 <dmwit> jystic: Hm, small files that don't import bigger files?
01:10:21 <jystic> dmwit: well, anything that uses Gtk2hs
01:10:39 <dmwit> Well, try running the compiler from the command-line.
01:10:45 <dmwit> Does it take as long as the lock-up you're observing?
01:10:54 <dmwit> If so, mystery solved... =P
01:11:06 <jystic> nope, ghc --make is almost instant
01:11:31 <dmwit> What about the literal line that :make would run?
01:11:38 <dmwit> i.e. ghc -e :q Foo.hs
01:12:09 <jystic> hmm, that's fast as well
01:12:12 <dmwit> As a subsidiary question, you don't happen to be sitting in the Gtk2Hs source directory, do you?
01:12:18 <dmwit> huh
01:12:38 <jystic> nope i'm just in a directory with test.hs which contains
01:12:49 <jystic> import Graphics.UI.Gtk
01:12:51 <dmwit> Well: I haven't seen that or know a solution, to answer your original question. =P
01:12:56 <jystic> main = do
01:13:01 <jystic> initGUI
01:13:06 <jystic> mainGUI
01:13:29 <jystic> thanks for the help anyhow =P
01:15:41 <jystic> it must be doing something crazy, it maxes out one of my CPUs for the entire time
01:16:15 <dmwit> Maybe you could try :set makeprg="ghc -e :q -v %" and see if it says anything interesting...
01:16:45 <jystic> i was just going to ask if there was a way to get more info
01:17:50 <kmc> anyone willing to help me with some multicore performance tweaking?
01:19:53 <jystic> dmwit: hmm didn't show me anything extra
01:20:50 <dmwit> You on Windows?
01:20:57 <jystic> Ubuntu
01:21:54 <gio123> .by domain means?
01:21:58 <gio123> which country
01:21:59 <gio123> ?
01:22:23 <ivanm> belorus I think
01:22:34 <ivanm> *belarus
01:22:42 <dmwit> jystic: odd
01:22:47 <dmwit> jystic: :set shellpipe?
01:23:00 <gio123> where is  y ?
01:23:01 <gio123> :)
01:23:04 <jystic> shellpipe=2>
01:24:02 <dmwit> jystic:
01:24:04 <dmwit> err
01:24:13 <dmwit> :set shellpipe="2>&1| tee"
01:24:15 <dmwit> and try again
01:25:10 <jystic> should i try with my defauly makeprg or the -v one?
01:25:15 <jystic> default*
01:25:29 * dmwit shrugs
01:25:35 <jystic> ok will try both
01:25:37 <dmwit> Chef's choice. =)
01:27:13 <jystic> still locks up, but this time i get an error saying can't open file /tmp/v347189/5
01:27:36 <jystic> (numbers are just random, didn't quite catch the exact ones)
01:27:48 <Twey> Sounds like a vim problem…
01:28:24 <Twey> To guess, it saves some sort of temporary data in a tmpfile, but it's having problems opening it this time for some reason or other
01:28:31 <dmwit> jystic: Have you got write permissions in /tmp or is /tmp full?
01:29:09 <dmwit> (Also, you can check exactly which file it's trying to grab with :set makeef? and knowing that ## will be replaced by a random number.)
01:29:52 <jystic> yeah it looks like everyone has permissions to write to /tmp
01:30:07 <jystic> the disk is definitely not full
01:30:35 <jystic> makeef=
01:31:12 <jystic> i only got that can't open file error when i changed the shellpipe
01:32:04 <jystic> it's interesting, :make completes basically straight away with the "Press ENTER or type comm..."
01:32:20 <jystic> it's only after I hit enter that it locks up and uses 100% cpu for 10s
01:33:19 <dmwit> Well, you can check out :help :make.
01:33:28 <dmwit> It has very detailed information on the order that things are done.
01:33:33 <dmwit> So maybe you can spot what stage it's in.
01:33:48 <dmwit> Otherwise, I'd say this is a case for #vim.
01:34:10 <jystic> ok cool, thanks for the help!
01:40:48 <jystic> that's really weird, an empty file ":make" works file, as soon as I add "import Graphics.UI.Gtk" it does the locking up thing
01:42:01 <dmwit> Hey, I figured out how to get haddock not to make docs for a module!  \o/
01:55:22 <mauke> curse you, hackage
02:08:06 <ivanm> mauke: why?
02:08:17 <mauke> no uploads :-(
02:08:22 <ivanm> :o why not?
02:08:26 <ivanm> maintenance or something?
02:09:17 <mauke> maybe everyone's just busy not uploading packages :-/
02:09:31 <ivanm> heh
02:09:47 <ivanm> mauke: how are you uploading them? from the web page or cabal-install?
02:10:02 <mauke> me?
02:10:12 <mauke> I'm not
02:10:25 <Twey> dmwit: How do you get it to *make* docs for a module?  o.@  I usually just do find . -iname '*.hs' -or -iname '*.lhs' | xargs haddock
02:10:26 <ivanm> oh, you're annoyed at the lack of new packages?
02:10:40 <mauke> yes, I want to test my hackagebot patches
02:10:55 <dmwit> Twey: Um, "cabal haddock" did the trick for me.
02:11:04 <Twey> Oh, huh.
02:11:11 <ivanm> heh
02:11:18 <ivanm> well, that needs a .cabal file as well...
02:11:25 <dmwit> Well, yeah.
02:11:35 <Twey> Should have one anyway, though :þ
02:11:45 <dmwit> But you can't really get cabal to do much of anything without one of those. =P
02:12:04 <Twey> Hehe
02:12:15 <ivanm> would anyone know why my browsers can't access microsoft research pages, but wget can? :s
02:12:28 <dibblego> I get that
02:12:32 <mauke> proxy settings? user agent?
02:12:50 <ivanm> dibblego: so maybe an aussie thing?
02:13:10 <dibblego> ivanm, I don't know -- it's truly puzzling, noticed it a long time ago, any request to research.microsoft.com times out
02:13:12 <ivanm> proxy settings for me are auto-detected...
02:13:20 <ivanm> dibblego: exactly
02:13:24 <dibblego> (I'm with TPG)
02:13:36 <ivanm> dibblego: same...
02:13:39 <ivanm> might be them then :@
02:13:42 <dibblego> bet it's them
02:13:53 <ivanm> right, I've got to ring them up during the week anyway
02:14:01 <ivanm> so I might as well bug them about this as well
02:14:22 <ivanm> OK, disabling the proxy in firefox doesn't help...
02:14:42 <mauke> http://mauke.ath.cx/exe/as?html;http://research.microsoft.com/en-us/ :-)
02:15:15 <mauke> breaks all links and images, but the basic page loads just fine
02:15:28 <dmwit> 500 malformed request ?
02:15:34 <dibblego> ivanm, perhaps a post to whirlpool
02:15:43 <ivanm> dibblego: maybe...
02:16:15 <dmwit> Never mind, it was just my terminal being stupid.
02:16:17 * ivanm tries changing his user agent...
02:16:30 <ivanm> dmwit: I get that a lot with cabal-install when uploading to hackage
02:16:33 <mauke> if my link worked, it wasn't your user-agent
02:16:44 <ivanm> mauke: works
02:16:56 <ivanm> what does that link of yours do? copy-paste? :p
02:17:08 <dibblego> I've accessed research.microsoft.com from exactly the same user-agent but a different ISP
02:17:12 <ivanm> nope, changing the user agent does nothing
02:17:26 <dibblego> it's TPG, I'd almost put a house on it
02:17:41 <Twey> Does wget work for you?
02:17:44 <mauke> well, it gets the specified document and returns it with the specified content-type
02:17:54 <ivanm> Twey: yes
02:17:55 <mauke> and it uses your user-agent header
02:18:11 <Twey> What happens if you tweak your headers so they're identical to the ones wget sends?
02:18:47 <mauke> if you want to know what your browser sends: http://mauke.ath.cx/exe/headers
02:18:48 <Twey> (with e.g. netcat to sniff the wget headers and the Modify Headers extension to Firefox)
02:18:58 <Twey> Oh, that'll work too
02:20:15 <ivanm> mauke: heh, wget has almost no headers...
02:21:08 <mauke> oh, someone using GET(1)?
02:21:40 * integral points at integral
02:21:43 <jystic> dmwit: #vim was no help whatsoever :) i can see why people come to #haskell with general programming questions. Things are looking up though, i've narrowed it down the the ghc.vim compiler file that comes with haskellmode for vim
02:22:45 <ivanm> Axman6: you still around?
02:23:04 <Twey> GET(1)?
02:23:08 <Twey> What's that?
02:23:24 <ivanm> dibblego: w3m works... >_>
02:23:44 <mauke> http://search.cpan.org/~gaas/libwww-perl-5.833/bin/lwp-request
02:23:50 <idnar> GET(1) is LWP::WWW or whatever it's called
02:23:56 <dibblego> I've tried firefox and konqueror in the past
02:24:02 <Twey> ivanm: What happened when you used your normal browser with wget headers?
02:24:12 <ivanm> Twey: no idea how to try that...
02:24:21 <Twey> mauke: Why is it called GET(1)?
02:24:34 <Twey> ivanm: 09:18:11 < Twey> What happens if you tweak your headers so they're identical to the ones wget sends?
02:24:37 <Twey> 09:18:47 < Twey> (with e.g. netcat to sniff the wget headers and the Modify Headers extension to Firefox)
02:24:50 <mauke> Twey: uh, it's called GET because it sends a GET http request
02:24:52 <Twey> ivanm: It was in response to that that mauke posted his header-display script
02:24:55 <ivanm> oh, missed the mention of the extension
02:25:07 <dibblego> konqueror can get the fron page and the redirected page, but after that it hangs -- firefox hangs on any request
02:25:10 <Twey> mauke: Right… what's the (1)?
02:25:14 <int-e> (1) is a manpage category.
02:25:15 <ivanm> *sigh* I have so many tabs open it will take forever to restart firefox with a new extension...
02:25:17 <Twey> Oh!
02:25:18 <mauke> Twey: section 1, command line programs
02:25:19 <Twey> Right
02:25:20 <Twey> Haha
02:25:42 <Twey> I was thinking it was some strange new HTTP request type that I'd never heard of.
02:25:55 <Twey> GET(1) /foo/bar HTTP/1.5
02:26:31 <dmwit> HELO(42)
02:26:38 <ivanm> dibblego: http://forums.whirlpool.net.au/forum-replies.cfm?t=1311734#bottom
02:26:39 <Twey> Heh
02:27:00 <ivanm> dibblego: someone said they can access the site with Internode, so it definitely isn't an Australian thing
02:27:20 <dibblego> ivanm, definitely not -- I've asked others to get me stuff from research.microsoft.com for the last 2 years
02:27:43 * ivanm hates TPG more and more each day
02:27:59 <ivanm> cheapest VoIP rates /= best ISP
02:28:15 <dibblego> same; if you send them an email they'll send you back a canned response, "have you checked your Internet Explorer settings?" or some crap like that
02:29:06 <ClaudiusMaximus> cabal question - i've never cabalized anything so far, but wondering how difficult it would be during the build to compile a 'temporary' program that generates some data files for use by the 'real' program (only the data and the real program would need to be installed)
02:29:27 <dmwit> Setup.lhs is a Haskell program.
02:29:34 <dmwit> You can do anything Haskell can!
02:31:18 <Twey> @faq Can Haskell do everything?
02:31:19 <lambdabot> The answer is: Yes! Haskell can do that.
02:44:11 <jre2> @pf f arg1 = g arg2 arg1
02:44:11 <lambdabot> Maybe you meant: bf pl
02:46:40 <jre2> @pl f a = g b a
02:46:40 <lambdabot> f = g b
02:46:45 <ivanm> dibblego: I get the impression that you're a tad irritated from your repetition of your final query...
02:46:47 <jre2> @pl f a = g b (h a)
02:46:47 <lambdabot> f = g b . h
02:46:50 <ivanm> ;-)
02:47:03 <dibblego> I just know they'll tell me to make sure my computer is turned on
02:50:48 <jre2> @pl p subpath = find xml (printf "/base/path" subpath)
02:50:48 <lambdabot> p = find xml . printf "/base/path"
02:54:59 <ivanm> dibblego: heh
02:55:23 <ivanm> dibblego: though really, "Microsludge" is a bit unprofessional...
02:55:34 <ivanm> (not that the TPG tech support people are professionals...)
02:55:39 <ivanm> Cale: you around?
02:55:44 <dibblego> I'm well passed that
02:56:11 <ivanm> heh
02:56:29 <ivanm> dibblego: on the cv on your website, you may wish to make the WM stuff past tense...
02:56:32 <ivanm> ;-)
02:56:54 <ivanm> wow, you actually lectured/tutored on COBOL? wtf was griffith doing teaching that still?
02:56:55 <dibblego> prolly
02:57:07 <dibblego> yes that was a one-off course they ran
02:57:21 <ivanm> ahhhh
02:57:24 <ivanm> about to say...
02:59:04 <Cale> ivanm: hi
02:59:28 <ivanm> Cale: did lambdabot pass my message on?
02:59:32 <Cale> hmm
03:00:03 <ivanm> she seems to have died since I did the @tell, not sure if you got it before or after she did so...
03:00:13 <Cale> ah, probably not :P
03:00:32 <Cale> (I just checked my messages and it had it)
03:00:40 <ivanm> heh
03:00:41 <ivanm> Cale: OK, I was wondering if you'd be going to POPL in Madrid in January
03:00:53 <Cale> Unless Madrid moves to someplace in southern Ontario...
03:00:59 <ivanm> heh
03:01:04 <ivanm> OK, nm then
03:04:36 <mandy_> whats a good book on lambda calculus
03:04:44 <Athas> Does GHC still use the Evil Mangler?
03:05:50 <Athas> mandy_: The Lambda Calculus: Its Syntax and Semantics, by Barendregt.
03:06:12 <Athas> It kind of has everything, but is very... rigorous, shall we say.
03:06:26 <Athas> Both expensive and expansive.
03:06:44 <ivanm> Athas: AFAIK, it does if you have -fvia-c
03:07:41 <mandy_> ok
03:08:37 <Athas> mandy_: if all you want is to learn enough lambda calculus to be conversant in a programming language context, you don't really need to read a book.
03:09:07 <twb> Athas: for that, Wikipedia's lambda calculus article is excellent
03:09:33 <mandy_> ok i'll start from that
03:09:49 <twb> From there it's a small step to the *typed* calculi, which in my case I already had a rough familiarity with thanks to exposure to HM inference
03:24:07 <ivanm> copumpkin: http://i.imgur.com/bQtWk.jpg
03:25:58 <twb> Don't you .usians have work to do?
03:26:10 <twb> Daft bloody holy days.
03:26:18 <ivanm> twb: hmmm?
03:26:30 <twb> ivanm: all hallow's
03:26:33 <ivanm> it's saturday night...
03:26:48 <ivanm> and I follow the Julian calendar...
03:26:49 <ivanm> ;-)
03:35:00 <bauchus> hi. I'd like to use the Network.CGI with a ReaderT monad. i guess the type of my function will be generatePage :: CGIT (ReaderT r IO) CGIResult. The problem is, that I also use Network.SCGI, which only has runSCGIConcurrent :: ... -> CGIT IO CGIResult -> ... Isn't this to restrictive? Maybe I'm just confused...
03:39:37 <mpwd> How many categories, up to isomorphism, are there with 4 objects and 8 morphisms?
03:40:13 <mpwd> Or better yet, is there a good resource to look at to learn how to answer this sort of problem?
03:40:59 <thp> I'm trying to eliminate duplicate elements from a list. My initial thought was to convert the list to a Data.Set and then convert it back to a list. Is there a better way?
03:41:29 <c_wraith> :t nub
03:41:30 <lambdabot> forall a. (Eq a) => [a] -> [a]
03:41:38 <Vanadium> > nub [1, 2, 1]
03:41:39 <lambdabot>   [1,2]
03:41:42 <Vanadium> :O!
03:41:58 <CalJohn> @src nub
03:41:58 <lambdabot> nub = nubBy (==)
03:42:09 <CalJohn> @src nubBy
03:42:09 <lambdabot> nubBy eq []             =  []
03:42:09 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
03:42:12 <dmwit> thp: Define better.
03:42:41 <dmwit> nub works on (slightly) more types, but is slower; is that better or worse?
03:43:14 <thp> dmwit: better for my case, I guess :)
03:44:12 <thp> thanks for the hint :)
03:45:34 <dmwit> instance (Bounded k, Enum k, Ord k, Ord v) => Show (k -> v) -- ooooh yeah
03:47:57 <dmwit> I guess I don't actually need the (Ord k) constraint there.
03:48:08 * dmwit adds a TODO to his code
03:48:52 <Vanadium> dmwit: What are you doing there?
03:49:20 <dmwit> Vanadium: I'm doing weird, dirty things.  But between two consenting adults... ;-)
03:49:24 <jre2> @pl find1 a b = g (find a b)
03:49:24 <lambdabot> find1 = (g .) . find
03:50:40 <dmwit> Vanadium: It's just that a function is the right type to put in this data structure, but I'm really reluctant to lose Read and Show instances, because it makes ghci useless.
03:50:53 <dmwit> So... dirty things. =)
03:51:00 <Vanadium> Hah
04:00:09 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11367#a11367 I don't understand this bizzare error
04:00:30 <mreh> is it alot to do with ST monad, because I am a n00b
04:02:10 <int-e> mreh: use runST (uniformDist 10 (1,10) =<< randomNumberGen seeds) rather than runST $ ...
04:02:42 <mreh> is that because $ does something with the context? Somebody told me that but I didn't understand him
04:03:10 <jre2> why isn't Text.Read.readEither exported?
04:06:05 <mreh> jre2: is that a general question?
04:06:24 <jre2> I'm curious if there's reason not to
04:06:50 <mreh> so you weren't asking me?
04:07:01 <jre2> no, just in general
04:07:13 <jre2> read is dangerous since it uses "error"
04:09:06 <jre2> read is even implemented via the safe readEither
04:09:55 <ReDAeR> Either?...just give me a nullPointerException please
04:10:15 <ReDAeR> I'm suprised how easy it is to implement a binary search tree o.o
04:10:18 <ReDAeR> 2 lines..
04:11:27 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11367#a11367: I still haven't gotten to the bottom of this error
04:11:41 <mreh> any help would be greatly appreciated
04:12:31 <int-e> mreh: oh. You're passing in a  Gen s  to kMeansCluster, then using it inside a different ST calculation. That won't work.
04:12:55 <mreh> It has to stay in an ST calculation?
04:13:27 <mreh> inside it's own ST calculation?
04:13:55 <int-e> mreh: you can either pass a (forall s. ST s (Gen s)) action, or you'll have to change the return value to ST s [[Vector a]], i.e. make kMeansCluster an ST action.
04:14:14 <int-e> mreh: yes. that's the whole point of that prevalent s type argument.
04:15:00 <mreh> hmm, i'm not so sure about this one
04:15:59 <mreh> i think I need to learn ST monad
04:32:35 <Peaker> mreh, the ST monad is similar to the IO monad, except the only effect is destructively writing STVars/STArrays/etc.  There's also the "s" phantom type parameter that's meant to ensure that ST variables/arrays don't escape between ST computations
04:35:49 <mreh> Peaker: thank you, that's very helpful
04:35:59 <mreh> i thought there was something going on that I couldn't understand
04:37:29 <Peaker> mreh, and of course, ST s a -> a   exists, and since destructive writes are still deterministic, they don't violate referential transparency
04:38:00 <int-e> @type runST
04:38:01 <lambdabot> forall a. (forall s. ST s a) -> a
04:38:42 <int-e> (basically what that inner forall s means is that runST can invent its own fresh type to use for s)
04:40:49 <int-e> the abominally clever part is that runST never actually bothers to do that, and gets away with it because s is a phantom type - no values of type s are ever needed.
04:41:29 <monadic_kid> anyone managed to get hsc2hs from hackage built with ghc 6.10.4?
04:42:07 <Peaker> @type newSTVar
04:42:08 <lambdabot> Not in scope: `newSTVar'
04:42:13 <Peaker> @hoogle STRef
04:42:14 <lambdabot> module Data.STRef
04:42:14 <lambdabot> Data.STRef data STRef s a
04:42:14 <lambdabot> Data.STRef.Lazy data STRef s a
04:42:17 <Peaker> @type newSTRef
04:42:18 <lambdabot> forall a s. a -> ST s (STRef s a)
04:42:49 <int-e> all that matters to the type checker is that runST could do that. So if you have x :: STRef s0 (), and write runST (readSTRef x), then you have readSTRef x :: ST s0 () (the s0 is the same as in the STRef), but runST could use a fresh type for s, which is different from s0. Hence you get a type error.
04:43:35 <int-e> and it says pretty much that - s0 is a rigid type, and it doesn't match the type s that runST invented (bound).
04:44:05 <jre2> @pl find1 xml path = getUnique (find xml path)
04:44:05 <lambdabot> find1 = (getUnique .) . find
04:44:11 <mije> hello
04:44:28 <int-e> mreh: does that help?
04:44:31 <Peaker> When you have:  f :: a -> a ; f x = ...    if you use some concrete type for "x" ghc complains "not as polymorphic as expected".  But wouldn't it make sense to say that in the context of "f", that "x" is existentially quantified?
04:44:56 <mreh> i'm just on the phone, i'll read it in a sec ;)
04:45:15 <mije> i have hard times trying to install hdbc, the manual installation tells there is an inconsistency in the librairies (between convertible and time) and the cabal install fails as well
04:45:29 <mije> does anybody has a hint ?
04:46:31 <ksf> what happens if I call fork() via the ffi? does the rts explode?
04:47:12 <ivanm> ksf: either the RTS or _you_! :p
04:48:44 <int-e> Peaker: Uhm, that's a matter of perspective I guess - are you looking at f from outside or from inside? Obviously you're looking from inside, and yes, that will make a existentially qualified. But the distinction means that it would make the error message harder to understand, I think.
04:50:18 * ksf would opt for a faq regarding type errors.
04:50:38 <Peaker> int-e, we already have existential-quantification error messages.. I think "not as polymorphic as expected" is nice, maybe that error can be re-used in the exist. quant. errors too?
04:50:41 <ksf> i.e. what are common reasons for the less-obvious error messages.
04:50:58 <int-e> Peaker: but you only get the former with language extensions.
04:51:47 <int-e> Peaker: and you should have seen the discussion of why we use forall for declaring existential types if you use them.
04:52:17 <int-e> Peaker: which is based on the same inside/outside distinction that I just tried to explain.
04:52:27 <Peaker> I think it would be nice if ghc, when giving me "Occurs check: infinite type errors", did what I do manually: Set each component of the value to "undefined" to see which part is actually responsible
04:52:59 <Peaker> int-e, of course its an inside-outside distinction, or caller/callee, that's what exist. quantification is all about (at least IMHO)
05:17:06 <FunctorSalad> Peaker: the "not as polymorphic" one *is* if you use existentials wrong AIUI
05:17:31 <FunctorSalad> though sometimes it's "type variables escapes"
05:21:45 <Peaker> FunctorSalad, I don't think it is, I think the not-as-polymorphic is what you get when your function is inferred to be, say:  a -> Int   rather than  a -> a
05:21:55 <Peaker> well, perhaps not quite that, but similarly
05:26:18 <dolio> runST (newSTRef 0) gets "Inferred type is less polymorphic than expected. Quantified type variable `s' escapes"
05:27:21 <dolio> a -> a versus a -> Int gets a mismatch between a and Int.
05:30:18 <Peaker> I must have mis-remembered then, my bad
05:31:27 <dolio> It may have been different in the past.
05:33:32 <Peaker> What alternatives to monad composition are there besides monad transformers?
05:34:02 <dolio> Coproducts
05:34:20 <Peaker> how do these work? Can you use State and IO composition as an example?
05:34:44 <ivanm> @tell roconnor readColourName in Data.Colour.Names has a bug: the fail message refers to readColourNames (note the trailing s)
05:34:44 <lambdabot> Consider it noted.
05:35:23 <dolio> Although I don't think those actually allow you to build up monads like transformers.
05:36:03 <mreh> what's the alternative to using the (forall s. ST s a) syntax?
05:36:04 <dolio> They let you define computations that use effects from several monads, and then extract into a monad that supports all the effects.
05:36:12 <Peaker> dolio, I was wondering about distributivity of monads:  this seems impossible: IO (State (IO (State a))) -> IO (IO (State (State a))
05:36:44 <dolio> Yeah, I don't think State distributes like a distributive law.
05:37:56 <thp> How can I convert a "Maybe Int" to an "Int"? (I get the Maybe Int from Data.List.findIndex)
05:38:37 <Peaker> thp, its not possible in general, but you can get it as an Int argument to a function that only runs in the Just case, when there actually is an Int
05:39:05 <Peaker> thp, the functions maybe, fmap, and (>>=) will all give you the content of the Just of a Maybe (e.g: The Int in this case) to a function you give them
05:39:32 <Peaker> > maybe 0 (\haveAnIntNow -> haveAnIntNow + 1) (Just 5)
05:39:33 <lambdabot>   6
05:39:47 <Peaker> You could say "maybe" translated Maybe Int  to Int here, when it gave an Int to  haveAnIntNow
05:40:06 <thp> Peaker: thanks. will try that
05:40:12 <Peaker> also:
05:40:17 <Peaker> > fmap (+1) (Just 5)
05:40:18 <lambdabot>   Just 6
05:40:38 <Peaker> > (Just 5) >>= (\anInt -> Just (anInt + 1))
05:40:39 <lambdabot>   Just 6
05:41:25 <dolio> Peaker: If you look at, for instance, MaybeT m a = m (Maybe a), it's distributing the Maybe past the m.
05:41:46 <chaosape> could i use template haskell to programmatically creat fields in a record?
05:41:51 <dolio> Peaker: But StateT s m a = s -> m (s, a) only distributes half way, or something.
05:41:59 <Peaker> dolio, StateT distributes positive things beyond the m, but negative things outside
05:42:21 <dolio> Yeah.
05:42:35 <dolio> And ReaderT doesn't do any distributing, i guess.
05:43:00 <Peaker> @src ReaderT
05:43:01 <lambdabot> Source not found. There are some things that I just don't know.
05:43:07 <Peaker> @unmtl ReaderT IO a
05:43:07 <lambdabot> err: `ReaderT IO a' is not applied to enough arguments, giving `/\A. IO -> a A'
05:43:13 <Peaker> @unmtl ReaderT Int IO a
05:43:13 <lambdabot> Int -> IO a
05:43:18 <dolio> ReaderT r m a = Reader r (m a)
05:44:05 <Peaker> @unmtl ContT Int IO a
05:44:06 <lambdabot> (a -> IO Int) -> IO Int
05:44:52 <Peaker> here both negative and positive terms are put behind the "m"
03:47:52 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
03:47:52 --- topic: set by roconnor on [Thu Jul 30 11:33:44 2009]
03:47:52 --- names: list (clog_ en0th_ Heffalump carlocci monadic_kid tibbe gio123 lazni SureAin levitation[A] hiratara adlan_ iago MrFahrenheit jao paulvisschers_ hirbel akrohit Dessous mlesniak_ Taejo jaspervdj BCoppens adept paper_cc mije THC4k djinni Yoric[DT] u_quark aik blastbeat dschoepe QplQyer triplez dolio sioraiocht nominolo rejeep rgr mreh rdd RayNbow igel alter smorg medfly jrib leadnose Tomas mattwynne danvet miccm bauchus thp hkBst horms noteventime)
03:47:52 --- names: list (shintah ksf lemonjelly BONUS woggle kayess macron galdor jeltsch jystic Athas Cale rlarson86 int-e timebomb namor_ eagletmt Peaker paolino pao fbru02 ReDAeR jelly12gen ulfdoz joga ShoeRain iaefai twb zaarg byorgey_ dons nwf abbe zakwilson hackagebot ivanm Cthulhon| voker57 c_wraith dibblego aeron mmaruseacph2 IamMilan Xichekolas tommd Jafet eno__ ablokzijl borism dmwit novas0x2a Stefa2 Philonous1 erg0t otto_s absentia alexsuraci rdrake)
03:47:52 --- names: list (Liskni_si psal _Ray_ BMeph ksandstr Apocalisp XGas xinming Saizan_ alvarezp sshc saccade_ saint_cypher reqamst mandy_ flippo anonym newToHaskell caligula_ gwern jsgf mxc kuningas kosmic skorpan copumpkin Pygmalion ve fxr mshaw aconbere Pthing ttmrichter Gracenotes bohanlon geoaxis Cobra^^ Axman6 hazridi dfeuer Beelsebob JaffaCake1 nimred mansour equanimity peddie_ sigh FunctorSalad MacCoaster lhnz cognominal BgPerl-VB04 dancor Nanar malcolmw)
03:47:52 --- names: list (s76 CalJohn Philippa TR2N jvogel_ chaosape andrewsw-afk nerfquark trofi ketil doublethink_work Taggnostr impl Aikawa Kambus jan_ ChthonLaptop mm_freak tomasos zoonfafer trez gbeshers glith kmc gbeshers_ SamB_XP_ mp_g dreixel MyCatVerbs lunabot lambdabot OnionKnight noj EvilRanter koala_man angelixd_ niksnut ChilliX lefant Lemmih Gilly epmf aleator maskd sebbe1991 jims gbacon tilman deavid ps-auxw smg qwr Zao dqd shutdown_-h_now jre2 Colours)
03:47:52 --- names: list (Bassetts matthew-_ heaumer Boney _plcs_ ToRA magicman rey_ trzkril ziman opqdonut laz0r prigaux koninkje_away sebas_ yernab Igloo Vq dilinger Exteris igorgue loupgaroublond scott_ droidcore desu looooop Adamant daed Aisling_ QtPlaty[HireMe] BrianHV pem_ Twey thingwath sjanssen nnunley tensorpudding wharrgarble mikm Mr_Awesome jfredett inimino deiga_ kynky Pewpewarrows ned ddarius jayne tarbo_ flori thorkilnaur_ suiside taruti mjrosenb)
03:47:52 --- names: list (dino- newsham jlouis_ tuukkah ibid harlekin thoughtpolice daf poucet nornagon DrSyzygy brx r0bby Gabbie arcatan jvoorhis DRMacIver lanaer Arnar rapacity cjay etpace_ Jiten_ sunnavy mrd Vulpyne majoh sgf dr4wd3 quicksilver tew88 theclaw pettter wdonnelly Laney burp kalven dayz byoteki jrockway qm13 saiam And[y] neurocyte Esmil samulihs Badger mokus Stephan202 p}q_ Deewiant spoop sevvie Tobsan Counter-Strike ertai sbok Khisanth guerby gildor)
03:47:52 --- names: list (tavelram AnMaster mux yahooooo qed Ornedan anders^^ zsol Veinor alexander m4thrick dionoea aempirei eevar regulate preflex bind_return ijnek stepnem Jaak Cyneox StarFire sunfun omes PHO_ JuanDaugherty infrared lantti kar-1 astrocub mattam MrDomino^ inhortte earthy ville olsner drhodes jfoutz hiredman fryguy kanalj nsfx liff tromp_ _br_ Vanadium ahihi __marius__ jleedev icee ahf idnar clog SmurfOR LeCamarade|Away anekos Lycurgus kolmodin)
03:47:52 --- names: list (mahogny jlaire noddy integral thetallguy orbitz sohum vili1 Elly boyscared det tessier Twigathy Jedai whoppix GNU\colossus willb helge_ Elench mreggen pshc Neronus pragma_ agemo dcoutts Raku^ otherdude Megant bolrod glitch raim0_ wagle_home shortcircuit h3r3tic gnuvince alpheccar thetallguy1 guerrilla teneighty stepcut nathanic_work noZone tamiko wolverian davidL endojelly Poeir lstor felipe_ Draconx Botje Bleadof lament Annie|Home wornof)
03:47:52 --- names: list (canvon authentic sieni nasloc__ mml` wang aggiejy bd_ mlesniak drbean_ jimmyjazz14 karld Schmidt ath saccade TML StoneToad welterde glguy gdsx_ augur Nereid Bassetts_ Whitesquall anji gogonkt danchou mfp lsthemes arvid_ dcoutts_ Blaketh stoop danopia nablaa shapr benmachine marmolak jtra jimi_hendrix sereven periodic cods nlogax aep mauke ehamberg flux Ferdirand Warrigal Valodim profmakx arkx birkenfeld nominolo|uni erg t zygoloid Baughn)
03:47:52 --- names: list (sproingie shachaf @ChanServ mornfall crem Trafalgard midnite tmatix sior|oifig araujo electrogeek tmug nothingmuch jnwhiteh jonafan jql Reisen snorble hexpuem tltstc kniu PsiOmega pixel5 fredcy shepheb eelco malouin xian Paradox924X tinLoaf luite Blub\0 ggreg_ LeoD blackdog mikste angel_de_vicente M| jbauman gju shellsage encryptio webframp mmmdonuts ray McManiaC hellige dixie mfoemmel ski pikhq jones- Raevel tkr desp _Jordan_ fnord123)
03:47:52 --- names: list (dogmaT tumult thomastc jonto_aw dcolish int_e netcat ^Einstein mlh bran SimonRC stedolan Sisu im_maciek fnordus aavogt kw317 mapreduce ponzao__ alip osfameron eyck_ SubStack Nafai mercury^ Optimoe mdordal2 wormwood joed stroan joevandyk dumael stalker bockmabe p_l jahgru Eelis SeaPrior Milo- allbery_b skaar kakeman jml sutats otulp loop ClaudiusMaximus)
03:48:02 <dolio> Anyhow, how coproducts work is from M and N, you make M :+: N, which as I recall admits a sort of arbitrary nesting of M and N.
03:48:13 <thp> Peaker: I now have got this so that in case of Nothing I get 0: maybe 0 (\x -> x) (...) where (...) is the function that returns a Maybe Int
03:48:51 <dolio> Then, to run it, you provide (forall a. M a -> O a) and (forall a. N a -> O a), and it unravels the nesting by turning all the Ms and Ns into O, and using join in O, or something like that.
03:49:23 <Peaker> thp, \x -> x   is so useful it has a name: id (the identity function)
03:49:50 <Peaker> thp, and  maybe something id   is so useful it has a name:  fromMaybe
03:49:53 <Peaker> @src fromMaybe
03:49:53 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
03:50:03 <Peaker> @type fromMaybe
03:50:04 <lambdabot> forall a. a -> Maybe a -> a
03:50:11 <Peaker> @type (`maybe` id)
03:50:12 <lambdabot> forall a. a -> Maybe a -> a
03:50:59 <Peaker> thp, so you can use: fromMaybe 0
03:51:26 <thp> Peaker: thanks :) (as you probably noticed, I'm just starting with haskell :p)
05:51:56 <Peaker> thp, Yeah, I envy you for you are about to make many delightful discoveries :-)
05:52:13 * en0th_ got an assignment in C.
05:52:17 * en0th_ cries.
05:52:56 <dolio> There's also Lawvere theories, which I've heard people describe as being superior to monads for modeling effects, but I don't really understand them, or whether you could build combinator libraries out of them.
05:53:59 <Peaker> dolio, I like Monad Transformers, myself, but wondering about the alternatives
05:54:15 <dolio> And the paper I tried reading recently said, in effect, that you can't do continuations with Lawvere theories, because continuations 'aren't really an effect' or something like that, which I don't find encouraging.
05:54:35 <Peaker> HackageDB :: [Package]  is not quire right, btw, its more of a:  HackageDB :: Time -> [Package] :-)
05:55:19 <mauke> en0th_: what do you have to do?
05:55:58 <en0th_> mauke: a small superserver like inetd, *with config file* ! :(
05:56:06 <mauke> oh, ouch
05:56:11 <monadic_kid> I'm going to mix both c2hs and  hsc2hs, which way around should I build, c2hs -> hsc2hs or the other way?
05:57:26 <Peaker> en0th_, not too bad if you're allowed to use existing libraries for config files
05:58:56 <en0th_> i guess i cannot.. i really miss Haskell. Sadly i haven't time for it..
05:59:38 <en0th_> the world is so.. impure.
06:01:02 <mreh> en0th_ : haskell has ruined my life
06:01:05 * Jafet rapes en0th
06:01:25 <en0th_> mreh: why!
06:01:40 <mreh> every language everyone else wants me to use is so boring
06:02:04 <en0th_> heh
06:02:21 <FunctorSalad> we must haskell people to want us to use haskell then
06:02:42 <mreh> HAHAHA
06:03:02 <mreh> awful
06:03:47 <FunctorSalad> yes I just wanted to include the verb Haskell in there :(
06:05:29 <ivanm> FunctorSalad: but you didn't use it as a verb...
06:05:54 <FunctorSalad> ivanm: in the first occurence I did
06:06:03 <dolio> Come to think of it, I don't think coproducts handle continuations well, either, if I remember the article correctly. They're only constructible for finitary (or some other adjective) monads.
06:06:12 <ivanm> FunctorSalad: oh, right, you used "haskell" twice...
06:07:44 <FunctorSalad> dolio: WP says lawvere theories are like equational theories... no wonder they don't include continuations then :)
06:07:58 <dolio> Yeah.
06:08:20 <Peaker> I tried convincing my coworkers to use Haskell for various things -- everybody's too scared of learning/switching languages
06:08:27 <FunctorSalad> (and every equational theory gives a Set -> Set monad that takes the free gadget over the set... don't know about the lawvere generalization)
06:08:31 <Peaker> I got a few to be fellow enthusiasts too that try to push Haskell..
06:08:43 <dolio> They don't do partiality (like you might model with a monad in Agda), either.
06:09:54 <dolio> At least, according to the paper I have.
06:10:10 <dolio> Although they're talking about Moggi's stuff, mostly.
06:10:19 <FunctorSalad> equational theories are relatively well-known though, so maybe this notion is still useful even if it doesn't replace monads
06:10:51 <MrBlueSky> Happy Halloween #Haskell!
06:12:22 <dolio> And he just talks about partiality as "M A = A \cup {_|_}" which isn't the sort of thing you do when making it a monad in Agda.
06:12:51 <Heffalump> has anyone tried out the latest darcs cabal-install? It seems to have a problem with actually downloading packages
06:13:45 <mreh> o noes, it's haloween
06:14:42 <mreh> why don't generic types have a namespace?
06:15:26 <mreh> like when I'm defining a function inside another, why can't the context also apply to my function
06:15:42 <mreh> you don't loose any generality... or do you
06:15:48 <mreh> maybe you do
06:16:56 <FunctorSalad> mreh: -XScopedTypeVariables
06:17:03 <FunctorSalad> if by 'generic type' you mean a type variable
06:17:17 <mreh> yes, that one
06:17:18 <FunctorSalad> ('generics' is used for something else in haskell)
06:17:36 <mreh> type variables are like generics in java
06:17:57 <mreh> sorry, I am trying to remove all traces of Java from my system
06:18:14 <mreh> switching to decaf
06:19:25 <en0th_> (is there a full book about ghc implementation?)
06:19:58 <ivanm> en0th_: I doubt it
06:20:19 <Peaker> mreh, type varibles are like generics in Java, on Steroids, on Steroids, on Steroids
06:20:58 <hackagebot> breakout 0.0.2 - A simple Breakout game implementation. (EyalLotem)
06:20:58 <Elench> So dead and with excessive hair growth?
06:22:37 <mauke> excellent
06:23:33 <Peaker> Elench, :-)
06:26:38 <mreh> I don't get why this error keeps happening: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11369#a11369
06:26:48 <mreh> I thought I qualified it correctly
06:30:25 <dolio> You need parentheses around the forall s. (ST s (Gen s))
06:31:03 <dolio> Otherwise that forall s. can be lifted all the way to the top level.
06:31:54 <mauke> preflex: seen sm
06:31:54 <preflex>  sm was last seen on #haskell 16 hours, 30 minutes and 18 seconds ago, saying: oh, it's like /me
06:33:02 <dolio> Because "A -> forall s. B -> C" = "A -> (forall s. (B -> C))" = "forall s. A -> B -> C" as long as 's' isn't free in A.
06:33:55 <ReDAeR> dolio: That makes so much sense ;o
06:37:20 <tibbe> Anyone know which source tarball I should use when building GHC from source on Windows?
06:37:35 <ivanm> tibbe: AFAIK, there's only one source tarball...
06:37:54 <ivanm> or, there might be .zip and a .tar.gz versions, but they'd have the same contents
06:37:59 <mauke> why are you building GHC from source on windows?
06:38:04 <mauke> s/ on windows//
06:38:11 <tibbe> ivanm: there's a -mingw version too
06:38:27 <ivanm> mauke: I build GHC from source...
06:38:29 <tibbe> mauke: testing 6.12 to try to see if I can fix a network compile failure
06:38:36 <mauke> ah
06:38:47 <ivanm> tibbe: you mean it makes a difference if you build with mingw as opposed to cygwin?
06:39:11 <ivanm> tibbe: well, how are you compiling it?
06:39:25 <ivanm> if using mingw, use that version; if using cygwin, use the normal version
06:39:29 * ivanm guesses
06:40:50 <tibbe> ivanm: hmm, I downloaded msys as per the Building GHC on Windows instuctions
06:40:59 <ivanm> *shrug*
06:41:03 <tibbe> ivanm: I wonder if that counts as mingw
06:41:11 <ivanm> I think it does
06:41:14 <p_l> tibbe: yes
06:41:34 <p_l> though I recall weird stuff about MSYS/mingw versions
06:43:12 <tibbe> p_l: it's all kinda messy
06:52:27 * ReDAeR is stunned once again my the simplicity of a haskell recursive solution
06:52:31 <ReDAeR> my=by*
06:53:15 <Peaker> ReDAeR, which one?
06:53:45 <ReDAeR> Binary Tree, how to count elements, construct them, sort them from left to right etc
06:54:12 <Peaker> ReDAeR, yeah, trees lend themselves very nicely to recursive algorithms.. most of those are simple tree folds too
06:54:25 <FunctorSalad> getSum $ foldMap (const (Sum 1))
06:54:26 <FunctorSalad> ;)
06:54:55 <Peaker> @hoogle foldMap
06:54:56 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:54:56 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
06:55:05 <Peaker> :-)
06:55:17 <Peaker> I love Monoids
06:55:29 <FunctorSalad> well I don't love the newtypes so much
06:55:45 <FunctorSalad> oO (local opening of instances?)
06:56:39 <Peaker> FunctorSalad, I see the newtypes as a very reasonable solution to instance selection
07:06:25 <stroan> @src mapM
07:06:25 <lambdabot> mapM f as = sequence (map f as)
07:06:50 <stroan> @src liftM
07:06:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:14:58 <Taejo> byorgey: is it possible to define recursive species in the species library? e.g. tree = 1 + (tree * tree)
07:15:13 <ReDAeR> Wouldn't that cause an infinite loop?
07:15:49 <Taejo> ReDAeR: well I don't know how the species library works, so that's what I'd like to know
07:16:22 <mauke> preflex: nickometer ReDAeR
07:16:22 <preflex>  ReDAeR is 98.67% lame
07:17:01 <en0th> what's that!
07:17:06 <ReDAeR> preflex: nickometer mauke
07:17:06 <preflex>  mauke is 0% lame
07:17:09 <ReDAeR> >.<
07:17:10 <ReDAeR> Cheetz
07:17:54 <zygoloid> preflex: nickometer Cheetz
07:17:54 <preflex>  Cheetz is 0% lame
07:17:58 <zygoloid> hah
07:18:06 <Taejo> ReDAeR: lowercase letters are never lame. afair, uppercase at the end of a nick is very lame, leetspeak is very lame, and internal caps are somewhat lame
07:18:21 <int-e> dashes are somewhat lame.
07:18:26 <int-e> preflex: nickmeter int-e
07:18:32 <Taejo> preflex: nickometer Th1sIzV3ryLameZ
07:18:32 <preflex>  Th1sIzV3ryLameZ is 99.964203% lame
07:18:38 <ReDAeR> Lulz
07:18:40 <zygoloid> preflex: nickometer DonS
07:18:40 <preflex>  DonS is 0% lame
07:18:41 <int-e> preflex: nickometer int-e
07:18:41 <preflex>  int-e is 14% lame
07:18:59 <int-e> preflex: nickometer int_e
07:18:59 <preflex>  int_e is 14% lame
07:19:13 <ReDAeR> I could just name myself after my firstname but what.. what would be the point, you use tab, or are you typing my name by hand?
07:19:27 <ReDAeR> :O
07:19:28 <mauke> preflex: nickometer en0th
07:19:28 <preflex>  en0th is 31% lame
07:19:34 <en0th> w00t!
07:19:34 <ReDAeR> preflex: nickometer robert
07:19:35 <preflex>  robert is 0% lame
07:19:56 <ReDAeR> preflex: nickometer H4X
07:19:56 <preflex>  H4X is 33% lame
07:20:02 <Jafet> preflex: nickometer _d_-[d34Th]-_b_`
07:20:02 <preflex>  _d_-[d34Th]-_b_` is 99.951309% lame
07:20:04 <Vanadium> Uppercase last letter is perfectly acceptable when the last letter is in fact the first letter of the last name :<
07:20:11 <ReDAeR> Oh.. i would suspect 100% lame for that
07:20:12 <medfly> preflex, nickometer ReDAeR
07:20:12 <preflex>  ReDAeR is 98.67% lame
07:20:15 <medfly> hahaha
07:20:17 <int-e> ReDAeR: the inner capitals are a bit hard on the eye, imo
07:20:19 <mercury^> preflex: nickometer mercury^
07:20:20 <preflex>  mercury^ is 14% lame
07:20:34 <Taejo> Vanadium: it's just a bunch of arbitrary rules, I might not have remembered them correctly
07:20:38 <medfly> I usually identify people by the colour of their nick on my client and their nick length, so I don't care
07:20:58 <medfly> preflex, nickometer medfly
07:20:58 <preflex>  medfly is 0% lame
07:21:00 <medfly> :)
07:21:11 <mercury^> medfly: I bet you like the white nicks best!
07:21:24 <medfly> oh no, I have a white background, so no nicks are white
07:21:26 <ReDAeR> (He customized his IRC client so all names are white)
07:21:26 <Vanadium> Maybe we ought to port the nickometer into a lambdabot @let
07:21:40 <FunctorSalad> white background? D:
07:21:41 <mauke> Vanadium: hah, I'd like to see that
07:21:56 <medfly> yes, I'm not very nerdy, I know
07:22:18 <FunctorSalad> :)
07:22:40 <FunctorSalad> well my xchat still has gray panels :(
07:22:47 <medfly> yeah, that's why I kept it white
07:22:51 * ReDAeR loves his irssi :)
07:22:57 <mercury^> Is there any study around that proves what everyone knows, that dark background is best?
07:23:04 <jeltsch> If you use a KDE IRC client like I do, you might not be very nerdy, but you get a nice white background.
07:23:14 <medfly> mercury^, best at what?
07:23:22 <mercury^> Best for the eyes.
07:23:26 <mauke> preflex: nickometer warezdude
07:23:26 <preflex>  warezdude is 99.2621% lame
07:23:29 <Taejo> @tell byorgey does species handle recursively defined species? is there a way to make things like | let tree = 1 + nonEmpty (tree * tree) in generate tree "abcd" | work?
07:23:29 <lambdabot> Consider it noted.
07:23:39 <medfly> you're staring at a monitor for hours on end. can't be too good
07:24:02 <medfly> the good choice is to take frequent breaks from staring at the computer.
07:24:05 <ReDAeR> hours, make that days ;o
07:24:11 <FunctorSalad> mercury^: unless you use dark gray fonts on the black, like some Friendly websites do ;)
07:24:12 <medfly> you don't sleep?
07:24:21 <jeltsch> mercury^: Isn’t dark worst for the eye?
07:24:42 <jeltsch> preflex: nickometer jeltsch
07:24:42 <preflex>  jeltsch is 0% lame
07:24:43 <ReDAeR> mercury^: i prefer white chars on a black background then the other way arround
07:24:43 <mercury^> jeltsch: my impression is that light grey on black background is easiest on the eyes.
07:24:52 <jeltsch> Really?
07:24:55 <mercury^> Yep
07:24:56 <zygoloid> Taejo: the last letter rule is: last alpha letter is capital X or Z
07:25:05 <Berengal> I prefer dark grey characters on a light-grey background
07:25:06 <medfly> I think white on black is the nerdy choice because that's how terminals are
07:25:13 <medfly> or is it the other way around
07:25:17 * FunctorSalad prefers white or full green
07:25:28 <FunctorSalad> (on black)
07:25:39 <mercury^> Green is the truly nerdy choice.
07:25:42 <medfly> switching from a black background to a white background is painful, and sometimes I use website.
07:25:44 <Berengal> FunctorSalad, I'm with you on the green, when I feel really l33t
07:25:47 <medfly> websites
07:25:51 <FunctorSalad> mercury^: it's also quite readable somehow
07:25:56 <jeltsch> mercury^: Green on black?
07:26:00 <mercury^> Yes.
07:26:05 <mercury^> I don't like it.
07:26:11 <jeltsch> Like old monitors, yeah!
07:26:12 <mercury^> But many people use it because "hackers do"
07:26:19 <burp> lol
07:26:23 <jeltsch> :-D
07:26:27 <medfly> I find it pretty, but I don't use it.
07:26:34 <FunctorSalad> or because they like colors and blue and red aren't so readable
07:26:35 <burp> matrix like
07:27:01 <mauke> preflex: nickometer Alucard_Not_Orca
07:27:01 <preflex>  Alucard_Not_Orca is 99.8306% lame
07:27:03 <mercury^> FunctorSalad: low intensity yellow would be much better imo.
07:27:05 <mauke> wow
07:27:20 <medfly> Alucard_Not_Orca, you're very lame
07:27:29 <FunctorSalad> preflex: nickomete >>=
07:27:31 <FunctorSalad> preflex: nickometer >>=
07:27:32 <preflex>  >>= is 97.05% lame
07:27:36 <medfly> preflex, nickometer FunctorSalad
07:27:37 <preflex>  FunctorSalad is 0% lame
07:27:40 <medfly> wow
07:27:50 <Taejo> clearly, nickometer hates haskell
07:27:54 <medfly> I thought it won't like you because you have capital letters in your nick
07:28:01 <Taejo> can we ban it please?
07:28:02 <FunctorSalad> mercury^: aka brown :o
07:28:14 <medfly> or POOP COLOUR
07:28:20 <FunctorSalad> YES
07:29:32 <zygoloid> preflex: nickometer fix$((0:).(1:).)$zipWith(+)<*>tail
07:29:32 <preflex>  fix$((0:).(1:).)$zipWith(+)<*>tail is 99.987655% lame
07:29:53 <mercury^> Is there a truly lame name?
07:30:06 <zygoloid> ^^ clearly a rounding error. fibonacci is really 99.9876543210% lame
07:30:57 <FunctorSalad> preflex: nickometer is 10% lame
07:30:58 <preflex>  is 10% lame is 99.4131% lame
07:31:06 <FunctorSalad> preflex: nickometer is 99.4131% lame
07:31:06 <preflex>  is 99.4131% lame is 99.8220% lame
07:31:15 <FunctorSalad> preflex: nickometer is 99.8220% lame
07:31:15 <preflex>  is 99.8220% lame is 99.8091% lame
07:31:16 <burp> find the fixpoint :D
07:31:20 <FunctorSalad> right
07:31:37 <Taejo> can we please lay off the nickometer crap?
07:31:43 <byorgey> Taejo: there isn't yet; this is by far the most glaringly obvious missing feature, and one I'm working hard on adding.
07:31:44 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:32:11 <byorgey> but I've gotten caught in some rather nasty type problems.  I think I'll write a blog post about it soon.
07:32:14 <Taejo> byorgey: cool. is there an alternative way to define the species of trees?
07:32:43 <ReDAeR> http://omploader.org/vMm52bA (<3 my irssi :o)
07:32:45 <byorgey> Taejo: not that I know of, I'd have to think about it...
07:33:18 <zygoloid> mercury^: looks like it computes an integer score s, then returns the percentage: 100 * (1 + tanh ((s-400) / 400)) * (1-1/(1+s/5)) / 2
07:33:26 <zygoloid> mercury^: so no, you can't get 100% lame
07:34:03 <zygoloid> i'm assuming it's using this: http://adamspiers.org/computing/nickometer/
07:35:13 <ReDAeR> Integer? :o more like a double?
07:38:33 <byorgey> Taejo: but if you need this feature that will give me some motivation to get it working =)
07:39:07 <gwern> :t (</>)
07:39:08 <lambdabot> Not in scope: `</>'
07:39:12 <gwern> @hoogle (</>)
07:39:12 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
07:39:12 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
07:39:12 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
07:39:27 <Taejo> let need = "desire, in order to satisfy a long-lasting curiosity" in byorgey, I need this feature
07:40:20 <Peaker> what's with all-uppercase names?
07:41:01 <gwern> it's a mystery!
07:41:11 <Berengal> Peaker, they're classes, which instances are supposed to "act" like the type
07:41:38 <Peaker> Berengal, What does that mean? How is it different from normal classes?
07:42:16 <Berengal> Peaker, it's not different. It's just that the names are supposed to be similar, but they can't be identical, for obvious reasons
07:42:48 <Peaker> So there's HtmlTable and HTMLTABLE?
07:42:59 <Berengal> Indeed. And there's Html and HTML
07:42:59 <Peaker> does the class have other instances besides HtmlTable?
07:43:10 * Irrelevant would go for data HtmlTable and class HtmlTabley :P
07:43:20 <Vanadium> HtmlTable and HtmlTableClass?:<
07:43:28 <Irrelevant> IsHtmlTable?
07:43:31 <mauke> Html and Hmtl
07:43:39 <Berengal> Peaker, Html
07:44:47 <Berengal> Peaker, it's easier to see the logic with the HTML class. It has more instances, like String, (HTML a) => [a], HtmlTable etc.
07:45:36 <gwern> I just hope we won't confuse it with htmLTable
07:45:38 <Peaker> Berengal, I suppose the class has:  a -> Html ?
07:45:46 <Peaker> Berengal, I'd call it HtmlShow or such
07:45:59 <Berengal> Peaker, it does, and [a] -> Html
07:47:07 <Berengal> Not a big fan of the naming convention myself, but it's easy to get and easy to read. It's just ugly, not bad.
07:47:10 <Peaker> HTML is a bad name for it :-P
07:47:56 <FunctorSalad> does current graphics-drawingcombinators work for anyone? (init >> draw foo) does nothing for me (program just exits)
07:48:42 <Peaker> Berengal, its bad in that its not immediately clear from the name how it is similar to Show
07:49:07 <Berengal> Peaker, it's not similar to Show, it's similar to Html
07:49:24 <Peaker> @src Shiw
07:49:25 <lambdabot> Source not found. It can only be attributed to human error.
07:49:28 <Peaker> @src Show
07:49:28 <lambdabot> class  Show a  where
07:49:28 <lambdabot>     showsPrec :: Int -> a -> ShowS
07:49:28 <lambdabot>     show      :: a   -> String
07:49:28 <lambdabot>     showList  :: [a] -> ShowS
07:49:44 <Berengal> Show has a rather different use-case
07:50:56 <jeltsch> preflex: nickometer nickometer
07:50:56 <preflex>  nickometer is 0% lame
07:51:06 <jeltsch> preflex: nickometer preflex
07:51:07 <preflex>  preflex is 0% lame
07:51:15 <jeltsch> preflex: Wrong!
07:52:12 <sohum> what's the nickometer?
07:53:26 <jeltsch> sohum: It seems to check how lame nicks are.
07:53:37 <jeltsch> preflex: nickometer sohum
07:53:38 <preflex>  sohum is 0% lame
07:53:48 <jeltsch> Good for you. :-)
07:53:50 <sohum> um. yay?
07:54:24 <sohum> preflex: nickometer l33t_h4x0r
07:54:24 <preflex>  l33t_h4x0r is 99.914452% lame
07:54:31 <sohum> impressive.
07:54:37 <jeltsch> :-D
07:54:43 <m0nkfish> aw man
07:54:48 <m0nkfish> preflex: nickometer m0nkfish
07:54:49 <preflex>  m0nkfish is 31% lame
07:54:49 <mreh> how could I return the index of a minimum inside a collection? foldl1 min and then just find the first element that is equal to that
07:54:54 <m0nkfish> gah
07:55:06 <mreh> is there an easier way?
07:55:28 <jeltsch> preflex: nickometer foldl1
07:55:28 <preflex>  foldl1 is 22% lame
07:55:36 <MyLittleSimCoin> preflex: nickometer shrdlu
07:55:37 <preflex>  shrdlu is 0% lame
07:55:54 <jeltsch> mreh: So better don’t use fold1. :-D
07:56:02 <MyLittleSimCoin> preflex: nickometer H@sk311
07:56:02 <preflex>  H@sk311 is 64% lame
07:56:23 <luite> mreh: you could zip with [0..] and then do the fold
07:56:34 <jeltsch> preflex: nickometer MyLittleSimCoin
07:56:35 <preflex>  MyLittleSimCoin is 99.939967% lame
07:56:38 <mreh> luite, genius
07:56:57 <burp> or min and elemIndex combination
07:56:59 <jeltsch> MyCatVerbs: Sorry, didn’t expect THAT.
07:57:12 <sohum> so it's doing more than just counting numbers
07:57:21 <jeltsch> MyLittleSimCoin: Sorry, didn’t expect THAT.
07:57:29 <mreh> actually, zip with [0..] is going to be harder to understand
07:57:38 <sohum> mreh: remember min `on` second
07:57:41 <jeltsch> MyCatVerbs: Didn’t mean you. Sorry.
07:57:55 <luite> mreh: minimumBy (compare `on` fst) $ zip xs [0..]
07:57:56 <mreh> :t on
07:57:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:57:59 <jeltsch> preflex: nickometer `on`
07:58:00 <preflex>  `on` is 26% lame
07:58:15 <mreh> who is this joker?
07:58:19 <jeltsch> mreh: Okay, I’ll stop now.
07:58:20 <FunctorSalad> zipping with [0..] is pretty common though isn't it
07:58:21 <luite> at least if it's a list
07:58:34 <FunctorSalad> (re understandability)
07:58:51 <Jafet> mreh, *the* minimum?
07:58:59 <sohum> :t map
07:59:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:59:19 <mreh> Jafet: I want to find the index of the minimum of a list
07:59:24 <sohum> @pl \f xs -> map f (zip [0..] xs)
07:59:24 <lambdabot> (. zip [0..]) . map
08:01:54 <gwern> @wn complect
08:01:55 <lambdabot> *** "complect" wn "WordNet (r) 2.0"
08:01:55 <lambdabot> complect
08:01:55 <lambdabot>      v : be interwoven or interconnected; "The bones are
08:01:55 <lambdabot>          interconnected via the muscle" [syn: {interconnect}, {interlink}]
08:08:28 <jlouis_> mreh: I think your plan is flawed if you wan't the index of a list
08:08:55 <mreh> jlouis_ how did you arrive at that conclusion
08:09:04 <mreh> are you familiar with k-means squared?
08:09:10 <mreh> or just k-means
08:09:20 <mreh> forget the squared
08:09:38 <jlouis_> mreh: well, links are singly-linked lists so asking for the index of any element in them is usually silly
08:10:39 <jlouis_> the path has already been laid out: zip with a  series of numbers and find the one you are looking for. Since you attached numbers to all of them, you know the index
08:10:41 <mreh> i'm not asking for that element, i'm using that index in an array
08:18:20 <mreh> :t minimumBy (compare `on` fst) $ zip xs [0..]
08:18:21 <lambdabot> Not in scope: `xs'
08:18:39 <mreh> :t minimumBy (compare `on` fst) $ zip [0..] [0..]
08:18:39 <lambdabot> forall a b. (Ord a, Num a, Enum a, Num b, Enum b) => (a, b)
08:19:24 <patch-tag> is there a way to generate haddock with source links, using cabal install? I described a way to generate haddock at http://blog.patch-tag.com/2009/10/23/cabal-install-a-package-with-documentation/ but I'd like this to be with source links.
08:20:26 <Lemmih> patch-tag: --hyperlink-source?
08:20:45 <mreh> which method uses the class Enum?
08:22:21 <mreh> function, not method
08:23:38 <mreh> :t \xs -> minimumBy (compare `on` fst) $ zip xs [0..]
08:23:38 <lambdabot> forall a b. (Ord a, Num b, Enum b) => [a] -> (a, b)
08:24:08 <mreh> :t \xs -> snd . minimumBy $ (compare `on` fst) $ zip xs [0..]
08:24:09 <lambdabot>     Couldn't match expected type `(a, b)'
08:24:09 <lambdabot>            against inferred type `[a1] -> a1'
08:24:09 <lambdabot>     In the second argument of `(.)', namely `minimumBy'
08:24:30 <mreh> :t \xs -> snd $ minimumBy  (compare `on` fst) $ zip xs [0..]
08:24:31 <lambdabot> forall a b. (Ord a, Num b, Enum b) => [a] -> b
08:24:56 <mreh> what's with the existentials in output of ':t'?
08:27:18 <patch-tag> cabal install --haddock-options=--hyperlink-sourceblehblehbleh     doesn't throw an error. without the blehblehbleh it runs, but doesn't install with source links.
08:27:44 <Lemmih> patch-tag: It's an argument to 'cabal haddock'.
08:28:20 <patch-tag> I get that, but then why doesn't haddock throw an error?
08:29:03 <patch-tag> examples section should really include examples using --with-PROG and --PROG-options
08:29:12 <patch-tag> I can't find a good one online
08:31:01 <patch-tag> cabal haddock --hyperlink-source does the right thing
08:31:09 <patch-tag> ahhhh
08:31:18 <patch-tag> I guess I didn't get it
08:31:55 <patch-tag> fine, so why does cabal support --haddock-options if this doesn't do what I wanted?
08:32:04 <patch-tag> i mean, why doesn't...
08:32:26 <patch-tag> I mean... you know.
08:46:30 <hirbel> where can I get ThreadScope?
08:47:38 <patch-tag> When I updated gitit cabal file to use dev version of happs (4.0), there's some kind of major problem which I suspect to be lazy io related. (because I suspect all problems that aren't easily diagnosable to be that)
08:48:34 <mreh> how does one divide a whole row of a system of equations by the row of another?
08:48:53 <mreh> i thought about multiplying by the inverse of the transpose, but my matrices aren't square
08:56:58 <cinimod> *Main> genericLength [1..1000000]
08:56:58 <cinimod> *** Exception: stack overflow
08:57:21 <cinimod> I must admit I wasn't expecting that
08:58:36 <Saizan_> patch-tag: --haddock-options adds those options to all the invokation of the haddock executable, it doesn't add them to the haddock command of cabal-install
09:03:58 <patch-tag> erm.... but the haddock executable is called by cabal install, or dist/doc wouldn't contain anything right?
09:04:47 <dcoutts> patch-tag: right, Cabal calls haddock
09:05:30 <patch-tag> so... cabal install --haddock-options=--hyperlink-source
09:05:36 <patch-tag> should call haddock --hyperlink-source, right?
09:06:11 <dcoutts> patch-tag: yes, but haddock does not have a --hyperlink-source flag, so that would not help you
09:06:39 <dcoutts> the "cabal haddock" sub-command has a --hyperlink-source flag
09:07:06 <patch-tag> oh, ok
09:08:20 <dcoutts> patch-tag: if you're trying to make "cabal install" do hyperlinked haddock sources then you should know that you cannot.
09:08:44 <dcoutts> since nobody has worked out a sane command line interface, so we've not implemented it yet
09:09:07 <dcoutts> there's an open ticket on it if you have a good suggestion
09:09:41 <patch-tag> a sane command line interface to haddock or cabal?
09:09:47 <dcoutts> to cabal
09:10:41 <EddyDean> Is ghc supposed to give "undefined reference" errors if I import Data.Set in a program?
09:10:56 <patch-tag> eddy: don't think, so http://hpaste.net
09:11:09 <dcoutts> EddyDean: make sure you're using ghc --make
09:11:30 <patch-tag> sorry, hpaste.org
09:11:47 <dcoutts> patch-tag: we've got the "install" command which is an "all in one" command and people want to be able use specific options for the various steps, but we do not want to grow an ad-hoc collection of flags on the install command. We want something systematic.
09:11:52 <EddyDean> --make solves it, thanks dcoutts
09:11:57 <dcoutts> systematic but usable
09:12:07 <dcoutts> EddyDean: you always want to use --make really
09:12:33 <patch-tag> is there an argument to haddock that generates hadock with source links? I couldn't find one.
09:12:49 <dcoutts> patch-tag: yes, but not the thing it links to
09:13:08 <patch-tag> hmm
09:13:39 <dcoutts> patch-tag: cabal calls hscolour to make the colourised source, and calls haddock with flags to point to that
09:15:19 <mreh> :i `on`
09:15:35 <mreh> duh
09:16:28 <mreh> :t on
09:16:29 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:16:40 <mreh> which package is this from?
09:16:46 <luite> Data.Function
09:17:06 <aavogt> @index on
09:17:06 <lambdabot> bzzt
09:17:07 <luite> but I forgot the lambdabot command :)
09:25:21 <jre2> > min 1 $ sqrt (-1)
09:25:22 <lambdabot>   NaN
09:25:23 <d4mien> hi everyone I am new to haskell and sitting with some exercises. I don't want a complete answer but a little light in the dark would be nice. If I got a function like this and want to compute the amount of steps it takes and I got the base case that power n 0 = 1 how could I go further?
09:25:25 <jre2> blast
09:25:33 <d4mien> http://pastebin.com/m4d08b9dd
09:26:37 <jokerGTA> benmachine you there
09:26:58 <d4mien> and I know that power n 1 is 1 step and then using powner n 0 which is 1 step then power n 1 is 2 steps
09:27:07 <d4mien> right? :)
09:27:41 <zygoloid> d4mien: what sort of 'steps' do you want to count? number of multiplications?
09:27:45 <Axman6> d4mien: what do you mean by steps?
09:28:09 * Axman6 thinks 'steps' sounds very imperative
09:28:17 <burp> function evaluations?
09:28:24 <sm> mauke: thanks for the patch
09:28:33 <d4mien> i mean the amount of computing steps it takes. like power n 1 would be 2 computing steps
09:28:46 <_Ray_> Um. Weird question. I had some code that looked for the maximum element of a list (usual restrictions: no functions more complex than "length", no higher order functions, no lists by comprehension), and I was using a sort of "buffer" variable to keep the highest count so far. But then the prof explained how to do it without such a variable (as seen here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11375 ). I decided to try the same trick
09:28:46 <_Ray_> for a function I had which got the largest word out of a sentence. The problem? It works. But I don't understand why :( Code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11376 . I understand how it works if it uses a buffer, but...I especially don't understand why line 4 works. Could anyone explain it?
09:29:05 <d4mien> because it using recursive to first compute itself and then use the one after and so on until it get to the base case
09:30:25 <_Ray_> My problem is understanding why line 4 doesn't recurse anymore...
09:30:28 <zygoloid> d4mien: i'm still not quite sure what you mean by computing steps.
09:31:22 <d4mien> zygoloid this is the exercise http://pastebin.com/m7c213d55
09:31:23 <_Ray_> Hrm...does it work by chance because it's recursing on line 3 when I do the comparison?
09:31:29 <Axman6> d4mien: well, power n k will recurse k times
09:32:33 <d4mien> Axman6 yes but how could I write a function which I give a power n k and it gives me back and Integer with the amount of steps?
09:32:49 <Vanadium> goddamn gtk2hs is confusing
09:32:55 <zygoloid> d4mien: cost (power n 0) = 1; cost (power n k) = 1 + cost (power n (k-1)), right?
09:32:59 <Axman6> d4mien: but when you talk about functional programming, you don't really talk about 'steps'. it's a very imperative way of looking at things, and can somewhat impede you when trying to think in a functional way
09:33:17 <Axman6> d4mien: ah, sec
09:33:49 <Jafet> powercost power n k = k
09:34:37 <c_wraith> actually, the cost of multiplication can become significant when doing power calculations.
09:34:47 <Axman6> d4mien: http://pastebin.com/mef12706
09:34:50 <CalJohn> _Ray_: by the way, your program can be made shorter: longestWord = foldl' (\ x y -> if (length x) > (length y) then x else y) ""
09:35:12 <_Ray_> CalJohn, see where I said I can't use higher order functions or anything more complex than 'length'.
09:35:15 <Axman6> CalJohn: did you miss the part about not using anything more complex than length?
09:35:25 <Axman6> heh
09:35:27 <CalJohn> Axman6: i did
09:35:40 <_Ray_> But yes, it's a classic fold.
09:35:42 <CalJohn> (sorry ;))
09:35:42 <Jafet> c_wraith: obviously for d4mien's evaluator, multiplication is unit time
09:35:55 <Jafet> I mean, unit cost.
09:36:03 <d4mien> oh I see
09:36:22 <_Ray_> I guess I don't see why I can just stop recursing at line 4...(and I tried installing hat to see the reductions, but it won't compile on OS X, neither will hmake)
09:36:43 <d4mien> Axman6 it's my frist week in haskell and have only read 5 chapters in the book, haven't got to let yet but gonna look it up.
09:36:48 <c_wraith> Ah, for the metric it's asking about, yes.
09:36:54 <d4mien> zygoloid thanks that one I understad
09:36:58 <Axman6> d4mien: which book?
09:37:30 <d4mien> I have two acctually one is called The craft of functional programming and the other Programming in haskell
09:37:44 * Axman6 suggests you check out lyah
09:37:47 <Axman6> @where lyah
09:37:48 <lambdabot> www.learnyouahaskell.com
09:37:51 <Axman6> ^^^^^^^^^^^^^^^^^^^^^^
09:37:54 <d4mien> the first one I listed don't have answers for the exercises which I find a little odd but otherwise great book
09:39:17 <teeMan_> gonna try out the both solutions and see if I get it fully. thanks alot guys cath you in a minute
09:39:53 <_Ray_> Hrm...I think I get it...on line 3 I am exploring as deep as I can in the string. So "next" is /already/ the longest word from the end of the string to my current position. On line 4 I can just return pal (my current word) since I'm going "backwards", not "towards".
09:40:23 <_Ray_> That would be a sort of "invariant". "next is the longest word from here to the end of the string".
09:50:14 <mreh> Occurs check: cannot construct the infinite type: a = Vector a
09:50:14 <mreh>     When generalising the type(s) for `centers'
09:50:21 <mreh> I dont understand what this means?
09:50:30 <mauke> it means "type error"
09:50:51 <mauke> you used an 'a' where you need a 'Vector a' or vice versa
09:51:56 <mreh> centers :: (Field a) => [Vector a] -> Matrix a -> [Vector a]
09:51:56 <mreh>     centers xs r = zipWith (/) (toRows $ trans r `multiply` fromRows xs) (map sum (toLists r))
09:52:02 <mreh> i don't think it's that straight forward
09:52:34 <mauke> :t zipWith
09:52:35 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:52:37 <d4mien2> zygoloid in your solution how would I define such a method cost :: (power a b) -> Integer ?
09:52:54 <copumpkin> ooh field
09:53:09 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11377#a11377
09:53:59 <mreh> i'm using zipWith with a function (Vector a -> Vector a -> Vector a) and two lists [Vector a]
09:54:08 <copumpkin> mreh: why not make them functions on their own, without hiding them in a where?
09:54:22 <seanmcl> is there arrow syntax for this function?  (a -> b) -> (a, a) -> (b, b)
09:54:23 <mreh> copumpkin: dunno
09:54:29 <seanmcl> I use first and second for applying a function to one or the other
09:54:35 <copumpkin> seanmcl: join (***)
09:54:46 <seanmcl> copumpkin: great, thanks
09:54:58 <copumpkin> that's not really arrow syntax though
09:54:59 <Saizan_> mreh: can you annotate with the types of the functions you use in that expression? like toLists, toRows, fromRows, trans and multiply
09:55:02 <copumpkin> never used the actual syntax much
09:55:38 <zygoloid> d4mien2: well, you know costOfPower n 0 = 1, and you know costOfPower n k = ...
09:55:40 <Saizan_> or i could just check on hackage maybe
09:55:59 <mauke> what's the type of toLists?
09:56:14 <Saizan_> (but i don't know where they are from)
09:56:26 <mreh> toLists :: Element t => Matrix t -> [[t]]
09:56:31 <d4mien2> zygoloid yes so it should be costPower :: Integer -> Integer -> Integer ? takes two ints and return 1 int with the amount of "steps" ?
09:56:57 <d4mien2> or can I write a function as parameter ?
09:57:13 <mauke> mreh: so map sum (toLists r) :: [a]
09:57:25 <mauke> mreh: but zipWith (/) expects [Vector a]
09:57:55 <mreh> mauke: so why does it give me something about infinite types?
09:58:08 <zygoloid> d4mien2: you could have it take two Integers. or you could observe that you're not actually /using/ 'n' for anything, and reduce it to just taking k
09:58:17 <mreh> Vector has no map or fold implemented on it
09:58:26 <mauke> mreh: because a@(Vector a) is an infinite type
09:58:51 <mauke> which is what's required to make centers typecheck
09:59:18 <mreh> I'm still on the learning curve I think
10:00:00 <d4mien2> zygoloid yes I noticed that. But I get a parse error in pattern now. for my cost (power n 0) = 1
10:00:08 <mauke> mreh: what's the type of (\xs -> if even (length xs) then head xs else tail xs)?
10:00:59 <mreh> impossible to define
10:01:03 <mreh> mauke:
10:01:27 <mauke> if you only look at one branch, it's [a] -> a; if you only look at the other branch, it's [a] -> [a]
10:01:36 <mreh> yah
10:01:44 <mauke> the typechecker concludes from this that a = [a]
10:01:57 <mreh> whaaat
10:02:05 <mreh> it needs fixing
10:02:06 <zygoloid> d4mien2: well yeah, that wasn't code, just exposition :)
10:02:16 <mauke> but then it does an "occurs check", which makes this type illegal
10:02:25 <sm> mauke: thanks for the patch, but darcs 2.3.1 complains bad patch bundle. Any chance I can pull it ?
10:02:29 <mauke> because you can't use a type variable in its own definition
10:02:33 <copumpkin> the type police will take it away
10:02:45 <d4mien2> zygoloid oh I see then I gonna try somethings out
10:03:42 <mauke> sm: http://mauke.ath.cx/rss2irc/
10:03:53 <sm> thanks
10:09:38 <sm> ah! I was simply applying to the wrong repo. Poor error message.
10:12:55 <sm> pushed and deployed, let's see how it works out
10:13:14 <mauke> oh, nice
10:13:28 <copumpkin> yay it's hackagebot!
10:13:55 <sm> courtesy of mauke, hackagebot will announce with ACTIONs, feedback welcome
10:14:25 <c_wraith> who's going to make a release just to demo? :)
10:14:30 <mreh> centers :: (Field a) => [Vector a] -> Matrix Double -> [Vector a]
10:14:30 <mreh>     centers xs r = zipWith (divide) (toRows $ trans r `multiply` fromRows xs) (map sum (toLists r))
10:14:39 <sm> c_wraith: ha, that's the spirit :)
10:15:06 <mreh> this is an improvement on the whole thing, however:  Couldn't match expected type `Vector a'
10:15:06 <mreh>            against inferred type `Double'
10:17:08 <nainaide> :t  Cont $  ( \_ -> 10 )
10:17:09 <lambdabot> forall a r. (Num r) => Cont r a
10:17:21 <nainaide> :t Cont $  ( \s ->s 10 )
10:17:22 <lambdabot> forall a r. (Num a) => Cont r a
10:18:04 <nainaide> What difference between "Cont $  ( \_ -> 10 )"  and "Cont $  ( \s ->s 10 )" ? please
10:18:41 <int-e> > runCont (Cont (\s -> s 10)) succ
10:18:42 <lambdabot>   11
10:18:49 <int-e> > runCont (Cont (\_ -> 10)) succ
10:18:50 <lambdabot>   10
10:19:54 <nainaide> int-e, I am still dont understand.
10:19:58 <Irrelevant> nainaide, (\_ -> 10) would be the same as (\s -> 10), or (const 10)
10:20:02 <int-e> Cont (\_ -> 10) discards the continuation; Cont (\s -> s 10) calls the continuation with 10 as its argument.
10:20:07 <copumpkin> nainaide: the _ ignores the next function
10:20:26 <monochrom> It is unusual to use Cont directly.
10:21:05 <int-e> does Cont . const have a name?
10:21:24 <copumpkin> :t Cont . const
10:21:25 <lambdabot> forall a r. r -> Cont r a
10:21:51 <Badger> @hoogle forall a r. r -> Cont r a
10:21:51 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
10:21:51 <lambdabot> Data.Graph.Inductive.NodeMap delMapNode :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
10:21:51 <lambdabot> Data.Graph.Inductive.NodeMap insMapNode_ :: (Ord a, DynGraph g) => NodeMap a -> a -> g a b -> g a b
10:22:35 <nainaide> thanks you all
10:22:50 <Badger> that result is just confusing.
10:23:18 <int-e> Badger: well, it could be used to model throwing exceptions
10:23:54 <Badger> hoogle is cleverer than me
10:24:15 <int-e> oh. /that/ result.
10:24:35 <int-e> I agree, that's confusing :)
10:25:44 <d4mien2> zygoloid are you still there? I am still having trouble getting it to work, won't compile :/ any other tips to help out a beginner?
10:26:36 <aweber> hi - I'm new to haskell. I want to do different things depending on the type of the parameter (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11378#a11378). is something like that possible?
10:26:58 <mauke> aweber: what would the type of test be?
10:27:55 <eflister> hi, i am trying to make a simple DSL but can't get it to express exactly what i want -- could anyone take a look?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11379
10:28:21 <int-e> test :: Test a => a -> Int ?
10:28:34 <lpjhjdh> aweber: classes let you overload functions based on types
10:28:39 <zygoloid> d4mien2: can you paste what you've got?
10:29:28 <c_wraith> aweber:  If your intention is for different types to do different things, you need to use a typeclass
10:29:35 <d4mien2> zygoloid yes of course. I have tried several different things but one sec I get something together
10:29:50 <zygoloid> hpaste.org is best :)
10:29:59 <Saizan_> though maybe the more idiomatic way would be a sum type in haskell
10:30:06 <Saizan_> data Foo = A | B
10:30:44 <c_wraith> Saizan has a good point.  If you can use one type, it's a good idea.
10:31:37 <aweber> mauke, for all parameter types i want the same return type - in this case Integer - but i thought the return type should not be important as long its the same for all cases
10:32:08 <mauke> aweber: that doesn't look like a type signature
10:32:25 <c_wraith> aweber:  The only way a haskell function can take any type is by not examing the argument.
10:32:39 <c_wraith> *examining
10:33:00 <scree> eflister: heh, it took me a foolishly long time to realize what you were trying to model.
10:33:04 <d4mien2> zygoloid http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11380#a11380
10:33:17 <aeron> so I've got some pattern like this: empty = [], a = someFunc ("test") empty, b = someFunc ("test1") a, c = someFunc ("test2") b
10:33:30 <c_wraith> aweber:  If it's going to examine the argument, it needs to know something about it.  either its concrete type, or a typeclass that it implements.
10:33:37 <eflister> scree: yeah, should be simple, right?  :)  thanks for taking a look, any ideas?
10:33:51 <aeron> what sort of fold does that become with the proper auxillary function?
10:34:20 <zygoloid> d4mien2: if 'costPower n k' is representing the cost of calling 'power n k', then what is 'costPower n k' for k > 0?
10:34:50 <zygoloid> d4mien2: line 8 isn't right
10:35:20 <mshaw> what's a good starting point for someone used to OO languages and who doesn't grok functional programming very well who wants to learn haskell?
10:35:33 <lpjhjdh> aweber: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11378#a11382
10:36:40 <Codex_> mshaw: buy some category theory books.
10:36:55 <zygoloid> mshaw: start by forgetting everything? ;-)
10:37:19 <scree> eflister: what stops you having the whole thing as one monolithic type?
10:37:20 <Jafet> "OO languages" means nothing
10:37:33 <EddyDean> mshaw: I started learning haskell less than a week ago, have used Java and C++ for several years before
10:37:46 <EddyDean> mshaw: Once you grasp the concept it's really not that hard
10:37:49 <Jafet> If a language doesn't allow you to encapsulate things, it's probably worthless anyway
10:37:58 <d4mien2> zygoloid hm ok. yeah it complains about that row. So I need a patter that rather checks if k is bigger then 0 and if it is then dow hat I have on the right side?
10:38:02 * mshaw sighs.
10:38:08 <aeron> Jafet: but if you're not being pedantic, you can probably assume what he means based on what you know of the population of programmers in the world
10:38:09 <mshaw> okay, what's a good starting point to learning haskell?
10:38:24 <geoaxis> Jafet: are you calling Assembly worthless?
10:38:26 <eflister> scree: yeah i started with that, but i needed type flags in there that made it unnatural -- like "Triplet $ DurBase Eighth", etc
10:38:29 <Jafet> Unless by "OO languages" you mean "languages which say they allow you to encapsulate things nicely, but don't"
10:38:31 <zygoloid> d4mien2: no, the stuff on the right-hand side isn't right.
10:38:40 <mshaw> the de facto tutorial, what do you haskell folks recommend
10:38:44 <Jafet> geoaxis, no, I'm calling it probably worthless. Also, which assembly?
10:38:47 <geoaxis> Jafet> language bashing will not get you any where...languages are tools, each has some applications
10:38:49 <zygoloid> d4mien2: ther rest of it is fine
10:38:52 <EddyDean> mshaw: I am learning it from "learn you a haskell for great good" and "real world haskell", both available for free online
10:39:01 <c_wraith> mshaw: same as any other language.  Have a small project that you want to get done, and learn as you go.
10:39:05 <mshaw> EddyDean: thanks, i'll check them out
10:39:10 <aweber> ah all right, thanks a lot :)
10:39:17 <geoaxis> Jafet: the one which was probably involved at some point when you lovely haskell compiler was made
10:39:35 <sshc> mshaw: first read http://learnyouahaskell.com/
10:39:40 <geekiac> i am trying to do a cabal install hdbc-odbc and it gives me an error when trying to compile Database.HDBC.SqlValue.  Can anyone suggest where I would look to try and sort out the problem?
10:39:49 <Jafet> No Haskell compiler I know of is written in any assembly language.
10:39:53 <sshc> mshaw: and then Real World Haskell; my suggestion
10:39:55 <d4mien2> zygoloid oh I see.
10:40:04 <geoaxis> Jafet: there is a quote, when you have a hammer in your hand, every thing looks like a nail
10:40:12 <scree> eflister: where DurBase in that context is a constructor, right?
10:40:14 <mshaw> sshc: excellent, thank you as well
10:40:16 <c_wraith> mshaw: also, this channel is a great resource for answering questions about any problems you run into.
10:40:24 <eflister> scree: right
10:40:25 <geoaxis> working in haskell does not mean that all other languages are crap
10:40:29 <Jafet> geoaxis, there is a quote, I did your mom.
10:40:30 <geoaxis> each has its place
10:40:55 <geoaxis> Jafet: this attitide will get you no where in haskell community btw
10:41:02 <scree> eflister: so, if that's unnatural then I'm no longer sure what you're trying to achieve.
10:41:03 <aeron> Jafet go back to #trolls :/
10:41:05 <d4mien2> zygoloid don't have the functional thinking, have only programmed OO languages. this is pretty tricky even though this particular exercise should be easy.
10:41:07 <Codex_> mshaw: One good book I've read was: "Algorithms, a functional programming approach".
10:41:58 <eflister> scree: well it seems like the approach in the hpaste avoids needing to flag everything with that constructor, if i could get it to work (and it seems like it should)
10:42:09 <mshaw> Codex_: thank you, noted
10:42:11 <zygoloid> d4mien2: i think the thing to keep in mind is what the semantics of your functions should be. costPower n k is the cost of running power n k
10:42:32 <zygoloid> d4mien2: so for k > 0, costPower n k is 1 + the cost of running power n (k-1)
10:42:45 <Jafet> aeron, I didn't come from #trolls
10:42:58 <Aviator> is there a way to bundle all required *.so files along side with my executable to a remote linux system? (ghc)
10:43:46 <Jafet> Aviator, sounds like nothing to do with Haskell; use ldd
10:43:47 <eflister> mshaw: refer to the typeclassopedia frequently, otherwise the myriad nearly synonymous functions and class distinctions are hard to keep straight
10:44:22 <geekiac> Does anyone know where I can go for help if a cabal install won't compile?
10:45:30 <d4mien2> zygoloid yes I get that and I can tell myself the anser by doing it on papper but I can't get the in the place in the haskell code. so frustraing
10:45:39 <d4mien2> frustrating
10:45:43 <aavogt> geekiac: cabal install itself, or some package (both of which you can ask about here)
10:46:01 <zygoloid> d4mien2: well, remember that 'the cost of running power n (k-1)' is costPower n (k-1)
10:46:11 <mshaw> eflister: bookmarked, thanks
10:47:26 <eflister> i'd like to have something like this: data ModDur = (NoteDur x => Dotted x) | Triplet DurBase  -- where instance NoteDur ModDur  -- anyone know why this doesn't work or a way to achieve the equivalent?
10:48:59 <eflister> this would be fine too, but also doesn't work:  data ModDur = Dotted DurBase | Dotted ModDur | Triplet DurBase
10:49:04 <sinelaw> Peaker, hey
10:50:18 <d4mien2> zygoloid hm but in my pattern I should only write costPower n 0 and not like costPower power n 0 right?
10:51:15 <tavelram> @src (.)
10:51:15 <lambdabot> (f . g) x = f (g x)
10:51:20 <zygoloid> eflister: your first one can be written as: data ModDur = forall x. NoteDur x => Dotted x | ...
10:51:34 <zygoloid> eflister: but you need -XExistentialQuantification for that
10:51:54 <eflister> zygoloid: great, i thought existentials should work but couldn't figure them out -- i'll try it...
10:52:16 <eflister> zygoloid: why isn't the quantification implicit?
10:52:44 <zygoloid> eflister: because it usually indicates a typo i guess
10:53:30 <zygoloid> eflister: what doesn't work in the second example?
10:53:43 <scree> eflister: see hpaste
10:54:07 <scree> eflister: two things: your existential type needs the quantifier *before* the constructor, not after
10:54:32 <Aviator> crap..
10:54:35 <geekiac> aavogt: The package is hdbc
10:54:42 <scree> eflister: and you then can't use the record syntax very much, because "dur" escapes existential context.
10:55:01 <d4mien2> zygoloid coule you be kind to give the right solution so I can learn from it by seeing how it should be done in haskell. I understand what I want to do but can't get it to work. been trying for a long time now.
10:55:11 <scree> eflister: I would personally then instantiate Note as NoteDur to avoid having to access the contents ever again
10:55:12 <Aviator> how do i statically link my program? it seems that ghc never finds static libraries from my system
10:55:19 <zygoloid> d4mien2: costPower n k = 1 + costPower n (k-1)
10:55:43 <geekiac> avvogt:  There is an error log on the Hackage pages at http://hackage.haskell.org/packages/archive/HDBC/2.1.1/logs/failure/ghc-6.10
10:59:08 <d4mien2> zygoloid thanks, I really appriciate it. is there a way I could define costPower to take in power n k insteed of costPower n k ? like costPower :: (power n k) -> Integer
10:59:11 <Aviator> wait, i think i got it
11:00:07 <zygoloid> d4mien2: "power n k" would be a value rather than a type
11:01:26 <Jafet> What's costPower?
11:01:29 <d4mien2> zygoloid ah ok.
11:01:36 <d4mien2> Jafet and exercise I am doing
11:01:52 <d4mien2> Jafet to compute how many computing unite the power function takes
11:02:01 <Jafet> Define it.
11:02:30 <d4mien2> Jafet http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11387#a11387
11:03:34 <Jafet> Ok, so what's the problem?
11:04:32 <eflister> zygloid and scree: interesting, thx, that worked.  using the existential means i can't derive eq or show.  losing the record syntax seems a bit extreme, in reality Note has has a lot of other fields and i access them frequently...
11:06:22 <d4mien2> Jafet the one I posted to you works, zygoloid helped me out. But the assigment was to create that costPower and I have only been doing haskell for 1 week so couldn't get it to work
11:06:47 <scree> eflister: so, losing Eq is fair enough.  You're potentially asking it to compare two very different types underneath the wrapper.
11:07:39 <scree> eflister: as for the record syntax, you can still have it, but you just can't use the accessor for the forall'ed type very much
11:08:26 <scree> eflister: (which is ok if you have the typeclass instance to deal with that automatically)
11:11:04 <eflister> scree: i added another field to Note and that's wrecked it -- it now thinks pattern matches on Note should have two arguments?  why do existentials wreck records?
11:16:22 <jre2> @pl save ps = printCSV $ map p2r ps
11:16:22 <lambdabot> save = printCSV . map p2r
11:19:39 <jre2> @pl save ps = write
11:19:40 <lambdabot> save = const write
11:20:07 <scree> eflister: if you add another record, the pattern match will change; it's just like adding another term to the constructor.  Existentials "wreck records" in so far as the function dur has type Note -> (forall x. NoteDur x => x) which means that whenever you use it, the compiler has no idea what the type of the answer is, so complains.
11:25:31 <eflister> scree: huh, it seems like it should be enough to know that it will be specified by the type of the dur field of the argument.  i got the pattern to work, but it's not reasonable to require that it have n arguments when Note has n fields -- is there a more natural approach that a haskell native would take?  :)
11:27:22 <scree> eflister: if you want to do it this way, personally I'd leave Note as it was (or give it another name, like Dur) and make Dur a field of Note
11:28:03 <scree> eflister: it's encapsulating one concept, namely "has a duration and I don't care what else"
11:28:17 <eflister> scree: oh that would work, i'll try it.  is there a totally different approach that occurs to you (you seem to imply that...)?  :)
11:28:54 <monochrom> f Note{dur=x} = x+1 ?
11:30:16 <eflister> monochrom: huh, i didn't know a pattern could look like that
11:30:35 <scree> monochrom: good point :)
11:31:10 <scree> eflister: as you ask, I'd still have gone with the monolithic type in the first place if it were me
11:31:30 <monochrom> I heard GHC 6.12 has an even sweeter syntax for that, so you don't even need to invent the name "x".
11:31:43 <scree> eflister: you're paying a bit of a price just to eliminate an extra constructor
11:31:54 <scree> monochrom: what do you type?
11:32:12 <monochrom> In fact GHC 6.10 too. In a minute... or you can look for "record puns"
11:32:30 <eflister> scree: i see your point.  in this case i'm striving for as natural a DSL as possible, and don't mind uglier plumbing...
11:32:36 <monochrom> f Note{dur} = dur+1  in GHC 6.10
11:33:05 <copumpkin> yeah, or you can do f Note{..} = dur + 1
11:33:20 <scree> cool.
11:33:20 <copumpkin> with -XRecordWildcards enabled
11:33:36 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-puns "record puns" and then the next section "record wildcards" too.
11:33:44 <monochrom> This is indeed very wild.
11:34:19 <monochrom> Oooohhhh, local fixity declarations! I need exactly that! (Unrelated note.)
11:34:42 <eflister> hmm, i'm on 6.10.3 and got unsupported extension: RecordWildcards
11:34:51 <Peaker> sinelaw, hey
11:35:09 <eflister> maybe copumpkin wasn't talking about 6.10
11:35:26 <monochrom> Perhaps 6.10.4 then. I'm just looking at the official current manual.
11:35:39 <monochrom> (I haven't even used 6.10.x!)
11:35:55 <copumpkin> eflister: that might not be the exact name... GHC should do an edit distance for language extensions and suggest corrections
11:36:17 <ve> I seem to be unable to get the SIGPIPE/openEndedPipe signal from a closed pipe created using System.Posix.IO.createPipe. Say if I start shell with a command that doesn't exist, it just hangs the program until the process is killed. "setFdOption nonBlockingRead True" does nothing either.
11:36:40 <copumpkin> eflister: RecordWildCards for some reason
11:36:43 <copumpkin> uppercase C
11:36:43 <monochrom> capitalize C in Cards
11:36:55 <eflister> copumpkin: ha ha, yeah, i took out the pragma but on a whim left in the {..} to see what would happen and it said to put the pragma back in.  :)  (RecordWildCards)
11:36:57 * copumpkin is annoyed very often by the naming of language extensions
11:37:24 <monochrom> This is the problem with camelcasing. There is no consensus on word boundaries. Just ask an English and a German.
11:37:38 <copumpkin> well not only that
11:37:43 <copumpkin> also some things are randomly abbreviated
11:37:49 <copumpkin> while other things are extremely verbose
11:37:52 <eflister> why doesn't it just tolower everything?
11:38:03 <copumpkin> EmptyDataDecls vs. ExistentialQuantification
11:38:14 <Twey> monochrom: I don'tagreewiththat!
11:38:22 <copumpkin> eflister: that would be smart, eh
11:38:33 <hgolden> copumpkin: Life little mysteries?  ;-)
11:38:33 <m0nkfish> is Ord a subset of Eq
11:38:34 <monochrom> Perhaps "existential quant" has a bad connotation because it mentions quants.
11:38:46 <Twey> m0nkfish: No
11:38:49 <hgolden> s/Life/Life's/
11:38:51 <desp> Does anyone know if the Clarion package presented in Jerzy Karczmarczuk's paper "Functional Framework for Sound Synthesis" (www.haskell.org/jcp/sound.pdf) is available anywhere?
11:38:54 <copumpkin> m0nkfish: possible Ord instances are a subset of possible Eq instances
11:39:39 <Twey> I don't think so
11:39:56 <Twey> It's not necessary to implement Eq to return EQ from compare
11:40:12 <Twey> @info Ord
11:40:13 <lambdabot> Ord
11:40:13 <m0nkfish> you can derive eq by saying not < and not >
11:40:27 <Twey> m0nkfish: Not necessarily
11:40:37 <m0nkfish> counterexample?
11:40:37 <copumpkin> Twey: Eq is a superclass of Ord
11:40:42 <Twey> m0nkfish: Is 3i greater than, less than, or equal to 2?
11:40:43 <copumpkin> @src Ord
11:40:43 <lambdabot> class  (Eq a) => Ord a  where
11:40:43 <lambdabot>     compare      :: a -> a -> Ordering
11:40:43 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
11:40:43 <lambdabot>     max, min         :: a -> a -> a
11:40:50 <Twey> copumpkin: Oh, okay
11:40:55 <aavogt> > let f :: Ord a => a -> a -> Bool; f = (==) in f 1 2
11:40:57 <lambdabot>   False
11:41:05 <monochrom> "class  (Eq a) => Ord a  where" already determines the answer. Malicious implementations are beside the point.
11:41:06 <Twey> I tried looking that up on my local GHCi, but got swamped with instances :þ
11:41:18 <copumpkin> :)
11:41:30 <scree> eflister: we clearly need the possibility for RandomExtention and RanDomExtention to be different
11:41:33 <m0nkfish> thanks copumpkin
11:41:49 <m0nkfish> trey perhaps next time dont jump the gun ^_^
11:42:10 <eflister> scree: :)
11:42:13 <copumpkin> in theory he's right
11:42:13 <aavogt> copumpkin: well I think it's worse when they go renaming those extensions
11:42:19 <monochrom> Next time "is Monad subset of Functor" will be more interesting!
11:42:40 <copumpkin> a monad IS a functor!
11:42:59 <aavogt> but a Monad is not a Functor
11:43:09 <copumpkin> aavogt: why not keep a list of common variations and accept all of them?
11:43:16 <monochrom> This time malicious implementations matter.
11:43:17 <chaosape> could i use template haskell to programmatically creat fields in a record?
11:43:29 <Twey> Heh
11:43:37 <copumpkin> this is where we need dependent types to prevent malicious instances
11:43:58 <copumpkin> "a monad is a functor, two natural transformations, and a few proofs"
11:44:02 <aavogt> chaosape: yes, but how are you going to decide what they are neamed?
11:44:08 <EvilTerran> we should identify extensions by GUIDs :P
11:44:16 <copumpkin> EvilTerran: AARRGHH!!H!
11:44:22 <copumpkin> :)
11:44:26 * Twey laughs.
11:44:34 <Twey> Does an Ord instance for Complex make sense, in fact?
11:44:44 <aeron> how does something like Parsec do backtracking effeciently?
11:44:44 * copumpkin is reminded of writing a FireFox extension
11:44:49 <c_wraith> Twey: Not in the traditional meanings
11:44:54 <copumpkin> Twey: sure, but it might not make intuitive sense
11:45:15 <Twey> There doesn't seem to be one in Data.Complex
11:45:18 <copumpkin> yeah
11:45:23 <scree> Twey: you can order by magnitude of you want to
11:45:31 <scree> but then a = b doesn't mean a = b ...
11:45:32 <monochrom> No Ord for Complex will satisfy ordered field axioms.
11:45:33 <Codex_> hom(AxB,C) == hom(B,hom(A,C)) ?
11:45:36 <aavogt> same way we have (Ord a, Ord b) => Ord (a,b)
11:45:38 <Twey> Yeah…
11:45:44 <chaosape> aavogt: through a list? All strings in a list become a field?
11:45:45 <copumpkin> monochrom: luckily for us, Ord has no "laws"
11:46:05 <Twey> It obviously makes sense to say that 3 :+ 0 < 4 :+ 0
11:46:07 <monochrom> Correct, you could still do Ord.
11:46:10 <Jafet> aeron, you can memoize recursive parsers, but I don't know how parsec is specifically implemented
11:46:14 <aavogt> chaosape: and they all have the same type, or one you provide?
11:46:57 <copumpkin> did anyone miss the safe sex makespan on proggit?
11:46:59 <aeron> Jafet: in short I'm doing recursive descent in a list, and if I encounter a certain case, i need to effeciently backtrack up to where the conflicting item is, make a change in how that item is processed, then go back down
11:47:00 <monochrom> compare (3:+4) (4:+3) = ?
11:47:09 <copumpkin> monochrom: EQ!
11:47:10 <copumpkin> :P
11:47:19 <copumpkin> we have nice circular equivalence classes
11:47:27 <chaosape> chaosape: I provide.  So that someone who wants to extend has a consistent scoped(in terms of amount of code they have to change) interface.
11:47:38 <Jafet> That sounds possibly inefficient
11:47:40 <aavogt> copumpkin: but don't things like Data.Map require Ord instances to be to be transitive?
11:47:48 <aavogt> chaosape: yeah, it can be done
11:47:52 <copumpkin> aavogt: dunno, probably :)
11:48:27 <monochrom> parsec backtracks the naive way, when it backtracks. no tricks.
11:48:31 <chaosape> aavogt: talking to myself.  that was meant to go to you.   Do you know where I could find an example of doing that?
11:48:31 <aeron> Jafet: i'm not sure how else to approach it; basically, if I run into an ambiguous case, I just have to assume one of two possibilities, and later on if that choice happens to cause a conflict, I need to backtrack to that decision, do it the other way, and keep going
11:48:35 <monochrom> Ooohhhh tricks!
11:48:42 <Jafet> What monochrom said, then
11:48:52 <copumpkin> how's tricks?
11:48:58 <Jafet> You could do it nondeterministically!
11:49:00 <monochrom> parsec treats backtracks the naive way, when it treats backtracks. no tricks.  (hahaha)
11:49:03 <aeron> the only easy way i can think of doing it is holding onto the state each time I hit an ambiguous case
11:49:41 * scree wants data Foo deriving WellOrdering
11:49:43 <idnar> @type (:+)
11:49:44 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
11:49:55 <monochrom> anyway, this is why parsec makes you write extra code to ask for backtracking, e.g., you have to say "try".
11:49:59 <Alpounet> copumpkin, the safe sex span is a very nice read :-)
11:50:02 <copumpkin> :)
11:50:07 <Alpounet> makespan*
11:50:08 <aeron> monochrom: alright, thanks
11:50:47 <Alpounet> I'm surprised it's been on WP though.
11:51:16 <monochrom> If x doesn't backtrack by itself, and y doesn't backtrack by itself, then x<|>y doesn't backtrack by itself. To ask for backtracking in case x fails, you have to write  try x <|> y
11:51:19 <_Ray_> Hey. I'm trying to install hat on OS X via DarwinPorts. It fails compilation, and just before, it warns it can't find System.Console.Readline. How can I install this on OS X? It says it needs libreadline?
11:51:36 <copumpkin> _Ray_: darwinports??? when did you last update? :P
11:51:45 <_Ray_> Installed it today
11:51:48 <_Ray_> (And for this)
11:52:04 <copumpkin> Alpounet: lots of weird and random things on wikipedia :)
11:52:15 * hackagebot upload: uhexdump 0.2.2 - hex dumper for UTF-8 text (EricKow)
11:52:18 <Alpounet> heh yeah
11:52:35 <lpjhjdh> _Ray_: ghci has a debugger now too
11:52:36 <sinelaw> @hoogle [Char] -> ByteString
11:52:36 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
11:52:36 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
11:52:36 <lambdabot> Prelude error :: [Char] -> a
11:52:53 <_Ray_> lpjhjdh, yeah, but it doesn't show reductions, which is what I want it for
11:52:56 <mauke> success.
11:53:49 <copumpkin> win.
11:54:59 <aavogt> chaosape: not really, there are a bunch of TH tutorials, but I'm not sure they directly cover that stuff
11:55:36 <m0nkfish> how can i have multiple "where" clauses
11:55:38 <m0nkfish> what is the syntax
11:55:44 <sinelaw> is the author of PerfectHash here?
11:55:53 <copumpkin> who's the author?
11:56:04 <sinelaw> don't remember, we talked two days ago though
11:56:11 <copumpkin> @hackage perfecthash
11:56:11 <lambdabot> http://hackage.haskell.org/package/perfecthash
11:56:21 <copumpkin> mwotton
11:56:22 <sinelaw> Mark Wotton
11:56:24 <copumpkin> or blackdog
11:56:29 <mauke> m0nkfish: what's the point?
11:56:33 <sinelaw> copumpkin, thanks
11:56:48 <aavogt> chaosape: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11389#a11389
11:56:59 <sinelaw> blackdog, doesn't Perfect implement Binary?
11:57:19 <mmmdonuts> Small brainteaser: is there any simpler or more standard way to write this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11388
11:57:25 <aavogt> so you want to generate something like that [DataD ...], with your names and types provided as arguments to a function.
11:57:37 <m0nkfish> mauke what i mean is i want to bind multiple 'variables' so i dont have to perform the calculations twice
11:58:00 <mauke> m0nkfish: ok, but why use multiple "where"s?
11:58:10 <m0nkfish> i dont need to use multiple "where"
11:58:16 <m0nkfish> i just dont know how to do two variables
11:58:20 <chaosape> aavogt: Rock! Thats exactly what I needed!
11:58:22 <m0nkfish> whats the delimiter
11:58:29 <mauke> m0nkfish: newline, usually
11:58:29 <aavogt> then to actually run that ([String] -> Q [Dec]), you'd write it as $(functionName listOfFields)
11:58:33 <m0nkfish> colon? semicolon? pipe?
11:58:38 <m0nkfish> oh with indentatino?
11:58:47 <Twey> Semicolon
11:58:55 <Twey> (newline is equivalent)
11:59:07 <aavogt> and by running, I mean to get TH to dump the actual code in your module
11:59:12 <Twey> > let a = 5; b = 6 in a + b
11:59:13 <lambdabot>   11
11:59:29 <Twey> > let { a = 5; b = 6 } in { a + b }
11:59:30 <lambdabot>   <no location info>: parse error on input `{'
11:59:33 <Twey> > let { a = 5; b = 6 } in a + b
11:59:34 <lambdabot>   11
12:00:01 <hqm42> hi! i cant figure out how to multiply an Integer with something like (sqrt 2) having an Integer as result
12:00:20 <hexpuem> fromxxx
12:00:21 <Twey> hqm42: You can't, because you don't end up with an Integer
12:00:35 <Twey> hqm42: Convert your Integer to a floating type, then round
12:00:47 <ray> > 3 * (sqrt 2)
12:00:47 <newsham> ?seen jfredett
12:00:48 <lambdabot> Unknown command, try @list
12:00:48 <lambdabot>   4.242640687119286
12:01:06 <ray> > fromIntegral (3 :: Integer) * (sqrt 2)
12:01:07 <lambdabot>   4.242640687119286
12:01:15 <Twey> > let int = 3 :: Integer in round $ sqrt 2 + fromIntegral 3
12:01:16 <aeron> how can I sort a Data.Set of (Int, Int)s?
12:01:16 <lambdabot>   4
12:01:28 <Twey> aeron: Sets are unordered
12:01:37 <Twey> If you want order, use the toList function
12:01:50 <Gracenotes> cough Data.Ord
12:01:54 <Twey> You can sort that with ‘sort’ if it's not already ordered when it comes out
12:02:04 <_Ray_> That fixed it :) cabal install readline --extra-include-dirs=/opt/local/include --configure-option=--with-readline-includes="/opt/local/include" --configure-option=--with-readline-libraries="/opt/local/lib". Enormous line.
12:02:14 <hexpuem> is reverse . sort still O(n)
12:02:31 <Twey> I don't think so
12:02:50 <Gracenotes> O(n lg n), you mean? you might want to do sortBy (flip compare), in that case
12:02:58 <Twey> It has to sort all the way through first to find the last element, you see
12:02:59 <newsham> sort isnt O(n)
12:03:05 <newsham> reverse probably is
12:03:06 <Gracenotes> both with a lg n factor
12:03:17 <m0nkfish> could someone help me out here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4544
12:03:26 <Gracenotes> sort by itself just just sortBy compare. so flip it
12:03:33 <aeron> what's the big-O for toList/fromList for Data.Set, n?
12:03:33 <hexpuem> yea
12:03:37 <hexpuem> diddnt think of flip
12:03:49 <copumpkin> aeron: O(n)
12:03:52 <aeron> kk
12:03:56 <copumpkin> where n is the number of elements in the map, obviously :)
12:04:05 <m0nkfish> am i thinking in the right paradigm
12:04:10 <m0nkfish> im not so good with infinite lists :/
12:04:11 <Gracenotes> fromList is O(n lg n). There are other methods that take advantage of ordering in the list, which are O(n)
12:04:13 <hqm42> this is what i get: No instance for (Floating Integer)
12:04:25 <Twey> hqm42: You did it wrong
12:04:37 <Twey> > let int = 3 :: Integer in round $ sqrt 2 + fromIntegral int
12:04:38 <lambdabot>   4
12:04:40 <copumpkin> oh I missed the fromList question
12:04:42 <Twey> Like that
12:04:43 <copumpkin> I saw toList :P
12:04:48 <copumpkin> fromAscList will be O(n)
12:04:51 <Gracenotes> m0nkfish: what is the problem?
12:04:53 <newsham> fwiw, the Data.Set documentation says how expensive the ops are (http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html)
12:05:04 <copumpkin> newsham is back!
12:05:05 <Gracenotes> at least, in terms of scaling
12:05:23 <newsham> copumpkin: just temporarily decloaking
12:05:26 <copumpkin> :)
12:05:29 <m0nkfish> well, if i do say "take 5 hamming" it jams up
12:05:34 <m0nkfish> i guess its just going in infinite loops
12:05:39 <m0nkfish> but i dont know how to code around it
12:05:48 <m0nkfish> are there tutorials on this kind of thing
12:05:48 <newsham> not writing a lot of haskell at the moment (wrote a little earlier this month)
12:05:50 <Gracenotes> m0nkfish: something to note is that foldl won't work on infinite lists
12:05:52 <sinelaw> holy crap. my program just printed:
12:05:52 <sinelaw> Dying horribly, hash is null
12:06:01 <copumpkin> sinelaw: sweet
12:06:06 <m0nkfish> oh well it shouldnt be used on infinite lists in that sense
12:06:14 <newsham> copumpkin: functor is a verb now?
12:06:25 <m0nkfish> it operates on a finite number of potentially infinite lists
12:06:27 <copumpkin> newsham: indeed! much has changed since you were last here
12:06:28 <newsham> (I hardly know'or)
12:06:29 <m0nkfish> (should do)
12:06:45 <hqm42> nice! thank you! fromIntegral saved the day ^^
12:06:46 <sinelaw> I think I'll give up on using PerfectHash
12:06:48 <Gracenotes> hm... let me see where these infinite lists are actually used
12:07:20 <newsham> haskell is noticeably absent in android.  i'm just saying, thats all.
12:07:31 <newsham> jvm anyone?
12:07:33 <copumpkin> newsham: fix that!
12:07:41 <newsham> my plate runneth over
12:08:14 <Gracenotes> implementing STG in JVM... hm... well, it is primarily stack based. there are no general purpose registers though.
12:08:34 <copumpkin> haskell doesn't have to go through STG :o
12:08:37 <m0nkfish> Gracenotes: the idea is that combine [[a]] will take a list of sorted (ascending) lists and chop their heads off, get the lowest head, then throw away any other heads that are <= the chosen head
12:08:39 <Gracenotes> i.e. a stack machine
12:08:43 <stoop> Weird compilation error, any advice? http://tinyurl.com/panic292
12:08:58 <tavelram> there are already (a few?) jvm-implementations...
12:09:00 <copumpkin> stoop: ahem
12:09:08 <Gracenotes> copumpkin: that is quite true. but better for it not to be just an interpreter
12:09:20 <newsham> co'kin: but w/o stg, you dont have the defact haskell standard, ghc.
12:09:29 <hexpuem> you can use scala for android dev i heard
12:09:34 <newsham> yes
12:09:51 <Gracenotes> copumpkin: there is a GHC bias around (for a good reason), and I am not sure how other major Haskell compilers, uh, manage operational semantics
12:10:20 <eflister> would there be a way to get 'join (***)' to work existentially?
12:10:36 <copumpkin> eflister: meaning?
12:10:43 <copumpkin> eflister: to allow the two sides of it to be of different types?
12:10:55 <eflister> right, but both members of a class
12:11:01 <copumpkin> you could write it yourself
12:11:07 <copumpkin> join is going to force them to be of the same type
12:11:17 <eflister> yeah
12:11:29 <copumpkin> actually it may be harder than that
12:11:43 <Gracenotes> m0nkfish: hm. is there a particular point where it doesn't freeze?
12:11:50 <copumpkin> actually no
12:12:12 <eflister> copumpkin: no, it can't even be written?
12:12:18 <m0nkfish> gracenotes: when it crashes :)
12:12:26 <Gracenotes> well, input value
12:12:34 <Gracenotes> I see..
12:12:36 <m0nkfish> finite lists
12:12:39 <copumpkin> eflister: no, my objection is unfounded
12:12:39 <Gracenotes> it doesn't even return a constructor
12:12:56 <eflister> copumpkin: well that seems to be the problem at the moment...
12:13:01 <copumpkin> @type let both (f :: forall a. Num a => a -> a) (x, y) = (f x, f y) in both
12:13:02 <lambdabot> forall t t1. (Num t, Num t1) => (forall a. (Num a) => a -> a) -> (t, t1) -> (t, t1)
12:13:02 <m0nkfish> oh yeah it should return a constructor shouldnt it
12:13:15 <m0nkfish> ill have another go
12:13:22 <copumpkin> eflister: needs rank-2 types though
12:13:50 <eflister> compumpkin: i was going to call it both too.  :)  why did you say unfounded?
12:14:01 <copumpkin> at first I thought it wasn't possible
12:14:09 <copumpkin> but then I remembered rank-2 polymorphism :)
12:14:32 <copumpkin> however, it can't be general
12:14:34 <eflister> copumpkin: hm, does it need to be class specific?
12:14:37 <copumpkin> yeah :/
12:14:44 <copumpkin> you can't say "for all classes"
12:14:53 <copumpkin> I'd very much like that on the type of the on function too
12:15:05 <sinelaw> why does HashTable use IO??
12:15:15 <copumpkin> sinelaw: because HashTables aren't persistent
12:15:23 <copumpkin> sinelaw: why not just use Data.Map or IntMap?
12:15:32 <Gracenotes> monochrom: I do mean more that it doesn't say whether the list has any elements or not
12:15:38 <Gracenotes> er, @m0nkfish, sorry
12:15:45 <copumpkin> m0n0chr0m
12:15:47 <sinelaw> copumpkin, i will, but i don't understand why you mean
12:16:08 <copumpkin> sinelaw: updating a hashtable doesn't keep the old hashtable around, unlike most functional datastructure
12:16:08 <copumpkin> s
12:16:28 <sinelaw> copumpkin, so it's mutable
12:16:44 <copumpkin> yeah, so we stick mutable things in IO or ST
12:16:48 <eflister> copumpkin: yeah isn't it common to want higher order polymorphism?  why wouldn't this be something haskell would emphasize?
12:16:49 <copumpkin> because we can't have mutable pure values
12:16:53 <m0nkfish> Gracenotes: i figured a far easier way to do it, akin to prime sieves :)
12:17:17 <copumpkin> eflister: it is, but this is slightly different
12:17:30 <sinelaw> copumpkin, ok, i didn't know it's mutable
12:17:33 <Jafet> Hash tables can't be persistently implemented in Haskell, barring unsafePerformIOAndIReallyNeedIt
12:17:38 <copumpkin> eflister: it goes back to the fundamental difference between let and case
12:18:01 <eflister> copumpkin: er, huh?
12:18:26 <copumpkin> eflister: most of the haskell you use and write is reduced down to a bunch of let expressions and case expressions
12:18:56 <copumpkin> eflister: they're sort of like the fundamental building blocks of it
12:19:07 <Gracenotes> m0nkfish: ah.. I'm trying to see what's wrong in the first place
12:19:26 <m0nkfish> i think lots of things
12:19:27 <eflister> copumpkin: but it definitely doesn't seem ambiguous to want to operate on an f that has class constraints, and let those dynamically propagate to the arguments
12:19:45 <Jafet> Well, let does substitution and case does control. In theory you don't need more
12:19:59 <m0nkfish> the function has to return a constructor in the case of infinite lists
12:20:10 <copumpkin> eflister: oh, you mean a "for all classes"? yeah, I'd very much like that, but surprisingly it doesn't really come up that often
12:21:03 <Gracenotes> m0nkfish: ah, right. I've made it step-by-step, and I can see that although res is getting built, you never actually see it. the problem is, incidentally, that combineaux uses an accumulator like foldl. And foldl doesn't work on infinite lists :)
12:21:20 <Gracenotes> @src foldl
12:21:20 <lambdabot> foldl f z []     = z
12:21:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:21:49 <mreh> :t minimumBy
12:21:50 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
12:21:52 <Gracenotes> you see, res is the accumulator z, and (x:xs) is the list of infinite strings
12:21:58 <mreh> @info minimumBy
12:21:58 <lambdabot> minimumBy
12:22:05 <mreh> interesting
12:22:09 <Gracenotes> list of list of infinite ints, rather
12:22:41 <tommd> Each Int is infinite?
12:22:54 <Gracenotes> list of infinite lists of ints
12:22:58 <Gracenotes> @type \f xs -> minimumBy (comparing f) xs
12:22:59 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
12:23:41 <drhodes> I just called a haskell function from python \o/
12:24:08 * drhodes prances around like homer in a doughnut shop
12:24:59 <Gracenotes> now, back to Haskell on JVM, the problem isn't making a semantically sound Haskell, but rather integrating many many things that were built around GHC-specificity
12:25:02 <tavelram> drhodes, ffi or in java? eg jaskell and jython?
12:25:09 <lpjhjdh> is there a wiki page or something with a timeline for TH functionality in ghc?
12:25:19 <tavelram> Gracenotes, what about compiling ghc into jvm as an architecture?
12:25:41 <tavelram> Gracenotes, then you only need to replace some c-bits and perhaps some asm-bits.
12:25:56 <drhodes> tavelram: ffi, through a c extension calling dlopen on a haskell .so
12:26:03 <tavelram> ok
12:26:43 <Gracenotes> tavelram: that does sound interesting. it is mostly the low-level primitive stuff where modifications would have to be made -- and these low-level things are not just relevant to the back-end
12:27:07 <sinelaw> why do I get "stack overflow" when trying to load (with Binary) a Map from a file?
12:27:13 <Gracenotes> I suppose Language.C could go straight through Java's FFI, as well. who knows.
12:27:52 <tavelram> yeah jni or something.
12:28:14 <tavelram> you'd /could use jni to speed up your android app as well
12:28:36 <tavelram> Gracenotes, that was your reason for this, right?
12:28:38 <copumpkin> sinelaw: ugh, yeah
12:28:42 <_Ray_> Hey. How could I use cabal to install Data.PackedString? "cabal install Data.PackedString" doesn't work :(
12:28:53 <copumpkin> _Ray_: why do you need packedstring?
12:28:54 <Gracenotes> I'm not sure about the state of JNI on Android, though
12:29:01 <_Ray_> copumpkin, to install Hat
12:29:14 <Gracenotes> tavelram: well, someone else brought up Haskell on the Android
12:29:15 <tavelram> Gracenotes, google used jni in their youtube-materials
12:29:19 <tavelram> oh, ok
12:29:28 <tavelram> -s
12:29:35 <Gracenotes> making it a sane JVM language would be the precursor
12:29:45 <mreh> what's the difference between: snd $ minimumBy (compare `on` fst) (zip xs [0..])
12:29:49 <tavelram> Gracenotes, have you looked at jaskell, jhaskell and whatever their called?
12:29:52 <mreh> and snd . minimumBy $ (compare `on` fst) (zip xs [0..])
12:30:02 <mreh> is it typing?
12:30:13 <sinelaw> I'm lost. Parsing the text file into a Map takes forever, and loading the map using Binary gets a stack overflow
12:30:23 <Gracenotes> tavelram: not in detail
12:30:29 <sinelaw> what can i do?
12:30:30 <drhodes> _Ray_: looks like it's $ cabal install packedstring
12:30:43 <_Ray_> Thanks :) It finds the module automagically?
12:30:46 <lpjhjdh> oh, does anyone have a copy of john hughes ideas regarding dependent types in haskell?
12:30:51 <tavelram> Gracenotes, iirc they are missing some things to fully support haskell98, so perhaps you should give those missing parts a peek before you start, so that you know what caused problems in those projects..
12:30:57 <dancor> why are (immutable non-strict) arrays bad again?  ppl seem to always recommend Map over them
12:30:58 <lpjhjdh> the one on the wiki is a dead link :(
12:31:01 <Gracenotes> as I said, it would be simple enough to write something with acceptable Haskell semantics. it's the libraries that regularly rely on dark corners of GHC.
12:31:03 <tavelram> if you aren't compiling ghc that is
12:31:50 <monochrom> immutable non-strict arrays are good! I always recommend it for dynamic programming.  http://www.haskell.org/haskellwiki/Dynamic_programming_example
12:31:54 <tavelram> Gracenotes, Ive been thinking of writing a haskell->(real/actual) java code, and do the same for haskell->python.
12:32:01 <Gracenotes> dancor: they can be useful for dynamic programming if you don't modify them
12:32:13 <dancor> monochrom: what about for a multidimensional tensorish data structure
12:32:19 <monochrom> people recommend Map because the askers ask for associative memory.
12:32:28 <tavelram> Gracenotes, not haskell->scala though - since one of the reasons for the haskell->java project was to use google web toolkit, and that operates on java and not jvm...
12:33:20 <tavelram> so the haskell->java is more like a syntax change into haskell, and probably loosing lazy evaluation etc in that specific sense.
12:33:36 <impl> how can you run on Java but not the JVM?
12:34:01 <tavelram> impl, it parses the java-code and operates on that.
12:34:02 <dancor> arrays and Map both leave something to be desired if you want a multidimensional block that is modified and on which you can do slicing, right?
12:34:22 <tavelram> Gracenotes, so that project is alot like timber.
12:34:27 <impl> tavelram: does it implement just a subset of the Java language itself then?
12:34:39 <Gracenotes> the primary object of my concern would be, if anything, Haskell->JVM. no Java linking involved, necessarily.
12:35:00 <Gracenotes> particularly not insofar as it would limit Haskell semantics
12:35:35 <tavelram> impl, dont think so. it actually parses the java-code and produces highly optimized javascript, html, css, imagemaps for a bunch of browsers and locales, depending on the settings...
12:35:40 <sinelaw> Saizan_, do you have knowledge about how to avoid stack overflows when loading binary dumps?
12:35:41 <dancor> or are Maps a good choice for a the underlying structure of a multidimensional slicing lib?
12:35:47 <sinelaw> (google'd irc logs suggest you do :)
12:36:04 <copumpkin> dancor: slicing?
12:36:28 <dancor> copumpkin: takeRangeAlongDimension (startI, endI) nthDim
12:37:02 <tavelram> Gracenotes, yeah, and using jvm directly would probably be alot easier, especially if you can reuse a compiler.
12:37:26 <tavelram> Gracenotes, have you looked at any c->java compilers?
12:37:34 <tavelram> or c->jvm for that matter
12:37:42 <scree> dancor: by "is modified", you mean sequentially or non-sequentially?
12:38:18 <dancor> scree: non-sequentially; random points in the tensor change at different time
12:38:21 <dancor> s
12:38:26 <Gracenotes> no. The most I've been involved with the JVM is browsing through the specs
12:38:53 <scree> dancor: but you only care about one tensor at ony given time?
12:39:06 <dancor> yes..
12:39:34 <copumpkin> isn't the next version of jvm gonna have tail call support btw?
12:39:36 <dancor> you care about your n-dimensional block but you might pull n-1-dimensional blocks out of it and stuff
12:40:34 <eflister> the redundancy of this bugs me:  f (A x) = 3 * g x ; f (B x) = 4 * g x  ...    shouldn't i be able to do something like  f (a x) = g x * {case a of A -> 3; B -> 4}  ?
12:40:46 <tavelram> Gracenotes, ok, but perhaps it would be efficient to reuse some of that in some way.
12:41:00 <copumpkin> dancor: if you're just taking "rectangular" slices of multidimensional arrays, I don't think you'd even need a map
12:41:10 <tavelram> Gracenotes, you need to say my nick for the msg to get highlighted, otherwise i might not read it :p
12:41:39 <Gracenotes> well. there isn't a message every 5 seconds or something ;)
12:41:57 <dancor> copumpkin: oh?  but arrays are bad for changing right?  you mean mutable arrays then?
12:42:07 <copumpkin> dancor: oh, I didn't realize you wanted to change them too
12:42:17 <copumpkin> dancor: but you can take "slices" of arrays without changing the original ones
12:42:29 <Gracenotes> tavelram: it is the case that GHC can compile to C. Perhaps the solution is already present then. perhaps not.
12:42:36 <scree> dancor: 'm being slow; could you outline the interface you want?
12:42:51 <tavelram> Gracenotes, well, I dont poll the channel every 5 seconds ;)
12:42:55 <scree> dancor: as in some type signatures or something
12:42:58 <dancor> updatePoint, sliceOnDimension
12:43:11 <dancor> getPoint
12:43:28 <tavelram> Gracenotes, yeah, ghc uses c as an intermediate language. but at that point, it includes alot of other files for the runtime, and some of those might not be that easy/suitable to compile into jvm.
12:43:50 <copumpkin> dancor: I'd do this on mutable arrays in ST, and the slicing can be done by wrapping the underlying array memory in a layer of arithmetic
12:43:51 <hexpuem> are there any plans to trim down the Prelude
12:44:02 <tavelram> youd need to write a wrapper (or new) scheduler, gc, memoryaccess, etc, et.c
12:44:07 <hexpuem> seems like alot of the functions in it have better equivalents in other modules in the stdlib
12:44:17 <dancor> copumpkin: and the thing would live in ST or you would wrap it in unsafeStuff?
12:44:52 <copumpkin> dancor: the mutability stuff would live in ST, and the rest outside. You could have a mutable slicer in ST too that gets rid of the unused memory, I guess
12:45:41 <dancor> why are maps bad for this (they have the advantage that mutation isn't stuck in ST)
12:45:53 <Gracenotes> tavelram: as it is, the primary structure of the C files is executing a series of instructions along the lines of entering closures, updating lazy values, getting values from constructors, etc. this is implemented as jumping around. it's not so hard to map onto most VMs. Maybe we could even go C-- -> JVM.
12:46:14 <eflister> any ideas on factoring out the g x in my question above?
12:46:27 <Gracenotes> hm.. the garbage collection would be a main issue.
12:46:44 <tavelram> Gracenotes, sure, and you could probably even remove the gc and trust that java does it right :p
12:46:50 <dancor> Gracenotes: how do ppl limit haskell (or c) when compiling to the more limited jvm?  compile-time fail on things-that-normally-work?
12:47:21 <Gracenotes> I'm not sure the JVM does GC by default, does it?
12:47:23 <Jafet> There is C -> JVM, so it's clearly possible
12:47:27 <tavelram> Gracenotes, but most things about side-effects would be an issue...
12:47:28 <copumpkin> dancor: nothing wrong with them, I just think an array would be simpler
12:47:47 <Gracenotes> Java specifically provides a GC
12:47:49 <tavelram> Gracenotes, yes it does.
12:48:37 <Gracenotes> hm. well, like any other programming language, Haskell does GC on items in the heap it no longer needs. so that can't be so difficult.
12:49:01 <Gracenotes> the only main issue I can think of is the close binding between the JVM and classes.
12:49:09 <Gracenotes> well, *another* main issue :)
12:49:14 <scree> eflister: what you suggest can't be done
12:49:14 <tavelram> Gracenotes, well, there are different algos and strategies for gc, and the one java uses might not be that suitable for haskell.
12:49:29 <tavelram> Gracenotes, highlight... :P
12:49:41 <scree> eflister: if you find you have constructors A x, B x, ... where x is always the same type, you should consider a different data representation
12:49:45 <Gracenotes> tavelram: maybe your client supports "/stalk Gracenotes"
12:49:50 <tavelram> Gracenotes, classes?
12:50:04 <gwern> I suspect the jvm gc is bad for haskell - haskell and FP in general I've heard are massively focused on generating and getting rid of lots of small items
12:50:05 <tavelram> tried, didnt.
12:50:11 <scree> eflister: such as (A | B | C | ..., x), maybe
12:50:14 <gwern> maybe if everything in java were an object...
12:50:39 <Gracenotes> gwern: well, there are plenty of opportunities for inplace updates..
12:51:09 <Gracenotes> tavelram: yes, things must be in a .class file..
12:51:10 <eflister> scree: in this case they are 'Dotted' and 'Triplet' -- so it goes back to your monolithic type preference...
12:51:33 <tavelram> Gracenotes, well, you can use jasmin or something to just emit "assembly" code.
12:51:59 <eflister> scree: so x is always a member of NoteDur
12:52:02 <tavelram> Gracenotes, whats your background? any program languages or compiler courses?
12:52:09 <eflister> scree: s/member/instance
12:52:23 <dancor> what are your influences
12:52:38 <scree> eflister: ModDur a = ModDur Modification a ?
12:52:50 <scree> eflister: Modification = Dotted | Triplet ?
12:52:54 <Gracenotes> tavelram: thoroughly examining the compiler process at the moment, and have written a few interpreters of varying complexity, plus one very minimal compiler (mostly arithmetic).
12:53:17 <tavelram> Gracenotes, ok
12:53:40 <eflister> scree: so things wind up looking like ModDur Triplet Eighth, right?
12:53:49 <Gracenotes> tavelram: interested in type theory and denotational/operational semantics, but mostly the latter for now :)
12:53:55 <scree> eflister: right
12:53:59 <Gracenotes> (latter of latter)
12:54:27 <tavelram> Gracenotes, ok.
12:54:50 <eflister> scree: then the cased version of f above works?
12:55:20 <ddarius> Gracenotes: Have you read Olivier Danvy's recent work?
12:55:50 <Gracenotes> not quite, I'm still looking through old papers :)
12:56:03 <scree> eflister: f ModDur{ mod, val } = someFunction mod * g val, yes
12:56:31 <Gracenotes> ddarius: any work in particular?
12:57:18 <eflister> scree: whoa, mod looks like a field of a record now?
12:57:39 <scree> eflister: f (ModDur mod val) = rhs
12:57:54 <scree> eflister: just playing around with my newfound record syntax :)
12:57:55 <eflister> scree: oh ok yeah
12:58:06 <eflister> scree: those are the same thing behind the scenes?
12:58:33 <scree> eflister: well, not with the definitions I gave above, 'cos those aren't records
12:58:57 <scree> eflister: if I had defined ModDur a = ModDur { mod :: Modification, val :: a } then yes
12:59:25 <scree> eflister: (in the latter case, both versions work)
13:00:59 <dancor> denotational semantics and operational semantics are both ways to prove what language code actually does, but what's the difference?  operations focus on transformation rules and denotations focus on proving things in a compositional way?
13:01:35 <eflister> scree: huh!  i guess i can see how they are equivalent
13:02:39 <FunctorSalad> dancor: denotational semantics tries to express the meaning of the program in terms of more abstract mathematical structures
13:02:58 <FunctorSalad> it's less syntactic
13:03:07 <yitz> operational semantics is the series of steps that will be executed on a von-Neumann style computer as a result of the program
13:04:21 <FunctorSalad> (the idea is that you'll be able to leverage existing mathematical knowledge, I think)
13:04:29 <FunctorSalad> but I'm far from an expert
13:09:20 <eflister> scree: why did we need the existential class constraint outside the record data constructor?  i have other fields where the constraint is inside, just on that specific field.
13:10:28 <copumpkin> eflister: it means something different
13:10:48 <scree> eflister: if you have data Foo = Foo (forall x . C x => x)
13:11:08 <scree> eflister: then you need to give it a forall x . C x => x to construct one
13:11:37 <scree> eflister: most of the time you only have a specific type which happens to instantiate C
13:13:19 <scree> eflister: so (someone stop me if I'm wrong here) if you give me a (forall x. C x => x) then *I* get to choose which type x we're using
13:14:04 <eflister> scree: what would it even mean to have a forall x . C x => x.  in the cases where it works for me, they are numbers, like data Foo = Foo {m :: Integral a => a}
13:14:15 <eflister> scree: is it the defaulting that's at work here?
13:14:32 <scree> eflister: no
13:15:10 <scree> eflister: so, for a typeclass Group, the method id :: forall x . Group x => x
13:15:26 <eflister> scree: i instantiate them with things like "3" :)  is that a forall x . Integral x?
13:15:45 <scree> @type 3
13:15:46 <lambdabot> forall t. (Num t) => t
13:15:52 <eflister> huh
13:15:54 <ksf> copumpkin, I've solved the hsc issue.
13:16:04 <copumpkin> ksf: oh, how?
13:16:06 <ksf> that were the good news.
13:16:12 <eflister> scree: but isn't it the defaulting that decides it's an Int in a given case?
13:16:23 <ksf> the bad news is that I've sucessfully exploded the build system due to ad-hockery.
13:16:39 <ksf> copumpkin, a crosscompiler and two make rules.
13:16:58 <scree> eflister: defaulting is kind of irrelevant
13:17:02 <ksf> ...one to replace the one hsc -> hs rule.
13:17:31 <scree> eflister: it's a convenience so that the compiler doesn't complain that much
13:17:36 <ksf> the first goes hsc -> some binary, which calls the cross compiler, and the second one goes some binary -> hs, which scp's the binary over to the target, runs it and collects the output.
13:17:43 <eflister> scree: well i'm trying to figure out what makes my Integral and RealFrac fields different from my dur field
13:18:02 <scree> eflister: paste?
13:18:04 <eflister> scree: and one difference is that those classes are defaulted i think
13:18:34 <eflister> scree: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11391
13:18:50 <FunctorSalad> defaulting doesn't happen in data declarations
13:19:00 <FunctorSalad> only for values which don't have a sig
13:19:20 <ksf> copumpkin, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11392#a11392
13:19:21 <Gracenotes> mrowl
13:19:40 <ksf> (rules/hs-suffix-rules-srcdir.mk)
13:20:11 <ksf> that solution is so easy it's embarassing I didn't think of it earlier.
13:20:19 <scree> eflister: I don't think that's what you mean
13:21:04 <eflister> scree: does my q make sense -- why is dur different there?
13:21:11 <d4mien2> hi can anyone tell me why this doesn't work ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11393#a11393
13:21:21 <scree> eflister: data Note a b = forall x . NoteDur x => { ... measure :: a, .., subdiv :: b, ... }
13:22:11 <scree> eflister: the question is: do you want to be able to take two Notes and add their subdivs?
13:22:25 <d4mien2> do I need in ?
13:22:34 <eflister> scree: hm, that's never come up (it works as is...)
13:22:36 <mauke> d4mien2: looks like you want 'where' instead of 'let'
13:22:41 <yitz> d4mien2: yes
13:22:45 <FunctorSalad> the non-gadt syntax for existentials is immensely confusing admittedly
13:22:57 <yitz> d4mien2: let (x, acc) = power n (k-1) in (n * x,1+ acc)
13:23:07 <yitz> d4mien2: or, yeah, use where
13:23:23 <yitz> instead of let, the way you have it
13:23:30 <d4mien2> yitz ah okey. thanks guys
13:23:37 <mauke> I don't see the point of acc
13:23:44 <mauke> it's always k+1 at the end
13:24:21 <FunctorSalad> take an easier example: data Ex where MakeEx :: forall a. [a] -> Ex
13:24:26 <d4mien2> mauke you are right could be just x
13:24:55 <FunctorSalad> now if you have a value of type Ex, you know it contains *some* list, but know nothing about the type of the elements
13:25:06 <FunctorSalad> compare with:
13:25:16 <d4mien2> mauke hm if I only have x and not acc it won't compile
13:25:19 <FunctorSalad> take an easier example: data All where MakeAll :: (forall a. [a]) -> All
13:25:37 <mauke> d4mien2: what's the error message?
13:25:42 <FunctorSalad> err too much copy & paste :)
13:26:23 <d4mien2> mauke http://pastebin.com/m23838340
13:26:46 <mauke> er, what
13:27:58 <mauke> d4mien2: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11393#a11394
13:28:47 <scree> eflister: ok, understand.  For Integral, RealFrac &c. we have a convenient method of generating forall x . C x => x stuff (namely 3, 4 &c.).  So we can put these objects of unspecified type in the data declaration.
13:29:16 <d4mien2> mauke but on that one I only get one integer as output I won't two. one with the reslt and the other that computes the number of steps
13:29:32 <scree> eflister: however, for your custom-defined types, you have no mechanism for making forall x. C x => x things: whenever you build something, it has a specific type
13:29:38 <mauke> d4mien2: the caller already knows the number of steps (second parameter)
13:30:12 <scree> eflister: so we do something different, namely tell the data decl to *hide* the type in question from the outside world
13:31:34 <d4mien2> mauke well I want it to be printed aswell. so then I must have x and acc(or y or whatever) doing the same thing?
13:32:58 <yitz> d4mien2: let powerWithSteps n k = (power n k, k+1)
13:33:09 <eflister> scree: ok, makes sense.  any reason haskell coldn't be happy to let you have values with unknown types, and just some known class instantiations?  ie, no need to hide from the outside world that the result of some f has no reliable type, only reliable class constraints?
13:35:13 <scree> eflister: so, the general question you'll have to ask the type theory guys; if you can give a specific example of what you want to type I might be able to say why it's not workable
13:35:24 <copumpkin> eflister: it can be
13:35:36 <copumpkin> eflister: with an existential wrapper, that's exactly what happens
13:36:23 <d4mien2> yitz ok thanks that is one way
13:36:24 <d4mien2> thanks guys
13:36:34 <scree> I guess the question was, could this in principle be done without a datatype wrapper (?)
13:37:12 <eflister> copumpkin and scree: hm, then i don't get why the fields have to be handled differently in the example -- nothing is hidden from the outside world, it's just that accessing those fields gives values that only have known class constraints
13:37:59 <copumpkin> eflister: huh?
13:38:30 <eflister> copumpkin and scree: i don't see why constructing the value should be an issue, if i supply a specific value that meets the constraints, why can't it be used (ie, lose its specific type info, retaining only the relevant class info)
13:38:36 <copumpkin> eflister: btw, your 0-255 stuff can be enforced by making it a Word8 instead of an Int
13:38:48 <copumpkin> eflister: it can be, and that's exactly what happens...
13:39:08 <eflister> copumpkin: why NoteDur is different than RealFrac and Integral in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11391
13:39:13 <copumpkin> data Showable = forall a. Show a => Showable a
13:39:38 <copumpkin> [Showable 5, Showable True, Showable ()]
13:39:40 <copumpkin> that will work
13:39:43 <eflister> copumpkin: yeah good idea re Word8
13:40:11 <sinelaw> somehow existential types seem like evil magic to me
13:40:18 <copumpkin> eflister: why do you care about measure and subdiv having class constraints?
13:40:22 <scree> eflister: so, one is a case of saying: here's a magic box (3 : forall a . Num a => a); you can force it to be anything you want it to be
13:40:51 <copumpkin> eflister: you can do the exact same thing with measure and subdiv's types if you want, but I'm not sure why you'd want to
13:40:54 <scree> eflister: the other is saying: here's a magic box; I'm not telling you anything about it except that it's a number
13:41:06 <jmcarthur> Existential types are neither good nor evil.
13:41:14 <scree> eflister: in the former case, it's ok to take the thing out of the box and force it to be an Integer
13:41:32 <sinelaw> @where fix
13:41:33 <lambdabot> I know nothing about fix.
13:41:35 <sinelaw> @hoogle fix
13:41:35 <lambdabot> Data.Function fix :: (a -> a) -> a
13:41:35 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
13:41:35 <lambdabot> module Control.Monad.Fix
13:41:36 <scree> eflister: in the latter, it must *stay in the box* at all times, because we've forgotten what type it really is
13:41:41 <sinelaw> @src fix
13:41:41 <lambdabot> fix f = let x = f x in x
13:41:45 <sinelaw> evil magic
13:41:51 <copumpkin> sinelaw: fun magic :)
13:42:04 * mauke has used fix in perl
13:42:10 <copumpkin> sinelaw: more evil is the type of loop
13:42:11 <sinelaw> mauke, what for?
13:42:22 <mauke> sinelaw: recursive private functions
13:42:24 <eflister> copumpkin: well what i want to do is put NoteDur inside, not RealFrac outside.  why do i care about them having class constraints?  i was just trying to keep the definition as general as possible...
13:42:39 <sinelaw> mauke, as a Y combinator?
13:42:51 <mauke> sinelaw: yes
13:42:58 <scree> eflister: one is "I haven't decided yet"; the other is "I've forgotten"
13:43:23 <sinelaw> lambdabot should replace ghci
13:43:26 <eflister> scree: inside the constructor is 'not decided yet', right?
13:43:30 <mauke> @where goa
13:43:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:43:33 <sinelaw> how many people have said this before me?
13:43:39 <mauke> sinelaw: ^
13:43:42 <Twey> Enough that somebody implemented it.
13:43:43 <scree> eflister: yep
13:43:50 <_Ray_> Question. I'm building a package, and hmake complains it can't find the *.hi file (but I can see a .hs version). Can the .hi be generated somehow from the .hs?
13:43:55 <sinelaw> mauke, thanks :)
13:44:08 <eflister> scree: oh is the idea that at compile time it WILL be decided once and for all, so if it's inside, it can't be lots of things?  (this is exactly what i meant by defaulting)
13:44:19 <scree> eflister: there's nothing *stopping* you from putting dur inside
13:44:36 <mauke> _Ray_: I take it this package isn't from hackage?
13:44:47 <sinelaw> why the name "goa"
13:44:50 <_Ray_> I didn't get it from there, no. It's Hat.
13:44:53 <mauke> ghc generates .hi files during compilation
13:44:59 <mauke> sinelaw: ghci on acid
13:45:05 <sinelaw> heh
13:45:12 <scree> eflister: so, someone further down the chain will decide on the type, whether that's the user or a defaulting thingy
13:45:26 <eldragon> @where jit
13:45:26 <lambdabot> I know nothing about jit.
13:46:04 <scree> eflister: heh
13:46:06 <eflister> scree: ok, so inside vs. outside the constructor is something like 'someone else gets to make the decision for everyone' vs. 'each runtime object can flexibly decide for itself'?
13:46:30 <_Ray_> Well, GHC says "Failed to load interface for `AuxTypes':". Is there a reasonably easy way to fix this, having AuxTypes.hs?
13:46:41 <_Ray_> (It's sitting on the same dir)
13:47:11 <scree> eflister: do you have a C++ background by any chance?
13:47:31 <eflister> scree: well not a lot, a couple small projects
13:47:55 <scree> eflister: oh well
13:48:11 <scree> eflister: I think your last statement is true
13:48:42 <_Ray_> Oh, is the "Interface" the part after "module foo", meaning the exported functions?
13:49:16 <scree> eflister: (what I was going to say was: outside the constructor (i.e. existential quantification) is basically like recasting as a superclass)
13:49:53 <sinelaw> how do i actually use goa?
13:49:58 <sinelaw> what do i write within ghci?
13:50:13 <scree> eflister: in fact, bizarrly, I think that (forall x . C x => x) can be decided at runtime
13:52:08 <sinelaw> i guess :m +GOA, etc...
13:53:15 <eflister> scree: i don't get the reasoning for keeping the 'i haven't decided yet' option -- it seems most natural to me to just have the inside option mean 'when accessed in this field, my type is unknown, but i promise to implement this class' -- ie, it's always fair for an object to retain its specific type, while some people only have some more abstract interface to it.
13:55:18 <eflister> scree: as it currently stands, i don't see why we had to lose the dur accessor function -- it should just return something more abstract...
13:56:53 <c_wraith> :t const . const $ 5
13:56:54 <lambdabot> forall b a b1. (Num a) => b -> b1 -> a
13:57:07 <copumpkin> const . const . const . const . const . const $ 5
13:57:49 <scree> eflister: then, your only option in current Haskell is to make a seperate existential wrapper (data Dur = forall x . WhatsitClass x => Dur x)
13:58:54 <scree> eflister: Dur now becomes your way of writing "you are only allowed a small interface to this object"
13:59:16 <scree> eflister: you very much *don't* want to do this with Integral t
13:59:19 <mauke> for bonus points, add instance WhatsitClass Dur
13:59:34 <scree> exactly
14:00:02 <scree> eflister: with Integral t, you have the problem that you can't add two of them together unless you're *sure* they have the same type
14:00:37 <scree> (+) has type Num a => a -> a -> a, not Num a, Num b, Num c => a -> b -> c
14:01:03 <eflister> scree: is that a bug or a feature of (+)?
14:01:14 <scree> eflister: definitely a feature
14:01:44 <scree> eflister: Integer + Matrix -> (Real -> Real) is ...
14:01:56 <scree> eflister: problematic
14:02:12 <_Ray_> How do I use cabal to install Data.Set? (Hell, what's the syntax for installing package foo.bar?)
14:02:17 <c_wraith> @instances num
14:02:17 <scree> eflister: (yet all of these can be added to things of the same type)
14:02:18 <lambdabot> Couldn't find class `num'. Try @instances-importing
14:02:19 <copumpkin> _Ray_: you already have it
14:02:21 <copumpkin> it's in the base package
14:02:21 <c_wraith> @instances Num
14:02:23 <lambdabot> Double, Float, Int, Integer
14:02:30 <copumpkin> but normally, cabal install <package>
14:02:34 <_Ray_> :( Damned Hat is saying it can't find it.
14:02:41 <mauke> copumpkin: I don't think it's in base
14:02:45 <copumpkin> Data.Set?
14:02:46 <mauke> shouldn't it be in containers?
14:02:47 <eflister> scree: well not all combinations need be defined, but that doesn't seem like a reason to require only homogenous types
14:02:47 <copumpkin> oh, containers
14:02:48 <copumpkin> yeah
14:03:07 <eflister> scree: int + matrix has an unproblematic interpretation
14:03:07 <scree> eflister: you want all these functions to be total
14:03:07 <_Ray_> So how would I install it? Data.Set doesn't work, Set doesn't either
14:03:12 <copumpkin> _Ray_: hat looks bitrotted...
14:03:32 <scree> eflister: if you want int + matrix, you need a new operator +| or something
14:03:34 <_Ray_> copumpkin, it is, extremely. But I've found nothing else that can show code reductions.
14:05:26 <eflister> scree: couldn't they still be total?  you could still type-check everything at compile time, and just have (+) refer to a variety of more specific operations, each of which was total.  if there is no instantiation for the particular type mixture, it's a compile time error
14:05:43 <scree> eflister: you're right
14:05:47 <copumpkin> eflister: it would be possible, but more painful
14:05:58 <copumpkin> with a multiparameter typeclass
14:06:15 <scree> eflister: you'd need a class Plus a b c | a, b -> c where (+) :: a -> b -> c
14:09:08 <rasfar> i'm looking into parsing haskell source to get a syntax tree.  any opinions on best starting point?  preferably something that can be installed with minimum fuss, and comes with a nontrivial example or two that work?
14:09:27 <copumpkin> haskell-src-exts
14:10:52 <rasfar> okay ... I obtain it with darcs get http://code.haskell.org/HSP/haskell-src-exts
14:11:07 <copumpkin> or just cabal
14:11:18 <rasfar> the it is:  runhaskell Setup configure
14:11:36 <rasfar> (or you are suggesting cabal install haskell-src-exts?
14:12:38 <rasfar> I get an error     Module `System.Process' does not export `rawSystem'
14:13:09 <rasfar> When I install from source, it is possible to find the offending source file and change this to import from System.Cmd, but this seems like the start of a nightmare...
14:14:28 <rasfar> (I've not yet been able to complete the compilation because it complains I need cpphs >= 3.1, which is installed and present in /usr/bin
14:15:16 <rasfar> I'm sorry for my naivity, but just feeling this out to see if it's worth trying to parse properly or continue using the ad-hoc custom parser I wrote (which can't handle any language extensions, so is going to hinder me from exploring any interesting projects out there...)
14:16:23 <m0nkfish> ive just written a function and i dont know the name of what it does
14:17:20 <m0nkfish> is there a specific word for permutations that allow items to be used more than once
14:17:36 <rasfar> copumpkin: thanks at least for confirming that haskell-src-exts is a good avenue to try; i'll probably figure out how to install it after an hour or two (hopefully)
14:18:26 <aavogt> m0nkfish: combinations?
14:18:42 <aavogt> but those are unordered
14:18:45 <m0nkfish> i thought combinations were a subset of permutations
14:18:53 <m0nkfish> oh ok
14:19:01 <m0nkfish> so what im looking for is the union of permutations and combinations hehe
14:21:03 <Twey> Oo-er.
14:21:12 <Twey> Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
14:21:19 <Twey> (trying to cabal install lambdabot)
14:21:51 <Twey> Hum
14:21:54 <yitz> Twey: you have ncurses installed on your machine?
14:22:12 <Twey> My /usr/lib/libncurses.so is a single-line text file, ‘INPUT(-lncursesw)’
14:22:23 <yitz> he, sounds pretty wrong
14:22:37 <mauke> it's a linker script
14:22:40 <yitz> what's your platform?
14:22:49 <mauke> check google, this sounds like a Known Problem
14:23:02 <yitz> mauke: looks like m4
14:23:20 <Twey> Arch
14:23:24 <dons> linker scripts can be replaced with symlinks
14:23:24 <Twey> http://www.haskell.org/pipermail/arch-haskell/2008-December.txt
14:23:40 <Twey> dons: To libncursesw.so?
14:23:42 <dons> ln -s /usr/lib/libncurses.so /usr/lib/libncursesw.so -- haxoring your arch
14:23:51 <dons> but then ghci will be able to load the files.
14:23:57 <dons> yay for our hand rolled dyn linker in ghc
14:24:01 <Twey> Heheh.
14:24:11 <dons> (it would be almost trivial to add support for 90% of linker scripts like this)
14:25:02 <kyagrd> somthing should be done to those linker scripts in GHC
14:25:12 <pikhq> ... Hand-rolled dynamic linker? That sounds very hackish.
14:25:38 <pikhq> (though, so's everything else involving dynamic linking)
14:25:50 <rasfar> dons: a word of advice on what's going wrong with my haskell-src-exts installation?
14:25:52 <dons> we have to, so that you can compile a .hs to a .o, and then load in in ghci
14:26:11 <dons> don't know, rasfar
14:26:41 <rasfar> kay, thanks
14:27:04 <Twey> dons: Argh
14:27:15 <Twey> You got your arguments backwards to ln
14:27:31 <Twey> I just overwrote my libncursesw.so with an infinitely recursive one-line linker script
14:27:49 <pikhq> dons: Scary. Clever, but scary.
14:28:34 <dancor> ln arg order is just one of those things that everyone does worse-than-chance on
14:28:38 <Twey> I'm so glad I caught that :þ
14:28:43 <dons> Twey: yikes. ln warns about, doesn't it?
14:28:46 <Twey> dancor: Yeah, I screw it up often too :-\
14:28:57 <Twey> dons: Not if you're expecting it to overwrite anyway and so added a -f to the line.
14:29:00 <dons> i always think of `ln` as a function ->
14:29:09 <mauke> dons: it is
14:29:11 <Twey> Aye
14:29:12 <mauke> it works just like cp
14:29:26 <mauke> or echo foo > bar
14:29:26 <dons> cp old new. ok. so apparently i don't think of it like that.
14:29:31 <dons> but more like: foo dest src
14:29:33 <Twey> Heh
14:29:46 <dons> stupid memcpy
14:29:55 <Vanadium> Remember that you can do ln -s file1 file2 file3 targetdir
14:29:59 <Vanadium> so clearly the target is the last argument
14:30:02 <Twey> ‘dest’ can mean many things for ln
14:30:06 <Twey> I guess so.
14:30:10 <rasfar> maybe my GHC 6.8 isn't new enough?  (in ubuntu jaunty)
14:30:35 <rasfar> (6.8.2)
14:31:29 <thomastc> why is there no function "if :: Bool -> a -> a -> a"?
14:31:47 <thomastc> I know there is the if/then/else construct, but it doesn't support currying, right?
14:31:53 <dancor> > if' True 4 5
14:31:54 <lambdabot>   Not in scope: `if''
14:32:03 <thomastc> actually, "if :: a -> a -> Bool -> a" would be more useful I think
14:32:23 <pikhq> @let if' x y z = if x then y else z
14:32:24 <lambdabot>  Defined.
14:32:28 <pikhq> > if' True 4 5
14:32:29 <dancor> > if' True 4 5
14:32:29 <lambdabot>   4
14:32:30 <lambdabot>   4
14:32:37 <dancor> no concurrency bugs
14:33:25 <dancor> thomastc: if' is common.  your second thing is usually called bool i think
14:33:25 <dons> dancor: ?
14:33:32 <dancor> dons: just a joke
14:33:42 <dons> :)
14:33:58 <dancor> @let bool t e c = if' c t e
14:33:59 <lambdabot>  Defined.
14:34:00 <thomastc> dancor: okay, thanks
14:34:21 <dancor> thomastc: by analogy with either
14:34:27 <dancor> :t either
14:34:27 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:34:29 <dancor> :t maybe
14:34:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:34:50 <dancor> :t bool
14:34:51 <lambdabot> forall t. t -> t -> Bool -> t
14:37:44 <Twey> Hm
14:38:06 <Twey> thomastc: let (y ?? n) p = if p then y else n
14:38:49 <Twey> When I use the :pl GOA alias in GHCi, it does nothing (returns the string I gave it for pl'ing intact)
14:38:53 <chaosape> if i can't run reify in the IO monad, how can I check that my template is generating what I want it to?
14:39:05 <thomastc> yes, of course I could define it in many ways, just wondering why it didn't seem to exist
14:39:25 <Twey> But when I call ‘lambdabot "pl" str’ instead, it works (prints the input, then the pl'd output, then returns an empty string)
14:40:35 <mreh> i need to make a matrix of distances between a list of points and a list of centers, how can I zip two lists into every possible combination of pairs?
14:40:58 <m0nkfish> will i ever get my head around this:
14:40:59 <m0nkfish> strings = [x++[a] | x <- "" : strings, a <- ['a'..'z']]
14:41:00 <mauke> liftM2 (,)
14:41:50 <jokerGTA> guys i have this type MyType and I need to make it an instance of ParsecRead class and not sure how to do it
14:41:51 <m0nkfish> is the empty list being consed to the list of strings
14:41:52 <m0nkfish> :S
14:41:58 <jokerGTA> instance ParsecRead MyType where
14:43:00 <jokerGTA> i want to be able then to say something like this...myFunction::MyType
14:43:01 <lpjhjdh> chaosape: $((report False . show =<< reify ''Whatever) >> return [])
14:43:11 <FunctorSalad> m0nkfish: "a nonempty string is any string, followed by a letter. an (any string) is either the empty string or a nonempty string"
14:43:28 <jokerGTA> myFunction = read "some string to read"
14:43:31 <FunctorSalad> (strings = nonempty strings, x = any strings)
14:44:04 <mreh> > map (zip [1..10]) chunk $ cycle [1..10]
14:44:05 <lambdabot>   Not in scope: `chunk'
14:44:09 <m0nkfish> does : perform a different function in lambda expressions
14:44:12 <mreh> > map (zip [1..10]) splitEvery $ cycle [1..10]
14:44:13 <lambdabot>   Not in scope: `splitEvery'
14:44:13 <m0nkfish> wait i mean list comprehensinos
14:44:14 <m0nkfish> sorry
14:44:39 <FunctorSalad> chaosape: -ddump-splices
14:44:44 <mreh> :t Data.List.Split.SplitEvery
14:44:45 <jlouis_> m0nkfish: no, it is the cons-operator
14:44:46 <lambdabot> Couldn't find qualified module.
14:44:52 <mreh> :t Data.List.Split.chunk
14:44:53 <lambdabot> Couldn't find qualified module.
14:45:02 <m0nkfish> oh so you can cons the null list to a list
14:45:15 <jlouis_> m0nkfish: to the front, yes
14:45:19 <FunctorSalad> but lpjhjdh's approach is more generally useful for displaying any stuff out of the Q monad
14:45:32 <m0nkfish> how does that work :(
14:45:43 <m0nkfish> now i am mega confused.. does it show up in the list?
14:46:19 <chaosape> lpjhjdh,FunctorSalad:  Thanks!
14:50:03 <SpookyGent> "maw" ++ cycle "ha"
14:50:12 <SpookyGent> hi all :)
14:50:25 <medfly> needs >
14:51:41 <ewd> SpookyGent means tonight he is spooky and he wants to say mawhahahaha... to you.
14:51:52 <jlouis> m0nkfish: it works because of laziness. A haskell system will only compute it on a by-need basis
14:53:05 <jlouis> m0nkfish: perhaps it would be easier to start with [x ++ [a] | x <- "", a <- ['a' .. 'z']] which is almost trivial, no_
14:53:08 <jlouis> ?
14:53:25 <m0nkfish> yeah
14:53:27 <jlouis> bah, x <- "" : []
14:53:41 <m0nkfish> so it'll find the empty list first in the expression
14:54:15 <jlouis> yeah and then generate ["a", ..., "z"] which is then your approximation of strings
14:54:26 <mreh> (zip (concat $ map (take 10 . repeat) [1..10]) (concat . repeat $ [1..10])) -- I think this is a bit overly complicated, any better ideas?
14:54:45 <dibblego> mreh, concat $ map == concatMap == (=<<)
14:54:57 <dibblego> concat . repeat == cycle
14:55:31 <mmorrow> @src replicate
14:55:32 <lambdabot> replicate n x = take n (repeat x)
14:55:36 <mreh> > (zip (contcatMap (take 10 . repeat) [1..10]) (cycle [1..10]))
14:55:37 <lambdabot>   Not in scope: `contcatMap'
14:55:57 <jlouis> hep Athas! :)
14:56:11 <rasfar> Looks like I need newer GHC.  Should I uninstall my ubuntu jaunty GHC 6.8.2 before installing the 6.10.4 binary?
14:56:19 <mmorrow> , replicate 10 =<< [1..10]
14:56:21 <lunabot>  [1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,...
14:56:33 <burp> > [(i,j) | i <- [1..10], j <- [1..10]]
14:56:34 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
14:56:36 <burp> what about this? ;)
14:56:44 <dmwit> rasfar: You can, but different GHC versions can usually coexist if you want them to.
14:56:50 <mreh> burp, even better
14:56:56 <Athas> Yo, jlouis.
14:57:26 <dmwit> rasfar: Each ghc command (ghc, ghci, ghc-pkg, etc.) have corresponding versioned names (ghc-6.8.2, ghci-6.8.2, ghc-pkg-6.8.2, etc.), and libraries are stored in versioned directories.
14:57:50 <mreh> thanks
14:58:27 <rasfar> thanks dmwit, i'll try the coexistence.  i'm just worried that cabal will choke (this system has been upgraded several times).  i'm really very clueless when it comes to installing haskell' stuff.
14:59:24 <mreh> > [(i + j) | i <- [1..10], j <- [1..10]]
14:59:25 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:00:04 <dibblego> > join (liftA2 (+)) [1..10]
15:00:05 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:01:58 <burp> > [1..10] >>= (\i -> [1..10] >>= (\j -> return (i,j) ))
15:01:59 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
15:04:56 <burp> > concat $ map (zip [1..10]) (tails [1..10])
15:04:57 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(1,2),(2,3),...
15:05:04 <rasfar> Okay ... so it looks like now I should change these 6 symlink in /etc/alternatives?  ghc ghc-pkg ghc.1.gz ghci ghci.1.gz ghcprof  (this may be ubuntu-specific, not sure)
15:05:06 <burp> oops, thats not the same ;)
15:05:28 <dmwit> rasfar: The installer should do that for you... I think.
15:05:36 <dmwit> But if not, yeah, switch out those symlinks.
15:05:46 <mauke> > map sum . sequence . replicate 2 $ [1..6]
15:05:47 <lambdabot>   [2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10,6,7,8,9,10,11,7,8,9,10,11...
15:05:47 <dmwit> Or use debian's method for changing them (I can't remember what it is).
15:05:56 <jlouis> update-alternatives
15:06:03 <dmwit> Yeah, that.
15:06:15 <mm_freak> > replicateM 2 [0..9]
15:06:16 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[1,0],[1,1],[1...
15:06:28 <FunctorSalad_> or put /usr/local/bin, or whereever you installed it, first in your PATH
15:07:17 <mm_freak> > map (\[x,y] -> (x,y)) . replicateM 2 $ [0..9]
15:07:18 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1...
15:07:48 <mm_freak> not the same though
15:07:49 <jlouis> burp: those are far too readable. May I suggest you define your own number system based on ternary numbers?
15:08:20 <Twey> Ternary numbers are for wimps.  Leverage Unicode — invent a base-100 number system.
15:08:23 <mm_freak> > map (\[x,y] -> (x,y)) . replicateM 2 $ [1..10]
15:08:24 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
15:08:27 <rasfar> I think the installer didn't do it, because ghc --version still shows me 6.8.2, and cabal install haskell-src-exts gives the same error about System.Process not exporting rawSystem.
15:09:00 <rasfar> Unfortunately, the relinking failed...  for example, /usr/lib/ghc-6.10.4/bin/ghc: No such file or directory.  Ah well...
15:09:58 <rasfar> oops, new version is in /usr/local/* @*&^
15:11:14 * hackagebot upload: flow2dot 0.7 - Library and binary to generate sequence/flow diagrams from plain text source (DmitryAstapov)
15:12:50 <rasfar> /usr/local/lib/ghc-6.10.4/base-4.1.0.0/Prelude.hi: openBinaryFile: permission denied (Permission denied)
15:13:24 <mm_freak> hmm
15:13:26 <rasfar> and indeed the permissions are only -rw------- 1 root root, so dare I chmod -R at top GHC level?
15:13:34 <mm_freak> > map (take 10) . tails $ [2..]
15:13:35 <lambdabot>   [[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,5,6,7,8,9,10,11,12,13]...
15:13:40 <mm_freak> oh
15:13:46 <mm_freak> > concat . map (take 10) . tails $ [2..]
15:13:47 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:13:59 <mm_freak> well
15:14:03 <mm_freak> > concatMap (take 10) . tails $ [2..]
15:14:04 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:14:05 <mm_freak> =)
15:14:32 <m0nkfish> how can i do a breadth-first search using recursion
15:15:22 <rasfar> yep, that seems to have worked.  cabal install haskell-src-exts happily compiling.
15:15:42 <jlouis> m0nkfish: keep a FIFO of current subtrees. Pick subtree from queue and add its subcomputations in the back
15:16:39 <mmorrow> m0nkfish: breadth first /search/ or breadth-first traversal resulting in a new tree?
15:17:01 <mmorrow> for the former you don't even need a queue
15:17:56 <mm_freak> > tails [2..] >>= take 10
15:17:57 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:18:44 <rasfar> oops, missed the advice jlouis, thanks.  it seems to revert to 6.8.2 when I do that, but could be becasue I mussed it up already.
15:18:57 <m0nkfish> traversal i think
15:19:20 * hackagebot upload: graphtype 0.1.2 - A simple tool to illustrate dependencies between Haskell types (DmitryAstapov)
15:19:20 <m0nkfish> i solved my problem a different way
15:19:39 <namor> Ah, noob question.. how do I call another program from within haskell?
15:19:46 <rasfar> compilation complete; thanks copumpkin, dons, dmwit, jlouis
15:20:18 <rasfar> namor: System.Process(runCommand) perhaps?
15:20:51 <mreh> haskell hates me
15:20:55 <namor> rasfar, yes, that's it. Thanks!
15:21:30 <rasfar> cheers
15:22:56 <jlouis> hi adept .. ltns
15:23:08 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11399#a11399 -- this has completely stumped me
15:24:07 <SimonRC> I just realised what (>>=) for lists is...
15:24:12 <Vanadium> It is terrible
15:24:14 <Vanadium> that is what it is
15:24:15 <SimonRC> it's flip concatmap
15:24:16 <travisbrady> can't figure out which library I should be using to parse bytestrings. bytestringparser, attoparsec, parsec 3.0?
15:24:27 <dmwit> SimonRC: Yup! =)
15:24:29 <SimonRC> I never seemed to be able to remember it before
15:25:07 <mm_freak> travisbrady: i'm using parsec 3.0 and i'm happy with it…  it's quite sophisticated
15:25:20 <mm_freak> i haven't tried attoparsec so far
15:26:01 <mm_freak> Vanadium: well, with each list comprehension you use, you implicitly use list's (>>=)
15:26:20 <jlouis> SimonRC: it makes sense that it should be that thing
15:27:24 <Vanadium> mm_freak: I hardly ever see people use list comprehensions, especially not when they could use terrible unreadable monads instead
15:27:26 <mreh> could somebody please help?
15:27:40 <mm_freak> hmm
15:27:55 <mm_freak> > [ take 10 xs | xs <- [2..] ]
15:27:56 <lambdabot>   No instance for (GHC.Enum.Enum [a])
15:27:56 <lambdabot>    arising from the arithmetic sequence...
15:28:02 <mm_freak> oh
15:28:05 <mm_freak> > [ take 10 xs | xs <- tails [2..] ]
15:28:05 <lambdabot>   [[2,3,4,5,6,7,8,9,10,11],[3,4,5,6,7,8,9,10,11,12],[4,5,6,7,8,9,10,11,12,13]...
15:28:12 <mm_freak> > concat [ take 10 xs | xs <- tails [2..] ]
15:28:13 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:28:16 <mm_freak> there you go
15:28:21 <mauke> Vanadium: list comprehensions is monads
15:28:24 <mm_freak> but i find the monadic variant nicer
15:28:31 <Vanadium> mauke: except more readable
15:28:37 <mauke> Vanadium: no
15:28:46 <mm_freak> Vanadium: not if you use do syntax
15:29:03 <Vanadium> That makes it even more obscure
15:29:11 <mm_freak> > do xs <- tails [2..]; take 10 xs
15:29:12 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:29:30 <mm_freak> not really, just interpret the variables as non-deterministic variables
15:29:59 <mm_freak> after all, that's what the list monad expresses:  non-deterministic computations
15:30:15 <ewd> monad is readable. comprehension is readable.
15:30:16 <Vanadium> I thought you needed IO for non-determinism
15:30:30 <jlouis> Vanadium: nono. Not at all.
15:30:39 <travisbrady> mm_freak: thank you
15:30:43 <mm_freak> non-determinism in this context means:  arbitrarily many results
15:30:46 <mreh> hey, dijkstra has joined us in
15:30:48 <Vanadium> System.Random.randomRIO etc
15:30:48 <mreh> #haskell
15:31:16 <ewd> halloween costume
15:31:24 <mreh> gross
15:34:15 <mm_freak> > randomRs (1,6)
15:34:16 <lambdabot>   Ambiguous type variable `g' in the constraints:
15:34:16 <lambdabot>    `System.Random.RandomGen...
15:34:22 <mm_freak> > randomRs (1,6::Integer)
15:34:23 <lambdabot>   Ambiguous type variable `g' in the constraints:
15:34:23 <lambdabot>    `GHC.Show.Show g'
15:34:23 <lambdabot>      a...
15:34:33 <mm_freak> > randomRs (1,6) :: [Integer]
15:34:34 <lambdabot>   Couldn't match expected type `[GHC.Integer.Internals.Integer]'
15:34:34 <lambdabot>         agai...
15:36:00 <mreh> is it unusual to have a hard time with the type system when you're a n00b?
15:36:25 <mm_freak> mreh: no, sometimes even i struggle with it, but it pays off every time =)
15:36:29 <ewd> No, but when I was a n00b I didn't use existential type.
15:36:55 <ewd> I mean yes, it is unusual.
15:37:24 <mm_freak> depends
15:37:27 <mm_freak> i came from C
15:37:42 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11399#a11399 -- I just can't understand this
15:37:47 <ewd> I came from basic and pascal and c and lisp and perl.
15:38:26 <FunctorSalad_> mm_freak: it does? sometimes I get lost in ridiculous contortions
15:38:30 <ewd> And then I encountered Hindley-Milner and I found it "finally, something logical and systematic!"
15:38:39 <rasfar> mreh: I couldn't compile your example because I don't have Numeric.LinearAlgebra.Linear .... although I have Numeric.  How does one install the submodules?
15:38:50 <mm_freak> ewd: ok, i've had used many languages already, but they all had a poor type system
15:39:01 <mreh> rasfar it's part of hmatrix
15:39:14 <FunctorSalad_> ewd: yeah
15:39:14 <mm_freak> (compared to haskell at least)
15:39:15 <rasfar> (not that I'm likely going to be able to help) ... thanks for the package name...
15:39:27 <mreh> I came from Java, but I'm still finding it hard
15:39:32 <mm_freak> FunctorSalad_: well, then probably i'm just more lucky at that
15:40:02 <mm_freak> mreh: when i learned C# i already knew haskell
15:40:27 <mm_freak> i found myself implementing the state monad as my first work…  not that i needed it, but it just seemed more natural to me
15:40:31 <mreh> why did you learn C# then, are you mad
15:40:34 <FunctorSalad_> mm_freak: I mean cases where you could have solved the problem with basic types but are tempted to go crazy on the type level ;)
15:40:39 <mm_freak> unfortunately my code often stack-overflowed =)
15:40:48 <mm_freak> mreh: i had to, for both work and school
15:41:22 <ewd> You first learn something done wrong (or maybe not plain wrong, just ad hoc and therefore incomplete and overly complicated), then you learn something done right. Which one gives you a harder time depends on how gullible you are. If you buy the done wrong or done ad hoc story, you will have prejudice against the done right story.
15:41:38 <mm_freak> (i'm glad that i was allowed to use it…  much better than VB.NET, and after some time i moved to F#, which is much better)
15:41:58 <iaefai_> Hallow!
15:42:07 <mm_freak> FunctorSalad_: yeah, that's really dangerous, but much more dangerous in other languages
15:42:27 <mm_freak> i found myself asking in C# forums how i can get "generic generics"
15:42:40 <iaefai_> Is there any shortcut to something where you want to do fromList (a ++ b)  but where you would rather not put in brackets?
15:43:07 <mm_freak> when i told them i wanted to implement generic functor functions, they told me i'm crazy and that's not the way to do things in C#
15:43:17 <ewd> It's probably the same deal as "I came from basic, I have a hard time with pascal, I get confused by parameter passing in procedure calls".
15:43:30 <FunctorSalad_> fromList$mappend a b
15:43:32 <FunctorSalad_> ;)
15:43:36 <mreh> why is haskell rejecting my generic type saying it doesn't match another generic type, how am I supposed to infer the reason?
15:43:48 <mreh> is it to do with typeclasses?
15:44:14 <mm_freak> mreh: sounds like it has to do with existentials
15:44:20 <FunctorSalad_> one good type debugging tool are implicit parameters
15:44:33 <mm_freak> i prefer state monads
15:44:37 <mauke> rank-n types!
15:44:38 <mreh> that dastardly existentials
15:44:42 <FunctorSalad_> (put a question mark in front of one of the dubious functions :))
15:44:50 <mm_freak> almost 80% of my code is wrapped in some StateT
15:45:11 <mreh> they were a bunch of philosophers in the 1900s weren't they?
15:45:15 <mm_freak> recently i got in love with ContT to break out of 'forever' loops =)
15:45:17 <FunctorSalad_> > sequence (mapM length >> ?eh)
15:45:17 <lambdabot>   Couldn't match expected type `m b'
15:45:17 <lambdabot>         against inferred type `GHC.Types...
15:45:25 <FunctorSalad_> hmm that was too random
15:45:42 <FunctorSalad_> > sequence (fmap length >> ?eh)
15:45:43 <lambdabot>   Couldn't match expected type `[a]'
15:45:43 <lambdabot>         against inferred type `f [a1] ->...
15:46:01 <FunctorSalad_> > sequence (fmap (+) >> ?eh)
15:46:03 <lambdabot>   Couldn't match expected type `[a]'
15:46:03 <lambdabot>         against inferred type `f a1 -> f...
15:46:13 <mauke> ...
15:46:14 <FunctorSalad_> err sorry for the line noise
15:46:25 <mreh> :t ?eh
15:46:26 <lambdabot> forall t. (?eh::t) => t
15:46:28 <FunctorSalad_> the aim was to demonstrate implicit parameters to find the type of holes
15:46:31 <mauke> sequence takes a list. (+) is a function
15:46:42 <mauke> wait, fmap (+) is a function
15:46:48 <mauke> in any case, you can't win
15:46:55 <FunctorSalad_> mauke: the nonsensicality was the whole point
15:47:04 <mauke> yeah, but it's unrelated to ?eh
15:47:09 <FunctorSalad_> but I hoped there was some instance such that it would work for some value of ?eh
15:47:33 <stulli> Hi, i have a Parsec question: I use "many1 xyz", is there a way to find out how often xyz was called?
15:47:33 <mreh> is there some reading I can do about existentials?
15:47:36 <mreh> RWH?
15:48:07 <FunctorSalad_> > concatMap (fst . ?eh) [1,2,3]
15:48:08 <lambdabot>   Unbound implicit parameter (?eh::a -> ([b1], b))
15:48:08 <lambdabot>    arising from a use of i...
15:48:10 <rasfar> Okay, installed GSL and hmatrix.  Now it wan't Data.Array.Vector.  Is there a standard way to find out the name of the required package when some module is missing?  Web search for Data.Array.Vector doesn't really do it.
15:48:12 <FunctorSalad_> ahh
15:48:38 <mauke> stulli: well, many1 should give you a list
15:48:44 <mauke> you can compute the length of that list
15:49:25 <mreh> rasfar us hackageDB to find the name of the missing packages
15:49:42 <rasfar> Thanks mreh!  Will try...
15:49:49 <stulli> mauke: Thanks, that was easy...
15:52:17 <mm_freak> > fix (fix (fix (fix (1:):):):)
15:52:18 <lambdabot>   [[[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:53:08 <chaosape> aavogt,FunctorSalad,lpjhjdh: Thanks for your help! Here is my working simple case - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11401#a11401
15:56:47 <rasfar> mreh: what's your compilation options, so we're on the same page?  I tried just ghc --make Main, and then tried with additional -XRankNTypes since errors suggested it.
15:57:06 <FunctorSalad_> chaosape: what does it do?
15:57:40 <mreh> with GHC it should compile the existentials fine, there's a single comment line at the top that turns that on
16:00:22 <chaosape> FunctorSalad: Generates a record from a set of variables.  It is a simplified case but I am going to use it so that I can have pluggable components in the software I am working on.  I geuss similar to how lambabot's modules work?
16:01:21 <rasfar> mreh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11402#a11402
16:01:34 * SimonRC goes
16:01:39 <mreh> lol, you're supposed to be helping me rasfar
16:01:50 <rasfar> sneaky ain't i?
16:02:15 <rasfar> at least i'm keeping it topical!
16:05:31 * hackagebot upload: mecha 0.0.1 - Mecha is a solid modeling language geared for machine design. (TomHawkins)
16:06:23 <skorpan> hey, that's not new
16:06:30 <skorpan> oh, maybe 0.0.0 was the first version
16:06:33 <copumpkin> yeah
16:06:38 <copumpkin> I remember being puzzled by a version of 0.00
16:07:01 <skorpan> i think i released my only hackage package as 0.0 initially
16:11:56 <chaosape> it seems like a companion to hpaste should be hcookbook.
16:13:01 <skorpan> can some function take itself as an argument in ghc (allowing all kinds of extensions)?
16:13:18 <skorpan> some type system super hack
16:13:22 <aavogt> > id id $ 2
16:13:24 <lambdabot>   2
16:13:34 <skorpan> ...
16:13:38 <sjanssen> skorpan: fix?
16:13:44 <skorpan> what an anti-climax
16:14:22 <skorpan> i don't know what i was thinking there
16:16:15 <shachaf> skorpan: You were probably thinking of (\x -> x x).
16:16:27 <skorpan> probably
16:16:46 <skorpan> so that's a function which applies its argument to itself
16:17:05 <Draconx> @let my_sum self x y = if x == 0 then y `asTypeOf` x else self (x - 1) (y + 1)
16:17:06 <lambdabot>  Defined.
16:17:14 <Draconx> > (fix my_sum) 3 4
16:17:15 <lambdabot>   7
16:17:22 <skorpan> :t asTypeOf
16:17:23 <lambdabot> forall a. a -> a -> a
16:17:24 <iaefai_> If you are composing two functions, say take and drop, and you want to drop first and then take, would it be    drop n . take n or take n . drop n?
16:17:28 <shachaf> @ty let f :: (forall a. a -> a) -> b -> b; f x = x x in f
16:17:29 <lambdabot> forall b. (forall a. a -> a) -> b -> b
16:17:36 <skorpan> iaefai_: take n . drop n
16:17:54 <dibblego> iaefai, read (.) from right to left or use (>>>) for left to right
16:18:08 <iaefai_> :t (>>>)
16:18:09 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:18:16 <skorpan> (don't use (>>>) just because you can)
16:18:22 <iaefai_> Category?
16:18:40 <skorpan> @src asTypeOf
16:18:41 <lambdabot> asTypeOf = const
16:18:52 <skorpan> i demand an explanation
16:19:01 <aavogt> @type const
16:19:03 <lambdabot> forall a b. a -> b -> a
16:19:05 <travisbrady> can anyone help me make sense of this error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11403#a11403 i'm following a trivial example from the Parsec docs to the letter
16:19:05 <aavogt> @type asTypeOf
16:19:07 <lambdabot> forall a. a -> a -> a
16:19:23 <iaefai_> travisbrady: parsec docs from its website or from ghc docs?
16:19:32 <dibblego> iaefai, approximately (a -> b) -> (b -> c) -> (a -> c)
16:19:42 <iaefai_> :t (.)
16:19:43 <skorpan> aavogt: it un-generalizes const?
16:19:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:20:06 <travisbrady> iaefai_: from http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Char.html#v%3AoneOf
16:20:17 <iaefai_> travisbrady: good, just checking :p;
16:20:36 <aavogt> skorpan: yeah, it's useful when you have ambiguous type variables
16:20:42 <iaefai_> Somebody said (.) was like (a -> b) -> (c -> a) -> f b
16:21:01 <dibblego> @type (.)
16:21:01 <iaefai_> So dibblego, does how this work in that context?
16:21:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:21:06 <dibblego> gah
16:21:12 <aavogt> @type (Prelude..)
16:21:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:21:15 <dibblego> (a -> b) -> (t -> a) -> (t -> b)
16:21:25 <travisbrady> iaefai_: ahh, -XNoMonomorphismRestriction takes care of it
16:21:48 <iaefai_> dibblego: the t is wierd
16:21:53 <iaefai_> I will forget I heard about >>>
16:22:35 <dibblego> iaefai, sure
16:22:54 <iaefai_> I need to do this: row n (Board s) = S.take 8 . S.drop (n * 8) s     will . be tighter than the s at the end, or do I need more brackets?
16:23:10 <dibblego> S.take 8 . S.drop (n * 8) $ s
16:23:14 <mauke> the latter
16:23:18 <iaefai_> lovely
16:23:22 <mauke> function calls > operators
16:23:28 <iaefai_> I was thnking $
16:23:39 <iaefai_> I wrote myself a little note yesterday about . and $, most helpful
16:24:30 <iaefai_> Awesome works
16:25:23 <dibblego> > head . reverse $ "abc"
16:25:24 <lambdabot>   'c'
16:25:30 <dibblego> > reverse >>> head $ "abc"
16:25:31 <lambdabot>   'c'
16:25:40 <skorpan> when i learned ($), i was taught to think that $ is like parentheses all the way from $ to the far right of that line
16:25:54 <samnardoni> Hey guys, for hackage, is there a command to be able to download/install packages remotely? Similar to rubygem's (gem install package)
16:26:08 <skorpan> samnardoni: there's cabal-install
16:26:24 <skorpan> e.g. "cabal install xmonad"
16:26:59 <samnardoni> ah, and that downloads it and installs it yeah?
16:27:08 <skorpan> yeah, and figures out the dependencies as well
16:27:14 <samnardoni> ah sweet :) cheers
16:27:40 <samnardoni> i think it should be made a bit clearer on the hackage website TBH ;)
16:28:54 <skorpan> samnardoni: i stalked you for a second and found your blog entry about html... i can imagine something like that being done pretty easily in haskell, so ditch the scala idea!
16:29:21 <samnardoni> yeah that's exactly what i had my eyes on :)
16:29:30 <samnardoni> im still trying to figure it out in my head atm
16:29:36 <samnardoni> just a bag of ideas atm
16:29:41 <samnardoni> what do you think of the idea?
16:30:01 <skorpan> i think it's great, i've had the same idea as well... it's probably been done already though, as everything in programming. :/
16:30:13 <samnardoni> yeah true
16:30:19 <skorpan> have you had a look at that ruby program "less" which is for css?
16:30:32 <skorpan> i've been thinking about writing the same thing in haskell
16:30:43 <skorpan> http://lesscss.org/
16:30:43 <samnardoni> yeah i have, it's quite a nice little program
16:30:54 <skorpan> when i tried it out it felt a bit buggy though
16:31:00 <samnardoni> i used SASS quite a lot, which was good
16:31:28 <skorpan> never tried that
16:31:40 <ddarius> XSLT
16:31:48 <samnardoni> i almost feel the whole HTML/CSS idea needs to be started from scratch haha
16:31:55 <skorpan> i hear you
16:32:16 <samnardoni> but, it's easier to critisize than to create
16:32:26 <skorpan> i wish there was some tool like less and sass which also takes care of ie6 for me... kind of like jquery for javascript. e.g. puts "display: inline" on anything with "float: left" and "margin-left" to avoid the double margin bug.
16:32:57 <samnardoni> yeah agreed
16:33:15 <skorpan> we could call this CCSS... compiled css!
16:33:27 <skorpan> or ReCSS which could be pronounced as "recess"
16:33:38 <samnardoni> i like reCSS :)
16:33:44 <skorpan> thinking of names for a tool is the most awesome part of writing software :)
16:33:59 <samnardoni> haha yeah
16:34:50 <samnardoni> i love programming, but finding a problem worth solving i feel is pretty hard
16:34:56 <skorpan> indeed
16:35:15 <samnardoni> the amount of times i find myself wanting to just code something, but no ideas what to do
16:35:26 <skorpan> same here, i feel you
16:35:27 <dmwit> hsakell_proposals.reddit.com
16:36:02 <sm> well, I have no idea what you're talking about :)
16:36:25 <dmwit> (Personally, I'm usually the other way... tons of ideas, and no time to do them.)
16:36:36 <tavelram> samnardoni, how about p=np? isnt that worth solving?
16:36:49 <samnardoni> dmwit: that's probably the best way round :)
16:36:58 <dmwit> tavelram: That's not exactly a coding problem.
16:37:13 <tavelram> then make it one :p
16:37:14 <skorpan> "it's provable, therefore uninteresting" --anonymous thinker
16:37:16 <samnardoni> tavelram: finding a problem _I_ could solve then ;)
16:37:55 <tavelram> samnardoni, why are you putting yourself down? :P
16:37:59 <jmcarthur> how bout making an html alternative then :)
16:38:26 <ddarius> jmcarthur: That's trivial.  Getting it adopted is hard.
16:38:27 <skorpan> a WYMIWYG HTML generator!
16:38:29 <jmcarthur> it's deceptively harder than it sounds, probably
16:38:43 <jmcarthur> ddarius: well, i said that because it was mentioned already ;)
16:39:26 <samnardoni> well, the program I was thinking of was more of a generator than a replacement
16:39:34 <jmcarthur> an HTML WYSIWYG generator!
16:40:02 <skorpan> it should be able to parse files with contents such as "everything is 760px wide. bar with full width: header. two boxes next to each other separated by 20px: content. bar with full width: footer."
16:40:54 <dmwit> http://thedailywtf.com/articles/omgwtf-finalist-06-omg!ocrcal.aspx
16:41:10 <jmcarthur> "i want it to work on every browser, and my logo should be at the top, and there should be an animated under construction sign, and i think i actually want the logo to be under that instead, and put a shopping cart in it with a music player. khtx"
16:41:19 <dmwit> "Zero is a large circle; One is either a long vertical line or a long vertical line a very small slash line top of first joins top of second; ..."
16:41:47 <skorpan> dmwit: cool
16:42:06 <tavelram> skorpan, jmcarthur, so just add html+css as a language to Grammatical Framework? :p
16:42:17 <jmcarthur> heh
16:42:43 <skorpan> tavelram: getting xhtml working in ie6 is probably harder than any natural language ;P
16:42:59 <tavelram> :)
16:43:23 <dmwit> The Next Big Thing: a browser, written in Java script, that runs embedded in IE6.
16:43:24 <m0nkfish> is there a prettier way of doing this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4545
16:43:46 <skorpan> dmwit: chrome can be embedded in IE, firefox is written in javascript... almost there.
16:44:06 <blackdog> tell sinelaw no, it doesn't. it should implement Binary, I just haven't added it because no-one asked and I didn't need it at the time.
16:44:19 <dmwit> :t filterM
16:44:20 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:44:31 <dmwit> > filterM (const [False, True]) [1..3]
16:44:32 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
16:44:48 <dmwit> m0nkfish: I may have misread your code, though.
16:44:49 <skorpan> > filterM (const [False, True]) [1..3]
16:44:50 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
16:45:00 <tavelram> dmwit, actually, the js-engine in ie6 is horribly bad, iirc eg exponential in code size for gc when the js-file is larger than 1mb. so youd probably want to implement a js-engine in js first, and then on top of that implement a browser ;)
16:45:01 <m0nkfish> this is a powerset i think
16:45:13 <skorpan> sure seems like it
16:45:14 <m0nkfish> a segment must guarantee consecutive members
16:45:16 <ddarius> dmwit: Been done.
16:45:34 <dmwit> > let segaux [] = []; segaux (x:xs) = [x : segs | segs <- [] : segaux xs] in segaux [1..3]
16:45:35 <lambdabot>   [[1],[1,2],[1,2,3]]
16:45:44 <dmwit> > inits [1..3]
16:45:45 <lambdabot>   [[],[1],[1,2],[1,2,3]]
16:45:49 <dmwit> m0nkfish: ?
16:45:50 <m0nkfish> heres the expected output: [[1],[1,2],[1,2,3],[2],[2,3],[3]]
16:46:05 <dmwit> > inits [1..3] >>= tails
16:46:06 <lambdabot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[]]
16:46:21 <dmwit> What do I win?
16:46:31 <m0nkfish> would it catch [2,3] in [1,2,3,4]
16:46:40 <dmwit> Try it. ;-)
16:46:42 <samnardoni> skorpan, where would you suggest i start with this whole HTML thing?
16:46:44 <dmwit> (yes)
16:46:49 <m0nkfish> > inits [1..4] >>= tails
16:46:50 <lambdabot>   [[],[1],[],[1,2],[2],[],[1,2,3],[2,3],[3],[],[1,2,3,4],[2,3,4],[3,4],[4],[]]
16:46:51 <samnardoni> any specific libraries to use?
16:46:57 <m0nkfish> cool i have no idea how that works
16:47:38 <MoALTz> "I felt an urge to participate in the contest: somehow its much more fun to write something creative and... err, useless. I used to write exclusively C++ code, so I felt qualified to give it a shot."
16:47:47 <dmwit> > let ensure p x = guard (p x) >> return x in inits [1..4] >>= tails >>= ensure (not . null)
16:47:49 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
16:48:01 <skorpan> samnardoni: i'm all talk no game, i barely know haskell ;P  how much haskell do you know?
16:48:02 <MoALTz> (from the link posted above)
16:48:16 <dmwit> MoALTz: Yeah, pretty funny. =)
16:48:18 <samnardoni> ah, im in the same boat :)
16:48:31 <m0nkfish> @index inits
16:48:32 <lambdabot> Data.List
16:48:59 <samnardoni> im coming from a ruby background, so my head is in OOP/imperitive mode
16:49:18 <jmcarthur> what would be a typical way to create a Set of MVars or IORefs? pair them with unique values of some type having an Ord instance (effectively a Map rather than a Set, of course)?
16:49:21 <dmwit> > [seqs | i <- inits [1..4], seqs <- tails i, not (null seqs)]
16:49:22 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
16:49:25 <dibblego> #haskell is full of counsellors
16:50:41 <dmwit> jmcarthur: That's a little strange.  Under what conditions are you going to have an MVar/IORef that you aren't sure is new?
16:50:59 <dmwit> jmcarthur: i.e. why wouldn't you simply use a list?
16:51:28 <skorpan> samnardoni: maybe you should read this: http://book.realworldhaskell.org/read/using-parsec.html
16:51:38 <skorpan> samnardoni: and any previous chapters if you feel the need
16:51:47 <jmcarthur> dmwit: this is for an STM implementation i'm making. it's a transaction log, and i only want one entry per TVar
16:51:58 <jmcarthur> because the order won't matter in this case
16:52:38 <samnardoni> skorpan: sweet, i'll check it now
16:52:42 <Cale> It's annoying that IORef has an instance of Eq but not Ord
16:52:44 <m0nkfish> what is the >>= function
16:52:45 <jmcarthur> and i don't want to traverse the same reference multiple times at commit/abort time
16:53:05 <Cale> It wouldn't be that hard to totally order IORefs in an arbitrary way so that they could be used with Data.Set, etc.
16:53:11 <jmcarthur> yeah
16:53:12 <dmwit> m0nkfish: In this case, it's concatMap, but with the arguments flipped.
16:53:19 <dmwit> ?src (>>=) []
16:53:19 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:53:24 <dmwit> ?src [] (>>=)
16:53:24 <lambdabot> xs >>= f     = concatMap f xs
16:53:56 <Cale> By the same token, StableNames have the same issue, despite the fact that they were *designed to be used as keys in memo tables*!
16:54:00 <jmcarthur> of course i wouldn't actually be able to use an Ord instance for IORef or MVar directly anyway since the log will have entries for more than one type
16:54:34 <dmwit> Do IORefs actually point to the same place across garbage collection runs?
16:54:34 <jmcarthur> i'm using existential quantification for the log
16:54:49 <dmwit> That seems like a dangerous assumption.
16:55:08 <tommd> very
16:55:23 <Cale> Perhaps it's a performance tradeoff.
16:55:32 <Cale> But they could just include an Int
16:55:45 <dmwit> m0nkfish: Did you see the list comprehension version?  It might be easier to understand than the non-determinism-monad version.
16:55:47 <jmcarthur> ah, might as well just do that on the haskell level though, i guess
16:56:57 <jmcarthur> i think i'll just tag my TVars with Ints
16:57:03 <Cale> Apparently the Eq instance for IORef is defined in terms of the Eq instance for STRef, which calls something called sameMutVar#
16:57:15 <skorpan> @src mconcat
16:57:15 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:57:45 <m0nkfish> dmwit: i find the list comprehension tough enough
16:57:51 <skorpan> @src Data.Monoid.mconcat
16:57:52 <lambdabot> Source not found. Take a stress pill and think things over.
16:57:54 <skorpan> WHY
16:58:00 <aavogt> @src [] mconcat
16:58:01 <lambdabot> Source not found. Just try something else.
16:58:24 <skorpan> mconcat = foldr mappend mempty
16:58:31 <skorpan> makes quite a bit of sense
16:58:31 <dmwit> > let hum = 1:undefined in ([seqs | i <- inits hum, seqs <- tails i, not (null seqs)], [seqs | t <- tails hum, seqs <- inits t, not (null seqs)])
16:58:32 <lambdabot>   (* Exception: Prelude.undefined
16:58:36 <Cale> Perhaps the garbage collector relocates MutVar#'s, in which case ordering them would be a bit expensive
16:58:47 <dmwit> > let hum = 1:undefined in [seqs | t <- tails hum, seqs <- inits t, not (null seqs)]
16:58:48 <lambdabot>   * Exception: Prelude.undefined
16:59:25 <dmwit> ah,
16:59:55 <dmwit> > let hum = 1:2:undefined in [seqs | t <- tails hum, seqs <- inits t, not (null seqs)]
16:59:56 <lambdabot>   [[1]* Exception: Prelude.undefined
17:00:10 <dmwit> > let hum = 1:2:undefined in [seqs | i <- inits hum, seqs <- tails i, not (null seqs)]
17:00:11 <lambdabot>   [[1]* Exception: Prelude.undefined
17:02:35 <m0nkfish> dmwit what are you doing now :S
17:07:48 <dmwit> m0nkfish: I was just comparing the laziness of two different implementations.
17:08:41 <FunctorSalad_> the great question: put arrows and (=>) in multiline types at the end of lines or at the beginning?
17:08:45 <m0nkfish> ah
17:08:49 <FunctorSalad_> (and what colour to paint the arrowshed?)
17:12:20 <m0nkfish> dmwit: segments4 l = filter (not.null) (concatMap inits (tails l))
17:12:25 <m0nkfish> this is the same right?
17:14:37 <ewd> haddock likes putting -> at end of line
17:15:36 <ewd> err wrong, haddock puts -> at beginning
17:16:33 <FunctorSalad_> it also puts sigs one one line although I linebroke them manually
17:17:20 <desp> I could use a pointer on passing a Haskell function as a callback to C code.
17:17:30 <ewd> If you want my opinion, do a mixture. It's a fashion statement. The message that plain text file is more trouble than worth.
17:24:46 <kyagrd> Was there a library that you can hoogle on GHCi and directs you to the html link of the document?
17:28:49 <dmwit> m0nkfish: That looks good, though I haven't run it at all. =)
17:29:23 <dmwit> ?quickcheck \xs -> filter (not . null) (concatMap inits (tails xs)) == [seqs | i <- inits xs, seqs <- tails i, not (null seqs)]
17:29:23 <lambdabot> Unknown command, try @list
17:29:28 <dmwit> ?list
17:29:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:29:38 <dmwit> ?check \xs -> filter (not . null) (concatMap inits (tails xs)) == [seqs | i <- inits xs, seqs <- tails i, not (null seqs)]
17:29:39 <lambdabot>   "Falsifiable, after 2 tests:\n[(),(),(),()]\n"
17:29:58 <dmwit> > filter (not . null) (concatMap inits (tails [(), (), (), ()]))
17:29:59 <lambdabot>   [[()],[(),()],[(),(),()],[(),(),(),()],[()],[(),()],[(),(),()],[()],[(),()]...
17:30:21 <dmwit> > [seqs | i <- inits [(), (), (), ()], seqs <- tails i, not (null seqs)]
17:30:22 <lambdabot>   [[()],[(),()],[()],[(),(),()],[(),()],[()],[(),(),(),()],[(),(),()],[(),()]...
17:30:38 <dmwit> ah
17:30:51 <dmwit> ?check \xs -> sort (filter (not . null) (concatMap inits (tails xs))) == sort [seqs | i <- inits xs, seqs <- tails i, not (null seqs)]
17:30:55 <lambdabot>   mueval-core: Time limit exceeded
17:31:04 <dmwit> Looks like it passes. =)
17:31:20 <dmwit> ?check \xs -> sort (filter (not . null) (concatMap inits (tails xs))) == sort [seqs | i <- inits (xs :: [Int]), seqs <- tails i, not (null seqs)]
17:31:24 <lambdabot>   mueval-core: Time limit exceeded
17:34:38 <dmwit> desp: Maybe http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-290005.4.2 ?
17:37:14 <dmwit> ?check \xs -> filter (not . null) (concatMap inits (tails xs)) == [seqs | t <- tails (xs :: [Int]), seqs <- inits t, not (null seqs)]
17:37:18 <lambdabot>   mueval-core: Time limit exceeded
17:42:22 <dmwit> ?check \xs -> filter (not . null) (concatMap inits (tails xs)) == [seqs | t <- tails (xs :: [Int]), seqs@(_:_) <- inits t]
17:42:26 <lambdabot>   mueval-core: Time limit exceeded
17:42:48 <dmwit> (_:_), the porn filter
17:47:12 <samnardoni> What would be the best way to represent a HTML document as a type?
17:47:26 <samnardoni> would i need recursive types?
17:48:05 <samnardoni> data Element = Text | Element     sort of thing
17:48:13 <ddarius> It depends on what operations you want to support well.
17:48:21 <Cale> samnardoni: Depends on how much of the well-formedness of the document you want to enforce
17:48:28 <Cale> and yeah, the operations
17:48:56 <samnardoni> Hmm, i'm not too sure at the moment
17:51:12 <mmorrow> samnardoni: you'd probably want a tree of some form
17:51:38 <mmorrow> samnardoni: you could look at the xhtml package's code for an example
17:52:23 <mmorrow> although you need to look at the code since the representation of the Html type isn't exported
17:53:07 <mmorrow> err, and the rep is in an internal module too
17:54:34 <mmorrow> samnardoni: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11404#a11404
17:54:44 <mmorrow> http://darcs.haskell.org/libraries/xhtml/Text/XHtml/Internals.hs
17:55:38 <dmwit> Yeah, my first recommendation would be "don't make your own type".
17:55:48 <dmwit> There's half a dozen different representations of HTML documents out there.
17:56:04 <dmwit> Pandoc, WASH, xhtml, etc.
17:58:37 <samnardoni> Ah, i'm stuck between re-inventing the wheel for learning purposes and uses other code
17:58:41 <samnardoni> decisions, decisions!
17:59:38 <samnardoni> is this a valid definition?... data Element = String | Element
18:00:01 <dibblego> yes
18:00:17 <dibblego> though you may as well use Bool
18:00:40 <samnardoni> how do you mean?
18:00:47 <kmc> i don't agree
18:00:55 <Vanadium> You are defining two nullary data constructors
18:00:58 <copumpkin> I generally don't agree, but I'm not a fan of the repetition
18:01:06 <copumpkin> Vanadium: so why not make them descriptive instead of generic?
18:01:06 <samnardoni> ah
18:01:17 <samnardoni> what would be a better way of doing this?
18:01:18 <kmc> there's a point to isomorphic types that aren't equal
18:01:24 <copumpkin> yeah, definitely
18:01:28 <kmc> types exist in order to express and prove properties of program
18:01:30 * copumpkin mumbles Either
18:01:33 <Vanadium> I expected you want data Element = TextNode String | Element Element or something
18:01:33 <kmc> not to specify representation
18:01:47 <kmc> however, i don't generally like types with multiple ctors where one has the same name as the type
18:01:53 <copumpkin> yeah
18:02:02 <kmc> i tend to reuse the type name iff it has one ctor
18:02:30 <samnardoni> Valodim: ah, so TextNode would be a constructor? and  Element would be?
18:02:30 <copumpkin> yeah
18:02:42 <mmorrow> samnardoni: a constructor
18:02:47 <Vanadium> another one
18:03:06 <mmorrow> samnardoni: holding a value of type Element
18:03:31 <mmorrow> you'd probably want
18:03:34 <copumpkin> that data Element = TextNode String | Element Element doesn't look very useful either
18:03:50 <copumpkin> you might as well just keep only the TextNode half, unless you care about bottoms
18:04:00 <kmc> is anyone here willing to help me do some multicore performance tweaking?
18:04:18 <samnardoni> copumpkin, but wouldnt that mean than an element couldn't contain another element?
18:04:27 <mmorrow> data Element = TextNode String | Element [Element]
18:04:33 <copumpkin> that's more like it :)
18:04:34 <kmc> samnardoni, how do an element x and the Element containing the element x differ?
18:04:35 <Apocalisp> kmc: Willing? Sure. Able? Maybe.
18:05:07 <mmorrow> but more useful/compact would be
18:05:11 <kmc> okay, so i'm learning the parallel and concurrent stuff by rendering mandelbrot sets
18:05:15 <mmorrow> data Element a = Element a [Element]
18:05:19 <mmorrow> data Element a = Element a [Element a]
18:05:34 <mmorrow> , src ''Tree
18:05:38 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
18:05:39 <Vanadium> Elements probably also need a bunch of attributes
18:05:48 <mmorrow> data Tree a = Node a [Tree a]
18:06:01 <kmc> i did a version with parMap and it was pretty good, about 140% productivity on a 2-core machine (don't remember the exact figure, it was a while ago)
18:06:12 <kmc> so that's pretty good for very little effort, but i wanted to make it faster
18:06:14 <samnardoni> would that support an element containing a string and an element?
18:06:27 <kmc> so i figured the next step was to render to an IOUArray and fork threads explicitly
18:06:35 <kmc> which is this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11361
18:06:42 <mmorrow> type Html tag attr = Tree (tag,[attr])
18:07:18 <mmorrow> well
18:07:21 <mmorrow> content too
18:07:31 <mmorrow> type Html tag attr a = Tree (tag,[attr],a)
18:07:39 <samnardoni> I never even considered attributes haha
18:08:09 <samnardoni> i think this is a bit out of my depth at the moment
18:08:13 <kmc> and it gets no better than 175% even with the (serial) "writePPM" step disabled
18:08:19 * Axman6 thinks the tuple is redundant there
18:08:25 <samnardoni> first encounters i've had with declaring data types
18:08:50 <mmorrow> data Html tag attr a = Node tag [attr] a [Html tag attr a]
18:09:08 <mmorrow> is that type flattened and specialized
18:09:09 <kmc> so i'm wondering what more if anything i can improve
18:09:44 <kmc> it's not spending much time on GC
18:09:52 <samnardoni> mmorrow, so how would i go about using that data type?
18:09:58 <samnardoni> (im super new to this stuff)
18:10:57 <yitz> mmorrow: does a represent content inside the tag or at the same level?
18:11:01 <mmorrow> Node "html" [] "" [Node "body" [] "" [Node "p" [] "asdfghjk" []]]
18:11:09 <mmorrow> yitz: yeah, that's kind of annoying
18:11:20 <mmorrow> hrm
18:11:29 <samnardoni> ah nice :)
18:11:53 <mmorrow> data Html tag attr a = Data a | Node tag [attr] [Html tag attr]
18:11:57 <mmorrow> maybe
18:12:18 <mmorrow> Node "html" [] [Node "body" [] [Data "asdfghjk"]]
18:12:50 <mmorrow> :: forall attr. Html String [attr] String
18:13:00 <mmorrow> Node "html" [] [Node "body" [42::Int] [Data "asdfghjk"]]
18:13:06 <mmorrow> :: Html String [Int] String
18:13:31 <mmorrow> if you know that you only want e.g. String tags and String attributes, then you could specialize the datatype
18:13:54 <Apocalisp> kmc: 175% out of how much available?
18:14:02 <mmorrow> type Tag = String; type Attr = String; data Html a = Data a | Node Tag [Attr] [Html a]
18:14:38 <mmorrow> and to render it, you could do e.g.   render :: (a -> String) -> Html a -> String
18:14:40 <Axman6> might Attr be better if it were type Attr = (String, String)?
18:14:49 <Vanadium> type Html = Ptr xmlDocument; foreign import libxml2
18:14:51 <mmorrow> Axman6: good point
18:15:10 <Axman6> somewhat enforces the foo=bar-ness
18:15:23 <Vanadium> Axman6: Also lets you use lookup
18:15:28 <Axman6> indeed :)
18:15:48 <Axman6> hey, let's create a new HTML library! :o
18:16:00 <tavelram> and enforcing that values always are quoted
18:16:19 <Axman6> and we could blog about it, and show that it only took us like an hour
18:16:40 <Vanadium> We need to come up with a way to shoehorn the list monad into it though
18:17:19 <mmorrow> Axman6: the blog would need to be rendered using it, naturally
18:17:26 <Axman6> of course :)
18:17:52 <Axman6> and it'd need a nice DSL for writing html in it
18:18:00 <kmc> Apocalisp, varies.  maybe 195%
18:18:23 <samnardoni> mmorrow: would that work for this:     <p><b>Hello</b>mmorrow</p>     as the element contains data and a node inside the data?
18:19:00 <mmorrow> Node "p" [] [Node "b" [] [Data "Hello"], Data "mmorrow"]
18:19:04 <m0nkfish> could anyone give me a better definition of this function: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4546
18:20:01 <fxr> is there any Network.SSL package?
18:20:02 <tavelram> mmorrow, youre missing one ]
18:20:04 <Vanadium> @pl change cs m = [x:rest | x<-cs, rest<-[]:(change (filter (x<=) cs) (m-x)), x+(sum rest) == m]
18:20:05 <lambdabot> change = fix (ap ((.) . (:) . (x :) . ((rest | x) <-)) . flip flip (return . (x + sum rest ==)) . (liftM2 ((:) . (rest <- [] :)) .) . flip flip (subtract x) . ((.) .) . (. filter (x <=)))
18:20:09 <Vanadium> there you go~
18:20:22 <samnardoni> mmorrow: what about <p>Hello<b>mmorrow</b>again</p>?
18:20:23 <m0nkfish> i prefer mine
18:20:25 <mmorrow>  ] {- :) -}
18:20:40 <Axman6> m0nkfish: so you should
18:20:42 <Vanadium> use <strong>, damn it
18:20:48 <Axman6> (rest <- [] :))
18:20:50 <mmorrow> Node "p" [] [Data "Hello", Node "b" [] [Data "mmorrow"], Data "again"]
18:20:52 <mmorrow> ]
18:20:52 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
18:20:57 <m0nkfish> yeah see i learned :)
18:21:12 <samnardoni> ohhh, so data can have a node inside too?
18:21:26 <m0nkfish> i cant help but think there is a far more elegant way to do it though
18:21:28 <mmorrow> data Html tag attr a = Data a | Node tag [attr] [Html tag attr]
18:21:58 <mmorrow> samnardoni: if you had a (Data <Data or a Node here>), then that would have type
18:22:02 <Axman6> mmorrow: hmm, maybe you could enforce the tag types too, by having data Tag = Html | Par | Strong | ...
18:22:04 <mmorrow> Html tag attr (Html ..)
18:22:43 <mmorrow> Axman6: sure, if Html is parametric in the tag type, you could do anything like that
18:22:52 <Axman6> yeah
18:23:30 <mmorrow> samnardoni: so i think you're stuck on something having to do with the list inside a "Node" tag having a mixture of Data and Node contructors in it?
18:23:41 <Axman6> seems to be that if you did what i said, you could validate HTML fairly easily
18:23:46 <samnardoni> yeah
18:24:00 <samnardoni> this is my first time using 'data'
18:24:00 <mmorrow> @type [Nothing, Just 42, Just 0]
18:24:01 <lambdabot> forall a. (Num a) => [Maybe a]
18:24:35 <mmorrow> Node () () [Data 42, Node () () [Data 42]] :: Html () () Int
18:24:41 <mmorrow> (Node () () [Data 42, Node () () [Data 42]]) :: Html () () Int
18:24:48 <samnardoni> just trying to get my head around t all
18:24:55 <mmorrow> :)
18:25:20 <Axman6> samnardoni: do you understand things like: data List a = Nil | Cons a (List a)?
18:25:41 <samnardoni> not really, to be honest
18:25:44 <Axman6> and how you can then say: Cons 2 (Cons 4 (Cons 0 Nill))
18:25:50 <Axman6> -l
18:26:17 <samnardoni> Axman6, care to explain :P
18:26:25 <Axman6> samnardoni: what don't you get?
18:26:35 <samnardoni> data List a = Nil | Cons a (List a)
18:27:15 <samnardoni> (sorry if i sound a bit like an idiot, i've got too much OOP in my veins)
18:27:28 <Axman6> data List a = Nil | Cons a (List a) says that a List with a's in it is either Nill (empty), or it is a pair with an a, and another list, which could be empty, or contain another Cons
18:27:40 <Axman6> samnardoni: bah, we'll detox you soon enough :)
18:27:50 <samnardoni> ah yeah i get it :)
18:28:11 <samnardoni> i'm starting to like it more and more
18:28:14 <samnardoni> feels a lot closer to math
18:28:20 <Axman6> so, now when you read data List a = Nil | Cons a (List a), you know what it's saying right?
18:28:28 <Axman6> samnardoni: yes indeed :)
18:28:51 <samnardoni> yeah i understand it vaguely
18:28:59 <Axman6> samnardoni: ok, so, what about this: data BTree a = Tip a | Node a (BTree a) (BTree a)?
18:29:02 <kmc> i think we shouldn't diss on OOP so much as the dreadful implementation and use of OOP in languages like C++
18:29:18 <kmc> OOP in Python is pleasant.  it's a very different world from haskell of course
18:29:28 <Zao> More like the blessed hashes of Perl.
18:29:41 <cristianpane> hi
18:29:59 <cristianpane> hello!
18:30:16 <samnardoni> Axman6: a BTree of type a either has a Tip of type a, or has a Node which contains 2 more BTree's with type a?
18:30:48 <Axman6> samnardoni: yep, and what sort of structure is that? (don't feel bad if you don't see it right away)
18:30:50 <cristianpane> anyone can help me?
18:30:55 <kmc> cristianpane, probably
18:30:58 <m0nkfish> can i make use of currying to eliminate the "l" variable here: perms l = filter (\x -> length x == length l) $ permutations l
18:31:01 <kmc> ask your question and we'll see :)
18:31:01 <Axman6> cristianpane: not if you don't ask your question
18:31:02 <samnardoni> binary tree?
18:31:08 <Axman6> samnardoni: well done :)
18:31:16 <samnardoni> :)
18:31:30 <cristianpane> i have a trouble when I try transalete C code to Haskell code
18:31:50 <samnardoni> recursion doesn't feel natural for me... yet
18:31:51 <Axman6> cristianpane: well, Haskell is nothing like C, so i'm not surprised
18:32:03 <dibblego> @type (filter . (. length) . (==) . length) <*> permutations
18:32:04 <lambdabot> forall a. [a] -> [[a]]
18:32:10 <kmc> cristianpane, i'm not surprised
18:32:18 <kmc> cristianpane, if you upload your code to hpaste.org we can take a look
18:32:32 <samnardoni> i like how helpful everyone is in here :)
18:32:33 <Axman6> cristianpane: it's possible to do, but it's very ugly, and highly unrecommended
18:32:43 <Axman6> samnardoni: haskell's best asset is its community
18:34:37 <mmorrow> samnardoni: one thing that might be helpful if you're coming from e.g. C and structs, is that every haskell value is basically a ptr
18:34:50 <mmorrow> samnardoni: data A a = A a | B (A a)
18:35:01 <mmorrow> well, say
18:35:10 <mmorrow> data A = A Int | B A
18:35:17 <mmorrow> struct {
18:35:18 <mmorrow> bah
18:35:22 <mmorrow> data A = A Int A
18:35:53 <Axman6> yeah, | doesn't play well with the struct analagy :P
18:35:54 <mmorrow> struct A {int a; struct A* b;}
18:35:59 <Axman6> o*
18:36:26 <samnardoni> ahhhh
18:36:30 <samnardoni> that clears it up a bit
18:36:31 <mmorrow> any type that's recursive has to have ptrs
18:37:33 <kmc> haskell encourages you not to think at the level of pointers though
18:37:37 <Axman6> samnardoni: so, data List a = Cons a (List a) (forgetting the Nil, you can use NULL... yuck), you'd get struct List { a head; struct List* tail};
18:37:41 <kmc> especially since things are immutable, so aliasing is irrelevant
18:37:42 <mmorrow> in haskell you just don't have to explicitly deal with them
18:38:12 <samnardoni> ah yeah that's starting to make sense now :)
18:38:52 <kmc> haskell, the language, is an abstract machine without a notion of addresses or pointers
18:39:01 <m0nkfish> could someone give me a simple example of >>
18:39:15 <kmc> m0nkfish, (putStrLn "hi" >> putStrLn "bye")
18:39:15 <Zao> print "lol" >> f
18:39:22 <kmc> it's like C's semicolon
18:39:33 <kmc> monads == "operator overloading for C's semicolon"
18:39:39 <Axman6> > [1,2,3] >> [4,5,6]
18:39:40 <lambdabot>   [4,5,6,4,5,6,4,5,6]
18:39:54 <kmc> > [1,2] >> [4,5,6]
18:39:55 <lambdabot>   [4,5,6,4,5,6]
18:39:55 <Zao> do { putStrLn "hi"; putStrLn "bye" } desugars to (putStrLn "hi" >> putStrLn "bye")
18:40:06 <m0nkfish> :S
18:40:58 <m0nkfish> ok i need to study monads
18:41:39 <kmc> m0nkfish, the advice i give everyone: learn the Maybe or List monad first
18:41:39 <Axman6> m0nkfish: it runs the thing before, before returning the thing after being run... sort of
18:41:43 <kmc> IO is not a typical monad
18:41:47 <Axman6> yeah
18:42:02 <kmc> the meaning of "before" and "after" is defined by the monad you're using
18:42:05 <Axman6> > Just 4 >> Just "ok"
18:42:06 <lambdabot>   Just "ok"
18:42:11 <kmc> > Nothing >> Just "ok"
18:42:11 <Axman6> > Nothing >> Just "ok"
18:42:12 <lambdabot>   Nothing
18:42:13 <lambdabot>   Nothing
18:42:14 <kmc> heh
18:42:15 <yitz> > [Nothing >> Just 1, Just 2 >> Nothing, Just 3 >> Just 4]
18:42:16 <lambdabot>   [Nothing,Nothing,Just 4]
18:42:30 <Axman6> oi! quit stealing my examples :P
18:42:55 <yitz> oops, wasn't watching while I typed, sorry Axman6
18:43:17 <Axman6> that was for kmc, your example was superior ;)
18:44:41 <Axman6> cristianpane: could you paste your question here please? also i recommend you a) go and read a good tutorial (http://www.learnyouahaskell.com) and b) forget about trying to translate C to haskell, it won't be fun. they're extremely different languages
18:45:19 <kmc> cristianpane, another good tutorial: http://www.realworldhaskell.org
18:45:53 <Axman6> oh hooray, i actually got the lyah url right
18:46:24 <yitz> @where lyah
18:46:24 <lambdabot> www.learnyouahaskell.com
18:46:39 <samnardoni> mmorrow: just thinking, wouldn't the Data part be... Data String ... rather than ... Data a?
18:47:11 <yitz> > return 5 >> throwError "oops" >> return 6 :: Either String Int
18:47:12 <lambdabot>   Left "oops"
18:47:32 <yitz> > return 5 >> return 6 :: Either String Int
18:47:33 <lambdabot>   Right 6
18:52:40 <Axman6> samnardoni: so, could you now go and define a data type BTree a which can either be empty, have a tip with an element, or a node with an element, and two branches?
18:54:30 <copumpkin> BTree a = nu X. 1 + a + (X * a * X) ?
18:54:46 <copumpkin> is that correct?
18:54:50 <Axman6> you're such a jerk
18:54:51 <Axman6> :P
18:55:01 <Axman6> nu X?
18:55:20 <copumpkin> or mu
18:55:27 <copumpkin> it's like a fix for types
18:55:57 <Axman6> oh, the type Mu f = M (f (Mu f)) one?
18:56:17 <copumpkin> yeah
18:56:41 <samnardoni> data BTree a = Nil | Tip a (Element) | Node a (Element) (BTree a) (Btree a)
18:56:43 <samnardoni> i know thats wrong
18:56:46 <samnardoni> but my best guess haha
18:57:02 <copumpkin> it's almost right, but you have this weird (Element) stuff in there
18:57:08 <Axman6> remove all the "(Element)" bits, and it's correct :)
18:57:21 <samnardoni> thought you said something about an element haha
18:57:30 <copumpkin> a is the element
18:57:36 <samnardoni> ahh
18:57:39 <samnardoni> makes sense haha
18:58:51 <samnardoni> type Tag = String; type Attr = (String, String)
18:58:51 <samnardoni> data Html tag attr a = Data a | Node tag [attr] [Html tag attr]
18:59:05 <samnardoni> with that, does that mean I could put anything inside Data?
18:59:15 <samnardoni> or should it be... Data String?
18:59:15 <Axman6> samnardoni: the a is something that can be replaced with another type
18:59:25 <aavogt> as long as the tag is the same for each Html
18:59:38 <Axman6> yep, you could have anything (but all the a's would have to be the same)
18:59:48 <samnardoni> ah
18:59:56 <samnardoni> but they should only be strings in there
19:00:02 <samnardoni> would Data String work?
19:00:12 <Axman6> yes
19:00:15 <aavogt> then put String on the right hand side
19:00:33 <aavogt> data Html a = Data a | Node String [String] [Html a]
19:01:02 <Axman6> or you could have data Html tag attr = Data String | Node tag [attr] [Html tag attr]
19:01:30 <samnardoni> so the 'a' is not really needed?
19:01:45 <samnardoni> if i know im using a String
19:01:47 <aavogt> it depends what you want to do with the data
19:02:14 <samnardoni> well, the data should only be a string really, shouldn't it?
19:02:22 <samnardoni> i can't think of any reason for it not to be
19:02:31 <Axman6> samnardoni: you might also find it useful though to have the a, and have a version where the a could only be a type that implements Show
19:03:37 <aavogt> Axman6: why not put that constraint on the functions that manipulate the data instead?
19:03:48 <Axman6> well, that's really what i meant
19:04:14 <aavogt> data X a = Show a => X a -- I think this is legal
19:04:29 <aavogt> or some variation on that
19:04:32 <kmc> aavogt, iirc it doesn't do what you want for a regular H98 type
19:04:42 <kmc> it doesn't provide the typeclass context where X is used
19:04:48 <kmc> in a GADT definition it does
19:06:33 <kmc> ah, that one's fine
19:06:48 <kmc> but "data (Show a) => X a = X a" does not
19:08:54 <mmorrow> samnardoni: right, it could be Data String if you wanted, but otoh it could be convenient for it to be able to hold an arbitrary type
19:09:05 <mmorrow> samnardoni: then get collapsed to String when you render it
19:09:21 <mmorrow> samnardoni: since e.g. say you're rendering arbitrarily nested tables
19:10:01 <mmorrow> data Table a = Cell a | Tab [[Table a]]
19:10:07 <mmorrow> Html tag attr (Table a)
19:10:28 <Axman6> samnardoni: if you kept the a, instead of String, you could have a function which does: renderHTML :: (Show attr, Show tag, Show a) => Html tag attr a -> String
19:10:35 <mmorrow> would probably be easier to work with than having to collapse the table immediately to String before you even start laying them out
19:11:10 <samnardoni> ah i think i get it
19:11:13 <mmorrow> Html tag attr (Table (Html tag attr a) {- Html of arbitrarily nested tables of Html -}
19:11:34 <mmorrow> also you could make Html an instance of Functor
19:12:06 <mmorrow> instance Functor (Html tag attr) where fmap f (Data a) = Data (f a); fmap f (Html t a xs) = Html t a ((fmap . fmap) f xs)
19:12:28 <Axman6> fmap . fmap, gross :(
19:12:41 <EvilTerran> fmap fmap fmap!
19:12:44 * Axman6 thinks map (fmap f) is much clearer
19:12:45 <mmorrow> then you can do   (\html -> fmap show html) :: (Show a) => Html tag attr a -> Html tag attr String
19:12:47 <mmorrow> e.g.
19:13:09 <samnardoni> i think all that is too over my head atm :)
19:13:14 <mmorrow> , ppDoc <$> fmaps 8
19:13:17 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
19:13:21 <mmorrow> :)
19:13:29 <Axman6> yeah, i had a feeling it might be samnardoni, but you'll learn it soon enough :)
19:13:30 <Draconx> :t fmap fmap fmap fmap fmap
19:13:31 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => (a1 -> b) -> (a -> a1) -> f a -> f b
19:13:40 <EvilTerran> , typ 'fmap
19:13:41 <Draconx> with five fmaps, you get a fairly normal type again :)
19:13:41 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]'
19:13:44 <EvilTerran> ,ty 'fmap
19:13:45 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name -> a'
19:13:59 <EvilTerran> er
19:14:04 <mmorrow> , fmap (*2) (Node 1 [Node 2 [], Node 3 [Node 4 []]])
19:14:05 <lunabot>  Node {rootLabel = 2, subForest = [Node {rootLabel = 4, subForest = []},No...
19:14:09 <EvilTerran> ,[$typ| fmaps |]
19:14:10 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
19:14:13 <EvilTerran> ,[$ty| fmaps |]
19:14:16 <lunabot>  Int -> ExpQ
19:14:17 <mmorrow> , flatten (Node 1 [Node 2 [], Node 3 [Node 4 []]])
19:14:18 <lunabot>  [1,2,3,4]
19:14:22 <EvilTerran> (sorry, got there eventually)
19:14:24 <mmorrow> , flatten (fmap show (Node 1 [Node 2 [], Node 3 [Node 4 []]]))
19:14:26 <lunabot>  ["1","2","3","4"]
19:14:35 <mmorrow> , flatten (fmap (show . replicate 2) (Node 1 [Node 2 [], Node 3 [Node 4 []]]))
19:14:36 <lunabot>  ["[1,1]","[2,2]","[3,3]","[4,4]"]
19:14:44 <Axman6> samnardoni: actually, Functor is probably very worthwhile learning, as it's a great introduction to classes
19:14:46 <mmorrow> samnardoni: nah, fmap is easy :)
19:15:02 <Axman6> @src Functor
19:15:03 <lambdabot> class  Functor f  where
19:15:03 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:15:25 <mmorrow> samnardoni: it just walks the structure all the way to the bottom, applying the function at each step of the way
19:15:45 <mmorrow> for list, fmap = map
19:15:58 <mmorrow> data A a = A a | B a (A a)
19:16:06 <Axman6> @src Maybe fmap
19:16:07 <mmorrow> instance Functor A where fmap f (A a) = A (f a)
19:16:07 <lambdabot> fmap _ Nothing       = Nothing
19:16:07 <lambdabot> fmap f (Just a)      = Just (f a)
19:16:15 <Axman6> @src Either fmap
19:16:16 <lambdabot> fmap _ (Left x) = Left x
19:16:16 <lambdabot> fmap f (Right y) = Right (f y)
19:16:18 <mmorrow> fmap f (B x a) = B (f x) (fmap f a)
19:16:27 <EvilTerran> haskell's Functors are a very specific case[*] of their category-theoretic namesake, and the trouble with category theory is in its complexity, so they're not so bad :)
19:16:40 <mmorrow> Functor instances are very mechanical to write, once you see the pattern
19:16:43 <cristianpane7> anyone know a function to read limited characters in a file.txt?
19:16:54 <EvilTerran> [*]: endofunctors on Hask (the category of haskell types and functions, iirc)
19:17:10 <Axman6> cristianpane7: why did you leave earlier without asking your question?
19:17:15 <EvilTerran> (not that that's at all relevant to understanding them from a Haskell perspective)
19:17:16 <samnardoni> ah i see :)
19:17:36 <cristianpane7> sry,I was afk
19:17:36 <EvilTerran> er, s/complexity/generality/
19:18:10 <Axman6> @hoogle FilePath -> IO String
19:18:10 <lambdabot> Prelude readFile :: FilePath -> IO String
19:18:10 <lambdabot> System.Directory getAppUserDataDirectory :: String -> IO FilePath
19:18:10 <lambdabot> System.IO readFile :: FilePath -> IO String
19:18:23 <Axman6> cristianpane7: you can use readFile and take
19:18:26 <Axman6> :t readFile
19:18:28 <lambdabot> FilePath -> IO String
19:18:31 <Axman6> :t take
19:18:32 <lambdabot> forall a. Int -> [a] -> [a]
19:18:38 <HaudRex> I'm beginning to be of the opinion that learning should go HOFs, folds, monads.
19:19:03 <Axman6> do { contents <- readFile "file.txt"; print (take 10 contents)}
19:19:58 <Axman6> cristianpane7: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19:20:45 <Berengal> Axman6, leaks a file descriptor
19:20:49 <mmorrow> , fix (Mu . Just)
19:20:50 <cristianpane7> oks axman6 thks,
19:20:51 <lunabot>  Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu (Just (Mu ...
19:21:24 <Axman6> ,ty (fix (Mu . Just))
19:21:26 <lunabot>  luna: Couldn't match expected type `Luna.Mu.Mu Data.Maybe.Maybe -> a'
19:21:30 <Axman6> -_-
19:21:49 <Berengal> cristianpane7, use withOpenFile and hGetContents instead
19:22:00 * Axman6 gets the feeling that Mu Maybe isn't very useful
19:22:08 <Berengal> Sorry, withFile
19:22:23 <Berengal> Axman6, it's the natural numbers
19:22:25 * Axman6 doesn't do IO, so doesn't know about files in haskell really
19:22:38 <samnardoni> data HTML = Content String | Node String [(String, String)] [HTML]
19:22:42 <samnardoni> does that look OK?
19:22:57 <mmorrow> samnardoni: yes
19:23:01 <Berengal> Axman6, I know just enough to know that lazy IO is bad, and if you want to slurp a file, remember to seq last
19:23:05 <samnardoni> (just playing around with different ways of doing it so i can get my head around it a bit easier)
19:23:10 <Axman6> samnardoni: looks alright, you could pretty it up a little, with some more types (for clarity)
19:23:30 <mmorrow> samnardoni: that exactly the specialized form of that earlier def that i'd use if i were to specialize it
19:23:51 <Axman6> type Attr = (String, String); type Tag = String
19:24:07 <samnardoni> ah yeah, but i remember seeing..  HTML tag attr = BLABLABLA ...
19:24:14 <Axman6> heh
19:24:17 <samnardoni> so i took it out haha
19:24:19 <mmorrow> yeah, few type synonyms are nice especially for distinguishing difference uses of String
19:24:23 <samnardoni> it was confusing me
19:24:41 <mmorrow> well, actually i'd probably use
19:24:43 <samnardoni> yeah, i would put in more types for real world use, just using it to get my head around :)
19:24:45 <ewd> Hahaha "Luna Mu Mu" "Data Maybe Maybe" "Cat Meow Meow" "Dog Puppy Puppy"
19:24:54 <mmorrow> data HTML a = Content a | Node String [(String, String)] [HTML a]
19:25:18 <mmorrow> instance Functor HTML where fmap f (Content a) = Content (f a)
19:25:35 <mmorrow> fmap f (Node tag attrs xs) = Node tag attrs (fmap (fmap f) xs)
19:25:43 <Axman6> no fmap fmap!
19:25:46 <Axman6> quit that
19:25:55 <Axman6> you're confusing the noobs!
19:25:55 <mmorrow> i despise fmap fmap
19:26:06 <Axman6> i should hope so
19:26:19 <copumpkin> :t fmap fmap fmap
19:26:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:26:22 <mmorrow> i just mean using fmap for (.)
19:26:24 <samnardoni> my brain isn't far off imploding
19:26:34 <Axman6> heh
19:26:35 <mmorrow> fmap f (Node tag attrs xs) = Node tag attrs (map (fmap f) xs)
19:26:38 <mmorrow> fmap f (Node tag attrs xs) = Node tag attrs (fmap (fmap f) xs)
19:26:40 <mmorrow> are the same
19:26:41 <Berengal> I prefer fmap g . f to (g.).f
19:27:00 <Axman6> i don't like either of them
19:27:00 <copumpkin> :t (.) . (.) . (.) . (.) . (.) . (.)
19:27:01 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) a b (f5 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5) => (a -> b) -> f (f1 (f2 (
19:27:01 <lambdabot> f3 (f4 (f5 a))))) -> f (f1 (f2 (f3 (f4 (f5 b)))))
19:27:16 <mmorrow> if you guys want to see an EPIC functor instance ...
19:27:22 <copumpkin> I prefer monic
19:27:24 * mmorrow pastes
19:27:30 <camio> Wow, the finally tagless paper is blowing my mind.
19:28:47 <mmorrow> i think i have carpal tunnel syndrome now http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4547#a4547
19:29:03 <copumpkin> lol
19:29:08 <copumpkin> beautiful
19:29:17 <copumpkin> whose bytecode is that?
19:29:42 <mmorrow> it's an intermediate lang i'm using in my interp/compiler thing that never seems to be done
19:29:48 <copumpkin> ah
19:30:03 <mmorrow> s/done/working from start-to-finish/
19:30:23 <copumpkin> needs some of edwardk's secret JIT
19:30:40 <kmc> isn't there some kind of TH to do that for you?
19:31:01 <Axman6> mmorrow: what's it an interpreter/comiler for?
19:31:27 <mmorrow> kmc: probably, but the thing is that it's tricky with stuff like e.g. ... | Foo (Maybe [Maybe (Foo a)]) .. | ...
19:31:40 <mmorrow> fmap f (Foo a) = Foo ((fmap . fmap . fmap . fmap) f a)
19:32:17 <mmorrow> so you need to know that (1) Maybe's a Functor, (2) [] is a Functor, (3) the type Foo is a part of is a Functor (but only because you're currently making it one!)
19:32:33 <mmorrow> so it's non-trivial in non-trivial cases
19:32:46 <mmorrow> Axman6: a lazy functional language
19:33:02 <mmorrow> Axman6: i've hooked ghc up as a front end, using external core
19:33:13 <samnardoni> Couldn't match expected type `HTML a'
19:33:13 <samnardoni>        against inferred type `[Char]'
19:33:14 <Axman6> what features does it have?
19:33:22 <mmorrow> just finished fully eradicating all mention of ghc primops and translating to my own
19:33:22 <copumpkin> mmorrow: as a front end?
19:33:27 <samnardoni> is what i'm getting with... Node "html" ("", "") [ "HELLO" ]
19:33:30 <mmorrow> copumpkin: right
19:33:32 <Axman6> samnardoni: care to paste the code?
19:33:43 <samnardoni> data HTML a = Content a | Node Tag Attr [HTML a]
19:33:43 <Axman6> samnardoni: ah, you need Content "HELLO"
19:33:52 <samnardoni> oh yeah :)
19:33:54 <copumpkin> mmorrow: oh, so you're a new backend for haskell?
19:33:56 <mmorrow> Axman6: it's a bytecode interpreter, with the GC/interp/rts written in C
19:34:09 <mmorrow> copumpkin: that's what i'm shooting for, yes :)
19:34:10 <copumpkin> ah
19:34:16 <Axman6> sounds good
19:34:18 <blackdog> mmorrow: what's the motivation for it?
19:35:17 <mmorrow> blackdog: to have a bytecode interp / code gen that is less epic to modify/try out new things with than ghc
19:35:34 <samnardoni> now how would i go about printing this?
19:35:52 <mmorrow> i need to start a blog and write up the status of it, i'm getting reallllly close to a first release
19:36:01 <blackdog> hm. is it important that it be a bytecode-driven thing? I thought LHC was aiming at something similar
19:36:29 <mmorrow> blackdog: well, i've already written the interpreter, GC, and (basic parts of) the runtime
19:37:00 <mmorrow> blackdog: but i'd also like to generate either asm/C or either eventually
19:37:45 <mmorrow> blackdog: (the interp/GC/rts are in C)
19:38:19 <samnardoni> anyhoo, i best be off to bed, cheers for all your help guys :) much appreciated
19:38:21 <mmorrow> LHC interprets its GRIN intermediate language in haskell, and also optionally generates C which uses the boehm GC
19:38:29 <Axman6> samnardoni: if you give me a few mins, i can show you how i'd do it
19:38:46 <samnardoni> yeah if you could that'd be great :)
19:44:46 <PetRat> Is there an advantage to using "ErrorT Identity" rather than "Either"?
19:44:56 <Axman6> samnardoni: take a gander at this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11408#a11408
19:45:06 <copumpkin> I disapprove of using Either for errors, so you get my approval
19:45:14 <copumpkin> probably the only advantage
19:45:15 <Axman6> copumpkin: why?
19:45:23 <copumpkin> I'm left-handed.
19:45:39 * sohum snerk
19:45:39 <Axman6> freak >_>
19:46:00 <ewd> If you use ErrorT Identity, later you can change it to ErrorT State () at a wimp.
19:46:05 <PetRat> Axmax6: for some reason the PortMidi library uses Left for success, so you will like it.
19:46:06 <copumpkin> *whim
19:46:07 <Axman6> samnardoni: with that, i get from this: renderHTML $ Node Html [] [Node Img [("src","/images/foo.jpg")] [Content 7]]
19:46:11 <aavogt> > fail "copumpkin" :: Either String a
19:46:13 <lambdabot>   Left "copumpkin"
19:46:18 <Axman6> samnardoni: to: "<html ><img src=\"/images/foo.jpg\">7</img></html>"
19:46:22 <ewd> I am a whim.
19:46:27 <copumpkin> oh monochrom turned into dijkstra
19:46:37 <copumpkin> and he is a whim indeed
19:46:39 <samnardoni> Axman6: you sir, are a legend :)
19:46:46 <ewd> haha
19:46:57 <sohum> > fail "foo" :: Either String String
19:46:58 <lambdabot>   Left "foo"
19:47:07 <copumpkin> gah
19:47:09 * sohum nods
19:47:10 <Axman6> samnardoni: nowhere near complete, but what do you think? (there's a lot that would need changing if it were going to be a real library)
19:48:02 <Axman6> samnardoni: you might consider checking HsStringTemplate or whatever it's called if you're really interrested in doing HTML
19:49:09 <Axman6> samnardoni: also, you'd probably want to change the renderHTML (Content a) = show a line to something like renderHTML (Content a) = escape . show $ a
19:49:52 <samnardoni> it's brilliant :)
19:50:04 <samnardoni> wasn't expecting you to do all that!
19:50:17 <Axman6> i was curious :)
19:50:32 <Axman6> and haskell lets you explore your curiosity very easily
19:51:22 <samnardoni> i can imagine once you get used to this, other languages seem horrible
19:51:29 <Axman6> oh yes
19:51:33 <Axman6> very much so
19:51:52 <ewd> full of artificial myopic limitations
19:51:52 <Axman6> we try not to be elitist, but it's often very hard not to be ;)
19:52:11 <samnardoni> hahah
19:52:35 <Axman6> samnardoni: putStrLn . renderHTML $ Node Html [] [Node Img [("src","/images/foo.jpg")] [Content 7, Content 4, Node Div [("style","float: left")] [Content (-1)]]]  ---> <html ><img src="/images/foo.jpg">7 4 <div style="float: left">-1</div></img></html>
19:53:14 <cristianpane7> if I need use the content of a "file.txt" in integer, how can do that?
19:53:35 <Axman6> @hoogle FilePath -> IO a
19:53:36 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
19:53:36 <lambdabot> Network.Socket.Internal throwSocketError :: String -> IO a
19:53:36 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
19:53:44 <Axman6> @hoogle Read a => FilePath -> IO a
19:53:45 <lambdabot> Prelude readIO :: Read a => String -> IO a
19:53:45 <lambdabot> System.IO readIO :: Read a => String -> IO a
19:53:45 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
19:53:51 <Axman6> hmm
19:53:54 <mmorrow> , read "47829098764728903987647892038476473829093746547382903974654789209876547829" :: Integer
19:53:55 <lunabot>  47829098764728903987647892038476473829093746547382903974654789209876547829
19:54:32 <mmorrow> , read "asdf47829098764728903987647892038476473829093746547382903974654789209876547829" :: Integer
19:54:33 <lunabot>  luna: Prelude.read: no parse
19:54:36 <mmorrow> , reads "asdf47829098764728903987647892038476473829093746547382903974654789209876547829" :: Integer
19:54:37 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer'
19:54:47 <mmorrow> , reads "asdf47829098764728903987647892038476473829093746547382903974654789209876547829" :: [(Integer,String)]
19:54:48 <lunabot>  []
19:54:54 <mmorrow> , reads "47829098764728903987647892038476473829093746547382903974654789209876547829" :: [(Integer,String)]
19:54:55 <lunabot>  [(47829098764728903987647892038476473829093746547382903974654789209876547...
19:55:24 <mmorrow> use reads if it could be malformed and you don't want to crash in the case that it is
19:55:25 <Axman6> samnardoni: anyway, are you starting to see how easy programming can become when you care about datatypes a lot more? once you have great types, the implementation of the functionality you want can alsmot write itself
19:55:43 <aeron> So I want to create permutations of all (Int, Int) with each int ranging from 0..n. Any builtins that can make doing so easy?
19:56:23 <Axman6> > let f n = liftM2 (,) [1..n] [1..n] in f 3
19:56:24 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:56:24 <mmorrow> , (\n -> let xs = [0..n] in [(a,b) | a <- xs, b <- xs]) 4
19:56:25 <copumpkin> aeron: certainly
19:56:25 <lunabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(1,1),(1,2),(1,3),(1,4),(2,0),(2,1),...
19:56:32 <aeron> oh wow, thank you
19:56:38 <copumpkin> > join (liftM2 (,)) [1..3])
19:56:39 <lambdabot>   <no location info>: parse error on input `)'
19:56:39 <copumpkin> > join (liftM2 (,)) [1..3]
19:56:40 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:56:45 <copumpkin> or just use a list comp
19:57:00 <copumpkin> > [(a, b) | a <- [1..3], b <- [1..3]]
19:57:00 * Axman6 would recommend using a list comprehension to begin with at elast
19:57:01 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:57:03 <Axman6> least*
19:57:28 <aeron> And if the comprehension uses infinite lists, and I take the head or index into it, it'll be pretty effecient right?
19:58:13 <mmorrow> aeron: sure, but if you have to use (!!) more than once, there's a better way to do it
19:58:17 <blackdog> aeron: index will be slow on lists.
19:59:09 <mmorrow> (namely, use an IntMap)
19:59:19 <mmorrow> if you need to repeatedly index
19:59:24 <mmorrow> or a Sequence
19:59:25 <cristianpane7> ogm Im very confuse with IO, anyone can help me with the code in hpaste, is the 3rd, the code is in C because I dont know how start it :(
20:00:00 <mmorrow> well, if it's infinite you can't use either i suppose
20:00:50 <copumpkin> cristianpane7: aw come on, don't make us go look for it for oyu
20:00:57 <copumpkin> cristianpane7: just give us a link :P
20:01:06 <MoALTz> if it's infinite you'd need to decide the ordering of generation anyway
20:01:10 <Axman6> cristianpane7: use a tutorial:
20:01:11 <blackdog> mmorrow: hm, a chunked array format could be interesting there. get array performance most of the time, but allow infinite sizes
20:01:14 <Axman6> @where lyah
20:01:15 <lambdabot> www.learnyouahaskell.com
20:01:17 <Axman6> cristianpane7: ^^^^^^^^^^^
20:01:20 <MoALTz> spiral would be my most niave guess
20:01:41 <Saizan> you can use the omega monad instead of lists
20:02:06 <mmorrow> blackdog: yeah that would be, kinda of like a lazy ByteString
20:02:16 <mmorrow> *kinda like ..
20:02:31 <HaudRex> Oh, this is fun. You can replace $ with `id`.
20:02:40 <mmorrow> heh
20:02:46 <mmorrow> @type [($),id]
20:02:47 <lambdabot> forall a b. [(a -> b) -> a -> b]
20:02:47 <blackdog> mmorrow: yeah, exactly
20:02:53 <Axman6> HaudRex: gross :P
20:03:23 <HaudRex> > (+ 1) `fmap` (*2) `id` 3
20:03:24 <blackdog> Axman6: well, $ is a deliberate null op..
20:03:24 <lambdabot>   7
20:03:31 <copumpkin> HaudRex: beautiful
20:03:33 <Axman6> it's still gross
20:03:37 <HaudRex> tehehe
20:03:39 <MoALTz> haha
20:03:42 <blackdog> it's only there to screw with operator precedence:)
20:05:16 <Axman6> blackdog: what do you think of the little HTML library i whipped up in about 10 mins? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11408#a11408
20:05:31 <Axman6> i'm rather proud that it took almost no thought at all
20:05:48 <blackdog> Axman6: production ready! Ship it!
20:05:54 <Axman6> ha
20:06:16 <blackdog> *grin* although the repeated (++) thing's a bit icky
20:06:36 <Axman6> blackdog: if that's your idea of production ready, no wonder hubris isn't giving you much love :P
20:06:41 <mmorrow> using Show for prettyprinting nooooooo!
20:06:44 <Axman6> yeah, like i said, didn't take much though
20:06:45 <mmorrow> :)
20:06:51 <Axman6> thought*
20:07:27 <Saizan> Attr = (String,String) is too liberal!
20:07:35 <Axman6> hmm, needs an extra HTML constructor for <blah ... /> tags
20:07:51 <Axman6> though that'd be XHTML
20:07:54 <blackdog> Axman6: *grin* my old boss at Optus was an angry russian. "Production-ready! Ship it!" was about the most sarcastic thing I've ever heard.
20:08:12 <Axman6> heh
20:08:13 <copumpkin> Saizan is such a conservative
20:08:19 <Axman6> you still at optus?
20:08:30 <blackdog> god no. been hacking freelance for months
20:08:30 <Saizan> Attr should be a type family indexed by the tag
20:08:38 <Axman6> heh, good work
20:08:48 <Axman6> i may have found a job :o
20:08:54 <Axman6> working at kind of knives
20:09:00 * Axman6 *stabstabstab*
20:09:00 <copumpkin> Saizan: ooh
20:09:00 <blackdog> ah, well done.
20:09:05 <blackdog> ... kind of knives?
20:09:11 <Axman6> oh, king*
20:09:12 <blackdog> do they bend when you try to use them?
20:09:16 * hackagebot upload: hack-contrib 2009.11.1 - Hack contrib (JinjingWang)
20:10:17 <blackdog> Axman6: oh, did i tell you about my latest hack for Hubris? i'm rather proud of it - using Hint and the GHC api, I can automatically wrap a Haskell library and present it to Ruby with a nice autogenerated interface
20:10:20 * Axman6 needs $$$ :(
20:10:35 <Axman6> ooo, nice :D
20:10:38 <blackdog> exportable <- filterM (\func -> typeChecks ("((Language.Ruby.Hubris.wrap " ++ func ++ ") Language.Ruby.Hubris.T_NIL) == Language.Ruby.Hubris.T_NIL" )) functions
20:10:39 <Axman6> sounds lovely
20:11:13 <blackdog> it feels a bit filthy - i'm scanning the library and just exporting everything that typechecks:)
20:11:14 <Axman6> now, time to preach to the rubists!
20:11:31 <Axman6> lol
20:11:37 <blackdog> ah, the rubyists like it already - it's just hard to install, which is a pain
20:11:49 <Axman6> how's it look to the from the ruby side?
20:11:59 <blackdog> but this should help - you can ship .so files rather than needing the compiler on hand
20:12:00 * Axman6 pokes sohum because he might like hubris
20:12:10 <Axman6> excellent
20:12:17 * hackagebot upload: bamboo 2009.11.1 - A simple blog engine on Hack (JinjingWang)
20:12:28 <blackdog> module Foo; hubris :module => 'Data.Map'; end
20:12:30 <Axman6> @hackage bamboo
20:12:31 <lambdabot> http://hackage.haskell.org/package/bamboo
20:12:52 <blackdog> attaches all of the suitable functions on Data.Map to the ruby module Foo
20:12:58 <Axman6> hmm, been far too long since i used ruby... hooray :P
20:13:17 <blackdog> going to have :source, :inline and :module tags, so you can still do inline haskell if you want to
20:13:20 <samnardoni> i've just come from using ruby exclusively
20:13:32 <copumpkin> that's where I came from
20:13:50 <copumpkin> well, not exclusively, but by strong preference :)
20:13:51 <Axman6> i never really liked ruby very much. i thought it was cool, but not useful for me
20:13:53 <blackdog> samnardoni: it's not a bad gateway drug :)
20:14:13 * Axman6 likes speed
20:14:19 <Axman6> hmm, lunch time
20:14:25 <blackdog> Axman6: unfortunate timing there
20:14:27 <samnardoni> yeah i quite like the language to be fair
20:14:35 <samnardoni> anyway, bed time for me!
20:14:45 <HaudRex> The proc/block dichotomy is annoying though
20:14:49 <copumpkin> Axman6: I've got some fod cheap if you want though
20:14:51 <copumpkin> *for
20:14:58 <samnardoni> cheers for your help guys!
20:15:09 <blackdog> HaudRex: yeah, there are a few weird little corners like that
20:15:13 <HaudRex> Guess the language: fact = Y(S(I.flip(one).o(S(mul)).o.o(pred))
20:15:26 <blackdog> scoping is broken in two different ways in 1.8 and 1.9
20:15:59 <blackdog> HaudRex: with the appropriate other definitions, that could be many languages...
20:16:38 <HaudRex> blackdog: Too right. It could be Ruby.
20:16:50 <Axman6> copumpkin: what is it?
20:16:58 <copumpkin> Axman6: speed?
20:17:05 <Axman6> oh, heh
20:17:37 <HaudRex> Axman6: It's written as Javascript, but could just as well be any dot-notation ULC.
20:17:59 <FunctorSalad_> hehe
20:18:31 <HaudRex> Oh, lysdexic me.
20:18:35 <blackdog> Axman6: what do you actually need speed for, though?
20:18:48 <ewd> Y,S,I sounds like someone having combinator fun in a language not designed for combinators.
20:18:51 <Axman6> need?
20:18:53 <Axman6> :P
20:18:56 <copumpkin> need for speed!
20:19:00 <blackdog> I'm still trying to find a good use case for Hubris - it's not easy to find web apps that really need to be fast
20:19:18 * hackagebot upload: bamboo-launcher 2009.11.1 - bamboo-launcher (JinjingWang)
20:19:27 <copumpkin> big big bamboo
20:20:00 <Axman6> > unsafeLaunchBambooMissile
20:20:01 <lambdabot>   Not in scope: `unsafeLaunchBambooMissile'
20:20:03 <blackdog> HaudRex: it could be Haskell too, i think
20:20:03 <HaudRex> blackdog: That's really interesting though, calling Haskell from Ruby. I'm working in Ruby right now and I could definitely use that.
20:20:18 <ewd> blackdog: I suggest this use: just use Hubris for normal web apps. This will raise user expectation on other web apps.
20:21:25 <Axman6> mmmm, mi goreng noodles!
20:21:26 <HaudRex> Good way to sneak Haskell into an organisation using Rails.
20:21:27 <blackdog> ewd: the problem is that your runtime is usually swamped by database connections and latency anyway
20:21:59 <blackdog> HaudRex: github.com/mwotton/Hubris *pimppimppimp*
20:22:18 <blackdog> it's not quite production-ready, though, as Axman6 astutely points out
20:22:26 <HaudRex> fair enough
20:22:37 <blackdog> HaudRex: what would you use it for? I'm still looking for feedback
20:22:40 * Axman6 didn't think he was polite, and felt bad about it :(
20:23:48 <FunctorSalad_> ?
20:23:52 <HaudRex> blackdog: Off the top of my head, being able to use Data.Tree and TreeLoc would come in handy for breadcrumbs
20:23:53 <ewd> I have seen slow web apps, as in, opening a drop-down menu is slow. This is not affected by database connections.
20:24:14 <HaudRex> ewd: Javascript-heavy?
20:25:00 * Axman6 thinks that that sounds like they're affected by mentally slow developers
20:25:40 <sohum> I might like what now?
20:25:46 <ewd> If you, as programmer, can make your life easier, good; if not, at least make other programmers' lives harder by raising standards.
20:26:12 <blackdog> ewd: that'd be latency in AJAX calls, or really badly written javascript
20:26:46 <blackdog> sohum: i think Axman6 was suggesting you might be interested in my Ruby-Haskell bridge project.
20:27:28 <blackdog> ewd: i agree in principle. the tricky bit is finding places where the higher standards actually make a measurable, noticeable difference
20:29:30 <blackdog> HaudRex: can you expand a bit? I'm not quite sure what you mean
20:29:56 <sohum> oooh, interesting
20:29:57 <Axman6> sohum: you're a ruby apologist right? :P
20:30:01 <sohum> both ways?
20:30:20 <blackdog> sohum: mostly focused on letting ruby call haskell
20:30:23 <sohum> I just like Ruby. I think it's a relatively elegant and powerful language among the morass that's in the mainstream atm.
20:30:32 <sohum> blackdog: *nod*. how typesafe is it?
20:30:38 <blackdog> there's no reason not to go the other way, except that no-one shows much interest.
20:30:54 <Axman6> sohum: as typesafe as ruby :P
20:30:55 <blackdog> sohum: completely
20:31:00 <Axman6> >_>
20:31:05 * sohum snerk
20:31:23 <sohum> like, what do you map to the Num hierarchy?
20:31:36 <blackdog> that is, you make a ruby call, and get a ruby value back. the wrapping is a bit manual at the moment, but i've just cracked a way to do it a bit more cleanly
20:31:54 <blackdog> fixnums go to Ints, bignums go to Integers.
20:32:23 <blackdog> but it's extensible - there's a Rubyable class for copying haskell values to ruby, and a Haskellable class for the reverse direction
20:32:28 <blackdog> (my names suck, i know.)
20:32:45 <Axman6> could be worse
20:33:05 * Axman6 prefers Rubable, for the lulz
20:33:24 <ewd> I am not fond of "x2y" names.
20:33:43 <blackdog> sohum: the ghc api is really helpful there - if you can state what type you expect (in this case, i've restricted it to RValue -> RValue), you can scan a random haskell module with the ghc-api and only export things that fit the type.
20:34:22 <Axman6> om nom nom nom
20:35:20 <blackdog> hm, which one of you is runarorama? i refuse to believe that was a coincidence...
20:35:38 <Axman6> ?
20:35:58 <blackdog> got a twitter search going for ruby and haskell and someone's pimping Hubris
20:36:08 <Axman6> o.O
20:36:30 <MyCatVerbs> Not quite all of the Haskell community shows up on IRC.
20:36:43 <Axman6> only most of it
20:36:47 <MyCatVerbs> Most of the rest talk on the mailing lists, though.
20:37:07 <Axman6> bulat doesn;t come here does he?
20:37:27 <MyCatVerbs> I still can't quite fathom why (Peyton `Simon` Jones) doesn't at least poke his head into IRC once in a blue moon. ;)
20:37:35 <MyCatVerbs> Not that I know of.
20:37:42 <Axman6> hoorah >_>
20:37:52 <Axman6> yeah :(
20:37:54 <luite> a run with +RTS -prof tells me that 95% of all allocations are done in one function, but is there a way to find out which types are allocated, and how many of each?
20:38:01 <hexpuem> yea
20:38:20 <hexpuem> -hy? i cant remember
20:38:21 <hexpuem> maybe ht
20:38:28 <MyCatVerbs> luite: You put also more SCCs in, so that individual subexpressions inside that function will be profiled.
20:38:38 <MyCatVerbs> Which might be more useful to you than profiling by type.
20:38:43 <HaudRex> blackdog: That was me.
20:39:01 <luite> MyCatVerbs: ah thanks, that could be useful indeed
20:39:41 <blackdog> MyCatVerbs: See, i'm vindicated:)
20:39:59 <blackdog> HaudRex: now i feel silly spamming you in multiple media...
20:40:08 <hexpuem> anyone know if hpysics was abandoned
20:40:43 <MyCatVerbs> blackdog: I'm not sure what you're talking about there, and I'm dreading what consequences my talking might have just had. ;)
20:40:51 <HaudRex> blackdog: Bladdy spammer.
20:41:33 <sohum> blackdog: huuuh. that's pretty damn cool.
20:41:36 <blackdog> MyCatVerbs: oh, the person i was looking for was in the channel
20:42:07 <luite> hexpuem: a
20:42:12 <luite> oops
20:42:24 <blackdog> sohum: not in the mainline yet. i made that classic error of trying to improve it in multiple directions at once, so getting a sensible patch that doesn't break anything is a bit of a chore
20:42:37 <MyCatVerbs> blackdog: Oh, you bad lot, you. ^^
20:42:38 <luite> hexpuem: it was -hy :)
20:44:15 * sohum snerk
20:44:40 <sohum> doesn't darcs have that awesome automatic-branching feature thing?
20:45:26 <blackdog> don't know. am using git.... it's not really even a source control thing, i just have about four features half-working, but not at all working with each other.
20:45:28 <MyCatVerbs> sohum: You mean cherry-picking? That doesn't  completely alleviate the need to work out exactly what set of patches will actually all work together. :)
20:45:46 <sohum> no, but it helps!
20:56:44 <Axman6> blackdog: zomg. getting pretty printed HTML working now :P
20:59:37 <Axman6> blackdog: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11408#a11411
21:07:19 <blackdog> Axman6: remind me why you're writing an HTML prettyprinter again? :)
21:07:41 <Axman6> someone was learning haskell earlier, and trying to do it, and i got interested
21:09:55 <iaefai_> cabalized package builds!
21:13:42 <kmc> since there's probably a different set of people here now:
21:13:53 <kmc> anyone have suggestions for how to squeeze more performance out of this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11361
21:14:24 <kmc> right now it gets only 175% productivity on a machine with 2 cores and maybe 5% other load
21:15:05 <blackdog> kmc: tried ThreadScope?
21:15:27 <kmc> is that available on 6.10.4?
21:15:41 <blackdog> you need 6.12 installed as well, i think
21:15:52 <kmc> bummer
21:16:02 <kmc> last i checked it was hard to get anything platform-ish running with 6.12
21:16:07 <ivanm> blackdog: well, threadscope is _for_ 6.12...
21:16:18 <ivanm> kmc: there's no platform for 6.12 and there won't be till next year
21:16:22 <blackdog> http://chplib.wordpress.com/2009/10/19/an-early-look-at-threadscope/
21:16:24 <ivanm> is 6.12 even out yet?
21:16:29 <blackdog> only the RC
21:16:40 <kmc> i mean rolling my own by manually getting cabal-install, etc
21:16:43 <kmc> but there were many broken things
21:16:58 <blackdog> yeah, it's definitely a bit bleeding edge.
21:17:18 <ivanm> kmc: well, cabal-install doesn't support the new ghc-pkg format for 6.12 yet
21:17:28 <kmc> i gather multithreading is also generally better in 6.12
21:17:59 <luite> yes I noticed a 3x speedup in one of my programs, with the same number of threads
21:18:05 <kmc> woah
21:18:18 <luite> surprised me a little :)
21:18:43 <blackdog> ivanm: i think duncan patched the cabal-install in darcs
21:19:38 <kmc> luite, were you using parallel evaluation or explicit threads or both?
21:20:11 <ivanm> blackdog: yes, but it's not released yet, is it? :p
21:20:19 <ivanm> partially because it needs live Cabal
21:20:32 <blackdog> ivanm: what's your definition of released? :)
21:20:36 <luite> kmc: parallel evaluation,  with lots of elements in large lists (using parListChunk)
21:20:41 <kmc> cool
21:20:50 <ivanm> blackdog: on hackage
21:21:48 <kmc> i'm glad that haskell supports parallelism as a separate concept from explicit threading
21:21:49 <blackdog> ivanm: jeez, man, live a little
21:22:36 * blackdog has ulterior motives - he can't live without 6.12 and wants other people to knock the rough edges off
21:22:41 <ivanm> blackdog: heh
21:22:51 <kmc> blackdog, what do you need 6.12 for?
21:22:58 <blackdog> kmc: dynamic libraries
21:22:59 <luite> kmc: with 6.10 I had to start more OS threads than I have cores to keep them busy (I experimented with the chunk size, but there still might be something else wrong with my implementation)
21:23:13 <gonzojive> i'm working on a compiler that generates a control-flow graph of the program it is compiling.  I would like to change the state of the graph as it is built up, or alternatively while performing optimizations.  how can you "modify' a graph in a purely functional language like Haskell?
21:23:38 <blackdog> gonzojive: ST monad, perhaps?
21:23:43 <Axman6> by creating a new graph from the old pieces and the changed pieces
21:23:50 <kmc> gonzojive, do you truly need to modify in-place?
21:24:01 <kmc> or do you just want to construct new graphs based on the old ones, and pass them to new function calls?
21:24:14 <copumpkin> I often represent graphs as IntMaps
21:24:23 <copumpkin> updating those is cheap
21:24:25 <gonzojive> no, I don't need to modify in place but I need a new version of the graph with edges deleted/added and maybe new nodes
21:24:29 <kmc> a lot of data structures in Haskell will support the latter without duplicating all of the information between versions
21:24:36 <kmc> gonzojive, are you using an existing graph library?
21:25:26 <Axman6> copumpkin: you're cheap
21:25:31 <Axman6> >_>
21:25:34 <copumpkin> :O
21:25:44 <copumpkin> I am actually
21:25:44 <gonzojive> kmc: no.  in fact I am not using haskell but I wanted to know what sort of functional approaches to this problem exist
21:25:55 <kmc> ah
21:26:00 <kmc> well, what level are you interested in?
21:26:20 <kmc> a functional graph library would provide functions to get a new version of the graph with various changes
21:26:35 <kmc> one level below, the representation of the graph might be a finite map like copumpkin suggested
21:26:49 <kmc> that in turn may be implemented by a self-balancing tree or such
21:26:56 <kmc> or even a hash trie, i know Clojure uses those
21:27:14 <copumpkin> IntMap is very close to Clojure's hash trie as far as I can tell, minus the actual hashing
21:27:31 <kmc> and those sorts of data structures support creating new versions without much copying
21:27:49 <kmc> is there a hash trie library for Haskell?
21:27:59 <mmorrow> gonzojive: you just use type Graph a = IntMap a, where `a' contains either a [Int] or (better for union/intersection) an IntSet
21:28:25 <copumpkin> nope, but I think (unless I missed something) you could build Clojure's hash trie on top of an IntMap with a Hashable class with hash :: a -> Int
21:29:09 <kmc> but the hash is not necessarily a unique key
21:29:16 <kmc> so you'd need a secondary structure as the elements of your IntMap
21:29:18 <copumpkin> mmorrow: you'd probably want to carry some data with you
21:29:19 <gio123> is there anybody prom portugal?
21:29:26 <kmc> anyway it's certainly doable but we might want a library to make it nice
21:29:49 <mmorrow> copumpkin: right, the `a' type holds it
21:30:10 <copumpkin> oh, I thought you said it contains a [Int] or an IntSet O:-)
21:30:18 <mmorrow> gonzojive: here's an e.g. (using Map a (Set a) here) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2362
21:30:23 <mmorrow> copumpkin: among other things..
21:30:48 <copumpkin> :)
21:31:07 <mmorrow> data Node a = Node {stuff :: a, succs :: IntSet}; type Graph a = IntMap (Node a)
21:31:15 <iaefai_> If you have a data that was constructed with a type constructor using braces { }, how do you access the data inside?
21:31:16 <mmorrow> or to have info attached to edges
21:31:23 <kmc> iaefai_, example?
21:31:25 <gonzojive> thanks for all the tips.  it's hard to figure out what's going on in that example, mmorrow, since I'm pretty new to haskell
21:31:36 <kmc> like mmorrow's?
21:31:38 <iaefai_> kmc, what mmorrow just typed willwork
21:31:45 <kmc> that's the same as "Node a IntSet"
21:32:02 <kmc> except you also get functions defined for you:  stuff :: Node a -> a, and succs :: Node a -> IntSet
21:32:02 <iaefai_> awesome
21:32:05 <copumpkin> mmorrow: I've never been able to decide the best way to do it. It seems that based on what kind of information you want in your graph there are different possible representations. Type families maybe to decide on the representation?
21:32:09 <kmc> it's called a "record"
21:32:12 <Woof> Twey >: O
21:32:20 <iaefai_> kmc, that is good
21:32:20 <copumpkin> Meow
21:32:29 <kmc> and, to be honest, those extra functions are rather limited use... there are libraries to provide something better
21:32:44 <mmorrow> copumpkin: yeah, it seems almost impossible to make a one-size-fits-all graph datatype
21:32:46 <kmc> data-accessor, fclabels, lenses
21:32:50 <kmc> i don't remember which one is the best
21:32:52 <mmorrow> copumpkin: i've tried on multiple occations
21:32:56 <mmorrow> *occasions
21:32:58 <iaefai_> I am using that httpd-shed thing
21:33:18 <copumpkin> mmorrow: yeah :/ most of the time I don't want edge data, so filling it up with () seems ugly, but when I do it's a pain to add it
21:33:33 <iaefai_> I tried that leksah program, and it doesn't seem to lend itself to easy use.
21:34:04 <mmorrow> copumpkin, gonzojive: here're the graph types i'm using in my compiler http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4548#a4548
21:34:12 <kmc> fclabels has the template haskell integration
21:34:25 <iaefai_> template haskell?
21:34:36 <mmorrow> copumpkin: ah right, i have different datatype (all ad-hoc) for edge data
21:34:41 <mmorrow> *datatypes
21:34:44 <copumpkin> mmorrow: thanks :) I have a simple IntMap/Set-based representation and a knot-tied representation in one of my recent projects
21:34:51 <copumpkin> but the knot-tied one is a pain to work with
21:35:40 <kmc> iaefai_, template haskell allows you to write haskell programs that write other haskell programs
21:35:47 <copumpkin> I need to come up with a better uniform interface to both representations
21:35:53 <mmorrow> IntMap IntSet is super fast, but it starts to become a real pita when you want graphs of graphs and to have data attached (as well as edge data)
21:35:54 <copumpkin> I really like the tied knots in theory though
21:35:56 <kmc> in this case, using it to look at the definition of a record, and automatically generate useful functions for working with that record
21:36:23 <iaefai_> oh ok
21:36:43 <iaefai_> I am glad it wasn't like 'template C' (otherwise known as C++)
21:37:36 <kmc> ha
21:38:03 <mmorrow> copumpkin, gonzojive: here's a quicky djikstra http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4548#a4549
21:38:04 <kmc> so people do metaprogramming in C++ using templates
21:38:15 <kmc> but their metalanguage (templates) is bizarre and totally different from the object language (C++)
21:38:22 <kmc> with TH you use the same language at both levels
21:38:31 <copumpkin> whoa
21:38:36 <mmorrow> transcribed from this one combinatorial algorithms book, so had to translate to functional along the way..
21:38:39 <copumpkin> mmorrow: is that as simple as dijkstra gets?
21:38:42 <copumpkin> ah, phew
21:38:44 <mmorrow> dunno
21:38:55 <Axman6> mmorrow: was pure-fft yours? i can't remember now
21:39:05 <mmorrow> Axman6: gah!!
21:39:08 <Axman6> lol
21:39:09 <mmorrow> Axman6: i completely forgot
21:39:13 <mmorrow> :)
21:39:16 <Axman6> :)
21:39:23 <mmorrow> Axman6: going to update it right now.
21:39:31 <Axman6> got a link to that awesome TH stuff you did?
21:39:37 <blackdog> mmorrow: marching bravely off the edge of the screen...
21:39:44 <mmorrow> blackdog: heh
21:39:48 <mmorrow> Axman6: yesh
21:40:10 <Axman6> thought it might be interesting for iaefai_ to see the TH and the results (both code and speed)
21:40:59 <kmc> well, the speed is exactly the speed of the code that the metaprogram produces :)
21:41:09 <kmc> unless you mean compilation speed, which i thought wasn't very good with TH
21:41:14 <ivanm> heya Axman6
21:41:19 <Axman6> \o
21:41:33 <gonzojive> is the idea behind (some of) the finite map implementations of a functional graph to "shadow" old definitions of nodes with new ones that have modified properties?
21:41:41 <mmorrow> Axman6: http://moonpatio.com/repos/hsfft_vec/
21:41:43 <Axman6> kmc: the speed of the resulting FFT code, it's rather good
21:42:18 <mmorrow> gonzojive: rather, when you update the value at a given key, you're "mutating" that node
21:42:24 <copumpkin> mmorrow: how's it compare to fftw? :P
21:42:35 <gonzojive> maybe there is a paper you could recommend on the topic.  I did not immediately find a canonical functional graph paper
21:42:43 <copumpkin> fgl
21:42:48 <copumpkin> I don't like it much though
21:42:56 <kmc> so it generates fft code for a particular input size?
21:43:00 <copumpkin> @hackage fgl
21:43:01 <lambdabot> http://hackage.haskell.org/package/fgl
21:43:01 <mmorrow> gonzojive: and since you usually aren't holding on to multiple copies of the graph across changes, it's basically mutation
21:43:46 <kmc> gonzojive, if you did need in-place update, haskell has various facilities for that
21:44:03 <mmorrow> copumpkin: i'm not sure (given that that just generates a very particular fft, whereas fftw generates a bunch of different kinds, with options etc), but that being said, it'd be interesting to benchmark that against the equivalent fft generated by fftw
21:44:05 <kmc> it's only "purely functional" in that you have to own up (in the type system) to the fact that you're using state
21:44:08 <kmc> the capabilities are still there
21:44:35 <copumpkin> yeah
21:45:15 <gonzojive> ah.  i apologize for not really knowing haskell
21:45:24 <mmorrow> kmc: yeah, it generates an fft that operates on vectors of the given size (for size `in` [2,4,8,16,32,64])
21:45:26 <kmc> no apologies necessary.  that's why we're here :)
21:45:28 <Axman6> gonzojive: you can change that ;)
21:45:33 <kmc> mmorrow, that's really cool
21:46:36 <mmorrow> kmc: the asm is super good too, since the vector constructors are basically arrays of N*2 doubles (since everything is unpacked), and ghc compiles the pattern match selection of the components super-well
21:46:57 <mmorrow> kmc: the .s files are in that directory too
21:47:10 <mmorrow> err, .s file
21:47:36 <kmc> very cool
21:47:43 <kmc> what vector library are you using?
21:47:44 <mmorrow> oh, and the timings for the single fft apparently are borked
21:48:11 <mmorrow> since 20 nanoseconds is impossible for a few thousand machine instrs
21:48:19 <mmorrow> kmc: vector lib? ;)
21:48:24 <kmc> "import Vec"
21:48:28 <mmorrow> oh, right
21:48:31 * fryguy 's head hurts
21:48:37 <mmorrow> kmc: http://moonpatio.com/repos/hsfft_vec/Vec.hs
21:48:41 <kmc> what you don't have a 50 GHz machine? ;)
21:48:57 <kmc> cool
21:50:18 <kmc> any reason not to generate more of that by TH?
21:50:23 <ivanm> kmc: don't they come in cornflakes boxes nowadays?
21:50:23 <kmc> like, the definition of "data Vec"
21:50:24 <ivanm> ;-)
21:52:37 <mmorrow> kmc: it was generated by TH, then prettyprinted ;)
21:52:45 <kmc> :)
21:52:56 <kmc> but why not do it that way "live"?
21:53:00 <mmorrow> kmc: which is usually the method i prefer, rather than splicing it directly
21:53:29 <mmorrow> since then you can (1) see it, and (2) not have to re-generate it in its entirety every time you compile or reload in ghci
21:53:50 <mmorrow> well, that, and then you aren't dependent on the TH lib either
21:54:07 <ivanm> kmc: because people that release code that uses TH for every damn compilation rather than generating it once should be shot
21:54:53 <mmorrow> it's convenient to splice when you're e.g. generating instances for particular datatypes that you're changing a lot though
21:57:10 <luite> would it be easy to unfold something like: sum (\x -> r i * w i) [0..p], with p fixed, with template haskell
21:57:37 <kmc> x isn't being used
21:57:41 <luite> oh sorry
21:57:44 <luite> that should be 'i
21:57:46 <luite> \i
21:58:06 <kmc> yeah should be easy
21:58:16 <kmc> but also your compiler might do the optimization anyway
21:58:41 <mmorrow> err, is that supposed to be
21:58:52 <mmorrow> sum (map (\i -> ..) [0..p]) ?
21:59:32 <luite> yes, I'm sorry, I have my own sum-like function that I use there (which does a sum and a map), so I got things a bit mixed up there
22:00:34 <copumpkin> summap
22:00:56 * Axman6 likes stream fusion for that sort of thing
22:01:32 <luite> copumpkin: yes with the arguments flipped, so it looks more like a \sum_{i \in ...}
22:03:26 <rasfar> anyone feel like helping me get a Haskell parsing example working with haskell-src-exts?  i'm just getting back into Haskell, not a total n00b, but I'm pretty shaky about a couple things...
22:03:45 <ivanm> rasfar: what kind of parsing are you wanting to do with hsx?
22:04:16 <rasfar> i'm doing a software architecture course, and for the project I want to browse some largish projects if possible.  like xmonad or something...
22:04:29 <rasfar> but to start with, any single library module would be nice!
22:04:34 <iaefai_> I understand the shaky - my hand shakes when thinking about the monads
22:04:34 <luite> xmonad is not really large
22:04:44 <rasfar> I'm looking at Graph.hs as possible first example
22:04:56 <rasfar> what's a large example?
22:05:05 <rasfar> darcs?
22:05:10 <ivanm> rasfar: what are you actually wanting to use haskell-src-exts for?
22:05:41 <rasfar> i have an ad hoc parser i already made.  i am visualizing syntax trees.  my parser chokes on extensions, so i hacen't been able to use it beyond toy examples...
22:05:50 <mmorrow> , ppDoc <$> let sumQ p = let go acc r w i | p <= i = acc | otherwise = go [|$acc + ($r i * $w i)|] r w (i+1) in do [r,w] <- replicateM 2 (newName "f"); lamE [varP r,varP w] (go [|0|] (varE r) (varE w) 0) in sumQ 3
22:05:51 <lunabot>  \f_0 f_1 -> ((0 + (f_0 0 * f_1 0)) + (f_0 1 * f_1 1)) + (f_0 2 * f_1 2)
22:06:04 <ivanm> rasfar: see SOurceGraph (shameless plug)
22:06:07 <mmorrow> luite: something like that?
22:06:43 <rasfar> ivanm: sure ... will looking at that help me understand how to use hsx?
22:06:44 <jfredett_> @botsmack ivanm
22:06:44 <lambdabot> :)
22:06:44 <lunabot>  :o
22:07:01 <ivanm> jfredett_: I'm working on a new version! you'll get more release announcements soon!
22:07:01 <jfredett_> hey, I haven't seen a release from you in like... two weeks!
22:07:03 <mmorrow> , $(let sumQ p = let go acc r w i | p <= i = acc | otherwise = go [|$acc + ($r i * $w i)|] r w (i+1) in do [r,w] <- replicateM 2 (newName "f"); lamE [varP r,varP w] (go [|0|] (varE r) (varE w) 0) in sumQ 3) (*20) (+7)
22:07:03 <ivanm> ;-)
22:07:04 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
22:07:11 <jfredett_> Did you die or something?
22:07:12 <ivanm> rasfar: I use hsx to draw call graphs
22:07:24 <mmorrow> , $(let sumQ p = let go acc r w i | p <= i = acc | otherwise = go [|$acc + ($r i * $w i)|] r w (i+1::Int) in do [r,w] <- replicateM 2 (newName "f"); lamE [varP r,varP w] (go [|0|] (varE r) (varE w) 0) in sumQ 3) (*20) (+7)
22:07:26 <lunabot>  520
22:07:28 <jfredett_> I hear that death puts a hamper on hacking...
22:07:29 <ivanm> jfredett_: I had to write the paper on SourceGraph, then I had to do my PhD application, etc.
22:07:36 <jfredett_> ah.
22:07:41 <rasfar> okay!  sounds promising.  I'll likely be citing your work as well.
22:07:43 <jfredett_> so you had _work_ to do.
22:07:43 <luite> mmorrow: I guess that's what I mean. I haven't really used TH though zo it may take me a while to digest the whole expression :)
22:07:50 <ivanm> jfredett_: yeah, that... >_>
22:07:54 <jfredett_> You're a bad Haskeller, don't you know we're supposed to be lazy?!
22:08:02 <jfredett_> :D
22:08:13 <mmorrow> luite: it should look relatively straightforward when un-oneliner-ized
22:08:19 <ivanm> jfredett_: heh, I needed to get the application done so that I can get government money to keep being lazy... >_>
22:08:26 <Zao> jfredett_: Some strictness is necessary, otherwise you'll leak out of your living space.
22:08:33 <Axman6> ivanm: how's the PhD application going?
22:08:36 <jfredett_> Zao: hehe..
22:08:49 <ivanm> Axman6: applied; won't hear back for up to 6 weeks apparently :s
22:08:55 <Axman6> ooo, installing EclipseFP is much easier than it used to be...
22:08:57 <ivanm> but apparently I'm guaranteed a spot! \o/
22:09:01 <jfredett_> ivanm: I know what you mean... I have to apply for gradschools soon, pain in the unholy ass...
22:09:02 <iaefai_> Anyone know why I get a parse error in pattern on a line:     putStrLn "Starting up httpd."
22:09:04 <Axman6> ivanm: :\ oh well
22:09:15 <rasfar> ivanm: one of the reports linked at http://code.haskell.org/~ivanm
22:09:19 <rasfar> ?
22:09:27 <ivanm> rasfar: all of them
22:09:32 <mmorrow> luite: and you'd in reality (ie when you don't have to fit everything into a single expression) use that like
22:09:46 <mmorrow> luite: (\r w -> $(sumQ 50) r w)
22:09:57 <luite> mmorrow: yes, unonelinerization did help :)
22:10:13 <rasfar> cool, i am so glad i asked.  i'll have to look at the stuff for a bit to see if it will help me, might be too far developed to afford me exmple how to use hsx, but thanks for the lead...
22:11:39 <luite> mmorrow: ok, thanks. I'll try and see if this can help the compiler to do some additional optimizations (and get rid of unnecessary allocations)
22:11:56 <mmorrow> luite: cool, lemme know how it goes
22:12:42 <mmorrow> luite: yeah, ghc not being able to fuse foldl-like things with enumFromTo is particularly unfortunate
22:13:26 <copumpkin> just need to switch to stream-fusion
22:15:34 <mmorrow> copumpkin: i've got the non-nested loop case nailed currently, and am trying to work out the details of the arbitrarily nested loop case currently (as in on workspace one). i'm excited for getting this over with so i can test it..
22:15:49 <copumpkin> how do you mean?
22:15:54 <copumpkin> you're working on getting it into ghc?
22:16:19 <gmaslov> is it possible to write an arithmetic mean function that will work on lists of any-size tuples, without resorting to Template Haskell or SYB?
22:16:25 <mmorrow> copumpkin: well, i get the external core ast from ghc, with -fno-rewrite-rules, and go from there
22:16:28 <copumpkin> oh
22:17:10 <mmorrow> copumpkin: and also use the (i forget the name) option for list comprehensions so that it doesn't try use use foldr/build
22:18:45 <kmc> gmaslov, no, the types of tuples of various sizes are not related in any formal way
22:19:58 <rasfar> okay, i'm cabal install sourcegraph, and it's installing a lot of dependencies and whatnot ... but would anyone be willing to help me build the minimal test module to parse a small example module (like Graph.hs)?
22:20:10 <rasfar> Using hsx only, that is.
22:20:22 <gmaslov> kmc: mmh, that's the problem i ran into. also that there's no type constructor "TwoTuple a" for (a,a), only "(,) a b".
22:21:00 <Axman6> hmmmmm eclipsefp looks rather nice
22:21:04 <rasfar> copumpkin, have you done it?  as you did recommend hsx earlier.
22:21:15 <copumpkin> ?
22:21:20 <copumpkin> done what?
22:21:25 <copumpkin> oh
22:21:28 <rasfar> er, ... i was looking to parse ....
22:21:34 <rasfar> (sorry for the intrusion)
22:21:51 <copumpkin> nah, I'm just forgetful and didn't figure out the hsx abbreviation immediately
22:21:57 <copumpkin> I did it once but I can't remember how to use it
22:22:19 <rasfar> i'm just a bit rusty on the mechanics of getting an example up; a little advice would go a long way at this point, i'm so rusty with hackage, cabal, etc.
22:22:56 <rasfar> I currently have installed haskell-src-exts, and I have a module Graph.hs (Data.Graph) I'd like to try it out on.
22:23:09 <rasfar> Okay, at least you did it!
22:23:12 <PetRat_> I've got some questions about Error and ErrorT : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11412#a11412
22:23:45 <rasfar> I'm looking for the quick example, but might just have to figure it out myself.  Would be nice if it was documented someplace...
22:23:53 <gmaslov> @pl (\a -> sqrt (a * a))
22:23:53 <lambdabot> sqrt . join (*)
22:24:10 <copumpkin> rasfar: the announcement on cafe might have something
22:24:15 <Axman6> > sqrt . join (*) $ a
22:24:16 <lambdabot>   sqrt (a * a)
22:24:28 <Axman6> yay SimplReflect
22:26:20 <rasfar> If that's http://old.nabble.com/ANN:-haskell-src-exts-1.2.0-td26031669.html (Oct. 23) I'm afraid not.  Perhaps one of the older announcements?
22:29:18 <PetRat_> I've got some questions about Error and ErrorT : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11412#a11412
22:29:24 <kmc> gmaslov, you can make that TwoTuple with a type synonym family i think
22:30:23 <rasfar> sorry PetRat_, I'd help if I could.
22:30:49 <PetRat_> rasfar: is the question not clear?
22:31:50 <mmorrow> copumpkin: woot http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4550
22:32:06 <rasfar> it looks clear ... looked at the paste ... i simply don't know
22:33:28 <copumpkin> mmorrow: wait what, what's that? you're fusing automatically in your backend?
22:33:45 <mmorrow> copumpkin: oh yesh
22:33:48 <copumpkin> nice :)
22:33:59 <copumpkin> how does your compiler figure that out?
22:35:44 <mmorrow> copumpkin: it's got a semi-elaborate algo, but it basically amounts to traveling the path of every loop in the code exactly once, and for a given function, you inline the functions that it uses into a local let, then "solve" for the minimal local control flow
22:36:58 <rasfar> PetRat_: when you say "functional dependency" what do you mean?  (if you feel like educating me while you await better help)
22:38:23 <copumpkin> making the value of some of the parameters to a multiparameter typerclass depend on other ones
22:40:22 <rasfar> (copumpkin: i trust that was answer to my last question?)
22:40:32 <copumpkin> yep
22:40:46 <copumpkin> so if you have class Moo a b | a -> b
22:41:03 <rasfar> the a -> b is a functional dependency?
22:41:06 <copumpkin> yep
22:41:10 <copumpkin> that says for any given value of a in Moo, there is exactly one value of b is possibl
22:41:11 <copumpkin> e
22:41:11 <rasfar> kay thx
22:41:22 <copumpkin> you could also say that b -> a
22:41:34 <copumpkin> or both at once
22:42:00 <kmc> where "value" means the type you put there in an instance
22:42:01 <rasfar> is this in Haskell98?
22:42:03 <kmc> no
22:42:09 <rasfar> ah
22:42:25 <rasfar> to be honest it's been so long i wasn't even sure
22:42:36 <kmc> they're called "functional" because multi-param type classes define n-ary relations on types, and this gives a way to specify that part of that relation is a function (again, on types)
22:43:03 <kmc> for a more direct way to implement functions on types, see the newer extensions (in GHC) of associated types / type synonyms and the generalization of that, type/type-synonym families
22:43:06 <copumpkin> there's also a very similar concept in (relational) databases with the same name
22:43:06 <rasfar> i like this kind of explanation, thank you
22:44:12 <copumpkin> rasfar: http://code.haskell.org/HSP/haskell-src-exts/examples/
22:45:06 <rasfar> yes, okay ... i toyed with that.  i get an error, may i hpaste it?
22:45:50 <kmc> certainly
22:46:19 <luite> hmm, my program suddenly does not link anymore: ghc.exe: Unknown PEi386 section name `/22' (while processing: Lp\lp.o)
22:46:32 <rasfar> Actually an hpaste is overkill.  If I run "prettify Prettify.hs" (or other .hs), I get
22:46:35 <rasfar> prettify: Prettify.hs:167:21-54: Missing field in record construction Language.Haskell.Exts.ParseMonad.extensions
22:46:54 <rasfar> compiled using ghc --make Prettify -o prettify
22:48:08 <rasfar> it's probably something obvious, but I'm really rusty...
22:48:34 <copumpkin> did you check that line?
22:48:35 <kmc> luite, are you using --make?
22:49:28 <luite> kmc: yes. lp.o is a foreign object (compiled from lp.c using g++). I had this problem before, but fixed it somehow, now it's back
22:50:22 <luite> when I compile it with g++ 3.4.5 it complains about an unknown section .dtors
22:51:52 <kmc> you might need to link with some c++-specific library
22:52:50 <iaefai_> My eyes hurt!
22:53:31 <luite> kmc: I already link with the required libraries (at least it worked before with -lClp -lCoinUtils -lstdc++)
22:54:17 <luite> the only function in lp.c is in a extern "C" { ... } block in the header lp.h (which is included in both lp.c and the haskell file using this function
22:54:23 <luite> )
22:54:35 <rasfar> i also did "cabal configure" and "cabal build" in the directory containing hse-examples.cabal, but still get the same error using that binary.
22:55:49 <rasfar> anyway, it will be worth the effort if hsx can actually help me parse whole projects like xmonad, yi, lambdabot, sourcegraph, ...
22:56:03 <luite> apparently .dtors is a section for global destructors, but I don't know why it suddenly causes this problem
22:59:19 <kmc> any reason to prefer "| otherwise =" versus repeating the equation lhs with no guard?
22:59:40 <mmorrow> rasfar: here's a handy prog (that i actually use all the time) that might be relevant to what you're doing http://moonpatio.com/repos/derive-gadt/tools/hstidy.hs
23:00:57 <mmorrow> rasfar: i usually copy/paste that code and use it as a template for any quicky haskell-source-parsing-and-_ cli progs i write/need
23:01:43 <rasfar> Thanks mmorrow; cabal install haskell-src-meta .... working on it
23:01:51 <copumpkin> kmc: probably not, except not repeating the patterny bits. otherwise = True by the way
23:01:56 <copumpkin> @src otherwise
23:01:56 <lambdabot> otherwise = True
23:02:00 <copumpkin> ^^ :)
23:02:02 * BMeph prefers to use "dtors" by going around them... ;p
23:02:10 <rasfar> and compiled your example ...
23:02:51 <mmorrow> rasfar: oh gah, i might have to update one of the hstidy imports for the new haskell-src-exts
23:03:12 <luite> BMeph: I don't use any "dtors" myself, the problem is that the library is written in C++. I call it through a single C function though
23:04:06 <luite> but the strange thing is that it worked before with ghc, but that I had exactly the same error when I tried to load the program in ghci
23:04:16 <rasfar> mmorrow: ./t < Main.hs seems to work
23:04:18 <luite> now I have it in both ghc and ghci
23:04:58 <rasfar> mmorrow: this is very promising, thanks a lot!
23:05:07 <mmorrow> rasfar: ah nice. in case in the future you have a problem with the Language.Haskell.Exts.Fixity import, i believe the fix is to s/Language.Haskell.Exts.Fixity/Language.Haskell.Exts.Annotated.Fixity/
23:05:12 <mmorrow> rasfar: no problem
23:09:39 <luite> hmm, this is strange, if I remove the TemplateHaskell LANGUAGE extension, the program links just fine
23:11:56 <luite> oh then I guess I know what the problem is... templatehaskell uses ghci to evaluate the templates
23:12:12 <luite> :(
23:17:23 <Peaker> "Space leaks are bad not merely for the memory they consume, but also because of their time effects. Build a big data structure in a leaky way, and the garbage collector will expend a lot of futile cycles traversing it." <-- can't a GC "cache" the traversal result of immutable values?
23:17:30 <rasfar> (or rather, ./hstidy < hstidy.hs now that i've reminded myself about -main-is)
23:19:34 <kmc> Peaker, the reachability of a given heap value is not immutable
23:19:37 <blackdog> Peaker: it's not immutable at the GC level
23:20:16 <kmc> the starting points for your search are the values on the evaluation stack, which change as computation proceeds
23:20:25 <Peaker> oh, right, thunk evaluation reduces reachability
23:20:31 <kmc> that too
23:20:45 <Peaker> kmc, Of course, I was talking about a map from values to reachable values
23:20:52 <Peaker> kmc, not an immutable set of reachable values, of course
23:22:39 <Peaker> though the GC could probably optimize the case of a huge thunk tree -- where nodes only referred by single other nodes are "skipped" in the next traversal, so the whole tree is flattened, and need not be traversed if the root is still reachable, all the leafs are reachable. When nodes are evaluated, leafs are eliminated and new ones are created instead
23:25:29 <mmorrow> Peaker: where would the GC store this info, and what datatype would it use to do so?
23:25:52 <mmorrow> (not saying that it's not possible, just curious about the scheme you have in mind)
23:26:37 <Peaker> mmorrow, Perhaps a C hash table using an intrusive linked list for the "set"
23:26:52 <mmorrow> "set" of what?
23:27:17 <Peaker> of reachable values from a value
23:27:26 <mmorrow> oh
23:27:27 <Peaker> I guess this only makes sense for values moved to the heap
23:27:54 <mmorrow> what if 2GB are reachable from the root of a particular tree?
23:28:29 <mmorrow> (and say that the ptrs for that would take up 400MB)
23:28:30 <blackdog> ouch, nasty
23:28:48 <Peaker> mmorrow, I'm not sure, how big are thunks?
23:28:54 <blackdog> i suspect GC design is like algorithmic analysis - the worst case is really important...
23:29:45 <mmorrow> Peaker: well, a thunk is {ptr-to-thunk-info-table, to-be-overwritten-slot, Either ptr (the data for an AP node)}
23:30:13 <mmorrow> an ap is {ptr-to-AP-infotab, ptr-to-code, arity, [arguments]}
23:30:26 <Peaker> arity?
23:30:32 <luite> is the old hpaste.org database stil available somewhere? (I found a link to a paste with supposedly a C++ wrapper header, but it's dead now, http://hpaste.org/1349 )
23:30:44 <mmorrow> Peaker: since GHC re-uses the same layout for a PAP
23:30:50 <copumpkin> luite: I think it just died
23:31:03 <copumpkin> luite: shapr used to run it, I think, so you might try asking him
23:31:39 <mmorrow> Peaker: so a thunk basically points to a frozen function application
23:31:41 <Peaker> mmorrow, so its about 3-5 ptrs long? Adding 2 ptrs to each thunk would be pretty expensive then, I guess
23:31:44 <luite> ah
23:31:57 <Keko> anyone know how can I stop a function if when is reading in file find \n?
23:32:38 <mmorrow> Peaker: ohh. so you're saying to add some ptr slots to each thunk which in turn point to (?) the a set of ptrs which contains all the ptrs reachable from it?
23:32:40 <Peaker> mmorrow, I don't know exactly how to "cache" traversal results, but it kind of bothers me that if a Haskell program grows in its actual use of memory, the GC time will grow proportionately, at each interval.  GC is supposed to be O(1) amortized free, right?
23:33:20 <blackdog> Keko: you could read it in lazily with getContents, then apply 'lines' to it and only evaluate the first element
23:33:38 <Peaker> mmorrow, an evaluated thunk is still a thunk, right?
23:33:41 <blackdog> Keko: hGetContents if you're reading from file, sorry
23:33:53 <mmorrow> hmm, i recall hearing something along the lines of "generational gc can be made arbitrarily cheap by increasing the size of the first-generation" somewhere, but i don't think that necessarily means constant time
23:34:16 <mmorrow> i'm not sure exactly what that statement is supposed to mean actually
23:34:59 <blackdog> mmorrow: Appel wrote about beating malloc with a massive amount of extra memory, didn't he?
23:35:08 <mmorrow> Peaker: no, when a thunk gets evaluated it gets
23:35:10 <kmc> Keko, if it finds \n you want to process only the string up to that point?
23:35:45 <Keko> right
23:35:57 <mmorrow> the infoptr of the thunk is overwritten to be the infoptr for an INDirection node, and the to-be-overwritten slot is overwritten with the ptr to the value that thunk evaluated to
23:35:59 <Peaker> surely GC algorithms have been developed further than a few minutes of toying around could improve :-)  I hope performance of programs doesn't have to degrade linearly with their memory use
23:36:37 <mmorrow> so, since the infoptr of a closure determines the type of closure it is, a thunk /becomes/ an INDirection
23:36:45 <Peaker> mmorrow, and how is the evaluated thunk used? Is its function ptr still called or is it special-cased in the user?
23:36:49 <mmorrow> and INDirections get collapsed by GC
23:36:51 <Keko> I have to use the string before the \n, and then use the other line below
23:37:24 <blackdog> mmorrow: this one, i think: http://www.cs.princeton.edu/~appel/papers/45.ps
23:37:38 <mmorrow> Peaker: any time the value at the end of that IND node is needed, it ("it" := the code needing it) follows that indirection
23:37:41 <Peaker> mmorrow, what do you mean by collapsed by GC here?
23:38:06 <Peaker> mmorrow, who tests whether a thunk is evaluated or not?
23:38:14 <mmorrow> Peaker: say we have  {CON,ptr1,ptr2,42,9437545}
23:38:20 <blackdog> mmorrow: he's got a formula showing that the cost of each GC per cell can be decreased by making the arena bigger
23:38:31 <mmorrow> where CON := ptr to some info table for a particular constructor
23:38:45 <mmorrow> and say that ptr1 points to
23:39:00 <mmorrow> {IND,ptr3}   and ptr3 is  <something>
23:39:10 <mmorrow> a copying GC will turn this into
23:39:26 <mmorrow> {CON,_,ptr3,..}
23:39:37 <mmorrow> so removing the IND node
23:39:40 <Peaker> I see
23:39:54 <mmorrow> blackdog: ahh right, that's exactly what i'm thinking of
23:40:26 <mmorrow> blackdog: ah yeah, it was wrt malloc
23:40:45 <Peaker> is it proven in practice that making allocation O(1) and freeing more expensive (copying generations around) has better performance than mark&sweep or other methods that make allocation more expensive but freeing cheaper (and perhaps even require less traversals?)
23:41:58 <mmorrow> Peaker: i'm not sure the extent to which it's formally proven in some sense, but since haskell relies so heavily on allocating massive amount of mem at really high rates, it seems like O(1) alloc is crucial
23:42:17 <Jafet> Given any strategy, there is a program that it does badly on
23:42:32 <mmorrow> and since not much of the first generation survives, you don't have to copy very much in the common case
23:42:33 <Keko> blackdog I used char1 <- hGetChar for read characters in the file and then I tried to use an if but I dont know how step to the other line if find \n
23:42:40 <Peaker> mmorrow, ghc could potentially optimize LIFO allocations to a stack or such
23:43:03 <blackdog> Keko: I think you're trying to solve the problem at too low a level
23:43:30 <blackdog> Keko: unless this is homework and your instructor has explicitly asked you to use hGetChar, you might want to take a higher-level approach.
23:43:40 <mmorrow> Peaker: yeah, iirc some compilers (ML ones iirc) do some sort of analysis that determines if particular closures can be stack allocated, and does so for those
23:44:09 <blackdog> Peaker: laziness kills you with regions
23:44:10 <mmorrow> i guess the criterion would be "non-upwardly-escaping" or something
23:44:22 <blackdog> everything escapes with laziness :)
23:45:10 <mreh> I need a function to make an array of zeros, with a single 1 in a position I specify
23:45:43 <mreh> I thought making an array of zeros and then updating is unnecessary
23:45:58 <Keko> is a homework but they didnt explain which one use
23:46:59 <luite> is there a good and relatively simple binding to some C++ library at hackage?
23:47:01 <mmorrow> Peaker: (oops, i put "ptr3" in the wrong slot in the after-gc {CON,..}, in case that was unclear)
23:47:29 <mmorrow> s/{CON,_,ptr3,..}/{CON,ptr3,_,..}/
23:47:42 <blackdog> Keko: ok. Conceptually, what you want to do is this: 1. Read the whole file, but lazily. 2. split the file up into lines. 3. do something with however many lines you actually need to use.
23:48:02 <blackdog> Keko: if you only look at the first value, you'll only read that much in, through the wonder (horror?) of lazy IO
23:48:25 <kmc> mreh, what kind of array?
23:48:40 <mreh> kmc, i don't mean array, I mean list
23:48:51 <mreh> but I am working with vectors so I might just use the monad
23:50:55 <mreh> and then poot out a list
23:52:14 <gmaslov> > fmap (+1) (1,2,3)
23:52:15 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
23:52:16 <lambdabot>    arising from a use of `GH...
23:52:31 <rasfar> mreh: could this help?
23:52:36 <jre2> anyone know a up to data and working guide for getting curl to work on windows?
23:52:36 <rasfar> replicateEachU 10 (toU [1..3]) (toU [3..5]) yields toU [3.0,4.0,4.0,5.0,5.0,5.0]
23:52:59 <mxc> mreh: if you want a list, specifically:  let l m = [ if (x == m) then 1 else 0 | x <- [1..]]
23:53:20 <rasfar> (that was from Data.Array.Vector)
23:53:24 <mxc> that would be 1-indexed.. if you want zero-indexed, replace [1..] with [0..]
23:53:40 <mreh> mxc thanks guys, you've given me an idea
23:54:27 <dmwit> > map (fromEnum . (==5)) [0..10]
23:54:29 <lambdabot>   [0,0,0,0,0,1,0,0,0,0,0]
23:54:47 <blackdog> dmwit: ah, much nicer
23:55:21 <dmwit> ?pl \m n -> map (fromEnum . (m==)) [0..n]
23:55:21 <lambdabot> (. enumFromTo 0) . map . (fromEnum .) . (==)
23:55:27 <dmwit> so readable
23:55:46 <mxc> whats ?pl?
23:55:49 <mxc> pointless?
23:55:52 <dmwit> yes
23:55:52 <Axman6> pointless
23:55:59 <Axman6> aka: pointfree
23:56:04 <blackdog> Axman6: stop, you'll hurt its feelings
23:56:09 <mxc> yeah, i liked that little pun..
23:56:13 <Axman6> it IS pointless!
23:56:24 * Axman6 declares a jihad on @pl
23:56:51 <mxc> probably doesn't apply to haskell, but was a post on JSCs ocaml blog about how point{free | less} style coding in ocaml prevents some major optimizations
23:57:42 <mxc> axman6 - pointfree is a great way to keep the steep learning curve to haskell as steep as possible...  remember, avoid success at all costs
23:59:24 <blackdog> pointfree style is nice so long as you don't take it to extremes
23:59:38 <dmwit> Pointfree style definitely has its place.
23:59:43 <dmwit> But this... is not that place. =)
